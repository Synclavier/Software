// =================================================================================// MPUtilities.c// =================================================================================// General utilities to assist with multi-processor execution// Mac OS Includes:#include <Multiprocessing.h>#include <DriverServices.h>#include <Events.h>// Local Includes:#include "MPUtilities.h"// Local prototypesstatic	void		MySynchronizeIO();// Global variableslong				MPU_num_processors;								// No. of processors availablelong				MPU_task_is_running;							// True if MP task is runninglong 				MPU_task_should_stop;							// True to terminate tasklong 				MPU_task_should_yield;							// True if task should yieldlong 				MPU_task_has_terminated;						// True if task has terminatedchar				MPU_print_out_buf[MPU_PRINT_BUF_SIZE];			// Holds chars printed from MP or TM Tasklong				MPU_print_buf_rd;								// Read pointerlong				MPU_print_buf_wr;								// Write pointervoid				(*MPU_synchronize_io)() = MySynchronizeIO;		// init in case DSL availablevoid				(*MPU_task)()           = NULL;// Local routinesstatic	void		MySynchronizeIO() {}							// null synchronize IO of no DSL available (happens using MP API on non-PCI machines)// =================================================================================// ¥ MPU_Driver// =================================================================================static	OSStatus MPU_Driver(void *)									// the MP task{		while (!MPU_task_should_stop)									// while we should not stop	{		if (MPU_task)			MPU_task();				if (MPU_task_should_yield)									// yield on single processor (e.g. using multi			MPYield();												// API on a single processor machine)	}	MPU_task_has_terminated = true;									// set termination	MPU_synchronize_io();											// publish termination status		return (0);}// =================================================================================// ¥ MP_post_output_character// =================================================================================//// Called from MP to post debug outputvoid MPU_post_output_character(char it)								// MP ONLY (!!): post a character for later output{	long	cur_write_pointer = MPU_print_buf_wr;					// get snapshot current pointer				MPU_print_out_buf[cur_write_pointer++] = it;					// store new value		if (cur_write_pointer == MPU_PRINT_BUF_SIZE)					// handle wrap		cur_write_pointer = 0;		while (cur_write_pointer == MPU_print_buf_rd)					// detect pending buffer underrun.  wait here if would loose bufferload	{		if (MPU_task_should_stop)									// toss rest of output if we should stop			return;				MPYield();													// let someone else run	}			MPU_synchronize_io();											// publish the character			MPU_print_buf_wr = cur_write_pointer;							// update write pointer				MPU_synchronize_io();											// publish the write pointer}// =================================================================================// ¥ MPU_post_output_character_from_TM_or_DT// =================================================================================//// Version of MPU_post_output_character provided to simplify debugging of time manager// and deferred task manager routines of host processor.  Only makes (good?) sense// if MP is not being used.void MPU_post_output_character_from_TM_or_DT(char it)				// host processor, from timer or deferred task{	long	cur_write_pointer = MPU_print_buf_wr;					// get snapshot current pointer				MPU_print_out_buf[cur_write_pointer++] = it;					// store new value		if (cur_write_pointer == MPU_PRINT_BUF_SIZE)					// handle wrap		cur_write_pointer = 0;		MPU_print_buf_wr = cur_write_pointer;							// update write pointer}// =================================================================================// ¥ MPU_dump_posted_MP_output_characters// =================================================================================//// Flush saved up output characters.void MPU_dump_posted_MP_output_characters(void (*out_routine)(char it)){	long	cur_write_pointer = MPU_print_buf_wr;					// get snapshot current pointer	while (MPU_print_buf_rd != cur_write_pointer)	{		long	cur_read_pointer = MPU_print_buf_rd;				// get snapshot current pointer				out_routine(MPU_print_out_buf[cur_read_pointer++]);				if (cur_read_pointer == MPU_PRINT_BUF_SIZE)			cur_read_pointer = 0;					MPU_print_buf_rd = cur_read_pointer;				MPU_synchronize_io();										// publish new read pointer for grins	}}// =================================================================================// ¥ MPU_initialize_for_mp// =================================================================================//// Initialize for MP use.void	MPU_initialize_for_mp(void (*theTask)(), long force_mp_api){	MPU_num_processors      = 0;	MPU_task_is_running     = false;	MPU_task_should_stop    = false;	MPU_task_should_yield   = false;	MPU_task_has_terminated = false;	MPU_task                = theTask;	if (MPLibraryIsLoaded())										// if MPlib is loaded	{		MPU_num_processors = MPProcessors();						// get no. of processors				if (MPU_num_processors <= 1)								// if only 1, then must yield in MP task			MPU_task_should_yield = true;							// so host gets some time...					if (SynchronizeIO != NULL)									// publish pci1_task_should_yield in case task runs when we launch it		{			MPU_synchronize_io = SynchronizeIO;						// if SynchronizeIO avail, we will use it			MPU_synchronize_io();		}				if (force_mp_api || MPU_num_processors > 1)					// if second processors available		{			OSStatus	mp_task_creation_status;					// Creation status			MPTaskID	mp_task_id = NULL;							// Task ID of MP task, which we don't bother to keep around			mp_task_creation_status = MPCreateTask(MPU_Driver, NULL, 128*1024, NULL, NULL, NULL, 0, &mp_task_id);			if (mp_task_creation_status == noErr)					// set available immediately so we can kill it				MPU_task_is_running = true;		}	}}// =================================================================================// ¥ MPU_terminate// =================================================================================//// Terminatevoid	MPU_terminate(){	if (MPU_task_is_running)	{		MPU_task_should_stop = true;				MPU_synchronize_io();				while (!MPU_task_has_terminated)							// Wait for MP task termination			SystemTask();	}			MPU_task_is_running     = false;	MPU_task_should_stop    = false;	MPU_task_should_yield   = false;	MPU_task_has_terminated = false;	MPU_task                = NULL;}