// =================================================================================//	SoundfileTranslatorAp.cp// =================================================================================//	CONTAINS: SOURCE CODE FOR CRUDE FILE SELECTOR TO TEST SOUNDFILE PARSING AND TRANSLATION ROUTINES//	REVISION HISTORY://		2000/06/04	Todd Yvega		Created.//		2000/08/28	Cameron Jones	Blended./*……………………………………………………………………  # I N C L U D E S  ……………………………………………………………………*/// MSL C#include <iostream>#include <console.h>#include <Strings.h>// Mac O/S#include <QuickTimeComponents.h>#include <Resources.h>#include <StandardFile.h>#include <MacTypes.h>#include <AIFF.h>// Local includes#include "CSynclavierSoundFileHeader.h"#include "SoundfileTranslators.h"#include "SoundDesigner.h"#include "my_sioux_prefs.h"#include "WAVE.h"using namespace std;// *** Todd: See more notes at the end of this file ***// ---------------------------------------------------------------------------//	• main// ---------------------------------------------------------------------------int main(void)						//	crude driver for opening various types of sound files{	/*	some sound file types, as defined in <QuickTimeComponents.h>		kQTFileTypeAIFF				 = FOUR_CHAR_CODE('AIFF'),		kQTFileTypeAIFC				 = FOUR_CHAR_CODE('AIFC'),		kQTFileTypeSoundDesignerII	 = FOUR_CHAR_CODE('Sd2f'),		kQTFileTypeWave				 = FOUR_CHAR_CODE('WAVE'),		kQTFileTypeAudioCDTrack		 = FOUR_CHAR_CODE('trak'),		kQTFileTypeSystemSevenSound  = FOUR_CHAR_CODE('sfil'),	*/	//	Init SIOUX output; avoids Todd's agravating stay-up-all-night StandardGetFile/sioux event loop bug	set_my_sioux_prefs();	InstallConsole(0);	// 	Test compilation settings	if (sizeof(SynclSFIndex) != 6 || sizeof(SynclSFHeader) != 3*512)	{		printf("Error: Struct sizes are incorrect.\n");				printf("   sizeof SynclSFIndex : %d\n", sizeof(SynclSFIndex ));		printf("   sizeof SynclSFHeader: %d\n", sizeof(SynclSFHeader));			return (0);	}	// 	Ask for an input file	while (1)	{		OSErr				MyOSErr = noErr;		const OSType		MyFileFilter[] = {kQTFileTypeAIFF, kQTFileTypeAIFC, kQTFileTypeSoundDesignerII, kQTFileTypeWave, kFileTypeSyncSound};		StandardFileReply	SourceFileReply;		SynclSFHeader		sf_header;		AudioDataDescriptor descriptor;				short				SourceDataForkRefNum = 0, SourceResourceForkRefNum = 0;		StandardGetFile(NULL, sizeof(MyFileFilter)/sizeof(OSType), MyFileFilter, &SourceFileReply);		if (!SourceFileReply.sfGood)			break;					cout << "\"";		printf("%#s", SourceFileReply.sfFile.name);		cout << "\" opened successfully; OSType = '";		printf("%4.4s", &SourceFileReply.sfType);		cout << "'" << endl;				//	Open both forks for grins		if (FSpOpenDF(&SourceFileReply.sfFile, fsRdPerm, &SourceDataForkRefNum))		//	open the source file's data fork - read only		{			printf("Failed: could not open data fork\n");						break;		}				//	Open resource fork; but may yield (-1) if file has no resource fork		SourceResourceForkRefNum = FSpOpenResFile (&SourceFileReply.sfFile, fsRdPerm);				//	Parse the sound file and construct the syncl sound file header as appropriate		if (SourceFileReply.sfType == kQTFileTypeAIFF)			ParseAIFFSoundFile(SourceDataForkRefNum, SourceResourceForkRefNum, descriptor, sf_header);		else if (SourceFileReply.sfType == kQTFileTypeSoundDesignerII)			ParseSd2fSoundFile(SourceDataForkRefNum, SourceResourceForkRefNum, descriptor, sf_header);				else if (SourceFileReply.sfType == kQTFileTypeWave)			ParseWAVESoundFile(SourceDataForkRefNum, SourceResourceForkRefNum, descriptor, sf_header);		else			printf("File type %4.4s cannot be processed\n", &SourceFileReply.sfType);		FSClose      (SourceDataForkRefNum);					if (SourceResourceForkRefNum != (-1))			CloseResFile(SourceResourceForkRefNum);	}				return EXIT_SUCCESS;}// *** More Notes ***// Todd: Here are some extractions from InterChange that perform an actual// translation.// They obviously work in conjunction with copying a file from a synclavier// disk to the mac or vice-versa.// Some of these routines compile as is (like OpenMacFile).  Others will// have to be re-written if you want a mac-to-mac file copy with translation.// PS: Hopefully, it's all coming in InterChange™ 2 not too long from now.// CJ/*--------------------------------------------------------------------------*//*	Missing pieces/*--------------------------------------------------------------------------*/// These stubs relate to reading and writing synclavier disks and would// have to be implemented for a mac-to-mac file copy with translation#define COPY_BUFFER_SIZE	(256*1024)static	Boolean	import_as_aiff = true;				// Global variables control what style we import asstatic	Boolean import_as_sd2f = false;static	Boolean import_as_wave = false;static	short WriteAbleDisk(UInt16	scsi_id, void* out_buf, UInt32 block_num, UInt32 num_blocks){	#pragma unused (scsi_id)	#pragma unused (out_buf)	#pragma unused (block_num)	#pragma unused (num_blocks)	printf("WriteAbleDisk: needs to be written\n");	return (-1);}static	short ReadAbleDisk(UInt16	scsi_id, void* out_buf, UInt32 block_num, UInt32 num_blocks){	#pragma unused (scsi_id)	#pragma unused (out_buf)	#pragma unused (block_num)	#pragma unused (num_blocks)	printf("ReadAbleDisk: needs to be written\n");	return (-1);}static	void	run_host_environment_250(){	// Chill...  InterChange™ runs the Mac (e.g. GetNextEvent...) from it's version of run_host_environment_250}/*--------------------------------------------------------------------------*//*	OpenMacFile																*//*--------------------------------------------------------------------------*/typedef struct						// handy struct for accessing a mac file{	short		MacFRefNum;			// file reference number	short		MacRRefNum;			// resource fork file ref num (-1 if not open; opened for Sd2f files only)	long		MacFileLen;	OSType		MacFileTyp;	OSType		MacFileCre;	long		blocks_allocated;}   mac_file_info;static int OpenMacFile(const FSSpec *the_spec, mac_file_info *the_info, const char *error_name){	OSErr	FSstatus;	FInfo	info;		// Init	the_info->MacFRefNum = 0;	the_info->MacRRefNum = -1;	the_info->MacFileLen = 0;	the_info->MacFileTyp = 0;	the_info->MacFileCre = 0;	the_info->blocks_allocated = 0;		// Make an FSSpec for the file	if ((FSstatus = FSpOpenDF    (the_spec, fsRdPerm, &the_info->MacFRefNum)) != 0)		{printf("OpenMacFile: Could not open \"%s\" (%d)\n", error_name, FSstatus); return (-1);}		if ((FSstatus = GetEOF       (the_info->MacFRefNum, &the_info->MacFileLen)) != 0)		{printf("OpenMacFile: Could not get length of \"%s\" (%d)\n", error_name, FSstatus); FSClose(the_info->MacFRefNum); the_info->MacFRefNum = 0; return (-1);}	if ((FSstatus = FSpGetFInfo  (the_spec, &info)) != 0)		{printf("OpenMacFile: Could not get file type info for \"%s\" (%d)\n", error_name, FSstatus); FSClose(the_info->MacFRefNum); the_info->MacFRefNum = 0; return (-1);}	the_info->MacFileTyp = info.fdType;	the_info->MacFileCre = info.fdCreator;		// Open res fork for Sd2 files	if (the_info->MacFileTyp == SD2FileType)		the_info->MacRRefNum = FSpOpenResFile (the_spec, fsRdPerm);	return (0);}static	void	CloseMacFile(mac_file_info& the_info){	if (the_info.MacFRefNum)		{FSClose(the_info.MacFRefNum); the_info.MacFRefNum = 0;}			if (the_info.MacRRefNum != 0 && the_info.MacRRefNum != -1)		{CloseResFile(the_info.MacRRefNum); the_info.MacRRefNum = 0;}}/*--------------------------------------------------------------------------*//*	ComputeSoundFileSize											        *//*--------------------------------------------------------------------------*//* returns Able word length of a Mac sound file */static unsigned long ComputeSoundFileSize(short our_ref_num, short res_ref_num, const char *error_name, unsigned long type){	SynclSFHeader		header;	AudioDataDescriptor	descriptor;	if (type == AIFFID)	{		if (ParseAIFFSoundFile(our_ref_num, res_ref_num, descriptor, header))			{printf("ComputeSoundFileSize: File \"%s\" cannot be analyzed\n", error_name); return (-1);}	}		else if (type == SD2FileType)	{		if (ParseSd2fSoundFile(our_ref_num, res_ref_num, descriptor, header))			{printf("ComputeSoundFileSize: File \"%s\" cannot be analyzed\n", error_name); return (-1);}	}	else if (type == WAVEID)	{		if (ParseWAVESoundFile(our_ref_num, res_ref_num, descriptor, header))			{printf("ComputeSoundFileSize: File \"%s\" cannot be analyzed\n", error_name); return (-1);}	}		else		{printf("ComputeSoundFileSize: File \"%s\" cannot be converted\n", error_name); return (-1);}	unsigned long out_words = (header.total_data.sector << 8) + (3*256);	return (out_words);}/*--------------------------------------------------------------------------*//*	ExportSoundFileFile											            *//*--------------------------------------------------------------------------*/static int ExportSoundFileFile(UInt16 scsi_id, UInt32 block_num, short our_ref_num, short res_ref_num, UInt32 type){	SynclSFHeader		header;	AudioDataDescriptor	descriptor;	char				*in_buf  = NULL;	UInt16				*out_buf = NULL;	Handle				in_buf_handle  = NULL;	Handle				out_buf_handle = NULL;	OSErr				FSstatus;	if (type == AIFFID)	{		if (ParseAIFFSoundFile(our_ref_num, res_ref_num, descriptor, header))			return (-1);	}		else if (type == SD2FileType)	{		if (ParseSd2fSoundFile(our_ref_num, res_ref_num, descriptor, header))			return (-1);	}	else if (type == WAVEID)	{		if (ParseWAVESoundFile(our_ref_num, res_ref_num, descriptor, header))			return (-1);	}		else		{printf("ExportSoundFileFile: Missing translator\n"); return (-1);}	UInt32 out_words = (header.total_data.sector << 8) + (3*256);	block_num = block_num & 0x00FFFFFF;		in_buf_handle  = NewHandle(COPY_BUFFER_SIZE);	out_buf_handle = NewHandle(COPY_BUFFER_SIZE);		if (in_buf_handle)		in_buf = (char *) *in_buf_handle;			if (out_buf_handle)		out_buf = (UInt16 *) *out_buf_handle;			if (!in_buf_handle || !in_buf || !out_buf_handle || !out_buf)		{printf("ExportSoundFileFile: out of memory for sound file export\n"); DisposeHandle(in_buf_handle); DisposeHandle(out_buf_handle); return (-1);}			if ((FSstatus = SetFPos(our_ref_num, fsFromStart, descriptor.start_pos_in_file)) != 0)		{printf("ExportSoundFileFile: Failed SetFPos (%d)\n", FSstatus); DisposeHandle(in_buf_handle); DisposeHandle(out_buf_handle); return (-1);}		// Copy and synthesize file as needed	long	write_ptr = 0;				// word pointer to write file	long	read_ptr  = 0;				// byte pointer to read file (data area only)	long	samples_to_copy  = descriptor.frames_per_file * descriptor.samples_per_frame;	long    bytes_to_copy    = descriptor.byte_len_in_file;	long    bytes_per_sample = descriptor.bits_per_sample / 8;	// Write entire file	while (write_ptr < out_words)	{		long	chunk_words = out_words - write_ptr;			// assume rest of file will fit in this buffer		long	write_where = 0;								// init word pointer into output bufer		long	chunk_left;		if (chunk_words > (COPY_BUFFER_SIZE>>1))				// limit to buffer size			chunk_words = COPY_BUFFER_SIZE>>1;				chunk_left = chunk_words;								// number of samples needed to fill out this chunk		// Stuff sound file header into output buffer.  Here is the 1 place we advance read pointer without advancing write pointer		if ((read_ptr == 0) && ((write_ptr + write_where) == 0))		{			memcpy(out_buf, &header, 3*256*2);					// copy sound file header all bytes						write_where += (3*256);								// advance word pointer to output buffer; samples will go here			chunk_left  -= (3*256);								// reduce samples needed to fill buffer		}				// Get and expand audio data		while (chunk_left)										// fill out chunk's worth of data (to end of buffer or end of file)		{			// Fetch audio data if any			if (samples_to_copy != 0)							// get more samples if any.  Note we (gracefully) stop if we run out of data in the file.			{				long	samples_to_read = chunk_left;						// assume all data needed in output buffer will fit in read buffer				long	bytes_of_data   = samples_to_read * bytes_per_sample;								if (bytes_of_data > COPY_BUFFER_SIZE)						// limit to what will fit in read buffer				{					samples_to_read = COPY_BUFFER_SIZE   / bytes_per_sample;// watch for round-down due to 3 bytes per sample					bytes_of_data   = samples_to_read * bytes_per_sample;				}				if (samples_to_read > samples_to_copy)						// also limit to samples left to copy				{					samples_to_read = samples_to_copy;						// assume 16-bit source data and all will fit					bytes_of_data   = samples_to_read * bytes_per_sample;				}								if (bytes_of_data > bytes_to_copy)							// also limit to valid				{					samples_to_read = bytes_to_copy   / bytes_per_sample;	// watch for round-down due to 3 bytes per sample					bytes_of_data   = samples_to_read * bytes_per_sample;				}									if (samples_to_read == 0)									// detect weird case of not enough bytes to finish last sample				{					samples_to_copy = 0;					bytes_to_copy   = 0;					continue;				}								else				{					long count = bytes_of_data;										probably byte swapping to do here...					// Read 16-bit big-endian data directly into output buffer to avoid copy					if (bytes_per_sample == 2 & !descriptor.bytes_need_swizzling)					{						if (((FSstatus = FSRead(our_ref_num, &count, (void *)&out_buf[write_where])) != 0)						||  (count != bytes_of_data))							{printf("ExportSoundFileFile: Failed FSRead (%d)\n", FSstatus); DisposeHandle(in_buf_handle); DisposeHandle(out_buf_handle); return (-1);}					}										// Else read and tweak the bytes					else					{						long   loop;						char   *source_chars;						SInt16 *source_fixeds;						long   *source_longs;						SInt16 *dest_data;												if (((FSstatus = FSRead(our_ref_num, &count, (void *)in_buf)) != 0)						||  (count != bytes_of_data))							{printf("ExportSoundFileFile: Failed FSRead (%d)\n", FSstatus); DisposeHandle(in_buf_handle); DisposeHandle(out_buf_handle); return (-1);}											if (bytes_per_sample == 1 && !descriptor.bytes_need_swizzling)			// 8-bit Sd2f & AIFF						{							source_chars = (char   *) in_buf;							dest_data    = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data;							while (loop)								{*dest_data++ = ((SInt16) (*source_chars++)) << 8; loop--;}						}												else if (bytes_per_sample == 1 && !descriptor.bytes_need_swizzling)		// 8-bit WAVE						{							source_chars = (char   *) in_buf;							dest_data    = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data;							while (loop)								{*dest_data++ = ((SInt16) (*source_chars++ ^ 128)) << 8; loop--;}						}												else if (bytes_per_sample == 2)								// 16-bit swizzled (non_swizzled handled above)						{							source_fixeds = (SInt16 *) in_buf;							dest_data     = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data / 2;							while (loop)								{*dest_data++ = Endian16_Swap(*source_fixeds); source_fixeds++; loop--;}						}												else if (bytes_per_sample == 3 && !descriptor.bytes_need_swizzling)				// 24-bit data						{							source_fixeds = (SInt16 *) in_buf;							dest_data     = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data / 3;							while (loop)								{*dest_data++ = *source_fixeds; source_fixeds = (SInt16 *) (((char *) source_fixeds) + 3); loop--;}						}						else if (bytes_per_sample == 3 &&  descriptor.bytes_need_swizzling)						{							source_fixeds = (SInt16 *) (in_buf + 1);							dest_data     = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data / 3;							while (loop)								{*dest_data++ = Endian16_Swap(*source_fixeds); source_fixeds = (SInt16 *) (((char *) source_fixeds) + 3); loop--;}						}						else if (bytes_per_sample == 4 && !descriptor.bytes_need_swizzling)						{							source_longs = (long  *) in_buf;							dest_data    = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data / 4;							while (loop)								{*dest_data++ = *source_longs++ >> 16; loop--;}						}						else if (bytes_per_sample == 4 &&  descriptor.bytes_need_swizzling)						{							source_fixeds = (SInt16 *) (in_buf + 2);							dest_data     = (SInt16 *) &out_buf[write_where];							loop = bytes_of_data / 4;							while (loop)								{*dest_data++ = Endian16_Swap(*source_fixeds); source_fixeds = (SInt16 *) (((char *) source_fixeds) + 4); loop--;}						}					}															samples_to_copy -= samples_to_read;				// few samples to copy from source file					bytes_to_copy   -= bytes_of_data;				// few bytes of data available in source file					read_ptr        += bytes_of_data;				// advance (unused) read_ptr position in source file					write_where     += samples_to_read;				// advance where we write in output buffer					chunk_left      -= samples_to_read;				// reduce samples left needed to fill output buffer										continue;				}			}						// Else synth zeroes to fill out last sector			memset(&out_buf[write_where], 0, chunk_left << 1);			write_where += chunk_left;			chunk_left = 0;		}				if (WriteAbleDisk(scsi_id, out_buf, block_num + (write_ptr >> 8), chunk_words >> 8))			{printf("ExportSoundFileFile: failed WriteAbleDisk\n"); DisposeHandle(in_buf_handle); DisposeHandle(out_buf_handle); return (-1);}				write_ptr += chunk_words;		run_host_environment_250();	}	DisposeHandle(in_buf_handle );	DisposeHandle(out_buf_handle);	in_buf_handle  = NULL; in_buf  = 0;	out_buf_handle = NULL; out_buf = 0;		return (0);}/*--------------------------------------------------------------------------*//*	ImportAbleSoundFile														*//*--------------------------------------------------------------------------*/static int ImportAbleSoundFile(UInt16 scsi_id, UInt32 block_num, UInt32 num_words,                              char *file_name, short vol_ref_num, long dir_id, char *tree_name){	UInt32	 			i,j,k;	UInt16				*in_buf = NULL;	Handle				in_buf_handle = NULL;	OSErr				FSstatus;	long				count;	long				file_length;	short				our_ref_num = 0;	short				our_res_num = (-1);	UInt32				chunk_blocks = COPY_BUFFER_SIZE/512;	char				pas_name[64];	SynclSFHeader		sf_header;	AudioDataDescriptor	descriptor;	 	strcpy(pas_name, file_name);				// get working copy of file name		if (pas_name[0] == '.')						// map leading . to • to avoid		pas_name[0] = '•';						// mac os conflict with devices	c2pstr(pas_name);							// get in pascal format	in_buf_handle = NewHandle(COPY_BUFFER_SIZE);		if (in_buf_handle)		in_buf = (UInt16 *) *in_buf_handle;			if (!in_buf_handle || !in_buf)		{printf("ImportAbleSoundFile: out of memory for data file buffer\n"); DisposeHandle(in_buf_handle); return (-1);}			/* Create output file: */	if      (import_as_aiff) FSstatus = HCreate(vol_ref_num, dir_id, (UInt8 *) pas_name, 'TVOD', 'AIFF');	else if (import_as_sd2f) FSstatus = HCreate(vol_ref_num, dir_id, (UInt8 *) pas_name, 'TVOD', 'Sd2f');	else if (import_as_wave) FSstatus = HCreate(vol_ref_num, dir_id, (UInt8 *) pas_name, 'TVOD', 'WAVE');	else                     FSstatus = HCreate(vol_ref_num, dir_id, (UInt8 *) pas_name, 'SNCL', 'SNDF');		if (FSstatus)	{		if (FSstatus == dupFNErr)			{printf("ImportAbleSoundFile: Can't import %s; it already exists\n", tree_name); DisposeHandle(in_buf_handle); return (-1);}		else			{printf("ImportAbleSoundFile: Failed HCreate (%d)\n", FSstatus); DisposeHandle(in_buf_handle); return (-1);}	}	if (import_as_sd2f)		HCreateResFile(vol_ref_num, dir_id, (UInt8 *) pas_name);	if ((FSstatus = HOpen(vol_ref_num, dir_id, (UInt8 *) pas_name, fsRdWrPerm, &our_ref_num)) != 0)		{printf("ImportAbleSoundFile: Failed HOpen (%d)\n", FSstatus); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}		if (import_as_sd2f)		our_res_num = HOpenResFile(vol_ref_num, dir_id, (UInt8 *) pas_name, fsRdWrPerm);		if (num_words <= 3*256)	{		printf("ImportAbleSoundFile: Can't import %s; it is too short to be a sound file\n", tree_name);		FSClose(our_ref_num);		if (our_res_num != (-1)) CloseResFile(our_res_num);		HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name);		DisposeHandle(in_buf_handle);		return (-1);	}			// Read in sound file header	if (ReadAbleDisk(scsi_id, in_buf, block_num, sizeof(SynclSFHeader) / 512))		{FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}		memcpy(&sf_header, in_buf, 3*256*2);					// copy sound file header all bytes	memset(&descriptor, 0, sizeof(descriptor));				// init desriptor	// Handle old SF headers as per ps.load	if (sf_header.compatibility < 0)		sf_header.compatibility = 0;	if (sf_header.stereo != 0 && sf_header.stereo != 1)	{		printf("ImportAbleSoundFile: Can't import %s; it contains invalid data\n", tree_name);		FSClose(our_ref_num);		if (our_res_num != (-1)) CloseResFile(our_res_num);		HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name);		DisposeHandle(in_buf_handle);		return (-1);	}		if (sf_header.sample_rate == 0)	{		if (sf_header.compatibility < 1)			sf_header.period_index = 600;					if (sf_header.period_index < 300)			sf_header.period_index = 300;	}			// Import all valid data	if (1)	{		descriptor.byte_len_in_file = (sf_header.valid_data.sector << 9) + (sf_header.valid_data.word_offset << 1);				if (descriptor.byte_len_in_file > ((num_words - 3*256) << 1))			descriptor.byte_len_in_file = ((num_words - 3*256) << 1);					if (0)		{			// Could also extract mark start to mark end		}	}	// Else could just use length of file; but may contain bogus data at end		else		descriptor.byte_len_in_file  = (num_words - 3*256) << 1;		descriptor.start_pos_in_file = 0;						// init start pos to 0; will be set correctly by appropriate Compute....SoundFileSize routine below	if (import_as_wave)		descriptor.bytes_need_swizzling = true;	else		descriptor.bytes_need_swizzling = false;		descriptor.bits_per_sample   = 16;	descriptor.samples_per_frame = sf_header.stereo+1;	descriptor.frames_per_file   = descriptor.byte_len_in_file / descriptor.samples_per_frame / 2;		if (sf_header.sample_rate == 0 && sf_header.period_index != 0)		descriptor.frames_per_second = 30000000.0 / ((double) sf_header.period_index);	else		descriptor.frames_per_second = ((double) sf_header.sample_rate)*100.0;	if      (import_as_aiff) file_length = ComputeAIFFSoundFileSize(sf_header, descriptor);	else if (import_as_sd2f) file_length = ComputeSd2fSoundFileSize(sf_header, descriptor);	else if (import_as_wave) file_length = ComputeWAVESoundFileSize(sf_header, descriptor);	else file_length = num_words << 1;	count = file_length;		if ((FSstatus = Allocate(our_ref_num, &count)) != 0)	{		printf("ImportAbleSoundFile: Failed Allocate (%d)\n", FSstatus);		printf("   Your hard drive may be out of storage or may be read-only\n");		FSClose(our_ref_num);		if (our_res_num != (-1)) CloseResFile(our_res_num); 		HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name);		DisposeHandle(in_buf_handle);		return (-1);	}	if ((FSstatus = SetFPos(our_ref_num, fsFromStart, 0)) != 0)		{printf("ImportAbleSoundFile: Failed SetFPos (%d)\n", FSstatus); FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}			// Write info	int	xfer_limit;	if      (import_as_aiff)	{		if (CreateAIFFSoundFile(our_ref_num, our_res_num, descriptor, sf_header))			{FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}		i = 3*256;							// audio data starts here		xfer_limit = i + (descriptor.byte_len_in_file >> 1);	}		else if (import_as_sd2f)	{		if (CreateSd2fSoundFile(our_ref_num, our_res_num, descriptor, sf_header))			{FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}		i = 3*256;							// copy rest of data		xfer_limit = i + (descriptor.byte_len_in_file >> 1);	}		else if (import_as_wave)	{		if (CreateWAVESoundFile(our_ref_num, our_res_num, descriptor, sf_header))			{FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}		i = 3*256;							// copy rest of data		xfer_limit = i + (descriptor.byte_len_in_file >> 1);	}		else	{		i = 0;								// else copy entire sound file using loop below; pray swizzle == 0!		xfer_limit = num_words;	}		while (i < xfer_limit)					// loop over words to copy	{		j = (xfer_limit - i + 255) >> 8;	// number of blocks remaining in file		if (j > chunk_blocks)				// limit to size of buffer			j = chunk_blocks;				if (ReadAbleDisk(scsi_id, in_buf, block_num + (i >> 8), j))			{FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}			// Swizzle bytes if we need to		if (descriptor.bytes_need_swizzling)		{			long	loop  = j * 256;			SInt16* where = (SInt16*) &in_buf[0];						while (loop)				{*where++ = Endian16_Swap(*where); loop--;}			}				count = j << 9;							// get total number of bytes read in				if (count > ((xfer_limit - i) << 1))	// if more than needed to fill out the file			count = (xfer_limit - i) << 1;		// limit to valid data or mark start computed above					k = count;				swap?		if (((FSstatus = FSWrite(our_ref_num, &count, (void *)in_buf)) != 0)		||  (count != k))			{printf("ImportAbleSoundFile: Failed FSWrite (%d)\n", FSstatus); FSClose(our_ref_num); if (our_res_num != (-1)) CloseResFile(our_res_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}			i += (count >> 1);				run_host_environment_250();	}		if ((FSstatus = SetEOF(our_ref_num, file_length)) != 0)		/* set length 		*/		{printf("ImportAbleSoundFile: Failed SetEOF (%d)\n", FSstatus); if (our_res_num != (-1)) CloseResFile(our_res_num); FSClose(our_ref_num); HDelete(vol_ref_num, dir_id, (UInt8 *) pas_name); DisposeHandle(in_buf_handle); return (-1);}	if (our_res_num != (-1)) CloseResFile(our_res_num);		if ((FSstatus = FSClose(our_ref_num)) != 0)		{printf("ImportAbleSoundFile: Failed FSClose (%d)\n", FSstatus); DisposeHandle(in_buf_handle); return (-1);}		DisposeHandle(in_buf_handle);		in_buf_handle = NULL; in_buf = NULL;		return (0);}// Here's how InterChange™ actually performs an export (e.g. mac file to synclav hard drive)#if 0	if ((FSstatus = OpenMacFile(&temp_spec, &CurrentExportFile, this_mac_name)) != 0)		... could not open mac file for exporting to synclav	else if (ExportMacFile(&temp_spec, &CurrentExportFile, this_mac_name, this_able_name, temp_name, 1))	{		... failed copy or translation		CloseMacFile(&CurrentExportFile);	}	else		CloseMacFile(&CurrentExportFile);#endif// Here's how InterChange™ actually performs an import (e.g. synclav hard drive to mac)#if 0	if (ImportAbleSoundFile(SCSI_id, block_num, word_len,					        destination_entity_name, TopImportFolderFSSpec.vRefNum, TopImportFolderFSSpec.parID, import_full_mac_name))		... failed import#endif