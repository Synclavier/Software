// ==========================================================================//	SoundDesigner.h// ==========================================================================// Contents: STRUCTURE DEFINITIONS FOR SDI AND SDII SOUND FILE FORMATS// REVISION HISTORY://		2000/06/04	Todd Yvega		Created.//		2000/08/28	Cameron Jones	Blended.#pragma once// Mac O/S Includes...#include <MacTypes.h>// --------------------------------------------------------------------------//	¥ Constants// --------------------------------------------------------------------------#define SD1_HEADER_SIZE	= 1336// --------------------------------------------------------------------------//	¥ Enumerations// --------------------------------------------------------------------------//	file type and resource type codesenum {	SD1FileType	= FOUR_CHAR_CODE('SFIL'),	SD2FileType	= FOUR_CHAR_CODE('Sd2f')};enum {	STR_ResType				= FOUR_CHAR_CODE('STR '),	SD2Loops_ResType		= FOUR_CHAR_CODE('sdLL'),	SD2Markers_ResType		= FOUR_CHAR_CODE('sdML'),	SD2DocumentData_ResType	= FOUR_CHAR_CODE('sdDD')};//	loop sense valuesenum {	SD2ForwardLooping			= 117,	SD2ForwardBackwardLooping	= 118};// --------------------------------------------------------------------------//	¥ Sound Designer I File Format// --------------------------------------------------------------------------/*Digidesign sez...Sound Designer I file format is the original Digidesign sound file format first released in 1985.  It is widely used and supported as evidenced by the many CD ROM discs with sound effects stored in this format.  It is primarily used to store mono 16 bit short duration (on the order of seconds) audio samples.  We recommend that you support this format for short sounds, but that you use Sound Designer II format as a primary format due to its flexibility.File Type: 'SFIL'Resource ForkThe resource fork is not used.Data ForkThe first 1336 bytes of the data fork contain the sound header (see the C struct "HeaderType" below -TY) followed by the sample data itself.  Default values are given in () within the comment next to a field.  Byte offsets are indicated to the left at various offsets.  Fields with the comment "DO NOT USE" are for SoundDesigner internal use and should not be changed except when initializing the file.  The size of the data types are detailed in Inside Macintosh, Volume 1, page 86.*///	Simulate Pascal user-defined ordinal typesenum SideType   {leftSide, rightSide};enum ScaleNames {Time, SampleNumber, HexSampNum, Volts, Percent, dbm, User};enum ModeType	{Select, Draw, ZoomSelect};//	The following pragma forces the same alignment as in the original Pascal structures.// Make sure to reset it at the end of this file or things could get really ugly!#pragma pack(2)struct MarkerType{	Byte				Pad;					//	(needed due to the difference between C++ bool and Pascal Boolean)	bool				Free;					//	TRUE if this marker is free for use (TRUE/1)	long				Position;				//	byte position in file (0)	unsigned char	Name[33];					//	name of the marker ("Untitled")};struct EditRecord{	long				HiAddr;					//	DO NOT USE (0)	long				LoAddr;					//	DO NOT USE (0)	SideType			ExtendSide;				//	DO NOT USE (0)};struct ZoomType{	short				v;						//	vertical scale factor: (-256)												//		positive = magnification, negative = reduction	long				h;						//	horizontal scale factor: (1)												//		positive = magnification, negative = reduction};struct ScaleType{	long				VFactor;				//	scale factor for vertical axis tick units: (327)												//		positive = magnification, negative = reduction	ScaleNames			VType;					//	type of vertical axis tick mark unit (4)	unsigned char		VString[33];			//	vertial axis tick units string ("%Scale")	long				HFactor;				//	scale factor for horizontal axis tick units: (1)												//		positive = magnification, negative = reduction	ScaleNames			HType;					//	type of horizontal axis tick mark unit (0)	unsigned char		HString[33];			//	horizontal axis tick units string: ("sec")												//		µsec, msec, sec, samples};struct HeaderType{	short				HeaderSize;				//	size in bytes of the file header (1336)	short				Version;				//	DO NOT USE (32)	Byte				Pad_0004;				//	(needed due to the difference between C++ bool and Pascal Boolean)	bool				Preview;				//	DO NOT USE (0)	WindowPtr			WPtr;					//	DO NOT USE (0)	void*				WPeek;					//	DO NOT USE (0)	long				HInxPage;				//	DO NOT USE (0)	long				HInxLine;	long				VInxPage;				//	DO NOT USE (0)	long				VInxLine;	long				HCtlPage;				//	DO NOT USE (0)	long				HCtlLine;	long				VCtlPage;				//	DO NOT USE (0)	long				VCtlLine;	long				VOffset;				//	position of vertical center of window 												//		in quantization units ie -32768 to 32767 (0)	long				HOffset;				//	position of left edge of sample window 												//		in #SAMPLES (0)	short				VOffConst;				//	DO NOT USE (0)	ZoomType			Zoom;					//	see above	ScaleType			Scale;					//	see above	short				VScrUpdate;				//	DO NOT USE (0)	Ptr					BufPtr;					//	DO NOT USE (0)	Size				BufBytes;				//	DO NOT USE (0)	long				BufOffset;				//	DO NOT USE (0)	RgnHandle			WaveRgn;				//	DO NOT USE (0)	RgnHandle			ClipArea;				//	DO NOT USE (0)	RgnHandle			ScaleArea;				//	DO NOT USE (0)	Rect				CtlWidth;				//	DO NOT USE (0)	ControlHandle		VScroll;				//	DO NOT USE (0)	ControlHandle		HScroll;				//	DO NOT USE (0)	Size				FileSize;				//	2 * number of samples in this file												//		ie number of bytes of sound data	unsigned char		BUName[65];				//	name of edit backup file	unsigned char		FileName[65];			//	name of this file (Mac Filename)	short				BURefNum;				//	DO NOT USE (0)	short				refNum;					//	DO NOT USE (0)	short				vRefNum;					//	DO NOT USE (0)	Byte				Pad_0320;				//		bool				BufChanged;				//	DO NOT USE (0)	Byte				Pad_0322;				//		bool				FileChanged;			//	DO NOT USE (0)	Byte				Pad_0324;				//		bool				NoBackup;				//	DO NOT USE (0)	ModeType			Mode;					//	DO NOT USE (0)	Byte				Pad_0327;				//		EditRecord			Edit;					//	see above	long				CursorPos;				//	cursor position relative to window start (0)	RgnHandle			CursorRgn;				//	cursor region in which it can be grasped (0)	MarkerType			MarkerData[10];			//	see above	long				MarkerOffset;			//	offset to get relative time (0)	long				LoopStart;				//	starting byte # of loop (-1)	long				LoopEnd;				//	ending byte # of loop (-1)	Byte				Pad_0758;				//		bool				ZeroLineOn;				//	(FALSE/0)	Byte				Pad_0760;				//		bool				CursorOn;				//	(FALSE/0)	Byte				Pad_0762;				//		bool				ScalesOn;				//	(FALSE/0)	Str255				Comment;				//	file comment (" ")	long				SampRate;				//	sample rate in hertz ie 44100	long				SampPeriod;				//	sample period in microseconds	short				SampSize;				//	number of bits in a sample (16)	unsigned char		CodeType[34];			//	type of sample data ("Linear")	Str255				UserStr1;				//	for user comments or reserved for future	Size				BufSize;				//	size of the RAM wave buffer in bytes	long				Loop2Start;				//	release loop start in bytes (-1)	long				Loop2End;				//	release loop end in bytes (-1)	SignedByte			Loop1Type;				//	type of loop: 1 = forward, 2 = forward/backward	SignedByte			Loop2Type;				//	type of loop: 1 = forward, 2 = forward/backward	short				User4;					//	DO NOT USE (0)};	//	end of struct HeaderType/*Digidesign sez...Header NotesIntegers (2 bytes) and LongInts (4 bytes) are stored in Motorola 68000 format with the most significant bytes stored first, followed by the least significant bytes.  For example, to store the hexadecimal value 0123 4567 as a LongInt, we would store in ASCENDING memory locations: 01, 23, 45, 67.  Leading zeros must be considered as part of the number.The total length of the header is 1336 bytes.  It is the first thing in the file, so if a file is rewound to an offset of 0 from the beginning of the file, the file position marker will be pointing to the first byte in the header.If a default value is given for a variable in the header, it MUST be set to that value when creating the header for the first time.  All default values for numeric data in the header are given in DECIMAL.  A header variable with the comment "DO NOT USE" should be set to its default value when creating a file, and under no circumstances used otherwise.The notation for strings in the Macintosh is STR[NN] where NN is the length in bytes of the string.  The actual string stored in memory or the header will have one extra byte preceding it.  This byte contains the length of the string, NN.  For example to store a STR[32] in the header, the first byte will be 32 (decimal), followed by 32 bytes of ASCII representing the string.  A string constant is specified above by using quote marks ie "".  DO NOT include the quote marks as part of the string itself.  Note that the string values in the header give the MAXIMUM length of that string variable.  If you wish to use a string which is shorter (and you usually will), then the first byte of that string should give the actual number of ASCII characters in the string you wish to use.  For example, although FileName is specified as a STR[64], you may wish to use less characters for a filename.  If you wish to use "New File" as the filename, you would store the byte 08 (ie the length not including the length byte itself) followed by the ASCII values for the characters in the string "New File".  The byte 08 says that there are 8 bytes in the string itself.End addresses, such as Loop End addresses are the address of the first byte AFTER the last byte IN THE LOOP.  They DO NOT refer to the last byte of the loop.  Start addresses, however, refer to the first byte of a selection.There are currently no user bytes available in the header for independent use.  This does not preclude the possibility that there will be some date, however at this time you must assume that no bytes in the header may be used for any purpose other than described above.  All bytes which are NOT listed above are reserved for use exclusively by Digidesign Inc. until further notice.*/// --------------------------------------------------------------------------//	¥ Sound Designer II File Format// --------------------------------------------------------------------------//	Note: some of the SDII structures below use types defined above under "SDI data structures"/*Digidesign sez...Sound Designer II files store all sound samples in the data fork and all sound parameters in the resource fork.  This is extremely convenient for sound data where the data fork may grow to a hundred megabytes or more.  Regardless of the size of the data fork you can add, delete, and modify sound parameters at will without compacting the sound data or moving it around the disk (an extremely time consuming procedure if the file is 100 MB).  In addition, you may add your own parameters to a file (as long as their resource types don't conflict with Sound Designer II's) while allowing the file to be read by both Sound Designer and your program.  We recommend that developers standardize on the Sound Designer II file format as the primary format due to its customizability.  For multi-track operations, we recommend that each track be recorded in a separate single mono Sound Designer II file using stereo Sound Designer II files as the mastering medium.File Type: 'Sd2f'Resource ForkThe resource fork contains many different kinds of resources which specify everything from the sample rate to loop points to graphic eq settings.  Most of these are application-specific to Sound Designer II.  There are three core parameters/rsrcs in an SDII file:Type: 'STR '   ID: 1000   Name: "sample-size"Value: Integer numeric string specifying the number of bytes per sample		 (ie 2 for standard 16 bit samples).Type: 'STR '   ID: 1001   Name: "sample-rate"Value: Floating point numeric string specifying the sample rate in hertz of the file		 (ie '44100.0000' for a standard 44.1 kHz sample rate file).Type: 'STR '   ID: 1002   Name: "channels"Value: Integer numeric string specifying the number of channels in the file		 (ie 2 for stereo).The above resources are all that are specifically required in an SDII file.  Given only these three parameters, Sound Designer II can read in and play the file.  If your program modifies the sound data or above 'STR ' resources in any way, it is your responsibility to delete any other resources that may have become out of sync with the file.  This can happen if you delete a large section of the file without updating the playlist pointers.  Notice that the length of the file is not stored.  This is because you can derive the length given the sample size, number of channels, and the length in bytes of the data fork (using file system calls) using the following formulas:Length of file (in sample frames) = Length of data fork / (number of channels * sample size)Length of file (in seconds) = (Length of data fork / (number of channels * sample size) ) / sample rateOther Parameter/Resource TypesThe following resources store file information used by Sound Designer II for various advanced playback and processing.  Unlike the above core parameters, these are stored as Pascal RECORD structures written out to resources.  (Therefore they are defined by the corresponding C structures below. -TY)  Default values are given in () within the comment next to a field.  Byte offsets are indicated to the left at various offsets.  Fields with the comment DO NOT USE are for Sound Designer internal use and should not be changed except when initializing the file.  The size of the data types are detailed in Inside Macintosh, Volume 1, page 86.*///	Type: 'sdLL'   ID: 1000//	Use: Stores a list of audio loops (commonly used with samplers).//	Structure: Variable - See SD2LoopsRecord as defined below.struct LoopRecord{	long				LoopStart;				//	reference to start sample frame of this loop	long				LoopEnd;				//	reference to end sample frame of this loop	short				LoopIndex;				//	identifies which loop this is (1..NumLoops)	short				LoopSense;				//	117=foward loop, 118=backwards/forwards loop	short				Channel;				//	channel which loop is on (0..NumChannels-1)};struct SD2LoopsRecord{	short				Version;				//	version/format of this resource(1)	short				HScale;					//	DO NOT USE (0)	short				VScale;					//	DO NOT USE (0)	short				NumLoops;				//	number of LoopRecords to follow	LoopRecord			LoopRecords[1];			//	variable length array};//	Type: 'sdML'   ID: 1000//	Use: Stores a list of text and numeric markers.//	Structure: Variable - See SD2MarkersRecord as defined below.struct MarkerRecord{	short				MarkerType;				//	1 = numbered marker, 2 = text marker (1)	short				MarkerTypeDup;			//	DUPLICATE of previous value - for historical reasons	long				Position;				//	sample frame in file	long				Text;					//	DO NOT USE (0)	short				CursorID;				//	24430 = numeric, 3012 = text (24430)	short				MarkerID;				//	unique unsigned ID for each marker	long				TextLength;				//	length of marker text	char				TheText[1];				//	variable length array: TextLength bytes of ASCII characters};struct SD2MarkersRecord{	short				Version;				//	version/format of this resource(1)	long				MarkerOffset;			//	DO NOT USE (0)	short				NumMarkers;				//	number of MarkerRecords to follow	MarkerRecord		MarkerRecords[1];		//	variable length array};//	Type: 'sdDD'   ID: 1000//	Use: Stores general document information such as comments.//	Structure: A DocumentDataRecord as defined below.struct DocumentDataRecord{	short				Version;				//	version/format of this resource(1)	long				BufOffset;				//	DO NOT USE (0)	long				MarkerOffset;			//	offset to get relative time of markers	Str255				Comment;				//	file comment (" ")	short				HDPlayBufMultiple;		//	HD play buf multiple for this file (8)	long				SMPTEStartTime;			//	SMPTE start time of this file (0)	short				FramesPerSec;			//	SMPTE frame rate of this file (30)	short				FilmSize;				//	16mm or 35mm film (35)	long				StartBarNum;			//	starting Bar Number (0)	long				StartBeatNum;			//	starting Beat Number (0)	long				StartFrame;				//	the sample frame this new entry starts at	Fixed				Tempo;					//	tempo in beats/sec	Fixed				TimeSignature;			//	HiWord = numerator, LoWord = denominator	long				CursorPos;				//	cursor position relative to window start (0)	Byte				Pad;					//	(needed due to the difference between C++ bool and Pascal Boolean)	bool				CursorOn;				//	(FALSE/0)	ZoomType			Zoom;					//	see above	ScaleType			Scale;					//	see above	EditRecord			Edit;					//	see above	long				VOffset;				//	position of vertical center of window 												//		in quantization units ie -32768 to 32767 (0)	long				HOffset;				//	position of left edge of sample window 												//		in #SAMPLES (0)	Rect				CtlWidth;				//	DO NOT USE (0)	Point				ZoomIndex;				//	h and v indices in zoom increments	short				SelectMode;				//	DO NOT USE (0)};#pragma options align=reset/*Digidesign sez...Reserved Parameter/Resource TypesDigidesign reserves all resource types that begin with the letters 'sd' or 'dd' (capital and lower case) ie 'sdPL', 'SDxx', 'DDxx' or 'dDxx', for present and future use by Sound Designer II and other Digidesign programs.Data ForkByte one of the data fork is the first byte of sound data.  The sound data is organized as interleaved samples (if more then one channel) of either 8 or 16 bit samples depending on the value of the "sample-size" 'STR ' resource (see below).For example, a standard 16 bit stereo file would be organized as follows:Left Channel sample #1Right Channel sample #1Left Channel sample #2Right Channel sample #2Left Channel sample #3Right Channel sample #3etc...Where each sample is the MSB (most significant byte) followed by the LSB (least significant byte) or better known as little endian format.A four channel file would be as follows:Channel 1 sample #1Channel 2 sample #1Channel 3 sample #1Channel 4 sample #1Channel 1 sample #2Channel 2 sample #2Channel 3 sample #2Channel 4 sample #2etc...*/