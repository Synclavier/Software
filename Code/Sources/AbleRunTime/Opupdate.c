/* Index file update utility *//* 02/27/97 - Cj - restructured for MAC compilation *//*	Translated to C:   	12/22/99 at 23:22	*//*	Translator Version:	0.000				*/// Mac O/S#include <Events.h>#include	"XPL.h"#include 	"XPLASCIILit.h"#include 	"Syslits.h"#include 	"Catrtns.h"#include 	"FileIO.h"#include 	"Optical.h"#include 	"Optical.h"#include	"Messages.h"#include	"SCSILits.h"#include	"Devutil.h"extern fixed s_sensekey;extern void	 _pstring(char*);extern void	 _pstringr(char*);extern void	 _pablestringr(fixed*);extern void	 _pnum   (fixed, fixed);extern void	 _clear_screen();extern void	 _crlf();extern void	 _flush_term();extern void	 _pos(fixed, fixed);extern void  _erase_line();extern fixed _rchar();#define		 real_milliseconds	((ufixed) (TickCount()*15))extern void	 timeshare_with_host();// ### call main level code from optical, fileio.c, opupdate_main// ####/* External memory manager matching RTP: */extern	array	diskio_info;											// Info used by polyread, polywrite, extread, extwrite/* comlits - insert file for pdl size, configuration, compilation flags */#define	pdl_size			1500										// size is here_pdl(pdl_size)															// so everyone knows about it#define	inc_voice_output	0											// include S. Wonder voice output...#define	delete_on_next_full_build	1									//  mark publics to delete on next build/* Some-vk   $title flags for standard vk compilation   modified:   02/07/91 - MWH - Combine 3200, 6400 and 9600 RTP's   10/16/89 - cj  - added inc.creg for inclusion of d130 (creg/dreg)                    code.   Only set to 0 for debugging. inc.fm for                    fm code as well.   06/15/89 - PF  - Removed dcl of inc.new.midi   06/05/89 - TSS - Added INC.KBD.MAPS and INC.KBD.MAP.SCREEN   01/13/89 - PF  - added inc.new.midi for Monster MIDI   09/01/88 - SGS - Added inc.pvoc   08/29/88 - SGS - Added inc.clav   06/06/88 - MWH - Rename from "SYN-N"      This file is used to replace :synlits:somelits*/_configuration("modelc, muldiv")#define	new_pan				1											// Velocity kbd#define	inc_poly			1											// Poly#define	inc_mono			0											// No mono#define	mono_lb				0											// No large buffers#define	inc_axe				0											// No guitar#define	inc_dtd				1											// set to 1 to include direct-to-disk#define	inc_midi			1											// set to 1 to include midi#define	inc_mouse			1											// set to 1 to include mouse code#define	inc_mult			1											// set to 1 to include multichannel#define	inc_music_notation	1											// include m. nota#define	inc_stm				1											// set to 1 to include sample-to-memory#define	inc_stmm			1											// set to 1 to include rel m stm commands#define	inc_tds				1											// set to 1 to include timbre display#define	inc_creg			1											// set to 1 to include d130 code#define	inc_fm				1											// set to 1 if d160-d163 are avail#define	inc_pro				1											// set to 1 to include RS232 protocol#define	inc_kbd_maps		1											// set to 1 to use new kbd mapping code/* Globlits  $title  file of General Literals Used by Most Programs *//*Modified:1998/05/15 - TY  - Corrected a misleading comment for LAST.LOD.TRACK.1998/05/09 - TY  - Added "is.negative" and "is.odd".1990/03/09 - PF  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 1281989/03/14 - PF  - Added DEFAULT.MIDI.VELOCITY1988/06/22 - EEG - Moved various track literals (tracks above 200) here1988/05/04 - TSS - MOVED MIDI.MIDDLE.C HERE FROM 142-MIDI1987/06/15 - MWH - Added 32 bit address literals1987/01/20 - TS  - ADDED POLYPHONY.DISP LITERAL1986/11/17 - EG  - CHANGED SWAPABLE TO RECURSIVE SWAP1986/11/04 - BSW - increased the size of the character input buffer*//* Xpl literals: */#define	swapable			recursive SWAP#define	forward				procedure#define	forever				while 1#define	true				1#define	false				0#define	boolean				fixed#define	atnv				0x00D4										// Lit for abs transfer never/* Multiply divide literals: */#define	load				write(5)=									// Load#define	uload				write(4)=									// Load upper#define	rem					read(4)										// Quotient remainder#define	mul					write(6)=									// Perform multiply#define	div					write(7)=									// Perform divide#define	res					read(5)										// Result lsb#define	ures				read(4)										// Result msb#define	mwait				write("324")=RES							// D5 to atnv to wait for mul/div/* Repeat counter (model c processor only): */#define	rpc					write("010")=(-1)+/* External memory definitions */#define	mam					0x0030										// memory address msb#define	mal					0x0031										// memory address lsb#define	md					0x0032										// memory data#define	mdi					0x0033										// memory data with increment/* Serial port device addresses */#define	d50					0x0028 #define	d51	0x0029					// Terminal port#define	d40					0x0020 #define	d41	0x0021					// Printer  port#define	d42					0x0022 #define	d43	0x0023					// Voice    port#define	d44					0x0024 #define	d45	0x0025					// Mouse    port#define	d54					0x002C										// Bits for d4x interrupt status/* The smpte board is accessed using 4 device addresses: */#define	smpte_subsys		8											// Subsystem # for smpte card#define	d70					0x0038										// Write 8 to reset#define	d71					0x0039										/* Status   bits														*/  /* Write opcodes here */#define	d72					0x003A										// Seconds  frames#define	d73					0x003B										/* Hours    minutes														*/  /* Read of d73 triggers new info *//* For midi board - note: they match smpte */#define	syssel				0x0038										// Midi subsystem select address#define	mcha				0x0039										// Channel select address if write#define	msta				0x0039										// Input fifo status      if read#define	mdat				0x003A										// Input and output data port/* Scientific timer device addresses */#define	d16					0x000E#define	d17					0x000F/* Mono sampling synth addresses */#define	d66					0x0036										// Control register#define	d67					0x0037										// Data    register/* Guitar device addresses */#define	d134				0x005C#define	d135				0x005D/* Multi-channel distributor device addresses */#define	d32					0x001A										// Device 32 digital io multiplexor#define	d33					0x001B										//           Data port/* Keyboard interface device addresses */#define	dreg				0x0058										// Keyboard interface data register#define	creg				0x0059										// Keyboard interface control register#define	pulse_exwr			write(CREG)="40"\1; WRITE(CREG)=1; WRITE(CREG)="100"\1	// Mode 1 write then read/* Gate & trigger devices */#define	d164				0x0074#define	d165				0x0075/* Fundamental synclavier literals: */#define	num_partials		4											// Number of partials per timbre/* **** Note ****  -  during run time,  the keyboard and split keyboard   area treated as tracks in many ways.   Look up tables for tracks   are therefore offset by 2 words when compared to the tracks of the   sequencer. */#define	num_keys			(85)										// Allowable software key range - 0-84#define	max_key_			(num_keys-1)								// Max allowed key number#define	sync_middle_c		(36)										// Key number of middle c on synclavier#define	midi_middle_c		(60)										// Key number of middle c in midi world/* Run-time data structure: */#define	zero_time			50											// Play.time.lsb of script=0.000#define	rte_max				225											// Largest rte pedal position#define	default_midi_velocity	rte_max									// Midi default velocity#define	max_tracks			256											// Max # of tracks processed#define	num_kbd_tracks		2											// Num of keyboard tracks#define	max_inputs			128											// Num of input channels (kbd+midi)#define	first_lod_track		202											// Abs. Track number of first lod track#define	last_lod_track		218											// Abs. Track number of first track after last lod track/* Various important or temp tracks used by procedures */#define	undo_trk			230											// Abs trk used by g-screen for undo function#define	undo_tmp_trk		231											// Abs trk used by g-screen for undo function#define	bounce_trk			240											// Abs trk used by bounce for tmp trk#define	chain_trk			241											// Abs trk used by chain to chain on to#define	sou_trk				242											// Abs trk used by chain for copy of source trk#define	sou_copy			243											// Abs trk used by cut for copy of source trk#define	temp_trk			244											// Abs trk used by paste for tmp trk#define	always_empty_track	248											// Abs. Track number of an always empty track#define	locate_info_track	249											// Abs. Track number where aee locate positions stored#define	cue_audition_track	254											// Abs. Track number of cue audition trk#define	reserved_track		255											// Track 255 is reserved for future use#define	max_timbres			256											// Max # of timbres processed#define	bit0				1#define	bit1				2#define	bit2				4#define	bit3				8#define	bit4				16#define	bit5				32#define	bit6				64#define	bit7				128#define	bit8				256#define	bit9				512#define	bit10				1024#define	bit11				2048#define	bit12				((fixed) 4096)#define	bit13				((fixed) 8192)#define	bit14				((fixed) 16384)#define	bit15				((fixed) 32768)/* 32 bit address literals */#define	lw_msb				0											// Upper 16 bits of 32-bit "long word"#define	lw_lsb				1											// Lower 16 bits of 32-bit "long word"#define	lw_ilt				-1											// 32 bit compare is less than#define	lw_ieq				0											// 32 bit compare is equal to#define	lw_igt				1											// 32 bit compare is greater than#define	lw_num				0											// numerator in array stored here#define	lw_den				1											// denominator in array stored here/* use with care - check parenthesis carefully!   dcl is.negative	lit '& Bit15';   dcl is.odd			lit '& 1';*//* Samplits  $title  memory Management Literals for Poly/Mono Sampling Memory *//*    Modified:   15 Jun 1987    MWH   Add literals for multiple poly bins   *//* The poly synth wave memory is managed by using variable length   blocks.   The following variables are used:      psfirst - points to the sector of poly memory where the blocks                start.  Is most likey one.   Starting at this                sector,  and up through (but not including) pslast                are a group of these variable length blocks.  Each                block is an integer number of sectors long.      pslast  - points to next available sector.      psmax   - points to the end of the poly synth memory that is                available.   Memory sector psmax-1 may be used.      psfree  - indicates sectors of poly memory that are unused.                some of these sectors may contain a file but that                file is not being used at the moment.   A complete                garbage collection will always yield psfree sectors.      pshere  - a rotary pointer used to indicate where to start loading                files and/or garbage collecting.   Provides least recently                used algorithm.   an identical algorithm (using msfirst, mslast, msmax, msfree) is   used to manage blocks of attack buffers in external memory for   the mono sampling code. */#define	poly_magic			((fixed) 12345)								// Magic number restored when poly contains valid data#define	poly_rev			((fixed) 54336)								// Rev # for held memory - count up#define	first_base			21											// Start poly mem blocks here#define	psmaxbins			4											// Maximum number of poly bins per system#define	psmaxpages			16											// Maximum number of 32mb pages of poly memory -> 512 mb total/* $Subtitle  definitions for poly/mono memory blocks */#define	bl_len				0											//   0 - Block length in sectors#define	bl_users			1											//   1 - Number of patch list frames using this file/buffer#define	bl_fname			2											//   2 - File name, for matching purposes#define	bl_dev				6											//   6 - Original device we came from to detect same sound on different devices#define	bl_sec				7											//   7 - Original sector/* Info from sound file:   (must match timbre lits) */#define	bl_keytc			20											// Holds keytc from sound file#define	bl_vrate			21											// Holds vrate from sound file#define	bl_vdepth			22											// Holds vib depth#define	bl_vat				23											// Holds vibrato attack time/* Precomputed pitch info: */#define	bl_srate			24											// Holds file sample rate correction factor#define	bl_pitch			25											// Set octave pitch correction factor#define	bl_toffs			26											// Holds octave correction with transposition/* Mono sampling only:     */#define	bl_start			27											// Start of valid data from sector+1 of block#define	bl_abufl			28											// Attack buffer len words#define	bl_wdd				29											// W. Disk device#define	bl_wds				30											// W. Disk start sector#define	bl_wdn				31											// W. Disk # of sectors#define	bl_fwrds			32											// Words in final sector/* Poly sampling only:     */#define	bl_wtabl			27											// holds number of complete sectors of audio data that should be heard																		// holds number of additional words of audio data that should be heard#define	bl_sofs				29											// hold sector offset from sfile.base of sector that contains the first sample to be heard#define	bl_wofs				30											// holds word offset within the BL.SOFS sector of first sample that should be heard#define	bl_loopl			31											// holds duplicate copy of BL.WTABL. not really used. massaged in PT.LOOPL.#define	bl_onloop			33											// holds a 1; massaged to 3 in PT.ONLOOP if a loop is required#define	bl_max				34											// holds duplicate copy of BL.WTABL. not really used. massaged in PT.MAX#define	bl_check			36											// hold checksum#define	bl_sftl				37											// holds sound file total length from sound file header, if any#define	bl_sfll				39											// holds sound file loop  length from sound file header, if any#define	bl_stereo			41											// true if stereo#define	bl_khz				42											// khz*10 for this file#define	bl_copyl			43											// Number of words to copy into partial#define	bl_saved			43											// Poly sampling only - true if file saved#define	bl_mono				256											//  256 - Start mono sampling data here#define	bl_poly				1024										// 1024 - Start poly sampling data here#define	sf_hdr				1											// offset of sound file header (in sectors) from start of allocated memory when file is in polly memory																		// also equals length of sound file header (in sectors)#define	sf_sym				2											// offset of sound file symbol table (in sectors) from start of allocated memory when file is in polly memory																		// also equals length of symbol table area (in sectors)/* Sound file cache header */#define	bl_w0ptr			16											// Pointer to beginning of w0 area in cache#define	bl_w1ptr			17											// Pointer to beginning of w1 area in cache#define	bl_filecount		18											// No. Sound files in cache#define	bl_catcount			19											// No. Categories in cache#define	bl_cacheptr			20											// No. Words in cache#define	bl_lines			21											// Start of line count array#define	bl_linesmax			16											// Size of line count array/* $Subtitle  literal Dcls for Sound File Header Information */#define	max_symbols			64											// maximum number of symbols in`the sound file symbol table#define	symbol_length		8											// symbol description is eight words long#define	name_entry			3											// point to the name entry location/* sound file header information */#define	sf_compatibility	0											// sound file revision where#define	sf_file_data_type	1											// data type of the sound file where#define	sf_valid_data		2											// points to 3 word index vector with number of data points in file#define	sf_total_data		6											// points to total allocated data length. 24-bit format.#define	sf_data_end			9											// time corresponding to valid.data-1#define	sf_keyboard_decay_number	12									// a time value in milliseconds.#define	sf_semitones		13											// pitch bend range in semitones#define	sf_vibrato_rate		14											// Hz*100; Vibrato is the periodic variation in pitch.#define	sf_vibrato_depth	15											// semitones*100; pitch range for Random wave shapes.#define	sf_vibrato_attack	16											// vibrato wave attack time in milliseconds.#define	sf_vibrato_type		17											/* twelve possible vibrato wave shapes									*/  #define	sf_hertz			18											// 10*pitch frequency (i.e., 4400); The number of samples per second.#define	sf_octave			19											// floating point keyboard octave.cents set by user.#define	sf_period_index		21											// the number of clock ticks per sampling period#define	sf_nyquist_freq		22											/* in Hz.																*/ #define	sf_mark_start		23											// marks where the sound begins.#define	sf_mark_end			26											// marks where the sound ends.#define	sf_cursor_time		29											// the time of the current cursor location.#define	sf_gain_exponent	32											// for filters, the scale factor which scales the output in steps of 6 dB#define	sf_number_of_symbols	33										// number of symbols in sound file#define	sf_total_length		34											// perfect looping file length in 24-bit format#define	sf_loop_length		37											// perfect loop length in 24-bit format#define	sf_magic_number		40											// used to detect possible changes in file in SFM#define	sf_stereo			41											// indicates if stereo or not 1-> stereo#define	sf_sample_rate		42											// sound file sampling rate in kHz * 10#define	sf_smpte_mode		45											// Smpte mode#define	sf_smpte_bits		46											// Smpte start time bits#define	sf_smpte_secs_fra	47											// Smpte start time of file#define	sf_smpte_hrs_min	48											// Smpte start time of sound file#define	sf_mark_offset		49											// time corresponding to SMPTE offset in sound file#define	sf_index_base		52											// start of categorey index#define	sf_id_field_bytes	127											// byte count of sound file caption#define	sf_id_field			128											// word string of user data or file caption./* Xmemlits - literals for use with xmem module: *//* The following declarations are used to set up information neeededduring calls to polyread, polywrite, extread, extwrite.  These routinesdo diskreading and diskwriting directly in and out of poly sampling memoryand external memory. */#define	_start_sec			diskio_info[0]								// Starting sector addr in memory#define	_start_wd			diskio_info[1]								// Starting word   addr in memory#define	_sec_len			diskio_info[2]								// Sectors to read or write#define	_wd_len				diskio_info[3]								// Words   to read or write#define	copy_blen			64											// Length of copy.buf buffer#define	alt_copy_blen		256											// Actual length; new code can use this valuefixed			examount;												// Sectors of external memory availstatic	fixed			alloc_examount(									// Allocate & zero out external memory	fixed	num)	_recursive	_swap{	static	fixed	i, j;		if (_ILT_(examount, 64)) {											// Out of room		return (0);	}			if (_ILT_((examount-64), num)) {									// Out of room		return (0);	}			examount=examount-num;		_write_60(examount);		for (i = 0; i < num; i++) {											// Zero out		XPL_write(010, (-1)+ 256);		_write_63(0);	}			return (examount);	}	fixed			copy_buf[alt_copy_blen];								// Buf used by copy routines - can be used by others with carestatic	void			copy_in(										// Copy block into main memory - set up mam & mal before calling	fixed	*des,	fixed	len){	while (len--)		*des++ = _read_63;}	static	void			copy_out(										// Copy block to ex mem - set up mam & mal before calling	fixed	*sou,	fixed	len){	while (len--)		_write_63(*sou++);}	static	void			copy_ext_mem(									// High speed copies - copies up or down, any length, in external memory	fixed	soum,	fixed	soul,	fixed	desm,	fixed	desl,	fixed	len){	static	fixed	i;		soum=soum+shr(soul,8); soul=soul&255;								// Convert from base+ offset to sector + word	desm=desm+shr(desl,8); desl=desl&255;								// Convert from base+ offset to sector + word		if ((soum==desm)&&(soul==desl)) return;								// Check here for equal - no need to move	if (len==0)                 return;									// Also zero length			if ((_IGT_(soum, desm))||((soum==desm)&&(_IGT_(soul, desl)))) {		// Copy down		while (len!=0) {												// Process desired words			i=alt_copy_blen;											// Get disk buffer length in words			if (_IGT_(i, len)) i=len;			_write_60(soum); _write_61(soul);			copy_in(&(copy_buf[0]),i);									// Get data from ex mem			soum=_read_60(); soul=_read_61();								// Get continuation address			_write_60(desm); _write_61(desl);							// Set up destination			copy_out(&(copy_buf[0]),i);									// Write data out			desm=_read_60(); desl=_read_61();								// Get continuation address			len=len-i;													// Account for words copied		}	}	else {																// Copy up - must start at top and work down		soul=soul+len; desl=desl+len;									// Compute top pointers		soum=soum+shr(soul,8); soul=soul&255;		desm=desm+shr(desl,8); desl=desl&255;		while (len!=0) {												// Process desired words			i=alt_copy_blen;											// Get disk buffer length in words			if (_IGT_(i, len)) i=len;			soul=soul-i;												// Back up pointer by length to copy			if (soul<0) {												// Back up msb as well				soum=soum+(((fixed) 0xFF00)|shr(soul,8));				// Construct - number, add in				soul=soul&255;											// Get positive msb			}			_write_60(soum); _write_61(soul);			copy_in(&(copy_buf[0]),i);									// Get data from ex mem			desl=desl-i;												// Back up pointer by length to copy			if (desl<0) {												// Back up msb as well				desm=desm+(((fixed) 0xFF00)|shr(desl,8));				// Construct - number, add in				desl=desl&255;											// Get positive msb			}			_write_60(desm); _write_61(desl);							// Set up destination			copy_out(&(copy_buf[0]),i);									// Write data out			len=len-i;													// Account for words copied		}	}}	static void			copy_ext_mem_sec(									// Sector boundaries & lengh	fixed	sou,	fixed	des,	fixed	secl)	{	if (sou==des) return;												// No work to do if in place	if (secl==0)  return;												// Zero length			if (_ILT_(sou, des)) {												// Copying up - start from top		sou=sou+secl; des=des+secl;	}	while (_IGT_(secl, 250)) {											// Copy in chunks		if (_ILT_(sou, des)) {											// Back up for copy			sou=sou-250; des=des-250;		}		copy_ext_mem(sou,0,des,0,shl(250,8));		if (_IGT_(sou, des)) {											// Increment after if copying up			sou=sou+250; des=des+250;		}		secl=secl-250;	}	if (_ILT_(sou, des)) {		sou=sou-secl; des=des-secl;	}	copy_ext_mem(sou,0,des,0,shl(secl,8));}	/* Required by SCSI: *//* From terminal primitive: */static	void			display_update_status(							// display status message on screen from laser disk update	fixed	mode, 														// mode to display	fixed	count, 														// no. items processed so far	fixed	total)	_recursive	_swap									// total no. items to process{	fixed			i;		if (mode == 0) {													// intitialize		/* reserve for initilize */	}	else {				if (total == 0) i = 100;										// deal with divide by zero		else {			_write_5(count);											// calculate percent complete			_write_6(100);			XPL_write(0324, _read_5);			_write_7(total);											// percent = (count / total) * 100			i = _read_5;		}					_pstring ("   ");		switch (mode - 1) {												// print different messages			case 0:				_pstring ("Reading category list:  ");				break;			case 1:				_pstring ("Reading optical disk:   ");				break;			case 2:				_pstring ("Updating file list:     ");				break;			case 3:				_pstring ("Updating category list: ");				break;		}		_pnum(count,6); _pstring (" processed out of ");		_pnum(total,6); _pstring (", ");		_pnum(i,    6); _pstringr("% complete");			}}		/* Update variable: */static	fixed	new_poly_contents;/* Memory Block Management Routines   by Kip Olson, September 1987   Modification History:   	 02/24/97 - CWJ - Extracted from SYNSOU:RECRDMOD:RECRDSOU to simplify	                  linking problems.  Deleted references to poly memory.					  made dedicated code instead of module.   	 11/26/96 - CWJ - Included comlits to get configuration info correct     05/02/88 - KJO - Updated for new poly routines*//* insert ':synmods:xmemdcl'; *//* external memory routines and declarations *//* The memory space in poly or external memory is allocated by word.      It is defined as follows:        word n  +---------------------------+                 |        Relocatable        | <- MStartPtr                |           Area            |                |                           |                |- - - - - - - - - - - - - -|                |                           | <- MRelocPtr                |           Free            |                |           Area            |                |                           |                |- - - - - - - - - - - - - -| <- MStaticPtr                |                           |                |          Static           |                |           Area            |                +---------------------------+   word n + len                               <- MEndPtr   *//* Memory Definition *//* Memory Block Parameters *//* Block Memory Management Literals *//* Memory Definition *//* The routines can use external or poly memory. The memory space can      be determined at run time using MDEVI as a variable or compile time      using MDEVI as a literal. It is about 20% faster to use a literal,      but then only one memory space can be used.      To use literals, the variables USINGPOLY and MDEVI must be changed      as shown below and all modules using the memory block routines      must be recompiled.   *//*    dcl UsingPoly     lit '0'; *//* use external memory *//*   dcl mdevi         lit 'mdi'; *//*   dcl UsingPoly     lit '1'; *//* use poly memory *//*   dcl mdevi         lit 'psd'; *//* Pointer Definition *//* A pointer to a word in external or poly memory is defined      using a two-word array, as follows:        15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0      +---------------------------------------------------------------+   0: |  Bin  | 0 | 0 |   Word Offset within Sector  |    MS Sector   |      |---------------------------------------------------------------|   1: |                          LS Sector                            |      +---------------------------------------------------------------+   */#define	ptr_msw				0											// Ms word of pointer#define	ptr_lsw				1											// Ls word of pointer#define	ptr_len				2											// no. words used by pointer/* Block Definition *//* Blocks of memory are pointed to by pointers. The format of a      memory block is given below:      +------------------------------+   0: | No. words allocated to block |      |------------------------------|   1: | No. words actually used      |      |------------------------------|   2: | MS pointer to data           |      |------------------------------|   3: | LS pointer to data           |      |------------------------------|   4: | Block data                   |      |------------------------------|                   .                   .   n:              .   */#define	mem_alloc			0											// no. words allocated#define	mem_used			1											// no. words used#define	mem_ptr				2											// pointer to another block#define	mem_data			4											// start of data field#define	mem_len				4											// no. words used for block control variables/* Tree Definition *//* A node on a balanced binary tree is defined using the following      fields in addition to the previously defined memory block fields:      +------------------------------+   4: | MS pointer to left subtree   |      |------------------------------|   5: | LS pointer to left subtree   |      |------------------------------|   6: | MS pointer to right subtree  |      |------------------------------|   7: | LS pointer to right subtree  |      |------------------------------|   8: | Red/Black flag               |      |------------------------------|   9: | Length of primary key        |      |------------------------------|   10:| Primary key data             |      |------------------------------|                   .                   .   n:              .   */#define	tree_leftptr		4											// pointer to left subtree#define	tree_rightptr		6											// pointer to right subtree#define	tree_red			8											// red/black flag#define	tree_key			9											// start of key field#define	tree_len			5											// no. words used for tree control variables/* TreeInsert return codes */#define	nodecreated			0											// new tree node created#define	nodefound			1											// tree node found#define	nomoreroom			-1											// no room for new memory blocks#define	mdevi				mdi											// memory device to read/writestatic	fixed	mstartptr[ptr_len];										// start of memory areastatic	fixed	mendptr[ptr_len];										// end of memory areastatic	fixed	mrelocptr[ptr_len];										// next free section after reloc areastatic	fixed	mstaticptr[ptr_len];									// last static blockfixed			mnullptr[ptr_len];										// null pointer/* Stack Parameters */fixed			r_stkbase;												// base of stack in external memoryfixed			r_stkmax;												// max no. items on stackstatic	fixed	stkptr;													// no. items on stackstatic	fixed	baseptr;												// pointer to current base of stackstatic	fixed	mtreeptr[ptr_len];										// tree node/* Memory Block Management Routines */static	void			ptrtowords(										// turn pointer address into a word address	fixed	ptr[], 														// pointer to convert	fixed	buf[])	_recursive	_swap									// array to return words in	{	buf[0] = (shl(ptr[0] & 0x000F,8) | shr(ptr[1],8));	buf[1] = (shl(ptr[1],8) | (shr(ptr[0],4) & 0x00FF));}	static	void			wordstoptr(										// turn word address into a pointer address	fixed	buf[], 														// words to convert	fixed	ptr[])	_recursive	_swap									// pointer to return	{	ptr[0] = ((ptr[0] & ((fixed) 0xF000)) | shl(buf[1] & 0x00FF,4) | shr(buf[0],8));	ptr[1] = (shl(buf[0],8) | shr(buf[1],8));}	static	void			readmblock(										// setup to read block of memory	fixed	ptr[], 														// pointer to block to read	fixed	offset)														// offset from beginning of pointer{	static	fixed	base[2];											// base pointer		offset = (shr(ptr[0],4) & 0x00FF) + offset;							// add on offset		_write_60(ptr[1] + shr(offset,8));									// starting sector	_write_61((offset & 0x00FF));										// starting word within that sector}	static	void			writemblock(									// setup to write block of memory	fixed	ptr[], 														// pointer to block to read	fixed	offset)														// offset from beginning of pointer{	static	fixed	base[2];											// base pointer		offset = (shr(ptr[0],4) & 0x00FF) + offset;							// add on offset		_write_60(ptr[1] + shr(offset,8));									// starting sector	_write_61((offset & 0x00FF));										// starting word within that sector}	static	void			readmptrblock(									// setup to read memory block given by pointer	fixed	ptr[], 														// pointer to source block	fixed	ptroffset, 													// offset of pointer in that block	fixed	offset)	_recursive	_swap									// offset in pointed-to block to read{	fixed			p[ptr_len];		readmblock(ptr,ptroffset);	p[0] = _read_63; p[1] = _read_63;									// get pointer	readmblock(p,offset);												// read block pointed to}	static	void			writemptrblock(									// setup to write memory block given by pointer	fixed	ptr[], 														// pointer to source block	fixed	ptroffset, 													// offset of pointer in that block	fixed	offset)	_recursive	_swap									// offset in pointed-to block to write{	fixed			p[ptr_len];		readmblock(ptr,ptroffset);	p[0] = _read_63; p[1] = _read_63;									// get pointer	writemblock(p,offset);												// write block pointed to}	static	void			copymblock(										// copy block of memory	fixed	sourceptr[], 												// pointer to source block	fixed	sourceoffset, 												// offset from beginning of source block to start copy	fixed	destptr[], 													// pointer to destination block	fixed	destoffset, 												// offset from beginning of destination block to copy to	fixed	len)	_recursive	_swap									// no. words to copy{	sourceoffset = (shr(sourceptr[0],4) & 0x00FF) + sourceoffset;		// add on offset	destoffset = (shr(destptr[0],4) & 0x00FF) + destoffset;		copy_ext_mem(sourceptr[1],sourceoffset,	destptr[1],  destoffset,	len);}	static	void	compactmblocks()	_recursive	_swap					// compact relocateable memory{	fixed			sourceptr[ptr_len];									// source pointer	fixed			destptr[ptr_len];									// destination pointer	fixed			ptr[ptr_len];										// scratch pointer	fixed			buf[2];												// word buffer	fixed			alloclen;											// no. words allocated for block	fixed			datalen;											// no. words used for block		sourceptr[0] = mstartptr[0];										// start at beginning of relocateable memory	sourceptr[1] = mstartptr[1];	destptr[0] = sourceptr[0];											// this is same as destination	destptr[1] = sourceptr[1];		while ((sourceptr[0] != mrelocptr[0]) || (sourceptr[1] != mrelocptr[1])) {	// loop until end of relocateable area		readmblock(sourceptr,mem_alloc);		alloclen = _read_63;											// allocation		datalen = _read_63;												// size		ptr[0] = _read_63;												// pointer		ptr[1] = _read_63;				if ((ptr[0] == mnullptr[0]) && (ptr[1] == mnullptr[1]) && (datalen == 0)) {	// skip deleted blocks		}		else {															// valid data block			if ((sourceptr[0] != destptr[0]) || (sourceptr[1] != destptr[1])) {	// source <> destination, so shuffle down				copymblock(sourceptr,0,destptr,0,alloclen);				// copy data				if ((ptr[0] != mnullptr[0]) || (ptr[1] != mnullptr[1])) {	// something is pointing at this block					writemblock(ptr,mem_ptr);							// make it point to the new location					_write_63(destptr[0]);					_write_63(destptr[1]);				}			}							ptrtowords(destptr,buf);			buf[1] = buf[1] + alloclen;			if (_ILT_(buf[1], alloclen)) buf[0] = buf[0] + 1;			wordstoptr(buf,destptr);		}					ptrtowords(sourceptr,buf);		buf[1] = buf[1] + alloclen;		if (_ILT_(buf[1], alloclen)) buf[0] = buf[0] + 1;		wordstoptr(buf,sourceptr);	}			mrelocptr[0] = destptr[0];											// new end of relocatable area	mrelocptr[1] = destptr[1];}	static	void			getmfree(										// return no. words free in buffer area	fixed	buf[])	_recursive	_swap									// buffer to return memory data{	fixed			staticStuff[2], reloc[2];		ptrtowords(mstaticptr,staticStuff);									// convert to word pointers	ptrtowords(mrelocptr,reloc);		buf[0] = staticStuff[0] - reloc[0];									// free = static - reloc	if (_ILT_(staticStuff[1], reloc[1])) buf[0] = buf[0] - 1;	buf[1] = staticStuff[1] - reloc[1];}	static	fixed			getmblocksize(									// return no. words used by memory block	fixed	ptr[])	_recursive	_swap									// pointer to block	{	readmblock(ptr,mem_alloc);	return (_read_63 - mem_len);										// return allocated size minus reserved words}	static	boolean			newmblock(										// allocate new memory block	fixed	ptr[], 														// pointer to return	fixed	len, 														// no. words to allocate	boolean	relocate)	_recursive	_swap								// True if block is to be relocateable{	fixed			total;												// total no. words to allocate	fixed			buf[2];		total = len + mem_len;												// total no. words required		getmfree(buf);														// find amount of free memory	if ((buf[0] == 0) && (_ILT_(buf[1], total))) {						// not enough room for requested block		compactmblocks();												// compact memory		getmfree(buf);													// find amount of free memory	}			if ((buf[0] == 0) && (_ILT_(buf[1], total))) {						// still not enough room for requested block		s_sensekey = s_good;		c_status = e_record_full;										// set appropriate error message		return (false);													// die	}			if (relocate & 1) {													// allocate relocateable block		ptr[0] = mrelocptr[0];											// store pointer		ptr[1] = mrelocptr[1];				ptrtowords(mrelocptr,buf);										// convert pointer to word		buf[1] = buf[1] + total;										// move reloc pointer down		if (_ILT_(buf[1], total)) buf[0] = buf[0] + 1;		wordstoptr(buf,mrelocptr);										// store new reloc pointer	}	else {																// allocate static block		ptrtowords(mstaticptr,buf);										// convert pointer to word		if (_ILT_(buf[1], total)) buf[0] = buf[0] - 1;					// backup the required no. words		buf[1] = buf[1] - total;		wordstoptr(buf,mstaticptr);										// store new static pointer				ptr[0] = mstaticptr[0];											// store pointer		ptr[1] = mstaticptr[1];	}			writemblock(ptr,mem_alloc);											// intialize block	_write_63(total);													// store allocation length	_write_63(len);														// store used length	_write_63(mnullptr[0]);												// nothing points to this	_write_63(mnullptr[1]);		return (true);														// block allocated}	static	boolean			disposemblock(									// remove memory block	fixed	ptr[])	_recursive	_swap									// pointer to block to remove{	fixed			buf[2];	fixed			limit[2];		if ((ptr[0] == mnullptr[0]) && (ptr[1] == mnullptr[1]))		return (false);													// cannot delete null pointer			ptrtowords(ptr,buf);	ptrtowords(mstartptr,limit);	if ((_ILT_(buf[0], limit[0])) || ((buf[0] == limit[0]) && (_ILT_(buf[1], limit[1]))))		return (false);													// cannot delete a block before the beginning of the relocateable area			ptrtowords(mrelocptr,limit);	if ((_IGT_(buf[0], limit[0])) || ((buf[0] == limit[0]) && (_IGE_(buf[1], limit[1]))))		return (false);													// cannot delete a block after the end of the relocateable area			writemblock(ptr,mem_used);	_write_63(0);														// no words used	_write_63(mnullptr[0]);												// nothing points to this	_write_63(mnullptr[1]);		return (true);														// block deleted}	static	fixed			compareblock(									// compare memory block string to given string	fixed	ptr[], 														// pointer to block to compare	fixed	keyoffset, 													// offset of key in block	fixed	target[])	_recursive	_swap								// target string to compare against{	fixed			keyword;											// word of key	fixed			keych;												// character of key	fixed			keylen;												// length of of key	fixed			targetch;											// character of target	fixed			targetlen;											// length of target	fixed			max, i;		readmblock(ptr,keyoffset);											// prepare to read key	keylen = _read_63;													// get length of key string	targetlen = target[0];												// get length of target string	if (_ILT_(keylen, targetlen)) max = keylen; else max = targetlen;	// limit search to minimum of the two strings			keych = 0; targetch = 0;											// get into loop first time	i = 0;																// start at first character of target	while ((_ILT_(i, max)) && (keych == targetch)) {					// loop until all characters have been compared or a difference is found		if (i & 1) keych = shr(keyword,8);								// get odd characters		else {			keyword = _read_63;											// get next word of key			keych = (keyword & 0x00FF);									// get even characters		}		targetch = byte(target,i);										// get next character of target		i = i + 1;														// advance to next character position	}			if (_ILT_(keych, targetch))											// key < target		return (-1);	else if (_IGT_(keych, targetch))									// key > target		return (1);	else {																// all characters are the same		if (keylen == targetlen)										// lengths are the same			return (0);													// key = target		else if (_ILT_(keylen, targetlen))			return (-1);												// key < target		else return ( 1);												// key > target	}}	/* Tree Management Routines */static	boolean			treeinit(										// intialize tree	fixed	h[])	_recursive	_swap									// head of tree	{	if (newmblock(h,tree_len + 1,false) & 1) {		writemblock(h,tree_leftptr);		_write_63(mnullptr[0]); _write_63(mnullptr[1]);					// left pointer		_write_63(mnullptr[0]); _write_63(mnullptr[1]);					// right pointer		_write_63(false);												// red flag		_write_63(0);													// zero-length key		return (true);													// tree is ready	}	return (false);														// could not initialize tree}	static	boolean			treesearch(										// search tree for string	fixed	s[], 														// string to search for	fixed	h[], 														// head of tree	fixed	x[])	_recursive	_swap									// pointer to node{	fixed			c;		x[0] = h[0]; x[1] = h[1];											// start at root		while ((x[0] != mnullptr[0]) || (x[1] != mnullptr[1])) {			c = compareblock(x,tree_key,s);		if (c > 0) readmblock(x,tree_leftptr);							// node > string, so traverse left		else if (c < 0) readmblock(x,tree_rightptr);					// node < string, so traverse right		else return (true);												// key = node, so we are done					x[0] = _read_63; x[1] = _read_63;	}			return (false);														// string not found}	static	void	treeinsert_rotate(	fixed	s[], 														// string to insert	fixed	y[], 														// pointer to rotate	fixed	result[])													// function result{	static	fixed	ss[ptr_len], gs[ptr_len], t[ptr_len];		if (compareblock(y,tree_key,s) > 0)		readmblock(y,tree_leftptr);	else readmblock(y,tree_rightptr);	ss[0] = _read_63; ss[1] = _read_63;		if (compareblock(ss,tree_key,s) > 0) {		readmblock(ss,tree_leftptr);		gs[0] = _read_63; gs[1] = _read_63;		readmblock(gs,tree_rightptr);		t[0] = _read_63; t[1] = _read_63;		writemblock(ss,tree_leftptr);		_write_63(t[0]); _write_63(t[1]);		writemblock(gs,tree_rightptr);		_write_63(ss[0]); _write_63(ss[1]);	}	else {		readmblock(ss,tree_rightptr);		gs[0] = _read_63; gs[1] = _read_63;		readmblock(gs,tree_leftptr);		t[0] = _read_63; t[1] = _read_63;		writemblock(ss,tree_rightptr);		_write_63(t[0]); _write_63(t[1]);		writemblock(gs,tree_leftptr);		_write_63(ss[0]); _write_63(ss[1]);	}			if (compareblock(y,tree_key,s) > 0)		writemblock(y,tree_leftptr);	else writemblock(y,tree_rightptr);	_write_63(gs[0]); _write_63(gs[1]);		result[0] = gs[0]; result[1] = gs[1];}	static	void	treeinsert_split(	fixed	s[], 														// string to insert	fixed	h[],	fixed	gg[],	fixed	g[],	fixed	f_arg[],	fixed	x_arg[], 													// various pointers	fixed	result[])													// function result{	static	fixed	f[ptr_len], x[ptr_len];								// local variables		f[0] = f_arg[0]; f[1] = f_arg[1];									// copy to local variables	x[0] = x_arg[0]; x[1] = x_arg[1];		writemblock(x,tree_red);	_write_63(true);													// set red flag to true		writemptrblock(x,tree_leftptr,tree_red);	_write_63(false);													// set left child's red flag to false	writemptrblock(x,tree_rightptr,tree_red);	_write_63(false);													// set right child's red flag to false		readmblock(f,tree_red);	if (_read_63 & 1) {		writemblock(g,tree_red);		_write_63(true);				if ((compareblock(g,tree_key,s) > 0)		!= (compareblock(f,tree_key,s) > 0))			treeinsert_rotate(s,g,f);					treeinsert_rotate(s,gg,x);				writemblock(x,tree_red);		_write_63(false);	}			writemptrblock(h,tree_rightptr,tree_red);	_write_63(false);													// set right child's red flag to false		result[0] = x[0]; result[1] = x[1];}	static	fixed			treeinsert(										// insert string into tree	fixed	s[], 														// string to insert	fixed	h[], 														// head of tree	fixed	result[])	_recursive	_swap								// pointer to node found/created{    fixed			_upper0;	fixed			gg[ptr_len], g[ptr_len], f[ptr_len], x[ptr_len];	// various pointers	fixed			redleft, redright;	fixed			i, c;		/* main procedure */		x[0] = h[0]; x[1] = h[1];											// start at root	f[0] = x[0]; f[1] = x[1];	g[0] = x[0]; g[1] = x[1];		while ((x[0] != mnullptr[0]) || (x[1] != mnullptr[1])) {		gg[0] = g[0]; gg[1] = g[1];		g[0] = f[0]; g[1] = f[1];		f[0] = x[0]; f[1] = x[1];				c = compareblock(x,tree_key,s);		if (c > 0) readmblock(x,tree_leftptr);							// node > string, so traverse left		else if (c < 0) readmblock(x,tree_rightptr);					// node < string, so traverse right		else {															// key = node, so we are done			result[0] = x[0]; result[1] = x[1];							// store result			return (nodefound);		}					x[0] = _read_63; x[1] = _read_63;				readmptrblock(x,tree_leftptr,tree_red);							// get left child's red flag		redleft = _read_63;		readmptrblock(x,tree_rightptr,tree_red);						// get right child's red flag		redright = _read_63;				if ((redleft & 1) && (redright & 1)) {							// this is a four-node, so split it			treeinsert_split(s,h,gg,g,f,x,x);		}	}			if (newmblock(x,tree_len + shr(s[0] + 1,1) + 1,false) & 1) {		// could create new node		writemblock(x,tree_leftptr);				_write_63(mnullptr[0]); _write_63(mnullptr[1]);					// left pointer		_write_63(mnullptr[0]); _write_63(mnullptr[1]);					// right pointer		_write_63(false);												// red/black flag				_write_63(s[0]);												// length of key		for (_upper0 = shr(s[0] + 1,1), i = 1; i <= _upper0; i++) {		// store words of key			_write_63(s[i]);		}					if (compareblock(f,tree_key,s) > 0)			writemblock(f,tree_leftptr);								// node > string		else writemblock(f,tree_rightptr);								// node < string		_write_63(x[0]); _write_63(x[1]);								// make parent point to new child				result[0] = x[0]; result[1] = x[1];				treeinsert_split(s,h,gg,g,f,x,x);				return (nodecreated);											// new node inserted	}			return (nomoreroom);												// no more room in data area}	static	void	treetraverse_push(										// push onto stack	fixed	value)														// value to push{	_write_60(r_stkbase + shr(stkptr,8));								// sector in external memory	_write_61((stkptr & 0x00FF));										// word in that sector	_write_62(value);													// store value	stkptr = stkptr + 1;												// increment stack pointer}	static	fixed	treetraverse_pop()										// pop off of stack{	stkptr = stkptr - 1;												// decrement stack pointer	_write_60(r_stkbase + shr(stkptr,8));								// sector in external memory	_write_61((stkptr & 0x00FF));										// word in that sector	return (_read_62);													// return value there}	static	boolean	treetraverse(											// traverse tree	fixed	headptr[], 													// head of tree to traverse	boolean	initialize, 												// True to initialize traversal	fixed	nodeptr[])	_recursive	_swap								// pointer to node found	{	if (initialize & 1) {												// intialize stack for traversal		treetraverse_push(baseptr);										// save current base pointer		treetraverse_push(mtreeptr[0]);									// save current tree pointer		treetraverse_push(mtreeptr[1]);				baseptr = stkptr;												// this is now the new base pointer		readmblock(headptr,tree_rightptr);		mtreeptr[0] = _read_63; mtreeptr[1] = _read_63;					// start at right child of header	}			while (1) {		if ((mtreeptr[0] == mnullptr[0]) && (mtreeptr[1] == mnullptr[1])) {	// cannot traverse left anymore						if (stkptr == baseptr) {									// nothing left on this stack				mtreeptr[1] = treetraverse_pop();						// restore old tree pointer				mtreeptr[0] = treetraverse_pop();				baseptr = treetraverse_pop();							// restore old base pointer				s_sensekey = s_good;									// this is not an error				c_status = e_none;				return (false);											// nothing left			}							nodeptr[1] = treetraverse_pop();							// get node to return			nodeptr[0] = treetraverse_pop();						readmblock(nodeptr,tree_rightptr);			mtreeptr[0] = _read_63; mtreeptr[1] = _read_63;				// get right child						return (true);												// node found		}		else {			if (_IGE_(stkptr, r_stkmax)) {								// no more room on stack				s_sensekey = s_good;									// this is an error				c_status = e_stack_full;				return (false);			}							treetraverse_push(mtreeptr[0]);								// save this node			treetraverse_push(mtreeptr[1]);						readmblock(mtreeptr,tree_leftptr);			mtreeptr[0] = _read_63; mtreeptr[1] = _read_63;				// keep traversing to left		}	}}	/* Intialization Routines */static	void	definemarea(											// define memory area	fixed	bin, 														// bin to use	fixed	ms_start,	fixed	ls_start, 													// starting sector of memory area	fixed	ms_len,	fixed	ls_len)	_recursive	_swap									// sector length of memory area	{	if (bin == -1) {													// use external memory		bin = 0;	}			mstartptr[0] = (shl(bin,14) | shl(0,4) | (ms_start & 0x000F));		// bin, word, ms sec	mstartptr[1] = ls_start;											// ls sec		ms_start = ms_start + ms_len;										// calculate end of memory area	ls_start = ls_start + ls_len;	if (_ILT_(ls_start, ls_len)) ms_start = ms_start + 1;			mendptr[0] = (shl(bin,14) | shl(0,4) | (ms_start & 0x000F));		// bin, word, ms sec	mendptr[1] = ls_start;												// ls sec		mrelocptr[0] = mstartptr[0];										// reloc area starts at beginning of memory area	mrelocptr[1] = mstartptr[1];		mstaticptr[0] = mendptr[0];											// static area starts at end of memory area	mstaticptr[1] = mendptr[1];		newmblock(mnullptr,tree_len + 1,false);								// allocate null pointer in static area		writemblock(mnullptr,mem_ptr);	_write_63(mnullptr[0]); _write_63(mnullptr[1]);						// does not point to a data block		writemblock(mnullptr,tree_leftptr);	_write_63(mnullptr[0]); _write_63(mnullptr[1]);						// left pointer	_write_63(mnullptr[0]); _write_63(mnullptr[1]);						// right pointer	_write_63(false);													// red flag	_write_63(0);														// key length}	static	void			definestack(									// define stack area	fixed	base, 														// base of stack in external memory	fixed	max)	_recursive	_swap									// max no. sectors on stack	{	r_stkbase = base;	if (_IGT_(max, 255)) max = 255;										// limit to 255 sectors	r_stkmax = shl(max,8);}	static	void		stackinit()	_recursive	_swap							// intialize stack{	stkptr = 0;	baseptr = stkptr;	mtreeptr[0] = mnullptr[0]; mtreeptr[1] = mnullptr[1];}/* Index File Update Routines   By Kip Olson, June 1987   Modification History:   10/19/90 - cj  - Inserted synmods:getvdcl to access new.poly.contents.                    Created event bit in Mount.Optical.Volume   03/14/89 - SGS - change .INDEX pathname, based on system device   05/01/88 - KJO - Added faster index file update routines*/#define	debug				0#define	debugalloc			0#define	updateinterval		1000										// no. ms between screen updatesstatic	fixed	filetree[ptr_len];										// head of file treestatic	fixed	cattree[ptr_len];										// head of category treestatic	fixed	i_indexpath [] = { 6, '.' + ('I'<<8), 'N' + ('D'<<8), 'E' + ('X'<<8)};		//{".INDEX"}static	fixed	i_index1path[] = { 7, '.' + ('I'<<8), 'N' + ('D'<<8), 'E' + ('X'<<8), '1'};	//{".INDEX1"}static	fixed	i_uncategory[] = {16, '"' + ('U'<<8), 'N' + ('C'<<8), 'A' + ('T'<<8), 'E' + ('G'<<8), 'O'+ ( 'R'<<8), 'I' + ('Z'<<8), 'E' + ('D'<<8), '"'};static	fixed	i_w0        [] = { 3, 'W' + ('0'<<8), ':'};static  fixed	i_colon     [] = { 1, ':'};static  fixed	i_r         [] = { 1, 'r'};static  fixed	i_w         [] = { 1, 'w'};file			filelist;												// file variable for file liststatic	fixed	filelistbuf;											// first sector of bufferstatic	fixed	filelistlen;											// no. sectors in bufferstatic	fixed	filelistmed;											// memory locationfile			catlist;												// file variable for category liststatic	fixed	catlistbuf;												// first sector of bufferstatic	fixed	catlistlen;												// no. sectors in bufferstatic	fixed	catlistmed;												// memory locationfixed			i_indexstart;											// sector offset of file list indexfixed			i_indexcount;											// no. entries in file list indexfixed			i_filestart;											// sector offset of file listfixed			i_filecount;											// no. entries in file listfixed			i_catstart;												// sector offset of category listfixed			i_catcount;												// no. entries in catetgory listfixed			i_entrycount;											// no. directory entries on optical diskfixed			i_stride;												// file list index stridestatic	void	print_pointer(	fixed	ptr[])	{	print("%6d%6d", ptr[1], shr(ptr[0],4) & 0x00FF);}	static	void	print_string(	fixed	ptr[], 	fixed	offset){    fixed			_upper0;	static	fixed	i, j, c;		readmblock(ptr,offset);	XPL_disable_interrupts();	j = _read_63;														// get length of key	for (_upper0 = shr(j + 1,1), i = 1; i <= _upper0; i++) {		c = _read_63;		print("%c", (c));		c = shr(c,8);		if (c != 0) print("%c", (c));	}}	static	void	print_blockdata(	fixed	ptr[]){	static	fixed	dp[ptr_len];		readmblock(ptr,mem_alloc);	XPL_disable_interrupts();	print("%s%6d%s%6d%s", "Block: A", _read_63, " U", _read_63, " DP");	dp[0] = _read_63; dp[1] = _read_63;	print_pointer(dp);}	static	void	print_treedata(	fixed	ptr[]){	static	fixed	dp[ptr_len];		readmblock(ptr,tree_leftptr);	XPL_disable_interrupts();	print("%s", "Tree:  LP");	dp[0] = _read_63; dp[1] = _read_63;	print_pointer(dp);	print("%s", " RP");	dp[0] = _read_63; dp[1] = _read_63;	print_pointer(dp);	print("%s%6d%s%6d", " Red", _read_63, " KL", _read_63);}	static	void	print_filenode(	fixed	nodeptr[]){	static	fixed	dataptr[ptr_len], catptr[ptr_len];	static	fixed	i, j;		XPL_disable_interrupts();	print("%s", "File:  ");	print_string(nodeptr,tree_key); print("\n");	print_blockdata(nodeptr); print("\n");	print_treedata(nodeptr); print("\n");		readmblock(nodeptr,mem_used);	if (_read_63 == -1) {		print("File deleted\n");	}	else {		readmblock(nodeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;				if ((dataptr[0] == mnullptr[0]) && (dataptr[1] == mnullptr[1])) {			print("No data pointer\n");		}		else {			readmblock(dataptr,mem_used);			XPL_disable_interrupts();			j = _read_63;			print("%s%6d\n", "Cats:  ", j);			for (i = 0; i < j; i++) {				readmblock(dataptr,mem_data + l_rec_length + i*ptr_len);				catptr[0] = _read_63; catptr[1] = _read_63;				readmblock(catptr,tree_key);				XPL_disable_interrupts();				print("%s%6d%s", "  ", _read_63, " ");				print_string(catptr,tree_key);				print("\n");			}		}	}}	static	void	print_catnode(	fixed	nodeptr[]){	static	fixed	dataptr[ptr_len];	static	fixed	i, j;		XPL_disable_interrupts();	print("%s", "Cat:   ");	print_string(nodeptr,tree_key); print("\n");	print_blockdata(nodeptr); print("\n");	print_treedata(nodeptr); print("\n");		readmblock(nodeptr,mem_used);	if (_read_63 == -1) {		print("File deleted\n");	}	else {		readmblock(nodeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;				if ((dataptr[0] == mnullptr[0]) && (dataptr[1] == mnullptr[1])) {			print("No data pointer\n");		}		else {			readmblock(dataptr,mem_used);			XPL_disable_interrupts();			j = _read_63;			print("%s%6d\n", "Files: ", j);			for (i = 0; i < j; i++) {				readmblock(dataptr,mem_data + i);				XPL_disable_interrupts();				print("%6d", _read_63);				if (((i + 1) % 8) == 0) print("\n");			}			if ((j % 8) != 0) print("\n");		}	}}	static	void	print_tree(	fixed	headptr[], 													// head of tree	boolean	printfiletree){	static	fixed	nodeptr[ptr_len];									// pointer to node	static	boolean	more_nodes;											// True if there are more nodes to print		more_nodes = treetraverse(headptr,true,nodeptr);					// get first node	while (more_nodes & 1) {		if (printfiletree & 1)			print_filenode(nodeptr);									// print file tree node		else print_catnode(nodeptr);									// print category tree node					more_nodes = treetraverse(headptr,false,nodeptr);				// get remaining nodes	}}static	void			definefilebuffers(								// define index file buffers	fixed	filesec, 													// sector start of file list buffer	fixed	filelen, 													// sector length of file list buffer	fixed	filemed, 													// file list buffer medium	fixed	catsec, 													// sector start of category list buffer	fixed	catlen, 													// sector length of category list buffer	fixed	catmed)	_recursive	_swap									// category list buffer medium	{	filelistbuf = filesec;	filelistlen = shl(filelen,8);	filelistmed = filemed;		catlistbuf = catsec;	catlistlen = shl(catlen,8);	catlistmed = catmed;}	static	void	str_insert(												// insert string s into string d starting at index	fixed	s[], 														// source string	fixed	d[], 														// destination string	fixed	index)	_recursive	_swap									// insertion point{    fixed			_upper0;	fixed			i;		if (_IGT_(index, d[0])) return;										// insertion point out of range		   for (i = d[0] - 1; i >= index; i--) {								// make room for source string in destination		pbyte(d,i + s[0],byte(d,i));	}	for (_upper0 = s[0] - 1, i = 0; i <= _upper0; i++) {				// put source string into proper location in destination string		pbyte(d,index + i,byte(s,i));	}	d[0] = d[0] + s[0];													// adjust destination size accordingly}	static	fixed	words_to_secs(											// convert words to sectors	fixed	msw,	fixed	lsw)	_recursive	_swap									// no. words	{	lsw = lsw + 255;													// add 255 to round no. sectors up, if neccessary	if (_ILT_(lsw, 255)) msw = msw + 1;			lsw = (shl(msw,8) | shr(lsw,8));									// divide by 256 to get no. sectors	msw = shr(msw,8);		return (lsw);														// return LS no. sectors}	static	void	get_file_name(											// get file name from optical disk buffer	fixed	bufindex, 													// starting index of name in buffer	fixed	len, 														// length of name in words	fixed	name[])														// array space to return name in{	static	fixed	i, c;		name[0] = 0; i = 0; c = -1;											// get the name of the file	while ((_ILT_(i, len)) && (c != 0)) {								// loop over characters of file name		c = gbuf(bufindex + i);											// get word of file name		if (c != 0) {													// there's a character in there somewhere			name[1 + i] = c;											// store character(s)			name[0] = name[0] + 1 + (shr(c,8) != 0);					// count the no. characters		}		i = i + 1;														// next word	}}	static	void			get_index_directory_name(						// construct index file tree name	fixed	treename[])	_recursive	_swap								// array space for index file treename	{	treename[0] = 0;													// nothing in treename	str_insert(i_w0, treename, 0);										// winchester-based system	str_insert(i_indexpath,treename,treename[0]);						// start with path name}	static	void			get_index_name(									// construct index file tree name	fixed	filename[], 												// name of index file	fixed	treename[])	_recursive	_swap								// array space for index file treename	{	get_index_directory_name(treename);		str_insert(i_colon, treename,treename[0]);							// add colon	str_insert(filename,treename,treename[0]);							// add file name		if (filename[0] > shl(f_name_len,1))								// file name uses more than the allowed no. characters		treename[0] = treename[0] - (filename[0] - shl(f_name_len,1));	// lop off extra characters}	static	void			get_index1_directory_name(						// construct index file tree name	fixed	treename[])	_recursive	_swap								// array space for index file treename	{	treename[0] = 0;													// nothing in treename	str_insert(i_w0, treename, 0);										// winchester-based system	str_insert(i_index1path,treename,treename[0]);						// start with path name}	static	void	get_index1_name(										// construct index file tree name	fixed	filename[], 												// name of index file	fixed	treename[])	_recursive	_swap								// array space for index file treename	{	get_index1_directory_name(treename);		str_insert(i_colon, treename,treename[0]);							// add colon	str_insert(filename,treename,treename[0]);							// add file name		if (filename[0] > shl(f_name_len,1))								// file name uses more than the allowed no. characters		treename[0] = treename[0] - (filename[0] - shl(f_name_len,1));	// lop off extra characters}	static	file	close_file(												// close file	file	f)	_recursive	_swap										// file to close{	fixed			i, j, k;		i = c_status;														// store statuses	j = file_error;	k = s_sensekey;		fclose(f);															// close file		c_status = i;														// restore statuses	file_error = j;	s_sensekey = k;		return (nullf);														// file is closed}	static	file	open_file(												// try to open file	fixed	name[], 													// treename of file to open	fixed	access[], 													// access type	fixed	bufptr, 													// pointer to file buffer	fixed	bufmed, 													// medium of file buffer	fixed	buflen)	_recursive	_swap									// size of file buffer{	file			f;													// file variable returned by FOPEN		f = fopen(name,access);												// try to open file with given access	if (f != nullf) {													// opened successfully		if (setbuf(f,bufptr,bufmed,buflen) != eof_mark) {				// buffer paremeters setup ok			return (f);													// return file pointer		}	}			if (f != nullf) f = close_file(f);									// close up file variable if it was opened			return (nullf);														// file not opened}	static	boolean	read_volume_name(										// read volume name	fixed	name[], 													// array space to return name in	fixed	level)														// level to read name from{	static	fixed	i, ch;		if (readheader(level) & 1)											// header could be read		get_file_name(h_name,h_name_max,name);							// get name from buffer	else return (false);												// could not read header			return (true);														// volume name read}	static	boolean			mount_volume(									// mount volume	fixed	level)	_recursive	_swap									// level to mount{	fixed			found;												// true if directory area has any unused space		if (readheader(level) & 1) {										// try to read header		found = findnextunused(o_ms_dirstart,o_ls_dirstart,o_ms_dirlen,o_ls_dirlen,level);	// could not find free entry		if ((found & 1) || ((! (found & 1)) && (s_sensekey == s_good))) {	// directory area searched without any SCSI errors			o_entrycount = sectoentry(f_ms_sector,f_ls_sector);			// convert sector to directory entry						if (read_volume_name(o_volume_name, level) & 1) {			// get volume name				return (true);											// volume mounted			}		}	}			return (false);														// volume not mounted}	static	boolean	check_volume_comparenames(								// returns TRUE if names are the same	fixed	s1[],	fixed	s2[])														// strings to compare{    fixed			_upper0;	static	fixed	i;		if (s1[0] == s2[0]) {												// same length		for (_upper0 = s1[0] - 1, i = 0; i <= _upper0; i++) {			// loop over bytes of name			if (byte(s1,i) != byte(s2,i)) return (false);				// different		}		return (true);													// same	}	return (false);														// names are different}	static	boolean			check_volume(									// see if volume has changed	fixed	level)	_recursive	_swap									// level to check{	fixed			new_name[h_name_max + 1];							// new volume name		if (read_volume_name(new_name,level) & 1) {							// try to read new volume name		if (check_volume_comparenames(o_volume_name,new_name) & 1) {	// volume name has not changed			return (true);												// volume has not changed		}		else c_status = e_volume_changed;								// new volume inserted	}	else {																// volume name could not be read		if (s_sensekey == s_unitattention) {							// got a unit attention sense			if (read_volume_name(new_name,level) & 1) {					// and could read header this time				if (check_volume_comparenames(o_volume_name,new_name) & 1) {	// volume name has not changed					if (findentrycount(level) != -1) {											// no new entries on optical disk						return (true);															// volume has not changed					}				}				else c_status = e_volume_changed;						// new volume inserted			}		}	}			return (false);}	static	boolean	mount_index_openindexfile(								// open index file	fixed	name[])														// treename of index file{	static	fixed	i, j;		filelist = open_file(name,i_r,filelistbuf,filelistmed,filelistlen);	// try to open index file for input	if (filelist != nullf) {											// opened successfully		catlist = open_file(name,i_r,catlistbuf,catlistmed,catlistlen);	// try to open index file for input		if (catlist != nullf) {											// opened successfully			return (true);												// index file opened and buffers allocated		}	}			return (false);														// index file not opened}	static	boolean	mount_index(											// mount optical disk volume	fixed	treename[])	_recursive	_swap								// treename of index file to mount	{	/* main procedure */		if (filelist != nullf) filelist = close_file(filelist);				// close up file variables	if (catlist  != nullf) catlist  = close_file(catlist );				// from prior optical			i_entrycount = 0;													// assume index file will not be found		if (mount_index_openindexfile(treename) & 1) {						// index file found and opened for input				seek(filelist,shl(h_magic,1),0);								// seek to magic number field		if (getw(filelist) < 0) {										// valid magic number						seek(filelist,shl(h_ls_dirstart,1),0);			i_indexstart = getw(filelist);								// get first sector of file list index			seek(filelist,shl(h_ls_dirlen,1),0);			_write_5(getw(filelist));									// get no. sectors in file list index			_write_6(256);												// no. words = no. sectors * 256			XPL_write(0324, _read_5);			_write_7(l_name_max);										// divide by the word length of the file names			i_indexcount = _read_5;										// store the no. entries in the file list index						seek(filelist,shl(h_ls_datastart,1),0);			i_filestart = getw(filelist);								// get first sector of file list			seek(filelist,shl(h_filecount,1),0);			i_filecount = getw(filelist);								// get no. records in file list						seek(filelist,shl(h_ls_catstart,1),0);			i_catstart = getw(filelist);								// get first sector of category list			seek(filelist,shl(h_catcount,1),0);			i_catcount = getw(filelist);								// get no. records in category list						seek(filelist,shl(h_entrycount,1),0);						// seek to directory entry count field			i_entrycount = getw(filelist);								// get the no. entries the index file thinks are on the optical disk						seek(filelist,shl(h_stride,1),0);							// seek to stride field			i_stride = getw(filelist);									// get file list index stride						return (true);												// index file is ready to go		}		else c_status = e_bad_index;									// index file header in bad state	}																	// index file opened			if (filelist != nullf) filelist = close_file(filelist);				// close up file variables	if (catlist  != nullf) catlist = close_file(catlist);			return (false);														// there was a problem mounting index}	static	boolean			check_index()	_recursive	_swap				// see if index has changed{	if ((filelist != nullf) && (catlist != nullf)) {					// file variables are still valid		return (true);													// index file is ready and willing	}	else c_status = e_no_index;											// no index file open			return (false);}	static	boolean			open_optical(									// open volume and index file	fixed	treename[], 												// array space for tree name	fixed	level)	_recursive	_swap									// level of optical disk{	boolean			found;	fixed			status;		/* Note: see exactly similar logic in update_index that finds the correct 	*/	/* index file to update...																	*/		if (mount_volume(level) & 1) {										// volume mounted		get_index_name(o_volume_name,treename);							// get treename of index file		found = mount_index(treename);									// see if exists in :.INDEX				if (found == false)												// not there: check :.INDEX1		{			status = c_status;											// save why failed						get_index1_name(o_volume_name,treename);					// get treename of index file			found = mount_index(treename);						if (found == false)											// could not find in .index1 either			{				if ((c_status == e_no_file)								// if .INDEX1 exists but specific .index file is missing				&&  (status   == e_no_path))							// and .INDEX subcatalog is missing					;													// then leave set up to use .INDEX1									else 													// else revert to .INDEX for normal use				{					get_index_name(o_volume_name,treename);				// e.g. publish the error message that goes with .INDEX					c_status = status;									// instead of .INDEX1...				}			}		}					if (found & 1) {												// index mounted						seek(filelist,shl(h_date,1),0);								// seek to date/time field						#if (0)														// force mounting of out-of-date index				o_entrycount = i_entrycount;				return (true);			#endif 						if ((gbuf(h_date) == getw(filelist)) && (gbuf(h_time) == getw(filelist))) {	// date and times match				if (o_entrycount == i_entrycount) {						// disk is up to date					return (true);										// volume is mounted				}				else if (_IGT_(o_entrycount, i_entrycount)) {			// new entries on optical					c_status = e_not_uptodate;							// index file is not up to date					return (false);										// return without closing file variables				}				else c_status = e_no_file;								// more entries in index file????			}			else c_status = e_no_file;									// date/time did not match, so file not found		}	}			if (filelist != nullf) filelist = close_file(filelist);	if (catlist  != nullf) catlist = close_file(catlist);			return (false);														// optical disk not open for business today}	static	boolean			check_optical(									// see if optical system is still open	fixed	level)	_recursive	_swap									// level of optical disk to verify	{	if ((check_volume(level) & 1) && (check_index() & 1)) {				// volume and index files have not changed		if (o_entrycount == i_entrycount) {								// disk is up to date			return (true);												// optical disk is still open		}		else c_status = e_not_uptodate;									// index file is not up to date	}			return (false);}/* 10/19/90 - cj - Created event bit when index file is modified */static	fixed	totalfiles, totalcats;									// total files and subcatsstatic	void	attach_data_block(										// attach data block to tree block	fixed	treeptr[], 													// pointer to tree block	fixed	dataptr[])	_recursive	_swap								// pointer to data block	{	writemblock(treeptr,mem_ptr);	_write_63(dataptr[0]); _write_63(dataptr[1]);						// make tree block point to data block	writemblock(dataptr,mem_ptr);	_write_63(treeptr[0]); _write_63(treeptr[1]);						// make data block point to tree block}	static	boolean	get_category_list(										// read category list into a balanced binary tree	fixed	infile)	_recursive	_swap									// input file{    fixed			_upper0;	fixed			treeptr[ptr_len];									// pointer to tree block	fixed			dataptr[ptr_len];									// pointer to data block	fixed			catname[65];										// array space for large category name	fixed			numfiles;											// no. file pointers in category	fixed			updatetime;											// last update time	fixed			i, j, p;		seek(infile,i_catstart,3);											// seek to first sector of category list		if (debug) { print("%s%6d%s%6d%s\n", "Category list starts at sector ", i_catstart, ", contains ", i_catcount, " entries");}			updatetime = real_milliseconds;										// show initial update message		i = 0;	while (_ILT_(i, i_catcount)) {										// read in all categories from category list			timeshare_with_host();				j = getw(infile);												// get forward pointer				catname[0] = getw(infile);										// get length of category name		for (_upper0 = shr(catname[0] + 1,1), j = 1; j <= _upper0; j++) {	// store category name			catname[j] = getw(infile);		}					numfiles = getw(infile);										// get no. file pointers		if (debug) { print("%s%6d%s%a%s%6d\n", "Category", i, ": Name = ", catname, ", Files = ", numfiles);}					p = treeinsert(catname,cattree,treeptr);						// insert category name into tree		if (p == nomoreroom) return (false);							// no room for new category					if (newmblock(dataptr,numfiles,true) & 1) {						// create data block			attach_data_block(treeptr,dataptr);							// attach to tree			writemblock(dataptr,mem_used);			_write_63(numfiles);										// store the number of file pointers						for (j = 0; j < numfiles; j++) {							// store file pointers				p = getw(infile);										// get file pointer				writemblock(dataptr,mem_data + j);				_write_63(p);											// store file pointer			}		}		else return (false);											// no room for data block					j = getw(infile);												// get back pointer				i = i + 1;														// get next category				if ((real_milliseconds >= updatetime) && (! (debug))) {			// time to display update message			display_update_status(1,i,i_catcount);						// show message			updatetime = real_milliseconds + updateinterval;			// next update time		}	}																	// looping over categories	if (debug) { print("Category list created\n");}			if (! (debug)) 		display_update_status(1,i,i_catcount);							// show final update status			totalcats = i_catcount;												// count the no. categories in category tree		return (true);														// category list successfully read from index file}	static	fixed	count_dir_categories()	_recursive	_swap				// count no. categories in this file{	fixed			start, i;											// starting index		start = gbuf(e_header + sf_index_base);								// get first word of category data	if (start == 0) start = 256;										// no index data, so start at end of header			i = 0;	while (start < 256) {		start = start + 1 + shr(gbuf(e_header + start) + 1,1);			// skip to next category		i = i + 1;	}			return (i);															// return the no. categories found}	static	void	store_file_data(										// store file list record to data block	fixed	dataptr[], 													// pointer to data block	fixed	entry)	_recursive	_swap									// directory entry on optical disk{    fixed			_upper0;	fixed			record[l_rec_length];								// file list record	fixed			i, j;		for (i = 0; i < l_rec_length; i++) {								// zero-out record		record[i] = 0;	}			for (i = 0; i < l_name_max; i++) {									// entry name		record[l_name + i] = gbuf(e__name + i);	}			record[l_ls_secstart] = gbuf(e_ls_secstart);						// Sector Start	record[l_ms_secstart] = gbuf(e_ms_secstart);		record[l_ls_seclen] = gbuf(e_ls_seclen);							// Sector Length	record[l_ms_seclen] = gbuf(e_ms_seclen);		record[l_ls_wordlen] = gbuf(e_ls_wordlen);							// Word Length	record[l_ms_wordlen] = gbuf(e_ms_wordlen);		record[l_file_type] = gbuf(e_file_type);							// File Type		record[l_dir_entry] = entry;										// Directory Entry on Optical		i = gbuf(e_header + sf_sample_rate);	if (i == 0) {														// no sample rate - must calculate it from period index		j = gbuf(e_header + sf_period_index);							// get period index		_write_5(((fixed) 30000));		_write_6(10);		XPL_write(0324, _read_5);		_write_7(j);													// sampling rate * 10 = (30000 * 10) / period		i = _read_5 + (_IGE_(_read_4, shr(j,1)));	}	record[l_sample_rate] = i;											// store sample rate		record[l_flags] = ( gbuf(e_header + sf_file_data_type) |	shl(gbuf(e_header + sf_stereo),10) );		j = gbuf(e_header + sf_id_field_bytes);								// get length of caption	if (_IGT_(j, shl(l_caption_max,1))) j = shl(l_caption_max,1);		// limit size of caption			record[l_caption] = j;												// store length of caption	for (_upper0 = shr(j + 1,1), i = 1; i <= _upper0; i++) {			// volume caption		record[l_caption + i] = gbuf(e_header + sf_id_field_bytes + i);	// store caption characters	}			writemblock(dataptr,mem_data);	for (i = 0; i < l_rec_length; i++) {								// write this data out to data block		_write_63(record[i]);	}}	static	boolean	store_file_categories(									// store file's list of categories	fixed	fileptr[], 													// pointer to file tree node	fixed	catcount)	_recursive	_swap								// no. categories for this file{    fixed			_upper0;	fixed			catname[65];										// category name	fixed			catptr[ptr_len];									// pointer to category tree node	fixed			catdataptr[ptr_len];								// pointer to category data block	fixed			start;												// start of category in directory entry record	fixed			count;												// no. categories to process	fixed			len;												// length of category in characters	fixed			index;												// index into category list	fixed			i, j, p, s;		if (catcount == 0) count = 1;										// this file has no categories	else {		start = gbuf(e_header + sf_index_base);							// get first word of category data		count = catcount;												// process all categories	}			writemptrblock(fileptr,mem_ptr,mem_used);	_write_63(count);													// store the no. categories	index = mem_data + l_rec_length;									// add category pointers after file list record data	    for (i = 1; i <= count; i++) {										// loop over all categories for this file			if (catcount == 0) {											// file has no category, so put in "uncategorized" category			len = i_uncategory[0];			for (_upper0 = shr(len + 1,1), j = 0; j <= _upper0; j++) {	// store uncategory name				catname[j] = i_uncategory[j];			}		}		else {			p = e_header + start;			len = gbuf(p);												// get length of category			for (_upper0 = shr(len + 1,1), j = 0; j <= _upper0; j++) {	// copy words of category name				catname[j] = gbuf(p + j);			}		}		if ((len & 0x0001) != 0)										// odd category length			pbyte(catname,len,0);										// zero out MS 8 bits					s = treeinsert(catname,cattree,catptr);							// insert category name into tree		if (s == nomoreroom) return (false);							// no room in tree for category					if (s == nodecreated) {											// category not already in tree			if (! (newmblock(catdataptr,ptr_len,true) & 1))				// create data block for this category				return (false);			attach_data_block(catptr,catdataptr);						// attach to category tree			writemblock(catdataptr,mem_used);			_write_63(0);												// no files in this category yet						totalcats = totalcats + 1;									// count the total no. categories in the tree		}					writemptrblock(fileptr,mem_ptr,index);							// add category to file's list of categories		_write_63(catptr[0]); _write_63(catptr[1]);				index = index + ptr_len;										// skip to next category list position		start = start + 1 + shr(len + 1,1);								// skip to next category	}			return (true);														// all categories added}	static	fixed	firstentry, lastentry;									// entry range in bufferstatic	boolean	get_entry(												// get buffered entry	fixed	entry, 														// entry to get	fixed	level)	_recursive	_swap									// level to read	{	if ((_IGE_(entry, firstentry)) && (_ILE_(entry, lastentry))) {		// this entry is already in the buffer		o_bufptr = r_stkbase + shl(entry - firstentry,1);				// adjust buffer pointer		return (true);													// go to it	}	else if (_ILT_(entry, o_entrycount)) {								// valid entry no., so read in buffer load		firstentry = entry;												// this will be the first entry		lastentry = firstentry + shr(r_stkmax,8 + 1) - 1;				// use all of stack area for buffer		if (_IGE_(lastentry, o_entrycount))								// cannot go beyond end of used directory area			lastentry = (o_entrycount - 1);								// limit size					o_bufptr = r_stkbase;											// reset buffer pointer to beginning of stack area		s_sensekey = readentries(firstentry,lastentry - firstentry + 1,level);	// read a buffer load of entries		if (s_sensekey == s_good)  {									// no error reading entries			return (true);												// go for it		}	}	else {																// invalid entry number, so die		s_sensekey = s_good;		c_status = e_fcb;												// illegal FCB	}			return (false);														// something bad happened}	static	boolean	add_file(												// add file to tree	fixed	entry)	_recursive	_swap									// directory entry number of file{	fixed			treeptr[ptr_len];									// pointer to tree block	fixed			dataptr[ptr_len];									// pointer to data block	fixed			filename[l_name_max + 1];							// name of file to add	fixed			catcount;											// no. categories for this file	fixed			blocksize;											// required size of data block in words	fixed			i, s;		catcount = count_dir_categories();									// count the no. categories for this file	if (catcount == 0)													// no categories for this file		blocksize = l_rec_length + ((fixed) (1*ptr_len));				// space for file record and "uncategorized" category pointer	else blocksize = l_rec_length + catcount*ptr_len;					// space for file record and all category pointers			get_file_name(e__name,l_name_max,filename);							// get name of file		if (debug) { print("%s%a", "Adding File ", filename);}			s = treeinsert(filename,filetree,treeptr);							// try to insert name into file tree	if (s == nomoreroom) return (false);								// no room in tree for file			if (s == nodecreated) {												// file added - create new data block		if (! (newmblock(dataptr,blocksize,true) & 1))					// create data block with room for category pointers			return (false);												// no room for new data block		attach_data_block(treeptr,dataptr);								//  attach to tree		totalfiles = totalfiles + 1;									// count the no. files in the file tree		if (debug) { print(", Node Created\n");}	}	else {																// file already in tree - update existing data block		i = getmblocksize(treeptr);										// get size of block		writemblock(treeptr,mem_used);		_write_63(i);													// store no. words used (in case file was previously deleted)		readmblock(treeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;					// get data block for this file				if (_ILT_(getmblocksize(dataptr), blocksize)) {					// not enough room in data block			disposemblock(dataptr);										// get rid of this block			if (! (newmblock(dataptr,blocksize,true) & 1))				// create new data block with more room				return (false);											// no room for new data block			attach_data_block(treeptr,dataptr);							// attach to tree		}		if (debug) { print(", Node Replaced\n");}	}			store_file_data(dataptr,entry);										// store file information in data block	if (! (store_file_categories(treeptr,catcount) & 1))				// store categories in data block		return (false);			return (true);														// record added successfully}	static	boolean	delete_file()	_recursive	_swap						// delete file from tree{	fixed			treeptr[ptr_len];									// pointer to tree block	fixed			dataptr[ptr_len];									// pointer to data block	fixed			filename[l_name_max + 1];							// name of file to add	fixed			s;		get_file_name(e_oldname,l_name_max,filename);						// get name of file to delete		if (debug) { print("%s%a%s", "Deleting File ", filename, ",");}			s = treeinsert(filename,filetree,treeptr);							// try to insert name into file tree	if (s == nomoreroom) return (false);								// no room in tree for file			if (s == nodecreated) {												// file added - create new data block		if (! (newmblock(dataptr,1,true) & 1))							// create dummy data block			return (false);												// no room for new data block		attach_data_block(treeptr,dataptr);								//  attach to tree		totalfiles = totalfiles + 1;									// count the no. files in the file tree		if (debug) { print("%s", ", Node Created, ");}	}			writemblock(treeptr,mem_used);	_write_63(-1);														// set flag to show that file has been deleted		return (true);														// file was deleted from tree}	static	boolean	get_updates(											// get updated directory entries off optical disk	fixed	level)	_recursive	_swap									// level to use{	fixed			entry;												// entry currently being processed	fixed			entrytype;											// entry type	fixed			optbufptr;											// optical disk buffer pointer	boolean			noerror;											// True if no error has occured	fixed			updatetime;											// last update time	fixed			i;		if (debug) { print("%s%6d%s%6d%s\n", "Adding entries ", i_entrycount, " to ", o_entrycount - 1, "...");print("\n");}			optbufptr = o_bufptr;												// store current buffer pointer so it can be moved around	firstentry = -1;													// nothing in buffer now	lastentry = -1;	updatetime = real_milliseconds;										// show initial update message		noerror = true;														// assume no error	entry = i_entrycount;												// start at first new entry	while ((_ILT_(entry, o_entrycount)) && (noerror & 1)) {				// loop over new entries, quit on error			timeshare_with_host();				if (debug) { print("\n");print("%s%6d%s", "Entry  ", entry, ": ");}					if (get_entry(entry,level) & 1) {								// entry found			entrytype = gbuf(e__type);									// get entry type						if (entrytype == e_dir_entry) {								// this is a directory entry				noerror = add_file(entry);								// add file to tree			}			else if (entrytype == e_delete_entry) {						// delete entry				noerror = delete_file();								// delete file from tree				if (debug) { print(" Done\n");}			}			else if (entrytype == e_rename_entry) {						// rename entry				i = 0;				while ((_ILT_(i, e_name_max)) && (gbuf(e__name + i) == gbuf(e_oldname + i))) {	// see if new name is same as old name					i = i + 1;				}				if (debug) {					print("%s", "Renaming File with ");					if (i == e_name_max) print("%s", "Same Name: ");else print("%s", "Different Name: ");				}				if (i == e_name_max)									// new name same as old name					noerror = true;										// don't go to trouble of deleting				else noerror = delete_file();							// delete old name from tree									if (noerror & 1)										// no error deleting					noerror = add_file(entry);							// add new file			}		}		else noerror = false;											// an error occured					entry = entry + 1;												// go to next entry				if ((real_milliseconds >= updatetime) && (! (debug))) {			// time to display update message			display_update_status(2,entry - i_entrycount,o_entrycount - i_entrycount + 1);	// display message			updatetime = real_milliseconds + updateinterval;			// next update time		}	}	if (debug) { print("\n");print("All entries added\n");}			o_bufptr = optbufptr;												// restore buffer pointer to its original position		if (! (debug)) 		display_update_status(2,entry - i_entrycount,o_entrycount - i_entrycount + 1);	// display status message			#if (debug)		print("%s", "Enter 1 to display trees, 0 to continue");// input i;		if (i == 0) return (noerror);		print("\n");		print("File Tree:\n");		print_tree(filetree,true);		print("\n");		print("Category Tree:\n");		print_tree(cattree,false);//input i;	#endif 		return (noerror);													// returns TRUE if updates added successfully}	static	void	initialize_header(										// intialize header for index file	fixed	level, 														// level to read from	fixed	direntrycount)	_recursive	_swap							// no. directory entries on optical disk	{	readheader(level);													// read header into buffer		pbuf(h_ls_dirstart,shr(h_rec_length,8));							// start of file list index	pbuf(h_ms_dirstart,0);		pbuf(h_ls_dirlen,shr(h_index_length,8));							// length of file list index	pbuf(h_ms_dirlen,0);		pbuf(h_entrycount,direntrycount);									// no. directory entries on optical disk	pbuf(h_stride,0);													// no stride yet}	static	void	save_header(											// save index file header to disk	file	outfile)	_recursive	_swap								// output file{	fixed			i, j;		seek(outfile,0,3);													// seek to first sector of header		for (i = 0; i < h_rec_length; i++) {								// write out header		j = gbuf(i);		putw(j,outfile);	}}	static	fixed	filelistrec;											// current file list record being processedstatic	fixed	filelistmax;											// max no. file list records in file liststatic	boolean	save_file_list_get_next_file(							// get next file list record	file	f, 															// input file	fixed	name[], 													// name of file	fixed	record[])													// record space to use{	static	fixed	i, c;		if (f != nullf) {													// there is an input file		if (_ILT_(filelistrec, filelistmax)) {							// more in file to get			fread(record,shl(l_rec_length,1),1,f);						// get record			filelistrec = filelistrec + 1;								// got another record						name[0] = 0; i = 0; c = -1;									// get the name of the file			while ((_ILT_(i, l_name_max)) && (c != 0)) {				// loop over characters of file name				c = record[l_name + i];									// get word of file name				if (c != 0) {											// there's a character in there somewhere					name[1 + i] = c;									// store character(s)					name[0] = name[0] + 1 + (shr(c,8) != 0);			// count the no. characters				}				i = i + 1;												// next word			}			return (true);												// got next file		}	}			return (false);														// no more files to get}	static	boolean	save_file_list_update_categories(						// update the file pointers in all categories	fixed	deleteindex, 												// delete every occurance of this file index	fixed	indexlimit, 												// adjust everything >= this limit	fixed	indexadjust)												// adjust factor (signed!){	static	fixed	treeptr[ptr_len];									// pointer to tree block	static	fixed	dataptr[ptr_len];									// pointer to data block	static	boolean	more_nodes;											// True if there are more nodes to process	static	fixed	fileindex;											// index of file in file list index	static	fixed	numfiles;											// no. files in category	static	fixed	count;												// no. elements in list	static	fixed	i, j;		if (debug) { print("Updating categories\n");}	if (debug) { print("%s%6d%6d%6d\n", "DeleteIndex, IndexLimit, IndexAdjust: ", deleteindex, indexlimit, indexadjust);}			more_nodes = treetraverse(cattree,true,treeptr);					// get first node	if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack		return (false);													// die			while (more_nodes & 1) {											// loop until the entire tree is traversed			timeshare_with_host();				readmblock(treeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;					// get pointer to data block				if ((dataptr[0] == mnullptr[0]) && (dataptr[1] == mnullptr[1]))	// no data block for this tree node			numfiles = 0;												// so there are no files in this category		else {			readmblock(dataptr,mem_used);			numfiles = _read_63;										// get the no. files in this category		}					count = 0;		while (_ILT_(count, numfiles)) {								// loop over all file indexes in category					timeshare_with_host();						readmblock(dataptr,mem_data + count);			fileindex = _read_63;										// get file index						if (fileindex == deleteindex) {								// delete this file from category								copymblock(dataptr,mem_data + count + 1,				// shuffle data over this index				dataptr,mem_data + count,				numfiles - count - 1);				numfiles = numfiles - 1;								// one less file index in list				writemblock(dataptr,mem_used);				_write_63(numfiles);									// store the new no. files in the list			}			else {														// see if limit needs adjusting				if (_IGE_(fileindex, indexlimit)) {						// update this pointer										fileindex = fileindex + indexadjust;				// adjust it up or down										writemblock(dataptr,mem_data + count);					_write_63(fileindex);								// store updated file index				}				count = count + 1;										// go to next file index in list			}		}					more_nodes = treetraverse(cattree,false,treeptr);				// get next node in tree		if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack			return (false);												// die	}																	// while traversing tree			return (true);}	static	boolean	save_file_list_insert_index(							// place file list index in proper place in category's list of files	fixed	treeptr[], 													// pointer to category's tree block	fixed	dataptr[], 													// pointer to category's data block	fixed	numfiles, 													// no. files in category's list of files	fixed	filelistindex, 												// index of file in file list	fixed	insertpt)													// point to insert file in category's list of files{	static	fixed	currentsize;										// current size of data block	static	fixed	newsize;											// new size required for data block	static	fixed	newptr[ptr_len];									// pointer to new data block	static	fixed	i, p;		currentsize = getmblocksize(dataptr);								// get current size of data block	newsize = numfiles + 1;												// calculate new size of data block		if (_IGT_(newsize, currentsize)) {									// not enough room in current data block - make new one		if (! (newmblock(newptr,newsize,true) & 1))						// create new data block			return (false);												// no more room for new block					readmblock(treeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;					// get data pointer in case it moved				copymblock(dataptr,mem_data,									// copy over data before the insert point		newptr, mem_data,		insertpt);	}	else {																// there is enough room in current data block		newptr[0] = dataptr[0]; newptr[1] = dataptr[1];					// use it	}			copymblock(dataptr,mem_data + insertpt,								// move data after insert point to make room for new index	newptr, mem_data + insertpt + 1,	numfiles - insertpt);		writemblock(newptr,mem_data + insertpt);	_write_63(filelistindex);											// write new file list index		if (_IGT_(newsize, currentsize)) {									// a new block was created		disposemblock(dataptr);											// dispose of old data block		attach_data_block(treeptr,newptr);								// attach new data block to tree	}			writemblock(newptr,mem_used);	_write_63(numfiles + 1);											// another file added to list	return (true);														// index added}	static	boolean	save_file_list_add_file_to_categories(					// add this file index to all of it's categories	fixed	filetreeptr[], 												// pointer to file's tree block	fixed	filelistindex, 												// index of file in file list	file	f)															// input file{	static	fixed	catcount;											// no. categories in file's list of categories	static	fixed	cattreeptr[ptr_len];								// pointer to category's tree block	static	fixed	catdataptr[ptr_len];								// pointer to category's data block	static	fixed	filedataptr[ptr_len];								// pointer to file's data block	static	fixed	filecount;											// no. files in category's list of files	static	fixed	insertpt;											// insert point in category's list of files	static	fixed	index;												// index of a category in file's list of categories	static	fixed	i;		if (debug) { print("Adding file to categories\n");}			readmblock(filetreeptr,mem_ptr);	filedataptr[0] = _read_63; filedataptr[1] = _read_63;				// get pointer to file's data block		if ((filedataptr[0] == mnullptr[0]) && (filedataptr[1] == mnullptr[1]))// no data block		catcount = 0;													// this file has no categories - should never happen, right?	else {																// get no. categories		readmblock(filedataptr,mem_used);		catcount = _read_63;											// get the no. categories in file's list of categories		index = mem_data + l_rec_length;								// index of first category pointer	}			for (i = 0; i < catcount; i++) {									// loop over categories																		// don't use filedataptr instead following read																		// - the heap may have been compacted, leaving																		// filedataptr a dangling ptr!		readmptrblock(filetreeptr,mem_ptr,index);		cattreeptr[0] = _read_63; cattreeptr[1] = _read_63;				// get pointer to category's tree block				readmblock(cattreeptr,mem_ptr);		catdataptr[0] = _read_63; catdataptr[1] = _read_63;				// get pointer to category's data block		readmblock(catdataptr,mem_used);		filecount = _read_63;											// get the no. files in category's list of files				if (f == nullf) {												// no input file - must be creating index file from scratch			insertpt = filecount;										// add new file at end of list		}		else {															// using file list, so find where to put this file			insertpt = 0;												// start at beginning of list			readmblock(catdataptr,mem_data);			while ((_ILT_(insertpt, filecount)) && (_ILT_(_read_63, filelistindex))) {	// loop until insert point is found				insertpt = insertpt + 1;			}		}					if (! (save_file_list_insert_index(cattreeptr,catdataptr,filecount,filelistindex,insertpt) & 1))			return (false);												// not enough room to insert index					index = index + ptr_len;										// go to next category pointer	}																	// looping over categories			return (true);														// file added}	static	void	save_file_list_save_data_block(							// save data block to disk	fixed	treeptr[], 													// pointer to tree node	fixed	index, 														// index of file in file list	file	f)															// file to use{	static	fixed	record[l_rec_length];								// room for file list record	static	fixed	i;	#pragma unused (index)		readmptrblock(treeptr,mem_ptr,mem_data);	for (i = 0; i < l_rec_length; i++) {								// read file information from data block		record[i] = _read_63;	}			fwrite(record,shl(l_rec_length,1),1,f);								// write out record to index file}	static	boolean	save_file_list(											// save file list to disk	file	infile, 													// input file	file	outfile)	_recursive	_swap								// output file{	boolean			more_nodes;											// True if there are more nodes in tree to process	boolean			more_files;											// True if there are more file list records to process	boolean			validnode;											// True if node has not been deleted	fixed			filecount;											// no. file list records output to file	fixed			fileptr[ptr_len];									// pointer to file's tree block	fixed			listname[l_name_max + 1];							// name of file in file list	fixed			listrecord[l_rec_length];							// informaton from file list	fixed			updatetime;											// last update time	fixed			msw, lsw;	fixed			i, c, count;		/* Main procedure */		/* calculate start of file list area and seek there */		msw = gbuf(h_ms_dirstart) + gbuf(h_ms_dirlen);						// file list starts right after file list index	lsw = gbuf(h_ls_dirstart) + gbuf(h_ls_dirlen);	if (_ILT_(lsw, gbuf(h_ls_dirstart))) msw = msw + 1;			pbuf(h_ls_datastart,lsw);											// store start of file list	pbuf(h_ms_datastart,msw);		seek(outfile,lsw,3);												// seek to starting point		/* save all records in file list to disk, updating the category list */		more_nodes = treetraverse(filetree,true,fileptr);					// get first node in tree	if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack		return (false);													// die			filelistrec = 0;													// start at first record in file list	filelistmax = i_filecount;											// total no. records in file list	more_files = save_file_list_get_next_file(infile,listname,listrecord);	// get first file list record	if (more_files & 1) totalfiles = totalfiles + i_filecount;			// add the files already in the file list			updatetime = real_milliseconds;										// show initial update message		filecount = 0;														// no records saved yet	count = 0;															// no files processed yet	while ((more_nodes & 1) || (more_files & 1)) {						// loop until both the tree and the file list have been completely traversed			timeshare_with_host();				if ((more_nodes & 1) && (more_files & 1))						// both lists have not been completely traversed			c = compareblock(fileptr,tree_key,listname);				// compare the file names		else if ((more_nodes & 1) && (! (more_files & 1)))				// file list has been traversed, so add everything else in tree			c = -1;		else if ((! (more_nodes & 1)) && (more_files & 1))				// tree has been traversed, so copy everything else in file list			c = 1;					if (debug) { print("%s%6d%6d%6d\n", "Mode_Nodes, More_Files, c = ", more_nodes, more_files, c);}					if (c < 0) {													// file in tree is not in file list, so add it to file list			readmblock(fileptr,mem_used);			validnode = (_read_63 != -1);								// True if this node has not been deleted						if (validnode & 1) {										// add this entry				if (infile != nullf) {									// make room for new node if file list present					if (! (save_file_list_update_categories(-1,filecount,1) & 1))// could not update them						return (false);				}									if (! (save_file_list_add_file_to_categories(fileptr,filecount,infile) & 1))// add this file index to all of it's categories					return (false);									if (debug) { print("Saving data block\n");}									save_file_list_save_data_block(fileptr,filecount,outfile);	// save node's data block to index file				filecount = filecount + 1;								// another record saved			}							more_nodes = treetraverse(filetree,false,fileptr);			// get next node from tree			if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack				return (false);											// die		}					else if (c == 0) {												// file in tree is the same as the one in the file list, so deal with update			readmblock(fileptr,mem_used);			validnode = (_read_63 != -1);								// True if this node has not been deleted						if (validnode & 1) {										// add this entry				if (debug) { print("Replacing file\n");}				if (! (save_file_list_update_categories(filecount,-1,0) & 1))// delete all current references to this file					return (false);										// could not update for some reason									if (! (save_file_list_add_file_to_categories(fileptr,filecount,infile) & 1))// add this file index to all of it's categories					return (false);										// could not add file to categories									save_file_list_save_data_block(fileptr,filecount,outfile);	// save node's data block to index file				filecount = filecount + 1;								// another record saved			}			else {														// delete this entry				if (! (save_file_list_update_categories(filecount,filecount,-1) & 1))// delete all current references to this file and shift pointers up					return (false);										// could not update			}							more_nodes = treetraverse(filetree,false,fileptr);			// get next node from tree			if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack				return (false);											// die			more_files = save_file_list_get_next_file(infile,listname,listrecord);	// get next file		}					else {															// file in file list is not in tree, so just copy to output file			fwrite(listrecord,shl(l_rec_length,1),1,outfile);			// save record to file list			filecount = filecount + 1;									// another record saved			more_files = save_file_list_get_next_file(infile,listname,listrecord);	// get next file		}					count = count + 1;												// another file processed				if (debug) { print("%s%6d\n", "FileCount = ", filecount);}		if ((real_milliseconds >= updatetime) && (! (debug))) {			// time to display update message			display_update_status(3,count,totalfiles);			updatetime = real_milliseconds + updateinterval;			// next update time		}	}			if (! (debug)) 		display_update_status(3,count,totalfiles);						// display final update status			// calculate file list parameters		_write_5(filecount);												// calculate the no. words used	_write_6(l_rec_length);												// words used = no. records * record length	XPL_write(0324, _read_5);		i = words_to_secs( _read_4, _read_5);								// convert to sectors		/* update file list fields in header */		pbuf(h_ls_datalen,i);												// sector length of file list	pbuf(h_ms_datalen,0);		pbuf(h_filecount,filecount);										// no. records in file list		if (debug) {		print("%s", "Enter 1 to display trees, 0 to continue");//input i;		if (i == 0) return (true);		print("\n");		print("Category Tree:\n");		print_tree(cattree,false);//input i;	}			return (true);														// file list saved}	static	boolean	save_category_list(										// save category list to disk	file	outfile)	_recursive	_swap								// output file{    fixed			_upper0;	fixed			treeptr[ptr_len];									// pointer to tree block	fixed			dataptr[ptr_len];									// pointer to data block	boolean			more_nodes;											// True if there are more nodes to print	fixed			reclen;												// length of category record	fixed			namelen;											// no. characters in category name	fixed			numfiles;											// no. files in this category	fixed			catcount;											// no. category list records output to file	fixed			msw, lsw;											// no. words written out	fixed			names[h_namelinemax + 1];							// array to store names/line values	fixed			updatetime;											// last update time	fixed			i, count;		/* calculate start of category list area and seek there */		msw = gbuf(h_ms_datastart) + gbuf(h_ms_datalen);					// category list starts right after file list	lsw = gbuf(h_ls_datastart) + gbuf(h_ls_datalen);	if (_ILT_(lsw, gbuf(h_ls_datastart))) msw = msw + 1;			pbuf(h_ls_catstart,lsw);											// store start of category list	pbuf(h_ms_catstart,msw);		seek(outfile,lsw,3);												// seek to first sector of category list		/* save all category records to disk */	    for (i = 1; i <= h_namelinemax; i++) {		names[i] = 0;													// no lines used yet	}			more_nodes = treetraverse(cattree,true,treeptr);					// get first node	if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack		return (false);													// die			updatetime = real_milliseconds;										// show initial update message		catcount = 0;														// no category records saved yet	count = 0;															// no categories processed yet	msw = 0; lsw = 0;													// no words saved yet	while (more_nodes & 1) {			timeshare_with_host();				readmblock(treeptr,mem_ptr);		dataptr[0] = _read_63; dataptr[1] = _read_63;					// get pointer to data block		readmblock(dataptr,mem_used);		numfiles = _read_63;											// get the no. files in the list				if (numfiles != 0) {											// not a null category			readmblock(treeptr,tree_key);			namelen = _read_63;											// get no. characters in category name						reclen = shr(namelen + 1,1) + numfiles + 4;					// calculate no. words category record																					// Write Category Record to disk						putw(reclen,outfile);										// store forward pointer						putw(namelen,outfile);										// store length of category name						for (_upper0 = shr(namelen + 1,1), i = 1; i <= _upper0; i++) {	// store category name				readmblock(treeptr,tree_key + i);				putw( _read_63, outfile);			}							putw(numfiles,outfile);										// store no. file pointers						for (i = 0; i < numfiles; i++) {							// write out file pointers				readmblock(dataptr,mem_data + i);				putw( _read_63, outfile);								// store updated index			}							putw(reclen,outfile);										// store back pointer						catcount = catcount + 1;									// count the no. records output						lsw = lsw + reclen;											// count the no. words output			if (_ILT_(lsw, reclen)) msw = msw + 1;				            for (i = 1; i <= h_namelinemax; i++) {						// add on the lines used by this category for all names/line values				_write_5(numfiles);				_write_7(i);											// divide no. files by no. files/line				names[i] = names[i] + _read_5 + (_read_4 != 0);			// store no. lines required			}		}					more_nodes = treetraverse(cattree,false,treeptr);				// get next node in tree		if ((! (more_nodes & 1)) && (s_sensekey == s_good) && (c_status == e_stack_full))// blew the stack			return (false);												// die					count = count + 1;												// another category processed				if ((real_milliseconds >= updatetime) && (! (debug))) {			// time to display update message			display_update_status(4,count,totalcats);					// display status			updatetime = real_milliseconds + updateinterval;			// next update time		}	}			if (! (debug)) 		display_update_status(4,count,totalcats);						// display status			// calculate category list parameters		i = words_to_secs(msw,lsw);											// convert no. words to sectors		/* update category list fields in header */		pbuf(h_ls_catlen,i);												// sector length of category list	pbuf(h_ms_catlen,0);		pbuf(h_catcount,catcount);											// no. category records in category list	for (i = 0; i < h_namelinemax; i++) {								// store no. lines required for file names in category list		pbuf(h_catlines + i,names[i + 1]);	}			return (true);														// category list saved}	static	void	save_file_list_index(									// create file list index	file	infile, 													// input file	file	outfile)	_recursive	_swap								// output file{	fixed			indexentries;										// no. entries in file list index	fixed			stride;												// stride of file list index (no. records skipped between each entry)	fixed			increment;											// no. bytes needed to skip to the next record	fixed			filecount;											// no. files in file list	fixed			i, j, k, count;		_write_5(gbuf(h_ls_dirlen));										// get no. sectors in file list index	_write_6(256);														// no. words = no. sectors * 256	XPL_write(0324, _read_5);	_write_7(l_name_max);												// divide by the word length of the file names	indexentries = _read_5;												// store the no. entries in the file list index		if (debug) {		print("%s%6d%s%6d%s\n", "File List Index starts at ", gbuf(h_ls_dirstart), ", contains ", indexentries, " entries");		print("%s%6d%s%6d%s\n", "File List starts at ", gbuf(h_ls_datastart), ", contains ", gbuf(h_filecount), " entries");	}			_write_5(gbuf(h_filecount));										// calculate file list index stride	_write_7(indexentries);												// index stride = no. records / no. file list index entries	stride = _read_5;													// store stride	i = _read_4;														// store remainder	if (stride == 0) stride = 1;										// FileCount < IndexEntries, so index every file	else if (_IGE_(i, shr(indexentries,1))) stride = stride + 1;		// round up			if (debug) {		print("%s%6d\n", "Stride = ", stride);		print("Here we go...\n");	}			seek(infile,gbuf(h_ls_datastart),3);								// seek to first sector of file list	seek(outfile,gbuf(h_ls_dirstart),3);								// seek to first sector of file list index		increment = shl(stride * l_rec_length - l_name_max,1);				// no. bytes to skip ahead each time	filecount = gbuf(h_filecount);										// get the no. files in the file list	count = 0;															// nothing in file list index yet	i = 0;	while (_ILT_(i, filecount)) {										// loop over file list records			timeshare_with_host();				if (_ILT_(count, indexentries)) {   		for (j = 1; j <= l_name_max; j++) {								// copy name to file list index				k = getw(infile);										// get word from file list				putw(k,outfile);										// store in file list index			}							seek(infile,increment,1);									// seek to next record			count = count + 1;											// count no. items in file list index		}		i = i + stride;													// skip to next file	}			if (debug) { print("%6d%s\n", count, " entries saved to index file ");}		   		for (i = (count + 1); i <= indexentries; i++) {					// pad remaining entries   		for (j = 1; j <= l_name_max; j++) {								// set all bits in name, so nothing will be greater than it			putw(-1,outfile);		}	}			pbuf(h_stride,stride);												// store stride value	}	static	boolean	update_index_file_open_index_file(						// open index file	fixed	name[], 													// treename of index file	fixed	indexpath[])												// the path to .INDEX	{	if ((read_catalog(indexpath,1) & 1) && (findmax() & 1)) {			// read index subcat and find largest block		// Limit index file to 32 megs to avoid FileI IO bugs with index files greater than		// 32 megs in size				if ((f_ms_length != 0) || (_IGT_(f_ls_length, -256)))		{ 	f_ms_length = 0; f_ls_length = -256; }					if ((f_ls_length & 0x00FF) == 0)  {								// sector length is a multiple of 256			if (f_ls_length == 0) f_ms_length = f_ms_length - 1;			f_ls_length = f_ls_length - 1;								// subtract one so FILEIO doesn't barf on this file		}					if (replace(name, t_index, f_ms_length, f_ls_length, shl(f_ls_length,8), 1) & 1) {	// room for this file			if (catlist != nullf) catlist = close_file(catlist);		// close up file variable			catlist = open_file(name,i_w,catlistbuf,catlistmed,catlistlen);	// try to open this file for output			if (catlist != nullf) {										// file opened successfully				return (true);											// output file is ready to go			}		}	}			return (false);														// output file not ready to go}	static	boolean	update_index_file_close_index_file(						// close index file	fixed	name[], 													// treename of index file	boolean	oldindex, 													// True if old index file was around	fixed	origname[])													// treename of original index file	{	static	fixed	filename[f_name_len + 1];							// space for file name	static	fixed	msw, lsw;	static	fixed	i;		filelist = close_file(filelist);									// close input file	catlist = close_file(catlist);										// close output file		msw = gbuf(h_ms_catstart) + gbuf(h_ms_catlen);						// find no. sectors used in index file	lsw = gbuf(h_ls_catstart) + gbuf(h_ls_catlen);	if (_ILT_(lsw, gbuf(h_ls_catstart))) msw = msw + 1;			if ((lsw & 0x00FF) == 0)  {											// sector length is a multiple of 256		lsw = lsw + 1;													// add one so FILEIO doesn't barf on this file		if (lsw == 0) msw = msw + 1;	}			if (truncate(name, msw,lsw,shl(lsw,8),1) & 1) {						// truncate index file		if (! (oldindex & 1)) {											// no old index file			return (true);												// index file closed successfully		}		else {															// get rid of old index file			if (XPLdelete(origname, 1) & 1) {							// delete old index file   		for (i = 0; i <= f_name_len; i++) {								// get name for index file					filename[i] = o_volume_name[i];				}				if (filename[0] > shl(f_name_len,1)) filename[0] = shl(f_name_len,1);	// truncate name, if neccessary				if (rename_able_file(name, filename, 1) & 1) {			// rename new index file to be old index file					return (true);										// successfully closed and renamed				}			}		}	}			return (false);														// could not close index file}	static	boolean			update_index_file(								// save index to disk	fixed	treename[], 												// array space for working treename	fixed	level)	_recursive	_swap									// optical disk level to use	{	fixed			tempname[16];										// array space for temp name	fixed			dirname[16];										// array space for dir name	fixed			origname[16];										// copy of original name	boolean			indexpresent;										// True if index file already present	boolean			found;	fixed			status;	fixed			i, j;		/* main procedure */		if (! (check_optical(level) & 1)) {									// optical not open and ready to go		if (! ((s_sensekey == s_good)		&& ((c_status == e_no_index) || (c_status == e_not_uptodate)) ))// continue if there is no index file or it is not up to date			return (false);												// some other problem, so die	}			if (! (treeinit(filetree) & 1 && treeinit(cattree) & 1))			// could not initialize trees		return (false);	stackinit();														// initialize stack	totalfiles = 0;														// no files in tree yet	totalcats = 0;														// no categories in tree yet		get_index_name(o_volume_name, treename);							// get treename of index file	get_index_name(o_volume_name, origname);							// in two places...	get_index_directory_name(dirname);									// and the directory name...		found = locate (treename, 1);										// see if exists in :.INDEX		if (found == false)													// not there: check :.INDEX1	{		status = c_status;												// save error about .INDEX				get_index1_name(o_volume_name, treename);						// get treename of index1 file		get_index1_name(o_volume_name, origname);		get_index1_directory_name(dirname);				found = locate (treename, 1);									// if that exists				if (found == false)												// not there neither		{			if ((c_status == e_no_file)									// if .INDEX1 exists but specific .index file is missing			&&  (status   == e_no_path))								// and .INDEX subcatalog is missing				;														// then leave set up to use .INDEX1							else 														// else revert to .INDEX for normal use			{				get_index_name(o_volume_name, treename);				// get treename of index file				get_index_name(o_volume_name, origname);				// in two places...				get_index_directory_name(dirname);						// and the directory name...			}		}	}			c_status   = 0;														// toss bogus stati from index	s_sensekey = 0;														// file search		/* change working name of .index file to a temp name (with _ in it) while we				*/	/* construct the new index.  That way it won't be used if we bomb during the				*/	/* update...																									*/		indexpresent = (filelist != nullf);									// True if index file already exists (hopefully is the one we just located!!!)	if (indexpresent & 1) {												// index file already exists		if (i_entrycount == o_entrycount) return (true);				// nothing has has changed					if (i_catcount != 0) {											// need to read in current categories			if (! (get_category_list(filelist) & 1))					// read category list out of index file and into a balanced binary tree				return (false);											// could not do it for some reason		}					seek(filelist,i_filestart,3);									// seek to first sector of file list				pbyte(treename, treename[0] - 1, a_score);						// change last character to underscore	}	else i_entrycount = 0;												// no index file at all			if (get_updates(level) & 1) {										// get new directory entries from optical disk and put into tree				if (update_index_file_open_index_file(treename, dirname) & 1) {	// index file opened for output			initialize_header(level,o_entrycount);						// set up header						if (! (save_file_list(filelist,catlist) & 1))				// save and update file list				return (false);							if (! (save_category_list(catlist) & 1))					// save category list				return (false);							fflush(catlist);											// flush output buffer to disk						if (filelist != nullf) filelist = close_file(filelist);		// close up file variable			filelist = open_file(treename,i_r,filelistbuf,filelistmed,filelistlen);	// try to open output file for input						if (filelist != nullf) {									// file opened successfully								save_file_list_index(filelist,catlist);					// save file list index								save_header(catlist);									// save updated header								if (update_index_file_close_index_file(treename,indexpresent, origname) & 1) {	// file closed successfully					if (open_optical(treename,level) & 1) {										// open volume again to set up for new index file																														// Set bit to create a protocol event when the																								// index file has been updated:												new_poly_contents = new_poly_contents | 8;												return (true);															// success!!!!					}				}			}		}																// index file opened					i = c_status;													// store catalog error status		j = s_sensekey;													// store sense key status				get_index_name(o_volume_name,tempname);							// get treename of index file		pbyte(tempname,tempname[0] - 1,a_score);						// set last character to underscore		XPLdelete(tempname,1);											// delete temporary file if it is still around				get_index1_name(o_volume_name,tempname);						// get treename of index file		pbyte(tempname,tempname[0] - 1,a_score);						// set last character to underscore		XPLdelete(tempname,1);											// delete temporary file if it is still around				c_status = i;													// restore original error status		s_sensekey = j;	}																	// adding new directory entries			return (false);														// index file not created}fixed			recnum;													// record number of entry in file list	/*      printstr: proc(s);	         dcl s fixed array;	         dcl (i,c) fixed;		         do i = 0 to shl(l#name_max,1) - 1;	            c = byte(loc(addr(s(0)) - 1),i);	            if (c ige a.SP) and (c ile l.z)	            then print chr(c),;	            else print '*',;	         end;	      end printstr; */	static	fixed	index_locate_comparenames(								// compare names	fixed	name1[],	fixed	name2[])													// names to compare{	static	fixed	i;		for (i = 0; i < l_name_max; i++) {									// loop over all characters in name		if (_ILT_(rot(name1[i],8), rot(name2[i],8))) return (-1);		// less than		else if (_IGT_(rot(name1[i],8), rot(name2[i],8))) return (1);	// greater than	}			return (0);															// equal}	static	fixed	index_locate_binarysearch(								// do binary search on index buffer	fixed	source[], 													// file name to search for	fixed	contender[])												// array space for contender name{	static	fixed	total;												// total no. records in database	static	fixed	first;												// first record	static	fixed	indexbase;											// byte base of file list index	static	fixed	i, c;		indexbase = shl(i_indexstart,8);									// first word of file list index in index file	seek(catlist,i_indexstart,3);										// seek to first sector of file list index	i = getw(catlist);													// get a word to prime the buffer		first = 0;															// Start at the first entry	total = i_indexcount;												// search all entries	while (total != 0) {												// Repeat until entire area has been searched			timeshare_with_host();				i = first + shr(total,1);										// find midpoint entry				seek(catlist,shl(indexbase + i*l_name_max,1),0);				// seek to first word of name		fread(contender,shl(l_name_max,1),1,catlist);					// get name				c = index_locate_comparenames(source,contender);				// compare name to the one in the index buffer				if (c == 0) {													// source = contender			return (i + 1);												// return entry location		}		else if (c > 0) {												// source > contender			first = i + 1;												// start at next record			total = total - 1;		}					total = shr(total,1);											// half the area has now been searched	}			return (first);														// return entry location to start linear search at}	static	boolean			index_locate(									// locate file using index file	fixed	name[], 													// name to look for	fixed	record[], 													// array space to return record in	fixed	level)	_recursive	_swap									// level number of optical device{    fixed			_upper0;	fixed			target[l_name_max];									// formatted target to look for	fixed			i, j, c;		/* Main procedure */		s_sensekey = s_good;												// assume no error will occur	c_status = e_none;	recnum = 0;		if (check_index() & 1) {											// index file opened				for (_upper0 = shl(l_name_max,1) - 1, i = 0; i <= _upper0; i++) {	// loop over all possible characters in name			if (i < name[0]) {											// valid name character				c = byte(name,i);										// get character of name				if ((c >= l_a) && (c <= l_z)) c = c - 0x0020;			// make upper case			}			else c = 0;													// insert a null			pbyte(_location_(&(target[0]) - 1),i,c);					// add character to target name		}					i = index_locate_binarysearch(target,record);					// search for this name in the file list index				if (i != 0) {													// name might be in file list - let's find out						_write_5(i - 1);											// compute record to start search on			_write_6(i_stride);											// record location = buffer index * stride			recnum = _read_5;											// search will be started at this record			_write_6(l_rec_length);										// word location = record location * record length in words			XPL_write(0324, _read_5);			_write_7(256);												// sector = words / 256						i = _read_5;												// store sector			j = _read_4;												// store word in that sector						seek(filelist,i_filestart + i,3);							// seek to this sector			seek(filelist,shl(j,1),1);									// seek to byte in this sector						c = -1;														// get into loop at least once			while ((c < 0) && (_ILT_(recnum, i_filecount))) {			// loop while new names are less than target name				fread(record,shl(l_rec_length,1),1,filelist);			// get record				c = index_locate_comparenames(_location_(&(record[l_name])),target);	// compare names				if (c != 0) recnum = recnum + 1;						// next record			}							if (c == 0) {												// file found				f_ms_sector = (shl(level,8) | record[l_ms_secstart]);	// set up file variables				f_ls_sector = record[l_ls_secstart];				f_ms_length = record[l_ms_seclen];				f_ls_length = record[l_ls_seclen];				f_words = record[l_ls_wordlen];				f_type = record[l_file_type];								return (true);											// file found			}		}					c_status = e_no_file;											// set appropriate status		recnum = 0;	}			return (false);														// file not found}	static	boolean			index_replace(									// replace on optical	fixed	name[], 													// name of file	fixed	type, 														// type of file	fixed	ms_len,	fixed	ls_len, 													// size of file in sectors	fixed	wordlen, 													// size of file in words (mod 64K)	fixed	header[], 													// sound file header	fixed	record[], 													// array space to use	fixed	level)	_recursive	_swap									// level to replace on{	fixed			entry;	boolean			found;		s_sensekey = s_good;												// assume no error will occur	c_status = e_none;		if (! (check_optical(level) & 1)) {									// optical not open		if (! ((s_sensekey == s_good) && (c_status == e_not_uptodate)))	// something other than index file not up to date			return (false);												// die	}			found = index_locate(name,record,level);							// file to delete was found	if ((found & 1) || ((! (found & 1)) && (c_status == e_no_file))) {	// no bizarre errors occured		if (found & 1)													// file already exists			entry = record[l_dir_entry];								// get most recent directory entry		else entry = -1;												// no directory entry for this file					if (optical_replace(name,type,ms_len,ls_len,wordlen,header,entry,level) & 1) {	// replace file on optical			return (true);												// delete record inserted		}	}			return (false);}	static	boolean			index_delete(									// delete file using index file	fixed	name[], 													// name to delete	fixed	record[], 													// record array space	fixed	level)	_recursive	_swap									// level of optical disk to delete on	{	s_sensekey = s_good;												// assume no error will occur	c_status = e_none;		if (! (check_optical(level) & 1)) {									// optical not open		if (! ((s_sensekey == s_good) && (c_status == e_not_uptodate)))	// something other than index file not up to date			return (false);												// die	}			if (index_locate(name,record,level) & 1) {							// file to delete was found				if (optical_delete(name,record[l_dir_entry],level) & 1) {			return (true);												// delete record inserted		}	}			return (false);														// delete record not inserted}	static	boolean			index_update(									// update file using index file	fixed	oldname[], 													// old name of file	fixed	newname[], 													// new name of file	fixed	header[], 													// new sound file header	fixed	record[], 													// record array space	fixed	level)	_recursive	_swap									// level of optical disk to rename on	{	s_sensekey = s_good;												// assume no error will occur	c_status = e_none;		if (! (check_optical(level) & 1)) {									// optical not open		if (! ((s_sensekey == s_good) && (c_status == e_not_uptodate)))	// something other than index file not up to date			return (false);												// die	}			if (index_locate(oldname,record,level) & 1) {						// old file name found				if (optical_update(oldname,newname,header,record[l_dir_entry],level) & 1) {	// update file on optical			return (true);												// update record inserted		}	}			return (false);														// rename record not inserted}static	void	init_optical_disk_stuff()	_recursive	_swap			// initialize stuff for Optical Disk and Index File routines{	fixed			base_optbuf;	fixed			flistbase;											// disk buffers for FILEIO	#define	flistlen		4											// to use when managing	fixed			clistbase;											// index files	#define	clistlen		4	fixed			stackbase;	fixed			membase;		if (find_device(10) != 0 || find_device(11)  != 0)	{				base_optbuf  =alloc_examount(2);		flistbase    =alloc_examount(flistlen);		clistbase    =alloc_examount(clistlen);				if (debugalloc) {			stackbase = alloc_examount(32);			definestack(stackbase,32);			//print 'Enter 0 to for external, 1 for poly memory',;//input MemBase;						if (membase == 1) {				membase = 0;											// start at beginning of poly memory				definemarea(0,0,membase,0,2048);			}			else {				membase = alloc_examount(2048);				definemarea(-1,0,membase,0,2048);			}		}					set_optbuf(base_optbuf,1);										// allocate space for optical disk buffer				definefilebuffers(flistbase, flistlen, 1, clistbase, clistlen, 1);				if (debugalloc) 			print("%s%6d%6d%6d%6d%6d\n", "Opt,FList,CList,Stack, Mem base = ", base_optbuf, flistbase, clistbase, stackbase, membase);	}	#undef	flistlen	#undef	clistlen}	/* Main program Variables: */static	fixed	name[h_name_max + 1];static	fixed	destserial;static	fixed	treename[101];static	fixed	catbuf[c_dir_max];static	boolean	ok;static	fixed	deststatbuf[stat_rec_length];static	fixed	opname[nam_buf_size_bytes/2 + 1];static	char	sensemes[MESSAGE_BUF_SIZE + 1];static	char	catmes[MESSAGE_BUF_SIZE + 1];static	char	statmes[200];static	fixed	whichdev;static	fixed	doit;static	fixed	gotit;static	fixed	i;static	fixed	complete;static	void	opupdate_main(){	examount = able_core(loc_emsize)	- able_core(able_core(1)+c_swplen);									// Get amount of external memory available		filelist = nullf;													// points at no file initially	catlist = nullf;													// points at no file initially	init_optical_disk_stuff();		XPL_enable_interrupts();		/* Main Program */		init_optical_controller();											// init controller		initialize_able_catalog_routines();	definestack(0,128);													// define stack in external memory	definemarea(-1,0,128,0,examount - 128);								// use remainder of external memory for update		complete = true;		doit  = false;	gotit = false;		while (doit == false || gotit == false)	{		if ((complete) != 0)		{			_clear_screen();			_pstringr ("Utility to update Optical Volume Index File.");			_crlf();			_pstringr ("Instructions:");			_pstringr ("   Press <RETURN> to construct or update the .INDEX file");			_pstringr ("                  for the Optical Volume shown below.");			_crlf();			_flush_term();						if (find_device(10) == 0 && find_device(11) != 0)				whichdev = 11;			else 				whichdev = 10;							if (find_device(10) != 0 && find_device(11) != 0)				_pstringr("   Press <SPACE> or <i> to select a different Optical Drive");			else 				_pstringr("   Press <SPACE> to update the information displayed");							_pstringr("   Press <BREAK> or Q to quit");						complete = false;		}					_pos(12, 0);				fetch_level_name(whichdev, opname);		statmes[0] = 0;				if (whichdev == 10)		{ 	_erase_line(); _pstring ("UPDATE: Optical Zero: \"O0:\"  "); _pablestringr(opname); }		else 		{ 	_erase_line(); _pstring ("UPDATE: Optical One : \"O1:\"  "); _pablestringr(opname); }					gotit = false;				if (readheader(whichdev) != 0)		{			get_file_name(h_name, h_name_max, name);					// get name from buffer			destserial = gbuf(h_serial);						if (get_statistics(whichdev, deststatbuf) != 0)			{				static	fixed	ms_tot, ls_tot, ms_used, ls_used, percent, megabytes_used;				static	fixed	ms_avail, ls_avail, megabytes_avail;								ms_used = deststatbuf[stat_ms_used];				ls_used = deststatbuf[stat_ls_used];								ms_avail = deststatbuf[stat_ms_free];				ls_avail = deststatbuf[stat_ls_free];								ms_tot = ms_used + ms_avail;				ls_tot = ls_used + ls_avail;				if (_ILT_(ls_tot, ls_used))					ms_tot = ms_tot + 1;									_write_5(ls_used);										// no. sectors used				_write_4(ms_used); ;				_write_7(2048);											// divide to get megabytes				megabytes_used = _read_5 + (_read_4 != 0);				// round up								_write_5(ls_avail);										// no. sectors used				_write_4(ms_avail); ;				_write_7(2048);											// divide to get megabytes				megabytes_avail = _read_5;								while (ms_tot != 0)				{					ls_tot  = shr(ls_tot,  1) | shl(ms_tot,  15);					ms_tot  = shr(ms_tot,  1);					ls_used = shr(ls_used, 1) | shl(ms_used, 15);					ms_used = shr(ms_used, 1);				}									_write_5(ls_used); _write_6(100); XPL_write(0324, _read_5); _write_7(ls_tot);				percent = _read_5;								_erase_line(); _pstring ("   Volume Name:    "); _pablestringr (name);				_erase_line(); _pstring ("   Serial Number:  "); _pnum(destserial, 6); _crlf();				_erase_line(); _pstring ("   Megabytes used: "); _pnum(megabytes_used, 6);				_pstring ("   ("); _pnum(percent, 2); _pstring ("% full)");				_pstring ("   Megabytes available: "); _pnum(megabytes_avail, 6); _crlf();								gotit = true;			}		}					if (gotit == false)		{			get_sense_code_message(s_sensekey, sensemes);			add_optical_sense_code_message(s_sensekey, sensemes);			get_cat_code_message(c_status,   catmes  );			add_optical_cat_code_message(c_status,   catmes  );						_erase_line(); _pstringr ("   Could not read volume header:");			_erase_line(); _pstring  ("      S$SenseKey = "); _pnum (s_sensekey, 6); _pstring ("  "); _pstringr(sensemes);			_erase_line(); _pstring  ("      C#Status   = "); _pnum (c_status,   6); _pstring ("  "); _pstringr(catmes  );			gotit = false;						copy_error_message("   Drive is not ready; see specific error message above", statmes);		}					if (gotit != 0 && statmes[0] == 0)			copy_error_message("   Press <RETURN> to start .INDEX file update", statmes);					_pos(17, 0);		_erase_line(); _pstringr ("Status:");		_erase_line(); _pstringr (statmes);				i    = _rchar();		doit = false;				if (i == a_refresh)			complete = true;					else if (i == a_sp && find_device(10) != 0 && find_device(11) != 0)			whichdev = whichdev ^ 1;					else if (i == a_i && find_device(10) != 0 && find_device(11) != 0)			whichdev = whichdev ^ 1;					else if (i == l_i && find_device(10) != 0 && find_device(11) != 0)			whichdev = whichdev ^ 1;					else if (i == a_q || i == l_q || i == 0)			return;					if (i == a_cr) doit = true;	}			_pos(20,0);	_flush_term();		ok = open_optical(treename,whichdev);								// try to open optical volume		if ((! (ok & 1)) && (s_sensekey == s_good)) {						// catalog error		if ((c_status == e_no_file)										// no index file or index file not up to date		|| (c_status == e_not_uptodate))			ok = true;													// ok to do update	}			if ((ok & 1) && (update_index_file(treename,whichdev) & 1)) {		_pstringr ("");		_pstringr ("   Update successfull - index file created");		_flush_term();	}	else {		get_sense_code_message(s_sensekey, sensemes);		add_optical_sense_code_message(s_sensekey, sensemes);		get_cat_code_message(c_status,   catmes  );		add_optical_cat_code_message(c_status,   catmes  );		_flush_term();		print("\n");		print("   Update failed:\n");		print("%s%6d%s%a\n", "      S$SenseKey = ", s_sensekey, "  ", sensemes);		print("%s%6d%s%a\n", "      C#Status   = ", c_status, "  ", catmes);	}		}