/* $title  FILEIO  Buffered File I/O a la C *//* Modification:     10/6/88 - CJ - fix in FREAD/FWRITE (optical disk trashing int mem)*//*	Translated to C:   	12/22/99 at 21:09	*//*	Translator Version:	0.000				*//* Fileio code *//* This module handles file input and output.  It is primarily used for text   files which have the following format:   <file>  := <line>*   <line>  := <line#> [<text>] <eol>   <line#> := 16-bit binary representation of the line number   <text>  := {A|B|C...Y|Z|a|b|c...y|z|0|1...8|9|$...}   <eol>   := null byte or null word   Designed and written by Karim J. Chichakly:  August 30, 1984   From original GET routines implemented by Betsy Wakeman:  July 16, 1984     WARNING:  These routines assume the logical end-of-file occurs within             the last 256-sector block of the file.   Notes:     1) Make use of accesses.  E.g., don't change word length unless open for append.           'r':  Read only (disallow all PUTs & SHUFFLE)           'w':  Write only (disallow all GETs); truncate if there, create if not           'a':  Append (disallow all GETs); position to end if there, create if not           'r+': Update - file MUST be there           'w+': Update - truncate if there, create if not           'a+': Update - position to end if there, create if not*/#include "XPL.h"#include "Literals.h"#include "Syslits.h"#include "Catrtns.h"#include "XPLASCIILit.h"#include "Fileio.h"#define	buffer_size			1024										// recommended file buffer size#define	max_files			4											// maximum number of files allowed openfixed			file_error;												// global file error indicator/* file status bits (in DIRTY) */#define	b_dirty				1											// if buffer's changed (dirty)#define	b_len				2											// length's changed (only when dirty)/* $page */static	fixed	ms_catalog[max_files];									// starting sector of catalog file is instatic	fixed	ls_catalog[max_files];static	fixed	cat_entry[max_files];									// catalog entry where file is locatedstatic	fixed	ms_start[max_files];									// starting sector of filestatic	fixed	ls_start[max_files];static	fixed	seclen[max_files];										// length of file in sectorsstatic	fixed	filelen[max_files];										// length of file in wordsstatic	fixed	secpos[max_files];										// current file position (sector)static	fixed	filepos[max_files];										// current file position (word)static	fixed	bufptr[max_files];										// pointer to our bufferstatic	fixed	bufmed[max_files];										// buffer medium (0: internal, 1: external, 2: poly)static	fixed	bufsiz[max_files];										// size of our bufferstatic	fixed	buflen[max_files];										// length of valid data in file bufferstatic	fixed	bufpos[max_files];										// character position in file bufferstatic	boolean	dirty[max_files];										// True if the file buffer has been changedstatic	fixed	extdata[4]; static	fixed	ms_sector;					// global current sector (never preserved)static	fixed	ls_sector;static	fixed	current_file[] = {8,0x2020,0x2020,0x2020,0x2020};		// canonical name of current file (must be 2N letters and lowercase)/* $subtitle Poly Memory Drivers */#define	mam					0x0030										// external memory sector address#define	mal					0x0031										// external memory word address#define	md					0x0032										// external memory#define	mdi					0x0033										// external memory then increment#define	r1					0x00C1										// register one#define	sub1				0x008D										// subtract from register one#define	repeat				write("10")=								// repeat macro#define	psc					0x006D										// write channel ##define	psf					0x006E										// write function code#define	psd					0x006F										// write data here#define	psx					0x006C										// write extended data here#define	pswma				16											// fc 16 - write memory address#define	psrma				20											// fc 20 - read memory  addressstatic	void	psmread(												// set up for poly synth memory read	fixed	msb,	fixed	lsb)	_recursive	{	msb = msb + shr(lsb, 8);											// normalize	lsb = (lsb & 0x00FF);		XPL_disable_interrupts();	XPL_write(0155, 0);													// select channel 0 for consistency	XPL_write(0156, psrma);												// read memory address fc	XPL_write(0157, msb);												// upper 16 bits	XPL_write(0157, lsb);												// lower  8 bits	XPL_enable_interrupts();}	static	void	psmwrite(												// poly synth memory write	fixed	msb,	fixed	lsb)	_recursive	{	msb = msb + shr(lsb, 8);											// normalize	lsb = (lsb & 0x00FF);		XPL_disable_interrupts();	XPL_write(0155, 0);													// select channel 0 for consistency	XPL_write(0156, pswma);												// write memory address fc	XPL_write(0157, msb);												// upper 16 bits	XPL_write(0157, lsb);												// lower  8 bits	XPL_enable_interrupts();}	static	void	polyset(												// set a chunk of poly memory	fixed	msb,	fixed	lsb,	fixed	len,	fixed	val)	_recursive	{    fixed			_upper0;	psmwrite (msb, lsb);												// set up poly for write		for (_upper0 = len, len = 1; len <= _upper0; len++) {				// write LEN words		XPL_write(0157, val);											// of VAL	}}	/* $subtitle Internal Buffer Management Routines *//* This procedure computes the last logical sector in file F (rounded up).     The last logical word (plus one) is FILELEN; the last physical sector     is SECLEN; the last physical word is zero. */static	fixed	logical_eof(											// compute last logical sector (rounded up)	file	f)															// file to determine logical EOF of	{	if (seclen [f] == 0)												// see if empty file (this is the only anomaly)		return (0);														// if so, the logical end is sector zero	else return (((seclen [f] - 1) & ((fixed) 0xFF00)) + shr(filelen [f], 8) + ((filelen [f] & 0x00FF) != 0));	// else compute it}		/* This procedure updates file F's catalog entry if necessary. */static	void	update_cat(												// update catalog entry for file F	file	f)	_recursive												// file to update{	fixed			fcb[f_len];											// catalog FCB		if (cat_entry [f] < 0) return;										// ignore current file (until accesses are implemented)			readcat (ms_catalog [f], ls_catalog [f], (((cat_entry [f] + 1)*c_len + 255) & (~ 0x00FF)), 0, 0);	// read in its catalog	get_fcb (cat_entry [f], fcb);										// get its FCB		ms_sector = c_ms_sector + fcb [f_ms];								// get starting sector	ls_sector = c_ls_sector + fcb [f_ls];	if (_ILT_(ls_sector, c_ls_sector)) ms_sector = ms_sector + 1;			if ((ms_sector == ms_start [f]) && (ls_sector == ls_start [f]) && (fcb [f_ml] == 0)// if it's the same file	&& ((seclen [f] != fcb [f_ll]) || (filelen [f] != fcb [f_wd]))) {	// if the sector or file length has changed, update the catalog		fcb [f_ll] = seclen [f];										// update sector length		fcb [f_wd] = filelen [f];										// update file length		put_fcb (cat_entry [f], fcb);									// and put it back				write_catalog();												// write the catalog back out	}																	// of updating the catalog}		/* This procedure flushes file F's buffer if it's been modified. */#define __location__(a) &(ABLE_CONTEXT._able_memory_[(ufixed) (a)])static	void	flush(													// flush the current buffer for file F	file	f)	_recursive												// file to flush the buffer of	{	if (dirty [f] & 1) {												// flush the buffer if necessary		ms_sector = ms_start [f];										// determine where the buffer was read from		ls_sector = ls_start [f] + (secpos [f] - shr(buflen [f] + 255, 8));		if (_ILT_(ls_sector, ls_start [f])) ms_sector = ms_sector + 1;					extdata [0] = bufptr [f]; extdata [3] = buflen [f];				// set up start and length		switch (bufmed [f]) {											// write out buffer			case 0:				writedata (ms_sector, ls_sector, __location__(bufptr [f]), buflen [f]);				break;			case 1:				extwrite  (ms_sector, ls_sector, extdata);				// external memory				break;			case 2:				polywrite (ms_sector, ls_sector, extdata, 0);			// poly memory				break;		}																// of write out buffer					if ((dirty [f] & b_len) != 0)									// if its length has changed			update_cat (f);												// update its catalog entry					dirty [f] = false;												// buffer now matches the disk	}																	// of flushing the buffer}/* $page *//* This procedure reads the next buffer from file F. */static	void	readbuf(												// read in the next buffer from the file F	file	f)	_recursive												// file to read the next buffer from	{	flush (f);															// write out any buffer changes		if ((_IGE_(secpos [f] + shr(bufsiz [f], 8), logical_eof (f)))		// check if we'll go past the logical EOF	&& ((_IGT_(filepos [f] + bufsiz [f], filelen [f])) || (_ILT_(filepos [f] + bufsiz [f], bufsiz [f]))))// be careful of wrapping around		buflen [f] = filelen [f] - filepos [f];							// restrict length to read (don't read past EOF)	else buflen [f] = bufsiz [f];										// we can read a whole buffer full			ms_sector = ms_start [f];											// find where next buffer is located	ls_sector = ls_start [f] + secpos [f];	if (_ILT_(ls_sector, ls_start [f])) ms_sector = ms_sector + 1;			extdata [0] = bufptr [f]; extdata [3] = buflen [f];					// set up start and length	switch (bufmed [f]) {												// read in next buffer		case 0:			readdata (ms_sector, ls_sector, __location__(bufptr [f]), buflen [f]);			break;		case 1:			extread  (ms_sector, ls_sector, extdata);					// external memory			break;		case 2:			polyread (ms_sector, ls_sector, extdata, 0);				// poly memory			break;	}																	// of read in next buffer			secpos [f] = secpos [f] + shr(buflen [f] + 255, 8);					// point past this buffer	filepos [f] = filepos [f] + buflen [f];								// move the word pointer as well	bufpos [f] = 0;														// reset character position		if (buflen [f] != bufsiz [f])										// zero out to the end of the buffer	switch (bufmed [f]) {												// (so PUTC works properly!)		case 0:			blockset (__location__(bufptr [f] + buflen [f]), bufsiz [f] - buflen [f] - 1, 0);			break;		case 1:			XPLextset(bufptr [f], buflen [f], bufsiz [f] - buflen [f] - 1, 0);			break;		case 2:			polyset  (bufptr [f], buflen [f], bufsiz [f] - buflen [f] - 1, 0);			break;	}																	// of zeroing out to end of buffer}	/* $page *//* This procedure reads the next buffer from file F.  It differs from     READBUF in that it will go past the logical end-of-file if the next     buffer goes past it.  This routine is used only by PUTC and PUTW     to allow you to APPEND to the file. */static	void	read_next(												// read the next bufferfull from file F (go past logical eof if necessary)	file	f)	_recursive												// pointer to file to read{	fixed			i;		if ((filepos [f] == filelen [f]) && (secpos [f] == logical_eof (f))) {	// check for logical end of file		filelen [f] = filelen [f] + 1;									// increase the length of the file by one word		dirty [f] = (dirty [f] | b_len);								// flag length change				if (buflen [f] == bufsiz [f])									// if we're now at the physical end of the buffer		{																// then read in the next buffer			readbuf (f);												// like so						switch (bufmed [f]) {										// zero the upper byte of the first word				case 0:					pbyte(__location__(bufptr [f] - 1), bufpos [f] + 1, 0);	// internal					break;				case 1:				{														// external					_write_60(bufptr [f]);								// point to start of buffer					_write_62((_read_62 & 0x00FF));						// toss out upper byte					break;				}														// external				case 2:				{														// poly					psmread (bufptr [f], 0);							// set up to read first word of buffer					i = (XPL_read(0157) & 0x00FF);						// toss out upper byte					psmwrite (bufptr [f], 0);							// set up to write first word					XPL_write(0157, i);									// write it					break;				}														// poly			}															// of zeroing upper byte of first word		}																// of read in the next buffer		else {															// otherwise move forward in current buffer			if ((filepos [f] & 0x00FF) == 0)							// are we entering an uncharted sector?				secpos [f] = secpos [f] + 1;							// yes, we need to increment the sector position							filepos [f] = filepos [f] + 1;								// increment the file (word) position			buflen [f] = buflen [f] + 1;								// increase the buffer length by one		}	}																	// of at eof	else readbuf (f);													// read the next bufferfull if not at end of file}	/* $subtitle FOpen, FClose, & SetBuf *//* This procedure opens a file and initializes file variables. */file			fopen(													// open a file	fixed	filename[], 	fixed	access[])	_recursive										// 'r' for read, 'w' for write, 'a' for append, 'r+' for read/append, 'w+' for read/write, 'a+' for write/append{	file			f;													// file descriptor for opened file	boolean			current;											// True if opening current file		#pragma unused (access)		if (filename [0] != current_file [0])								// if lengths don't match		current = false;												// not opening current file	else {																// may be opening current file		current = true; f = 1;											// assume opening current file				while (current & 1 && (f < shr(current_file [0], 1))) {			// check every word			if ((filename [f] | shl(0x0020, 8) | 0x0020) != current_file [f])// if this word doesn't match				current = false;										// no go			else f = f + 1;												// look at next word		}																// check every word	}																	// of may be opening current file			file_error = f_okay;												// no errors yet	f = nullf;															// assume we can't open the file		if (current & 1 || (locate (filename, 1) & 1 && ((f_ms_length & 0x00FF) == 0))) {	// we found it/it's not too big - open it up		f = 0;		while ((f < max_files) && (cat_entry [f] != -1)) {				// look for a free file descriptor			f = f + 1;		}					if (f == max_files) {											// if no free file descriptors			file_error = f_too_many;									// too many files open			f = nullf;		}		else {															// we found one			if (current & 1) {											// current file? don't allow write access				ms_catalog [f] = -1; ls_catalog [f] = -2; cat_entry [f] = -2;	// no catalog (-2 so it isn't considered free)				ms_start [f] = able_core(loc_csec + 1);					// ge origin				ls_start [f] = able_core(loc_csec);				seclen [f] = able_core(loc_csln);						// length				filelen [f] = able_core(loc_clen);						// word length			}															// of current file			else {														// opened file				ms_catalog [f] = c_ms_sector;							// remember catalog origin				ls_catalog [f] = c_ls_sector;				cat_entry [f] = findfile (f_name);						// and its catalog entry (FCB number)				ms_start [f] = f_ms_sector;								// remember file origin				ls_start [f] = f_ls_sector;				seclen [f] = f_ls_length;								// and length				filelen [f] = f_words;									// and word length			}															// of opened file							secpos [f] = 0; filepos [f] = 0;							// point to start of file			buflen [f] = 0; bufpos [f] = 0; dirty [f] = false;			// initialize buffer variables		}																// of found one	}																	// of opening it	else if ((f_ms_length & 0x00FF) != 0) file_error = f_too_big;		// file is too large to process	else file_error = f_no_file;										// file doesn't exist			return (f);															// return the associated file pointer}	/* $page *//* This procedure closes a previously opened file. */fixed			fclose(													// close a file	file	f)	_recursive												// pointer to file to read	{	if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			flush (f);															// flush the buffer if the buffer has changed		ms_start [f] = -1; ls_start [f] = -1; seclen [f] = 0; filelen [f] = 0; secpos [f] = 0; filepos [f] = 0;	// set file parameters to zero	cat_entry [f] = -1; buflen [f] = 0; bufpos [f] = 0;					// and buffer parameters		return (0);															// closed it okay}		/* This procedure sets the file buffer for the last opened file to     a buffer passed by the user of these routines. */fixed			setbuf(													// set the file buffer to a user's buffer - operates on last file opened ONLY	file	f, 															// file to set buffer for	fixed	buf, 														// the buffer in question	fixed	med, 														// medium of the buffer in question (0: internal, 1: external, 2: poly)	fixed	siz)	_recursive											// size of buffer in question	{	if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			if ((buflen [f] != 0) || ((buflen [f] == 0) && (secpos [f] != 0))	// have we read the file yet?	|| ((ms_start [f] == -1) && (ls_start [f] == -1))) {				// or is it closed?		file_error = f_bad_arg;		return (eof_mark);	}			bufptr [f] = buf;													// set the pointer	bufmed [f] = med;													// save the medium	bufsiz [f] = (siz & (~ 0x00FF));									// and the size (to nearest sector)		return (0);															// okay}	/* $subtitle FFlush & FEOF *//* This procedure flushes file F's buffer. */fixed			fflush(													// flush file F's buffer	file	f)	_recursive												// pointer to file to read	{	if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			flush (f);															// flush the buffer if the buffer has changed		return (0);															// done}		/* This procedure returns TRUE if we're at the end of file F, FALSE otherwise. */boolean			feof(													// return TRUE if at end-of-file	file	f)															// file to check	{	if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (true);	}			if (bufmed [f] == -1) {												// oops - no buffer		file_error = f_no_buffer;		return (true);	}			file_error = f_okay;												// clear the air		if ((filepos [f] == filelen [f]) && (secpos [f] == logical_eof (f)) && (bufpos [f] == shl(buflen [f], 1)))		return (true);													// at logical end-of-file	else return (false);												// not at end}	/* $subtitle GetC & GetW *//* This procedure reads a file into a buffer and returns the     next character or EOF mark (EOF_MARK) of the file. */fixed			getc(													// get next character from F	file	f)															// file to read{	static	fixed	theChar;											// character or EOF		if (feof (f) & 1)													// check for logical end of file		theChar = eof_mark;												// end of file	else {																// otherwise get next character		if (bufpos [f] == shl(buflen [f], 1)) readbuf (f);				// read the next bufferfull					theChar = shr(bufpos [f], 1);									// get word offset of next char				switch (bufmed [f]) {											// get word with next character in it			case 0:				theChar = able_core(bufptr [f] + theChar);				// internal				break;			case 1:			{															// external				_write_60(bufptr [f] + shr(theChar, 8));				// point to next word in buffer				_write_61(theChar);				theChar = _read_62;										// get it				break;			}															// external			case 2:			{															// poly				psmread (bufptr [f], theChar);							// set up to read next word				theChar = XPL_read(0157);								// get it				break;			}															// poly		}																// of get next character					if (bufpos [f] & 1)												// if looking for an odd byte			theChar = shr(theChar, 8);									// get next from upper		else theChar = (theChar & 0x00FF);								// even - keep lower					bufpos [f] = bufpos [f] + 1;	}			return (theChar);}	/* $page *//* This procedure returns the next word in a line or an EOF mark.     NOTE:  If the next word in the file is a -1, it will be returned     even though the EOF may not have been reached. */fixed			getw(													// get next word from F	file	f)															// pointer to file to read{	static	fixed	word;	static	fixed	temp;		if (bufpos [f] & 1) {												// if starting from an odd character, do it the hard way		word = getc (f);												// get first character				if (word != eof_mark) {											// if not at end			temp = getc (f);											// get second character						if (temp != eof_mark)										// if not at end				word = (word | shl(temp, 8));							// construct word			else word = eof_mark;										// else return EOF		}	}																	// of starting on an odd character	else {																// starting on a word boundary - do it FAST		if (feof (f) & 1)												// check for logical end of file			word = eof_mark;											// end of file		else {															// otherwise get next word			if (bufpos [f] == shl(buflen [f], 1)) readbuf (f);			// read the next bufferfull							switch (bufmed [f]) {										// get the next word				case 0:					word = able_core(bufptr [f] + shr(bufpos [f], 1));	// internal					break;				case 1:				{														// external					word = shr(bufpos [f], 1);							// get word offset					_write_60(bufptr [f] + shr(word, 8));					_write_61(word);					word = _read_62;									// get it					break;				}														// of external				case 2:				{														// poly					psmread (bufptr [f], shr(bufpos [f], 1));					word = XPL_read(0157);								// get it					break;				}														// of poly			}															// of get the next word							bufpos [f] = bufpos [f] + 2;		}	}																	// of on a word boundary			return (word);}	/* $subtitle FGetS *//* This procedure returns the next line of a file and the line number.      When it reaches the end of the file, it then returns an EOF mark.     NOTE:  The line# could be -1 and hence could be confused with the EOF. */fixed			fgets(													// get next line (and line #) from F	fixed	line[], 	fixed	maxline, 	file	f)	_recursive												// pointer to file to read{	fixed			number;	fixed			nword;	fixed			i;		number = getw (f);													// get line number		if (number != eof_mark) {											// if not at end of file		line [0] = 0;													// initialize the number of bytes in the line		i = 1;															// and the index into line		nword = getw (f);												// get first word				while (((nword & 0x007F) != 0) && ((nword & shl(0x007F, 8)) != 0) && ((nword & ((fixed) 0x8080)) == 0)) {	// look for valid text (both end-of-line and end-of-file are invalid text)			if (line [0] < maxline) {									// if we haven't exceeded the line length				line [i] = nword;										// save next word				line [0] = line [0] + 2;								// increase # of bytes stored				i = i + 1;												// point to next entry in LINE			}							nword = getw (f);											// get next character		}					if ((nword & ((fixed) 0xFF00)) == 0) {							// if we found an end-of-line, it's a text file			if ((nword & 0x00FF) != 0) {								// if one last byte				if (line [0] < maxline) {								// if we haven't gone over					line [i] = nword;									// save last byte					line [0] = line [0] + 1;							// increase # of bytes stored				}			}			if (line [0] > maxline)										// if we went a little too far (only one character max!)				line [0] = maxline;										// truncate down		}																// of valid text file		else {															// not a text file			file_error = f_bad_arg;										// invalid operation requested - cannot FGETS non-text files			number = eof_mark;											// return EOF		}	}																	// of not at end of file			return (number);													// return line number}	/* $subtitle PutC & PutW *//* This procedure writes the passed character to the specified file     at the current location.  The passed character is returned if we     succeed.  Otherwise, EOF_MARK is returned. */fixed			putc(													// put specified character to F	fixed	the_char, 														// the character to write	file	f)															// file to read{	static	fixed	i;		if (((! (feof (f) & 1)) && (file_error != f_okay))					// check for bad file descriptor	|| ((secpos [f] == seclen [f]) && (filepos [f] == filelen [f]) && (bufpos [f] == shl((buflen [f] + 255) & ((fixed) 0xFF00), 1))))// at physical eof?		the_char = eof_mark;											// we're at end of file	else {																// not at physical eof, write next character		if (bufpos [f] == shl(buflen [f], 1)) read_next (f);			// read the next bufferfull					the_char = (the_char & 0x00FF);									// make sure we save and return one character				switch (bufmed [f]) {											// write the next character			case 0:				pbyte(__location__(bufptr [f] - 1), bufpos [f], the_char);	// internal				break;			case 1:			{															// external				_write_60(bufptr [f] + shr(bufpos [f], 8 + 1));			// point to next word in buffer				_write_61(shr(bufpos [f], 1));								if (bufpos [f] & 1)										// if odd					_write_62((shl(the_char, 8) | (_read_62 & 0x00FF)));	// put in upper				else _write_62(((_read_62 & (~ 0x00FF)) | the_char));		// else put in lower				break;			}															// external			case 2:			{															// poly				psmread (bufptr [f], shr(bufpos [f], 1));				// set up to read containing word				i = XPL_read(0157);										// get it				psmwrite (bufptr [f], shr(bufpos [f], 1));				// set up to read containing word								if (bufpos [f] & 1)										// if odd					XPL_write(0157, (shl(the_char, 8) | (i & 0x00FF)));		// put in upper				else XPL_write(0157, ((i & (~ 0x00FF)) | the_char));		// else put in lower				break;			}															// poly		}																// of write the next character					bufpos [f] = bufpos [f] + 1;		dirty [f] = (dirty [f] | b_dirty);								// the buffer is now dirty	}																	// of not at physical eof			return (the_char);}	/* $page *//* This procedure writes the passed word to the specified file.  If we     succeed, the same word is returned.  Otherwise, EOF_MARK is returned.     NOTE:  If the word is -1, the procedure will return a -1 even though            it may not have reached an EOF mark.  It is therefore best to            use such constructs as IF PUTW (WORD, F) <> WORD instead of            the more obvious IF PUTW (WORD, F) = EOF_MARK which will            fail under some circumstances. */fixed			putw(													// put specified word to F	fixed	word, 														// word to write	file	f)															// pointer to file to read{	static	fixed	temp;		if (bufpos [f] & 1) {												// if starting from an odd character, do it the hard way		temp = putc (word, f);											// write out first character				if (temp != eof_mark)											// if not at end			temp = putc (shr(word, 8), f);								// write second character					if (temp == eof_mark)											// at end of file?			word = eof_mark;											// yes, return EOF_MARK	}																	// of starting on an odd character	else {																// starting on a word boundary - do it FAST		if (((! (feof (f) & 1)) && (file_error != f_okay))				// check for bad file descriptor		|| ((secpos [f] == seclen [f]) && (filepos [f] == filelen [f]) && (bufpos [f] == shl((buflen [f] + 255) & ((fixed) 0xFF00), 1))))// at physical eof?			word = eof_mark;											// we're at end of file		else {															// not at physical eof, write next word			if (bufpos [f] == shl(buflen [f], 1)) read_next (f);		// read the next bufferfull							switch (bufmed [f]) {										// store the next word				case 0:					set_able_core(bufptr [f] + shr(bufpos [f], 1), word);	// internal					break;				case 1:				{														// external					_write_60(bufptr [f] + shr(bufpos [f], 8 + 1));					_write_61(shr(bufpos [f], 1));					_write_62(word);									// put it					break;				}														// of external				case 2:				{														// poly					psmwrite (bufptr [f], shr(bufpos [f], 1));					XPL_write(0157, word);								// put it					break;				}														// of poly			}															// of store the next word							bufpos [f] = bufpos [f] + 2;			dirty [f] = (dirty [f] | b_dirty);							// the buffer is now dirty		}																// of not at physical eof	}																	// of on a word boundary			return (word);}	/* $subtitle FPutS *//* This procedure writes the passed line to the specified file.  If     we succeed, the passed line number is returned.  Otherwise, EOF_MARK     is returned.     NOTE:  Since -1 is a valid line number, there may be some confusion            regarding whether we've reached the end-of-file.  See the            comments under PUTW above. */fixed			seek(file, fixed, fixed);								// seek to a position in the filefixed			fputs(													// put specified line (and line #) to F	fixed	line[], 													// the line to write	fixed	number, 													// the line number to give said line	file	f)	_recursive												// pointer to file to write{	fixed			i;		if (putw (number, f) == number) {									// if not at end of file		i = 1;															// initialize the index into LINE				while ((i <= shr(line [0], 1)) && (number != eof_mark)) {		// look for end-of-line or end-of-file			if (putw (line [i], f) != line [i])							// try to write next word				number = eof_mark;										// couldn't do it; flag the end							i = i + 1;													// point to next word		}					if (number != eof_mark) {										// watch out for EOF			if (line [0] & 1)											// is number of bytes odd?				i = (line [i] & 0x00FF);								// yes, get last byte and EOL byte			else i = 0;													// no, get EOL word							if (putw (i, f) != i)										// write out the last word				number = eof_mark;										// oops, we're at the end		}					if (number == eof_mark) {										// if the entire line couldn't be written out			seek (f, -1, 1);											// try to clean up			putc (f, a_nul);											// by ending with a null		}																// of entire line couldn't be written	}																	// of not at end of file	else number = eof_mark;												// end of file			return (number);													// return line number}	/* $subtitle FFull *//* This procedure checks to see if writing the specified number of bytes     to the specified file will cause its file buffer to become full and     hence be flushed.  A boolean TRUE is returned if the buffer will be     flushed.  Otherwise, a boolean FALSE is returned. */boolean			ffull(													// see if this many bytes fills F's buffer	fixed	bytes, 														// number of bytes to write to the file	boolean	fputs, 														// True if we are going to call FPUTS with these bytes	file	f)	_recursive												// pointer to file to check{	fixed			pos;												// buffer lookahead pointer	boolean			full;												// True when the buffer's full		if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			file_error = f_okay;												// clear the air		if (fputs & 1) {													// if we are putting a line		bytes = bytes + 2 + 1;											// account for line number and end-of-line bytes				if (bytes & 1)													// number of bytes odd?			bytes = bytes + 1;											// make even - must end lines on word boundaries	}																	// of putting a line			pos = bufpos [f];													// pick up current buffer position	full = false;														// the buffer isn't full yet		while ((_ILT_(pos, bufpos [f] + bytes)) && (! (full & 1))) {		// loop until we've "written" all bytes (or buffer's full)		if (pos == shl(buflen [f], 1))									// if the buffer's full			full = true;												// remember it		else pos = pos + 1;												// "write" next byte	}																	// of "writing" all bytes			return (full);														// return whether the buffer's full}	/* $subtitle FRead & FWrite *//* This procedure reads a NUMBER of records of size SIZE bytes     from file F into BUFFER.  It returns the number of records     actually read. */fixed			fread(													// read one or more records from F	fixed	buf[], 														// buffer to read into	fixed	size, 														// size of record in bytes	fixed	number, 													// number of records to read	file	f)	_recursive												// pointer to file to read{    fixed			_upper0;	fixed			words;												// number of words to transfer	fixed			pos;												// current buffer word position	fixed			i, j;		number = size*number;												// calculate total bytes to transfer	words = shr(number, 1);												// calculate number of words to transfer	i = 0;																// initialize word counter		if (bufpos [f] & 1)													// if buffer position odd	while ((i < words) && (! (feof (f) & 1))) {							// transfer a word at a time		buf [i] = getw (f);		i = i + 1;	}																	// of transfer a word at a time (buffer position odd)			else while ((i < words) && (! (feof (f) & 1))) {					// buffer position even - blast the buffer over		if (bufpos [f] == shl(buflen [f], 1)) readbuf (f);				// read the next bufferfull					pos = shr(bufpos [f], 1);										// get word position				if ((words - i) <= buflen [f] - pos)							// if it's all in the buffer			j = (words - i);											// copy WORDS		else j = buflen [f] - pos;										// just get what's left in the buffer					switch (bufmed [f]) {											// get the next word			case 0:			{															// internal				fixed *where = __location__(bufptr [f] + pos);								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					buf [i] = *where++;				}														// of read it in				break;			}															// of internal							case 1:			{															// external				_write_60(bufptr [f] + shr(pos, 8));					// set up external memory pointer				_write_61(pos);								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					buf [i] = _read_63;				}														// of read it in				break;			}															// of external							case 2:			{															// poly				psmread (bufptr [f], pos);								// set up poly memory pointer								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					buf [i] = XPL_read(0157);				}														// of read it in				break;			}															// of poly		}																// of get the next word					bufpos [f] = bufpos [f] + shl(j, 1);							// bump up buffer position	}																	// of buffer position even - blast the buffer over			i = shl(i, 1);														// get bytes transferred		if (number & 1 && (! (feof (f) & 1))) {								// if an odd byte at the end		buf [shr(i, 1)] = getc (f);										// get last byte		i = i + 1;														// one more byte	}			return (i/size);													// return number of records transferred}	/* $page *//* This procedure writes a NUMBER of records of size SIZE bytes     from BUFFER to file F.  It returns the number of records     actually written. */fixed			fwrite(													// write one or more records to F	fixed	buf[], 														// buffer to write from	fixed	size, 														// size of record in bytes	fixed	number, 													// number of records to read	file	f)	_recursive												// pointer to file to write{    fixed			_upper0;	fixed			words;												// number of words to transfer	fixed			pos;												// current buffer word position	fixed			i, j;		if ((! (feof (f) & 1)) && (file_error != f_okay)) return (0);		// check for bad file descriptor			number = size*number;												// calculate total bytes to transfer	words = shr(number, 1);												// calculate number of words to transfer	i = 0;																// initialize word counter		if (bufpos [f] & 1)													// if buffer position odd	while ((i < words) && (putw (buf [i], f) == buf [i])) {				// transfer a word at a time		i = i + 1;	}																	// of transfer a word at a time (buffer position odd)			else while ((i < words)												// buffer position even - blast the buffer over	&& ! ((secpos [f] == seclen [f]) && (filepos [f] == filelen [f]) && (bufpos [f] == shl((buflen [f] + 255) & ((fixed) 0xFF00), 1)))) {	// while not at physical eof		if (bufpos [f] == shl(buflen [f], 1)) read_next (f);			// read the next bufferfull					pos = shr(bufpos [f], 1);										// get word position				if ((words - i) <= buflen [f] - pos)							// if more is in the buffer than what we're copying			j = (words - i);											// copy WORDS		else j = buflen [f] - pos;										// just copy over the rest of the buffer					switch (bufmed [f]) {											// branch on buffer media			case 0:			{															// internal				fixed *where = __location__(bufptr [f] + pos);								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					*where++ =  buf [i];				}														// of read it in				break;			}															// of internal							case 1:			{															// external				_write_60(bufptr [f] + shr(pos, 8));					// set up external memory pointer				_write_61(pos);								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					_write_63(buf [i]);				}														// of read it in				break;			}															// of external							case 2:			{															// poly				psmwrite (bufptr [f], pos);								// set up poly memory pointer								for (_upper0 = i + j - 1, i = i; i <= _upper0; i++) {	// not model C - read it in					XPL_write(0157, buf [i]);				}														// of read it in				break;			}															// of poly		}																// of branch on buffer media					bufpos [f] = bufpos [f] + shl(j, 1);							// bump up buffer position		dirty [f] = (dirty [f] | b_dirty);								// the buffer is now dirty	}																	// of buffer position even - blast the buffer over			i = shl(i, 1);														// get bytes transferred		if (number & 1 && (putc (buf [shr(i, 1)], f) == (buf [shr(i, 1)] & 0x00FF)))// if an odd byte at the end		i = i + 1;														// one more byte			return (i/size);													// return number of records transferred}	static	void	seek_sector_seek(										// seek to sector NEWSEC	file	f, 															// pointer to file to seek through	fixed	newsec)														// new sector to seek to	{	if ((_IGE_(newsec, secpos [f] - shr(buflen [f] + 255, 8))) && (_ILT_(newsec, secpos [f])))// see if we're moving to someplace in the buffer		bufpos [f] = shl(newsec - (secpos [f] - shr(buflen [f] + 255, 8)), 8 + 1);	// if so, just reset buffer pointer	else {																// we need to read in a new buffer		flush (f);														// flush this buffer		secpos [f] = newsec;											// set new sector position		filepos [f] = shl(secpos [f], 8);								// and new word position		readbuf (f);													// and read it in	}																	// of reading in new buffer}	/* $subtitle Seek *//* This procedure seeks to a given place in the specified file.  It     returns the logical position of the file after the SEEK.  (This is     really a cross between FSEEK and SEEK since we need SEEK's args for now.) */fixed			seek(													// seek to a given place in the given file	file	f, 															// pointer to file to seek through	fixed	offset, 													// where to seek to (word offset)	fixed	origin)	_recursive											// 0: seek from byte zero, 1: seek from current position, 2: seek from end of file, 3-5: same as 0-2, but treat OFFSET as a sector offset{	fixed			newsec;												// new sector position to seek to	fixed			newpos;												// new byte position (in sector NEWSEC) to seek to (0 -> 511)	boolean			to_eof;												// True if we're trying to seek right to the logical EOF		if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			if (bufmed [f] == -1) {												// oops - no buffer		file_error = f_no_buffer;		return (eof_mark);	}			if (_IGT_(origin, 5)) {												// origin out of bounds?		file_error = f_bad_arg;		return (eof_mark);	}			// $page			file_error = f_okay;												// no error	to_eof = false;														// assume we're NOT trying to seek right to the logical EOF		if (origin < 3) {													// offset is in words		switch (origin) {												// set base according to the origin			case 0:			{															// move relative to the start of file				newsec = 0; newpos = 0;									// point to start of file				break;			}			case 1:			{															// move relative to current position				newsec = (secpos [f] - shr(buflen [f] + 255, 8)) + shr(bufpos [f], 9);	// current sector				newpos = (bufpos [f] & 0x01FF);							// current byte position in that sector				break;			}			case 2:			{															// move relative to the logical end-of-file				newsec = logical_eof (f) - 1;							// point to logical end-of-file				newpos = shl(filelen [f] & 0x00FF, 1);					// and current byte position in last sector				if (newpos == 0) newsec = newsec + 1;					// we are in the last sector exactly				break;			}		}																// of setting base					if (offset < 0) {												// negative offset?			newsec = newsec - shr(XPL_abs(offset), 9);					// get pointer to new sector			newpos = newpos - (XPL_abs(offset) & 0x01FF);				// and new position in that sector						if (newpos < 0) {											// if NEWPOS is now out of range				newsec = newsec - 1;									// means we're moving to the previous sector				newpos = newpos + 512;									// and put NEWPOS back in range			}		}																// of negative offset		else {															// positive or zero offset			newsec = newsec + shr(offset, 9);							// get pointer to new sector			newpos = newpos + (offset & 0x01FF);						// and new position in that sector						if (newpos >= 512) {										// if NEWPOS is now out of range				newsec = newsec + 1;									// means we're moving to the next sector				newpos = newpos - 512;									// and put NEWPOS back in range			}		}																// of positive or zero offset					if (_IGE_(newsec, logical_eof (f))) {							// if sector is out of bounds			if (offset < 0) {											// if negative offset given				newsec = 0; newpos = 0;									// seek back to beginning of file			}			else {														// if positive or zero offset given				newsec = logical_eof (f) - 1;							// seek to end of file				newpos = ((shl(filelen [f], 1) - 1) & 0x01FF);			// less one byte				to_eof = true;											// we're trying to seek right up to the logical EOF			}		}																// of forcing back into range					seek_sector_seek (f, newsec);									// seek to the new sector		bufpos [f] = bufpos [f] + newpos;								// and to the new byte in that sector				if (to_eof & 1)													// if we're searching to logical EOF			bufpos [f] = bufpos [f] + 1;								// point right to logical EOF					return (shl(filepos [f] - buflen [f], 1) + bufpos [f]);			// return the character position of the file	}																	// of offset is in words			// $page			else {																// offset is in sectors		switch (origin - 3) {											// set target according to the origin			case 0:				newsec = offset;										// move relative to the start of file				break;			case 1:				newsec = (secpos [f] - shr(buflen [f] + 255, 8)) + shr(bufpos [f] + 511, 9) + offset;	// move relative to where we currently are				break;			case 2:				newsec = logical_eof (f) + offset;						// move relative to the logical end of file (physical eof is SECLEN)				break;		}																// of setting target					if (_IGE_(newsec, logical_eof (f))) {							// check if out of range			if (offset < 0)												// if negative offset				newsec = 0;												// force to start of file			else {														// if positive or zero offset				newsec = logical_eof (f) - 1;							// force to end of file				to_eof = true;											// and remember we want to go right to the logical EOF			}		}																// of forcing in range					seek_sector_seek (f, newsec);									// seek to new sector				if (to_eof & 1)													// if we want to go right up to the logical EOF			bufpos [f] = shl(buflen [f], 1);							// put buffer pointer at end of file					return ((secpos [f] - shr(buflen [f] + 255, 8)) + shr(bufpos [f] + 511, 9));	// return the sector position of the file	}																	// of offset is in sectors}	/* $subtitle Shuffle *//* This procedure shuffles part of a disk file up or down on the disk. */fixed			shuffle(												// shuffle an area of the disk somewhere else	file	f, 															// file to shuffle	fixed	source, 													// starting sector for shuffle	fixed	destination, 												// destination sector for shuffle	fixed	length)	_recursive											// length to shuffle (in sectors){	fixed			ms_source;											// Ms starting sector for shuffle	fixed			ms_dest;											// Ms destination sector for shuffle	fixed			amount;												// amount to shuffle at one time		if (_IGE_(f, max_files)) {											// bad file descriptor?		file_error = f_bad_file;		return (eof_mark);	}			if (bufmed [f] == -1) {												// oops - no buffer		file_error = f_no_buffer;		return (eof_mark);	}			file_error = f_okay;												// clear the air		if ((_IGE_(source, logical_eof (f))) || (_IGE_(destination, seclen [f])) || (_IGT_(length, logical_eof (f)))// out of bounds?	|| (_IGT_(source + length, logical_eof (f))) || (_IGT_(destination + length, seclen [f])))// make sure source within logical and destination within physical		return (eof_mark);												// return EOF if out of range					// $page		flush (f);															// flush the file buffer	secpos [f] = 0; filepos [f] = 0; buflen [f] = 0; bufpos [f] = 0;	// zap all pointers	dirty [f] = (dirty [f] | b_len);									// flag length change		if (_IGT_(destination, source)) {									// to shuffle up, we need to start from the top		if (_IGT_(destination + length, logical_eof (f)))				// are we increasing the logical size of the file?			filelen [f] = filelen [f] + shl(destination + length - logical_eof (f), 8);	// yes, increase it					source = source + length;										// start at the end of the block		destination = destination + length;								// same for the target block	}																	// of shuffling up	else {																// we are shuffling down		if ((ufixed) (source + length) == (ufixed) (logical_eof (f))) {	// are we decreasing the logical size of the file?			if (_ILT_(shr(filelen [f], 8), source - destination))		// do we need to decrease the sector length as well (are we crossing a 256-sector block boundary?				seclen [f] = ((seclen [f] - (source - destination)) & ((fixed) 0xFF00));	// yes, decrease the sector length as well			filelen [f] = filelen [f] - shl(source - destination, 8);	// decrease logical size of file		}	}																	// of shuffling down			ms_source = ms_start [f];											// determine absolute source sector	source = ls_start [f] + source;	if (_ILT_(source, ls_start [f])) ms_source = ms_source + 1;			ms_dest = ms_start [f];												// and the absolute destination sector	destination = ls_start [f] + destination;	if (_ILT_(destination, ls_start [f])) ms_dest = ms_dest + 1;			while (length != 0) {												// shuffle until no more sectors to shuffle		if (_IGT_(length, shr(bufsiz [f], 8))) amount = shr(bufsiz [f], 8); else amount = length;	// amount = min(length, bufsiz/256);					if (_IGT_(destination, source)) {								// moving up?			if (_ILT_(source, amount)) ms_source = ms_source - 1;		// borrow			source = source - amount;									// yes, point to next block (below us)			if (_ILT_(destination, amount)) ms_dest = ms_dest - 1;		// borrow			destination = destination - amount;							// and next destination		}					extdata [0] = bufptr [f]; extdata [3] = shl(amount, 8);		switch (bufmed [f]) {											// shuffle next block			case 0:			{															// internal				readdata (ms_source, source, __location__(bufptr [f]), shl(amount, 8));	// read next block in				writedata (ms_dest, destination, __location__(bufptr [f]), shl(amount, 8));	// write it out				break;			}															// of internal			case 1:			{															// external				extread (ms_source, source, extdata);					// read next block in				extwrite (ms_dest, destination, extdata);				// write it out				break;			}															// of external			case 2:			{															// poly				polyread (ms_source, source, extdata, 0);				// read next block in				polywrite (ms_dest, destination, extdata, 0);			// write it out				break;			}															// of poly		}																// of shuffle next block					if (_ILE_(destination, source)) {								// no, moving down			source = source + amount;									// point to next block (above us)			if (_ILT_(source, amount)) ms_source = ms_source + 1;			destination = destination + amount;							// and next destination			if (_ILT_(destination, amount)) ms_dest = ms_dest + 1;		}					length = length - amount;										// keep track of amount left to shuffle	}																	// of until no more sectors left			return (0);															// we shuffled okay}	void	fileio_main(){	blockset (extdata, 4, 0);											// global EXT/POLY READ/WRITE parameter list (never preserved)	for (ls_sector = 0; ls_sector < max_files; ls_sector++) {			// free all FCBs		cat_entry [ls_sector] = -1; ms_start [ls_sector] = -1; ls_start [ls_sector] = -1; bufmed [ls_sector] = -1;	}}