/* $title Optical Disk Management Routines *//* Optical Disk Management Routines by Kip Olson, February 1987 Modification history:    24 Feb 96 - CWJ - Recombined files. Reworked init_optical_controller to interrogate drive for info    04 Mar 91 - LSS - several fixes for magneto, broke file into two pieces    04 Oct 90 - LSS - buffer check bug fix in TRANSFEROPTICAL    17 Jul 90 - LSS - support for 5-inch magneto optical devices    27 Feb 89 - CWJ - moved HeaderGapSize to optlits for Repair program                    - added error recovery to ReadHeader,  WriteHeader.                    - added SearchEmpty1024kBlocks    1  Aug 88 - KJO - Made TRANSFEROPTICAL global, added serial no. to header    8  Jun 88 - KJO - Added WRITEHEADER, support for multiple volume headers    8  Jul 87 - KJO - Added physical sector relignment, usage of directory pointer*//*	Translated to C:   	12/22/99 at 22:29	*//*	Translator Version:	0.000				*/#include	"XPL.h"#include	"Optical.h"_module(optical)#define	quantum				0											// controller types#define	ld1200				1#define	magicnumber			((fixed) 0x8000)							// header revision number#define	formatpattern		((fixed) 0x6363)							// format pattern written to magneto media#include "Literals.h"#include "Syslits.h"#include "XPLASCIILit.h"#include "Catrtns.h"#include "SCSICode.h"#include "CmdRout.h"#include "Optlits.h"#include "Devutil.h"// Code for :xpl:opticalfixed			o_bufptr;												// buffer pointerfixed			o_bufmed;												// 0: internal memory, 1: external memoryfixed			o_volume_name[h_name_max + 1];							// volume namefixed			o_ms_dirstart;											// sector start of directoryfixed			o_ls_dirstart;fixed			o_ms_dirlen;											// sector length of directoryfixed			o_ls_dirlen;fixed			o_ms_datastart;											// sector start of data areafixed			o_ls_datastart;fixed			o_ms_datalen;											// sector length of data areafixed			o_ls_datalen;fixed			o_entrycount;											// no. directory entries on optical disk#define	d63		0x0033													// external memory then increment/* This routine must be called before anything else to set up       the correct controller type. *//* lookup_controller_type: interrogates drive for controller type and capacity *//* caches info for speedy access..															 *//* lookup_controller_block_size: reports the device blocksize that was cached	 *//* by lookup_controller_type																	 */static	boolean	dev10set;static	boolean	dev11set;static	fixed	dev10ctrlr;static	fixed	dev11ctrlr;static	fixed	dev10blksiz;static	fixed	dev11blksiz;static	fixed	finddevadr(												// Find device address for this drive	fixed	level)	_recursive	_swap									// level to check{	fixed			i, j;		if ((level == 10) || (level == 11)) {								// optical disk				i = find_device(level);											// search in configuration for this device				if (i != 0) {													// device found			j = able_core(i + s_devadr);								// look up device address						if (unitattentionoccured [computescsiindex (j)] != 0)		// if unit attention has occured			{															// then re-poll for capacity				dev10set = false;				dev11set = false;			}							return (j);													// return device address		}	}	return (-1);														// device not found}	static	fixed	lookup_controller_type(									// look up controller type for this level	fixed	level)	_recursive{	fixed			inqbuf[inq_buf_size_bytes/2 + 1];	fixed			capbuf[8/2 + 1];	fixed			devptr;	fixed			devadr;	fixed			devtyp;	fixed			controller;	fixed			blocksize;		if ((level    == 10)												// look up controller type for D10	&&  (dev10set != 0 ))		return (dev10ctrlr);			if ((level    == 11)												// look up controller type for D11	&&  (dev11set != 0 ))		return (dev11ctrlr);			devptr = find_device (level);										// look for optical device		if (devptr == 0)													// return if not configured		return (quantum);			devadr = finddevadr (level);										// find device address for this level		if (devadr == (-1))													// not configured...		return (quantum);			if (inquiry(devadr, inq_buf_size_bytes, inqbuf) != s_good)			// if can't inquire, doomed	{		set_able_core(devptr + s_seccyl, 144);							// provide simulated 1 gig quantum media		set_able_core(devptr + s_totcyl, ((fixed) 6815));				return (quantum);	}			devtyp = byte(inqbuf, 0) & 0x001F;									// get type		if (devtyp == 0)													// direct access - find size	{		set_able_core(devptr + s_devtyp, able_core(devptr + s_devtyp) | shl(1,10));	// allow formcopy to select this for format even if no media present				if (find_win_size (devadr, devptr, inqbuf, capbuf) != s_good)		{			set_able_core(devptr + s_seccyl, 144);						// provide simulated 1 gig quantum media			set_able_core(devptr + s_totcyl, ((fixed) 6815));						return (quantum);		}					controller = quantum;											// is quantum; size is set		blocksize  = shl(byte(capbuf,6),8) | byte(capbuf,7);			}			else if (devtyp == 4)	{		set_able_core(devptr + s_devtyp, able_core(devptr + s_devtyp) & (~(shl(1,10))));				set_able_core(devptr + s_seccyl, 1000);							// set up the size		set_able_core(devptr + s_totcyl, 2048);							// hard wire for LD1200 worm only				controller = ld1200;		blocksize  = 1024;			}			else 	{		set_able_core(devptr + s_seccyl, 144);							// provide simulated 1 gig quantum media		set_able_core(devptr + s_totcyl, ((fixed) 6815));				return (quantum);	}			unitattentionoccured [computescsiindex (devadr) ] = false;	deviceblocksize      [computescsiindex (devadr) ] = blocksize;		if (level == 10)	{ 	dev10set = true; dev10ctrlr = controller; dev10blksiz = blocksize; }			if (level == 11)	{ 	dev11set = true; dev11ctrlr = controller; dev11blksiz = blocksize; }			return (controller);	}	static	fixed	lookup_controller_block_size(	fixed	level)	_recursive	{	if ((level    == 10)												// look up block size for D10	&&  (dev10set != 0 ))		return (dev10blksiz);			if ((level    == 11)												// look up block size for D11	&&  (dev11set != 0 ))		return (dev11blksiz);			return (0);															// not set !!!}	void			init_optical_controller()								// set optical controller type based on system configuration{	static	fixed	i;		dev10set = false;													// force re-polling in all cases if we are called	dev11set = false;		lookup_controller_type(10);											// set both types if configured & running	lookup_controller_type(11);}		/* $subtitle Buffer Manipulation */void			pbuf(													// store a word in the buffer	fixed	index, 														// offset index into buffer	fixed	value)														// value to store	{	if (o_bufmed == 0) {												// internal memory		set_able_core(o_bufptr + index, value);							// store word	}	else {																// external memory		_write_60(o_bufptr + shr(index,8));								// sector in external memory		_write_61((index & 0x00FF));									// word in that sector		_write_62(value);												// store word	}}fixed			gbuf(													// retrieve a word from the buffer	fixed	index)														// offset index into buffer	{	if (o_bufmed == 0) {												// internal memory		return (able_core(o_bufptr + index));							// retrieve word	}	else {																// external memory		_write_60(o_bufptr + shr(index,8));								// sector in external memory		_write_61((index & 0x00FF));									// word in that sector		return (_read_62);												// retrieve word	}}	static	boolean	check_buf(												// check through buffer for a blank check	fixed	seclen)														// sector length of data read into buffer{	static	fixed	count, i;	static	boolean	force_blank;										// true if we found a sector full of the format pattern		count = 0;	if (o_bufmed == 0) {												// internal memory		while (_ILT_(count, seclen)) {			if (able_core(o_bufptr + shl(count,8)) == formatpattern) {	// first word of sector is format pattern				force_blank = true;										// assume this whole sector is blank check				for (i = 1; i <= 511; i++) {							// check the rest of the sector					if (able_core(o_bufptr + shl(count,8) + i) != formatpattern)// if not the format pattern						force_blank = false;													// then don't force a blank check				}				if (force_blank & 1) return (false);					// found a blank check			}			count = count + 2;											// advance 512 words		}	}	else {																// external memory		while (_ILT_(count, seclen)) {									// go through the buffer by sector			_write_60(o_bufptr + count);								// sector in external memory			_write_61(0);												// word in that sector						if (_read_63 == formatpattern) {							// first word is the format pattern				force_blank = true;										// assume this whole sector is blank				for (i = 1; i <= 511; i++) {							// check the rest of the sector					if (_read_63 != formatpattern)						// if not the format pattern						force_blank = false;													// then don't force a blank check				}				if (force_blank & 1) return (false);					// found a blank check			}			count = count + 2;											// advance 512 words		}	}	return (true);														// buffer does not contain a blank check sector}	void			set_optbuf(												// set buffer pointers	fixed	bufptr, 													// pointer to optical disk buffer	fixed	medium)	_recursive	_swap									// buffer medium (0 = internal memory, 1 = external memory	{	o_bufptr = bufptr;													// set these variables	o_bufmed = medium;}	/* $subtitle Buffer I/O */fixed			transferoptical(										// read data into the buffer	fixed	cmd, 														// command to send	fixed	ms_sec,	fixed	ls_sec, 													// sector to read	fixed	seclen, 													// no. sectors to read	fixed	level)	_recursive	_swap									// level to read{#pragma unused (cmd)#pragma unused (ms_sec)#pragma unused (ls_sec)#pragma unused (seclen)#pragma unused (level)	#if 0	fixed			devadr;												// device address to check	fixed			address;											// address of buffer	fixed			controller;	fixed			blksiz;	fixed			count;	fixed			i;	fixed			word;	#define	rpt				0x0008										// repeat counter	#define	repeat			write(rpt)=									// repeat macro		#define	rd1int			write(mr0i) = read(ScsiWord)				// read one word into internal memory	#define	intread			write(rpt)= 255; rd1int						// read one sector into internal memory		#define	rd1ext			write(d63) =  read(ScsiWord)				// read one word into external memory	#define	extread			write(rpt)= 255; rd1ext						// read one sector into external memory		#define	wt1int			write(ScsiWord) = read(mr0i)				// write one word from internal memory	#define	intwrite		write(rpt)= 255; wt1int						// write one sector from internal memory		#define	wt1ext			write(ScsiWord) =  read(d63)				// write one word from external memory	#define	extwrite		write(rpt)= 255; wt1ext						// write one sector from external memory		if (o_bufmed == -1) {												// no buffer allocated		c_status = e_buffer;		return (s_illegalrequest);	}			devadr = finddevadr(level);											// find device address for this level & check for media changed	if (devadr == -1) return (s_baddevice);								// return error			controller = lookup_controller_type      (level);	blksiz     = lookup_controller_block_size(level);		if (blksiz == 0)													// if can't get block size, must be not ready		return (s_notready);			if (o_bufmed != 0)													// External Memory		interp_set_xmem_addr(o_bufptr, 0);	else 																// Int memory		interp_set_imem_addr(o_bufptr);			i = busconnect(devadr);												// connect to SCSI bus	if (i != s_goodconnect) return (i);									// connection failed			XPL_write(026, cmd);												// Operation Code	XPL_write(026, s_busconnectlun);									// Target LUN		if (blksiz == 512)													// 512 media - do normally	{		XPL_write(027, ms_sec);											// 512-byte Logical Block (MSW)		XPL_write(027, ls_sec);											// 512-byte Logical Block (LSW)		XPL_write(026, 0);												// Reserved		XPL_write(027, seclen);											// No. 512-byte blocks to read	}	else 	{		XPL_write(027, shr(ms_sec,1));									// 1024-byte Logical Block (MSW)		XPL_write(027, shl(ms_sec,15) | shr(ls_sec,1));					// 1024-byte Logical Block (LSW)		XPL_write(026, 0);												// Reserved		XPL_write(027, shr(seclen,1));									// No. 1024-byte blocks to read	}			XPL_write(026, 0);													// Control		address = o_bufptr;													// start at beginning of buffer		if (o_bufmed != 0)													// set ext mem pointer		_write_60(address);			while ((XPL_read(025) & (s_req | s_atn)) != s_req) {}				// Wait for prior atn to be released and new REQ to be asserted			if (cmd == s_extendedread) {										// read optical disk		while ((XPL_read(025) & s_sigmask) == s_datain) {				// get data bytes					if (o_bufmed == 0) {										// internal memory				XPL_write(0300, address);								// set up memory pointer				XPL_write(010, 255); XPL_write(0360, XPL_read(027));	// read a 256 words into internal memory				address = XPL_read(0300);								// Save address			}			else {														// external memory				XPL_write(010, 255); _write_63(XPL_read(027));			// read 256 words into external memory				address = address + 1;			}							while ((XPL_read(025) & (s_req | s_atn)) != s_req) {}		// Wait for prior atn to be released and new REQ to be asserted		}	}	else if (cmd == s_extendedwrite) {									// write optical disk		while ((XPL_read(025) & s_sigmask) == s_dataout) {				// get data bytes			if (o_bufmed == 0) {										// internal memory				XPL_write(0300, address);								// set up memory pointer				XPL_write(010, 255); XPL_write(027, XPL_read(0360));				address = XPL_read(0300);								// Save address			}			else {														// external memory				XPL_write(010, 255); XPL_write(027, _read_63);				address = address + 1;			}							while ((XPL_read(025) & (s_req | s_atn)) != s_req) {}		// Wait for prior atn to be released and new REQ to be asserted		}	}	else return (s_illegalrequest);										// unknown command			i = getstatus(devadr);												// get status of this command	if (i == s_recoverederror) i = s_good;								// recovered error is just as good			if ((controller == quantum) && (cmd == s_extendedread) && (i == s_good)) {	// using Winchester simulation (or magneto optical)		if (! (check_buf(seclen) & 1))									// look through buffer for format pattern			i = s_blankcheck;											// if format pattern is found, force a BlankCheck	}			return (i);															// return status	#undef	rpt	#undef	repeat	#undef	rd1int	#undef	intread	#undef	rd1ext	#undef	extread	#undef	wt1int	#undef	intwrite	#undef	wt1ext	#undef	extwrite	#endifreturn (0);}	/* $subtitle Directory Entry I/O */fixed			sectoentry(												// convert sector no. to directory entry no.	fixed	msw,	fixed	lsw)	_recursive	_swap									// 32-bit sector number	{	msw = msw - o_ms_dirstart;											// subtract starting sector of directory	if (_ILT_(lsw, o_ls_dirstart)) msw = msw - 1;	lsw = lsw - o_ls_dirstart;		return (shl(msw,15) | shr(lsw,1));									// divide by two to get entry no.}	void			entrytosec(												// convert entry no. to a sector no.	fixed	entry)	_recursive	_swap									// entry no. to convert	{	f_ms_sector = shr(entry,15);										// turn entry number into a sector offset	f_ls_sector = shl(entry,1);		f_ms_sector = o_ms_dirstart + f_ms_sector;							// add sector offset to beginning of directory area	f_ls_sector = o_ls_dirstart + f_ls_sector;	if (_ILT_(f_ls_sector, o_ls_dirstart)) f_ms_sector = f_ms_sector + 1;}	fixed			readentry(												// read a directory entry	fixed	entry, 														// entry to read	fixed	level)	_recursive	_swap									// level to read from{	fixed			i;		entrytosec(entry);													// convert entry no. to it's 32-bit sector number		i = transferoptical(s_extendedread,f_ms_sector,f_ls_sector,2,level);	// try to read this sector	return (i);															// return status of read}	fixed			writeentry(												// write a directory entry	fixed	entry, 														// entry to read	fixed	level)	_recursive	_swap									// level to read from{	fixed			i;		entrytosec(entry);													// convert entry no. to it's 32-bit sector number		i = transferoptical(s_extendedwrite,f_ms_sector,f_ls_sector,2,level);	// try to write this sector	return (i);															// return status of write}	fixed			readentries(											// read directory entries	fixed	entry, 														// first entry to read	fixed	entrycount, 												// no. entries to read	fixed	level)	_recursive	_swap									// level to read from{	fixed			i;		entrytosec(entry);													// convert entry no. to it's 32-bit sector number		i = transferoptical(s_extendedread,f_ms_sector,f_ls_sector,shl(entrycount,1),level);	// try to read these sectors	return (i);															// return status of read}	fixed			writeentries(											// write directory entries	fixed	entry, 														// first entry to write	fixed	entrycount, 												// no. entries to write	fixed	level)	_recursive	_swap									// level to write to{	fixed			i;		entrytosec(entry);													// convert entry no. to it's 32-bit sector number		i = transferoptical(s_extendedwrite,f_ms_sector,f_ls_sector,shl(entrycount,1),level);	// try to write these sectors	return (i);															// return status of write}	/* $subtitle Operations on Directory Parameter */static	void	cleanname(												// make sure name checks out	fixed	oldname[], 													// name to check	fixed	newname[], 													// space to put cleaned name	fixed	max)	_recursive	_swap									// max no. words in name{    fixed			_upper0;	fixed			i, ch;												// word length of name		for (_upper0 = shl(max,1) - 1, i = 0; i <= _upper0; i++) {			// loop over name		if (_ILT_(i, oldname[0])) {										// process character			ch = byte(oldname,i);										// get character			if ((ch >= l_a) && (ch <= l_z)) ch = ch - 0x0020;			// make upper case		}		else ch = 0;													// pad with nulls		pbyte(_location_(&(newname[0]) - 1),i,ch);	}}	/* $subtitle Search for Empty Blocks */boolean			searchempty1024kblocks(									// search for empty data blocks	fixed	ms_start,	fixed	ls_start, 													// sector to start search at	fixed	scanlen, 													// no. BLOCKS    to scan	fixed	emptylen, 													// no. empty BLOCKS to search for	fixed	level)	_recursive	_swap									// level to read{	fixed			devadr;												// device address to check	fixed			sbuf[5];											// buffer for sense data	fixed			controller;		#define	s_searchemptyblocks	0x000C									// operation code		s_sensekey = s_good;												// assume no errors		devadr = finddevadr(level);											// find device address for this level and check for unit attention	if (devadr == -1) {													// bad device		s_sensekey = s_baddevice;										// bad device		return (false);													// die	}			controller = lookup_controller_type(level);		if (controller == quantum) {										// winchester simulation		f_ms_sector = ms_start;		f_ls_sector = ls_start + 2;		if (_ILT_(f_ls_sector, 2)) f_ms_sector = f_ms_sector + 1;		return (true);	}			s_sensekey = busconnect(devadr);									// connect to SCSI bus	if (s_sensekey != s_goodconnect) return (false);					// connection failed			XPL_write(026, s_searchemptyblocks);								// Operation Code	XPL_write(026, s_busconnectlun);									// Target LUN	XPL_write(027, 0);													// Reserved	XPL_write(026, 0);													// Reserved	XPL_write(026, 0);													// Control		XPL_write(027, shr(ms_start,1));									// Starting 1024-byte block (MSW)	XPL_write(027, (shl(ms_start,15) | shr(ls_start,1)));				// Starting 1024-byte block (LSW)	XPL_write(027, 0);													// No. 1024-byte blocks to scan (MSW)	XPL_write(027, scanlen);											// No. 1024-byte blocks to scan (LSW)	XPL_write(027, emptylen);											// No. 1024-byte empty blocks to scan for (LSW)		s_sensekey = shr(XPL_read(027) & s_statmask,8);						// get status byte		if (s_sensekey == s_conditionmet) {									// found empty blocks		s_sensekey = requestsense(devadr,7,sbuf);						// request sense data		if (s_sensekey == s_good) {										// got sense data			f_ms_sector = ( shl(byte(sbuf,3),8) | byte(sbuf,4) );		// store in buffer			f_ls_sector = ( shl(byte(sbuf,5),8) | byte(sbuf,6) );			f_ms_sector = ( shl(f_ms_sector,1) | shr(f_ls_sector,15) );	// convert back to 512-byte sectors			f_ls_sector = ( shl(f_ls_sector,1) );			return (true);												// success		}	}	else if (s_sensekey == s_checkcondition) {							// something happened		s_sensekey = requestsense(devadr,7,sbuf);						// request sense data		if (s_sensekey == s_recoverederror) s_sensekey = s_good;		// recovered is just as good	}			return (false);														// failure	#undef	s_searchemptyblocks}	boolean			searchemptyblocks(										// search for empty data blocks	fixed	ms_start,	fixed	ls_start, 													// sector to start search at	fixed	scanlen, 													// no. sectors to scan	fixed	emptylen, 													// no. empty sectors to search for	fixed	level)	_recursive	_swap									// level to read	{	return (searchempty1024kblocks(ms_start, ls_start,	shr(scanlen,1),  shr(emptylen,1), level));}	/* $subtitle Find Next Unused Logical Block */boolean			findnextunused(											// find next unused block in the given section	fixed	ms_start,	fixed	ls_start, 													// starting sector of region to search	fixed	ms_len,	fixed	ls_len, 													// sector length of region to search	fixed	level)	_recursive	_swap									// level to search{	fixed			ms_first, ls_first;									// first sector of region to search	fixed			ms_end, ls_end;										// end of directory	fixed			msw, lsw;	fixed			i;		s_sensekey = s_good;												// assume no errors will occur		ls_start = shl(ms_start,15) | shr(ls_start,1);						// convert to 1024-byte starting sector	ms_start = shr(ms_start,1);		ls_len = shl(ms_len,15) | shr(ls_len,1);							// convert to 1024-byte sector length	ms_len = shr(ms_len,1);		ms_end = ms_start + ms_len;											// calculate the end of the area	ls_end = ls_start + ls_len;	if (_ILT_(ls_end, ls_start)) ms_end = ms_end + 1;			ms_first = ms_start;												// Start at beginning of area	ls_first = ls_start;		while (! ( (ms_len == 0) && (ls_len == 0) )) {						// Repeat until entire area has been searched			msw = ms_first + shr(ms_len,1);									// get midpoint		lsw = ls_first + (shl(ms_len,15) | shr(ls_len,1));		if (_ILT_(lsw, ls_first)) msw = msw + 1;					i = transferoptical(s_extendedread,shl(msw,1) | shr(lsw,15),shl(lsw,1),2,level);	// try to read this sector				if (i == s_good) {												// this sector has data in it			msw = ms_first + shr(ms_len,1);								// skip half the region			lsw = ls_first + (shl(ms_len,15) | shr(ls_len,1));			if (_ILT_(lsw, ls_first)) msw = msw + 1;							ms_first = msw;												// add one to new starting sector			ls_first = lsw + 1;			if (_ILT_(ls_first, 1)) ms_first = ms_first + 1;							if (ls_len == 0) ms_len = ms_len - 1;						// subtract one from length			ls_len = ls_len - 1;		}		else if ((i == s_blankcheck) || (i == s_mediumerror)) {			// could not read this sector																		// search at a lower address		}		else {															// die if some other error occurred			s_sensekey = i;												// store error status			return (false);		}					ls_len = shl(ms_len,15) | shr(ls_len,1);						// divide no. sectors to search by 2		ms_len = shr(ms_len,1);	}			f_ms_sector = shl(ms_first,1) | shr(ls_first,15);					// convert back to 512-byte sectors	f_ls_sector = shl(ls_first,1);		if ((  _IGT_(ms_first, ms_end) )	|| ( (ms_first  ==  ms_end) && (_IGE_(ls_first, ls_end)) )) {		// no unsed sector found		return (false);													// no more room in directory	}			return (true);														// it's been found}	/* $subtitle Find No. Used Directory Entries */fixed			findentrycount(											// find no. directory entries	fixed	level)	_recursive	_swap									// level to look at{	boolean			found;		s_sensekey = s_good;												// assume no errors	c_status = e_none;		if (o_entrycount == -1) {											// optical disk not mounted yet		found = findnextunused(o_ms_dirstart,o_ls_dirstart,o_ms_dirlen,o_ls_dirlen,level);	// could not find free entry				if ((found & 1) || ((! (found & 1)) && (s_sensekey == s_good))) {	// directory area searched without any SCSI errors			return (sectoentry(f_ms_sector,f_ls_sector));				// convert sector to directory entry and return		}	}	else {																// optical disk must already be mounted				s_sensekey = readentry(o_entrycount,level);						// try to read this entry				if ((s_sensekey == s_blankcheck) || (s_sensekey == s_mediumerror)) {	// could not read it, so continue			if (o_entrycount == 0)										// there could not be an entry before this one				s_sensekey = s_good;			else s_sensekey = readentry(o_entrycount - 1,level);		// try to read entry before this							if (s_sensekey == s_good) {									// entry could be read, so this must be the end of directory				return (o_entrycount);									// return no. directory entries			}			else if (s_sensekey == s_blankcheck) {						// could not read one before it				s_sensekey = s_good;									// clear sense key				c_status = e_volume_changed;							// volume must be mounted again			}		}		else if (s_sensekey == s_good) {								// sector already written			c_status = e_volume_changed;								// volume must be mounted again		}	}			return (-1);														// signal error condition}	/* $subtitle Mode Select */static	fixed	modeselectoptical(										// set up optical disk	fixed	level)	_recursive	_swap									// level to set up{	fixed			devadr;												// Scsi device address of drive	fixed			buf[9];												// mode select buffer	fixed			i, j;	#define	defectmode		0											// auto-rewrite mode	fixed			controller;		devadr = finddevadr(level);											// find device address for this level and check for unit attention	if (devadr == -1) return (s_baddevice);								// bad device			controller = lookup_controller_type(level);		if (controller == ld1200) {											// optical disk		i = s_unitattention;		while (i == s_unitattention) {									// loop over unit attention			i = modesense(devadr,0,16,buf);								// get sense bytes		}		if (i != s_good) return (i);									// die					if ((shr(byte(buf,12),5) & 0x0003) != defectmode) {				// not in correct defect mode			for (i = 0; i <= 8; i++) {									// zero out buffer				buf[i] = 0;			}			buf[0] = 16;												// no. bytes in buffer			pbyte(buf,3,8);												// block descriptor length			pbyte(buf,10,0x0004);										// 1024-byte block size			pbyte(buf,11,0x0000);			pbyte(buf,12,shl(defectmode,5));							// use correct defect mode			pbyte(buf,13,0);											// use defaults			pbyte(buf,15,0);											// use default reselection delay						i = modeselect(devadr,0,16,buf);							// select these parameters			if (i != s_good) return (i);								// die on error		}	}			else {																// magneto optical		i = s_unitattention;											// get into loop at least once		while (i == s_unitattention) {									// wait unit unit attention goes away			i = testunitready(devadr);									// see if device is ready		}		if (i == s_busy) {												// try again, probably media just inserted			for (j = 0; j <= 2; j++) {				if (XPL_read(03) & 1)									// if the clock has ticked					XPL_write(03, 0);									// synchronize with the clock				for (i = 1; i <= 500; i++) {XPL_write(03, 0); }			// delay here to let drive happen				i = testunitready(devadr);			}		}		if (i != s_good) return (i);									// die	}			return (s_good);													// everything's cool	#undef	defectmode}	/* $subtitle Read and Write Header */boolean			readheader(												// read volume header and set up globals for this disk	fixed	level)	_recursive	_swap									// level to read{	fixed			devadr;												// Scsi device address of drive	fixed			buf[9];												// mode select buffer	fixed			ms_sec, ls_sec;	fixed			hmsb, hlsb;	fixed			controller;	fixed			blocksize;	fixed			i;		c_status = e_none;													// assume no error		devadr = finddevadr(level);											// find device address for this level and check for unit attention		if (devadr == (-1))	{		c_status = e_no_config;		return (false);	}			controller = lookup_controller_type      (level);	blocksize  = lookup_controller_block_size(level);		if (controller == quantum) {		s_sensekey = modeselectoptical(level);							// make sure drive is set up correctly		if (s_sensekey != s_good) return (false);	}			ms_sec = 0;															// start at first sector on disk	ls_sec = 0;		hmsb = (-1); hlsb = (-1);											// assume no header found		s_sensekey = transferoptical(s_extendedread,ms_sec,ls_sec,2,level);	// try to read the first volume header		if ((s_sensekey != s_good       )	&& (s_sensekey != s_mediumerror))		return (false);													// not formatted, or some other error			// This next block will catch magneto media that has not been	// formatted or not formatted slip sector.		if (controller == quantum) {										// magneto optical drive		if (s_sensekey == s_mediumerror) {								// never been formatted at all ?			s_sensekey = s_good;										// what we really want is an optical catalog error, not bad SCSI status			c_status = e_not_initialized;								// must format the media first with FORMCOPY			return (false);		}		else if (s_sensekey == s_good) {								// could read it, check format type			if (blocksize == 1024)										// only look further if may be M/O (vs. hard disk)			{															// in other words, skip the LNR check for Jaz drives...				i = modesense(devadr,0x002A,16,buf);					// get sense bytes				if (i == s_good) {										// if tahiti 1...  E.G. T-4 failes the above mode sense					if (shr(byte(buf,14),1) == 1) {												// Lnr bit is set, not slip sector						c_status = e_not_initialized;											// must format the media with FORMCOPY						return (false);					}				}				else s_sensekey = s_good;								// just set good sense for T-4			}		}	}			if (s_sensekey == s_good) {											// save good sector #		hmsb = ms_sec; hlsb = ls_sec;	}			i = 0;		while (((_ILT_(i, (headergapsize-1))   ))	&&      ((s_sensekey == s_good       )	||        (s_sensekey == s_mediumerror))) {		ls_sec = ls_sec + 2;											// try to read the next header		if (_ILT_(ls_sec, 2)) ms_sec = ms_sec + 1;					i      = i + 1;				s_sensekey = transferoptical(s_extendedread,ms_sec,ls_sec,2,level);	// try to read the next volume header				if (s_sensekey == s_good) {										// we read something that was there			hmsb = ms_sec; hlsb = ls_sec;								// save good sector number		}		else if ((s_sensekey != s_blankcheck )		&&     (s_sensekey != s_mediumerror))							// something weird happened			return (false);	}			if (hmsb == (-1))													// if we get nothing but medium errors,		return (false);													// then cannot read.			s_sensekey = transferoptical(s_extendedread,hmsb,hlsb,2,level);		// read the good one again		if (s_sensekey != s_good)											// could not read it a second time?		return (false);			if ((controller == quantum)											// optical type is M/O	&& (gbuf(h_magic) != magicnumber)									// it doesn't have a header yet	&& (gbuf(h_magic) != formatpattern)) {								// and can't find the format pattern either		c_status = e_not_initialized;									// must format the media first with FORMCOPY		return (false);	}			if ((controller == ld1200)											// optical type is LMS WORM	&& (gbuf(h_magic) != magicnumber)) {								// header not in NED format		c_status = e_bad_volume;										// volume in bad state		return (false);	}			o_ls_dirstart = gbuf(h_ls_dirstart);								// store sector start of directory	o_ms_dirstart = gbuf(h_ms_dirstart);		o_ls_dirlen = gbuf(h_ls_dirlen);									// store sector length of directory	o_ms_dirlen = gbuf(h_ms_dirlen);		o_ls_datastart = gbuf(h_ls_datastart);								// store sector start of data area	o_ms_datastart = gbuf(h_ms_datastart);		o_ls_datalen = gbuf(h_ls_datalen);									// store sector length of data area	o_ms_datalen = gbuf(h_ms_datalen);		return (true);														// header read correctly}	boolean			writeheader(											// write volume header	fixed	header[], 													// header to write	fixed	level)	_recursive	_swap									// level to write{	fixed			ms_sec, ls_sec;	fixed			i;		c_status = e_none;													// assume no error		ms_sec = 0;															// start at first sector on disk	ls_sec = 0;		s_sensekey = transferoptical(s_extendedread,ms_sec,ls_sec,2,level);	// try to read the first volume header		if ((s_sensekey != s_good       )	&& (s_sensekey != s_mediumerror)	&& (s_sensekey != s_blankcheck ))		return (false);													// not formatted, or some other error			i = 0;		while ((_ILT_(i,          (headergapsize-2)))						// -2 for error recovery below	&&       (s_sensekey !=  s_blankcheck    )) {						// read headers until a blank check is found		i = i + 1;		ls_sec = ls_sec + 2;											// try to read the next header		if (_ILT_(ls_sec, 2)) ms_sec = ms_sec + 1;		s_sensekey = transferoptical(s_extendedread,ms_sec,ls_sec,2,level);	// try to read the next volume header				if ((s_sensekey != s_good       )		&& (s_sensekey != s_mediumerror)		&& (s_sensekey != s_blankcheck ))			return (false);												// not formatted, or some other error	}			if (s_sensekey != s_blankcheck) {									// no more blank header entries		c_status = e_dir_full;											// set catalog error status		return (false);	}			for (i = 0; i < h_rec_length; i++) {								// copy header info into buffer		pbuf(i,header[i]);	}			s_sensekey = transferoptical(s_extendedwrite,ms_sec,ls_sec,2,level);	// try to write the new volume header		/* Must use complicated error recovery since block is reported as */	/* blank,  but we cannot write ...  The one time I tried this,    */	/* I was able to read the sector back from either logical sector  */	/* number!!.                                                      */		if (s_sensekey == s_blankcheck) {		ls_sec = ls_sec + 2;											// try to read the next header		if (_ILT_(ls_sec, 2)) ms_sec = ms_sec + 1;		s_sensekey = transferoptical(s_extendedwrite,ms_sec,ls_sec,2,level);	// try to write the new volume header	}			if (s_sensekey != s_good) return (false);			return (true);														// header saved successfully}	/* $subtitle Get Disk Statistics */boolean			get_statistics(											// get disk statistics	fixed	level, 														// level to get statistics from	fixed	buf[])	_recursive	_swap									// buffer to return data in{	fixed			ms_start, ls_start;									// first physical sector of free data area	fixed			ms_used, ls_used;									// no. sectors used on this disk	fixed			ms_free, ls_free;									// no. sectors free on this disk	fixed			ms_end, ls_end;										// end of data area	fixed			freeentry;											// next free entry in directory	fixed			lastentry;											// last directory entry in directory	boolean			found;	fixed			i;		freeentry = findentrycount(level);									// find the no. entries in directory	if (freeentry == -1) return (false);								// an error occurred			lastentry = freeentry;												// now search for the last directory entry	found = false;														// have not found entry yet	while ((lastentry != 0) && (! (found & 1))) {						// loop over directory entries			lastentry = lastentry - 1;										// back up one entry				s_sensekey = readentry(lastentry,level);		if (s_sensekey != s_good) return (false);						// error reading entry					if (gbuf(e__type) == e_dir_entry) found = true;					// this is a directory entry, so we've found what we're looking for	}																	// looping over directory entries			if (found & 1) {													// directory entry was found		ms_start = gbuf(e_ms_secstart) + gbuf(e_ms_seclen);				// calculate start of file		ls_start = gbuf(e_ls_secstart) + gbuf(e_ls_seclen);		if (_ILT_(ls_start, gbuf(e_ls_secstart))) ms_start = ms_start + 1;					if ((ls_start & 0x0001) != 0) {									// cannot have odd starting sectors			ls_start = ls_start + 1;									// add one to get even starting sectors			if (ls_start == 0) ms_start = ms_start + 1;		}					if (_ILT_(ls_start, 2)) ms_start = ms_start - 1;				// calculate last sector of previous file		ls_start = ls_start - 2;				ms_end = o_ms_datastart + o_ms_datalen;							// compute end of data area		ls_end = o_ls_datastart + o_ls_datalen;		if (_ILT_(ls_end, o_ls_datastart)) ms_end = ms_end + 1;					if (searchemptyblocks(ms_start,ls_start,0,8,level) & 1) {		// find next physical block			if ((_IGT_(f_ms_sector, ms_end))							// empty blocks found beyond end of data area			|| ((f_ms_sector  ==  ms_end) && (_IGE_(f_ls_sector, ls_end)))) {				ms_start = ms_end;										// start at end of data area				ls_start = ls_end;			}			else {				ms_start = f_ms_sector;									// store physical starting sector				ls_start = f_ls_sector;			}		}		else if (s_sensekey == s_good) {								// empty blocks not found			ms_start = ms_end;											// start at end of data area			ls_start = ls_end;		}		else return (false);											// Scsi error occurred	}	else {																// entry was not found, so start at beginning of data area		ms_start = o_ms_datastart;		ls_start = o_ls_datastart;	}			ms_used = ms_start - o_ms_datastart;								// calculate the no. sectors used	if (_ILT_(ls_start, o_ls_datastart)) ms_used = ms_used - 1;	ls_used = ls_start - o_ls_datastart;		ms_free = o_ms_datalen - ms_used;									// calculate no. free sectors	if (_ILT_(o_ls_datalen, ls_used)) ms_free = ms_free - 1;	ls_free = o_ls_datalen - ls_used;		_write_5(ls_free);													// calculate the no. bad sectors	_write_4(ms_free);	_write_7(1000);														// assume .1% of these free sectors will be bad	i = _read_5;		if (_ILT_(ls_free, i)) ms_free = ms_free - 1;						// subtract the no. bad sectors	ls_free = ls_free - i;												// this is the true no. sectors free		/* store these values */		buf[stat_dir_used] = freeentry;										// no. entries used	buf[stat_dir_free] = (shl(o_ms_dirlen,15) | shr(o_ls_dirlen,1)) - freeentry;	buf[stat_dir_start] = freeentry;									// first free entry		buf[stat_ms_used] = ms_used;										// no. data sectors used	buf[stat_ls_used] = ls_used;	buf[stat_ms_free] = ms_free;										// no. data sectors free	buf[stat_ls_free] = ls_free;	buf[stat_ms_start] = ms_start;										// first free sector in data area	buf[stat_ls_start] = ls_start;		return (true);														// got statistics}	/* $subtitle Format Disk */boolean			optical_format(											// format a new disk	fixed	name[], 													// volume name	fixed	caption[], 													// volume caption	fixed	date, 														// date stamp for volume	fixed	time, 														// time stamp for volume	fixed	serial, 													// serial number for volume	fixed	level)	_recursive	_swap									// level to write volume on{    fixed			_upper0;	fixed			devadr;												// Scsi device address	fixed			ms_total, ls_total;									// total no. sectors on volume	fixed			header_size;										// size of header	fixed			header_gap;											// size of header gap	fixed			dir_size;											// size of directory area	fixed			dir_gap;											// size of directory gap	fixed			ms_data, ls_data;									// size of data area	fixed			data_gap;											// size of data gap	fixed			databuf[5];											// general data buffer	fixed			headername[h_name_max];								// Header name	fixed			msw, lsw;	fixed			controller;	fixed			i, j;		c_status = e_none;													// assume no errors	s_sensekey = s_good;		if (! (valid_filename(name) & 1)) {									// not a valid file name		c_status = e_treename;		return (false);													// die if bad name	}			cleanname(name,headername,h_name_max);								// clean and fill name		devadr = finddevadr(level);											// find device address for this level and check for unit attention		controller = lookup_controller_type(level);		if (controller == quantum) {		s_sensekey = modeselectoptical(level);							// make sure drive is set up correctly		if (s_sensekey != s_good) return (false);	}			s_sensekey = transferoptical(s_extendedread,0,0,2,level);			// try to read the first sector of the disk		if (s_sensekey == s_good) {											// if it has already been written		c_status = e_formatted;											// disk is already formatted		return (false);													// die	}	else if (s_sensekey != s_blankcheck) return (false);				// some other error			s_sensekey = readcapacity(devadr,databuf);							// get capacity information	if (s_sensekey != s_good) return (false);							// an error occurred			i = (shl(byte(databuf,6),8) | byte(databuf,7));						// get LSW of block size	if (controller == ld1200 && i != 1024) {							// block size must be 1024 bytes for WORMS		s_sensekey = s_baddevice;		return (false);													// die	}			if (i != 512 && i != 1024)											// must be 512-byte or 1024-byte media at this point	{		s_sensekey = s_baddevice;		return (false);													// die	}			ms_total = (shl(byte(databuf,0),8) | byte(databuf,1));				// add one to last logical block to get total blocks	ls_total = (shl(byte(databuf,2),8) | byte(databuf,3)) + 1;	if (ls_total == 0) ms_total = ms_total + 1;			if (i == 512)														// if device is 512 media, compute number of 1024	{																	// byte blocks it maps to for the following size		ls_total = shr(ls_total, 1) | shl(ms_total, 15);				// computations...		ms_total = shr(ms_total, 1);	}			// Limit to 8-gigabytes for use with readdata, writedata:		if (_IGE_(ms_total, 128))											// note: limit is in 1024-byte sectors at this point!	{		ms_total = 0x007F;		ls_total = ((fixed) 0xFFFF);	}			// Allocate Header Area	header_size = 1;													// header takes up 1 sector	header_gap = 100;													// allow room for more headers		/* Allocate Directory Area */	if ((_IGT_(ms_total, 0x0063))	|| ((ms_total  ==  0x0063) && (_IGT_(ls_total, ((fixed) 0xFF38)))))	// 1% of the disk would hold more than 65534 entries		dir_size = ((fixed) 65534);										// so limit to 65534 entries	else {		_write_5(ls_total);												// calculate size of directory area		_write_4(ms_total);		_write_7(100);													// directory size is 1% of the total space available		dir_size = _read_5;												// size of directory in 1024-byte blocks	}			_write_5(dir_size);													// calculate size of directory gap	_write_7(500);														// assume 0.2% of the sectors in the directory area will be bad	dir_gap = _read_5;													// size of directory gap in 1024-byte sectors		/* Allocate Data Area */	msw = 0;	lsw = header_size + header_gap + dir_gap;							// calculate size taken up by header and directory area	lsw = lsw + dir_size;	if (_ILT_(lsw, dir_size)) msw = msw + 1;			ms_data = ms_total - msw;											// calculate size of data area	if (_ILT_(ls_total, lsw)) ms_data = ms_data - 1;	ls_data = ls_total - lsw;											// subtract size of header and directory areas		_write_5(ls_data);													// calculate size of data area gap	_write_4(ms_data);	_write_7(1000);														// assume .1% of the data sectors will be bad	data_gap = _read_5;													// size of data area gap		if (_ILT_(ls_data, data_gap)) ms_data = ms_data - 1;				// subtract data gap from data area	ls_data = ls_data - data_gap;		for (i = 0; i < h_rec_length; i++) {								// clear the buffer		pbuf(i,0);	}			/* Set up buffer with header information */		pbuf(h_magic, magicnumber);											// magic number		for (i = 0; i < h_name_max; i++) {									// volume name		pbuf(h_name + i,headername[i]);									// store name characters	}			pbuf(h_date,date);													// store date	pbuf(h_time,time);													// store time		msw = 0; lsw = 0;													// start at beginning of disk		lsw = lsw + (header_size + header_gap);								// calculate start of directory area	pbuf(h_ls_dirstart,shl(lsw,1));										// 512-byte sector start of directory	pbuf(h_ms_dirstart,shr(lsw,15));		pbuf(h_ls_dirlen,shl(dir_size,1));									// 512-byte sector length of directory	pbuf(h_ms_dirlen,shr(dir_size,15));		lsw = lsw + dir_size;												// calculate start of data area	if (_ILT_(lsw, dir_size)) msw = msw + 1;							// add on size of directory	lsw = lsw + dir_gap;	if (_ILT_(lsw, dir_gap)) msw = msw + 1;								// add on size of directory gap			pbuf(h_ls_datastart,shl(lsw,1));									// 512-byte start of data area	pbuf(h_ms_datastart,shl(msw,1) | shr(lsw,15));		pbuf(h_ls_datalen,shl(ls_data,1));									// 512-byte length of data area	pbuf(h_ms_datalen,shl(ms_data,1) | shr(ls_data,15));				// the no. sectors left is the length of the data area		pbuf(h_serial,serial);												// store serial number		j = caption[0];														// get length of caption	if (_IGT_(j, shl(h_caption_max,1))) j = shl(h_caption_max,1);		// limit size of caption			pbuf(h_caption,j);													// store length of caption	for (_upper0 = shr(j + 1,1), i = 1; i <= _upper0; i++) {			// volume caption		pbuf(h_caption + i,caption[i]);									// store caption characters	}			s_sensekey = transferoptical(s_extendedwrite,0,0,2,level);			// write out the buffer	return (s_sensekey == s_good);										// format complete}	/* $subtitle Replace File */boolean			optical_replace(										// replace on optical	fixed	name[], 													// name of file	fixed	type, 														// type of file	fixed	ms_len,	fixed	ls_len, 													// size of file in sectors	fixed	wordlen, 													// size of file in words (mod 64K)	fixed	header[], 													// sound file header	fixed	entry, 														// previous directory entry	fixed	level)	_recursive	_swap									// level to replace on{	fixed			entryname[e_name_max];								// entry name	fixed			buf[stat_rec_length];								// statistics array	fixed			databuf[2];											// buffer for data information	fixed			i;		c_status = e_none;													// assume no error	s_sensekey = s_good;		if (! (valid_filename(name) & 1)) {									// not a valid file name		c_status = e_treename;		return (false);													// die if bad name	}	cleanname(name,entryname,e_name_max);								// clean and fill name		if (! (readheader(level) & 1)) return (false);						// header could not be read			if (entry != -1) {													// there is a previous entry		s_sensekey = readentry(entry,level);							// get previous entry		if (s_sensekey != s_good) return (false);						// an error occurred					for (i = 0; i < e_name_max; i++) {								// loop over words of name			if (entryname[i] != gbuf(e__name + i)) {					// names do not match				c_status = e_no_file;									// file to replace was not found				return (false);											// die			}		}	}			if (! (get_statistics(level,buf) & 1)) return (false);				// could not get statistics			if (buf[stat_dir_free] == 0) {										// no more directory entries		c_status = e_dir_full;											// no more room		return (false);													// die	}			if ((_IGT_(ms_len, buf[stat_ms_free]))	|| ((ms_len  ==  buf[stat_ms_free]) && (_IGT_(ls_len, buf[stat_ls_free])))) {	// not enough room		c_status = e_storage;											// no more room		return (false);													// die	}			for (i = 0; i < e_rec_length; i++) {								// clear the buffer		pbuf(i,0);	}			/* Set up buffer with entry information */		pbuf(e__type,e_dir_entry);											// this is a directory entry		for (i = 0; i < e_name_max; i++) {									// entry name		pbuf(e__name + i,entryname[i]);									// store name characters	}			getdatetime(databuf);												// get date and time from clock, if it's there	pbuf(e_date,databuf[0]);											// store date	pbuf(e_time,databuf[1]);											// store time		pbuf(e_ls_secstart,buf[stat_ls_start]);	pbuf(e_ms_secstart,buf[stat_ms_start]);								// store sector start		pbuf(e_ls_seclen,ls_len);	pbuf(e_ms_seclen,ms_len);											// store sector length		pbuf(e_ls_wordlen,wordlen);	pbuf(e_ms_wordlen,0);												// store word length		pbuf(e_file_type,type);												// store file type		pbuf(e_prev_entry,entry);											// store previous entry		for (i = 0; i < e_header_max; i++) {								// store sound file header		pbuf(e_header + i,header[i]);	}			s_sensekey = writeentry(buf[stat_dir_start],level);					// try to write this directory entry at first free entry	if (s_sensekey != s_good) return (false);			f_ms_sector = shl(level,8) | buf[stat_ms_start];					// set up file variables	f_ls_sector = buf[stat_ls_start];	f_ms_length = ms_len;	f_ls_length = ls_len;	f_words = wordlen;	f_type = type;		if (o_entrycount != -1)												// volume is mounted		o_entrycount = o_entrycount + 1;								// another directory entry inserted			return (true);														// directory entry now in place}	/* $subtitle Delete File */boolean			optical_delete(											// delete file	fixed	name[], 													// name of file to delete	fixed	entry, 														// latest directory entry for this file	fixed	level)	_recursive	_swap									// level to delete file from{	fixed			entryname[e_name_max];								// entry name	fixed			freeentry;											// next free entry in directory	fixed			i;		c_status = e_none;													// assume no error	s_sensekey = s_good;		if (! (readheader(level) & 1)) return (false);						// header could not be read			s_sensekey = readentry(entry,level);								// get entry	if (s_sensekey != s_good) return (false);							// an error occurred			cleanname(name,entryname,e_name_max);								// clean and fill name	for (i = 0; i < e_name_max; i++) {									// loop over words of name		if (entryname[i] != gbuf(e__name + i)) {						// names do not match			c_status = e_no_file;										// file to delete was not found			return (false);												// die		}	}			freeentry = findentrycount(level);									// find no. entries in directory	if (freeentry == -1) return (false);								// could not find free entry	if (_IGE_(freeentry, (shl(o_ms_dirlen,15) | shr(o_ls_dirlen,1)))) {	// all directory entries are used		c_status = e_dir_full;											// signal error		return (false);													// die	}			for (i = 0; i < e_rec_length; i++) {								// clear the buffer		pbuf(i,0);	}			/* Set up buffer with entry information */		pbuf(e__type,e_delete_entry);										// this is a delete entry		for (i = 0; i < e_name_max; i++) {									// entry name		pbuf(e_oldname + i,entryname[i]);								// store name characters in old name field	}			pbuf(e_prev_entry,entry);											// store previous entry		s_sensekey = writeentry(freeentry,level);							// try to write this directory entry	if (s_sensekey != s_good) return (false);			if (o_entrycount != -1)												// volume is mounted		o_entrycount = o_entrycount + 1;								// another directory entry inserted			return (true);														// directory entry now in place}	/* $subtitle Update File */boolean			optical_update(											// update file	fixed	oldname[], 													// old name of file	fixed	newname[], 													// new name of file	fixed	header[], 													// new sound file header for file	fixed	entry, 														// latest directory entry for file to update	fixed	level)	_recursive	_swap									// level to update file on{	fixed			entryname[e_name_max];								// entry name	fixed			freeentry;											// next free entry in directory	fixed			i, c;		c_status = e_none;													// assume no error	s_sensekey = s_good;		if (! (valid_filename(newname) & 1)) {								// not a valid file name		c_status = e_treename;		return (false);													// die if bad name	}			if (! (readheader(level) & 1)) return (false);						// header could not be read			freeentry = findentrycount(level);									// find no. entries in directory	if (freeentry == -1) return (false);								// could not find free entry	if (_IGE_(freeentry, (shl(o_ms_dirlen,15) | shr(o_ls_dirlen,1)))) {	// all directory entries are used		c_status = e_dir_full;											// signal error		return (false);													// die	}			s_sensekey = readentry(entry,level);								// get entry	if (s_sensekey != s_good) return (false);							// an error occurred			cleanname(oldname,entryname,e_name_max);							// clean and fill name	for (i = 0; i < e_name_max; i++) {									// loop over words of name		if (entryname[i] != gbuf(e__name + i)) {						// names do not match			c_status = e_no_file;										// file to update was not found			return (false);												// die		}	}			/* Set up buffer with entry information */		pbuf(e__type,e_rename_entry);										// this is a rename entry		cleanname(newname,entryname,e_name_max);							// clean and fill name	for (i = 0; i < e_name_max; i++) {									// entry name		c = gbuf(e__name + i);											// get word of current name		pbuf(e_oldname + i,c);											// store old name		pbuf(e__name + i,entryname[i]);									// store new name	}			pbuf(e_prev_entry,entry);											// store previous entry		for (i = 0; i < e_header_max; i++) {								// store sound file header		pbuf(e_header + i,header[i]);	}			s_sensekey = writeentry(freeentry,level);							// try to write this directory entry	if (s_sensekey != s_good) return (false);			if (o_entrycount != -1)												// volume is mounted		o_entrycount = o_entrycount + 1;								// another directory entry inserted			return (true);														// directory entry now in place}	/* $subtitle Locate File */boolean			optical_locate(											// find file	fixed	name[], 													// name of file	fixed	level)	_recursive	_swap									// level to search on{	fixed			entry;												// directory entry	fixed			numentries;											// total no. entries in directory	boolean			filefound;											// True if file found	fixed			fileentry;											// file entry	fixed			entryname[e_name_max];								// entry name	fixed			i;													// word length of string		c_status = e_none;													// assume no errors	s_sensekey = s_good;		cleanname(name,entryname,e_name_max);								// clean file name		if (! (readheader(level) & 1)) return (false);						// try to read header			numentries = shl(o_ms_dirlen,15) | shr(o_ls_dirlen,1);				// get total no. directory entries		filefound = false;													// assume file not found	s_sensekey = s_good;	entry = 0;															// start at first entry	while ((_ILT_(entry, numentries)) && (s_sensekey == s_good)) {		// loop over entries until an error occurs		s_sensekey = readentry(entry,level);							// get entry				if (s_sensekey == s_good) {										// got an entry			if (gbuf(e__type) == e_dir_entry) {							// this is a directory entry								i = 0;													// start at first character				while ((i < e_name_max) && (entryname[i] == gbuf(e__name + i))) {	// loop while words are the same					i = i + 1;				}									if (i == e_name_max) {									// same name					filefound = true;									// file found					fileentry = entry;									// save entry				}			}															// directory entry		}																// entry found					entry = entry + 1;												// go to next entry	}																	// looping over directory entries			if ((_ILT_(entry, numentries)) && (s_sensekey != s_blankcheck)) return (false);	// error reading directory			if (filefound & 1) {												// matching file name was found		s_sensekey = readentry(fileentry,level);						// read in entry		if (s_sensekey != s_good) return (false);					f_ms_sector = shl(level,8) | gbuf(e_ms_secstart);				// set up globals		f_ls_sector = gbuf(e_ls_secstart);		f_ms_length = gbuf(e_ms_seclen);		f_ls_length = gbuf(e_ls_seclen);		f_words = gbuf(e_ls_wordlen);		f_type = gbuf(e_file_type);				return (true);													// file found	}			c_status = e_no_file;	return (false);														// file not found}	void	optical_main(){	o_bufmed = -1;														// buffer not intialized yet		o_entrycount = -1;													// optical disk not mounted yet	}