/* Definitions used by pass2 and pass3: *//* define the configuration table */#define	vstart			0#define	vlngth			1#define	stklen			2#define	objloc			3#define	objlen			4#define	swpram			5#define	swplen			6#define	rtploc			7#define	inttab			8#define	rcvptr			9#define	inpbuf			10#define	sbrsbw			11#define	curtrk			12#define	devtab			13/* Define symbols for intermediate file format:..  The intermediate file is a record oriented file created by pass2..  Each type of record may have a different length...  The ET.LDF records are emitted by the linker (during pass3), and by.  pass2 for MAIN only.  The ET.REF records are emitted and used by the.  linker only...  The first word of each record indicates its type as follows:*/#define	et_eof			0						/* end of file									*/#define	et_lit			1						/* literal word									*/#define	et_tra			2						/* jump instruction								*/#define	et_cal			3						/* procedure call								*/#define	et_rtp			4						/* rtp call										*/#define	et_vpt			5						/* variable area pointer						*/#define	et_opt			6						/* object code pointer							*/#define	et_lde			7						/* label definition								*/#define	et_dat			8						/* data declaration								*/#define	et_cpy			9						/* copy data to object file						*/#define	et_scn			10						/* copy scon to object file						*/#define	et_ign			11						/* ignore record								*/#define	et_pdf			12						/* procedure definition							*/#define	et_pen			13						/* end of procedure defn						*/#define	et_whn			14						/* beginning of when stmt						*/#define	et_wen			15						/* end of when stmt								*/#define	et_spt			16						/* string constant ptr							*/#define	et_adr			17						/* addr of fixed array							*/#define	et_seq			18						/* sequence number								*/#define	et_sym			19						/* symbol defn or reference						*/#define	et_mod			20						/* module statement								*/#define	et_lib			21						/* library statement							*/#define	et_ins			22						/* insert statement								*/#define	et_ldf			23						/* library definition							*/#define	et_ref			24						/* external symbol reference					*/#define	et_cas			25						/* emit code for do case						*/#define	et_atr			26						/* alt jump instruction							*/#define	et_ald			27						/* alt label definition							*/#define	et_max			27						/* largest record type defined					*/#define	et_maximum		0x003F					/* maximum record type allowed without changing LITERAL.MASK	*/#define	literal_mask	((fixed) 0xFFC0)		/* if any of these bits are set in the record type, it is of type ET.LIT (see EM.LIT)	*/#define	et_revision		13						/* revision number for pass2 to pass3 IF - MUST be incremented whenever the format changes	*/static	fixed	et_length[] = {0,1,3,-1,1, 3,1,1,2,-1, -1,0,-1,6,1, 2,3,2,1,-1, -1,-1,-1,1,2, 0,3,1};	/* lengths of IF records by type (not including type word); -1 indicates variable length	*//* Able series instruction set:.  .   The following macros define the model A instruction set, unless otherwise.   noted.  Symbols are defined for source and destination fields, the.   arithmetic opcodes, and so forth. *//* sources: */#define	b_is			0x0080					/* immediate source								*/#define	b_imsk			0x003F					/* immediate field								*/#define	b_rs			0x00C0					/* register source								*/#define	b_ms			0x00E0					/* memory source								*/#define	b_ibt			0x0010					/* increment bit								*/#define	b_pc			0x000F					/* pc is r17									*/#define	b_rmsk			0x000F					/* register field								*/#define	b_amsk			0x0003					/* accumulator field							*//* destinations: */#define	b_ad			0x0080					/* arithmetic destination						*/#define	b_loa			0x0000					/* arith load									*/#define	b_and			0x0004					/* arith and									*/#define	b_add			0x0008					/* arith add									*/#define	b_sub			0x000C					/* arith subtract								*/#define	b_ex			0x0010					/* arith exor									*/#define	b_lef			0x0014					/* arith left rot								*/#define	b_or			0x0018					/* arith or										*/#define	b_com			0x001C					/* arith loa compl								*/#define	b_td			0x00A0					/* test destination								*/#define	b_bsor			0x00B0					/* byte swap or    (model B)					*/#define	b_shra			0x00B4					/* shift right add (model B)					*/#define	b_tlo			0x0000					/* test load									*/#define	b_tan			0x0004					/* test and										*/#define	b_tad			0x0008					/* test add										*/#define	b_tsu			0x000C					/* test sub										*/#define	b_rd			0x00C0					/* register destination							*/#define	b_ca			0x00D0					/* conditional absolute							*/#define	b_cr			0x00D8					/* conditional relative							*/#define	b_tra			0						/* always										*/#define	b_tze			1						/* zero flag									*/#define	b_trc			2						/* carry flag									*/#define	b_tmi			3						/* minus flag									*/#define	b_tnv			4						/* never										*/#define	b_tnz			5						/* non-zero										*/#define	b_tnc			6						/* no carry										*/#define	b_tpl			7						/* positive										*/#define	b_md			0x00E0					/* memory destination							*/