/* Definitions used by pass1 and pass2: *//* Operator definitions:.  .  As mentioned above, the procedure 'SCAN' is called to scan the next.  token from the input file.   If the next character in the input.  file is an operator (i.e. ' + ', ' - ', '*', etc.)  then the scanner.  returns with the global variable 'TOKEN' equal to T.OPR and.  the global variable 'INFO' equal to one of the following values, .  depending on the type of operator. */#define	o_math			0						/* abs, log, atn, cos, sin, tan, exp, sqr		*/#define	o_int			16						/* int											*/#define	o_read			17						/* read											*/#define	o_adr			19						/* addr function								*/#define	o_not			24						/* not - monadic								*/#define	o_incr			25						/* increment - monadic							*/#define	o_decr			26						/* decrement - monadic							*/#define	o_minus			28						/* minus - monadic or dyadic					*/#define	o_plus			29						/* plus  - monadic or dyadic					*/#define	o_shr			30						/* shr											*/#define	o_shl			31						/* shl											*/#define	o_rot			32						/* rot											*/#define	o_div			36						/* divide - dyadic								*/#define	o_times			37						/* times  - dyadic								*/#define	o_mod			38						/* mod    - dyadic								*/#define	o_fmu			39						/* fractional multiply							*/#define	o_fdi			40						/* fractional divide - dyadic					*/#define	o_and			41						/* and - dyadic									*/#define	o_or			42						/* or  - dyadic									*/#define	o_xor			43						/* xor - dyadic									*/#define	o_eq			49						/* equal										*/#define	o_lt			50						/* less than									*/#define	o_le			51						/* less than or equal to						*/#define	o_gt			52						/* greater than									*/#define	o_ge			53						/* greater or equal to							*/#define	o_ne			54						/* not equal to									*/#define	o_ilt			55						/* integer less than							*/#define	o_ile			56						/* integer less than equal to					*/#define	o_igt			57						/* integer greater than							*/#define	o_ige			58						/* integer greater than equal to				*//* Statement definitions:..   If the token scanned is a statement, the scanner returns with the.   global variable TOKEN equal to T.STMT and the global variable INFO.   set to one of the values below (depending on which statement was scanned). */#define	s_call			0						/* procedure call								*/#define	s_return		1						/* return										*/#define	s_proc			2						/* procedure definition							*/#define	s_begin			3						/* begin										*/#define	s_do			4						/* do											*/#define	s_if			5						/* if											*/#define	s_goto			6						/* goto											*/#define	s_enable		7						/* enable interrupts							*/#define	s_disable		8						/* disable interrupts							*/#define	s_stop			9						/* halt the processor							*/#define	s_write			10						/* write to a device							*/#define	s_linput		11						/* line input from console						*/#define	s_input			12						/* input from console							*/#define	s_print			13						/* output to console							*/#define	s_send			14						/* output to printer/modem						*/#define	s_when			15						/* interrupt processing block definition		*/#define	s_invoke		16						/* invoke an interrupt handler					*/#define	s_module		17						/* define a relocatable module					*/#define	s_library		18						/* reference a precompiled module				*/#define	s_insert		19						/* define the start/end of an insert file		*/#define	s_declare		20						/* declare stack storage to be used by the program (must be same as S.PASS1 in P1-DEFS)	*//* Definitions used by EXPR (pass1 and pass2):..  The types of tree nodes (created by EXPR) are defined as follows: */#define	x_dyad			0						/* dyadic  opr - ARG1, ARG2 = operands, INFO = opr type	*/#define	x_monad			1						/* monadic opr - ARG1 = operand,        INFO = opr type	*/#define	x_const			2						/* constant    - ARG1 = type,           INFO = value	*/#define	x_var			3						/* variable    - ARG1 = class/type, ARG2 = subscr (if one), INFO = location	*/#define	x_proc			4						/* procedure   - see EXPR						*/#define	x_cal			5						/* pass1 only: zero argument rtp call - ARG1 = type, INFO = rtp routine to call	*//* Register definitions (used in setting up procedure calls):. .  The registers (accumulators) are not numbered traditionally (0-3).  but are instead represented by bits.  They are numbered 1, 2, 4, and.  8, which makes some tables longer but also shortens the compiler and.  the compile time.*/#define	b_ac0			0x0001#define	b_ac1			0x0002#define	b_ac2			0x0004#define	b_ac3			0x0008/* Communications area definitions for pass1 and pass2: */#define	com				r						/* com unfortunately has an alias				*/#define	pdll			com [l_pdll         - rtp_ptrs]#define	nexkey			com [l_key          - rtp_ptrs]#define	altkey			com [l_altkey       - rtp_ptrs]#define	recurs_parms	com [l_recurs_parms - rtp_ptrs]#define	s_names_used	com [l_s_names_len  - rtp_ptrs]#define	str_data		com [l_str_data     - rtp_ptrs]#define	stack_used		com [l_stack_used   - rtp_ptrs]#define	flags			com [l_flags        - rtp_ptrs]#define	ram				com [l_ram          - rtp_ptrs]#define	extloc			com [l_extloc       - rtp_ptrs]#define	_st				com [l__st          - rtp_ptrs]#define	_sk				com [l__sk          - rtp_ptrs]#define	_bl				com [l__bl          - rtp_ptrs]#define	_if2			com [l__if2         - rtp_ptrs]#define	iflng			com [l_iflng        - rtp_ptrs]#define	if2lng			com [l_if2lng       - rtp_ptrs]#define	ovram			com [l_ovram        - rtp_ptrs]#define	get_blocks		com [l_get_blocks   - rtp_ptrs]#define	main_key		com [l_main_key     - rtp_ptrs]#define	l_icell			((fixed)(icell - rtp_ptrs))		/* interrupt cells for when						*/#define	l_ctab			((fixed)(ctab  - rtp_ptrs))		/* configuration table							*/