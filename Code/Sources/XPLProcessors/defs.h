/* General definitions used by pass1, pass2, and pass3: */#define	extern_base			((fixed)(56*1024))		/* Ram/scon/key base for external references (so they don't conflict with external definitions - see pass1:GET_EXTLOC)	*/#define	temp_base			((fixed)(extern_base - ((fixed) (4*1024))))	/* Scon base for temporaries in recursive procs (so that we can recognize them)	*/#define	s_depth_max			15						/* levels of localization (by default, it's only 4 bits) - must be (2^N - 1)	*/#define	max_recurs_parms	16						/* maximum number of parameters to recursive procs	*/#define	proc_keys			4						/* number of keys used by a proc (minus one)	*/#define	when_keys			3						/* number of keys used by a when (minus one)	*//* Token type definitions:.  .   The 'scanner'(procedure 'SCAN') is called to scan the next.   token (or 'atom') from the source file.   The scanner sets certain.   values to the global variables 'TOKEN' and 'INFO',  depending.   on the type of symbol that is scanned.   In general,  the global.   variable 'TOKEN' will contain an integer that indicates what type of.   atom was scanned (such as a fixed point variable),  and the.   global variable 'INFO' will further modify token (such as where.   in memory the variable will be stored)...   NOTE:  There is a dependency in the statement scanner (and perhaps.   elsewhere) on the token values less than T.LIT.  In particular,.   all variables must be less than T.LIT, all arrays must have odd.   token values, and all pointers must have the T.PVAR bit set...   RELOCATE_DEFNS in P3-3 also has an array STORAGE_TYPE that maps these.   token types to general storage types (i.e., ram, data, keys). */#define	t_var			0						/* numeric fixed point variable					*/#define	t_arr			1						/* fixed point array							*/#define	t_fvar			2						/* floating point variable						*/#define	t_farr			3						/* floating point array							*/#define	t_pvar			4						/* pointer to fixed point variable				*/#define	t_parr			5						/* pointer to fixed point array					*/#define	t_pfvar			6						/* pointer to floating variable					*/#define	t_pfarr			7						/* pointer to floating point array				*/#define	t_lit			8						/* literal declaration							*/#define	t_fxdata		9						/* fixed point data array						*/#define	t_fldata		11						/* floating data array							*/#define	t_extern		8						/* global variable reference					*/#define	t_public		9						/* global variable definition					*/#define	t_symonly		10						/* internal code to emit symbol ref only		*/#define	t_proc			16						/* procedure									*/#define	t_label			17						/* statement label								*/#define	t_stmt			18						/* statement									*/#define	t_type			19						/* declaration type name						*/#define	t_storage		20						/* declaration storage type						*/#define	t_rtp			21						/* run time call (shr, shl)						*/#define	t_module		22						/* module										*/#define	t_address		23						/* addr of a parameter							*/#define	t_const			32						/* fixed point constant							*/#define	t_fconst		33						/* floating point constant						*/#define	t_sconst		34						/* string constant								*/#define	t_comma			48						/* comma										*/#define	t_semi			49						/* semi											*/#define	t_lpar			50						/* lpar											*/#define	t_rpar			51#define	t_colon			52						/* colon										*/#define	t_eof			53						/* eof											*/#define	t_opr			54						/* operator										*/#define	t_sdy			55						/* special form dyadic - shr(a, b) etc.			*/#define	t_while			64						/* while										*/#define	t_case			65						/* case											*/#define	t_to			66						/* to											*/#define	t_by			67						/* by											*/#define	t_end			68						/* end											*/#define	t_then			69						/* then											*/#define	t_else			70						/* else											*/#define	t_unda			72						/* undeclared proc argument						*/#define	t_und			73						/* undefined symbol								*/#define	t_input			81						/* input										*/#define	t_locat			82						/* symbol 'location' - used in proc calls		*/#define	t_copys			98						/* denotes copy scon to object file				*/#define	t_copyd			99						/* denotes copy data to object file (only data statement)	*/#define	t_ldef			100#define	t_assign		101#define	t_lnum			103						/* indicates source line number					*/#define	t_null			104						/* null statement								*/#define	t_symref		105						/* symbol reference for linker					*/#define	t_config		109						/* configuration type							*/#define	t_pform			110						/* print format									*/#define	t_string		111						/* indicates string as in print string(array);	*/#define	t_icell			112						/* interrupt cell token identifier				*/#define	t_rtns			113						/* returns keyword in procedure definition		*/#define	t_recurs		114						/* defines a procedure to be recursive			*/#define	t_swap			115						/* defines a procedure to be swappable			*/#define	t_swpcode		116						/* does not allow the swapping of string constants or data arrays	*/#define t_cond_asm		117						/* conditional assembly tokens 					*/#define	a_eof			0x0080					/* special flag (in char returned by GC) for end of file	*//* storage classes */#define	s_static		0						/* static storage								*/#define	s_automatic		1						/* automatic storage							*/#define	s_temporary		7						/* temporary storage (static or automatic) - used only by PASS2	*//* procedure attribute bits *//* There are 16 bits, in this word, allocated for use as attribute bits */#define	p_recursive		0x0001					/* recursive procedure							*/#define	p_swap			0x0002					/* swapping procedure							*/#define	p_swapscon		0x0004					/* nonswapping scons or data arrays				*//* conditional assembly subtypes */#define ca_endif		0#define ca_else			1#define ca_elseif		2/* Interpass data communications area:.  .   Certain data elements must be transferred from pass1 to pass2.   and on to pass3.   To simplify this transfer,  several important.   variables are defined to be locations of an array that is later.   written out to the intermediate file.   When pass2 reads in the.   intermediate file, the data elements are read in with it.  Pass3.   uses this area to find the location of the bound runtime package. */#define	rtp_ptrs		128						/* number of rtp pointers used by pass3			*/#define	configlen		48						/* length of configuration area in high core and interpass comm area (plus C#OFFSET for lowcore)	*/#define	whentablen		48						/* length of when table in comm area			*//* communications area locations */#define	l_pdll			((fixed)(rtp_ptrs + 0))			/* push down length								*/#define	l_key			((fixed)(rtp_ptrs + 1))			/* next available key - 1 (number of keys used)	*/#define	l_recurs_parms	((fixed)(rtp_ptrs + 2))			/* address of canonical storage for passing parameters to recursive procs	*/#define	l_altkey		((fixed)(rtp_ptrs + 3))			/* alternate keys								*//* word 4 is free */#define	l_s_names_len	((fixed)(rtp_ptrs + 5))			/* pass1 symbol table size						*/#define	l_str_data		((fixed)(rtp_ptrs + 6))			/* amount of string and data storage			*/#define	l_stack_used	((fixed)(rtp_ptrs + 7))			/* pass2 push stack size						*/#define	l_flags			((fixed)(rtp_ptrs + 8))			/* various flags (defined below)				*/#define	l_ram			((fixed)(rtp_ptrs +  9))		/* ram area length + 1							*/#define	l_extloc		((fixed)(rtp_ptrs + 10))		/* external references processed				*/#define	l__st			((fixed)(rtp_ptrs + 11))		/* pass1 symbol table max						*/#define	l__sk			((fixed)(rtp_ptrs + 12))		/* pass2 push stack max							*/#define	l__bl			((fixed)(rtp_ptrs + 13))		/* pass2 number of blocks						*/#define	l__if2			((fixed)(rtp_ptrs + 14))		/* max size of interfile #2						*//* words 15-16 are free */#define	l_iflng			((fixed)(rtp_ptrs + 17))		/* length of interfile #1						*/#define	l_if2lng		((fixed)(rtp_ptrs + 18))		/* length of interfile #2						*/#define	l_ovram			((fixed)(rtp_ptrs + 19))		/* overriding starting ram location				*/#define	l_get_blocks	((fixed)(rtp_ptrs + 20))		/* pass2 get block stats						*/#define	l_main_key		((fixed)(rtp_ptrs + 21))		/* key of main program (only when linking)		*/#define	icell			((fixed)(rtp_ptrs + 22))		/* interrupt cells								*/#define	ctab			((fixed)(icell + whentablen))	/* configuration table							*//* size of area */#define	maxcomm			((fixed)(ctab + configlen - rtp_ptrs - 1))	/* size of interpass communications area		*//* bits set in L.FLAGS: */#define	enable_flag		0x0001					/* an enable statement was encountered			*/#define	when_flag		0x0002					/* a when statement was encountered				*/#define	link_flag		0x0004					/* a library statement was encountered			*/#define	module_flag		0x0008					/* this is a module								*/#define	dump_flag		0x0100					/* dump statistics								*/#define	symtab_flag		0x0200					/* dump the symbol and sequence table			*/#define	skip_flag		0x0400					/* skip dead code analysis phase				*/#define	force_flag		0x0800					/* force code to ext memory						*/#define	debug_flag		0x1000					/* gen better code for debugging				*/#define	keep_flags		(when_flag | enable_flag)	/* flags we keep when creating a relocatable binary	*//* Transfer vector locations for the runtime package:..     As in Dartmouth's BASIC runtime package, there is a transfer vector.     at the beginning of the rtp which points to the routine to call..     The compiler only knows the location of the transfer vector.  In.     this compiler, the code gets changed by pass3 to point to the actual.     location of the routine rather than to the transfer vector location. *//* system routines */#define	l_sta			0x0000#define	l_pat			0x0001#define	l_in1			0x0002/* Model C only: */#define	l_in2			0x0003#define	l_in3			0x0004/* Model D only: */#define	l_sw1			0x0003					/* patch this location in startup to point to g.swap	*/#define	l_pgsw			0x0004					/* pointer to code to switch to page 0			*/#define	l_pgx			0x0005					/* pointer to code to exchange pages			*/#define	l_sreg			0x0006#define	l_lreg			0x0007#define	l_retn			0x0008#define	l_swe			0x0008					/* model c & later - swap entry					*/#define	l_sw2			0x0009					/* model c & later - swap patch					*/#define	l_swpp			0x000A					/* relative pointer from h.swap to g.swap		*/#define	l_swap			0x000B/* floating point routines */#define	l_fpm			0x000C#define	l_fpd			0x000D#define	l_fpa			0x000E#define	l_fps			0x000F#define	l_fix			0x0010#define	l_flo			0x0011#define	l_abs			0x0015#define	l_log			0x0016#define	l_atn			0x0017#define	l_cos			0x0018#define	l_sne			0x0019#define	l_tan			0x001A#define	l_exp			0x001B#define	l_sqr			0x001C/* misc routines */#define	l_rot			0x0021#define	l_shl			0x0022#define	l_shr			0x0023#define	l_bmv			0x0025#define	l_bst			0x0026#define	l_brk			0x0027/* Transfer vector (cont.):.     output routines */#define	l_npr			0x0028#define	l_spr			0x0029#define	l_pri			0x002A#define	l_fpr			0x002B#define	l_con			0x002C#define	l_opr			0x002D#define	l_pch			0x002E/* terminal input */#define	l_fin			0x0030#define	l_sin			0x0031#define	l_ipr			0x0032#define	l_idn			0x0033#define	l_ich			0x0034#define	l_fxi			0x0037/* byte/string routines */#define	l_byt			0x0038#define	l_pbt			0x0039#define	l_erd			0x003B#define	l_ewr			0x003C#define	l_ept			0x003D#define	l_ipt			0x003E#define	l_est			0x003F/* special functions */#define	l_ter			0x0040#define	l_sbr			0x0041#define	l_sbw			0x0042#define	l_see			0x0043#define	l_fde			0x0046#define	l_scur			0x0047/* fixed point math ops */#define	l_fmu			0x0048#define	l_fdi			0x0049/* other routines */#define	l_rfl			0x004A#define	l_wfl			0x004B#define	l_wsl			0x004C#define	l_prd			0x004D#define	l_pwr			0x004E#define	l_swi			0x004F/* Values greater than l_interp indicate *//* calls to Mac-hosted routines running  *//* the interpreter						 */#define	l_interp		0x0100