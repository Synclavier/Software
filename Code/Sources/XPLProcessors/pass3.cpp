/* $Dump statistics */


/* Scientific XPL Compiler - Pass 3
.  
.    This program forms pass3 of the XPL compiler.   This program
.    iteratively reads through the output file generated by pass2,
.    computes the locations of all instructions to be generated,
.    compacts as many instructions as possible into one word,
.    optimizes jumps and subroutine calls, deletes 'dead' code,
.    and then emits the code.  If any libraries are referenced by
.    the program, they are linked in during this pass.
.
.    Modification history:
.      13 Oct 1983:  Recreated relocatable XPL [KJC]
.      10 Feb 1984:  Cleaned up symbol table output [KJC]
.      20 Feb 1984:  Added insert statements to sequence table output [KJC]
.      29 Feb 1984:  Added support for true recursion [KJC]
.       1 May 1984:  Made OPTIMIZE toss out DO-loops in conditional DO-blocks [KJC & CWJ]
.      20 Jul 1984:  Fixed OPTIMIZE so it didn't toss out GOTO's [KJC]
.       7 Sep 1984:  Fixed OPTIMIZE so it truly does a dead code analysis [KJC & CWJ]
.      17 Sep 1984:  Added overlays (swappable procs) [KJC]
.      29 Oct 1984:  Cleaned up overlays [KJC]
.       7 Nov 1984:  Fixed a jump-to-jump deletion bug in OPTIMIZE [KJC & CWJ]
.      20 Dec 1984:  Changed offset table emission in OPTIMIZE to make offsets absolute [KJC]
.      27 Dec 1984:  Shrink out scon/data and temps from uncalled procs [KJC]
.      26 Mar 1985:  Fixed a swap table backpatch bug in FINISH [KJC]
.      27 Jul 1985:  Changed structure of linked programs so MAIN is first [KJC]
.      29 Jul 1985:  Moved swap table to ext mem and allocate key tables from ext mem [KJC]
.       1 Aug 1985:  Dynamically allocate RTP buffer and moved key flags from KEYJTO to KEYFLAG [KJC]
.      16 Aug 1985:  Added swapping of SCON [KJC]
.      24 Oct 1985:  Added user device drivers through READDATA/WRITEDATA [KJC]
.       3 Feb 1986:  Added swapping of data statements in swappable procs [KJC]
.      20 Feb 1986:  Added user device types for FIND_DEVICE [KJC]
.      30 Apr 1986:  Moved symbol table to external memory [CWJ]
.      15 Oct 1986:  Updated for -7 catalog structure [KJC]
.       5 Nov 1986:  Changed RECURSIVE procs to calculate variable pointers [KJC]
.       9 Nov 1986:  Defined and fully supported storage classes [KJC]
.      17 Feb 1987:  Numerous changes to speed up pass3 [KJC]
.         Sep 1988:  AG, CJ - Model D processor,  object code optimizing,
.         Oct 1990:  CJ - coded alternate keys
*/

/*	Translated to C:   	11/17/96 at 08:51	*/
/*	Translator Version:	0.000				*/

#include 	<string.h>
#include 	<stdlib.h>
#include 	<stdio.h>

#include	"XPLCompiler.h"
#include	"XPLRuntime.h"

#include	"defs.h"
#include	"p23-defs.h"

#include	"syslits.h"
#include	"literals.h"
#include	"asciilit.h"


/* Misc extractions: */

static	void	astrcpy(array dest, char* source)
{
	fixed i = dest[0] = strlen(source);
	fixed j;
	
	for (j=0; j<i; j++)
		pbyte(dest, j, source[j]);
		
	pbyte(dest, i, 0);
}


static	fixed	astrcmp(						/* string compare a la C: 0 if equal, <0 if s < t, >0 if s > t	*/
	fixed	s[],
	fixed	t[])								/* the strings to compare						*/
{
	static	fixed	len;						/* length of the smallest string				*/
	static	fixed	i, j;
	
	if (s [0] > t [0])							/* is S larger than T?							*/
		len = t [0];							/* yes, min(s (0), t (0)) = t (0)				*/
	else len = s [0];							/* no,  min(s (0), t (0)) = s (0)				*/
		
	i = 0;										/* start comparing from first byte				*/
	
	if (s [1] == t [1]) {						/* do word compare if looks like a match		*/
		i = 1;									/* start comparing from the first word			*/
		j = shr(len + 1, 1);					/* end the comparison at the last word			*/
		
		while ((i < j) && (s [i] == t [i])) {	/* compare each word							*/
			i = i + 1;
		}
			
		i = shl(i - 1, 1);						/* go back to starting character of last word compared	*/
	}											/* of word compare								*/
		
	while ((i < len) && (byte(s, i) == byte(t, i))) {	/* compare each byte in last word				*/
		i = i + 1;
	}
		
	if ((i == s [0]) && (i == t [0]))			/* perfect match?								*/
		return (0);								/* yes, return zero								*/
	else {										/* no, return difference						*/
		if (i == len)							/* are we at the end of one of the strings?		*/
			return (s [0] - t [0]);				/* yes, return difference in their lengths		*/
		else return (byte(s, i) - byte(t, i));	/* no, return difference in last byte compared	*/
	}
}

static	fixed			toupper(				/* uppercase an ASCII word						*/
	fixed	word)								/* the word to uppercase						*/
	
{
	if (_ILE_((word & (fixed) 0x00FF) - l_a, (l_z - l_a)))/* is the lower byte lowercase?					*/
		word = word - (l_a - a_a);				/* yes, make it upper							*/
		
	if (_ILE_((word & (fixed) 0xFF00) - shl(l_a, 8), shl(l_z - l_a, 8)))/* and the upper byte?							*/
		word = word - shl(l_a - a_a, 8);		/* yes, make it upper							*/
		
	return (word);								/* return the converted word					*/
}

static	void	set_extmem(						/* set external memory to VAL					*/
	fixed	start, 								/* starting sector								*/
	fixed	finish, 							/* ending sector								*/
	fixed	val)								/* value to assign								*/
{
    fixed			_upper0;
	fixed	i, j;
	
	for (_upper0 = finish - 1, i = start; i <= _upper0; i += 64) {
		j = finish - i;							/* get sectors left to set						*/
		if (_IGT_(j, 64)) j = 64;				/* limit to 64									*/
		XPLextset (i, 0, shl(j, 8), val);		/* set external memory							*/
	}
}
	
static	fixed	r[maxcomm + rtp_ptrs + 1];		/* set up the communications area				*/
static	fixed	rtpsubs[rtp_ptrs];				/* used to determine which rtp subs are used	*/

static	fixed	debug_on;						/* True if we produce best code for debug		*/

/* Pass3 definitions: */

#define	divmax			256						/* maximum number of ram divisions				*/
#define	altstacklen		512						/* stack size									*/
#define	istacklen		((fixed)(3*ins_levels))	/* insert file stack length						*/
#define	pstacklen		s_depth_max				/* procedure stack length						*/
#define	insmax			128						/* allow 128 x 16 = 2048 insert statements/program	*/
#define	cutoff			3						/* maximum number of registers saved in-line on proc entry	*/

#define	t_executable	1						/* executable file file type					*/
#define	t_relocatable	2						/* relocatable binary file type					*/

/* linker definitions */

#define	lib_size		200						/* maximum number of libraries linker can handle	*/
#define	lib_name_size	((fixed)(lib_size*10))	/* maximum area for library names				*/
#define	hash_size		511						/* size of linker hash table (must be 2^n - 1)	*/
#define	most_symbols	6553					/* can never handle more symbols than these (just 65536/SYMBOL_LENGTH)	*/
#define	symbol_length	10						/* average symbol length = 18 chars; can be decreased 1 char by allocation rounding	*/
#define	stentry_size	((fixed)(symbol_length + 10))	/* number of words in a symbol table entry		*/
#define	stable_round	(_scale_(stentry_size, 3, 10))	/* round up .7 and up					*/
#define	name_size		64						/* maximum size of linker name block			*/
#define	devtablen		14						/* length of device driver table				*/
#define	devdrivers		10						/* number of words of that table that are device driver pointers (rest are for FIND_DEVICE)	*/
#define	spectablen		2						/* special labels - used by pass 3 only,  not rtp	*/

/* runtime package routines */
#define	rfbufl			5120					/* word size of rtp file buffer					*/
#define	sreg			rfbuf [l_sreg]			/* save registers routine						*/
#define	lreg			rfbuf [l_lreg]			/* load registers								*/
#define	retn			rfbuf [l_retn]			/* return routine								*/
#define	swpe			rfbuf [l_swe ]			/* model c,d swap proc entry					*/

/* communication area defs */

#define	l_icell			icell					/* interrupt cells for when						*/
#define	l_ctab			ctab					/* configuration table							*/

#define	ram				r [l_ram]
#define	pdll			r [l_pdll]
#define	max_refs		r [l_extloc]			/* maximum number of external references the linker can handle/library	*/
#define	main_key		r [l_main_key]			/* key of main program (when linking)			*/

#define	prctyp			(shr(r [l_ctab + 1], 8) & 7)	/* configuration area defs						*/

/* Pass 3 global declarations: */

static	ufixed	bit[] = {0x0001,     0x0002,     0x0004,     0x0008,
                         0x0010,     0x0020,     0x0040,     0x0080,
						 0x0100,     0x0200,     0x0400,     0x0800,
                         0x1000,     0x2000,     0x4000,     0x8000};

static	fixed	iteration;						/* where we are in pass3 (for status only)		*/
static	fixed	cur_loc;						/* current object code location					*/
static	fixed	max_keys;						/* maximum number of keys available				*/
static	fixed	max_alts;						/* maximum number of alt keys available			*/

static	fixed	rtpcode;						/* amount of RTP code bound into final object program	*/
static	fixed	vstrt;							/* pointer to start of variable area			*/
static	fixed	obj_base;						/* pointer to start of object code				*/

static	fixed	oldram  [divmax + 1];			/* used to toss ram from procs					*/
static	fixed	deltaram[divmax + 1];
static	fixed	ramptr;

static	fixed	oldscon[divmax + 1];			/* used to toss scon/data from procs			*/
static	fixed	deltascon[divmax + 1];
static	fixed	sconptr;
static	fixed	rfbuf[rfbufl];					/* rtp buffer									*/

/* swap area */

static	fixed	swap_ram;						/* pointer to ram reserved for swapping			*/
static	fixed	swap_area;						/* address of swap area							*/
static	fixed	swap_size;						/* length of swap area							*/
static	fixed	swap_procs;						/* number of swappable procs					*/
static	fixed	swap_total;						/* total number of sectors of swapped procs		*/
static	fixed	swap_words;						/* number of words in last sector of swapped procs	*/
static	fixed	swap_scon;						/* maximum SCON swapped by any one procedure	*/

/* output file buffer info */

static	fixed	objlng;							/* object file length (in words) as it grows	*/
static	fixed	introlen;						/* length of "intro" part of object file (lowcore)	*/

static	fixed	redirect_object = 0;			/* True if object code should be redirected to overlay file	*/
static	fixed	creating_object = 1;			/* True if we're creating the object file (set FALSE only in FINISH)	*/
static	fixed	creating_reloc = 0;				/* True if we're creating a reloc file			*/

/* symbol table buffer info */

static	fixed	redirect_symtab = 0;			/* True if SYMTAB should be redirected to file '-SYMTAB-'	*/

/* General error handling:
.
.  ER.SYS: call to abort the compiler because of a system error (most
.          likely a consistency check failed).
.
.  ER.FTL: call when something the user did has caused a fatal error
.          (i.e., when there's not enough memory to compile the user's
.          program).
*/

static	void	er_sys(							/* abort the compiler							*/
	char	message[], 							/* the message to print							*/
	char	location[])							/* name of procedure we failed in				*/
	
{
	print("\n");
	print("### Compiler system error:\n");
	print("%s%s%s%s%s\n", "      ", message, " (pass3 ", location, ").");
	exit(-1);
}
	
static	void	er_ftl(							/* process a user related fatal error			*/
	char	message[])							/* the message to print							*/
	
{
	print("\n");
	print("%s%s\n", message, ".");
	exit(-1);
}
	
/* $$File input/output subroutines:
.  
.   The following routines are used to  read through the second intermediate
.   file and to write to the object file.
.
.   The intermediate file is read on a word by word basis.  The last word
.   read from the IF may be rewritten by calling WRITEIF.
.
.   The routine WRITEOBJ is used to write one more word to the output file.
.   The output file is randomly accessed under certain conditions to patch
.   certain locations of memory.
*/

static	long	interfile_in_pointer   = INTER_FILE_2_START;
static	long	main_in_pointer        = INTER_FILE_2_START + 256;
static	long	objectfile_out_pointer = 0;
static	long	largest_in_pointer     = INTER_FILE_2_START;

static	fixed	readmain()						/* used to read main code when linking			*/
{
	return (inter_file[main_in_pointer++]);
}
	
static	void	closemain()						/* so resolve can close it...					*/
{
}

static	fixed	readif()						/* called to get next word						*/
{
	return (inter_file[interfile_in_pointer++]);
}
	
static	void	writeif(						/* rewrite word just read from file				*/
	fixed	word)
	
{
	inter_file[interfile_in_pointer - 1] = word;
}
	
static	void	copyif(							/* called to overwrite next word (used for library copy - assumes we won't read after this)	*/
	fixed	word)								/* data to overwrite							*/
	
{
	if (interfile_in_pointer >= INTER_FILE_WORD_SIZE)
	{
		print("\n");
		print("Program too large (pass 3 library copy).\n");
		exit(-1);
	}
	
	inter_file[interfile_in_pointer++] = word;
}
	
static	void	resetif()						/* call procedure to reset intermediate file	*/
{
	if (objectfile_out_pointer > (INTER_FILE_2_START + 256))
		er_ftl ((char *) "Program too large (object file/IF collision)");
		
	if (interfile_in_pointer > largest_in_pointer)
		largest_in_pointer = interfile_in_pointer;
	
	interfile_in_pointer = INTER_FILE_2_START + 256;	/* skip communication area				*/
}
	

/* $$The following routines process the object file (used for linking and
.   for generating the final object code). */

static	void	objforce()						/* used to force object buffer					*/
{
	if (!out_file)
		er_ftl ((char *) "Missing output file");			/* abort										*/
	
	// Convert in place
	#if __LITTLE_ENDIAN__
	{
		ufixed * dataPtr = (ufixed *) inter_file;
		long   i = objectfile_out_pointer;
		
		while (i--)
        {*dataPtr = CFSwapInt16BigToHost(*dataPtr); dataPtr++;}
	}
	#endif

	fwrite ((void *) inter_file, 2, objectfile_out_pointer, out_file);

	// Convert back in place, although I doubt the data is looked at...
	#if __LITTLE_ENDIAN__
	{
		ufixed * dataPtr = (ufixed *) inter_file;
		long   i = objectfile_out_pointer;
		
		while (i--)
        {*dataPtr = CFSwapInt16BigToHost(*dataPtr); dataPtr++;}
	}
	#endif

	fflush(out_file);
}
	
static	void	writeobject(					/* append one word to object file - use WRITEOBJ to output to object	*/
	fixed	word)
	
{
	if (objectfile_out_pointer >= INTER_FILE_WORD_SIZE)
	{
		print("\n");
		print("Program too large (pass 3 object file).\n");
		exit(-1);
	}

	inter_file[objectfile_out_pointer++] = word;
	
	if (creating_object) {						/* only change OBJLNG if creating the object file	*/
		objlng = objlng + 1;					/* increment file length						*/
		if ((objlng        == 0)				/* file too big									*/
		&& (creating_reloc == 0))				/* does not apply to relocatables				*/
			er_ftl ((char *) "Object file too big for compilation");	/* abort										*/
	}
}												/* and that is it								*/
	
/* The following routines process the overlay file during final object code
.  generation. */

FILE 	*ovr_file = NULL;

static	unsigned long	ovr_length;

static	void	writeovr(						/* append one word to object file				*/
	fixed	word)
	
{
	if (!ovr_file)
		er_ftl ((char *) "Missing data file (writeovr)");

	ovr_length++;

	putc((char) (shr(word, 8)), ovr_file);		/* write MSB first to match abledisktool		*/
	putc((char)      word,      ovr_file);		/* note: endian swap not needed in this case	*/
}												/* and that is it								*/
	
static	void	writeobj(						/* append a word to the current object file		*/
	fixed	word)								/* the word to append							*/
{
	if (redirect_object & 1)					/* are we redirecting to the overlay file?		*/
		writeovr (word);						/* yes, write to overlay file					*/
	else writeobject (word);					/* no, write to object file						*/
}


/* $$The following routines process the overlay file.  They are
.   used to copy the overlay file after the object file.  They
.   are only used in FINISH (and by the linker to read in libraries);
.   keep it that way! */

static	fixed	readovr()						/* read the next word from the overlay file		*/
{
	if (!ovr_file)
		er_ftl ((char *) "Missing data file (readovr)");
	
	#if __LITTLE_ENDIAN__
	{
		return ((shl((unsigned char) getc(ovr_file), 8))
		|       ((fixed) (unsigned char) getc(ovr_file)));
	}
	#endif

	#if __BIG_ENDIAN__
	{
		return (((fixed) (unsigned char) getc(ovr_file))
		|       (shl((unsigned char) getc(ovr_file), 8)));
	}
	#endif
}
	
static	void	resetovr()						/* reset the overlay file to the beginning (position zero)	*/
{
	if (!ovr_file)
		er_ftl ((char *) "Missing data file (resetovr)");
	fflush (ovr_file);
	rewind (ovr_file);
}
	
static	void	closeovr()						/* close the overlay file						*/
{
	if (!ovr_file)
		er_ftl ((char *) "Missing data file (closeovr)");
	
	fclose(ovr_file);
	ovr_file = NULL;
}
	

/* $$Symbol table output and formatting routines: */

static	void	symforce()						/* force the symbol table buffer				*/
{
	if (sym_file)
	{
		fflush(sym_file);
		fclose(sym_file);
	}
	
	sym_file = NULL;
}
	
static	void	writesym(						/* write a character to the symbol table file	*/
	fixed	chr)								/* the character to write						*/
	
{
	if (!sym_file)
		print("%c", chr);
	else
		putc((char) chr, sym_file);
}
	
static	void	eol()							/* send an end-of-line to the symbol table		*/
{
	writesym('\n');
}
	
static	void	pstring(						/* print a string to the symbol table			*/
	char	buffer[])							/* the string to print							*/
{
	while (*buffer)
		writesym(*buffer++);
}
	
static	void	pastring(						/* print a string to the symbol table			*/
	fixed	buffer[])							/* the string to print							*/
{
	fixed   i = buffer[0];						/* get able string format						*/
	fixed   j = 0;
	
	while (i--)
		writesym(byte(buffer, j++));
}
	
static	void	unum(							/* output an unsigned number (0 to 65535)		*/
	fixed	n)
{
	static	fixed	i, r;						/* n:  value to print							*/
	static	fixed	go;
	
	static	fixed	_divisors[] = {10000,1000,100,10,1};	/* powers of ten								*/
	
	writesym (a_sp);							/* start with a space (no sign)					*/
	
	go = 0;										/* suppress leading zeroes						*/
	
	for (i = 0; i <= 4; i++) {					/* loop over 5 digits							*/
		r = 0;									/* assume digit is zero							*/
		
		while (_IGE_(n, _divisors [i])) {		/* simulate unsigned divide						*/
			n = n - _divisors [i];
			r = r + 1;
		}
			
		if (r > 0) go = 1;						/* turn on printing								*/
			
		if (go & 1 || (i == 4))					/* print at least one zero						*/
			writesym (a_0 + r);					/* print digit									*/
		else writesym (a_sp);					/* or print space								*/
	}											/* of digits loop								*/
}
	
static	void	onum(							/* output a number in octal						*/
	fixed	n)
{
	static	fixed	i;							/* n:  value to print							*/
	
	writesym(a_0);
	writesym(l_x);

	for (i = 0; i <= 3; i++) {					/* loop over 4 digits							*/
		n = rot(n, 4);
		if ((n&0xF) < 10)
			writesym (a_0 + (n & 0xF));
		else
			writesym (a_a + (n & 0xF) - 10);
	}
}
	
/* $$Initialize for pass3: */

static	void	init()
{
	fixed	i, _upper0;
	
	for (_upper0 = maxcomm + rtp_ptrs, i = rtp_ptrs; i <= _upper0; i++) {	/* get basic info								*/
		r [i] = readif();
	}
		
	for (i = maxcomm + 1; i <= 255; i++) {		/* position pointer to first token (ignore remainder of first sector)	*/
		readif();
	}
}
	
/* As part of initialization, read in the entire contents of
.  the run time package file into memory. */

static	void	init_rtp()						/* read the rtp into memory						*/
{
    fixed	_upper0;
	fixed	i;
	long	length;
	
	if (prctyp<2)
		rtp_file = (FILE *) open_able_file((char *) ":*SYSTEM:*RTB-7.sdat");
	else if (prctyp == 2)
		rtp_file = (FILE *) open_able_file((char *) ":*SYSTEM:*RTC-7.sdat");
	else if (debug_on)
		rtp_file = (FILE *) open_able_file((char *) ":*SYSTEM:*RTDB-7.sdat");
	else
		rtp_file = (FILE *) open_able_file((char *) ":*SYSTEM:*RTD-7.sdat");

	length = fread  ((void *) rfbuf, 2, rfbufl, rtp_file);
	
	#if __LITTLE_ENDIAN__
	{
		ufixed * dataPtr = (ufixed *) rfbuf;
		long   i = length;
		
		while (i--)
        {*dataPtr = CFSwapInt16BigToHost(*dataPtr); dataPtr++;}
	}
	#endif

	if (length >= rfbufl)									/* make sure the rtp isn't larger than our buffer	*/
		er_sys ((char *) "runtime package is too long", (char *) "init_rtp");	/* abort										*/
		
	if (length <= 3000)										/* make sure the rtp has some meat on it		*/
		er_sys ((char *) "runtime package is too short", (char *) "init_rtp");
		
	introlen = rfbuf [rfbuf [l_sta]] - rfbuf [l_sta] - 1;	/* number of words in start routine				*/
	
	for (_upper0 = rfbuf [l_sta] + introlen, i = rfbuf [l_sta] + 1; i <= _upper0; i++) {	/* write the start routine to the object		*/
		writeobj (rfbuf [i]);
	}
		
	rtpcode = introlen;							/* rtp data is always at least this much		*/
}
	
/* $$The following routines access the KEYLOC, KEYJTO, and KEYFLAG arrays.
.  If XMEM is set, the arrays are in external memory.  Otherwise, they are
.  in main memory.  KEYLOC.PTR, KEYJTO.PTR, and KEYFLAG.PTR are the arrays'
.  base pointers (in words for main memory; in sectors for external memory).
.
.  The KEYLOC array is used to contain the absolute object code location
.  of a label definition.  Whenever we come to a label definition,  we
.  store the current location counter (CUR.LOC) in the KEYLOC array.
.  On the second pass through, we can then determine whether or not
.  the jump instruction can be compacted into one word. 
.
.  The KEYJTO array is used to indicate whether the instruction at this
.  location is another jump instruction (to detect jumps to jumps).  The
.  key that is jumped to (if any) from this label location is stored in
.  the KEYJTO array.  Before JUMPS, KEYJTO is only used by procedures
.  (PROC_NOSWAP and PROC_TEMPS).
.
.  The KEYFLAG array is used to indicate:
.    a) whether a label is used as the destination of a jump instruction
.       (i.e., whether the code that follows is active) [ABIT],
.    b) whether we've encountered this label yet during this pass [DBIT], and
.    c) whether this label represents the start of a procedure [PBIT].
.
.  For procedures, KEYFLAG (key + proc_flags) is used to indicate:
.    a) whether this procedure is recursive [P.RECURSIVE], and
.    b) whether this procedure swaps [P.SWAP], and
.    c) whether this procedure swaps its scon/data [P.SWAPSCON]
*/

static	fixed	keyloc_ptr;						/* pointer to KEYLOC							*/
static	fixed	keyjto_ptr;						/* pointer to KEYJTO							*/
static	fixed	keyflag_ptr;					/* pointer to KEYFLAG							*/

static	fixed	altloc_ptr;						/* pointer to ALTLOC							*/
static	fixed	altjto_ptr;						/* pointer to ALTJTO							*/
static	fixed	altflag_ptr;					/* pointer to ALTFLAG							*/

static	fixed	swinfo_ptr;						/* pointer to SWINFO							*/
#define	swinfo_max	((fixed)(32*256))			/* # of swap procedures that are optimized		*/
												/* twice as much storage is used           		*/

/* Keyflag bit assignments: */

#define	abit			0x0001					/* indicates active (if not set, indicates unknown)	*/
#define	pbit			0x0002					/* indicates this is the label for a procedure entry	*/
#define	dbit			0x0008					/* indicates defined already during this pass (chosen so doesn't collide with proc bits - see CLEAR_KEYFLAG)	*/

/* Data storage for procedure definitions:                         */
/*                                                                 */
/*    The first 3 keys are actual location keys using KEYLOC,      */
/*    Keyjto,  and KEYFLAGS.   The next two locations of each of   */
/*    these three arrays is used for special information not       */
/*    related to keys or locations or jumps:                       */

#define	proc_entry		0						/* offset for procedure entry key				*/
#define	proc_jump		1						/* offset for jump around procedure key			*/
#define	proc_return		2						/* offset for procedure return key				*/

#define	proc_dswp		3						/* Keyloc   - offset for NOSWAP bit list		*/
												/*   for procedure data (1st two iterations)	*/
#define	proc_regs		3						/* Keyloc   - offset for registers used			*/
												/*   by procedure (3rd iteration and on)     	*/
#define	proc_inside		1						/*   bit 0 - set to 1 if this proc is			*/
												/*   defined inside a swapping procedure.    	*/
#define	proc_bound		2						/*   bit 1 - set to 1 if this proc is			*/
												/*   forced to a page boundary               	*/

#define	reg_mask		((fixed)(~(15)))

#define	proc_stack		4						/* Keyloc   - offset for stack frame size		*/

#define	proc_noswap		3						/* Keyjto   - offset for formal parameter		*/
												/*   Noswap bitlist (thru JUMPS)             	*/
#define	proc_objsz		3						/* Keyjto   - length of object code only (no	*/
												/*   Scons) of swapping procedure - SWAP     	*/
												/*   and after.                              	*/

#define	proc_temps		4						/* Keyjto   - offset for temp start of			*/
												/*            temps in recursive procs       	*/

#define	proc_flags		3						/* Keyflags - offset for procedure flags		*/
#define	proc_info		4						/* Keyflags - more info about the proc			*/

#define	proc_when		1						/*   bit 0 - set if a proc is called from		*/
												/*   within a when statement                	*/

/* Note:  KEYJTO   (4) is only used by recursive procs                */
/* Note:  KEYFLAGS (4) is unused, but it is only a 4-bit field        */

/* Swinfo storage: 2 words per swapping procedure, indexed by         */
/*                 2 * swapping proc id#                              */
/*                 information is nonzero only if compiling for       */
/*                 model d and procedure has no swapping strings or   */
/*                 data (ie SWAPCODE)                                 */
/*    word 0:      location on page where procedure starts            */
/*    word 1:      lower half - page (relative to start of swap file) */
/*    word 1:      upper half - number of arguments passed to proc    */

static	fixed	keyloc(							/* return the contents of array cell KEYLOC (index)	*/
	ufixed	index)								/* index into KEYLOC array						*/
	
{
	_write_60(keyloc_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	return (_read_62());						/* return the element							*/
}
	
static	fixed	altloc(							/* return the contents of array cell ALTLOC (index)	*/
	ufixed	index)								/* index into ALTLOC array						*/
	
{
	_write_60(altloc_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	return (_read_62());						/* return the element							*/
}
	
static	void	set_keyloc(						/* set the contents of array cell KEYLOC (index) to VALUE	*/
	ufixed	index, 								/* index into KEYLOC array						*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(keyloc_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	_write_62(value);							/* set the element to VALUE						*/
}
	
static	void	set_altloc(						/* set the contents of array cell ALTLOC (index) to VALUE	*/
	ufixed	index, 								/* index into ALTLOC array						*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(altloc_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	_write_62(value);							/* set the element to VALUE						*/
}
	
static	fixed	keyjto(							/* return the contents of array cell KEYJTO (index)	*/
	ufixed	index)								/* index into KEYJTO array						*/
	
{
	_write_60(keyjto_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	return (_read_62());						/* return the element							*/
}
	
static	fixed	altjto(							/* return the contents of array cell ALTJTO (index)	*/
	ufixed	index)								/* index into ALTJTO array						*/
	
{
	_write_60(altjto_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	return (_read_62());						/* return the element							*/
}
	
static	void	set_keyjto(						/* set the contents of array cell KEYJTO (index) to VALUE	*/
	ufixed	index, 								/* index into KEYJTO array						*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(keyjto_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	_write_62(value);							/* set the element to VALUE						*/
}
	
static	void	set_altjto(						/* set the contents of array cell ALTJTO (index) to VALUE	*/
	ufixed	index, 								/* index into ALTJTO array						*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(altjto_ptr + shr(index, 8));		/* write sector address of array element		*/
	_write_61(index);							/* and word address								*/
	_write_62(value);							/* set the element to VALUE						*/
}
	
static	fixed	keyflag(						/* return the contents of array cell KEYFLAG (index)	*/
	fixed	index)								/* index into KEYFLAG array						*/
{
	static	fixed	value;						/* retrived value								*/
	
	_write_60(keyflag_ptr + shr(index, 8 + 2));	/* write sector address of array element		*/
	_write_61(shr(index, 2));					/* and word address								*/
	value = _read_62();							/* pick up word containg requested nibble from external memory	*/
		
	switch (index & 0x0003) {					/* hardcode SHR(VALUE, SHL(INDEX AND "3", 2))	*/
		case 0:
			return (    value      & 0x000F);	/* Shr by 0										*/
			break;
		case 1:
			return (shr(value,  4) & 0x000F);	/* Shr by 4										*/
			break;
		case 2:
			return (shr(value,  8) & 0x000F);	/* Shr by 8										*/
			break;
		case 3:
			return (shr(value, 12) & 0x000F);	/* Shr by 12									*/
			break;
	}
	return (0);
}
	
static	fixed	altflag(						/* return the contents of array cell ALTFLAG (index)	*/
	ufixed	index)								/* index into ALTFLAG array						*/
{
	static	fixed	value;						/* retrived value								*/
	
	_write_60(altflag_ptr + shr(index, 8 + 2));	/* write sector address of array element		*/
	_write_61(shr(index, 2));					/* and word address								*/
	value = _read_62();							/* pick up word containg requested nibble from external memory	*/
		
	switch (index & 0x0003) {					/* hardcode SHR(VALUE, SHL(INDEX AND "3", 2))	*/
		case 0:
			return (    value      & 0x000F);	/* Shr by 0										*/
			break;
		case 1:
			return (shr(value,  4) & 0x000F);	/* Shr by 4										*/
			break;
		case 2:
			return (shr(value,  8) & 0x000F);	/* Shr by 8										*/
			break;
		case 3:
			return (shr(value, 12) & 0x000F);	/* Shr by 12									*/
			break;
	}
	return (0);
}
	
static	void	set_keyflag(					/* set the contents of array cell KEYFLAG (index) to VALUE	*/
	ufixed	index, 								/* index into KEYFLAG array						*/
	fixed	value)								/* value to set element to						*/
	
{
	static	fixed	mask[] = {~ 0x000F, ~ shl(0x000F, 4), ~ shl(0x000F, 8), ~ shl(0x000F, 12)};	/* masks for each nibble position				*/
	
	value = (value & 0x000F);					/* keep lowest nibble only						*/
	
	switch (index & 0x0003) {					/* move nibble to proper position [hardcode SHL(VALUE, SHL(INDEX AND "3", 2))]	*/
		case 0:
			;									/* Shl by 0										*/
			break;
		case 1:
			value = shl(value,  4);				/* Shl by 4										*/
			break;
		case 2:
			value = shl(value,  8);				/* Shl by 8										*/
			break;
		case 3:
			value = shl(value, 12);				/* Shl by 12									*/
			break;
	}											/* of moving nibble to proper position			*/
		
	_write_60(keyflag_ptr + shr(index, 8 + 2));	/* write sector address of array element		*/
	_write_61(shr(index, 2));					/* and word address								*/
	_write_62(((_read_62() & mask [index & 0x0003]) | value));	/* set the element to VALUE						*/
}
	
static	void	set_altflag(					/* set the contents of array cell ALTFLAG (index) to VALUE	*/
	ufixed	index, 								/* index into ALTFLAG array						*/
	fixed	value)								/* value to set element to						*/
	
{
	static	fixed	mask[] = {~ 0x000F, ~ shl(0x000F, 4), ~ shl(0x000F, 8), ~ shl(0x000F, 12)};	/* masks for each nibble position				*/
	
	value = (value & 0x000F);					/* keep lowest nibble only						*/
	
	switch (index & 0x0003) {					/* move nibble to proper position [hardcode SHL(VALUE, SHL(INDEX AND "3", 2))]	*/
		case 0:
			;									/* Shl by 0										*/
			break;
		case 1:
			value = shl(value,  4);				/* Shl by 4										*/
			break;
		case 2:
			value = shl(value,  8);				/* Shl by 8										*/
			break;
		case 3:
			value = shl(value, 12);				/* Shl by 12									*/
			break;
	}											/* of moving nibble to proper position			*/
		
	_write_60(altflag_ptr + shr(index, 8 + 2));	/* write sector address of array element		*/
	_write_61(shr(index, 2));					/* and word address								*/
	_write_62(((_read_62() & mask [index & 0x0003]) | value));	/* set the element to VALUE						*/
}
	
static	void	clear_keyflag(					/* clear BIT in entire KEYFLAG and ALTFLAG array (assumes no bit definition collosions)	*/
	fixed	bit)								/* bit to clear									*/
{
    ufixed			_upper0;
	static	fixed	i;
	
	bit = (~ (bit | shl(bit, 4) | shl(bit, 8) | shl(bit, 12)));	/* set up bit mask								*/
	
	_write_60(keyflag_ptr);						/* write sector address of KEYFLAG				*/
	
	for (_upper0 = shr(r [l_key], 2), i = 0; i <= _upper0; i++) {	/* loop over entire array						*/
		_write_63((_read_62() & bit));			/* turn off bit									*/
	}
		
	_write_60(altflag_ptr);						/* write sector address of ALTFLAG				*/
	
	for (_upper0 = shr(r [l_altkey], 2), i = 0; i <= _upper0; i++) {	/* loop over entire array						*/
		_write_63((_read_62() & bit));			/* turn off bit									*/
	}
}
	
static	fixed	swinfo(							/* look up info about a swapping procedure		*/
	ufixed	ptr)								/* pass pointer using stride of 2				*/
	
{
	_write_60(swinfo_ptr + shr(ptr,8));
	_write_61(ptr);
	return (_read_62());						/* return with pointers set up in case modify	*/
}
	
static	void	set_swinfo(						/* store info about a swapping procedure		*/
	ufixed	ptr, 								/* pass pointer using stride of 2				*/
	fixed	val)
	
{
	_write_60(swinfo_ptr + shr(ptr,8));
	_write_61(ptr);
	_write_62(val);
}
	
/* $$Stack routines:
.  
.     A push down stack is used to store information during pass3.  The
.     following routines store and read information from the stack. */

static	fixed	stkptr;							/* pointer to same								*/

static	void	push(							/* save on stack								*/
	fixed	word)
{
	if (_IGT_(stkptr, stacksize)) er_sys ((char *) "stack overflow", (char *) "push");
	stack [stkptr] = word;
	stkptr = stkptr + 1;						/* incr											*/
}
	
static	fixed	pop()							/* and recover from stack						*/
{
	stkptr = stkptr - 1;						/* decrement ponter								*/
	return (stack [stkptr]);					/* get it										*/
}
	
static	fixed	altstk[altstacklen + 1];		/* holds it										*/
static	fixed	altstkptr;						/* pointer to same								*/

static	void	altpush(						/* save on stack								*/
	fixed	word)
{
	if (_IGT_(altstkptr, altstacklen)) er_sys ((char *) "alt stack overflow", (char *) "altpush");
	altstk [altstkptr] = word;
	altstkptr = altstkptr + 1;					/* incr											*/
}
	
static	fixed	altpop()						/* and recover from stack						*/
{
	altstkptr = altstkptr - 1;					/* decrement ponter								*/
	return (altstk [altstkptr]);				/* get it										*/
}
	
static	fixed	istk[istacklen + 1];			/* insert file stack							*/
static	fixed	istkptr;						/* pointer to same								*/

static	void	ipush(							/* save on insert file stack (must be used in OPTIMIZE because normal stack is used for jumps)	*/
	fixed	word)
{
	if (_IGT_(istkptr, istacklen)) er_sys ((char *) "stack overflow", (char *) "ipush");
	istk [istkptr] = word;						/* save it										*/
	istkptr = istkptr + 1;						/* and increment pointer						*/
}
	
static	fixed	ipop()							/* remove from insert file stack				*/
{
	istkptr = istkptr - 1;						/* decrement pointer							*/
	return (istk [istkptr]);					/* get it										*/
}
	
static	fixed	pstk[pstacklen + 1];			/* procedure stack								*/
static	fixed	pstkptr;						/* pointer to same								*/

static	void	ppush(							/* save on procedure stack (must be used in OPTIMIZE because normal stack is used for jumps)	*/
	fixed	word)
{
	if (_IGT_(pstkptr, pstacklen)) er_sys ((char *) "stack overflow", (char *) "ppush");
	pstk [pstkptr] = word;						/* save it										*/
	pstkptr = pstkptr + 1;						/* and increment pointer						*/
}
	
static	fixed	ppop()							/* remove from procedure stack					*/
{
	pstkptr = pstkptr - 1;						/* decrement pointer							*/
	return (pstk [pstkptr]);					/* get it										*/
}
	
/* $$Skiprecord:
.
.   The SKIPRECORD procedure is used to skip information from the
.   intermediate file.  The compiler skips such information when it
.   determines that certain sections of a program will never be executed.
.   This happens, for example, when a procedure is never called or
.   during certain if/then/else and do loop processing. */

static	void	skiprecord(						/* pass type of record							*/
	fixed	typ)
{
    fixed			_upper0;
	static	fixed	len;
	
	if ((typ & literal_mask) != 0) return;		/* skip literal word							*/
		
	len = et_length [typ];						/* get length to skip							*/
	
	if (len == -1) len = (readif() & 0x00FF);	/* if variable length, READ the length			*/
		
	for (_upper0 = len, len = 1; len <= _upper0; len++) {	/* skip over record								*/
		readif();
	}
}
	
/* Routine EMITT:
.  
.  This routine is passed a number.  If that number can be expressed in
.  the immediate field of one instruction, a true value (1) is returned.
.
.  EMITT is used to determine which jump instructions can be performed in
.  one instruction and which jump instructions will require two instructions. */

static	fixed	emitt(
	fixed	n)
	
{
	if ((n & (fixed) 0xFFE0) == (fixed) 0xFFE0) return (1);
	if ((n & (fixed) 0xFFE0) == (fixed) 0x0000) return (1);
		
	return (0);
}
	
/* $$The following routines are used to emit code to save index registers
.   within a procedure.
.
.   These procedures determine the number of registers that must be saved
.   during a procedure call (NUMBITS),  emit instructions to save
.   registers on the stack (SAVEREGS),  and emit instructions to load the
.   registers from the stack (LOADREGS). */

static	fixed	numbits(						/* see how many bits set in val					*/
	fixed	val)
{
	static	fixed	i, j;
	
	i = 1;
	j = 0;
	
	while (val >= i) {							/* while any bits set							*/
		if ((val & i) != 0) j = j + 1;
		i = shl(i, 1);
	}
		
	return (j);
}
	
static	void	xmit(							/* shorthand									*/
	fixed	sou,
	fixed	des)
	
{
	writeobj (shl(des, 8) | sou);
}
	
static	void	saveregs(						/* emit in line code to save registers			*/
	fixed	bits)
{
	static	fixed	i, j;
	
	if (prctyp < 2) xmit (b_rs + b_ibt + 0x000D, b_rd + 0x000A);	/* r15i to r12									*/
		
	i = 1; j = 0;
	while (bits >= i) {
		if ((bits & i) != 0) {					/* need to save this register					*/
			if (prctyp < 2)						/* models A & B									*/
				xmit (b_rs + j, b_md + b_ibt + 0x000D);	/* r to mr15i									*/
			else xmit (b_rs + j, b_md + b_ibt + 0x000A);	/* r to mr12d on model C						*/
		}
			
		i = shl(i, 1); j = j + 1;
	}
		
	if (prctyp < 2) xmit (b_rs + 0x000A, b_md + 0x000D);	/* r12 to mr15 save back pointer				*/
}
	
static	void	loadregs(						/* emit code to load registers					*/
	fixed	bits)
{
	static	fixed	i, j;
	
	if (prctyp < 2) {							/* models A and B								*/
		xmit (b_ms + 0x000D, b_rd + 0x000A);	/* mr15 to r12									*/
		xmit (b_rs + b_ibt + 0x000A, b_ca + b_tnv);	/* incre r12 (r12i to atnv)						*/
		
		i = 1; j = 0;
		while (bits >= i) {
			if ((bits & i) != 0) xmit (b_ms + b_ibt + 0x000A, b_rd + j);	/* mr12i to r									*/
			i = shl(i, 1); j = j + 1;
		}
			
		xmit (b_ms + 0x000D, b_rd + 0x000D);	/* mr15 to r15 - back up pointer				*/
	}
	else {										/* Model C & later - load in reverse order		*/
		i = (fixed) 0x8000; j = 15;
		
		while (i != 0) {						/* stop when all registers have been loaded		*/
			if ((bits & i) != 0) xmit (b_ms + b_ibt + 0x000A, b_rd + j);	/* mr12i to rX									*/
			i = shr(i, 1); j = j - 1;
		}
	}
}
	
/* $$Pass3 of the compiler will detect any procedures that are never
.   called.  The object code for these procedures are deleted from
.   object file,  and the storage for variables defined in the
.   procedures is deallocated.
.
.   The following procedures manipulate the ram and scon area pointers for
.   deleted procedures. */

static	void	delram(							/* procedure used to delete a block of ram		*/
	fixed	loc,
	fixed	len)
{
	static	fixed	p;
	
	if (len == 0) return;						/* ignore zero-length blocks					*/
		
	p = 0;										/* start at the beginning of the list			*/
	while ((p < ramptr) && (_ILT_(oldram [p], loc))) {	/* find where to insert this block				*/
		p = p + 1;
	}
		
	if ((p != ramptr) && (oldram [p] == loc)) {	/* join up with existing block					*/
		oldram [p] = loc + len;					/* point one past the end of the block			*/
		deltaram [p] = deltaram [p] + len;		/* update length								*/
	}
	else if (ramptr <= divmax) {				/* insert new block								*/
		blockmove (_location_(&(oldram [p])), _location_(&(oldram [p + 1])), ramptr - p);	/* make room									*/
		blockmove (_location_(&(deltaram [p])), _location_(&(deltaram [p + 1])), ramptr - p);
		oldram [p] = loc + len;					/* point one past end of block					*/
		deltaram [p] = len;						/* save length									*/
		ramptr = ramptr + 1;					/* there's now one more entry					*/
	}											/* of inserting new block						*/
	else er_ftl ((char *) "Program too complex for compilation (deleted ram too fragmented)");
}
	
static	void	delscon(						/* procedure used to delete a block of scon		*/
	fixed	loc,
	fixed	len)
{
	static	fixed	p;
	
	if (len == 0) return;						/* ignore zero-length blocks					*/
		
	p = 0;										/* start at the beginning of the list			*/
	while ((p < sconptr) && (_ILT_(oldscon [p], loc))) {	/* find where to insert this block				*/
		p = p + 1;
	}
		
	if ((p != sconptr) && (oldscon [p] == loc)) {	/* join up with existing block					*/
		oldscon [p] = loc + len;				/* point one past the end of the block			*/
		deltascon [p] = deltascon [p] + len;	/* update length								*/
	}
	else if (sconptr <= divmax) {				/* insert new block								*/
		blockmove (_location_(&(oldscon [p])), _location_(&(oldscon [p + 1])), sconptr - p);	/* make room									*/
		blockmove (_location_(&(deltascon [p])), _location_(&(deltascon [p + 1])), sconptr - p);
		oldscon [p] = loc + len;				/* point one past end of block					*/
		deltascon [p] = len;					/* save length									*/
		sconptr = sconptr + 1;					/* there's now one more entry					*/
	}											/* of inserting new block						*/
	else er_ftl ((char *) "Program too complex for compilation (deleted scon too fragmented)");
}
	
static	fixed	_adjram(						/* system procedure used to adjust ram location for tossed p	*/
	fixed	loc,
	fixed	err)
{
	static	fixed	i, j;
	
	j = loc;									/* start here									*/
	i = 0;
	
	while ((i < ramptr) && (_IGE_(loc, oldram [i]))) {
		j = j - deltaram [i];					/* reduce										*/
		i = i + 1;
	}
		
	if (err & 1 && (i < ramptr) && (_ILT_(loc, oldram [i])) && (_IGE_(loc, oldram [i] - deltaram [i])))
		er_sys ((char *) "attempting to map deleted ram", (char *) "adjram");
		
	return (j);
}
	
static	fixed	adjram(							/* user procedure used to adjust ram location for tossed p	*/
	fixed	loc)
	
{
	return (_adjram (loc, 1));
}
	
static	fixed	adj_ram(						/* user procedure used to adjust ram location for tossed p (no error checking)	*/
	fixed	loc)
	
{
	return (_adjram (loc, 0));
}
	
static	fixed	_adjscon(						/* system procedure used to adjust scon location for tossed p	*/
	fixed	loc,
	fixed	err)
{
	static	fixed	i, j;
	
	j = loc;									/* start here									*/
	i = 0;
	
	while ((i < sconptr) && (_IGE_(loc, oldscon [i]))) {
		j = j - deltascon [i];					/* reduce										*/
		i = i + 1;
	}
		
	if (err & 1 && (i < sconptr) && (_ILT_(loc, oldscon [i])) && (_IGE_(loc, oldscon [i] - deltascon [i])))
		er_sys ((char *) "attempting to map deleted scon", (char *) "adjscon");
		
	return (j);
}
	
static	fixed	adjscon(						/* user procedure used to adjust scon location for tossed p	*/
	fixed	loc)
	
{
	return (_adjscon (loc, 1));
}
	
static	fixed	adj_scon(						/* user procedure used to adjust scon location for tossed p (no error checking)	*/
	fixed	loc)
	
{
	return (_adjscon (loc, 0));
}
/* The following routines handle entering a recursive procedure.  ENTRY_LEN
.   returns the length of code emitted by pass3 to enter a given recursive
.   procedure.  ENTER.PROC emits said code. */

static	fixed	entry_len(						/* determine length of recursive proc's entry code	*/
	fixed	parms, 								/* number of parameters passed to a recursive proc	*/
	fixed	stack_len, 							/* length of proc's stack frame					*/
	fixed	flags)								/* procedure attributes							*/
{
	static	fixed	len;						/* length of entry code							*/
	
	if (stack_len == 0)							/* any variables stacked?						*/
		len = 0;								/* no, we don't need any code to enter			*/
	else {										/* yes, we need some code						*/
		len = 2;								/* at least this much code is generated (to save back pointer)	*/
		
		if (prctyp < 2) {						/* models A & B									*/
			if ((flags & p_recursive) != 0) {	/* if recursive procedure						*/
				len = len + parms;				/* need to stack parameters						*/
				if (parms > 4) len = len + 2;	/* add two words for variable pointer for parms past 4	*/
			}									/* of recursive procedure						*/
				
			stack_len = stack_len - parms;		/* determine remaining space on stack			*/
		}										/* end of models A & B							*/
		else {									/* model C										*/
			if ((flags & p_recursive) != 0) {	/* if recursive proc, stack parms				*/
				if (parms > 4) {				/* if not all register parameters				*/
					len = len + (4 + 5);		/* at least this many more words (accumulators/extra parm copy code)	*/
					stack_len = stack_len - 4;	/* zero out extra non-register parameters also	*/
					
					if (parms > 5) len = len + 1;						/* need one more for repeat over parms			*/
				}
				else {							/* all register parameters						*/
					len = len + parms;			/* at least PARMS more words					*/
					stack_len = stack_len - parms;	/* don't include register parms					*/
				}
			}									/* of recursive procedure						*/
				
			if (stack_len > 256) len = len + 1;	/* need to save R3								*/
		}										/* of model C									*/
			
		if (stack_len != 0) {					/* add in zeroing stack code					*/
			if (((stack_len <= 4) && (prctyp < 2)) || ((stack_len <= 2) && (prctyp >= 2)))/* should we zero the rest of the stack in-line?	*/
				len = len + stack_len;			/* yes, we use as many words as the stack size	*/
			else {								/* no, we need to generate a loop				*/
				if ((prctyp >= 2) && (stack_len <= 256)) {	/* model C REPEAT?								*/
					len = len + 2;				/* two words for repeat							*/
					if (! (emitt (stack_len - 1) & 1)) len = len + 1;	/* unless it's a large stack					*/
				}
				else {							/* normal loop									*/
					len = len + 4;				/* this is how much code it takes to zero the stack	*/
					if (! (emitt (stack_len) & 1)) len = len + 1;		/* unless it's a large stack					*/
					if (prctyp >= 2) len = len + 3;						/* and unless Model C - this takes three more words	*/
						
					if (((flags & p_recursive) == 0)/* if non-recursive proc, haven't saved parms yet	*/
					&& (/*parms > 3*/1)) len = len + 2;					/* if more than three parms, R3 holds a parm - save it	*/
				}
			}									/* of generating a loop							*/
		}										/* of zeroing stack code						*/
	}											/* of determining code needed					*/
		
	return (len);								/* return length of code						*/
}
	
static	void	enter_proc(						/* emit code to enter a recursive procedure		*/
	fixed	parms, 								/* number of parameters passed on by pass1		*/
	fixed	stack_len, 							/* length of recursive proc's stack				*/
	fixed	flags, 								/* procedure attributes							*/
	fixed	sp)									/* stack pointer (r15 for models A & B, r12 for model C & later)	*/
{
    fixed			_upper0;
	static	fixed	i;
	
	if (stack_len != 0) {						/* if there are variables for the stack, we need to set things up	*/
		if (prctyp < 2) {						/* models A & B									*/
			xmit (b_rs + b_ibt + sp, b_rd + 0x000A);	/* rSPi to r12 [save stack frame start]			*/
			
			if ((flags & p_recursive) != 0) {	/* if recursive proc, stack parms				*/
				if (parms > 4) i = 4; else i = parms;	/* determine number of parms in regs			*/
					
				for (_upper0 = i - 1, i = 0; i <= _upper0; i++) {	/* stack the first four passed parameters		*/
					readif();					/* ignore garbage from pass1					*/
					xmit (b_rs + i, b_md + b_ibt + sp);	/* rX to mrSPi [stack the next register]		*/
				}
					
				if (parms > 4) {				/* any remaining parms must be moved from canonical location to the stack	*/
					xmit (b_ms + b_ibt + b_pc, b_rd + 0x0003);	/* pci to r3 [get a variable pointer]			*/
					writeobj ((adjram (readif())) + vstrt - 1);	/* data canonical [pointer to canonical location]	*/
					xmit (b_ms + b_ibt + 0x0003, b_md + b_ibt + sp);	/* mr3i to mrSPi [stack this parm]				*/
					for (_upper0 = parms - 4, i = 2; i <= _upper0; i++) {	/* stack the remaining args						*/
						readif();										/* Assume variables are in consecutive locations	*/
						xmit (b_ms + b_ibt + 0x0003, b_md + b_ibt + sp);	/* mr3i to mrSPi [stack this parm]				*/
					}
				}								/* of moving any remaining parms				*/
					
				stack_len = stack_len - parms;	/* determine remaining stack length (parameters take one word each!)	*/
			}									/* of recursive procedure						*/
		}										/* of models A & B								*/
		else {									/* model C										*/
			xmit (b_rs + sp, b_rd + 0x000D);	/* rSP to r15 [save stack frame start - Model C]	*/
			
			if ((flags & p_recursive) != 0) {	/* if recursive proc, stack parms				*/
				if (parms > 4)					/* if not all register parameters				*/
					stack_len = stack_len - 4;	/* zero out extra non-register parameters also	*/
				else stack_len = stack_len - parms;	/* don't include register parms					*/
			}									/* of recursive procedure						*/
				
			if (stack_len > 256)				/* if stack is larger than repeat can handle	*/
				xmit (b_rs + 0x0003, b_rd + 0x0009);	/* preserve R3									*/
		}										/* of model C									*/
			
		if (stack_len != 0) {					/* if there is any stack space left				*/
			if (((stack_len <= 4) && (prctyp < 2)) || ((stack_len <= 2) && (prctyp >= 2)))/* don't create the loop if we can do it in-line in fewer words	*/
			    for (i = 1; i <= stack_len; i++) {	/* create remaining stack length in-line		*/
				    xmit (b_is + 0, b_md + b_ibt + sp);	/* im(0) to mrSPi [fill the stack with zeros]	*/
			}									/* of creating remaining stack in-line			*/
			else {								/* need to generate a loop						*/
				if ((prctyp >= 2) && (stack_len <= 256)) {	/* on Model C, see if we can use simple REPEAT (stack_len <> 0 here!)	*/
					if (emitt (stack_len - 1) & 1)/* will it fit in an intermediate field?		*/
						xmit (b_is + ((stack_len - 1) & b_imsk), 0x0008);	/* im(stack_len - 1) to d10 [load repeat counter]	*/
					else {												/* need to do a long immediate					*/
						xmit (b_ms + b_ibt + b_pc, 0x0008);				/* pci to d10 [load repeat counter]				*/
						writeobj (stack_len - 1);						/* data stack_len - 1							*/
					}
					xmit (b_is + 0, b_md + b_ibt + 0x000A);	/* im(0) to mr12d [fill the stack with zeros]	*/
				}								/* of using simple REPEAT						*/
				else {							/* can't use Model C simple REPEAT - generate normal loop	*/
					if (((flags & p_recursive) == 0)/* if non-recursive proc, haven't saved parms yet	*/
					&& (/*parms > 3*/1))		/* if more than three parms, R3 holds a parm	*/
						xmit (b_rs + 0x0003, b_rd + 0x0009);			/* r3 to r11 [preserve R3]						*/
						
					if (emitt (stack_len) & 1)	/* will it fit in an intermediate field?		*/
						xmit (b_is + (stack_len & b_imsk), b_rd + 0x0003);	/* im(stack_len) to r3 [get stack length]		*/
					else {												/* need to do a long immediate					*/
						xmit (b_ms + b_ibt + b_pc, b_rd + 0x0003);		/* pci to r3 [get the stack length]				*/
						writeobj (stack_len);							/* data stack_len								*/
					}
					if (prctyp < 2) {									/* normal Model A & B loop						*/
						xmit (b_is + 0, b_md + b_ibt + sp);				/* im(0) to mrSPi [fill the stack with zeros]	*/
						xmit (b_is + 1, b_ad + b_sub + 0x0003);			/* im(1) to sub3 [decrement count]				*/
						xmit (b_is + (-3 & b_imsk), b_cr + b_tnz);		/* im(-3) to rtnz [loop until we're done]		*/
					}													/* of Model A & B loop							*/
					else {												/* normal Model C & later loop					*/
						xmit (b_is + 1, b_ad + b_sub + 0x0003);			/* im(1) to sub3 [subtract one from remaining count	*/
						xmit (b_rs + 0x0003, 0x0008);					/* r3 to d10 [repeat up ((R3 + 1) mod 256) times]	*/
						xmit (b_is + 0, b_md + b_ibt + sp);				/* im(0) to mrSPd [fill the stack with zeros]	*/
						xmit (b_ms + b_ibt + b_pc, b_ad + b_and + 0x0003);	/* pci to and3 [mask off amount already repeated]	*/
						writeobj (~ 0x00FF);							/* data ^377									*/
						xmit (b_is + (-6 & b_imsk), b_cr + b_tnz);		/* im(-6) to rtnz [loop back if not done yet]	*/
					}													/* of Model C & later loop						*/
						
					if (((flags & p_recursive) == 0)/* if non-recursive proc, haven't saved parms yet	*/
					&& (/*parms > 3*/1))		/* if more than three parms, R3 holds a parm	*/
						xmit (b_rs + 0x0009, b_rd + 0x0003);			/* r11 to r3 [restore R3]						*/
				}								/* of normal loop								*/
			}									/* of generating a loop							*/
		}										/* of save the appropriate space on the stack	*/
			
		if (prctyp < 2)							/* models A & B									*/
			xmit (b_rs + 0x000A, b_md + sp);	/* r12 to mrSP [save the stack base]			*/
		else {									/* model C										*/
			if ((flags & p_recursive) != 0) {	/* if recursive proc, stack parms				*/
				if (parms > 4) i = 4; else i = parms;	/* determine number of parms in regs			*/
					
				for (i = i - 1; i >= 0; i--) {	/* stack register parameters (in reverse)		*/
					readif();					/* skip address									*/
					if ((i == 3) && (stack_len > 256))/* if R3 is really in R11						*/
						xmit (b_rs + 0x0009, b_md + b_ibt + sp);		/* r11 to mrSPi [stack R3]						*/
					else xmit (b_rs + i,    b_md + b_ibt + sp);			/* rX  to mrSPi [stack the next register]		*/
				}								/* of stacking register parameters				*/
					
				if (parms > 4) {				/* if non-register parameters - copy them into stack	*/
					xmit (b_rs + sp, b_rd + 0x0003);	/* rSP to r3 [move stack pointer to R3]			*/
					xmit (b_is + 5, b_ad + b_add + 0x0003);	/* im(5) to add3 [point to fifth parameter]		*/
					xmit (b_ms + b_ibt + b_pc, b_rd + 0x0009);	/* pci to r11 [get a variable pointer]			*/
					writeobj (adjram (readif()) + vstrt - 1);	/* data canonical [pointer to canonical location]	*/
					
					i = parms - 4 - 1;			/* get number of parameters remaining (base zero)	*/
					
					if (i != 0)					/* if more than one								*/
						xmit (b_is + i, 0x0008);						/* im(i) to D10 [repeat]						*/
						
					xmit (b_ms + b_ibt + 0x0009, b_md + b_ibt + 0x0003);	/* mr11i to mr3i [copy this parm to stack]		*/
					
					for (_upper0 = i, i = 1; i <= _upper0; i++) {	/* skip over rest of IF record					*/
						readif();										/* Assume variables are in consecutive locations	*/
					}
				}								/* of non-register parms						*/
			}									/* of recursive procedure						*/
				
			xmit (b_rs + 0x000D, b_md + b_ibt + sp);	/* r15 to mrSPd [save stack frame base]			*/
		}										/* model C										*/
	}											/* of outputting entry code						*/
}
	
/* The following routines handle exitting a recursive procedure.  EXIT_LEN
.   returns the length of code emitted by pass3 to exit a given recursive
.   procedure.  EXIT.PROC emits said code. */

static	fixed	exit_len(						/* determine length of recursive proc's exit code	*/
	fixed	stack_len)							/* length of recursive proc's stack				*/
{
	static	fixed	len;						/* length of exit code							*/
	
	if (stack_len == 0)							/* any variables stacked?						*/
		len = 0;								/* no, we don't need any code to exit			*/
	else {										/* yes, we need some code						*/
		if (prctyp < 2)							/* models A & B									*/
			len = 1;							/* need one word								*/
		else len = 2;							/* two words on Model C							*/
	}
		
	return (len);								/* return length required						*/
}
	
static	void	exit_proc(						/* emit code to exit a recursive procedure		*/
	fixed	stack_len, 							/* stack length									*/
	fixed	sp)									/* stack pointer (r15 for models A & B, r12 for model C & later)	*/
	
{
	if (stack_len != 0) {						/* clean up only if there's a stack frame		*/
		if (prctyp < 2) xmit (b_ms + sp, b_rd + sp);	/* yes, zap the stack frame (mrSP to rSP)		*/
		else {									/* a little different on Model C and later		*/
			xmit (b_rs + b_ibt + sp, b_ca + b_tnv);	/* increment rSP on Model C & Later (rSPi to atnv)	*/
			xmit (b_ms + sp, b_rd + sp);		/* get rid of stack frame like so on Model C and later [mrSP to rSP]	*/
		}
	}											/* of outputting exit code						*/
		
}

static	void	create_reloc_copy(				/* copy len words from the interfile to the binary	*/
	fixed	len)								/* number of words to copy						*/
	
{
	while (len--)
		writeobj (readif());					/* copy directly								*/
}
	
/* Create a relocatable binary file:
.
.     This procedure will create a relocatable binary file from the
.     intermediate file.  The relocatable binary is basically just
.     the intermediate file with some header information preceding
.     it.  This header information is entirely from the interpass
.     communications area as is evidenced by the code below. */

static	fixed	create_reloc()					/* create a relocatable binary file				*/
{
	static	fixed	i;
	
	iteration = iteration + 1;					/* let the user know where we are				*/
	
	out_file = (FILE *)	open_able_file_for_output(object_file_name, 'RLOC', 'SNCL');
	
	/* copy out the header information for the linker */
	
	creating_reloc = 1;
	
	writeobj (7 + whentablen + configlen);		/* start with length of header					*/
	writeobj (et_revision);						/* start with the IF revision number			*/
	writeobj (r [l_key]);						/* number of keys used							*/
	writeobj (r [l_altkey]);					/* number of alt keys used						*/
	writeobj (ram);								/* amount of ram used							*/
	writeobj (r [l_str_data]);					/* amount of string constants/data				*/
	writeobj (r [l_flags] & keep_flags);		/* we need to know this information				*/
	writeobj (r [l_recurs_parms]);				/* recursive parameter canonical location		*/
	
	for (i = 0; i < whentablen; i++) {			/* copy out interrupt cells						*/
		writeobj (r [l_icell + i]);
	}
		
	for (i = 0; i < configlen; i++) {			/* copy out configuration						*/
		writeobj (r [l_ctab + i]);
	}
		
	i = readif();								/* get first record type						*/
	
	while (i != et_eof) {						/* copy intermediate file as is for linker - stop at eof	*/
		writeobj (i);							/* copy the type over							*/
		
		if ((i & literal_mask) == 0) {			/* already copied literal word					*/
			i = et_length [i];					/* get length to copy (length of record)		*/
			if (i == -1) {						/* if variable length, read and copy length from IF	*/
				i = readif();					/* get length word								*/
				writeobj (i);					/* copy length word								*/
				i = (i & 0x00FF);				/* extract length portion						*/
			}									/* of variable length record					*/
			create_reloc_copy (i);				/* copy the record over							*/
		}
			
		i = readif();							/* get next type								*/
	}											/* of do while									*/
		
	writeobj (et_eof);							/* output eof									*/
	objforce();									/* force out the object code					*/
	
	if ((r [l_flags] & dump_flag) != 0) {		/* dump stats if they're interested				*/
		print("\n");
		print("%s", "String and data constants: ");unum (r [l_str_data]); print("\n");
		print("%s", "Variable space required:   ");unum (ram - 1); print("\n");
		print("\n");
		print("%s", "Relocatable binary length: ");unum (objlng); print("\n");
		print("\n");
		print("%s", "Symbol table:   [");unum (r [l__st]        ); print("%s", " ]: ");unum (r [l_s_names_len]);
		print("%s", "    Keys used:      [");unum ((fixed) 65535); print("%s", " ]: ");unum (r [l_key]        ); print("\n");
		print("%s", "Stack used:     [");unum (r [l__sk]        ); print("%s", " ]: ");unum (r [l_stack_used] );
		print("%s", "    Alt Keys used:  [");unum ((fixed) 65535); print("%s", " ]: ");unum (r [l_altkey]     ); print("\n");
		print("%s", "First file:     [");unum ((INTER_FILE_WORD_SIZE - INTER_FILE_1_START) / 256); print("%s", " ]: ");unum (r [l_iflng]      );
		print("%s", "    Second file:    [");unum (r [l__if2]    ); print("%s", " ]: ");unum (r [l_if2lng]     ); print("\n");
		print("%s", "Blocks used:    [");unum (r [l__bl]     ); print("%s", " ]: ");unum (r [l_get_blocks] );
		print("\n");
	}
		
	return (objlng);							/* return the actual word length of the file, modulo 64k	*/
}
	
/* Linker routines:
.
.    When a 'LIBRARY' statement is encountered, it is necessary for the
.    compiler to replace the statement by the relocatable binary file
.    specified (much as an 'INSERT' statement is replaced by the specified
.    source file).  These routines effect that replacement.  Nested
.    libraries are not explicitly supported by these routines, but they
.    do work (the pass done by RESOLVE ensures they do).
.
.    The following variables are used by the linker routines only:
*/

#define	main_lib		1						/* library number of MAIN (set in LINK)			*/

static	fixed	undef_ext;						/* number of unresolved references				*/
static	fixed	link_error;						/* non-zero if any errors during the linking process (set by ER.USR)	*/

/* library related variables */

static	fixed	next_lib;						/* pointer to next available library index		*/
static	fixed	next_lib_name;					/* pointer to next available name table entry	*/
static	fixed	current_lib;					/* pointer to the library presently used		*/

static	fixed	lib_name[lib_name_size];		/* text of library names						*/
static	fixed	name_lib[lib_size];				/* pointer to LIB_NAME							*/

static	fixed	b_scon[lib_size + 1];			/* base of string constants						*/
static	fixed	b_ram [lib_size + 1];			/* base of ram area								*/
static	fixed	b_key [lib_size + 1];			/* base of keys used							*/
static	fixed	b_alt [lib_size + 1];			/* base of alt keys used						*/

static	fixed	recurs_parms[lib_size + 1];		/* starting location of canonical recursive parms	*/

/* 'When' handling information structure:
.
.    Each library has a table of labels for 'WHEN' statements.  A table
.    is built up with the label and the number of the library it came
.    from (libraries are assigned unique numbers during the link process).
.    In this way, we will know when to translate the label in RELOCATE.
*/

static	fixed	when_label   [whentablen];		/* label value table							*/
static	fixed	when_library [whentablen];		/* library number table							*/
static	fixed	device_label [devtablen];		/* device driver table							*/
static	fixed	special_label[spectablen];		/* special labels								*/

static	fixed	device_driver(					/* returns TRUE if the passed KEY is they key of a device driver	*/
	fixed	key)								/* key to check									*/
{
	static	fixed	i;
	
	for (i = 0; i < devtablen; i++) {			/* search the device table						*/
		if (device_label [i] == key) return (1);	/* if it's there, it's a driver					*/
	}
		
	return (0);									/* not a device driver							*/
}
	
static	fixed	special_driver(					/* returns TRUE if the passed KEY is they key of a special routine	*/
	fixed	key)								/* key to check									*/
{
	static	fixed	i;
	
	for (i = 0; i < spectablen; i++) {			/* search the special lable table				*/
		if (special_label [i] == key) return (1);	/* if it's there, it's a driver					*/
	}
		
	return (0);									/* not a special procedure						*/
}
	
/* Inform the user of an error on his part. */

static	void	er_usr(							/* tell the user he did something wrong			*/
	char	message[], 							/* the message to print							*/
	char	details[], 							/* any details about the error					*/
	fixed	idetail, 							/* integer details								*/
	fixed	lnum, 								/* line number in library						*/
	fixed	lib, 								/* library number								*/
	fixed	dlib)								/* library it was defined in					*/
	
{
	print("%s", message);
	
	if (details [0] != 0)						/* don't output the null string					*/
		print("%s%s", " ", details);
		
	if (idetail != 0)							/* don't output details of zero					*/
		print("%6d", idetail);
		
	if (lnum != 0)								/* skip for line number of zero					*/
		print("%s%6d", " at line", lnum);		/* output line number							*/
		
	if ((lib != 0) && (lib != main_lib)) {		/* skip for library of zero and skip MAIN		*/
		if (dlib != 0) { print("\n");print("%s", " ");}	/* try to be neat								*/
		print("%s%1p", " in ", _location_(&(lib_name [name_lib [lib]])));
	}
		
	if (dlib != 0)								/* output the defining library if necessary		*/
		print("%s%1p%s", " (defined in ", _location_(&(lib_name [name_lib [dlib]])), ")");
		
	print(".\n");
	
	link_error = -1;							/* abort when we're done						*/
}
	
static	void	er_usra(						/* tell the user he did something wrong			*/
	char	message[], 							/* the message to print							*/
	fixed	details[], 							/* any details about the error					*/
	fixed	idetail, 							/* integer details								*/
	fixed	lnum, 								/* line number in library						*/
	fixed	lib, 								/* library number								*/
	fixed	dlib)								/* library it was defined in					*/
	
{
	print("%s", message);
	
	if (details [0] != 0)						/* don't output the null string					*/
		print("%s%1p", " ", details);
		
	if (idetail != 0)							/* don't output details of zero					*/
		print("%6d", idetail);
		
	if (lnum != 0)								/* skip for line number of zero					*/
		print("%s%6d", " at line", lnum);		/* output line number							*/
		
	if ((lib != 0) && (lib != main_lib)) {		/* skip for library of zero and skip MAIN		*/
		if (dlib != 0) { print("\n");print("%s", " ");}	/* try to be neat								*/
		print("%s%1p", " in ", _location_(&(lib_name [name_lib [lib]])));
	}
		
	if (dlib != 0)								/* output the defining library if necessary		*/
		print("%s%1p%s", " (defined in ", _location_(&(lib_name [name_lib [dlib]])), ")");
		
	print(".\n");
	
	link_error = -1;							/* abort when we're done						*/
}

/* Symbol table routines:
.
.    The symbol table contains the symbol name and information about
.    the symbol (such as its location, whether it was defined, and its
.    type bits).  To locate a symbol, a hash function is performed on
.    the symbol, the result pointing into the vector HASHTAB.  The value
.    in HASHTAB points to corresponding vectors which contain:  a pointer
.    to the next symbol from the hash bucket (NXT_SYM), the location in
.    memory where the symbol will be (LOC_SYM), flags specifying the
.    definition and use of a symbol (PUBEXT_SYM), and a pointer to the
.    text of the symbol in STABLE (PTR_SYM).
.
.    STABLE contains both the text of and the type bits for the symbol.
.    If the type bits are zero, the symbol will match anything.  The
.    symbol is in XPL string format (character length in first word,
.    followed by the characters packed two to a word).  The length (in
.    words) of the type bits directly follow the symbol.  This length
.    is followed by the type bits themselves.  This is also the format
.    of NAME which contains the current symbol in use.
.
.    The following variables are used solely by the symbol table routines: */

/* type information (stored after symbol in STABLE) */
#define	ti_len			0						/* length of type info							*/
#define	ti_typ			1						/* type of symbol or returns type for proc		*/
#define	ti_args			2						/* number of arguments (proc only)				*/
#define	ti_atyp			3						/* start of argument type list (proc only)		*/

static	fixed	hashtab[hash_size + 1];
static	fixed	stable_ptr;						/* pointer to the symbol table					*/
static	fixed	source_ptr;						/* pointer to the source reference table		*/
static	fixed	max_symbols;					/* maximum number of symbols allowed			*/
static	fixed	stable_size;					/* allocated size of symbol table				*/
static	fixed	source_size;					/* allocate size of source ref table			*/

static	fixed	nxt_sym_ptr;					/* pointer to next symbol in hash bucket		*/
static	fixed	loc_sym_ptr;					/* location of symbol at runtime				*/
static	fixed	pubext_sym_ptr;					/* definition and usage flags					*/
static	fixed	ptr_sym_ptr;					/* pointer to symbol name in STABLE				*/
static	fixed	type_sym_ptr;					/* type of symbol								*/
static	fixed	deflib_sym_ptr;					/* number of the library the symbol was defined in	*/
static	fixed	lnum_sym_ptr;					/* line number symbol was defined on			*/
static	fixed	store_sym_ptr;					/* storage used by the symbol					*/
static	fixed	loc_args_ptr;					/* location of first argument in procedure argument list (WARNING: assumes the remaining args follow consecutively)	*/
static	fixed	sort_sym_ptr;					/* symbol table pointers for sorting (GENSYM only)	*/
static	fixed	source_sym_ptr;					/* source entry pointer							*/
static	fixed	sym_only_nam_ptr;				/* pointer to name for source only reference	*/
static	fixed	sym_only_ref_ptr;				/* pointer to source ref						*/

static	fixed	nextstable;						/* next free STABLE area						*/
static	fixed	nextsym;						/* next free symbol area						*/

static	fixed	nextsource   = 1;				/* next free location in source ref area		*/
static	fixed	num_sym_only = 0;				/* number of sym-only definitions				*/

static	fixed	name[name_size + 1];			/* current symbol								*/

static	fixed	stable(							/* return contents of STABLE (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(stable_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}

static	fixed*	get_sym(						/* get address of symbol starting at STABLE (PTR) [equiv to ADDR(STABLE (PTR))]	*/
	fixed	ptr)								/* pointer to symbol							*/
{

	_write_60(stable_ptr + shr(ptr, 8));
	_write_61(ptr);
	return (&(ABLE_CONTEXT.d60[ABLE_CONTEXT._able_xmem_addr]));
}
	
static	fixed*	get_typ(						/* get address of type info for symbol starting at STABLE (PTR) [equiv to ADDR(STABLE (PTR + ?))]	*/
	fixed	ptr)								/* pointer to symbol							*/
{
	static	fixed	i;
	
	_write_60(stable_ptr + shr(ptr, 8));
	_write_61(ptr);
	ptr = ptr + shr(_read_62() + 3, 1);			/* point to type info							*/
	
	_write_60(stable_ptr + shr(ptr, 8));
	_write_61(ptr);
	return (&(ABLE_CONTEXT.d60[ABLE_CONTEXT._able_xmem_addr]));
}
	
/*  */

static	fixed	nxt_sym(						/* return contents of NXT_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(nxt_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_nxt_sym(					/* set NXT_SYM (INDEX) to VALUE					*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(nxt_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	loc_sym(						/* return contents of LOC_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(loc_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_loc_sym(					/* set LOC_SYM (INDEX) to VALUE					*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(loc_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	pubext_sym(						/* return contents of PUBEXT_SYM (INDEX)		*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(pubext_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_pubext_sym(					/* set PUBEXT_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(pubext_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
/*  */

static	fixed	ptr_sym(						/* return contents of PTR_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(ptr_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_ptr_sym(					/* set PTR_SYM (INDEX) to VALUE					*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(ptr_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	type_sym(						/* return contents of TYPE_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(type_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_type_sym(					/* set TYPE_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(type_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
/*  */

static	fixed	deflib_sym(						/* return contents of DEFLIB_SYM (INDEX)		*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(deflib_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_deflib_sym(					/* set DEFLIB_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(deflib_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	lnum_sym(						/* return contents of LNUM_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(lnum_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_lnum_sym(					/* set LNUM_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(lnum_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	store_sym(						/* return contents of STORE_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(store_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_store_sym(					/* set STORE_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(store_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
/*  */

static	fixed	loc_args(						/* return contents of LOC_ARGS (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(loc_args_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_loc_args(					/* set LOC_ARGS (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(loc_args_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}
	
static	fixed	sort_sym(						/* return contents of SORT_SYM (INDEX)			*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(sort_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_sort_sym(					/* set SORT_SYM (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(sort_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}

static	fixed	source_ref(						/* return contents of SOURCE_REF (INDEX)		*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(source_sym_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_source_ref(					/* set SOURCE_REF (INDEX) to VALUE				*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(source_sym_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}

static	fixed	sym_only_nam(					/* return contents of SYM_ONLY_NAM (INDEX)		*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(sym_only_nam_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_sym_only_nam(				/* set SYM_ONLY_NAM (INDEX) to VALUE			*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(sym_only_nam_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}

static	fixed	sym_only_ref(					/* return contents of SYM_ONLY_REF (INDEX)		*/
	fixed	index)								/* index into array								*/
	
{
	_write_60(sym_only_ref_ptr + shr(index, 8));
	_write_61(index);
	return (_read_62());
}
	
static	void	set_sym_only_ref(				/* set SYM_ONLY_REF (INDEX) to VALUE			*/
	fixed	index, 								/* index into array								*/
	fixed	value)								/* value to set element to						*/
	
{
	_write_60(sym_only_ref_ptr + shr(index, 8));
	_write_61(index);
	_write_62(value);
}

	
/* Hash and S.lookup: */

static	fixed	hash(							/* hash a string								*/
	array	name)								/* string to hash								*/
	
{
	return ((name [0] + shr(name [1], 2)) & hash_size);	/* return the hashed value						*/
}
	
/* This routine will try to find the symbol stored in 'NAME' in the
.  symbol table (STABLE).  A pointer to the corresponding vectors NXT_SYM,
.  LOC_SYM, etc. is returned if the symbol is found.  Otherwise a minus one
.  is returned. */

static	fixed	s_lookup()						/* returns 0 if not found; else ptr to STABLE	*/
{
	static	fixed	sym_pt;						/* pointer to symbol							*/
	static	fixed	name_pt;					/* pointer to symbol name						*/
	
	sym_pt = hashtab [hash (name)];				/* point into symbol table						*/

	while (sym_pt != -1) {						/* search down linked list						*/
		name_pt = ptr_sym (sym_pt);				/* point to symbol name							*/
		
		if ((stable (name_pt) == name [0])		/* don't STRCMP unless the length matches		*/
		&& (astrcmp (name, _location_(get_sym (name_pt))) == 0))/* if the symbol name matches					*/
			return (sym_pt);					/* found										*/
			
		sym_pt = nxt_sym (sym_pt);				/* point to next								*/
	}
		
	return (-1);								/* not found									*/
}
	
/* S.define and Sym.dump: */

/* This procedure is called to define a new symbol.  It is STRONGLY
.  recommended that S.LOOKUP is called before S.DEFINE (as S.LOOKUP
.  removes trailing nulls). */

static	fixed	s_define()						/* returns pointer to defined symbol			*/
{
	static	fixed	i;
	
	set_pubext_sym (nextsym, 0);				/* we know nothing about this symbol's use or definition yet	*/
	set_loc_sym    (nextsym, 0);				/* nor do we know its location at runtime		*/
	set_loc_args   (nextsym, 0);				/* nor its arguments' locations (if any)		*/
	set_ptr_sym    (nextsym, nextstable);		/* point to STABLE entry						*/
	
	i = shr(name [0] + 1, 1) + 1;				/* get word length of name (inc. len)			*/
	i = i + name [i] + 1;						/* add in length of type bits (inc. len)		*/
	
	if (_IGE_(nextstable, stable_size - i))		/* check for symbol table overflow				*/
		er_ftl ((char *) "Too many public symbols defined (symbol table overflow)");	/* abort										*/
		
	XPLexport (stable_ptr, nextstable, name, i); /* copy into table								*/
		
	nextstable = nextstable + i;				/* it's in there now							*/
	
	/* the symbol is now in STABLE; now put it in HASHTAB */
	
	i = hash (name);							/* hash that symbol								*/
	set_nxt_sym (nextsym, hashtab [i]);			/* point to first bucket entry					*/
	hashtab [i] = nextsym;						/* and make HASHTAB point to this symbol		*/
	
	nextsym = nextsym + 1;						/* point to the next free symbol area			*/
	
	if (_IGE_(nextsym, max_symbols))			/* check for overflow							*/
		er_ftl ((char *) "Too many public symbols defined");	/* abort										*/
		
	return (nextsym - 1);						/* return pointer to this symbol				*/
}
	
static	fixed	source_define(fixed line_no, fixed fname_byte_len, char *the_name)
{
	fixed	i, this_ptr;

	this_ptr = nextsource;						/* current pointer to source ref table			*/
	
	i = shr(fname_byte_len + 1, 1) + 2;			/* length of text, byte length, line no			*/
	
	i = shr(i+15, 4);							/* compute # of 16-word blocks needed			*/
	
	if (_IGE_(nextsource, source_size - i))		/* check for symbol table overflow				*/
		er_ftl ((char *) "Too many public symbols defined (source reference table overflow)");	/* abort										*/

	nextsource = nextsource + i;				/* it's in there now							*/

	_write_60(source_ptr + shr(this_ptr, 4));	/* set memory pointers							*/
	_write_61(shl(this_ptr, 4));

	_write_63(line_no);							/* store line no								*/
	_write_63(fname_byte_len);					/* store name byte length						*/

	for (i = 0; i < fname_byte_len; i+=2)		/* store this source reference					*/
		_write_63((((fixed) (unsigned char) the_name[i]) << 8) | ((fixed) (unsigned char) the_name[i+1]));

	return (this_ptr);							/* return pointer to this source ref			*/
}

static	void	sym_dump()						/* dump the symbol table (used for debugging and diagnostics)	*/
{
	static	fixed	i;
	
	print("\n");
	print("Symbol table:\n");
	print("pubext  loc     argloc  lineno  type    storage  name      symlen\n");
	for (i = 0; i < nextsym; i++) {
		print("%6d%s%6d%s%6d%s%6d%s%6d%s", pubext_sym (i), "  ", loc_sym (i), "  ", loc_args (i), "  ", lnum_sym (i), "  ", type_sym (i), "  ");
		print("%6d%s%1p%s%6d\n", store_sym (i), "   >", _location_(get_sym (ptr_sym (i))), "<  ", stable (ptr_sym (i)));
	}
}
	
static	fixed	add_lib_save_tab(				/* save a word in the names table				*/
	fixed	word)								/* word to save									*/
	
{
	next_lib_name = next_lib_name + 1;			/* point to next available word					*/
	
	if (_IGE_(next_lib_name, lib_name_size))	/* check for overflow							*/
		er_ftl ((char *) "Too many libraries referenced (library table overflow)");	/* abort										*/
		
	lib_name [next_lib_name] = word;			/* save next word								*/
	
	return (next_lib_name);						/* return a pointer to the word just stored		*/
}
	
static	fixed	add_lib_find_lib(				/* return TRUE if library already found			*/
	fixed	lname[])							/* name of library to search for				*/
{
	static	fixed	len;						/* length of the library name					*/
	static	fixed	i, j;
	
    for (i = 1; i <= next_lib; i++) {			/* see if this library already exists			*/
		len = shr(lname [0] + 1, 1);			/* get length of current name					*/
		
		if (i < next_lib)						/* make sure we don't point past the end of NAME_LIB	*/
			j = name_lib [i + 1];				/* end of name is start of next name			*/
		else j = next_lib_name + 1;				/* end of name is ending pointer				*/
			
		if (len == j - name_lib [i] - 1)		/* is the word length the same as one already there?	*/
		{										/* yes, see if they're really the same			*/
			j = 0;
			
			while ((j <= len) && (toupper (lname [j]) == toupper (lib_name [j + name_lib [i]]))) {	/* compare each word							*/
				j = j + 1;
			}
				
			if (j > len)						/* did we find a perfect match?					*/
				return (1);						/* sure did										*/
		}
	}
		
	return (0);									/* no match										*/
}
	
/* Add a library to the library structure (LIB_NAME and NAME_LIB). */

static	void	add_lib(						/* add a library to our list of libraries referenced	*/
	array	lname)								/* filename										*/
{
    fixed			_upper0;
	static	fixed	i;
	
	if (! (add_lib_find_lib (lname) & 1))		/* make sure the library isn't already there	*/
	{											/* it isn't - add it							*/
		next_lib = next_lib + 1;				/* point to next library table entry			*/
		
		if (_IGE_(next_lib, lib_size))			/* check for overflow							*/
			er_ftl ((char *) "Too many libraries referenced");	/* abort										*/
			
		name_lib [next_lib] = add_lib_save_tab (lname [0]);	/* save length and point to name				*/
		
		for (_upper0 = shr(lname [0] + 1, 1), i = 1; i <= _upper0; i++) {	/* save the name								*/
			add_lib_save_tab (lname [i]);
		}
	}
}
static	void	resolve_em_ref(					/* emit external symbol reference record to IF	*/
	fixed	pt,
	fixed	key)
{
	static	fixed	a_loc;						/* symbol table pointer, external key			*/
	
	copyif (et_ref);							/* start with record type						*/
	copyif (pt);								/* emit a pointer to the symbol					*/
	copyif (key);								/* emit the external key used for this symbol	*/
}
	
/* Resolve external references:
.
.    This procedure reads thru a library file (or MAIN) and appends
.    the contents to the interfile.  In the process, it builds up
.    the external names in the symbol table and keeps track of
.    the maximums of ram area, labels, etc.  Five parameters are
.    passed:  LIBDEV (device of library file), LIBSTART (starting
.    sector of library file), LIBLEN (length of library file),
.    MAINFLAG (if set, we are resolving the MAIN program). */

static	void	resolve(						/* collect library data and try to resolve references	*/
	fixed (*readlib )(),						/* pass pointer to read next word routine				*/
	void  (*closelib)(),						/* pass pointer to close input file routine				*/
	fixed	mainflag)							/* true if resolving MAIN								*/
{
    fixed			_upper0;
	static	fixed	t_scon;						/* total scon/data used by this library			*/
	static	fixed	t_key;						/* total keys used by this library				*/
	static	fixed	t_alt;						/* total alt keys used by library				*/
	static	fixed	t_ram;						/* total ram used by this library				*/
	static	fixed	word;						/* present word read from file					*/
	static	fixed	i;
	static	fixed	j;
	
	static	char	model_[] = {"Model A processor"};	/* model number template						*/
	
				
	/* Resolve references (cont.):
	.     Initialize. */

	if (mainflag & 1) {							/* for MAIN										*/
	
		#if __LITTLE_ENDIAN__
			add_lib ((fixed *) "\4" "\0" "MAIN");	/* add in the name of the main program			*/
		#endif
		
		#if __BIG_ENDIAN__
			add_lib ((fixed *) "\0" "\4" "AMNI");	/* add in the name of the main program			*/
		#endif

		t_key  = r [l_key];						/* get total keys								*/
		t_alt  = r [l_altkey];					/* get total alternate keys						*/
		t_ram  = r [l_ram] - 1;					/* get total ram								*/
		t_scon = r [l_str_data];				/* get total string constants/data				*/
		recurs_parms [current_lib] = r [l_recurs_parms];	/* save canonical parms location				*/

		for (i = 0; i < whentablen; i++) {		/* copy over when table							*/
			when_label [i] = r [l_icell + i];	/* label										*/
			when_library [i] = current_lib;		/* and library number							*/
		}
	}											/* of for MAIN									*/
	else {										/* only if library								*/
		word = readlib();						/* get length of library data from library header	*/
		
		if ((i = readlib()) != et_revision) {	/* is this the correct revision IF?				*/
			print("\n");
			print("%s%1p%s", "Library \"", _location_(&(lib_name [name_lib [current_lib]])), "\" incompatible with current compiler.\n");
			printf("info: %d %d %x %x\n", i, et_revision, i, et_revision);
			er_ftl ((char *) "Please recompile it");		/* abort										*/
		}										/* of wrong revision							*/
			
		t_key  = readlib();						/* total keys used in library					*/
		t_alt  = readlib();						/* total alternate keys used					*/
		t_ram  = readlib() - 1;					/* and total ram used							*/
		t_scon = readlib();						/* total string/data area						*/
		
		r [l_flags] = (r [l_flags] | readlib());	/* make sure the proper flags are set			*/
		recurs_parms [current_lib] = readlib();	/* save canonical parms location				*/

		for (_upper0 = (word - 7) - 1, i = 0; i <= _upper0; i++) {	/* skip rest of info							*/
			word = readlib();					/* get next word								*/
			
			if ((i < whentablen) && (word != 0)) {	/* keep track of any when statements			*/
				if (when_label [i] != 0)		/* already one there							*/
					er_usr ((char *) "Duplicate WHEN statement", (char *) "", i, 0, current_lib, when_library [i]);
				else {							/* new when										*/
					when_label [i] = word;		/* save label									*/
					when_library [i] = current_lib;	/* and library number							*/
				}								/* of new when									*/
			}									/* of have a when statement present				*/
			if (i == whentablen + 1) {			/* I = whentablen is start of configuration; + 1 is options word	*/
				/* if previously compiled for ModelC or later & linked   */
				/* in w/Model A or B                                     */
				if (((shr(word, 8) & 0x0007) >= 2) && (prctyp < 2)) {
					model_[6] = (shr(word, 8) & 0x0007) + 0x0041;
					er_usr ((char *) "Configuration mismatch:  Library compiled with", (char *) model_, 0, 0, current_lib, deflib_sym (current_lib));
				}
			}									/* of checking processor type					*/
		}										/* of skip rest of info							*/
	}											/* of only if library							*/
		
	b_scon [current_lib + 1] = b_scon [current_lib] + t_scon;	/* set the bases for next library				*/
	if (_ILT_(b_scon [current_lib + 1], t_scon)) er_usr ((char *)"Too many constants", (char *) "", 0, 0, current_lib, 0);
		
	b_key  [current_lib + 1] = b_key  [current_lib] + t_key;
	if (_ILT_(b_key [current_lib + 1], t_key)) er_usr ((char *)"Too many keys", (char *) "", 0, 0, current_lib, 0);
		
	b_alt  [current_lib + 1] = b_alt  [current_lib] + t_alt;
	if (_ILT_(b_alt [current_lib + 1], t_alt)) er_usr ((char *)"Too many alt keys", (char *) "", 0, 0, current_lib, 0);
		
	b_ram  [current_lib + 1] = b_ram  [current_lib] + t_ram;
	if (_ILT_(b_ram [current_lib + 1], t_ram)) er_usr ((char *)"Too many variables", (char *) "", 0, 0, current_lib, 0);
		
	/* Resolve references (cont.):
	.     Copy the file over, recording library information where appropriate.
	.     Handle a symbol.	*/
	
	word = readlib();							/* read first word from library					*/
	
	while (word != et_eof) {					/* continue til end of this library				*/

		/* now copy over special records,  or records at buffer boundaries	*/
		/* with more care at a leisurely pace:			*/
		
		if ((word & literal_mask) != 0)			/* not a record (just a literal word)			*/
			copyif (word);						/* write out the word							*/
			
		else if (word == et_sym)				/* symbol reference?							*/
		{										/* symbol										*/
			static	fixed	totalread, tlen, bits, wlen, type;
			static	fixed	key, store, lnum, _args, a_loc, pt;
			
			fixed	fname_word_len = 0;
			fixed	fname_byte_len = 0;
			fixed	line_no        = 0;
			char	the_name[256];
			
			totalread = 0;						/* nothing read so far							*/
			_args = 0;							/* no arguments yet								*/
			a_loc = 0;							/* no argument location yet						*/
			
			i = readlib();						/* bits | total len								*/
			tlen = (i & 0x00FF);				/* get total length								*/
			bits = (shr(i, 8) & 0x000F);		/* and bits										*/
			
			i = readlib();						/* type | text length							*/
			wlen = (i & 0x00FF);				/* length in words of text						*/
			type = shr(i, 8);					/* type like T.PROC etc							*/
			
			key   = readlib();					/* pick up location								*/
			store = readlib();					/* storage used									*/
			lnum  = readlib();					/* sequence number								*/
			
			for (i = 1; i <= wlen; i++) {		/* copy over text of symbol						*/
				name [i] = readlib();
			}
				
			name [0] = wlen + wlen;				/* set length of symbol in characters			*/
			if ((name [wlen] & (fixed) 0xFF00) == 0) name [0] = name [0] - 1;	/* set proper character length					*/
				
			totalread = 4 + wlen;				/* count words read								*/
			wlen = wlen + 1;					/* point to type info							*/
			
			if ((bits != t_symonly)				/* if not a refonly situation					*/
			&&  (type == t_proc   )) {			/* procedures have special type fields			*/
				
				run_host_environment_250();		/* give cpu to host... 							*/
				
				key   = readlib();				/* pick up proc's key							*/
				_args = readlib();				/* and number of arguments						*/
				
				name [wlen + ti_len ] = 2 + _args;	/* length of type info							*/
				name [wlen + ti_typ ] = readlib();	/* returns type									*/
				name [wlen + ti_args] = _args;	/* save number of args							*/
				
				for (_upper0 = _args + (ti_atyp - 1), i = ti_atyp; i <= _upper0; i++) {	/* get type/location for each argument			*/
					name [wlen + i] = readlib();	/* get type of argument							*/
					j = readlib();				/* ignore location of argument					*/
					if (i == ti_atyp) a_loc = j;						/* remember location of first argument			*/
				}
					
				totalread = totalread + 3 + _args + _args;
			}									/* special type fields							*/
			
			else {								/* non-procedure record							*/
				name [wlen + ti_len] = 1;		/* only one word of type info					*/
				name [wlen + ti_typ] = type;	/* and this is the type							*/
			}									/* of non-procedure record						*/
			
			if (totalread < tlen)				/* pick up file name/line no. record			*/
			{
				fname_word_len = readlib();
				fname_byte_len = readlib();
				line_no        = readlib();
				
				totalread += 3;
				
				if (fname_byte_len >= 255)		/* limit to avoid sub errors on trashed files 	*/
					fname_byte_len = 255;
					
				for (i = 0; i < fname_byte_len; i += 2)
				{
					j = readlib();
					totalread++;
					
					the_name[i  ] = (char) (shr(j, 8));
					the_name[i+1] = (char) (j & 0xFF);
				}
				
				the_name[fname_byte_len] = 0;	/* in case trailing null wasn't sent */
			}
			
			if (totalread > tlen)				/* system error									*/
				er_sys ((char *) "symbol record longer than expected", (char *) "resolve");	/* abort										*/
				
			/* Resolve references (cont.):
			.     Finish handling a symbol definition/reference.	*/
			
			if (bits == t_symonly)				/* if symref only, emit to source ref table		*/
			{
				if (fname_byte_len)				/* if source ref exists in this record			*/
				{
					fixed where_pt  = num_sym_only++;
					fixed where_ref = source_define(line_no, fname_byte_len, the_name);
					fixed where_nam;
					char  the_sym[256];
					
					if (where_pt >= max_symbols)
						er_ftl ((char *) "Too many source references (symbol-only reference table overflow)");
					
					to_c_string(name, the_sym);

					where_nam = source_define(0, name[0], the_sym);

					set_sym_only_nam(where_pt, where_nam);
					set_sym_only_ref(where_pt, where_ref);
				}
			}
			
			else
			{
				pt = s_lookup();					/* look up symbol in table						*/

				if (pt == -1) {						/* not defined									*/
					pt = s_define();				/* define the symbol							*/
					set_type_sym (pt, type);		/* and the type									*/
					set_pubext_sym (pt, bits);		/* mark as used									*/
					set_deflib_sym (pt, current_lib);	/* set library for error messages				*/
					set_lnum_sym (pt, lnum);		/* remember where it was (for error messages)	*/
					
					if (fname_byte_len)				/* if name specified (e.g. defined here)		*/
						set_source_ref(pt, source_define(line_no, fname_byte_len, the_name));
				
					if (bits == t_public) {			/* definer										*/
						set_store_sym (pt, store);	/* storage used									*/
						set_loc_sym (pt, key);		/* save location/key							*/
						set_loc_args (pt, a_loc);	/* save first argument starting location		*/
					}								/* definer										*/
					else undef_ext = undef_ext + 1;	/* must be T.EXTERN - count number of undefined externals	*/
				}
				else {								/* previously defined							*/
				
					fixed *j = get_typ (ptr_sym (pt));				/* point to type information	*/
					
					i = 0;
					while ((i <= j[0]) && (j[i] == name [wlen + i])) {	/* check type info								*/
						i = i + 1;
					}								/* of check type info							*/
					if (i <= j[0]) er_usra ((char *) "Types don\'t match:", name, 0, lnum, current_lib, deflib_sym (pt));
						
					if (fname_byte_len)				/* if name specified (e.g. defined here)		*/
						set_source_ref(pt, source_define(line_no, fname_byte_len, the_name));
				
					if (bits == t_public) {			/* check for definer							*/
						if ((pubext_sym (pt) & 0x000F) == t_public)	/* two definers									*/
							er_usra ((char *) "Duplicate definition:", name, 0, lnum, current_lib, deflib_sym (pt));
						else {												/* not already defined							*/
							set_deflib_sym (pt, current_lib);				/* point to the defining library				*/
							set_lnum_sym (pt, lnum);						/* remember what line it was on					*/
							set_store_sym (pt, store);						/* and the storage used							*/
							set_pubext_sym (pt, t_public);					/* now it's defined (this is BITS)				*/
							set_loc_sym (pt, key);							/* save location/key							*/
							set_loc_args (pt, a_loc);						/* save first argument starting location		*/
							
							undef_ext = undef_ext - 1;						/* we've found the definition					*/
							
							if (undef_ext < 0)								/* system error									*/
								er_sys ((char *) "negative number of undefined externals", (char *) "resolve");	/* abort										*/
						}													/* of not already defined						*/
					}							/* check for definer							*/
				}								/* previously defined							*/
					
				if (bits == t_extern)			/* if an external reference						*/
					resolve_em_ref (pt, key);	/* emit external symbol reference				*/
			}
		}										/* of symbol									*/
			
		/* Resolve references (cont.):
		.     Handle libraries and all types which can be ignored.	*/
		
		else if (word == et_mod) {				/* module										*/
			for (_upper0 = readlib(), i = 1; i <= _upper0; i++) {	/* skip record for now							*/
				readlib();
			}
		}										/* module										*/
			
		else if (word == et_lib) {				/* library										*/
			i = readlib();						/* get length of whole block					*/
			readlib();							/* skip line number library was defined on		*/
			
			for (_upper0 = (i - 1) - 1, i = 0; i <= _upper0; i++) {	/* copy over text								*/
				j = readlib();					/* get text										*/
				
				if (i <= name_size)				/* save name if not too big						*/
					name [i] = j;
			}
				
			if (name [0] > shl(name_size, 1))	/* limit size of name							*/
				name [0] = shl(name_size, 1);	/* to max size of name							*/
				
			add_lib (name);						/* save this library name						*/
		}										/* library										*/
			
		else if ((word == et_ldf) && mainflag & 1) {	/* library definition for MAIN?					*/
			copyif (word);						/* copy record type								*/
			readlib();							/* ignore library number passed by pass2		*/
			copyif (current_lib);				/* replace with current library number			*/
		}										/* of library definition for MAIN				*/
			
		else if (word == et_eof) {
			/* nothing - copied below */
		}
			
		else {									/* copy other records							*/
			copyif (word);						/* copy the record type to the IF				*/
			
			j = et_length [word];				/* get record length							*/
			
			if (j == -1) {						/* variable length record						*/
				j = readlib();					/* pick up length								*/
				copyif (j);						/* copy it to the IF							*/
				j = (j & 0x00FF);				/* keep just the length							*/
			}
				
   			for (i = 1; i <= j; i++) {			/* copy the record over							*/
				copyif (readlib());
			}
		}										/* handle a record								*/ 
			
		if (word != et_eof)						/* if we are not sitting at the eof				*/
			word = readlib();					/* then get next word							*/
			
	}											/* while more									*/
		
	copyif (et_eof);							/* and copy the end-of-file over				*/

	closelib();
}

static	fixed	relocate_adjust(				/* relocate a pointer							*/
	fixed	offset, 							/* the offset within the library				*/
	fixed	base[], 							/* the appropriate base array					*/
	fixed	current_lib, 
	fixed	loc_ref[])
{
	static	fixed	reloc;						/* the relocated pointer						*/

	if (_IGE_(offset, extern_base))				/* is this an external reference?				*/
	{											/* yes, relocate to the appropriate public area	*/
		if (_IGE_(offset - extern_base, max_refs))/* too many external references?				*/
			er_sys ((char *) "too many external references", (char *) "relocate:adjust");	/* abort										*/

		reloc = loc_ref [offset - extern_base];	/* point to the public							*/
	}
	else reloc = offset + base [current_lib];	/* relocate within this library					*/

	return (reloc);								/* return the relocated pointer					*/
}
	
/* Relocate variables, constants, and keys:
.
.   This phase reads through the file with all the libraries and
.   relocates the scon, key and ram areas. */

static	void	relocate(
	fixed	current_lib, 						/* the library to relocate						*/
	fixed	loc_ref[])							/* place to store locations of external references	*/
{
    fixed			_upper0;
	static	fixed	key;						/* current key									*/
	static	fixed	pt;							/* pointer into STABLE for symbol				*/
	static	fixed	i;
	
	static	char	ptl[] = {"Program too large for compilation (too many external references)"};
	
	/* Relocate pointers:
	.
	.   Read over the whole library and relocate the pointers. */
	
	/* relocate any when statements defined in this library */
	
	for (i = 0; i < whentablen; i++) {
		if ((when_library [i] == current_lib) && (when_label [i] != 0))/* if this is the defining library				*/
			when_label [i] = when_label [i] + b_key [current_lib];	/* add in the base								*/
	}
		
	/* force recursive parameters into LOC_REF */
	
	if (_IGE_(recurs_parms [current_lib], extern_base)) {	/* if canonicals are external (i.e., in a module)	*/
		key = recurs_parms [current_lib] - extern_base;	/* normalize first one							*/
		
		for (i = 0; i < max_recurs_parms; i++) {	/* enter into LOC_REF							*/
			if (_IGE_(key, max_refs))			/* too many external references?				*/
				er_ftl (ptl);					/* abort										*/
				
			loc_ref [key] = r [l_recurs_parms] + i;	/* set location of parm (WARNING: assumes allocated consecutively)	*/
			key = key + 1;						/* get next external loc (WARNING: assumes allocated consecutively)	*/
		}										/* of entering into LOC_REF						*/
	}											/* of canonicals are external					*/
		
	key = readif();								/* get first word from interfile				*/
	
	while (key != et_eof) {						/* read till the end							*/
		if ((key & literal_mask) == 0)			/* no need to relocate literals					*/
		switch (key - 1) {						/* handle records								*/
			case 0:
			{									/* literal										*/
				skiprecord (key);				/* no relocation								*/
				break;
			}									/* literal										*/
				
			case 1:
			{									/* transfer										*/
				readif();						/* don't care about condition					*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate key									*/
				readif();						/* skip over estimated key location				*/
				break;
			}									/* transfer										*/
				
			case 2:
			{									/* procedure call								*/
				key = readif();					/* get length to skip							*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate key									*/
				
				i = 1;
				while (i < key) {				/* adjust any formal parameter keys if necessary	*/
					if (readif() < 0) {									/* if a key follows								*/
						writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate it									*/
						i = i + 1;										/* we read another word							*/
					}
					i = i + 1;					/* read a word									*/
				}								/* of adjust any formal parm keys				*/
				break;
			}									/* call											*/
				
			case 3:
			{									/* rtp call										*/
				skiprecord (key);				/* pass3 relocates rtp							*/
				break;
			}									/* rtp call										*/
				
			case 4:
			{									/* variable ptr									*/
				readif();						/* skip destination								*/
				
				switch (readif()) {				/* branch on storage class						*/
					case 0:
						writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate ram ptr (statics)					*/
						break;
					case 1:
						readif();										/* skip automatics								*/
						break;
				}
				break;
			}									/* variable ptr									*/
				
			case 5:
			{									/* object ptr									*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate pointer key							*/
				break;
			}									/* object ptr									*/
				
			case 6:
			{									/* label def									*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate key for label						*/
				break;
			}									/* label def									*/
				
			/* Relocate pointers (continued):				*/
			
			case 7:
			{									/* data definition								*/
				skiprecord (key);				/* nothing to relocate							*/
				break;
			}									/* data definition								*/
				
			case 8:
			{									/* copy data									*/
				skiprecord (key);				/* pass3 relocates data							*/
				break;
			}									/* copy data									*/
				
			case 9:
			{									/* copy scon									*/
				key = readif();					/* get length to skip							*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate KEY of proc it's passed to (NOTE: this will relocate 0's)	*/
				for (i = 1; i < key; i++) {readif(); }	/* skip the rest of the record					*/
				break;
			}									/* copy scon									*/
				
			case 10:
			{									/* ignore										*/
				skiprecord (key);				/* ignore it									*/
				break;
			}									/* ignore										*/
				
			case 11:
			{									/* procedure def								*/
				run_host_environment_250();
				
				key = (readif()&255);			/* get length of procedure record				*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate procedure label						*/
				writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate ram base							*/
				writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate temp base (meaningless for recursives)	*/
				
				push (readif());				/* push procedure attributes onto stack for proc end	*/
				
				for (_upper0 = key - 4, i = 1; i <= _upper0; i++) {	/* relocate parameter locations					*/
					writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate parameter location					*/
				}
				break;
			}									/* procedure def								*/
				
			case 12:
			{									/* procedure end								*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate proc's key							*/
				writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate ending ram location					*/
				
				if ((pop() & p_recursive) == 0)	/* if not in a recursive proc					*/
					writeif (relocate_adjust (readif(), b_ram, current_lib, loc_ref));	/* relocate ending temp location				*/
				else readif();					/* don't relocate temps offset					*/
					
				readif(); readif(); readif();	/* ignore stack len, regs used, data NOSWAP bit list	*/
				break;
			}									/* procedure end								*/
				
			case 13:
			{									/* when statement								*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate key									*/
				break;
			}									/* when def										*/
				
			case 14:
			{									/* end when										*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate key									*/
				readif();						/* ignore bits word								*/
				break;
			}									/* end when										*/
				
			case 15:
			{									/* string constant ptr							*/
				readif();						/* destination									*/
				writeif (relocate_adjust (readif(), b_scon, current_lib, loc_ref));	/* relocate pointer								*/
				readif();						/* swaps										*/
				break;
			}									/* string constant ptr							*/
				
			case 16:
			{									/* addr of fixed array parameter				*/
				writeif (relocate_adjust (readif(), b_key, current_lib, loc_ref));	/* relocate proc key							*/
				readif();						/* skip parm number								*/
				break;
			}									/* addr of fixed array parameter				*/
				
			case 17:
			{									/* sequence number								*/
				skiprecord (key);				/* skip it										*/
				break;
			}									/* sequence number								*/
				
			/* Relocate pointers (cont.):					*/
			
			case 18:
			{									/* symbol										*/
				skiprecord (key);				/* skip over symbols (better not occur!)		*/
				break;
			}									/* symbol										*/
				
			case 19:
			{									/* module										*/
				skiprecord (key);				/* skip over modules							*/
				break;
			}									/* module										*/
				
			case 20:
			{									/* library										*/
				skiprecord (key);				/* skip over libraries							*/
				break;
			}									/* library										*/
				
			case 21:
			{									/* insert file									*/
				skiprecord (key);				/* skip it										*/
				break;
			}									/* insert file									*/
				
			case 22:
			{									/* library definition							*/
				skiprecord (key);				/* skip the definition							*/
				break;
			}									/* library definition							*/
				
			case 23:
			{									/* external symbol reference					*/
				fixed *where;
				
				pt = readif();					/* pick up symbol pointer						*/
				key = readif();					/* external key of symbol						*/
				
				if (_IGE_(key - extern_base, max_refs))	/* too many external references?				*/
					er_ftl (ptl);				/* abort										*/
					
				loc_ref [key - extern_base] = loc_sym (pt);	/* save its real location (this works because references must come before usage)	*/
				
				where = get_typ (ptr_sym (pt));	/* pick up pointer to type info					*/
				
				if (where[ti_len] >= ti_args)
					i = where[ti_args];
				else							/* pick up number of args from the symbol table	*/
					i = 0;
					
				for (_upper0 = i - 1, i = 0; i <= _upper0; i++) {	/* relocate each argument						*/
					key = key + 1;				/* Warning: assumes pass1 allocates consecutive external keys for arguments (starting after proc key).	*/
					
					if (_IGE_(key - extern_base, max_refs))			/* too many external references?				*/
						er_ftl (ptl);								/* abort										*/
						
					loc_ref [key - extern_base] = loc_args (pt) + i;	/* Warning: assumes pass1 allocates consecutive ram locations for arguments.	*/
				}								/* of relocate each argument					*/
				break;
			}									/* of external symbol reference					*/
				
			case 24:
			{									/* do case record - nothing required			*/
				break;
			}
				
			case 25:
			{									/* transfer to alternate key					*/
				readif();						/* don't care about condition					*/
				writeif (relocate_adjust (readif(), b_alt, current_lib, loc_ref));	/* relocate alternate key						*/
				readif();						/* skip over estimated key location				*/
				break;
			}									/* transfer to alternate key					*/
				
			case 26:
			{									/* label def of alternate key					*/
				writeif (relocate_adjust (readif(), b_alt, current_lib, loc_ref));	/* relocate alt key for label					*/
				break;
			}									/* alt label def								*/
				
		}										/* of handle records							*/
			
		key = readif();							/* get next word from interfile					*/
	}											/* till EOF										*/
		
	writeif (et_ign);							/* ignore EOF next pass							*/
}
	
static	void	link_em_tra(					/* emit a transfer record						*/
	fixed	con,
	fixed	key)								/* condition to transfer on, key to transfer to	*/
	
{
	readif(); writeif (et_tra);					/* write record type							*/
	readif(); writeif (con);					/* write transfer condition						*/
	readif(); writeif (key);					/* write key to transfer to						*/
	readif(); writeif (-1);						/* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE)	*/
}
	
static	void	link_em_ldf(					/* emit library definition to IF				*/
	fixed	lib)								/* the number of the library we're about to append to the IF	*/
	
{
	readif(); writeif (et_ldf);					/* write out the record type					*/
	readif(); writeif (lib);					/* and the library number						*/
}
	
static	void	link_relocate_defns()			/* relocate public definitions					*/
{
	static	fixed	stype;						/* storage type									*/
	static	fixed	i;
	
	static	fixed	storage_type[] = {2,2,2,2,-1, -1,-1,-1,-1,0, -1,0,-1,-1,-1, -1,1,1,-1,-1, -1};	/* storage types table							*/
	
	for (i = 0; i < nextsym; i++) {				/* relocate publics								*/
		stype = storage_type [type_sym (i)];	/* get area to relocate from					*/
		
		if (_IGE_(stype, 3))					/* is the value in range?						*/
			er_sys ((char *) "incorrect storage type", (char *) "relocate_defns");	/* abort										*/
			
		switch (stype) {						/* branch on type								*/
			case 0:
				set_loc_sym (i, loc_sym (i) + b_scon [deflib_sym (i)]);	/* scon											*/
				break;
			case 1:
			{									/* keys											*/
				set_loc_sym (i, loc_sym (i) + b_key [deflib_sym (i)]);	/* keys											*/
				
				if (loc_args (i) != 0) {		/* if external arguments						*/
					if (loc_args (i) != recurs_parms [deflib_sym (i)])/* if not recursive variable defn				*/
						set_loc_args (i, loc_args (i) + b_ram [deflib_sym (i)]);	/* start of args								*/
					else set_loc_args (i, r [l_recurs_parms]);			/* set to start of recursive parms				*/
				}								/* of external arguments						*/
				break;
			}									/* of keys										*/
			case 2:
				set_loc_sym (i, loc_sym (i) + b_ram [deflib_sym (i)]);	/* ram											*/
				break;
		}										/* of branch on type							*/
	}											/* of relocate publics							*/
}


/* Link in any referenced libraries:
.
.     This procedure constitutes the XPL linker.  Any library statements
.     in the main procedure will cause this linker to be invoked.  The
.     function is strictly that of inserting relocatable libraries and
.     assigning locations for any external variables.
.
.     The algorithm runs as follows:
.       a) Examine the main procedure (MAIN) setting up the external symbol table.
.       b) Copy all referenced libraries (in the order they appear) to the IF.
.       c) Try to resolve all external references.
.       d) Create variable space for all publics (i.e., relocate their addresses).
.       e) Relocate all variables to the end of the code segment. */

static	void	link(							/* link in any referenced libraries				*/
	fixed	loc_ref[])							/* place to store external reference locations (RELOCATE only)	*/
{
	static	fixed	i, j;
	
	static	char	ptl[] = {"Program too large for compilation (libraries exceed work file length)"};
	
	/* Link in any referenced libraries (cont.): */
	
	if (show_progress || show_p3_progress)
		printf("XPL Tool: Pass 3: Resolving\n");

	iteration = iteration + 1;					/* initiate next pass through IF				*/
	
	current_lib = 1;							/* start with library number one				*/
	
	resolve (readmain, closemain, 1);			/* resolve MAIN									*/

	current_lib = current_lib + 1;				/* point to first library						*/
	
	while (current_lib <= next_lib) {			/* load all libraries (NEXT_LIB is set by RESOLVE)	*/
		char 	c_name[256] = {""};
		fixed  *a_name = &(lib_name [name_lib [current_lib]]);
		
		for (i=0; i<a_name[0]; i++)				/* copy library name to c format				*/
		{
			c_name[i    ] = byte(a_name, i);
			c_name[i + 1] = 0;
		}
		
		run_host_environment_250();				/* give cpu to host... 							*/

		if (show_progress)
			print("XPL Tool: resolving library: %s\n", c_name);
		
		// Append mandatory file extension
		strcat(c_name, ".srel");
		
		ovr_file = (FILE *) open_able_file(c_name);

		link_em_ldf (current_lib);				/* write the library number to the IF			*/
		
		resolve (readovr, closeovr, 0);			/* append the library file to the IF			*/

		current_lib = current_lib + 1;			/* point to next available library structure space	*/
	}
		
	if (undef_ext > 0) {						/* were all references resolved?				*/
		for (i = 0; i < nextsym; i++) {			/* print out unresolved references				*/
			if (pubext_sym (i) != t_public)		/* is this one defined?							*/
				er_usra ((char *) "Unresolved reference: ", _location_(get_sym (ptr_sym (i))), 0, lnum_sym (i), deflib_sym (i), 0);
		}
	}
		
	r [l_str_data] = b_scon[next_lib + 1];		/* record new lengths							*/
	r [l_key     ] = b_key [next_lib + 1];
	r [l_altkey  ] = b_alt [next_lib + 1];
	r [l_ram     ] = b_ram [next_lib + 1] + 1;	/* add one to account for RAM start at one		*/
	
	current_lib = 1;							/* search all libraries							*/
	while ((r [l_recurs_parms] == 0) && (current_lib <= next_lib)) {	/* check for recursive parms					*/
		if (recurs_parms [current_lib] != 0) {	/* if canonicals for recursive parms not allocated yet	*/
			r [l_recurs_parms] = ram;			/* allocate after variables						*/
			ram = ram + max_recurs_parms;		/* need this many words							*/
		}										/* of allocating canonicals for recursive parms	*/
			
		current_lib = current_lib + 1;			/* check next									*/
	}											/* of check for recursive parms					*/
		
	link_relocate_defns();						/* relocate public definitions					*/
	resetif ();									/* reset to the beginning of the interfile again	*/
	
	if (show_progress || show_p3_progress)
		printf("XPL Tool: Pass 3: Relocating\n");

	iteration = iteration + 1;					/* initiate next pass through IF				*/
	
	for (current_lib = 1; current_lib <= next_lib; current_lib++) {	/* relocate each library						*/
		relocate (current_lib, loc_ref);		/* relocate variables							*/
	}
		
	link_em_tra (b_tra, main_key);				/* transfer to main program						*/
	
	readif(); writeif (et_eof);					/* write out an EOF (this is the REAL end of file)	*/
	
	resetif ();									/* reset and flush the IF						*/
	
	for (i = 0; i < whentablen; i++) {			/* set labels of when statements in interpass comm area	*/
		r [l_icell + i] = when_label [i];
	}
		
	for (i = 0; i < devtablen; i++) {			/* set labels of device driver entry points		*/
		switch (i) {							/* branch on driver we're looking for			*/
			case 0:
				astrcpy (name, (char *) "WIN1READ");
				break;
			case 1:
				astrcpy (name, (char *) "WIN1WRITE");
				break;
			case 2:
				astrcpy (name, (char *) "DEV8READ");
				break;
			case 3:
				astrcpy (name, (char *) "DEV8WRITE");
				break;
			case 4:
				astrcpy (name, (char *) "DEV10READ");
				break;
			case 5:
				astrcpy (name, (char *) "DEV10WRITE");
				break;
			case 6:
				astrcpy (name, (char *) "DEV12READ");
				break;
			case 7:
				astrcpy (name, (char *) "DEV12WRITE");
				break;
			case 8:
				astrcpy (name, (char *) "DEV14READ");
				break;
			case 9:
				astrcpy (name, (char *) "DEV14WRITE");
				break;
			case 10:
				astrcpy (name, (char *) "DEV8TYPE");
				break;
			case 11:
				astrcpy (name, (char *) "DEV10TYPE");
				break;
			case 12:
				astrcpy (name, (char *) "DEV12TYPE");
				break;
			case 13:
				astrcpy (name, (char *) "DEV14TYPE");
				break;
		}
			
		j = s_lookup();							/* see if it's there							*/
		
		if ((j != -1) && (((i < devdrivers) && (type_sym (j) == t_proc))/* if we found it								*/
		|| ((i >= devdrivers) && (type_sym (j) == t_var))))/* watch out for device types					*/
			device_label [i] = loc_sym (j);		/* remember where it is							*/
	}											/* of setting labels for device driver entry points	*/
		
	for (i = 0; i < spectablen; i++) {			/* set labels of special procedure entry points	*/
		switch (i) {							/* branch on driver we're looking for			*/
			case 0:
				astrcpy (name, (char *) "OVERLAY");
				break;
			case 1:
				astrcpy (name, (char *) "CHECK_POLYCACHE");
				break;
		}
			
		j = s_lookup();							/* see if it's there							*/
				
		if ((j             !=   -1)
		&& (type_sym (j) == t_proc))
			special_label [i] = loc_sym (j);
	}
	
	if (link_error != 0)						/* did we make it through the link phase without any errors?	*/
		exit(-1);								/* no, abort									*/
}


	/* $$The KEYCH procedure is used to check a key number passed from pass2. */
	
static	void	optimize_keych(					/* check range									*/
	fixed	k)
{
	if (_IGT_(k, r [l_key]))
		er_sys ((char *) "key value out of range", (char *) "keych");
}
	
static	void	optimize_altch(					/* check range									*/
	fixed	k)
{
	if (_IGT_(k, r [l_altkey]))
		er_sys ((char *) "alt key value out of range", (char *) "keych");
}
	
	/* The ADDSWAP procedure adds the remapped locations of swapped scon to
	.  the list of swapping scon pointers.
	.
	.  ADJSWAP adjusts a scon pointer to its remapped value if it's in
	.  the list.  If the pointer is adjusted, the global flag IT_SWAPS
	.  will be set to TRUE so we can later determine whether this
	.  is a pointer to swapping scon.  ADJSWAP removes the entry for the
	.  passed pointer after it adjusts the pointer.  This is because string
	.  constants can only be referenced ONCE.  The adjusted pointer for a
	.  data constant has a negative value; these entries aren't removed
	.  until the end of the swapping procedure.
	.
	.  These routines can ONLY be called during SWAPS. */
	
static	void	optimize_addswap(				/* add a swapping scon's mapping to the swapping scon pointer list	*/
	fixed	old_ptr,
	fixed	new_ptr,
	fixed	swaps)								/* old scon pointer, new scon pointer			*/
	
{
	if (! (swaps & 1)) er_sys ((char *) "not in SWAPS", (char *) "addswap");
		
	push (old_ptr);								/* push the old pointer							*/
	push (new_ptr);								/* immediately followed by the new				*/
}
	
static	fixed	optimize_adjswap(				/* adjust a scon pointer if it swaps			*/
	fixed	ptr, 								/* pointer to adjust							*/
	fixed	swaps, 
	pointer	it_swaps)
{
	static	fixed	found;						/* True when we find the address in the swap area	*/
	static	fixed	i;
	
	if (! (swaps & 1)) er_sys ((char *) "not in SWAPS", (char *) "adjswap");
		
	i = -2; found = 0;
	while ((i < stkptr) && (! (found & 1))) {	/* look for this pointer						*/
		i = i + 2;
		if (stack [i + 1] < 0)					/* if data										*/
			found = ((_IGE_(ptr, stack [i])) & (_ILE_(ptr, stack [i + 2])));	/* see if in range								*/
		else found = (stack [i] == ptr);		/* for scon										*/
	}
		
	if (i < stkptr) {							/* if swapped scon								*/
		*it_swaps = true;						/* let 'em know it swaps						*/
		
		if (stack [i + 1] < 0)					/* if data										*/
			ptr = -stack [i + 1] + (ptr - stack [i]);	/* remap pointer								*/
		else {									/* delete scon entries as we go					*/
			ptr = stack [i + 1];				/* remap pointer								*/
			stkptr = stkptr - 2;				/* we have one less entry						*/
			if (i < stkptr) {					/* delete this entry							*/
				stack [i] = stack [stkptr]; stack [i + 1] = stack [stkptr + 1];	/* by swapping in last entry					*/
			}
		}										/* of deleting scon entries as we go			*/
	}											/* of swapped scon								*/
	else *it_swaps = false;						/* let 'em know it doesn't swap					*/
		
	return (ptr);								/* return mapped (or unchanged) pointer			*/
}
	
static	void	optimize_clrswap()				/* clear the scon pointer list					*/
{
	stkptr = 0;
}
	/* 06/01/89 - cj - fixed "off by 1" bug with jump optimization */
	
	/*  $$Initialize for iterative scan through the intermediate file - KEYFLAG
	.   contains all zeroes at this point, so all keys are "unknown". */
	
static	void	optimize_clearstkptr()			/* handy routine to clear both stack			*/
{
	stkptr = 0;									/* pointers										*/
	altstkptr = 0;
}
	
/*  $$Perform iterative optimization phase:
.
.   During this phase of compilation, the string and data constants are
.   copied to the object file.  This places them directly after the rtp
.   "intro" (lowcore) and directly before the runtime package.
.
.   A dead code analysis is also performed.  This proceeds as follows:
.      1) Assume all labels are at the start of neither dead (inactive)
.         or active code.  Rather, assume the state of said code is unknown.
.      2) Assume the startup code (at the beginning of the IF) is active
.         (which it better be since LOWCORE transfers there at start-up).
.      3) Iterate through the IF until no more label states change:
.         a) When we reach a label, determine if we should be active:
.            If we are active when we reach the label, stay active (and
.            make the label's state active).
.            Otherwise, set active to the label's state (active or unknown).
.         b) When we reach a jump or a user proc call, update target label's
.            state to active if we are currently active.
.
.   This routine also determines what SCON records can swap.  Two lists
.   are used to make this determination:  NOSWAP and ALIASES.
.
.   NOSWAP is a bit list with one word assigned to every procedure
.   (indexed by the key number of the proc).  Each bit in this word is
.   used to signify which parameters of the procedure are fixed arrays
.   and can't swap (i.e., fixed array parameters that are eventually
.   passed on to a swapping procedure OR are in a swapping procedure).
.   The bit list is oriented from least significant to most significant,
.   so formal parameter zero's flag is in bit zero of the word, formal
.   parameter one's flag is in bit one of the word, etc.  In this way,
.   we can represent the state of up to sixteen formal parameters.  Any
.   excess (beyond sixteen) parameters of a procedure are ignored (i.e.,
.   NOT optimized).  Note that every bit in a swapping procedure's word
.   is set (i.e., none of its formal parameters can swap).  NOSWAP is
.   physically stored in KEYJTO and indexed by (KEY + PROC_NOSWAP).
.
.   ALIASES is a list of lists of formal parameter/actual parameter
.   aliases.  There is a separate list of formal parameter/actual
.   parameter aliases for each procedure.  This list is comprised
.   of a specified number of aliases.  Each alias is represented
.   in one machine word.  This word contains the formal -> actual
.   mapping with the actual parameter number stored in the lower
.   eight bits and the formal parameter number stored in the upper
.   eight bits.  ALIASES is physically stored in the CALL records
.   of the intermediate file.
.
.   The "find swapping scon" algorithm proceeds as follows:
.
.      1) Make one pass over intermediate file to initialize NOSWAP:
.         a) If SWAP flag is set in ET.PDF record, set NOSWAP to all ones (-1).
.         b) As we process ET.CAL statements, if NOSWAP is set for the actual
.            parameter to the called function, set NOSWAP for formal parameter
.            of calling procedure.
.
.      2) Make N passes over ALIASES list (until NOSWAP doesn't change):
.         a) If NOSWAP is set for actual parameter of called function
.            and NOSWAP isn't set for formal parameter of calling proc,
.            set NOSWAP for formal parameter of calling proc and make
.            another pass.
.
.      3) Make another pass through the intermediate file (JUMPS and (ITER = 0)):
.         a) If key in ET.SCN record is zero, it's being passed to an
.            RTP routine, so set SWAPPING flag in the ET.SCN record.
.         b) If key in ET.SCN record is non-zero, it's being passed to
.            a user routine, so clear SWAPPING flag in the ET.SCN record
.            if NOSWAP for that actual parameter; otherwise set SWAPPING.
*/

/*  $$
.   This process has three phases:
.      1) Eliminate all dead code (activate all "live" code) as described above (JUMPS = FALSE) and find all swapping scon.
.      2) Emit non-swapping scon and compress jumps to jumps into single jumps (JUMPS = TRUE).
.      3) Emit swap lookup table (SWAPS = TRUE).
*/

static	void	optimize(						/* optimize the object code (sets up KEYLOC, KEYJTO, and KEYFLAG)	*/
	fixed	skip_opt, 							/* True if we should skip dead code analysis	*/
	fixed	force_out)							/* True if should force all procs to ext mem	*/
{
    fixed			_upper0;
	static	fixed	altf;						/* True if the IF has been altered				*/
	static	fixed	iter;						/* current iteration of this phase (phase defined by JUMPS)	*/
	static	fixed	jumps;						/* True when we are optimizing jumps to jumps	*/
	static	fixed	swaps;						/* True when we are emitting swap lookup table	*/
	static	fixed	active;						/* True if this code is active					*/
	static	fixed	key;						/* current key value							*/
	static	fixed	okey;						/* old key value								*/
	static	fixed	ocl;						/* old CUR.LOC									*/
	static	fixed	dist;						/* jump distance								*/
	static	fixed	cond;						/* jump condition								*/
	static	fixed	lcl;						/* last CUR.LOC									*/
	static	fixed	scon_loc;					/* Scon/data location (analogous to CUR.LOC)	*/
	static	fixed	swapscon;					/* swapping SCON location (analogous to CUR.LOC)	*/
	static	fixed	anyscon;					/* set if any swapping data/consts for proc		*/
	static	fixed	swapdata;					/* True if succeeding data should swap			*/
	static	fixed	tosskey;					/* key of the current proc being tossed (ZERO if not tossing)	*/
	static	fixed	tossram;					/* starting ram for current proc being tossed (undefined if TOSSKEY = 0)	*/
	static	fixed	tosstemp;					/* starting temp for current proc being tossed (undefined if TOSSKEY = 0)	*/
	static	fixed	sram;						/* starting ram location for proc				*/
	static	fixed	stemp;						/* starting temp location for proc				*/
	static	fixed	swapping;					/* True if swapping scon						*/
	static	fixed	swap_loc;					/* used to save and restore CUR.LOC before/after swap proc definitions	*/
	static	fixed	swap_key;					/* Key of current swappable proc				*/
	static	fixed	swap_key_id;
	static	fixed	temp;
	static	fixed	numargs;
	static	fixed	swap_id;
	static	fixed	current_page;
	static	fixed	new_page;
	static	fixed	boundary;
	static	fixed	proclevel;
	static	fixed	whenlevel;
	static	fixed	whenproc;
	
	static	fixed	current_key = 0;			/* key of proc we're currently scanning			*/
	static	fixed	parms;						/* number of parameters passed to a recursive proc	*/
	
	static	fixed	delete_map[insmax];			/* bit map of INSERT statements to delete (16 x INSMAX = maximum allowed)	*/
	static	fixed	insert_;					/* # of insert statements we've found			*/
	static	fixed	deleted;					/* # of insert statements we've deleted			*/
	
	static	fixed	always_process[] = {13, et_tra, et_lde, et_dat, et_cpy, 
	et_scn, et_pdf, et_pen, et_whn,
	et_wen, et_ins, et_ldf, et_atr, et_ald};	/* records to always process					*/
	static	fixed	not_always[et_max + 1];		/* False if this record should always be processed	*/
	
	#define	debug		false					/* True to debug								*/
	static	fixed	new_active, new_loc, new_swapscon;	/* Altf causes							*/
	
	fixed	proc_def_found;
	
	iter = 0;									/* first iteration is the 0th					*/
	jumps = 0;									/* no jumps to jumps optimized out yet			*/
	swaps = 0;									/* no swap table yet							*/
	tosskey = 0;								/* we aren't tossing anything here				*/
	ramptr = 0;									/* initialize ram deleted stack (only done during ITER 0 of JUMPS)	*/
	sconptr = 0;								/* initialize scon deleted stack (only done during ITER 0 of JUMPS)	*/
	scon_loc = 0;								/* start SCON/data at location zero				*/
	swap_key = 0;								/* no swappable proc yet						*/
	proclevel = 0;
	whenlevel = 0;
	whenproc  = 0;
	
	blockset (not_always, et_max + 1, 1);		/* assume no records are always processed		*/
	for (_upper0 = always_process [0], key = 1; key <= _upper0; key++) {	/* set up NOT_ALWAYS							*/
		not_always [always_process [key]] = 0;	/* always process this type of record			*/
	}
		
	/* make procedures and device drivers active */
	for (_upper0 = l_icell + whentablen - 1, key = l_icell; key <= _upper0; key++) {	/* make all WHEN statements active (since they are)	*/
		if (r [key] != 0) set_keyflag (r [key], abit);
	}
		
	for (key = 0; key < devdrivers; key++) {	/* make all device drivers active (since they are)	*/
		if (device_label [key] != 0) set_keyflag (device_label [key], abit);
	}
		
	while ((iter < 2) || altf & 1 || (! (jumps & 1 && swaps & 1))) {	/* 2 times min (before JUMPS and after JUMPS)	*/

		if (show_progress || show_p3_progress)
			printf(".\n");

		proc_def_found = false;
		iteration = iteration + 1;				/* count for stat printout						*/
		cur_loc = 0;							/* start code at location zero					*/
		altf = 0;								/* indicate not altered							*/
		active = 1;								/* initial code is active						*/
		insert_ = 0; deleted = 0;				/* haven't seen any INSERT statements and haven't deleted any either	*/
		istkptr = 0;							/* reset istk pointer in case we have too many	*/
		stkptr = 0;								/* clean up stack initially						*/
		altstkptr = 0;							/* also alternate stack							*/

		for (key = 0; key < rtp_ptrs; key++) {	/* initialize list of called subs				*/
			rtpsubs [key] = 0;
		}
		resetif ();								/* reset the IF									*/
		
		/* Initialize the following variables for all iterations:    */
		
		/* compute where first swap procedure would sit in ext memory */
		/* based upon how many were defined in the last iteration,    */
		/* hence upon the size of the swap look up table:             */
		
		if (prctyp < 3) {									/* Model A, B, C - use 3 stride table				*/
			swap_total = shr(swap_procs*3 + 1, 8);			/* set sector length to length of lookup table		*/
			swap_words = ((swap_procs*3 + 1) & 0x00FF);		/* set word length to length of lookup table		*/
		}
		else {												/* Model d: reserve 64 words, use 4 stride table	*/
			swap_total = shr(swap_procs*4 + 65, 8);			/* set sector length to length of lookup table		*/
			swap_words = ((swap_procs*4 + 65) & 0x00FF);	/* set word length to length of lookup table		*/
		}
			
		/* Actually write the swap table out to the intermediate file */
		/* during the one pass that swaps <> 0.   Also set swap_total */
		/* and swap_words to equal the length of the swap table (plus */
		/* header) so that they point to where the first swapping     */
		/* proc will actually go:                                     */
		
		if (swaps & 1 && (swap_procs != 0)) {
			
			ovr_file = (FILE *) open_able_file_for_output((char *) "/tmp/XPLCompilerSwapFile", 'DATA', 'SNCL');
			strncpy (host_swap_file, ABLE_CONTEXT.opened_file_name, 256);

			ovr_length = 0;
			
			/* For Model D compilations,  emit 64 words at the front of	*/
			/* swap file that contains the object code used to switch	*/
			/* pages:										*/
			
			if (prctyp >= 3) {
				for (_upper0 = rfbuf [l_sta] + 64, temp = rfbuf [l_sta] + 1; temp <= _upper0; temp++) {	/* copy 64 words								*/
					writeovr(rfbuf[temp]);
				}
			}
				
			writeovr (swap_procs);				/* write out number of overlays					*/
			
			rtpsubs [l_swap] = 1;				/* make sure we include "call swapped proc" routine	*/

		}										/* of emitting swap table header				*/
			
		/* reset variables for next iteration:			*/
		
		swap_procs = 0;							/* reset swap proc counter for next iteration	*/
		swap_size = 0;							/* reset size for next iteration				*/
		swap_scon = 0;							/* reset size of largest scon data area			*/
		scon_loc = 0;							/* restart SCON/data at location zero			*/
		swapscon = 1;							/* start swapping scon pointer (starts at ONE	*/
		anyscon  = 0;							/* to avoid zero (-0 = 0))						*/
		
		/*  $$Iterative optimization phase (cont.): */
		
		key = readif();							/* get first word of IF							*/
		
		while (key != et_eof) {					/* stop at eof									*/
		
			if ((swapdata  != 0     )			/* if we had been scanning data					*/
			&& (key       != et_cpy))			/* and we are not now							*/
			{									/* add it to list if SWAPS						*/
				if (swaps & 1)					/* if emitting swapping code					*/
					optimize_addswap (scon_loc - 1, 0, swaps);	/* remember the length							*/
				swapdata = 0;					/* only swap copy data records which immediately follow the data definition (which sets this flag)	*/
			}
				
			/* Quickly find next non-literal word			*/
			
			if ((key & literal_mask) != 0) {	/* literal word									*/
				if (active & 1) {
					if (jumps & 1 && (! (swaps & 1)))
						optimize_clearstkptr();
					cur_loc = cur_loc + 1;		/* literals take one word						*/
					key = readif();				/* get next word of IF							*/
					while ((key & literal_mask) != 0) {
						cur_loc = cur_loc + 1;							/* literals take one word						*/
						key = readif();									/* get first word of IF							*/
					}
				}
				else while ((key & literal_mask) != 0) {
					key = readif();
				}
			}
				
			if (key == et_eof) {
				/* exit next time */
			}
				
			else if ((! (active & 1)) && not_always [key] & 1)/* if this doesn't always need to be processed	*/
				skiprecord (key);				/* skip non-active records						*/
				
			else switch (key - 1) {				/* else branch on type							*/
				case 0:
				{								/* literal word									*/
					readif();
					cur_loc = cur_loc + 1;
					if (active & 1 && jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					break;
				}								/* literal word									*/
					
				/* Iterative optimization:  process jump instruction
				.
				.  Examine each jump instruction.   If it is an unconditional jump
				.  instruction,  then set a flag to indicate the code that follows can
				.  never be called.  Also detect a jump to a jump instruction, and forward
				.  the address to the destination of the second jump.
					*/
				
				case 1:
				{								/* jump instruction								*/
					cond = readif();			/* get condition code							*/
					key = readif();				/* get key to jump to							*/
					lcl = cur_loc;				/* save CUR.LOC before this instruction (for jump to jump deletion)	*/
					
					if (active & 1) {									/* for active code only							*/
						if (key != 0) {									/* ignore clobbered keys (from jmp . => clobbered below if DIST = 10000)	*/
							optimize_keych (key);						/* make sure in range							*/
							
							if (jumps & 1) {							/* follow jumps to jumps only during JUMPS		*/
								dist = 0;								/* this is infinite loop detector				*/
								okey = keyjto (key);					/* see if this location jumps somewhere			*/
								
								while ((okey != 0) && (dist < 10000)) {	/* after 10000, assume we are hung up			*/
									set_keyflag (key, keyflag (key) & (~ abit));	/* this label is now unknown					*/
									key = okey;							/* make this the new destination				*/
									okey = keyjto (key);
									dist = dist + 1;
								}
									
								if (dist == 10000) key = 0;				/* detect infinite loop - key of 0 = jmp .		*/
									
								if (dist != 0) {						/* if we changed the key						*/
									writeif (key);						/* write out new key							*/
									altf = 1;							/* we've made an alteration						*/
									if (debug & 1) new_loc = (new_loc | 1);
								}
							}											/* of if JUMPS									*/
								
							if (key != 0) {								/* if key isn't clobbered (i.e., it's jumped to)	*/
								okey = keyflag (key);					/* pick up bits									*/
								
								if ((okey & abit) == 0) {				/* see if we need to make it active				*/
									set_keyflag (key, okey | abit);		/* indicate active								*/
									altf = 1;							/* we've made an alteration						*/
									if (debug & 1) new_active = (new_active | 1);
								}
							}											/* of it's jumped to							*/
						}												/* of non-clobbered key							*/
							
						ocl = readif();									/* get old estimated location					*/
						if (ocl != cur_loc) {							/* check if loc changed from last pass			*/
							writeif (cur_loc);							/* write out new location						*/
							if (jumps & 1) {							/* only bother to re-iterate if JUMPS			*/
								altf = 1;								/* the IF changed								*/
								if (debug & 1) new_loc = (new_loc | 2);
							}
						}												/* of altered loc								*/
							
						if ((iter == 0) && (! (jumps & 1))) cur_loc = cur_loc + 2;	/* assume 2 before JUMPS						*/
						else if (skip_opt != 0)         cur_loc = cur_loc + 2;
						else if (key == 0) cur_loc = cur_loc + 1;		/* detect jmp .									*/
						else {											/* see if jump instruction fits in one word		*/
							if ((okey & dbit) != 0)						/* already defined this pass					*/
								dist = keyloc (key) - cur_loc - 1;		/* compute distance based on current iteration	*/
							else {										/* forward reference jump						*/
								if (ocl == -1) dist = -32768;			/* if inactive last pass, assume long jump		*/
								else {									/* was active last pass							*/
									dist = keyloc (key) - ocl - 1;		/* forward distance (use values from previous pass)	*/
									if (dist == -1) dist = 0;			/* -1 means previously deleted jmp .+1			*/
								}										/* of was active last pass						*/
							}											/* of forward reference jump					*/
								
							if ((dist != 0) || (!(jumps & 1))) {		/* 0 means jmp .+1 - delete instr - but only after all active code has been identified	*/
								if (emitt (dist) & 1)					/* if fits in immediate field					*/
									cur_loc = cur_loc + 1;				/* then 1 word									*/
								else cur_loc = cur_loc + 2;				/* else 2 words									*/
							}
						}												/* of checking if jump instruction fits in one word	*/
					}													/* of active									*/
					else {												/* if we're not active							*/
						if (readif() != -1) writeif (-1);				/* get old loc - mark inactive if not already marked	*/
					}													/* of not active								*/
						
					if (cond == b_tra) {								/* unconditional transfer?						*/
						if (jumps & 1 && (! (swaps & 1)))				/* if deleting jumps to jumps					*/
						{
							while (stkptr != 0) {						/* see if any labels at this location (unstack label defs)	*/
								ocl = pop(); okey = pop();				/* get location, its key						*/
								
								if (ocl == lcl)							/* see if instruction at this label is jump (LCL is set to CUR.LOC at top)	*/
									set_keyjto (okey, key);				/* indicate jmp to jmp							*/
							}
							altstkptr = 0;								/* cannot jump to jumps of different key types	*/
						}
						active = 0;										/* inactive code follows unconditional transfers	*/
					}													/* of unconditional transfer					*/
					break;
				}								/* of jump										*/
					
				/*  $$Iterative optimization phase (continued):	*/
				
				case 2:
				{								/* proc call									*/
					lcl = readif();				/* get length of record							*/
					key = readif();				/* get key										*/
					optimize_keych (key);
					
					for (dist = 1; dist < lcl; dist++) {	/* examine formal/actual parameter aliases		*/
						ocl = readif();									/* get next formal/actual parameter alias		*/
						
						if (ocl < 0) {									/* if the formal parameter key follows			*/
							if ((ufixed) dist == (ufixed) (lcl - 1))	/* if at the end of the list - bad alias list	*/
								er_sys ((char *) "invalid alias list", (char *) "optimize");
								
							ocl = (ocl & (fixed) 0x7FFF);				/* turn off the sign bit						*/
							okey = readif();							/* pick up proc key of formal parm defn			*/
							dist = dist + 1;							/* we read one more word						*/
							optimize_keych (okey);
						}
						else okey = current_key;						/* otherwise, it's the current proc				*/
							
						if ((! (jumps & 1)) && ((keyjto (key + proc_noswap) & bit [ocl & 0x00FF]) != 0))
						{												/* if actual can't swap							*/
							if ((shr(ocl, 8) < 16) && ((keyjto (okey + proc_noswap) & bit [shr(ocl, 8)]) == 0))
							{											/* if we think the corresponding formal parameter can swap	*/
								set_keyjto (okey + proc_noswap, keyjto (okey + proc_noswap) | bit [shr(ocl, 8)]);	/* flag it as non-swappable						*/
								altf = 1;								/* we need to keep looking to see whether data can swap	*/
								if (debug & 1) new_swapscon = (new_swapscon | 1);
							}
						}												/* of actual parameter that can't swap			*/
					}													/* of examining formal/actual parameter aliases	*/
						
					/* see if this proc is called from inside a when     */
					/* statement.   If so, make sure proc cannot swap    */
					
					if ((whenlevel != 0)		/* if inside a when statement					*/
					||  (whenproc  != 0))		/* or inside a proc called						*/
					{													/* from a when statement						*/
						if ((keyflag (key + proc_info) & proc_when) == 0)
						{
							set_keyflag (key + proc_info,
							keyflag (key + proc_info) | proc_when);
							altf = 1;
							if (debug & 1) new_loc = (new_loc | 0x0200);
						}
					}
						
					if ((keyflag (key) & abit) == 0) {					/* if not active already						*/
						set_keyflag (key, keyflag (key) | abit);		/* indicate active								*/
						altf = 1;
						if (debug & 1) new_active = (new_active | 2);
					}
						
					/* if calling a swap procedure, see how many instructions	*/
					/* it will need:								*/
					
					if ((keyflag (key + proc_flags) & p_swap) != 0) {
						
						swap_id = keyloc (key);							/* get id for this swap proc					*/
						
						if (swap_key == key)							/* if call to itself, only						*/
							cur_loc = cur_loc + 2;						/* two instructions needed						*/
							
						else if ((prctyp     >= 3)						/* if on model d ...							*/
						&&      (swap_id    != 0)						/* and not first time thru						*/
						&&      (swinfo_ptr != 0)						/* if swinfo storage available					*/
						&&      (_ILT_(swap_id, swinfo_max))			/* and info for id we are calling is available	*/
						&&      (swinfo(2*swap_id) != 0)				/* and proc we are calling uses no string/data storage	*/
						&&      ((shr(swinfo(2*swap_id+1),8) < 4)		/* takes 3 or fewer register arguments			*/
						||        ((swap_key != 0)						/* or we are in a swap proc now					*/
						&&        (_ILT_(swap_key_id, swinfo_max))		/* and info for current procedure is available	*/
						&&        ((swinfo(2*swap_id+1)&255) == (swinfo(2*swap_key_id+1)&255))))/* and it resides on the same page as the one we are calling	*/
						&&      (! (debug_on & 1)))						/* don't do this if debug flag on				*/
						{
							
							new_page = swinfo(swap_id*2+1)&255;
							
							if (swap_key == 0)							/* if on page 0 - look up page and go there		*/
							{
								if (new_page == 0)
									cur_loc = cur_loc + 7;
								else if (emitt(new_page) & 1)
									cur_loc = cur_loc + 8;
								else cur_loc = cur_loc + 9;
							}
								
							else {
								current_page = swinfo(swap_key_id*2+1)&255;
								if (current_page != new_page)
								{
									if (emitt(new_page - current_page) & 1)/* else use 4 or								*/
										cur_loc = cur_loc + 4;			/* 5 instr jump									*/
									else cur_loc = cur_loc + 5;			/* sequence										*/
								}
								else cur_loc = cur_loc + 2;				/* jump if same page							*/
							}
						}
							
						/* else if models c or d, store swap id # in r15	*/
						/* and jump to low memory:						*/
						
						else if (prctyp >= 2) {							/* models c, d									*/
							if (emitt (swap_id) & 1)					/* if small id									*/
								cur_loc = cur_loc + 2;					/* then 2 words									*/
							else cur_loc = cur_loc + 3;					/* else 3 words									*/
						}
							
						/* else for model b,  store swap id # in memory	*/
						/* and call r.swap:								*/
						
						else {											/* models a,b - store id#						*/
							if (emitt (swap_id) & 1)
								cur_loc = cur_loc + 5;
							else cur_loc = cur_loc + 6;
						}
					}
						
					/* else if calling an internal memory procedure from	*/
					/* a swapping procedure,  it takes a 3 word call on	*/
					/* the model D:									*/
					
					else if ((swap_key  != 0)
					&&     (prctyp    >= 3))
					{
						/* proc_inside */if (keyloc (key + proc_regs) & 1)/* if calling a proc WITHIN					*/
							cur_loc = cur_loc + 2;						/* a swapping proc, 2 words						*/
						else cur_loc = cur_loc + 3;						/* else 3 words to switch pages					*/
					}
						
					/* else can do a call in two instructions:		*/
					
					else cur_loc = cur_loc + 2;							/* two words to do a CALL						*/
					break;
				}														/* of procedure call							*/
					
				case 3:
				{														/* rtp call										*/
					key = readif();										/* get rtp location								*/
					
					if (jumps & 1 && (! (swaps & 1)))
						optimize_clearstkptr();							/* free up stack here - we know this makes code	*/
					
					if (_IGE_(key, l_interp))							/* interpreter call								*/
					{
						if (emitt(key-l_interp) != 0)					/* will fit in 1 word							*/
							cur_loc += 1;
						else											/* will fit in 2 wods							*/
							cur_loc += 2;
					}
					
					else if (_IGE_(key, rtp_ptrs))						/* too big??									*/
						er_sys ((char *) "RTP key value out of range", (char *) "optimize");
					
					else
					{					
						rtpsubs [key] = 1;								/* set to true to indicate sub is used			*/
						
						if ((swap_key != 0)
						&& (prctyp   >= 3))
							cur_loc = cur_loc + 3;						/* three locations								*/
						
						else
							cur_loc = cur_loc + 2;						/* two locations								*/
					}

					break;
				}
					
				case 4:
				{								/* variable area pointer to dest				*/
					readif();					/* skip destination								*/
					
					switch (readif()) {			/* branch on storage class						*/
						case 0:
						{												/* static										*/
							readif();									/* skip loc										*/
							cur_loc = cur_loc + 2;						/* always takes two words						*/
							break;
						}												/* of static									*/
							
						case 1:
						{												/* automatic									*/
							key = readif();								/* get location									*/
							
							if ((iter == 0) && jumps & 1) {				/* remap stack addresses during iteration zero of JUMPS	*/
								if ((_IGE_(key, temp_base)) && (_ILT_(key, extern_base)))/* is this a temp?								*/
									key = (key - temp_base) + keyjto (current_key + proc_temps) + 1;	/* map temp to relative stack location			*/
									
								if (prctyp < 2)							/* on models A & B								*/
									key = (key - 1) - keyloc (current_key + proc_stack);	/* make relative to stack pointer (rather than stack start - LOC is off by one)	*/
								else key = key + 1;						/* model C - LOC is off by one					*/
									
								writeif (key);							/* save location relative to stack pointer		*/
							}											/* of checking for temps						*/
								
							if (emitt (key) & 1)						/* if it fits in an immediate field				*/
								cur_loc = cur_loc + 2;					/* only two words								*/
							else cur_loc = cur_loc + 3;					/* need three words								*/
							break;
						}												/* of automatic									*/
					}													/* of storage class								*/
					break;
				}								/* variable area pointer to dest				*/
					
				case 5:
				{								/* object code pointer (do case jump)  - et.cas	*/
					key = readif();
					optimize_keych (key);		/* check in range								*/
					
					if (jumps & 1 && (keyjto (key) != 0)) {				/* detect jmps to jmps here (i.e., empty case)	*/
						key = keyjto (key);
						writeif (key);									/* this is new destination for do case			*/
						altf = 1;
						if (debug & 1) new_loc = (new_loc | 4);
					}
						
					if ((keyflag (key) & abit) == 0) {					/* if it is now known							*/
						set_keyflag (key, keyflag (key) | abit);		/* indicate active								*/
						altf = 1;
						if (debug & 1) new_active = (new_active | 4);
					}
						
					/* for Model D,  if in swapping procedure, emit a jump	*/
					/* to the correct case.							*/
					if ((swap_key  != 0)
					&& (prctyp    >= 3))
						cur_loc = cur_loc + 2;
					else cur_loc = cur_loc + 1;
					break;
				}								/* of object code pointer						*/
					
				case 6:
				{								/* label definition  - ET.LDE					*/
					key = readif();
					optimize_keych (key);		/* check limits									*/
					okey = keyflag (key);		/* pick up flags								*/
					
					if ((skip_opt & 1)			/* skip of optimization desired					*/
					&& (iter ==  0)				/* and first iteration							*/
					&& (! (jumps & 1)))			/* of not jumps									*/
						okey = okey | abit;
						
					if (active & 1) {									/* if we're active								*/
						if ((okey & abit) == 0) {						/* and not already active						*/
							okey = (okey | abit);						/* mark as active								*/
							altf = 1;
							if (debug & 1) new_active = (new_active | 0x0008);
						}
					}													/* of active									*/
					else active = ((okey & abit) != 0);					/* if not active, assume activity of label		*/      
						
					if (((okey & pbit) == 0)	/* if is a lobel (VS proc)						*/
					|| ((keyflag(key + proc_flags) & p_swap) == 0))/* or a non-swapping proc						*/
					{
						if (keyloc (key) != cur_loc) {					/* if stored location doesn't match newest location	*/
							set_keyloc (key, cur_loc);					/* save current location of the label			*/
							if (jumps & 1) {							/* only bother to re-iterate if jumps			*/
								altf = 1;
								if (debug & 1) new_loc = (new_loc | 0x0010);
							}
						}												/* of stored location doesn't match newest		*/
					}													/* of normal proc								*/
						
					set_keyflag (key, okey | dbit);	/* indicate is defined							*/
					
					if (jumps & 1 && (! (swaps & 1))) {					/* stack jump to jump detectors only if detecting jumps to jumps	*/
						push (key);
						push (cur_loc);									/* stack these to check next instr				*/
					}
					break;
				}								/* of label definition							*/
					
				case 7:
				{								/* data definition								*/
					if ((iter == 1) && (! (jumps & 1))) {				/* move data swapping info into the IF			*/
						key = readif();									/* pick up data key								*/
						readif();										/* read swapping flag							*/
						if (((current_key != 0) && (key < 16)
						&& ((keyloc (current_key + proc_dswp)
						& bit [key]) == 0))								/* if it can swap								*/
						&& ((keyflag (current_key + proc_flags) & p_swapscon) != 0))/* check for swapping of scons & data arrays	*/
							writeif (1);								/* mark it as such								*/
					}
					else {												/* determine if succeeding data swaps			*/
						readif();										/* skip over key								*/
						swapdata = ((swap_key != 0) & readif());		/* set swap data flag for following COPY DATA record(s)	*/
					}
					break;
				}								/* of data definition							*/
					
				case 8:
				{								/* copy data to object file						*/
					key = readif();				/* get number of data words						*/
					if ((iter == 0) && jumps & 1) {						/* emit SCON during first iteration				*/
						
 					for (okey = 1; okey <= key; okey++) {				/* copy over or skip the data					*/
							ocl = readif();								/* get data										*/
							if ((tosskey == 0) && (! (swapdata & 1))) writeobj (ocl);	/* only emit if not in an inactive proc			*/
						}
							
						/* If the string constant/data is being tossed because */
						/* the procedure is never called,  or if the string    */
						/* constant data is for a swap procedure and hence     */
						/* written out to the swap file,  adjust the string    */
						/* constant/data map to reflect the data will not be   */
						/* in internal memory:                                 */
						
						if ((tosskey != 0) || swapdata & 1)
							delscon (scon_loc, key);
						scon_loc = scon_loc + key;						/* count the number of words we encounter		*/
					}													/* of first iteration							*/
					else if (swaps & 1) {								/* if we're in SWAPS							*/
						
						if (swapdata & 1 && active & 1) {				/* if swapping scon								*/
							optimize_addswap (scon_loc, -swapscon, swaps);	/* add it to the swapping scon table (but mark it as data)	*/
						}
							
						for (okey = 1; okey <= key; okey++) {readif(); }	/* skip over record								*/
						scon_loc = scon_loc + key;						/* count the number of words we encounter		*/
					}													/* of in SWAPS									*/
					else {
 						for (okey = 1; okey <= key; okey++) {readif(); }	/* skip over record								*/
					}
					if (swapdata & 1 && active & 1) {					/* if swapping scon								*/
						swapscon = swapscon + key;						/* count number of swapped words				*/
					}
					anyscon = 1;
					break;
				}								/* copy data									*/
					
				case 9:
				{								/* copy scon to object file						*/
					key = readif() - 2;			/* get the number of data words					*/
					okey = readif();			/* pick up key of proc this is passed to		*/
					swapping = readif();		/* pick up param # or swapping					*/
					if ((iter == 0) && jumps & 1) {						/* emit SCON during first iteration				*/
						
						/* If calling an rtp procedure,  then we can swap */
						/* the string constants,  but do so only if we    */
						/* are in a swapping procedure:                   */
						
						if (okey == 0)
							swapping = (swap_key != 0)
							& ((keyflag(swap_key + proc_flags) & p_swapscon) != 0);
							
						/* Else if calling a user procedure,  then see	*/
						/* if the procedure we are calling swaps,  or	*/
						/* passes the string constant to another proc	*/
						/* that swaps.									*/
						
						else swapping = (swapping < 16)
							& ((keyjto (okey + proc_noswap) & bit [swapping]) == 0)
							& ((keyflag(swap_key + proc_flags) & p_swapscon) != 0);
							
						writeif (swapping);								/* save flag for later passes					*/
						
						for (okey = 1; okey <= key; okey++) {			/* copy over or skip the scon					*/
							ocl = readif();								/* get scon										*/
							if (active & 1 && ((swap_key == 0) || (! (swapping & 1)))) writeobj (ocl);	/* only emit if active							*/
						}
							
						if ((! (active & 1)) || ((swap_key != 0) && swapping & 1))
							delscon (scon_loc, key);					/* add to deleted SCON list if not used OR IF data will rewside in swap file/external memory	*/
						scon_loc = scon_loc + key;						/* count the number of words we encounter		*/
					}													/* of first iteration							*/
					else if (swaps & 1) {								/* if we're in SWAPS							*/
						
						if (swapping & 1 && active & 1 && (swap_key != 0)) {	/* if swapping scon								*/
							optimize_addswap (scon_loc, swapscon, swaps);	/* add it to the swapping scon table			*/
						}
							
						for (okey = 1; okey <= key; okey++) {readif(); }	/* skip over record								*/
						scon_loc = scon_loc + key;						/* count the number of words we encounter		*/
					}													/* of in SWAPS									*/
					else {
						for (okey = 1; okey <= key; okey++) {readif(); }	/* skip over record								*/
					}
						
					if (swapping & 1 && active & 1 && (swap_key != 0))/* if swapping scon								*/
						swapscon = swapscon + key;						/* count number of swapped words				*/
						
					anyscon = 1;
					break;
				}								/* copy scon									*/
					
				case 10:
				{								/* do nothing for ignore type records			*/
					break;
				}
					
				/*  $$Iterative optimization phase (cont.):		*/
				
				case 11:
				{								/* procedure definition record  - proc def		*/
					run_host_environment_250();
					
					proc_def_found = true;
					
					numargs = readif();			/* get # of reg args plus record length			*/
					parms = (numargs&255) - 4;	/* get number of parms passed (only for recursive procs)	*/
					numargs = shr(numargs,8);	/* number of registers used						*/
					key = readif();				/* get key										*/
					optimize_keych (key + proc_keys);	/* check on all N keys							*/
					set_keyflag (key, keyflag (key) | pbit);	/* mark as a procedure							*/
					ppush (current_key); current_key = key;	/* save key of current proc						*/
					
					sram = readif();			/* get starting ram location					*/
					stemp = readif();			/* get starting temp location					*/
					cond = readif();			/* get procedure bits							*/
					
					if (proclevel == 0) {
						
						/* see if this procedure is called from a WHEN */
						/* statement:                                  */
						
						whenproc = ((keyflag(key + proc_info) & proc_when) != 0);
						
						/* Turn the proc into a swapping proc if it is */
						/* not called by an interrupt routine:         */
						
						if ((iter == 0)									/* if very first iteration						*/
						&& (! (jumps & 1))								/* ie VERY first								*/
						&& (force_out & 1)								/* and force swap desired						*/
						&& (whenlevel == 0)								/* and not inside WHEN							*/
						&& (! (device_driver (key) & 1))				/* and not a device driver						*/
						&& (! (special_driver(key) & 1))				/* and not 'OVERLAY' ...						*/
						&& (numargs < 4)								/* can jump there								*/
						&& (whenproc == 0))								/* and not called by WHEN						*/
						{												/* then force out								*/
							cond = cond | p_swap;
							writeif(cond);
						}
							
						/* if swaping procedure - turn into nonswap if proc	*/
						/* is called from a WHEN statement				*/
						
						if (((cond & p_swap) != 0)
						&&  (whenproc         != 0))
						{
							cond = cond & (~(p_swap|p_swapscon));
							writeif(cond);
							altf = 1;
							if (debug & 1) new_loc = (new_loc | 0x0400);
						}
					}
						
					proclevel = proclevel + 1;
					
					if ((cond & p_swap) != 0) {							/* if swappable proc							*/
						if (jumps & 1 && active & 1) {					/* if active and we're optimizing jumps (this condition MUST match the same in label defn)	*/
							swap_procs = swap_procs + 1;				/* count number of swappable procs (and assign proc ID)	*/
							if (keyloc(key) != swap_procs)				/* more info included							*/
							{
								altf = 1;
								set_keyloc (key, swap_procs);			/* set the ID for this proc						*/
								if (debug & 1) new_loc = (new_loc | 0x0020);
							}
							swap_loc = cur_loc;							/* remember CUR.LOC								*/
							
							if (prctyp >= 3)							/* For model d, cur.loc is						*/
								cur_loc = 0;							/* relative to start of proc					*/
							else cur_loc = swap_area;					/* else absolute								*/
								
							swapscon = 1;								/* restart swapping scon pointer				*/
							anyscon  = 0;								/* assume no string/data found					*/
							swap_key = key;								/* mark that we are inside a swap proc and remember the key for optimizing recursive calls	*/
							swap_key_id = swap_procs;
							
							/* store number of register arguments away so the */
							/* procedure end record can look at them:         */
							
							if ((swinfo_ptr != 0)						/* if swinfo storage available					*/
							&& (_ILT_(swap_procs, swinfo_max)))			/* and this id will fit							*/
								_write_62((swinfo(2*swap_procs+1)&255) + shl(numargs,8));
						}
					}													/* of swappable proc							*/
						
					set_keyflag (key + proc_flags, cond);	/* save procedure bits							*/
					
					for (okey = 1; okey <= parms; okey++) {	/* skip over parms								*/
						readif();
					}
						
					if (active & 1) {									/* for a called proc							*/
						if (prctyp >= 2) cur_loc = cur_loc + 1;			/* Model C requires one word to enter			*/
							
						if (jumps & 1)									/* don't look at proc registers until JUMPS (PROC_DSWP lives here until then)	*/
							okey = numbits (keyloc (key + proc_regs) & reg_mask);	/* see how many regs to save					*/
						else okey = 0;									/* this number is rather irrelevant (but must match proc end)	*/
							
						if ((okey > cutoff)								/* too many regs and Model C or (not swappable and not a device driver)?	*/
						&& ((prctyp >= 2) || (((cond & p_swap) == 0) && (! (device_driver (key) & 1)))))
							cur_loc = cur_loc + 1;						/* save all regs with 1 jump (to SREG)			*/
						else if (okey > 0) {							/* else save up to cutoff						*/
							cur_loc = cur_loc + okey;					/* need as many word as registers				*/
							if (prctyp < 2) cur_loc = cur_loc + 2;		/* Model A & B need two extra words				*/
						}
							
						if ((iter != 0) || jumps & 1)					/* only after first iteration (need to set up KEYLOC during first iter)	*/
							cur_loc = cur_loc + entry_len (parms, keyloc (key + proc_stack), cond);	/* determine where we are						*/
						if (jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					}													/* of a called proc defn						*/
					else if (jumps & 1 && (iter == 0)) {				/* set up to toss ram/scon from proc that isn't called	*/
						if (tosskey == 0) {								/* if we aren't already tossing a proc's ram	*/
							tosskey = key;								/* toss the ram from this proc					*/
							tossram = sram;								/* remember starting ram						*/
							tosstemp = stemp;							/* remember starting temp						*/
						}
					}													/* of proc that isn't called					*/
					break;
				}								/* of proc defn									*/
					
				case 12:
				{								/* handle end of procedure definition			*/
					key = readif();				/* get key										*/
					optimize_keych (key + proc_keys);	/* be paranoid about pass2 - check on all 4 keys again	*/
					sram = readif();			/* get ending ram in case we're tossing this proc	*/
					stemp = readif();			/* pick up temp end/temp offset					*/
					cond = keyflag (key + proc_flags);	/* pick up proc flags							*/
					
					proclevel = proclevel - 1;
					
					if (proclevel == 0)			/* clear whenlevel when returning				*/
						whenproc = 0;									/* to level 0 only.								*/
						
					if ((cond & p_recursive) != 0)/* if end of a recursive proc					*/
						set_keyjto (key + proc_temps, stemp);			/* save temp offset								*/
						
					set_keyloc (key + proc_stack, readif());	/* save stack length							*/
					okey = readif();			/* get registers used							*/
					
					if ((iter == 0) && (! (jumps & 1))) {				/* during first iteration only					*/
						if (((cond & p_recursive) == 0)					/* if end of a non-recursive proc				*/
						&& (keyloc (key + proc_stack) != 0)) {			/* and non-zero stack length (i.e., automatic vars declared)	*/
							okey = (okey | bit [0x0009]);				/* R11 is also used (it should be set anyway, but...)	*/
							writeif (okey);								/* save new regs used							*/
						}												/* of end of non-recursive proc with stack		*/
						if ((( prctyp             < 3 )					/* if models a,b,c								*/
						&&  ((cond & p_swap)     != 0))					/* and code swaps								*/
						||  (( prctyp             >=3 )					/* or if model D								*/
						&&  ((cond & p_swapscon) != 0)					/* and scon swaps								*/
						&&  ( anyscon            != 0))					/* and some there								*/
						||  ((debug_on           != 0 )					/* or if debugging								*/
						&&  ( prctyp             >=3 )					/* on model D									*/
						&&  ((cond & p_swap)     != 0)))				/* and code swaps								*/
							set_keyjto (key + proc_noswap, -1);
					}													/* of during first iteration only				*/
						
					/* copy NOSWAP bit info into proc_dswp very first	*/
					/* iteration only								*/
					
					if ((iter == 0) && (! (jumps & 1)))/* during first iteration only					*/
						set_keyloc (key + proc_dswp, readif());			/* get NOSWAP bitmap for data (set by pass1)	*/
						
					/* else copy proc_regs info into proc_regs on the	*/
					/* next pass,  remembering it lies on top of	*/
					/* proc_dswp									*/
					
					else {
						
						readif();										/* skip NOSWAP bitmap for data					*/
						
						if ((iter == 1) && (! (jumps & 1)))				/* during second iteration only					*/
							set_keyloc (key + proc_regs, (okey&reg_mask) | (swap_key != 0));
						else {
							
							/* Keep track of whether we are defining a proc inside */
							/* a swapping proc.  Compiler some times takes a while */
							/* to decide if a proc swaps or not.                   */
							
							if ((swap_key != 0) != (keyloc(key + proc_regs)&proc_inside))
							{
								set_keyloc (key + proc_regs,
								keyloc(key + proc_regs) ^ proc_inside);
								altf = 1;
								if (debug & 1) new_loc = (new_loc | 0x0100);
							}
						}
					}
						
					if (active & 1 || ((keyflag (key) & abit) != 0)) {	/* end of a called proc (it may NOT be active at the end)	*/
						if (active & 1) {								/* Only do this if we're still active at this point	*/
							if ((iter != 0) || jumps & 1)				/* after KEYLOC is set up						*/
								cur_loc = cur_loc + exit_len (keyloc (key + proc_stack));	/* account for exit code						*/
								
							if (jumps & 1)								/* don't look at proc registers until JUMPS (PROC_DSWP lives here until then)	*/
								okey = numbits (keyloc (key + proc_regs) & reg_mask);	/* see how many registers saved					*/
							else okey = 0;								/* this number is rather irrelevant (but must match proc defn)	*/
								
							if ((okey == 0) || ((okey > cutoff) && ((prctyp >= 2)/* if LREG can/should be called					*/
							|| (((cond & p_swap) == 0) && (! (device_driver (key) & 1)))))) {
								if ((okey == 0) && (prctyp >= 2)) cur_loc = cur_loc + 1;	/* ModelC needs an extra word (for predecrement) to return with no regs saved	*/
								cur_loc = cur_loc + 1;
							}
							else {										/* must load registers and return				*/
								cur_loc = cur_loc + okey + 2;
								if (prctyp < 2) cur_loc = cur_loc + 2;	/* two extra words for Models A & B				*/
							}
							if (jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
						}												/* of active									*/
							
						if (jumps & 1 && ((cond & p_swap) != 0)) {		/* swappable proc? (only set after JUMPS) (KEY had better equal SWAP_KEY here)	*/
							
							/* Compute actual # of words of object code */
							/* that will be generated for this proc:    */
							
							if (prctyp < 3)								/* if model a,b,c ...							*/
								cur_loc = cur_loc - swap_area;
								
							/* if swapping proc - save size of object code only	*/
							/* to compute where string constants are stored	*/
							
							if (swaps & 1) {
								set_keyjto(key + proc_objsz, cur_loc);
							}
								
							cur_loc = cur_loc + swapscon - 1;			/* add in swapping scon to get total object length	*/
							
							/* For model d, figure out where this proc will */
							/* sit in ext memory.  Bump up if needed so     */
							/* it will not straddle a page:                 */
							
							if (prctyp >= 3) {
								
								boundary = keyloc (key + proc_regs) & proc_bound;
								temp = shl(swap_total,8) | swap_words;	/* object code will start here in ext memory	*/
								
								/* If proc bumps into next page,  then move */
								/* up to page boundary:                     */
								
								if (_ILT_((temp + cur_loc), temp))
								{
									
									swap_total = (swap_total + 256) & (fixed) 0xFF00;
									swap_words = 64;					/* start proc at word 64						*/
									
									/* set bit to force this proc to bound */
									set_keyloc (key + proc_regs,
									(keyloc (key + proc_regs) | proc_bound));
								}
									
								/* else if proc was forced to a page boundary last	*/
								/* time through,  then bring it down to prior	*/
								/* page only if there would be some extra room,	*/
								/* otherwise pass3 can oscilate here has the	*/
								/* object code changes length:					*/
								
								else if (boundary != 0)
								{
									
									/* clear the boundary bit if there would be */
									/* more than 500 free words on this page    */
									/* after the proc was moved back here:      */
									
									if (_ILT_((temp + cur_loc), (-500)))
									{
										/* clear boundary bit */
										set_keyloc (key + proc_regs,
										(keyloc (key + proc_regs) & ~(proc_bound)));
										altf = 1;
										if (debug & 1) new_loc = (new_loc | 0x0080);
									}
										
									/* else keep this proc bumped up to the next	*/
									/* page even if it does not really need to		*/
									/* be:											*/
									
									else {
										swap_total = (swap_total + 256) & (fixed) 0xFF00;
										swap_words = 64;				/* start proc at word 64 on						*/
									}
								}
									
								if ((swinfo_ptr != 0)					/* if swinfo storage available					*/
								&& (_ILT_(swap_procs, swinfo_max)))		/* and this id will fit							*/
								{
									if (swapscon == 1)					/* equal 1 means NO STORAGE						*/
									{
										/* save away current location (<>0) for */
										/* optimization check:                  */
										set_swinfo(2*swap_procs,
										shl(swap_total,8) | swap_words);
									}
									else set_swinfo(2*swap_procs, 0);	/* can not skip r.swap if proc has any strings/data - store 0	*/
									/* but always save away current page # for this swap proc */
									_write_62((swinfo(2*swap_procs+1) & (fixed) 0xFF00)
									| shr(swap_total,8));
								}
									
							}
								
							if (swaps & 1) {							/* write out lookup table during SWAPS iteration	*/
								writeovr (swap_total);					/* relative starting sector number				*/
								writeovr (swap_words);					/* word offset in starting sector				*/
								
								writeovr (cur_loc);						/* total word length (includes scon length)		*/
								if (prctyp >= 3)						/* write out scon len for model d and after		*/
									writeovr (swapscon - 1);			/* amount of string constant & data array swapped	*/
								optimize_clrswap();						/* clear out swapping scon pointer list			*/
							}
								
							swap_words = swap_words + cur_loc;			/* number of words so far (minus shl(SWAP_TOTAL, 8))	*/
							swap_total = swap_total + shr(swap_words, 8);	/* keep track of total number of sectors (perhaps minus one)	*/
							swap_words = (swap_words & 0x00FF);			/* make this the number of words in the final sector	*/
							
							if (prctyp < 3) {							/* model a, b, c								*/
								if (_IGT_(cur_loc, swap_size))
									swap_size = cur_loc;				/* find the largest overlay						*/
							}
							else {										/* modeld - only scons swap						*/
								if (_IGT_(swapscon - 1, swap_size))
									swap_size = swapscon - 1;			/* keep track of largest scon area				*/
							}
								
							/* keep track of largest scon area for final iteration */
							/* error checks:                                       */
							
							if (_IGT_(swapscon - 1, swap_scon))
								swap_scon = swapscon - 1;
								
							cur_loc  = swap_loc;						/* reset CUR.LOC								*/
							swap_key = 0;								/* reset SWAP_KEY since we're no longer in a swappable proc	*/
						}												/* of swappable proc							*/
							
						active = 0;										/* not active after end of proc					*/
					}													/* of end of a called proc						*/
					else if ((tosskey == key) && (tossram != 0)) {		/* end of an uncalled proc - toss ram			*/
						delram (tossram, sram - tossram);				/* delete this block of ram						*/
						
						if ((cond & p_recursive) == 0)					/* if not a recursive proc						*/
							delram (tosstemp, stemp - tosstemp);		/* delete temps as well							*/
					}
						
					tosskey = 0;				/* no longer tossing							*/
					current_key = ppop();		/* restore key of previous proc					*/
					break;
				}								/* of end of proc defn							*/
					
				/*  $$Iterative optimization phase (cont.):		*/
				
				case 13:
				{								/* process when statement						*/
					key = readif();				/* pick up key									*/
					optimize_keych (key + when_keys);	/* check on all N keys							*/
					okey = numbits (keyloc (key + proc_regs) & reg_mask);	/* get reg save bit word						*/
					
					whenlevel = whenlevel + 1;
					
					if (prctyp >= 2) cur_loc = cur_loc + 1;				/* one word for Model C entry					*/
					if (okey != 0) {									/* must save regs								*/
						cur_loc = cur_loc + okey;
						if (prctyp < 2) cur_loc = cur_loc + 2;			/* two extra words for Models A & B				*/
					}
					active = 1;					/* when statements are always active			*/
					if (jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					break;
				}
					
				case 14:
				{								/* process the end of a when statement			*/
					key = readif();				/* get key										*/
					optimize_keych (key + when_keys);	/* be paranoid about pass 2 - check on all N keys again	*/
					
					whenlevel = whenlevel - 1;
					
					ocl = readif();				/* get regs used								*/
					set_keyloc (key + proc_regs, ocl & reg_mask);	/* save regs used								*/
					okey = numbits (ocl);		/* get number of regs used						*/
					
					if (prctyp >= 2) cur_loc = cur_loc + 1;				/* Model C needs to predecrement stack pointer	*/
					if (okey != 0) {									/* must reload regs								*/
						cur_loc = cur_loc + okey;
						if (prctyp < 2) cur_loc = cur_loc + 3;			/* two extra words for Models A & B				*/
					}
					cur_loc = cur_loc + 1;		/* one word return								*/
					if (active & 1 && jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					active = 0;					/* inactive code always follows when statement	*/
					break;
				}
					
				case 15:
				{								/* emit string constant pointer					*/
					static	fixed	it_swaps;
					
					readif();					/* ignore destination							*/
					
					if ((swaps & 1 && (swap_key != 0))/* check for swapping scon						*/
					&& ((keyflag(swap_key + proc_flags) & p_swapscon) != 0)) {	/* check for swapping of scon's & data			*/
						writeif (optimize_adjswap (readif(), swaps, &(it_swaps)));	/* update if swapping							*/
						readif(); writeif (it_swaps);					/* store whether it swaps						*/
					}													/* of check for swapping scon					*/
					else {												/* ignore record this time						*/
						readif(); readif();
					}
						
					cur_loc = cur_loc + 2;
					if (active & 1 && jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					break;
				}								/* of emit string constant pointer				*/
					
				case 16:
				{								/* addr of fixed array parameter				*/
					key = readif();				/* pick up defining procedure's key				*/
					ocl = readif();				/* and formal parameter number					*/
					
					if ((! (jumps & 1)) && (ocl < 16) && ((keyjto (key + proc_noswap) & bit [ocl]) == 0))
					{													/* if we think this formal parameter can swap	*/
						set_keyjto (key + proc_noswap, keyjto (key + proc_noswap) | bit [ocl]);	/* flag it as non-swappable						*/
						altf = 1;										/* we need to keep looking						*/
						if (debug & 1) new_swapscon = (new_swapscon | 2);
					}
					break;
				}								/* of addr of fixed array parameter				*/
					
				case 17:
				{								/* sequence number record						*/
					readif();					/* ignore for now (many of these - SKIPRECORD takes too long)	*/
					break;
				}								/* of sequence (line) number record				*/
					
				case 18:
				{								/* symdef or symref (passed for linker)			*/
					skiprecord (key);			/* none of these								*/
					break;
				}								/* of symdef or symref							*/
					
				case 19:
				{								/* module statement								*/
					skiprecord (key);			/* none of these								*/
					break;
				}								/* of module statement							*/
					
				case 20:
				{								/* library statement							*/
					skiprecord (key);			/* none of these								*/
					break;
				}								/* of library statement							*/
					
				case 21:
				{								/* insert statement								*/
					
					if (shr(insert_, 4) >= insmax)
					{
						skiprecord (key);								/* skip the record until we process jumps to jumps	*/
																		/* stack will be reset at start of next pass */
					}
						
					else if (! (jumps & 1))
						skiprecord (key);								/* skip the record until we process jumps to jumps	*/
						
					else {												/* we are now processing jumps to jumps			*/
						if (shr(delete_map [shr(insert_, 4)], (insert_ & 0x000F)) & 1) {	/* if we should delete this insert statement	*/
							writeif (et_ign);							/* delete record type							*/
							okey = (readif() & 0x00FF); writeif (et_ign);	/* get record length and delete					*/
							for (_upper0 = okey, okey = 1; okey <= _upper0; okey++) {readif(); writeif (et_ign); }	/* delete the rest of the record				*/
								
							delete_map [shr(insert_, 4)] = (delete_map [shr(insert_, 4)] ^ bit [insert_ & 0x000F]);	/* turn off the delete flag						*/
							deleted = deleted + 1;						/* we've deleted another insert record			*/
						}												/* of delete this record						*/
						else {											/* don't delete this record						*/
							key = readif();								/* get the record length						*/
							
							if (key != 0) {								/* if this is a start of insert file			*/
								for (_upper0 = key, key = 1; key <= _upper0; key++) {	/* skip over the record							*/
									readif();
								}
								ipush (proc_def_found);
								ipush (cur_loc          );
								ipush (insert_ - deleted);				/* save info in case we need to delete it later	*/
								
								proc_def_found = false;
							}											/* of start of insert							*/
							else {										/* this is an end of insert file record			*/
								key = ipop();							/* get starting insert file's statement number	*/
								
								if (cur_loc == ipop() && !proc_def_found) {	/* if there's no code in this insert file, get rid of the reference	*/
									delete_map [shr(key, 4)] = (delete_map [shr(key, 4)] | bit [key & 0x000F]);	/* delete the starting record					*/
									delete_map [shr(insert_ - deleted, 4)] = (delete_map [shr(insert_ - deleted, 4)] | bit [(insert_ - deleted) & 0x000F]);	/* and the ending record						*/
								}										/* of if there's no code						*/
								
								proc_def_found = ipop();
							}											/* of end of insert								*/
						}												/* of don't delete this record					*/
							
						insert_ = insert_ + 1;							/* we've found another insert statement			*/
					}													/* of we're deleting jumps to jumps				*/
					break;
				}								/* of insert statement							*/
					
				case 22:
				{								/* library definition (library follows immediately in the intermediate file)	*/
					key = readif();				/* get library number							*/
					b_key [key] = cur_loc;		/* update the object base for this library		*/
					break;
				}
					
				case 23:
				{								/* external symbol reference					*/
					readif();					/* skip over it (many of these - SKIPRECORD takes too long)	*/
					readif();
					break;
				}								/* of external symbol reference					*/
					
				case 24:
				{								/* et.cas = emit object code for do case		*/
					if ((swap_key  != 0)
					&& (prctyp    >= 3))
						cur_loc = cur_loc + 2;
					else cur_loc = cur_loc + 3;
					if (active & 1 && jumps & 1 && (! (swaps & 1))) optimize_clearstkptr();	/* clear out stacked label list					*/
					break;
				}
					
				case 25:
				{								/* et.atr - alternate key transfer				*/
					/* Insert file to process alternate jump instruction */
					
					cond = readif();			/* get condition code							*/
					key = readif();				/* get key to jump to							*/
					lcl = cur_loc;				/* save CUR.LOC before this instruction (for jump to jump deletion)	*/
					
					if (active & 1) {									/* for active code only							*/
						if (key != 0) {									/* ignore clobbered keys (from jmp . => clobbered below if DIST = 10000)	*/
							optimize_altch (key);						/* make sure in range							*/
							
							if (jumps & 1) {							/* follow jumps to jumps only during JUMPS		*/
								dist = 0;								/* this is infinite loop detector				*/
								okey = altjto (key);					/* see if this location jumps somewhere			*/
								
								while ((okey != 0) && (dist < 10000)) {	/* after 10000, assume we are hung up			*/
									set_altflag (key, altflag (key) & (~ abit));	/* this label is now unknown					*/
									key = okey;							/* make this the new destination				*/
									okey = altjto (key);
									dist = dist + 1;
								}
									
								if (dist == 10000) key = 0;				/* detect infinite loop - key of 0 = jmp .		*/
									
								if (dist != 0) {						/* if we changed the key						*/
									writeif (key);						/* write out new key							*/
									altf = 1;							/* we've made an alteration						*/
									if (debug & 1) new_loc = (new_loc | 1);
								}
							}											/* of if JUMPS									*/
								
							if (key != 0) {								/* if key isn't clobbered (i.e., it's jumped to)	*/
								okey = altflag (key);					/* pick up bits									*/
								
								if ((okey & abit) == 0) {				/* see if we need to make it active				*/
									set_altflag (key, okey | abit);		/* indicate active								*/
									altf = 1;							/* we've made an alteration						*/
									if (debug & 1) new_active = (new_active | 1);
								}
							}											/* of it's jumped to							*/
						}												/* of non-clobbered key							*/
							
						ocl = readif();									/* get old estimated location					*/
						if (ocl != cur_loc) {							/* check if loc changed from last pass			*/
							writeif (cur_loc);							/* write out new location						*/
							if (jumps & 1) {							/* only bother to re-iterate if JUMPS			*/
								altf = 1;								/* the IF changed								*/
								if (debug & 1) new_loc = (new_loc | 2);
							}
						}												/* of altered loc								*/
							
						if ((iter == 0) && (! (jumps & 1))) cur_loc = cur_loc + 2;	/* assume 2 before JUMPS						*/
						else if (skip_opt != 0)         cur_loc = cur_loc + 2;
						else if (key == 0) cur_loc = cur_loc + 1;		/* detect jmp .									*/
						else {											/* see if jump instruction fits in one word		*/
							if ((okey & dbit) != 0)						/* already defined this pass					*/
								dist = altloc (key) - cur_loc - 1;		/* compute distance based on current iteration	*/
							else {										/* forward reference jump						*/
								if (ocl == -1) dist = -32768;			/* if inactive last pass, assume long jump		*/
								else {									/* was active last pass							*/
									dist = altloc (key) - ocl - 1;		/* forward distance (use values from previous pass)	*/
									if (dist == -1) dist = 0;			/* -1 means previously deleted jmp .+1			*/
								}										/* of was active last pass						*/
							}											/* of forward reference jump					*/
								
							if ((dist != 0) || (!(jumps & 1))) {		/* 0 means jmp .+1 - delete instr - but only after all active code has been identified	*/
								if (emitt (dist) & 1)					/* if fits in immediate field					*/
									cur_loc = cur_loc + 1;				/* then 1 word									*/
								else cur_loc = cur_loc + 2;				/* else 2 words									*/
							}
						}												/* of checking if jump instruction fits in one word	*/
					}													/* of active									*/
					else {												/* if we're not active							*/
						if (readif() != -1) writeif (-1);				/* get old loc - mark inactive if not already marked	*/
					}													/* of not active								*/
						
					if (cond == b_tra) {								/* unconditional transfer?						*/
						if (jumps & 1 && (! (swaps & 1)))				/* if deleting jumps to jumps					*/
						{
							while (altstkptr != 0) {					/* see if any labels at this location (unstack label defs)	*/
								ocl = altpop(); okey = altpop();		/* get location, its key						*/
								
								if (ocl == lcl)							/* see if instruction at this label is jump (LCL is set to CUR.LOC at top)	*/
									set_altjto (okey, key);				/* indicate jmp to jmp							*/
							}
							stkptr = 0;									/* cannot optimize jumps to jumps of different key types	*/
						}
							
						active = 0;										/* inactive code follows unconditional transfers	*/
					}													/* of unconditional transfer					*/
					break;
				}
					
				case 26:
				{								/* et.ald - alternate label definition			*/
					/* Pass 3 file for alternate key label definition */
					
					key = readif();
					optimize_altch (key);		/* check limits									*/
					okey = altflag (key);		/* pick up flags								*/
					
					if ((skip_opt & 1)			/* skip of optimization desired					*/
					&& (iter ==  0)				/* and first iteration							*/
					&& (! (jumps & 1)))			/* of not jumps									*/
						okey = okey | abit;
						
					if (active & 1) {									/* if we're active								*/
						if ((okey & abit) == 0) {						/* and not already active						*/
							okey = (okey | abit);						/* mark as active								*/
							altf = 1;
							if (debug & 1) new_active = (new_active | 0x0008);
						}
					}													/* of active									*/
					else active = ((okey & abit) != 0);					/* if not active, assume activity of label		*/      
						
					if (((okey & pbit) == 0)	/* if is a lobel (VS proc)						*/
					|| ((altflag(key + proc_flags) & p_swap) == 0))/* or a non-swapping proc						*/
					{
						if (altloc (key) != cur_loc) {					/* if stored location doesn't match newest location	*/
							set_altloc (key, cur_loc);					/* save current location of the label			*/
							if (jumps & 1) {							/* only bother to re-iterate if jumps			*/
								altf = 1;
								if (debug & 1) new_loc = (new_loc | 0x0010);
							}
						}												/* of stored location doesn't match newest		*/
					}													/* of normal proc								*/
						
					set_altflag (key, okey | dbit);	/* indicate is defined							*/
					
					if (jumps & 1 && (! (swaps & 1))) {					/* stack jump to jump detectors only if detecting jumps to jumps	*/
						altpush (key);
						altpush (cur_loc);								/* stack these to check next instr				*/
					}
					break;
				}
					
			}									/* of do case									*/
				
			key = readif();						/* get next record type							*/
		}										/* of stop at eof								*/
			
		b_key [next_lib + 1] = cur_loc;			/* update end of object pointer					*/
		
		clear_keyflag (dbit);					/* clear defined bit from KEYFLAG array for next pass	*/
		
		/* find out end of object code - this is where swap area */
		/* will go (if needed)                                   */
		
		if (swap_area != cur_loc) {
			if (jumps & 1) {					/* only bother to re-iterate if in JUMPS		*/
				altf = 1;						/* don't stop until it stabilizes				*/
				if (debug & 1) new_loc = (new_loc | 0x0040);
			}
		}
		swap_area = cur_loc;					/* save estimate								*/
		
		if (swaps & 1) {						/* if we just did the swap table pass			*/
			
			/* make SWAP_TOTAL total number of sectors (it's also OVSECLN) */
			
			if (swap_words != 0) swap_total = swap_total + 1;

			if (altf != 0)
				er_sys ((char *) "Optimization error (two SWAP passes)", (char *) "optimize");
		}
			
		if ((! (altf & 1)) && (! (jumps & 1))) {	/* if no more alterations and we haven't optimized the jumps to jumps	*/
			jumps = 1;							/* make sure we optimize jumps to jumps now		*/
			altf  = 1;							/* assume we will make changes					*/
			iter  = 0;							/* and start counting again						*/
		}
		else {									/* not yet ready for or past jump to jumps		*/
			if ((! (altf & 1)) && jumps & 1 && (! (swaps & 1)) && (iter != 0)) {	/* if no more alterations, but jumps have been optimized	*/
				swaps = 1;						/* next pass, we'll look at swaps				*/
				if (swap_procs != 0) altf = 1;	/* if any procs swap, make sure we go around again	*/
			}
			iter = iter + 1;					/* increment loop counter						*/
		}
			
		if (debug & 1) {
			print("%s%6d%6d%6d%6d%6d%6d\n", "jumps, iter, swaps, loc, active, swapscon", jumps, iter, swaps, new_loc, new_active, new_swapscon);
			new_loc = 0; new_active = 0; new_swapscon = 0;
		}
			
	}											/* of iterative loop							*/
		
	stkptr    = 0;								/* clean out the stack when we're done			*/
	altstkptr = 0;
	
	resetif ();									/* reset interfile for final pass				*/
}


/* procedure to bind a routine pointed to by global variable 'L.RTP' */
	
static	void	e_rtp_e_rtpsub(					/* recursive procedure for emitting object pointers	*/
	fixed	l_rtp)
{
    fixed			_upper0;
	static	fixed	loca[51];					/* location to patch							*/
	static	fixed	rout[51];					/* and which routine to patch it to				*/
	static	fixed	top, bot, rloc;				/* top and bottom pointer to loca and rout		*/
	static	fixed	i, j, k;
	static	fixed	plp;						/* patch list pointer							*/
	
	if (r [l_rtp] != 0) return;					/* routine is in there							*/
		
	rloc = rfbuf [l_rtp];						/* get pointer to routine						*/
	plp = rfbuf [rloc];							/* get pointer to patch list					*/
	i = rfbuf [plp];							/* pick up word from patch list					*/
	bot = top;									/* and save pointer to where our group started	*/
	while (i != 0) {							/* and copy patch list onto stack				*/
		loca [top] = i;							/* save location to patch						*/
		rout [top] = rfbuf [plp + 1];			/* and get l.rtp pointer for routine to call	*/
		top = top + 1; plp = plp + 2;			/* increment stack pointer and plist pointer	*/
		i = rfbuf [plp];						/* and check for more of patch list				*/
	}											/* of copy of patch list						*/
		
	/*
	      .   We have scanned the patch-up list for this routine from the
	      .   run time package file.   We will now proceed to emit
	      .   all routines called by this one, so that pointers to other
	      .   subroutines can be updated during the emission
	      .   of the l.rtp routine.
	      */
	
	/* now sort list, so we can dump out */
	
	i = 1;
	while (i & 1) {								/* do until scan produced no errors				*/
		i = 0;									/* reset here									*/
		for (_upper0 = top - 2, j = bot; j <= _upper0; j++) {	/* and search list								*/
			if (loca [j] > loca [j + 1]) {		/* if out of order, then bubble					*/
				k = loca [j]; loca [j] = loca [j + 1]; loca [j + 1] = k;
				k = rout [j]; rout [j] = rout [j + 1]; rout [j + 1] = k;
				i = 1;							/* and set flag to continue sorting				*/
			}
		}
	}											/* of sort of list								*/
		
	/* $$Routine E.RTP (cont):
	      .
	      .   We have examined the runtime package patch list, and have emitted
	      .   all routines that are called by the routine in equations.
	      .
	      .   Now emit the final routine, patching up all pointers to the
	      .   subroutines that are called from the main one.
	      */
	
	i = bot;
	while (i < top) {							/* and do until end								*/
		if (r [rout [i]] == 0) {				/* must emit routine if not emitted yet			*/
			push (bot); push (top); push (i);
			push (rloc); push (l_rtp);			/* save info									*/
			l_rtp = rout [i];					/* routine to emit								*/
			e_rtp_e_rtpsub(l_rtp);				/* and recursivedly call ourselves to emit routine	*/
			l_rtp = pop(); rloc = pop();
			i = pop(); top = pop(); bot = pop();	/* restore important variables from recursion	*/
		}										/* of must emit routine							*/
		i = i + 1;								/* check next one								*/
	}											/* of emit loop									*/
		
	/* now emit our specified routine,  patching up locations */
	
	r [l_rtp] = objlng;							/* location of routine							*/
	plp = rfbuf [rloc];							/* restore pointer to patch list				*/
	j = bot;									/* and get pointer to bottom for comparison		*/
	for (i = rloc + 1; i < plp; i++) {			/* and emit entire routine, patching up locations	*/
		k = rfbuf [i];							/* and get rtp word now							*/
		if (j != top) {							/* if not at top yet,  then see if this is a patch up location	*/
			if (i == loca [j]) {				/* is patch up - get pointer and increment		*/
				k = r [rout [j]];				/* get our own pointer to where routine is		*/
				j = j + 1;						/* and move on to next patch location			*/
			}
		}
			
		/* patch model C interrupt routine if needed	*/
		
		if ((l_rtp  == l_in1)					/* if emitting interrupt routine				*/
		&& (prctyp == 2    )					/* for modelc									*/
		&& (r[l_swap] != 0))					/* and swapping code included					*/
		{										/* then patch save of mam/mal					*/
			if (i == (rfbuf[l_in2]))
				k = (shl(b_md | b_ibt | 0x000A,8)) | 0x0031;	/* d61 to MR12D									*/
			if (i == (rfbuf[l_in2]+1))
				k = (shl(b_md | b_ibt | 0x000A,8)) | 0x0030;	/* d60 to MR12D									*/
			if (i == (rfbuf[l_in3]))
				k = (shl(0x0030,8)) | (b_md | b_ibt | 0x000A);	/* Mr12i to d60									*/
			if (i == (rfbuf[l_in3]+1))
				k = (shl(0x0031,8)) | (b_md | b_ibt | 0x000A);	/* Mr12i to d61									*/
		}
			
		writeobj (k);							/* and write out word from file or routine location if patch	*/
		rtpcode = rtpcode + 1;					/* count amount of rtp							*/
	}											/* of copy loop									*/
		
	top = bot;									/* reset top to bottom for next call to emit, so we use same space	*/
}												/* end of our internal procedure				*/
	
/* $$Routine E.RTP:
.
.   E.RTP is called to bind a stock run time package routine into the
.   output object file.   Available object routines are stored in the
.   run time package file.   The first N words of the file form a transfer
.   vector that is used to find the object code start location for each
.   routine.  Each routine is identified by its transfer vector location.
.
.   The object code for the routine that is stored in the run time package
.   file is slightly formatted - information as to the length of the rtp
.   routine, plus any pointers to any other routines that are to be included, 
.   are in the run time package routine object area.
.
.   E.RTP is called with a transfer vector location.  The object code for
.   the specified routine is bound out to the object file (WIF) and then
.   any other rtp routines that are called as subroutines by this one
.   are also written out.
*/

static	void	e_rtp(							/* bind a rtp routine into the intermediate file	*/
	fixed	l_rtp)
	
{
	e_rtp_e_rtpsub(l_rtp);						/* call the subrotine							*/
}
	
/* $$Bind in rtp routines, when table, and assign special ram locations:
.     We have completed the iterative optimization phase of pass3 of
.     the compiler.   We will now bind in the necessary run time package
.     routines, compute the locations of where things will go in
.     memory, and prepare for the final object code generation.
*/

static	fixed	whentab, device_table, rcvdp, inv, sbrwp, seekp;	/* special ram areas							*/

static	void	bindrtp()						/* bind in the rtp (uses KEYLOC)				*/
{
	static	fixed	devptr;						/* device driver pointer						*/
	static	fixed	i;
	
	r [l_str_data] = adjscon (r [l_str_data]);	/* set actual length of scon/data (should equal OBJLNG - INTROLEN!!!)	*/
	
	for (i = 0; i < rtp_ptrs; i++) {
		if (rtpsubs [i] != 0) e_rtp (i);		/* if called, put it there						*/
	}
		
	if ((r [l_flags] & enable_flag) != 0)		/* if 'enable' statement - bind in				*/
		e_rtp (l_in1);							/* bind in interrupt routine					*/
		
	devptr = 0;									/* look for any device drivers					*/
	for (i = 0; i < devtablen; i++) {			/* search the table								*/
		if (device_label [i] != 0) devptr = 1;	/* if we have a driver, remember it				*/
	}
		
	obj_base = objlng;							/* object code will go here						*/
	if (devptr & 1) obj_base = obj_base + devtablen;	/* watch for device driver table				*/
	if ((r [l_flags] & (enable_flag | when_flag)) != 0) obj_base = obj_base + whentablen;	/* watch out for WHEN table						*/
	swap_area = obj_base + swap_area;			/* swap area at end of object code (SWAP_AREA better equal CUR.LOC before calculation)	*/
	vstrt = swap_area + swap_size;				/* default variable area at end of swap area	*/
	ram = adjram (ram);							/* adjust ram for any deleted procedures		*/
	if ((_ILT_(vstrt, 8192)) && (_ILT_(ram, 8001))) vstrt = 8192;	/* put at 8k if short pgm						*/
		
	if (r [l_ovram] != 0) {						/* user specified								*/
		if (_ILT_(r [l_ovram], obj_base + cur_loc)) {	/* memory conflict								*/
			print("\n");
			print("Memory conflict - starting RAM address is too low.  For this\n");
			print("%s", "program, the RAM area must be at or above location ");
			print("%6d%s\n", (obj_base + cur_loc), " decimal.");
			exit(-1);
		}
		vstrt = r [l_ovram];					/* move it to here								*/
	}
		
	if (devptr & 1) {							/* need to emit the device driver table			*/
		device_table = objlng;					/* device driver table goes here				*/
		for (i = 0; i < devtablen; i++) {		/* emit table									*/
			if (device_label [i] != 0) {		/* if we have a driver							*/
				if (i < devdrivers) {			/* if this is a device driver pointer			*/
					devptr = device_table + devtablen + keyloc (device_label [i]);	/* pick up routine pointer						*/
					if ((r [l_flags] & (enable_flag | when_flag)) != 0)/* if 'enable' or 'when', bind in table			*/
						devptr = devptr + whentablen;					/* watch out for WHEN table						*/
				}
				else devptr = vstrt + adjram (device_label [i]) - 1;	/* else pick up variable location				*/
				writeobj (devptr);				/* write out pointer							*/
			}									/* of if we have a driver						*/
			else writeobj (0);					/* no driver available							*/
		}
		rtpcode = rtpcode + devtablen;			/* Devtablen more rtp words						*/
	}
		
	if ((r [l_flags] & (enable_flag | when_flag)) != 0) {	/* if 'enable' or 'when', bind in table			*/
		whentab = objlng;						/* when table goes here							*/
		for (i = 0; i < whentablen; i++) {
			if (r [l_icell + i] != 0)
				writeobj (keyloc (r [l_icell + i]) + whentab + whentablen);	/* emit ptr to rtn								*/
			else writeobj (0);					/* else no when statement						*/
		}
		rtpcode = rtpcode + whentablen;			/* Whentablen more rtp words					*/
	}
		
	if (r [l_swap] != 0) {						/* if swappable procs							*/
		swap_ram = vstrt + ram - 1;				/* point to ram reserved for swapping			*/
		ram = ram + 4;							/* allocate it									*/
	}
	if (((r [l_flags] & enable_flag) != 0) || (r [l_ich] != 0)) {	/* if enable or rcvdchar used					*/
		rcvdp = vstrt + ram - 1;
		ram = ram + 1;
	}
	if (r [l_ipr] != 0) {						/* check for user input statement				*/
		inv = vstrt + ram - 1;					/* allocate input buffer						*/
		ram = ram + 67;
	}
	if ((r [l_sbr] | r [l_sbw]) != 0) {
		sbrwp = vstrt + ram - 1;				/* allocate special word pair					*/
		ram = ram + 2;
	}
	if (r [l_see] != 0) {
		seekp = vstrt + ram - 1;
		ram = ram + 4;
	}
}
	
	/* The following procedure returns the memory location associated with a
	.  given symbol in the linker symbol table. */
	
static	fixed	gensym_adj_loc(					/* return memory location associated with a symbol	*/
	fixed	symbol)								/* the symbol to find the address of			*/
{
	static	fixed	type;						/* that symbol's type							*/
	
	type = type_sym (symbol);					/* get the symbol type							*/
	
	if (type == t_proc) {						/* procedure									*/
		if ((keyflag (loc_sym (symbol) + proc_flags) & p_swap) != 0)/* swapping proc?								*/
			return (keyloc (loc_sym (symbol)));	/* yes, return ID								*/
		else return (obj_base + keyloc (loc_sym (symbol)));	/* no, return absolute address					*/
	}											/* of procedure									*/
	else if (type == t_label) return (obj_base + keyloc (loc_sym (symbol)));	/* label										*/
	else if ((type == t_fxdata) || (type == t_fldata)) return (introlen + adj_scon (loc_sym (symbol)));	/* data											*/
	else return (vstrt + adj_ram (loc_sym (symbol)) - 1);	/* info											*/
		
}

static	fixed	gensym_print_nam(				/* print out source ref symbol only				*/
	fixed	this_ptr)
{
	fixed	i,j;
	fixed	fname_byte_len = 0;
	fixed	line_no;
	char	the_name[256];
	
	_write_60(source_ptr + shr(this_ptr, 4));	/* set memory pointers							*/
	_write_61(shl(this_ptr, 4));
	
	line_no        = _read_63();
	fname_byte_len = _read_63();
			
	if (fname_byte_len >= 255)					/* limit to avoid sub errors on trashed files 	*/
		fname_byte_len = 255;
		
	for (i = 0; i < fname_byte_len; i += 2)
	{
		j = _read_63();
		
		the_name[i  ] = (char) (shr(j, 8));
		the_name[i+1] = (char) (j & 0xFF);
	}
	
	the_name[fname_byte_len] = 0;				/* in case trailing null wasn't sent 			*/
	
	pstring (the_name);

	i = fname_byte_len;							/* return num of chars printed					*/
	
	return (i);
}

static	fixed	gensym_print_ref(				/* print out source ref of a symbol				*/
	fixed	this_ptr)
{
	fixed i,j;
		
	fixed	fname_byte_len = 0;
	
	fixed	line_no;
	char	the_name[256];
	
	_write_60(source_ptr + shr(this_ptr, 4));	/* set memory pointers							*/
	_write_61(shl(this_ptr, 4));
	
	line_no        = _read_63();
	fname_byte_len = _read_63();
			
	if (fname_byte_len >= 255)				/* limit to avoid sub errors on trashed files 	*/
		fname_byte_len = 255;
		
	for (i = 0; i < fname_byte_len; i += 2)
	{
		j = _read_63();
		
		the_name[i  ] = (char) (shr(j, 8));
		the_name[i+1] = (char) (j & 0xFF);
	}
	
	the_name[fname_byte_len] = 0;	/* in case trailing null wasn't sent */
	
	pstring ((char *) "\"open '");			/* "open 'xyz:xyz';line 10"			 */
	pstring (the_name  );
	pstring ((char *) "'; line" );
	unum    (line_no   );
	pstring ((char *) "\""      );

	i = fname_byte_len + 7 + 7 + 1;	/* return num of chars printed		*/
	
	return (i);
}

	/* The following procedure outputs an entry from the symbol table.
	.  If HEADER is one, a header is output before the symbol. */
	
static	void	gensym_print_sym(				/* print out a symbol table entry				*/
	fixed	symbol, 							/* the symbol to output							*/
	fixed	header)								/* 0 = don't print header, 1 = print header		*/
{
	static	fixed	type;						/* record type									*/
	static	fixed	i,j;
	
	if (header & 1) {							/* print header?								*/
		eol();
	}
		
	pastring (_location_(get_sym (ptr_sym (symbol))));	/* print symbol name							*/
	
	pstring ((char *) " ");
	
	for (i = stable (ptr_sym (symbol)) + 1; i < 40; i++) {
		pstring ((char *) " ");
	}
	
	if (source_ref (symbol))
	{
		i = gensym_print_ref(source_ref(symbol));	/* print out the symbol reference			*/

		while (i < 32)
			{pstring ((char *) " "); i++;}
	}
	
	else
	{
		unum (lnum_sym (symbol));				/* print line number							*/
	
		for (i=0; i<32; i++)
			pstring ((char *) " ");
	}
	
	pstring ((char *) "  ");								/* tab to position 57							*/
	type = type_sym (symbol);					/* print type									*/
	if (type == t_var)   pstring ((char *) "fixed      ");
	else if (type == t_arr)   pstring ((char *) "fixed array");
	else if (type == t_fvar)  pstring ((char *) "floating   ");
	else if (type == t_farr)  pstring ((char *) "float array");
	else if (type == t_fxdata)  pstring ((char *) "fixed data ");
	else if (type == t_fldata) pstring ((char *) "float data ");
	else if (type == t_proc)  {
		if ((keyflag (loc_sym (symbol) + proc_flags) & p_swap) != 0)/* swapping proc?								*/
			pstring ((char *) "swap proc  ");
		else pstring ((char *) "procedure  ");
	}
	else if (type == t_label) pstring ((char *) "label      ");
	else { unum (type); pstring ((char *) "     "); }
		
	pstring ((char *) "  ");								/* tab to position 70							*/
	onum (gensym_adj_loc (symbol));				/* output address								*/
	
	pstring ((char *) "   "); onum (store_sym (symbol));
	
	if ((prctyp >= 3) && type == t_proc && ((keyflag (loc_sym (symbol) + proc_flags) & p_swap) != 0))
	{
		pstring ((char *) "   page: "); onum ((swinfo(2*gensym_adj_loc (symbol)+1)&255) << 8);
		pstring ((char *) "   loc: " ); onum ((swinfo(2*gensym_adj_loc (symbol)  )    )     );
	}
	
	eol();
	
}
	
	/* $$Gensym - sort and output the symbol table:
	.
	.   The following procedure sorts the symbol table using a simple
	.   insertion sort.  The table is sorted in-place by actually sorting
	.   an array of pointers which are passed to this routine.  The table
	.   is sorted by defining library in ascending order.  Any conflicts
	.   are resolved by a subsort on the symbol name (again in ascending
	.   order). */
	
static	void	gensym_s_sort(					/* sort the symbol table by defining library	*/
	fixed	symbols)							/* number of symbols defined					*/
{
    fixed			_upper0;
	static	fixed	temp;
	static	fixed	i, j;
	
	for (_upper0 = symbols - 2, i = 0; i <= _upper0; i++) {	/* sort all symbols								*/
		if ((deflib_sym (sort_sym (i)) > deflib_sym (sort_sym (i + 1)))/* are the next two elements out of order?		*/
		|| ((deflib_sym (sort_sym (i)) == deflib_sym (sort_sym (i + 1)))/* check the subfield when equal				*/
		&& (astrcmp (_location_(get_sym (ptr_sym (sort_sym (i)))), _location_(get_sym (ptr_sym (sort_sym (i + 1))))) > 0)))
		{										/* yes, put them in order						*/
			temp = sort_sym (i + 1);			/* save the next element's value				*/
			j = i;								/* start moving earlier elements up				*/
			
			while ((j >= 0) && ((deflib_sym (sort_sym (j)) > deflib_sym (temp))/* stop when TEMP fits in						*/
			|| ((deflib_sym (sort_sym (j)) == deflib_sym (temp))/* check the subfield when equal				*/
			&& (astrcmp (_location_(get_sym (ptr_sym (sort_sym (j)))), _location_(get_sym (ptr_sym (temp)))) > 0)))) {
				set_sort_sym (j + 1, sort_sym (j));	/* move the element up							*/
				j = j - 1;						/* look at previous element						*/
			}
				
			set_sort_sym (j + 1, temp);			/* place element in its proper place			*/
		}
	}
		
}
	
/* $$Generate the symbol table: */

static	void	gensym()						/* output symbol table (uses KEYLOC and KEYFLAG)	*/
{
	static	fixed	type;						/* type of current symbol						*/
	static	fixed	more_symbols;				/* set to one if there are more symbols in this library	*/
	static	fixed	header;						/* set to one to print symbol header			*/
	static	fixed	i, j;
	
	for (i = 0; i < nextsym; i++) {				/* initialize symbol table pointers				*/
		set_sort_sym (i, i);
	}
		
	gensym_s_sort (nextsym);					/* sort the symbol table (by defining library, then name)	*/
	
	eol();										/* print header									*/
	pstring ((char *) "Symbol table:"); eol();
	
	/* First print out sym-only references */
	
	if (num_sym_only)
	{
		eol();
		pstring ((char *) "Non-public procedure source references:");
		eol();
		eol();
		
		for (j = 0; j < num_sym_only; j++)
		{
			fixed	where_nam = sym_only_nam(j);
			fixed	where_ref = sym_only_ref(j);
		
			i = gensym_print_nam(where_nam);
		
			pstring ((char *) " ");
			
			for (; i < 39; i++)
				pstring ((char *) " ");
				
		 	gensym_print_ref(where_ref);
			eol();
		}
	}
	
	j = 0;										/* initialize symbol table index				*/
	
	for (i = 1; i <= next_lib; i++) {			/* loop over the libraries						*/
		eol();									/* print information about the library			*/
		pstring ((char *) "Library:  "); pastring(_location_(&(lib_name [name_lib [i]]))); eol();
		
		pstring ((char *) "Extents:  data:  ");
		
		if (adj_scon (b_scon [i]) != adj_scon (b_scon [i + 1]))/* make sure there's data						*/
		{ 	onum (introlen + adj_scon (b_scon [i])); pstring ((char *) " to "); onum (introlen + adj_scon (b_scon [i + 1]) - 1); }
		else pstring ((char *) "none"); eol();
		
		pstring ((char *) "        object:  ");
		
		if (b_key [i] != b_key [i + 1])			/* make sure there's object						*/
		{ 	onum (obj_base + b_key [i]); pstring ((char *) " to "); onum (obj_base + b_key [i + 1] - 1); }
		else pstring ((char *) "none"); eol();
		
		pstring ((char *) "           ram:  ");
		
		if (adj_ram (b_ram [i]) != adj_ram (b_ram [i + 1]))/* make sure there's ram						*/
		{ 	onum (vstrt + adj_ram (b_ram [i])); pstring ((char *) " to "); onum (vstrt + adj_ram (b_ram [i + 1]) - 1); }
		else pstring ((char *) "none"); eol();
		
		more_symbols = 1;						/* assume there are some symbols in this library	*/
		header = 1;								/* print header before next symbol				*/
		
		while ((j < nextsym) && more_symbols & 1) {	/* output all symbols from this library			*/
			if (deflib_sym (sort_sym (j)) == i)	/* is this symbol in this library?				*/
			{									/* yes, output it								*/
				type = type_sym (sort_sym (j));	/* get type of symbol							*/
				
				if ((type == t_proc) || (type == t_label)) {	/* make sure either is active before outputting	*/
					if ((keyflag (loc_sym (sort_sym (j))) & abit) != 0) {	/* if active, output it							*/
						gensym_print_sym (sort_sym (j), header);		/* print out the symbol							*/
						header = 0;										/* don't output header next time around			*/
					}
				}								/* of make sure it's active						*/
				else {							/* not a key - just output it					*/
					gensym_print_sym (sort_sym (j), header);	/* print out the symbol							*/
					header = 0;					/* don't output header next time around			*/
				}
					
				j = j + 1;						/* look at next symbol							*/
			}									/* of output it									*/
			else more_symbols = 0;				/* no more symbols for this library				*/
		}										/* of output all symbols						*/
	}											/* of loop over the libraries					*/
		
	pstring ((char *) "*** End of symbol table ***"); eol();
	
}
	
/* $$Generate final object file:
.
.     Read through intermediate file and generate object code. */

static	fixed	count;							/* count of sequence numbers output on this line	*/
static	fixed	indent;							/* current sequence table indent level			*/
static	fixed	swap_key;						/* key of current swappable proc				*/

static	void	create_object_line(				/* indent the line								*/
	fixed	indent)								/* amount to indent								*/
{
	static	fixed	i;
	
   	for (i = 1; i <= indent; i++) {				/* indent										*/
		pstring ((char *) "   ");
	}
}
	
static	void	create_object_print_sequence(	/* add a line number/address to the sequence table	*/
	fixed	lnum, 								/* line number									*/
	fixed	addr)								/* address										*/
	
{
	if (count != 0)								/* are we at the start of the line?				*/
		pstring ((char *) "    ");						/* no, tab over									*/
	else create_object_line (indent);			/* yes, indent if necessary						*/
		
	unum (lnum); pstring ((char *) "  "); onum (addr);	/* output next sequence table entry				*/
	count = count + 1;							/* we've now output one more number				*/
	
	if (count == 4)								/* are we at the end of the line?				*/
	{											/* yes, skip									*/
		eol();
		count = 0;								/* reset counter								*/
	}
}
	
static	void	create_object_emit_page_0_call(
	fixed	page_0_loc)
	
{
	/* Model A or B: */
	
	if (prctyp < 2) {							/* model A, B									*/
		xmit (b_rs + b_ibt + b_pc - 1, 1);		/* r16i to d1									*/
		writeobj (page_0_loc);					/* and emit absolute pointer					*/
	}
		
	/* Calling an rtp from external memory on model D:	*/
	
	else if ((swap_key != 0)
	&&     (prctyp   >= 3))
	{
		xmit (b_ms + b_ibt + b_pc, b_rd + 0x000D);	/* pci to R15									*/
		writeobj (page_0_loc);					/* and emit absolute pointer					*/
		xmit (b_is + rfbuf[l_pgsw], b_ca + b_tra);
	}
		
	/* calling an rtp from model C,  or from an internal	*/
	/* memory Model D routine:						*/
	
	else {
		xmit (b_ms + b_ibt + b_pc, b_ca + b_tra);	/* pci to atra for Model C and later			*/
		writeobj (page_0_loc);					/* and emit absolute pointer					*/
	}
}
	
static	void	create_object(					/* generate object code (uses KEYLOC, KEYJTO, and KEYFLAG)	*/
	fixed	scon[], 							/* table to store swapping SCON for each proc	*/
	fixed	skip_opt)							/* True if we skipped dead code analysis (also skips short jumps)	*/
{
    fixed			_upper0;
	static	fixed	swapscon;					/* pointer into SCON (length of scon stored in SCON)	*/
	static	fixed	swap_key_id;
	static	fixed	swapdata;					/* True if copy data records should swap		*/
	static	long	start_of_swap;				/* starting pos of swap proc for phase error	*/
	static	fixed	swap_start;					/* starting cur.loc for this swap proc			*/
	static	fixed	active;						/* True if we're processing active code			*/
	static	fixed	key;						/* current key value							*/
	static	fixed	okey;						/* old key value								*/
	static	fixed	ocl;						/* old CUR.LOC									*/
	static	fixed	dist;						/* jump distance								*/
	static	fixed	cond;						/* jump condition								*/
	static	fixed	des;						/* destination of variable pointer, etc.		*/
	static	fixed	vloc;						/* variable location							*/
	static	fixed	swap;						/* P.Swap bit for this proc						*/
	static	fixed	sp;							/* stack pointer (r15 for models A & B, r12 for model C & later)	*/
	static	fixed	p_lnum;						/* previous sequence number read in				*/
	static	fixed	p_addr;						/* previous address read in						*/
	static	fixed	header;						/* True if we should output the sequence header before the next sequence number	*/
	static	fixed	i;
	static	fixed	temp;
	static	fixed	p0_obj;						/* obj.base for page 0 (internal memory) code	*/
	static	fixed	current_page;
	static	fixed	new_page;
	
	static	fixed	swap_too_large = 1;			/* True if the swap area is too large			*/
	static	fixed	swap_too_small = 0;			/* True if the swap area is too small			*/
	
	static	fixed	always_process[] = {6, et_lde, et_pen, et_ins, et_ldf, et_seq, et_ald};	/* records to always process					*/
	static	fixed	not_always[et_max + 1];		/* False if this record should always be processed	*/
	
	blockset (not_always, et_max + 1, 1);		/* assume no records are always processed		*/
	for (_upper0 = always_process [0], key = 1; key <= _upper0; key++) {	/* set up NOT_ALWAYS							*/
		not_always [always_process [key]] = 0;	/* always process this type of record			*/
	}

	out_file = (FILE *)	open_able_file_for_output(object_file_name, 'EXEC', 'SNCL');	
		
	if ((r [l_flags] & symtab_flag) != 0) {		/* print sequence number table header			*/
		pstring ((char *) "Sequence number table:");
		header = 1;								/* output header if we find a sequence number	*/
		indent = 0;								/* no indentation yet							*/
		count = 0;								/* no numbers across the page yet				*/
		p_addr = -1;							/* invalidate previous address					*/
	}
		
	if (prctyp < 2) sp = 0x000D; else sp = 0x000A;	/* assign proper stack pointer					*/
		
	p0_obj = obj_base;							/* save start of object base of internal memory	*/
	
	if (show_progress || show_p3_progress)
		printf("XPL Tool: Pass 3: Generating code\n");
	
	iteration = iteration + 1;					/* for stat printout							*/
	active = 1;									/* we're initially known to be active			*/
	
	key = readif();								/* get first word of file						*/
	while (key != 0) {							/* and wait until eof							*/
		if (key != et_cpy) swapdata = 0;		/* only swap copy data records which immediately follow the data definition (which sets this flag)	*/
			
		if ((key & literal_mask) != 0) {		/* literal word									*/
			if (active & 1) writeobj (key);		/* just write it to the object					*/
		}
			
		else if ((! (active & 1)) && not_always [key] & 1)/* active code?									*/
			skiprecord (key);					/* no, skip the record							*/
			
		else switch (key - 1) {					/* branch on record type						*/
			case 0:
				writeobj (readif());			/* write out literal							*/
				
				break;
			case 1:
			{									/* jump instruction								*/
				cond = readif();
				key = readif();
				ocl = readif();
				
				if (key == 0) dist = -1;		/* this is jmp .								*/
				else {							/* compute distance to jump						*/
					dist = keyloc (key) - ocl - 1;	/* compute relative distance (OCL had better equal CUR.LOC here or phase error!)	*/
					if (((keyflag (key) & dbit) == 0) && (dist == -1)) dist = 0;	/* deleted jmp .+1 instruction					*/
				}
					
				if (dist != 0) {				/* dist of 0 are tossed							*/
					if ((! (skip_opt & 1)) && emitt (dist) & 1)/* if fits in immediate (and didn't skip optimization)	*/
						xmit (b_is + (dist & b_imsk), b_cr + cond);		/* immed cond rel								*/
					else {												/* else use full word							*/
						xmit (b_ms + b_ibt + b_pc, b_ca + cond);		/* else abs										*/
						writeobj (obj_base + keyloc (key));				/* emit abs pointer								*/
					}
				}								/* of not dist of 0 (not jmp .)					*/
					
				if (cond == b_tra) active = 0;	/* no longer active for unconditional transfers	*/
				break;
			}									/* of jump										*/
				
			case 2:
			{									/* user proc call								*/
				okey = readif();				/* get length of record							*/
				key = readif();					/* get key										*/
				for (_upper0 = okey - 1, okey = 1; okey <= _upper0; okey++) {readif(); }	/* skip rest of record							*/
				swap = (keyflag (key + proc_flags) & p_swap);	/* get SWAP bit of called proc					*/
				vloc = keyloc (key);			/* pick up address of called proc (or id # of swapping proc if it swaps)	*/
				
				/* if calling a swap procedure, see how many instructions */
				/* it will need:                                          */
				
				if (swap != 0) {				/* calling a swap proc							*/
					
					if (swap_key == key)		/* if call to itself, only						*/
					{													/* emit same page jump							*/
						if (prctyp < 3)									/* if model A, B, C								*/
							create_object_emit_page_0_call(swap_area);
						else {
							/* jump back to top of this page.                */
							xmit (b_ms + b_ibt + b_pc, b_ca + b_tra);	/* pci to atra for Model C and later			*/
							writeobj (swap_start);
						}
					}
						
					else if ((prctyp     >= 3)	/* if on model d ...							*/
					&&      (swinfo_ptr != 0)	/* if swinfo storage available					*/
					&&      (_ILT_(vloc, swinfo_max))/* and info for id we are calling is available	*/
					&&      (swinfo(2*vloc) != 0)/* and proc we are calling uses no string/data storage	*/
					&&      ((shr(swinfo(2*vloc+1),8) < 4)/* takes 3 or fewer register arguments			*/
					||        ((swap_key != 0)	/* or we are in a swap proc now					*/
					&&        (_ILT_(swap_key_id, swinfo_max))/* and info for current procedure is available	*/
					&&        ((swinfo(2*vloc+1)&255) == (swinfo(2*swap_key_id+1)&255))))/* and it resides on the same page as the one we are calling	*/
					&&      (! (debug_on & 1)))	/* don't do this if debug flag on				*/
					{
						
						new_page = swinfo(vloc*2+1)&255;				/* get page proc we are calling is on			*/
						
						if (swap_key == 0)								/* if we are on page 0,  must look up			*/
						{												/* where swap file is in memory					*/
							/* pci to r15    */xmit (b_ms + b_ibt + b_pc, b_rd + 0x000D);	/* pci to r15 - pick up pointer to canonical location	*/
							/* swapram       */writeobj (swap_ram);		/* pointer to canonical loc						*/
							/* mr15 to r3    */xmit (b_ms + 0x000D, b_ad + 0x0003);	/* mr15 t0 load 3								*/
							/* im0  to bsor3 */xmit (b_is, b_bsor + 0x0003);	/* im(0) to bsor3								*/
							if (new_page != 0) {
								if (emitt (new_page) & 1)				/* will the page # fit in one word?				*/
								/* page to  add3 */     xmit (b_is + (new_page & b_imsk), b_ad + b_add + 0x0003);
								else {									/* need to use long immediate					*/
									xmit (b_ms + b_ibt + b_pc, b_ad + b_add + 0x0003);	/* pci to add3									*/
									writeobj (new_page);				/* send location								*/
								}
							}
							/* pci to r15									*/   xmit (b_ms + b_ibt + b_pc, b_rd + 0x000D);	/* pci to R15									*/
							/* location     */writeobj (swinfo(2*vloc));
							/* jump pgx     */xmit (b_is + rfbuf[l_pgx], b_ca + b_tra);
						}
							
						else {											/* else we can do relative transfer				*/
							
							current_page = swinfo(swap_key_id*2+1)&255;
							
							/* if on same page, transfer with simple jump */
							/* else use page switch code                  */
							
							if (current_page != new_page)				/* if different page							*/
							{
								if (emitt(new_page - current_page) & 1)
								{
									xmit (b_is + ((new_page - current_page)&b_imsk), b_rd + 0x0003);	/* page delta to r3								*/
								}
								else {									/* need to use long immediate					*/
									xmit (b_ms + b_ibt + b_pc, b_rd + 0x0003);	/* pci to mrI - send ID to loc					*/
									writeobj (new_page - current_page);	/* send page difference							*/
								}
								xmit (b_ms + b_ibt + b_pc, b_rd + 0x000D);	/* pci to R15									*/
								writeobj (swinfo(2*vloc));
								xmit (b_is + rfbuf[l_pgx], b_ca + b_tra);
							}
							else {
								xmit (b_ms + b_ibt + b_pc, b_ca + b_tra);	/* pci to atra for Model C and later			*/
								writeobj (swinfo(vloc*2));
							}
						}
					}
						
					/* else if models c or d, store swap id # in r15	*/
					/* and jump to low memory:						*/
					
					else if (prctyp >= 2) {								/* models c, d									*/
						if (emitt (vloc) & 1)							/* will the ID fit in one word?					*/
							xmit (b_is + (vloc & b_imsk), b_rd + 0x000D);	/* im(ID) to R15								*/
						else {											/* need to use long immediate					*/
							xmit (b_ms + b_ibt + b_pc, b_rd + 0x000D);	/* pci to R15									*/
							writeobj (vloc);							/* send location								*/
						}
						xmit (b_is + swpe, b_ca + b_tra);
					}
						
					/* else store proc id# in memory (models a,b)	*/
					/* and call r.swap								*/
					else {												/* call a normal swap proc						*/
						xmit (b_ms + b_ibt + b_pc, b_rd + 0x000A);		/* pci to r12 - pick up pointer to canonical location	*/
						writeobj (swap_ram + 1);						/* pointer to canonical loc						*/
						
						if (emitt (vloc) & 1)							/* will the ID fit in one word?					*/
							xmit (b_is + (vloc & b_imsk), b_md + 0x000A);	/* im(ID) to mr12 - send ID to loc				*/
						else {											/* need to use long immediate					*/
							xmit (b_ms + b_ibt + b_pc, b_md + 0x000A);	/* pci to mr12 - send ID to loc					*/
							writeobj (vloc);							/* send location								*/
						}
						create_object_emit_page_0_call(r[l_swap]);
					}
				}
					
				else if ((swap_key   != 0)		/* else if  within a swap proc					*/
				&&     (prctyp     >= 3)		/* residing in external memory					*/
				&&     (keyloc (key + proc_regs) & 1))/* that calls a proc defined within				*/
				{								/* proc_inside									*/         /* the swap proc:                   */
					xmit (b_ms + b_ibt + b_pc, b_ca + b_tra);	/* pci to atra for Model C and later			*/
					writeobj (vloc + obj_base);
				}
					
				else create_object_emit_page_0_call(vloc + p0_obj);
				break;
			}
				
			case 3:
			{														/* rtp call									*/
				fixed	where = readif();							/* get what to call							*/
				
				if (_IGE_(where, l_interp))							/* interpreter call							*/
				{
					where -= l_interp;								/* get abs interpreter code					*/

					if (emitt (where) & 1)							/* will fit into immed field?				*/
						xmit (b_is + (where & b_imsk), b_cr+b_tnv);	/* immed to destination						*/
					else {											/* full word								*/
						xmit (b_ms + b_ibt + b_pc, b_cr+b_tnv);		/* pc and i to dest							*/
						writeobj (where);						
					}												/* full word								*/
				}
				
				else
					create_object_emit_page_0_call(r[where]);
				
				break;
			}
				
			case 4:
			{									/* variable pointer								*/
				des = readif();					/* dest											*/
				i = readif();					/* storage class								*/
				vloc = readif();				/* relative variable distance					*/
				
				switch (i) {					/* branch on storage class						*/
					case 0:
					{													/* static										*/
						xmit (b_ms + b_ibt + b_pc, des);				/* full scale									*/
						writeobj (vstrt + adjram (vloc) - 1);			/* -1 here because first vloc was 1				*/
						break;
					}													/* of static									*/
						
					case 1:
					{													/* automatic									*/
						xmit (b_rs + sp, des);							/* move stack pointer to destination			*/
						des = b_ad + b_add + (des & b_amsk);			/* convert destination to ADD instruction		*/
						
						if (emitt (vloc) & 1)							/* if fits in immediate field					*/
							xmit (b_is + (vloc & b_imsk), des);			/* add in stack offset							*/
						else {											/* must use long immediate (PCI)				*/
							xmit (b_ms + b_ibt + b_pc, des);			/* add stack offset to SP						*/
							writeobj (vloc);							/* write out stack offset						*/
						}
						break;
					}													/* of automatic									*/
				}								/* of storage class								*/
				break;
			}									/* of variable pointer							*/
				
			case 5:
			{									/* object pointer								*/
				key = readif();					/* get key										*/
				
				/* for Model D,  if in swapping procedure, emit a jump */
				/* to the correct case.                                */
				if ((swap_key  != 0)
				&& (prctyp    >= 3))
				{
					xmit (b_ms + b_ibt + b_pc, b_ca + b_tra);	/* pci to atra for Model D in swapping procedures	*/
				}
				writeobj (keyloc (key) + obj_base);	/* write out									*/
				break;
			}
				
			case 6:
			{									/* label def									*/
				key = readif();
				okey = keyflag (key);			/* pick up current flag bits					*/
				set_keyflag (key, okey | dbit);	/* indicate defined now							*/
				active = (active | ((okey & abit) != 0));	/* assume active state of label					*/
				break;
			}
				
			/* $$Final code generation (cont.):				*/
			
			case 7:
			{									/* data definition								*/
				readif();						/* skip over key								*/
				swapdata = ((swap_key != 0) & readif());	/* set swap data flag for following COPY DATA record(s)	*/
				break;
			}									/* data definition								*/
				
			case 8:
			{									/* copy data									*/
				if (swapdata & 1) for (_upper0 = readif(), key = 1; key <= _upper0; key++) {	/* if this data should swap						*/
					if (_IGE_(swapscon, swap_scon)) er_sys ((char *) "too much swapping scon", (char *) "create_object");
					scon [swapscon] = readif();	/* save next word								*/
					swapscon = swapscon + 1;
				}								/* of swapping data								*/
				else skiprecord (key);			/* if not swapping, just skip it				*/
				break;
			}									/* copy data									*/
				
			case 9:
			{									/* copy scon									*/
				key = readif() - 2;				/* get length of scon record					*/
				readif();						/* skip over key								*/
				okey = readif();				/* see if it swaps								*/
				for (_upper0 = key, key = 1; key <= _upper0; key++) {	/* read all scon								*/
					i = readif();				/* read the next word							*/
					if ((swap_key != 0) && okey & 1) {					/* if swapping, save it							*/
						if (_IGE_(swapscon, swap_scon)) er_sys ((char *) "too much swapping scon", (char *) "create_object");
						scon [swapscon] = i;							/* save it										*/
						swapscon = swapscon + 1;
					}
				}								/* of read all scon								*/
				break;
			}									/* copy scon									*/
				
			case 10:
			{									/* ignore record								*/
				break;
			}
				
			case 11:
			{									/* proc def record - store registers			*/
				run_host_environment_250();
				
				i = readif() & 255;				/* get length of record (for non-recursive procs, it had better be 4)	*/
				key = readif();					/* get key										*/
				readif(); readif();				/* ignore start ram and start temp				*/
				cond = readif();				/* get procedure attributes						*/
				ocl = keyloc (key + proc_regs) & reg_mask;	/* pick up regs used							*/
				
				if ((cond & p_swap) != 0) {		/* if a swappable procedure						*/
					redirect_object = 1;		/* redirect object code to overlay				*/
					swap_key = key;				/* save which swappable proc we're within (to optimize recursive calls)	*/
					swap_key_id = keyloc(key);
					if (prctyp >= 3) {									/* for model d - bump page, emit code			*/
						
						/* bump start of swap procedure up to next page bound */
						/* if modeld and swap proc would extend across page.  */
						/* Look at the bit stored in KEYJTO during the final  */
						/* optimization pass:                                 */
						
						if ((keyloc(key + proc_regs) & proc_bound) != 0)
						{
							swap_start = (fixed) (ovr_length & 0xFFFF);	
							
							/* emit zeroes to fill out to page boundary */
							while (swap_start != 0) {
								writeobj (0);
								swap_start = swap_start + 1;
							}
								
							/* For Model D compilations,  emit 64 words at the  */
							/* front of swap file that contains the object code */
							/* used to switch pages:                            */
							
							for (_upper0 = rfbuf [l_sta] + 64, temp = rfbuf [l_sta] + 1; temp <= _upper0; temp++) {	/* copy 64 words								*/
								writeobj(rfbuf[temp]);
							}
								
						}												/* of set to page boundary						*/
						
						swap_start = (fixed) (ovr_length & 0xFFFF);		/* calculate cur.loc for this swapping proc		*/
						obj_base = swap_start;							/* object pointers relative to 0 for external memory code	*/
					}													/* of prctyp >= 3								*/
					
					start_of_swap = ovr_length;
				}								/* of if swappable proc							*/
					
				if (prctyp >= 2)				/* on Model C and later, also save return (D10)	*/
					xmit (0x0008, b_md + b_ibt + sp);	/* d10 to mrSPd									*/
					
				okey = numbits (ocl);			/* get number to save							*/
				
				if ((okey > cutoff)				/* too many regs and Model C or (not swappable and not a device driver)?	*/
				&& ((prctyp >= 2) || (((cond & p_swap) == 0) && (! (device_driver (key) & 1)))))
					xmit (b_is + sreg, b_ca);	/* call save reg								*/
				else if (okey != 0) saveregs (ocl);
				enter_proc (i - 4, keyloc (key + proc_stack), cond, sp);	/* enter the procedure							*/
				break;
			}									/* of proc def record							*/
				
			case 12:
			{									/* et.pen - end of procedure definition			*/
				i = et_length [key];			/* get length of record							*/
				key = readif();					/* get key										*/
				
				for (_upper0 = i - 1, i = 1; i <= _upper0; i++) {	/* skip rest of record							*/
					readif();
				}
					
				if (active & 1 || ((keyflag (key) & abit) != 0)) {	/* if active or started out as active			*/
					swap = (keyflag (key + proc_flags) & p_swap);	/* save swap bit for this proc					*/
					
					if (active & 1) {									/* only do the following for active code		*/
						exit_proc (keyloc (key + proc_stack), sp);		/* emit exit code								*/
						
						ocl = keyloc (key + proc_regs) & reg_mask;		/* get regs used								*/
						okey = numbits (ocl);							/* get number of regs							*/
						
						if ((okey > cutoff)								/* too many regs and Model C or (not swappable and not a device driver)?	*/
						&& ((prctyp >= 2) || ((swap == 0) && (! (device_driver (key) & 1)))))
							xmit (b_is + lreg, b_ca);					/* load all regs and ret						*/
						else {											/* load regs and return							*/
							if (prctyp >= 2) xmit (b_rs + b_ibt + sp, b_ca + b_tnv);	/* increment rSP on Model C & Later (rSPi to atnv)	*/
							if (okey > 0) loadregs (ocl);				/* load regs									*/
							if (prctyp < 2) xmit (b_is + retn, b_ca + b_tra);	/* and return									*/
							else xmit (b_ms + sp, b_ca + b_tra);		/* mrSP to atra (return on model C & later)		*/
						}
					}													/* of active code								*/
						
					if (swap != 0) {									/* swappable proc? (KEY had better equal SWAP_KEY)	*/
						okey = (fixed) (ovr_length - start_of_swap);	/* determine word length of swapping proc		*/
						
						if (okey != (keyjto (key + proc_objsz)))		/* if swapping proc has a different length than what we got optimizing	*/
							er_sys ((char *) "swapping proc phase error", (char *) "create_object");
							
						okey = okey + swapscon;							/* add in swapping scon to get full length		*/
						
						if (prctyp < 3) {								/* model a,b,c - swap area contains code + strings	*/
							if (_IGT_(okey, swap_size)) swap_too_small = 1;	/* if swapping proc is larger than swap area	*/
							if (okey == swap_size) swap_too_large = 0;	/* if we have a match, we're okay				*/
						}
						else {											/* model d - swap area is size of string area	*/
							if (_IGT_(swapscon, swap_size)) swap_too_small = 1;	/* if swapping proc is larger than swap area	*/
							if (swapscon == swap_size) swap_too_large = 0;	/* if we have a match, we're okay				*/
							obj_base = p0_obj;							/* restore object base							*/
						}
							
						for (i = 0; i < swapscon; i++) {				/* emit the swapping scon for this proc			*/
							writeobj (scon [i]);
						}
							
						swapscon = 0;									/* no more swapping scon						*/
						redirect_object = 0;							/* redirect object code back to object file		*/
						swap_key = 0;									/* no longer in swappable proc					*/
					}													/* of swappable proc							*/
				}								/* of active or started out as active			*/
					
				active = 0;						/* no longer active here						*/
				break;
			}
				
			case 13:
			{									/* when statement								*/
				key = readif();
				ocl = keyloc (key + proc_regs) & reg_mask;	/* get regs used								*/
				okey = numbits (ocl);			/* get number									*/
				
				if (prctyp >= 2)				/* on Model C and later, save return (D10)		*/
					xmit (0x0008, b_md + b_ibt + 0x000A);	/* d10 to mr12d									*/
				if (okey != 0) saveregs (ocl);	/* save these regs								*/
				break;
			}
				
			case 14:
			{									/* end of when statement						*/
				key = readif();					/* get key										*/
				readif();
				ocl = keyloc (key + proc_regs) & reg_mask;	/* get regs used								*/
				okey = numbits (ocl);			/* get number used								*/
				
				if (prctyp >= 2) xmit (b_rs + b_ibt + 0x000A, b_ca + b_tnv);	/* increment r12 on Model C & Later (r12i to atnv)	*/
				if (okey != 0) loadregs (ocl);	/* load regs									*/
				if (prctyp < 2) xmit (b_ms + 0x000D, b_ca + b_tra);	/* return from interrupt						*/
				else xmit (b_ms + 0x000A, b_ca + b_tra);	/* mr12 to atra (return on model C & later)		*/
				active = 0;						/* no longer active now							*/
				break;
			}
				
			case 15:
			{									/* emit string pointer							*/
				okey = readif();				/* get destination								*/
				key = readif();					/* and location - relative to start				*/
				
				xmit (b_ms + b_ibt + b_pc, okey);	/* Pci to <dest>								*/
				
				if (readif() & 1 && (swap_key != 0)) {	/* if swapped scon								*/
					if (prctyp < 3)				/* model a,b,c - string data is after swapping object code	*/
						writeobj (swap_area + keyjto (swap_key + proc_objsz) + key - 1);	/* pointer is in swap area after proc			*/
					else writeobj (swap_area + key - 1);				/* string is in swap area						*/
				}
				else writeobj (introlen + adjscon (key));	/* emit normal pointer							*/
				break;
			}
				
			/* $$Final code generation (cont.):				*/
			
			case 16:
			{									/* addr of fixed array parameter				*/
				skiprecord (key);				/* skip it										*/
				break;
			}									/* of addr										*/
				
			case 17:
			{									/* sequence number								*/
				key = readif();					/* get sequence number							*/
				
				if ((r [l_flags] & symtab_flag) != 0) {					/* if we're to dump stats						*/
					if (header & 1) {									/* output header if necessary					*/
						eol(); create_object_line (indent);				/* indent if necessary							*/
						pstring ((char *) "number  address   number  address   number  address   number  address"); eol();
						header = 0;										/* don't output header again					*/
					}
						
					if (p_addr != -1)									/* if address info is available					*/
						create_object_print_sequence (p_lnum, p_addr);	/* then print it...								*/
						
					p_lnum = key;										/* save line number printed						*/
					
					if (redirect_object)								/* if going to swap file						*/
						p_addr = (fixed) (ovr_length & 0xFFFF);			/* then executable address is here				*/
					else												/* at least for model d...						*/
						p_addr = objlng;
				}
				break;
			}									/* of sequence number							*/
				
			case 18:
			{									/* symbol reference or definition				*/
				skiprecord (key);				/* skip over									*/
				break;
			}									/* of symref or symdef							*/
				
			case 19:
			{									/* module statement								*/
				skiprecord (key);				/* skip over									*/
				break;
			}									/* of module statement							*/
				
			case 20:
			{									/* library statement							*/
				skiprecord (key);				/* skip over									*/
				break;
			}									/* of library statement							*/
				
			case 21:
			{									/* insert statement								*/
				key = readif();					/* get record length							*/
  				
  				for (i = 1; i <= key; i++) {	/* get insert filename							*/
					name [i - 1] = readif();
				}
					
				if ((r [l_flags] & symtab_flag) != 0) {						/* are we dumping stats?						*/
					if (key != 0) {											/* if there's a new insert file					*/
						
						if (p_addr != -1)									/* print sequence entry for last line of prior	*/
							create_object_print_sequence (p_lnum, p_addr);	/* file...										*/
						
						if (count != 0) eol();								/* tidy up after the last segment				*/
							
						eol(); create_object_line (indent);					/* output insert file header for sequence table	*/
						pstring ((char *) "Insert:  "); pastring (name);
						pstring ((char *) " (object base: "); onum (objlng); pstring ((char *) ")");
						
						header = 1;											/* output header next time around				*/
						indent = indent + 1;								/* and indent some more							*/
						count = 0;											/* we're starting all over again				*/
						p_addr = -1;										/* invalidate last address						*/
					}														/* of new insert file							*/
					else {													/* end of last insert file						*/
						if (p_addr != -1)									/* if address info is available					*/
							create_object_print_sequence (p_lnum, p_addr);	/* then print it...								*/

						if (count != 0) eol();								/* tidy up after the last segment				*/
							
						header = 1;											/* output header next time around				*/
						indent = indent - 1;								/* outdent some									*/
						create_object_line (indent); pstring ((char *) "*** End of insert (object end: "); onum (objlng - 1); pstring ((char *) ")"); eol();
						
						count = 0;											/* starting all over							*/
						p_addr = -1;										/* invalidate last address						*/
					}														/* of insert file								*/
				}								/* of dumping stats								*/
				break;
			}									/* of insert statement							*/
				
			case 22:
			{									/* library definition							*/
				i = readif();					/* get the library number						*/
				
				if ((r [l_flags] & symtab_flag) != 0) {	/* are we dumping stats?						*/
					if (p_addr != -1)									/* if address info is available					*/
						create_object_print_sequence (p_lnum, p_addr);	/* then print it...								*/
					
					if (count != 0) eol();								/* tidy up after the last library				*/
						
					eol(); eol();				/* output library header for sequence table		*/
					pstring ((char *) "Library:  "); pastring (_location_(&(lib_name [name_lib [i]])));
					pstring ((char *) " (object base: "); onum (objlng); pstring ((char *) ")");
					
					header = 1;					/* output header next time around				*/
					indent = 1;					/* and indent									*/
					count = 0;					/* we're starting all over again				*/
					p_addr = -1;				/* invalidate previous address					*/
				}
				break;
			}									/* of library definition						*/
				
			case 23:
			{									/* external symbol reference					*/
				skiprecord (key);
				break;
			}									/* of external symbol reference					*/
				
			case 24:
			{									/* et.cas = emit object code for do case		*/
				if ((swap_key  != 0)
				&& (prctyp    >= 3))
				{								/* model d swapping procedure					*/
					xmit (b_rs + 0x0000, b_ad + b_add + 0x0000);	/* r0 to ADD0 - get stride of 2 for jump table	*/
					xmit (b_rs + 0x0000, b_cr              );	/* r0 to rtra									*/
				}
				else {							/* model a,b,c, model D internal memory only	*/
					xmit (b_rs + b_pc, b_ad + b_add + 0x0000);	/* Pc to ADD0 - make the case # relative to the PC	*/
					xmit (b_is + 2, b_ad + b_add + 0x0000);	/* im(2) to ADD0 - compensate for 2 ins needed for PC-relative addressing	*/
					xmit (b_ms + 0x0000, b_ca + b_tra);	/* Mr0 to ATRA - transfer (indirectly) to the correct statement	*/
				}
				break;
			}
				
			case 25:
			{									/* jump to alternate key instruction			*/
				cond = readif();
				key = readif();
				ocl = readif();
				
				if (key == 0) dist = -1;		/* this is jmp .								*/
				else {							/* compute distance to jump						*/
					dist = altloc (key) - ocl - 1;	/* compute relative distance (OCL had better equal CUR.LOC here or phase error!)	*/
					if (((altflag (key) & dbit) == 0) && (dist == -1)) dist = 0;	/* deleted jmp .+1 instruction					*/
				}
					
				if (dist != 0) {				/* dist of 0 are tossed							*/
					if ((! (skip_opt & 1)) && emitt (dist) & 1)/* if fits in immediate (and didn't skip optimization)	*/
						xmit (b_is + (dist & b_imsk), b_cr + cond);		/* immed cond rel								*/
					else {												/* else use full word							*/
						xmit (b_ms + b_ibt + b_pc, b_ca + cond);		/* else abs										*/
						writeobj (obj_base + altloc (key));				/* emit abs pointer								*/
					}
				}								/* of not dist of 0 (not jmp .)					*/
					
				if (cond == b_tra) active = 0;	/* no longer active for unconditional transfers	*/
				break;
			}									/* of alternate jump							*/
				
			case 26:
			{									/* alternate key label def						*/
				key = readif();
				okey = altflag (key);			/* pick up current flag bits					*/
				set_altflag (key, okey | dbit);	/* indicate defined now							*/
				active = (active | ((okey & abit) != 0));	/* assume active state of label					*/
				break;
			}
				
		}										/* of do case									*/
			
		key = readif();							/* get first word of next record				*/
	}											/* of do while									*/
		
	if ((r [l_flags] & symtab_flag) != 0) {		/* if they want stats							*/
		if (p_addr != -1) create_object_print_sequence (p_lnum, p_addr);	/* output last number from last library			*/
		if (count != 0) eol();					/* tidy up after last library output			*/
		eol(); pstring ((char *) "*** End of sequence table ***"); eol();	/* print sequence table trailer					*/
		if (((r [l_flags] & dump_flag) == 0) && (! (redirect_symtab & 1))) print("\n");	/* be neat										*/
	}
		
	if (r [l_swap] != 0) {						/* if we have a swap area						*/
		if (swap_too_small & 1) er_sys ((char *) "swap area too small", (char *) "create_object");
		if (swap_too_large & 1) er_sys ((char *) "swap area too large", (char *) "create_object");
	}
}
	
/* $$End of compilation: */

static	void	finish()						/* clean up and output compilation stats		*/
{
	static	fixed	conptr;						/* configuration table pointer					*/
	static	fixed	i, j;
	
	if (r [l_swap] != 0) {						/* do we have an overlay file?					*/
		unsigned long it;
		
		creating_object = 0;					/* no longer creating the object file			*/
		while ((objectfile_out_pointer & 0x00FF) != 0) /* move up to the next sector in the object file	*/
			writeobject (0);					/* zero out each word							*/
			
		if (show_progress || show_p3_progress)
			printf("XPL Tool: Pass 3: Copying swap file (word: 0x%08x) (sector: 0x%08x)\n", (int) objectfile_out_pointer, (int) (objectfile_out_pointer >> 8));
		
		resetovr();								/* reset the overlay file						*/
		
		for (it = 0; it < ovr_length; it++)		/* now move swap file to end of object flle		*/
			writeobject (readovr());
		
		closeovr();								/* close it										*/
		
		remove(host_swap_file);					/* trash it...									*/
	}											/* of overlay file								*/
		
	/* now patch up configuration information */
	
	conptr = inter_file [1];					/* pick up pointer to config table				*/
	inter_file [conptr + vstart] = vstrt;		/* start of variable area						*/
	inter_file [conptr + vlngth] = ram - 1;		/* number of words to zero						*/
	inter_file [conptr + stklen] = pdll;		/* length of stack								*/
	inter_file [conptr + objloc] = obj_base;	/* start of object code							*/
	inter_file [conptr + objlen] = objlng;		/* length of object code						*/
	inter_file [conptr + swpram] = swap_ram;	/* address of swap ram area						*/
	inter_file [conptr + swplen] = swap_total;	/* length of swapping code						*/
	inter_file [conptr + rtploc] = introlen + r [l_str_data];	/* start of runtime package		*/
	inter_file [conptr + inttab] = whentab;		/* pointer to when table						*/
	inter_file [conptr + rcvptr] = rcvdp;		/* rcvdcharacter word							*/
	inter_file [conptr + inpbuf] = inv;			/* input buffer, if used						*/
	inter_file [conptr + sbrsbw] = sbrwp;		/* sbr sbw word pair							*/
	inter_file [conptr + curtrk] = seekp;		/* current head position word foursome			*/
	inter_file [conptr + devtab] = device_table;	/* pointer to device drivers				*/
	
	for (i = 0; i < configlen; i++) {			/* copy over monitor's configuration into output file	*/
		if (i != c_version - c_offset)			/* don't change the version						*/
			inter_file [conptr + c_offset + i] = r [l_ctab + i];	/* copy desired configuration					*/
	}
	
	if (r [l_in1] != 0) inter_file [rfbuf [l_pat]] = r [l_in1];
		
	/* Patch up the object file to perform jumps to the swap routine:	*/
	/* Note: these patches only need to be made on the internal	*/
	/* memory page.									*/
	
	if (prctyp >= 2) {
		if (r [l_swap] != 0) inter_file [rfbuf [l_sw2]] = r [l_swap];
	}
	if (prctyp >= 3) {
		if (r [l_swap] != 0) inter_file [rfbuf [l_sw1]] = r [l_swap] + rfbuf[l_swpp];
	}
	
	objforce();									/* force out object file						*/
	
	/* $$Finish compilation (cont.):
	   .     Print out stats if user requests them. */
	
	if ((r [l_flags] & dump_flag) != 0) {		/* stats										*/
		print("\n");
		print("%s", "System routines:           ");unum (rtpcode); print("\n");
		print("%s", "String and data constants: ");unum (r [l_str_data]); print("\n");
		print("%s", "Object code length:        ");unum (cur_loc);
		print("%s", "     (");unum (objlng); print(" )\n");	/* Objlng = r (l.Str.Data) + rtpcode + cur.Loc [verified below]	*/
		
		if (swap_procs != 0) {
			print("%s", "Swap area:                 ");unum (swap_size); print("\n");
		}
			
		print("%s", "Variable space required:   ");unum (ram - 1); print("\n");
		print("%s", "Push down list length:     ");unum (pdll);
		print("%s", "     (");unum (vstrt + ram - 1 + pdll); print(" )\n");
		print("\n");
		print("%s", "Symbol table:   [");unum (r [l__st]); print("%s", " ]: ");unum (r [l_s_names_len]);
		print("%s", "    Keys used:      [");unum (max_keys); print("%s", " ]: ");unum (r [l_key]); print("\n");
		print("%s", "Stack used:     [");unum (r [l__sk]); print("%s", " ]: ");unum (r [l_stack_used]);
		print("%s", "    Alt keys used:  [");unum (max_alts); print("%s", " ]: ");unum (r [l_altkey]); print("\n");
		print("%s", "RAM tossed:     [");unum (divmax); print("%s", " ]: ");unum (ramptr);
		print("%s", "    SCON tossed:    [");unum (divmax); print("%s", " ]: ");unum (sconptr); print("\n");
		print("%s", "First file:     [");unum ((INTER_FILE_WORD_SIZE - INTER_FILE_1_START) / 256); print("%s", " ]: ");unum (r [l_iflng]);
		print("%s", "    Second file:    [");unum (r [l__if2]); print("%s", " ]: ");unum (r [l_if2lng]); print("\n");
		
		if ((r [l_flags] & link_flag) != 0) {	/* output additional stats if we're linking		*/
			print("%s", "Libraries:      [");unum (lib_size); print("%s", " ]: ");unum (next_lib);
			print("%s", "    Link file:      [");unum ((INTER_FILE_WORD_SIZE - INTER_FILE_2_START) / 256); print("%s", " ]: ");unum ((largest_in_pointer - INTER_FILE_2_START) / 256); print("\n");
			print("%s", "Public symbols: [");unum (max_symbols); print("%s", " ]: ");unum (nextsym);
			print("%s", "    Linker symtab:  [");unum (stable_size); print("%s", " ]: ");unum (nextstable); print("\n");
			print("%s", "Source Ref:     [");unum (source_size); print("%s", " ]: ");unum (nextsource);
 			print("\n");
 		}
			
		if (swap_procs != 0) {					/* output overlay info							*/
			print("%s", "Swapping procedures:       ");unum (swap_procs);
			print("%s", "    Swap file (sectors):       ");unum (swap_total); print("\n");
		}
			
		print("%s", "Total iterations:          ");unum (iteration);
		print("%s", "    Blocks used:    [");unum (r [l__bl]); print("%s", " ]: ");unum (r [l_get_blocks]); print("\n");
		print("\n");
	}
		
	if ((( (ufixed) (r [l_str_data] + rtpcode + cur_loc)) != (ufixed) objlng) || (swap_area != objlng))
	{
		printf("phase error info: %d %d %d\n", r [l_str_data] + rtpcode + cur_loc, objlng, swap_area);
		er_sys ((char *) "phase error", (char *) "finish");
	}
		
	/* print memory map								*/
	
	if (((r [l_flags] & dump_flag) != 0)) {	/* stats reqd									*/
		print("Memory map:\n");
		print("%s0x%04X%s0x%04X", "  Start: 000000  Conf: ", (conptr), "  Scon:  ", (introlen));
		print("%s0x%04X%s0x%04X\n", "  RTP:  ", (introlen + r [l_str_data]), "  Object: ", (obj_base));
		print("%s0x%04X%s0x%04X", "  Swap:  ", (swap_area), "  Vars: ", (vstrt));
		print("%s0x%04X%s0x%04X\n", "  Stack: ", (vstrt + (ram - 1)), "  Heap: ", (vstrt + (ram - 1) + pdll));
		print("%s", "Memory required for this program: ");unum (vstrt + ram - 1 + pdll); print(" words.\n");
		print("\n");
	}											/* if stats printed on dump or compile			*/
}

#define sym_only_sectors	3000

static	fixed	pass3()							/* create object file							*/
{
	static	fixed*	loc_ref_ptr;				/* pointer to LOC_REF							*/
	static	fixed*	scon_ptr;					/* pointer to SCON								*/
	static	fixed	ext_required;				/* memory required in sectors					*/
	static	fixed	mem_available;				/* memory available for KEYLOC and KEYJTO		*/
	static	fixed	ext_available;				/* amount of external memory available (sectors)	*/
	static	fixed	available;					/* external memory available for STABLE/internal memory available above IFBUF	*/
	static	fixed	skip_dca;					/* True if we should skip dead code analysis	*/
	static	fixed	force_swap;					/* True if all procs should be swapcoded		*/
	static	fixed	i, j, k, l;
	
	init();										/* initialize									*/
	
	ext_available = ABLE_CONTEXT._able_xmem_size;	/* number of sectors available in external memory	*/
		
	if ((r [l_flags] & module_flag) != 0)		/* if we're processing a module					*/
		create_reloc();							/* create a relocatable binary					*/
	
	else {										/* otherwise create an object					*/
		
		if ((r [l_flags] & link_flag) != 0)		/* is there a library statement and/or external definition present?	*/
		{										/* yes, link in any modules						*/
			if ((interfile_in_pointer - INTER_FILE_2_START) != 256)
				er_sys ((char *) "intermediate file not reset before LINK", (char *) "pass3");
		
			/* Divide up 'external' memory for our use at this time.  Use 256 sectors for	*/
			/* the name table, 	1024 sectors for the file name table, plus 416 sectors for	*/
			/* a total of 11 storage areas, each with enough room for 8192 entries			*/
			
			if (ext_available < 2048 + sym_only_sectors)
				er_ftl ((char *) "Program too large for compilation (ext mem sym table)");

			stable_ptr = ext_available -  256;
			source_ptr = stable_ptr    - sym_only_sectors;
			
			nxt_sym_ptr      = source_ptr       - 32;	/* set up linker tables							*/
			loc_sym_ptr      = nxt_sym_ptr      - 32;
			pubext_sym_ptr   = loc_sym_ptr      - 32;
			ptr_sym_ptr      = pubext_sym_ptr   - 32;
			type_sym_ptr     = ptr_sym_ptr      - 32;
			deflib_sym_ptr   = type_sym_ptr     - 32;
			lnum_sym_ptr     = deflib_sym_ptr   - 32;
			store_sym_ptr    = lnum_sym_ptr     - 32;
			loc_args_ptr     = store_sym_ptr    - 32;
			sort_sym_ptr     = loc_args_ptr     - 32;
			source_sym_ptr   = sort_sym_ptr     - 32;
			sym_only_nam_ptr = source_sym_ptr   - 32;
			sym_only_ref_ptr = sym_only_nam_ptr - 32;
			
			set_extmem(sym_only_ref_ptr, ext_available, 0);	/* zero out arrays								*/
			
			ext_available    = sym_only_ref_ptr;    /* now this much is left						*/
			
			source_size = shl(sym_only_sectors, 4);	/* source table: # of 16-word blocks		*/
			
			max_symbols = shl(32,  8);			/* max symbols:  word limit					*/
			stable_size = shl(255, 8);			/* symbol table: word limit					*/

			i = able_core(0);					/* set up able core (see run-time)				*/
			j = able_core(c_contab + c_vstart) + able_core(c_contab + c_vlngth) + able_core(c_contab + c_stklen);	/* start of heap								*/

			loc_ref_ptr = &(ABLE_CONTEXT._able_memory_[j]);	/* ref pointers store here in memory	*/
			max_refs = mem_siz - j - 1;						/* determine its maximum size			*/
			
			link (loc_ref_ptr);					/* link in any modules							*/
			
			blockset (loc_ref_ptr, max_refs, 0);/* reinitialize memory							*/
		}										/* of link in any modules						*/
		
		if ((interfile_in_pointer - INTER_FILE_2_START) != 256)
			er_sys ((char *) "intermediate file not reset before OPTIMIZE", (char *) "pass3");
			
		ext_required = 6						/* compute memory needed						*/
		+ (2*shr(r[l_key   ], 8))				/* for tables, in								*/
		+ (  shr(r[l_key   ],10))				/* sectors, rounded								*/
		+ (2*shr(r[l_altkey], 8))				/* up.											*/
		+ (  shr(r[l_altkey],10));
		
		if (ext_available > shr(2*swinfo_max,8))
		{
			swinfo_ptr = ext_available - shr(2*swinfo_max,8);
			ext_available = swinfo_ptr;
			XPLextset (swinfo_ptr, 0, 2*swinfo_max, 0);	/* zero it out									*/
		}
		else er_ftl ((char *) "Program too large for compilation (swap area too large)");
		
		if (_IGE_(ext_available, ext_required)) {	/* if there's external memory available			*/
			keyloc_ptr  = 0;				/* put KEYLOC at the start of external memory	*/
			keyjto_ptr  = keyloc_ptr  + shr(r [l_key   ],  8) + 1;	/* put KEYJTO after KEYLOC						*/
			keyflag_ptr = keyjto_ptr  + shr(r [l_key   ],  8) + 1;	/* put KEYFLAG after KEYJTO						*/
			altloc_ptr  = keyflag_ptr + shr(r [l_key   ], 10) + 1;	/* put ALTLOC  after KEYFLAG					*/
			altjto_ptr  = altloc_ptr  + shr(r [l_altkey],  8) + 1;
			altflag_ptr = altjto_ptr  + shr(r [l_altkey],  8) + 1;
			
			i = _scale_(ext_available, 4, 9);	/* get keys available (total)					*/
			j = shr(r[l_key   ], 2);		/* get 1/4 keys needed							*/
			k = shr(r[l_altkey], 2);		/* 1/4 alt keys needed							*/
			l = j + k;						/* get 1/4 of total								*/
			if ((j == 0) || (k == 0))		/* if basically no keys ...						*/
			{								/* divide up memory 50:50						*/
				max_keys = shr(i,1);
				max_alts = shr(i,1);		/* actually sectors at this pt					*/
			}
			else {							/* else compute according to					*/
				max_keys = _scale_(i, j, l);	/* ratio needed by program						*/
				max_alts = _scale_(i, k, l);
			}
				
			if (max_keys >= 256)			/* now get in words								*/
				max_keys = (fixed) 65535;
			else max_keys = shl(max_keys, 8);
				
			if (max_alts >= 256)
				max_alts = (fixed) 65535;
			else max_alts = shl(max_alts, 8);
				
			set_extmem (0, altflag_ptr + shr(r [l_altkey], 10) + 1, 0);	/* zero out what we need						*/
			ext_available = 0;				/* no more available, since keyloc.ptr starts at 0	*/
		}									/* end of use external memory					*/
		
		else er_ftl ((char *) "Program too large for compilation (too many keys)");
			
		skip_dca   = ((r [l_flags] & skip_flag ) != 0);	/* see if we should skip the dead code analysis	*/
		force_swap = ((r [l_flags] & force_flag) != 0);	/* and/or force all procs to ext memory			*/
		debug_on   = ((r [l_flags] & debug_flag) != 0);	/* and/or produce best code for debug			*/
		
		init_rtp();								/* copy lowcore to the object file				*/
		optimize (skip_dca, force_swap);		/* optimize the code (and output string/data areas to object)	*/
		bindrtp();								/* bind in the runtime package (OPENFILE is called here!)	*/
		
		if ((r [l_flags] & symtab_flag) != 0)	/* does the user want a symbol table?			*/
		{
			char	sym_name[256] = {""};
			
			if ((r [l_flags] & link_flag) != 0)	/* only create symbol table if requested (and linking)	*/
			{
				/* Open up the symbol table file and create it */
				
				strncpy(sym_name, object_file_name, 256);	/* start with object name				*/
				strncat(sym_name, "SYM", 256);				/* append sym							*/
				
				sym_file = (FILE *)	open_able_file_for_output(sym_name, 'TEXT', 'MPS ');
		
				gensym();							/* generate and output the symbol table			*/
				symforce();							/* flush and close								*/
				
				/* Open up the sequence number file in preparation for creating it: */
				
				strncpy(sym_name, object_file_name, 256);	/* start with object name				*/
				strncat(sym_name, "SEQ", 256);				/* append seq							*/
				
				sym_file = (FILE *)	open_able_file_for_output(sym_name, 'TEXT', 'MPS ');
			}

		}
			
		if ((interfile_in_pointer - INTER_FILE_2_START) != 256)
			er_sys ((char *) "intermediate file not reset before CREATE_OBJECT", (char *) "pass3");
		
		i = able_core(0);						/* set up able core (see run-time)				*/
		j = able_core(c_contab + c_vstart) + able_core(c_contab + c_vlngth) + able_core(c_contab + c_stklen);	/* start of heap								*/

		scon_ptr = &(ABLE_CONTEXT._able_memory_[j]);	/* ref pointers store here in memory	*/
		available = mem_siz - j - 1;					/* determine its maximum size			*/
		
		if (_IGT_(swap_scon, available)) {		/* if not enough memory for swapping scon		*/
			 er_ftl ((char *) "Program too large for compilation (too much swapping scon)");
		}										/* of not enough memory							*/
		
		create_object (_location_(scon_ptr), skip_dca);	/* create the final object code (and output sequence table)	*/
		
		symforce();

		finish();								/* clean up and output stats					*/
	}
	
	return ((r [l_flags] & module_flag) != 0);	/* return TRUE if we processed a module			*/
}

/* Pass three initialization and termination: */

static	fixed	is_module;						/* True if we just created a module				*/
static	fixed	i;

long	pass3_main()
{
	b_scon [1] = 0;
	b_ram  [1] = 0;
	b_key  [1] = 0;
	b_alt  [1] = 0;
	
	blockset (hashtab, hash_size + 1, -1);		/* the hash table								*/

	is_module = pass3();
	
	if (!run_quietly)
		print("Compilation successful\n");

	return (0);
}
