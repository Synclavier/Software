/* $Dump statistics */


/* Scientific XPL Compiler - Pass 2 
.  
.    This program forms the second pass of the XPL compiler.  This program
.    reads through the intermediate file generated by pass1, computes
.    the instructions to perform the program being compiled, and writes
.    them out to a second intermediate file for further processing by
.    pass3.
*/

/*	Translated to C:   	11/17/96 at 08:50	*/
/*	Translator Version:	0.000				*/

#include 	<string.h>
#include 	<stdlib.h>
#include 	<stdio.h>

#include	"XPLCompiler.h"
#include	"XPLRuntime.h"

#include	"defs.h"			/* include able files.  by the way, which	*/
#include	"p1-defs.h"			/* came first, the chicken or the egg?		*/
#include	"p12-defs.h"
#include	"p2-defs.h"
#include	"p23-defs.h"

#include	"literals.h"
#include	"asciilit.h"


static	fixed	end_of_main;					/* key for end of main program					*/
static	fixed	trmst;							/* termination status							*/
static	fixed	_stmts;

/* Xpl storage areas: */

/* 12-5-88 - cj - changed intermediage file offsets for humungous work files */

static	fixed	r[maxcomm + 1];					/* set up communications area					*/
static	fixed	fstk[fstklen];

static	fixed	alias_ptr;						/* pointer into ALIASES							*/

static	fixed	token;							/* next token from the file						*/
static	fixed	line_no;						/* current line number							*/

static	fixed	in_recursive;					/* zero if we're not in a recursive proc; KEY of recursive proc otherwise [used for TEMP allocation]	*/

/* The variable CUR.LOC is used to hold the estimated current position
.  within the object code area.  During pass2, worst case assumptions
.  are made about the number of machine words that are used to perform
.  a specific instruction.  The result of the worst case calculation
.  is stored in CUR.LOC.  During pass3, as many instructions as
.  possible are compressed into one machine word. */

static	fixed	cur_loc;
static	fixed	swaploc;						/* Cur.Loc at start of a swappable procedure	*/


/* File input/output subroutines:
.  
.   The following routines are used to read and write data
.   from the various source, intermediate, and runtime package
.   files.  These routines facilitate the reading of files on
.   a byte-by-byte basis and using our own controlled buffer sizes.
.
.   The following comment is left over from DTSS:
.
.  "Our first task (here is our first line of code) is to expand our
.   core allocation to a full 16K.  This is required:  a. for system
.   efficiency, and b. because pass2 of the compiler is larger
.   than pass1 and the DTSS overlay MME requires that the core
.   be allocated by the first pass.
.  
.  "After allocating a full 16K of memory, we will screw with the DXPL
.   runtime package to:  a. convince it that we have 16K of memory, and
.   b. find out where in memory the original registers are stored so
.   that we may find out what the registers contained when the program
.   was started."
.  
.   The routine GC is called to scan the next token from our input file.
.   Remember that our input file is the output file generated by pass1.
.   This file is a sequence of machine words (36-bits on Honeywell
.   systems, 16-bits on Nova systems).
.  
.   The routine GC, in this pass, merely reads the next word from the
.   word-by-word format input file.
.  
.   Since all insert file processing was done during pass1, pass2 does
.   not do any insert processing. */

static	long	interfile_in_pointer = INTER_FILE_1_START;

static	fixed	gc()							/* procedure to get next word					*/
{
	return (inter_file[interfile_in_pointer++]);
}
	
static	fixed	peek()							/* check next word without incrementing			*/
{
	return (inter_file[interfile_in_pointer]);
}
	
/* Intermediate and object file:
.  
.   The routines 'EMIT' and 'WRITEOBJ' are used to write data to the
.   intermediate file and the object file, respectively.
. 
.   Both the intermediate file and the object file are (except for one case)
.   written sequentially.  Therefore, each routine is passed the word
.   which should be appended to the appropriate file.
. 
.   The specified data word is passed as a fixed point argument to both 
.   routines. (only EMIT exists in PASS2) */

static	long	interfile_out_pointer = INTER_FILE_2_START;

static	void	emit(							/* emit word to file							*/
	fixed	word)
{
	if ((interfile_out_pointer >= interfile_in_pointer)
	||  (interfile_out_pointer >= INTER_FILE_WORD_SIZE))
	{
		print("\n");
		print("Program too large (pass 2 intermediate file).\n");
		exit(-1);
	}

	inter_file[interfile_out_pointer++] = word;
}
	
/* Pass two initialization: */

static	void	init()							/* pass2 initialization (return IF starting offset in .WORK)	*/
{
	fixed	i;
	
   	for (i = 0; i <= maxcomm; i++) {			/* read in comm file data						*/
		r [i] = gc();
	}
		
	for (i = maxcomm + 1; i <= 255; i++) {		/* skip the rest of the sector					*/
		gc();
	}
		
	for (i = 0; i <= 255; i++) {				/* save a sector for the interpass comm area at front of interfile	*/
		emit (0);
	}
		
	_sk = stacksize;													/* for pass3 stat printout						*/
	_bl = _blocks;														/* for pass3 stat printout						*/
	_if2 = (fixed) ((INTER_FILE_WORD_SIZE - INTER_FILE_2_START) / 256);	/* for pass3 stat printout						*/
}

/*
.  
.  The following procedures are used to print error messages on the
.  terminal, in a variety of formats.
*/

static	void	er_cerr(						/* compiler system error						*/
	char*	str)
{
	print("\n");
	print("%s%s%s%6d\n", "### Compiler system error (", str, ") at line", line_no);
	exit(-1);
}
	
static	void	er_etc(							/* expression too complicated					*/
	char *	str)
{
	print("\n");
	print("%s%6d%s%s%s\n", "Expression too complicated at line", line_no, " (", str, ")");
	exit(-1);
}
	
static	void	er_emes1(						/* print string									*/
	char *	str)
{
	print("%s%s%6d\n", str, " at line", line_no);
	trmst = -1;									/* abort compilation							*/
}
	
static	void	er_atdnm() {er_emes1 ((char *) "Argument types do not match"); }
static	void	er_fna() {er_emes1 ((char *) "Floating point not allowed with fixed point"); }
static	void	er_tmnc() {er_emes1 ((char *) "Too many numeric constants"); }
static	void	er_tmpl() {er_emes1 ((char *) "Too many procedures/labels"); exit(-1); }
	
/* Routine GKEY:
.     The routine GKEY is called to get the next key.
.     It increments the key counter and returns the new value.
*/

static	fixed	gkey()
{
	nexkey = nexkey + 1;
	
	if (_IGE_(nexkey, shr(extern_base, 1))) er_tmpl();	/* did we collide with the externals?			*/
		
	return (nexkey);
}
	
static	fixed	galt()							/* used to get an alternate key					*/
{
	altkey = altkey + 1;						/* incr alt key									*/
	
	if (_IGE_(altkey, shr(extern_base, 1))) er_tmpl();	/* did we collide with the externals? too many procs/labels	*/
		
	return (altkey);							/* note that zero is never returned				*/
}
	
/* Storage allocation:
.  
.   Many routines need allocatable fixed length blocks.  Since they
.   all want four word blocks, these blocks are all allocated out
.   of the same arrays.  The blocks consist of one entry in each of four
.   separate arrays.  To keep the different uses distinguishable, any
.   routines using these arrays should declare their own names for them
.   and also rename the storage allocation routines.  Note that the block
.   with index zero is never used.  This means that zero as a link may
.   be used to indicate the end of a list. */

static	fixed	freebl = 1;						/* free block pointer							*/
static	fixed	free_end;						/* end of free list pointer						*/
static	fixed	blk_in_use;						/* number of blocks currently in use			*/

/* get a block from free storage */

static	fixed	get()
{
	static	fixed	block;
	block = freebl;
	if (block == 0) er_etc ((char *) "get");
	else freebl = store1 [block];
	blk_in_use = blk_in_use + 1;
	if (blk_in_use > get_blocks) get_blocks = blk_in_use;
	return (block);
}
	
/* return a block to free storage */

static	void	rel(
	fixed	block)
{
	store1 [block] = freebl;					/* link up										*/
	freebl = block;								/* here we are									*/
	blk_in_use = blk_in_use - 1;
}
	
/* Stack definitions and routines:
. 
.  The stack is used for any important parameters during any of the
.  recursive routines in the compiler.  This is true not only for the
.  recursive descent scanning routines, but also, for example, for the
.  recursive expression compiler.  */

static	fixed	stackpt;						/* pointer into stack							*/
#define	queue			stack					/* put a queue over the stack					*/
static	fixed	frontpt;						/* pointer to front of queue					*/
static	fixed	startpt;						/* where the queue starts in the stack			*/

/* stack push and pop routines */

static	void	push(
	fixed	info)
	
{
	if (_IGT_(stackpt, stacksize)) er_etc ((char *) "push");
	stack [stackpt] = info;
	stackpt = stackpt + 1;
	if (_ILT_(stack_used, stackpt)) stack_used = stackpt;	/* stats										*/
}
	
static	fixed	pop()
{
	static	fixed	top;
	
	if (_ILE_(stackpt, frontpt)) er_emes1 ((char *) "stack underflow (pass2 pop)");
	stackpt = stackpt - 1;
	top = stack [stackpt];						/* strip off the top							*/
	
	if (stackpt == frontpt) {					/* end of stack									*/
		if (startpt != 0) {						/* watch out for empty queue					*/
			stackpt = startpt - 2; startpt = stack [stackpt]; frontpt = stack [stackpt + 1];	/* reset stack and queue						*/
		}
		else {									/* possibly empty queue							*/
			stackpt = 0; frontpt = 0;			/* reset stack and queue						*/
		}
	}											/* of end of stack								*/
		
	return (top);
}
	
static	void	start_queue()					/* start a queue								*/
{
	if (stackpt != 0) {							/* only save if we're not at the beginning		*/
		push (startpt);							/* start a new queue							*/
		push (frontpt);
	}
		
	startpt = stackpt;							/* remember where it starts						*/
	frontpt = stackpt;							/* start dequeueing here						*/
}
	
#define	enqueue			push					/* just to turn it into a bonafide queue		*/

static	fixed	dequeue()						/* dequeue an element from the stack			*/
{
	static	fixed	next;
	
	if (_IGE_(frontpt, stackpt)) er_emes1 ((char *) "queue underflow (pass2 dequeue)");
	next = queue [frontpt];						/* pull off the next element in line			*/
	frontpt = frontpt + 1;						/* move pointer up								*/
	
	if (frontpt == stackpt) {					/* end of queue									*/
		if (startpt != 0) {						/* watch for empty stack						*/
			stackpt = startpt - 2; startpt = stack [stackpt]; frontpt = stack [stackpt + 1];	/* reset stack and queue						*/
		}
		else {									/* possibly empty stack							*/
			stackpt = 0; frontpt = 0;			/* reset stack and queue						*/
		}
	}											/* of end of queue								*/
		
	return (next);
}
	
/* Miscellaneous push and pop routines (save registers, etc.):
.  
.  The array REGC contains during compilation what each index
.  register will contain during runtime.  By carefully keeping
.  track of which registers are loaded when, it is possible
.  to do a fair job of optimizing the index register use.  This
.  is very important on the ABLE machine, since memory can only
.  be accessed by the index registers.  REGS contains the appropriate
.  storage class (address space) that that particular register
.  points into.
.
.  The array REGP contains during compilation what each index
.  register was explicitly set to by GETVP.  If a value in REGP
.  does not equal the corresponding value in REGC, the index
.  register was implicitly altered by some register increment
.  instruction.  This information is important because the
.  final locations of external references are not known until
.  after relocation in pass3.  If REGP does not correspond to
.  REGC for an external reference, that index register MUST be
.  reloaded.
.
.  An index register is considered free when REGC (reg) is zero.
.
.  The global variables REGU and REGL are used to keep track of which
.  registers are used by a procedure without being loaded (REGU) and
.  which index registers are actually loaded by a certain section of
.  code (REGL).
*/

static	fixed	regl, regu;						/* lists of registers loaded/used				*/
static	fixed	regc  [max_ptr_reg + 1];		/* holds contents of the index registers		*/
static	fixed	regs  [max_ptr_reg + 1];		/* holds storage class of index registers		*/
static	fixed	regp  [max_ptr_reg + 1];		/* holds explicitly set contents of index registers	*/
static	fixed	regloc[max_ptr_reg + 1];		/* used to select 'least recently used' register	*/
static	fixed	tregc [max_ptr_reg + 1];		/* holds set of registers temporarily			*/
static	fixed	tregs [max_ptr_reg + 1];
static	fixed	tregp [max_ptr_reg + 1];
static	fixed	t1regc[max_ptr_reg + 1];		/* more temps									*/
static	fixed	t1regs[max_ptr_reg + 1];
static	fixed	t1regp[max_ptr_reg + 1];

static	ufixed	regbit[] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000};	/* bit assignments for regs						*/

static	void	pushr()							/* save the regs on the stack					*/
{
	fixed	bits, i;
	
	bits = 0;									/* which are stored								*/
   	for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		if (regc [i] != 0) {
			bits = (bits | regbit [i]);			/* remember this register saved					*/
			push (regc [i]);					/* save loc and storage class					*/
			push (regs [i]);
			push (regp [i]);					/* save explicit setting also					*/
		}
	}
	push (bits);								/* and store the bits too						*/
}
	
static	void	popr()							/* restore regs saved by pushr					*/
{
	fixed	bits, i;
	
	bits = pop();								/* get bits										*/
	i = max_ptr_reg;
	while (i >= min_ptr_reg) {
		if ((bits & regbit [i]) != 0) {			/* if previously saved							*/
			regp [i] = pop();					/* restore										*/
			regs [i] = pop();
			regc [i] = pop();
		}
		else regc [i] = 0;						/* clear										*/
		i = i - 1;
	}											/* of loop										*/
}
	
/* During compilation, it is often necessary to store temporarily
.   the contents of the REGC array.  This happens, for example, at
.   the end of an iterative do-loop, when a jump instruction is
.   emitted back to an earlier section of code.   
.  
.   When this jump instruction is emitted, any registers that were used
.   earlier in the routine but were then reloaded during a later section
.   of code are reloaded before the jump is emitted.
.  
.   The following routines facilitate the manipulation of the REGC
.   array on and off the stack, and in and out of temporary storage
.   areas.
*/

static	void	sreg()							/* move regs tempo								*/
{
	static	fixed	i;
	
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		tregc [i] = regc [i];
		tregs [i] = regs [i];
		tregp [i] = regp [i];
	}
}
	
static	void	lreg()
{
	static	fixed	i;
	
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		regc [i] = tregc [i];
		regs [i] = tregs [i];
		regp [i] = tregp [i];
	}
}
	
static	void	sreg1()							/* save in another temporary					*/
{
	static	fixed	i;
	
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		t1regc [i] = regc [i];
		t1regs [i] = regs [i];
		t1regp [i] = regp [i];
	}
}
	
static	void	lreg1()
{
	static	fixed	i;
	
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		regc [i] = t1regc [i];
		regs [i] = t1regs [i];
		regp [i] = t1regp [i];
	}
}
	
static	void	pushv()							/* push REGU, REGL								*/
{
	push (regl);
	push (regu);
	regl = 0;
	regu = 0;
}
	
static	void	popv()							/* restore										*/
{
	static	fixed	pregu, pregl;
	
	pregu = pop();								/* get old REGU									*/
	pregl = pop();								/* and REGL										*/
	regu = (pregu | (regu & (~ pregl)));		/* used means one used that we did not load		*/
	regl = (regl | pregl);						/* and these are the total register used in this block	*/
}
	
/* Code emission:
.
.   During code emission, certain blocks are allocated with the 'GET'
.   routine to help in the processing of temporaries, procedure call
.   generation, and so forth.
.  
.   The locations of the 'GET' blocks that are used are: */

#define	e_loc			store2					/* location (if known)							*/
#define	e_point			store4					/* pointer for various linked lists				*/
#define	e_get			get						/* storage allocation routines					*/
#define	e_rel			rel

static	fixed	zflags;							/* indicates which register corresponds to ZFLAGS	*/

static	void	zflchk(							/* examines dest to see if it sets ZFLAGS		*/
	fixed	des)
{
	if ((des & 0x00C0) == b_ad) {				/* arith, test									*/
		zflags = shl(1, des & 3);				/* indicate register by bit #					*/
		if ((des & 0x00F0) == b_td) zflags = 0;	/* test ops										*/
	}
}
	
/* Code emission - emit subroutines:
. 
.   The various emit routines are used to emit records to the formatted object
.   code file.  There is one little routine for each type of record in the
.   intermediate file.
*/

/* Test if a constant will fit in the constant (6-bit) field:
.    Passed the constant to test.
.    Returns TRUE (1) if it fits, FALSE (0) if it don't. */

static	fixed	emitt(							/* test if N is a constant that will fit into immediate field	*/
	fixed	n)
{
	if (((n & (fixed) 0xFFE0) == (fixed) 0xFFE0) || ((n & (fixed) 0xFFE0) == (fixed) 0x0000))
		return (1);								/* return true if does fit						*/
	else return (0);							/* false if it don't							*/
}
	
/* Emit end of file marker: */

static	void	em_eof()						/* emit an EOF record							*/
{
	emit (et_eof);								/* write out one word							*/
}
	
/* Emit literal data word or instruction:
.    Passed the 16-bit word to emit. */

static	void	em_lit(							/* emit a literal word							*/
	fixed	lw)
{
	if ((lw & literal_mask) == 0) emit (et_lit);	/* if not flagable, emit header					*/
	emit (lw);
	cur_loc = cur_loc + 1;
}
	
/* Emit transfer (conditional) to key location:
.    Passed bit encoded condition.
.    Passed key number, to be set up during pass3.
*/

static	void	em_tra(							/* emit a transfer record						*/
	fixed	con,
	fixed	key)
{
	emit (et_tra);
	emit (con);
	emit (key);
	emit (-1);									/* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE)	*/
	cur_loc = cur_loc + 2;						/* assume two for transfer						*/
}
	
/* Emit transfer (conditional) to alternate key location:
.    Passed bit encoded condition.
.    Passed key number, to be set up during pass3.
*/

static	void	em_atr(							/* emit a transfer record						*/
	fixed	con,
	fixed	akey)
{
	emit (et_atr);
	emit (con);
	emit (akey);
	emit (-1);									/* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE)	*/
	cur_loc = cur_loc + 2;						/* assume two for transfer						*/
}
	
/* Emit call to user procedure:
.    Passed key which will point to routine during pass3.
.    Passed pointer to alias list for this call.
.    Passed length of alias list for this call.
*/

static	void	em_cal(							/* emit a user procedure call record			*/
	fixed	key,
	fixed	*ptr,
	fixed	len)
	
{
    fixed			_upper0;
	emit (et_cal);								/* emit record type								*/
	emit (len + 1);								/* emit record length							*/
	emit (key);									/* emit key of proc we're calling				*/
	for (_upper0 = len - 1, len = 0; len <= _upper0; len++) {	/* emit alias list for this call				*/
		emit (ptr[len]);
	}
	cur_loc = cur_loc + 2;						/* always 2 here								*/
	
	if ((prctyp < 2) && ((flags & module_flag) == 0))/* if model B and NOT in a module				*/
		zflags = 1;								/* zflags equal ac0 after call					*/
	else zflags = 0;							/* zflags are garbage on Model C after call (also in modules so upwards compatible to Model C)	*/
}
	
/* Emit call to runtime package routine:
.     Passed absolute location of run time routine in object file.
*/

static	void	em_rtp(							/* emit an RTP call record						*/
	fixed	rloc)
{
	emit (et_rtp);
	emit (rloc);

	if (_ILT_(rloc, l_interp)) 					/* Normal RTP calls: 2 instructions				*/
		cur_loc = cur_loc + 2;
	else if (emitt(rloc-l_interp) != 0)			/* interpreter call (small) 1 instruction		*/
		cur_loc = cur_loc + 1;
	else										/* interpreter call (large) 2 instructions		*/
		cur_loc = cur_loc + 2;
		
	if ((prctyp < 2) && ((flags & module_flag) == 0))/* if model B and NOT in a module				*/
		zflags = 1;								/* zflags equal ac0 after call					*/
	else zflags = 0;							/* zflags are garbage on Model C after call (also in modules so upwards compatible to Model C)	*/
}
	
/* Emit a pointer to a variable:
.    Passed storage class of variable.
.    Passed the variable location, relative to the start of the
.      as-yet-undetermined variable area.
.    Passed an ABLE destination (register, etc.) to send the
.      absolute location to.
*/

static	void	em_vpt(							/* emit variable pointer record					*/
	fixed	sclass,
	fixed	vloc,
	fixed	des)
	
{
	emit (et_vpt);
	emit (des);									/* destination first							*/
	emit (sclass);								/* then storage class							*/
	emit (vloc);								/* finally the variable location				*/

	cur_loc = cur_loc + 2;						/* always 2 words here							*/

	if (sclass == s_automatic)					/* karim: this was the bug						*/
		des = b_ad + b_add + (des & b_amsk);	/* convert destination to ADD instruction		*/

	zflchk (des);								/* record ZFLAGS if arith load					*/
}
	
/* Emit a pointer to an object code location:
.    Passed the key that will point to the object location during pass3.
*/

static	void	em_opt(							/* emit object pointer record					*/
	fixed	key)
{
	emit (et_opt);
	emit (key);
	cur_loc = cur_loc + 1;
}
	
/* Emit a label definition record: 
.     Passed the key to assign location to during pass3.  The current
.       location counter will be assigned to the specified key during
.       the final object code location assignment. */

static	void	em_lde(							/* emit label definition record					*/
	fixed	key)
{
	emit (et_lde);
	emit (key);
}
	
static	void	em_ald(							/* emit label definition record for alternate keys	*/
	fixed	akey)
{
	emit (et_ald);
	emit (akey);
}
	
/* Emit a data definition record:
.    Passed key of declared data - the data immediately follows. */

static	void	em_dat(							/* emit data definition record					*/
	fixed	key)								/* key of data definition						*/
	
{
	emit (et_dat);								/* emit record type								*/
	emit (key);									/* emit the key									*/
	emit (0);									/* emit the SWAP flag (can't swap by default)	*/
}
	
/* Emit copy data to object record:
.    Passed number of words to copy to interfile2. */

static	void	em_cpy(							/* emit copy data to object						*/
	fixed	len)								/* number of words to emit						*/
	
{
    fixed			_upper0;
	emit (et_cpy);								/* emit record type								*/
	emit (len);									/* emit the length								*/
	
	for (_upper0 = len, len = 1; len <= _upper0; len++) {	/* emit the data								*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit copy scon to object record:
.    Passed number of words to copy to interfile2. */

static	void	em_scn(							/* emit copy scon to object						*/
	fixed	len)								/* number of words to emit						*/
	
{
    fixed			_upper0;
	emit (et_scn);								/* emit record type								*/
	emit (len);									/* emit the length								*/
	
	for (_upper0 = len, len = 1; len <= _upper0; len++) {	/* emit the data								*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit procedure definition:
.    Passed procedure key.
.    Passed starting ram location.
.    Passed starting temp location.
.    Passed procedure attributes.
.    Passed number of register arguments. */

static	void	em_pdf(							/* emit procedure definition					*/
	fixed	prockey, 							/* procedure key								*/
	fixed	numargs, 							/* number of reg args total						*/
	fixed	ramloc, 							/* starting ram location						*/
	fixed	temploc, 							/* starting temp location						*/
	fixed	attr, 								/* procedure attributes							*/
	fixed	reg_arg)							/* number of register arguments for pass3 to store	*/
	
{
	em_tra (0, prockey + 1);					/* emit jump around procedure body				*/
	em_lde (prockey);							/* define location for procedure entry			*/
	
	emit (et_pdf);								/* emit procedure definition type				*/
	emit (shl(numargs,8) + reg_arg + 4);		/* emit record length, numargs in upper half	*/
	emit (prockey);								/* emit key										*/
	emit (ramloc);								/* emit starting ram location					*/
	emit (temploc);								/* emit starting temporary location				*/
	emit (attr);								/* emit procedure attributes					*/
	/* register args are handled by whoever calls EM.PDF */
}
	
/* Emit end of procedure:
.    Passed procedure key.
.    Passed ending ram location.
.    Passed ending temp location [offset into stack for temporaries (recursive procs only)]
.    Passed stack frame length.
.    Passed registers used by the procedure.
.    Passed NOSWAP bit list for data statements. */

static	void	em_pen(							/* emit end of procedure						*/
	fixed	prockey, 							/* procedure key								*/
	fixed	ramloc, 							/* ending ram location							*/
	fixed	temploc, 							/* ending temporary location (tempory offset for recursive procs)	*/
	fixed	stack_len, 							/* length of stack frame						*/
	fixed	regs, 								/* registers used by procedure					*/
	fixed	dswp)								/* Noswap bit list for data						*/
	
{
	emit (et_pen);								/* emit end of procedure type					*/
	emit (prockey);								/* emit procedure key							*/
	emit (ramloc);								/* emit ending ram location						*/
	emit (temploc);								/* emit ending temp location (or temp offset)	*/
	emit (stack_len);							/* emit stack length							*/
	emit (regs);								/* emit registers used map						*/
	emit (dswp);								/* emit NOSWAP bit list for data				*/
	
	em_lde (prockey + 1);						/* emit label definition for jump around		*/
}
	
/* Emit when statement definition:
.    Passed procedure key. */

static	void	em_whn(							/* emit when statement definition				*/
	fixed	prockey)							/* procedure key								*/
	
{
	em_tra (0, prockey + 1);					/* emit jump around when body					*/
	em_lde (prockey);							/* emit label definition for when body entry	*/
	
	emit (et_whn);								/* emit when statement type						*/
	emit (prockey);								/* emit its key									*/
}
	
/* Emit end of when statement:
.    Passed procedure key.
.    Passed registers used by the when body. */

static	void	em_wen(							/* emit end of when statement					*/
	fixed	prockey, 							/* procedure key								*/
	fixed	regs)								/* registers used by when						*/
	
{
	em_lde (prockey + 2);						/* emit label definition for return location	*/
	
	emit (et_wen);								/* emit end of when type						*/
	emit (prockey);								/* emit key										*/
	emit (regs);								/* emit regs used								*/
	
	em_lde (prockey + 1);						/* emit label definition for jump around		*/
}
	
/* Emit string constant pointer:
.     Passed string location.
.     Passed destination. */

static	void	em_spt(							/* emit string constant/data pointer			*/
	fixed	sloc,
	fixed	des)
	
{
	emit (et_spt);
	emit (des);
	emit (sloc);
	emit (0);									/* doesn't swap									*/
	cur_loc = cur_loc + 2;
	zflchk (des);								/* record zflags if arith load					*/
}
	
/* Emit addr of fixed array:
.    Passed key of defining procedure.
.    Passed formal parameter number. */

static	void	em_adr(							/* emit addr of fixed array						*/
	fixed	parm_key, 							/* key of defining procedure					*/
	fixed	parm)								/* formal parameter number in that procedure	*/
	
{
	emit (et_adr);								/* emit record type								*/
	emit (parm_key);							/* followed by the key							*/
	emit (parm);								/* and the parameter number						*/
}
	
/* Emit sequence number:
.    Passed sequence number. */

static	void	em_seq(							/* emit sequence number							*/
	fixed	snum)								/* the sequence number to emit					*/
	
{
	emit (et_seq);								/* emit the record type							*/
	emit (snum);								/* and the sequence number						*/
}
	
/* Emit symref (global reference) or symdef (global definition):
.    Passed number of words to copy to interfile2. */

static	void	em_sym(							/* emit symref or symdef						*/
	fixed	len)								/* number of words to emit						*/
	
{
    fixed			_upper0;
	emit (et_sym);								/* emit the symref/symdef header				*/
	emit (len);									/* emit length									*/
	
	for (_upper0 = (len & 0x00FF), len = 1; len <= _upper0; len++) {	/* emit len words		*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit module name:
.    Passed number of words to copy to interfile2. */

static	void	em_mod(							/* emit module name								*/
	fixed	len)								/* number of words to emit						*/
	
{
    fixed			_upper0;
	emit (et_mod);								/* emit the module header						*/
	emit (len);									/* emit length									*/
	
	for (_upper0 = (len & 0x00FF), len = 1; len <= _upper0; len++) {	/* emit len words								*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit library reference:
.    Passed number of words to copy to interfile2. */

static	void	em_lib(							/* emit library reference						*/
	fixed	len)								/* number of words to emit						*/
	
{
    fixed			_upper0;
	emit (et_lib);								/* emit the library header						*/
	emit (len);									/* emit length									*/
	
	for (_upper0 = (len & 0x00FF), len = 1; len <= _upper0; len++) {	/* emit len words								*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit insert filename record:
.    Passed number of words to copy to interfile2. */

static	void	em_ins(							/* emit insert filename							*/
	fixed	len)								/* number of words to emit						*/
{
    fixed			_upper0;
	emit (et_ins);								/* emit the insert header						*/
	
	emit (len);									/* emit length									*/
	
	for (_upper0 = (len & 0x00FF), len = 1; len <= _upper0; len++) {	/* emit len words								*/
		emit (gc());							/* copy directly from interfile1 to interfile2	*/
	}
}
	
/* Emit library definition record: (only for MAIN)
.    Passed library number. */

static	void	em_ldf(							/* emit library definition to IF				*/
	fixed	lib)								/* the number of the library we're about to append to the IF	*/
	
{
	emit (et_ldf);								/* write out the record type					*/
	emit (lib);									/* and the library number						*/
}
	
/* Emit a record to construct code for a 'Do Case' construct: */
static	void	em_cas()
{
	emit (et_cas);
	cur_loc = cur_loc + 3;
}
	
/* The following procedures assist in the object code emission
.   process.  They perform standard shifts, constant field tests,
.   and other standard items. */

/* Emit a (source, destination) instruction:
.    Passed source.
.    Passed destination. */

static	void	emita(							/* emit a (source, destination) instruction		*/
	fixed	sou,
	fixed	des)
{
	em_lit (shl(des, 8) + sou);
	zflchk (des);								/* record it if dest effects zflags				*/
}
	
/* Emit a constant to a destination:
.     Passed the constant (value).
.     Passed the destination.
.
.     This routine will compact the constant into a single instruction
.       if it will fit (6-bits). */

static	void	emitc(							/* send a known constant to destination			*/
	fixed	valu,
	fixed	dest)
{
	if (emitt (valu) & 1)						/* will fit into immed field?					*/
		emita (b_is + (valu & b_imsk), dest);	/* immed to destination							*/
	else {										/* full word									*/
		emita (b_ms + b_ibt + b_pc, dest);		/* pc and i to dest								*/
		em_lit (valu);							/* ship out constant							*/
	}											/* full word									*/
}												/* emit constant								*/

/* Expression scanner - definitions:
.
.  Arithmetic expressions are stored in tree form.
.  The following definitions are used:
*/

#define	x_node			store1					/* type of the node								*/
#define	x_arg1			store2					/* first argument pointer						*/
#define	x_arg2			store3					/* second argument pointer						*/
#define	x_info			store4					/* extra information							*/
#define	x_spec			store5					/* special information							*/
#define	x_get			get						/* storage allocation routines					*/
#define	x_rel			rel

/* 
.  The following types of nodes, including X.VAR and X.CONST,
.  are created by 'COMPUTE' for passage to IN.REG.
.  
.  Every node returned by COMPUTE has X.ARG1 (NODE) set to indicate
.  a floating or fixed point node.
*/

#define	x_reg			5						/* register  - ARG1 = type, INFO = reg#			*/
#define	x_temp			6						/* temporary - ARG1 = type, INFO = loc block	*/
#define	x_preg			7						/* pointer register - ARG1 = type, INFO = reg#	*/
#define	x_dev			8						/* device    - ARG1 = type (always fixed), INFO = dev#	*/
#define	x_pvar			9						/* pointer to variable - arg1 = class (upper),  arg2 = 0, info = location	*/

/* For the above:
.     X.REG:  if T.VAR,  then INFO = register# bit (1, 2, 4, 8)
.             if T.FVAR, then INFO = fpr# (1, 2) where 1 = AC0-AC1, and 2 = AC2-AC3
.     X.TEMP: if T.VAR,  then INFO points to single word loc block where stored
.             if T.FVAR, then INFO points to double word loc block where stored
.     X.PREG: if T.VAR,  then INFO = reg# which points to desired location
.             if T.FVAR, then INFO = reg# which points to word-pair
.  
.             ***** Note that for X.REG, X.TEMP, X.PREG, and X.PTEMP, the X.ARG1
.             information is either T.FVAR or T.VAR.  Other information (such as
.             T.ARR or T.PVAR bits) has been completely masked out in the process of
.             going from a subscripted variable to a pointer register (subscript)
.             and then going from a register to a temporary.
*/

/* Scan check routine:
.   
.   The routine SCANC is called to check for the occurance of a 
.   line number record, a symbol definition record, or a ZREG 
.   type record in the intermediate file.
.  
.   If one is found, then it is skipped after appropriate action.
*/

static	void	scanc()							/* check for various records					*/
{
	static	fixed	t;
	xstart:;									/* come back here for more						*/
	t = peek();									/* scan current word,  no increment				*/
	
	if (t == t_lnum) {							/* line number									*/
		gc();									/* skip current word (T)						*/
		line_no = gc();							/* get line number								*/
		em_seq (line_no);						/* output line number for pass3					*/
		goto xstart;
	}
		
	if (t == t_copyd) {							/* see if should copy data to file				*/
		gc();									/* skip current word (T)						*/
		em_cpy (gc());							/* output copy information for pass3			*/
		goto xstart;
	}
		
	if (t == t_copys) {							/* see if should copy scon to file				*/
		gc();									/* skip current word (T)						*/
		em_scn (gc());							/* output copy information for pass3			*/
		goto xstart;
	}
		
	if (t == t_symref) {						/* process symbol for linker					*/
		gc();									/* skip current word (T)						*/
		em_sym (gc());							/* copy information for pass3					*/
		goto xstart;
	}
		
	if (t == t_address) {						/* process addr of fixed array					*/
		gc();									/* skip current word (T)						*/
		t = gc();								/* pick up procedure key						*/
		em_adr (t, gc());						/* pass info onto pass3							*/
		goto xstart;
	}
}
	
/* Floating point management:
.  
.   During compilation (pass1), sequences of digits (1.123) are
.   converted into binary floating point representation.
.  
.   Each floating point number requires 32-bits.  During compilation
.   therefore, floating pont constants are carried around
.   in two fixed-point numbers, each with 16-bits. */

static	fixed	fstkptr;
static	fixed	fstr(							/* store two constants in stack, return ptr		*/
	fixed	v1,
	fixed	v2)
{
	fstkptr = 0;								/* start at zero								*/
	while (fstk [fstkptr] != (fixed) 0x8000) {	/* scan for free								*/
		fstkptr = fstkptr + 2;
		if (fstkptr == fstklen) er_tmnc();
	}
	fstk [fstkptr] = v1; fstk [fstkptr + 1] = v2;	/* save											*/
	return (fstkptr);
}
	
/* Expression scanner:
.  
.   The expression scanner is a routine that is used to recover an expression
.   tree from the intermediate file generated by pass1.  Virtually all of the
.   expression processing has been done in pass1.
*/

static	fixed	expr()							/* get next expression							*/

{
    fixed			_upper0;
	static	fixed	tree, temtree, brk;
	
	push (tree);								/* save current tree							*/
	tree = x_get();								/* get a block for the tree node				*/
	temtree = gc();								/* get word from file							*/
	x_node [tree] = (temtree & 0x00FF);			/* lower half is always node type				*/
	if (x_node [tree] > x_cal) {				/* error if too big								*/
		print("\n");
		print("%s%6d%s%6d%s\n", "### Compiler system error in expression scanner (", x_node [tree], " at line", line_no, ")");
		exit(-1);
	}
		
	switch (x_node [tree]) {					/* branch on type of node						*/
		case 0:
		{										/* dyadic operator								*/
			x_info [tree] = shr(temtree, 8);	/* extract operator type						*/
			temtree = expr(); x_arg1 [tree] = temtree;	/* dxpl used temp to store ptr to store1 array???	*/
			temtree = expr(); x_arg2 [tree] = temtree;
			break;
		}
			
		case 1:
		{										/* monadic operator								*/
			x_info [tree] = shr(temtree, 8);	/* and this is operator type					*/
			temtree = expr(); x_arg1 [tree] = temtree;
			break;
		}
			
		case 2:
		{										/* constant										*/
			x_arg1 [tree] = shr(temtree, 8);	/* and this is type								*/
			if (x_arg1 [tree] == t_var)
				x_info [tree] = gc();			/* fixed point constant							*/
			else {								/* floater - read in two words					*/
				static	fixed	t1, t2;
				t1 = gc(); t2 = gc();			/* read and get it								*/
				x_info [tree] = fstr (t1, t2);	/* and store those								*/
			}
			break;
		}
			
		case 3:
		{										/* variable										*/
			x_arg1 [tree] = (shr(temtree, 8) | shl(gc(), 8));	/* and this is type/storage class				*/
			x_info [tree] = gc();				/* pick up relative variable location			*/
			if (x_arg1 [tree] & 1) {			/* if array										*/
				temtree = expr(); x_arg2 [tree] = temtree;
			}
			if ((x_arg1 [tree] & 0x00FF) == t_pvar)/* and now they are the same					*/
				x_arg1 [tree] = (t_var | (x_arg1 [tree] & (~ 0x00FF)));
			break;
		}
			
		/* Procedure call tree node:
		.  
		.   X.NODE (TREE) = X.PROC
		.   X.ARG1 (TREE) = start of linked list of arguments, starting with first argument
		.   X.ARG2 (TREE) = alias list ptr/T.PROC or T.RTP, depending
		.   X.INFO (TREE) = key (for T.PROC) or absolute rtp location (for T.RTP)
		.   X.SPEC (TREE) = variable type returned by procedure
		.  
		.   For each argument block:
		.  
		.   X.NODE (BLK) = link to next block, end with zero
		.   X.ARG1 (BLK) = token type of passed array, or start of expression tree for variable
		.   X.ARG2 (BLK) = declared variable type (arg declared in proc.)
		.   X.INFO (BLK) = 0 if declared vtype is variable; variable offset for arrays; ptr for strings
		.   X.SPEC (BLK) = variable offset location for procedure argument (declared in proc.)
			*/
		
		case 4:
		{										/* procedure call								*/
			static	fixed	blk, argtem;
			static	fixed	ptr;
			
			x_info [tree] = gc();				/* and pick up location - loc for rtp, key # for user proc	*/
			x_spec [tree] = gc();				/* get variable type returned and				*/
			x_arg1 [tree] = 0;					/* initialize variable list						*/
			x_arg2 [tree] = (shl(alias_ptr, 8) | shr(temtree, 8));	/* save type plus pointer to alias table		*/
			
			if ((ptr = alias_ptr++) >= num_alias_structs)
				er_emes1 ((char *) "alias table incompatibility");	/* better match pass one!						*/

			aliases[ptr].key = x_info [tree];	/* save key we just read from file				*/
			aliases[ptr].num = gc();			/* get list length from intermediate file		*/

			if (aliases[ptr].num >= num_info_spaces)
				er_emes1 ((char *) "alias table size incompatibility");	/* better match pass one!						*/

			for (_upper0 = aliases[ptr].num - 1, temtree = 0; temtree <= _upper0; temtree++) {	/* read in alias list							*/
				aliases[ptr].info[temtree] = gc();			/* get list length from intermediate file		*/
			}									/* of reading in alias list						*/
				
			temtree = gc();						/* get next word								*/
			while (temtree != 0) {				/* and loop										*/
				blk = x_get();					/* get a block for the argument					*/
				x_node [blk] = x_arg1 [tree];	/* set up forward ptr							*/
				x_arg1 [tree] = blk;			/* and now we are first (args are backwards in file, remember)	*/
				x_arg2 [blk] = (temtree & 255);	/* get type, ignore flag bit					*/
				if (x_arg2 [blk] == t_pvar) x_arg2 [blk] = t_var;	/* delete T.PVAR bits							*/
				x_spec [blk] = gc();			/* variable area location of this argument - always vs1	*/
				if (x_arg2 [blk] & 1) {			/* argument is an array							*/
					x_arg1 [blk] = gc();		/* get token type/storage class of array we are passing	*/
					x_info [blk] = gc();		/* get variable location or string constant pointer for passed argument	*/
				}
				else {							/* argument in proc is variable, not array		*/
					push (blk);
					argtem = expr();			/* scan expression, put in temporary			*/
					blk = pop();				/* restore block								*/
					x_arg1 [blk] = argtem;		/* put expression node here						*/
				}
				temtree = gc();					/* and get next one								*/
			}									/* of do while for arg list						*/
			break;
		}										/* procedure call								*/
			
		case 5:
		{										/* X.Cal - convert to procedure call			*/
			x_node [tree] = x_proc;				/* procedure call								*/
			x_arg1 [tree] = 0;					/* takes no arguments							*/
			x_arg2 [tree] = t_rtp;				/* is runt time package call					*/
			x_spec [tree] = shr(temtree, 8);	/* get type returned							*/
			x_info [tree] = gc();				/* and get routine to call						*/
			break;
		}
			
		/* note: other node types are not created by pass 1	*/
		
	}											/* of do case									*/
		
	temtree = tree;								/* save tree									*/
	tree = pop();								/* restore callers tree, in case of recursion	*/
	return (temtree);							/* and return scanned tree						*/
}
	
/* Register optimizing:
.
.  In addition to optimizing the use of index registers, the compiler
.  attempts to optimize the use of the accumulators.  Specifically, two
.  types of optimizing are done:
.
.    1. When a variable is needed in a register, the compiler checks to
.       see if it is already in an allowable register. 
.
.    2. When the compiler needs a pointer to an element of a subscripted
.       variable, the compiler checks to see if a register points to
.       the selected element.  Optimization on statements like:
.
.         x (a + b + c) = x (a + b + c) + 1;
.
.       is performed.
.
.  To perform this optimizing, the compiler uses the array 'TREES' to
.  contain a description of what is in a register.  Routines are used
.  to deallocate the storage associated with a tree, to compare two
.  trees, and so forth. */

static	fixed	trees[9];						/* holds contents of registers					*/
static	fixed	freetr;							/* pointer to next free tree					*/

static	void	tree_free()						/* passed global 'FREETR' - deallocates blocks	*/
{
	static	fixed	tree;
	
	if (freetr == 0) return;					/* already freed - no storage left				*/
		
	push (tree); tree = freetr;					/* restore it									*/
	switch (x_node [tree]) {					/* branch on node type to deallocate			*/
		case 0:
		{										/* dyadic										*/
			freetr = x_arg1 [tree]; tree_free();
			freetr = x_arg2 [tree]; tree_free();
			break;
		}
		case 1:
		{										/* monadic										*/
			freetr = x_arg1 [tree]; tree_free();
			break;
		}
		case 2:
			;									/* constant										*/
			break;
		case 3:
		{										/* variable										*/
			if (x_arg1 [tree] & 1) {			/* subscripted									*/
				freetr = x_arg2 [tree]; tree_free();
			}
			break;
		}
		case 4:
			;									/* proc											*/
			break;
		case 5:
			;									/* reg											*/
			break;
		case 6:
			;									/* temp - has already been sent					*/
			break;
		case 7:
			;									/* pointer reg									*/
			break;
		case 8:
			;									/* dev											*/
			break;
		case 9:
			;									/* x.pvar										*/
			break;
	}
		
	rel (tree);									/* free up storage								*/
	tree = pop();								/* restore tree									*/
}
	
static	void	freeup(							/* free up a register							*/
	fixed	reg)
	
{
	freetr = trees [reg];
	tree_free();
	trees [reg] = 0;
}
	
/* Register optimizing (cont):
.
.   Comparison of tree:
.
.   When loading a register or computing a subscript, the contents
.   of the accumulators are checked to see if one already contains
.   the desired item.
.
.   The following procedure performs that search. */

static	fixed	treept;							/* special resetable push and pop routines		*/
static	fixed	treestk[32];					/* and special stack							*/

static	void	tpush(							/* push a tree									*/
	fixed	t)
	
{
	treestk [treept] = t;
	treept = treept + 1;
}
	
static	fixed	tpop()							/* pop a tree									*/
{
	treept = treept - 1;
	return (treestk [treept]);
}
	
static	fixed	tree_comp(						/* compare two trees							*/
	fixed	tree1,
	fixed	tree2)
{
	static	fixed	t1, t2;
	
	treept = 0;									/* initialize									*/
	
	while (1) {									/* loop forever									*/
	
		if (x_node [tree1] != x_node [tree2]) return (0);	/* not equal									*/
			
		switch (x_node [tree1]) {				/* branch on type								*/
			case 0:
			{									/* dyadic										*/
				if (x_info [tree1] != x_info [tree2]) return (0);	/* not same op									*/
				tpush (x_arg1 [tree1]); tpush (x_arg1 [tree2]);
				tpush (x_arg2 [tree1]); tpush (x_arg2 [tree2]);
				break;
			}
			case 1:
			{									/* monadic										*/
				if (x_info [tree1] != x_info [tree2]) return (0);
				tpush (x_arg1 [tree1]); tpush (x_arg1 [tree2]);
				break;
			}
			case 2:
			{									/* constant										*/
				if (x_arg1 [tree1] != x_arg1 [tree2]) return (0);	/* not same type								*/
				if (x_arg1 [tree1] == t_var) {	/* fixed										*/
					if (x_info [tree1] != x_info [tree2]) return (0);	/* not equal const								*/
				}
				else {
					t1 = x_info [tree1]; t2 = x_info [tree2];
					if (fstk [t1] != fstk [t2]) return (0);
					if (fstk [t1 + 1] != fstk [t2 + 1]) return (0);
				}
				break;
			}
			case 3:
			{									/* variable										*/
				if (x_info [tree1] != x_info [tree2]) return (0);
				if (x_arg1 [tree1] != x_arg1 [tree2]) return (0);
				if (x_arg1 [tree1] & 1) {		/* if subscripted, make sure =					*/
					tpush (x_arg2 [tree1]); tpush (x_arg2 [tree2]);
				}
				break;
			}
				
			case 4:
				return (0);
				break;
			case 5:
				return (0);
				break;
			case 6:
				return (0);
				break;
			case 7:
				return (0);
				break;
			case 8:
				return (0);
				break;
			case 9:
				return (0);
				
				break;
		}										/* of branch on type							*/
			
		if (treept == 0) return (1);			/* if none to pop, then are =					*/
		tree2 = tpop(); tree1 = tpop();			/* pick up next ones							*/
		if (treept > 30) return (0);			/* too complex to search						*/
	}											/* of do forever								*/
}
	
	
static	fixed	tree_var(						/* see if tree references variable				*/
	fixed	tree,
	fixed	sclass,
	fixed	var)
	
{
	treept = 0;									/* initialize stack pointer						*/
	while (1) {									/* examine each node							*/
		switch (x_node [tree]) {				/* branch on type								*/
			case 0:
			{									/* dyadic										*/
				tpush (x_arg1 [tree]); tpush (x_arg2 [tree]);
				break;
			}
			case 1:
				tpush (x_arg1 [tree]);			/* monadic										*/
				break;
			case 2:
				;								/* constant - no way							*/
				break;
			case 3:
			{									/* variable										*/
				if ((x_info     [tree]     == var  )
				&& (shr(x_arg1 [tree], 8) == sclass))
					return (1);					/* references this var							*/
				if (x_arg1 [tree] & 1) tpush (x_arg2 [tree]);	/* check subscr									*/
				break;
			}
			case 4:
				;
				break;
			case 5:
				;
				break;
			case 6:
				;
				break;
			case 7:
				;
				break;
			case 8:
				;
				break;
			case 9:
				;
				break;
		}										/* of branch on type							*/
			
		if (treept == 0) return (0);			/* does not reference variable					*/
		if (treept > 30) return (1);			/* too complex - it might						*/
		tree = tpop();							/* get next one									*/
	}											/* of examine each node							*/
}

/* Expression compiler:
. 
.   The expression compiler takes a binary tree produced by the expression
.   scanner and produces object code to compute the expression and put the
.   result into a register.  The routine is called with a pointer to the tree
.   to be compiled and it returns the register into which the value of the
.   expression has been put.
. 
.   Runtime register usage: 
.  
.   During runtime, registers 4-9 (MIN.PTR.REG to MAX.PTR.REG) are used as
.   variable address pointers.  Since the machine can only access memory
.   through the registers, we will attempt to do a good job of keeping
.   track of which registers are used when.
.  
.   Since all variable addresses are assigned at declare time, the
.   address of a variable is a known constant during compilation.
.   (Note this is NOT true for external references which are relocated
.   in pass3.  REGC is used in conjunction with REGP to solve this
.   incongruity.)
.  
.   The array REGC is 10 words long and holds the contents of the
.   corresponding register.  Obviously, the registers must be freed up 
.   when we jump around and do procedure calls.  We will attempt to
.   keep track of which registers are used by which procedures and
.   to optimize the variable assignments as much as possible. */

/* register allocation definitions */

static	fixed	reg_free = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* free regs									*/
static	fixed	reg_pref;						/* currently preferred registers				*/
static	fixed	reg_cont[9];					/* contents of each reg							*/

static	fixed	bitreg[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};	/* translation of bit to reg 0-3				*/

static	void	accpurg()						/* purge all accumulators						*/
{
	static	fixed	i;
	
	for (i = 0; i <= 3; i++) {
		freeup (regbit [i]);
	}
}
	
static	void	regzap()						/* indicate that all registers contain trash	*/
{
	fixed	i;
	
	regl = 0;									/* indicate all registers zapped				*/
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		regc [i] = 0;							/* index registers don't point to anything anymore	*/
		regl = (regl | regbit [i]);				/* this reg not used							*/
	}
}
	
static	void	regclr(							/* to clear certain registers (i.e., on proc calls )	*/
	fixed	bits)
{
	fixed	i;
	
	regl = (regl | bits);						/* indicate register was cleared				*/
	bits = shr(bits, min_ptr_reg);				/* get regs 4-9 (min.ptr.reg to max.ptr.reg) handy	*/
    
	for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
		if (bits & 1) regc [i] = 0;				/* zap it										*/
		bits = shr(bits, 1);
	}
}
	
static	fixed	getreg(							/* find a register to use, when all are being used	*/
	fixed	nono)								/* bits for register not to use					*/
{
	static	fixed	i, j;						/* look for "oldest" one						*/
	
	j = min_ptr_reg;
	
	while ((nono&regbit[j])!=0) {				/* skip it if disallowed						*/
		j=j+1;
	}
		
    for (i = min_ptr_reg + 1; i <= max_ptr_reg; i++) {
		if ((regloc [i] <= regloc [j])
		&& ((nono&regbit[i])==0))
			j = i;
	}
		
	return (j);									/* j is oldest									*/
}
	
/* Run time register allocation (cont):
.  
.   The routine 'GETVP' is used to generate code that will load
.   a hardware index register with a pointer to a memory location
.   during the program execution.
.  
.   GETVP is passed a relative pointer into the variable area.  Although
.   the absolute location of the variable area is not known until the
.   end of pass3 (just before final object code generation), register
.   allocation can intelligently be done by looking at the relative
.   locations to which they will point during execution.
.  
.   GETVP checks to see if an index register is already pointing to the
.   specified variable area (the contents of the index registers are
.   kept track of in the 'REGC' array during compilation.)  If one
.   register is already pointing to that location, then it is used.
.  
.   If no register points to the specified location, then instructions
.   are emitted that will load the register with the specified value
.   during program execution.  The register to load is selected on 
.   a 'least recently used' algorithm. */

static	fixed	reg_allc(fixed);				/* accumulator allocation						*/

static	fixed	reg1_to_store;					/* accumulators to store						*/
static	fixed	reg2_to_store;					/* while computing auto variable poitner		*/
static	fixed	store_preg;						/* true + store pointed to value rather than register contents	*/

static	fixed	getvp(							/* get a register pointing to a variable location	*/
	fixed	sclass,
	fixed	vloc,
	fixed	nono)
{
	static	fixed	i, j, k, l;					/* note: NONO IS 16-BITS for getvp				*/
	static	fixed	reg1, reg2;
	
	if (_IGE_(vloc, extern_base)) sclass = s_static;	/* force storage class for EXTERNALs			*/
		
	if (sclass == s_temporary) {					/* map temporary based on procedure type (see GTEMP)	*/
		if (in_recursive == 0)					/* if NOT in a recursive procedure				*/
			sclass = s_static;					/* static temporary								*/
		else sclass = s_automatic;				/* automatic temporary							*/
	}											/* of mapping temporaries						*/
		
	/* see if a register already points to the variable in question	*/
	
	j = 0;										/* look for equal or empty reg					*/
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {	/* this loop is very similar to the procedure SENDVP	*/
		if ((regc [i] == vloc) && ((regs [i] == sclass) || (vloc == 0))/* if same location (class irrelevent if searching for free reg)	*/
		&& ((_ILT_(vloc, extern_base)) || (regc [i] == regp [i]))) {	/* it is in a register							*/
			if (vloc == 0)						/* we were looking for an empty reg				*/
				regl = (regl | regbit [i]);		/* assume that we are going to use it			*/
			else {								/* we found its pointer							*/
				if ((regl & regbit [i]) == 0)	/* used in orig form							*/
					regu = (regu | regbit [i]);
			}
			regloc [i] = cur_loc;				/* indicate this is newest register				*/
			return (i);							/* found										*/
		}										/* of in a register								*/
		if ((regc [i] == 0)
		&& ((nono & regbit[i])==0))
			j = i;								/* an empty register found that we can change	*/
	}
		
	/* not there - get another register */
	
	if (j == 0) j = getreg(nono);				/* didn't find a free register - get the oldest (LRU) register	*/
		
	/* see if index register points to the desired location - 1.  use	*/
	/* increment feature if so.						*/
	
	if ((_IGE_(vloc, 2))						/* location 2 (1) or beyond						*/
	&& (_ILT_(vloc, extern_base)))				/* and not an external							*/
	{											/* look for location - 1						*/
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
			if (((ufixed) regc [i] == (ufixed) (vloc-1))			/* location vloc-1								*/
			&& (regs [i] == sclass   )			/* same class (vloc will never = 0)				*/
			&& ((nono & regbit[i])==0))			/* not protected by sap/senvp					*/
			{									/* it is in a register							*/
				if (i==j) {						/* desire to use same register					*/
					if ((regl & regbit [i]) == 0)/* used in orig form							*/
						regu = (regu | regbit [i]);
					regl = (regl | regbit [i]);	/* loaded by changing it						*/
					emita (b_rs | b_ibt | i, b_ca | b_tnv);	/* regi to atnv									*/
					regc[i]=regc[i]+1;			/* incremented									*/
					regloc [i] = cur_loc;		/* last used here								*/
					return (i);					/* use this guy									*/
				}
				else {							/* copy to another to preserve pointers			*/
					if ((regl & regbit [i]) == 0)/* used in orig form							*/
						regu = (regu | regbit [i]);
					regl = (regl | regbit [i]);	/* i is changed by increment					*/
					regl = (regl | regbit [j]);	/* j is changed by write						*/
					emita (b_rs | b_ibt | i, b_rd | j);	/* regi to rj									*/
					regc [j] = regc[i];			/* reg j now contains what						*/
					regs [j] = regs[i];			/* reg i did.  update info						*/
					regp [j] = regp[i];			/* but leave regloc as it						*/
					regloc [j] = regloc[i];		/* was since we did not reference variable at that location	*/
					regc[i] = regc[i]+1;		/* incremented									*/
					regloc [i] = cur_loc;		/* last used here								*/
					return (i);
				}
			}									/* of in a register								*/
		}
	}
		
	/* check for index register 2 locations back	*/
	/* if recursive variable						*/
	
	if ((_IGE_(vloc, 3))						/* location 3 (2) or beyond						*/
	&& (_ILT_(vloc, extern_base))				/* and not an external							*/
	&& (sclass == s_automatic))					/* for now only for recv's						*/
	{											/* look for location - 1						*/
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {
			if (((ufixed) regc [i] == (ufixed) (vloc-2))			/* location vloc-2								*/
			&& (regs [i] == sclass   )			/* same class (vloc will never = 0)				*/
			&& ((nono & regbit[i])==0))			/* not protected by sap/senvp					*/
			{									/* it is in a register							*/
				if (i==j) {						/* desire to use same register					*/
					if ((regl & regbit [i]) == 0)/* used in orig form							*/
						regu = (regu | regbit [i]);
					regl = (regl | regbit [i]);	/* loaded by changing it						*/
					emita (b_rs | b_ibt | i, b_ca | b_tnv);	/* regi to atnv									*/
					emita (b_rs | b_ibt | i, b_ca | b_tnv);	/* regi to atnv									*/
					regc[i]=regc[i]+2;			/* incremented									*/
					regloc [i] = cur_loc;		/* last used here								*/
					return (i);					/* use this guy									*/
				}
				else {							/* copy to another to preserve pointers			*/
					if ((regl & regbit [i]) == 0)/* used in orig form							*/
						regu = (regu | regbit [i]);
					regl = (regl | regbit [i]);	/* i is changed by increment					*/
					regl = (regl | regbit [j]);	/* j is changed by write						*/
					emita (b_rs | b_ibt | i, b_rd | j);	/* regi to rj									*/
					emita (b_rs | b_ibt | i, b_ca | b_tnv);	/* regi to atnv									*/
					regc [j] = regc[i];			/* reg j now contains what						*/
					regs [j] = regs[i];			/* reg i did.  update info						*/
					regp [j] = regp[i];			/* but leave regloc as it						*/
					regloc [j] = regloc[i];		/* was since we did not reference variable at that location	*/
					regc[i] = regc[i]+2;		/* incremented twice							*/
					regloc [i] = cur_loc;		/* last used here								*/
					return (i);
				}
			}									/* of in a register								*/
		}
	}
		
	/* emit object code (blah!!) to load pointer	*/
	
	if (vloc != 0)								/* emit a variable pointer record (register J points to var location)	*/
	switch (sclass) {							/* branch on storage class						*/
	
		case 0:
			em_vpt (sclass, vloc, b_rd | j);		/* static - emit a variable pointer				*/
			
			break;
		case 1:
		{										/* automatic - relative to stack				*/
			
			/* if reg1.to.store is nonzero,  then we are being called */
			/* from reg.allc to get a pointer in an index register,   */
			/* and store the contents of reg1.to.store in that memory */
			/* location                                               */
			
			/* object codes:
			
			            store 1 reg in temp:       r0   to  r11      move accum to temp index reg
			                                       r12  to  loa0     compute stack
			                                       im() to  add0     pointer
			                                       r11  to  mr0      store orig accum in temp
			                                       r0   to  r11      move pointer to ixr
			
			            store 1 preg in temp:      r0   to  r11      move accum to temp index reg
			                                       r12  to  loa0     compute stack
			                                       im() to  add0     pointer
			                                       mr11 to  mr0      move pointed to item to temp
			                                       r0   to  r11      move pointer to ixr
			
			            store 2 regs in temp:      r0   to  r11
			                                       r12  to  loa0
			                                       im() to  add0
			                                       r11  to  mr0
			                                       r0i  to  r11
			                                       r1   to  mr0
			
			            store 2 word preg
			            in temporary:              r0    to  r11
			                                       r12   to  loa0
			                                       im()  to  add0
			                                       mr11I to  mr0i
			                                       mr11I to  mr0i
			                                       im(2) to  sub0
			                                       r0    to  r11   */
			
			if (reg1_to_store!=0)				/* called from reg.allc - store these registers while computing automatic variable poitner	*/
			{
				
				i = x_get();					/* get optimizing block							*/
				x_node[i] = x_pvar;				/* pointer to variable							*/
				x_arg1[i] = shl (sclass,8);		/* store class									*/
				x_arg2[i] = 0;					/* x.info is set below							*/
				
				reg1=bitreg[reg1_to_store];
				reg2=bitreg[reg2_to_store];
				
				emita (b_rs | reg1, b_rd | j);	/* reg1 to regj									*/
				em_vpt(sclass, vloc, b_rd | reg1);	/* vpt  to reg1									*/
				
				if (reg2_to_store!=0)
				{								/* two registers/words to store					*/
					
					if (store_preg != 0)		/* double word x.preg to store					*/
					{
						emita (b_ms | b_ibt | j, b_md | b_ibt | reg1);
						emita (b_ms | b_ibt | j, b_md | b_ibt | reg1);
						emitc (-2,b_ad+b_add+reg1);						/* subtract 2 to correct for increments			*/
						emita (b_rs | reg1, b_rd | j);
						x_info[i] = vloc;
					}
					else {												/* two registers to store						*/
						emita (b_rs | j, b_md  | reg1);					/* regj to mreg1								*/
						emita (b_rs | b_ibt | reg1, b_rd | j);			/* reg1i to regj								*/
						emita (b_rs | reg2, b_md  | reg1);				/* reg2 to mreg1								*/
						x_info[i] = vloc+1;								/* note increment above							*/
					}
				}
					
				else {							/* single word									*/
					if (store_preg != 0)		/* single word preg								*/
					{
						emita (b_ms | j, b_md | reg1);					/* mregj to mreg1								*/
						emita (b_rs | reg1, b_rd | j);					/* reg1 to regj									*/
						x_info[i] = vloc;
					}
					else {
						emita (b_rs | j, b_md | reg1);					/* regj to mreg1								*/
						emita (b_rs | reg1, b_rd | j);					/* reg1 to regj									*/
						x_info[i] = vloc;
					}
				}
					
				freeup(reg1_to_store);			/* clean up tree								*/
				trees [reg1_to_store] = i;		/* indicate it points							*/
				reg1_to_store=0;				/* indicate stored								*/
				reg2_to_store=0;
				store_preg   =0;
			}
				
			else {								/* not called from reg.allc - get a register to do computation	*/
				
				/* perform optimization - see if one of the accumulators */
				/* allready points to the stack.   add in a delta offset */
				/* to save an instruction or two if so:                  */
				
				i=b_ac0;
				k=0;
				while ((i <= b_ac3) && (k==0)) {
					l = trees[i];				/* see if we know contents						*/
					if (l != 0) {										/* nonzero means we do							*/
						if ((x_node [l] == x_pvar)						/* type											*/
						&& (x_arg1 [l] == shl(sclass, 8))				/* class										*/
						&& (((_IGE_(x_info [l], temp_base)) && (_IGE_(vloc, temp_base)))/* temporary or variable						*/
						||   ((_ILT_(x_info [l], temp_base)) && (_ILT_(vloc, temp_base)))))
						{
							k=i;										/* indicate found								*/
							if (vloc != x_info[l])						/* add in offset if not zero.   some times is zero when using floating point since index registers get incremented	*/
								emitc(vloc-x_info[l],b_ad+b_add+bitreg[k]);
							emita (b_rs | bitreg[k], b_rd | j);			/* move to pointer reg							*/
						}
					}
					i=shl(i,1);
				}
					
				if (k==0) {						/* no accumulator points to stack - get one		*/
					push(sclass); push(vloc);	/* save variables in case						*/
					push(nono ); push(   j);	/* reg.allc needs a v ptr						*/
					push(reg_pref);				/* save preferences								*/
					reg_pref = b_ac2 | b_ac3;	/* most preferred								*/
					regc [j] = vloc;			/* mock up indication of register contents		*/
					regs [j] = 9999+sclass;		/* so that we do not use this same register		*/
					regp [j] = vloc;			/* if reg.allc calls us							*/
					regloc [j] = cur_loc;		/* last used here								*/
					k = reg_allc (nono);		/* get an accumulator							*/
					i = bitreg   [k];
					reg_pref = pop();
					j = pop(); nono = pop(); vloc = pop(); sclass = pop();
					em_vpt (sclass, vloc, b_rd | i);	/* get variable pointer							*/
					emita (b_rs | i, b_rd | j);	/* move to pointer reg							*/
				}
					
				freeup(k);						/* nothing we keep track of						*/
				i = x_get();					/* get optimizing block							*/
				x_node[i] = x_pvar;				/* pointer to variable							*/
				x_arg1[i] = shl (sclass,8);		/* store class									*/
				x_arg2[i] = 0;
				x_info[i] = vloc;
				trees [k] = i;					/* indicate it points							*/
			}
			break;
		}										/* of automatic									*/
			
	}											/* of emit a variable pointer record			*/
		
	regc   [j] = vloc;							/* save for future reference					*/
	regs   [j] = sclass;
	regp   [j] = vloc;
	regloc [j] = cur_loc;						/* last used here								*/
	regl = (regl | regbit [j]);					/* keep track of which are loaded				*/
	
	return (j);									/* and return the register						*/
}
	
/* Send a variable pointer to a destination.  This is quite similar to
.   GETVP, except the pointer is to be sent to a known destination rather
.   than to a free index register.
.
.   DEST is restricted to loads of arithmetic accumulators or variable
.   pointer references. */

static	void	sendvp(							/* send variable pointer to destination			*/
	fixed	sclass,
	fixed	vloc,
	fixed	dest,
	fixed	nono)
{
	static	fixed	i, j;
	
	if (vloc == 0) er_cerr ((char *) "sendvp");
		
	if (_IGE_(vloc, extern_base)) sclass = s_static;	/* force storage class for EXTERNALs			*/
	if (sclass == s_temporary) {					/* map temporary based on procedure type (see GTEMP)	*/
		if (in_recursive == 0)					/* if NOT in a recursive procedure				*/
			sclass = s_static;					/* static temporary								*/
		else sclass = s_automatic;				/* automatic temporary							*/
	}											/* of mapping temporaries						*/
		
    for (i = min_ptr_reg; i <= max_ptr_reg; i++) {	/* see if it's already in an index register (similar to GETVP)	*/
		if ((regc [i] == vloc)
		&&  (regs [i] == sclass)					/* see if same location							*/
		&&  ((_ILT_(vloc, extern_base)) || (regc [i] == regp [i])))
		{										/* if local or unchanged						*/
			if ((regl & regbit [i]) == 0) regu = (regu | regbit [i]);	/* used on orig form							*/
			regloc [i] = cur_loc;				/* and save location last used					*/
			emita (b_rs + i, dest);				/* send it										*/
			return;
		}
	}
		
	/* isn't already in a register */
	
	if ((sclass == s_static)						/* static variable								*/
	||  ((dest | b_amsk) == (b_ad | b_loa | b_amsk))/* or accum load								*/
	||  ((dest | b_amsk) == (b_rd         | b_amsk)))/* or accum dest								*/
		em_vpt (sclass, vloc, dest);				/* just emit the variable pointer				*/
	else emita  (b_rs + getvp (sclass, vloc, nono), dest);	/* get pointer and send it (assume DEST was used recently).  optimizing code will never find it becuase dest will always point to a static variable	*/
		
}
	
/* Expression compiler - temporary allocation:
.  
.   During the processing of arithmetic expressions, temporaries are
.   sometimes needed to store intermediate arithmetic results.
.   Temporary memory allocation and deallocation is handled by the
.   following routines:
*/

#define	fxd				0						/* zero is pointer to fixed temps				*/
#define	flt				1						/*  one is pointer to float temps				*/

static	fixed	tlist[flt + 1];					/* holds pointers to temps						*/

static	fixed	gtemp(							/* pass type - fixed or float					*/
	fixed	typ)
{
	static	fixed	temp;						/* will become pointer							*/
	
	if (tlist [typ] == 0) {						/* if no temps of type,  then get a block		*/
		if (_IGE_(ram, extern_base))			/* expression too complicated					*/
			er_etc ((char *) "too many temps");
			
		temp = ram;								/* allocate in ram region						*/
		ram = ram + 1 + typ;					/* allocate memory								*/
	}
	else {										/* there is a free one - use it					*/
		temp = e_loc [tlist [typ]];				/* get pointer to block							*/
		e_rel (tlist [typ]);					/* and free up block holding this temp			*/
		tlist [typ] = e_point [tlist [typ]];	/* and move down list							*/
	}
		
	return (temp);								/* and that is pointer to memory location,  absolute	*/
}
	
static	void	ptemp(							/* free up a temporary of type x				*/
	fixed	temp,
	fixed	typ)
{
	static	fixed	t;
	t = e_get();								/* get a block									*/
	e_loc [t] = temp;
	e_point [t] = tlist [typ];
	tlist [typ] = t;							/* save memory pointer, set pointer, update list	*/
}
	
static	void	freetemp()						/* free up all temporary blocks					*/
{
	static	fixed	i, j;
	for (i = 0; i <= 1; i++) {					/* free up temporaries							*/
		j = tlist [i];
		while (j != 0) {
			e_rel (j);
			j = e_point [j];
		}
		tlist [i] = 0;
	}
}
	
static	void	pushtemp()						/* call to push temps							*/
{
	push (tlist [1]); push (tlist [0]);
	tlist [0] = 0; tlist [1] = 0;
}
	
static	void	poptemp()						/* call to restore temps						*/
{
	tlist [0] = pop(); tlist [1] = pop();
}
	
/* Routine SENDIT:
.  
.   The 'SENDIT' routine is called to generate object code that will
.   move one data element from a source (register, memory, etc.) to
.   any destination.
.  
.   The source is represented by a 'node block', which was first
.   generated by the 'EXPR' routine (pass1) and then later massaged
.   by the 'COMPUTE' routine (pass2).
.  
.   The 'SENDIT' routine is only for fixed point variables, and
.   assumes that all the nodes have been massaged with the
.   'COMPUTE' procedure before 'SENDIT' is called. */

static	fixed	d4used, d4block;				/* keep track of what is in D4					*/
static	fixed	d5used, d5block;				/* keep track of what is in D5					*/
static	fixed	divarg, upperblock;				/* used to locate upper bits					*/

static	void	sendit(							/* node, destination - pass registers not to use	*/
	fixed	node,
	fixed	dest,
	fixed	nono)
{
	static	fixed	reg, type, info;
	static	fixed	i, k, sou, sclass;
	
	type = x_node [node];						/* get type										*/
	info = x_info [node];						/* and info										*/
	
	switch (type) {								/* branch on node type							*/
	
		case 0:
			;									/* dyadic operators have been computed			*/
			break;
		case 1:
			;									/* monadic operators have been computed			*/
			
			break;
		case 2:
			emitc (info, dest);					/* constant										*/
			
			break;
		case 3:
		{										/* variable - not subscripted (they are X.PREGS by now)	*/
			sclass = shr(x_arg1 [node], 8);		/* get storage sclass							*/
			i = 1; sou = 0;
			while ((i < 16) && (sou == 0)) {
				k = trees [i];
				if (k != 0) {
					if ((x_node [k] == x_var)	/* register contains a variable					*/
					&& (x_info [k] == info )	/* at same location								*/
					&& (x_arg1 [k] == (t_var | shl(sclass, 8))))/* same sclass									*/
						sou = b_rs + bitreg [i];						/* use variable in register						*/
				}
				i = shl(i, 1);
			}
			if (sou == 0) {						/* must fetch from memory						*/
				reg = getvp (sclass, info, nono);
				emita (b_ms + reg, dest);
			}
			else emita (sou, dest);				/* else register to destinatin					*/
			break;
		}										/* of variable									*/
			
		case 4:
			;
			
			break;
		case 5:
		{
			emita (b_rs + bitreg [info], dest);
			reg_free = (reg_free | info);
			break;
		}
			
		case 6:
		{										/* temp											*/
			reg = getvp (s_temporary, info, nono);
			emita  (b_ms + reg, dest);
			ptemp  (info, fxd);					/* and free up temporary						*/
			if (dest == b_md + reg) er_emes1 ((char *) "sent-3");
			break;
		}										/* temp											*/
			
		case 7:
		{										/* pointer register								*/
			emita (b_ms + bitreg [info], dest);
			reg_free = (reg_free | info);
			break;
		}										/* pointer register								*/
			
		case 8:
		{										/* device to read								*/
			emita (info, dest);					/* send device to dest							*/
			if (info == 4) d4used = 0;
			if (info == 5) d5used = 0;
			break;
		}										/* device to read								*/
			
		case 9:
		{										/* pointer to variable - not used with sendit	*/
			er_cerr((char *) "Sendit/X.pvar");			/* compiler system error						*/
			break;
		}
			
	}											/* of do case									*/
}
	
/* Fsendit:
.  
.   The routine 'FSENDIT' is used to generate object code that
.   will transfer a floating point number between a source 
.   and a destination.
.  
.   The routine is passed an expression node (created by pass1:EXPR 
.   and modified by pass2:COMPUTE) and two 8-bit destinations. */

static	fixed	ffpr[] = {0, b_ac0, b_ac2};		/* first floating point register				*/
static	fixed	sfpr[] = {0, b_ac1, b_ac3};

/* Note:  fsendit is passed NONO registers where NONO contains
   bits for fixed point accumulators (ac0-ac3) and the index
   registers (r4 - r11) */

static	void	fsendit(						/* pass 2 dests									*/
	fixed	node,
	fixed	dest1,
	fixed	dest2,
	fixed	nono)
{
	static	fixed	reg, type, info, sclass;
	static	fixed	reg3;
	
	type = x_node [node];						/* get type of node								*/
	info = x_info [node];						/* and get local info							*/
	
	switch (type) {								/* branch on type of floating point node		*/
		case 0:
			;
			break;
		case 1:
			;
			
			break;
		case 2:
		{										/* floating point constant to destination		*/
			emitc (fstk [info], dest1);			/* send pout first								*/
			emitc (fstk [info + 1], dest2);		/* and second									*/
			fstk [info] = (fixed) 0x8000;		/* and indicate free							*/
			break;
		}
			
		case 3:
		{										/* variable										*/
			sclass = shr(x_arg1 [node], 8);		/* storage sclass for vars						*/
			reg = getvp (sclass, info, nono);	/* get pointer to variable,  no matter what type	*/
			if ((dest1 & 15) == reg) er_emes1 ((char *) "fsen-1");
			if ((dest2 & 15) == reg) er_emes1 ((char *) "fsen-2");
			if ((x_arg1 [node] & 0x00FF) == t_fvar) {	/* plain floating variable - not pointer		*/
				emita (b_ms + b_ibt + reg, dest1);
				emita (b_ms + b_ibt + reg, dest2);
				regl = (regl | regbit [reg]); regc [reg] = regc [reg] + 2;	/* and increment register						*/
			}
			else {								/* must be pointer to variable					*/
				reg3 = getvp (0, 0, nono | regbit[reg]);	/* get empty index register						*/
				emita (b_ms + reg, b_rd + reg3);	/* get pointer									*/
				emita (b_ms + b_ibt + reg3, dest1);
				emita (b_ms + b_ibt + reg3, dest2);
				regl = (regl | regbit [reg3]); regc [reg3] = 0;	/* clean up temp register						*/
			}
			break;
		}										/* of variable									*/
			
		case 4:
			;
			
			break;
		/* handle floating nodes that are registers, pointer registers, and
		      .  temporaries.	*/
		
		case 5:
		{										/* floating point register						*/
			reg3 = ffpr [info]; emita (b_rs + bitreg [reg3], dest1);	/* send first									*/
			reg_free = (reg_free | reg3);		/* and it is now free							*/
			reg3 = sfpr [info]; emita (b_rs + bitreg [reg3], dest2);	/* send other floating register also			*/
			reg_free = (reg_free | reg3);		/* and now that register is freed up			*/
			break;
		}
			
		case 6:
		{										/* tempr										*/
			reg = getvp (s_temporary, info, nono);	/* get pointer to temp							*/
			emita (b_ms + b_ibt + reg, dest1);	/* send it										*/
			emita (b_ms + b_ibt + reg, dest2);	/* and lower half,  from memory to dest			*/
			regl = (regl | regbit [reg]); regc [reg] = regc [reg] + 2;	/* and we incremented it						*/
			ptemp (info, flt);					/* and scratch one floating point temp			*/
			break;
		}
			
		case 7:
		{										/* pointer register - points to variable pair	*/
			emita (b_ms + b_ibt + bitreg [info], dest1);	/* send first word								*/
			emita (b_ms + b_ibt + bitreg [info], dest2);	/* send second word								*/
			reg_free = (reg_free | info);		/* pointer register is now free					*/
			break;
		}
			
		case 8:
		{										/* x.pvar										*/
			er_cerr((char *) "Fsendit/X.pvar");			/* compiler system error						*/
			break;
		}
			
	}											/* of floating point case - will get do case error if compiler error	*/
}												/* and done with it all							*/
/* Runtime register allocation:
.  
.  The routine 'REG.ALLC' is called to allocate one of the
.  four hardware accumulators (vs. index registers).
.  
.  'REG.ALLC' is passed a bit encoded word (one bit for each register)
.  that indicates the registers that must not (!!##$$##@@!!) be used.
.  
.  If there are no desired registers available, one register is selected,
.  its current contents are stored in a temporary, and then the
.  register is made available.
.  
.  The register is always free after calling 'REG.ALLC'.
*/

static	fixed	reg_allc(						/* pass registers not to use					*/
	fixed	nono)
{
	static	fixed	reg, temp;
	static	fixed	node, reg1, reg2, ixr;
	static	fixed	sou1, sou2, fva;
	
	static	fixed	reg_choose[] = {0, b_ac0, b_ac1, b_ac0, 
	b_ac2, b_ac0, b_ac1, b_ac0, 
	b_ac3, b_ac0, b_ac1, b_ac0, 
	b_ac2, b_ac0, b_ac1, b_ac0};
	static	fixed	ofpr[] = {0, b_ac1, b_ac0, 0, b_ac3, 0, 0, 0, b_ac2};	/* other reg									*/
	
	reg = (reg_pref & (~ nono) & 15);			/* compute prefered and not disallowed			*/
	if (reg == 0) reg = ((~ nono) & 15);		/* if none, then compute those not disallowed	*/
		
	if ((reg & reg_free) != 0)					/* use it										*/
		return (reg_choose [reg & reg_free]);	/* if free, then done							*/
		
	if (((~ nono) & reg_free) != 0)				/* but use non-preferred register instead of storing one in a temp	*/
		return (reg_choose [(~ nono) & reg_free]);
		
	reg = reg_choose [reg];						/* else pick one random register				*/
	
	/* force register into temp */
	
	node = reg_cont [reg];						/* get pointer to tree node that represents what is in register	*/
	fva = ((x_arg1 [node] & t_fvar) != 0);
	
	/* see if the register actually points to the desired item,  rather
	      than containing the desired item.  if so,  move the desired item
	      (memory) instead of the register */
	
	
	reg1 = reg;									/* initialize variables to						*/
	reg2 = 0;									/* most common case								*/
	store_preg = 0;
	
	if (x_node [node] == x_preg) {				/* pointer register								*/
		sou1 = b_ms + bitreg [reg];
		sou2 = sou1;
		reg1_to_store = reg1;					/* pass info to getvp in case he				*/
		reg2_to_store = reg2;					/* needs an accumulator							*/
		if (fva & 1) {
			sou1 = (sou1 | b_ibt);				/* increment first one if floating				*/
			reg2_to_store = reg1_to_store;		/* make sure reg2.to.store is nonzero			*/
		}
		store_preg = 1;
	}
	else {										/* must be register								*/
		if (fva & 1) {
			if (ofpr [reg] < reg)
			{ 	reg1 = ofpr [reg]; reg2 = reg; }
			else { reg1 = reg; reg2 = ofpr [reg]; }	/* must store in proper order					*/
		}
		sou1 = b_rs + bitreg [reg1];
		sou2 = b_rs + bitreg [reg2];			/* second source								*/
		reg1_to_store = reg1;					/* pass info to getvp in case he				*/
		reg2_to_store = reg2;					/* needs an accumulator							*/
	}
		
	/*  In the above code, we have set up REG1 and REG2 to indicate which
	   .   register(s) is/are to be stored in a temporary (fixed or floating)
	   .   location.  The variables SOU1 and SOU2 have been set up depending
	   .   on whether the register contains data or a pointer to data.
	   .  
	   .   Now emit the instructions to store the register(s) or pointed to 
	   .   values in a temporary (fixed or floating) location. */
	
	temp = gtemp (fva);							/* get a fixed or floating temporary			*/
	
	ixr  = getvp (s_temporary, temp, nono & 15);	/* and get pointer to temporary					*/
	
	if (reg1_to_store != 0) {					/* store here if getvp did not					*/
		if (fva & 1) {
			emita (sou1, b_md | b_ibt | ixr);
			emita (sou2, b_md | b_ibt | ixr);
			regl = (regl | regbit [ixr]); regc [ixr] = regc [ixr] + 2;
		}
		else emita (sou1, b_md | ixr);			/* else store fixed point						*/
		reg1_to_store = 0;
		reg2_to_store = 0;
		store_preg    = 0;
	}
		
	x_node [node] = x_temp;
	x_info [node] = temp;
	reg_free = (reg_free | reg1 | reg2);		/* free up regs and adjust node					*/
	freeup (reg1);
	
	return (reg);								/* done with allocation							*/
}
	
/* Lllin.Reg:
.  
.   The routine 'IN.REG' is used to load the contents of a node block
.   into a fixed point register.
.  
.   IN.REG is passed a node block pointer (in node) to a block
.   that was generated by the pass1 expression routine.
.  
.   IN.REG is also passed a bit encoded word that indicates which
.   registers are not to be used.
.  
.   IN.REG uses the REG.ALLC routine to find a free register,
.   and then emits code to load the contents into a register.
.
.   The routine first checks the contents of the registers to see if one of
.   the registers contains the constant or variable that is to be loaded in
.   the register.  If one is found, it is used.   
.
.   ****** NOTE: ****** If the register contains a variable, and that
.   variable is a subscripted variable, the register actually contains a 
.   pointer to that element.
.    
.   The global variable 'ZFLAGS' is used to keep track of which
.   register contents corresponds to the Z and M flags */


static	fixed	in_reg(							/* passing it a node, and verboten regs			*/
	fixed	node,
	fixed	nono)
{
	static	fixed	reg, type, info;
	static	fixed	j, k;
	
	type = x_node [node];
	info = x_info [node];						/* get data handy								*/
	
	if ((type == x_reg) && ((info & nono) == 0)) return (info);	/* already is in an ok reg						*/
		
	reg = 0;									/* no register found							*/
	if ((type == x_const) || (type == x_var)) {	/* see if var or const in reg					*/
		j = 1;
		while ((j < 16) && (reg == 0)) {		/* check 4 accums								*/
			if ((j & reg_free & (~ nono)) != 0) {
				k = trees [j];					/* see what is in the register now				*/
				if (k != 0) {					/* if anything									*/
					if (tree_comp (node, k) & 1) reg = j;				/* found										*/
				}
			}
			j = shl(j, 1);
		}										/* of check 4 accums							*/
	}											/* of var or const								*/
		
	if (reg == 0) {								/* not there - must load						*/
		
		if ((type == x_preg)					/* if node is a pointer register				*/
		&& ((nono & info) == 0))				/* and not disallowed							*/
			reg_free = (reg_free | info);		/* free up ptr reg here so reg.allc can use it. we know reg.allc will not try to store something in a recursive temp	*/
			
		reg = reg_allc (nono);					/* find free or force temp reg now				*/
		
		type = x_node [node];					/* look up node type and info again				*/
		info = x_info [node];					/* since it may be a temporary now				*/
		
		sendit (node, b_ad + bitreg [reg], nono & 15);	/* and load pointer there						*/
		
	}
		
	reg_free = (reg_free & (~ reg));			/* register is no longer free					*/
	freeup (reg);								/* ealier contents is gone						*/
	
	if (type == x_reg) {						/* was a register - move tree entry				*/
		trees [reg] = trees [info]; trees [info] = 0;	/* record movement								*/
	}
		
	if ((type == x_const) || (type == x_var)) {	/* constant or variable							*/
		j = x_get(); trees [reg] = j;			/* allocate block								*/
		x_node [j] = type; x_info [j] = info;
		x_arg1 [j] = x_arg1 [node]; x_arg2 [j] = x_arg2 [node];
	}
		
	reg_cont [reg] = node; x_node [node] = x_reg;
	x_info [node] = reg; x_arg1 [node] = t_var;
	
	return (reg);								/* which register								*/
}
	
/* Lllfin.Reg:
.  
.   The FIN.REG routine is called to load a floating point
.   expression into a register.
.  
.   It is passed a pointer to the node block and a bit encoded word that
.   represents the registers that must not be used.
.  
.   FIN.REG uses the 'REG.ALLC' routine to allocate a floating point
.   register should the need arise.
.
.   Note:  FPR0 = AC0 and AC1; FPR1 = AC2 and AC3 */

static	fixed	fin_reg(						/* pass node and no good registers				*/
	fixed	node,
	fixed	nono)
{
	static	fixed	reg, type, info;
	static	fixed	reg1, reg2, reg3;
	static	fixed	dreg;
	
	static	fixed	tab1[] = {0, 0, 0, b_ac0, 0, 0, 0, b_ac0, 0, 0, 0, b_ac0, b_ac1, b_ac1, b_ac1, b_ac0 | b_ac1};	/* convert REG.FREE to floaters					*/
	static	fixed	tab2[] = {0, b_ac0, b_ac1, b_ac0};	/* convert free to free							*/
	
	type = x_node [node];
	info = x_info [node];
	
	if ((type == x_reg) && ((info & nono) == 0)) return (info);	/* is in an ok register							*/
		
	/* allocate registers:							*/
	
	if ((type == x_preg)						/* if node is a pointer register				*/
	&& (in_recursive == 0))						/* and we are not prone to recursive temporaries	*/
	{											/* free up pointer register for use				*/
		if ((info == b_ac1) || (info == b_ac3)) reg_free = (reg_free | info);	/* free up anyways if ac1 or ac3				*/
		else if ((tab1 [reg_free & 15] & (~ nono) & reg_pref) == 0)
			reg_free = (reg_free | info);		/* free up ac0, 2 only if rest nogo				*/
	}
		
	reg3 = tab1 [reg_free & 15];				/* see if any floating registers are free		*/
	reg = (reg_pref & (~ nono) & 3);			/* select preferred non-forbidden register		*/
	
	if (reg == 0) reg = ((~ nono) & 3);			/* if preferred is not, then get any			*/
	if ((reg & reg3) != 0) dreg = tab2 [reg & reg3];	/* get one available ones						*/
	else dreg = tab2 [reg];						/* else must find one							*/
		
	reg1 = ffpr [dreg]; reg2 = sfpr [dreg];		/* select our two registers to hold floating number	*/
	
	/*   
	   .   In the above code, we have selected two registers (either AC0-AC1 or
	   .   AC2-AC3) in which to load a floating point variable.
	   .   
	   .   Now emit the instructions to load the floating point number 
	   .   into the register pair. */
	
	if ((type == x_preg) && (reg1 == info)) {	/* check for pointer in first register			*/
		reg_allc (~ reg2);						/* free up reg2.								*/
		emita (b_rs + bitreg [reg1], b_rd + bitreg [reg2]);	/* move pointer to reg2 in this special case	*/
		info = reg2; x_info [node] = reg2;
	}
		
	else {										/* else free up the two registers				*/
		reg_allc (~ reg1);
		reg_allc (~ reg2);
	}
		
	type = x_node [node];						/* look up node type again						*/
	info = x_info [node];						/* since reg.allc may have stored it			*/
	
	fsendit (node, b_ad + bitreg [reg1], b_ad + bitreg [reg2], reg1);	/* and load - ok to use reg2 for recursive variable pointer, since it is loaded last	*/
	
	freeup (reg1); freeup (reg2);
	reg_free = (reg_free & (~ reg1) & (~ reg2));
	reg_cont [reg1] = node; reg_cont [reg2] = node;
	x_node [node] = x_reg; x_info [node] = dreg;	/* type, which one								*/
	x_arg1 [node] = t_fvar;						/* type of node is floating variable register	*/
	
	return (dreg);								/* and return which one we put it in			*/
}
	
/* Lllexpression compiler - FIX and FLOAT:
.  
.   The following routines (FIX, FLOAT) take a node as an argument, and
.   return such that the node is a fixed or floating node, as appropriate.
.  
.   Always call COMPUTE before calling FIX or FLOAT. */

static	void	fix(
	fixed	node)
{
	static	fixed	sign, inf1, inf2, exp, pt;
	static	fixed	ff;							/* fudge factor - detects int (-1.1) = -2		*/
	
	if ((x_arg1 [node] & t_fvar) == 0) return;	/* is allready fixed point						*/
		
	if (x_node [node] == x_const) {				/* floating constant							*/
		pt = x_info [node];						/* extract pointer from doen					*/
		inf1 = fstk [pt]; inf2 = fstk [pt + 1];	/* and get 32-bits								*/
		sign = (shr(inf1, 15) & 1);				/* extract sign bit								*/
		exp = (inf2 & 0x007F);					/* and extract exponent							*/
		ff = 1;									/* and assume ok								*/
		inf1 = (inf1 & (fixed) 0x7FFF);			/* isolate mantissa								*/
		inf2 = (inf2 & (fixed) 0xFF80);			/* and isolate man lsb							*/
		if (inf1 != 0) {						/* if something to normalize,  then do it		*/
			while (exp < 64 + 31) {				/* and loop until ready							*/
				if (inf2 & 1) ff = 0;			/* clear kluge flag if should					*/
				inf2 = shr(inf2, 1);			/* shift right									*/
				if (inf1 & 1) inf2 = (inf2 | (fixed) 0x8000);	/* propagate carry if should					*/
				inf1 = shr(inf1, 1);			/* and shift this right							*/
				exp = exp + 1;					/* if reduce mantissa, increase exponent for same result	*/
			}
			if (sign & 1) inf2 = (~ inf2) + ff;	/* negate if minus sign							*/
		}
		fstk [pt] = (fixed) 0x8000;						/* and done with FSTK							*/
		x_arg1 [node] = t_var; x_info [node] = inf2;	/* and is now fixed								*/
	}											/* of constant									*/
	else {										/* not a constant								*/
		fin_reg (node, ~ b_ac0);				/* must get in AC0 for fix						*/
		reg_allc (~ b_ac2); reg_allc (~ b_ac3);	/* free up all regs								*/
		em_rtp (l_fix);							/* rtp call to fix routine						*/
		accpurg();								/* indicate all registers meaningless			*/
		x_arg1 [node] = t_var;					/* regular variable in register now				*/
		x_info [node] = b_ac0;					/* here											*/
		reg_free = (b_ac1 | b_ac2 | b_ac3);		/* all free										*/
	}											/* of not a constant							*/
}
	
/* Lllroutine FLOAT:
.  
.   The FLOAT routine is used to generate code that will 
.   convert a fixed point expression to floating point.
.  
.   It is passed the node and returns with the node 
.   equal to floating point. */

static	void	floatme(
	fixed	node)
{
	static	fixed	sign, inf1, inf2, exp;
	static	fixed	info;						/* temp info									*/
	
	if ((x_arg1 [node] & t_fvar) != 0) return;	/* allready floating							*/
		
	if (x_node [node] == x_const) {				/* check for fixed point constant				*/
		info = x_info [node];					/* get current value							*/
		sign = (shr(info, 15) & 1);				/* extract sign bit								*/
		if (sign & 1) info = -info;
		inf2 = info; inf1 = 0;					/* initialize									*/
		exp = 64 + 31;							/* start here - shl 30 times gives 040, 65 from 1	*/
		
		if (inf2 != 0) {						/* float it										*/
			while ((inf1 & (fixed) 0x4000) == 0) {
				inf1 = shl(inf1, 1);			/* shift left									*/
				if ((inf2 & (fixed) 0x8000) != 0) inf1 = (inf1 | 1);	/* or in										*/
				inf2 = shl(inf2, 1);			/* 16 bits										*/
				exp = exp - 1;					/* and reduce exponent for same					*/
			}
			inf1 = (inf1 | shl(sign, 15));				/* or in sign bit								*/
			inf2 = ((inf2 & (fixed) 0xFF80) | exp);		/* or in exponent								*/
		}
			
		info = fstr (inf1, inf2);				/* store in stack, get ponter					*/
		x_arg1 [node] = t_fvar; x_info [node] = info;
	}											/* of floating a constant						*/
		
	else {										/* not a constant								*/
		in_reg (node, ~ b_ac0);					/* get node in b.ac0							*/
		reg_allc (~ b_ac1); reg_allc (~ b_ac2); reg_allc (~ b_ac3);	/* free up										*/
		reg_free = (b_ac2 | b_ac3);				/* but these ones now free						*/
		em_rtp (l_flo);							/* float it										*/
		accpurg();								/* indicate all registers empty					*/
		x_arg1 [node] = t_fvar; x_info [node] = b_ac0;
		reg_cont [b_ac1] = node;				/* say what is in b.ac1 too						*/
	}											/* of not a constant							*/
}
	
/* Lllexpression compiler - compute subscript: 
.
.   This routine computes a subscript for a subscripted variable.  It
.   is passed the node (with X.NODE (NODE) = X.VAR) which is the variable, 
.   and returns with X.NODE = X.PREG, (a register pointing to 
.   where the subscripted beast is located. */

static	fixed	compute();
static	fixed	subtree;						/* used for info to compute						*/
static	fixed	mvt;							/* master variable type:  1 means floating, 0 means fixed	*/

static	fixed	fprs[] = {0, b_ac0, b_ac0, 0, b_ac1, 0, 0, 0, b_ac1};	/* fixed to floating reg						*/

static	fixed	iffreg(fixed);

static	fixed	subscript(						/* pass node, and value to store in it			*/
	fixed	node,
	fixed	val)
{
	static	fixed	subscr, reg1, reg2, disp, fva;
	static	fixed	ptr, dat, con;
	static	fixed	rtu, op;					/* indicates register.to.use and operation		*/
	static	fixed	i, j;
	static	fixed	ffregs;
	
	fva = ((x_arg1 [node] & t_fvar) != 0);		/* true if floating array type					*/
	if (val != 0) {								/* match to array type							*/
		if (fva & 1) floatme (val);				/* float here if array is floating type			*/
		else if ((x_arg1 [val] & t_fvar) != 0) {	/* else error									*/
			er_fna(); fix (val);
		}
	}
		
	reg1 = 0; ptr = 1;							/* see if any regs contain pointer to element	*/
	if (! (fva & 1)) while ((reg1 == 0) && (ptr < 16)) {	/* if not floating, scan stack					*/
		if ((ptr & reg_free) != 0) {			/* first make sure free register				*/
			dat = trees [ptr];					/* check contents - does not even need be free	*/
			if (dat != 0) {						/* check contents if any						*/
				if (tree_comp (node, dat) & 1) {	/* found										*/
					reg1 = ptr; freetr = x_arg2 [node]; tree_free();	/* free up exp									*/
				}
			}
		}
		ptr = shl(ptr, 1);
	}
		
	if (reg1 == 0) {							/* not found - must compute subscript			*/
		push (reg_pref); push (node); push (val); push (mvt); push (fva);
		subtree = x_arg2 [node];				/* get subscript expression						*/
		mvt = 0;								/* and that is fixed point						*/
		if (fva & 1) reg_pref = (b_ac1 | b_ac3);	/* subscr in these regs for floaters			*/
		else {									/* fxd pt - use desired reg						*/
			ptr = 3;							/* see if empty reg - start with 3				*/
			reg_pref = 0;						/* initialize									*/
			while ((reg_pref == 0) && (ptr > 0)) {	/* check 3, 2, 1								*/
				con = regbit [ptr];				/* get bit coded reg #							*/
				if (((reg_free & con) != 0) && (trees [con] == 0)) reg_pref = con;	/* idle, free r									*/
				ptr = ptr - 1;
			}
			if (reg_pref == 0) {				/* not found idle reg - check further			*/
				if (rtu == 0) rtu = b_ac3;		/* cycle is 3, 2, 1 3, 2, 1, 3, 2, 1			*/
				if ((reg_free & (b_ac1 | b_ac2 | b_ac3)) != 0) while ((reg_free & rtu) == 0) {
					rtu = shr(rtu, 1); if (rtu == b_ac0) rtu = b_ac3;
				}
				reg_pref = rtu; rtu = shr(rtu, 1); if (rtu == b_ac0) rtu = b_ac3;
			}
		}
		compute();
		fva = pop(); mvt = pop(); val = pop(); node = pop();	/* restore variables,  keep reg.pref on stack	*/
		subscr = x_arg2 [node];					/* and this is subscript node we just computed	*/
		fix (subscr);							/* and make sure it is fixed point				*/
		
		/* Lllexpression compiler - subscript computation (cont):
		.  
		.   We have computed the subscript and emitted the line number if the user
		.   so desires.
		.  
		.   So let's:
		.     1. check for constant math,
		.     2. allocate suitable register depending on fixed vs. floating, and
		.     3. protect the necessary registers. */
		
		ptr = ((x_arg1 [node] & t_pvar) != 0);	/* true if is pointer							*/
		dat = (((x_arg1 [node] & 0x00FF) == t_fxdata) | ((x_arg1 [node] & 0x00FF) == t_fldata));
		con = (x_node [subscr] == x_const);
		
		if (con & 1 && (! (ptr & 1)) && (_ILT_(x_info [node], extern_base))) {	/* if constant subscript, then do not use register unless needed	*/
			if (fva & 1) x_info [subscr] = shl(x_info [subscr], 1);	/* double subscript if floating array			*/
			disp = x_info [subscr]; reg1 = 0;	/* set displacement								*/
			if ((dat & 1) || (x_info [node] == 0)) {	/* detect core(3)								*/
				reg1 = reg_allc (0);			/* get any register if data type				*/
				if (dat & 1) em_spt (x_info [node] + disp, b_ad + bitreg [reg1]);	/* load ptr										*/
				else emitc (disp, b_ad + bitreg [reg1]);	/* detect core(const)							*/
				freeup (reg1);
				trees [reg1] = subscr;			/* indicate in register							*/
			}
			else x_rel (subscr);				/* else done with subscript node				*/
		}
			
		else {									/* else we must use a register					*/
			disp = 0;							/* no displacement								*/
			if (con & 1 && (x_info [subscr] == 0)) {	/* zero subscript ptr - check - this applies to references to external(0) and pvar(0)	*/
				reg1 = 0; op = 0; i = 1;
				if (ptr & 1) {					/* if is pointer,  see if is in register (proc call)	*/
					while ((reg1 == 0) && (i < 16)) {	/* scan to see what is in regs					*/
						j = trees [i];
						if (j != 0) {									/* see if points there							*/
							if ((x_node [j] == x_var)
							&& (x_info [j] == x_info [node])
							&& (x_arg1 [j] == (t_var | (x_arg1 [node] & (~ 0x00FF)))))
								reg1 = i;
						}
						i = shl(i, 1);
					}
				}
				if (reg1 == 0) {				/* must allocate and load						*/
					reg1 = reg_allc (0);		/* get any register								*/
					op = b_ad + b_loa;			/* must load subscript pointer (no add)			*/
				}
				freeup (reg1); trees [reg1] = subscr;	/* this is it									*/
			}
			else {								/* is not a constant of zero					*/
				reg1 = in_reg (subscr, 0);		/* get in any register							*/
				op = b_ad + b_add;				/* else add										*/
				if (fva & 1) emita (b_rs + bitreg [reg1], b_ad + b_add + bitreg [reg1]);	/* double subscript for floaters				*/
				x_rel (subscr);					/* believe it or not we are through with subscr	*/
			}
			if (op != 0) {						/* must load if so								*/
				if (dat & 1) em_spt (x_info [node], op + bitreg [reg1]);	/* data ptr										*/
				else if (x_info [node] != 0) {	/* skip the following for 'CORE'				*/
					reg2 = getvp (shr(x_arg1 [node], 8), x_info [node], reg1);	/* get pointer to array base or to array pointer	*/
					if (ptr & 1) emita (b_ms + reg2, op + bitreg [reg1]);	/* add in ptr if pointer						*/
					else emita (b_rs + reg2, op + bitreg [reg1]);		/* else add in register							*/
				}
			}
		}
			
		if (reg1 != 0) {						/* if subscript ended up in register, look:		*/
			if (fva & 1) freeup (reg1);			/* nothing to do here							*/
			else if (trees [reg1] != 0) {		/* if was a keep trackable item bingo			*/
				reg2 = x_get();
				x_node [reg2] = x_var;
				x_arg1 [reg2] = x_arg1 [node];
				x_arg2 [reg2] = trees  [reg1];
				x_info [reg2] = x_info [node];
				trees [reg1] = reg2;			/* indicate this register contains ptr			*/
			}
		}
			
		reg_pref = pop();						/* and restore prefered registers				*/
		
	}											/* of actually computing subscript pointer register	*/
		
	/* Lllexpression compiler - compute subscript (cont):
	.  
	.   In the above code, we have computed the subscript, loaded it
	.   into a register (unless it is a constant), and then added the
	.   array base (or pointer to same) to the subscript.
	.  
	.   Now determine whether or not we are storing data into the
	.   array (if val <> 0) and handle accordingly.	*/
	
	if (val == 0) {								/* if not assignment							*/
		if (reg1 == 0) {						/* if no register, then change to variable		*/
			x_node [node] = x_var;
			x_arg1 [node] = ((x_arg1 [node] & t_fvar) | (x_arg1 [node] & (~ 0x00FF)));
			x_info [node] = x_info [node] + disp;
		}
		else {									/* else we have generated a pointer register	*/
			x_node [node] = x_preg;
			x_arg1 [node] = (x_arg1 [node] & t_fvar);
			x_info [node] = reg1;
			reg_free = (reg_free & (~ reg1)); reg_cont [reg1] = node;	/* register is used, set up pointer				*/
		}
	}
		
	else {										/* else we must be assigning					*/
		
		if (reg1 == 0) {						/* just pointer									*/
			if ((x_node [val] == x_var               )/* if node is variable							*/
			&& (x_arg1 [val] == x_arg1 [node]       )/* of same class & type							*/
			&& ((ufixed) (x_info [val]) == (ufixed) (x_info [node] + disp)))/* at same location								*/
			{
				/* nothing to do; skip assigment of a (1) = a (1) since it blows up with floating */
				/* point due to increment bit                                                 */
			}
				
			else {								/* else emit instructions						*/
				if (fva & 1) {					/* floating assignment							*/
					ffregs = iffreg(val);
					reg2 = getvp (shr(x_arg1 [node], 8), x_info [node] + disp, ffregs);	/* get pointer into data area					*/
					fsendit (val, b_md + b_ibt + reg2, b_md + b_ibt + reg2, ffregs | regbit[reg2]);	/* store data									*/
					regl = (regl | regbit [reg2]); regc [reg2] = regc [reg2] + 2;
				}
				else {
					reg2 = getvp (shr(x_arg1 [node], 8), x_info [node] + disp, 0);	/* get pointer into data area					*/
					sendit (val, b_md + reg2, regbit [reg2]);	/* else store the data							*/
				}
			}
		}
		else {
			if (fva & 1) {
				ffregs = iffreg (val);
				fsendit (val, b_md + b_ibt + bitreg [reg1], b_md + b_ibt + bitreg [reg1], reg1 | ffregs);	/* floating store								*/
			}
			else sendit (val, b_md + bitreg [reg1], reg1);	/* else store node in thing - a - ma - jig		*/
			reg_free = (reg_free | reg1);		/* and free up pointer register after store		*/
		}
	}											/* of assignment								*/
		
	if (fva & 1) return (fprs [reg1]);			/* indicate which floating register contains pointer	*/
	else return (reg1);							/* else this is fixed register which contains pointer	*/
}
/* Expression compiler - subroutines:
.  
.  The following subroutines are used to assist the compilation 
.  of arithmetic expressions.
.  
.  The 'IFREG' routine examines a COMPUTEd (!!) node to see if it 
.  is in a register (X.REG or X.PREG).  This is used to assist in
.  the assigning of registers for dyadic operations.
.  
.  The "IFFREG" routine examines a COMPUTED FLOATING POINT node
.  and returns bits for which FIXED POINT ACCUMULATORS (b.ac0, b.ac1,
.  b.ac2, b.ac3) the node is stored in (if any).
.
.  The 'MATCH' routine is used to check if the operands of two
.  dyadic operators are the same type.  The operands must be
.  COMPUTEd before calling MATCH.
.  
.  MATCH floats the other argument if one is floating. */

static	fixed	ifreg(							/* pass node									*/
	fixed	node)
	
{
	if (x_node [node]  == x_reg)  return (x_info [node]);	/* is in register								*/
	if (x_node [node] != x_preg) return (0);	/* if not PREG, then arg is not in a register	*/
	if ((x_arg1 [node] & t_fvar) == 0) return (x_info [node]);	/* for fixed, register containing pointer		*/
	else return (fprs [x_info [node]]);			/* else indicate which floating registers holds fixed pointer	*/
}
	
static	fixed	iffreg(							/* pass node									*/
	fixed	node)
	
{
	if (x_node [node]  == x_reg)  return (ffpr[x_info [node]] | sfpr[x_info [node]]);	/* is in register								*/
	if (x_node [node]  == x_preg) return (x_info[node]);
	return (0);
	
}
	
static	fixed	match(							/* check types									*/
	fixed	arg1,
	fixed	arg2)
	
{
	if ((x_arg1 [arg1] & t_fvar) != 0) { floatme (arg2); return (1); }
	if ((x_arg1 [arg2] & t_fvar) != 0) { floatme (arg1); return (1); }
	return (0);									/* both args are fixed							*/
}
	
static	void	freemul()						/* routine to free up the mul/div				*/
{
	push (reg_pref);							/* save these									*/
	if (d4used == 1) {							/* preserve d4									*/
		reg_pref = x_arg2 [d4block];
		in_reg (d4block, 0);					/* get in any register							*/
	}
	if (d5used == 1) {							/* preserve d5									*/
		reg_pref = x_arg2 [d5block];
		in_reg (d5block, 0);					/* get in any reg								*/
	}
	reg_pref = pop();
}
	
/* Lllexpression compiler - compute subtree:
. 
.   This routine compiles code to compute the expression represented
.   by the tree passed to it in 'SUBTREE'.  It leaves the node in such
.   a state that the argument may actually be loaded into a register
.   by simply calling 'IN.REG'.  This routine destroys the subtree while
.   compiling code.  If it actually returns the operand in a register,
.   it returns the number of the register used.  This is a recursive routine.
*/

static	fixed	arg1, arg2, reg1, reg2, opr, xftl;

static	void	compute_swap(					/* swaps ARG1 and ARG2 for optimizing commutative operations	*/
	fixed	tree)
{
	static	fixed	tem;
	static	fixed	swtab[] = {o_eq, o_gt, o_ge, o_lt, o_le, o_ne, o_igt, o_ige, o_ilt, o_ile};
	
	tem = x_arg1 [tree]; x_arg1 [tree] = x_arg2 [tree]; x_arg2 [tree] = tem;
	arg1 = x_arg1 [tree]; arg2 = x_arg2 [tree];
	reg1 = ifreg (arg1);						/* see if reg									*/
	reg2 = ifreg (arg2);
	opr = x_info [tree];						/* look up operator								*/
	if (opr >= o_eq) {							/* if relational - change direction				*/
		opr = swtab [opr - o_eq]; x_info [tree] = opr;
	}
}
	
			/* Lllexpression compiler - procedure.ADAPT:
			.  
			.   ADAPT is called passing a declared variable type, a tree structure node, 
			.   and an 8-bit (reg or mem) destination field.  The node has already
			.   been computed using the 'COMPUTE' procedure.
			.  
			.   ADAPT proceeds to adapt a node type for passage to the declared variable
			.   (procedure.actual parameter).   If dest is nonzero, the appropriate 
			.   quantity (a pointer to arrays, a pointer to a temporary containing a 
			.   floating point argument for FVARs, or the fixed point results for a 
			.   fixed point number) is then sent to the specified destination.  DEST
			.   is restricted to loads of arithmetic accumulators and variable pointer
			.   references.
			.  
			.   ADAPT is only passed DTYPEs and NODEs that are T.VAR (fixed points) or
			.   T.PFVAR (pointers to floating point variables).  Adapting for arrays
			.   is handled by the 'SAP' (send array pointer) procedure.(below).
			*/
			
static	void	compute_adapt(					/* adapt a node to a dtype, send to dest if nonzero	*/
	fixed	dtype,
	fixed	node,
	fixed	dest,
	fixed	nono)
{
	static	fixed	info;
	static	fixed	adptem;
	
	if (dtype == t_var) {						/* dtype is T.VAR or T.PFVAR					*/
		if ((x_arg1 [node] & t_fvar) != 0)
		{
			er_atdnm();
			x_arg1 [node] = (t_var | (x_arg1 [node] & (~ 0x00FF)));
		}
		if (dest != 0) sendit (node, dest, nono);	/* put result of comput in dest					*/
	}
	else {										/* dtype is T.PFVAR								*/
		floatme (node);							/* make sure is floating						*/
		info = x_info [node];					/* restore new info								*/
		if (x_node [node] != x_temp) {			/* get one										*/
			static	fixed	ft;
			ft = gtemp (flt);
			reg1 = getvp (s_temporary, ft, nono);	/* get pointer to it							*/
			if (dest != 0) {					/* if we do send it								*/
				emita (b_rs + reg1, dest);		/* send pointer to dest.  ptr points to where we are about to store	*/
				adptem = x_get();				/* get a block for temp							*/
				e_point [adptem] = xftl; xftl = adptem;	/* link onto temp allocated list				*/
				e_loc [adptem] = ft;			/* and save location							*/
			}
			fsendit (node, b_md + b_ibt + reg1, b_md + b_ibt + reg1, nono);	/* store in temporary							*/
			x_node [node] = x_temp; x_info [node] = ft; x_arg1 [node] = t_fvar;
			regl = (regl | regbit [reg1]); regc [reg1] = regc [reg1] + 2;	/* and fix up register							*/
		}										/* of not a temp								*/
		else {									/* X.Node (node) is an X.TEMP					*/
			if (dest != 0) {					/* if we really do send it						*/
				sendvp (s_temporary, info, dest, nono);	/* send variable pointer to DEST				*/
				adptem = x_get(); e_point [adptem] = xftl; xftl = adptem;	/* get block, link								*/
				e_loc [adptem] = info;			/* and put in temp location						*/
			}									/* of dest <> 0									*/
		}										/* of tymp										*/
	}											/* of handling floaters							*/
}
	
			/* Lllroutine SAP:
			.  
			.   The routine SAP is passed a declared argument type, a passed argument 
			.   type, an info word, and a destination address.  DTYPE is either 
			.   T.PARR (pointer to array) or T.PFARR (pointer to floating point array).
			.   PTYPE is either T.ARR (fixed point array), T.PARR (pointer to such), 
			.   T.FARR (floating point array), T.PFARR (pointer to same), or 
			.   T.SCONST (string constant).  INFO is either a pointer to the variable 
			.   start location of a passed array, or a pointer to where the string 
			.   constant will be sitting during execution.  DEST is restricted as in
			.   ADAPT (above).  PTYPE is expected to be a X.ARG1 value (i.e., storage
			.   class and type).
			.  
			.   SAP sends a 16-bit number to dest.  That number represents a pointer
			.   to the array base during execution.
			*/
			
static	void	compute_sap(					/* send array pointer to dest					*/
	fixed	tree,
	fixed	dtype,
	fixed	ptype,
	fixed	info,
	fixed	dest,
	fixed	nono)
{
	static	fixed	sclass;
	
	sclass = shr(ptype, 8);						/* extract storage class						*/
	ptype  = (ptype & 0x00FF);					/* leave just the type							*/
	
	if ((x_arg2 [tree] & 0x00FF) == t_proc) {	/* only check arg type for user call			*/
		if (dtype == t_parr) {					/* fixed array - must not be floating			*/
			if ((ptype != t_sconst) && ((ptype & t_fvar) != 0)) er_atdnm();
		}
		else {									/* must be T.PFARR								*/
			if ((ptype == t_sconst) || ((ptype & t_fvar) == 0)) er_atdnm();
		}
	}
	if ((ptype == t_sconst) || (ptype == t_fxdata) || (ptype == t_fldata))/* string constant or data?						*/
		em_spt (info, dest);					/* emit scon pointer							*/
	else if ((ptype & t_pvar) != 0) {			/* Ptype is PFARR or PARR						*/
		reg1 = getvp (sclass, info, nono);		/* get pointer in register to pointer in vs1	*/
		emita (b_ms + reg1, dest);				/* send out to dest								*/
	}
	else {										/* Ptype is FARR or ARR							*/
		if (info == 0)							/* Core array									*/
			emitc (0, dest);					/* Core array starts at location 0				*/
		else sendvp (sclass, info, dest, nono);	/* not CORE - send the variable pointer to DEST	*/
	}											/* of arrays									*/
}
	
static	fixed	compute()						/* compute (compile) an expression				*/
{
	static	fixed	tree, reg_d;				/* current tree pointer, register containg result (if any)	*/
	static	fixed	vtype;						/* used as temporaries							*/
	static	fixed	instr, x_i, tmp;			/* used in dyadic processing					*/
	static	fixed	tree1, tree2;
	
	push (tree);								/* save current tree							*/
	push (reg_pref);							/* and preferred registers						*/
	tree = subtree;								/* make subtree the working tree				*/
	
	switch (x_node [tree]) {
	
	/* The following routines are responsible for compiling code to compute
	.   the expression represented by the current tree.  They must get it into
	.   a form such that it may be directly loaded into a register.  They are
	.   also required to release all storage in the tree below the top.  Since
	.   they will presumably be using the COMPUTE routine themselves, this only
	.   means releasing all first level nodes.  If the result is in a register
	.   then 'REG.D' should be set to the bit-coded register number; REG.D
	.   should be set to zero otherwise.
	. 
	.   Expression compiler - dyadic operator:
	.     The following routines and data areas are used to compile dyadic operators.	*/
	
		case 0:
		{
			
			static	fixed	rptab1[] = {0, 0, b_ac0, b_ac0, b_ac0, 0, 0, 0, 
			b_ac1, b_ac1 | b_ac2, b_ac1, b_ac1, b_ac0, 0, 0, 0, 0, 0, 0, 0, 0};
			
			static	fixed	rptab2[] = {0, 0, b_ac1, b_ac1, b_ac1, 0, 0, 0, 
			b_ac2, b_ac1 | b_ac2, b_ac2, b_ac2, b_ac2, 0, 0, 0, 0, 0, 0, 0, 0};
			
			static	fixed	swptab[] = {0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 
			1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
			
			static	fixed	fxdops[] = {b_sub, b_add, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b_and, b_or, b_ex};
			
			static	fixed	fltops[] = {l_fps, l_fpa, 0, 0, 0, 0, 0, 0, l_fpd, l_fpm, 0, 0, 0, 0, 0, 0};
			
			/* Lllexpression compiler - process dyadic operator:
			.  
			.   Examine the operation to be performed.  In many cases, specific
			.   registers must be used (such as multiply).  In other cases, try
			.   to use the best possible register allocation.  For example, if one
			.   of the fixed point add arguments is in a register, then send the
			.   other argument to add to it. */
			
			opr = x_info [tree];				/* get operator type							*/
			subtree = x_arg1 [tree];			/* get first arg subtree						*/
			if (opr == o_div) {					/* for divide, must protect ops					*/
				push (divarg); push (upperblock);
				upperblock = 0;
				if ((x_node [subtree] == x_dyad) && (x_info [subtree] == o_times))
					divarg = subtree;			/* tell multiply to produce both results		*/
			}
				
			push (reg_pref);					/* save preferred registers						*/
			
			/* compute prefered register for first argument */
			
			if (opr < o_eq) {
				tmp = rptab1 [opr - o_minus];	/* look up basic preference						*/
				if ((opr >= o_shr) && (opr <= o_rot))/* shift rotate									*/
				{
					if (prctyp >= 2) tmp = 0;							/* no pref if model >= c						*/
					else if (x_node [x_arg2 [tree]] == x_const)
						tmp = 0;										/* no pref if const shf cnt						*/
				}
				else if ((opr >= o_div) && (opr <= o_fdi))/* mul div operations							*/
				{								/* no preference if								*/
					if (muldiv != 0) tmp = 0;							/* hardware										*/
				}
				if (tmp != 0) reg_pref = tmp;	/* use it if desired							*/
			}
				
			reg1 = compute();					/* and compute the subtree						*/
			
			opr = x_info [tree];				/* restore opr									*/
			reg_pref = pop();					/* restore original preference					*/
			push (reg_pref);					/* save it again								*/
			
			reg_pref = reg_pref & (~(reg1));
			
			if (opr < o_eq) {
				tmp = rptab2 [opr - o_minus];	/* look up preference							*/
				if ((opr >= o_shr) && (opr <= o_rot))/* shift rotate									*/
				{
					if (prctyp >= 2) tmp = 0;							/* no pref if model >= c						*/
					else if (x_node [x_arg2 [tree]] == x_const)
						tmp = 0;										/* no pref if const shf cnt						*/
				}
				else if ((opr >= o_div) && (opr <= o_fdi))/* mul div operations							*/
				{								/* no preference if								*/
					if (muldiv != 0) tmp = 0;							/* hardware										*/
				}
				if (tmp != 0) reg_pref = tmp;
			}
				
			subtree = x_arg2 [tree]; reg2 = compute();
			
			arg1 = x_arg1 [tree]; arg2 = x_arg2 [tree];
			opr = x_info [tree];				/* and restore operator type					*/
			if (opr < o_eq) {					/* check type for non-relationals				*/
				if (fltops [opr - o_minus] == 0) {
					fix (arg1);
					fix (arg2);
				}
			}
				
			vtype = match (arg1, arg2);			/* compute desired type							*/
			if ((mvt & 1) && ((opr == o_times) || (opr == o_div))) {	/* force to floating							*/
				floatme (arg1); floatme (arg2); vtype = 1;
			}
			reg1 = ifreg (arg1);				/* see if ARG1 in register *** or is pointer ***	*/
			reg2 = ifreg (arg2);				/* see if ARG2 in register *** or is pointer ***	*/
			
			reg_pref = pop();					/* and restore preferred registers				*/
			
			if (vtype & 1) {					/* if floating, then load registers here		*/
				reg_d = b_ac0;					/* all floating results are here				*/
				if (opr < o_eq) {
					freemul();					/* free up multiplier for all floating ops		*/
					if (swptab [opr - o_minus] & 1 && ((reg1 == b_ac1) || (reg2 == b_ac0)))
						compute_swap(tree);								/* swap ops if we can							*/
					if (reg2 == b_ac0) reg2 = fin_reg (arg2, ~ b_ac1);	/* move to AC1 now if in AC0, or ptr in FPR0	*/
					fin_reg (arg1, ~ b_ac0);	/* and get ARG1 in AC0							*/
					fin_reg (arg2, ~ b_ac1);	/* and get ARG2 in AC1 no matter what			*/
					em_rtp (fltops [opr - o_minus]);	/* call routine to perform op					*/
				}
				else {							/* relational									*/
					if (swptab [opr - o_minus] & 1 && ((reg2 == b_ac1) || (reg1 == b_ac0))) compute_swap(tree);	/* swap ops if in wrong regs					*/
					if (opr > o_ne) { opr = opr - 5; x_info [tree] = opr; }
					if ((opr == o_ge) || (opr == o_lt)) compute_swap(tree);	/* can not do these								*/
					if (reg2 == b_ac1) reg2 = fin_reg (arg2, ~ b_ac0);	/* move to AC0 here if must						*/
					fin_reg (arg1, ~ b_ac1);	/* get first arg in AC1							*/
					fin_reg (arg2, ~ b_ac0);	/* and second in AC0							*/
					em_rtp (l_fps);				/* and subtract b from a						*/
				}
			}									/* of floating									*/
				
			/* Lllexpression compiler - dyadic operator (cont):
			.  
			.   We have performed the computation of the operands.  No emit
			.   instructions to perform the proper fixed or floating point
			.   operations.	*/
			
			/* now for fixed point multiply, divide, shifts:	*/
			
			else {								/* is not floating point						*/
				static	fixed	brtab[] = {4, 4, 1, 1, 1, 2, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
				switch (brtab [opr - o_minus]) {	/* branch on type								*/
					case 0:
					{													/* div tim mod fmu fdi							*/
						if (muldiv == 0) {								/* if no mul div, use software routine			*/
							/* Software multiply/divide: */
							
							static	fixed	brtab1[] = {1, 0, 1, 0, 2};	/* div times mod fmu fdi						*/
							static	fixed	rtab[] = {b_ac1, b_ac1, b_ac0, b_ac0, b_ac1};	/* result										*/
							if (reg2 != 0) reg2 = in_reg (arg2, ~ b_ac2);	/* move ARG2 to AC2 here						*/
							switch (brtab1 [opr - o_div]) {				/* branch onto type								*/
								case 0:
								{										/* multiply, fractional multiply				*/
									reg1 = in_reg (arg1, ~ b_ac1);
									reg2 = in_reg (arg2, ~ b_ac2);
									reg_allc (~ b_ac0); reg_allc (~ b_ac3);	/* other regs									*/
									em_rtp (l_fmu);						/* perform fixed point multiply					*/
									reg_free = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* all free - answer masked below				*/
									if (tree == divarg) {				/* save AC0 for later divide					*/
										upperblock = x_get();			/* allocate block								*/
										x_node [upperblock] = x_reg; x_arg1 [upperblock] = t_var;
										x_info [upperblock] = b_ac0;	/* save here									*/
										reg_cont [b_ac0] = upperblock;	/* for stuffing into temp						*/
										reg_free = (reg_free & (~ b_ac0));	/* Ac0 no longer free							*/
									}
									break;
								}										/* of mul/div									*/
									
								case 1:
								{										/* divide and mod								*/
									if (arg1 == divarg) {				/* this is result of multiply					*/
										in_reg (upperblock, ~ b_ac0);	/* get upper word								*/
										reg1 = in_reg (arg1, ~ b_ac1);	/* and lsb										*/
										x_rel (upperblock);				/* done with upperblock							*/
										upperblock = 0;
									}
									else {								/* must get arg1 in register					*/
										if (reg1 == b_ac0) reg1 = in_reg (arg1, ~ b_ac1);	/* move AC0 to AC1 if shd						*/
										reg_allc (~ b_ac0);				/* get AC0 free for sign extension				*/
										emitc (0, b_rd);				/* zero out AC0									*/
										freeup (b_ac0);					/* Ac0 is now clobbered							*/
										reg1 = in_reg (arg1, ~ b_ac1);	/* get second arg here							*/
										if (zflags != b_ac1) emitc (0, b_ad + b_add + 1);	/* set signs									*/
										emitc (1, b_cr + b_tpl);		/* if positive, uppers are zero					*/
										emitc (-1, b_ad + b_loa);		/* else sign of all ones						*/
									}
									reg2 = in_reg (arg2, ~ b_ac2);		/* get ARG2										*/
									reg_allc (~ b_ac3);					/* free up AC3 for divide						*/
									em_rtp (l_fdi);						/* fixed division								*/
									reg_free = b_ac0 | b_ac1 | b_ac2 | b_ac3;	/* indicate all free							*/
									break;
								}
									
								case 2:
								{										/* fractional divide							*/
									reg1 = in_reg (arg1, ~ b_ac0);
									reg2 = in_reg (arg2, ~ b_ac2);
									reg_allc (~ b_ac1); reg_allc (~ b_ac3);
									emitc (0, b_ad + b_loa + 1);
									em_rtp (l_fdi);						/* divide										*/
									reg_free = (reg_free | b_ac0 | b_ac1 | b_ac2);
									break;
								}
							}											/* of the do case								*/
							reg_d = rtab [opr - o_div];					/* get register containing answer				*/
							freeup (b_ac3);
							if (reg_d == b_ac1) freeup (b_ac0);
							if (reg_d == b_ac0) freeup (b_ac1);			/* indicate clobbered by sub call				*/
						}
						else {											/* hardware multiply divide						*/
							/* Hardware multiply/divide: */
							
							static	fixed	brtab2[] = {1, 0, 1, 0, 1};	/* div times mod fmu fdi						*/
							static	fixed	atab[] = {5, 5, 4, 4, 5};	/* answer device								*/
							switch (brtab2 [opr - o_div]) {				/* branch on type								*/
								case 0:
								{										/* muliply, fractional multiply					*/
									reg1=0; reg2=0; tmp=0;
									if ((opr == o_fmu) || (tree == divarg)) {	/* see if msb reqd								*/
										freemul();						/* free up the multiplier						*/
										reg1 = in_reg (arg1, reg2);		/* get in any registers, except ARG2			*/
										reg2 = in_reg (arg2, reg1);		/* get in any register, except ARG1				*/
										tmp = reg_allc (reg1 | reg2);	/* allocate register for msb correction			*/
									}
									else {								/* normal multiply								*/
										if (((d4used == 1) && (d4block != arg1))
										|| ((d5used == 1) && (d5block != arg1))) freemul();	/* free up unless ARG1							*/
										tmp = 0;						/* no correction required						*/
									}
									sendit (arg1, 5, reg1 | reg2 | tmp);	/* write ARG1									*/
									sendit (arg2, 6, reg1 | reg2 | tmp);	/* write ARG2 - both regs now free				*/
									x_node [tree] = x_dev; x_info [tree] = atab [opr - o_div];
									x_arg1 [tree] = t_var;
									if (opr == o_fmu) {					/* fmul											*/
										reg_d = tmp;					/* answer is here								*/
										in_reg (tree, ~ tmp);			/* get answer in register						*/
									}
									else {								/* multiply										*/
										reg_d = 0;						/* no answer									*/
										x_rel (arg1); x_rel (arg2);		/* free up arguments							*/
										d5used = 1; d5block = tree;		/* indicate D5 is used							*/
										x_arg2 [d5block] = reg_pref;
										if (tree == divarg) {			/* need 32-bits									*/
											upperblock = x_get();
											x_node [upperblock] = x_dev; x_arg1 [upperblock] = t_var;
											x_info [upperblock] = 4;
											in_reg (upperblock, ~ tmp);	/* and get uppers in register					*/
										}
									}
									if (tmp != 0) {						/* must do correction							*/
										emitc (0, b_ad + b_add + bitreg [reg1]);	/* test ARG1									*/
										emitc (1, b_cr + b_tpl);		/* skip if pos									*/
										emita (b_rs + bitreg [reg2], b_ad + b_sub + bitreg [tmp]);
										emitc (0, b_ad + b_add + bitreg [reg2]);	/* test ARG2									*/
										emitc (1, b_cr + b_tpl);		/* skip if pos									*/
										emita (b_rs + bitreg [reg1], b_ad + b_sub + bitreg [tmp]);
										freeup (tmp);					/* register is now clobbered					*/
									}
									break;
								}										/* of mul and fmu								*/
									
								case 1:
								{										/* div mod fdi									*/
									static	fixed	r1, r2, b1, b2, b3;
									freemul();							/* free up multiplier							*/
									if (opr == o_fdi) {					/* fractional divide							*/
										reg1 = in_reg (arg1, reg2);		/* get ARG1 (msb) in reg						*/
										r1 = reg1;
										r2 = reg_allc (r1 | reg2);
										emitc (0, b_rd + bitreg [r2]);	/* synthesize low order 16-bits of operand 1	*/
										freeup (r2);					/* now clobbered								*/
									}
									else if (arg1 == divarg) {			/* 32-bit multiply								*/
										r1 = in_reg (upperblock, reg2);	/* get upper									*/
										x_rel (upperblock);
										upperblock = 0;
										reg1 = in_reg (arg1, r1 | reg2);	/* get in reg									*/
										r2 = reg1;						/* and this contains lsb						*/
									}
									else {								/* normal div or mod							*/
										r1 = reg_allc (reg1 | reg2);	/* get a reg									*/
										emitc (0, b_rd + bitreg [r1]);	/* assume pos									*/
										freeup (r1);
										reg1 = in_reg (arg1, r1 | reg2);	/* get lsb										*/
										r2 = reg1;
										if (zflags != r2) emitc (0, b_ad + b_add + bitreg [r2]);
											
										/* divide or mod - extend sign of divide-into argument so we can perform a signed	*/
										/* 32-bit by 16-bit divide:						*/
										emitc (1, b_cr + b_tpl);		/* skip if pos									*/
										emitc ( - 1, b_rd + bitreg [r1]);	/* else signs of all ones						*/
									}
									reg2 = in_reg (arg2, r1 | r2);		/* get third arg in reg							*/
									b1 = bitreg [r1]; b2 = bitreg [r2]; b3 = bitreg [reg2];
									
									/* test divide-by argument.  if dividing by negative number, then negate			*/
									/* both the divide-by and divide-into arguments.  This assures that the divide-by	*/
									/* argument is always positive by the time we actually do the divide				*/
									
									if (zflags != reg2) emitc (0, b_ad + b_add + b3);	/* test divide-by value							*/
									emitc (7, b_cr + b_tpl);			/* if pos, skip									*/
									emita (b_rd + b1, b_ad + b_com + b1);	/* complement									*/
									emita (b_rd + b2, b_ad + b_com + b2);
									emitc (1, b_ad + b_add + b2);		/* then add 1 to negate							*/
									emitc (1, b_cr + b_tnc);
									emitc (1, b_ad + b_add + b1);
									emita (b_rd + b3, b_ad + b_com + b3);	/* negate divide-by								*/
									emitc (1, b_ad + b_add + b3);
									
									/* now test the divide-into argument.  if it is negative, then pre-correct it		*/
									/* before the divide so the result is signed...									*/
									
									emitc (0, b_ad + b_add + b1);		/* see if - msb									*/
									emitc (1, b_cr + b_tpl);
									emita (b_rs + b3, b_ad + b_add + b1);
									
									emita (b_rs + b2, 5);				/* load values into hardware and divide			*/
									emita (b_rs + b1, 4);
									emita (b_rs + b3, 7);
									
									freeup (r1); freeup (r2); freeup (reg2);
									x_node [tree] = x_dev; x_arg1 [tree] = t_var; x_info [tree] = atab [opr - o_div];
									x_arg2 [tree] = reg_pref;			/* save these									*/
									if (opr == o_mod) {					/* mod - protect it								*/
										d4used = 1; d4block = tree;
									}
									else {
										d5used = 1; d5block = tree;
									}
									x_rel (arg1); x_rel (arg2);
									reg_d = 0;
									reg_free = (reg_free | r1 | r2 | reg2);
									break;
								}										/* of fdi, mod, div								*/
							}											/* of do case									*/
						}
						break;
					}
						
					/* Dyadic operators - shifts and rotates:
					.  
					.  Now process the logical shift and rotate operators.  First check
					.  for constant arguments and emit shorthand instructions if we can.	*/
					
					case 1:
					{													/* shr shl rot									*/
						if (prctyp == 2) {								/* model C processor							*/
							/* Model C shift functions: */
							
							if (x_node [arg2] == x_const) {				/* handle constant shifts						*/
								x_i = x_info [arg2];					/* get number of shifts							*/
								reg_d = in_reg (arg1, 0);				/* get ARG1 in any register						*/
								if (opr == o_rot) x_i = (x_i & 15);		/* modulo 16 for rotate							*/
								else if (_IGT_(x_i, 16)) x_i = 16;		/* check for neg, or > 16						*/
								while (x_i >= 8) {						/* modulo 8 do with rotate						*/
									emitc (0, b_bsor + bitreg [reg_d]);	/* rotate 8 times								*/
									if (opr == o_shl) emitc ((fixed) 0xFF00, b_ad + b_and + bitreg [reg_d]);	/* extract upper								*/
									else if (opr == o_shr) emitc (255, b_ad + b_and + bitreg [reg_d]);	/* else lower									*/
									x_i = x_i - 8;
								}
								if (x_i <= 2) for (tmp = 1; tmp <= x_i; tmp++) {	/* now finish shift (for small numbers do in-line)	*/
									switch (opr - o_shr) {				/* branch on shift type							*/
										case 0:
											emitc (0, b_shra + bitreg [reg_d]);	/* shift right									*/
											break;
										case 1:
											emita (b_rs + bitreg [reg_d], b_ad + b_add + bitreg [reg_d]);	/* shift left									*/
											break;
										case 2:
											emitc (0, b_ad + b_lef + bitreg [reg_d]);	/* rotate left									*/
											break;
									}
								}
								else {									/* for larger numbers, use REPEAT				*/
									emita (b_is + ((x_i - 1) & b_imsk), 0x0008);	/* im(shift - 1) to d10 - load repeat counter	*/
									switch (opr - o_shr) {				/* branch on shift type							*/
										case 0:
											emitc (0, b_shra + bitreg [reg_d]);	/* shift right									*/
											break;
										case 1:
											emita (b_rs + bitreg [reg_d], b_ad + b_add + bitreg [reg_d]);	/* shift left									*/
											break;
										case 2:
											emitc (0, b_ad + b_lef + bitreg [reg_d]);	/* rotate left									*/
											break;
									}
								}
							}
							else {										/* must use REPEAT only							*/
								reg1 = in_reg (arg1, reg2);				/* get first argument in any accumulator (but don't wipe out REG2 if it's already loaded)	*/
								reg2 = in_reg (arg2, reg1);				/* and get second (anywhere but REG1)			*/
								tmp = gkey();							/* get a key for the transfer					*/
								emita (b_is + 0, b_td + b_tad + bitreg [reg2]);	/* im(0) to tadd0 - check if it's zero			*/
								em_tra (b_tze, tmp);					/* skip if zero									*/
								emita (b_is + 1, b_ad + b_sub + bitreg [reg2]);	/* im(1) to subX - subtract one from the count	*/
								emita (b_rs + bitreg [reg2], 0x0008);	/* reg2 to d10 - load repeat counter			*/
								switch (opr - o_shr) {					/* branch on shift type							*/
									case 0:
										emitc (0, b_shra + bitreg [reg1]);	/* shift right									*/
										break;
									case 1:
										emita (b_rs + bitreg [reg1], b_ad + b_add + bitreg [reg1]);	/* shift left									*/
										break;
									case 2:
										emitc (0, b_ad + b_lef + bitreg [reg1]);	/* rotate left									*/
										break;
								}
								em_lde (tmp);							/* end of shift is here							*/
								reg_free = (reg_free | reg2);
								reg_d = reg1;							/* Reg2 is now free, answer is in REG1			*/
							}											/* if shift/rotate with no constant				*/
						}
						else {											/* model B processor							*/
							/* Model B shift functions: */
							
							if (x_node [arg2] == x_const) {				/* handle constant shifts						*/
								x_i = x_info [arg2];					/* get number of shifts							*/
								reg_d = in_reg (arg1, 0);				/* get ARG1 in any register						*/
								if (opr == o_rot) x_i = (x_i & 15);		/* modulo 16 for rotate							*/
								else if (_IGT_(x_i, 16)) x_i = 16;		/* check for neg, or > 16						*/
								while (x_i >= 8) {						/* modulo 8 do with rotate						*/
									emitc (0, b_bsor + bitreg [reg_d]);	/* rotate 8 times								*/
									if (opr == o_shl) emitc ((fixed) 0xFF00, b_ad + b_and + bitreg [reg_d]);	/* extract upper								*/
									else if (opr == o_shr) emitc (255, b_ad + b_and + bitreg [reg_d]);	/* else lower									*/
									x_i = x_i - 8;
								}
 								for (tmp = 1; tmp <= x_i; tmp++) {	/* now finish shift								*/
									if (opr == o_shl) emita (b_rs + bitreg [reg_d], b_ad + b_add + bitreg [reg_d]);	/* shift left									*/
									else if (opr == o_shr) emitc (0, b_shra + bitreg [reg_d]);
									else emitc (0, b_ad + b_lef + bitreg [reg_d]);	/* rotate left									*/
								}
							}
							else {										/* must do sub call								*/
								if (reg2 == b_ac0) reg2 = in_reg (arg2, ~ b_ac1);	/* move to ARG1 if first register				*/
								reg1 = in_reg (arg1, ~ b_ac0);			/* get first argument							*/
								reg2 = in_reg (arg2, ~ b_ac1);			/* and get second								*/
								switch (opr - o_shr) {					/* and branch									*/
									case 0:
										em_rtp (l_shr);					/* shift right									*/
										break;
									case 1:
										em_rtp (l_shl);					/* shift left									*/
										break;
									case 2:
										em_rtp (l_rot);					/* rotate										*/
										break;
								}
								reg_free = (reg_free | b_ac1);
								reg_d = b_ac0;							/* Ac1 is now free, answer is in AC0			*/
							}											/* if shift/rotate with no constant				*/
						}
						break;
					}													/* of shift rotate								*/
						
					case 2:
						;												/* undefined									*/
						break;
					case 3:
						;												/* undefined									*/
						
						break;
					/* Standard arithmetic - perform operation using what ever registers
					.  are available.	*/
					
					case 4:
					{													/* math operations - add, sub, etc.				*/
						if (swptab [opr - o_minus] & 1 && (x_node [arg2] == x_reg)) {
							reg_d = in_reg (arg2, reg1);				/* get ARG2 in any register						*/
							sendit (arg1, b_ad + fxdops [opr - o_minus] + bitreg [reg_d], reg_d);
						}
						else {
							reg_d = in_reg (arg1, reg2);				/* get in register								*/
							sendit (arg2, b_ad + fxdops [opr - o_minus] + bitreg [reg_d], reg_d);	/* and perform math								*/
						}
						break;
					}
					case 5:
					{													/* relational									*/
						if (reg1 != 0) compute_swap(tree);				/* swap if arg1 is allready in register			*/
						if ((opr == o_ge) || (opr == o_lt) || (opr == o_ige) || (opr == o_ilt)) compute_swap(tree);
						reg_d = in_reg (arg2, reg1);					/* get arg2 in register							*/
						sendit (arg1, b_ad + b_sub + bitreg [reg_d], reg_d);	/* subtract b from a for rels					*/
						break;
					}													/* of relops									*/
				}								/* of standard arithmetic						*/
			}									/* of fixed point only							*/
				
			/* Lllexpression compiler:  dyadic operator (cont.) */
			
			if (opr >= o_eq) {					/* relops - correct								*/
				tmp = bitreg [reg_d];			/* get register #								*/
				switch (opr - o_eq) {			/* branch on relation							*/
					case 0:
						emita (1, b_ad + tmp);							/* read device 1 to get z flag					*/
						break;
					case 1:
						;
						break;
					case 2:
					{													/* <=											*/
						emitc (0, b_ad + b_lef + tmp);					/* shift left to get sign bit					*/
						emitc (1, b_ad + b_ex + tmp);					/* and complement least sig bit					*/
						break;
					}
					case 3:
						emitc (0, b_ad + b_lef + tmp);					/* rotatate left to get sign bit for >			*/
						break;
					case 4:
						;
						break;
					case 5:
						emita (1, b_ad + b_com + tmp);					/* complement z flag in register for <>			*/
						break;
					case 6:
						;												/* no go										*/
						break;
					case 7:
					{													/* integer le									*/
						emitc (0, b_rd + tmp);							/* load a zero - leave zflags					*/
						emitc (1, b_cr + b_tnc);						/* if no carry, then false						*/
						emitc (1, b_rd + tmp);							/* else true									*/
						break;
					}
					case 8:
					{													/* integer gt									*/
						emitc (0, b_rd + tmp);							/* assme fail									*/
						emitc (1, b_cr + b_trc);						/* if cary, then false							*/
						emitc (1, b_rd + tmp);							/* else ture									*/
						break;
					}
				}
				if (opr <= o_ne) emitc (1, b_ad + b_and + tmp);	/* mask if used - fl							*/
			}
				
			/* Lllexpression compiler - dyadic operator (cont):
			.  
			.   Done with expression compilation:
			.     Release nodes, 
			.     Set up tree info to indicate which register contains result.	*/
			
			if (opr == o_div) {					/* pop semphores								*/
				if (upperblock != 0) x_rel (upperblock);
				upperblock = pop(); divarg = pop();
			}
			if (reg_d != 0) {
				if (x_node [arg1] == x_reg) {	/* Arg1 in register								*/
					reg1 = x_info [arg1];
					tree1 = trees [reg1]; trees [reg1] = 0;
					x_rel (arg1);
				}
				else tree1 = arg1;
				if (x_node [arg2] == x_reg) {	/* Arg2 was in register							*/
					reg2 = x_info [arg2];
					tree2 = trees [reg2]; trees [reg2] = 0;
					x_rel (arg2);
				}
				else tree2 = arg2;
				freeup (reg_d);					/* Reg.D now has new value						*/
				if ((tree1 == 0) || (tree2 == 0)) {	/* can not optimize then						*/
					freetr = tree1; tree_free();
					freetr = tree2; tree_free();
				}
				else {							/* maybe can keep track of register contents	*/
					tmp = x_get();
					x_node [tmp] = x_dyad; x_info [tmp] = opr;
					x_arg1 [tmp] = tree1; x_arg2 [tmp] = tree2;
					trees [reg_d] = tmp;		/* this is contents of register now				*/
					
					/* final check - if proc or temp, cannot optimize */
					
					if ((x_node [tree1] > x_var) || (x_node [tree2] > x_var)) freeup (reg_d);
				}
					
				x_node [tree] = x_reg; x_info [tree] = reg_d;
				if (vtype & 1) {				/* floating										*/
					if (opr >= o_eq) {									/* but relational								*/
						reg_free = (b_ac1 | b_ac2 | b_ac3); reg_cont [reg_d] = tree;
						x_arg1 [tree] = t_var;							/* fixed point result							*/
					}
					else {												/* fixed point									*/
						reg_free = (b_ac2 | b_ac3);
						reg_cont [b_ac0] = tree; reg_cont [b_ac1] = tree;
						x_arg1 [tree] = t_fvar;							/* floating result								*/
					}
				}
				else {							/* fixed										*/
					reg_free = (reg_free & (~ reg_d));
					reg_cont [reg_d] = tree; x_arg1 [tree] = t_var;
				}
			}									/* of result in register						*/
			break;
		}										/* of dyadic									*/
			
		/* Lllexpression compiler - monadic operator:	*/
		
		case 1:
		{										/* monadic operator								*/
			
			static	fixed	montab[] = { 		/* do case table for monadic operators			*/
			1, 1, 1, 1, 1, 1, 1, 1, 			/* math ops										*/
			9, 9, 9, 9, 9, 9, 9, 9, 			/* unused now									*/
			0, 									/* int											*/
			4, 									/* read											*/
			9, 									/* unused										*/
			2, 									/* addr											*/
			9, 9, 9, 9, 						/* unused										*/
			3, 3, 3, 9, 3};						/* not incr decr null minus						*/
			
			subtree = x_arg1 [tree];
			push (reg_pref); push (mvt);
			
			opr = x_info [tree];				/* get operator type							*/
			
			if (opr < o_read) reg_pref = b_ac0;	/* use r0 for floating sin, cosine, etc.		*/
				
			if (opr < o_int) mvt = 1;			/* use floating here							*/
			else if (opr != o_minus) mvt = 0;	/* else try for fixed unless -					*/
			compute();							/* compute operand								*/
			mvt = pop(); reg_pref = pop();
			opr = x_info [tree];
			arg1 = x_arg1 [tree];
			vtype = ((x_arg1 [arg1] & t_fvar) != 0);	/* true if floating operand						*/
			
			if ((opr == o_read) && (x_node [arg1] == x_const)) {	/* Read(constant)?								*/
				fix (arg1);						/* make sure fixed point constant				*/
				x_node [tree] = x_dev; x_arg1 [tree] = t_var; x_info [tree] = x_info [arg1];
				reg_d = 0; x_rel (arg1);
				if (((x_info [tree] >= b_rs + b_ibt) && (x_info [tree] < b_ms))/* register then increment?						*/
				|| ((x_info [tree] >= b_ms + b_ibt) && (x_info [tree] <= b_ms + b_ibt + b_pc))) {	/* memory register then increment?				*/
					if ((x_info [tree] & b_rmsk) <= b_amsk)/* accumulator?									*/
						freeup (regbit [x_info [tree] & b_amsk]);		/* yes, free up the accumulator					*/
					else if (((x_info [tree] & b_rmsk) >= min_ptr_reg) && ((x_info [tree] & b_rmsk) <= max_ptr_reg))/* variable pointer?							*/
						regclr (regbit [x_info [tree] & b_rmsk]);		/* free up VP									*/
				}								/* of increment source							*/
			}									/* of READ(constant)							*/
				
			else {								/* not read of constant - always will use register	*/
				switch (montab [opr]) {			/* branch on it									*/
					case 0:
					{													/* int function									*/
						fix (arg1);										/* convert to fixed point						*/
						reg_d = in_reg (arg1, 0);						/* and force into ay register - this is not good	*/
						vtype = 0;										/* is actually fixed now						*/
						break;
					}													/* of int										*/
						
					/* now check for math operation					*/
					
					case 1:
					{													/* math operation - abs, sin cos etc.			*/
						
						static	fixed	mops[] = {l_abs, l_log, l_atn, l_cos, l_sne, l_tan, l_exp, l_sqr};	/* pointers										*/
						
						if ((vtype == 0) && (opr == o_math)) {			/* fixed point abs - in line					*/
							reg_d = in_reg (arg1, 0);					/* get in any register							*/
							if (zflags != reg_d) emitc (0, b_ad + b_add + bitreg [reg_d]);	/* set											*/
							emitc (2, b_cr + b_tpl);					/* skip if pos or zero							*/
							emita (b_rs + bitreg [reg_d], b_ad + b_com + bitreg [reg_d]);	/* get complement								*/
							emitc (1, b_ad + b_add + bitreg [reg_d]);	/* and add one for negation						*/
						}
							
						else {											/* must be floating point						*/
							freemul();									/* free up the multiplier in ay case			*/
							floatme (arg1);								/* must be floating point						*/
							vtype = 1;									/* is now floating								*/
							reg_d = fin_reg (arg1, ~ b_ac0);			/* get argument in AC0 only						*/
							reg_allc (~ b_ac2); reg_allc (~ b_ac3);		/* free up all registers						*/
							em_rtp (mops [opr]);						/* and call routine to perform operation		*/
							accpurg();									/* can not optimize accumulators here			*/
						}												/* of floaters									*/
						break;
					}													/* and end - REG.D is set, REG.FREE is ok, and REG.C is too	*/
						
					/* Lllexpression compiler - monadic operator (cont):
					.  
					.   Now handle standard operations - minus, negate, increment.	*/
					
					case 2:
					{													/* addr function								*/
						vtype = 0;										/* always fixed point							*/
						if (x_node [arg1] == x_preg) {
							x_node [arg1] = x_reg;
							reg_d = x_info [arg1];
						}
						else if (x_node [arg1] == x_var) {				/* get pointer									*/
							reg_d = reg_allc (0);						/* get a register								*/
							sendvp (shr(x_arg1 [arg1], 8), x_info [arg1], b_ad + b_loa + bitreg [reg_d], 0);	/* get ptr										*/
							freeup (reg_d);								/* we have lost contents of previous reg		*/
							tmp = x_get(); x_node [tmp] = x_var;
							x_info [tmp] = x_info [arg1];
							x_arg1 [tmp] = x_arg1 [arg1];
							trees [reg_d] = tmp;
						}
						else {											/* no go										*/
							er_atdnm();
							reg_d = in_reg (arg1, 0);
						}
						break;
					}													/* of addr - for now, see below					*/
						
					case 3:
					{													/* misc operations - not incr decr minus		*/
						
						if ((vtype & 1) && (opr == o_minus)) {			/* floating negate								*/
							reg_d = fin_reg (arg1, 0);					/* get in either register						*/
							reg1 = ffpr [reg_d]; reg2 = sfpr [reg_d];	/* and get the two registers					*/
							emitc (0, b_td + b_tsu + bitreg [reg1]);	/* test for zero								*/
							emitc (2, b_cr + b_tze);					/* skip xor if zero								*/
							emitc ((fixed) 0x8000, b_ad + b_ex + bitreg [reg1]);	/* change sign									*/
						}												/* of floating									*/
							
						else {											/* fixed point									*/
							
							fix (arg1); vtype = 0;						/* must be fixed								*/
							
							if ((x_node [arg1] == x_reg)
							||  (x_node [arg1] == x_preg))
								reg_free = (reg_free | x_info [arg1]);	/* free up here - may be one to use				*/
								
							reg_d = reg_allc (0);						/* get a register for operation - any one - we know we wont be using a temp here (if x.node is an x.reg or an x.preg) since we have just free up a register and nono = 0	*/
							switch (opr - o_not) {						/* and branch on type							*/
							
								case 0:
								{										/* not											*/
									sendit (arg1, b_ad + b_com + bitreg [reg_d], 0);	/* load compil version							*/
									break;
								}
									
								case 1:
								{										/* increment									*/
									sendit (arg1, b_rd + bitreg [reg_d], 0);	/* load it										*/
									emitc (1, b_ad + b_add + bitreg [reg_d]);	/* add one to it								*/
									break;
								}
									
								case 2:
								{										/* decrement									*/
									sendit (arg1, b_rd + bitreg [reg_d], 0);	/* load it										*/
									emitc (1, b_ad + b_sub + bitreg [reg_d]);	/* subtract one from it							*/
									break;
								}
									
								case 3:
									;									/* spare										*/
									
									break;
								case 4:
								{										/* minus										*/
									sendit (arg1, b_ad + b_com + bitreg [reg_d], 0);
									emitc (1, b_ad + b_add + bitreg [reg_d]);
									break;
								}
									
							}											/* of do case									*/
							freeup (reg_d);								/* register is now clobbered					*/
						}												/* of fixed										*/
						break;
					}													/* of normal operation begin					*/
						
					case 4:
					{													/* read											*/
						fix (arg1);										/* must be fixed point							*/
						vtype = 0;										/* indicate fixed								*/
						in_reg (arg1, ~ b_ac0);							/* get in reg									*/
						reg_allc (~ b_ac1); reg_allc (~ b_ac2); reg_allc (~ b_ac3);
						accpurg();
						em_rtp (l_sbr);
						reg_d = b_ac0;
						break;
					}													/* read											*/
				}								/* of do case for types							*/
					
				/* Lllexpression compiler - monadic operators (cont): */
				
				/* now clean up after monadic op leaving result in REG */
				
				if (vtype == 0) {				/* if fixed point output - continue				*/
					if (x_node [arg1] == x_reg) {						/* Arg1 was put in REG							*/
						reg1 = x_info [arg1];
						tree1 = trees [reg1]; trees [reg1] = 0;
						x_rel (arg1);
					}
					else tree1 = arg1;
					freeup (reg_d);				/* indicate free								*/
					if (tree1 != 0) {									/* if anything identifiable was in register		*/
						tmp = x_get();									/* get a block									*/
						x_node [tmp] = x_monad; x_info [tmp] = opr; x_arg1 [tmp] = tree1;
						trees [reg_d] = tmp;
						if (x_node [tree1] > x_var) freeup (reg_d);		/* can not optimize								*/
					}													/* of check for unidentifiable register contents	*/
					reg_free = (reg_free & (~ reg_d));	/* update free registers						*/
					x_node [tree] = x_reg; x_arg1 [tree] = t_var; x_info [tree] = reg_d;
					reg_cont [reg_d] = tree;	/* update back ptr in case of force reqd		*/
				}								/* of fixed										*/
					
				else {							/* floating result								*/
					reg1 = ffpr [reg_d]; reg2 = sfpr [reg_d];
					reg_free = (reg_free & (~ reg1) & (~ reg2));
					reg_cont [reg1] = tree; reg_cont [reg2] = tree;
					x_node [tree] = x_reg; x_arg1 [tree] = t_fvar; x_info [tree] = reg_d;
					x_rel (arg1);				/* and arg is now freed up						*/
				}
			}									/* of monadic ops that always use registers		*/
			break;
		}										/* of all mondic ops							*/
			
		case 2:
			reg_d = 0;							/* constants - no processing required, no register used	*/
			
			break;
		case 3:
		{										/* variables - check for subscripted			*/
			reg_d = 0;							/* assume not									*/
			if (x_arg1 [tree] & 1) reg_d = subscript (tree, 0);	/* get pointer									*/
			break;
		}
			
		/* Lllexpression compiler - procedure calls:	*/
		
		case 4:
		{										/* procedure.call								*/
			fixed	link, reg_, d1, adptem, inregl, stuffl, linktem;
			
			freemul();							/* free up multiplier on procedure.call			*/
			reg_allc (~ b_ac0);
			reg_allc (~ b_ac1);
			reg_allc (~ b_ac2);
			reg_allc (~ b_ac3);
			
			/* First of all, set up two linked data lists:
			.   One for arguments that go in a register, then the other list 
			.   for those arguments (5 and above) that get stuffed in memory.
			.
			.   Then for each one that gets stuffed, COMPUTE it and store proper 
			.   data in the memory cell
			.  
			.   Then for each one that goes in a register, COMPUTE it, and if the 
			.   argument is a floating variable, get a temporary location and
			.   store it there.
			.  
			.   Then for each argument that goes in a register, get proper result
			.   in REG.
			. 
			.   Then emit procedure.call.
			*/
			
			/* Lllexpression compiler - start emitting code for procedure.call: */
			
			xftl = 0; inregl = 0; stuffl = 0;	/* initialize lists								*/
			
			/* set up list of args */
			
			link = x_arg1 [tree];				/* initialize llink								*/
			adptem = 0;
			while (link != 0) {					/* loop through all arguments, putting ont two list	*/
				if (adptem < 4) {				/* goes in register								*/
					linktem = x_node [link]; x_node [link] = inregl; inregl = link;	/* link on to pass in register list				*/
				}
				else {							/* must be stuffed								*/
					linktem = x_node [link]; x_node [link] = stuffl; stuffl = link;	/* link on to stuff list						*/
				}
				link = linktem;					/* move down list								*/
				adptem = adptem + 1;			/* keep track of counter						*/
			}									/* of first pass through argument list			*/
				
			/* Pass 1.5 - go through both lists and compute and expressions that */
			/* need to be computed.  Since these expressions might be other      */
			/* procedure calls,  we have to compute them all before we stuff     */
			/* any arguments into static variables.                              */
			
			link = stuffl;
			while (link != 0) {					/* for each one to stuff						*/
				if (!(x_arg2 [link] & 1)) {		/* declared variable type was not array			*/
					push (inregl); push (stuffl); push (link); push (xftl);
					reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any reg										*/
					push (mvt);					/* protect										*/
					if (x_arg2 [link] == t_var) mvt = 0; else mvt = 1;
					subtree = x_arg1 [link]; compute();	/* compute the expression						*/
					mvt = pop();				/* restore										*/
					xftl = pop();
					link = pop(); stuffl = pop(); inregl = pop();	/* pop											*/
				}
				link = x_node [link];			/* move down list								*/
			}									/* of pass 1.5									*/
				
			/*  First reverse the INREGL list, so that the first item on the 
			.   list will be going in register 0. */
			
			link = inregl; inregl = 0;
			while (link != 0) {					/* go through									*/
				linktem = x_node [link];		/* point to next								*/
				x_node [link] = inregl; inregl = link;	/* reverse										*/
				link = linktem;
			}
				
			reg_ = b_ac0;						/* first one goes here							*/
			link = inregl;
			while (link != 0) {					/* go down list									*/
				if (! (x_arg2 [link] & 1)) {	/* here, we only handle non-arrays				*/
					push (reg_  ); push (inregl);
					push (stuffl); push (link  ); push (xftl);	/* store temp list pointer						*/
					reg_pref = reg_;			/* prefer result here							*/
					push (mvt);
					if (x_arg2 [link] == t_var) mvt = 0; else mvt = 1;
					subtree = x_arg1 [link]; compute();	/* and compute result							*/
					mvt = pop();				/* restore										*/
					xftl = pop();
					link = pop(); stuffl = pop(); inregl = pop(); reg_ = pop();
				}
				reg_ = shl(reg_, 1);			/* next arg, next reg							*/
				link = x_node [link];			/* move down									*/
			}									/* of this pass									*/
				
			/* Pass two - go through stuff list and compute those, and send data to memory cell
			.  (these memory cells are always static). */
			
			link = stuffl;
			while (link != 0) {					/* for each one to stuff						*/
				if (x_arg2 [link] & 1) {		/* declared variable type was array				*/
					reg1 = getvp (s_static, x_spec [link], 0);	/* get variable pointer to where to stuff arg (in this case arr ptr)	*/
					compute_sap (tree, x_arg2 [link], x_arg1 [link], x_info [link], b_md + reg1, regbit[reg1]);	/* send array pointer to memory					*/
				}
				else {							/* argument is variable, not array				*/
					reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any reg										*/
					reg1 = getvp (s_static, x_spec [link], 0);	/* get vptr of where to stuff					*/
					compute_adapt (x_arg2 [link], x_arg1 [link], b_md + reg1, regbit[reg1]);	/* adapt node and send to memory				*/
				}
				link = x_node [link];			/* move down list								*/
			}									/* of pass2										*/
				
			/*  Pass three - go down 'pass in register list' and compute all operands
			.   and then store any floaters in temps.  We do.not load the argument 
			.   carrying register at this time, because we need all available registers
			.   for computing each argument that is going to pass in a register. */
			
			reg_ = b_ac0;						/* first one goes here							*/
			link = inregl;
			while (link != 0) {					/* go down list									*/
				if (! (x_arg2 [link] & 1) ) {	/* here, we only handle non-arrays				*/
					reg_pref = reg_;			/* prefer result here							*/
					compute_adapt (x_arg2 [link], x_arg1 [link], 0, 0);	/* allocate temporaries for fvars at this time	*/
				}
				reg_ = shl(reg_, 1);			/* next arg, next reg							*/
				link = x_node [link];			/* move down									*/
			}									/* of this pass									*/
				
			/* Lllexpression compiler - procedure.call (cont):
			.  
			.   Pass four - go through list of arguments that are passed in registers
			.   and then put the appropriate number in the appropriate register.
			.  
			.   Note:  All floating arguments are in temporaries by now.
			.  
			.   From here on, the tree structure falls to pieces since
			.   registers are loaded with pointers and things that are
			.   not conveniently represented by an X.NODE type.  Also, 
			.   a used register must not be stored in a temp once an argument 
			.   has been loaded into it (obviously). */
			
			reg_ = b_ac0; link = inregl;
			while (link != 0) {
				if (x_arg2 [link] == t_var) in_reg (x_arg1 [link], ~ reg_);	/* if var, get in reg							*/
				else if (x_arg2 [link] == t_pfvar) {	/* argument is pointer to floating variable		*/
					reg_allc (~ reg_);
					compute_adapt (x_arg2 [link], x_arg1 [link], b_rd + bitreg [reg_], ((~ reg_) & 15));	/* send proper item (ptr to temp) to reg.  use this reg for recursive variable pointers	*/
				}
				else {							/* declared argument type must be an array		*/
					reg_allc (~ reg_);			/* free up regs									*/
					compute_sap (tree, x_arg2 [link], x_arg1 [link], x_info [link], b_rd + bitreg [reg_], ((~ reg_) & 15));	/* send ptr into reg.  use this reg for recursive variable pointers	*/
				}
				freeup (reg_);					/* indicate contents is now nothing				*/
				reg_ = shl(reg_, 1);			/* next, next									*/
				link = x_node [link];			/* move on										*/
			}
				
			/* Pass 5 - go through both lists and free up expression blocks and link blocks. */
			
			link = inregl;
			while (link != 0) {
				if (! (x_arg2 [link] & 1) ) x_rel (x_arg1 [link]);
				d1 = x_node [link]; x_rel (link); link = d1;
			}
			link = stuffl;
			while (link != 0) {
				if (! (x_arg2 [link] & 1) ) x_rel (x_arg1 [link]);
				d1 = x_node [link]; x_rel (link); link = d1;
			}
				
			/* free up stacked temps */
			
			while (xftl != 0) {
				ptemp (e_loc [xftl], flt);		/* release this temporary						*/
				d1 = e_point [xftl]; x_rel (xftl); xftl = d1;	/* and release block							*/
			}
				
			/* emit proper JSR (jump subroutine) */
			
			if ((x_arg2 [tree] & 0x00FF) == t_proc) {	/* call of user procedure.						*/
				d1 = shr(x_arg2 [tree], 8);		/* point to list for this proc call				*/
				if (aliases[d1].key != x_info [tree])	/* make sure it's for this proc!				*/
					er_emes1 ((char *) "alias list doesn\'t match call");
				em_cal (x_info [tree], &(aliases[d1].info[0]), aliases[d1].num);	/* emit call using key system					*/
			}
			else {								/* rtp call										*/
				em_rtp (x_info [tree]);			/* emit call to rtp routine						*/
			}
				
			/* clean up and return */
			
			accpurg();							/* indicate all registers zapped				*/
			x_node [tree] = x_reg; x_arg1 [tree] = x_spec [tree];	/* set up type returned							*/
			x_info [tree] = b_ac0;				/* answer is in reg 0							*/
			reg_cont [b_ac0] = tree; reg_cont [b_ac1] = tree;
			if (x_arg1 [tree] == t_var)			/* if returns type is fixed						*/
				reg_free = (b_ac1 | b_ac2 | b_ac3);
			else reg_free = (b_ac2 | b_ac3);	/* only these 2 are free						*/
			reg_d = b_ac0;
			
			break;
		}										/* of procedure.call							*/
			
		/* Lllexpression compiler - end of the compute subtree routine:	*/
		
	}											/* of case statement							*/
	reg_pref = pop();							/* reload stacked parameters					*/
	subtree = tree;								/* also preserve calling parameter				*/
	tree = pop();
	
	return (reg_d);								/* return as value the register that the answer is in	*/
}
/* Expression compiler - generate conditional transfers from logical expression:
.  
.   Routine XCOMPUTE:
.  
.   XCOMPUTE is a routine that is similar in function to the 'COMPUTE' routine.
.   XCOMPUTE is passed an expression tree node (in the global variable SUBTREE).
.   XCOMPUTE is also passed two key numbers:  one in TRUEL, and the other
.   in FALSEL.  XCOMPUTE is also passed a flag (TRUFIRST).
.  
.   XCOMPUTE looks through the expression tree passed in SUBTREE and 
.   generates object code that jumps to TRUEL or FALSEL depending on 
.   the true/false condition of the tree expression.  It is used to 
.   process IF/THEN and DO/WHILE expressions.
.  
.   At each conditional test point (as in 'if a = b') a jump instruction is
.   emitted (conditional jump instruction).  If TRUFIRST is set to true (one),
.   then the object code will jump to location TRUEL if the condition is 
.   true, else the object code will fall through.  If TRUFIRST is false
.   (zero), then the object code will jump to location FALSEL if the
.   condition is false, else object code will fall through.
.  
.   The purpose of the TRUFIRST bullshit is to avoid object code such as:
.     tze .+2  (a = b true condition)
.     tra fail (false).
.  
.   The proper object code would be a:
.     tnz fail
.
.   The variable XCREGL is used to keep track of which registers
.   were loaded by XCOMPUTE before the first jump instruction
.   was emitted.  This is advantageous, since we know that those
.   registers were correctly loaded and are valid.
. 
.   Note:  Set XCFIRSTJ to zero before calling XCOMPUTE. */

static	fixed	truel, falsel, trufirst;
static	fixed	xcfirstj, xcregl, xcregu;

static	void	xcomset()						/* call this proc to set up for XCOMPUTE call	*/
{
	truel = 0; falsel = 0; trufirst = 0; xcregl = 0; xcregu = 0; xcfirstj = 0;
}
	
static	void	xcompv()						/* set to push special saved REGU, REGL			*/
{
	push (xcregl);								/* we must do this after XCOMPUTE has release stack	*/
	push (xcregu);
}
	
static	void	xcomchk()						/* call to check XCFIRSTJ on each jump instr	*/
{
	if (xcfirstj == 0) {
		xcfirstj = 1; xcregl = regl; xcregu = regu; regl = 0; regu = 0;
		sreg();									/* save regs as of first jump					*/
	}
}
	
/* Llldonewith routine:
.
.   XCOMPUTE is passed a key to jump to on true and a key to jump to on
.   a false condition (FALSEL).  Obviously, when a location is jumped to,
.   certain registers must be cleared at the jump to address.  However,
.   since many times the location will not be jumped to (for example the
.   expression 'if a = b' emits just one 'tnz fail' instruction, so TRUEL
.   never gets jumped to)  it would be poor policy to zero out the register
.   optimization stack at a location that was never jumped to.
.
.   We must generate a mechanism that keeps track of which key numbers have
.   been jumped to and which have not been jumped to.
.    
.   Therefore, it is legal to call XCOMPUTE with a TRUEL or FALSEL of zero.
.   In this case, TRUEL will be allocated (and set equal to the allocated key)
.   when and if a jump instruction is actually emitted.
.  
.   If, after calling XCOMPUTE with TRUEL or FALSEL = 0, the calling routine
.   finds that (TRUEL or FALSEL) is no longer zero, an ET.ALD type record
.   record must be emitted to the object file to actually locate the key.
.  
.   DONEWITH routine:
.     The DONEWITH routine is passed TRUEL or FALSEL.  If the passed 
.     variable is zero, then DONEWITH returns.  If it is nonzero, 
.     then DONEWITH emits an ET.ALD record and then clears the
.     REGC array locations specified by REGL.
*/

static	void	donewith(						/* done with TRUEL or FALSEL					*/
	fixed	akey)
{
	if (akey == 0) return;						/* never emitted any jumps to it				*/
	em_ald (akey);								/* label definition time						*/
	regclr (regl);								/* and zap any regs loaded up to now in expression	*/
	accpurg();									/* clean out accumulators						*/
	zflags = 0;									/* Zflags are trash after label definition		*/
}
	
static	void	xcompute_swap(					/* used to swap relation						*/
	fixed	tree)
{
	static	fixed	tem;
	
	tem = x_arg1 [tree]; x_arg1 [tree] = x_arg2 [tree]; x_arg2 [tree] = tem;
	arg1 = x_arg1 [tree]; arg2 = x_arg2 [tree];
	reg1 = ifreg (arg1);						/* see if in a register							*/
	reg2 = ifreg (arg2);
}
	
/* Lllexpression compiler - XCOMPUTE: */

static	fixed	tt[] = {b_tze, b_tmi, b_tpl, b_tmi, b_tpl, b_tnz, b_tnc, b_trc, b_tnc, b_trc};	/* true transfers								*/
static	fixed	ft[] = {b_tnz, b_tpl, b_tmi, b_tpl, b_tmi, b_tze, b_trc, b_tnc, b_trc, b_tnc};	/* false transfers								*/
		
static	void	xcompute()

{
	static	fixed	tree;
	static	fixed	fva;
	static	fixed	node, info;
	static	fixed	fltflag;					/* special flag									*/
	push (tree); tree = subtree;
	node = x_node [tree]; info = x_info [tree];
	
	if ((node == x_dyad) && (info == o_and)) {	/* and											*/
		push (trufirst); push (truel);
		truel = 0;
		trufirst = 0; subtree = x_arg1 [tree]; xcompute();	/* recurse										*/
		donewith (truel);
		truel = pop(); trufirst = pop();
		subtree = x_arg2 [tree]; xcompute();
		x_rel (x_arg1 [tree]); x_rel (x_arg2 [tree]);
	}
	else if ((node == x_dyad) && (info == o_or)) {	/* or											*/
		push (trufirst); push (falsel);
		falsel = 0;
		trufirst = 1;
		subtree = x_arg1 [tree]; xcompute();
		donewith (falsel);
		falsel = pop(); trufirst = pop();
		subtree = x_arg2 [tree]; xcompute();
		x_rel (x_arg1 [tree]); x_rel (x_arg2 [tree]);
	}											/* of or										*/
		
	/* Lllexpression compiler - routine XCOMPUTE (cont):
	.  
	.   If the node is a relational operator (=, <, etc.) then we
	.   will emit a comparison instruction (subtract) followed by
	.   a conditional jump.
	.  
	.   In this case, the answer to the comparison is never 'calculated', 
	.   but the transfer of control is given directly below.	*/
	
	else if ((node == x_dyad) && (info >= o_eq)) {	/* aha : relop									*/
		reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any register									*/
		mvt = 0;
		subtree = x_arg1 [tree]; reg1 = compute();	/* compute ARG1									*/
		mvt = 0; reg_pref = (reg_pref & (~ reg1));	/* now for second argument						*/
		subtree = x_arg2 [tree]; compute();		/* compute second operand						*/
		opr = x_info [tree];					/* get type of relational operator				*/
		arg1 = x_arg1 [tree]; arg2 = x_arg2 [tree];
		fva = match (arg1, arg2);				/* set to same type								*/
		reg1 = ifreg (arg1); reg2 = ifreg (arg2);	/* get in register								*/
		
		if ((opr == o_eq) || (opr == o_ne)) {	/* eq, ne - can use either one					*/
			if (fva & 1) {						/* check floaters								*/
				if ((reg1 == b_ac1) || (reg2 == b_ac0)) xcompute_swap(tree);	/* put in optimized registers					*/
			}
			else {								/* fixed - just check ARG1						*/
				if (x_node [arg2] == x_reg) xcompute_swap(tree);	/* use existing register						*/
			}
		}										/* of these two									*/
		else if ((opr == o_gt) || (opr == o_le) || (opr == o_igt) || (opr == o_ile)) xcompute_swap(tree);
		if (fva & 1) {							/* floating										*/
			if (opr > o_ne) {
				opr = opr - 5;
				x_info [tree] = opr;
			}									/* no int ops if floating						*/
			if (reg2 == b_ac0) reg2 = fin_reg (arg2, ~ b_ac1);	/* move to AC1 if should						*/
			reg1 = fin_reg (arg1, ~ b_ac0);		/* get in register								*/
			fltflag = 0;						/* assume we can not skip the subtract			*/
			if (x_node [arg2] == x_const) {		/* see if floating pont cont					*/
				if (fstk [x_info [arg2]] == 0) fltflag = 1;	/* then we can									*/
			}
			if (fltflag & 1) {					/* then we can									*/
				emitc (0, b_ad + b_add);		/* set status flags for floating				*/
				fstk [x_info [arg2]] = (fixed) 0x8000;	/* and clear the slot							*/
			}
			else {								/* nonzero - subtract it						*/
				reg2 = fin_reg (arg2, ~ b_ac1);	/* get second in register						*/
				em_rtp (l_fps);					/* and subtract									*/
			}
			reg_free = (b_ac1 | b_ac2 | b_ac3);	/* these are free, free up AC0 below			*/
		}
		else {									/* fixed										*/
			if ((x_node [arg2] == x_const) && (x_info [arg2] == 0)) {	/* detect a zero								*/
				reg1 = in_reg (arg1, 0);		/* get arg in register							*/
				if ((zflags != reg1) || (opr >= o_ilt)) emitc (0, b_td + b_tsu + bitreg [reg1]);	/* set flags (inc. carry)						*/
			}
			else {								/* not comparing with zero						*/
				reg1 = in_reg (arg1, reg2);		/* get ARG1 in register							*/
				sendit (arg2, b_td + b_tsu + bitreg [reg1], reg1);	/* preserve register counts						*/
			}
		}										/* of fixed										*/
			
		/* Lllexpression compiler - XCOMPUTE (cont):
		.  
		.   In the above routine, we calculated each of the relational operands.
		.   The subtraction (comparison) has been performed.
		.  
		.   Now emit the proper conditional jump instruction, based upon
		.   which relationship was specified and which type we want. */
		
		if (trufirst & 1) {						/* emit jump on true condition					*/
			if (truel == 0) truel = galt();
			em_atr (tt [opr - o_eq], truel);
		}
		else {									/* emit jump on false condition					*/
			if (falsel == 0) falsel = galt();
			em_atr (ft [opr - o_eq], falsel);	/* jump											*/
		}
		xcomchk();								/* save REGU and REGL here if first jump		*/
		
		reg_free = (reg_free | reg1);
		x_rel (arg1); x_rel (arg2);
	}											/* of relops									*/
		
	else if ((node == x_monad) && (info == o_not)) {	/* just negate transfer conditions				*/
		subtree = truel; truel = falsel; falsel = subtree;	/* swap locations								*/
		trufirst = ((~ trufirst) & 1); subtree = x_arg1 [tree];	/* now compute subtree							*/
		xcompute();
		subtree = truel; truel = falsel; falsel = subtree;	/* swap true, false conditions					*/
		trufirst = ((~ trufirst) & 1);			/* and reverse flag								*/
		x_rel (x_arg1 [tree]);					/* done											*/
	}											/* of not										*/
		
	else if (node == x_const) {					/* check for constant							*/
		fix (tree);								/* fix it										*/
		if (trufirst & 1) {						/* emit jump to true							*/
			if (x_info [tree] & 1) {			/* true											*/
				if (truel == 0) truel = galt();
				xcomchk();
				em_atr (0, truel);				/* jump											*/
			}
		}
		else {									/* false										*/
			if (! (x_info [tree] & 1)) {		/* jump to false								*/
				if (falsel == 0) falsel = galt();	/* get one										*/
				em_atr (0, falsel);
				xcomchk();
			}
		}
	}											/* of constant									*/
		
	/* Lllexpression compiler - XCOMPUTE (cont):
	.  
	.   If the relationship is just a variable or an expression, 
	.   then we will compute it and check the result for bit 0.
	.  
	.   Example:
	.     if x + y then call zqr
	.  
	.   Give up - call COMPUTE and check for odd/even:	*/
	
	else {										/* must be variable, or something that requires computation	*/
		subtree = tree;							/* pass tree to compute							*/
		reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);
		mvt = 0;								/* is fixed										*/
		compute();								/* compute item									*/
		fix (tree);								/* and make sure fixed point					*/
		reg1 = in_reg (tree, 0);				/* get in any register							*/
		emitc (1, b_td + b_tan + bitreg [reg1]);	/* preserve regs, set flags						*/
		if (trufirst & 1) {						/* emit true on tnz								*/
			if (truel == 0) truel = galt();
			em_atr (b_tnz, truel);
		}
		else {									/* jump to false								*/
			if (falsel == 0) falsel = galt();	/* get one if we are first to jump				*/
			em_atr (b_tze, falsel);				/* jump to false								*/
		}
		xcomchk();
		reg_free = (reg_free | reg1);			/* free											*/
	}											/* of everything else							*/
	subtree = tree;								/* restore subtree								*/
	tree = pop();
}												/* and end here									*/
	/* Statement list routine - scans statements up to an 'END' statement. */
	
static	void	stmt();

static	void	stmt_stmt_list()
{
	scanc();									/* check for line number, label definition, or ZREG	*/
	token = peek();								/* get next token								*/
	while (! ((token == t_end) || (token == t_eof))) {
		stmt();
		scanc();								/* check for line numbers, etc.					*/
		token = peek();
	}
	gc();										/* skip over token of t.end						*/
}
	
static	void	stmt_compute_to_reg0()			/* scan expression, compute it, store in reg 0	*/
{
	scanc(); subtree = expr();					/* skip line no's and get expr from interfile	*/
	reg_pref = b_ac0; mvt = 0;					/* get result in AC0, look for fixed			*/
	compute(); fix (subtree);					/* fixed point									*/
	in_reg (subtree, ~ b_ac0);
	reg_free = (reg_free | b_ac0); x_rel (subtree);
}
	
	/* first a convenient sub: */
	
static	void	stmt_pstmt_pins(				/* subroutine to emit call to PRINT				*/
	fixed	loc,
	fixed	pdes)	_was_nested("stmt_pstmt", "pins") {
	static	fixed	blk;
	
	blk = x_get(); x_node [blk] = x_const;
	x_arg1 [blk] = t_var; x_info [blk] = pdes;
	in_reg (blk, ~ b_ac2);						/* get destination in AC2						*/
	reg_free = (reg_free | b_ac2);				/* but register is actually free				*/
	x_rel (blk);								/* done with block								*/
	em_rtp (loc);
	freeup (b_ac0); freeup (b_ac1); freeup (b_ac3);	/* trashed										*/
}
	
	/* $$Statement scanner - handle the PRINT/SEND statement: */
	
static	void	stmt_pstmt()					/* just call - device type is in intermediate file	*/
{
	static	fixed	pdes, rl;					/* holds node block and temp					*/
	
	static	fixed	rtab[] = {l_opr, l_pch};	/* print formats								*/
	
	pdes = gc();
	scanc();									/* skip lnums									*/
	
	while (peek() != 0) {						/* and do until end of print list				*/
		switch (gc() - 1) {						/* branch on type of print statement			*/
		
			case 0:
				stmt_pstmt_pins (l_pri, pdes);	/* print crlf									*/
				
				break;
			case 1:
			{									/* expression									*/
				scanc();						/* lnums here									*/
				mvt = 1;						/* assume worst case							*/
				subtree = expr(); reg_pref = b_ac0; compute();	/* get and compute expression					*/
				if ((x_arg1 [subtree] & t_fvar) != 0) {	/* floating print								*/
					fin_reg (subtree, ~ b_ac0); reg_free = (reg_free | b_ac0 | b_ac1);	/* get in reg									*/
					rl = l_fpr;					/* floating print								*/
				}
				else {							/* fixed point									*/
					in_reg (subtree, ~ b_ac0); reg_free = (reg_free | b_ac0);	/* get in reg									*/
					rl = l_npr;					/* number print									*/
				}								/* of fixed										*/
				x_rel (subtree);				/* done with expression							*/
				stmt_pstmt_pins (rl, pdes);		/* emit instructions							*/
				if (rl == l_fpr) freeup (b_ac2);	/* floating print trashes AC2					*/
				break;
			}									/* of expression								*/
				
			case 2:
			{									/* string										*/
				em_spt (gc(), b_rd + 0);		/* get string pointer in AC0					*/
				stmt_pstmt_pins (l_spr, pdes);	/* and print it									*/
				break;
			}
				
			case 3:
			{									/* print string									*/
				static	fixed	sclass, info;
				token = gc(); sclass = gc(); info = gc();	/* get type, sclass, and location				*/
				if ((token == t_sconst) || (token == t_fxdata) || (token == t_fldata))/* scon or data									*/
					em_spt (info, b_rd + 0);	/* pointer in AC0								*/
				else if (token == t_arr) {		/* Print string(array)							*/
					if (info == 0)				/* Core? - someone has big ideas				*/
						emitc (0, b_rd + 0);							/* String(core)									*/
					else sendvp (sclass, info, b_rd + 0, 0);				/* else emit variable pointer					*/
				}
				else if (token == t_locat) stmt_compute_to_reg0();	/* Print string(location(x))					*/
				else {							/* must be pointer to array						*/
					static	fixed	reg1;
					reg1 = getvp (sclass, info, 0);	/* get pointer register pointing to pointer		*/
					emita (b_ms + reg1, b_rd + 0);	/* load pointer to array into AC0				*/
				}
				stmt_pstmt_pins (l_spr, pdes);	/* and use same routine							*/
				break;
			}
				
			case 4:
			{									/* character:									*/
				rl = rtab [gc()];				/* get it										*/
				stmt_compute_to_reg0();
				stmt_pstmt_pins (rl, pdes);		/* and print character							*/
				break;
			}
		}										/* of do case									*/
		scanc();								/* ignore stuff here							*/
	}											/* of do while									*/
	gc();										/* to skip over final zero						*/
}												/* and end of it								*/
	
/* Statement scanner:
. 
.  Statement scanning routine:  This scans off the next statement
.  including the semicolon and compiles code to execute it.  A statement
.  includes the label on the statement.  This routine is obviously very
.  recursive, calling both itself and the statement list routine. */

static	void	stmt()
{
	static	fixed	stype, sclass, sinfo, wdes;
	static	fixed	fva, pva, dreg, ireg, subscr, val, snode, xinfo;
	static	fixed	reg1, reg2, d1;
	static	fixed	pbk, i, j, k, reg_e;		/* used in loop processing						*/
	static	fixed	arg_, temp, temps, slen, reg_arg, dswp;	/* and in proc defs								*/
	static	fixed	prockey, pbits;				/* pbits contains the procedures attributes		*/
	static	fixed	regd, ffregs;
	static	fixed	dest;
	
	/* $$Statement scanner - check for statement: */
	
	_stmts++;
	
	scanc();									/* check for line number, etc.					*/
	token = peek();								/* get current one								*/
	
	if (token == t_ldef) {						/* was a label definition at start of statement	*/
		gc(); em_lde (gc());					/* label def - this is key						*/
		regzap();								/* indicate all index register unknown (goto)	*/
		accpurg();								/* indicate all registers unknown				*/
		zflags = 0;
		scanc();								/* skip labels here								*/
		token = peek();							/* and new token, maybe							*/
		if (token == t_end) return;				/* and detect label: end here					*/
	}
		
	if (token == t_null) {						/* null statment								*/
		gc(); scanc();
		return;
	}
		
	/* $$Statement scanner - assignment:
	. 
	.   Assignment:
	. 
	.   Get expression and subscript if one.
	. 
	.   Compute value and store in desired location.	*/
	
	if ((token & 0x00FF) == t_assign) {			/* assignment									*/
		gc();									/* skip assign token							*/
		stype = shr(token, 8);					/* extract type									*/
		sclass = gc();							/* storage class								*/
		sinfo = gc();							/* and variable info							*/
		scanc();								/* skip line #'s, etc.							*/
		if (stype == t_pvar) stype = t_var;		/* and fix up to be variable					*/
		fva = (stype & t_fvar) != 0; pva = (stype & t_pvar) != 0;	/* fl var attrib, ptr var attrib				*/
		if (stype & 1) subscr = expr();			/* scan expression if subscripted				*/
		else subscr = 0;						/* plain										*/
		mvt = fva;								/* set mvt to 0 (fixed) or 1 (floating)			*/
		val = expr();
		subtree = val;
		reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);
		regd = compute();						/* compute VAL									*/
		
		if (subscr != 0) {						/* handle subscripted							*/
			snode = x_get();
			x_node [snode] = x_var;
			x_arg1 [snode] = (shl(sclass, 8) | stype);
			x_arg2 [snode] = subscr;
			x_info [snode] = sinfo;				/* set up type and location						*/
			subscript (snode, val);				/* store VAL in subscripted variable			*/
			x_rel (snode);						/* done with node								*/
		}
			
		else if ((x_node [val] == x_var)		/* if node is variable							*/
		&&       (x_arg1 [val] == (shl(sclass, 8) | stype))/* of same class & type							*/
		&&       (x_info [val] == sinfo))		/* at same location								*/
		{
			/* do nothing if assignment of a=a since floating point blows up */
		}
			
		else {									/* emit assignment instructions					*/
			if (fva & 1) {
				floatme (val);					/* make sure floating if floating assignment	*/
				ffregs = iffreg(val);			/* get fixed point regs							*/
			}
			else if ((x_arg1 [val] & t_fvar) != 0)
			{ 	er_fna(); fix (val); }			/* floating assigned to fix - warn user			*/
			if (pva & 1) {						/* pointer to floating variable, must load		*/
				ireg = reg_allc (ffregs);		/* get another accumulator						*/
				dreg = getvp (sclass, sinfo, ffregs | ireg);	/* now get pointer to variable area				*/
				emita (b_ms + dreg, b_rd + bitreg [ireg]);	/* load pointer into accumulator. through with dreg now	*/
				freeup (ireg);					/* no trackable contents here					*/
				dest = b_md + b_ibt + bitreg [ireg];	/* compute destination							*/
				fsendit (val, dest, dest, ireg | ffregs);	/* and store the value in location				*/
			}									/* and REG.FREE is all set						*/
			else {								/* regular item									*/
				if (fva & 1) {					/* floater										*/
					dreg = getvp (sclass, sinfo, ffregs);	/* get pointer to variable area					*/
					dest = b_md + b_ibt + dreg;	/* pointer										*/
					fsendit (val, dest, dest, ffregs | regbit[dreg]);	/* store same									*/
					regl = (regl | regbit [dreg]); regc [dreg] = regc [dreg] + 2;	/* it was incremented							*/
				}
				else {
					dreg = getvp (sclass, sinfo, regd);	/* get pointer to variable area					*/
					sendit (val, b_md + dreg, regd | regbit[dreg]);	/* store result									*/
				}
			}
				
			/* delete optimizing tree entries that refer to this variable */
			/* since it's value has now changed                           */
			
			d1 = 1;								/* start with AC0								*/
			for (i = 0; i <= b_amsk; i++) {		/* see if any saved register affected by this var	*/
				xinfo = trees [d1];
				if (xinfo != 0) {				/* check contents								*/
					if (tree_var (xinfo, sclass, sinfo) & 1) freeup (d1);
				}
				d1 = shl(d1, 1);
			}
			if (fva == 0) {						/* if scalar fixed point, indicate reg contains var	*/
				if (x_node [val] == x_reg) {	/* yes - record it								*/
					d1 = x_info [val];			/* which reg									*/
					freeup (d1);
					xinfo = x_get();			/* get block									*/
					x_node [xinfo] = x_var; x_arg1 [xinfo] = (shl(sclass, 8) | t_var); x_info [xinfo] = sinfo;
					trees [d1] = xinfo;			/* this register contains a variable now!		*/
				}
			}
		}										/* of non-arrays								*/
			
		x_rel (val);							/* and done with VAL block						*/
	}											/* of handling assignment						*/
		
	/* $$Statement scanner - other statements:		*/
	
	else if ((token & 255) == t_stmt) {			/* statement									*/
		gc();									/* skip over this token							*/
		sinfo = shr(token, 8);					/* get it										*/
		switch (sinfo) {						/* branch on statement type						*/
		
		/* Statement scanner - CALL statement:			*/
		
			case 0:
			{
				scanc();						/* ignore any junk from pass1					*/
				subtree = expr();				/* get expression from intermediate file		*/
				reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any reg										*/
				compute();						/* this forces calling the procedure			*/
				reg_free = (reg_free | b_ac0 | b_ac1);	/* just in case of a floating result			*/
				x_rel (subtree);				/* and the block								*/
				break;
			}
				
			/* Statement scanner - RETURN statement:		*/
			
			case 1:
			{
				
				if (gc() != 0) {				/* means was an expression						*/
					mvt = gc();					/* get type to return - T.VAR or T.FVAR			*/
					reg1 = mvt;					/* save for later too							*/
					scanc();					/* check for line number						*/
					subtree = expr();			/* scan arithmetic expression					*/
					reg_pref = b_ac0;			/* try to get it into AC0						*/
					compute();					/* compute it									*/
					fva = (x_arg1 [subtree] & t_fvar) != 0;
					if (reg1 == t_var) {								/* must return fixed							*/
						if (fva & 1) { er_fna(); fix (subtree); }
						in_reg (subtree, ~ b_ac0);						/* get SUBTREE in reg							*/
						reg_free = (reg_free | b_ac0);
					}
					else {
						floatme (subtree);								/* make sure a floater							*/
						fin_reg (subtree, ~ b_ac0);						/* and answer in AC0							*/
						reg_free = (reg_free | b_ac0 | b_ac1);
					}
					x_rel (subtree);			/* release block								*/
				}
					
				em_tra (0, gc());				/* emit location to jump to						*/
				
				break;
			}
				
			/* $$Statement scanner - PROCEDURE definition:
			.
			.   To process a procedure definition, a 5 word block of keys is
			.   allocated.  These are used to process:
			.     key + 0 = the entry location for the proc
			.     key + 1 = the jump around location
			.     key + 2 = the return location
			.     key + 3 = a bit encoded word indicating which registers used by proc
			.     key + 3 (in KEYJTO) = NOSWAP bitlist and code size for swapping procs
			.     key + 4 = stack frame size
			.     key + 4 (in KEYJTO) = temp start for recursive procs only
				*/
			
			case 2:
			{
				pushv();						/* push REGL, REGU, and zero them				*/
				pushr();						/* push registers onto stack					*/
				regzap();						/* empty out all registers						*/
				accpurg();
				zflags = 0;						/* no ZFLAGS set on entry						*/
				regl = 0;						/* but we really did not load them				*/
				pushtemp();						/* push and zero temp list ptrs					*/
				push (in_recursive);			/* save recursive flag							*/
				
				temp = gc();					/* pick up starting ram location put there by pass1	*/
				prockey = gc();					/* and get N word block of keys for this procedure def	*/
				pbits = gc();					/* pick up procedure attribute bits				*/
				if ((pbits & p_swap) != 0) {	/* if swappable proc, restart CUR.LOC			*/
					swaploc = cur_loc;			/* save CUR.LOC									*/
					cur_loc = 0;				/* and reset to zero							*/
				}
				reg_arg = gc();					/* get number of register arguments passed		*/
				if ((pbits & p_recursive) != 0) {	/* recursive proc?								*/
					in_recursive = prockey;		/* flag a recursive proc with the proc's key	*/
					i = reg_arg;				/* and pass on all args							*/
					temps = 0;					/* start of temps is meaningless here			*/
					sclass = s_automatic;		/* args are on stack							*/
				}
				else {							/* not recursive								*/
					in_recursive = 0;			/* not in a recursive proc						*/
					i = 0; temps = ram;			/* don't pass any args on to pass3; temps at RAM	*/
					sclass = s_static;			/* args are static								*/
				}
				em_pdf (prockey, reg_arg, temp, temps, pbits, i);	/* emit procedure definition					*/
				
				for (i = 0; i < reg_arg; i++) {	/* emit appropriate store instructions			*/
					temp = gc();				/* get location of variable						*/
					if ((in_recursive != prockey) || (i < 3)) {			/* register three gets trashed by recursive procs	*/
						xinfo = x_get();
						x_node [xinfo] = x_var;
						x_arg1 [xinfo] = (shl(sclass, 8) | t_var);		/* indicate reg									*/
						x_info [xinfo] = temp;
						trees [regbit [i]] = xinfo;						/* contains arg									*/
					}													/* of make sure we remember the registers we know about	*/
					if (in_recursive != prockey) {						/* if not defining a recursive proc				*/
						temp = getvp (s_static, temp, 0);				/* and get variable pointer to location			*/
						if (i == reg_arg - 1) emita (b_rs + i, b_md + temp);	/* no incre if final argument					*/
						else {											/* use increment bit only on the first ones, so it ends up pointing to something usefull (hopefully)	*/
							emita (b_rs + i, b_md + b_ibt + temp);		/* use inc here									*/
							regc [temp] = regc [temp] + 1;				/* and keep track								*/
						}
					}													/* of not in recursive proc						*/
					else emit (temp);									/* pass location through to pass three for recursive procs	*/
				}								/* of emit appropriate stores					*/
					
				if (in_recursive == prockey) {	/* are we defining a recursive procedure?		*/
					push (ram);					/* save the current size of ram					*/
					ram = temp_base;			/* reset ram pointer for temporary allocation	*/
				}								/* of defining a recursive proc					*/
					
				/* scan statement list							*/
				
				push (pbits);					/* save procedure bits							*/
				push (prockey);
				stmt_stmt_list();
				prockey = pop();
				pbits = pop();					/* restore proc bits							*/
				dswp = gc();					/* pick up NOSWAP bit list for data statements	*/
				temp = gc();					/* pick up final ram location to toss dcl's in proc def	*/
				temps = gc();					/* pick up stack length/temp offset				*/
				
				em_lde (prockey + 2);			/* emit label definition for 'return'			*/
				
				if (in_recursive == prockey) {	/* are we ending a recursive proc?				*/
					slen = temps + (ram - temp_base);	/* compute stack length (add in space used for temps)	*/
					if (slen != 0)				/* if non-zero stack length						*/
						regl = (regl | regbit [0x0009]);				/* yes, save R11 to use entering proc			*/
					ram = pop();				/* restore next ram location					*/
				}								/* of recursive proc							*/
				else { slen = temps; temps = ram; }	/* not in recursive - get temp end				*/
				in_recursive = pop();			/* restore recursion flag						*/
				
				em_pen (prockey, temp, temps, slen, regl, dswp);	/* emit end of procedure						*/
				
				if ((pbits & p_swap) != 0) cur_loc = swaploc;	/* reset CUR.LOC at end of swappable proc		*/
					
				/* release temporaries							*/
				
				freetemp();
				poptemp();						/* and pop temps from stack						*/
				
				/* restore index registers */
				
				popr();							/* restore regs									*/
				regu = pop(); regl = pop();		/* and restore REGU, REGL, without changing		*/
				accpurg();						/* indicate accumulators free now				*/
				zflags = 0;
				break;
			}									/* procedure statement							*/
				
			/* Statement scanner - BEGIN statement:			*/
			
			case 3:
			{
				scanc();						/* check for line numbers, etc.					*/
				stmt_stmt_list();				/* get a list of statements followed by 'END'	*/
				break;
			}
				
			/* $$Statement scanner - DO statement:			*/
			
			case 4:
			{
				/* Statement scanner - DO statement: */
				
				static	fixed	temp_a, temp_b, temp_c, num_of_cases;
				
				token = gc();					/* get next word to identify DO loop type		*/
				
				/* 'do;' */
				
				if (token == t_semi) {
					stmt_stmt_list();			/* get a list of statements followed by 'END'	*/
				}
					
				else {							/* Do loops										*/
					if (token == t_case) {								/* Do case										*/
						
						/*
						.   object code:
						.   example 'do case var1; stmt1; stmt2; stmt3; stmt4; end;'
						. 
						.   VAR1    to R0       pick up VAR1 (case #)
						.   re(XYZ) to RTRA     jump until after cases object code
						.   xyz.0: (object code for stmt1)
						.   xyz.1: (object code for stmt2)
						.   xyz.2: (object code for stmt3)
						.   xyz.3: (object code for stmt4)
						. 
						.   xyz: ...                 handle DO CASE
						.   im(# of cases) to TSUB0  see if in range
						.   re(ZZZ)        to RTRC   skip if out of range
						.
						.For models A, B, C, or Model D Internal Memory Procedures:
						.   PC             to ADD0   make the case # relative to the PC
						.   im(2)          to ADD0   compensate for two instructions to convert to PC-relative
						.   MR0            to ATRA   transfer indirectly to proper statement
						.   xyz.0 (pointer to code for case 0)
						.   xyz.1 (pointer to code for case 1)
						.   xyz.2 (pointer to code for case 2)
						.   xyz.3 (pointer to code for case 3)
						.
						.For Model D (in swapping procedures only)
						.   r0             to add0   shift left
						.   r0             to rtra   jump into jump table
						.   pci to atra    jump for case 0
						.   xyz.0          pointer for case 0
						.   pci to atra    jump for case 1
						.   xyz.1          pointer for case 1
						.   zzz: ...
						*/
						
						scanc();										/* check for line numbers, etc.					*/
						subtree = expr();								/* scan expression								*/
						reg_pref = b_ac0;								/* try to get result in AC0						*/
						mvt = 0;										/* and we want fixed							*/
						
						compute();										/* compute the argument							*/
						
						fix (subtree);
						in_reg (subtree, b_ac1 | b_ac2 | b_ac3);		/* put result in AC0 for sure					*/
						x_rel (subtree);								/* through with this tree						*/
						reg_free = (reg_free | b_ac0);					/* Ac0 is now free								*/
						temp_a = galt();								/* get key for jump to after cases				*/
						temp_b = galt();								/* and for jump to exit point					*/
						em_atr (0, temp_a);								/* jump there									*/
						scanc();										/* check for line numbers						*/
						token = peek();									/* get next item								*/
						num_of_cases = 0;								/* initial number of cases						*/
						
						/* Statement scanner - DO loops - DO CASE (cont): 
						. 
						.   Now scan the statements until an END is found. */
						
						pushv();										/* save REGU and REGL, set to zero				*/
						if (token != t_end)								/* watch out for null DO-CASE					*/
							start_queue();								/* start object pointer queue here				*/
						while (token != t_end) {						/* until END									*/
							temp_c = gkey();							/* get key to define start of this case			*/
							em_lde (temp_c);							/* and locate it here							*/
							enqueue (temp_c);							/* and enqueue it to emit an object pointer later	*/
							accpurg();									/* accumulators free on entry					*/
							zflags = 0;
							pushr();									/* put start of case registers on stack			*/
							pushv();									/* and push REGL, REGU							*/
							push (temp_b);								/* ditto TEMP.B									*/
							push (num_of_cases);						/* save number									*/
							push (temp_a);								/* save here for immediate recall				*/
							stmt();										/* get this statement (recursion !!!!!)			*/
							temp_a = pop();								/* restore location								*/
							num_of_cases = pop() + 1;					/* recover and increment NUM.OF.CASES			*/
							temp_b = pop();								/* restore goto block							*/
							em_atr (0, temp_b);							/* emit jump to after cases						*/
							regu = regu | pop();						/* a register is used if used by any case		*/
							regl = regl | pop();						/* ditto										*/
							popr();										/* reload registers for start of case			*/
							token = peek();								/* and grab next token for END check			*/
						}												/* of do while									*/
							
						/* object code is out */
						
						gc();											/* skip T.END									*/
						em_ald (temp_a);								/* case logic located here						*/
						emitc (num_of_cases, b_td + b_tsu + 0x0000);	/* im(NUM.OF.CASES) to TSUB0 - see if out of range (case # is in R0)	*/
						em_atr (b_trc, temp_b);							/* re(TEMP.B) to RTRC - skip if out of range	*/
						em_cas();										/* emit a do case record to create correct object code	*/
 						for (temp_a = 1; temp_a <= num_of_cases; temp_a++) {	/* for every case								*/
							em_opt (dequeue());							/* emit pointer to object routine				*/
						}												/* of loop										*/
						regclr (regl);									/* zap any regs used by any of the cases		*/
						popv();											/* update REGU and REGL for this block			*/
						em_ald (temp_b);								/* and this is location after cases				*/
						accpurg();										/* accumulators free here						*/
						zflags = 0;
					}													/* of 'DO CASE'									*/
						
					/* Statement scanner - DO loops - DO WHILE:
					. 
					.    Process DO WHILE loop:
					. 
					.      Scan expression, compute it.
					.      Then scan statement list.
					.      Pass back appropriate registers.
					.      Then jump back.	*/
					
					else {												/* do loops (while, i =)						*/
						
						if (token == t_while) {							/* Do while										*/
							
							static	fixed	while_ret;					/* use for jump back							*/
							
							scanc();									/* check for lnums, etc.						*/
							while_ret = galt();							/* get key for return							*/
							em_ald (while_ret);							/* locate it									*/
							accpurg();									/* empty accumulators at start of loop			*/
							zflags = 0;
							pushv();									/* push variables								*/
							pushr();									/* save regs for passback						*/
							
							subtree = expr();							/* scan expression								*/
							xcomset();									/* set up for call to XCOMPUTE					*/
							xcompute();									/* and process jump instructions				*/
							xcomchk();									/* check for no jump instructions emitted		*/
							
							sreg1();									/* save regs here								*/
							lreg();										/* get earlier regs								*/
							pushr();									/* stack them									*/
							lreg1();									/* push regs at first jump						*/
							
							xcompv();									/* and push REGU, REGL as of first jump			*/
							donewith (truel);							/* done with this - locate it if we jumped here	*/
							x_rel (subtree);							/* done with SUBTREE							*/
							
							/* scan statement list */
							
							scanc();									/* scan for line numbers, etc.					*/
							push (falsel);								/* push this key for later locating				*/
							push (while_ret);							/* save for jump back							*/
							
							stmt_stmt_list();							/* scan a list followed by 'END'				*/
							
							while_ret = pop();
							falsel = pop();								/* restore pointers								*/
							xcregl = regl;								/* preserve ones actually loaded after first jump	*/
							
							popv();										/* get used, loaded from initial loop entry		*/
							popr();										/* get regs at first jump						*/
							sreg();										/* save in temp									*/
							popr();										/* and get regs at start of loop				*/
							sreg1();									/* save in t1 to look up info					*/
							
							pbk = (regu & regl);						/* detect those used and then loaded in above	*/
							if (pbk != 0) for (i = min_ptr_reg; i <= max_ptr_reg; i++) {	/* pass back req'd regs							*/
								if ((pbk & regbit [i]) != 0) {			/* reload register								*/
									lreg1();							/* get info to pass back						*/
									j = regc [i];						/* save storage class							*/
									
									for (k = min_ptr_reg; k <= max_ptr_reg; k++) {	/* indicate all are blank						*/
										regc[k]=0;						/* so optimizing does not						*/
									}									/* find one										*/
									getvp (regs [i], j, (~ 15) ^ regbit[i]);	/* use getvp to load it							*/
								}										/* of reload registers							*/
							}
								
							em_atr (0, while_ret);						/* and jump back to start of DO loop			*/
							
							lreg();										/* get regs at first jump						*/
							push (regl);								/* save regs used by entire loop				*/
							regl = xcregl;								/* and get regs used by loop after first jump only	*/
							donewith (falsel);							/* and done with failure jump					*/
							regl = pop();								/* restore regl to actual loaded during entire loop	*/
							popv();										/* update previous REGL and REGU of upper level	*/
						}												/* of while loop								*/
							
						/* Statement scanner - DO. loops - iterative (do i = 1 to 2 by 3):	*/
						
						else {											/* must be do. i = (TOKEN contains variable type)	*/
							static	fixed	do_out, iclass, index, xindex, lower, upper, step, negstep, v_indx, t_indx, reg_indx, reg_step, reg_upper, reg_lower, reg_temp;
							static	fixed	do_loop, do_vtype, do_start;
							
							iclass = gc();								/* get storage class of index (TOKEN already contains the variable type)	*/
							index  =  gc();								/* get variable location						*/
							if (token == t_pvar) token = t_var;			/* and change to var at this time if we should	*/
								
							t_indx = token;								/* save variable type (T.VAR, T.FVAR, T.PVAR, T.PFVAR)	*/
							
							do_vtype = ((t_indx & t_fvar) != 0);
							
							scanc();									/* skip over line numbers, etc. up to expressions	*/
							lower = expr();								/* recover lower expr							*/
							upper = expr();								/* and upper									*/
							step = expr();								/* and the step									*/
							
							/* now massage step - compute if required,  then store it */
							
							subtree  = step;							/* set up for computing step					*/
							reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* in any reg.									*/
							mvt      = do_vtype;						/* and select desired type						*/
							
							reg_step = compute();						/* compute step into a register					*/
							
							if (do_vtype & 1) {
								floatme (step);							/* float it										*/
								reg_step = iffreg(step);				/* get FIXED POINT REGISTERS  holding result	*/
							}
							else if ((x_arg1 [step] & 0x00FF) != t_var)
							{
								er_fna();
								fix (step);
							}											/* fix it										*/
								
							if (x_node [step] != x_const) {				/* allocate temp unless constant				*/
								temp_a = gtemp (do_vtype);				/* allocate temp								*/
								v_indx = getvp (s_temporary, temp_a, reg_step);	/* get ptr to where to store					*/
								if (do_vtype & 1) {						/* floaters										*/
									fsendit (step, b_md + b_ibt + v_indx, b_md + b_ibt + v_indx, reg_step | regbit[v_indx]);	/* store variable								*/
									regc [v_indx] = regc [v_indx] + 2;
									regl = (regl | regbit [v_indx]);
								}
								else sendit (step, b_md + v_indx, reg_step | regbit[v_indx]);	/* do it - will free up register here			*/
								x_node [step] = x_var;					/* flag as such									*/
								x_info [step] = temp_a;					/* ptr to loc block								*/
								x_arg1 [step] = (shl(s_temporary, 8) | (t_indx & t_fvar));	/* set to fixed or floating						*/
								negstep = 0;							/* step can only be negative if constant		*/
							}											/* of calculated step							*/
							else {										/* constant step								*/
								if (do_vtype & 1)						/* floaters										*/
									negstep = (fstk [x_info [step]] < 0);	/* see if negative step							*/
								else negstep = (x_info [step] < 0);		/* check for fixed negative step				*/
								temp_a = -1;							/* flag we didn't allocate this temp (tenuous at best)	*/
							}											/* of constant step								*/
								
							/* Statement scanner - DO. loops - iterative (cont):
							  . 
							  .   If the upper limit of the do. loop is a variable, then store
							  .   it in a unique place, so that end checks do not get fouled up. */
							
							/* massage 'upper' */
							
							subtree = upper;							/* calculate upper value						*/
							reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any reg.										*/
							mvt = do_vtype;								/* and this is variable type					*/
							
							reg_upper = compute();						/* compute into register						*/
							
							if (do_vtype & 1) {
								floatme (upper);						/* float it										*/
								reg_upper = iffreg(upper);				/* get FIXED POINT REGISTERS  holding result	*/
							}
							else if ((x_arg1 [upper] & 0x00FF) != t_var)
							{ 	er_fna(); fix (upper); }
								
							if (x_node [upper] != x_const) {			/* allocate a temp unless constant				*/
								temp_b = gtemp (do_vtype);				/* get unique temporary							*/
								v_indx = getvp (s_temporary, temp_b, reg_upper);	/* get pointer to upper							*/
								if (do_vtype & 1) {						/* handle floaters here							*/
									fsendit (upper, b_md + b_ibt + v_indx, b_md + b_ibt + v_indx, reg_upper | regbit[v_indx]);	/* store uper									*/
									regc [v_indx] = regc [v_indx] + 2; regl = regl | regbit [v_indx];	/* store this									*/
								}
								else sendit (upper, b_md + v_indx, reg_upper | regbit[v_indx]);	/* else store upper								*/
								x_node [upper] = x_var;					/* change type to variable						*/
								x_info [upper] = temp_b;				/* pointer to loc block							*/
								x_arg1 [upper] = (shl(s_temporary, 8) | (t_indx & t_fvar));	/* fixed or floating							*/
								do_start = galt();						/* get key for tze jump							*/
							}											/* of calculating upper							*/
							else {										/* is a constant								*/
								temp_b = -1;							/* flag we didn't allocate this temp (tenuous at best)	*/
								if ((do_vtype == 0) && (negstep == 0)) {	/* fixed point & pos step - add 1 and skip tze	*/
									x_info [upper] = x_info [upper] + 1;
									do_start = 0;						/* no key										*/
								}
								else do_start = galt();					/* for floaters, must do it anyways				*/
							}
								
							/* Statement scanner - DO loops - iterative (cont):
							  . 
							  .   Now calculate starting value and get in a register.  Enter the place
							  .   where we perform a store and then start the loop. */
							
							/* massage 'lower' */
							
							subtree = lower;							/* lower										*/
							reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any reg.										*/
							mvt = do_vtype;								/* get type										*/
							
							compute();									/* get it										*/
							
							if (do_vtype & 1) floatme (lower);			/* float it										*/
							else if ((x_arg1 [lower] & 0x00FF) != t_var)
							{ 	er_fna(); fix (lower); }
								
							if (do_vtype & 1) {							/* floaters here								*/
								fin_reg (lower, ~ b_ac0);				/* get lower in floating point reg0 FPR0		*/
								reg_indx = iffreg(lower);				/* get fixed point registers holding result (for getvp)	*/
								reg_free = (reg_free | b_ac0 | b_ac1);	/* and yet free up regs cause we jump			*/
							}
							else {
								reg_indx = in_reg (subtree, 0);
								reg_free = (reg_free | reg_indx);		/* yet still free								*/
							}
								
							getvp (iclass, index, reg_indx);			/* get pointer handy							*/
							do_loop = galt(); em_ald (do_loop);			/* and this is restart point					*/
							accpurg();
							zflags = 0;
							pushv();									/* save REGU, REGL								*/
							pushr();									/* so we can load them for passback				*/
							
							/* Statement scanner - DO loops - iterative (cont):
							  . 
							  .   We have calculated the step, upper, and lower bounds.
							  .   The lower bound is in a register and is ready for storing.
							  . 
							  .   Now construct expression tree for index variable increment.
							  .   The actual code is not emitted until the end of the loop */
							
							xindex = x_get();
							x_node [xindex] = x_var;
							x_arg1 [xindex] = (shl(iclass, 8) | t_indx);
							x_info [xindex] = index;					/* variable loc block							*/
							
							subtree = x_get();							/* get a SUBTREE for fake addition expression	*/
							
							x_node [subtree] = x_dyad;					/* +											*/
							x_info [subtree] = o_plus;
							x_arg1 [subtree] = xindex;					/* variable										*/
							x_arg2 [subtree] = step;					/* + step										*/
							zflags = 0;
							v_indx = getvp (iclass, index, reg_indx);	/* get pointer to index							*/
							switch (shr(t_indx, 1)) {					/* store based on type of index					*/
							
								case 0:
								{
									emita (b_rs + bitreg [reg_indx], b_md + v_indx);	/* store word									*/
									break;
								}
									
								case 1:
								{
									emita (b_rs + 0, b_md + b_ibt + v_indx); emita (b_rs + 1, b_md + b_ibt + v_indx);
									regl = (regl | regbit [v_indx]);
									regc [v_indx] = regc [v_indx] + 2;
									break;
								}
									
								case 2:
									;									/* not used										*/
									
									break;
								case 3:
								{										/* pfvar										*/
									reg_temp = reg_allc (b_ac0 | b_ac1);	/* allocate AC2 or AC3 for pointer				*/
									emita (b_ms + v_indx, b_rd + bitreg [reg_temp]);	/* load pointer into accumulator				*/
									emita (b_rs + 0, b_md + b_ibt + bitreg [reg_temp]);
									emita (b_rs + 1, b_md + b_ibt + bitreg [reg_temp]);	/* store it										*/
									freeup (reg_temp);					/* indicate empty								*/
									break;
								}
									
							}											/* of store do case								*/
								
							/* Statement scanner - DO loops - iterative (cont):
							  . 
							  .   Now scan the statement list, pass back registers, and emit the final
							  .   jump back to the start of the loop. */
							
							if (do_vtype & 1) {							/* floater										*/
								fin_reg (upper, ~ b_ac1);
								em_rtp (l_fps);
								reg_indx = b_ac0;
								reg_free = (b_ac1 | b_ac2 | b_ac3);
							}
							else {										/* fixed point									*/
								sendit (upper, b_td + b_tsu + bitreg [reg_indx], reg_indx);	/* perform test									*/
								xinfo = x_get();
								x_node [xinfo] = x_var;
								x_arg1 [xinfo] = (shl(iclass, 8) | t_var);
								x_info [xinfo] = index;
								trees [reg_indx] = xinfo;				/* indicate index is in reg for optimizing		*/
							}
								
							do_out = galt();							/* get key for out								*/
							if (negstep & 1)							/* if a negative constant step					*/
								em_atr (b_tmi, do_out);					/* if negative, exit							*/
							else {										/* positive constant or variable step			*/
								if (do_start != 0) em_atr (b_tze, do_start);	/* jump to start								*/
								em_atr (b_tpl, do_out);					/* if plus, then exit							*/
							}
								
							reg_free = (reg_free | reg_indx);
							
							if (do_start != 0) em_ald (do_start);
							x_rel (upper);								/* done											*/
							x_rel (lower);								/* ditto										*/
							
							/* get the loop statement list */
							
							push (temp_b); push (temp_a);				/* save temps									*/
							push (do_out);
							push (do_loop);								/* save loop address for recursion				*/
							pushr();									/* so we know what regs are on loop exit		*/
							push (regl);								/* save which were loaded during test and store	*/
							push (subtree);								/* save increment subtree						*/
							push (reg_indx);							/* which registers								*/
							push (do_vtype);							/* and type										*/
							
							stmt_stmt_list();							/* get a list									*/
							
							/* now emit code for increment of step */
							
							do_vtype = pop();							/* restore type									*/
							reg_indx = pop();							/* and which register							*/
							subtree = pop();							/* and increment tree							*/
							
							reg_pref = reg_indx;
							mvt = do_vtype;								/* set up for computation of increment			*/
							
							compute();									/* emit code for increment of step				*/
							
							if (do_vtype & 1) {
								fin_reg (subtree, ~ b_ac0);
								reg_free = (reg_free | b_ac0 | b_ac1);
							}
							else {
								in_reg (subtree, ~ reg_indx);
								reg_free = (reg_free | reg_indx);
							}
								
							reg_e = pop();								/* get which regs were loaded during add and store	*/
							pbk = (regu & regl);						/* pass back anything used in orig form, and then loaded	*/
							popr();										/* and get what regs were on jmp to exit		*/
							sreg();										/* store them									*/
							
							do_loop = pop(); do_out = pop();			/* and restore									*/
							temp_a = pop(); temp_b = pop();				/* get temps back								*/
							
							popr();										/* these are the regs that we must restore from	*/
							sreg1();									/* save in second temporary						*/
							
							if (pbk != 0) for (i = min_ptr_reg; i <= max_ptr_reg; i++) {	/* pass back req'd regs							*/
								if ((pbk & regbit [i]) != 0) {			/* reload register								*/
									lreg1();							/* get info to pass back						*/
									j = regc [i];						/* save storage class							*/
									for (k = min_ptr_reg; k <= max_ptr_reg; k++) {	/* indicate all are blank						*/
										regc[k]=0;						/* so optimizing does not						*/
									}									/* find one										*/
									getvp (regs [i], j, ((~ 15) ^ regbit[i]) | reg_indx);	/* use getvp to load it							*/
								}										/* of reload registers							*/
							}
								
							x_rel (subtree);							/* done											*/
							em_atr (0, do_loop);						/* jump there									*/
							
							lreg();										/* get what regs were on exit					*/
							regclr (regl & (~ pbk) & (~ reg_e));		/* zap anything loaded and not pbk				*/
							popv();										/* and update the upper level REGU, REGL		*/
							em_ald (do_out);							/* locate exit point here						*/
							accpurg();									/* indicate accumulators empty on exit			*/
							zflags = 0;
							if (temp_a != -1) ptemp (temp_a, do_vtype);	/* free up this temp if allocated				*/
							if (temp_b != -1) ptemp (temp_b, do_vtype);	/* free up this temp if allocated				*/
						}												/* of DO loops									*/
					}													/* of DO loops, DO WHILE						*/
				}								/* of DO loops, DO CASE, DO WHILE				*/
				break;
			}									/* of do statememt								*/
				
			/* Statement scanner - IF statement:			*/
			
			case 5:
			{
				
				pushv();						/* save zero, REGU, REGL						*/
				scanc();						/* for lnums									*/
				subtree = expr();				/* pick up EXPR from interfile					*/
				xcomset();						/* set up for XCOMPUTE call						*/
				xcompute();						/* compute jump instructions					*/
				xcomchk();						/* handle case of no jump; set REGU = REGL = 0 if so	*/
				xcompv();						/* push REGU, REGL as of first jump instruction	*/
				
				e_rel (subtree);				/* done with tree								*/
				donewith (truel);				/* done with this - locate it if we jumped here	*/
				push (regl);					/* save regs loaded during exp after first jump	*/
				pushr();						/* sav regs for else; REGL regs are cleared below	*/
				push (falsel);					/* save exit location for later EM.ALD			*/
				scanc();						/* check for lnums								*/
				
				stmt();							/* scan 'THEN' clause							*/
				
				sreg();							/* save what registers were at end of IF		*/
				falsel = pop();					/* restore false location						*/
				popr();							/* sav regs at start of IF in case there is an ELSE clause	*/
				regclr (pop());					/* clr regs loaded during exp aftr first jmp	*/
				pushv();						/* save and zero REGL, REGU for ELSE clause		*/
				
				token = peek();					/* see if ELSE									*/
				
				if (token == t_else) {			/* check if there is an 'ELSE' clause			*/
					static	fixed	jelse;		/* for exit										*/
					gc();						/* skip over T.ELSE token						*/
					jelse = galt();				/* get key										*/
					em_atr (0, jelse);			/* and jump from out of true to after ELSE		*/
					donewith (falsel);			/* and locate FALSEL here if any body jumped to it	*/
					push (jelse);				/* and push this for later DONEWITH				*/
					stmt();						/* scan ELSE clause								*/
					falsel = pop();				/* and restore this - is actually jump from out of ELSE	*/
				}
				else lreg();					/* if no ELSE, get regs at end of IF			*/
					
				regu = (regu | pop());			/* regs used by true or false statement			*/
				regl = (regl | pop());			/* regs loaded by true or false part			*/
				donewith (falsel);				/* and locate FALSEL here if we did jump to it	*/
				
				popv();							/* and update the upper level of REGU, REGL		*/
				popv();							/* and now include those used during initial expr XCOMPUTE	*/
				break;
			}
				
			/* $$Statement scanner - GOTO statement:		*/
			
			case 6:
			{
				em_tra (0, gc());				/* jump to key passed from pass1				*/
				scanc();						/* and check for lnums here						*/
				break;
			}
				
			/* Statement scanner - interrupts:				*/
			
			case 7:
			{									/* ion enable									*/
				emitc (-0x0008, b_rd + 0x000C);	/* load R14 with bits to turn on interrupts when written to D1	*/
				emita (b_rs + 0x000C, 1);		/* and send to device 1							*/
				zflags = 0;						/* Zflags garbled here							*/
				break;
			}
				
			case 8:
			{									/* ioff	disable									*/
				emitc (-0x0010, 1);				/* turn off interrupts with write to device 1	*/
				emitc (-0x0010, b_rd + 0x000C);	/* and put same in register for sub call		*/
				zflags = 0;						/* Zflags trashed								*/
				break;
			}
				
			/* Statement scanner - STOP:					*/
			
			case 9:
			{									/* Stop stmt									*/
				if (gc() == 0) emita (0, 0);	/* just stop									*/
				else {							/* stop expr									*/
					scanc();					/* check for line numbers here					*/
					subtree = expr();			/* scan expr									*/
					reg_pref = (b_ac0 | b_ac1 | b_ac2 | b_ac3);	/* any one										*/
					mvt = 0;					/* fixed										*/
					compute();					/* compute expr									*/
					fix (subtree);				/* fix it up									*/
					sendit (subtree, 0, 0);		/* send the subtree to device 0 for halt		*/
					x_rel (subtree);			/* done											*/
				}								/* of stop										*/
				break;
			}									/* of stop stmt									*/
				
			/* $$Statement scanner - WRITE and LINPUT:		*/
			
			case 10:
			{									/* write statement								*/
				scanc();						/* ignore lnums here							*/
				wdes = expr();					/* scan complete expression for address			*/
				scanc();						/* check line number							*/
				val = expr();					/* scan value									*/
				mvt = 0; reg_pref = b_ac1; subtree = val; compute();	/* compute VAL									*/
				mvt = 0; reg_pref = b_ac0; subtree = wdes; compute();	/* compute WDES									*/
				fix (val); fix (wdes);
				if (x_node [wdes] == x_const) {	/* constant - zap accum							*/
					sinfo = x_info [wdes];		/* get it										*/
					sendit (val, sinfo, 0);		/* send to dest									*/
					
					if (((sinfo >= b_ad) && (sinfo < b_td))/* if arithmetic								*/
					|| ((sinfo >= b_bsor) && (sinfo <= b_rd + 0x0003))/* or special arithmetic or direct to accumulator	*/
					|| ((sinfo >= b_md + b_ibt) && (sinfo <= b_md + b_ibt + 0x0003))) {	/* or memory register then increment on an accumulator	*/
						freeup (regbit [sinfo & 0x0003]);				/* free up the specified accumulator (we no longer know what's in it)	*/
						if (sinfo < b_rd) zflags = 0;					/* if arithmetic, we no longer know about the ZFLAGS	*/
					}													/* of accumulator								*/
					else if (((sinfo >= b_rd + min_ptr_reg) && (sinfo <= b_rd + max_ptr_reg))/* direct to variable pointer?					*/
					|| ((sinfo >= b_md + b_ibt + min_ptr_reg) && (sinfo <= b_md + b_ibt + max_ptr_reg)))/* or memory register then increment on a VP	*/
						regclr (regbit [sinfo & 0x000F]);				/* zap that variable pointer					*/
				}
				else {							/* write to variable - compute it				*/
					in_reg (wdes, ~ b_ac0); in_reg (val, ~ b_ac1);	/* get args in register							*/
					reg_allc (~ b_ac2); reg_allc (~ b_ac3);	/* should be free anyways						*/
					em_rtp (l_sbw);				/* and special write							*/
					reg_free = (reg_free | b_ac0 | b_ac1);	/* and done										*/
					accpurg(); zflags = 0;		/* zap the accumulators (they are used by L.SBW)	*/
				}
				x_rel (wdes); x_rel (val);		/* done											*/
				break;
			}									/* write										*/
				
			case 11:
			{									/* Linput statement								*/
				scanc();						/* clean up										*/
				stype = gc(); sclass = gc(); sinfo = gc();	/* get type, class, and location of array		*/
				if (stype == t_arr) {			/* array										*/
					if (sinfo == 0)				/* Core?										*/
						emitc (0, b_rd);								/* Linput core;									*/
					else sendvp (sclass, sinfo, b_rd + 0, 0);			/* else array ptr in reg 0						*/
				}
				else if (stype == t_parr) {		/* ptr to array									*/
					static	fixed	reg1;
					reg1 = getvp (sclass, sinfo, 0);	/* get pointer to array pointer					*/
					emita (b_ms + reg1, b_rd + 0);	/* and get that in AC0							*/
				}
				else {							/* must by 'LOCATION'							*/
					stmt_compute_to_reg0();
				}
				em_rtp (l_sin);					/* and get string input							*/
				accpurg();						/* and indicate registers free now				*/
				break;
			}									/* of linput									*/
				
			/* $$Statement scanner - INPUT, PRINT, SEND:	*/
			
			case 12:
			{									/* input										*/
				scanc();						/* clean up										*/
				regzap();						/* and we enter with any registers				*/
				accpurg();						/* garbage regs on restart						*/
				em_rtp (l_ipr);					/* prime the input buffer						*/
				
				zflags = 0;
				while (gc() != 0) {				/* and scan down list of arguments				*/
					stmt(); scanc();			/* scan off T.ASSIGN and assign to variable		*/
				}
					
				em_rtp (l_idn);					/* done with input								*/
				accpurg();						/* indicate registers free						*/
				break;
			}									/* of begin										*/
				
			case 13:
				stmt_pstmt();					/* for PRINT - call subroutine					*/
				
				break;
			case 14:
				stmt_pstmt();					/* for SEND - call subroutine					*/
				
				break;
			case 15:
			{									/* When statement								*/
				prockey = gc();					/* get key def									*/
				pushv(); pushr(); regzap(); regl = 0;	/* protect variables, clean registers, etc.		*/
				pushtemp();						/* push temp ptrs onto stack; zero them			*/
				accpurg();						/* empty accumulators							*/
				zflags = 0;
				em_whn (prockey);				/* emit WHEN statement definition				*/
				push (prockey);
				stmt();							/* and scan the WHEN statement					*/
				prockey = pop();
				freetemp();
				poptemp();						/* and poptemps off stack						*/
				em_wen (prockey, regl);			/* emit end of WHEN statement					*/
				accpurg();						/* indicate empty registers now					*/
				zflags = 0;
				
				popr();							/* restore registers from jump around procedure definition	*/
				regu = pop(); regl = pop();		/* and restore used, loaded indicater flags		*/
				break;
			}									/* of when										*/
				
			case 16:
			{									/* Invoke statement								*/
				stmt_compute_to_reg0();			/* get exception handler into register zero		*/
				em_rtp (l_brk);					/* and call the break routine					*/
				accpurg();						/* zap all accumulators (like a CALL)			*/
				break;
			}									/* of invoke									*/
				
			case 17:
			{									/* Module statement								*/
				em_mod (gc());					/* emit the module statement					*/
				stmt_stmt_list();				/* scan for list followed by 'END'				*/
				break;
			}									/* of module									*/
				
			case 18:
			{									/* Library statement							*/
				em_lib (gc());					/* emit the LIBRARY statement					*/
				break;
			}
				
			case 19:
			{									/* Insert statement								*/
				em_ins (gc());					/* emit the INSERT statement					*/
				
				run_host_environment_250();		/* give cpu to host... 							*/
				
				break;
			}
				
			case 20:
			{									/* Declare statement							*/
				gc();							/* get type (only DATA allowed currently)		*/
				em_dat (gc());					/* should be data defn							*/
				break;
			}									/* of declare									*/
				
		}										/* of do case for stmt types					*/
	}											/* of statement found							*/
		
	/* Statement scanner - clean up:				*/
	
	else {										/* file error!!									*/
		print("\n");
		print("%s%6d%s%6d%s\n", "### Compiler system error in pass 2 (", line_no, ", ", token, ")");
		exit(-1);
	}
	scanc();									/* skip final junk								*/
	if (reg_free != (b_ac0 | b_ac1 | b_ac2 | b_ac3))
		er_emes1 ((char *) "end STMT");
		
	alias_ptr = 0;								/* after statement is finished, there are no more aliases	*/
	
}

static	fixed	pass2()

{
	fixed i;
	
	init();										/* initialize									*/
	
	if (((flags & module_flag) == 0) && ((flags & link_flag) != 0)) {	/* is this a program that needs to be linked?	*/
		end_of_main = gkey();					/* get a key for the start of the libraries		*/
		main_key = gkey();						/* and one for the start of the main program (save for pass 3)	*/
		em_tra (b_tra, end_of_main);			/* emit a transfer around the main code			*/
		em_lde (main_key);						/* define the start of the main program (pass3 must emit a transfer to this)	*/
		em_ldf (-1);							/* emit a library definition record for MAIN (only place we call this in pass 2)	*/
	}
		
	scanc();									/* get started									*/
	token = peek();								/* check next									*/
	
	while (token != t_eof) {					/* compile the entire file						*/
		stmt();									/* compile the next statement					*/
		token = peek();							/* and check ahead								*/
	}
		
	freetemp();									/* free up any remaining temporaries			*/
	accpurg();									/* free up all storage for end check			*/
	
	if (_IGE_(ram, extern_base)) {				/* was too much ram allocated?					*/
		print("\n");
		print("Program too large (too many variables declared).\n");
		exit(-1);
	}
		
	if ((stackpt | blk_in_use) != 0) {			/* system error									*/
		print("\n");
		print("%s%6d%s%6d%s\n", "### Compiler system error (pass 2 stackpt", stackpt, " in use", blk_in_use, ")");
		exit(-1);
	}
		
	if ((flags & module_flag) == 0) {			/* is this a program (rather than a module)?	*/
		emitc (0, b_rd + 0);					/* yes, emit "call exit (0);" at end of code	*/
		em_rtp (l_ter);							/* actual call									*/
		if ((flags & link_flag) != 0)			/* do we need to link in any libraries?			*/
			em_lde (end_of_main);				/* yes, define the end of the main program		*/
	}
		
	em_eof();									/* and output an EOF							*/

	if2lng = (fixed) (((interfile_out_pointer - INTER_FILE_2_START) + 255) / 256);

	for (i=0; i<=maxcomm; i++)					/* write comm area to start of interfile		*/
		inter_file[INTER_FILE_2_START + i] = r[i];
		
	return (trmst);								/* return the termination status				*/
}
	
/* Pass two initialization and termination: */

long	pass2_main()
{
	fixed	term_status;						/* termination status							*/

	store1 [freebl] = 0;						/* zero indicates end of list					*/
	free_end = freebl;
    for (freebl = freebl + 1; freebl <= _blocks; freebl++) {
		store1 [freebl] = freebl - 1;
	}
	freebl = _blocks;
	
	for (fstkptr = 0; fstkptr < fstklen; fstkptr++) {	/* initialize floating point stack				*/
		fstk [fstkptr] = (fixed) 0x8000;
	}
		
	term_status = pass2();						/* invoke the second pass						*/
	
	if (term_status)	
		exit(-1);								/* no, abort									*/
	
	if (show_progress)
		printf("XPL Tool: Pass 2 completed:  statements: %8d   interfile: %8d\n", _stmts, (int) (interfile_out_pointer - INTER_FILE_2_START));
	
	return (0);
}
