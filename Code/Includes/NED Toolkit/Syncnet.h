/*	NED Toolkit - SYNCnet Protocol Interface Class		Copyright © 1990-1992 by New England Digital Corp.  All rights reserved.		This file defines the Syncnet protocol object for managing the protocol	for communication with New England Digital Audio Engines.	It also defines the SyncNode class for sending messages to the connected Engines		Modification History:		07/29/90	KJC	Created this file*/#ifndef NED__SYNCNET#define NED__SYNCNET#ifndef NED__CPLUS#include "cplus.h"#endif#ifndef NED__PROTOCOL#include "Protocol.h"#endif#ifndef NED__REQUEST#include "Request.h"#endif#ifndef NED_LISTEN#include "Listen.h"#endif#ifndef NED__MESSAGE#include "message.h"						// for parameter constants and SEQ_EVENT#endif#ifndef NED__MIXERMESSAGE#include "mixermessage.h"					// for mixer structures#endif#ifndef NED__SET#include "nedset.h"#endif// the following are references to systemwide objects, using MacApp conventionsclass Syncnet;								// forward declarationclass SyncNode;extern Syncnet	*gSyncnet;					// the one and only Syncnet server objectextern SyncNode	*gSyncNode;					// the default Audio Engineextern SyncNode	*gAble;						// the Synclavier/Ableextern SyncNode	*gBaker;					// the DSP option/Bakerextern "C" void	get_unique_name(char *);			// DRVR keeps these uniqueextern "C" int32	snet_putpool(int32 offset, int32 data[], int32 size);extern "C" int32	snet_getpool(int32 offset, int32 data[], int32 size);class Syncnet : public Protocol {public:	enum ErrorCode							// SyncNet error codes	{	NO_MEMORY = PKT_NO_MEMORY,			// ran out of packet buffers		NO_ERROR = PKT_SENT,				// everything is okay		TOO_LONG = PKT_TOO_LONG,			// packet not sent; it's too long		BAD_TYPE = PKT_BAD_TYPE,			// packet not sent; its type is invalid		NO_HARDWARE = PKT_NO_HARDWARE,		// packet not sent; there is no hardware		NOT_LOADED = PKT_NOT_LOADED,		// packet not sent; hardware was not loaded		NOT_CONNECTED = PKT_NOT_CONNECTED,	// Syncnet is not connected		DISABLED = 100						// Syncnet is disabled	};	Syncnet ();	virtual	~Syncnet ();		// Protcol overrides	virtual void enable ();							// enable protocol	virtual void disable ();						// disable protocol	virtual bool connected ();						// TRUE if connection established		virtual bool get_event (EventRecord *event);	// get events specific to this protocol	virtual bool handle_event (EventRecord *event);	// and handle them	virtual void run ();							// run background activity without generating events	// user messages	virtual bool Alert (const unsigned char *errortype, const unsigned char *suggest, bool OK, bool cancel);	// produce alert	virtual bool Timeout (long tstart);				// check for timeout & complain about bad service		// utility	void	get_unique_name(char name[12])			{ ::get_unique_name(name); }		int32	set_shared_data(int32 offset, int32 data[], int32 size)		{ return ::snet_putpool(offset,data,size); }	int32	get_shared_data(int32 offset, int32 data[], int32 size)		{ return ::snet_getpool(offset,data,size); }													private:	Listener		*connect_listen;				// listen for synclavier connections	static void		connect_handler (Syncnet* s);	// connection event handler};typedef Syncnet::ErrorCode Syncnet_Error;			// backwards compatibility// This class represents a particular Audio Engine// it consists largely of the message handlersstatic	void syncnode_new_msg       (int category, int msg_id);				/* start new message with standard buffering */static	void syncnode_new_msg_block (int category, int msg_id, int length);	/* start new message with large buffering */static	int	 syncnode_post_msg      (PACKET *sp);							/* send/enqueue message */class SyncNode {public:	enum { AbleID = 0, BakerID = 1, CharlieID, MacID = 16};	// node IDs		SyncNode (unsigned nodeID);						// create a service point	virtual ~SyncNode ();		unsigned		node ()		{ return nodeID; }	// get Node ID	Syncnet_Error	error ();						// get and clear last error	// playback messages	void play (void);						// play sequence	void stop (void);						// stop sequence	void rewind (void);						// rewind sequence	void fast_forward (void);				// move sequence forward	void locate (Locate_Mode mode, Locate_Type what, int32 where);	// locate to point in sequence	void locate (Locate_Mode mode, Locate_Type what, int32 where, int16 track);	// locate to note in sequence	void req_motion_status (Request *req);	// ask for sequencer's motion		void play_cue (void);					// play a cue	void play_edit (void);					// play the edit region of a cue	void play_region (int32 start, int32 stop, Playback_Source source);	// play a region of a sequence or cue	void play_from (int32 time, Playback_Source source);	void play_to (int32 time, Playback_Source source);	void pause_continue_cue (void);	void stop_dtd (void);		void start_seq_scrubbing (int32 start, int32 stop, SET *track_bits);	void scrub_to_new_seq_time (int32 sample);	void stop_seq_scrubbing (void);	void scrub_current_cue (int16 motion, int8 resolution);	void scrub_current_cue_to_time (int32 time);		void play_event (int16 seq_track, int32 time, int8 count);		void req_audition_mode (Request *req);	void set_audition_mode (bool mode);		void audition_ds (Request *req, int32 dir_id, int32 ds_id, Audio_Source audio_source);		// creation/recording messages	void start_record (void);				// start sequence recording	void start_punch (void);				// start sequence punch over	void stop_record (void);				// stop sequence recording		void req_auto_punch_info (Request *req);	void set_auto_punch_mode (bool mode);	void set_rehearse_mode (bool mode);	void set_auto_punch_time (int32 time, int8 what);		void req_recording_time (Request *req, SET *track_bits);	void req_dtd_record_state (Request *req);	void set_dtd_record_ready (bool mode);	void arm_manual_allocate (int32 length);	void arm_seq_trig_allocate (int32 seq_time, int32 length, int8 mode);	void arm_punch_in (int32 seq_time, int32 length, int8 mode);	void set_ext_rec_triggers (int32 preroll, int32 rec_in, int32 rec_out);	// set external record triggers	void erase_current_cue (void);	void block_cue (void);	// sequence editing messages	void save_sequence (void);				// save sequence	void restore_sequence (void);			// restore sequence	void erase_sequence (void);				// erase sequence	void req_seq_data (Request *req, Sequence_Area area, int32 start, int32 count);	void init_sequence_data(Sequence_Area area);	void add_to_sequence_data(Sequence_Area area, int32 record, int32 length, void *data);	void activate_data_area(Sequence_Area area, int16 data);	void req_seq_snapshot (Request *req, Event_Snapshot_Bits info_bits, int32 start, int32 stop, SET *track_bits);	void req_seq_event (Request *req, int16 track, int32 time, int16 count);	void req_default_event (Request *req, Event_Type type);		void place_seq_event (SEQ_EVENT *event);	void change_event_item (int16 track, int32 time, int16 count, int32 data, Event_Field item);	void req_event_string (Request *req, int16 track, int32 time, int16 count, Event_String_Type which);	void set_event_string (int16 track, int32 time, int16 count, Event_String_Type which, char *str);	void delete_event (int16 track, int32 time, int16 count);	void recall_event_for_edit (int16 track, int32 time, int16 count);	// make this event the current cue	void req_changed_tracks (Request *req);								// ## changes since last *Mac* request ##		void delete_time_on_track (int16 track, int32 time, int32 length);	void insert_time_on_track (int16 track, int32 time, int32 length);		void place_cue (void);	// sound editing messages	void req_cue_data (Request *req, int8 reel);	void set_cue_time (int32 time, Cue_Time_Select what);	void set_cue_tracks (SET *track_bits, int8 state);	void set_place_cue_track (int16 track);	void set_place_cue_mode (int8 mode);	void req_cue_string (Request *req, int8 reel, int16 what);	void set_cue_string (int8 reel, int16 what, char *string);	void req_cue_info_by_id (Request *req, int32 id);	void req_cue_string_by_id (Request *req, int32 id, int16 what);		void copy_cue_mem (int8 src, int8 dst, int8 method);	void cut_from_cue (int8 dst);	void paste_into_cue (int8 src, int8 loop);	void chain_cue (int8 src);	void fill_cue (int8 src, int8 loop);	void slide_cue (int32 slide_amount, int8 method);	void slide_cue (int32 slide_amount, int8 method, int8 fill_reel);	void select_reel_to_edit (int8 reel);	// archival messages	void store_cue (void);							// store current cue	// retrieval messages	void req_dir_key_by_name (Request *req, char *name, int8 match, int8 sort, int8 search, DS_Type_Filter filter, int8 recall);	void req_dir_key_by_index (Request *req, int32 index, int8 sort, int8 search, DS_Type_Filter filter, int8 recall);	void req_dir_key_by_id (Request *req, int32 id, int8 sort, int8 search, DS_Type_Filter filter, int8 recall);	void req_directory_info (Request *req, int32 id, char *name = NULL, int16 match = 0, DS_Type_Filter filter = INC_ALL);	inline void req_directory_info (Request *req, int32 id, DS_Type_Filter filter)	 { req_directory_info (req, id, (char *) NULL, 0, filter); }	void req_directory_entries (Request *req, int32 id, int32 start_entry, int32 entries, int16 max_len, char *name = NULL, int16 match = 0, DS_Type_Filter filter = INC_ALL);	inline void req_directory_entries (Request *req, int32 id, int32 start_entry, int32 entries, int16 max_len, DS_Type_Filter filter)		{ req_directory_entries (req, id, start_entry, entries, max_len, (char *) NULL, 0, filter); }		void open_ds (Request *req, int32 dir_id, int32 ds_id, DS_Access accesses);	void close_ds (int16 id);	void req_ds_read (Request *req, int16 id, int32 offset, int32 length);	void req_ds_write (Request *req, int16 id, int32 offset, int32 length, int8 data[]);	void copy_ds (Request *req, int32 src_dir_id, int32 src_ds_id, int32 dest_dir_id, char *dest_name);	// copy data structure	inline void copy_ds (Request *req, int32 src_dir_id, int32 src_ds_id, int32 dest_dir_id)	// copy data structure (w/same name)		{ copy_ds (req, src_dir_id, src_ds_id, dest_dir_id, (char *) NULL); }	void activate_ds (Request *req, int32 dir_id, int32 ds_id);	// activate or recall a data structure			// time information messages	inline int32 current_seq_time (void)	{ return (current_time ().sequencer); }	inline int32 current_disk_time (void)	{ return (current_time ().disk); }		void req_time_parameters (Request *req);	void set_time_parameter (int32 data, int8 what);	void req_trim_time (Request *req, int8 format);	// unimplemented	void set_trim_time (int32 data, int8 format);	// unimplemented	void req_sync_mode (Request *req);	void set_sync_mode (int8 mode);	void set_sync_mode (int8 mode, int8 midi_in);	void set_midi_sync_out (int8 channel);	void set_midinet_sync_out (int8 path);	void take_current_time (int8 what);	void req_current_mark (Request *req);	void set_current_mark (int32 time);	void req_cur_smpte_time (Request *req, int16 options);	void req_valid_saved_marks (Request *req);	void req_saved_mark (Request *req, int16 mark);	void set_saved_mark (int16 mark, int32 time, char *name, char *caption);		// track setup messages	void req_track_states (Request *req, Track_Attribute attr);	void set_track_state (int16 track, int8 track_type, Track_Attribute attr, int8 state);	void set_mult_track_states (SET *seq_track_bits, SET *dtd_track_bits, Track_Attribute attr, int8 state);	void clear_all_tracks (Track_Attribute attr);	void req_track_state (Request *req, int16 track, int8 track_type);	void req_group (Request *req, int8 group);	void set_group (SET *seq_track_bits, SET *dtd_track_bits, int8 group);	void req_valid_groups (Request *req);	void set_group_state (int8 group, Track_Attribute attr, int8 state);	void req_routing_info (Request *req, SET *track_bits, int16 rout_type);	void req_midi_in_out (Request *req, int16 seq_track, int8 direction);	void set_midi_in_out (int16 seq_track, int8 direction, int8 midi_num, int8 midi_chan);	void req_multichan_out (Request *req, int16 seq_track);	void set_multichan_out (int16 seq_track, int8 left_out, int8 right_out);	void req_dtd_inputs (Request *req, int16 dtd_track);	void set_dtd_inputs (int16 dtd_track, int8 input, int8 input_num);	void req_dtd_outputs (Request *req, int16 dtd_track);	void set_dtd_outputs (int16 dtd_track, int8 left_out, int8 right_out);	void	req_valid_tracks (Request *req);		// utility messages	void req_configuration (Request *req);	void req_echo (Request *req);		// event messages	void set_event_enables (SET *enables);		// MIDI messages	// undefined as of 8/15/89		// clavier emulation messages	void emulate_press_and_hold (int8 bank, int8 button);	void emulate_press_and_rel (int8 bank, int8 button);	void emulate_release (int8 bank, int8 button);	void emulate_release_all (void);	void emulate_clavier_knob_jog (int16 jog_amount);	void emulate_clavier_knob (int16 position);	void req_clavier_status_info (Request *req);		// mixer messages	void set_meter_control (int32 base, int32 count, int32 interval);		// set metering channels & rates	void req_mixer_configuration (Request *req);							// request type census	//void set_mixer_dials (int32 count, int intype, int innum, int outtype, int outnum, int dial, int setting, ...);	// collection of dials	void set_mixer_dials (int32 count,  ...);								// collection of dials	void req_mixer_dials (Request *req, int32 count, Mixer_Dial_Set coeffs[]);			// interrogate dials	void set_mixer_dials (int32 count, Mixer_Dial_Set coeffs[]);			// array of dials	void set_mixer_dial (Mixer_IO_Type intype, int8 innum, Mixer_IO_Type outtype, int8 outnum, Mixer_Dial_Type dial, int32 setting)	// update dial			{ set_mixer_dials (1, intype, innum, outtype, outnum, dial, (int)setting); }		//void set_mixer_switches (int32 count, int intype, int innum, int outtype, int outnum, int swtch, int setting, ...);		// collection of switches	void set_mixer_switches (int32 count, ...);								// collection of switches	void req_mixer_switches (Request *req, int32 count, Mixer_Switch_Set swtchs[]);		// interrogate switches	void set_mixer_switches (int32 count, Mixer_Switch_Set swtchs[]);		// array of switches	void set_mixer_switch (Mixer_IO_Type intype, int8 innum, Mixer_IO_Type outtype, int8 outnum, Mixer_Switch_Type swtch, int16 setting)	// update switch			{ set_mixer_switches (1, intype, innum, outtype, outnum, swtch, setting); }		// support routines for experimental extensions to “official” messages defined above	void set_raw (int category, int msg_id, void *data, int data_size);					// set parameter value from raw data	void req_raw (Request *req, int category, int msg_id, void *data, int data_size);	// request parameter value from raw data	void req_raw (Request *req, int req_size, int category, int msg_id, void *data, int data_size);	// request block transfer from raw dataprotected:			// stuff needed to send	// buffer management	virtual PACKET	*nextpacket(int length = PACKET_MAX);			// allocate buffer	virtual	void	donepacket(PACKET*);							// release buffer	// state management	Syncnet_Error		error(int status);	// set packet status	Syncnet_Error		send(PACKET *sendpacket);	Syncnet_Error		request(PACKET *sendpacket, Request *req, int length = PACKET_MAX);	unsigned			nodeID;				// the destination node number	Syncnet_Error 		status;				// latest Syncnet error	// attachment to message library	friend void syncnode_new_msg (int category, int msg_id);	friend void syncnode_new_msg_block (int category, int msg_id, int length);	friend int  syncnode_post_msg (PACKET *spkt);};#endif	// NED__SYNCNET