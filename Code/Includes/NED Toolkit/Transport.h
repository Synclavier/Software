/*	NED Toolkit - Abstract Transport Class		Copyright © 1990 by New England Digital Corp.  All rights reserved.		This file defines the abstract class that all motion/transport	related classes are derived from.		Modification History:		08/01/90	KJC	Incorporated comments from TSS and DSY		07/27/90	KJC	Created this file*/#ifndef NED__TRANSPORT#define NED__TRANSPORT#ifndef NED__CPLUS#include "cplus.h"#endif#ifndef NED__TRANSACTION#include "Transaction.h"#endif#ifndef NED__PROTOCOL#include "Protocol.h"#endif#ifndef NED__CONDITION#include "Condition.h"#endif#ifndef NED__TYPEStypedef int32 Millisecond;typedef int32 Sample;#endiftypedef double Rate;						// rate of transport's motion (signed)class /*PascalObj*/ Transport;/* Transport is an abstract class.  For each protocol that wants to be  supported (e.g., SyncNet, Sony BVH), this must be subclassed and all  protocol-related methods (and fields) must be overridden. */class Transport : public Transaction {			// abstract motion control classpublic:	enum Motion {							// motion states		STOPPED =			0x0000,			// not moving at all		PLAYING =			0x0001,			// playing		RECORDING =		0x0002,			// recording		SCRUBBING =		0x0004,			// scrubbing		MOVING_FORWARD =	0x0008,			// moving forward		MOVING_BACKWARD =	0x0010,			// moving backward		LOCATING =		0x0020,			// locating		PAUSED =			0x0040,			// paused		_SIZE_HOLDER =		MAX_UINT16	};		struct Motion_State {		Motion		state;				// motion state		Rate			rate;				// rate of motion		Millisecond	time;				// current time	};		Condition motion_changed;				// motion change Condition		Transport (Protocol *protocol, int requests = 1);	// constructor	~Transport ();							// destructor		virtual Motion_State get_state (void);		// get motion state	virtual Protocol	 *get_protocol (void);	// get protocol object		virtual void	play (void);				// start playing at current time	virtual void	play (Millisecond stop_time);	// play to location from current time	virtual void	play_across (Millisecond preplay, Millisecond postplay);	// play across current time		inline void	play_to (Millisecond preplay)	{ play_across (preplay, 0); }	// play to current time	inline void	play_from (Millisecond postplay)	{ play_across (0, postplay); }	// play from current time	inline void	play_region (Millisecond start, Millisecond stop) { locate (start); play (stop); }	// play region		virtual void	scrub (Millisecond time);	// scrub to location from current time	virtual void	move_forward (void);		// move forward	virtual void	move_forward (double speed);	// move forward at speed	virtual void	move_backward (void);		// move backward	virtual void	move_backward (double speed);	// move backward at speed		virtual void	stop (void);				// stop movement (pull head off tape)	virtual void	pause (void);				// pause movement		virtual void	locate (Millisecond time);	// locate to time	virtual void	locate_from (Millisecond offset);	// locate to relative time		virtual void	lock_to (Transport *machine);	// lock up with another machine (we're the master)	virtual void	unlock (void);				// run free againprotected:	inline void set_state (Motion new_state)	{ state.state = new_state; }	inline void set_rate (Rate new_rate)		{ state.rate = new_rate; }	inline void set_time (Millisecond new_time)	{ state.time = new_time; }	inline void set_protocol (Protocol *new_prot) { protocol = new_prot; }	inline void set_transaction (Transaction *new_trans) { transaction = new_trans; }	inline Transaction *get_transaction (void)	{ return (transaction); }	private:	Motion_State	state;					// motion state	Protocol		*protocol;				// protocol we're using	Transport		*that;					// object we're locked to (normally NULL)	Transaction	*transaction;				// current transaction in process};#endif	/* NED__TRANSPORT */