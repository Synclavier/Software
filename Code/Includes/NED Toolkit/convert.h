/* NED Toolkit - Time Conversion Library   Copyright © 1990 by New England Digital Corporation   In general, only the millisecond-to-string and string-to-millisecond   routines are needed.  Most of the other routines, as well as the   structures they use (such as S_TIME), are internal routines that are   useful only in very specific circumstances (such as scanning input).      Note:	SMPTE offsets are in smpte bits (sbits), NOT milliseconds.  		Footage offsets are in footage bits (fbits), NOT milliseconds.		SPEED is the sequencer speed times 1000, so 1250 is a speed of 1.250.		BPM is beats per measure.		CLICK is the click rate in clicks/second.		Sample RATE is the sample rate (in kHz) times ten, so 500 is 50.0 kHz.*/#ifndef NED__CONVERT#define NED__CONVERT#include "c.h"#include "convertstructs.h"#ifdef __cplusplusextern "C" {#endif/* some useful extended-precision multiply routines *//* This function multiplies a 32-bit integer by a 64-bit block floating point   number to produce a 48-bit block floating point result.  The decimal point   in the 64-bit number is just after the first 16-bits (a.bcd, where each   letter denotes a 16-bit quantity), so that it ranges from 0 to 65535.9999999.   The decimal point in the 48-bit result is just after the first 32-bits (ab.c),   so it ranges from 0 to 4,294,967,295.9999.      Warning:  Overflow is not detected. */   FLOAT fmultiply (uint32 multiplicand, LARGE_FLOAT multiplier);	/* 32-bit x 64-bit multiply *//* This function multiplies a 32-bit integer by a 64-bit block floating point   number to produce a 32-bit rounded integer result.  The decimal point   in the 64-bit number is just after the first 16-bits (a.bcd, where each   letter denotes a 16-bit quantity), so that it ranges from 0 to 65535.9999999.      Warning:  Overflow is not detected. */uint32 multiply (int32 multiplicand, LARGE_FLOAT multiplier);	/* 32-bit x 64-bit multiply *//* This function multiplies a 32-bit integer (X) by a fraction (NUM/DENOM).  The result is rounded.    Warning:  Overflow is not detected. */uint32 ratio_multiply (uint32 x, unsigned int num, unsigned int denom);	/* compute ratio x*(num/denom) *//* samples to milliseconds and back */int32 samples_to_msec(int32 samples, int speed, int rate);int32 msec_to_samples(int32 msec, int speed, int rate);/*						SECONDS	(Seconds.Milliseconds)					*/char *msec_to_sec_str (int32 msec, char *s);					/* convert milliseconds to seconds string */int32 sec_str_to_msec (char *s);							/* convert seconds string to milliseconds */int32 sec_to_msec (M_TIME time);							/* convert seconds to milliseconds */M_TIME msec_to_sec (int32 msec);							/* convert milliseconds to seconds *//*						MINUTES	(Minutes:Seconds.Milliseconds)			*/char *msec_to_min_str (int32 msec, char *s);					/* convert milliseconds to minutes string */int32 min_str_to_msec (char *s);							/* convert minutes string to milliseconds *//*						BEATS	(Beats.Fracs)							*/char *msec_to_beat_str (int32 msec, C_FORMAT format, int click, char *s);	/* convert milliseconds to beats string */int32 beat_str_to_msec (char *s, C_FORMAT format, int click);	/* convert beats string to milliseconds */int32 beats_to_msec (B_TIME b, C_FORMAT format, int click);		/* convert beats to milliseconds */B_TIME msec_to_beats (int32 msec, C_FORMAT format, int click);	/* convert milliseconds to beats *//*							MEASURES	(Measures:Beats.Fracs)				*/char *msec_to_meas_str (int32 msec, C_FORMAT format, int bpm, int click, char *s);	/* convert milliseconds to measures string */int32 meas_str_to_msec (char *s, C_FORMAT format, int bpm, int click);	/* convert measures string to milliseconds *//*							SMPTE	(HH:MM:SS:FF.BB)					*/char *msec_to_smpte_str (int32 msec, C_FORMAT format, int speed, S_MODE smode, int32 offset, char *s);	/* convert milliseconds to SMPTE string */int32 smpte_str_to_msec (char *s, C_FORMAT format, int speed, S_MODE smode, int32 offset);	/* convert SMPTE string to milliseconds */char *sbits_to_smpte_str (int32 sbits, S_MODE smode, char *s);	/* convert sbits to SMPTE string */int32 smpte_str_to_sbits (char *s, S_MODE smode);				/* convert SMPTE string to milliseconds */int32 smpte_to_msec (S_TIME smpte_time, C_FORMAT format, int speed, S_MODE smode, int32 offset);	/* convert SMPTE time to milliseconds */S_TIME msec_to_smpte (int32 msec, C_FORMAT format, int speed, S_MODE smode, int32 offset);	/* convert milliseconds to SMPTE time */int32 smpte_to_sbits (S_TIME s, S_MODE smode);				/* convert SMPTE time to SMPTE bits */S_TIME sbits_to_smpte (int32 sbits, S_MODE smode);			/* convert SMPTE bits to SMPTE time */int32 sbits_to_msec (int32 sbits, int speed, S_MODE smode);		/* convert SMPTE bits to milliseconds */int32 msec_to_sbits (int32 msec, int speed, S_MODE smode);		/* convert milliseconds to SMPTE bits *//*						FEET		(Feet/Frames.Bits)						*/char *msec_to_feet_str (int32 msec, C_FORMAT format, int speed, F_MODE fmode, int32 offset, char *s);	/* convert millseconds to feet string */int32 feet_str_to_msec (char *s, C_FORMAT format, int speed, F_MODE fmode, int32 offset);	/* convert feet string to milliseconds */char *fbits_to_feet_str (int32 fbits, F_MODE fmode, char *s);	/* convert fbits to feet string */int32 feet_str_to_fbits (char *s, F_MODE fmode);				/* convert feet string to fbits */int32 feet_to_msec (F_TIME footage, C_FORMAT format, int speed, F_MODE fmode, int32 offset);	/* converts film footage to synclavier msec */F_TIME msec_to_feet (int32 msec, C_FORMAT format, int speed, F_MODE fmode, int32 offset);  /* converts synclavier msec to film footage */int32 feet_to_fbits (F_TIME f, F_MODE fmode);				/* convert footage to 80ths of film frames */F_TIME fbits_to_feet (int32 fbits, F_MODE fmode);  			/* convert 80ths of frames to footage */int32 fbits_to_msec (int32 fbits, int speed, F_MODE fmode);		/* converts film footage subframe bits to synclavier msec */int32 msec_to_fbits (int32 msec, int speed, F_MODE fmode);		/* converts synclavier msec to film footage subframe bits */#ifdef __cplusplus}#endif#endif				/* NED__CONVERT */