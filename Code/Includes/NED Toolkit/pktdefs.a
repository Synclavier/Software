	title	'Packet Level Driver -- Data Definitions'* NED Toolkit - Packet Level Driver Definitions** Copyright © 1990 by New England Digital Corporation** By:  Dave Pearson on 8/31/88; Packet queue format.  The order is assumed by the queue management; routines.q	record	0tail	ds.l	1			; queue tail (points to head if empty)head	ds.l	1			; first element, or zero if emptypanic	ds.w	1			; length of queue - panic3qlen	equ	*			; total size	endr; Per-channel global data area for the packet driver;; The order of the fields in this record is assumed in init_pkt_driver's; subroutine "ichan".  The data area is initialized there.;; @rqs/@ack in driver assume RxState follows TxSeq and is zero.D	record	0Sem	ds.w	1			; semaphore, initialized to 1Chan	ds.w	1			; channel number (0 for A, 1 for B)DUSCC	ds.l	1			; channel's DUSCC base addressTxDMA	ds.l	1			; Transmit DMA channel baseRxErr	ds.l	1			; error counter -- receiver errorsTxErr	ds.l	1			; error counter -- re-transmissionsUrErr	ds.l	1			; error counter -- underrunsRxLost	ds.l	1			; number of Rx packets tossed on this channel (just initialized by packet)TxRetry	ds.w	1			; timer for consecutive retransmissionsRxHead	ds.l	1			; Receiver buffer queue startRxBuf	ds.l	1			; Receiver's current messageRxTail	ds.l	1			; Receiver buffer queue endTxQ	ds	q			; Transmit queueTxState	ds.w	1			; Transmitter state (word)TxSeq	ds.b	1			; Transmitter sequence# (byte)RxState	ds.b	1			; Receiver state (byte)RxSeq	ds.b	1			; Receiver seq# (byte, w/ 1 in low bit)TxMsg	ds.b	1			; Transmit msg byte (must follow RxSeq)Dlen	equ	*			; total size	endr; Crash data record formatcrash	record	0nodeID	ds.b	1			; node ID of crashed devicevector	ds.b	1			; exception vector numberstack	ds.b	62			; contents of stackregs	ds.l	16			; contents of registerslen	equ	*			; length of crash data	endr; Packet buffer format (except on receiver buffer queue).  On the receiver buffer queue,; rxqlink is a used as a 4-byte link field and len/chan are unused (this is a C union).pkt	record	0link:	ds.l	1			; link fieldrxqlink	equ	*			; offset (in bytes) of Rx interrupt link from start (this is often implied, rarely referenced)len:	ds.w	1			; length of data (in bytes)chan:	ds.w	1			; channel number (0 or 1)hdrlen:	equ	*-len			; length of packet headertype:	ds.w	1			; packet type word (start of data)	ds.b	64+4			; datamax	equ	*-type			; max length of actual packet (for read)bufmax	equ	*-link			; length of entire buffer	endr; Storage allocation panic levelspanic1	equ	100			; panic threshholdpanic2	equ	25			; extreme panic threshhold (minimum number of blocks to avoid crashing)panic3	equ	25			; queue is "long" if longer than this ((panic1 - panic2)/# of queues)max_retries	equ	750		; consecutive tx retries before resetting channel (4ms/retry); pkt_send return codes; if code > 0 packet has not been freedpkt_no_memory	equ	-1		; not enough memory to queue up packetpkt_sent	equ	0		; packet was sentpkt_too_long	equ	1		; packet is too longpkt_bad_type	equ	2		; packet has invalid typepkt_not_connected equ	5		; channel is inactive - no one to send packet to; Low-memory definitionsGlobSize	equ	$200			; size of low memory global areaGlobEnd		equ	GlobBase+GlobSize	; start of user areaAData		equ	GlobBase		; starting addressBData		equ	AData+D.Dlenfreelist	equ	BData+D.Dlen		; free memory list pointerfreepanic	equ	freelist+4		; block count minus panic threshholdpanicErr	equ	freepanic+2		; count of packets tossed from panicRxQ		equ	panicErr+4		; Received packet queue, for spare-timeLMFree		equ	RxQ+q.qlen		; start of free low memorycrashData	equ	GlobEnd-crash.len	; area overwritten by fault handler	if	LMFree >= crashData then	; normally don't want to use crashData area at all		aerror Low memory data exceeds allocated space.	endif