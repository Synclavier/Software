//	NED Toolkit DSP Audio Meter class//	Copyright © 1991-1992 by New England Digital Corp.  All rights reserved.	//	these classes control DSP Audio Metering//		DSPMeterControl controls the sampling for a range of channels//		DSPMeterChannel holds data for a single audio channel//	the meter data are volatile (updated asynchronously)//	it is the user's responsibility to poll the update count#ifndef NED__DSPMETER#define NED__DSPMETER#ifndef NED__PACKETS#include	"packets.h"#endif#ifndef NED__ANSWERSTUCTS#	include "Answerstructs.h"									// Data structures used in responses.#endif#ifndef NED__TOOLRUPT#include	"toolrupt.h"#endiftypedef int16	DSPlevel;						// a meter reading (dB*100) (milliBell?)					class DSPMeterChannel							// each channel{public:											// application interface	enum { kSilence = 13845 };					// range	DSPlevel	swap_peak(DSPlevel new_peak)	// return peak val, then set it								{ DSPlevel old_peak = peak; peak = new_peak; return old_peak; }	DSPlevel	get_latest()	{ return last; }	// return most recently received value	DSPlevel	get_peak()		{ return peak; }	// return peak val rcvd since last call	DSPlevel	get_and_clear_peak()				// return peak val, then reset it to latest								{ return swap_peak(get_latest()); }	void		clear()							// blank the level								{ last = peak = kSilence; }private:	DSPlevel	last, peak;						// latest & peak readings	void		update(DSPlevel upd);	friend class DSPMeterControl;				// only through this class};//	this class controls a set of meter channels//	meters are activated by setting a nonzero update interval (in msec)//	the update counter is incremented when a packet arrivesclass DSPMeterControl							// control channels{public:											// application interface	DSPMeterControl();							// construct meter data set	~DSPMeterControl();							// destroy meter data set	DSPMeterChannel*	get_input_channel(int chan_num)	 	{ return &inputs[chan_num]; }	DSPMeterChannel*	get_output_channel(int chan_num)	 { return &outputs[chan_num]; }	void		enable_updates(int update_period, uint32 input_map, uint32 output_map);	// enable meter updates every update_period msec	void		disable_updates();					// disable meter updates		bool		is_enabled();						// are we active?	int			get_update_period();				// get metering protocol msg interval in msec	void		clear_all_channels();				// set all meter channels to kSilence	int			num_updates;						// increments with each meter message rcvd	enum { max_channels = 32 };						// number of channels of each kind	DSPMeterChannel	inputs[max_channels],outputs[max_channels];		// channel arraysprotected:	virtual void	update(Meter_Data& upd);		// update levels from packetprivate:											// internal data representation 	// protocol driver interface	long		cookie;								// interrupt addressing validity check	rupt		*rhook;								// interrupt interface	static void	click(DSPMeterControl &me,PACKET *pkt);	// rupt handler	static const long	magic;};#endif