/* NED Toolkit - Queue Abstract Data Type Definitions  This library implements the Queue ADT.  A queue is a list from  which items can only be added or removed at one end (opposite ends).  It behaves like a line of people waiting (queued up) for something  (e.g., a free bank teller, airline tickets, food at a cafeteria,  etc.).  Such a list is called a FIFO (first-in, first out) because  the first item added to the list is the first one removed.  The first  item in a queue is said to be at the front of the queue, while the  last item is said to be at the rear of the queue.  A queue is an input-restricted and an output-restricted deque.  The operations defined are:	enqueue (x, Q):	append item x to rear of queue Q	dequeue (Q):		remove (and return) the item at the front of queue Q	frontq (Q):		return the item at the front of queue Q	fullq (Q):		TRUE if no more items can be added to queue Q	emptyq (Q):		TRUE if no items are in queue Q	clearq (Q):		remove all items from queue Q  This queue is implemented in an array as a circular queue  (i.e., the head and tail wrap back to zero when they reach  the end of the array).  By:  Karim J. Chichakly on 7 October 1985  Copyright © 1990 by New England Digital Corporation  Note:  The queue is implemented as macros to allow it to be  used for many sizes and data types.  To override the default  queue size, #define QUEUE_SIZE before including this file.  To  override the default queue element type (int), #define QUEUE_TYPE  before including this file.  These definitions can be used for  several different sizes and types of queues within one program  providing each different queue is used in a different source  file.  For example, file "double.c" could use these definitions  for a floating point queue while file "sample.c" uses these  definitions for an integer queue, but neither file could access  the other's queue.*/#ifndef NED__QUEUE#define NED__QUEUE#ifndef NED__C#include "c.h"#endif#ifndef QUEUE_SIZE#define QUEUE_SIZE	50						/* number of elements in queue */#endif#ifndef QUEUE_TYPE#define QUEUE_TYPE	int#endif/* data structures */typedef QUEUE_TYPE qtype;					/* element type */typedef struct {	int	 head, tail;						/* head & tail ptrs */	qtype element [QUEUE_SIZE];} QUEUE;/* prototypes */#ifdef __cplusplusextern "C" {#endifvoid  enqueue (qtype x, QUEUE *Q);				/* enqueue an element */qtype dequeue (QUEUE *Q);					/* dequeue next element */qtype frontq (QUEUE *Q);						/* get front element of queue */bool  fullq (QUEUE *Q);						/* test if queue can hold more elements */bool  emptyq (QUEUE *Q);						/* test if queue has any elements ar all */void  clearq (QUEUE *Q);						/* remove all elements from queue */#ifdef __cplusplus}#endif/* This function enqueues an item at the rear of a queue.  If the queue is full, it does nothing. */#define enqueue(x, Q)	{					/* enqueue x on Q */	\	if (not fullq (Q)) {										\		(Q)->head = ((Q)->head + 1)%QUEUE_SIZE;						\		(Q)->element [(Q)->head] = x;								\	}														\}/* This function dequeues an item from the front of a queue  and returns that item.  If the queue is empty, it returns  garbage. */#define dequeue(Q)							/* dequeue from Q */	\	((not emptyq (Q) ? (Q)->tail = ((Q)->tail + 1)%QUEUE_SIZE : 0),		\	(Q)->element [(Q)->tail])				/* return element *//* This function returns the item at the front of the queue  (but does not remove it).  If the queue is empty, it returns  garbage. */#define frontq(Q)	((Q)->element [((Q)->tail + 1)%QUEUE_SIZE])	/* return front of Q */#define fullq(Q)	((Q)->tail == ((Q)->head + 1)%QUEUE_SIZE)	/* TRUE if Q is full */#define emptyq(Q)	((Q)->head == (Q)->tail)		/* TRUE if Q is empty */#define clearq(Q)	((Q)->head = (Q)->tail = 0)	/* force Q empty */#endif	/* NED__QUEUE */