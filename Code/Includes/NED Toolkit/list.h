/* This library implements the linked list ADT using cursors (rather than  pointers).  The use of cursors allows applications that cannot allocate  memory (e.g., routines that run at interrupt-time) to maintain lists.  The following operations are available:	insert_list (p, l):		insert element at position P of list L (follow by update_list),						return position of new element or end_list (L)	delete_list (p, l):		delete element at position P of list L	find_list (px, l, comp):	find element pointed to by PX in list L,	find_sorted_list (px, l, comp):	find element pointed to by PX in list L,						return position or place to insert it (next greater element)	update_list (x, p, l):	updates the element at position P of list L to X	retrieve_list (p, l):	return element at position P of list L	retrieve_list_ptr (p, l):return pointer to element at position P of list L	first_list (l):		return first position of list L	end_list (l):			return last position of list L	next_list (p, l):		return next position (from P) in list L	prev_list (p, l):		return previous position (from P) in list L	full_list (l):			TRUE if list L is full	empty_list (l):		TRUE if list L is empty	pos_in_list (p, l):		TRUE is position P is in list L	clear_list (l):		clear list L	create_list (l):		create (and return) a list	destroy_list (l):		destroy list L (must have been previously created)    The functions find_list () and find_sorted_list () are passed a  comparison function that is passed two pointers, one to each of  two elements to compare (call them e1 and e2).  The comparison  function's return value must be (find_list only cares if it's  zero or nonzero):  		< 0:	if e1 < e2		= 0:	if e1 = e2		> 0:	if e1 > e2    Every list MUST be created before it is used!  The function create_list ()  is passed either an uninitialized list or NULL if it is to create the list.  The function destroy_list () can only be called with a list that was  allocated by create_list ().    Note:  Most of the list is implemented as macros to allow it to be  used for many sizes and data types.  To override the default list  size, #define LIST_SIZE before including this file.  To override  the default list element type (int), #define LIST_TYPE before  including this file.  If LIST_TYPE is not defined to be a standard  C data type (e.g., it's an aggregate), that data type must also  be defined before including this file.    These definitions can be used for several different sizes and types  of lists within one program providing each different list is used  in a different source file.  For example, file "double.c" could use  these definitions for a floating point list while file "sample.c"  uses these definitions for an integer list, but neither file could  access the other's list.    Warning:  The following macros cannot be used from within list.c either  because they depend on LIST_SIZE, LIST_TYPE, or sizeof(struct elem) (e.g.,  any subscripted references):		update_list		retrieve_list		retrieve_list_ptr		next_list		prev_list		create_list*/#ifndef NED__LIST#define NED__LIST#include <StdLib.h>							/* for create_list and destroy_list */#ifndef NED__C#include "c.h"#endif#ifndef LIST_SIZE#define LIST_SIZE	50						/* number of elements in list */#endif#ifndef LIST_TYPE#define LIST_TYPE	int#endif/* constants and local macros */#define L_END_OF_FREE_LIST	-1				/* end-of-free-list marker */#define l_head_tail_ptr(l)	((l)->size)		/* internal head/tail pointer */#define l_elem_ptr(p, l)		((struct elem *) (((char *) (l)->e) + (p)*(l)->e_size))	/* (internal) get ptr to element at P in L *//* data structures */typedef LIST_TYPE	list_type;				/* element data type */typedef int		list_pos;					/* position data type */struct elem {								/* list element */	list_pos	next;						/* ptr to next element */	list_pos	prev;						/* ptr to previous element */	list_type	element;						/* current element (MUST be last) */};typedef struct {							/* linked list */	list_pos	size;						/* size of list (also ptr to head/tail) */	int		e_size;						/* size of an element (for precompiled functions) */	list_pos	free;						/* ptr to first free element */	struct elem e [LIST_SIZE + 1];			/* list elements plus one reserved for head (MUST be last) */} LIST;/* globals */static LIST *l_created_list;					/* create_list variable *//* prototypes */#ifdef __cplusplusextern "C" {#endiflist_pos	insert_list (list_pos p, LIST *l);		/* insert element in L at P */void		delete_list (list_pos p, LIST *l);		/* delete element at P from L */list_pos	find_list (list_type *px, LIST *l, int (*compare) (void *e1, void *e2));	/* find x in L */list_pos	find_sorted_list (list_type *px, LIST *l, int (*compare) (void *e1, void *e2));	/* find x in sorted L */void		update_list (list_type x, list_pos p, LIST *l);	/* update list element at P in L */list_type	retrieve_list (list_pos p, LIST *l);	/* retrieve element at P in L */list_type	*retrieve_list_ptr (list_pos p, LIST *l);	/* retrieve pointer to element at P in L */list_pos first_list (LIST *l);				/* return first of L */list_pos end_list (LIST *l);					/* return end of L */list_pos next_list (list_pos p, LIST *l);		/* return next of L */list_pos prev_list (list_pos p, LIST *l);		/* return previous of L */bool full_list (LIST *l);					/* TRUE if L is full */bool empty_list (LIST *l);					/* TRUE if L is empty */bool pos_in_list (list_pos p, LIST *l);			/* TRUE if P is in L */void clear_list (LIST *l);					/* clear L */LIST *create_list (LIST *l);					/* create a list */void destroy_list (LIST *l);					/* destroy a created list */#ifdef __cplusplus}#endif/* macros */#define update_list(x, p, l)	(pos_in_list (p, l) ? (l)->e [p].element = x : x)	/* update list element at P in L */#define retrieve_list(p, l)	(pos_in_list (p, l) ? (l)->e [p].element : (l)->e [l_head_tail_ptr (l)].element)	/* retrieve element at P from L */#define retrieve_list_ptr(p, l) (pos_in_list (p, l) ? &(l)->e [p].element : NULL)	/* retrieve pointer to element at P in L */#define first_list(l)	(l_elem_ptr (l_head_tail_ptr (l), l)->next)	/* return first element of L */#define end_list(l)		l_head_tail_ptr (l)		/* return end of L (beyond last element) */#define next_list(p, l)	((p) != end_list (l) ? (pos_in_list (p, l) ? (l)->e [p].next : end_list (l)): p)	/* return next of L */#define prev_list(p, l)	((p) != first_list (l) ? (pos_in_list (p, l) ? (l)->e [p].prev : first_list (l)) : p)	/* return previous of L */#define full_list(l)	((l)->free == L_END_OF_FREE_LIST)	/* TRUE if L is full */#define empty_list(l)	(first_list (l) == end_list (l))	/* TRUE if L is empty */#define pos_in_list(p, l) (((p) >= 0) and ((p) < (l)->size) and (l_elem_ptr (p, l)->prev != L_END_OF_FREE_LIST))	/* TRUE if P is in L */#define create_list(l)	(					/* create a list */			\	l_created_list = ((l) == NULL ? malloc (sizeof (LIST)) : l),	/* allocate list if necessary */\	l_created_list->size = LIST_SIZE,			/* remember its size */		\	l_created_list->e_size = sizeof (struct elem),	/* and size of element */\	clear_list (l_created_list),				/* clear it */				\	l_created_list							/* return a pointer to it */	\)#define destroy_list(l)	free (l)				/* destroy a created list */#endif NED__LIST