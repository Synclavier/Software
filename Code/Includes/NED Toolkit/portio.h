/*	NED Toolkit - Serial Port I/O Management		Copyright © 1988-1991 by New England Digital Corp.  All rights reserved.		This file implements the high-level serial port management library.  The	library puts a layer between the programmer and the operating system,	allowing the programmer to concentrate on what he is trying to do, rather	than on what the operating system demands.  The following operations are	available:		port = port_open (port, which, in_baud, out_baud):		Opens the specified port at the specified baud rate (e.g., pass 9600		for 9600 baud).  The passed PORT record pointer can be NULL, in which		case the port record is allocated.  A pointer to the port record is		returned if the port is successfully opened (and allocated if necessary).		Otherwise, NULL is returned and port_status() should be called to		determine the problem.				The port's configuration is set to one start bit, eight data bits,		one stop bit, and no parity.  If this isn't right, use port_reset()		to correct it after opening the port (the number of start bits cannot		be changed).  Input handshaking is enabled after this call, while		output handshaking is disabled (use port_set_handshake() if you		need to change this).		port = (port_open) (NULL, which, in, out, buf_size):		Same as port_open() above, but allows different input buffer sizes		for each port (i.e., other than the default PORT_BUFSIZE).  Note		that the port record MUST be allocated by port_open in this instance.		port_close (port):		Close the previously opened PORT.  If port_open() allocated the port		record, it is now freed (so don't reference it after calling this).		status = port_status (port):		Get status of last operation on the specified port.  If the passed		PORT record pointer is NULL, the status is for the last open operation.		Thus, it is always valid to pass in the result of port_open().		port_reset (configuration, port):		Reset the port's configuration (and reinitialize the serial driver).		The configuration includes the number of data and stop bits, type of		parity, and baud rate.  See the SerReset() documentation in Inside		Mac II-250 for the format of CONFIGURATION.  Non-standard baud rates		(e.g., 31250 for MIDI) will have to be reset after this call with		port_set_baudrate().		port_abort (abort_in, abort_out, port):		Abort pending I/O operations on the input or output side of the driver.		All data in buffers is discarded.		port_set_handshake (in_handshake, out_handshake, port):		Enables or disables XON/XOFF handshaking on the specified serial port.		IN_HANDSHAKE should be TRUE if you want flow control on incoming data		(i.e., you want XOFFs to be sent when the input buffer approaches being		full).  OUT_HANDSHAKE should be TRUE if you want flow control on outgoing		data (i.e., you want received XOFFs to suspend the sending of characters		out the port).		port_set_baudrate (in_baud, out_baud, port):		Set the baud of the specified port to a non-standard rate (e.g., 31250		for MIDI) after doing a port_reset() (note that port_open() already		supports non-standard rates).		which_port = port_get_port (port):		Get constant corresponding to which port port record PORT refers to.		in_baud = port_get_in_baud (port):		Get the input baud rate of the specified port.		out_baud = port_get_out_baud (port):		Get the output baud rate of the specified port.		port_putc (c, port):		Send a character out the specified serial port.  If the serial driver is		busy sending, we wait here until it is free.		port_puts (s, port):		Send the contents of a C string out the specified serial port.		port_break (port):		Generate an outgoing BREAK on the specified serial port.		(port_break) (duration, port):		Same as port_break() above, but allows specification of the break		duration in milliseconds (which is normally not necessary).  A		standard break (233 ms) is issued if the duration is zero.		port_xon (port):		Send an XON out the specified serial port (to tell the other end to		resume data transmission) if in the XOFF state.		port_xoff (port):		Send an XOFF out the specified serial port (to tell the other end to		suspend data transmission) if XOFF hasn't already be sent.		c = port_getc (port):		Get the next character received from the specified serial port or  		the last error that occurred (the error has priority).  The return		value is an int and the error codes are guaranteed to be negative		(making it perfectly legitimate to compare the result against zero		to see if there was an error).  The PORT_BUF_EMPTY is not necessarily		a fatal error and can be avoided by calling port_empty() first.				Note that a received BREAK manifests itself as a framing error		(PORT_FRAME_ERR) followed by a received null character ('\0').		c = port_pollc (port):		Poll the specified serial port for the next available character.		The return value is identical to port_getc().  Unlike port_getc(),		this function does not remove the character from the input buffer,		allowing you to test for errors without removing any characters		and providing a one character look-ahead.		while (port_empty (port)):		Test if there are no characters available to be read from the		specified serial port (TRUE if there aren't, FALSE if there are).		If necessary, the serial driver is called to pick up more characters.		Unlike port_pollc(), this function reflects the actual status of		the character buffer (i.e., whether or not there are characters in		that buffer), ignoring any errors that may have come in.  This		functions is often used to wait for characters to arrive.		Many different input buffer sizes are supported both dynamically and	statically.  Dynamic input buffers (allocated by (port_open)()) can be	any size.  To override the default static or stack-based input buffer	allocation size, #define PORT_BUFSIZE before including this file.		Originally written by Devon L. Petty on 1/28/88.	Interface substantially reworked by John S. Schwenk on 9/12/89.	Interface totally changed to support multiple ports by Karim J. Chichakly on 2/14/91.*/ #ifndef	NED__PORTIO#define	NED__PORTIO#include <Files.h>							/* for IOParam */#include <Serial.h>							/* for port_reset() constants */#ifndef NED__C#include "c.h"#endif#define	baud38400		1					/* port_reset() value to use for 38.4 Kbaud (missing from Serial.h) */#ifndef	PORT_BUFSIZE#define	PORT_BUFSIZE	512					/* size of input buffer */#endif/* constants */#define	PORT_WPBMAX		16				/* max amount of async write blocks *//* values returned by port_status() [it also will return the poll_getc() errors] */#define	PORT_OKAY		0					/* port is open; no errors */#define	PORT_NO_MEMORY	1					/* no memory to allocate port record */#define	PORT_NOT_FOUND	2					/* serial port is not installed in computer */#define	PORT_IN_USE	3					/* selected serial port is already in use *//* values returned by port_getc() and port_pollc() */#define	PORT_BUF_EMPTY		(-1)				/* no chars in input buffer */#define	PORT_SW_OVERRUN	(-2)				/* input buffer overrun */#define	PORT_HW_OVERRUN	(-3)				/* hardware buffer overrun (not serviced often enough) */#define	PORT_PARITY_ERR	(-4)				/* parity error on input */#define	PORT_FRAME_ERR		(-5)				/* framing error on input */#define	PORT_UNKNOWN_ERR	(-6)				/* unrecognized error */enum Ser_Port {							/* names of serial ports supported */	NO_PORT = -1,	MODEM_PORT = 0,	modem_port = MODEM_PORT,					/* for reverse-compatibility: do NOT use */	PRINTER_PORT,	printer_port = PRINTER_PORT,				/* for reverse-compatibility: do NOT use */	C_PORT,	D_PORT,	E_PORT,	F_PORT};/* data structures */#define Port_Wpb_buf_size	32struct Port_Wpb {							/* write parameter block record */	IOParam	wpb;							/* write parameter block */	char		c[Port_Wpb_buf_size];		/* characters to write */};typedef struct {							/* port information */	int8			port;					/* which port */	int16			in_ref;					/* input driver reference number */	uint16			in_baud;				/* input baud rate */	int16			out_ref;				/* output driver reference number */	uint16			out_baud;				/* output baud rate */	uint8			status;					/* current status */	bool			alloc;					/* TRUE if we allocated it */	int				next_wpb;				/* next free write parameter block */	struct Port_Wpb wpb_list [PORT_WPBMAX];	/* write parameter blocks for this port */	int				next;					/* pointer to next character to read from buffer */	int				len;					/* number of characters in buffer */	unsigned char	chars_pend [2*PORT_BUFSIZE];	/* unprocessed chars *//*	replacement for SERD 64 char buffer starts halfway through chars_pend */} PORT;/* prototypes */#ifdef __cplusplusextern "C" {#endifPORT *port_open (PORT *p, enum Ser_Port which_port, uint16 in_baud, uint16 out_baud, int buf_size);	/* open port for I/O */void port_close (PORT *p);					/* close the port */int	port_status (PORT *p);					/* get status of specified port/open operation */void port_reset (uint16 configuration, PORT *p);	/* set baud rate, data & stop bits, parity */void port_abort (bool abort_in, bool abort_out, PORT *p);	/* abort pending I/O */void port_set_handshake (bool in_handshake, bool out_handshake, PORT *p);	/* enable/disable handshaking */void port_set_baudrate (uint16 in_baud, uint16 out_baud, PORT *p);	/* set odd baud rates */enum Ser_Port	port_get_port (PORT *p);			/* pick up which port is open */uint16		port_get_in_baud (PORT *p);		/* pick up input port's baud rate */uint16		port_get_out_baud (PORT *p);		/* pick up output port's baud rate */void port_putc (char c, PORT *p);				/* send a character */void port_puts (char *s, PORT *p);				/* send a string */void port_putbytes (char *s, int length, PORT *p);void port_break (long duration, PORT *p);		/* send a break */void port_xon (PORT *p);						/* send an XON */void port_xoff (PORT *p);					/* send an XOFF */int	port_getc (PORT *p);					/* get a character */int	port_pollc (PORT *p);					/* test for character available (returns character) */bool port_empty (PORT *p);					/* returns TRUE if no characters available */#ifdef __cplusplus}#endif/* macros */#define port_get_port(p)		((p) == NULL ? NO_PORT : (p)->port)	/* pick up which port is open */#define port_get_in_baud(p)	((p) == NULL ? 0 : (p)->in_baud)		/* pick up input port's baud rate */#define port_get_out_baud(p)	((p) == NULL ? 0 : (p)->out_baud)		/* pick up output port's baud rate */#define port_open(p, which, in_baud, out_baud)	/* open serial port */		\	((port_open) (p, which, in_baud, out_baud, PORT_BUFSIZE))#define port_break(p)		(port_break) (0, p)	/* send standard break *//* Old interface emulation (these are provided for reverse-compatibility and  will eventually be discontinued - do NOT use them):enum Ser_Port	serial_port;					// port selecteduint16		in_baud_rate;					// input baud rateuint16		out_baud_rate;					// output baud rate[serial_in and serial_out are no longer available.  Do not use them! Use closeport() to close the driver and abort_port to KillIO.]bool initport(enum port_des whichPort, unsigned int inbaud, unsigned int outbaud);	// set up serial portvoid setbaudrate(unsigned int inbaud, unsigned int outbaud);			// set the baud ratevoid set_port_handshake_mode(bool input_handshake, bool output_handshake);	// set handshaking modevoid reset_port(uint16 port_configuration);	// set baud rate, data & stop bits, parityvoid abort_port(bool abort_in, bool abort_out);	// abort pending I/Oint	status_port(void);						// status of portvoid closeport(void);						// close down serial portvoid sendBRK(void);							// send a breakvoid send_brk(long duration);					// send a breakvoid sendXON(void);							// send an XOn charvoid sendXOFF(void);						// send an XOff charvoid sendchar(char c);						// send one charvoid sendstr(char *s);						// send sequence of charsvoid serialpoll(void);						// try to read host charsbool	chars_in_buffer(void);					// tests for presence of chars in input bufferint	get_serial_char(void);					// removes/returns one char from input buffer*/extern PORT *l_port;						/* local port to emulate old portio interface *//* statuses returned by get_serial_char() */#define	IN_BUF_EMPTY	PORT_BUF_EMPTY			/* no chars in input buffer */#define	IN_SW_OVERRUN	PORT_SW_OVERRUN		/* input buffer overrun */#define	IN_HW_OVERRUN	PORT_HW_OVERRUN		/* hardware buffer overrun (not serviced often enough) */#define	IN_PARITY_ERR	PORT_PARITY_ERR		/* parity error on input */#define	IN_FRAME_ERR	PORT_FRAME_ERR			/* framing error on input */#define	IN_UNKNOWN_ERR	PORT_UNKNOWN_ERR		/* unrecognized error */#define serial_port						port_get_port (l_port)#define in_baud_rate					port_get_in_baud (l_port)#define out_baud_rate					port_get_out_baud (l_port)#define initport(which, inbaud, outbaud)	((l_port = port_open (NULL, which, inbaud, outbaud)) != NULL)#define setbaudrate(inbaud, outbaud)		port_set_baudrate (inbaud, outbaud, l_port)#define set_port_handshake_mode(inhand, outhand) port_set_handshake (inhand, outhand, l_port)#define reset_port(config)				port_reset (config, l_port)#define abort_port(in, out)				port_abort (in, out, l_port)#define status_port()					port_status (l_port)#define closeport()						port_close (l_port)#define sendBRK()						port_break (l_port)#define send_brk(duration)				(port_break) (duration, l_port)#define sendXON()						port_xon (l_port)#define sendXOFF()						port_xoff (l_port)#define sendchar(c)						port_putc (c, l_port)#define sendstr(s)						port_puts (s, l_port)#define sendbytes(s,num)				port_putbytes (s, num, l_port)#define serialpoll()					((void) port_empty (l_port))#define chars_in_buffer()				(not port_empty (l_port))#define get_serial_char()				port_getc (l_port)#endif	/* NED__PORTIO */