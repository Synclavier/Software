/* NED Toolkit - Firmware Packet Handling Definitions   Copyright © 1990 by New England Digital Corporation      By:  Karim J. Chichakly on 10/13/88*/#ifndef NED__PACKET#define NED__PACKET#ifndef NED__C#include "c.h"#endif#ifndef NED__PACKETS#include "packets.h"						/* get PACKET definition */#endif#ifndef __68K_HARDWARE#include "hardware.h"						/* for globals base */#endif/* data structures */#define PKT_HEADER	(sizeof (PKT) - sizeof (PACKET))	/* length of packet header */typedef struct {							/* packet queue */	char  *tail;							/* queue tail (points to head if empty) */	char  *head;							/* first element, or zero if empty */	int16 panic;							/* length of queue - panic3 */} PKT_Q;typedef struct pkt {						/* packet */	struct pkt *link;						/* pointer to next packet */	PACKET packet;							/* data packet */} PKT;struct channel_data {						/* channel database */	uint16 semaphore;						/* hardware semaphore (1 if free, 0 if seized) */	uint16 channel;						/* channel number (0: chan A, 1: chan B) */	char	 *duscc;							/* channel's DUSCC base address */	char  *tx_dma;							/* transmit DMA channel base address */	uint32 rx_errors;						/* receiver errors */	uint32 retransmits;						/* retransmissions */	uint32 underruns;						/* underruns */	uint32 packets_lost;					/* number of received packets that were tossed (out of memory) */	uint16 tx_timer;						/* number of consecutive retranmissions to previously active channel */		PKT	 *rx_head;						/* head of receive queue */	PKT	 *rx_buffer;						/* current receive buffer */	PKT	 *rx_tail;						/* tail of receive queue */	PKT_Q tx_queue;						/* transmit queue */	uint16 tx_state;						/* transmitter state */	uint8  tx_sequence;						/* transmitter sequence number */	uint8  rx_state;						/* receiver state */	uint8  rx_sequence;						/* receiver sequence number */	uint8  tx_message;						/* transmit message */};struct crash_info {							/* crash information record */	uint8  node;							/* node ID */	uint8  vector;							/* exception vector */	uint8  stack [62];						/* info from stack */	uint32 regs [16];						/* registers */};/* globals (all are pointers) */#define pkt_chan_a	((struct channel_data *) GLOB_BASE)	/* channel A database */#define pkt_chan_b	(pkt_chan_a + 1)					/* channel B database */#define pkt_freelist	((PKT *) (pkt_chan_b + 1))		/* free list pointer */#define pkt_panic	((int16 *) (pkt_freelist + 1))		/* free panic */#define pkt_tossed	((uint32 *) (pkt_panic + 1))			/* number of packets tossed due to panic */#define pkt_rxq	((PKT_Q *) (pkt_tossed + 1))			/* receive queue */#define pkt_lmfree	((void *) (pkt_rxq + 1))				/* start of free area in low memory */#define pkt_crash	((struct crash_info *) (GLOB_END - sizeof (struct crash_info)))	/* pointer to crash data structure */#ifdef __cplusplusextern "C" {#endif/* low-level protocol driver */void init_pkt_driver (void);					/* initialize driver */void init_pkt_receive (void);					/* initialize packet receiver */void pkt_reset_channel (int chan);				/* reset DUSCC channel */int	pkt_send (int chan, PKT *p);				/* send packet */PKT	*pkt_receive (void);					/* receive packet *//* packet queueing */void pkt_initq (PKT_Q *q);					/* initialize packet queue */int	pkt_clrq (PKT_Q *q);					/* clear packet queue (returns number of elements before clearing) */bool pkt_enq (PKT_Q *q, PKT *p);				/* enqueue packet (returns FALSE if fails) */PKT	*pkt_deq (PKT_Q *q);					/* dequeue packet *//* packet allocation */void init_pkt_alloc (char *p, long len);		/* initialize packet allocator */PKT	*pkt_alloc (void);						/* allocate packet */void pkt_free (PKT *p);						/* free packet */#ifdef __cplusplus}#endif#endif	/* NED__PACKET */