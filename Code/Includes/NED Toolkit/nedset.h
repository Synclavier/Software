/* NED Toolkit - Set Abstract Data Type Definitions  This library implements the Set ADT.  The values that can be stored in the set  are integers restricted to the range of M -> N-1.  The operations defined are:	union_set (a, b, c):	C = A U B; returns C	intersect_set (a, b, c):	C = A M B; returns C	differ_set (a, b, c):	C = A - B; returns C		insert_set (x, a):		A = A U {x}	delete_set (x, a):		A = A - {x}	member_set (x, a):		TRUE if x c A		first_set (x, a)		retrieve first member in set A, end_of_set (a) if no member	next_set (x, a):		retrieve next member after x in set A;						returns end_of_set (a) if no next member	retrieve_set (n, a):	retrieve Nth member of set A;						returns end_of_set (a) if no Nth member	lbound_set (a):		returns lower bound of set A's range (i.e., M)	ubound_set (a):		returns upper bound of set A's range + 1 (i.e., N)	assign_set (a, b):		A = B; returns A	fill_set (a):			A = set of all elements (A's range)	clear_set (a):			A = ¿	empty_set (a):			TRUE if A = ¿		create_set (a, m, len):	create a new set (M->N-1 defines the set's range where N = M+LEN)	destroy_set (a):		destroy set A (must have been previously allocated by create_set)	print_set (a);			print set A on standard output		send_set (a):			send set A over DAWN protocol	send_set_data (a):		send set A's data over DAWN protocol	get_set (a):			get a set from the DAWN protocol; returns A	get_set_data (a):		get a set's data from the DAWN protocol; returns A  Every set MUST be created before it is used!  The function create_set ()  is passed either a pointer to an uninitialized set (that has already been  allocated in the globals, on the stack, or on the heap) or NULL if create_set  is to both allocate and initialize the set (this is just the way NewWindow in  the Macintosh Toolbox works).  It returns a pointer to the set passed in or,  if NULL was passed, a pointer to the set that was allocated or NULL if the  set couldn't be allocated.  When create_set () allocates a set, it allocates  just enough space to hold the specified range.    The function destroy_set () only exists to deallocate sets that were  allocated by create_set (when a NULL pointer was passed).  Never call the  function destroy_set () with a set that was not allocated by create_set ().    Many different sizes of sets are supported both dynamically and statically.  Dynamic sets (allocated by create_set ()) can be any size.  To override the  default static or stack-based set allocation size, #define SET_SIZE before  including this file.    These definitions can be used for several different sizes of static or  stack-based sets within one program providing SET_SIZE is large enough  to accomodate the largest set or that each different set is defined in  a different source file.  For example, file "large.c" could define (and  create) a 10000 element set while file "small.c" defined (and created)  a 10 element set.  Either file can then contain code to manipulate  either set.    By:  Karim J. Chichakly on 5/16/88  modified by MAC 9/18/90 to use signed shifts  Copyright © 1990 by New England Digital Corporation*/#ifndef NED__SET#define NED__SET#include <StdLib.h>							/* for create_set and destroy_set */#ifndef NED__C#include "c.h"#endif#ifndef SET_SIZE#define SET_SIZE	256						/* size of set */#endif/* implementation constants */#define SET_BITS	5						/* mask bits for bit index */#define SET_UNIT	(1<<SET_BITS)				/* number of bits in a unit */#define SET_WORDS	((SET_SIZE + (SET_UNIT - 1))/SET_UNIT + 1)	/* words needed to hold SET_SIZE bits starting at any base *//* data structures */typedef int set_type;						/* type of element stored in set */typedef struct {							/* set data type */	set_type	m, n;						/* bounds of elements in set */	int		base;						/* set element at word 0, bit 0 (in words) */	int		size;						/* size (in words) of set data array */	uint32	data [SET_WORDS];				/* set data */} SET;/* prototypes */#ifdef __cplusplusextern "C" {#endifSET	*union_set (SET *a, SET *b, SET *c);		/* compute union of two sets */SET	*intersect_set (SET *a, SET *b, SET *c);	/* compute intersection of two sets */SET	*differ_set (SET *a, SET *b, SET *c);		/* compute difference of two sets */void insert_set (set_type x, SET *a);			/* insert x in set A */void delete_set (set_type x, SET *a);			/* delete x from set A */bool member_set (set_type x, SET *a);			/* TRUE if x is a member of set A */set_type first_set (SET *a);					/* get first member in set A */set_type next_set (set_type x, SET *a);			/* get next member after x in set A */set_type retrieve_set (int n, SET *a);			/* get Nth member of set A */set_type end_of_set (SET *a);					/* value returned by retrieve_set if N is out of range */set_type lbound_set (SET *a);					/* get lower bound of set A */set_type ubound_set (SET *a);					/* get upper bound of set A */SET	*assign_set (SET *a, SET *b);				/* assign set B to set A */void fill_set (SET *a);						/* fill set A with all of its possible members */void clear_set (SET *a);						/* assign empty set to set A */bool empty_set (SET *a);						/* TRUE if set A is the empty set */SET	*create_set (SET *a, set_type m, int len, int max_len);	/* create a set */void destroy_set (SET *a);					/* destroy a set allocated by create_set */SET	*print_set (SET *a);					/* print the contents of A */void send_set (SET *a);						/* send A over DAWN protocol */void send_set_data (SET *a);					/* send A's data over DAWN protocol */SET	*get_set (SET *a);						/* get A from DAWN protocol */SET	*get_set_data (SET *a);					/* get A's data from DAWN protocol */#ifdef __cplusplus}#endif/* macros */#define end_of_set(a)		((a)->n)			/* value returned by retrieve_set if N is out of range */#define lbound_set(a)		((a)->m)			/* get lower bound of set A */#define ubound_set(a)		((a)->n)			/* get upper bound of set A */#define create_set(a, range_base, range_len)		/* create a set */			\	((create_set) (a, range_base, range_len, (a == NULL ? range_len : SET_SIZE)))#define first_set(a)		retrieve_set (0,a)	/* get 1st member of set */#define destroy_set(a)	free (a)				/* destroy a set allocated by create_set */#endif