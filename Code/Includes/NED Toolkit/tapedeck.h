/*-----------------------------------------------------------------------------|	NED Toolkit - Audio and Video Tape Deck Machine Control Library||	Copyright © 1990-1991 by New England Digital Corp.  All rights reserved.||	   This file contains interfaces relating to external audio and video tape|	deck remote control using either the Sony or Ampex machine control protocol |	with either the modem or printer serial port.|	   Functions are included here to perform the following:|		¥ Start up and shut down machine control using a given protocol|			and serial port.|		¥ Address a particular machine on the serial chain (Ampex protocol only).|		¥ Send protocol transport commands for:|			Play, Stop, Rewind, Fast Forward, Cue to timecode location,|			Shuttle Forward, and Shuttle Reverse|		¥ Examine the input port for status info returned by the controlled|			machine due to the last transport command sent out.|		¥ Ask controlled machine for it's current status.|		¥ Ask controlled machine for it's current timecode location.|| USING THIS FILE:|	   The function mc_startup() must be called before any transport|	function is called.  The protocol and serial port is chosen with parameters |	to this function.|	   mc_set_address() works when using Ampex protocol only.  It specifies |	the address of which 1 of 8 possible machines on the serial chain will |	be spoken to.  Defaults to user address 1 (0x80A2 actual address) if |	mc_set_address() is not called.|	   The transport motion functions (mc_play(), mc_stop(), mc_search(), etc.) |	can now be called as needed to make the slave perform the desired action.|	   mc_command_followup() MUST be called at some time after |	each transport motion function and before any other machine control  |	function is called.  This procedure reads the byte(s) that should have|	been sent by the slave in response to the motion command and tells you|	whether the command was received and understood by the slave.|	   mc_get_status() prompts the slave for status information and returns |	the result as one or more enum codes ORed together.|	   mc_get_timecode() prompts the slave for it's current timecode location.|	Assumes that slave has a timecode reader capable of reading the timecode on|	the tape.  Returns the timecode as sbits assigned to the location pointed|	to by a parameter.|	   mc_shutdown() closes the serial port and must be called when you are |	done using machine control, typically when the module is closed or the |	application quits.|| CODE EXAMPLE: Some generic example code is shown below:||	// Setup for machine control using modem port and Ampex protocol|	mc_startup(modem_port, MC_AMPEX_PROTOCOL);	// (returned status ignored) |	mc_set_address(1);						// Talk to machine with user address = 1. (Ampex only)|	...[code]...							//   (1 corresponds to actual serial address 0x80A2)|	mc_search(sbits_value);					// Make machine cue to sbits timecode location	|	...[code]...|	if (mc_command_followup() != MC_OKAY) {		// Did cue command work?	|		...[error alert code]...				// No, alert user to problem w/cable or machine	|	}|	...[code]...|	do {									// Wait for machine to get to timecode loc	|		machine_status = mc_get_status();		// poll controlled machine for status	|	} while  (not (machine_status & MC_SEARCH_DONE)) 	// Wait until tape arrives at location	|		and (machine_status & MC_OKAY)		// or problem with communication or machine	|		and (timeout_condition_not_reached);	// or it's taken too long; something's wrong	||	// Handle problems with communication or machine	|	if not (machine_status & MC_OKAY) then ...[error alert code]...;| |	// Make sure machine got to location asked for with mc_search()|	mc_get_timecode(&timecode);				// Get timecode (ignore returned value)|	if ((timecode > desired_loc + delta)		// Location within bounds? |	or  (timecode < desired_loc - delta))		//  (Note: timecode is in sbits)|		...[error alert code]...				// No, alert user to problem w/search||	mc_play();							// Make machine play	|	...[code]...|	if (mc_command_followup() != MC_OKAY) {		// Did play command work?	|		...[error alert code]...				// No, alert user to problem w/cable or machine	|	}|	...[code]...|	mc_stop();							// Make machine stop	|	...[code]...|	if (mc_command_followup() != MC_OKAY) {		// Did stop command work?	|		...[error alert code]...				// No, alert user to problem w/cable or machine	|	}|	...[code]...|	mc_shutdown();							// Close port, etc. before closing module/quiting	|| MORE INFORMATION: See Ampex and Sony protocol documents. | CREATED: 3/1/90	JSS| MODIFIED: 9/5/90	DSY	- added async requests for data+-----------------------------------------------------------------------------*/#ifndef	NED__TAPEDECK		/* Don't include tapedeck.h more than once	*/#define	NED__TAPEDECK#ifndef NED__CONVERT#include "convert.h"		/* sbits to smpte conversion	*/#endif#ifndef NED__PORTIO#include "portio.h"#endif#define BYTES_IN_DETAIL	20/* These literals are defined using the following manuals	BVH-2000 SERIES	BVH-2500 SERIES	BVH-3000 SERIES	BVH-3100 SERIES	BVU-900 SERIES	BVU-920 SERIES	BVU-950 SERIES	VO-9800 SERIES	VO-9850 SERIES There are no guarentees that these will not change, or that they are right in the first place...*/#define SONY_DATA_BYTE_0		0x00#define	SONY_LOCAL_MODE	0x01#define 	SONY_HARD_ERROR	0x04#define	SONY_TAPE_TROUBLE	0x08#define 	SONY_CASS_OUT		0x20#define SONY_DATA_BYTE_1		0x01#define	SONY_PLAY			0x01#define	SONY_RECORD		0x02#define	SONY_FAST_FORWARD	0x04#define	SONY_REWIND		0x08#define	SONY_EJECT		0x10#define	SONY_STOP			0x20#define 	SONY_STANDBY		0x80#define SONY_DATA_BYTE_2		0x02#define	SONY_CUEUP_DONE	0x01#define	SONY_STILL		0x02#define	SONY_DIRECTION		0x04#define	SONY_VAR			0x08#define	SONY_JOG			0x10#define	SONY_SHUTTLE		0x20#define	SONY_SERVO_LOCK	0x80#define SONY_DATA_BYTE_3		0x03#define	SONY_IN			0x01#define	SONY_OUT			0x02#define	SONY_AUTO_MODE		0x80#define SONY_DATA_BYTE_4		0x04#define	SONY_PREROLL		0x01#define	SONY_PREVIEW		0x02#define	SONY_AUTO_EDIT		0x04#define	SONY_REVIEW		0x08#define	SONY_EDIT			0x10#define	SONY_FREEZE_ON		0x20#define	SONY_FULL_EE_ON	0x40#define	SONY_SELECT_EE_ON	0x80#define SONY_DATA_BYTE_5		0x05#define	SONY_AUDIO_CH1		0x01#define	SONY_AUDIO_CH2		0x02#define	SONY_VIDEO		0x10#define	SONY_ASSEMBLE		0x20#define	SONY_INSERT		0x40#define SONY_DATA_BYTE_6		0x06#define SONY_DATA_BYTE_7		0x07#define	SONY_IN_OUT_STATUS	0x01#define SONY_DATA_BYTE_8		0x08#define	SONY_REC_INHIBIT	0x01#define	SONY_COLOR_FR_LOCK	0x08#define	SONY_END_OF_TAPE	0x10 #define SONY_DATA_BYTE_9		0x09#define SONY_DATA_BYTE_10	0x0A#define SONY_DATA_BYTE_11	0x0Btypedef unsigned char EXTENDED_STATUS_CODES [BYTES_IN_DETAIL];/* Send one of these to the mc_startup function to specify what protocol to use	*/enum mc_protocols {MC_NO_PROTOCOL = 0, MC_SONY_PROTOCOL, MC_AMPEX_PROTOCOL};/* Returned by some machine control funcs to indicate the status of the slave	*/ /* or returned bytes.  These bits are ORed together when more than one is true.	*//* All routines and protocols are not capable of returning all codes.			*//* For more info see block comments for funcs that return mc_status_codes.		*/enum	mc_status_codes {	MC_OKAY				= 0x00000001,	/* Info received okay from slave; okay to send new command */	MC_RESPONSE_PENDING	= 0x00000002,	/* Must call mc_command_followup() before another MC func */	MC_NAK				= 0x00000004,	/* Valid NAK received from slave */	MC_TIMEOUT			= 0x00000008,	/* Slave took too long to respond */	MC_GARBAGE			= 0x00000010,	/* Unrecognized info received from slave */	MC_STOP				= 0x00000020,	/* Slave indicates Stop state */	MC_PLAY				= 0x00000040,	/* Slave indicates Play state */	MC_REWIND			= 0x00000080,	/* Slave indicates Rewind state */	MC_FAST_FORWARD		= 0x00000100,	/* Slave indicates Fast Forward state */	MC_SHUTTLE			= 0x00000200,	/* Slave indicates Shuttle state */	MC_EOT				= 0x00000400,	/* Slave indicates End of Tape */	MC_TROUBLE			= 0x00000800,	/* Slave indicates some kind of trouble with itself */	MC_STILL			= 0x00001000,	/* Slave indicates Still state */	MC_SEARCH_DONE		= 0x00002000,	/* Slave indicates Cue Up or Search operation is done */	MC_LOCAL			= 0x00004000,	/* Slave indicates Local (not Remote) mode */	MC_EXTRAPOLATED_TC	= 0x00008000,	/* Timecode has been extrapolated since last valid read */ 	MC_SERIAL_ERROR		= 0x00010000,	/* Serial port error - call mc_serial_error() for specific problem */	MC_TIMEOUT_1		= 0x01000000,	/* Low level timeout reason stored here */	MC_TIMEOUT_2		= 0x10000000	/* Higher level timeout code stored here */};enum mc_tape_position {	MC_TAPEHEAD_OFF,	MC_TAPEHEAD_ON};/***************  PROTOTYPES  ******************/#ifdef __cplusplusextern "C" {#endifextern bool response_pending;/* Machine control startup and shutdown functions:	*/bool mc_startup(enum Ser_Port the_port, enum mc_protocols the_protocol);										/* Turn on machine control.  Opens port, etc..	*/void	mc_shutdown(void);						/* Turn off machine control.  Closes port.	*/enum	mc_status_codes mc_set_address(int address);	/* Selects machine of given address (1,2,...)	*/ /* "Transport" functions:	*/void mc_play(void);							/* Make slave play	*/void mc_stop(void);							/* Make slave stop	*/void mc_fast_forward(void);					/* Make slave fast forward	*/void mc_rewind(void);						/* Make slave rewind	*/void mc_shuttle(signed int speed);				/* Make slave shuttle at "speed" (+/-)	*/void mc_search(uint32 sbits_time, S_MODE smode);											/* Make slave cue to sbits_time timecode location on tape	*/enum	mc_status_codes mc_command_followup(void);	/* Call this after all transport functions		*/										/* Gets returned byte(s), returns status code	*//* Status query functions:	*/enum	mc_status_codes mc_get_status(void);		/* Gets slave's machine status	*/enum	mc_status_codes mc_get_timecode(uint32 *timecode_ptr, S_MODE smode);										/* Gets slave's current timecode location (it must have a TC reader)	*/										/* Assigns location to *timecode_ptr	*/void	mc_tapehead (enum mc_tape_position position);void mc_request_status (void);uint32 mc_pickup_status (EXTENDED_STATUS_CODES return_codes);void mc_request_timecode (void);uint32 mc_pickup_timecode (uint32 *sbits_time, S_MODE smode);int	mc_serial_error (void);					/* Get last serial port error (values match get_serial_char() in portio) */#ifdef __cplusplus}#endif#endif	/* NED__TAPEDECK */