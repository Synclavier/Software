/* Insert file to process alternate jump instruction */   cond = readif; /* get condition code */   key = readif;  /* get key to jump to */   lcl = cur.loc; /* save CUR.LOC before this instruction (for jump to jump deletion) */   if active then do; /* for active code only */      if key <> 0 then do; /* ignore clobbered keys (from jmp . => clobbered below if DIST = 10000) */         call altch (key); /* make sure in range */         if jumps then do; /* follow jumps to jumps only during JUMPS */            dist = 0; /* this is infinite loop detector */            okey = altjto (key); /* see if this location jumps somewhere */            do while ((okey <> 0) and (dist < 10000)); /* after 10000, assume we are hung up */               call set_altflag (key, altflag (key) and (not abit)); /* this label is now unknown */               key = okey; /* make this the new destination */               okey = altjto (key);               dist = dist + 1;            end;            if dist = 10000 then key = 0; /* detect infinite loop - key of 0 = jmp . */            if dist <> 0 then do; /* if we changed the key */               call writeif (key); /* write out new key */               altf = 1; /* we've made an alteration */               if debug then new.loc = (new.loc or 1);            end;         end; /* of if JUMPS */         if key <> 0 then do; /* if key isn't clobbered (i.e., it's jumped to) */            okey = altflag (key); /* pick up bits */            if (okey and abit) = 0 then do; /* see if we need to make it active */               call set_altflag (key, okey or abit); /* indicate active */               altf = 1; /* we've made an alteration */               if debug then new.active = (new.active or 1);            end;         end; /* of it's jumped to */      end; /* of non-clobbered key */      ocl = readif; /* get old estimated location */      if ocl <> cur.loc then do; /* check if loc changed from last pass */         call writeif (cur.loc); /* write out new location */         if jumps then do; /* only bother to re-iterate if JUMPS */            altf = 1; /* the IF changed */            if debug then new.loc = (new.loc or 2);         end;      end; /* of altered loc */      if ((iter = 0) and (not jumps)) then cur.loc = cur.loc + 2; /* assume 2 before JUMPS */      else if (skip_opt <> 0)         then cur.loc = cur.loc + 2;      else if key = 0 then cur.loc = cur.loc + 1; /* detect jmp . */      else do; /* see if jump instruction fits in one word */         if (okey and dbit) <> 0 /* already defined this pass */         then dist = altloc (key) - cur.loc - 1; /* compute distance based on current iteration */         else do; /* forward reference jump */            if ocl = -1 then dist = -32768; /* if inactive last pass, assume long jump */            else do; /* was active last pass */               dist = altloc (key) - ocl - 1; /* forward distance (use values from previous pass) */               if dist = -1 then dist = 0; /* -1 means previously deleted jmp .+1 */            end; /* of was active last pass */         end; /* of forward reference jump */         if (dist <> 0) or (not(jumps)) then do; /* 0 means jmp .+1 - delete instr - but only after all active code has been identified */            if emitt (dist)    /* if fits in immediate field */            then cur.loc = cur.loc + 1; /* then 1 word */            else cur.loc = cur.loc + 2; /* else 2 words */         end;      end; /* of checking if jump instruction fits in one word */   end; /* of active */   else do; /* if we're not active */      if readif <> -1 then call writeif (-1); /* get old loc - mark inactive if not already marked */   end; /* of not active */   if cond = b.tra then do; /* unconditional transfer? */      if (jumps and (not swaps)) /* if deleting jumps to jumps */      then do;         do while (altstkptr <> 0); /* see if any labels at this location (unstack label defs) */            ocl = altpop; okey = altpop; /* get location, its key */            if ocl = lcl /* see if instruction at this label is jump (LCL is set to CUR.LOC at top) */            then call set_altjto (okey, key); /* indicate jmp to jmp */         end;         stkptr = 0; /* cannot optimize jumps to jumps of different key types */      end;      active = 0; /* inactive code follows unconditional transfers */   end; /* of unconditional transfer */