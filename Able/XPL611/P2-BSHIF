/* Model B shift functions: */if x.node (arg2) = x.const then do; /* handle constant shifts */  x.i = x.info (arg2); /* get number of shifts */  reg.d = in.reg (arg1, 0); /* get ARG1 in any register */  if opr = o.rot then x.i = (x.i and 15); /* modulo 16 for rotate */  else if x.i IGT 16 then x.i = 16; /* check for neg, or > 16 */  do while x.i >= 8; /* modulo 8 do with rotate */    call emitc (0, b.bsor + bitreg (reg.d)); /* rotate 8 times */    if      opr = o.shl then call emitc ("177400", b.ad + b.and + bitreg (reg.d)); /* extract upper */    else if opr = o.shr then call emitc (255, b.ad + b.and + bitreg (reg.d)); /* else lower */    x.i = x.i - 8;   end;  do tmp = 1 to x.i; /* now finish shift */    if      opr = o.shl then call emita (b.rs + bitreg (reg.d), b.ad + b.add + bitreg (reg.d)); /* shift left */    else if opr = o.shr then call emitc (0, b.shra + bitreg (reg.d));    else                     call emitc (0, b.ad + b.lef + bitreg (reg.d)); /* rotate left */  end;end;else begin; /* must do sub call */  if reg2 = b.ac0 then reg2 = in.reg (arg2, not b.ac1); /* move to ARG1 if first register */  reg1 = in.reg (arg1, not b.ac0); /* get first argument */  reg2 = in.reg (arg2, not b.ac1); /* and get second */  do case (opr - o.shr);  /* and branch  */    call em.rtp (l.shr); /* shift right */    call em.rtp (l.shl); /* shift left  */    call em.rtp (l.rot); /* rotate      */  end;  reg.free = (reg.free or b.ac1);  reg.d = b.ac0; /* AC1 is now free, answer is in AC0 */end; /* if shift/rotate with no constant */