/* General definitions used by pass1, pass2, and pass3: */dcl extern.base      lit '(56*1024)'; /* RAM/SCON/KEY base for external references (so they don't conflict with external definitions - see pass1:GET_EXTLOC) */dcl temp.base        lit '(extern.base - 4*1024)'; /* SCON base for temporaries in recursive procs (so they we can recognize them) */dcl ins_levels       lit '20'; /* allow 20 levels of insert files */dcl s.depth.max      lit '15'; /* levels of localization (by default, it's only 4 bits) - must be (2^N - 1) */dcl max_recurs_parms lit '16'; /* maximum number of parameters to recursive procs */dcl proc_keys        lit '4'; /* number of keys used by a proc (minus one) */dcl when_keys        lit '3'; /* number of keys used by a when (minus one) */dcl mam lit '"60"'; /* external memory definitions - sector address */dcl mal lit '"61"'; /* word address */dcl md  lit '"62"'; /* memory */dcl mdi lit '"63"'; /* memory then increment *//* Token type definitions:.  .   The 'scanner'(procedure 'SCAN') is called to scan the next.   token (or 'atom') from the source file.   The scanner sets certain.   values to the global variables 'TOKEN' and 'INFO',  depending.   on the type of symbol that is scanned.   In general,  the global.   variable 'TOKEN' will contain an integer that indicates what type of.   atom was scanned (such as a fixed point variable),  and the.   global variable 'INFO' will further modify token (such as where.   in memory the variable will be stored)...   NOTE:  There is a dependency in the statement scanner (and perhaps.   elsewhere) on the token values less than T.LIT.  In particular,.   all variables must be less than T.LIT, all arrays must have odd.   token values, and all pointers must have the T.PVAR bit set...   RELOCATE_DEFNS in P3-3 also has an array STORAGE_TYPE that maps these.   token types to general storage types (i.e., ram, data, keys). */  dcl t.var     lit '0'; /* numeric fixed point variable    */dcl t.arr     lit '1'; /* fixed point array               */dcl t.fvar    lit '2'; /* floating point variable         */dcl t.farr    lit '3'; /* floating point array            */dcl t.pvar    lit '4'; /* pointer to fixed point variable */dcl t.parr    lit '5'; /* pointer to fixed point array    */dcl t.pfvar   lit '6'; /* pointer to floating variable    */dcl t.pfarr   lit '7'; /* pointer to floating point array */dcl t.lit     lit '8'; /* literal declaration             */dcl t.data    lit '9'; /* fixed point data array          */dcl t.fdata   lit '11'; /* floating data array             */dcl t.extern  lit '8';  /* global variable reference  */dcl t.public  lit '9';  /* global variable definition */dcl t.symonly lit '10'; /* symbol ref only */dcl t.proc    lit '16'; /* procedure                */dcl t.label   lit '17'; /* statement label          */dcl t.stmt    lit '18'; /* statement                */dcl t.type    lit '19'; /* declaration type name    */dcl t.storage lit '20'; /* declaration storage type */dcl t.rtp     lit '21'; /* run time call (shr, shl) */dcl t.module  lit '22'; /* module                   */dcl t.address lit '23'; /* addr of a parameter      */  dcl t.const   lit '32'; /* fixed point constant    */dcl t.fconst  lit '33'; /* floating point constant */dcl t.sconst  lit '34'; /* string constant         */  dcl t.comma   lit '48'; /* comma */dcl t.semi    lit '49'; /* semi  */dcl t.lpar    lit '50'; /* lpar  */dcl t.rpar    lit '51';dcl t.colon   lit '52'; /* colon */dcl t.eof     lit '53'; /* eof      */dcl t.opr     lit '54'; /* operator */dcl t.sdy     lit '55'; /* special form dyadic - shr(a, b) etc. */  dcl t.while   lit '64'; /* while */dcl t.case    lit '65'; /* case  */dcl t.to      lit '66'; /* to    */dcl t.by      lit '67'; /* by    */dcl t.end     lit '68'; /* end   */dcl t.then    lit '69'; /* then  */dcl t.else    lit '70'; /* else  */dcl t.unda    lit '72'; /* undeclared proc argument */dcl t.und     lit '73'; /* undefined symbol         */  dcl t.input   lit '81'; /* input */dcl t.locat   lit '82'; /* symbol 'location' - used in proc calls         */dcl t.copys   lit '98'; /* denotes copy scon to object file */dcl t.copyd   lit '99'; /* denotes copy data to object file (only data statement) */dcl t.ldef    lit '100';dcl t.assign  lit '101';dcl t.lnum    lit '103'; /* indicates source line number */dcl t.null    lit '104'; /* null statement               */dcl t.symref  lit '105'; /* symbol reference for linker  */dcl t.config  lit '109'; /* configuration type           */dcl t.pform   lit '110'; /* print format                 */dcl t.string  lit '111'; /* indicates string as in print string(array); */dcl t.icell   lit '112'; /* interrupt cell token identifier             */dcl t.rtns    lit '113'; /* returns keyword in procedure definition     */dcl t.recurs  lit '114'; /* defines a procedure to be recursive         */dcl t.swap    lit '115'; /* defines a procedure to be swappable         */dcl t.swpcode lit '116'; /* does not allow the swapping of string constants or data arrays */dcl a.eof   lit '"200"'; /* special flag (in char returned by GC) for end of file *//* storage classes */dcl s.static    lit '0'; /* static storage */dcl s.automatic lit '1'; /* automatic storage */dcl s.temporary lit '7'; /* temporary storage (static or automatic) - used only by PASS2 *//* procedure attribute bits *//* There are 16 bits, in this word, allocated for use as attribute bits */dcl p.recursive lit '"01"'; /* recursive procedure */dcl p.swap      lit '"02"'; /* swapping procedure */dcl p.swapscon  lit '"04"'; /* nonswapping scons or data arrays *//* Interpass data communications area:.  .   Certain data elements must be transferred from pass1 to pass2.   and on to pass3.   To simplify this transfer,  several important.   variables are define to be locations of an array that is later.   written out to the intermediate file.   When pass2 reads in the.   intermediate file, the data elements are read in with it.  Pass3.   uses this area to find the location of the bound runtime package. */dcl rtp.ptrs       lit '128'; /* number of rtp pointers used by pass3 */dcl configlen      lit '48'; /* length of configuration area in high core and interpass comm area (plus C#OFFSET for lowcore) */dcl whentablen     lit '48'; /* length of when table in comm area */  /* communications area locations */dcl l.pdll         lit '(rtp.ptrs + 0)'; /* push down length */dcl l.key          lit '(rtp.ptrs + 1)'; /* next available key - 1 (number of keys used) */dcl l.recurs.parms lit '(rtp.ptrs + 2)'; /* address of canonical storage for passing parameters to recursive procs */dcl l.altkey       lit '(rtp.ptrs + 3)'; /* alternate keys                   *//* word 4 is free */  dcl l.s.names.len  lit '(rtp.ptrs + 5)'; /* pass1 symbol table size */dcl l.str.data     lit '(rtp.ptrs + 6)'; /* amount of string and data storage */dcl l.stack.used   lit '(rtp.ptrs + 7)'; /* pass2 push stack size */dcl l.flags        lit '(rtp.ptrs + 8)'; /* various flags (defined below) */dcl l.ram          lit '(rtp.ptrs +  9)'; /* ram area length + 1 */dcl l.extloc       lit '(rtp.ptrs + 10)'; /* external references processed */  dcl l.#st          lit '(rtp.ptrs + 11)'; /* pass1 symbol table max */dcl l.#sk          lit '(rtp.ptrs + 12)'; /* pass2 push stack max */dcl l.#bl          lit '(rtp.ptrs + 13)'; /* pass2 number of blocks */dcl l.#if2         lit '(rtp.ptrs + 14)'; /* max size of interfile #2 *//* words 15-16 are free */dcl l.iflng        lit '(rtp.ptrs + 17)'; /* length of interfile #1 */dcl l.if2lng       lit '(rtp.ptrs + 18)'; /* length of interfile #2 */dcl l.ovram        lit '(rtp.ptrs + 19)'; /* overriding starting ram location */dcl l.get.blocks   lit '(rtp.ptrs + 20)'; /* pass2 get block stats */dcl l.main.key     lit '(rtp.ptrs + 21)'; /* key of main program (only when linking) */  dcl icell          lit '(rtp.ptrs + 22)'; /* interrupt cells */dcl ctab           lit '(icell + whentablen)'; /* configuration table *//* size of area */dcl maxcomm        lit '(ctab + configlen - rtp.ptrs - 1)'; /* size of interpass communications area *//* bits set in L.FLAGS: */dcl enable.flag lit '"1"'; /* an enable statement was encountered */dcl when.flag   lit '"2"'; /* a when statement was encountered */dcl link.flag   lit '"4"'; /* a library statement was encountered */dcl module.flag lit '"10"'; /* this is a module */dcl dump.flag   lit '"400"'; /* dump statistics */dcl symtab.flag lit '"1000"'; /* dump the symbol and sequence table */dcl skip.flag   lit '"2000"'; /* skip dead code analysis phase */dcl force.flag  lit '"4000"'; /* force code to ext memory      */dcl debug.flag  lit '"10000"'; /* gen better code for debugging */dcl keep.flags  lit '(when.flag or enable.flag)'; /* flags we keep when creating a relocatable binary *//* Transfer vector locations for the runtime package:..     As in Dartmouth's BASIC runtime package, there is a transfer vector.     at the beginning of the rtp which points to the routine to call..     The compiler only knows the location of the transfer vector.  In.     this compiler, the code gets changed by pass3 to point to the actual.     location of the routine rather than to the transfer vector location. *//* system routines */dcl l.sta  lit '"000"';dcl l.pat  lit '"001"';dcl l.in1  lit '"002"';/* Model C only: */dcl l.in2  lit '"003"';dcl l.in3  lit '"004"';/* Model D only: */dcl l.sw1  lit '"003"';     /* patch this location in startup to point to g.swap */dcl l.pgsw lit '"004"';     /* pointer to code to switch to page 0 */dcl l.pgx  lit '"005"';     /* pointer to code to exchange pages   */dcl l.sreg lit '"006"';dcl l.lreg lit '"007"';dcl l.retn lit '"010"';dcl l.swe  lit '"010"';     /* model c & later - swap entry        */dcl l.sw2  lit '"011"';     /* model c & later - swap patch        */dcl l.swpp lit '"012"';     /* relative pointer from h.swap to g.swap */dcl l.swap lit '"013"';/* floating point routines */dcl l.fpm  lit '"014"';dcl l.fpd  lit '"015"';dcl l.fpa  lit '"016"';dcl l.fps  lit '"017"';dcl l.fix  lit '"020"';dcl l.flo  lit '"021"';dcl l.abs  lit '"025"';dcl l.log  lit '"026"';dcl l.atn  lit '"027"';dcl l.cos  lit '"030"';dcl l.sne  lit '"031"';dcl l.tan  lit '"032"';dcl l.exp  lit '"033"';dcl l.sqr  lit '"034"';/* misc routines */dcl l.rot  lit '"041"';dcl l.shl  lit '"042"';dcl l.shr  lit '"043"';dcl l.bmv  lit '"045"';dcl l.bst  lit '"046"';dcl l.brk  lit '"047"';/* Transfer vector (cont.):.     output routines */dcl l.npr  lit '"050"';dcl l.spr  lit '"051"';dcl l.pri  lit '"052"';dcl l.fpr  lit '"053"';dcl l.con  lit '"054"';dcl l.opr  lit '"055"';dcl l.pch  lit '"056"';/* terminal input */dcl l.fin  lit '"060"';dcl l.sin  lit '"061"';dcl l.ipr  lit '"062"';dcl l.idn  lit '"063"';dcl l.ich  lit '"064"';dcl l.fxi  lit '"067"';/* byte/string routines */dcl l.byt  lit '"070"';dcl l.pbt  lit '"071"';dcl l.erd  lit '"073"';dcl l.ewr  lit '"074"';dcl l.ept  lit '"075"';dcl l.ipt  lit '"076"';dcl l.est  lit '"077"';/* special functions */dcl l.ter  lit '"100"';dcl l.sbr  lit '"101"';dcl l.sbw  lit '"102"';dcl l.see  lit '"103"';dcl l.fde  lit '"106"';dcl l.scur lit '"107"';/* fixed point math ops */dcl l.fmu  lit '"110"';dcl l.fdi  lit '"111"';/* other routines */dcl l.rfl  lit '"112"';dcl l.wfl  lit '"113"';dcl l.wsl  lit '"114"';dcl l.prd  lit '"115"';dcl l.pwr  lit '"116"';dcl l.swi  lit '"117"';/* Values greater than l.interp indicate *//* calls to Mac-hosted routines running  *//* the interpreter						 */dcl	l.interp lit '"400"';