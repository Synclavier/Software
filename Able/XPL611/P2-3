/* Expression scanner - definitions:..  Arithmetic expressions are stored in tree form..  The following definitions are used:*/dcl x.node  lit 'store1'; /* type of the node */dcl x.arg1  lit 'store2'; /* first argument pointer */dcl x.arg2  lit 'store3'; /* second argument pointer */dcl x.info  lit 'store4'; /* extra information */dcl x.spec  lit 'store5'; /* special information */dcl x.get   lit 'get'; /* storage allocation routines */dcl x.rel   lit 'rel';/* .  The following types of nodes, including X.VAR and X.CONST,.  are created by 'COMPUTE' for passage to IN.REG..  .  Every node returned by COMPUTE has X.ARG1 (NODE) set to indicate.  a floating or fixed point node.*/  dcl x.reg   lit '5'; /* register  - ARG1 = type, INFO = reg#        */dcl x.temp  lit '6'; /* temporary - ARG1 = type, INFO = loc block   */dcl x.preg  lit '7'; /* pointer register - ARG1 = type, INFO = reg# */dcl x.dev   lit '8'; /* device    - ARG1 = type (always fixed), INFO = dev# */dcl x.pvar  lit '9'; /* pointer to variable - arg1 = class (upper),  arg2 = 0, info = location */  /* For the above:.     X.REG:  if T.VAR,  then INFO = register# bit (1, 2, 4, 8).             if T.FVAR, then INFO = fpr# (1, 2) where 1 = AC0-AC1, and 2 = AC2-AC3.     X.TEMP: if T.VAR,  then INFO points to single word loc block where stored.             if T.FVAR, then INFO points to double word loc block where stored.     X.PREG: if T.VAR,  then INFO = reg# which points to desired location.             if T.FVAR, then INFO = reg# which points to word-pair.  .             ***** Note that for X.REG, X.TEMP, X.PREG, and X.PTEMP, the X.ARG1.             information is either T.FVAR or T.VAR.  Other information (such as.             T.ARR or T.PVAR bits) has been completely masked out in the process of.             going from a subscripted variable to a pointer register (subscript).             and then going from a register to a temporary.*/ /* Scan check routine:.   .   The routine SCANC is called to check for the occurrence of a .   line number record, a symbol definition record, or a ZREG .   type record in the intermediate file..  .   If one is found, then it is skipped after appropriate action.*/  scanc: proc; /* check for various records */  dcl t fixed;  XSTART:; /* come back here for more */  t = peek; /* scan current word,  no increment */    if t = t.lnum then do;  /* line number */    call gc; /* skip current word (T) */    line.no = gc; /* get line number */    call em.seq (line.no); /* output line number for pass3 */    goto XSTART;  end;    if t = t.copyd then do; /* see if should copy data to file */    call gc; /* skip current word (T) */    call em.cpy (gc); /* output copy information for pass3 */    goto XSTART;  end;    if t = t.copys then do; /* see if should copy scon to file */    call gc; /* skip current word (T) */    call em.scn (gc); /* output copy information for pass3 */    goto XSTART;  end;  if t = t.symref then do; /* process symbol for linker */     call gc; /* skip current word (T) */     call em.sym (gc); /* copy information for pass3 */     goto XSTART;  end;  if t = t.address then do; /* process addr of fixed array */     call gc; /* skip current word (T) */     t = gc; /* pick up procedure key */     call em.adr (t, gc); /* pass info onto pass3 */     goto XSTART;  end;end scanc;  /* Floating point management:.  .   During compilation (pass1), sequences of digits (1.123) are.   converted into binary floating point representation..  .   Each floating point number requires 32-bits.  During compilation.   therefore, floating pont constants are carried around.   in two fixed-point numbers, each with 16-bits. */  dcl fstkptr fixed;do fstkptr = 0 to fstklen - 1; /* initialize floating point stack */  fstk (fstkptr) = "100000";end;  fstr: proc(v1, v2) fixed; /* store two constants in stack, return ptr */  dcl (v1, v2) fixed;  fstkptr = 0; /* start at zero */  do while fstk (fstkptr) <> "100000"; /* scan for free */    fstkptr = fstkptr + 2;    if fstkptr = fstklen then call er.tmnc;  end;  fstk (fstkptr) = v1; fstk (fstkptr + 1) = v2; /* save */  return fstkptr;end fstr;/* Expression scanner:.  .   The expression scanner is a routine that is used to recover an expression.   tree from the intermediate file generated by pass1.  Virtually all of the.   expression processing has been done in pass1.*/  expr: proc; /* get next expression */      dcl (tree, temtree, brk) fixed;      if (read("51") and 2) <> 0 then do; /* check for break */     temtree = (read("50") and "177");     if temtree = "23" then do; /* handle XOn/XOff */        brk = 0; /* assume no BREAK */        do while (temtree <> "21"); if temtree = 0 then brk = 1; temtree = (read("50") and "177"); end; /* wait for XOn (and look for BREAK) */        if brk then temtree = 0; /* if a break occurred, force it after XOn */     end;     if temtree = 0 then do; call wait_for_break; call exit(-1); end; /* break */     if temtree <> "21" then print 'Compiling:     Pass 2         Sector: ', sfsec + shr(sfpos, 8), '    [', sfl, ' ]';  end;    if systyp = 0 then write("104") = 0; /* keep floppies going */    call push (tree); /* save current tree */  tree = x.get; /* get a block for the tree node */  temtree = gc; /* get word from file */  x.node (tree) = (temtree and "377"); /* lower half is always node type */  if x.node (tree) > x.cal then do; /* error if too big */     print;     print '### Compiler system error in expression scanner (', x.node (tree), ' at line', line.no, ')';     call exit(-1);  end;    do case (x.node (tree)); /* branch on type of node */     do; /* dyadic operator */        x.info (tree) = shr(temtree, 8); /* extract operator type */        temtree = expr; x.arg1 (tree) = temtree; /* dxpl used temp to store ptr to store1 array??? */        temtree = expr; x.arg2 (tree) = temtree;     end;       do; /* monadic operator */        x.info (tree) = shr(temtree, 8); /* and this is operator type */        temtree = expr; x.arg1 (tree) = temtree;     end;       do; /* constant */        x.arg1 (tree) = shr(temtree, 8); /* and this is type */        if x.arg1 (tree) = t.var         then x.info (tree) = gc; /* fixed point constant */        else begin; /* floater - read in two words */           dcl (t1, t2) fixed;           t1 = gc; t2 = gc; /* read and get it */           x.info (tree) = fstr (t1, t2); /* and store those */        end;     end;       do; /* variable */        x.arg1 (tree) = (shr(temtree, 8) or shl(gc, 8)); /* and this is type/storage class */        x.info (tree) = gc; /* pick up relative variable location */        if x.arg1 (tree) then do; /* if array */           temtree = expr; x.arg2 (tree) = temtree;        end;        if (x.arg1 (tree) and "377") = t.pvar /* and now they are the same */        then x.arg1 (tree) = (t.var or (x.arg1 (tree) and (not "377")));     end;  /* Procedure call tree node:.  .   X.NODE (TREE) = X.PROC.   X.ARG1 (TREE) = start of linked list of arguments, starting with first argument.   X.ARG2 (TREE) = alias list ptr/T.PROC or T.RTP, depending.   X.INFO (TREE) = key (for T.PROC) or absolute rtp location (for T.RTP).   X.SPEC (TREE) = variable type returned by procedure.  .   For each argument block:.  .   X.NODE (BLK) = link to next block, end with zero.   X.ARG1 (BLK) = token type of passed array, or start of expression tree for variable.   X.ARG2 (BLK) = declared variable type (arg declared in proc.).   X.INFO (BLK) = 0 if declared vtype is variable; variable offset for arrays; ptr for strings.   X.SPEC (BLK) = variable offset location for procedure argument (declared in proc.)*/       begin; /* procedure call */        dcl (blk, argtem) fixed;        x.info (tree) = gc; /* and pick up location - loc for rtp, key # for user proc */        x.spec (tree) = gc; /* get variable type returned and */        x.arg1 (tree) = 0; /* initialize variable list */        x.arg2 (tree) = (shl(shr(alias_ptr + 1, 1), 8) or shr(temtree, 8)); /* save type plus pointer to alias table */        alias_ptr = ((alias_ptr + 1) and (not 1)); /* force to even word boundary */        if alias_ptr ige alias_len then call er.cerr ('alias table incompatibility'); /* better match pass one! */        aliases (alias_ptr) = x.info (tree); aliases (alias_ptr + 1) = gc; /* save key and alias list length */        alias_ptr = alias_ptr + 2; /* account for alias header */          do temtree = 0 to aliases (alias_ptr - 1) - 1; /* read in alias list */           if alias_ptr ige alias_len then call er.cerr ('alias table incompatibility'); /* better match pass one! */           aliases (alias_ptr) = gc; /* save next alias list value */           alias_ptr = alias_ptr + 1; /* advance pointer */        end; /* of reading in alias list */          temtree = gc; /* get next word */        do while temtree <> 0; /* and loop */          blk = x.get; /* get a block for the argument */          x.node (blk) = x.arg1 (tree); /* set up forward ptr */          x.arg1 (tree) = blk; /* and now we are first (args are backwards in file, remember) */          x.arg2 (blk) = (temtree and 255); /* get type, ignore flag bit */          if x.arg2 (blk) = t.pvar then x.arg2 (blk) = t.var; /* delete T.PVAR bits */          x.spec (blk) = gc; /* variable area location of this argument - always vs1 */          if x.arg2 (blk) then do; /* argument is an array */             x.arg1 (blk) = gc; /* get token type/storage class of array we are passing */             x.info (blk) = gc; /* get variable location or string constant pointer for passed argument */          end;          else do; /* argument in proc is variable, not array */             call push (blk);             argtem = expr; /* scan expression, put in temporary */             blk = pop; /* restore block */             x.arg1 (blk) = argtem; /* put expression node here */          end;          temtree = gc; /* and get next one */        end; /* of do while for arg list */     end; /* procedure call */       do; /* X.CAL - convert to procedure call */        x.node (tree) = x.proc; /* procedure call */        x.arg1 (tree) = 0; /* takes no arguments */        x.arg2 (tree) = t.rtp; /* is runt time package call */        x.spec (tree) = shr(temtree, 8); /* get type returned */        x.info (tree) = gc; /* and get routine to call */     end;     /* note: other node types are not created by pass 1 */  end; /* of do case */    temtree = tree; /* save tree */  tree = pop; /* restore callers tree, in case of recursion */  return (temtree); /* and return scanned tree */end expr;  insert ':xpl611:p2-regop';/* Expression compiler:. .   The expression compiler takes a binary tree produced by the expression.   scanner and produces object code to compute the expression and put the.   result into a register.  The routine is called with a pointer to the tree.   to be compiled and it returns the register into which the value of the.   expression has been put.. .   Runtime register usage: .  .   During runtime, registers 4-9 (MIN.PTR.REG to MAX.PTR.REG) are used as.   variable address pointers.  Since the machine can only access memory.   through the registers, we will attempt to do a good job of keeping.   track of which registers are used when..  .   Since all variable addresses are assigned at declare time, the.   address of a variable is a known constant during compilation..   (Note this is NOT true for external references which are relocated.   in pass3.  REGC is used in conjunction with REGP to solve this.   incongruity.).  .   The array REGC is 10 words long and holds the contents of the.   corresponding register.  Obviously, the registers must be freed up .   when we jump around and do procedure calls.  We will attempt to.   keep track of which registers are used by which procedures and.   to optimize the variable assignments as much as possible. */  /* register allocation definitions */ dcl reg.free     fixed; reg.free = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* free regs */dcl reg.pref     fixed; /* currently preferred registers */dcl reg.cont (8) fixed; /* contents of each reg          */ dcl bitreg data (0, 0, 1, 0, 2, 0, 0, 0, 3); /* translation of bit to reg 0-3 */accpurg: proc; /* purge all accumulators */   dcl i fixed;   do i = 0 to 3;      call freeup (regbit (i));   end;end accpurg;regzap: proc; /* indicate that all registers contain trash */   dcl i fixed;   regl = 0; /* indicate all registers zapped */   do i = min.ptr.reg to max.ptr.reg;      regc (i) = 0; /* index registers don't point to anything anymore */      regl = (regl or regbit (i)); /* this reg not used */   end;end regzap;  regclr: proc(bits); /* to clear certain registers (i.e., on proc calls ) */   dcl (bits, i) fixed;   regl = (regl or bits); /* indicate register was cleared */   bits = shr(bits, min.ptr.reg); /* get regs 4-9 (min.ptr.reg to max.ptr.reg) handy */   do i = min.ptr.reg to max.ptr.reg;      if bits then regc (i) = 0; /* zap it */      bits = shr(bits, 1);   end;end regclr;  getreg: proc (nono) fixed; /* find a register to use, when all are being used */   dcl (nono) fixed; /* bits for register not to use */   dcl (i, j) fixed; /* look for "oldest" one        */   j = min.ptr.reg;   do while (nono&regbit(j))<>0; /* skip it if disallowed */      j=j+1;   end;   do i = min.ptr.reg + 1 to max.ptr.reg;      if  (regloc (i) <= regloc (j))      and ((nono&regbit(i))=0)      then j = i;   end;   return (j); /* j is oldest */end getreg;  /* Run time register allocation (cont):.  .   The routine 'GETVP' is used to generate code that will load.   a hardware index register with a pointer to a memory location.   during the program execution..  .   GETVP is passed a relative pointer into the variable area.  Although.   the absolute location of the variable area is not known until the.   end of pass3 (just before final object code generation), register.   allocation can intelligently be done by looking at the relative.   locations to which they will point during execution..  .   GETVP checks to see if an index register is already pointing to the.   specified variable area (the contents of the index registers are.   kept track of in the 'REGC' array during compilation.)  If one.   register is already pointing to that location, then it is used..  .   If no register points to the specified location, then instructions.   are emitted that will load the register with the specified value.   during program execution.  The register to load is selected on .   a 'least recently used' algorithm. */  dcl reg.allc proc(fixed) returns (fixed); /* accumulator allocation */dcl reg1.to.store        fixed;           /* accumulators to store  */dcl reg2.to.store        fixed;           /* while computing auto variable poitner */dcl store.preg           fixed;           /* true + store pointed to value rather than register contents */getvp: proc(class, vloc, nono) fixed;     /* get a register pointing to a variable location */   dcl (class, vloc, nono, i, j, k, l) fixed;/* note: NONO IS 16-BITS for getvp */   dcl (reg1,reg2                    ) fixed;     if vloc ige extern.base then class = s.static; /* force storage class for EXTERNALs */   if class = s.temporary then do; /* map temporary based on procedure type (see GTEMP) */      if in.recursive = 0          /* if NOT in a recursive procedure */      then class = s.static;       /* static temporary */      else class = s.automatic;    /* automatic temporary */   end;   /* of mapping temporaries */   /* see if a register already points to the variable in question */   j = 0; /* look for equal or empty reg */   do i = min.ptr.reg to max.ptr.reg; /* this loop is very similar to the procedure SENDVP */      if ((regc (i) = vloc) and ((regs (i) = class) or (vloc = 0)) /* if same location (class irrelevent if searching for free reg) */      and ((vloc ilt extern.base) or (regc (i) = regp (i)))) then do; /* it is in a register */         if vloc = 0 /* we were looking for an empty reg */         then regl = (regl or regbit (i)); /* assume that we are going to use it */         else do; /* we found its pointer */            if (regl and regbit (i)) = 0 /* used in orig form */            then regu = (regu or regbit (i));         end;         regloc (i) = cur.loc; /* indicate this is newest register */         return (i); /* found */      end; /* of in a register */      if  (regc (i) = 0)      and ((nono & regbit(i))=0)      then j = i; /* an empty register found that we can change */   end;     /* not there - get another register */     if j = 0 then j = getreg(nono); /* didn't find a free register - get the oldest (LRU) register */   /* see if index register points to the desired location - 1.  use */   /* increment feature if so.                                       */   if  (vloc ige 2)               /* location 2 (1) or beyond */   and (vloc ilt extern.base)     /* and not an external      */   then do;                       /* look for location - 1    */      do i = min.ptr.reg to max.ptr.reg;          if  (regc (i) = (vloc-1))              /* location vloc-1  */         and (regs (i) = class   )              /* same class (vloc will never = 0) */         and ((nono & regbit(i))=0)             /* not protected by sap/senvp */         then do;                               /* it is in a register */            if i=j then do;                     /* desire to use same register */               if (regl and regbit (i)) = 0     /* used in orig form */               then regu = (regu or regbit (i));               regl = (regl or regbit (i));     /* loaded by changing it */               call emita (b.rs or b.ibt or i, b.ca or b.tnv);    /* regi to atnv */               regc(i)=regc(i)+1;               /* incremented    */               regloc (i) = cur.loc;            /* last used here */               return i;                        /* use this guy   */            end;            else do;                            /* copy to another to preserve pointers */               if (regl and regbit (i)) = 0     /* used in orig form */               then regu = (regu or regbit (i));               regl = (regl or regbit (i));     /* i is changed by increment */               regl = (regl or regbit (j));     /* j is changed by write     */               call emita (b.rs or b.ibt or i, b.rd or j);    /* regi to rj */               regc (j) = regc(i);       /* reg j now contains what */               regs (j) = regs(i);       /* reg i did.  update info */               regp (j) = regp(i);       /* but leave regloc as it  */               regloc (j) = regloc(i);   /* was since we did not reference variable at that location */               regc(i) = regc(i)+1;             /* incremented    */               regloc (i) = cur.loc;            /* last used here */               return i;            end;         end; /* of in a register */      end;   end;   /* check for index register 2 locations back */   /* if recursive variable                     */   if  (vloc ige 3)               /* location 3 (2) or beyond */   and (vloc ilt extern.base)     /* and not an external      */   and (class = s.automatic)      /* for now only for recv's  */   then do;                       /* look for location - 1    */      do i = min.ptr.reg to max.ptr.reg;          if  (regc (i) = (vloc-2))              /* location vloc-2  */         and (regs (i) = class   )              /* same class (vloc will never = 0) */         and ((nono & regbit(i))=0)             /* not protected by sap/senvp */         then do;                               /* it is in a register */            if i=j then do;                     /* desire to use same register */               if (regl and regbit (i)) = 0     /* used in orig form */               then regu = (regu or regbit (i));               regl = (regl or regbit (i));     /* loaded by changing it */               call emita (b.rs or b.ibt or i, b.ca or b.tnv);    /* regi to atnv */               call emita (b.rs or b.ibt or i, b.ca or b.tnv);    /* regi to atnv */               regc(i)=regc(i)+2;               /* incremented    */               regloc (i) = cur.loc;            /* last used here */               return i;                        /* use this guy   */            end;            else do;                            /* copy to another to preserve pointers */               if (regl and regbit (i)) = 0     /* used in orig form */               then regu = (regu or regbit (i));               regl = (regl or regbit (i));     /* i is changed by increment */               regl = (regl or regbit (j));     /* j is changed by write     */               call emita (b.rs or b.ibt or i, b.rd or j);    /* regi to rj */               call emita (b.rs or b.ibt or i, b.ca or b.tnv);    /* regi to atnv */               regc (j) = regc(i);       /* reg j now contains what */               regs (j) = regs(i);       /* reg i did.  update info */               regp (j) = regp(i);       /* but leave regloc as it  */               regloc (j) = regloc(i);   /* was since we did not reference variable at that location */               regc(i) = regc(i)+2;             /* incremented twice   */               regloc (i) = cur.loc;            /* last used here */               return i;            end;         end; /* of in a register */      end;   end;   /* emit object code (blah!!) to load pointer */   if vloc <> 0 /* emit a variable pointer record (register J points to var location) */   then do case (class); /* branch on storage class */      call em.vpt (class, vloc, b.rd or j); /* static - emit a variable pointer */      do; /* automatic - relative to stack */         /* if reg1.to.store is nonzero,  then we are being called */         /* from reg.allc to get a pointer in an index register,   */         /* and store the contents of reg1.to.store in that memory */         /* location                                               */         /* object codes:            store 1 reg in temp:       r0   to  r11      move accum to temp index reg                                       r12  to  loa0     compute stack                                       im() to  add0     pointer                                       r11  to  mr0      store orig accum in temp                                       r0   to  r11      move pointer to ixr            store 1 preg in temp:      r0   to  r11      move accum to temp index reg                                       r12  to  loa0     compute stack                                       im() to  add0     pointer                                       mr11 to  mr0      move pointed to item to temp                                       r0   to  r11      move pointer to ixr            store 2 regs in temp:      r0   to  r11                                       r12  to  loa0                                       im() to  add0                                       r11  to  mr0                                       r0i  to  r11                                       r1   to  mr0            store 2 word preg            in temporary:              r0    to  r11                                       r12   to  loa0                                       im()  to  add0                                       mr11I to  mr0i                                       mr11I to  mr0i                                       im(2) to  sub0                                       r0    to  r11   */         if reg1.to.store<>0      /* called from reg.allc - store these registers while computing automatic variable poitner */         then do;            i = x.get;                       /* get optimizing block  */            x.node(i) = x.pvar;              /* pointer to variable   */            x.arg1(i) = shl (class,8);       /* store class           */            x.arg2(i) = 0;                   /* x.info is set below   */            reg1=bitreg(reg1.to.store);            reg2=bitreg(reg2.to.store);            call emita (b.rs or reg1, b.rd or j);    /* reg1 to regj  */            call em.vpt(class, vloc, b.rd or reg1);  /* vpt  to reg1  */            if reg2.to.store<>0            then do;                 /* two registers/words to store */               if store.preg <> 0    /* double word x.preg to store  */               then do;                  call emita (b.ms or b.ibt or j, b.md or b.ibt or reg1);                     call emita (b.ms or b.ibt or j, b.md or b.ibt or reg1);                     call emitc (-2,b.ad+b.add+reg1); /* subtract 2 to correct for increments */                  call emita (b.rs or reg1, b.rd or j);                      x.info(i) = vloc;                               end;               else do;              /* two registers to store */                  call emita (b.rs or j, b.md  or reg1);   /* regj to mreg1  */                  call emita (b.rs or b.ibt or reg1, b.rd or j);    /* reg1i to regj   */                  call emita (b.rs or reg2, b.md  or reg1); /* reg2 to mreg1  */                  x.info(i) = vloc+1;                /* note increment above  */               end;            end;            else do;                 /* single word      */               if store.preg <> 0    /* single word preg */               then do;                  call emita (b.ms or j, b.md or reg1);    /* mregj to mreg1 */                  call emita (b.rs or reg1, b.rd or j);    /* reg1 to regj  */                  x.info(i) = vloc;               end;               else do;                  call emita (b.rs or j, b.md or reg1);    /* regj to mreg1 */                  call emita (b.rs or reg1, b.rd or j);    /* reg1 to regj  */                  x.info(i) = vloc;               end;            end;            call freeup(reg1.to.store);      /* clean up tree         */            trees (reg1.to.store) = i;       /* indicate it points    */            reg1.to.store=0;                 /* indicate stored       */            reg2.to.store=0;            store.preg   =0;         end;         else do;              /* not called from reg.allc - get a register to do computation */            /* perform optimization - see if one of the accumulators */            /* already points to the stack.  add in a delta offset   */            /* to save an instruction or two if so:                  */            i=b.ac0;                       k=0;            do while (i <= b.ac3) and (k=0);               l = trees(i);         /* see if we know contents */               if l <> 0 then do;    /* nonzero means we do     */                  if  (x.node (l) = x.pvar)        /* type  */                  and (x.arg1 (l) = shl(class, 8)) /* class */                  and (((x.info (l) ige temp.base) and (vloc ige temp.base))  /* temporary or variable */                  or   ((x.info (l) ilt temp.base) and (vloc ilt temp.base)))                  then do;                     k=i;            /* indicate found          */                     if (vloc <> x.info(l)) /* add in offset if not zero.   some times is zero when using floating point since index registers get incremented */                     then call emitc(vloc-x.info(l),b.ad+b.add+bitreg(k));                     call emita (b.rs or bitreg(k), b.rd or j); /* move to pointer reg     */                  end;               end;               i=shl(i,1);            end;            if k=0 then do;                        /* no accumulator points to stack - get one */               call push(class); call push(vloc);  /* save variables in case */               call push(nono ); call push(   j);  /* reg.allc needs a v ptr */               call push(reg.pref);                /* save preferences       */               reg.pref = b.ac2 \ b.ac3;           /* most preferred         */               regc (j) = vloc;       /* mock up indication of register contents */               regs (j) = 9999+class; /* so that we do not use this same register */               regp (j) = vloc;       /* if reg.allc calls us */               regloc (j) = cur.loc;  /* last used here       */               k = reg.allc (nono);   /* get an accumulator   */               i = bitreg   (k);                       reg.pref = pop;               j = pop; nono = pop; vloc = pop; class = pop;               call em.vpt (class, vloc, b.rd or i); /* get variable pointer */               call emita (b.rs or i, b.rd or j); /* move to pointer reg     */            end;            call freeup(k);                    /* nothing we keep track of */            i = x.get;                         /* get optimizing block  */            x.node(i) = x.pvar;                /* pointer to variable   */            x.arg1(i) = shl (class,8);         /* store class           */            x.arg2(i) = 0;            x.info(i) = vloc;            trees (k) = i;                     /* indicate it points    */         end;      end; /* of automatic */   end; /* of emit a variable pointer record */   regc   (j) = vloc; /* save for future reference */   regs   (j) = class;   regp   (j) = vloc;   regloc (j) = cur.loc; /* last used here */   regl = (regl or regbit (j)); /* keep track of which are loaded */   return (j); /* and return the register */end getvp;/* Send a variable pointer to a destination.  This is quite similar to.   GETVP, except the pointer is to be sent to a known destination rather.   than to a free index register...   DEST is restricted to loads of arithmetic accumulators or variable.   pointer references. */sendvp: proc(class, vloc, dest, nono); /* send variable pointer to destination */   dcl (class, vloc, dest, nono, i, j) fixed;     if vloc = 0 then call er.cerr ('sendvp');   if vloc ige extern.base then class = s.static; /* force storage class for EXTERNALs */   if class = s.temporary then do; /* map temporary based on procedure type (see GTEMP) */      if in.recursive = 0 /* if NOT in a recursive procedure */      then class = s.static; /* static temporary */      else class = s.automatic; /* automatic temporary */   end; /* of mapping temporaries */   do i = min.ptr.reg to max.ptr.reg;   /* see if it's already in an index register (similar to GETVP) */      if   (regc (i) = vloc)       and  (regs (i) = class)           /* see if same location */      and  ((vloc ilt extern.base) or (regc (i) = regp (i)))       then do;                          /* if local or unchanged */         if (regl and regbit (i)) = 0 then regu = (regu or regbit (i)); /* used on orig form */         regloc (i) = cur.loc;          /* and save location last used */         call emita (b.rs + i, dest);   /* send it */         return;      end;   end;   /* isn't already in a register */   if  (class = s.static)                          /* static variable */   or  ((dest \ b.amsk) = (b.ad \ b.loa \ b.amsk)) /* or accum load   */   or  ((dest \ b.amsk) = (b.rd         \ b.amsk)) /* or accum dest   */   then call em.vpt (class, vloc, dest);                   /* just emit the variable pointer */   else call emita  (b.rs + getvp (class, vloc, nono), dest);  /* get pointer and send it (assume DEST was used recently).  optimizing code will never find it becuase dest will always point to a static variable */end sendvp;  /* Expression compiler - temporary allocation:.  .   During the processing of arithmetic expressions, temporaries are.   sometimes needed to store intermediate arithmetic results..   Temporary memory allocation and deallocation is handled by the.   following routines:*/  dcl fxd lit '0'; /* zero is pointer to fixed temps */dcl flt lit '1'; /*  one is pointer to float temps */  dcl tlist (flt) fixed; /* holds pointers to temps */  gtemp: proc(typ); /* pass type - fixed or float */   dcl typ  fixed;   dcl temp fixed; /* will become pointer */   if tlist (typ) = 0 then do; /* if no temps of type,  then get a block */      if ram ige extern.base /* expression too complicated */      then call er.etc ('too many temps');      temp = ram; /* allocate in ram region */      ram = ram + 1 + typ; /* allocate memory */   end;   else do; /* there is a free one - use it */      temp = e.loc (tlist (typ)); /* get pointer to block */      call e.rel (tlist (typ)); /* and free up block holding this temp */      tlist (typ) = e.point (tlist (typ)); /* and move down list */   end;   return (temp); /* and that is pointer to memory location,  absolute */end gtemp;  ptemp: proc(temp, typ); /* free up a temporary of type x */  dcl (temp, typ) fixed;  dcl t fixed;  t = e.get; /* get a block */  e.loc (t) = temp;  e.point (t) = tlist (typ);  tlist (typ) = t; /* save memory pointer, set pointer, update list */end ptemp;freetemp: proc; /* free up all temporary blocks */  dcl (i, j) fixed;  do i = 0 to 1; /* free up temporaries */    j = tlist (i);    do while j <> 0;      call e.rel (j);      j = e.point (j);    end;    tlist (i) = 0;  end;end freetemp;pushtemp: proc; /* call to push temps */  call push (tlist (1)); call push (tlist (0));  tlist (0) = 0; tlist (1) = 0;end;poptemp: proc; /* call to restore temps */  tlist (0) = pop; tlist (1) = pop;end poptemp;  /* Routine SENDIT:.  .   The 'SENDIT' routine is called to generate object code that will.   move one data element from a source (register, memory, etc.) to.   any destination..  .   The source is represented by a 'node block', which was first.   generated by the 'EXPR' routine (pass1) and then later massaged.   by the 'COMPUTE' routine (pass2)..  .   The 'SENDIT' routine is only for fixed point variables, and.   assumes that all the nodes have been massaged with the.   'COMPUTE' procedure before 'SENDIT' is called. */  dcl (d4used, d4block)    fixed; /* keep track of what is in D4 */dcl (d5used, d5block)    fixed; /* keep track of what is in D5 */dcl (divarg, upperblock) fixed; /* used to locate upper bits  */sendit: proc(node, dest, nono); /* node, destination - pass registers not to use */   dcl (node, dest, nono, reg, type, info) fixed;   dcl (i, k, sou, class) fixed;   type = x.node (node); /* get type */   info = x.info (node); /* and info */   do case (type); /* branch on node type */      ;                        /* dyadic operators have been computed  */      ;                        /* monadic operators have been computed */              call emitc (info, dest); /* constant */      do; /* variable - not subscripted (they are X.PREGS by now) */         class = shr(x.arg1 (node), 8); /* get storage class */         i = 1; sou = 0;         do while (i < 16) and (sou = 0);            k = trees (i);            if k <> 0 then do;               if  (x.node (k) = x.var)  /* register contains a variable */               and (x.info (k) = info )  /* at same location             */               and (x.arg1 (k) = (t.var or shl(class, 8))) /* same class */               then sou = b.rs + bitreg (i); /* use variable in register */            end;            i = shl(i, 1);         end;         if sou = 0 then do; /* must fetch from memory */            reg = getvp (class, info, nono);            call emita (b.ms + reg, dest);         end;         else call emita (sou, dest); /* else register to destinatin */      end; /* of variable */              ;              do;         call emita (b.rs + bitreg (info), dest);         reg.free = (reg.free or info);      end;              do; /* temp */         reg = getvp (s.temporary, info, nono);          call emita  (b.ms + reg, dest);         call ptemp  (info, fxd);           /* and free up temporary */         if dest = b.md + reg then call er.cerr ('sent-3');      end; /* temp */              do; /* pointer register */         call emita (b.ms + bitreg (info), dest);         reg.free = (reg.free or info);      end; /* pointer register */              do; /* device to read */         call emita (info, dest); /* send device to dest */         if info = 4 then d4used = 0;         if info = 5 then d5used = 0;      end; /* device to read */              do; /* pointer to variable - not used with sendit */         call er.cerr('Sendit/X.pvar'); /* compiler system error */      end;   end; /* of do case */end sendit;  /* FSENDIT:.  .   The routine 'FSENDIT' is used to generate object code that.   will transfer a floating point number between a source .   and a destination..  .   The routine is passed an expression node (created by pass1:EXPR .   and modified by pass2:COMPUTE) and two 8-bit destinations. */  dcl ffpr data (0, b.ac0, b.ac2); /* first floating point register */dcl sfpr data (0, b.ac1, b.ac3);  /* NOTE:  fsendit is passed NONO registers where NONO contains   bits for fixed point accumulators (ac0-ac3) and the index   registers (r4 - r11) */fsendit: proc(node, dest1, dest2, nono); /* pass 2 dests */   dcl (node, dest1, dest2, nono, reg, type, info, class) fixed;   dcl reg3 fixed;   type = x.node (node); /* get type of node */   info = x.info (node); /* and get local info */   do case (type); /* branch on type of floating point node */      ;      ;          do; /* floating point constant to destination */         call emitc (fstk (info), dest1); /* send pout first */         call emitc (fstk (info + 1), dest2); /* and second */         fstk (info) = "100000"; /* and indicate free */      end;          do; /* variable */         class = shr(x.arg1 (node), 8); /* storage class for vars */         reg = getvp (class, info, nono); /* get pointer to variable,  no matter what type */         if (dest1 and 15) = reg then call er.cerr ('fsen-1');         if (dest2 and 15) = reg then call er.cerr ('fsen-2');         if (x.arg1 (node) and "377") = t.fvar then do; /* plain floating variable - not pointer */            call emita (b.ms + b.ibt + reg, dest1);            call emita (b.ms + b.ibt + reg, dest2);            regl = (regl or regbit (reg)); regc (reg) = regc (reg) + 2; /* and increment register */         end;         else do; /* must be pointer to variable */            reg3 = getvp (0, 0, nono \ regbit(reg)); /* get empty index register */            call emita (b.ms + reg, b.rd + reg3);    /* get pointer */            call emita (b.ms + b.ibt + reg3, dest1);            call emita (b.ms + b.ibt + reg3, dest2);            regl = (regl or regbit (reg3)); regc (reg3) = 0; /* clean up temp register */         end;      end; /* of variable */           ;          /* handle floating nodes that are registers, pointer registers, and      .  temporaries. */        do; /* floating point register */         reg3 = ffpr (info); call emita (b.rs + bitreg (reg3), dest1); /* send first */         reg.free = (reg.free or reg3); /* and it is now free */         reg3 = sfpr (info); call emita (b.rs + bitreg (reg3), dest2); /* send other floating register also */         reg.free = (reg.free or reg3); /* and now that register is freed up */      end;          do; /* tempr */         reg = getvp (s.temporary, info, nono); /* get pointer to temp */         call emita (b.ms + b.ibt + reg, dest1); /* send it */         call emita (b.ms + b.ibt + reg, dest2); /* and lower half,  from memory to dest */         regl = (regl or regbit (reg)); regc (reg) = regc (reg) + 2; /* and we incremented it */         call ptemp (info, flt); /* and scratch one floating point temp */      end;          do; /* pointer register - points to variable pair */         call emita (b.ms + b.ibt + bitreg (info), dest1); /* send first word */         call emita (b.ms + b.ibt + bitreg (info), dest2); /* send second word */         reg.free = (reg.free or info); /* pointer register is now free */      end;          do;         /* x.pvar */         call er.cerr('Fsendit/X.pvar'); /* compiler system error */      end;   end; /* of floating point case - will get do case error if compiler error */end fsendit; /* and done with it all */