/* Statement scanner:. .  Statement scanning routine:  This scans off the next statement.  including the semicolon and compiles code to execute it.  A statement.  includes the label on the statement.  This routine is obviously very.  recursive, calling both itself and the statement list routine. */stmt: proc;dcl (stype, sclass, sinfo, class, info, wdes) fixed;dcl (fva, pva, dreg, ireg, subscr, val, snode, xinfo) fixed;dcl (reg1, reg2, d1) fixed;dcl (pbk, i, j, k, reg.e) fixed; /* used in loop processing */dcl (arg#, temp, temps, slen, reg.arg, dswp) fixed; /* and in proc defs */dcl (prockey, pbits) fixed; /* pbits contains the procedures attributes */dcl (regd,ffregs)    fixed;dcl (dest)           fixed; /* Statement list routine - scans statements up to an 'END' statement. */ stmt.list: proc;   call scanc; /* check for line number, label definition, or ZREG */   token = peek; /* get next token */   do while not ((token = t.end) or (token = t.eof));      call stmt;      call scanc; /* check for line numbers, etc. */      token = peek;   end;   call gc; /* skip over token of t.end */end stmt.list; compute.to.reg0: proc; /* scan expression, compute it, store in reg 0 */   call scanc; subtree = expr; /* skip line no's and get expr from interfile */   reg.pref = b.ac0; mvt = 0; /* get result in AC0, look for fixed */   call compute; call fix (subtree); /* fixed point */   call in.reg (subtree, not b.ac0);   reg.free = (reg.free or b.ac0); call x.rel (subtree);end;/* $$Statement scanner - handle the PRINT/SEND statement: */ pstmt: proc; /* just call - device type is in intermediate file */   dcl (pdes, rl) fixed; /* holds node block and temp */       /* first a convenient sub: */   pins: proc(loc); /* subroutine to emit call to PRINT */      dcl loc fixed; dcl blk fixed;      blk = x.get; x.node (blk) = x.const;       x.arg1 (blk) = t.var; x.info (blk) = pdes;      call in.reg (blk, not b.ac2); /* get destination in AC2 */      reg.free = (reg.free or b.ac2); /* but register is actually free */      call x.rel (blk); /* done with block */      call em.rtp (loc);      call freeup (b.ac0); call freeup (b.ac1); call freeup (b.ac3); /* trashed */   end pins;          dcl rtab data (l.opr, l.pch); /* print formats */   pdes = gc;   call scanc; /* skip lnums */   do while (peek <> 0); /* and do until end of print list */      do case (gc - 1); /* branch on type of print statement */               call pins (l.pri); /* print crlf */               do; /* expression */            call scanc; /* lnums here */            mvt = 1; /* assume worst case */            subtree = expr; reg.pref = b.ac0; call compute; /* get and compute expression */            if (x.arg1 (subtree) and t.fvar) <> 0 then do; /* floating print */               call fin.reg (subtree, not b.ac0); reg.free = (reg.free or b.ac0 or b.ac1); /* get in reg */               rl = l.fpr; /* floating print */            end;            else do; /* fixed point */               call in.reg (subtree, not b.ac0); reg.free = (reg.free or b.ac0); /* get in reg */               rl = l.npr; /* number print */            end; /* of fixed */            call x.rel (subtree); /* done with expression */            call pins (rl); /* emit instructions */            if rl = l.fpr then call freeup (b.ac2); /* floating print trashes AC2 */         end; /* of expression */          do; /* string */            call em.spt (gc, b.rd + 0); /* get string pointer in AC0 */            call pins (l.spr); /* and print it */         end;          do; /* print string */            token = gc; class = gc; info = gc; /* get type, class, and location */            if (token = t.sconst) or (token = t.data) or (token = t.fdata) /* scon or data */            then call em.spt (info, b.rd + 0);   /* pointer in AC0 */            else if token = t.arr then do;       /* PRINT STRING(array) */               if info = 0 /* CORE? - someone has big ideas */               then call emitc (0, b.rd + 0);    /* STRING(core) */               else call sendvp (class, info, b.rd + 0, 0); /* else emit variable pointer */            end;            else if token = t.locat then call compute.to.reg0; /* PRINT STRING(LOCATION(x)) */            else do; /* must be pointer to array */               reg1 = getvp (class, info, 0); /* get pointer register pointing to pointer */               call emita (b.ms + reg1, b.rd + 0); /* load pointer to array into AC0 */             end;            call pins (l.spr); /* and use same routine */         end;            do; /* character: */            rl = rtab (gc); /* get it */            call compute.to.reg0;            call pins (rl); /* and print character */         end;      end; /* of do case */      call scanc; /* ignore stuff here */   end; /* of do while */   call gc; /* to skip over final zero */end pstmt; /* and end of it *//* $$Statement scanner - check for statement: */ call scanc; /* check for line number, etc. */token = peek; /* get current one */ if token = t.ldef then begin; /* was a label definition at start of statement */    call gc; call em.lde (gc); /* label def - this is key */    call regzap; /* indicate all index register unknown (goto) */    call accpurg; /* indicate all registers unknown */    zflags = 0;    call scanc; /* skip labels here */    token = peek; /* and new token, maybe */    if token = t.end then return; /* and detect label: end here */end; if token = t.null then do; /* null statment */   call gc; call scanc;   return;end;/* $$Statement scanner - assignment:. .   Assignment:. .   Get expression and subscript if one.. .   Compute value and store in desired location. */ if (token and "377") = t.assign then do; /* assignment */   call gc; /* skip assign token */   stype = shr(token, 8); /* extract type */   sclass = gc; /* storage class */   sinfo = gc; /* and variable info */   call scanc; /* skip line #'s, etc. */   if stype = t.pvar then stype = t.var; /* and fix up to be variable */   fva = (stype and t.fvar) <> 0; pva = (stype and t.pvar) <> 0; /* fl var attrib, ptr var attrib */   if stype then subscr = expr; /* scan expression if subscripted */   else subscr = 0; /* plain */   mvt = fva; /* set mvt to 0 (fixed) or 1 (floating) */   val = expr;    subtree = val;    reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3);    regd = compute; /* compute VAL */   if subscr <> 0 then do; /* handle subscripted */       snode = x.get;        x.node (snode) = x.var;        x.arg1 (snode) = (shl(sclass, 8) or stype);       x.arg2 (snode) = subscr;        x.info (snode) = sinfo;       /* set up type and location */       call subscript (snode, val);  /* #############store VAL in subscripted variable */       call x.rel (snode); /* done with node */   end;   else  if  (x.node (val) = x.var)                     /* if node is variable  */   and       (x.arg1 (val) = (shl(sclass, 8) or stype)) /* of same class & type */   and       (x.info (val) = sinfo)                     /* at same location     */   then do;      /* do nothing if assignment of a=a since floating point blows up */   end;   else do;  /* emit assignment instructions */      if fva then do;         call float (val);     /* make sure floating if floating assignment */         ffregs = iffreg(val); /* get fixed point regs */      end;      else if (x.arg1 (val) and t.fvar) <> 0      then do; call er.fna; call fix (val); end; /* floating assigned to fix - warn user */      if pva then do;    /* pointer to floating variable, must load */         ireg = reg.allc (ffregs);    /* get another accumulator */         dreg = getvp (sclass, sinfo, ffregs or ireg);   /* now get pointer to variable area */         call emita (b.ms + dreg, b.rd + bitreg (ireg)); /* load pointer into accumulator. through with dreg now */         call freeup (ireg);       /* no trackable contents here */         dest = b.md + b.ibt + bitreg (ireg); /* compute destination */         call fsendit (val, dest, dest, ireg or ffregs); /* and store the value in location */      end; /* and REG.FREE is all set */      else do;   /* regular item */         if fva then do; /* floater */            dreg = getvp (sclass, sinfo, ffregs); /* get pointer to variable area */            dest = b.md + b.ibt + dreg;        /* pointer */            call fsendit (val, dest, dest, ffregs or regbit(dreg));    /* store same */            regl = (regl or regbit (dreg)); regc (dreg) = regc (dreg) + 2; /* it was incremented */         end;         else do;            dreg = getvp (sclass, sinfo, regd); /* get pointer to variable area */            call sendit (val, b.md + dreg, regd or regbit(dreg)); /* store result */         end;      end;      /* delete optimizing tree entries that refer to this variable */      /* since it's value has now changed                           */      d1 = 1; /* start with AC0 */      do i = 0 to b.amsk; /* see if any saved register affected by this var */         xinfo = trees (d1);         if xinfo <> 0 then do; /* check contents */            if tree.var (xinfo, sclass, sinfo) then call freeup (d1);         end;         d1 = shl(d1, 1);      end;      if fva = 0 then do; /* if scalar fixed point, indicate reg contains var */         if x.node (val) = x.reg then do; /* yes - record it */            d1 = x.info (val); /* which reg */            call freeup (d1);            xinfo = x.get; /* get block */            x.node (xinfo) = x.var; x.arg1 (xinfo) = (shl(sclass, 8) or t.var); x.info (xinfo) = sinfo;            trees (d1) = xinfo; /* this register contains a variable now! */         end;      end;   end; /* of non-arrays */   call x.rel (val); /* and done with VAL block */end; /* of handling assignment *//* $$Statement scanner - other statements: */ else if (token and 255) = t.stmt then do; /* statement */ call gc; /* skip over this token */ sinfo = shr(token, 8); /* get it */ do case (sinfo); /* branch on statement type *//* Statement scanner - CALL statement: */  do;call scanc; /* ignore any junk from pass1 */subtree = expr; /* get expression from intermediate file */reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any reg */ call compute; /* this forces calling the procedure */reg.free = (reg.free or b.ac0 or b.ac1); /* just in case of a floating result */ call x.rel (subtree); /* and the block */end; /* Statement scanner - RETURN statement: */ do;  if gc <> 0 then do;   /* means was an expression */    mvt = gc;           /* get type to return - T.VAR or T.FVAR */    reg1 = mvt;         /* save for later too */    call scanc;         /* check for line number */    subtree = expr;     /* scan arithmetic expression */    reg.pref = b.ac0;   /* try to get it into AC0 */    call compute;       /* compute it */    fva = (x.arg1 (subtree) and t.fvar) <> 0;    if reg1 = t.var then do;   /* must return fixed */      if fva then do; call er.fna; call fix (subtree); end;      call in.reg (subtree, not b.ac0); /* get SUBTREE in reg */      reg.free = (reg.free or b.ac0);    end;    else do;      call float (subtree); /* make sure a floater */      call fin.reg (subtree, not b.ac0); /* and answer in AC0 */      reg.free = (reg.free or b.ac0 or b.ac1);    end;    call x.rel (subtree); /* release block */  end;  call em.tra (0, gc); /* emit location to jump to */end; /* $$Statement scanner - PROCEDURE definition:..   To process a procedure definition, a 5 word block of keys is.   allocated.  These are used to process:.     key + 0 = the entry location for the proc.     key + 1 = the jump around location.     key + 2 = the return location.     key + 3 = a bit encoded word indicating which registers used by proc.     key + 3 (in KEYJTO) = NOSWAP bitlist and code size for swapping procs.     key + 4 = stack frame size.     key + 4 (in KEYJTO) = temp start for recursive procs only*/ do;call pushv; /* push REGL, REGU, and zero them */call pushr; /* push registers onto stack */call regzap; /* empty out all registers */call accpurg;zflags = 0; /* no ZFLAGS set on entry */regl = 0; /* but we really did not load them */call pushtemp; /* push and zero temp list ptrs */call push (in.recursive); /* save recursive flag */temp = gc;       /* pick up starting ram location put there by pass1 */prockey = gc;    /* and get N word block of keys for this procedure def */pbits = gc;      /* pick up procedure attribute bits */if (pbits and p.swap) <> 0 then do; /* if swappable proc, restart CUR.LOC */   swaploc = cur.loc; /* save CUR.LOC */   cur.loc = 0;       /* and reset to zero */end;reg.arg = gc;    /* get number of register arguments passed */if (pbits and p.recursive) <> 0 then do; /* recursive proc? */   in.recursive = prockey; /* flag a recursive proc with the proc's key */   i = reg.arg;            /* and pass on all args */   temps = 0;              /* start of temps is meaningless here */   sclass = s.automatic;   /* args are on stack */end;else do; /* not recursive */   in.recursive = 0;       /* not in a recursive proc */   i = 0; temps = ram;     /* don't pass any args on to pass3; temps at RAM */   sclass = s.static;      /* args are static */end;call em.pdf (prockey, reg.arg, temp, temps, pbits, i); /* emit procedure definition */do i = 0 to reg.arg - 1;     /* emit appropriate store instructions */   temp = gc;                /* get location of variable            */   if ((in.recursive <> prockey) or (i < 3)) then do;  /* register three gets trashed by recursive procs */      xinfo = x.get;       x.node (xinfo) = x.var;       x.arg1 (xinfo) = (shl(sclass, 8) or t.var); /* indicate reg */      x.info (xinfo) = temp;       trees (regbit (i)) = xinfo; /* contains arg */   end; /* of make sure we remember the registers we know about */   if in.recursive <> prockey then do;   /* if not defining a recursive proc */      temp = getvp (s.static, temp, 0);  /* and get variable pointer to location */      if i = reg.arg - 1 then call emita (b.rs + i, b.md + temp); /* no incre if final argument */      else do; /* use increment bit only on the first ones, so it ends up pointing to something useful (hopefully) */         call emita (b.rs + i, b.md + b.ibt + temp); /* use inc here */         regc (temp) = regc (temp) + 1; /* and keep track */      end;   end; /* of not in recursive proc */   else call emit (temp); /* pass location through to pass three for recursive procs */end; /* of emit appropriate stores */if in.recursive = prockey then do; /* are we defining a recursive procedure? */   call push (ram); /* save the current size of ram */   ram = temp.base; /* reset ram pointer for temporary allocation */end; /* of defining a recursive proc *//* scan statement list */ call push (pbits); /* save procedure bits */call push (prockey);call stmt.list;prockey = pop;pbits = pop; /* restore proc bits */dswp = gc; /* pick up NOSWAP bit list for data statements */temp = gc; /* pick up final ram location to toss dcl's in proc def */temps = gc; /* pick up stack length/temp offset */call em.lde (prockey + 2); /* emit label definition for 'return' */if in.recursive = prockey then do; /* are we ending a recursive proc? */   slen = temps + (ram - temp.base); /* compute stack length (add in space used for temps) */   if slen <> 0 /* if non-zero stack length */   then regl = (regl or regbit ("11")); /* yes, save R11 to use entering proc */   ram = pop; /* restore next ram location */end; /* of recursive proc */else do; slen = temps; temps = ram; end; /* not in recursive - get temp end */in.recursive = pop; /* restore recursion flag */call em.pen (prockey, temp, temps, slen, regl, dswp); /* emit end of procedure */ if (pbits and p.swap) <> 0 then cur.loc = swaploc; /* reset CUR.LOC at end of swappable proc *//* release temporaries */ call freetemp;call poptemp; /* and pop temps from stack */ /* restore index registers */ call popr; /* restore regs */regu = pop; regl = pop; /* and restore REGU, REGL, without changing */call accpurg; /* indicate accumulators free now */zflags = 0;end; /* procedure statement */ /* Statement scanner - BEGIN statement: */ do;   call scanc; /* check for line numbers, etc. */   call stmt.list; /* get a list of statements followed by 'END' */end; /* $$Statement scanner - DO statement: */ do;   insert ':xpl611:p2-do';end; /* of do statememt *//* Statement scanner - IF statement: */ do;  call pushv;     /* save zero, REGU, REGL */  call scanc;     /* for lnums */  subtree = expr; /* pick up EXPR from interfile */  call xcomset;   /* set up for XCOMPUTE call */  call xcompute;  /* compute jump instructions */  call xcomchk;   /* handle case of no jump; set REGU = REGL = 0 if so */  call xcompv;    /* push REGU, REGL as of first jump instruction */  call e.rel (subtree);   /* done with tree */  call donewith (truel);  /* done with this - locate it if we jumped here */  call push (regl);       /* save regs loaded during exp after first jump */  call pushr;             /* sav regs for else; REGL regs are cleared below */  call push (falsel);     /* save exit location for later EM.ALD */  call scanc;             /* check for lnums */  call stmt;              /* scan 'THEN' clause */  call sreg;              /* save what registers were at end of IF */  falsel = pop;           /* restore false location */  call popr;              /* sav regs at start of IF in case there is an ELSE clause */  call regclr (pop);      /* clr regs loaded during exp aftr first jmp */  call pushv;             /* save and zero REGL, REGU for ELSE clause */  token = peek;           /* see if ELSE */  if token = t.else then begin;  /* check if there is an 'ELSE' clause */    dcl jelse fixed;             /* for exit */    call gc;                     /* skip over T.ELSE token */    jelse = galt;                /* get key */    call em.atr (0, jelse);      /* and jump from out of true to after ELSE */    call donewith (falsel);      /* and locate FALSEL here if any body jumped to it */    call push (jelse);           /* and push this for later DONEWITH */    call stmt;                   /* scan ELSE clause */    falsel = pop;                /* and restore this - is actually jump from out of ELSE */  end;  else call lreg; /* if no ELSE, get regs at end of IF */  regu = (regu or pop);    /* regs used by true or false statement */  regl = (regl or pop);    /* regs loaded by true or false part */  call donewith (falsel);  /* and locate FALSEL here if we did jump to it */  call popv; /* and update the upper level of REGU, REGL */  call popv; /* and now include those used during initial expr XCOMPUTE */end; /* $$Statement scanner - GOTO statement: */ do;call em.tra (0, gc); /* jump to key passed from pass1 */call scanc; /* and check for lnums here */end; /* Statement scanner - interrupts: */ do; /* ion */call emitc (-"10", b.rd + "14"); /* load R14 with bits to turn on interrupts when written to D1 */call emita (b.rs + "14", 1); /* and send to device 1 */zflags = 0; /* ZFLAGS garbled here */end; do; /* ioff */call emitc (-"20", 1); /* turn off interrupts with write to device 1 */call emitc (-"20", b.rd + "14"); /* and put same in register for sub call */zflags = 0; /* ZFLAGS trashed */end; /* Statement scanner - STOP: */ do; /* STOP stmt */if gc = 0 then call emita (0, 0); /* just stop */else do; /* stop expr */call scanc; /* check for line numbers here */subtree = expr; /* scan expr */reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any one */mvt = 0; /* fixed */call compute; /* compute expr */call fix (subtree); /* fix it up */call sendit (subtree, 0, 0); /* send the subtree to device 0 for halt */call x.rel (subtree); /* done */end; /* of stop */end; /* of stop stmt */ /* $$Statement scanner - WRITE and LINPUT: */ do; /* write */call scanc; /* ignore lnums here */wdes = expr; /* scan complete expression for address */call scanc; /* check line number */val = expr; /* scan value */mvt = 0; reg.pref = b.ac1; subtree = val; call compute; /* compute VAL */mvt = 0; reg.pref = b.ac0; subtree = wdes; call compute; /* compute WDES */call fix (val); call fix (wdes);if x.node (wdes) = x.const then do; /* constant - zap accum */sinfo = x.info (wdes); /* get it */call sendit (val, sinfo, 0); /* send to dest */if ((sinfo >= b.ad) and (sinfo < b.td)) /* if arithmetic */or ((sinfo >= b.bsor) and (sinfo <= b.rd + "3")) /* or special arithmetic or direct to accumulator */or ((sinfo >= b.md + b.ibt) and (sinfo <= b.md + b.ibt + "3")) then do; /* or memory register then increment on an accumulator */  call freeup (regbit (sinfo and "3")); /* free up the specified accumulator (we no longer know what's in it) */  if sinfo < b.rd then zflags = 0; /* if arithmetic, we no longer know about the ZFLAGS */end; /* of accumulator */else if ((sinfo >= b.rd + min.ptr.reg) and (sinfo <= b.rd + max.ptr.reg)) /* direct to variable pointer? */     or ((sinfo >= b.md + b.ibt + min.ptr.reg) and (sinfo <= b.md + b.ibt + max.ptr.reg)) /* or memory register then increment on a VP */then call regclr (regbit (sinfo and "17")); /* zap that variable pointer */end;else do; /* write to variable - compute it */call in.reg (wdes, not b.ac0); call in.reg (val, not b.ac1); /* get args in register */call reg.allc (not b.ac2); call reg.allc (not b.ac3); /* should be free anyways */call em.rtp (l.sbw); /* and special write */reg.free = (reg.free or b.ac0 or b.ac1); /* and done */call accpurg; zflags = 0; /* zap the accumulators (they are used by L.SBW) */end;call x.rel (wdes); call x.rel (val); /* done */end; /* write */ do; /* LINPUT statement */   call scanc; /* clean up */   stype = gc; sclass = gc; sinfo = gc; /* get type, class, and location of array */   if stype = t.arr then do; /* array */      if sinfo = 0 /* CORE? */      then call emitc (0, b.rd); /* LINPUT core; */      else call sendvp (sclass, sinfo, b.rd + 0, 0); /* else array ptr in reg 0 */   end;   else if stype = t.parr then do; /* ptr to array */      reg1 = getvp (sclass, sinfo, 0); /* get pointer to array pointer */      call emita (b.ms + reg1, b.rd + 0); /* and get that in AC0 */   end;   else do; /* must by 'LOCATION' */      call compute.to.reg0;   end;   call em.rtp (l.sin); /* and get string input */   call accpurg; /* and indicate registers free now */end; /* of linput *//* $$Statement scanner - INPUT, PRINT, SEND: */ do; /* input */   call scanc; /* clean up */   call regzap; /* and we enter with any registers */   call accpurg; /* garbage regs on restart */   call em.rtp (l.ipr); /* prime the input buffer */   zflags = 0;   do while (gc <> 0); /* and scan down list of arguments */      call stmt; call scanc; /* scan off T.ASSIGN and assign to variable */   end;   call em.rtp (l.idn); /* done with input */   call accpurg; /* indicate registers free */end; /* of begin */ call pstmt; /* for PRINT - call subroutine */ call pstmt; /* for SEND - call subroutine */ do; /* WHEN statement */   prockey = gc; /* get key def */   call pushv; call pushr; call regzap; regl = 0; /* protect variables, clean registers, etc. */   call pushtemp; /* push temp ptrs onto stack; zero them */   call accpurg; /* empty accumulators */   zflags = 0;   call em.whn (prockey); /* emit WHEN statement definition */   call push (prockey);   call stmt; /* and scan the WHEN statement */   prockey = pop;   call freetemp;   call poptemp; /* and poptemps off stack */   call em.wen (prockey, regl); /* emit end of WHEN statement */   call accpurg; /* indicate empty registers now */   zflags = 0;       call popr; /* restore registers from jump around procedure definition */   regu = pop; regl = pop; /* and restore used, loaded indicater flags */end; /* of when */do; /* INVOKE statement */   call compute.to.reg0; /* get exception handler into register zero */   call em.rtp (l.brk); /* and call the break routine */   call accpurg; /* zap all accumulators (like a CALL) */end; /* of invoke */do; /* MODULE statement */   call em.mod (gc); /* emit the module statement */   call stmt.list; /* scan for list followed by 'END' */end; /* of module */do; /* LIBRARY statement */   call em.lib (gc); /* emit the LIBRARY statement */end;do; /* INSERT statement */   call em.ins (gc); /* emit the INSERT statement */end;do; /* DECLARE statement */   call gc; /* get type (only DATA allowed currently) */   call em.dat (gc); /* should be data defn */end; /* of declare */end; /* of do case for stmt types */end; /* of statement found */ /* Statement scanner - clean up: */ else do; /* file error!! */   print;   print '### Compiler system error in pass 2 (', line.no, ', ', token,')';   call exit(-1);end;call scanc; /* skip final junk */if reg.free <> (b.ac0 or b.ac1 or b.ac2 or b.ac3)then call er.cerr ('end STMT');alias_ptr = 0; /* after statement is finished, there are no more aliases */ end stmt;