/* Special storage areas:.  .   The compiler uses storage areas for the construction of the symbol.   table, expression trees, and other information..  .   The following arrays are used: */  /* 4/14/89 - cj - fixed signed comparison for s.names.used to get *//*                reloc statistics printout correct               */dcl com (maxcomm)      fixed; /* set up communications area */dcl store1 (#blocks)   fixed; /* storage area one       */dcl store2 (#blocks)   fixed; /* symbol table pointers  */dcl store3 (#blocks)   fixed; /* and expression trees   */dcl store4 (#blocks)   fixed;dcl name (max_sym_len) fixed; /* current symbol/string constant */dcl catname (64)       fixed; /* current catalog name           */dcl fstk (fstklen - 1) fixed; /* floating point constants       */dcl istk (istklen)     fixed; /* insert file stack area         */dcl hashtab (hashsize) fixed; /* and this is hash table start   */dcl hashdep (hashsize) fixed; /* hashed depths are stored here  */dcl stack_length       fixed; /* length of stack frame          */  dcl cfname (f#name_len) fixed; /* current insert file name       */dcl cfnmes (5)          fixed; /* when in insert, ' in file '    */dcl in.fmes             data (' in file '); /* smae length as CFNMES */dcl ersymb (16)         fixed; /* symbol name during error       */dcl aliases (alias_len - 1)  fixed; /* array formal parameter/actual parameter aliases */dcl handles (handle_len - 1) fixed; /* handles into ALIASES */dcl mod.scanned    fixed; mod.scanned = 0; /* true if we're compiling a relocatable module */dcl in.begin       fixed; in.begin = 0; /* levels of BEGINs we're down (differentiates level changes due to BEGINs from PROCs) */dcl public_procs   boolean; public_procs = false; /* TRUE if all procs should be forced PUBLIC */  dcl token      fixed; /* holds current token type    */dcl info       fixed; /* global information variable */dcl depth      fixed; /* depth of current token      */dcl ufsp       fixed; /* pointer to undefined symbol */dcl name.pt    fixed; /* pointer to symbol table     */dcl dcl.symbol fixed; /* TRUE if we're scanning a variable name in a DCL statement */dcl line.no    fixed; /* current line number */dcl plineno    fixed;dcl numerrs    fixed;dcl stptr fixed; /* symbol table pointer    */dcl ptptr fixed; /* procedure table pointer */ dcl cur.proc.def fixed; cur.proc.def = -1; /* current procedure definition */dcl cur.proc.dpt fixed; /* depth of current procedure - GOES when ER.CRG goes */dcl data_key     fixed; /* key for data statement */dcl #stmts       fixed; #stmts = 0; /* # of statements parsed *//* file input/output global variables */  dcl sfbuf (sfbufl - 1) fixed; /* source file buffer */dcl ifbuf (ifbufl - 1) fixed; /* and intermediate file buffer */  dcl (sfdev, sfstart, sflngth) fixed; /* source file info */dcl (ifdev, ifstart, ifsecln) fixed; /* intermediate file length info */  dcl sfpos fixed; /* source file buffer position */dcl sfsec fixed; /* source file current sector (next one to read) */dcl sfflp fixed; /* and word equivalent of SFSEC */  dcl ifpos fixed; /* intermediate file buffer position         */dcl ifsec fixed; /* intermediate file sector counter          */dcl ifofs fixed; /* starting position of output file in .WORK */  dcl word  fixed; /* current word (insert processing) */dcl bc    fixed; /* and byte toggle */  dcl readl fixed; /* length to read *//* File input/output subroutines:.  .   The following routines are used to read and write data from the various .   source, intermediate, and runtime package files.  These routines .   facilitate the reading of files on a byte-by-byte basis and using .   our own controlled buffer sizes...   Read character from source file:.  .   The routine 'GC' is called to get the next character from the.   source file.  It will return the next 8-bit character (extracted.   from the 16-bit NEDCO machine word).  If an end of file.   condition is encountered, a value of '-1' will be returned..  .   The processing of insert files is done by the statement scanner.   ('STMT' processes the INSERT statement) and the scanner ('SCAN'.   detects the end-of-file condition of an inserted file).  As such,.   The 'GC' procedure does not differentiate between the end of the.   main source file and the end of an insert file. */  gc: proc; /* procedure to get next character */   dcl i fixed;   if bc = 0 then do; /* must get next word */      if sfflp = sflngth then return (-1); /* end of file */      if sfpos = sfbufl then begin; /* add - get buffer */         sfsec = sfsec + (sfbufl/256); /* incr length */         readl = sflngth - sfflp; if readl igt sfbufl then readl = sfbufl;         i = 0; if sfstart + sfsec ilt sfstart then i = 1; /* determine MS sector offset */         call readdata (sfdev + i, sfstart + sfsec, sfbuf, readl); /* get it all */         sfpos = 0; /* zero pointer */      end;      word = sfbuf (sfpos);      sfpos = sfpos + 1; /* incr it */      sfflp = sfflp + 1; /* increment file position */      bc = 1; /* set toggle */      return (word and "377");   end;   bc = 0;   return (shr(word, 8));end gc;  /* Intermediate and object file:.  .   The routines 'EMIT' and 'WRITEOBJ' are used to write data to the.   intermediate file and the object file, respectively..  .   Both the intermediate file and the object file are (except for one case).   written sequentially.  Therefore, each routine is passed the word.   which should be appended to the appropriate file..  .   The specified data word is passed as a fixed point argument to both .   routines.*/  ifforce: proc;   dcl (ms, ls) fixed;  if ifsec ige ifsecln then do; /* out of interfile space */    print;    print 'Program too large (interfile1).';    call exit(-1);  end;  ms = ifdev;  ls = ifstart + (ifsec + ifofs);  if ifsec + ifofs ige ifsecln /* need to wrap around? */  then ls = ls - ifsecln; /* wrap around */  if ls ilt ifstart then ms = ms + 1; /* carry (IFSEC + IFOFS - IFSECLN < 64K) */  call writedata (ms, ls, ifbuf, ifpos); /* write out data */  ifsec = ifsec + shr(ifbufl, 8); /* increment ptr */  ifpos = 0; /* and pos = 0 */end ifforce;  emit: proc(word); /* emit word to file */  dcl word fixed;  if ifpos = ifbufl then call ifforce; /* force it out */  ifbuf (ifpos) = word; /* store in buffer */  ifpos = ifpos + 1;end emit; lchk: proc; /* call to make sure line number is passed to pass2 */ dcl lastnum fixed; /* last line number emitted to file */ if lastnum <> line.no then do; /* write line number if new */   call emit (t.lnum);   call emit (line.no);   lastnum = line.no; end;end lchk;/* The symbol table (STABLE) can reside in either internal or external.  memory.  It is initially placed in internal memory.  The routine INIT.  decides if it can be moved to external memory and moves it if so...  The following routines are use to access the symbol table (STABLE). */  dcl xmem fixed; xmem = 0; /* set to one if STABLE is in external memory */stable: proc(index) fixed; /* return the contents of array cell STABLE (index) */   dcl index fixed; /* index into STABLE array */   if xmem then do; /* if STABLE is in external memory */      write(mam) = stab.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      return (read (md)); /* return the element */   end;   else return (core(stab.ptr + index)); /* it's in main memory */end stable;set_stable: proc(index, value); /* set the contents of array cell STABLE (index) to VALUE */   dcl index fixed; /* index into STABLE array */   dcl value fixed; /* value to set element to */   if xmem then do; /* if STABLE is in external memory */      write(mam) = stab.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      write(md)  = value; /* set the element to VALUE */   end;   else core(stab.ptr + index) = value; /* it's in main memory */end set_stable;/* The following procedures are used to print error messages on the terminal. */er.symb: proc(ptr); /* select a ersymb from tabl and put in 'ERSYMB' */dcl ptr fixed;dcl (i, j, k) fixed;i = (stable (ptr + s.tokn) and 255); /* get number of words in symbol */if i > 16 then i = 16;  /* and limit for ersymb          */ersymb (0) = shl(i, 1); /* and number of bytes to print  */do i = 1 to i;ersymb (i) = stable (ptr + s.text + i - 1);end;end er.symb;  er.emes1: proc(str, ptr); /* format one - for undef/dupl ersymb */dcl str array;  dcl ptr fixed; /* ptr to aray */  dcl pptr fixed; /* and only once per message */  trmst = -1; /* abort compilation */  if pptr = ptr then return; /* have already prited this one */  pptr = ptr; /* this is latest one printed */  call er.symb (ptr); /* extract ersymb into 'ERSYMB' */  print string(str), ' ''', string(ersymb), ''' at line', line.no, string(cfnmes), string(cfname);  numerrs = numerrs + 1;  if numerrs > max_errs then call exit(-1); /* an obviously fatal compilation */end er.emes1;  er.ufls: proc(ptr); /* undefined label/ersymb message */  dcl ptr fixed;  call er.emes1 ('Undefined symbol', ptr);end er.ufls;  er.lt: proc(ptr); /* duplicate - defined twice */  dcl ptr fixed;  call er.emes1 ('Duplicate definition for', ptr);end er.lt;  er.msub: proc(ptr); /* missing subscript */  dcl ptr fixed;  call er.emes1 ('Missing subscript for', ptr);  plineno = line.no;end er.msub;  /* Error messages, continued: */  er.emes2: proc(str); /* pass message string */  dcl str array;  trmst = -1; /* abort compilation */  if token = t.und then call er.ufls (ufsp);  if plineno = line.no then return; /* one per line */  plineno = line.no; /* save - only one useless message per line */  print string(str), ' at line', line.no, string(cfnmes), string(cfname);  numerrs = numerrs + 1;  if numerrs > max_errs then call exit(-1);end er.emes2;    er.sctl: proc;call er.emes2 ('String constant too long');end;er.map: proc; call er.emes2 ('Missing apostrophe');end;er.tmd: proc; call er.emes2 ('Too many digits in number');end;er.ntc: proc; call er.emes2 ('Nested or non-terminated comment');end;er.iptd: proc;call er.emes2 ('Improper type declaration');end;er.rna: proc; call er.emes2 ('RETURN statement not allowed');end;er.tme: proc; call er.emes2 ('Too many END statements');end;er.ifnc: proc;call er.emes2 ('Incorrect format in number');end;er.ifm: proc; call er.emes2 ('Incorrect format');end;er.nea: proc; call er.emes2 ('Not enough arguments supplied');end;er.tma: proc; call er.emes2 ('Too many arguments supplied');end;er.atdnm: proc;call er.emes2 ('Argument types do not match');end;er.me: proc;  call er.emes2 ('Missing END statement');end;er.ms: proc;  call er.emes2 ('Missing semicolon or format error');end;er.nm: proc;  call er.emes2 ('END label does not match');end;er.cr: proc;  call er.emes2 ('Expression not allowed');end;er.irec: proc;call er.emes2 ('Improper recursion');end;er.naad: proc;call er.emes2 ('Undeclared procedure argument');end;er.dupw: proc;call er.emes2 ('Duplicate ''WHEN'' statement');end;er.fpna: proc;call er.emes2 ('Floating point not allowed in data list');end;er.tmnc: proc;call er.emes2 ('Too many numeric constants');end;er.nst: proc; call er.emes2 ('Out of symbol table storage');call exit(-1);end;er.etc: proc; call er.emes2 ('Expression too complicated');call exit(-1);end;er.tmb: proc; call er.emes2 ('Too many nested ''BEGIN'' statements');call exit(-1);end;er.tmni:proc; call er.emes2 ('Too many nested insert files');call exit(-1);end;er.tmed:proc; call er.emes2 ('Too many externals declared');call exit(-1);end;er.tmpl:proc; call er.emes2 ('Too many procedures/labels');call exit(-1);end;er.tmc: proc; call er.emes2 ('Too many constants');call exit(-1);end;er.wna: proc; call er.emes2 ('''WHEN'' not allowed in procedure');end;er.sna: proc; call er.emes2 ('Subscript not allowed');end;er.ftm: proc; call er.emes2 ('File type mismatch');call exit(-1);end;er.mtn: proc; call er.emes2 ('No treename specified');end;er.cat: proc; call cat_err; call er.emes2 ('');end;er.atm: proc; call er.emes2 ('Argument type does not match previous proc defn');end;er.ram: proc; call er.emes2 ('Recursive attribute doesn''t match forward ref');end;er.pbna: proc;call er.emes2 ('Neither public nor swapping procs can be nested');end;er.mnfs: proc;call er.emes2 ('''MODULE'' must be the first statement of a library');end;er.mms: proc; call er.emes2 ('Multiple ''MODULE'' statements not allowed');end;er.somb: proc;call er.emes2 ('Statement outside of module body');call exit(-1);end;er.mnim: proc;call er.emes2 ('Module name is missing');end;er.crg: proc; call er.emes2 ('Cannot reference global automatic variable');end;er.ptl: proc; call er.emes2 ('Program too large (variable space exceeds maximum)');call exit(-1);end;  wa.wmes: proc(str); /* pass message string */  dcl str array;  if plineno = line.no then return; /* if an error already on this line, skip warning */  print 'Warning: ', string(str), ' at line', line.no, string(cfnmes), string(cfname);end wa.wmes;wa.pdip: proc; call wa.wmes ('public variable declared inside a proc');end;wa.oda: proc; call wa.wmes ('overwriting contents of data array');end;  /* Storage allocation:.  .  Many routines need allocatable fixed length blocks.  Since they.  all want four word blocks, these blocks are all allocated out of.  the same arrays.  The blocks consist of one entry in each of four.  separate arrays.  To keep the different uses distinguishable, any.  routines using these arrays should declare their own names for them.  and also rename the storage allocation routines.  Note that the block.  with index zero is never used.  This means that zero as a link may.  be used to indicate the end of a list.  */ dcl free fixed; free = 1; /* ptr to free, start here */dcl free.end fixed;dcl blocks.in.use fixed; /* Runtime initialization of free storage -- links up (as free storage).  all blocks with index greater than or equal to the initial value of.  'FREE'.  This permits using some of the blocks initially.  */ store1 (free) = 0; /* zero indicates end of list */free.end = free;do free = free + 1 to #blocks;store1 (free) = free - 1;end;free = #blocks; /* get a block from free storage */ get: proc;  dcl block fixed;  block = free;  if block = 0 then call er.etc;  else free = store1 (block);  blocks.in.use = blocks.in.use + 1;  return block;end get; /* return a block to free storage */ rel: proc(block);  dcl block fixed;  store1 (block) = free;  free = block;  blocks.in.use = blocks.in.use - 1; /* decrement */end rel;  /* Keys:.  .   There are two types of symbols that identify locations within a program: .     statement labels (used with GOTO), and.     procedures (activated by a CALL statement)...   When a label or procedure is defined, a unique number (starting with 1) is.   assigned to that label or procedure.  This number is then used to identify.     a. the destination of a GOTO,  or .     b. the destination of a CALL...   The procedure 'GKEY' is used to allocate the next unique number, .   hereinafter referred to as a 'NEXKEY'..  .   Alternate keys are used in a similar way to provide expansion of the.   number of keys possible beyond 16 bits.   Alternate keys are used.   in the same way keys are,  but are restricted to certain intermediate.   file record types (et.atr and et.ald as of 10/24/90). */gkey: proc; /* used to get a key */  nexkey = nexkey + 1; /* incr key */  if nexkey ige shr(extern.base, 1) then call er.tmpl; /* did we collide with the externals? too many procs/labels */  return (nexkey); /* note that zero is never returned */end gkey;galt: proc; /* used to get an alternate key */  altkey = altkey + 1; /* incr alt key */  if altkey ige shr(extern.base, 1) then call er.tmpl; /* did we collide with the externals? too many procs/labels */  return (altkey); /* note that zero is never returned */end galt;/* Variable and constant locations:..  All variable and constant area locations are assigned by pass1.  These.  locations are all relative to the variable area base and the constant.  area base for the program/module being compiled.  The variable area.  is assigned from RAM, the constant area from STR.DATA.  Public variables.  are intermixed with local/internal variables...  External variables must be relocated in pass3 so that they point to.  the area of storage defined by their public counterparts.  If these.  were to be allocated during pass1, "holes" in the variable area would.  be created during pass3 relocation (since externals are only references.  and do not require allocated storage) which would need to be removed..  This would not be a problem except that pass2 does its register.  optimization under the assumption that all variables are located.  in their proper "relative" locations by pass1.  We need to assign.  SOME location/identifier/key so we can identify externals for relocation.  during pass3.  Therefore, externals are given their own address space.  from EXTLOC.  GET_EXTLOC is called to return the next unique number.  from this address space.  The first EXTLOC is EXTERN.BASE.  Note that.  the formal parameters of an external procedure are external variables...  EXTERN.BASE is currently 60K.  This is because no program (and hence no.  RAM location can exceed 60K and still work.  Ideally, EXTERN.BASE should.  be (to minimize collisions for any maximum RAM size less than 64K):.    (64K - (maximum.external.symbols.pass3.allows*average.number.of.procedures.per.file)). */get_extloc: proc fixed; /* get next unique external tag */   extloc = extloc + 1; /* get the next unique tag */   if extloc = 0 then call er.tmed; /* did we wrap around? too many externals declared */   return (extloc); /* return next location */end get_extloc;/* Stack definitions and routines:. .  The stack is used for any important parameters during any of the.  recursive routines in the compiler.  This is true not only for the.  recursive descent scanning routines, but also, for example, for the.  recursive expression compiler.  */ dcl stack (stacksize) fixed;dcl stackpt           fixed; /* pointer to stack */ /* stack push and pop routines */ push: proc(info); dcl info fixed; if stackpt > stacksize then call er.etc; stack (stackpt) = info; stackpt = stackpt + 1;end; pop: proc;  stackpt = stackpt - 1;  return stack (stackpt);end;  /* Symbol table storage:.  .   The symbol table forms the heart of pass1 of the compiler.  A single 16-bit.   table is used.  The table is used at both ends (one going up, the other going.   down) so that when it does run out of storage, there is absolutely none left..  .   ******** Description of Symbol Table Entries *********..   Two fixed point arrays are used for symbol processing:  HASHTAB and STABLE..  .   Assume the existence of a symbol 'XYZ'.  A seven-bit hash table pointer is.   computed from the ASCII values of the symbol characters.  This pointer.   is used as an index into the array 'HASHTAB'.  The contents of.   HASHTAB (<pointer>) is a pointer in the STABLE array..  .   The STABLE array consists of two parts - a lower section growing up and.   an upper section growing down.  The lower section is the main section..  .   The lower section of the symbol table contains records.  There are.   two types of records:  symbol table entries and literal strings...   For each symbol, there is a symbol table entry record in STABLE..   This record looks like:..      word 0: 16-bit forward pointer to next bucket on this.              hash linked list..      word 1: 8-bit data key/4-bit storage class/4-bit symbol depth field..      word 2: lower half contains the number of 16-bit words in character.              field of symbol (i.e. (number of characters in.              symbol plus one) divided by 2)..              upper half contains the token type of the symbol. .      word 3: 16-bit information regarding symbol (either a.              pointer into the variable area, or etc.).      words 4 and on: hold the ASCII characters, packed two to a word..  .  The following variables are used to process symbols: */dcl s.depth  fixed; /* level information         */dcl hashcode fixed; /* computed hash information */dcl (s.nl.stak, s.sl.stak, s.pdef) (s.depth.max) fixed; /* holds recursive info */s.pdef (s.depth) = cur.proc.def; /* no procedures at this level */ /* Symbol table management:  subroutines. .  Check if the symbol in 'NAME' is in the designated spot in S.NAMES: */ s.check: proc(pointer);  dcl (pointer, i, j) fixed;  i = (stable (pointer + s.tokn) and 255); /* extract length */  if i <> name (0) then return 0; /* length is not the same */  do j = 1 to i; /* and compare */    if name (j) <> stable (pointer + s.text + j - 1) then return 0; /* not equal */  end;  return 1; /* found */end s.check;  /* Routines to store/get certain fields from symbol record: */  gtok: proc(p); /* get token, pass pointer */   dcl p fixed;   return (shr(stable (p + s.tokn), 8));end gtok;  ptok: proc(p, token); /* store token; pass pointer, token */   dcl (p, token) fixed;   call set_stable (p + s.tokn, (stable (p + s.tokn) and "377") or shl(token, 8));end ptok;  gclas: proc(p); /* get storage class, pass pointer */   dcl p fixed;   return (shr(stable (p + s.clas), 4) and "17");end gclas;  pclas: proc(p, clas); /* store storage class; pass pointer, storage class */   dcl (p, clas) fixed;   call set_stable (p + s.clas, (stable (p + s.clas) and "177417") or shl(clas, 4));end pclas;  gdkey: proc(p); /* get data key, pass pointer */   dcl p fixed;   return (shr(stable (p + s.dkey), 8));end gdkey;  pdkey: proc(p, dkey); /* store data key; pass pointer, data key */   dcl (p, dkey) fixed;   call set_stable (p + s.dkey, (stable (p + s.dkey) and "377") or shl(dkey, 8));end pdkey;  gflag: proc(p); /* get procedure flags, pass procedure pointer */   dcl p fixed;   if ((p = -1) or (p = -2)) /* if at the top level or in WHEN */   then return (0); /* no flags */   else return (shr(stable (p + p.flag), 8));end gflag;  pflag: proc(p, flags); /* store procedure flags; passed procedure pointer & flags */   dcl (p, flags) fixed;   if not ((p = -1) or (p = -2)) /* if not at the top level and not in when */   then call set_stable (p + p.flag, (stable (p + p.flag) and "377") or shl(flags, 8));end pflag; /* Symbol table management:  symbol look-up routine */ /* S.LOOKUP:.   This procedure is used to look up a symbol in the table..   Upon entry, the symbol is stored in the global variable.   'NAME'.  The routine returns a pointer to the symbol.   or a zero in the case of a new symbol. */ s.lookup: proc;  dcl i fixed;  hashcode = name (0) + shl(name (1), 1) + shl(shl(name (name (0)), 2), 1); /* hash function */  hashcode = (hashcode and hashsize); /* hashing function */  name.pt  = hashtab (hashcode); /* get pointer into stable */  depth    = hashdep (hashcode); /* pick up first symbol's depth */  do while name.pt <> 0; /* and scan every symbol that exists on this link */    if s.check (name.pt) <> 0 then return name.pt; /* found - return pointer */    depth   = (stable (name.pt + s.dpth) and s.depth.max); /* extract next depth */    name.pt = stable (name.pt + s.next); /* extract next pointer */  end; name.pt = stptr; /* new symbol - store characters in table here so 'NAME' is free */depth = s.depth; /* defined (presumably) at current level */stptr = stptr + s.length + name (0); /* S.LENGTH words of info + number of words */if stptr igt ptptr /* check for overflow if equal, then ok */then call er.nst;call set_stable (name.pt + s.next, -1); /* indicate a new symbol here */call set_stable (name.pt + s.dpth, -1); /* zap depth field */call set_stable (name.pt + s.tokn, name (0)); /* save length field */do i = 1 to name (0);  call set_stable (name.pt + s.text + i - 1, name (i)); /* copy character info into table, because name gets used often */end;return 0; /* indicates a new symbol */end s.lookup; /* Symbol table management:  symbol definition routine */ /*  The S.DEFINE routine is used to enter a symbol entry into the.   symbol table.   Multilevel variable localization is incorporated..  .   S.DEFINE is passed two variables:  a pointer into the symbol table.   (NAME.PT) and a hash table pointer..  .  S.DEFINE returns a value that is a pointer into STABLE.  Note.  that the NAME.PT returned by S.DEFINE might be different than.  the NAME.PT passed to S.DEFINE, in the case of a localized.  redefinition of a variable. */  s.define: proc(name.pt, hashcode); /* pass then - note these are local variables!!! */  dcl (name.pt, hashcode) fixed;  dcl (i, j, k) fixed;  i = hashtab (hashcode); j = hashdep (hashcode); /* get forward ptr and depth for this bucket */  do while (i <> 0) and (j = s.depth); /* detect end of list */    if i = name.pt then return i; /* use this as pointer - defined on this level */    j = (stable (i + s.dpth) and s.depth.max); /* get depth */    i = stable (i + s.next); /* and get forward pointer */  end;    /* new symbol, at least on this level */    if stable (name.pt + s.next) <> -1 then do; /* if defined on earlier level, must duplicate ascii */    i = name.pt; /* save current pointer */    name.pt = stptr; /* and pointer to current end */    j = (stable (i + s.tokn) and 255); /* extract length of record */    stptr = stptr + s.length + j; /* increment pointer */    if stptr igt ptptr then call er.nst;    do k = 0 to j - 1; /* copy over ASCII info */      call set_stable (name.pt + s.text + k, stable (i + s.text + k));    end;    call set_stable (name.pt + s.tokn, j); /* save length, with a zero token field */  end;  call set_stable (name.pt + s.next, hashtab (hashcode)); /* pick up pointer to next guy */  call set_stable (name.pt + s.dpth, hashdep (hashcode)); /* and his depth */  call ptok (name.pt, t.und); /* indicate undefined */  hashtab (hashcode) = name.pt; /* store forward ptr in hash table */  hashdep (hashcode) = s.depth; /* and depth */  return name.pt;end s.define;/* Symbol table management:  localize and globalize routines */ /* S.BLOCK procedure:.  .   S.BLOCK is called at the beginning of a variable localization event.   (such as the start of a procedure definition).  The routine pushes.   the current symbol table pointers onto an internal stack and then.   increments the 'DEPTH' field. */ s.block: proc; s.nl.stak (s.depth) = stptr; /* save current symbol table pointer */ s.sl.stak (s.depth) = ptptr; /* save pointer for procedure arguments */ s.depth = s.depth + 1; /* increment depth count */ if s.depth > s.depth.max then call er.tmb; s.pdef (s.depth) = cur.proc.def; /* save pointer to procedure definition at this level */end s.block; /* S.ENDBLOCK procedure:..   S.ENDBLOCK is called at the end of every level of block definitions..  .   It is used to undeclare all variables, labels, and procedures that.   are defined on inner blocks.  Undeclared labels (forward reference).   are detected at this level also. */  s.endblock: proc; dcl (index, last, last_depth, token, info) fixed;   if s.names.used ILT stptr + (stsiz - 1) - ptptr then s.names.used = stptr + (stsiz - 1) - ptptr; /* stats */  do index = 0 to hashsize; /* wipe out all defs at this level */last = hashtab (index); /* pick up start pointer this bucket */last_depth = hashdep (index); /* and the depth */do while (last <> 0) and (last_depth = s.depth); /* scan defined symbols this depth */token = gtok (last); /* get token and info of symbol */info = stable (last + s.locn);if token = t.label then do; /* for label - make sure def'd */  if (info and 1) = 0 then call er.ufls (last); /* undefined */end;else if token = t.proc then do; /* for procedure - make sure located */  if (stable (info + p.key) and 1) = 0 then call er.ufls (last); /* undefined */end;last_depth = (stable (last + s.dpth) and s.depth.max); /* pick up depth of next symbol */last = stable (last + s.next); /* pick up pointer to next symbol */end;hashtab (index) = last; /* and save top pointer in hashtab */hashdep (index) = last_depth; /* and associated depth */end; s.depth = s.depth - 1; /* decrement depth count */stptr = s.nl.stak (s.depth);ptptr = s.sl.stak (s.depth); end s.endblock;/* Define an external or public type entry:..    This routine just outputs to the interfile a record.    which contains the name, the type (public or external).    and the local location used.  The linker in pass3 will.    fix up the rest. */pub.ext.def: proc(sptr, pub.ext, storage, lnum);  dcl sptr    fixed; /* pointer into symbol table */  dcl pub.ext fixed; /* T.EXTERN (external) or T.PUBLIC (public) */  dcl storage fixed; /* storage used by this            */  dcl lnum    fixed; /* line number of definition */  dcl (i, len, type, info, numargs) fixed;  if ((not mod.scanned) and (pub.ext = t.extern)) /* if we aren't a module and have external variables */  then flags = (flags or link.flag); /* better call linker */  type = stable (sptr + s.tokn); /* get type information */  info = stable (sptr + s.locn); /* and info             */  if ((shr(type, 8) = t.label) and (pub.ext <> t.extern)) /* externals are passed as is */  then info = shr(info, 1); /* but we need to discard the 'defined' bit for others */  len = 4 + (type and "377"); /* every block has symbol + misc */  if shr(type, 8) = t.proc then do; /* procedures have more */    numargs = stable (info + p.args);  /* get number of arguments   */    len = len + 3 + numargs + numargs; /* procedures have type info */  end;  else numargs = -1; /* no args if not a proc */  call emit (t.symref); /* t.symref       */  call emit (shl(pub.ext, 8) + len); /* flag / len     */  call emit (type); /* type / symlen  */  call emit (info); /* info if needed */  call emit (storage); /* storage used   */  call emit (lnum); /* line number    */  do i = 0 to (type and "377") - 1; /* copy over symbol text */    call emit (stable (sptr + s.text + i));  end;  if numargs <> -1 then do; /* procedures have more info */    if pub.ext = t.extern /* emit key location */    then call emit (stable (info + p.key)); /* external - defined bit is significant! */    else call emit (shr(stable (info + p.key), 1)); /* public - defined bit is extraneous */    call emit (stable (info + p.args)); /* # of args    */    call emit (stable (info + p.rtyp) and "377"); /* returns type */    do i = 0 to numargs - 1; /* emit two words for every argument */      call emit (stable (info + p.parm + p.ptyp - i - i) and "377"); /* type */      if (gflag (info) and p.recursive) <> 0 /* are we defining a recursive procedure? */      then call emit (recurs.parms + i); /* yes, variable location is canonical */      else call emit (stable (info + p.parm + p.ploc - i - i)); /* no, send out relative variable location */    end;  end; /* procedures have more info */end pub.ext.def;