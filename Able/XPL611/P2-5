/* Expression compiler - subroutines:.  .  The following subroutines are used to assist the compilation .  of arithmetic expressions..  .  The 'IFREG' routine examines a COMPUTEd (!!) node to see if it .  is in a register (X.REG or X.PREG).  This is used to assist in.  the assigning of registers for dyadic operations..  .  The "IFFREG" routine examines a COMPUTED FLOATING POINT node.  and returns bits for which FIXED POINT ACCUMULATORS (b.ac0, b.ac1,.  b.ac2, b.ac3) the node is stored in (if any)...  The 'MATCH' routine is used to check if the operands of two.  dyadic operators are the same type.  The operands must be.  COMPUTEd before calling MATCH..  .  MATCH floats the other argument if one is floating. */  ifreg: proc(node) fixed; /* pass node */   dcl node fixed;   if x.node (node)  = x.reg  then return (x.info (node)); /* is in register */   if x.node (node) <> x.preg then return (0); /* if not PREG, then arg is not in a register */   if (x.arg1 (node) and t.fvar) = 0 then return (x.info (node)); /* for fixed, register containing pointer */   else return (fprs (x.info (node))); /* else indicate which floating registers holds fixed pointer */end ifreg;  iffreg: proc(node) fixed; /* pass node */   dcl node fixed;   if x.node (node)  = x.reg  then return (ffpr(x.info (node)) or sfpr(x.info (node))); /* is in register */   if x.node (node)  = x.preg then return (x.info(node));   return 0;end iffreg;match: proc(arg1, arg2) fixed; /* check types */   dcl (arg1, arg2) fixed;   if (x.arg1 (arg1) and t.fvar) <> 0 then do; call float (arg2); return (1); end;   if (x.arg1 (arg2) and t.fvar) <> 0 then do; call float (arg1); return (1); end;   return (0); /* both args are fixed */end match;freemul: proc; /* routine to free up the mul/div */  call push (reg.pref); /* save these */  if d4used = 1 then do; /* preserve d4 */    reg.pref = x.arg2 (d4block);    call in.reg (d4block, 0); /* get in any register */  end;  if d5used = 1 then do; /* preserve d5 */    reg.pref = x.arg2 (d5block);    call in.reg (d5block, 0); /* get in any reg */  end;  reg.pref = pop;end freemul;  /* LLLExpression compiler - compute subtree:. .   This routine compiles code to compute the expression represented.   by the tree passed to it in 'SUBTREE'.  It leaves the node in such.   a state that the argument may actually be loaded into a register.   by simply calling 'IN.REG'.  This routine destroys the subtree while.   compiling code.  If it actually returns the operand in a register,.   it returns the number of the register used.  This is a recursive routine.*/ compute: proc fixed; /* compute (compile) an expression */dcl (tree, reg.d) fixed; /* current tree pointer, register containg result (if any) */dcl (arg1, arg2, reg1, reg2, vtype, opr) fixed; /* used as temporaries */dcl (instr, x.i, tmp) fixed; /* used in dyadic processing */dcl (tree1, tree2) fixed;call push (tree);        /* save current tree */call push (reg.pref);    /* and preferred registers */tree = subtree;          /* make subtree the working tree */do case (x.node (tree));  /* The following routines are responsible for compiling code to compute.   the expression represented by the current tree.  They must get it into.   a form such that it may be directly loaded into a register.  They are.   also required to release all storage in the tree below the top.  Since.   they will presumably be using the COMPUTE routine themselves, this only.   means releasing all first level nodes.  If the result is in a register.   then 'REG.D' should be set to the bit-coded register number; REG.D.   should be set to zero otherwise.. .   Expression compiler - dyadic operator:.     The following routines and data areas are used to compile dyadic operators. */ begin;  swap: proc; /* swaps ARG1 and ARG2 for optimizing commutative operations */   dcl tem   fixed;   dcl swtab data (o.eq, o.gt, o.ge, o.lt, o.le, o.ne, o.igt, o.ige, o.ilt, o.ile);   tem = x.arg1 (tree); x.arg1 (tree) = x.arg2 (tree); x.arg2 (tree) = tem;   arg1 = x.arg1 (tree); arg2 = x.arg2 (tree);   reg1 = ifreg (arg1); /* see if reg */   reg2 = ifreg (arg2);   opr = x.info (tree); /* look up operator */   if opr >= o.eq then do; /* if relational - change direction */      opr = swtab (opr - o.eq); x.info (tree) = opr;   end;end swap;  dcl rptab1 data /* change REG.PREF for this op */(0, 0, b.ac0, b.ac0, b.ac0, 0, 0, 0, b.ac1, b.ac1 or b.ac2, b.ac1, b.ac1, b.ac0, 0, 0, 0, 0, 0, 0, 0, 0);  dcl rptab2 data /* change REG.PREF for ARG2 */(0, 0, b.ac1, b.ac1, b.ac1, 0, 0, 0, b.ac2, b.ac1 or b.ac2, b.ac2, b.ac2, b.ac2, 0, 0, 0, 0, 0, 0, 0, 0);  dcl swptab data /* if can be swapped */(0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0,  1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);  dcl fxdops data /* fixed point transfer operations */(b.sub, b.add, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b.and, b.or, b.ex);  dcl fltops data /* floating point subroutines */(l.fps, l.fpa, 0, 0, 0, 0, 0, 0, l.fpd, l.fpm, 0, 0, 0, 0, 0, 0);  /* LLLExpression compiler - process dyadic operator:.  .   Examine the operation to be performed.  In many cases, specific.   registers must be used (such as multiply).  In other cases, try.   to use the best possible register allocation.  For example, if one.   of the fixed point add arguments is in a register, then send the.   other argument to add to it. */  opr = x.info (tree);       /* get operator type */subtree = x.arg1 (tree);   /* get first arg subtree */if opr = o.div then do;    /* for divide, must protect ops */  call push (divarg); call push (upperblock);  upperblock = 0;  if (x.node (subtree) = x.dyad) and (x.info (subtree) = o.times)  then divarg = subtree; /* tell multiply to produce both results */end;call push (reg.pref); /* save preferred registers *//* compute prefered register for first argument */if opr < o.eq then do;   tmp = rptab1 (opr - o.minus);         /* look up basic preference */   if (opr >= o.shr) and (opr <= o.rot)  /* shift rotate             */   then do;      if prctyp >= 2 then tmp = 0;     /* no pref if model >= c    */      else if x.node (x.arg2 (tree)) = x.const      then tmp = 0;                    /* no pref if const shf cnt */   end;   else if (opr >= o.div) and (opr <= o.fdi)  /* mul div operations */   then do;                                   /* no preference if   */      if muldiv <> 0 then tmp = 0;            /* hardware           */   end;   if tmp <> 0 then reg.pref = tmp;    /* use it if desired        */end;reg1 = compute;      /* and compute the subtree */opr = x.info (tree);  /* restore opr             */reg.pref = pop;       /* restore original preference */call push (reg.pref); /* save it again           */reg.pref = reg.pref and (not(reg1));if opr < o.eq then do;   tmp = rptab2 (opr - o.minus);         /* look up preference       */   if (opr >= o.shr) and (opr <= o.rot)  /* shift rotate             */   then do;      if prctyp >= 2 then tmp = 0;     /* no pref if model >= c    */      else if x.node (x.arg2 (tree)) = x.const      then tmp = 0;                    /* no pref if const shf cnt */   end;   else if (opr >= o.div) and (opr <= o.fdi)  /* mul div operations */   then do;                                   /* no preference if   */      if muldiv <> 0 then tmp = 0;            /* hardware           */   end;   if tmp <> 0 then reg.pref = tmp;end;subtree = x.arg2 (tree); reg2 = compute;arg1 = x.arg1 (tree); arg2 = x.arg2 (tree);opr = x.info (tree); /* and restore operator type */if opr < o.eq then do; /* check type for non-relationals */  if fltops (opr - o.minus) = 0 then do;      call fix (arg1);      call fix (arg2);   end;end;vtype = match (arg1, arg2); /* compute desired type */if (mvt) and ((opr = o.times) or (opr = o.div)) then begin; /* force to floating */  call float (arg1); call float (arg2); vtype = 1;end;reg1 = ifreg (arg1); /* see if ARG1 in register *** or is pointer *** */reg2 = ifreg (arg2); /* see if ARG2 in register *** or is pointer *** */reg.pref = pop; /* and restore preferred registers */if vtype then begin; /* if floating, then load registers here */reg.d = b.ac0;      /* all floating results are here */if opr < o.eq then begin;  call freemul;     /* free up multiplier for all floating ops */  if swptab (opr - o.minus) and ((reg1 = b.ac1) or (reg2 = b.ac0))   then call swap;   /* swap ops if we can */  if reg2 = b.ac0 then reg2 = fin.reg (arg2, not b.ac1); /* move to AC1 now if in AC0, or ptr in FPR0 */  call fin.reg (arg1, not b.ac0); /* and get ARG1 in AC0 */  call fin.reg (arg2, not b.ac1); /* and get ARG2 in AC1 no matter what */  call em.rtp (fltops (opr - o.minus)); /* call routine to perform op */end;else begin; /* relational */  if swptab (opr - o.minus) and ((reg2 = b.ac1) or (reg1 = b.ac0)) then call swap; /* swap ops if in wrong regs */  if opr > o.ne then do; opr = opr - 5; x.info (tree) = opr; end;  if (opr = o.ge) or (opr = o.lt) then call swap; /* can not do these */  if reg2 = b.ac1 then reg2 = fin.reg (arg2, not b.ac0); /* move to AC0 here if must */  call fin.reg (arg1, not b.ac1); /* get first arg in AC1 */  call fin.reg (arg2, not b.ac0); /* and second in AC0 */  call em.rtp (l.fps); /* and subtract b from a */end;end; /* of floating */  /* LLLExpression compiler - dyadic operator (cont):.  .   We have performed the computation of the operands.  No emit.   instructions to perform the proper fixed or floating point.   operations. */  /* now for fixed point multiply, divide, shifts: */  else do; /* is not floating point */  dcl brtab data (4, 4, 1, 1, 1, 2, 3, 3, 0, 0, 0, 0, 0, 4, 4, 4, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5);  do case brtab (opr - o.minus); /* branch on type */  do; /* div tim mod fmu fdi */  if muldiv = 0 then do; /* if no mul div, use software routine */    insert ':xpl611:p2-smult';  end;  else do; /* hardware multiply divide */    insert ':xpl611:p2-hmult';  end;  end; /* Dyadic operators - shifts and rotates:.  .  Now process the logical shift and rotate operators.  First check.  for constant arguments and emit shorthand instructions if we can. */    do; /* shr shl rot */if prctyp = 2 then do; /* model C processor */   insert ':xpl611:p2-cshif';end;else do; /* model B processor */   insert ':xpl611:p2-bshif';end;end; /* of shift rotate */; /* undefined */; /* undefined */  /* Standard arithmetic - perform operation using whatever registers.  are available. */   do; /* math operations - add, sub, etc. */if swptab (opr - o.minus) and (x.node (arg2) = x.reg) then do;  reg.d = in.reg (arg2, reg1); /* get ARG2 in any register */  call sendit (arg1, b.ad + fxdops (opr - o.minus) + bitreg (reg.d), reg.d);end;else do;reg.d = in.reg (arg1, reg2); /* get in register */call sendit (arg2, b.ad + fxdops (opr - o.minus) + bitreg (reg.d), reg.d); /* and perform math */end;end;do; /* relational */if reg1 <> 0 then call swap; /* swap if arg1 is already in register */if (opr = o.ge) or (opr = o.lt) or (opr = o.ige) or (opr = o.ilt) then call swap;reg.d = in.reg (arg2, reg1); /* get arg2 in register */call sendit (arg1, b.ad + b.sub + bitreg (reg.d), reg.d); /* subtract b from a for rels */end; /* of relops */end; /* of standard arithmetic */end; /* of fixed point only *//* LLLExpression compiler:  dyadic operator (cont.) */if opr >= o.eq then begin; /* relops - correct */  tmp = bitreg (reg.d); /* get register # */  do case (opr - o.eq); /* branch on relation */    call emita (1, b.ad + tmp); /* read device 1 to get z flag */    ;    begin; /* <= */      call emitc (0, b.ad + b.lef + tmp); /* shift left to get sign bit */      call emitc (1, b.ad + b.ex + tmp); /* and complement least sig bit */    end;    call emitc (0, b.ad + b.lef + tmp); /* rotatate left to get sign bit for > */    ;    call emita (1, b.ad + b.com + tmp); /* complement z flag in register for <> */  ; /* no go */  do; /* integer le */    call emitc (0, b.rd + tmp); /* load a zero - leave zflags */    call emitc (1, b.cr + b.tnc); /* if no carry, then false */    call emitc (1, b.rd + tmp); /* else true */  end;  do; /* integer gt */    call emitc (0, b.rd + tmp); /* assme fail */    call emitc (1, b.cr + b.trc); /* if cary, then false */    call emitc (1, b.rd + tmp); /* else ture */  end;  end;  if opr <= o.ne then call emitc (1, b.ad + b.and + tmp); /* mask if used - fl*/end; /* LLLExpression compiler - dyadic operator (cont):.  .   Done with expression compilation:.     Release nodes, .     Set up tree info to indicate which register contains result. */  if opr = o.div then do; /* pop semphores */  if upperblock <> 0 then call x.rel (upperblock);  upperblock = pop; divarg = pop;end;if reg.d <> 0 then do;if x.node (arg1) = x.reg then do; /* ARG1 in register */  reg1 = x.info (arg1);  tree1 = trees (reg1); trees (reg1) = 0;  call x.rel (arg1);end;else tree1 = arg1;if x.node (arg2) = x.reg then do; /* ARG2 was in register */  reg2 = x.info (arg2);  tree2 = trees (reg2); trees (reg2) = 0;  call x.rel (arg2);end;else tree2 = arg2;call freeup (reg.d); /* REG.D now has new value */if (tree1 = 0) or (tree2 = 0) then do; /* can not optimize then */  freetr = tree1; call tree.free;  freetr = tree2; call tree.free;end;else do; /* maybe can keep track of register contents */  tmp = x.get;x.node (tmp) = x.dyad; x.info (tmp) = opr;x.arg1 (tmp) = tree1; x.arg2 (tmp) = tree2;trees (reg.d) = tmp; /* this is contents of register now *//* final check - if proc or temp, cannot optimize */if (x.node (tree1) > x.var) or (x.node (tree2) > x.var) then call freeup (reg.d);end;x.node (tree) = x.reg; x.info (tree) = reg.d;if vtype then do; /* floating */  if opr >= o.eq then do; /* but relational */    reg.free = (b.ac1 or b.ac2 or b.ac3); reg.cont (reg.d) = tree;    x.arg1 (tree) = t.var; /* fixed point result */  end;  else do; /* fixed point */    reg.free = (b.ac2 or b.ac3);    reg.cont (b.ac0) = tree; reg.cont (b.ac1) = tree;    x.arg1 (tree) = t.fvar; /* floating result */  end;end;else do; /* fixed */  reg.free = (reg.free and (not reg.d));  reg.cont (reg.d) = tree; x.arg1 (tree) = t.var;end;end; /* of result in register */end; /* of dyadic */  /* LLLExpression compiler - monadic operator: */begin; /* monadic operator */     dcl montab data ( /* do case table for monadic operators */   1, 1, 1, 1, 1, 1, 1, 1, /* math ops */   9, 9, 9, 9, 9, 9, 9, 9, /* unused now */   0, /* int */   4, /* read */   9, /* unused */   2, /* addr */   9, 9, 9, 9, /* unused */   3, 3, 3, 9, 3); /* not incr decr null minus */   subtree = x.arg1 (tree);   call push (reg.pref); call push (mvt);   opr = x.info (tree); /* get operator type */   if opr < o.read then reg.pref = b.ac0;    /* use r0 for floating sin, cosine, etc. */   if opr < o.int then mvt = 1; /* use floating here */   else if opr <> o.minus then mvt = 0; /* else try for fixed unless - */    call compute; /* compute operand */   mvt = pop; reg.pref = pop;   opr = x.info (tree);   arg1 = x.arg1 (tree);   vtype = ((x.arg1 (arg1) and t.fvar) <> 0); /* true if floating operand */if (opr = o.read) and (x.node (arg1) = x.const) then do;  /* READ(constant)? */  call fix (arg1); /* make sure fixed point constant */  x.node (tree) = x.dev; x.arg1 (tree) = t.var; x.info (tree) = x.info (arg1);  reg.d = 0; call x.rel (arg1);  if ((x.info (tree) >= b.rs + b.ibt) and (x.info (tree) < b.ms)) /* register then increment? */  or ((x.info (tree) >= b.ms + b.ibt) and (x.info (tree) <= b.ms + b.ibt + b.pc)) then do; /* memory register then increment? */    if (x.info (tree) and b.rmsk) <= b.amsk /* accumulator? */    then call freeup (regbit (x.info (tree) and b.amsk)); /* yes, free up the accumulator */    else if ((x.info (tree) and b.rmsk) >= min.ptr.reg) and ((x.info (tree) and b.rmsk) <= max.ptr.reg) /* variable pointer? */    then call regclr (regbit (x.info (tree) and b.rmsk)); /* free up VP */  end; /* of increment source */end; /* of READ(constant) */else do; /* not read of constant - always will use register */do case (montab (opr)); /* branch on it */do; /* int function */  call fix (arg1); /* convert to fixed point */  reg.d = in.reg (arg1, 0); /* and force into ay register - this is not good */  vtype = 0; /* is actually fixed now */end; /* of int */  /* now check for math operation */  do; /* math operation - abs, sin cos etc. */  dcl mops data /* list of operation pointers */    (l.abs, l.log, l.atn, l.cos, l.sne, l.tan, l.exp, l.sqr); /* pointers */  if (vtype = 0) and (opr = o.math) then do; /* fixed point abs - in line */    reg.d = in.reg (arg1, 0); /* get in any register */    if zflags <> reg.d then call emitc (0, b.ad + b.add + bitreg (reg.d)); /* set */    call emitc (2, b.cr + b.tpl); /* skip if pos or zero */    call emita (b.rs + bitreg (reg.d), b.ad + b.com + bitreg (reg.d)); /* get complement */    call emitc (1, b.ad + b.add + bitreg (reg.d)); /* and add one for negation */  end;  else begin;           /* must be floating point */    call freemul;       /* free up the multiplier in ay case */    call float (arg1);  /* must be floating point */    vtype = 1;          /* is now floating */    reg.d = fin.reg (arg1, not b.ac0); /* get argument in AC0 only */    call reg.allc (not b.ac2); call reg.allc (not b.ac3); /* free up all registers */    call em.rtp (mops (opr));   /* and call routine to perform operation */    call accpurg;               /* can not optimize accumulators here */  end;                          /* of floaters */end;      /* and end - REG.D is set, REG.FREE is ok, and REG.C is too */  /* LLLExpression compiler - monadic operator (cont):.  .   Now handle standard operations - minus, negate, increment. */  do; /* addr function */  vtype = 0;       /* always fixed point */  if x.node (arg1) = x.preg then do;     x.node (arg1) = x.reg;     reg.d = x.info (arg1);   end;  else if x.node (arg1) = x.var then do; /* get pointer */    reg.d = reg.allc (0);                /* get a register */    call sendvp (shr(x.arg1 (arg1), 8), x.info (arg1), b.ad + b.loa + bitreg (reg.d), 0); /* get ptr */    call freeup (reg.d);                 /* we have lost contents of previous reg */    tmp = x.get; x.node (tmp) = x.var;     x.info (tmp) = x.info (arg1);    x.arg1 (tmp) = x.arg1 (arg1);     trees (reg.d) = tmp;  end;  else do; /* no go */     call er.atdnm;     reg.d = in.reg (arg1, 0);  end;end; /* of addr - for now, see below */do; /* misc operations - not incr decr minus */ if (vtype) and (opr = o.minus) then do; /* floating negate */   reg.d = fin.reg (arg1, 0); /* get in either register */   reg1 = ffpr (reg.d); reg2 = sfpr (reg.d); /* and get the two registers */   call emitc (0, b.td + b.tsu + bitreg (reg1)); /* test for zero */   call emitc (2, b.cr + b.tze); /* skip xor if zero */   call emitc ("100000", b.ad + b.ex + bitreg (reg1)); /* change sign */ end; /* of floating */else begin; /* fixed point */ call fix (arg1); vtype = 0;  /* must be fixed */ if  (x.node (arg1) = x.reg) or  (x.node (arg1) = x.preg) then reg.free = (reg.free or x.info (arg1)); /* free up here - may be one to use */ reg.d = reg.allc (0); /* get a register for operation - any one - we know we won't be using a temp here (if x.node is an x.reg or an x.preg) since we have just freed up a register and nono = 0 */ do case (opr - o.not); /* and branch on type */      begin; /* not */     call sendit (arg1, b.ad + b.com + bitreg (reg.d), 0); /* load compil version */   end;        begin; /* increment */     call sendit (arg1, b.rd + bitreg (reg.d), 0); /* load it */     call emitc (1, b.ad + b.add + bitreg (reg.d)); /* add one to it */   end;        begin; /* decrement */     call sendit (arg1, b.rd + bitreg (reg.d), 0); /* load it */     call emitc (1, b.ad + b.sub + bitreg (reg.d)); /* subtract one from it */   end;   ; /* spare */   begin;     /* minus */     call sendit (arg1, b.ad + b.com + bitreg (reg.d), 0);     call emitc (1, b.ad + b.add + bitreg (reg.d));   end; end; /* of do case */call freeup (reg.d); /* register is now clobbered */end; /* of fixed */end; /* of normal operation begin */do; /* read */  call fix (arg1); /* must be fixed point */  vtype = 0; /* indicate fixed */    call in.reg (arg1, not b.ac0); /* get in reg */    call reg.allc (not b.ac1); call reg.allc (not b.ac2); call reg.allc (not b.ac3);    call accpurg;    call em.rtp (l.sbr);    reg.d = b.ac0;end; /* read */end; /* of do case for types */ /* LLLExpression compiler - monadic operators (cont): */ /* now clean up after monadic op leaving result in REG */if vtype = 0 then do; /* if fixed point output - continue */   if x.node (arg1) = x.reg then do; /* ARG1 was put in REG */     reg1 = x.info (arg1);     tree1 = trees (reg1); trees (reg1) = 0;     call x.rel (arg1);   end;   else tree1 = arg1;   call freeup (reg.d); /* indicate free */   if tree1 <> 0 then do; /* if anything identifiable was in register */      tmp = x.get; /* get a block */      x.node (tmp) = x.monad; x.info (tmp) = opr; x.arg1 (tmp) = tree1;      trees (reg.d) = tmp;      if x.node (tree1) > x.var then call freeup (reg.d); /* can not optimize */   end;    /* of check for unidentifiable register contents */   reg.free = (reg.free and (not reg.d)); /* update free registers */   x.node (tree) = x.reg; x.arg1 (tree) = t.var; x.info (tree) = reg.d;   reg.cont (reg.d) = tree; /* update back ptr in case of force reqd */end; /* of fixed */else do; /* floating result */  reg1 = ffpr (reg.d); reg2 = sfpr (reg.d);  reg.free = (reg.free and (not reg1) and (not reg2));  reg.cont (reg1) = tree; reg.cont (reg2) = tree;  x.node (tree) = x.reg; x.arg1 (tree) = t.fvar; x.info (tree) = reg.d;  call x.rel (arg1); /* and arg is now freed up */end;end; /* of monadic ops that always use registers */end; /* of all mondic ops */reg.d = 0; /* constants - no processing required, no register used */do; /* variables - check for subscripted */  reg.d = 0; /* assume not */  if x.arg1 (tree) then reg.d = subscript (tree, 0); /* get pointer */end;/* LLLExpression compiler - procedure calls: */do; /* procedure.call */  call freemul; /* free up multiplier on procedure.call */  call reg.allc (not b.ac0);  call reg.allc (not b.ac1);  call reg.allc (not b.ac2);  call reg.allc (not b.ac3);/* First of all, set up two linked data lists:.   One for arguments that go in a register, then the other list .   for those arguments (5 and above) that get stuffed in memory...   Then for each one that gets stuffed, COMPUTE it and store proper .   data in the memory cell.  .   Then for each one that goes in a register, COMPUTE it, and if the .   argument is a floating variable, get a temporary location and.   store it there..  .   Then for each argument that goes in a register, get proper result.   in REG.. .   Then emit procedure.call.*/  dcl (link, reg#, xftl, ft, d1, reg3, adptem, inregl, stuffl, linktem) fixed;  /* LLLExpression compiler - procedure.ADAPT:.  .   ADAPT is called passing a declared variable type, a tree structure node, .   and an 8-bit (reg or mem) destination field.  The node has already.   been computed using the 'COMPUTE' procedure..  .   ADAPT proceeds to adapt a node type for passage to the declared variable.   (procedure.actual parameter).   If dest is nonzero, the appropriate .   quantity (a pointer to arrays, a pointer to a temporary containing a .   floating point argument for FVARs, or the fixed point results for a .   fixed point number) is then sent to the specified destination.  DEST.   is restricted to loads of arithmetic accumulators and variable pointer.   references..  .   ADAPT is only passed DTYPEs and NODEs that are T.VAR (fixed points) or.   T.PFVAR (pointers to floating point variables).  Adapting for arrays.   is handled by the 'SAP' (send array pointer) procedure.(below).*/  adapt: proc(dtype, node, dest, nono); /* adapt a node to a dtype, send to dest if nonzero */   dcl (dtype, node, dest, nono) fixed;   dcl info fixed;   if dtype = t.var then do; /* dtype is T.VAR or T.PFVAR */      if (x.arg1 (node) and t.fvar) <> 0      then do;          call er.atdnm;         x.arg1 (node) = (t.var or (x.arg1 (node) and (not "377")));      end;      if dest <> 0 then call sendit (node, dest, nono); /* put result of comput in dest */   end;   else do; /* dtype is T.PFVAR */      call float (node); /* make sure is floating */      info = x.info (node); /* restore new info */      if x.node (node) <> x.temp then do; /* get one */         ft = gtemp (flt);          reg1 = getvp (s.temporary, ft, nono); /* get pointer to it */         if dest <> 0 then do; /* if we do send it */            call emita (b.rs + reg1, dest); /* send pointer to dest.  ptr points to where we are about to store */            adptem = x.get; /* get a block for temp */            e.point (adptem) = xftl; xftl = adptem; /* link onto temp allocated list */            e.loc (adptem) = ft; /* and save location */         end;         call fsendit (node, b.md + b.ibt + reg1, b.md + b.ibt + reg1, nono); /* store in temporary */         x.node (node) = x.temp; x.info (node) = ft; x.arg1 (node) = t.fvar;         regl = (regl or regbit (reg1)); regc (reg1) = regc (reg1) + 2; /* and fix up register */      end; /* of not a temp */      else do; /* X.NODE (NODE) is an X.TEMP */         if dest <> 0 then do; /* if we really do send it */            call sendvp (s.temporary, info, dest, nono); /* send variable pointer to DEST */            adptem = x.get; e.point (adptem) = xftl; xftl = adptem; /* get block, link */            e.loc (adptem) = info; /* and put in temp location */         end; /* of dest <> 0 */      end; /* of tymp */   end; /* of handling floaters */end adapt;  /* LLLRoutine SAP:.  .   The routine SAP is passed a declared argument type, a passed argument .   type, an info word, and a destination address.  DTYPE is either .   T.PARR (pointer to array) or T.PFARR (pointer to floating point array)..   PTYPE is either T.ARR (fixed point array), T.PARR (pointer to such), .   T.FARR (floating point array), T.PFARR (pointer to same), or .   T.SCONST (string constant).  INFO is either a pointer to the variable .   start location of a passed array, or a pointer to where the string .   constant will be sitting during execution.  DEST is restricted as in.   ADAPT (above).  PTYPE is expected to be a X.ARG1 value (i.e., storage.   class and type)..  .   SAP sends a 16-bit number to dest.  That number represents a pointer.   to the array base during execution.*/  sap: proc(dtype, ptype, info, dest, nono); /* send array pointer to dest */   dcl (dtype, ptype, info, dest, nono, class) fixed;   class = shr(ptype, 8); /* extract storage class */   ptype = (ptype and "377"); /* leave just the type */   if (x.arg2 (tree) and "377") = t.proc then begin; /* only check arg type for user call */      if dtype = t.parr then do; /* fixed array - must not be floating */         if (ptype <> t.sconst) and ((ptype and t.fvar) <> 0) then call er.atdnm;      end;      else do; /* must be T.PFARR */         if (ptype = t.sconst) or ((ptype and t.fvar) = 0) then call er.atdnm;      end;   end;   if (ptype = t.sconst) or (ptype = t.data) or (ptype = t.fdata) /* string constant or data? */   then call em.spt (info, dest); /* emit scon pointer */   else if (ptype and t.pvar) <> 0 then do; /* PTYPE is PFARR or PARR */      reg1 = getvp (class, info, nono); /* get pointer in register to pointer in vs1 */      call emita (b.ms + reg1, dest); /* send out to dest */   end;   else do; /* PTYPE is FARR or ARR */      if info = 0 /* CORE array */      then call emitc (0, dest); /* CORE array starts at location 0 */      else call sendvp (class, info, dest, nono); /* not CORE - send the variable pointer to DEST */   end; /* of arrays */end sap;  /* LLLExpression compiler - start emitting code for procedure.call: */  xftl = 0; inregl = 0; stuffl = 0; /* initialize lists */  /* set up list of args */  link = x.arg1 (tree); /* initialize llink */adptem = 0;do while (link <> 0); /* loop through all arguments, putting ont two list */   if adptem < 4 then do; /* goes in register */      linktem = x.node (link); x.node (link) = inregl; inregl = link; /* link on to pass in register list */   end;   else do; /* must be stuffed */      linktem = x.node (link); x.node (link) = stuffl; stuffl = link; /* link on to stuff list */   end;   link = linktem; /* move down list */   adptem = adptem + 1; /* keep track of counter */end; /* of first pass through argument list */  /* Pass 1.5 - go through both lists and compute and expressions that *//* need to be computed.  Since these expressions might be other      *//* procedure calls,  we have to compute them all before we stuff     *//* any arguments into static variables.                              */link = stuffl;do while (link <> 0); /* for each one to stuff */   if not(x.arg2 (link)) then do; /* declared variable type was not array */      call push (inregl); call push (stuffl); call push (link); call push (xftl);      reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any reg */      call push (mvt); /* protect */      if x.arg2 (link) = t.var then mvt = 0; else mvt = 1;      subtree = x.arg1 (link); call compute; /* compute the expression */      mvt = pop; /* restore */      xftl = pop;      link = pop; stuffl = pop; inregl = pop; /* pop */   end;   link = x.node (link); /* move down list */end; /* of pass 1.5 *//*  First reverse the INREGL list, so that the first item on the .   list will be going in register 0. */  link = inregl; inregl = 0;do while (link <> 0);  /* go through */   linktem = x.node (link); /* point to next */   x.node (link) = inregl; inregl = link; /* reverse */   link = linktem;end;  reg# = b.ac0;     /* first one goes here */link = inregl;do while (link <> 0); /* go down list */   if not x.arg2 (link) then do; /* here, we only handle non-arrays */      call push (reg#  ); call push (inregl);      call push (stuffl); call push (link  ); call push (xftl); /* store temp list pointer */      reg.pref = reg#; /* prefer result here */      call push (mvt);      if x.arg2 (link) = t.var then mvt = 0; else mvt = 1;      subtree = x.arg1 (link); call compute; /* and compute result */      mvt = pop; /* restore */      xftl = pop;      link = pop; stuffl = pop; inregl = pop; reg# = pop;   end;   reg# = shl(reg#, 1); /* next arg, next reg */   link = x.node (link); /* move down */end; /* of this pass *//* Pass two - go through stuff list and compute those, and send data to memory cell.  (these memory cells are always static). */  link = stuffl;do while (link <> 0); /* for each one to stuff */   if x.arg2 (link) then do; /* declared variable type was array */      reg1 = getvp (s.static, x.spec (link), 0); /* get variable pointer to where to stuff arg (in this case arr ptr) */      call sap (x.arg2 (link), x.arg1 (link), x.info (link), b.md + reg1, regbit(reg1)); /* send array pointer to memory */   end;   else do; /* argument is variable, not array */      reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any reg */      reg1 = getvp (s.static, x.spec (link), 0); /* get vptr of where to stuff */      call adapt (x.arg2 (link), x.arg1 (link), b.md + reg1, regbit(reg1)); /* adapt node and send to memory */   end;   link = x.node (link); /* move down list */end; /* of pass2 *//*  Pass three - go down 'pass in register list' and compute all operands.   and then store any floaters in temps.  We do.not load the argument .   carrying register at this time, because we need all available registers.   for computing each argument that is going to pass in a register. */reg# = b.ac0; /* first one goes here */link = inregl;do while (link <> 0); /* go down list */   if not x.arg2 (link) then do; /* here, we only handle non-arrays */      reg.pref = reg#; /* prefer result here */      call adapt (x.arg2 (link), x.arg1 (link), 0, 0); /* allocate temporaries for fvars at this time */   end;   reg# = shl(reg#, 1); /* next arg, next reg */   link = x.node (link); /* move down */end; /* of this pass */  /* LLLExpression compiler - procedure.call (cont):.  .   Pass four - go through list of arguments that are passed in registers.   and then put the appropriate number in the appropriate register..  .   Note:  All floating arguments are in temporaries by now..  .   From here on, the tree structure falls to pieces since.   registers are loaded with pointers and things that are.   not conveniently represented by an X.NODE type.  Also, .   a used register must not be stored in a temp once an argument .   has been loaded into it (obviously). */  reg# = b.ac0; link = inregl;do while (link <> 0);   if x.arg2 (link) = t.var then call in.reg (x.arg1 (link), not reg#); /* if var, get in reg */   else if x.arg2 (link) = t.pfvar then do; /* argument is pointer to floating variable */      call reg.allc (not reg#);      call adapt (x.arg2 (link), x.arg1 (link), b.rd + bitreg (reg#), ((not reg#) and 15)); /* send proper item (ptr to temp) to reg.  use this reg for recursive variable pointers */   end;   else do; /* declared argument type must be an array */      call reg.allc (not reg#); /* free up regs */      call sap (x.arg2 (link), x.arg1 (link), x.info (link), b.rd + bitreg (reg#), ((not reg#) and 15)); /* send ptr into reg.  use this reg for recursive variable pointers */   end;   call freeup (reg#); /* indicate contents is now nothing */   reg# = shl(reg#, 1); /* next, next */   link = x.node (link); /* move on */end;  /* Pass 5 - go through both lists and free up expression blocks and link blocks. */  link = inregl;do while (link <> 0);   if not x.arg2 (link) then call x.rel (x.arg1 (link));   d1 = x.node (link); call x.rel (link); link = d1;end;link = stuffl;do while (link <> 0);   if not x.arg2 (link) then call x.rel (x.arg1 (link));   d1 = x.node (link); call x.rel (link); link = d1;end;  /* free up stacked temps */  do while (xftl <> 0);   call ptemp (e.loc (xftl), flt); /* release this temporary */   d1 = e.point (xftl); call x.rel (xftl); xftl = d1; /* and release block */end;  /* emit proper JSR (jump subroutine) */  if (x.arg2 (tree) and "377") = t.proc then do; /* call of user procedure.*/   d1 = shl(shr(x.arg2 (tree), 8), 1); /* point to list for this proc call */   if aliases (d1) <> x.info (tree) /* make sure it's for this proc! */   then call er.cerr ('alias list doesn''t match call');   call em.cal (x.info (tree), d1 + 2, aliases (d1 + 1)); /* emit call using key system */end;else do; /* rtp call */   call em.rtp (x.info (tree)); /* emit call to rtp routine */end;  /* clean up and return */  call accpurg; /* indicate all registers zapped */x.node (tree) = x.reg; x.arg1 (tree) = x.spec (tree); /* set up type returned */x.info (tree) = b.ac0; /* answer is in reg 0 */reg.cont (b.ac0) = tree; reg.cont (b.ac1) = tree;if x.arg1 (tree) = t.var /* if returns type is fixed */then reg.free = (b.ac1 or b.ac2 or b.ac3);else reg.free = (b.ac2 or b.ac3); /* only these 2 are free */reg.d = b.ac0;  end; /* of procedure.call */  /* LLLExpression compiler - end of the compute subtree routine: */  end; /* of case statement */ reg.pref = pop; /* reload stacked parameters */ subtree = tree; /* also preserve calling parameter */ tree = pop; return (reg.d); /* return as value the register that the answer is in */end compute;