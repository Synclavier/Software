/* Expression scanner:  Definitions. .  The expression scanner scans the current expression and produces.  a tree representation of it (essentially a binary tree).  This permits.  lots of optimization, although very little is actually done by this.  routine.  Arithmetic on constants is handled (a + (1 + 2) generates the.  same tree as a + 3).  The format of the tree is as follows: */ dcl x.node  lit 'store1'; /* type of the node         */dcl x.arg1  lit 'store2'; /* first argument pointer   */dcl x.arg2  lit 'store3'; /* second argument pointer  */dcl x.info  lit 'store4'; /* extra information        */dcl x.get   lit 'get'; /* storage allocation routines */dcl x.rel   lit 'rel';  dcl mvtype fixed; /* set to 0 or T.VAR for fixed, nonzero or T.FVAR for float */ /*  $$The routine EXPR is called to scan an arithmetic or logical expression.    from the source file.  It is converted into an 'expression' tree.    for further processing ..  .    EXPR is recursive in nature and uses the internal push down.    stack (PUSH and POP) for recursive calls instead of the.    built-in system PDL.  Otherwise, prohibitive amounts of.    storage (PDL) are required for the compiler.*/  expr: proc;dcl (tree, prevtree, prior) fixed;dcl (EXPEXIT, EXPSTART) label; /* goto EXPSTART to start, goto EXPEXIT to return */dcl (subtree1, subtree2, arg1, arg2) fixed;dcl (dkey, ppoint) fixed; /* data key, proc pointer for proc data was dcl'd in */dcl parm           fixed; /* parameter number */dcl opr   fixed; /* holder for operator type */dcl ptr   fixed; /* alias list pointer */dcl const fixed;  /* Tables used during expression processing:.  .   Look-up tables are used during expression processing to determine.   the priority of different operations, and to distinguish dyadic.   and monadic operators..  .   The following table is used to find the priority of a given operator..   It is indexed by the operator type that is returned in 'INFO' by.   the scanner.*/ dcl b.monad lit '256'; /* indicates monadic allowed */dcl b.dyad  lit '512'; /* indicated dyadic allowed */dcl op.table data (/* and this is table */b.monad + 1, b.monad + 1, b.monad + 1, b.monad + 1, b.monad + 1, b.monad + 1, b.monad + 1, b.monad + 1, 0, 0, 0, 0, 0, 0, 0, 0, /* spare */b.monad + 1, b.monad + 1, 0, b.monad + 1, /* int, read, spare, addr */b.monad + 1, b.monad + 1, b.monad + 1, 0, /* shr1, shl1, rot8       */b.monad + 1, 0, 0, 0, /* not */b.monad + b.dyad + 3, b.monad + b.dyad + 3, /* minus, plus */0, 0, 0, 0, 0, 0, /* shr shl rot pat min max - elsewhere */b.dyad + 2, b.dyad + 2, b.dyad + 2, b.dyad + 2, b.dyad + 2, /* div, times, fmu, fdi, mod*/b.dyad + 5, b.dyad + 5, b.dyad + 5, /* and or xor */0, 0, 0, 0, 0, /* not used */b.dyad + 4, b.dyad + 4, b.dyad + 4, b.dyad + 4, b.dyad + 4, b.dyad + 4, b.dyad + 4, /* rels */b.dyad + 4, b.dyad + 4, b.dyad + 4, b.dyad + 4); /* integer relational ops */   prior = prior.max; /* start with maximum priority */ tree = 0; /* no tree yet */ call push (0); /* push a zero for EXPEXIT */ goto EXPSTART; /* and start the expression scan */ EXPLAB0: return tree; /* jump back here, use normal return to return ptr to tree */ /* $$The procedure LOOKUP_PARM searches the formal parameter list of the.   current procedure and all its outer procedures (those with a greater.   lexical scope) for the passed variable.  If it is found, the parameter.   number of that variable is returned and the global variable PARM_KEY.   contains the key of the procedure it is a formal parameter of.  If it.   isn't found, a -1 is returned. */dcl parm_key fixed; /* set to key of formal parm's procedure by LOOKUP_PARM */lookup_parm: proc(token, info) fixed; /* lookup a parameter definition */   dcl token  fixed; /* token of variable to lookup */   dcl info   fixed; /* location of variable to lookup */   dcl parm   fixed; /* resultant parameter number of variable */   dcl cptr   fixed; /* current proc parameter pointer */   dcl clim   fixed; /* lower limit of current proc's record */   dcl cdepth fixed; /* current depth */   cdepth = s.depth; /* start at current procedure level (S.PDEF (cdepth) = CUR.PROC.DEF here) */   do while ((cdepth > 0) and (s.pdef (cdepth - 1) = s.pdef (cdepth))); /* skip over BEGINs */      cdepth = cdepth - 1;   end;   parm = -1; /* assume this variable is the parameter of NO procedure */   cptr = clim; /* get into the loop */   do while ((s.pdef (cdepth) <> -1) and (cptr ile clim)); /* search for the parameter at all levels */      cptr = s.pdef (cdepth) + p.parm; /* point to parameters of current proc */      clim = cptr - shl(stable(s.pdef (cdepth) + p.args), 1); /* lower limit of current proc record */      do while ((cptr igt clim) /* look thru parms until we find this variable */      and ((token <> stable (cptr + p.ptyp) and "377") or (info <> stable (cptr + p.ploc))));         cptr = cptr - 2; /* look at next entry */      end;      if cptr igt clim then do; /* if still in range, this is a formal parm of the current proc */         parm = shr(s.pdef (cdepth) + p.parm - cptr, 1); /* save formal parameter number */         parm_key = shr(stable (s.pdef (cdepth) + p.key), 1); /* and key */      end;      else do; /* not in range - prepare to look at the next level */         cdepth = cdepth - 1; /* go up a level */         do while ((cdepth > 0) and (s.pdef (cdepth - 1) = s.pdef (cdepth))); /* skip over BEGINs */            cdepth = cdepth - 1;         end;      end; /* of look at the next level */   end; /* of searching for parameter at all levels */   return (parm); /* return formal parameter number */end lookup_parm;/* The procedure 'SCANARG' is used to scan off an argument that is.  enclosed in parenthesis.   (Such as when processing the 'READ'.  token or when scanning a subscript.).  .  The SCANARG routine returns a pointer to the scanned tree in the global.  variable SUBTREE1.*/  dcl typ fixed; /* set type to 0 (fixed) or 1 (float) before entering SCANARG */  SCANARG:; /* uses standard push/goto to activate SCANARG */  if token <> t.lpar then   call er.ifm;  call scan; call push (tree); prior = prior.max;  call push (mvtype); mvtype = typ; /* set up correct type */  call push (1); goto EXPSTART; EXPLAB1:; /* start parsing the expression */  mvtype = pop; /* restore */  prior = 0; subtree1 = tree; tree = pop;  if token <> t.rpar then call er.ifm;  call scan; /* skip final paren */  goto EXPEXIT; /* and return to point of call - tree is in global var SUBTREE1 */  /* $$Expression scanner - priority zero:. .   If the priority is zero we handle variables, constants, subscripted.   arrays, procedure calls, and expressions enclosed in parens.*/  EXPSTART:; /* enter here to start scan */ if tree <> 0 then prevtree = tree; /* save previous tree (we need this to detect ADDR(data)) - skip many zeroes */   if prior = 0 then do; if (token < t.lit) or (token = t.data) or (token = t.fdata) then do; /* var, data */  tree = x.get;  x.arg1 (tree) = (token or shl(gclas (name.pt), 8)); x.info (tree) = info;  x.node (tree) = x.var;  if (token and t.fvar) <> 0 then call lchk; /* make sure line no in file */  if ((cur.proc.def <> -1) and (cur.proc.def <> -2) /* if in a proc, but not a WHEN */  and (token = t.parr)) then do; /* fixed array? - watch out for ADDR (for SCON) */     if ((prevtree <> 0) and (x.node (prevtree) = x.monad) and (x.info (prevtree) = o.adr)) then do; /* ADDR of fixed array? */        parm = lookup_parm (token, info); /* see if this is the formal parameter of any procedure */        if parm <> -1 then do; /* if it is a formal parameter of a proc */           call emit (t.address); /* emit addr of parameter code */           call emit (parm_key); /* emit key of proc this is a formal parameter of */           call emit (parm); /* and the parameter number */        end; /* of formal parameter of a proc */     end; /* of ADDR of fixed array */  end; /* of fixed array */  if ((token = t.data) or (token = t.fdata)) then do; /* data? - see if it can swap */     if ((prevtree <> 0) and (x.node (prevtree) = x.monad) and (x.info (prevtree) = o.adr)) then do; /* ADDR of data? */        dkey = gdkey (name.pt); /* get data key */        ppoint = s.pdef (depth); /* get pointer to procedure it was defined in */        if ((ppoint <> -1) and (info ilt extern.base)) /* if defined within a procedure */        then call set_stable (ppoint + p.dswp, stable (ppoint + p.dswp) or shl(1, dkey)); /* this data statement cannot swap */     end; /* of ADDR of data */  end; /* of data */  if token then do; /* scan subscript */    arg1 = name.pt; /* save pointer to variable */    call scan; /* skip equals */    if token <> t.lpar then call er.msub (arg1); /* missing subscr */    typ = t.var;    call push (2); goto SCANARG; EXPLAB2:; /* and scan expr in parens */    x.arg2 (tree) = subtree1; /* and this is subscript */  end;  else call scan; /* else just skip over it */  goto EXPEXIT; /* return from EXPSTART */end; /* of variable */    if token = t.lpar then do; /* expression enclosed in parens */  typ = mvtype;  call push (3); goto SCANARG; EXPLAB3:; /* scan same type */  tree = subtree1; /* and return in tree */  goto EXPEXIT; /* and return */ end;  if (token = t.const) or (token = t.fconst) then do; /* constant */  tree = x.get;  x.info (tree) = info; x.node (tree) = x.const;  if token = t.const   then x.arg1 (tree) = t.var;  else do;    call lchk;    x.arg1 (tree) = t.fvar;    end;  call scan;  goto EXPEXIT; /* and return tree */end;  /* $$Dyadic operators - special form:..  The functions SHR, SHL, and ROT are treated as dyadic.  operators by the compiler.  Instead of the normal form.  (<term> <operator> <term>), their format is:.  <operator> (<term>, <term>)...  The following section scans off expressions with these special.  dyadic operators.*/if token = t.sdy then do; /* special dyadics - shift, rotate */  tree = x.get;  x.node (tree) = x.dyad; x.info (tree) = info; /* dyadic type */  call push (mvtype);  call scan;  if token <> t.lpar then call er.ifm;  call scan;  call push (tree);  prior = prior.max;  call push (7); goto EXPSTART; EXPLAB7:;  prior = 0; subtree1 = tree; /* save subtree */  tree = pop; x.arg1 (tree) = subtree1;  if token <> t.comma then call er.ifm; call scan;  call push (tree); prior = prior.max;  call push (8); goto EXPSTART; EXPLAB8:;  prior = 0; subtree2 = tree;  tree = pop;  x.arg2 (tree) = subtree2;  if token <> t.rpar then call er.ifm;  call scan;  mvtype = pop; /* restore type requested */  subtree1 = x.arg1 (tree); /* get first operand */  if (x.node (subtree1) = x.const) and (x.node (subtree2) = x.const)  and (x.arg1 (subtree1) = t.var) and (x.arg1 (subtree2) = t.var) then do;    arg1 = x.info (subtree1);    arg2 = x.info (subtree2); /* pick up constants */    do case (x.info (tree) - o.shr); /* perform it */      arg1 = shr(arg1, arg2);      arg1 = shl(arg1, arg2);      arg1 = rot(arg1, arg2);    end;    call x.rel (tree);    call x.rel (subtree2);    tree = subtree1;    x.info (tree) = arg1; /* new constant */  end;  goto EXPEXIT;end;/* $$Procedure calls:. .   For procedure calls, the node block looks like:.      X.NODE =  X.PROC.      X.ARG1 =  start of linked list of argument blocks (see below).      X.ARG2 =  alias list handle/T.PROC for user proc calls, T.RTP for rtp routine calls.      X.INFO =  pointer to entry in S.STACK for this procedure.  .  .   The S.STACK entry for each procedure looks like:.      0:  pointer to the location block for the body of this procedure (key!).      1:  number of arguments to pass to this procedure.      2:  proc flags/token type of variable returned - T.VAR or T.FVAR.      3:  for each argument mentioned above:.          a: arg flags/type of variable (T.VAR, T.ARR, etc) that arg.             was declared to be inside the procedure definition..          b: relative distance of this variable location from.             start of variable area..  .  .   Each 'argument block' looks like:.      if argument was declared to be some sort of array:.         X.ARG1 =  token type of array that we are passing to it.         X.INFO =  relative variable storage area of array (0).     .      if argument was declared to be some sort of fixed or floating variable:.         X.ARG1 =  pointer to expression tree to pass to procedure.     .      in both cases:.         X.ARG2 =  link pointer to next argument block.         X.NODE =  type of argument required by procedure*/  if (token = t.proc) or (token = t.rtp) then do; /* call */dcl (sptr, pptr) fixed; /* stack pointer, proc pointer */dcl lim          fixed; /* lower limit of target proc's record, lower limit of current proc's record */ pptr = info; /* point to procedure block */ sptr = pptr; /* start stack pointer at top of proc block */ tree = x.get; /* get a block for this tree */ ptr = alloc_handle (2); /* start alias list with header only */ if ptr = null then call er.etc; /* expression too complicated */ else do; /* expression not too complicated */    core(core(ptr)) = stable(pptr + p.key); core(core(ptr) + 1) = 0; /* save key and initial list length */    ptr = ptr - addr(handles (0)); /* normalize pointer to fit in field */ end; x.node (tree) = x.proc; x.info (tree) = sptr; /* pointer into stack */ x.arg1 (tree) = 0; /* initialize list of arguments */ x.arg2 (tree) = (shl(ptr, 8) or token); /* save T.PROC or T.RTP plus handle to alias table */ call scan; /* scan past procedure identifier */if (stable (sptr + p.rtyp) and "377") = t.fvar then call lchk; /* put line # there *//* $$Procedure call scan (continued):..   If any arguments are specified, scan them off and link them on.   a linked list: */ if stable (sptr + p.args) <> 0 then do; /* if any arguments, then scan them */call lchk;lim = sptr + p.parm - shl(stable (sptr + p.args), 1); /* lower limit */if token <> t.lpar then call er.nea; token = t.comma; /* pretend comma encountered */ sptr = sptr + p.parm; /* pointer to first argument */  do while token = t.comma; /* scan off all arguments */ call scan; /* scan off comma or open paren */ if sptr <= lim then do; /* too many */   call er.tma; sptr = lim + 2; /* fudge to continue ok */ end; subtree1 = x.get; /* get a block for this argument */ x.arg2 (subtree1) = x.arg1 (tree); /* link it on */ x.arg1 (tree) = subtree1; /* to list of args */ if (stable (sptr + p.ptyp) and "377") = t.unda then do;  call er.irec; call set_stable (sptr + p.ptyp, t.var); /* set to fixed */end; x.node (subtree1) = (stable (sptr + p.ptyp) and "377"); /* get type of arg reqd */if (x.node (subtree1)) and (token = t.locat) then do; /* 'location and  for array */  x.node (subtree1) = t.var; /* pass a variable instead - hope location is ok */  call scan; /* skip 'location' */end;if not x.node (subtree1) then do; /* if not array,  scan expression */ call push (tree); /* on the stack in case there is another */ call push (sptr); /* procedure call lurking down there */ call push (pptr); /* watch out for proc calls */ call push (subtree1); call push (lim); call push (mvtype); mvtype = (x.node (subtree1) and t.fvar); prior = prior.max; /* get complete expression */ call push (9); goto EXPSTART; EXPLAB9:; prior = 0; /* restore priority level */ mvtype = pop; /* restore calling type */ lim = pop; /* restore upper limit */ subtree2 = tree; /* preserve tree pointer */ subtree1 = pop; /* restore everything important */ pptr = pop; sptr = pop; tree = pop; x.arg1 (subtree1) = subtree2; /* point to expression tree */ end;/* handle arguments that are arrays: */else do; /* array - just scan token */if ((cur.proc.def <> -1) and (cur.proc.def <> -2) /* if in a proc, but not a WHEN */and (token = t.parr)) then do; /* and have a FIXED ARRAY token */   parm = lookup_parm (token, info); /* see if it's a formal parameter of a procedure */   if parm <> -1 then do; /* if this is a formal parm of a proc */      if parm_key = shr(stable (cur.proc.def + p.key), 1) /* if a formal parameter of the current procedure */      then dkey = 1; /* only one word used */      else dkey = 2; /* not a formal parameter of the current proc; two words used */      ptr = shr(x.arg2 (tree), 8) + addr(handles (0)); /* get handle into alias list for this call */      if expand_handle (ptr, dkey) = null /* expand the alias list */      then call er.etc; /* expression too complicated */      else do; /* expression isn't too complicated */         core(core(ptr) + 1) = core(core(ptr) + 1) + dkey; /* we've stored another alias - update length */         ptr = core(ptr) + (core(core(ptr) + 1) - dkey) + 2; /* point to where to insert entry */         core(ptr) = (shl(parm, 8) or shr(pptr + p.parm - sptr, 1)); /* save formal parameter number/actual parameter number */         if dkey <> 1 then do; /* if not formal parameter of current proc */            core(ptr) = (core(ptr) or "100000"); /* set sign bit */            core(ptr + 1) = parm_key; /* pass KEY along as well */         end; /* of not a formal parm of current proc */      end; /* of expression isn't too complicated */   end; /* of formal parameter of proc */end; /* of in a proc */if token = t.sconst then do; /* string constant */  if (x.arg2 (tree) and "377") = t.rtp /* runtime package call? */  then info = 0; /* no key associated with it */  else if stable (pptr + p.key) ige extern.base /* external? */  then info = stable (pptr + p.key); /* yes, get external key */  else info = shr(stable (pptr + p.key), 1); /* no, get rtp location or key */  info = e.scon (info, shr(pptr + p.parm - sptr, 1)); /* emit it and save pointer */end;else if ((token = t.data) or (token = t.fdata)) then do; /* data? - see if it can swap */  dkey = gdkey (name.pt); /* get data key */  ppoint = s.pdef (depth); /* get pointer to procedure it was defined in */  if ((ppoint <> -1) and (info ilt extern.base)) /* if defined within a procedure */  then call set_stable (ppoint + p.dswp, stable (ppoint + p.dswp) or shl(1, dkey)); /* this data statement cannot swap */end; /* of data */else if (token > t.fdata) or (not token) then do;  call er.atdnm; token = t.arr;  end;x.arg1 (subtree1) = (token or shl(gclas (name.pt), 8)); /* token type of what we are passing */x.info (subtree1) = info; /* variable location */  call scan; /* skip over argument */end; /* passing an array */  sptr = sptr - 2; /* move on to next arg */ end; /* of argument scanning loop */ if token <> t.rpar then call er.ifm;if sptr <> lim then call er.nea;call scan; /* scan off the close paren */end; /* scanning arguments */goto EXPEXIT; /* and return */end; /* procedure calls */ if token = t.und then call er.ufls (info);else call er.ifm;tree = x.get;x.node (tree) = x.const; x.arg1 (tree) = t.var; /* return fake tree of const 0 */goto EXPEXIT; /* and return */end; /* $$Expression scanner - nonzero priority:. .   Handle expression of the form:..     (<monadic operator>) <term> [<operator> <term>]*. .   where all of the operators are of the current priority, and the.   terms are expressions with all operators of higher priority than.   the current priority (lower priority number).  An expression (of.   a given priority) then consists of an optional monadic operator.   of that priority followed by one or more expressions of higher.   priority separated by dyadic operators of the current priority.*/  else do; tree = 0; /* nonzero indicates monadic operator found, points to node block */ if token = t.opr then /* check for monadic operator */ if (op.table (info) and 255) = prior then do; /* of the current priority */if (op.table (info) and b.monad) = 0 then do; call er.ifm; info = o.plus; end; if info <> o.plus then do; /*** ignore unary plus ***/ tree = x.get; /* get a new node */ x.info (tree) = info; /* type of operator */ x.node (tree) = x.monad; end; call scan; /* scan off monadic operator */ end;/* process monadic operators here: */  if tree <> 0 then do; /* check for monadic operator scanned */opr = x.info (tree); /* get operator type */call push (mvtype); /* save current type */if opr = o.adr then call lchk; /* for good error messages */if opr < o.int then do; mvtype = t.fvar; call lchk; end;else if opr < o.minus then mvtype = t.var; /* this wants fixed */ call push (tree); prior = prior - 1; call push (10); goto EXPSTART; EXPLAB10:; prior = prior + 1; subtree1 = tree; tree = pop;mvtype = pop; /* restore requested type */opr = x.info (tree); /* pick up type */if (x.node (subtree1) = x.const) and (x.arg1 (subtree1) = t.var) and (opr >= o.not) then begin; const = x.info (subtree1); /* get the constant easily accessible */do case (opr - o.not);const = (not const);;;;const = (-(const)); end; call x.rel (tree); /* release the extra node */ tree = subtree1; /* make the constant block our complete tree */x.info (tree) = const; /* store new constant value */ end;else if (x.node (subtree1) = x.const) and (x.arg1 (subtree1) = t.fvar) and (opr = o.minus) then do;  call x.rel (tree); /* no longer need - */tree = subtree1;opr = x.info (tree); /* get pointer into fstk - change sign there */if fstk (opr) <> 0 then fstk (opr) = (fstk (opr) xor "100000");end; else x.arg1 (tree) = subtree1; end;/* $$Expression scanner - nonzero priority (cont):.  .   Continue the expression scan here.  A leading monadic operator (if.   one) has been scanned.   .  .   Get the first term and then get successive operator/term pairs.   while each are of the current priority.*/  else do; prior = prior - 1; call push (11); goto EXPSTART; EXPLAB11:; prior = prior + 1; end; /* get following terms */  do while token = t.opr; /* stop whenever we run out of operators */ if (op.table (info) and 255) <> prior then goto EXPEXIT; /* or get wrong priority */ if (op.table (info) and b.dyad) = 0 then do;    call er.ifm;    info = o.plus; end; call push (tree); /* save what we have so far */ call push (info); /* as well as type of operator */ call scan; /* accept this operator */ prior = prior - 1; call push (12); goto EXPSTART; EXPLAB12:; prior = prior + 1; opr = pop; /* restore operator type */  /* $$Now optimize for fixed point constant arithmetic:..   During compile time, compute fixed point expressions if possible.*/subtree1 = pop; /* get back what we have so far */subtree2 = tree; /* and new part */arg1 = x.info (subtree1);arg2 = x.info (subtree2);if (x.node (subtree1) = x.const) and (x.node (subtree2) = x.const)   and (x.arg1 (subtree1) = t.var) and (x.arg1 (subtree2) = t.var)   and (((opr <> o.div) and (opr <> o.times)) or (mvtype = t.var))then do; /* must be fixed point, not mul or div */do case (opr - o.minus);arg1 = arg1 - arg2;arg1 = arg1 + arg2;; ; ; ; ; ;arg1 = arg1/arg2;arg1 = arg1*arg2;arg1 = arg1 mod arg2;arg1 = arg1 % arg2;arg1 = arg1 fdiv arg2;arg1 = arg1 and arg2;arg1 = arg1 or arg2;arg1 = arg1 xor arg2;; ; ; ; ;arg1 = arg1 = arg2;arg1 = arg1 < arg2;arg1 = arg1 <= arg2;arg1 = arg1 > arg2;arg1 = arg1 >= arg2;arg1 = arg1 <> arg2;arg1 = arg1 ilt arg2;arg1 = arg1 ile arg2;arg1 = arg1 igt arg2;arg1 = arg1 ige arg2;end;x.info (subtree1) = arg1; tree = subtree1; call x.rel (subtree2); end; else do; tree = x.get; x.arg1 (tree) = subtree1; /* set up block */ x.arg2 (tree) = subtree2; x.info (tree) = opr; /* add in operator type */ x.node (tree) = x.dyad; /* and most important of all, type of node */ end; end; goto EXPEXIT; /* and exit from nonzero priority block */ end; /* of block handling nonzero priority */  /* and our internal branching routine: */  EXPEXIT:; /* come here to exit */  do case (pop); /* get identifier, and branch */    goto EXPLAB0; goto EXPLAB1; goto EXPLAB2; goto EXPLAB3;    ; ; ; goto EXPLAB7;    goto EXPLAB8; goto EXPLAB9; goto EXPLAB10; goto EXPLAB11;    goto EXPLAB12;  end;  end expr;  /* $$Expression compiler section:.  .  The routine 'COMPUTE' takes a binary tree generated by 'EXPR' and.  dumps same out to the interfile in a form that can be reloaded by pass2.*/  dcl subtree fixed; /* global */compute2: proc;dcl tree fixed;dcl (#args, sptr, temp, pvtype, info) fixed;  call push (tree); /* save orig tree */  tree = subtree; /* aids in recursive calls */    do case (x.node (tree)); /* branch on type of node */      do; /* dyadic operator */      call emit (x.node (tree) or shl(x.info (tree), 8)); /* node and info */      subtree = x.arg1 (tree); call compute2; /* write out the first argument */      subtree = x.arg2 (tree); call compute2; /* and compute second argument */    end;      do; /* monadic */      call emit (x.node (tree) or shl(x.info (tree), 8)); /* node and type */      subtree = x.arg1 (tree); call compute2; /* write out subtree */    end;      do; /* constant */      call emit (x.node (tree) or shl(x.arg1 (tree), 8)); /* node and arg1 */      if x.arg1 (tree) = t.var then call emit (x.info (tree)); /* fixed */      else begin; /* floating point - write out two words */        info = x.info (tree); /* get ptr to stack */        call emit (fstk (info)); call emit (fstk (info + 1));        fstk (info) = "100000"; /* free up it */      end;    end; /* constant */      begin; /* variable */      call emit (x.node (tree) or shl(x.arg1 (tree), 8)); /* node and type */      call emit (shr(x.arg1 (tree), 8)); /* storage class */      call emit (x.info (tree)); /* emit relative variable location */      if x.arg1 (tree) then begin; /* emit subscript if one */        subtree = x.arg2 (tree);        call compute2;      end;    end; /* variable */  /* $$Write out expression tree to intermediate file:..   Handle procedure calls and special calls (i.e. input).*/    begin; /* procedure */      call emit (x.node (tree) or shl(x.arg2 (tree), 8)); /* node and type */      info = x.info (tree); /* pick up pointer to stack */      if stable (info + p.key) ige extern.base /* external? */      then call emit (stable (info + p.key)); /* yes, emit external key */      else call emit (shr(stable (info + p.key), 1)); /* no, emit rtp location or key */      call emit (stable (info + p.rtyp) and "377"); /* and emit type returned (fxd, fltg) */      temp = core(shr(x.arg2 (tree), 8) + addr(handles (0))); /* point to alias list for this proc call */      if core(temp) <> stable (info + p.key) then do; /* make sure it's for this proc! */         print;         print '### Compiler system error:  alias list doesn''t match call.';         call exit(-1);      end;      call emit (core(temp + 1)); /* emit word length of list */      do temp = (temp + 2) to (temp + 2) + core(temp + 1) - 1; /* emit alias list */         call emit (core(temp));      end;      #args = stable (info + p.args); /* get number of args */      temp = 1;      do while (temp <= #args); /* loop through */        sptr = info + p.parm - #args - #args + temp + temp; /* going backwards, ptr to stable */        pvtype = x.node (x.arg1 (tree)); /* get type of variable to pass */        if x.arg1 (tree) <> 0 then begin; /* if argument was provided */        call emit (pvtype or "400"); /* emit argument type (the "400" guarantees that PVTYPE is not zero - it is masked off in pass2) */        if (gflag (info) and p.recursive) <> 0 /* are we calling a recursive procedure? */        then call emit (recurs.parms + #args - temp); /* yes, variable location is canonical */        else call emit (stable (sptr + p.ploc)); /* no, send out relative variable location */        if pvtype then do; /* arg is an array type */          call emit (x.arg1 (x.arg1 (tree))); /* emit token type/storage class of array we are passing */          call emit (x.info (x.arg1 (tree))); /* emit variable location, or string const location */        end;        else do; /* is variable */          call push (info); /* save ptr to stack */          call push (temp); call push (#args); call push (pvtype); call push (sptr);          subtree = x.arg1 (x.arg1 (tree));          call compute2; /* emit tree */          sptr = pop; pvtype = pop; #args = pop; temp = pop;          info = pop; /* restore pointer to base of stack */        end;        sptr = x.arg1 (tree);        x.arg1 (tree) = x.arg2 (x.arg1 (tree)); /* link */        call x.rel (sptr); /* and get rid of this one */        end;        temp = temp + 1; /* increment loop counter */      end; /* of arg loop */      call emit (0); /* indicates end of argument list */    end; /* of procedure */      begin; /* X.CAL - emit location and type */      call emit (x.node (tree) or shl(x.arg1 (tree), 8)); /* node and type */      call emit (x.info (tree)); /* location i.d. */    end;    end; /* of do case */  call x.rel (tree); /* get rid of tree */  subtree = tree; /* restore */  tree = pop; /* and pop tree */end compute2;compute: proc; /* compute an expression */   call compute2; /* call the routine to compute the expression */   call clear_heap; /* clear alias list - aliases are only valid during an expression */end compute;