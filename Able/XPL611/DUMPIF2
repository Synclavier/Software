/* The following routine dumps out the intermediate file.  It is only used.  for debugging.  No references to DUMPIF should be found in the "official".  copy of this pass.  Therefore, DUMPIF will not exist in the "official".  version (OPTIMIZE will remove it).  This routine will leave the IF.  positioned where it was when the routine was entered.  It is suggested.  that MAX_SYMBOLS be reduced before inserting this into pass3...  NOTE:  Since this routine uses POSIF and RESETIF with an argument other.  than zero, this routine will NOT operate properly on intermediate files.  larger than 256 sectors.  This is not really a problem because you.  should not be dumping out IFs that large. */dumpif: proc; /* dump the pass2/3 intermediate file (debugging only) */   dcl word    fixed; /* the next word from the IF */   dcl level   fixed; /* indentation level */   dcl curpos  fixed; /* current IF file position */   dcl sys.dev fixed; /* current system device */   dcl (i, j)  fixed;   indent: proc(message, level); /* indent a message */      dcl message array; /* the message to indent */	  dcl level   fixed;      dcl i       fixed;      do i = 1 to level; /* indent this far */         print '   ',;      end;      print string(message),;   end indent;   copytext: proc(n, text, level); /* copy N words to the IF; print in "text" form (change WORD to last word read) */      dcl n     fixed; /* number of words to copy */      dcl text  fixed; /* 1 to include text form; 0 otherwise */	  dcl level fixed;	  dcl word  fixed;      dcl i     fixed;      do n = 1 to n; /* output the data */         call indent ('', level);         word = readif; /* get next word */         print octal(word),;         if text then do; /* only include text if needed */            print '  ',;            do i = 1 to 2; /* output both bytes */               if (word and "140") = 0 /* check for control characters */                then print ' ',; /* output space in place of controls */               else print character(word and "177"),; /* mask to ASCII */               word = shr(word, 8); /* look at second byte */            end;         end; /* of decoding text */         print;      end;   end copytext;   sys.dev = redirection_word; /* save current output device */   redirection_word = outdev; /* redirect output if necessary */   level = 0; /* we're on the left margin */   curpos = posif; /* save current IF position */   word = readif; /* get the first word */   do while (word <> et.eof); /* continue until the EOF */      if (word and literal.mask) <> 0 /* literal word? */      then do; /* yes */         call indent ('literal   ', level); print octal(word), '     sour:  ', octal(word and "377"),;         print '     dest:  ', octal(rot(word, 8) and "377");      end;      else do case (word - 1); /* branch on type */         do; /* literal (same as literal word above) */            i = readif; /* get the literal word */            call indent ('literal  ', level); print octal(i), '     sour:  ', octal(i and "377"),;            print '     dest:  ', octal(shr(i, 8));         end; /* of literal */         do; /* transfer */            call indent ('transfer', level); print;            call indent ('   cond :  ', level); print octal(readif);            call indent ('   label:  ', level); print octal(readif);            call indent ('   eloc :  ', level); print octal(readif); /* estimated location (from preevious pass) */         end; /* of transfer */         do; /* call */            call indent ('call  ', level); i = readif; print i;            call indent ('   label  :  ', level); print octal(readif);            call indent ('   aliases:  ', level); print i - 1;            level = level + 2;            call copytext (i - 1, 0, level); /* print aliases */            level = level - 2;         end; /* of call */         do; /* rtp call */            call indent ('rtp call  ', level); print octal(readif);         end; /* of rtp call */         do; /* variable pointer */            call indent ('variable pointer', level); print;            call indent ('   dest :  ', level); print octal(readif);            call indent ('   class:  ', level); print octal(readif);            call indent ('   ptr  :  ', level); print octal(readif);         end; /* of variable pointer */         do; /* object pointer */            call indent ('object pointer  ', level); print octal(readif);         end; /* of object pointer */         do; /* label definition */            call indent ('label definition  ', level); print octal(readif);         end; /* of label definition */         do; /* data definition */            call indent ('data definition', level); print;            call indent ('   label:  ', level); print octal(readif);            call indent ('   swap :  ', level); print octal(readif);         end; /* of data definition */         do; /* copy data */            call indent ('copy data ', level); i = readif; print i; /* print length */            level = level + 1;            call copytext (i, 1, level); /* output any text */            level = level - 1;         end; /* of copy data */         do; /* copy scon */            call indent ('copy scon ', level); i = readif; print i; /* print length */            call indent ('   proc label :  ', level); print octal(readif);            call indent ('   parm number:  ', level); print octal(readif);            call indent ('   string     :', level); print;            level = level + 2;            call copytext (i - 2, 1, level); /* output any text */            level = level - 2;         end; /* of copy scon */         do; /* ignore */            call indent ('ignore', level); print;         end; /* of ignore */         do; /* procedure definition */            call indent ('procedure definition ', level); i = readif; print (i and "377");            call indent ('   reg parms :  ', level); print octal(shr(i, 8));            call indent ('   label     :  ', level); print octal(readif);            call indent ('   ram base  :  ', level); print octal(readif);            call indent ('   temp base :  ', level); print octal(readif);            call indent ('   attributes:  ', level); print octal(readif);            call indent ('   parms     :  ', level); print i - 4;            level = level + 2;            call copytext (i - 4, 0, level); /* copy procedure args */            level = level - 1; /* we've gone in a level */         end; /* of procedure definition */         do; /* procedure end */            level = level - 1; /* we've now moved out a level */            call indent ('procedure end', level); print;            call indent ('   label    :  ', level); print octal(readif);            call indent ('   ram end  :  ', level); print octal(readif);            call indent ('   temp end :  ', level); print octal(readif);            call indent ('   stack len:  ', level); print octal(readif);            call indent ('   registers:  ', level); print octal(readif);            call indent ('   data swap:  ', level); print octal(readif);            call indent ('-------------------------', level); print;         end; /* of procedure end */         do; /* when definition */            call indent ('when definition', level); print;            call indent ('   label:  ', level); print octal(readif);            level = level + 1; /* we've gone in a level */         end; /* of when definition */         do; /* end when */            level = level - 1; /* we've gone out a level */            call indent ('when end', level); print;            call indent ('   label    :  ', level); print octal(readif);            call indent ('   registers:  ', level); print octal(readif);            call indent ('-------------------------', level); print;         end; /* of end when */         do; /* string constant pointer */            call indent ('string constant pointer', level); print;            call indent ('   dest :  ', level); print octal(readif);            call indent ('   ptr  :  ', level); print octal(readif);            call indent ('   swaps:  ', level); print octal(readif);         end; /* of string constant pointer */         do; /* addr of fixed array parameter */            call indent ('addr of fixed array parameter', level); print;            call indent ('   proc label :  ', level); print octal(readif);            call indent ('   parm number:  ', level); print octal(readif);         end; /* of addr of fixed array parameter */         do; /* sequence number */            call indent ('sequence number ', level); print readif;         end; /* of sequence number */         do; /* symbol */            j = readif; /* get the storage class/length */            i = shr(j, 8); /* extract the storage class */            if      i = t.public  then call indent ('public symbol definition ', level);            else if i = t.extern  then call indent ('external symbol reference ', level);            else do; call indent ('unknown (type =', level); print i, ') symbol reference ',; end;            i = (j and "377"); /* extract record length */            print i; /* print length */            level = level + 1;            j = readif; /* get type/symbol length */            call indent ('type   :  ', level); print shr(j, 8);            call indent ('symlen :  ', level); print (j and "377");            call indent ('info   :  ', level); print octal(readif);            call indent ('storage:  ', level); print readif;            call indent ('lnum   :  ', level); print readif;            call indent ('name   :  ', level); print;            level = level + 1;            j = (j and "377"); /* get symbol length */            call copytext (j, 1, level);            level = level - 1;            i = i - 4 - j; /* get remaining length (if any) */            if i > 0 then do; /* output procedure info */               call indent ('key loc:  ', level); print octal(readif);               call indent ('# args :  ', level); print readif;               call indent ('returns:  ', level); print readif;               do i = 1 to shr(i - 3, 1); /* output argument info */                  call indent ('argument', level); print i;                  level = level + 1;                  call indent ('type:  ', level); print readif;                  call indent ('loc :  ', level); print octal(readif);                  level = level - 1;               end;            end;            level = level - 1;         end; /* of symbol */         do; /* module */            call indent ('module name ', level); i = readif; print i;            level = level + 1;            call indent ('modname len: ', level); print readif;            call indent ('modname    : ', level); print;            level = level + 1;            call copytext ((i and "377") - 1, 1, level);            level = level - 2;         end; /* of module */         do; /* library */            call indent ('library reference ', level); i = readif; print i;            level = level + 1;            call indent ('line number: ', level); print readif;            call indent ('libname len: ', level); print readif;            call indent ('libname    : ', level); print;            level = level + 1;            call copytext ((i and "377") - 2, 1, level);            level = level - 2;         end; /* of library */         do; /* insert */            call indent ('insert filename ', level); i = readif; print i;            if i <> 0 then do; /* zero flags end of insert file */               level = level + 1;               call indent ('filename len: ', level); print readif;               call indent ('filename    : ', level); print;               level = level + 1;               call copytext ((i and "377") - 1, 1, level);               level = level - 2;            end; /* end of start of insert record */         end; /* of insert */         do; /* library definition */            call indent ('library definition ', level);            i = readif; /* get the library number */            print i, ' (', string(loc(addr(lib_name (name_lib (i))))), ')';         end; /* of library definition */         do; /* external symbol reference */            call indent ('external symbol reference ', level);            i = readif; /* get the pointer to the symbol */            print i, ' (', string(loc(get_sym (ptr_sym (i)))), ')';            call indent    ('   key    :  ', level); print octal(readif);         end; /* of external symbol reference */      end; /* of else do case */      word = readif; /* get the next word */   end; /* of do while */   print 'eof';   print '========================================================';   call resetif (curpos); /* reset the IF to where it was before we started */   redirection_word = sys.dev; /* point back to the regular output device */end dumpif;/* The following routine dumps out the contents of the KEY arrays.  (KEYLOC, KEYJTO, and KEYFLAG) in a meaningful way.  No references.  to DUMPKEYS should exist in the "official" version of this compiler.  (so it doesn't exist in the object code of the "official" compiler). */dumpkeys: proc(swaps); /* dump the contents of the KEY arrays (debugging only) */   dcl swaps   fixed; /* TRUE if we're in or after the SWAPS phase of OPTIMIZE */   dcl regs    fixed; /* registers used by proc */   dcl flags   fixed; /* flags for the current procedure */   dcl sys.dev fixed; /* current system device */   dcl (i, j)  fixed;   print_key: proc(key, indent); /* print out the values associated with KEY */      dcl key    fixed; /* the key we want to know about */      dcl indent fixed; /* TRUE if we should indent the print-out */      dcl flags  fixed; /* flags for the current key */      if indent then print '   ',;      print 'key    : ', octal(key);      if indent then print '   ',;      print 'keyloc : ', octal(keyloc (key));      if indent then print '   ',;      print 'keyjto : ', octal(keyjto (key));      flags = keyflag (key); /* get key's flags */      if indent then print '   ',;      print 'keyflag: ', octal(flags),;      if flags <> 0 then do; /* print out flags in human-readable form */         print '    ',;         if (flags and abit) = 0 then print 'in',;         print 'active ',;         if (flags and dbit) <> 0 then print 'defined ',;         if (flags and pbit) <> 0 then print 'procedure',;      end; /* of printing flags */      print;   end print_key;   sys.dev = redirection_word; /* save current output device */   redirection_word = outdev; /* redirect output if necessary */   print;   print;   print 'Contents of the KEY arrays:';   print;   do i = 1 to r (l.key); /* dump out all keys (note: key zero is never allocated!) */      call print_key (i, 0); /* print this key */      if (keyflag (i) and pbit) <> 0 then do; /* for procedures, interpret the locations */         print 'jump key  :';         call print_key (i + proc_jump, 1); /* print the jump around key */         print 'return key:';         call print_key (i + proc_return, 1); /* print the return key */         regs = keyloc (i + proc_regs); /* pick up regs used */         print 'regs used : ', octal(regs),;         if regs <> 0 then do; /* interpret regs */            print '    ',;            do j = 0 to 15; /* loop over registers */               if regs then do; /* this register is used */                  print 'r',;                  if j >= 8 then print '1',;                  print character(a.0 + (j and "7")), ' ',;               end;                           regs = shr(regs, 1); /* look at next register */            end; /* of looping over registers */         end; /* of interpretting registers */         print;         flags = keyflag (i + proc_flags); /* pick up flags */         print 'flags     : ', octal(flags),;         if flags <> 0 then do; /* interpret flags */            print '    ',;            if (flags and p.recursive) <> 0 then print 'recursive ',;            if (flags and p.swap)      <> 0 then print 'swap',;         end;         print;         if not swaps /* if we're not in SWAPS */         then print 'noswap   : ', octal(keyjto (i + proc_noswap));         else if (flags and p.swap) <> 0 /* if swapping proc */         then print 'code size: ', octal(keyjto (i + proc_size));         print 'stack len: ', octal(keyloc (i + proc_stack));         if (flags and p.recursive) <> 0 then do; /* if recursive proc */            print 'temps    : ', octal(keyjto (i + proc_temps));         end;         i = i + proc_keys; /* don't repeat these keys */      end; /* of interpretting proc info */      print;   end; /* of dumping out all keys */   redirection_word = sys.dev; /* point back to the regular output device */end dumpkeys;