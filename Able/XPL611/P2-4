/* Runtime register allocation:.  .  The routine 'REG.ALLC' is called to allocate one of the.  four hardware accumulators (vs. index registers)..  .  'REG.ALLC' is passed a bit encoded word (one bit for each register).  that indicates the registers that must not (!!##$$##@@!!) be used..  .  If there are no desired registers available, one register is selected,.  its current contents are stored in a temporary, and then the.  register is made available..  .  The register is always free after calling 'REG.ALLC'.*/  reg.allc: proc(nono); /* pass registers not to use */   dcl (reg, nono, temp) fixed;   dcl (node, reg1, reg2, ixr) fixed;   dcl (sou1, sou2, fva) fixed;   dcl reg.choose data /* choice vector */      (0, b.ac0, b.ac1, b.ac0,    b.ac2, b.ac0, b.ac1, b.ac0,    b.ac3, b.ac0, b.ac1, b.ac0,    b.ac2, b.ac0, b.ac1, b.ac0);   dcl ofpr data (0, b.ac1, b.ac0, 0, b.ac3, 0, 0, 0, b.ac2); /* other reg */        reg = (reg.pref and (not nono) and 15);    /* compute prefered and not disallowed */   if reg = 0 then reg = ((not nono) and 15); /* if none, then compute those not disallowed */   if (reg and reg.free) <> 0                 /* use it             */   then return reg.choose (reg and reg.free); /* if free, then done */   if ((not nono) and reg.free) <> 0          /* but use non-preferred register instead of storing one in a temp */   then return reg.choose ((not nono) and reg.free);   reg = reg.choose (reg); /* else pick one random register */        /* force register into temp */        node = reg.cont (reg);  /* get pointer to tree node that represents what is in register */   fva = ((x.arg1 (node) and t.fvar) <> 0);   /* see if the register actually points to the desired item,  rather      than containing the desired item.  if so,  move the desired item      (memory) instead of the register */   reg1 = reg;                   /* initialize variables to */   reg2 = 0;                     /* most common case        */   store.preg = 0;   if x.node (node) = x.preg then do; /* pointer register */      sou1 = b.ms + bitreg (reg);      sou2 = sou1;      reg1.to.store = reg1;     /* pass info to getvp in case he     */      reg2.to.store = reg2;     /* needs an accumulator              */      if fva then do;         sou1 = (sou1 or b.ibt);         /* increment first one if floating */         reg2.to.store = reg1.to.store;  /* make sure reg2.to.store is nonzero */      end;      store.preg = 1;   end;   else do; /* must be register */      if fva then do;         if ofpr (reg) < reg          then do; reg1 = ofpr (reg); reg2 = reg;       end;         else do; reg1 = reg;        reg2 = ofpr (reg);end; /* must store in proper order */      end;      sou1 = b.rs + bitreg (reg1);      sou2 = b.rs + bitreg (reg2); /* second source */      reg1.to.store = reg1;     /* pass info to getvp in case he     */      reg2.to.store = reg2;     /* needs an accumulator              */   end;        /*  In the above code, we have set up REG1 and REG2 to indicate which   .   register(s) is/are to be stored in a temporary (fixed or floating)   .   location.  The variables SOU1 and SOU2 have been set up depending   .   on whether the register contains data or a pointer to data.   .     .   Now emit the instructions to store the register(s) or pointed to    .   values in a temporary (fixed or floating) location. */        temp = gtemp (fva);       /* get a fixed or floating temporary */   ixr  = getvp (s.temporary, temp, nono and 15); /* and get pointer to temporary */   if reg1.to.store <> 0 then do;   /* store here if getvp did not */      if fva then do;         call emita (sou1, b.md or b.ibt or ixr);         call emita (sou2, b.md or b.ibt or ixr);         regl = (regl or regbit (ixr)); regc (ixr) = regc (ixr) + 2;      end;      else call emita (sou1, b.md or ixr); /* else store fixed point */      reg1.to.store = 0;      reg2.to.store = 0;      store.preg    = 0;   end;           x.node (node) = x.temp;    x.info (node) = temp;   reg.free = (reg.free or reg1 or reg2);        /* free up regs and adjust node */   call freeup (reg1);   return (reg);  /* done with allocation */end reg.allc;/* LLLIN.REG:.  .   The routine 'IN.REG' is used to load the contents of a node block.   into a fixed point register..  .   IN.REG is passed a node block pointer (in node) to a block.   that was generated by the pass1 expression routine..  .   IN.REG is also passed a bit encoded word that indicates which.   registers are not to be used..  .   IN.REG uses the REG.ALLC routine to find a free register,.   and then emits code to load the contents into a register...   The routine first checks the contents of the registers to see if one of.   the registers contains the constant or variable that is to be loaded in.   the register.  If one is found, it is used.   ..   ****** NOTE: ****** If the register contains a variable, and that.   variable is a subscripted variable, the register actually contains a .   pointer to that element..    .   The global variable 'ZFLAGS' is used to keep track of which.   register contents corresponds to the Z and M flags */in.reg: proc(node, nono) fixed; /* passing it a node, and verboten regs */   dcl (node, nono, reg, type, info) fixed;   dcl (j, k) fixed;   type = x.node (node);    info = x.info (node); /* get data handy */   if (type = x.reg) and ((info and nono) = 0) then return (info); /* already is in an ok reg */   reg = 0;    /* no register found */   if ((type = x.const) or (type = x.var)) then do; /* see if var or const in reg */      j = 1;      do while ((j < 16) and (reg = 0)); /* check 4 accums */        if (j and reg.free and (not nono)) <> 0 then do;           k = trees (j); /* see what is in the register now */           if k <> 0 then do; /* if anything */              if tree.comp (node, k) then reg = j; /* found */           end;        end;        j = shl(j, 1);      end; /* of check 4 accums */   end; /* of var or const */   if reg = 0 then do; /* not there - must load */      if  (type = x.preg)    /* if node is a pointer register */      and ((nono and info) = 0) /* and not disallowed            */      then reg.free = (reg.free or info); /* free up ptr reg here so reg.allc can use it. we know reg.allc will not try to store something in a recursive temp */      reg = reg.allc (nono); /* find free or force temp reg now */      type = x.node (node);  /* look up node type and info again */      info = x.info (node);  /* since it may be a temporary now  */      call sendit (node, b.ad + bitreg (reg), nono and 15); /* and load pointer there */   end;   reg.free = (reg.free and (not reg)); /* register is no longer free */   call freeup (reg);                   /* earlier contents are gone  */   if type = x.reg then do; /* was a register - move tree entry */      trees (reg) = trees (info); trees (info) = 0; /* record movement */   end;   if ((type = x.const) or (type = x.var)) then do; /* constant or variable */      j = x.get; trees (reg) = j; /* allocate block */      x.node (j) = type; x.info (j) = info;      x.arg1 (j) = x.arg1 (node); x.arg2 (j) = x.arg2 (node);   end;   reg.cont (reg) = node; x.node (node) = x.reg;   x.info (node) = reg; x.arg1 (node) = t.var;   return (reg); /* which register */end in.reg;  /* LLLFIN.REG:.  .   The FIN.REG routine is called to load a floating point.   expression into a register..  .   It is passed a pointer to the node block and a bit encoded word that.   represents the registers that must not be used..  .   FIN.REG uses the 'REG.ALLC' routine to allocate a floating point.   register should the need arise...   Note:  FPR0 = AC0 and AC1; FPR1 = AC2 and AC3 */  fin.reg: proc(node, nono) fixed; /* pass node and no good registers */   dcl (node, nono, reg, type, info) fixed;   dcl (reg1, reg2, reg3) fixed;   dcl dreg fixed;        dcl tab1 data (0, 0, 0, b.ac0, 0, 0, 0, b.ac0, 0, 0, 0, b.ac0, b.ac1, b.ac1, b.ac1, b.ac0 or b.ac1); /* convert REG.FREE to floaters */   dcl tab2 data (0, b.ac0, b.ac1, b.ac0); /* convert free to free */        type = x.node (node);    info = x.info (node);   if (type = x.reg) and ((info and nono) = 0) then return (info); /* is in an ok register */        /* allocate registers: */        if  (type = x.preg)       /* if node is a pointer register */   and (in.recursive = 0)    /* and we are not prone to recursive temporaries */   then do;                  /* free up pointer register for use */      if (info = b.ac1) or (info = b.ac3) then reg.free = (reg.free or info); /* free up anyways if ac1 or ac3 */      else if (tab1 (reg.free and 15) and (not nono) and reg.pref) = 0       then reg.free = (reg.free or info); /* free up ac0, 2 only if rest nogo */   end;   reg3 = tab1 (reg.free and 15);         /* see if any floating registers are free */   reg = (reg.pref and (not nono) and 3); /* select preferred non-forbidden register */   if reg = 0 then reg = ((not nono) and 3); /* if preferred is not, then get any */   if (reg and reg3) <> 0 then dreg = tab2 (reg and reg3); /* get one available ones */   else dreg = tab2 (reg); /* else must find one */        reg1 = ffpr (dreg); reg2 = sfpr (dreg); /* select our two registers to hold floating number */        /*      .   In the above code, we have selected two registers (either AC0-AC1 or   .   AC2-AC3) in which to load a floating point variable.   .      .   Now emit the instructions to load the floating point number    .   into the register pair. */        if (type = x.preg) and (reg1 = info) then do; /* check for pointer in first register */      call reg.allc (not reg2); /* free up reg2. */      call emita (b.rs + bitreg (reg1), b.rd + bitreg (reg2)); /* move pointer to reg2 in this special case */      info = reg2; x.info (node) = reg2;   end;        else do; /* else free up the two registers */      call reg.allc (not reg1);      call reg.allc (not reg2);   end;        type = x.node (node);    /* look up node type again           */   info = x.info (node);    /* since reg.allc may have stored it */   call fsendit (node, b.ad + bitreg (reg1), b.ad + bitreg (reg2), reg1); /* and load - ok to use reg2 for recursive variable pointer, since it is loaded last */   call freeup (reg1); call freeup (reg2);   reg.free = (reg.free and (not reg1) and (not reg2));   reg.cont (reg1) = node; reg.cont (reg2) = node;   x.node (node) = x.reg; x.info (node) = dreg; /* type, which one */   x.arg1 (node) = t.fvar; /* type of node is floating variable register */   return (dreg); /* and return which one we put it in */end fin.reg;/* LLLExpression compiler - FIX and FLOAT:.  .   The following routines (FIX, FLOAT) take a node as an argument, and.   return such that the node is a fixed or floating node, as appropriate..  .   Always call COMPUTE before calling FIX or FLOAT. */  fix: proc(node);   dcl node fixed;   dcl (sign, inf1, inf2, exp, pt) fixed;   dcl ff fixed; /* fudge factor - detects int (-1.1) = -2 */        if (x.arg1 (node) and t.fvar) = 0 then return; /* is already fixed point */   if x.node (node) = x.const then do; /* floating constant */      pt = x.info (node); /* extract pointer from doen */      inf1 = fstk (pt); inf2 = fstk (pt + 1); /* and get 32-bits */      sign = (shr(inf1, 15) and 1); /* extract sign bit */      exp = (inf2 and "177"); /* and extract exponent */      ff = 1; /* and assume ok */      inf1 = (inf1 and "077777"); /* isolate mantissa */      inf2 = (inf2 and "177600"); /* and isolate man lsb */      if inf1 <> 0 then do; /* if something to normalize,  then do it */         do while (exp < 64 + 31); /* and loop until ready */            if inf2 then ff = 0; /* clear kludge flag if should */            inf2 = shr(inf2, 1); /* shift right */            if inf1 then inf2 = (inf2 or "100000"); /* propagate carry if should */            inf1 = shr(inf1, 1); /* and shift this right */            exp = exp + 1; /* if reduce mantissa, increase exponent for same result */         end;         if sign then inf2 = (not inf2) + ff; /* negate if minus sign */      end;      fstk (pt) = "100000"; /* and done with FSTK */      x.arg1 (node) = t.var; x.info (node) = inf2; /* and is now fixed */   end; /* of constant */   else do; /* not a constant */      call fin.reg (node, not b.ac0); /* must get in AC0 for fix */      call reg.allc (not b.ac2); call reg.allc (not b.ac3); /* free up all regs */      call em.rtp (l.fix); /* rtp call to fix routine */      call accpurg; /* indicate all registers meaningless */      x.arg1 (node) = t.var; /* regular variable in register now */      x.info (node) = b.ac0; /* here */      reg.free = (b.ac1 or b.ac2 or b.ac3); /* all free */   end; /* of not a constant */end fix;  /* LLLRoutine FLOAT:.  .   The FLOAT routine is used to generate code that will .   convert a fixed point expression to floating point..  .   It is passed the node and returns with the node .   equal to floating point. */  float: proc(node);   dcl node fixed;   dcl (sign, inf1, inf2, exp) fixed;   dcl info fixed; /* temp info */   if (x.arg1 (node) and t.fvar) <> 0 then return; /* already floating */   if x.node (node) = x.const then do; /* check for fixed point constant */      info = x.info (node); /* get current value */      sign = (shr(info, 15) and 1); /* extract sign bit */      if sign then info = -info;      inf2 = info; inf1 = 0; /* initialize */      exp = 64 + 31; /* start here - shl 30 times gives 040, 65 from 1 */      if inf2 <> 0 then do; /* float it */         do while ((inf1 and "040000") = 0);            inf1 = shl(inf1, 1); /* shift left */            if (inf2 and "100000") <> 0 then inf1 = (inf1 or 1); /* or in */            inf2 = shl(inf2, 1); /* 16 bits */            exp = exp - 1; /* and reduce exponent for same */         end;         inf1 = (inf1 or shl(sign, 15)); /* or in sign bit */         inf2 = ((inf2 and "177600") or exp); /* or in exponent */      end;      info = fstr (inf1, inf2); /* store in stack, get ponter */      x.arg1 (node) = t.fvar; x.info (node) = info;   end; /* of floating a constant */   else do; /* not a constant */      call in.reg (node, not b.ac0); /* get node in b.ac0 */      call reg.allc (not b.ac1); call reg.allc (not b.ac2); call reg.allc (not b.ac3); /* free up */      reg.free = (b.ac2 or b.ac3); /* but these ones now free */      call em.rtp (l.flo); /* float it */      call accpurg; /* indicate all registers empty */      x.arg1 (node) = t.fvar; x.info (node) = b.ac0;      reg.cont (b.ac1) = node; /* say what is in b.ac1 too */   end; /* of not a constant */end float;  /* LLLExpression compiler - compute subscript: ..   This routine computes a subscript for a subscripted variable.  It.   is passed the node (with X.NODE (NODE) = X.VAR) which is the variable, .   and returns with X.NODE = X.PREG, (a register pointing to .   where the subscripted beast is located. */  dcl compute proc;dcl subtree fixed; /* used for info to compute */dcl mvt fixed; /* master variable type:  1 means floating, 0 means fixed */  dcl fprs data (0, b.ac0, b.ac0, 0, b.ac1, 0, 0, 0, b.ac1); /* fixed to floating reg */  dcl iffreg procedure(fixed) returns (fixed); subscript: proc(node, val); /* pass node, and value to store in it */dcl (node, val, subscr, reg1, reg2, disp, fva) fixed;dcl (ptr, dat, con) fixed;dcl (rtu, op) fixed; /* indicates register.to.use and operation */dcl (i, j)   fixed;dcl (ffregs) fixed;fva = ((x.arg1 (node) and t.fvar) <> 0); /* true if floating array type */if val <> 0 then do; /* match to array type */   if fva then call float (val); /* float here if array is floating type */   else if (x.arg1 (val) and t.fvar) <> 0 then do; /* else error */      call er.fna; call fix (val);   end;end;reg1 = 0; ptr = 1; /* see if any regs contain pointer to element */if not fva then do while (reg1 = 0) and (ptr < 16); /* if not floating, scan stack */   if (ptr and reg.free) <> 0 then do; /* first make sure free register */      dat = trees (ptr); /* check contents - does not even need be free */      if dat <> 0 then do; /* check contents if any */         if tree.comp (node, dat) then do; /* found */            reg1 = ptr; freetr = x.arg2 (node); call tree.free; /* free up exp */         end;      end;   end;   ptr = shl(ptr, 1);end;if reg1 = 0 then do; /* not found - must compute subscript */   call push (reg.pref); call push (node); call push (val); call push (mvt); call push (fva);   subtree = x.arg2 (node); /* get subscript expression */   mvt = 0; /* and that is fixed point */   if fva then reg.pref = (b.ac1 or b.ac3); /* subscr in these regs for floaters */   else do; /* fxd pt - use desired reg */      ptr = 3; /* see if empty reg - start with 3 */      reg.pref = 0; /* initialize */      do while (reg.pref = 0) and (ptr > 0); /* check 3, 2, 1 */         con = regbit (ptr); /* get bit coded reg # */         if ((reg.free and con) <> 0) and (trees (con) = 0) then reg.pref = con; /* idle, free r */         ptr = ptr - 1;      end;      if reg.pref = 0 then do; /* not found idle reg - check further */         if rtu = 0 then rtu = b.ac3; /* cycle is 3, 2, 1 3, 2, 1, 3, 2, 1 */         if (reg.free and (b.ac1 or b.ac2 or b.ac3)) <> 0 then do while (reg.free and rtu) = 0;            rtu = shr(rtu, 1); if rtu = b.ac0 then rtu = b.ac3;         end;         reg.pref = rtu; rtu = shr(rtu, 1); if rtu = b.ac0 then rtu = b.ac3;      end;   end;   call compute;   fva = pop; mvt = pop; val = pop; node = pop; /* restore variables,  keep reg.pref on stack */   subscr = x.arg2 (node); /* and this is subscript node we just computed */   call fix (subscr); /* and make sure it is fixed point */  /* LLLExpression compiler - subscript computation (cont):.  .   We have computed the subscript and emitted the line number if the user.   so desires..  .   So let's:.     1. check for constant math,.     2. allocate suitable register depending on fixed vs. floating, and.     3. protect the necessary registers. */     ptr = ((x.arg1 (node) and t.pvar) <> 0); /* true if is pointer */   dat = (((x.arg1 (node) and "377") = t.data) or ((x.arg1 (node) and "377") = t.fdata));   con = (x.node (subscr) = x.const);   if (con and (not ptr) and (x.info (node) ilt extern.base)) then do; /* if constant subscript, then do not use register unless needed */      if fva then x.info (subscr) = shl(x.info (subscr), 1); /* double subscript if floating array */      disp = x.info (subscr); reg1 = 0; /* set displacement */      if (dat) or (x.info (node) = 0) then do; /* detect core(3) */         reg1 = reg.allc (0); /* get any register if data type */         if dat then call em.spt (x.info (node) + disp, b.ad + bitreg (reg1)); /* load ptr */         else call emitc (disp, b.ad + bitreg (reg1)); /* detect core(const) */         call freeup (reg1);         trees (reg1) = subscr; /* indicate in register */      end;      else call x.rel (subscr); /* else done with subscript node */   end;   else do; /* else we must use a register */      disp = 0; /* no displacement */      if (con and (x.info (subscr) = 0)) then do; /* zero subscript ptr - check - this applies to references to external(0) and pvar(0) */         reg1 = 0; op = 0; i = 1;         if ptr then do;   /* if is pointer,  see if is in register (proc call) */            do while (reg1 = 0) and (i < 16); /* scan to see what is in regs */               j = trees (i);               if j <> 0 then do; /* see if points there */                  if  (x.node (j) = x.var)                   and (x.info (j) = x.info (node))                   and (x.arg1 (j) = (t.var or (x.arg1 (node) and (not "377"))))                  then reg1 = i;               end;               i = shl(i, 1);            end;         end;         if reg1 = 0 then do; /* must allocate and load */            reg1 = reg.allc (0); /* get any register */            op = b.ad + b.loa; /* must load subscript pointer (no add) */         end;         call freeup (reg1); trees (reg1) = subscr; /* this is it */      end;      else do; /* is not a constant of zero */         reg1 = in.reg (subscr, 0); /* get in any register */         op = b.ad + b.add; /* else add */         if fva then call emita (b.rs + bitreg (reg1), b.ad + b.add + bitreg (reg1)); /* double subscript for floaters */         call x.rel (subscr); /* believe it or not we are through with subscr */      end;      if op <> 0 then do; /* must load if so */         if dat then call em.spt (x.info (node), op + bitreg (reg1)); /* data ptr */         else if x.info (node) <> 0 then do; /* skip the following for 'CORE' */            reg2 = getvp (shr(x.arg1 (node), 8), x.info (node), reg1); /* get pointer to array base or to array pointer */            if ptr then call emita (b.ms + reg2, op + bitreg (reg1)); /* add in ptr if pointer */            else call emita (b.rs + reg2, op + bitreg (reg1)); /* else add in register */         end;      end;   end;   if reg1 <> 0 then do; /* if subscript ended up in register, look: */      if fva then call freeup (reg1); /* nothing to do here */      else if trees (reg1) <> 0 then do; /* if was a keep trackable item bingo*/         reg2 = x.get;          x.node (reg2) = x.var;          x.arg1 (reg2) = x.arg1 (node);         x.arg2 (reg2) = trees  (reg1);          x.info (reg2) = x.info (node);         trees (reg1) = reg2; /* indicate this register contains ptr */       end;   end;   reg.pref = pop; /* and restore prefered registers */end; /* of actually computing subscript pointer register */  /* LLLExpression compiler - compute subscript (cont):.  .   In the above code, we have computed the subscript, loaded it.   into a register (unless it is a constant), and then added the.   array base (or pointer to same) to the subscript..  .   Now determine whether or not we are storing data into the.   array (if val <> 0) and handle accordingly. */     if val = 0 then do;      /* if not assignment */      if reg1 = 0 then do;  /* if no register, then change to variable */         x.node (node) = x.var;          x.arg1 (node) = ((x.arg1 (node) and t.fvar) or (x.arg1 (node) and (not "377")));         x.info (node) = x.info (node) + disp;      end;      else do;      /* else we have generated a pointer register */         x.node (node) = x.preg;          x.arg1 (node) = (x.arg1 (node) and t.fvar);          x.info (node) = reg1;         reg.free = (reg.free and (not reg1)); reg.cont (reg1) = node; /* register is used, set up pointer */      end;   end;   else do; /* else we must be assigning */      if reg1 = 0 then do; /* just pointer */         if  (x.node (val) = x.var               ) /* if node is variable  */         and (x.arg1 (val) = x.arg1 (node)       ) /* of same class & type */         and (x.info (val) = x.info (node) + disp) /* at same location     */         then do;            /* nothing to do; skip assigment of a (1) = a (1) since it blows up with floating */            /* point due to increment bit                                                 */         end;         else do;                  /* else emit instructions */            if fva then do;        /* floating assignment    */               ffregs = iffreg(val);               reg2 = getvp (shr(x.arg1 (node), 8), x.info (node) + disp, ffregs); /* get pointer into data area */               call fsendit (val, b.md + b.ibt + reg2, b.md + b.ibt + reg2, ffregs or regbit(reg2)); /* store data */               regl = (regl or regbit (reg2)); regc (reg2) = regc (reg2) + 2;            end;            else do;               reg2 = getvp (shr(x.arg1 (node), 8), x.info (node) + disp, 0); /* get pointer into data area */               call sendit (val, b.md + reg2, regbit (reg2)); /* else store the data */            end;         end;      end;      else do;         if fva then do;            ffregs = iffreg (val);            call fsendit (val, b.md + b.ibt + bitreg (reg1), b.md + b.ibt + bitreg (reg1), reg1 or ffregs); /* floating store */         end;         else call sendit (val, b.md + bitreg (reg1), reg1); /* else store node in thing - a - ma - jig */         reg.free = (reg.free or reg1); /* and free up pointer register after store */      end;   end; /* of assignment */   if fva then return (fprs (reg1)); /* indicate which floating register contains pointer */   else return (reg1); /* else this is fixed register which contains pointer */end subscript;