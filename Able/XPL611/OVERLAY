insert ':-xpl:literals'; /* general definitions */insert ':-xpl:asciilit'; /* ASCII definitions */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:strings'; /* string manipulation */insert ':-xpl:dynamic'; /* dynamic memory allocation */insert ':-xpl:scanargs'; /* command line argument scanning (pass1 only) *//* The following routine is used to transfer control to the object.  file (in case of run) or to the monitor (in case of compile)...  WARNING:  This does not work with loader ROMs made before Sept 1979.            or with MONITOR or loader routines dated before Dec  1984. */overlay: proc(device, start, len); /* special routine to overlay an object file */  dcl (device, start, len, i) fixed;  i = loc.load + 1; /* enter word 1 of loader routine */  write("300") = device; /* device code/MSByte of start */  write("301") = start; /* start */  write("302") = 0; /* dest */  write("303") = len; /* move the amount here */  write("320") = i; /* and enter highcore copy routine */end overlay;dcl getresponse proc (fixed); /* routine to change disks */dcl ndisk       fixed; ndisk = 0; /* device of floppy if current disk isn't the original disk (set by OPEN, cleared by user) */  exit: proc(sts); /* and exit routine */  dcl sts fixed;  if ndisk <> 0 then do; /* was this library from a different disk? */     print 'Re-insert original user diskette into ',;     call getresponse (ndisk); /* get the original disk */  end;  core(loc.rst) = sts; /* store status */  call overlay (core(loc.mon + 1), core(loc.mon), core(loc.mon - 1)); /* do it */end exit;wait_for_break: proc; /* wait for a break to finish */   dcl i fixed;   write("3") = 0; write("3") = 0; /* synchronize with D3 */   do i = 1 to 30*d03_speed; /* wait 300 ms */      write ("3") = 0; /* wait 3 ms */   end;end wait_for_break;set_extmem: proc(start, finish, val); /* set external memory to VAL */   dcl start  fixed; /* starting sector */   dcl finish fixed; /* ending sector */   dcl val    fixed; /* value to assign */   dcl (i, j) fixed;   do i = start to finish - 1 by 64;      j = finish - i; /* get sectors left to set */      if j igt 64 then j = 64; /* limit to 64 */      call extset (i, 0, shl(j, 8), val); /* set external memory */   end;end set_extmem;/* Open routines:..   OPEN is called to open up an insert file during an 'INSERT' or.   'LIBRARY' statement.  OPEN asks the user to insert a second disk.   during compilation if the file is not saved on the current disk..   The flag NEWDISK is set if a new disk is used to open the file.*/ dcl catbuf (c#dir_max - 1) fixed; /* the catalog buffer */dcl cat_cache fixed; /* cache number of the catalog cache */dcl newdisk   fixed; newdisk = 0; /* device of floppy if we changed floppy disks to open this file */call set_catbuf (addr(catbuf (0)), 0); /* set up catalog buffer */cat_cache = cache (c#bufptr, c#bufmed); /* cache the catalog buffer in itself */call enter_alternate ('', 1); /* start searches from the current catalog */call cache_treename (true); /* cache the treename path */  /* special routine to allow user to swap floppy disks */getresponse: proc(dev); /* change floppies */   dcl dev fixed; /* device to ask for floppy from */   dcl i   fixed;   do case (dev - 2); /* only FLOPPIES allowed */      print 'F0',;      print 'F1',;      print 'R0',;      print 'R1',;   end;   print ' and press RETURN ->',;   if (read("51") and "2") <> 0 then i = read("50"); /* ignore typeahead */   i = 0;   do while (i <> a.cr); /* and wait for carriage return */     i = (read("50") and "177"); /* get character */     if i = a.nul then call exit(-1); /* stop if break */   end;   print;   call enable_cache (cat_cache); /* disable the catalog cache for next catalog read only */   call cache_treename (true); /* reset path cache */end getresponse;/* The following routine prints an error message related to any error.  returned by the catalog routines (or OPEN). */cat_err: proc; /* print catalog call error message */   do case (c#status); /* branch on status */      ; /* good status (must have found it) */      print '### Operating system error.';      print '### No catalog buffer.';      print '### No directory read into memory.';      print 'Device ', string(f#name), ' is not configured in your system',;      print 'No floppy disk in drive',;      print '### FCB number out of bounds.';      print '### Level number out of bounds.';      print '### Out of room on disk.';      print '### Not enough contiguous room on disk.';      print '### No directory entries left.';      print 'Validity error in catalog ', string(f#name),;      print 'Invalid character in filename ', string(f#name),;      print '### Duplicate filename.';      print 'File ', string(f#name), ' not found',;      print string(f#name), ' is not a catalog',;      print 'Incorrect format for treename',;      print 'Catalog ', string(f#name), ' not found',;      print '### Types don''t match on REPLACE.';      print '### Floppy is write protected.';      print '### File too large.';   end; /* of status messages */end cat_err;/* The following routine will update the file length of the file with.  the specified name in the specified catalog...  NOTE:  To be conservative, this routine will NOT let you update the.         length of a file that was read in from a disk other than the.         one originally searched (if OPEN was called to open the file). */update_length: proc(name, level, new_length); /* update file length of specified file */   dcl name            fixed array; /* name of file to update the length of */   dcl level           fixed; /* catalog the file is stored in */   dcl new_length      fixed; /* the new length */   dcl fcb (f#len - 1) fixed;   dcl i               fixed;   if ndisk <> 0 then do; /* if we've changed disks, we're in trouble */      print;      print '### Compiler system error:  disks changed before file''s length updated.';      call exit(-1);   end;   call read_catalog ('', level); /* read in the specified catalog */   i = findfile (name); /* look up the file */   if i = -1 then do; /* it better be there */      print;      print '### Compiler system error:  attempting to set non-existent file''s length.';      call exit(-1);   end;   call get_fcb (i, fcb); /* get the file's FCB */   if ((new_length igt shl(fcb (f#ll), 8)) and (fcb (f#ll) ilt 256) and (fcb (f#ml) = 0)) then do; /* can't set the length greater than the true length */      print;      print '### Compiler system error:  attempting to set file length beyond end of file.';      call exit(-1);   end;   fcb (f#wd) = new_length; /* update the length */   call put_fcb (i, fcb); /* write out the altered FCB */   call write_catalog; /* and write out the altered catalog */end update_length;/* Open a file with a specified treename.  Since this routine calls LOCATE,.   the same variables are set if the file is successfully opened.  If the.   file isn't found on the alternate catalog, the system catalog and.   then (possibly) another floppy disk are checked. */open: proc(treename) returns (boolean); /* open a treename specified file */   dcl treename fixed array; /* the treename of the file to open */   dcl user_dev fixed; /* current device */   dcl found    boolean; /* TRUE if we found it */   found = locate (treename, -1); /* try to open the file */   user_dev = shr(core(loc.ucat + 1), 8); /* pick up user device */   if ((not found) and ((c#status = e#no_file) or (c#status = e#no_path)) /* if haven't found it yet, search around */   and ((byte(treename, 0) = a.colon) or (f#name (0) = treename (0))) /* if top-level search or no patchname specified (if no pathname, F#NAME = TREENAME) */   and ((a#ms_sector <> core(loc.scat + 1)) or (a#ls_sector <> core(loc.scat)))) /* and we haven't searched the system catalog above? */   then found = locate (treename, 0); /* then search the system catalog */   if ((not found) and ((c#status = e#no_file) or (c#status = e#no_path)) /* STILL didn't find it? */   and (user_dev >= 2) and (user_dev < 6)) /* and current device is a floppy */   then do; /* this is beginning to look hopeless */      print;      print 'Insert diskette containing file "', string(treename), '"';      print 'into ',;      call getresponse (user_dev); /* get the new floppy */      found = locate (treename, user_dev); /* look on F1 */      newdisk = user_dev; /* we now have a new disk on USER_DEV */      if ((systyp = 0) and ((user_dev = 2) or (user_dev = 3))) /* if floppy system and we changed F0 or F1 */      then ndisk = user_dev; /* make sure we get the original back */   end; /* of still haven't found it */   else newdisk = 0; /* didn't need a new disk for this file */   return (found); /* return whether we found it */end open;