/* $title Dump Relocatable Files *//* This program dumps relocatable files by calling DUMPIF.   By:  Karim J. Chichakly on 16 July 1987*//*	Translated to C:   	02/23/99 at 12:20	*//*	Translator Version:	0.000				*/#include	"XPL.h"#include	"dumprel.h"/* Define the ASCII character set (and some special VT100 characters) *//* control characters */#define	c_a					0x0001										// ctrl-a#define	c_b					0x0002										// ctrl-b#define	c_c					0x0003										// ctrl-c#define	c_d					0x0004										// ctrl-d#define	c_e					0x0005										// ctrl-e#define	c_f					0x0006										// ctrl-f#define	c_g					0x0007										// ctrl-g#define	c_h					0x0008										// ctrl-h#define	c_i					0x0009										// ctrl-i#define	c_j					0x000A										// ctrl-j#define	c_k					0x000B										// ctrl-k#define	c_l					0x000C										// ctrl-l#define	c_m					0x000D										// ctrl-m#define	c_n					0x000E										// ctrl-n#define	c_o					0x000F										// ctrl-o#define	c_p					0x0010										// ctrl-p#define	c_q					0x0011										// ctrl-q#define	c_r					0x0012										// ctrl-r#define	c_s					0x0013										// ctrl-s#define	c_t					0x0014										// ctrl-t#define	c_u					0x0015										// ctrl-u#define	c_v					0x0016										// ctrl-v#define	c_w					0x0017										// ctrl-w#define	c_x					0x0018										// ctrl-x#define	c_y					0x0019										// ctrl-y#define	c_z					0x001A										// ctrl-z#define	a_nul				0x0000										// null#define	a_null				0x0000										// null#define	a_soh				0x0001										// soh#define	a_stx				0x0002										// stx#define	a_etx				0x0003										// etx#define	a_eot				0x0004										// eot#define	a_enq				0x0005										// enq#define	a_ack				0x0006										// ack#define	a_bel				0x0007										// bell#define	a_bs				0x0008										// backspace#define	a_ht				0x0009										// tab#define	a_lf				0x000A										// linefeed#define	a_vt				0x000B										// vert. tab#define	a_ff				0x000C										// formfeed#define	a_cr				0x000D										// return#define	a_so				0x000E										// so#define	a_si				0x000F										// si#define	a_dle				0x0010										// dle#define	a_dc1				0x0011										// dc1#define	a_xon				0x0011										// xon#define	a_dc2				0x0012										// dc2#define	a_dc3				0x0013										// dc3#define	a_xoff				0x0013										// xoff#define	a_dc4				0x0014										// dc4#define	a_nak				0x0015										// nak#define	a_syn				0x0016										// syn#define	a_etb				0x0017										// etb#define	a_can				0x0018										// can#define	a_em				0x0019										// em#define	a_sub				0x001A										// sub#define	a_esc				0x001B										// escape#define	a_fs				0x001C										// file separator#define	a_gs				0x001D										// group separator#define	a_rs				0x001E										// record separator#define	a_us				0x001F										// unit separator/* punctuation */#define	a_sp				0x0020										// space#define	a_space				0x0020										// space#define	a_exclam			0x0021										//   !#define	a_quote				0x0022										//   "#define	a_sharp				0x0023										//   ##define	a_dollar			0x0024										//   $#define	a_percent			0x0025										//   %#define	a_and				0x0026										//   &#define	a_apost				0x0027										//   '#define	a_lparen			0x0028										//   (#define	a_rparen			0x0029										//   )#define	a_star				0x002A										//   *#define	a_plus				0x002B										//   +#define	a_comma				0x002C										//   ,#define	a_minus				0x002D										//   -#define	a_period			0x002E										//   .#define	a_slash				0x002F										//   /#define	a_colon				0x003A										//   :#define	a_semicolon			0x003B										//   ;#define	a_less				0x003C										//   <#define	a_equals			0x003D										//   =#define	a_greater			0x003E										//   >#define	a_question			0x003F										//   ?#define	a_at				0x0040										//   @#define	a_lbracket			0x005B										//   [#define	a_backslash			0x005C										//   \#define	a_rbracket			0x005D										//   ]#define	a_cflex				0x005E										//   ^#define	a_score				0x005F										//   _#define	a_grave				0x0060										//   `#define	a_lbrace			0x007B										//   {#define	a_bar				0x007C										//   |#define	a_rbrace			0x007D										//   }#define	a_tilde				0x007E										//   ~#define	a_del				0x007F										// delete#define	a_delete			0x007F										// delete/* digits */#define	a_0					0x0030										// 0#define	a_1					0x0031										// 1#define	a_2					0x0032										// 2#define	a_3					0x0033										// 3#define	a_4					0x0034										// 4#define	a_5					0x0035										// 5#define	a_6					0x0036										// 6#define	a_7					0x0037										// 7#define	a_8					0x0038										// 8#define	a_9					0x0039										// 9/* uppercase letters */#define	a_a					0x0041										// A#define	a_b					0x0042										// B#define	a_c					0x0043										// C#define	a_d					0x0044										// D#define	a_e					0x0045										// E#define	a_f					0x0046										// F#define	a_g					0x0047										// G#define	a_h					0x0048										// H#define	a_i					0x0049										// I#define	a_j					0x004A										// J#define	a_k					0x004B										// K#define	a_l					0x004C										// L#define	a_m					0x004D										// M#define	a_n					0x004E										// N#define	a_o					0x004F										// O#define	a_p					0x0050										// P#define	a_q					0x0051										// Q#define	a_r					0x0052										// R#define	a_s					0x0053										// S#define	a_t					0x0054										// T#define	a_u					0x0055										// U#define	a_v					0x0056										// V#define	a_w					0x0057										// W#define	a_x					0x0058										// X#define	a_y					0x0059										// Y#define	a_z					0x005A										// Z/* lowercase letters */#define	l_a					0x0061										// a#define	l_b					0x0062										// b#define	l_c					0x0063										// c#define	l_d					0x0064										// d#define	l_e					0x0065										// e#define	l_f					0x0066										// f#define	l_g					0x0067										// g#define	l_h					0x0068										// h#define	l_i					0x0069										// i#define	l_j					0x006A										// j#define	l_k					0x006B										// k#define	l_l					0x006C										// l#define	l_m					0x006D										// m#define	l_n					0x006E										// n#define	l_o					0x006F										// o#define	l_p					0x0070										// p#define	l_q					0x0071										// q#define	l_r					0x0072										// r#define	l_s					0x0073										// s#define	l_t					0x0074										// t#define	l_u					0x0075										// u#define	l_v					0x0076										// v#define	l_w					0x0077										// w#define	l_x					0x0078										// x#define	l_y					0x0079										// y#define	l_z					0x007A										// z/* meta characters for VT100 escape sequences */#define	cur_up				0x0081										// cursor up#define	cur_down			0x0082										// cursor down#define	cur_right			0x0083										// cursor right#define	cur_left			0x0084										// cursor left#define	cur_home			0x0085										// cursor home#define	pf_1				0x0086										// pf key 1#define	pf_2				0x0087										// pf key 2#define	pf_3				0x0088										// pf key 3#define	pf_4				0x0089										// pf key 4#define	kp_0				0x008A										// keypad 0#define	kp_1				0x008B										// keypad 1#define	kp_2				0x008C										// keypad 2#define	kp_3				0x008D										// keypad 3#define	kp_4				0x008E										// keypad 4#define	kp_5				0x008F										// keypad 5#define	kp_6				0x0090										// keypad 8#define	kp_7				0x0091										// keypad 7#define	kp_8				0x0092										// keypad 8#define	kp_9				0x0093										// keypad 9#define	kp_comma			0x0094										// keypad comma#define	kp_minus			0x0095										// keypad minus#define	kp_dot				0x0096										// keypad dot#define	kp_enter			0x0097										// keypad enter#define	a_refresh			0x0098										// refresh display/* Catalog routines (no swapping) */_library(":-xpl:libs:catrtns")/* Syslits   $title  system-wide literals   Modified:   11/11/96 - CWJ - Changed order of declaration to assist with XPL translations   08/14/91 - MWH - Added option bit for DSP   02/07/91 - MWH - Added option bits for Poly Voice Type and the D164*//* $subtitle Configuration Information *//* Every XPL program has a configuration area in lowcore (pointed.  to by the contents of the word at address ONE of the program)..  The following definitions define the configuration area: */extern	fixed	mem_siz;												// holds memory size - required to use these literals#define	c_contab			able_core(1)								// pointer to the configuration table/* compiler information [accessed via CORE(C#CONTAB + <literal>)] */#define	c_vstart			0											// start  of variable area#define	c_vlngth			1											// length of variable area#define	c_stklen			2											// length of stack area#define	c_objloc			3											// start  of object code#define	c_objlen			4											// length of object code#define	c_swploc			c_objlen									// pointer to swap area#define	c_swpram			5											// pointer to swapping mechanism ram area#define	c_swplen			6											// length of swap file (in sectors)#define	c_rtploc			7											// start  of RTP#define	c_inttab			8											// pointer to WHEN statement table#define	c_rcvptr			9											// pointer to RCVDCHARACTER#define	c_inpbuf			10											// pointer to terminal INPUT buffer#define	c_sbrsbw			11											// pointer to special READ/WRITE word pair#define	c_curtrk			12											// pointer to disk head position words (F0/F1/R0/R1, in that order)#define	c_devtab			13											// pointer to additional device driver table#define	c_offset			16											// highcore configuration table starts here/* system configuration/options */#define	c_memsiz			16											// memory size (in sectors)#define	c_cmopt				17											// computer and music options#define	memory_sectors		able_core(c_contab + c_memsiz)				// memory size (in sectors)#define	options_word		able_core(c_contab + c_cmopt)				// computer and music options#define	memory_size			shl(memory_sectors, 8)						// memory size (in words)#define	processor_type		(shr(options_word, 8) & 0x0007)				// processor type (0: Model A, 1: Model B, 2: Model C, etc.#define	d03_speed			2											// hardcode to 200 Hz for now/* option bits *//* d03 speed was in lower 3 bits; a 0 or  a 1 */#define	o_bootable			0x0002										// set in options word if program is self-booting#define	o_d4567				0x0008										// set in options word if D4567 is in system#define	o_d40				0x0010										// set in options word if D40 (printer) is in system#define	o_d164				0x0020										// set in options word if D164 (kbd filter/trigger bd) is in system#define	o_d44				0x0040										// set in options word if D44 (mouse) is in system#define	o_pvoice			0x0080										// set in options word if mono/3200 poly voices are installed#define	o_proct				0x0700										// processor type field#define	o_dsp				((fixed) 0x1000)							// set in options word if DSP is attached to DTD#define	o_d66				((fixed) 0x2000)							// set in options word if D66 is in system#define	o_d130				((fixed) 0x4000)							// set in options word if D130 is in system#define	o_d160				((fixed) 0x8000)							// set in options word if D160 is in system/* option tests */#define	d4567_present		((options_word & o_d4567)  != 0)			// True if D4567 is in system#define	d40_present			((options_word & o_d40)    != 0)			// True if D40 is in system#define	d164_present		((options_word & o_d164)   != 0)			// True if D164 is in system#define	mouse_present		((options_word & o_d44)    != 0)			// True if D44 is in system#define	mono_voices_present	((options_word & o_pvoice) != 0)			// True if 3200/mono poly voices are in system#define	dsp_present			((options_word & o_dsp)    != 0)			// True if DSP is attached to DTD#define	d66_present			((options_word & o_d66)    != 0)			// True if D66 is in system#define	d130_present		((options_word & o_d130)   != 0)			// True if D130 is in system#define	d160_present		((options_word & o_d160)   != 0)			// True if D160 is in system/* terminal/printer information */#define	c_ptype				18											// terminal information#define	c_stype				19											// printer information#define	c_redrct			20											// redirection word#define	terminal_info		able_core(c_contab + c_ptype)				// terminal information#define	printer_info		able_core(c_contab + c_stype)				// printer information#define	redirection_word	able_core(c_contab + c_redrct)				// redirection word#define	terminal_model		shr(terminal_info, 8)						// terminal model#define	terminal_type		(shr(terminal_info, 8) & 0x001F)			// terminal type#define	terminal_graphics	shr(terminal_info, 13)						// terminal graphics#define	terminal_nulls		(terminal_info & 0x00FF)					// terminal nulls#define	printer_type		(shr(printer_info, 8) & 0x001F)				// printer  type#define	printer_graphics	shr(printer_info, 13)						// printer  graphics#define	printer_nulls		(printer_info & 0x00FF)						// printer  nulls#define	directed_output		(redirection_word & 0x00FF)					// output redirection information (0: to terminal; 1: to printer)#define	directed_input		shr(redirection_word, 8)					// input redirection information (0: from terminal; 1: from printer)#define	no_redirection		0											// cancel all redirection by setting REDIRECTION_WORD to this/* $page *//* graphics */#define	g_vt640				1#define	g_dq640				2#define	g_mg600				3#define	g_macintosh			4/* terminal models */#define	t_unknown			0#define	t_hardcopy			1#define	t_adm3				2#define	t_vt100				3#define	t_datamedia			4#define	t_z19				5#define	t_vt640				(t_vt100 | shl(g_vt640, 5))					// Vt100 w/graphics G#VT640#define	t_dq640				(t_vt100 | shl(g_dq640, 5))					// Vt100 w/graphics G#DQ640#define	t_mg600				(t_vt100 | shl(g_mg600, 5))					// Vt100 w/graphics G#MG600#define	t_macintosh			(t_vt100 | shl(g_macintosh, 5))				// Vt100 w/graphics G#MACINTOSH/* printer types */#define	p_unknown			0#define	p_deciii			9#define	p_la34				10											// Decwriter IV - has graphics capabilities#define	p_printronix		11											// has graphics capabilities#define	p_prism				12											// has graphics capabilities#define	p_diablo			13											// has graphics capabilities/* operating system version */#define	c_version			21											// configuration/system version number minus six (-6 is 0, -7 is 1, etc)#define	c_current_version	1											// current OS version is -7/* storage device information */#define	c_curdev			23											// current device (physically encoded)#define	c_sysdev			24											// system device (physically encoded)#define	current_device		(able_core(c_contab + c_curdev))			// current device (physically encoded)#define	system_device		(able_core(c_contab + c_sysdev))			// system device (physically encoded)#define	curtyp				(current_device & 0x000F)					// current device type (0=floppy, 1=winchester, 2=remote)#define	systyp				(system_device  & 0x000F)					// system  device type (0=floppy, 1=winchester)#define	c_strdev			24											// start of storage device table#define	c_strend			104											// end   of storage device table (plus one)#define	c_strlen			(c_strend - c_strdev)						// length of storage device table/* storage device table entry layout *//* For storage device table usage: checkout :xpl:scsi for interpration.								*//* Also: :utilcat:condev sets them, somewhat differently...											*/#define	s_devtyp			0											// 8 bits:					4 bits:				4 bits:/* 	1 = Scsi					0 = drive 0			0 = Floppy				*//* 								1 = drive 1			1 = W0/W1 winchester	*//*													2 = R0/r1 floppy		*//*													3 = T0/t1 tape			*//*													4 = O0/o1 optical		*//*	5 = for M/O Optical														*//* e.g bits 10,11: 0 == 12", 1 == 5"										*/#define	s_seccyl			1											// sectors/cylinder#define	s_totcyl			2											// total cylinders#define	s_spdtrk			3											// sectors per track/stepping speed for floppies#define	s_devadr			3											// device address (drive/controller) for Winchesters/* 4 bits: unknown	4 bits: LUN		4 bits: which board		4 bits: target	*//* note: for board 1, LUN becomes host ID and LUN is zero					*/#define	s_blklen			4											// length of device table entry#define	s_freblk			-1											// indicates a free block in the device table#define	c_conlen			c_strend									// length of configuration table (since the storage table is last)/* D40q baud rates (SHL by 8 before writing to D41, D43, D45, or D51) */#define	b_300				0											// 300 baud#define	b_1200				1											// 1200 baud#define	b_2400				2											// 2400 baud#define	b_4800				3											// 4800 baud#define	b_9600				4											// 9600 baud#define	b_19200				5											// 19200 baud#define	b_38400				6											// 38400 baud#define	b_76800				7											// 76800 baud#define	b_enable			((fixed) 0x8000)							// Or in to enable baud rate selection/* $subtitle Symbolic Definitions For Upper Memory *//* The ABLE Series Monitor stores many important items of information.  in the upper part of memory in order to preserve them between.  program overlays (and to pass certain information to cooperative.  programs).  This information includes items such as the name of.  the user's current file, where on the disk it is stored, etc. *//* current file definitions */#define	loc_cfn				(mem_siz -   5)								// current file name#define	loc_ftyp			(mem_siz -   6)								// current file type#define	loc_svd				(mem_siz -   7)								// True if file is saved#define	loc_strd			(mem_siz -   8)								// True if file stored#define	loc_strn			(mem_siz -  13)								// stored name of file#define	loc_cmed			(mem_siz -  14)								// current file media:  0 = file, 1 = core#define	loc_csec			(mem_siz -  16)								// starting sector/device of current file or word ptr if in core#define	loc_csln			(mem_siz -  17)								// number of sectors in current file#define	loc_clen			(mem_siz -  18)								// current file length mod 64K/* system, path, and user (current) catalog definitions */#define	loc_scat			(mem_siz -  20)								// system catalog sector#define	loc_sctl			(mem_siz -  21)								// system catalog length#define	loc_smax			(mem_siz -  23)								// system catalog maximum#define	loc_pcat			(mem_siz -  25)								// path   catalog sector (0 if no path)#define	loc_pctl			(mem_siz -  26)								// path   catalog length#define	loc_pmax			(mem_siz -  28)								// path   catalog maximum#define	loc_pcnm			(mem_siz -  33)								// path   catalog name#define	loc_ucat			(mem_siz -  35)								// user   catalog sector#define	loc_uctl			(mem_siz -  36)								// user   catalog length#define	loc_umax			(mem_siz -  38)								// user   catalog maximum#define	loc_ccnm			(mem_siz -  43)								// user   catalog name/* work file definitions */#define	loc_wmed			(mem_siz -  44)								// work file media:  0 = file, 1 = core#define	loc_wsec			(mem_siz -  46)								// starting sector of work file or word ptr if in core#define	loc_wsln			(mem_siz -  47)								// number of sectors in work file#define	loc_wlen			(mem_siz -  48)								// work file length mod 64K/* command file definitions */#define	loc_perform			(mem_siz -  49)								// indicates in a command file#define	loc_perptr			(mem_siz -  50)								// byte pointer into command file#define	loc_perfsec			(mem_siz -  52)								// starting sector of command file#define	loc_perflen			(mem_siz -  53)								// word length of command file/* system file locations/lengths (named after the system file they're most often used for) */#define	loc_mon				(mem_siz -  55)								// monitor (starting sector at LOC.MON, word length (or -1) at LOC.MON - 1)#define	loc_p1				(mem_siz -  58)								// pass1#define	loc_p2				(mem_siz -  61)								// pass2#define	loc_p3				(mem_siz -  64)								// pass3#define	loc_st				(mem_siz -  67)								// symbol table#define	loc_rt				(mem_siz -  70)								// runtime file#define	loc_mplt			(mem_siz -  73)								// music printing/* overlay parameters/return values */#define	loc_rst				(mem_siz -  75)								// run status (to MONITOR)#define	loc_usr1			(mem_siz -  76)								// user defined#define	loc_usr2			(mem_siz -  77)								// user defined#define	loc_usr3			(mem_siz -  78)								// user defined/* monitor bit definitions */#define	loc_monbits			(mem_siz -  79)								// bits for monitor ON/OFF states#define	m_log				0x0001										// history logging on/off#define	m_w0_ej				0x0002#define	m_w1_ej				0x0004/* words (MEM.SIZ - 80) through (MEM.SIZ - 82) are currently unused *//* $page *//* Monitor state variables */#define	loc_tyb				(mem_siz - 138)								// 110 char tty buffer (plus length)#define	loc_tybp			(mem_siz - 139)								// byte pointer into tty buffer#define	loc_inch			(mem_siz - 140)								// input character#define	loc_cnum			(mem_siz - 141)								// current command number#define	loc_prmt			(mem_siz - 146)								// 8 char command prompt#define	loc_screen			(mem_siz - 147)								// lines/screen on the terminal (0 means the terminal isn't screen-oriented)/* Monitor bootload state variables */#define	loc_magic			(mem_siz - 148)								// location of magic number#define	loc_psys			(mem_siz - 149)								// previous SYSTYP to detect bootload error/* Sed state variables */#define	loc_sed1			(mem_siz - 150)								// reserved for sed use#define	loc_sed2			(mem_siz - 151)								// reserved for sed use/* configuration/device information */#define	loc_ctab			(mem_siz - 239)								// system configuration#define	loc_headpos			(mem_siz - 243)								// drive F0, F1, R0, and R1 head positions#define	loc_emsize			(mem_siz - 244)								// external memory size less amount reserved for MONITOR (in sectors)/* word (MEM.SIZ - 245) is currently unused *//* Synclavier (r)/SCRIPT state variables */#define	loc_synrtpn			(mem_siz - 250)								// 8 char name of default Synclavier RTP#define	loc_synmed			(mem_siz - 251)								// synclavier file media (0 = normal memory, 1 = expanded memory)#define	loc_synmisc			(mem_siz - 252)								// pointer to synclavier miscellaneous area#define	loc_syntimb			(mem_siz - 253)								// pointer to synclavier timbre area#define	loc_synseq			(mem_siz - 254)								// pointer to synclavier sequence notes#define	loc_synstat			(mem_siz - 255)								// synclavier status word#define	loc_synret			(mem_siz - 256)								// pointer to word trio (above) describing program to return to if no room/* overlay routine (768 words) */#define	loc_load			(mem_siz - 1024)							// load/overlay routine stored here#define	mem_offs			256											// offset from a one K boundary (above 16K and below MEM.SIZ) of memory size word/* Note:  all longs are stored with the LS at the location and the MS at the location + 1. *//* external memory state variables (only there if core(loc.emsize) <> 0) */#define	loc_emarea			loc_emsize									// sector start of external memory state variables/* word offsets from LOC.EMAREA */#define	em_polycache		0											// True if poly cache valid#define	em_disallow_grouping_by_holding	1								// true to disallow track group creation by holding track buttons#define	em_perform			256											// nested perform file state (50 words + 56 words command line)_library(":-xpl:libs:syslits")											// set up MEM.SIZ/* Catalog routines:.     VALID_FILECHAR (c): returns TRUE if character C is valid in a filename.     VALID_FILENAME (name): returns TRUE if passed filename is valid.     CLEAN_FILENAME (name, fcb_name): converts XPL string format to FCB name format.     CLEAN_FCBNAME (fcb_name, name): converts FCB name to XPL string format..     CACHE (bufptr, bufmed): cache contents of catalog buffer in buffer BUFPTR on BUFMED.     REINIT_CACHE (n, buffer): reinitialize caching to provide for N caches.     FLUSH_CACHE (n): flush cache N to disk/tape.     DISABLE_CACHE (n): disable cache N.     ENABLE_CACHE (n): enable cache N.     CACHE_TREENAME (enable): enable/disable treename caching..     SET_CATBUF (bufptr, bufmed): set the catalog buffer pointer.     READCAT (ms_sector, ls_sector, dir_size, ms_length, ls_length): read in a catalog.     WRITECAT: write out the catalog buffer.     READDIR (name): read in catalog NAME..     GET_FCB (fcb#, fcb): extract an FCB from the catalog buffer.     PUT_FCB (fcb#, fcb): replace an FCB into the catalog buffer..     FINDFILE (name): find a file in the catalog buffer.     REMOVEFILE (name): remove file NAME from catalog.     ADDFILE (name, type, ms_sectors, ls_sectors, length): add file NAME to catalog.     SHORTENFILE (name, ms_sectors, ls_sectors, length): shorten file NAME.     RENAMEFILE (old_name, new_name): rename OLD_NAME to NEW_NAME.     FINDSTORAGE (ms_sectors, ls_sectors): find storage.     FINDMAX: find maximum storage available..     READ_CATALOG (treename, level): read catalog TREENAME on LEVEL.     WRITE_CATALOG: write out the catalog buffer.     DELETE (treename, level): delete file TREENAME on LEVEL.     REPLACE (treename, type, ms_sectors, ls_sectors, length, level): replace file TREENAME on LEVEL.     TRUNCATE (treename, ms_sectors, ls_sectors, length, level): truncate file TREENAME on LEVEL.     RENAME (old_name, new_name, level): rename OLD_NAME to NEW_NAME on LEVEL.     LOCATE (treename, level): locate file TREENAME on LEVEL.     LOOKSTORAGE (treename, ms_sectors, ls_sectors, level): look for storage on TREENAME/LEVEL.     LOOKMAX (treename, level): lookup maximum storage available on TREENAME/LEVEL.     ENTER_CATALOG (treename, level): enter catalog TREENAME on LEVEL.     ENTER_ALTERNATE (treename, level): enter alternate catalog TREENAME on LEVEL*//* Catalog entry definitions */#define	c_nm				0											// filename (four words)#define	c_ls				4											// Ls starting sector#define	c_ll				5											// Ls sector length#define	c_wd				6											// word length (modulo 64K)#define	c_ty				7											// Ms starting sector (8 bits)/MS sector length (4 bits)/file type (4 bits)#define	c_len				8											// number of words in a catalog entry#define	c_dir_max			1024										// maximum directory size (words)/* Fcb definitions (used with GET_FCB and PUT_FCB) */#define	f_nm				0											// filename (four words)#define	f_ls				4											// Ls starting sector#define	f_ms				5											// Ms starting sector#define	f_ll				6											// Ls sector length#define	f_ml				7											// Ms sector length#define	f_wd				8											// word length (modulo 64K)#define	f_ty				9											// file type#define	f_len				10											// number of words in an FCB#define	f_name_len			4											// number of words in a filename/* File type definitions */#define	t_text				0											// text file#define	t_exec				1											// executable binary#define	t_reloc				2											// relocatable binary#define	t_data				3											// data file#define	t_sync				4											// synclavier sequence#define	t_sound				5											// sound file#define	t_subc				6											// subcatalog#define	t_lsubc				7											// large subcatalog#define	t_dump				8											// dump file#define	t_spect				9											// spectral file#define	t_index				10											// index file#define	t_timbre			11											// synclavier timbre#define	t_max				11											// maximum defined filetype/* Errors returned in C#STATUS */#define	e_none				0											// no error encountered#define	e_os				1											// operating system error - magic number not set#define	e_buffer			2											// no catalog buffer allocated#define	e_no_dir			3											// no directory in memory#define	e_no_config			4											// device not configured#define	e_no_floppy			5											// no floppy in drive#define	e_fcb				6											// Fcb number out of bounds#define	e_level				7											// level number out of bounds#define	e_storage			8											// not enough available storage#define	e_cstorage			9											// not enough contiguous storage available#define	e_dir_full			10											// no entries left in the directory#define	e_invalid			11											// invalid directory#define	e_name				12											// invalid filename specified for operation requested#define	e_duplicate			13											// duplicate filename#define	e_no_file			14											// file not found#define	e_not_cat			15											// name specified is required to be a catalog, but isn't#define	e_treename			16											// incorrect format for treename#define	e_no_path			17											// intermediate catalog (in treename) not found#define	e_type				18											// type mismatch between saved file and replaced file (ADDFILE/REPLACE only)#define	e_protect			19											// write protected floppy#define	e_too_large			20											// file too large (>= 2^20 sectors)#define	e_truncate			21											// truncation error - trying to expand a file (or truncate tape file)#define	e_diskerror			22											// disk error - could not read disk/* Caching literals */#define	__vars				5											// five variables/cache/* Global catalog variables */extern	fixed	c_status;												// status of last catalog operationextern	fixed	c_bufptr;												// pointer to the catalog bufferextern	fixed	c_bufmed;												// catalog buffer media:  0 - main memory, 1 - external memoryextern	fixed	c_ms_sector;											// device and MS starting sector of catalogextern	fixed	c_ls_sector;											// Ls starting sector of catalogextern	fixed	c_ms_length;											// Ms sector length of catalog (including directory)extern	fixed	c_ls_length;											// Ls sector length of catalog (including directory)extern	fixed	c_dir_size;												// size of catalog directory (in words)/* Global file variables */extern	array	f_name;													// name of last filename scanned off treenameextern	fixed	f_ms_sector;											// device and MS starting sector of fileextern	fixed	f_ls_sector;											// Ls starting sector of fileextern	fixed	f_ms_length;											// Ms sector length of fileextern	fixed	f_ls_length;											// Ls sector length of fileextern	fixed	f_words;												// word length of file (modulo 64K)extern	fixed	f_type;													// type of file/* Alternate catalog variables (for reference only - do NOT modify) */extern	array	a_name;													// name of alternate catalogextern	fixed	a_ms_sector;											// device and MS starting sector of catalogextern	fixed	a_ls_sector;											// Ls starting sector of catalogextern	fixed	a_ms_length;											// Ms sector length of catalog (including directory)extern	fixed	a_ls_length;											// Ls sector length of catalog (including directory)extern	fixed	a_dir_size;												// size of catalog directory (in words)/* Filename processing */extern	boolean	valid_filechar(fixed);									// return TRUE if specified character is valid in a filenameextern	boolean	valid_filename(fixed[]);								// return TRUE if passed filename is validextern	void	clean_filename(fixed[], fixed[]);						// convert XPL string format to FCB name formatextern	void	clean_fcbname(fixed[], fixed[]);						// convert FCB name to XPL string format/* Caching */extern	fixed	cache(fixed, fixed);									// cache contents of catalog bufferextern	void	reinit_cache(fixed, fixed[]);							// reinitialize caching to provide for N cachesextern	boolean	flush_cache(fixed);										// flush cache N to disk/tapeextern	void	disable_cache(fixed);									// disable cache Nextern	void	enable_cache(fixed);									// enable cache Nextern	void	cache_treename(boolean);								// enable/disable treename caching/* Buffer interface */extern	void	set_catbuf(pointer, fixed);								// set the catalog buffer pointerextern	boolean	readcat(fixed, fixed, fixed, fixed, fixed);				// read in a catalogextern	boolean	writecat();												// write out the catalog bufferextern	boolean	readdir(fixed[]);										// read in catalog NAMEextern	boolean	get_fcb(fixed, fixed[]);								// extract an FCB from the catalog bufferextern	boolean	put_fcb(fixed, fixed[]);								// replace an FCB into the catalog bufferextern	fixed	findfile(fixed[]);										// find a file in the catalog bufferextern	boolean	removefile(fixed[]);									// remove file NAME from catalogextern	boolean	addfile(fixed[], fixed, fixed, fixed, fixed);			// add file NAME to catalogextern	boolean	shortenfile(fixed[], fixed, fixed, fixed);				// shorten file NAMEextern	boolean	renamefile(fixed[], fixed[]);							// rename OLD_NAME to NEW_NAMEextern	fixed	findstorage(fixed, fixed);								// find storageextern	boolean	findmax();												// find maximum storage available/* Level interface */extern	boolean	read_catalog(fixed[], fixed);							// read catalog TREENAME on LEVELextern	boolean	write_catalog();										// write out the catalog bufferextern	boolean	delete(fixed[], fixed);									// delete file NAME on LEVELextern	boolean	replace(fixed[], fixed, fixed, fixed, fixed, fixed);	// replace file NAME on LEVELextern	boolean	truncate(fixed[], fixed, fixed, fixed, fixed);			// truncate file NAME on LEVELextern	boolean	rename(fixed[], fixed[], fixed);						// rename OLD_NAME to NEW_NAME on LEVELextern	boolean	locate(fixed[], fixed);									// locate file NAME on LEVELextern	boolean	lookstorage(fixed[], fixed, fixed, fixed);				// look for storage on TREENAME/LEVELextern	boolean	lookmax(fixed[], fixed);								// lookup maximum storage available on TREENAME/LEVELextern	boolean	enter_catalog(fixed[], fixed);							// enter catalog NAME on LEVELextern	boolean	enter_alternate(fixed[], fixed);						// enter alternate catalog NAME on LEVEL/* Buffered file I/O - no swapping   Warning:  Either CATRTNS or CATSWAP MUST be libraried before FILEIO!*/_library(":-xpl:libs:fileio")/*.  This module handles buffered file input and output...  WARNING:  These routines assume the logical end-of-file occurs within.            the last 256-sector block of the file.  This means that a.            256-sector file that has a word length of zero will be.            considered to be zero words long rather than 65536 words long..            A 65536-word file is represented by a sector length of 257.            and a word length of zero...  FOpen (Filename, Access):  Opens a file by the given filename and access..               Returns a file pointer or NULLF if it fails.  Access must.               must be one of the following (presently unused):.                  'r':  Read only (disallow all PUTs & SHUFFLE).                  'w':  Write only (disallow all GETs); truncate if there, create if not.                  'a':  Append (disallow all GETs); position to end if there, create if not.                  'r+': Update - file MUST be there.                  'w+': Update - truncate if there, create if not.                  'a+': Update - position to end if there, create if not..  FClose (F):  Closes file F, where F is a file pointer returned by a.               previous call to FOPEN.  Returns zero if it works,.               EOF_MARK otherwise...  SetBuf (F, BufPtr, BufMed, Size):  Sets the buffer used for the file.               just opened by FOPEN to the buffer with the given SIZE.               pointed to by BUFPTR/BUFMED where BUFMED is zero for.               internal memory, one for external, and two for poly..               This routine can only be called immediately after a call.               to FOPEN.  Returns zero if it works, EOF_MARK otherwise..   .  FFlush (F):  Flush file F's buffer...  FEOF (F):    Returns TRUE if at EOF of file F...  GetC (F):    Gets the next character from file F.  GETC returns.               either a character or an end of file (EOF) mark...  GetW (F):    Gets the next word from file F.  It returns either a.               word or EOF_MARK...               NOTE:  There is a potential confusion due to the fact.               that EOF_MARK is defined as -1, which is a perfectly.               valid next word.  FGETS suffers from this problem as well..               Use FEOF before the GETW or FGETS call to be certain...  FGetS (Line, Max, F):  Gets the next line from file F and its line number..               When the end of the file is reached, EOF_MARK is returned .               instead of the line number...  PutC (C, F): Write character C to file F at the current file position..               EOF_MARK is returned if at the end of file...  PutW (W, F): Write word W to file F at the current file position..               EOF_MARK is returned if at the end of file...  FPutS (Line, Number, F):  Write line LINE with line number NUMBER to.               file F at the current file position.  EOF_MARK is.               returned if at the end of file...  FFull (Bytes, FPutS, F):  See if writing BYTES bytes to file F will.               cause its file buffer to be flushed.  This is useful.               when a program needs to know when time will be lost.               to disk I/O.  FFULL is TRUE if these bytes form a line.               to be passed to FPUTS...  FRead (Buf, Size, Number, F):  Read NUMBER records of SIZE bytes into.               BUF from file F starting at the current file position..               The number of records actually read is returned...  FWrite (Buf, Size, Number, F):  Write NUMBER records of SIZE bytes from.               BUF to file F starting at the current file position..               The number of records actually written is returned...  Seek (F, Offset, Origin):  Reset the file position of file F to character.               position OFFSET based on the mode specified in ORIGIN.  The.               new file position is returned.  ORIGIN must be one of these:.                  0: seek from start of file.                  1: seek from current position.                  2: seek from end of file.                3-5: same as 0-2, but treat OFFSET as a sector offset..  Shuffle (F, Source, Destination, Length):  Move sectors SOURCE through.               SOURCE + LENGTH - 1 of file F to DESTINATION in file F..               Returns EOF_MARK if the combination of SOURCE, DESTINATION,.               and LENGTH would cause a shuffle past the physical end of.               file or if SOURCE or DESTINATION is beyond the logical.               end of file.  SHUFFLE will change the logical length of.               file F if the shuffle caused said length to change..               After SHUFFLE returns, the file position will be zero.*/#define	file				fixed										// file type (returned by FOPEN and expected by all the others)#define	eof_mark			-1											// end-of-file mark#define	nullf				-1											// null file pointer - returned by FOPEN if it fails/* File errors (returned in FILE_ERROR) */#define	f_okay				0											// no errors#define	f_no_file			1											// file does not exist#define	f_bad_file			2											// invalid file descriptor#define	f_no_buffer			3											// no buffer assigned to the file#define	f_bad_arg			4											// invalid argument or improper operation requested#define	f_too_many			5											// too many files open#define	f_bad_access		6											// invalid access request#define	f_too_big			7											// file is too large to process - files are limited to 32 Mbytesextern	file	fopen(fixed[], fixed[]);								// open file with specified nameextern	fixed	fclose(file);											// close specified fileextern	fixed	setbuf(file, pointer, fixed, fixed);					// set opened file's bufferextern	fixed	fflush(file);											// flush specified file's bufferextern	boolean	feof(file);												// return TRUE if at end-of-fileextern	fixed	getc(file);												// get next character from specified fileextern	fixed	getw(file);												// get next word from specified fileextern	fixed	fgets(fixed[], fixed, file);							// get next line (and line #) from specified fileextern	fixed	putc(fixed, file);										// put specified character in specified fileextern	fixed	putw(fixed, file);										// put specified word in specified fileextern	fixed	fputs(fixed[], fixed, file);							// put specified line (and line #) in specified fileextern	boolean	ffull(fixed, boolean, file);							// see if this many bytes fills the file's bufferextern	fixed	fread(fixed[], fixed, fixed, file);						// read one or more records from specified fileextern	fixed	fwrite(fixed[], fixed, fixed, file);					// write one or more records to specified fileextern	fixed	seek(file, fixed, fixed);								// seek to given file position in specified fileextern	fixed	shuffle(file, fixed, fixed, fixed);						// shuffle fileextern	fixed	file_error;												// global file error indicatorstatic	fixed	rfbuf[11];												// put here to get literals to translate correctlyvoid			when_break(){	exit (0);															// let them get out		}/* globals */static	file	reloc;													// relocatable file to dumpstatic	fixed	lib_name[1], name_lib[1], get_sym[1], ptr_sym[1];		// for library and external defs (internal to pass 3)static	fixed	keyloc[1], keyjto[1], keyflag[1], r[1];					// for DUMPKEYSstatic	fixed	abit, dbit, pbit;										// for DUMPKEYSstatic	fixed	proc_entry, proc_jump, proc_return, proc_dswp, proc_regs, proc_noswap, proc_size, proc_flags, proc_stack, proc_temps;	// for DUMPKEYS/* If handling */#define	readif				getw (reloc)								// read a word from the IF#define	posif				seek (reloc, 0, 1)							// position of IFstatic	void	resetif(												// reset IF to position POS	fixed	pos)														// position to reset IF to	{	seek (reloc, pos, 0);												// seek away}	/* General definitions used by pass1, pass2, and pass3: */#define	extern_base			(((fixed) (56*1024)))						// Ram/scon/key base for external references (so they don't conflict with external definitions - see pass1:GET_EXTLOC)#define	temp_base			(extern_base - ((fixed) (4*1024)))			// Scon base for temporaries in recursive procs (so they we can recognize them)#define	ins_levels			20											// allow 20 levels of insert files#define	s_depth_max			15											// levels of localization (by default, it's only 4 bits) - must be (2^N - 1)#define	max_recurs_parms	16											// maximum number of parameters to recursive procs#define	proc_keys			4											// number of keys used by a proc (minus one)#define	when_keys			3											// number of keys used by a when (minus one)#define	mam					0x0030										// external memory definitions - sector address#define	mal					0x0031										// word address#define	md					0x0032										// memory#define	mdi					0x0033										// memory then increment/* Token type definitions:.  .   The 'scanner'(procedure 'SCAN') is called to scan the next.   token (or 'atom') from the source file.   The scanner sets certain.   values to the global variables 'TOKEN' and 'INFO',  depending.   on the type of symbol that is scanned.   In general,  the global.   variable 'TOKEN' will contain an integer that indicates what type of.   atom was scanned (such as a fixed point variable),  and the.   global variable 'INFO' will further modify token (such as where.   in memory the variable will be stored)...   NOTE:  There is a dependency in the statement scanner (and perhaps.   elsewhere) on the token values less than T.LIT.  In particular,.   all variables must be less than T.LIT, all arrays must have odd.   token values, and all pointers must have the T.PVAR bit set...   RELOCATE_DEFNS in P3-3 also has an array STORAGE_TYPE that maps these.   token types to general storage types (i.e., ram, data, keys). */#define	t_var				0											// numeric fixed point variable#define	t_arr				1											// fixed point array#define	t_fvar				2											// floating point variable#define	t_farr				3											// floating point array#define	t_pvar				4											// pointer to fixed point variable#define	t_parr				5											// pointer to fixed point array#define	t_pfvar				6											// pointer to floating variable#define	t_pfarr				7											// pointer to floating point array#define	t_lit				8											// literal declaration#define	t_data				9											// fixed point data array#define	t_fdata				11											// floating data array#define	t_extern			8											// global variable reference#define	t_public			9											// global variable definition#define	t_symonly			10											// symbol ref only#define	t_proc				16											// procedure#define	t_label				17											// statement label#define	t_stmt				18											// statement#define	t_type				19											// declaration type name#define	t_storage			20											// declaration storage type#define	t_rtp				21											// run time call (shr, shl)#define	t_module			22											// module#define	t_address			23											// addr of a parameter#define	t_const				32											// fixed point constant#define	t_fconst			33											// floating point constant#define	t_sconst			34											// string constant#define	t_comma				48											// comma#define	t_semi				49											// semi#define	t_lpar				50											// lpar#define	t_rpar				51#define	t_colon				52											// colon#define	t_eof				53											// eof#define	t_opr				54											// operator#define	t_sdy				55											// special form dyadic - shr(a, b) etc.#define	t_while				64											// while#define	t_case				65											// case#define	t_to				66											// to#define	t_by				67											// by#define	t_end				68											// end#define	t_then				69											// then#define	t_else				70											// else#define	t_unda				72											// undeclared proc argument#define	t_und				73											// undefined symbol#define	t_input				81											// input#define	t_locat				82											// symbol 'location' - used in proc calls#define	t_copys				98											// denotes copy scon to object file#define	t_copyd				99											// denotes copy data to object file (only data statement)#define	t_ldef				100#define	t_assign			101#define	t_lnum				103											// indicates source line number#define	t_null				104											// null statement#define	t_symref			105											// symbol reference for linker#define	t_config			109											// configuration type#define	t_pform				110											// print format#define	t_string			111											// indicates string as in print string(array);#define	t_icell				112											// interrupt cell token identifier#define	t_rtns				113											// returns keyword in procedure definition#define	t_recurs			114											// defines a procedure to be recursive#define	t_swap				115											// defines a procedure to be swappable#define	t_swpcode			116											// does not allow the swapping of string constants or data arrays#define	a_eof				0x0080										// special flag (in char returned by GC) for end of file/* storage classes */#define	s_static			0											// static storage#define	s_automatic			1											// automatic storage#define	s_temporary			7											// temporary storage (static or automatic) - used only by PASS2/* procedure attribute bits *//* There are 16 bits, in this word, allocated for use as attribute bits */#define	p_recursive			0x0001										// recursive procedure#define	p_swap				0x0002										// swapping procedure#define	p_swapscon			0x0004										// nonswapping scons or data arrays/* Interpass data communications area:.  .   Certain data elements must be transferred from pass1 to pass2.   and on to pass3.   To simplify this transfer,  several important.   variables are define to be locations of an array that is later.   written out to the intermediate file.   When pass2 reads in the.   intermediate file, the data elements are read in with it.  Pass3.   uses this area to find the location of the bound runtime package. */#define	rtp_ptrs			128											// number of rtp pointers used by pass3#define	configlen			48											// length of configuration area in high core and interpass comm area (plus C#OFFSET for lowcore)#define	whentablen			48											// length of when table in comm area/* communications area locations */#define	l_pdll				(rtp_ptrs + 0)								// push down length#define	l_key				(rtp_ptrs + 1)								// next available key - 1 (number of keys used)#define	l_recurs_parms		(rtp_ptrs + 2)								// address of canonical storage for passing parameters to recursive procs#define	l_altkey			(rtp_ptrs + 3)								// alternate keys/* word 4 is free */#define	l_s_names_len		(rtp_ptrs + 5)								// pass1 symbol table size#define	l_str_data			(rtp_ptrs + 6)								// amount of string and data storage#define	l_stack_used		(rtp_ptrs + 7)								// pass2 push stack size#define	l_flags				(rtp_ptrs + 8)								// various flags (defined below)#define	l_ram				(rtp_ptrs +  9)								// ram area length + 1#define	l_extloc			(rtp_ptrs + 10)								// external references processed#define	l__st				(rtp_ptrs + 11)								// pass1 symbol table max#define	l__sk				(rtp_ptrs + 12)								// pass2 push stack max#define	l__bl				(rtp_ptrs + 13)								// pass2 number of blocks#define	l__if2				(rtp_ptrs + 14)								// max size of interfile #2/* words 15-16 are free */#define	l_iflng				(rtp_ptrs + 17)								// length of interfile #1#define	l_if2lng			(rtp_ptrs + 18)								// length of interfile #2#define	l_ovram				(rtp_ptrs + 19)								// overriding starting ram location#define	l_get_blocks		(rtp_ptrs + 20)								// pass2 get block stats#define	l_main_key			(rtp_ptrs + 21)								// key of main program (only when linking)#define	icell				(rtp_ptrs + 22)								// interrupt cells#define	ctab				(icell + whentablen)						// configuration table/* size of area */#define	maxcomm				(ctab + configlen - rtp_ptrs - 1)			// size of interpass communications area/* bits set in L.FLAGS: */#define	enable_flag			0x0001										// an enable statement was encountered#define	when_flag			0x0002										// a when statement was encountered#define	link_flag			0x0004										// a library statement was encountered#define	module_flag			0x0008										// this is a module#define	dump_flag			0x0100										// dump statistics#define	symtab_flag			0x0200										// dump the symbol and sequence table#define	skip_flag			0x0400										// skip dead code analysis phase#define	force_flag			0x0800										// force code to ext memory#define	debug_flag			((fixed) 0x1000)							// gen better code for debugging#define	keep_flags			(when_flag | enable_flag)					// flags we keep when creating a relocatable binary/* Transfer vector locations for the runtime package:..     As in Dartmouth's BASIC runtime package, there is a transfer vector.     at the beginning of the rtp which points to the routine to call..     The compiler only knows the location of the transfer vector.  In.     this compiler, the code gets changed by pass3 to point to the actual.     location of the routine rather than to the transfer vector location. *//* system routines */#define	l_sta				0x0000#define	l_pat				0x0001#define	l_in1				0x0002/* Model C only: */#define	l_in2				0x0003#define	l_in3				0x0004/* Model D only: */#define	l_sw1				0x0003										// patch this location in startup to point to g.swap#define	l_pgsw				0x0004										// pointer to code to switch to page 0#define	l_pgx				0x0005										// pointer to code to exchange pages#define	l_sreg				0x0006#define	l_lreg				0x0007#define	l_retn				0x0008#define	l_swe				0x0008										// model c & later - swap entry#define	l_sw2				0x0009										// model c & later - swap patch#define	l_swpp				0x000A										// relative pointer from h.swap to g.swap#define	l_swap				0x000B/* floating point routines */#define	l_fpm				0x000C#define	l_fpd				0x000D#define	l_fpa				0x000E#define	l_fps				0x000F#define	l_fix				0x0010#define	l_flo				0x0011#define	l_abs				0x0015#define	l_log				0x0016#define	l_atn				0x0017#define	l_cos				0x0018#define	l_sne				0x0019#define	l_tan				0x001A#define	l_exp				0x001B#define	l_sqr				0x001C/* misc routines */#define	l_rot				0x0021#define	l_shl				0x0022#define	l_shr				0x0023#define	l_bmv				0x0025#define	l_bst				0x0026#define	l_brk				0x0027/* Transfer vector (cont.):.     output routines */#define	l_npr				0x0028#define	l_spr				0x0029#define	l_pri				0x002A#define	l_fpr				0x002B#define	l_con				0x002C#define	l_opr				0x002D#define	l_pch				0x002E/* terminal input */#define	l_fin				0x0030#define	l_sin				0x0031#define	l_ipr				0x0032#define	l_idn				0x0033#define	l_ich				0x0034#define	l_fxi				0x0037/* byte/string routines */#define	l_byt				0x0038#define	l_pbt				0x0039#define	l_erd				0x003B#define	l_ewr				0x003C#define	l_ept				0x003D#define	l_ipt				0x003E#define	l_est				0x003F/* special functions */#define	l_ter				0x0040#define	l_sbr				0x0041#define	l_sbw				0x0042#define	l_see				0x0043#define	l_fde				0x0046#define	l_scur				0x0047/* fixed point math ops */#define	l_fmu				0x0048#define	l_fdi				0x0049/* other routines */#define	l_rfl				0x004A#define	l_wfl				0x004B#define	l_wsl				0x004C#define	l_prd				0x004D#define	l_pwr				0x004E#define	l_swi				0x004F/* Values greater than l.interp indicate *//* calls to Mac-hosted routines running  *//* the interpreter						 */#define	l_interp			0x0100/* Pass3 definitions: */#define	divmax				256											// maximum number of ram divisions#define	stacklen			512											// stack size#define	istacklen			(((fixed) (2*ins_levels)))					// insert file stack length#define	pstacklen			s_depth_max									// procedure stack length#define	insmax				128											// allow 128 x 16 = 2048 insert statements/program#define	ifbufl_min			512											// minimum input file buffer length (MUST be >= 512)#define	ofbufl				2048										// output file buffer length (MUST be >= 512)#define	ovbufl				((fixed) 4096)								// overlay file buffer length#define	sfbufl				512											// size of symbol table output buffer#define	cutoff				3											// maximum number of registers saved in-line on proc entry#define	rtp_diff			400											// approximate difference between lengths of RTPs (len(RTC) - len(RTB))#define	key_ratio			3/5											// fraction of memory reserved for KEYs#define	t_executable		1											// executable file file type#define	t_relocatable		2											// relocatable binary file type/* linker definitions */#define	lib_size			200											// maximum number of libraries linker can handle#define	lib_name_size		(((fixed) (lib_size*10)))					// maximum area for library names#define	hash_size			511											// size of linker hash table (must be 2^n - 1)#define	total_symbols		400											// maximum number of symbols linker can handle (internal memory)#define	most_symbols		((fixed) 6553)								// can never handle more symbols than these (just 65536/SYMBOL_LENGTH)#define	symbol_length		10											// average symbol length = 18 chars; can be decreased 1 char by allocation rounding#define	stentry_size		(symbol_length + 10)						// number of words in a symbol table entry#define	stable_round		(_scale_(stentry_size,3,10))				// round up .7 and up#define	name_size			64											// maximum size of linker name block#define	devtablen			14											// length of device driver table#define	devdrivers			10											// number of words of that table that are device driver pointers (rest are for FIND_DEVICE)#define	spectablen			1											// special labels - used by pass 3 only,  not rtp/* runtime package routines */#define	sreg				rfbuf [l_sreg]								// save registers routine#define	lreg				rfbuf [l_lreg]								// load registers#define	retn				rfbuf [l_retn]								// return routine#define	swpe				rfbuf [l_swe ]								// model c,d swap proc entry/* communication area defs */#define	l_icell				icell										// interrupt cells for when#define	l_ctab				ctab										// configuration table#define	ram					r [l_ram]#define	pdll				r [l_pdll]#define	max_refs			r [l_extloc]								// maximum number of external references the linker can handle/library#define	main_key			r [l_main_key]								// key of main program (when linking)#define	prctyp				(shr(r [l_ctab + 1], 8) & 7)				// configuration area defs#define	muldiv				((r [l_ctab + 1] & 0x0008) != 0)#define	redrct				r [l_ctab + 4]#define	proc_type			(shr(able_core(loc_ctab + 1), 8) & 7)		// highcore config#define	outdev				able_core(loc_ctab + 4)						// highcore config/* the following is used to check to see if the swapcode bit is set dcl swapcode_set lit 'not(shr((keyflag(swap_key + proc_flags) and p.swapcode),2))';*//* Definitions used by pass2 and pass3: *//* define the configuration table */#define	vstart				0#define	vlngth				1#define	stklen				2#define	objloc				3#define	objlen				4#define	swpram				5#define	swplen				6#define	rtploc				7#define	inttab				8#define	rcvptr				9#define	inpbuf				10#define	sbrsbw				11#define	curtrk				12#define	devtab				13/* Define symbols for intermediate file format:..  The intermediate file is a record oriented file created by pass2..  Each type of record may have a different length...  The ET.LDF records are emitted by the linker (during pass3), and by.  pass2 for MAIN only.  The ET.REF records are emitted and used by the.  linker only...  The first word of each record indicates its type as follows:*/#define	et_eof				0											// end of file#define	et_lit				1											// literal word#define	et_tra				2											// jump instruction#define	et_cal				3											// procedure call#define	et_rtp				4											// rtp call#define	et_vpt				5											// variable area pointer#define	et_opt				6											// object code pointer#define	et_lde				7											// label definition#define	et_dat				8											// data declaration#define	et_cpy				9											// copy data to object file#define	et_scn				10											// copy scon to object file#define	et_ign				11											// ignore record#define	et_pdf				12											// procedure definition#define	et_pen				13											// end of procedure defn#define	et_whn				14											// beginning of when stmt#define	et_wen				15											// end of when stmt#define	et_spt				16											// string constant ptr#define	et_adr				17											// addr of fixed array#define	et_seq				18											// sequence number#define	et_sym				19											// symbol defn or reference#define	et_mod				20											// module statement#define	et_lib				21											// library statement#define	et_ins				22											// insert statement#define	et_ldf				23											// library definition#define	et_ref				24											// external symbol reference#define	et_cas				25											// emit code for do case#define	et_atr				26											// alt jump instruction#define	et_ald				27											// alt label definition#define	et_max				27											// largest record type defined#define	et_maximum			0x003F										// maximum record type allowed without changing LITERAL.MASK#define	literal_mask		((fixed) 0xFFC0)							// if any of these bits are set in the record type, it is of type ET.LIT (see EM.LIT)#define	et_revision			13											// revision number for pass2 to pass3 IF - MUST be incremented whenever the format changesstatic	fixed	et_length[] = {0,1,3,-1,1, 3,1,1,2,-1, -1,0,-1,6,1, 2,3,2,1,-1, -1,-1,-1,1,2, 0,3,1};	// lengths of IF records by type (not including type word); -1 indicates variable length/* Able series instruction set:.  .   The following macros define the model A instruction set, unless otherwise.   noted.  Symbols are defined for source and destination fields, the.   arithmetic opcodes, and so forth. *//* sources: */#define	b_is				0x0080										// immediate source#define	b_imsk				0x003F										// immediate field#define	b_rs				0x00C0										// register source#define	b_ms				0x00E0										// memory source#define	b_ibt				0x0010										// increment bit#define	b_pc				0x000F										// pc is r17#define	b_rmsk				0x000F										// register field#define	b_amsk				0x0003										// accumulator field/* destinations: */#define	b_ad				0x0080										// arithmetic destination#define	b_loa				0x0000										// arith load#define	b_and				0x0004										// arith and#define	b_add				0x0008										// arith add#define	b_sub				0x000C										// arith subtract#define	b_ex				0x0010										// arith exor#define	b_lef				0x0014										// arith left rot#define	b_or				0x0018										// arith or#define	b_com				0x001C										// arith loa compl#define	b_td				0x00A0										// test destination#define	b_bsor				0x00B0										// byte swap or    (model B)#define	b_shra				0x00B4										// shift right add (model B)#define	b_tlo				0x0000										// test load#define	b_tan				0x0004										// test and#define	b_tad				0x0008										// test add#define	b_tsu				0x000C										// test sub#define	b_rd				0x00C0										// register destination#define	b_ca				0x00D0										// conditional absolute#define	b_cr				0x00D8										// conditional relative#define	b_tra				0											// always#define	b_tze				1											// zero flag#define	b_trc				2											// carry flag#define	b_tmi				3											// minus flag#define	b_tnv				4											// never#define	b_tnz				5											// non-zero#define	b_tnc				6											// no carry#define	b_tpl				7											// positive#define	b_md				0x00E0										// memory destinationstatic	void	dumpif_indent(											// indent a message	array	message, 													// the message to indent	fixed	level){	static	fixed	i;	   (### check bound usage ###)    for (i = 1; i <= level; i++) {		// indent this far		print("%s", "   ");	}			print("%a", message);}	static	void	dumpif_copytext(										// copy N words to the IF; print in "text" form (change WORD to last word read)	fixed	n, 															// number of words to copy	fixed	text, 														// 1 to include text form; 0 otherwise	fixed	level){    fixed			_upper0;	static	fixed	word;	static	fixed	i;		for (_upper0 = n, n = 1; n <= _upper0; n++) {						// output the data		dumpif_indent ("", level);		word = readif;													// get next word		print("0x%04X", (word));				if (text & 1) {													// only include text if needed			print("%s", "  ");			for (i = 1; i <= 2; i++) {									// output both bytes				if ((word & 0x0060) == 0)								/* check for control characters */					print("%s", " ");									// output space in place of controls				else print("%c", (word & 0x007F));						// mask to ASCII									word = shr(word, 8);									// look at second byte			}		}																// of decoding text					print("\n");	}}	/* The following routine dumps out the intermediate file.  It is only used.  for debugging.  No references to DUMPIF should be found in the "official".  copy of this pass.  Therefore, DUMPIF will not exist in the "official".  version (OPTIMIZE will remove it).  This routine will leave the IF.  positioned where it was when the routine was entered.  It is suggested.  that MAX_SYMBOLS be reduced before inserting this into pass3...  NOTE:  Since this routine uses POSIF and RESETIF with an argument other.  than zero, this routine will NOT operate properly on intermediate files.  larger than 256 sectors.  This is not really a problem because you.  should not be dumping out IFs that large. */static	void	dumpif()												// dump the pass2/3 intermediate file (debugging only){    fixed			_upper0;	static	fixed	word;												// the next word from the IF	static	fixed	level;												// indentation level	static	fixed	curpos;												// current IF file position	static	fixed	sys_dev;											// current system device	static	fixed	i, j;		sys_dev = redirection_word;											// save current output device	redirection_word = outdev;											// redirect output if necessary		level = 0;															// we're on the left margin	curpos = posif;														// save current IF position	word = readif;														// get the first word		while (word != et_eof) {											// continue until the EOF		if ((word & literal_mask) != 0)									// literal word?		{																// yes			dumpif_indent ("literal   ", level); print("0x%04X%s0x%04X", (word), "     sour:  ", (word & 0x00FF));			print("%s0x%04X\n", "     dest:  ", (rot(word, 8) & 0x00FF));		}		else switch (word - 1) {										// branch on type			case 0:			{															// literal (same as literal word above)				i = readif;												// get the literal word				dumpif_indent ("literal  ", level); print("0x%04X%s0x%04X", (i), "     sour:  ", (i & 0x00FF));				print("%s0x%04X\n", "     dest:  ", (shr(i, 8)));				break;			}															// of literal							case 1:			{															// transfer				dumpif_indent ("transfer", level); print("\n");				dumpif_indent ("   cond :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   label:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   eloc :  ", level); print("0x%04X\n", (readif));	// estimated location (from preevious pass)				break;			}															// of transfer							case 2:			{															// call				dumpif_indent ("call  ", level); i = readif; print("%6d\n", i);				dumpif_indent ("   label  :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   aliases:  ", level); print("%6d\n", i - 1);				level = level + 2;				dumpif_copytext (i - 1, 0, level);						// print aliases				level = level - 2;				break;			}															// of call							case 3:			{															// rtp call				dumpif_indent ("rtp call  ", level); print("0x%04X\n", (readif));				break;			}															// of rtp call							case 4:			{															// variable pointer				dumpif_indent ("variable pointer", level); print("\n");				dumpif_indent ("   dest :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   class:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   ptr  :  ", level); print("0x%04X\n", (readif));				break;			}															// of variable pointer							case 5:			{															// object pointer				dumpif_indent ("object pointer  ", level); print("0x%04X\n", (readif));				break;			}															// of object pointer							case 6:			{															// label definition				dumpif_indent ("label definition  ", level); print("0x%04X\n", (readif));				break;			}															// of label definition							case 7:			{															// data definition				dumpif_indent ("data definition", level); print("\n");				dumpif_indent ("   label:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   swap :  ", level); print("0x%04X\n", (readif));				break;			}															// of data definition							case 8:			{															// copy data				dumpif_indent ("copy data ", level); i = readif; print("%6d\n", i);	// print length				level = level + 1;				dumpif_copytext (i, 1, level);							// output any text				level = level - 1;				break;			}															// of copy data							case 9:			{															// copy scon				dumpif_indent ("copy scon ", level); i = readif; print("%6d\n", i);	// print length				dumpif_indent ("   proc label :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   parm number:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   string     :", level); print("\n");				level = level + 2;				dumpif_copytext (i - 2, 1, level);						// output any text				level = level - 2;				break;			}															// of copy scon							case 10:			{															// ignore				dumpif_indent ("ignore", level); print("\n");				break;			}															// of ignore							case 11:			{															// procedure definition				dumpif_indent ("procedure definition ", level); i = readif; print("%6d\n", (i & 0x00FF));				dumpif_indent ("   reg parms :  ", level); print("0x%04X\n", (shr(i, 8)));				dumpif_indent ("   label     :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   ram base  :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   temp base :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   attributes:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   parms     :  ", level); print("%6d\n", i - 4);				level = level + 2;				dumpif_copytext (i - 4, 0, level);						// copy procedure args				level = level - 1;										// we've gone in a level				break;			}															// of procedure definition							case 12:			{															// procedure end				level = level - 1;										// we've now moved out a level				dumpif_indent ("procedure end", level); print("\n");				dumpif_indent ("   label    :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   ram end  :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   temp end :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   stack len:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   registers:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   data swap:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("-------------------------", level); print("\n");				break;			}															// of procedure end							case 13:			{															// when definition				dumpif_indent ("when definition", level); print("\n");				dumpif_indent ("   label:  ", level); print("0x%04X\n", (readif));				level = level + 1;										// we've gone in a level				break;			}															// of when definition							case 14:			{															// end when				level = level - 1;										// we've gone out a level				dumpif_indent ("when end", level); print("\n");				dumpif_indent ("   label    :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   registers:  ", level); print("0x%04X\n", (readif));				dumpif_indent ("-------------------------", level); print("\n");				break;			}															// of end when							case 15:			{															// string constant pointer				dumpif_indent ("string constant pointer", level); print("\n");				dumpif_indent ("   dest :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   ptr  :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   swaps:  ", level); print("0x%04X\n", (readif));				break;			}															// of string constant pointer							case 16:			{															// addr of fixed array parameter				dumpif_indent ("addr of fixed array parameter", level); print("\n");				dumpif_indent ("   proc label :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("   parm number:  ", level); print("0x%04X\n", (readif));				break;			}															// of addr of fixed array parameter							case 17:			{															// sequence number				dumpif_indent ("sequence number ", level); print("%6d\n", readif);				break;			}															// of sequence number							case 18:			{															// symbol				j = readif;												// get the storage class/length				i = shr(j, 8);											// extract the storage class				if (i == t_public)  dumpif_indent ("public symbol definition ", level);				else if (i == t_extern)  dumpif_indent ("external symbol reference ", level);				else { dumpif_indent ("unknown (type =", level); print("%6d%s", i, ") symbol reference ");}				i = (j & 0x00FF);										// extract record length				print("%6d\n", i);										// print length				level = level + 1;				j = readif;												// get type/symbol length				dumpif_indent ("type   :  ", level); print("%6d\n", shr(j, 8));				dumpif_indent ("symlen :  ", level); print("%6d\n", (j & 0x00FF));				dumpif_indent ("info   :  ", level); print("0x%04X\n", (readif));				dumpif_indent ("storage:  ", level); print("%6d\n", readif);				dumpif_indent ("lnum   :  ", level); print("%6d\n", readif);				dumpif_indent ("name   :  ", level); print("\n");				level = level + 1;				j = (j & 0x00FF);										// get symbol length				dumpif_copytext (j, 1, level);				level = level - 1;				i = i - 4 - j;											// get remaining length (if any)				if (i > 0) {											// output procedure info					dumpif_indent ("key loc:  ", level); print("0x%04X\n", (readif));					dumpif_indent ("# args :  ", level); print("%6d\n", readif);					dumpif_indent ("returns:  ", level); print("%6d\n", readif);					for (_upper0 = shr(i - 3, 1), i = 1; i <= _upper0; i++) {	// output argument info						dumpif_indent ("argument", level); print("%6d\n", i);						level = level + 1;						dumpif_indent ("type:  ", level); print("%6d\n", readif);						dumpif_indent ("loc :  ", level); print("0x%04X\n", (readif));						level = level - 1;					}				}				level = level - 1;				break;			}															// of symbol							case 19:			{															// module				dumpif_indent ("module name ", level); i = readif; print("%6d\n", i);				level = level + 1;				dumpif_indent ("modname len: ", level); print("%6d\n", readif);				dumpif_indent ("modname    : ", level); print("\n");				level = level + 1;				dumpif_copytext ((i & 0x00FF) - 1, 1, level);				level = level - 2;				break;			}															// of module							case 20:			{															// library				dumpif_indent ("library reference ", level); i = readif; print("%6d\n", i);				level = level + 1;				dumpif_indent ("line number: ", level); print("%6d\n", readif);				dumpif_indent ("libname len: ", level); print("%6d\n", readif);				dumpif_indent ("libname    : ", level); print("\n");				level = level + 1;				dumpif_copytext ((i & 0x00FF) - 2, 1, level);				level = level - 2;				break;			}															// of library							case 21:			{															// insert				dumpif_indent ("insert filename ", level); i = readif; print("%6d\n", i);				if (i != 0) {											// zero flags end of insert file					level = level + 1;					dumpif_indent ("filename len: ", level); print("%6d\n", readif);					dumpif_indent ("filename    : ", level); print("\n");					level = level + 1;					dumpif_copytext ((i & 0x00FF) - 1, 1, level);					level = level - 2;				}														// end of start of insert record				break;			}															// of insert							case 22:			{															// library definition				dumpif_indent ("library definition ", level);				i = readif;												// get the library number				print("%6d%s%a%s\n", i, " (", _location_(&(lib_name [name_lib [i]])), ")");				break;			}															// of library definition							case 23:			{															// external symbol reference				dumpif_indent ("external symbol reference ", level);				i = readif;												// get the pointer to the symbol				print("%6d%s%a%s\n", i, " (", _location_    (#### xpltoc: warning: operand for 'location' is not of type pointer ####)    (get_sym [ptr_sym [i]]), ")");				dumpif_indent    ("   key    :  ", level); print("0x%04X\n", (readif));				break;			}															// of external symbol reference		}																// of else do case					word = readif;													// get the next word	}																	// of do while			print("eof\n");	print("========================================================\n");		resetif (curpos);													// reset the IF to where it was before we started	redirection_word = sys_dev;											// point back to the regular output device	}		static	void	dumpkeys_print_key(										// print out the values associated with KEY	fixed	key, 														// the key we want to know about	fixed	indent)														// True if we should indent the print-out{	static	fixed	flags;												// flags for the current key		if (indent & 1) print("%s", "   ");	print("%s0x%04X\n", "key    : ", (key));	if (indent & 1) print("%s", "   ");	print("%s0x%04X\n", "keyloc : ", (keyloc [key]));	if (indent & 1) print("%s", "   ");	print("%s0x%04X\n", "keyjto : ", (keyjto [key]));		flags = keyflag [key];												// get key's flags	if (indent & 1) print("%s", "   ");	print("%s0x%04X", "keyflag: ", (flags));	if (flags != 0) {													// print out flags in human-readable form		print("%s", "    ");		if ((flags & abit) == 0) print("%s", "in");		print("%s", "active ");		if ((flags & dbit) != 0) print("%s", "defined ");		if ((flags & pbit) != 0) print("%s", "procedure");	}																	// of printing flags	print("\n");}	/* The following routine dumps out the contents of the KEY arrays.  (KEYLOC, KEYJTO, and KEYFLAG) in a meaningful way.  No references.  to DUMPKEYS should exist in the "official" version of this compiler.  (so it doesn't exist in the object code of the "official" compiler). */static	void	dumpkeys(												// dump the contents of the KEY arrays (debugging only)	fixed	swaps)														// True if we're in or after the SWAPS phase of OPTIMIZE{    fixed			_upper0;	static	fixed	regs;												// registers used by proc	static	fixed	flags;												// flags for the current procedure	static	fixed	sys_dev;											// current system device	static	fixed	i, j;		sys_dev = redirection_word;											// save current output device	redirection_word = outdev;											// redirect output if necessary		print("\n");	print("\n");	print("Contents of the KEY arrays:\n");	print("\n");		for (_upper0 = r [l_key], i = 1; i <= _upper0; i++) {				// dump out all keys (note: key zero is never allocated!)		dumpkeys_print_key (i, 0);										// print this key				if ((keyflag [i] & pbit) != 0) {								// for procedures, interpret the locations			print("jump key  :\n");			dumpkeys_print_key (i + proc_jump, 1);						// print the jump around key						print("return key:\n");			dumpkeys_print_key (i + proc_return, 1);					// print the return key						regs = keyloc [i + proc_regs];								// pick up regs used			print("%s0x%04X", "regs used : ", (regs));			if (regs != 0) {											// interpret regs				print("%s", "    ");				for (j = 0; j <= 15; j++) {								// loop over registers					if (regs & 1) {																// this register is used						print("%s", "r");						if (j >= 8) print("%s", "1");						print("%c%s", (a_0 + (j & 0x0007)), " ");					}											regs = shr(regs, 1);								// look at next register				}														// of looping over registers			}															// of interpretting registers			print("\n");						flags = keyflag [i + proc_flags];							// pick up flags			print("%s0x%04X", "flags     : ", (flags));			if (flags != 0) {											// interpret flags				print("%s", "    ");				if ((flags & p_recursive) != 0) print("%s", "recursive ");				if ((flags & p_swap)      != 0) print("%s", "swap");			}			print("\n");						if (! (swaps & 1))											// if we're not in SWAPS				print("%s0x%04X\n", "noswap   : ", (keyjto [i + proc_noswap]));			else if ((flags & p_swap) != 0)								// if swapping proc				print("%s0x%04X\n", "code size: ", (keyjto [i + proc_size]));							print("%s0x%04X\n", "stack len: ", (keyloc [i + proc_stack]));						if ((flags & p_recursive) != 0) {							// if recursive proc				print("%s0x%04X\n", "temps    : ", (keyjto [i + proc_temps]));			}							i = i + proc_keys;											// don't repeat these keys		}																// of interpretting proc info					print("\n");	}																	// of dumping out all keys			redirection_word = sys_dev;											// point back to the regular output device	}/* Main program */static	fixed	name[65];												// name of relocatable filestatic	fixed	i;void	dumprel_main(){	print("%s", "Reloc file to dump\? ");	linput(name); name [0] = name [0] - 1;								// get name		reloc = fopen (name, "r");											// try to open it		if (reloc != nullf) {												// if the file exists		if (f_type == t_reloc) {										// if relocatable binary			if (! (feof (reloc) & 1)) {									// if non-empty file   (### check bound usege ###)    for (i = 1; i <= readif; i++) {		// skip header					readif;				}														// of skip header									dumpif();												// dump it			}															// of non-empty file			else print("%s%a%s\n", "File ", name, " is empty.");		}																// of relocatable binary		else print("%s%a%s\n", "File ", name, " is not a relocatable binary.");	}																	// of file exists	else print("%s%a%s\n", "File ", name, " not found.");}