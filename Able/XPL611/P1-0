/* $Dump statistics */  /* Scientific XPL Compiler - Pass 1.  .   This program forms the first pass of the model A XPL compiler..   It is normally active on a system with 16K memory and dual.   floppy disk drives..  .   Pass1 reads through the source file and generates an intermediate.   file.  The intermediate file contains an encoded version of all.   elements of the source file..  .   Basic features of pass1:.  .     Symbol table processing (hash-coded table).     Expression processing (tree-structure generated).     Recursive statement scanner.     Character string to binary conversion.     Variable area location assignments.  .   At the end of pass1, pass2 is brought into memory and started up...   Things to do:.     1) Only emit symrefs if (and when) first referenced.  Remember.        Pass 3 requires symrefs to occur BEFORE the first usage.  To.        do this we'll need to remember if we've emitted the symref.        already (easy if we know if a variable's been referenced or.        assigned yet).  Remember we can only emit SYMREFs where pass2.        calls SCANC..     2) Think about ways to have the linker only link in procedures.        that are called from .MAIN (or any of its referenced procedures)..        In this way, we can perhaps avoid the painful task set for us.        in step one..     3) If a public variable is declared in a procedure, make sure the.        RAM for that variable isn't removed by the shrinking algorithm.        (i.e., allocate it elsewhere - in a "COMMON" area)..     4) Make use of module name in pass 3 (instead of library name)..     5) Allow recursive procedures to access any variables within their.        usual (in terms of XPL) scope.  I.e., define the storage area of.        all variables (some static, some recursive, some external, etc.).     6) Detect labels in swappable procs that can be GONE to from outside.        the procedure.  We just need to check the label's scope at the.        point the label occurs.  If the scope is outside the current proc's.        scope, OR the label is PUBLIC, AND we are in a swappable proc,.        it's illegal.  We can't check this until we expand the symbol table..     7) Add line number and file of largest swappable proc to $D output..     8) Preserve D60/D61 across interrupts - save them at start of WHEN.        if used by WHEN or any procs the WHEN calls.  Can also do this.        for D4567 instead of unconditionally saving it in RTP.  Only.        need two REGBITS in pass 2..     9) If EOF is declared in an insert file, processing returns to.        the inserting file immediately after EOF is scanned.  Could.        solve this by making EOF a compile-time statement (rather than.        constant) that doesn't have a trailing semicolon (just set the.        "don't scan" flag in STMT)..    10) No differentiation is currently made between compile-time (such.        as INSERT, LIBRARY, etc.) and run-time (such as PRINT, IF, etc.).        statements.   As a result, INSERTs in the middle of DO CASEs.        and IF-THEN-ELSEs (a la if a = b then insert 'x';) screw things up..    11) ADDR: implemented as an operator (not the best way).  Error.        recovery in compiler is wrong.  ADDR(express) gives incorrect.        line number in pass 2 if error in expression [odd since line.        number of ADDR is passed thru].  Also get compiler system error.        if error in expression - doesn't deallocate blocks assoc. w/.        express (this is a problem in gen'l).  To clean up: compute,.        load in reg (maybe allocate reg first), then freeup reg..        Also "10 print addr(2+2);" says "Argument types do not match"..        This is not the right error message (could be better)..    12) Pass 3 IF I/O:  Not terribly robust.  For example, reading past.        end of IF is only detected when we read a new buffer (not often)..    13) "if not read(dev)" generates "Incorrect format"..    14) Pass3 should verify that device drivers don't swap!.    15) The following does NOT generate a compiler error:.        dcl (a, b, a, b, a, a, a, b) fixed;.    16) Detect constant subscripts out of bounds in pass 1 (e.g., a (-1))..  .   Modification history:.     23 Apr 1981:  Added (ptype and stype) in configuration statement.     21 Oct 1981:  Winchester disk operation (XPL/4).     11 Oct 1983:  Recreated relocatable XPL [KJC].     10 Feb 1984:  Removed Kiewit specific code (module w/out name and procedure stubs) [KJC].     20 Feb 1984:  Created INSERT statement record for pass3 symbol table [KJC].     22 Feb 1984:  Restricted valid identifier characters to alpha, digit, '.', '#', '_', and '$' [KJC].     24 Feb 1984:  Added support for true recursion [KJC].     20 Jul 1984:  Removed DMINI and DMAXI configurations [KJC].     14 Sep 1984:  Added SWAPpable procedures (overlays) [KJC].     27 Dec 1984:  Shrink out scon/data and temps from uncalled procs (proc record change) [KJC].     15 Apr 1985:  Added DMINI (DD Mini) and SMINI (Super Mini) configs [KJC].     16 Aug 1985:  Added swapping of SCON [KJC].     16 Sep 1985:  Expanded symbol table and moved to external memory [KJC].     28 Oct 1985:  Added INVOKE statement [KJC].     15 Nov 1985:  Expanded literal storage [CWJ].     31 Jan 1986:  Added swapping of data statements in swappable procs [KJC].     20 Feb 1986:  Removed DISKREAD, DISKWRITE, SHR1, SHL1, ROT8, and PATCH [KJC].     15 Oct 1986:  Updated for -7 catalog structure [KJC].      4 Nov 1986:  Changed RECURSIVE procs to calculate variable pointers [KJC].      7 Nov 1986:  Defined and fully supported storage classes [KJC].     29 May 1987:  Removed PNULLS and SNULLS; fixed alias list bug [KJC].     18 Dec 1987:  Added conditional compilation (IF and DO WHILE) [AWG].      6 Jun 1988:  Fixed cond. compilation bug (added t.null emission) [AWG].     18 Aug 1988:  Added t.swapcde for non-swapping of scon's and data [AWG].     29 Sep 1988:  Added Model D to configuration statement [AWG].     15 Mar 1989:  Fixed bug in pass-3 with eof at sector end [CWJ/MWH].     14 Apr 1989:  Pass-1 stats now prints correct # symbols used [CWJ/MWH].     17 Jan 1990:  Enhanced for better Model D debugging [MWH].     24 Oct 1990:  Expanded key range by introducting 'alternate' [CWJ].                   keys used for logical expression transfer of control*/configuration modelD, nomuldiv;pdl 512;insert ':xpl611:defs'; 		/* general definitions */insert ':xpl611:p1-defs'; 	/* pass1 definitions */insert ':xpl611:p12-defs'; 	/* pass 1 and 2 specific definitions */insert ':xpl611:overlay'; 	/* get overlay and open routines */when break then call exit(-1); /* stop on break while printing */pass1: proc(stab.ptr, stsiz, iflen) fixed;   dcl stab.ptr fixed; /* pointer to symbol table */   dcl stsiz    fixed; /* size of symbol table */   dcl iflen    fixed array; /* IF length (returned) */   dcl trmst    fixed; /* termination status */   insert ':xpl611:p1-1';   insert ':xpl611:p1-2';   insert ':xpl611:p1-3';   insert ':xpl611:p1-4';       call init; /* initialize */   call s.block; /* start a block */   call scan; /* get first token */   do while (token <> t.eof); /* compile until we reach the end of the file */      call stmt;   end;   call s.endblock; /* end the block */       call emit (t.eof);  /* emit end of file */   call emit (t.eof);  /* remember pass two reads one extra word */        /* check for clean termination of pass1 */   if ram ige extern.base then call er.ptl; /* was too much ram allocated? */   if (stackpt or blocks.in.use) <> 0 then do; /* did not deallocate all of STORE */     print;     print '### Compiler system error detected (stackpt', stackpt, '  blocks', blocks.in.use, ')';     call exit(-1);   end;   iflng = ifsec + shr(ifpos, 8) + ((ifpos and "377") <> 0); /* compute file length (sectors) */   call ifforce; /* force intermediate file */   iflen (0) = 0; if ifstart + ifofs ilt ifstart then iflen (0) = 1; /* determine MS sector offset */   call writedata (ifdev + iflen (0), ifstart + ifofs, com, maxcomm + 1); /* write out interpass comm area */   iflen (0) = iflng; /* return the IF length */   return (trmst); /* return the termination status */end pass1;/* Pass one initialization and termination: */dcl stab.ptr  fixed; /* symbol table pointer */dcl stsiz     fixed; /* size of symbol table */dcl iflen     fixed; /* interfile length */dcl term_stat fixed; /* termintion status */  redirection_word = no_redirection; /* cancel any I/O redirection */if (core(loc.cmed) or core(loc.wmed)) <> 0 then do;   print 'System error with disk configuration (.WORK missing).'; /* crashola */   call exit(-1);end;if (core(loc.wsln) and (ifsecl - 1)) <> 0 then do; /* work file error */   print 'System error with disk configuration (.WORK is wrong length).';   call exit(-1);end; stab.ptr = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* start symbol table at heap */stsiz = loc.load - stab.ptr - max_sym_len; /* compute size of table (less MAX_SYM_LEN because we don't look before we save symbols) */call blockset (location(stab.ptr), stsiz, 0); /* zero out symbol table */if core(loc.rst) <> 0 /* compile? */then print 'Scientific XPL version 6.11 - October 25, 1990';term_stat = pass1 (stab.ptr, stsiz, location(addr(iflen)));  /* We have finished scanning the source file.  An intermediate.  file has been generated.  Now overlay pass2. */  core(loc.usr1) = iflen; /* patch the interfile length into memory */if term_stat = 0 /* clean termination? */then call overlay (core(loc.p2 + 1), core(loc.p2), core(loc.p2 - 1)); /* yes, overlay pass2 */call exit(-1); /* no, abort */