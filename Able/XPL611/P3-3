/* Resolve external references:..    This procedure reads thru a library file (or MAIN) and appends.    the contents to the interfile.  In the process, it builds up.    the external names in the symbol table and keeps track of.    the maximums of ram area, labels, etc.  Five parameters are.    passed:  LIBDEV (device of library file), LIBSTART (starting.    sector of library file), LIBLEN (length of library file),.    MAINFLAG (if set, we are resolving the MAIN program). */resolve: proc(libdev, libstart, liblen, mainflag); /* collect library data and try to resolve references */   dcl libdev   fixed; /* device of library file */   dcl libstart fixed; /* starting sector of library file */   dcl liblen   fixed; /* length of library file (sectors) */   dcl mainflag fixed; /* true if resolving MAIN */   dcl libsec   fixed; /* file position (sector number) in library file */   dcl libpos   fixed; /* buffer position for library file */   dcl t.scon   fixed; /* total scon/data used by this library */   dcl t.key    fixed; /* total keys used by this library */   dcl t.alt    fixed; /* total alt keys used by library  */   dcl t.ram    fixed; /* total ram used by this library */   dcl word     fixed; /* present word read from file */   dcl i        fixed;   dcl j        fixed;   dcl max      fixed; /* counter and other info      */   dcl copy     fixed; /* for fast copy routine       */   dcl ovbase   fixed; /* below.                      */   dcl ifbase   fixed;   dcl cont     fixed;   dcl special_records data (5, et.eof, et.sym, et.mod, et.lib, et.ldf);   dcl special         (et.max)  fixed;   dcl readlib lit 'readovr'; /* use overlay reading routine */   dcl model_ data ('Model A processor'); /* model number template */   em.ref: proc(pt, key); /* emit external symbol reference record to IF */      dcl (pt, key, a.loc) fixed; /* symbol table pointer, external key */      call copyif (et.ref); /* start with record type */      call copyif (pt); /* emit a pointer to the symbol */      call copyif (key); /* emit the external key used for this symbol */   end em.ref;/* Resolve references (cont.):.     Initialize. */   ovdev = libdev; /* point to start of library */   ovstart = libstart;   ovsecln = liblen; /* set length */   call resetovr; /* and prime buffer */   if mainflag then do; /* for MAIN */       call add_lib ('MAIN'); /* add in the name of the main program */      t.key  = r (l.key);      /* get total keys                    */      t.alt  = r (l.altkey);   /* get total alternate keys          */      t.ram  = r (l.ram) - 1;  /* get total ram                     */      t.scon = r (l.str.data); /* get total string constants/data   */      recurs.parms (current_lib) = r (l.recurs.parms); /* save canonical parms location */      do i = 0 to whentablen - 1; /* copy over when table */         when_label (i) = r (l.icell + i); /* label */         when_library (i) = current_lib; /* and library number */      end;   end; /* of for MAIN */   else do; /* only if library */      word = readlib; /* get length of library data from library header */      if readlib <> et.revision then do; /* is this the correct revision IF? */         print;         print 'Library "', string(location(addr(lib_name (name_lib (current_lib))))), '" incompatible with current compiler.',;         call er.ftl ('Please recompile it'); /* abort */      end; /* of wrong revision */      t.key  = readlib;      /* total keys used in library */      t.alt  = readlib;      /* total alternate keys used  */      t.ram  = readlib - 1;  /* and total ram used         */      t.scon = readlib;      /* total string/data area     */      r (l.flags) = (r (l.flags) or readlib); /* make sure the proper flags are set */      recurs.parms (current_lib) = readlib; /* save canonical parms location */      do i = 0 to (word - 7) - 1; /* skip rest of info */         word = readlib; /* get next word */         if (i < whentablen) and (word <> 0) then do; /* keep track of any when statements */            if when_label (i) <> 0 /* already one there */            then call er.usr ('Duplicate WHEN statement', '', i, 0, current_lib, when_library (i));            else do; /* new when */               when_label (i) = word; /* save label */               when_library (i) = current_lib; /* and library number */            end; /* of new when */         end; /* of have a when statement present */         if i = whentablen + 1 then do; /* I = WHENTABLEN is start of configuration; + 1 is options word */            /* if previously compiled for ModelC or later & linked   */            /* in w/Model A or B                                     */            if (((shr(word, 8) and "7") >= 2) and (prctyp < 2)) then do;                call pbyte(model_, 6, (shr(word, 8) and "7") + "101");                call er.usr ('Configuration mismatch:  Library compiled with', model_, 0, 0, current_lib, deflib_sym (current_lib));            end;         end; /* of checking processor type */      end; /* of skip rest of info */   end; /* of only if library */   b.scon (current_lib + 1) = b.scon (current_lib) + t.scon; /* set the bases for next library */   if b.scon (current_lib + 1) ilt t.scon then call er.usr ('Too many constants', '', 0, 0, current_lib, 0);   b.key  (current_lib + 1) = b.key  (current_lib) + t.key;   if b.key (current_lib + 1) ilt t.key then call er.usr ('Too many keys', '', 0, 0, current_lib, 0);   b.alt  (current_lib + 1) = b.alt  (current_lib) + t.alt;   if b.alt (current_lib + 1) ilt t.alt then call er.usr ('Too many alt keys', '', 0, 0, current_lib, 0);   b.ram  (current_lib + 1) = b.ram  (current_lib) + t.ram;   if b.ram (current_lib + 1) ilt t.ram then call er.usr ('Too many variables', '', 0, 0, current_lib, 0);/* Resolve references (cont.):.     Copy the file over, recording library information where appropriate..     Handle a symbol. */   call blockset (special, et.max + 1, 0);    /* set up SPECIAL array */   do i = 1 to special_records (0);           /* for fast copy        */      special (special_records (i)) = 1;      /* routine below.       */   end;   word = readlib; /* read first word from library */   do while (word <> et.eof); /* continue til end of this library */      /* Perform fast copy of blocks of instructions to speed */      /* up link time                                         */      ovbase = ovpos-1;          /* get current pos in library file */                                 /* minus 1 because we have already */                                 /* read the word.                  */      ifbase = ifpos;            /* get current pos in inter file   */      max = ovbufl - ovbase;     /* find how much room left in ovbuf */      i   = ifbufl - ifbase;     /* and in if buffer                 */      if i ILT max then max = i; /* get min of the two               */      if max > 5 then do;       /* look for fast copy if make sense */         max = max - 3;         /* make smaller, so we always no    */                                /* NEXT TWO WORDS will always be    */                                /* in the buffer.                   */         copy = 0;              /* count data to copy               */         cont = 1;              /* set flag to continue             */         do while cont <> 0;            if (word and literal.mask) <> 0 /* not a record (just a literal word) */            then do;               if (copy + 1) ILE max               then do;                  copy = copy + 1;                  word = ovbuf(ovbase+copy);   /* get next word */               end;               else cont = 0;            end;            else if special(word) <> 0      /* special record must be */            then cont = 0;                  /* processed below        */            else do;               i = et.length (word) + 1;    /* get actual record length */               if i = 0 then do;            /* if variable length record */                  i = 2 + (ovbuf(ovbase+copy+1) & 255);               end;               if copy + i ILE max               then do;                  copy = copy + i;                  word = ovbuf(ovbase+copy);   /* get next */               end;               else cont = 0;            end;         end;         if copy <> 0 then do;            call blockmove(loc(addr(ovbuf(ovbase))),                           loc(addr(ifbuf(ifbase))), copy);            write(r13) = addr(ifbuf(ifbase+copy));            ovpos      = ovbase + copy + 1;            force_if = 1;         end;      end;      /* now copy over special records,  or records at buffer boundaries */      /* with more care at a leisurely pace:                             */      if (word and literal.mask) <> 0 /* not a record (just a literal word) */      then call copyif (word); /* write out the word */      else if word = et.sym /* symbol reference? */      then begin; /* symbol */         dcl (totalread, tlen, bits, wlen, type)  fixed;         dcl (key, store, lnum, #args, a.loc, pt) fixed;         totalread = 0; /* nothing read so far */         #args = 0; /* no arguments yet */         a.loc = 0; /* no argument location yet */         i = readlib; /* bits | total len */         tlen = (i and "377"); /* get total length */         bits = (shr(i, 8) and "17"); /* and bits */         i = readlib; /* type | text length */         wlen = (i and "377"); /* length in words of text */         type = shr(i, 8); /* type like T.PROC etc */         key   = readlib; /* pick up location */         store = readlib; /* storage used */         lnum  = readlib; /* sequence number */         do i = 1 to wlen; /* copy over text of symbol */            name (i) = readlib;         end;         name (0) = wlen + wlen; /* set length of symbol in characters */         if (name (wlen) and "177400") = 0 then name (0) = name (0) - 1; /* set proper character length */         totalread = 4 + wlen; /* count words read */         wlen = wlen + 1; /* point to type info */		 if  (bits <> t.symonly)				/* if not a refonly situation					*/		 and (type = t.proc    )				/* procedures have special type fields			*/         then do; 								/* procedures have special type fields 			*/            key   = readlib; /* pick up proc's key */            #args = readlib; /* and number of arguments */            name (wlen + ti.len ) = 2 + #args; /* length of type info */            name (wlen + ti.typ ) = readlib; /* returns type */            name (wlen + ti.args) = #args; /* save number of args */            do i = ti.atyp to #args + (ti.atyp - 1); /* get type/location for each argument */               name (wlen + i) = readlib; /* get type of argument */               j = readlib; /* ignore location of argument */               if i = ti.atyp then a.loc = j; /* remember location of first argument */            end;            totalread = totalread + 3 + #args + #args;         end; /* special type fields */         else do; /* non-procedure record */            name (wlen + ti.len) = 1; /* only one word of type info */            name (wlen + ti.typ) = type; /* and this is the type */         end; /* of non-procedure record */		 do while (totalread < tlen);		 	call readlib;			totalread = totalread + 1;		 end;		          if totalread > tlen /* system error */         then call er.sys ('symbol record longer than expected', 'resolve'); /* abort *//* Resolve references (cont.):.     Finish handling a symbol definition/reference. */		 if (bits <> t.symonly) then do;			 pt = s.lookup; /* look up symbol in table */				 if pt = -1 then do; /* not defined */				pt = s.define; /* define the symbol */				call set_type_sym (pt, type); /* and the type */				call set_pubext_sym (pt, bits); /* mark as used */				call set_deflib_sym (pt, current_lib); /* set library for error messages */				call set_lnum_sym (pt, lnum); /* remember where it was (for error messages) */					if bits = t.public then do; /* definer */				   call set_store_sym (pt, store); /* storage used */				   call set_loc_sym (pt, key); /* save location/key */				   call set_loc_args (pt, a.loc); /* save first argument starting location */				end; /* definer */				else undef_ext = undef_ext + 1; /* must be T.EXTERN - count number of undefined externals */			 end;			 else do; /* previously defined */				j = get_typ (ptr_sym (pt)); /* point to type information */								i = 0;				do while ((i <= core(j)) and (core(j + i) = name (wlen + i))); /* check type info */					i = i + 1;				end; /* of check type info */				if i <= core(j) then call er.usr ('Types don''t match:', name, 0, lnum, current_lib, deflib_sym (pt));								if bits = t.public then do; /* check for definer */					if (pubext_sym (pt) and "17") = t.public /* two definers */					then call er.usr ('Duplicate definition:', name, 0, lnum, current_lib, deflib_sym (pt));					else do; /* not already defined */					  call set_deflib_sym (pt, current_lib); /* point to the defining library */					  call set_lnum_sym (pt, lnum); /* remember what line it was on */					  call set_store_sym (pt, store); /* and the storage used */					  call set_pubext_sym (pt, t.public); /* now it's defined (this is BITS) */					  call set_loc_sym (pt, key); /* save location/key */					  call set_loc_args (pt, a.loc); /* save first argument starting location */									  undef_ext = undef_ext - 1; /* we've found the definition */									  if undef_ext < 0 /* system error */					  then call er.sys ('negative number of undefined externals', 'resolve'); /* abort */					end; /* of not already defined */				end; /* check for definer */			 end; /* previously defined */				 if bits = t.extern /* if an external reference */			 then call em.ref (pt, key); /* emit external symbol reference */     	 end;	  end; /* of symbol *//* Resolve references (cont.):.     Handle libraries and all types which can be ignored. */      else if word = et.mod then do; /* module */         do i = 1 to readlib; /* skip record for now */            call readlib;         end;      end; /* module */      else if word = et.lib then do; /* library */         i = readlib; /* get length of whole block */         call readlib; /* skip line number library was defined on */         do i = 0 to (i - 1) - 1; /* copy over text */            j = readlib; /* get text */            if i <= name_size /* save name if not too big */            then name (i) = j;         end;         if name (0) > shl(name_size, 1) /* limit size of name */         then name (0) = shl(name_size, 1); /* to max size of name */         call add_lib (name); /* save this library name */      end; /* library */      else if ((word = et.ldf) and mainflag) then do; /* library definition for MAIN? */         call copyif (word); /* copy record type */         call readlib; /* ignore library number passed by pass2 */         call copyif (current_lib); /* replace with current library number */      end; /* of library definition for MAIN */      else if word = et.eof then do;         /* nothing - copied below */      end;      else do; /* copy other records */         call copyif (word); /* copy the record type to the IF */         j = et.length (word); /* get record length */         if j = -1 then do; /* variable length record */            j = readlib; /* pick up length */            call copyif (j); /* copy it to the IF */            j = (j and "377"); /* keep just the length */         end;         do i = 1 to j; /* copy the record over */            call copyif (readlib);         end;      end; /* handle a record */       if word <> et.eof      /* if we are not sitting at the eof */      then word = readlib;   /* then get next word               */         end; /* while more */   call copyif (et.eof); /* and copy the end-of-file over */   call closeovr; /* close the file */end resolve;/* Relocate variables, constants, and keys:..   This phase reads through the file with all the libraries and.   relocates the scon, key and ram areas. */relocate: proc(current_lib, loc_ref);   dcl current_lib fixed; /* the library to relocate */   dcl loc_ref     fixed array; /* place to store locations of external references */   dcl key         fixed; /* current key */   dcl pt          fixed; /* pointer into STABLE for symbol */   dcl i           fixed;   dcl ptl data ('Program too large for compilation (too many external references)');   adjust: proc(offset, base); /* relocate a pointer */      dcl offset fixed; /* the offset within the library */      dcl base   fixed array; /* the appropriate base array */      dcl reloc  fixed; /* the relocated pointer */      if offset ige extern.base /* is this an external reference? */      then do; /* yes, relocate to the appropriate public area */         if offset - extern.base ige max_refs /* too many external references? */         then call er.sys ('too many external references', 'relocate:adjust'); /* abort */         reloc = loc_ref (offset - extern.base); /* point to the public */      end;      else reloc = offset + base (current_lib); /* relocate within this library */      return (reloc); /* return the relocated pointer */   end adjust;/* Relocate pointers:..   Read over the whole library and relocate the pointers. */   /* relocate any when statements defined in this library */   do i = 0 to whentablen - 1;      if (when_library (i) = current_lib) and (when_label (i) <> 0) /* if this is the defining library */      then when_label (i) = when_label (i) + b.key (current_lib); /* add in the base */   end;   /* force recursive parameters into LOC_REF */   if recurs.parms (current_lib) ige extern.base then do; /* if canonicals are external (i.e., in a module) */      key = recurs.parms (current_lib) - extern.base; /* normalize first one */      do i = 0 to max_recurs_parms - 1; /* enter into LOC_REF */         if key ige max_refs /* too many external references? */         then call er.ftl (ptl); /* abort */         loc_ref (key) = r (l.recurs.parms) + i; /* set location of parm (WARNING: assumes allocated consecutively) */         key = key + 1; /* get next external loc (WARNING: assumes allocated consecutively) */      end; /* of entering into LOC_REF */   end; /* of canonicals are external */   key = readif; /* get first word from interfile */   do while (key <> et.eof); /* read till the end */      if (key and literal.mask) = 0 /* no need to relocate literals */      then do case (key - 1); /* handle records */         do; /* literal */            call skiprecord (key); /* no relocation */         end; /* literal */         do; /* transfer */            call readif; /* don't care about condition */            call writeif (adjust (readif, b.key)); /* relocate key */            call readif; /* skip over estimated key location */         end; /* transfer */         do; /* procedure call */            key = readif; /* get length to skip */            call writeif (adjust (readif, b.key)); /* relocate key */            i = 1;            do while (i < key); /* adjust any formal parameter keys if necessary */               if readif < 0 then do; /* if a key follows */                  call writeif (adjust (readif, b.key)); /* relocate it */                  i = i + 1; /* we read another word */               end;               i = i + 1; /* read a word */            end; /* of adjust any formal parm keys */         end; /* call */         do; /* rtp call */            call skiprecord (key); /* pass3 relocates rtp */         end; /* rtp call */         do; /* variable ptr */            call readif; /* skip destination */            do case (readif); /* branch on storage class */               call writeif (adjust (readif, b.ram)); /* relocate ram ptr (statics) */               call readif; /* skip automatics */            end;         end; /* variable ptr */         do; /* object ptr */            call writeif (adjust (readif, b.key)); /* relocate pointer key */         end; /* object ptr */         do; /* label def */            call writeif (adjust (readif, b.key)); /* relocate key for label */         end; /* label def *//* Relocate pointers (continued): */         do; /* data definition */            call skiprecord (key); /* nothing to relocate */         end; /* data definition */         do; /* copy data */            call skiprecord (key); /* pass3 relocates data */         end; /* copy data */         do; /* copy scon */            key = readif; /* get length to skip */            call writeif (adjust (readif, b.key)); /* relocate KEY of proc it's passed to (NOTE: this will relocate 0's) */            do i = 1 to key - 1; call readif; end; /* skip the rest of the record */         end; /* copy scon */         do; /* ignore */            call skiprecord (key); /* ignore it */         end; /* ignore */         do; /* procedure def */            key = (readif&255); /* get length of procedure record */            call writeif (adjust (readif, b.key)); /* relocate procedure label */            call writeif (adjust (readif, b.ram)); /* relocate ram base */            call writeif (adjust (readif, b.ram)); /* relocate temp base (meaningless for recursives) */            call push (readif); /* push procedure attributes onto stack for proc end */            do i = 1 to key - 4; /* relocate parameter locations */               call writeif (adjust (readif, b.ram)); /* relocate parameter location */            end;         end; /* procedure def */         do; /* procedure end */            call writeif (adjust (readif, b.key)); /* relocate proc's key */            call writeif (adjust (readif, b.ram)); /* relocate ending ram location */            if (pop and p.recursive) = 0 /* if not in a recursive proc */            then call writeif (adjust (readif, b.ram)); /* relocate ending temp location */            else call readif; /* don't relocate temps offset */            call readif; call readif; call readif; /* ignore stack len, regs used, data NOSWAP bit list */         end; /* procedure end */         do; /* when statement */            call writeif (adjust (readif, b.key)); /* relocate key */         end; /* when def */         do; /* end when */            call writeif (adjust (readif, b.key)); /* relocate key */            call readif; /* ignore bits word */         end; /* end when */         do; /* string constant ptr */            call readif; /* destination */            call writeif (adjust (readif, b.scon)); /* relocate pointer */            call readif; /* swaps */         end; /* string constant ptr */         do; /* addr of fixed array parameter */            call writeif (adjust (readif, b.key)); /* relocate proc key */            call readif; /* skip parm number */         end; /* addr of fixed array parameter */         do; /* sequence number */            call skiprecord (key); /* skip it */         end; /* sequence number *//* Relocate pointers (cont.): */         do; /* symbol */            call skiprecord (key); /* skip over symbols (better not occur!) */         end; /* symbol */         do; /* module */            call skiprecord (key); /* skip over modules */         end; /* module */         do; /* library */            call skiprecord (key); /* skip over libraries */         end; /* library */         do; /* insert file */            call skiprecord (key); /* skip it */         end; /* insert file */         do; /* library definition */            call skiprecord (key); /* skip the definition */         end; /* library definition */         do; /* external symbol reference */            pt = readif; /* pick up symbol pointer */            key = readif; /* external key of symbol */            if key - extern.base ige max_refs /* too many external references? */            then call er.ftl (ptl); /* abort */            loc_ref (key - extern.base) = loc_sym (pt); /* save its real location (this works because references must come before usage) */            i = get_typ (ptr_sym (pt)); /* pick up pointer to type info */            if core(i + ti.len) >= ti.args then i = core(i + ti.args); else i = 0; /* pick up number of args from the symbol table */            do i = 0 to i - 1; /* relocate each argument */               key = key + 1; /* WARNING: Assumes pass1 allocates consecutive external keys for arguments (starting after proc key). */               if key - extern.base ige max_refs /* too many external references? */               then call er.ftl (ptl); /* abort */               loc_ref (key - extern.base) = loc_args (pt) + i; /* WARNING: Assumes pass1 allocates consecutive ram locations for arguments. */            end; /* of relocate each argument */         end; /* of external symbol reference */         do;    /* do case record - nothing required */         end;         do; /* transfer to alternate key */            call readif; /* don't care about condition */            call writeif (adjust (readif, b.alt)); /* relocate alternate key */            call readif; /* skip over estimated key location */         end; /* transfer to alternate key */         do; /* label def of alternate key */            call writeif (adjust (readif, b.alt)); /* relocate alt key for label */         end; /* alt label def */      end; /* of handle records */      key = readif; /* get next word from interfile */   end; /* till EOF */   call writeif (et.ign); /* ignore EOF next pass */end relocate;/* Link in any referenced libraries:..     This procedure constitutes the XPL linker.  Any library statements.     in the main procedure will cause this linker to be invoked.  The.     function is strictly that of inserting relocatable libraries and.     assigning locations for any external variables...     The algorithm runs as follows:.       a) Examine the main procedure (MAIN) setting up the external symbol table..       b) Copy all referenced libraries (in the order they appear) to the IF..       c) Try to resolve all external references..       d) Create variable space for all publics (i.e., relocate their addresses)..       e) Relocate all variables to the end of the code segment. */link: proc(loc_ref); /* link in any referenced libraries */   dcl loc_ref fixed array; /* place to store external reference locations (RELOCATE only) */   dcl (i, j)  fixed;   dcl ptl data ('Program too large for compilation (libraries exceed work file length)');     em.tra: proc(con, key); /* emit a transfer record */     dcl (con, key) fixed; /* condition to transfer on, key to transfer to */     call readif; call writeif (et.tra); /* write record type */     call readif; call writeif (con); /* write transfer condition */     call readif; call writeif (key); /* write key to transfer to */     call readif; call writeif (-1); /* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE) */   end em.tra;   em.ldf: proc(lib); /* emit library definition to IF */      dcl lib fixed; /* the number of the library we're about to append to the IF */      call readif; call writeif (et.ldf); /* write out the record type */      call readif; call writeif (lib); /* and the library number */   end em.ldf;   relocate_defns: proc; /* relocate public definitions */      dcl stype fixed; /* storage type */      dcl i     fixed;      dcl storage_type data (2,2,2,2,-1, -1,-1,-1,-1,0, -1,0,-1,-1,-1, -1,1,1,-1,-1, -1); /* storage types table */      do i = 0 to nextsym - 1; /* relocate publics */         stype = storage_type (type_sym (i)); /* get area to relocate from */         if stype ige 3 /* is the value in range? */         then call er.sys ('incorrect storage type', 'relocate_defns'); /* abort */         do case (stype); /* branch on type */            call set_loc_sym (i, loc_sym (i) + b.scon (deflib_sym (i))); /* scon */            do; /* keys */               call set_loc_sym (i, loc_sym (i) + b.key (deflib_sym (i))); /* keys */               if loc_args (i) <> 0 then do; /* if external arguments */                  if loc_args (i) <> recurs.parms (deflib_sym (i)) /* if not recursive variable defn */                  then call set_loc_args (i, loc_args (i) + b.ram (deflib_sym (i))); /* start of args */                  else call set_loc_args (i, r (l.recurs.parms)); /* set to start of recursive parms */               end; /* of external arguments */            end; /* of keys */            call set_loc_sym (i, loc_sym (i) + b.ram (deflib_sym (i))); /* ram */         end; /* of branch on type */      end; /* of relocate publics */   end relocate_defns;/* Link in any referenced libraries (cont.): */   iteration = iteration + 1; /* initiate next pass through IF */   current_lib = 1; /* start with library number one */   i = 0; if ifstart + shr(maxcomm + 255, 8) ilt ifstart then i = 1; /* calculate carry */   call resolve (ifdev + i, ifstart + shr(maxcomm + 255, 8), ifsecln, 1); /* resolve MAIN */   current_lib = current_lib + 1; /* point to first library */   do while (current_lib <= next_lib); /* load all libraries (NEXT_LIB is set by RESOLVE) */      if not open (location(addr(lib_name (name_lib (current_lib))))) then do; /* open the next library */         print;         print 'File ''', string(location(addr(lib_name (name_lib (current_lib))))), ''' could not be opened';         call cat_err;         call exit(-1);      end;      if f#type <> t#reloc then do; /* complain if not a relocatable binary */         print;         print 'Specified library ''', string(location(addr(lib_name (name_lib (current_lib))))), ''' is not a relocatable binary.';         call exit(-1);      end;      if ((f#words = 0) and (f#ms_length = 0) and (f#ls_length = 0)) then do; /* zero length library */         print;         print 'Specified library ''', string(location(addr(lib_name (name_lib (current_lib))))), ''' is zero-length.';         call exit(-1);      end;      if f#ms_length <> 0 then do; /* library too large */         print;         print 'Specified library ''', string(location(addr(lib_name (name_lib (current_lib))))), ''' is too large.';         call exit(-1);      end;      ifsecln = ifsecln + f#ls_length; /* update IF sector length (approx. because we write additional info and don't copy it all) */      if ifsecln igt ifmaxln then call er.ftl (ptl); /* make sure won't push us over edge */      call em.ldf (current_lib); /* write the library number to the IF */      call resolve (f#ms_sector, f#ls_sector, f#ls_length, 0); /* append the library file to the IF */      current_lib = current_lib + 1; /* point to next available library structure space */   end;   if ndisk <> 0 then do; /* were any libraries from a different disk? (NDISK is in OVERLAY) */      print 'Re-insert original user diskette into ',;      call getresponse (ndisk); /* get the original disk */   end;   if undef_ext > 0 then do; /* were all references resolved? */      do i = 0 to nextsym - 1; /* print out unresolved references */         if pubext_sym (i) <> t.public /* is this one defined? */         then call er.usr ('Unresolved reference: ', loc(get_sym (ptr_sym (i))), 0, lnum_sym (i), deflib_sym (i), 0);      end;   end;   r (l.str.data) = b.scon(next_lib + 1); /* record new lengths */   r (l.key     ) = b.key (next_lib + 1);   r (l.altkey  ) = b.alt (next_lib + 1);   r (l.ram     ) = b.ram (next_lib + 1) + 1; /* add one to account for RAM start at one */   current_lib = 1; /* search all libraries */   do while ((r (l.recurs.parms) = 0) and (current_lib <= next_lib)); /* check for recursive parms */      if recurs.parms (current_lib) <> 0 then do; /* if canonicals for recursive parms not allocated yet */         r (l.recurs.parms) = ram; /* allocate after variables */         ram = ram + max_recurs_parms; /* need this many words */      end; /* of allocating canonicals for recursive parms */      current_lib = current_lib + 1; /* check next */   end; /* of check for recursive parms */   call relocate_defns; /* relocate public definitions */   call resetif (0); /* reset to the beginning of the interfile again */   iteration = iteration + 1; /* initiate next pass through IF */   do current_lib = 1 to next_lib; /* relocate each library */      call relocate (current_lib, loc_ref); /* relocate variables */   end;   ifsecln = ifsecln + 1; /* update IF sector length to make room for transfer and EOF (approx.) */   if ifsecln igt ifmaxln then call er.ftl (ptl); /* make sure won't push us over edge */   call em.tra (b.tra, main_key); /* transfer to main program */   call readif; call writeif (et.eof); /* write out an EOF (this is the REAL end of file) */   i = ifsec + shr(ifpos + 255, 8); /* get exact length of interfile (can't use POSIF because IFSEC may be large) */   call resetif (0); /* reset and flush the IF */   ifsecln = i; /* update IF sector length (after RESETIF so RESETIF knows proper buffer length) */   do i = 0 to whentablen - 1; /* set labels of when statements in interpass comm area */      r (l.icell + i) = when_label (i);   end;   do i = 0 to devtablen - 1; /* set labels of device driver entry points */      do case (i); /* branch on driver we're looking for */         call strcpy (name, 'WIN1READ');         call strcpy (name, 'WIN1WRITE');         call strcpy (name, 'DEV8READ');         call strcpy (name, 'DEV8WRITE');         call strcpy (name, 'DEV10READ');         call strcpy (name, 'DEV10WRITE');         call strcpy (name, 'DEV12READ');         call strcpy (name, 'DEV12WRITE');         call strcpy (name, 'DEV14READ');         call strcpy (name, 'DEV14WRITE');         call strcpy (name, 'DEV8TYPE');         call strcpy (name, 'DEV10TYPE');         call strcpy (name, 'DEV12TYPE');         call strcpy (name, 'DEV14TYPE');      end;      j = s.lookup; /* see if it's there */      if ((j <> -1) and (((i < devdrivers) and (type_sym (j) = t.proc)) /* if we found it */      or ((i >= devdrivers) and (type_sym (j) = t.var)))) /* watch out for device types */      then device_label (i) = loc_sym (j); /* remember where it is */   end; /* of setting labels for device driver entry points */   do i = 0 to spectablen - 1; /* set labels of special procedure entry points */      do case (i); /* branch on driver we're looking for */         call strcpy (name, 'OVERLAY');      end;      j = s.lookup; /* see if it's there */      if  (j             <>   -1)       and (type_sym (j) = t.proc)      then special_label (i) = loc_sym (j);   end;    if link_error <> 0 /* did we make it through the link phase without any errors? */   then call exit(-1); /* no, abort */end link;