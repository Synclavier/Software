/* This procedure sets any compile-time flags based on the passed character. *//* 12-5-88 - cj - changed intermediage file offsets for humungous work files */set_flags: proc(c); /* set compile-time flags */   dcl c fixed; /* character flag */   c = toupper (c); /* uppercase it */   if      c = a.d then flags = (flags or dump.flag); /* dump stats */   else if c = a.m then flags = (flags or symtab.flag); /* dump symbol map */   else if c = a.x then public_procs = true; /* make all procs public */   else if c = a.o then flags = (flags or skip.flag);   /* no optimize */   else if c = a.f then flags = (flags or force.flag);  /* force code to ext memory */   else if c = a.z then do;      if (flags and debug.flag) = 0    /* Haven't printed this yet */      then print '   ==> Generating code for debugger <==';      flags = (flags or debug.flag);  /* gen better code for debugging */   end;end set_flags;/* Pass one initialization:..  Here we set up the global variables and input/output file buffers. We.  also read in the XPL symbol table from the disk. */init: proc;   dcl chr fixed; /* last character read from the symbol table file */   call setup_args (name); /* set up command line arguments; ignore COM command */   call next_arg (name); /* get first command line argument */   do while (name (0) <> 0); /* pick up all command line arguments */      if byte(name, 0) = a.minus /* if starts with minus sign */      then do chr = 1 to name (0) - 1; /* set options */         call set_flags (byte(name, chr)); /* set flags appropriately */      end; /* of setting options */      call next_arg (name); /* get next command line argument */   end; /* of picking up command line arguments */   if core(loc.emsize) igt shr(stsiz, 8) then do; /* if there's more external memory available */      xmem = 1; /* use external memory */      stab.ptr = 0; /* put the symbol table at the start of external memory */      if core(loc.emsize) ige 256 /* stsiz = min(65536 - MAX_SYM_LEN, extmem_size); */      then stsiz = /* 65536 */ - max_sym_len; /* minus MAX_SYM_LEN because we leap before we look (i.e., save symbols before checking if there's room) */      else stsiz = shl(core(loc.emsize), 8);      call extset (stab.ptr, 0, stsiz, 0); /* zero it out */   end; /* end of use external memory */   #st = stsiz; /* initialize for proper stats printout in pass3 */   pdll = 256; /* default user pdl is 256 words */   ram = 1; /* start variable area at location 1 to keep 0 unused */   extloc = extern.base - 1; /* start externals here */   recurs.parms = 0; /* no recursive parameters */   stptr = 1; /* symbol table pointer - location 1 not used */   ptptr = stsiz - 1; /* procedure table pointer - starts at top of symbol table */   call create_heap (addr(aliases (0)), alias_len, addr(handles (0)), handle_len); /* create alias heap */       do chr = 0 to configlen - 1; /* copy the configuration area over into the interpass communications area */      com (l.ctab + chr) = core(loc.ctab + chr);   end;   sfdev = core(loc.st + 1);   sfstart = core(loc.st);   sflngth = core(loc.st - 1); /* start source file in symbol table */   ifdev = core(loc.wsec + 1); ifstart = core(loc.wsec); ifsecln = core(loc.wsln); /* work file    */        readl = sflngth; if readl igt sfbufl then readl = sfbufl; /* readl = min(sflngth, sfbufl); */   call readdata (sfdev, sfstart, sfbuf, readl); /* fill up first buffer */        ifofs = 32; /* start normally at 8K (two 4K offsets) */   if ifsecln ige 128 then ifofs = 64; /* else use two 8K offsets (16K) */   if ifsecln ige 256 then ifofs = 128; /* use two 16K segments for huge work file */        /* use 256 sector offset for 4096 sector work files.  increase linearly */   /* to 512 sector offset for 8192 files,  etc.   make multiple of 32.    */   if ifsecln ige 4096 then ifofs = shr(ifsecln,9)*32;/* Dynamic construction of symbol table:.  .   The symbol table is dynamically constructed at runtime..   This is because  .     1. it is always changing,  and .     2. the hashcode function and buckets would be .        too difficult to compile in as just data.*/        chr = gc; /* get first character */   do while chr <> 0; /* and look for the null at the end of symbol disk */      token = 0;      do info = 0 to chr - 1; /* and scan off the bytes */         chr = gc; /* get the byte */         if info then name (token) = (name (token) or shl(chr, 8)); /* or in second byte */         else begin; /* first byte */            token = token + 1;            name (token) = chr; /* save it */         end;      end;      name (0) = token; /* save count */      token = gc; info = gc; /* get new stuff */      call s.lookup; /* get the symbol */      chr = s.define (name.pt, hashcode); /* define the symbol */      call ptok (chr, token); call set_stable (chr + s.locn, info); /* save symbol info */      chr = gc; /* and get next,  end with zero */   end; /* of symbol read loop */        /* now read in the symbol definitions for the runtime package routines */        chr = gc; /* get the next character */   do while chr <> 0; /* and terminates with a zero */      token = 0;      do info = 0 to chr - 1; /* and scan off the bytes */         chr = gc; /* get byte */         if info then name (token) = (name (token) or shl(chr, 8)); /* or in next byte */         else begin;            token = token + 1;            name (token) = chr;         end;      end;      name (0) = token;      call s.lookup; /* look it up in symbol table */      chr = s.define (name.pt, hashcode); /* define it */      call ptok (chr, t.rtp); call set_stable (chr + s.locn, ptptr); /* save pointer */      call set_stable (ptptr + p.key, shl(gc, 1)); /* get address, shift left */      call set_stable (ptptr + p.args, gc); /* get number of args */      call set_stable (ptptr + p.rtyp, gc); /* get type */      do chr = 0 to 6 by 2; /* get args */         call set_stable (ptptr + p.parm - chr, gc); call set_stable (ptptr + p.parm - chr - 1, gc);      end;      ptptr = ptptr + p.parm - shl(stable (ptptr + p.args), 1); /* and update length */      chr = gc;   end; /* and that is it */        /* now open up source file */       sfdev = core(loc.csec + 1); sfstart = core(loc.csec); sflngth = core(loc.clen); /* set source file to current file */   bc = 0; sfflp = 0; sfpos = 0; sfsec = 0; /* clean up */   readl = sflngth; if readl igt sfbufl then readl = sfbufl;   sfbuf (0) = 0; /* to get line number correct if zero length file */   call readdata (sfdev, sfstart, sfbuf, readl); /* read first one */   line.no = sfbuf (0); /* set up first line number for compiling printout */   do token = 0 to 255; /* save one sector for the interpass comm area */      call emit (0);   end;end init;/* String constant processing:  emit string constant to data areas..  .   String constant and other numeric data is emitted to the object file.   during pass1.  It is bound into the output file at the end of the.   initialization routine..  .   The following routine is called to emit a string constant.   (stored in the array 'NAME') out to the output file..  .   The string constant is written out to the file in a form that makes.   it look like an array (fixed point, etc.).*/  e.scon: proc(key, n); /* emit a string constant out to constant file */dcl (key, n)  fixed; /* key of proc this scon is passed to/parameter number it's passed as */dcl (i, j, k) fixed;i = str.data; /* get pointer to start of string */j = name (0); /* get number of bytes */k = shr(j + 3, 1); /* and total # of words of data */call emit (t.copys); /* indicate copy scon */call emit (k + 2); /* emit # of words */call emit (key); /* emit key of proc scon is passed to */call emit (n); /* and the parameter number it's passed as */do j = 0 to k - 1; /* copy out entire string including # of byte field */ call emit (name (j)); /* write out 16-bit word */end;str.data = str.data + k; /* compute amount emitted */if str.data ilt k then call er.tmc; /* too many scons */return i;end e.scon;  e.scondata: proc; /* emit a string constant out to constant file */dcl (i, j, k) fixed;i = str.data; /* get pointer to start of string */j = name (0); /* get number of bytes */k = shr(j + 3, 1); /* and total # of words of data */call emit (t.copyd); /* indicate copy data */call emit (k); /* emit # of words */do j = 0 to k - 1; /* copy out entire string including # of byte filed */ call emit (name (j)); /* write out 16-bit word */end;str.data = str.data + k; /* compute amount emitted */if str.data ilt k then call er.tmc; /* too many data constants */return i;end e.scondata;  /* Data list initialization:.  .   Words of data generated by the 'DATA' statement are emitted.   to the object file in blocks of 10.  The array 'DBUF' holds.   up to 10 entries and is written to the intermediate file at.   appropriate intervals. */  dcl dbuf (9) fixed; /* 9 words           */dcl dbufp    fixed; /* pointer into same */  dbuffrc: procedure; /* call to force out */  if dbufp <> 0 then begin; /* only if data */    str.data = str.data + dbufp; /* and keep track of string data statistics */    call emit (t.copyd); /* record indicates copy data to inter file */    call emit (dbufp); /* and number of words */    do dbufp = 0 to dbufp - 1;      call emit (dbuf (dbufp));    end;    dbufp = 0; /* this is done */  end;end dbuffrc; /* force routine */  dbufemit: proc(word); /* emit one word */  dcl word fixed;  dbuf (dbufp) = word; /* save word */  dbufp = dbufp + 1;  if dbufp = 10 then call dbuffrc; /* force it if can */end dbufemit; /* bleep */  /* Scanner:  fixed to floating conversion..  .   During pass1, numeric constants are converted from a sequence of.   digits into an internal form.  For fixed point data, this internal.   form is a binary representation.  For floating point data, the.   32-bit word is generated..  .   Sometimes it is necessary to convert from one form to another..   The following routines do that:*/  dcl (fval1, fval2) fixed; /* used to return floating pont values */  float: proc(val); /* and convert fixed to floating */  dcl (val, sign, exp) fixed; /* components */  fval1 = 0; fval2 = val; /* mask to 16 bits on DTSS */  sign = shr(fval2, 15); /* extract single sign bit */  exp = 64 + 31; /* start here */  if sign then fval2 = -fval2; /* mantissa is always + */  if fval2 <> 0 then do; /* if any mantissa */    do while (fval1 and "040000") = 0; /* shift until normalized */      fval1 = shl(fval1, 1); /* extract 16-bits */      if (fval2 and "100000") <> 0 then fval1 = (fval1 or 1);      fval2 = shl(fval2, 1); /* mask to 16 bits on DTSS */      exp = exp - 1;    end;    fval1 = fval1 or shl(sign, 15);    fval2 = ((fval2 and "177600") or exp); /* and fval2 */  end;end float;  /*  The following subroutine is used by the token scanner in the conversion.   to floating point constants.  During compilation, sequences of digits.   that represent floating point constants are converted to an internal.   32 or 36 bit form..  .   The routine 'FDIVIDE' is used to fractionally divide two numbers passed .   as arguments.  A value equal to the fractional division is returned..  .   Obviously, the first number must be less than the second number for.   the division to work properly.*/  dcl (c1, c2) fixed; /* global variables which hold answer */  fdivide: proc(a1, a2, b1, b2); /* perform fractional divide on 32-bit ints */dcl (a1, a2, b1, b2, i) fixed; /* internal */  c1 = 0; c2 = 0; /* initialize answer */  do i = 0 to 30; /* 31 ties, as these are 31-bit precision */    a1 = shl(a1, 1); /* shift left (DTSS mask to 16 bits) */    if (a2 and "040000") <> 0 then a1 = (a1 or 1);    a2 = (shl(a2, 1) and "077777"); /* keep to 15-bit */    c1 = shl(c1, 1); /* (DTSS mask to 16 bits) */    if (c2 and "040000") <> 0 then c1 = (c1 or 1);    c2 = (shl(c2, 1) and "077777"); /* keep to 15-bit for compares */    if (a1 > b1) or ((a1 = b1) and (a2 >= b2)) then do; /* can subtract */      c2 = (c2 or 1); /* set answer bit */      if b2 > a2 then a1 = a1 - 1; /* is a borrow */      a2 = ((a2 - b2) and "077777"); /* keep to 15-bit quantity */      a1 = a1 - b1; /* bleep */    end;  end;end fdivide;  /* Insert file processing:.  .   The routine 'POPF' is used to pop back up from an insert.   file into the original program..  .   It is called from within the scanner when an EOF statement or.   end of file condition is encountered, when inside an insert file..  .   After calling POPF, the scan should be restarted..  .   First our own stack:*/  dcl ispt fixed; /* stack pointer - 0 means in source file */dcl nchr fixed; /* nchr - is fixed */dcl lchr fixed; /* previous nchr   */dcl (pchrp, chrbase, chrpt, chrln) fixed; /* macro processing */dcl n.info fixed; n.info = b.eol; /* starts at end of line */  ipush: proc(word); /* push word onto stack */  dcl word fixed;  if ispt > istklen then call er.tmni; /* too many nested inserts */  istk (ispt) = word; /* store word on bottom of stack */  ispt = ispt + 1; /* incr */end ipush; /* done */  ipop: proc; /* recover word */  ispt = ispt - 1; /* decr */  return istk (ispt); /* get word and return it */end ipop;/* POPFILE:..  The procedure POPFILE is used to restore the compiler back to.  an earlier source file after processing an INSERT statement...  While processing an insert file, various information is stored on.  a stack to allow nested INSERT statements.*/popfile: proc; /* procedure to pop up one file */   dcl i fixed; /* internal temp */   newdisk = ipop; /* record whether or not a new disk was reqd */   n.info = ipop; /* restore character info */   nchr = ipop; chrln = ipop; chrpt = ipop; pchrp = ipop; chrbase = ipop; /* restore character info */   line.no = ipop; /* restore linenumber */   word = ipop; bc = ipop; sfpos = ipop;   sfsec = ipop; sfflp = ipop; sflngth = ipop; sfstart = ipop; sfdev = ipop; /* recover info */   a#ms_sector = ipop; a#ls_sector = ipop; /* reset alternate starting sector */   a#dir_size  = ipop; /* pick up directory size */   a#ms_length = ipop; a#ls_length = ipop; /* and length */   i = 4;   do while i >= 0; cfname (i) = ipop; i = i - 1; end; /* and names */   call emit (t.stmt or shl(s.insert, 8)); /* emit end of insert file record */   call emit (0); /* zero means insert file ended */      if newdisk <> 0 then do; /* if installed a new disk, must get original */      if cfname (0) = 0 then do; /* back to original */         print 'Re-insert original user diskette',;         ndisk = 0; /* we have the original disk back */      end;      else do; /* insert correct one */         print 'Re-insert the diskette containing "', string(cfname), '"',;      end;      print ' into ',;      call getresponse (newdisk); /* print 'drive and press return' and wait for cr */   end;   readl = sflngth - shl(sfsec, 8); /* get words left */   if readl igt sfbufl then readl = sfbufl;   i = 0; if sfstart + sfsec ilt sfstart then i = 1; /* determine MS sector offset */   call readdata (sfdev + i, sfstart + sfsec, sfbuf, readl); /* and fill up (maybe) buf */   if cfname (0) = 0 then cfnmes (0) = 0; /* no message if no file name */end popfile;  /* Main token scanner:.  .   The routine 'SCAN' is called to scan the next token from the source.   file..  .   The SCAN routine examines the next character in the source file..   If it is a special character (such as  + , *, /, etc.) then the.   proper token types ('TOKEN') and information ('INFO') is set.   and SCAN returns (after discarding the single input character)..  .   If the next character is a digit, the digits are converted to.   binary (either fixed or floating point, depending) and the.   value is returned in 'INFO'..  .   If the next character is an apostrophe, a string constant is scanned.   and packed into the global array 'NAME'..  .   Otherwise, characters are compacted until a terminal character is.   found.  The symbol table is consulted for a corresponding entry..  .   If the symbol is found in the table, its token type is returned.   in 'TOKEN' and its information is returned in 'INFO'.  Otherwise,.   a token type of 'T.UND'  will be returned.*/  dcl fstkptr fixed; /* used to rotarily allocate fstk */  do fstkptr = 0 to fstklen - 1;   fstk (fstkptr) = "100000"; /* indicate free slots */end;fstkptr = 0; /* and start with zero */  fstr: proc(a1, a2) fixed; /* called to store number info FSTK -  returns ptr */  dcl (a1, a2, pt) fixed;  pt = fstkptr; /* current pointer */  if fstk (pt) <> "100000" then call er.tmnc; /* too many numeric constants */  fstk (pt) = a1; fstk (pt + 1) = a2; /* store in stack */  fstkptr = fstkptr + 2; /* rotary buffer */  if fstkptr = fstklen then fstkptr = 0; /* end */  return pt; /* and return where stored */end fstr;/* Token scanner: */  scan: proc; /* main token scanner */ dcl saved.nchr  lit 'store1';dcl saved.chrb  lit 'store2';dcl saved.chri  lit 'store3';dcl saved.pchrp lit 'store4';  dcl (i, j) fixed; /* internal to 'scan' */ /* Scanner:  get next character subroutine. .  Returns the next character in 'NCHR'.  Previous character is kept.  in 'LCHR' and information about the new character is in 'NINFO'.*/ get.char: proc;    dcl info.table data (    b.eol + b.comnt, 0, 0, 0, 0, 0, 0, 0, 0, b.spa, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, b.spa, 0, 0, b.symb, b.symb + b.comnt, b.opr + o.fmu, b.opr + o.and, 0, b.spec + t.lpar, b.spec + t.rpar,     b.opr + o.times + b.comnt, b.opr + o.plus, b.spec + t.comma, b.opr + o.minus, b.symb,     b.opr + o.div + b.comnt  , b.digit + b.symb, b.digit + b.symb, b.digit + b.symb, b.digit + b.symb,     b.digit + b.symb, b.digit + b.symb, b.digit + b.symb, b.digit + b.symb,     b.digit + b.symb, b.digit + b.symb, b.spec + t.colon, b.spec + t.semi, b.relop + b.lt,     b.relop + b.eq, b.relop + b.gt, 0, 0, b.symb, b.symb, b.symb, b.symb, b.symb,     b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb,     b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb, b.symb,     b.symb, 0, b.opr + o.or, 0, b.relop + b.not, b.symb, 0, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase, b.symb + b.lcase,     b.symb + b.lcase, 0, b.opr + o.or, 0, b.relop + b.not, 0, b.spec + t.eof + b.comnt);    lchr = nchr; /* save previous character */    if pchrp <> 0 then do; /* we are in a literal string */       if chrln = 0 then do; /* end of this literal string - back down */          nchr    = saved.nchr (pchrp); /* restore NCHR */          chrbase = saved.chrb (pchrp);          chrpt   = saved.chri (pchrp);          chrln   = shr(chrpt,8);          chrpt   = (chrpt and "377");          call rel (pchrp); /* release this level of literal stacking */          pchrp = saved.pchrp (pchrp); /* note rel does not use STORE4 */       end;       else do; /* next character comes from literal */          nchr = stable (chrbase + shr(chrpt, 1) + 1); /* extract word with byte */          if chrpt then nchr = shr(nchr, 8); /* get upper half */          chrpt = chrpt + 1; /* increment char pointer */          chrln = chrln - 1; /* decrement length */       end; /* if char comes from this level of literal */    end; /* of literals instead of file */    else nchr = gc; /* get next character from file */        /* common routine */        if nchr = -1 then nchr = a.eof; else nchr = (nchr and "177");    n.info = info.table (nchr); /* get type bits */ end get.char; /* of get.char */ /* Scanner:  number scanner and evaluator..  .   The following routines assist in the conversion of fixed to.   floating point numbers.   . .   The routine 'MTEN' is called to multiply the global variables.   VAL1 and VAL2 by 10.   .   .   VAL1 is a 16-bit number, VAL2 is a 15-bit number.  Placed end.   to end, they form a 31-bit integer..  .   The routine 'VAL' converts a sequence of digits (12345678) to.   a VAL1/VAL2 31-bit integer.*/  dcl (val1, val2) fixed; /* double value returned by 'VAL' */  mten: proc; /* procedure to multiply (VAL1, VAL2) by 10 */  dcl (t1, t2) fixed;  if (val1 and "176000") <> 0 then call er.tmd;  t1 = (shl(val1, 3) or ((shr(val2, 12) and 7))); /* shift three times */  t2 = (shl(val2, 3) and "077777"); /* and three times to LSB */  val1 = val1 + val1; /* now times 2 */  val2 = val2 + val2;  if (val2 and "100000") <> 0 then val1 = (val1 or 1);  val2 = (val2 and "077777");  val1 = val1 + t1; /* now form times 10 */  val2 = val2 + t2; /* and here */  if (val2 and "100000") <> 0 then val1 = val1 + 1;  val2 = val2 and "077777"; /* and mask */end mten;  val: proc; /* and scan value of 10 */ val1 = 0; val2 = 0; /* initialize answer */ do while (n.info and b.digit) <> 0;   call mten; /* multiply current value by 10 */   val2 = val2 + nchr - a.0; /* and add in new digit */   if (val2 and "100000") <> 0 then val1 = val1 + 1; /* carry propagation */   val2 = (val2 and "077777"); /* and keep 15-bits only here */   call get.char; end;end val;  /* Get next character and check for the end of the line..  If we are at the end of the line, then the next character.  on the new line will be returned (after the optional line.  number and an optional space).*/ eol.ck: proc;  dcl (tlnum, plchr) fixed;  if (n.info and b.eol) <> 0 then do; /* check end of line */    if systyp = 0 then write("104") = 0; /* keep floppy going */    if curtyp = 0 then write("104") = (shr(current_device, 4) and "17"); /* keep current floppy going as well */    if curtyp = 2 then write("114") = (shr(current_device, 4) and "17"); /* keep current floppy going as well */    plchr = lchr; /* save character at end of line */    if bc then call get.char; /* and skip second one if left over */    call get.char; /* get first character of line number */    if nchr <> a.eof then do; /* NCHR is A.EOF by this time if end of file here */      tlnum = word; call get.char; /* scan full word and skip upper byte */      call get.char; /* and get first one of next line */      if tlnum <> 0       then line.no = tlnum;      else line.no = line.no + 1;    end;  /* of do if more in file */    if nchr = a.sp then call get.char; /* scan off optional blank */    lchr = plchr; /* restore lchr to end of previous line */  end;  else call get.char; /* if not end of line, scan one char */ end eol.ck; /* Scanner:  main routine */ SCAN.START:; /* return here */if (read("51") and 2) <> 0 then do; /* see if char typed */  i = (read("50") and "177"); /* get character */  if i = "23" then do; /* handle XOn/XOff */    j = 0; /* assume no BREAK */    do while (i <> "21"); if i = 0 then j = 1; i = (read("50") and "177"); end; /* wait for XOn (watch for BREAK) */    if j then i = 0; /* force BREAK after XOn */  end;  if i = 0 then do; call wait_for_break; call exit(-1); end; /* break */  if i <> "21" then print 'Compiling:     Pass 1         Line:   ', line.no, string(cfnmes), string(cfname);end;if systyp = 0 then write("104") = 0; /* keep floppies going */if curtyp = 0 then write("104") = (shr(current_device, 4) and "17"); /* keep current floppy going as well */if curtyp = 2 then write("114") = (shr(current_device, 4) and "17"); /* keep current floppy going as well */  name.pt = 0; /* assume initially that token is not symbol */dcl (point, point1) fixed; /* temps used in literal processing */ /* ignore what should be ignored */ do while (n.info and (b.spa + b.eol)) <> 0;call eol.ck;end; /* check for digit */  if (nchr = a.period) or ((n.info and b.digit) <> 0) then begin; /* number */ dcl (man1, man2, frac1, frac2, lzer1, lzer2, inf1, inf2) fixed; dcl (exp, infexp) fixed; call val; /* scan off decimal number */  if (nchr = a.period) or (val1 > 1) then do; /* see if fractional part */  inf1 = val1; inf2 = val2; /* save the integer mantissa part */  if nchr = a.period then do; /* find fractional part */    call get.char; val1 = 0; val2 = 1; /* set up to compute leading zeroes */    do while nchr = a.0;      call mten; /* multiply val by ten */      call get.char;    end;    lzer1 = val1; lzer2 = val2; /* save leading zero indicator */    call val; /* now scan off fractional parg */    frac1 = val1; frac2 = val2; /* save fractional part */    val1 = 0;val2 = 1; /* now compute denominator */    do while (val1 < frac1) or ((val1 = frac1) and (val2 <= frac2));      call mten; /* compute denominator - power of ten */    end;    call fdivide (frac1, frac2, val1, val2); /* now divide - compute fraction */    man1 = c1; man2 = c2; /* save result of fractional divide in man1, man2 */    man2 = (shr(man2, 2) or (shl(man1 and 3, 13))); /* shift right by two to avoid overflow */    man1 = shr(man1, 2); /* reduce it */    exp = -29; /* start here */    do while (lzer1 < man1) or ((lzer1 = man1) and (lzer2 <= man2));      lzer1 = shl(lzer1, 1);      if (lzer2 and "040000") <> 0 then lzer1 = (lzer1 or 1);      lzer2 = (shl(lzer2, 1) and "077777");      exp = exp + 1; /* bring up expoent */    end; call fdivide (man1, man2, lzer1, lzer2); /* and fractional divide */    man1 = c1; man2 = c2; /* and store here */  end;  else do; /* no fractional part */    man1 = 0; man2 = 0; exp = 0;  end;  /* now normalize the number: */    if (inf1 or inf2 or man1 or man2) <> 0 then do; /* must normalize */    infexp = 64 + 30; /* and this is where we start */    do while (inf1 and "040000") = 0; /* shift until normalized */      inf1 = shl(inf1, 1); /* shift all the bits left */      if (inf2 and "040000") <> 0 then inf1 = (inf1 or 1);      inf2 = (shl(inf2, 1) and "077777");      if exp >= 0 then do; /* if down to mantissa level,  then shift it in*/      if (man1 and "100000") <> 0 then inf2 = (inf2 or 1);      man1 = shl(man1, 1);      if (man2 and "040000") <> 0 then man1 = (man1 or 1);      man2 = (shl(man2, 1) and "077777");      end;      infexp = infexp - 1; /* reduce exponent */      exp = exp + 1; /* and keep track of separate mantissa point */    end;    if (infexp < 0) then call er.tmd; /* too many digits */    inf2 = ((shl(inf2, 1) and "177600") or infexp); /* or in exponent field */  end;    info = fstr (inf1, inf2); /* store pon stack */token = t.fconst; /* and is pointer */end;else do; /* fixed point constant */  token = t.const; info = (val2 or shl(val1, 15)); /* set up information */end; return; end;  /* check for leading symbol character (other than digit) */  if (n.info and b.symb) <> 0 then do; /* symbol */   point = 0; /* initialize pointer into name */   point1 = 1; /* set false to exit loop */   do while point1; /* accumulate symbol - note how we exit (this is fast!) */     if (n.info and b.lcase) <> 0 then nchr = nchr - (l.a - a.a); /* convert to uppercase */     call get.char; /* get next character - move NCHR to LCHR */     if (n.info and b.symb) <> 0 then do; /* means two letters */       if (n.info and b.lcase) <> 0 then nchr = nchr - (l.a - a.a);       point = point + 1; /* one full word */       name (point) = (lchr or shl(nchr, 8));       call get.char; /* get next character */       if (n.info and b.symb) = 0 then point1 = 0; /* exit loop */       if point = max_sym_len - s.length then point1 = 0; /* break out on symbol too long */     end;     else do;       point = point + 1; /* treat as full word - zeroes in upper half */       name (point) = lchr; /* save last character */       point1 = 0;     end;   end;      name (0) = point; /* fill in length field */   point = s.lookup; /* look the symbol up in the symbol table */      if point = 0 then do; /* undefined symbol */     token = t.und;     info = name.pt; /* return pointer here */     ufsp = name.pt; /* and save here also */     dcl.symbol = 0; /* we aren't in a DCL */     return;   end; /* of undefined symbol */    token = gtok (name.pt); /* get token type for this symbol */   info = stable (name.pt + s.locn); /* and pick up info */   if ((not dcl.symbol) and (gclas (name.pt) = s.automatic) and (depth < cur.proc.dpt))   then call er.crg; /* cannot reference global automatic */   if ((token = t.lit) and ((not dcl.symbol) or (depth = s.depth))) then do; /* if literal, then start it up */     point1 = get;           /* get a block for stacking literal nesting */     saved.nchr  (point1) = nchr;    /* saved delimiting character */     saved.chrb  (point1) = chrbase; /* saved buffer pointer       */     saved.chri  (point1) = chrpt \ shl(chrln,8);  /* saved buffer pointer       */     saved.pchrp (point1) = pchrp;   /* saved back pointer         */     pchrp   = point1; /* new back pointer */     chrbase = info;   /* literal base     */     chrpt = 0;        /* this is relative byte pointer to first character */     chrln = stable (info);      /* get number of bytes in literal string */     nchr = lchr; call get.char; /* preserve LCHR and get first lit */     goto SCAN.START; /* and start up scan agin */     end; /* of literal call */    else do; /* label is not a literal */     dcl.symbol = 0; /* we aren't in a DCL */     if ((token = t.stmt) and (info = s.declare)) then dcl.symbol = 1; /* next token should be a variable name; necessary - name is scanned by STMT before DCL processing */     if token <> t.eof then return; /* return directly with that */     if ispt = 0 then return; /* if eof of original source then return */     call popfile; /* go back up one file */     goto SCAN.START; /* and retry */   end;end; /* end of symbol scan */ /* Token scanner (cont):..   Check for special character (comma, semicolon, paren...) */  if (n.info and b.spec) <> 0 then do; /* special character */ token = (n.info and b.mask); call get.char; /* skip to next character */ if token <> t.eof then return; /* return now if not eof */ if ispt = 0 then return; /* return also if end of source file */ call popfile; /* pop up to source file */ goto SCAN.START; /* and start scan again */ end; /* check for "ddddd" (octal constants) */ if nchr = a.quote then do; /* octal constant */call get.char; /* scan off double quote */if (nchr = a.h) or (nchr = l.h) then do; /* detect "hex" */ i = 4; j = a.a + 6; /* hex: shift count, limits */ call get.char; end;else do;  i = 3; j = a.0 + 8; /* else set up octal limits */  end; info = 0; do while nchr <> a.quote; /* and wait for next quote */    if (info and "160000") <> 0 then call er.tmd;    if (nchr - l.a) ile (a.z - a.a) then nchr = nchr - (l.a - a.a); /* uppercase it */    if (nchr < a.0) or (nchr >= j) then do; /* error */      call er.ifnc;      nchr = a.quote; /* exit loop */    end;    else do; /* legal digit: */      if nchr >= a.a       then nchr = nchr - a.a + 10;      else nchr = nchr - a.0; /* get binary equivalent */      info = (shl(info, i) or nchr); /* and set those bits */      call get.char;    end; end; token = t.const; call get.char; /* skip the second quote */ return; end;/* String constants:..   When a string constant is encountered, it is stored in the array.   called 'NAME'...   The character information is written out to the object file.   at a later time.*/  if nchr = a.apost then do; /* is string constant */ call get.char; /* skip over first apostrophe */ call get.char; /* move next one to lchr*/  i = 0; /* initialize count */  point = 1; /* start words here */do while ((lchr = a.apost) and (nchr = a.apost))or ((lchr <> a.apost) and (lchr <> a.nul) and (lchr <> a.eof)); /* NULL means end of line */    if (lchr = a.apost) and (nchr = a.apost) then call get.char; /* convert double apostrophes to single */    if i >= 128 then do; call er.sctl; i = 0; point = 1; end;    if i then do; name (point) = (name (point) or shl(lchr, 8)); point = point + 1; end;    else name (point) = lchr; /* clear upper half */    i = i + 1; call get.char; /* move nchr to lchr */  end;  name (0) = i; /* number of bytes */if lchr <> a.apost then call er.map; /* missing appost */  token = t.sconst; /* token is string constant */  return; /* end of string constant */end; /* of ' */   /* check for operator */  if (n.info and b.opr) <> 0 then do; /* operator */ token = t.opr; info = (n.info and b.mask); call get.char; /* skip to next character */  if (lchr = a.slash) and (nchr = a.star) then begin; /* special check for / * denoting comment */   dcl templine.no fixed;   templine.no = line.no; /* save the line number for error messages */   call get.char; /* get next character into 'nchar' */   do while ((lchr <> a.slash) or (nchr <> a.star)) and (nchr <> a.eof); /* check for nested comm, eof */     if nchr = a.dollar then do; /* handle $ in comment field */       call get.char; /* get character after $ */       call set_flags (nchr); /* set compile-time flags based on character */     end;     if (lchr = a.star) and (nchr = a.slash) then do;       call get.char; /* scan past slash */       goto SCAN.START; /* start all over again */     end;     call eol.ck; /* get the next character and check for eol */     do while (n.info and b.comnt) = 0; /* fast loop to find /, *, eof, eol, $ */       call get.char; /* scan comment out of literal ?  */     end;   end;   line.no = templine.no; /* restore the line number where we started */   call er.ntc;   goto SCAN.START; /* treat the end of file normally */ end;  return; end;  /* check for relational operator */  if (n.info and b.relop) <> 0 then begin; dcl notflag fixed; /* flag to indicate negated relation */ if (n.info and b.not) <> 0 then do; /* check for leading not */ notflag = 1; call get.char; end; else notflag = 0; info = (b.relop or b.not); /* don't allow further nots */ do while (n.info and info) = b.relop; /* continue through relationals that we have not yet got */ info = info + (n.info and b.mask); /* accumulating condition bits */ call get.char; end; info = (info and b.rel); /* mask to relation bits */if info = (b.eq or b.lt or b.gt) then call er.ifm; token = t.opr; /* we have an operator (although it is relational) */ if notflag <> 0 then if (info and b.rel) = 0 then do; /* check for unary not */info = o.not; return; end; else info = b.rel - info; /* else simply negate relation */ info = (o.eq - b.eq) + info; /* compute operator type from relation bits */ return; end;  /* illegal character - give error */  token = -1; /* invalidate the token (it means nothing anyway) */ call er.ifm; call get.char; /* bypass illegal character */goto SCAN.START; /* and ignore it */ end scan;