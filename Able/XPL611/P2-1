/* XPL storage areas: */  /* 12-5-88 - cj - changed intermediage file offsets for humungous work files */dcl r (maxcomm)        fixed; /* set up communications area */dcl store1 (#blocks)   fixed;dcl store2 (#blocks)   fixed;dcl store3 (#blocks)   fixed;dcl store4 (#blocks)   fixed;dcl store5 (#blocks)   fixed;dcl fstk (fstklen - 1) fixed;dcl aliases (alias_len - 1) fixed; /* array formal parameter/actual parameter aliases */dcl alias_ptr               fixed; /* pointer into ALIASES */dcl token   fixed; /* next token from the file */dcl line.no fixed; /* current line number */dcl in.recursive fixed; /* zero if we're not in a recursive proc; KEY of recursive proc otherwise [used for TEMP allocation] *//* The variable CUR.LOC is used to hold the estimated current position.  within the object code area.  During pass2, worst case assumptions.  are made about the number of machine words that are used to perform.  a specific instruction.  The result of the worst case calculation.  is stored in CUR.LOC.  During pass3, as many instructions as.  possible are compressed into one machine word. */dcl cur.loc fixed;dcl swaploc fixed; /* CUR.LOC at start of a swappable procedure */  /* global file variables and buffers */  dcl sfb (sfbufl - 1) fixed; /* source file buffer */dcl (sfd, sfs, sfl)  fixed; /* device, start, and sector length of the input file */dcl sfpos fixed; /* source file buffer position */dcl sfsec fixed; /* source file current sector (next one to read */dcl sfofs fixed; /* sector offset for source file in case of wrap around buffer */  dcl ifb (ifbufl - 1) fixed; /* and intermediate file buffer */dcl (ifd, ifs, ifl)  fixed; /* device, start, and sector length of the output file */dcl ifsec fixed; /* and sector counter */dcl ifpos fixed; /* intermediate file buffer position */  dcl readl fixed; /* max length to read *//* File input/output subroutines:.  .   The following routines are used to read and write data.   from the various source, intermediate, and runtime package.   files.  These routines facilitate the reading of files on.   a byte-by-byte basis and using our own controlled buffer sizes...   The following comment is left over from DTSS:..  "Our first task (here is our first line of code) is to expand our.   core allocation to a full 16K.  This is required:  a. for system.   efficiency, and b. because pass2 of the compiler is larger.   than pass1 and the DTSS overlay MME requires that the core.   be allocated by the first pass..  .  "After allocating a full 16K of memory, we will screw with the DXPL.   runtime package to:  a. convince it that we have 16K of memory, and.   b. find out where in memory the original registers are stored so.   that we may find out what the registers contained when the program.   was started.".  .   The routine GC is called to scan the next token from our input file..   Remember that our input file is the output file generated by pass1..   This file is a sequence of machine words (36-bits on Honeywell.   systems, 16-bits on Nova systems)..  .   The routine GC, in this pass, merely reads the next word from the.   word-by-word format input file..  .   Since all insert file processing was done during pass1, pass2 does.   not do any insert processing. */  gc: proc; /* procedure to get next word */   dcl (ms, ls) fixed;   if sfpos = sfbufl then begin; /* add - get buffer */      sfsec = sfsec + shr(sfbufl, 8); /* incr length */      if sfsec ige sfl then sfsec = sfl; /* in case of compiler error */      ls = sfsec + sfofs; /* sector of work file we wish to read */      if ls ige core(loc.wsln) then ls = ls - core(loc.wsln); /* modulo core(LOC.WSLN) - number of sectors in work file */      ms = sfd; ls = sfs + ls; /* get starting sector */      if ls ilt sfs then ms = ms + 1; /* carry */      readl = sfl - sfsec; if readl ige shr(sfbufl, 8) then readl = shr(sfbufl, 8);      call readdata (ms, ls, sfb, shl(readl, 8));      sfpos = 0; /* zero pointer */   end;   sfpos = sfpos + 1; /* incr it */   return (sfb (sfpos - 1)); /* and return word */end gc;  peek: proc; /* check next word without incrementing */  dcl word fixed;  word = gc; /* get next word */  sfpos = sfpos - 1; /* decrement counter */  return word;end peek;  /* Intermediate and object file:.  .   The routines 'EMIT' and 'WRITEOBJ' are used to write data to the.   intermediate file and the object file, respectively.. .   Both the intermediate file and the object file are (except for one case).   written sequentially.  Therefore, each routine is passed the word.   which should be appended to the appropriate file.. .   The specified data word is passed as a fixed point argument to both .   routines. (only EMIT exists in PASS2) */  ifforce: proc;   dcl (ms_if, ls_if, ms_sf, ls_sf, ms_wf, ls_wf) fixed;     ms_if = (ifd and "377"); /* get first sector not written to by WRITEDATA call below */   ls_if = ifs + (ifsec + shr(ifpos, 8) + ((ifpos and "377") <> 0));   if ls_if ilt ifs then ms_if = ms_if + 1; /* carry */   ms_sf = (sfd and "377"); /* get next sector to read */   ls_sf = sfs + (sfsec + shr(sfbufl, 8) + sfofs);   if ls_sf ilt sfs then ms_sf = ms_sf + 1; /* carry */   ms_wf = (core(loc.wsec + 1) and "377"); /* get first sector after .WORK file */   ls_wf = core(loc.wsec) + core(loc.wsln);   if ls_wf ilt core(loc.wsec) then ms_wf = ms_wf + 1; /* carry */   if ((ms_if igt ms_sf) /* if intermediate file is about to collide with source file */   or ((ms_if = ms_sf) and (ls_if igt ls_sf))   or  (ms_if igt ms_wf) /* or next sector in IF is past the end of .WORK */   or ((ms_if = ms_wf) and (ls_if igt ls_wf)))   then do; /* intermediate file too big */      print;      print 'Program too large (pass 2 intermediate file).';      call exit(-1);   end;   ms_if = ifd; ls_if = ifs + ifsec; /* get sector to write */   if ls_if ilt ifs then ms_if = ms_if + 1; /* carry */   call writedata (ms_if, ls_if, ifb, ifpos); /* write IFPOS words */   ifsec = ifsec + shr(ifbufl, 8); /* increment ptr */   ifpos = 0; /* and pos = 0 */end ifforce;  emit: proc(word); /* emit word to file */   dcl word fixed;   if ifpos = ifbufl then call ifforce; /* force it out */   ifb (ifpos) = word; /* store in buffer */   ifpos = ifpos + 1;end emit;/* Pass two initialization: */init: proc fixed; /* pass2 initialization (return IF starting offset in .WORK) */   dcl i fixed;   sfd = core(loc.wsec + 1); sfs = core(loc.wsec); sfl = core(loc.usr1); /* stats for first interfile */   ifd = sfd; ifl = core(loc.wsln); /* get # of sectors in work file */   sfofs = 32; /* for long file,  source file starts in here */   if ifl ige 128  then sfofs = 64; /* starts here if large word file */   if ifl ige 256  then sfofs = 128; /* use two 16K segments for huge work file */   /* use 256 sector offset for 4096 sector work files.  increase linearly */   /* to 512 sector offset for 8192 files,  etc.   make multiple of 32.    */   if ifl ige 4096 then sfofs = shr(ifl,9)*32;   ifs = shr(sfofs, 1); /* normally start 1/2 way to start of IF (IFS is relavtive start here) */   if sfl + sfofs igt ifl then do; /* see if we wrapped around in pass1 */     if (sfl + sfofs - ifl) igt ifs  /* if we wrapped into our part */     then ifs = (sfl + sfofs - ifl); /* move base up to here */   end;   ifl = ifl - ifs; /* this is amount left for our intermediate file */   ifs = sfs + ifs; /* compute absolute starting sector */   if ifs ilt sfs then ifd = ifd + 1; /* carry */        readl = sfl; if readl igt shr(sfbufl, 8) then readl = shr(sfbufl, 8); /* do not read past end */   i = 0; if sfs + sfofs ilt sfs then i = 1; /* determine MS sector offset */   call readdata (sfd + i, sfs + sfofs, sfb, shl(readl, 8)); /* fill buffer from starting sector */   do i = 0 to maxcomm; /* read in comm file data */      r (i) = gc;   end;   do i = maxcomm + 1 to 255; /* skip the rest of the sector */      call gc;   end;   do i = 0 to 255; /* save a sector for the interpass comm area at front of interfile */      call emit (0);   end;   #sk = stacksize; /* for pass3 stat printout */   #bl = #blocks; /* for pass3 stat printout */   #if2 = ifl; /* for pass3 stat printout */end init;