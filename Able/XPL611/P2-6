/* Expression compiler - generate conditional transfers from logical expression:.  .   Routine XCOMPUTE:.  .   XCOMPUTE is a routine that is similar in function to the 'COMPUTE' routine..   XCOMPUTE is passed an expression tree node (in the global variable SUBTREE)..   XCOMPUTE is also passed two key numbers:  one in TRUEL, and the other.   in FALSEL.  XCOMPUTE is also passed a flag (TRUFIRST)..  .   XCOMPUTE looks through the expression tree passed in SUBTREE and .   generates object code that jumps to TRUEL or FALSEL depending on .   the true/false condition of the tree expression.  It is used to .   process IF/THEN and DO/WHILE expressions..  .   At each conditional test point (as in 'if a = b') a jump instruction is.   emitted (conditional jump instruction).  If TRUFIRST is set to true (one),.   then the object code will jump to location TRUEL if the condition is .   true, else the object code will fall through.  If TRUFIRST is false.   (zero), then the object code will jump to location FALSEL if the.   condition is false, else object code will fall through..  .   The purpose of the TRUFIRST bullshit is to avoid object code such as:.     tze .+2  (a = b true condition).     tra fail (false)..  .   The proper object code would be a:.     tnz fail..   The variable XCREGL is used to keep track of which registers.   were loaded by XCOMPUTE before the first jump instruction.   was emitted.  This is advantageous, since we know that those.   registers were correctly loaded and are valid.. .   Note:  Set XCFIRSTJ to zero before calling XCOMPUTE. */dcl (truel, falsel, trufirst)  fixed;dcl (xcfirstj, xcregl, xcregu) fixed;xcomset: proc; /* call this proc to set up for XCOMPUTE call */  truel = 0; falsel = 0; trufirst = 0; xcregl = 0; xcregu = 0; xcfirstj = 0;end xcomset;xcompv: proc; /* set to push special saved REGU, REGL */  call push (xcregl); /* we must do this after XCOMPUTE has release stack */  call push (xcregu);end xcompv;xcomchk: proc; /* call to check XCFIRSTJ on each jump instr */  if xcfirstj = 0 then do;    xcfirstj = 1; xcregl = regl; xcregu = regu; regl = 0; regu = 0;    call sreg; /* save regs as of first jump */  end;end xcomchk;/* LLLDONEWITH routine:..   XCOMPUTE is passed a key to jump to on true and a key to jump to on.   a false condition (FALSEL).  Obviously, when a location is jumped to,.   certain registers must be cleared at the jump to address.  However,.   since many times the location will not be jumped to (for example the.   expression 'if a = b' emits just one 'tnz fail' instruction, so TRUEL.   never gets jumped to)  it would be poor policy to zero out the register.   optimization stack at a location that was never jumped to...   We must generate a mechanism that keeps track of which key numbers have.   been jumped to and which have not been jumped to..    .   Therefore, it is legal to call XCOMPUTE with a TRUEL or FALSEL of zero..   In this case, TRUEL will be allocated (and set equal to the allocated key).   when and if a jump instruction is actually emitted..  .   If, after calling XCOMPUTE with TRUEL or FALSEL = 0, the calling routine.   finds that (TRUEL or FALSEL) is no longer zero, an ET.ALD type record.   record must be emitted to the object file to actually locate the key..  .   DONEWITH routine:.     The DONEWITH routine is passed TRUEL or FALSEL.  If the passed .     variable is zero, then DONEWITH returns.  If it is nonzero, .     then DONEWITH emits an ET.ALD record and then clears the.     REGC array locations specified by REGL.*/  donewith: proc(akey); /* done with TRUEL or FALSEL */  dcl akey fixed;  if akey = 0 then return; /* never emitted any jumps to it */  call em.ald (akey); /* label definition time */  call regclr (regl); /* and zap any regs loaded up to now in expression */  call accpurg; /* clean out accumulators */  zflags = 0; /* ZFLAGS are trash after label definition */end donewith;  /* LLLExpression compiler - XCOMPUTE: */  xcompute: proc;  dcl tree fixed;dcl (opr, fva, reg1, reg2, arg1, arg2) fixed;dcl (node, info) fixed;dcl fltflag fixed; /* special flag */call push (tree); tree = subtree;node = x.node (tree); info = x.info (tree);  swap: proc; /* used to swap relation */   dcl tem fixed;   tem = x.arg1 (tree); x.arg1 (tree) = x.arg2 (tree); x.arg2 (tree) = tem;   arg1 = x.arg1 (tree); arg2 = x.arg2 (tree);   reg1 = ifreg (arg1); /* see if in a register */   reg2 = ifreg (arg2);end swap;    if (node = x.dyad) and (info = o.and) then begin; /* and */    call push (trufirst); call push (truel);    truel = 0;    trufirst = 0; subtree = x.arg1 (tree); call xcompute; /* recurse */    call donewith (truel);    truel = pop; trufirst = pop;    subtree = x.arg2 (tree); call xcompute;    call x.rel (x.arg1 (tree)); call x.rel (x.arg2 (tree));  end;  else if (node = x.dyad) and (info = o.or) then begin; /* or */    call push (trufirst); call push (falsel);    falsel = 0;    trufirst = 1;    subtree = x.arg1 (tree); call xcompute;    call donewith (falsel);    falsel = pop; trufirst = pop;    subtree = x.arg2 (tree); call xcompute;    call x.rel (x.arg1 (tree)); call x.rel (x.arg2 (tree));  end; /* of or */  /* LLLExpression compiler - routine XCOMPUTE (cont):.  .   If the node is a relational operator (=, <, etc.) then we.   will emit a comparison instruction (subtract) followed by.   a conditional jump..  .   In this case, the answer to the comparison is never 'calculated', .   but the transfer of control is given directly below. */    else if (node = x.dyad) and (info >= o.eq) then begin; /* aha : relop */    reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any register */    mvt = 0;    subtree = x.arg1 (tree); reg1 = compute; /* compute ARG1 */    mvt = 0; reg.pref = (reg.pref and (not reg1)); /* now for second argument */    subtree = x.arg2 (tree); call compute; /* compute second operand */    opr = x.info (tree); /* get type of relational operator */    arg1 = x.arg1 (tree); arg2 = x.arg2 (tree);    fva = match (arg1, arg2); /* set to same type */    reg1 = ifreg (arg1); reg2 = ifreg (arg2); /* get in register */    if (opr = o.eq) or (opr = o.ne) then begin; /* eq, ne - can use either one */      if fva then begin; /* check floaters */        if (reg1 = b.ac1) or (reg2 = b.ac0) then call swap; /* put in optimized registers */      end;      else begin; /* fixed - just check ARG1 */        if x.node (arg2) = x.reg then call swap; /* use existing register */      end;    end; /* of these two */    else if (opr = o.gt) or (opr = o.le) or (opr = o.igt) or (opr = o.ile) then call swap;      if fva then begin; /* floating */        if opr > o.ne then do;            opr = opr - 5;            x.info (tree) = opr;         end; /* no int ops if floating */        if reg2 = b.ac0 then reg2 = fin.reg (arg2, not b.ac1); /* move to AC1 if should */        reg1 = fin.reg (arg1, not b.ac0); /* get in register */        fltflag = 0; /* assume we can not skip the subtract */        if x.node (arg2) = x.const then begin; /* see if floating pont cont*/          if fstk (x.info (arg2)) = 0 then fltflag = 1; /* then we can */        end;        if fltflag then begin;     /* then we can */          call emitc (0, b.ad + b.add); /* set status flags for floating */          fstk (x.info (arg2)) = "100000"; /* and clear the slot */        end;        else begin; /* nonzero - subtract it */          reg2 = fin.reg (arg2, not b.ac1); /* get second in register */          call em.rtp (l.fps); /* and subtract */        end;        reg.free = (b.ac1 or b.ac2 or b.ac3); /* these are free, free up AC0 below */      end;      else begin; /* fixed */        if (x.node (arg2) = x.const) and (x.info (arg2) = 0) then begin; /* detect a zero */          reg1 = in.reg (arg1, 0); /* get arg in register */          if ((zflags <> reg1) or (opr >= o.ilt)) then call emitc (0, b.td + b.tsu + bitreg (reg1)); /* set flags (inc. carry) */        end;        else begin; /* not comparing with zero */          reg1 = in.reg (arg1, reg2); /* get ARG1 in register */          call sendit (arg2, b.td + b.tsu + bitreg (reg1), reg1); /* preserve register counts */        end;      end; /* of fixed */  /* LLLExpression compiler - XCOMPUTE (cont):.  .   In the above routine, we calculated each of the relational operands..   The subtraction (comparison) has been performed..  .   Now emit the proper conditional jump instruction, based upon.   which relationship was specified and which type we want. */  dcl tt data (b.tze, b.tmi, b.tpl, b.tmi, b.tpl, b.tnz, b.tnc, b.trc, b.tnc, b.trc); /* true transfers */dcl ft data (b.tnz, b.tpl, b.tmi, b.tpl, b.tmi, b.tze, b.trc, b.tnc, b.trc, b.tnc); /* false transfers */      if trufirst then begin; /* emit jump on true condition */      if truel = 0 then truel = galt;      call em.atr (tt (opr - o.eq), truel);    end;    else begin; /* emit jump on false condition */      if falsel = 0 then falsel = galt;      call em.atr (ft (opr - o.eq), falsel); /* jump */    end;call xcomchk; /* save REGU and REGL here if first jump */      reg.free = (reg.free or reg1);    call x.rel (arg1); call x.rel (arg2);  end; /* of relops */  else if (node = x.monad) and (info = o.not) then begin; /* just negate transfer conditions */  subtree = truel; truel = falsel; falsel = subtree; /* swap locations */  trufirst = ((not trufirst) and 1); subtree = x.arg1 (tree); /* now compute subtree */  call xcompute;  subtree = truel; truel = falsel; falsel = subtree; /* swap true, false conditions */  trufirst = ((not trufirst) and 1); /* and reverse flag */  call x.rel (x.arg1 (tree)); /* done */end; /* of not */    else if node = x.const then begin; /* check for constant */    call fix (tree); /* fix it */    if trufirst then begin; /* emit jump to true */      if x.info (tree) then begin; /* true */        if truel = 0 then truel = galt;call xcomchk;        call em.atr (0, truel); /* jump */      end;    end;    else begin; /* false */      if not x.info (tree) then begin; /* jump to false */        if falsel = 0 then falsel = galt; /* get one */        call em.atr (0, falsel);call xcomchk;      end;    end;  end; /* of constant */  /* LLLExpression compiler - XCOMPUTE (cont):.  .   If the relationship is just a variable or an expression, .   then we will compute it and check the result for bit 0..  .   Example:.     if x + y then call zqr.  .   Give up - call COMPUTE and check for odd/even: */  else begin; /* must be variable, or something that requires computation */  subtree = tree; /* pass tree to compute */  reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3);  mvt = 0; /* is fixed */  call compute; /* compute item */  call fix (tree); /* and make sure fixed point */  reg1 = in.reg (tree, 0); /* get in any register */  call emitc (1, b.td + b.tan + bitreg (reg1)); /* preserve regs, set flags */  if trufirst then begin; /* emit true on tnz */    if truel = 0 then truel = galt;    call em.atr (b.tnz, truel);  end;  else begin; /* jump to false */    if falsel = 0 then falsel = galt; /* get one if we are first to jump */    call em.atr (b.tze, falsel); /* jump to false */  end;call xcomchk;  reg.free = (reg.free or reg1); /* free */end; /* of everything else */subtree = tree; /* restore subtree */tree = pop;end xcompute; /* and end here */