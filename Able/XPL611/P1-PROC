/* Statement scanner - PROCEDURE definition:. .  The following code compiles a procedure definition..  .  A jump instruction is emitted that will transfer control.  around a procedure body..  .  The compiler, however, will optimize the jumps around successive.  procedure definitions and emit only one jump at the start.  around many procedure definitions if there is no intermixed.  object code.  This is done by pass3..  .  We proceed by:.    1. Emitting jump..    2. Defining the procedure name in the symbol table..    3. Entering the procedure argument symbols in the symbol table..    4. Scanning the procedure body..    5. Emitting a return instruction if the user did not terminate his.       procedure with a 'RETURN'.*/  begin;dcl (arg.pt, numarg, ppoint) fixed;dcl temp      fixed;dcl prevdef   fixed; /* previous defined flag (TRUE if this was defined with a FORWARD reference) */dcl start.ram fixed; /* procedure's starting ram location */dcl ret.typ   fixed; /* returned variable type  */dcl lin.att   fixed; /* linker attribute        */dcl plab      fixed; /* pointer to symbol block for procedure */dcl p.ptptr   fixed; /* previous ptptr in case of previous definition of proc */dcl p.lnum    fixed; /* line number of procedure statement */dcl attribute fixed; /* this procedure's attributes */dcl prev.proc fixed; /* pointer to containing procedure's record */lab = s.define (sname, shash); /* define proc */plab = lab; /* save for linker call */p.lnum = line.no; /* save line number for error messsages */  /* Fix up the symbol table to indicate that the procedure name is.  a procedure and then scan off the arguments, putting them.  in the symbol table also...  A consecutive block of 5 keys are allocated for each procedure.  definition.  These keys are used to identify:.    1. the location of the start of the proc (entry).    2. the location to jump to (around the procedure).    3. the location to jump to in order to return from the procedure.    4. a bit word to indicate which registers are used by proc body.    5. length of stack frame for this proc*/start.ram = ram; /* save starting ram location */p.ptptr = ptptr; /* keep PTPTR in case of previous proc def */prevdef = 0; /* not previously defined */attribute = 0; /* no attributes either */if gtok (lab) <> t.und then do; /* should have been previously defined */if gtok (lab) <> t.proc then do; /* but it wasn't */call er.lt (lab); /* a label used to mark a procedure */ppoint = ptptr; /* storage is safe if pointed to here */end; /* not a proc */else do; /* was defined previously */ppoint = stable (lab + s.locn); /* point to procedure stack */ptptr = ppoint + p.parm; /* point to argument list area */prevdef = 1; /* assume normal forward ref */end;end; /* of should have been previously defined */else do; /* if undefined, then look for args */if ptptr + p.parm ilt stptr then call er.nst;ppoint = ptptr; /* table pointer */ptptr = ptptr + p.parm; /* and use up this storage */call ptok (lab, t.proc); /* save new proc type */call set_stable (lab + s.locn, ppoint); /* and save proc info pointer */end;call push (cur.proc.def); /* push this */prev.proc = cur.proc.def; /* save this in case we need it */cur.proc.def = ppoint; /* pointer into stack for current definition */call s.block; /* start of block here */call push (cur.proc.dpt); /* push this */cur.proc.dpt = s.depth; /* remember depth here *//* Statement scanner - PROCEDURE definition (cont):.     Scan arguments: */numarg = 0; /* zero count of arguments */ if token = t.lpar then do; /* scan off arguments, if any */   token = t.comma; /* pretend we got a comma */   do while (token = t.comma);      if ptptr - 2 ilt stptr then call er.nst;      dcl.symbol = 1; /* we're scanning off variable names at a new scope level */      call scan; /* scan over comma or open paren */      numarg = numarg + 1; /* count arguments */      if name.pt = 0 then call er.ifm;      lab = s.define (name.pt, hashcode); /* define symbol */      if gtok (lab) <> t.und then call er.lt (name.pt); /* should be undefined here */      call ptok (lab, t.unda); /* indicate undefined arg */      call set_stable (lab + s.locn, ptptr); /* set up info to point to proc def area entry */      call scan; /* scan over symbol */      if not prevdef then do; /* allocate ram for argument */         call set_stable (ptptr + p.ptyp, t.unda); /* no type known */         call set_stable (ptptr + p.ploc, ram); /* allocate ram */         ram = ram + 1; /* allocate one word/argument in consecutive order (pass3 linker depends on this!) */         ptptr = ptptr - 2; /* account for used symbol table space */      end;      else do; /* not so new (forward reference); type info known */         if numarg <= stable (ppoint + p.args)         then ptptr = ptptr - 2; /* not too many */         else call er.tma; /* too few is checked below */      end; /* not so new */   end;   if token <> t.rpar then call er.ifm;   call scan; /* scan over close paren */end;dcl.symbol = 0; /* done scanning off variable names *//* save number of arguments */if not prevdef then call set_stable (ppoint + p.args, numarg); /* save number of args */else do; /* previous definition; must match */ptptr = p.ptptr; /* restore procedure pointer */if numarg < stable (ppoint + p.args) then call er.nea; /* not same # of args */end;/* Statement scanner - PROCEDURE definition (cont):.     Syntax scan:  Scan off procedure attributes.  For example:.       a: proc fixed;                       : fixed.       a: proc recursive;                   : recursive.       a: proc recursive swap;              : recursive, swappable.       a: proc floating public recursive;   : floating, public, recursive.       a: proc returns (floating);          : floating..     There are two returns attributes:  FIXED and FLOATING (T.VAR, T.FVAR),.     one linker attribute:  PUBLIC (T.PUBLIC), one local storage attribute:.     RECURSIVE (T.RECURS), and one residence attribute (in main memory or.     in external memory):  SWAP (T.SWAP).  If a procedure is recursive,.     its RAM (variables) is allocated on the stack, rather than in static.     canonical locations.*/ret.typ = t.var; /* default return type */if token = t.rtns then do; /* has PL/I RETURNS () keyword */call scan; /* scan off left paren */if token <> t.lpar then call er.ifm;call scan; /* scan off type field */if token <> t.type then call er.iptd;else ret.typ = info; /* set type */call scan; /* scan off right paren */if token <> t.rpar then call er.ifm;call scan; /* get next token */end; /* RETURNS () keyword */else do; /* not RETURNS () keyword */if token = t.type then do; /* old style return type */ret.typ = info; /* save type for semantic check */call scan; /* get next identifier */end; /* old style */end; /* not RETURNS () keyword *//* semantics scan - check for illegal combinations */if (ret.typ <> t.var) and (ret.typ <> t.fvar) then do; /* returns type can only be fixed or floating */call er.iptd; /* illegal return type */ret.typ = t.var; /* but set some reasonable type */end;/* now gather linker attributes */lin.att = 0; /* default linker attribute: none */if token = t.storage then do; /* some storage class */   if info = t.public then do; /* linker attribute */      lin.att = info; /* save info for semantic check */      call scan; /* and scan to next */   end; /* linker attribute */   else call er.iptd; /* bad format */end; /* some type */else if public_procs then do; /* if outer procs should be forced PUBLIC */   if s.depth - in.begin = 2 + mod.scanned /* are we at outer level (ignoring BEGINs)? */   then lin.att = t.public; /* force public */end; /* of forcing outer procs to be PUBLIC */call push (stack_length); /* save present stack length */stack_length = 0; /* no stack space allocated for this procedure yet */if ((token = t.recurs) or ((gflag (prev.proc) and p.recursive) <> 0)) then do; /* recursive? */   if recurs.parms = 0 then do; /* set up canonical storage for passing parameters to recursive procs */      if mod.scanned then do; /* in a module */         recurs.parms = get_extloc; /* make it external */         do temp = 1 to max_recurs_parms - 1; /* get a whole block of them */            call get_extloc;         end;      end; /* of in module */      else do; /* in MAIN program, allocate out of the variable area */         recurs.parms = start.ram; /* set the starting location */         start.ram = start.ram + max_recurs_parms; /* allocate the ram */      end; /* of in MAIN */   end; /* of set up canonical storage */   ram = start.ram; /* UNdefine any storage allocated for parameters */   attribute = (attribute or p.recursive); /* it's recursive */   if (prevdef and ((gflag (ppoint) and p.recursive) = 0)) then call er.ram; /* previously declared, but not as recursive */   if numarg > max_recurs_parms then call er.tma; /* too many arguments */   arg.pt = ppoint + p.parm; /* start here */   do stack_length = 0 to numarg - 1; /* update the parameter locations (and initialize STACK_LENGTH) */      call set_stable (arg.pt + p.ploc, stack_length + 1); /* update the argument location (on stack) */      arg.pt = arg.pt - 2; /* point to next arg */   end; /* of update parameter locations */   if token = t.recurs then call scan; /* scan to next symbol */end; /* of recursive? */else if (prevdef and ((gflag (ppoint) and p.recursive) <> 0)) /* if previously declared to be recursive */then call er.ram; /* recursive attribute mismatch */if token = t.swap then do; /* swappable procedure (indeed, this type ONLY swaps) */   attribute = (attribute or p.swap or p.swapscon); /* remember this is a swappable proc */   call scan; /* scan to next token */end;if token = t.swpcode then do; /* for nonswapping scon's and data arrays */   attribute = (attribute or p.swap); /* swap, but don't swap the scon's or data arrays */   call scan; /* get next token */end;if token <> t.semi then call er.ifm; /* make sure it ends with a semicolon */if ((lin.att = t.public) or ((attribute and p.swap) <> 0)) then do; /* check that it's not an internal proc */   if mod.scanned then do; /* if we're in a module */      if s.depth - in.begin <> 3 /* are we at MODULE's outer level (ignoring BEGINs)? */      then call er.pbna; /* public procedure not at outer level */   end;   else do;      if s.depth - in.begin <> 2 /* are we at outer level (ignoring BEGINs)? */      then call er.pbna; /* no, error */   end;end;/* make sure returns type matches if previously defined */if prevdef then do; /* was previously defined */   call set_stable (ppoint + p.rtyp, stable (ppoint + p.rtyp) and "377"); /* remove any flags (erase previous assumptions) */   arg.pt = ppoint + p.parm; /* start here */   do while (arg.pt > ppoint + p.parm - numarg - numarg); /* and process each arg */      call set_stable (arg.pt + p.ptyp, stable (arg.pt + p.ptyp) and "377"); /* remove flags from parameters */      arg.pt = arg.pt - 2;   end;   if stable (ppoint + p.rtyp) <> ret.typ then call er.iptd; /* wrong type */   if stable (ppoint + p.key) then call er.lt (plab); /* multiple declarations */end; /* was previously defined */else call set_stable (ppoint + p.rtyp, ret.typ); /* not defined - set type */call pflag (ppoint, attribute); /* define proc flags HERE (and not before!) */if not prevdef then do; /* forward references already defined all this */   lab = gkey; /* select key used for jump to procedure */   nexkey = nexkey + proc_keys; /* save enough keys for proc */   call set_stable (ppoint + p.key, shl(lab, 1)); /* save key w/o defined bit */end;call emit (start.ram); /* keep track of variables used by this procedure (emit starting ram location) */call emit (shr(stable (ppoint + p.key), 1)); /* emit key for future label defs */call emit (gflag (ppoint)); /* emit procedure attributes *//* Statement scanner - PROCEDURE definition (cont):.     The arguments have been scanned and the return type set..     Set at this point are:.       P.KEY  = key of entry*2 + defined bit.       P.ARGS = number of arguments.       P.RTYP = proc flags/return variable type.       P.PARM = arg flags/(T.UNDA or type), location..     Prepare to define procedure - save everything, output code to save.     parameters passed in registers, etc.  */call push (cur.ret); /* and current return key */cur.ret = shr(stable (ppoint + p.key), 1) + 2; /* current return key */call push (ppoint);if (gflag (ppoint) and p.recursive) = 0 then do; /* if we're not defining a recursive proc */   if numarg > 4 then numarg = 4; /* restrict number of arguments assigned to regs */end;call emit (numarg); /* emit number of arguments being passed in regs */arg.pt = ppoint + p.parm; /* pointer to first arg */temp = numarg; /* move number of args */if temp > 4 then temp = 4; /* unconditionally restrict to 4 */numarg = numarg - temp; /* get remaining args to be emitted later */do while (temp > 0); /* emit store for up to first 4 args */   call emit (stable (arg.pt + p.ploc)); /* and emit variable location for it */   arg.pt = arg.pt - 2; /* move ptr */   temp = temp - 1; /* decrement count of arguments left to do */end;if (gflag (ppoint) and p.recursive) <> 0 then do; /* is this a recursive proc? */   temp = recurs.parms + 4; /* point to next canonical parameter location */   do while (numarg > 0); /* emit stack stores for remaining parameters */      call emit (temp); /* emit canonical location */      temp = temp + 1; /* point to next canonical location */      numarg = numarg - 1; /* decrement number of arguments left to do */   end; /* of emit stores for remaining parameters */end; /* of if this is a recursive procedure */ /* Now scan the statement list that comprises the procedure body.  and emit the code that will eventually become the procedure..  After that, clean up and return. */ s.sl.stak (s.depth - 1) = ptptr; /* kludge to preserve def info at top */call push (data_key); /* save next data key */data_key = 0; /* start data keys all over */call push (lin.att ); /* save linker attributes */call push (plab    ); /* save pointer to symbol name for proc */call push (p.lnum  ); /* save line number for error messages */call stmt.list (1); /* don't let STMT.LIST scan off last semicolon */p.lnum = pop; plab = pop; lin.att = pop;data_key = pop;ppoint = pop; /* et cetera */call emit (stable (ppoint + p.dswp)); /* emit NOSWAP bitmap for data statements */call emit (ram); /* detect how much ram area used by uncalled proc */call emit (stack_length); /* emit stack frame length */numarg = stable (ppoint + p.args); /* get back # of arguments */call set_stable (ppoint + p.key, stable (ppoint + p.key) or 1); /* define the symbol */ /* check that all arguments were properly defined */ arg.pt = ppoint + p.parm; /* point to parameter list inside symbol table */do while (arg.pt > ppoint + p.parm - numarg - numarg); /* and process each arg */   if (stable (arg.pt + p.ptyp) and "377") = t.unda then do;      call er.naad;      call set_stable (arg.pt + p.ptyp, t.var); /* pretend fixed for calling */   end;   arg.pt = arg.pt - 2;end;if lin.att = t.public /* emit linker information after arguments are defined */then call pub.ext.def (plab, lin.att, proc_keys + 1, p.lnum); /* define it for linker */ call s.endblock; /* globalize */call scan; /* scan HERE so we get any name at the correct level of localization */cur.ret = pop; /* restore this */stack_length = pop; /* restore stack length */cur.proc.dpt = pop; /* and restore this for nesting */cur.proc.def = pop; /* and restore this for nesting */ /* check for closing proper procedure */ if token <> t.semi then do; /* name may be omitted */   if ((token <> t.proc) or (info <> ppoint)) /* procedure name we're looking for? */   then call er.nm; /* no, error! */   else call scan; /* but if they are there, they must be right */end; /* of name may be omitted */end; /* procedure statement */