/* $$Routine E.RTP:..   E.RTP is called to bind a stock run time package routine into the.   output object file.   Available object routines are stored in the.   run time package file.   The first N words of the file form a transfer.   vector that is used to find the object code start location for each.   routine.  Each routine is identified by its transfer vector location...   The object code for the routine that is stored in the run time package.   file is slightly formatted - information as to the length of the rtp.   routine, plus any pointers to any other routines that are to be included, .   are in the run time package routine object area...   E.RTP is called with a transfer vector location.  The object code for.   the specified routine is bound out to the object file (WIF) and then.   any other rtp routines that are called as subroutines by this one.   are also written out.*/e.rtp: proc(l.rtp); /* bind a rtp routine into the intermediate file */   dcl l.rtp fixed;   /* procedure to bind a routine pointed to by global variable 'L.RTP' */   e.rtpsub: proc; /* recursive procedure for emitting object pointers */      dcl loca (50)        fixed; /* location to patch */      dcl rout (50)        fixed; /* and which routine to patch it to */      dcl (top, bot, rloc) fixed; /* top and bottom pointer to loca and rout */      dcl (i, j, k)        fixed;      dcl plp              fixed; /* patch list pointer */      if r (l.rtp) <> 0 then return; /* routine is in there */      rloc = rfbuf (l.rtp); /* get pointer to routine */      plp = rfbuf (rloc);   /* get pointer to patch list */      i = rfbuf (plp);      /* pick up word from patch list */      bot = top;            /* and save pointer to where our group started */      do while i <> 0;      /* and copy patch list onto stack */         loca (top) = i;    /* save location to patch */         rout (top) = rfbuf (plp + 1); /* and get l.rtp pointer for routine to call */         top = top + 1; plp = plp + 2; /* increment stack pointer and plist pointer */         i = rfbuf (plp); /* and check for more of patch list */      end; /* of copy of patch list */      /*      .   We have scanned the patch-up list for this routine from the      .   run time package file.   We will now proceed to emit      .   all routines called by this one, so that pointers to other      .   subroutines can be updated during the emission      .   of the l.rtp routine.      */      /* now sort list, so we can dump out */      i = 1;      do while i; /* do until scan produced no errors */         i = 0; /* reset here */         do j = bot to top - 2; /* and search list */            if loca (j) > loca (j + 1) then do; /* if out of order, then bubble */               k = loca (j); loca (j) = loca (j + 1); loca (j + 1) = k;               k = rout (j); rout (j) = rout (j + 1); rout (j + 1) = k;               i = 1; /* and set flag to continue sorting */            end;         end;      end; /* of sort of list */      /* $$Routine E.RTP (cont):      .      .   We have examined the runtime package patch list, and have emitted      .   all routines that are called by the routine in equations.      .      .   Now emit the final routine, patching up all pointers to the      .   subroutines that are called from the main one.      */      i = bot;      do while i < top; /* and do until end */         if r (rout (i)) = 0 then do; /* must emit routine if not emitted yet */            call push (bot); call push (top); call push (i);            call push (rloc); call push (l.rtp); /* save info */            l.rtp = rout (i); /* routine to emit */            call e.rtpsub; /* and recursivedly call ourselves to emit routine */            l.rtp = pop; rloc = pop;            i = pop; top = pop; bot = pop; /* restore important variables from recursion */         end; /* of must emit routine */         i = i + 1; /* check next one */      end; /* of emit loop */      /* now emit our specified routine,  patching up locations */      r (l.rtp) = objlng; /* location of routine */      plp = rfbuf (rloc); /* restore pointer to patch list */      j = bot; /* and get pointer to bottom for comparison */      do i = rloc + 1 to plp - 1; /* and emit entire routine, patching up locations */         k = rfbuf (i); /* and get rtp word now */         if j <> top then do; /* if not at top yet,  then see if this is a patch up location */            if i = loca (j) then begin; /* is patch up - get pointer and increment */               k = r (rout (j)); /* get our own pointer to where routine is */               j = j + 1; /* and move on to next patch location */            end;         end;                  /* patch model C interrupt routine if needed */         if  (l.rtp  = l.in1)   /* if emitting interrupt routine */         and (prctyp = 2    )   /* for modelc                    */         and (r(l.swap) <> 0)   /* and swapping code included    */         then do;               /* then patch save of mam/mal    */            if (i = (rfbuf(l.in2)))            then k = (shl(b.md \ b.ibt \ "12",8)) \ "61";  /* d61 to MR12D */            if (i = (rfbuf(l.in2)+1))            then k = (shl(b.md \ b.ibt \ "12",8)) \ "60";  /* d60 to MR12D */            if (i = (rfbuf(l.in3)))            then k = (shl("60",8)) \ (b.md \ b.ibt \ "12"); /* MR12I to d60 */            if (i = (rfbuf(l.in3)+1))            then k = (shl("61",8)) \ (b.md \ b.ibt \ "12"); /* MR12I to d61 */         end;         call writeobj (k); /* and write out word from file or routine location if patch */         rtpcode = rtpcode + 1; /* count amount of rtp */      end; /* of copy loop */      top = bot; /* reset top to bottom for next call to emit, so we use same space */   end e.rtpsub; /* end of our internal procedure */   call e.rtpsub; /* call the subrotine */end e.rtp;/* $$Bind in rtp routines, when table, and assign special ram locations:.     We have completed the iterative optimization phase of pass3 of.     the compiler.   We will now bind in the necessary run time package.     routines, compute the locations of where things will go in.     memory, and prepare for the final object code generation.*/dcl (whentab, device_table, rcvdp, inv, sbrwp, seekp) fixed; /* special ram areas */bindrtp: proc; /* bind in the rtp (uses KEYLOC) */   dcl devptr fixed; /* device driver pointer */   dcl i      fixed;   r (l.str.data) = adjscon (r (l.str.data)); /* set actual length of scon/data (should equal OBJLNG - INTROLEN!!!) */   do i = 0 to rtp.ptrs - 1;      if rtpsubs (i) <> 0 then call e.rtp (i); /* if called, put it there */   end;   if (r (l.flags) and enable.flag) <> 0 /* if 'enable' statement - bind in */   then call e.rtp (l.in1); /* bind in interrupt routine */   devptr = 0; /* look for any device drivers */   do i = 0 to devtablen - 1; /* search the table */      if device_label (i) <> 0 then devptr = 1; /* if we have a driver, remember it */   end;   obj.base = objlng; /* object code will go here */   if devptr then obj.base = obj.base + devtablen; /* watch for device driver table */   if (r (l.flags) and (enable.flag or when.flag)) <> 0 then obj.base = obj.base + whentablen; /* watch out for WHEN table */   swap_area = obj.base + swap_area; /* swap area at end of object code (SWAP_AREA better equal CUR.LOC before calculation) */   vstrt = swap_area + swap_size; /* default variable area at end of swap area */   ram = adjram (ram); /* adjust ram for any deleted procedures */   if (vstrt ilt 8192) and (ram ilt 8001) then vstrt = 8192; /* put at 8k if short pgm */   if r (l.ovram) <> 0 then begin; /* user specified */      if (r (l.ovram) ilt obj.base + cur.loc) then do; /* memory conflict */         print;         print 'Memory conflict - starting RAM address is too low.  For this';         print 'program, the RAM area must be at or above location ',;         print (obj.base + cur.loc), ' decimal.';         call exit(-1);      end;      vstrt = r (l.ovram); /* move it to here */   end;   if devptr then do; /* need to emit the device driver table */      device_table = objlng; /* device driver table goes here */      do i = 0 to devtablen - 1; /* emit table */         if device_label (i) <> 0 then do; /* if we have a driver */            if i < devdrivers then do; /* if this is a device driver pointer */               devptr = device_table + devtablen + keyloc (device_label (i)); /* pick up routine pointer */               if (r (l.flags) and (enable.flag or when.flag)) <> 0 /* if 'enable' or 'when', bind in table */               then devptr = devptr + whentablen; /* watch out for WHEN table */            end;            else devptr = vstrt + adjram (device_label (i)) - 1; /* else pick up variable location */            call writeobj (devptr); /* write out pointer */         end; /* of if we have a driver */         else call writeobj (0); /* no driver available */      end;      rtpcode = rtpcode + devtablen; /* DEVTABLEN more rtp words */   end;   if (r (l.flags) and (enable.flag or when.flag)) <> 0 then do; /* if 'enable' or 'when', bind in table */      whentab = objlng; /* when table goes here */      do i = 0 to whentablen - 1;         if r (l.icell + i) <> 0          then call writeobj (keyloc (r (l.icell + i)) + whentab + whentablen); /* emit ptr to rtn */         else call writeobj (0); /* else no when statement */      end;      rtpcode = rtpcode + whentablen; /* WHENTABLEN more rtp words */   end;   if r (l.swap) <> 0 then do; /* if swappable procs */      swap_ram = vstrt + ram - 1; /* point to ram reserved for swapping */      ram = ram + 4; /* allocate it */   end;   if ((r (l.flags) and enable.flag) <> 0) or (r (l.ich) <> 0) then do; /* if enable or rcvdchar used */      rcvdp = vstrt + ram - 1;      ram = ram + 1;   end;   if (r (l.ipr) <> 0) then do; /* check for user input statement */      inv = vstrt + ram - 1; /* allocate input buffer */      ram = ram + 67;   end;   if (r (l.sbr) or r (l.sbw)) <> 0 then do;      sbrwp = vstrt + ram - 1; /* allocate special word pair */      ram = ram + 2;   end;   if r (l.see) <> 0 then do;      seekp = vstrt + ram - 1;      ram = ram + 4;   end;end bindrtp;/* $$Generate the symbol table: */gensym: proc; /* output symbol table (uses KEYLOC and KEYFLAG) */   dcl type         fixed; /* type of current symbol */   dcl more.symbols fixed; /* set to one if there are more symbols in this library */   dcl header       fixed; /* set to one to print symbol header */   dcl (i, j)       fixed;/* The following procedure returns the memory location associated with a.  given symbol in the linker symbol table. */   adj_loc: proc(symbol); /* return memory location associated with a symbol */      dcl symbol fixed; /* the symbol to find the address of */      dcl type   fixed; /* that symbol's type */      type = type_sym (symbol); /* get the symbol type */      if type = t.proc then do; /* procedure */         if (keyflag (loc_sym (symbol) + proc_flags) and p.swap) <> 0 /* swapping proc? */         then return (keyloc (loc_sym (symbol))); /* yes, return ID */         else return (obj.base + keyloc (loc_sym (symbol))); /* no, return absolute address */      end; /* of procedure */      else if type = t.label then return (obj.base + keyloc (loc_sym (symbol))); /* label */      else if (type = t.data) or (type = t.fdata) then return (introlen + adj_scon (loc_sym (symbol))); /* data */      else                                             return (vstrt + adj_ram (loc_sym (symbol)) - 1); /* info */   end adj_loc;/* The following procedure outputs an entry from the symbol table..  If HEADER is one, a header is output before the symbol. */   print.sym: proc(symbol, header) fixed; /* print out a symbol table entry */      dcl symbol fixed; /* the symbol to output */      dcl header fixed; /* 0 = don't print header, 1 = print header */      dcl type   fixed; /* record type */      dcl i      fixed;      if header then do; /* print header? */         call eol;         call pstring ('   symbol            lineno  type         address  storage'); call eol;      end;      call pstring ('   '); call pstring (loc(get_sym (ptr_sym (symbol)))); /* print symbol name */      do i = stable (ptr_sym (symbol)) + 1 to 19 - 1; /* tab to position 19 */         call pstring (' ');      end;      call unum (lnum_sym (symbol)); /* print line number */      call pstring ('  '); /* tab to position 27 */      type = type_sym (symbol); /* print type */      if      type = t.var   then call pstring ('fixed      ');      else if type = t.arr   then call pstring ('fixed array');      else if type = t.fvar  then call pstring ('floating   ');      else if type = t.farr  then call pstring ('float array');      else if type = t.data  then call pstring ('fixed data ');      else if type = t.fdata then call pstring ('float data ');      else if type = t.proc  then do;         if (keyflag (loc_sym (symbol) + proc_flags) and p.swap) <> 0 /* swapping proc? */         then                     call pstring ('swap proc  ');         else                     call pstring ('procedure  ');      end;      else if type = t.label then call pstring ('label      ');      else do;        call unum (type); call pstring ('     '); end;      call pstring ('  '); /* tab to position 40 */      call onum (adj_loc (symbol)); /* output address */      call pstring ('   '); call onum (store_sym (symbol)); call eol; /* tab to position 49 and print storage */   end print.sym;/* $$Gensym - sort and output the symbol table:..   The following procedure sorts the symbol table using a simple.   insertion sort.  The table is sorted in-place by actually sorting.   an array of pointers which are passed to this routine.  The table.   is sorted by defining library in ascending order.  Any conflicts.   are resolved by a subsort on the symbol name (again in ascending.   order). */   s.sort: proc(symbols); /* sort the symbol table by defining library */      dcl symbols fixed; /* number of symbols defined */      dcl temp    fixed;      dcl (i, j)  fixed;      do i = 0 to symbols - 2; /* sort all symbols */         if ((deflib_sym (sort_sym (i)) > deflib_sym (sort_sym (i + 1))) /* are the next two elements out of order? */         or ((deflib_sym (sort_sym (i)) = deflib_sym (sort_sym (i + 1))) /* check the subfield when equal */         and (strcmp (loc(get_sym (ptr_sym (sort_sym (i)))), loc(get_sym (ptr_sym (sort_sym (i + 1))))) > 0)))         then do; /* yes, put them in order */            temp = sort_sym (i + 1); /* save the next element's value */            j = i; /* start moving earlier elements up */            do while ((j >= 0) and ((deflib_sym (sort_sym (j)) > deflib_sym (temp)) /* stop when TEMP fits in */            or ((deflib_sym (sort_sym (j)) = deflib_sym (temp)) /* check the subfield when equal */            and (strcmp (loc(get_sym (ptr_sym (sort_sym (j)))), loc(get_sym (ptr_sym (temp)))) > 0))));               call set_sort_sym (j + 1, sort_sym (j)); /* move the element up */               j = j - 1; /* look at previous element */            end;            call set_sort_sym (j + 1, temp); /* place element in its proper place */         end;      end;   end s.sort;   do i = 0 to nextsym - 1; /* initialize symbol table pointers */      call set_sort_sym (i, i);   end;   call s.sort (nextsym); /* sort the symbol table (by defining library, then name) */   call eol; /* print header */   call pstring ('Symbol table:'); call eol;   j = 0; /* initialize symbol table index */   do i = 1 to next_lib; /* loop over the libraries */      call eol; /* print information about the library */      call pstring ('Library:  '); call pstring(loc(addr(lib_name (name_lib (i))))); call eol;      call pstring ('Extents:  data:  ');      if adj_scon (b.scon (i)) <> adj_scon (b.scon (i + 1)) /* make sure there's data */      then do; call onum (introlen + adj_scon (b.scon (i))); call pstring (' to '); call onum (introlen + adj_scon (b.scon (i + 1)) - 1); end;      else call pstring ('none'); call eol;      call pstring ('        object:  ');      if b.key (i) <> b.key (i + 1) /* make sure there's object */      then do; call onum (obj.base + b.key (i)); call pstring (' to '); call onum (obj.base + b.key (i + 1) - 1); end;      else call pstring ('none'); call eol;      call pstring ('           ram:  ');      if adj_ram (b.ram (i)) <> adj_ram (b.ram (i + 1)) /* make sure there's ram */      then do; call onum (vstrt + adj_ram (b.ram (i))); call pstring (' to '); call onum (vstrt + adj_ram (b.ram (i + 1)) - 1); end;      else call pstring ('none'); call eol;      more.symbols = 1; /* assume there are some symbols in this library */      header = 1; /* print header before next symbol */      do while ((j < nextsym) and more.symbols); /* output all symbols from this library */         if deflib_sym (sort_sym (j)) = i /* is this symbol in this library? */         then do; /* yes, output it */            type = type_sym (sort_sym (j)); /* get type of symbol */            if ((type = t.proc) or (type = t.label)) then do; /* make sure either is active before outputting */               if (keyflag (loc_sym (sort_sym (j))) and abit) <> 0 then do; /* if active, output it */                  call print.sym (sort_sym (j), header); /* print out the symbol */                  header = 0; /* don't output header next time around */               end;            end; /* of make sure it's active */            else do; /* not a key - just output it */               call print.sym (sort_sym (j), header); /* print out the symbol */               header = 0; /* don't output header next time around */            end;            j = j + 1; /* look at next symbol */         end; /* of output it */         else more.symbols = 0; /* no more symbols for this library */      end; /* of output all symbols */   end; /* of loop over the libraries */   call pstring ('*** End of symbol table ***'); call eol;end gensym;/* $$Generate final object file:..     Read through intermediate file and generate object code. */create_object: proc(scon, skip_opt); /* generate object code (uses KEYLOC, KEYJTO, and KEYFLAG) */   dcl scon     fixed array; /* table to store swapping SCON for each proc */   dcl skip_opt fixed; /* TRUE if we skipped dead code analysis (also skips short jumps) */   dcl swapscon fixed; /* pointer into SCON (length of scon stored in SCON) */   dcl swap_key fixed; /* key of current swappable proc */   dcl swap_key_id fixed;   dcl swapdata fixed; /* TRUE if copy data records should swap */   dcl swap_sec fixed; /* starting sector of swap proc in overlay file */   dcl swap_pos fixed; /* position of swap proc in overlay file */   dcl swap_start fixed; /* starting cur.loc for this swap proc */   dcl active   fixed; /* TRUE if we're processing active code */   dcl key      fixed; /* current key value */   dcl okey     fixed; /* old key value */   dcl ocl      fixed; /* old CUR.LOC */   dcl dist     fixed; /* jump distance */   dcl cond     fixed; /* jump condition */   dcl des      fixed; /* destination of variable pointer, etc. */   dcl vloc     fixed; /* variable location */   dcl swap     fixed; /* P.SWAP bit for this proc */   dcl sp       fixed; /* stack pointer (r15 for models A & B, r12 for model C & later) */   dcl p.lnum   fixed; /* previous sequence number read in */   dcl p.addr   fixed; /* previous address read in */   dcl header   fixed; /* TRUE if we should output the sequence header before the next sequence number */   dcl indent   fixed; /* current sequence table indent level */   dcl count    fixed; /* count of sequence numbers output on this line */   dcl i        fixed;   dcl temp     fixed;   dcl p0.obj   fixed; /* obj.base for page 0 (internal memory) code    */   dcl current.page  fixed;   dcl new.page      fixed;   dcl swap_too_large fixed; swap_too_large = 1; /* TRUE if the swap area is too large */   dcl swap_too_small fixed; swap_too_small = 0; /* TRUE if the swap area is too small */   dcl always_process data (6, et.lde, et.pen, et.ins, et.ldf, et.seq, et.ald); /* records to always process */   dcl not_always (et.max) fixed; /* FALSE if this record should always be processed */   line: proc(indent); /* indent the line */      dcl indent fixed; /* amount to indent */      dcl i      fixed;      do i = 1 to indent; /* indent */         call pstring ('   ');      end;   end line;   print.sequence: proc(lnum, addr); /* add a line number/address to the sequence table */      dcl lnum fixed; /* line number */      dcl addr fixed; /* address */      if count <> 0 /* are we at the start of the line? */      then call pstring ('    '); /* no, tab over */      else call line (indent); /* yes, indent if necessary */      call unum (lnum); call pstring ('  '); call onum (addr); /* output next sequence table entry */      count = count + 1; /* we've now output one more number */      if count = 4 /* are we at the end of the line? */      then do; /* yes, skip */         call eol;         count = 0; /* reset counter */      end;   end print.sequence;   Emit.Page.0.Call: proc (page.0.loc);      dcl page.0.loc  fixed;      /* Model A or B: */      if prctyp < 2 then do;     /* model A, B */         call xmit (b.rs + b.ibt + b.pc - 1, 1); /* r16i to d1    */         call writeobj (page.0.loc);             /* and emit absolute pointer */      end;      /* Calling an rtp from external memory on model D: */      else if (swap_key <> 0)      and     (prctyp   >= 3)      then do;         call xmit (b.ms + b.ibt + b.pc, b.rd + "15"); /* pci to R15 */         call writeobj (page.0.loc);    /* and emit absolute pointer */         call xmit (b.is + rfbuf(l.pgsw), b.ca + b.tra);      end;      /* calling an rtp from model C,  or from an internal */      /* memory Model D routine:                           */      else do;         call xmit (b.ms + b.ibt + b.pc, b.ca + b.tra); /* pci to atra for Model C and later */         call writeobj (page.0.loc); /* and emit absolute pointer */      end;   end Emit.Page.0.Call;   call blockset (not_always, et.max + 1, 1); /* assume no records are always processed */   do key = 1 to always_process (0); /* set up NOT_ALWAYS */      not_always (always_process (key)) = 0; /* always process this type of record */   end;   if (r (l.flags) and symtab.flag) <> 0 then do; /* print sequence number table header */      call eol; call eol;      call pstring ('Sequence number table:');      header = 1; /* output header if we find a sequence number */      indent = 0; /* no indentation yet */      count = 0; /* no numbers across the page yet */      p.addr = -1; /* invalidate previous address */   end;   if prctyp < 2 then sp = "15"; else sp = "12"; /* assign proper stack pointer */   p0.obj = obj.base;   /* save start of object base of internal memory */   iteration = iteration + 1; /* for stat printout */   active = 1; /* we're initially known to be active */   key = readif; /* get first word of file */   do while (key <> 0); /* and wait until eof */      if key <> et.cpy then swapdata = 0; /* only swap copy data records which immediately follow the data definition (which sets this flag) */      if (key and literal.mask) <> 0 then do; /* literal word */         if active then call writeobj (key); /* just write it to the object */      end;      else if ((not active) and not_always (key)) /* active code? */      then call skiprecord (key); /* no, skip the record */      else do case (key - 1); /* branch on record type */         call writeobj (readif); /* write out literal */         do; /* jump instruction */            cond = readif;            key = readif;            ocl = readif;            if key = 0 then dist = -1; /* this is jmp . */            else do; /* compute distance to jump */               dist = keyloc (key) - ocl - 1; /* compute relative distance (OCL had better equal CUR.LOC here or phase error!) */               if (((keyflag (key) and dbit) = 0) and (dist = -1)) then dist = 0; /* deleted jmp .+1 instruction */            end;            if dist <> 0 then do; /* dist of 0 are tossed */               if ((not skip_opt) and emitt (dist)) /* if fits in immediate (and didn't skip optimization) */               then call xmit (b.is + (dist and b.imsk), b.cr + cond); /* immed cond rel */               else do; /* else use full word */                  call xmit (b.ms + b.ibt + b.pc, b.ca + cond); /* else abs */                  call writeobj (obj.base + keyloc (key)); /* emit abs pointer */               end;            end; /* of not dist of 0 (not jmp .) */            if cond = b.tra then active = 0; /* no longer active for unconditional transfers */         end; /* of jump */         do; /* user proc call */            okey = readif; /* get length of record */            key = readif;  /* get key */            do okey = 1 to okey - 1; call readif; end; /* skip rest of record */            swap = (keyflag (key + proc_flags) and p.swap); /* get SWAP bit of called proc */            vloc = keyloc (key); /* pick up address of called proc (or id # of swapping proc if it swaps) */            /* if calling a swap procedure, see how many instructions */            /* it will need:                                          */                        if (swap <> 0) then do;        /* calling a swap proc     */               if (swap_key = key)         /* if call to itself, only */               then do;                    /* emit same page jump     */                  if prctyp < 3            /* if model A, B, C        */                  then call Emit.Page.0.Call(swap_area);                  else do;                     /* jump back to top of this page.                */                     call xmit (b.ms + b.ibt + b.pc, b.ca + b.tra); /* pci to atra for Model C and later */                     call writeobj (swap_start);                  end;               end;               else if  (prctyp     >= 3)  /* if on model d ...       */               and      (swinfo.ptr <> 0)  /* if swinfo storage available */               and      (vloc ilt swinfo.max)      /* and info for id we are calling is available */               and      (swinfo(2*vloc) <> 0)      /* and proc we are calling uses no string/data storage */               and      ((shr(swinfo(2*vloc+1),8) < 4)   /* takes 3 or fewer register arguments */               or        ((swap_key <> 0)                /* or we are in a swap proc now */               and        (swap_key_id ilt swinfo.max)   /* and info for current procedure is available */               and        ((swinfo(2*vloc+1)&255) = (swinfo(2*swap_key_id+1)&255)))) /* and it resides on the same page as the one we are calling */               and      (not debug_on)     /* don't do this if debug flag on */               then do;                  new.page = swinfo(vloc*2+1)&255;  /* get page proc we are calling is on */                  if swap_key = 0      /* if we are on page 0,  must look up */                  then do;             /* where swap file is in memory    *//* pci to r15    */  call xmit (b.ms + b.ibt + b.pc, b.rd + "15"); /* pci to r15 - pick up pointer to canonical location *//* swapram       */  call writeobj (swap_ram);    /* pointer to canonical loc *//* mr15 to r3    */  call xmit (b.ms + "15", b.ad + "3"); /* mr15 t0 load 3 *//* im0  to bsor3 */  call xmit (b.is, b.bsor + "3");      /* im(0) to bsor3 */                     if new.page <> 0 then do;                        if emitt (new.page)    /* will the page # fit in one word? *//* page to  add3 */     then call xmit (b.is + (new.page and b.imsk), b.ad + b.add + "3");                        else do; /* need to use long immediate */                           call xmit (b.ms + b.ibt + b.pc, b.ad + b.add + "3"); /* pci to add3 */                           call writeobj (new.page); /* send location */                        end;                     end;/* pci to r15   */   call xmit (b.ms + b.ibt + b.pc, b.rd + "15"); /* pci to R15 *//* location     */   call writeobj (swinfo(2*vloc));/* jump pgx     */   call xmit (b.is + rfbuf(l.pgx), b.ca + b.tra);                  end;                  else do;             /* else we can do relative transfer */                     current.page = swinfo(swap_key_id*2+1)&255;                     /* if on same page, transfer with simple jump */                     /* else use page switch code                  */                     if  (current.page <> new.page)   /* if different page */                     then do;                        if emitt(new.page - current.page)                         then do;                            call xmit (b.is + ((new.page - current.page)&b.imsk), b.rd + "3"); /* page delta to r3 */                        end;                        else do; /* need to use long immediate */                           call xmit (b.ms + b.ibt + b.pc, b.rd + "3"); /* pci to mrI - send ID to loc */                           call writeobj (new.page - current.page); /* send page difference */                        end;                        call xmit (b.ms + b.ibt + b.pc, b.rd + "15"); /* pci to R15 */                        call writeobj (swinfo(2*vloc));                        call xmit (b.is + rfbuf(l.pgx), b.ca + b.tra);                     end;                     else do;                        call xmit (b.ms + b.ibt + b.pc, b.ca + b.tra); /* pci to atra for Model C and later */                        call writeobj (swinfo(vloc*2));                     end;                  end;               end;               /* else if models c or d, store swap id # in r15 */               /* and jump to low memory:                       */               else if prctyp >= 2 then do;   /* models c, d    */                  if emitt (vloc)      /* will the ID fit in one word? */                  then call xmit (b.is + (vloc and b.imsk), b.rd + "15"); /* im(ID) to R15 */                  else do; /* need to use long immediate */                     call xmit (b.ms + b.ibt + b.pc, b.rd + "15"); /* pci to R15 */                     call writeobj (vloc); /* send location */                  end;                  call xmit (b.is + swpe, b.ca + b.tra);               end;               /* else store proc id# in memory (models a,b)    */               /* and call r.swap                               */               else do;                    /* call a normal swap proc */                  call xmit (b.ms + b.ibt + b.pc, b.rd + "12"); /* pci to r12 - pick up pointer to canonical location */                  call writeobj (swap_ram + 1); /* pointer to canonical loc */                  if emitt (vloc) /* will the ID fit in one word? */                  then call xmit (b.is + (vloc and b.imsk), b.md + "12"); /* im(ID) to mr12 - send ID to loc */                  else do; /* need to use long immediate */                     call xmit (b.ms + b.ibt + b.pc, b.md + "12"); /* pci to mr12 - send ID to loc */                     call writeobj (vloc); /* send location */                  end;                  call Emit.Page.0.Call(r(l.swap));               end;            end;            else if (swap_key   <> 0)          /* else if  within a swap proc */            and     (prctyp     >= 3)          /* residing in external memory */            and     (keyloc (key + proc_regs)) /* that calls a proc defined within */            then do; /* proc_inside */         /* the swap proc:                   */               call xmit (b.ms + b.ibt + b.pc, b.ca + b.tra); /* pci to atra for Model C and later */               call writeobj (vloc + obj.base);            end;            else call Emit.Page.0.Call(vloc + p0.obj);         end;         begin; /* rtp call */			dcl where fixed;						where = readif;										    /* get what to call							*/						if (where IGE l.interp) then do;						/* interpreter call							*/				where = where - l.interp;							/* get abs interpreter code					*/				if (emitt (where))									/* will fit into immed field?				*/				then call xmit (b.is + (where & b.imsk), b.cr + b.tnv);	/* immed to destination						*/				else do;											/* full word								*/					call xmit (b.ms + b.ibt + b.pc, b.cr + b.tnv);	/* pc and i to dest							*/					call writeobj (where);										end;												/* full word								*/			end;            else call Emit.Page.0.Call(r(where));         end;         do; /* variable pointer */            des = readif; /* dest */            i = readif; /* storage class */            vloc = readif; /* relative variable distance */            do case (i); /* branch on storage class */               do; /* static */                  call xmit (b.ms + b.ibt + b.pc, des); /* full scale */                  call writeobj (vstrt + adjram (vloc) - 1); /* -1 here because first vloc was 1 */               end; /* of static */               do; /* automatic */                  call xmit (b.rs + sp, des); /* move stack pointer to destination */                  des = b.ad + b.add + (des and b.amsk); /* convert destination to ADD instruction */                  if emitt (vloc) /* if fits in immediate field */                  then call xmit (b.is + (vloc and b.imsk), des); /* add in stack offset */                  else do; /* must use long immediate (PCI) */                     call xmit (b.ms + b.ibt + b.pc, des); /* add stack offset to SP */                     call writeobj (vloc); /* write out stack offset */                  end;               end; /* of automatic */            end; /* of storage class */         end; /* of variable pointer */         do; /* object pointer */            key = readif; /* get key */            /* for Model D,  if in swapping procedure, emit a jump */            /* to the correct case.                                */            if  (swap_key  <> 0)            and (prctyp    >= 3)            then do;               call xmit (b.ms + b.ibt + b.pc, b.ca + b.tra); /* pci to atra for Model D in swapping procedures */            end;            call writeobj (keyloc (key) + obj.base); /* write out */         end;         do; /* label def */            key = readif;            okey = keyflag (key); /* pick up current flag bits */            call set_keyflag (key, okey or dbit); /* indicate defined now */            active = (active or ((okey and abit) <> 0)); /* assume active state of label */         end;         /* $$Final code generation (cont.): */         do; /* data definition */            call readif; /* skip over key */            swapdata = ((swap_key <> 0) and readif); /* set swap data flag for following COPY DATA record(s) */         end; /* data definition */         do; /* copy data */            if swapdata then do key = 1 to readif; /* if this data should swap */               if swapscon ige swap_scon then call er.sys ('too much swapping scon', 'create_object');               scon (swapscon) = readif; /* save next word */               swapscon = swapscon + 1;            end; /* of swapping data */            else call skiprecord (key); /* if not swapping, just skip it */         end; /* copy data */         do; /* copy scon */            key = readif - 2; /* get length of scon record */            call readif; /* skip over key */            okey = readif; /* see if it swaps */            do key = 1 to key; /* read all scon */               i = readif; /* read the next word */               if ((swap_key <> 0) and okey) then do; /* if swapping, save it */                  if swapscon ige swap_scon then call er.sys ('too much swapping scon', 'create_object');                  scon (swapscon) = i; /* save it */                  swapscon = swapscon + 1;               end;            end; /* of read all scon */         end; /* copy scon */         do; /* ignore record */         end;         do; /* proc def record - store registers */            i = readif & 255; /* get length of record (for non-recursive procs, it had better be 4) */            key = readif;     /* get key */            call readif; call readif; /* ignore start ram and start temp */            cond = readif; /* get procedure attributes */            ocl = keyloc (key + proc_regs) & reg_mask; /* pick up regs used */            if (cond and p.swap) <> 0 then do; /* if a swappable procedure */               redirect.object = 1; /* redirect object code to overlay */               swap_key = key;   /* save which swappable proc we're within (to optimize recursive calls) */               swap_key_id = keyloc(key);               if prctyp >= 3 then do;    /* for model d - bump page, emit code */                  /* bump start of swap procedure up to next page bound	*/                  /* if modeld and swap proc would extend across page.	*/                  /* Look at the bit stored in KEYJTO during the final	*/                  /* optimization pass:									*/                  if ((keyloc(key + proc_regs) & proc_bound) <> 0)                  then do;                     swap_start = shl(ovsec,8) + ovpos; /* calculate cur.loc for this swapping proc */                     /* emit zeroes to fill out to page boundary */                     do while swap_start <> 0;                        call writeobj (0);                        swap_start = swap_start + 1;                     end;                     /* For Model D compilations,  emit 64 words at the  */                     /* front of swap file that contains the object code */                     /* used to switch pages:                            */                     do temp = rfbuf (l.sta) + 1 to rfbuf (l.sta) + 64; /* copy 64 words */                        call writeobj(rfbuf(temp));                     end;                  end; /* of set to page boundary */                  swap_start = shl(ovsec,8) + ovpos; /* calculate cur.loc for this swapping proc */                  obj.base = swap_start; /* object pointers relative to 0 for external memory code */               end;    /* of prctyp >= 3          */               swap_sec = ovsec; /* remember where this proc starts */               swap_pos = ovpos;             end;       /* of if swappable proc    */            if prctyp >= 2 /* on Model C and later, also save return (D10) */            then call xmit ("10", b.md + b.ibt + sp); /* d10 to mrSPd */            okey = numbits (ocl); /* get number to save */            if ((okey > cutoff) /* too many regs and Model C or (not swappable and not a device driver)? */            and ((prctyp >= 2) or (((cond and p.swap) = 0) and (not device_driver (key)))))            then call xmit (b.is + sreg, b.ca); /* call save reg */            else if okey <> 0 then call saveregs (ocl);            call enter.proc (i - 4, keyloc (key + proc_stack), cond, sp); /* enter the procedure */         end; /* of proc def record */         do; /* et.pen - end of procedure definition */            i = et.length (key); /* get length of record */            key = readif; /* get key */            do i = 1 to i - 1; /* skip rest of record */               call readif;            end;            if (active or ((keyflag (key) and abit) <> 0)) then do; /* if active or started out as active */               swap = (keyflag (key + proc_flags) and p.swap); /* save swap bit for this proc */               if active then do; /* only do the following for active code */                  call exit.proc (keyloc (key + proc_stack), sp); /* emit exit code */                  ocl = keyloc (key + proc_regs) & reg_mask; /* get regs used */                  okey = numbits (ocl); /* get number of regs */                  if ((okey > cutoff) /* too many regs and Model C or (not swappable and not a device driver)? */                  and ((prctyp >= 2) or ((swap = 0) and (not device_driver (key)))))                  then call xmit (b.is + lreg, b.ca); /* load all regs and ret */                  else do; /* load regs and return */                     if prctyp >= 2 then call xmit (b.rs + b.ibt + sp, b.ca + b.tnv); /* increment rSP on Model C & Later (rSPi to atnv) */                     if okey > 0 then call loadregs (ocl); /* load regs */                     if prctyp < 2 then call xmit (b.is + retn, b.ca + b.tra); /* and return */                     else call xmit (b.ms + sp, b.ca + b.tra); /* mrSP to atra (return on model C & later) */                  end;               end; /* of active code */               if swap <> 0 then do; /* swappable proc? (KEY had better equal SWAP_KEY) */                  okey = shl(ovsec - swap_sec, 8) + (ovpos - swap_pos); /* determine word length of swapping proc */                  if okey <> (keyjto (key + proc_objsz)) /* if swapping proc has a different length than what we got optimizing */                  then call er.sys ('swapping proc phase error', 'create_object');                  okey = okey + swapscon; /* add in swapping scon to get full length */                  if prctyp < 3 then do; /* model a,b,c - swap area contains code + strings */                     if okey igt swap_size then swap_too_small = 1; /* if swapping proc is larger than swap area */                     if okey = swap_size then swap_too_large = 0; /* if we have a match, we're okay */                  end;                  else do;  /* model d - swap area is size of string area */                     if swapscon igt swap_size then swap_too_small = 1; /* if swapping proc is larger than swap area */                     if swapscon = swap_size then swap_too_large = 0; /* if we have a match, we're okay */                     obj.base = p0.obj; /* restore object base */                  end;                  do i = 0 to swapscon - 1; /* emit the swapping scon for this proc */                     call writeobj (scon (i));                  end;                  swapscon = 0; /* no more swapping scon */                  redirect.object = 0; /* redirect object code back to object file */                  swap_key = 0; /* no longer in swappable proc */               end; /* of swappable proc */            end; /* of active or started out as active */            active = 0; /* no longer active here */         end;         do; /* when statement */            key = readif;            ocl = keyloc (key + proc_regs) & reg_mask; /* get regs used */            okey = numbits (ocl); /* get number */            if prctyp >= 2 /* on Model C and later, save return (D10) */            then call xmit ("10", b.md + b.ibt + "12"); /* d10 to mr12d */            if okey <> 0 then call saveregs (ocl); /* save these regs */         end;         do; /* end of when statement */            key = readif; /* get key */            call readif;            ocl = keyloc (key + proc_regs) & reg_mask; /* get regs used */            okey = numbits (ocl); /* get number used */            if prctyp >= 2 then call xmit (b.rs + b.ibt + "12", b.ca + b.tnv); /* increment r12 on Model C & Later (r12i to atnv) */            if okey <> 0 then call loadregs (ocl); /* load regs */            if prctyp < 2 then call xmit (b.ms + "15", b.ca + b.tra); /* return from interrupt */            else call xmit (b.ms + "12", b.ca + b.tra); /* mr12 to atra (return on model C & later) */            active = 0; /* no longer active now */         end;         do; /* emit string pointer */            okey = readif; /* get destination */            key = readif; /* and location - relative to start */            call xmit (b.ms + b.ibt + b.pc, okey); /* PCI to <dest> */            if (readif and (swap_key <> 0)) then do; /* if swapped scon */               if prctyp < 3 /* model a,b,c - string data is after swapping object code */               then call writeobj (swap_area + keyjto (swap_key + proc_objsz) + key - 1); /* pointer is in swap area after proc */               else call writeobj (swap_area + key - 1); /* string is in swap area */            end;            else call writeobj (introlen + adjscon (key)); /* emit normal pointer */         end;         /* $$Final code generation (cont.): */         do; /* addr of fixed array parameter */            call skiprecord (key); /* skip it */         end; /* of addr */         do; /* sequence number */            key = readif; /* get sequence number */            if (r (l.flags) and symtab.flag) <> 0 then do; /* if we're to dump stats */               if header then do; /* output header if necessary */                  call eol; call line (indent); /* indent if necessary */                  call pstring ('number  address   number  address   number  address   number  address'); call eol;                  header = 0; /* don't output header again */               end;               if ((p.addr <> -1) and (p.addr <> objlng)) /* has this address repeated? */               then call print.sequence (p.lnum, p.addr); /* no, output the last address */               p.lnum = key; p.addr = objlng; /* save previous address */            end;         end; /* of sequence number */         do; /* symbol reference or definition */            call skiprecord (key); /* skip over */         end; /* of symref or symdef */         do; /* module statement */            call skiprecord (key); /* skip over */         end; /* of module statement */         do; /* library statement */            call skiprecord (key); /* skip over */         end; /* of library statement */         do; /* insert statement */            key = readif; /* get record length */            do i = 1 to key; /* get insert filename */               name (i - 1) = readif;            end;            if (r (l.flags) and symtab.flag) <> 0 then do; /* are we dumping stats? */               if key <> 0 then do; /* if there's a new insert file */                  if ((p.addr <> -1) and (p.addr <> objlng)) then call print.sequence (p.lnum, p.addr); /* output last number from before the insert (if isn't duplicated) */                  if count <> 0 then call eol; /* tidy up after the last segment */                  call eol; call line (indent); /* output insert file header for sequence table */                  call pstring ('Insert:  '); call pstring (name);                  call pstring (' (object base: '); call onum (objlng); call pstring (')');                  header = 1; /* output header next time around */                  indent = indent + 1; /* and indent some more */                  count = 0; /* we're starting all over again */                  p.addr = -1; /* invalidate last address */               end; /* of new insert file */               else do; /* end of last insert file */                  if ((p.addr <> -1) and (p.addr <> objlng)) then call print.sequence (p.lnum, p.addr); /* output last number from before the insert (if isn't duplicated) */                  if count <> 0 then call eol; /* tidy up after the last segment */                  header = 1; /* output header next time around */                  indent = indent - 1; /* outdent some */                  call line (indent); call pstring ('*** End of insert (object end: '); call onum (objlng - 1); call pstring (')'); call eol;                  count = 0; /* starting all over */                  p.addr = -1; /* invalidate last address */               end; /* of insert file */            end; /* of dumping stats */         end; /* of insert statement */         do; /* library definition */            i = readif; /* get the library number */            if (r (l.flags) and symtab.flag) <> 0 then do; /* are we dumping stats? */               if ((p.addr <> -1) and (p.addr <> objlng)) then call print.sequence (p.lnum, p.addr); /* output last number from last library (if isn't duplicated) */               if count <> 0 then call eol; /* tidy up after the last library */               call eol; call eol; /* output library header for sequence table */               call pstring ('Library:  '); call pstring (location(addr(lib_name (name_lib (i)))));               call pstring (' (object base: '); call onum (objlng); call pstring (')');               header = 1; /* output header next time around */               indent = 1; /* and indent */               count = 0; /* we're starting all over again */               p.addr = -1; /* invalidate previous address */            end;         end; /* of library definition */         do; /* external symbol reference */            call skiprecord (key);         end; /* of external symbol reference */         do;  /* et.cas = emit object code for do case */            if  (swap_key  <> 0)            and (prctyp    >= 3)            then do; /* model d swapping procedure */               call xmit (b.rs + "0", b.ad + b.add + "0"); /* r0 to ADD0 - get stride of 2 for jump table */               call xmit (b.rs + "0", b.cr              ); /* r0 to rtra */            end;            else do;  /* model a,b,c, model D internal memory only */               call xmit (b.rs + b.pc, b.ad + b.add + "0"); /* PC to ADD0 - make the case # relative to the PC */               call xmit (b.is + 2, b.ad + b.add + "0"); /* im(2) to ADD0 - compensate for 2 ins needed for PC-relative addressing */               call xmit (b.ms + "0", b.ca + b.tra); /* MR0 to ATRA - transfer (indirectly) to the correct statement */            end;         end;         do; /* jump to alternate key instruction */            cond = readif;            key = readif;            ocl = readif;            if key = 0 then dist = -1; /* this is jmp . */            else do; /* compute distance to jump */               dist = altloc (key) - ocl - 1; /* compute relative distance (OCL had better equal CUR.LOC here or phase error!) */               if (((altflag (key) and dbit) = 0) and (dist = -1)) then dist = 0; /* deleted jmp .+1 instruction */            end;            if dist <> 0 then do; /* dist of 0 are tossed */               if ((not skip_opt) and emitt (dist)) /* if fits in immediate (and didn't skip optimization) */               then call xmit (b.is + (dist and b.imsk), b.cr + cond); /* immed cond rel */               else do; /* else use full word */                  call xmit (b.ms + b.ibt + b.pc, b.ca + cond); /* else abs */                  call writeobj (obj.base + altloc (key)); /* emit abs pointer */               end;            end; /* of not dist of 0 (not jmp .) */            if cond = b.tra then active = 0; /* no longer active for unconditional transfers */         end; /* of alternate jump */         do; /* alternate key label def */            key = readif;            okey = altflag (key); /* pick up current flag bits */            call set_altflag (key, okey or dbit); /* indicate defined now */            active = (active or ((okey and abit) <> 0)); /* assume active state of label */         end;      end; /* of do case */      key = readif; /* get first word of next record */   end; /* of do while */   if (r (l.flags) and symtab.flag) <> 0 then do; /* if they want stats */      if ((p.addr <> -1) and (p.addr <> obj.base + b.key (next_lib + 1))) then call print.sequence (p.lnum, p.addr); /* output last number from last library */      if count <> 0 then call eol; /* tidy up after last library output */      call eol; call pstring ('*** End of sequence table ***'); call eol; /* print sequence table trailer */      if (((r (l.flags) and dump.flag) = 0) and (not redirect.symtab)) then print; /* be neat */   end;   if r (l.swap) <> 0 then do; /* if we have a swap area */      if swap_too_small then call er.sys ('swap area too small', 'create_object');      if swap_too_large then call er.sys ('swap area too large', 'create_object');   end;end create_object;/* $$End of compilation: */finish: proc fixed; /* clean up and output compilation stats */   dcl oflen  fixed; /* object file length (in words) */   dcl conptr fixed; /* configuration table pointer */   dcl readl  fixed; /* length to read from disk */   dcl (i, j) fixed;   if r (l.swap) <> 0 then do; /* do we have an overlay file? */      creating_object = 0; /* no longer creating the object file */      do while ((ofpos and "377") <> 0); /* move up to the next sector in the object file */         call writeobject (0); /* zero out each word */      end;      call resetovr; /* reset the overlay file */      i = 0;      do while (i ilt ovsecln); /* append the swap file to the object file */         do j = 1 to 256; /* copy one sector at a time */            call writeobject (readovr);         end;         i = i + 1;      end;      oflen = shl(ofsec, 8) + ofpos + ((swap_words and "377") - 256); /* preserve final word length of file (to the word) */   end; /* of overlay file */   else oflen = objlng; /* final word length of file is just the object file length */   if ofsec <> 0 then do; /* must force */      call objforce;      readl = 256;      call readdata (ofdev, ofstart, ofbuf, readl);   end;   else do; /* entire file is in buffer */      ofsec = shr(oflen + 255, 8);      readl = oflen;   end;   /* now patch up configuration information */   conptr = ofbuf (1); /* pick up pointer to config table */   ofbuf (conptr + vstart) = vstrt;      /* start of variable area   */   ofbuf (conptr + vlngth) = ram - 1;    /* number of words to zero  */   ofbuf (conptr + stklen) = pdll;       /* length of stack          */   ofbuf (conptr + objloc) = obj.base;   /* start of object code     */   ofbuf (conptr + objlen) = objlng;     /* length of object code    */   ofbuf (conptr + swpram) = swap_ram;   /* address of swap ram area */   ofbuf (conptr + swplen) = swap_total; /* length of swapping code  */   ofbuf (conptr + rtploc) = introlen + r (l.str.data); /* start of runtime package  */   ofbuf (conptr + inttab) = whentab;    /* pointer to when table    */   ofbuf (conptr + rcvptr) = rcvdp;      /* rcvdcharacter word       */   ofbuf (conptr + inpbuf) = inv;        /* input buffer, if used    */   ofbuf (conptr + sbrsbw) = sbrwp;      /* sbr sbw word pair        */   ofbuf (conptr + curtrk) = seekp;      /* current head position word foursome */   ofbuf (conptr + devtab) = device_table; /* pointer to device drivers */   if core(loc.rst) = 1 then do; /* if this is a COMpile */      redrct = 0; /* cancel any redirection inherent in the COMpile command */      do i = 0 to configlen - 1; /* copy over monitor's configuration into output file */         if i <> c#version - c#offset /* don't change the version */         then ofbuf (conptr + c#offset + i) = r (l.ctab + i); /* copy desired configuration */      end;   end;   if r (l.in1) <> 0 then ofbuf (rfbuf (l.pat)) = r (l.in1);   /* Patch up the object file to perform jumps to the swap routine: */   /* Note: these patches only need to be made on the internal       */   /* memory page.                                                   */   if prctyp >= 2 then do;      if r (l.swap) <> 0 then ofbuf (rfbuf (l.sw2)) = r (l.swap);   end;   if prctyp >= 3 then do;      if r (l.swap) <> 0 then ofbuf (rfbuf (l.sw1)) = r (l.swap) + rfbuf(l.swpp);   end;   call writedata (ofdev, ofstart, ofbuf, readl); /* force out object file */   /* $$Finish compilation (cont.):   .     Print out stats if user requests them. */   if (r (l.flags) and dump.flag) <> 0 then do; /* stats */     print;     print 'System routines:           ',; call unum (rtpcode); print;     print 'String and data constants: ',; call unum (r (l.str.data)); print;     print 'Object code length:        ',; call unum (cur.loc);     print '     (',; call unum (objlng); print ' )'; /* OBJLNG = R (L.STR.DATA) + RTPCODE + CUR.LOC [Verified below] */     if swap_procs <> 0 then do;     print 'Swap area:                 ',; call unum (swap_size); print;     end;     print 'Variable space required:   ',; call unum (ram - 1); print;     print 'Push down list length:     ',; call unum (pdll);     print '     (',; call unum (vstrt + ram - 1 + pdll); print ' )';     print;         print 'Symbol table:   [',; call unum (r (l.#st)); print ' ]: ',; call unum (r (l.s.names.len));     print '    Keys used:      [',; call unum (max_keys);  print ' ]: ',; call unum (r (l.key)); print;         print 'Stack used:     [',; call unum (r (l.#sk)); print ' ]: ',; call unum (r (l.stack.used));     print '    Alt keys used:  [',; call unum (max_alts);  print ' ]: ',; call unum (r (l.altkey)); print;         print 'RAM tossed:     [',; call unum (divmax);    print ' ]: ',; call unum (ramptr);     print '    SCON tossed:    [',; call unum (divmax);    print ' ]: ',; call unum (sconptr); print;         print 'First file:     [',; call unum (core(loc.wsln)); print ' ]: ',; call unum (r (l.iflng));     print '    Second file:    [',; call unum (r (l.#if2));     print ' ]: ',; call unum (r (l.if2lng)); print;     if (r (l.flags) and link.flag) <> 0 then do; /* output additional stats if we're linking */         print 'Libraries:      [',; call unum (lib_size);    print ' ]: ',; call unum (next_lib);     print '    Link file:      [',; call unum (ifmaxln);     print ' ]: ',; call unum (ifsecln); print;         print 'Public symbols: [',; call unum (max_symbols); print ' ]: ',; call unum (nextsym);     print '    Linker symtab:  [',; call unum (stable_size); print ' ]: ',; call unum (nextstable); print;     end;     if swap_procs <> 0 then do; /* output overlay info */         print 'Swapping procedures:       ',; call unum (swap_procs);     print '    Swap file (sectors):       ',; call unum (swap_total); print;     end;         print 'Total iterations:          ',; call unum (iteration);     print '    Blocks used:    [',; call unum (r (l.#bl)); print ' ]: ',; call unum (r (l.get.blocks)); print;     print;   end;   if (((r (l.str.data) + rtpcode + cur.loc) <> objlng) or (swap_area <> objlng))   then call er.sys ('phase error', 'finish');   if ((core(loc.rst) = 0) and (swap_total igt core(loc.emsize))) /* RUNning a swapping program without enough external memory? */   then call er.ftl ('Not enough external memory to run program');   /* print memory map */   if ((r (l.flags) and dump.flag) <> 0) or (core(loc.rst) = 1) or (((vstrt + ram - 1 + pdll) and "140000") <> 0) then do; /* stats reqd */      print 'Memory map:';      print '  Start: 000000  Conf: ', octal(conptr), '  Scon:  ', octal(introlen),;      print '  RTP:  ', octal(introlen + r (l.str.data)), '  Object: ', octal(obj.base);      print '  Swap:  ', octal(swap_area), '  Vars: ', octal(vstrt),;      print '  Stack: ', octal(vstrt + (ram - 1)), '  Heap: ', octal(vstrt + (ram - 1) + pdll);      print 'Memory required for this program: ',; call unum (vstrt + ram - 1 + pdll); print ' words.';      print;   end; /* if stats printed on dump or compile */   return (oflen); /* return object file length */end finish;