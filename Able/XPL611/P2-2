/*.  .  The following procedures are used to print error messages on the.  terminal, in a variety of formats.*/  er.cerr: proc(str); /* compiler system error */dcl str array;  print;  print '### Compiler system error (', string(str), ') at line', line.no;  call exit(-1);end er.cerr;  er.etc: proc(str); /* expression too complicated */  dcl str array;  print;  print 'Expression too complicated at line', line.no, ' (', string(str), ')';  call exit(-1);end er.etc;  er.emes1: proc(str); /* print string */  dcl str array;  print string(str), ' at line', line.no;  trmst = -1; /* abort compilation */end er.emes1;  er.atdnm: proc; call er.emes1 ('Argument types do not match');end;er.fna:   proc; call er.emes1 ('Floating point not allowed with fixed point');end;er.tmnc:  proc; call er.emes1 ('Too many numeric constants');end;er.tmpl:  proc; call er.emes1 ('Too many procedures/labels');call exit(-1);end;/* Routine GKEY:.     The routine GKEY is called to get the next key..     It increments the key counter and returns the new value.*/  gkey: proc;  nexkey = nexkey + 1;  if nexkey ige shr(extern.base, 1) then call er.tmpl; /* did we collide with the externals? */  return (nexkey);end gkey;  galt: proc; /* used to get an alternate key */  altkey = altkey + 1; /* incr alt key */  if altkey ige shr(extern.base, 1) then call er.tmpl; /* did we collide with the externals? too many procs/labels */  return (altkey); /* note that zero is never returned */end galt;/* Storage allocation:.  .   Many routine need allocatable fixed length blocks.  Since they.   all want four word blocks, these blocks are all allocated out.   of the same arrays.  The blocks consist of one entry in each of four.   separate arrays.  To keep the different uses distinguishable, any.   routines using these arrays should declare their own names for them.   and also rename the storage allocation routines.  Note that the block.   with index zero is never used.  This means that zero as a link may.   be used to indicate the end of a list. */dcl free       fixed; free = 1; /* free block pointer */dcl free.end   fixed; /* end of free list pointer */dcl blk.in.use fixed; /* number of blocks currently in use */ store1 (free) = 0; /* zero indicates end of list */free.end = free;do free = free + 1 to #blocks;  store1 (free) = free - 1;end;free = #blocks; /* get a block from free storage */ get: proc;  dcl block fixed;  block = free;  if block = 0 then call er.etc ('get');  else free = store1 (block);  blk.in.use = blk.in.use + 1;  if blk.in.use > get.blocks then get.blocks = blk.in.use;  return block;end get; /* return a block to free storage */ rel: proc(block);  dcl block fixed;  store1 (block) = free; /* link up */  free = block; /* here we are */  blk.in.use = blk.in.use - 1;end rel; /* Stack definitions and routines:. .  The stack is used for any important parameters during any of the.  recursive routines in the compiler.  This is true not only for the.  recursive descent scanning routines, but also, for example, for the.  recursive expression compiler.  */ dcl stack (stacksize) fixed;dcl stackpt fixed; /* pointer into stack */dcl queue lit 'stack'; /* put a queue over the stack */dcl frontpt fixed; /* pointer to front of queue */dcl startpt fixed; /* where the queue starts in the stack */ /* stack push and pop routines */ push: proc(info);   dcl info fixed;   if stackpt igt stacksize then call er.etc ('push');   stack (stackpt) = info;   stackpt = stackpt + 1;   if stack.used ilt stackpt then stack.used = stackpt; /* stats */end push; pop: proc;  dcl top fixed;  if stackpt ile frontpt then call er.cerr ('stack underflow (pass2 pop)');  stackpt = stackpt - 1;  top = stack (stackpt); /* strip off the top */  if stackpt = frontpt then do; /* end of stack */     if startpt <> 0 then do; /* watch out for empty queue */        stackpt = startpt - 2; startpt = stack (stackpt); frontpt = stack (stackpt + 1); /* reset stack and queue */     end;     else do; /* possibly empty queue */        stackpt = 0; frontpt = 0; /* reset stack and queue */     end;  end; /* of end of stack */  return top;end pop;start_queue: proc; /* start a queue */   if stackpt <> 0 then do; /* only save if we're not at the beginning */      call push (startpt); /* start a new queue */      call push (frontpt);   end;   startpt = stackpt; /* remember where it starts */   frontpt = stackpt; /* start dequeueing here */end start_queue;dcl enqueue lit 'push'; /* just to turn it into a bonafide queue */dequeue: proc; /* dequeue an element from the stack */   dcl next fixed;   if frontpt ige stackpt then call er.cerr ('queue underflow (pass2 dequeue)');   next = queue (frontpt); /* pull off the next element in line */   frontpt = frontpt + 1; /* move pointer up */   if frontpt = stackpt then do; /* end of queue */      if startpt <> 0 then do; /* watch for empty stack */         stackpt = startpt - 2; startpt = stack (stackpt); frontpt = stack (stackpt + 1); /* reset stack and queue */      end;      else do; /* possibly empty stack */         stackpt = 0; frontpt = 0; /* reset stack and queue */      end;   end; /* of end of queue */   return next;end dequeue;/* Miscellaneous push and pop routines (save registers, etc.):.  .  The array REGC contains during compilation what each index.  register will contain during runtime.  By carefully keeping.  track of which registers are loaded when, it is possible.  to do a fair job of optimizing the index register use.  This.  is very important on the ABLE machine, since memory can only.  be accessed by the index registers.  REGS contains the appropriate.  storage class (address space) that that particular register.  points into...  The array REGP contains during compilation what each index.  register was explicitly set to by GETVP.  If a value in REGP.  does not equal the corresponding value in REGC, the index.  register was implicitly altered by some register increment.  instruction.  This information is important because the.  final locations of external references are not known until.  after relocation in pass3.  If REGP does not correspond to.  REGC for an external reference, that index register MUST be.  reloaded...  An index register is considered free when REGC (reg) is zero...  The global variables REGU and REGL are used to keep track of which.  registers are used by a procedure without being loaded (REGU) and.  which index registers are actually loaded by a certain section of.  code (REGL).*/  dcl (regl, regu)         fixed; /* lists of registers loaded/used */dcl regc   (max.ptr.reg) fixed; /* holds contents of the index registers */dcl regs   (max.ptr.reg) fixed; /* holds storage class of index registers */dcl regp   (max.ptr.reg) fixed; /* holds explicitly set contents of index registers */dcl regloc (max.ptr.reg) fixed; /* used to select 'least recently used' register */dcl tregc  (max.ptr.reg) fixed; /* holds set of registers temporarily */dcl tregs  (max.ptr.reg) fixed;dcl tregp  (max.ptr.reg) fixed;dcl t1regc (max.ptr.reg) fixed; /* more temps */dcl t1regs (max.ptr.reg) fixed;dcl t1regp (max.ptr.reg) fixed;dcl regbit data ("1", "2", "4", "10", "20", "40", "100", "200", "400", "1000", "2000", "4000", "10000", "20000", "40000", "100000"); /* bit assignments for regs */  pushr: proc; /* save the regs on the stack */   dcl (bits, i) fixed;   bits = 0; /* which are stored */   do i = min.ptr.reg to max.ptr.reg;      if regc (i) <> 0 then do;         bits = (bits or regbit (i)); /* remember this register saved */         call push (regc (i)); /* save loc and storage class */         call push (regs (i));         call push (regp (i)); /* save explicit setting also */      end;   end;   call push (bits); /* and store the bits too */end pushr;  popr: proc; /* restore regs saved by pushr */   dcl (bits, i) fixed;   bits = pop; /* get bits */   i = max.ptr.reg;   do while (i >= min.ptr.reg);      if (bits and regbit (i)) <> 0 then do; /* if previously saved */         regp (i) = pop; /* restore */         regs (i) = pop;         regc (i) = pop;      end;      else regc (i) = 0;   /* clear   */      i = i - 1;   end; /* of loop */end popr;  /* During compilation, it is often necessary to store temporarily.   the contents of the REGC array.  This happens, for example, at.   the end of an iterative do-loop, when a jump instruction is.   emitted back to an earlier section of code.   .  .   When this jump instruction is emitted, any registers that were used.   earlier in the routine but were then reloaded during a later section.   of code are reloaded before the jump is emitted..  .   The following routines facilitate the manipulation of the REGC.   array on and off the stack, and in and out of temporary storage.   areas.*/  sreg: proc; /* move regs tempo */   dcl i fixed;   do i = min.ptr.reg to max.ptr.reg;      tregc (i) = regc (i);      tregs (i) = regs (i);      tregp (i) = regp (i);   end;end sreg;  lreg: proc;   dcl i fixed;   do i = min.ptr.reg to max.ptr.reg;      regc (i) = tregc (i);      regs (i) = tregs (i);      regp (i) = tregp (i);   end;end lreg;  sreg1: proc; /* save in another temporary */   dcl i fixed;   do i = min.ptr.reg to max.ptr.reg;      t1regc (i) = regc (i);      t1regs (i) = regs (i);      t1regp (i) = regp (i);   end;end sreg1;  lreg1: proc;   dcl i fixed;   do i = min.ptr.reg to max.ptr.reg;      regc (i) = t1regc (i);      regs (i) = t1regs (i);      regp (i) = t1regp (i);   end;end lreg1;  pushv: proc; /* push REGU, REGL */   call push (regl);   call push (regu);   regl = 0;   regu = 0;end pushv;  popv: proc; /* restore */   dcl (pregu, pregl) fixed;   pregu = pop; /* get old REGU */   pregl = pop; /* and REGL     */   regu = (pregu or (regu and (not pregl))); /* used means one used that we did not load */   regl = (regl or pregl); /* and these are the total register used in this block */end popv; /* Code emission:..   During code emission, certain blocks are allocated with the 'GET'.   routine to help in the processing of temporaries, procedure call.   generation, and so forth..  .   The locations of the 'GET' blocks that are used are: */  dcl e.loc   lit 'store2'; /* location (if known) */dcl e.point lit 'store4'; /* pointer for various linked lists */dcl e.get   lit 'get'; /* storage allocation routines */dcl e.rel   lit 'rel';  dcl zflags fixed;   /* indicates which register corresponds to ZFLAGS */zflchk: proc(des);  /* examines dest to see if it sets ZFLAGS */  dcl des fixed;  if (des and "300") = b.ad then do; /* arith, test */    zflags = shl(1, des and 3); /* indicate register by bit # */    if (des and "360") = b.td then zflags = 0; /* test ops */  end;end zflchk; /* Code emission - emit subroutines:. .   The various emit routines are used to emit records to the formatted object.   code file.  There is one little routine for each type of record in the.   intermediate file.*/  /* Emit end of file marker: */  em.eof: proc; /* emit an EOF record */  call emit (et.eof); /* write out one word */end;  /* Emit literal data word or instruction:.    Passed the 16-bit word to emit. */  em.lit: proc(lw); /* emit a literal word */  dcl lw fixed;  if (lw and literal.mask) = 0 then call emit (et.lit); /* if not flagable, emit header */  call emit (lw);  cur.loc = cur.loc + 1;end em.lit;  /* Emit transfer (conditional) to key location:.    Passed bit encoded condition..    Passed key number, to be set up during pass3.*/  em.tra: proc(con, key); /* emit a transfer record */  dcl (con, key) fixed;  call emit (et.tra);  call emit (con);  call emit (key);  call emit (-1); /* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE) */  cur.loc = cur.loc + 2; /* assume two for transfer */end em.tra;  /* Emit transfer (conditional) to alternate key location:.    Passed bit encoded condition..    Passed key number, to be set up during pass3.*/  em.atr: proc(con, akey); /* emit a transfer record */  dcl (con, akey) fixed;  call emit (et.atr);  call emit (con);  call emit (akey);  call emit (-1); /* estimate location of key (previously CUR.LOC - mark inactive for pass3 OPTIMIZE) */  cur.loc = cur.loc + 2; /* assume two for transfer */end em.atr;/* Emit call to user procedure:.    Passed key which will point to routine during pass3..    Passed pointer to alias list for this call..    Passed length of alias list for this call.*/  em.cal: proc(key, ptr, len); /* emit a user procedure call record */  dcl (key, ptr, len) fixed;  call emit (et.cal); /* emit record type */  call emit (len + 1); /* emit record length */  call emit (key); /* emit key of proc we're calling */  do len = 0 to len - 1; /* emit alias list for this call */     call emit (aliases (ptr + len));  end;  cur.loc = cur.loc + 2; /* always 2 here */  if (prctyp < 2) and ((flags and module.flag) = 0) /* if model B and NOT in a module */  then zflags = 1; /* zflags equal ac0 after call */  else zflags = 0; /* zflags are garbage on Model C after call (also in modules so upwards compatible to Model C) */end em.cal;  /* Emit call to runtime package routine:.     Passed absolute location of run time routine in object file.*/  em.rtp: proc(rloc); /* emit an RTP call record */  dcl rloc fixed;  call emit (et.rtp);  call emit (rloc);  cur.loc = cur.loc + 2; /* always 2 here */  if (prctyp < 2) and ((flags and module.flag) = 0) /* if model B and NOT in a module */  then zflags = 1; /* zflags equal ac0 after call */  else zflags = 0; /* zflags are garbage on Model C after call (also in modules so upwards compatible to Model C) */end em.rtp;  /* Emit a pointer to a variable:.    Passed storage class of variable..    Passed the variable location, relative to the start of the.      as-yet-undetermined variable area..    Passed an ABLE destination (register, etc.) to send the.      absolute location to.*/  em.vpt: proc(class, vloc, des); /* emit variable pointer record */  dcl (class, vloc, des) fixed;  call emit (et.vpt);  call emit (des);       /* destination first */  call emit (class);     /* then storage class */  call emit (vloc);      /* finally the variable location */  cur.loc = cur.loc + 2; /* always 2 words here */  if class = s.automatic /* karim: this was the bug */  then des = b.ad + b.add + (des and b.amsk); /* convert destination to ADD instruction */  call zflchk (des);     /* record ZFLAGS if arith load */end em.vpt;  /* Emit a pointer to an object code location:.    Passed the key that will point to the object location during pass3.*/  em.opt: proc(key); /* emit object pointer record */  dcl key fixed;  call emit (et.opt);  call emit (key);  cur.loc = cur.loc + 1;end em.opt;  /* Emit a label definition record: .     Passed the key to assign location to during pass3.  The current.       location counter will be assigned to the specified key during.       the final object code location assignment. */  em.lde: proc(key); /* emit label definition record */  dcl key fixed;  call emit (et.lde);  call emit (key);end em.lde;em.ald: proc(akey); /* emit label definition record for alternate keys */  dcl akey fixed;  call emit (et.ald);  call emit (akey);end em.ald;/* Emit a data definition record:.    Passed key of declared data - the data immediately follows. */em.dat: proc(key); /* emit data definition record */   dcl key fixed; /* key of data definition */   call emit (et.dat); /* emit record type */   call emit (key); /* emit the key */   call emit (0); /* emit the SWAP flag (can't swap by default) */end em.dat;/* Emit copy data to object record:.    Passed number of words to copy to interfile2. */em.cpy: proc(len); /* emit copy data to object */   dcl len fixed; /* number of words to emit */   call emit (et.cpy); /* emit record type */   call emit (len); /* emit the length */   do len = 1 to len; /* emit the data */      call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.cpy;/* Emit copy scon to object record:.    Passed number of words to copy to interfile2. */em.scn: proc(len); /* emit copy scon to object */   dcl len fixed; /* number of words to emit */   call emit (et.scn); /* emit record type */   call emit (len); /* emit the length */   do len = 1 to len; /* emit the data */      call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.scn;/* Emit procedure definition:.    Passed procedure key..    Passed starting ram location..    Passed starting temp location..    Passed procedure attributes..    Passed number of register arguments. */em.pdf: proc(prockey, numargs, ramloc, temploc, attr, reg.arg); /* emit procedure definition */   dcl prockey fixed; /* procedure key         */   dcl numargs fixed; /* number of reg args total  */   dcl ramloc  fixed; /* starting ram location */   dcl temploc fixed; /* starting temp location */   dcl attr    fixed; /* procedure attributes */   dcl reg.arg fixed; /* number of register arguments for pass3 to store */   call em.tra (0, prockey + 1); /* emit jump around procedure body */   call em.lde (prockey); /* define location for procedure entry */   call emit (et.pdf); /* emit procedure definition type */   call emit (shl(numargs,8) + reg.arg + 4); /* emit record length, numargs in upper half */   call emit (prockey); /* emit key */   call emit (ramloc); /* emit starting ram location */   call emit (temploc); /* emit starting temporary location */   call emit (attr); /* emit procedure attributes */   /* register args are handled by whoever calls EM.PDF */end em.pdf;/* Emit end of procedure:.    Passed procedure key..    Passed ending ram location..    Passed ending temp location [offset into stack for temporaries (recursive procs only)].    Passed stack frame length..    Passed registers used by the procedure..    Passed NOSWAP bit list for data statements. */em.pen: proc(prockey, ramloc, temploc, stack_len, regs, dswp); /* emit end of procedure */   dcl prockey   fixed; /* procedure key */   dcl ramloc    fixed; /* ending ram location */   dcl temploc   fixed; /* ending temporary location (tempory offset for recursive procs) */   dcl stack_len fixed; /* length of stack frame */   dcl regs      fixed; /* registers used by procedure */   dcl dswp      fixed; /* NOSWAP bit list for data */   call emit (et.pen); /* emit end of procedure type */   call emit (prockey); /* emit procedure key */   call emit (ramloc); /* emit ending ram location */   call emit (temploc); /* emit ending temp location (or temp offset) */   call emit (stack_len); /* emit stack length */   call emit (regs); /* emit registers used map */   call emit (dswp); /* emit NOSWAP bit list for data */   call em.lde (prockey + 1); /* emit label definition for jump around */end em.pen;/* Emit when statement definition:.    Passed procedure key. */em.whn: proc(prockey); /* emit when statement definition */   dcl prockey fixed; /* procedure key */   call em.tra (0, prockey + 1); /* emit jump around when body */   call em.lde (prockey); /* emit label definition for when body entry */   call emit (et.whn); /* emit when statement type */   call emit (prockey); /* emit its key */end em.whn;/* Emit end of when statement:.    Passed procedure key..    Passed registers used by the when body. */em.wen: proc(prockey, regs); /* emit end of when statement */   dcl prockey fixed; /* procedure key */   dcl regs    fixed; /* registers used by when */   call em.lde (prockey + 2); /* emit label definition for return location */   call emit (et.wen); /* emit end of when type */   call emit (prockey); /* emit key */   call emit (regs); /* emit regs used */   call em.lde (prockey + 1); /* emit label definition for jump around */end em.wen;/* Emit string constant pointer:.     Passed string location..     Passed destination. */em.spt: proc(sloc, des); /* emit string constant/data pointer */  dcl (sloc, des) fixed;  call emit (et.spt);  call emit (des);  call emit (sloc);  call emit (0); /* doesn't swap */  cur.loc = cur.loc + 2;  call zflchk (des); /* record zflags if arith load */end em.spt;/* Emit addr of fixed array:.    Passed key of defining procedure..    Passed formal parameter number. */em.adr: proc(parm_key, parm); /* emit addr of fixed array */   dcl parm_key fixed; /* key of defining procedure */   dcl parm     fixed; /* formal parameter number in that procedure */   call emit (et.adr); /* emit record type */   call emit (parm_key); /* followed by the key */   call emit (parm); /* and the parameter number */end em.adr;/* Emit sequence number:.    Passed sequence number. */em.seq: proc(snum); /* emit sequence number */   dcl snum fixed; /* the sequence number to emit */   call emit (et.seq); /* emit the record type */   call emit (snum); /* and the sequence number */end em.seq;/* Emit symref (global reference) or symdef (global definition):.    Passed number of words to copy to interfile2. */em.sym: proc(len); /* emit symref or symdef */   dcl len fixed; /* number of words to emit */   call emit (et.sym); /* emit the symref/symdef header */   call emit (len); /* emit length */   do len = 1 to (len and "377"); /* emit len words */      call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.sym;/* Emit module name:.    Passed number of words to copy to interfile2. */em.mod: proc(len); /* emit module name */   dcl len fixed; /* number of words to emit */   call emit (et.mod); /* emit the module header */   call emit (len); /* emit length */   do len = 1 to (len and "377"); /* emit len words */      call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.mod;/* Emit library reference:.    Passed number of words to copy to interfile2. */em.lib: proc(len); /* emit library reference */   dcl len fixed; /* number of words to emit */   call emit (et.lib); /* emit the library header */   call emit (len); /* emit length */   do len = 1 to (len and "377"); /* emit len words */      call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.lib;/* Emit insert filename record:.    Passed number of words to copy to interfile2. */em.ins: proc(len); /* emit insert filename */   dcl len fixed; /* number of words to emit */   call emit (et.ins); /* emit the insert header */   call emit (len); /* emit length */   do len = 1 to (len and "377"); /* emit len words */         call emit (gc); /* copy directly from interfile1 to interfile2 */   end;end em.ins;/* Emit library definition record: (only for MAIN).    Passed library number. */em.ldf: proc(lib); /* emit library definition to IF */   dcl lib fixed; /* the number of the library we're about to append to the IF */   call emit (et.ldf); /* write out the record type */   call emit (lib); /* and the library number */end em.ldf;  /* Emit a record to construct code for a 'Do Case' construct: */em.cas: proc;  call emit (et.cas);  cur.loc = cur.loc + 3;end em.cas;/* The following procedures assist in the object code emission.   process.  They perform standard shifts, constant field tests,.   and other standard items. */  /* Emit a (source, destination) instruction:.    Passed source..    Passed destination. */  emita: proc(sou, des);  /* emit a (source, destination) instruction */  dcl (sou, des) fixed;  call em.lit (shl(des, 8) + sou);  call zflchk (des);    /* record it if dest effects zflags */end emita;  /* Test if a constant will fit in the constant (6-bit) field:.    Passed the constant to test..    Returns TRUE (1) if it fits, FALSE (0) if it don't. */  emitt: proc(n) fixed; /* test if N is a constant that will fit into immediate field */  dcl n fixed;  if (((n and "177740") = "177740") or ((n and "177740") = "000000"))  then return 1; /* return true if does fit */  else return 0; /* false if it don't */end emitt;  /* Emit a constant to a destination:.     Passed the constant (value)..     Passed the destination...     This routine will compact the constant into a single instruction.       if it will fit (6-bits). */  emitc: proc(valu, dest); /* send a known constant to destination */  dcl (valu, dest) fixed;  if emitt (valu) /* will fit into immed field? */  then call emita (b.is + (valu and b.imsk), dest); /* immed to destination */  else begin; /* full word */    call emita (b.ms + b.ibt + b.pc, dest); /* pc and i to dest */    call em.lit (valu); /* ship out constant */  end; /* full word */end emitc; /* emit constant */