/* Statement scanner - DECLARE statement:.  .  The following routine processes the 'DECLARE' statement:..    declare (symb1, symb2, symb3) (subscript if needed) (attributes);..  All of the processing of the DECLARE statement is done during.  pass one.*/begin;dcl (symb, symb1, submax, type) fixed;dcl (snptr, pspt, aloc, atype)  fixed;dcl a.ptptr fixed; /* pointer to argument list for current procedure table entry */dcl delta   fixed; /* size of current procedure table entry */dcl numargs fixed; /* number of arguments to a forward reference procedure call */dcl r.type  fixed; /* returns type for a forward reference procedure call */dcl pub.ext fixed; /* public or external flag */dcl sclass  fixed; /* storage class */dcl p.lnum  fixed; /* line number for linker */dcl store   fixed; /* storage used by symbol */dcl recurs  fixed; /* TRUE if this is a forward reference recursive proc defn */dcl first   fixed; /* TRUE if this is the first time through the symbol processing loop */dcl i       fixed;dcl prctyp lit '(shr(com (l.ctab + 1), 8) and 7)';p.lnum = line.no; /* save line number in case linker needs it */ DCL.START:;pub.ext = 0; /* no publics or externals found yet */if (gflag (cur.proc.def) and p.recursive) <> 0 /* in a recursive procedure? */then sclass = s.automatic; /* yes, automatic variables by default */else sclass = s.static; /* no, static variables by default */ /* build up a queue of symbols declared in list */ if token = t.lpar then do; /* list of symbols to be declared */ symb = 0; /* initialize list of symbols */ token = t.comma; /* pretend it started with a comma */ do while token = t.comma; dcl.symbol = 1; /* we're scanning off a variable name in a DCL */ call scan; /* scan off the comma */ dcl.symbol = 0; /* done scanning declared variable name */if name.pt = 0 then call er.ifm;else do; symb1 = get; /* get a list element */ store2 (symb1) = name.pt; /* save pertinent info about symbol */ store3 (symb1) = hashcode; store1 (symb1) = 0; /* no forward pointer */ if symb = 0 then symb = symb1; /* for first one, stor here */ else store1 (type) = symb1; /* else link to end */ type = symb1; /* and save this pointer */end; call scan; /* scan off symbol */ end;if token <> t.rpar then call er.ifm; end;  /* Declaration statement (cont):.  .   If single symbol declaration (dcl xyz attributes subscript), then.   just scan the one symbol, queue it, and process the single-entry.   queue as normal.*/   else do; /* single symbol */if name.pt = 0 then do;   call er.ifm; symb = 0;end;else do; symb = get; /* get a single block */ store1 (symb) = 0; /* zero link (end of list) */ store2 (symb) = name.pt; /* and store pertinent information about the symbol */ store3 (symb) = hashcode;end;end;  call scan; /* scan over close paren or single symbol */  /* now scan off subscript (if one) */  if token = t.lpar then do;subscr = 1; /* initialize */submax = get.const (t.var) + 1; /* get fixed point subscript */ end; else subscr = 0; /* no subscript provided */ /* Declaration statement (continued):..   Get type of symbol. */stype = t.var; /* assume fixed for data types */if (token = t.stmt) and (info = s.proc) then do; /* detect 'dcl xyz procedure' */  if subscr then call er.sna; /* no subscripts allowed in procedure definitions */  a.ptptr = ptptr + p.parm; /* point to start of argument list in procedure table */  numargs = 0; /* no arguments scanned yet */  r.type = t.var; /* default returns type */  call scan; /* scan off the next token */  if token = t.lpar then do; /* argument list? */     token = t.comma; /* pretend we found a comma */     do while (token = t.comma); /* scan off the args */        call scan; /* get first argument type */        numargs = numargs + 1; /* count arguments */        if token <> t.type then call er.ifm; /* check type */        type = info; /* remember what kind of argument it is */        call scan; /* get next token */        if ((token = t.type) and (info = t.arr)) then do; /* array */           if type = t.arr then call er.ifm;           type = (type or t.arr); /* remember it's an array */           call scan; /* get the next token */        end;        if a.ptptr - 2 ilt stptr then call er.nst; /* overflow */        call set_stable (a.ptptr + p.ptyp, type or t.pvar); /* save type (OR in pointer bit for effect) */        a.ptptr = a.ptptr - 2; /* point to the next entry */     end;     if token <> t.rpar then call er.ifm; /* must end with a right paren */     call scan; /* get next token */  end;  if token = t.rtns then do; /* PL/I style RETURNS? */     call scan; /* scan off left paren */     if token <> t.lpar then call er.ifm;     call scan; /* scan off type field */     if ((token <> t.type) or ((info <> t.var) and (info <> t.fvar))) /* if not FIXED or FLOATING */     then call er.iptd;     else r.type = info;     call scan; /* scan off right paren */     if token <> t.rpar then call er.ifm;     call scan; /* get next token */  end;  type = t.pvar; /* remember this is a forward reference proc */  delta = a.ptptr - ptptr; /* get size of current procedure table entry */end;else do; /* not a forward reference procedure */  if token <> t.type then do;     call er.ifm; info = 0;   end;  type = info; call scan; /* save type and skip */if type <= t.fvar then do; /* fixed, floating, or array (plain array means fixed array */  if subscr then type = (type or t.arr); /* any thing with subscript means array */  if token = t.type then do; /* check further - fixed data, fixed array, etc. */    if info = t.arr then do; /* array */       if subscr then call er.sna; /* no subscript allowed */       type = (type or t.arr); /* make it an array */       call scan;    end; /* array */    else if info = 7 then do; /* DATA type? */       stype = (type and t.fvar); /* set up STYPE */       type = info; /* set type to DATA */       call scan;    end;  end;end; end;if token = t.storage then do; /* check for public or external */   if ((info = t.public) or (info = t.extern)) then do; /* public or external? */      pub.ext = info; /* save value */      sclass = s.static; /* MUST be static */      if ((info = t.extern) and subscr) then call er.sna; /* subscripts not allowed with externals */   end;   else if ((info = s.static) or (info = s.automatic)) then do; /* static or automatic? */      sclass = info; /* save storage class */      if type > t.farr then call er.iptd; /* only allowed for variables */      if ((info = s.automatic) and ((cur.proc.def = -1) or (cur.proc.def = -2))) /* if at top level or in WHEN */      then call er.iptd; /* no AUTOs outside procs */   end;   else call er.ifm; /* no, illegal format */   call scan; /* scan off token */end;if type = t.pvar then do; /* forward reference procedure? */   if token = t.recurs /* if it's recursive */   then do; /* remember it */      recurs = 1; /* like so */      if numargs > max_recurs_parms then call er.tma; /* check limit */      if pub.ext = t.extern then do; /* if external */         call er.iptd; /* no go */         recurs = 0; /* the precompiled module decides the recursion, not us */      end;      call scan; /* scan to next token */   end;   else recurs = 0; /* not recursive */end; /* of forward reference procedure? *//* process each scanned symbol: */first = 1; /* this is the first time through this loop */do while symb <> 0; loc.block = symb; /* get pointer to block for current symbol */ symb = store1 (symb); /* unlink it */ snptr = s.define (store2 (loc.block), store3 (loc.block)); /* define label, get symbol ptr */ call rel (loc.block); /* release list element */ ptype = gtok (snptr); /* get current type - should be T.UND or T.UNDA */  /* Statement scanner - DECLARATION statement (cont):.  .  .   Procedure argument declarations:.  .   The symbols that correspond to procedure arguments are entered.   in the symbol table during the processing of the 'PROCEDURE'.   statement.  At that time, however, no information about the.   type of symbol or the amount of storage required for it, or the.   type of store instruction to perform, is available..  .   Information is written to the intermediate file that allows the.   second and third passes of the compiler to generate the proper.   store instructions..  .   For undeclared procedure arguments,  we start with:.     type in symbol block = T.UNDA.     info in symbol block = pointer to S.STACK location (below).  .     S.STACK (INFO) = T.UNDA.     S.STACK (INFO + 1) = key number that is used to define symbol with..   For forward reference procedures, the argument type is already in.   the procedure table and better match what we find in the declare.   statement.  Other procedures have an argument type of T.UNDA in.   the procedure table.*/  if ptype = t.unda then do; /* symbol is an undeclared procedure argument */if type > t.farr then do; call er.ifm; type = 0; end;if ((((gflag (cur.proc.def) and p.recursive) = 0) and (sclass <> s.static)) /* if storage class specified and wrong */or (((gflag (cur.proc.def) and p.recursive) <> 0) and (sclass <> s.automatic))) then call er.iptd;pspt = stable (snptr + s.locn); /* get pointer into stack here */atype = (type or t.pvar); /* or in pointer bit for effect */if (stable (pspt + p.ptyp) and "377") <> t.unda /* is the argument type T.UNDA in the procedure table? */then do; /* no, this means this was a forward reference procedure */   if atype <> (stable (pspt + p.ptyp) and "377") /* does this type match that previously defined? */   then call er.atm; /* argument type mismatch - complain */end;call set_stable (pspt + p.ptyp, atype); /* save defined type of argument in procedure info table */call set_stable (snptr + s.locn, stable (pspt + p.ploc)); /* thru with ptr info; replace with variable location */call ptok (snptr, atype); /* and store new type in symbol table */call pclas (snptr, sclass); /* save storage class */if pub.ext <> 0 then call er.iptd; /* arguments can't be external or public */if subscr then call er.sna;subscr = 0; /* in case there */end; /* of undeclared procedure argument */  /* Statement scanner - DECLARATION statement (cont): .  .   The following code precesses the declarations of new symbols.   (i.e. those symbols that are not undeclared procedure arguments)..  .   Branch on type of declaration and adjust symbol table/data.   area accordingly.*/  else if ptype <> t.und then call er.lt (snptr);else do; /* ptype = T.UND := new symbol */if pub.ext = t.extern then store = 0; /* no storage used by externals */do case (type); /* break up cases */   do; /* fixed variable */      call ptok (snptr, t.var); /* save new token in symbol table */      store = 1; /* need one word */   end;      do; /* fixed array */      call ptok (snptr, t.arr); /* save new token in symbol table */      store = submax; /* need SUBMAX words */      if ((pub.ext <> t.extern) and (not subscr)) then call er.ifm; /* ARRAY with no subscript (better to check above, but can't) */   end;        do; /* floating variable */      call ptok (snptr, t.fvar); /* save new token in symbol table */      store = 2; /* need two words */   end;        do; /* floating array */      call ptok (snptr, t.farr); /* save new token in symbol table */      store = shl(submax, 1); /* need 2*SUBMAX words */      if ((pub.ext <> t.extern) and (not subscr)) then call er.ifm; /* ARRAY with no subscript (better to check above, but can't) */   end;        do; /* forward reference proc call */      if a.ptptr ilt stptr then call er.nst; /* overflow */      call ptok (snptr, t.proc); /* define as proc here */      if pub.ext = t.extern /* external? */      then do; /* yes, flag it */         call set_stable (ptptr + p.key, get_extloc); /* get a unique pointer */         if (stable (ptptr + p.key) and "1") = 0 /* is it odd (i.e., defined)? */         then call set_stable (ptptr + p.key, get_extloc); /* no, make it odd so the defined bit is set */      end;      else do; /* no, allocate keys for it */         if pub.ext = t.public then call er.ifm; /* this isn't legal */         call set_stable (ptptr + p.key, shl(gkey, 1)); /* get key, store in table */         nexkey = nexkey + proc_keys; /* reserve enough keys for PROC */         store = proc_keys + 1; /* number of keys used */         if (recurs and (recurs.parms = 0)) then do; /* set up canonical storage for passing parameters to recursive procs */            if mod.scanned then do; /* in a module */               recurs.parms = get_extloc; /* make it external */               do i = 1 to max_recurs_parms - 1; /* get a whole block of them */                  call get_extloc;               end;            end; /* of in module */            else do; /* in MAIN program, allocate out of the variable area */               recurs.parms = ram; /* set the starting location */               ram = ram + max_recurs_parms; /* allocate the ram */            end; /* of in MAIN */         end; /* of set up canonical storage for recursive procs */      end;      a.ptptr = a.ptptr + numargs + numargs; /* point back to start of argument list */      do i = 1 to numargs; /* assign argument locations */         if pub.ext = t.extern /* external? */         then call set_stable (a.ptptr + p.ploc, get_extloc); /* yes, assign external locs so they're relocated in pass3 (Warning: pass3 assumes consecutive locs that immediately follow proc key) */         else do; /* no, assign ram */            if recurs /* recursive proc? */            then call set_stable (a.ptptr + p.ploc, recurs.parms + i - 1); /* yes, allocate from canonical */            else do; /* no, allocate from ram */               call set_stable (a.ptptr + p.ploc, ram); /* assign the current ram position */               ram = ram + 1; /* we've used one more word */            end;         end; /* of assign ram */         if not first /* if this isn't the first symbol processed in the loop */         then call set_stable (a.ptptr + p.ptyp, stable (a.ptptr + p.ptyp - delta)); /* copy type information from previous entry */         a.ptptr = a.ptptr - 2; /* point to next argument */      end;      call set_stable (ptptr + p.args, numargs); /* takes NUMARGS arguments */      call set_stable (ptptr + p.rtyp, r.type); /* and returns R.TYPE */      call set_stable (snptr + s.locn, ptptr); /* save pointer to data area */      call pflag (ptptr, p.swap); /* assume procedure swaps */      if recurs then call pflag (ptptr, gflag (ptptr) or p.recursive); /* set recursive flag */      ptptr = a.ptptr; /* point to the end of this procedure table entry */      a.ptptr = a.ptptr + delta; /* and point to the end of the next entry (in case there is one) */   end;       do; /* statement label */      if subscr then call er.sna; /* no subscripts allowed here */      call ptok (snptr, t.label); /* indicate a label */      if pub.ext = t.extern /* external? */      then do; /* yes, flag it */         call set_stable (snptr + s.locn, get_extloc); /* yes, flag it */         if (stable (snptr + s.locn) and "1") = 0 /* is the value odd? */         then call set_stable (snptr + s.locn, get_extloc); /* no, get an odd value so the defined bit is set */      end;      else do; /* no, allocate a key for it */         call set_stable (snptr + s.locn, shl(gkey, 1)); /* and get key */         store = 1; /* number of keys used */      end;   end;        do; /* literal declarations */      if subscr then call er.sna; /* no subscripts allowed here */      call ptok (snptr, t.lit); /* indicate a literal */      if token <> t.sconst then call er.ifm;      if pub.ext <> 0      then call er.ifm; /* literals are compile-time */      d1 = shr(name (0) + 3, 1); /* get number of words, including byte count */      if stptr + d1 igt ptptr then call er.nst;      do d2 = 0 to d1 - 1; call set_stable (stptr + d2, name (d2)); end; /* copy literal string into data area */      call set_stable (snptr + s.locn, stptr); /* save pointer to characters in table */      stptr = stptr + d1; /* and this much longer */      call scan; /* skip over string constant */   end; /* of handling literal declaration */  /* Statement scanner - DECLARATION statement (cont):.  .   The following code processes the data type of a variable:.  .      dcl xyz data (a, b, c, d);.   or dcl xyz data ('string');.  .   Since the data list is allowed to extend over many source lines, .   it is directly copied from the source file to the object file.   so there is no maximum length associated with the data type of variable..  .   Scan the data and write same to object file:*/  do; /* type 'DATA' */  if subscr then call er.sna; /* subscripts not allowed */  call ptok (snptr, (t.data or stype)); /* set type of data for future use */  if pub.ext = t.extern /* external has no data */  then call set_stable (snptr + s.locn, get_extloc); /* get marker to put into interfile */  else do; /* not an external */     call pdkey (snptr, data_key); /* store data key for this data statement */     call emit (shl(s.declare, 8) or t.stmt); /* emit a declare data record */     call emit (t.data or stype); /* tag it as being data */     call emit (data_key); /* and emit the key */     if data_key < 255 then data_key = data_key + 1; /* assign a new key */     if token <> t.lpar then call er.ifm; /* must be lpar */     call scan;     if token = t.sconst then do; /* dcl a data ('abcdefghj'); */       call set_stable (snptr + s.locn, e.scondata); /* emit string constant, store pointer */       call scan; /* skip it */     end;     else do; /* list of numbers */     store = 0; /* # */     dbufp = 0; /* and initialize buffer pointer */     call set_stable (snptr + s.locn, str.data); /* set up pointer to where data starts */     do while token <> t.rpar; /* until end */       sinfo = get.const (stype); /* get data - fixed or floating constant */       if stype = t.var then call dbufemit (sinfo); /* there it is */       else do; /* floating data */         call dbufemit (fstk (sinfo));         call dbufemit (fstk (sinfo + 1));         fstk (sinfo) = "100000"; /* and free up */         store = store + 1; /* plus two words for floating data */       end;       store = store + 1; /* one word for each additional */       if token = t.comma then call scan;       else if token <> t.rpar then do; /* error */         call er.ifm; token = t.rpar;       end;     end;     call dbuffrc; /* and force out data if any */     end; /* of numbers */     if token <> t.rpar then call er.ifm; /* error */     call scan;  end; /* of not external */end; /* of type data */  end; /* of case statement */if type <= t.farr then do; /* if storage declared, allocate it */   call pclas (snptr, sclass); /* save storage class */   if pub.ext = t.extern /* external? */   then call set_stable (snptr + s.locn, get_extloc); /* yes, flag it */   else do case (sclass); /* no, allocate storage by class */      do; /* static storage */         call set_stable (snptr + s.locn, ram); /* located at RAM */         if ram + store ile ram then call er.ptl; /* check for overflow */         ram = ram + store;      end;      do; /* automatic storage */         call set_stable (snptr + s.locn, stack_length + 1); /* located at STACK_LENGTH */         if stack_length + store ile stack_length then call er.ptl; /* check for overflow */         stack_length = stack_length + store;      end;   end; /* of storage class */end; /* of allocating storage */ /* define a symref or symdef record if external or public */ if pub.ext <> 0 /* emit symbols for symbol table in linker */ then call pub.ext.def (snptr, pub.ext, store, p.lnum); if pub.ext = t.public then do; /* check that a public variable is not in a procedure */    if mod.scanned then do; /* if we're in a module */       if s.depth - in.begin <> 2 /* are we at MODULE's outer level (ignoring BEGINs)? */       then call wa.pdip; /* public definition not allowed */    end;    else do;       if s.depth - in.begin <> 1 /* are we at outer level (ignoring BEGINs)? */       then call wa.pdip; /* no, warn the user */    end; end;end; /* of handling a non-T.UNDA symbol */  first = 0; /* done with first loop */ end; /* of do loop */ if token = t.comma then do; /* multiple declarations */    dcl.symbol = 1; /* we're scanning off a variable name in a DCL */    call scan; /* scan over comma */    dcl.symbol = 0; /* done scanning declared variable name */    goto DCL.START; /* go back for some more */ end;  end; /* declare statement */