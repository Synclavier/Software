/* Software multiply/divide: */dcl brtab1 data (1, 0, 1, 0, 2); /* div times mod fmu fdi */dcl rtab   data (b.ac1, b.ac1, b.ac0, b.ac0, b.ac1); /* result */if reg2 <> 0 then reg2 = in.reg (arg2, not b.ac2); /* move ARG2 to AC2 here */do case (brtab1 (opr - o.div)); /* branch onto type */do; /* multiply, fractional multiply */  reg1 = in.reg (arg1, not b.ac1);  reg2 = in.reg (arg2, not b.ac2);  call reg.allc (not b.ac0); call reg.allc (not b.ac3); /* other regs */  call em.rtp (l.fmu); /* perform fixed point multiply */  reg.free = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* all free - answer masked below */  if tree = divarg then do; /* save AC0 for later divide */    upperblock = x.get; /* allocate block */    x.node (upperblock) = x.reg; x.arg1 (upperblock) = t.var;    x.info (upperblock) = b.ac0; /* save here */    reg.cont (b.ac0) = upperblock; /* for stuffing into temp */    reg.free = (reg.free and (not b.ac0)); /* AC0 no longer free */  end;end; /* of mul/div */do; /* divide and mod */  if arg1 = divarg then do; /* this is result of multiply */    call in.reg (upperblock, not b.ac0); /* get upper word */    reg1 = in.reg (arg1, not b.ac1); /* and lsb */    call x.rel (upperblock); /* done with upperblock */    upperblock = 0;  end;  else do; /* must get arg1 in register */    if reg1 = b.ac0 then reg1 = in.reg (arg1, not b.ac1); /* move AC0 to AC1 if shd */    call reg.allc (not b.ac0); /* get AC0 free for sign extension */    call emitc (0, b.rd); /* zero out AC0 */    call freeup (b.ac0); /* AC0 is now clobbered */    reg1 = in.reg (arg1, not b.ac1); /* get second arg here */    if zflags <> b.ac1 then call emitc (0, b.ad + b.add + 1); /* set signs */    call emitc (1, b.cr + b.tpl); /* if positive, uppers are zero */    call emitc (-1, b.ad + b.loa); /* else sign of all ones */  end;  reg2 = in.reg (arg2, not b.ac2); /* get ARG2 */  call reg.allc (not b.ac3); /* free up AC3 for divide */  call em.rtp (l.fdi); /* fixed division */  reg.free = b.ac0 or b.ac1 or b.ac2 or b.ac3; /* indicate all free */end;do; /* fractional divide */  reg1 = in.reg (arg1, not b.ac0);  reg2 = in.reg (arg2, not b.ac2);  call reg.allc (not b.ac1); call reg.allc (not b.ac3);  call emitc (0, b.ad + b.loa + 1);  call em.rtp (l.fdi); /* divide */  reg.free = (reg.free or b.ac0 or b.ac1 or b.ac2);end;end; /* of the do case */reg.d = rtab (opr - o.div); /* get register containing answer */call freeup (b.ac3);if reg.d = b.ac1 then call freeup (b.ac0);if reg.d = b.ac0 then call freeup (b.ac1); /* indicate clobbered by sub call */