/* $Dump statistics *//* Scientific XPL Compiler - Pass 3.  .    This program forms pass3 of the XPL compiler.   This program.    iteratively reads through the output file generated by pass2,.    computes the locations of all instructions to be generated,.    compacts as many instructions as possible into one word,.    optimizes jumps and subroutine calls, deletes 'dead' code,.    and then emits the code.  If any libraries are referenced by.    the program, they are linked in during this pass...    Modification history:.      13 Oct 1983:  Recreated relocatable XPL [KJC].      10 Feb 1984:  Cleaned up symbol table output [KJC].      20 Feb 1984:  Added insert statements to sequence table output [KJC].      29 Feb 1984:  Added support for true recursion [KJC].       1 May 1984:  Made OPTIMIZE toss out DO-loops in conditional DO-blocks [KJC & CWJ].      20 Jul 1984:  Fixed OPTIMIZE so it didn't toss out GOTO's [KJC].       7 Sep 1984:  Fixed OPTIMIZE so it truly does a dead code analysis [KJC & CWJ].      17 Sep 1984:  Added overlays (swappable procs) [KJC].      29 Oct 1984:  Cleaned up overlays [KJC].       7 Nov 1984:  Fixed a jump-to-jump deletion bug in OPTIMIZE [KJC & CWJ].      20 Dec 1984:  Changed offset table emission in OPTIMIZE to make offsets absolute [KJC].      27 Dec 1984:  Shrink out scon/data and temps from uncalled procs [KJC].      26 Mar 1985:  Fixed a swap table backpatch bug in FINISH [KJC].      27 Jul 1985:  Changed structure of linked programs so MAIN is first [KJC].      29 Jul 1985:  Moved swap table to ext mem and allocate key tables from ext mem [KJC].       1 Aug 1985:  Dynamically allocate RTP buffer and moved key flags from KEYJTO to KEYFLAG [KJC].      16 Aug 1985:  Added swapping of SCON [KJC].      24 Oct 1985:  Added user device drivers through READDATA/WRITEDATA [KJC].       3 Feb 1986:  Added swapping of data statements in swappable procs [KJC].      20 Feb 1986:  Added user device types for FIND_DEVICE [KJC].      30 Apr 1986:  Moved symbol table to external memory [CWJ].      15 Oct 1986:  Updated for -7 catalog structure [KJC].       5 Nov 1986:  Changed RECURSIVE procs to calculate variable pointers [KJC].       9 Nov 1986:  Defined and fully supported storage classes [KJC].      17 Feb 1987:  Numerous changes to speed up pass3 [KJC].         Sep 1988:  AG, CJ - Model D processor,  object code optimizing,.         Oct 1990:  CJ - coded alternate keys*/  configuration modelD, nomuldiv; /* to get some speed out of this */pdl 256;insert ':xpl611:defs'; 		/* general definitions */insert ':xpl611:p3-defs'; 	/* pass3 definitions */insert ':xpl611:p23-defs'; 	/* pass2 and pass3 specific definitions */insert ':xpl611:overlay'; 	/* get overlay and open routines */when break then call exit(-1); /* exit if user wants during terminal output */pass3: proc(ifbuf, ifbufl, rfbuf, rfbufl, objdev, objstart, objslen, objlength) fixed; /* create object file */   dcl ifbuf     fixed array; /* IF buffer */   dcl ifbufl    fixed; /* IF buffer length */   dcl rfbuf     fixed array; /* RTP buffer */   dcl rfbufl    fixed; /* RTP buffer length */   dcl objdev    fixed array; /* device of object file (returned value) */   dcl objstart  fixed array; /* starting sector of object file (returned value) */   dcl objslen   fixed array; /* final sector length of object file (returned value) */   dcl objlength fixed array; /* final word length of object file (returned value) */   dcl debug_on  fixed;       /* TRUE if we produce best code for debug */   insert ':xpl611:p3-1';   insert ':xpl611:p3-2';   insert ':xpl611:p3-3';   insert ':xpl611:p3-4';   insert ':xpl611:p3-5';   insert ':xpl611:p3-6';   dcl loc_ref.ptr   fixed; /* pointer to LOC_REF */   dcl scon.ptr      fixed; /* pointer to SCON */   dcl system.device fixed; /* previous system device */   dcl mem_end       fixed; /* end of internal memory */   dcl mem_required  fixed; /* memory required for KEYLOC and KEYJTO */   dcl ext_required  fixed; /* memory required in sectors            */   dcl mem_available fixed; /* memory available for KEYLOC and KEYJTO */   dcl ext_available fixed; /* amount of external memory available (sectors) */   dcl available     fixed; /* external memory available for STABLE/internal memory available above IFBUF */   dcl skip_dca      fixed; /* TRUE if we should skip dead code analysis */   dcl force_swap    fixed; /* TRUE if all procs should be swapcoded     */   dcl (i,j,k,l)     fixed;   call init; /* initialize */   mem_end = loc.load; /* end of memory is at overlay routine */   mem_available = mem_end - addr(ifbuf (0)) - ifbufl_min; /* total memory available */   ext_available = core(loc.emsize);    /* number of sectors available in external memory */   i = mem_available * 4 / 9;           /* get keys available (total)     */   j = shr(r(l.key   ), 2);             /* get 1/4 keys needed            */   k = shr(r(l.altkey), 2);             /* 1/4 alt keys needed            */   l = j + k;                           /* get 1/4 of total               */   if (j = 0) or (k = 0)                /* if basically no keys ...       */   then do;                             /* divide up memory 50:50         */      max_keys = shr(i,1);      max_alts = shr(i,1);   end;   else do;                             /* else compute according to      */      max_keys = i * j / l;             /* ratio needed by program        */      max_alts = i * k / l;   end;   if (r (l.flags) and module.flag) <> 0 /* if we're processing a module */   then objlength (0) = create_reloc; /* create a relocatable binary */   else do; /* otherwise create an object */      if core(loc.rst) = 0 /* is this a RUN? */      then r (l.flags) = (r (l.flags) and (not symtab.flag)); /* yes, don't output symbol table */      if (r (l.flags) and link.flag) <> 0 /* is there a library statement and/or external definition present? */      then do; /* yes, link in any modules */         if not (((ifsec = 0) and (ifpos = 256)) or ((ifsec = 1) and (ifpos = 0))) /* are we at the start of the IF? (MUST check before resizing IFBUF) */         then call er.sys ('intermediate file not reset before LINK', 'pass3');         if ext_available <> 0 then do; /* if external memory available for linker symbol table */            stxmem = 1; /* symbol table is in external memory */            stable.ptr = 9*((ext_available*key_ratio + 8)/9); /* point to sector start of symbol table (round up key allocation) */            available = most_symbols; /* move constant to variable: XPL bug w/constant times/divide */            available = available*stentry_size/256; /* set to sectors needed (32-bit mult) */            if available igt ext_available - stable.ptr /* available = min(secs_avail, secs_needed); */            then available = ext_available - stable.ptr; /* set to sectors available */            max_symbols = (available + stable_round)/stentry_size; /* determine maximum number of symbols w/round up */            stable_size = available - max_symbols*(stentry_size - symbol_length); /* calculate size of symbol table; make up rounding/truncation here */            call setup_linker (max_symbols, stable_size); /* set up linker symbol table */            call set_extmem (stable.ptr, sort_sym.ptr + max_symbols, 0); /* zero out arrays */            max_symbols = shl(max_symbols, 8); /* convert from sectors to actual number */            if stable_size > 255 /* too many sectors? */            then stable_size = 65535; /* limit to 65535 words */            else stable_size = shl(stable_size, 8); /* convert from sectors to words */            loc_ref.ptr = addr(ifbuf (0)) + ifbufl; /* start this buffer after IFBUF */            max_refs = mem_end - loc_ref.ptr - 1; /* determine its maximum size */            ext_available = stable.ptr;           /* now this much is left */         end; /* of external memory */         else do; /* internal memory symbol table */            max_symbols = total_symbols; /* room for this many symbols */            stable_size = total_symbols*symbol_length; /* calculate size of symbol table */            if total_symbols*stentry_size igt mem_available /* if not enough room */            then call er.ftl ('Not enough memory for linker symbol table');            stable.ptr = mem_end - total_symbols*stentry_size; /* calculate start of linker symbol table */            mem_end = stable.ptr; /* memory now ends here */            mem_available = mem_available - total_symbols*stentry_size; /* subtract from memory available */            call setup_linker (max_symbols, stable_size); /* set up linker tables */            max_refs = -extern.base; /* 64K - EXTERN.BASE = -EXTERN.BASE */            if max_refs igt mem_available then max_refs = mem_available; /* max_refs = min(mem_avail, 64K-extern.base); */            loc_ref.ptr = stable.ptr - max_refs; /* start this buffer before STABLE */            if loc_ref.ptr ilt addr(ifbuf (ifbufl)) then do; /* shorten IFBUF if necessary */               i = ((loc_ref.ptr - addr(ifbuf (0))) and "177400"); /* reduce the size of IFBUF (to nearest sector) */               call blockset (loc(addr(ifbuf (i))), ifbufl - i, 0); /* zero it out */               ifbufl = i; /* shrink the IF buffer */            end;         end; /* of internal memory symbol table */         call link (loc(loc_ref.ptr)); /* link in any modules */         call blockset (loc(loc_ref.ptr), max_refs, 0); /* reinitialize memory */      end; /* of link in any modules */      if not (((ifsec = 0) and (ifpos = 256)) or ((ifsec = 1) and (ifpos = 0))) /* are we at the start of the IF? (MUST check before resizing IFBUF) */      then call er.sys ('intermediate file not reset before OPTIMIZE', 'pass3');      ext_required = 6                           /* compute memory needed */                     + (2*shr(r(l.key   ), 8))   /* for tables, in        */                     + (  shr(r(l.key   ),10))   /* sectors, rounded      */                     + (2*shr(r(l.altkey), 8))   /* up.                   */                     + (  shr(r(l.altkey),10));      if ext_required > 255      then mem_required = 65535;      else mem_required = shl(ext_required, 8);      available = mem_end - addr(ifbuf (0)) - ifbufl; /* memory currently available */      if  (prctyp >= 3)           /* IF COMPILING FOR MODEL D  */      and (ext_available igt (shr(2*swinfo.max,8)))   /* and enough external memory avail for swinfo table */      then do;                    /* get xmem for swinfo.ptr   */         swinfo.ptr = ext_available - shr(2*swinfo.max,8);         ext_available = swinfo.ptr;         call extset (swinfo.ptr, 0, 2*swinfo.max, 0); /* zero it out */      end;      if mem_required igt available then do; /* if not enough memory */         if ext_available ige ext_required then do; /* if there's external memory available */            xmem = 1; /* use external memory */            keyloc.ptr  = 0; /* put KEYLOC at the start of external memory */            keyjto.ptr  = keyloc.ptr  + shr(r (l.key   ),  8) + 1; /* put KEYJTO after KEYLOC   */            keyflag.ptr = keyjto.ptr  + shr(r (l.key   ),  8) + 1; /* put KEYFLAG after KEYJTO  */            altloc.ptr  = keyflag.ptr + shr(r (l.key   ), 10) + 1; /* put ALTLOC  after KEYFLAG */            altjto.ptr  = altloc.ptr  + shr(r (l.altkey),  8) + 1;            altflag.ptr = altjto.ptr  + shr(r (l.altkey),  8) + 1;            i = ext_available * 4 / 9;     /* get keys available (total)  */            j = shr(r(l.key   ), 2);       /* get 1/4 keys needed         */            k = shr(r(l.altkey), 2);       /* 1/4 alt keys needed         */            l = j + k;                     /* get 1/4 of total            */            if (j = 0) or (k = 0)          /* if basically no keys ...    */            then do;                       /* divide up memory 50:50      */               max_keys = shr(i,1);               max_alts = shr(i,1);        /* actually sectors at this pt */            end;            else do;                       /* else compute according to   */               max_keys = i * j / l;       /* ratio needed by program     */               max_alts = i * k / l;            end;            if max_keys >= 256             /* now get in words            */            then max_keys = 65535;            else max_keys = shl(max_keys, 8);            if max_alts >= 256            then max_alts = 65535;            else max_alts = shl(max_alts, 8);            call set_extmem (0, altflag.ptr + shr(r (l.altkey), 10) + 1, 0); /* zero out what we need */            ext_available = 0; /* no more available, since keyloc.ptr starts at 0 */         end; /* end of use external memory */         else if mem_required ile mem_available then do; /* can we allocate more space? */            i = ((ifbufl - (mem_required - available)) and "177400"); /* yes, reduce the size of IFBUF (to nearest sector) */            call blockset (loc(addr(ifbuf (i))), ifbufl - i, 0); /* zero out what we just released */            ifbufl = i; /* actually shrink the buffer here */            available = mem_required; /* at this point we have exactly what we need */         end; /* of allocating more space */         else call er.ftl ('Program too large for compilation (too many keys)');      end; /* of not enough memory */      if xmem = 0 then do; /* if we haven't put these arrays in external memory */         keyflag.ptr = mem_end     - shr(r (l.key   ) + 3, 2) - 1; /* start KEYFLAG at end of memory */         keyjto.ptr  = keyflag.ptr -     r (l.key   )         - 1; /* start KEYJTO just before KEYFLAG */         keyloc.ptr  = keyjto.ptr  -     r (l.key   )         - 1; /* start KEYLOC just before KEYJTO */         altflag.ptr = keyloc.ptr  - shr(r (l.altkey) + 3, 2) - 1;         altjto.ptr  = altflag.ptr -     r (l.altkey)         - 1;         altloc.ptr  = altjto.ptr  -     r (l.altkey)         - 1;         mem_available = mem_available - mem_required; /* keep track of how much is left */         available     = available     - mem_required; /* keep track of how much is left w/out affecting IFBUF */      end;      skip_dca   = ((r (l.flags) and skip.flag ) <> 0); /* see if we should skip the dead code analysis */      force_swap = ((r (l.flags) and force.flag) <> 0); /* and/or force all procs to ext memory */      debug_on   = ((r (l.flags) and debug.flag) <> 0); /* and/or produce best code for debug   */      call init_rtp; /* copy lowcore to the object file */      call optimize (skip_dca, force_swap); /* optimize the code (and output string/data areas to object) */      call bindrtp; /* bind in the runtime package (OPENFILE is called here!) */      redirection_word = (outdev and "377"); /* set so com,p works */      if (r (l.flags) and symtab.flag) <> 0 /* does the user want a symbol table? */      then do; /* yes, see if it ought to be redirected */         redirect.symtab = locate (symbol_table, 1); /* attempt to open the symbol table file (on the user disk only) */         redirect.symtab = (redirect.symtab and ((f#ms_length <> 0) or (f#ls_length <> 0)) and (f#type = t#text)); /* redirect if the file exists (and is a text file) */         if redirect.symtab then do; /* set up file if redirecting */            sfdev = f#ms_sector; /* save device */            sfstart = f#ls_sector; /* save starting sector */            sfsecln = f#ls_length; /* save sector length (ignore F#MS_LENGTH - this is a TEXT file!) */            call writesym (0); call writesym (0); /* start the file with a null line number */         end;         if (r (l.flags) and link.flag) <> 0 /* only create symbol table if requested (and linking) */         then call gensym; /* generate and output the symbol table */      end;      if not (((ifsec = 0) and (ifpos = 256)) or ((ifsec = 1) and (ifpos = 0))) /* are we at the start of the IF? (MUST check before resizing IFBUF) */      then call er.sys ('intermediate file not reset before CREATE_OBJECT', 'pass3');      if swap_scon igt available then do; /* if not enough memory for swapping scon */         if swap_scon ile mem_available /* if we can allocate more space */         then ifbufl = ((ifbufl - (swap_scon - available)) and "177400"); /* yes, reduce the size of IFBUF (to nearest sector) */         else call er.ftl ('Program too large for compilation (too much swapping scon)');      end; /* of not enough memory */      scon.ptr = addr(ifbuf (0)) + ifbufl; /* start SCON after IFBUF */      call create_object (loc(scon.ptr), skip_dca); /* create the final object code (and output sequence table) */      if redirect.symtab /* was the symbol table redirected? */      then do; /* yes, force out the last buffer */         i = symforce; /* yes, force out the symbol table */         if redirect.symtab /* is the symbol table still redirected? (SYMFORCE updates length if it redirects output) */         then call update_length (symbol_table, 1, i); /* yes, update the file length */         redirect.symtab = 0; /* make sure FINISH can use UNUM to output stats */      end;      objlength (0) = finish; /* clean up and output stats */      redirection_word = no_redirection; /* don't redirect output any more */   end;   objdev (0) = ofdev; /* return device of object file */   objstart (0) = ofstart; /* return starting sector of object code */   objslen (0) = ofsec; /* return sector length */   return ((r (l.flags) and module.flag) <> 0); /* return TRUE if we processed a module */end pass3;/* Pass three initialization and termination: */dcl cnam (f#name_len) fixed; /* holds name for change */dcl ifbuf.ptr fixed; /* pointer to IF buffer */dcl ifbufl    fixed; /* length of IF buffer */dcl rfbuf.ptr fixed; /* pointer to RTP buffer */dcl rfbufl    fixed; /* length of RTP buffer */dcl ofdev     fixed; /* device of object file */dcl ofstart   fixed; /* starting sector of object file */dcl ofsec     fixed; /* sector length of object file */dcl oflen     fixed; /* word length of object file (modulo 64K) */dcl is_module fixed; /* TRUE if we just created a module */dcl i         fixed; rfbuf.ptr = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* start of heap */rfbufl = core(loc.rt - 1); /* pick up RTP length */if proc_type >= 2 then rfbufl = rfbufl + rtp_diff; /* if we have RTC, estimate correct size for RTB (in case we need it) */ifbuf.ptr = rfbuf.ptr + rfbufl; /* put IF buffer right after the RTP buffer */ifbufl = ((loc.load - ifbuf.ptr + extern.base) and "177400"); /* leave room for EXTERN.BASE (-(64K - EXTERN.BASE) = EXTERN.BASE) */if ifbufl < ifbufl_min then do; /* must have at least IFBUFL_MIN words in IF buffer */   if ifbuf.ptr + ifbufl_min igt loc.load then do; /* no room */      print 'Not enough memory for Pass3 intermediate file.';      call exit(-1);   end;   ifbufl = ifbufl_min; /* set minimum */end; /* of must have at least IFBUFL_MIN words */call blockset (loc(ifbuf.ptr), loc.load - ifbuf.ptr, 0); /* zero out the rest of memory */is_module = pass3 (loc(ifbuf.ptr), ifbufl, loc(rfbuf.ptr), rfbufl, loc(addr(ofdev)), loc(addr(ofstart)), loc(addr(ofsec)), loc(addr(oflen)));  /* Successful compilation:  check for compile or run. */if (((ofsec and "377") = 1) and (ofsec <> 1)) then do; /* if multiple of 256 plus one */   ofsec = ofsec + 1; /* make it one sector longer (OVERLAY bug!!) */   oflen = oflen + 256; /* the word length especially (OVERLAY doesn't look at sector length) */end; /* of kludge */  if core(loc.rst) = 0 then do; /* run - overlay the file */   print;   core(loc.rst) = 2; /* indicates successful compilation */   if is_module /* don't overlay a module */   then call exit(0); /* just stop for modules */   else call overlay (ofdev, ofstart, oflen); /* overlay the object file */end;/* must be compile */do i = 0 to f#name_len; cnam (i) = core(loc.cfn + i); end; /* get current file name */i = cnam (0); /* get number of letters */if i >= shl(f#name_len, 1) then i = shl(f#name_len, 1) - 1; /* add one letter */call pbyte(cnam, i, a.period); /* add dot at end to mean compiled */cnam (0) = i + 1; /* and add one letter */do i = 0 to f#name_len; /* restore filename */   core(loc.cfn + i) = cnam (i);end;core(loc.cmed) = 0; /* indicate disk file */core(loc.csec + 1) = ofdev; /* device */core(loc.csec) = ofstart; /* starting sector */core(loc.csln) = ofsec; /* length in sectors */core(loc.clen) = oflen; /* length in words */core(loc.strd) = 1; /* indicate stored (in .work) */core(loc.svd) = 0; /* but NOT saved */core(loc.rst)  = 2; /* indicates successful compilation */if is_module /* is this a module? */then core(loc.ftyp) = t.relocatable; /* yes, indicate relocatable binary */else core(loc.ftyp) = t.executable; /* no, indicate directly executable */print 'Compilation successful - current file is now called "', string(cnam), '"'; call overlay (core(loc.mon + 1), core(loc.mon), core(loc.mon - 1));