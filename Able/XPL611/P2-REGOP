/* Register optimizing:..  In addition to optimizing the use of index registers, the compiler.  attempts to optimize the use of the accumulators.  Specifically, two.  types of optimizing are done:..    1. When a variable is needed in a register, the compiler checks to.       see if it is already in an allowable register. ..    2. When the compiler needs a pointer to an element of a subscripted.       variable, the compiler checks to see if a register points to.       the selected element.  Optimization on statements like:..         x (a + b + c) = x (a + b + c) + 1;..       is performed...  To perform this optimizing, the compiler uses the array 'TREES' to.  contain a description of what is in a register.  Routines are used.  to deallocate the storage associated with a tree, to compare two.  trees, and so forth. */dcl trees (8) fixed; /* holds contents of registers */dcl freetr    fixed; /* pointer to next free tree */tree.free: proc; /* passed global 'FREETR' - deallocates blocks */   dcl tree fixed;   if freetr = 0 then return; /* already freed - no storage left */   call push (tree); tree = freetr; /* restore it */   do case (x.node (tree)); /* branch on node type to deallocate */      do; /* dyadic */         freetr = x.arg1 (tree); call tree.free;         freetr = x.arg2 (tree); call tree.free;      end;      do; /* monadic */         freetr = x.arg1 (tree); call tree.free;      end;      ; /* constant */      do; /* variable */         if x.arg1 (tree) then do; /* subscripted */            freetr = x.arg2 (tree); call tree.free;         end;      end;      ; /* proc        */      ; /* reg         */      ; /* temp - has already been sent */      ; /* pointer reg */      ; /* dev         */      ; /* x.pvar      */   end;   call rel (tree); /* free up storage */   tree = pop; /* restore tree */end tree.free;freeup: proc(reg); /* free up a register */   dcl reg fixed;   freetr = trees (reg);   call tree.free;   trees (reg) = 0;end freeup;/* Register optimizing (cont):..   Comparison of tree:..   When loading a register or computing a subscript, the contents.   of the accumulators are checked to see if one already contains.   the desired item...   The following procedure performs that search. */dcl treept       fixed; /* special resetable push and pop routines */dcl treestk (31) fixed; /* and special stack */tpush: proc(t); /* push a tree */   dcl t fixed;   treestk (treept) = t;   treept = treept + 1;end;tpop: proc fixed; /* pop a tree */   treept = treept - 1;   return (treestk (treept));end;tree.comp: proc(tree1, tree2) fixed; /* compare two trees */   dcl (tree1, tree2) fixed;   dcl (t1, t2)       fixed;      treept = 0; /* initialize */   do while (1); /* loop forever */      if x.node (tree1) <> x.node (tree2) then return (0); /* not equal */      do case (x.node (tree1)); /* branch on type */         do; /* dyadic */            if x.info (tree1) <> x.info (tree2) then return (0); /* not same op */            call tpush (x.arg1 (tree1)); call tpush (x.arg1 (tree2));            call tpush (x.arg2 (tree1)); call tpush (x.arg2 (tree2));         end;         do; /* monadic */            if x.info (tree1) <> x.info (tree2) then return (0);            call tpush (x.arg1 (tree1)); call tpush (x.arg1 (tree2));         end;         do; /* constant */            if x.arg1 (tree1) <> x.arg1 (tree2) then return (0); /* not same type */            if x.arg1 (tree1) = t.var then do; /* fixed */               if x.info (tree1) <> x.info (tree2) then return (0); /* not equal const */            end;            else do;               t1 = x.info (tree1); t2 = x.info (tree2);               if fstk (t1) <> fstk (t2) then return (0);               if fstk (t1 + 1) <> fstk (t2 + 1) then return (0);            end;         end;         do; /* variable */            if x.info (tree1) <> x.info (tree2) then return (0);            if x.arg1 (tree1) <> x.arg1 (tree2) then return (0);            if x.arg1 (tree1) then do; /* if subscripted, make sure = */               call tpush (x.arg2 (tree1)); call tpush (x.arg2 (tree2));            end;         end;         return 0;         return 0;         return 0;         return 0;         return 0;         return 0;               end; /* of branch on type */      if treept = 0 then return (1);  /* if none to pop, then are = */      tree2 = tpop; tree1 = tpop;     /* pick up next ones */      if treept > 30 then return (0); /* too complex to search */   end; /* of do forever */end tree.comp;tree.var: proc(tree, class, var); /* see if tree references variable */   dcl (tree, class, var) fixed;   treept = 0; /* initialize stack pointer */   do while (1); /* examine each node */      do case (x.node (tree)); /* branch on type */         do;        /* dyadic */            call tpush (x.arg1 (tree)); call tpush (x.arg2 (tree));         end;         call tpush (x.arg1 (tree)); /* monadic */         ;          /* constant - no way */         do;        /* variable */            if  (x.info     (tree)     = var  )            and (shr(x.arg1 (tree), 8) = class)            then return (1); /* references this var */            if x.arg1 (tree) then call tpush (x.arg2 (tree)); /* check subscr */         end;         ;         ;         ;         ;         ;         ;      end; /* of branch on type */      if treept = 0 then return (0); /* does not reference variable */      if treept > 30 then return (1); /* too complex - it might */      tree = tpop; /* get next one */   end; /* of examine each node */end tree.var;