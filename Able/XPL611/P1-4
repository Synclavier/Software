/* Statement scanner:. .  This routine scans off the next statement including the semicolon.  and compiles code to execute it.  A statement includes the label.  on the statement.  This routine is obviously very recursive,.  calling both itself and the statement list routine.*/stmt: proc;dcl (stype, sinfo, sname, shash) fixed;dcl (lab, ptype)         fixed;dcl call.scan.flag       fixed;dcl cur.ret              fixed; /* holds key to jump to for 'RETURN' of current proc */dcl subscr               fixed;dcl loc.block            fixed; /* location block (will always be needed) */dcl (lower, upper, step) fixed; /* limits used for processing iterative do */dcl (d1, d2)             fixed; /* temps */dcl val                  fixed; /* val used in assignment */dcl i                    fixed;/* The following routine processes the PRINT and SEND statements. */  pstmt: proc(pdes); /* passed destination - 0 for SEND, 1 for PRINT */dcl pdes fixed;call emit (pdes); /* emit destination */if token = t.semi then call emit (1); /* print a crlf */  else do;  NEXPR:; /* re-enter here */  if token <> t.semi then do; /* semi means eol */    if token <> t.comma then do; /* comma's are null also */      if token = t.sconst then do; /* string constant print */        info = e.scon (0, 0); /* emit the string constant, get pointer to it */        call emit (3); /* 3 = string */        call emit (info); /* ptr to sconst */        call scan; /* skip over sconst */      end;      else if token = t.string then do; /* identifier 'STRING' */        call scan; /* skip it */        if token <> t.lpar then call er.ifm;        else call scan;        if (token = t.data) or (token = t.sconst) or (token = t.arr) or (token = t.parr) or (token = t.locat) then do;          if token = t.sconst then info = e.scon (0, 0); /* emit string constant if so*/          call emit (4);          call emit (token);          call emit (gclas (name.pt));          call emit (info);          if token = t.locat then do; /* scan and pass expression */            call scan; mvtype = t.var; subtree = expr; /* scan fixed pt expressin */            call compute; /* write it out to intermediate file */          end;          else call scan; /* skip token type and get paren */        end;        else call er.ifm;        if token <> t.rpar then call er.ifm;        else call scan;      end;      else do; /* not a string constant */if token = t.pform then do; /* octal, character print formats */  call emit (5);  call emit (info);  mvtype = t.var;  call scan;  end;else do;  call emit (2);  mvtype = t.fvar;  end; /* decide fixed, floating */        subtree = expr; /* scan expr */        call compute; /* and write out expression to print */      end;    end; /* of not a comma */    if token = t.comma then do; /* print next if comma here */      call scan;      goto NEXPR;      end; /* print next if comma here */    call emit (1); /* print crlf here */  if token <> t.semi then call er.ifm;end; /* of not a semi */end; /* of begin if output; */call emit (0); /* end of print statenent */end pstmt; /* end of procedure */  /* $$Statement list routine and statement label processing: .  .   The STMT.LIST procedure is used to scan off a sequence of statements.   until an 'END' statement is encountered.  It is used during the.   processing of do loops, procedure definitions, and so forth..  .   STMT.LIST will return with TOKEN = T.SEMI after the 'END' has been.   scanned past.*/ stmt.list: proc (skipscan); /* scan a list of statements */   dcl skipscan fixed; /* TRUE if we should skip final scan (after end) */   call push (skipscan); /* push requested SKIPSCAN value */   if token <> t.semi then call er.ms; /* scan semicolon from previous stmt */   call scan; /* skip semicolon - get first stmt of list */   do while ((token <> t.end) and (token <> t.eof));      call stmt;   end;   if token = t.eof then call er.me;   if not pop then call scan; /* scan off END statement (MODULE and PROC want to do this themselves; POP = passed SKIPSCAN!) */   call emit (t.end); /* and emit T.END to stop STMT.LIST in pass2 */end stmt.list;  if (mod.scanned and (s.depth = 1)) /* is this statement after the module? */then call er.somb; /* statement outside of module body - this is fatal */ #stmts = #stmts + 1; /* count statements */ stype = token;       /* save last token in its entirety */ sinfo = info; sname = name.pt; shash = hashcode;    /* and hash table pointer (in case we want to define it later) */ call scan; /* scan to next token */ /* check for statement label */  if (token = t.colon) and (sname <> 0) then do; /* statement label */    call scan; /* skip over colon */    call lchk; /* emit line number if label */    if not ((token = t.stmt) and (info = s.proc)) then do; /* if not procedure def, define label */       if (stype <> t.und) and (stype <> t.label) then call er.lt (sname); /* dupl def */       else do; /* see if defined or not */          if stype = t.und then do;             sname = s.define (sname, shash); /* define symbol getting new sname if new level */             call ptok (sname, t.label); /* indicate is a label now */             sinfo = shl(gkey, 1); /* get key, indicate unlocated so far */          end;          else if stype = t.label then do; /* see if existing label */             if sinfo then call er.lt (sname); /* duplicate */          end;          call set_stable (sname + s.locn, sinfo or 1); /* save new key, indicate is located */          call emit (t.ldef); /* locate a label here */          if sinfo ige extern.base /* external label? */          then call emit (sinfo); /* yes, emit external key */          else call emit (shr(sinfo, 1)); /* no, emit standard key # */          if token = t.end then return; /* return now if T.END with label definition */       end;       sname = name.pt; /* update name pointer */       shash = hashcode; /* and hash table pointer (in case we want to define it later) */    end;    stype = token; /* save new token */    sinfo = info;    call scan; /* scan over first word of statement */ end; else if ((stype = t.stmt) and (sinfo = s.proc)) then call er.ifm; /* procedure with no label */     if stype <> t.semi then begin; /* ignore null statement */ /* SCANSUB:..  SCANSUB is used to scan of an expression enclosed in parens..  This is used during the scanning of subscripts for subscripted.  variables and during the processing of the 'WRITE' statement.*/scansub: proc;dcl sub fixed;  if token <> t.lpar then call er.ifm;  mvtype = t.var;  call scan; sub = expr;  if token <> t.rpar then call er.ifm;  call scan;  return sub;end scansub;  /* $$Routine to get constant:.  .   The following subroutine is used to scan off an expression that.   must be a constant.   It is used to scan off a subscript.   during the processing of an array declaration.*/  get.const: proc(typ); /* scan a constant of type typ - T.FVAR or T.VAR */dcl (block, val, typ) fixed; mvtype = typ; /* set type for scanner */ block = expr;if x.node (block) <> x.const then call er.cr; /* constant expression required  */ val = x.info (block);if (typ <> x.arg1 (block)) then begin; /*  must change type */  if typ = t.var then begin; /* have floating, want fixed */    fstk (val) = "100000";    call er.fpna; /* floating not allowed in data list */  end;  else begin; /* want floating,  have fixed */    call float (val); /* float the fixed point number */    val = fstr (fval1, fval2);  end;end; call x.rel (block); return val; end get.const;  /* Assignment:. .  The following code processes the assignment statement:.  .     <variable> (subscript if required) = <expression>;.  .  The following routine scans off the variable, its possible subscript,.  and the expression to assign to it.  The information is then written.  out to the intermediate file.*/  if ((stype < t.lit) or (stype = t.data) or (stype = t.fdata)) then begin; /* variable - assignment */  if ((stype = t.data) or (stype = t.fdata)) then call wa.oda; /* warn them the code isn't ROMable */  if stype then do; /* expect subscript */    if token <> t.lpar then call er.msub (sname); /* no subscript */    subscr = scansub;  end;  else subscr = 0; /* plain */  if (token <> t.opr) or (info <> o.eq) then call er.ifm;  call scan; /* skip over = */  call emit (t.assign or shl(stype, 8)); /* assign and type */  call emit (gclas (sname)); /* storage class */  call emit (sinfo); /* variable location in variable area */  mvtype = (stype and t.fvar); /* set bit if floating */  val = expr; /* scan expression for assignment */  if stype then do; subtree = subscr; call compute2; end; /* emit subscript if one */  subtree = val; call compute; /* and emit expression to interfile */end; /* of handling assignment */elseif stype = t.stmt then do; /* handle a statement */ /* $$Statement scanner - other statements: */   if sinfo < s.pass1 then call emit (stype or shl(sinfo, 8)); /* type of statement and T.STMT in one */  do case (sinfo); /* and branch on type */ /* Statement scanner - CALL statement */ do; mvtype = t.fvar; /* assume worst case */if (token <> t.proc) and (token <> t.rtp)then call er.ifm; /* not allowed */subtree = expr; /* scan expression */call compute; /* and is what to call */ end; /* Statement scanner - RETURN statement: */ do; if cur.proc.def = -1 then call er.rna; if token <> t.semi then begin; /* allow passing no value */ call emit (1); /* one means there is an expression */ if cur.proc.def = -2 then mvtype = t.var; /* fixed point for interrupt ret */ else mvtype = (stable (cur.proc.def + p.rtyp) and t.fvar); /* set bit for fxd or flt desired */ call emit (mvtype); /* emit type returned */ subtree = expr; /* scan arithmetic expression */ call compute; /* compute it */ call emit (cur.ret); /* location to jump to */ end;else do; /* null return */  call emit (0); call emit (cur.ret);end; /* null return */end;do; /* procedure definition */   insert ':xpl611:p1-proc';end; /* Statement scanner - BEGIN statement: */  do;    call s.block; /* localize */    in.begin = in.begin + 1; /* remember we're in a BEGIN block (so we can treat it separately from a procedure) */    call stmt.list (0); /* get a list of statements followed by 'END' */    in.begin = in.begin - 1; /* forget we're in this BEGIN block */    call s.endblock; /* return to former locale */ end; /* $$Statement scanner - DO statement: */ do;call emit (token); /* emit token type - while, case, semicolon, or variable */   /* 'do;' */ if token = t.semi then do; call stmt.list (0); /* get a list of statements followed by 'END' */ end;  /* do case routine */  else if token = t.case then do; /* do case */ call scan; /* scan past 'CASE' */ mvtype = t.var; /* fixed point case expression */ subtree = expr; /* scan expression */ call compute; /* compute the argument */call stmt.list (0); end; /* of 'do case' */  /* do loops - do while */  else if token = t.while then do; /* do while */ call scan; /* scan off 'WHILE' */ mvtype = t.var; /* fixed point is desired */ subtree = expr; /* scan expression */call compute; /* write expression tree out to interfile */ call stmt.list (0); /* scan a list followed by 'END' */ end; /* of do while */  /* do loops - do i = 1 to 3 by 4 */   else do; /* must be do i = */if token >= t.lit then call er.ifm;if token          then call er.ifm;call emit (gclas (name.pt)); /* emit storage class */call emit (info); /* emit variable location */mvtype = (token and t.fvar); /* save variable type for scan */ call scan; /* scan over variable */ if not ((token = t.opr) and (info = o.eq)) then call er.ifm; call scan; /* skip over "=" */ lower = expr; /* scan expression for starting value */if token <> t.to then call er.ifm; call scan; /* skip over to */ upper = expr; /* scan upper expression */ if token <> t.by then do; /* assume step of one */ step = x.get; /* get block for constant */ x.node (step) = x.const; /* const step */x.arg1 (step) = t.var; /* fixed point constant */ x.info (step) = 1; /* step of one */ end; /* of constant step */ else do; /* variable step */ call scan; /* skip by */ step = expr; /* scan expression */ end;  subtree = lower; call compute2; /* write out lower */subtree = upper; call compute2; /* write out upper */subtree = step;  call compute; /* write out step  */call stmt.list (0); /* and scan loop statement list */ end; /* of do loops */ end; /* of do statememt *//* $$Statement scanner - IF statement: */  do; mvtype = t.var; /* look for fixed point */ subtree = expr; /* get boolean expression */ if token <> t.then then call er.ifm; call scan; /* scan over 'THEN' */ call compute; /* write out if expression */ call stmt; /* scan 'THEN' clause */ if token = t.else then begin; /* check if there is an 'ELSE' clause */ call emit (t.else); /* let pass2 know there is an else */ call scan; /* scan 'ELSE' */ call stmt; /* scan else clause */ end; call.scan.flag = 1; /* set to one to indicate skip the call */ end; /* Statement scanner - GOTO statement: */ do;   if token <> t.label then do; /* if not label, try to define it */      if token <> t.und then call er.ifm; /* must be label after GOTO statement */      else do; /* is undefined - define forward reference label */         lab = s.define (name.pt, hashcode);         call ptok (lab, t.label); /* indicate label, as yet undefined */         info = shl(gkey, 1); /* get a key here also */         call set_stable (lab + s.locn, info); /* and store it in symbol table - indicates unlocated label */      end;   end;   if info ige extern.base /* external key? */   then call emit (info); /* yes, emit external key */   else call emit (shr(info, 1)); /* no, emit key pointer for label */   call scan; /* scan past label */end;  /* Statement scanner - interrupts: */  flags = (flags or enable.flag); /* indicate existence of 'ENABLE' */  ; /* DISABLE - already in interfile */  /* Statement scanner - STOP: */  do; /* stop stmt */if token = t.semi then call emit (0); /* plain stop */else begin; /* stop expr */  call emit (1); /* one means something */  mvtype = t.var; /* fixed point */subtree = expr; /* scan expr */call compute; /* compute expr */end; /* of stop */end; /* of stop stmt */  /* $$Statement scanner - WRITE, INPUT, and PRINT: */  do; /* write */  subtree = scansub; /* scan scan subexpression in parens */  call compute; /* write out expression */  if (token <> t.opr) or (info <> o.eq) then call er.ifm;  call scan; /* skip over */  subtree = expr; call compute; /* scan and compute expression */end; /* write */  do; /* linput string */  call emit (token); call emit (gclas (name.pt)); call emit (info);  if token = t.locat then do; /* location expression */    call scan;    mvtype = t.var;    subtree = expr;    call compute;  end;  else if (token = t.arr) or (token = t.parr) then call scan;  else call er.ifm; /* else error */end;  do; /* input */  if token = t.semi then call er.ifm;  do while token <> t.semi; /* and loop through list */    if token >= t.lit then begin;       call er.ifm;       token = t.var;    end;    stype = token; sinfo = info; sname = name.pt; /* save these items */    call scan; /* skip over type */    if stype then subscr = expr; /* scan subscript */    val = x.get; x.node (val) = x.cal; /* set type */    if (stype and t.fvar) = 0 then begin;      x.info (val) = l.fxi;      x.arg1 (val) = t.var;    end;    else begin; /* floating */      x.info (val) = l.fin;      x.arg1 (val) = t.fvar;    end;    call emit (1); /* 1, so zero is end */    call emit (t.assign or shl(stype, 8)); /* do it */    call emit (gclas (sname));    call emit (sinfo);    if stype then do;      subtree = subscr;      call compute2;    end;    subtree = val;    call compute;    if token = t.comma then call scan;    else if token <> t.semi then do;       call er.ifm;       token = t.semi;    end;  end;  call emit (0); /* end of list */end; /* of input begin */  call pstmt (1); /* print statement - destination is 1 */  call pstmt (0); /* send statement - destination is 0 */  /* Statement scanner - WHEN interrupt statement:.  .   The format for processing interrupts is:.  .     when <cell identifier> then <statement>;.  .   where <cell identifier> = 'lncint', ttoint', etc. and.   <statement> is any statement.*/  do; /* when statement */  flags = (flags or when.flag); /* indicate a 'WHEN' */   if token <> t.icell then do;    if token = t.und     then call er.ufls (name.pt); /* undefined */    else call er.ifm;    info = 0;  end;  if cur.proc.def <> -1 then call er.wna; /* not allowed here */  lab = gkey; /* get key */  nexkey = nexkey + when_keys; /* save enough keys for WHEN */  if com (l.icell + info) <> 0 then call er.dupw; /* duplicate when detected */  com (l.icell + info) = lab; /* save  key */  call emit (lab); /* emit key type */  call scan; /* can type */  if token <> t.then then call er.ifm; /* must be then */  else call scan; /* skip the then */    call push (cur.proc.def); /* save current procedure definition */  call push (cur.ret);      cur.proc.def = -2;   /* set recognizable proc def flag for the return statement */  cur.ret = lab + 2;   /* return key */  call stmt;           /* and scan the when statement */  cur.ret = pop;       /* resture return */  cur.proc.def = pop;  call.scan.flag = 1;  /* set flag to skip scan */end;                   /* of the when business */ do; /* invoke statement */   if token <> t.icell then do;      if token = t.und       then call er.ufls (name.pt); /* undefined */      else call er.ifm;      info = 0;   end;   token = t.const; /* pretend it's a constant */   mvtype = t.var; /* want fixed point */   subtree = expr; /* create a node for it */   call compute; /* emit the statement to invoke */end; /* of invoke statement *//* Statement scanner - MODULE and LIBRARY statements:..  The MODULE statement defines this program as a library file.  (relocatable binaries are produced for modules).  The format.  is:  module <name>;  There must be an accompanying END statement.  at the end of the file...  The library statement points to a precompiled module.  The.  format is:  library 'filename'; */begin; /* module statement */   dcl module_info fixed; /* save pointer to module name here (note the module statement can only occur once) */   if mod.scanned     then call er.mms; /* prevent multiple module statements */   if #stmts <> 1     then call er.mnfs; /* module must be the first statement */   if token <> t.semi then do; /* if name specified */      if token <> t.und /* if there's something there */      then do; /* it better be undefined */         call er.ifm; /* it's not - complain */         module_info = -1; /* and remember there wasn't a valid name */      end;      else do; /* it's there and it's undefined */         module_info = s.define (name.pt, hashcode); /* define the symbol and remember its pointer */         call ptok (module_info, t.module); /* set token field in symbol */         call set_stable (module_info + s.locn, module_info); /* and set info field in symbol */      end;      call scan; /* get the next token */   end; /* of if name specified */   else do; /* no module name */      module_info = -1; /* remember no name was specified */      call er.mnim;   end;   mod.scanned = 1; /* now we have scanned a module */   flags = (flags or module.flag); /* turn flag on for pass3 */   call emit (name (0) + 1); /* emit the module name length (in words) */   i = shl(name (0), 1); /* calculate byte length */   if (name (name (0)) and (not "377")) = 0 then i = i - 1; /* odd number of bytes */   call emit (i); /* emit byte length */   do i = 1 to name (0); /* emit the module name */      call emit (name (i));   end;   call s.block; /* be nice and start a new block */   call stmt.list (1); /* scan the rest of the program; don't let STMT.LST scan last semi */   call s.endblock; /* move back out again */   call scan; /* scan HERE so we get any name at the correct level of localization */   if token <> t.semi then do; /* name may be omitted */      if ((token <> t.module) or (info <> module_info)) /* module name we're looking for? */      then call er.nm; /* no, error! */      else call scan; /* if name is there, it must be right */   end; /* of name may be omitted */end; /* of module statement */begin; /* library statement */   dcl treename (64) fixed; /* full treename of library */   if token <> t.sconst then call er.ifm; /* must be followed by a filename */   if name (0) = 0 then call er.mtn; /* check for an empty filename */   flags = (flags or link.flag); /* turn flag on for linker initiation */   if ((catname (0) <> 0) and (byte(name, 0) <> a.colon)) then do; /* prefix library name with entered catalog name if necessary */      call strcpy (treename, catname); /* copy the catalog name over */            if ((treename (0) <> 1) or (byte(treename, 0) <> a.colon)) /* is there a colon already there? */      then do; /* no, add one in */         call pbyte(treename, treename (0), a.colon); /* like so */         treename (0) = treename (0) + 1; /* keep track of the length */      end;      if treename (0) + name (0) > 128 /* watch the string length */      then call er.sctl;      else call strcat (treename, name); /* tack on the library name */   end;   else call strcpy (treename, name); /* don't prefix the name */   call emit (shr(treename (0) + 1, 1) + 2); /* emit the record length (in words) */   call emit (line.no); /* emit the line number we found the statement on */   do i = 0 to shr(treename (0) + 1, 1); /* emit the library name */      call emit (treename (i));   end;   call scan;end;  /* $$Statement scanner - INSERT statement:.  .   The following routine handles the initial entry of insert files:.   .     insert 'filename';.  .   The file is opened and then all pertinent information about the current.   file (line number, current position, etc.) is pushed onto our internal.   stack.  Pointers are set up to the new file and compilation continues.*/  do; /* insert file */call scan; /* skip string, should get semi */if token <> t.semi then call er.ms; /* missing */if name (0) = 0 then call er.mtn; /* check for missing treename */else if not open (name) then call er.cat; /* try to open the file */else do; /* we found the file - insert it */if f#type <> t#text then call er.ftm;call emit (shr(name (0) + 1, 1) + 1); /* emit the record length (in words) */do i = 0 to shr(name (0) + 1, 1); /* emit the insert filename */   call emit (name (i));end;do i = 0 to 4; /* store old file name on stack, new file name in 'cfname' */  call ipush (cfname (i));  cfname (i) = f#name (i);end;do i = 0 to 5; cfnmes (i) = in.fmes (i); end; /* and message */call ipush (a#ls_length); call ipush (a#ms_length); call ipush (a#dir_size); /* save entered cat in REVERSE order */call ipush (a#ls_sector); call ipush (a#ms_sector);call ipush (sfdev);       call ipush (sfstart);     call ipush (sflngth); call ipush (sfflp);call ipush (sfsec);       call ipush (sfpos);       call ipush (bc);call ipush (word);        call ipush (line.no); call ipush (chrbase);     call ipush (pchrp);   call ipush (chrpt);       call ipush (chrln);       call ipush (nchr);call ipush (n.info);      call ipush (newdisk); /* indicate if new disk */  sfdev = f#ms_sector; sfstart = f#ls_sector; sflngth = f#words;readl = sflngth; if readl igt sfbufl then readl = sfbufl; /* readl = min(sflngth, sfbufl); */sfbuf (0) = 0; /* to get line number correct if zero length file? */call readdata (sfdev, sfstart, sfbuf, readl); /* and read first load */bc = 0; sfflp = 0; sfpos = 0; sfsec = 0; /* initialize pointers */pchrp = 0; nchr = 0; /* save first one */n.info = b.eol;line.no = sfbuf (0); /* word 0 of file should be first line no. */call scan; /* skip semi, get first token of next file */call.scan.flag = 1; /*  d o  n o t  call scan */end; /* of inserting file */end; /* of insert */     do; /* declare statement */        insert ':xpl611:p1-dcl';     end;  /* $$Statement scanner - ENTER statement: */do; /* process enter statement */   if name (0) = 0 then call er.mtn; /* check for an empty filename */   else do; /* open any catalog */      if name (0) = 1 and name (1) = a.star then do; /* enter '*' */         call enter_alternate ('', 1); /* enter original current catalog */         catname (0) = 0; /* no more catalog name */      end;      else do; /* do it */         if not enter_alternate (name, -1) then call er.cat; /* search for the catalog */         else do; /* got the catalog */            do i = 0 to shr(name (0) + 1, 1); /* save the current catalog name */               catname (i) = name (i); /* so LIBRARY works properly */            end;         end;      end;   end;   call scan; /* skip to semicolon */end; /* of ENTER */  do; /* pdl */   pdll = get.const (t.var); /* get a constant here */   if pdll = 0 then call er.ifm; /* not allowed */end;  /* $$Statement scanner - RAM and CONFIGURATION:.  .   The RAM statement is used to specify an overriding ram location. */  do; /* ram statement */  ovram = get.const (t.var); /* get fixed point constant */end;begin; /* configuration statement */  dcl memsiz lit  '0'; /* size of memory    */  dcl prctyp lit  '1'; /* processor type    */  dcl muldiv lit  '1'; /* mul div in system */  dcl tapdrv lit  '1'; /* tape drive in system */  dcl ptype  lit  '2'; /* terminal type     */  dcl stype  lit  '3'; /* printer type      */  dcl curdvt lit  '7'; /* current device type */  dcl sysdvt lit  '8'; /* system device type  */  dcl enddvt lit '48'; /* end of devive table + 1 */  dcl maxi data ( shl("2", 8), 8, 77,  shl(8, 8) or 2); /* maxifloppy  config */  dcl mini data (           0, 5, 35,  shl(5, 8) or 3); /* minifloppy  config */  dcl dmin data (           0, 5, 80,  shl(5, 8) or 1); /* double mini config */  dcl smin data (shl("5", 8), 30, 80, shl(15, 8) or 0); /* super mini config */  copy: proc(data); /* pass data type - assign to storage config */    dcl data array;    dcl i fixed;    do i = sysdvt to enddvt - 1; /* free what's there */      com (l.ctab + i) = -1;    end;    com (l.ctab + curdvt) = (data (0) and "377"); /* set current device equal to system device */    do i = 0 to 3;      com (l.ctab + sysdvt + i) = data (i); /* store there */    end;    com (l.ctab + tapdrv) = (com (l.ctab + tapdrv) and (not shl(1, 5))); /* remove tape drive as well */  end copy;  stuff: proc(off, shf); /* used for stuffing 8 bit fields */    dcl (off, shf) fixed;    dcl (t, q) fixed;    t = com (l.ctab + off); /* get original value */    q = get.const (t.var); /* get the fixed point number */    if q ige 256 then q = 255; /* max */    com (l.ctab + off) = (t and rot("hff00", shf)) + shl(q, shf); /* and put into place */  end stuff;  do while token = t.config; /* scan of types */    sinfo = info; /* save current info */    call scan; /* skip over - get another one, expression, comma, semi */  do case (sinfo); /* branch on type */      call copy (maxi);      call copy (mini);      call copy (dmin);      call copy (smin);      com (l.ctab + prctyp) = ((com (l.ctab + prctyp) and (not shl(7, 8))) or shl(1, 8));      com (l.ctab + prctyp) = ((com (l.ctab + prctyp) and (not shl(7, 8))) or shl(2, 8));      com (l.ctab + prctyp) = ((com (l.ctab + prctyp) and (not shl(7, 8))) or shl(3, 8));      com (l.ctab + memsiz) = shr(get.const (t.var), 8);      com (l.ctab + muldiv) = (com (l.ctab + muldiv) or "10");      com (l.ctab + muldiv) = (com (l.ctab + muldiv) and (not "10"));      call stuff (ptype, 8); /* terminal type */      call stuff (stype, 8); /* printer  type */    end;    if token = t.comma then call scan; /* skip over separating commas */  end;end; /* of configuration stmt *//* $$End of statement routines: */  end; /* of do case branch for statement types */end; /* of do for statements */else if stype = t.end then call er.tme;else if stype = t.und then call er.ufls (sname);else call er.ifm; if call.scan.flag <> 1 then begin; /* should call scan */if token <> t.semi then call er.ms; call scan; /* skip over semi */ end; call.scan.flag = 0; /* reset flag */  end; /* of non-null statement case */else call emit (t.null); /* null statement */ end stmt;