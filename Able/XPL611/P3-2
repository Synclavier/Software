/* The following routines handle entering a recursive procedure.  ENTRY_LEN.   returns the length of code emitted by pass3 to enter a given recursive.   procedure.  ENTER.PROC emits said code. */entry_len: proc(parms, stack_len, flags) fixed; /* determine length of recursive proc's entry code */   dcl parms     fixed; /* number of parameters passed to a recursive proc */   dcl stack_len fixed; /* length of proc's stack frame */   dcl flags     fixed; /* procedure attributes */   dcl len       fixed; /* length of entry code */   if stack_len = 0 /* any variables stacked? */   then len = 0; /* no, we don't need any code to enter */   else do; /* yes, we need some code */      len = 2; /* at least this much code is generated (to save back pointer) */      if prctyp < 2 then do; /* models A & B */         if (flags and p.recursive) <> 0 then do; /* if recursive procedure */            len = len + parms; /* need to stack parameters */            if parms > 4 then len = len + 2; /* add two words for variable pointer for parms past 4 */         end; /* of recursive procedure */         stack_len = stack_len - parms; /* determine remaining space on stack */      end; /* end of models A & B */      else do; /* model C */         if (flags and p.recursive) <> 0 then do; /* if recursive proc, stack parms */            if parms > 4 then do; /* if not all register parameters */               len = len + (4 + 5); /* at least this many more words (accumulators/extra parm copy code) */               stack_len = stack_len - 4; /* zero out extra non-register parameters also */               if parms > 5 then len = len + 1; /* need one more for repeat over parms */            end;            else do; /* all register parameters */               len = len + parms; /* at least PARMS more words */               stack_len = stack_len - parms; /* don't include register parms */            end;         end; /* of recursive procedure */         if stack_len > 256 then len = len + 1; /* need to save R3 */      end; /* of model C */      if stack_len <> 0 then do; /* add in zeroing stack code */         if (((stack_len <= 4) and (prctyp < 2)) or ((stack_len <= 2) and (prctyp >= 2))) /* should we zero the rest of the stack in-line? */         then len = len + stack_len; /* yes, we use as many words as the stack size */         else do; /* no, we need to generate a loop */            if ((prctyp >= 2) and (stack_len <= 256)) then do; /* model C REPEAT? */               len = len + 2; /* two words for repeat */               if not emitt (stack_len - 1) then len = len + 1; /* unless it's a large stack */            end;            else do; /* normal loop */               len = len + 4; /* this is how much code it takes to zero the stack */               if not emitt (stack_len) then len = len + 1; /* unless it's a large stack */               if prctyp >= 2 then len = len + 3; /* and unless Model C - this takes three more words */               if (((flags and p.recursive) = 0) /* if non-recursive proc, haven't saved parms yet */               and (/*parms > 3####*/1)) then len = len + 2; /* if more than three parms, R3 holds a parm - save it */            end;         end; /* of generating a loop */      end; /* of zeroing stack code */   end; /* of determining code needed */   return (len); /* return length of code */end entry_len;enter.proc: proc(parms, stack_len, flags, sp); /* emit code to enter a recursive procedure */   dcl parms     fixed; /* number of parameters passed on by pass1 */   dcl stack_len fixed; /* length of recursive proc's stack */   dcl flags     fixed; /* procedure attributes */   dcl sp        fixed; /* stack pointer (r15 for models A & B, r12 for model C & later) */   dcl i         fixed;   if stack_len <> 0 then do; /* if there are variables for the stack, we need to set things up */      if prctyp < 2 then do; /* models A & B */         call xmit (b.rs + b.ibt + sp, b.rd + "12"); /* rSPi to r12 [save stack frame start] */         if (flags and p.recursive) <> 0 then do; /* if recursive proc, stack parms */            if parms > 4 then i = 4; else i = parms; /* determine number of parms in regs */            do i = 0 to i - 1; /* stack the first four passed parameters */               call readif; /* ignore garbage from pass1 */               call xmit (b.rs + i, b.md + b.ibt + sp); /* rX to mrSPi [stack the next register] */            end;            if parms > 4 then do; /* any remaining parms must be moved from canonical location to the stack */               call xmit (b.ms + b.ibt + b.pc, b.rd + "3"); /* pci to r3 [get a variable pointer] */               call writeobj (adjram (readif) + vstrt - 1); /* data canonical [pointer to canonical location] */               call xmit (b.ms + b.ibt + "3", b.md + b.ibt + sp); /* mr3i to mrSPi [stack this parm] */               do i = 2 to parms - 4; /* stack the remaining args */                  call readif; /* ASSUME variables are in consecutive locations */                  call xmit (b.ms + b.ibt + "3", b.md + b.ibt + sp); /* mr3i to mrSPi [stack this parm] */               end;            end; /* of moving any remaining parms */            stack_len = stack_len - parms; /* determine remaining stack length (parameters take one word each!) */         end; /* of recursive procedure */      end; /* of models A & B */      else do; /* model C */         call xmit (b.rs + sp, b.rd + "15"); /* rSP to r15 [save stack frame start - Model C] */         if (flags and p.recursive) <> 0 then do; /* if recursive proc, stack parms */            if parms > 4 /* if not all register parameters */            then stack_len = stack_len - 4; /* zero out extra non-register parameters also */            else stack_len = stack_len - parms; /* don't include register parms */         end; /* of recursive procedure */         if stack_len > 256 /* if stack is larger than repeat can handle */         then call xmit (b.rs + "3", b.rd + "11"); /* preserve R3 */      end; /* of model C */      if stack_len <> 0 then do; /* if there is any stack space left */         if (((stack_len <= 4) and (prctyp < 2)) or ((stack_len <= 2) and (prctyp >= 2))) /* don't create the loop if we can do it in-line in fewer words */         then do i = 1 to stack_len; /* create remaining stack length in-line */            call xmit (b.is + 0, b.md + b.ibt + sp); /* im(0) to mrSPi [fill the stack with zeros] */         end; /* of creating remaining stack in-line */         else do; /* need to generate a loop */            if ((prctyp >= 2) and (stack_len <= 256)) then do; /* on Model C, see if we can use simple REPEAT (stack_len <> 0 here!) */               if emitt (stack_len - 1) /* will it fit in an intermediate field? */               then call xmit (b.is + ((stack_len - 1) and b.imsk), "10"); /* im(stack_len - 1) to d10 [load repeat counter] */               else do; /* need to do a long immediate */                  call xmit (b.ms + b.ibt + b.pc, "10"); /* pci to d10 [load repeat counter] */                  call writeobj (stack_len - 1); /* data stack_len - 1 */               end;               call xmit (b.is + 0, b.md + b.ibt + "12"); /* im(0) to mr12d [fill the stack with zeros] */            end; /* of using simple REPEAT */            else do; /* can't use Model C simple REPEAT - generate normal loop */               if (((flags and p.recursive) = 0) /* if non-recursive proc, haven't saved parms yet */               and (/*parms > 3######*/1)) /* if more than three parms, R3 holds a parm */               then call xmit (b.rs + "3", b.rd + "11"); /* r3 to r11 [preserve R3] */               if emitt (stack_len) /* will it fit in an intermediate field? */               then call xmit (b.is + (stack_len and b.imsk), b.rd + "3"); /* im(stack_len) to r3 [get stack length] */               else do; /* need to do a long immediate */                  call xmit (b.ms + b.ibt + b.pc, b.rd + "3"); /* pci to r3 [get the stack length] */                  call writeobj (stack_len); /* data stack_len */               end;               if prctyp < 2 then do; /* normal Model A & B loop */                  call xmit (b.is + 0, b.md + b.ibt + sp); /* im(0) to mrSPi [fill the stack with zeros] */                  call xmit (b.is + 1, b.ad + b.sub + "3"); /* im(1) to sub3 [decrement count] */                  call xmit (b.is + (-3 and b.imsk), b.cr + b.tnz); /* im(-3) to rtnz [loop until we're done] */               end; /* of Model A & B loop */               else do; /* normal Model C & later loop */                  call xmit (b.is + 1, b.ad + b.sub + "3"); /* im(1) to sub3 [subtract one from remaining count */                  call xmit (b.rs + "3", "10"); /* r3 to d10 [repeat up ((R3 + 1) mod 256) times] */                  call xmit (b.is + 0, b.md + b.ibt + sp); /* im(0) to mrSPd [fill the stack with zeros] */                  call xmit (b.ms + b.ibt + b.pc, b.ad + b.and + "3"); /* pci to and3 [mask off amount already repeated] */                  call writeobj (not "377"); /* data ^377 */                  call xmit (b.is + (-6 and b.imsk), b.cr + b.tnz); /* im(-6) to rtnz [loop back if not done yet] */               end; /* of Model C & later loop */               if (((flags and p.recursive) = 0) /* if non-recursive proc, haven't saved parms yet */               and (/*parms > 3#####*/1)) /* if more than three parms, R3 holds a parm */               then call xmit (b.rs + "11", b.rd + "3"); /* r11 to r3 [restore R3] */            end; /* of normal loop */         end; /* of generating a loop */      end; /* of save the appropriate space on the stack */      if prctyp < 2 /* models A & B */      then call xmit (b.rs + "12", b.md + sp); /* r12 to mrSP [save the stack base] */      else do; /* model C */         if (flags and p.recursive) <> 0 then do; /* if recursive proc, stack parms */            if parms > 4 then i = 4; else i = parms; /* determine number of parms in regs */            do i = i - 1 to 0 by -1; /* stack register parameters (in reverse) */               call readif; /* skip address */               if ((i = 3) and (stack_len > 256)) /* if R3 is really in R11 */               then call xmit (b.rs + "11", b.md + b.ibt + sp); /* r11 to mrSPi [stack R3] */               else call xmit (b.rs + i,    b.md + b.ibt + sp); /* rX  to mrSPi [stack the next register] */            end; /* of stacking register parameters */            if parms > 4 then do; /* if non-register parameters - copy them into stack */               call xmit (b.rs + sp, b.rd + "3"); /* rSP to r3 [move stack pointer to R3] */               call xmit (b.is + 5, b.ad + b.add + "3"); /* im(5) to add3 [point to fifth parameter] */               call xmit (b.ms + b.ibt + b.pc, b.rd + "11"); /* pci to r11 [get a variable pointer] */               call writeobj (adjram (readif) + vstrt - 1); /* data canonical [pointer to canonical location] */               i = parms - 4 - 1; /* get number of parameters remaining (base zero) */               if i <> 0 /* if more than one */               then call xmit (b.is + i, "10"); /* im(i) to D10 [repeat] */               call xmit (b.ms + b.ibt + "11", b.md + b.ibt + "3"); /* mr11i to mr3i [copy this parm to stack] */               do i = 1 to i; /* skip over rest of IF record */                  call readif; /* ASSUME variables are in consecutive locations */               end;            end; /* of non-register parms */         end; /* of recursive procedure */         call xmit (b.rs + "15", b.md + b.ibt + sp); /* r15 to mrSPd [save stack frame base] */      end; /* model C */   end; /* of outputting entry code */end enter.proc;/* The following routines handle exitting a recursive procedure.  EXIT_LEN.   returns the length of code emitted by pass3 to exit a given recursive.   procedure.  EXIT.PROC emits said code. */exit_len: proc(stack_len) fixed; /* determine length of recursive proc's exit code */   dcl stack_len fixed; /* length of recursive proc's stack */   dcl len       fixed; /* length of exit code */   if stack_len = 0 /* any variables stacked? */   then len = 0; /* no, we don't need any code to exit */   else do; /* yes, we need some code */      if prctyp < 2 /* models A & B */      then len = 1; /* need one word */      else len = 2; /* two words on Model C */   end;   return (len); /* return length required */end exit_len;exit.proc: proc(stack_len, sp); /* emit code to exit a recursive procedure */   dcl stack_len fixed; /* stack length */   dcl sp        fixed; /* stack pointer (r15 for models A & B, r12 for model C & later) */   if stack_len <> 0 then do; /* clean up only if there's a stack frame */      if prctyp < 2 then call xmit (b.ms + sp, b.rd + sp); /* yes, zap the stack frame (mrSP to rSP) */      else do; /* a little different on Model C and later */         call xmit (b.rs + b.ibt + sp, b.ca + b.tnv); /* increment rSP on Model C & Later (rSPi to atnv) */         call xmit (b.ms + sp, b.rd + sp); /* get rid of stack frame like so on Model C and later [mrSP to rSP] */      end;   end; /* of outputting exit code */end exit.proc;/* Create a relocatable binary file:..     This procedure will create a relocatable binary file from the.     intermediate file.  The relocatable binary is basically just.     the intermediate file with some header information preceding.     it.  This header information is entirely from the interpass.     communications area as is evidenced by the code below. */create_reloc: proc fixed; /* create a relocatable binary file */   dcl i fixed;   copy: proc(len); /* copy len words from the interfile to the binary */      dcl len fixed; /* number of words to copy */      do len = 1 to len; /* do the copy */         call writeobj (readif); /* copy directly */      end;   end copy;   iteration = iteration + 1; /* let the user know where we are */   /* copy out the header information for the linker */   creating_reloc = 1;   call writeobj (7 + whentablen + configlen); /* start with length of header */   call writeobj (et.revision); /* start with the IF revision number */   call writeobj (r (l.key));   /* number of keys used     */   call writeobj (r (l.altkey));/* number of alt keys used */   call writeobj (ram); /* amount of ram used */   call writeobj (r (l.str.data)); /* amount of string constants/data */   call writeobj (r (l.flags) and keep.flags); /* we need to know this information */   call writeobj (r (l.recurs.parms)); /* recursive parameter canonical location */   do i = 0 to whentablen - 1; /* copy out interrupt cells */      call writeobj (r (l.icell + i));   end;   do i = 0 to configlen - 1; /* copy out configuration */      call writeobj (r (l.ctab + i));   end;   i = readif; /* get first record type */   do while (i <> et.eof); /* copy intermediate file as is for linker - stop at eof */      call writeobj (i); /* copy the type over */      if (i and literal.mask) = 0 then do; /* already copied literal word */         i = et.length (i); /* get length to copy (length of record) */         if i = -1 then do; /* if variable length, read and copy length from IF */            i = readif; /* get length word */            call writeobj (i); /* copy length word */            i = (i and "377"); /* extract length portion */         end; /* of variable length record */         call copy (i); /* copy the record over */      end;      i = readif; /* get next type */   end; /* of do while */   call writeobj (et.eof); /* output eof */   call objforce; /* force out the object code */   if (r (l.flags) and dump.flag) <> 0 then do; /* dump stats if they're interested */      print;      print 'String and data constants: ',; call unum (r (l.str.data)); print;      print 'Variable space required:   ',; call unum (ram - 1); print;      print;      print 'Relocatable binary length: ',; call unum (objlng); print;      print;          print 'Symbol table:   [',; call unum (r (l.#st)     ); print ' ]: ',; call unum (r (l.s.names.len));      print '    Keys used:      [',; call unum (max_keys      ); print ' ]: ',; call unum (r (l.key)        ); print;          print 'Stack used:     [',; call unum (r (l.#sk)     ); print ' ]: ',; call unum (r (l.stack.used) );      print '    Alt Keys used:  [',; call unum (max_alts      ); print ' ]: ',; call unum (r (l.altkey)     ); print;          print 'First file:     [',; call unum (core(loc.wsln)); print ' ]: ',; call unum (r (l.iflng)      );      print '    Second file:    [',; call unum (r (l.#if2)    ); print ' ]: ',; call unum (r (l.if2lng)     ); print;          print 'Blocks used:    [',; call unum (r (l.#bl)     ); print ' ]: ',; call unum (r (l.get.blocks) );      print;   end;   return (objlng); /* return the actual word length of the file, modulo 64k */end create_reloc;/* Linker routines:..    When a 'LIBRARY' statement is encountered, it is necessary for the.    compiler to replace the statement by the relocatable binary file.    specified (much as an 'INSERT' statement is replaced by the specified.    source file).  These routines effect that replacement.  Nested.    libraries are not explicitly supported by these routines, but they.    do work (the pass done by RESOLVE ensures they do)...    The following variables are used by the linker routines only:*/dcl main_lib    lit '1'; /* library number of MAIN (set in LINK) */dcl undef_ext   fixed; /* number of unresolved references */dcl link_error  fixed; /* non-zero if any errors during the linking process (set by ER.USR) *//* library related variables */ dcl next_lib      fixed; /* pointer to next available library index    */dcl next_lib_name fixed; /* pointer to next available name table entry */dcl current_lib   fixed; /* pointer to the library presently used      */ dcl lib_name (lib_name_size - 1) fixed; /* text of library names    */dcl name_lib (lib_size - 1)      fixed; /* pointer to LIB_NAME      */dcl b.scon (lib_size) fixed; b.scon (1) = 0; /* base of string constants */dcl b.ram  (lib_size) fixed; b.ram  (1) = 0; /* base of ram area         */dcl b.key  (lib_size) fixed; b.key  (1) = 0; /* base of keys used        */dcl b.alt  (lib_size) fixed; b.key  (1) = 0; /* base of alt keys used    */dcl recurs.parms (lib_size) fixed; /* starting location of canonical recursive parms *//* 'WHEN' handling information structure:..    Each library has a table of labels for 'WHEN' statements.  A table.    is built up with the label and the number of the library it came.    from (libraries are assigned unique numbers during the link process)..    In this way, we will know when to translate the label in RELOCATE.*/dcl when_label   (whentablen - 1) fixed; /* label value table */dcl when_library (whentablen - 1) fixed; /* library number table */dcl device_label (devtablen  - 1) fixed; /* device driver table */dcl special_label(spectablen - 1) fixed; /* special labels      */device_driver: proc(key) fixed; /* returns TRUE if the passed KEY is they key of a device driver */   dcl key fixed; /* key to check */   dcl i   fixed;   do i = 0 to devtablen - 1; /* search the device table */      if device_label (i) = key then return (1); /* if it's there, it's a driver */   end;   return (0); /* not a device driver */end device_driver;special_driver: proc(key) fixed; /* returns TRUE if the passed KEY is they key of a special routine */   dcl key fixed; /* key to check */   dcl i   fixed;   do i = 0 to spectablen - 1; /* search the special lable table */      if special_label (i) = key then return (1); /* if it's there, it's a driver */   end;   return (0); /* not a special procedure */end special_driver;/* Inform the user of an error on his part. */er.usr: proc(message, details, idetail, lnum, lib, dlib); /* tell the user he did something wrong */   dcl message fixed array; /* the message to print */   dcl details fixed array; /* any details about the error */   dcl idetail fixed; /* integer details */   dcl lnum    fixed; /* line number in library */   dcl lib     fixed; /* library number */   dcl dlib    fixed; /* library it was defined in */   print string(message),;   if details (0) <> 0 /* don't output the null string */   then print ' ', string(details),;   if idetail <> 0 /* don't output details of zero */   then print idetail,;   if lnum <> 0 /* skip for line number of zero */   then print ' at line', lnum,; /* output line number */   if ((lib <> 0) and (lib <> main_lib)) then do; /* skip for library of zero and skip MAIN */      if dlib <> 0 then do; print; print ' ',; end; /* try to be neat */      print ' in ', string(location(addr(lib_name (name_lib (lib))))),;   end;   if dlib <> 0 /* output the defining library if necessary */   then print ' (defined in ', string(location(addr(lib_name (name_lib (dlib))))), ')',;   print '.';   link_error = -1; /* abort when we're done */end er.usr;/* Symbol table routines:..    The symbol table contains the symbol name and information about.    the symbol (such as its location, whether it was defined, and its.    type bits).  To locate a symbol, a hash function is performed on.    the symbol, the result pointing into the vector HASHTAB.  The value.    in HASHTAB points to corresponding vectors which contain:  a pointer.    to the next symbol from the hash bucket (NXT_SYM), the location in.    memory where the symbol will be (LOC_SYM), flags specifying the.    definition and use of a symbol (PUBEXT_SYM), and a pointer to the.    text of the symbol in STABLE (PTR_SYM)...    STABLE contains both the text of and the type bits for the symbol..    If the type bits are zero, the symbol will match anything.  The.    symbol is in XPL string format (character length in first word,.    followed by the characters packed two to a word).  The length (in.    words) of the type bits directly follow the symbol.  This length.    is followed by the type bits themselves.  This is also the format.    of NAME which contains the current symbol in use...    The following variables are used solely by the symbol table routines: *//* type information (stored after symbol in STABLE) */dcl ti.len  lit '0'; /* length of type info */dcl ti.typ  lit '1'; /* type of symbol or returns type for proc */dcl ti.args lit '2'; /* number of arguments (proc only) */dcl ti.atyp lit '3'; /* start of argument type list (proc only) */dcl hashtab (hash_size) fixed; call blockset (hashtab, hash_size + 1, -1); /* the hash table */dcl stable.ptr          fixed; /* pointer to the symbol table */dcl max_symbols         fixed; /* maximum number of symbols allowed */dcl stable_size         fixed; /* size of symbol table */dcl stxmem              fixed; stxmem = 0; /* TRUE if symbol table in external memory */dcl nxt_sym.ptr    fixed; /* pointer to next symbol in hash bucket */dcl loc_sym.ptr    fixed; /* location of symbol at runtime */dcl pubext_sym.ptr fixed; /* definition and usage flags */dcl ptr_sym.ptr    fixed; /* pointer to symbol name in STABLE */dcl type_sym.ptr   fixed; /* type of symbol */dcl deflib_sym.ptr fixed; /* number of the library the symbol was defined in */dcl lnum_sym.ptr   fixed; /* line number symbol was defined on */dcl store_sym.ptr  fixed; /* storage used by the symbol */dcl loc_args.ptr   fixed; /* location of first argument in procedure argument list (WARNING: assumes the remaining args follow consecutively) */dcl sort_sym.ptr   fixed; /* symbol table pointers for sorting (GENSYM only) */dcl nextstable     fixed; /* next free STABLE area */dcl nextsym        fixed; /* next free symbol area */dcl name  (name_size)     fixed; /* current symbol */dcl gname (name_size + 3) fixed; /* symbol returned by GET_SYM/GET_TYP (only if from external memory - round to nearest multiple of 4) */setup_linker: proc(max_symbols, stable_size); /* set up linker symbol table pointers */   dcl max_symbols fixed; /* maximum number of symbols */   dcl stable_size fixed; /* size of symbol table */   nxt_sym.ptr    = stable.ptr     + stable_size; /* set up linker tables */   loc_sym.ptr    = nxt_sym.ptr    + max_symbols;   pubext_sym.ptr = loc_sym.ptr    + max_symbols;   ptr_sym.ptr    = pubext_sym.ptr + max_symbols;   type_sym.ptr   = ptr_sym.ptr    + max_symbols;   deflib_sym.ptr = type_sym.ptr   + max_symbols;   lnum_sym.ptr   = deflib_sym.ptr + max_symbols;   store_sym.ptr  = lnum_sym.ptr   + max_symbols;   loc_args.ptr   = store_sym.ptr  + max_symbols;   sort_sym.ptr   = loc_args.ptr   + max_symbols;end setup_linker;/*  */stable: proc(index) fixed; /* return contents of STABLE (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = stable.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(stable.ptr + index)); /* internal memory */end stable;get_sym: proc(ptr) fixed; /* get address of symbol starting at STABLE (PTR) [equiv to ADDR(STABLE (PTR))] */   dcl ptr fixed; /* pointer to symbol */   dcl i   fixed;   if stxmem <> 0 then do; /* external memory */      write(mam) = stable.ptr + shr(ptr, 8);      write(mal) = ptr;      do i = 0 to shr(read(md) + 1, 1) by 4; /* copy name to internal memory in groups of 4 */         write(r0) = addr(gname (i)); /* point to next string location */         write(mr0i) = read(mdi); write(mr0i) = read(mdi); write(mr0i) = read(mdi); write(mr0i) = read(mdi);      end;      return (addr(gname (0))); /* return pointer to symbol */   end; /* of external memory */   else return (stable.ptr + ptr); /* internal memory - return pointer */end get_sym;get_typ: proc(ptr) fixed; /* get address of type info for symbol starting at STABLE (PTR) [equiv to ADDR(STABLE (PTR + ?))] */   dcl ptr fixed; /* pointer to symbol */   dcl i   fixed;   if stxmem <> 0 then do; /* external memory */      write(mam) = stable.ptr + shr(ptr, 8);      write(mal) = ptr;      ptr = ptr + shr(read(md) + 3, 1); /* point to type info */      write(mam) = stable.ptr + shr(ptr, 8);      write(mal) = ptr;      do i = 0 to read(md) by 4; /* copy type info to internal memory in groups of 4 */         write(r0) = addr(gname (i)); /* point to next string location */         write(mr0i) = read(mdi); write(mr0i) = read(mdi); write(mr0i) = read(mdi); write(mr0i) = read(mdi);      end;      return (addr(gname (0))); /* return pointer to type info */   end; /* of external memory */   else do; /* internal memory */      ptr = ptr + shr(core(stable.ptr + ptr) + 3, 1); /* point to type info */      return (stable.ptr + ptr); /* return pointer */   end; /* of internal memory */end get_typ;/*  */nxt_sym: proc(index) fixed; /* return contents of NXT_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = nxt_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(nxt_sym.ptr + index)); /* internal memory */end nxt_sym;set_nxt_sym: proc(index, value); /* set NXT_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = nxt_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(nxt_sym.ptr + index) = value; /* internal memory */end set_nxt_sym;loc_sym: proc(index) fixed; /* return contents of LOC_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = loc_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(loc_sym.ptr + index)); /* internal memory */end loc_sym;set_loc_sym: proc(index, value); /* set LOC_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = loc_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(loc_sym.ptr + index) = value; /* internal memory */end set_loc_sym;pubext_sym: proc(index) fixed; /* return contents of PUBEXT_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = pubext_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(pubext_sym.ptr + index)); /* internal memory */end pubext_sym;set_pubext_sym: proc(index, value); /* set PUBEXT_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = pubext_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(pubext_sym.ptr + index) = value; /* internal memory */end set_pubext_sym;/*  */ptr_sym: proc(index) fixed; /* return contents of PTR_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = ptr_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(ptr_sym.ptr + index)); /* internal memory */end ptr_sym;set_ptr_sym: proc(index, value); /* set PTR_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = ptr_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(ptr_sym.ptr + index) = value; /* internal memory */end set_ptr_sym;type_sym: proc(index) fixed; /* return contents of TYPE_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = type_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(type_sym.ptr + index)); /* internal memory */end type_sym;set_type_sym: proc(index, value); /* set TYPE_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = type_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(type_sym.ptr + index) = value; /* internal memory */end set_type_sym;/*  */deflib_sym: proc(index) fixed; /* return contents of DEFLIB_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = deflib_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(deflib_sym.ptr + index)); /* internal memory */end deflib_sym;set_deflib_sym: proc(index, value); /* set DEFLIB_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = deflib_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(deflib_sym.ptr + index) = value; /* internal memory */end set_deflib_sym;lnum_sym: proc(index) fixed; /* return contents of LNUM_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = lnum_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(lnum_sym.ptr + index)); /* internal memory */end lnum_sym;set_lnum_sym: proc(index, value); /* set LNUM_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = lnum_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(lnum_sym.ptr + index) = value; /* internal memory */end set_lnum_sym;store_sym: proc(index) fixed; /* return contents of STORE_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = store_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(store_sym.ptr + index)); /* internal memory */end store_sym;set_store_sym: proc(index, value); /* set STORE_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = store_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(store_sym.ptr + index) = value; /* internal memory */end set_store_sym;/*  */loc_args: proc(index) fixed; /* return contents of LOC_ARGS (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = loc_args.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(loc_args.ptr + index)); /* internal memory */end loc_args;set_loc_args: proc(index, value); /* set LOC_ARGS (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = loc_args.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(loc_args.ptr + index) = value; /* internal memory */end set_loc_args;sort_sym: proc(index) fixed; /* return contents of SORT_SYM (INDEX) */   dcl index fixed; /* index into array */   if stxmem <> 0 then do; /* external memory */      write(mam) = sort_sym.ptr + shr(index, 8);      write(mal) = index;      return (read(md));   end;   else return (core(sort_sym.ptr + index)); /* internal memory */end sort_sym;set_sort_sym: proc(index, value); /* set SORT_SYM (INDEX) to VALUE */   dcl index fixed; /* index into array */   dcl value fixed; /* value to set element to */   if stxmem <> 0 then do; /* external memory */      write(mam) = sort_sym.ptr + shr(index, 8);      write(mal) = index;      write(md)  = value;   end;   else core(sort_sym.ptr + index) = value; /* internal memory */end set_sort_sym;/* Hash and S.lookup: */  hash: proc(name) fixed; /* hash a string */   dcl name array; /* string to hash */   return ((name (0) + shr(name (1), 2)) and hash_size); /* return the hashed value */end hash; /* This routine will try to find the symbol stored in 'NAME' in the.  symbol table (STABLE).  A pointer to the corresponding vectors NXT_SYM,.  LOC_SYM, etc. is returned if the symbol is found.  Otherwise a minus one.  is returned. */ s.lookup: proc fixed; /* returns 0 if not found; else ptr to STABLE */   dcl sym.pt  fixed; /* pointer to symbol */   dcl name.pt fixed; /* pointer to symbol name */   sym.pt = hashtab (hash (name)); /* point into symbol table */   do while (sym.pt <> -1); /* search down linked list */      name.pt = ptr_sym (sym.pt); /* point to symbol name */      if ((stable (name.pt) = name (0)) /* don't STRCMP unless the length matches */      and (strcmp (name, loc(get_sym (name.pt))) = 0)) /* if the symbol name matches */      then return (sym.pt); /* found */      sym.pt = nxt_sym (sym.pt); /* point to next */   end;   return (-1); /* not found */end s.lookup;/* S.define and Sym.dump: */ /* This procedure is called to define a new symbol.  It is STRONGLY.  recommended that S.LOOKUP is called before S.DEFINE (as S.LOOKUP.  removes trailing nulls). */ s.define: proc fixed; /* returns pointer to defined symbol */   dcl i fixed;   call set_pubext_sym (nextsym, 0); /* we know nothing about this symbol's use or definition yet */   call set_loc_sym    (nextsym, 0); /* nor do we know its location at runtime */   call set_loc_args   (nextsym, 0); /* nor its arguments' locations (if any) */   call set_ptr_sym    (nextsym, nextstable); /* point to STABLE entry */   i = shr(name (0) + 1, 1) + 1; /* get word length of name (inc. len) */   i = i + name (i) + 1; /* add in length of type bits (inc. len) */   if nextstable ige stable_size - i /* check for symbol table overflow */   then call er.ftl ('Too many public symbols defined (symbol table overflow)'); /* abort */   if stxmem <> 0 /* external memory */   then call export (stable.ptr, nextstable, name, i); /* copy into table */   else call blockmove (name, loc(stable.ptr + nextstable), i); /* internal memory */      nextstable = nextstable + i; /* it's in there now */   /* the symbol is now in STABLE; now put it in HASHTAB */      i = hash (name); /* hash that symbol */   call set_nxt_sym (nextsym, hashtab (i)); /* point to first bucket entry */   hashtab (i) = nextsym; /* and make HASHTAB point to this symbol */       nextsym = nextsym + 1; /* point to the next free symbol area */   if nextsym ige max_symbols /* check for overflow */   then call er.ftl ('Too many public symbols defined'); /* abort */   return (nextsym - 1); /* return pointer to this symbol */end s.define; sym.dump: proc; /* dump the symbol table (used for debugging and diagnostics) */   dcl i fixed;     print;   print 'Symbol table:';   print 'pubext  loc     argloc  lineno  type    storage  name      symlen';   do i = 0 to nextsym - 1;      print pubext_sym (i), '  ', loc_sym (i), '  ', loc_args (i), '  ', lnum_sym (i), '  ', type_sym (i), '  ',;      print store_sym (i), '   >', string(loc(get_sym (ptr_sym (i)))), '<  ', stable (ptr_sym (i));   end;end sym.dump;/* Add a library to the library structure (LIB_NAME and NAME_LIB). */ add_lib: proc(lname); /* add a library to our list of libraries referenced */   dcl lname array; /* filename */   dcl i     fixed;      save_tab: proc(word) fixed; /* save a word in the names table */      dcl word fixed; /* word to save */      next_lib_name = next_lib_name + 1; /* point to next available word */      if next_lib_name ige lib_name_size /* check for overflow */      then call er.ftl ('Too many libraries referenced (library table overflow)'); /* abort */      lib_name (next_lib_name) = word; /* save next word */      return (next_lib_name); /* return a pointer to the word just stored */   end save_tab;    find_lib: proc(lname) fixed; /* return TRUE if library already found */      dcl lname  fixed array; /* name of library to search for */      dcl len    fixed; /* length of the library name */      dcl (i, j) fixed;      do i = 1 to next_lib; /* see if this library already exists */         len = shr(lname (0) + 1, 1); /* get length of current name */                  if i < next_lib /* make sure we don't point past the end of NAME_LIB */         then j = name_lib (i + 1); /* end of name is start of next name */         else j = next_lib_name + 1; /* end of name is ending pointer */         if len = j - name_lib (i) - 1 /* is the word length the same as one already there? */         then do; /* yes, see if they're really the same */            j = 0;            do while ((j <= len) and (toupper (lname (j)) = toupper (lib_name (j + name_lib (i))))); /* compare each word */               j = j + 1;            end;            if j > len /* did we find a perfect match? */            then return (1); /* sure did */         end;      end;      return (0); /* no match */   end find_lib;   if not find_lib (lname) /* make sure the library isn't already there */   then do; /* it isn't - add it */      next_lib = next_lib + 1; /* point to next library table entry */      if next_lib ige lib_size /* check for overflow */      then call er.ftl ('Too many libraries referenced'); /* abort */      name_lib (next_lib) = save_tab (lname (0)); /* save length and point to name */      do i = 1 to shr(lname (0) + 1, 1); /* save the name */         call save_tab (lname (i));      end;   end;end add_lib;