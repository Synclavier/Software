/* XPL Symbol Table Generator:..  Modification history:.    23 Apr 1981:  Added D107INT and (PTYPE and STYPE) [CEW].    11 Oct 1983:  Added MODULE, LIBRARY, RETURNS, EXTERNAL, PUBLIC, and FORWARD [KJC].    10 Feb 1984:  Removed FORWARD [KJC].    16 Feb 1984:  Rearranged statement types to clean up pass1 to pass2 interfile [KJC].    20 Feb 1984:  Moved INSERT back into pass1 to pass2 interfile [KJC].    24 Feb 1984:  Added RECURSIVE [KJC].    20 Jul 1984:  Removed SETPOS, GETPOS, DOUBLEMAXI, and DOUBLEMINI [KJC].     9 Aug 1984:  Removed INC, DMA, NODMA; Added MODELC, DMINI, BLOCKMOVE, BLOCKSET [KJC].    14 Sep 1984:  Added SWAP [KJC].    19 Sep 1984:  Added EXPORT, IMPORT, EXTSET, and SWAPINIT [KJC].    19 Nov 1984:  Added SET_CURDEV and FIND_DEVICE/Removed EOF [KJC].    23 Jan 1985:  Changed D14INT to D66INT [KJC].    15 Apr 1985:  Removed MODELA, added SMINI [KJC].    20 Jul 1985:  Added EXTREAD, EXTWRITE, POLYREAD, POLYWRITE [KJC].    28 Oct 1985:  Added D24INT, INVOKE [KJC].    20 Feb 1986:  Removed DISKREAD, DISKWRITE, SHR1, SHL1, ROT8, PATCH [KJC].    25 Mar 1986:  Added LOC, CHR [KJC].    15 Sep 1986:  Changes for -7 catalog structure [KJC].    22 Oct 1986:  Added BOOLEAN, POINTER, PTR [KJC].     7 Nov 1986:  Added STATIC, AUTOMATIC [KJC].    17 Mar 1987:  Added TRUE, FALSE/Removed PTR [KJC].    29 May 1987:  Removed DTOINT, DTIINT, D43INT, PNULLS, SNULLS; Added D136INT, D137INT, NULL [KJC].    10 Sep 1987:  Added D132INT [KJC].    17 Aug 1988:  Added DSP70INT [KJC].    18 Aug 1988:  Added SWAPCODE [AWG].    27 Sep 1988:  Changed D107INT to D115INT [KJC].    29 Sep 1988:  Added MODELD for CONFIGURATION statement [AWG]*/insert ':xpl611:defs';insert ':xpl611:p1-defs';insert ':xpl611:p12-defs';  /* Procedures to build symbol table: */  dcl buf (1023) fixed; /* output buffer */dcl ptr fixed; /* byte pointer into output buffer */  pc: proc(byt); /* put character into output file */  dcl byt fixed;  call pbyte(buf, ptr, byt); /* store byte */  ptr = ptr + 1; /* increment */  if ptr > shl(1023, 1) then do; print 'Error: symbol table overflow.'; call exit(-1); end;end pc;  symbol: proc(nam, typ, inf); /* and emit a symbol */  dcl nam array;  dcl typ fixed;  dcl inf fixed;  dcl i fixed;  i = nam (0);  call pc (i);  do i = 0 to i - 1; call pc (byte(nam, i)); end;  if ((inf or typ) and "177400") <> 0 then do; /* larger than one byte */    print 'Error: info field too large for symbol ', string(nam), '.';  end;  call pc (typ); /* emit type - bytes only */  call pc (inf);end symbol; /* Procedure to define a runtime package canned procedure.  This routine.  takes six arguments:  the name of the procedure, the transfer vector.  address, the number of arguments (must be less than four), and four.  argument types (all must be supplied even if only some are to be used). */ fixit: proc(arg);  dcl arg fixed;  if (arg = t.var) or (arg = t.fvar)   then return arg;  else return (arg or t.pvar); /* else is pointer to array */end fixit;  defrtp: proc(name, addr, numarg, type, arg1, arg2, arg3, arg4);  dcl name array;  dcl (addr, numarg, type, arg1, arg2, arg3, arg4) fixed;  dcl i fixed;  i = name (0);  call pc (i);  do i = 0 to i - 1;     call pc (byte(name, i));  end;  if ((numarg or addr or type or arg1 or arg2 or arg3 or arg4) and "177400") <> 0 then print 'Error: argument type too large for ', string(name), '.'; /* restrict to lower byte */  call pc (addr); call pc (numarg);  arg1 = fixit (arg1); arg2 = fixit (arg2); arg3 = fixit (arg3); arg4 = fixit (arg4);  call pc (type);  call pc (arg1); call pc (0);  call pc (arg2); call pc (0);  call pc (arg3); call pc (0);  call pc (arg4); call pc (0);end defrtp;/* First define operator symbols: */print 'Creating symbol table.  Please wait...';  call symbol ('ABS', t.opr, o.math + 0);call symbol ('LOG', t.opr, o.math + 1);call symbol ('ATN', t.opr, o.math + 2);call symbol ('COS', t.opr, o.math + 3);call symbol ('SIN', t.opr, o.math + 4);call symbol ('TAN', t.opr, o.math + 5);call symbol ('EXP', t.opr, o.math + 6);call symbol ('SQR', t.opr, o.math + 7);call symbol ('INT',  t.opr, o.int);call symbol ('READ', t.opr, o.read);call symbol ('CORE', t.arr, 0);call symbol ('ADDR', t.opr, o.adr);call symbol ('NOT', t.opr, o.not);call symbol ('SHR', t.sdy, o.shr);call symbol ('SHL', t.sdy, o.shl);call symbol ('ROT', t.sdy, o.rot);call symbol ('MOD',  t.opr, o.mod);call symbol ('FDIV', t.opr, o.fdi);call symbol ('AND', t.opr, o.and);call symbol ('OR',  t.opr, o.or);call symbol ('XOR', t.opr, o.xor);call symbol ('IEQ', t.opr, o.eq);call symbol ('ILT', t.opr, o.ilt);call symbol ('ILE', t.opr, o.ile);call symbol ('IGT', t.opr, o.igt);call symbol ('IGE', t.opr, o.ige);call symbol ('INE', t.opr, o.ne);  /* Build symbol table:  Statements and keywords. */ call symbol ('CALL',          t.stmt, s.call);call symbol ('RETURN',        t.stmt, s.return);call symbol ('PROC',          t.stmt, s.proc);call symbol ('PROCEDURE',     t.stmt, s.proc);call symbol ('BEGIN',         t.stmt, s.begin);call symbol ('DO',            t.stmt, s.do);call symbol ('IF',            t.stmt, s.if);call symbol ('GOTO',          t.stmt, s.goto);call symbol ('ENABLE',        t.stmt, s.enable);call symbol ('DISABLE',       t.stmt, s.disable);call symbol ('STOP',          t.stmt, s.stop);call symbol ('WRITE',         t.stmt, s.write);call symbol ('LINPUT',        t.stmt, s.linput);call symbol ('INPUT',         t.stmt, s.input);call symbol ('PRINT',         t.stmt, s.print);call symbol ('SEND',          t.stmt, s.send);call symbol ('WHEN',          t.stmt, s.when);call symbol ('INVOKE',        t.stmt, s.invoke);call symbol ('MODULE',        t.stmt, s.module);call symbol ('LIBRARY',       t.stmt, s.library);call symbol ('INSERT',        t.stmt, s.insert);call symbol ('DCL',           t.stmt, s.declare); /* pass1 only emits these in special cases (stack allocation) */call symbol ('DECLARE',       t.stmt, s.declare);call symbol ('ENTER',         t.stmt, s.enter); /* start of statements processed by pass1 only */call symbol ('PDL',           t.stmt, s.pdl);call symbol ('RAM',           t.stmt, s.ram);call symbol ('CONFIGURATION', t.stmt, s.config);  /* Keywords: */  call symbol ('LOC',       t.locat,  0); /* array specifier */call symbol ('LOCATION',  t.locat,  0); /* array specifier */call symbol ('CHR',       t.pform,  1); /* print format */call symbol ('CHARACTER', t.pform,  1); /* print format */call symbol ('OCTAL',     t.pform,  0); /* print format */call symbol ('STRING',    t.string, 0); /* print format */call symbol ('EOF',       t.eof,    0);call symbol ('WHILE',     t.while,  0);call symbol ('CASE',      t.case,   0);call symbol ('TO',        t.to,     0);call symbol ('BY',        t.by,     0);call symbol ('END',       t.end,    0);call symbol ('THEN',      t.then,   0);call symbol ('ELSE',      t.else,   0);call symbol ('READ',      t.opr,    o.read);call symbol ('RETURNS',   t.rtns,   0); /* definition of procedure return value */call symbol ('RECURSIVE', t.recurs, 0); /* define a procedure to be recursive */call symbol ('SWAP',      t.swap,   0); /* define a procedure to be swappable */call symbol ('SWAPCODE',  t.swpcode,0); /* allows swapping but not of string constants or data arrays */ /* Symbol types for declarations: */ call symbol ('FIXED',     t.type, t.var);call symbol ('BOOLEAN',   t.type, t.var);call symbol ('POINTER',   t.type, t.var);call symbol ('ARRAY',     t.type, t.arr);call symbol ('FLOATING',  t.type, t.fvar);call symbol ('LABEL',     t.type, 5);call symbol ('LIT',       t.type, 6);call symbol ('LITERALLY', t.type, 6);call symbol ('DATA',      t.type, 7);call symbol ('EXTERNAL',  t.storage, t.extern); /* external reference */call symbol ('PUBLIC',    t.storage, t.public); /* external definition */call symbol ('STATIC',    t.storage, s.static); /* static variable */call symbol ('AUTOMATIC', t.storage, s.automatic); /* automatic variable */call symbol ('TRUE',  t.const, 1); /* boolean TRUE */call symbol ('FALSE', t.const, 0); /* boolean FALSE */call symbol ('NULL',  t.const, 0); /* null pointer */  /* Dynamic construction of symbol table:  Interrupt keywords..  .   The format for processing interrupts via the WHEN statement is:.   .      when lncint then do;.         anything;.         anything;.      end;.   .   or:.   .      when lncint then lbsyflg = 0;.   .   The following interrupt cell identifier names are recognized:*/  call symbol ('BREAK',     t.icell,  0);call symbol ('TTOINT',    t.icell,  1);call symbol ('TTIINT',    t.icell,  2);call symbol ('D16INT',    t.icell,  5);call symbol ('D03INT',    t.icell,  7);call symbol ('DISKERROR', t.icell,  8);call symbol ('D140INT',   t.icell,  9);call symbol ('D136INT',   t.icell, 10);call symbol ('D137INT',   t.icell, 11);call symbol ('D115INT',   t.icell, 13);call symbol ('BDB14INT',  t.icell, 14);call symbol ('BDB15INT',  t.icell, 15);call symbol ('D40INT',    t.icell, 16); /* start of D54 acknowledge: ID = 16 + BDB # */call symbol ('D42INT',    t.icell, 17);call symbol ('D44INT',    t.icell, 18);call symbol ('D46INT',    t.icell, 19);call symbol ('D66INT',    t.icell, 20);call symbol ('D24INT',    t.icell, 23);call symbol ('D30INT',    t.icell, 24);call symbol ('D31INT',    t.icell, 25);call symbol ('D32INT',    t.icell, 26);call symbol ('D33INT',    t.icell, 27);call symbol ('D34INT',    t.icell, 28);call symbol ('D35INT',    t.icell, 29);call symbol ('D36INT',    t.icell, 30);call symbol ('D37INT',    t.icell, 31);call symbol ('DSP70INT',  t.icell, 40); /* start of D55 acknowledge: ID = 32 + BDB # */call symbol ('D132INT',   t.icell, 43);/* Symbols for CONFIGURATION statement: */call symbol ('MAXI',       t.config,  0);call symbol ('MINI',       t.config,  1);call symbol ('DMINI',      t.config,  2);call symbol ('SMINI',      t.config,  3);call symbol ('MODELB',     t.config,  4);call symbol ('MODELC',     t.config,  5);call symbol ('MODELD',     t.config,  6);call symbol ('MEMORY',     t.config,  7);call symbol ('MULDIV',     t.config,  8);call symbol ('NOMULDIV',   t.config,  9);call symbol ('PTYPE',      t.config, 10);call symbol ('STYPE',      t.config, 11);/* Runtime package routine names: */  call pc (0); /* one byte to separate labels, RTPs */call defrtp ('EXIT',          l.ter, 1, t.var, t.var, 0, 0, 0);call defrtp ('BYTE',          l.byt, 2, t.var, t.arr, t.var, 0, 0);call defrtp ('PBYTE',         l.pbt, 3, t.var, t.arr, t.var, t.var, 0);call defrtp ('RCVDCHARACTER', l.ich, 0, t.var, 0, 0, 0, 0);call defrtp ('BLOCKMOVE',     l.bmv, 3, t.var, t.arr, t.arr, t.var, 0);call defrtp ('BLOCKSET',      l.bst, 3, t.var, t.arr, t.var, t.var, 0);call defrtp ('EXPORT',        l.ept, 4, t.var, t.var, t.var, t.arr, t.var);call defrtp ('IMPORT',        l.ipt, 4, t.var, t.var, t.var, t.arr, t.var);call defrtp ('EXTSET',        l.est, 4, t.var, t.var, t.var, t.var, t.var);call defrtp ('READDATA',      l.rfl, 4, t.var, t.var, t.var, t.arr, t.var);call defrtp ('WRITEDATA',     l.wfl, 4, t.var, t.var, t.var, t.arr, t.var);call defrtp ('SWAPINIT',      l.swi, 1, t.var, t.var, 0, 0, 0);call defrtp ('FIND_DEVICE',   l.fde, 1, t.var, t.var, 0, 0, 0);call defrtp ('SET_CURDEV',    l.scur,1, t.var, t.var, 0, 0, 0);call defrtp ('EXTREAD',       l.erd, 3, t.var, t.var, t.var, t.arr, 0);call defrtp ('EXTWRITE',      l.ewr, 3, t.var, t.var, t.var, t.arr, 0);call defrtp ('POLYREAD',      l.prd, 4, t.var, t.var, t.var, t.arr, t.var);call defrtp ('POLYWRITE',     l.pwr, 4, t.var, t.var, t.var, t.arr, t.var);  call pc (0); /* and a final zero *//* Write the symbol table to disk: */print 'Symbol table complete.  Number of bytes:', ptr;insert ':-xpl:literals';insert ':-xpl:catrtns';dcl catbuf (c#dir_max - 1) fixed;dcl nbuf   (64)            fixed;print;print 'Filename of symbol table? ',;linput nbuf; nbuf (0) = nbuf (0) - 1; /* discard carriage return */ptr = shr(ptr + 1, 1); /* convert bytes to words */call set_catbuf (addr(catbuf (0)), 0);if replace (nbuf, t#data, 0, shr(ptr + 255, 8), ptr, 1) then do;   call writedata (f#ms_sector, f#ls_sector, location(addr(buf (1))), ptr);   print 'The new symbol table is now saved in file "', string(nbuf), '".';end;else print 'Unable to save file "', string(nbuf), '".';