/* Model C shift functions: */if x.node (arg2) = x.const then do; /* handle constant shifts */  x.i = x.info (arg2); /* get number of shifts */  reg.d = in.reg (arg1, 0); /* get ARG1 in any register */  if opr = o.rot then x.i = (x.i and 15); /* modulo 16 for rotate */  else if x.i IGT 16 then x.i = 16; /* check for neg, or > 16 */  do while x.i >= 8; /* modulo 8 do with rotate */    call emitc (0, b.bsor + bitreg (reg.d)); /* rotate 8 times */    if      opr = o.shl then call emitc ("177400", b.ad + b.and + bitreg (reg.d)); /* extract upper */    else if opr = o.shr then call emitc (255, b.ad + b.and + bitreg (reg.d)); /* else lower */    x.i = x.i - 8;   end;   if x.i <= 2 then do tmp = 1 to x.i; /* now finish shift (for small numbers do in-line) */     do case (opr - o.shr);  /* branch on shift type */       call emitc (0, b.shra + bitreg (reg.d)); /* shift right */       call emita (b.rs + bitreg (reg.d), b.ad + b.add + bitreg (reg.d)); /* shift left */       call emitc (0, b.ad + b.lef + bitreg (reg.d)); /* rotate left */     end;  end;  else do; /* for larger numbers, use REPEAT */    call emita (b.is + ((x.i - 1) and b.imsk), "10"); /* im(shift - 1) to d10 - load repeat counter */    do case (opr - o.shr);  /* branch on shift type */      call emitc (0, b.shra + bitreg (reg.d)); /* shift right */      call emita (b.rs + bitreg (reg.d), b.ad + b.add + bitreg (reg.d)); /* shift left */      call emitc (0, b.ad + b.lef + bitreg (reg.d)); /* rotate left */    end;  end;end;else begin; /* must use REPEAT only */  reg1 = in.reg (arg1, reg2); /* get first argument in any accumulator (but don't wipe out REG2 if it's already loaded) */  reg2 = in.reg (arg2, reg1); /* and get second (anywhere but REG1)*/  tmp = gkey; /* get a key for the transfer */  call emita (b.is + 0, b.td + b.tad + bitreg (reg2)); /* im(0) to tadd0 - check if it's zero */  call em.tra (b.tze, tmp); /* skip if zero */  call emita (b.is + 1, b.ad + b.sub + bitreg (reg2)); /* im(1) to subX - subtract one from the count */  call emita (b.rs + bitreg (reg2), "10"); /* reg2 to d10 - load repeat counter */  do case (opr - o.shr);  /* branch on shift type */    call emitc (0, b.shra + bitreg (reg1)); /* shift right */    call emita (b.rs + bitreg (reg1), b.ad + b.add + bitreg (reg1)); /* shift left */    call emitc (0, b.ad + b.lef + bitreg (reg1)); /* rotate left */  end;  call em.lde (tmp); /* end of shift is here */  reg.free = (reg.free or reg2);  reg.d = reg1; /* REG2 is now free, answer is in REG1 */end; /* if shift/rotate with no constant */