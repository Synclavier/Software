/* 06/01/89 - cj - fixed "off by 1" bug with jump optimization *//*  $$Initialize for iterative scan through the intermediate file - KEYFLAG.   contains all zeroes at this point, so all keys are "unknown". */   clearstkptr: proc;     /* handy routine to clear both stack */      stkptr = 0;         /* pointers                          */      altstkptr = 0;   end;   iter = 0; /* first iteration is the 0th */   jumps = 0; /* no jumps to jumps optimized out yet */   swaps = 0; /* no swap table yet */   tosskey = 0; /* we aren't tossing anything here */   ramptr = 0; /* initialize ram deleted stack (only done during ITER 0 of JUMPS) */   sconptr = 0; /* initialize scon deleted stack (only done during ITER 0 of JUMPS) */   scon.loc = 0; /* start SCON/data at location zero */   swap_key = 0; /* no swappable proc yet */   proclevel = 0;   whenlevel = 0;   whenproc  = 0;   call blockset (not_always, et.max + 1, 1); /* assume no records are always processed */   do key = 1 to always_process (0); /* set up NOT_ALWAYS */      not_always (always_process (key)) = 0; /* always process this type of record */   end;   /* make procedures and device drivers active */   do key = l.icell to l.icell + whentablen - 1; /* make all WHEN statements active (since they are) */      if r (key) <> 0 then call set_keyflag (r (key), abit);   end;   do key = 0 to devdrivers - 1; /* make all device drivers active (since they are) */      if device_label (key) <> 0 then call set_keyflag (device_label (key), abit);   end;   do while ((iter < 2) or altf or (not (jumps and swaps))); /* 2 times min (before JUMPS and after JUMPS) */      iteration = iteration + 1; /* count for stat printout */      cur.loc = 0;   /* start code at location zero */      altf = 0;      /* indicate not altered */      active = 1;    /* initial code is active */      insert# = 0; deleted = 0; /* haven't seen any INSERT statements and haven't deleted any either */      istkptr = 0;   /* reset istk pointer in case we have too many */      stkptr = 0;    /* clean up stack initially */      altstkptr = 0; /* also alternate stack     */      do key = 0 to rtp.ptrs - 1; /* initialize list of called subs */         rtpsubs (key) = 0;       end;       call resetif (0); /* reset the IF */      /* Initialize the following variables for all iterations:    */      /* compute where first swap procedure would sit in ext memory */      /* based upon how many were defined in the last iteration,    */      /* hence upon the size of the swap look up table:             */      if prctyp < 3 then do;  /* Model A, B, C - use 3 stride table */        swap_total = shr(swap_procs*3 + 1, 8); /* set sector length to length of lookup table */        swap_words = ((swap_procs*3 + 1) and "377"); /* set word length to length of lookup table */      end;      else do;                /* Model d: reserve 64 words, use 4 stride table */        swap_total = shr(swap_procs*4 + 65, 8); /* set sector length to length of lookup table */        swap_words = ((swap_procs*4 + 65) and "377"); /* set word length to length of lookup table */      end;      /* Actually write the swap table out to the intermediate file */      /* during the one pass that swaps <> 0.   Also set swap_total */      /* and swap_words to equal the length of the swap table (plus */      /* header) so that they point to where the first swapping     */      /* proc will actually go:                                     */      if (swaps and (swap_procs <> 0)) then do;         ovdev = ifdev; ovstart = ifstart + ifsecln; /* start immediately after the IF */         if ovstart ilt ifstart then ovdev = ovdev + 1; /* carry */         if swap_total + (swap_words <> 0) igt ovmaxln /* make sure .WORK can hold it */         then call er.ftl ('.WORK not large enough to create swap file'); /* oops! */         /* For Model D compilations,  emit 64 words at the front of */         /* swap file that contains the object code used to switch   */         /* pages:                                                   */         if prctyp >= 3 then do;            do temp = rfbuf (l.sta) + 1 to rfbuf (l.sta) + 64; /* copy 64 words */               call writeovr(rfbuf(temp));            end;         end;         call writeovr (swap_procs); /* write out number of overlays */         rtpsubs (l.swap) = 1; /* make sure we include "call swapped proc" routine */      end; /* of emitting swap table header */      /* reset variables for next iteration: */            swap_procs = 0;   /* reset swap proc counter for next iteration */      swap_size = 0;    /* reset size for next iteration              */      swap_scon = 0;    /* reset size of largest scon data area       */      scon.loc = 0;     /* restart SCON/data at location zero         */      swapscon = 1;     /* start swapping scon pointer (starts at ONE */      anyscon  = 0;     /* to avoid zero (-0 = 0))                    *//*  $$Iterative optimization phase (cont.): */        key = readif; /* get first word of IF */      do while (key <> et.eof);        /* stop at eof */         if  (swapdata  <> 0     )     /* if we had been scanning data */         and (key       <> et.cpy)     /* and we are not now           */         then do;                      /* add it to list if SWAPS      */            if swaps                   /* if emitting swapping code    */            then call addswap (scon.loc - 1, 0); /* remember the length */            swapdata = 0; /* only swap copy data records which immediately follow the data definition (which sets this flag) */         end;         /* Quickly find next non-literal word */         if (key and literal.mask) <> 0 then do; /* literal word */            if active then do;               if (jumps and (not swaps))               then call clearstkptr;               cur.loc = cur.loc + 1;    /* literals take one word */               key = readif;             /* get next word of IF    */               do while (key and literal.mask) <> 0;                  cur.loc = cur.loc + 1; /* literals take one word */                  key = readif; /* get first word of IF */               end;            end;            else do while (key and literal.mask) <> 0;               key = readif;            end;         end;         if key = et.eof then do;            /* exit next time */         end;         else if ((not active) and not_always (key)) /* if this doesn't always need to be processed */         then call skiprecord (key); /* skip non-active records */         else do case (key - 1); /* else branch on type */            do; /* literal word */               call readif;               cur.loc = cur.loc + 1;               if (active and jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */            end; /* literal word */     /* Iterative optimization:  process jump instruction..  Examine each jump instruction.   If it is an unconditional jump.  instruction,  then set a flag to indicate the code that follows can.  never be called.  Also detect a jump to a jump instruction, and forward.  the address to the destination of the second jump.*/            do; /* jump instruction */               cond = readif; /* get condition code */               key = readif;  /* get key to jump to */               lcl = cur.loc; /* save CUR.LOC before this instruction (for jump to jump deletion) */               if active then do; /* for active code only */                  if key <> 0 then do; /* ignore clobbered keys (from jmp . => clobbered below if DIST = 10000) */                     call keych (key); /* make sure in range */                     if jumps then do; /* follow jumps to jumps only during JUMPS */                        dist = 0; /* this is infinite loop detector */                        okey = keyjto (key); /* see if this location jumps somewhere */                        do while ((okey <> 0) and (dist < 10000)); /* after 10000, assume we are hung up */                           call set_keyflag (key, keyflag (key) and (not abit)); /* this label is now unknown */                           key = okey; /* make this the new destination */                           okey = keyjto (key);                           dist = dist + 1;                        end;                        if dist = 10000 then key = 0; /* detect infinite loop - key of 0 = jmp . */                        if dist <> 0 then do; /* if we changed the key */                           call writeif (key); /* write out new key */                           altf = 1; /* we've made an alteration */                           if debug then new.loc = (new.loc or 1);                        end;                     end; /* of if JUMPS */                     if key <> 0 then do; /* if key isn't clobbered (i.e., it's jumped to) */                        okey = keyflag (key); /* pick up bits */                        if (okey and abit) = 0 then do; /* see if we need to make it active */                           call set_keyflag (key, okey or abit); /* indicate active */                           altf = 1; /* we've made an alteration */                           if debug then new.active = (new.active or 1);                        end;                     end; /* of it's jumped to */                  end; /* of non-clobbered key */                  ocl = readif; /* get old estimated location */                  if ocl <> cur.loc then do; /* check if loc changed from last pass */                     call writeif (cur.loc); /* write out new location */                     if jumps then do; /* only bother to re-iterate if JUMPS */                        altf = 1; /* the IF changed */                        if debug then new.loc = (new.loc or 2);                     end;                  end; /* of altered loc */                  if ((iter = 0) and (not jumps)) then cur.loc = cur.loc + 2; /* assume 2 before JUMPS */                  else if (skip_opt <> 0)         then cur.loc = cur.loc + 2;                  else if key = 0 then cur.loc = cur.loc + 1; /* detect jmp . */                  else do; /* see if jump instruction fits in one word */                     if (okey and dbit) <> 0 /* already defined this pass */                     then dist = keyloc (key) - cur.loc - 1; /* compute distance based on current iteration */                     else do; /* forward reference jump */                        if ocl = -1 then dist = -32768; /* if inactive last pass, assume long jump */                        else do; /* was active last pass */                           dist = keyloc (key) - ocl - 1; /* forward distance (use values from previous pass) */                           if dist = -1 then dist = 0; /* -1 means previously deleted jmp .+1 */                        end; /* of was active last pass */                     end; /* of forward reference jump */                     if (dist <> 0) or (not(jumps)) then do; /* 0 means jmp .+1 - delete instr - but only after all active code has been identified */                        if emitt (dist)    /* if fits in immediate field */                        then cur.loc = cur.loc + 1; /* then 1 word */                        else cur.loc = cur.loc + 2; /* else 2 words */                     end;                  end; /* of checking if jump instruction fits in one word */               end; /* of active */               else do; /* if we're not active */                  if readif <> -1 then call writeif (-1); /* get old loc - mark inactive if not already marked */               end; /* of not active */               if cond = b.tra then do; /* unconditional transfer? */                  if (jumps and (not swaps)) /* if deleting jumps to jumps */                  then do;                     do while (stkptr <> 0); /* see if any labels at this location (unstack label defs) */                        ocl = pop; okey = pop; /* get location, its key */                        if ocl = lcl /* see if instruction at this label is jump (LCL is set to CUR.LOC at top) */                        then call set_keyjto (okey, key); /* indicate jmp to jmp */                     end;                     altstkptr = 0; /* cannot jump to jumps of different key types */                  end;                  active = 0; /* inactive code follows unconditional transfers */               end; /* of unconditional transfer */            end; /* of jump *//*  $$Iterative optimization phase (continued): */            do; /* proc call */               lcl = readif; /* get length of record */               key = readif; /* get key */               call keych (key);               do dist = 1 to lcl - 1; /* examine formal/actual parameter aliases */                  ocl = readif; /* get next formal/actual parameter alias */                  if ocl < 0 then do; /* if the formal parameter key follows */                     if dist = lcl - 1 /* if at the end of the list - bad alias list */                     then call er.sys ('invalid alias list', 'optimize');                     ocl = (ocl and "77777"); /* turn off the sign bit */                     okey = readif; /* pick up proc key of formal parm defn */                     dist = dist + 1; /* we read one more word */                     call keych (okey);                  end;                  else okey = current_key; /* otherwise, it's the current proc */                  if ((not jumps) and ((keyjto (key + proc_noswap) and bit (ocl and "377")) <> 0))                  then do; /* if actual can't swap */                     if ((shr(ocl, 8) < 16) and ((keyjto (okey + proc_noswap) and bit (shr(ocl, 8))) = 0))                     then do; /* if we think the corresponding formal parameter can swap */                        call set_keyjto (okey + proc_noswap, keyjto (okey + proc_noswap) or bit (shr(ocl, 8))); /* flag it as non-swappable */                        altf = 1; /* we need to keep looking to see whether data can swap */                        if debug then new.swapscon = (new.swapscon or 1);                     end;                  end; /* of actual parameter that can't swap */               end; /* of examining formal/actual parameter aliases */               /* see if this proc is called from inside a when     */               /* statement.   If so, make sure proc cannot swap    */               if   (whenlevel <> 0)    /* if inside a when statement */               or   (whenproc  <> 0)    /* or inside a proc called    */               then do;                 /* from a when statement      */                  if (keyflag (key + proc_info) & proc_when) = 0                  then do;                     call set_keyflag (key + proc_info,                                       keyflag (key + proc_info) \ proc_when);                     altf = 1;                     if debug then new.loc = (new.loc or "1000");                  end;               end;               if (keyflag (key) and abit) = 0 then do; /* if not active already */                  call set_keyflag (key, keyflag (key) or abit); /* indicate active */                  altf = 1;                  if debug then new.active = (new.active or 2);               end;               /* if calling a swap procedure, see how many instructions */               /* it will need:                                          */                             if ((keyflag (key + proc_flags) and p.swap) <> 0) then do;                  swap_id = keyloc (key);     /* get id for this swap proc */                  if (swap_key = key)         /* if call to itself, only */                  then cur.loc = cur.loc + 2; /* two instructions needed */                  else if  (prctyp     >= 3)  /* if on model d ...       */                  and      (swap_id    <> 0)  /* and not first time thru */                  and      (swinfo.ptr <> 0)  /* if swinfo storage available */                  and      (swap_id ilt swinfo.max)    /* and info for id we are calling is available */                  and      (swinfo(2*swap_id) <> 0)    /* and proc we are calling uses no string/data storage */                  and      ((shr(swinfo(2*swap_id+1),8) < 4)   /* takes 3 or fewer register arguments */                  or        ((swap_key <> 0)                /* or we are in a swap proc now */                  and        (swap_key_id ilt swinfo.max)   /* and info for current procedure is available */                  and        ((swinfo(2*swap_id+1)&255) = (swinfo(2*swap_key_id+1)&255)))) /* and it resides on the same page as the one we are calling */                  and      (not debug_on)     /* don't do this if debug flag on */                  then do;                     new.page = swinfo(swap_id*2+1)&255;                     if swap_key = 0   /* if on page 0 - look up page and go there */                     then do;                        if new.page = 0                        then cur.loc = cur.loc + 7;                        else if emitt(new.page)                        then cur.loc = cur.loc + 8;                        else cur.loc = cur.loc + 9;                     end;                     else do;                        current.page = swinfo(swap_key_id*2+1)&255;                        if (current.page <> new.page)                        then do;                           if emitt(new.page - current.page) /* else use 4 or */                           then cur.loc = cur.loc + 4;       /* 5 instr jump  */                           else cur.loc = cur.loc + 5;       /* sequence      */                        end;                        else cur.loc = cur.loc + 2;  /* jump if same page    */                     end;                  end;                  /* else if models c or d, store swap id # in r15 */                  /* and jump to low memory:                       */                  else if prctyp >= 2 then do;   /* models c, d    */                     if emitt (swap_id)          /* if small id    */                     then cur.loc = cur.loc + 2; /* then 2 words   */                     else cur.loc = cur.loc + 3; /* else 3 words   */                  end;                  /* else for model b,  store swap id # in memory */                  /* and call r.swap:                             */                  else do;                    /* models a,b - store id#    */                     if emitt (swap_id)                     then cur.loc = cur.loc + 5;                     else cur.loc = cur.loc + 6;                  end;               end;               /* else if calling an internal memory procedure from */               /* a swapping procedure,  it takes a 3 word call on  */               /* the model D:                                      */               else if (swap_key  <> 0)               and     (prctyp    >= 3)               then do;/* proc_inside */ if keyloc (key + proc_regs) /* if calling a proc WITHIN */                  then cur.loc = cur.loc + 2; /* a swapping proc, 2 words */                  else cur.loc = cur.loc + 3; /* else 3 words to switch pages */               end;               /* else can do a call in two instructions: */               else cur.loc = cur.loc + 2; /* two words to do a CALL */            end; /* of procedure call */                    do; /* rtp call */               key = readif; /* get rtp location */               			   if (jumps and (not swaps)) then call clearstkptr; /* free up stack here - we know this makes code */             				if (key IGE l.interp) then do;						/* interpreter call								*/					if (emitt(key-l.interp) <> 0)					/* will fit in 1 word							*/					then cur.loc = cur.loc + 1;					else cur.loc = cur.loc + 2;				end;			  			   else if (key ige rtp.ptrs) 			   then call er.sys ('RTP key value out of range', 'optimize');               			   else do;				   rtpsubs (key) = 1; /* set to true to indicate sub is used */				   if  (swap_key <> 0)				   and (prctyp   >= 3)				   then cur.loc = cur.loc + 3; /* three locations */				   else cur.loc = cur.loc + 2; /* two locations   */				end;            end;            do; /* variable area pointer to dest */               call readif; /* skip destination */               do case (readif); /* branch on storage class */                  do; /* static */                     call readif; /* skip loc */                     cur.loc = cur.loc + 2; /* always takes two words */                  end; /* of static */                  do; /* automatic */                     key = readif; /* get location */                     if ((iter = 0) and jumps) then do; /* remap stack addresses during iteration zero of JUMPS */                        if ((key ige temp.base) and (key ilt extern.base)) /* is this a temp? */                        then key = (key - temp.base) + keyjto (current_key + proc_temps) + 1; /* map temp to relative stack location */                        if prctyp < 2 /* on models A & B */                        then key = (key - 1) - keyloc (current_key + proc_stack); /* make relative to stack pointer (rather than stack start - LOC is off by one) */                        else key = key + 1; /* model C - LOC is off by one */                        call writeif (key); /* save location relative to stack pointer */                     end; /* of checking for temps */                     if emitt (key) /* if it fits in an immediate field */                     then cur.loc = cur.loc + 2; /* only two words */                     else cur.loc = cur.loc + 3; /* need three words */                  end; /* of automatic */               end; /* of storage class */            end; /* variable area pointer to dest */            do; /* object code pointer (do case jump)  - et.cas */               key = readif;               call keych (key); /* check in range */               if (jumps and (keyjto (key) <> 0)) then do; /* detect jmps to jmps here (i.e., empty case) */                  key = keyjto (key);                  call writeif (key); /* this is new destination for do case */                  altf = 1;                  if debug then new.loc = (new.loc or 4);               end;               if (keyflag (key) and abit) = 0 then do; /* if it is now known */                  call set_keyflag (key, keyflag (key) or abit); /* indicate active */                  altf = 1;                  if debug then new.active = (new.active or 4);               end;               /* for Model D,  if in swapping procedure, emit a jump */               /* to the correct case.                                */               if  (swap_key  <> 0)               and (prctyp    >= 3)               then cur.loc = cur.loc + 2;               else cur.loc = cur.loc + 1;            end; /* of object code pointer */                    do; /* label definition  - ET.LDE */               key = readif;               call keych (key); /* check limits */               okey = keyflag (key); /* pick up flags */               if  (skip_opt)    /* skip of optimization desired */               and (iter =  0)   /* and first iteration          */               and (not jumps)   /* of not jumps                 */               then okey = okey \ abit;               if active then do; /* if we're active */                  if (okey and abit) = 0 then do; /* and not already active */                     okey = (okey or abit); /* mark as active */                     altf = 1;                     if debug then new.active = (new.active or "10");                  end;               end; /* of active */               else active = ((okey and abit) <> 0); /* if not active, assume activity of label */                     if ((okey and pbit) = 0)      /* if is a lobel (VS proc) */               or ((keyflag(key + proc_flags) and p.swap) = 0) /* or a non-swapping proc */               then do;                  if keyloc (key) <> cur.loc then do; /* if stored location doesn't match newest location */                     call set_keyloc (key, cur.loc); /* save current location of the label */                     if jumps then do;  /* only bother to re-iterate if jumps */                        altf = 1;                        if debug then new.loc = (new.loc or "20");                     end;                  end; /* of stored location doesn't match newest */               end; /* of normal proc */               call set_keyflag (key, okey or dbit); /* indicate is defined */               if (jumps and (not swaps)) then do; /* stack jump to jump detectors only if detecting jumps to jumps */                  call push (key);                  call push (cur.loc); /* stack these to check next instr */               end;            end; /* of label definition */            do; /* data definition */               if ((iter = 1) and (not jumps)) then do; /* move data swapping info into the IF */                  key = readif; /* pick up data key */                  call readif; /* read swapping flag */                  if (((current_key <> 0) and (key < 16)                      and ((keyloc (current_key + proc_dswp)                      and bit (key)) = 0)) /* if it can swap */                  and ((keyflag (current_key + proc_flags) and p.swapscon) <> 0)) /* check for swapping of scons & data arrays */                  then call writeif (1); /* mark it as such */               end;               else do; /* determine if succeeding data swaps */                  call readif; /* skip over key */                  swapdata = ((swap_key <> 0) and readif); /* set swap data flag for following COPY DATA record(s) */               end;            end; /* of data definition */                    do; /* copy data to object file */               key = readif;    /* get number of data words */               if ((iter = 0) and jumps) then do; /* emit SCON during first iteration */                  do okey = 1 to key; /* copy over or skip the data */                     ocl = readif; /* get data */                     if ((tosskey = 0) and (not swapdata)) then call writeobj (ocl); /* only emit if not in an inactive proc */                  end;                  /* If the string constant/data is being tossed because */                  /* the procedure is never called,  or if the string    */                  /* constant data is for a swap procedure and hence     */                  /* written out to the swap file,  adjust the string    */                  /* constant/data map to reflect the data will not be   */                  /* in internal memory:                                 */                  if ((tosskey <> 0) or swapdata)                   then call delscon (scon.loc, key);                  scon.loc = scon.loc + key; /* count the number of words we encounter */               end; /* of first iteration */               else if swaps then do; /* if we're in SWAPS */                  if (swapdata and active) then do; /* if swapping scon */                     call addswap (scon.loc, -swapscon); /* add it to the swapping scon table (but mark it as data) */                  end;                  do okey = 1 to key; call readif; end; /* skip over record */                  scon.loc = scon.loc + key; /* count the number of words we encounter */               end; /* of in SWAPS */               else do;                  do okey = 1 to key; call readif; end; /* skip over record */               end;               if (swapdata and active) then do; /* if swapping scon */                  swapscon = swapscon + key;     /* count number of swapped words */               end;               anyscon = 1;            end; /* copy data */                    do; /* copy scon to object file */               key = readif - 2;    /* get the number of data words */               okey = readif;       /* pick up key of proc this is passed to */               swapping = readif;   /* pick up param # or swapping  */               if ((iter = 0) and jumps) then do; /* emit SCON during first iteration */                  /* If calling an rtp procedure,  then we can swap */                  /* the string constants,  but do so only if we    */                  /* are in a swapping procedure:                   */                  if okey = 0                  then swapping = (swap_key <> 0)                                & ((keyflag(swap_key + proc_flags) and p.swapscon) <> 0);                  /* Else if calling a user procedure,  then see    */                  /* if the procedure we are calling swaps,  or     */                  /* passes the string constant to another proc     */                  /* that swaps.                                    */                  else swapping = (swapping < 16)                                 & ((keyjto (okey + proc_noswap) and bit (swapping)) = 0)                                & ((keyflag(swap_key + proc_flags) and p.swapscon) <> 0);                  call writeif (swapping); /* save flag for later passes */                  do okey = 1 to key; /* copy over or skip the scon */                     ocl = readif; /* get scon */                     if (active and ((swap_key = 0) or (not swapping))) then call writeobj (ocl); /* only emit if active */                  end;                  if ((not active) or ((swap_key <> 0) and swapping))                  then call delscon (scon.loc, key); /* add to deleted SCON list if not used OR IF data will rewside in swap file/external memory */                  scon.loc = scon.loc + key; /* count the number of words we encounter */               end; /* of first iteration */               else if swaps then do; /* if we're in SWAPS */                  if (swapping and active and (swap_key <> 0)) then do; /* if swapping scon */                     call addswap (scon.loc, swapscon); /* add it to the swapping scon table */                  end;                  do okey = 1 to key; call readif; end; /* skip over record */                  scon.loc = scon.loc + key; /* count the number of words we encounter */               end; /* of in SWAPS */               else do;                  do okey = 1 to key; call readif; end; /* skip over record */               end;               if (swapping and active and (swap_key <> 0)) /* if swapping scon */               then swapscon = swapscon + key; /* count number of swapped words */               anyscon = 1;            end; /* copy scon */            do; /* do nothing for ignore type records */            end;/*  $$Iterative optimization phase (cont.): */            do; /* procedure definition record  - proc def */               numargs = readif;    /* get # of reg args plus record length */               parms = (numargs&255) - 4; /* get number of parms passed (only for recursive procs) */               numargs = shr(numargs,8);   /* number of registers used */               key = readif; /* get key */               call keych (key + proc_keys); /* check on all N keys */               call set_keyflag (key, keyflag (key) or pbit); /* mark as a procedure */               call ppush (current_key); current_key = key; /* save key of current proc */               sram = readif; /* get starting ram location */               stemp = readif; /* get starting temp location */               cond = readif; /* get procedure bits */               if proclevel = 0 then do;                  /* see if this procedure is called from a WHEN */                  /* statement:                                  */                  whenproc = ((keyflag(key + proc_info) & proc_when) <> 0);                  /* Turn the proc into a swapping proc if it is */                  /* not called by an interrupt routine:         */                  if  (iter = 0)                /* if very first iteration */                  and (not jumps)               /* ie VERY first           */                  and (force_out)               /* and force swap desired  */                  and (whenlevel = 0)           /* and not inside WHEN     */                  and (not device_driver (key)) /* and not a device driver */                  and (not special_driver(key)) /* and not 'OVERLAY' ...   */                  and (numargs < 4)             /* can jump there          */                  and (whenproc = 0)            /* and not called by WHEN  */                  then do;                      /* then force out          */                     cond = cond \ p.swap;                     call writeif(cond);                  end;                  /* if swaping procedure - turn into nonswap if proc      */                  /* is called from a WHEN statement                       */                  if  ((cond and p.swap) <> 0)                  and  (whenproc         <> 0)                  then do;                     cond = cond & (not(p.swap\p.swapscon));                     call writeif(cond);                     altf = 1;                     if debug then new.loc = (new.loc or "2000");                  end;               end;               proclevel = proclevel + 1;               if (cond and p.swap) <> 0 then do; /* if swappable proc */                  if (jumps and active) then do; /* if active and we're optimizing jumps (this condition MUST match the same in label defn) */                     swap_procs = swap_procs + 1; /* count number of swappable procs (and assign proc ID) */                     if keyloc(key) <> swap_procs /* more info included */                     then do;                        altf = 1;                        call set_keyloc (key, swap_procs); /* set the ID for this proc */                        if debug then new.loc = (new.loc or "40");                     end;                     swap_loc = cur.loc; /* remember CUR.LOC */                     if prctyp >= 3     /* For model d, cur.loc is   */                     then cur.loc = 0;  /* relative to start of proc */                     else cur.loc = swap_area;  /* else absolute     */                     swapscon = 1;   /* restart swapping scon pointer */                     anyscon  = 0;   /* assume no string/data found   */                     swap_key = key; /* mark that we are inside a swap proc and remember the key for optimizing recursive calls */                     swap_key_id = swap_procs;                     /* store number of register arguments away so the */                     /* procedure end record can look at them:         */                     if  (swinfo.ptr <> 0)     /* if swinfo storage available */                     and (swap_procs ilt swinfo.max) /* and this id will fit  */                     then write(md) = (swinfo(2*swap_procs+1)&255) + shl(numargs,8);                  end;               end; /* of swappable proc */               call set_keyflag (key + proc_flags, cond); /* save procedure bits */               do okey = 1 to parms; /* skip over parms */                  call readif;               end;               if active then do; /* for a called proc */                  if prctyp >= 2 then cur.loc = cur.loc + 1; /* Model C requires one word to enter */                  if jumps /* don't look at proc registers until JUMPS (PROC_DSWP lives here until then) */                  then okey = numbits (keyloc (key + proc_regs) & reg_mask); /* see how many regs to save */                  else okey = 0; /* this number is rather irrelevant (but must match proc end) */                  if  ((okey > cutoff) /* too many regs and Model C or (not swappable and not a device driver)? */                  and ((prctyp >= 2) or (((cond and p.swap) = 0) and (not device_driver (key)))))                  then cur.loc = cur.loc + 1; /* save all regs with 1 jump (to SREG) */                  else if okey > 0 then do; /* else save up to cutoff */                     cur.loc = cur.loc + okey; /* need as many word as registers */                     if prctyp < 2 then cur.loc = cur.loc + 2; /* Model A & B need two extra words */                  end;                  if ((iter <> 0) or jumps) /* only after first iteration (need to set up KEYLOC during first iter) */                  then cur.loc = cur.loc + entry_len (parms, keyloc (key + proc_stack), cond); /* determine where we are */                  if (jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */               end; /* of a called proc defn */               else if (jumps and (iter = 0)) then do; /* set up to toss ram/scon from proc that isn't called */                  if tosskey = 0 then do; /* if we aren't already tossing a proc's ram */                     tosskey = key; /* toss the ram from this proc */                     tossram = sram; /* remember starting ram */                     tosstemp = stemp; /* remember starting temp */                  end;               end; /* of proc that isn't called */            end; /* of proc defn */            do; /* handle end of procedure definition */               key = readif; /* get key */               call keych (key + proc_keys); /* be paranoid about pass2 - check on all 4 keys again */               sram = readif;  /* get ending ram in case we're tossing this proc */               stemp = readif; /* pick up temp end/temp offset */               cond = keyflag (key + proc_flags); /* pick up proc flags */               proclevel = proclevel - 1;               if proclevel = 0    /* clear whenlevel when returning */               then whenproc = 0;  /* to level 0 only.               */               if (cond and p.recursive) <> 0 /* if end of a recursive proc */               then call set_keyjto (key + proc_temps, stemp); /* save temp offset */               call set_keyloc (key + proc_stack, readif); /* save stack length */               okey = readif; /* get registers used */               if ((iter = 0) and (not jumps)) then do; /* during first iteration only */                  if (((cond and p.recursive) = 0) /* if end of a non-recursive proc */                  and (keyloc (key + proc_stack) <> 0)) then do; /* and non-zero stack length (i.e., automatic vars declared) */                     okey = (okey or bit ("11")); /* R11 is also used (it should be set anyway, but...) */                     call writeif (okey); /* save new regs used */                  end; /* of end of non-recursive proc with stack */                  if  (( prctyp             < 3 )      /* if models a,b,c */                  and  ((cond & p.swap)     <> 0))     /* and code swaps  */                  or  (( prctyp             >=3 )      /* or if model D   */                  and  ((cond & p.swapscon) <> 0)      /* and scon swaps  */                  and  ( anyscon            <> 0))     /* and some there  */                  or  ((debug_on           <> 0 )      /* or if debugging */                  and  ( prctyp             >=3 )      /* on model D      */                  and  ((cond & p.swap)     <> 0))     /* and code swaps  */                  then call set_keyjto (key + proc_noswap, -1);               end; /* of during first iteration only */               /* copy NOSWAP bit info into proc_dswp very first  */               /* iteration only                                  */               if ((iter = 0) and (not jumps)) /* during first iteration only */               then call set_keyloc (key + proc_dswp, readif); /* get NOSWAP bitmap for data (set by pass1) */               /* else copy proc_regs info into proc_regs on the  */               /* next pass,  remembering it lies on top of       */               /* proc_dswp                                       */               else do;                  call readif; /* skip NOSWAP bitmap for data */                  if ((iter = 1) and (not jumps)) /* during second iteration only */                  then call set_keyloc (key + proc_regs, (okey&reg_mask) \ (swap_key <> 0));                  else do;                                  /* Keep track of whether we are defining a proc inside */                     /* a swapping proc.  Compiler some times takes a while */                     /* to decide if a proc swaps or not.                   */                     if (swap_key <> 0) <> (keyloc(key + proc_regs)&proc_inside)                     then do;                        call set_keyloc (key + proc_regs,                                         keyloc(key + proc_regs) xor proc_inside);                        altf = 1;                        if debug then new.loc = (new.loc or "400");                     end;                  end;               end;               if (active or ((keyflag (key) and abit) <> 0)) then do; /* end of a called proc (it may NOT be active at the end) */                  if active then do; /* ONLY do this if we're still active at this point */                     if ((iter <> 0) or jumps) /* after KEYLOC is set up */                     then cur.loc = cur.loc + exit_len (keyloc (key + proc_stack)); /* account for exit code */                     if jumps /* don't look at proc registers until JUMPS (PROC_DSWP lives here until then) */                     then okey = numbits (keyloc (key + proc_regs) & reg_mask); /* see how many registers saved */                     else okey = 0; /* this number is rather irrelevant (but must match proc defn) */                     if (okey = 0) or ((okey > cutoff) and ((prctyp >= 2) /* if LREG can/should be called */                     or (((cond and p.swap) = 0) and (not device_driver (key))))) then do;                        if (okey = 0) and (prctyp >= 2) then cur.loc = cur.loc + 1; /* ModelC needs an extra word (for predecrement) to return with no regs saved */                        cur.loc = cur.loc + 1;                     end;                     else do; /* must load registers and return */                        cur.loc = cur.loc + okey + 2;                        if prctyp < 2 then cur.loc = cur.loc + 2; /* two extra words for Models A & B */                     end;                     if (jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */                  end; /* of active */                  if (jumps and ((cond and p.swap) <> 0)) then do; /* swappable proc? (only set after JUMPS) (KEY had better equal SWAP_KEY here) */                     /* Compute actual # of words of object code */                     /* that will be generated for this proc:    */                     if prctyp < 3 /* if model a,b,c ... */                     then cur.loc = cur.loc - swap_area;                     /* if swapping proc - save size of object code only */                     /* to compute where string constants are stored     */                     if swaps then do;                        call set_keyjto(key + proc_objsz, cur.loc);                     end;                     cur.loc = cur.loc + swapscon - 1; /* add in swapping scon to get total object length */                     /* For model d, figure out where this proc will */                     /* sit in ext memory.  Bump up if needed so     */                     /* it will not straddle a page:                 */                     if prctyp >= 3 then do;                        boundary = keyloc (key + proc_regs) & proc_bound;                        temp = shl(swap_total,8) \ swap_words; /* object code will start here in ext memory */                        /* If proc bumps into next page,  then move */                        /* up to page boundary:                     */                        if ((temp + cur.loc) ilt temp)                        then do;                           swap_total = (swap_total + 256) & "177400";                           swap_words = 64;  /* start proc at word 64 */                           /* set bit to force this proc to bound */                           call set_keyloc (key + proc_regs,                                (keyloc (key + proc_regs) \ proc_bound));                        end;                        /* else if proc was forced to a page boundary last */                        /* time through,  then bring it down to prior      */                        /* page only if there would be some extra room,    */                        /* otherwise pass3 can oscilate here has the       */                        /* object code changes length:                     */                        else if boundary <> 0                        then do;                           /* clear the boundary bit if there would be */                           /* more than 500 free words on this page    */                           /* after the proc was moved back here:      */                           if (temp + cur.loc) ilt (-500)                           then do;                              /* clear boundary bit */                              call set_keyloc (key + proc_regs,                                   (keyloc (key + proc_regs) & not(proc_bound)));                              altf = 1;                              if debug then new.loc = (new.loc or "200");                           end;                           /* else keep this proc bumped up to the next */                           /* page even if it does not really need to   */                           /* be:                                       */                           else do;                              swap_total = (swap_total + 256) & "177400";                              swap_words = 64;  /* start proc at word 64 on */                           end;                        end;                        if  (swinfo.ptr <> 0)     /* if swinfo storage available */                        and (swap_procs ilt swinfo.max) /* and this id will fit  */                        then do;                           if swapscon = 1        /* equal 1 means NO STORAGE */                           then do;                              /* save away current location (<>0) for */                              /* optimization check:                  */                              call Set_Swinfo(2*swap_procs,                                    shl(swap_total,8) \ swap_words);                           end;                           else call Set_Swinfo(2*swap_procs, 0); /* can not skip r.swap if proc has any strings/data - store 0 */                           /* but always save away current page # for this swap proc */                           write(md) = (swinfo(2*swap_procs+1)&"177400")                                     \ shr(swap_total,8);                        end;                     end;                     if swaps then do; /* write out lookup table during SWAPS iteration */                        call writeovr (swap_total); /* relative starting sector number */                        call writeovr (swap_words); /* word offset in starting sector */                        call writeovr (cur.loc); /* total word length (includes scon length) */                        if prctyp >= 3           /* write out scon len for model d and after */                        then call writeovr (swapscon - 1); /* amount of string constant & data array swapped */                        call clrswap; /* clear out swapping scon pointer list */                     end;                     swap_words = swap_words + cur.loc; /* number of words so far (minus shl(SWAP_TOTAL, 8)) */                     swap_total = swap_total + shr(swap_words, 8); /* keep track of total number of sectors (perhaps minus one) */                     swap_words = (swap_words and "377"); /* make this the number of words in the final sector */                     if prctyp < 3 then do;   /* model a, b, c */                        if cur.loc igt swap_size                        then swap_size = cur.loc; /* find the largest overlay */                     end;                     else do;                 /* modeld - only scons swap */                        if swapscon - 1 igt swap_size                         then swap_size = swapscon - 1; /* keep track of largest scon area */                     end;                     /* keep track of largest scon area for final iteration */                     /* error checks:                                       */                                         if swapscon - 1 igt swap_scon                      then swap_scon = swapscon - 1;                      cur.loc = swap_loc; /* reset CUR.LOC */                     swap_key = 0; /* reset SWAP_KEY since we're no longer in a swappable proc */                  end; /* of swappable proc */                  active = 0; /* not active after end of proc */               end; /* of end of a called proc */               else if ((tosskey = key) and (tossram <> 0)) then do; /* end of an uncalled proc - toss ram */                  call delram (tossram, sram - tossram); /* delete this block of ram */                  if (cond and p.recursive) = 0 /* if not a recursive proc */                  then call delram (tosstemp, stemp - tosstemp); /* delete temps as well */               end;               tosskey = 0; /* no longer tossing */               current_key = ppop; /* restore key of previous proc */            end; /* of end of proc defn *//*  $$Iterative optimization phase (cont.): */            do; /* process when statement */               key = readif; /* pick up key */               call keych (key + when_keys); /* check on all N keys */               okey = numbits (keyloc (key + proc_regs) & reg_mask); /* get reg save bit word */               whenlevel = whenlevel + 1;               if prctyp >= 2 then cur.loc = cur.loc + 1; /* one word for Model C entry */               if okey <> 0 then do; /* must save regs */                  cur.loc = cur.loc + okey;                  if prctyp < 2 then cur.loc = cur.loc + 2; /* two extra words for Models A & B */               end;               active = 1;   /* when statements are always active */               if (jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */            end;            do; /* process the end of a when statement */               key = readif; /* get key */               call keych (key + when_keys); /* be paranoid about pass 2 - check on all N keys again */               whenlevel = whenlevel - 1;               ocl = readif; /* get regs used */               call set_keyloc (key + proc_regs, ocl & reg_mask); /* save regs used */               okey = numbits (ocl); /* get number of regs used */               if prctyp >= 2 then cur.loc = cur.loc + 1; /* Model C needs to predecrement stack pointer */               if okey <> 0 then do; /* must reload regs */                  cur.loc = cur.loc + okey;                  if prctyp < 2 then cur.loc = cur.loc + 3; /* two extra words for Models A & B */               end;               cur.loc = cur.loc + 1; /* one word return */               if (active and jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */               active = 0; /* inactive code always follows when statement */            end;            do; /* emit string constant pointer */               call readif; /* ignore destination */               if ((swaps and (swap_key <> 0))  /* check for swapping scon */               and ((keyflag(swap_key + proc_flags) and p.swapscon) <> 0)) then do; /* check for swapping of scon's & data */                  call writeif (adjswap (readif)); /* update if swapping */                  call readif; call writeif (it_swaps); /* store whether it swaps */               end; /* of check for swapping scon */               else do; /* ignore record this time */                  call readif; call readif;               end;               cur.loc = cur.loc + 2;               if (active and jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */            end; /* of emit string constant pointer */            do; /* addr of fixed array parameter */               key = readif; /* pick up defining procedure's key */               ocl = readif; /* and formal parameter number */               if ((not jumps) and (ocl < 16) and ((keyjto (key + proc_noswap) and bit (ocl)) = 0))               then do; /* if we think this formal parameter can swap */                  call set_keyjto (key + proc_noswap, keyjto (key + proc_noswap) or bit (ocl)); /* flag it as non-swappable */                  altf = 1; /* we need to keep looking */                  if debug then new.swapscon = (new.swapscon or 2);               end;            end; /* of addr of fixed array parameter */            do; /* sequence number record */               call readif; /* ignore for now (many of these - SKIPRECORD takes too long) */            end; /* of sequence (line) number record */            do; /* symdef or symref (passed for linker) */               call skiprecord (key); /* none of these */            end; /* of symdef or symref */            do; /* module statement */               call skiprecord (key); /* none of these */            end; /* of module statement */            do; /* library statement */               call skiprecord (key); /* none of these */            end; /* of library statement */                    do; /* insert statement */               if (shr(insert#, 4) >= insmax)               then do;                  call skiprecord (key); /* skip the record until we process jumps to jumps */                  /* stack will be reset at start of next pass */               end;               else if (not jumps)                then call skiprecord (key); /* skip the record until we process jumps to jumps */               else do; /* we are now processing jumps to jumps */                  if shr(delete (shr(insert#, 4)), (insert# and "17")) then do; /* if we should delete this insert statement */                     call writeif (et.ign); /* delete record type */                     okey = (readif and "377"); call writeif (et.ign); /* get record length and delete */                     do okey = 1 to okey; call readif; call writeif (et.ign); end; /* delete the rest of the record */                     delete (shr(insert#, 4)) = (delete (shr(insert#, 4)) xor bit (insert# and "17")); /* turn off the delete flag */                     deleted = deleted + 1; /* we've deleted another insert record */                  end; /* of delete this record */                  else do; /* don't delete this record */                     key = readif; /* get the record length */                     if key <> 0 then do; /* if this is a start of insert file */                        do key = 1 to key; /* skip over the record */                           call readif;                        end;                        call ipush (cur.loc); call ipush (insert# - deleted); /* save info in case we need to delete it later */                     end; /* of start of insert */                     else do; /* this is an end of insert file record */                        key = ipop; /* get starting insert file's statement number */                        if cur.loc = ipop then do; /* if there's no code in this insert file, get rid of the reference */                           delete (shr(key, 4)) = (delete (shr(key, 4)) or bit (key and "17")); /* delete the starting record */                           delete (shr(insert# - deleted, 4)) = (delete (shr(insert# - deleted, 4)) or bit ((insert# - deleted) and "17")); /* and the ending record */                        end; /* of if there's no code */                     end; /* of end of insert */                  end; /* of don't delete this record */                  insert# = insert# + 1; /* we've found another insert statement */               end; /* of we're deleting jumps to jumps */            end; /* of insert statement */            do; /* library definition (library follows immediately in the intermediate file) */               key = readif; /* get library number */               b.key (key) = cur.loc; /* update the object base for this library */            end;            do; /* external symbol reference */               call readif; /* skip over it (many of these - SKIPRECORD takes too long)*/               call readif;            end; /* of external symbol reference */            do; /* et.cas = emit object code for do case */               if  (swap_key  <> 0)               and (prctyp    >= 3)               then cur.loc = cur.loc + 2;               else cur.loc = cur.loc + 3;               if (active and jumps and (not swaps)) then call clearstkptr; /* clear out stacked label list */            end;            do; /* et.atr - alternate key transfer */               insert ':xpl611:p3-atr';            end;            do; /* et.ald - alternate label definition */               insert ':xpl611:p3-ald';            end;         end; /* of do case */         key = readif; /* get next record type */      end; /* of stop at eof */      b.key (next_lib + 1) = cur.loc; /* update end of object pointer */      call clear_keyflag (dbit); /* clear defined bit from KEYFLAG array for next pass */      /* find out end of object code - this is where swap area */      /* will go (if needed)                                   */      if swap_area <> cur.loc then do;         if jumps then do;  /* only bother to re-iterate if in JUMPS */            altf = 1; /* don't stop until it stabilizes */            if debug then new.loc = (new.loc or "100");         end;      end;      swap_area = cur.loc; /* save estimate */      if swaps then do; /* if we just did the swap table pass */         /* make SWAP_TOTAL total number of sectors (it's also OVSECLN) */         if swap_words <> 0 then swap_total = swap_total + 1;          if swap_total igt ovmaxln /* make sure .WORK can hold it */         then call er.ftl ('.WORK not large enough to create swap file'); /* oops! */         if altf <> 0         then call er.sys ('Optimization error (two SWAP passes)', 'optimize');      end;      if ((not altf) and (not jumps)) then do; /* if no more alterations and we haven't optimized the jumps to jumps */         jumps = 1; /* make sure we optimize jumps to jumps now */         altf  = 1; /* assume we will make changes */         iter  = 0; /* and start counting again */      end;      else do; /* not yet ready for or past jump to jumps */         if ((not altf) and jumps and (not swaps) and (iter <> 0)) then do; /* if no more alterations, but jumps have been optimized */            swaps = 1; /* next pass, we'll look at swaps */            if swap_procs <> 0 then altf = 1; /* if any procs swap, make sure we go around again */         end;         iter = iter + 1; /* increment loop counter */      end;      if debug then do;         print 'jumps, iter, swaps, loc, active, swapscon', jumps, iter, swaps, new.loc, new.active, new.swapscon;         new.loc = 0; new.active = 0; new.swapscon = 0;      end;   end; /* of iterative loop */   stkptr    = 0; /* clean out the stack when we're done */   altstkptr = 0;   call resetif (0); /* reset interfile for final pass */end optimize;