/*  $$Perform iterative optimization phase:..   During this phase of compilation, the string and data constants are.   copied to the object file.  This places them directly after the rtp.   "intro" (lowcore) and directly before the runtime package...   A dead code analysis is also performed.  This proceeds as follows:.      1) Assume all labels are at the start of neither dead (inactive).         or active code.  Rather, assume the state of said code is unknown..      2) Assume the startup code (at the beginning of the IF) is active.         (which it better be since LOWCORE transfers there at start-up)..      3) Iterate through the IF until no more label states change:.         a) When we reach a label, determine if we should be active:.            If we are active when we reach the label, stay active (and.            make the label's state active)..            Otherwise, set active to the label's state (active or unknown)..         b) When we reach a jump or a user proc call, update target label's.            state to active if we are currently active...   This routine also determines what SCON records can swap.  Two lists.   are used to make this determination:  NOSWAP and ALIASES...   NOSWAP is a bit list with one word assigned to every procedure.   (indexed by the key number of the proc).  Each bit in this word is.   used to signify which parameters of the procedure are fixed arrays.   and can't swap (i.e., fixed array parameters that are eventually.   passed on to a swapping procedure OR are in a swapping procedure)..   The bit list is oriented from least significant to most significant,.   so formal parameter zero's flag is in bit zero of the word, formal.   parameter one's flag is in bit one of the word, etc.  In this way,.   we can represent the state of up to sixteen formal parameters.  Any.   excess (beyond sixteen) parameters of a procedure are ignored (i.e.,.   NOT optimized).  Note that every bit in a swapping procedure's word.   is set (i.e., none of its formal parameters can swap).  NOSWAP is.   physically stored in KEYJTO and indexed by (KEY + PROC_NOSWAP)...   ALIASES is a list of lists of formal parameter/actual parameter.   aliases.  There is a separate list of formal parameter/actual.   parameter aliases for each procedure.  This list is comprised.   of a specified number of aliases.  Each alias is represented.   in one machine word.  This word contains the formal -> actual.   mapping with the actual parameter number stored in the lower.   eight bits and the formal parameter number stored in the upper.   eight bits.  ALIASES is physically stored in the CALL records.   of the intermediate file...   The "find swapping scon" algorithm proceeds as follows:..      1) Make one pass over intermediate file to initialize NOSWAP:.         a) If SWAP flag is set in ET.PDF record, set NOSWAP to all ones (-1)..         b) As we process ET.CAL statements, if NOSWAP is set for the actual.            parameter to the called function, set NOSWAP for formal parameter.            of calling procedure...      2) Make N passes over ALIASES list (until NOSWAP doesn't change):.         a) If NOSWAP is set for actual parameter of called function.            and NOSWAP isn't set for formal parameter of calling proc,.            set NOSWAP for formal parameter of calling proc and make.            another pass...      3) Make another pass through the intermediate file (JUMPS and (ITER = 0)):.         a) If key in ET.SCN record is zero, it's being passed to an.            RTP routine, so set SWAPPING flag in the ET.SCN record..         b) If key in ET.SCN record is non-zero, it's being passed to.            a user routine, so clear SWAPPING flag in the ET.SCN record.            if NOSWAP for that actual parameter; otherwise set SWAPPING.*//*  $$.   This process has three phases:.      1) Eliminate all dead code (activate all "live" code) as described above (JUMPS = FALSE) and find all swapping scon..      2) Emit non-swapping scon and compress jumps to jumps into single jumps (JUMPS = TRUE)..      3) Emit swap lookup table (SWAPS = TRUE).*/optimize: proc(skip_opt,force_out); /* optimize the object code (sets up KEYLOC, KEYJTO, and KEYFLAG) */   dcl skip_opt  fixed; /* TRUE if we should skip dead code analysis */   dcl force_out fixed; /* TRUE if should force all procs to ext mem */   dcl altf      fixed; /* TRUE if the IF has been altered */   dcl iter      fixed; /* current iteration of this phase (phase defined by JUMPS) */   dcl jumps     fixed; /* TRUE when we are optimizing jumps to jumps */   dcl swaps     fixed; /* TRUE when we are emitting swap lookup table */   dcl active    fixed; /* TRUE if this code is active */   dcl key       fixed; /* current key value */   dcl okey      fixed; /* old key value */   dcl ocl       fixed; /* old CUR.LOC */   dcl dist      fixed; /* jump distance */   dcl cond      fixed; /* jump condition */   dcl lcl       fixed; /* last CUR.LOC */   dcl scon.loc  fixed; /* SCON/data location (analogous to CUR.LOC)     */   dcl swapscon  fixed; /* swapping SCON location (analogous to CUR.LOC) */   dcl anyscon   fixed; /* set if any swapping data/consts for proc      */   dcl swapdata  fixed; /* TRUE if succeeding data should swap */   dcl tosskey   fixed; /* key of the current proc being tossed (ZERO if not tossing) */   dcl tossram   fixed; /* starting ram for current proc being tossed (undefined if TOSSKEY = 0) */   dcl tosstemp  fixed; /* starting temp for current proc being tossed (undefined if TOSSKEY = 0) */   dcl sram      fixed; /* starting ram location for proc */   dcl stemp     fixed; /* starting temp location for proc */   dcl swapping  fixed; /* TRUE if swapping scon */   dcl swap_loc  fixed; /* used to save and restore CUR.LOC before/after swap proc definitions */   dcl swap_key  fixed; /* KEY of current swappable proc */   dcl swap_key_id fixed;   dcl temp      fixed;   dcl numargs   fixed;   dcl swap_id   fixed;   dcl current.page  fixed;   dcl new.page      fixed;   dcl boundary      fixed;   dcl proclevel     fixed;   dcl whenlevel     fixed;   dcl whenproc      fixed;   dcl current_key fixed; current_key = 0; /* key of proc we're currently scanning */   dcl parms       fixed; /* number of parameters passed to a recursive proc */   dcl delete (insmax - 1) fixed; /* bit map of INSERT statements to delete (16 x INSMAX = maximum allowed) */   dcl insert#             fixed; /* # of insert statements we've found */   dcl deleted             fixed; /* # of insert statements we've deleted */   dcl always_process data (13, et.tra, et.lde, et.dat, et.cpy,                                 et.scn, et.pdf, et.pen, et.whn,                                et.wen, et.ins, et.ldf, et.atr, et.ald); /* records to always process */   dcl not_always (et.max) fixed; /* FALSE if this record should always be processed */   dcl debug lit 'false'; /* TRUE to debug */   dcl (new.active, new.loc, new.swapscon) fixed; /* ALTF causes *//* $$The KEYCH procedure is used to check a key number passed from pass2. */   keych: proc(k); /* check range */      dcl k fixed;      if k igt r (l.key)      then call er.sys ('key value out of range', 'keych');   end keych;   altch: proc(k); /* check range */      dcl k fixed;      if k igt r (l.altkey)      then call er.sys ('alt key value out of range', 'keych');   end altch;/* The ADDSWAP procedure adds the remapped locations of swapped scon to.  the list of swapping scon pointers...  ADJSWAP adjusts a scon pointer to its remapped value if it's in.  the list.  If the pointer is adjusted, the global flag IT_SWAPS.  will be set to TRUE so we can later determine whether this.  is a pointer to swapping scon.  ADJSWAP removes the entry for the.  passed pointer after it adjusts the pointer.  This is because string.  constants can only be referenced ONCE.  The adjusted pointer for a.  data constant has a negative value; these entries aren't removed.  until the end of the swapping procedure...  These routines can ONLY be called during SWAPS. */   addswap: proc(old_ptr, new_ptr); /* add a swapping scon's mapping to the swapping scon pointer list */      dcl (old_ptr, new_ptr) fixed; /* old scon pointer, new scon pointer */      if not swaps then call er.sys ('not in SWAPS', 'addswap');      call push (old_ptr); /* push the old pointer */      call push (new_ptr); /* immediately followed by the new */   end addswap;   dcl it_swaps boolean; /* TRUE if ADJSWAP adjusts the pointer */   adjswap: proc(ptr) returns (fixed); /* adjust a scon pointer if it swaps */      dcl ptr   fixed; /* pointer to adjust */      dcl found fixed; /* TRUE when we find the address in the swap area */      dcl i     fixed;      if not swaps then call er.sys ('not in SWAPS', 'adjswap');      i = -2; found = 0;      do while ((i < stkptr) and (not found)); /* look for this pointer */         i = i + 2;         if stk (i + 1) < 0 /* if data */         then found = ((ptr ige stk (i)) and (ptr ile stk (i + 2))); /* see if in range */         else found = (stk (i) = ptr); /* for scon */      end;      if i < stkptr then do; /* if swapped scon */         it_swaps = true; /* let 'em know it swaps */         if stk (i + 1) < 0 /* if data */         then ptr = -stk (i + 1) + (ptr - stk (i)); /* remap pointer */         else do; /* delete scon entries as we go */            ptr = stk (i + 1); /* remap pointer */            stkptr = stkptr - 2; /* we have one less entry */            if i < stkptr then do; /* delete this entry */               stk (i) = stk (stkptr); stk (i + 1) = stk (stkptr + 1); /* by swapping in last entry */            end;         end; /* of deleting scon entries as we go */      end; /* of swapped scon */      else it_swaps = false; /* let 'em know it doesn't swap */      return (ptr); /* return mapped (or unchanged) pointer */   end adjswap;   clrswap: proc; /* clear the scon pointer list */      if not swaps then call er.sys ('not in SWAPS', 'clrswap');      stkptr = 0;   end clrswap;