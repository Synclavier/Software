/* Definitions used by pass1 and pass2: */dcl alias_len  lit '256'; /* maximum array formal parameter/actual parameter correspondences per expression */dcl handle_len lit '32'; /* handles into alias array (ALIAS_LEN/8) [MUST be <= 256] */  /* Operator definitions:.  .  As mentioned above, the procedure 'SCAN' is called to scan the next.  token from the input file.   If the next character in the input.  file is an operator (i.e. ' + ', ' - ', '*', etc.)  then the scanner.  returns with the global variable 'TOKEN' equal to T.OPR and.  the global variable 'INFO' equal to one of the following values, .  depending on the type of operator. */dcl o.math  lit '0'; /* abs, log, atn, cos, sin, tan, exp, sqr */dcl o.int   lit '16'; /* int           */dcl o.read  lit '17'; /* read          */dcl o.adr   lit '19'; /* addr function */dcl o.not   lit '24'; /* not - monadic */dcl o.incr  lit '25'; /* increment - monadic */dcl o.decr  lit '26'; /* decrement - monadic */  dcl o.minus lit '28'; /* minus - monadic or dyadic */dcl o.plus  lit '29'; /* plus  - monadic or dyadic */dcl o.shr   lit '30'; /* shr */dcl o.shl   lit '31'; /* shl */dcl o.rot   lit '32'; /* rot */  dcl o.div   lit '36'; /* divide - dyadic */dcl o.times lit '37'; /* times  - dyadic */dcl o.mod   lit '38'; /* mod    - dyadic */dcl o.fmu   lit '39'; /* fractional multiply        */dcl o.fdi   lit '40'; /* fractional divide - dyadic */  dcl o.and   lit '41'; /* and - dyadic */dcl o.or    lit '42'; /* or  - dyadic */dcl o.xor   lit '43'; /* xor - dyadic */  dcl o.eq    lit '49'; /* equal                 */dcl o.lt    lit '50'; /* less than             */dcl o.le    lit '51'; /* less than or equal to */dcl o.gt    lit '52'; /* greater than          */dcl o.ge    lit '53'; /* greater or equal to   */dcl o.ne    lit '54'; /* not equal to          */dcl o.ilt   lit '55'; /* integer less than             */dcl o.ile   lit '56'; /* integer less than equal to    */dcl o.igt   lit '57'; /* integer greater than          */dcl o.ige   lit '58'; /* integer greater than equal to *//* Statement definitions:..   If the token scanned is a statement, the scanner returns with the.   global variable TOKEN equal to T.STMT and the global variable INFO.   set to one of the values below (depending on which statement was scanned). */dcl s.call    lit '0'; /* procedure call */dcl s.return  lit '1'; /* return */dcl s.proc    lit '2'; /* procedure definition */dcl s.begin   lit '3'; /* begin */dcl s.do      lit '4'; /* do */dcl s.if      lit '5'; /* if */dcl s.goto    lit '6'; /* goto */dcl s.enable  lit '7'; /* enable interrupts */dcl s.disable lit '8'; /* disable interrupts */dcl s.stop    lit '9'; /* halt the processor */dcl s.write   lit '10'; /* write to a device */dcl s.linput  lit '11'; /* line input from console */dcl s.input   lit '12'; /* input from console */dcl s.print   lit '13'; /* output to console */dcl s.send    lit '14'; /* output to printer/modem */dcl s.when    lit '15'; /* interrupt processing block definition */dcl s.invoke  lit '16'; /* invoke an interrupt handler */dcl s.module  lit '17'; /* define a relocatable module */dcl s.library lit '18'; /* reference a precompiled module */dcl s.insert  lit '19'; /* define the start/end of an insert file */dcl s.declare lit '20'; /* declare stack storage to be used by the program (must be same as S.PASS1 in P1-DEFS) *//* Definitions used by EXPR (pass1 and pass2):..  The types of tree nodes (created by EXPR) are defined as follows: */  dcl x.dyad  lit '0'; /* dyadic  opr - ARG1, ARG2 = operands, INFO = opr type */dcl x.monad lit '1'; /* monadic opr - ARG1 = operand,        INFO = opr type */dcl x.const lit '2'; /* constant    - ARG1 = type,           INFO = value    */dcl x.var   lit '3'; /* variable    - ARG1 = class/type, ARG2 = subscr (if one), INFO = location */dcl x.proc  lit '4'; /* procedure   - see EXPR */dcl x.cal   lit '5'; /* pass1 only: zero argument rtp call - ARG1 = type, INFO = rtp routine to call */ /* Register definitions (used in setting up procedure calls):. .  The registers (accumulators) are not numbered traditionally (0-3).  but are instead represented by bits.  They are numbered 1, 2, 4, and.  8, which makes some tables longer but also shortens the compiler and.  the compile time.*/ dcl b.ac0   lit '"01"';dcl b.ac1   lit '"02"';dcl b.ac2   lit '"04"';dcl b.ac3   lit '"10"';/* Communications area definitions for pass1 and pass2: */dcl com          lit 'r'; /* com unfortunately has an alias */dcl pdll         lit 'com (l.pdll         - rtp.ptrs)';dcl nexkey       lit 'com (l.key          - rtp.ptrs)';dcl altkey       lit 'com (l.altkey       - rtp.ptrs)';dcl recurs.parms lit 'com (l.recurs.parms - rtp.ptrs)';  dcl s.names.used lit 'com (l.s.names.len - rtp.ptrs)';dcl str.data     lit 'com (l.str.data    - rtp.ptrs)';dcl stack.used   lit 'com (l.stack.used  - rtp.ptrs)';dcl flags        lit 'com (l.flags       - rtp.ptrs)';  dcl ram          lit 'com (l.ram    - rtp.ptrs)';dcl extloc       lit 'com (l.extloc - rtp.ptrs)';dcl #st          lit 'com (l.#st       - rtp.ptrs)';dcl #sk          lit 'com (l.#sk       - rtp.ptrs)';dcl #bl          lit 'com (l.#bl       - rtp.ptrs)';dcl #if2         lit 'com (l.#if2      - rtp.ptrs)';  dcl iflng        lit 'com (l.iflng      - rtp.ptrs)';dcl if2lng       lit 'com (l.if2lng     - rtp.ptrs)';dcl ovram        lit 'com (l.ovram      - rtp.ptrs)';dcl get.blocks   lit 'com (l.get.blocks - rtp.ptrs)';dcl main_key     lit 'com (l.main.key   - rtp.ptrs)';dcl l.icell      lit '(icell - rtp.ptrs)'; /* interrupt cells for when */dcl l.ctab       lit '(ctab  - rtp.ptrs)'; /* configuration table */