/* Statement scanner - DO statement: */ dcl (temp.a, temp.b, temp.c, num.of.cases) fixed;token = gc; /* get next word to identify DO loop type */ /* 'do;' */ if token = t.semi then do; call stmt.list; /* get a list of statements followed by 'END' */ end;  else do; /* DO loops */ if token = t.case then begin; /* DO CASE *//*.   object code:.   example 'do case var1; stmt1; stmt2; stmt3; stmt4; end;'. .   VAR1    to R0       pick up VAR1 (case #).   re(XYZ) to RTRA     jump until after cases object code.   xyz.0: (object code for stmt1).   xyz.1: (object code for stmt2).   xyz.2: (object code for stmt3).   xyz.3: (object code for stmt4). .   xyz: ...                 handle DO CASE.   im(# of cases) to TSUB0  see if in range.   re(ZZZ)        to RTRC   skip if out of range..For models A, B, C, or Model D Internal Memory Procedures:.   PC             to ADD0   make the case # relative to the PC.   im(2)          to ADD0   compensate for two instructions to convert to PC-relative.   MR0            to ATRA   transfer indirectly to proper statement.   xyz.0 (pointer to code for case 0).   xyz.1 (pointer to code for case 1).   xyz.2 (pointer to code for case 2).   xyz.3 (pointer to code for case 3)..For Model D (in swapping procedures only).   r0             to add0   shift left.   r0             to rtra   jump into jump table.   pci to atra    jump for case 0.   xyz.0          pointer for case 0.   pci to atra    jump for case 1.   xyz.1          pointer for case 1.   zzz: ...*/ call scanc;          /* check for line numbers, etc. */ subtree = expr;      /* scan expression */ reg.pref = b.ac0;    /* try to get result in AC0 */ mvt = 0;             /* and we want fixed */ call compute;        /* compute the argument */ call fix (subtree); call in.reg (subtree, b.ac1 or b.ac2 or b.ac3); /* put result in AC0 for sure */ call x.rel (subtree);  /* through with this tree */ reg.free = (reg.free or b.ac0); /* AC0 is now free */temp.a = galt;          /* get key for jump to after cases */temp.b = galt;          /* and for jump to exit point */call em.atr (0, temp.a); /* jump there */call scanc;              /* check for line numbers */token = peek;            /* get next item */ num.of.cases = 0; /* initial number of cases *//* Statement scanner - DO loops - DO CASE (cont): . .   Now scan the statements until an END is found. */ call pushv;              /* save REGU and REGL, set to zero */if token <> t.end        /* watch out for null DO-CASE */then call start_queue;   /* start object pointer queue here */do while token <> t.end; /* until END */  temp.c = gkey; /* get key to define start of this case */  call em.lde (temp.c); /* and locate it here */  call enqueue (temp.c); /* and enqueue it to emit an object pointer later */  call accpurg; /* accumulators free on entry */  zflags = 0;  call pushr; /* put start of case registers on stack */  call pushv; /* and push REGL, REGU */  call push (temp.b); /* ditto TEMP.B */  call push (num.of.cases); /* save number */  call push (temp.a); /* save here for immediate recall */   call stmt; /* get this statement (recursion !!!!!) */  temp.a = pop; /* restore location */   num.of.cases = pop + 1; /* recover and increment NUM.OF.CASES */   temp.b = pop; /* restore goto block */  call em.atr (0, temp.b); /* emit jump to after cases */  regu = regu or pop; /* a register is used if used by any case */  regl = regl or pop; /* ditto */  call popr; /* reload registers for start of case */  token = peek; /* and grab next token for END check */end; /* of do while */  /* object code is out */ call gc; /* skip T.END */call em.ald (temp.a); /* case logic located here */call emitc (num.of.cases, b.td + b.tsu + "0"); /* im(NUM.OF.CASES) to TSUB0 - see if out of range (case # is in R0) */call em.atr (b.trc, temp.b); /* re(TEMP.B) to RTRC - skip if out of range */call em.cas;                 /* emit a do case record to create correct object code */do temp.a = 1 to num.of.cases; /* for every case */  call em.opt (dequeue);       /* emit pointer to object routine */end; /* of loop */call regclr (regl); /* zap any regs used by any of the cases */call popv; /* update REGU and REGL for this block */call em.ald (temp.b); /* and this is location after cases */call accpurg; /* accumulators free here */zflags = 0; end; /* of 'DO CASE' *//* Statement scanner - DO loops - DO WHILE:. .    Process DO WHILE loop:. .      Scan expression, compute it..      Then scan statement list..      Pass back appropriate registers..      Then jump back. */ else do;                         /* do loops (while, i =) */   if token = t.while then begin;   /* DO WHILE */      dcl while.ret fixed;      /* use for jump back */      call scanc;               /* check for lnums, etc. */      while.ret = galt;         /* get key for return */      call em.ald (while.ret);  /* locate it */      call accpurg;             /* empty accumulators at start of loop */      zflags = 0;      call pushv;               /* push variables */      call pushr;               /* save regs for passback */      subtree = expr;     /* scan expression */      call xcomset;       /* set up for call to XCOMPUTE */      call xcompute;      /* and process jump instructions */      call xcomchk;       /* check for no jump instructions emitted */      call sreg1;         /* save regs here   */      call lreg;          /* get earlier regs */      call pushr;         /* stack them       */      call lreg1;         /* push regs at first jump */      call xcompv;        /* and push REGU, REGL as of first jump */      call donewith (truel); /* done with this - locate it if we jumped here */      call x.rel (subtree); /* done with SUBTREE */             /* scan statement list */             call scanc;             /* scan for line numbers, etc. */      call push (falsel);     /* push this key for later locating */      call push (while.ret);  /* save for jump back */      call stmt.list;       /* scan a list followed by 'END' */      while.ret = pop;       falsel = pop;         /* restore pointers */      xcregl = regl;        /* preserve ones actually loaded after first jump */            call popv;            /* get used, loaded from initial loop entry */      call popr;            /* get regs at first jump                   */      call sreg;            /* save in temp                             */      call popr;            /* and get regs at start of loop            */      call sreg1;           /* save in t1 to look up info               */      pbk = (regu and regl);  /* detect those used and then loaded in above */      if pbk <> 0 then do i = min.ptr.reg to max.ptr.reg; /* pass back req'd regs */         if (pbk and regbit (i)) <> 0 then do; /* reload register */            call lreg1;                        /* get info to pass back  */            j = regc (i);                      /* save storage class     */            do k=min.ptr.reg to max.ptr.reg;   /* indicate all are blank */               regc(k)=0;                      /* so optimizing does not */            end;                               /* find one               */            call getvp (regs (i), j, (not 15) xor regbit(i)); /* use getvp to load it */         end; /* of reload registers */      end;      call em.atr (0, while.ret);   /* and jump back to start of DO loop */      call lreg;                    /* get regs at first jump */      call push (regl);             /* save regs used by entire loop */      regl = xcregl;                /* and get regs used by loop after first jump only */      call donewith (falsel);       /* and done with failure jump    */      regl = pop;                   /* restore regl to actual loaded during entire loop */      call popv;                    /* update previous REGL and REGU of upper level*/   end;          /* of while loop *//* Statement scanner - DO. loops - iterative (do i = 1 to 2 by 3): */ else begin; /* must be do. i = (TOKEN contains variable type) */  dcl (do.out, iclass, index, xindex,       lower, upper, step, negstep,       v.indx, t.indx, reg.indx, reg.step, reg.upper, reg.lower, reg.temp) fixed;  dcl (do.loop, do.vtype, do.start) fixed;  iclass = gc;   /* get storage class of index (TOKEN already contains the variable type) */  info  =  gc;   /* get variable location */  if token = t.pvar then token = t.var; /* and change to var at this time if we should */  index = info;  /* points to loc block for index variable */  t.indx = token; /* save variable type (T.VAR, T.FVAR, T.PVAR, T.PFVAR) */  do.vtype = ((t.indx and t.fvar) <> 0);  call scanc;    /* skip over line numbers, etc. up to expressions */  lower = expr;  /* recover lower expr */  upper = expr;  /* and upper */  step = expr;   /* and the step */     /* now massage step - compute if required,  then store it */     subtree  = step;        /* set up for computing step */  reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* in any reg. */  mvt      = do.vtype;    /* and select desired type */  reg.step = compute;     /* compute step into a register */  if do.vtype then do;     call float (step);        /* float it */     reg.step = iffreg(step);  /* get FIXED POINT REGISTERS  holding result */  end;  else if (x.arg1 (step) and "377") <> t.var  then do;      call er.fna;      call fix (step);   end;      /* fix it */  if x.node (step) <> x.const then do;  /* allocate temp unless constant */    temp.a = gtemp (do.vtype);    /* allocate temp */    v.indx = getvp (s.temporary, temp.a, reg.step);  /* get ptr to where to store */    if do.vtype then do; /* floaters */       call fsendit (step, b.md + b.ibt + v.indx, b.md + b.ibt + v.indx, reg.step or regbit(v.indx)); /* store variable */       regc (v.indx) = regc (v.indx) + 2;        regl = (regl or regbit (v.indx));    end;    else call sendit (step, b.md + v.indx, reg.step or regbit(v.indx)); /* do it - will free up register here */    x.node (step) = x.var;       /* flag as such */    x.info (step) = temp.a;      /* ptr to loc block */    x.arg1 (step) = (shl(s.temporary, 8) or (t.indx and t.fvar)); /* set to fixed or floating */    negstep = 0;                 /* step can only be negative if constant */  end;     /* of calculated step */  else do; /* constant step */     if do.vtype /* floaters */     then negstep = (fstk (x.info (step)) < 0); /* see if negative step */     else negstep = (x.info (step) < 0);        /* check for fixed negative step */     temp.a = -1;                               /* flag we didn't allocate this temp (tenuous at best) */  end;     /* of constant step */  /* Statement scanner - DO. loops - iterative (cont):  .   .   If the upper limit of the do. loop is a variable, then store  .   it in a unique place, so that end checks do not get fouled up. */     /* massage 'upper' */     subtree = upper;     /* calculate upper value */  reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any reg. */  mvt = do.vtype;      /* and this is variable type */  reg.upper = compute; /* compute into register */  if do.vtype then do;     call float (upper);         /* float it */     reg.upper = iffreg(upper);  /* get FIXED POINT REGISTERS  holding result */  end;  else if (x.arg1 (upper) and "377") <> t.var  then do; call er.fna; call fix (upper); end;  if x.node (upper) <> x.const then do; /* allocate a temp unless constant */    temp.b = gtemp (do.vtype); /* get unique temporary */    v.indx = getvp (s.temporary, temp.b, reg.upper); /* get pointer to upper */    if do.vtype then do; /* handle floaters here */      call fsendit (upper, b.md + b.ibt + v.indx, b.md + b.ibt + v.indx, reg.upper or regbit(v.indx)); /* store uper */      regc (v.indx) = regc (v.indx) + 2; regl = regl or regbit (v.indx); /* store this */    end;    else call sendit (upper, b.md + v.indx, reg.upper or regbit(v.indx)); /* else store upper */    x.node (upper) = x.var; /* change type to variable */    x.info (upper) = temp.b; /* pointer to loc block */    x.arg1 (upper) = (shl(s.temporary, 8) or (t.indx and t.fvar)); /* fixed or floating */    do.start = galt; /* get key for tze jump */  end;      /* of calculating upper */  else do;  /* is a constant */    temp.b = -1;        /* flag we didn't allocate this temp (tenuous at best) */    if ((do.vtype = 0) and (negstep = 0)) then do; /* fixed point & pos step - add 1 and skip tze */      x.info (upper) = x.info (upper) + 1;      do.start = 0;     /* no key */    end;    else do.start = galt; /* for floaters, must do it anyways */  end;  /* Statement scanner - DO loops - iterative (cont):  .   .   Now calculate starting value and get in a register.  Enter the place  .   where we perform a store and then start the loop. */     /* massage 'lower' */     subtree = lower;   /* lower */  reg.pref = (b.ac0 or b.ac1 or b.ac2 or b.ac3); /* any reg. */  mvt = do.vtype;    /* get type */  call compute;      /* get it */  if do.vtype then call float (lower); /* float it */  else if (x.arg1 (lower) and "377") <> t.var  then do; call er.fna; call fix (lower); end;  if do.vtype then do; /* floaters here */    call fin.reg (lower, not b.ac0);   /* get lower in floating point reg0 FPR0 */    reg.indx = iffreg(lower);          /* get fixed point registers holding result (for getvp) */    reg.free = (reg.free or b.ac0 or b.ac1); /* and yet free up regs cause we jump */  end;  else do;    reg.indx = in.reg (subtree, 0);     reg.free = (reg.free or reg.indx); /* yet still free */  end;  call getvp (iclass, index, reg.indx);   /* get pointer handy */  do.loop = galt; call em.ald (do.loop);  /* and this is restart point */  call accpurg;  zflags = 0;  call pushv; /* save REGU, REGL */  call pushr; /* so we can load them for passback */  /* Statement scanner - DO loops - iterative (cont):  .   .   We have calculated the step, upper, and lower bounds.  .   The lower bound is in a register and is ready for storing.  .   .   Now construct expression tree for index variable increment.  .   The actual code is not emitted until the end of the loop */     xindex = x.get;   x.node (xindex) = x.var;   x.arg1 (xindex) = (shl(iclass, 8) or t.indx);  x.info (xindex) = index; /* variable loc block */  subtree = x.get; /* get a SUBTREE for fake addition expression */  x.node (subtree) = x.dyad; /* + */  x.info (subtree) = o.plus;  x.arg1 (subtree) = xindex; /* variable */  x.arg2 (subtree) = step;   /* + step */  zflags = 0;  v.indx = getvp (iclass, index, reg.indx);  /* get pointer to index */  do case shr(t.indx, 1); /* store based on type of index */       do;      call emita (b.rs + bitreg (reg.indx), b.md + v.indx); /* store word */    end;         do;      call emita (b.rs + 0, b.md + b.ibt + v.indx); call emita (b.rs + 1, b.md + b.ibt + v.indx);      regl = (regl or regbit (v.indx));       regc (v.indx) = regc (v.indx) + 2;    end;         ; /* not used */         do; /* pfvar */      reg.temp = reg.allc (b.ac0 or b.ac1); /* allocate AC2 or AC3 for pointer */      call emita (b.ms + v.indx, b.rd + bitreg (reg.temp)); /* load pointer into accumulator */      call emita (b.rs + 0, b.md + b.ibt + bitreg (reg.temp));      call emita (b.rs + 1, b.md + b.ibt + bitreg (reg.temp)); /* store it */      call freeup (reg.temp); /* indicate empty */    end;     end; /* of store do case */  /* Statement scanner - DO loops - iterative (cont):  .   .   Now scan the statement list, pass back registers, and emit the final  .   jump back to the start of the loop. */     if do.vtype then do;                /* floater */     call fin.reg (upper, not b.ac1);     call em.rtp (l.fps);     reg.indx = b.ac0;     reg.free = (b.ac1 or b.ac2 or b.ac3);  end;  else do;   /* fixed point */    call sendit (upper, b.td + b.tsu + bitreg (reg.indx), reg.indx); /* perform test */    xinfo = x.get;     x.node (xinfo) = x.var;     x.arg1 (xinfo) = (shl(iclass, 8) or t.var);    x.info (xinfo) = index;     trees (reg.indx) = xinfo; /* indicate index is in reg for optimizing */  end;  do.out = galt; /* get key for out */  if negstep /* if a negative constant step */  then call em.atr (b.tmi, do.out); /* if negative, exit */  else do; /* positive constant or variable step */     if do.start <> 0 then call em.atr (b.tze, do.start); /* jump to start */     call em.atr (b.tpl, do.out); /* if plus, then exit */  end;  reg.free = (reg.free or reg.indx);  if do.start <> 0 then call em.ald (do.start);  call x.rel (upper); /* done */  call x.rel (lower); /* ditto */     /* get the loop statement list */     call push (temp.b); call push (temp.a); /* save temps */  call push (do.out);  call push (do.loop); /* save loop address for recursion */  call pushr; /* so we know what regs are on loop exit */  call push (regl); /* save which were loaded during test and store */  call push (subtree); /* save increment subtree */  call push (reg.indx); /* which registers */  call push (do.vtype); /* and type */  call stmt.list; /* get a list */  /* now emit code for increment of step */  do.vtype = pop;    /* restore type */  reg.indx = pop;    /* and which register */  subtree = pop;     /* and increment tree */  reg.pref = reg.indx;   mvt = do.vtype;    /* set up for computation of increment */  call compute;      /* emit code for increment of step */  if do.vtype then do;      call fin.reg (subtree, not b.ac0);      reg.free = (reg.free or b.ac0 or b.ac1);   end;  else do;       call in.reg (subtree, not reg.indx);     reg.free = (reg.free or reg.indx);   end;  reg.e = pop;            /* get which regs were loaded during add and store */  pbk = (regu and regl);  /* pass back anything used in orig form, and then loaded */  call popr;              /* and get what regs were on jmp to exit */  call sreg;              /* store them */  do.loop = pop; do.out = pop; /* and restore */  temp.a = pop; temp.b = pop; /* get temps back */  call popr;  /* these are the regs that we must restore from */  call sreg1; /* save in second temporary                     */  if pbk <> 0 then do i = min.ptr.reg to max.ptr.reg; /* pass back req'd regs */     if (pbk and regbit (i)) <> 0 then do; /* reload register */        call lreg1;                        /* get info to pass back  */        j = regc (i);                      /* save storage class     */        do k=min.ptr.reg to max.ptr.reg;   /* indicate all are blank */           regc(k)=0;                      /* so optimizing does not */        end;                               /* find one               */        call getvp (regs (i), j, ((not 15) xor regbit(i)) or reg.indx); /* use getvp to load it */     end; /* of reload registers */  end;  call x.rel (subtree); /* done */  call em.atr (0, do.loop); /* jump there */  call lreg;     /* get what regs were on exit */  call regclr (regl and (not pbk) and (not reg.e)); /* zap anything loaded and not pbk */  call popv; /* and update the upper level REGU, REGL */  call em.ald (do.out); /* locate exit point here */  call accpurg; /* indicate accumulators empty on exit */  zflags = 0;  if temp.a <> -1 then call ptemp (temp.a, do.vtype); /* free up this temp if allocated */  if temp.b <> -1 then call ptemp (temp.b, do.vtype); /* free up this temp if allocated */end; /* of DO loops */end; /* of DO loops, DO WHILE */end; /* of DO loops, DO CASE, DO WHILE */