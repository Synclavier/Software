/* Pass 3 global declarations: */dcl bit data ("1",     "2",     "4",     "10",   "20",   "40", /* BIT (I) = shl(1, I) */            "100",   "200",   "400",   "1000", "2000", "4000",          "10000", "20000", "40000", "100000");dcl iteration fixed; /* where we are in pass3 (for status only) */dcl cur.loc   fixed; /* current object code location */dcl max_keys  fixed; /* maximum number of keys available     */dcl max_alts  fixed; /* maximum number of alt keys available */dcl rtpcode   fixed; /* amount of RTP code bound into final object program */dcl vstrt     fixed; /* pointer to start of variable area */dcl obj.base  fixed; /* pointer to start of object code */dcl oldram   (divmax) fixed; /* used to toss ram from procs */dcl deltaram (divmax) fixed;dcl ramptr            fixed;dcl oldscon   (divmax) fixed; /* used to toss scon/data from procs */dcl deltascon (divmax) fixed;dcl sconptr            fixed;dcl r (maxcomm + rtp.ptrs) fixed; /* set up the communications area */dcl rtpsubs (rtp.ptrs - 1) fixed; /* used to determine which rtp subs are used *//* swap area */dcl swap_ram   fixed; /* pointer to ram reserved for swapping */dcl swap_area  fixed; /* address of swap area */dcl swap_size  fixed; /* length of swap area */dcl swap_procs fixed; /* number of swappable procs */dcl swap_total fixed; /* total number of sectors of swapped procs */dcl swap_words fixed; /* number of words in last sector of swapped procs */dcl swap_scon  fixed; /* maximum SCON swapped by any one procedure */  /* run time package file info */dcl rfdev   fixed; /* device          */dcl rfstart fixed; /* starting sector */dcl rflngth fixed; /* word length     */  /* interfile from pass2 file buffer info */dcl ifdev   fixed; /* device                 */dcl ifstart fixed; /* starting sector number */dcl ifpos   lit '(read(r13) - addr(ifbuf (0)))'; /* buffer position        */dcl ifsec   fixed; /* current sector         */dcl ifsecln fixed; /* length in sectors      */dcl ifmaxln lit 'core(loc.wsln) - (ifstart - core(loc.wsec))'; /* size of IF area of .WORK */dcl force_if fixed; force_if = 0; /* TRUE when the IF buffer needs to be flushed before reading in the next bufferfull *//* output file buffer info */dcl ofbuf    (ofbufl - 1) fixed; /* output buffer */dcl ofdev    fixed; ofdev = (-1 and "377"); /* device */dcl ofstart  fixed; ofstart = -1; /* start sector of output  */dcl ofpos    fixed; /* current buffer position */dcl ofsec    fixed; /* and sector number */dcl objlng   fixed; /* object file length (in words) as it grows */dcl introlen fixed; /* length of "intro" part of object file (lowcore) *//* overlay file buffer info */dcl ovbuf   (ovbufl - 1) fixed; /* overlay buffer */dcl ovdev   fixed; ovdev = (-1 and "377"); /* device */dcl ovstart fixed; ovstart = -1; /* start sector of overlay */dcl ovpos   fixed; /* current buffer position */dcl ovsec   fixed; /* and sector number       */dcl ovsecln lit 'swap_total'; /* sector length of overlay file */dcl ovmaxln lit '(core(loc.wsln) - (ovstart - core(loc.wsec)))'; /* size of OVERLAY area of .WORK */dcl redirect.object fixed; redirect.object = 0; /* TRUE if object code should be redirected to overlay file */dcl creating_object fixed; creating_object = 1; /* TRUE if we're creating the object file (set FALSE only in FINISH) */dcl creating_reloc  fixed; creating_reloc  = 0; /* TRUE if we're creating a reloc file    *//* symbol table buffer info */dcl sfbuf   (sfbufl - 1) fixed; /* symbol table buffer */dcl sfdev   fixed; sfdev = (-1 and "377"); /* device                       */dcl sfstart fixed; sfstart = -1; /* start sector of symbol table */dcl sfpos   fixed; /* current buffer position      */dcl sfsec   fixed; /* and sector number            */dcl sfchar  fixed; /* and character number         */dcl sfsecln fixed; /* and sector length            */dcl redirect.symtab fixed; redirect.symtab = 0; /* TRUE if SYMTAB should be redirected to file '-SYMTAB-' */dcl symbol_table    data ('-SYMTAB-'); /* name of symbol table file *//* General error handling:..  ER.SYS: call to abort the compiler because of a system error (most.          likely a consistency check failed)...  ER.FTL: call when something the user did has caused a fatal error.          (i.e., when there's not enough memory to compile the user's.          program).*/er.sys: proc(message, location); /* abort the compiler */   dcl message  fixed array; /* the message to print */   dcl location fixed array; /* name of procedure we failed in */   print;   print '### Compiler system error:';   print '      ', string(message), ' (pass3 ', string(location), ').';   call exit(-1);end er.sys;er.ftl: proc(message); /* process a user related fatal error */   dcl message fixed array; /* the message to print */   print;   print string(message), '.';   call exit(-1);end er.ftl;  /* $$File input/output subroutines:.  .   The following routines are used to  read through the second intermediate.   file and to write to the object file...   The intermediate file is read on a word by word basis.  The last word.   read from the IF may be rewritten by calling WRITEIF...   The routine WRITEOBJ is used to write one more word to the output file..   The output file is randomly accessed under certain conditions to patch.   certain locations of memory.*/handletty: proc;   dcl (chr, brk) fixed;   chr = (read("50") and "177");   if chr = "23" then do; /* handle XOn/XOff */      brk = 0; /* assume no break */      do while (chr <> "21"); if chr = 0 then brk = 1; chr = (read("50") and "177"); end; /* wait for XOn (watch for break) */      if brk then chr = 0; /* force BREAK after XOn */   end;   if chr = 0 then do; call wait_for_break; call exit(-1); end; /* exit on break */   if chr <> "21" then print 'Compiling:     Pass 3         Iteration: ', iteration; /* explain where we are */end handletty;ifforce: proc fixed; /* force IF buffer to disk */   dcl readl fixed; /* length to read */   dcl i     fixed;   readl = ifsecln - ifsec;   if readl igt shr(ifbufl, 8) then readl = shr(ifbufl, 8); /* write length */   if force_if then do; /* only write if we have to */      i = 0; if ifstart + ifsec ilt ifstart then i = 1; /* determine MS sector offset */      call writedata (ifdev + i, ifstart + ifsec, ifbuf, shl(readl, 8)); /* write out altered stuff */      force_if = 0; /* we haven't written to this buffer yet */   end;   return (readl); /* return amount forced */end ifforce;ifread: proc; /* read next buffer from IF (assumes IFFORCE called first) */   dcl readl fixed; /* length to read */   dcl i     fixed;   readl = ifsecln - ifsec;   if readl igt shr(ifbufl, 8) then readl = shr(ifbufl, 8); /* only read this */   i = 0; if ifstart + ifsec ilt ifstart then i = 1; /* determine MS sector offset */   call readdata (ifdev + i, ifstart + ifsec, ifbuf, shl(readl, 8)); /* and read in */end ifread;/* $$More intermediate file processing: */updateif: proc(update); /* flush this bufferful and get next bufferful */   dcl update fixed; /* TRUE if we should update the buffer contents */   if systyp = 0 then write("104") = 0; /* keep disks on */   ifsec = ifsec + ifforce; /* increment to next buffer */   if ifsec = ifsecln /* have we reached the end of the file? */   then call er.sys ('attempting to read/write beyond end of IF', 'updateif');   if update then call ifread; /* read in next bufferful */   write(r13) = addr(ifbuf (0)); /* point to first word of buffer */   if (read("51") and "2") <> 0 then call handletty; /* check terminal */end updateif;readif: proc; /* called to get next word */   if ifpos = ifbufl then call updateif (1); /* get next buffer */   return (read(mr13i)); /* return next word */end readif;  writeif: proc(word); /* rewrite word just read from file */   dcl word fixed;   ifbuf (ifpos - 1) = word; /* there we go */   force_if = 1; /* we now need to write out this buffer */end writeif; /* done */copyif: proc(word); /* called to overwrite next word (used for library copy - assumes we won't read after this) */   dcl word  fixed; /* data to overwrite */   if ifpos = ifbufl then call updateif (0); /* write next buffer */   write(mr13i) = word; /* save it */   force_if = 1; /* we now need to write out this buffer */end copyif;posif: proc fixed; /* returns current file position of the IF (if IFSECLN < 256) */   if ifsec + shr(ifpos + 255, 8) ige 256 /* will we overflow this word? */   then call er.sys ('attempting to POSIF a very large interfile', 'posif');   return (shl(ifsec, 8) + ifpos); /* return buffer start plus buffer position */end posif;resetif: proc(pos); /* call procedure to reset intermediate file to POS (if IFSECLN < 256) */   dcl pos    fixed; /* file position to reset file to */   dcl newsec fixed; /* sector number containing POS */   dcl newpos fixed; /* buffer position within NEWSEC where POS is */   newsec = shr(pos, 8); /* recover requested sector number */   newpos = (pos and "HFF"); /* and requested buffer position within that sector */   if ofsec + shr(ofpos + 255, 8) igt (ifstart - ofstart) + newsec + (newpos <> 0) /* file error - too much object file written */   then call er.ftl ('Program too large (object file/IF collision)'); /* abort */   if newsec ige ifsecln /* is this sector number out of orbit? */   then call er.sys ('can''t reset IF beyond end of file', 'resetif'); /* abort */   if systyp = 0 then write("104") = 0; /* keep disks on */   if (read("51") and "2") <> 0 then call handletty; /* check terminal */   if newsec = 0 then newsec = 1; /* make certain we point past the interpass communications area */   if ((newsec ige ifsec) and (newsec ilt ifsec + shr(ifbufl, 8))) /* is this sector already in memory? */   then write(r13) = addr(ifbuf (newpos + shl(newsec - ifsec, 8))); /* point to desired position */   else do; /* sector not already in memory - read it in */      call ifforce; /* write out the buffer */      ifsec = newsec; /* reset to the desired sector */      call ifread; /* read in desired part of IF */      write(r13) = addr(ifbuf (newpos)); /* reset position to desired place */   end; /* of sector not already in memory */end resetif; /* and done */  /* $$The following routines process the object file (used for linking and.   for generating the final object code). */  objforce: proc; /* used to force object buffer */   dcl i fixed;   if shr(objlng, 8) + ((objlng and "377") <> 0) ige (ifstart - ofstart) + ifsec + shr(ifbufl, 8)   then call er.ftl ('Program too large (pass3 object file)'); /* abort */   i = 0; if ofstart + ofsec ilt ofstart then i = 1; /* determine MS sector offset */   call writedata (ofdev + i, ofstart + ofsec, ofbuf, ofpos); /* write out current information */   ofsec = ofsec + shr(ofpos + 255, 8); /* incr ptrs */   ofpos = 0;end objforce;  writeobject: proc(word); /* append one word to object file - use WRITEOBJ to output to object */  dcl word fixed;  if ofpos = ofbufl then call objforce; /* end of buffer - write it out */  ofbuf (ofpos) = word; /* store word */  ofpos = ofpos + 1; /* incr pos */  if creating_object then do; /* only change OBJLNG if creating the object file */     objlng = objlng + 1; /* increment file length */     if  (objlng         = 0) /* file too big                   */     and (creating_reloc = 0) /* does not apply to relocatables */     then call er.ftl ('Object file too big for compilation'); /* abort */  end;end writeobject; /* and that is it */  /* The following routines process the overlay file during final object code.  generation. */  ovrforce: proc; /* used to force object buffer */   dcl i fixed;   if ovsec + shr(ovpos + 255, 8) igt ovsecln /* too large? */   then do;      call er.sys ('overlay file longer than expected', 'ovrforce'); /* abort */   end;   i = 0; if ovstart + ovsec ilt ovstart then i = 1; /* determine MS sector offset */   call writedata (ovdev + i, ovstart + ovsec, ovbuf, ovpos); /* write out current information */   ovsec = ovsec + shr(ovpos + 255, 8); /* incr ptrs */   ovpos = 0;end ovrforce;  writeovr: proc(word); /* append one word to object file */   dcl word fixed;   if ovpos = ovbufl then call ovrforce; /* end of buffer */   ovbuf (ovpos) = word; /* store word */   ovpos = ovpos + 1; /* incr pos */end writeovr; /* and that is it */writeobj: proc(word); /* append a word to the current object file */   dcl word fixed; /* the word to append */   if redirect.object /* are we redirecting to the overlay file? */   then call writeovr (word); /* yes, write to overlay file */   else call writeobject (word); /* no, write to object file */end writeobj;/* $$The following routines process the overlay file.  They are.   used to copy the overlay file after the object file.  They.   are only used in FINISH (and by the linker to read in libraries);.   keep it that way! */ovrread: proc; /* read next bufferful from overlay file */   dcl readl fixed; /* length to read */   dcl i     fixed;   ovsec = ovsec + shr(ovbufl, 8); /* update current file position (in sectors) */   readl = ovsecln - ovsec; /* try to read the rest of the file */   if readl igt shr(ovbufl, 8) /* if we can't fit the rest in memory */   then readl = shr(ovbufl, 8); /* read what we can */   i = 0; if ovstart + ovsec ilt ovstart then i = 1; /* get MS sector offset */   call readdata (ovdev + i, ovstart + ovsec, ovbuf, shl(readl, 8)); /* read it in */   ovpos = 0; /* reset buffer pointer */   if (read("51") and "2") <> 0 then call handletty; /* check terminal */end ovrread;readovr: proc fixed; /* read the next word from the overlay file */   if ovpos = ovbufl then call ovrread; /* fill buffer if necessary */   ovpos = ovpos + 1; /* point to next word */   return (ovbuf (ovpos - 1)); /* return this word */end readovr;resetovr: proc; /* reset the overlay file to the beginning (position zero) */   if ovpos <> 0 then call ovrforce; /* force the current buffer out */   ovsec = -shr(ovbufl, 8); /* force OVRREAD to red beginning of file */   call ovrread; /* read in first buffer */end resetovr;closeovr: proc; /* close the overlay file */   ovdev = (-1 and "377"); ovstart = -1; /* zap starting sector */   ovsecln = 0; /* no more length */   ovsec = 0; ovpos = 0; /* reset sector/word pointers */end closeovr;/* $$Symbol table output and formatting routines: */symforce: proc fixed; /* force the symbol table buffer */   dcl readl fixed; /* length to write */   dcl i     fixed;   if sfchar /* was there just one character in the last word? */   then sfpos = sfpos + 1; /* yes, make sure that word is output */   if sfpos < sfbufl /* make sure the file ends with a null */   then do;      sfbuf (sfpos) = 0; /* terminate the file with a null */      sfpos = sfpos + 1;   end;   readl = sfpos; /* the length to write is the amount of data in the buffer */   if sfsec + shr(sfpos, 8) ige sfsecln - 1 /* will this buffer fill the file? */   then do; /* yes, better redirect the output */      redirect.symtab = 0; /* redirect output back to the console (just in case there's more) */      if ((sfpos = sfbufl) or (sfsec + shr(sfpos, 8) igt sfsecln - 1)) /* is this last buffer full to the top (or will this overflow the file?) */      then do; /* yes, assume there's more and warn the user of the redirection */         if sfsec + shr(sfpos, 8) igt sfsecln - 1 /* will this buffer overflow the file? */         then readl = shl(sfsecln - sfsec, 8); /* yes, truncate the length to write */         i = shr(sfbuf (readl - 1), 8); /* get last character in buffer */         sfbuf (readl - 1) = (sfbuf (readl - 1) and "HFF"); /* terminate with a null */         print '*** File ''-SYMTAB-'' is not large enough to hold the symbol table.';         print '    Subsequent symbol table output will be redirected to the console.';         if i <> 0 /* if the last character isn't null */         then print character(i),; /* print it */         do i = readl + readl - 2 to (sfpos - 1) + (sfpos - 1) - 1; /* now output anything remaining in this buffer */            if byte(sfbuf, i) <> 0 /* is this an end-of-line? */            then print character(byte(sfbuf, i)),; /* no, print the character */            else do; /* yes, it is */               print; /* send an eol */               if i /* was this found on an even or odd byte? */               then i = i + 2; /* odd - next two bytes are the line number */               else i = i + 3; /* even - next byte is remainder of eol, then next two bytes are line # */            end;         end;      end; /* of buffer overflowed */      call update_length (symbol_table, 1, shl(sfsec, 8) + readl); /* set the file length */   end; /* of redirect output back to screen */   i = 0; if sfstart + sfsec ilt sfstart then i = 1; /* determine MS sector offset */   call writedata (sfdev + i, sfstart + sfsec, sfbuf, readl); /* write out the next buffer */   i = shl(sfsec, 8) + readl; /* get actual word length of file */   sfsec = sfsec + shr(readl + 255, 8); /* point to the next sector */   sfpos = 0; /* and reset the word count */   sfchar = 0; /* reinitialize the character count */   return (i); /* return word length */end symforce;      writesym: proc(chr); /* write a character to the symbol table file */   dcl chr fixed; /* the character to write */   if redirect.symtab /* should we output this info to the SYMTAB file? */   then do; /* yes */      if sfpos = sfbufl then call symforce; /* end of buffer? */      if sfchar /* is this an odd numbered character? */      then do; /* yes, finish off a word */         sfbuf (sfpos) = (sfbuf (sfpos) or shl(chr, 8)); /* then it goes at the top of the word */         sfpos = sfpos + 1; /* point to the next word */      end;      else sfbuf (sfpos) = (chr and "HFF"); /* no, it goes at the low end */      sfchar = sfchar + 1; /* we added another character */   end;   else print character(chr),; /* no send the character */end writesym;eol: proc; /* send an end-of-line to the symbol table */   if redirect.symtab /* is this redirected? */   then do;      call writesym (0); /* just a null in the text file */      if sfchar then call writesym (0); /* make sure it ends on a word boundary */      call writesym (0); call writesym (0); /* and output a null line number */   end;   else print; /* no redirection - just send a cr/lf pair */end eol;pstring: proc(buffer); /* print a string to the symbol table */   dcl buffer fixed array; /* the string to print */   dcl i      fixed;   do i = 0 to buffer (0) - 1; /* output every character */      call writesym (byte(buffer, i));   end;end pstring;unum: proc(n); /* output an unsigned number (0 to 65535) */   dcl (n, i, r) fixed; /* n:  value to print */   dcl go        fixed;   dcl #divisors data (10000,1000,100,10,1); /* powers of ten */   call writesym (a.sp); /* start with a space (no sign) */   go = 0; /* suppress leading zeroes */   do i = 0 to 4; /* loop over 5 digits */      r = 0; /* assume digit is zero */      do while (n ige #divisors (i)); /* simulate unsigned divide */          n = n - #divisors (i);          r = r + 1;      end;      if r > 0 then go = 1; /* turn on printing */      if (go or (i = 4)) /* print at least one zero */      then call writesym (a.0 + r); /* print digit */      else call writesym (a.sp); /* or print space */   end; /* of digits loop */end unum;onum: proc(n); /* output a number in octal */   dcl (n, i) fixed; /* n:  value to print */   n = rot(n, 1);   if n then call writesym (a.1); /* first digit */   else      call writesym (a.0);   do i = 0 to 4; /* loop over 5 digits */      n = rot(n, 3);      call writesym (a.0 + (n & "7"));   end;end onum;/* $$Initialize for pass3: */init: proc;   dcl i fixed;   ifdev = core(loc.usr1); /* device of intermediate file */   ifstart = core(loc.usr2); /* starting sector of intermediate file */   ifsecln = core(loc.usr3); /* and length of interfile */   ifsec = 0; /* start at sector zero */   ofdev = core(loc.wsec + 1); /* object file is the work file */   ofstart = core(loc.wsec); /* object file starts at start of work */        call ifread; /* read in first bufferful */   write(r13) = addr(ifbuf (0)); /* point to first word of buffer */        do i = rtp.ptrs to maxcomm + rtp.ptrs; /* get basic info */      r (i) = readif;   end;   do i = maxcomm + 1 to 255; /* position pointer to first token (ignore remainder of first sector) */      call readif;   end;end init;  /* As part of initialization, read in the entire contents of.  the run time package file into memory. */init_rtp: proc; /* read the rtp into memory */   dcl i fixed;   openfile: proc(file) fixed; /* open the specified system file */      dcl file  fixed array; /* name of file to open */      dcl found fixed; /* TRUE if we found it */      found = locate (file, -2); /* try to open it in path catalog */      if not found then do; /* not in path catalog */         found = locate (file, 0); /* try to open it in system catalog */         if not found /* not in system catalog */         then found = locate (file, 1); /* try to open it in user catalog */      end;      return (found);   end openfile;   if ((prctyp < 2) and (proc_type >= 2)) then do; /* if user wanted Model A or B rather than default of C or later */      if not openfile ('.RTB-7') then call er.ftl ('System file ''.RTB-7'' missing'); /* missing RTP */      rfdev = f#ms_sector; rfstart = f#ls_sector; rflngth = f#words;   end;   else if ((prctyp = 2) and (proc_type < 2)) then do; /* if user wanted Model C or later raher than default or A or B */      if not openfile ('.RTC-7') then call er.ftl ('System file ''.RTC-7'' missing'); /* missing RTP */      rfdev = f#ms_sector; rfstart = f#ls_sector; rflngth = f#words;   end;   else if (prctyp = 3) then do;   /* Model D Compilation */      if (not debug_on) then do;         if not openfile ('.RTD-7') then call er.ftl ('System file ''.RTD-7'' missing'); /* missing RTP */      end;      else do;         if not openfile ('.RTDB-7') then call er.ftl ('System file ''.RTDB-7'' missing'); /* missing RTP */      end;      rfdev = f#ms_sector; rfstart = f#ls_sector; rflngth = f#words;   end;   else do; /* use what MONITOR sent us */      rfdev = core(loc.rt + 1); /* point to rtp's device */      rfstart = core(loc.rt); /* point to rtp */      rflngth = core(loc.rt - 1); /* get length */   end;   if rflngth igt rfbufl /* make sure the rtp isn't larger than our buffer */   then call er.sys ('runtime package is too long', 'init_rtp'); /* abort */   call readdata (rfdev, rfstart, rfbuf, rflngth); /* read in entire rtp file */   introlen = rfbuf (rfbuf (l.sta)) - rfbuf (l.sta) - 1; /* number of words in start routine */   do i = rfbuf (l.sta) + 1 to rfbuf (l.sta) + introlen; /* write the start routine to the object */      call writeobj (rfbuf (i));   end;   rtpcode = introlen; /* rtp data is always at least this much */end init_rtp;/* $$The following routines access the KEYLOC, KEYJTO, and KEYFLAG arrays..  If XMEM is set, the arrays are in external memory.  Otherwise, they are.  in main memory.  KEYLOC.PTR, KEYJTO.PTR, and KEYFLAG.PTR are the arrays'.  base pointers (in words for main memory; in sectors for external memory)...  The KEYLOC array is used to contain the absolute object code location.  of a label definition.  Whenever we come to a label definition,  we.  store the current location counter (CUR.LOC) in the KEYLOC array..  On the second pass through, we can then determine whether or not.  the jump instruction can be compacted into one word. ..  The KEYJTO array is used to indicate whether the instruction at this.  location is another jump instruction (to detect jumps to jumps).  The.  key that is jumped to (if any) from this label location is stored in.  the KEYJTO array.  Before JUMPS, KEYJTO is only used by procedures.  (PROC_NOSWAP and PROC_TEMPS)...  The KEYFLAG array is used to indicate:.    a) whether a label is used as the destination of a jump instruction.       (i.e., whether the code that follows is active) [ABIT],.    b) whether we've encountered this label yet during this pass [DBIT], and.    c) whether this label represents the start of a procedure [PBIT]...  For procedures, KEYFLAG (key + proc_flags) is used to indicate:.    a) whether this procedure is recursive [P.RECURSIVE], and.    b) whether this procedure swaps [P.SWAP], and.    c) whether this procedure swaps its scon/data [P.SWAPSCON]*/dcl keyloc.ptr  fixed; /* pointer to KEYLOC  */dcl keyjto.ptr  fixed; /* pointer to KEYJTO  */dcl keyflag.ptr fixed; /* pointer to KEYFLAG */dcl altloc.ptr  fixed; /* pointer to ALTLOC  */dcl altjto.ptr  fixed; /* pointer to ALTJTO  */dcl altflag.ptr fixed; /* pointer to ALTFLAG */dcl swinfo.ptr  fixed; /* pointer to SWINFO  */dcl swinfo.max  lit '(20*256)'; /* # of swap procedures that are optimized */                                /* twice as much storage is used           */dcl xmem        fixed; xmem = 0; /* set to one if KEYLOC, KEYJTO, and KEYFLAG are in external memory *//* KEYFLAG bit assignments: */dcl abit lit '"01"'; /* indicates active (if not set, indicates unknown) */dcl pbit lit '"02"'; /* indicates this is the label for a procedure entry */dcl dbit lit '"10"'; /* indicates defined already during this pass (chosen so doesn't collide with proc bits - see CLEAR_KEYFLAG) *//* Data storage for procedure definitions:                         *//*                                                                 *//*    The first 3 keys are actual location keys using KEYLOC,      *//*    KEYJTO,  and KEYFLAGS.   The next two locations of each of   *//*    these three arrays is used for special information not       *//*    related to keys or locations or jumps:                       */dcl proc_entry  lit '0'; /* offset for procedure entry key */dcl proc_jump   lit '1'; /* offset for jump around procedure key */dcl proc_return lit '2'; /* offset for procedure return key */dcl proc_dswp   lit '3'; /* KEYLOC   - offset for NOSWAP bit list     */                         /*   for procedure data (1st two iterations) */dcl proc_regs   lit '3'; /* KEYLOC   - offset for registers used      */                         /*   by procedure (3rd iteration and on)     */dcl proc_inside lit '1'; /*   bit 0 - set to 1 if this proc is        */                         /*   defined inside a swapping procedure.    */dcl proc_bound  lit '2'; /*   bit 1 - set to 1 if this proc is        */                         /*   forced to a page boundary               */dcl reg_mask    lit '(not(15))';dcl proc_stack  lit '4'; /* KEYLOC   - offset for stack frame size    */dcl proc_noswap lit '3'; /* KEYJTO   - offset for formal parameter    */                         /*   NOSWAP bitlist (thru JUMPS)             */dcl proc_objsz  lit '3'; /* KEYJTO   - length of object code only (no */                         /*   SCONS) of swapping procedure - SWAP     */                         /*   and after.                              */dcl proc_temps  lit '4'; /* KEYJTO   - offset for temp start of       */                         /*            temps in recursive procs       */dcl proc_flags  lit '3'; /* KEYFLAGS - offset for procedure flags     */dcl proc_info   lit '4'; /* KEYFLAGS - more info about the proc       */dcl proc_when   lit '1'; /*   bit 0 - set if a proc is called from    */                         /*   within a when statement                 *//* Note:  KEYJTO   (4) is only used by recursive procs                *//* Note:  KEYFLAGS (4) is unused, but it is only a 4-bit field        *//* Swinfo storage: 2 words per swapping procedure,  indexed by        *//*                 2 * swapping proc id#                              *//*                 information is nonzero only if compiling for       *//*                 model d and procedure has no swapping strings or   *//*                 data (ie SWAPCODE)                                 *//*    word 0:      location on page where procedure starts            *//*    word 1:      lower half - page (relative to start of swap file) *//*    word 1:      upper half - number of arguments passed to proc    */keyloc: proc(index) fixed; /* return the contents of array cell KEYLOC (index) */   dcl index fixed; /* index into KEYLOC array */   if xmem <> 0 then do; /* if KEYLOC is in external memory */      write(mam) = keyloc.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      return (read (md)); /* return the element */   end;   else return (core(keyloc.ptr + index)); /* it's in main memory */end keyloc;altloc: proc(index) fixed; /* return the contents of array cell ALTLOC (index) */   dcl index fixed; /* index into ALTLOC array */   if xmem <> 0 then do; /* if ALTLOC is in external memory */      write(mam) = altloc.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      return (read (md)); /* return the element */   end;   else return (core(altloc.ptr + index)); /* it's in main memory */end altloc;set_keyloc: proc(index, value); /* set the contents of array cell KEYLOC (index) to VALUE */   dcl index fixed; /* index into KEYLOC array */   dcl value fixed; /* value to set element to */   if xmem <> 0 then do; /* if KEYLOC is in external memory */      write(mam) = keyloc.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      write(md)  = value; /* set the element to VALUE */   end;   else core(keyloc.ptr + index) = value; /* it's in main memory */end set_keyloc;set_altloc: proc(index, value); /* set the contents of array cell ALTLOC (index) to VALUE */   dcl index fixed; /* index into ALTLOC array */   dcl value fixed; /* value to set element to */   if xmem <> 0 then do; /* if ALTLOC is in external memory */      write(mam) = altloc.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      write(md)  = value; /* set the element to VALUE */   end;   else core(altloc.ptr + index) = value; /* it's in main memory */end set_altloc;keyjto: proc(index) fixed; /* return the contents of array cell KEYJTO (index) */   dcl index fixed; /* index into KEYJTO array */   if xmem <> 0 then do; /* if KEYJTO is in external memory */      write(mam) = keyjto.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      return (read (md)); /* return the element */   end;   else return (core(keyjto.ptr + index)); /* it's in main memory */end keyjto;altjto: proc(index) fixed; /* return the contents of array cell ALTJTO (index) */   dcl index fixed; /* index into ALTJTO array */   if xmem <> 0 then do; /* if ALTJTO is in external memory */      write(mam) = altjto.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      return (read (md)); /* return the element */   end;   else return (core(altjto.ptr + index)); /* it's in main memory */end altjto;set_keyjto: proc(index, value); /* set the contents of array cell KEYJTO (index) to VALUE */   dcl index fixed; /* index into KEYJTO array */   dcl value fixed; /* value to set element to */   if xmem <> 0 then do; /* if KEYJTO is in external memory */      write(mam) = keyjto.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      write(md)  = value; /* set the element to VALUE */   end;   else core(keyjto.ptr + index) = value; /* it's in main memory */end set_keyjto;set_altjto: proc(index, value); /* set the contents of array cell ALTJTO (index) to VALUE */   dcl index fixed; /* index into ALTJTO array */   dcl value fixed; /* value to set element to */   if xmem <> 0 then do; /* if ALTJTO is in external memory */      write(mam) = altjto.ptr + shr(index, 8); /* write sector address of array element */      write(mal) = index; /* and word address */      write(md)  = value; /* set the element to VALUE */   end;   else core(altjto.ptr + index) = value; /* it's in main memory */end set_altjto;keyflag: proc(index) fixed; /* return the contents of array cell KEYFLAG (index) */   dcl index fixed; /* index into KEYFLAG array */   dcl value fixed; /* retrived value */   if xmem <> 0 then do; /* if KEYFLAG is in external memory */      write(mam) = keyflag.ptr + shr(index, 8 + 2); /* write sector address of array element */      write(mal) = shr(index, 2); /* and word address */      value = read (md); /* pick up word containg requested nibble from external memory */   end;   else value = core(keyflag.ptr + shr(index, 2)); /* it's in internal memory */   do case (index and "3"); /* hardcode SHR(VALUE, SHL(INDEX AND "3", 2)) */      return (    value      and "17"); /* SHR by 0 */      return (shr(value,  4) and "17"); /* SHR by 4 */      return (shr(value,  8) and "17"); /* SHR by 8 */      return (shr(value, 12) and "17"); /* SHR by 12 */   end;end keyflag;altflag: proc(index) fixed; /* return the contents of array cell ALTFLAG (index) */   dcl index fixed; /* index into ALTFLAG array */   dcl value fixed; /* retrived value */   if xmem <> 0 then do; /* if ALTFLAG is in external memory */      write(mam) = altflag.ptr + shr(index, 8 + 2); /* write sector address of array element */      write(mal) = shr(index, 2); /* and word address */      value = read (md); /* pick up word containg requested nibble from external memory */   end;   else value = core(altflag.ptr + shr(index, 2)); /* it's in internal memory */   do case (index and "3"); /* hardcode SHR(VALUE, SHL(INDEX AND "3", 2)) */      return (    value      and "17"); /* SHR by 0 */      return (shr(value,  4) and "17"); /* SHR by 4 */      return (shr(value,  8) and "17"); /* SHR by 8 */      return (shr(value, 12) and "17"); /* SHR by 12 */   end;end altflag;set_keyflag: proc(index, value); /* set the contents of array cell KEYFLAG (index) to VALUE */   dcl index fixed; /* index into KEYFLAG array */   dcl value fixed; /* value to set element to */   dcl mask data (not "17", not shl("17", 4), not shl("17", 8), not shl("17", 12)); /* masks for each nibble position */   value = (value and "17"); /* keep lowest nibble only */   do case (index and "3"); /* move nibble to proper position [hardcode SHL(VALUE, SHL(INDEX AND "3", 2))] */      ; /* SHL by 0 */      value = shl(value,  4); /* SHL by 4 */      value = shl(value,  8); /* SHL by 8 */      value = shl(value, 12); /* SHL by 12 */   end; /* of moving nibble to proper position */   if xmem <> 0 then do; /* if KEYFLAG is in external memory */      write(mam) = keyflag.ptr + shr(index, 8 + 2); /* write sector address of array element */      write(mal) = shr(index, 2); /* and word address */      write(md) = ((read(md) and mask (index and "3")) or value); /* set the element to VALUE */   end;   else core(keyflag.ptr + shr(index, 2)) = ((core(keyflag.ptr + shr(index, 2)) and mask (index and "3")) or value); /* it's in main memory */end set_keyflag;set_altflag: proc(index, value); /* set the contents of array cell ALTFLAG (index) to VALUE */   dcl index fixed; /* index into ALTFLAG array */   dcl value fixed; /* value to set element to */   dcl mask data (not "17", not shl("17", 4), not shl("17", 8), not shl("17", 12)); /* masks for each nibble position */   value = (value and "17"); /* keep lowest nibble only */   do case (index and "3"); /* move nibble to proper position [hardcode SHL(VALUE, SHL(INDEX AND "3", 2))] */      ; /* SHL by 0 */      value = shl(value,  4); /* SHL by 4 */      value = shl(value,  8); /* SHL by 8 */      value = shl(value, 12); /* SHL by 12 */   end; /* of moving nibble to proper position */   if xmem <> 0 then do; /* if ALTFLAG is in external memory */      write(mam) = altflag.ptr + shr(index, 8 + 2); /* write sector address of array element */      write(mal) = shr(index, 2); /* and word address */      write(md) = ((read(md) and mask (index and "3")) or value); /* set the element to VALUE */   end;   else core(altflag.ptr + shr(index, 2)) = ((core(altflag.ptr + shr(index, 2)) and mask (index and "3")) or value); /* it's in main memory */end set_altflag;clear_keyflag: proc(bit); /* clear BIT in entire KEYFLAG and ALTFLAG array (assumes no bit definition collosions) */   dcl bit fixed; /* bit to clear */   dcl i   fixed;   bit = (not (bit or shl(bit, 4) or shl(bit, 8) or shl(bit, 12))); /* set up bit mask */   if xmem <> 0 then do; /* if KEYFLAG is in external memory */      write(mam) = keyflag.ptr; /* write sector address of KEYFLAG */      do i = 0 to shr(r (l.key), 2); /* loop over entire array */         write(mdi) = (read(md) and bit); /* turn off bit */      end;      write(mam) = altflag.ptr; /* write sector address of ALTFLAG */      do i = 0 to shr(r (l.altkey), 2); /* loop over entire array */         write(mdi) = (read(md) and bit); /* turn off bit */      end;   end;   else do;      do i = 0 to shr(r (l.key), 2); /* KEYFLAG is in internal memory */         core(keyflag.ptr + i) = (core(keyflag.ptr + i) and bit); /* turn off bit */      end;      do i = 0 to shr(r (l.altkey), 2); /* ALTFLAG is in internal memory */         core(altflag.ptr + i) = (core(altflag.ptr + i) and bit); /* turn off bit */      end;   end;end clear_keyflag;swinfo: proc(ptr);     /* look up info about a swapping procedure */   dcl ptr fixed;      /* pass pointer using stride of 2          */   write(mam) = swinfo.ptr + shr(ptr,8);   write(mal) = ptr;   return read(md);    /* return with pointers set up in case modify */end swinfo;set_swinfo: proc(ptr,val);     /* store info about a swapping procedure */   dcl ptr fixed;              /* pass pointer using stride of 2          */   dcl val fixed;   write(mam) = swinfo.ptr + shr(ptr,8);   write(mal) = ptr;   write(md ) = val;end set_swinfo;/* $$Stack routines:.  .     A push down stack is used to store information during pass3.  The.     following routines store and read information from the stack. */  dcl stk (stacklen) fixed; /* holds it        */dcl stkptr         fixed; /* pointer to same */  push: proc(word); /* save on stack */  dcl word fixed;  if stkptr igt stacklen then call er.sys ('stack overflow', 'push');  stk (stkptr) = word;  stkptr = stkptr + 1; /* incr */end push;  pop: proc; /* and recover from stack */  stkptr = stkptr - 1; /* decrement ponter */  return (stk (stkptr)); /* get it */end pop;dcl altstk (stacklen) fixed; /* holds it        */dcl altstkptr         fixed; /* pointer to same */  altpush: proc(word); /* save on stack */  dcl word fixed;  if altstkptr igt stacklen then call er.sys ('alt stack overflow', 'altpush');  altstk (altstkptr) = word;  altstkptr = altstkptr + 1; /* incr */end altpush;  altpop: proc; /* and recover from stack */  altstkptr = altstkptr - 1; /* decrement ponter */  return (altstk (altstkptr)); /* get it */end altpop;dcl istk (istacklen) fixed; /* insert file stack */dcl istkptr          fixed; /* pointer to same */ipush: proc(word); /* save on insert file stack (must be used in OPTIMIZE because normal stack is used for jumps) */   dcl word fixed;   if istkptr igt istacklen then call er.sys ('stack overflow', 'ipush');   istk (istkptr) = word; /* save it */   istkptr = istkptr + 1; /* and increment pointer */end ipush;ipop: proc; /* remove from insert file stack */   istkptr = istkptr - 1; /* decrement pointer */   return (istk (istkptr)); /* get it */end ipop;dcl pstk (pstacklen) fixed; /* procedure stack */dcl pstkptr          fixed; /* pointer to same */ppush: proc(word); /* save on procedure stack (must be used in OPTIMIZE because normal stack is used for jumps) */   dcl word fixed;   if pstkptr igt pstacklen then call er.sys ('stack overflow', 'ppush');   pstk (pstkptr) = word; /* save it */   pstkptr = pstkptr + 1; /* and increment pointer */end ppush;ppop: proc; /* remove from procedure stack */   pstkptr = pstkptr - 1; /* decrement pointer */   return (pstk (pstkptr)); /* get it */end ppop;/* $$SKIPRECORD:..   The SKIPRECORD procedure is used to skip information from the.   intermediate file.  The compiler skips such information when it.   determines that certain sections of a program will never be executed..   This happens, for example, when a procedure is never called or.   during certain if/then/else and do loop processing. */skiprecord: proc(typ); /* pass type of record */   dcl typ fixed;   dcl len fixed;   if (typ and literal.mask) <> 0 then return; /* skip literal word */   len = et.length (typ); /* get length to skip */   if len = -1 then len = (readif and "377"); /* if variable length, READ the length */   do len = 1 to len; /* skip over record */      call readif;   end;end skiprecord;/* Routine EMITT:.  .  This routine is passed a number.  If that number can be expressed in.  the immediate field of one instruction, a true value (1) is returned...  EMITT is used to determine which jump instructions can be performed in.  one instruction and which jump instructions will require two instructions. */  emitt: proc(n);   dcl n fixed;   if (n and "177740") = "177740" then return (1);   if (n and "177740") = "000000" then return (1);   return (0);end emitt;/* $$The following routines are used to emit code to save index registers.   within a procedure...   These procedures determine the number of registers that must be saved.   during a procedure call (NUMBITS),  emit instructions to save.   registers on the stack (SAVEREGS),  and emit instructions to load the.   registers from the stack (LOADREGS). */numbits: proc(val); /* see how many bits set in val */   dcl (val, i, j) fixed;   i = 1;   j = 0;   do while val >= i; /* while any bits set */      if (val and i) <> 0 then j = j + 1;      i = shl(i, 1);   end;   return (j);end;xmit: proc(sou, des); /* shorthand */   dcl (sou, des) fixed;   call writeobj (shl(des, 8) or sou);end xmit;saveregs: proc(bits); /* emit in line code to save registers */   dcl (bits, i, j) fixed;   if prctyp < 2 then call xmit (b.rs + b.ibt + "15", b.rd + "12"); /* r15i to r12 */   i = 1; j = 0;   do while (bits >= i);     if (bits and i) <> 0 then do; /* need to save this register */        if prctyp < 2 /* models A & B */        then call xmit (b.rs + j, b.md + b.ibt + "15"); /* r to mr15i */        else call xmit (b.rs + j, b.md + b.ibt + "12"); /* r to mr12d on model C */     end;     i = shl(i, 1); j = j + 1;   end;   if prctyp < 2 then call xmit (b.rs + "12", b.md + "15"); /* r12 to mr15 save back pointer */end saveregs;loadregs: proc(bits); /* emit code to load registers */   dcl (bits, i, j) fixed;   if prctyp < 2 then do; /* models A and B */      call xmit (b.ms + "15", b.rd + "12"); /* mr15 to r12 */      call xmit (b.rs + b.ibt + "12", b.ca + b.tnv); /* incre r12 (r12i to atnv) */      i = 1;j = 0;      do while bits >= i;        if (bits and i) <> 0 then call xmit (b.ms + b.ibt + "12", b.rd + j); /* mr12i to r */        i = shl(i, 1);j = j + 1;      end;      call xmit (b.ms + "15", b.rd + "15"); /* mr15 to r15 - back up pointer */   end;   else do; /* Model C & later - load in reverse order */      i = "100000"; j = 15;      do while (i <> 0); /* stop when all registers have been loaded */         if (bits and i) <> 0 then call xmit (b.ms + b.ibt + "12", b.rd + j); /* mr12i to rX */         i = shr(i, 1); j = j - 1;      end;   end;end loadregs;/* $$Pass3 of the compiler will detect any procedures that are never.   called.  The object code for these procedures are deleted from.   object file,  and the storage for variables defined in the.   procedures is deallocated...   The following procedures manipulate the ram and scon area pointers for.   deleted procedures. */delram: proc(loc, len); /* procedure used to delete a block of ram */   dcl (loc, len, p) fixed;   if len = 0 then return; /* ignore zero-length blocks */   p = 0; /* start at the beginning of the list */   do while ((p < ramptr) and (oldram (p) ilt loc)); /* find where to insert this block */      p = p + 1;   end;   if ((p <> ramptr) and (oldram (p) = loc)) then do; /* join up with existing block */      oldram (p) = loc + len; /* point one past the end of the block */      deltaram (p) = deltaram (p) + len; /* update length */   end;   else if ramptr <= divmax then do; /* insert new block */      call blockmove (location(addr(oldram (p))), location(addr(oldram (p + 1))), ramptr - p); /* make room */      call blockmove (location(addr(deltaram (p))), location(addr(deltaram (p + 1))), ramptr - p);      oldram (p) = loc + len; /* point one past end of block */      deltaram (p) = len; /* save length */      ramptr = ramptr + 1; /* there's now one more entry */   end; /* of inserting new block */   else call er.ftl ('Program too complex for compilation (deleted ram too fragmented)');end delram;delscon: proc(loc, len); /* procedure used to delete a block of scon */   dcl (loc, len, p) fixed;   if len = 0 then return; /* ignore zero-length blocks */   p = 0; /* start at the beginning of the list */   do while ((p < sconptr) and (oldscon (p) ilt loc)); /* find where to insert this block */      p = p + 1;   end;   if ((p <> sconptr) and (oldscon (p) = loc)) then do; /* join up with existing block */      oldscon (p) = loc + len; /* point one past the end of the block */      deltascon (p) = deltascon (p) + len; /* update length */   end;   else if sconptr <= divmax then do; /* insert new block */      call blockmove (location(addr(oldscon (p))), location(addr(oldscon (p + 1))), sconptr - p); /* make room */      call blockmove (location(addr(deltascon (p))), location(addr(deltascon (p + 1))), sconptr - p);      oldscon (p) = loc + len; /* point one past end of block */      deltascon (p) = len; /* save length */      sconptr = sconptr + 1; /* there's now one more entry */   end; /* of inserting new block */   else call er.ftl ('Program too complex for compilation (deleted scon too fragmented)');end delscon;_adjram: proc(loc, err) fixed; /* system procedure used to adjust ram location for tossed p */   dcl (loc, err, i, j) fixed;   j = loc; /* start here */   i = 0;   do while (i < ramptr) and (loc ige oldram (i));     j = j - deltaram (i); /* reduce */     i = i + 1;   end;   if (err and (i < ramptr) and (loc ilt oldram (i)) and (loc ige oldram (i) - deltaram (i)))   then call er.sys ('attempting to map deleted ram', 'adjram');   return (j);end _adjram;adjram: proc(loc) fixed; /* user procedure used to adjust ram location for tossed p */   dcl loc fixed;   return (_adjram (loc, 1));end adjram;adj_ram: proc(loc) fixed; /* user procedure used to adjust ram location for tossed p (no error checking) */   dcl loc fixed;   return (_adjram (loc, 0));end adj_ram;_adjscon: proc(loc, err) fixed; /* system procedure used to adjust scon location for tossed p */   dcl (loc, err, i, j) fixed;   j = loc; /* start here */   i = 0;   do while (i < sconptr) and (loc ige oldscon (i));      j = j - deltascon (i); /* reduce */      i = i + 1;   end;   if (err and (i < sconptr) and (loc ilt oldscon (i)) and (loc ige oldscon (i) - deltascon (i)))   then call er.sys ('attempting to map deleted scon', 'adjscon');   return (j);end _adjscon;adjscon: proc(loc) fixed; /* user procedure used to adjust scon location for tossed p */   dcl loc fixed;   return (_adjscon (loc, 1));end adjscon;adj_scon: proc(loc) fixed; /* user procedure used to adjust scon location for tossed p (no error checking) */   dcl loc fixed;   return (_adjscon (loc, 0));end adj_scon;