/* $Dump statistics */  /* Scientific XPL Compiler - Pass 2 .  .    This program forms the second pass of the XPL compiler.  This program.    reads through the intermediate file generated by pass1, computes.    the instructions to perform the program being compiled, and writes.    them out to a second intermediate file for further processing by.    pass3...    Certain sections of this program (parts of the statement scanner and.    parts of the expression compiler) were written by David M. Pearson, .    Dartmouth '75.  Most of the rest was written by Cameron W. Jones, .    Thayer '76, for the Bachelor of Engineering project..      .    Accordingly:.       Copyright (C) 1973 Cameron W. Jones and David M. Pearson.       Copyright (C) 1974 Cameron W. Jones and David M. Pearson.       Copyright (C) 1975 Cameron W. Jones and David M. Pearson.       Copyright (C) 1976 Cameron W. Jones and David M. Pearson.       Copyright (C) 1977 Cameron W. Jones.       Copyright (C) 1978 Cameron W. Jones.       Copyright (C) 1979 Cameron W. Jones.       Copyright (C) 1980 and on by New England Digital Corporation..    Modification history:.      12 Oct 1983:  Recreated relocatable XPL [KJC].      16 Feb 1984:  Cleaned up pass1 to pass2 interfile [KJC].      20 Feb 1984:  Added INSERT statement record for pass3 symbol table [KJC].      27 Feb 1984:  Added support for true recursion [KJC].      20 Jul 1984:  Optimized WRITE and READ so all registers aren't destroyed [KJC].       9 Aug 1984:  Moved DO CASE in-line & deallocated temps in iterative DO [KJC].      14 Sep 1984:  Added overlays [KJC].       7 Nov 1984:  Changed EM.TRA to pass -1 as estimated location for Pass 3 OPTIMIZE [KJC].      20 Dec 1984:  Changed EM.OFT to pass a relative value and EM.CAL to set ZFLAGS to zero in modules (for Model C) [KJC].      27 Dec 1984:  Shrink out scon/data and temps from uncalled procs (EM.OFT, EM.PDF, EM.PEN) [KJC].      15 Apr 1985:  Removed Model A processor support [KJC].      27 Jul 1985:  Changed structure of linked programs so MAIN is first [KJC].      16 Aug 1985:  Added swapping of SCON [KJC].      28 Oct 1985:  Added INVOKE statement [KJC].      15 Oct 1986:  Updated for -7 catalog structure [KJC].       4 Nov 1986:  Changed RECURSIVE procs to calculate variable pointers [KJC].       8 Nov 1986:  Defined and fully supported storage classes [KJC].      14 Nov 1986:  Automatic variable object code optimization and fixes [CWJ].      24 Oct 1990:  Allowed more keys by using alternate keys for.                    if/then/else and do/while transfers.*/configuration modelD, nomuldiv;pdl 1024;insert ':xpl611:defs'; 			/* general definitions */insert ':xpl611:p2-defs'; 		/* pass2 definitions */insert ':xpl611:p12-defs'; 		/* pass1 and pass2 specific definitions */insert ':xpl611:p23-defs'; 		/* pass2 and pass3 specific definitions */insert ':xpl611:overlay'; 		/* get overlay and open ruotines */when break then call exit(-1); /* stop while printing if desired */pass2: proc(ifdev, ifstart, iflength) fixed;   dcl ifdev       fixed array; /* interfile device (returned) */   dcl ifstart     fixed array; /* interfile starting sector (returned) */   dcl iflength    fixed array; /* interfile sector length (returned) */   dcl end_of_main fixed; /* key for end of main program */   dcl trmst       fixed; /* termination status */   insert ':xpl611:p2-1';   insert ':xpl611:p2-2';   insert ':xpl611:p2-3';   insert ':xpl611:p2-4';   insert ':xpl611:p2-5';   insert ':xpl611:p2-6';   insert ':xpl611:p2-7';   call init; /* initialize */       if (((flags and module.flag) = 0) and ((flags and link.flag) <> 0)) then do; /* is this a program that needs to be linked? */      end_of_main = gkey; /* get a key for the start of the libraries */      main_key = gkey; /* and one for the start of the main program (save for pass 3) */      call em.tra (b.tra, end_of_main); /* emit a transfer around the main code */      call em.lde (main_key); /* define the start of the main program (pass3 must emit a transfer to this) */      call em.ldf (-1); /* emit a library definition record for MAIN (only place we call this in pass 2) */   end;   call scanc; /* get started */   token = peek; /* check next */   do while (token <> t.eof); /* compile the entire file */      call stmt; /* compile the next statement */      token = peek; /* and check ahead */   end;   call freetemp; /* free up any remaining temporaries */   call accpurg; /* free up all storage for end check */        if ram ige extern.base then do; /* was too much ram allocated? */      print;      print 'Program too large (too many variables declared).';      call exit(-1);   end;   if (stackpt or blk.in.use) <> 0 then do; /* system error */      print;      print '### Compiler system error (pass 2 stackpt', stackpt, ' in use', blk.in.use, ')';      call exit(-1);   end;       if (flags and module.flag) = 0 then do; /* is this a program (rather than a module)? */      call emitc (0, b.rd + 0); /* yes, emit "call exit (0);" at end of code */      call em.rtp (l.ter); /* actual call */      if (flags and link.flag) <> 0 /* do we need to link in any libraries? */      then call em.lde (end_of_main); /* yes, define the end of the main program */   end;   call em.eof; /* and output an EOF */       if2lng = ifsec + shr(ifpos, 8) + ((ifpos and "377") <> 0); /* get length in sectors of IF2 */   call ifforce; /* and force our output file */       call writedata (ifd, ifs, r, maxcomm + 1); /* write out the new interpass comm area */   ifdev (0) = ifd; /* return IF's device */   ifstart (0) = ifs; /* its starting sector */   iflength (0) = if2lng; /* and its sector length */   return (trmst); /* return the termination status */end pass2;/* Pass two initialization and termination: */dcl ifdev       fixed; /* device of interfile */dcl ifstart     fixed; /* start of interfile  */dcl iflength    fixed; /* length of interfile */dcl term_status fixed; /* termination status  */term_status = pass2 (loc(addr(ifdev)), loc(addr(ifstart)), loc(addr(iflength))); /* invoke the second pass */ if term_status = 0 then do; /* overlay on clean termination */   core(loc.usr1) = ifdev; /* pass IF device onto pass3 */   core(loc.usr2) = ifstart; /* save start of IF for pass3 */   core(loc.usr3) = iflength; /* and save length of interfile */   call overlay (core(loc.p3 + 1), core(loc.p3), core(loc.p3 - 1)); /* and overlay pass3 */end;call exit(-1); /* abort */