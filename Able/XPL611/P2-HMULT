/* Hardware multiply/divide: */dcl brtab2 data (1, 0, 1, 0, 1); /* div times mod fmu fdi */dcl atab   data (5, 5, 4, 4, 5); /* answer device */do case (brtab2 (opr - o.div)); /* branch on type */do; /* muliply, fractional multiply */  reg1=0; reg2=0; tmp=0;  if (opr = o.fmu) or (tree = divarg) then do; /* see if msb reqd */    call freemul; /* free up the multiplier */    reg1 = in.reg (arg1, reg2); /* get in any registers, except ARG2 */    reg2 = in.reg (arg2, reg1); /* get in any register, except ARG1 */    tmp = reg.allc (reg1 or reg2); /* allocate register for msb correction */  end;  else do; /* normal multiply */    if ((d4used = 1) and (d4block <> arg1))    or ((d5used = 1) and (d5block <> arg1)) then call freemul; /* free up unless ARG1 */    tmp = 0; /* no correction required */  end;  call sendit (arg1, 5, reg1 or reg2 or tmp); /* write ARG1 */  call sendit (arg2, 6, reg1 or reg2 or tmp); /* write ARG2 - both regs now free */  x.node (tree) = x.dev; x.info (tree) = atab (opr - o.div);  x.arg1 (tree) = t.var;  if opr = o.fmu then do; /* fmul */    reg.d = tmp; /* answer is here */    call in.reg (tree, not tmp); /* get answer in register */  end;  else do; /* multiply */    reg.d = 0; /* no answer */    call x.rel (arg1); call x.rel (arg2); /* free up arguments */    d5used = 1; d5block = tree; /* indicate D5 is used */    x.arg2 (d5block) = reg.pref;    if tree = divarg then do; /* need 32-bits */      upperblock = x.get;      x.node (upperblock) = x.dev; x.arg1 (upperblock) = t.var;      x.info (upperblock) = 4;      call in.reg (upperblock, not tmp); /* and get uppers in register */    end;  end;  if tmp <> 0 then do; /* must do correction */    call emitc (0, b.ad + b.add + bitreg (reg1)); /* test ARG1 */    call emitc (1, b.cr + b.tpl); /* skip if pos */    call emita (b.rs + bitreg (reg2), b.ad + b.sub + bitreg (tmp));    call emitc (0, b.ad + b.add + bitreg (reg2));    call emitc (1, b.cr + b.tpl);    call emita (b.rs + bitreg (reg1), b.ad + b.sub + bitreg (tmp));    call freeup (tmp); /* register is now clobbered */  end;end; /* of mul and fmu */begin; /* div mod fdi */  dcl (r1, r2, b1, b2, b3) fixed;  call freemul; /* free up multiplier */  if opr = o.fdi then do; /* fractional divide */    reg1 = in.reg (arg1, reg2); /* get ARG1 (msb) in reg */    r1 = reg1;    r2 = reg.allc (r1 or reg2);    call emitc (0, b.rd + bitreg (r2));    call freeup (r2); /* no clobbered */  end;  else if arg1 = divarg then do; /* 32-bit multiply */    r1 = in.reg (upperblock, reg2); /* get upper */    call x.rel (upperblock);    upperblock = 0;    reg1 = in.reg (arg1, r1 or reg2); /* get in reg */    r2 = reg1; /* and this contains lsb */  end;  else do; /* normal div or mod */    r1 = reg.allc (reg1 or reg2); /* get a reg */    call emitc (0, b.rd + bitreg (r1)); /* assume pos */    call freeup (r1);    reg1 = in.reg (arg1, r1 or reg2); /* get lsb */    r2 = reg1;    if zflags <> r2 then call emitc (0, b.ad + b.add + bitreg (r2));    call emitc (1, b.cr + b.tpl); /* skip if pos */    call emitc ( - 1, b.rd + bitreg (r1)); /* else signs of all ones */  end;  reg2 = in.reg (arg2, r1 or r2); /* get third arg in reg */  b1 = bitreg (r1); b2 = bitreg (r2); b3 = bitreg (reg2);  if zflags <> reg2 then call emitc (0, b.ad + b.add + b3);  call emitc (7, b.cr + b.tpl);  call emita (b.rd + b1, b.ad + b.com + b1);  call emita (b.rd + b2, b.ad + b.com + b2);  call emitc (1, b.ad + b.add + b2);  call emitc (1, b.cr + b.tnc);  call emitc (1, b.ad + b.add + b1);  call emita (b.rd + b3, b.ad + b.com + b3);  call emitc (1, b.ad + b.add + b3);  call emitc (0, b.ad + b.add + b1); /* see if - msb */  call emitc (1, b.cr + b.tpl);  call emita (b.rs + b3, b.ad + b.add + b1);  call emita (b.rs + b2, 5);  call emita (b.rs + b1, 4);  call emita (b.rs + b3, 7);  call freeup (r1); call freeup (r2); call freeup (reg2);  x.node (tree) = x.dev; x.arg1 (tree) = t.var; x.info (tree) = atab (opr - o.div);  x.arg2 (tree) = reg.pref; /* save these */  if opr = o.mod then do; /* mod - protect it */    d4used = 1; d4block = tree;  end;  else do;    d5used = 1; d5block = tree;  end;  call x.rel (arg1); call x.rel (arg2);  reg.d = 0;  reg.free = (reg.free or r1 or r2 or reg2);end; /* of fdi, mod, div */end; /* of do case */