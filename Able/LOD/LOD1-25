/* LOD1-25 - subroutines to start, stop, and set new volumes for voices *//* 10/16/91 - cj - used different timing in terminate.output to work    *//*                 around SyncSound problems                            *//* 03/19/91 - cj - ramped up output at loop start to remove clicks      *//* 03/08/91 - cj - ramp down outputs digitally for DDSAD                *//* 06/20/89 - cj - fixed bug in call to turn.off.voice that generated   *//*                 click when stopping output                           *//* The following variables keep track of the status of the output voices *//* Use of Chan.On:                                                       *//*    0:  voice is off.                                                  *//*    1:  unused                                                         *//*    2:  voice is on playing back repro data                            *//*    3:  voice is on playing back repro data but we are trying to       *//*        turn it off,  so the envelope limits have been set to 0        *//*    4:  voice is on playing input data (monitoring)                    *//*    5:  voice is on playing input data (monitoring) but we are trying  *//*        to turn it off,  so the envelope limit register is 0           */dcl chan.on          (  max.voices-1) fixed PUBLIC;dcl chan.on.track#   (  max.voices-1) fixed; /* if on, holds dtd track#      */dcl chan.on.priority (  max.voices-1) fixed; /* priority of segment on now   */dcl chan.on.end      (2*max.voices-1) fixed; /* ending sample # of segment   */dcl desired.track#   (  max.voices-1) fixed; /* holds 256 + desired track#   */dcl desired.strack#  (  max.voices-1) fixed; /* desired syncl track #        */dcl desired.priority (  max.voices-1) fixed; /* priority of this assignment  */dcl desired.time     (2*max.voices-1) fixed; /* time for voice priority      */dcl desired.sync     (2*max.voices-1) fixed; /* time for voice syncing       */dcl desired.end      (2*max.voices-1) fixed; /* end time for syncing         */dcl rec.chan.on      (max.tracks-1)  fixed;  /* 0: off  1: on                */dcl last.ria         (max.tracks-1)  fixed;/* Storage areas for DDT harddware: */dcl desired.voice#  (  max.ddts-1)   fixed; /* voice # to get data from      */dcl ddt.on          (  max.ddts-1)   fixed; /* lower half:                   */                                            /* 0 = off; 1 = repro; 2 = input */                                            /* upper half:                   */                                            /* track # data came from        */dcl ddt.on.priority (  max.ddts-1)   fixed; /* priority of audio segment     */dcl ddt.on.end      (2*max.ddts-1)   fixed; /* sample # to end   at          */dcl ddt.bounce.trk  (  max.ddts-1)   fixed; /* 256 + dest track # if bounce  */dcl ddt.bounce.sou  (  max.ddts-1)   fixed; /* 256+trk#/512+voice#           *//* variables to describe contents of DDT output buffer:                      */dcl ddt.zeroed       (max.ddts-1)    fixed; /* true if buffer zeroed out     */dcl ddt.zero.ptr     (max.ddts-1)    fixed; /* ptr for zeroing out           */dcl ddt.zero.ctr     (max.ddts-1)    fixed; /* counter for zeroing           */dcl ddt.chunk.size   lit   'bbuf.len';      /* words to xfer at a crack      */                                            /* must divide into 64K          */dcl ddt.base.msb     (max.ddts-1)    fixed; /* holds sample # of buf start   */dcl ddt.base.lsb     (max.ddts-1)    fixed;dcl ddt.next.msb     (max.ddts-1)    fixed; /* holds next sample # to load   */dcl ddt.next.lsb     (max.ddts-1)    fixed;dcl ddt.on.delay     (max.ddts-1)    fixed; /* counts samples for inp delay  */dcl ddt.on.fade.in   (max.ddts-1)    fixed; /* perform input fade-in         *//* Storage areds for DDT input routing: */dcl ddt.in.track#    (max.ddts-1)    fixed; /* 256 + destination track #     *//* $page - compute status display for meter bridge *//* compute track status display sets the status lights on the meter *//* bridge to reflect the status of the track.   The status lites    *//* show the status of a track,   while the signal displayed (set    *//* elsewhere) show the signal level at an output                    */compute.track.status.display: proc(track#);   dcl track# fixed;   dcl i fixed;   i=0;   if track.available(track#)<>0 then do;      if last.ria(track#) = 1               /* in input mode   */      then i=i\input.led;                   /* light input led */      if  ((precd.tracks&bits(track#))<>0)  /* if recording    */      or  ((track.info.direction&read.track.info&bits(track#))<>0) /* or writing data to track (bounce, poly transfer) */      then i=i\record.led\track#.red;       /* use red track#  */      else do;                              /* not recording   */         if last.ria(track#) = 1                      then i=i\track#.green;             /* input mode - green trk# */         else i=i\track#.green\track#.red;  /* repro - track # yellow  */         if  (ready.tracks&bits(track#))<>0  /* recording desired       */         then i=i\ready.led;      end;   end;   call set.track.display(track#,i);end compute.track.status.display;/* $page - update volume for playback voices                     *//* Update Volume is called once a voice has been turned on for a *//* certain track.   It saves away some information about the     *//* audio segment being played at this time,  adjust the          *//* volume registers for real-time-effects,  and writes out       *//* the volume/envelope interpolator information.                 *//* It also reads & stores away the peak level for the signal     *//* meter.                                                        *//* note: this routine is only called when chan.on(voice#) = 2!   */update.volume:proc(voice#);        /* set volume info for track  */   dcl (voice#) fixed;             /* pass voice#                */   dcl (i,j,k ) fixed;   /* save away current information about audio segment being played */   /* to provide for orderly processing of different cues from       */   /* different synclavier tracks all routed to this output.         */   /* Specifically: save away the end time for the cue being         */   /* triggered out this output at this time so we can avoid         */   /* switching the output away from this track too soon at the end  */   /* of the cue.                                                    */   chan.on.priority(voice#) = desired.priority(voice#);   call COPY32(loc(addr(desired.end(2*voice#))),               loc(addr(chan.on.end(2*voice#))));   /* Compute actual volume to use from track directory info         */   /* plus real time info:                                           */   i = Trigger.Vol.Info;            /* get possible factor for high  */                                    /* speed triggering              */   if desired.strack#(voice#) <> 0  /* if synclavier cue list        */   then do;                         /* involved, scale by trk volume */      write(mam) = tvol.xmsec#;     /* look up track vol for syncl   */      write(mal) = desired.strack#(voice#); /* cue list              */      load i; mul read(md); i = ures;       /* scale by that factor  */   end;   write(mam) = venv.xmsec#;        /* now get precomputed info      */   write(mal) = (voice#*venv.stride) + venv.tdrvol;   disable;                         /* for accurate synth writes     */   write(psc) = Base.Voice# + voice#;   write(psf) = psrdvol;            /* write dest vol (right)        */   load read(mdi);                  /* start with venv.tdrvol        */   mul  i;                          /* scale by real time volume     */   write(psd) = ures;               /* write that to synth           */   write(mdi) = ures;               /* save in venv.rvol             */   load read(mdi);                  /* start with venv.tdlvol        */   mul  i;                          /* scale by real time volume     */   write(psd) = ures;               /* write that to synth           */   write(mdi) = ures;               /* save in venv.lvol             */   /* write out envelope information to start a possible new         */   /* envelope segment:                                              */   write(psf) = pseinc;             /* now write out envelope info   */   write(psd) = read(mdi);          /* too - venv.adder to pseinc    */   write(psd) = read(mdi);          /* venv.delta to psedel          */   write(psf) = pselim;             /* and write limit as well       */   write(psd) = read(mdi);          /* venv.limit to pselim          */      if polydac<>0 then do;          /* read peak if hardware avail    */      write(psc)=shl(Base.Voice# + voice#,1);      write(psf)=psrpeak;      i=read("157");               /* get left peak                  */      write(psc)=shl(Base.Voice# + voice#,1)+1;      write(psf)=psrpeak;      j=read("157");      enable;                      /* now allow interrupts           */      k = track.levels(voice#);    /* get current levels */      if i ilt shr(k,8) then i = shr(k,8);  /* save max */      if j ilt (k&255)  then j = (k&255);   /* save max */      track.levels(voice#)=shl(i,8)\j;   end;   else enable;end update.volume;/* Update.Monitor.Volume is called to update the volume info         *//* for a voice that is monitoring an input.                          *//* note: this routine is only called when chan.on(voice#) = 4!       */update.monitor.volume:proc(voice#); /* set volume info for track     */   dcl (voice#) fixed;              /* pass voice#                   */   dcl (i,j,k ) fixed;   write(mam) = venv.xmsec#;        /* now get precomputed info      */   write(mal) = (voice#*venv.stride) + venv.tdrvol;   disable;                         /* for accurate synth writes     */   write(psc) = Base.Voice# + voice#;   write(psf) = psrdvol;            /* write dest vol (right)        */   write(psd) = read(mdi);          /* start with venv.tdrvol        */   write("324") = read(mdi);        /* skip venv.rvol                */   write(psd) = read(mdi);          /* start with venv.tdlvol        */   if polydac<>0 then do;          /* read peak if hardware avail    */      write(psc)=shl(Base.Voice# + voice#,1);      write(psf)=psrpeak;      i=read("157");               /* get left peak                  */      write(psc)=shl(Base.Voice# + voice#,1)+1;      write(psf)=psrpeak;      j=read("157");      enable;                      /* now allow interrupts           */      k = track.levels(voice#);    /* get current levels */      if i ilt shr(k,8) then i = shr(k,8);  /* save max */      if j ilt (k&255)  then j = (k&255);   /* save max */      track.levels(voice#)=shl(i,8)\j;   end;   else enable;end update.monitor.volume;/* $page - turn on voice for input mode playback  */turn.on.input.voice: proc(voice#, track#, code);   dcl (voice#) fixed;      /* voice #                        */   dcl (track#) fixed;      /* track #                        */   dcl (code  ) fixed;      /* 0 = turn voice on with         */                            /*     attack time = 1/2 of cross */                            /*     fade time.   used to       */                            /*     simulate punch ins         */                            /* 1 = turn voice on immediately  */                            /* 2 = turn on with 2.5 msec      */                            /*     ramp-up                    */   /* set up the voice's state variables:                     */   chan.on         (voice#) = 4;   chan.on.track#  (voice#) = track#;   chan.on.priority(voice#) = 0;   /* set up the voice playback hardware:                     */   call ps_wave(Base.Voice# + voice#, 256,                 compute.base.adr(track#)+rec.base, 0);   call ps_freq(Base.Voice# + voice#, 0, 256, 256);  /* 100 khz, pi=0 */   call ps_on  (Base.Voice# + voice#, 3);            /* on with loop  */   disable;   write(psc) = Base.Voice# + voice#;   write(psf) = pseinc;                 /* set up for correct */   write(psd) = 4095;                   /* attack time        */   if code = 2                          /* set psedel         */   then write(psd) = 64;   else write(psd) = pmsec;   write(psf) = pselim;                 /* set envelope limit */   write(psd) = 4095;                   /* to max for input   */   enable;   call update.monitor.volume(voice#);  /* set vol, reak pk   */   /* if immediate turn-on desired,  set current values       */   /* to peak right now:                                      */   if code = 1 then do;      disable;      write(psc) = Base.Voice# + voice#;      write(psf) = pseval;      write(psd) = 4095;      write(mam) = venv.xmsec#;        /* now get precomputed info      */      write(mal) = (voice#*venv.stride) + venv.tdrvol;      write(psf) = psrcvol;            /* write curr vol (right)        */      write(psd) = read(mdi);          /* start with venv.tdrvol        */      write("324") = read(mdi);        /* skip venv.rvol                */      write(psd) = read(mdi);          /* start with venv.tdlvol        */      enable;   end;end turn.on.input.voice;/* $page - turn on voice for repro playback: */turn.on.voice: proc(voice#, track#, time, code);   dcl (voice#) fixed;      /* voice #                        */   dcl (track#) fixed;      /* track #                        */   dcl (time  ) array;      /* sample time to turn voice on   */   dcl (code  ) fixed;      /* 0 = turn voice on with         */   dcl (i     ) fixed;      /*     a 2.5 msec ramp-up         */                            /* 1 = turn voice on immediately  */   /* set state variables.  priority and end time are set     */   /* in update volume:                                       */   chan.on        (voice#) = 2;   chan.on.track# (voice#) = track#;   /* Set up voice playback hardware:                         */   call ps_wave(Base.Voice# + voice#, 256,                 compute.base.adr(track#), 0);   call ps_freq(Base.Voice# + voice#, 0, 256, 256);  /* 100 khz, pi=0                       */   call ps_on  (Base.Voice# + voice#, 3);            /* on with loop                        */   /* Find the envelope value we should start the voice at:          */   if (now.looping <> 0)                        /* if looping,  get   */   then i = Find.Envelope.Value(track#, time);  /* accurate value     */   else i = Quickly.Find.First.Envelope.Value(track#, time);   write(mam) = venv.xmsec#;        /* now get precomputed info      */   write(mal) = (voice#*venv.stride) + venv.adder;   write(mdi) = 4095;               /* use adder of 4095.  store in  */                                    /* venv.adder                    */   write(mdi) = 64;                 /* venv.delta                    */   write(mdi) = i;                  /* save limit in venv.limit      */   call update.volume(voice#);      /* set values, read peak         */   /* if immediate turn-on desired,  set current values              */   /* to peak right now:                                             */   if code = 1 then do;      disable;      write(mam) = venv.xmsec#;        /* now get precomputed info   */      write(mal) = (voice#*venv.stride) + venv.limit;      write(psc) = Base.Voice# + voice#;      write(psf) = pseval;      write(psd) = read(md);      write(mal) = (voice#*venv.stride) + venv.rvol;      write(psf) = psrcvol;            /* write curr vol (right)     */      write(psd) = read(mdi);          /* start with venv.rvol       */      write("324") = read(mdi);        /* skip venv.tdlvol           */      write(psd) = read(mdi);          /* start with venv.lvol       */      enable;   end;end turn.on.voice;/* $page - turn off a voice,  turn off all voices */turn.off.voice: proc(voice#,immed); /* turn off voice,  hopefully gently  */   dcl (voice#) fixed;              /* logical voice #,  0 - x            */   dcl (immed ) fixed;              /* 0 = turn off voice in 2.5 msecs    */                                    /* 1 = turn off immediately (CLICK!)  */   write(psc) = Base.Voice# + voice#;      if immed = 0 then do;           /* not immediately - do gently         */      /* set envelope delta to control */      /* attack/decay                  */      write(psf) = pseinc;         /* set up interpolator for a 2.5       */      write(psd) = 4095;           /* msec final decay                    */      write(psd) = 64;             /* by writing pseinc, psedel           */      write(psf) = pselim;         /* and set limit to 0                  */      write(psd) = 0;      write(psf) = pseval;         /* see if channel has reached          */                                   /* desired limit of 0                  */      if read(psd)<>0 then do;         chan.on(voice#) = chan.on(voice#) \ 1;         return 0;      end;   end;   /* if val is at 0, or we want an immediate turn-off, then     */   /* clean up the voice now:                                    */   write(psf) = pselim;         write(psd) = 0;   write(psd) = 0;      write(psf) = psrdvol;            /* set volume                */   write(psd) = 0;   write(psd) = 0;   write(psf) = psrcvol;            /* set volume                */   write(psd) = 0;   write(psd) = 0;   call ps_on  (Base.Voice# + voice#, 0);          /* off */   chan.on     (voice#) = 0;   track.levels(voice#) = 0;   return 1;                        /* voice is off            */end turn.off.voice;terminate.output:proc swapable;   dcl (i,j) fixed;   dcl (time, t#, v#)     fixed;   dcl (polysec, polywrd) fixed;   do i=0 to max.tracks-1;          /* begin by moving track.toss         */      if  (track.toss(i)<>0)        /* to zap.buffer if we need to        */      then do;         zap.buffer(i) = 1;         track.toss(i) = 0;      end;      track.mode.change(i) = 0;   end;   /* turn off repro voices digitally to void DDSAD clicks & pops         */   if now.looping <> 0 then do;     /* if looping, ramp down digitally    */      call set.lod.hz(Current.Rate*4-2,0); /* set up for fast i/o         */      do j=0 to 2000; end;                 /* wait for it to take effect  */      call construct.looping.fade(Sync.S#, Our.Time, 0); /* fade out      */      do j=0 to 2000; end;                 /* wait for last DDSAD         */                                           /* sample to be output         */      Output.Happening = 0;                /* no longer doing any output  */      call set_ddsad_controls(0,1);        /* turn off ddsad now          */   end;   else do;                         /* else while we are playing          */      /* Note on timing - On 3/08/91 I timed the following software.  It  */      /* took 3.76 milliseconds to loop over all 16 voices and            */      /* construct ramp-downs on 4 voices.  The time for all 16           */      /* channels should be somewhat less than 15.04 milliseconds.        */      /* We will give ourselves a 5 millisecond margin:                   */      i = shr(active.rate,1);      /* get # of samples in 20 milliseconds */      j = i + 256;                 /* plus 256 digital zeroes             */      wait.for.buffer:;            /* re-enter if near buffer wrap        */      write(psc)=32;               /* find out where we are playing now   */      write(psf)=psadsc32;      time = read(psd) - shl(buf.base,8);      if (shl(buf.len,8) - time) ILT j      then goto wait.for.buffer;      do v# = 0 to max.voices-1;         /* turn off all repro voices      */         if (chan.on(v#)&2) <> 0         /* if voice is repro mode         */         then do;                        /* then ramp it down              */            t# = chan.on.track#(v#);     /* get releevant track #          */            polysec = compute.base.adr(t#) + buf.base + shr(time + i,8);            polywrd = (time + i) & 255;            call fadeout (polysec, polywrd);  /* ramp down ending here     */            call psmwrite(polysec, polywrd);  /* plus silence              */            rpc 256;            write(psd) = 0;            zap.buffer(t#) = 1;         end;      end;      j = time + i;              /* get time to wait until                 */      wait.for.fade:;            /* re-enter while waiting                 */      write(psc)=32;             /* find out where we are playing now      */      write(psf)=psadsc32;      time = read(psd) - shl(buf.base,8);      if time ILT j      then goto wait.for.fade;      do v# = 0 to max.voices-1;         /* turn off all repro voices      */         if (chan.on(v#)&2) <> 0         /* if voice is repro mode         */         then do;                        /* turn actual channel off here   */            call Turn.Off.Voice(v#, 1);         end;      end;      /* wait here a little longer to make sure all the samples our        */      /* out the DDSAD                                                     */      do j = 0 to 2000; end;   end;   Output.Happening = 0;            /* no longer doing any output         */   Monitor.Timer    = 0;            /* reset monitor delay timer          */   /* turn off all voices to avoid clicks */   i = 1;             /* initially assume some voices are on        */   do while i <> 0;      i = 0;          /* assume they will all be turned off here    */      do j = 0 to max.voices-1;           /* turn off all voices,   */         if chan.on(j) <> 0               /* both repro and input   */         then do;                         /* modes.                 */            if Turn.Off.Voice(j, 0) = 0            then i = 1;         end;      end;   end;   call Initialize.Channel.32.For.LOD.Playback;   /* Turn off DDT output as well */   if Sync.Mode = 2         /* if using DDT in or DDT out, then */   then do;                 /* turn off GO bit                  */      if  (DDT.Connect.Mode   = 0)    /* if using routable UDIO */      and ((aux.d24.# <> ddt.d24.#) or (port.io(max.ports) = 0))      then call Gently.Turn.Off.DDT.Output;      /* Else if using multi-track units,  just set flag here.  */      /* we will come around and stop all the units later       */      /* on when all the ports are idle.                        */      else Stop.DDT.Units = 1;   end;end terminate.output;/* Here is a handy routine that ramps up the digital signal level at *//* the start of scrubbing.  The idea is to remove the click at       *//* the start.  Same routine also used during scrubbing shut-down.    */construct.looping.fade: proc(Current.Buf, Our.Time, code) swapable;   dcl Current.Buf              array;   dcl Our.Time                 array;   dcl code                     fixed;  /* 1 = ramp in, 0 = ramp out */   dcl the_chans                fixed;   dcl the_loc                  fixed;   dcl the_data  (max.tracks-1) fixed;   dcl (i,j,k)                  fixed;   dcl num_samples lit '100';   the_chans = trig.tracks & track.avail.bits;  /* get bits for tracks     */   write(psc)=32;                               /* get location of poly    */   write(psf)=psadsc32;                         /* where the first/last    */   the_loc = read(psd);                         /* sample sits             */   /* read the value of the sample construct the desired ramp:             */   do i = 0 to max.tracks - 1;      if ((the_chans & bits(i)) <> 0)      then do;         call psmread(compute.base.adr(i), the_loc);         the_data(i) = read(psd);         if code = 1 then do;            call psmwrite(compute.base.adr(i), the_loc);            write(psd) = 0;         end;         else zap.buffer(i) = 1;      end;   end;   /* Handle fade-in */   if code = 1 then do;      /* now turn on the voices (and the DDSAD) playing zeroes:               */      call Voice.Check(1, Current.Buf, Our.Time, 0); /* turn desired voices on, but skip ddt */      call set_ddsad_controls(0,1);      /* now enable DDSAD output (output happening now equals 1) */      do i = 0 to max.tracks - 1;         if ((the_chans & bits(i)) <> 0)         then do j = 0 to num_samples;            call psmwrite(compute.base.adr(i), the_loc);            write(psd)  = the_data(i) * j / num_samples;         end;      end;   end;   /* else ramp down the output                                          */   else do i = 0 to max.tracks - 1;      if ((the_chans & bits(i)) <> 0)      then do j = num_samples to 0 by -1;         call psmwrite(compute.base.adr(i), the_loc);         write(psd)  = the_data(i) * j / num_samples;      end;   end;end construct.looping.fade;/* Terminate DDT Output is called from the main loop   *//* if Stop.DDT.Units is <> 0.   It must wait until all *//* ports are free,   then go through all the boxes and *//* turn them off.                                      */Terminate.DDT.Output: proc swapable;   dcl i fixed;   if  (Sync.Mode        =  2)    /* if doing DDT               */   then do;      if (DDT.Connect.Mode = 0)            /* if using routable  */      then do;                             /* UDIO, wait for     */         if (aux.d24.# = ddt.d24.#) and (port.io(max.ports) <> 0)         then return;                      /* aux to become free */         call Gently.Turn.Off.DDT.Output;  /* THEN turn off      */      end;      else do;                               	/* multi udio      				  */						#if (inc.multi.udio)							/* multi udio included	  		  */				do i = 0 to max.ports-1;            /* look over all ports          */						if  (Port.Available(i) <> 0)     /* if port is available         */					and (Port.DDT      (i) <> 0)     /* and has DDT hardware         */					and (Port.Io       (i) <> 0)     /* and port is busy             */					then return;                     /* then must wait               */					end;					/* Loop through all the units.   Ramp out the audio and set the */				/* mute bit for all outputs.   When all ports have been         */				/* muted,  turn off the front end go bit in the go master.      */					do i = 0 to max.ports-1;            /* look over all ports          */						if  (Port.Available(i) <> 0)     /* if port is available         */					and (Port.DDT      (i) <> 0)     /* and has DDT hardware         */					and ((Port.DDT.Mode(i) & FE_Dir_In) = 0)  /* doing output        */					then do;							DDT.Mode = Port.DDT.Mode(i);							call quickly.select.port(i);							call Gently.Turn.Off.DDT.Output;							Port.DDT.Mode(i) = Port.DDT.Mode(i) \ FE_Mute;							call deselect(i);          /* disconnect from port */						end;				end;					/* Now select the master chanel and turn off its go bit */					DDT.Mode = Port.DDT.Mode(dig.xfer.go.master) & (not(FE_Go));				Port.DDT.Mode(dig.xfer.go.master) = DDT.Mode;					call quickly.select.port(dig.xfer.go.master);					call Read.Selected.DDT.Word.Clock;  /* write out new DDT.Mode */					call deselect(dig.xfer.go.master);  /* disconnect from port   */			#endif		end;   end;   Stop.DDT.Units = 0;                    /* reset flag             */end Terminate.DDT.Output;/* $page - turn on or off recording channel */turn.on.rec.chan:proc(track#);  /* turn on recording channel */   dcl (track#) fixed;   dcl (voice#) fixed;   dcl (basead) fixed;   dcl (i,j   ) fixed;   voice#=track.rvoice#   (track#); /* look up input channel #          */   basead=compute.base.adr(track#); /* and base address                 */   if voice#>=polynumv then return;   call ps_wave(voice#,256,basead+rec.base, 0);  /* set up base addr for recording buffer, tot len, loop len */   call ps_freq(voice#,0,256,256);  /* 100 khz, pi=0                       */   call ps_on  (voice#,3);          /* on with loop                        */   rec.chan.on(track#) = 1;   status.tracks = status.tracks \ bits(track#);end turn.on.rec.chan;turn.off.rec.chan:proc(track#); /* turn off recording channel              */   dcl (track#) fixed;   dcl (voice#) fixed;   voice# = track.rvoice#   (track#); /* look up input channel #          */   if voice#>=polynumv then return;   call ps_on  (voice#,0);          /* off                                */   rec.chan.on (track#)=0;   status.tracks = status.tracks \ bits(track#);end turn.off.rec.chan;/* $page - routine to see if there is valid audio data in the disk        *//* buffer for a given track:                                              */buffers.are.in.range: proc(track#);   dcl track# fixed;   if zap.buffer(track#) <> 0                  /* no valid data if buffer */   then return 0;                              /* waiting to be zapped!   */   if   ((buf1.msb(track#)=current.msb)        /* and buf1 has data from correct       */   and   (buf1.lsb(track#)=current.lsb)        /* place on disk                        */   and   ((buf1.len(track#)>(current.offs+5))  /* plenty of buffer left in buf1        */   or     ((buf1.len(track#)=buf.len)          /* or buf1 is full                      */   and     (buf2.msb(track#)=next.buf.msb)     /* and buf2 is from correct place       */   and     (buf2.lsb(track#)=next.buf.lsb)     /* place on disk,  and is full enough   */   and     (buf2.len(track#)>(5-(buf.len-current.offs))))))   then return 1;   if   ((buf2.msb(track#)=current.msb)        /* or buf2 has data from correct        */   and   (buf2.lsb(track#)=current.lsb)        /* place on disk, and has enough        */   and   (buf2.len(track#)>(current.offs+5)))  /* data to play                         */   then return 1;   if   ((buf3.msb(track#)=current.msb)        /* or buf3 has the data we are          */   and   (buf3.lsb(track#)=current.lsb)        /* looking for                          */   and   (buf3.len(track#)>(buf.len - current.offs + 5)))   then return 1;   if   ((tracks.per.port >=  4)               /* or in max tracks and we are reading  */   and   (port.io(track.port.ix(track#)) <> 0) /* data for this track now ...          */   and   (port.io.track#(track.port.ix(track#)) = track#))   then return 1;   return 0;end buffers.are.in.range;