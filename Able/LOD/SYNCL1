/* Synclavier simulated variables: */dcl debug    lit '1';dcl inc.poly lit '1';dcl inc.mono lit '0';dcl d16      lit '"16"';dcl swapable lit 'swap';dcl zero.time lit '50';configuration muldiv,modelc;dcl (d16tim)               fixed;dcl (d16there)             fixed;dcl (d16phase)             fixed;dcl (d16phasechange)       fixed;dcl (play.time.msb)        fixed;dcl (play.time.lsb)        fixed;dcl (time.accum)           fixed;dcl (samp.speed)           fixed;dcl (play,recd,move,pnch)  fixed;dcl (mark.button)          fixed;dcl (mark.button.msb)      fixed;dcl (mark.button.lsb)      fixed;dcl (mark.button.acu)      fixed;insert ':-xpl:sysiortt';insert ':-xpl:syscatrn';insert ':-XPL:SCSILITS';/* NEW!!!: */dcl (play.tracks)          fixed;   dcl (recd.tracks)          fixed;   dcl (new.motion )          fixed;   dcl (scsi.busy)            fixed;  /* 1   = lod has been selected - must abort it */                                   /* 2,3 = reset in progress                     */dcl (scsi.reset.time)      fixed;  /*       timer for reset                       */dcl (screen)               fixed;/* global definitions for live overdub/scsi *//* MULTIPLY DIVIDE LITERALS: */DCL loadm  LIT 'WRITE(5)=';            /* LOAD         */DCL ULOAD LIT 'WRITE(4)=';             /* LOAD UPPER   */DCL REM   LIT 'READ(4)'  ;             /* QUOTIENT REMAINDER               */DCL MUL   LIT 'WRITE(6)=';DCL DIV   LIT 'WRITE(7)=';  DCL RES   LIT 'READ(5)'  ;             /* RESULT       */DCL URES  LIT 'READ(4)'  ;             /* UPPER RESULT */DCL MWAIT LIT 'WRITE("324")=RES';      /* D5 TO ATNV TO WAIT FOR MUL/DIV *//* REPEAT COUNTER: */  DCL RPC   LIT 'WRITE("010")=(-1)+';dcl scsibits data (256,512,1024,2048);dcl bits     data (1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768);/* $page *//* Synclavier simulated routines: */dcl abort.scsi procedure;run.syn.loop:proc;   dcl (i,j) fixed;   do i=0 to 100; end;end run.syn.loop;log.error:proc(msg);                      /* logg error on main synclavier */   dcl msg array;   print string(msg);end log.error;time.base:proc;   if move then do;      play.time.lsb=play.time.lsb+10;      if play.time.lsb ilt 10 then play.time.msb=play.time.msb+1;   end;   else if play then do;      time.accum=time.accum+samp.speed;      do while time.accum ige 1000;         play.time.lsb=play.time.lsb+1;         if play.time.lsb=0 then play.time.msb=play.time.msb+1;         time.accum=time.accum-1000;      end;   end;end time.base;when d16int then begin;   write(14)=d16there-read(14);   call time.base;end;dcl real.milliseconds fixed;when d03int then begin;   dcl i fixed;   if debug then do;            /* phase lock d16 to d3    */      i=d16phase+read(14);      /* get current phase error - remember d16 returns complemented data */      if abs(i)<shr(d16tim,1)   /* narrow phase error - must be close */      then do;         write(14)=d16phase;    /* preset to it                       */      end;      else do;                  /* wide phase error - we either missed a call to time.base,  or made an extra call */         if d16phase<shr(d16tim,1)  /* we want interrupt soon */         then do;                   /* must be we did an exta one */            write(14)=d16phase+d16tim;         end;         else do;                   /* must be we missed one      */            write(14)=d16phase;            call time.base;         end;      end;   end;   if debug then do;            /* for our testing only */      d16phase=d16phase+d16phasechange;         do while d16phase<0;         d16phase=d16phase+d16tim;      end;      do while d16phase>=d16tim;         d16phase=d16phase-d16tim;      end;   end;   real.milliseconds=real.milliseconds+5;end;dcl break.me fixed;dcl new.info fixed;when ttiint then begin;   if rcvdcharacter= "00" then break.me=1;   if rcvdcharacter= "15" then new.info=1;  /* return   */   if rcvdcharacter= "13" then new.info=2;  /* up arrow */    if rcvdcharacter= "12" then new.info=3;  /* down     */   if rcvdcharacter= "61" then play.tracks=play.tracks xor 1; /* 1 */   if rcvdcharacter= "62" then play.tracks=play.tracks xor 2; /* 2 */   if rcvdcharacter="120" /* P */  then do; play=1; move=0; recd=0; end;   if rcvdcharacter="160" /* p */  then do; play=1; move=0; recd=0; end;   if rcvdcharacter="106" /* F */  then do; play=1; move=1; recd=0; end;   if rcvdcharacter="146" /* f */  then do; play=1; move=1; recd=0; end;   if rcvdcharacter="124" /* T */  then new.info=4;  /* new nam  */   if rcvdcharacter="164" /* t */  then new.info=4;  /* new nam  */   if rcvdcharacter="104" /* D */  then new.info=5; /* toggle directory */   if rcvdcharacter="144" /* d */  then new.info=5; /* toggle directory */   if rcvdcharacter="105" /* E */  then new.info=7; /* enter directory  */   if rcvdcharacter="145" /* e */  then new.info=7; /* enter directory  */   if rcvdcharacter="101" /* A */  then new.info=6; /* look at adir     */   if rcvdcharacter="141" /* a */  then new.info=6; /* look at adir     */   if rcvdcharacter="114" /* L */  then new.info=8; /* tape load        */   if rcvdcharacter="154" /* l */  then new.info=8;    if rcvdcharacter="116" /* N */  then new.info=9;   if rcvdcharacter="156" /* n */  then new.info=9;   if rcvdcharacter="122" /* R */     or rcvdcharacter="162" /* r */     then do;       play=0; move=0; recd=0;       if mark.button=0 then do;         play.time.msb=0; play.time.lsb=0; time.accum=1000-samp.speed;      end;      else do;         play.time.msb=mark.button.msb; play.time.lsb=mark.button.lsb;         time.accum=mark.button.acu;         if (play.time.msb<>0) or (play.time.lsb igt zero.time)         then do;            if play.time.lsb ilt zero.time then play.time.msb=play.time.msb-1;            play.time.lsb=play.time.lsb-zero.time;         end;      end;   end;   if rcvdcharacter="103" /* C */  then do; play=1; move=0; recd=1; end;   if rcvdcharacter="143" /* c */  then do; play=1; move=0; recd=1; end;   if rcvdcharacter="123" /* S */  then do; play=0; move=0; recd=0; end;   if rcvdcharacter="163" /* s */  then do; play=0; move=0; recd=0; end;   if rcvdcharacter=32 then do;      print 'enter speed--',;      input samp.speed;   end;   if rcvdcharacter="115"   or rcvdcharacter="155"   then do;      print 'Mark button, msb, lsb, acu: ',;      input mark.button,mark.button.msb,mark.button.lsb,mark.button.acu;   end;   new.motion=1;end;/* $page *//* Synclavier simulated initialization: */begin;   dcl (i,j) fixed;   i=0; j=0;   write( 3)=0; write(3)=0; write(3)=0;   i=read(14); write(3)=0; j=read(14);   d16tim=(j-i+2)/5;   d16there=d16tim-1;   d16phase=shr(d16tim,1); /* midphase now */   d16phasechange=0;   if debug then do;       /* initialize to correct phase */      write(3)=0; write(3)=0;      write(14)=d16phase;       /* initialize d16 */   end;   enable;   samp.speed=1000;   play.tracks=(-1);   recd.tracks=1;end;/* $page  -  ABORT.SCSI,  SCSI/LOD  Variables *//* Lod-specific variables */dcl (look.for.lod  )  fixed;              /* set to 1 to poll for lod        */dcl (lod.running   )  fixed;              /* set true if lod there & running */dcl (send.update.ms)  fixed;              /* time of last update        */dcl (syncl.target.#)  lit '6';dcl (lod.target.#  )  lit '3';dcl (lod.d24.#     )  fixed;dcl (scsi.out.buf  )  (4096)  fixed;dcl misc.buf (256) fixed;/* new LOD routines: *//* abort.scsi:      Called from main loop when software wants to do input/output from      scsi.   It terminates any live overdub scsi i/o that is currently      going on. */abort.scsi:proc swapable;   dcl (i) fixed;   do case (scsi.busy);      do;                               /* case 0 - no action needed  */      end;      do;                               /* case 1 - lod is selected   */         write(ScsiData)=0;             /* remove DATA6               */         do i=0 to 99;                  /* wait for possible busy     */         end;                           /* REQ could be down here     */         write(ScsiBus )=S$SEL\S$ATN;   /* leave SEL,  gnd ATN        */         do while (read(ScsiBus)&S$BSY)<>0;         end;         write(ScsiBus )=0;             /* releset SEL and ATN        */      end;      do;                               /* case 2 - reset pulse       */         do while real.milliseconds<scsi.reset.time+10;           end;         write(ScsiBus) = 0;         scsi.reset.time=real.milliseconds;         do while real.milliseconds<scsi.reset.time+2000;         end;      end;      do;                               /* case 3 - end of reset      */         do while real.milliseconds<scsi.reset.time+2000;         end;      end;   end;   scsi.busy=0;end abort.scsi;/* $page - RESET.LOD.SCSI *//* reset.lod.scsi - issue reset to scsi port */reset.lod.scsi:proc swapable;   call log.error('Resetting SCSI/LOD port...');   scsi.busy=2;                                 /* reseting          */   write(ScsiBus) = S$RST;                      /* issue reset       */   scsi.reset.time=real.milliseconds;   do while real.milliseconds<scsi.reset.time+10;        call run.syn.loop;      if scsi.busy=0 then return;               /* reset completed by main loop */   end;   scsi.busy=3;   write(ScsiBus) = 0;   scsi.reset.time=real.milliseconds;   do while real.milliseconds<scsi.reset.time+2000;      call run.syn.loop;      if scsi.busy=0 then return;               /* reset completed by main loop */   end;   scsi.busy=0;end reset.lod.scsi;/* $page  -  SEND.TO.LOD *//* send.to.lod - procedure to send a message to lod computer *//* routine is passed:   1. a message type.   see Live Overdub printout for message      protocols (1='hello', 4='reboot', 200-202='load')   2. a byte length. (scsi.out.buf(0))    3. a message      (scsi.out.buf   ) *//* routine sends message to live overdub.   will return if   live overdub has gone off the air */   /* returns message acknowledgement code received. *//* error messages for terminal are spun off here. */dcl (scsibuf) (512)    fixed;dcl ddudev             fixed;dcl ddusec             fixed;dcl ddulen             fixed;send.to.lod:proc(msgtype) swapable;   /* send message to lod */   dcl (msgtype)         fixed;   dcl (i,j,k)           fixed;   send.again:;   write(ScsiSel)=S$SelectEnable \ Scsibits (lod.d24.#);  /* select this d24 */   write(ScsiBus) = 0;   write(ScsiData)= 0;   i=real.milliseconds+20;                     /* retry timer        */   do while  ((read(ScsiBus )&S$BusMask )<>0)  /* check for bus bysy */   or        ((read(ScsiData)&S$DataMask)<>0); /* or reset needed    */      if real.milliseconds>= i then do;        /* gonzo              */         call reset.lod.scsi;                  /* issue reset        */         return 0;                             /* not sent           */      end;      call run.syn.loop;      write(ScsiSel)=S$SelectEnable \ Scsibits (lod.d24.#);        write(ScsiBus) = 0;      write(ScsiData)= 0;   end;   scsi.busy=1;          /* set scsi.busy so main loop knows what is happening */   write(ScsiSel)  =S$SelectEnable \ Scsibits (lod.d24.#);  /* select this d24 */   write(ScsiData) =bits(lod.target.#);        /* single initiator   */   write(ScsiBus)  =S$SEL;                     /* gnd SEL            */   i=real.milliseconds;                        /* retry timer        */   if lod.running<>0 then i=i+5000;            /* 5 seconds if run   */   else                   i=i+10;              /* 10 msec for srch   */   do while (read(ScsiBus)&S$BSY)=0;           /* or not found       */      if real.milliseconds>= i then do;        /* gonzo              */         write(ScsiBus) = 0;         write(ScsiData)= 0;         scsi.busy      = 0;         lod.running    = 0;                   /* not running        */         look.for.lod   = 1;                   /* try to find one    */         if msgtype<>1 then call log.error('Timeout Error in Multi-Track Computer');         return 0;      end;      call run.syn.loop;      if scsi.busy=0 then goto send.again;     /* aborted by main l  */   end;   write(ScsiData)=0;                          /* release DATA       */   write(ScsiBus )=0;                          /* release SEL        */   if msgtype=130 then do;                     /* real time message  */      i=real.milliseconds;                     /* retry timer        */      do while (read(ScsiBus)&S$REQ)=0;        /* wait for his REQ   */         if real.milliseconds>=i+10 then do;   /* gonzo              */            call abort.scsi;                   /* abort ourselves    */            goto send.again;           end;         call run.syn.loop;                    /* make him wait for us */         if scsi.busy=0 then goto send.again;  /* aborted by main l    */      end;      write(ScsiByte)=msgtype;                 /* message type         */      write(ScsiWord)=4;                       /* byte length          */      disable;                                 /* send precise time    */      write(ScsiWord)=play.time.lsb;      i=read(d16);                             /* get current d16      */      if i>=(-1) then do;         write(d16)=1;                         /* reset d16 timer since interrupt request was cleared by read */         i=(-1);      end;      loadm d16tim+i;                           /* get fraction into d16 */      mul samp.speed; mwait; div d16tim;      write(ScsiWord)=time.accum+res;      enable;   end;   else do;                                    /* normal message     */      write(ScsiByte)=msgtype;                 /* message            */      if msgtype>=128 then do;                 /* data               */         do i=0 to shr(scsi.out.buf(0)+1,1);            write(ScsiWord)=scsi.out.buf(i);         end;      end;   end;   i=read(ScsiByte);                           /* get reply          */   if i>=128 then do;                          /* long message       */      scsibuf(0)=read(ScsiWord);               /* get length, bytes  */      if scsibuf(0)>1024 then do;               /* limit to 512words */         do j=1 to 512;                        /* length in bytes    */            scsibuf(j)=read(ScsiWord);         end;         do j=513 to shr(scsibuf(0)+1,1);            k=read(ScsiWord);         end;         scsibuf(0)=1024;      end;      else do j=1 to shr(scsibuf(0)+1,1);         scsibuf(j)=read(ScsiWord);      end;   end;   scsi.busy=0;   if i=128 then do;                           /* message for terminal */      call log.error(scsibuf);      scsibuf(0)=0;      i=3;                                     /* convert to type 3    */   end;   else if i=220 then begin;      dcl (dtd.song#  )       fixed;      dcl song.len       lit  '24';      dcl song.item      lit  ' 0';       /* human item # - start w/ 1 */      dcl song.title     lit  ' 1';      dcl song.start     lit  '13';       /* start time, secs, 50 khz  */      dcl song.end       lit  '14';       /* end   time, secs, 50 khz  */      dcl song.rate      lit  '15';       /* sample rate for song      */      dcl song.used      lit  '16';       /* # of seconds used         */      dcl song.status    lit  '17';       /* status bits               */      dcl song.modified  lit  '18';       /* true if modified since    */      print;      print 'song directory: ';      print;      dtd.song#=scsibuf(1);      do i=0 to 9;         if i=dtd.song# then print '* ',;         else print '  ',;         print scsibuf(i*song.len+2+song.item),' ',;         do j=0 to 11;            print character(scsibuf(i*song.len+2+song.title+j)),;            print character(shr(scsibuf(i*song.len+2+song.title+j),8)),;         end;         print ' ',;         print scsibuf(i*song.len+2+song.start),' ',;         print scsibuf(i*song.len+2+song.end),' ',;         print scsibuf(i*song.len+2+song.rate),' ',;         print scsibuf(i*song.len+2+song.used),' ',;         print scsibuf(i*song.len+2+song.status),' ',;         print scsibuf(i*song.len+2+song.modified),;         print;      end;      i=3;   end;   else if i=221 then begin;      dcl (dtd.track#  )       fixed;      dcl song.len       lit  '24';      dcl song.item      lit  ' 0';       /* human item # - start w/ 1 */      dcl song.title     lit  ' 1';      dcl song.start     lit  '13';       /* start time, secs, 50 khz  */      dcl song.end       lit  '14';       /* end   time, secs, 50 khz  */      dcl song.rate      lit  '15';       /* sample rate for song      */      dcl song.used      lit  '16';       /* # of seconds used         */      dcl song.status    lit  '17';       /* status bits               */      dcl song.modified  lit  '18';       /* true if modified since    */      dcl song.index     lit  '19';      dcl track.len     lit '16';      dcl track.title   lit ' 0';      dcl track.stat    lit ' 8';   /* status (see below)              */      dcl track.used    lit ' 9';   /* seconds actually used           */      dcl track.input   lit '10';   /* input routing #                 */      dcl track.gain    lit '11';   /* input gain                      */      dcl track.volume  lit '12';      dcl track.pan     lit '13';      print;      print 'Track directory: ';      print;      print;      print 'song info ',;      dtd.track#=scsibuf(1);      do j=0 to 11;         print character(scsibuf(2+song.title+j)),;         print character(shr(scsibuf(2+song.title+j),8)),;      end;      print ;      print scsibuf(2+song.start),'  ',;      print scsibuf(2+song.end),'  ',;      print scsibuf(2+song.rate),'  ',;      print scsibuf(2+song.used),'  ',;      print scsibuf(2+song.status),'  ',;      print scsibuf(2+song.modified),'  ',;      print;      print 'Index: ',scsibuf(2+song.index);      print; print;      do i=0 to 15;         if i=dtd.track# then print '* ',;         else                 print '  ',;         do j=0 to 7;            print character(scsibuf(song.len+i*track.len+2+track.title+j)),;            print character(shr(scsibuf(song.len+i*track.len+2+track.title+j),8)),;         end;         print ' ',;         print scsibuf(song.len+i*track.len+2+track.used),' ',;         print scsibuf(song.len+i*track.len+2+track.stat),' ',;         print scsibuf(song.len+i*track.len+2+track.input),' ',;         print scsibuf(song.len+i*track.len+2+track.gain),' ',;         print scsibuf(song.len+i*track.len+2+track.volume),' ',;         print scsibuf(song.len+i*track.len+2+track.pan),' ',;         print;      end;      i=3;   end;   else if i=222 then do;      print 'dtd.max.secs   ',scsibuf(1);      print 'dtd.max.tracks ',scsibuf(2);      print 'dtd.max.inputs ',scsibuf(3);      print;      i=3;   end;   else if i=223 then do;      print 'allocation directory: ';      print;      do i=0 to 31;         print shl(i,3),':  ',;         do j=0 to 7;            print scsibuf(i*8+j+1),;         end;         print;      end;      i=3;   end;   else if i=224 then do;      if ddulen<>0 then do;         call writedata(shl(1,8),ddusec,location(addr(scsibuf(1))),256);         ddusec=ddusec+1;         ddulen=ddulen-1;         if ddulen=0 then print 'Sound file Load completed';      end;      i=3;   end;   return i;                                   /* message type         */end send.to.lod;/* $Page  -  INTERROGATE.LOD *//* interrogate.lod - send message to lod to find out *//* if loader rom or main code is running.   load     *//* main code if loader is running.                   */dcl filename (64) fixed;dcl lodnam   data ('.LOD-6');dcl (i,j,k,l) fixed;do i=0 to 3;                /* initialize file name */   filename(i)=lodnam(i);end;interrogate.lod:proc (status) swapable;   dcl (j,status) fixed;   if (status=2) then do;             /* loader running     */      if lookfile(filename,0)=0 then do;         call log.error('Multi-Track System File ',string(filename),' is missing');         look.for.lod=0;         lod.running=0;      end;      else do;         if debug then do;   /* look in pcat or scat for .lod-7, .ltab-7 */end;         call locate(filename,0);         call log.error('Starting Up Multi-Track Computer...');         scsi.out.buf(0)=2; scsi.out.buf(1)=0;         call send.to.lod(200);       /* send load address */         j=0;         do while j<>file.sector.length;            scsi.out.buf(0)=512;if debug then do; end; /* 32 bit math needed here */            call readdata(0,starting.sector,location(addr(scsi.out.buf(1))),256);            call send.to.lod(201);  /* send load data */            call run.syn.loop;            starting.sector=starting.sector+1;            j=j+1;         end;         scsi.out.buf(0)=2; scsi.out.buf(1)=j;         call send.to.lod(202);       /* send checksum/execute */      end;                            /* will check next loop time */   end;   else if (status=3) then do;        /* lod running        */      look.for.lod=0;                 /* found              */      lod.running=1;      /* now load freq table */      call locate('.ltab-7',0);      scsi.out.buf(0)=2; scsi.out.buf(1)=0;      call send.to.lod(210);       /* send load address */      j=0;      do while j<>file.sector.length;         scsi.out.buf(0)=512;if debug then do; end; /* 32 bit math needed here */         call readdata(0,starting.sector,location(addr(scsi.out.buf(1))),256);         call send.to.lod(211);  /* send load data */         call run.syn.loop;         starting.sector=starting.sector+1;         j=j+1;      end;      scsi.out.buf(0)=0;      if      screen=1 then call send.to.lod(12);      else if screen=2 then call send.to.lod(13);      new.motion=1;                   /* send motion info   */   end;end interrogate.lod;/* $page - send.long.message */send.long.message:proc swapable;   dcl (i) fixed;   scsi.out.buf( 0)=64;   do i=1 to 32;      scsi.out.buf(i)=0;   end;   disable;   new.motion=0;                      /* clear flag            */   scsi.out.buf( 1) = play.time.msb;    /* look at play info     */   scsi.out.buf( 2) = play.time.lsb;   scsi.out.buf( 3) = time.accum;   enable;   scsi.out.buf( 4) = samp.speed;   scsi.out.buf( 5) = play\shl(recd,1)\shl(move,2)\shl(pnch,3);   scsi.out.buf( 6) = play.tracks;   scsi.out.buf(10) = recd.tracks;   scsi.out.buf(14) = mark.button;   scsi.out.buf(15) = mark.button.msb;   scsi.out.buf(16) = mark.button.lsb;   scsi.out.buf(17) = mark.button.acu;   call send.to.lod(131);             /* send motion info      */   send.update.ms=real.milliseconds;  /* send update now       */end send.long.message;/* $Page - Scsi/LOD initialization *//* initialization */if (read("51")&"40000")<>0 then do;     /* scsi board exists        */   lod.d24.#    = 0;                    /* start here               */   look.for.lod = 1;   if debug then lod.d24.#=3; /* start here for speed */end;print 'Start of Synclavier Simulation Program';print;print '  P         Play            ';print '  F         FF              ';print '  R         REW to 0        ';print '  C         ReCord          ';print '  S         Stop            ';print '  <space>   Speed entry     ';print '  M         Mark Start      ';print '  1,2       Soloing         ';print '  T         Title           ';print '  D         Directory toggle';print '  E         Enter directory info or transfer SFM file';print '  N         Enter File Name of LOD program';print 'd16 :',d16tim;screen=1;do while 1;   call run.syn.loop;                        /* main program          */   if  (inc.poly<>0)   and (inc.mono =0)   then do;      if  (lod.running   <>0)                /* lod is running        */      and (new.motion    <>0)                /* must send play time   */      then do;         call send.long.message;             /* send complete message  */      end;      else if real.milliseconds>=send.update.ms      then do;                               /* time for lod activity  */         if (look.for.lod<>0) then do;       /* find a lod if possible */            write(ScsiSel)  =S$SelectEnable \ Scsibits (lod.d24.#);  /* select this d24 */            if (read(ScsiSel) & Scsibits(lod.d24.#))=0 then do;      /* board does not exist */               lod.d24.#=(lod.d24.#+1)&3;             /* try other d24      */            end;            else do;               i=send.to.lod(1);                      /* try to send 'HELLO'  */               if i<>0 then call interrogate.lod(i);  /* if answer, check     */               else lod.d24.#=(lod.d24.#+1)&3;        /* else try another d24 */            end;            send.update.ms=real.milliseconds+1000;    /* approx once per second        */         end;           /* of look.for.lod<>0          */         else if lod.running<>0 then do;       /* send short message */            if send.to.lod(130)<>3             /* let send.to.lod sample play.time.lsb & timer precisely */            then do;                           /* must be lod pgm    */               lod.running=0;               look.for.lod=1;            end;            if ddulen<>0             then send.update.ms=real.milliseconds    ;            else send.update.ms=real.milliseconds+200;  /* approx 5 times/second */         end;      end;              /* of lod activity timer       */   end;                 /* if inc.poly<>0 & inc.mono=0 */   if break.me<>0 then do;      if lod.running<>0 then do;         call send.to.lod(4);        end;      call exit(0);   end;   disable;   i=new.info; new.info=0;   enable;   /* process new.info commands */   scsi.out.buf(0)=0;   do case (i);      ;      do;      /* RETURN - REDRAW SCREEN */         if screen=1 then do;            call send.to.lod(12);         end;         else if screen=2 then do;            call send.to.lod(13);         end;      end;      call send.to.lod(11);  /* up arrow                       */      call send.to.lod(10);  /* down arrow                     */      do;     /* T - ENTER TITLE                               */         scsi.out.buf(0)=24;         do j=1 to 12;            scsi.out.buf(j)=(65+shl(j-1,1))+shl(66+shl(j-1,1),8);         end;         call send.to.lod(140);  /* set name ABCDEFGHIJKLMNOP */      end;      do;     /* D - TOGGLE DIRECTORY */         if screen=1 then do;            screen=2;            call send.to.lod(13);         end;         else if screen=2 then do;            screen=1;            call send.to.lod(12);         end;      END;      do;   /* A - disk dump */         call send.to.lod(22);      end;      do;   /* E - enter directory item */         print;         print 'Enter directory item: ';         print '   1,0    :toggle song protected status';         print '   2,0    :toggle repro/input/auto     ';         print '   3,0    :toggle safe/ready           ';         print '   4,x    :enter start time            ';         print '   5,x    :enter end time              ';         print '   6,x    :enter sample rate           ';         print '   7,x    :enter input chan            ';         print '   8,x    :command  0. backup song    1. load  song  ';         print '                    2. backup all     3. load  all   ';         print '                    4. erase  song    5. erase all   ';         print '                    6. erase  track   7. backup track';         print '                    8. load   track   9. cancel op   ';         print '                   10. protect all   11. all safe    ';         print '   9,0    :delete song line            ';         print '  10,0    :append song line            ';         print '  11,0    :insert song line            ';         print '  12,x    :change cross fade time      ';         print '  13,x    :change gain                 ';         print '  14,x    :change volume               ';         print '  15,x    :change pan                  ';         print '  16,0    :load file for SFM           ';         print 'Info--',;         input i,j;         do case i;            ;            call send.to.lod(14);  /* toggle protected */            call send.to.lod(16);  /* toggle r/i/a     */            call send.to.lod(17);  /* toggle safe/rdy  */            do;               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(141);   /* start time */            end;            do;               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(142);   /* end time   */            end;            do;               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(146);   /* sample rate */            end;            do;               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(145);   /* input chan   */            end;            do;                         /* send         */               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(144);   /* command      */            end;            call send.to.lod(19);  /* delete           */            call send.to.lod(20);  /* +                */            call send.to.lod(21);  /* -                */            do;                       /* cross fade time */               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(150);               end;            do;                       /* set gain */               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(147);               end;            do;                       /* volume */               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(148);               end;            do;                       /* pan   */               scsi.out.buf(0)=2;               scsi.out.buf(1)=j;               call send.to.lod(149);               end;            begin;               dcl fname (64) fixed;               print;               print 'Enter Track #,  Starting Sector, Sector Length ',;               input j,k,l;               print 'Enter file name to store data in --',;               linput fname;               if replace.sectors(fname,sound.f,l+3,shl(l+3,8),1) then do;                  do i=0 to 255;                     misc.buf(i)=0;                  end;                  call writedata(shl(1,8),starting.sector+1,misc.buf,256);                  call writedata(shl(1,8),starting.sector+2,misc.buf,256);                  misc.buf(0)=4;                  misc.buf(1)=1;                  misc.buf(2)=0;                  misc.buf(3)=l;                  misc.buf(4)=0;                  misc.buf(6)=0;                  misc.buf(7)=l;                  misc.buf(8)=0;                  loadm l; mul 256; mwait; div 50000;                  misc.buf(9)=res;                  loadm rem; div 50;                  misc.buf(10)=res;       /* msec  */                  misc.buf(11)=rem*20;    /* mcsec */                  misc.buf(18)=4400;                  dcl z floating;                  z=3.09;                  misc.buf(19)=core(addr(z)  );                  misc.buf(20)=core(addr(z)+1);                  misc.buf(21)=600;                  misc.buf(22)=25000;                                    misc.buf(26)=misc.buf(9);                  misc.buf(27)=misc.buf(10);                  misc.buf(28)=misc.buf(11);                  call writedata(shl(1,8),starting.sector  ,misc.buf,256);                  ddusec=starting.sector+3;                  ddulen=l;                  scsi.out.buf(0)=12;    /* 12 bytes             */                  scsi.out.buf(1)=23;    /* command 23: ddu data */                  scsi.out.buf(2)=j;     /* track #              */                  scsi.out.buf(3)=0;                  scsi.out.buf(4)=k;     /* sector  */                  scsi.out.buf(5)=0;                  scsi.out.buf(6)=l;     /* length  */                  call send.to.lod(144);   /* command      */                  print 'Start of File Load';               end;               else print 'Not Enough Space On Disk';            end;         end;      end;      do;                              /* load from tape */         print 'Tape Load:  Enter # of sectors--',;         input i;         do while i<>0;            j=i;            if j igt 16 then j=16;            i=i-j;            call READ_tape(location(addr(scsi.out.buf(1))),shl(j,8));            scsi.out.buf(0)=shl(j,9);            call send.to.lod(212);         end;         print 'Done';      end;      do;            /* enter new file name for next load */         print 'Enter new file name for LOD loading --',;         linput filename;      end;   end;end;