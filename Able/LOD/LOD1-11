/* $page - start port io for recording, playback *//* 11/21/91 - cj - commented out unused code to save room             *//*                 Also change cue stack backup logic                 *//*                 to fix bugs on high speed systems                  *//* STart.Port.IO is called to initiate a read or write of data   while recording or playing back                                    *//* notes on fadein/fadeout:   short digital cross fades are computed   *//* between audio segments.   this is done to get rid of the small      *//* clicks and pops that would otherwise occur.                         *//* Port.Fadein is set when we are reading the disk forward and we      *//* are reading the front of a new cue (or the zeroes after the last    *//* cue).   This tells the disk code to construct the fade in at the    *//* start of the data that was read in                                  *//* Port.Fadeout is set when we are reading the disk backwards and      *//* the last sactor being read is the end of the cue (or the zeroes     *//* before the first cue or gap).   This tells the disk code to         *//* construct a fade out/fade in at the end of the data that            *//* is read in                                                          */Start.Port.Io:proc(port#);               /* start io operation */   dcl (port#,track#,buf#) fixed;   dcl (dtrack#)           fixed;   dcl (slen#)             fixed;   dcl (drive#)            fixed;   dcl (pmemsec,pmemwrd)   fixed;   dcl (Sec)      (1)      fixed;   dcl (secmsb)   lit      'Sec(0)';   dcl (seclsb)   lit      'Sec(1)';   dcl (a,b,c,d)   (1)     fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';   dcl cmsb    lit  'c(0)';   dcl clsb    lit  'c(1)';   dcl dmsb    lit  'd(0)';   dcl dlsb    lit  'd(1)';   dcl (i)                 fixed;   dcl (writing  )         fixed;   dcl (dir)               fixed;   /* Check for cue stack backup:   This routine is called when */   /* we are trying to read the disk using the cue stack and    */   /* either  1) the current cue pointer points to the end      */   /* of the stacked cue list for this stack,  or  the          */   /* disk time to read is before the start of the current      */   /* cue.   If these conditions exist and there is prior       */   /* cue on the cue stack,  and we are trying to read          */   /* from it,  then we must back up the cue stack              */   /* Happens during looped playback (fine scroll bar) and      */   /* the user backs up                                         */   Check.For.Cue.Stack.Backup: proc;      dcl Seg.Ptr  fixed;      dcl t(1)     fixed;      /* Get pointer to prior block on cue (if any)             */      Seg.Ptr = cue.read.ptr(track#);    /* get current pointer */      if Seg.Ptr = 0 then do;            /* if at end, get      */         write(mam) = cseg.xmsec#;       /* pointer to last     */         write(mal) = shl(track#, 1) + 1;/* block on que        */         Seg.Ptr    = read(md);          /* (if any)            */      end;      else do;                           /* else back up        */         Seg.Ptr = gseg.info(Seg.Ptr + Seg.Bptr.Loc);      end;      if Seg.Ptr = shl(track#, 1)        /* if none,  then      */      then return 0;                     /* cannot back up      */      call gseg.info(Seg.Ptr + Seg.End.Loc);      t(0) = read(mdi);      t(1) = read(mdi);      if (COM32(Sec, t) = lw#ilt) /* if has audio we needed,       */      then do;                    /* then read it in again         */         call read.seg.stack(Seg.Ptr);      /* look at prior block */         Seg.Exists = Seg.Exists & not(32); /* clear expired bit   */         call write.seg.stack(Seg.Ptr);     /* in prior block      */         cue.read.ptr(track#) = Seg.Ptr;    /* back up to it       */         return 1;      end;      return 0;   end Check.For.Cue.Stack.Backup;   /* give priority to this track to provide greater bandwidth        */   /* for max trax/DDT/Bounce problems.   Basically,  if there is     */   /* room in the buffer for 10 more sectors of audio data after      */   /* this edit point,  then we will read more data for this track    */   /* immediately instead of going on to the next track               */   Limit.Length: proc(NewLength);      dcl NewLength fixed;      if (slen# IGT (NewLength+10))       /* if 10 more sectors avail */      then port.toggle(port#) = track# & (tracks.per.port-1);      slen#=NewLength;                          /* limit to region            */   end Limit.Length;         /* look up passed info: */   track#  = port.io.track#(port#);    /* get controlling track */   slen#   = port.io.len#  (port#);    /* and sector length     */   port.fadein (port#)=0;              /* clear fade in flags   */   port.fadeout(port#)=0;                    /* re-enter here for retry if we are */   /* reading backwards, and we         */   /* run into a boundary               */   retry:;   dtrack# = track#;                   /* assume disk is same   */   if (port.io(port#)=2)               /* read or request sense */   or (port.io(port#)=4)               /* after read            */   then begin;      dcl (offs) fixed;                /* offset from buf base  */      writing = 0;      buf# = port.io.buf#(port#);      do case (buf#-1);                /* compute ptrs          */         do;                           /* for first logical     */            secmsb=buf1.msb(track#);   /* buffer                */            seclsb=buf1.lsb(track#);            offs  =buf1.len(track#);               dir   =0;         end;         do;                           /* for second logical    */            secmsb=buf2.msb(track#);   /* buffer                */            seclsb=buf2.lsb(track#);            offs  =buf2.len(track#);            dir   =0;         end;         do;                           /* for third logical     */            secmsb=buf3.msb(track#);   /* buffer                */            seclsb=buf3.lsb(track#);            offs  =buf.len - buf3.len(track#) - slen#;            dir   =1;         end;         do;                           /* special case for      */            secmsb=buf1.msb(track#);   /* re-reading buf#1      */            seclsb=buf1.lsb(track#);   /* data that had gotten clobbered by reading into buf#2 */            offs  =clob.len(track#) - slen#;            dir   =1;         end;      end;      pmemsec=compute.base.adr(track#)+buf.base+offs;  /* read into this section of memory */      pmemwrd=0;                                       /* for now                          */      offs=shl(offs,8);                /* get offset in buf     */      seclsb=seclsb+offs;              /* in samples            */      if seclsb ilt offs      then secmsb=secmsb+1;   end;   else begin;                         /* write or request sense */      dcl (offs) fixed;                /* after write            */      writing = 1;      secmsb = rec.s#.msb   (track#);  /* msb            */      seclsb = rec.s#.lsb   (track#);  /* lsb            */      offs   = shr(rec.s#.lsb(track#)-recb.lsb(track#),8);  /* sector # in buffer where data sits */      pmemsec=compute.base.adr(track#)+buf.base;        pmemwrd=0;                                             if piolen(track#)=0                  /* if done with punch-in/out    */      then do;                             /* then write from recbuf       */         pmemsec=pmemsec + rec.base;       /* do so.                       */         if  (Correct.DDT.Sync       <> 0) /* if correcting for ddt delay  */         and (track.sampling(track#) =  2) /* (only during DDT in)         */         then do;            offs = offs + shr(ddt.monitor.delay,8);  /* pick up that data  */            if offs IGE buf.len            /* check for wrap to start      */            then offs = offs - buf.len;    /* of next buffer               */         end;      end;      pmemsec = pmemsec + offs;      if (buf.len - offs) ILT slen#        /* limit write command to end   */      then call Limit.Length(buf.len-offs);/* of rotary buffer             */      dir = 0;   end;   /* $page - check song boundaries */   /* set up secmsb,seclsb = sector to read */   /* set up amsb,alsb     = length to read */   /* secmsb,seclsb are in samples here     */   /* eventually are converted to sectors   */   /* below                                 */   next.cue:;   if  (source.or.cue(track#)<>1)         /* if source plback   */   then do;                               /* then limit to song */      call SHR32(Sec, 8);                 /* now get sector #   */      /* check for read/write past end */      /* of song:                      */      if COM32(Sec, Song.Ending) >= lw#ieq      then do;                          /* past end of song     */         port.io  (port#) = 0;                   track.eof(track#)= 1;          /* end of track reached */         return;                        /* done                 */      end;      /* also check for read/write before */      /* start of song - happens during   */      /* cue recording if cue stack       */      /* gets clobbered by complex        */      /* timing type of problems          */      if COM32(Sec, Song.Data) = lw#ilt      then do;                          /* past end of song       */         /* could check here (if dir <> 0) for reading backwards  */         /* to very front of song.  we won't take the time now    */         /* since all backwards reading is done via the           */         /* cue stack                                             */         port.io  (port#) = 0;                   track.eof(track#)= 1;          /* end of track reached   */         return;                        /* done                   */      end;      call SUB32(Song.Ending, Sec, A);     /* get # of sectors left   */                                           /* in song to limit read   */                                           /* command issued below    */   end;   /* $page - map disk addresses to actual location */   /* through cue stack                             */   else do;                               /* cue playback         */      /* deal with sample #'s for a while */      /* here to simplify later items:    */      if cue.read.ptr(track#) = 0         /* if we have reached end of */      then do;                            /* list,  then check for     */                                          /* backing up                */         if Check.For.Cue.Stack.Backup <> 0  /* back up to prior cue   */         then goto next.cue;                 /* if scrubbing backwards */         call COPY32(Zero.S#, Sec);       /* read a full load     */         call COPY32(Zero.Len.S#, A);     /* of digital zeroes    */      end;      else do;                            /* a cue is on the stak */         call read.seg.stack(cue.read.ptr(track#)); /* get 8 words quickly  */         if COM32(Sec, Seg.Sync) = lw#ilt  /* if trying to read data before */         then do;                          /* start of this cue, check      */            /* but check to see if this is the first block of data   */            /* before the cue and we are reading backwards.  If so   */            /* then fadeout/fadein will be needed                    */            if dir<>0 then do;                 /* if backwards read   */               call COPY32(Sec, D);            /* get sample #        */               call ADD16 (shl(slen#,8), D);   /* compute ending s#   */               if COM32(D, Seg.Sync) = lw#ieq  /* if next sector read */               then port.fadeout(port#) = 1;   /* will be the one just before the start of this cue,  then fadeout/fade in is needed at end of that data */            end;            if Check.For.Cue.Stack.Backup <> 0  /* see if looping, should back up */            then goto next.cue;            /* if not looping, or above test fails (no prior cue, or */            /* not back that far),  then read digital zeroes         */            /* from the disk                                         */            call SUB32(Seg.Sync, Sec, A);    /* get distance to cue    */            if COM32(A, Zero.Len.S#) = lw#igt  /* limit to length of   */            then call COPY32(Zero.Len.S#, A);  /* zero region          */            call COPY32(Zero.S#, Sec);         /* and read from there  */         end;                                  /* write detected later */         else do;                              /* reading at or after sync point for this cue */            /* compute length of cue in  */            /* samples to have it handy: */            call SUB32(Seg.End, Seg.Sync, B);            /* now check some things: */            /* see if we are reading after the end */            /* of this cue                         */            if COM32(Sec, Seg.End) >= lw#ieq            then do;               if writing then do;         /* if we are writing past the   */                  port.io  (port#) = 0;    /* end of the stacked cue, then */                  track.eof(track#)= 1;    /* must be a system error of    */                  return;                  /* some sort                    */               end;               /* check for fadein needed at start of this  */               /* audio segment                             */               /* if we are reading forward and this is the */               /* first sector after the end of the cur     */               /* cue,  then set flag to construct fade out */               /* fade in at beginning of this next audio   */               /* segment.   We must check here since the   */               /* next audio segment may be digital zeroes  */               /* in which case we would not be reading     */               /* from the front of the next cue            */               if  (dir = 0)                      /* if reading forward  */               and (COM32(Sec, Seg.End) = lw#ieq) /* first sector after  */               then port.fadein(port#) = 1;       /* end of cue          */               /* advance to next cue - first check */               /* for looping specified             */               if  (0)                         /* not used 11/19/91    */               /* if  ((Seg.Exists&2) <> 0  )     if looping specified */               /* and ((bmsb          <> 0  )     and loop length >=   */               /* or   (blsb         ige 256))    one sector           */               then do;                        /* loop of cue */                  call COPY32(Seg.End, Seg.Sync); /* move end point to starting point to affect loop */                  call ADD32(Seg.End, B, Seg.End);                  call ADD32(Scroll.Base, B, Scroll.Base); /* move scroll base ahead so that displayed looping time does not change */                  if ((Seg.Exists&16)<>0)      /* ff/rewind desired         */                  then do;                     /* perform ff/rew            */                     call COPY32(b, BIT);      /* cue length, samples       */					 ratio_multiply(abs(ff.speed), 1);                     call COPY32(Seg.Disk, C); /* get starting disk sample # handy */                     if ff.speed<0 then do;    /* rewind - back up          */                        if COM32(C, BIT) = lw#ilt                        then call STR32(0,0,C);                        else call SUB32(C, BIT, C);                        if COM32(C, Data.S#) = lw#ilt                        then call COPY32(Data.S#, C);                        call SUB32(Seg.Disk, C, BIT);  /* get amount backed up */                        call SUB32(Scroll.S#, BIT, Scroll.S#);                      end;                     else do;                        call ADD32(C, BIT, C);     /* compute new start */                        call ADD32(Scroll.S#, Bit, Scroll.S#);                      end;                     call COPY32(C, Seg.Disk);                  end;                  call write.seg.stack(cue.read.ptr(track#)); /* re-write modified info */                  goto next.cue;               end;               if  ((Seg.Exists&64)       <>0) /* we will later be recording over  */               and (recrec(recrec.rehearse)=0) /* does not apply if rehearsing */               then do;                  /* this cue                         */                  port.io  (port#)  = 0; /* treat as if we ran into          */                  track.eof(track#) = 1; /* end of track so cue stays on stk */                  port.fadein(port#)= 0;                   return;                /* otherwise cue will be gone by    */               end;                      /* the time we need to write        */               /* leave cue on stack in case we have to reset buffer pointers    */               /* back to the middle of this cue.  advance read pointer over it  */               /* set expired bit since cue really has expired and we can toss   */               /* it when we need the space on the stack                         */               Seg.Exists = Seg.Exists \ 32;     /* indicate expired */               call write.seg.stack(cue.read.ptr(track#)); /* re-write modified info */               i = Seg.Exists&128;               /* save return to source bit */               if Seg.Fptr = shl(track#, 1)      /* if forward pointer points to head   */               then cue.read.ptr(track#) = 0;    /* of cue,  then set cue.read.ptr to 0 */               else cue.read.ptr(track#) = Seg.Fptr;  /* else advance pointer           */               if  (cue.read.ptr(track#) = 0)   /* if end of cue stack reached */               and (i                    <>0)   /* and we desire to return to  */               then do;                         /* source playback             */                  source.or.cue(track#) = 2;    /* then do so               */               end;               goto next.cue;       /* see if there is another one */            end;            /* reading/writing within cue area */            /* compute offset from     */            /* start of cue            */            if  (writing)               /* if we are writing to disk  */            and ((Seg.Exists&64) <> 0)  /* and this is the recording  */            then do;                    /* cue,  then clear bit now   */               Seg.Exists = Seg.Exists & not(64); /* so we can skip over it above. */               call write.seg.stack(cue.read.ptr(track#)); /* restore modified info */            end;            call SUB32(Sec, Seg.Sync, C);  /* get offset within cue to read */            call ADD32(Seg.Disk, C, Sec);  /* map to new sector address     */            call SUB32(B, C, A);           /* limit length to end of cue    */            if writing = 0 then do;        /* if not writing, check fade    */               dtrack# = Seg.Track;        /* get track we may read from    */               if dir = 0 then do;         /* forward = check start of cue  */                  if (cmsb\clsb)=0 then do;/* if reading start of cue (forward) */                     /* must fade out prior cue here since it may represent */                     /* data that was read in a long time ago (i.e before   */                     /* this new cue was stacked                            */                     if (Seg.Exists & 64) <> 0   /* perform no fade in if   */                     then port.fadein(port#)=0;  /* we will be writing data */                                                 /* back out ...            */                     else port.fadein(port#)=1;  /* else perform fade in    */                  end;               end;               else do;                          /* backing up              */                  call COPY32(C, D);             /* and this will be end    */                  call ADD16 (shl(Slen#,8), D);  /* of cue, then fade       */                  if COM32(B, D) = lw#ieq        /* out data after          */                  then port.fadeout(port#) = 1;  /* reading it              */               end;            end;                                       end;      end;      /* compute sector #'s from sample #'s */      call SHR32(Sec, 8);      call SHR32(A  , 8);   end;   /* limit length of this disk read/write command */   /* to end of appropriate region (cue or song)   */   /* as computed above                            */      if  (amsb  =  0    )   and (alsb ilt slen#)   then do;      if alsb=0 then do;                 /* must mean zero length */         port.io  (port#) = 0;           /* song                  */         track.eof(track#)= 1;                     return;                                end;      if dir = 1 then do;                /* backing up - limit region to */         slen# = slen# - alsb;           /* what is in last part of      */         goto retry;                     /* valid area, and start over   */      end;      call Limit.Length(alsb);   end;      /* if reading,  check allocation */   /* directory to see if this      */   /* sector has been written.  if  */   /* not,   read zeroes to         */   /* substitute data:              */   if  (secmsb = 0        )         /* see if accessing zeroes */   and (seclsb = zero.sec#)   then do;      if writing then do;           /* must be system error of */         port.io  (port#) = 0;      /* sorts (ie cue recording */          track.eof(track#)= 1;      /* with no cue on stack)   */         return;                          end;      else do;                      /* nothing to do - no need */      end;                          /* to check allocation     */   end;                             /* directory               */   else if  (writing = 0)           /* if reading,  then check */   then do;                         /* allocation directory    */      next.adir:;      i=adir.ptr(dtrack#);          /* pt to alloc direct     */      call gadir(i);      write("313")=addr(amsb);      /* read in amsb,alsb      */      rpc 6;                        /* bmsb,blsb, cmsb,clsb   */      write("373")=read(mdi);      /* see if adir pointer is pointing past the end */      /* of the recorded section of the track:        */      if (amsb\alsb)=0              /* means end of active    */      then do;                      /* track has been reached */         if (i&255)>=4 then do;     /* back up                */            adir.ptr(dtrack#)=adir.ptr(dtrack#)-4;            goto next.adir;         end;         secmsb=0;                   /* read zeroes from zero.sec#  */         seclsb=zero.sec#;           /* start disk read here        */      end;      /* if sector is > current */      /* block,  then must be   */      /* in next or is off end  */      else if COM32(Sec, B) >= lw#ieq      then do;         if (cmsb\clsb)=0           /* end of track reached   */         then do;            secmsb=0;               /* read zeroes from zero.sec#  */            seclsb=zero.sec#;       /* start disk read here        */         end;         /* see if sector          */         /* is in following        */         /* block                  */         else if COM32(Sec, C) >=lw#ieq         then do;            adir.ptr(dtrack#)=adir.ptr(dtrack#)+4;            goto next.adir;         end;         /* else read zeroes to fill in the    */         /* silence between the first allocate */         /* block and the second allocate      */         /* block                              */         else do;            /* limit read length to read up to */            /* start of next allocate block    */            call SUB32(C, Sec, D);                        if (dmsb=0)&(dlsb ilt slen#) /* if shorter than what we were */            then do;                     /* looking for, then must       */               if dir<>0 then do;        /* be smart                     */                  slen# = slen# - dlsb;                  goto retry;               end;               call Limit.Length(dlsb);            end;            secmsb=0;                  /* read zeroes from zero.sec#  */            seclsb=zero.sec#;          /* start disk read here        */         end;      end;      /* see if sector is before start   */      /* of current block                */      else if COM32(Sec, A) = lw#ilt      then do;         if (i&255)>=4 then do;     /* back up                     */            adir.ptr(dtrack#)=adir.ptr(dtrack#)-4;            goto next.adir;         end;         /* read zeros up until first allocated segment: */         call SUB32(A, Sec, C);     /* # of sectors we can read    */         if (cmsb=0)&(clsb ilt slen#)         then do;            if dir<>0 then do;               slen# = slen# - clsb;               goto retry;            end;            call Limit.Length(clsb);         end;         secmsb=0;                  /* read zeroes from zero.sec#  */         seclsb=zero.sec#;          /* start disk read here        */      end;      else do;                      /* within block - limit        */         call SUB32(B, Sec, C);     /* get # of sectors we can rd. */         if (cmsb=0)&(clsb ilt slen#)         then do;            if dir<>0 then do;               slen# = slen# - clsb;               goto retry;            end;            call Limit.Length(clsb);         end;      end;   end;   /* save information in case of retries: */   port.io.dtrack#(port#) = dtrack#;   port.io.len#   (port#) = slen#;    /* pass info to issue.port.command */   port.secmsb    (port#) = secmsb;   /* also save in arrays in case     */   port.seclsb    (port#) = seclsb;   /* of retries                      */   port.pmemsec   (port#) = pmemsec;    port.pmemwrd   (port#) = pmemwrd;   port.update    (port#) = 1;        /* indicate update of play info    */   call Issue.Port.Command(port#,dir); /* issue command for read/write    */end Start.Port.Io;