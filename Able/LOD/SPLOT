/* S-curve splice computations *//* General floating point routine:      Input  - 0.0000 to 1.0000      Output - 1.0000 to 0.0000       *****                                           ****      Value @ .50000 = .50000                   ***                                                   **      Slope @ .50000 = P                             *                                                      **      Slope @ 0.0000 = 0.0000                           ***      Slope @ 1.0000 = 0.0000                              ****                                                               *****    *//* C. Jones - 12-17-88 */insert ':synlits:comlits';insert ':synlits:globlits';dcl scurve.sec#  lit '0';/* Routine to return S_Curve function: */S_Curve: proc(point, power) floating;   dcl point     floating;   /* 0.0000 - 1.0000 */   dcl power     floating;   /* power factor    */   if point = 0.0000         /* avoid math problems with */   then return 1.0000;       /* log of 0                 */   if point < .5000   then return (1.0000 - (exp(log(2*point)*power)/2.0000));   else return exp(log(2.0000*(1.0000 - point))*power)/2.0000;end S_Curve;/* Construct linear interpolation table in external memory: */Construct_S_Curve_Table: proc(power);   dcl power floating;   dcl (i,j,k) fixed;   dcl (a,b,c) floating;   dcl (last) fixed;   last = 65535;   write(mam) = scurve.sec#;   do i = 1 to 256;      a = i / 256.0;          /* get next fraction from 0 - .99999 */      b = s_curve(a, power);  /* get next value                    */      j = 1 + int(b*65534.0+.5); /* scale 1 - 65535, with rounding */      write(mdi) = last-j;    /* store NEGATIVE slope */      write(mdi) = last;      /* and value            */      last = j;   end;end Construct_S_Curve_Table;/* Routine to quickly compute s-curve value for 0-65535 input */Interpolate_S_Curve: proc(val);   dcl val   fixed;   write(mam) = scurve.sec# + (rot(val,1)&1);  /* index to 2 sector table */   write(mal) = shl(shr(val,8), 1);   load   read(mdi); mul (val&255); mwait; div 256;   if rem >= 128   then return read(md) - res - 1;   /* remember NEGATIVE slope was stored */   else return read(md) - res    ;   /* remember NEGATIVE slope was stored */end Interpolate_S_Curve;insert ':synmods:ttydcl';insert ':synmods:plotdcl';insert ':synmods:syndummy';dcl xpix   fixed;dcl ypix   fixed;print 'Enter xpix, ypix --',;input xpix, ypix;call clear.term;call viewport  (50, 50+xpix, 50, 50+ypix);call window    (0, xpix, 0, ypix);call border;dcl (i,j,k,l) fixed;dcl list floating data (.1, .2, .4, .6, 1.0, 2.0, 3.0, 5.0, 10.0);do i = 0 to 8;   call Construct_S_Curve_Table(list(i));   call move_to  (0,ypix);   j = 32;   do while j <> 0;      load j; mul xpix; k = ures;      load Interpolate_S_Curve(j); mul ypix; l = ures;      call plot(k, l);      j = j + 32;   end;end;transparent_mode;call tty_wait;stop;