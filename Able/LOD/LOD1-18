/* LOD1-18 - erase track info *//* mark adir to indicate no data recorded for this track */erase.track.info:proc (track#) swapable;   dcl (track#       ) fixed;   dcl (amsb,alsb    ) fixed;   dcl (bmsb,blsb    ) fixed;   dcl (i,j,k,l,m    ) fixed;   remove.from.adir:proc(track#);      dcl (track#       ) fixed;      dcl (secmsb,seclsb) fixed;      dcl (amsb,alsb    ) fixed;      dcl (bmsb,blsb    ) fixed;      dcl (dmsb,dlsb    ) fixed;      dcl (i,j,k,l,m    ) fixed;      /* remove area for this song          */      /* from allocation directory          */      secmsb=c.data.msb;        /* get starting sector    */      seclsb=c.data.lsb;        /* handy                  */      dmsb   =c.end.msb;        /* also get ending        */      dlsb   =c.end.lsb;        /* sector handy           */      adir.ptr(track#)=track#*adir.len; /* start at top       */      i=adir.ptr(track#);           /* pt to alloc direct    */      next.adir:;      call gadir(i);      write("313")=addr(amsb);      /* read in amsb,alsb      */      rpc 4;                        /* bmsb,blsb              */      write("373")=read(mdi);      if (amsb\alsb)=0              /* means end of active    */      then do;                      /* track has been reached */         return;                    /* has been collected     */      end;      if  ((amsb igt dmsb))         /* see if this block      */      or  ((amsb  =  dmsb)          /* begins after end of    */      and  (alsb ige dlsb))         /* section we wish        */      then do;                      /* to erase               */         return;                    /* done                   */      end;      if  ((bmsb ilt secmsb))       /* see if block ends      */      or  ((bmsb  =  secmsb)        /* before the section     */      and  (blsb ile seclsb))       /* we need to erase       */      then do;         i=i+4;         goto next.adir;            /* try next one           */      end;      if  ((amsb ilt secmsb))       /* if this block starts   */      or  ((amsb  =  secmsb)        /* before the section     */      and  (alsb ilt seclsb))       /* to be erased, we       */      then do;                      /* must keep some of it   */         call gadir(i+2);         write(mdi)=secmsb;         /* must keep section from */         write(mdi)=seclsb;         /* amsb,lsb to secmsb,lsb */         new.adir(track#)=1;         i=i+4;                              if  ((bmsb ilt dmsb))      /* if block ends within   */         or  ((bmsb  =  dmsb)       /* erased section         */         and  (blsb ile dlsb))      /* then it goes.  check   */         then do;                   /* next block to see if   */            goto next.adir;         /* it is still in erased  */         end;                       /* section                */         call read.store(adir.xmsec#,i);         call read.len  (addr(misc.buf(0)),adir.len-(i&255)-8);         call write.store(adir.xmsec#,i+4);         call write.len (addr(misc.buf(0)),adir.len-(i&255)-8);         call gadir(i);         write(mdi)=dmsb;            /* otherwide create a     */         write(mdi)=dlsb;            /* from end of erased     */         write(mdi)=bmsb;            /* section to end         */         write(mdi)=blsb;            /* of written section     */         new.adir(track#)=1;         return;                    /* and that will do it    */      end;      if  ((bmsb ilt dmsb))         /* if block ended within  */      or  ((bmsb  =  dmsb)          /* the erase section      */      and  (blsb ile dlsb))         /* then it goes away      */      then do;         call read.store(adir.xmsec#,i+4);         call read.len  (addr(misc.buf(0)),adir.len-(i&255)-4);         call write.store(adir.xmsec#,i );         call write.len (addr(misc.buf(0)),adir.len-(i&255)-4);         new.adir(track#)=1;         goto next.adir;      end;      call gadir(i);      write(mdi)=dmsb;              /* else make this block   */      write(mdi)=dlsb;              /* start at the end of    */      new.adir(track#)=1;           /* the erase section      */      return;                       /* and that will do it    */   end remove.from.adir;   call remove.from.adir(track#);   /* un-allocate space      */   adir.ptr(track#)=track#*adir.len;/* reset to start         */   /* check for shortening track: */   /* determine where in the trk  */   /* we erased from and set      */   /* used to there               */   /* Note: at this point,  c.data.msb, c.end.msb represent the area   */   /* we wish to erase.  This will match the entire project if we      */   /* are erasing the whole project.  It will only be part of the      */   /* project in the case of a 'retake'.                               */   s.start = gsong.dir(command.song*song.len+song.start); /* look up start */   s.end   = gsong.dir(command.song*song.len+song.end);   /* and end times */   call compute.bounds(loc(addr(amsb)),loc(addr(bmsb)));  /* get sectors   */   call SUB32(loc(addr(c.data.msb)),loc(addr(amsb)),loc(addr(BITMSB)));   call ratio_multiply(256,50000);     /* get # of seconds       */   call unround;                       /* no rounding            */   if mul.llsb<>0                      /* but round up instead   */   then bitlsb=bitlsb+1;   l = bitlsb;                         /* start of erase area    */   call SUB32(loc(addr(c.end.msb)),loc(addr(amsb)),loc(addr(BITMSB)));   call ratio_multiply(256,50000);     /* get # of seconds       */   call unround;                       /* no rounding            */   if mul.llsb<>0                      /* but round up instead   */   then bitlsb=bitlsb+1;   m = bitlsb;                         /* end of erase area      */   i=alt.tdir(track#*track.len+track.used);   if (i > l) and (i <= m)             /* if we erase end of recorded area */   then do;      alt.tdir(track#*track.len+track.used)=l;  /* now track is this long */      alt.tdir.updated=1;      i=gsong.dir(command.song*song.len+song.modified);      if (i&1)=0 then do;             /* song was not modified  */         write(md)=i\1;         command.song.dir.updated=1;      end;      k=l;                               /* find longest track     */      do j=0 to max.tracks-1;         i=alt.tdir(j*track.len+track.used);         if i igt k then k=i;      end;      i=gsong.dir(command.song*song.len+song.used);      if k ilt i then do;                /* song was longer; is shorter now */         write(md)=k;         i=gsong.dir(command.song*song.len+song.status);         if k=0                          /* not modified or locked if empty */         then write(md)=0;         command.song.dir.updated=1;      end;   end;   /* remove this track from cue directory */   call process.all.cues(1,bits(track#),track.avail.bits);end erase.track.info;