/* TALKSOUD -   $TITLE  handle directory data commands   Modified:   02/11/92 - cj  - allow multi udio to work with DDSYN   01/08/92 - cj  - Added 144:58 message to get buf.len                    Added 144:59 message to move poly around                    Added 144:60 message to get sync stuff   08/14/91 - cj  - Added UDIO/DDSYN stuff   07/29/91 - cj  - Handled 144:57 message for Editview Envelopes   02/09/91 - cj  - Added more tape commands   04/27/90 - MWH - Only give error if actually recording, not new adir   03/15/90 - cj/lss - allow maxtrax if tdebug/xdebug   06/14/89 - cj  - added command for cue scrubbing   03/23/89 - cj  - changed ERASE ALL command functionality   03/13/89 - LSS - changed messages that still referred to "songs"   09/19/88 - SJS - Moved handle.cue.commands to lod1-7   09/12/88 - MWH - Add DSP interface   */dcl Cue.Retake.Start (1) fixed public;dcl Cue.Retake.Len   (1) fixed public;handle.song.track.title: proc swapable;   dcl i fixed;   if screen=1 then do;          /* song title                  */      call song.lookup;      if (s.status&2)<>0      then call log.error('Project is Locked - Changes not allowed');      else if check.song=0 then do;         call gsong.dir((song.base+dtd.song#)*song.len+song.title);         do i=0 to 11;           /* store in directory          */            write(mdi)=scsi.in.buf(i+1);         end;         call song.store;      end;   end;   if screen=2 then do;          /* change track title          */      call song.lookup;      if (s.status&2)<>0      then call log.error('Project is Locked - Changes not allowed');      else if track.dir.valid=0      then call log.sys.is.not.ready;      else if check.song=0 then do;         call track.lookup;         do i=0 to 7;           /* store in directory           */            track.dir(dtd.track#*track.len+track.title+i)=scsi.in.buf(i+1);         end;         call track.store;      end;   end;end handle.song.track.title;handle.song.start.time: proc swapable;   call song.lookup;   s.start=scsi.in.buf(1);       /* try new start time out      */   if (s.status&1)<>0            /* song is non-empty           */   then call log.error('Must Erase Project to Change Start Time');   else if any.track.actually.recording<>0   then call log.error('Cannot Change Start Time While Recording');   else if s.start ige dtd.max.secs   then call log.error('Cannot set Start time off end of disk');   else if check.song=0 then do;      if s.end ilt s.start       /* brint end time out    */      then s.end=s.start;        /* with start time       */      call song.store;      new.dtd.song#=1;        /* recompute start time        */      call check.for.song.overlap;      if songs.overlap <> 0      then do;         log.buf(0)=0;        /* give this message priority  */         call log.error('Warning:');         call log.overlap.message;      end;   end;end handle.song.start.time;handle.song.end.time: proc swapable;   call song.lookup;   s.end=scsi.in.buf(1);         /* get new end time            */   if (s.status&2)<>0   then call log.error('Project is Locked - Changes not allowed');   else if s.end ilt s.start   then call log.error('Cannot set End time before Start time');   else if s.end<(s.start+s.used)   then call log.error('Must Erase Project to Shorten');   else if s.end igt dtd.max.secs   then call log.error('Cannot set End time off end of disk');   else if any.track.actually.recording<>0   then call log.error('Cannot Change End Time While Recording');   else if check.song=0 then do;      call song.store;      new.dtd.song#=1;           /* recompute start time        */      call check.for.song.overlap;      if songs.overlap <> 0      then do;         log.buf(0)=0;        /* give this message priority  */         call log.error('Warning:');         call log.overlap.message;      end;   end;end handle.song.end.time;/* Subroutine for various erase all configurations */Process.Erase.All.Command: proc(commandcode) public swapable;   dcl (commandcode) fixed;   dcl (i,j,k)       fixed;   i=dtd.song#; j=0;    /* save current song#  */   k=song.base; song.base=0;   do dtd.song#=0 to num.songs-1;      call song.lookup;      if (s.status&2)<>0      then do;         j=1;         /* protected song found        */         if log.buf(0)=0         then do;     /* display error               */            call log.error('Cannot Erase All Projects: Project "');            call append.song.name;            call append.log.string('" is Locked');         end;      end;   end;   dtd.song#=i; song.base=k;   if j=0 then do;      /* no protected song found     */      if room.for.commands then do;         call push.command(commandcode,-1,-1,0);         erase1=9876;         erase2=5432;      end;   end;end Process.Erase.All.Command;Process.Load.Project.Command: proc(commandcode) swapable;   dcl (commandcode) fixed;   call song.lookup;   if (s.status&2)<>0   /* protected                   */   then call log.error('Project is Locked - Cannot Load');   else if check.for.song.overlap<>0   then call log.error('Projects Overlap - Cannot Load');   else if room.for.commands then do;      call push.command(commandcode,song.base+dtd.song#,-1,1);   end;end Process.Load.Project.Command;Process.Load.All.Command: proc(commandcode) swapable;   dcl (commandcode) fixed;   dcl (i,j,k)       fixed;   i=dtd.song#; j=0;    /* save current song#          */   k=song.base; song.base=0;   do dtd.song#=k+i to num.songs-1;  /* check all following songs */      call song.lookup;      if (s.status&2)<>0      then do;         j=1;         /* protected song found        */         if log.buf(0)=0         then do;     /* display error               */            call log.error('Cannot Load All: Project "');            call append.song.name;            call append.log.string('" is Locked');         end;      end;   end;   dtd.song#=i; song.base=k;   if j=0 then do;      /* no protected song found     */      if room.for.commands then do;         call push.command(commandcode,song.base+dtd.song#-1,-1,1);      end;   end;end Process.Load.All.Command;Handle.Directory.144.Commands:proc public swapable;   dcl (i,j,k,l,m) fixed;   dcl (a,b)  (1)  fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';	i=scsi.in.buf(1);          /* get type                    */		if (i<0) or (i>66)	then call log.error('System Error in Command');		else do case(i);           /* check commands              */				do;                     /* 0: back up song             */			call song.lookup;			if (s.status&1)=0    /* empty song?                 */			then call log.error('Cannot Backup Empty Project');			else if room.for.commands then do;			  call push.command(c.backup,song.base+dtd.song#,-1,1);			end;		end;				do;                     /* 1: load song                */			call Process.Load.Project.Command(c.lsong);		end;				do;                     /* 2: back up all              */			i=dtd.song#; j=0;    /* save current song#          */			k=song.base; song.base=0;			do dtd.song#=0 to num.songs-1;			  call song.lookup;			  if (s.status&1)<>0			  then j=1;         /* non-empty song found        */			end;			dtd.song#=i; song.base=k;			if j=0               /* all songs empty             */			then call log.error('Direct-to-Disk System is Empty');			else do;             /* stack all info               */			  i=dtd.song#; j=0;    /* save current song#          */			  k=song.base; song.base=0;			  l=command.in; m=0;   /* in case error               */			  do dtd.song#=0 to num.songs-1;				 call song.lookup;				 if ((s.status&1)<>(0           ))  /* non-empty */				 or ((s.start   )<>(s.end       ))  /* times     */				 or ((s.title(1))<>(32\shl(32,8)))  /* title     */				 then do;					if compute.bounds(a,b)=0        /* ok boundaries */					then do;						if room.for.commands then do;						  call push.command(c.backup,dtd.song#,-1,1);						end;						else m=1;					end;				 end;			  end;			  dtd.song#=i; song.base=k;			  if m<>0                /* toss all commands if */			  then command.in=l;     /* not room on stack    */			end;		end;				do;                     /* 3: load all                 */			call Process.Load.All.Command(c.lall);		end;				/* $page - erase song, all, track */				do;                     /* 4: erase song               */			call song.lookup;			if (s.status&2)<>0   /* protected                   */			then call log.error('Project is Locked - Cannot Erase');			else if (new.dtd.song#<>0)			then call log.error('System is Not Ready for Commands');			else if any.track.actually.recording<>0			then call log.error('Cannot Erase Project While Recording');			else if check.for.song.overlap<>0			then call log.error('Projects Overlap - Cannot Erase');			else if room.for.commands then do;			  call push.command(c.esong,song.base+dtd.song#,-1,1);			end;		end;				do;                        /* 5: erase all                */			if      (longconfig(Song.Dir.Track-1)) = 1			then call Process.Erase.All.Command(c.eraselng);  /* 1 */			else if (longconfig(Song.Dir.Track-1)) = 2			then call Process.Erase.All.Command(c.erase4tr);  /* 4 */			else call Process.Erase.All.Command(c.eraseall);  /* 2 */		end;      /* of erase alll       */				do;                        /* 6: erase track              */			if scsi.in.buf(0)<18			then do;                /* erase track in cur song     */			  i=bits(dtd.track#);			  call COPY32(Song.Data,  a);			  call COPY32(Song.Length,b);			  if check.tracks.for.erase(i) then do;				 call push.command(c.etrack,song.base+dtd.song#,i,1);			  end;			end;			else do;                /* selected erase              */					  /* times passed are 32-bit milliseconds with respect */			  /* to the current project                            */					  i=scsi.in.buf(2);    /* get tracks                  */					  call compute.mark.start.point(loc(addr(scsi.in.buf(6))),											0,1,a);			  call ROUND32(a);			  call SHR32  (a,8);					  call compute.mark.start.point(loc(addr(scsi.in.buf(8))),  /* convert passed cue time to sample # */											0,1,b);			  call ROUND32(b);			  call SHR32  (b,8);					  call SUB32(b,a,b);					  call COPY32(a, Cue.Retake.Start);			  call COPY32(b, Cue.Retake.Len  );					  if check.tracks.for.erase(i) then do;				 call push.command(c.etrack,song.base+dtd.song#,i,2);			  end;			end;		end;				/* $page - back up track, load track */						do;                     /* 7: back up track            */			if track.avail.and.ready<>0			then do;			  call track.lookup;			  if t.used=0          /* empty track?                */			  then call log.error('Cannot Backup Empty Track');			  else if room.for.commands then do;				 call push.command(c.backup,song.base+dtd.song#,bits(dtd.track#),1);			  end;			end;		end;				do;                     /* 8: load track                  */			call song.lookup;			call track.lookup;			if track.avail.and.ready<>0			then do;			  if (s.status&2)<>0   /* protected                   */			  then call log.error('Project is Locked - Cannot Load Track');			  else if (t.sr&1)=0   /* track is safe               */			  then call log.error('Track is Safe - Cannot Load');			  else if (t.sr&2)<>0  /* track is locked             */			  then call log.error('Track is Locked - Cannot Load');			  else if check.for.song.overlap<>0			  then call log.error('Projects Overlap - Cannot Load');			  else if room.for.commands then do;				 call push.command(c.ltrack,song.base+dtd.song#,bits(dtd.track#),1);			  end;			end;		end;				do;       /* 9: abort command    */			abort.command=1;			command.in   =0;			command.out  =0;			call mark.stars;		end;				do;       /* 10: lock all     */			do i=0 to num.songs-1;			  j=i*song.len;			  s.status=gsong.dir(j+song.status);			  if (s.status&1)<>0 then do; /* non-empty */				 s.status=s.status \ 2;   				 write(md)=s.status;				 song.dir.updated=1;				 send.screen.info=1;			  end;			end;			call log.error('All Projects are now Locked');		end;				do;       /* 11: all safe        */			if track.dir.valid=0			then call log.sys.is.not.ready;			else do;			  do i=0 to num.tracks-1;				 j=i*track.len;				 k=track.dir(j+track.stat);				 track.dir(j+track.stat)=k&"177776"; /* t.sr */			  end;			  track.dir.updated = 1;			  send.screen.info  = 1;			  call log.error('All Tracks for this Project are now Safe');			end;		end;				do;       /* 12: lock song   */			call song.lookup;			if (s.status&1)=0			then call log.error('Cannot Lock Empty Project');			else do;			  s.status=s.status or 2;      /* lock song */			  call song.store;			end;		end;				do;       /* 13: unlock song */			call song.lookup;			s.status=s.status and (not(2));      			call song.store;		end;				do;       /* 14: unlock track */			call song.lookup;			call track.lookup;			if  (track.avail.and.ready<>0)			and (check.song            =0)			then do;                      /* change safe/ready         */			  if  ((s.status&2)<>0)      /* if song is locked         */			  then call log.error('Project is Lock Protected - Changes Not Allowed');			  else do;				 t.sr=t.sr and (not(2));				 call track.store;				 call Check.Multi.Track.DDT.Direction;				 if this.track.shares.an.input(dtd.track#) <> 0				 then new.inputs=1;			  end;			end;		end;				do;       /* 15: lock track   */			call song.lookup;			call track.lookup;			if  (track.avail.and.ready<>0)			and (check.song            =0)			then do;                     			  t.sr=t.sr or 2;			  t.sr=t.sr and (not(5));    /* safe as well */			  call track.store;			  call Check.Multi.Track.DDT.Direction;			  if this.track.shares.an.input(dtd.track#) <> 0			  then new.inputs=1;			end;		end;				do;       /* 16: all repro    */			if track.dir.valid=0			then call log.sys.is.not.ready;			else do;			  do i=0 to num.tracks-1;				 j=i*track.len;				 k=track.dir(j+track.stat);				 track.dir(j+track.stat)=k&255;				 call handle.ria.change(i);     			  end;			end;		end;				do;       /* 17: all input    */			if track.dir.valid=0			then call log.sys.is.not.ready;			else do;			  do i=0 to num.tracks-1;				 j=i*track.len;				 k=track.dir(j+track.stat);				 track.dir(j+track.stat)=(k&255)\shl(1,8);				 call handle.ria.change(i);     /* handle real time rep-inp-aut change */			  end;			end;		end;				do;       /* 18: all auto     */			if track.dir.valid=0			then call log.sys.is.not.ready;			else do;			  do i=0 to num.tracks-1;				 j=i*track.len;				 k=track.dir(j+track.stat);				 track.dir(j+track.stat)=(k&255)\shl(2,8);				 call handle.ria.change(i);     /* handle real time rep-inp-aut change */			  end;			end;		end;				do; /* 19: home */			if room.for.commands then do;			  call push.command(c.home,-1,-1,0);			end;		end;				do; /* 20: verify */			if room.for.commands then do;			  call push.command(c.verf,-1,-1,0);			end;		end;				do; /* 21: eject */			if room.for.commands then do;			  call push.command(c.eject,-1,-1,0);			end;		end;				do; /* 22: verify all */			if room.for.commands then do;			  call push.command(c.verfall,-1,-1,0);			end;		end;				do;       /* 23: read track data */			ddutrk=256\scsi.in.buf(2);          /* track # */			ddusec=    scsi.in.buf(4);			ddulen=    scsi.in.buf(6);		end;				do;                     /* 24: erase long              */			call Process.Erase.All.Command(c.eraselng);		end;      /* of erase alll       */				do;       /* 25: all cue playback */			if track.dir.valid=0			then call log.sys.is.not.ready;			else do;			  do i=0 to num.tracks-1;				 j=i*track.len;				 k=track.dir(j+track.stat);				 track.dir(j+track.stat)=k&255\shl(3,8); /* t.ria */				 call handle.ria.change(i);     /* handle real time rep-inp-aut change */			  end;			end;		end;				do;         /* 26: bounce/mix       */		end;				do;         /* 27: set ff/rew speed */			ff.speed = scsi.in.buf(2);		end;				do;         /* 28: set scroll mode */			if scsi.in.buf(2)<>0 then scrollmode = cs.alph.sort;			else                      scrollmode =    alph.sort;		end;				do;         /* 29: look up indexes */			do i=0 to 5;			  current.cue(i)=cur.ix(i);			end;			dtd.cue#    =0;			send.dtd.cue=7;		end;				do;         /* 30:  auto allocate for cue recording */					if scsi.in.buf(2) = 0 then do;   /* if no tracks specified,  then check all ready tracks */			  scsi.in.buf(2) = lookup.ready.tracks;			end;					scsi.in.buf(2) = scsi.in.buf(2) & track.avail.bits;					call COPY32(Song.Data,a);  /* get start of song */					do i=0 to max.tracks-1;    /* find last recording time in song */					  if (scsi.in.buf(2)&bits(i))<>0   /* check specified */			  then do;                         /* tracks only     */						 j=i * adir.len;               /* pt to start of alloc dir */						 next.adir:;						 call gadir(j);               /* point to it */				 b(0) = read(mdi);            /* get start   */				 b(1) = read(mdi);            /* of recorded area */						 if (b(0)\b(1))<>0 then do;    /* see if adir entry exists    */							if COM32(b,Song.Ending) = lw#ilt					then do;								call gadir(j+2);            /* get disk sector #   */						b(0) = read(mdi);           /* of end of recorded  */						b(1) = read(mdi);           /* area                */								/* include any un-written recorded data */						/* in calculation here.   this assumes  */						/* that the un-written data is about    */						/* to be written to the end of the      */						/* track.   this will always be the     */						/* case during auto-allocate recording  */						/* since we are always appending to the */						/* the track                            */								if track.recording(i)<>0						then do;						  k = shr(max.s#.lsb(i)-rec.s#.lsb(i),8);						  call ADD16(k,b);						end;								if COM32(b,a) = lw#igt						then do; 								  if COM32(b,Song.Ending) = lw#igt						  then do;							 call COPY32(Song.Ending,b);						  end;								  call COPY32(b,a);								end;								j = j + 4;								goto next.adir;							end;				 end;			  end;			end;					dtd.cue#     = 1;					call shl32(a,8);					/* times passed are 32-bit milliseconds with respect */			/* to the current project                            */					call compute.syncl.time(a,1,Syncl.Time);			call round.syncl.time(Syncl.Time);			call COPY32(Syncl.Time,Current.Cue);					call compute.syncl.time(Song.End.S#,0,Syncl.Time);			call round.syncl.time(Syncl.Time);			call COPY32(Syncl.Time,loc(addr(Current.Cue(2))));					send.dtd.cue = 5;		end;				do;       /* 31: see if armed        */			i=0;			do j=0 to max.tracks-1;			  if track.recording(j)<>0 then i=i\bits(j);			end;			current.cue (0) = armed\recrec.is.stacked;			current.cue (1) = (i <> 0);			current.cue (2) = i;			current.cue (3) = 0;			current.cue (4) = 0;			current.cue (5) = 0;			dtd.cue#        = 1;			send.dtd.cue    = 7;		end;				do;       /* 32: set ready displays */			show.all.track.readys = scsi.in.buf(2);		end;				do;       /* 33: check for record protection */			current.cue(0) = check.record.protection;			dtd.cue#        = 0;			send.dtd.cue    = 2;		end;				do;       /* 34: zero out part of track buffer  -  used during digital transfer to zero fill */			i = compute.base.adr(Scsi.In.Buf(2)) + buf.base; /* get base addr for this track + point to rotary buffer */			j = Scsi.In.Buf(4);                  /* get word length */			call psmwrite(i,Scsi.In.Buf(3));			do while j ige 256;			  rpc 256;			  write(psd)=0;			  j=j-256;			end;			if j<>0 then do;			  rpc j;			  write(psd)=0;			  j=0;			end;		end;				do;   /* 35 - get sync point */					/* times passed are 32-bit milliseconds with respect */			/* to the current project                            */					/* also, when recording, all disk times are          */			/* in the current project as well                    */					call compute.syncl.time(Sync.Point.Disk,1,Syncl.Time);			call round.syncl.time(Syncl.Time);			call COPY32(Syncl.Time, Current.Cue);					/* sync point trig is either a synclavier trigger time */			/* or the same as the disk in time                     */					call compute.syncl.time(Sync.Point.Trig,0,Syncl.Time);			call round.syncl.time(Syncl.Time);			call COPY32(Syncl.Time, loc(addr(Current.Cue(2))));					dtd.cue#        = 0;			send.dtd.cue    = 5;		end;				do;       /* 36: update sync point for cue def */					/* we are passed a synclav time which is after */			/* the first sync point                        */					/* times passed are 32-bit milliseconds with respect */			/* to the current project                            */					/* begin by getting a sample # for that */					call compute.mark.start.point(loc(addr(scsi.in.buf(2))),  /* convert passed cue time to sample # */										 0,1,A);					/* round to sector boundary for precision */					call ROUND32(A);					/* compute # of samples in prior cue (ie     */			/* # of samples back to start of sync point) */					call SUB32(A, Sync.Point.Disk, B);					/* assign new sync point */					call COPY32(A, Sync.Point.Disk);					/* assign new trig point */					call ADD32(Sync.Point.Trig, B, Sync.Point.Trig);				end;				do;   /* 37 - see if system is still busy doing command */			current.cue(0)  = (command.#<>0) or (command.in<>command.out);			dtd.cue#        = 0;			send.dtd.cue    = 2;		end;				do;   /* 38 - set new armed tracks - punch in/out of armed recording */			new.armd.tracks = new.armd.tracks \ Scsi.In.Buf(2);		end;				do;   /* 39 - get copy of track directory */			do i = 0 to 255;			  current.cue(i) = track.dir(i);			end;			dtd.cue#        = 0;			send.dtd.cue    = 257;		end;				do;   /* 40 - set dig transfer mode */			i = bits(Scsi.In.Buf(2));    /* get bit that was clicked */										/*  1 = off                 */										/*  2 = in                  */										/*  4 = out                 */										/*  8 = bounce              */										/* 16 = dsp in              */					if  (DDT.Hardware.Avail  <> 0)       /* if multi-trk     */			and (DDT.MULTI.Avail     <> 0)       /* hardware avail   */			and ((i = Dig.In )                   /* IN clicked       */			or   (i = Dig.Out))                  /* OUT clicked      */			then do;                             /* then allow both  */			  New.Dig.Xfer.Mode = (   New.Dig.Xfer.Mode								  &   (Dig.In \ Dig.Out))								  xor i;			  If New.Dig.Xfer.Mode = 0			  then New.Dig.Xfer.Mode = Dig.Off;			end;			else New.Dig.Xfer.Mode = i;          /* else assign      */					New.DTD.Song#  = 1;                  /* process it       */			Send.Init.Info = 1;                  /* send it back     */					/* See if appropriate dig xfer hardware is avail.  If    */			/* not, clear the bit now so user sees it right away.    */			/* Also send back an error message.                      */					if  ((New.Dig.Xfer.Mode & (Dig.In\Dig.Out)) <> 0)			and (DDT.MULTI.Avail  = 0)           /* no multi trk     */			and (DDT.UDIO.Avail   = 0)           /* no udio          */			then do;			  call Log.Error('Direct-Digital-Transfer hardware is not installed.');			  New.Dig.Xfer.Mode = Dig.Off;			end;					else if  ((New.Dig.Xfer.Mode & Dig.Dspin) <> 0)			and      (DDT.DDSYN.Avail = 0)       /* no ddsyn         */			then do;			  call Log.Error('DSP Input is not installed.');			  New.Dig.Xfer.Mode = Dig.Off;			end;		end;				do;                           /* 41: erase 4 track */			if max.trax.enabled = 0			then call Log.Error('This DTD software does not support 4 tracks per drive');			else if  (fastboot = 0)         /* for most people   */			and      (xdebug   = 0)			and      (tdebug   = 0)			and      (tracks.per.port = 2)  /* give error if not enough voices */			and      ((polynumv - base.voice#) < (shl(dtd.max.tracks,1)))			then call Log.Error('Hardware for 4 tracks per drive is not installed in DTD');			else call Process.Erase.All.Command(c.erase4tr);		end;  /* of erase alll       */				do;   /* 42 - set dig transfer format & sync */			i = Scsi.In.Buf(2);          /* get new format & sync    */					DDT.Format = i & 15;         /* get new format & sync    */			DDT.Sync   = shr(i,4) & 15;  /* modes                    */					New.DTD.Song#  = 1;          /* re-initialize units      */			Send.Init.Info = 1;          /* send it back             */					/* Set bits to write magic sector so that current format */			/* and sync are saved on disk:                           */					write.magic.tracks = write.magic.tracks \ track.avail.bits;				end;				do;     /* 43 - send info for Optical.Tptr */			tptr = optical.tptr;					track.drive.exists =  1;          		/* mark that drive exists         */			track.track#       =  0;          		/* use track # of 0 for errors    */			track.d24#         =  syn.d24.#;   		/* use synclavier d24             */			track.port#        =  max.ports;   		/* no port#                       */			track.target#      =  Scsi.In.Buf(2);			track.lun#         =  Scsi.In.Buf(3);			track.smsb         =  0;          		/* no base offset                 */			track.slsb         =  0;			track.emsb         = -1;          		/* assume infinite size for now   */			track.elsb         = -1;					if Scsi.In.Buf(4) = 1024          		/* set bit if 1024 byte blocks    */			then track.drive.exists = track.drive.exists \ 256;				end;				do;       /* 44 - activate 2 track erase */			call Process.Erase.All.Command(c.eraseall);		end;      /* of erase alll       */				do;       /* 45 - get amount of poly memory available  */			dtd.cue#      = polyamount;  /* send amount of poly */			send.dtd.cue  = 1;		end;				do;       /* 46 - see if poly is available for audition */			if  (func             <> 0)   /* send back dtd.cue# = 1 */			and (new.inputs        = 0)   /* if all processes that  */			and (output.happening  = 0)   /* use poly memory have   */			and (poly.buffs.in.use = 0)   /* been completed         */			and (any.port.doing.io = 0)   /* io off                 */			and (any.chan.on       = 0)			then dtd.cue# = 1;			else dtd.cue# = 0;			send.dtd.cue  = 1;			read.track.time = real.milliseconds;			timeout.point   = real.milliseconds+10000;		end;				do;       /* 47 - read disk into poly                   */				  /* handled in digest synclavier message since */				  /* the scsi port is still busy at this time   */				  /* (synclavier is waiting for our answer)     */			read.track.time = real.milliseconds;			timeout.point   = real.milliseconds+10000;		end;				do;       /* 48 - start audition                        */			/* 2 = khz * 10            */			/* 3 = stereo              */			/* 4 = poly sector msb     */			/* 5 = poly sector lsb     */			/* 6 = poly word           */			/* 7 = sector length msb   */			/* 8 = sector length lsb   */			/* 9 = word length         */					if currently.auditioning = 0			then call Initialize.Channel.32.For.Audition				(Base.Voice#, scsi.in.buf(2), scsi.in.buf(3), scsi.in.buf(5), scsi.in.buf(8));			else call Update.Audition.Pointers				(Base.Voice#, scsi.in.buf(2), scsi.in.buf(3), scsi.in.buf(5), scsi.in.buf(8));			read.track.time = real.milliseconds;			timeout.point   = real.milliseconds+10000;		end;				do;       /* 49 - see if audition is done (stop it if needed) */			if (scsi.in.buf(2) <> 0)			or (See.If.Audition.Is.Finished(Base.Voice#))			then do;			  call Terminate.Audition (Base.Voice#, 1);			  dtd.cue# = 1;			end;			else dtd.cue# = 0;			send.dtd.cue  = 1;			read.track.time = real.milliseconds;			timeout.point   = real.milliseconds+10000;		end;				do;       /* 50 - get current project sampling rate */			dtd.cue# = current.rate - Apply.Drop.Frame.Correction;			send.dtd.cue  = 1;		end;				do;       /* 51 - see if ready for event stacking   */			dtd.cue#      = dtd.is.ready.for.stacking;			send.dtd.cue  = 1;		end;				do;       /* 52 = add to project                    */			call Process.Load.Project.Command(c.asong);		end;				do;       /* 53 = a dd to all projects              */			call Process.Load.All.Command(c.aall);		end;				do;       /* 54 = show tape position                */			if room.for.commands then do;			  call push.command(c.show,-1,-1,0);			end;		end;				do;       /* 55 = quickly skip forward              */			if room.for.commands then do;			  call push.command(c.skipf,-1,-1,0);			end;		end;				do;       /* 56 = quickly skip backwards            */			if room.for.commands then do;			  call push.command(c.skipb,-1,-1,0);			end;		end;				do;       /* 57 = handled in TALKSOUE               */		end;				do;       /* 58 = return BUF.LEN for bounce         */			dtd.cue#     = buf.len;			send.dtd.cue = 1;             /* just send dtd.cue# back */		end;				do;       /* 59 = move poly around for bounce       */			/* buf(1) = 59 */			/* buf(2) = source track # */			/* buf(3) = word offset    */			/* buf(4) = dest   track # */			/* buf(5) = word offset    */			/* buf(6) = length (wrds)  */			i = compute.base.adr(scsi.in.buf(2)) + buf.base;			j = compute.base.adr(scsi.in.buf(4)) + buf.base;			call move.poly(i, scsi.in.buf(3),						  j, scsi.in.buf(5),						  0, scsi.in.buf(6));		end;				do;   /* 60 - set DDSYN sync mode */					DDT.Use.DDSYN = Scsi.In.Buf(2);					New.DTD.Song#  = 1;                  /* process it       */			Send.Init.Info = 1;                  /* send it back     */					/* See if appropriate dig xfer hardware is avail.        */					if  (DDT.Use.DDSYN <> 0)			and (DDT.DDSYN.Avail = 0)            /* no ddsyn         */			then do;			  call Log.Error('DSP Input is not installed for synchronization.');			  DDT.Use.DDSYN = 0;			end;		end;		do;       /* 61: dismount all drives */			if room.for.commands then do;				call push.command(c.dismount,-1,-1,0);			end;		end;				do;       /* 62: mount all drives */			/* handled elsewhere since subsystem ready == 0 */		end;				do;		 /* 63: format command */			call Process.Erase.All.Command(c.format);		end;				do;		/* 64: sleep command */			if room.for.commands then do;			  call push.command(c.sleep,-1,-1,0);			end;		end;				do;		/* 65: spin command */			if room.for.commands then do;			  call push.command(c.spin,-1,-1,0);			end;		end;				do;		/* 66: skip forward all command */			if room.for.commands then do;			  call push.command(c.skipfall,-1,-1,0);			end;		end;	end;         /* of command do case  */	end Handle.Directory.144.Commands;Handle.Directory.Data.Commands:proc public swapable;   dcl (i)       fixed;   do case (scsi.in.msg-140);      do;                              /* 140: song/track title       */         call handle.song.track.title;      end;      do;                              /* 141: song start time        */         call handle.song.start.time;      end;      /* $page - set song end time */      do;                              /* 142: song end time          */         call handle.song.end.time;      end;      do;                           	/* 143: set screen line        */         if screen=1 then do;            dtd.song#=scsi.in.buf(1);            if (dtd.song#=0)&(song.base<>0)            then do;               dtd.song#=dtd.song#+5;               song.base=song.base-5;            end;            if (dtd.song#=9)&((song.base+dtd.song#)<(num.songs-1))            then do;               dtd.song#=dtd.song#-5;               song.base=song.base+5;            end;            call invalidate.track.dir; /* read in new one             */            send.screen.info=1;     /* send screen info            */         end;         if screen=2 then do;       /* track base                  */            dtd.track#=scsi.in.buf(1);            if (dtd.track#) igt max.tracks then dtd.track# = max.tracks-1;            call track.error.check;            send.screen.info=1;     /* send screen info            */         end;      end;      /* $page - perform special commands - backup, load, erase */            do;                           /* 144: send command   */			/* handled elsewhere... */      end;            					/* of type 144         */      /* $page - more synclavier input codes */      do;                                /* 145: set input channel    */         call track.lookup;         if any.track.actually.recording<>0         then call log.error('Cannot Change Input While Recording');         else if track.avail.and.ready<>0         then do;                        /* change input channel */            t.input=scsi.in.buf(1);            call track.store;            call Check.Multi.Track.DDT.Direction;            new.inputs=1;         end;      end;      do;                              /* 146: song sample rate       */         call song.lookup;             /* allow sampling rate change  */         if (s.status&2)<>0            /* protected                   */         then call log.error('Project is Locked - Cannot Change Rate');         else if check.song=0 then do;            s.rate=scsi.in.buf(1);     /* for effects                 */            call song.store;            new.dtd.song#=1;           /* recompute rate and position */         end;      end;      do;                                /* 147: set gain             */         call track.lookup;         if any.track.actually.recording<>0         then call log.error('Cannot Change Gain While Recording');         else if track.avail.and.ready<>0         then do;                        /* change gain               */            t.gain=scsi.in.buf(1);            call track.store;            new.inputs=1;         end;      end;      do;                                /* 148: set volume           */         call track.lookup;         if track.dir.valid=0         then call log.sys.is.not.ready;         else do;                        /* change volume             */            t.volume=scsi.in.buf(1);     /* allow for unavailable     */            call track.store;            /* tracks if dynamic output  */                                         /* allocation going on       */            call Precompute.Volume.Information;         end;      end;      do;                                /* 149: set pan              */         call track.lookup;         if track.dir.valid=0         then call log.sys.is.not.ready;         else do;                        /* change input channel      */            t.pan=scsi.in.buf(1);            call track.store;            call Precompute.Volume.Information;         end;      end;      do;                              /* 150: cross fade time        */         call song.lookup;         s.fade=scsi.in.buf(1);         if (s.status&2)<>0            /* protected                   */         then call log.error('Project is Locked - Changes Not Allowed');         else if any.track.actually.recording<>0         then call log.error('Cannot Change Cross Fade While Recording');         else do;            call song.store;            new.dtd.song#=1;           /* compute new info            */         end;      end;      do;             /* 151: send software vesion    */                      /* handled in non-swapping code */      end;      do;                           /* 152: select current song */         if scsi.in.buf(1)<num.songs then do;            load scsi.in.buf(1);            div  10;            dtd.song# = rem;            song.base = res*10;            call invalidate.track.dir; /* read in new one             */            send.screen.info=1;        /* send screen info            */         end;      end;      do;                           /* 153: set safe/ready */         call song.lookup;         call track.lookup;         if  (track.avail.and.ready<>0)         then do;                      /* change safe/ready         */            if  ((s.status&2)   <> 0)  /* if song is locked         */            and (scsi.in.buf(1) =  1)  /* and making track ready    */            then call log.error('Project is Lock Protected');            else if ((t.sr&2)<>0)      /* else if track is locked   */            then do;                   /* then error if not safing  */               if (scsi.in.buf(1) = 1) /* and making track ready    */               then call log.error('Track is Locked');            end;            else do;               /* set bits in new.armd.tracks when safe/ready */               /* status changes                              */               if (scsi.in.buf(1) <> t.sr)               then new.armd.tracks = new.armd.tracks \ bits(dtd.track#);               t.sr=scsi.in.buf(1);               call track.store;               call Check.Multi.Track.DDT.Direction;               if this.track.shares.an.input(dtd.track#) <> 0               then new.inputs=1;            end;         end;      end;      do;                           /* 154: set repro/input/auto/cue pb */         call track.lookup;         if track.avail.and.ready<>0         then do;                      /* change repro/input/auto  */            t.ria=scsi.in.buf(1);            call track.store;            call Check.Multi.Track.DDT.Direction;            call handle.ria.change(dtd.track#);         end;      end;      do;                          /* 155: set track doa routing        */         call track.lookup;         if track.avail.and.ready<>0         then do;            /* unassign any prior tracks routed to this output */            do i = 0 to num.tracks - 1;               if (track.dir(i*track.len + track.routs) & 255) = Scsi.In.Buf(1)               then do;                  track.dir(i*track.len + track.routs) = track.dir(i*track.len + track.routs)                                                        & "177400";               end;            end;            t.routs = (t.routs&"177400") \ (scsi.in.buf(1)&255);            call track.store;         end;      end;      do;                          /* 156: set voice ddt routing        */         call track.lookup;         if track.dir.valid=0         then call log.sys.is.not.ready;         else do;            /* unassign any prior tracks routed to this output */            do i = 0 to num.tracks - 1;               if shr(track.dir(i*track.len + track.routs),8) = Scsi.In.Buf(1)               then do;                  track.dir(i*track.len + track.routs) = track.dir(i*track.len + track.routs)                                                       & 255;               end;            end;            t.routs = (t.routs&255) \ (shl(scsi.in.buf(1),8));            call track.store;         end;      end;   end;               /* of message do case  */end Handle.Directory.Data.Commands;