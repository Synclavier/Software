/* LOD1-29:  end of command, real time loop *//* 03/09/92 - cj - created event bit at end of rehearsing                 *//* 02/12/92 - cj - deleted ddsad_xtal restrictions                        *//* 09/27/91 - cj  - Send env info to DSP during TRIG                      *//* 08/14/91 - cj  - Added UDIO/DDSYN stuff                                *//* 08/14/91 - cj - slightly different use of creg_avail                   *//* 07/29/91 - cj - sent current scrub position to DSP add-on              *//* 06/26/91 - cj - added punch.out.pending to sync voice                  *//*                 switch on output                                       *//* 03/27/91 - cj - allowed more scrubbing if current rate <> 44.1         *//* 03/14/91 - cj - restricted DDSAD scrub rate to to PLL problems         *//* 03/11/91 - cj - printout out more information for sho proj info        *//* 03/07/91 - cj - Changes for DDSAD outputs                              *//* 06/12/90 - cj - Adjust scrubbing constants for improved editview sound *//* Constants for cue scrubbing algorithm *//* Constants for new algorithm developed 6/13/90 by C Jones & E Richardson */dcl scrub.alg.code     lit '  1';dcl dist.time.const    lit ' 50';dcl rate.time.const    lit '100';dcl scrub.chase.factor lit '  5';dcl scrub.rate.factor  lit '  7';dcl scrub.rate.limit   fixed;/* Original algorithm can be activated by    scrub.alg.code         '  0'     dist.time.const        ' 50'     rate.time.const        ' 25'     scrub.chase.factor     '  0' *//* check for end of background command */check.for.command.end:proc swapable;   dcl (i,j) fixed;   dcl modified.lookup data (0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0); /* c.max true if command modifies current song */   if  (alt.tdir.updated<>0  )      /* changes in alt tdir  */   and (command.#<>c.verf    )   and (command.#<>c.verfall )      /* double check         */   and (command.#<>c.show    )      /* just to be sure      */   and (command.#<>c.skipf   )   and (command.#<>c.skipb   )   and (command.#<>c.skipfall)   then do;                         /* must be written      */      if command.#=c.esong          /* after erase song     */      then call init.alt.tdir;      /* erase all track info */      write.alt.tdir=1;             /* out to disks         */      alt.tdir.tracks=track.info.bits;      alt.tdir.updated=0;      error.lsb=error.lsb+1;        /* increment error detector */      if error.lsb=0 then error.msb=error.msb+1;      if (command.song=track.dir.song)  /* is current song */      then do;         track.dir.updated=0;           /* no longer write it         */         track.dir.valid  =0;           /* but read it after we write */      end;   end;   if write.alt.tdir<>0 then return;   if any.cues.deleted<>0 then do;      /* see if cues were deleted   */      call process.all.cues(0,0,0);     /* now garbage collect        */      any.cues.deleted = 0;   end;   if command.fatal=0          /* if no fatal error message */   then do;                    /* then clean up             */      if command.aborted<>0    /* terminated by user        */      then do;         call log.error('Command Halted');         command.in =0;         command.out=0;      end;      else if tape.verify.error <> 0 then do;         call log.error('Data errors were encountered in this project.');      end;      else do;                 /* normal termination         */         if log.buf(0) <>0 then return;         /* print normal termination message: */         if  ((command.#=c.lall    )      /* load all    */         or   (command.#=c.aall    )      /* add  all    */         or   (command.#=c.verfall )      /* verify all  */         or   (command.#=c.skipfall))     /* skip all    */         and ((eotreached <>     0 ))     /* end of tape */         then do;            command.out = command.out+command.stride; /* pop command stack */            if command.in=command.out                 /* here when end     */            then do;                                  /* of tape is        */               command.in=0;                          /* reached           */               command.out=0;            end;         end;         do case (command.#-1);						  /* c.max			   */            call log.error('Backup Completed');            call log.error('Project Load Completed');            ;    /* erase all handled elsewhere */            do;               if (c.data.msb <> song.data.msb)               or (c.data.lsb <> song.data.lsb)               or (c.len.msb  <> song.len.msb )               or (c.len.lsb  <> song.len.lsb )               then call Log.Error('Cue Erase Completed');               else call log.error('Track Erase Completed');            end;            call log.error('Project Erase Completed');            call log.error('Track Load Completed');            if eotreached<>0 then call log.error('All Projects Loaded');            do;               call blockmove(skipped.song, s.title, 13);               call log.error('Project "');               call append.song.name;               call append.log.string('" has been verified');            end;            if eotreached<>0 then call log.error('Backup Media is Now at End');            call log.error('Backup Media is Now at Start');            call log.error('Backup Media is Now Released');            ;    /* erase long handled elsewhere */            call log.error('Bounce/Mix Completed');            ;    /* erase 4 track handled elsewhere */            call log.error('Add-to-Project Completed');            if eotreached<>0 then call log.error('All Projects Loaded');            do;  /* show project name */               call blockmove(skipped.song, s.title, 13);               call log.error('Next project: ');               call append.song.name;               call append.log.string(', ');               call append.khz(skipped.rate);               call append.log.string(', ');               call append.min.sec(skipped.used);            end;            do;               call blockmove(skipped.song, s.title, 13);               call log.error('Project "');               call append.song.name;               call append.log.string('" has been skipped');            end;            call log.error('Backwards Skip Completed');			;								/* dismount: handled during re-initialization */            call log.error('Completed...');	/* sleep	*/            call log.error('Completed...');	/* spin		*/			;   							/* format: handled during re-initialization   */		 	if eotreached<>0 then call log.error('All Projects Skipped; Backup Media is Now at End');         end;      end;   end;   else do;      command.in=0; command.out=0;   end;   if modified.lookup(command.#-1)<>0   then do;      if command.song=(song.base+dtd.song#)      then new.dtd.song#=1;       end;   if  (fastboot)   and (poly.buffs.in.use <> 0)   then print 'Error with Poly.Buffs.In.Use';   command.#        =0;   command.completed=0;   poly.buffs.in.use=0;   do i = 0 to max.ports;      this.buf.in.use (i) = 0;   end;   if buf.size.in.use > buf.len /* if input buffer was needed for load  */   then new.inputs = 1;         /* or backup,  then must turn off       */   send.screen.info =1;        /* update screen info after any op */   alt.tdir.needed=0;   alt.tdir.valid =0;   call mark.stars;            /* remove *'s or +'s               */   if command.song.dir.updated<>0   /* write new song dir         */   then do;      song.dir.updated        =1;   /* at end of command          */      command.song.dir.updated=0;   end;   if Synclav.software.version >= 3          /* update screen */   then get.new.motion = get.new.motion \ 4; /* on aee        */   waiting.msg.printed = 0;     /* don't glom final message!! */   delay.command       = 0;end check.for.command.end;/* $page handle new loop pos                                *//* new.loop.pos is set when the mouse has moved to a        *//* new position                                             */Handle.New.Loop.Pos:proc;   dcl (i,j)      fixed;   dcl (atmp) (1) fixed;   /* compute new mouse rate every time a new */   /* request comes in from the syncl         */   /* we can do this even if we are not       */   /* presently looping (like when we are     */   /* waiting for the buffers to load         */   if new.loop.pos = 1 then do;  /* compute new mouse rate */      /* get time,  in milliseconds */      i = Time.Of.New.Loop.Request - Time.Of.Prior.Loop.Request;      /* compute distance from prior position (in samples) */      /* to new position (in samples)                      */      j = Newly.Requested.Loop.S#(1) - Prior.Requested.Loop.S#(1);      loop.mouse.rate = 4  * j / i;  /* 2000 = 50 khz forward */      Time.Of.Prior.Loop.Request = Time.Of.New.Loop.Request;      call COPY32(Newly.Requested.Loop.S#,Prior.Requested.Loop.S#);      new.loop.pos = 2;              /* now check for new bufers */      do i = 0 to max.tracks-1;      /* may be more data         */         track.eof(i) = 0;      end;      compute.new.scrub.limit = 1;   /* compute new limit below  */   end;   /* check for buffer change once we have */   /* started the looped output            */   /* ie must get first buffer up and      */   /* running before we can go anywhere!   */   if now.looping <> 0 then do;      /* for loop playback, treat just as startup.  Get buffers */      /* loaded from correct point and then play them           */      if loop.mode = 1 then do;         if Check.Buffers.For.Looped.Playback(Newly.Requested.Loop.S#)<>0 /* if ok to play this guy */         then do;            /* construct fades and do it */            do i = 0 to max.tracks-1;           /* create first audio segment     */               if  (Track.Available  (i) <>0)   /* if track is available          */               and ((trig.tracks&bits(i))<>0)   /* and we want to hear it         */               then do;                  /* first construct audio for new loop in unused */                  /* loop buffer                                  */                  call Construct.Loop.Buffers(i,1,Cur.Loop.Buf xor 2,                       Loop.Start.In.Buffer,buf1.len(i),loop.buf.len,compute.base.adr(i));                  /* now construct the 'bridge' audio loop */                  call Construct.Loop.Buffers(i,2,Cur.Loop.Buf xor 2,                       Loop.Start.In.Buffer,buf1.len(i),loop.buf.len,compute.base.adr(i));                 end;            end;            /* now switch base addresses at the right time */            call get.sync.s#;         /* get word offset from buffer start */            /* wait until machine is playing in middle */            /* third of the loop area                  */            i = Loop.Buf.Len - 256 - loop.pre.len;            do while (sync.s#.lsb < (i))            or       (sync.s#.lsb > (i + (loop.pre.len-loop.fade.len-loop.fade.len)));               call get.sync.s#;                     end;            call ps_wave(32,shr(Loop.Buf.Len,8)-1,loop.buf2+1, 0);             j = Cur.Loop.Buf xor 2;    /* compute new buffer #  */            Cur.Loop.Buf = 2;          /* switch to loop buf #2 */            call get.sync.s#;                     do while (sync.s#.lsb ige i); /* will be random number here until first carry */               call get.sync.s#;          /* until next carry occurs    */            end;            Cur.Loop.Buf = j;             /* now go to new buffer       */            if Cur.Loop.Buf = 1 then i = loop.buf1;            else                     i = loop.buf3;            call ps_wave(32,shr(Loop.Buf.Len,8)-1,i+1,0);             new.loop.pos = 0;         end;      end;      /* if in point loop mode,  the chase logic takes */      /* care of all buffer positioning                */      else do;            new.loop.pos = 0;      end;   end;end Handle.New.Loop.Pos;/* $page - real time loop                                                *//* The following functions are the most time-critical functions          *//* performed by the direct-to-disk software.  Eventually, these          *//* functions might be entirely performed on an interrupt basis so that   *//* they will never be delayed.                                           *//* For now, they are put in this handy procedure so they can be          *//* called from several places.                                           *//* NOTE:  this routine is called when stacking HUMONGOUS cues.  So       *//* don't ever stack a cue within the Real.Time.Loop!                     */Real.Time.Loop: proc PUBLIC;    /* basic real-time routines              */   dcl (i,j,k)       fixed;   dcl (atmp)  (1)   fixed;   /* We are now getting to the meat of this program.  The objective now */   /* is to load the correct data from the disks into poly memory so     */   /* we can then turn on the poly voices.                               */   /* if output is happening, then compute the desired buffer position   */   /* based upon where we are playing now.  If we are not playing        */   /* at the moment, compute the desired buffer position based upon      */   /* where we expect to be starting up next  (i.e at the start of       */   /* the project (by pressing start), or at the start of a cue we       */   /* are trying to trigger (if trig <> 0)                               */   if (output.happening <> 0)   /* if play, trig, loop, or monitor       */   then do;                     /* then compute current buffer position  */                                /* (where poly is playing at the         */                                /* moment) and where we would like to    */                                /* be loading the disk buffers from      */      /* Compute current buffer/prior buffer/next buffer based upon      */      /* where we are playing at the moment:                             */      call get.sync.s#;         /* get current sample we are playing     */      if (now.looping = 0)      /* if playing or triggering              */      or (loop.mode   = 0)      /* or doing point loop                   */      then do;                  /* or monitoring                         */         if COM32(Sync.S#, Next.Buf) >= lw#ieq       /* compute current, */         then do;                                    /* next, and prior  */            call ADD16(shl(buf.len,8), Current.Buf );/* buffer positions */            call ADD16(shl(buf.len,8), Next.Buf    );/* as the poly      */            call ADD16(shl(buf.len,8), Prior.Buf   );/* system is        */         end;                                        /* rolling along.   */         else if COM32(Sync.S#, Current.Buf) = lw#ilt /* bet check for   */         then do;                                     /* backwards       */            call SUB16(shl(buf.len,8), Current.Buf ); /* motion too in   */            call SUB16(shl(buf.len,8), Next.Buf    ); /* case we are     */            call SUB16(shl(buf.len,8), Prior.Buf   ); /* scrubbing       */         end;         current.offs = shr(sync.s#.lsb - current.lsb,8);         /* $page - Set up buffer positions during LOOPED POINT playback */         /* when scrubbing audio,  adjust the   */         /* disk buffers and active rate        */         /* to follow the mouse                 */         /* adjust playback rate to match mouse */         /* if doing looped point playback      */         if now.looping <> 0             /* we now loop.mode = 0 since */         then begin;                     /* we checked it above.       */            dcl distance.to.go  fixed;   /* will holds 1/2 of the number of sectors */                                         /* to go to the destination sample #.      */                                         /* used to adjust 4 track buffer           */                                         /* sizes below.                            */            /* Adjust lod playback rate to track mouse movement */            /* basic chase algorithm:     */            /* we will compute a rate that will take us to the  */            /* desired point in a fixed time interval.  if      */            /* we make this computation continuously,  we       */            /* will exponentially approach the desired point    */            /* See how many samples are between where we are    */            /* now and where the destination sample ist.        */            /* limit to +/- 30000                               */            if enabled.for.envelope.info <> 0           /* send current scrub pos */            then do;                                    /* to SYNCL if needed     */               call SUB32(Sync.S#, Data.S#, Dtd.Scrub); /* by DSP add-on          */               send.scrub.info = 1;            end;            if COM32(Newly.Requested.Loop.S#, Sync.S#) = lw#ilt            then do;               call SUB32(Sync.S#, Newly.Requested.Loop.S#, atmp);               if COM16(30000,atmp) = lw#ilt then i=-30000;               else                               i=-atmp(1);               distance.to.go = (i+255)/512;   /* get sectors, limited to +/- 58, rounded up (towards 0) in this case */            end;            else do;               call SUB32(Newly.Requested.Loop.S#, Sync.S#, atmp);               if COM16(30000,atmp) = lw#ilt then i=+30000;               else                               i=+atmp(1);               distance.to.go = i/512;   /* get sectors, limited to +/- 58, rounded down (towards 0) */            end;                        /* Compute a maximum scrub rate based upon how far we are */            /* from the desired point every time the mouse moves.     */            if (compute.new.scrub.limit <> 0) then do;               /* original method - allow scrub to full rate:         */               if scrub.rate.factor = 0 then do;                  scrub.rate.limit = 4*current.rate;               end;               /* else limit rate to reach desired destination in     */               /* a certain time.  Scrub rate factor is the number    */               /* of hundredths of a second in this time interval.    */               else do;                  j = abs(i);               /* get # of samples to point */                  k = current.rate          /* compute # of samples in   */                    * scrub.rate.factor;    /* S.R.F time interval       */                  if j IGT k                /* if far away, use max      */                  then scrub.rate.limit = 4 * current.rate;                  else do;                  /* else use rate that will   */                     load current.rate*4;   /* reach goal in that time   */                     mul  j; mwait;                     div  k;                     scrub.rate.limit = res;                     if scrub.rate.limit < 10                     then scrub.rate.limit = 10;                  end;                                    /* If we are trying to scrub using the DDSAD (i.e.     */                  /* the project rate is <= 44.1, limit the scrub rate   */                  /* to be 500 Hz. below the crystal rate to assure that */                  /* we do not exceed the xtal rate due to tolerances:   */                  if (creg_avail <> 0)                  &  (scrub.rate.limit > (current.rate*4-1))                  then scrub.rate.limit = (current.rate*4-1);               end;               compute.new.scrub.limit = 0;            end;            /* Original first & second order algorithm */            if scrub.alg.code = 0            then do;               k = dist.time.const;   /* get time const, msec */               if abs(i) ige (125*k) then do;    /* would result in > 100 khz rate */                  if i < 0 then j = -5000;                  else          j = +5000;               end;               else do;                          /* compute desired rate  */                  j = i * 40 / k;                /* 2000 = 50 khz         */               end;               if 0 then do;                /* mouse rate          */                  j = loop.mouse.rate + j;  /* add rates together  */               end;               /* filter rate with 2nd order filter */               i = our.time.lsb - Prior.Rate.Time(1);   /* d16 ticks since we were last here */               call COPY32(Our.Time, Prior.Rate.Time);               k = rate.time.const * d16tim; /* time const in d16 ticks */               if k <> 0 then do;                       /* only filter if time constant <> 0 (0 means instantaneous - no filtering needed) */                  if i ige shr(k,2) then i = shr(k,2);  /* limit to 1/4 of the rate change every loop time */                  i = (j - active.rate) * i / k;        /* delta to adjust rate by */                  if i = 0 then i = 1;                  /* pos numbers round down */                  j = active.rate + i;               end;            end;            /* New algorithm to improve editview sound */            /* Basic algorithm:  measure our software loop time.     */            /* Limit the value to a reasonable range.  Compute the   */            /* desired synth rate that would bring us to the         */            /* destination sample in 2 loop times, 3 loop times,     */            /* etc.                                                  */            else do;               /* Get # of d16 ticks since we were last here         */               k = our.time.lsb - Prior.Rate.Time(1);               call COPY32(Our.Time, Prior.Rate.Time);               /* Get N * # of milliseconds since we were last here: */               load k; mul scrub.chase.factor; mwait; div d16tim; k = res;               /* Limit rate adjustment to a minimum period:         */               if k < dist.time.const               then k = dist.time.const;               if k > 250         /* limit to avoid overflow         */               then k = 250;               /* Compute what rate will bring us to the desired     */               /* point in N main loops:                             */               if abs(i) ige (125*k) then do;    /* would result in > 100 khz rate */                  if i < 0 then j = -5000;                  else          j = +5000;               end;               else do;                          /* compute desired rate  */                  j = i * 40 / k;                /* 2000 = 50 khz         */               end;               /* filter rate with 2nd order filter unless we have        */               /* overshot the desired point                              */               if (j xor active.rate) >= 0       /* if same direction,    */               then do;                          /* then filter           */                  k = j - active.rate;           /* get change in rate    */                  if k <> 0 then do;             /* any needed            */                     k = k * rate.time.const / 1000;                     if k = 0 then do;                        if j < active.rate then k = (-1);                        else                    k = (+1);                     end;                  end;                  j = active.rate + k;               end;            end;            if j<(-scrub.rate.limit) then j = (-scrub.rate.limit);            if j>(+scrub.rate.limit) then j = (+scrub.rate.limit);            /* positive means forwards */            /* handle direction change */            /* carefully               */            if j>=0 then do;                  /* we want to go forward */               if active.rate<0 then do;      /* direction change      */                  call set.lod.hz        (100,0);  /* set to zero phase inc        */                  do i=1 to 2000;             /* wait for pinc = 0     */                  end;                        /* to take effect        */                  call get.sync.s#;           /* get chan.32.last      */                  call Ps_Word_Wave(32,0,shl(buf.len,8),0,shl(buf.len,8),buf.base);                  do i = 1 to 100;            /* wait for enw rate    */                  end;                        /* to be digested       */                  active.rate = 0;            /* active rate of 0 now */               end;               call set.lod.hz        ( j, 1);            end;            else do;                          /* we want to go back */               if active.rate>=0 then do;     /* direction change  */                  call set.lod.hz        (100,0);  /* set to zero phase inc        */                  do i=1 to 2000;             /* wait for pinc = 0 */                  end;                        /* to take effect    */                  call get.sync.s#;           /* get chan.32.last  */                  call Ps_Word_Wave(32,0,shl(buf.len,8),-1,-shl(buf.len,8),buf.base);                  do i = 1 to 100;            /* wait for enw rate */                  end;                        /* to be digested    */                  active.rate = (-1);         /* slowly backwards now */               end;               call set.lod.hz        (-j,-1);  /* backwards        */            end;            active.rate = j;            /* And now set up what data we would like to have buffered */            /* from the disk for point playback.                       */            call COPY32(Current.Buf, Desired.Buf1); /* fill buffer with current buffer      */                                                    /* if possible                          */            call COPY32(Next.Buf,    Desired.Buf2); /* fill buffer 2 with from next segment */            call COPY32(Prior.Buf,   Desired.Buf3); /* fill buffer 3 with data from prior segment */            /* try to keep 1/2 the buffer ahead of us, and 1/2 */            /* the buffer behind us (sounds simple, huh?)      */            /* oops - in 4 tracks/drive config,  must change   */            /* that algorithm to try and get a high data rate  */            /* when going forward/backwards at full speed.     */            /* Algorithm:  choose our desired buffer position  */            /* based up current mouse speed and direction.     */            /* basicall, at > 40 khz forward,  put 100% of     */            /* buffer space in front of us.   if > 40 khz      */            /* backwards,  put all of our buffer space         */            /* behind us.   Use linear scale for sampling      */            /* rates below 40 khz.                             */            if  (tracks.per.port >= 4)            then do;               i = active.rate;     /* get active rate. + 1600 = 40 khz forward */               if i > (+1600) then i = (+1600);               if i < (-1600) then i = (-1600);               /* compute correction factor of up to +/- 1/2 buf.len */               /* to buffer more in front of us at high forward      */               /* speeds,  or more behind us at high rewind speeds   */               j = (i*shr(buf.len,1)/2000);               /* But limit to our destination,  so we can quickly   */               /* detect changes of direction.                       */               if (j xor distance.to.go) < 0   /* if different sign,  then we are observing second order effects right around the */               then j = 0;                     /* sample point.   Leave buffer in place     */               else if abs(j) > abs(distance.to.go)               then j = distance.to.go;               desired.buf1.len  = current.offs + shr(buf.len,1) + j;               desired.buf2.len  = 0;               desired.buf3.len  = 0;            end;            else do;                /* 2 tracks/port - put 50% ahead, 50% behind */               desired.buf1.len  = current.offs + shr(buf.len,1);               desired.buf2.len  = 0;               desired.buf3.len  = 0;            end;            if desired.buf1.len > buf.len  /* put some in buf2 */            then do;               desired.buf2.len = desired.buf1.len - buf.len;               desired.buf1.len = buf.len;            end;            if desired.buf1.len < buf.len /* room for some in buf3 */            then do;               desired.buf3.len = buf.len - desired.buf1.len;            end;         end;         /* $page - set up disk buffer positions during monitoring */         else if now.monitoring <> 0         then do;            /* Note:  these are the exact same buffer */            /* positions that are used when no        */            /* output is being done:                  */            if New.Buffer.Position <> 0                /* new buf pos - load from */            then call COPY32(New.Buf, Desired.Buf1);   /* where we want to        */            else if buffered.msb <> (-1)               /* else if Buffered is     */            then call COPY32(Buffered, Desired.Buf1);  /* good, hang on to it     */            else call STR32( 0, 0, Desired.Buf1);      /* else 0,0                */            call COPY32(Desired.Buf1,   Desired.Buf2);            call ADD16(shl(buf.len,8),  Desired.Buf2);             call COPY32(Desired.Buf1,   Desired.Buf3);            call SUB16(shl(buf.len,8),  Desired.Buf3);            desired.buf1.len  = buf.len;            desired.buf2.len  = 0;                          desired.buf3.len  = 0;         end;         /* Set up desired buffer position for normal     */         /* play and trig output                          */         else do;      /* normal play or triggered output */            call COPY32(Current.Buf, Desired.Buf1); /* fill buffer with current buffer      */                                                    /* if possible                          */            desired.buf1.len  = buf.len;            /* fill it to the rim with BRIM         */            call COPY32(Next.Buf, Desired.Buf2);    /* fill buffer 2 with from next segment */            desired.buf2.len  = current.offs;       /* fill up to current play position     */            call STR32( 0, 0, Desired.Buf3);        /* and don't bother to have */            desired.buf3.len  = 0;            if (Newinfo < 0)          /* if running DDSIN test, read in */            then do;                  /* less data so we can test...    */               i = shr(buf.len,2);    /* get 1/4 of buffer size         */               if current.offs < i    /* if at start of buffer,         */               then do;               /* leave end of buf1 intact       */                  desired.buf1.len = buf.len - (i - current.offs);                  desired.buf2.len = 0;               end;               else do;                  desired.buf2.len = current.offs - i;               end;            end;            if  (Now.Triggering <> 0)              /* if triggering         */            and (Trig.Rate       > 0)              /* at high speed         */            then do;                               /* check for overload    */               i = Scale.For.Trig.Rate(Current.Rate);               if i igt 1000                       /* if > 100 khz asked    */               then do;                            /* for, then compromise  */                  load buf.len; mul 1000; mwait; div i;                  desired.buf1.len = res;          /* fill buf1 part way.   */               end;                                /* then let audio shut   */            end;                                   /* while we go ahead     */         end;                                      /* and fill buff #2      */      end;      /* set up desired buffer contents */      /* for looped audio playback      */      /* (segment loop)                 */      else do;         call COPY32(Current.Buf, Desired.Buf1);    /* fill buffer with current buffer      */                                                    /* if possible                          */         desired.buf1.len  = buf.len;               /* fill it to the rim with BRIM         */         call COPY32(Next.Buf, Desired.Buf2);       /* and other buffers */         call STR32(0, 0, Desired.Buf3);            /* can/should be     */                                                    /* empty             */         desired.buf2.len  = 0;         desired.buf3.len  = 0;      end;      /* Now check for real-time punching in & out.  Also update the     */      /* variables that tell us how much data has been recorded,         */      /* so we can write more to the disk if we are recording.           */      if  (now.playing <> 0)     /* if doing normaly play,  check to     */      and (recd.tracks <> 0)     /* see if we are off the end of project */      and (COM32(Sync.S#,Song.End.S#) >= lw#ieq)      then do;         call log.error('Cannot record past the end of the current project');         recd = 0;               /* Shut off VK recording                */         pnch = 0;         recd.tracks = 0;         Lod.Recd.Tracks     = 0;         Lod.Punch.In.Tracks = 0;      end;      if (now.playing    <> 0)   /* if doing playing or triggering,      */      or (now.triggering <> 0)   /* check various items:                 */      then do;         if  (now.triggering            <> 0)         and (enabled.for.envelope.info <> 0)        /* send current scrub pos */         then do;                                    /* to SYNCL if needed     */            call SUB32(Sync.S#, Data.S#, Dtd.Scrub); /* by DSP add-on          */            send.scrub.info = 1;         end;         if send.scrolling<>0 then do;               /* scroll desired */            call compute.scroll.info;                /* send it        */         end;         /* detect playing past end of armed section */         if  (armed         <> 0)                 /* if armed             */         and ((precd.tracks <> 0)                 /* and recording        */         or   (recrec(recrec.rehearse) <> 0))     /* or rehearsing...     */         and (COM32(Sync.S#, RecRec.Send) >= lw#ieq)         then do;            call clear.armed.info;                    call SUB32(RecRec.Send, RecRec.Sync, Atmp); /* compute accurate end time punch out point */            call ADD32(RecRec.In,   Atmp,        Atmp); /* after rounding in stack.cue               */            if COM32(Atmp, Song.End.S#) >= lw#ieq            then call log.proj.eof.error;         end;         if (precd.tracks<>(recd.tracks\armd.tracks))  /* change in recd.tracks or armed tracks */         or (out.of.sync <>(0                      ))         then do;            do i=0 to max.tracks-1;              /* punch in/out             */               /* check for punch in */               if  ((precd.tracks&bits(i))   =0) /* not recording yet        */               and (out.of.sync              =0)               and (((recd.tracks&bits(i))  <>0) /* if general recording desired */               or   (((armd.tracks&bits(i)) <>0) /* or armed recording desired   */               and   (source.or.cue    (i)  <>0) /* cue has been stacked         */               and   (recrec(recrec.stacked)<>0)               and   (recrec(recrec.rehearse)=0) /* not rehearsing               */               and   (((sync.s#.msb igt recrec(recrec.sync.msb)))  /* and current time is          */               or     ((sync.s#.msb  =  recrec(recrec.sync.msb))   /* within armed range           */               and     (sync.s#.lsb ige recrec(recrec.sync.lsb))))               and   (((sync.s#.msb ilt recrec(recrec.send.msb)))               or     ((sync.s#.msb  =  recrec(recrec.send.msb))               and     (sync.s#.lsb ilt recrec(recrec.send.lsb))))))               and (track.available(i)    <>0) /* track is available       */               and (track.recording(i)     =0) /* not busy from last op    */               then do;                  track.recording  (i)  = 1;         /* now recording      */                  if Synclav.software.version >= 3                  then get.new.motion = get.new.motion \ 2;                  precd.tracks          = precd.tracks or bits(i);                  track.eof        (i)  = 0;         /* may not be at eof  */                  recb.msb         (i)  = current.msb;                  recb.lsb         (i)  = current.lsb;                  rec.s#.msb       (i)  = sync.s#.msb;                  rec.s#.lsb       (i)  = sync.s#.lsb;                  max.s#.msb       (i)  = rec.s#.msb(i);                  max.s#.lsb       (i)  = rec.s#.lsb(i);                  track.punch      (i)  = 1;     /* perform punch-in cross fade            */                  track.plen       (i)  = pwlen; /* save cross fade to simplify punch out  */                  call compute.track.status.display(i);                  call check.sync.point(i,now.playing);               end;               /* check for punch out */               else if ((precd.tracks&bits(i))   <> 0)  /* recording here    */               and     ((out.of.sync             <> 0)  /* out of sync       */               or       (((recd.tracks&bits(i))   = 0)  /* no gen'l recding  */               and       (((armd.tracks&bits(i))  = 0)  /* no arm'd recding  */               or         (source.or.cue     (i)  <>1)  /* or no cue stked?  */               or         (recrec(recrec.stacked) = 0)  /* or gonzo?         */               or         (recrec(recrec.rehearse)<>0)  /* or rehearsing     */               or         (((sync.s#.msb ilt recrec(recrec.sync.msb)))  /* and current time is          */               or          ((sync.s#.msb  =  recrec(recrec.sync.msb))   /* within armed range           */               and          (sync.s#.lsb ilt recrec(recrec.sync.lsb))))               or         (((sync.s#.msb igt recrec(recrec.send.msb)))               or          ((sync.s#.msb  =  recrec(recrec.send.msb))               and          (sync.s#.lsb ige recrec(recrec.send.lsb)))))))               then do;                  precd.tracks      = precd.tracks     xor bits(i);                  punch.out.pending = punch.out.pending \  bits(i);                  track.punch (i) = track.punch(i) or  8; /* start punch out */                  punch.time  (i) = real.milliseconds;    /* set timer       */                  /* if doing armed recording, with sequencer trigger */                  /* then try to punch out exactly at trig stop       */                  if  (source.or.cue      (i)  <>0)    /* if  cue is stacked (etc) */                  and (recrec(recrec.stacked)  <>0)    /* and recording cue is stk */                  and (recrec(recrec.code   )  <>0)    /* sequencer triggering  */                  and (((sync.s#.msb igt recrec(recrec.send.msb)))  /* and we got all the way to the end */                  or   ((sync.s#.msb  =  recrec(recrec.send.msb))                  and   (sync.s#.lsb ige recrec(recrec.send.lsb))))                  then do;                                                     max.s#.msb(i) = recrec(recrec.send.msb);                     max.s#.lsb(i) = recrec(recrec.send.lsb);                  end;                  call compute.track.status.display(i);               end;            end;         end;         do i=0 to max.tracks-1;                    /* check recording */            if  ((precd.tracks&bits(i))<>0)         /* recording here  */            and ((track.punch(i)&(8\16))=0)         /* no punch out    */            and ((track.eof  (i)) =0)               /* not past end    */            then do;                                /* more info       */               max.s#.msb(i) = sync.s#.msb;               max.s#.lsb(i) = sync.s#.lsb;            end;         end;      end;   end;   /* $page - fill buffers while waiting */   /* If we are not playing at the current time,  then fill the disk */   /* buffers with our best guestimate of the data that we will      */   /* need in the near future.                                       */   else do;                    /* no output happening - fill buffer from most recently requested position */      /* sample current d16 time to */      /* keep the msb's happening:  */      call get.d16.time;      /* if new buffer position is pending (for example when we are   */      /* trying to start up at a new location) then that is our       */      /* desired position                                             */      if New.Buffer.Position <> 0                /* new buf pos - load from */      then call COPY32(New.Buf, Current.Buf);    /* where we want to        */      else if buffered.msb <> (-1)               /* else if Buffered is     */      then call COPY32(Buffered, Current.Buf);   /* good, hang on to it     */      else call STR32( 0, 0, Current.Buf);      /* else 0,0                */      current.offs = 0;      call COPY32(Current.Buf,   Next.Buf  );      call ADD16(shl(buf.len,8), Next.Buf  );       call COPY32(Current.Buf,   Prior.Buf );      call SUB16(shl(buf.len,8), Prior.Buf );      call COPY32(Current.Buf, Desired.Buf1);      call COPY32(Next.Buf,    Desired.Buf2);      call COPY32(Prior.Buf,   Desired.Buf3);      if func = 0                        /* fill buffers if not reading */      then desired.buf1.len  = buf.len;  /* data functions.   else      */      else desired.buf1.len  = 0;        /* leave buffers empty.        */      /* Limit attack buffer to 100 sectors long if pre-filling buffers */      /* if we are doing multi-track DDT output.    This makes it       */      /* more likely that the ports will be free so we can start        */      /* the DDT units on time.   If trying to start LOOPING output     */      /* however,  we must allow the buffers to fill all the way.       */      if  ((Dig.Xfer.Mode & (Dig.In \ Dig.Out)) <>  0)  /* if doing ddt */      and ( DDT.Connect.Mode                    <>  0)  /* multi track  */      and ( Loop                                =   0)  /* no scrubbing */      and ( Desired.Buf1.Len                    > 100)  /* then limit   */      then  Desired.Buf1.Len = 100;                     /* buf size     */      desired.buf2.len       = 0;                    desired.buf3.len       = 0;      call get.d16.time;                   /* set up valid info as if    */      call COPY32(Current.Buf, Sync.S#);   /* we called get.sync.s#      */      call STR32 (0, 0, Chan32.S#);        /* so that voice.check        */      call COPY32(Current.Buf, Output.S#); /* can pre-load ddt buffers   */      call COPY32(Current.Buf, DDT.S#   ); /* correctly                  */      active.rate = current.rate*4;        /* set sensible current rate  */   end;   /* $page - Read in DDT input data */   /* The following code reads in the audio data from the DDT */   /* input ports.   the data is stored in the track#         */   /* associated with DDT.In.Track#.                          */   /* Note: Only for 2-track routable DDT                     */   if  ((Dig.Xfer.Mode & (Dig.In\Dig.Dspin)) <> 0) /* if doing DDT input (UDIO or DDSYN) */   and (DDT.Connect.Mode   = 0)        /* from routable unit                */   and ((aux.d24.# <> ddt.d24.#) or (port.io(max.ports) = 0)) /* aux not using UDIO d24 */   and (now.looping        = 0)        /* and not looping                   */   and (new.dtd.song#      = 0)        /* and not trying to change DDT mod  */   and (new.inputs         = 0)        /* and not trying to change routing  */   then call Process.DDT.In(DDT.S#);   /* $page - Real Time Loop (continued) - Voice Check,  Port Check */   if output.happening <> 0   then call get.sync.s#;    /* get latest sync.s# for DOA software */   call voice.check(0, Sync.S#, Our.Time, 1); /* check each voice for turn on     */   /* If data is being read or written from/to the synclavier SCSI bus      it needs to be intercetped here before port.check is called.      Synclavier.SCSI.Check looks at the buffer data structures and      mimicks port.check functions for the Synclavier SCSI bus.   */   if  (syn.scsi.data.xfer <> Sys#off) /* if there is Synclavier SCSI io */   and (dsp.paused         <> 1      ) /* and we can have the SCSI bus   */   then do;      if func = 0 then syn.scsi.data.xfer = Sys#off;      else if poly.buffs.in.use = 0 /* else if no load/backup using poly */      then call Synclavier.SCSI.Check;/* read/write to devices on the Synclavier SCSI bus */   end;   call port.check;              /* check each port for more disk io */end Real.Time.Loop;