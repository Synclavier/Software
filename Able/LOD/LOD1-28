/* lod1-28 - special functions, loop items *//* Modifications:  03/03/92 - cj  - Fixed bug with UDIO-only crashing system  02/11/92 - cj  - allow multi udio to work with DDSYN  09/10/91 - cj  - Fixed bug with UDIO but NO DDSYN configuration  08/14/91 - cj  - Added UDIO/DDSYN stuff  08/20/90 - cj  - added code for 4 wangs/4 pats  10/06/89 - JSS - UDIO nondrop operation workaround for normally drop rates  06/07/89 - cj  - provided "tape medium error" error message  05/16/89 - JSS - Bug fixes to UDIO initialization  04/06/89 - JSS - Added/changed UDIO format & sync source choices  03/23/89 - cj  - fixed Mike Thorne's command stacking bug  03/13/89 - LSS - changed messages that still referred to "songs"  02/09/89 - cj  - fixed AEE bugs with 31.9, 44.0, 47.9, 88.1, 95.9 KHZ   02/22/89 - CJ  - added capabability for new STM (with prm)  07/10/90 - cj  - fixed Multi-track UDIO sync signal bug*//* write updated song/track directory to disk               *//* track.dir.updated is set to a one when the user has changed *//* information in the track directory.    this is only         *//* allowed once a valid track directory has been read in       *//* from the disk.                                              */write.track.dir:proc;   if track.dir.updated=1 then do;        /* change has been made  */      track.dir.to.write=track.info.bits; /* write these tracks    */      track.dir.updated=2;                /* activate write code   */      call add16(1,loc(addr(error.msb))); /* for write.magic       */      return;   end;   if track.dir.to.write = 0              /* if all written ...    */   then do;      track.dir.updated=0;   end;end write.track.dir;write.song.dir:proc;   if song.dir.updated=1 then do;          /* change has been made  */      song.dir.to.write=track.info.bits;   /* write to these tracks */      song.dir.updated=2;                  /* activate write code   */      call add16(1,loc(addr(error.msb)));      return;   end;   if song.dir.to.write = 0                /* if all written ...    */   then do;      song.dir.updated=0;   end;end write.song.dir;/* $page - start process to write cue directory to disk */write.cue.info:proc;   dcl i fixed;   if cue.info.updated=1 then do;          /* change has been made  */      cue.info.to.write=track.info.bits;   /* write to these tracks */      cue.info.updated=2;                  /* activate write code   */      do i=0 to max.tracks-1;         cue.write.sec#(i)=0;         cue.prior.sec#(i)=0;         cue.prior.ctr (i)=0;      end;      return;   end;   if cue.info.to.write = 0   then do;      cue.info.updated=0;   end;end write.cue.info;/* $page - misc subroutines for main loop *//* when the user calls up a new song,  we must *//* compute some new global information         */look.up.new.song.info:proc swapable;   dcl (i,j) fixed;   dcl rate.lookup data (505,1010,500,1000,500,500,500,500,500,500);   dcl format.info      fixed;   dcl sync.info        fixed;   dcl first.box        fixed;   dcl first.in         fixed;   dcl first.out        fixed;   dcl clock.mast.box   boolean;   dcl rev#             fixed;   dcl external_default_sync lit '-1';   /* Look-up tables to map AEE DDT switches to hardware literals: */   /* These switches must match the switch settings in the Audio   */   /* Event Editor which are:                                      */   /* Format: ProDigi 2 Track  Output Sync: Internal               */   /*         ProDigi Multi                 External Default       */   /*         SDIF 2 Track                  NTSC B+W               */   /*         SDIF Multi                    NTSC Color             */   /*         AES/EBU                       PAL/SECAM              */   /*         S/PDIF                        Ext ProDigi 2 Track    */   /*                                       Ext ProDigi Multi      */   /*                                       Ext SDIF               */   /*                                       Ext AES/EBU or S/PDIF  */   dcl format   data (ProDigi_2, ProDigi_M, SDIF_2_16Bit,                       SDIF_M_16bit, AES_16Bit, SPDIF);   dcl formsync data (ProDigi_2_In_Sync, ProDigi_M_In_Sync,                      SDIF_In_Sync, SDIF_In_Sync, AES_In_Sync, AES_In_Sync);   dcl sync     data (Internal_Sync, external_default_sync,                      House_Sync_30, House_Sync_29, House_Sync_25,                      Prodigi_2_In_Sync, ProDigi_M_In_Sync,                      SDIF_In_Sync, AES_In_Sync);   call clear.armed.info;      /* dis-arm recording/rehears on song change */     recrec.is.stacked = 0;      /* no arm pending                           */   /* wait for any recording to finish so we don't accidentally start      */   /* start writing to the new project if we were recording.               */   if Any.Track.Actually.Recording    /* wait for recording to finish */   then return;                       /* before changing song         */   /* Also wait for any output to stop as well                        */   if output.happening <> 0           /* wait for all output to stop  */   then return;                       /* as well                      */   /* Look up new song in time/out time before waiting for track      */   /* directory to avoid mike thorne's stacking bug                   */   call song.lookup;                  /* look up info              */   if compute.bounds(Song.Data,Song.Length)<>0   /* compute disk bounds       */   then call log.error('Warning: Project End Time is Before Start Time');   call ADD32(Song.Data, Song.Length, Song.Ending);   call COPY32(Song.Data,    Song.Data.S#);   call SHL32 (Song.Data.S#, 8           );   call COPY32(Song.Ending,  Song.End.S# );   call SHL32 (Song.End.S#,  8           );   /* Now wait for new track directory so we can set the correct      */   /* direction for the universal UDIO boxes.                         */   if track.dir.valid = 0             /* wait for track directory so  */   then return;                       /* we can set box direction     */   /* Must make sure all ports are free before changing projects      */   /* so we can initialize the MULTI-Track DDT units.                 */   do j=0 to max.ports-1;             /* soo if port is busy          */      if  (port.available(j)<>0)      /* if port is avail             */      and (port.io       (j)<>0)      /* and doing  IO                */      and (DDT.Connect.Mode <>0)      /* and we need to connect       */      then return;   end;   if  (aux.d24.# = ddt.d24.#)    and (port.io(max.ports) <> 0)      /* wait for aux tape to         */   then return;                       /* finish up before changing    */                                      /* songs so we can re-init      */                                      /* UDIO DDT box.                */   /* look up new user dig xfer mode here,  after all playback has */   /* stopped:                                                     */   if New.Dig.Xfer.Mode   = 0         /* detect un-initialized     */   then New.Dig.Xfer.Mode = Dig.Off;  /* variables                 */   Dig.Xfer.Mode = New.Dig.Xfer.Mode;   if ((Dig.Xfer.Mode & (Dig.In\Dig.Out)) <> 0)   or ( DDT.DDSYN.Avail                   =  0)   then do;      DDT.Lun# = DDT.UDIO.Lun#;      rev#     = DDT.UDIO.Rev#;		#if (inc.multi.udio)				  /* multi udio included	  	 */			if DDT.MULTI.Avail <> 0			then DDT.Connect.Mode = 1;			else DDT.Connect.Mode = 0;		#endif   end;   else do;                           /* might be using DDSYN      */      DDT.Lun# = DDT.DDSYN.Lun#;      /* set up for possible       */      rev#     = DDT.DDSYN.Rev#;      /* clocking                  */				#if (inc.multi.udio)				  /* multi udio included	    */     		DDT.Connect.Mode = 0;        /* access via D24            */		#endif		      /* Force tracking of DDSYN clock even if we are not doing    */      /* any DDYSYN input (assumes that DSP option is there...)    */      if  (DDT.DDSYN.Avail           <> 0) /* if ddsyn is avail    */      and (enabled.for.envelope.info <> 0) /* and dsp option there */      and (DDT.Use.DDSYN             <> 0) /* and should sync to   */      then Dig.Xfer.Mode = Dig.Xfer.Mode \ Dig.Forcedsp;   end;   if s.rate<10 then do;              /* debug rates < 1.0 khz */      s.rate    = rate.lookup(s.rate);      Sync.Mode = 0;   end;   else do;      if (Dig.Xfer.Mode & (Dig.In \ Dig.Out \ Dig.Forcedsp)) <> 0   /* if doing dig xfer */      then Sync.Mode = 2;             /* then use word clock   */      else Sync.Mode = 1;             /* else use D3/Poly      */   end;   current.rate  =  s.rate;   /* get new sample rate     */   /* Warn UDIO user of invalid sample rates with UDIO in   */   /* output direction and internal sync (UDIO lacks XTALs) */   /* WARNING: This test works with 2-track only!           */   /* Modification required to work with multitrack UDIO.   */   if  ((Dig.Xfer.Mode & Dig.Out) <> 0)   /* if doing UDIO output      */   and (Internal_Sync = Sync (DDT.Sync))  /* with internal sync source */   and ((current.rate = 319)              /* and rate is unsupported   */   or   (current.rate = 479)   or   (current.rate = 959))   then call Log.Error('Sampling rate is incompatible with UDIO output and internal sync');   /* Handle drop frome rates correctly */   if  (current.rate = 319)   /* if rate is 31.9 khz     */   or  (current.rate = 440)   /* or 44.0 khz             */   or  (current.rate = 479)   /* OR 47.9 KHZ             */   or  (current.rate = 881)   /* OR 88.1 KHZ             */   or  (current.rate = 959)   /* OR 95.9 KHZ             */   then do;      current.rate = current.rate + 1;  /* make LOD see 32, 44.1, 48, 88.2, 96 (UDIO sees drop frame rate) */      apply.drop.frame.correction = 1;  /* apply 2997/3000 correction    */   end;   /* Handle these funny rates for nondrop operation at sample rates */                             /* normally used with drop frame SMPTE (ie, 31.97, 44.056, 47.95, */   /* 88.11, 95.90 kHz).                                             */   /* Note: this is a workaround; the correct way to do this would   */   /* be to have an additional SMPTE mode.                           */   else if  (current.rate = 321)    /* if rate is 32.1 khz     */   or       (current.rate = 442)    /* or 44.2 khz             */   or       (current.rate = 481)    /* OR 48.1 KHZ             */   or       (current.rate = 883)    /* OR 88.3 KHZ             */   or       (current.rate = 961)    /* OR 96.1 KHZ             */   then do;                                                       current.rate = current.rate - 1;     /* make LOD see 32, 44.1, 48, 88.2, 96 */      s.rate = s.rate - 1;                 /* make UDIO see 32, 44.1, 48, 88.2, 96 */      apply.drop.frame.correction = (-1);  /* apply 3000/2997 correction */        end;   else do;      apply.drop.frame.correction = 0;  /* else no correction to apply */   end;   /* Warn UDIO user if sample rate is invalid with UDIO */   if ((Dig.Xfer.Mode & (Dig.In \ Dig.Out)) <> 0)   /* if doing dig xfer */   and (current.rate <> 320)         /* check for sensible sampling rate */   and (current.rate <> 441)   and (current.rate <> 480)   and (current.rate <> 882)   and (current.rate <> 960)   then call Log.Error('Warning: Sampling rate is incompatible with digital I/O');   /* Warn DSP user if sample rate is invalid with DDIOC */   if ((Dig.Xfer.Mode & (Dig.Dspin \ Dig.Forcedsp)) <> 0)   /* if doing dig xfer */   and (current.rate <> 320)         /* check for sensible sampling rate */   and (current.rate <> 441)   and (current.rate <> 480)   and (current.rate <> 500)   then call Log.Error('Warning: Sampling rate is incompatible DSP option');   do i=0 to max.tracks-1;    /* indicate attack buffers */      zap.buffer(i) = 1;      track.eof(i)  = 0;                  adir.ptr (i)  = i*adir.len;   end;   /* compute mark start sample # from mark start time */   call compute.mark.start.point(loc(addr(mark.button.msb)),mark.button.acu,1,Mark.Button.S#);   call Add16  (127, Mark.Button.S#);    /* round up to new sector boundary */   call ROUND32(Mark.Button.S#);   call set.new.play.buffer.position;    /* load new buffers now            */   loop.buf.len = s.rate*2;            /* # of samples in 20 msec */   loop.buf.len = (loop.buf.len+(256+127))&"177400"; /* include 1 extra sector for cross fade data */   /* must have min of 768 words  */   /* 256 of preamble (not included in the 20 msec looping segment) */   /* 256 of plain data (give us time to switch base regs)          */   /* 256 words of cross fade info                                  */   if loop.buf.len < 768 then loop.buf.len = 768;   if loop.buf.len > shl(loop.maxl,8) then loop.buf.len = shl(loop.maxl,8);   if (Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Bounce\Dig.Dspin)) <> 0 /* if doing digital transfer,  then must not */   then do;                    /* super long cross fades                    */      if   s.fade IGT 50      then s.fade  =  50;      /* must be <= 50 milliseconds                */   end;   pwlen=s.fade*s.rate/10;             /* samples in cross fade  */   if pwlen ilt 5 then pwlen=5;        /* limit to avoid math    */   pmsec=s.fade*25;                    /* # of 40 micsec periods */   if pmsec=0 then pmsec=1;   if pmsec igt 4095 then pmsec=4095;   load 4095; div pmsec; pmsec=res;    /* interpolator delta     */   if subsystem.ready<>0 then do;      /* set up chan 32 at correct rate   */      call Initialize.Channel.32.For.LOD.Playback;   end;   new.dtd.song#=0;                    /* done with new song info       */   /* Set up triggered output buffer and delay sizes based upon         */   /* sampling rate.                                                    */   /* Higher sampling rates need larger disk read sizes to get the      */   /* bandwidth up.   Larger disk read sizes need longer pre-trigger    */   /* delay so machine has time to read data from both tracks           */   trig.chunk =  25 + 100*Current.Rate/1000; /*  75 sectors @ 50  khz   */                                             /* 125 sectors @ 100 khz   */   trig.delay = 200 + 200*Current.Rate/1000; /* 300 msecs @ 50 khz      */                                             /* 400 msecs @ 100 khz     */   if (Dig.Xfer.Mode & Dig.Out) <> 0         /* add extra delay if      */   then do;                                  /* doing ddt output.       */      if DDT.Connect.Mode = 0                /* 50 msecs for routing    */      then trig.delay = trig.delay +  50;    /* type                    */      else trig.delay = trig.delay + 500;    /* else long for multitrk  */   end;   /* compute # of samples in 75 msecs to provide 75 msec delay         */   /* for DDT input monitoring.  use longer delays if punch-in fades    */   /* are > 5 milliseconds                                              */   i = 65 + (2*s.fade);    /* compute monitoring delay, milliseconds */   if i < 75 then i = 75;  /* min of 75 milliseconds                 */   ddt.monitor.delay = (current.rate * i / 10) & "177400";  /* get delay samples */   /* set new inputs set, etc. when track directory finally */   /* arrives.  see there in port.io.  if track dir is      */   /* already valid (ie just changing sample rate, not      */   /* changing songs)  do housekeeping here                 */   if track.dir.valid <> 0                      /* if track dir is valid now (happens when changing */   then do;                                     /* sample rates, for example) update AEE now.       */      new.inputs   =1;                          /* now get inputs going       */      get.new.motion=get.new.motion\1;          /* get new motion info        */      if Synclav.software.version >= 3          /* update screen */      then get.new.motion = get.new.motion \ 4; /* on aee        */      if output.happening = 0      then call set.new.play.buffer.position;   /* load new buffers now     */   end;   if  ((((command.#=c.eraseall)       /* if one of the erase			*/   or     (command.#=c.eraselng)			/* commands							*/   or     (command.#=c.erase4tr)   or     (command.#=c.format  ))   and   (abort.command=0       )      /* not aborted yet            */   and   (erase1=9876)                 /* double check               */   and   (erase2=5432))                /* do it                      */	or   ((command.#=c.dismount)			/* or a dismount...				*/   and   (abort.command=0     )))   then do;      subsystem.ready = 0;             /* re-start system init       */      initialize      = 1;             /* from top                   */				if (command.# == c.format)			/* for format, try to			*/		{											/* preserve current config by	*/			if      (longconfig(0) == 1)	/* checking track 0 config		*/			then eraselong=1;						else if (longconfig(0) == 2)			then eraselong=2;						else eraselong=0;						erase1 = 3456;			erase2 = 5432;			format.drives = 1;		}				else if (command.# == c.dismount)		{			dismount.drives = 1;		}				else		{			erase1 = 3456;			erase2 = 5432;				if      (command.#=c.eraselng)			then eraselong=1;			else if (command.#=c.erase4tr)			then eraselong=2;			else eraselong=0;		}		      call init.song.dir;      call init.track.dir;      track.dir.updated  = 0;    /* clear these variables so */      track.dir.to.write = 0;    /* that we do not try to    */      song.dir.updated   = 0;    /* write any information    */      song.dir.to.write  = 0;    /* to the disks after       */      write.alt.tdir     = 0;    /* the erase all has        */      alt.tdir.tracks    = 0;    /* complete.   Problem got  */      track.dir.valid    = 0;    /* compounded when Erase    */      cue.info.updated   = 0;    /* All would generate       */      cue.info.to.write  = 0;    /* fewer tracks.            */      write.magic.tracks = 0;      command.#          = 0;   end;   else do;      /* re-look up cue directory for current song */      /* after changing  projects                  */      local.transfer:proc(type,cstype);         dcl type   fixed;         dcl cstype fixed;         dcl i      fixed;         num.of(cstype)=0;         do i=0 to num.of(type)-1;            if get.sort.cue(type,i) <> 0 then do;               call read.basic.cue(cue.sec# + cue.sec, cue.wrd, current.cue);               if cue.is.in.current.song(current.cue) then do;                  call write.store(sort.base(cstype),num.of(cstype));                  write(md) = cc.alloc#;                  num.of(cstype) = num.of(cstype)+1;               end;            end;         end;      end local.transfer;      call local.transfer(alph.sort,cs.alph.sort);      call local.transfer(time.sort,cs.time.sort);      call local.transfer(smpt.sort,cs.smpt.sort);   end;   /* Set up DDT Hardware for this sample rate */   /* Look up and set DDT.Mode depending on */   /* what mode the user desires:           */   /* Dig.Xfer.Clock.Port holds the port# of the DDT unit that is used */   /* to control the syncing.   On other cases it holds a -1.          */   dig.xfer.clock.port = (-1);            /* set to -1 unless used     */   first.box           = (-1);            /* find first box            */   first.in            = (-1);            /* first in box              */   first.out           = (-1);            /* first out box             */   DDT.Good.Word.Clk   = 0;               /* no word clocks yet        */   DDT.In.Sync         = 0;               /* not in sync yet           */   if DDT.Hardware.Avail <> 0   then do;      /* If dedicated hardware available,  then initialize it */      if DDT.Connect.Mode = 0   /* If 2-track routable DDT on D24 #1 */      then do;         if (Dig.Xfer.Mode & (Dig.In\Dig.Dspin\Dig.Forcedsp)) <> 0         then DDT.Mode = FE_Dir_In;         /* handle input         */         else DDT.Mode = FE_Dir_Out;        /* else send out        */         format.info = Format(DDT.Format);         sync.info   = Sync  (DDT.Sync  );         /* Use sync source corresponding to format if "External      */         /* Default" Output Sync switch position was chosen by user   */         /* or if going In.                                           */         if  (DDT.Mode  = FE_Dir_In)              /* if doing input   */         or  (sync.info = external_default_sync)  /* or generic 'EXT' */         then sync.info = formsync(DDT.Format);         /* Setup the DDT unit for this sample rate, direction, format, */         /* & sync source, plus to be Sys Clock, Go, and Group master.  */         call Initialize.DDT.Unit(rev#, S.Rate, DDT.Mode,                                  format.info, sync.info,                                  1,1,1);      end;      /* Else loop over ports and initialize DDT unit connected */      /* to each port (multitrack UDIO case).                   */      else do;  /* Setup for multitrack case */						#if (inc.multi.udio)					/* multi udio included	    */				/* PASS 1 through all ports:                                 */				/*   Find first UDIO unit set up for INPUT, if there is one, */				/*   so that later we can assign the System Clock Master.    */				do i = 0 to max.ports-1;         /* for each potential box:  */					if  (Port.Available(i) <> 0)  /* if there's a port  */					and (Port.DDT      (i) <> 0)  /* and there's a UDIO */					and look.up.port.ddt.direction(i) /* and it's set to INPUT */					and first.in = (-1) /* and the FIRST input box we've found */					then do;						first.in = i;  /* then make note of it. */					end;				end;					/* PASS 2 through all ports:       */				/*   To initialize all UDIO units  */				do i = 0 to max.ports-1;  /* Initialize UDIO on each port */					if  (Port.Available(i) <> 0)					and (Port.DDT      (i) <> 0)					then do;						if first.box = (-1)    /* find first box  */						then first.box = i;    /* in system       */							/* Set the direction for this box.   Set the box going in */						/* if the track is ready or the mode is INPUT.            */							if look.up.port.ddt.direction(i)						then Port.DDT.Mode(i) = FE_Dir_In;						else Port.DDT.Mode(i) = FE_Dir_Out;							call quickly.select.port(i);							DDT.Mode = Port.DDT.Mode(i);   /* look up mode */							format.info = Format(DDT.Format);						sync.info   = Sync  (DDT.Sync  );							/* Use sync source corresponding to format if "External     */						/* Default" Output Sync switch position was chosen by user  */						/* or if going In.                                          */						if  (DDT.Mode  = FE_Dir_In)             /* if doing input   */						or  (sync.info = external_default_sync) /* or generic 'EXT' */						then sync.info = formsync(DDT.Format);							if  (DDT.Mode = FE_Dir_Out)   /* if doing output */						then do;							if first.out = (-1)        /* first output box? */							then do;								first.out = i;          /* Yes, indicate it. */							end;						end;							/* Determine if THIS box is the System Clock Master.     */						/* If there is an INPUT box then if THIS box is the      */						/* input box, it is the Clock Master.  Otherwise the top */						/* box is the System Clock Master.                       */							clock.mast.box = false;						if first.in <> (-1)            /* If there is an INPUT box */						then do;                       /* and */							if (i = first.in)           /* if this IS the INPUT box  */							then clock.mast.box = true; /* Then make it clock master */						end;						else if i = first.box       /* Otherwise make first box */						then clock.mast.box = true; /* clock master.            */							call Initialize.DDT.Unit(Port.DDT.rev# (i), S.Rate, DDT.Mode,														 format.info, sync.info,	/* Group 1 for IN boxes, 0 for out. */  (shl(DDT.Mode = FE_Dir_in, 8)	/* Group masters are first          */   \ (i = first.in )	/* in box & first out box.          */   \ (i = first.out)),														 i = first.box,   /* first box is go master */														 clock.mast.box); /* clock master */							/* Set up for scanning of Sync information from */						/* first available DDT box.                     */							if (Dig.Xfer.Mode & (Dig.In \ Dig.Out)) <> 0   /* if doing DDT input or output */						then do;								if dig.xfer.clock.port   = (-1)  /* save away first port# */							then do;									dig.xfer.clock.port = i;      /* with DDT unit         */									disable;								call get.d16.time;            /* get d16 time          */								dig.xfer.clock.value = Read.Selected.DDT.Word.Clock;  /* get word clock      */								enable;									dig.xfer.clock.time   = Our.Time.Lsb;								dig.xfer.clock.pvalue = dig.xfer.clock.value;								dig.xfer.clock.ptime  = dig.xfer.clock.time;								dig.xfer.clock.rate   = Current.Rate * 50;   /* samples in .5 second */								end;						end;							call deselect(i);               /* disconnect from port 	 */					end;										  /* of port exists       	 */         	end;   										  /* init UDIO on each port */			#endif      		end;   /* init in multitrack case */      Dig.Xfer.Go.Master = first.box;          /* save away port# of first */                                               /* box to use as go master  */   end;  /* init DDT hardware */   /* reset all contents variables for the ddt so we   */   /* reload any and all data on a project change      */   do i = 0 to max.ddts-1;       /* reset variables for each ddt port */      ddt.zeroed   (i) = 0;      /* indicate buffer is not zeroes     */      ddt.zero.ptr (i) = 0;      ddt.zero.ctr (i) = 0;      ddt.base.msb (i) = 0;      ddt.base.lsb (i) = 0;      ddt.next.msb (i) = 0;      ddt.next.lsb (i) = 0;   end;end look.up.new.song.info;/* $page - set up new input routings */dcl prior.motherboard.bits fixed;setup.new.input.routes:proc swap;   dcl input.used(15)  fixed static;  /* Note:  all variables must be */   dcl boxbits         fixed static;  /* static since this procedure  */   dcl chancount       fixed static;  /* is re-entered                */   dcl local.t#        fixed static;   dcl local.s#        fixed static;   dcl (i,j,k,l)       fixed static;   dcl (srr)           fixed static;   dcl (sou)           fixed static;   /* We must wait for all recording to stop before re-routing */   /* inputs.   Otherwise we would get clicks and pops on      */   /* the disk                                                 */   if  any.track.actually.recording<>0   /* wait for all recording to stop */   then return;   do case (new.inputs-1);               /* check state            */      do;                                /* wait for all input     */         do i = 0 to max.voices-1;       /* voices to be turned    */            if (chan.on(i)&4) <> 0       /* off.   Happens in      */            then return;                 /* voice.check when       */         end;                            /* new.inputs <> 0        */         new.inputs = new.inputs + 1;      end;      do;                                /* now turn off all       */         do i = 0 to max.tracks-1;       /* rec.chans (stm chans). */            if  (track.available(i) <> 0)   /* the rec.chans are   */            and (rec.chan.on    (i) <> 0)   /* turned off after    */            then call turn.off.rec.chan(i); /* the input voices    */         end;                               /* so we don't get     */         new.inputs = new.inputs + 1;       /* clicks and pops     */      end;      do;                          /* now initialize ADC */         call ad_init;             /* in case someone is */         new.inputs=new.inputs+1;  /* plugging the unit  */      end;                         /* in                 */      do;                          /* clear maxchan      */         call ps_maxchan(0,1);     /* give it time to    */         new.inputs=new.inputs+1;  /* take effect        */      end;               /* now loop over voice assignments,  check for conflicts  */      /* and set up input routings:                             */      do;                                         write(psc)=0;                            write(psf)=psnumv;         prior.motherboard.bits = read(psd);         if (read(psd)&"200")<>0         then do;            if current.rate >=501            then call ps_setmode(1);  /* 100 khz sampling */            else call ps_setmode(0);  /*  50 khz sampling */         end;         do i=0 to 15;                /* init input.used  */            input.used(i)=0;         end;         do i = 0 to max.ddts - 1;    /* init DDT input routing */            ddt.in.track# (i) = 0;    /* to all off             */            ddt.bounce.trk(i) = 0;    /* and digital bouncing   */            ddt.bounce.sou(i) = 0;    /* to not happening       */         end;         boxbits=0; chancount=0;      /* init synth info  */         do i=0 to max.tracks-1;      /* set up inputs    */            /* initialize to assume this track does not share an */            /* input.   If it does,  then we must re-compute the */            /* input routings whenever this track changes its      */            /* safe/ready status                                   */            this.track.shares.an.input(i) = 0;            if  (track.available(i) <> 0)     /* if track is available     */            and (func = 0)                    /* and not reading data      */            and ((buf.size.in.use <= buf.len) /* and either enough buffer  */            or   (command.#       = 0       ))/* for cdc, or no command.#  */            then do;               /* if we had been sampling into a track, then mark */               /* track.sampling to fill buffer with zeroes if an */               /* input is no longer assigned for this track      */               if track.sampling(i)<>0                     then track.sampling(i)= (-1);                           j   = track.dir(i*track.len+track.input)    ;  /* get source (upper half), input (0-x, lower half) */               k   = track.dir(i*track.len+track.gain )    ;  /* gain 10=1.0                */               srr = track.dir(i*track.len+track.stat )&255;  /* 0=safe  1 = ready   2 = locked */               sou = shr(j,8);           /* get source Id:         */               j   = j & 255;            /*    0 = STM             */                                         /*    1 = DIG             */                                         /*    2 = OUT             */                                         /*    3 = TRK             */               if sou > 3 then do;       /* system error           */                  call log.error('System Error with Input Routing');               end;               /* branch on input type to set up routing */               else if sou = 0               then do;               /* handle STM routing     */                  if j > 16 then do;  /* system error           */                     call log.error('System Error with Input Routing');                  end;                  else if j <> 0 then do;  /* i.e. 0-15             */                     j=j-1;                /* get easier form       */                     /* check input for 100 khz if using no prm     */   /* THE FORMAT OF THE RETURNED WORD IS AS FOLLOWS:      BIT  15:    1=NEW SAFES, 0=OLD SAFES      BIT  14:    1=PRM THERE, 0=PRM NOT THERE      BITS 13-11: NUMBER OF BOXES (0-4)      BITS 10-8:  UNUSED      BIT   7:    SET IF 2ND SAFE IN BOX 3 IS THERE      BIT   6:    SET IF 1ST SAFE IN BOX 3 IS THERE      BIT   5:    SET IF 2ND SAFE IN BOX 2 IS THERE      BIT   4:    SET IF 1ST SAFE IN BOX 2 IS THERE      BIT   3:    SET IF 2ND SAFE IN BOX 1 IS THERE      BIT   2:    SET IF 1ST SAFE IN BOX 1 IS THERE      BIT   1:    SET IF 2ND SAFE IN BOX 0 IS THERE      BIT   0:    SET IF 1ST SAFE IN BOX 0 IS THERE   */                     if   ( current.rate         >= 501) /* >= 50.1 khz */                     and  ((adconfig & "040000") =  0  ) /* no PRM      */                     then do;                   /* 100 khz mode         */                        l=(j&1)\shr(j&"14",1);  /* get index number  */                        if (j&2)<>0             /* inputs 2,3 6,7    */                        then do;                /* 10,11  14,15      */                           if log.buf(0)=0 then do;     /* are not available */                              call log.error('Input '); /* at 100 khz        */                              call append.input.number(j+1);                              call append.log.string(' is Not Available above 50 Khz');                              j=(-1);                           end;                        end;                        else if (adconfig&bits(l))=0                        then do;                           if log.buf(0)=0 then do;                              call log.error('Input ');                              call append.input.number(j+1);                              call append.log.string(' is Not Installed in System');                              j=(-1);                           end;                        end;                     end;                     /* check input for 50 khz (no prm), or all rates */                     /* with new prm                                  */                     else do;               /* check input for 50 khz */                        if (adconfig&bits(shr(j,1)))=0                        then do;                           if log.buf(0)=0 then do;                              call log.error('Input ');                              call append.input.number(j+1);                              call append.log.string(' is Not Installed in System');                              j=(-1);                           end;                        end;                     end;                     /* if specified input is available, then */                     /* plan to use it for this input:        */                     if j>=0 then do;          /* use it */                        if Input.Used(j)<>0    /* if this input is used by another track */                        then do;               /* then check for priority                */                           this.track.shares.an.input(i) = 1;                           this.track.shares.an.input((Input.Used(j)&255)-1) = 1;                           if  (srr=1)                     /* if this track is ready */                           and ((Input.Used(j)&256)<>0)    /* and competing track was also ready */                           then do;            /* input is shared by two ready tracks - give error */                              if log.buf(0)=0 then do;                                 call log.error('Input ');                                 call append.input.number(j+1);                                 call append.log.string(' Is routed to several tracks');                              end;                           end;                           else if srr=1 then do; /* switch to this track if it is ready and other is not */                              Input.Used(j)=256 + i + 1;     /* save track #          */                              if   ( current.rate         >= 501) /* >= 50.1 khz */                              and  ((adconfig & "040000") =  0  ) /* no PRM      */                              then do;               /* 100 khz mode          */                                 if j then l=j+1;    /* comput bit for box    */                                 else      l=j;      /* to arm channel        */                              end;                              else do;                                 l=j;                              end;                              call ps_gain(l,k);     /* set gain              */                           end;                           else do;                              /* nothing - competing track was ready and we are not - leave input assigned to competing track */                           end;                        end;                        /* assign input channel to this track */                        /* if there is no competing track:    */                        else do;                           Input.Used(j)=i+1;     /* save track #          */                           if srr=1 then Input.Used(j)=Input.Used(j)\256;  /* set bit if actually ready */                           if   ( current.rate         >= 501) /* >= 50.1 khz */                           and  ((adconfig & "040000") =  0  ) /* no PRM      */                           then do;               /* 100 khz mode          */                              if j then l=j+1;    /* comput bit for box    */                              else      l=j;      /* to arm channel        */                           end;                           else do;                              l=j;                           end;                           boxbits=boxbits\bits(l);                           chancount=chancount+1;                           call ps_gain(l,k);     /* set gain              */                        end;    /* of input not shared */                     end;       /* of input available  */                  end;          /* of input specified  */               end;             /* of STM   routing    */               /* $page - handle DIG input routing     */               else if (sou              =  1) /* if source is DIG           */               and     ((Dig.Xfer.Mode & (Dig.In\Dig.Dspin)) <> 0) /* and DIG IN or DSP IN selected        */               and     (DDT.Connect.Mode =  0) /* routable only              */               and     (j                <> 0) /* and channel # is specified */               then do;                        /* then handle DIG routing    */                  if j > Max.DDTS                  then do;                     if log.buf(0)=0 then do;                        call log.error('Digital Input ');                         call append.decimal.number(j);                        call append.log.string(' is not available');                     end;                  end;                  /* else handle digital input routing of channel */                  /* j to track i                                 */                  else do;                     j=j-1;                /* get easier form       */                     /* see if this digital input is shared by      */                     /* another channel.   if so,   determine       */                     /* priority by seeing which track is           */                     /* ready                                       */                     if DDT.In.Track#(j)<>0                       then do;                                       /* mark both tracks as sharing an input     */                        /* so that the inputs will be recomputed    */                        /* when safe/ready changes                  */                        this.track.shares.an.input(i) = 1;                        this.track.shares.an.input((DDT.In.Track#(j)&255)) = 1;                        if  (srr=1)                     /* if this track is ready */                        and ((DDT.In.Track#(j)&512)<>0) /* and competing track was also ready */                        then do;                        /* input is shared by two ready tracks - give error */                           if log.buf(0)=0 then do;                              call log.error('Digital Input ');                              call append.decimal.number(j+1);                              call append.log.string(' is routed to several tracks');                           end;                        end;                        else if srr=1 then do; /* switch to this track if it is ready and other is not */                           DDT.In.Track#(j)=512 + 256 + i;  /* save track #          */                        end;                        else do;                           /* nothing - competing track was ready and we are not - leave input assigned to competing track */                        end;                     end;                     /* else if this digital input is free,  assign */                     /* it to this track if there is no competition */                     else do;                        DDT.In.Track#(j)=256 + i;     /* save track #          */                        if srr=1 then DDT.In.Track#(j)=DDT.In.Track#(j)\512;  /* set bit if actually ready */                     end;                  end;          /* of valid routing    */               end;             /* of DIG   routing    */               /* Handle Multi-track DDT routing: */               else if (sou                      =  1) /* if source is DIG           */               and     ((Dig.Xfer.Mode & Dig.In) <> 0) /* and DIG IN selected        */               and     (DDT.Connect.Mode         <> 0) /* multi-track hardware       */               then do;                     /* then handle DIG routing    */						#if (inc.multi.udio)		  /* multi udio included	  	  */							if  ( port.available(track.port.ix(i)) <> 0)							and ( port.ddt      (track.port.ix(i)) <> 0)							and ((port.ddt.mode (track.port.ix(i)) & FE_Dir_In) <> 0)							then do;								track.sampling(i)   = 4; /* mark as doing multi-ddt in */								track.ddt.zeroed(i) = 1; /* input buffer zeroed below  */							end;						#endif               end;               /* $page - handle OUT or TRK input routing     */               else if ((sou           =  2)  /* if source is OUT or TRK    */               or       (sou           =  3))               and     ((Dig.Xfer.Mode & Dig.Bounce) <> 0) /* and BOUNCE selected        */               and     ( j             <> 0 ) /* and channel # is specified */               then do;                       /* then handle DIG routing    */                  if  (sou = 2)                        /* OUT is selected    */                  and ((j > (PolyNumv - Base.Voice#))  /* but does not exist */                  or   (j > Max.Voices              )) /* or can not be used */                  then do;                     if log.buf(0)=0 then do;                        call log.error('Output ');                         call append.decimal.number(j);                        call append.log.string(' is not available for BOUNCE');                     end;                  end;                  else if  ( sou                  = 3          ) /* TRK      */                  and      ((j                    > Max.Tracks)  /* oops     */                  or        (track.available(j-1) = 0         )) /* not avl. */                  then do;                     if log.buf(0)=0 then do;                        call log.error('Track ');                         call append.decimal.number(j);                        call append.log.string(' is not available for BOUNCE');                     end;                  end;                  /* else handle digital bounce of OUT or TRK j   */                  /* to track i                                   */                  else do;                     j=j-1;                /* get easier form       */                     if sou = 2 then k = 512 + j;  /* 512 + voice#  */                     else            k = 256 + j;  /* 256 + track#  */                     /* see if this voice/track   is shared by      */                     /* another track.     if so,   determine       */                     /* priority by seeing which track is           */                     /* ready                                       */                     l = 0;                     do while (l                 <  Max.DDTs)                     and      (DDT.Bounce.Sou(l) <> k       );                        l = l + 1;                     end;                     if l < Max.DDTs    /* if this track/voice is  */                     then do;           /* being bounced 2 places  */                        /* mark both tracks as sharing an input     */                        /* so that the inputs will be recomputed    */                        /* when safe/ready changes                  */                        this.track.shares.an.input(i) = 1;                        this.track.shares.an.input((DDT.Bounce.Trk(l)&255)) = 1;                        if  (srr=1)                      /* if this track is ready */                        and ((DDT.Bounce.Trk(l)&512)<>0) /* and competing track was also ready */                        then do;                         /* input is shared by two ready tracks - give error */                           if log.buf(0)=0 then do;                              if sou = 2                              then call log.error('Output ');                              else call log.error('Track ');                              call append.decimal.number(j+1);                              call append.log.string(' cannot be bounced to more than 1 track at once');                           end;                        end;                        else if srr=1 then do; /* switch to this track if it is ready and other is not */                           DDT.Bounce.Trk(l)=512 + 256 + i;  /* save dest track #          */                           DDT.Bounce.Sou(l)=k;              /* save src  track/voice      */                        end;                        else do;                           /* nothing - competing track was ready and we are not - leave input assigned to competing track */                        end;                     end;                     /* else if this track/voice is not being       */                     /* bounced anywhere,  then do so               */                     else do;                        /* find free "logical" ddt routing channel: */                        l = 0;                        do while (l                 <  Max.DDTs)                        and      (DDT.Bounce.Sou(l) <> 0       );                           l = l + 1;                        end;                        /* only two tracks can be bounced at a time: */                        if l >= Max.DDTs                        then do;                           if log.buf(0)=0 then do;                              call log.error('Only two tracks can be bounced at any one time');                           end;                        end;                        else do;                           DDT.Bounce.Trk(l) = 256 + i;  /* save dest track #          */                           DDT.Bounce.Sou(l) = k;        /* save src  track/voice      */                           if srr=1 then DDT.Bounce.Trk(l)=DDT.Bounce.Trk(l)\512;  /* set bit if actually ready */                        end;                     end;       /* of no conflict      */                  end;          /* of valid routing    */               end;             /* of BOUNCE           */            end;                /* of track avail      */         end;                   /* of loop over tracks */         /* $page - set channel active bits for STM inputs */         do i=0 to 3;        /* check boxes         */            if (adconfig&(bits(i*2)\bits(i*2+1)))<>0            then do;         /* box exists          */               write(psc)=0;             /* make sure motherboard          */               write(psf)=psnumv;               if (read(psd)&"200")<>0               then do;                  write(psc)=shl(i,2);   /* channel # = box # */                  write(psf)=psadact;                  write(psd)=boxbits&"17";               end;            end;            boxbits=shr(boxbits,4);         end;         call ps_maxchan(chancount,1);         /* compute voice numbers */         /* set up track.sampling and track.rvoice# so that */         /* voice.check can turn on the channels:           */         chancount = 0;         do i=0 to 15;            j=input.used(i)&255;            if j<>0 then do;               track.rvoice# (j-1) = chancount;               track.sampling(j-1) = 1;               chancount = chancount+1;            end;         end;         /* mark track.sampling for DDT inputs, or BOUNCE */         do i = 0 to max.ddts-1;            if ddt.in.track#(i) <> 0            then do;               j = ddt.in.track#(i)&255; /* get track #                    */               track.rvoice# (j) = i;    /* save ddt#                      */               track.sampling(j) = 2;    /* mark track.sampling            */            end;            if ddt.bounce.trk(i) <> 0            then do;               j = ddt.bounce.trk(i)&255; /* get track #                    */               track.rvoice# (j) = i;     /* save ddt#                      */               track.sampling(j) = 3;     /* mark track.sampling            */            end;         end;         new.inputs=new.inputs+1;                  local.t#=0;         local.s#=0;      end;      /* $page - zero out input buffer when turning off input routings: */      do;         /* Zero out any input buffers that either:                     */         /*    A) had been assigned to a source before but are not      */         /*       now                                                   */         /* or B) has a DDT input assigned                              */         /* or C) is the destination track # for a digital bounce       */         if  (func <> 0)                   /* if function reading        */         or  ((buf.size.in.use > buf.len)  /* or need input buffer       */         and  (command.#       <> 0     )) /* for load/backup            */         then do;            new.inputs = new.inputs + 1;   /* then do not glom what      */            return;                        /* might be in poly.          */         end;         if (track.sampling(local.t#) = (-1))  /* was sampling, but not now */         or (track.sampling(local.t#) >= 2  )  /* or doing ddt/bounce       */         then do;            j=buf.len-local.s#;    /* zero out up throu end of record buffer */            if j>32 then j=32;     /* limit to 32                  */            call psmwrite(compute.base.adr(local.t#)+buf.base+rec.base+local.s#, 0);            do i=0 to j-1;               rpc 256;               write(psd) = 0;            end;            local.s#=local.s#+j;   /* count sectors                */            if local.s#=buf.len    /* done with this track         */            then do;               if   track.sampling(local.t#) = (-1)               then track.sampling(local.t#) = ( 0);               local.s#=0;               local.t#=local.t#+1;            end;         end;         else local.t#=local.t#+1;         if local.t#=max.tracks       /* see if done with all tracks */         then do;            new.inputs = new.inputs + 1;         end;      end;      do;                              /* now turn on rec channels to */         do i=0 to max.tracks-1;       /* start the stm box sampling. */            if  (track.available(i) <> 0)  /* if track is available   */            and (track.sampling (i) =  1)  /* and has an adc assigned */            then do;               call turn.on.rec.chan(i);   /* then give him one       */            end;         end;         /* initialize variables to start DDT input process */         call Initialize.For.DDT.Input;         /* if doing bounce,  then re-initialize all DDT buffer */         /* contents variables:                                 */         if (Dig.Xfer.Mode & Dig.Bounce) <> 0     /* indicate that all   */         then do i = 0 to max.ddts-1;             /* bounce destination  */            ddt.on    (i) = 0;                    /* buffers contain     */            ddt.zeroed(i) = 1;                    /* the zeroes above    */         end;         new.inputs = new.inputs + 1;      end;      /* Done with processing of new input assignments: */      do;         new.inputs = 0;         get.new.motion = get.new.motion \ 1;   /* get new motion info */      end;   end;                               /* of do case        */end setup.new.input.routes;/* $page - start background commands */get.next.command:proc swapable;   dcl (i)            fixed;   dcl (command.code) fixed;   dcl command.uses.tapes data (1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1);	/* c.max	*/   dcl command.uses.atdir data (1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1);	/* c.max	*/   dcl command.uses.disk  data (1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1);	/* c.max	*/   /* look up command #: */   command.#      = command.stack(command.out  );   /* get command code   */   command.song   = command.stack(command.out+1);   /*             song # */   command.tracks = command.stack(command.out+2);   /*             tracks */   command.code   = command.stack(command.out+3);   /*             code   */   command.tracks = command.tracks & track.avail.bits;   /* initialize command.track# to start with first track on this port */   do i = 0 to max.ports;      command.track#  (i) = port.base.track(i);      this.buf.in.use (i) = 0;   end;   do i=0 to max.tracks-1;          /* clear status error reporting so */      track.command(i) = 0;         /* we can give a better message    */      track.status (i) = 0;   end;	if ((any.drives.sleeping            != 0)		/* if a sleep command has been processed and	*/	&&  (command.uses.disk(command.#-1) != 0))	/* this command uses the disks, substitute	*/	{															/* a spin command here...							*/		command.#      = c.spin;		command.song   = -1;		command.tracks = -1;		command.code   = 0;			command.tracks = command.tracks & track.avail.bits;	}     else if  (command.#<>c.lall    )			/* if not one of the all commands  */   and      (command.#<>c.aall    )			/* remove it from stack.  Leave    */   and      (command.#<>c.verfall )			/* all commands on the stack...	  */   and      (command.#<>c.skipfall)   then do;		command.out = command.out+command.stride;		if command.# = c.bounce then do;			do i=0 to bounce.mix.rec.len-1;				bounce.mix.rec(i) = command.stack(command.out+i);			end;			command.out = command.out + bounce.mix.rec.len;		end;		if command.in=command.out		then do;			command.in=0;			command.out=0;		end;   end;     else do;                                       /* keep lall on stack   */      if command.song<>(num.songs-1)              /* golden dubloon award */      then command.song=command.song+1;           /* increment to 0 first */      command.stack(command.out+1)=command.song;  /* time thru            */   end;   /* Look up info about start and end of song from song directory */   /* in case it has been modified by other commands.              */   do case (command.code);      do;                             /* 0: command does not use song info */         call STR32(0, 0, C.Data);         call STR32(0, 0, C.Len );      end;      do;                             /* 1: get song start & end           */         s.start = gsong.dir(command.song*song.len+song.start);         s.end   = gsong.dir(command.song*song.len+song.end  );         call compute.bounds(C.Data, C.Len);      end;      do;                             /* get cue retake info               */         call COPY32(Cue.Retake.Start, C.Data);         call COPY32(Cue.Retake.Len  , C.Len );      end;   end;   call compute.c.info;          /* get c.end, c.data.s#, etc.             */   command.completed     =0;     /* initialize important */   command.fatal         =0;     /* command variables    */   command.aborted       =0;   alt.tdir.valid        =0;   alt.tdir.needed       =command.uses.atdir(command.#-1);   errmess               =0;   readybits             =0;     /* used by backup       */   emptybits             =0;     /* and load for         */   dumpedbits            =0;     /* user optimize        */   bouncedbits           =0;   deadtapes             =0;   notloadedtapes        =0;   dirloaded             =0;   eotreached            =0;   songread              =0;   trackswap             =0;   onetapeloaded         =0;   updatetime            =real.milliseconds+5000;   any.cues.deleted      =0;   poly.buffs.in.use     =0;   tape.verify.error     =0;   buf.size.in.use       =buf.len;   skipped.song (0)      =0;   active.tape.config    =0;   interrogatedtapes     =0;   auxinterrogated       =0;   tapetouse             =0;   skipverify            =0;   /* interrogate for tapes at start of command if there is an aux */   /* tape on the D24 #1 or if there is both a tape1 and a tape2   */   /* any any port (including max.ports!)                          */   interrogate.tapes = ((port.available(max.ports) | (any.tape2.found))                        & command.uses.tapes(command.#-1));   do i=0 to max.ports;        /* initialize tape state    */      tape.state     (i) = 0;  /* zero out tape state      */      tape.to.use    (i) = 0;  /* init to ldrive 0         */      tape.condition (i) = 0;  /* init to no cart in       */   end;   call mark.stars;         /* set * or +               */   if abort.command<>0      /* check for abort received after    */   then do;                 /* command was stacked but before    */      command.tracks   =0;  /* command was started               */      command.completed=1;      command.aborted  =1;      erase1=0;             /* stop imminent erase all           */      erase2=0;   end;   else if (command.#=c.eraseall)        or (command.#=c.eraselng)        or (command.#=c.erase4tr)        or (command.#=c.dismount)        or (command.#=c.format  )   then do;      new.dtd.song#=1;      /* stop all I/O to perform erase all.  Note that these commands	*/   end;							 /* are processed after the song directory is read in...				*/   else if command.tracks=0    /* tracks have disappeared after erase long */   then do;      command.completed=1;      command.aborted  =1;      call log.error('Specified Tracks are No Longer Available');   end;end get.next.command;