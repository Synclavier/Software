/* Test program for in-system DDT testing *//* 06/23/88 - cj - for rev # 0 mitsubishi boards *//* System literals needed: *//* MULTIPLY DIVIDE LITERALS: */DCL D16   LIT '"16"';DCL LOAD  LIT 'WRITE(5)=';             /* LOAD         */DCL ULOAD LIT 'WRITE(4)=';             /* LOAD UPPER   */DCL REM   LIT 'READ(4)'  ;             /* QUOTIENT REMAINDER               */DCL MUL   LIT 'WRITE(6)=';DCL DIV   LIT 'WRITE(7)=';  DCL RES   LIT 'READ(5)'  ;             /* RESULT       */DCL URES  LIT 'READ(4)'  ;             /* UPPER RESULT */DCL MWAIT LIT 'WRITE("324")=RES';      /* D5 TO ATNV TO WAIT FOR MUL/DIV *//* REPEAT COUNTER: */  DCL RPC   LIT 'WRITE("010")=(-1)+';dcl scsibits data (256,512,1024,2048);dcl bits     data (1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768);dcl (misc.buf) (256)       fixed;insert ':-xpl:scsilits';/* Page - literals & device codes for Direct Digital Transfer Hardware *//* Literals for control bits for Direct Digital Transfer Hardware */dcl (DDT.Connect.Mode)    lit '0';     /* 0: connect thru D24     */                                       /* 1: connect thru D24/BMC */dcl (DDT.D24.#)           lit '1';     /* D24 connected to D24    */dcl (DDT.Hardware.Avail)  fixed;       /* true if DDT avail       */dcl (DDT.Hardware.Rev# )  fixed;       /* revision code           */dcl (DDT.LUN#)            lit '"40"';  /* LUN number of DDT       */dcl (DDT.Mode)            fixed;       /* Holds bits to be        */                                       /* written to Front End    */                                       /* Command Byte.           */                                       /*                         */                                       /* 0 = output              */                                       /* 1 = input               */                                       /* 2 = go bit              *//* For SCSI Command Byte:      */dcl SCSI_dir_in      lit '"H01"'; /* Bit 0 set; Direction: FE => Mem => SCSI */dcl SCSI_dir_out     lit '"H00"'; /* Bit 0   0; Direction: SCSI => Mem => FE */dcl SCSI_go          lit '"H02"'; /* Bit 1 set; SCSI or FE go operation */dcl SCSI_track_A     lit '"H00"'; /* Bit 2   0; Sets track A */dcl SCSI_track_B     lit '"H04"'; /* Bit 2 set; Sets track B */dcl SCSI_target_mode lit '"H20"'; /* Bit 5 set; SCSI DMA mode = target */dcl SCSI_cmd_byte    lit '"H00"'; /* No bits set; indicates SCSI command byte */dcl SCSI_loc_ad_next lit '"H10"';  /* Bit 4 set; requests that next write will be to Local Address byte *//* For Front End Command Byte: */dcl FE_dir_In        lit '"H01"'; /* Bit 0 set; Direction: FE => Mem => SCSI */dcl FE_dir_Out       lit '"H00"'; /* Bit 0   0; Direction: FE => SCSI => MEM */dcl FE_go            lit '"H02"'; /* Bit 1 set; SCSI or FE go operation */dcl FE_cmd_byte      lit '"H80"'; /* Bit 7 set; indicates mem/FE command byte */dcl FE_loc_ad_next   lit '"H10"'; /* Bit 4 set; requests that next write will be to Local Address byte */    /* For Local Address Byte:     */dcl LAD_loc_ad_next   lit '"H10"'; /* Bit 4 set; requests that next write will be to Local Address byte */dcl LAD_Read          lit '"H80"'; /* bit 7 set; for read                      */dcl LAD_Write         lit '"H00"'; /* bit 7   0; for write                     */    /* Local Addresses of Addressable registers: */dcl LAD_Scsi_Front_End_A       lit '"H00"';    /* channel A output latch             */dcl LAD_Scsi_Front_End_B       lit '"H01"';    /* channel B output latch             */dcl LAD_Scsi_Address_Pointer   lit '"H04"';    /* read/write Scsi Address Pointer    */dcl LAD_Scsi_DMA_Length        lit '"H05"';    /* scsi transfer length (target only) */dcl LAD_FE_Address_Pointer     lit '"H06"';    /* read/write FE address pointer      */dcl LAD_FE_Word_Clock          lit '"H07"';    /* front end word clock               *//* For Mitsubishi Front End Control Byte:  */dcl LAD_FE_Control_Byte  lit '"H08"';  /* Local Address 8 = Fropnt End Control Byte */   dcl FECB_reset        lit '"H00"';  /* Bit 3   0; reset FE modes and clocks      */   dcl FECB_no_FE_reset  lit '"H08"';  /* Bit 3 set; Don't reset FE modes and clocks */   dcl FECB_clock_441    lit '"H28"';  /* Bit 5, 3 set; 44.1 Khz clock rate/unReset */   dcl FECB_clock_480    lit '"H48"';  /* Bit 6, 3 set; 48.0 Khz clock rate/unReset */   dcl FECB_clock_960    lit '"H88"';  /* Bit 7, 3 set; 96.0 Khz clock rate/unReset */       dcl LAD_Revision_#       lit '"H0F"';  /* revision code *//* $page - Special routines for DDT Hardware Module                 *//* These routines provide convenient access to the DDT hardware     *//* Connect to DDT Hardware: *//* note: routine should not enable & disable since we are sometimes *//* called with interrupts off                                       */select.d24:proc(d24.#);          /* set up for a d24 usage */   dcl d24.#    fixed;   /* select d24 # */   write(ScsiSel ) = S$SelectEnable \ Scsibits (d24.#);   write(ScsiData) = 0;   write(ScsiBus ) = 0;end select.d24;DDT.connect: proc;      dcl lun      fixed;   dcl i        fixed;   /* Connect to DDT through dedicated D24 board: */   if DDT.Connect.Mode = 0 then do;      call select.d24(DDT.D24.#);          /* set up for a d24 usage       */      write(ScsiData) = bits(0);           /* target 0                     */      write(ScsiBus ) = S$SEL;             /* gnd SEL                      */      do i = 0 to 1; end;                  /* short delay                  */      write(ScsiBus ) = S$SEL \ S$BSY;     /* create our own busy          */      do i = 0 to 1; end;                  /* short delay                  */      write(ScsiData) = 0;                 /* clear data bus               */      write(ScsiBus ) = S$BSY;             /* remove SEL                   */      write(ScsiBus ) = S$BSY \ S$REQ;           /* create our own REQ     */      write(ScsiData) = DDT.Lun#;                /* this is DDT lun#       */      write(ScsiBus ) = S$BSY \ S$REQ \ S$ACK;   /* and ACK         */      write(ScsiBus ) = S$BSY \         S$ACK;   /* remove REQ      */      write(ScsiBus ) = S$BSY;                   /* remove ACK      */      write(ScsiData) = 0;                 /* remove lun# from data lines  */      write(ScsiBus ) = 0;                 /* remove fabricated busy       */   end;   else do;      /* DDT connected to buffer memory card - not implemented yet */   end;end DDT.connect;/* $page - Procedures to read and write registers in DDT Hardware *//* Read.DDT.Register performs two functions:      1.  It writes the global variable DDT.MODE out to the Front End          Command Byte.    Bits must be set in this word to set the          direction (in or out) and Front End Go.      2.  It reads the specified register and returns that          as the procedure value */Read.DDT.Register: proc(reg#);   dcl reg# fixed;   /* pass register ID code */   call DDT.Connect;   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next \ DDT.Mode;   write(ScsiByte) = LAD_Read    \ reg#;   return read(ScsiWord);end Read.DDT.Register;/* Write.DDT.Register also performs two functions:      1.  It writes the global variable DDT.MODE out to the Front End          Command Byte.    Bits must be set in this word to set the          direction (in or out) and Front End Go.      2.  It writes the passed value the specified register. */Write.DDT.Register: proc(reg#, val);   dcl reg# fixed;   /* pass register ID code */   dcl val  fixed;   /* and value to write    */   call DDT.Connect;   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next    \ DDT.Mode;   write(ScsiByte) = LAD_Write   \ reg#;   write(ScsiWord) = val;end Write.DDT.Register;/* Convenient routines to get at registers */Read.DDT.Word.Clock: proc;   return Read.DDT.Register(LAD_FE_Word_Clock);end Read.DDT.Word.Clock;Read.DDT.Front.End.Address.Pointer: proc;   return Read.DDT.Register(LAD_FE_Address_Pointer);end Read.DDT.Front.End.Address.Pointer;Set.DDT.Front.End.Address.Pointer: proc (val);   dcl val fixed;    /* value to write to front end address pointer */   call Write.DDT.Register(LAD_FE_Address_Pointer, val);end Set.DDT.Front.End.Address.Pointer;/* $page - routines to transfer data to/from DDT Buffer Memory *//* Procedure to start transfer to or from DDT */Start.DDT.Read: proc(chan#, address, #wrds);   dcl chan#   fixed;    /* channel, 0 or 1               */   dcl address fixed;    /* address in buffer             */   dcl #wrds   fixed;    /* # of words to transfer        */   call DDT.Connect;   write(ScsiByte) = SCSI_Cmd_Byte                    \ SCSI_Target_Mode                    \ shl(chan#,2)                   \ SCSI_go                   \ SCSI_dir_in;   write(ScsiWord) = address;   write(ScsiWord) = not(#wrds)-1;end Start.DDT.Read;Start.DDT.Write: proc(chan#, address, #wrds);   dcl chan#   fixed;    /* channel, 0 or 1               */   dcl address fixed;    /* address in buffer             */   dcl #wrds   fixed;    /* # of words to transfer        */   call DDT.Connect;   write(ScsiByte) = SCSI_Cmd_Byte                    \ SCSI_Target_Mode                    \ shl(chan#,2)                   \ SCSI_go                   \ SCSI_dir_out;   write(ScsiWord) = address;   write(ScsiWord) = not(#wrds);end Start.DDT.Write;/* Procedure to provide ramp up or ramp down to data in        *//* Scsi DDT Buffer Memory                                      *//* Construct.DDT.Ramp.In:  this procedure constructs a short ramp *//* up of data in the DDT buffer memory                            *//* it is passed a channel #,  and address in the buffer memory    *//* to start the ramp up at                                        *//* code is simplified because buffer is 64K words long            */Construct.DDT.Ramp.In: proc(chan#, address);   dcl chan#     fixed;   /* ddt channel #       */   dcl address   fixed;   /* where in buffer     */   dcl (accum  ) fixed;   dcl (i,j    ) fixed;   accum = 1024;                      /* for 32 word fade in */   call Start.DDT.Read(chan#, address, 32);                                      /* into misc.buf             */   write("313")=addr(misc.buf(0));   rpc 32;                            /* read in data              */   write("373")=read(ScsiWord);       /* data to ramp in           */   call Start.DDT.Write(chan#, address, 32);   write("313")=addr(misc.buf(0));   do i=0 to 31;      load (read("373") xor "100000");   /* get orig data element    */      mul accum;                         /* fade in - start small    */      j=ures;                       load "100000";                     /* get offset binary 0      */      mul -accum;                             accum=accum+2048;                        write(ScsiWord) = (j+ures) xor "100000";   end;end Construct.DDT.Ramp.In;/* Construct.DDT.Ramp.Out:  this procedure constructs a short ramp *//* down of data in the DDT buffer memory                           *//* it is passed a channel #,  and address in the buffer memory    *//* to END the ramp down at                                        *//* code is simplified because buffer is 64K words long            *//* Note:   The address passed to this routine is the address of   *//* the first sample AFTER the end of the ramp down.   This        *//* is generally the most convenient address to compute.           *//* The ramp down is constructed prior to the address passed,      *//* so that digital zeroes (or the next audio segment with a       *//* ramp up) can be written starting at the passed address         */Construct.DDT.Ramp.Out: proc(chan#, address);   dcl chan#     fixed;   /* ddt channel #       */   dcl address   fixed;   /* where in buffer     */   dcl (accum  ) fixed;   dcl (i,j    ) fixed;   address = address - 32;        /* 32 word fade         */   accum = -1024;                 /* for 32 word fade out */   call Start.DDT.Read(chan#, address, 32);                                      /* into misc.buf             */   write("313")=addr(misc.buf(0));   rpc 32;                            /* read in data              */   write("373")=read(ScsiWord);       /* data to ramp down         */   call Start.DDT.Write(chan#, address, 32);   write("313")=addr(misc.buf(0));   do i=0 to 31;      load (read("373") xor "100000");   /* get orig data element    */      mul accum;                         /* fade out - start big     */      j=ures;                       load "100000";                     /* get offset binary 0      */      mul -accum;                             accum=accum-2048;                  /* decrement cross fade     */      write(ScsiWord) = (j+ures) xor "100000";   end;end Construct.DDT.Ramp.Out;/* $page - begin of test program *//* first see if DDT is there */dcl (i,j,k,l,m,n,errors) fixed;dcl (a,b,c,d,e,f       ) fixed;dcl (x,y,z             ) fixed;print;print;print 'Start of DDT In-System Test.';print;if DDT.Connect.Mode = 0              /* Connect thru D24 only    */then do;   DDT.Hardware.Avail = 0;           /* assume hardware not avil */   write(ScsiSel) = S$SelectEnable \ Scsibits (DDT.d24.#);  /* select d24 to DDT subsystem */   if (read(ScsiSel) & Scsibits(DDT.d24.#)) = 0 then do;      print 'Error - D24 # ',DDT.D24.#,' is not in system.';      stop;   end;   write(ScsiBus)  = S$RST;   do i = 1 to 1000; end;   write(ScsiBus)  = 0;   write(ScsiData) = 0;   if  ((read(ScsiBus )&S$BusMask )<>0)          /* make sure idle    */   or  ((read(ScsiData)&S$DataMask)<>0)   then do;      print 'Error - Could not reset DDT D24';      stop;   end;   else do;      print 'Ok: DDT D24 located in system';      call DDT.Connect;                 /* connect to DDT           */      do i=1 to 10; end;                /* short delay              */      if (read(ScsiBus)&S$BSY) = 0     /* if not Busy, then is not there   */      then do;         print 'Error: DDT Board did not respond to LUN # ',ddt.lun#;         stop;      end;      DDT.Hardware.Avail = 1;       write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next;      write(ScsiByte) = LAD_Read \ LAD_Revision_#;      DDT.Hardware.Rev# = Read(ScsiByte);      print 'ok: DDT Hardware Avail, rev ',DDT.Hardware.Rev#;   end;end;/* Set up DDT Hardware for this sample rate *//* Look up and set DDT.Mode depending on *//* what mode the user desires:           */print;print 'Initializing DDT board and clock...';DDT.Mode = FE_Dir_Out;      /* initialize to out direction */call DDT.Connect;           /* connect to DDT              *//* Issue reset to board and set up desired *//* clock rate: (48 KHZ)                    */write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next \ DDT.Mode;write(ScsiByte) = LAD_Write \ LAD_Loc_Ad_Next \ LAD_FE_Control_Byte;write(ScsiByte) = FECB_Reset;   /* active low reset    */write(ScsiByte) = LAD_Write \ LAD_Loc_Ad_Next \ LAD_FE_Control_Byte;write(ScsiByte) = FECB_No_FE_Reset;write(ScsiByte) = LAD_Write                   \ LAD_FE_Control_Byte;write(ScsiByte) = FECB_No_FE_Reset \ FECB_Clock_480;/* zero out front end registers so output data is *//* digital zeroes for now                         */call Write.DDT.Register(LAD_Scsi_Front_End_A, 0);call Write.DDT.Register(LAD_Scsi_Front_End_B, 0);print;print 'Initializing SCSI output buffer to ramp wave ...';/* Fill memory with incrementing numbers for write */i = 0;do j = 0 to 31;   call Start.DDT.Write (0, shl(j,11), 2048);   do k = 0 to 2047;      write(ScsiWord) = i;      i = i + 1;   end;   i = i - 2048;   call Start.DDT.Write (1, shl(j,11), 2048);   do k = 0 to 2047;      write(ScsiWord) = -i;      i = i + 1;   end;end;print 'Beginning test of D3 clock in DTD';print 'Terminal should beep once per second for the next 10 seconds...';write(3) = 0;write(3) = 0;do i = 0 to 9;   do j = 0 to 199;      write(3) = 0;   end;   print '',;end;print;/* Turn on the GO bit for the following test: */DDT.Mode = DDT.Mode \ FE_Go;        /* set go bit          */call Read.DDT.Word.Clock;           /* set it this way     */PRINT;PRINT 'Beginning High Speed Word Clock/Front End Address Test';print '   (Test takes 2 minutes)';print ;disable;                            /* ints off for this test */i = Read.DDT.Word.Clock;                /* get current value  */a = Read.DDT.Front.End.Address.Pointer; /* fap as well        */x = read(d16);                          /* get d16            */j = 0;do while j <> 200*120;              /* test for 2 minutes     */   k = Read.DDT.Word.Clock;                /* get word clock  */   b = Read.DDT.Front.End.Address.Pointer; /* fap as well     */   y = read(d16);                          /* get d16         */   /* compute how many samples should have gone by in loop time */   /* depend on 10 microsecond d16 rate                         */   /* 48 khz = 20.833 microseconds per sample.  d16 = 10 microseconds */   load 10000; mul (y - x); mwait; div 20833; z = res;   if z >= 5 then do;   /* check if should have had 5 samples */      l = k - i;                       /* get how many increments occurred */                                       /* in loop time                    */      c = b - a;                       /* for fap as well                 */      if l < (z-2)      or l > (z+2)      or c < (z-2)      or c > (z+2)      then do;         m = Read.DDT.Word.Clock;                 /* perform second read     */         d = Read.DDT.Front.End.Address.Pointer;  /* fap as well             */         if l < (z-2)         or l > (z+2)         then do;            print;            print 'Error with DDT Word Clock:';            print '   Test #:                ',j;            print '   Prior value was:       ',i;            print '   ',int((y-x)*10),' mcsecs later';            print '   New   value was:       ',k;            print '   Should have been:      ',i + z;            print '   Second read produced:  ',m;            print '   Was off by:            ',k - (i+z);         end;         if c < (z-2)         or c > (z+2)         then do;            print;            print 'Error with Front End Address Pointer';            print '   Test #:                ',j;            print '   Prior value was:       ',a;            print '   ',int((y-x)*10),' mcsecs later';            print '   New   value was:       ',b;            print '   Should have been:      ',a + z;            print '   Second read produced:  ',d;            print '   Was off by:            ',b - (a+z);         end;         if errors <> (-1) then errors = errors + 1;         k = Read.DDT.Word.Clock;            /* reset for next test */         b = Read.DDT.Front.End.Address.Pointer;         y = read(d16);      end;      i = k;   /* save prior values for next */      a = b;   /* test                       */      x = y;      if read(3) <> 0      then do;         write(3) = 0;         j = j + 1;                             /* count tests */      end;   end;end;PRINT;PRINT 'Beginning word clock and front end address pointer test';print '   (Test takes 5 minutes)';print ;write(3) = 0; write(3) = 0;         /* sync to d3 clock       */i = Read.DDT.Word.Clock;                /* get current value  */a = Read.DDT.Front.End.Address.Pointer; /* fap as well        */j = 0;do while j <> 65000;                 /* test 65000 word clocks */   write(3) = 0;                    /* wait 5 milliseconds    */   k = Read.DDT.Word.Clock;                /* get word clock  */   b = Read.DDT.Front.End.Address.Pointer; /* fap as well     */   l = k - i;                       /* get how many increments occurred */                                    /* in 5.000 milliseconds   */   c = b - a;                       /* for fap as well         */   /* should be precisely 240 word clocks in 5 milliseconds to */   /* achieve 48 khz.   Allow +/- .5 percent error             */   if l < 238   or l > 242   or c < 238   or c > 242   then do;      m = Read.DDT.Word.Clock;                 /* perform second read     */      d = Read.DDT.Front.End.Address.Pointer;  /* fap as well             */      if l < 238      or l > 242      then do;         print;         print 'Error with DDT Word Clock:';         print '   Test #:                ',j;         print '   Prior value was:       ',i;         print '   5 milliseconds later   ';         print '   New   value was:       ',k;         print '   Should have been:      ',i + 240;         print '   Second read produced:  ',m;         print '   Was off by:            ',k - (i+240);         print '   Rate was:              ',200*(k-i)/1000;      end;      if c < 238      or c > 242      then do;         print;         print 'Error with Front End Address Pointer';         print '   Test #:                ',j;         print '   Prior value was:       ',a;         print '   5 milliseconds later   ';         print '   New   value was:       ',b;         print '   Should have been:      ',a + 240;         print '   Second read produced:  ',d;         print '   Was off by:            ',b - (a+240);         print '   Rate was:              ',200*(b-a)/1000;      end;      if errors <> (-1) then errors = errors + 1;      write(3) = 0;                       /* re-sync to clock   */      write(3) = 0;      k = Read.DDT.Word.Clock;            /* reset for next test */      b = Read.DDT.Front.End.Address.Pointer;   end;   i = k;   /* save prior values for next */   a = b;   /* test                       */   j = j + 1;                             /* count tests */end;print 'Word Clock Test Completed.   Errors: ',errors;/* turn off GO bit */DDT.Mode = DDT.Mode & (not(FE_Go));call Read.DDT.Word.Clock;           /* set it this way     *//* reset so digital zeroes go out */call Write.DDT.Register(LAD_Scsi_Front_End_A, 0);call Write.DDT.Register(LAD_Scsi_Front_End_B, 0);print ;print 'End of DDT test.';stop;