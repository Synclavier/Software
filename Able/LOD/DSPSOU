/* DSPSOU - Module for DSP, TSM, WAVE DISPLAY *//* 09/07/89 - sjs - fixed stereo cue bug (not doing right channel) *//* 03/06/89 - sjs - fixed .tsmdata bug in Move.DSP.Data */module dspmod;   insert ':-xpl:scsilits';   insert ':lod:lodlits:globlits'; /* get glob literals                */   insert ':lod:lodlits:dbuglits'; /* get dbug literals                */   insert ':lod:lodlits:xmemlits'; /* literals for xmem allocation     */   insert ':lod:lodlits:polylits'; /* literals for poly synth          */   insert ':lod:lodlits:cuelits';  /* literals for cue storage         */   insert ':lod:lodlits:initlits'; /* literals for init/SCSI           */   insert ':lod:lodlits:stacklit'; /* literals for real time cue stk   */   insert ':lod:lodlits:dsplits';  /* literals for DSP items           */   insert ':lod:lodmods:miscdcl';  /* get misc routines                */   insert ':lod:lodmods:dbugdcl';  /* debug routines                   */   insert ':lod:lodmods:polydcl';  /* poly synth routines              */   insert ':lod:lodmods:cuedcl';   /* basic cue routines               */   insert ':lod:lodmods:initdcl';  /* scsi variables                   */   insert ':lod:lodmods:stackdcl'; /* real time cue stack              */dcl calculating.compressed fixed PUBLIC;     /* state of generating wave display   */dcl (comp.start) (1)       fixed PUBLIC;     /* Start of whole cue to compress */dcl (comp.end)   (1)       fixed PUBLIC;     /* End of whole cue */dcl (comp.len)   (1)       fixed PUBLIC;     /* Length of whole cue (samples) */dcl (comp.here)  (1)       fixed PUBLIC;     /* Where we are currently reading */dcl (comp.prior) (1)       fixed PUBLIC;     /* prior sample # for pixel       */dcl (comp.words)           fixed PUBLIC;     /* Resulting size in words after compress */dcl (comp.ratio)           fixed PUBLIC;     /* No. of samples that go into next pixel */dcl (comp.incr)            fixed PUBLIC;     /* Look at every comp.incr sample to get min/max */dcl (comp.max)             fixed PUBLIC;     /* Max value seen so far in this block */dcl (comp.min)             fixed PUBLIC;     /* Min value seen so far in this block */dcl (comp.samples)         fixed PUBLIC;     /* Samples compressed so far for this block */dcl (comp.track)           fixed PUBLIC;     /* Which track we're compressing data for */dcl (comp.xmptr)           fixed PUBLIC;     /* Pointer to next word of external memory */dcl (comp.ptr)             fixed PUBLIC;     /* Pointer to word in sector               */dcl (comp.scale)           fixed PUBLIC;     /* for min/max auto scaling                */dcl (dsp.state)            fixed PUBLIC;     /* State of DSP processing            */dcl (dsp.paused)           fixed PUBLIC;     /* true when we want to suspend the dsp for a short while */dcl (dsp.function)         fixed PUBLIC;     /* DSP function selected             */dcl (dsp.algorithm)        fixed PUBLIC;     /* which alg selected for DSP funct  */dcl (DSP70.there)          fixed PUBLIC;     /* true if DSP70 in system (after check) */dcl (dsp.scsi.error)       fixed PUBLIC;     /* if there is a device error, will contain code */dcl (dsp.trk.ptr)          fixed PUBLIC;     /* Pointer into dsp.in/out.tracks     */dcl (dsp.#tracks)          fixed PUBLIC;     /* Number of tracks being processed   */dcl (dsp.in.trk.bits)      fixed PUBLIC;     /* Tracks to read cue on              */dcl (dsp.start) (1)        fixed PUBLIC;     /* Start of whole cue modify          */dcl (dsp.end)   (1)        fixed PUBLIC;     /* End of whole cue                   */dcl (dsp.len)   (1)        fixed PUBLIC;     /* Length of whole cue                */dcl (dsp.boot.len)         fixed PUBLIC;     /* Length of boot object file         */dcl (dsp.alg.len)          fixed PUBLIC;     /* Length of algorithm object file    */dcl (dsp.data.len)         fixed PUBLIC;     /* Length of data table file          */dcl (dsp.data.offset)      fixed PUBLIC;     /* Sector offset of current data pos  */dcl (dsp.out.trk.bits)     fixed PUBLIC;     /* Tracks to write output to          */dcl (dsp.out.tracks) (15)  fixed PUBLIC;     /* Array of output tracks             */dcl (dsp.out.track)        fixed PUBLIC;     /* Left/mono output track currently doing       */dcl (dsp.out.track.r)      fixed PUBLIC;     /* Right output track currently doing       */dcl (dsp.out.s) (1)        fixed PUBLIC;     /* Start of where to write output     */dcl (dsp.out.e) (1)        fixed PUBLIC;     /* End of where to write              */dcl (dsp.in.here) (1)      fixed PUBLIC;     /* Current read pointer               */dcl (dsp.out.here) (1)     fixed PUBLIC;     /* Current write pointer              */dcl (dsp.percent.done)     fixed PUBLIC;     /* percent complete of dsp operation  */dcl (dsp.new.len) (2)      fixed PUBLIC;     /* length of TSMed file (ms,ls)    */dcl (dsp.new.end) (1)      fixed PUBLIC;     /* ending sector #                    */dcl (dsp.in.wds)           fixed PUBLIC;     /* extra input words past sector boundary */dcl (dsp.out.wds)          fixed PUBLIC;     /* extra output words past sector boundary */dcl (dsp.time)             fixed PUBLIC;     /* for timeout                        */dcl (dsp.reselect.time)    fixed;            /* for reselect timeout               */dcl (Dsp.Buf.Msb)          fixed;dcl (Dsp.Buf.Lsb)          fixed;dcl (Dsp.Buf.Len)          fixed;            dcl (dsp.read.event.ptr)   fixed PUBLIC;     /* read ptr for event stack (if no DSP70) */dcl (dsp.write.event.ptr)  fixed PUBLIC;     /* write ptr for event stack (if no DSP70) */dcl (dsp.last.event)       fixed PUBLIC;     /* holds last event simulated    */dcl (dsp.first.write.to.opt) fixed PUBLIC;   /* flag for special first time processing */dcl (Dsp.Next.Track)       fixed PUBLIC;dcl (Dsp.Edit.Len)         fixed PUBLIC;dcl (tsm.in.done)          fixed PUBLIC;     /* number of input secs done          */dcl (tsm.out.done)         fixed PUBLIC;     /* number of output secs done (poly)  */dcl (tsm.ratio)            fixed PUBLIC;     /* time comp/exp ratio                */dcl (tsm.c.or.e)           fixed PUBLIC;     /* time comp or exp flag              */dcl (tsm.stereo)           fixed PUBLIC;     /* flag true if stereo file to proc   */dcl (tsm.pitch)            fixed PUBLIC;     /* value of Pitch option in samples   */dcl (tsm.max.cut)          fixed PUBLIC;     /* value of Max.Cut option            */dcl (tsm.just)             fixed PUBLIC;     /* value of justification option      */dcl sys.stereo             fixed PUBLIC;     /* true for synchronous stereo processing */dcl syn.scsi.data.xfer     fixed PUBLIC;     /* IO with Synclavier SCSI bus */dcl src.ratio(1)           fixed PUBLIC;     /* ratio to sample rate convert *//* $Page Some DSP70 mumbo jumbo */Select.DSP70: proc PUBLIC swapable;   dcl i              fixed;   if (read("51") and "400") = 0   then return false;                         /* no D70s in system */   write(DSPSel) = DSPEnable | DSP#;         /* try to select D70 for DSP70 */   i = ((read(DSPSel) & (DSPEnable|DSP#)) <> (DSPEnable | DSP#));   if i   then return false;                         /* DSP70 not found */   else return true;                          /* board is probably there */end Select.DSP70;Reset.DSP70: proc PUBLIC swapable; /* performs hardware reset on DSP70 */   dcl interrupts fixed;   if Select.DSP70 then do;      /* perform DSP70 reset here: */      interrupts = read("1") & "10";/* save interrupt state */      disable;         /*     1. assert RESET line        */         write (DSPCtl) = DSPReset;         write ("3") = 0;         write ("3") = 0;         write (DSPCtl) = 0;/* deassert reset line */         /*     2. wait at least 10 msec    */         write ("3") = 0;         write ("3") = 0;         write ("3") = 0;      if interrupts <> 0 then enable;      /*     4. ready to go              */   end;   else if dspdebug <> 0 then do;      print 'DSP70 Selection unsuccessful (Reset.DSP70)';   end;end Reset.DSP70;DSP.Write: proc(reg,data) PUBLIC;  /* Write a byte of data to a DSP register */   dcl reg  fixed;                 /* Which register to write */   dcl data fixed;                 /* Data to write */   data = data & "377";            /* Use only low byte */   write(DSPCtl)  = DSPWrite|reg;  /* enable write to register */   write(DSPData) = data;          /* write data byte */   return;end DSP.Write;DSP.Read: proc(reg) PUBLIC; /* Read a byte of data from a DSP register */   dcl reg  fixed;          /* Which register to read */   dcl data fixed;          /* Data read */   write(DSPCtl) = DSPRead|reg;   /* select register; enable read */   data = read(DSPData);          /* read a byte */   return( data & "377");  /* Return only low byte */end DSP.Read;Send.24Bit.Value: proc (high,low) PUBLIC; /* sends 3 bytes to DSP70 (discards high byte of 32 bit) */   dcl high fixed;                        /* high and low words to send */   dcl low  fixed;   write(DSPCtl) = DSPWrite|DSP32SE;   write(DSPData) = low;   write(DSPData) = high;end Send.24Bit.Value;Send.Options.to.DSP70: proc(the.function,the.algorithm) PUBLIC;   dcl the.function    fixed;   dcl the.algorithm   fixed;   if the.function = dsp#tsm   then do;      if the.algorithm = dsp#one      then do;         call Send.24bit.Value(0,tsm.max.cut);         call Send.24bit.Value(0,tsm.just);      end;      else if the.algorithm = dsp#two      then do;         /* no options to date */      end;      else if the.algorithm = dsp#three      then do;         /* no options to date */      end;   end;   else if the.function = dsp#SynSCSI   then do;      /* add options to send to DSP70 */   end;end Send.Options.to.DSP70;Load.Next.Sector: proc(wdlen) PUBLIC;		/* loads next sector from scsi into the DSP70 */   dcl wdlen fixed;   dcl i     fixed;      call Select.DSP70;   call DSP.Write(icr,dsp#write.ack.clr);	/* reset port */   write(DSPCtl) = DSPWrite | DSP32SE; 		/* Set for write of 32 bit words */   if (wdlen ige 256) then do;          	/* quick full sector xfer */      write(DSPData)  = Get.Scsi.Word();  	/* get in sync            */      do i=0 to 84;							/* do 3 words at a shot to reduce loop overhead */	  	 write(DSPData) = Get.Scsi.Word();	  	 write(DSPData) = Get.Scsi.Word();	  	 write(DSPData) = Get.Scsi.Word();      end;   end;end Load.Next.Sector;Load.Next.Words: proc(wdlen) PUBLIC;/* load less than 1 sector (wdlen<256) */   dcl wdlen     fixed;   dcl i     fixed;   call Select.DSP70;   write(DSPCtl) = DSPWrite | DSP32SE;  /* Set for write of 32 bit words */   do i=0 to wdlen-1; 	  write(DSPData) = Get.Scsi.Word;   end;end Load.Next.Words;Store.DSP.Data: proc(sec.offset, data.len) PUBLIC;   dcl sec.offset   fixed;   dcl data.len     fixed;   dcl j            fixed;   write(mam) = dsp.xmsec# + sec.offset;   do while data.len > 0;  	  write(mdi) = Get.Scsi.Word;      data.len = data.len-1;   end;end Store.DSP.Data;Move.DSP.Data: proc (data.len) PUBLIC;/* moves data from external mem to DSP70 */   dcl data.len   fixed;   dcl sec.ctr    fixed;   sec.ctr = 0;   do while data.len ige 256;      call dsp.write(icr,dsp#write.ack.set);/* set hf1 */      write(DSPCtl) = DSPWrite|DSP32SE;     /* set for write of 32 bit words */      write(mam)= dsp.xmsec# + sec.ctr;      rpc 256;      write(DSPData) = read(mdi);      data.len = data.len-256;      sec.ctr = sec.ctr+1;      call dsp.write(icr,dsp#write.ack.clr);/* clear hf1 */   end;   if data.len > 0 then do;/* this should never happen for TSM (handshaking?) */      rpc data.len;      write(DSPData) = read(mdi);      data.len = 0;   end;end Move.DSP.Data;Init.DSP.Function: proc(which.function, which.algorithm) PUBLIC swapable;   dcl which.function    fixed;   dcl which.algorithm   fixed;   if dspdebug <> 0   then do;      disable;      print 'Starting function  ',which.function;      print 'Starting algorithm ',which.algorithm;      enable;   end;   if Select.DSP70 = FALSE   then return 0;   if which.function = dsp#tsm   then do;/* initialize for TSM */      /* 1. send start command to DSP70 */      call dsp.write(icr,dsp#write.ack.clr);      call dsp.write(cvr,"h92");/* start whole shebang */      if dspdebug <> 0      then print 'program started';      /* 2. send options */      call Send.Options.To.DSP70(which.function,which.algorithm);      if dspdebug <> 0      then print 'options sent';      /* 3. select compression or expansion */      call Send.24bit.Value(0,tsm.c.or.e);      if dspdebug <> 0      then print 'c.or.e sent';      /* 4. send comp/exp ratio */      call Send.24bit.Value(shr(tsm.ratio,9),shl(tsm.ratio,7));      if dspdebug <> 0      then print 'ratio sent';      /* 5. send stereo flag */      call Send.24bit.Value(0,tsm.stereo);      if dspdebug <> 0      then print 'stereo flag sent';      /* 6. send length of samples to be processed */      call Send.24bit.Value(dsp.new.len(0),dsp.new.len(1));/* 24 bit sector length */      call Send.24bit.Value(0,dsp.new.len(2));             /*  8 bit word length   */      if dspdebug <> 0      then print 'length sent';      /* 7. download Sine/Cos Tables */      call Move.DSP.Data(8192);		/* load data from xmem to DSP70 */      if dspdebug <> 0      then print 'data tables sent';   end;/* of TSM */   else if which.function = dsp#synscsi   then do;      if which.algorithm = dsp#src      then do;         if dspdebug then do;            disable;            print 'Initializing for Sample Rate Conversion';            enable;         end;         /* 1. send start command to DSP70 */         call dsp.write(icr,dsp#write.ack.clr);         call dsp.write(cvr,"h92");/* start whole shebang */         if dspdebug <> 0         then do;            disable;            print 'program started';            print 'sys.stereo   = ',sys.stereo;            print 'src.ratio(0) = ',src.ratio(0);            print 'src.ratio(1) = ',shr(src.ratio(1),8), shl(src.ratio(1),8);            enable;         end;         call Send.24bit.Value(0, sys.stereo);         call Send.24bit.Value(0, src.ratio(0));/* integer value */         call Send.24bit.Value(shr(src.ratio(1),8), shl(src.ratio(1),8)); /* fractional value */         call Send.24bit.Value(dsp.new.len(0), dsp.new.len(1));         call Send.24bit.Value(0,dsp.out.wds);      end;   end;   dsp.state          = dsp#working;   dsp.time           = real.milliseconds;   /* save time to detect timeout */   dsp.buf.len        = 0;                   /* no data buffered yet        */   dsp.buf.len        = 0;                   /* no data buffered yet        */   return 1;end Init.DSP.Function;Find.Track: proc (which.channel, S#, limit);   dcl which.channel    fixed;   dcl S#               array;/* sample number to find track for */   dcl limit            array;/* routine sets the limit of the current segment */   dcl t#               fixed;   dcl track#           fixed;   dcl ctr              fixed;   dcl found            fixed;   dcl Next.Sync (1)    fixed;   track# = 0;   ctr    = 0;   do while (ctr    <= which.channel)  /* find corresponding track for disk read */   and      (track# <  max.tracks );      found = 0;                     /* assume this track has no audio */      /* make sure this track # is included in cue: */      if (dsp.in.trk.bits & bits(track#)) <> 0      then do;         if source.or.cue(track#) = 0       /* else if no cue stacked - means unusual error */         then do;            found = 1;                    /* or else doing 'repro' kind of things         */            call COPY32(Dsp.End, Limit);         end;         /* examine cue stack to see if there is any audio for this */         /* track at this sector #                                  */         else do;            next.cue:;            /* if entry exists on real time cue stack,  and we have not */            /* wrapped to the current store pointer,  then check audio  */            /* segment data                                             */            if (cue.rt.ptr(track#) <> 0)            then do;                            /* a cue is on the stak */               call read.seg.stack(cue.rt.ptr(track#));               /* advance cue stack read pointer if time has advanced   */               /* to off of end of cue                                  */               if COM32(S#, Seg.End) >= lw#ieq      /* see if past end  */               then do;                             /* of this seg      */                  if Seg.Fptr <> shl(track#, 1)     /* if not at end of */                  then do;                          /* list, look more  */                     cue.rt.ptr(track#) = Seg.Fptr;                     goto next.cue;                  end;               end;               else if COM32(S#, Seg.Sync) >= lw#ieq /* see if in region              */               then do;                              /* else provide digital silence  */                  found = 1;                         /* until segment starts.         */                  call COPY32(Seg.End, limit);       /* save segment limit            */               end;               /* else see if we must back up cue.rt.ptr to point */               /* to prior block:                                 */               else if Seg.Bptr <> shl(track#,1)     /* if block behind us */               then do;                              /* look at it         */                  call gseg.info(Seg.Bptr + Seg.End.Loc);                  Next.Sync(0) = read(mdi);  /* get the end time of  */                  Next.Sync(1) = read(mdi);  /* the PRIOR segment!   */                  if COM32(S#, Next.Sync) = lw#ilt    /* if sample # IS in */                  then do;                            /* prior block then  */                     cue.rt.ptr(track#) = Seg.Bptr;   /* look at it!       */                     goto next.cue;                  end;               end;            end;         end;      end;      if found then do;     /* if a track that contains audio is */         t#  = track#;      /* found,  count up to find the      */         ctr = ctr + 1;     /* one we are looking for.           */      end;      track# = track# + 1;   end;   if ctr > which.channel then return t#;/* found track we are looking for */   else return -1;/* no disk audio for this track */end Find.Track;/* $SUBTITLE  Waveform display processing *//* Look for data being read into buffer memory and compress what's there *//* NOTE: calculating.compressed goes from comp#working --> comp#done     *//* when calculation is complete */do.compress: proc PUBLIC;   dcl s(1)    fixed;  /* Start of what's in buffer memory */   dcl e(1)    fixed;  /* End   of what's in buffer memory */   dcl t(1)    fixed;  /* Temp 32 bit pointer */   dcl (i,j,k) fixed;/*   DISABLE;      PRINT '---';      PRINT 'do.comp: calc=       ',calculating.compressed;      PRINT 'COMP.START,LEN,END : ',COMP.START(LW#MSB),COMP.START(LW#LSB),COMP.END(LW#MSB),COMP.END(LW#LSB),COMP.LEN(LW#MSB),COMP.LEN(LW#LSB);      PRINT 'COMP.HERE          : ',COMP.HERE(LW#MSB),COMP.HERE(LW#LSB);      PRINT 'WORDS,MAX,MIN      : ',COMP.WORDS,COMP.MAX,COMP.MIN;      PRINT 'SAMPLES,TRACK,XMPTR: ',COMP.SAMPLES,COMP.TRACK,COMP.XMPTR;   ENABLE;*/   if calculating.compressed <> comp#working then return;   s(lw#msb) = buf1.msb(comp.track);   /* get sample # we are buffered at  */   s(lw#lsb) = buf1.lsb(comp.track);   call SHR32(s,8);                    /* convert that to sector #         */   call COPY32(s,e);                   /* get sector # up to which we      */   call ADD16(buf1.len(comp.track),e); /* have buffered                    */   call COPY32(comp.here,t);   call ADD16(5,t);                    /* process 5 sectors at a time      */   /* if data is sitting in buffer, compress it now,      */   /* otherwise, start a process going to get the data    */   /* into the buffer                                     */   if  (clob.len(comp.track) = 0)              /* if nothing in buf2 has glommed buf1       */   and (COM32(comp.here,s) >= lw#ieq)          /* and desired sectors is after buffer start */   and (COM32(t        ,e) <= lw#ieq)          /* and desired end is before end of buffer   */   and ((read.track.info&bits(comp.track))<>0) /* force read first time through so data is at start of buffer */   then do;                                    /* data is in poly and set to compress */      i=compute.base.adr(comp.track);      call psmread(i+buf.base+comp.here(lw#lsb)-s(lw#lsb),0);      /* Loop through available sectors in buffer memory */      do while (com32(comp.here,t)     = lw#ilt      )         AND   (calculating.compressed = comp#working);         write("313") = addr(misc.buf(0));         rpc 256;         write("373") = read(psd);                  do while comp.ptr < 256;   /* process the data in this sector */            /* Change (-32768 to +32767) to be (0 to 65535)  */            j = misc.buf(comp.ptr) XOR "100000";            if j igt comp.max       /* Remember max seen  */            then comp.max = j;            if j ilt comp.min       /* Remember min seen  */            then comp.min = j;            comp.samples = comp.samples + comp.incr;            comp.ptr     = comp.ptr     + comp.incr;            /* When we've compressed enough, save max and min seen */            if comp.samples IGE comp.ratio then do;               /* Changes values 0 to 65535 to be in the range 0 to 255 */               comp.max = shr(comp.max,8);               comp.min = shr(comp.min,8);               if abs(comp.max-128) > comp.scale               then comp.scale = abs(comp.max-128);               if abs(comp.min-128) > comp.scale               then comp.scale = abs(comp.min-128);               /* Now write out the max and min values */               if comp.xmptr ilt 1024               then do;                  write(MAM) = comp.xmsec# + shr(comp.xmptr,8);                  write(MAL) = comp.xmptr & "377";                  write(MD)  = shl(comp.max,8) \ comp.min;               end;               comp.xmptr = comp.xmptr + 1;               comp.samples = comp.samples - comp.ratio;               /* re-compute how many samples get compressed into */               /* the next pixel,  to avoid accumulated round     */               /* off error:                                      */               call COPY32(Comp.Len, Bit);  /* get # of words to do */               call ratio_multiply(comp.xmptr + 1, comp.words);               comp.ratio = Bit(lw#lsb) - comp.prior(lw#lsb);               call COPY32(Bit, Comp.Prior);               /* handle ratios less than 1 (ie very small scales)  */               /* by storing same min/max several times             */               do while (comp.samples IGE comp.ratio)  /* only happens with */               and      (comp.xmptr   ILT 1024      ); /* ratios = 0        */                  write(MAM) = comp.xmsec# + shr(comp.xmptr,8);                  write(MAL) = comp.xmptr & "377";                  write(MD)  = shl(comp.max,8) \ comp.min;                  comp.xmptr = comp.xmptr + 1;                  comp.samples = comp.samples - comp.ratio;                  call COPY32(Comp.Len, Bit);  /* get # of words to do */                  call ratio_multiply(comp.xmptr + 1, comp.words);                  comp.ratio = Bit(lw#lsb) - comp.prior(lw#lsb);                  call COPY32(Bit, Comp.Prior);               end;               comp.max     = 0;     /* re-initialize max           */               comp.min     = (-1);  /* and min to 65535            */            end;         end;    /* of processing a sector */         comp.ptr = comp.ptr - 256;  /* count 256 samples processed */         call add16(1,comp.here);                   /* Next sector */         if (com32(comp.here,comp.end)  = lw#igt)   /* At end of data... */         OR (comp.xmptr                >= 1024  )   /* ...or output buffer is full */         then do;            calculating.compressed = comp#done;   /* We're done. */            /* normalize signal display to provide peak of 255 */            write(MAM) = comp.xmsec#;            do i = 0 to comp.xmptr-1;                   /* scale so max    */               j = shr(read(md),8);                     /* is 112.  This   */               k = read(md) & 255;                      /* yields + and -  */               j = ((j-128) * 112 / comp.scale) + 128;  /* 14 pixels       */               k = ((k-128) * 112 / comp.scale) + 128;               write(mdi) = shl(j,8) \ k;            end;         end;      end;        /* of loop through buffer memory */   end;   /* else start disk read operation to get the correct data in */   /* memory.                                                   */   else if (track.info.busy & bits(comp.track)) = 0 then do;      read.track.time = real.milliseconds;          /* set timeout timer */      if ((read.track.info&bits(comp.track))=0)        /* if first read */      or ((track.info.direction&bits(comp.track))<>0)  /* or we just wrote */      then zap.buffer(comp.track)   = 1;               /* then clear buffer contents */      read.track.info               = read.track.info \ bits(comp.track);      track.info.direction          = track.info.direction & (not(bits(comp.track)));      track.info.busy               = track.info.busy \ bits(comp.track);      read.track.buf.len(comp.track)= buf.len;      read.track.chunk  (comp.track)= 25;      call copy32(comp.here,t);      call shl32(t,8);                                 /* convert sectors to words */      read.track.msb(comp.track)    = t(lw#msb);      read.track.lsb(comp.track)    = t(lw#lsb);      track.eof(comp.track)         = 0;   end;end do.compress;/* $SUBTITLE  DSP processing *//* This code is used to bounce the tracks being processed by DSP  *//* from input to output, running the data through the DSP chip    *//* according to the algorithm selected                            */Calc.Percent: proc(done,total) PUBLIC;   dcl done     array;   dcl total    array;   dcl percent  fixed;   dcl num(1)   fixed;   dcl den(1)   fixed;   call Copy32(done,num);/* make local copy to trash */   call Copy32(total,den);   do while num(0) and den(0) <> 0;      call Shr32(num,1);      call Shr32(den,1);   end;   bitmsb=0;bitlsb=num(1);   call ratio_multiply(100,den(1));   dsp.percent.done = bitlsb;end Calc.Percent;Send.Audio.To.DSP70: proc (left.pointer,right.pointer,sync.stereo) PUBLIC;/* Send sector from poly to DSP70 */   dcl left.pointer     fixed;/* poly pointer to left track data  */   dcl right.pointer    fixed;/* poly pointer to right track data */   dcl sync.stereo      fixed;/* set if stereo tracks are to be processed side-by-side */   /* if either of the sector pointers are -1 (assume this is not a valid */   /* sector in poly) then send zeros instead of data.                    */   if left.pointer <> -1 then do;      call psmread(left.pointer,0);      call dsp.write(icr,dsp#write.ack.set);/* get in sync with DSP70 */      write(DSPCtl) = DSP16SE|DSPWrite;     /* set transfer mode */      rpc 256;      write(DSPData) = read(psd);           /* write data */      call dsp.write(icr,dsp#write.ack.clr);/* clear flags init port */   end;   else do;      call dsp.write(icr,dsp#write.ack.set);/* get in sync with DSP70 */      write(DSPCtl) = DSP16SE|DSPWrite;     /* set transfer mode */      rpc 256;      write(DSPData) = 0;/* send zeros */      call dsp.write(icr,dsp#write.ack.clr);/* clear flags init port */   end;   if sync.stereo then do;      if right.pointer <> -1 then do;         call psmread(right.pointer,0);         call dsp.write(icr,dsp#write.ack.set);/* get in sync with DSP70 */         write(DSPCtl) = DSP16SE|DSPWrite;     /* set transfer mode */         rpc 256;         write(DSPData) = read(psd);           /* write data */         call dsp.write(icr,dsp#write.ack.clr);/* clear flags init port */      end;      else do;         call dsp.write(icr,dsp#write.ack.set);/* get in sync with DSP70 */         write(DSPCtl) = DSP16SE|DSPWrite;     /* set transfer mode */         rpc 256;         write(DSPData) = 0;/* send zeros */         call dsp.write(icr,dsp#write.ack.clr);/* clear flags init port */      end;   end;end Send.Audio.To.DSP70;Read.Audio.From.DSP70: proc (left.pointer,right.pointer,sync.stereo) PUBLIC;/* Read sector from DSP70 to poly */   dcl left.pointer     fixed;   dcl right.pointer    fixed;   dcl sync.stereo      fixed;/* set if stereo tracks are to be processed side-by-side */   call psmwrite(left.pointer,0);   call dsp.write(icr,dsp#read.ack.set);/* get in sync with the DSP70 */   write(DSPCtl) = DSP16SE|DSPRead;   rpc 256;   write(psd) = read(DSPData);   call dsp.write(icr,dsp#read.ack.clr);   if sync.stereo then do;      call psmwrite(right.pointer,0);      call dsp.write(icr,dsp#read.ack.set);/* get in sync with the DSP70 */      write(DSPCtl) = DSP16SE|DSPRead;      rpc 256;      write(psd) = read(DSPData);      call dsp.write(icr,dsp#read.ack.clr);   end;end Read.Audio.From.DSP70;Send.Audio.To.RAM: proc (left.pointer, right.pointer, stereo); /* send audio to external RAM buffer */   dcl left.pointer   fixed;   dcl right.pointer  fixed;   dcl stereo         fixed;   call psmread(left.pointer,0);     /* set up source pointer for poly */   write(mam) = dsp.write.event.ptr; /* set up dest pointer for xRAM   */   if left.pointer <> -1 then do;    /* if we are supposed to write audio */      rpc 256;      write(mdi) = read(psd);   end;   else do;                          /* if we are supposed to write zeros */      rpc 256;      write(mdi) = 0;   end;   dsp.write.event.ptr = dsp.write.event.ptr + 1;   if stereo then do;      call psmread(right.pointer,0);      if right.pointer <> -1 then do;   /* if we are supposed to write audio */         rpc 256;         write(mdi) = read(psd);      end;      else do;                          /* if we are supposed to write zeros */         rpc 256;         write(mdi) = 0;      end;      dsp.write.event.ptr = dsp.write.event.ptr + 1;   end; /* of if stereo */end Send.Audio.To.RAM;Read.Audio.From.RAM: proc (left.pointer, right.pointer, stereo); /* read audio from external RAM buffer */   dcl left.pointer   fixed;   dcl right.pointer  fixed;   dcl stereo         fixed;   call psmwrite(left.pointer,0);   /* set up destination pointer for poly */   write(mam) = dsp.read.event.ptr; /* set up source pointer for xRAM      */   rpc 256;   write(psd) = read(mdi);   dsp.read.event.ptr = dsp.read.event.ptr + 1;   if stereo then do;      call psmwrite(right.pointer,0);      rpc 256;      write(psd) = read(mdi);      dsp.read.event.ptr = dsp.read.event.ptr + 1;   end;end Read.Audio.From.RAM;/* If there is no DSP70 in the system, Get.Stacked.DSP.Event is called *//* instead of DSP.Read to simulate the operation of the DSP70.  Why is *//* this necessary?  Because!  Some users who don't want to shell out   *//* the $$$$ for the DSP70, still want to do transfers between the  DTD *//* and the Synclavier SCSI bus (imagine that). By simulating the DSP70 *//* we can use the software that is already in place to accomplish the  *//* transfer, albeit without any processing.                            */Get.Next.Stacked.DSP.Event: proc; /* returns next stacked event and manages stacking */   /* this routine assumes that the pointers have been initialized */   /* prior to this call.                                          */   /* if we last returned an extended command then we are done */   if dsp.last.event = dsp#extended.cmd   then do;      dsp.last.event = dsp#done;      return dsp#done;   end;   else if (COM32(dsp.out.here,dsp.new.end) >= LW#IEQ) /* if we have read all we are supposed to */   then do;      dsp.last.event = dsp#extended.cmd;      return dsp#extended.cmd;   end;   /* else if there is still room in RAM */   /* start a poly -> RAM transfer       */   else if dsp.write.event.ptr < (bbuf.xmsec# + shr(bbuf.len,8))    then do;      dsp.last.event = dsp#write.audio;      return dsp#write.audio;                                    end;   /* else if still data to read */   /* RAM -> poly transfer       */   else if (dsp.write.event.ptr = (bbuf.xmsec# + shr(bbuf.len,8)))   and     (dsp.read.event.ptr  < (bbuf.xmsec# + shr(bbuf.len,8)))   then do;      dsp.last.event = dsp#read.audio;      return dsp#read.audio;                        end;   /* both at end of buffer */   else do;      dsp.write.event.ptr = (bbuf.xmsec#); /* reset pointers */      dsp.read.event.ptr  = (bbuf.xmsec#);      dsp.last.event = dsp#write.audio;      return dsp#write.audio;             /* poly -> RAM transfer */   end;end Get.Next.Stacked.DSP.Event;Flush.Opt.Data: proc (msb, lsb) PUBLIC swapable;   dcl (Msb, Lsb)    fixed;   dcl (i)           fixed;   if dsp.opt.data.stacked = 0 then return; /* oops ... */   else do;      write(mam) = temp.xmsec#;      if dspdebug then do;         disable;         print 'Flushing Data';         print 'msb = ', msb, ' lsb = ', lsb;         print 'i = 256';         enable;      end;      i = writedata(msb&255, lsb, loc(0), 256, 1);      if i <> 0 then do;         print 'Error - ',i;         dsp.scsi.error = i;         dsp.state = dsp#abort;         return i; /* some sort of SCSI error */      end;      dsp.opt.data.stacked = 0;   end;end Flush.Opt.Data;insert ':lod:dspsou1';/* do.dsp rouitne */end dspmod;