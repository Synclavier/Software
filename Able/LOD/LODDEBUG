/* 02/15/90 - standardized EOF usage for old code */Process.Debug.Character:proc swapable;/* code to recover DTD audio *//* Type and A on the diagnostic terminal */if NewInfo = 65  then begin;   dcl i fixed;   Repair.Track: proc(track#);      dcl track# fixed;      dcl port#  fixed;      dcl i      fixed;      dcl a (1)  fixed;      dcl b (1)  fixed;      port# = track# / tracks.per.port;      if port.io(port#) <> 0 then do;         print 'Track is BUSY ... try again';         return;      end;      print;      print 'Recovering audio for track ', track# + 1;      call COPY32(Song.Data,   a);      call COPY32(Song.Length, b);      do while COM16(0, b) <> LW#IEQ;         if COM16(100, b) = lw#IGT then i = b(1);         else                           i = 100;         port.secmsb  (port#) = a(0);         port.seclsb  (port#) = a(1);         port.io.len# (port#) = i;         call Update.Adir.After.Write(port#, track#);         if Synclav.software.version >= 3          /* update screen */         then get.new.motion = get.new.motion \ 4; /* on aee        */         call ADD16(i, a);         call SUB16(i, b);      end;      call COPY32(Song.Ending, BIT);      call update.song.and.track.used(track#);      print 'Recovery complete for track ',track# + 1;   end Repair.Track;   dcl track# fixed;   print;   if Subsystem.Ready = 0 then do;      print 'System Not Ready.';   end;   else do;      print 'Type a B to recover all audio for current project,  or ';      print 'type any other character to continue --',;      if read("50")= 66 then do;         write("50")=66; print;         print 'Enter Track Number (or Type "-1" for all tracks) ',;         input i;         if i = -1 then do;            do track# = 0 to Max.Tracks-1;               if (Track.Avail.Bits & bits(track#)) <> 0               then call Repair.Track(track#);            end;         end;         else if (i >  0)         and     (i <= Max.Tracks)         then do;            track# = i - 1;            if (Track.Avail.Bits & bits(track#)) <> 0            then call Repair.Track(track#);            else print 'Track is not available';         end;         else do;            print;            print 'Bad Track Number';         end;      end;      else do;         print;         print 'Command Ignored.';      end;   end;end;end Process.Debug.Character;eof/* Tape Debug Stuff */   dcl (i,j,k,l,m,n ) fixed;   dcl (port#,track#) fixed;   disable;   print ' 0,TRK,0    : tape inquiry      ',;   print ' 1,TRK,0    : test unit ready   ';   print ' 2,TRK,0    : load tape         ',;   print ' 3,TRK,0    : unload tape       ';   print ' 4,TRK,0    : mode select       ',;   print ' 5,TRK,0    : request sense     ';   print ' 6,TRK,blen : write to tape     ',;   print ' 7,TRK,blen : read from tape    ';   print ' 8,TRK,code : space             ',;   print ' 9,TRK,0    : write 0 file mrk  ';   print '10,0,config : select config     ',;   print '11,TRK,TT   : tape select track ';   print '12,0,0      : set type to CDC   ',;   print '13,TRK,0    : set XTRACK        ';   print '14,TRK,#blks: read rev til proj ',;   print '15,0,0      : set type to fuji  ';   print '16,0,0      : print space count ',;   print '17,TRK,#blks: debug tape space  ';   print '18,TRK,sec# : dump buf + sec#   ',;   print '19,TRK,0    : see reverse info  ';   print '20,0,0      : print tape.type   ',;   print '21,TRK,sec  : dump disk sector  ';   enable;   input i,j,k;   if (j = (-1)) then do;     /* track -1: means access aux tape */      port#  = max.ports;     /* drive.  Use track 0 for         */      track# = 0;             /* errors.                         */   end;   else do;      track# = j;      port#  = j/tracks.per.port;   end;      /* see if port is busy */   if (i<10)                     /* if this command issues a     */   or (i=11)                     /* scsi command,  then check    */   or (i=14)                     /* for port.io being 0          */   or (i=17)   or (i=21)   then do;      if port.io(port#) <> 0      then do;         print 'Error: port is busy!!  Code =',port.io(port#);         return;      end;   end;   do case i;      do;  /* tape inquiry */         i=start.tape.command(port#,track#,6,9);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do;  /* tape test unit ready */         i=start.tape.command(port#,track#,7,0);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do;  /* load tape */         i=start.tape.command(port#,track#,8,1);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do;  /* unload tape */         i=start.tape.command(port#,track#,8,0);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do;  /* mode select */         if (tape.type(port#)=type.cdc)         or (tape.type(port#)=type.tan)         then i=start.tape.command(port#,track#,10,12);         else if tape.type(port#)=type.epi         then i=start.tape.command(port#,track#,10,22);          else i=start.tape.command(port#,track#,10,13);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do; /* request sense */         port.last.io(port#)=0;         i=start.tape.command(port#,track#,11,7);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do; /* write to tape */         stop;    /* disallow write for now */         tape.pmem.add=compute.base.adr(track#) + buf.base;         i=start.tape.command(port#,track#,12,k);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do; /* read from tape */         tape.pmem.add=compute.base.adr(track#) + buf.base;         if k = (-1) then do;   /* -1 = means recover data & write to disk */            recover.msb  = song.data.msb;  /* start recovery at start of */            recover.lsb  = song.data.lsb;  /* current project            */            recover.code = 1;            k            = 1;         end;         else recover.code = 0;         i=start.tape.command(port#,track#,Tape.Read,k);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do; /* space tape */         i=start.tape.command(port#,track#,Tape.Space,k);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         port.timer(port#)=real.seconds+1000; /* allow 1000 seconds to LEOT */         xtrack=track#;      end;      do; /* write 0 file marks */         stop;  /* disallow write for now */         i=start.tape.command(port#,track#,15,0);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do;         active.tape.config = k;     /* select active tape configuration */      end;      do;   /* tape track select */         I=start.tape.command(port#,track#,Tape.TrackSelect,k);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do i = 0 to max.ports;      /* set type to cdc */         tape.type(i) = type.cdc;      end;      xtrack=j;                   /* set xtrack      */      do;      /* start read reverse until start of project block */         Tape.Reverse.Left (port#) = k;   /* save how many to reverse    */         Tape.Reverse.Count(port#) = 0;   /* none issued so far          */         Tape.Reverse.Chunk(port#) = 1;   /* by 1 block at a time (is no faster of more) */         tape.pmem.add = compute.base.adr(track#) + buf.base;         i=start.tape.command(port#,track#,Tape.ReadReverse,Tape.Reverse.Chunk(port#));         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         xtrack=track#;      end;      do i = 0 to max.ports;    /* set type to fuji */         tape.type(i) = type.fuj;      end;      print Tape.Space.Count;      do; /* start debug space */         Tape.Space.Count = 0;         if    k < 0 then Tape.Space.Dir = (-1);         else             Tape.Space.Dir = (+1);         Tape.Space.Limit = k;         i=start.tape.command(port#,track#,Tape.BlockSpace,Tape.Space.Dir);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;         port.timer(port#)=real.seconds+1000; /* allow 1000 seconds to LEOT */         xtrack=track#;      end;      do;                          /* print buf.base */         j = compute.base.adr(track#);  /* sector #       */         disable;         do i=0 to 31;            print int(i*8),':  ',;            call psmread(j+k+buf.base,i*8);            do l=0 to 7;               print read(psd),;            end;            print ' ',;            call psmread(j+k+buf.base,i*8);            do l = 0 to 7;               m=read(psd);               if (m&127) < 32 then print '.',;               else print character(m&127),;               m = shr(m,8);               if (m&127) < 32 then print '.',;               else print character(m&127),;            end;            print;         end;         enable;      end;      do;  /* see reverse info */         print 'Reverse Left:  ',Tape.Reverse.Left (port#);         print 'Reverse Count: ',Tape.Reverse.Count(port#);         print 'Reverse Chunk: ',Tape.Reverse.Chunk(port#);      end;      do;  /* print tape.type  */         print 'tape.type: ',;         do i = 0 to max.ports;            print tape.type(i),;         end;         print;      end;      do; /* dump disk sector */         tptr = j*total.stride;         call readdata(0, k, misc.buf, 256);         disable;         do l=0 to 7;            print l*8,':  ',;            do m=0 to 7;               print misc.buf(l*8+m),;            end;            print ' ',;            do m = 0 to 7;               n = misc.buf(l*8+m);               if (n&127) < 32 then print '.',;               else print character(n&127),;               n = shr(n,8);               if (n&127) < 32 then print '.',;               else print character(n&127),;            end;            print;         end;         enable;      end;   end;end Process.Debug.Character;eof/* Code for extremely difficult tape recovery:    *//* Code for copying data to disk reading forward: *//* insert after successful tape read:             */   if (i=S$Good)   or (i=S$ConditionMet)   then do;     /* good status - updated length */      tape.state(port#)=tape.state(port#)+1;      /* write data to disk if no command outstanding */      if (command.# = 0) then do;         do i = 0 to 15;            call psmread(compute.base.adr(track#)                         + buf.base + i, 0);            call poly.in(addr(misc.buf(0)), 256);            /* compute disk address to write to */            /* this code writes every single block */            /* read in out to the disk:            */            x(0) = 0;            x(1) = tape.reverse.count(port#);            call shl32(x,4);   /* times 16 for sectors/block */            call add16(i,x);   /* index to sector of interest */            call add32(song.data, x, x); /* add in sector start of curr project */            /* write to first drive - only works */            /* for even tracks !!!               */            tptr=(track#*total.stride);            k = writedata(x(0),x(1),misc.buf,256,1);            /* if good status, update adir & track dir */            if k = 0 then do;               port.secmsb (port#) = x(0);               port.seclsb (port#) = x(1);               port.io.len#(port#) = 1;               call update.adir.after.write(port#, track#);               bitmsb=port.secmsb  (port#);                 bitlsb=port.seclsb  (port#) + port.io.len#(port#);               if bitlsb ilt port.io.len#(port#) then bitmsb = bitmsb + 1;               call update.song.and.track.used(track#);  /* update used from sector # = bitmsb, bitlsb */            end;            print 'Writedata: ',x(0), x(1), k;         end;         Tape.Reverse.Count(port#) = Tape.Reverse.Count(port#)                                    + 1;         /* issue next read command */         tape.pmem.add=compute.base.adr(track#) + buf.base;         i=start.tape.command(port#,track#,Tape.Read,1);         if i<>0 then do;            print 'Error Status :',i;            port.io(j/tracks.per.port)=0;         end;      end;   end;end;end Process.Debug.Character;eof   /* And also for reading in reverse: */   /* write data to disk:              */   /* process 16 sectors:              */   /* Only write data out to disk if   */   /* not in search mode (ie tape.     */   /* reverse left = (-1))             */   if Tape.Reverse.Left(port#) >= 0   then do i = 0 to 15;      /* get first sector to write to disk by */      /* looking at last sector read from     */      /* tape:                                */      call psmread(compute.base.adr(track#)                   + buf.base + 15 - i, 0);      call poly.in(addr(misc.buf(0)), 256);      /* reverse bytes:                       */      do j = 0 to 255;         misc.buf(j) = rot(misc.buf(j),8);      end;      /* reverse words:                       */      do j = 0 to 127;         k = misc.buf(j);         l = misc.buf(255-j);         misc.buf(j) = l;         misc.buf(255-j)=k;      end;      /* compute disk address to write to */      /* this code writes every single block */      /* read in out to the disk:            */      j = Tape.Reverse.Left(port#);      if j <> 0 then do;         j = j - 1;   /* predecrement */         x(0) = 0;         x(1) = j;         call shl32(x,4);   /* times 16 for sectors/block */         call add16(i,x);   /* index to sector of interest */         call add32(song.data, x, x); /* add in sector start of curr project */         /* write to first drive - only works */         /* for even tracks !!!               */         tptr=(track#*total.stride);         k = writedata(x(0),x(1),misc.buf,256,1);         /* if good status, update adir & track dir */         if k = 0 then do;            port.secmsb (port#) = x(0);            port.seclsb (port#) = x(1);            port.io.len#(port#) = 1;            call update.adir.after.write(port#, track#);            bitmsb=port.secmsb  (port#);              bitlsb=port.seclsb  (port#) + port.io.len#(port#);            if bitlsb ilt port.io.len#(port#) then bitmsb = bitmsb + 1;            call update.song.and.track.used(track#);  /* update used from sector # = bitmsb, bitlsb */         end;         print 'Writedata: ',x(0), x(1), k;      end;   end;end;end Process.Debug.Character;eof/* Code for segment list debugging: */begin;   dcl i fixed; dcl j fixed; dcl k fixed;   count.free.blocks: proc;      i = Seg.Free.Ptr; j = 0;      do while i <> 0;         i = gseg.info(i); j = j + 1;      end;      print j,' free blocks';   end;   if Newinfo = 1 then do; /* control a - start timing main loop */      max.time  = 0;      call STR32(0, 0, tot.time);      tot.loops = 0;      time.loop = 1;   end;   if Newinfo = 2 then do; /* control b - print loop time        */      i = loop.time - read(d16);      load tot.time(1); uload tot.time(0); div tot.loops;      print 'Avg: ',res;      print 'Max: ',max.time;      write(d16) = -i;      loop.time = read(d16) + i;   end;   if NewInfo = 32  then do;      call count.free.blocks;   end;   if  (NewInfo >= 48)   /* 0 - 7 */   and (NewInfo <= 55)   then do;      disable;      i = NewInfo - 48;  /* get track # */      j = gseg.info(shl(i,1));      k = 0;      print 'Track:   ',i;      print 'Read, Rt:',cue.read.ptr(i), cue.rt.ptr(i);      print '  Fptr  Bptr Exists   Sync  Sync  Disk  Disk   End   End  Info  Time  Time';      do while j <> shl(i,1);         call read.seg.stack(j);         print Seg.Fptr, Seg.Bptr,' ',octal(Seg.Exists),;         print ' ',seg.sync(0),seg.sync(1), seg.disk(0), seg.disk(1),;         print seg.end(0), seg.end(1), seg.info, seg.time(0), seg.time(1);         j = Seg.Fptr;      end;      print;      j = gseg.info(env.cue.heads + shl(i,1));      k = 0;      print '  Fptr  Bptr  Sync  Sync   Len   Len  Send  Send  Sval Adder Delta Limit';      do while j <> (env.cue.heads + shl(i,1));         call read.env.stack(j);         print env.fptr, env.bptr, env.sync(0), env.sync(1),;         print env.len(0), env.len(1), env.send(0), env.send(1),;         print env.sval, env.adder, env.delta, env.limit;         j = Env.Fptr;      end;      enable;   end;end;end Process.Debug.Character;eof/* Code for optical disk/readddata/writedata debugging: */begin;   print 'Enter Target #, 1 if 1024k blocks --, sector, wrd length',;   input i,j,k,l;   tptr = optical.tptr;   track.target# = i;   track.drive.exists = 1 \ shl(j,8);   print 'Sense:    ',requestsense;   print 'Inquire:  ',inquire,'  ',string(InquiryDataCode);   print 'Test:     ',Test.Unit.Ready;   print 'Capacity: ',ReadCapacity,cap.msb,cap.lsb;   print 'Read:     ',Readdata(0, k, misc.buf, l), '  ',octal(misc.buf(0)), '  ', octal(misc.buf(1)), '  ',octal(misc.buf(2)), '  ',octal(misc.buf(3));   PolyMemSec  = buf.base;   PolyMemWord = 2;   print 'Poly Read:',Readdata(0, k, loc(-1), l),;   call psmread(buf.base,2);   print '  ',octal(read(psd)), '  ', octal(read(psd)),;   print '  ',octal(read(psd)), '  ', octal(read(psd));   print 'End  Data:',0,;   call psmread(buf.base,l);   print '  ',octal(read(psd)), '  ', octal(read(psd)),;   print '  ',octal(read(psd)), '  ', octal(read(psd));end;end Process.Debug.Character;eof/* Code for searching for audio: *?begin;   print 'Enter track, sector #, search # --',; input i,j,k;   call COPY32(Song.Data, atmp);   call ADD16(j, atmp);   tptr = i*total.stride;   call readdata(atmp(0), atmp(1), misc.buf, 256);   disable;   do l=0 to 7;      print l*8,':  ',;      do m=0 to 7;         print misc.buf(l*8+m),;      end;      print;   end;   enable;   if k <> 0 then do;      print 'Searching ...';      btmp(0) = misc.buf(0); btmp(1) = misc.buf(1);      do while k <> 0;         call COPY32(Song.Data, atmp);         call ADD16(j-k, atmp);         call readdata(atmp(0), atmp(1), misc.buf, 256);         if  (misc.buf(0) = btmp(0))         and (misc.buf(1) = btmp(1))         then print 'Found: ',j-k;         k = k-1;      end;   end;end;end Process.Debug.Character;eof/* Code to fabricate sine wave */if newinfo = 65 then do;   print 'Enter Track, frequency --',;   input i,j;   do k = 0 to 255;      misc.buf(k) = int(30000*sin(2*3.14159265*j*k/256));   end;   call psmwrite(compute.base.adr(i)+buf.base+rec.base, 0);   do j = 0 to buf.len-1;      do k = 0 to 255;         write(psd) = misc.buf((k+64)&255);      end;   end;end;end Process.Debug.Character;eof/* Code to print out loop time: */if newinfo = 66 then do;   print 'Max Time - ',max.time;   max.time = 0;end;end Process.Debug.Character;eof/* Code to debug allocation directory: */begin;  if newinfo = 32 then do;     i = (song.base+dtd.song#)*song.len;      j = gsong.dir(i+song.index);             print 'Song Index: ',j;  end;    else if newinfo = 65 then begin;     print 'Allocation Directory: Track 0';     call gadir(0);     print read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi);     print 'Allocation Directory: Track 1';     call gadir(256);     print read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi),read(mdi);  end;  else if newinfo = 66 then begin;     dcl (a,b,c,d,e,f,g,h,i) fixed;     print 'Enter Track #, 8 adir values:';     input i,a,b,c,d,e,f,g,h;     call gadir(i*256);     write(mdi) = a;write(mdi) = b;write(mdi) = c; write(mdi) = d;     write(mdi) = e;write(mdi) = f;write(mdi) = g; write(mdi) = h;     new.adir(i) = 1;  end;  else if newinfo = 67  then begin;     print 'Enter track # to glom --',;     input i;     tptr=i*total.stride;     misc.buf(0) =  99;     misc.buf(1) = 100;       call writedata(0,0,misc.buf,2,1);  end;    else print character(newinfo),;end;end Process.Debug.Character;eof /* Code for cue directory debugging: */begin;   p.cue.head:proc;      print '  smsb  slsb  emsb  elsb   fin  fout  name';   end;   p.cue:proc;      print cc.s.msb,cc.s.lsb,cc.e.msb,cc.e.lsb,cc.fin,cc.fout,'  ',;      print string(loc(addr(cc.name)));   end;   disable;   print '0     : Print cue dir     ',;   print '1     : Zap Cue Directory ';   input i;   do case (i);      do;      /* print cue base */         i=0; j=0; k=0;         call p.cue.head;         do while k < cue.num;            call read.basic.cue(cue.sec# + i,j,current.cue);            call p.cue;            call read.store(cue.sec# + i,j);            j = j + read(md);            i = i + shr(j,8);            j = j & 255;            k = k + 1;         end;         print;         print 'Alloc table  ',num.of.alloc;         DO K=0 TO NUM.OF.ALLOC-1;            CALL READ.STORE(allc.sec#,shl(K,1));            PRINT READ.WORD,' ',READ.WORD,'    ',;            IF (K&3)=3 THEN PRINT;         END;         DO L = 0 TO 5;            PRINT;            DO CASE (L);               PRINT 'TOTAL DISK NAME SORT ',;               PRINT 'TOTAL DISK TIME SORT ',;               PRINT 'TOTAL DISK SMPT SORT ',;               PRINT 'CUR PROJ   NAME SORT ',;               PRINT 'CUR PROJ   TIME SORT ',;               PRINT 'CUR PROJ   SMPT SORT ',;            END;            PRINT NUM.OF(L);            DO K=0 TO NUM.OF(L)-1;               CALL READ.STORE(SORT.BASE(L),K);               PRINT READ.WORD,'  ',;               IF (K&7)=7 THEN PRINT;            END;            PRINT;         END;      end;      do;      /* 34: zap cue directory */         call zero.cue.dir;         cue.info.updated = 1;      end;   end;   enable;end;end Process.Debug.Character;eof