/* DDTSOU - Module containing LOW LEVEL DDT hardware routines *//* 02/11/92 - cj - allow multi udio to work with DDSYN             *//* 08/14/91 - cj  - Added UDIO/DDSYN stuff                         *//* These routines provide convenient access to the DDT hardware    */module ddtmod;insert ':-xpl:scsilits';insert ':lod:lodlits:globlits'; /* get glob literals                */insert ':lod:lodlits:ddtlits';  /* literals for DDT hardware        */insert ':lod:lodmods:miscdcl';  /* get misc routines                *//* SCSI Subroutines for connecting to special devices:                 *//* Bit selections for D24 card - map card # to bit selection: */dcl Scsibits data public (256,512,1024,2048);Select.D24: proc(d24.#) PUBLIC;          /* set up for a d24 usage */   dcl d24.#    fixed;   /* select d24 # */   write(ScsiSel ) = S$SelectEnable \ Scsibits (d24.#);   write(ScsiData) = 0;   write(ScsiBus ) = 0;end Select.D24;/* Targ0.Connect:  connect to a proprietary lun.   call this   routine ONLY WHEN THE BUS IS FREE                            */Targ0.Connect:proc(lun) PUBLIC;   /* connect to proprietary lun */   dcl lun      fixed;   dcl i        fixed;   /* 1/29/89 - cj - put in retry error recovery because we hang up here */   /* trying to connect to the DDT shortly after doing a tape            */   /* operation.                                                         */   retry:;   write(ScsiData) =bits(0);           /* target 0                     */   write(ScsiBus ) =S$SEL;             /* gnd SEL                      */   do while ((read(ScsiBus)&S$BSY)=0); /* had better happen right away */   end;                                /* or our hardware has died     */   write(ScsiData)=0;                  /* clear bus                    */   write(ScsiBus )=0;   i=0;   do while ((read(ScsiBus)&S$REQ)=0); /* had better happen right away */      i = i + 1;      if i = 100 then goto retry;   end;   write(ScsiByte)=lun;                /* select our proprietary lun   */end Targ0.Connect;/* Variables to indicate DDT hardware availability:              *//* There are two methods of connecting the DDT units to the Direct - to - *//* Disk.    One mode 0,  the single DDT unit connects directly to the     *//* ddt computer with its own dedicated SCSI d24 card.   This limits the   *//* system to two channels only (same direction),  but provides routing    *//* ability.    The other connect mode provides for multiple units on      *//* each SCSI buffer memory card.   This provides for multiple tracks      *//* at the same time,  but provides no routing capablity.                  */dcl DDT.Hardware.Avail fixed PUBLIC;  /* true if any DDT avail   */dcl DDT.DDSYN.Avail    fixed PUBLIC;  /* true if DDSYN avail     */dcl DDT.DDSYN.Rev#     fixed PUBLIC;  /* DDSYN rev code          */dcl DDT.UDIO.Avail     fixed PUBLIC;  /* true if UDIO avail      */dcl DDT.UDIO.Rev#      fixed PUBLIC;  /* UDIO rev code           */dcl DDT.Lun#           fixed PUBLIC;  /* holds lun# in use       */dcl DDT.Mode           fixed PUBLIC;  /* Holds bits to be        */                                      /* written to Front End    */                                      /* Command Byte.           */                                      /*                         */                                      /* 0 = output              */                                      /* 1 = input               */                                      /* 2 = go bit              */dcl DDT.Format         fixed PUBLIC;  /* format in use           */dcl DDT.Sync           fixed PUBLIC;  /* sync to use             */dcl DDT.Use.DDSYN      fixed PUBLIC;  /* sync to DDSYN           */dcl DDT.In.Sync        fixed PUBLIC;  /* true if PLL is synced   */dcl DDT.Good.Word.Clk  fixed PUBLIC;  /*  0 - initialized        */                                      /* -1 - no clock, msg sent */                                      /* +1 - good word clock    */dcl Stop.DDT.Units     fixed PUBLIC;  /* true if trying to stop  *//* Info for port-specific DDT information: */#if (inc.multi.udio)						  		/* multi udio included	  	*/	dcl DDT.MULTI.Avail    fixed PUBLIC;   /* true if MULTI avail     */	dcl DDT.Connect.Mode   fixed PUBLIC;  	/* 0: connect thru D24     */													  	/* 1: connect thru BMC     */		dcl port.ddt        (max.ports) fixed PUBLIC; /* true if dedicated ddt    */	dcl port.ddt.rev#   (max.ports) fixed PUBLIC; /* avail.  holds rev#       */	dcl port.ddt.mode   (max.ports) fixed PUBLIC; /* holds DDT.MODE for port  */#else	dcl DDT.MULTI.Avail    lit '0';	dcl DDT.Connect.Mode   lit '0';#endif	/* Routine to Connect to DDT Hardware: *//* note: routine should not enable & disable since we are sometimes *//* called with interrupts off                                       *//* DDT.Connect is called to connect to a DDT unit.   If DDT.Connect.Mode *//* is zero,   then the routine connects to a routable DDT unit via       *//* the dedicated D24.   Otherwise,  we connect to a DDT unit on a buffer *//* memory card.   NOTE:  In this case,  the correct d24 card and the     *//* correct SCSI port must be selected before DDT Connect is called.      */DDT.connect: proc (mode) PUBLIC;   dcl mode     fixed;   dcl lun      fixed;   dcl i        fixed;   /* Connect to DDT through dedicated D24 board: */   if mode = 0 then do;      call Select.D24(DDT.D24.#);      write(ScsiData) = bits(0);           /* target 0                     */      write(ScsiBus ) = S$SEL;             /* gnd SEL                      */      do i = 0 to 1; end;                  /* short delay                  */      write(ScsiBus ) = S$SEL \ S$BSY;     /* create our own busy          */      do i = 0 to 1; end;                  /* short delay                  */      write(ScsiData) = 0;                 /* clear data bus               */      write(ScsiBus ) = S$BSY;             /* remove SEL                   */      write(ScsiBus ) = S$BSY \ S$REQ;           /* create our own REQ     */      write(ScsiData) = DDT.Lun#;                /* this is DDT lun#       */      write(ScsiBus ) = S$BSY \ S$REQ \ S$ACK;   /* and ACK         */      write(ScsiBus ) = S$BSY \         S$ACK;   /* remove REQ      */      write(ScsiBus ) = S$BSY;                   /* remove ACK      */      write(ScsiData) = 0;                 /* remove lun# from data lines  */      write(ScsiBus ) = 0;                 /* remove fabricated busy       */   end;   /* Connect to DDT through Buffer Memory Card.  Must select d24 and */   /* correct port before accessing DDT unit.                         */   else call Targ0.Connect(DDT.Lun#);end DDT.connect;/* $page - Procedures to read and write registers in DDT Hardware *//* Read.Selected.DDT.Register performs two functions:      1.  It writes the global variable DDT.MODE out to the Front End.          Command Byte.    Bits must be set in this word to set the          direction (in or out) and Front End. Go.      2.  It reads the specified register and returns that          as the procedure value */Read.Selected.DDT.Register: proc(reg#) PUBLIC;   dcl reg# fixed;   /* pass register ID code */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next \ DDT.Mode;   write(ScsiByte) = LAD_Read    \ reg#;   return read(ScsiWord);end Read.Selected.DDT.Register;Read.Selected.DDT.Byte: proc(reg#) PUBLIC;   dcl reg# fixed;   /* pass register ID code */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next \ DDT.Mode;   write(ScsiByte) = LAD_Read    \ reg#;   return read(ScsiByte);end Read.Selected.DDT.Byte;/* Write.Selected.DDT.Register also performs two functions:      1.  It writes the global variable DDT.MODE out to the Front End          Command Byte.    Bits must be set in this word to set the          direction (in or out) and Front End. Go.      2.  It writes the passed value the specified register. */Write.Selected.DDT.Register: proc(reg#, val) PUBLIC;   dcl reg# fixed;   /* pass register ID code */   dcl val  fixed;   /* and value to write    */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next    \ DDT.Mode;   write(ScsiByte) = LAD_Write   \ reg#;   write(ScsiWord) = val;end Write.Selected.DDT.Register;Write.Selected.DDT.Byte: proc(reg#, val) PUBLIC;   dcl reg# fixed;   /* pass register ID code */   dcl val  fixed;   /* and value to write    */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next    \ DDT.Mode;   write(ScsiByte) = LAD_Write   \ reg#;   write(ScsiByte) = val;end Write.Selected.DDT.Byte;/* Convenient routines to get at registers */Read.Selected.DDT.Word.Clock: proc PUBLIC;   return Read.Selected.DDT.Register(LAD_FE_Word_Clock);end Read.Selected.DDT.Word.Clock;Read.Selected.DDT.Front.End.Address.Pointer: proc PUBLIC;   return Read.Selected.DDT.Register(LAD_FE_Address_Pointer);end Read.Selected.DDT.Front.End.Address.Pointer;Set.Selected.DDT.Front.End.Address.Pointer: proc (val) PUBLIC;   dcl val fixed;    /* value to write to front end address pointer */   call Write.Selected.DDT.Register(LAD_FE_Address_Pointer, val);end Set.Selected.DDT.Front.End.Address.Pointer;/* $page - routines to transfer data to/from DDT Buffer Memory *//* Procedure to start transfer to or from DDT */Start.DDT.Read: proc(chan#, address, #wrds, mode) PUBLIC;   dcl chan#   fixed;    /* channel, 0 or 1               */   dcl address fixed;    /* address in buffer             */   dcl #wrds   fixed;    /* # of words to transfer        */   dcl mode    fixed;    /* SCSI_Target_Mode              */                         /* SCSI_Incr_Inhib               */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = SCSI_Cmd_Byte                    \ mode                   \ shl(chan#,2)                   \ SCSI_go                   \ SCSI_dir_in;   write(ScsiWord) = address;   write(ScsiWord) = not(#wrds)-1;end Start.DDT.Read;/* 12/23/88 - cj - bug in start.ddt.write - unit requests an extra *//* word of data that is not stored in memory.    Follow transfer   *//* by sending an extra word.                                       */Start.DDT.Write: proc(chan#, address, #wrds, mode) PUBLIC;   dcl chan#   fixed;    /* channel, 0 or 1               */   dcl address fixed;    /* address in buffer             */   dcl #wrds   fixed;    /* # of words to transfer        */   dcl mode    fixed;    /* SCSI_Target_Mode              */   call DDT.Connect(DDT.Connect.Mode);   write(ScsiByte) = SCSI_Cmd_Byte                    \ mode                   \ shl(chan#,2)                   \ SCSI_go                   \ SCSI_dir_out;   write(ScsiWord) = address;   write(ScsiWord) = not(#wrds);   /* Note: hardware will ask for #wrds + 1 */                                   /* but last word does not get stored     */end Start.DDT.Write;/* Procedure to provide ramp up or ramp down to data in        *//* Scsi DDT Buffer Memory                                      *//* Construct.DDT.Ramp.In:  this procedure constructs a short ramp *//* up of data in the DDT buffer memory                            *//* it is passed a channel #,  and address in the buffer memory    *//* to start the ramp up at                                        *//* code is simplified because buffer is 64K words long            */Construct.DDT.Ramp.In: proc(chan#, address) PUBLIC;   dcl chan#     fixed;   /* ddt channel #       */   dcl address   fixed;   /* where in buffer     */   dcl (accum  ) fixed;   dcl (i,j    ) fixed;   accum = 1024;                      /* for 32 word fade in */   call Start.DDT.Read(chan#, address, 32, SCSI_Target_Mode);                                      /* into misc.buf             */   write("313")=addr(misc.buf(0));   rpc 32;                            /* read in data              */   write("373")=read(ScsiWord);       /* data to ramp in           */   call Start.DDT.Write(chan#, address, 32, SCSI_Target_Mode);   write("313")=addr(misc.buf(0));   do i=0 to 31;      load (read("373") xor "100000");   /* get orig data element    */      mul accum;                         /* fade in - start small    */      j=ures;                       load "100000";                     /* get offset binary 0      */      mul -accum;                             accum=accum+2048;                        write(ScsiWord) = (j+ures) xor "100000";   end;   if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */end Construct.DDT.Ramp.In;/* Construct.DDT.Ramp.Out:  this procedure constructs a short ramp *//* down of data in the DDT buffer memory                           *//* it is passed a channel #,  and address in the buffer memory    *//* to END the ramp down at                                        *//* code is simplified because buffer is 64K words long            *//* Note:   The address passed to this routine is the address of   *//* the first sample AFTER the end of the ramp down.   This        *//* is generally the most convenient address to compute.           *//* The ramp down is constructed prior to the address passed,      *//* so that digital zeroes (or the next audio segment with a       *//* ramp up) can be written starting at the passed address         */Construct.DDT.Ramp.Out: proc(chan#, address) PUBLIC;   dcl chan#     fixed;   /* ddt channel #       */   dcl address   fixed;   /* where in buffer     */   dcl (accum  ) fixed;   dcl (i,j    ) fixed;   address = address - 32;        /* 32 word fade         */   accum = -1024;                 /* for 32 word fade out */   call Start.DDT.Read(chan#, address, 32, SCSI_Target_Mode);                                      /* into misc.buf             */   write("313")=addr(misc.buf(0));   rpc 32;                            /* read in data              */   write("373")=read(ScsiWord);       /* data to ramp down         */   call Start.DDT.Write(chan#, address, 32, SCSI_Target_Mode);   write("313")=addr(misc.buf(0));   do i=0 to 31;      load (read("373") xor "100000");   /* get orig data element    */      mul accum;                         /* fade out - start big     */      j=ures;                       load "100000";                     /* get offset binary 0      */      mul -accum;                             accum=accum-2048;                  /* decrement cross fade     */      write(ScsiWord) = (j+ures) xor "100000";   end;   if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */end Construct.DDT.Ramp.Out;/* Turn off DDT output as well *//* Let's try to be a sport and turn off the DDT output gently,  IE   *//* with no clicks and pops.   This will be accomplished by providing *//* a short ramp down at the end of the digital data,  and by         *//* providing a stream of digital zeroes during which time we turn    *//* the go bit off                                                    *//* For the routable 2-track DDT,  we will turn off the output        *//* by clearing the GO bit.   For the multi-track DDT case,  we       *//* will turn off the output by setting the MUTE bit.                 */Gently.Turn.Off.DDT.Output: proc PUBLIC swapable;   dcl (i,j,k) fixed;   /* Method to construct down ramp:                      */   /*                                                     */   /*    1. Read the front end address pointer to see     */   /*       what sample is going out the door as we       */   /*       speak.   compute what sample # will be        */   /*       going out the door 5 milliseconds from now    */   /*       so that we can spend up to 5 msecs            */   /*       constructing the down ramps                   */   /*                                                     */   /*    2. construct down ramps in both channels         */   /*       on the data beginning 5 msecs from now        */   /*                                                     */   /*    3. then store zeroes in the buffer after         */   /*       the ramped down data                          */   /*                                                     */   /*    4. wait for the DDT to play through the          */   /*       ramp down and into the zeroes.                */   /*                                                     */   /*    5. turn off the go bit while digital zeroes      */   /*       are being played out                          */   /*       so no clicks and pops are created             */   /* Give ourselves 5 msec to construct the ramp down    */   if (DDT.Mode & FE_dir_In) = 0   then do;      i = shr(Current.Rate,1); /* This is # of samples in 5 milliseconds */      j = Read.Selected.DDT.Front.End.Address.Pointer;  /* get current pointer */      /* note: took approx 1 msec to construct ramp out.  tested */      /* 5/20/88                                                 */      call Construct.DDT.Ramp.Out(0, j + i + 32);      call Construct.DDT.Ramp.Out(1, j + i + 32);      call Start.DDT.Write(0, j + i + 32, 512,                            SCSI_Target_Mode);   /* follow ramp out with */      rpc 256;                                  /* 256 samples of       */      write(ScsiWord) = 0;                      /* digital zeroes.      */                                                /* this should give us  */                                                /* min of 2.5 msecs to  */      rpc 256;                                  /* turn off the go bit  */      write(ScsiWord) = 0;                      /* (at 100 Khz)         */      if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */      k = Real.Milliseconds;                    /* timeout timer        */      /* wait here for address register to reach past the end */      /* of the ramp down.   Provide a 20 msec time out timer */      /* in case no clock pulses are being received.          */      /* Note: signed comparisons can be used here since      */      /* the numbers are close together                       */      do while (Read.Selected.DDT.Front.End.Address.Pointer <= (j + i + 32))      and      (Real.Milliseconds < k + 25);         end;   end;   if DDT.Connect.Mode = 0   then DDT.Mode = DDT.Mode & (not(FE_Go)); /* clear go bit     */   else DDT.Mode = DDT.Mode \ (FE_Mute   ); /* or set mute bit  */   call Read.Selected.DDT.Word.Clock;       /* write that out   */   /* zero out output registers to provide digital zeroes  */   /* in case we messed up above (or there was no clock)   */   call Write.Selected.DDT.Register(LAD_Scsi_Front_End_A, 0);   call Write.Selected.DDT.Register(LAD_Scsi_Front_End_B, 0);   if DDT.Connect.Mode <> 0  /* zero out other bits if doing 20/24 bit xfers */   then do;      call Write.Selected.DDT.Register(LAD_FEA_24_Mode, 0);      call Write.Selected.DDT.Register(LAD_FEB_24_Mode, 0);   end;end Gently.Turn.Off.DDT.Output;/* Get initilization routines */insert ':lod:ddtinit';end ddtmod;