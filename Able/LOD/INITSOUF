/* INITSOUF - more initialization, initialization driver *//* 01/06/94 - pf - invalidate.track.dir after mount all drives  *//* 02/11/92 - cj - allow multi udio to work with DDSYN          *//* 08/14/91 - cj - Added UDIO/DDSYN stuff                       *//* 08/14/91 - cj - Added DataEnd.S# for bug fix                 *//* 03/26/90 - cj - Code for new tape format                     *//*                 Moved init11 to INITSOUF                     *//* 03/23/89 - cj - moved code around                            */   /* read song/track directory from disk */   Init11:proc swapable;  /* check directory                */      if track#<max.tracks then do;         if track.available(track#)<>0         then do;            tptr=track#*total.stride;            port#=track.port#;            if port.io(port#)=0      /* if no reset in progress      */            then do;               if sec#=0 then do;    /* check contents of disk:      */                  i=readdata(0,magic.sec#,misc.buf,256);                  if i<>0 then do;    /* readdata error              */                     call check.and.log.retry;                     return;                  end;                  /* If this track shares disks with an earlier drive, */                  /* then do not look for song directory or magic      */                  /* sector information.   Just read in allocation     */                  /* directory.                                        */                  if (track.data.msb(track#) <> 0)                  or (track.data.lsb(track#) <> 0)                  then do;                     /* read in allocation directory below */                  end;                  /* See if track has been initialized and contains */                  /* valid data for song directory,   or see        */                  /* if track has been re-initialized,  or see      */                  /* if track contains random numnbers:             */                  else if   (misc.buf(0)<>magic#1)                  or        (misc.buf(1)<>magic#2)                  then do;                     track.retry(track#)=track.retry(track#)+1;                     if track.retry(track#)<3  /* give drive a chance */                     then return;              /* to change it's mind */                     track.retry   (track#)=0;                     if ((misc.buf(0)<>magic#2)   /* see if not an initialized track */                     or  (misc.buf(1)<>magic#1))                     then do;                        sec#=1;       /* enter above code on retry */                        return;       /* to initialize track       */                     end;                     /* else see below - just read in adir.  skip the */                     /* check to see if there is a song directory     */                  end;                  else do;                     /* read in song directory from disk */                     /* save away error counter for this */                     /* track so we can find most        */                     /* common directory                 */                     track.error.msb(track#) = misc.buf(2);                     track.error.lsb(track#) = misc.buf(3);                     write(mam)=song.xmsec#;                     i=readdata(0,song.sec#,loc(0),num.songs*song.len);                     if i<>0 then do;       /* readdata error              */                        call init.song.dir; /* re-init song directory      */                        call check.and.log.retry;                        return;                     end;                     /* re-initialize song directory in case we       */                     /* have to initialize some tracks later on.      */                     /* We will read in the correct song directory    */                     /* later once we find out which one              */                     /* to use:                                       */                     call init.song.dir;                      /* mark that this track has valid song directory */                     /* and magic sector.   we will find the most     */                     /* common one later and actually use it          */                     valid.info(track#)=1;                     /* save away zero.sec# and data.sec# so we can   */                     /* decide to use the new or the old format       */                     /* once we find the most common catalog          */                     track.zero.sec#(track#) = misc.buf(5);                     track.data.sec#(track#) = misc.buf(6);                  end;                  /* read in allocation directory for this track */                  write(mam)=adir.xmsec#+track#;                  i=readdata(0,track.adir.sec(track#),loc(0),adir.len);                  if i<>0 then do;       /* readdata error           */                     call check.and.log.retry;                     return;                  end;                  track#=track#+1;  /* good track */                  return;               end;               /* write data to disk to */               /* initialize track:     */               if sec#=1 then do;                  /* No need to initialize tracks that share a drive */                  /* with earlier tracks.                            */                  if (track.data.msb(track#) <> 0)                  or (track.data.lsb(track#) <> 0)                  then do;                     track#=track#+1;                     sec#=0;                     if   ((erase1 = 3456)         /* if doing erase all */                     and   (erase2 = 5432))        /* begin with write   */                     then sec#=1;                     return;                  end;                  call log.error('Initializing Direct-to-Disk ');                  call append.tape.mes(port#);               end;               if sec#<new.data.sec# then do;                  if sec# < track.sec#      /* write out zeroes        */                  then do;                  /* up to track.sec#        */                     i=track.sec#-sec#;                     if i igt 200 then i=200;                     misc.buf(0)=0;                     j=writedata(0,sec#,misc.buf,1,i);                  end;                  else if (sec# < disk.info.sec#) /* write out track directories */                  then do;                                       i=disk.info.sec#-sec#;                     if i igt 200 then i=200;                     j=writedata(0,sec#,track.dir,num.tracks*track.len,i);                  end;                  else do;                    /* else write out zeroes                 */                     i=new.data.sec#-sec#;                     if i igt 200 then i=200;                     misc.buf(0)=0;                     j=writedata(0,sec#,misc.buf,1,i);                  end;                  if j<>0 then do;             /* write error encountered */                     call check.and.log.retry;                     if track.available(track#) = 0                     then do;                        sec#=0;                        if   ((erase1 = 3456)         /* if doing erase all */                        and   (erase2 = 5432))        /* begin with write   */                        then sec#=1;                     end;                     return;                  end;                  sec#=sec#+i;                  return;               end;               /* after zeroing out initial sectors, */               /* write out blank song directory     */               write(mam)=song.xmsec#;               i=writedata(0,song.sec#,loc(0),num.songs*song.len,1);               if i<>0 then do;          /* write error encountered               */                  call check.and.log.retry;                  if track.available(track#) = 0                  then do;                     sec#=0;                     if   ((erase1 = 3456)         /* if doing erase all */                     and   (erase2 = 5432))        /* begin with write   */                     then sec#=1;                  end;                  return;               end;               /* write out special magic sector to */               /* indicate initialized track but    */               /* no valid song directory.  This    */               /* way, if we loose a drive, we      */               /* hopefully can recover what song   */               /* info is on the other drives       */               do i=0 to 255;                  misc.buf(i)=0;               end;               misc.buf(0)=magic#2;    /* first write out #2, #1 */               misc.buf(1)=magic#1;    /* reversed later (above) */               if   ((erase1    = 3456)  /* if doing erase all   */               and   (erase2    = 5432)               and   (eraselong = 1   ))               then misc.buf(4) = 1;     /* set to 1 for long mode */               if   ((erase1    = 3456)  /* if doing 4 trk erase  */               and   (erase2    = 5432)               and   (eraselong = 2   ))               then misc.buf(4) = 2;     /* set to 2 for 4 trk mode */               call fill.magic.sec#(port#, track#, misc.buf);               i=writedata(0,magic.sec#,misc.buf,256,1);               if i<>0 then do;          /* write error encountered               */                  call check.and.log.retry;                  if track.available(track#) = 0                  then do;                     sec#=0;                     if   ((erase1 = 3456)         /* if doing erase all */                     and   (erase2 = 5432))        /* begin with write   */                     then sec#=1;                  end;                  return;               end;               /* after initializing this track,  move on to next */               /* track to see if there is a valid directory      */               /* one some later track                            */               track#=track#+1;               sec#=0;               if   ((erase1 = 3456)         /* if doing erase all */               and   (erase2 = 5432))        /* begin with write   */               then sec#=1;               return;            end;            /* waiting for reset */            if (real.seconds < port.timer(port#))            then return;              /* waiting                        */            port.io(port#)=0;            track.retry(track#)=track.retry(track#)+1;            if track.retry(track#)<3  /* give drive a chance      */            then return;              /* to change it's mind      */            track.status   (track#) = S$BadBusState;            track.available(track#) = 0;  /* could not start it up    */            sec#=0;            if   ((erase1 = 3456)         /* if doing erase all */            and   (erase2 = 5432))        /* begin with write   */            then sec#=1;            return;         end;         track#=track#+1;         return;      end;      initialize=initialize+1;   end Init11;   /* $page  See if we have a valid song Directory.  Use it if so */   Init11A:proc swapable;      /* Look through each track.  if this track has a valid song */      /* directory, see if other tracks had a header with the     */      /* same error #.  Pick the most commonly occurring          */      /* song directory to use.                                   */      do i = 0 to max.tracks-1;         if valid.info(i) <> 0         then do;            j = 0;            error.msb = track.error.msb(i);            error.lsb = track.error.lsb(i);            do k = 0 to max.tracks-1;               if  (valid.info(k) <> 0)             /* will always */               and (error.msb = track.error.msb(k)) /* find        */               and (error.lsb = track.error.lsb(k)) /* ourselves   */               then j = j + 1;            end;            valid.info.ctr(i) = j;         end;      end;      /* Find most commonly occurring error code */      i = 0;                         /* find first track with a */      do while (i   < max.tracks)    /* readable song directory */      and      (valid.info(i) = 0);         i = i+1;      end;      if i < max.tracks              /* if one was found,  see if */      then do;                       /* other track had a better  */                                     /* song directory            */         do j = i+1 to max.tracks-1;            if  (valid.info(j) <> 0)            and (valid.info.ctr(j) > valid.info.ctr(i))            then i = j;         end;         track# = i;                 /* read song dir from here   */         tptr   = track#*total.stride;         port#  = track.port#;         write(mam)=song.xmsec#;         i=readdata(0,song.sec#,loc(0),num.songs*song.len);         if i<>0 then do;                   /* if readdata error occurs */            call init.song.dir;             /* then re-init directory   */            call check.and.log.retry;       /* count errors             */            if track.available(track#) = 0  /* if dead,  then has no    */            then valid.info(track#) = 0;    /* valid info               */            return;         end;         song.dir.valid = 1;                /* else we have a valid     */                                            /* song directory           */         song.dir.track = track#+1;         /* from here                */         zero.sec# = track.zero.sec#(track#);  /* see if current data   */         data.sec# = track.data.sec#(track#);  /* is in new or old fmt  */         if zero.sec#<>new.zero.sec# then zero.sec#=old.zero.sec#; /* must be old format */         if data.sec#<>new.data.sec# then data.sec#=old.data.sec#; /* on disk            */         error.msb = track.error.msb(track#);         error.lsb = track.error.lsb(track#);         /* Read in other system defaults from magic sector for this track */         i=readdata(0,magic.sec#,misc.buf,256);         if i = 0 then do;            DDT.Format = Misc.Buf(16) & 255;            DDT.Sync   = shr(Misc.Buf(16), 8);         end;      end;      initialize=initialize+1;      track#=0;   end Init11A;   /* Check for song directory: */   Init12:proc swapable;    /* check for song directory found */      if track#<max.tracks then do;         if track.available(track#)<>0         then do;            tptr=track#*total.stride;            port#=track.port#;           /* look up port for drive 0 */            if port.io(port#)=0            then do;               if  (song.dir.valid         = 0)  /* if no directory    */               and (track.data.msb(track#) = 0)  /* and this is start  */               and (track.data.lsb(track#) = 0)  /* of this drive      */               then do;                  /* write out magic #'s to reflect     */                  /* valid data stored on track:        */                  do i=0 to 255;                     misc.buf(i)=0;                  end;                  misc.buf(0)=magic#1;                  misc.buf(1)=magic#2;                  if   ((erase1    = 3456)  /* if doing erase all   */                  and   (erase2    = 5432)                  and   (eraselong = 1   ))                  then misc.buf(4) = 1;     /* set to 1 for long mode */                  else if ((erase1    = 3456)  /* if doing erase all   */                  and      (erase2    = 5432)                  and     (eraselong = 2   ))                  then misc.buf(4) = 2;     /* set to 2 for 4 trks/drive */                  else if longconfig(track#)=1                  then misc.buf(4) = 1;     /* set to 1 for long mode */                  else if longconfig(track#)=2                  then misc.buf(4) = 2;     /* set to 2 for 4 trks/drive */                  misc.buf(5)=new.zero.sec#;                  misc.buf(6)=new.data.sec#;                  call fill.magic.sec#(port#, track#, misc.buf);                  i=writedata(0,magic.sec#,misc.buf,256,1);                  if i<>0 then do;          /* write error encountered               */                     call check.and.log.retry;                     return;                  end;                  /* make sure they got there: */                  misc.buf(0)=0;                  misc.buf(1)=0;                  i=readdata(0,magic.sec#,misc.buf,256);                  if i<>0 then do;    /* readdata error              */                     call check.and.log.retry;                     return;                  end;                  if  (misc.buf(0)<>magic#1)                  or  (misc.buf(1)<>magic#2)                  then do;                     call check.and.log.retry;                     if track.available(track#) = 0                     then track.status(track#)=S$CatError;                     return;                  end;                  /* this track now has valid info (basically,  an */                  /* empty song directory:                         */                  valid.info(track#) = 1;               end;               track#=track#+1;               return;            end;            /* reset in progress */            if (real.seconds < port.timer(port#))            then return;              /* waiting                        */            port.io(port#)=0;            track.retry(track#)=track.retry(track#)+1;            if track.retry(track#)<3  /* give drive a chance      */            then return;              /* to change it's mind      */            track.status   (track#) = S$BadBusState;            track.available(track#) = 0;  /* could not start it up    */            return;         end;         track#=track#+1;         return;      end;      initialize=initialize+1;   end Init12;   /* Continue with initialization: read in cue directory */   Init13:proc swapable;           /* done with initialization       */      if    (erase1    = 3456)     /* if doing erase long or erase   */      and   (erase2    = 5432)     /* 4 track                        */      and   ((eraselong = 1 )       or     (eraselong = 2 ))      then do;                     /* after erase long - go back and reconfigur for long system */         erase1       = 0;         erase2       = 0;         initialize   = 1;         if eraselong = 1         then call log.error('Setting Up Long Configuration');         else call log.error('Setting Up 4 Track Configuration');         return;      end;      erase1 = 0;                /* done with erase (if needed) */      erase2 = 0;      /* If no valid song directory was found,  then */      /* all song directories have been initialized  */      /* above.   Pick the first one to use as our   */      /* new directory                               */      if song.dir.valid=0 then do;         /* no valid directory     */         do i = (max.tracks-1) to 0;       /* find first available   */            if (track.available(i) <> 0)   /* track with valid       */            and (valid.info    (i) <> 0)   /* directory (just        */            then do;                       /* written out above)     */               song.dir.valid = 1;         /* and use it             */               song.dir.track = (i+1);            end;         end;         error.msb = 0;                    /* start error counter    */         error.lsb = 0;                    /* from zero              */         zero.sec# = new.zero.sec#;        /* new format             */         data.sec# = new.data.sec#;        /* if no song dir valid   */      end;      call STR32(0, zero.sec#, Zero.S#);   /* compute sample # of    */      call SHL32(Zero.S#, 8);              /* digital zeroes         */      track#  = song.dir.track-1;          /* look for cue dir here first */      ldrive# = 0;      sec#    = 0;      /* Define how much room on the disk there is for cues: */      max.store.disk = zero.sec#-disk.cue.sec#;      initialize = initialize + 1;   end Init13;   Init14:proc swapable;              /* read in cue directory from disk */      local.abort:proc;         call zero.cue.dir;           /* zap any half read cue dir */         track#  = track#+1;          /* go on to next track       */         if track# = max.tracks then track# = 0; /* wrap           */         ldrive# = ldrive#+1;         /* use ldrive# to count trks */         sec#=0;                      /* reset to start            */      end local.abort;      local.transfer:proc(first,last,maxs,maxw,base);         dcl (first) fixed;                     /* base sector #   */         dcl (last)  fixed;                     /* ending sec#     */         dcl (maxs,maxw) fixed;                 /* len (s,w)       */         dcl (base)  fixed;                     /* store base      */         maxs = maxs + shr(maxw+255,8);         if   (sec#>=first)                    and  (sec#< last )         then do;            j = sec#-first;              /* get rel sec pos  */            if j ilt maxs            then do;               k = maxs - j;             /* get # to read    */               if k > 100 then k = 100;  /* limit            */               write(mam)=base+j;        /* read to here     */               i=readdata(0,sec#,loc(0),shl(k,8));               if i<>0 then do;                      call local.abort;                  return 1;               end;               sec#=sec#+k;               return 1;            end;            sec#=last;           /* else done with this segment */         end;         return 0;      end local.transfer;      if ldrive#<max.tracks then do;     /* look for track with cue dir */         if  (track.available(track#)<> 0)  /* make sure track is avail */         and (valid.info(track#)     <> 0)  /* and has valid info       */         then do;            tptr  = track#*total.stride;            port# = track.port#;            /* look up port for drive 0 */            if sec#=0 then sec#=disk.info.sec#;    /* start here */            if sec#=disk.info.sec# then do;        /* read magic */               misc.buf(0)=0;               misc.buf(1)=0;               i=readdata(0,sec#,misc.buf,256);               if i<>0 then do;                      call local.abort;                  return;               end;               cue.num      = misc.buf(2);  /* num of cues in data area */               cue.numsec   = misc.buf(3);  /* num of secs of cue def   */               cue.numwrd   = misc.buf(4);  /* num of wrds of cue def   */               num.of.alloc = misc.buf(5);  /* num of entries in alloc  */               do j=0 to 2;                  num.of(j) = misc.buf(6+j);               end;               if  (misc.buf(0)<>magic#1)   /* double check data        */               or  (misc.buf(1)<>magic#2)               or  (num.of.alloc igt (max.#.of.cues-2))                 or  ((cue.sec# + cue.numsec + 1) igt max.store.secs)               then do;                  call local.abort;                  return;               end;               sec# = disk.alloc.sec#;      /* move on         */               return;            end;            if local.transfer(disk.alloc.sec#,                              disk.alph.sec#,                              0,shl(num.of.alloc,1),allc.sec#)             then return;            if local.transfer(disk.alph.sec#,                              disk.time.sec#,                              0,num.of(alph.sort),alph.sec#)             then return;            if local.transfer(disk.time.sec#,                              disk.smpt.sec#,                              0,num.of(time.sort),time.sec#)             then return;            if local.transfer(disk.smpt.sec#,                              disk.cue.sec#,                              0,num.of(smpt.sort),smpt.sec#)             then return;            if local.transfer(disk.cue.sec#,                              zero.sec#,                              cue.numsec,cue.numwrd,cue.sec#)             then return;            /* Complete cue data base has been read in.  */            ldrive# = max.tracks;   /* cue directory successfully read in */            return;         end;         call local.abort;         return;      end;      initialize = initialize + 1;   end Init14;   /* $page - Initialization - Inspect DDT Hardware */   Init15:proc swapable;      /* See if Mono DDT Hardware is in machine */      write(ScsiSel) = S$SelectEnable \ Scsibits (DDT.d24.#);  /* select d24 to DDT subsystem */      if (read(ScsiSel) & Scsibits(DDT.d24.#)) <> 0 then do;   /* board exists                */         write(ScsiBus ) = 0;         write(ScsiData) = 0;         if  ((read(ScsiBus )&S$BusMask )<>0)          /* make sure idle    */         or  ((read(ScsiData)&S$DataMask)<>0)         then do;            print 'Could not reset DDT D24';         end;         else do;            print 'DDT D24 exists';            /* Look for UDIO: */            DDT.Lun# = DDT.UDIO.Lun#;         /* look for UDIO first      */            call DDT.Connect(0);              /* connect to DDT           */            do i=1 to 10; end;                /* short delay              */            if (read(ScsiBus)&S$BSY) <> 0     /* if Busy, then is there   */            then do;               DDT.Hardware.Avail  = 1;               DDT.UDIO.Avail      = 1;                write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next;               write(ScsiByte) = LAD_Read \ LAD_Revision_#;               DDT.UDIO.Rev#   = Read(ScsiByte);               print 'UDIO Hardware Avail, rev: ',octal(DDT.UDIO.Rev#);            end;            /* Look for DDSYN: */            DDT.Lun# = DDT.DDSYN.Lun#;        /* look for DDSYN now       */            call DDT.Connect(0);              /* connect to DDT           */            do i=1 to 10; end;                /* short delay              */            if (read(ScsiBus)&S$BSY) <> 0     /* if Busy, then is there   */            then do;               DDT.Hardware.Avail  = 1;               DDT.DDSYN.Avail     = 1;                write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next;               write(ScsiByte) = LAD_Read \ LAD_Revision_#;               DDT.DDSYN.Rev#   = Read(ScsiByte);               print 'DDSYN Hardware Avail, rev: ',octal(DDT.DDSYN.Rev#);            end;         end;      end;      initialize = initialize + 1;   end Init15;   /* $page - Initialization - Done with Initialize */   Init16:proc (version) swapable;                   /* finish initialize      */      dcl version array;      do i=0 to num.songs-1;                   /* clean out all stars */         call gsong.dir(i*song.len+song.star); /* in project records  */         write(md)=0;      end;      /* find max recording time avail: */      call init.signal.display;      amsb=0; alsb=0;                      		/* initialize             	*/	  cmsb=0; clsb=0;      do track#=0 to max.tracks-1;         		/* see how many trks      	*/         if track.available(track#)<>0     		/* avail in hardware      	*/         then do;           		    dtd.max.tracks=track#+1;       		/* count # of tracks     	*/           		    bmsb=track.numsec.msb (track#);   	/* get length avail    		*/            blsb=track.numsec.lsb (track#);           		   	if ((bmsb != 0) || (blsb != 0))		/* nonzero length			*/			{				if  ((bmsb igt amsb))          	/* get largest sectr #    	*/				or  ((bmsb  =  amsb)				and  (blsb igt alsb))				then do;				   amsb=bmsb; alsb=blsb;				end;						if (cmsb == 0 && clsb == 0)	   	/* capture first nonzero  	*/					{cmsb = bmsb; clsb = blsb;}				else							/* find shortest track		*/				{					if (( bmsb ILT cmsb )					or  ((bmsb  =  cmsb)					and  (blsb ILT clsb)))						{cmsb = bmsb; clsb = blsb;}				}			}		   		    track.avail.bits=track.avail.bits\bits(track#);           		    if  (track.data.msb(track#) = 0)            and (track.data.lsb(track#) = 0)            then track.info.bits = track.info.bits\bits(track#);           		    call set.track.display(track#,track#.red\track#.green);  /* turn on track light now */         end;         else call set.track.display(track#,0);  /* turn off track light */      end;      /* check for track with partially broken drive chain */      do track#=0 to max.tracks-1;         /* see how many trks      */         if track.available(track#)<>0     /* avail in hardware      */         then do;            if (amsb<>track.numsec.msb (track#))            or (alsb<>track.numsec.lsb (track#))            then track.status(track#) = S$BadDrive;         end;      end;      /* compute recording time available */      call STR32(cmsb, clsb, DataEnd.S#);/* save end of disk too  */      call SHL32(DataEnd.S#, 8);      if (cmsb<>0) or (clsb igt data.sec#)      then do;         if clsb ilt data.sec# then cmsb=cmsb-1;         clsb=clsb-data.sec#;      end;      else clsb=0;      call STR32(0,data.sec#,Data.S#);   /* get sample # of start */      call SHL32(Data.S#,    8      );   /* of data area          */      call COPY32(Data.S#, Cue.Data.S#); /* tell cue routines too */      bitmsb=cmsb; bitlsb=clsb;      call ratio_multiply(256,50000);	/* compute # of seconds at 50.000 khz */      call unround;      dtd.max.secs=bitlsb;      call process.all.cues(2,0,0);		/* update any old format cues */      i=0;      dtd.max.inputs=0;      do while (i<8)&((adconfig&bits(i))<>0);         i=i+1; dtd.max.inputs=dtd.max.inputs+2;      end;      send.init.info=1;      if screen<>0 then send.screen.info=1;      new.dtd.song#=1;             /* look up rate, set song data msb, etc */      /* check for good directory */      call check.for.song.overlap;      if songs.overlap <> 0      then do;         log.buf(0)=0;             /* give this message priority  */         call log.error('Warning:');         call log.overlap.message;      end;      else do;         if (format.drives=1) then do;            call log.error('FORMAT Of All Drives Complete');         end;         else if (dismount.drives=1) then do;            call log.error('Dismount Of All Drives Complete');         end;         else if (mount.drives=1) then do;            call log.error('Mount Of All Drives Complete');         end;         else do;            call log.error('Direct-to-Disk System ');            call append.log.string(version);            call append.log.string(' Now Running');         end;      end;      print '  Polynums:    ',polynums;      print '  Polynumv:    ',polynumv;      print '  Polyamount:  ',polyamount;      print '  Avail ports: ',num.available.ports;      print '  Avail Tracks:',num.available.tracks;      print '  Proj Dir     ',song.dir.track-1;      do track#=0 to max.tracks-1;         if track.available(track#)<>0 then do;            bmsb=track.numsec.msb (track#);   /* get length avail    */            blsb=track.numsec.lsb (track#);            print '  Trk:',track#,'  Storage:',bmsb,blsb,;            port# = track.port.ix (track#);			#if (inc.multi.udio)				/* multi udio included	  		  */				if port.ddt (port#) <> 0 then do;				   print '   Multi UDIO Rev#: ',Port.DDT.Rev#(port#),;				end;				else do;				   print '   No Multi UDIO          ',;				end;			#endif            tptr=(track#*total.stride)                  /* point to entry */            +(max.drives.per.track*track.info.stride);  /* for first tape */            if track.drive.exists then print '  Tape1',;            else                       print '       ',;            tptr = tptr + track.info.stride;            if track.drive.exists then print '  Tape2';            else                       print '       ';         end;         else if track.exists(track#)<>0 then do;            /* exists but not avail - must be error */            print '  Trk:',track#,'  Unavailable.  CMD, STATUS: ',track.command(track#),track.status(track#);         end;      end;      tptr = tape1.tptr;      if track.drive.exists then print '  Aux Tape1',;      else                       print '           ',;      tptr = tape2.tptr;      if track.drive.exists then print '  Aux Tape2';      else                       print '           ';      initialize      = 0;      subsystem.ready = 1;      if (dismount.drives=1)      then do;         call init.song.dir;         call init.track.dir;         send.screen.info  = 1;         subsystem.ready   = 0;  /* NOTE: leave dismount.drives=1 until drives are remounted */      end;      if (mount.drives=1)      then do;         call invalidate.track.dir;         send.screen.info = 1;      end;      mount.drives  = 0;	  format.drives = 0;      rezero.timer   = real.seconds + 60;       /* rezero in 1 minute */      last.user.time = real.seconds;      get.new.motion = get.new.motion \ 1;      /* get synclav info   */      if Synclav.software.version >= 3          /* update screen */      then get.new.motion = get.new.motion \ 4; /* on aee        */   end Init16;   /* $page - driver for initialization */   Perform.Initialization: procedure (version) PUBLIC;      dcl version  array;      if log.buf(0)<>0 then return 0;    /* wait for free buffer           */      do case(initialize-1);             /* branch on state                */                                         /* to correct swapping proc       */         call Init1(version);         call Init2;         call Init3;         call Init4;         call Init5;         call Init6;         call Init7;         call Init7A;         call Init8;         call Init8A;         call Init9;         call Init10;         call Init11;         call Init11A;         call Init12;         call Init13;         call Init14;         call Init15;         call Init16(version);      end;   end perform.initialization;end;