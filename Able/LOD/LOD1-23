/* LOD1-23 - Main status checking (port.check) */   /* 02/09/91 - cj - added more tape space commands                 */   /* 08/20/90 - cj - added code for 4 wangs/4 pats                  */   /* 02/22/90 - cj - added code for Tandberg EOT fix                */   /* 02/20/90 - cj - moved mode select data phase here (from        */   /*                 INITSOUC to solve wangdata timeout problem.    */   /*                 Better prints for tandberg EOT problem         */   /* 02/15/90 - cj - added better debug prints                      */   /* 01/16/90 - cj - added tandberg code                            */   /* 09/07/89 - cj - added TDEBUG check to reduce code size         */   /* 06/02/89 - cj - added exabyte code                             */   /* Check port.   if port is busy,  check for      command completion (process if so).   Otherwise,  see      if we should start a disk operation */   do port#=0 to max.ports;                   /* check each port     */                                              /* including port #8   */      if port.available(port#)<>0 then do;    /* if available        */         /* see if port is corrently performing     */         /* a scsi command.   check for completion  */         /* if it is:                               */         if port.io(port#)<>0 then do;        /* output happening    */            track#  = port.io.track# (port#); /* get track handy     */            dtrack# = port.io.dtrack#(port#); /* and disk track#     */            call select.d24(port.d24.#(port#));           /* select the d24 */            if port# < max.ports                          /* if using buf   */            then do;                                      /* memory ...     */               j=wait.for.busfree.or.start.reset(port#);  /* booss fry      */               if j<>0 then do;                           /* reset issued   */                   call count.retries(port#,track#);                   sstatus=0;               end;                                else do;                                   /* read status    */                  call targ0.connect(0);                  write(ScsiByte)=port# \ lun0.senable;                  sstatus=read(ScsiByte);               end;            end;            /* read status from D24 directly and map to L$SigMask format    */            else do;               sstatus = read(ScsiBus) & (not(L$I.O)); /* basically: remove S$RST */               if (sstatus & S$I.O) <> 0        /* map S$I.O to L$I.O */               then sstatus = sstatus \ L$I.O;               sstatus = sstatus & 255;         /* get only lower 8 bits */            end;            do case port.io(port#)-1;         /* see if done         */               do;                            /* reset occurring     */				/* note: do not swap.  may	*/                  if (real.seconds >= port.timer(port#))									/* occur before swap code  */                  then do;																			/* is loaded...				*/                     port.io(port#)=0;                 /* done with reset */                     call select.d24(port.d24.#(port#));                     i=select.port.or.start.reset(port#,0);                     if i=0 then do;                        i=wait.for.busfree.or.start.reset(port#);                        if i=0 then do;                           if port# < max.ports       /* clean up targ 0  */                           then do;                   /* if port uses     */                              call targ0.connect(0);  /* buf memory       */                              write(ScsiByte)=port#\lun0.iorst;                                do i=0 to 10; end;                              call targ0.connect(0);                              write(ScsiByte)=port#;                              do i=0 to 10; end;                           end;                        end;                        else port.io(0)=0;                     end;                     else port.io(0)=0;                     if (port.lun1(port#)<>0) then do;   /* try to clean out lun1 */                        call select.d24(port.d24.#(port#));                        i=select.port.or.start.reset(port#,lun0.penable);                        if i=0 then do;                           i=wait.for.busfree.or.start.reset(port#);                           if i=0 then do;                              call targ0.connect(1);                              write(ScsiByte)=0;                              port.lun1(port#)=0;                              call deselect(port#);                           end;                        end;                     end;                  end;               end;               /* $page - check for end of diskread */               do;              /* disk read occurring  */                  if check.for.status.phase then do;                     if (port.lun1(port#)<>0)     /* turn off DMA  */                     then do;                     /* hardware      */                        call targ0.connect(1);                        write(ScsiByte)=0;                        port.lun1(port#)=0;                     end;                     call deselect(port#);                     if sstatus=S$CheckCondition then do;                        port.io(port#)=4;              /* check con */                        call issue.port.command(port#,0);                          end;                     else do;                         /* check status */                        port.io(port#)=0;             /* port is now free */                        if (sstatus == 0)         		/* good status - updated length */								{                           if port.update(port#)<>0                           then call update.for.read.ok; /* note: may start DDT operation */                        }																else if (sstatus == S$Busy)	/* likely busy from spin-up or down	*/								{										/* wait & retry with no error...		*/									port.io   (port#) = Tape.Wait;									port.timer(port#) = real.milliseconds + 1000;								}                        else								{                           track.command(dtrack#)=S$ExtendedRead;                           track.status (dtrack#)=sstatus;                           call count.retries(port#,track#);                        }                     end;                  end;               end;               /* $page - check for end of diskwrite */               do;              /* disk write occurring  */                  /* Check for manual data transfer here */                  /* Happens when bouncing data between  */                  /* ports when reading AUX tapes on     */                  /* non-aux systems.                    */                  if  (port.lun1(port#) = 0)                  and ((sstatus&(L$SigMask\S$Req))=(L$DataOut\S$Req))                  then do;                     call select.d24(port.d24.#(port#));                     call select.port.or.start.reset(port#,lun0.penable);                     call psmread(port.tape.addr(port#), 0);  /* set poly adr */                     more.manual.write:;                     if (read(ScsiBus)&(S$SigMask))=S$DataOut                     then do;                        rpc 256;                        write(ScsiWord) = read(psd);                        port.tape.addr(port#) = port.tape.addr(port#) + 1;                        /* Wait a short moment here to see if REQ comes */                        /* immediately back for the next sector         */                        do i = 0 to 10;                           if (read(ScsiBus) & S$REQ) <> 0                            then goto more.manual.write;                        end;                     end;                     call deselect(port#);                  end;                  else if check.for.status.phase then do;                     if (port.lun1(port#)<>0)     /* turn off DMA  */                     then do;                     /* hardware      */                        call targ0.connect(1);                        write(ScsiByte)=0;                        port.lun1(port#)=0;                     end;                     call deselect(port#);                     if sstatus=S$CheckCondition then do;                        port.io(port#)=5;             /* check con */                        call issue.port.command(port#,0);                          end;                     else do;                         /* check status */                        port.io(port#)=0;      /* port is now free */                        if (sstatus == 0)  	  /* good status - update */								{                           if port.update(port#)<>0                           then call update.for.write.ok;                        }								else if (sstatus == S$Busy)	/* likely busy from spin-up or down	*/								{									port.io   (port#) = Tape.Wait;									port.timer(port#) = real.milliseconds + 1000;								}                        								else								{                           track.command(dtrack#)=S$ExtendedWrite;                           track.status (dtrack#)=sstatus;                           call count.retries(port#,track#);                        }                     end;                  end;               end;               /* $page - check for end of Check Condition (Request Sense) after disk read */               do;              /* check condition at end of readdata */                  if check.for.data.in.phase.after.sense then do;                     if port.update(port#)<>0                     then call update.for.read.ok;                  end;               end;               /* $page - check condition after disk write */               do;              /* check condition at end of write */                 if check.for.data.in.phase.after.sense then do;                     if port.update(port#)<>0                     then call update.for.write.ok;                  end;               end;               /* $page - process tape commands */               /* The inquiry command is the first command issued */               /* at the start of every load/backup.  It must     */               /* determine the tape.type.  For fuji,  it also    */               /* tells you if the cart is redy.                  */               begin;      /* inquiry         */                  if check.tape.status then do;							handle.tape.inquiry(port#, track#);                  end;               end;               /* For test unit ready,  our goal is to see if the */               /* cart is in place for CDC & WANGDATS:            */			   	/* also see if the cart is in place for Jaz		  */               do;      /* test unit ready */                  if check.tape.status then do;							handle.tape.test.unit(port#, track#);                  end;               end;               do;      /* load unit       */                  if check.tape.status then do;							handle.tape.load(port#, track#);                  end;               end;               /* The AUX tape port (port# = max.ports) is parked here */               /* while we read data from the disk (during a backup)   */               /* or write data to the disk (during a load).           */               /* That command should terminate normally and we        */               /* should be unblocked un Update.ADIR.after.write or    */               /* update.for.read.ok.  In the case of a disk error,    */               /* however,  we will check the other port.io here.      */               /* Individual ports are also parked here while the      */               /* AUX tape is reading data directly into that port     */               do;                  if (port.io(port.timer(port#)) = 0)                  then port.io(port#) = 0;               end;               do;      /* mode select      */                  if check.tape.status then do;   /* see if REQ */							handle.tape.mode.select(port#, track#);                  end;               end;               do;  /* request sense in process (for tapes) */                  if check.tape.status then do;							handle.tape.request.sense(port#, track#, dtrack#);                  end;               end;               do; /* check for tape writing tape write */                  if check.tape.data.xfer.status then do;                     i=read(ScsiWord);          /* get it    */                     i=shr(i,8);                                          if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'Write: ',port#,i;                     j=wait.for.busfree.or.start.reset(port#);                     if j<>0 then do;                              call count.retries(port#,track#);                     end;                                       else do;              /* clean up target 1        */                        if (port.lun1(port#)<>0)     /* turn off DMA  */                        then do;                     /* hardware      */                           call targ0.connect(1);                           write(ScsiByte)=0;                           port.lun1(port#)=0;                        end;                        call deselect(port#);                        if i=S$CheckCondition then do;                           port.last.io(port#)=port.io(port#);                           i=start.tape.command(port#,track#,Tape.RequestSense,7);                           if i<>0 then do;                              call count.tape.retries(port#,track#);                           end;                        end;                        else do;               /* check status */                           port.io(port#)=0;   /* port is now free */                           if (i=S$Good)                           or (i=S$ConditionMet)                           then do;                              tape.state(port#)=tape.state(port#)+1;																				/* if writing to Jaz drive, update current position (soon to be LEOT)	*/										/* unless we are writing the directory												*/																				if ((tape.type      (port#) == type.jaz)										&&  (port.jaz.update(port#) != 0       ))										{											port.jaz.sec.lsb(port#) = port.jaz.sec.lsb(port#) + port.jaz.update(port#);											if (port.jaz.sec.lsb(port#) ILT port.jaz.update(port#))												port.jaz.sec.msb(port#) = port.jaz.sec.msb(port#) + 1;										}                           end;                           else do;                              track.command(dtrack#)=S$Write;                              track.status (dtrack#)=i;                              call count.retries(port#,track#);                              if  (xdebug=0)   /* if I am not debugging */                              and (tdebug=0)   /* the tapes...          */                              then call issue.reset(port#);                           end;                        end;                     end;                  end;               end;               do;             /* check for tape reading */                  if check.tape.data.xfer.status then do;                     i=shr(read(ScsiWord),8);          /* get it    */                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'Read: ',port#,i,tape.state(port#);                     j=wait.for.busfree.or.start.reset(port#);                     if j<>0 then do;      /* reset was issued      */                         call count.retries(port#,track#);                     end;                  /* has gone out          */                     else do;              /* clean up target 1     */                        if (port.lun1(port#)<>0)   /* turn off DMA  */                        then do;                   /* hardware      */                           call targ0.connect(1);                           write(ScsiByte)=0;                           port.lun1(port#)=0;                        end;                        call deselect(port#);                        if i=S$CheckCondition then do;                           port.last.io(port#)=port.io(port#);                           i=start.tape.command(port#,track#,Tape.RequestSense,7);                           if i<>0 then do;                              call count.tape.retries(port#,track#);                           end;                        end;                        else do;               /* check status */                           port.io(port#)=0;   /* port is now free */                           if (i=S$Good)                           or (i=S$ConditionMet)                           then do;     /* good status - updated length */                              tape.state(port#)=tape.state(port#)+1;										/* if reading from Jaz drive, update current position */										/* unless we are reading the directory						*/																				if ((tape.type      (port#) == type.jaz)										&&  (port.jaz.update(port#) != 0       ))										{											port.jaz.sec.lsb(port#) = port.jaz.sec.lsb(port#) + port.jaz.update(port#);																						if (port.jaz.sec.lsb(port#) ILT port.jaz.update(port#))												port.jaz.sec.msb(port#) = port.jaz.sec.msb(port#) + 1;										}      /* Perform difficult data recovery from Patriot tapes:     */      if  (xdebug)             /* if both levels of debug code   */      and (tdebug)             /* compiled in                    */      and (command.# = 0)      /* and not doing load/backup      */      and (recover.code <> 0)  /* and recovery desired           */      then do;         /* Begin by looking for end of verify block and toss it */         if  (include.verify =  0)   /* if no verify             */         then recover.code   =  2;   /* go directly to data      */         if  (include.verify <> 0)   /* if using verify info     */         and (recover.code   =  1)   /* and searching ...        */         then do;                    /* see if checksum block    */            call psmread(compute.base.adr(track#)       /* get last block */                         + buf.base + 15, 0);            call poly.in(addr(misc.buf(0)), 256);            i = 1;                               /* assume is check block */            do j = 0 to 10;                      /* make sure first 10    */               if misc.buf(j) = 0                /* samples are nonzero   */               then         i = 0;            end;            do j = buf.len to 255;               /* make sure post-check  */               if misc.buf(j) <> 0               /* data is all zeroes    */               then         i  = 0;            end;            if i <> 0 then do;                   /* looks like the        */               recover.code  = 2;                /* checksum block        */               recover.count = 0;                /* init count            */               print 'Found Checksum Block';            end;            else print 'Tossing Block ...';         end;         else if recover.code = 2                /* if synced up, then    */         then do;                                /* write to disk         */            do i = 0 to 15;               recover.count = recover.count + 1;               if  (include.verify <> 0)        /* toss every checksum */               and (recover.count   = buf.len)  /* block               */               then do;                  recover.count = 0;               end;               else do;  /* else write to disk */                  call psmread(compute.base.adr(track#)                               + buf.base + i, 0);                  call poly.in(addr(misc.buf(0)), 256);                  /* write to first drive - only works */                  /* for even tracks !!!               */                  tptr=(track#*total.stride);                  k = writedata(recover.msb,recover.lsb,misc.buf,256,1);                  /* if good status, update adir & track dir */                  if k = 0 then do;                     port.secmsb (port#) = recover.msb;                     port.seclsb (port#) = recover.lsb;                     port.io.len#(port#) = 1;                     call update.adir.after.write(port#, track#);                     bitmsb=port.secmsb  (port#);                       bitlsb=port.seclsb  (port#) + port.io.len#(port#);                     if bitlsb ilt port.io.len#(port#) then bitmsb = bitmsb + 1;                     call update.song.and.track.used(track#);  /* update used from sector # = bitmsb, bitlsb */                  end;                  print 'Writedata: ',recover.msb, recover.lsb, k;                  recover.lsb = recover.lsb + 1;                  if recover.lsb = 0 then recover.msb = recover.msb + 1;               end;            end;         end;         /* issue next read command */         tape.pmem.add=compute.base.adr(track#) + buf.base;         i=start.tape.command(port#,track#,Tape.Read,1);         if i<>0 then do;            print 'Error Status :',i;            port.io(port#)=0;         end;      end;                           end;                           else do;                              track.command(dtrack#)=S$Read;                              track.status (dtrack#)=i;                              call count.retries(port#,track#);                              if  (xdebug=0)   /* if I am not debugging */                              and (tdebug=0)   /* the tapes...          */                              then call issue.reset(port#);                           end;                        end;                     end;                  end;               end;               do;      /* space command */                  if check.tape.status then do;                     i=shr(read(ScsiWord),8);       /* get status */                     call deselect(port#);                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'Space: ',port#,i;                     if i=S$CheckCondition then do;                        port.last.io(port#)=port.io(port#);                        i=start.tape.command(port#,track#,Tape.RequestSense,7);   /* request sense */                        if i<>0 then do;                           call count.tape.retries(port#,track#);                        end;                     end;                     else do;                          /* check status */                        port.io(port#)=0;   /* port is now free */                        if i=0 then do;     /* good status - updated length */                           if port.space.info(port#)=1 then do;  /* good status from space back 1 file mark on fuji */                              i=start.tape.command(port#,track#,Tape.Space,1); /* now go forward 1 block */                              if i<>0 then do;                                 call count.tape.retries(port#,track#);                              end;                              else port.space.info(port#)=2;                           end;                           else if port.space.info(port#)=2 then do; /* means we started with a read */                              port.space.info(port#)=0;              /* tape.eof is set. tape is repositioned. do not increment tape state since we encountered eof during read */                           end;                                      /* do not increment tape.state since we never read any data */                           else do;                              tape.state(port#)=tape.state(port#)+1;                           end;                        end;                        else do;                           track.command(dtrack#)=S$Space;                           track.status (dtrack#)=i;                           call count.retries(port#,track#);                        end;                     end;                  end;               end;               do;      /* write 0 file marks */                  if check.tape.status then do;                     i=shr(read(ScsiWord),8);       /* get status */                     call deselect(port#);                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'File Mark: ',port#,i;                     if i=S$CheckCondition then do;                        port.last.io(port#)=port.io(port#);                        i=start.tape.command(port#,track#,Tape.RequestSense,7);                        if i<>0 then do;                           call count.tape.retries(port#,track#);                        end;                     end;                     else do;               /* check status */                        if i=0 then do;     /* good status - update */                           tape.state(port#)=tape.state(port#)+1;                        end;                        else do;                           track.command(dtrack#)=S$WriteFileMarks;                           track.status (dtrack#)=i;                           call count.retries(port#,track#);                        end;                        port.io(port#)=0;   /* port is now free */                     end;                  end;               end;               do;      /* mode sense      */                  if check.tape.status then do;							handle.tape.mode.sense(port#, track#);                  end;               end;               do; /* wait until millisecond timer is done */                  if (real.milliseconds >= port.timer(port#)) then do;                     port.io(port#)=0; /* waited long enough - go back to what was happening */                  end;               end;               if tdebug then do; /* tape track select */                  if check.tape.status then do;                     i=shr(read(ScsiWord),8);       /* get status */                     call deselect(port#);                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'Track Select: ',port#,i;                     port.io(port#)=0;      /* port is now free */                  end;               end;               if tdebug then do;             /* Tape Read Reverse */                  if check.tape.data.xfer.status then do;                     i=shr(read(ScsiWord),8);  /* get it    */                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then do;                        call psmread(compute.base.adr(track#)+buf.base+15,252);                        print 'Read Reverse: ',port#,i,tape.state(port#),rot(read(psd),8),rot(read(psd),8),rot(read(psd),8),rot(read(psd),8);                     end;                     j=wait.for.busfree.or.start.reset(port#);                     if j<>0 then do;      /* reset was issued      */                         call count.retries(port#,track#);                     end;                  /* has gone out          */                     else do;              /* clean up target 1     */                        if (port.lun1(port#)<>0)   /* turn off DMA  */                        then do;                   /* hardware      */                           call targ0.connect(1);                           write(ScsiByte)=0;                           port.lun1(port#)=0;                        end;                        call deselect(port#);                        port.io(port#)=0;   /* port is now free */                        /* For now,  continue to issue read reverse */                        /* until we find the block that represents  */                        /* the start of the project.                */                        if  ((xdebug <> 0)                        or   (tdebug <> 0))                        and ( i = S$Good  )                        then do;                           Tape.Reverse.Count(port#) = Tape.Reverse.Count(port#) + Tape.Reverse.Chunk(port#);                           call psmread(compute.base.adr(track#)+buf.base+15,0);                           call poly.in(addr(misc.buf(0)), 256);                           /* see if this is a start of project block */                           if  ((misc.buf(252) = rot(6666,8))                           or   (misc.buf(252) = rot(5555,8)))                           and ( misc.buf(253) = rot(7777,8 ))                           and ( misc.buf(254) = rot(8888,8 ))                           and ( misc.buf(255) = rot(9999,8 ))                           then do;                              do i = 0 to 127;     /* get in normal order */                                 j = misc.buf(i);                                  misc.buf(i)=rot(misc.buf(255-i),8);                                 misc.buf(255-i)=rot(j,8);                              end;                              misc.buf(10) = 24;  /* set project name string length */                              print 'Tape ',port#+1,' is positioned at start of project ',string(loc(addr(misc.buf(10))));                           end;                           /* else re-issue reverse command until */                           /* we reach the user limit.            */                           else do;                              if Tape.Reverse.Left(port#) ILE Tape.Reverse.Chunk(port#)                              then Tape.Reverse.Left(port#) = 0; /* user limit reached */                              else do;                                 Tape.Reverse.Left(port#) = Tape.Reverse.Left(port#) - Tape.Reverse.Chunk(port#);                                 if output.happening = 0 then do;                                    tape.pmem.add=compute.base.adr(track#) + buf.base;                                    i=start.tape.command(Port#,Track#,Tape.ReadReverse,tape.reverse.chunk(port#));                                    if i<>0 then do;                                       call count.tape.retries(port#,track#);                                    end;                                 end;                              end;                           end;                        end;                     end;                  end;               end;               if tdebug then do;      /* special debug space command */                  if check.tape.status then do;                     i=shr(read(ScsiWord),8);       /* get status */                     call deselect(port#);                     if  ((track#=xtrack)                     and  (xdebug <>0   ))                     or  ((tdebug <>0   )                     and  (i      <>0   ))                     then print 'Special Space: ',port#,i;                     port.io(port#)=0;   /* port is now free */                     /* Issue repeated space commands */                     if (i=S$Good)                     then do;                        Tape.Space.Count = Tape.Space.Count + Tape.Space.Dir;                        if Tape.Space.Count <> Tape.Space.Limit                        then do;                           i=start.tape.command(Port#,Track#,Tape.BlockSpace,Tape.Space.Dir);                           if i<>0 then do;                              call count.tape.retries(port#,track#);                           end;                        end;                     end;                  end;               end;										do;                  if check.tape.status then do;							handle.tape.read.capacity(port#, track#);                  end;					end;               if (inc.multi.udio) then do;            /* Multi-track DDT Output */                  /* Wait for bus to go free at end of the */                  /* transfer to the DDT unit.             */                  if (sstatus & L$SigMask) = 0                  then do;                     call quickly.select.port(port#);                     call targ0.connect(1);  /* clean up lun1 */                     write(ScsiByte)=0;      /* for later     */                     port.lun1(port#)=0;     /* mark free     */                     call deselect(port#);                     port.io(port#) = 0;     /* port is idle  */                  end;               end;               if (inc.multi.udio) then do;            /* Multi-track DDT Input */                  /* Wait for bus to go free at end of the */                  /* transfer to the DDT unit.             */                  if (sstatus & L$SigMask) = 0                  then do;                     call quickly.select.port(port#);                     call targ0.connect(1);  /* clean up lun1 */                     write(ScsiByte)=0;      /* for later     */                     port.lun1(port#)=0;     /* mark free     */                     call deselect(port#);                     port.io(port#) = 0;     /* port is idle  */                  end;               end;					do;												/* Port.Start.Unit.Code: handle startup of unit 	*/                  if check.for.status.phase then do;	/* fetch status if available; ignore it				*/                     call deselect(port#);				/* clean up after status phase							*/                     port.io(port#)=0;             	/* port is now idle. drive hopefully has started	*/						end;					end;					            end;         end;