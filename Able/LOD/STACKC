/* STACKC - routine to stack an entire reel *//* 01/06/92 - cj - Extended conflict window definition        *//* 11-15/91 - cj - Fixed 'Horta' type problems with voicing   *//* 09-27/91 - cj - Sent envelope info to DSP during TRIG      *//* 09/20/91 - cj - fixed 'editview fades busted' bug          *//* 09/12/91 - cj - fixed 'track 1 dropout bug'                *//* 08/22/91 - cj - fixed cue scrubbing dropout bug            *//* 08/15/91 - cj - Improved track routing ability for Lucas   *//* 07/29/91 - cj - Sent xfade info to DSP Add on              *//* 05/29/91 - cj - added stack.extend function                *//* 11/05/90 - cj - provided accurate play to function         *//* Here is a routine to help resolve track conflicts.  This   *//* routine looks through a segment list for a track.  It is   *//* passed a start and end time.  It sees if any audio         *//* segments on the track extend into the passed region.       *//* It also sees what voice is used in the conflicting or      *//* prior segment.                                             */dcl Any.Track.Conflict     fixed;    /* arguments returned by following */dcl Recent.Voice#          fixed;    /* routine                         */check.track.for.conflicts: proc(track#, s, e);   dcl track#     fixed;             /* pass track #                    */   dcl s          array;             /* sync start time                 */   dcl e          array;             /* sync end time                   */   dcl Seg.Ptr   fixed;              /* temp segment pointer            */   Any.Track.Conflict = 0;           /* initialize to no conflict       */   Recent.Voice#      = 0;           /* no voice preference             */   write(mam) = cseg.xmsec#;              /* look up ending pointer     */   write(mal) = shl(track#, 1) + 1;       /* to see if list is empty    */   Seg.Ptr    = read(md);                 /* point to last block on que */   if  (Seg.Ptr = shl(track#, 1))         /* if que has no blocks       */   then return;                           /* then no conflict, no pref  */   next.cue:;   call read.seg.stack(Seg.Ptr);          /* read record into memory    */   if COM32(Seg.End, s) < lw#ieq          /* if last cue on stack ends  */   then do;                               /* before us: no conflict     */      Recent.Voice# = (Seg.Info&31) + 1;  /* get voice # used           */      return;                             /* done. no conflict.         */   end;   if COM32(Seg.Sync, e) > lw#ieq         /* if prior cue starts after  */   then do;                               /* us, see if we should back  */      Seg.Ptr = Seg.Bptr;                 /* up.  Get back pointer.     */      if Seg.Ptr = shl(track#, 1)         /* If no block behind us,     */      then do;                            /* prefer later voice, but    */         Recent.Voice# = (Seg.Info&31)+1; /* no conflict.               */         return;      end;      goto next.cue;                      /* else examine prior cue     */   end;   Any.Track.Conflict = 1;                /* else conflict occurs       */   Recent.Voice#      = (Seg.Info&31)+1;  /* use this voice             */end check.track.for.conflicts;/* Stack Entire Cue is called to stack the cue segments of an *//* entire reel on to the necessary tracks.                    *//* it is passed:   A cue id      (-1 = tcue.xmsec#)           *//*                 a sync time   (time to trigger cue)        *//*                 an offset     (in case we are late)        *//*                 bits          (control bits)               *//* This routine proceeds to stack all the cue segments        *//* in a not necessarily efficient way                         *//* should really truncate entire cue stack between in and     *//* out before doing this,  and then stack 1 set of zeroes     */Zero.Out.Stack.Record: proc(Stack.Record) PUBLIC;   dcl Stack.Record array;   write("300") = addr(Stack.Record(0));  /* zero out     */   rpc Stack.Record.Size;                 /* entire       */   write("360") = 0;                      /* record.      */end Zero.Out.Stack.Record;Stack.Entire.Cue: proc(Stack.Record) PUBLIC;   dcl Stack.Record     array;   /* actually a Stack.Record!! */   dcl (i,j,k)       fixed;   dcl (sec#,wrd#)   fixed;   dcl (info)        fixed;   dcl (tinfo)       fixed;   dcl Stime(1)      fixed;   dcl In   (1)      fixed;   dcl Out  (1)      fixed;   dcl Send (1)      fixed;   dcl Trks          fixed;   dcl StripBits     fixed;   dcl SegSync   (1) fixed;  /* sync time of segment              */   dcl SegSend   (1) fixed;  /* computed sync end of segment      */   dcl SegIn     (1) fixed;  /* in time of seg (actual disk addr) */   dcl SegOut    (1) fixed;  /* out time of seg (actual sample #) */   dcl SegLen    (1) fixed;  /* computed segment length           */   dcl SegTrks       fixed;   dcl (base,len)    fixed;   /* declare in order                 */   dcl (a)       (1) fixed;   dcl (b)       (1) fixed;   dcl (c)       (1) fixed;   dcl (zz)      (1) fixed;   /* leave at 0,0                     */   dcl (track#)      fixed;   dcl (voice#)      fixed;   dcl (resolved)    fixed;   dcl (track#s) (max.tracks-1) fixed;   dcl (voice#s) (max.tracks-1) fixed;   dcl (reserved)(max.tracks-1) fixed;   dcl (conflicts) (3)          fixed;   dcl (baseconflict)           fixed;   dcl (Stacktime)   fixed;   /* used for real-time info          */   dcl (Env ) (ESegSize) fixed;      /* envelope constructed here */   dcl (Tenv) (ESegSize) fixed;      /* temporary envelope        */   dcl Real.Time.Loop proc EXTERNAL;   /* look up xmem pointers to cue */   Stacktime = Real.Milliseconds;    /* detect humgo bongo cues       */   if Stack.Cue.Id  = (-1) then do;  /* trigger temp cue sent over or */      sec# = tcue.xmsec#;            /* built up in tcue.xmsec#       */      wrd# = 0;   end;   else do;                   /* trigger cue by id                   */      if get.cue.ptrs(Stack.Cue.Id)=0      then return;            /* bad id#                             */      sec# = cue.sec# + cue.sec;      wrd# = cue.wrd;   end;   /* Look up in/out times for the passed cue.   Remember that these */   /* are not disk address.   Instead they must be mapped (via the   */   /* segment list) to actual disk addresses that are to be          */   /* triggered                                                      */   /* See what section of the cue we are supposed to trigger.  If    */   /* we are scrubbing,  then we want to stack the entire map        */   /* so the user can scrub forward and backwards outside the range  */   /* of the in and out points.   If we are triggering an event,     */   /* then we want to extract the portion of the cue that is to      */   /* be played by the event.   Otherwise we want to only stack      */   /* th portion of the cue that is represented by the in and out    */   /* times.  Also construct a description of the desired envelope.  */   call COPY32(Stack.Sync, Stime);      /* get passed sync time       */   call ROUND32(Stime);                 /* get it on sector boundary  */                                        /* so envelope will match     */                                        /* stacked data               */   /* For looping playback: stack entire map so we can go backwards:  */   if (Stack.Bits & Stack.Whole.Map) <> 0   then do;                       /* stack whole cue                 */      call COPY32(Data.S#, in);   /* because user could scroll       */      call ADD32 (DataEnd.S#, out, out);      Stack.Bits = Stack.Bits & (not(Stack.Construct.Env));   end;   /* For events: just stack segments between the modified in and    */   /* out times:                                                     */   else if (Stack.Bits & Stack.Modify.In) <> 0   then do;      call Read.Store(sec#, wrd# + Event.In.S#.Msb);      a(0)  = read(mdi);         /* get frozen event in time.        */      a(1)  = read(mdi);         /* (relative to mapping)            */      call ADD32(a, Stack.New.In,  In );   /* compute new in time    */      call ADD32(a, Stack.new.Out, Out);   /* and out time.          */      if (in(0) < 0) then do;    /* if in is before start of disk    */         call ROUND32(In);       /* get info in sectors              */         call SUB32(Stime, In, Stime); /* then make In time later    */         call STR32(    0,  0, In   ); /* but correct picture sync   */      end;      if COM32(In, Data.S#) = lw#ilt then do; /* still before disk   */         call ROUND32(In);             /* get info in sectors        */         call SUB32(Data.S#, In, a);   /* get how much earlier       */         call ADD32(Stime, a, Stime);  /* add to picture sync        */         call COPY32(Data.S#, In);     /* set in time to min.        */      end;      if out(0) < 0 then return;       /* out time is before disk .. */      if COM32(Out, Data.S#) = lw#ilt then return;   end;   /* else for Cue Triggers,  stack between cue in and cue out:      */   else do;      call Read.Store(sec#, wrd# + Cue.S.Msb);      In(0)  = read(mdi);     /* get in and out times.  these are    */      In(1)  = read(mdi);     /* with respect to the segment         */      Out(0) = read(mdi);     /* sync times                          */      Out(1) = read(mdi);      call Read.Store(sec#, wrd# + Cue.Fin);      Stack.Fin  = read(mdi); /* cue fade in, msecs                  */      Stack.Fout = read(mdi);      Stack.Spare1 = 1000;       Stack.Spare2 = 1000;   end;   call ROUND32(In );                   /* get in & out info         */   call ROUND32(Out);                   /* to sector bounds before   */                                        /* comparison                */   /* Extend in and out time but keep picture sync to hear           */   /* underlying audio when scrubbing from EditView:                 */   if (Stack.Bits & Stack.Extend) <> 0   then do;      if COM32(Stime,In) = lw#ilt       /* get smaller of In time    */      then call COPY32(Stime,  a);      /* or Sync time              */      else call COPY32(In,     a);      call SUB32(a, Data.S#,   a);      /* compute a = a - Data.S#   */      call SUB32(In,    a,    In);      /* bring In time and Stime   */      call SUB32(Stime, a, Stime);      /* back until one of them    */      call ADD32(DataEnd.S#, Out, Out); /* extend out to whole disk  */   end;   /* Check for empty cue:                                           */   if COM32(In, Out) >= lw#ieq          /* skip the cue trigger if   */   then return;                         /* event or cue has no       */                                        /* region.                   */   /* Now get some info handy:                                       */   call Read.Store(sec#, wrd# + Cue.List.Ptr);   base = read(mdi);          /* get pointers to seg list, if any    */   len  = read(mdi);   call Read.Store(sec#, wrd# + Cue.Trks);   trks = read(mdi);   /* Now look up the routing/volume info for this      */   /* event in case it is being triggered from a        */   /* synclavier cuelist:                               */   /* Stack.Track#    tells us whether this cue trigger */   /* is referenced to a particular synclavier cuelist. */   /* If so,  then construct a 'routing' word that      */   /* has an output routing and track# for the DOA      */   /* software.                                         */   /* Contstruct routing word from input control word   */   /* input word  :  32768 + Syncl Cue Track #          */   /*                      + other bits to ignore here  */   /* routing word:  32768  (to make nonzero)           */   /*                syncl track # (upper 10 bits)      */   /*                32     (if routing specified)      */   /*                output #  (lower 5 bits)           */   if Stack.Track# < 0 then do;        /* compute routing word       */      write(mam) = tout.xmsec#;        /* index to track output      */      write(mal) = Stack.Track# & 255; /* get routing                */      if read(md) <> 0                 /* look up routing info       */      then do;                         /* if specified               */         info = 32768 + shl((Stack.Track# & 255),6) + 32 + (read(md) & 31);      end;      else do;                         /* no routing - vol only      */         info = 32768 + shl((Stack.Track# & 255),6);      end;   end;   else info = 0;                      /* if no track reference,     */                                       /* then our routing control   */                                       /* word is 0.                 */   /* Now construct a description of the volume envelope to use      */   /* for the entire cue:                                            */   /* There are 5 possible envelope shapes that can be constructed:  */   /*   1.     -         no fade in, no fade out, peak = sust        */   /*   2. / or \        no fade in, no fade out,  peak <> sust      */   /*   3. /----         fade in, no fade out                        */   /*   4. ---\          no fade in, fade out                        */   /*   5. /---\         fade in, fade out                           */   /* NOTE: the length of the envelope must PRECISELY MATCH the      */   /* length of the triggered audio for the punch-over envelope      */   /* stuff to work properly.                                        */   /* Set up basic Envelope Framework:                               */   call SUB32(Out, In, A);       /* get triggered region lngth handy */   Env(0) = 1 + ESegStride + 1;  /* assume no envelope will be used  */   Env(1 + ESegSval) = 4095;     /* start at max value normally      */   call COPY32(A, loc(addr(Env(1 + ESegLen)))); /* for length of cue  */   Env(1 + ESegDval) = 4095;     /* and end there as well            */   if (Stack.Bits & Stack.Construct.Env) <> 0   /* if envelope is    */   then do;                      /* desired,  build it               */      /* scale peak/sustain for volume info if needed:               */      i = Stack.Spare1;          /* get peak & sustain level handy   */      j = Stack.Spare2;      if (Stack.Bits & Stack.POVP) <> 0     /* scale for cue volume  */      then do;                              /* if info is available  */         load i; mul Stack.Vol; mwait; div 1000; i = res;         load j; mul Stack.Vol; mwait; div 1000; j = res;      end;      load i; mul 4095; mwait; div 1000; i = res; /* scale 0 - 4095 */      load j; mul 4095; mwait; div 1000; j = res;      if i IGT 4095 then i = 4095; /* limit to hardware maxes       */      if j IGT 4095 then j = 4095;      /* Look at fade in, fade out times,  and peak/sustain levels  */      /* and figure out what shape we want to the envelope.  Try    */      /* to eliminate unnecessary envelope segments                 */      /*   1.     -         no fade in, no fade out, peak = sust    */      /*   2. / or \        no fade in, no fade out,  peak <> sust  */      if  (Stack.Fin  ILE 1)    /* if no fade in, fade out,         */      and (Stack.Fout ILE 1)    /* then use one segment             */      then do;                  /* (very likely to be 4095!)        */         Env(1 + ESegSval) = i; /* start at declared peak value     */                                /* length was set up above          */         Env(1 + ESegDval) = j; /* end at declared sustain value    */      end;      /*   3. /----         fade in, no fade out                    */      else if (Stack.Fout ILE 1)  /* if no fade out, must mean      */      then do;                    /* a fade in is needed            */         Env(0) = 1 + 1;          /* fade in from a starting value  */         Env(1) = 0;              /* of 0                           */         call Conv.Msecs.To.Samples(Stack.Fin,  SegIn);         if COM32(SegIn, A) = lw#igt    /* limit fade in time to    */         then call COPY32(A, SegIn);    /* length of cue            */         call Add.Envelope.Segment(Env, SegIn, i); /* fade in to pk */         if (COM32(A, SegIn) <> lw#ieq) /* if some left after fade  */         then do;                       /* then perform initial dcy */            call SUB32(A, SegIn, SegLen);            call Add.Envelope.Segment(Env, SegLen, j);         end;      end;      /*   4. ---\          no fade in, fade out                    */      else if (Stack.Fin ILE 1)   /* if no fade in, must mean       */      then do;                    /* a fade out is needed           */         call Conv.Msecs.To.Samples(Stack.Fout,  SegOut);         if COM32(SegOut, A) = lw#igt  /* limit fade out to length  */         then call COPY32(A, SegOut);  /* of cue                    */         if (COM32(A, SegOut) <> lw#ieq) /* if initial decay needed */         then do;            Env(0) = 1 + 1;          /* start sustain portion          */            Env(1) = i;              /* at peak level                  */            call SUB32(A, SegOut, SegLen);            call Add.Envelope.Segment(Env, SegLen, j);         end;         else do;                    /* else start with final decay    */            Env(0) = 1 + 1;          /* only (ie from sustain level    */            Env(1) = j;              /* down to 0)                     */         end;         call Add.Envelope.Segment(Env, SegOut, 0);      end;      /*   5. /---\         fade in, fade out                          */      else do;              /* both fade in & out needed:              */         /* Limit fade in & fade out times so they are not longer      */         /* than entire cue                                            */         next.limit:;         call Conv.Msecs.To.Samples(Stack.Fin,  SegIn);         call Conv.Msecs.To.Samples(Stack.Fout, SegOut);         call ADD32(SegIn, SegOut, SegLen);         if COM32(SegLen, A) = lw#igt then do;            Stack.Fin  = shr(Stack.Fin,  1); /* try shorter fade in & out */            Stack.Fout = shr(Stack.Fout, 1); /* without a great deal of   */            goto next.limit;                 /* accuracy                  */         end;         Env(0) = 1 + 1;          /* fade in from a starting value  */         Env(1) = 0;              /* of 0                           */         call Add.Envelope.Segment(Env, SegIn, i); /* fade in       */         if (i <> j)                   /* if peak & sustain differ  */         or (COM32(SegLen, A) <> lw#ieq)    /* or length needed     */         then do;            call SUB32(A, Seglen, Seglen); /* get length of sustain portion, in samples */            call Add.Envelope.Segment(Env, SegLen, j);         end;         call Add.Envelope.Segment(Env, SegOut, 0);      end;   end;   /* To simplify triggering from the Cue Editor, we can also extract  */   /* a region of this resulting cue.   This allows us to easily       */   /* trigger a section of the audio with a ramp in or out.            */   if (Stack.Bits & Stack.Extract) <> 0  /* if extraction desired ...  */   then do;      call COPY32(Stack.Ext.In,  A);     /* get region to extract      */      call COPY32(Stack.Ext.Out, B);     /* relative to start          */      call ROUND32(A);                   /* round to sector bounds     */      call ROUND32(B);                   /* here so things line up     */      call SUB32(Out, In, C);            /* get original length handy  */      if COM32(B, C) = lw#igt            /* limit extract region to    */      then call COPY32(C, B);            /* end of audio.              */      if COM32(A, B) >= lw#ieq           /* if no section left to      */      then return;                       /* play,  then done.          */      /* Extract the part of the envelope we need:                     */      call Extract.Envelope.Region(Env, A, B, Env, ESegSize);            /* and the portion of the audio we need:                         */      call ADD32(In, B, Out);            /* compute new out time       */      call ADD32(In, A, In );            /* and new in time            */      /* note: but sync time remains unchanged!                        */   end;   /* compute actual in time that we want to use,  based    */   /* on the fact that we might be triggering the cue late. */   /* check for offset past end of cue (we were too late)   */   if COM16(128, Stack.Offset) <= lw#ieq /* if offset point specified, */   then do;                              /* then start up in middle    */      call COPY32(Stack.Offset, B);      /* get offset into cue        */      call ROUND32(B);                   /* move to sector bound       */      call SUB32(Out, In, A);            /* get original length handy  */      if COM32(B, A) >= lw#ieq           /* if we missed entire cue    */      then return;                       /* then we are done!          */      call ADD32(Stime, B, Stime);       /* add offset to sync         */      call ADD32(In,    B, In   );       /* and to in time             */      /* Extract the part of the envelope we need:                     */      call Extract.Envelope.Region(Env, B, A, Env, ESegSize);   end;   /* Limit section of cue to play to limit if needed:                 */   if (Stack.Bits & Stack.Play.To) <> 0   then do;                              /* then limit end of cue      */      call COPY32(Stack.To.Time, B);     /* get desired end time       */      call ROUND32(B);                   /* move to sector bound       */      if COM32(Stime, B) >= lw#ieq       /* if que starts after play   */      then return;                       /* to point, then done !!     */      call SUB32(B, Stime, B);           /* get max length desired     */      call SUB32(Out, In, A);            /* get current length handy   */      if COM32(B, A) = lw#ilt            /* if we should truncate the  */      then do;                           /* cue then do so             */         call ADD32(In, B, Out);         /* compute new out point      */         /* Extract the part of the envelope we need:                  */         call Extract.Envelope.Region(Env, zz, B, Env, ESegSize);      end;   end;   call COPY32(In,    Scroll.S#);       /* save in time for scrolling message in time display */   call COPY32(Stime, Scroll.Base);     /* and save time at which we triggered it             */   /* Now go through all the tracks in the cue:                      */   /*    1.  Stack the actual audio for simple cues (non-reels)      */   /*    2.  Erase prior audio for reels to avoid "leader fill"      */   /*        bugs.                                                   */   call SUB32(Out, In, A);  /* get length of triggered area, samples */   call ADD32(Stime, A, Send);     /* get segment end time handy     */   StripBits = 0;           /* initialize strip assignment list      */   write("300") = addr(reserved(0));      /* initialize list of      */   rpc max.tracks;                        /* reserved tracks         */   write("360") = 0;   do i = 0 to max.tracks-1;     /* loop over tracks here            */      if (trks&bits(i)) <> 0     /* if this track is involved ...    */      then do;                  /* Perform smart output routing allocation here.  If        */         /* outputs from different tracks are being dynamically      */         /* routed to different outputs,  resolve conflicts by       */         /* using a logical "track" to read the data from an         */         /* actual data "track".                                     */         tinfo  = info;          /* get working copy of routing word */         track# = i;             /* normally use track# for data     */         if (tinfo & 63) = 0     /* if no routing specified...       */         then do;                /* then use repro mode default      */            voice# = track.dir(i*track.len+track.routs) & 255;            if voice# = 0 then voice# = 32;            tinfo = tinfo \ 32 \ (voice#-1);         end;         /* else if routing is specifed,  see if another track on this same    */         /* scsi port is routed to that output.  If so,  use that track# for   */         /* reading the cue data to provide polyphonic track capability.       */         else do;            voice# = (tinfo & 31) + 1; /* get voice we are routed to, 1 - x */            info   = info + 1;         /* increment output for next track   */            /* if cue is being triggered out a voice that is not the voice     */            /* assigned to this track,  then look further:                     */            if voice# <> (track.dir(track#*track.len+track.routs) & 255)            then do;               if voice# = (track.dir((track# xor 1)*track.len+track.routs) & 255)               then track# = track# xor 1;               else if tracks.per.port = 4 then do;                  if voice# = (track.dir((track# xor 2)*track.len+track.routs) & 255)                  then track# = track# xor 2;                  else if voice# = (track.dir((track# xor 3)*track.len+track.routs) & 255)                  then track# = track# xor 3;               end;                              /* if performing switching, then check restrictions */               if track# <> i then do;                  if  (track.available (track#) =  0 )   /* track is not available */                  or  (track.recording (track#) <> 0 )   /* or recording here      */                  then track# = i;                       /* then go back to orig   */               end;            end;         end;         /* check for conflicts and find another track             */         /* to play from (on this drive) if conflicts occur...     */         if reserved(track#) = 0         then do;            call check.track.for.conflicts(track#, Stime, Send);            baseconflict = Any.Track.Conflict;         end;         if  (reserved(track#) <> 0     )     /* if track is claimed...  */         or  (Recent.Voice#    <> voice#)     /* or uses other voice...  */         then do;                             /* then look...            */            /* Begin by looking for a track# that just used this         */            /* voice (or is going to immediately after this cue          */            /* if stacking notes backwards...)                           */            resolved = 0;                                 /* clear flag   */            j        = track# & (not(tracks.per.port-1)); /* get first    */            k        = 0;                                 /* counter...   */            do while (resolved = 0)         /* look for different track   */            and      (k < tracks.per.port); /* that was sent to this      */               if    (j <> track#)          /* output...                  */               and   (reserved        (j) =  0)  /* not reserved          */               and   (track.available (j) <> 0)  /* track is available    */               and   (track.recording (j) =  0)  /* not recording         */               then do;                  call check.track.for.conflicts(j, Stime, Send);                  if  (Recent.Voice# = voice#)   /* if track uses this    */                  then do;                       /* voice, then use       */                     resolved = 1;               /* regardless of         */                     track#   = j;               /* possible conflicts    */                  end;                  else conflicts(k) = Any.Track.Conflict;               end;               k = k + 1;               j = j + 1;            end;            /* else find first track that does not conflict...            */            if  (resolved = 0)                      /* not resolved above */            and ((baseconflict     <> 0)            /* and cannot use     */            or   (reserved(track#) <> 0))           /* track# as is...    */            then do;                                /* then look          */               j = track# & (not(tracks.per.port-1));               k = 0;               do while (resolved = 0)         /* look for different track   */               and      (k < tracks.per.port); /* with no conflict...        */                  if    (j <> track#)                  and   (reserved        (j) =  0)  /* not reserved       */                  and   (track.available (j) <> 0)  /* track is available */                  and   (track.recording (j) =  0)  /* not recording      */                  and   (conflicts       (k) =  0)  /* does not conflict  */                  then do;                     resolved = 1;                     track#   = j;                  end;                  else do;                     k = k + 1;                     j = j + 1;                  end;                  /* else could not resolve conflict... */               end;            end;         end;         /* If no segments, then stack basic cue. */         /* If this is the case,  then the in     */         /* and out times are the disk addresses  */         /* themselves.                           */         if base = 0 then do;            call stack.cue(Track#, Stack.Exists, Stime,  /* stack the cue itself */                             In, Out, Tinfo, Stack.Sync, Env, i);         end;         /* For reels, begin by removing prior stacked audio  */         /* from the stack between our in times and out times */         /* That way lower priority audio won't show through  */         /* after leader filling                              */         else do;            call stack.cue(Track#,Stack.Exists,Stime,  /* stack the cue itself */                             ZZ, A, Tinfo, Stack.Sync, /* use 0,0 to indicate  */                             ZZ, i);                   /* no cue to stack.     */         end;                                          /* Just delete earlier  */                                                       /* audio                */         /* Also set up StripBits word for DSP add on:        */         if voice# <= 16         then StripBits = StripBits \ bits(voice#-1);         track#s(i) = track#;       /* save for stack of data below */         voice#s(i) = tinfo;        /* in case we have a reel       */         reserved(track#) = 1;      /* keep other tracks of this cue from using this track */         if  (Real.Milliseconds > Stacktime + 20)         and ((Now.Playing    <> 0)         or   (Now.Triggering <> 0))         then do;            call Real.Time.Loop;            Stacktime = Real.Milliseconds;         end;      end;   end;   /* Send the envelope descriptor over to the DSP Add on if          */   /* needed:                                                         */   if enabled.for.envelope.info <> 0     /* if anyone cares...        */   then do;      if  (StripBits            <> 0)    /* if any outputs...         */      and ((play \ loop \ trig) <> 0)    /* and PLAY or LOOP or TRIG  */      and ((env.env.len + ESegSize) < dsp.env.len)   /* will fit...   */      and ((env(0))       > 2)           /* any env info at all...    */      then do;         if (play = 0)                   /* set bit if not playing    */         then do;            env.control.bits = env.control.bits \ 2;            call SUB32(Stime, Data.S#, a);  /* remove data.s# offset  */         end;         else do;            call SUB32(Stime, Song.Data.S#, a);         end;         write(mam) = dsp.env.sec# + shr(env.env.len, 8);         write(mal) = env.env.len;         write(mdi) = StripBits;        /* Send bits over             */         write(mdi) = a(0);             /* sync time                  */         write(mdi) = a(1);         write(mdi) = (env(0) - 2) / ESegStride; /* # segs            */         do i = 1 to env(0) - 1;        /* start val, each segment    */            write(mdi) = env(i);         end;         env.env.len     = env.env.len + 4 + env(0) - 1;         env.num.of.envs = env.num.of.envs + 1;      end;   end;   /* if this is a simple cue trigger (not a reel), then we are done: */   if base = 0   then return;   /* Else handle stack of reel:                        */   /* Process each segmant.   Extract from each segment */   /* that audio that is between the in and out times   */   /* get ready to trigger that                         */   /* Now stack the extracted reel segments: */   do i = base to (base+len-1) by Cue.Seg.Stride;      call Read.Store(sec#, wrd# + i);      SegSync(0) = read(mdi);      /* S#Sync.Msb */      SegSync(1) = read(mdi);      SegIn  (0) = read(mdi);      /* S#In.Msb   */      SegIn  (1) = read(mdi);      SegOut (0) = read(mdi);      /* S#Out.Msb  */      SegOut (1) = read(mdi);      SegTrks    = read(mdi) & Trks; /* get tracks; solo those of interest */      /* Remember - SegSync times are with respect to our */      /* actual in/out times.   SegIn times are actual    */      /* disk addresses                                   */      call ROUND32(SegIn);         /* get In & Sync to sector bounds     */      call ROUND32(SegSync);       /* now.                               */      if SegOut(0) = (-1)          /* special handling if at end of disk */      then do;                     /* to avoid overflow                  */         SegOut(1) = ( 0);         /* give us some breathing room        */         if COM32(SegSync, SegIn) = lw#igt         then do;                  /* must limit further                 */            call SUB32(SegOut, SegSync, SegLen); /* compute new out time */            call ADD32(SegIn,  SegLen,  SegOut); /* that won't overflow  */         end;      end;      else call ROUND32(SegOut);      call SUB32(SegOut,  SegIn,  SegLen);  /* get seg len      */      call ADD32(SegSync, SegLen, SegSend); /* get seg sync end */      if (SegTrks              = 0     )    /* no trks */      or (COM32(SegSend, In ) <= lw#ieq)    /* case #1 */      or (COM32(SegSync, Out) >= lw#ieq)    /* case #5 */      then do;         /* segment ends before our in time       */         /* or segment starts after our out time  */         /* no audio from this segment            */         if  (Real.Milliseconds > Stacktime + 20)         and ((Now.Playing    <> 0)         or   (Now.Triggering <> 0))         then do;            call Real.Time.Loop;            Stacktime = Real.Milliseconds;         end;                     end;      else do;       /* else there will be some audio - cases 2,3,4,6 */         if COM32(SegSync, In) = lw#ilt   /* case 2 or 6 - must trunc */         then do;                         /* in time                  */            call SUB32 (In, SegSync, a    );  /* get delta            */            call ADD32 (a,  SegIn,   SegIn);  /* change disk address  */            call COPY32(In, SegSync       );  /* this is new segsync  */         end;         if COM32(SegSend, Out) = lw#igt  /* case 4 or 6 - must trunc */         then do;                         /* out time                 */            call SUB32 (SegSend, Out, a    );            call SUB32 (SegOut, a,   SegOut);            call COPY32(Out, SegSend       );         end;         /* compute actual sync time for this segment */         /* and extract envelope for this region:     */         call SUB32(SegSync, In, a);  /* get how far into trigger we are    */         call SUB32(SegSend, In, b);  /* and how far into trigger end is    */         call Extract.Envelope.Region(Env, A, B, Tenv, ESegSize); /* get its envelope */                  call ADD32(a, Stime, a);     /* compute trigger time for segment   */         if  (SegOut (0)= (-1))       /* special handling if at end of disk */         or  (SegSend(0)= (-1))         then do;                     /* to avoid overflow                  */            SegOut(0) = (-1);         /* set out to end of disk             */            SegOut(1) = ( 0);         /* but give us some breathing room    */            if COM32(A, SegIn) = lw#igt            then do;                  /* must limit further                 */               call SUB32(SegOut, A,       SegLen); /* compute new out time */               call ADD32(SegIn,  SegLen,  SegOut); /* that won't overflow  */            end;         end;         do j=0 to max.tracks-1;            if  ((SegTrks&bits(j)) <> 0)          /* cue on this trk      */            then do;               call stack.cue(track#s(j),Stack.Exists, A,  /* stack the cue itself */                                SegIn, SegOut, voice#s(j), Stack.Sync, Tenv, j);               if  (Real.Milliseconds > Stacktime + 20)               and ((Now.Playing    <> 0)               or   (Now.Triggering <> 0))               then do;                  call Real.Time.Loop;                  Stacktime = Real.Milliseconds;               end;                           end;         end;      end;   end;end Stack.Entire.Cue;