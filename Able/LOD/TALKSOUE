/* TALKSOUE -  $TITLE  Process Synclav Msg   Modified:   02/11/92 - cj  - allow multi udio to work with DDSYN   01/16/91 - cj  - fixed bug in 192 command for bounce   09/27/91 - cj  - send trig/scrub motion in send.scrub.info message   08/14/91 - cj  - Added UDIO/DDSYN stuff   07/29/91 - cj  - Sent envelope info to SYNTABULATOR for DSP addon   06/20/91 - cj  - Fixed bug with fade out of short files   09/21/89 - sjs - added support for THREE algorithm   07/28/89 - cj  - arguement check for song directory lookup   07/24/89 - cj  - added LOOP to cur.dtd.playing   02/22/89 - CJ  - added capabability for new STM (with prm)   10/06/88 - sjs - DSP code for first beta release   09/19/88 - SJS - Moved handle.cue.commands from lod1-6   08/01/88 - MWH - Add DSP interface   03/29/88 - MWH - Add wave display data compression and transfer   */Handle.Cue.Commands:proc inc.multi.udio.swapable;	dcl i      fixed;	dcl j      fixed;   dcl z (1)  fixed;	   do case (scsi.in.msg-179);      do;       /* general scsi to poly transfer              */         if optdebug then do;            print 'Scsi To Any Poly ',scsi.in.buf(1), scsi.in.buf(2), scsi.in.buf(3);         end;         /* 1 = poly memory sector */         /* 2 = poly memory word   */         /* 3 = word length        */         call scsi.to.any.poly(scsi.in.buf(1),scsi.in.buf(2),scsi.in.buf(3));         clean.up.all.of.poly = 1;    /* set flag to clean up all of poly  */         read.track.time = real.milliseconds;         timeout.point   = real.milliseconds+10000;      end;      do;                               /* 180: store a new cue in cue dir */         call convert.entire.record.to.samples(ccue.xmsec#);         dtd.cue# = insert.cue.in.list(ccue.xmsec#,0,0);    /* insert.  return error code, or id#. pick new id# and store in new place in data base */         send.dtd.cue=1;             /* just send dtd.cue# back */      end;      do;                               /* 181: cue locate       */         /* cue locate - try to locate one in cur project first  */         dtd.cue# = perform.binary.search(z, loc(addr(scsi.in.buf(2))), 12);  /* get any cue with this name in cur project */         if dtd.cue# = 0         then dtd.cue# = perform.binary.search(z, loc(addr(scsi.in.buf(2))),2);  /* get any cue with this name in any project */         if scsi.in.buf(1)<>0 then do;  /* update pointers       */            current.dtd.cue#=dtd.cue#;  /* set current cue#      */            if dtd.cue#<>0              /* match found           */            then call lookup.cur.cue(dtd.cue#); /* get it        */            if (dtd.cue# = 0)           /* if not found at all   */            or (find.cue.indexes(dtd.cue#,current.cue,scrollmode) = 0) /* or not in index for this scroll mode */            then do;               /* set up for alpha mode scrolling even if cue is not */               /* in current project                                 */               call perform.binary.search(z, loc(addr(scsi.in.buf(2))),2);  /* get any cue with this name in cur project */               cur.ix(alph.sort  ) = found.cue.num;               call perform.binary.search(z, loc(addr(scsi.in.buf(2))),12);  /* search current song to set up scroll index */               cur.ix(3+alph.sort) = found.cue.num;               current.dtd.cue# = 0;    /* do not increment before next scroll */            end;         end;         send.dtd.cue=1;  /* send cue id# only */      end;      do;                               /* 182: fetch cue record */         current.dtd.cue# = scsi.in.buf(1);     /* save record id # */         call lookup.cur.cue(current.dtd.cue#); /* get basic record */         if cc.rlen=0 then do;                  /* and check for    */            dtd.cue#=0;                         /* cue exists, etc  */            send.dtd.cue=1;                     /* send cue id# only */         end;         else do;                               /* cue exists       */            dtd.cue#=current.dtd.cue#;          /* return id#       */            /* 0 = fetch short cue and map it       */            /* 1 = fetch short cue with no mapping  */            /* 2 = fetch entire cue and map it      */            /* 3 = fetch entire cue with no mapping */            if  (Scsi.In.Buf(0) < 4)       /* if old software        */            or  (Scsi.In.Buf(2) < 2)       /* or not entire cue      */            then do;                       /* then get basic cue     */               if  (scsi.in.buf(0) < 4)                   or  (scsi.in.buf(2) < 1)    /* see if we should map   */               then do;                  call convert.basic.record.to.msecs(current.cue);               end;               send.dtd.cue = cc.rlen + 1;               end;            else do;                       /* return entire cue      */               call read.store(cue.sec# + cue.sec, cue.wrd);               i = read(md);               /* get raw length         */               call Move.Store(cue.sec# + cue.sec, cue.wrd,                               ccue.xmsec#,0,0,i);               if (scsi.in.buf(2) < 3)     /* see if we should map   */               then do;                  call convert.entire.record.to.msecs(ccue.xmsec#);               end;               Send.Dtd.Cue  = (-i-1);     /* send cue from ext mem  */            end;         end;      end;      do;                               /* 183: rewrite current.dtd.cue# */         dtd.cue# = 0;                  /* clear in case bomb      */         call read.basic.cue(ccue.xmsec#,0,Scsi.In.Buf);  /* get basic cue in internal memory */         if  (scsi.in.buf(cue.rlen) ile Max.Cue.Record.Len) /* length error */         and (scsi.in.buf(cue.rlen) igt cue.name )         and (scsi.in.buf(cue.name) <>  0        )         and (scsi.in.buf(cue.name) ile cue.name.l)         and (get.cue.ptrs(current.dtd.cue#)  <> 0)   /* make sure cue is saved */         then do;            call read.store(cue.sec# + cue.sec, cue.wrd);            i = read(md);  /* get length of currently defined cue */            write(mam) = ccue.xmsec#;  /* check length */            if read(md) = i            /* see if replacing with same length cue */            then do;               if delete.cue(current.dtd.cue#,0,1) then do; /* unsort only. leave in cue data area. no garbage collect */                  call convert.entire.record.to.samples(ccue.xmsec#);                  dtd.cue# = insert.cue.in.list(ccue.xmsec#,current.dtd.cue#,1); /* store using this id# in same place */               end;            end;            else if delete.cue(current.dtd.cue#,1,0) then do; /* delete it entire cue with garbage collect */               call convert.entire.record.to.samples(ccue.xmsec#);               dtd.cue# = insert.cue.in.list(ccue.xmsec#,current.dtd.cue#,0); /* store using this id# but in new place */            end;         end;         send.dtd.cue=1;  /* send cue id# only */      end;      do;                                /* 184: delete a cue record */         current.dtd.cue# = scsi.in.buf(1);         if delete.cue(current.dtd.cue#,1,0)  /* delete entire cue and garbage collect */         then do;            dtd.cue#=current.dtd.cue#;        /* deleted                 */            current.dtd.cue#=0;               /* no current cue left     */         end;         else dtd.cue#=0;         send.dtd.cue=1;  /* send cue id# only */      end;      do;                                /* 185: partial name search */         dtd.cue# = perform.binary.search(z, loc(addr(scsi.in.buf(1))),5+ 10*(scrollmode<>0));  /* get any cue with this partial name */         cur.ix(scrollmode)=found.cue.num;    /* save in case not perfect match */         call return.search.result;      end;      do;                                /* 186: search for cue time */         /* from record panel (or early software) the passed time   */         /* is a 32-bit millisecond time with respect to the start  */         /* of the current project.                                 */         if  (Scsi.In.Buf(0) < 6)        /* if old software          */         or  (Scsi.In.Buf(3) = 0)        /* or milliseconds passed   */         then do;            call compute.mark.start.point(loc(addr(scsi.in.buf(1))),  /* convert passed cue time to sample # */                                          0,1,loc(addr(scsi.in.buf(1))));         end;         /* or we can search for a cue recorded on the disk at any    */         /* absolute sample #.   This sample # is an actual disk      */         /* address of a sample                                       */         else do;                         /* passed sample #          */            call ADD32(loc(addr(scsi.in.buf(1))), Data.S#,                       loc(addr(scsi.in.buf(1))));         end;         dtd.cue# = perform.binary.search(loc(addr(scsi.in.buf(1))), '', 0 + 10*(scrollmode<>0));         cur.ix(scrollmode+1)=found.cue.num;    /* save in case not perfect match */         call return.search.result;             /* set up for return        */      end;      do;                                /* 187: locate nth alphabetic cue */         call return.nth.cue(scrollmode,scsi.in.buf(1));         cur.ix(scrollmode)=scsi.in.buf(1);      end;      do;                                /* 188: locate nth cue in time order */         call return.nth.cue(scrollmode+1,scsi.in.buf(1));         cur.ix(scrollmode+1)=scsi.in.buf(1);      end;      do;                                 /* 189: song dir info    */         dtd.cue#     = num.songs;         send.dtd.cue = 10*song.len+1;         j = scsi.in.buf(1);              /* get base              */         if (j < 0) then j = song.base + dtd.song#;  /* get info for current song */         call gsong.dir(j*song.len);         do i=0 to 10*song.len-1;            current.cue(i)=read(mdi);         end;      end;      do;                                /* 190: search for smpt time */         dtd.cue# = perform.binary.search(loc(addr(scsi.in.buf(1))), '', 3 + 10*(scrollmode<>0));         cur.ix(scrollmode+2)=found.cue.num;    /* save smpt index even if no match */         call return.search.result;             /* set up for return        */      end;      do;                                /* 191: locate nth cue in smpt bit order */         call return.nth.cue(scrollmode+2,scsi.in.buf(1));         cur.ix(scrollmode+2)=scsi.in.buf(1);      end;   end;end Handle.Cue.Commands;Handle.Big.Cue.Commands:proc swapable;   dcl (i,j,k,l,m)       fixed;   dcl (a,b,c,d,z)  (1)  fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';   dcl cmsb    lit  'c(0)';   dcl clsb    lit  'c(1)';   dcl dmsb    lit  'd(0)';   dcl dlsb    lit  'd(1)';   do case (scsi.in.msg-192);      do;                                /* 192 - get digital data from cue */         read.track.time = real.milliseconds;   /* set timeout timer */         timeout.point   = real.milliseconds+10000;         i    = scsi.in.buf(1);    /* track #            */         call COPY32(loc(addr(Scsi.In.Buf(2))), a); /* get sector # to read from relative to start of cue */         call ADD16 (Data.Sec#, a);                 /* get absolue sector # now  */         j    = scsi.in.buf(4);    /* # of words desired */                                   /* note: # of words desired could be zero.  in this case */                                   /* we just want to read the data into the dtd buffers */                                   /* but not send it over to the synclavier.   we are */                                   /* getting ready to do a cross fade */         b(0) = buf1.msb(i);       /* get sample # we are buffered at  */         b(1) = buf1.lsb(i);         call SHR32(b,8);          /* convert that to sector #         */         call COPY32(b,c);         /* get sector # up to which we      */         call ADD16(buf1.len(i),c);/* have buffered                    */         /* compute sector # of data end desired */         call COPY32(a,d);         call ADD16(shr(j,8),d);               /* if data is sitting in buffer, send it to synclavier */         /* otherwise, start a process going to get the data    */         /* into the buffer                                     */         if  (clob.len(i) = 0)      /* if nothing in buf2 has glommed buf1       */         and (COM32(a,b) >= lw#ieq) /* and desired sectors is after buffer start */         and (COM32(d,c) <= lw#ieq) /* and desired end is before end of buffer   */         and ((read.track.info&bits(i))<>0)      /* force read first time through so data is at start of buffer */         and ((track.info.direction&bits(i))=0)  /* or we just wrote */         and (j <> 0) /* note: above tests fail if j = 0!! */         then do;                  /* data is in poly and set to go */            send.screen.info   = 1;            send.screen.length = j;            k=compute.base.adr(i);            call psmread(k+buf.base+alsb-blsb,0);         end;         else if func<>0 then do;            if ((read.track.info&bits(i))=0)        /* if first read */            or ((track.info.direction&bits(i))<>0)  /* or we just wrote */            then zap.buffer    (i) = 1;               /* then clear buffer contents */            send.screen.length     = 0;               /* no data yet       */            read.track.info        = read.track.info \ bits(i);            track.info.direction   = track.info.direction & (not(bits(i)));            track.info.busy        = track.info.busy \ bits(i);            read.track.buf.len (i) = buf.len;         /* fill entire buffer */            read.track.chunk   (i) = 25;              /* limit chunk        */            call shl32(a,8);                                    read.track.msb(i)      = amsb;            /* sample # to read   */            read.track.lsb(i)      = alsb;            track.eof(i)           = 0;         end;         else send.screen.length = 0;      end;      begin;                             /* 193 - start compressing digital data from cue */         dcl smsb  lit 'loc(addr(scsi.in.buf(4)))';  /* Start msb */         dcl lmsb  lit 'loc(addr(scsi.in.buf(6)))';  /* Length/end msb */         calculating.compressed = comp#working;  /* We're working on it */         read.track.time = real.milliseconds;    /* set timeout timer */         timeout.point   = real.milliseconds+10000;         write(MAM) = comp.xmsec#;       /* Compress display to here */         j = 128 \ shl(128,8);         do i=1 to 4;                    /* Init sectors to horiz.   */            rpc 256;                     /* line                     */            write(MDI)=j;         end;         comp.samples = 0;               /* initialize sample count    */         comp.xmptr   = 0;               /* and xmem pointer           */         comp.ptr     = 0;               /* and word pointer in sector */         comp.max     = 0;               /* initialize max             */         comp.min     = (-1);            /* and min to 65535           */         comp.scale   = 8;               /* allow max magnif. of 120/8 */         /* Note: compute lmsb in samples for now */         if scsi.in.buf(1) = 1 then do;  /* 0 = disk address, 1 = time given */            /* need to convert time to disk address */            call compute.mark.start.point(smsb,0,0,smsb);  /* convert a synclavier time to sample # */            call SUB32(smsb,Song.Data.S#,smsb);            /* remove this offset */            call compute.mark.start.point(lmsb,0,0,lmsb);  /* convert a synclavier time to sample # */            call SUB32(lmsb,Song.Data.S#,lmsb);            /* remove this offset */            if COM32(lmsb,smsb) = lw#igt            then call SUB32(lmsb,smsb,lmsb);  /* (END - START) = LENGTH */            else call STR32(0,0,lmsb);            comp.ptr = scsi.in.buf(5) & 255;  /* get starting word      */            call SHR32(smsb,8);               /* get sector address     */         end;         else do;            /* must get lmsb in samples sometime ... */         end;         comp.track = scsi.in.buf(2);    /* track # */         comp.words = scsi.in.buf(3);    /* word length after compress */         if comp.words igt 1024 then comp.words = 1024;         call COPY32(smsb, comp.start);        /* get sector # to read from relative to start of cue */         call ADD16 (Data.Sec#, comp.start);   /* get absolue sector # now  */         call COPY32(comp.start,comp.here);    /* we're at the start */         call COPY32(lmsb,comp.len);     /* get length in words   */         /* compute increment to determine how many samples       */         /* we look at.   IE skip over some samples when doing    */         /* a long compress so it does not take FOREVER!!         */         comp.incr = comp.len(lw#msb);   /* use msb of length (in samples) */         if comp.incr = 0                /* as increment.  means we        */         then comp.incr = 1;             /* will only look at about        */                                         /* 65,000 samples to compute      */                                         /* the envelope display.          */                                      /* compute how many samples go in the first pixel: */         call COPY32(Comp.Len, Bit);     /* get # of words to do  */         call ratio_multiply(1, comp.words);         comp.ratio = BITLSB;            /* note: could be 0 here */         call COPY32(Bit, Comp.Prior);         /* compute sector # of data end desired */         call COPY32(comp.len, comp.end);  /* get length, samples  */         call ADD16(comp.ptr,  comp.end);  /* add in starting word */         call ADD16(255, comp.end);        /* round up             */         call SHR32(comp.end, 8);          /* get # of sectors     */         call ADD32(comp.start, comp.end, comp.end);            end;      do;                                /* 194 - Try to fetch last compressed data */         /* Don't keep compressing for more than 10 seconds after last */         /* time Synclavier requested compressed data */         timeout.point   = real.milliseconds+10000;         /* No data to read here, only send a reply (below) if */         /* compressed data is ready */         if calculating.compressed = comp#done then send.screen.info = 1;         else                                       send.screen.info = 0;      end;      do;    /* 195 - see if digital data transfer command is completed */         current.cue(0) = ((track.info.busy&bits(scsi.in.buf(1)))<>0);         dtd.cue# = 0;         send.dtd.cue=2;      end;      do;   /* 196 - store data in track buffers */         call scsi.to.poly(scsi.in.buf(1),scsi.in.buf(2),scsi.in.buf(3),scsi.in.buf(4),scsi.in.buf(5));      end;      do;   /* 197 - construct poly cross fade */         i = compute.base.adr(Scsi.In.Buf(1)) + buf.base; /* get base addr for this track + point to rotary buffer */         call construct.dtd.poly.crossfade(i,scsi.in.buf(2), /* fade out */                                           i,scsi.in.buf(3), /* fade in  */                                           i,scsi.in.buf(4), /* dest     */                                           scsi.in.buf(5),   /* pre      */                                           scsi.in.buf(6),   /* fade     */                                           scsi.in.buf(7));  /* post     */      end;      do;  /* 198 - write data from track buffer to disk */         read.track.time = real.milliseconds;   /* set timeout timer */         timeout.point   = real.milliseconds+10000;         i    = scsi.in.buf(1);    /* track #            */         amsb = scsi.in.buf(2);    /* disk address msb   */  /* sector # */         alsb = scsi.in.buf(3);    /* disk address lsb   */  /* sector # */         j    = scsi.in.buf(4);    /* # of words desired */         call ADD16 (Data.Sec#, a);/* get absolue sector # now  */         read.track.info        = read.track.info      \ bits(i);         track.info.direction   = track.info.direction \ bits(i);         track.info.busy        = track.info.busy      \ bits(i);         status.tracks          = status.tracks        \ bits(i);         read.track.msb(i)      = amsb;      /* keep as sector numbers */         read.track.lsb(i)      = alsb;      /* for convenience        */         read.track.len(i)      = shr(j,8);  /* sector length          */         read.track.buf.base(i) = 0;         /* sector 0 of buffer     */         read.track.written (i) = 0;         /* indicate none written  */         read.track.chunk   (i) = shr(j,8);  /* write in one op        */         track.eof(i)           = 0;         screen = 0;          /* wait for aee to ask for updates */      end;      do;  /* 199 - handle DSP command */         /* If Synclavier is quiet for 10 sec, give up (will go out of func mode) */         read.track.time = real.milliseconds;   /* set timeout timer */         timeout.point   = real.milliseconds+10000;         do case scsi.in.buf(1);               /* Type of DSP command */            do;                                /* 0: Idle message from Synclavier */               if dspdebug then do;                  disable;                  print 'Do Case: Idle';                  enable;               end;               /* send progress info. Kludge  of send.dtd.cue */               if  (dsp.function =  dsp#tsm)   /* send percentage while */               and (dsp.state    <> dsp#off)   /* still busy            */               then do;                  dtd.cue#       = 1;/* fixed cue number for now */                  send.dtd.cue   = 3;/* length to send. 1+length of buffer */                  current.cue(0) = dsp.out.track;                  current.cue(1) = dsp.percent.done;               end;               else if  (dsp.function =  dsp#SynSCSI)               and      (dsp.state    <> dsp#off    )   /* still busy            */               then do;                  if scsi.in.buf(2) <> 0 then do;                     DSP.Next.Track      = 1; /* trigger clean up at end of cue */                     current.cue(2) = 1;                  end;                  else current.cue(2) = 0;                  dtd.cue#       = 1;/* fixed cue number for now */                  send.dtd.cue   = 4;/* length to send. 1+length of buffer */                  current.cue(0) = dsp.out.track;                  current.cue(1) = dsp.percent.done;               end;               dsp.paused = 0;/* "unpause" the current dsp operation */            end;            do;                                /* 1: Load boot code,algorithm, and data from Synclavier */               if dspdebug then do;                  disable;                  print 'Do Case: Boot';                  enable;               end;               if scsi.in.buf(2) = 1 then do;  /* if start of process */                  dsp.boot.len = scsi.in.buf(3);                  dsp.alg.len  = scsi.in.buf(4);                  dsp.data.len = scsi.in.buf(5);                  if Select.DSP70 then do;                     DSP70.there = 1;                     call Reset.DSP70;                     call DSP.Write(icr,"h82");                     dsp.data.offset = 0;/* init parameters */                     dsp.state = dsp#load.boot;                     dtd.cue#     = 1;                  end;                  else do;                     dtd.cue# = 0;                     DSP70.there = 0;                  end;                  send.dtd.cue  = 1;  /* send back dtd.cue# */               end;/* of if scsi.in.buf(2) */               else do;/* if continuation of process */                  if DSP70.there = 0 then return;                  if dsp.state = dsp#load.boot then do;                     if dsp.boot.len igt 256 then do;                        call Load.Next.Sector(256);/* handle actual boot of sector */                        dsp.boot.len = dsp.boot.len-256;                     end;                     else do;                        call Load.Next.Words(dsp.boot.len);                        call DSP.Write(icr,"h8");/* tell DSP done with boot load */                        dsp.state = dsp#load.alg;/* done, switch to next state */                        dsp.boot.len = 0;                     end;                     return;                  end;                  if dsp.state = dsp#load.alg then do;                     if dsp.alg.len igt 256 then do;                        call Load.Next.Sector(256);                        dsp.alg.len = dsp.alg.len - 256;                     end;                     else do;                        call Load.Next.Words(dsp.alg.len);                        call DSP.Write(icr,"h82");                        dsp.alg.len = 0;                        dsp.state = dsp#load.data;                     end;                     return;                  end;                  if dsp.state = dsp#load.data then do;                     if dsp.data.len igt 256 then do;                        call Store.DSP.Data(dsp.data.offset,256);                        dsp.data.len = dsp.data.len - 256;                        dsp.data.offset = dsp.data.offset + 1;                     end;                     else do;                        call Store.DSP.Data(dsp.data.offset,dsp.data.len);                        dsp.data.len = 0;                     end;                     return;                  end;               end;/* of if continuation of process */            end;/* of case 1: */            do;                                /* 2: start of TSM command */               if dspdebug then do;                  disable;                  print 'Do Case: Time Compression';                  enable;               end;               dsp.algorithm   = scsi.in.buf(2);               dsp.in.trk.bits = scsi.in.buf(3);      /* Track # */               call COPY32(loc(addr(scsi.in.buf(4))),dsp.start);  /* Sector # to read from relative to start of cue */               call ADD16 (Data.Sec#,dsp.start);      /* Absolue sector # now */               call COPY32(loc(addr(scsi.in.buf(6))),dsp.len); /* Length in sectors */               call ADD32(dsp.start,dsp.len,dsp.end);               dsp.out.trk.bits = scsi.in.buf(8);     /* Output track # */               call COPY32(loc(addr(scsi.in.buf(9))),dsp.out.s); /* Start of output */               call ADD16 (Data.Sec#,dsp.out.s);      /* Absolue sector # now */               call COPY32(loc(addr(scsi.in.buf(11))),dsp.out.e); /* End of output - in allocate mode, this is end of project (ie not very useful) */               call ADD16 (Data.Sec#,dsp.out.e);      /* Absolue sector # now */               tsm.pitch   = scsi.in.buf(13);               tsm.max.cut = scsi.in.buf(14);               tsm.just    = scsi.in.buf(15);               tsm.c.or.e  = scsi.in.buf(16);               tsm.ratio   = scsi.in.buf(17);               tsm.stereo  = scsi.in.buf(18);               call Copy32(loc(addr(scsi.in.buf(19))),dsp.new.len);               call COPY32(dsp.out.s,  dsp.new.end);               call ADD32(dsp.new.len, dsp.new.end, dsp.new.end);               if  (dsp.algorithm =  dsp#three)               and (tsm.stereo    <> 0        )               then sys.stereo = true;               /* compute list of output tracks for */               /* writing data                      */               dsp.#tracks  = 0;               dsp.trk.ptr  = 0;               do i=0 to 15;                  dsp.out.tracks(i) = 0;                  if (dsp.out.trk.bits & bits(i)) <> 0 then do;                     dsp.out.tracks(dsp.#tracks) = i;                     dsp.#tracks = dsp.#tracks + 1;                  end;               end;               /* Initialize read/write pointers and tracks to the start */               call COPY32(dsp.start,dsp.in.here);               call COPY32(dsp.out.s,dsp.out.here);               dsp.out.track = dsp.out.tracks(dsp.trk.ptr);               if sys.stereo                then dsp.out.track.r = dsp.out.tracks(dsp.trk.ptr+1);               else dsp.out.track.r = -1;               dsp.percent.done = 0;               dsp.function   = dsp#tsm;    /* set algorithm type */               dsp.state      = dsp#working;/* Switch into DSP mode working */               dsp.paused     = 0;               Dsp.Next.Track = 0;               Dsp.Edit.Len   = 0;               /* These variables are not altered by TSM but need to */               /* be reset just in case                              */               dsp.opt.data.stacked = 0;               dsp.scsi.error       = 0;               syn.scsi.data.xfer = sys#off;/* make sure were not still in this mode */               if init.dsp.function(dsp.function,dsp.algorithm) = FALSE               then do;                  dsp.state = dsp#off;                  call log.error('No DSP70 in system');/* send message to synclavier */                  DSP70.there = 0;                  if dspdebug <> 0                  then print 'No DSP70 in system';               end;               if dspdebug <> 0 then do;                  print 'dsp.start          = ', dsp.start(0),dsp.start(1);                  print 'dsp.end            = ', dsp.end(0),dsp.end(1);                  print 'dsp.len            = ', dsp.len(0),dsp.len(1);                  print 'dsp.out.s          = ', dsp.out.s(0),dsp.out.s(1);                  print 'dsp.out.e          = ', dsp.out.e(0),dsp.out.e(1);                  print 'dsp.out.wds        = ', dsp.out.wds;                  print 'dsp.new.len        = ', dsp.new.len(0),dsp.new.len(1);               end;            end;    /* of TSM command        */            do;     /* 3: check to see if there is a DSP70 in the system */               if dspdebug then do;                  disable;                  print 'Do Case: Check for DSP70';                  enable;               end;               dtd.cue#       = 1;               send.dtd.cue   = 2;               DSP70.there    = Select.DSP70;/* select to see if it there */               current.cue(0) = DSP70.there;               if dspdebug then do;                  disable;                  print '   DSP70.there = ', DSP70.there;                  enable;               end;            end;            do;/* 4: start Synclavier SCSI transfer (both directions) */               if dspdebug then do;                  disable;                  print 'Do Case: Opt <-> DTD';                  enable;               end;               dcl dsp.source.dev  fixed;               dcl dsp.dest.dev    fixed;               dsp.algorithm   = scsi.in.buf(2);      /* which SRC algorithm (if any) */               dsp.in.trk.bits = scsi.in.buf(3);      /* Track # */               dsp.source.dev  = scsi.in.buf(4);      /* source device */               call COPY32(loc(addr(scsi.in.buf(5))),dsp.start);  /* Sector # to read from relative to start of cue */               dsp.start(0) = dsp.start(0) & 255;               if dsp.source.dev = DTDDev               then call ADD16 (Data.Sec#,dsp.start);      /* Absolute sector # now */               call COPY32(loc(addr(scsi.in.buf(7))),dsp.len); /* Length in sectors */               call ADD32(dsp.start,dsp.len,dsp.end);               dsp.in.wds = (scsi.in.buf(9)&255); /* extra length words */               dsp.out.trk.bits = scsi.in.buf(10);     /* Output track # */               dsp.dest.dev     = scsi.in.buf(11);    /* dest    device */               call COPY32(loc(addr(scsi.in.buf(12))),dsp.out.s); /* Start of output */               dsp.out.s(0) = dsp.out.s(0) & 255;               if dsp.dest.dev =DTDDev               then call ADD16 (Data.Sec#,dsp.out.s);      /* Absolute sector # now */               call Copy32(loc(addr(scsi.in.buf(14))),dsp.new.end);               dsp.new.end(0) = dsp.new.end(0) & 255;               if dsp.dest.dev =DTDDev               then call ADD16 (Data.Sec#,dsp.new.end);    /* Absolute sector # now */               call SUB32(dsp.new.end, dsp.out.s, dsp.new.len);               call COPY32(dsp.new.end, dsp.out.e);   /* Remove reference to dsp.out.e */               dsp.out.wds = (scsi.in.buf(16)&255); /* get extra words past dsp.new.end */               call Copy32(loc(addr(scsi.in.buf(17))),src.ratio);/* sample rate conversion ratio */               sys.stereo  = scsi.in.buf(19);     /* set if stereo file */               if (dsp.source.dev=LaserDev) and (dsp.dest.dev=DTDDev)               then do;                  if dspdebug then do;                     disable;                     print 'Setting mode to Opt -> DTD';                     enable;                  end;                  syn.scsi.data.xfer = SyS#OptDTD;                  dsp.first.write.to.opt = 0; /* don't need this here */               end;               else if (dsp.source.dev=DTDDev) and (dsp.dest.dev=LaserDev or dsp.dest.dev=6)               then do;                  if dspdebug then do;                     disable;                     print 'Setting mode to DTD -> Opt';                     enable;                  end;                  syn.scsi.data.xfer = SyS#DTDOpt;                  dsp.first.write.to.opt = 1; /* we will remember our "first time" */               end;               else do;                  /* post an error message */                  if dspdebug then do;                     disable;                     print 'Not Opt<->DTD';                     enable;                  end;                  syn.scsi.data.xfer = 0;               end;               /* when Opt <-> DTD, buf1 has the optical disk address */               /* Initialize read/write pointers and tracks to the start */               call COPY32(dsp.start,dsp.in.here);               call COPY32(dsp.out.s,dsp.out.here);               dsp.#tracks  = 0;               dsp.trk.ptr  = 0;               /* if we are writing to the optical, it doesn't matter */               /* what track buffers we store the output in so, we'll */               /* arbitrarily pick them to be the same as the input   */               /* buffers.                                            */               if syn.scsi.data.xfer = sys#DTDOpt               then dsp.out.trk.bits = dsp.in.trk.bits;               do i=0 to 15;                  dsp.out.tracks(i) = 0;                  if (dsp.out.trk.bits & bits(i)) <> 0 then do;                     dsp.out.tracks(dsp.#tracks) = i;                     dsp.#tracks = dsp.#tracks + 1;                  end;               end;               dsp.out.track = dsp.out.tracks(dsp.trk.ptr);               if sys.stereo                then dsp.out.track.r = dsp.out.tracks(dsp.trk.ptr+1);               else dsp.out.track.r = -1;               dsp.function     = dsp#SynSCSI;/* set function type */               dsp.state        = dsp#working;/* Switch into DSP mode working */               dsp.paused       = 0;               dsp.percent.done = 0;               Dsp.Next.Track   = 0;               Dsp.Edit.Len     = 0;               dsp.write.event.ptr  = bbuf.xmsec#;               dsp.read.event.ptr   = bbuf.xmsec#;               dsp.last.event       = 0;               dsp.opt.data.stacked = 0;/* no data in xmem for optical write yet */               dsp.scsi.error   = 0;               if dsp.algorithm <> dsp#nosrc then do; /* if we are useing the DSP70 */                  if init.dsp.function(dsp.function,dsp.algorithm) = FALSE                  then do;                     dsp.state = dsp#off;                     call log.error('No DSP70 in system');/* send message to synclavier */                     if dspdebug <> 0                     then print 'No DSP70 in system';                  end;               end;               if dspdebug then do;                  disable;                  print 'dsp.algorithm      = ', dsp.algorithm;                  print 'dsp.in.trk.bits    = ', dsp.in.trk.bits;                  print 'dsp.source.dev     = ', dsp.source.dev;                  print 'dsp.start          = ', dsp.start(0),dsp.start(1);                  print 'dsp.end            = ', dsp.end(0),dsp.end(1);                  print 'dsp.len            = ', dsp.len(0),dsp.len(1);                  print 'dsp.in.wds         = ', dsp.in.wds;                  print;                  print 'dsp.out.trk.bits   = ', dsp.out.trk.bits;                  print 'dsp.dest.dev       = ', dsp.dest.dev;                  print 'dsp.out.s          = ', dsp.out.s(0),dsp.out.s(1);                  print 'dsp.out.e          = ', dsp.out.e(0),dsp.out.e(1);                  print 'dsp.out.wds        = ', dsp.out.wds;                  print 'dsp.new.len        = ', dsp.new.len(0),dsp.new.len(1);                  print 'src.ratio(0)       = ', src.ratio(0);                  print 'src.ratio(1)       = ', src.ratio(1);                  print 'sys.stereo         = ', sys.stereo;                  print 'syn.scsi.data.xfer = ', syn.scsi.data.xfer;                  enable;               end;               dsp.time = real.milliseconds;            end;/* of Synclavier SCSI transfer */         end;       /* of do case on command */      end;          /* of 199 = DSP command  */   end;end Handle.Big.Cue.Commands;/* Send init record back to the Synclav */send.init.record: proc swapable;   dcl (i,j,k) fixed;   send.init.info=0;   if   New.Dig.Xfer.Mode = 0            /* initialize variables */   then New.Dig.Xfer.Mode = Dig.Off;   call send.scsi.byte(225);             /* 225: expaned init info */   call send.scsi.word(44);   call send.scsi.word(dtd.max.secs);      call send.scsi.word(dtd.max.tracks);   if   ( current.rate         >= 501)   /* >= 50.1 khz */   and  ((adconfig & "040000") =  0  )   /* no PRM      */   then call send.scsi.word(shr(dtd.max.inputs,1));      else call send.scsi.word(   (dtd.max.inputs  ));      call send.scsi.word(track.avail.bits);   /* new items for cues: */   call send.scsi.word(num.of(  alph.sort));   call send.scsi.word(num.of(cs.alph.sort));   call send.scsi.word(current.dtd.cue#);       /* id# of current cue                      */   call compute.syncl.time(Song.End.S#,0,Syncl.Time);   call send.scsi.word(Syncl.Time(0));   call send.scsi.word(Syncl.Time(1));   call send.scsi.word(lod.software.version  ); /* send lod version  */   call send.scsi.word(PolyNumv - Base.Voice#); /* # of avail voices */   call send.scsi.word(New.Dig.Xfer.Mode     ); /* and pending mode  */   /* Construct DDT Config info for SYNTABULATOR: */   /* lower 4 bits:  0 = none           */   /*                1 = routable       */   /*                2 = multi          */   /*                4 = ddsyn          */   /* next  4 bits:  0 = mutsu only     */   /*                1 = universal ddt  */   /* next  4 bits:  current format     */   /* upper 4 bits:  current sync       */   i = shl(DDT.Format,8) \ shl(DDT.Sync,12);   j = 0;   if DDT.Hardware.Avail <> 0 then do;      /* If routable hardware is available,  send info back */      /* to synclav:                                        */      if DDT.UDIO.Avail <> 0 then do;         /* UDIO       */         i = i \ 1;                           /* set bit    */         if DDT.UDIO.Rev#   <> DDT.MITSU.REV         then i = i \ 16;         j = j \ track.avail.bits;      end;      if DDT.DDSYN.Avail <> 0 then do;        /* DDSYN      */         i = i \ 4;         j = j \ track.avail.bits;      end;      /* If multi-track hardware is available,  send info  */      /* about the config back to synclav:                 */		#if (inc.multi.udio)			if DDT.MULTI.Avail <> 0 then do;				i = i \ 2;   /* set bits for multi format hardware */				do k = 0 to max.ports-1;           /* allow format select */					if (port.ddt(k) <> 0)           /* if any UDDT boxes.  */					then do;                        /* Send over which     */						if port.ddt.rev#(k) <> DDT.MITSU.REV /* tracks have DDT     */						then i = i \ 16;             /* boxes available     */						j = j \ port.track.bits(k);					end;				end;			end;		#endif   end;   call send.scsi.word(i);   call send.scsi.word(j);   call send.scsi.word(DDT.Use.DDSYN);   call send.scsi.word(tracks.per.port);            call send.scsi.word(0);            call send.scsi.word(0);            call send.scsi.word(0);            call send.scsi.word(0);            call send.scsi.word(0);            call send.scsi.word(0);         end send.init.record;/* $page - process synclav msg *//* Process Synclav Msg is called when a message from the synclavier *//* is being sent to the LOD.                                        *//* We are called with interrupts off */Process.Synclav.Msg:proc PUBLIC;   dcl (i,j,k,l,m)       fixed;   dcl (a,b,c,d,z)  (1)  fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';   dcl cmsb    lit  'c(0)';   dcl clsb    lit  'c(1)';   dcl dmsb    lit  'd(0)';   dcl dlsb    lit  'd(1)';   dcl any.env.stuff     fixed;   log.not.ready.message:proc;		if (erase1 = 3456)		/* if just started erase or format, leave	*/		&& (erase2 = 5432)		/* the message showing...						*/			return;		      if (dismount.drives=1)      then call log.error('Direct-To-Disk Drives Are Not Mounted');      else call log.error('Direct-To-Disk System is not Ready');   end;   /* procedure to send time base adjust information to Synclavier. */   Send.Time.Base.Adjust:proc;                    call send.scsi.word(Synclav.Time.Base.Adjust);      /* if we just received a sync message,  and are sending a time base */      /* adjust message back,  then modify our received data to reflect   */      /* the time base jump that the synclavier is doing AS WE SPEAK      */      if scsi.in.msg=130 then do;         load Synclav.Time.Base.Adjust;         mul  Samp.Speed;         scsi.in.buf(2) = scsi.in.buf(2) + res;      end;      Synclav.Time.Base.Adjust = 0;            /* done with it           */   end Send.Time.Base.Adjust;   /* procedure to send editview envelope info to synclavier             */   Send.Envelope.Info: proc;      dcl i fixed;      call send.scsi.word(env.control.bits);   /* send control bits      */      call send.scsi.word(env.num.of.envs );   /* send # of envelopes    */      write(mam) = dsp.env.sec#;               /* get info from ext mem  */      do i = 0 to env.env.len - 1;             /* send each word         */         call send.scsi.word(read(mdi));       /* from ext memory        */      end;                                     /* buffer                 */               env.control.bits = 0;                    /* clear info after       */      env.num.of.envs  = 0;                    /* we have sent it...     */      env.env.len      = 0;   end Send.Envelope.Info;	// Wait for S$SEL release   do while ((read(Scsibus)&S$SEL)<>0);     /* SEL release                 */   end;	// Check for S$ATN asserted; will happen if Synclav decided to give up on us, presumably	// because we did not respond in time.  Like, we just missed it...   if ((read(Scsibus)&S$ATN)<>0)            /* see if abort desired        */   then do;      write(ScsiBus)=0;                     /* done                        */      return;   end;   if ((read(Scsibus)&S$RST)<>0)            /* see if abort desired        */   then do;      write(ScsiBus)=0;                     /* done                        */      return;   end;   scsi.in.msg=get.scsi.byte;               /* get command byte            */   if ((read(Scsibus)&(S$ATN\S$RST))<>0)    /* see if abort desired        */   then do;      write(ScsiBus)=0;                     /* done                        */      scsi.in.msg   =0;      return;   end;   if scsi.in.msg>=128 then do;             /* scan data/text if so        */      scsi.in.buf(0)=get.scsi.word;         /* get length in bytes         */      if ((read(Scsibus)&(S$ATN\S$RST))<>0) /* see if abort desired        */      then do;         write(ScsiBus)=0;                  /* done                        */         scsi.in.msg   =0;         return;      end;      if scsi.in.msg=130 then do;           /* sample d16 for syncing      */         call get.d16.time;                 /* get d16 time                */         scsi.in.buf(513)=our.time.msb;     /* save d16 time as well       */         scsi.in.buf(514)=our.time.lsb;      end;      if (scsi.in.msg = 180)                /* if define/replace of cue    */      or (scsi.in.msg = 183)                /* store in external memory    */      then do;         write(mam) = ccue.xmsec#;         do i=1 to shr(scsi.in.buf(0)+1,1); /* length in bytes             */            write(mdi) = Get.Scsi.Word;         end;         Scsi.In.Buf(0) = 0;                /* scsi buf now empty          */      end;      else if (scsi.in.msg = 137)           /* cue for tcue.xmsec#         */      then do;         write(mam) = tcue.xmsec#;         do i=1 to shr(scsi.in.buf(0)+1,1); /* length in bytes             */            write(mdi) = Get.Scsi.Word;         end;         Scsi.In.Buf(0) = 0;                /* scsi buf now empty          */      end;      else do i=1 to shr(scsi.in.buf(0)+1,1); /* length in bytes             */         scsi.in.buf(i)=get.scsi.word;      end;      if ((read(Scsibus)&(S$ATN\S$RST))<>0) /* see if abort desired        */      then do;         write(ScsiBus)=0;                  /* done                        */         scsi.in.msg   =0;         return;      end;   end;                                    else do;      scsi.in.buf(0)=0;                   /* no data if <128             */   end;      /* $page - check for directory/screen message */   if  (scsi.in.msg>=10)           /* song/track info             */   and (scsi.in.msg<=34)   then do;      if (subsystem.ready=0)       /* directory not ready yet     */      then do;         call log.not.ready.message;         if scsi.in.msg=12 then screen=1;         if scsi.in.msg=13 then screen=2;      end;      else if (scsi.in.msg <= 22)			call Handle.Directory.Non.Data.Commands;		else			call Handle.Directory.Cue.Commands;   end;   /* $page - check for synclavier messages with data fields for directories */   else if  (scsi.in.msg >= 140)           /* more directory info         */   and      (scsi.in.msg <= 156)   then do;      if scsi.in.msg = 151      then do;                             /* 151: send software vesion   */         Synclav.software.version=scsi.in.buf(1);         if  (subsystem.ready <> 0)        /* if swap code avail...       */         then send.init.info=1;      end;      else if (scsi.in.msg    = 144)      and     (scsi.in.buf(1) =  57)      then do;                            /* 57 = enable for envelopes    */			#if (0)				enabled.for.envelope.info = 1;   /* set flag                     */				if  (subsystem.ready <> 0)       /* if DSP being turned on late, */				then new.dtd.song#=1;            /* set up to track it now       */			#endif      end;      else if (scsi.in.msg     = 144)     /* snaarf ddsyn sync mode here  */      and     (scsi.in.buf(1)  =  60)     /* if being sent over before    */      and     (subsystem.ready =   0)     /* we are booted...             */      then do;         DDT.Use.DDSYN = Scsi.In.Buf(2);      end;      else if (scsi.in.msg     = 144)     /* mount drives command         */      and     (scsi.in.buf(1)  =  62)     /* and we are currently         */      and     (subsystem.ready =   0)     /* dismounted...                */      then do;         initialize      = 1;					/* restart init process...		  */         dismount.drives = 0;         mount.drives    = 1;      end;      else if  (subsystem.ready=0)         /* directory not ready yet     */      then do;         call log.not.ready.message;      end;		else if (scsi.in.msg == 144)			Handle.Directory.144.Commands();      else call Handle.Directory.Data.Commands;   end;                  /* of 140-156 message  */   else if  (scsi.in.msg>=179)            /* cue processing */   and      (scsi.in.msg<=199)   then do;      if  (subsystem.ready=0)              /* directory not ready yet     */      then do;         call log.not.ready.message;      end;      else if (scsi.in.msg < 192)			call Handle.Cue.Commands;		else			call Handle.Big.Cue.Commands;   end;   /* $page - now send an answer back to the synclavier */   any.env.stuff = 0;              /* assume no env stuff waiting to go back. */   if (env.control.bits <> 0)      /* get # of bytes of envelope info to send */   or (env.env.len      <> 0)      /* handy                                   */   then any.env.stuff = 4 + env.env.len + env.env.len;   if send.dtd.cue<>0 then do;                /* send cue first since user needs it immediately */      call send.scsi.byte(227);               /* send cue back to syncl    */      call send.scsi.word(shl(abs(send.dtd.cue),1)); /* length             */      call send.scsi.word(dtd.cue#);      if send.dtd.cue < 0 then do;            /* send cue in ext mem       */         write(mam) = ccue.xmsec#;         do i = 1 to (-send.dtd.cue) - 1;            call send.scsi.word(read(mdi));         end;      end;      else do i=0 to send.dtd.cue-2;         call send.scsi.word(current.cue(i));      end;      send.dtd.cue=0;   end;   else if send.init.info<>0 then do;      call send.init.record;   end;   else if send.screen.info<>0 then do;     /* send director info back   */      send.screen.info=0;      if scsi.in.msg=22 then do;            /* disk dump opcode          */         call send.scsi.byte(223);          /* disk data                 */         call send.scsi.word(512);         write(mam)=ddub.xmsec#;         do i=0 to 255;            call send.scsi.word(read(mdi));         end;      end;      else if (scsi.in.msg        =  192)       and     (send.screen.length <> 0  )      then do;      /* poly data desired         */         call send.scsi.byte(228);          /* disk data                 */         call send.scsi.word(shl(send.screen.length,1));         call send.scsi.poly(send.screen.length);      end;      else if (scsi.in.msg        =  194)      then do;         call send.scsi.byte(229);                /* External mem data desired */         call send.scsi.word(shl(comp.words,1));  /* Number of bytes to send */         write(MAM) = comp.xmsec#;         do i=1 to comp.words;            call send.scsi.word(read(MDI));   /* Send xmem data over */         end;         calculating.compressed = comp#init;  /* Reset after successful transfer */      end;      else if screen=1 then do;             /* song directory            */         call send.scsi.byte(220);          /* 220 = song directory      */         call send.scsi.word(10*song.len*2+2);         call send.scsi.word(dtd.song#);    /* send cursor               */         call gsong.dir(song.base*song.len);         do i=0 to 10*song.len-1;            call send.scsi.word(read(mdi));         end;      end;      else if screen=2 then do;         call send.scsi.byte(221);          /* 221 = track directory      */         call send.scsi.word((song.len+16*track.len)*2+2); /* send  current track, song info, + 16 tracks */         call send.scsi.word(dtd.track#);   /* send cursor                */         call gsong.dir((song.base+dtd.song#)*song.len);         do i=0 to song.len-1;              /* send song info             */            call send.scsi.word(read(mdi));         end;         do i=0 to num.tracks-1;            do j=0 to track.len-1;               call send.scsi.word(track.dir(i*track.len+j));            end;         end;         get.new.motion=get.new.motion\1;   /* set ready lights correctly */      end;      else call send.scsi.byte(3);          /* send a 3 back if no screen */      send.screen.length = 0;   end;   else if log.buf(0)<>0 then do;           /* send terminal message       */      call send.scsi.byte(128);      do i=0 to shr(log.buf(0)+1,1);        /* length in bytes             */         call send.scsi.word(log.buf(i));      end;      log.buf(0)=0;   end;        else if (get.new.motion<>0) then do;      if (get.new.motion&1)<>0 then do;         get.new.motion=get.new.motion xor 1;         call send.scsi.byte(4);      end;      else if (get.new.motion&2)<>0 then do;         get.new.motion=get.new.motion xor 2;         call send.scsi.byte(5);      end;      else if (get.new.motion&4)<>0 then do;         get.new.motion=get.new.motion xor 4;         call send.scsi.byte(6);      end;      else if (get.new.motion&8)<>0 then do;         get.new.motion=get.new.motion xor 8;         call send.scsi.byte(7);      end;      else if (get.new.motion&16)<>0 then do;  /* & 16:  ask for object   */         call send.scsi.byte(2);               /* again so we can snarf   */         /* leave bit set so we send 2's */    /* swap code from old RTPs */         /* until we get swap file!      */      end;      else do;         get.new.motion = 0;         call send.scsi.byte(3);      end;   end;   /* Scrub info is only sent while scrubbing and the DSP add-on      */   /* is running:                                                     */   else if (  send.scrub.info          <> 0   )  /* if scrub info should   */   and     (( send.scroll.info         =  0  )   /* be sent provided no    */   or       ((any.env.stuff            =  0 )    /* env/sync stuff         */   and       (Synclav.Time.Base.Adjust =  0 )))   then do;      call send.scsi.byte(232);             /* 232 - scrub pos  */      if send.scroll.info = 0      then call send.scsi.word(  6);             /*  6 bytes          */      else call send.scsi.word( 12);             /* 10 bytes          */      call send.scsi.word(Dtd.Scrub(0));      call send.scsi.word(Dtd.Scrub(1));      call send.scsi.word(loop\trig);      if send.scroll.info <> 0 then do;         call send.scsi.word(cur.dtd.ms.msb);         call send.scsi.word(cur.dtd.ms.lsb);         call send.scsi.word(now.playing \ now.triggering \ now.looping \ trig \ loop);         send.scroll.info = 0;      end;      send.scrub.info=0;   end;   /* *** Note: send.scroll.info must be last since it   */   /* is sent more or less continuously during triggered */   /* playback                                           */   else if (send.scroll.info<>0) then do;   /* scroll info      */      call send.scsi.byte(226);             /* 226 = playt time */      if (any.env.stuff <> 0)               /* if any env stuff */      then call send.scsi.word( 8 + any.env.stuff);      else if (Synclav.Time.Base.Adjust <> 0)      then call send.scsi.word(  8);        /* 8 bytes          */      else call send.scsi.word(  6);        /* 6 bytes          */      call send.scsi.word(cur.dtd.ms.msb);      call send.scsi.word(cur.dtd.ms.lsb);      call send.scsi.word(now.playing \ now.triggering \ now.looping \ trig \ loop);      if (any.env.stuff <> 0)               /* if any env stuff       */      then do;         if Synclav.Time.Base.Adjust <> 0         then call Send.Time.Base.Adjust;   /* send it                */         else call send.scsi.word (0);      /* or a zero              */         call Send.Envelope.Info;           /* send env info          */      end;      else if Synclav.Time.Base.Adjust <> 0      then call Send.Time.Base.Adjust;      /* send it                */      send.scroll.info=0;   end;   else if (Synclav.Time.Base.Adjust <> 0)     /* send info to ajust time base */   or      (any.env.stuff            <> 0)     /* send envelope info           */   then do;      call send.scsi.byte(230);                /* 230 = adjust time base */      call send.scsi.word(2 + any.env.stuff);  /* 2 bytes                */      if Synclav.Time.Base.Adjust <> 0      then call Send.Time.Base.Adjust;         /* send it                */      else call send.scsi.word (0);            /* or a zero              */      if (any.env.stuff <> 0)                  /* if any env stuff       */      then call Send.Envelope.Info;            /* send env info          */   end;   else do;                                 /* no message                  */      call send.scsi.byte(3);               /* send a 3 back               */   end;   write(ScsiData)=0;                       /* clear data lines */   write(ScsiBus)=0;                        /* done                        */   break.me=0;                              /* continue after message     */end process.synclav.msg;