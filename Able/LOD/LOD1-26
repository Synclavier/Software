/* LOD1-26 - voice.check routine *//* voice check  -  check each track and voice for output              *//* 06/21/89 - CJ - handle voice switching in both directions          *//* Voice Check is called to process the voice outputs from the Direct *//* to Disk system.   It operates as follows:                          *//*   1. First look at each track and start STM input voices going     *//*      to get the ADC running if needed.                             *//*                                                                    *//*   2. Then look at output assignments. See what data will be going  *//*      out the DAC 40 milliseconds from now.   See which output the  *//*      data is to be directed to.                                    *//*                                                                    *//*      Use this information to construct a 'Desired.Track#' look up  *//*      table that holds the desired track # for each voice           *//*                                                                    *//*   3. Then loop over all the voices.   Turn a voice off if it       *//*      should be muted,  or if it is playing data from the wrong     *//*      track.   Turn a voice on from the correct track once it is    *//*      off.   Use the delay field of the amplitude computer to       *//*      try to get the envelope to start 3 msec before the start of   *//*      the cue,  with a 2.5 msec ramp up time                        *//*                                                                    *//*   4. Use a similar process to rout the digital data from a voice   *//*      out to a Direct Digital Transfer output jack.                 */voice.check:proc(immed, Dac.S#, D16Info, Check.DDT);   dcl (immed)    fixed;  /* 1= set volume immediately since starting up */   dcl (Dac.S#)   array;  /* sample number currently going out dac       */   dcl (D16Info)  array;  /* d16 time when we are playing that sample#   */   dcl (Check.DDT) fixed; /* true if should check DDT this call          */   dcl (s#msb)  lit 'Dac.S#(0)';   dcl (s#lsb)  lit 'Dac.S#(1)';   dcl (track#)         fixed;   dcl (voice#)         fixed;   dcl (ddt#  )         fixed;   dcl (strack#)        fixed;   dcl (priority)       fixed;   dcl (Voice.Time) (1) fixed;   dcl (Voice.Sync) (1) fixed;   dcl (Voice.End)  (1) fixed;   dcl (i,j,k,l,m,n)    fixed;   dcl (a,b) (1)        fixed;   dcl (ria)            fixed;   dcl (code)           fixed;   dcl (srr)            fixed;   dcl (ptime)          fixed;   dcl (seg.ptr)        fixed;   dcl (next.sync)  (1) fixed;   dcl (Adv.S#) (1) fixed;    /* holds sample # 40 msec from now */   dcl Perform.Fadein   fixed;   /* Set.Delay is called to set the delay field of an envelope computer */   /* so that an attack or decay will occur at a specific time.          */   /*                                                                    */   /* Set.Delay uses as input the following variables:                   */   /*                                                                    */   /*   Dac.S#    sample # of data that was going out dac when d16 time  */   /*             was measured                                           */   /*   Adv.S#    sample # that is computed for 40 milliseconds in       */   /*             front of us                                            */   /*   D16Info   D16 time corresponding to Dac.S#                       */   /*   Time      Sample # where 2.56 millisecond attack/decay is to     */   /*             end                                                    */   Set.Delay: proc(voice#, time, backup);      dcl voice#     fixed;   /* pass voice # to set delay for           */      dcl time       array;   /* pass time we want the voice turned on   */      dcl backup     fixed;   /* # of milliseconds before time           */      dcl a(1)       fixed;      dcl i          fixed;      if  ( Now.Playing    =  0 )      /* if not playing, not triggering, */      and ( Now.Triggering =  0 )      /* or not looping forward, then    */      and ((Now.Looping    =  0)       /* cannot use delay field          */      or   (Active.Rate    <= 0))      then return 0;      if COM32(Dac.S#, Time) >= lw#ieq /* use no delay if we are already  */      then return 0;                   /* late                            */      if COM32(Time, Adv.S#) =  lw#igt /* use no delay if there was no    */      then return 0;                   /* valid segment end time          */      call SUB32(Time, Dac.S#, A);     /* get # of samples to delay       */      /* # of d16 ticks to wait = d16tim       (ticks/msec)               */      /*                        * 40           (constant  )               */      /*                        * samples      (samples to wait)          */      /*                        / active.rate  (40*samples/msec)          */      load d16tim         ;      mul  40             ;      mwait               ;      mul  a(1)           ;      mwait               ;      div abs(active.rate);      i = D16Info(1) + res - backup*d16tim;  /* get d16 info x msec before */      disable;         i = i-read(d16);              /* get ticks to wait                */         if i > 0 then do;             /* only positive amounts are valid  */            load i    ;                /* d16 ticks                        */            mul 25    ;                /* * 25  (to match 25 khz env comp) */            mwait     ;            div d16tim;                /* / (d16 ticks/msec)               */            write(psc) = Voice# + Base.Voice#;            write(psf) = psecnt;            write(psd) = 4095 - res;         end;      enable;      return 1;   end Set.Delay;   /* $page - routine to check envelope segments and update volume */   check.envelope: proc(voice#, track#);      dcl (voice#)    fixed;  /* pass voice #           */      dcl (track#)    fixed;  /* pass track #           */      dcl (i,j,k,l)   fixed;      dcl (a)  (1)    fixed;      /* if looping,  find the value we should be at */      /* and go there in 20 milliseconds:            */      if now.looping <> 0      then do;         j = Find.Envelope.Value(track#, Dac.S#);         write(mam) = venv.xmsec#;         write(mal) = (voice#*venv.stride) + venv.adder;         write(mdi) = 4095;                 /* venv.adder */         write(mdi) = 8;                    /* venv.delta */         write(mdi) = j;                    /* venv.limit */         return;      end;      /* Look at envelope list for this track to see */      /* what the current envelope limit & ramp-in   */      /* settings are.                               */      write(mam) = cseg.xmsec#;                    /* get pointer to */      write(mal) = Env.Cue.Heads + shl(track#, 1); /* first block of */      i          = read(md);                       /* this track     */      /* if no block on cue,  just set up cur.env    */      /* value:                                      */      if i = (Env.Cue.Heads + shl(track#, 1))      then do;         write(mam) = venv.xmsec#;         write(mal) = (voice#*venv.stride) + venv.adder;         write(mdi) = 4095;                /* venv.adder */         write(mdi) = 64;                  /* venv.delta */         write(mdi) = cur.env.val(track#); /* venv.limit */         return;      end;      /* if a block exists,  look at it further:         */      call read.env.stack(i);         /* get global info */      /* if this envelope segment does not start for a   */      /* while,  make sure the current limit reflects    */      /* our necessary starting value.  That way we will */      /* go to the right limit when the cue is first     */      /* qued up                                         */      if COM32(Adv.S#, Env.Sync) = lw#ilt      then do;         write(mam) = venv.xmsec#;         write(mal) = (voice#*venv.stride) + venv.adder;         write(mdi) = 4095;                 /* venv.adder */         write(mdi) = 64;                   /* venv.delta */         write(mdi) = Env.Sval;             /* venv.limit */         return;      end;            /* We know it is time to start this envelope        */      /* segment.   Either it starts within 40            */      /* milliseconds from now,  or maybe it should have  */      /* started at some time in the past.  Take a look.  */      check.next.env:;   /* come from below to look ahead */      /* if this segment has not been written to          */      /* synth, see what we should do:                    */      if Env.Adder >= 0  /* if segment has not been       */      then do;           /* started yet ...               */         /* See if we are already late starting this      */         /* segment.  If we are, quickly go to the        */         /* correct value for this time & then start      */         /* the envelope.                                 */         if COM32(Dac.S#, Env.Sync) >= lw#ieq  /* if we are already late,  */         then do;                              /* then write out now       */            /* see what the current value is:                              */            disable;            write(psc) = Base.Voice# + voice#; /* read current value      */            write(psf) = pseval;               /* for the voice           */            j          = read(psd);            enable;            /* see what it should be now,  and now + 40 msecs:            */            k = Quickly.Find.First.Envelope.Value(track#, Dac.S#);            l = Quickly.Find.First.Envelope.Value(track#, Adv.S#);            /* if it is between the value it should be at now and it      */            /* should be at 40 msecs from now, then start the envelope    */            /* segment.  Allow for round off error, and check for         */            /* both up and down envelope segments:                        */            if  ((j >= (k-1)) and (j <= (l+1)))            or  ((j <= (k+1)) and (j >= (l-1)))            then do;               write(mam) = venv.xmsec#;               write(mal) = (voice#*venv.stride) + venv.adder;               write(mdi) = Env.Adder;            /* venv.adder */               write(mdi) = Env.Delta;            /* venv.delta */               write(mdi) = Env.Limit;            /* venv.limit */               Env.Adder = Env.Adder \ 32768;     /* set "written" bit  */               call write.env.stack(i);               return;            end;            /* Else go to the desired value quickly and (hopefully)     */            /* start the envelope segment next time around:             */            write(mam) = venv.xmsec#;            write(mal) = (voice#*venv.stride) + venv.adder;            write(mdi) = 4095;                 /* venv.adder */            write(mdi) = 64;                   /* venv.delta */            write(mdi) = l;                    /* venv.limit */            if fastboot then print 'Late';            return;         end;         /* Else we know that this envelope segment should start        */         /* sometime between now and now + 40 milliseconds.             */         /* If the current envelope value has reached our starting      */         /* value,  then we use the delay function to start our         */         /* segment precisely on time.                                  */         disable;         write(psc) = Base.Voice# + voice#;  /* read current value      */         write(psf) = pseval;                /* for the voice           */         j          = read(psd);         enable;         if (j = (Env.Sval  ))     /* see if current value matches      */         or (j = (Env.Sval-1))     /* our starting value.  Allow for    */         or (j = (Env.Sval+1))     /* some round-off error.             */         then do;            call Set.Delay(voice#, Env.Sync, 0);  /* delay to start     */            write(mam) = venv.xmsec#;            write(mal) = (voice#*venv.stride) + venv.adder;            write(mdi) = Env.Adder;            /* venv.adder */            write(mdi) = Env.Delta;            /* venv.delta */            write(mdi) = Env.Limit;            /* venv.limit */            Env.Adder = Env.Adder \ 32768;     /* set "written" bit     */            call write.env.stack(i);            return;         end;         /* else we are not at our sval yet so we cannot use the    */         /* the delay field because that would cause the current    */         /* envelope segment to 'freeze'.   Just set our sval       */         /* as the new limit & wait.  Rate should be correct.       */         write(mam) = venv.xmsec#;         write(mal) = (voice#*venv.stride) + venv.limit;         write(mdi) = Env.Sval;            /* venv.limit */         return;      end;      /* else if this segment has been started,  see if it might       */      /* be done yet.  If it should be done,  check the next block     */      /* on the list to see if it might be time to start that          */      /* segment:                                                      */      if  (COM32(Adv.S#, Env.Send) >= lw#ieq)      and (Env.Fptr <> (Env.Cue.Heads + shl(track#, 1)))      then do;         call genv.info(Env.Fptr + Env.Sync.Loc);         a(0) = read(mdi);               /* get time the next segment  */         a(1) = read(mdi);               /* should start.              */         if COM32(Adv.S#, a) >= lw#ieq   /* if that is imminently      */         then do;                        /* upon us,  then look        */            i = Env.Fptr;                /* at it.                     */            call read.env.stack(i);            goto check.next.env;         end;      end;      /* else just reset the limit to our */      /* segment in case it changes when  */      /* a new segment gets stacked.      */      /* Also re-write adder and delta    */      /* in case we are starting up       */      /* the voice again after            */      /* a dropout.                       */      write(mam) = venv.xmsec#;      write(mal) = (voice#*venv.stride) + venv.adder;      write(mdi) = Env.Adder;      write(mdi) = Env.Delta;      write(mdi) = Env.LImit;            /* venv.limit */   end check.envelope;   /* $page - Loop over tracks to check DOA routing */   /* begin by clearing out desired track# info     */   /* so voices will get turned off if they         */   /* become unrouted                               */   write("313") = addr(desired.track#(0));  /* assume each voice        */   rpc max.voices;                          /* should be muted (not     */   write("373") = 0;                        /* assigned to any track    */   /* Now compute a sample # that is 40 msec in front of us.   This     */   /* will give us a chance to switch the audio on or off in time       */   call COPY32(Dac.S#, Adv.S#);             /* get current sample #     */   call ADD16(abs(Active.Rate), Adv.S#);    /* plus 40 msecs from now   */   /* now check each track.   check for input happening (turn on        */   /* ADC channel if needed).   Then check mode (repro/input/auto/cue)  */   /* to check desired routing and its priority                         */   do track#=0 to max.tracks-1;             /* check each track        */      if track.available(track#)<>0         /* if track is available   */      then do;                              /* then look for output    */         /* Check STM Input channels for clipping:  */         if rec.chan.on(track#) <> 0 then do;               write(psc)=track.rvoice#(track#);   /* look up input channel #          */            write(psf)=psadenv;            j=read(psd);            if  (j>=235)            and (log.buf(0)=0)            then do;               call log.error('Warning: Clip on Track ');               call append.decimal.number(track#+1);            end;         end;         /* compute desired output voice assignment */         /* Check cue stack for each track.   See what output voice */         /* is desired for the segment of audio that is going out   */         /* the dac 20 msec from now                                */         voice# = track.dir(track#*track.len+track.routs) & 255;         if voice# = 0 then voice# = 31;         /* for now, map off to 31, */         else               voice# = voice# - 1; /* compute 0 - x           */         strack#  = 0;               /* with no syncl track vol info  */         priority = 0;               /* lowest priority               */         call STR32( 0,  0, Voice.Sync); /* no sync delay             */         call STR32(-1, -1, Voice.End ); /* no ending sync delay      */         /* look up mode   for this track (repro/input/auto/cue pb)   */         /* look up status for this track (safe/ready             )   */         /* compute desired repro vs input mode for automatic         */         /* and cue playback selections                               */         srr = track.dir(track#*track.len+track.stat);         ria = shr(srr,8);             /* get repro/input/auto    */         srr = srr & 255;              /* get safe/ready          */         /* ria: 0 = repro     1 =  input    2 = auto     3 = cue playback */         /* srr: 0 = safe      1 =  ready    2 = locked                    */         if (ria = 0)     /* track is in repro - use default voice assign  */         then do;         /* computed above                                */         end;         else if  (ria=1) /* INPUT mode selected by user. */         then do;         /* means monitor input if an    */                          /* input is assigned,  or mute  */                          /* the output if no input is    */                          /* assigned                     */            if  ((now.triggering<>0)             /* if triggering       */            or   (now.looping   <>0))            /* or looping          */            and ((trig.tracks&bits(track#))<>0)  /* on this track       */            then    do;               ria = 0;     /* override input if cue trigger from terminal */            end;            /* use routing computed above                  */            else if ((now.playing                <> 0 )  /* if play output   */            and      (audit.cue.stacked (track#) <> 0 )) /* audit cue...     */            then do;               ria = 0;     /* override input if auditioning cue           */            end;            /* while in input mode                         */            else do;        /* user must be using INPUT to mute or monitor */               priority = 2;            end;         end;         else do;      /* else must be auto or cue pb:  AUTOMATE! */            /* always use repro for 'safe' tracks if auto or cue pb: */            if srr <> 1                               /* if not ready, then */            then ria = 0;                             /* repro always       */            /* use input mode if recording */            /* on this track:              */            else if  ((now.playing      = 0)          /* if not playing     */            and       (now.triggering   = 0)          /* and not triggering */            and       (now.looping      = 0)          /* and not looping    */            and       (trig             = 0))         /* no trig pending    */            or       ((precd.tracks&bits(track#))<>0) /* or recording       */            then ria = 1;                             /* then use input     */            /* use input mode if rehearsing and current seq time */            /* is within the rehearse region                     */            else if (armed                      <>0) /* if armed recd'g */            and     (now.playing                <>0) /* play output     */            and     (recrec(recrec.rehearse)    <>0) /* doing rehearse  */            and     ((armd.tracks&bits(track#)) <>0) /* on this track   */            and     (source.or.cue    (track#)  <>0) /* and cue pb      */            and     (recrec(recrec.stacked)     <>0) /* recrec stacked  */            and     (((s#msb igt recrec(recrec.sync.msb)))   /* and time */            or       ((s#msb  =  recrec(recrec.sync.msb))    /* is in    */            and       (s#lsb ige recrec(recrec.sync.lsb))))  /* rehrse   */            and     (((s#msb ilt recrec(recrec.send.msb)))   /* region   */            or       ((s#msb  =  recrec(recrec.send.msb))            and       (s#lsb ilt recrec(recrec.send.lsb))))            then ria = 1;                        /* then use input to mute during rehearse portion */            /* use repro mode if in auto mode and seq is playing,  or in */            /* or in cue pb mode and seq is going and cues are stacked   */            else if (( now.playing               <> 0 )  /* if play output   */            and      ((any.cues.stacked (track#) <> 0)   /* and cues         */            or        (ria                       =  2))) /* or auto (vs cpb) */            or      (((trig                     <> 0)    /* or about to trig */            or        (now.looping              <> 0))   /* or doing loops   */            and      ((trig.tracks&bits(track#))<> 0 ))  /* on this trk      */            then ria = 0;                                    /* else leave in input mode for all other conditions */            else ria = 1;  /* else leave in input for untriggered cue playback tracks */                           /* or for playing tracks in cue p that are ready until cue is triggered */         end;         if ria<>last.ria(track#)         then do;            status.tracks = status.tracks \ bits(track#);            last.ria(track#) = ria;         end;         /* advance real time cue stack pointer for this track */         /* always.   look up output # (etc) if we are repro.  */         /* Scan ahead to find audio segment (if one) that     */         /* will be playing 40 msec from now                   */         /* Also advance the real time envelope list for this  */         /* track to garbage collect it.                       */         if  ( source.or.cue(track#) <> 0 )      /* if cue playback      */         and ((now.playing           <> 0)       /* and playing          */         or   (now.triggering        <> 0)       /* or triggering        */         or   (now.looping           <> 0))      /* or looping           */         then do;                                /* then check cue stack */            next.cue:;            /* if entry exists on real time cue stack,  and we have not */            /* wrapped to the current store pointer,  then check audio  */            /* segment data                                             */            if cue.rt.ptr(track#) <> 0            then do;               call read.seg.stack(cue.rt.ptr(track#)); /* get info     */               /* advance cue stack read pointer if time has advanced   */               /* to off of end of cue                                  */               if COM32(Dac.S#, Seg.End) >= lw#ieq  /* see if past end  */               then do;                             /* of this seg      */                  if Seg.Fptr = shl(track#, 1)                  then cue.rt.ptr(track#) = 0;                  else cue.rt.ptr(track#) = Seg.Fptr;                  goto next.cue;               end;               /* back up to prior segment (only needed if looping)      */               /* and we have scrubbed backwards to it.                  */               else if (now.looping <> 0             )    /* looping...  */               and     (Seg.Bptr    <> shl(track#, 1))    /* earlier blk */               and     (COM32(Dac.S#, Seg.Sync) = lw#ilt) /* exists,     */               then do;                                   /* then check  */                  call gseg.info(Seg.Bptr + Seg.End.Loc);                  Next.Sync(0) = read(mdi);  /* get the end time of  */                  Next.Sync(1) = read(mdi);  /* the PRIOR segment!   */                  if COM32(Dac.S#, Next.Sync) = lw#ilt                  then do;                     cue.rt.ptr(track#) = Seg.Bptr;                     goto next.cue;                  end;               end;               if (ria = 0)          /* if output desired               */               then do;              /* then look up output & info      */                  /* prescan ahead to see if advanced time is already   */                  /* into the next audio segment.  check it if so       */                  next.seg:;                  if  (COM32(Adv.S#, Seg.End) >= lw#ieq) /* time past end of this cue */                  and (Seg.Fptr <> shl(track#, 1))       /* and we have another one   */                  then do;                     call gseg.info(Seg.Fptr + Seg.Sync.Loc);                     Next.Sync(0) = read(mdi);  /* get the start time of */                     Next.Sync(1) = read(mdi);  /* the NEXT segment!     */                     if COM32(Adv.S#, Next.Sync) >= lw#ieq                     then do;                        call read.seg.stack(Seg.Fptr);  /* get next segment info */                        goto next.seg;                  /* will advance seg.fptr for us */                     end;                  end;                  if  (Seg.Info <> 0)   /* if syncl track#/routing info    */                  then do;                     strack# = shr(Seg.Info,6); /* get syncl track # info  */                                                /* if any used.  will be   */                                                /* 512 + syncl track # if  */                                                /* nonzero                 */                     if  ((Seg.Info & 63) <> 0) /* if routing specified    */                     then do;                   /* look up routing         */                        voice#   = Seg.Info & 31;                        priority = 1;                             /* save Voice.Time for priority comparisons */                        /* save Voice.End to accurately switch off  */                        /* voice at end of this particular audio    */                        /* segment:                                 */                        call COPY32(Seg.Time, Voice.Time);                        call COPY32(Seg.Sync, Voice.Sync);                        call COPY32(Seg.End,  Voice.End );                     end;                  end;               end;            end;            /* else if we are looping, see if we are scrubbing backwards */            /* at the end of the sequence and have run into the end of   */            /* the last segment on the list:                             */            else if now.looping <> 0 then do;               write(mam) = cseg.xmsec#;               /* get pointer to */               write(mal) = shl(track#, 1) + 1;        /* last  block of */               i = read(md);                           /* this track     */               if i <> shl(track#, 1)                  /* if block is    */               then do;                                /* there, look... */                  call read.seg.stack(i);              /* get info       */                  /* back up cue stack read pointer if time has gone back*/                  /* to where there is data stacked:                     */                  if COM32(Dac.S#, Seg.End) = lw#ilt  /* see if past end */                  then do;                            /* of this seg     */                     cue.rt.ptr(track#) = i;                     goto next.cue;                  end;               end;            end;            /* Perform garbage collection of the track envelope segment list. */            /* Do this by removing any segments that are over with for sure   */            /* by now.  That way,  the envelope list will have the correct    */            /* segment on the front if it if we are about to turn on          */            /* a voice.  If looping,  keep the entire segment list intact     */            /* because we might scrub backwards to it.                        */            if now.looping = 0            then do;               next.env:;               write(mam) = cseg.xmsec#;                    /* get pointer to */               write(mal) = Env.Cue.Heads + shl(track#, 1); /* first block of */               i          = read(md);                       /* this track     */               /* if there is a block on the list,  look at it                */               if i <> (Env.Cue.Heads + shl(track#, 1))               then do;                  call read.env.stack(i);   /* get global variables handy     */                  if COM32(Dac.S#, Env.Send) >= lw#ieq                  then do;                     cur.env.val(track#) = Env.Limit;                     New.Cur.Env = New.Cur.Env \ bits(track#);                     call UnLink.Envelope.Record (i);                     call Release.Envelope.Record(i);                     goto next.env;                  end;               end;            end;         end;         /* Resolve voice conflicts here  */         /* make sure voice# is in range: */         if (voice# < (Polynumv - Base.Voice#))         then do;            /* if no prior track has requested the use of this output: */            if  (Desired.Track#(voice#) = 0)                                                        /* or if a prior track has requested the use of this       */            /* output,  and this is a cue trigger and the prior        */            /* request was for repro audio and it is approaching       */            /* the time to play the cue:                               */            or  ((priority  > Desired.Priority(voice#))              and  (COM32(Adv.S#, Voice.Sync ) >= lw#ieq))                                                                      /* or if a prior track has requested the use of this       */            /* output,  and the prior track was triggering a cue       */            /* and we are triggering repro data BUT it is not close    */            /* to the time to trigger the cue yet:                     */            or  ((priority  < Desired.Priority(voice#))              and  (COM32(Adv.S#, loc(addr(Desired.Sync(voice#*2)))) < lw#ieq))            /* or if two tracks both triggering cues are requesting    */            /* this output and this cue is later and it is time to     */            /* trigger it,  or  the other cue is later but it is not   */            /* time to trigger it yet:                                 */            or  ((priority = Desired.Priority(voice#))   /* or equal priority  */            and  (priority = 1                       )   /* of priority 1      */            and  (((COM32(Voice.Time,loc(addr(Desired.Time(voice#*2))))>= lw#ieq)            and    (COM32(Adv.S#,    Voice.Sync                       )>= lw#ieq)            and    (COM32(Adv.S#,    Voice.End                        ) = lw#ilt))            or    ((COM32(Voice.Time,loc(addr(Desired.Time(voice#*2))))<= lw#ieq)            and    (COM32(Adv.S#,    loc(addr(Desired.Sync(voice#*2)))) = lw#ilt))))            /* then route this track # to this voice#:                  */            then do;               Desired.Track#  (voice#) = 256 + track#;               Desired.Priority(voice#) = priority;               Desired.Strack# (voice#) = strack#;               call COPY32(Voice.Time, loc(addr(Desired.Time(voice#*2))));               call COPY32(Voice.Sync, loc(addr(Desired.Sync(voice#*2))));               call COPY32(Voice.End,  loc(addr(Desired.End (voice#*2))));            end;         end;      end;   end;   /* $page - loop over voice outputs   */   /* no loop over each voice.   turn the voice on or off as         */   /* required,  from the correct track                              */   /* also set up the routing of output voices to DDT outputs        */   /* Initialize to assume there are no voices assigned to           */   /* the DDT outputs:                                               */   write("313") = addr(desired.voice#(0));  /* assume each DDT output  */   rpc max.ddts;                            /* should be muted (not    */   write("373") = 0;                        /* assigned to any voice   */   do voice#=0 to max.voices-1;             /* check each voice      */      /* if channel should be muted,  then  */      /* do so                              */      if Desired.Track# (voice#) = 0           /* see if channel should */      then do;                                 /* be muted.             */         if Chan.On (voice#) <> 0              /* turn it off if it is  */         then do;                              /* on, else leave off    */            /* use delay field to catch very end of cue out this output */            /* if audio segment came from a clearly defined cue         */            if (Chan.On.Priority(voice#) = 1)            then call Set.Delay(voice#,loc(addr(Chan.On.End(2*voice#))), 3);            call turn.off.voice(voice#, 0);         end;      end;      /* if voice is routed to wrong track, */      /* then turn it off before we         */      /* reroute it                         */      else if (Chan.On        (voice#) <> (0                          ))      and     (Desired.Track# (voice#) <> (256+Chan.On.Track# (voice#)))      then do;         /* if audio segment coming out this output has a clearly defined */         /* end point,  and the new audio we want to switch to has no     */         /* clearly defined starting point (most likely all zeroes), then */         /* use delay field to capture very end of cue                    */         if  (Chan.On.Priority(voice#) = 1)         and (Desired.Priority(voice#) = 0)         then call Set.Delay(voice#,loc(addr(Chan.On.End(2*voice#))), 3);         call turn.off.voice(voice#, 0);      end;      /* if voice is not on,  or is on and  */      /* playing from the correct track,    */      /* then look more closely             */      else do;         track# = Desired.Track#(voice#) & 255; /* get track# handy        */         /* See what state the voice should be in.   Set it to the         */         /* correct state.                                                 */         if Last.Ria(track#) = 0 then do;       /* if repro desired ...    */            /* turn off voice immediately if we were monitoring and we     */            /* now want repro to provide instantaneous switching for       */            /* cue trigger playback:                                       */            if ((chan.on(voice#) & 4) <> 0)          /* if was doing input */            then call turn.off.voice(voice#, immed); /* then turn off      */            /* turn on repro playback if repro desired, */            /* the track is not muted,  and the data    */            /* is sitting in one of the buffers, or     */            /* in the case of max-trax, we are reading  */            /* data for this track:                     */            if  (    track.recording (track#)  = 0    ) /* not recording */            and (((  now.playing               <>0 )    /* if doing 'play' output on this track */            and   (((play.tracks&bits(track#)) <>0)     /* and track is not muted,  or a cue    */            or     ((source.or.cue   (track#)) <>0)))   /* has been triggered                   */            or   ((( now.triggering            <>0 )    /* or doing triggered output            */            or     ( now.looping               <>0 ))   /* or scrubbing                         */            and   ( (trig.tracks&bits(track#)) <>0  ))) /* on this track                        */            and (buffers.are.in.range(track#) <> 0    )            then do;               /* check for more envelope segments and update  */               /* the volume register if already doing repro:  */               if chan.on(voice#) = 2               then do;                  call check.envelope(voice#, track#);                  call update.volume (voice#);               end;               /* else turn the voice on for repro playback    */               /* provided it has been switched off of input   */               /* monitoring above:                            */               else if (chan.on(voice#) & 4) = 0  /* double check to make sure input was turned off above */               then do;                  /* Turn voice on in repro immediately if no delay */                  /* needed:                                        */                  if  punch.out.pending = 0                  then do;                     if  (Desired.Priority(voice#) = 1)                     and (immed                    = 0)                     and (Set.Delay(voice#,loc(addr(Desired.Sync(2*voice#))), 3) <> 0)                     then call turn.on.voice(voice#, track#,                                              loc(addr(Desired.Sync(2*voice#))),                                             0);                     else call turn.on.voice(voice#, track#, Dac.S#, immed);                  end;                  /* Else wait for data to be loaded for all       */                  /* voices before turning voices back on.         */                  /* Currently, this algorithm will blow up if     */                  /* one voice is not routed to any output while   */                  /* another voice is ...                          */                  else punch.out.pending = punch.out.pending & (not(bits(track#)));               end;            end;            /* else keep turning channel off if that is what we */            /* are doing but it is not off yet:                 */            else if (chan.on(voice#) & 2) <> 0            then call turn.off.voice(voice#,0);         end;         /* if input mode is desired,  turn it off of repro mode and       */         /* turn it on to input mode when we can:                          */         else do;                             /* else input mode desired   */            /* turn on input monitoring if desired */            /* and data is available:              */            if  (new.inputs            = 0)  /* if no new input routings   */            and (func                  = 0)  /* and not data reading       */            and ((chan.on(voice#) & 2) = 0)  /* and not doing repro        */            and ((  track.sampling(track#)  =  1  )  /* and ADC available      */            or   (( track.sampling(track#)  >= 2 )   /* or DIG available       */            and   ((now.playing             <> 0)    /* and playing            */            or     (now.triggering          <> 0)    /* or triggering          */            or     (now.monitoring          <> 0)))) /* or monitoring          */            then do;               if (chan.on(voice#) = 4)               then call update.monitor.volume(voice#);               else call turn.on.input.voice(voice#, track#, immed);            end;            else if chan.on(voice#) <> 0        /* turn off voice if wasn't  */            then call turn.off.voice(voice#, 0);         end;      end;      /* $page - Look up DDT output routing for each voice */      /* look up DDT output routing for this voice */      /* to have it handy.   0 is unrouted.  1     */      /* is output 0, etc.                         */      ddt# = shr(track.dir(voice#*track.len+track.routs),8);      if ddt# <> 0 then do;                    /* if any, look at it */         if  ((Dig.Xfer.Mode & Dig.Out) <> 0)  /* if doing DDT output */         and (ddt# ILE Max.DDTS   )            /* and arg is in rage  */         and (DDT.Connect.Mode = 0)            /* and routing         */         then do;                              /* then establish link */            desired.voice#(ddt#-1) = 256 \ voice#;         end;      end;   end;   if (real.milliseconds-ptime) igt 20 then do;   /* send new peaks */      ptime=real.milliseconds;      call set.level.display(track.levels);   end;