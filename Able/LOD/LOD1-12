/* :LOD:LOD1-12  routines to map synclavier times to disk sample #'s *//* 11/08/88 - cj: Fixed bug with REHEARSE function, which did not    *//*                work correctly if track was in cue playback        *//*                mode.                                              *//* compute address and sync time examines the current synclavier   time base (in play.time.msb, play.time.lsb, play.time.acu) that   occurred at d16 time sync.time.msb, sync.time.lsb.   it computes the time at some future time (>=approx 10 msec from now)   at which a certain sample # should be played.   the future time is returned in play.sync.time.msb, play.sync.time.lsb   the sample # is returned in play.s#.msb, play.s#.lsb */dcl (new.buffer.position)   fixed;  /* true when desired pos changes */dcl (new.buffer.time    )   fixed;dcl (Buffered)       (1)    fixed;  /* sample # wich is most likely  */dcl (buffered.msb)   lit    'Buffered(0)';  /* in the start of the   */dcl (buffered.lsb)   lit    'Buffered(1)';  /* playback buffers      */dcl (New.Buf)        (1)    fixed;  /* sample # of desired new buf   */dcl (new.buf.msb)    lit    'New.Buf(0)';   /* position              */dcl (new.buf.lsb)    lit    'New.Buf(1)';dcl (Play.Sync.Time) (1)    fixed;  /* holds d16 time at which to    */dcl (play.sync.time.msb)lit 'Play.Sync.Time(0)';  /* start dtd outpt */dcl (play.sync.time.lsb)lit 'Play.Sync.Time(1)';  /* from Play.S#    */dcl (Play.S#)        (1)    fixed;  /* Sample # to play that matches */dcl (play.s#.msb)    lit    'Play.S#(0)';  /* Play.Sync.Time         */dcl (play.s#.lsb)    lit    'Play.S#(1)';dcl (Sync.Window)    fixed;                /* # of samples in trig.delay */compute.address.and.sync.time:proc(boundary);   dcl (boundary)     fixed;               /* 1 = force to sector boundary */                                           /* 2 = use cue.time.msb,lsb,acu */   dcl (msb)          fixed;               /* milliseconds, msb */   dcl (lsb)          fixed;               /* milliseconds, lsb */   dcl (acu)          fixed;               /* microseconds      */   dcl (i,j,k)        fixed;   dcl (a) (1)        fixed;   /* first compute the number of sectors of data */   /* in approx .25 second.   we will use this    */   /* number for two calculations:  (sync.window) */   /*                                             */   /*   1.  if the track buffers contains data    */   /*       that is within .25 second of the      */   /*       desired start time,  we will try to   */   /*       start the output there                */   /*                                             */   /*   2.  if the track buffers are not loaded   */   /*       when we want to play (i.e. random)    */   /*       then we will start loading them       */   /*       with data that corresponds to .25     */   /*       a second from now                     */   load current.rate; mul Trig.Delay;      /* compute # of samples */   mwait;             div  10;             /* in Trig.Delay msecs  */   Sync.Window=res;   if smpte.onoff<>0 then do;                  /* smpte                */      load Sync.Window; mul smpte.track.rate;  /* provide smaller      */      if ures>=smpte.mode.rate                 /* window at slow       */      then Sync.Window=51200;                  /* smpte rates          */      else do;         div smpte.mode.rate;         Sync.Window=res;      end;   end;   if   Sync.Window ILT 10      /* limit to useful range for  */   then Sync.Window  =  10;     /* very slow rates            */   if   Sync.Window igt 51200   /* and fast rates to avoid    */   then Sync.Window  =  51200;  /* overflow                   */   /* now by sampling synclavier time base into our variables */   msb=play.time.msb;                      /* synclavier time base */   lsb=play.time.lsb;                      /* was here             */   acu=play.time.acu;   call COPY32(Sync.Time, Play.Sync.Time); /* when we were here    */                                           /* d16 time             */   /* normalize the synclavier time base */   do while acu < 0;                       /* check for minus      */      acu=acu+1000;                        /* happens especially   */      lsb=lsb-1;                           /* if smpte rounding    */      if lsb=(-1) then msb=msb-1;   end;   if acu > 1000 then do;      load acu;      div 1000;      lsb=lsb+res;      if lsb ilt res then do;         msb=msb+1;      end;      acu=rem;   end;   /* $page - more address mapping */   /* see if synclavier time is before first click.   if so,  */   /* compute time in the future where the synclavier time    */   /* would be equal to the first click,  and advance our     */   /* sync time to there                                      */   if (msb=0) & (lsb ilt zero.time)   then do;                                /* is before first click */      load  (zero.time-lsb);               /* # of syncl ticks to zero.time */      mul 1000;                            /* get # of synclav microseconds until first click */      bitmsb=ures; bitlsb=res;                   if bitlsb ilt acu then               /* subtrack time accum           */      bitmsb=bitmsb-1;      bitlsb=bitlsb-acu;                   /* synclav microseconds to first click */      /* bitlsb,bitmsb hold the synclavier microseconds (scaled by speed) */      /* until the first click.   we want to uncorrect for the speed to   */      /* compute the actual real microseconds until the first click.      */      /* we also want to compute the time in d16 timer ticks              */      /* d16tim = d16 ticks per millisecond                               */      /* so d16tim/1000 = d16ticks per microsecond                        */      /* 1000/speed = speed ratio inverse                                 */      /* so:                                                              */      call ratio_multiply(d16tim,samp.speed); /* easy enough */      if smpte.onoff<>0 then do;              /* must wait longer if slow smpte speed */         call ratio_multiply(smpte.mode.rate,smpte.track.rate);      end;      /* add to play.sync.time to get     */      /* time of first click:             */      call ADD32(Play.Sync.Time, Bit, Play.Sync.Time);      lsb=zero.time;            /* corresponding synclavier time */      acu=0;                    /* is at zero.time               */   end;   /* subtrack zero.time from synclav time base */   /* this will line up our recording with      */   /* the first click                           */   if lsb ilt zero.time then   msb=msb-1;   lsb=lsb-zero.time;   /* now compute the sample # that corresponds */   /* to that synclavier time.                  */   /* this will be a sample # with sample 0     */   /* equal to the sampling of the first click. */   /* this is done by applying an inverse       */   /* correction for the speed,  and then       */   /* a second correction for the sample rate.  */   call COPY32(Song.Data.S#, Play.S#);     /* start with sample # at start of song */   bitmsb=msb; bitlsb=lsb;                 /* get current synclavier play time */      ratio_multiply(100, 1);                 /* compute sample # based on 100 khz sampling */   call ratio_multiply(current.rate,samp.speed);  /* correct for user specified sampling rate and synclav speed */      if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction > 0      then call ratio_multiply(2997, 3000);      else call ratio_multiply(3000, 2997);   end;   call ADD32(Play.S#, Bit, Play.S#);   bitmsb=0; bitlsb=acu;   call ratio_multiply(current.rate,samp.speed); /* correct for user specified sampling rate and synclav speed */   if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction > 0      then call ratio_multiply(2997, 3000);      else call ratio_multiply(3000, 2997);   end;   call ratio_multiply(1,10);                     /* 10 mcsec/sample       */   call ADD32(Play.S#, Bit, Play.S#);   /* $page - more address mapping */   /* now provide a 1 msec offset so we are sure to record         */   /* the first click.   start recording at 1 msec early (100 khz) */   /* or 2 msec early (50 khz).                                    */   bitmsb=0; bitlsb=d16tim;                /* 1 millisecond in d16 units */   call ratio_multiply(1000,current.rate); /* compute longer time for slower sampling rates */   if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction < 0   /****** note reverse usage ******/      then call ratio_multiply(2997, 3000);    /* instead of 29.97 frames  */      else call ratio_multiply(3000, 2997);   end;   if (bitmsb<>0) or (bitlsb igt (10*d16tim))  /* limit to 10 msec.  this  */   then do;                                    /* will allow us to capture */      bitmsb=0; bitlsb=10*d16tim;              /* the first click with     */   end;                                        /* all rates                */   if smpte.onoff<>0 then do;                  /* start even earlier if slower smpte rate */      call ratio_multiply(smpte.mode.rate,smpte.track.rate);   end;   if play.sync.time.lsb ilt bitlsb then   play.sync.time.msb=play.sync.time.msb-1;   play.sync.time.lsb=play.sync.time.lsb-bitlsb;   /* now we must provide a software window for us to start up  */   /* the oscillator,  and so forth.   make sure play.sync.time */   /* is sufficiently far in the future to do this              */   call get.d16.time;            /* get our current time */   call COPY32(Our.Time, A);     /* get d16 time now     */   call ADD16(15*D16tim, A);     /* get now + 15 msecs   */   /* use signed comparison for play.sync.time: */   if  ((play.sync.time.msb  <  a(0)))      /* see if we have a 10  msec */   or  ((play.sync.time.msb  =  a(0))       /* window.  if not,  start   */   and  (play.sync.time.lsb ilt a(1)))      /* playing with a later      */   then do;                                 /* sample at a later time    */      call SUB32(A, Play.Sync.Time, Bit);      call ratio_multiply(current.rate,10*d16tim);      if Apply.Drop.Frame.Correction <> 0  /* if correcting for drop frame */      then do;                             /* usage, then do so            */         if Apply.Drop.Frame.Correction > 0         then call ratio_multiply(2997, 3000); /* instead of 29.97 frames  */         else call ratio_multiply(3000, 2997);      end;      if smpte.onoff<>0 then do;         /* smpte: need to wait fewer samples if slow smpte */         call ratio_multiply(smpte.track.rate,smpte.mode.rate);      end;      call ADD32(Play.S#, Bit, Play.S#);      call COPY32(A, Play.Sync.Time);    /* and a later time      */   end;     /* $page - map address to sector boundary       */   /* now see if we should move to sector boundary */   /* we must do this when starting since we       */   /* can only start the oscillator with a         */   /* phase accum of 0                             */   if boundary=1 then do;      if (play.s#.lsb&255)<>0 then do;      /* sample is not on sector boundary */         i=256-(play.s#.lsb&255);           /* wait this many more samples */         call ADD16(i, Play.S#);      end;      else i=0;               /* see if we are near the point that we think is in the */      /* memory buffers.   if so,   delay starting the        */      /* output to take advantage of the fact that the        */      /* buffers are already loaded                           */      bitmsb=0; bitlsb=i;     /* save # of samples to advance time by */      if COM32(Play.S#, Buffered) = lw#ilt  /* see if buffer point sits in front of us */      then do;         load Sync.Window; mul 4;           /* see if buffere lies  */         j=play.s#.msb+ures;                /* within 1.024 secs    */         k=play.s#.lsb+ res;                /* seconds in front of  */         if k ilt res then j=j+1;           /* us                   */         k=k+512;                           /* plus extra for       */         if k ilt 512 then j=j+1;           /* round up             */         if  ((buffered.msb ilt j))         /* buffer point is      */         or  ((buffered.msb  =  j)          /* between play.s# and  */         and  (buffered.lsb ile k))         /* play.s# + 4 windows  */         then do;            k=buffered.msb-play.s#.msb;            j=buffered.lsb-play.s#.lsb;     /* wait this much more  */            if buffered.lsb ilt play.s#.lsb            then k=k-1;            bitmsb=bitmsb+k;            bitlsb=bitlsb+j;            if bitlsb ilt j            then bitmsb=bitmsb+1;            play.s#.lsb=buffered.lsb;            play.s#.msb=buffered.msb;         end;                               /* done below           */      end;      /*    samples = (current.rate/10) * (ticks/d16tim) */      /* or ticks   = (samples*10*d16tim/current.rate)   */      call ratio_multiply(10*d16tim,current.rate);      if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */      then do;                                /* usage, then do so            */         if Apply.Drop.Frame.Correction < 0   /****** note reverse usage ******/         then call ratio_multiply(2997, 3000);          else call ratio_multiply(3000, 2997);      end;      if smpte.onoff<>0 then do;   /* smpte: more time to wait if slower rate */         call ratio_multiply(smpte.mode.rate,smpte.track.rate);      end;      /* add to play.sync.time to get     */      /* of this sample:                  */      call ADD32(Play.Sync.Time, Bit, Play.Sync.Time);   end;end compute.address.and.sync.time;/* $page - set new play buffer position *//* set new play buffer position:   this routine is called      1) when a new song is called up      2) at the end of playing back a song      3) when a new mark start position is received (when not playing)   it sets up the new buffer position to be the start of the   song or the mark start point */set.new.play.buffer.position:proc;   dcl (i) fixed;   new.buffer.position=1;    /* new buffer position needed      */   if mark.button.state<>0   /* load buffers from mark start    */   then do;                  /* if one is selected              */      call COPY32(Mark.Button.S#, New.Buf);   end;   else do;      call COPY32(Song.Data.S#, New.Buf);   end;   call STR32( -1, -1, Buffered);   call lookup.all.source.or.cues;     /* set up for source or cue playback */      call clear.all.playback.cue.stacks; /* zap cue stack                     */   call clear.all.envelope.lists;      /* clear out envelope area as well   */   do i=0 to max.tracks-1;             /* trash buffer contents since       */      zap.buffer(i)=1;                 /* it may contain data from cues     */   end;end set.new.play.buffer.position;