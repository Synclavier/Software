/* INITDCL - Basic initialization routine for LOD Operating System *//* 08/13/93 - pf - Added mount.drives and dismount.drives dcls     *//* 08/14/91 - cj - Added DataEnd.S# for bug fix                    *//* 08/20/90 - cj - added code for 4 wangs/4 pats                   *//* The following variables are set up by the initilization routine *//* to reflect how the hardware is configured.                      */dcl Subsystem.Ready    fixed EXTERNAL;  /* true if lod subsystem is ready */dcl Initialize         fixed EXTERNAL;  /* nonzero when initializing      */dcl Song.Dir.Track     fixed EXTERNAL;  /* track we actually read song dir from  */dcl Error.Msb          fixed EXTERNAL;  /* detect re-activation of bad drive     */dcl Error.Lsb          fixed EXTERNAL;dcl Base.Voice#        fixed EXTERNAL;  /* assign during initialization     */dcl Zero.Sec#          fixed EXTERNAL;  /* Sector   of disk where zeroes are */dcl Zero.S#            array EXTERNAL;  /* Sample # of disk where zeroes are */dcl Zero.Len.S#        data  EXTERNAL;  /* # of samples of zeroes            */dcl Data.Sec#          fixed EXTERNAL;  /* Sector   of disk where data is  */dcl Data.S#            array EXTERNAL;  /* Sample # of disk where data is  */dcl DataEnd.S#         array EXTERNAL;  /* Sample # of disk end            */dcl Swap.Info.Loaded   fixed EXTERNAL;  /* true when swap info is loaded                       */dcl Swap.Info.Sec#     fixed EXTERNAL;  /* counter for snarfing swap code from obj file        */dcl Swap.Info.Skip     fixed EXTERNAL;  /* counter for tossing object code from obj file       */dcl dtd.max.secs        fixed EXTERNAL;dcl dtd.max.tracks      fixed EXTERNAL;dcl dtd.max.inputs      fixed EXTERNAL;dcl num.available.ports fixed EXTERNAL;   /* holds # of ports available   */dcl port.exists         array EXTERNAL; /* true if port exists      */dcl port.available      array EXTERNAL; /* true if port avaialable  */dcl port.d24.#          array EXTERNAL; /* which d24                */dcl port.track.bits     array EXTERNAL; /* bits for tracks here     */dcl port.base.track     array EXTERNAL; /* base track on this port  */dcl port.io             array EXTERNAL; /* io operation occurring   */dcl port.lun1           array EXTERNAL; /* 1 if lun1 has been set   */dcl port.timer          array EXTERNAL; /* timeout timer for drives */dcl port.status         array EXTERNAL; /* status of last i/o       */dcl port.retry          array EXTERNAL; /* holds retry count        */dcl port.last.io        array EXTERNAL; /* during request sense     */dcl port.space.info     array EXTERNAL; /* used for space command   */dcl port.io.track#      array EXTERNAL; /* track # for this command */dcl port.io.dtrack#     array EXTERNAL; /* disk track# for command  */dcl port.count          array EXTERNAL; /* use to switch tapes      */dcl port.tptr		    array EXTERNAL; /* tptr in use...			*/dcl num.available.tracks fixed EXTERNAL;dcl track.avail.bits     fixed EXTERNAL; /* bits for avail tracks - set up during initialization */dcl track.info.bits      fixed EXTERNAL; /* bits for tracks we should write directories too */dcl track.exists        array EXTERNAL; /* true if track exists     */dcl track.available     array EXTERNAL; /* true if track avail      */dcl track.base.adr      array EXTERNAL;  dcl track.port.ix       array EXTERNAL; /* holds which port# has disks  */dcl track.track.bits    array EXTERNAL; /* bits for tracks on same port */dcl track.command       array EXTERNAL; /* last command (on error)  */dcl track.status        array EXTERNAL; /* error status if one      */dcl track.numsec.msb    array EXTERNAL; /* sectors (max) on track   */dcl track.numsec.lsb    array EXTERNAL;dcl track.data.msb      array EXTERNAL; /* sector # of data area    */dcl track.data.lsb      array EXTERNAL;dcl track.adir.sec      array EXTERNAL; /* sector for adir          */dcl track.retry         array EXTERNAL; /* retry count              */dcl track.starts        array EXTERNAL; /* start drive retry count  */dcl track.ddt.zeroed    array EXTERNAL; /* true if ibuf zeroed      */dcl track.ddt.ptr       array EXTERNAL; /* ptr for zeroing          */dcl track.ddt.ctr       array EXTERNAL; /* counter for zeroing      */dcl track.ddt.msb       array EXTERNAL; /* sample pointer msb       */dcl track.ddt.lsb       array EXTERNAL; /* sample pointer lsb       */dcl compute.base.adr    lit 'track.base.adr';/* For Wren IV Rezeroing:     */dcl rezero.timer                  fixed EXTERNAL;dcl last.user.time                fixed EXTERNAL;dcl rezero.happening              fixed EXTERNAL;dcl rezero.time                   fixed EXTERNAL;/* For erase function         */dcl erase1               fixed EXTERNAL;  /* keys for the erase all */dcl erase2               fixed EXTERNAL;  /* function               */dcl eraselong            fixed EXTERNAL;  /* true for long erase    *//* For mount/dismount functinos */dcl mount.drives         fixed EXTERNAL;dcl dismount.drives      fixed EXTERNAL;dcl format.drives        fixed EXTERNAL;/* For data function reading: */dcl read.track.info               fixed EXTERNAL;    /* holds bits for tracks where info is desired */dcl read.track.msb                array EXTERNAL;dcl read.track.lsb                array EXTERNAL;dcl read.track.buf.len            array EXTERNAL; /* Buffer size to fill on READ                 */dcl read.track.buf.base           array EXTERNAL; /* offset in buffer of data to WRITE           */dcl read.track.len                array EXTERNAL;dcl read.track.chunk              array EXTERNAL; /* chunk size for actual disk ops              */dcl read.track.written            array EXTERNAL; /* # of sectors written                        */dcl read.track.time               fixed EXTERNAL;dcl timeout.point                 fixed EXTERNAL;dcl track.info.direction          fixed EXTERNAL;dcl track.info.busy               fixed EXTERNAL;dcl clean.up.all.of.poly          fixed EXTERNAL;dcl dsp.opt.data.stacked          fixed EXTERNAL; /* true if sector of data to write to opt is stacked in xmem */dcl zap.read.track.info.tracks    proc  EXTERNAL;dcl any.port.doing.io               proc         EXTERNAL;dcl any.track.actually.recording    proc         EXTERNAL;dcl any.track.recording.or.new.adir proc         EXTERNAL;/* data storage literals */dcl tptr       fixed EXTERNAL;          /* use tptr to point to current entry */dcl track.info array EXTERNAL;dcl selected.port fixed EXTERNAL;      /* for error messages           */dcl quickly.select.port        proc(fixed)        EXTERNAL;dcl select.port.or.start.reset proc(fixed,fixed)  EXTERNAL;dcl deselect                   proc(fixed)        EXTERNAL;dcl issue.reset                proc(fixed)        EXTERNAL;dcl wait.for.busfree.or.start.reset proc(fixed)   EXTERNAL;dcl issue.rezero.commands.to.all.drives proc      EXTERNAL;dcl (PolyMemSec, PolyMemWord)  fixed              EXTERNAL;dcl readdata  proc(fixed,fixed,array,fixed)       EXTERNAL;dcl writedata proc(fixed,fixed,array,fixed,fixed) EXTERNAL;dcl requestsense               proc               EXTERNAL;dcl cap.msb                    fixed              EXTERNAL;dcl cap.lsb                    fixed              EXTERNAL;dcl InquiryDataCode            array              EXTERNAL;dcl InquiryRMBCode             fixed 			  EXTERNAL;dcl ModeSenseData              array              EXTERNAL;dcl Inquire                    proc               EXTERNAL;dcl Issue.Start.Unit           proc(fixed, fixed) EXTERNAL;dcl Issue.Stop.Unit            proc(fixed)        EXTERNAL;dcl Test.Unit.Ready            proc               EXTERNAL;dcl ReadCapacity               proc               EXTERNAL;dcl ModeSense                  proc(fixed, fixed) EXTERNAL;/* Target handshake routines for talking with SYNTABULATOR */dcl Get.Scsi.Byte  proc                                EXTERNAL;dcl Get.Scsi.Word  proc                                EXTERNAL;dcl Scsi.To.Poly   proc(fixed,fixed,fixed,fixed,fixed) EXTERNAL;dcl Scsi.To.Any.Poly proc(fixed,fixed,fixed)           EXTERNAL;dcl Syncl.SCSI.Write proc (fixed,fixed,fixed,fixed,fixed,fixed) EXTERNAL;dcl Syncl.SCSI.Read  proc(fixed,fixed,fixed,fixed,fixed,fixed)  EXTERNAL;dcl Send.Scsi.Byte proc(fixed)                         EXTERNAL;dcl Send.Scsi.Word proc(fixed)                         EXTERNAL;dcl Send.Scsi.Poly proc(fixed)                         EXTERNAL;dcl Reselect.Synclavier proc(fixed, array)             EXTERNAL;dcl reload.project.dir         proc        EXTERNAL;dcl reload.track.dir           proc        EXTERNAL;dcl reload.cue.dir             proc        EXTERNAL;dcl reload.adir                proc(fixed) EXTERNAL;/* Tape Routines: */dcl tape.type         array EXTERNAL;dcl tape.recover.code array EXTERNAL;dcl port.tape.addr    array EXTERNAL;dcl tape.to.use       array EXTERNAL;dcl scanmessins proc(fixed) EXTERNAL; /* 0: no scan, 1: scan and toss message in phases */dcl Tape.Space.Count  fixed  EXTERNAL;dcl Tape.Space.Limit  fixed  EXTERNAL;dcl Tape.Space.Dir    fixed  EXTERNAL;dcl Tape.Reverse.Chunk array EXTERNAL;dcl Tape.Reverse.Count array EXTERNAL;dcl Tape.Reverse.Left  array EXTERNAL;dcl Tape.Pmem.Add     fixed EXTERNAL; /* poly memory address for read/write of data */dcl Tape.Disk.Add.Msb fixed EXTERNAL; /* disk address for jaz tapes						 */dcl Tape.Disk.Add.Lsb fixed EXTERNAL;dcl Start.Tape.Command proc(fixed,fixed,fixed,fixed) EXTERNAL;dcl append.tape.mes proc(fixed) EXTERNAL;dcl buf1.msb            array EXTERNAL; /* current buffer start     */dcl buf1.lsb            array EXTERNAL; /* for buf1                 */dcl buf1.len            array EXTERNAL;dcl buf2.msb            array EXTERNAL; /* current buffer start     */dcl buf2.lsb            array EXTERNAL; /* for buf2 (lies on top    */dcl buf2.len            array EXTERNAL; /* of buf1)                 */dcl buf3.msb            array EXTERNAL; /* rewind data stored at    */dcl buf3.lsb            array EXTERNAL; /* end of buffer (past end  */dcl buf3.len            array EXTERNAL; /* of buf1)                 */dcl clob.len            array EXTERNAL; /* amount of data in the front of buffer #1 that has been clobbered by reading data into buffer #2 */dcl recb.msb            array EXTERNAL; /* msb,lsb (sample#) of     */dcl recb.lsb            array EXTERNAL; /* record buffer start      */dcl rec.s#.msb          array EXTERNAL; /* sample # last written    */dcl rec.s#.lsb          array EXTERNAL;dcl max.s#.msb          array EXTERNAL; /* max sample # recorded    */dcl max.s#.lsb          array EXTERNAL; dcl adir.ptr            array EXTERNAL; /* store current pointer for speed optimize */dcl new.adir            array EXTERNAL; /* true on adir change      */dcl track.eof           array EXTERNAL; /* true if played past end  */dcl longconfig          array EXTERNAL; /* true if long config      */dcl this.track.shares.an.input                         array EXTERNAL; /* true if changing safe/ready on this track could re-route inputs */                     dcl piolen              array EXTERNAL; /* sectors of punch data    */dcl track.plen          array EXTERNAL; /* sampled punch length     */dcl track.toss          array EXTERNAL; /* toss buffer on stop      */dcl zap.buffer          array EXTERNAL; /* toss buffer immediately  */dcl track.recording     array EXTERNAL; /* true if recording        */dcl track.sampling      array EXTERNAL; /* contains code if an      */                                            /* input source is assigned */                                            /* for this track:          */                                            /*    0: no input assigned  */                                            /*    1: STM input          */                                            /*    2: DIG input          */                                            /*    3: OUT or TRK input   */dcl track.rvoice#       array EXTERNAL; /* recording voice #        */dcl track.punch         array EXTERNAL; /* true if cross fade needed */dcl punch.time          array EXTERNAL; /* time of punch out         */dcl valid.info          array EXTERNAL; /* track has valid catalog  */dcl valid.info.ctr      array EXTERNAL; /* looks for matchin error# */dcl track.error.msb     array EXTERNAL; /* error counter for this   */dcl track.error.lsb     array EXTERNAL; /* track read during init   */dcl track.zero.sec#     array EXTERNAL; /* additional info from     */dcl track.data.sec#     array EXTERNAL; /* this track               */dcl cue.write.sec#      array EXTERNAL; /* for writing cue directry */dcl cue.prior.sec#      array EXTERNAL; /* for writing cue directry */dcl cue.prior.ctr       array EXTERNAL; /* for writing cue directry */dcl track.mode.change   array EXTERNAL; /* for fading in            *//* Variables for operating backup tapes: */dcl tape.condition      array EXTERNAL; /* for cart insert stuff    */dcl tape.state          array EXTERNAL; /* state of tape io         */dcl tape.return.state   array EXTERNAL; /* for subroutine calls     */dcl tape.remove         array EXTERNAL;dcl tape.eof            array EXTERNAL; /*                          */dcl tape.track#         array EXTERNAL; /* track # being written    */dcl tape.data.msb       array EXTERNAL; /* for tape i/o             */dcl tape.data.lsb       array EXTERNAL;dcl tape.len.msb        array EXTERNAL;dcl tape.len.lsb        array EXTERNAL;dcl tape.copy.len.msb   array EXTERNAL;dcl tape.copy.len.lsb   array EXTERNAL;dcl tape.buf.len        array EXTERNAL;dcl tape.read.len       array EXTERNAL;dcl tape.issue.len      array EXTERNAL;dcl tape.fmark          array EXTERNAL;dcl port.empty          array EXTERNAL; /* true if trks 0 and 1 mpt */dcl tape.skip           array EXTERNAL; /* true to skip data        */dcl block.skip          array EXTERNAL; /* true to skip 1 block     */dcl port.track.list     array EXTERNAL; /* used to sort out track   */dcl port.dest.list      array EXTERNAL; /* routings during load.    */dcl port.thisdest       array EXTERNAL;dcl port.cue.ix         array EXTERNAL;dcl port.io.buf#     array EXTERNAL; /* buf#                     */dcl port.io.len#     array EXTERNAL; /* length requested         */dcl port.update      array EXTERNAL; /* true to update play vars */dcl port.upcode      array EXTERNAL; /* code for update          */dcl port.secmsb      array EXTERNAL; /* holds abs sect #         */dcl port.seclsb      array EXTERNAL; /* for accounting after wr  */dcl port.pmemsec     array EXTERNAL; /* pmem address             */dcl port.pmemwrd     array EXTERNAL;dcl port.fadein      array EXTERNAL; /* construct fade in        */dcl port.fadeout     array EXTERNAL; /* construct fade out       */dcl port.toggle      array EXTERNAL; /* track # to check         */dcl port.jaz.sec.msb array EXTERNAL; /* holds current 'tape' position */dcl port.jaz.sec.lsb array EXTERNAL;dcl port.jaz.fmk.inx array EXTERNAL; /* holds current file mark index */dcl port.jaz.cap.msb array EXTERNAL; /* holds current tape capacity	 */dcl port.jaz.cap.lsb array EXTERNAL;dcl port.jaz.update  array EXTERNAL; /* update pos by this much		 */dcl zero.jaz.position proc (fixed) external;dcl any.tape2.found  fixed EXTERNAL; /* true if any tape2 in sys */dcl Issue.Port.Command proc(fixed,fixed) EXTERNAL;  /* issue command for read/write        */dcl fill.magic.sec#        procedure (fixed, fixed, array) EXTERNAL;dcl perform.initialization procedure (array) EXTERNAL; library ':LOD:LODLIBS:INITLIB';