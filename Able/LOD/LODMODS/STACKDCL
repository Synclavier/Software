/* STACKDCL - declarations for real time cue stacking routines */dcl enabled.for.envelope.info    lit '0';         /* true if SYNCL has enabled to receive envelope info */dcl env.control.bits             fixed external;  /* control bits returned to syncl                     */dcl env.num.of.envs              fixed external;  /* number of envelope descriptors in ext memory       */dcl env.env.len                  fixed external;  /* number of words of env descriptors in ext mem      */dcl (recrec)             array EXTERNAL;  /* holds record record          */dcl (armed)              fixed EXTERNAL;  /* true if armed for recording  */dcl (stackedrecrec)      array EXTERNAL;  /* holds copy if new record record that came in during prior guy's punch out */dcl (recrec.is.stacked)  fixed EXTERNAL;dcl Sync.Point.Disk     array  EXTERNAL;   /* disk sampl # (sector bound) */ dcl Sync.Point.Trig     array  EXTERNAL;   /* trig sampl # (sector bound) */dcl Sync.Point.Used.Disk     array EXTERNAL;   /* disk sampl # (sector bound) */ dcl Sync.Point.Used.Trig     array EXTERNAL;   /* trig sampl # (sector bound) */dcl source.or.cue            array EXTERNAL;   /* 0 = source playback */                                               /* 1 = cue    playback */                                               /* 2 = src    playback after end of cue that got triggered while in source playback mode */dcl any.cues.stacked         array EXTERNAL;dcl audit.cue.stacked        array EXTERNAL;dcl record.cue.ptr           array EXTERNAL;dcl ff.speed                 fixed EXTERNAL;   /* speed for loop ff/rew */dcl Scroll.S#                array EXTERNAL;   /* sample # for scrolling base    */dcl Scroll.Base              array EXTERNAL;   /* base sample #                  */dcl New.Cur.Env           fixed EXTERNAL;  /* new cur.env.val set            */dcl New.Seg.List          fixed EXTERNAL;  /* new block linked to seg list   */dcl New.Env.List          fixed EXTERNAL;  /* new block linked to env list   *//* define in order: */dcl Seg.Fptr       fixed EXTERNAL;dcl Seg.Bptr       fixed EXTERNAL;dcl Seg.Exists     fixed EXTERNAL;   /* holds working copy of cue          */dcl Seg.Sync       array EXTERNAL;   /* must declare cue.exists = cue.end  */dcl Seg.Disk       array EXTERNAL;   /* in order                           */dcl Seg.End        array EXTERNAL;dcl Seg.Info       fixed EXTERNAL;dcl Seg.Time       array EXTERNAL;dcl Seg.Track      fixed EXTERNAL;dcl Env.Fptr       fixed EXTERNAL;dcl Env.Bptr       fixed EXTERNAL;dcl Env.Sync       array EXTERNAL;   /* must declare in order!!            */dcl Env.Len        array EXTERNAL;dcl Env.Send       array EXTERNAL;dcl Env.Sval       fixed EXTERNAL;dcl Env.Adder      fixed EXTERNAL;dcl Env.Delta      fixed EXTERNAL;dcl Env.Limit      fixed EXTERNAL;dcl gseg.info       proc (fixed) EXTERNAL; /* set up mam & mal ptrs for cue stack*/dcl genv.info       lit  'gseg.info';      /* use same routine for now           */dcl read.seg.stack  proc (fixed) EXTERNAL; /* read in current Segment Record     */dcl read.env.stack  proc (fixed) EXTERNAL; /* read in current Envelope Record    */dcl write.seg.stack proc (fixed) EXTERNAL; /* write out current Segment Record   */dcl write.env.stack proc (fixed) EXTERNAL; /* write out current Envelope Record  */dcl cue.read.ptr  array  EXTERNAL;   /* pointer for reading stack    */dcl cue.rt.ptr    array  EXTERNAL;   /* real time cue read pointer   */dcl Seg.Free.Ptr  fixed  EXTERNAL;dcl Seg.Free.Last fixed  EXTERNAL;dcl initialize.free.seg.records   proc        EXTERNAL;dcl Get.Segment.Record            proc        EXTERNAL;dcl Release.Segment.Record        proc(fixed) EXTERNAL;dcl UnLink.Segment.Record         proc(fixed) EXTERNAL;dcl Link.In.Segment.Record        proc(fixed,fixed) EXTERNAL;dcl Get.Envelope.Record           lit  'Get.Segment.Record';dcl Release.Envelope.Record       lit  'Release.Segment.Record';dcl UnLink.Envelope.Record        lit  'UnLink.Segment.Record';dcl Link.In.Envelope.Record       lit  'Link.In.Segment.Record';dcl clear.playback.cue.stack      proc(fixed) EXTERNAL;dcl clear.all.playback.cue.stacks proc        EXTERNAL;dcl clear.all.source.or.cues      proc        EXTERNAL;dcl set.all.source.or.cues        proc        EXTERNAL;dcl lookup.this.source.or.cue     proc(fixed) EXTERNAL;dcl lookup.all.source.or.cues     proc        EXTERNAL;dcl cur.env.val                   array       EXTERNAL;dcl Found.Point.Was.Mid.Segment   fixed       EXTERNAL;dcl Found.Point.Length            array       EXTERNAL;dcl Found.Point.Limit             fixed       EXTERNAL;dcl Interpolate.Envelope.Segment proc(fixed, fixed, array, array) EXTERNAL;dcl Find.Envelope.Value      proc(fixed, array)                      EXTERNAL;dcl Quickly.Find.First.Envelope.Value proc(fixed, array)             EXTERNAL;dcl Place.Envelope.Segment   proc(fixed, array, fixed, array, fixed) EXTERNAL;dcl Delete.Envelope.Range    proc(fixed, array, array)               EXTERNAL;dcl Clear.Envelope.List      proc(fixed)                             EXTERNAL;dcl clear.all.envelope.lists proc                                    EXTERNAL;dcl Stacked.End.Time          array       EXTERNAL;dcl armd.tracks               fixed       EXTERNAL;dcl new.armd.tracks           fixed       EXTERNAL;dcl stack.armed.cue           proc(fixed) EXTERNAL;dcl stack.armed.cue.if.needed proc        EXTERNAL;dcl Zero.Out.Stack.Record proc(array)     EXTERNAL;dcl Stack.Entire.Cue      proc(array)     EXTERNAL;library ':LOD:LODLIBS:STACKLIB';