/* :LOD:CUESOU - basic routines for processing cues in external memory		*//* 09/14/89 - cj  - fixed CMX "Partial Name Search" bug							*//* 02/09/89 - cj  - fixed 'muted track load/backup bug'							*//* the dtd software stores cues in external memory.  the organization		*//* of the storage memory is described in XMEMLITS									*//* the cue table is a linear list of variable length records.  The			*//* format is described below.																*//* Each cue is assigned an allocation #.  this is a unique 16-bit #			*//* that can be used to identify a particular cue.  this alloc # is used		*//* for triggering a cue playback, etc.													*//* the allocation # is an index to a look up table that has a two-word		*//* pointer to every cue.  when a cue is moved in memory this pointer			*//* is updated																					*//* three other tables are created.  the first of these is the alphabetic	*//* look up table.  this indexes the cues alphabetically.  this table			*//* is a list of allocation #'s in alphabetic order									*//* a second lookup table indexes the cues in time-order.  this table			*//* is a list of allocation #'s in order of starting time							*//* a third lookup table indexes the cues in smpte sync point time				*//* order.  this is a list of allocation #'s in order of smpte time			*//* The three tables are duplicated to list cues just in the current			*//* project																						*/module cuemod;insert ':lod:lodlits:globlits'; /* get main literals                */insert ':lod:lodlits:xmemlits'; /* literals for xmem allocation     */insert ':lod:lodlits:cuelits';  /* literals for cue storage         */insert ':lod:lodmods:miscdcl';  /* get misc routines                */dcl num.of.alloc    fixed PUBLIC;  /* number of entries in the allocation #  */                                   /* table that are used                    */dcl max.store.secs  fixed PUBLIC;  /* end of storage available for cues      */dcl max.store.disk  fixed PUBLIC;  /* # of sectors of cue storage available  */                                   /* on disk                                */dcl Cue.Data.S# (1) fixed PUBLIC;  /* holds sample # of start of audio data  */                                   /* on disk for updating cue info          *//* 6 sort tables are set up as indexes into the cue data base: *//* The following lits are codes for the different sort tables  */dcl num.of (5) fixed PUBLIC;    /* number of entries     */dcl cur.ix (5) fixed PUBLIC;    /* current dtd index     *//* Data table to look up base sector in ext memory based *//* upon the sort code                                    */dcl sort.base data public (alph.sec#,    time.sec#,    smpt.sec#,                           cs.alph.sec#, cs.time.sec#, cs.smpt.sec#);/* Variables to hold info about the actual cue data *//* base area                                        */dcl cue.num        fixed PUBLIC;  /* # of cue records in data base                   */dcl cue.numsec     fixed PUBLIC;  /* num of full sectors of cue defs                 */dcl cue.numwrd     fixed PUBLIC;  /* num or extra words of cue defs                  *//* routine to erase cue information *//* used for debugging,  but also    *//* to recover from disk error       *//* during startup                   */zero.cue.dir:proc PUBLIC swapable;   dcl i fixed;   cue.num      = 0;         /* no cues in memory yet */   cue.numsec   = 0;   cue.numwrd   = 0;   num.of.alloc = 0;   do i=0 to 5;      num.of(i)=0;      cur.ix(i)=0;   end;end zero.cue.dir;/* $page - Current Cue Record *//* the Current.Cue array is used to hold basic cue information *//* for a cue.   The segment list part of a cue is always       *//* stored in external memory                                   *//* declare these items in order: */dcl current.cue (256) fixed PUBLIC;   /* must be 256 words since it is used for other things *//* $page - variables for processing cues at a higher level */dcl current.dtd.cue# fixed PUBLIC; /* id # of most recent synclavier cue  */dcl cue.sec          fixed PUBLIC; /* holds pointer to cue in ext mem set */dcl cue.wrd          fixed PUBLIC; /* by get .cue.ptrs                    */get.cue.ptrs:proc(id#) PUBLIC;   /* look up cue pointers from alloc #     */   dcl id# fixed;   if  (id#=0)   or  (id# igt num.of.alloc)   then return 0;                   /* cue id# out of range */   call read.store(allc.sec#,shl(id#-1,1));   cue.sec=read.word;   cue.wrd=read.word;   if cue.sec=(-1) then return 0; /* see if it has been deleted */   else                 return 1;end get.cue.ptrs;get.sort.cue:proc(type,ix) PUBLIC;  /* look up nth sorted cue (time.sec#,alph.sec#,smpt.sec#) */   dcl type fixed;   dcl ix   fixed;   dcl id#  fixed;   if ix ige num.of(type)                /* check limit */   then return 0;                   call read.store(sort.base(type),ix);   id# = read.word;      if get.cue.ptrs(id#)=0 then return 0;  /* set up cue ptrs */   return id#;                            /* return alloc # */end get.sort.cue;/* pass ABSOLUTE SECTOR #s *//* routine returns actual complete length *//* of the cue                             */read.basic.cue:proc(sec,wrd,arr) PUBLIC; /* read basic cue info into array */    dcl sec fixed;     /* this routine reads only the basic */   dcl wrd fixed;     /* cue information, into an internal */   dcl arr array;     /* memory array (up through name)    */   dcl len fixed;   call read.store(sec,wrd);   write("313")=addr(arr(0));   rpc (cue.name+shr(cue.name.l+3,1));   write("373")=read(mdi);   if (arr(cue.rlen) igt Max.Cue.Record.Len)   or (arr(cue.name) igt cue.name.l        )   then do;                    /* bad data        */      arr(cue.rlen) = 0;      arr(cue.name) = 0;      return 0;   end;   /* compute length of basic cue information */   len = arr(cue.rlen);  /* save original length for return */   arr(cue.rlen) = cue.name + shr(arr(cue.name)+3,1);   return len;end read.basic.cue;/* OR.Cue.Track.Bits is used to find the list of tracks that are referenced *//* in any cue segment.   This allows us to handle multi-segmented cues      *//* with muted tracks correctly.                                             *//* Pass sector and word of where cue sits in external memory.               *//* Pass 4 bit array for 64 output bits.                                     */Or.Cue.Track.Bits: proc(sec,wrd,arr) PUBLIC;    dcl sec  fixed;     /* pass sector of XMEM holding cue   */   dcl wrd  fixed;     /* word offset                       */   dcl arr  array;     /* 4 word array for track bits       */   dcl rlen fixed;   dcl len  fixed;   dcl ptr  fixed;   dcl i    fixed;   dcl j    fixed;   call read.store(sec,wrd+cue.rlen);   /* get cue record length */   rlen = read(md);   call read.store(sec,wrd+cue.trks);   /* or basic track info   */   do i = 0 to 3;                       /* into array            */      arr(i) = read(mdi);   end;   if rlen igt Max.Cue.Record.Len       /* check for bad data    */   then return 0;   call read.store (sec, wrd+Cue.List.Ptr);   ptr = read(mdi);                     /* see if there are any  */   len = read(mdi);                     /* segment pointers.     */   if ptr <> 0   then do i = 0 to len-1 by Cue.Seg.Stride;      call read.store (sec, wrd+ptr+i+S#DriveBits1);      do j = 0 to 3;         arr(j) = arr(j) \ read(mdi);      end;   end;   return 1;end Or.Cue.Track.Bits;/* Write.Entire.Cue is called to copy an entire cue from *//* a temporary cue buffer (such as ccue.xmsec#) out to   *//* the cue data storage area                             */write.entire.cue:proc(sec,wrd,base) PUBLIC;    /* write a cue to memory */   dcl sec  fixed;  /* dest sector # */   dcl wrd  fixed;  /* dest word   # */   dcl base fixed;  /* base of cue   */   dcl i    fixed;   write(mam) = base;                   /* get length of cue     */   i = read(md);   call Move.Store(Base,0,sec,wrd,0,i);end write.entire.cue;/* $page - higher level routines for cue processing *//* Routine to perform name comparison between cues  *//* returns  0 = names equal                         *//* returns -1 = for n1 < n2                         *//* returns +1 = for n1 > n2                         *//* returns -3 = for n1 < n2 but partial match       *//* returns +3 = for n1 > n2 but partial match       */check.name:proc(n1,n2) PUBLIC;       /* look for name match */   dcl (n1,n2) array;   dcl (i ,j ) fixed;   dcl (w1,w2) fixed;   if n1(0)<n2(0) then do;   /* n1 is shorter         */      j=shr(n1(0)+3,1);      /* get word length of n1 */   end;   else do;                  /* same or n2 is shorter */      j=shr(n2(0)+3,1);      /* get word length of n2 */   end;   i=1;                      /* compare ascii parts   */   do while (i<j)            /* skip equal letters    */   and      (n1(i)=n2(i));      i=i+1;   end;   if i=j then do;           /* words match for same length */      if n1(0)<n2(0) then return (-3);   /* partial match, but shorter */      if n1(0)>n2(0) then return (+3);   /* partial match, but longer  */      else                return ( 0);   /* perfect match              */   end;   w1=n1(i); w2=n2(i);                   /* get first nonmatch word    */   if (w1&255)=(w2&255) then do;         /* if lower byte matches then */      w1=shr(w1,8); w2=shr(w2,8);        /* look at upper byte         */   end;   else do;                              /* else extract lower byte    */      w1=w1&255; w2=w2&255;   end;   if w1>w2 then do;                           if w2=0 then return +3;            /* partial match              */      else         return +1;            /* no      match              */   end;   else  do;      if w1=0 then return -3;            /* partial match              */      else         return -1;            /* no      match              */   end;end check.name;clean.cue.name:proc(name) PUBLIC;   dcl (name) array;   dcl (i   ) fixed;   if name(0) then call pbyte(name,name(0),0);  /* zero fill upper byte for compare */   do i=0 to name(0)-1;                         /* upper case                       */      if byte(name,i)>=96      then call pbyte(name,i,byte(name,i)-32);   end;end clean.cue.name;/* routines to add/delete cues */dcl found.cue.num fixed PUBLIC;  /* index entry of item (or place to insert) */dcl found.cue.id# fixed PUBLIC;  /* id#         of item (only if match     ) */perform.binary.search:proc(info,name,type) PUBLIC inc.multi.udio.swapable;    /* perform binary search */   dcl (info   )     array;   /* pass 32-bit comparison info       */   dcl (name   )     array;   /* pass alphanumeric comparison info */   dcl (type   )     fixed;   /* search type (see list below)      */   dcl (i,j,k,l)     fixed;   dcl (stype  )     fixed;   dcl (val    ) (1) fixed;   dcl (msb    ) lit 'val(0)';   dcl (lsb    ) lit 'val(1)';   /* types of searches:  */   /*    0:   find first cue that starts >= msb,lsb */   /*    1:   find first cue that starts >  msb,lsb */   /*    2:   find equal file name                  */   /*    3:   find smpt bit  that starts >= msb,lsb */   /*    4:   find smpt bit  that starts >  msb,lsb */   /*    5:   find partial equal file name          */   /* note on file name search:  if msb,lsb are <>0 */   /* then the search routine looks for a cue of    */   /* that name and that starting sample#           */   /* 10-15 are same as 0-5 but current song only   */   /* sort.look maps one of tye above type codes to a sort table id: */   dcl sort.look1 data (time.sort,    time.sort,    alph.sort,                        smpt.sort,    smpt.sort,    alph.sort);   dcl sort.look2 data (cs.time.sort, cs.time.sort, cs.alph.sort,                        cs.smpt.sort, cs.smpt.sort, cs.alph.sort);   call COPY32(info,val);           /* get working copy  */   if type>=10 then do;             /* current song sort */      type=type-10;      stype=sort.look2(type);   end;   else stype = sort.look1 (type);   found.cue.num = 0;   found.cue.id# = 0;   if name(0)<>0 then do;           /* if name is passed */      if name(0) igt cue.name.l     /* then check for    */      then return 0;                /* length and case   */      call clean.cue.name(name);    /* match             */   end;   i=shr(max.#.of.cues,1)-1;        /* start in middle       */   j=shr(max.#.of.cues,2);          /* increment will be 1/2 */   do while j <> 0;                 /*                          */      if get.sort.cue(stype,i) = 0  /* if off end of sort stack */      then do;                      /* (or other error??)       */         i=i-j;      end;      else do;                      /* entry exists - look at it */         call read.basic.cue(cue.sec# + cue.sec, cue.wrd, current.cue);         if  (cc.rlen igt cue.name)                /* make sure includes name */         and (cc.name <>  0       )                /* not a deleted cue       */         then do case (type);            do;                              /* 0: look for >= start time */               if COM32(CC.In.S#, Val) >= lw#ieq               then i=i-j;               else i=i+j;            end;            do;                                   /* 1: look for > start time */               if COM32(CC.In.S#, Val) = lw#igt               then i=i-j;               else i=i+j;            end;            do;                                   /* 2: look for cue name =   */               call clean.cue.name(loc(addr(cc.name)));               k=check.name(loc(addr(cc.name)),name);               if  (k=0)                          /* if name is =     */               and (((msb\lsb)=0)                 /* any name desired */               or   ((msb = cc.in.s#.msb)         /* or matches this  */               and   (lsb = cc.in.s#.lsb)))       /* start time       */               then do;                           /* found =          */                  found.cue.num =i;               /* save # in list   */                  found.cue.id# =cc.alloc#;                  return found.cue.id#;           /* return id #      */               end;               if k>0 then i=i-j;               else        i=i+j;            end;            do;                              /* 3: look for >= smpt     */               if COM32(CC.Smpt, Val) >= lw#ieq               then i=i-j;               else i=i+j;            end;            do;                               /* 4: look for > smpt       */               if COM32(CC.Smpt, Val) = lw#igt               then i=i-j;               else i=i+j;            end;            do;                                   /* 5: look for partial cue name =   */               call clean.cue.name(loc(addr(cc.name)));               k=check.name(loc(addr(cc.name)),name);               if k>=0 then do;                   /* if >=,  back up       */                  if (k=0) or (k=3)               /* if exact or partial   */                  then found.cue.id# = cc.alloc#; /* match, then save id   */                  i=i-j;                          /* back up               */               end;               else do;                  i=i+j;               end;            end;         end;      end;      j=shr(j,1);   end;   /* check last binary entry */   if get.sort.cue(stype,i) <> 0  /* if last entry exists         */   then do;                       /* then perform comparison      */      call read.basic.cue(cue.sec# + cue.sec, cue.wrd, current.cue);      if  (cc.rlen igt cue.name)                /* make sure includes name */      and (cc.name <>  0       )                /* not a deleted cue       */      and (cc.rlen <>  0       )                /* valid record length     */      then do case (type);         do;                              /* 0: look for >= start    */            if COM32(CC.In.S#, Val) >= lw#ieq            then do;               if COM32(CC.In.S#, Val) = lw#ieq               then found.cue.id#=cc.alloc#;            end;            else i=i+1;                   /* at end of list          */         end;         do;                                   /* 1: look for > start      */            if COM32(CC.In.S#, Val) = lw#igt            then i=i;            else i=i+1;         end;         do;                                   /* 2: look for cue name =   */            call clean.cue.name(loc(addr(cc.name)));            k=check.name(loc(addr(cc.name)),name);            if  (k=0)                          /* if name is =     */            and (((msb\lsb)=0)                 /* any name desired */            or   ((msb = cc.in.s#.msb)         /* or matches this  */            and   (lsb = cc.in.s#.lsb)))       /* start time       */            then do;                           /* found =          */               found.cue.num =i;     /* save # in list */               found.cue.id# =cc.alloc#;               return found.cue.id#; /* return id #    */            end;            if k<=0 then i=i+1;         end;         do;                              /* 3: look for >= smpt     */            if COM32(CC.Smpt, Val) >= lw#ieq            then do;               if COM32(CC.Smpt, Val) = lw#ieq               then found.cue.id# = cc.alloc#;            end;            else i=i+1;         end;         do;                               /* 4: look for > smpt       */            if COM32(CC.Smpt, Val) = lw#igt            then i=i;            else i=i+1;         end;         do;                                   /* 5: look for partial cue name =   */            call clean.cue.name(loc(addr(cc.name)));            k=check.name(loc(addr(cc.name)),name);            if k<0 then do;                    /* no match at all    */               i=i+1;            end;            else if k=0 then do;               /* perfect match      */               found.cue.id#=cc.alloc#;            end;            else if k=3 then do;               /* partial match      */               found.cue.id#=cc.alloc#;            end;         end;      end;   end;   found.cue.num =i;     /* save insert point */   return found.cue.id#;end perform.binary.search;/* $page - more cue routines */get.alloc.num:proc PUBLIC;              /* look for free alloc #       */   dcl i fixed;   write(mam) = allc.sec#;       /* scan alloc table            */   do i=0 to num.of.alloc-1;     /* see if alloc # is available */      if read(mdi) = -1          /* look for sector # = - 1     */      then return i+1;      write("313") = read(mdi);  /* skip word                   */   end;   if num.of.alloc ige (max.#.of.cues-2)  /* out of room        */   then return 0;   return num.of.alloc+1;end get.alloc.num;/* Routine to see if a cue is in either the current song *//* or the command song                                   */cue.is.in.song.area:proc(arr,data.s#,end.s#) PUBLIC;   dcl arr      array;   dcl data.s#  array;   dcl end.s#   array;   dcl msb (1)  fixed;   call COPY32(loc(addr(arr(Cue.In.S#.Msb))), msb);   call ROUND32(msb);   if  (COM32(msb,end.s# ) >= lw#ieq)   or  (COM32(msb,data.s#) =  lw#ilt)   then return 0;   else return 1;end cue.is.in.song.area;cue.is.in.current.song:proc(arr) PUBLIC;   dcl arr array;   return cue.is.in.song.area(arr,song.data.s#,song.end.s#);end cue.is.in.current.song;cue.is.in.command.song:proc(arr) PUBLIC;   dcl arr array;   return cue.is.in.song.area(arr,c.data.s#,c.end.s#);end cue.is.in.command.song;/* $page: user routine to add cue to list *//* returns:                        *//*   -1:  cue name too long        *//*   -2:  cue already exists       *//*   -3:  too  many cues (4096)    *//*   -4:  out of room in table     *//*   -5:  record too long          *//*   -6:  replace system error     */dcl cue.info.updated fixed PUBLIC; /* set = 1 to rewrite cue info to disk */insert.cue.in.list:proc(base,num,repl) PUBLIC inc.multi.udio.swapable;                                           /* pass cue base          */                                         /* pass alloc num to use  */                                         /* (if replacing)         */   dcl base         fixed;               /* base in ext mem        */   dcl num          fixed;               /* if repl=1 then new cue */   dcl sec#         fixed;               /* is same length as old  */   dcl wrd#         fixed;               /* cue and no garbage     */   dcl i            fixed;               /* collect is needed      */   dcl j            fixed;   dcl insert.point fixed;   dcl repl         fixed;               /* 1 = same length replace */   dcl clen         fixed;   dcl arr  (cue.name + shr(cue.name.l,1)) fixed automatic;   dcl nam# (cue.name.l/2)                 fixed automatic;   clen = read.basic.cue(base,0,arr);    /* get basic info handy    */   /* Take snapshot of in time in case we are loading old cues      */   /* from tape:                                                    */   if (arr(cue.bits) & 16) = 0 then do;  /* if event in time is not */      write(mam) = base;                 /* defined,  then do so.   */      write(mal) = cue.bits;             /* point to bits word.     */      write(md ) = read(md) \ 16;        /* set event defined bit.  */      write(mal) = event.in.s#.msb;      /* write cue s msb to      */      write(mdi) = arr(cue.s.msb);       /* to event.in.s#          */      write(mdi) = arr(cue.s.lsb);   end;   if (arr(cue.name) igt cue.name.l)     /* name   is too long  */   or (arr(cue.name)  =  0         )     /* name   is too short */   then return -1;   if (Clen igt Max.Cue.Record.Len)      /* record is too long */   or (Clen ile cue.name+shr(arr(cue.name)+1,1))   then return -5;   do i=0 to (cue.name.l/2);             /* copy name into temp */      nam#(i) = arr(cue.name+i);         /* for case matching   */   end;   call clean.cue.name(nam#);   i = perform.binary.search(loc(addr(arr(cue.in.s#.msb))), nam#, 2);   /* see if this cue exists */   insert.point = found.cue.num;     /* get alpha insert point            */   if repl=0 then do;                /* not replacing - get alloc #, space */      if (i<>0)                      /* if not replacing and cue already  */      then return -2;                /* exists then duplicate             */      if num=0 then do;         num=get.alloc.num;          /* get next alloc num  */         if num=0 then return -3;    /* out of room         */      end;      /* make sure new cue dir */      /* will fit in memory    */      if cue.numsec+cue.sec#+shr(clen+255,8) ige max.store.secs          then return -4;                                      /* also make sure it     */      /* will fit on disk      */      if cue.numsec+shr(clen+255,8) ige Max.Store.Disk      then return -4;                                      sec#=cue.numsec;                 /* append cue to end of */      wrd#=cue.numwrd;                 /* cue data base        */                  cue.num = cue.num+1;              /* one more cue            */      if num=num.of.alloc+1 then do;    /* increment next alloc #  */         num.of.alloc = num.of.alloc+1; /* if we are appending     */      end;      call write.store(allc.sec#,shl(num-1,1));      call write.word(sec#);          /* store alloc pointer to cue */      call write.word(wrd#);             end;   else do;      if get.cue.ptrs(num)=0      then return (-6);      sec#=cue.sec;                /* rewrite cue in same place */       wrd#=cue.wrd;                /* if replacing              */   end;   write(mam) = base;              /* save alloc # in cue       */   write(mal) = cue.alloc#;   write(md ) = num;   call write.entire.cue(cue.sec# + sec#, wrd#, base); /* store new cue out there */   if repl=0 then do;                              /* if not replacing */      cue.numwrd = cue.numwrd + clen;              /* then cue data    */      cue.numsec = cue.numsec + shr(cue.numwrd,8); /* area is getting  */      cue.numwrd = cue.numwrd & 255;               /* longer           */   end;   /* insert into alphabetic list */   call move.store(alph.sec#,insert.point,                   alph.sec#,insert.point+1,                   0,num.of(alph.sort)-insert.point);   call write.store(alph.sec#,insert.point);   call write.word (num);   num.of(alph.sort) = num.of(alph.sort) + 1;   if cur.ix(alph.sort) igt insert.point           /* keep current index pointing */   then cur.ix(alph.sort) = cur.ix(alph.sort) + 1; /* to same entry               */   /* insert cue into other sort lists: */   /* insert into time list             */   local.insert:proc(type,num);      dcl type fixed;      dcl num  fixed;      call move.store(sort.base(type),found.cue.num,                      sort.base(type),found.cue.num+1,                      0,num.of(type)-found.cue.num);      call write.store(sort.base(type),found.cue.num);      call write.word (num);      num.of(type) = num.of(type) + 1;      if cur.ix(type) igt found.cue.num           /* keep current index pointing */      then cur.ix(type) = cur.ix(type) + 1; /* to same entry               */   end local.insert;   call perform.binary.search(loc(addr(arr(cue.in.s#.msb))), '', 1); /* find place to put in list */   call local.insert(time.sort, num);   call perform.binary.search(loc(addr(arr(cue.smpt.msb))), '',4); /* find place to put in list */   call local.insert(smpt.sort, num);   if cue.is.in.current.song(arr) then do;      call perform.binary.search(loc(addr(arr(cue.in.s#.msb))), nam#, 12);      call local.insert(cs.alph.sort, num);      call perform.binary.search(loc(addr(arr(cue.in.s#.msb))), '', 11); /* find place to put in list */      call local.insert(cs.time.sort, num);      call perform.binary.search(loc(addr(arr(cue.smpt.msb))), '', 14); /* find place to put in list */      call local.insert(cs.smpt.sort, num);   end;   cue.info.updated = 1;   return num;         /* alloc # returned                */end insert.cue.in.list;/* $page - Process all cues *//* process all cues is called to read through the entire cue *//* data base and perform an operation on all the cues        *//* three operations are available : garbage collect            *//*                                : clear track bits/delete    *//*                                  cue after erase track      *//*                                : convert cue records to     *//*                                  new format                 */dcl any.cues.deleted fixed PUBLIC;process.all.cues:proc(type,arg1,arg2) PUBLIC swapable;  /* routine to process all cues and perform an operation on them */   dcl (type     )  fixed;   /* 0:										*/                             /* 1:										*/                             /* 2:										*/   dcl (arg1     )  fixed;   /* usage depends upon type			*/   dcl (arg2     )  fixed;   /* pass track avail bits if ERASE	*/   dcl (i,j,k    )  fixed;   dcl (l,m,n    )  fixed;   dcl (p        )  fixed;   dcl (new.num  )  fixed;   dcl (len#     )  fixed;   dcl (ptr      )  fixed;   dcl (len      )  fixed;   dcl (tbits    )  fixed;   dcl (tmp)   (3)  fixed;	dcl delete.cue proc  (fixed,fixed,fixed) external;   /* types:     0  =  garbage collect cues                    */   /*            1  =  erase arg1 track if cue in command.song */   /*                  arg1 = bits for tracks to erase         */   /*            2  =  convert record to new format            */   i=0; j=0; k=0;   /* source pointers */   l=0; m=0; n=0;   /* dest   pointers */   new.num          = 0;   do while k < cue.num;      len# = read.basic.cue(cue.sec# + i, j, current.cue);      if len# = 0 then k=cue.num;    /* bad data - end of list */      else do;                       /* garbage collect record */         if  (len# igt cue.name)     /* make sure includes name */         and (cc.name <>  0    )     /* not a deleted cue       */         then do case(type);            do;                         /* garbage collect         */               if (i<>l) or (j<>m)      /* copy data over if moved */               then do;                 /* to new location         */                  call move.store(cue.sec# + i, j,                                  cue.sec# + l, m, 0, len#);                  if cc.alloc#<>0 then do;          /* change pointer */                     call write.store(allc.sec#,shl(cc.alloc#-1,1));                     call write.word(l);                                 call write.word(m);                              end;               end;               m = m + len#;               /* advance ptr            */               l = l + shr(m,8);               m = m & 255;               new.num = new.num+1;            end;                        do;                               /* erase track  */               if cue.is.in.command.song(current.cue)  /* this cue is in command song */               then do;                  /* See what tracks are referenced anywhere in this cue: */                  call Or.Cue.Track.Bits(cue.sec#+i, j, tmp);                  /* If cue references the track(s) being erased,  then   */                  /* go through cue and update segments if needed.        */                  if ((tmp(0) & arg1) <> 0)  /* if this track used        */                  or ((tmp(0) & arg2) =  0)  /* or cue uses no avail trks */                  then do;                     /* Change cue to reflect that track is being erased. */                     /* In orther words remove the track from this cue    */                     cue.info.updated = 1;       /* new cue info     */                     if (tmp(0) & (not(arg1)) & arg2) = 0 then do; /* no tracks left in cue */                        call delete.cue(cc.alloc#,0,0); /* but no recursive garbagbe collect! */                        any.cues.deleted=1;      /* remove cue and sort   */                     end;                     else do;                    /* else remove this      */                                                 /* track bit from all    */                                                 /* segments              */                        call read.store(cue.sec#+i,j+cue.trks);                        tbits = read(md);        /* get its tracks        */                        write(md) = tbits & (not(arg1)) & arg2; /* remove tracks being erased and all unavailable tracks from this cues main track list */                        call read.store (cue.sec#+i,j+Cue.List.Ptr);                        ptr = read(mdi);                        len = read(mdi);                        if ptr <> 0 then do;   /* update all equal segment bits */                           do p = ptr to ptr + len - 1  by Cue.Seg.Stride;                              call read.store(cue.sec#+i, j + p + S#DriveBits1);                              write(md) = read(md) & (not(arg1)) & arg2; /* mask off unavailable tracks and track we are erasing */                           end;                        end;                     end;                  end;               end;            end;            /* This following block of code is performed on     */            /* all cues during system initialization.   It      */            /* converts any cues from earlier formats.          */            do;               /* if cc.in.s# area is un-initialized, set it to */               /* be same as in time                            */               if COM32(CC.In.S#, Cue.Data.S#) = lw#ilt               then do;                  call write.store(cue.sec#+i,j+cue.in.s#.msb);                  call write.word (cc.s.msb);                  call write.word (cc.s.lsb);               end;               /* Set the event.in.s# field to match the in     */               /* time for old cues:                            */               if (cc.bits&16) = 0 then do;   /* if not set.    */                  call write.store(cue.sec#+i,j+cue.bits);                  call write.word (cc.bits \ 16);                  call write.store(cue.sec#+i,j+event.in.s#.msb);                  call write.word (cc.s.msb);                  call write.word (cc.s.lsb);               end;            end;         end;         j = j + len#;               /* advance ptr            */         i = i + shr(j,8);         j = j & 255;         k = k + 1;      end;   end;   do case (type);      do;         cue.num    = new.num;         cue.numsec = l;         cue.numwrd = m;         cue.info.updated = 1;      end;      do;      end;      do;      end;   end;end process.all.cues;lookup.cur.cue:proc(id#) PUBLIC;   dcl id# fixed;   if get.cue.ptrs(id#) then do;      call read.basic.cue(cue.sec# + cue.sec, cue.wrd, current.cue);      current.cue(cue.srate) = current.rate - Apply.Drop.Frame.Correction;      return 1;   end;   else do;      cc.rlen=0;      cc.s.msb     = Cue.Data.S#(0);   /* for consistent results,  define */      cc.s.lsb     = Cue.Data.S#(1);   /* a zero length cue that starts   */      cc.e.msb     = Cue.Data.S#(0);   /* at the front of the audio       */      cc.e.lsb     = Cue.Data.S#(1);   /* material if someone tries to    */      cc.in.s#.msb = Cue.Data.S#(0);   /* reference a cue that does not   */      cc.in.s#.lsb = Cue.Data.S#(1);   /* exist                           */      cc.trks  = 0;      return 0;   end;end lookup.cur.cue;/* find.cue.indexes - pass id#, cue name, start time, smpte time *//* routine will find alpha index, time index, smpte index        *//* three pointers are stored in the passed array                 *//* pass type =    alph.sort to compute total disk cur dtd index    *//* pass type = cs.alph.sort to compute current song cur dtd index  *//* returns 1 if cue name was actually in directory                 *//* returns 0 if cue name was not in directory                      */find.cue.indexes:proc(id#,cuearr,type) PUBLIC;   dcl (id#)         fixed;              /* pass id #              */   dcl (cuearr)      array;              /* and array              */   dcl (type)        fixed;   dcl (i)           fixed;   dcl (j)           fixed;   dcl (found)       fixed;   dcl (s)     (1)   fixed;              /* save info in temp arrays */   dcl (t)     (1)   fixed;              /* since current cue info   */   dcl (z)     (1)   fixed;              /* is glommed everywhere    */   if (type=alph.sort)   then j=0;   else j=10;      dcl nam# (cue.name.l/2) fixed automatic;   call COPY32(loc(addr(cuearr(cue.in.s#.msb))), t);   call COPY32(loc(addr(cuearr(cue.smpt.msb ))), s);   do i=0 to (cue.name.l/2);            /* save name              */      nam#(i)=cuearr(cue.name+i);   end;   do i=0 to 2;                         /* initialize current index pointers        */      cur.ix(type+i)=num.of(type+i);    /* to be off the end of the list            */   end;                                 /* in case cue is not found in current song */   local.insert:proc(ourtype);      dcl ourtype fixed;      dcl mintype fixed;      dcl maxtype fixed;      mintype = found.cue.num;          /* save where we started search */      maxtype = num.of(ourtype);        /* look up search limit         */      retry:;      call read.store(sort.base(ourtype),found.cue.num);      do while found.cue.num<maxtype;      /* search forward from here */         if read(mdi) = id# then do;       /* found this id#           */            cur.ix(ourtype)=found.cue.num; /* in sort list             */            return 1;         end;         found.cue.num=found.cue.num+1;      end;      /* does not look good if id# not found */      /* start again from the top            */      /* and hope we find a matching id      */      if mintype<>0 then do;               /* does not look good - id# */         mintype = 0;                      /* is not in sort list      */         found.cue.num = 0;                /* where it should be       */         goto retry;      end;      return 0;                            /* oops - id# not in index */   end local.insert;   found=perform.binary.search(z, nam#, j+5);       /* find first cue with this name (might be several) */   if local.insert(type) = 0 then return 0;   call perform.binary.search(t, '', j);    /* find pointer to cues with this starting time */   if local.insert(type+1) = 0 then return 0;   call perform.binary.search(s, '', j+3);  /* find pointer to cues with this starting smpt bit */   if local.insert(type+2) = 0 then return 0;   return 1;          /* all 3 indexes set up correctly */end find.cue.indexes;/* delete cue is used to delete a cue from the data base *//* it is passed 3 arguments:                             *//*    id#  =  id# of cue to delete                       *//*    gcol =  1 to garbage collect or not                *//*    repl =  1 to delete cue from sort tables only      */delete.cue:proc(id#,gcol,repl) PUBLIC inc.multi.udio.swapable;  /* pass id#,  1 to garbage collect,  1 if about to replace */   dcl id#     fixed;   dcl gcol    fixed;   dcl repl    fixed;   dcl i       fixed;   dcl sec#    fixed;   dcl wrd#    fixed;   dcl len#    fixed;   dcl ixs (5) fixed static;   do i=0 to 5;                  /* save current index pointers in case */      ixs(i)=cur.ix(i);          /* we are loading cues and displaying  */   end;                          /* cues at the same time               */   if get.cue.ptrs(id#) then do; /* make sure id# is valid              */      sec# = cue.sec;      wrd# = cue.wrd;      len# = read.basic.cue(cue.sec# + sec#, wrd#, current.cue);      if len# igt cue.name then do;   /* good record            */         local.remove:proc(type);            dcl type fixed;            if cur.ix(type) ige num.of(type)  /* cue was not in this */            then return;                      /* sort table          */            call move.store(sort.base(type),cur.ix(type)+1,                            sort.base(type),cur.ix(type),                            0,num.of(type)-cur.ix(type)-1);            num.of(type) = num.of(type) - 1;            if ixs(type) igt cur.ix(type) then ixs(type)=ixs(type)-1;         end local.remove;         if find.cue.indexes(id#,current.cue,alph.sort) then do;            call local.remove(alph.sort);            call local.remove(time.sort);            call local.remove(smpt.sort);         end;         call read.basic.cue(cue.sec# + sec#, wrd#, current.cue); /* rearead current cue (glommed by find.cue.indexes above) */         if find.cue.indexes(id#,current.cue,cs.alph.sort) then do;            call local.remove(cs.alph.sort);            call local.remove(cs.time.sort);            call local.remove(cs.smpt.sort);         end;         /* zap cue entry: */         if repl=0 then do;         /* zap if not replacing      */            call write.store(cue.sec# + sec#, wrd# + cue.name);            write(md) = 0;            call write.store(cue.sec# + sec#, wrd# + cue.alloc#);            write(md) = 0;            call write.store(cue.sec# + sec#, wrd# + cue.trks);            rpc 4;            write(md) = 0;            /* zap alloc table pointer: */            call write.store(allc.sec#,shl(id#-1,1));            call write.word(-1);        /* zap alloc ptrs            */            call write.word(-1);            /* garbage collect: */            if gcol<>0 then call process.all.cues(0,0,0);    /* garbage collect to compact data */         end;         cue.info.updated = 1;         do i=0 to 5;                  /* restore current index pointers */            cur.ix(i)=ixs(i);                   end;                                   return 1;      end;   end;      return 0;end delete.cue;/* $page - convert record routines *//* These routines convert records back and forth between *//* absolute disk samples,  and samples with respect to   *//* the start of the data area                            *//* Within the direct to disk system,  all cue times      *//* are stored as absolute sample #'s with respect to     *//* the start of the disk.   The Audio Event Editor       *//* needs the information in a different format to        *//* simplify its job                                      *//* the following routines map back and forth between     *//* the two formats.                                      *//* To Further complicate matters,  some parts of the AEE *//* need the times in samples,  while others need it      *//* as sequencer times.                                   *//* The basic rules are:                                  *//*    Old Software - pass basic cue, in milliseconds     *//*    New Software - if requesting basic cue, return     *//*                   info in milliseconds.   if          *//*                   requesting entire cue,  return      *//*                   all information in samples          *//* $page - convert record to AEE format *//* convert record to format for AEE software *//* Note - short records are always returned with times in *//* milliseconds.    Entire records are always returned    *//* with times in samples                                  *//* Note - must return cue times as 32-bit msecs with      *//* respect to current project                             */convert.basic.record.to.msecs:proc(arr) PUBLIC inc.multi.udio.swapable;  /* convert sample ptrs to msecs */   dcl arr    array;   dcl tmp(1) fixed;   Compute.Relative.S#: proc(arr);      dcl arr array;      call compute.syncl.time(arr, 0, Syncl.Time);      call round.syncl.time(Syncl.Time);      call COPY32(Syncl.Time, arr);   end Compute.Relative.S#;   /* compute cue length in milliseconds */   /* all the time to facilitate chain   */   call SUB32(loc(addr(arr(cue.e.msb))),loc(addr(arr(cue.s.msb))),tmp);   call ADD32(tmp,Song.Data.S#,tmp);   call compute.syncl.time(tmp,0,Syncl.Time);   call round.syncl.time(Syncl.Time);   call COPY32(Syncl.Time,loc(addr(arr(cue.len.msb))));   call SUB16 (zero.time, loc(addr(arr(cue.len.msb))));   call Compute.Relative.S#(loc(addr(arr(cue.s.msb      ))));   call Compute.Relative.S#(loc(addr(arr(cue.e.msb      ))));   call Compute.Relative.S#(loc(addr(arr(cue.edit.in.msb))));   call Compute.Relative.S#(loc(addr(arr(cue.edit.out.msb))));   call Compute.Relative.S#(loc(addr(arr(cue.off.msb     ))));   /* pass sample # of in time for use by some routines */   call SUB32(loc(addr(arr(cue.in.S#.msb))), Cue.Data.S#, loc(addr(arr(cue.in.S#.msb))));   /* pass sample # of event.in.s#.msb as well          */   call SUB32(loc(addr(arr(event.in.S#.msb))), Cue.Data.S#, loc(addr(arr(event.in.S#.msb))));end convert.basic.record.to.msecs;/* Entire records are always returned with all *//* information in samples                      */convert.entire.record.to.msecs:proc(base) PUBLIC inc.multi.udio.swapable;    /* convert to absolute sample #'s */   dcl base   fixed;   dcl ptr    fixed;   dcl len    fixed;   dcl i      fixed;   consub:proc(base,ptr);      dcl base fixed;      dcl ptr  fixed;      dcl tmp(1) fixed;      call READ32(base,ptr,tmp);      /* compute sample # with respect to start of disk */      if (tmp(0) <> (-1))     /* if not infinity        */      then do;         if COM32(tmp,Cue.Data.S#) = lw#ilt  /* else convert relative  */         then call STR32(0,0,tmp);           /* to Cue.Data.S#             */         else call SUB32(tmp, Cue.Data.S#, tmp);      end;      call WRITE32(base,ptr,tmp);   end consub;   call Consub(base, cue.s.msb       );   call Consub(base, cue.e.msb       );   call Consub(base, cue.edit.in.msb );   call Consub(base, cue.edit.out.msb);   call Consub(base, cue.off.msb     );   call Consub(base, cue.in.s#.msb   );   call Consub(base, event.in.s#.msb );   write(mam) = base;   write(mal) = Cue.List.Ptr;   ptr = read(mdi);   len = read(mdi);   if ptr <> 0 then do;      do i = ptr to ptr + len - 1  by Cue.Seg.Stride;         call Consub(base, i + S#Sync.Msb);         call Consub(base, i + S#In.Msb  );         call Consub(base, i + S#Out.Msb );      end;   end;   /* return sample rate for stm transfer */   write(mam) = base;   write(mal) = cue.srate;   write(md ) = current.rate - Apply.Drop.Frame.Correction;end convert.entire.record.to.msecs;/* $page - convert record to samples *//* Note: records coming into the AEE are only long *//* records                                         */Compute.Absolute.S#:proc(arr) PUBLIC;   dcl arr array;   if Synclav.software.version < 4 then do;      call compute.mark.start.point(arr,0,1,arr);   end;   else do;            /* compute sample # with respect to start of disk */      if arr(0) <> (-1)                     /* leave -1, -1 at end of disk */      then call ADD32(arr,Cue.Data.S#,arr); /* else convert it             */   end;end Compute.Absolute.S#;convert.entire.record.to.samples:proc(base) PUBLIC inc.multi.udio.swapable;    /* convert to absolute sample #'s */   dcl base   fixed;   dcl ptr    fixed;   dcl len    fixed;   dcl i      fixed;   consub:proc(base,ptr);      dcl base fixed;      dcl ptr  fixed;      dcl tmp(1) fixed;      call READ32(base,ptr,tmp);      call Compute.Absolute.S#(tmp);      call WRITE32(base,ptr,tmp);   end consub;   call Consub(base, cue.s.msb       );   call Consub(base, cue.e.msb       );   call Consub(base, cue.edit.in.msb );   call Consub(base, cue.edit.out.msb);   call Consub(base, cue.off.msb     );   call Consub(base, cue.in.s#.msb   );   call Consub(base, event.in.s#.msb );   write(mam) = base;   write(mal) = Cue.List.Ptr;   ptr = read(mdi);   len = read(mdi);   if ptr <> 0 then do;      do i = ptr to ptr + len - 1  by Cue.Seg.Stride;         call Consub(base, i + S#Sync.Msb);         call Consub(base, i + S#In.Msb  );         call Consub(base, i + S#Out.Msb );      end;   end;end convert.entire.record.to.samples;end cuemod;