/* MAINSOU  $TITLE   Main loop module for DTD   Modified:   06/26/91 - cj  - added punch.out.pending to sync voice switch on output   03/07/91 - CJ  - scrubbing improvements for DDSAD   11/05/90 - CJ  - Improved accuracy of "play to"   02/12/90 - CJ  - inserted 'loddebug' here instead of in main loop   01/25/90 - MWH - Fix "300 msec delay starting cues" bug (from EditView)   06/20/89 - cj - added new variables to initiate scrubbing of                   placed cues.*/module mainmod;insert ':-xpl:scsilits';insert ':lod:lodlits:globlits'; /* get main literals                */insert ':lod:lodlits:dbuglits'; /* get dbug literals                */insert ':lod:lodlits:varlits';  /* variable msbs/lsbs               */insert ':lod:lodlits:polylits'; /* literals for poly synth          */insert ':lod:lodlits:xmemlits'; /* literals for xmem allocation     */insert ':lod:lodlits:cuelits';  /* literals for cue storage         */insert ':lod:lodlits:ddtlits';  /* literals for DDT hardware        */insert ':lod:lodlits:dsplits';  /* literals for DSP items           */insert ':lod:lodlits:initlits'; /* literals for init/SCSI           */insert ':lod:lodlits:stacklit'; /* literals for cue stacking        */insert ':lod:lodlits:talklits'; /* literals for communications      */insert ':lod:lodlits:jazlits';  /* literals for JAZ backup drive    */insert ':lod:lodmods:miscdcl';  /* get misc routines                */insert ':lod:lodmods:dbugdcl';  /* debug routines                   */insert ':lod:lodmods:dspdcl';   /* dsp/tsm/wave calc routines       */insert ':lod:lodmods:polydcl';  /* poly synth routines              */insert ':lod:lodmods:mididcl';  /* midi routines                    */insert ':lod:lodmods:cuedcl';   /* basic cue routines               */insert ':lod:lodmods:ddtdcl';   /* basic ddt routines               */insert ':lod:lodmods:initdcl';  /* initialization routine           */insert ':lod:lodmods:stackdcl'; /* real time cue stack              */insert ':lod:lodmods:talkdcl';  /* comunications with syntabulator  *//* Variables to assist in recovering patriot tapes with verify      *//* information on it:                                               */dcl (recover.code ) fixed;dcl (recover.count) fixed;dcl (recover.msb  ) fixed;dcl (recover.lsb  ) fixed;/* Variables that provide a local copy of the synclavier time base  */dcl (new.speed     )       fixed PUBLIC;dcl (new.speed.time)       fixed PUBLIC;dcl (prior.speed   )       fixed PUBLIC;dcl (play,recd,move,pnch)  fixed PUBLIC;  /* synclav motion controls */dcl (Play.Time)      (2)   fixed;        /* Synclaver Play Time.  Updated      */dcl (trig)                 fixed PUBLIC; /* set trig = 1 to start playback  */dcl (trig.new.info)        fixed;     /* set when new trig info ready       */dcl (trig.record) (stack.record.size-1) fixed;  /* holds the trigger info   */dcl (trig.rate)            fixed;     /* sync audio playback.  trig time    */dcl (trig.time)            fixed;     /* used to provide startup delay      */dcl (trig.start  )         fixed;     /* timer for sync timing              */dcl (trig.delay  )         fixed;     /* msecs for cue delay                */dcl (trig.chunk  )         fixed;     /* disk read block size               */dcl (func)                 fixed PUBLIC;     /* true if data function reading      */dcl (monitor)              fixed;     /* true if monitor desired            */dcl (first.play)           fixed;dcl (first.loop)           fixed;dcl (first.trig)           fixed;dcl (first.func)           fixed;dcl (play.tracks)          fixed;dcl (trig.tracks)          fixed;dcl (recd.tracks)          fixed;dcl (punch.out.pending)    fixed;dcl (Lod.Recd.Tracks)      fixed;dcl (Lod.Punch.In.Tracks)  fixed;dcl (precd.tracks)         fixed;     dcl (ready.tracks)         fixed;dcl (pready.tracks)        fixed;dcl (recorded.tracks)      fixed;dcl (precd)                fixed;dcl (pplay)                fixed;dcl (ptrig)                fixed;dcl (ploop)                fixed;dcl (pfunc)                fixed;dcl (mark.button.state)    fixed;dcl (Mark.Button)     (2)  fixed;            /* Holds dialed in Synclav */dcl (Mark.Button.S#)     (1) fixed;               /* holds our sample # */dcl (Delay.Cue.Starts)     fixed;  /* Turns on pre-roll (without audio) */dcl (Delay.Cue.Time)  (1)  fixed;dcl (Delay.Cue.S#)    (1)  fixed;dcl (Play.Seq.To.A.Time)   fixed;  /* variables for accurate play to    */dcl (Play.Seq.To.Time)(1)  fixed;  /* function                          */dcl (Play.Seq.To.S# ) (1)  fixed;dcl (Sync.Time)       (1)  fixed;  /* Used to old d16 time of sync point */dcl (New.Sync.Info)        fixed;         /* set when sync message received from synclavier */dcl (Sync.Mode)            fixed;         /* 0: use no sync (debug only)  */                                          /* 1: use Synclav D3 or Poly    */                                          /*    bin 50 Mhz clock          */                                          /* 2: use DDT Word Clock        */                                          /*    for synchronization       */dcl (d16tim)               fixed;         /* d16 ticks per msec           */dcl (dig.xfer.mode)        fixed public;  /* 0/1: off                     */                                          /* 2:   DDT Input               */                                          /* 4:   DDT Output              */                                          /* 8:   Bounce                  *//* Common routines to assist with DDT sync timing */dcl (dig.xfer.go.master)   fixed;   /* port# of GO master           */dcl (dig.xfer.clock.port)  fixed;   /* port# for syncing            */dcl (dig.xfer.clock.value) fixed;   /* current clock value          */dcl (dig.xfer.clock.time)  fixed;   /* time of measurement          */dcl (dig.xfer.clock.pvalue)fixed;   /* last value measurement       */dcl (dig.xfer.clock.ptime) fixed;   /* last time of measurement     */dcl (dig.xfer.clock.rate)  fixed;   /* measure rate coming in       *//* Routine returns estimated word clock value based upon last reading      *//* and estimated rate:                                                     *//* Uses global variable Our.Time.Lsb so the time precisely matches the     *//* time at which the D16 was read:                                         */Get.DDT.Clock.Estimate: proc;   dcl i fixed;   i = d16tim * 500;                 /* get d16 ticks in .5 sec   */   load dig.xfer.clock.rate;         /* get samples in .5 sec     */   mul  our.time.lsb - dig.xfer.clock.time; /* get real time      */   mwait; div i;   if rem IGE shr(i,1)    then return dig.xfer.clock.value + res + 1;   else return dig.xfer.clock.value + res    ;end Get.DDT.Clock.Estimate;dcl (pwlen)                fixed PUBLIC;  /* punch in cross fade, words   */dcl (pmsec)                fixed;         /* interpolator info to match in real-time what the resulting cross fade will do */dcl (ddt.monitor.delay)    fixed;         /* # of samples in 75 msecs     */                                          /* while recording              *//* $page - loop (point) playback *//* a facility for loop/point playback is now available.   loop playback *//* refers to constructing a short audio loop (either before or after    *//* the specified point) and playing it.   point playback refers to      *//* playing back just a single point and chasing towards it as it        *//* changes                                                              *//* the following variables control the loop/point playback:             */dcl (loop)                 fixed PUBLIC;  /* 1 = loop playback (vs play or trig)  */dcl (loop.mode)     lit    '0'  ;  /* 0 = point      1 = loop              */dcl (loop.resp)            fixed;  /* time const to use for point playback */dcl (loop.post)            fixed;  /* 0 = pre        1 = post  (loop only) */dcl (cur.loop.buf)         fixed;  /* 1 = loop.buf1  3 = loop.buf3 in use  */dcl (new.loop.pos)         fixed;  /* set = 1 when new position recvd      */dcl (compute.new.scrub.limit) fixed;  /* set to compute new rate limit     */dcl (new.pos.computed)     fixed;  /* set = 1 when new position computed   */dcl (prior.rate.time) (1)  fixed;  /* used for 2nd order rate filter       */dcl s#.to.start.looping.at      (1)   fixed;   /* s# to start at           */dcl newly.requested.loop.s#     (1)   fixed;   /* move to here             */dcl prior.requested.loop.s#     (1)   fixed;   /* needed to for mouse rate */dcl hold.loop.for.stacking            fixed;          /* wait for stacking before starting point playback */dcl dtd.is.ready.for.stacking         fixed PUBLIC;   /* true when ready for events                       */dcl time.of.new.loop.request          fixed;dcl time.of.prior.loop.request        fixed;dcl loop.buf.len                      fixed;dcl (loop.mouse.rate)      fixed;dcl (examount)             fixed;              /* holds amount of ext memory *//* motion subroutines */Clear.Motion.Controls:proc;        /* zap any motion           */   play = 0; trig = 0; recd = 0;   /* for example, needed      */   pnch = 0; move = 0; loop = 0;   /* on program exit          */   func = 0; monitor = 0;          /* no data reads, monitor   */   New.Sync.Info = 0;              /* or someone pressed load  */   new.armd.tracks = 0;            /* no changes               */end Clear.Motion.Controls;clear.armed.info:proc;             /* convenient procedure to disarm */   dcl i fixed;   if armed<>0 then do;      if Synclav.software.version >= 3           /* tell synclav to change highlight */      then get.new.motion = get.new.motion \ 2;  /* on aee record panel              */      do i=0 to max.tracks-1;         if (armd.tracks&bits(i))<>0 then zap.buffer(i)=1;      end;   end;   armed           = 0;   armd.tracks     = 0;   new.armd.tracks = 0;end clear.armed.info;/* procedure to set handy variables when track directory is updated *//* on change of repro/input/auto/cue pb                             *//* provides real time switching (approximately) of audio            */dcl handle.real.time.ria.change proc(fixed);handle.ria.change:proc (track#) PUBLIC swapable;     /* handle real time rep-inp-aut change */   dcl (track#) fixed;   dcl (j,k)    fixed;   track.dir.updated = 1;       /* set flags to re-write track */   send.screen.info  = 1;       /* directory                   */   /* if idle, monitoring, or doing play output,  reset cue stack */   /* to provide appropriate switch in the near future:           */   if  ((output.happening  =  0)      /* if no output happening   */   or   (now.monitoring    <> 0)      /* or monitoring            */   or   (now.playing       <> 0))     /* or playing               */   and ((armed            =  0)       /* and not armed recording  */   or   (((armd.tracks&bits(track#))=0)))   and (track.recording(track#) = 0)  /* and not recording        */   then do;      j = track# * track.len;                  /* get track dir pointer */      k = shr(track.dir(j+track.stat),8);      /* look up t.ria         */      if k=3 then do;                          /* new mode is cue pb    */         if source.or.cue(track#)=0 then do;   /* if had been repro     */            call clear.playback.cue.stack(track#);             if now.playing <> 0                /* if playing, switch    */            then call handle.real.time.ria.change(track#);            else zap.buffer(track#)=1;         /* else start over       */         end;         source.or.cue(track#)=1;      end;      else do;                                 /* repro/inp/aut         */         if source.or.cue(track#)<>0 then do;            call clear.playback.cue.stack(track#);             if now.playing <> 0                /* if playing, switch    */            then call handle.real.time.ria.change(track#);            else zap.buffer(track#)=1;         end;         source.or.cue(track#)=0;      end;   end;end handle.ria.change;/* $page - assemble insert file list */dcl compute.track.status.display procedure (fixed);dcl track.levels(num.tracks-1) fixed;insert ':LOD:LOD1-11';insert ':LOD:LOD1-12';insert ':LOD:LOD1-13';insert ':LOD:LOD1-14';insert ':LOD:LOD1-15';insert ':LOD:LOD1-16';insert ':LOD:LOD1-17';insert ':LOD:LOD1-18';insert ':LOD:LOD1-19';insert ':LOD:LOD1-21';insert ':LOD:LOD1-22';insert ':LOD:LOD1-23';insert ':LOD:LOD1-24';insert ':LOD:LOD1-25';insert ':LOD:LOD1-26';insert ':LOD:LOD1-27';insert ':LOD:LOD1-28';insert ':LOD:LOD1-29';insert ':LOD:LODDEBUG';MAINLOOP: proc (version, allow.max.trax) PUBLIC;   dcl version         array;   dcl allow.max.trax  fixed;   insert ':LOD:LOD-MAIN';      /* init and main loop */end MAINLOOP;end mainmod;