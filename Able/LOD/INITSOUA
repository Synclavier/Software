/* INITSOUA - Basic Buffer Memory/Scsi IO Routines *//* 08/14/91 - cj - Added DataEnd.S# for bug fix    *//* 03/26/90 - cj - Code for new tape format        *//* The following variables are set up by the initilization routine *//* to reflect how the hardware is configured.                      *//* Useful information: */dcl Subsystem.Ready    fixed PUBLIC;  /* true if lod subsystem is ready */dcl Initialize         fixed PUBLIC;  /* nonzero when initializing      */dcl Song.Dir.Track     fixed PUBLIC;  /* track we actually read song dir from  */dcl Error.Msb          fixed PUBLIC;  /* detect re-activation of bad drive     */dcl Error.Lsb          fixed PUBLIC;dcl Base.Voice#        fixed PUBLIC;  /* voice # to user for output 0   */dcl Zero.Sec#          fixed PUBLIC;  /* Sector   of disk where zeroes are */dcl Zero.S#      (1)   fixed PUBLIC;  /* Sample # of disk where zeroes are */dcl Zero.Len.S#        data  PUBLIC (Zero.Len.S#.Msb, Zero.Len.S#.Lsb);dcl Data.Sec#          fixed PUBLIC;  /* Sector   of disk where data is  */dcl Data.S#       (1)  fixed PUBLIC;  /* Sample # of disk where data is  */dcl DataEnd.S#    (1)  fixed PUBLIC;  /* Sample # of disk end            */dcl Swap.Info.Loaded   fixed PUBLIC;  /* true when swap info is loaded                       */dcl Swap.Info.Sec#     fixed PUBLIC;  /* counter for snarfing swap code from obj file        */dcl Swap.Info.Skip     fixed PUBLIC;  /* counter for tossing object code from obj file       */dcl dtd.max.secs       fixed PUBLIC;dcl dtd.max.tracks     fixed PUBLIC;dcl dtd.max.inputs     fixed PUBLIC;/* Variables for each port:    */dcl num.available.ports fixed PUBLIC;   /* holds # of ports available   *//* note: some of the following tables hold information for the          *//* dedicated D24 as info(max.port)                                      */dcl port.exists     (max.ports) fixed PUBLIC; /* true if port exists      */dcl port.available  (max.ports) fixed PUBLIC; /* true if port avaialable  */dcl port.track.bits (max.ports) fixed PUBLIC; /* bits for tracks here     */dcl port.base.track (max.ports) fixed PUBLIC; /* base track on this port  */dcl port.d24.#      (max.ports) fixed PUBLIC; /* which d24                */dcl port.io         (max.ports) fixed PUBLIC; /* io operation occurring   */dcl port.lun1       (max.ports) fixed PUBLIC; /* 1 if lun1 has been set   */dcl port.timer      (max.ports) fixed PUBLIC; /* timeout timer for drives */dcl port.status     (max.ports) fixed PUBLIC; /* status of last i/o       */dcl port.retry      (max.ports) fixed PUBLIC; /* holds retry count        */dcl port.last.io    (max.ports) fixed PUBLIC; /* during request sense     */dcl port.space.info (max.ports) fixed PUBLIC; /* used for space command   */dcl port.io.track#  (max.ports) fixed PUBLIC; /* track # for this command */dcl port.io.dtrack# (max.ports) fixed PUBLIC; /* disk track# for command  */dcl port.count      (max.ports) fixed PUBLIC; /* used during startup      */dcl port.tptr		  (max.ports) fixed PUBLIC; /* tptr in use...			  *//* Variables for each track: */dcl num.available.tracks fixed PUBLIC;dcl track.avail.bits     fixed PUBLIC; /* bits for avail tracks - set up during initialization */dcl track.info.bits      fixed PUBLIC; /* bits for tracks we should write directories too */dcl track.exists     (max.tracks-1)  fixed PUBLIC; /* true if track exists     */dcl track.available  (max.tracks-1)  fixed PUBLIC; /* true if track avail      */dcl track.port.ix    (max.tracks-1)  fixed PUBLIC; /* holds which port# has disks  */dcl track.track.bits (max.tracks-1)  fixed PUBLIC; /* bits for tracks on same port */dcl track.base.adr   (max.tracks-1)  fixed PUBLIC; /* holds base address of track  */dcl track.command    (max.tracks-1)  fixed PUBLIC; /* last command (on error)  */dcl track.status     (max.tracks-1)  fixed PUBLIC; /* error status if one      */dcl track.numsec.msb (max.tracks-1)  fixed PUBLIC; /* sectors (max) on track   */dcl track.numsec.lsb (max.tracks-1)  fixed PUBLIC;dcl track.data.msb   (max.tracks-1)  fixed PUBLIC; /* sector # of data area    */dcl track.data.lsb   (max.tracks-1)  fixed PUBLIC;dcl track.adir.sec   (max.tracks-1)  fixed PUBLIC; /* sector for adir          */dcl track.retry      (max.tracks-1)  fixed PUBLIC; /* retry count              */dcl track.starts     (max.tracks-1)  fixed PUBLIC; /* start drive retry count  *//* Info for multi-track DDT input: */dcl track.ddt.zeroed (max.tracks-1)  fixed PUBLIC;dcl track.ddt.ptr    (max.tracks-1)  fixed PUBLIC;dcl track.ddt.ctr    (max.tracks-1)  fixed PUBLIC;dcl track.ddt.msb    (max.tracks-1)  fixed PUBLIC;dcl track.ddt.lsb    (max.tracks-1)  fixed PUBLIC;/* Important info - holds the drive list for *//* each track (target #, size, etc)          */dcl tptr  fixed PUBLIC;          /* use tptr to point to current entry  */dcl track.info (max.tracks*max.entries.per.track*track.info.stride               +track.info.stride    /* info for optical disk on d24 #0 */               +track.info.stride    /* info for tape1        on d24 #1 */               +track.info.stride    /* info for tape2        on d24 #1 */               -1) fixed PUBLIC;/* for Wren IV rezeroing: */dcl rezero.timer                  fixed PUBLIC;dcl last.user.time                fixed PUBLIC;dcl rezero.happening              fixed PUBLIC;dcl rezero.time                   fixed PUBLIC;/* For Erase All function: */dcl erase1                        fixed PUBLIC;  /* keys for the erase all */dcl erase2                        fixed PUBLIC;  /* function               */dcl eraselong                     fixed PUBLIC;  /* true for long erase    *//* for Mount/Dismount functions */dcl mount.drives                  fixed PUBLIC;dcl dismount.drives               fixed PUBLIC;dcl format.drives						 fixed PUBLIC;/* For data function reading: */dcl read.track.info                   fixed PUBLIC;  /* holds bits for tracks where info is desired */dcl read.track.msb     (max.tracks-1) fixed PUBLIC;  /* holds SAMPLE # disk address for reading     */dcl read.track.lsb     (max.tracks-1) fixed PUBLIC;  /* holds SECTOR # disk address for writing     */dcl read.track.buf.len (max.tracks-1) fixed PUBLIC;  /* buffer size to fill on READ                 */dcl read.track.len     (max.tracks-1) fixed PUBLIC;  /* # of sectors to WRITE                       */dcl read.track.buf.base(max.tracks-1) fixed PUBLIC;  /* offset in buffer of data to WRITE           */dcl read.track.written (max.tracks-1) fixed PUBLIC;  /* # of sectors written                        */dcl read.track.chunk   (max.tracks-1) fixed PUBLIC;  /* chunk size for actual disk ops              */dcl read.track.time                   fixed PUBLIC;dcl timeout.point                     fixed PUBLIC;dcl track.info.direction              fixed PUBLIC;dcl track.info.busy                   fixed PUBLIC;dcl clean.up.all.of.poly              fixed PUBLIC;dcl dsp.opt.data.stacked              fixed PUBLIC;/* $page - Useful subroutines for managing port io activity  *//* see if any port is doing io at the moment                 */any.port.doing.io: proc PUBLIC;   dcl i fixed;   do i=0 to max.ports;      if   (port.available(i)<>0)      and  (port.io       (i)>1)       then return 1;   end;   return 0;   end any.port.doing.io;/* $page - scsi routines for proprietary targets *//* general guidelines:   Early during initialization,  we make sure the buffer memory   cards are there,  and that the proprietary targets are working.   Once we have initialized them,  the following 2 rules   are observed:       1)  the d24 card is normally kept disconnected from any           of the scsi ports (i.e. lun0.penable=0).   This           will assure us of a bus free condition (baring           hardware problems on the memory controller or           buffer memory cards).       2)  the only variance to this situation ocurs after a           real reset is given to a port.   Since we have           lun0.renable set in this case,  there is no           way to disconnect from a port until the bus           is free.   we must depend on the real reset           pulse to tell whoever is out there           to reset. *//* select a certain d24: *//* $page - select port or start reset:                         *//* important routine:  generally the first one called whenever *//* we wish to access a disk.                                   */dcl selected.port fixed PUBLIC;      /* for error messages           *//* quick version - no error checking - mostly for DDT                *//* sometimes called with interrupts off (keep them off)              */quickly.select.port: proc(port#) PUBLIC;   dcl (port#) fixed;   call select.d24(port.d24.#(port#));    /* select correct d24    */   do while ((read(ScsiBus )&S$BusMask )<>0)   or       ((read(ScsiData)&S$DataMask)<>0);   end;   call targ0.connect(0);                /* connect to target 0 */   write(ScsiByte)=port# \ lun0.penable; /* quickly select port */   selected.port  =port# \ 256;          /* record that fact    */end quickly.select.port;select.port.or.start.reset:proc(port#,enable.bits) PUBLIC;   dcl (port#      ) fixed;   dcl (enable.bits) fixed;   dcl (i          ) fixed;   dcl (j,k        ) fixed;   if port# >= max.ports                         /* no selection needed */   then return 0;                                /* if dedicated D24    */   /* wait for free:  */                         /* give errant modules */                                                 /* 500 msec to get off */   i=real.milliseconds;                          /* the bus after a     */   if subsystem.ready<>0 then i=i+100;   else                       i=i+500;   j=read(ScsiData);   k=read(ScsiBus );   do while (((read(ScsiBus )&S$BusMask )<>0)    /* reset               */   or        ((read(ScsiData)&S$DataMask)<>0))   and      (real.milliseconds < i           );        if (read(ScsiBus)&S$Req)<>0        /* toss unused message byte from */      then do;                           /* early disk drives.  do not    */         write(ScsiBus)=S$Ack;           /* read scsibyte since it        */         write(ScsiBus)=0;               /* may hang                      */      end;   end;   if  ((read(ScsiBus )&S$BusMask )<>0)          /* make sure idle    */   or  ((read(ScsiData)&S$DataMask)<>0)   then do;      /* pulse reset:                               */      /* here we may be giving a second reset pulse */      /* to a selected scsi port if it still has    */      /* not gotten off the bus,  or we are giving  */      /* a reset pulse to the internal scsi bus     */      /* only                                       */      if xdebug<>0 then do;         print 'Starting Reset: Port ',port#,'  (',selected.port&255,' )';         print 'ScsiData      : ',octal(j);         print 'ScsiBus       : ',octal(k);      end;      write(ScsiBus ) = S$RST;    /* pulse reset out to disks   */      i=real.milliseconds;        /* for approx 5 msec          */      do while real.milliseconds<i+10;  end;      write(ScsiBus) = 0;      if log.buf(0)=0 then do;         call log.error('Resetting (SP) Direct-to-Disk Port #');         if selected.port<>0         then call append.decimal.number(selected.port&255);         else call append.decimal.number(port#            );         call append.log.string(' (');         call append.decimal.number(j);         call append.log.string(' ');         call append.decimal.number(k);         call append.log.string(')');      end;      port.io   (port#) = 1;     /* 1 = reset               */      port.timer(port#) = real.seconds+reset.time;               return S$ArbFailed;   end;         call targ0.connect(0);   write(ScsiByte)=port# \ enable.bits;   selected.port  =port# \ 256;   return 0;end select.port.or.start.reset;deselect:proc(port#) PUBLIC;   /* deselect current port      */   dcl port# fixed;   if port# >= max.ports       /* no deselection needed if   */   then return;                /* dedicated d24              */   write(ScsiBus ) = S$RST;    /* disable connection to port */   write(ScsiData) = 0;        /* by pulsing reset           */   write(ScsiBus ) = 0;   selected.port   = 0;end deselect;issue.reset:proc (port#) PUBLIC;   dcl (port#) fixed;   dcl (i,j,k) fixed;   if select.port.or.start.reset(port#,lun0.penable\lun0.renable)=0   then do;                              /* connect to port with reset  */                                         /* enabled                     */      /* pulse reset:      */      j=read(ScsiData);      k=read(ScsiBus );      if xdebug<>0 then do;         print 'Starting Reset: Port ',port#,'  (',selected.port&255,' )';         print 'ScsiData      : ',octal(j);         print 'ScsiBus       : ',octal(k);      end;      write(ScsiBus ) = S$RST;    /* pulse reset out to disks   */      i=real.milliseconds;        /* for approx 5 msec          */      do while real.milliseconds<i+10;  end;      write(ScsiBus) = 0;      if log.buf(0)=0 then do;         call log.error('Resetting (IR) Direct-to-Disk Port #');         call append.decimal.number(port#);         call append.log.string(' (');         call append.decimal.number(j);         call append.log.string(' ');         call append.decimal.number(k);         call append.log.string(')');      end;      port.io   (port#) = 1;     /* 1 = reset               */      port.timer(port#) = real.seconds+reset.time;   end;end issue.reset;/* $page - wait.for.busfree.or.start.reset *//* this routine is called ONLY after we have successfully connected *//* to an external buffere memory port above.                        *//* it is called to make sure the external bus is free.   it will    *//* issue an actual reset to the external scsi bus if not            */wait.for.busfree.or.start.reset:proc(port#) PUBLIC;   dcl (port#)   fixed;   dcl (i    )   fixed;   dcl (j,k  )   fixed;   /* wait for free:    */   i=real.milliseconds;   if subsystem.ready<>0 then i=i+2000;   else                       i=i+5000;   j=read(ScsiData);   k=read(ScsiBus );   do while (((read(ScsiBus )&S$BusMask )<>0)   or        ((read(ScsiData)&S$DataMask)<>0))   and      (real.milliseconds < i           );      if (read(ScsiBus)&S$Req)<>0        /* toss unused message byte from */      then do;                           /* early disk drives.  do not    */         write(ScsiBus)=S$Ack;           /* read scsibyte since it        */         write(ScsiBus)=0;               /* may hang                      */      end;   end;   if  ((read(ScsiBus )&S$BusMask )<>0)     /* if busy, must do real reset */   or  ((read(ScsiData)&S$DataMask)<>0)   then do;      call deselect(port#);                 /* unconnect to get free bus   */      call issue.reset(port#);                  return S$ArbFailed;   end;         return 0;end wait.for.busfree.or.start.reset;/* $page - more scsi routines:   wait.for.req *//* common check used by many routines: */wait.for.req:proc;   dcl i  fixed;   i=real.milliseconds;   if subsystem.ready<>0 then i=i+2000;   else                       i=i+5000;   do while ((read(ScsiBus)&S$REQ) = 0)      and   (real.milliseconds     < i);   end;   if ((read(ScsiBus)&S$REQ)=0)   then do;      return S$Timeout;           /* time out              */   end;   return 0;end wait.for.req;/* $page - scsi connect routine *//* this connect routine is only called after:      1.  the bus was free and we are able to connect to          an external scsi portand   2.  the external bus was also free.   Now connect to the actual scsi target: */connect:proc(target#);   dcl (target#) fixed;   dcl (i)       fixed;   /* select target: */   write(ScsiData) =bits(target#); /* single initiator   */   write(ScsiBus ) =S$SEL;         /* gnd SEL            */   i=real.milliseconds+300;   do while ((read(ScsiBus)&S$BSY)=0)      and   (real.milliseconds    <i);        end;   write(ScsiBus )=0;   write(ScsiData)=0;   if ((read(ScsiBus)&S$BSY)=0)   then return S$SelFailed;   return 0;end connect;optical_connect:proc(target#);   dcl (target#) fixed;   dcl (i)       fixed;   /* select target: */   write(ScsiData) =bits(target#) | bits(3);   write(ScsiBus ) =S$SEL;   i=real.milliseconds+300;   do while ((read(ScsiBus)&S$BSY)=0)      and   (real.milliseconds    <i);        end;   write(ScsiBus )=0;   write(ScsiData)=0;   if ((read(ScsiBus)&S$BSY)=0)   then return S$SelFailed;   return 0;end optical_connect;/* $page - send message to device */Send.Message:proc(target#,message) swapable;   dcl (target#) fixed;   dcl (message) fixed;   dcl (i)       fixed;   /* select target: */   write(ScsiData) =bits(target#); /* single initiator   */   write(ScsiBus ) =S$ATN;         /* asser atn          */   write(ScsiBus ) =S$ATN\S$SEL;   /* gnd SEL            */   i=real.milliseconds+300;   do while ((read(ScsiBus)&S$BSY)=0)      and   (real.milliseconds    <i);        end;   write(ScsiBus )=S$ATN;         /* remove sel */   write(ScsiData)=0;             /* and    bit */   if ((read(ScsiBus)&S$BSY)=0)   then do;      write(ScsiBus )=0;          /* remove atn    */      return S$SelFailed;   end;   i = wait.for.req;              /* wait for req */   if i <> 0 then do;      write(ScsiBus )=0;         /* remove atn    */      return i;                  /* no req       */   end;   write(ScsiBus ) = 0;          /* remove atn */   write(ScsiByte) = message;   return 0;end Send.Message;/* $page - non-overlapped commands *//* the software uses the scsi ports in two distinctly separate   ways.   In the non-overlapped method,  commands are issued   to a drive,  and we wait right there for the status/data.   These commands are done during startup,  or when updating   directories, etc. *//* once the system is up and running,   overlapped commands are   issued to multiple ports at once.   this method is   described later. *//* requestsense is only called during error recovery within   a non-overlapped command routine.   the d24# and the port#   have been selected.  issue a request sense command         *//* note:   TPTR must point to a drive entry here */requestsense:proc PUBLIC swapable;   dcl (i,j,k)                    fixed;   i=wait.for.busfree.or.start.reset(track.port#);   if i<>0 then do;                    /* would be S$ArbFailed     */      track.command(track.track#)=S$RequestSense;      track.status (track.track#)=i;   /* but do not deselect here */      return i;                        /* since we did a reset     */   end;                                /* on the port              */	if (tptr == optical.tptr)   	i=optical_connect(track.target#);	else   	i=connect(track.target#);   if i<>0 then do;      track.command(track.track#)=S$RequestSense;      track.status (track.track#)=i;      return i;   end;   i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=S$RequestSense;      track.status (track.track#)=i;      return i;   end;   write(ScsiByte) = S$RequestSense;   write(ScsiByte) = shl(track.lun#,5);     i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=S$RequestSense;      track.status (track.track#)=i;      return i;   end;   if (read(ScsiBus)&S$SigMask)=S$Command   then do;                                /* lun exists   */      write(ScsiWord) = 0;      write(ScsiByte) = 7;      write(ScsiByte) = 0;   end;   i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=S$RequestSense;      track.status (track.track#)=i;      return i;   end;   if (read(ScsiBus)&S$SigMask)=S$Datain   then do;      i=read(ScsiWord);      j=read(Scsibyte) and "HF";      i=read(ScsiWord);      i=read(ScsiWord);   end;   else j=S$NoData;    i=read(ScsiWord);   return j;    /* return sense status */end requestsense;/* $page - routine to issue non-overlapped diskread/diskwrite *//* note:   TPTR must point to a drive entry here */dcl (PolyMemSec, PolyMemWord) fixed PUBLIC;readwrite: proc(command, secmsb, seclsb, buf, wlen, repeat) swapable;   dcl (command)            fixed;   dcl (secmsb,seclsb,wlen) fixed;   dcl (repeat)             fixed;   dcl (buf)                array;   dcl (i,j,k)              fixed;   dcl (ptr)                fixed;   dcl (start.time)         fixed;   dcl (smam,smal )         fixed;   dcl (blen)               fixed;   dcl (blockskip)          fixed;   dcl (blockpad)           fixed;   dcl (skip)               fixed;   dcl (pad)                fixed;   call select.d24(track.d24#);            /* select d24 for drive */   i=select.port.or.start.reset(track.port#,lun0.penable);   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      return i;   end;   start.time=real.milliseconds;   if addr(buf(0))=0 then do;              /* ext mem - save pointers */      smam = read(mam);      smal = read(mal);   end;   /* look up block length,  and correct sector address based upon */   /* whether device has 512 byte sectors or 1024 byte sectors     */   blockskip = 0;                         /* assume no skip needed */   blockpad  = 0;                         /* assume no pad needed  */   blen = repeat*shr(wlen+255,8);         /* # of 256 wrd blocks   */   if shr(track.drive.exists,8) then do;  /* if 1024 byte sectors  */      if seclsb then do;                  /* detect read/write of  */         if command = S$ExtendedRead      /* odd sector            */         then blockskip = 1;         else if command = S$ExtendedWrite         then blockpad  = 1;              /* write to odd sector   */      end;                                /* of optical disk?      */      seclsb = shr(seclsb,1) \ shl(secmsb,15);      secmsb = shr(secmsb,1);      blen = shr(blen + 1 + (blockskip | blockpad),1); /* # of 512 wrd blocks   */   end;   retry:;   skip = blockskip;                       /* get working copies         */   pad  = blockpad;   if addr(buf(0))=0 then do;              /* ext mem - restore pointers */      write(mam) = smam;      write(mal) = smal;   end;   if addr(buf(0))=(-1) then do;           /* poly mem - save pointers */      if command = S$ExtendedRead          /* if reading disk ...      */      then call psmwrite (PolyMemSec,PolyMemWord); /* then write poly  */      else call psmread  (PolyMemSec,PolyMemWord); /* else read poly   */   end;                                    /* to write to disk!        */   i=wait.for.busfree.or.start.reset(track.port#);   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;   /* but do not deselect here */      return i;                        /* since we did a reset     */   end;                                /* on the port              */	if (tptr == optical.tptr)   	i=optical_connect(track.target#);	else   	i=connect(track.target#);		   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      call deselect(track.port#);      /* unconnect to get free bus   */      return i;   end;   i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      call deselect(track.port#);      /* unconnect to get free bus   */      return i;   end;   write(ScsiByte) = command;                /* issue scsi command    */   write(ScsiByte) = shl(track.lun#,5);      /* Target LUN            */   write(ScsiWord) = secmsb;                 /* Logical Block Address (MSW) */   write(ScsiWord) = seclsb;                 /* Logical Block Address (LSW) */   write(ScsiByte) = 0;                      /* Reserved              */   write(ScsiWord) = blen;                   /* this many blocks      */   write(ScsiByte) = 0;                      /* Control byte          */   i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      call deselect(track.port#);      /* unconnect to get free bus   */      return i;   end;   ptr=0;   if command=S$ExtendedRead   then do while (read(ScsiBus)&S$BusMask)=(S$BSY \ S$I.O \ S$REQ);   /* data in       */      if skip then do;                      /* if skipping odd optical */         j = 0;                             /* sector,  then save no   */         skip = 0;                          /* words                   */      end;      else if (wlen-ptr) ige 256 then do;   /* else if >= 256 wrds     */         j = 256;                           /* then save all of them   */      end;      else do;                              /* else save only amount   */         j = wlen-ptr;                      /* we want                 */      end;      if j<>0 then do;                      /* if more words to save   */         if addr(buf(0))=0 then do;         /* in memory,  then do so  */            rpc j;                          /* in external memory      */            write(mdi)=read(ScsiWord);         end;         else if addr(buf(0))=(-1) then do; /* or in poly memory       */            rpc j;            write(psd)=read(ScsiWord);         end;         else do;                           /* or in internal memory   */            write("313")=addr(buf(ptr));            rpc j;            write("373")=read(ScsiWord);         end;      end;      if j <> 256 then do;                  /* if only saving part     */         rpc 256-j;                         /* of a block then ignore  */         write("313")=read(ScsiWord);       /* the rest                */      end;      ptr=ptr+j;                            /* advance pointer         */      do j=0 to 10;end;      i=wait.for.req;      if i<>0 then do;         track.command(track.track#)=command;         track.status (track.track#)=i;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;   end;   else do while (read(ScsiBus)&S$BusMask)=(S$BSY \ S$REQ);   /* data out       */      if  (ptr = wlen )      and (repeat <> 1)      then do;                          /* check for repeated data    */         ptr=0;                         /* must be repeating          */         if addr(buf(0))=0 then do;     /* ext mem - restore pointers */            write(mam) = smam;            write(mal) = smal;         end;         if addr(buf(0))=(-1) then do;            call psmread(PolyMemSec,PolyMemWord);         end;      end;      if (pad <> 0) then do; /* if we are writing to the optical and */         j = 0;              /* need to pad a sector with zeros      */         pad = 0;      end;      else if (wlen-ptr) ige 256 then do;/* if 256 more words to write */         j = 256;                        /* then write them all        */      end;      else do;                          /* else finish out partial    */         j = wlen-ptr;                  /* block                      */      end;      if j<>0 then do;                  /* if any words are left to   */         if addr(buf(0))=0 then do;     /* write,  then do so         */            rpc j;                      /* ... from external memory   */            write(ScsiWord)=read(mdi);         end;         else if addr(buf(0))=(-1) then do;             rpc j;                      /* ... from poly memory       */            write(ScsiWord)=read(psd);         end;         else do;                       /* ... from internal memory   */            write("313")=addr(buf(ptr));            rpc j;            write(ScsiWord)=read("373");         end;      end;      if j <> 256 then do;              /* if writing a partial sector */         rpc 256-j;                     /* then fill rest of block     */         write(ScsiWord)=0;             /* with zeroes                 */      end;      ptr=ptr+j;                        /* advance pointer             */      do j=0 to 10;end;      i=wait.for.req;      if i<>0 then do;         track.command(track.track#)=S$ExtendedWrite;         track.status (track.track#)=i;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;   end;   i=shr(read(ScsiWord),8);                    /* get status            */   if i=S$CheckCondition then do;      j=requestsense;      if (j=S$ArbFailed)                       /* timed out - could not */      then return j;                           /* get bus - reset done  */      else if (j=S$RecoveredError)      or      (j=S$NoSense       )      then do;         i=0;                                  /* good status           */      end;      else if (j=S$NotReady     )      or      (j=S$UnitAttention)       then do;         if (real.milliseconds<start.time+20000)         then goto retry;         else i=i+shl(j,8);                         /* put request sense status in upper half */      end;      else i=i+shl(j,8);                            /* put request sense status in upper half */   end;   else if i=S$Busy then do;                        /* retry on busy */      if (real.milliseconds<start.time+20000)      then goto retry;   end;   call deselect(track.port#);         /* unconnect to get free bus   */   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      return i;   end;      if ptr<>wlen then do;      track.command(track.track#)=command;      track.status (track.track#)=S$NoData;      return S$NoData;   end;   return 0;end readwrite;/* $page - Non-overlapped READDATA *//* note:   TPTR must point to a drive entry here */readdata:proc(secmsb,seclsb,buf,wlen) PUBLIC;   dcl (secmsb,seclsb,wlen) fixed;   dcl (buf)                array;   return readwrite(S$ExtendedRead,secmsb,seclsb,buf,wlen,1);end readdata;/* $page - Non-overlapped WRITEDATA *//* note:   TPTR must point to a drive entry here */writedata: proc(secmsb,seclsb,buf,wlen,repeat) PUBLIC; /* (public to write out song directory) */   dcl (secmsb,seclsb,wlen,repeat) fixed;   dcl (buf)                       array;   return readwrite(S$ExtendedWrite,secmsb,seclsb,buf,wlen,repeat);end writedata;/* $page - issue non-data commands (inquire, startunit, etc) *//* note:   TPTR must point to a drive entry here */dcl cap.msb fixed PUBLIC;dcl cap.lsb fixed PUBLIC;dcl InquiryDataCode (16) fixed PUBLIC;dcl InquiryRMBCode       fixed PUBLIC;dcl ModeSenseData   (32) fixed PUBLIC;/* Normal case:  arg1 = SCSI bytes 2, 3			 *//*               arg2 = SCSI byte 4				 *//*               arg3 = SCSI byte 5				 */nondatacommand: proc(command, lunword, arg1, arg2, arg3, issueonly) swapable;   dcl (command)        fixed;   dcl (lunword)        fixed;   dcl (arg1,arg2,arg3) fixed;   dcl (i,j,k,l,m,n)    fixed;   dcl (start.time)     fixed;   dcl (issueonly)      fixed;   /*  0: issue command and wait for result */                                 /* +1: issue command only                */                                 /* +2: send message only                 */                                 /* -1: check result only                 */   call select.d24(track.d24#);            /* select d24 for drive */   i=select.port.or.start.reset(track.port#,lun0.penable);   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      return i;   end;   if issueonly >=0 then do;               /* issue command unless  */                                           /* we are calling to     */      start.time=real.milliseconds;        /* get status result     */      retry:;      i=wait.for.busfree.or.start.reset(track.port#);      if i<>0 then do;         track.command(track.track#)=command;         track.status (track.track#)=i;   /* but do not deselect here */         return i;                        /* since we did a reset     */      end;                                /* on the port              */      if issueonly = 2 then do;           /* send message byte        */         i = Send.Message(track.target#, arg1);         if i<>0 then do;                 /* check for ok status      */            track.command(track.track#)=command;            track.status (track.track#)=i;         end;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;      i=connect(track.target#);      if i<>0 then do;         track.command(track.track#)=command;         track.status (track.track#)=i;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;      i=wait.for.req;      if i<>0 then do;         track.command(track.track#)=command;         track.status (track.track#)=i;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;      write(ScsiByte) = command;      if command = S$ModeSelect      then write(ScsiByte) = lunword \ "20";  /* set PF bit */      else write(ScsiByte) = lunword;      i=wait.for.req;      if i<>0 then do;         track.command(track.track#)=command;         track.status (track.track#)=i;         call deselect(track.port#);      /* unconnect to get free bus   */         return i;      end;      if (read(ScsiBus)&S$SigMask)=S$Command      then do;                                /* lun exists   */         write(ScsiWord) = arg1;		  /* SCSI bytes 2, 3			 */         write(ScsiByte) = arg2;		  /* SCSI byte 4				 */         write(ScsiByte) = arg3;		  /* SCSI byte 5				 */         if command=S$ReadCapacity then do;            write(ScsiWord) = 0; write(ScsiWord) = 0;         end;      end;      if issueonly <> 0 then do;              /* issue command then return   */         call deselect(track.port#);          /* unconnect to get free bus   */         return 0;      end;   end;   i=wait.for.req;   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      call deselect(track.port#);      /* unconnect to get free bus   */      return i;   end;   if command=S$Inquiry then do;             /* return for inquire command */      if (read(ScsiBus)&S$SigMask)=S$Datain  /* check for data in phase    */      then do;         k=read(ScsiByte);                   /* get drive type into return variable.  0 = disk */		   InquiryRMBCode = read(ScsiByte);	 	/* get RMB bit as well							   */         write("324") = read(ScsiByte);		/* toss unneeded stuf for now...				   */         write("324") = read(ScsiByte);         l=read(ScsiByte)+5;                 /* get tot avail sense bytes */         if   l > arg2                       /* if more than we asked for */         then l = arg2;                      /* then limit                */         InquiryDataCode(0) = 0;             /* initialize string length  */         do m = 5 to l-1;                    /* get additional bytes      */            n = read(ScsiByte);              /* get bytes                 */            if (n < 32) or (n > 126)         /* limit to ascii            */            then n = 32;            if m >= 8 then do;               /* store name                */               call pbyte(InquiryDataCode, m-8, n);               InquiryDataCode(0) = InquiryDataCode(0) + 1;            end;         end;      end;      else k=(S$NoData);      i=shr(read(ScsiWord),8);                    /* get status            */      if i=S$CheckCondition then do;         j=requestsense;   /**/  if (j=S$NotReady)                        /* not ready from disk   */   /**/  then do;                                 /* assume it is a disk   */   /**/     i=0;                                  /* that has not been     */   /**/     k=0;                                  /* started up            */   /**/  end;         else if (j=S$ArbFailed)                  /* timed out - could not */         then return j;                           /* get bus - reset done  */         else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;         else if (j=S$NotReady     )              /* old code              */         or      (j=S$UnitAttention)          then do;            if (real.milliseconds<start.time+20000)            then goto retry;            else i=i+shl(j,8);                   /* put request sense status in upper half */         end;         else i=i+shl(j,8);                      /* put request sense status in upper half */      end;      else if i=S$Busy then do;                  /* return busy code in */         i = 0;                                  /* case cart is in     */         k = S$Busy;                             /* drive during        */      end;                                       /* startup             */   end;                     /* of inquire command */   else if ((command == S$StartStop   )	||       (command == S$PreventAllow)	||       (command == S$FormatUnit  ))	then do;      i=shr(read(ScsiWord),8);                    /* get status            */      if i=S$CheckCondition then do;        		   j=requestsense;        		   if (j=S$ArbFailed)                       /* timed out - could not */         then return j;                           /* get bus - reset done  */        		   else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;        		   else if ((command == S$FormatUnit   )	  /* return unit atten		*/			&&       (j       == S$UnitAttention))	  /* explicitly for format */				i = i+shl(j,8);						   else if (j=S$NotReady     )              /* old code              */         or      (j=S$UnitAttention)          then do;            i=S$Reissue;                          /* reissue               */         end;        		   else i=i+shl(j,8);                       /* put request sense status in upper half */      end;      else if i=S$Busy then do;                   /* retry on busy    */         i=S$Reissue;                             /* reissue               */      end;      if i=S$IllegalRequest then i=0;          /* treat as good status if drive does not respond to start unit command. */      k=i; /* return command status */   end;   else if command=S$TestUnitReady then do;      i=shr(read(ScsiWord),8);                    /* get status            */      if i=S$CheckCondition then do;        		   j=requestsense;         			if (j=S$ArbFailed)                       /* timed out - could not */         then return j;                           /* get bus - reset done  */        		   else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;         			else if (j=S$UnitAttention)          then do;            if (real.milliseconds<start.time+20000)            then goto retry;            else i=i+shl(j,8);                         /* put request sense status in upper half */         end;         else i=i+shl(j,8);                            /* put request sense status in upper half */      end;      k = i;      if ((i == S$Busy)												/* if drive reports busy or not ready,	*/		||  (i == S$CheckCondition + shl(S$NotReady, 8)))	/* don't bother to publich those two	*/			i=0;    /* not an error */								/* stati to the user...						*/         end;   else if command=S$ReadCapacity then do;      if (read(ScsiBus)&S$SigMask)=S$Datain      then do;         cap.msb=read(ScsiWord);         cap.lsb=read(ScsiWord);         l      =read(ScsiWord);         m      =read(ScsiWord);         cap.lsb=cap.lsb+1;                  /* add 1 to get # of sectors */         if cap.lsb=0 then cap.msb=cap.msb+1;      end;      else do;         cap.msb=0;         cap.lsb=0;         l=0; m=512;      end;      i=shr(read(ScsiWord),8);       /* get status            */      if i=S$CheckCondition then do;         j=requestsense;         if (j=S$ArbFailed)                       /* timed out - could not */         then return j;                           /* get bus - reset done  */         else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;         else if (j=S$NotReady     )         or      (j=S$UnitAttention)          then do;            if (real.milliseconds<start.time+20000)            then goto retry;            else i=i+shl(j,8);                         /* put request sense status in upper half */         end;         else i=i+shl(j,8);                            /* put request sense status in upper half */      end;      else if i=S$Busy then do;                   /* retry on busy    */         if (real.milliseconds<start.time+20000)         then goto retry;      end;      if i<>0 then do;         cap.msb=0;         cap.lsb=0;         k=i;          /* bad status of sorts */      end;            if ((shr(track.drive.exists,8)=0) & ((l<>0)\(m<> 512)))      or ((shr(track.drive.exists,8)=1) & ((l<>0)\(m<>1024)))      then do;         cap.msb=0;         cap.lsb=0;         i=S$BlockSizeError;         k=S$BlockSizeError;      end;      else if (cap.msb=0)&(cap.lsb=0) then do;         i=S$Nodata;         k=S$Nodata;      end;   end;   else if command = S$ModeSense then do;   /* get mode sense info */      if (read(ScsiBus)&S$SigMask)=S$Datain      then do;         do i = 0 to (arg2-1);            ModeSenseData(i) = read(ScsiByte);         end;         k=0;      end;      else k=(S$NoData);      i=shr(read(ScsiWord),8);                    /* get status            */      if i=S$CheckCondition then do;         j=requestsense;         if (j=S$ArbFailed)                       /* timed out - could not */         then return j;                           /* get bus - reset done  */         else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;         else if (j=S$NotReady     )         or      (j=S$UnitAttention)          then do;            if (real.milliseconds<start.time+20000)            then goto retry;            else i=i+shl(j,8);                         /* put request sense status in upper half */         end;         else i=i+shl(j,8);                            /* put request sense status in upper half */      end;      else if i=S$Busy then do;                   /* retry on busy    */         if (real.milliseconds<start.time+20000)         then goto retry;      end;   end;   else if command = S$ModeSelect then do;       /* set mode select info */      if (read(ScsiBus)&S$SigMask)=S$DataOut      then do;         do i = 0 to (arg2-1);            write(ScsiByte) = ModeSenseData(i);         end;         k=0;      end;      else k=(S$NoData);      i=shr(read(ScsiWord),8);                    /* get status            */      if i=S$CheckCondition then do;         j=requestsense;         if (j=S$ArbFailed)                       /* timed out - could not */         then return j;                           /* get bus - reset done  */         else if (j=S$RecoveredError)         or      (j=S$NoSense       )         then do;            i=0;                                  /* good status           */         end;         else if (j=S$NotReady     )         or      (j=S$UnitAttention)          then do;            if (real.milliseconds<start.time+20000)            then goto retry;            else i=i+shl(j,8);                         /* put request sense status in upper half */         end;         else i=i+shl(j,8);                            /* put request sense status in upper half */      end;      else if i=S$Busy then do;                   /* retry on busy    */         if (real.milliseconds<start.time+20000)         then goto retry;      end;   end;   call deselect(track.port#);      /* unconnect to get free bus   */   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;   end;      return k;                             end nondatacommand;/* $page - Non-overlapped INQUIRE, START UNIT, TEST UNIT READY, READ CAPACITY *//* note:   TPTR must point to a drive entry here */Send.Message.To.Target: proc(message);   dcl message fixed;   return nondatacommand(S$RezeroUnit, shl(track.lun#,5) , Message, 0, 0, 2);end Send.Message.To.Target;Inquire:proc PUBLIC;   InquiryDataCode(0) = 0;    /* initialize to null string */   return nondatacommand(S$Inquiry,shl(track.lun#,5),0,36,0,0);end inquire;Issue.Start.Unit:proc (immed, code) PUBLIC;	dcl (immed, code) fixed;	   return nondatacommand(S$StartStop,shl(track.lun#,5) | immed, 0, 1, 0, code);end Issue.Start.Unit;Issue.Stop.Unit:proc (code) PUBLIC;	dcl code fixed;	   return nondatacommand(S$StartStop, shl(track.lun#,5) | 1, 0, 0, 0, code);end Issue.Stop.Unit;Issue.Eject.Unit:proc PUBLIC;   return nondatacommand(S$StartStop, shl(track.lun#,5) | 1, 0, 2, 0, 1);end Issue.Eject.Unit;Issue.Prevent.Allow:proc (which) PUBLIC;	dcl which fixed;	   return nondatacommand(S$PreventAllow, shl(track.lun#,5), 0, which, 0, 0);end Issue.Prevent.Allow;Issue.Format.Unit:proc PUBLIC;   return nondatacommand(S$FormatUnit, shl(track.lun#,5), 0, 0, 0, 1);end Issue.Format.Unit;Check.For.Start.Unit.Result:proc PUBLIC;   dcl i fixed;   call select.d24(track.d24#);            /* select d24 for drive */   i=select.port.or.start.reset(track.port#,lun0.penable);   if i<>0 then do;      track.command(track.track#)=S$StartStop;      track.status (track.track#)=i;      return i;   end;   if ((read(ScsiBus)&S$REQ) = 0) then do;      call deselect(track.port#);      /* unconnect to get free bus   */      return S$NoReqYet;   end;   call deselect(track.port#);      /* unconnect to get free bus   */   return nondatacommand(S$StartStop,shl(track.lun#,5),0,1,0,-1);end Check.For.Start.Unit.Result;Test.Unit.Ready:proc PUBLIC;   return nondatacommand(S$TestUnitReady,shl(track.lun#,5),0,0,0,0);end Test.Unit.Ready;ReadCapacity:proc PUBLIC;   return nondatacommand(S$ReadCapacity,shl(track.lun#,5),0,0,0,0);end ReadCapacity;ModeSense:proc(page#, bytelen) PUBLIC;   dcl page#    fixed;   dcl bytelen  fixed;   return nondatacommand(S$ModeSense,shl(track.lun#,5),shl(page#,8),bytelen,0,0);end ModeSense;ModeSelect:proc(bytelen) PUBLIC;   dcl bytelen  fixed;   return nondatacommand(S$ModeSelect,shl(track.lun#,5),0,bytelen,0,0);end ModeSelect;/* $PAGE - start.disk.op - start overlapped disk operation *//* issue disk read/write command for LOD.  for use with real time code *//* note:   TPTR must point to a drive entry here */dcl port.tape.addr (max.ports) fixed PUBLIC;Start.Disk.Op:proc(command,secmsb,seclsb,slen,pmemsec,pmemwrd);   dcl (command,secmsb,seclsb,slen,pmemsec,pmemwrd) fixed;   dcl (i,j) fixed;   /* remember: issue a reset or do a deselect! */   call select.d24(track.d24#);            /* select d24 for drive */   i=select.port.or.start.reset(track.port#,lun0.penable);   if i<>0 then do;                        /* reset occurred        */      track.command(track.track#)=command;      track.status (track.track#)=i;      return i;   end;   i=wait.for.busfree.or.start.reset(track.port#);   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;   /* but do not deselect here */      return i;                        /* since we did a reset     */   end;                                /* on the port              */   /* turn on poly memory port if we should */   if  (command<>S$RequestSense)   /* if not getting sense     */   then do;                        /* get ready for data xfer  */      /* Check for special case pmemwrd = (-1): means the pmem     */      /* address for this data transfer is from a different        */      /* buffer memory card and we must use a manual data transfer */      /* instead of using LUN 1                                    */      if pmemwrd = (-1) then do;         port.tape.addr(track.port#) = pmemsec;      end;      else do;         call targ0.connect(1);         if command=S$ExtendedRead         then write(ScsiByte)=2\shl((shr(pmemsec,8)&"3"),2);  /* data in  */         else write(ScsiByte)=3\shl((shr(pmemsec,8)&"3"),2);  /* data out */         write(ScsiWord)=shl(pmemsec,8)+pmemwrd;              /* address  */         port.lun1 (track.port#)=1;           /* inidicate lun1 enabled!  */         i=wait.for.busfree.or.start.reset(track.port#);       /* make sure  */         if i<>0 then do;                                      /* bus is     */            track.command(track.track#)=command;        /* still free */            track.status (track.track#)=i;   /* but do not deselect here */            return i;                        /* since we did a reset     */         end;                                /* on the port              */      end;   end;   i=connect(track.target#);           /* now connect to drive     */   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      if port.lun1(track.port#)<>0      then do;                         /* clear lun1 if activated  */         j=wait.for.busfree.or.start.reset(track.port#);         if j<>0 then return i;        /* could not even reset lun 1 */         call targ0.connect(1);        /* clear lun 1                */         write(ScsiByte)=0;            /* clear lun 1 bits           */         port.lun1(track.port#)=0;      end;      call deselect(track.port#);      /* unconnect to get free bus  */      return i;   end;   i=wait.for.req;                     /* wait for ready for command */   if i<>0 then do;      track.command(track.track#)=command;      track.status (track.track#)=i;      if port.lun1(track.port#)<>0      then do;                         /* clear lun1 if activated  */         j=wait.for.busfree.or.start.reset(track.port#);         if j<>0 then return i;        /* could not even reset lun 1 */         call targ0.connect(1);        /* clear lun 1                */         write(ScsiByte)=0;         port.lun1(track.port#)=0;      end;      call deselect(track.port#);      /* unconnect to get free bus  */      return i;   end;   write(ScsiByte) = command;                  /* issue scsi command    */   write(ScsiByte) = shl(track.lun#,5);        /* Target LUN            */   if command=S$RequestSense then do;      write(ScsiWord) = 0;      write(ScsiByte) = 7;      write(ScsiByte) = 0;   end;   else do;      write(ScsiWord) = secmsb;       /* Logical Block Address (MSW) */      write(ScsiWord) = seclsb;       /* Logical Block Address (LSW) */      write(ScsiByte) = 0;            /* Reserved              */      write(ScsiWord) = slen;         /* this many blocks      */      write(ScsiByte) = 0;            /* Control byte          */   end;   call deselect(track.port#);        /* unconnect to get free bus   */   return 0;end Start.Disk.Op;/* $page - Overlapped Readdata, Writedata, Request Sense *//* note:   TPTR must point to a drive entry here */Start.Disk.Read:proc(secmsb,seclsb,slen,pmemsec,pmemwrd);   dcl (secmsb,seclsb,slen,pmemsec,pmemwrd) fixed;   return Start.Disk.Op(S$ExtendedRead,secmsb,seclsb,slen,pmemsec,pmemwrd);end Start.Disk.Read;Start.Disk.Write:proc(secmsb,seclsb,slen,pmemsec,pmemwrd);   dcl (secmsb,seclsb,slen,pmemsec,pmemwrd) fixed;   return Start.Disk.Op(S$ExtendedWrite,secmsb,seclsb,slen,pmemsec,pmemwrd);end Start.Disk.Write;Start.Request.Sense:proc;   return Start.Disk.Op(S$RequestSense,0,0,0,0,0);end Start.Request.Sense;/* $page - issue rezero commands to all drives */issue.rezero.commands.to.all.drives:proc PUBLIC swapable;   dcl (track#,port#)             fixed;   dcl (ldrive#     )             fixed;   dcl (i           )             fixed;   /* loop over all tracks */   i = 0;   do track# = 0 to max.tracks - 1;   /* loop over all tracks        */      if track.available(track#)<>0      then do;         do ldrive# = 0 to max.drives.per.track - 1; /* do all disks; but not tapes */            tptr=track#*total.stride+ldrive#*track.info.stride;            /* issue rezero commands to all drives */            /* that need them                      */            if (track.drive.exists&4)<>0 then do;                 port#=track.port#;              /* check port         */               if  (port.available(port#) <> 0)               and (port.io       (port#) =  0)               then do;                  call Send.Message.To.Target(S$ResetDev);                  i = i + 1;               end;            end;         end;      end;   end;   return i;end issue.rezero.commands.to.all.drives;