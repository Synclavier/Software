/* lod1-17 - process tape commands - backup, erase, load *//* 08/20/90 - cj  - added code for 4 wangs/4 pats                  *//* 02/26/90 - cj - set tape.issue.len for every tape write command *//* 01/16/90 - cj - added tandberg code                   *//* 06/02/89 - cj - added exabyte code                    *//* 02/09/89 - cj - fixed 'muted track load/backup bug'   */dcl include.verify       lit '1';   /* 1 to include checksum blocks - if so, */                                    /* then backup tapes will not be compat  */                                    /* ible with earlier software            */dcl verify.len           lit '256'; /* check sum length                      */dcl (verify_do_len    )  fixed;dcl (readybits        )  fixed;dcl (emptybits        )  fixed;dcl (dumpedbits       )  fixed;dcl (bouncedbits      )  fixed;dcl (onetapeloaded    )  fixed;dcl (interrogatedtapes)  fixed;dcl (auxinterrogated  )  fixed;dcl (tapetouse        )  fixed;dcl (skipverify       )  fixed;dcl (alt.tdir.needed)    fixed;  /* get tdir for command.song#              */dcl (alt.tdir.valid )    fixed;  /* true if read in                         */dcl (alt.tdir.updated)   fixed;  /* true if changed                         */dcl (write.alt.tdir)     fixed;  /* write when done                         */dcl (alt.tdir.tracks)    fixed;  /* bits to write alt tdirs                 */dcl (buf.size.in.use)    fixed;  /* size of buffer in use                   */dcl (active.tape.config) fixed;  /* 0 = multi; 1 = use aux tape             */dcl (interrogate.tapes ) fixed;  /* 1 = interrogate tapes for carts         */dcl tape.write.code (max.ports) fixed;  /* holds code for write errors   */dcl port.polyadd    (max.ports) fixed;  /* holds poly address            */dcl port.dport#     (max.ports) fixed;  /* holds destination port#       */dcl backup.begin.real.interrogation.state fixed;dcl backup.begin.backup.of.track.state    fixed;dcl backup.message.code							fixed;finish.port.command:proc(port#);   dcl port#  fixed;   dcl track# fixed;   command.tracks = command.tracks                   and (not(port.track.bits(port#)));   if command.tracks=0   then command.completed=1;end finish.port.command;finish.command:proc(track#);   dcl track# fixed;   command.tracks=command.tracks and (not(bits(track#)));   if command.tracks=0   then command.completed=1;end finish.command;abort.check:proc(track#);   dcl track# fixed;   if abort.command<>0         /* bombed out on other track           */   then do;      call finish.command(track#);      command.aborted=1;      return 1;   end;   return 0;end abort.check;/* Handy routine to check states during drive interrogation */check.interrogation.condition: proc(port#);   dcl port# fixed;   /* normal exit is by retry > 3 if there is no tape configured.     */   if (port.retry(port#) > 3) or (interrogate.tapes = 0)   then do;      port.retry(port#) = 0;      tape.state(port#) = tape.state(port#) + 1;      return 1;   end;   if abort.command<>0         /* bombed out on other track           */   then do;                    /* or user abort:  just stop.          */      if port.available(max.ports) = 0       /* if no aux tape        */      then interrogate.tapes = 0;            /* then done looking     */      if (port# = max.ports)                 /* if this is aux tape   */      then interrogate.tapes = 0;            /* then stop it.         */      else if interrogate.tapes = 0          /* else if done with aux */      then do;                               /* then quit             */         call finish.port.command(port#);         command.aborted=1;      end;      return 1;   end;   if log.buf(0)<>0            /* wait for error message to be sent   */   then return 1;              /* to ABLE.                            */   return 0;end check.interrogation.condition;/* And common routine to check for results of interrogation */check.interrogation.result: proc(port#) swapable;   dcl port# fixed;   dcl i     fixed;   dcl j     fixed;   /* Check for abort,  error (no tape drive), end of interrogation */   if check.interrogation.condition(port#) <> 0   then return;   /* Interrogate both tape1 and tape2 tapes:                       */	/* We get here when we have done an inquiry and a test unit		  */	/* for the tape drive.  We repeat this process for two tape		  */	/* drives to see if one of them is ready								  */   if (tape.to.use(port#) = 0)  /* if we have not checked second    */   then do;                     /* tape on this port ...            */      tape.to.use(port#) = 1;   /* then do so.                      */      port.retry (port#) = 0;      tape.state (port#) = tape.state(port#) - 2;      return;   end;   /* We have checked the tapes for this port.  See if there is */   /* a cart ready for use                                      */   if port# = max.ports then auxinterrogated = (-1);   else interrogatedtapes = interrogatedtapes \ port.track.bits(port#);   /* Wait for other ports to interrogate their drives if      */   /* we are the first to finish:                              */   if (((command.tracks & (not(interrogatedtapes))) <> 0))   or (((port.available(max.ports)                ) <> 0)   and ((auxinterrogated                          ) =  0))   then do;      tape.to.use(port#) = 0;      port.retry (port#) = 0;      port.timer (port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */      port.io    (port#) = Tape.Wait;      tape.state (port#) = tape.state(port#) - 2;      return;   end;   /* Check for too many carts in drive */   i = 0;   do j = 0 to max.ports-1;      i = i \ tape.condition(j);   end;   j = i \ tape.condition(max.ports);      if  (((i                         & (t1.cond.rdy\t2.cond.rdy)) <> 0)  /* tape in port drive */   and  ((tape.condition(max.ports) & (t1.cond.rdy\t2.cond.rdy)) <> 0)) /* plus in aux  drive */   or  (((j                         & (t1.cond.rdy            )) <> 0)  /* tape in both tope1 */   and  ((j                         & (t2.cond.rdy            )) <> 0)) /* and tape2 drives   */   then do;      /* oops - tape in more than one drive configuration */      if errmess <> (-2)      then call log.error('Ambiguous drive usage - Remove unnecessary cartridges!');      errmess = (-2);      call finish.port.command(port#);      command.fatal = 1;      return;   end;   /* Check for no tapes in cartrdige */   if  ((i                         & (t1.cond.rdy\t2.cond.rdy)) = 0) /* no tape in port drive */   and ((tape.condition(max.ports) & (t1.cond.rdy\t2.cond.rdy)) = 0) /* no tape in aux  drive */   then do;      if  (errmess <> (-1))      and (errmess <> (-2))      then do;         call log.error('Please insert cartridge in drive at this time');         errmess = (-1);      end;      tape.to.use(port#) = 0;      port.retry (port#) = 0;      port.timer (port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */      port.io    (port#) = Tape.Wait;      tape.state (port#) = tape.state(port#) - 2;      return;   end;   /* Else select this cartridge for use. */   if ((tape.condition(max.ports) & (t1.cond.rdy\t2.cond.rdy)) <> 0)   then active.tape.config = 1;      /* switch to AUX only here     */   if (j & t1.cond.rdy) <> 0         /* check for tape1 VS tape2    */   then tapetouse = 0;   else tapetouse = 1;   interrogate.tapes = 0;            /* cancel interrogation phase  */   if errmess = (-1) then do;        /* thank the user if we had    */      call log.error('Thank You.');  /* asked him for a tape.       */      errmess = 0;   end;   port.retry (port#) = 0;end check.interrogation.result;hardware.error:proc(port#,track#) swapable; /* max no. retries exceeded */   dcl (port#,track#) fixed;   if port.empty(port#)<>0               /* empty tracks      */   then do;                              /* no error mes      */      call finish.port.command(port#);   /* even if bad hdwre */      return;   end;   if  (track.command(track#) = S$RequestSense)   and (track.status (track#) = S$MediumError )   then call log.error('A Medium Error occurred with Backup ');   else call log.error('Hardware Error with Backup ');   call append.tape.mes(port#);   call finish.port.command(port#);   command.fatal=1;end hardware.error;/* Handy routine to issue tape commands */check.tape.ready: proc(port#, track#);   dcl port#  fixed;   dcl track# fixed;   if abort.check(track#)<>0					/* check for possible user abort			*/   then return 1;   if log.buf(0)<>0            				/* make sure error message get out     */   then return 1;   if port.retry(port#)>3 then do;			/* check for fatal error					*/      call hardware.error(port#,track#); 	/* print message if so						*/      return 1;   end;   return 0;										/* else no problems (yet!)					*/end check.tape.ready;issue.inquiry: proc (port#, track#);   dcl port#  fixed;   dcl track# fixed;   dcl i      fixed;   if check.tape.ready(port#, track#) <> 0   then return;   i = start.tape.command(port#, track#, Tape.Inquiry, 9);  /* start inquiry                */   if i<>0 then do;      /* Check for power on of aux port tape */      if  (port# = max.ports  )      and (i     = S$SelFailed)      and (errmess <> (-3)    )      then do;         call log.error('Please turn on power to Auxiliary Drive');         errmess = (-3);      end;   end;   else if (port# = max.ports)          /* else see if user has just */   and     (errmess = (-3))             /* turned on the aux tape    */   then do;                             /* power                     */      call log.error('Thank You.');      errmess = 0;   end;   return;end issue.inquiry;issue.test.unit.ready: proc(port#,track#);   dcl port#  fixed;   dcl track# fixed;   if check.tape.ready(port#, track#) <> 0   then return;   start.tape.command(port#, track#, Tape.TestUnit, 0);end issue.test.unit.ready;issue.mode.sense: proc(port#,track#);   dcl port#  fixed;   dcl track# fixed;   if check.tape.ready(port#, track#) <> 0   then return;   start.tape.command(port#, track#, Tape.ModeSense, 4);end issue.mode.sense;issue.read.capacity: proc(port#,track#);   dcl port#  fixed;   dcl track# fixed;   if check.tape.ready(port#, track#) <> 0   then return;   start.tape.command(port#, track#, Tape.ReadCapacity, 0);end issue.read.capacity;issue.mode.select: proc(port#,track#); /* mode select tape */   dcl (port#,track#) fixed;   if check.tape.ready(port#, track#) <> 0   then return;   if      (tape.type(port#) = type.cdc)                       /* Patriot        */   or      (tape.type(port#) = type.tan)                       /* Tanberg        */   then   start.tape.command(port#,track#,Tape.ModeSelect,12); /* = 12 bytes     */   else if (tape.type(port#) = type.epi)                       /* EPI            */   then   start.tape.command(port#,track#,Tape.ModeSelect,22); /* = 22 bytes     */   else   start.tape.command(port#,track#,Tape.ModeSelect,13); /* FUJ, Exabyte   */end issue.mode.select;get.stream.size:proc(port#); /* get stream size for a tape */   dcl port# fixed;   if      tape.type(port#) = type.epi then return (epi.stream.size);   else if tape.type(port#) = type.fuj then return (fuj.stream.size);   else                                     return (cdc.stream.size);end get.stream.size;/* Handle backup case of no cart in drive: */handle.backup.song.no.cart.case:proc(port#) swap; 	dcl (i,port#) fixed;		zero.jaz.position(port#);		/* reset possible jaz to BOT if no cart...		  */	if (errmess=(1024\port#))     /* write protect message had been displayed       */	then errmess=0;	if (errmess<>0)               /* other message waiting        */	then return;	if port# = max.ports          /* if using AUX tape, then      */	then i = port#;               /* ask for cart in it.          */	/* else if using multi tapes,  ask for cart for first track   */	/* that is not empty.                                         */	else if onetapeloaded = 0 then do;		i=0;                            /* have them load first tape */		do while (i < max.ports)		and      (((command.tracks&port.track.bits(i))=0)		or         (port.empty(i)<>0));			i=i+1;		end;		if i = max.ports then i=port#;	end;	else i=port#;	if tape.return.state(port#)<>0 then do; /* second tape: */		call log.error('Insert Next Cartridge in ');		call append.tape.mes(port#);		errmess=(256\port#);	end;	else do;		call log.error('Insert Cartridge in ');		call append.tape.mes(i);		errmess=(256\i);	end;end handle.backup.song.no.cart.case;handle.backup.song.cart.remove.case:proc (port#) swap; 	dcl port# fixed;		port.timer  (port#) = real.milliseconds + cdc.busy.delay; 		/* wait a while before polling again */	port.io     (port#) = Tape.Wait;	port.retry  (port#) = 0;     	tape.state  (port#) = backup.begin.real.interrogation.state; 	/* reissue inq */	if (errmess<>0)               /* other message waiting        */	then return;	errmess=(256\port#);	call log.error('Media is Full - Insert Next Cartridge in ');	call append.tape.mes(port#);end handle.backup.song.cart.remove.case;handle.backup.song.cart.in.case:proc(port#) swap; 	dcl port# fixed;		if (errmess = (256\port#))    /* if we had asked for    */	then do;                      /* cartridge, say         */		errmess = 0;               /* thank you.             */		if tape.return.state(port#)=0		then do;			call log.error('Thank You.');		end;		else do;			call log.error('Thank you. Continuing with Backup - ');			call append.tape.mes(port#);		end;	end;	/* else if we are continuing to second cart,  present   */	/* continuing message even if we did not explicitly     */	/* ask for the cartridge.                               */	else if (tape.return.state(port#)<>0)	and     (port.count       (port#) =0)	then do; 		if errmess=0 then do;			call log.error('Continuing with Backup - ');			call append.tape.mes(port#);		end;	end;	tape.state(port#) = tape.state(port#) + 1;end handle.backup.song.cart.in.case;handle.write.check.error.retry:proc (port#, track#) swap;	dcl (port#, track#) fixed;		if log.buf(0)<>0 then return;							/* wait for earlier error message */	if  (track.command(track#) = S$RequestSense)	and (track.status (track#) = S$MediumError )	then call log.error('A Medium Error occurred with Backup ');	else call log.error('Hardware Error with Backup ');	call append.tape.mes(port#);	call finish.port.command(port#);	command.fatal = 1;end handle.write.check.error.retry;handle.write.check.error.eof:proc (port#) swap;	dcl (port#) fixed;	tape.return.state(port#) = tape.state(port#);	tape.state (port#)       = 1;	tape.eof   (port#)       = 0;  /* clear eof flag              */	tape.remove(port#)       = 1;  /* wait for remove before load */end handle.write.check.error.eof;init.for.backup.song:proc(port#) swap;	dcl (port#) fixed;	backup.message.code = 0;		port.retry       (port#)=0; /* initialize retry count              */	tape.return.state(port#)=0;	tape.remove      (port#)=0;	tape.eof         (port#)=0;	port.empty       (port#)=0;	port.count       (port#)=0;	tape.type        (port#)=0;	tape.write.code  (port#)=0;	tape.state       (port#)=tape.state(port#) + 4;end init.for.backup.song;handle.backup.load:proc (port#, track#) swap;	dcl (port#, track#) fixed;		if errmess=0 then do;		call log.error('Media is Full - Ejecting ');		call append.tape.mes(port#);	end;	/* We are about to change media.  If this drive    */	/* is a removable media hard drive, write the		*/	/* file mark directory to the first sector of		*/	/* the disk.													*/		/* Note that we flush the directory to disk here	*/	/* and after writing the 'file mark'; it's not		*/	/* needed at any other time...							*/		if (tape.type(port#) == type.jaz)							 	/* if jaz drive, write		*/	{																			/* directory to disk...		*/				/* Update end of tape and write out directory.  Note that there may be no file	*/		/* marks if the first project on the media extended all the way across the			*/		/* first media and onto the second media.														*/				write(mam) = jaz.dir.sec# + port#;		write(mal) = jaz.leot.msb.loc;		write(mdi) = port.jaz.sec.msb(port#);						/* jaz.leot.msb.loc			*/		write(mdi) = port.jaz.sec.lsb(port#);						/* jaz.leot.lsb.loc			*/		      tape.issue.len (port#) = 1;		port.jaz.update(port#) = 0;									/* no update at this point */		tape.pmem.add = compute.base.adr(track#) + inf.base;	/* use info sector			*/		Tape.Disk.Add.Msb = 0;											/* disk block #				*/		Tape.Disk.Add.Lsb = 0;				call Copy.Ext.Mem.To.Poly(jaz.dir.sec# + port#, 0,			                       tape.pmem.add, 0, 256);		start.tape.command(port#,track#,Tape.ExtendedWr,1);   /* write one block 			*/	}		else																	 	/* else for tapes, do a	 	*/		start.tape.command(port#,track#, Tape.LoadUnload,1);  /* load first to clean	 	*/end handle.backup.load;													/* up the write op			*/handle.load.load:proc (port#, track#) swap;	dcl (port#, track#) fixed;		if errmess=0 then do;		call log.error('Changing Cartridges in ');		call append.tape.mes(port#);	end;	if (tape.type(port#) == type.jaz)							 	/* for jaz, go directly to */		tape.state(port#) = tape.state(port#) + 1;			 	/* ejecting...				 	*/		else																	 	/* else for tapes, do a	 	*/		start.tape.command(port#,track#, Tape.LoadUnload,1);  /* load first to clean	 	*/end handle.load.load;													/* up the write op			*/handle.backup.eject:proc (port#, track#) swap;					/* handl eject of media		*/	dcl (port#, track#) fixed;		zero.jaz.position(port#);											/* reset to BOT				*/		if (tape.type(port#) == type.jaz)							 	/* for jaz, issue stop		*/		start.tape.command(port#, track#, Tape.LoadUnload, 2);/* command with eject bit	*/	else		start.tape.command(port#, track#, Tape.LoadUnload, 0);/* else for tapes, 0			*/end handle.backup.eject;												/* does eject...				*/handle.backup.write.protect.condition:proc (port#) swap;	dcl (port#) fixed;		/* If cartridge is write protected,  wait before poling again */	/* to reduce the chance of seeing the cartridge IN for the    */	/* INQ and TEST UNIT,  but not in for the MODE SENSE          */	port.timer(port#) = real.milliseconds + 5000; /* wait 5 sec   */	port.io   (port#) = Tape.Wait;                /* enter delay state       */	tape.state(port#) = backup.begin.real.interrogation.state;    /* re-issue inquiry after delay state */	if errmess = (256\port#)      /* had been our message */	then errmess = 0;	if (errmess<>0)               /* other message waiting        */	then return;	errmess=(1024\port#);	call log.error('Cartridge is Write Protected: Try Another One - ');	call append.tape.mes(port#);end handle.backup.write.protect.condition;handle.backup.check.for.return.state:proc (port#) swap;	dcl (port#) fixed;		port.retry(port#)=0;	if tape.return.state(port#)<> 0 then do;      /* return for next tape */			/* At this point, we are in the middle of backing up	*/		/* a project to a removable media hard drive.  We		*/		/* filled the first cartridge, wrote out it's			*/		/* directory, ejected that cartridge, and the user		*/		/* has put in a new cartridge.  Initialize the			*/		/* directory of the new cartridge to be blank.  The	*/		/* new directory will be flushed to the disk at the	*/		/* end of the backup (after the 'filemark'), or 		*/		/* when this second cartridge is itself ejected...		*/		if (tape.type(port#) == type.jaz)		{			write(mam) = jaz.dir.sec# + port#;			write(mdi) = jaz.magic.#1;						/* jaz.magic.#1.loc		*/			write(mdi) = jaz.magic.#3;						/* jaz.magic.#2.loc		*/			rpc 256-2;											/* zero out rest of		*/			write(mdi) = 0;									/* jaz position			*/						if (( port.jaz.sec.msb(port#) != 0 ) 		/* position should have */			||  ( port.jaz.sec.lsb(port#) != 0 )		/* been reset to zero   */			||  ( port.jaz.fmk.inx(port#) != 0 )		/* in no cart case...   */			||  ((port.jaz.cap.msb(port#) == 0)			/* and capacity must		*/			&&   (port.jaz.cap.lsb(port#) == 0)))		/* be measured by now   */			{				if log.buf(0)<>0 then return;  			/* wait for prior msg   */				call log.error('Position error (fatal) occurred in ');				call append.tape.mes(port#);				call finish.port.command(port#);				command.fatal = 1;				return;			}						/* set the current tape position to the start of the data area    */			/* and begin writing.  E.G. reserve space for the directory			*/			/* on disk...																		*/						port.jaz.sec.lsb(port#) = jaz.directory.space;		}				tape.state       (port#) = tape.return.state(port#);		tape.return.state(port#) = 0;	end;		/* Else we are about to begin a backup.  This cart is in.   We				*/	/* wait for all carts to be in before starting the serious work...		*/		else do;		tape.state(port#) = tape.state(port#)+1;	end;end handle.backup.check.for.return.state;handle.backup.all.ready:proc (port#, track#, tport#) swapable;	dcl (port#, track#, tport#) fixed;	dcl (i,j)                   fixed;		if backup.message.code=0 then do;		/* perform check once...						*/			if log.buf(0)<>0 then return;			/* wait for message to go out					*/				/* We get at this point just once.  This happens when all of the ports			*/		/* (that are not empty) have tapes in them.  If the drives are removable		*/		/* media hard drives, we'll check at this point to see if they are all			*/		/* positioned similarly.  That should help reduce data loss if someone			*/		/* ejects and then re-inserts one cartridge in a set.									*/				/* Check synchronization of JAZ drives in multi-port backup case.  E.G. make	*/		/* if one of the jaz drives is positioned at the start, make sure they all		*/		/* are...																							*/				if (port# != max.ports)					/* check is only needed in non-aux case	*/		{			i = 0;                           /* assume no cart is at start					*/					do j = 0 to max.ports-1;			/* loop over ports								*/							/* if port is ready and is involved in this command, then see if			*/				/* it's jaz cartridge is positioned at 0											*/								if ((command.tracks&port.track.bits(j)&readybits) != 0)				{					if (tape.type(j) == type.jaz)					{						if (((port.jaz.sec.msb(j) == 0) 		/* if jaz cartridge is			*/						&&   (port.jaz.sec.lsb(j) == 0))		/* positioned at start			*/						||  ( port.jaz.fmk.inx(j) == 0 ))							i = 1;									/* then remember that fact		*/					}				}			end;						if (i != 0)									/* if one tape is at start, all should	*/			{												/* be...											*/				do j = 0 to max.ports-1;			/* loop over ports							*/					if ((command.tracks&port.track.bits(j)&readybits) != 0)					{						if (tape.type(j) == type.jaz)						{							if (((port.jaz.sec.msb(j) != 0) 		/* if jaz cartridge is not	*/							||   (port.jaz.sec.lsb(j) != 0))		/* at start, then sync		*/							||  ( port.jaz.fmk.inx(j) != 0 ))	/* error...						*/							{								call log.error('Position error; must Home drives before backup');															call finish.port.command(port#);								command.fatal = 1;								abort.command = 1;								return;							}						}					}				end;			}		}				if command.tracks=bits(track#) then do;			call log.error('Backing Up Track ');			call append.decimal.number(track#+1);		end;		else do;			call log.error('Backing Up Project "');			call append.command.song.name(command.song);			call append.log.string('"');		end;		backup.message.code = 1;	end;		/* We are about to begin the backup.  Check to see if   */	/* the drive we are using is a removable media hadr 	  */	/* drive.  If so, initialize the directory of the       */	/* hard drivce at this time.									  */		/* We do this in a way that emulates a tape drive.      */	/* If we are positioned at the front of the media, the  */	/* media is erased.  If we are positioned right after	  */	/* a file mark, we make that position as the end of	  */	/* of the tape.  If we are positioned at the end		  */	/* of the tape, then we start writing there...			  */		/* Format the Jaz media at this point if positioned     */	/* at zero.  Or truncate the jaz media at this point    */	/* if not at zero and not at end								  */		if (tape.type(port#) == type.jaz)	{		if ((port.jaz.cap.msb(port#) == 0)		/* if capacity information not available, then	*/		&&  (port.jaz.cap.lsb(port#) == 0))		/* something bombed										*/		{			if log.buf(0)<>0 then return;  		/* wait for prior msg   								*/			call log.error('Capacity error (fatal) occurred with ');			call append.tape.mes(port#);			call finish.port.command(port#);			command.fatal = 1;			return;		}				if (( port.jaz.sec.msb(port#) != 0 )	/* if current jaz position is not at start,		*/		||  ( port.jaz.sec.lsb(port#) != 0 )	/* then erase from current position onward		*/		||  ( port.jaz.fmk.inx(port#) != 0 ))	/* as tapes do...											*/		{			dcl (magic1, magic2, numfmarks, eotmsb, eotlsb, fmkmsb, fmklsb) fixed;						write(mam) = jaz.dir.sec# + port#;			magic1     = read(mdi);					/* jaz.magic.#1.loc										*/			magic2     = read(mdi);					/* jaz.magic.#2.loc										*/			numfmarks  = read(mdi);					/* jaz.num.fmarks.loc									*/			eotmsb     = read(mdi);					/* jaz.leot.msb.loc										*/			eotlsb     = read(mdi);					/* jaz.leot.lsb.loc										*/						/* Consistency check the in-core directory */						if ((magic1                  != jaz.magic.#1)		/* if in-core directory not set	*/			||  (port.jaz.fmk.inx(port#) == 0           )		/* fmrk index at 0???				*/			||  (port.jaz.fmk.inx(port#) >  numfmarks   )		/* or inx off end of list??		*/			||  (port.jaz.fmk.inx(port#) >= jaz.max.fmarks-1))	/* or not room for 1 more...		*/ /* PS: imagine 123 projects on 1 media?  Ugh! */			{				if log.buf(0)<>0 then return;  		/* wait for prior msg   							*/				call log.error('Directory error (fatal) occurred with ');				call append.tape.mes(port#);					call finish.port.command(port#);				command.fatal = 1;				return;			}						/* Position the 'tape' right after the file mark.  Note that this may not be			*/			/* the leot if there is another project after us that was continued on another		*/			/* cartridge.  That is, there is no file mark at the end of a tape if the project	*/			/* was continued on a second cartridge.															*/						write(mam) = jaz.dir.sec# + port#;			write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);			fmkmsb = read(mdi);										/* get block number of fmark we		*/			fmklsb = read(mdi);										/* positioned after						*/						fmklsb = fmklsb + 1;										/* add one to position ourselves		*/			if (fmklsb == 0) fmkmsb = fmkmsb + 1;				/* after the file mark					*/						port.jaz.sec.msb(port#) = fmkmsb;					/* set current position to be			*/			port.jaz.sec.lsb(port#) = fmklsb;					/* the sector after the file mark	*/						write(mam) = jaz.dir.sec# + port#;			write(mal) = jaz.num.fmarks.loc;			write(mdi) = port.jaz.fmk.inx(port#);				/* jaz.num.fmarks.loc					*/			write(mdi) = port.jaz.sec.msb(port#);				/* jaz.leot.msb.loc						*/			write(mdi) = port.jaz.sec.lsb(port#);				/* jaz.leot.lsb.loc						*/			write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#), 1);			do while read(mal) != 0;								/* zero out rest of old					*/				write(mdi) = 0;										/* file mark list...						*/			end;						if (inc.jaz.prints)										/* hello...									*/			{				if ((port.jaz.sec.msb(port#) == eotmsb)		/* if position same as former leot	*/				&&  (port.jaz.sec.lsb(port#) == eotlsb))					print 'Appending to JAZ ', port#;			/* then we are appending				*/				else						print 'Truncating JAZ ', port#;				/* else we truncated...					*/			}		}				else												/* else jaz is posiitoned at start.  Set up		*/		{													/* for a blank tape...									*/			write(mam) = jaz.dir.sec# + port#;			write(mdi) = jaz.magic.#1;				/* jaz.magic.#1.loc		*/			write(mdi) = jaz.magic.#2;				/* jaz.magic.#2.loc		*/			rpc 256-2;									/* zero out rest of		*/			write(mdi) = 0;							/* jaz position			*/			port.jaz.sec.lsb(port#) = jaz.directory.space;						if (inc.jaz.prints)				print 'Initializing JAZ ', port#;		}	}		/* Prepare for backup.  Lock poly here to write out the */	/* various headers.                                     */	poly.buffs.in.use        = poly.buffs.in.use       + 1;	this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;	tape.state(port#)=tape.state(port#)+1;	port.retry(port#)=0;end handle.backup.all.ready;construct.song.header:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i, j)          fixed;		/* write song header to tape */	do i=0 to 255;		misc.buf(i)=0;	end;	misc.buf(0)=9999;        /* set unique code in first 4 words */	misc.buf(1)=8888;	misc.buf(2)=7777;	if include.verify   		 /* use 5555 for tapes with verify   */	then misc.buf(3)=5555;   /* info so old software will not    */	else misc.buf(3)=6666;   /* try to read them                 */	call gsong.dir(command.song*song.len);	do i=0 to song.len-1;		misc.buf(10+i)=read(mdi);	end;	/* create list of which tracks from this port are */	/* being dumped out:                              */	i = 0;	do j = 0 to max.tracks-1;		if (command.tracks & bits(j) & port.track.bits(port#))<>0		then do;			misc.buf(100+i)=256 + j;			i = i + 1;		end;	end;	/* set verify information if desired */	if include.verify then do;		misc.buf(200) = get.stream.size(port#); /* write out stream size     */		misc.buf(201) = verify_do_len;          /* and words per checksum    */	end;	j=compute.base.adr(track#);	call psmwrite(j+buf.base,0);	do i=0 to 255;		write(psd)=misc.buf(i);	end;	do i=0 to 255;		write(psd)=alt.tdir(i);	end;	do i=512 to 4095;		write(psd)=0;	end;		tape.pmem.add         = j+buf.base;           /* set address     	*/	tape.issue.len(port#) = 16;                   /* 16 sectors      	*/			end construct.song.header;construct.song.trailer:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i, j)          fixed;		do i=0 to 255;		misc.buf(i)=0;	end;	misc.buf(0)=1111;                    /* end of song */	misc.buf(1)=2222;	misc.buf(2)=3333;	misc.buf(3)=4444;	j=compute.base.adr(track#);	call psmwrite(j+buf.base,0);	do i=0 to 255;		write(psd)=misc.buf(i);	end;	do i=256 to 4095;		write(psd)=0;	end;	tape.pmem.add         = j+buf.base;               /* set address     */	tape.issue.len(port#) = 16;                       /* 16 sectors      */end construct.song.trailer;/* Here we write a file mark to a jaz drive.  We do this by making		*//* an entry in the directory of the jaz drive.  We reserve one block		*//* for the file mark (although we ever write it) so we can					*//* do such yummy things as consecutive file marks, etc. if at some		*//* point we ever should want to...													*/write.jaz.filemark:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (msb,   lsb   ) fixed;		/* Store current tape position in file mark list */		write(mam) = jaz.dir.sec# + port#;	write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#), 1);	write(mdi) = port.jaz.sec.msb(port#);	write(mdi) = port.jaz.sec.lsb(port#);		/* Construct in-core image of what header would  */	/* look like if the write completes ok...			 */		/* that is, increment the file mark index			 */	/* and compute what the leot will be after		 */	/* reserving one (un-written!) block for			 */	/* the "file mark"										 */		msb = port.jaz.sec.msb(port#);						/* get current tape position     */	lsb = port.jaz.sec.lsb(port#);	lsb = lsb + 1;												/* skip 1 block for file mark		*/	if (lsb == 0) msb = msb + 1;			write(mam) = jaz.dir.sec# + port#;	write(mal) = jaz.num.fmarks.loc;	write(mdi) = port.jaz.fmk.inx(port#) + 1;			/* jaz.num.fmarks.loc				*/	write(mdi) = msb;											/* jaz.leot.msb.loc					*/	write(mdi) = lsb;											/* jaz.leot.msb.loc					*/	tape.issue.len (port#) = 1;	port.jaz.update(port#) = 1;							/* update by 1 for fmark			*/	tape.pmem.add = compute.base.adr(track#) + inf.base;	/* use info sector			*/	Tape.Disk.Add.Msb = 0;											/* disk block #				*/	Tape.Disk.Add.Lsb = 0;		call Copy.Ext.Mem.To.Poly(jaz.dir.sec# + port#, 0,									  tape.pmem.add, 0, 256);	start.tape.command(port#, track#, Tape.ExtendedWr, 1);   /* write one block 	   */		/* note: we will update our current tape position and increment the current		*/	/* file mark index when the write command completes successfully...					*/end write.jaz.filemark;/* Backup Song main driver */backup.song:proc(port#,track#) public swap;   dcl (port#,track#) fixed static;   dcl (tport#      ) fixed static;   dcl (i,j,k       ) fixed static;   dcl (amsb,alsb   ) fixed static; /* declare these in order!! */   dcl (bmsb,blsb   ) fixed static;   dcl (cmsb,clsb   ) fixed static;   dcl (dmsb,dlsb   ) fixed static;   dcl (emsb,elsb   ) fixed static;   dcl (secmsb      ) fixed static;   dcl (seclsb      ) fixed static;   dcl (wrd#        ) fixed static;   dcl (clen        ) fixed static;   dcl (exit        ) fixed static;   dcl (ptr         ) fixed static;   dcl (len         ) fixed static;   dcl (tmp)      (3) fixed static;   write.check.error:proc;      if port.retry(port#)<>0 then do;			handle.write.check.error.retry(port#, track#);         return 1;      end;      if tape.eof(port#)<>0 then do;    /* end of tape reached - get next */			handle.write.check.error.eof(port#);         return 1;      end;      return 0;   end write.check.error;   empty.and.done.check:Proc;      /* if all tracks on this port are empty,  sit here waiting */      /* for the user to put in a cartridge until all other      */      /* non-empty tracks have been written.  When all other     */      /* non-empty tracks have been written,  then terminate     */      /* our command if there is still no tape in the drive.     */      /* This allows someone to back up a project to one tape    */      /* of only the first few tracks are used.                  */      if port.empty(port#) = 0   /* if port is not empty, then   */      then return 0;             /* return 0 - ask for cart.     */      /* if no more tracks left to write,  then terminate        */      /* this command.                                           */      if (command.tracks&(not(emptybits)))=0 /* if all non-empty */      then do;                               /* tracks done,     */         call finish.port.command(port#);      end;      return 1;   end empty.and.done.check;	issue.jaz.write.command:proc (blen);		dcl (blen)          fixed;		dcl (len, msb, lsb) fixed;				/* This is where we do data writes to a removable media        */		/* hard drive that is emulating a backup tape.  We see how		*/		/* long the block we are writing is, and whether that will		*/		/* fit on the media.  If it does not, we eject this media		*/		/* and start writing to the next.										*/				/* We reserve 500 sectors at the end of the media for 			*/		/* writing a file mark, and a possible song header block			*/		/* for the next song.  That way, a) we can always finish			*/		/* this project (e.g. write the file mark) if the end-of-proj	*/		/* block is on this media,  and 2) the song header for a			*/		/* possible next project will always be on this media as well.	*/		/* This simplifies the 'skip' command processing, so that		*/		/* we know whether the project is contiued on another				*/		/* media or not...															*/				len = shl(blen, 4);								/* get # of sectors  */		msb = port.jaz.sec.msb(port#);				/* get cur position  */		lsb = port.jaz.sec.lsb(port#);				/* handy					*/				lsb = lsb + len;									/* add length we are	*/		if (lsb ILT len) msb = msb + 1;				/* writing				*/				lsb = lsb + jaz.eot.space;						/* add emergency		*/		if (lsb ILT jaz.eot.space) msb = msb + 1;	/* gap length			*/				if (( msb IGT port.jaz.cap.msb(port#) )	/* if data won't		*/		||  ((msb ==  port.jaz.cap.msb(port#))		/* fit on cart, set	*/		&&   (lsb IGT port.jaz.cap.lsb(port#))))	/* up to eject cart	*/			handle.write.check.error.eof(port#);	/* and get next		*/				else		{			Tape.Disk.Add.Msb      = port.jaz.sec.msb(port#);			Tape.Disk.Add.Lsb      = port.jaz.sec.lsb(port#);			port.jaz.update(port#) = len;			start.tape.command(port#, track#, Tape.ExtendedWr, len);		}	end issue.jaz.write.command;   /* $page - start of backup song/backup track */   tport# = track.port.ix(track#); /* get track port in case using AUX  */   if  (port.io(tport#)  <> 0)     /* make sure this port is free       */   and (interrogate.tapes = 0)     /* once the interrogation phase      */   then return;                    /* is through.                       */   zap.buffer(track#) = 1;         /* zap buffer next time we play 		*/   /* process tape: */   do case tape.state(port#);      /* state 0 - beginning of operation */      /* initialize variables.  Jump ahead to state 4.  States 1 and 2      */      /* are used to change cartridges.                                     *//* 0. */		do;                            /* start of backup for this port/track */			init.for.backup.song(port#);      end;      /* State 1:  re-enter here on changing cartridges.  Issue eject *//* 1. */      do;   /* first issue load to handle of patriot bugs */         if check.tape.ready(port#, track#) <> 0         then return;						handle.backup.load(port#, track#);      end;/* 2. */      do;         if check.tape.ready(port#, track#) <> 0         then return;			handle.backup.eject(port#, track#);      end;      /* Done with eject: reinitialize variables and wait for next */      /* cartridge.                                                *//* 3. */      do;         port.count (port#) = 0;         tape.state (port#) = backup.begin.real.interrogation.state;      end;      /* State 4: normal start of backup             */      /* Begin by waiting for alt tdir,  then see if */      /* all the tracks on this port are             */      /* empty.                                      *//* 4. */		do;         if check.tape.ready(port#, track#) <> 0	/* check for user abort or		 */         then return;										/* retry count exceeded			 */         if alt.tdir.valid=0         /* wait here for the track directory for the */         then return;					 /* project we are backing up to be available */         /* look up empty tracks - set bits in I for every empty track: */         i = 0;         do j = 0 to max.tracks-1;            if alt.tdir(j*track.len+track.used) = 0            then i = i \ bits(j);         end;         /* compute which tracks accessed by this port are empty: */         i         = (i & command.tracks & port.track.bits(port#));         emptybits = emptybits \ i;         /* mark the port as being empty if all tracks used       */         /* by this port for this command are empty.              */         if i = (port.track.bits(port#) & command.tracks)         then port.empty(port#) = 1;         tape.state(port#) = tape.state(port#) + 1;      end;      /* Tape Interrogation phase - The following 3 states are executed */      /* to determine which specific tape drive to use for the command. */		/* This software supports 4 backup configuration: AUX port		   */		/* target 1, AUX port target 2, plus dedicated port target 1		*/		/* plus dedicated port target 2.												*/				/* We poll all 4 places to see if there is a drive with a cart		*/		/* ready to go therein.  If so, we use that configuration			*/		/* for the backup.																*/				/* Note that we breeze through the next 3 states if					*/		/* interrogate.tapes == 0 (e.g. if we did not find any				*/		/* second tape drive to check!)												*//*5*/ do;         /* Check for abort,  error (no tape drive), end of interrogation */         if check.interrogation.condition(port#) <> 0         then return;         call issue.inquiry(port#, track#);      end;/*6*/ do;         /* Check for abort,  error (no tape drive), end of interrogation */         if check.interrogation.condition(port#) <> 0         then return;         call issue.test.unit.ready(port#,track#);      end;/*7*/ do;         call check.interrogation.result(port#);      end;      /* Now we have selected the type of tape to back up to.          */      /* Issue inquiry to find tape tape, plus get ready info for fuji */				/* At this point, we have interrogated the tape and found		  */		/* a drive or a set of drives with a cartridge in it.				  */		/* Based upon the interrogation we did, we selected a particular */		/* drive or set of drives to back up to.  Now repeat the			  */		/* interrogation to make sure the selected set is ready.			  *//*8*/ do;			backup.begin.real.interrogation.state = tape.state(port#);         tape.condition(port#) = 0; /* clear all condition bits for tape1 & tape2 */         tape.to.use   (port#) = tapetouse; /* select tape1 VS tape2   */         call issue.inquiry(port#, track#);      end;      /* Issue test unit ready to check ready info for cdc, wang       *//*9*/ do;          call issue.test.unit.ready(port#, track#);      end;      /* Issue mode sense to get WP bit                                *//*10*/do;         call issue.mode.sense(port#, track#);      end;      /* Examine tape.condition to determine cartridge status          *//*11*/do;         if check.tape.ready(port#, track#) <> 0         then return;         if (tape.condition(port#) & (t1.cond.rdy\t2.cond.rdy)) = 0 /* no cartridge in drive */         then do;            tape.remove(port#) = 0;      /* tape has been removed        */            port.retry (port#) = 0;      /* reset retry count            */            port.count (port#) = 0;      /* double check new cart        */            port.timer (port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */            port.io    (port#) = Tape.Wait;            tape.state (port#) = backup.begin.real.interrogation.state; /* re-issue inq    */            if empty.and.done.check<>0    /* if port is empty, no error   */            then return;                  /* if no cartridge in drive     */				handle.backup.song.no.cart.case(port#);             return;         end;         /* Ok - this cartridge is in the drive */         onetapeloaded = 1;         /* See if we need to remove it because we need the next cart: */         if tape.remove (port#)<>0        /* must remove tape for second one */         then do;				handle.backup.song.cart.remove.case(port#);             return;         end;         /* OK - Cartridge is in.                                */         /* go to next state.  Issue mode select and then double */         /* check the write protect.  Need to do this because    */         /* WANGDATS don't know about the write protect until    */         /* after the mode select is done.                       */         /* If we had asked for a cartridge, say thank you.      */			handle.backup.song.cart.in.case(port#);       end;      /* Issue mode select to make sure tape is in proper mode always */		/* Also get media capacity of JAZ drive at this point				 *//*12*/do;                            /* mode select */			if (tape.type(port#) == type.jaz)				issue.read.capacity(port#, track#);   		else				issue.mode.select(port#,track#);      end;/*13*/do;      /* wait for 1/4 second for write protect to become valid */         tape.state(port#) = tape.state(port#) + 1;         if port.count(port#) = 0         then do;            port.timer(port#) = real.milliseconds + 250; /* wait 1/4 sec  */            port.io   (port#) = Tape.Wait;               /* enter delay state       */         end;      end;/*14*/do;         /* OK - Cartridge is in.                                */         /* perform a second check in case cartrdige was in      */         /* for the INQ but was removed for the TUN              */         if port.count(port#)=0 then do;            port.count(port#) = port.count(port#) + 1;            tape.state(port#) = backup.begin.real.interrogation.state;    /* do another inq/sense command in case cartdridge was inserted for sense but was not in for inq */            return;         end;         if (tape.condition(port#) & (t1.cond.wp\t2.cond.wp)) <> 0 /* cart is write protected */         then do;				handle.backup.write.protect.condition(port#);            return;         end;         port.retry  (port# )=0;             /* reset error count */         tape.state  (port#) = tape.state(port#) + 1;      end;      /* A non-write-protected cartridge is in.  Return to backup state if we */		/* are writing a second cartridge.													*/      do;                               /* reset retry count at start of backup */			handle.backup.check.for.return.state(port#);      end;      do;   /* wait for all tapes to be loaded */			if abort.check(track#)<>0			then return;         if (command.tracks&(not(readybits))&(not(emptybits)))=0         then do;  /* all command tracks either ready or empty */            handle.backup.all.ready(port#, track#, tport#);         end;         else do;            /* Mark which tracks are ready.  All tracks that use */            /* this port are ready for loading.  Works neatly    */            /* when using AUX tape:                              */            readybits = readybits \ port.track.bits(port#);         end;						/* and hope nobody removes a cartridge at this point!!! */      end;      /* $page - begin backup by writing song header */      do;   /* locked */                   /* begin backup */         /* See if we are trying an illegal operation (IE writing */         /* to a tanberg tape at other than the start or the end  */         /* of the tape:                                          */         if tape.write.code(port#) <> 0         then do;            if log.buf(0)<>0 then return;  /* wait for prior message */            call log.error('Must reposition cartridge to perform backup in ');            call append.tape.mes(port#);            call finish.port.command(port#);            command.fatal = 1;            return;         end;         if write.check.error<>0 then return;			if (tape.type(port#) == type.jaz)				/* if jaz drive		*/				verify_do_len = 5;								/* skip verify			*/			else				verify_do_len = verify.len;			construct.song.header(port#, track#);			/* Write the song header to tape.  If we are writing to a 			*/			/* removable media hard drive, we know there is room for				*/			/* the header.  In otherwords, skip the end-of-media check			*/			/* for writing the song header.  This way, it will be					*/			/* possible to detect the proper end of the media in all cases		*/			/* whilst loading...																*/						if (tape.type(port#) == type.jaz)				/* if jaz drive		*/			{				Tape.Disk.Add.Msb      = port.jaz.sec.msb(port#);				Tape.Disk.Add.Lsb      = port.jaz.sec.lsb(port#);				port.jaz.update(port#) = 16;					start.tape.command(port#, track#, Tape.ExtendedWr, 16);			}         else				start.tape.command(port#,track#,Tape.Write,1);   	/* write one block */      end;      /* Unlock from song header write to give audio a chance to play */      do;   /* locked */         poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         tape.state(port#)=tape.state(port#)+1;      end;      do;     /* unlocked */         backup.begin.backup.of.track.state = tape.state(port#);     /* return here for second track */         tape.data.msb(port#)=c.data.msb;         tape.data.lsb(port#)=c.data.lsb;         tape.len.msb (port#)=c.len.msb;         tape.len.lsb (port#)=c.len.lsb;         port.cue.ix  (port#)=1;         tape.state   (port#)=tape.state(port#)+1;         poly.buffs.in.use        = poly.buffs.in.use       + 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;      end;      /* $page - write cue directory out to tape for this track *//*0*/ do;     /* locked */         wrd# = 100;    /* store cue data beginning at word 100 of */         exit = 0;      /* the 4k word block.  clear exit flag     */         i=compute.base.adr(track#)+buf.base;         /* loop cues in list until exit condition is met */         do while exit = 0;            if (port.cue.ix(port#) igt num.of.alloc)      /* see if done    */            then exit = 1;                                /* with cue list  */            else do;                                      /* check cue      */               if   (lookup.cur.cue(port.cue.ix(port#)))     /* get basic cue and set up cue.sec#, cue.wrd  */               and  (cue.is.in.command.song(current.cue))    /* if this cue is in our song              */               and  (Or.Cue.Track.Bits(cue.sec# + cue.sec, cue.wrd, tmp))  /* and track bits avail      */               and  ((tmp(0) & bits(track#)) <> 0)           /* and cue contains info from this track   */               then do;                                      /* then write this cue info to disk        */                  call read.store(cue.sec# + cue.sec, cue.wrd);                  clen = read(md);                           /* get total cue length */                  if wrd# + clen igt 4096                    /* stop scan when block limit reached */                  then exit = 1;                  else do;                                   /* store in buffer */                     /* Copy entire cue to ccue.xmsec# so we can modify it */                     /* to reflect just the track in question              */                     call Move.Store(cue.sec# + cue.sec, cue.wrd, /* move entire cue */                                     ccue.xmsec#, 0, 0, clen);    /* to ccue.xmsec#  */                                     write(mam) = ccue.xmsec#;                     write(mal) = cue.trks;                     write(md)  = read(md) & bits(track#);   /* only this trk (if set)  */                                          /* compute sample # with respect to current song */                     local.fix:proc(x,code);                        dcl x    fixed;                        dcl code fixed;                        dcl a(1) fixed;                        call READ32(ccue.xmsec#,x,a);                        if (a(0) <> (-1))  /* if not -1, -1           */                        or (code  = ( 0))  /* or not an end time      */                        then do;           /* then adjust             */                           /* generate some negative numbers here for material that */                           /* is before the start of the current project.  this     */                           /* will be detected when the cue is reloaded             */                           call SUB32(a,C.Data.S#,a);                        end;                        call WRITE32(ccue.xmsec#,x,a);                     end;                     /* see if is a reel */                     write(mam) = ccue.xmsec#;                     write(mal) = Cue.List.Ptr;                     ptr = read(mdi);                     len = read(mdi);                     /* always adjust cue.in.s#.msb since it is in */                     /* the current project                        */                     call local.fix(cue.in.s#.msb, 0);                     /* if not a reel, then adjust in times relative */                     /* to current project                           */                     if ptr = 0 then do;                        call local.fix(cue.s.msb,0);       /* store data addresses */                        call local.fix(cue.e.msb,0);       /* relative to start    */                        call local.fix(cue.edit.in.msb,0); /* of song              */                        call local.fix(cue.edit.out.msb,0);                        call local.fix(cue.off.msb,0);                        call local.fix(event.in.s#.msb,0);                     end;                     /* if a reel - just adjust mapping */                     else do;                        do j = ptr to ptr + len - 1  by Cue.Seg.Stride;                           call local.fix(j + S#In.Msb  ,0);                           call local.fix(j + S#Out.Msb ,1);                           /* leave the original segment track bits in */                           /* place.   These will be corrected during  */                           /* the project load.                        */                        end;                     end;                     call Copy.Ext.Mem.To.Poly(ccue.xmsec#, 0,                                               i, wrd#, clen);                     wrd#=wrd# + clen;                     port.cue.ix(port#) = port.cue.ix(port#) + 1;                  end;               end;               else port.cue.ix(port#) = port.cue.ix(port#) + 1;            end;         end;         if (wrd#<>100)         then do;            do j=0 to 99;               misc.buf(j)=0;            end;            misc.buf(0)=7777;        /* set this code if block   */            misc.buf(1)=6666;        /* contains cue definitions */            misc.buf(2)=5555;            misc.buf(3)=4444;            misc.buf(4)=256+track#;  /* and which track they came from */            misc.buf(5)=wrd#;        /* # of words of cue data         */            call psmwrite(i,0);            call poly.out(addr(misc.buf(0)),100);            tape.state   (port#)=tape.state(port#)+1; /* issue write command next time around */         end;         else do;            tape.state   (port#)=tape.state(port#)+3; /* else no write needed - now write block header */            poly.buffs.in.use        = poly.buffs.in.use       - 1;            this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         end;      end;/*1*/ do;  /* locked */  /* write out cue definition */         if write.check.error<>0 then return;         j=compute.base.adr(track#);         tape.pmem.add         = j+buf.base;               /* set address       */         tape.issue.len(port#) = 16;                       /* 16 sectors        */						if (tape.type(port#) == type.jaz)					  /* if jaz drive		  */				issue.jaz.write.command(1);			     		  /* then check eot	  */         else        		start.tape.command(port#,track#,Tape.Write,1); /* 1 4096 word block */      end;/*2*/ do;   /* locked */ /* check for more cue definitions to write */         tape.state(port#)=tape.state(port#)-2;      end;      /* $page - compute length of block to be written *//*3*//*0*/ do;   /* unlocked */          /* compute physical sectors to be written */         adir.ptr(track#)=track#*adir.len;   /* reset every block */         next.adir:;         secmsb=tape.data.msb(port#);  /* disk sector to read    */         seclsb=tape.data.lsb(port#);         emsb  =tape.len.msb (port#);  /* number of sectors to   */         elsb  =tape.len.lsb (port#);  /* back up                */         i=adir.ptr(track#);           /* pt to alloc direct     */         call gadir(i);         write("313")=addr(amsb);      /* read in amsb,alsb      */         rpc 4;                        /* bmsb,blsb              */         write("373")=read(mdi);         if (amsb\alsb)=0              /* means end of active    */         then do;                      /* track has been reached */            adir.ptr(track#)=track#*adir.len;       /* reset to start */            tape.state(port#)=tape.state(port#)+7;  /* end of song    */            return;                    /* catch next time        */         end;         if ((secmsb igt bmsb))        /* if sector is > current */         or ((secmsb  =  bmsb)         /* block,  then must be   */         and (seclsb ige blsb))        /* in next or is off end  */         then do;            adir.ptr(track#)=adir.ptr(track#)+4;            goto next.adir;         end;         if  ((secmsb ilt amsb))       /* sector is before       */         or  ((secmsb  =  amsb)        /* this block (unused)    */         and  (seclsb ilt alsb))         then do;            cmsb=amsb-secmsb;          /* compute # of secs from      */            clsb=alsb-seclsb;          /* secmsb,lsb to amsb,lsb      */            if alsb ilt seclsb then cmsb=cmsb-1;            if ((cmsb igt emsb))       /* gap is >= length left to    */            or ((cmsb  =  emsb)        /* write - means done with     */            and (clsb ige elsb))       /* this track                  */            then do;               adir.ptr  (track#)=track#*adir.len;       /* reset to start */               tape.state(port#)=tape.state(port#)+7;               return;                 /* done                        */            end;            tape.data.msb(port#)=amsb; /* jump to beginning of block */            tape.data.lsb(port#)=alsb; /* since block was all zeroes */            secmsb              =amsb; /* also for command           */            seclsb              =alsb;            if elsb ilt clsb then emsb=emsb-1;   /* reduce length    */            emsb=emsb-cmsb;                      /* left to write    */            elsb=elsb-clsb;            tape.len.msb (port#)=emsb;            tape.len.lsb (port#)=elsb;         end;         cmsb=bmsb-secmsb;          /* compute # of secs from      */         clsb=blsb-seclsb;          /* secmsb,lsb to bmsb,lsb      */         if blsb ilt seclsb then cmsb=cmsb-1;         if ((cmsb ilt emsb))       /* limit write length to this  */         or ((cmsb  =  emsb)         and (clsb ilt elsb))         then do;            emsb=cmsb;            elsb=clsb;         end;         tape.copy.len.msb(port#) = emsb;         tape.copy.len.lsb(port#) = elsb;         tape.read.len    (port#) = 0;         poly.buffs.in.use         = poly.buffs.in.use       + 1;         this.buf.in.use  (tport#) = this.buf.in.use(tport#) + 1;         tape.state       (port#) = tape.state(port#)+1;         port.retry       (port#) = 0;         adir.ptr         (track#)= track#*adir.len;             end;      /* $page - write block header to tape *//*1*/ do; /* locked */   /* write block header to tape */         if write.check.error<>0 then return;         /* write block header to tape */         do i=0 to 255;            misc.buf(i)=0;         end;         misc.buf(0)=5555;         misc.buf(1)=4444;         misc.buf(2)=3333;         misc.buf(3)=2222;         misc.buf(4)=256+track#;                    i=tape.data.msb (port#)-c.data.msb;    /* get distance in sectors */         j=tape.data.lsb (port#)-c.data.lsb;    /* from song start         */         if tape.data.lsb(port#) ilt c.data.lsb         then i=i-1;                            /* bug                     */         misc.buf(10)=i;         misc.buf(11)=j;         misc.buf(12)=tape.copy.len.msb(port#);         misc.buf(13)=tape.copy.len.lsb(port#);         j=compute.base.adr(track#);         call psmwrite(j+buf.base,0);         do i=0 to 255;            write(psd)=misc.buf(i);         end;         do i=256 to 4095 by 256;            rpc 256;            write(psd)=0;         end;         tape.pmem.add         = j+buf.base;               /* set address     */         tape.issue.len(port#) = 16;                       /* 16 sectors      */			if (tape.type(port#) == type.jaz)					  /* if jaz drive		  */				issue.jaz.write.command(1);			     		  /* then check eot	  */         else         	start.tape.command(port#,track#,Tape.Write,1); /* write one block */      end;      /* $page - read disk to perform copy *//*2*/ do;   /* unlock after writing header */         poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         tape.state      (port# ) = tape.state     (port# ) + 1;      end;/*3*/ do; /* unlocked */   /* first - lock out poly memory from FUNC reading */         poly.buffs.in.use        = poly.buffs.in.use       + 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;         tape.state      (port# ) = tape.state     (port# ) + 1;      end;/*4*/ do;             /* read disk to perform copy */         if write.check.error<>0 then return;         i=get.stream.size(port#) - tape.read.len(port#);  /* read correct block size for streaming */         if include.verify		/* if we should include verify data,  */         then i = i - 1;      /* then read 1 less sector from disk  */                              /* to make room for the verify info   */         if  (tape.copy.len.msb(port#)=0) /* buf if finishing up this block        */         and (tape.copy.len.lsb(port#) ilt i)         then i=tape.copy.len.lsb(port#);         if i=0 then do;                   /* all read in         */            /* compute check sum info if desired                  */            if include.verify then do;     /* compute check sum   */               do j = 0 to tape.read.len(port#) - 1;                  call psmread(compute.base.adr(track#)+buf.base+j,0);                  write("303") = 0;        /* im(0) to r3         */                  rpc verify_do_len;                  write("213") = read(psd);/* D(157) to ADD3      */                  k = read("303");                  misc.buf(j) = k;               end;               call psmwrite(compute.base.adr(track#)+buf.base+tape.read.len(port#),0);               call poly.out(addr(misc.buf(0)), tape.read.len(port#));               rpc 256-tape.read.len(port#);               write(psd) = 0; /* zero fill rest of sector to simplify later changes */               tape.read.len(port#) = tape.read.len(port#) + 1; /* add one block to reflect verify info */            end;            port.retry    (port#)=0;            tape.buf.len  (port#)=0;            tape.state    (port#)=tape.state(port#)+1;         end;         else do;            secmsb = tape.data.msb(port#);        /* sector within this song */            seclsb = tape.data.lsb(port#);            /* Issue command to read data from disk for this track.    */            /* Must use tport# here (the actual port for this track)   */            /* because port# may actually point to the AUX tape.       */            port.io        (tport#) = 2;        /* read desired        */            port.io.track# (tport#) = track#;   /* this track #        */            port.io.dtrack#(tport#) = track#;   /* this track #        */            port.io.len#   (tport#) = i;        /* for this len        */            port.secmsb    (tport#) = secmsb;            port.seclsb    (tport#) = seclsb;            port.pmemsec   (tport#) = compute.base.adr(track#)+buf.base+tape.read.len(port#);            port.pmemwrd   (tport#) = 0;            port.update    (tport#) = 2;                    port.upcode    (tport#) = port#;     /* update info           */            call issue.port.command(tport#,0);            if port.io(tport#)<>2 then do;        /* could not start command */               port.retry(port#)=port.retry(port#)+1;            end;            else if port# <> tport#           /* park this port on hold  */            then do;                          /* until the disk command  */               port.io   (port#) = Tape.Park; /* is completed.           */               port.timer(port#) = tport#;            end;         end;      end;/*5*/ do; /* locked */   /* now write data to tape */         nextcommand:;         if write.check.error<>0 then return;         tape.issue.len(port#)= tape.read.len(port#)   /* write out user data */                              - tape.buf.len(port#);   /* plus verify info    */			if (tape.type(port#) != type.jaz)				 /* if not jaz				*/			{				if (tape.issue.len(port#) igt 16)   		/* limit to 16 sectors  */				then tape.issue.len(port#) = 16;   			/* if not jaz           */			}			         i=shr(tape.issue.len(port#)+15,4);  /* 4096 WORD blocks, round up */         j=compute.base.adr(track#);         tape.pmem.add=j+buf.base+tape.buf.len(port#);			if (tape.type(port#) == type.jaz)					  /* if jaz drive		  */				issue.jaz.write.command(i);			           /* then check eot	  */         else         	start.tape.command(port#,track#,Tape.Write,i);      end;      /* $page - tape was successfully written to *//*6*/ do; /* locked */ /* data was written to tape */         tape.buf.len(port#) = tape.buf.len(port#)+tape.issue.len(port#);         if tape.read.len(port#) <> tape.buf.len(port#)         then do;     /* must write some  more - must be variable length */            tape.state(port#)=tape.state(port#)-1;            goto nextcommand;       /* try to stream by issuing command now */         end;         /* done                     */                  poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         /* see if more to copy */         if (tape.copy.len.msb(port#)<>0)         /* more sectors to */         or (tape.copy.len.lsb(port#)<>0)         /* copy in this    */         then do;                                 /* block           */            tape.read.len    (port#)=0;            tape.state(port#)=tape.state(port#)-3;            port.retry       (port#)=0;            return;         end;         if (tape.len.msb (port#)<>0)             /* more blocks     */         or (tape.len.lsb (port#)<>0)             /* to copy in      */         then do;                                 /* this song       */            tape.state(port#)=tape.state(port#)-6;            return;         end;         port.retry(port#)=0;                     /* write trailer    */         tape.state(port#)=tape.state(port#)+1;      end;/*7*/ do; /* unlocked */                 /* See if we need to dump more tracks from this port: */         if (command.tracks & port.track.bits(port#) & (not(bits(track#))))<>0         then do;            call finish.command(track#);         							/* record track 0 finished */            dumpedbits=dumpedbits\bits(track#);  							/* this track written out */            tape.state(port#)=backup.begin.backup.of.track.state;    /* write more blocks */            return;                              							/* wait for trk 0    */         end;         /* else done with all tracks for this port */         tape.state(port#)=tape.state(port#)+1;         port.retry(port#)=0;      end;      /* $page - trailing block and file mark */      do;   /* unlocked */ /* lock out poly for trailer write */         poly.buffs.in.use        = poly.buffs.in.use       + 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;         tape.state      (port# ) = tape.state     (port# ) + 1;      end;      do;  /* locked */      /* write trailing block */         if write.check.error<>0 then return;						construct.song.trailer(port#, track#);			/* if the song header was written in the emergency gap area, here's where */			/* we eject the media and write the block on the next media...				  */						if (tape.type(port#) == type.jaz)					  /* if jaz drive		  */				issue.jaz.write.command(1);			           /* then check eot	  */         else        		start.tape.command(port#,track#,Tape.Write,1); /* write one block */      end;      do;   /* locked */    /* write file mark at eof              */         if write.check.error<>0 then return;			if (tape.type(port#) == type.jaz)				write.jaz.filemark(port#, track#);			else         	start.tape.command(port#,track#,Tape.WriteFile,1);  /* write 1 file mark */      end;      do;  /* locked */      /* space to get out of write mode */			/* for jaz drives, increment file mark index if the directory was	*/			/* successfully written to disk.  The current position was			*/			/* incremented as the write command completed (see which).			*/						if (tape.type(port#) == type.jaz)				port.jaz.fmk.inx(port#) = port.jaz.fmk.inx(port#) + 1;         			if tape.type(port#)<>type.epi then do;    /* not epi: skip the space to leot */            tape.state(port#)=tape.state(port#)+1;            return;         end;         if port.retry(port#)<>0 then do;          /* non-fatal error */            tape.state(port#)=tape.state(port#)+1;            return;         end;         start.tape.command(port#,track#,Tape.Space,0);  /* space to leot (epi only) */      end;      do;    /* locked */ /* backup of this track pair completed */         poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         call finish.command       (track#);         dumpedbits=dumpedbits\bits(track#);   /* this track written out */         if  ((track.avail.bits & (not(emptybits)) & (not(dumpedbits))) = 0)         and ((command.fatal                      ) = 0         )         then do;                              /* all song was dumped      */            i=gsong.dir(command.song*song.len+song.modified);            if (i&1)<>0 then do;               /* song had been modified   */               write(md)=i xor 1;               song.dir.updated=1;               if screen=1 then send.screen.info=1;             end;         end;      end;   end;end backup.song;