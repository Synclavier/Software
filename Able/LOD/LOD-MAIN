/* LOD-MAIN   $TITLE  Main Code for Live Overdub   Modified:   02/12/94 - pf  - look for synclav id6 set during selection phase   09/26/91 - cj  - send final scrub position after triggering   09/24/91 - cj  - enabled monitoring whenever DDSAD available   08/14/91 - cj  - looked up creg_avail from options word   03/07/91 - cj  - added prints for D130 recognition   06/14/90 - cj  - fixed bug to keep monitoring off while doing tape                    commands to avoid crashing bug   02/12/90 - cj  - called Process.Debug.Character instead of inserting loddebug   07/26/88 - MWH - Add DSP interface   02/29/88 - MWH - Split; LOD1 is too big!   *//* initialization */dcl (i,j)         fixed;dcl (syn.avail)   fixed;dcl (atmp)  (1)   fixed;dcl (id)          fixed;dcl (time.loop)     fixed;dcl (loop.time)     fixed;dcl (max.time )     fixed;dcl (tot.time ) (1) fixed;dcl (tot.loops)     fixed;/* original code: creg_avail = dsp_present;  look up from options word */print 'DTD Running - ',string(version),;if creg_avail <> 0 then do;   print '/DSP Option',;end;print;print;examount = poll.for.external.memory;      /* see how much ext memory avail *//* see if syncl d24 available */write(ScsiSel) = S$SelectEnable \ Scsibits (syn.d24.#);  if (read(ScsiSel) & Scsibits(syn.d24.#))=0 then do;      /* board does not exist */   print 'No D24!!!.';end;else syn.avail=1;samp.speed    = 1000;         /* default speed = 1.000           */current.rate  =  500;         /* 50 khz for now                  */Sync.Mode     =    1;         /* default to syncl sync up        */Dig.Xfer.Mode = Dig.Off;      /* default to dig.xfer.mode off    *//* measure d16: */disable;                      /* just to be sure ...             */i=0; j=0;                     /* set memory pointers             */write(3)=0; write(3)=0; write(3)=0;i=read(d16); write(3)=0; j=read(d16);d16tim=(j-i+2)/5;             /* compute d16 increments per msec.  round *//* check for warm/cold boot: */if core(magic.loc)<>12345 then do;   /* cold boot */   core(magic.loc)=12345;   core(rmsec.loc)=    0;            /* keep track of how long power has been on */   core(maxms.loc)=    0;end;real.milliseconds= core(rmsec.loc);loop.time        = read(d16);timeout.point    = real.milliseconds+10000;our.time.lsb     = read(d16);        /* initialize d16 timer */enable;if examount < (cue.sec# + 100)then call log.error('Error: Direct-to-Disk Needs More Memory');else do;   Initialize=1;      /* allow cue storage all the way up to examount: */   max.store.secs = examount;end;max.trax.enabled = allow.max.trax;  /* pass down to talk routine *//* $Page - main loop for Live Overdub */do while 1;                 /* main program loop                   */   /* keep track of  how long power has been on */   i=real.milliseconds;   core(rmsec.loc)=i;   if i igt core(maxms.loc) then core(maxms.loc)=i;   /* check for basic initialization */   if  (Initialize       <> 0)   and (Swap.Info.Loaded <> 0)   then call perform.initialization(version);   /* check for synclav message */   /* disable here to guarantee quick response from seeing sel & data6 */   /* to generating busy (see abort.scsi in syncl prog)                */   new.armd.tracks = 0;        /* initialize to no new armed tracks */   more:   if syn.avail<>0 then do;      disable;      write(ScsiSel) = S$SelectEnable \ Scsibits (syn.d24.#);  /* select this d24 */      write(ScsiBus) = 0;             /* clear all lines */      write(ScsiData) = 0;      id = bits(lod.target.#);      	  if  ((read(ScsiBus )&(S$SEL\S$BSY\S$I.O))=(S$SEL))       /* we are being selected */      and ((read(ScsiData)&id)<>0)      then do;          if  ((read(ScsiBus )&(S$SEL\S$BSY\S$I.O))=(S$SEL))    /* still selected */         and ((read(ScsiData)&id)<>0)         then do;			// Detect selection by Synclav            if ((read(ScsiData)&S$DataMask) = (bits(syn.target.#)\bits(lod.target.#)))            then do;               write(ScsiBus)=S$BSY;                    /* assert bsy   */               call process.synclav.msg;                /* now read msg */            end;						// Detect selection by Mac            else if ((read(ScsiData)&S$DataMask) = ("H80"\bits(lod.target.#)))            then do;               write(ScsiBus)=S$BSY;                    /* assert bsy   */               call process.scsi.msg;                   /* now read msg */            end;         end;      end;      enable;   end;   if ((scsi.comm.prt&256) <> 0) then do;      if (log.buf(0) = 0)      and (port.io(scsi.comm.prt&255)=0)      then do;         tptr = ((scsi.comm.prt&255)*tracks.per.port) * total.stride;         write(mam)=xfer.buf.sec#;         if (scsi.comm.len igt 32768) then scsi.comm.len = 32768;         if (scsi.comm.io = 1) then do;   /* lod to initiator */            call readdata(scsi.comm.msb,scsi.comm.lsb,loc(0),scsi.comm.len);         end;         else do;            call writedata(scsi.comm.msb,scsi.comm.lsb,loc(0),scsi.comm.len,1);         end;         scsi.comm.prt = scsi.comm.prt & 255;      end;      else do;         print 'ioio';      end;   end;   if scsi.in.msg<>0 then do;          /* digest any synclavier message */      call digest.synclav.message;     /* to which we could not respond */   end;                                /* immediately                   */   /* $page - check for new sequencer motion */   /* Check state variables for new sequencer motions */   /* including Play, Record, Punch In, Punch Out     */   /* Check for Synclavier Timeout: */   if  (real.milliseconds >= timeout.point)   then do;                              /* no info for 10 seconds   */      print 'DTD Timeout',character(13),;      call Clear.Motion.Controls;        /* zap any motion           */      timeout.point=real.milliseconds+10000;      get.new.motion=get.new.motion \ 1;         /* get.new.motion when we next hear from him */   end;                                     /* Check for Exit desired:       */   if break.me<>0 then do;                      /* break: exit gracefully   */      call Clear.Motion.Controls;               /* zap any motion           */   end;   if (func<>0) then loop = 0;          /* give top priority to function reading */   if (loop<>0) or (func<>0) then do;   /* if looping (point) output is */      play = 0; trig = 0; recd    = 0;  /* desired, then stop all       */      pnch = 0; move = 0;               /* other output. same with      */      call clear.armed.info;            /* function reading             */   end;   monitor = 0;                         /* assume no monitor neeeded    */   if  (play          =  0)             /* if no play/trig/loop/func    */   and (trig          =  0)             /* is desired,  then monitor    */   and (loop          =  0)             /* ddt/bounce inputs            */   and (func          =  0)   and (command.#     =  0)   then do;      if (((Dig.Xfer.Mode & (Dig.Bounce              )) <> 0)) /* if bouncing   */      or (((Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Dspin)) <> 0)  /* or dig xfer   */      and (DDT.Good.Word.Clk                            >= 0)) /* possible clk  */      or (((Dig.Xfer.Mode & (Dig.Off)                 ) <> 0)  /* or no dig xfr */      and (creg_avail                                   <> 0)) /* but DDSAD     */      then monitor       =  1;   end;   /* Check for turning off the multi-track DDT units.                  */   if Stop.DDT.Units <> 0   then do;      call Terminate.DDT.Output;   end;   /* check for new song called up  */   if  (new.dtd.song#  <>0)          /* new song info to look    */   and (subsystem.ready<>0)          /* subsystem ready          */   then do;      call Clear.Motion.Controls;    /* zap any motion           */      call look.up.new.song.info;   end;   /* check for new input routing */   if  (new.inputs        <>0)               /* new inputs desired     */   and (subsystem.ready   <>0)               /* and poly is ready      */   and (track.dir.valid   <>0)               /* and we read track dir  */   and (New.DTD.Song#     = 0)               /* no new song pending    */   then begin;      recd        = 0;                       /* keep recording off     */      pnch        = 0;                       /* until all input        */      monitor     = 0;                       /* and no monitoring      */      Lod.Recd.Tracks     = 0;      Lod.Punch.In.Tracks = 0;      call clear.armed.info;              recrec.is.stacked = 0;            call setup.new.input.routes;   end;                               /* check for load/backup command desired or in process: */   if  (command.#=0)             /* no command being done now */   then do;      if  (command.in      <> command.out)  /* see if one has been enterred on the stack */      and (subsystem.ready <> 0          )  /* but check for erase all completion        */      and (Any.Track.Actually.Recording=0)  /* wait for recording to finish              */      then do;         call get.next.command;      end;   end;   else if (command.completed<>0)    /* command is happening - see if it is completed yet */   then do;      call check.for.command.end;   end;   else if (delay.command <> 0)   and     ((real.milliseconds - delay.command.time) IGT 3000)   then delay.command = 0;   /* check for real time toggles of safe */   /* ready tracks:                       */   if new.armd.tracks <> 0           /* check for real time changes in */   then do;                          /* safe/ready                     */      if recrec.is.stacked <> 0      /* record cue is waiting to be    */      then do;                       /* processed                      */         stackedrecrec(recrec.tracks) = stackedrecrec(recrec.tracks) xor new.armd.tracks;      end;      if (armed<>0) then do;         recrec(recrec.tracks) = recrec(recrec.tracks) xor new.armd.tracks;      end;      /* leave new.armd.tracks set for check below */   end;   /* look up tracks for armed recording: */   if (armed<>0)    then armd.tracks = recrec(recrec.tracks);   else armd.tracks = 0;   /* disable play and record on tracks */   /* doing load or backup:             */   if  (command.# <> 0)                  /* command active       */   then do;                              /* turn off busy tracks */      if  (((Lod.Recd.Tracks     & command.tracks) <> 0)      and  (recd                                   <> 0))      or  (((armd.tracks         & command.tracks) <> 0))      or  (((Lod.Punch.In.Tracks & command.tracks) <> 0))      then do;         call Log.Error('Cannot Record During Load/Backup/Home/Eject');      end;      Lod.Recd.Tracks     = Lod.Recd.Tracks      & (not(command.tracks));      Lod.Punch.In.Tracks = Lod.Punch.In.Tracks  & (not(command.tracks));      armd.tracks         = armd.tracks          & (not(command.tracks));   end;   /* Check for recording, song protection */   /* track protection                     */   Recd.Tracks = 0;                       /* assume no tracks are recording */   if Play <> 0                           /* if sequencer going             */   then Recd.Tracks = Recd.Tracks \ Lod.Punch.In.Tracks;   if Recd <> 0                           /* if doing vk button panel recording */   then Recd.Tracks = Recd.Tracks \ Lod.Recd.Tracks;   if (recd.tracks<>0)    or (armd.tracks<>0)   then do;          /* check protection        */      if check.record.protection=0 then do;         recd = 0;          pnch = 0;         recd.tracks = 0;         armd.tracks = 0;         Lod.Recd.Tracks     = 0;         Lod.Punch.In.Tracks = 0;      end;      else do;   /* else check track protection */         do i=0 to max.tracks-1;            if  (((recd.tracks&bits(i))<>0)                   /* recording desired */            or   ((armd.tracks&bits(i))<>0))                  /* cue recording     */            and (((track.dir(i*track.len+track.stat)&1) =0)   /* but is 'safe'     */            or   ((track.dir(i*track.len+track.stat)&2)<>0))  /* or is locked      */            then do;               if log.buf(0)=0 then do;                  call Log.Error('Warning: Track # ');                  call append.decimal.number(i+1);                  if ((track.dir(i*track.len+track.stat)&2)<>0)   /* or is locked      */                  then call append.log.string(' is "Locked"');                  else call append.log.string(' is "Safe"');               end;               recd.tracks = recd.tracks and (not(bits(i)));               armd.tracks = armd.tracks and (not(bits(i)));               Lod.Recd.Tracks     = Lod.Recd.Tracks     and (not(bits(i)));               Lod.Punch.In.Tracks = Lod.Punch.In.Tracks and (not(bits(i)));            end;         end;      end;   end;   /* disallow recording if one of the above error conditions */   /* was encountered so we cannot record on any tracks       */   if  (armed       <> 0                    )    and (armd.tracks <> recrec(recrec.tracks))   and (armd.tracks =  0                    )   then do;      call clear.armed.info;       /* could not do it          */      recrec(recrec.stacked) = 0;   end;   if show.all.track.readys <> 0   then ready.tracks = lookup.ready.tracks;   /* $page - Check for motion change */      if recd=0 then precd=0;           /* clear precd always       */   if  (ftable.loaded  <>0)          /* freq table here          */   and (subsystem.ready<>0)          /* subsystem ready          */   then begin;      dcl play.desired    fixed;      dcl trig.desired    fixed;      dcl loop.desired    fixed;      dcl func.desired    fixed;      dcl monitor.desired fixed;      dcl reset.poly      fixed;      play.desired    = 0;              /* assume no play/trig      */      trig.desired    = 0;              /* desired                  */      loop.desired    = 0;      func.desired    = 0;      monitor.desired = 0;      if (func<>0)                   /* synclavier wishes to read/write */      then do;                       /* some audio data                 */         func.desired = 1;           /* give it priority                */         if pfunc = 0         then first.func = 1;         pfunc = 1;      end;      else pfunc = 0;      if (loop<>0)      then do;         loop.desired = 1;         if ploop = 0                /* detect first one         */         then first.loop = 1;        /* to clear cue stack       */         ploop = 1;      end;      else ploop = 0;      if (play<>0) and (move=0)      /* means play is desired    */      then do;         play.desired = 1;         if pplay = 0                /* detect first one         */         then first.play = 1;        /* to clear cue stack       */         pplay = 1;         trig  = 0;                  /* give priority to play    */      end;      else pplay = 0;      if (trig<>0)                   /* means trigger desired    */      then do;         trig.desired = 1;         ptrig        = 1;      end;      else ptrig = 0;      if (monitor<>0)                /* if doing DDT and no other       */      then do;                       /* output is desired,  then        */         monitor.desired = 1;        /* start poly to monitor DDT       */      end;      /* stop output at end of play or end of trigger. */      /* also stop output if we are playing and we get */      /* a trigger request,  or we are triggering      */      /* and we get a new play request:                */      if  (output.happening<>0)          /* if playing from disk     */      then do;                           /* check for end of play    */         last.user.time = real.seconds;         if ((now.playing   <>0) and (play.desired    = 0)) /* end of play */         or ((now.triggering<>0) and (trig.desired    = 0)) /* end of trig */         or ((now.looping   <>0) and (loop.desired    = 0)) /* end of loop */         or ((now.monitoring<>0) and (monitor.desired = 0)) /* end of mon  */         then do;                                           /* stop it!    */            /* wait for all punch outs to occur */            /* before we actually stop          */            /* recording                        */            armd.tracks = 0;  /* make sure armed sequencer recording stops */            /* wait for all recording to finish */            /* before glomming cue playback     */            /* stack!!!                         */            if  (Any.Track.Actually.Recording = 0)   /* if done recording  */            then do;               call get.sync.s#;          /* get last sample # for scoll   */               call terminate.output;     /* stop all output               */               reset.poly = 0;            /* no need to clean up           */               if  (now.triggering            <> 0)               and (enabled.for.envelope.info <> 0)        /* send final scrub pos */               then do;                                    /* to SYNCL if needed     */                  call SUB32(Sync.S#, Data.S#, Dtd.Scrub); /* by DSP add-on          */                  send.scrub.info = 1;               end;               if send.scrolling<>0 then do;       /* send final scroll with */                  call compute.scroll.info;        /* output.happening = 0   */               end;               do i=0 to max.ports-1;       /* reset retry count on stop              */                  port.retry(i)=0;          /* (we give up playing a track after 3    */               end;                         /*  disk read errors so the computer does */               if recorded.tracks <> 0      /* disarm after actual take to keep user */               then do;                     /* from wiping himself out               */                  call clear.armed.info;                  recorded.tracks = 0;               end;               recrec(recrec.stacked) = 0;  /* reset in case user had to retry   */               if (now.playing     <> 0)    /* set up new play buffers */               or (now.triggering  <> 0)    /* after play, trig, or    */               or (now.looping     <> 0)    /* loop, but not montoring */               then do;                  call set.new.play.buffer.position;                  /* Delay the re-start of any tape commands because */                  /* user will likely want to audition another cue   */                  /* immediately.                                    */                  if command.# <> 0                  then do;                     delay.command      = 1;                     delay.command.time = real.milliseconds;                  end;               end;               now.playing     = 0;     /* zap all motion variables */               now.triggering  = 0;     /* here                     */               now.looping     = 0;               now.monitoring  = 0;               New.Sync.Info   = 0;               if (recrec.is.stacked<>0)               then do;                  call set.up.for.armed.recording;   /* process stacked rec rec now */               end;            end;         end;                            /*  not get bogged down                   */      end;      /* Check for start of play/recd: */      if  (Rezero.WrenIVs   <> 0)        /* if rezero desired       */      and (rezero.happening <> 0)        /* rezeroing - skip checks */      then do;         if (real.milliseconds - rezero.time) igt 1000         then rezero.happening = 0;      end;      else if (output.happening=0)       /* not playing now          */      and     (track.dir.valid<>0)       /* and good track info      */      and     (Stop.DDT.Units  =0)       /* and not trying to stop   */      then do;                           /* check for play needed    */         if   (play.desired <> 0)        /* play/record desired      */         then do;            last.user.time = real.seconds;            if (first.play<>0) then do;               call lookup.all.source.or.cues;     /* set up for source or cue playback           */               call clear.all.playback.cue.stacks; /* clear all cue stacks until we are running   */               call clear.all.envelope.lists;      /* clear out envelope area as well             */               call stack.armed.cue.if.needed;     /* stack armed sequencer recording if needed   */               call STR32(0,0,Cue.Delay.#1);       /* initialize cue delay field                  */               call STR32(0,0,Cue.Delay.#2);       /* initialize cue delay field                  */               first.play=0;                       /* now allow cue triggers to be processed      */            end;            if  (New.Sync.Info  <> 0)        /* sync message received    */            then do;               call try.to.start.output(1);  /* try to start synchronous output */               reset.poly = output.happening xor 1; /* might need reset if did not start */            end;         end;         else  if (trig.desired<>0)          /* trigger desired           */         then do;            last.user.time = real.seconds;            if  (first.trig    <>0)          /* process first cue trig    */            and (trig.new.info <>0)          /* here.  the rest wait      */            then begin;                      /* until we are outputting   */               dcl Stack.Record lit 'Trig.Record';               call Set.Up.For.Stacked.Playback (Stack.Record);               trig.new.info = 0;               first.trig    = 0;            end;            call try.to.start.output(0);     /* try to start immediately   */            reset.poly = output.happening xor 1; /* might need reset if did not start */         end;         else if (loop.desired <> 0)       /* loop desired               */         then do;            last.user.time = real.seconds;            /* Set up for start of point playback */            if (first.loop<>0) then begin;               dcl Stack.Record lit 'Trig.Record';               call Zero.Out.Stack.Record(Stack.Record);               if hold.loop.for.stacking <> 0  /* if user will be stacking */               then Stack.Cue.Id = ( 0);       /* cues, then stack none    */               else Stack.Cue.Id = (-1);       /* here; else stack tempcue */               Stack.Exists = 1;               Stack.Bits   = Stack.Bits \ Stack.Whole.Map;               call Copy32(Data.S#, Stack.Sync);               call Set.Up.For.Stacked.Playback (Stack.Record);               loop.mouse.rate           = 0;               first.loop                = 0;               dtd.is.ready.for.stacking = 1;            end;            call try.to.start.output(2);  /* try to start loop output */            reset.poly = output.happening xor 1; /* might need reset if did not start */         end;         else if (func.desired <> 0)      /* start of data function reading */         then do;            if (first.func<>0) then begin;                  dcl Stack.Record lit 'Trig.Record';               call Zero.Out.Stack.Record(Stack.Record);               Stack.Cue.Id = (-1);               Stack.Exists = 1;               Stack.Bits   = Stack.Bits \ Stack.Whole.Map;               call Copy32(Data.S#, Stack.Sync);               call Set.Up.For.Stacked.Playback (Stack.Record);               first.func = 0;               do i = 0 to max.tracks-1;      /* initialize read track info */                  read.track.len     (i) = 0; /* for operation with DSP     */                  read.track.written (i) = 0;                  track.eof          (i) = 0;               end;            end;            /* but no output to start up!! */            /* nor any need to suppress    */            /* rezeroing                   */         end;         /* start of DDT/Bounce monitoring: */         else if monitor.desired<>0         then do;            call try.to.start.output(3);            reset.poly = output.happening xor 1; /* might need reset if did not start */         end;         /* Else remove possible waiting message if we never did */         /* earlier.                                             */         else if waiting.msg.printed <> 0         then call remove.waiting.msg;         /* Else reset poly/ddsad if we tried to play/loop (etc) */         /* but user changed his mind before we started it:      */         else if reset.poly <> 0         then do;            call set.lod.hz(current.rate*4,0);         /* re-set hz with 0 phase incr         */            call set_ddsad_controls(current.rate*4,0); /* re-activate DDSAD if needed         */            reset.poly = 0;         end;      end;      /* Check for correct sync during playback: */      if  (now.playing   <>0)             /* if playing out now       */      and (New.Sync.Info <>0)             /* new syn message rcvd     */      then do;                            /* check for sync           */         i = check.synchronization;       /* check sync               */         if i <> 0                        /* see if synch is in error */         then do;            if any.track.actually.recording<>0             then do;                      /* if recording,  then      */               out.of.sync = 1;           /* stop recording as gently */            end;                          /* as possible              */            else do;               call terminate.output;     /* glom output if not recording   */               now.playing   = 0;               reset.poly    = 0;               if i<0 then do;                  /* means sequencer jumped   */                                                /* ahead (preset play time) */               end;                             /* leave cue stack in place */               else if i>0 then do;             /* means overall loop       */                  pplay = 0;                    /* restart from the top     */                  call set.new.play.buffer.position; /* set up new buffer position from 0 or mark start */                  get.new.motion=get.new.motion \ 8; /* get new cue list sent over */               end;            end;         end;      end;      /* Triggered audio - check DDT Sync, check for new cues */      if  (now.triggering<>0)             /* add new trigger to list */      then do;         if (Trig.New.Info <> 0)          /* new trigger received    */         then begin;            dcl Stack.Record lit 'Trig.Record';            call compute.delayed.sync.point(shr(Stack.Exists,6)&1,1,Stack.Sync);  /* get sample # a short distance in the future. use no delay if recording on this cue. this is where shuttle movements are normally processed */            call Stack.Entire.Cue(Stack.Record);            call Set.Trigger.Rate(Active.Rate);    /* update rate info */            Trig.New.Info = 0;         end;         if (Real.Milliseconds - Trig.Start) IGT 200         then do;            Trig.Start = Real.Milliseconds;            if Sync.Mode = 2            then do;               i = check.synchronization;    /* check sync if cue trig */                                             /* doing DDT xfer         */               if i <> 0               then trig = 0;                /* stop triggering if     */                                             /* gross sync error       */            end;         end;         /* Check for end of triggered output:                         */         call get.sync.s#;                   /* get current time       */         if COM32(Sync.S#, Stacked.End.Time) = lw#igt         then trig = 0;      end;      /* Check synchronization during DDT monitoring */      if  (now.monitoring<>0)           /* check sync during DDT monitor */      then do;         if (Real.Milliseconds - Trig.Start) IGT 200         then do;            Trig.Start = Real.Milliseconds;            if Sync.Mode = 2                 /* only check sync if     */            then do;                         /* doing DDT transfer     */               i = check.synchronization;    /* check sync if monitor  */                                             /* doing DDT xfer         */               if i <> 0               then do;                      /* stop triggering if     */                                             /* gross sync error       */                  call terminate.output;                  now.monitoring = 0;               end;            end;         end;      end;            /* $page -check for new update to looping playback position */      /* new.loop.pos is set when the mouse has moved to a        */      /* new position                                             */      if  (new.loop.pos<>0)       then do;         call Handle.New.Loop.Pos;      end;   end;   /* $page - chek special items */   if  (break.me        <>0          )   /* check for break desired  */   and (output.happening= 0          )   /* (normally a program load */   and (command.#       = 0          )   /*  activated from the dtd  */   and (command.in      = command.out)   /*  toiminal)               */   then do;      i = any.track.recording.or.new.adir  /* see if any track recd'ng */        \ any.port.doing.io;               /* or any port doing io     */      if  (i=0)                          /* no commands or adirs     */      and (song.dir.updated =0)          /* no directory updates     */      and (track.dir.updated=0)          /* for song or track        */      and (write.alt.tdir   =0)      and (cue.info.updated =0)      then do;                           /* then terminate           */         print 'Returning to loader';         if (subsystem.ready<>0)         then call poly.init;            /* turn off output          */         disable;         write("317")=loadadd;      end;   end;   /* $page - Compute where to load buffers from */   /* now compute what we would like */   /* for buffers, based upon        */   /* whether we are playing or not  */   /* and where we are playing if so */   /* check for new buffer position: */   /* if so, quickly stop all output */   /* and try to go there asap       */   /* (user has pressed 'continue'   */   /* button and is waiting for      */   /* the sound                      */   if new.buffer.position<>0           /* load buffers from new place */   then do;      if new.buffer.position = 1       /* state 1: stop output, set   */      then do;                         /* time                        */         i = 0;         do j=0 to max.ports-1;            if   (port.available(i)<>0)       /* if port is avail     */            and  (port.io       (i) >1)       /* and reading disk     */            and  (port.io       (i)< Tape.Inquiry)	/* (port.io < Tape.Inquiry indicates a disk operation... */            then i = 1;                       /* then busy ...        */         end;         if i=0 then do;               /* now set new buffer pos      */            new.buffer.time     = real.milliseconds;            new.buffer.position = 2;            do j=0 to max.tracks-1;       /* reset eof flag          */               track.eof(j)=0;            /* on time base change     */               adir.ptr (j)=j*adir.len;            end;            call stack.armed.cue.if.needed;     /* stack armed sequencer recording if needed. better not happen for looped playback!!! */            call COPY32(New.Buf, Buffered);     /* set new 'buffered' position     */         end;      end;      /* if new buffer position = 2,  then we are providing a fixed */      /* delay after which hopefully the buffers have been filled   */      else if (real.milliseconds - new.buffer.time) IGT (shr(trig.delay,1))      then do;         new.buffer.position = 0; /* now new buffer is ready for use */      end;   end;   /* Check several things if armed for recording:                     */   if (armed <> 0)            /* if armed for recording,  then check   */   then do;                   /* for proper cue stacking, and punches  */      if  (recrec(recrec.stacked) = 0)  /* if recording cue is not     */      and (now.playing <> 0)            /* stacked yet doing normal    */      then do;                          /* play output,  stack it!     */         call get.sync.s#;              /* so we know where we are     */         if recrec(recrec.code ) = 0    /* immediate desired           */         then do;            recrec(recrec.sync.msb) = sync.s#.msb; /* will be changed to sector bound in stack.cue */            recrec(recrec.sync.lsb) = sync.s#.lsb;         end;         call stack.armed.cue(armd.tracks); /* stack armed cue */         /* see if we are trying to punch in but we are */         /* already late - disallow here since user     */         /* must rewind                                 */         if COM32(Sync.S#, RecRec.Send) >= lw#ieq         then do;            call clear.armed.info;                 end;      end;      if  ((armd.tracks & new.armd.tracks) <> 0) /* if new punch in/out */      and ((now.playing    <> 0)                 /* while playing or    */      or   (now.triggering <> 0))                /* triggering          */      then call stack.armed.cue(armd.tracks & new.armd.tracks);   end;   /* Now perform basic system functions:                               */   if (subsystem.ready<>0) then do;      call Real.Time.Loop;          /* perform the real time functions  */      if track.dir.updated<>0       /* current contents changed         */      then call write.track.dir;    /* write out before trashing        */      else if song.dir.updated<>0   /* song directory changed: write */      then call write.song.dir;     /* it out to save it             */      else if cue.info.updated<>0   /* cue  directory changed: write */      then call write.cue.info;     /* it out to save it             */            status.tracks = status.tracks \ (pready.tracks xor (ready.tracks \ armd.tracks));      pready.tracks = ready.tracks \ armd.tracks;      if status.tracks<>0           /* detect change in safe/ready light */      then do;         do i=0 to max.tracks-1;            if (status.tracks & bits(i))<>0            then call compute.track.status.display(i);         end;         status.tracks=0;      end;   end;   if calculating.compressed = comp#working   then do;                         /* if we're in the middle of calculating */      if func = 0 then calculating.compressed = comp#init;      else if poly.buffs.in.use = 0 /* else if no load/backup using poly */      then call do.compress;        /* calculate next part of display    */   end;   if  ((dsp.state = dsp#working ) or (dsp.state = dsp#abort))   and (dsp.paused <> 1         )   then do;             /* if we're working on a dsp function */      if func = 0 then do;         dsp.state = dsp#off;         if dspdebug <> 0 then do;            print 'FUNC disappeared during DSP';         end;         call log.error('System error with Time Scale Modify');         get.new.motion = get.new.motion \ 4;  /* Send end cmd to Synclav */      end;      else if poly.buffs.in.use = 0     /* else if load/backups are not using */      then call do.dsp;                 /* poly,  then use it ourselves       */   end;   /* $page - check for terminal debug command, special features */   /* check for more debug/special features: */   if  (ddutrk<>0)                      /* see if sfm wants to get at some samples */   and (log.buf(0)=0)                   /* no errors waiting */   and (send.ddu.info=0)                /* last buffer sent  */   and (port.io(shr(ddutrk&255,1))=0)   /* no other i/o outstanding on port */   then do;      if ((ddutrk&255)>=max.tracks)      or (track.available(ddutrk&255)=0)      or (ddulen=0)       then do;         call log.error('Trk Error');         ddutrk=0;      end;      else begin;         tptr=(ddutrk&255)*total.stride;         call COPY32(loc(addr(song.data.msb)),atmp);         call ADD16 (ddusec,atmp);         write(mam)=ddub.xmsec#;         call readdata(atmp(0),atmp(1),loc(0),256);         send.ddu.info=1;         ddusec=ddusec+1;         ddulen=ddulen-1;         if ddulen=0 then ddutrk=0;      end;   end;   /* check for stm box plug/unplug */   dcl perform.ad_init fixed;   dcl ad_init.time    fixed;   if perform.ad_init<>0 then do;        /* wait 3 seconds */      if real.milliseconds>=ad_init.time /* then init box  */      then do;         new.inputs=1;         perform.ad_init=0;      end;   end;   else if (subsystem.ready<>0)    and     (new.inputs      =0)   then do;      write(psc)=0;                   /* make sure motherboard  */      write(psf)=psnumv;      if prior.motherboard.bits <> read(psd)      then do;         perform.ad_init=1;         ad_init.time=real.milliseconds+3000;      end;   end;   /* check for timeout during data transfer */   /* happens if user presses load during    */   /* digital transfer                       */   if  ((read.track.info<>0) or (func<>0))   and (real.milliseconds > read.track.time + 10000)   then do;      if fastboot then print 'Data Read Timeout';      call zap.read.track.info.tracks;      func       = 0;      new.inputs = 1;   end;   insert ':lod:dbg-midi';   /* terminal debug */   if newinfo<>0 then begin;      call Process.Debug.Character;      newinfo = 0;   end;   if hzdbug<>0 then do;        /* print out sample rate */      if hzinc <> 0 then do;    /* to monitor lock-up    */         print hzinc, hzmod;    /* algorithm             */         hzinc = 0;      end;   end;   /* $page - check for rezero timer to rezero wren IV drives */   if  (Rezero.WrenIVs  <> 0)                    /* if rezero desired     */   and (subsystem.ready <> 0)                    /* if init completed     */   and (real.seconds > rezero.timer)             /* time for rezero       */   and ((real.seconds - last.user.time) igt 60)  /* user having coffee    */   and (any.port.doing.io = 0)                   /* double check idle     */   then do;      if issue.rezero.commands.to.all.drives <> 0      then do;         rezero.happening = 1;                   /* suppress play/trig/loop */         rezero.time  = real.milliseconds;       /* for 1 second            */      end;      rezero.timer = real.seconds + 600;         /* 10 minute intervals     */   end;   /* Check for new speed setting - do not try to get the synclav to */   /* sync to us if user is changing speed                           */   if  ((new.speed                         ) <>  0   )   and ((Real.Milliseconds - new.speed.time) IGT 2000)   then new.speed = 0;   i = read(d16) - loop.time;   if time.loop <> 0 then do;      if i IGT max.time then max.time = i;      call ADD16(i, tot.time);      tot.loops = tot.loops + 1;   end;   loop.time = loop.time + i;end;  /* of "main program loop"  (do while 1) */