/* MIDISOU - subroutines for Midi Output to signal meter */module midimod;insert ':lod:lodlits:globlits'; /* get main literals                */insert ':lod:lodlits:xmemlits'; /* literals for xmem allocation     */insert ':lod:lodmods:miscdcl';DCL MIDI.THERE     FIXED;DCL MAX.MIDI.CHAN  FIXED;DCL SYSTEM.EXCLUSIVE LIT '240';DCL END.OF.BLOCK     LIT '247';DCL TIMING.CLOCK     LIT '248';DCL START.CLOCK      LIT '250';DCL CONTINUE.CLOCK   LIT '251';DCL STOP.CLOCK       LIT '252';DCL ACTIVE.SENSING   LIT '254';DCL SYSTEM.RESET     LIT '255';/* FOR MIDI BOARD - NOTE THEY MATCH SMPTE */DCL SYSSEL LIT '"70"';  /* MIDI SUBSYSTEM SELECT ADDRESS   */DCL MCHA   LIT '"71"';  /* CHANNEL SELECT ADDRESS IF WRITE */DCL MSTA   LIT '"71"';  /* INPUT FIFO STATUS      IF READ  */DCL MDAT   LIT '"72"';  /* INPUT AND OUTPUT DATA PORT      */dcl loduart  lit '1';INIT.MIDI.SUBSYSTEMS:  PROC PUBLIC SWAPABLE; /* INIT ROUTINE FOR MIDI SUBSYSTEMS */   DCL (I,J) FIXED;   DCL DISABLE.INTERRUPTS LIT 'WRITE("313")=READ("314"); DISABLE';   DCL RESTORE.INTERRUPTS LIT 'WRITE("314")=READ("313"); WRITE(1)=READ("313")';   DISABLE.INTERRUPTS;   MIDI.THERE=0;                       /* ASSUME NO MIDI SUBSYSTEMS FOUND */   MAX.MIDI.CHAN=0;   IF (READ("51")&256)<>0 THEN DO;     /* HAVE SOME D70 TYPE DEVICE */      I=16; J=I;      DO WHILE (J=I) AND (I<(16+8)); /* LOOP OVER THE 8 MIDI SUBSYSTEMS */         WRITE(SYSSEL)=I;              /* SELECT SUBSYSTEM      */         IF  (READ(SYSSEL)=I)          /* THIS SUBSYSTEM EXISTS */         AND ((READ(MSTA)&2)=0)        /* AND THE CABLES ARE OK */         THEN DO;                      /* WE HAVE 4 MORE GOOD OUTPUTS AND 1 MORE GOOD INPUT */            MIDI.THERE=MIDI.THERE\BITS(I-16); /* TURN ON CORRESPONDING BIT */            MAX.MIDI.CHAN=MAX.MIDI.CHAN+4;    /* ANOTHER 4 OUTPUTS AVAILABLE */            DO J="10" TO "14";         /* INIT FIFO ROTARY PTRS */               WRITE(MCHA)=J;          /* SELECT UART AND ASSERT RESET LINE */               WRITE(MDAT)=READ(MDAT); /* INIT ROTARY PTRS */            END;             WRITE(MCHA)=0;             /* DEASSERT RESET LINE */            J=I;                       /* INIDICATE THAT ADJACENT OUTPUTS FOUND */         END;         ELSE J=0;                     /* INDICATE END OF ADJACENT OUTPUTS */         I=I+1; J=J+1;                 /* STEP TO NEXT POSSIBLE SUBSYTEM */      END;   END;   RESTORE.INTERRUPTS;END INIT.MIDI.SUBSYSTEMS;/* $page - op codes for midi output to meter display */dcl display.init   lit '64';dcl display.status lit '80';dcl display.levels lit '96';dcl display.bank   lit ' 8';dcl activate.peak  lit ' 8';dcl max.intensity  lit ' 0';dcl input.led      lit ' 1';dcl record.led     lit ' 2';dcl ready.led      lit ' 4';dcl track#.red     lit ' 8';dcl track#.green   lit '16';init.signal.display:proc public swapable;   /* initialize remote display */   dcl (i,j,k) fixed;   if (midi.there = 0)   or (max.midi.chan<4)   then return;   write(syssel)=16;                  /* select first MI70 board */   write(mcha  )=loduart;                do i=0 to (num.tracks-1) by display.bank;    /* init 2 displays */      write(mdat  )=system.exclusive;      write(mdat  )=255;      write(mdat  )=display.init+i;      write(mdat  )=activate.peak \ max.intensity;      write(mdat  )=32;                 /* peak hold time, .080 secs * 32 */      write(mdat  )=10;                 /* decay rate, msec               */      write(mdat  )= 0;                 /* 5 spares                       */      write(mdat  )= 0;      write(mdat  )= 0;      write(mdat  )= 0;      write(mdat  )= 0;      write(mdat  )=end.of.block;   end;end init.signal.display;set.track.display:proc(track#,info) public;   dcl (track#) fixed;   dcl (info  ) fixed;   dcl (i,j,k ) fixed;   if (midi.there  = 0)   or (max.midi.chan<4)   then return;   write(syssel)=16;                  /* select first MI70 board */   write(mcha  )=loduart;                write(mdat  )=system.exclusive;   write(mdat  )=255;   write(mdat  )=display.status \ track#;   write(mdat  )=info;   write(mdat  )=end.of.block;end set.track.display;/* $page - Signal meter look up and initialization *//* look up led code for signal metering */signallookup:proc(val);      /* pass log value,  0 - 255 */   dcl (val) fixed;   write(mam) = metr.xmsec#;   write(mal) = val;   return read(md);end signallookup;/* signal meter: *//* largest value read = 192  (4095 volume, 32767 signal ) *//* clipping (red)     = 191 = +16 db                      */dcl signalmap data     (1,101,109,117,125,133,141,149,157,161,165,168,170,173,176,181,186,191,256);/* results in:         0  : 0     1-100  : 1   101-108  : 2   109-116  : 3   117-124  : 4   125-132  : 5   133-140  : 6   141-148  : 7   149-156  : 8   157-160  : 9   161-164  :10   165-167  :11   168-169  :12   170-172  :13   173-175  :14   176-180  :15   181-185  :16   186-189  :17   191-255  :18 */Initialize.Signal.Meter.Lookup:proc public swapable;   dcl (i,j,k) fixed;   i=0;   do j=0 to 18;      k=signalmap(j);      do while i<k;         write(mam) = metr.xmsec#;         write(mal) = i;         write(md ) = j;         i=i+1;      end;   end;end Initialize.Signal.Meter.Lookup;/* $page - routines to send out signal levels to display */set.level.display:proc(track.levels) public;   dcl track.levels array;  /* pass l/r level word for each track */   dcl (i,j,k ) fixed;   if (midi.there  = 0)   or (max.midi.chan<4)   then return;   write(syssel)=16;                  /* select first MI70 board */   write(mcha  )=loduart;                do i=0 to (num.tracks-1) by display.bank;    /* init 2 displays */      write(mdat  )=system.exclusive;      write(mdat  )=255;      write(mdat  )=display.levels+i;      do j=i to i+7;         write(mdat)=signallookup(   (track.levels(j)&255)); /* SEND RIGHT FIRST */         write(mdat)=signallookup(shr(track.levels(j),8  )); /* THEN LEFT */         track.levels(j) = 0;      end;      write(mdat  )=end.of.block;   end;end set.level.display;end midimod;