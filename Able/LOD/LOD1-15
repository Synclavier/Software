/* :LOD:LOD1-15 - Start Direct To Disk Output *//* 02/12/92 - cj - deleted ddsad_xtal restrictions                    *//* 06/26/91 - cj - synchronized voice switching on punch out          *//* 03/26/91 - cj - narrowed SMPTE lockup window                       *//* 03/19/91 - cj - Removed click at start of scrubbing                *//* 03/07/91 - cj - Added controls for DDSAD                           *//* 05/15/90 - cj - Disabled 'Waiting ...' & 'Continuing ...' messages *//* current.msb,lsb holds the sample # that corresponds to the	*//* start of the current play buffer (called buffer #1)			*/dcl (Current.Buf)    (1)      fixed;    dcl (current.msb)    lit      'Current.Buf(0)';dcl (current.lsb)    lit      'Current.Buf(1)';dcl (current.offs)   fixed;   dcl (Next.Buf)       (1)      fixed;  /* Current + Buf.len		*/dcl (next.buf.msb)   lit      'Next.Buf(0)';dcl (next.buf.lsb)   lit      'Next.Buf(1)';dcl (Prior.Buf)      (1)      fixed;  /* Current - Buf.Len		*/dcl (prior.buf.msb)  lit      'Prior.Buf(0)';dcl (prior.buf.lsb)  lit      'Prior.Buf(1)';dcl voice.check proc(fixed, array, array, fixed);dcl construct.looping.fade proc(array, array, fixed) recursive;/* Semaphores for locking poly memory usage during background load	*//* and backup:																			*/dcl (poly.buffs.in.use)              fixed PUBLIC;dcl (this.buf.in.use  ) (max.ports)  fixed;/* Handy routines to tell user when we are waiting for a command to	*//* be stopped before starting output.											*/dcl (delay.command      )            fixed;dcl (delay.command.time )            fixed;dcl (waiting.msg.printed)            fixed;present.waiting.msg: proc swapable;   return;           /* for now, disable waiting message presentation */   if waiting.msg.printed <> 0           /* present message only once */   then return;   if command.fatal = 0                  /* if fatal message pends,   */   then call Log.Error('Waiting ...');   /* leave it, else print      */                                         /* "waiting"                 */   waiting.msg.printed = 1;end present.waiting.msg;remove.waiting.msg: proc swapable;   if waiting.msg.printed = 0   then return;   if command.fatal = 0   then call Log.Error('Continuing ...');   waiting.msg.printed = 0;   errmess             = 0;        /* re-present any tape error message */end remove.waiting.msg;/* $page - routine to initialize for DDT input *//* the following routine is called when we start DDT output,  or when *//* we change the input routings for DDT inputs.   This routine sets   *//* up variables to  A) provide a 75 milliseconds period of digital    *//* silence for all DDT inputs,  and B) initializes the input          *//* address counter for each channel                                   */dcl ddt.in.s#.msb   (max.ddts-1)   fixed;   /* These variables are    */dcl ddt.in.s#.lsb   (max.ddts-1)   fixed;   /* only used for the      */dcl ddt.input.delay (max.ddts-1)   fixed;   /* two-track routable     */dcl ddt.in.zeroed   (max.ddts-1)   fixed;   /* case of direct         */dcl ddt.in.zero.ptr (max.ddts-1)   fixed;   /* digital transfer.      */dcl ddt.in.fade.in  (max.ddts-1)   fixed;Initialize.For.DDT.Input:proc swapable;   dcl i fixed;   do i = 0 to Max.DDTS-1;      /* set ddt.in.s# to point to current offset in current */      /* buffer.   This is where we will start storing       */      /* DDT input data.   If output happening = 0,  then    */      /* this will be the start of the buffer.   If output   */      /* is happening,  then this will approximate where     */      /* we are during the playback:                         */      ddt.in.s#.msb   (i) = current.msb;      ddt.in.s#.lsb   (i) = current.lsb + shl(current.offs, 8);      if ddt.in.s#.lsb(i) ILT current.lsb      then ddt.in.s#.msb(i) = ddt.in.s#.msb(i) + 1;      ddt.input.delay (i) = ddt.monitor.delay;      /* also set flags to zero out DDT input buffer when output */      /* is not happening:                                       */      ddt.in.zeroed   (i) = 0;   end;   /* Also initialize variables in case doing multi-track ddt input */   do i = 0 to max.tracks-1;      track.ddt.msb      (i) = current.msb;      track.ddt.lsb      (i) = current.lsb + shl(current.offs, 8);      if track.ddt.lsb   (i) ILT current.lsb      then track.ddt.msb (i) = track.ddt.msb(i) + 1;   end;end Initialize.For.DDT.Input;/* $page - handle real time RIA change */handle.real.time.ria.change: proc(track#);   dcl (track#) fixed;   dcl (i,j,k)  fixed;   dcl (port#)  fixed;   /* Try to change from CUE PB to REPRO gracefully.   This */   /* code is only executed when we are PLAYING and the     */   /* user has switched from REPRO to CUE PB or from CUE PB */   /* to REPRO.                                             */   /* Basically, we try to toss out data that is in the     */   /* disk buffer that is more than 250 milliseconds in     */   /* front of us,   and replace that data with the correct */   /* data (ie digital zeroes or repro audio)               */   track.eof(track#)=0;               /* in case we had reached eof    */   /* see if a disk read command is outstanding to add more data       */   /* to this disk buffer.   set flag to ignore that data once the     */   /* read is finished:                                                */   port# = track.port.ix(track#);     /* get corresponding port# */   if  ((port.io      (port#)=2)      /* if read is outstanding  */   or   (port.io      (port#)=4))   and (port.io.track#(port#)=track#) /* for this track          */   and (port.update   (port#)=1)      /* play data read          */   then do;      port.update(port#) = 0;         /* toss data after read    */   end;   i = current.offs;                  /* get current play buffer offset */   load trig.delay;                   /* compute # of sectors of audio  */   mul current.rate;                  /* in trig.delay                  */   mwait;   div 2560;   j = res;                           /* # of sectors of audio          */   if  (buf1.msb(track#) = current.msb)  /* if buf1 is current,  check  */   and (buf1.lsb(track#) = current.lsb)  /* buf1 and buf2               */   then do;      if buf1.len(track#) > (i+j)        /* truncate buffer 1 if it     */      then do;                           /* contains more data than     */         buf1.len(track#) = (i+j);       /* we want to save             */         buf2.len(track#) = 0;      end;      k = i + j;      if k >= buf.len then k = k - buf.len;      if buf2.len(track#) > k            /* truncate buffer 2 if it     */      then buf2.len(track#) = k;         /* has unwanted info           */   end;   /* else current.msb has wrapped to the next buffer load.  buf2 */   /* had better contain the current data:                        */   else if (buf2.msb(track#) = current.msb)   and     (buf2.lsb(track#) = current.lsb)   then do;      if buf2.len(track#) > (i+j)      then do;         buf2.len(track#) = (i+j);      end;   end;   track.mode.change(track#) = 1;   /* perform fade in/out */end handle.real.time.ria.change;/* $page - check sync point for triggered recording              *//* Check Sync Point is called to detect triggered recording.  It *//* makes a bunch of special checks to try to precisely catch the *//* start of triggered recording                                  */check.sync.point:proc(trk,type);   dcl trk   fixed;  /* pass track #                             */   dcl type  fixed;  /* 0 = seq not running; 1 = seq running     */   dcl a(1)  fixed;   dcl amsb  lit 'a(0)';   dcl alsb  lit 'a(1)';   if   ((armd.tracks&bits(trk)) <>0)      /* if doing armed recording */   and  (source.or.cue    (trk)  <>0)      /* and cue is stacked (etc) */   and  (recrec(recrec.stacked)  <>0)      /* and recording cue is stk */   then do;                                /* set sync point           */      amsb = rec.s#.msb (trk);              /* get punch in sample #    */      alsb = rec.s#.lsb (trk)&"177400";     /* handy (sector bound)     */      if   (recrec(recrec.code )<>0)       /* if sequencer synced      */      then do;                             /* recording,  then try to  */                                           /* capture precise sync     */         /* see if sync point is within */         /* current buffer              */         if  ((recrec(recrec.sync.msb) igt recb.msb(trk)))         or  ((recrec(recrec.sync.msb)  =  recb.msb(trk))         and  (recrec(recrec.sync.lsb) ige recb.lsb(trk)))         then do;            /* if sync point is within current buffer,  then back */            /* up punch in point to precise sync point to         */            /* capture very first data.   this is needed since    */            /* the software is always late by this point          */            /* but first check to see if we are grossly late.     */            /* this will happen if user presses record after the  */            /* sync point has gone by,  (within 1 buffer after)   */            /* in other words,  if the user presses the record    */            /* button either before the sync point or up to       */            /* 20 milliseconds after the sync point (100 khz)     */            /* then we will punch in right at the sync point      */            if  (alsb - recrec(recrec.sync.lsb)) ilt shl(8,8)            then do;               amsb = recrec(recrec.sync.msb);               alsb = recrec(recrec.sync.lsb)&"177400";            end;         end;      end;      rec.s#.msb(trk) = amsb;   /* save away rounded down,  and possilby */      rec.s#.lsb(trk) = alsb;   /* synced punch in point                 */      /* save trig time and disk address of where we punched in  */      /* so synclav can define auto allocate cue with correct    */      /* sync time                                               */      if type=0 then do;      /* manual recording with no sequencer running */         call COPY32(RecRec.In, Sync.Point.Trig);      end;      else do;               /* sequencer is running - capture time (either manual with seq running,  or seq trigger recording) */         call COPY32(A, Sync.Point.Trig);      end;      call COPY32(RecRec.In, Sync.Point.Disk);      /* save disk address and trigger time so we can compute    */      /* the used recording time:                                */      call COPY32(A,         Sync.Point.Used.Trig);      call COPY32(RecRec.In, Sync.Point.Used.Disk);      /* save info for computing used field */      call COPY32(RecRec.Sync, Sync.Point.Used.Trig);      call COPY32(RecRec.In,   Sync.Point.Used.Disk);      /* if doing allocate recording and we are punching in late, establish */      /* a new sync point so we don't waste tons of disk storage:           */      if   (recrec(recrec.code   )   =  2)  /* if  doing allocate recording */      and  (record.cue.ptr(trk)      <> 0)  /* and we pass this safety test */      then do;                              /* then establish new sync point in cue playback stack as well */         call read.seg.stack(record.cue.ptr(trk));         if (Seg.Exists&(1\32\64))=(1\64)/* if this is the recording cue */         then do;            call COPY32(A, Seg.Sync);    /* set stacked cue to match sync */            /* this only works because cue.disk.msb/lsb = recrec.in.msb/lsb */            call write.seg.stack(record.cue.ptr(trk));            call COPY32(A, Sync.Point.Used.Trig);         end;      end;   end;end check.sync.point;/* $page - Compute.Play.S#.For.Loop *//* this routine looks at the desired loop sample point.  *//* it computes what buffer positions are possible to     *//* play that point from.   if sets up play.s#.msb,lsb    *//* to contain the sample # of what section of the        *//* disk should be in the buffer to be able to play       *//* the loop                                              */dcl Loop.Start.In.Buffer     fixed;   /* word start in buffer to hear */dcl Loop.Buf.Secs.Needed     fixed;   /* # of bufsecs needed          */Compute.Play.S#.For.Loop:proc(loop.s#);   dcl  (loop.s#)     array; /* pass sample # of interest */   dcl  (min)     (1) fixed;   dcl  (max)     (1) fixed;   dcl  (tmp)     (1) fixed;   dcl  (point)   (1) fixed;   call COPY32(loop.s#,tmp);              /* get sam# in temp    */   if  (Loop.Mode = 1)                    /* if segment loop     */   and (Loop.Post = 0)                    /* if pree loop, then  */   then call SUB16 (loop.buf.len,tmp);    /* back up by loop     */   if COM32(tmp, Data.s#) = lw#ilt        /* limit to disk area  */   then call COPY32(Data.S#, tmp);   call COPY32(tmp,point);                /* save sample point   */   tmp(1) = tmp(1) & "177400";            /* sector bound        */   /* we want to hear the audio from point to point + loop.buf.len */   /* tmp is nearest sector bound before that                      */   /* back up by max buffer length minus amount we need */   call COPY32(tmp,min);                        /* min buffer position */   call SUB16(shl(buf.len-loop.maxl-1,8),min);  /* would allow for all */                                                /* of loop + 1 sector  */   call COPY32(tmp,max);                        /* if point playback   */   if loop.mode = 0                             /* then we need some   */   then call SUB16(shl(loop.maxl+1,8),max);     /* at the front of     */                                                /* the buffer to avoid */                                                /* undershooting       */   if COM32(max, Data.S#) = lw#ilt              /* hope for the */   then call COPY32(Data.S#, max);              /* best at the  */                                                /* start of     */                                                /* disk         */   /* if buffers are loaded in such a way that the */   /* desired sample is in memory, then go ahead   */   /* and use it                                   */   if  (COM32(Buffered, min) >= lw#ieq)   and (COM32(Buffered, max) <= lw#ieq)   then do;      call COPY32(Buffered, Play.s#);   end;   else do;                     /* else load buffers so sample would be in middle */      call ADD16(shl(buf.len-loop.maxl,7),min);      if COM32(min, Data.S#) = lw#ilt      then call COPY32(Data.S#, min);      call COPY32(min, Play.S#);   end;   /* compute handy global information */   call SUB32(point, Play.S#, tmp);  /* loop start */   Loop.Start.In.Buffer = tmp(1);   Loop.Buf.Secs.Needed = shr(Loop.Start.In.Buffer + Loop.Buf.Len + 255,8);end Compute.Play.S#.For.Loop;/* check buffers for looped playback computes what buffers to use *//* for loop playback at point loop.s#.  if the play buffers are   *//* not loaded from that section,  then it starts a process        *//* to get then filled.                                            *//* routine returns a 0 if the buffers are not ready               */Check.Buffers.For.Looped.Playback:proc(loop.s#);   dcl loop.s#     array;   dcl i           fixed;   call Compute.Play.S#.For.Loop(loop.s#);   if COM32(Buffered, Play.S#) <> lw#ieq  /* see if we can use existing  */   then do;                               /* if not,  then reset buffer  */      new.buffer.position=1;              /* new buffer position needed  */      call COPY32(Play.S#, New.Buf);      call STR32 (-1, -1, Buffered);      /* re-enter each time here     */                                          /* until all other i/o stops   */                                          /* to keep making new estimate */      /* if we are actually looping now,  then advance current */      /* position here.  this will cause buffers to be         */      /* tossed (in track.playback.check) and reloaded         */      /* from the new position.  the audio will go off as      */      /* soon as the buffers are tossed                        */      if  (loop.mode = 1)         /* if doing loop vs point playback */      and (now.looping <> 0)      /* and output has started          */      then do;                    /* then update curremt.msb here    */         call COPY32(Play.S#, Current.Buf);      end;      return 0;   end;   do i=0 to max.tracks-1;                /* see if enough buffer is loaded */      if  (Track.Available  (i) <>0)      /* if track is available          */      and ((trig.tracks&bits(i))<>0)      /* and we want to hear it         */      and (Track.Eof        (i)  =0)      /* and not at eof                 */      and ((buf1.msb  (i)<>buffered.msb)    /* and buffer is not loaded       */      or   (buf1.lsb  (i)<>buffered.lsb)      or   (zap.buffer(i)<>0           )      or   (buf1.len(i)< Loop.Buf.Secs.Needed))      then return 0;                      /* wait for disk data to arrive   */   end;   return 1;end Check.Buffers.For.Looped.Playback;/* $page - sub routine to start trigger and loop playback and data function reading *//* Set up for stacked playback is a convenient routine that  *//* sets up for playback of a cue.   It is used both to start *//* triggered playback output,  as well as looped playback    *//* output                                                    *//* it is also used to start the data function reading        *//* mode                                                      */Set.Up.For.Stacked.Playback:proc (Stack.Record);   dcl Stack.Record  array;   dcl i             fixed;   call set.all.source.or.cues;        /* set state for mapped playback  */   call clear.all.playback.cue.stacks; /* clear all stacks to start with */   call clear.all.envelope.lists;      /* and provide no envelopes       */   if  (armed                  <>0)    /* if set up for rehearse    */   and (recrec(recrec.rehearse)<>0)    /* then nuke it if someone   */   then call clear.armed.info;         /* triggers audio from term  */   call STR32(0, 0, Stacked.End.Time); /* initialize last time      */   do i=0 to max.tracks-1;             /* force new buffer contents */      zap.buffer(i) = 1;               /* now that mapping has been */      track.eof (i) = 0;               /* no eof until found        */   end;                                /* stacked                   */   call Stack.Entire.Cue (Stack.Record);      new.buffer.position=1;              /* and start new buffer      */   call COPY32(Stack.Sync, New.Buf);   /* process to quickly        */   call STR32(-1,-1,Buffered);         /* load buffers from         */                                       /* desired sync point        */end Set.Up.For.Stacked.Playback;/* $page - try to start audio output */dcl Monitor.Timer  fixed;              /* used to provide monitor startup */try.to.start.output:proc(code) swapable;   dcl code    fixed;   /* pass 0 -- for triggered  playback */                        /* pass 1 -- for synced     playback */                        /* pass 2 -- for looped     playback */                        /* pass 3 -- for monitoring playback */   dcl immed   fixed;   dcl (i)     fixed;   dcl (a) (1) fixed;   check.for.record.start:proc(code);        /* check tracks for recording */      dcl (code) fixed;      dcl (i,j)  fixed;      do i=0 to max.tracks-1;          /* set record info if doing so */         if  ((((recd.tracks&bits(i))          <> 0     )    /* if general recording desired */         and   (COM32(Current.Buf,Song.End.S#) =  lw#ilt))   /* before end of project        */         or   (((armd.tracks&bits(i)) <>0)                   /* or armed recording desired   */         and   (source.or.cue    (i)  <>0)                   /* cue has been stacked         */         and   (recrec(recrec.stacked)<>0)                   /* cue has been stacked         */         and   (recrec(recrec.rehearse)=0)                   /* not rehearsing               */         and   (((current.msb igt recrec(recrec.sync.msb)))  /* and current time is          */         or     ((current.msb  =  recrec(recrec.sync.msb))   /* within armed range           */         and     (current.lsb ige recrec(recrec.sync.lsb))))         and   (((current.msb ilt recrec(recrec.send.msb)))         or     ((current.msb  =  recrec(recrec.send.msb))         and     (current.lsb ilt recrec(recrec.send.lsb))))))         and (track.available(i)   <>0)  /* track is available     */         and (track.recording(i)    =0)  /* not busy from last op  */         then do;                        /* recording desired      */            track.recording  (i)  = 1;         /* now recording      */            if Synclav.software.version >= 3            then get.new.motion = get.new.motion \ 2;            precd.tracks          = precd.tracks \ bits(i);            track.eof        (i)  = 0;         /* may not be at eof  */            recb.msb         (i)  = output.s#.msb;            recb.lsb         (i)  = output.s#.lsb;            rec.s#.msb       (i)  = output.s#.msb;            rec.s#.lsb       (i)  = output.s#.lsb;            max.s#.msb       (i)  = output.s#.msb;            max.s#.lsb       (i)  = output.s#.lsb;            if  (code          = 1               )  /* if synced playback */            and (armed         = 0               )  /* that is not armed           */            and (output.s#.msb = song.data.s#.msb)  /* at start of song   */            and (output.s#.lsb = song.data.s#.lsb)            then track.punch (i)  = 4;     /* no punch in at start of track */            else track.punch (i)  = 1;     /* perform punch-in cross fade   */            track.plen       (i)  = pwlen; /* save cross fade to simplify punch out  */                        call compute.track.status.display(i);                        call check.sync.point(i,code);  /* set sync point if seq trig recording in allocate mode */         end;      end;   end check.for.record.start;   /* Routine to see if ports or busy to tape command I/O so that the    */   /* real time i/o should be delayed:                                   */   Port.Is.Busy.Doing.Command: proc(trackbits);      dcl trackbits  fixed;      dcl i          fixed;      /* Check here to see if this port is busy doing a tape command.     */      /* If so,  wait for the tape command to finish before we start      */      /* the output.                                                      */		if command.# <> 0		then do;						do i = 0 to max.ports - 1;            /* check each port         */															  /* EXcluding AUX tape      */				if  (port.available(i) <> 0)       /* if port is avail        */				and ((port.track.bits(i) & trackbits) <> 0) /* and needed     */				then do;					if this.buf.in.use(i) <> 0      /* if poly being used      */					then do;                        /* for command, wait to    */						call present.waiting.msg;						return 1;					end;						if (port.io(i) <> 0)            /* if output happening     */					then do;                        /* then check.             */							if port.io(i) = Tape.Wait    /* if waiting, then stop   */						then port.io(i) = 0;         /* waiting and do output   */							else if (port.io(i) >= Tape.Inquiry)     /* if busy doing  */						and     (port.io(i) <= Tape.AnyCommand)  /* tape command,  */						then do;                                 /* then wait      */							call present.waiting.msg;							return 1;						end;					end;				end;			end;			if waiting.msg.printed <> 0			then call remove.waiting.msg;		end;      return 0;   end Port.Is.Busy.Doing.Command;   /* Routine sees if port is busy.   All ports must be idle when        */   /* starting output doing multi-track DDT.                             */   Port.Is.Busy.For.DDT: proc;      dcl i fixed;      if Sync.Mode <> 2                   /* no check needed if not doing */      then return 0;                      /* direct digital transfer      */      if DDT.Connect.Mode = 0                /* if using Routable UDIO,   */      then return (aux.d24.# = ddt.d24.#)    /* connected to same d24     */      and         (port.io(max.ports)<>0);   /* then wait for AUX tape.   */				#if (inc.multi.udio)			if Stop.DDT.Units <> 0              /* must turn off units from     */			then return 1;                      /* last time if needed          */				do i = 0 to max.ports-1;            /* look over all ports          */					if  (Port.Available(i) <> 0)     /* if port is available         */				and (Port.DDT      (i) <> 0)     /* and has DDT hardware         */				and (Port.Io       (i) <> 0)     /* and port is busy             */				then return 1;                   /* then must wait               */				end;		#endif		      return 0;   end Port.Is.Busy.For.DDT;   /* Procedure to zero out front end address registers  */   /* when starting output doing DDT                     */   Zero.FEAPS: proc(inonly);      dcl i      fixed;      dcl inonly fixed;      if Sync.Mode = 2                    /* initialize address ptr     */      then do;                            /* if doing DDT xfer          */         if DDT.Connect.Mode = 0 then do; /* handle dedicated D24       */            call Set.Selected.DDT.Front.End.Address.Pointer(0);         end;						else do;								#if (inc.multi.udio)         		do i = 0 to max.ports-1;						if  (Port.Available(i) <> 0)						and (Port.DDT      (i) <> 0)						then do;									call quickly.select.port(i);									DDT.Mode = Port.DDT.Mode(i) & (not(FE_Go));									/* Set mute bit if we are monitoring so that digital */							/* zeroes go out all DDT outputs while monitoring.   */									if  (inonly <> 0)							and ((DDT.Mode & FE_Dir_In) = 0)							then DDT.Mode = DDT.Mode \ FE_Mute;							else DDT.Mode = DDT.Mode & (not(FE_Mute));									Port.DDT.Mode(i) = DDT.Mode;									call Set.Selected.DDT.Front.End.Address.Pointer(0);									call deselect(i);								end;					end;				#endif         end;      end;   end Zero.FEAPS;   Set.Master.FEGO: proc;      if Sync.Mode <> 2          /* nothing to do if not doing */      then return;               /* any ddt                    */      if DDT.Connect.Mode = 0    /* handle 2 track DDT         */      then do;                   /* easily                     */         DDT.Mode = DDT.Mode \ FE_Go;             /* set go bit      */         ddt.last = Read.Selected.DDT.Word.Clock; /* get wrd clk     */         return;      end;            /* Now start master unit: */				#if (inc.multi.udio)			DDT.Mode = Port.DDT.Mode(dig.xfer.go.master) \ FE_Go;			Port.DDT.Mode(dig.xfer.go.master) = DDT.Mode;				call quickly.select.port(dig.xfer.go.master);				call Read.Selected.DDT.Word.Clock;				call deselect(dig.xfer.go.master);  /* disconnect from port */				call get.d16.time;                  /* get current d16 time */			ddt.last = Get.DDT.Clock.Estimate;  /* and ddt word clock   */		#endif   end Set.Master.FEGO;   /* Start output - triggered playback (internal sync) */   New.Cur.Env        = (-1);     /* force synth check/update when */   New.Seg.List       = ( 1);     /* any output starts.            */   New.Env.List       = ( 1);   Trigger.Vol.Info   = (-1);     /* initialize to max             */   punch.out.pending  = 0;        /* no punch outs pending         */   if code = 0 then do;           /* non synced playback - make sure buffers loaded */      active.rate = current.rate*4;    /* use project rate for triggered play back */      call Set.Trigger.Rate(Active.Rate); /* set rate, compute trigger.vol.info    */                                          /* mostly for DDSAD's use at this time   */                                          /* since output happening = 0            */      if COM16(0, Buffered) <> lw#ieq  /* see if we are able to play right */      then do;                         /* now from data that is buffered   */         new.buffer.position=1;        /* if not,  then must reload        */         call STR32( 0, 0,New.Buf );   /* buffers from new place           */         call STR32(-1,-1,Buffered);      end;      if Port.Is.Busy.Doing.Command(trig.tracks)      then return;      if (armed = 0)              /* if not armed for cue recording */      then do;                    /* then wait for data to start up */                                  /* otherwise, start up right away */                                  /* so manual recording starts     */                                  /* quickly                        */         do i=0 to max.tracks-1;             /* see if tracks loaded */            if  (track.available(i)<>0)      /* track is available   */            then do;               if  (track.eof        (i) = 0)   /* not at eof           */               and ((trig.tracks&bits(i))<>0)   /* output desired       */               and ((buf1.msb  (i)<>0  )               or   (buf1.lsb  (i)<>0  )               or   (buf1.len  (i)< 30 )               or   (zap.buffer(i)<>0  ))               then do;                  return;                 /* cannot start output yet  */               end;            end;         end;         if real.milliseconds<trig.time  /* provide fixed delay that  */         then return;                    /* matches polyphony trigger */      end;                                                     if Port.Is.Busy.For.DDT            /* must also wait if port is */      then return;                       /* busy and we are doing     */                                         /* multi-track DDT           */      output.happening = 1;      now.triggering   = 1;      call STR32( 0, 0, Output.S#);       /* save file position       */                                          /* we started playing       */      call STR32( 0, 0, Chan32.S#);       /* init phase count         */      chan32.last  = shl(buf.base,8);      call STR32( 0, 0, DDT.S#);          /* initialize for word clk  */                                          /* ddt.last is read below   */      call STR32( 0, 0, Current.Buf);     /* we will start here       */      current.offs = 0;                   /* set up for call to       */                                          /* track check              */      call check.for.record.start(code);  /* check for trigered recding */      call Zero.FEAPS(0);                 /* zero front end addr ptrs   */      call Compute.Trigger.Vol.Info;      /* set up trigger.vol.info    */            call get.d16.time;                  /* get current d16 time */      call Voice.Check(1, Current.Buf, Our.Time, 0); /* turn desired voices on, but skip ddt */      /* start output by setting phase increment: */      /* sample DDT clock + timer for DDT         */      /* sync - up                                */      /* Triggered output:                        */      disable;         call Set.Master.FEGO;         call Set.Trigger.Rate(Active.Rate); /* set rate, compute trigger.vol.info */         trig.start = real.milliseconds;     /* initialize timer    */                                             /* for DDT sync'ing    */      enable;      /* Call voice.check again now to start any fade-ins that      */      /* start right at 0,0 (ie triggering a cue with a pre-set     */      /* fade in time).   The voice was just turned on above - we   */      /* won't start the ramp-in until the next call to Voice.Check */      /* so let's do that now:                                      */      call get.sync.s#;                      /* get d16 time and chan 32 sample # */      call voice.check(0, Sync.S#, Our.Time, 1);   end;   /* Start output - PLAY */   else if code = 1 then do;                 /* compute info for synchronous start */      /* Compute rate we will be playing at here so we can give the  */      /* DDSAD pll as much time as possible to sync up.  At this     */      /* point output.happening stil == 0                            */      active.rate = current.rate*4;      /* use .025 khz resolution  */      if  (smpte.onoff<>0)      and (Sync.Mode  <>0)      then do;                           /* scale for smpte speed    */         load active.rate;               /* active rate              */         mul smpte.track.rate; mwait;    /* times tracking rate      */         div smpte.mode.rate;            /* divide by mode rate      */         active.rate=res;                /* round below              */         if shl(rem,1) ige smpte.mode.rate         then active.rate=active.rate+1;         /* disable smpte playback off-speed if DDSAD is being       */         /* used                                                     */         if  (CREG_AVAIL<>0)             /* if using DDSAD           */         and (abs(smpte.mode.rate - smpte.track.rate) IGE DDSAD_WINDOW)         then return;      end;      if active.rate<    0 then active.rate=   0;      if active.rate>=4095 then active.rate=4095;      call set.lod.hz(active.rate,0);         /* reset rate, but pinc = 0  */      call set_ddsad_controls(active.rate,0); /* set up DDSAD for tracking */      call compute.address.and.sync.time(1); /* compute address and sync time to start playing */      if COM32(Buffered, Play.S#) <> lw#ieq  /* see if we were able to play */                                             /* at buffer start             */      then do;                               /* if not,  then reset buffer  */         /* compute new buffer position that will correspond to */         /* where we will be playing .256 second from now.      */         /* Start disk reading process to read data from there  */         new.buffer.position=1;              /* new buffer position needed  */         call COPY32(Play.S#, New.Buf);      /* start with Play.S# computed */         load Sync.Window; mul 1;            /* above. Compute samples in   */         New.Buf(0)  =New.Buf(0) + ures;     /* .256 second; add that in    */         call ADD16(res, New.Buf);           /* plus 1 sector to handle     */         call ADD16(256, New.Buf);           /* very slow rates             */         New.Buf.Lsb = New.Buf.Lsb&"177400"; /* start on boundary           */         call STR32(-1, -1, Buffered);       /* re-enter each time here     */                                             /* until all other i/o stops   */         return;                             /* to keep making new estimate */      end;      if New.Buffer.Position <> 0           /* also must wait if buffer    */      then return;                          /* has not been filled         */      call get.d16.time;                    /* get current d16 time */      call COPY32(Our.Time,  A);            /* get it in a temp     */      call ADD16 (50*d16tim, A);            /* add 50 msec to it    */      if COM32(Play.Sync.Time, A) = lw#igt  /* if sync time is > 50 msec */      then return;                          /* from now,  then do not    */                                            /* hang up here.  retry      */      if Port.Is.Busy.Doing.Command(-1)     /* wait for tape to stop.     */      then return;      if Port.Is.Busy.For.DDT               /* must also wait if port is */      then return;                          /* busy and we are doing     */                                            /* multi-track DDT           */      output.happening     = 1;      now.playing          = 1;      previous.delta       = 0;        /* accurate now             */      previous.correction  = 0;      New.Sync.Info        = 0;      call COPY32(Play.S#, Output.S#); /* save file position       */                                       /* we started playing       */      call STR32( 0, 0, Chan32.S#);    /* init phase count         */      chan32.last      =shl(buf.base,8);      call COPY32(Play.S#, DDT.S#);       /* save file position       */                                          /* we started playing       */                                          /* as ddt word clock base   */                                          /* as well                  */      call COPY32(Play.S#, Current.Buf);  /* we will start here       */      current.offs = 0;                   /* set up for call to       */                                          /* track check              */      call check.for.record.start(code);      call Zero.FEAPS(0);  /* zero front end addr ptrs   */      if COM32(Current.Buf, Song.Data.S#) = lw#ieq                                             /* if starting from      */                                             /* top then              */      then immed=1;                          /* jump to volume        */      else immed=0;                          /* else use volume filt  */      call voice.check(immed, Current.Buf, Our.Time, 0);  /* turn desired voices on, but skip ddt */      call get.d16.time;                 /* get current d16 time */      call COPY32(Our.Time, A);          /* in a temp            */      call ADD16(10*d16tim, A);          /* add in 10 msec       */      do while  ((play.sync.time.msb  >  a(0)))   /* if sync time is > 10 msec */      or        ((play.sync.time.msb  =  a(0))    /* from now,  then do not    */      and        (play.sync.time.lsb igt a(1)));  /* hang up here.  retry      */         call get.d16.time;                    /* get current d16 time */         call COPY32(Our.Time, A);             /* in a temp            */         call ADD16(10*d16tim, A);             /* add in 10 msec       */      end;      do while (read(d16)+d16tim) < play.sync.time.lsb;   /* wait until 1 msec before sync point */      end;      call set_ddsad_controls(active.rate,0); /* now enable DDSAD output (output happening now equals 1) */      /* start synchronized output: */      disable;                                    do while read(d16)<play.sync.time.lsb;   /* wait for sync point  */         end;         call Set.Master.FEGO;              /* start master ddt           */         call set.lod.hz(active.rate,1);    /* now set phase incr to 1    */      enable;   end;   /* Start output - point playback (scrubbing) */   else if code = 2 then do;                 /* compute info for looped playback */      if loop.mode = 0 then do;              /* point playback mode            */         active.rate = 0;                    /* start out halted               */      end;      else do;         active.rate = current.rate*4;       /* use current rate for looping play back */      end;      compute.new.scrub.limit = 1;           /* force computation of scrub.rate.limit  */      call set.lod.hz(current.rate*4,0);     /* leave poly at current rate so preset.chan.32 works correctly */      call set_ddsad_controls(0,1);          /* set up DDSAD for scrubb      */      if hold.loop.for.stacking <> 0         /* if not done with stacking     */      then return;      if Check.Buffers.For.Looped.Playback(S#.To.Start.Looping.At) = 0      then do;         call Port.Is.Busy.Doing.Command(trig.tracks);    /* present waiting message too */         return;      end;      if Port.Is.Busy.Doing.Command(trig.tracks)  /* wait for tape to stop.           */      then return;      if Port.Is.Busy.For.DDT                /* must also wait if port is */      then return;                           /* busy and we are doing     */                                             /* multi-track DDT           */      if loop.mode = 0 then do;              /* point playback mode            */         /* jump chan 32 phase accum to correct point */         call Preset.Chan.32.Phase.Accum(Loop.Start.In.Buffer);      end;      else do;                               /* segment playback               */         Cur.Loop.Buf = 1;                   /* use buf #1 to start            */         do i = 0 to max.tracks-1;           /* create first audio segment     */            if  (Track.Available  (i) <>0)   /* if track is available          */            and ((trig.tracks&bits(i))<>0)   /* and we want to hear it         */            then do;               call Construct.Loop.Buffers(i,1,1,                    Loop.Start.In.Buffer,buf1.len(i),loop.buf.len,compute.base.adr(i));              end;         end;      end;      /* now we can set up channel base address for playback from buf #1 */      output.happening     = 1;      now.looping          = 1;      call COPY32(Play.S#, Output.S#); /* save file position       */                                       /* we started playing       */      call STR32(0, 0, Chan32.S#);     /* init phase count         */      chan32.last = shl(buf.base,8);      call COPY32(Play.S#, DDT.S#);    /* keep ddt.s# up to date   */                                       /* even though it could     */                                       /* never be used during     */                                       /* looping playback?        */      call COPY32(Play.S#, Current.Buf);      current.offs  = shr(Loop.Start.In.Buffer + 255,8);      call get.d16.time;                     /* get current d16 time */      call COPY32(Our.Time, Prior.Rate.Time);      if Sync.Mode = 2                   /* get ddt word clock  */      then do;                           /* if needed           */         if DDT.Connect.Mode = 0 then do;            ddt.last = Read.Selected.DDT.Word.Clock;         end;         else do;            ddt.last = Get.DDT.Clock.Estimate;         end;      end;      /* construct digital ramp-in to remove clicks:                 */      call construct.looping.fade(Current.Buf, Our.Time, 1);      /* start looped output: */      if loop.mode = 0 then do;          /* point playback         */         call set.lod.hz(0,0);           /* set rate to 0 now      */         call set_ddsad_controls(0,1);   /* set up DDSAD for scrubb      */      end;      else do;                           /* segment playback       */         call ps_on(32,0);               /* turn off channel 32 for a moment */         do i=0 to 10;end;               /* to zero out phase accum          */         /* set up channel 32 to play the data in the looped portion */         /* of the audio segment.  the first sector of the audio     */         /* data is not played directly.  it stored in the buffer    */         /* to facilitate making the next cross fade                 */         call ps_wave(32,shr(Loop.Buf.Len,8)-1,loop.buf1+1, 0); /* set up chan 32 for loop     */         call set.lod.hz(active.rate,1);    /* set hz with 1 phase incr    */         call ps_on(32,3);                  /* turn on with loop for input monitoring */      end;   end;   /* Start output - MONITORing */   else if code = 3 then do;            /* start poly to monitor DDT inputs */      active.rate = current.rate*4;     /* use current rate for triggered play back */      call set.lod.hz(active.rate,0);         /* reset rate, but pinc = 0  */      call set_ddsad_controls(active.rate,0); /* set up DDSAD for tracking */      Monitor.Timer = Monitor.Timer + 1; /* wait 10 loop times so that      */      if Monitor.Timer ILT 10            /* plenty of zeroes get written    */      then return;                       /* to the various input buffers    */                                         /* if doing 2 track routable       */                                         /* direct digital transfer         */      /* wait for all port activity to stop if doing DDT monitoring         */      /* from multi-track DDT                                               */      if Port.Is.Busy.For.DDT               /* must also wait if port is */      then return;                          /* busy and we are doing     */                                            /* multi-track DDT           */      output.happening = 1;      now.monitoring   = 1;      call STR32( 0, 0, Output.S#);       /* save file position       */                                          /* we started playing       */      call STR32( 0, 0, Chan32.S#);       /* init phase count         */      chan32.last  = shl(buf.base,8);      call STR32( 0, 0, DDT.S#);          /* initialize for word clk  */                                          /* ddt.last is read below   */      call STR32( 0, 0, Current.Buf);     /* we will start here       */      current.offs = 0;                   /* set up for call to       */                                          /* track check              */      call Zero.FEAPS(1);                 /* zero front end addr ptrs   */                                          /* set mute bits for outputs  */      call get.d16.time;                  /* get current d16 time       */      call Voice.Check(1, Current.Buf, Our.Time, 0); /* turn desired voices on, but skip ddt */      /* Monitoring output: */      call set_ddsad_controls(active.rate,0); /* now enable DDSAD output (output happening now equals 1) */      disable;         call Set.Master.FEGO;                  /* start master DDT */         call Set.Lod.Hz(active.rate,1);        /* now set phase incr to 1       */         trig.start = real.milliseconds;        /* initialize timer    */                                                /* for DDT sync'ing    */      enable;   end;   /* Common routines after starting any output: */   /* compute next and prior buffer positions */   /* to have handy                           */   call COPY32(Current.Buf, Next.Buf);   call ADD16(shl(buf.len,8), Next.Buf);   call COPY32(Current.Buf, Prior.Buf);   call SUB16(shl(buf.len,8), Prior.Buf);   if xdebug then do;      print 'Start: ',output.s#.msb,output.S#.lsb;   end;   out.of.sync = 0;   /* initialize variables for DDT input as well: */   call Initialize.For.DDT.Input;end try.to.start.output;