/* INITSOUE - Perform initialization for Live Overdub *//* 02/11/92 - cj - allow multi udio to work with DDSYN          *//* 08/14/91 - cj - Added UDIO/DDSYN stuff                       *//* 08/14/91 - cj - slightly different use of creg_avail         *//* 06/26/91 - cj - added more information to magic sector       *//* 03/07/91 - cj - added support for DDSAD dsp option           *//* 08/20/90 - cj - added code for 4 wangs/4 pats                *//* 05/15/90 - cj - Changed aux tape to d24 #2                   *//* 03/26/90 - cj - Code for new tape format                     *//*                 Moved init11 to INITSOUF                     *//* 03/27/89 - cj - initialize port.toggle to avoid bugs when    *//*                 switching from max tracks back to normal     *//*                 tracks                                       *//* 03/23/89 - cj - disabled Wren IV caching,  moved code around *//* the initialization process interrogates all *//* drives and makes sure they are running.     */begin;                         /* local variables for initialize   */   dcl (track#,port#,ldrive#,i,j,k,l,m) fixed static;   dcl (port.track#                   ) fixed static;   dcl (voice#                        ) fixed static;   dcl (baseadr                       ) fixed static;   dcl (sec#                          ) fixed static;   dcl (amsb,alsb                     ) fixed static;   dcl (bmsb,blsb                     ) fixed static;   dcl (cmsb,clsb                     ) fixed static;   dcl (init.timer                    ) fixed static;   dcl (any.tape.found                ) fixed static;   dcl (any.tape2.found               ) fixed public;	dcl (num.start.commands.to.do      ) fixed;	dcl (num.format.commands.to.do     ) fixed;   compute.base.voice#: proc swapable;      if new.backplane <> 0       /* new poly backplane - start w 16  */      then do;         if polynumv < 16         /* if shows < 16 voices - error     */         then return polynumv;         else return 16;          /* start with voice # 16            */      end;      if (polynumv<8)             /* 0 or 4 voices - error            */      then return polynumv;      if (polynumv<12)            /* 8 voices: must be 4 track        */      then return polynumv - 4;      if (polynumv<20)            /* 12 or 16 voices - must be 8 trk  */      then return polynumv - 8;      return polynumv - 16;       /* assume is a 16 track             */   end compute.base.voice#;   /* Fill Magic Sec# is called whenever we are writing the magic sector */   /* to the disk.   Assorted system information is stored away in       */   /* that sector.                                                       */   /* Format of magic sector:                                            */   /* words   0 -  15:      for use by calling routine                   */   /* word   16      :      holds current DDT Format & DDT Sync mode     */   /* word   17 -  21:      hardware config info                         */   /* word   22 - 255:      free                                         */   fill.magic.sec#: proc (port#, track#, buf) PUBLIC swapable;   /* store system info in magic sec#  */      dcl port#  fixed;      dcl track# fixed;      dcl buf    array;      /* save away DDT Format & Sync that are currently selected: */      buf(16) = DDT.Format \ shl(DDT.Sync,8);      buf(17) = port#;      buf(18) = port.base.track(port#);      buf(19) = tracks.per.port;      buf(20) = track.avail.bits;      buf(21) = track.data.msb   (track#);      buf(22) = track.data.lsb   (track#);   end fill.magic.sec#;   setup.drive.config: proc(targ#) swapable;  /* set up config for track */      dcl targ# fixed;      if Rezero.WrenIVs      then track.drive.exists = 3;  /* check for Wren IV       */      else track.drive.exists = 1;  /* else no check needed    */      track.track#   =track#;      track.d24#     =port.d24.#(port#);      track.port#    =port#;      track.target#  =targ#;      track.lun#     =0;      track.smsb     =0;       /* zero out here               */      track.slsb     =0;       /* size measured below         */      track.emsb     =0;        track.elsb     =0;   end setup.drive.config;   check.and.log.retry: proc swapable;      if port.io(port#)=1            /* if we did a reset  */      then return;                   /* then wait for it   */      track.retry(track#)=track.retry(track#)+1;      if track.retry(track#)<=3      /* give drive a chance */      then return;                   /* to change it's mind */      track.available(track#)=0;     /* must not be there   */   end check.and.log.retry;   Abort.Initialize:proc swapable;      initialize      = 0;           /* if unable to complete         */      subsystem.ready = 0;           /* initialization,  reset all    */      erase1          = 0;           /* flags and indicate subsystem  */      erase2          = 0;           /* is not ready                  */      mount.drives    = 0;      dismount.drives = 0;		format.drives   = 0;   end Abort.Initialize;   /* first,  initialize variables */   /* and check d24 connection     */   Init1:proc (version) swapable;      dcl version array;      /* Initialize several hardware items */      if  (erase1=3456)                    /* for overall erase */      and (erase2=5432)                    /* then go to init   */      then do;			if      format.drives = 1 then call log.error('Starting FORMAT Of All Drives');         else if eraselong     = 1 then call log.error('Starting Erase Long'   );         else if eraselong     = 2 then call Log.Error('Starting 4-track Erase');         else                                call log.error('Starting Erase All'    );      end;	   else if dismount.drives=1      then do;         call log.error('Starting Dismount Of All Drives');      end;      else if mount.drives=1      then do;         call log.error('Starting Mount Of All Drives');      end;      else do;         if fastboot = 0         then call log.error('Starting Direct-to-Disk - ');         else call log.error('Starting FAST Initialize - ');         call append.log.string(version);         if creg_avail <> 0 then call append.log.string('/DSP Option');      end;      call Initialize.Signal.Meter.Lookup;      call init.midi.subsystems;           /* init display quickly   */      call init.signal.display;            /* set desired decay rate */      do i=0 to num.tracks-1;              /* turn off input/ready/record lights on remote box */         call set.track.display(i,0);         misc.buf(i) = 0;      end;      call set.level.display(misc.buf);    /* clear signal leds too */      song.dir.valid    =0;                /* reset song dir valid  */      error.msb         =0;                /* in case this is       */      error.lsb         =0;                /* erase all             */		      initialize = initialize + 1;   end Init1;   Init2:proc swapable;      DDT.Hardware.Avail  = 0;         /* assume hardware not avail   */      DDT.DDSYN.Avail     = 0;      DDT.UDIO.Avail      = 0;	  		#if (inc.multi.udio)				 	/* multi udio included	  	  	 */			DDT.MULTI.Avail     = 0;			DDT.Connect.Mode    = 0;		#endif		      num.available.ports = 0;         /* assume no ports avail        */      Tracks.Per.Port     = 2;         /* set up for 2 tracks per port */      Buf.Len             = Buf.2track;      Rec.Base            = Rec.2track;		num.start.commands.to.do  = 0;		num.format.commands.to.do = 0;      do port#=0 to max.ports;         /* re-initialize port variables */         port.exists    (port#)=0;     /* in case this is an erase     */         port.available (port#)=0;         port.retry     (port#)=0;         port.toggle    (port#)=0;         port.io        (port#)=0;         port.count     (port#)=0;						#if (inc.multi.udio)				/* multi udio included	  		  */				port.ddt       (port#)=0;  /* for now, now hardware        */				port.ddt.rev#  (port#)=0;  /* is available                 */				port.ddt.mode  (port#)=0;			#endif         if port# < max.ports                /* only these ports       */         then do;                            /* have tracks            */            port.track.bits(port#)=bits(port#*Tracks.Per.Port)                                  \bits(port#*Tracks.Per.Port+1);            port.base.track(port#)=port#*Tracks.Per.Port;            port.d24.#     (port#)=lod.d24.#;   /* most ports are here    */         end;         else do;            port.track.bits(port#)=(-1);        /* all tracks use aux     */            port.base.track(port#)=( 0);        /* base track is 0        */            port.d24.#     (port#)=aux.d24.#;   /* this port is here      */         end;						zero.jaz.position(port#);      end;      do track#=0 to max.tracks-1;     /* also re-initialize tracks    */         longconfig      (track#)=0;         track.exists    (track#)=0;         track.available (track#)=0;         track.port.ix   (track#)=track#/tracks.per.port;         track.base.adr  (track#)=track#*2*Rec.Base;         track.numsec.msb(track#)=0;         track.numsec.lsb(track#)=0;         track.eof       (track#)=0;         track.retry     (track#)=0;         track.starts    (track#)=0;         track.recording (track#)=0;         new.adir        (track#)=0;         adir.ptr        (track#)=track#*adir.len;         buf1.len        (track#)=0;         buf2.len        (track#)=0;         buf3.len        (track#)=0;         clob.len        (track#)=0;         valid.info      (track#)=0;         track.status    (track#)=0;         track.command   (track#)=0;         /* track.track.bits - holds bits for the OTHER tracks that */         /* share this same port:                                   */         track.track.bits(track#) = bits(track# xor 1);         tptr=track#*total.stride;         do i=0 to (max.entries.per.track*track.info.stride)-1;            track.info(tptr+i)=0;         end;      end;      /* Set up TPTR for possible optical disk transfer */      tptr = optical.tptr;      track.drive.exists =  257;        /* assume optical drive exists    */                                        /* set bit for 1024 byte sectors  */      track.track#       =  0;          /* use track # of 0 for errors    */      track.d24#         = syn.d24.#;   /* use synclavier d24             */      track.port#        = max.ports;   /* no port#                       */      track.target#      =  5;          /* use target 5                   */      track.lun#         =  0;          /* lun 0                          */      track.smsb         =  0;          /* no base offset                 */      track.slsb         =  0;      track.emsb         = -1;          /* assume infinite size for now   */      track.elsb         = -1;      /* Set up TPTR block for dedicated external tape drives             */      tptr = tape1.tptr;      track.drive.exists =  1;          /* assume tape1   drive exists    */      track.track#       =  0;          /* use track # of 0 for errors    */      track.d24#         = aux.d24.#;   /* use aux        d24             */      track.port#        = max.ports;   /* no port#                       */      track.target#      =  1;          /* use target 1                   */      track.lun#         =  0;          /* lun 0                          */      track.smsb         =  0;          /* no base offset                 */      track.slsb         =  0;      track.emsb         =  0;      track.elsb         =  0;      tptr = tape2.tptr;      track.drive.exists =  1;          /* assume tape1   drive exists    */      track.track#       =  0;          /* use track # of 0 for errors    */      track.d24#         = aux.d24.#;   /* use aux        d24             */      track.port#        = max.ports;   /* no port#                       */      track.target#      =  2;          /* use target 2                   */      track.lun#         =  0;          /* lun 0                          */      track.smsb         =  0;          /* no base offset                 */      track.slsb         =  0;      track.emsb         =  0;      track.elsb         =  0;      num.available.tracks=0;      track.avail.bits    =0;      track.info.bits     =0;      any.tape.found      =0;      any.tape2.found     =0;      call gadir(0);             /* zero out allocation directory in */                                 /* external memory so it will       */      do i=0 to max.tracks-1;    /* contain all zeros if we cannot   */         rpc adir.len;           /* read it in                       */         write(mdi)=0;      end;      call zero.cue.dir;         /* zero out cue directory info      */      /* Make sure d24 exists: */      write(ScsiSel) = S$SelectEnable \ Scsibits (lod.d24.#);  /* select d24 to lod subsystem */      if (read(ScsiSel) & Scsibits(lod.d24.#))=0 then do;      /* board does not exist */         call log.error('Direct-to-Disk System Error - D24 is missing');         call Abort.Initialize;         return;      end;      initialize=initialize+1;     /* now look for poly              */   end Init2;   /* $page - Initialization, cont:  Poly */   /* Check to make sure poly system exists,  etc. etc. */   Init3:proc swapable;      if (read("51")&1024)=0 then do;         call log.error('Direct-to-Disk System Error - D155 is missing');         call Abort.Initialize;         return;      end;      call Poly.Init;                     /* init poly subsystem     */      Base.Voice# = Compute.Base.Voice#;  /* compute base voice #    */      if polyadc=0 then do;               /* no adcontroller card    */         call log.error('Direct-to-Disk Error - Poly ADC not in system');         call Abort.Initialize;         return;      end;      call ps_maxchan(0,1);        /* set LOD bit on adc always      */      /* Initialize for the DSP option connection */      if creg_avail <> 0 then do;         print 'D130/DDSAD revision code: ',octal(read_ddsad_revision);         call write_ddsad_bits         (DDSAD_BUFLEN \ DDSAD_CLOCK \ DDSAD_SCRUBB \ DDSAD_MUTE \ DDSAD_STOP);      end;      /* Make sure we can clear out the main d24: */      call select.d24(lod.d24.#);      write(ScsiBus) = S$RST;    /* issue reset             */      i=real.milliseconds;      do while real.milliseconds<i+10;  end;      write(ScsiBus) = 0;      if  (fastboot = 0)      and (core(maxms.loc) ilt 10000)      then init.timer=real.milliseconds+10000;      else init.timer=real.milliseconds+ 1500;            initialize=initialize+1;     /* move on                        */   end Init3;   Init4:proc swapable;      if real.milliseconds<init.timer   /* wait 10 seconds after reset */      then return;                       call select.d24(lod.d24.#);      if  ((read(ScsiBus )&S$BusMask )<>0)          /* make sure idle    */      or  ((read(ScsiData)&S$DataMask)<>0)      then do;         call log.error('Could Not Reset Buffer Memory D24');         call Abort.Initialize;         return;      end;      port# = 0;      initialize=initialize+1;     /* move on                        */   end Init4;   Init5:proc swapable;            /* initialize all 8 ports         */      if port#<max.ports then do;  /* interrogate ports              */         /* make sure target zero exists */         call select.d24(port.d24.#(port#));         write(ScsiData) =bits(0);    /* target 0           */         write(ScsiBus ) =S$SEL;      /* gnd SEL            */         i=real.milliseconds;         do while ((read(ScsiBus)&S$BSY) =0)            and   (real.milliseconds < i+20);     /* 20 msec           */         end;         if ((read(ScsiBus)&S$BSY)=0) then do;   /* target not there   */            write(ScsiBus )=0;            write(ScsiData)=0;            call log.error('Memory Controller Target Zero Hardware Error');            call Abort.Initialize;            return;         end;         write(ScsiData)=0;         write(ScsiBus )=0;         write(ScsiByte)=0;           /* select our lun 0               */         write(ScsiByte)=port#;       /* that port, nothing enabled     */         do i=0 to 10; end;         call targ0.connect(0);         write(ScsiByte)=port#\lun0.iorst;   /* generate iorst for port */         do i=0 to 10; end;         call targ0.connect(0);         write(ScsiByte)=port#;         port#=port#+1;         return;                  /* try another port            */      end;      port#=0;                     /* initialize for port scan       */      initialize=initialize+1;     /* move on                        */   end Init5;   /* $page - Initialization, cont:  Scan Ports */   /* now scan over all possible */   /* ** PORTS **.  make sure    */   /* port exists and has a      */   /* free bus.  issue reset     */   /* if bad bus state           */   /* mark which ports exist     */   Init6:proc swapable;            /* check ports                    */      /* Interrogate ALL ports here:  up to 8 ports connected to     */      /* buffer memory port,  plus port #8 which is the dedicated    */      /* d24 #1                                                      */      if port# <= max.ports then do;         if  (port.io(port#)=0)    /* if not resetting, look at it   */         then do;            write(ScsiSel) = S$SelectEnable \ Scsibits (port.d24.#(port#));            /* see if D24 exists (only a useful test for port #8)    */            if (read(ScsiSel) & Scsibits(port.d24.#(port#)))=0            then do;               port# = port# + 1;               return;            end;            call select.d24(port.d24.#(port#)); /* mostly to zero d24 & d25 */            i=select.port.or.start.reset(port#,lun0.penable);            if i<>0 then return;   /* reset was started              */            i=wait.for.busfree.or.start.reset(port#);            if i<>0 then return;   /* reset was started              */            /* Make sure bus stays free for 100 msec so that         */            /* devices that are occasionally trying to reselect      */            /* us will be reset!                                     */            i = real.milliseconds;            do while real.milliseconds < i+100;               if  ((read(ScsiBus )&S$BusMask )<>0)               or  ((read(ScsiData)&S$DataMask)<>0)               then do;                  call issue.reset(port#);                  return;               end;            end;            /* Check for target 0 availability only for first 8      */            /* ports                                                 */            if port# < max.ports    /* check target 0 for buf mem    */            then do;                /* ports only                    */               call targ0.connect(1); /* see if target 1 exists         */               i=real.milliseconds;               do while real.milliseconds<i+10;  end;               if ((read(ScsiBus)&S$BSY)=0) then do;   /* not available */                  call deselect(port#);                  port.retry(port#)=port.retry(port#)+1;                  if port.retry(port#)<3            /* try 3 times      */                  then return;                  print 'No response from target 1 for port ',port#;                  /* no response from target 1 - port does not exist    */                  port#=port#+1;                  return;               end;               write(ScsiByte)=0;                /* turn 'go' off     */            end;            port.exists   (port#) = 1;        /* mark port as existing */            port.available(port#) = 1;            /* Check for multi track DDTs only for first 8 ports         */				if port# < max.ports    	/* check target 0 for buf mem     */				then do;               		/* ports only                     */					num.available.ports=num.available.ports+1; /* stats    	 */						/* See if a DDT unit is connected to this port         	 */										#if (inc.multi.udio)		/* multi udio included	  		 	 */						DDT.Lun# = DDT.UDIO.Lun#;         /* look for udio multi trk  */						call DDT.Connect(1);              /* connect to DDT           */							do i=1 to 10; end;                /* short delay              */							if (read(ScsiBus)&S$BSY) <> 0     /* if Busy, then is there   */						then do;								DDT.Hardware.Avail     = 1; 							DDT.MULTI.Avail        = 1;							port.ddt       (port#) = 1;								write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next;							write(ScsiByte) = LAD_Read \ LAD_Revision_#;								port.ddt.rev#  (port#) = Read(ScsiByte);							end;					#endif				end;				            /* Through with port - move on.                        */            call deselect(port#);            port#=port#+1;                    /* move on to next   */            return;         end;         /* else must be resetting - wait for timer:               */         if (real.seconds < port.timer(port#))         then return;            /* waiting                        */         port.io(port#)=0;       /* done with reset                */         port.retry(port#)=port.retry(port#)+1;         if port.retry(port#)>3 then do;            call log.error('Could not RESET Direct-to-Disk Port #');            call append.decimal.number(port#);            call Abort.Initialize;            return;         end;         return;      end;      port#=0;                    /* reset port # for next block */      port.track#=0;      initialize=initialize+1;    /* move on                     */   end Init6;      /* $page - Initialization - scan ports again */   /* Scan all PORTS one more time. */   /* For every available port,     */   /* indicate its tracks exist.    */   /* Poll for Targets/Luns         */   /* and set up track.info         */   /* for each drive for each track */		/* Note: we begin the day by		*/	/* assuming that all drives		*/	/* exist.  Later on we 				*/	/* interrogate for them and		*/	/* mark them as non-existing		*/	/* if they are not there...		*/   Init7:proc swapable;              /* set up drive exists table      */      if port#<max.ports then do;         if port.exists(port#)<>0         then do;                    /* port is there                  */            /* At this point,  only interrogate drives for up to  */            /* two tracks per port.   This will locate all drives */            /* that the software supports.   Later on we will     */            /* distribute the available drives amongst the        */            /* desired tracks to achieve 1 track/drive (long      */            /* configuration),  2 tracks/drive (normal            */            /* configuration),  or 4 tracks/drive (4-track        */            /* configuration).                                    */            do while (port.track# < tracks.per.port);               /* compute trk #: */               track# = port#*tracks.per.port + port.track#;               if track# < max.tracks   /* check for someone trying to */               then do;                 /* do a 32 track system        */                                        /* before we are ready         */                                        /* for it                      */                  track.exists(track#)=1;            /* if port exists    */                                                     /* then assume track */                                                     /* exists (for now)  */                  baseadr = track.base.adr(track#);  /* check for voice   */                  if port.available(port#)=0         /* and memory        */                  then do;                           /* must be bad bus   */                     track.status(track#)=port.status(track#);                  end;                  else if track# >= (polynumv - Base.Voice#)                  then do;            /* no voice for track               */                     track.status(track#)=S$NoVoiceCard;                  end;                  else if (baseadr+rec.base+rec.base) igt polyamount                  then do;                     track.status(track#)=S$NoMemory;                  end;                  else do;            /* port is available - poll         */                     track.available(track#)=1;  /* assume available      */                     tptr=track#*total.stride;                     do ldrive# = 0 to 1;        /* configure for 2 drives/trk */                        call setup.drive.config(6-port.track#-shl(ldrive#,1));																/* Start the format operation here so all the formats get done	*/								/* in parallel																	*/																if  ((format.drives == 1   )								and  (erase1        == 3456)								and  (erase2        == 5432)) 								{									i=Inquire;                   /* perform inquiry					*/									if (i == 0)		  				  /* if device is a disk			*/									{									  /* then mark for format			*/										track.drive.exists        = track.drive.exists        | (8 | 64);										num.start.commands.to.do  = num.start.commands.to.do  + 1;										num.format.commands.to.do = num.format.commands.to.do + 1;									}								}								                        tptr = tptr + track.info.stride;                     end;                     /* set up two entries for tapes */                     /* use last two entries         */                                          tptr=(track#*total.stride)                         +(max.drives.per.track*track.info.stride);                     call setup.drive.config(1);                     tptr=(track#*total.stride)                         +((max.drives.per.track+1)*track.info.stride);                     call setup.drive.config(2);                  end;               end;               port.track#=port.track#+1;            end;         end;         port#=port#+1;                /* next port */         port.track#=0;                /* ptrack 0  */         return;      end;		if  ((format.drives == 1   )		and  (erase1        == 3456)		and  (erase2        == 5432))       	initialize=initialize+1;		else      	initialize=initialize+2;		      track# =0;      ldrive#=0;   end Init7;	/* Handle format of drives.  Poll any drives being formatted to wait for the */	/* format to complete																		  */		/* We begin by issueing a start unit for each drive.  Then we issue a		  */	/* format for each drive.  The following loop iterates these processes		  */	/* along.																						  */	   Init7A:proc swapable;		if ((num.start.commands.to.do  == 0)		/* move on to next state when	  */		&&  (num.format.commands.to.do == 0))		/* all start & formats have	  */		{														/* been done						  */      	initialize = initialize+1;			track#     = 0;			ldrive#    = 0;			return;		}		do track# = 0 to max.tracks-1;      	if (track.available(track#) != 0)			{				do ldrive# = 0 to max.drives.per.track-1;               tptr  = track#*total.stride+ldrive#*track.info.stride;					port# = track.port#;										/* Wait for any io to complete */										if (port.io(port#) != 0)					    	/* if command was issued 			*/					{						if (port.io.track#(port#) != (track# + shl(ldrive#, 8)))							;													/* chill if not ourselves...		*/						else if (port.io(port#) == 1)		 			/* reset had been issued			*/						{                     if (real.seconds >= port.timer(port#))	/* see if reset timer is up		*/								port.io(port#) = 0;						}												else if (port.io(port#) == 7)		 			/* start unit had been issued		*/						{                     i = Check.For.Start.Unit.Result;  		/* see if start unit completed  	*/                     if (i == S$NoReqYet)					 		/* wait for req...					*/								;														else if (i == S$Reissue)			 		/* re-issue on unit atten       	*/							{                        port.io(port#) = 0;                              							   i = Issue.Start.Unit(0,1); 	 		/* issue command again on unit attention */															if (i == 0)							 		/* if issue ok, poll	 				*/								{									port.io(port#) = 7;						  		 	port.io.track#(port#) = track# + shl(ldrive#, 8);								}																else											/* else bombed; done					*/									num.start.commands.to.do = num.start.commands.to.do - 1;							}														else										  		/* else must be done					*/							{													/* hope we started up ok....		*/                        port.io(port#) = 0;       								num.start.commands.to.do = num.start.commands.to.do - 1;							}						}												else if (port.io(port#) == 9)					/* else format had been issued   */						{							call select.d24(track.d24#);         	/* select d24 for drive */							i=select.port.or.start.reset(port#, lun0.penable);														if (i != 0)										/* big bad trouble					*/							{								port.io(port#) = 0;								num.format.commands.to.do = num.format.commands.to.do - 1;							}														else if ((read(ScsiBus)&S$REQ) = 0)	 	/* if no req: wait		 			*/									call deselect(port#);														else							{								call deselect(port#);    				/* unconnect to get free bus  	*/															i = nondatacommand(S$FormatUnit, shl(track.lun#,5), 0, 0, 0, -1);																port.io(port#) = 0;								num.format.commands.to.do = num.format.commands.to.do - 1;																/* Retry on unit attentions in all cases */																if  ((i == (S$CheckCondition | shl(S$UnitAttention, 8)))								and  (format.drives == 1   )								and  (erase1        == 3456)								and  (erase2        == 5432)) 								{									i = Issue.Format.Unit;																		if (i == 0)									{										port.io       (port#) = 9;						   			port.io.track#(port#) = track# + shl(ldrive#, 8);										num.format.commands.to.do = num.format.commands.to.do + 1;									}								}							}						}					}										/* Issue a start unit in case it has spun down */					               else if ((track.drive.exists & 8) != 0)					{						i = Issue.Start.Unit(0,1);  					/* start it up        */						track.drive.exists = track.drive.exists xor 8;												if (i == 0)											/* if issue ok, poll	 */						{	                  port.io       (port#) = 7;						   port.io.track#(port#) = track# + shl(ldrive#, 8);						}						else													/* else bombed			 */							num.start.commands.to.do = num.start.commands.to.do - 1;					}					               else if ((track.drive.exists & 64) != 0)					{						Issue.Format.Unit();						track.drive.exists = track.drive.exists xor 64;												if (i == 0)											/* if issue ok, poll	 */						{	                  port.io       (port#) = 9;						   port.io.track#(port#) = track# + shl(ldrive#, 8);						}												else													/* else bombed			 */							num.format.commands.to.do = num.format.commands.to.do - 1;					}				}			}		}   end Init7A;   /* $page - Initialization - scan for Tracks */   /* now scan each TRACK    */   /* perform initialization */   /* commands on each drive */   /* (inquire, capacity,    */   /*  readdata)             */   /* mark unavailable if    */   /* any errors             */	/* Note: we begin the day by		*/	/* assuming that all drives		*/	/* exist.  Later on we 				*/	/* interrogate for them and		*/	/* mark them as non-existing		*/	/* if they are not there...		*/    Init8:proc swapable;           /* read info from each track      */      if track#<max.tracks then do;         if  (track#)              /* if this is odd track           */         and (track.available(track# xor 1)=0)  /* and corresponding even track is not available */         then do;                               /* then bomb out here in case track is long config */            track.available(track#)=0;            track.command(track#)=track.command(track# xor 1); /* copy error from track 0 */            track.status (track#)=track.status (track# xor 1); /* to track 1 */         end;         if track.available(track#)<>0         then do;            do while ldrive# < max.drives.per.track; /* look at disks only */               tptr=track#*total.stride+ldrive#*track.info.stride;               if (track.drive.exists != 0)  	  /* make sure it works */					{                  port#=track.port#;              /* check port         */                  if port.io(port#)=0 then do;    /* check drive        */                     if  ( fastboot <> 0 )        /* fast load          */                     and ((track#      )          /* and odd track      */                     or   (ldrive# <> 0))         /* or second drive    */                     then do;                        if track#                 /* odd track - skip   */                        then track.available(track#)=0; /* track not avail */                        else do;                           track.drive.exists = 0;                           ldrive# = ldrive# + 1;     /* else configured, but not there */                        end;                        return;                     end;                     i=Inquire;                   /* check type         */                     if i=S$BUSY then do;         /* if busy,  retry    */                        port.count(port#) = port.count(port#) + 1;                        if port.count(port#) < 5  /* try 10-15 seconds  */                        then do;                  /* total of 3 times   */                           port.io   (port#)=8;                           port.timer(port#)=real.seconds+3;                           return;                        end;                     end;                     port.count(port#) = 0;       /* reset count        */                     if i<>0 then do;             /* couldn't inquire   */                       							   if port.io(port#)=1       /* if we did a reset  */                        then return;              /* then wait for it   */                       							   if ((i == S$SelFailed)			/* speed up dismounting by moving on	*/								&&  (dismount.drives != 0))	/* to next track as soon as one			*/								{										/* selection failed							*/									track.available(track#) = 0;									return;								}															   track.retry(track#)=track.retry(track#)+1;                       							   if ((i <> S$SelFailed))   /* if drive there     */                        or ((ldrive#       =0)    /* or looking for     */                        and ((track#&1)    =0))   /* first drive on port */                        or (track.retry(track#)=1)/* always 1 retry/trk */                        then do;                  /* even track         */                           if (track.retry(track#)<=2) /* give drive a chance */                           then do;                              port.io   (port#)=8;                              port.timer(port#)=real.seconds+3;                              return;                /* to change it's mind */                           end;                        end;                        								if (ldrive#=0)              /* first drive dead    */                        then track.available(track#)=0; /* track not avail */                        else do;                           track.drive.exists = 0;                           if  (track.command(track#)=S$Inquiry)                           and (track.status (track#)=S$SelFailed)                           then do;                              track.command(track#)=0;                              track.status (track#)=0;                           end;                           ldrive# = ldrive# + 1;     /* else configured, but not there */                        end;                        return;                     end;                     print 'Disk Drive: Track:',track#,'  Target:',track.target#,'  ',string(InquiryDataCode);							/* If dismounting, sleep the drive or eject the media, as appropriate */														if (dismount.drives != 0)	  /* if dismounting, do an eject or sleep here.... */							{								if ((InquiryRMBCode & 128) != 0)		/* allow media removal now				*/									Issue.Prevent.Allow(0);																if ((InquiryRMBCode & 128) != 0)		/* if removable media, eject it		*/                        	i=Issue.Eject.Unit;													else                        	i=Issue.Stop.Unit(1);				/* else just stop it						*/                       							   if i<>0 then do;          				/* if couldn't issue, then done		*/                           if port.io(port#)=1    				/* if we did a reset  					*/                           then return;          				/* then wait for it   					*/                            track.available(track#) = 0; 		/* ding processing this track			*/																				/* if we couln't issue the command  */                           return;                        end;                       							   port.io   (port#)=7;						/* wait for stop/eject to do its		*/                        port.timer(port#)=real.seconds+90;	/* thang...									*/                        return;							}                     i=Test.Unit.Ready;           /* see if off  */                     if i<>0 then do;             /* start it    */                        track.starts(track#) = track.starts(track#) + 1;                        if track.starts(track#) >= 4                        then do;                           call log.error('Could not turn on Track');                           call append.decimal.number(track#+1);                           call append.log.string(' Drive ');                           call append.decimal.number(ldrive#);                           if  (track.status (track#) = 0)                           and (track.command(track#) = 0)                           then do;                              track.command (track#) = S$StartStop;                              track.status  (track#) = -1;                           end;                           track.available(track#)=0; /* could not start it up    */                           return;                        end;                        if port.io(port#)=1       /* if we did a reset  */                        then return;              /* then wait for it   */                        i=Issue.Start.Unit(0,1);  /* start it up        */                        if i<>0 then do;          /* error */                           if port.io(port#)=1    /* if we did a reset  */                           then return;           /* then wait for it   */                           track.retry(track#)=track.retry(track#)+1;                           if track.retry(track#)<=3  /* give drive a chance      */                           then do;               /* to change it's mind      */                              port.io   (port#)=8;                              port.timer(port#)=real.seconds+3;                              return;             /* to change it's mind */                           end;                           track.available(track#)=0;/* could not start it up    */                           return;                        end;                        track.drive.exists = track.drive.exists  and (not(2)); /* no need to rezero unit */                        call log.error('Turning On Track ');                        call append.decimal.number(track#+1);                        call append.log.string(' Drive ');                        call append.decimal.number(ldrive#);                        port.io   (port#)=7;                        port.timer(port#)=real.seconds+90;                        return;                     end;                     /* issue rezero unit now */                     if Rezero.WrenIVs                     then do;                        if (track.drive.exists&2) <> 0                        then do;                           i = Send.Message.To.Target(S$ResetDev);                           if i <> 0 then do;                              call check.and.log.retry;                              return;                           end;                           /* resero message given - wait 1 */                           /* second                        */                           track.drive.exists = track.drive.exists xor 2;                           port.io     (port#) = 8;                           port.timer  (port#) = real.seconds+2;                           return;                                        end;                     end;                     /* check capacity */                     i=readcapacity;                     if i<>0 then do;       /* capacity error */                        call check.and.log.retry;                        return;                     end;                     track.smsb    =0;   /* zero out here               */                     track.slsb    =0;   /* size measured below         */                     track.emsb    =cap.msb;                       track.elsb    =cap.lsb;                     /* read 1 sector */                     i=readdata(0,0,misc.buf,256);                     if i<>0 then do;    /* readdata error              */                        call check.and.log.retry;                        return;                     end;							/* lock media in place if removable						*/							if ((InquiryRMBCode & 128) != 0)		/* if removable media, lock media in	*/							{												/* place and note that it is a			*/								Issue.Prevent.Allow(1);				/* removable media							*/																track.drive.exists = track.drive.exists | 32;							}								                     /* check for long configuration here */                     if  ((track#&1)=0)              /* if this is even (first) track */                     and (ldrive#   =0)              /* and first drive of that */                     then do;                        /* check for long config */                        if  ((misc.buf(0)=magic#1)   /* track contains valid info */                        and  (misc.buf(1)=magic#2))                        or  ((misc.buf(0)=magic#2)                        and  (misc.buf(1)=magic#1))                        then do;                           if  ((erase1<>3456)     /* if not start of erase */                           or   (erase2<>5432))                               and (misc.buf(4)=1)     /* drive config is for long */                           then do;                /* set up for long config */                              tptr=track#*total.stride+track.info.stride;  /* configur drive 1 differently */                              do i = 1 to max.drives.per.track - 1;  /* configure for 4 drives/trk now */                                 call setup.drive.config(6-i);                                 tptr = tptr + track.info.stride;                              end;                              longconfig(track#)=1;                              /* restore tptr to avoid serious bugs below: */                              tptr=track#*total.stride+ldrive#*track.info.stride;                              track.available(track# xor 1)=0;  /* odd track is now not available */                           end;                           else if  ((erase1<>3456)   /* if not start of erase */                           or        (erase2<>5432))                             and      (misc.buf(4)=2)   /* drive config is for 4 tracks/drive */                           then do;                   /* then save that info aside */                              longconfig(track#)=2;                           end;                        end;                     end;                  end;                  else if port.io(port#)=1       /* performed a reset */                  then do;                     if (real.seconds<port.timer(port#))                     then return;              /* waiting                        */                     port.io(port#)=0;                     track.retry(track#)=track.retry(track#)+1;                     if track.retry(track#)<3  /* give drive a chance      */                     then return;              /* to change it's mind      */                     track.status   (track#) = S$BadBusState;                     track.available(track#) = 0;  /* could not start it up    */                     return;                  end;                  else if port.io(port#)=7   /* issued a start/stop/eject unit command */                  then do;                   /* see if start/stop/eject unit completed */                     i = Check.For.Start.Unit.Result;  /* see if start unit completed */                     if (i=S$NoReqYet)                     then do;                   /* no request yet */                        if real.seconds < port.timer(port#)                        then do;                           return;              /* wait           */                        end;                       							   port.io(port#)=0;       /* clean up       */																if (dismount.drives != 0)		/* oops: couldn't issue stop or eject? */								{								 	track.available(track#)=0;									return;								}                        if track.retry(track#)<2    /* give drive a chance */                        then do;                           call issue.reset(port#); /* issue reset         */                           return;                  /* to turn on          */                        end;                        track.status   (track#)=S$NoReqYet; /* drive did not turn on */                        track.available(track#)=0;                        return;                     end;							if (dismount.drives != 0)		/* handle dismounting			*/							{								if (i != 0)						/* hmm... couldn't stop/eject */								{                      	   port.io(port#)=0;       									track.available(track#)=0;									return;								}								                      	port.io(port#)=0;         /* done with eject/stop                  */              				ldrive#=ldrive#+1;		  /* ok: drive has been stopped or ejected */																return;						  /* move on to next drive						 */							}                     if (i=S$Reissue)             /* reissue start unit command on unit attention */                     then do;                        port.io(port#)=0;                               i=Issue.Start.Unit(0,1);  /* issue command again on unit attention */                        if i<>0 then do;          /* error */                           call check.and.log.retry;                           return;                        end;                        port.io   (port#)=7;                        port.timer(port#)=real.seconds+90;                        return;                     end;                     if i=0 then do;            /* drive is running */                        /* wait 2 seconds after start unit to avoid */                        /* wren iv crash bug                        */                        port.io(port#)=8;       /* done with start unit attempt */                        port.timer(port#) = real.seconds + 2;                        return;                 /* return above to do inquire/test unit ready/readcapacity */                     end;                     if port.io(port#)=1       /* if we did a reset  */                     then return;              /* then wait for it   */                     port.io(port#)=0;         /* bad status         */                     track.retry(track#)=track.retry(track#)+1;                     if track.retry(track#)<3  /* give drive a chance */                     then return;              /* to change it's mind */                     track.available(track#)=0;/* must not be a disk  */                     return;                  end;                  else if port.io(port#)=8                  then do;                     if (real.seconds < port.timer(port#))                     then return;              /* waiting                        */                     port.io(port#)=0;                     return;                  end;               }               ldrive#=ldrive#+1;            end;            /* $page - Check for existence of tape drives */				if (dismount.drives != 0)			/* speed up dismount by moving      */				{											/* on to next drive instead of		*/					track.available(track#) = 0;	/* checking for tapes					*/					return;				}			   do while ldrive# < (max.drives.per.track+max.tapes.per.track);  /* look at tapes now */               tptr=track#*total.stride+ldrive#*track.info.stride;               if track.drive.exists<>0 then do;  /* see if tape drive is configured in */                  port#=track.port#;              /* check port         */                  if port.io(port#)=0 then do;    /* check tape         */                     i=Inquire;                   /* check type         */                     if i=S$BUSY then do;         /* if busy,  retry    */                        port.count(port#) = port.count(port#) + 1;                        if port.count(port#) < 60 /* try for 5 minutes  */                        then do;                  /* in case cart is    */                           port.io   (port#)=8;   /* stuck              */                           port.timer(port#)=real.seconds+5;                           return;                        end;                     end;                     port.count(port#) = 0;       /* reset count        */							if (((i == 1))					  								/* if device says it is a tape		*/							||  ((i == 0) && ((InquiryRMBCode & 128) != 0)))	/* or removable media disk				*/							{																	/* then allow it for backups			*/								print 'Tape Drive: Track:',track#,'  Target:',track.target#,'  ',string(InquiryDataCode);									any.tape.found = 1;								if ldrive# <> 0								then any.tape2.found = 1;							}							else							{                        track.drive.exists = 0;                        if  (track.command(track#)=S$Inquiry)                        and (track.status (track#)=S$SelFailed)                        then do;                           track.command(track#)=0;                           track.status (track#)=0;                        end;                        ldrive# = ldrive# + 1;     /* else configured, but not there */                        return;                    }                  end;                  /* Else must be waiting for busy */                  else do;                     if (real.seconds < port.timer(port#))                     then return;                     port.io(port#)=0;                     return;                  end;               end;               ldrive#=ldrive#+1;            end;            /* $page - good track */            /* if all drives are up and running */            /* count track as available         */            /* compute total size,  and offsets */            /* for each drive                   */				if (dismount.drives != 0)				/* if dismount desired, drives have been stopped.	*/            	track.available(track#)=0;			/* mark track as unavailable								*/								else											/* else track is available									*/				{					num.available.tracks=num.available.tracks+1;						track.numsec.msb(track#)=0;   /* get ready to total up */					track.numsec.lsb(track#)=0;   /* # of sectors          */						do ldrive#=0 to max.drives.per.track - 1;  /* skip tape here */						tptr=track#*total.stride+ldrive#*track.info.stride;						if track.drive.exists<>0 then do;							track.smsb=track.numsec.msb(track#);							track.slsb=track.numsec.lsb(track#);							track.numsec.msb(track#)=track.numsec.msb(track#)+track.emsb;							track.numsec.lsb(track#)=track.numsec.lsb(track#)+track.elsb;							if track.numsec.lsb(track#) ilt track.elsb							then track.numsec.msb(track#)=track.numsec.msb(track#)+1;						end;					end;				}         end;         track#  = track#+1;         ldrive# = 0;         return;      end;      ldrive#    = 0;               /* initialize ldrive# for next step */      initialize = initialize+1;    /* go there                         */   end Init8;   /* $page - Check for existence of auxiliary tape drives   */   /* on dedicated D24:                                      */   init8A: proc swapable;		if (dismount.drives != 0)		/* speed up dismounting by skipping	*/		{										/* check of aux port drives			*/      	initialize=initialize+1;			return;		}      if ldrive# < max.tapes.per.track     /* check two aux tapes  */      then do;         tptr=tape1.tptr + (ldrive# * track.info.stride);         if track.drive.exists<>0 then do;  /* see if tape drive is configured in */            port#  = track.port#;           /* get max.ports         */            track# = track.track#;          /* get track# for errors */            if port.available(port#) = 0    /* if no port            */            then track.drive.exists = 0;            else do;                        /* look at it            */               if port.io(port#)=0 then do;    /* check tape         */                  i=Inquire;                   /* check type         */                  if i=S$BUSY then do;         /* if busy,  retry    */                     port.count(port#) = port.count(port#) + 1;                     if port.count(port#) < 60 /* try for 5 minutes  */                     then do;                  /* in case cart is    */                        port.io   (port#)=8;   /* stuck              */                        port.timer(port#)=real.seconds+5;                        return;                     end;                  end;                  port.count(port#) = 0;       /* reset count        */						if (((i == 1))					  								/* if device says it is a tape		*/						||  ((i == 0) && ((InquiryRMBCode & 128) != 0)))	/* or removable media disk				*/						{                     print 'Aux  Tape :               Target:',track.target#,'  ',string(InquiryDataCode);                     any.tape.found = 1;                     if ldrive# <> 0                     then any.tape2.found = 1;						}												else						{                     track.drive.exists = 0;                     if  (track.command(track#)=S$Inquiry)                     and (track.status (track#)=S$SelFailed)                     then do;                        track.command(track#)=0;                        track.status (track#)=0;                     end;						}               end;               /* Else must be waiting for busy */               else do;                  if (real.seconds < port.timer(port#))                  then return;                  port.io(port#)=0;                  return;               end;            end;         end;         ldrive# = ldrive#+1;     /* move on to next drive next time */         return;                  /* around                          */      end;      /* If there are absolutely no tape drives in the system        */      /* but the ddt.d24 is available,  then assume aux tape1 is     */      /* connected but turned off.                                   */      if  (port.available(max.ports) <> 0)  /* if aux d24 avail      */      and (any.tape.found             = 0)  /* no tapes at all       */      then do;         tptr=tape1.tptr;         track.drive.exists = 1;      end;      /* Mark port.available(max.ports) = 0 if there are no tapes    */      /* available on it.                                            */      else do;         tptr = tape1.tptr; i = track.drive.exists;         tptr = tape2.tptr; j = track.drive.exists;         if (i\j)=0    /* if no aux tapes at all, stop looking for them */         then port.available(max.ports) = 0;      end;      initialize=initialize+1;   end Init8A;   /* Check through available tracks to see if no odd tracks */   /* are available.  if this is the case,  then set up      */   /* the 1/2 drive configuration (i.e. two tracks on 1      */   /* drive).   Also see if desired configuration is 4       */   /* tracks per port.   If so,  set up that configuration   */   Init9:proc swapable;                    /* check for 1/2 drive configuration */      i=0; j=0; k=0; l=0; m=0;      do track# = 1 to max.tracks-1 by 2;  /* if any odd track is available, */         if track.available(track#)<>0     /* then system obviously contains */         then i=1;                         /* more than 1 drive on a port    */      end;      do track# = 0 to max.tracks-1 by 2;  /* see if some even tracks available */         if track.available(track#)<>0         then do;            j=1;                           /* set flag - yes some even tracks are available       */            if longconfig(track#) = 1      /* disallow 1/2 drive configuration                    */            then i=1;                      /* if user has requested a long configuration          */         end;      end;      do track# = 0 to max.tracks-1;       /* also find largest available */         if track.available(track#)<>0     /* track #                     */         then do;            m=track#;            if longconfig(track#) = 2      /* keep track of how many drives perfer 4 tracks/drive */            then k = k + 1;                /* and how many prefer two tracks/drive                */            else l = l + 1;         end;      end;		/* basic configuration set up above was 2 drives for each track with 2 tracks per port.		*/		/* That is, a total of 4 drives were initially configures.												*/				/* If none of the odd dives exists, then we split the disk drives associated with the first	*/		/* track on each port.  That is, we duplicate the tptr table, and provide an offset to the	*/		/* second track.																										*/				/* Later on we will further mangle the data if in fact there should be 4 tracks on 1 drive	*/		      if (j<>0) and (i=0) then do;         /* some even tracks, no odd tracks */         do track# = 0 to max.tracks-1 by 2;  /* split up the disk drive */            call blockmove(location(addr(track.info((track#  )*total.stride))),                           location(addr(track.info((track#+1)*total.stride))),                           total.stride);     /* duplicate configuration */            track.numsec.lsb(track#  ) = shr(track.numsec.lsb(track#), 1)                                       \ shl(track.numsec.msb(track#),15);            track.numsec.msb(track#  ) = shr(track.numsec.msb(track#), 1);            track.data.msb  (track#  ) = 0;            track.data.lsb  (track#  ) = 0;            track.adir.sec  (track#  ) = adir.sec#;            longconfig      (track#+1) = longconfig      (track#);            track.exists    (track#+1) = track.exists    (track#);            track.available (track#+1) = track.available (track#);            track.numsec.msb(track#+1) = track.numsec.msb(track#);            track.numsec.lsb(track#+1) = track.numsec.lsb(track#);            track.data.msb  (track#+1) = track.numsec.msb(track#);            track.data.lsb  (track#+1) = track.numsec.lsb(track#);            track.adir.sec  (track#+1) = adir.sec#+1;            track.retry     (track#+1) = 0;            /* clear out selfailed message for odd tracks,  since we */            /* gave it half of the storage for the even track (i.e.  */            /* missing drive is not counted as error)                */            if  (track.command(track#+1)=S$Inquiry)            and (track.status (track#+1)=S$SelFailed)            then do;               track.command(track#+1)=0;               track.status (track#+1)=0;            end;                        /* clear rezero bits for odd tracks to keep   */            /* rezero from happening twice                */            /* in the case of the 1/2 track configuration */            if Rezero.WrenIVs            then do ldrive#=0 to max.drives.per.track - 1;  /* disks only */               tptr=(track#+1)*total.stride+ldrive#*track.info.stride;               track.drive.exists = track.drive.exists & (not(4));            end;            /* Update track.track# in configuration area: */            do ldrive#=0 to max.entries.per.track-1;               tptr=(track#+1)*total.stride+ldrive#*track.info.stride;               track.track# = (track#+1);            end;         end;         /* twice as many tracks are now available: */         num.available.tracks = shl(num.available.tracks,1);         m = m + 1;           /* largest track is now even 1 larger */      end;      /* normal 1 track per drive or 1 track per 2 drives configuration: */      else do;         do track# = 0 to max.tracks-1;            track.data.msb  (track#  ) = 0;         /* data starts at 0.0  */            track.data.lsb  (track#  ) = 0;            track.adir.sec  (track#  ) = adir.sec#; /* adir goes here      */         end;      end;      /* Now check for MAX TRACKS configuration (4 tracks/port) */      if  (k <> 0)        /* if some drives wanted 4 tracks/port */      and (k >= l)        /* and more did so than did not ...    */      and (m <= shr(max.tracks,1))  /* and room to double tracks */      then do;            /* then set up 4 tracks/port config    */         /* Note: must do this in REVERSE order */         Tracks.Per.Port     = 4;           /* set up for 4 tracks per port */         Buf.Len             = Buf.4track;         Rec.Base            = Rec.4track;         do port# = 0 to max.ports-1;            if port# < 4            then port.track.bits(port#) = bits(port#*4  ) \ bits(port#*4+1)                                        \ bits(port#*4+2) \ bits(port#*4+3);            else port.track.bits(port#) = 0;            port.base.track(port#) = port#*Tracks.Per.Port;         end;         do track# = max.tracks-1 to 0 by -1; /* double each track */            /* move track 7 configuration to track 15      */            /* move track 7 configuration to track 14      */            /* move track 6 configuration to track 13      */            /* move track 6 configuration to track 12      */				/* ......................................      */            /* move track 0 configuration to track  1      */            /* move track 0 configuration to track  0      */            call blockmove(location(addr(track.info((shr(track#,1))*total.stride))),                           location(addr(track.info((    track#   )*total.stride))),                           total.stride);     /* duplicate configuration */            longconfig       (track#) = longconfig       (shr(track#,1));            track.exists     (track#) = track.exists     (shr(track#,1));            track.available  (track#) = track.available  (shr(track#,1));            track.numsec.msb (track#) = track.numsec.msb (shr(track#,1));            track.numsec.lsb (track#) = track.numsec.lsb (shr(track#,1));            track.data.msb   (track#) = track.data.msb   (shr(track#,1));            track.data.lsb   (track#) = track.data.lsb   (shr(track#,1));            track.adir.sec   (track#) = track.adir.sec   (shr(track#,1));            track.command    (track#) = track.command    (shr(track#,1));            track.status     (track#) = track.status     (shr(track#,1));            track.port.ix    (track#) = track#/tracks.per.port;            track.base.adr   (track#) = track#*2*Rec.Base;            track.track.bits (track#) = bits(track# xor 1)                                      \ bits(track# xor 2)                                      \ bits(track# xor 3);            track.retry      (track#) = 0;            /* Now correct numsec, data, adir sec for this track: */            track.numsec.lsb(track#) = shr(track.numsec.lsb(track#), 1)                                     \ shl(track.numsec.msb(track#),15);            track.numsec.msb(track#) = shr(track.numsec.msb(track#), 1);            if track# then do;      /* for odd track - offset data by 1/2 or 1/4 of the drive */               track.data.msb  (track#) = track.data.msb  (track#)                                        + track.numsec.msb(track#);               track.data.lsb  (track#) = track.data.lsb  (track#)                                        + track.numsec.lsb(track#);               if track.data.lsb(track#) ILT track.numsec.lsb(track#)               then track.data.msb(track#) = track.data.msb(track#) + 1;            end;            track.adir.sec  (track#) = adir.sec#                                      + shl(track.adir.sec(track#)-adir.sec#,1)                                     + (track#&1);            /* clear rezero bits for odd tracks to keep   */            /* rezero from happening twice                */            /* in the case of the 1/2 track configuration */            if  (track#        )            and (Rezero.WrenIVs)            then do ldrive#=0 to max.drives.per.track-1;  /* do only for disk drives */               tptr=track#*total.stride+ldrive#*track.info.stride;               track.drive.exists = track.drive.exists & (not(4));            end;            /* and update track.track# in configuration table */            /* to reflect this new assignment:                */            do ldrive#=0 to max.entries.per.track-1;               tptr=track#*total.stride+ldrive#*track.info.stride;               track.track# = track#;            end;            /* see if voice card exists: */            if track# >= (polynumv - Base.Voice#)            then do;            /* no voice for track               */               track.status (track#) = S$NoVoiceCard;               track.command(track#) = 0;            end;         end;         /* twice as many tracks are now available: */         num.available.tracks = shl(num.available.tracks,1);         m = shl(m,1)+1;      end;      initialize=initialize+1;      track# =0;      sec#   =0;   end Init9;   Init10:proc swapable;      /* zero out record buffer for each track */      if track#<max.tracks then do;         if track.available(track#)<>0         then do;            j=rec.base+rec.base-sec#; /* zero out up throu end of record buffer */            if j>32 then j=32;        /* limit to 32                  */            call psmwrite(track.base.adr(track#)+sec#,0);            do i=0 to j-1;               rpc 256;               write(psd) = 0;            end;            sec#=sec#+j;            if sec#<rec.base+rec.base then return;         end;         sec#=0;         track#=track#+1;         return;      end;      initialize=initialize+1;      track# =0;      sec#   =0;      if   ((erase1 = 3456)         /* if doing erase all */      and   (erase2 = 5432))        /* begin with write   */      then sec#=1;   end Init10;