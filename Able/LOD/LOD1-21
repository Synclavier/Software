/* LOD1-21 - Load/Unload, BOUNCE/MIX, playback check, record check	*//* 03/08/91 - ty - removed some unused static variables					*//* 03/08/91 - cj - got rid of clicks/pops for DDSAD						*//* 08/20/90 - cj - Added code for 4 wangs/4 pats							*//* 01/17/90 - CJ - Added code for Tandberg tapes							*//* Start or spin drives on a port */dcl any.drives.sleeping fixed;spin.sleep:proc(port#,track#,opcode) swap;   dcl (port#,track#) fixed static;   dcl (opcode      ) fixed static;   /* 1: load.    0: unload */   abort.check:proc;      if abort.command<>0                  /* force halt to command */      then do;			call finish.port.command(port#);			command.aborted=1;         return 1;      end;      return 0;   end;   do case tape.state(port#);		do;                            /* start of spin or sleep				  */         if errmess=0 then do;            do case(opcode);               call log.error('Spinning down hard drives...');               call log.error('Starting up hard drives...' );            end;            errmess=1;         end;         			port.retry  (port#) = 0;      			port.count  (port#) = 0;         tape.state  (port#)=tape.state(port#)+1;      end;      /* Loop over ports and issue appropriate command */		do;         if abort.check<>0           /* user abort desired                  */         then return;         if (port.count(port#) < max.drives.per.track)			{				tptr=track#*total.stride+port.count(port#)*track.info.stride;				if ((track.drive.exists     != 0)	/* if drive exists and is	 */		      &&  (track.data.msb(track#) == 0)	/* the first one on the		 */            &&  (track.data.lsb(track#) == 0))	/* chain, start or stop		 */				{												/* it								 */            	if (opcode == 0)					{						Issue.Stop.Unit(0);						track.drive.exists = track.drive.exists | 16;						any.drives.sleeping = true;					}               else					{						Issue.Start.Unit(1,0);						track.drive.exists = track.drive.exists & (not(16));						any.drives.sleeping = false;					}				}								port.count(port#) = port.count(port#) + 1;				return;			}						port.count(port#) = 0;			/* done with this track.  reset port.count	*/         call finish.command(track#);	/* for next track and move on to it...			*/      end;   end;end spin.sleep;/* load/unload tape */loadunload:proc(port#,track#,opcode) swap;   dcl (port#,track#) fixed static;   dcl (opcode      ) fixed static;   /* 1: load.    0: unload */   abort.check:proc;      if abort.command<>0                  /* force halt to command */      then do;         if port.available(max.ports) = 0  /* if no aux tape        */         then interrogate.tapes = 0;       /* then done looking     */         if (port# = max.ports)            /* if this is aux tape   */         then interrogate.tapes = 0;       /* then stop it.         */         else if interrogate.tapes = 0     /* else if through       */         then do;                          /* with aux, then quit   */            call finish.port.command(port#);            command.aborted=1;         end;         return 1;      end;      return 0;   end;   do case tape.state(port#);/*1*/ do;                            /* start of load for this port/track */         if log.buf(0)<>0            /* get message out                   */         then return;         port.retry  (port#) = 0;               tape.type   (port#) = 0;		 	zero.jaz.position(port#);	 /* zero pos on either load or eject  */         tape.state  (port#)=tape.state(port#)+1;         if errmess=0 then do;            do case(opcode);               call log.error('Starting Eject');               call log.error('Starting Home' );            end;            errmess=1;         end;      end;      /* Begin by trying to do an inquiry to try to set the tape type       */      /* to TAN if it is:                                                   *//*2*/ do;         if abort.check<>0           /* user abort desired                  */         then return;         if port.retry(port#)>=2     /* if no luck, proceed to load/unload  */         then do;                    /* anyways.                            */            port.retry (port#) = 0;            tape.state (port#) = tape.state(port#) + 1;            return;         end;         start.tape.command(port#, track#, Tape.Inquiry, 9);  /* start inquiry                */      end;/*3*/ do;                            /* start tape load/unload              */         if abort.check<>0           /* user abort desired                  */         then return;         if port.retry(port#)>=2     /* try twice									 */         then do;            port.retry (port#) = 0;            tape.state (port#) = tape.state(port#) + 1;            return;         end;			if (opcode == 1)															/* if loading					*/       		start.tape.command(port#, track#, Tape.LoadUnload, 1);	/* then load or spin up		*/						else	if (tape.type(port#) == type.jaz)							/* else unload for jaz		*/				start.tape.command(port#, track#, Tape.LoadUnload, 2);  	/* means stop & eject		*/						else																			/* else unload for other	*/				start.tape.command(port#, track#, Tape.LoadUnload, 0);  	/* tapes means stop			*/      end;/*4*/ do;         /* Go back and load/unload tape 2 if we need to: */         if (tape.to.use(port#) = 0)  /* if we just loaded/unloaded tape */         then do;                     /* then return to load/unload      */            tape.to.use(port#) = 1;   /* tape 2. Set tape.to.use,        */            tape.type  (port#) = 0;   /* clear tape type & retry         */            port.retry (port#) = 0;                  tape.state (port#) = tape.state(port#) - 2;            return;         end;         if port.available(max.ports) = 0       /* if no aux tape        */         then interrogate.tapes = 0;            /* then done looking     */         if (port# = max.ports)                 /* if this is aux tape   */         then interrogate.tapes = 0;            /* then stop it.         */         else if interrogate.tapes = 0          /* else if done with aux */         then call finish.port.command(port#);  /* tape, then quit       */      end;                                      /* else hang here for    */                                                /* aux to finish         */   end;end loadunload;/* $page - bounce/mix (unimplemented at the moment) */bouncemix:proc(port#,track#) swap;   dcl (port#,track#) fixed static;   return;  /* for now, due to space limitations */   dcl (b.state)      fixed;      /* bounce state */   dcl (m.state)      fixed;      /* mix    state */   dcl (d.state)      fixed;      /* dest   state */   dcl (b.ready)      fixed;      /* bounce buf ready */   dcl (m.ready)      fixed;      /* mix    buf ready */   dcl (d.ready)      fixed;      /* dest   buf ready */   dcl (b.nonmt)      fixed;      /* bounce buffer non-empty */   dcl (m.nonmt)      fixed;      /* mix    buffer non-empty */   dcl (d.nonmt)      fixed;      /* dest   buffer non-empty */   dcl b.type    lit '(bounce.mix.rec(bounce.source.type))';                        dcl b.s.msb   lit '(bounce.mix.rec(bounce.source.s.msb))';   dcl b.s.lsb   lit '(bounce.mix.rec(bounce.source.s.lsb))';   dcl b.e.msb   lit '(bounce.mix.rec(bounce.source.e.msb))';   dcl b.e.lsb   lit '(bounce.mix.rec(bounce.source.e.lsb))';                        dcl b.trk#    lit '(bounce.mix.rec(bounce.source.trk#))';   dcl b.vol     lit '(bounce.mix.rec(bounce.source.vol))';   dcl b.fade    lit '(bounce.mix.rec(bounce.source.fade))';                                             dcl m.type    lit '(bounce.mix.rec(mix.source.type))';                                         dcl m.s.msb   lit '(bounce.mix.rec(mix.source.s.msb))';   dcl m.s.lsb   lit '(bounce.mix.rec(mix.source.s.lsb))';   dcl m.e.msb   lit '(bounce.mix.rec(mix.source.e.msb))';   dcl m.e.lsb   lit '(bounce.mix.rec(mix.source.e.lsb))';                        dcl m.trk#    lit '(bounce.mix.rec(mix.source.trk#))';   dcl m.vol     lit '(bounce.mix.rec(mix.source.vol))';   dcl m.fade    lit '(bounce.mix.rec(mix.source.fade))';   dcl d.type    lit '(bounce.mix.rec(mix.dest.type))';                                         dcl d.s.msb   lit '(bounce.mix.rec(mix.dest.s.msb))';   dcl d.s.lsb   lit '(bounce.mix.rec(mix.dest.s.lsb))';   dcl d.e.msb   lit '(bounce.mix.rec(mix.dest.e.msb))';   dcl d.e.lsb   lit '(bounce.mix.rec(mix.dest.e.lsb))';                                         dcl d.trk#    lit '(bounce.mix.rec(mix.dest.trk#))';   dcl d.vol     lit '(bounce.mix.rec(mix.dest.vol))';   dcl d.fade    lit '(bounce.mix.rec(mix.dest.fade))';   abort.check:proc;      if abort.command<>0         /* bombed out on other track           */      then do;         call finish.command(track#);         command.aborted=1;         return 1;      end;      return 0;   end;   if log.buf(0)<>0               /* make sure error messages happen     */   then return;   if errmess=0 then do;          /* initialize on first time through    */      call log.error('Starting Bounce/Mix');      errmess=1;      b.state=0;                  /* initialize states for each track    */      m.state=0;      d.state=0;      port.retry  (b.trk#)=0;     /* zero retry,  even if command is     */      port.retry  (m.trk#)=0;     /* outstanding on these other tracks   */      port.retry  (d.trk#)=0;            b.ready=0;      m.ready=0;      d.ready=0;      print bounce.mix.rec(bounce.source.type);      print bounce.mix.rec(bounce.source.s.msb),bounce.mix.rec(bounce.source.s.lsb);      print bounce.mix.rec(bounce.source.e.msb),bounce.mix.rec(bounce.source.e.lsb);      print bounce.mix.rec(bounce.source.trk#);      print bounce.mix.rec(bounce.source.vol);      print bounce.mix.rec(bounce.source.fade);      print;      print bounce.mix.rec(mix.source.type);      print bounce.mix.rec(mix.source.s.msb),bounce.mix.rec(mix.source.s.lsb);      print bounce.mix.rec(mix.source.e.msb),bounce.mix.rec(mix.source.e.lsb);      print bounce.mix.rec(mix.source.trk#);      print bounce.mix.rec(mix.source.vol);      print bounce.mix.rec(mix.source.fade);      print;      print bounce.mix.rec(mix.dest.type);      print bounce.mix.rec(mix.dest.s.msb),bounce.mix.rec(mix.dest.s.lsb);      print bounce.mix.rec(mix.dest.e.msb),bounce.mix.rec(mix.dest.e.lsb);      print bounce.mix.rec(mix.dest.trk#);      print bounce.mix.rec(mix.dest.vol);      print bounce.mix.rec(mix.dest.fade);   end;   if abort.check<>0           /* user abort desired                  */   then return;   if alt.tdir.valid=0         /* wait for valid alternate tdir       */   then return;                   if track#=b.trk# then do;   /* see if this is bounce source        */      if b.ready=0 then do;    /* see if bounce buffer ready          */         b.ready=1;            /* bounce buffer is now ready          */         b.nonmt=0;            /* but has no contents                 */      end;   end;   if  (track#=m.trk#)         /* see if this is mix source           */   and (port.io(port#)=0)      /* check to make sure it is not the    */   then do;                    /* same as bounce source and command   */                               /* was just issued above               */      if m.ready=0 then do;    /* see if mix    buffer ready          */         m.ready=1;            /* mix buffer is now ready             */         m.nonmt=0;            /* but has no contents                 */      end;   end;   if  (track#=d.trk#)         /* see if this is dest track            */   and (port.io(port#)=0)      /* also see if command was issued       */   then do;                    /* for this track for bounce/mix source */      if d.ready=0 then do;    /* see if dest    buffer ready         */         d.ready=1;            /* dest buffer is now ready            */         d.nonmt=0;            /* but has no contents                 */      end;      if  (b.ready<>0)         /* see if in buffers ready             */      and (m.ready<>0)      and (d.ready<>0)      then do;         call finish.command(b.trk#);         call finish.command(m.trk#);         call finish.command(d.trk#);      end;   end;end bouncemix;/* $page - track command check   *//* when not recording on a track,  process back ground commands *//* such as erase, backup, load                                  */track.command.check:proc (port#,track#); 	/* called only when command.#<>0  */   dcl (port#,track#) fixed;             	/* and command.tracks has bit set */   do case (command.#-1);            		/* branch on command type (c.max)   		*/      call backup.song(port#,track#);      call load.song  (port#,track#);      ;                               		/* erase all - wait for io to complete  	*/      call erase.track(track#);       		/* erase track                          	*/      call erase.track(track#);       		/* erase song: do each track here       	*/      call load.song  (port#,track#); 		/* load track, actually                 	*/      call load.song  (port#,track#); 		/* load all,   actually                 	*/      call load.song  (port#,track#); 		/* verify one song                      	*/      call load.song  (port#,track#); 		/* verify all songs (move to eog)       	*/      call loadunload (port#,track#,1); 	/* load tape (home)                   		*/      call loadunload (port#,track#,0); 	/* unload tape  (eject)               		*/      ;                                 	/* erase long - not used              		*/      call bouncemix  (port#,track#);   	/* bounce/mix                         		*/      ;                                 	/* erase 4trk - not used             		*/      call load.song  (port#,track#);   	/* add to song                        		*/      call load.song  (port#,track#);   	/* add to all songs                   		*/      call load.song  (port#,track#);   	/* show song name                     		*/      call load.song  (port#,track#);   	/* skip forward quickly               		*/      call load.song  (port#,track#);   	/* skip backwards quickly             		*/				;											 	/* dismount: handled by initialize			*/		call spin.sleep (port#, track#, 0);	/* sleep command									*/		call spin.sleep (port#, track#, 1);	/* spin command									*/		;											 	/* format: handled by initialize     		*/      call load.song  (port#,track#);   	/* skip forward all quickly               */   end;end track.command.check;/* $page - track play back check *//* track playback check is called for every idle port whenever *//* the corresponding track is not recording.  the goal of      *//* track playback check is to issue disk commands to fill      *//* the disk buffers as indicated by the global variables       *//* desired.buf1,  desired.buf2,  desired.buf3                  */track.playback.check:proc(port#,track#);    dcl (port#,track#,i) fixed;   dcl (secmsb,seclsb)  fixed;   chunk.check:proc(i);      dcl i fixed;      if  (now.playing=0)          /* if preffilling buffers or trigger playback (vs. actual playback) */      and (now.looping=0)          /* and not looping (we want a high data rate for looping) */      and (i igt trig.chunk)       /* and this is a large read request  */      and ((now.triggering = 0)    /* and either not triggering         */      or   (trig.rate      < 1))   /* or triggering at <= normal rate   */      then i  =  trig.chunk;       /* issue smaller command for speedier start when pressing continue button */      return i;   end chunk.check;   if zap.buffer(track#)<>0 then do;         /* trash contents     */      buf1.len(track#)=0;                    /* on change from cue */      buf2.len(track#)=0;                    /* to source playback */      buf3.len(track#)=0;      clob.len(track#)=0;      track.eof(track#)=0;      if  (now.triggering  <> 0)             /* if triggering or     */      or  (now.playing     <> 0)             /* playing, then fake   */                                             /* as iff we have       */      then do;                               /* filled up to the     */         buf1.msb(track#)=desired.buf1.msb;  /* current offset,      */         buf1.lsb(track#)=desired.buf1.lsb;  /* since we won't       */         buf1.len(track#)=desired.buf2.len;  /* need the prior data  */         track.toss(track#)=1;               /* force refill on stop */      end;      zap.buffer(track#)=0;   end;   /* check for read/write of disk to accomplish */   /* digital transfer:                          */   if (read.track.info&bits(track#))<>0      /* special track info desired */   then do;                                  /* for xfer to synclav        */      /* check for special WRITE of data from poly to disk: */      if  ((track.info.direction&bits(track#))<>0)  /* if write is desired */      then do;                               /* writing data to disk       */         if syn.scsi.data.xfer = Sys#DTDOpt  /* but if transferring to optical */         then return;                        /* then don't write here!!        */         /* read.track.written holds the amount already written.  read.track.len  */         /* holds the total amount we need to write.                              */         if read.track.written(track#) < read.track.len(track#)         then do;                            /* more data to write         */            secmsb = read.track.msb(track#);            seclsb = read.track.lsb(track#) + read.track.written(track#);            if seclsb ilt read.track.written(track#) then secmsb = secmsb + 1;            if  (secmsb = 0) and (seclsb ilt data.sec#)            then stop;                         /* write to non-data part of disk? */                        i    = read.track.len  (track#) - read.track.written     (track#);            if i > read.track.chunk(track#) then i = read.track.chunk(track#);            port.io        (port#) = 3;         /* write desired       */            port.io.track# (port#) = track#;    /* this track #        */            port.io.dtrack#(port#) = track#;    /* this track #        */            port.io.len#   (port#) = i;            port.secmsb    (port#) = secmsb;            port.seclsb    (port#) = seclsb;            port.pmemsec   (port#) = compute.base.adr   (track#)                                   + buf.base                                   + read.track.written (track#)                                   + read.track.buf.base(track#);            port.pmemwrd   (port#) = 0;            port.update    (port#) = 5;            call issue.port.command(port#,0);            if  (port.io(port#)=0)       /* if read bombed out */            and (track.eof(track#)<>0)   /* becuase of eof     */            then track.info.busy = track.info.busy & (not(bits(track#)));            return;         end;         track.info.busy = track.info.busy & (not(bits(track#)));         return;      end;      /* handle reading data from disk */      if syn.scsi.data.xfer = Sys#OptDTD  /* but if transferring from optical    */      then return;                        /* then we read from optical elsewhere */      if (buf1.msb(track#)<>read.track.msb(track#))      or (buf1.lsb(track#)<>read.track.lsb(track#))      then do;         buf1.len(track#) = 0;         buf1.msb(track#) = read.track.msb(track#);         buf1.lsb(track#) = read.track.lsb(track#);      end;      if buf1.len(track#) ilt read.track.buf.len(track#) then do;         i    = read.track.buf.len(track#) - buf1.len(track#);         if i > read.track.chunk  (track#) then i = read.track.chunk(track#);         port.io        (port#) = 2;       /* read data from trk  */         port.io.track# (port#) = track#;  /* this track #        */         port.io.buf#   (port#) = 1;       /* into buf1           */         port.io.len#   (port#) = i;       /* for this len        */         call start.port.io(port#);        /* start it            */         if  (port.io(port#)=0)            /* if read bombed out  */         and (track.eof(track#)<>0)        /* becuase of eof      */         then track.info.busy = track.info.busy & (not(bits(track#)));         return;      end;      track.info.busy = track.info.busy & (not(bits(track#)));      return;   end;   /* read in normal playback data */   /* if buffer #1 does not contain the correct data,  then */   /* see if buffer 2 or 3 does.  this would happen when    */   /* crossing over the buffer boundaries                   */   if  (buf1.msb(track#)<>desired.buf1.msb)   or  (buf1.lsb(track#)<>desired.buf1.lsb)   then do;      /* scroll forward if buf2 */      /* contains the data:     */      if  (buf2.msb(track#) = desired.buf1.msb)      and (buf2.lsb(track#) = desired.buf1.lsb)      and (buf2.len(track#) <> 0              )      then do;         /* scroll back buf1 to buf3 if */         /* buf1 has the data in it     */         if  (buf1.msb(track#) = desired.buf3.msb)         and (buf1.lsb(track#) = desired.buf3.lsb)         and (buf1.len(track#) = buf.len         )         then do;            buf3.msb(track#) = desired.buf3.msb;            buf3.lsb(track#) = desired.buf3.lsb;            buf3.len(track#) = desired.buf3.len;            if buf3.len(track#) > (buf.len-clob.len(track#))            then buf3.len(track#) = buf.len-clob.len(track#);         end;         else buf3.len(track#) = 0;         buf1.msb(track#)=buf2.msb(track#);         buf1.lsb(track#)=buf2.lsb(track#);         buf1.len(track#)=buf2.len(track#);         buf2.len(track#)=0;         clob.len(track#)=0;      end;      /* scroll backwards if buf3 contains */      /* the data (happens during point    */      /* playback)                         */      else if  (buf3.msb(track#) = desired.buf1.msb)      and      (buf3.lsb(track#) = desired.buf1.lsb)      and      (buf3.len(track#) <> 0              )      and      (clob.len(track#) =  0              )      then do;         /* scroll buf1 ahead to buf2 if */         /* buf1 has the data in it      */         if  (buf1.msb(track#) = desired.buf2.msb)         and (buf1.lsb(track#) = desired.buf2.lsb)         then do;            buf2.msb(track#) = desired.buf2.msb;            buf2.lsb(track#) = desired.buf2.lsb;            buf2.len(track#) = buf1.len(track#);         end;         else buf2.len(track#) = 0;         buf1.msb(track#)=buf3.msb(track#);         buf1.lsb(track#)=buf3.lsb(track#);         buf1.len(track#)=buf.len;         clob.len(track#)=buf.len-buf3.len(track#);         buf3.len(track#)=0;      end;      else do;         /* no data from correct place - toss it all */         buf1.msb(track#)=desired.buf1.msb;         buf1.lsb(track#)=desired.buf1.lsb;         buf1.len(track#)=0;                        buf2.len(track#)=0;         buf3.len(track#)=0;         clob.len(track#)=0;      end;   end;   /* also check buf2, buf3 to see if they */   /* are where they should be             */   if  (buf2.msb(track#)<>desired.buf2.msb)   or  (buf2.lsb(track#)<>desired.buf2.lsb)   then do;      buf2.msb(track#)=desired.buf2.msb;      buf2.lsb(track#)=desired.buf2.lsb;      buf2.len(track#) = 0;   end;   if  (buf3.msb(track#)<>desired.buf3.msb)   or  (buf3.lsb(track#)<>desired.buf3.lsb)   then do;      buf3.msb(track#)=desired.buf3.msb;      buf3.lsb(track#)=desired.buf3.lsb;      buf3.len(track#) = 0;   end;   /* check for freeing up space as we scroll */   /* forward and backward                    */   if buf1.len(track#) > desired.buf1.len   then buf1.len(track#) = desired.buf1.len;   if buf2.len(track#) > desired.buf2.len   then buf2.len(track#) = desired.buf2.len;   if buf3.len(track#) > desired.buf3.len   then buf3.len(track#) = desired.buf3.len;   /* issue disk read command to fill */   /* buf1:                           */   if (desired.buf1.len>buf1.len(track#))   then do;                               /* fill it       */      i=desired.buf1.len-buf1.len(track#);      i=chunk.check(i);      port.io        (port#)=2;           /* read desired  */      port.io.track# (port#)=track#;      /* this track #  */      port.io.buf#   (port#)=1;           /* into this buf */      port.io.len#   (port#)=i;           /* for this len  */      call start.port.io(port#);          /* start it      */      /* Remove clicks at front of audio during startup for    */      /* benefit of DDSAD                                      */      if  (buf1.msb(track#) = new.buf.msb) /* if reading from pre-buffered */      and (buf1.lsb(track#) = new.buf.lsb) /* position, and not looping    */      and (loop             = 0          ) /* and this is the first        */      and (buf1.len(track#) = 0          ) /* buffer load, then /--\       */      then port.fadein(port#) = 1;      /* For 4 tracks/per/drive - come back right away to fill */      /* buffer 2 if we run into the end of buffer 1.   This   */      /* gives us a higher net data rate since caching is      */      /* available in the drive.                               */      if  (desired.buf1.len = buf.len)     /* if  filling buf1 to top    */      and (desired.buf2.len > 5      )     /* and room in buf2           */      then port.toggle(port#) = track# & (tracks.per.port-1);      return;   end;   if (clob.len(track#)>desired.buf2.len)   then do;                               /* fill it       */      i=clob.len(track#)-desired.buf2.len;      i=chunk.check(i);      port.io        (port#)=2;           /* read desired  */      port.io.track# (port#)=track#;      /* this track #  */      port.io.buf#   (port#)=4;           /* into this buf */      port.io.len#   (port#)=i;           /* for this len  */      call start.port.io(port#);          /* start it      */      return;   end;   /* $page - check for filling of buffer 2 */   /* buffer #2 is the area in poly memory */   /* that contains data that has          */   /* already been played.  see if we      */   /* can read more data in there          */   if (desired.buf2.len<>0)     /* we want someting in buf2  */   then do;      /* issue disk read command to fill */      /* buf2:                           */      if (desired.buf2.len>buf2.len(track#))      then do;                               /* fill it */         i=desired.buf2.len-buf2.len(track#);         i=chunk.check(i);         port.io        (port#)=2;           /* read          */         port.io.track# (port#)=track#;      /* this track #  */         port.io.buf#   (port#)=2;           /* into this buf */         port.io.len#   (port#)=i;           /* for this len  */         call start.port.io(port#);          /* start it      */      end;   end;   if (desired.buf3.len<>0)     /* we want someting in buf3  */   then do;      /* issue disk read command to fill */      /* buf3:                           */      if (desired.buf3.len>buf3.len(track#))      then do;                               /* fill it */         i=desired.buf3.len-buf3.len(track#);         i=chunk.check(i);         port.io        (port#)=2;           /* read          */         port.io.track# (port#)=track#;      /* this track #  */         port.io.buf#   (port#)=3;           /* into this buf */         port.io.len#   (port#)=i;           /* for this len  */         call start.port.io(port#);          /* start it      */      end;   end;end track.playback.check;/* $page - error retry counting *//* when a disk error occurs on a track,  we try several times to   do the operation again.   if after several tries we still can   do the operation,  we mark the track as having reached   then end of file.  This will terminate further output until   we start playing again. */count.retries:proc(port#,track#);   dcl (port#,track#) fixed;   port.retry(port#)=port.retry(port#)+1;   if port.retry(port#)>3        /* retry up to 3 times    */   then do;      track.eof(track#)= 1;      /* end of track reached   */   end;   if port.io(port#)<>1          /* clear port.io          */   then port.io  (port#) = 0;    /* unless reset was done  */   end count.retries;count.tape.retries:proc(port#,track#);   dcl (port#,track#) fixed;   if port.retry(port#)>3        /* retry up to 3 times    */   then do;      track.eof(track#)= 1;      /* end of track reached   */   end;end count.tape.retries;