/* LOD1-13 State Variables, Sync Routines,  Start output, other major functions *//* 8/14/91 - cj - Added UDIO/DDSYN stuff                          *//* 3/07/91 - cj - changes for DDSAD                               *//* 2/09/89 - cj - fixed 'muted track load/backup bug'             *//* 7/29/88 - cj - fixed 44.1 khz bug                              *//* these variables control the state *//* of our output                     */dcl (active.rate)             fixed;     /* active sample rate       */dcl (previous.delta)          fixed;     /* delta last time around   */dcl (previous.correction)     fixed;     /* correction therefore     */dcl (send.scrolling)          fixed;     /* true to send scrolling   *//* Output.S# is an important number.   It holds the sample # of the  *//* first sample that was played.   This is the sample that is in     *//* location 0 of BUF1 when the output is started,  as well as        *//* in location 0 of the DDT Output Buffer when output is started     */dcl (Output.S#)      (1)      fixed;     /* sample # of output start */dcl (output.s#.msb)  lit      'Output.S#(0)';dcl (output.s#.lsb)  lit      'Output.S#(1)';dcl (Chan32.S#)      (1)      fixed;     /* 32-bit chan 32 phase acc */dcl (chan32.s#.msb)  lit      'Chan32.S#(0)';dcl (chan32.s#.lsb)  lit      'Chan32.S#(1)';dcl (chan32.last  )           fixed;dcl (Sync.S#)        (1)      fixed;     /* Synchronization sample #  */dcl (sync.s#.msb)    lit      'Sync.S#(0)'; /* basically the sum of   */dcl (sync.s#.lsb)    lit      'Sync.S#(1)'; /* Output.S# + Chan32.S#  */dcl (DDT.S#)         (1)      fixed;   /* sample # from DDT Word Clock  */dcl (ddt.s#.msb)     lit      'DDT.S#(0)';dcl (ddt.s#.lsb)     lit      'DDT.S#(1)';dcl (ddt.last  )              fixed;   /* last word clock               */dcl (cue.delay.#1) (1)      fixed;     /* used to provide a minimum */dcl (cue.delay.#2) (1)      fixed;     /* delay between triggers    */                                       /* during scroll bar         */                                       /* movements                 *//* $page - construct temporary cue for triggering *//* There are two basic types of ways that the synclavier can trigger *//* a cue playback.  In one case, the cue is already saved on         *//* the dtd and the synclavier just has to trigger it.  This is       *//* what happens when the cue is triggered from the sequencer.        *//* For this type of playback the dtd only needs to know the id# of   *//* the cue, and when to trigger it.  (other information such as      *//* volume, pan, output # (etc) could also be specified)              *//* Sometimes the synclavier needs to trigger output when there is    *//* no cue that has been defined.  To do this easily and quickly,     *//* a temporary cue is constructed that sits in TCUE.XMSEC#.  This    *//* cue is referenced by id = (-1).                                   *//* There are two ways a temporary cue is constructed.  Way #1,       *//* an in time, out time, and track bits are specifed.  Way #2,       *//* a complete cue is sent over from the synclav and it is processed  *//* without the delays of saving it (used from  scroll bar, for       *//* example)                                                          */Create.Temp.Cue: proc(In, Out, tracks, modify);   dcl in      array;   /* pass in  time (absolute sample #) */   dcl out     array;   /* pass out time (absolute sample #) */   dcl tracks  fixed;   /* tracks                            */   dcl modify  fixed;   /* 1 = modify existing tcue          */   write(mam) = tcue.xmsec#;    /* create temporary cue in tcue.xmsec# */   if modify = 0 then do;       /* initialize to default (no map)      */      write(mdi) = cue.name+1;  /* record length up through name       */      rpc cue.name;      write(mdi) = 0;   end;   else do;      /* leave existing tcue mapping in place.  presumably a valid	  */      /* tcue has been loaded in via 137.  just change in/out times    */      /* to reflect new mouse position                                 */   end;   write(mal) = cue.s.msb;      /* in time                             */   write(mdi) = in(0);   write(mdi) = in(1);   write(mal) = cue.e.msb;      /* out time                            */   if (out(0)\out(1))<>0        /* if end time specified               */   then do;                     /* then use it                         */      write(mdi) = out(0);      write(mdi) = out(1);   end;   else do;                     /* else if raw data, then use proj end */      if modify = 0 then do;             write(mdi) = Song.End.S#(0);         write(mdi) = Song.End.S#(1);      end;      else do;                  /* else with respect to current cue,   */         write(mdi) = (-1);     /* play all of it                      */         write(mdi) = ( 0);      end;   end;   write(mal) = cue.trks;   write(md ) = tracks;end Create.Temp.Cue;/* $page - set up for armed recording *//* The aee performs recording by sending over an 'armed recording' *//* data record.   It is called 'ARMED' because it often arms the   *//* dtd for recording when a later trigger pulse is received        *//* When the record is first received, it is stacked in a temporary *//* buffer call StackedRECREC.   This is done because the dtd may   *//* not be ready to accept the record this instant, for example if  *//* it is still busy cleaning up from the last recording operation  *//* This routine looks at StackedRECREC and sets up for armed       *//* recording                                                       */set.up.for.armed.recording:proc swapable;      dcl i fixed;   do i=recrec.code  to recrec.audio;  /* store away record record */      recrec(i) = stackedrecrec(i);   end;   recrec.is.stacked = 0;                /* no stackedrecrec waiting */   recrec(recrec.stacked) = 0;           /* indicate not stacked yet */   armed = 1;                            /* now armed                */   /* if we are doing recording synced to the */   /* sequencer,  then compute the sample #   */   /* that we should trigger at               */   if recrec(recrec.code )<>0 then do;         call compute.mark.start.point(RecRec.Sync, 0, 0, RecRec.Sync);   end;   /* Now compute sample #s for the punch in/out times */   if recrec(recrec.dtype)<>0 then do;   /* get sample # for dest points */      call compute.mark.start.point(RecRec.In, 0, 0, RecRec.In );      call compute.mark.start.point(RecRec.Out, 0, 0, RecRec.Out );      if recrec(recrec.newinfo) = 0      then recrec(recrec.tracks) = lookup.ready.tracks & track.avail.bits;      /* Check to be sure all recording is in our song */      if COM32(RecRec.In, Song.Data.S#) = lw#ilt  /* Before the beginning */      then do;         call log.error('Cannot record before the start of the current project');         call clear.armed.info;              end;      else if COM32(RecRec.In, Song.End.S#)  >= lw#ieq  /* at/Past the end */      then do;         call log.error('Cannot record past the end of the current project');         call clear.armed.info;              end;      else if COM32(RecRec.Out,Song.End.S#)  >  lw#ieq      then call COPY32(Song.End.S#, RecRec.Out);   end;   else do;                  /* dest is cue - make sure in current song */      if lookup.cur.cue(recrec(recrec.cue.id))=0      then call clear.armed.info;        /* bad id#                 */      else if current.cue(cue.list.ptr) <> 0      then call clear.armed.info;        /* can not punch over reel */      else if cue.is.in.current.song(current.cue)=0 /* oops - not in cur song */      then do;         call log.error('Cue is in Different Project - Cannot Record');         call clear.armed.info;              end;      else do;               /* save sample #'s for pin/out points */         call COPY32(CC.In,  RecRec.In );         call COPY32(CC.OUt, RecRec.Out);         recrec(recrec.tracks) = cc.trks & lookup.ready.tracks & track.avail.bits;      end;   end;/****************************************************************//*                                                              *//*   allow recording with no ready tracks now to provide        *//*   for button panel punch ins                                 *//*                                                              *//*    if  (armed<>0)                                            *//*    and (recrec(recrec.tracks)=0)                             *//*    then do;                                                  *//*       call log.error('No Tracks are READY - Cannot Record'); *//*       call clear.armed.info;                                 *//*    end;                                                      *//*                                                              *//****************************************************************/   if  (armed                <> 0 ) /* if no errors so far          */   and ((play                =  0 ) /* if not playing               */   or   (move                <> 0)) /* or are moving                */   and (recrec(recrec.code ) =  0 ) /* and immediate desired        */   then do;                         /* set up for immediate trigger */      /* create default cue to */      /* trigger               */      call Create.Temp.Cue(RecRec.In, RecRec.Out, recrec(recrec.tracks)\recrec(recrec.audio), 0);      /* and initiate output   */      if trig=0 then do;            /* detect first cue trigger     */         first.trig = 1;            /* set flag for startup         */         call STR32(0,0,Cue.Delay.#1);       /* initialize cue delay field */         call STR32(0,0,Cue.Delay.#2);       /* initialize cue delay field */      end;      trig     =1;                  /* internal sync playback       */      trig.rate=0;                  /* normal rate                  */      trig.time=real.milliseconds;  /* immediately                  */      trig.tracks    = recrec(recrec.audio);        /* set up Trig.Record to start the playback:                  */      dcl Stack.Record lit 'Trig.Record';      call Zero.Out.Stack.Record(Stack.Record);      Trig.New.Info  = 1;           /* new info now avail           */      Stack.Cue.Id   = (-1);        /* trigger tcue.xmsec#          */      Stack.Exists   = 1\64;        /* bits for record              */      Stack.Track#   = 0;           /* no routing for recording     */   end;end set.up.for.armed.recording;/* $page - routine to process trigger rates *//* Scale For Trig Rate scales a passed number by the trigger *//* sampling rate.   For example,  if the trigger sample      *//* rate was 2x, the returned value would be twice the        *//* number passed                                             */Scale.For.Trig.Rate:proc (val);   dcl val fixed;   load val;   if Trig.Rate>0 then do;      mul (1+Trig.Rate);      if (ures<>0) or (res igt 30000)      then load 30000;   end;   else if Trig.Rate<0 then do;      div (1-Trig.Rate);   end;   return res;end Scale.For.Trig.Rate;/* compute trig time - compute a time (based off real.milliseconds) *//* that is a fixed delay in front of us.   this delay is chosen     *//* so that the playback buffers will have been filled by then       *//* This is done to give the mouse playback an even response         */Compute.Trig.Time:proc;   trig.time=real.milliseconds+trig.delay; /* that was easy */end Compute.Trig.Time;/* $page - routine to set trigger rate and compute volume *//* Set Trigger rate performs two functions:  it computes a muted *//* volume factor to use during high speed playback,  and it      *//* also sets the lod sampling rate to achieve the new rate       */dcl Trigger.Vol.Info fixed;Compute.Trigger.Vol.Info:proc;   dcl i fixed;   if now.triggering = 0              /* if not triggering,    */   then i = 1;                        /* set to maximum        */   else i = Scale.For.Trig.Rate(1);   /* compute volume factor */                                      /* for high speed        */                                      /* playback.             */   if i <= 1   then Trigger.Vol.Info = (-1);      /* use max if slow trig  */   else do;                           /* or not triggering     */      load  0;                        /* at all.               */      uload 1;                        /* use fractional divide */      div   i;                        /* so we are set up for  */      Trigger.Vol.Info = res;         /* fractional multiply   */   end;end Compute.Trigger.Vol.Info;Set.Trigger.Rate: proc(Rate);   /* set hz for trigger rate */   dcl rate  fixed;             /* basic sample rate * 4   */   dcl incr  fixed;             /* compute phase incr      */   dcl new   fixed;   dcl i     fixed;   incr = Scale.For.Trig.Rate(1);   /* compute phase incr to use    */   if incr = 0 then do;             /* slow playback - compute rate */      incr = 1;                     /* use pinc of 1                */      rate = Scale.For.Trig.Rate(rate);  /* at slower active rate   */   end;   else if incr > 1 then do;        /* else up sampling rate        */      load rate; mul incr;          /* compute what new sampling    */      mwait; div(shr(incr+1,1));    /* rate would be with 1/2       */      new = res;                    /* the increment                */      do while (incr>1   )          /* prefered method is by using  */      and      (new <4040);         /* pinc of 1 at higher rate     */         rate = new;                /* use higher rate with         */         incr = shr(incr+1,1);      /* smaller increment if poss    */         load rate; mul incr;       /* compute what new sampling    */         mwait; div(shr(incr+1,1)); /* rate would be with 1/2       */         new = res;                 /* the increment                */      end;   end;   /* if not actually triggering now, then we are just setting up   */   /* for triggered output.  Arm the DDSAD accordingly              */   if now.triggering = 0   then do;      call set.lod.hz(rate,0);      call set_ddsad_controls(rate,0);   end;   /* else if we are actually triggering (or just starting at this) */   /* instant, turn on the DDSAD first:                             */   else do;      call set_ddsad_controls(rate,0);   /* turn on DDSAD here      */      call set.lod.hz(rate,incr);        /* then poly               */   end;   /* compute muted volume for high */   /* speed playback                */   call Compute.Trigger.Vol.Info;end Set.Trigger.Rate;/* $page - routines for synchronization *//* Routine to read current phase * position of chan 32 *//* Also read Direct-Digital-Transfer Word Clock        *//* get.sync.s# samples the d16 timer and the channel 32 sample counter   at as nearly the same instant as possible.   The following information   is gathered:      Our.Time   =   d16 time of reading      Chan32.S#  =   32-bit chan32 phase accumulator      Sync.S#    =   sum if output start samp# + chan32.s#      DDT.S#     =   accumulated ddt word clocks      note: Sync.S# has different meaning for looped playback.      so: */get.sync.s#:proc;   dcl (i,j,k) fixed;   disable;   call get.d16.time;               /* get d16 time        */   write(psc)=32;                   /* chan 32             */   write(psf)=psadsc32;             /* chan 32 lsb address */   i=read(psd);                        /* Read word clock counter from DDT unit: */   if Sync.Mode = 2                    /* get ddt word clock  */   then do;                            /* if needed           */      /* If connected through dedicated D24,  then can read word */      /* clock at any time: (unless using the AUX tape).         */      if DDT.Connect.Mode = 0      then do;         if (aux.d24.# <> ddt.d24.#) or (port.io(max.ports) = 0)         then j = Read.Selected.DDT.Word.Clock; /* get word clock      */         else j = DDT.Last + (i - chan32.last); /* else guess          */      end;      /* Else if using MULTI-TRACK DDT,  can only read word clock when */      /* port is idle.   Estimate current position here based upon     */      /* last reading:                                                 */      else j = Get.DDT.Clock.Estimate;       /* get estimated clock    */      if  (j = DDT.Last)                     /* if ddt in clock has    */      then do;                               /* stopped,  check        */         if ((i - chan32.last) > 10)         /* if it has stopped for  */         then do;                            /* 10 sample periods,     */            if DDT.Good.Word.Clk >= 0        /* then give error mess   */            then call Log.Error('Direct-Digital-Transfer sync signal is not connected');            DDT.Good.Word.Clk = (-1);         end;         j = DDT.Last + i - chan32.last;  /* simulate clocks if none     */                                          /* are coming in. keep from    */      end;                                /* crashing when cable comes   */      else DDT.Good.Word.Clk = 1;         /* unplugged                   */   end;   enable;   /* handle normal play mode or trig mode */   /* first:                               */   if  (now.looping = 0)            /* if not looping      */   or  (loop.mode   = 0)            /* or doing point loop */   then do;            /* compute # of samples that have gone by since */      /* last reading                                 */      if  (active.rate >= 0)         /* forward motion */      then do;          k = i - chan32.last;         if i ilt chan32.last then do;  /* detect buffer wrap */            k = k + shl(buf.len,8);         end;         call ADD16(k,Chan32.S#);       /* compute new chan32 pos */      end;      else do;                          /* backwards motion */         k = chan32.last - i;         if i igt chan32.last then do;             k = k + shl(buf.len,8);         end;         call SUB16(k,Chan32.S#);       /* compute new chan32 pos */      end;      chan32.last=i;      call ADD32(Chan32.S#,     /* sync.s# is sum of chan */                 Output.S#,     /* 32 pos + starting pos  */                 Sync.S#   );      /* keep DDT variables up to date */      k = j - DDT.last;        /* compute word clocks        */      call ADD16(k,DDT.S#);     /* and accumulate them    */      DDT.last = j;   end;   /* for looping playback,  set sync.s#.lsb to the word */   /* within the buffer we are playing back at           */   else do;      dcl loop.bases data (loop.buf1+1,loop.buf2+1,loop.buf3+1);      sync.s#.msb = 0;      sync.s#.lsb = i - shl(loop.bases(Cur.Loop.Buf-1),8);   end;end get.sync.s#;/* $page - compute delayed sync point *//* this routine is called to compute a synchronization point a *//* short distance in the future.                               *//* a sync sample # is computed that is 250 msec in the future. *//* This should give us time to load attack buffers, etc.       *//* the routine is passed true/false for 'immediate'.   if true *//* then the current playback time is returned.   this is done  *//* to provide immediate start up for cue recording.   if 0 is  *//* passed then the sync point will be 250 msec in the future   *//* the second argument is used to postpone rapid trigger       *//* requests,  such as those that happen when the mouse         *//* is moved along the shuttle bar.  if delay=1,  then the      *//* sync time is further delayed to be 250 msec after the       *//* most recent cue trigger time                                */compute.delayed.sync.point:proc(immed,delay,output); /* get sync address we want cue to start (fixed delay from now) */   dcl (immed)  fixed;    /* 1 = provide no delay.  used during recording start */   dcl (delay)  fixed;    /* 1 = delay cue trig till 250 msec after last one - used to smooth out scroll bar mouse movements   */   dcl (output) array;    /* output sample # data aray                                                   */   dcl (i,j,k)  fixed;   if (now.playing    <> 0)   or (now.triggering <> 0)   then do;      call get.sync.s#;          /* if doing output, get sample # */      call COPY32(Sync.S#, Output);   end;   else if play <> 0 then do;        /* if about to play,  then   */      call COPY32(New.Buf, Output);  /* sync to buffer load point */   end;   else if trig <> 0 then do;        /* already trying to trig    */      call STR32(0, 0, Output);      /* but not started yet       */   end;   else do;                          /* who knows - must be first */      call STR32(0, 0, Output);      /* trigger cue.  start at    */      return;                        /* 0,0                       */   end;   if immed<>0 then return;      /* use immediate sync time           */   load (shr(active.rate+2,2));  /* round; get khz * 10               */   if Now.Triggering <> 0        /* scale for trig rate if applic.    */   then load Scale.For.Trig.Rate(res);    mul  trig.delay;              /* times fixed delay (msec)          */   if ures IGE 10                /* watch for divide overflow         */   then do;      bitmsb = 0; bitlsb = 50000;   end;   else do;      div 10;                       /* /10 to get samples                */      bitmsb = 0;                   /* result is samples to delay        */      bitlsb = res;                 /* ie # of samples in 250 msec       */      if   bitlsb IGT 50000         /* limit to sensible value even if   */      then bitlsb  =  50000;        /* very high trigger rates           */   end;   call ADD32(Output, Bit, Output);   if delay <> 0 then do;        /* delay for cue if needed           */      call SHL32(Bit, 1);        /* get 1/2 second delay              */      if COM32(Output, Cue.Delay.#1) = lw#ilt      then do;         call COPY32(Cue.Delay.#1, Output);         call ADD32 (Cue.Delay.#1, Bit, Cue.Delay.#2);      end;      else do;         if COM32(Output, Cue.Delay.#2) = lw#ilt         then do;            call COPY32(Cue.Delay.#2, Output);            call COPY32(Cue.Delay.#2, Cue.Delay.#1);         end;         else do;            call ADD32(Output, Bit, Cue.Delay.#1);            call COPY32(Cue.Delay.#1, Cue.Delay.#2);         end;      end;   end;end compute.delayed.sync.point;/* $page - routine to trigger a cue by id *//* The following routine starts a process going that triggers  *//* cue playback.   It is complicated by one item:              *//*                                                             *//* If the sequencer is running,  then we will actually         *//* process the cue here and stack its segments on the playback *//* stack right here.   This is done here because sequencer     *//* triggered playback is inherently POLYPHONIC.   If for       *//* some reason we are not ready to accept the cue at this      *//* instant,  then we must toss it since we have no mechanism   *//* to locally stack a LIST of cues to play at some time in     *//* the future                                                  *//* if the sequencer is not running,  then we should trigger    *//* the cue using internal sync.   This is an inherently        *//* MONOPHONIC situation (IE one user with 1 terminal, 1 mouse  *//* and 1 cue directory or scroll bar).   In this case we do    *//* not trigger the cue here,  but stack it on a one level      *//* stack (trig.record,  first.trig, etc) so that it can be     *//* digested as soon as possible.   This is done this way so    *//* we never throw away monophonic cue triggers.   In other     *//* words,  if the user clicks on the scroll bar and moves the  *//* mouse before the DTD has had a chance to start the output,  *//* then we want to  A) start ANY output as soon as possible    *//* (presumably the output that corresponds to where he         *//* pressed the mouse)  and then quickly SWITCH the output      *//* point to where the mouse has been moved to as soon as       *//* we can.   That way the audio will eventually be correct,    *//* even if it took us a while to get the right output          *//* happening                                                   *//* The following routine handles the necessary cases */Trigger.Cue:proc (Stack.Record, rate);   dcl Stack.Record    array;    /* actually a stack record    */   dcl rate            fixed;    /* new trig.rate              */   /* if cue trigger commmand is received while */   /* we are playing,  then just cue up to      */   /* trigger off of sequencer clocking         */   if  (play           <> 0)              /* if playing          */   and (move            = 0)              /* and not moving      */   and (now.triggering  = 0)              /* and not trigging    */   then do;      call compute.delayed.sync.point(0,1,Stack.Sync); /* get sample # a short distance in the future that will work for us */      Stack.Exists = Stack.Exists & (not(64));         /* protect us from recording here */      call Stack.Entire.Cue(Stack.Record);   end;   /* otherwise lett normal trig processing  */   /* take care of it                        */   else do;      if trig = 0            /* if this is first trigger      */      then do;               /* then set up info              */         call compute.trig.time;  /* get time in front of us  */         first.trig=1;            /* set flag to zap stack    */         call STR32(0,0,Cue.Delay.#1);       /* initialize cue delay field */         call STR32(0,0,Cue.Delay.#2);       /* initialize cue delay field */         trig      =1;            /* internal sync playback   */      end;      trig.new.info  = 1;      call blockmove(Stack.Record, Trig.Record, Stack.Record.Size);      if  ((Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Dspin\Dig.Forcedsp)) <> 0)      then Trig.Rate = 0;        /* cannot speedup/slow down  */      else Trig.Rate = rate;     /* during DDT xfers.         */      /* caller must set trig.tracks for audio */   end;end Trigger.Cue;