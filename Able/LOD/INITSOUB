/* INITSOUB - Special SCSI routines SYNCL communications *//* 03/26/90 - cj - Code for new tape format              *//* Get.Scsi.Byte - get byte from SCSI with TARGET handshake *//* Get.Scsi.Word                                            *//* Scsi.To.Poly  - get multi track data from synclav        */// These routines mimic a SCSI target using the D24 card.// They are used to receive data from the main Synclavier computer.// The Synclavier computer (Able 0) is considered the initiator and uses// the D26/D27 to toggle the scsi data.// The Direct-to-Disk computer (Able 1) is the target and manually toggles// each byte.get.scsi.byte: proc PUBLIC;   dcl (i) fixed;   // Assert REQ   write(ScsiBus)=S$BSY \ S$REQ;   // Wait for ACK (or atn/reset, although not really handled)   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;      // Grab the data   i=read(ScsiData)&S$DataMask;   // Remove req   write(ScsiBus)=S$BSY;   // Wait for ack to go away   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;   return i;end get.scsi.byte;get.scsi.word: proc PUBLIC;   dcl (i) fixed;   write(ScsiBus)=S$BSY \ S$REQ;														// assert REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;					// wait for ACK   i=shl(read(ScsiData)&S$DataMask,8);												// get first byte; store in upper half   write(ScsiBus)=S$BSY;																// remove REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;				// wait for !ack   write(ScsiBus)=S$BSY \ S$REQ;														// assert next REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;					// wait for ACK   i = i | (read(ScsiData)&S$DataMask);											// get next byte in lower half; or together complete word			   write(ScsiBus)=S$BSY;																// remove REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;				// wait for !ack     return i;end get.scsi.word;/* $page - send scsi info into poly memory *//* scsi.to.poly is used to perform a "smart" data transfer from *//* the scsi card into poly memory.  arguments are as            *//* follows:                                                     */Scsi.To.Poly: proc(stereo,wrdlen,trk1,trk2,wpos) PUBLIC swapable;   dcl stereo fixed;   /* 0 for mono transfer,  1 for stereo transfer */   dcl wrdlen fixed;   /* # of words (total) to transfer              */   dcl trk1   fixed;   /* first track                                 */   dcl trk2   fixed;   /* second track (for stereo)                   */   dcl wpos   fixed;   /* word position in data buffer to store data  */   dcl base1  fixed;   dcl base2  fixed;   dcl (i,j)  fixed;   base1 = track.base.adr(trk1);    /* compute poly base addresses */   base2 = track.base.adr(trk2);    /* for tracks                  */   do while wrdlen<>0;      if stereo<>0 then do;    /* stereo xfer - split amongs tracks */         call psmwrite(base1+buf.base,wpos); /* set up for data xfer to track 1 */         write("313")=addr(misc.buf(0));     /* set up misc buf ptr for track 2 */         if wrdlen ige 256 then do;          /* quick xfer for full sectors   */            write(psd)  =Get.Scsi.Word;      /* force synclav into repeat counter */            write("373")=Get.Scsi.Word;            do i=0 to 126;                   /* get 254 more words        */					write(psd  ) = get.scsi.word();               write("373") = get.scsi.word();            end;            /* transfer stereo data to other channel */            call psmwrite(base2+buf.base,wpos);            write("313")=addr(misc.buf(0));            rpc 128;            write(psd)=read("373");            wpos   = wpos   + 128;            wrdlen = wrdlen - 256;         end;         else do;           /* fill in remaining sector */            do i=0 to wrdlen-1 by 2;               write(psd)  =Get.Scsi.Word;               write("373")=Get.Scsi.Word;            end;            call psmwrite(base2+buf.base,wpos);            write("313")=addr(misc.buf(0));            rpc shr(wrdlen,1);            write(psd)=read("373");            wpos   = wpos   + shr(wrdlen,1);            wrdlen = 0;         end;      end;      else do;              /* mono transfer - a little easier */         call psmwrite(base1+buf.base,wpos);  /* set up for data write to poly */         if wrdlen ige 256 then do;         /* quick full sector xfer */            write(psd)  =Get.Scsi.Word;     /* get in sync            */				            do i=0 to 84;					write(psd) = get.scsi.word();					write(psd) = get.scsi.word();					write(psd) = get.scsi.word();				end;            wpos   = wpos   + 256;            wrdlen = wrdlen - 256;         end;         else do;           /* fill in remaining sector */            do i=0 to wrdlen-1;               write(psd)  =Get.Scsi.Word;            end;            wpos   = wpos + wrdlen;            wrdlen = 0;         end;      end;   end;end Scsi.To.Poly;/* and a more generic scsi to poly transfer: */Scsi.To.Any.Poly: proc(pmemsec,pmemwrd,wrdlen) PUBLIC swapable;   dcl pmemsec  fixed; /* poly memory sector                          */   dcl pmemwrd  fixed; /* poly memory word                            */   dcl wrdlen fixed;   /* # of words (total) to transfer              */   dcl (i,j)  fixed;   do while wrdlen<>0;      call psmwrite(pmemsec,pmemwrd);    /* set up for data write to poly */      if wrdlen ige 256 then do;         /* quick full sector xfer */         write(psd) = Get.Scsi.Word;     /* get in sync            */         do i=0 to 84;				write(psd) = get.scsi.word();				write(psd) = get.scsi.word();				write(psd) = get.scsi.word();         end;         pmemsec = pmemsec + 1;         wrdlen  = wrdlen  - 256;      end;      else do;           /* fill in remaining sector */         do i=0 to wrdlen-1;            write(psd)  =Get.Scsi.Word;         end;         pmemwrd = pmemwrd + wrdlen;         wrdlen  = 0;      end;   end;end Scsi.To.Any.Poly;/* $Subtitle Routines to read and write the Synclavier SCSI bus.         *//* Disk addresses are always passed as 256 word/sec msbs and lsbs.       *//* If the source or destination SCSI device is the optical disk, the     *//* routines do the conversion to 1024 byte/sec so that it is transparent *//* to the user.                                                          *//* goal: transfer (and possibly interleave) digital audio from LOD poly  *//* memory out to a scsi device (ie: optical disk)                        *//* Note 1: all sample numbers are analagous to time.  Therefore, when dealing           with a stereo sample, sample.index = 2 * sample.number   Note 2: Syncl.SCSI.Write and Syncl.SCSI.Read both use an 8 sector buffer           in external memory (dsp.xmsec#) as a temporary for stereo files.*/Syncl.SCSI.Write:proc (sou.l,sou.r,len,dest.msb,dest.lsb,stereo) PUBLIC swapable;/* write data to SCSI bus */   dcl sou.l      fixed;/* poly address of source audio (left)             */   dcl sou.r      fixed;/* poly address of source audio (right)            */   dcl len        fixed;/* length in sectors of data to write (per channel)*/   dcl dest.msb   fixed;/* logical address of destination (sample #)       */   dcl dest.lsb   fixed;   dcl stereo     fixed;/* flag indicating that a stereo (interleaved)     */                        /* output is desired.                              */   dcl poly.ptr   fixed; /* number of sectors past sou.l or sou.r that we have read */   dcl poly.ctr   fixed; /* number of sectors past poly.base that we have written */   dcl poly.base  fixed; /* base sector in poly to store assembled data to write */   dcl do.stack   fixed; /* true if we need to stack a sector at the end of stereo write */   dcl total.left fixed; /* total length (including stack) to be written    */   dcl (i,j,k)    fixed;   dcl      ATNV       lit  '"324"';   tptr = optical.tptr; /* Assume writing to optical for now */   if dspdebug <> 0   then do;      disable;      print 'Writing SCSI device ',track.target#;      print '    poly addr = ', sou.l;      print '    disk addr = ', dest.msb, dest.lsb;      print '    len       = ', len;      enable;   end;   /* send audio out the synclavier scsi port */   if stereo then do;      len = shl(len,1);/* get total number of sectors to merge */      total.left = len;      poly.ptr  = 0; /* initialize relative read poly pointer */      do.stack  = 0;      poly.base = (track.base.adr(0) + buf.base + rec.base); /* use record buffer of first track */      /* if there is a stacked sector, then we need to decrement the */      /* write pointer by one to keep everyone happy.                */      if dsp.opt.data.stacked then do;         dest.lsb = dest.lsb - 1;         if dest.lsb = -1 then dest.msb = dest.msb - 1; /* assume no 32 bit wrap */      end;      do while (total.left <> 0);         poly.ctr = 0;         total.left = total.left + dsp.opt.data.stacked;         if (dsp.opt.data.stacked <> 0) then do; /* write temporary buffer to poly */            call Copy.Ext.Mem.To.Poly (temp.xmsec#,0,poly.base+poly.ctr,0,256);            poly.ctr  = poly.ctr + 1;            dsp.opt.data.stacked = 0;         end;         if total.left > buf.len         then do;            len = buf.len - poly.ctr;            if len then len = len - 1; /* if odd round down because len must be even */         end;         else len = total.left - poly.ctr;         do while (len <> 0);            write (mam) = dsp.xmsec#;            write (mal) = 0;            call psmread(sou.l+poly.ptr,0);            j = dsp.xmbuf.len;       /* get word length of ext mem buffer     */            if len ILT shr(j,8)      /* limit to length (in words) of entire  */            then j = shl(len,8);     /* transfer (words)                      */            do i = 0 to j-16 by 16;  /* interleave first track (left)         */               write(mdi) = read(PSD);  /* with zeroes for now                */               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;               write(mdi) = read(PSD);               write(mdi) = 0;            end;            write (mam) = dsp.xmsec#;   /* now merge in write side            */            write (mal) = 0;            call psmread(sou.r+poly.ptr,0);            do i = 0 to j-16 by 16;               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);               write(ATNV) = read(mdi);/*advance xmem pointer */               write(mdi)  = read(PSD);            end;            /* write to poly instead */            call Copy.Ext.Mem.To.Poly (dsp.xmsec#,0,poly.base+poly.ctr,0,j);            poly.ctr = poly.ctr + shr(j,8); /* just wrote j to poly so inc poly.ctr */            /* update counters, pointers */            i = shr(j,8);/* convert to sectors written */            poly.ptr = poly.ptr + shr(i,1);            len = len - i;         end;         if dest.lsb then do; /* if writing to an odd sector */            /* note: writedata will pad the previous even sector with  */            /* zeros, so we need to write an odd amount of "real" data */            if poly.ctr            then do; /* this should never be the case */               do.stack = 0;                i = shl(poly.ctr,8);            end;            else do; /* this should happen on the first write of the sound file */               do.stack = 1;               i = shl(poly.ctr-1, 8);            end;         end;         else do; /* if writing to an even sector */            if poly.ctr            then do;                do.stack = 1;                i = shl(poly.ctr-1,8);            end;            else do;               do.stack = 0;               i = shl(poly.ctr, 8);            end;         end;         /* write from poly to disk */         PolyMemSec  = poly.base; /* Set up globals for readdata */         PolyMemWord = 0;         if dspdebug then do;            disable;            print 'PolyMemSec  = ', polymemsec;            print 'msb = ', dest.msb, ' lsb = ', dest.lsb;            print 'i = ',i,' stacked = ',dsp.opt.data.stacked;            enable;         end;         k = writedata(dest.msb& 255, dest.lsb, loc(-1), i, 1);         if k <> 0 then return k;         dest.lsb = dest.lsb + shr(i,8);         if dest.lsb ilt shr(i,8) then dest.msb = dest.msb + 1;         total.left = total.left - poly.ctr;         if (do.stack <> 0) then do;             /* copy from poly to temp buffer */            call psmread(poly.base + poly.ctr-1, 0); /* set up source pointer for poly */            write(mam) = temp.xmsec#; /* set up dest pointer for xRAM   */            rpc 256;            write(mdi) = read(psd);            dsp.opt.data.stacked = 1; /* stack */         end;         else dsp.opt.data.stacked = 0; /* nothing to stack */      end; /* of writing to poly */   end;   else do;               /* mono sound file             */      PolyMemSec  = sou.l;/* Set up globals for readdata */      PolyMemWord = 0;      len = shl(len,8);   /* get length in words         */      i = writedata(dest.msb,dest.lsb,loc(-1),len,1);      if i <> 0 then do;         return i;/* some sort of SCSI error */      end;   end;   /* Note: sou.r will be garbage if sys.stereo is 0. Watch out */   return 0;/* successful write */end Syncl.SCSI.Write;/* read from scsi disk (ie optical) to 1 or 2 tracks of poly memory */Syncl.SCSI.Read:proc(dest.l,dest.r,len,sou.msb,sou.lsb,stereo) PUBLIC swapable;/* read data from SCSI bus */   dcl dest.l     fixed;/* base poly address of left track */   dcl dest.r     fixed;/* base address of right track if stereo */   dcl len        fixed;/* length in sectors to read             */   dcl sou.msb    fixed;/* disk address of source material (msb) */   dcl sou.lsb    fixed;/*                                 (lsb) */   dcl stereo     fixed;/* indicates that stereo (interleaved)   */                        /* samples are to be read.               */   dcl poly.ptr     fixed;   dcl (i,j)        fixed;   dcl      ATNV       lit  '"324"';   poly.ptr = 0;   tptr =  optical.tptr;     /* set up tptr for reading syn d24# */   /* read audio from the synclavier scsi port */   if stereo then do;      len = shl(len,1);       /* get total length in sectors to read from disk */      do while len <> 0;/* get N sectors at a time */         /* read sectors into external mem. */         j = dsp.xmbuf.len;      /* assume we can fill xmbuf */         if len ILT shr(j,8)         then j = shl(len,8);         write (mam) = dsp.xmsec#;   /* load mam & mal pointer for readdata */         write (mal) = 0;         i = readdata(sou.msb & 255, sou.lsb, loc(0), j);         if i <> 0 then do;/* error case */            return i;         end;         /* write odd samples to the left track   */         write(mam) = dsp.xmsec#;/* set up external memory */         write(mal) = 0;         call psmwrite(dest.l + poly.ptr,0);         do i = 0 to (j-16) by 16;            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */         end;         /* write even samples to the right track */         write(mam) = dsp.xmsec#;/* set up external memory */         write(mal) = 0;         call psmwrite(dest.r + poly.ptr,0);         do i = 0 to (j-16) by 16;            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */            write(ATNV) = read(mdi);/* skip sample          */            write(PSD)  = read(mdi);/* write sample to poly */         end;         /* update pointers and counters */         i = shr(j,8); /* get # of sectors we read */         sou.lsb = sou.lsb + i;         if sou.lsb ilt i then sou.msb = sou.msb+1;         poly.ptr = poly.ptr + shr(i,1);         len = len - i;      end;   end;   else do;    /* mono sound file to poly */      /* read data from SCSI to poly track buffer */      PolyMemSec  = dest.l;/* Set up globals for readdata */      PolyMemWord = 0;      len = shl(len,8);  /* get # of words to read */      i = readdata(sou.msb & 255, sou.lsb, loc(-1), len);      if i <> 0 then do;         return i;      end;   end;   return 0;/* read successful */end Syncl.SCSI.Read;/* $page more SCSI subroutines *//* Send.Scsi.Byte  -  send byte with TARGET handshake *//* Send.Scsi.Word                                     *//* Send.Scsi.Poly  -  high speed poly to poly         */send.scsi.byte: proc(b) PUBLIC;   dcl (i,b) fixed;   write(ScsiData)=b;   write(ScsiBus)=S$BSY \ S$REQ;   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;   write(ScsiBus)=S$BSY;   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;   write(ScsiData)=0;end send.scsi.byte;send.scsi.word: proc(w) PUBLIC;   dcl (w) fixed;   write(ScsiData)=shr(w,8);													// write first byte (upper)   write(ScsiBus)=S$BSY \ S$REQ;												// assert REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;			// wait for ACK   write(ScsiBus)=S$BSY;														// remove REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;		// wait for !ack   write(ScsiData)=w&255;														// write second byte (lower)	   write(ScsiBus)=S$BSY \ S$REQ;												// assert REQ				   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;			// wait for ACK   write(ScsiBus)=S$BSY;														// remove REQ   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;		// wait for !ack   write(ScsiData)=0;															// clear busend send.scsi.word;send.scsi.poly: proc(len) PUBLIC swapable;   dcl len fixed;   dcl i   fixed;   dcl j   fixed;      do while len ige 256;                  /* fast transfer for full sectors */      call send.scsi.word(read(psd));     /* use routine for first word to get synclav using repeat counter */      do i=0 to 84;                       /* send 255 more 3 at a crack */			send.scsi.word(read(psd));			send.scsi.word(read(psd));			send.scsi.word(read(psd));      end;      write(ScsiData)=0;      len = len - 256;   end;   do while len<>0;      call send.scsi.word(read(psd));     /* use routine for first word to get synclav using repeat counter */      len=len-1;   end;end send.scsi.poly;/* $page - routine to send reselection message to synclavier */Reselect.Synclavier: proc(wrdlen, message) PUBLIC swapable;   dcl wrdlen       fixed;        /* # of 16-bit words in message */   dcl message      array;        /* contents of message          */   dcl i            fixed;   /* wait for bus to be free in case the disk is still holding the */   /* bus from the last operation                                   */   write(ScsiSel)=S$SelectEnable \ Scsibits (syn.d24.#);  /* select this d24 */   write(ScsiBus) = 0;           /* double check make sure we are off */   write(ScsiData)= 0;           /* the bus                           */   do while  ((read(ScsiBus )&S$BusMask )<>0)  /* wait for bus free        */   or        ((read(ScsiData)&S$DataMask)<>0); /* but see if any selecting */      if (Read(ScsiBus) & (S$SEL\S$RST\S$ATN)) <> 0  /* or resetting being done. */      then return 0;                           /* most likely means        */   end;                                        /* rebooting if so          */   write(ScsiData) = bits(syn.target.#);       /* now try to select        */   write(ScsiBus)  = S$Sel;                    /* synclavier               */   do while (read(ScsiBus)&S$BSY)=0;     /* wait for Synclavier to set bsy */      if (Read(ScsiBus) & (S$RST\S$ATN)) <> 0 /* but see if resetting      */      then do;                           /* if reset occurs,  then clear   */         write(ScsiData) = 0;            /* the buss and quit              */         write(ScsiBus ) = 0;         return 0;      end;   end;   write(ScsiBus) = 0;  /* remove Sel      */   write(ScsiData)= 0;  /* and remove data */   /* send a non-standard reply back */  /* note use of target hand shaking! */   call send.scsi.word(shl(wrdlen,1));   /* send byte length of message back */   do i = 0 to wrdlen-1;                 /* and send the message             */      call send.scsi.word(message(i));   end;   write(ScsiBus) = 0; /* remove the BSY that was set by send.scsi.word */   write(ScsiData)= 0; /* double check the scsidata is free too         */   /* synclavier will remove busy shortly */   return 1;end Reselect.Synclavier;/* $page - Routines to reload project dir, track dir, cue dir and adir  */reload.project.dir: proc PUBLIC swapable;   dcl i fixed;   /* read song directory from disk 0 when slink has changed it */   tptr=0;                    /* use port 0 */   write(mam)=song.xmsec#;   i=readdata(0,song.sec#,loc(0),num.songs*song.len);end reload.project.dir;reload.track.dir: proc PUBLIC swapable;   call invalidate.track.dir;end reload.track.dir;begin;   dcl sec# fixed;   dcl abort fixed;   reload.cue.dir: proc PUBLIC swapable;      dcl (i,j)   fixed;      local.abort:proc;         call zero.cue.dir;           /* zap any half read cue dir */         abort = 1;      end local.abort;      local.transfer: proc(first,last,maxs,maxw,base);         dcl (first) fixed;                     /* base sector #   */         dcl (last)  fixed;                     /* ending sec#     */         dcl (maxs,maxw) fixed;                 /* len (s,w)       */         dcl (base)  fixed;                     /* store base      */         dcl (i,j,k)   fixed;         maxs = maxs + shr(maxw+255,8);         if   (sec#>=first)                    and  (sec#< last )         then do;            j = sec#-first;              /* get rel sec pos  */            if j ilt maxs            then do;               k = maxs - j;             /* get # to read    */               if k > 100 then k = 100;  /* limit            */               write(mam)=base+j;        /* read to here     */               i=readdata(0,sec#,loc(0),shl(k,8));               if i<>0 then do;                      call local.abort;                  return 1;               end;               sec#=sec#+k;               return 1;            end;            sec#=last;           /* else done with this segment */         end;         return 0;      end local.transfer;      abort = 0;      tptr  = 0;                      /* just assume port 0 is there and good??? */      sec#=disk.info.sec#;            /* start here */      misc.buf(0)=0;      misc.buf(1)=0;      i=readdata(0,sec#,misc.buf,256);      if i<>0 then do;             call local.abort;         return;      end;      cue.num      = misc.buf(2);  /* num of cues in data area */      cue.numsec   = misc.buf(3);  /* num of secs of cue def   */      cue.numwrd   = misc.buf(4);  /* num of wrds of cue def   */      num.of.alloc = misc.buf(5);  /* num of entries in alloc  */      do j=0 to 2;         num.of(j) = misc.buf(6+j);      end;      if  (misc.buf(0)<>magic#1)   /* double check data        */      or  (misc.buf(1)<>magic#2)      or  (num.of.alloc igt (max.#.of.cues-2))        or  ((cue.sec# + cue.numsec + 1) igt max.store.secs)      then do;         call local.abort;         return;      end;      sec# = disk.alloc.sec#;      /* move on         */      i = 1;      do while ((i = 1) and (abort = 0));         i = local.transfer(disk.alloc.sec#,                            disk.alph.sec#,                            0,shl(num.of.alloc,1),allc.sec#);       end;      if (abort) then return;      i = 1;      do while ((i = 1) and (abort = 0));         i = local.transfer(disk.alph.sec#,                            disk.time.sec#,                            0,num.of(alph.sort),alph.sec#);       end;      if (abort) then return;      i = 1;      do while ((i = 1) and (abort = 0));         i = local.transfer(disk.time.sec#,                            disk.smpt.sec#,                            0,num.of(time.sort),time.sec#);       end;      if (abort) then return;      i = 1;      do while ((i = 1) and (abort = 0));         i = local.transfer(disk.smpt.sec#,                            disk.cue.sec#,                            0,num.of(smpt.sort),smpt.sec#);       end;      if (abort) then return;      i = 1;      do while ((i = 1) and (abort = 0));         i = local.transfer(disk.cue.sec#,                            zero.sec#,                            cue.numsec,cue.numwrd,cue.sec#);       end;      if (abort) then return;   end reload.cue.dir;end;reload.adir: proc (t) PUBLIC swapable;   dcl t fixed;   dcl i fixed;   tptr = (t*total.stride);   write(mam)=adir.xmsec#+t;   i=readdata(0,track.adir.sec(t),loc(0),adir.len);end reload.adir;