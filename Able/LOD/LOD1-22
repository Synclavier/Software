/* LOD-22 - Start of Port.Check,  Multi-track DDT processing, AUX TAPE code  *//* 03/11/91 - cj - disabled timeout check for tape space command *//* Routine to add audio segment to allocation directory after *//* writing to disk                                            *//* update.adir is called after writing to the disk.  it records   in the allocation directory that data has been written to   certain sectors of the disk.                                */update.adir.after.write: proc(port#, track#);   dcl (port#)         fixed;   dcl (track#)        fixed;   dcl (len#)          fixed;   dcl (secmsb,seclsb) fixed;   dcl (i,j,k        ) fixed;   dcl (amsb,alsb    ) fixed;  /* declare in order */   dcl (bmsb,blsb    ) fixed;   dcl (cmsb,clsb    ) fixed;   dcl (dmsb,dlsb    ) fixed;   /* update allocation directory for ok */   /* data write:                        */   secmsb=port.secmsb  (port#);  /* look up abs sector     */   seclsb=port.seclsb  (port#);  /* for track now          */   len#  =port.io.len# (port#);        dmsb=secmsb;                  /* also get ending        */   dlsb=seclsb+len#;             /* sector handy           */   if dlsb ilt len#   then dmsb=dmsb+1;   next.adir:;   i=adir.ptr(track#);           /* pt to alloc direct     */   call gadir(i);   write("313")=addr(amsb);      /* read in amsb,alsb      */   rpc 6;                        /* bmsb,blsb, cmsb,clsb   */   write("373")=read(mdi);   if (amsb\alsb)=0              /* means end of active    */   then do;                      /* track has been reached */      if (i&255)=0               /* writing first block    */      then do;                   /* to track               */         call gadir(i);         write(mdi)=secmsb;      /* create one block       */         write(mdi)=seclsb;      /* for us                 */         write(mdi)=dmsb;         write(mdi)=dlsb;         new.adir(track#)=1;         return;      end;      adir.ptr(track#)=adir.ptr(track#)-4;      goto next.adir;   end;   if ((secmsb ilt amsb))        /* see if writing to      */   or ((secmsb  =  amsb)         /* before this block      */   and (seclsb ilt alsb))   then do;      if (i&255)>=4 then do;     /* back up                */         adir.ptr(track#)=adir.ptr(track#)-4;         goto next.adir;      end;      /* wrote to earlier block */      /* on disk                */      /* insert this block      */      /* then garbage collect   */      /* as normal:             */      call read.store(adir.xmsec#,i);      call read.len  (addr(misc.buf(0)),adir.len-(i&255)-8);      call write.store(adir.xmsec#,i+4);      call write.len (addr(misc.buf(0)),adir.len-(i&255)-8);      call gadir(i);      write(mdi)=secmsb;         /* enter zero length      */      write(mdi)=seclsb;         /* block into allocation  */      write(mdi)=secmsb;         /* list                   */      write(mdi)=seclsb;      new.adir(track#)=1;      goto next.adir;            /* it will now be in block */   end;   if ((secmsb igt bmsb))        /* if sector is > current */   or ((secmsb  =  bmsb)         /* block,  then must be   */   and (seclsb igt blsb))        /* in next or is off end  */   then do;      if (cmsb\clsb)=0           /* end of track reached   */      then do;         if (i&255)>=248         /* allocation block is    */         then return;            /* full - data lost       */         i=i+4;                  /* add block after us     */         adir.ptr(track#)=adir.ptr(track#)+4;         call gadir(i);         write(mdi)=secmsb;      /* add another block      */         write(mdi)=seclsb;      /* to end of allocation   */         write(mdi)=dmsb;        /* list                   */         write(mdi)=dlsb;         new.adir(track#)=1;         return;      end;      if ((secmsb igt cmsb))     /* see if sector          */      or ((secmsb  =  cmsb)      /* is in following        */      and (seclsb ige clsb))     /* block                  */      then do;         adir.ptr(track#)=adir.ptr(track#)+4;         goto next.adir;      end;      /* insert new block    */      i=i+4;                  /* add block after us     */      adir.ptr(track#)=adir.ptr(track#)+4;      if (i&255)>=248         /* allocation block is    */      then return;            /* full - data lost       */      call read.store(adir.xmsec#,i);      call read.len  (addr(misc.buf(0)),adir.len-(i&255)-8);      call write.store(adir.xmsec#,i+4);      call write.len (addr(misc.buf(0)),adir.len-(i&255)-8);      call gadir(i);      write(mdi)=secmsb;          /* enter zero length      */      write(mdi)=seclsb;          /* block into allocation  */      write(mdi)=secmsb;          /* list                   */      write(mdi)=seclsb;      new.adir(track#)=1;      goto next.adir;            /* it will now be in block */   end;   /* within current block - garbage collect */   if  (secmsb=bmsb)             /* most common case: append */   and (seclsb=blsb)             /* to current block         */   then do;      bmsb=dmsb;                 /* end of block is where    */      blsb=dlsb;                 /* we stopped recording     */      call gadir(i+2);      write(mdi)=bmsb;                write(mdi)=blsb;      new.adir(track#)=1;   end;   else do;                      /* punched in to mid-block  */      if  ((dmsb ilt bmsb))      /* within block:  allocate  */      or  ((dmsb  =  bmsb)       /* table does not change    */      and  (dlsb ile blsb))      then return;      bmsb=dmsb;                 /* end of block is where    */      blsb=dlsb;                 /* we stopped recording     */      call gadir(i+2);      write(mdi)=bmsb;                write(mdi)=blsb;      new.adir(track#)=1;   end;   do while 1;                   /* now garbage collect      */      if (cmsb\clsb)=0           /* end of adir reached      */      then return;      if  ((bmsb igt cmsb))         or  ((bmsb  =  cmsb)      and  (blsb ige clsb))      then do;         call gadir(i+6);         dmsb=read(mdi);         /* get end block # for      */         dlsb=read(mdi);         /* following record         */         call read.store(adir.xmsec#,i+8);         call read.len  (addr(misc.buf(0)),adir.len-(i&255)-8);         call write.store(adir.xmsec#,i+4);         call write.len (addr(misc.buf(0)),adir.len-(i&255)-8);         new.adir(track#)=1;         if  ((dmsb igt bmsb))   /* if end of that block     */         or  ((dmsb  =  bmsb)    /* was larger, then it      */         and  (dlsb igt blsb))   /* is now end of combined   */         then do;                /* block                    */            bmsb=dmsb;           /*  (hopefully will fail    */            blsb=dlsb;           /*   test next time thru)   */            call gadir(i+2);            write(mdi)=bmsb;                      write(mdi)=blsb;         end;         call gadir(i+4);         cmsb=read(mdi);         /* also get beginning       */         clsb=read(mdi);         /* of next block            */      end;      else return;   end;   return;end update.adir.after.write;/* $page - handle multi-track DDT input commands         *//* Process.multi.ddt.input is called to transfer data from a DDT unit *//* into poly memory.   It is only called when the port is idle.       *//* The purpose of this routine is to transfer the next chunk of       *//* data from the DDT unit into poly memory.                           */Process.Multi.DDT.Input: proc (Port#, Track#, ZeroOut);   dcl (port#)      fixed;   /* pass port # in question  */   dcl (track#)     fixed;   /* pass trk  # in question  */   dcl (ZeroOut)    fixed;   /* true if allow zeroing    */   dcl (i,j,k)      fixed;   dcl (base)       fixed;   dcl (poly)       fixed;   /* We are sampling from the DDT input into this track.     */   /* Use this time between disk reads to move a short block  */   /* of data from the DDT unit into poly memory              */   /* If no output is happening,  then we would like to zero  */   /* out the poly memory input buffer (rec.buf) so that      */   /* when we start up (either play or monitor),  we hear     */   /* silence during the delay period.   We will do this      */   /* by reading digital zeroes from the disk into poly       */   /* memory.                                                 */   if output.happening <> 0 then do;      /* See how many samples are available & will fit: */      i = ddt.s#.lsb  - track.ddt.lsb(track#); /* get # of samples there   */      j = sync.s#.lsb - track.ddt.lsb(track#); /* get room in input buffer */      if j ILT i then i = j;    /* get min                   */      i = shr(i,8);             /* get # of complete sectors */      /* Compute where into poly memory buffer we are to     */      /* store the data:                                     */      if  ((track.ddt.msb(track#) IGT current.msb))      or  ((track.ddt.msb(track#)  =  current.msb)      and  (track.ddt.lsb(track#) IGE current.lsb))      then base = shr(track.ddt.lsb(track#) - current.lsb,8);      else base = shr(track.ddt.lsb(track#) - prior.buf.lsb,8);      poly = compute.base.adr(track#) + buf.base + rec.base + base;      /* limit data transfer to end of poly buffer: */      if i > (buf.len-base) then i = (buf.len-base);      if i <> 0 then do;    /* only do if some available */         /* provide ramp-in on first sector of input data */         call quickly.select.port(port#);         if track.ddt.zeroed(track#) <> 0 then do;            call Construct.DDT.Ramp.In(track# & (tracks.per.port-1),                                       track.ddt.lsb(track#) - output.s#.lsb);            track.ddt.zeroed(track#) = 0;         end;         /* Enable SCSI buffer memory for transfer of data from */         /* the DDT unit:                                       */         call targ0.connect(1);   /* connect to lun 1        */         write(ScsiByte)=2\shl((shr(poly,8)&"3"),2);         write(ScsiWord)=shl(poly,8);         port.lun1 (port#)=1;     /* inidicate lun1 enabled! */         port.io (port#) = Port.DDT.Read.Command.Code;    /* save our command code   */         i = shl(i,8);      /* get complete words */         call Start.DDT.Read(track# & (tracks.per.port-1),                              track.ddt.lsb(track#) - output.s#.lsb,                              i,                             SCSI_Target_Mode);         /* Now account for data transfer: */         track.ddt.lsb(track#) = track.ddt.lsb(track#) + i;         if track.ddt.lsb(track#) ILT i         then track.ddt.msb(track#) = track.ddt.msb(track#) + 1;         call deselect(port#);         /* disconnect from port */      end;   end;   /* Else zero out the input buffer if not doing output.  This will */   /* provide digital silence during the delay period.               */   else if (ZeroOut <> 0)  /* else if we allow zeroing out here */   and     (Trig     = 0)  /* and we are not waiting to trig    */   and     (Play     = 0)  /* or play                           */   then do;      if track.ddt.zeroed(track#) <> 1 then do;         /* Initialize pointers to start the zeroing operation if */         /* this is first time through                            */         if track.ddt.zeroed(track#) = 0 then do;   /* start zero process */            track.ddt.zeroed(track#) = 2;           /* indicate doing so  */            track.ddt.ptr   (track#) = 0;           /* start here in buf  */            track.ddt.ctr   (track#) = 0;           /* init counter       */         end;         if track.ddt.ctr   (track#) >= buf.len     /* see if we are      */         then track.ddt.zeroed(track#) = 1;         /* now done           */         else do;                                   /* if not, issue read */            i = buf.len - track.ddt.ptr(track#);  /* get length to end of buffer */            j = buf.len - track.ddt.ctr(track#);  /* and sectors left to do      */            if j < i then i = j;                  /* get min of the two          */            if i > trig.chunk                     /* limit to reasonable chunk   */            then i = trig.chunk;                  /* for speed                   */            /* Read digital zeroes from disk to zero out */            /* the input buffer without tying up the     */            /* computer:                                 */            if 0 then do;                         /* read digital zeroes from disk */               port.io        (port#) = 2;        /* read desired        */               port.io.track# (port#) = track#;   /* this track #        */               port.io.dtrack#(port#) = track#;   /* this track #        */               port.io.len#   (port#) = i;        /* for this len        */               port.secmsb    (port#) = 0;               port.seclsb    (port#) = zero.sec#;               port.pmemsec   (port#) = compute.base.adr(track#)                                      + buf.base                                      + rec.base                                      + track.ddt.ptr(track#);               port.pmemwrd   (port#) = 0;               port.update    (port#) = 3;               call issue.port.command(port#,0);               if port.io(port#)<>2 then do;        /* could not start command */                  port.retry(port#)=port.retry(port#)+1;               end;            end;            /* Use feature of DDT box to provide digital zeroes into */            /* poly memory.                                          */            else do;               call quickly.select.port(port#);               call Write.Selected.DDT.Register(LAD_Scsi_Address_Pointer, 0);               call Write.Selected.DDT.Register(LAD_Scsi_Memory_A, 0);               call Write.Selected.DDT.Register(LAD_Scsi_Memory_B, 0);               /* Enable SCSI buffer memory for transfer of data from */               /* the DDT unit:                                       */               poly = compute.base.adr(track#)  /* get poly address of */                    + buf.base                  /* memory that we      */                    + rec.base                  /* wish to zero out    */                    + track.ddt.ptr(track#);               call targ0.connect(1);   /* connect to lun 1        */               write(ScsiByte)=2\shl((shr(poly,8)&"3"),2);               write(ScsiWord)=shl(poly,8);               port.lun1 (port#)=1;     /* inidicate lun1 enabled! */               port.io (port#) = Port.DDT.Read.Command.Code;    /* save our command code   */               call Start.DDT.Read(track# & (tracks.per.port-1),                                    0,                                   shl(i,8),                                   SCSI_Target_Mode \ SCSI_Incr_Inhib);               /* Now account for data transfer: */               track.ddt.ptr (track#) = track.ddt.ptr(track#) + i;               track.ddt.ctr (track#) = track.ddt.ctr(track#) + i;               call deselect(port#);         /* disconnect from port */            end;         end;      end;   end;end Process.Multi.DDT.Input;/* $page - start of port check routine */dcl track.dir.to.write   fixed; /* bits used to tell when song and track */dcl song.dir.to.write    fixed; /* directory has been written to each    */                                /* disk                                  */dcl cue.info.to.write    fixed; /* same info for cue directory           */dcl write.magic.tracks   fixed PUBLIC; /* re-write magic sector for this trk    */handle.tape.inq.data:proc (port#) swapable;	dcl (port#) fixed;		dcl per.typ  fixed;	dcl rmb.bit  fixed;	dcl i        fixed;	dcl inq.len  fixed;		per.typ          = read(ScsiByte); /*| 0   | Peripheral qualifier     |           Peripheral device type           |*/	rmb.bit          = read(ScsiByte); /*| 1   |  RMB   |                  Device-type modifier                        |*/	i                = read(ScsiByte); /*| 2   |   ISO version   |       ECMA version       |  ANSI-approved version   |*/	i                = read(ScsiByte); /*| 3   |  AENC  | TrmIOP |     Reserved    |         Response data format      |*/	inq.len          = read(ScsiByte); /*| 4   |                           Additional length (n-4)                     |*/	if (inc.jaz.prints)	{		if (per.typ == 0 && ((rmb.bit & 128) != 0))			print 'JAZ drive found: port: ', port#;	}	if (per.typ == 0 && ((rmb.bit & 128) != 0))	then tape.type(port#) = type.jaz;	else if inq.len=13 then tape.type(port#) = type.epi;	else if inq.len=12 then tape.type(port#) = type.fuj;	else if inq.len=31 then tape.type(port#) = type.cdc;	else if inq.len=47 then tape.type(port#) = type.exa;	/* Tandberg drives return 46 bytes.  Assume */	/* any other kind of drive is a Tandberg    */	/* compatible QIC320 tape drive:            */	else tape.type(port#) = type.tan;	i = read(ScsiWord);	/* 5,6 */	i = read(ScsiByte); /*   7 */	i = read(ScsiByte);  /* 8 get useful bits for fuji */	if tape.type(port#) = type.fuj	then do;		if (i&4) <> 0 then do;			if tape.to.use(port#) = 0			then tape.condition(port#) = tape.condition(port#)												\ t1.cond.rdy;			else tape.condition(port#) = tape.condition(port#)												\ t2.cond.rdy;		end;	end;end handle.tape.inq.data;toss.extra.data.bytes:proc;	do while ((read(ScsiBus)&S$REQ)=0);end;	do while (read(ScsiBus)&(S$SigMask))=S$DataIn;		write("300")=read(ScsiByte);		do while ((read(ScsiBus)&S$REQ)=0);end;	end;end toss.extra.data.bytes;toss.extra.mess.bytes:proc;	do while (read(ScsiBus)&S$Req) = 0; end;	do while (read(ScsiBus)&(S$SigMask))=S$MessIn;		write("300")=read(ScsiByte);  /* disconnects, save data pointers, identify */		do while (read(ScsiBus)&S$Req) = 0; end;	end;end toss.extra.mess.bytes;handle.tape.inquiry:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i)				  fixed;		/* if phase is "data in",  get the inq data */	/* and store away in tape.condition for     */	/* use by the load/backup software.         */	/* Also: be sure to set tape.type!!         */	if (read(ScsiBus)&(S$SigMask))=S$DataIn	then do;		handle.tape.inq.data(port#);	end;	else do;		if tdebug then do;			print 'Port',port#,' no Inq data';		end;	end;	call toss.extra.data.bytes;	if (scanmessins(port#) != 0) toss.extra.mess.bytes();	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);          /* deselect   */	port.io(port#)=0;              /* done       */	if  ((xdebug <>0   )	and  (track#=xtrack)	and  (command.# = 0))	or  ((tdebug <>0   )	and  (i      <>0   )	and  (command.# = 0))	then do;		print 'Inq status: ',port#,i,tape.to.use(port#),tape.condition(port#),tape.type(port#);	end;	if i = S$Good then do;    /* good status from inquiry */				/* If tape is a jaz drive, issue a start unit here in case it has auto-timed out.	*/		/* That way it will report ready if a cart is in												*/				if (tape.type(port#) == type.jaz)		{			i=start.tape.command(port#, track#, Tape.LoadUnload, 1);	/* issue spin up */			if i<>0 then do;				tape.state(port#)=tape.state(port#)+1;			end;		}		else				tape.state(port#)=tape.state(port#)+1;	end;	else if i=S$Busy then do; /* busy status      */		port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */		port.io   (port#) = Tape.Wait; /* go to this state to wait */	end;	/* note: should never see check cond on inq.  */	else call count.retries(port#,track#);end handle.tape.inquiry;handle.tape.test.unit:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i)				  fixed;	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);          /* deselect   */	port.io(port#) = 0;            /* done       */	if  ((xdebug <>0   )	and  (track#=xtrack)	and  (command.# = 0))	or  ((tdebug <>0   )	and  (i      <>0   )	and  (command.# = 0))	then do;		print 'Test Unit: ',port#,i;	end;	/* Ignore results for EPI, FUJ: */	if (tape.type(port#) <= type.fuj)	then do;		tape.state(port#) = tape.state(port#) + 1;	end;	/* Else if good status,  indicate cartridge ready: */	else if (i = S$Good)	then do;		if tape.to.use(port#) = 0		then tape.condition(port#) = tape.condition(port#)											\ t1.cond.rdy;		else tape.condition(port#) = tape.condition(port#)											\ t2.cond.rdy;		tape.state(port#) = tape.state(port#) + 1;	end;	/* Else for check condition, must sense it:        */	else if i = S$CheckCondition 	/* check condition status */	then do;								/* e.g. not ready			  */		port.last.io(port#) = Tape.TestUnit;		i=start.tape.command(port#,track#,Tape.RequestSense,7);		if i<>0 then do;			call count.tape.retries(port#,track#);		end;	end;	/* else if busy,  try again after a while */	else if i = S$Busy then do; /* busy status */		port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */		port.io   (port#) = Tape.Wait; /* go to this state to wait, then retry */	end;	/* else unknown error.                    */	else call count.retries(port#,track#); /* something weird happened */end handle.tape.test.unit;handle.tape.load:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i)				  fixed;	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);	port.io(port#)=0;   				/* port is now free */	if  ((track#=xtrack)	and  (xdebug <>0   ))	or  ((tdebug <>0   )	and  (i      <>0   ))	then print 'Load Status: ',port#,i;	if (i == 0) 											/* good status: done						*/		tape.state(port#)=tape.state(port#)+1;		else if (tape.type(port#) == type.jaz)			/* ignore bad status for jaz; may	*/	{		if (i == S$CheckCondition) then do;			/* if got check condition on load,	*/			port.last.io(port#) = Tape.LoadUnload;	/* look further...						*/			i = start.tape.command(port#,track#,Tape.RequestSense,7);			if i<>0 then do;								/* if bomb, give up...					*/				tape.state(port#)=tape.state(port#)+1;			end;		end;		else													/* else not check-condition			*/			tape.state(port#)=tape.state(port#)+1;	/* give up...								*/	}	else 		count.retries(port#,track#);end handle.tape.load;handle.tape.request.sense:proc (port#, track#, dtrack#) swapable;	dcl (port#, track#, dtrack#) fixed;		dcl VADD.Code.Seg  fixed;	dcl info1          fixed;	dcl info2          fixed;	dcl i					 fixed;	dcl j              fixed;	/* see if phase is "data in" */	if (read(ScsiBus)&(S$SigMask))=S$DataIn	then do;		VADD.Code.Seg = read(ScsiWord);		/* 0x7000 or 0x7100 for Jaz		*/		j             = read(Scsibyte);		/* sense key in lower 4 bits	*/		info1         = read(ScsiWord);		/* MSB of information			*/		info2         = read(ScsiWord);		/* LSB of information			*/	end;	else do;		j=S$NoData;		if tdebug then do;			print 'Port',port#,' no Request Sense data';		end;	end;	call toss.extra.data.bytes;	if (scanmessins(port#) != 0) toss.extra.mess.bytes();	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);          /* deselect   */	port.io(port#)=0;              /* done       */	if  ((xdebug <>0   )	and  (track#=xtrack)	and  (command.# = 0))	or  ((tdebug  <>0            )	and  ((port.last.io(port#)=Tape.Write    )   /* write data       */	or    (port.last.io(port#)=Tape.WriteFile)   /* write file mrk   */	or    (port.last.io(port#)=Tape.Read     )   /* tape read */	or    (port.last.io(port#)=Tape.Space    ))) /* space     */	then do;		print 'Sense: ',port#,i,j,'  ',octal(VADD.Code.Seg),'  ',info1,info2;	end;	/* Examine the sense code based upon what kind */	/* of operation it followed.					     */	if (port.last.io(port#) = Tape.ReadCapacity)	then do;		j = (j and 15);              /* extract sense key */		if (j = S$RecoveredError)    /* if no error, then */		or (j = S$NoSense       )    /* retry...			  */		then do;		end;		else if j = (S$NotReady) 	  /* not ready?        */	/* might happen if someone inserted	*/		{									  /* a cartridge and then removed it before the backup			*/			zero.jaz.position(port#); /* started...																*/			call count.retries(port#,track#);		}		else if (j == S$UnitAttention)	/* unit attention on capacity read; zero out					*/			zero.jaz.position(port#);		/* position and re-issue capacity request						*/		else do;			track.command(dtrack#)=S$RequestSense;			track.status (dtrack#)=j;			call count.retries(port#,track#);		end;	end;		else if (port.last.io(port#) = Tape.TestUnit) /* test unit ready */	then do;		j = (j and 15);              /* extract sense key */		if (j = S$RecoveredError)    /* if no error, then */		or (j = S$NoSense       )    /* drive is ready    */		then do;			if tape.to.use(port#) = 0			then tape.condition(port#) = tape.condition(port#)												\ t1.cond.rdy;			else tape.condition(port#) = tape.condition(port#)												\ t2.cond.rdy;			tape.state(port#) = tape.state(port#) + 1;		end;		else if j = (S$NotReady  )    /* not ready = no cart     */		or      j = (S$BlankCheck)    /* cdc's give blank check? */		then do;			tape.state(port#)=tape.state(port#) + 1;		end;		else if (j == S$UnitAttention)	/* else unit attention on test unit ready		*/		then do;									/* then likely means new cart inserted			*/			zero.jaz.position(port#);		/* indicate current jaz position is at			*/		end;										/* start of tape and re-issue opii				*/		else do;			track.command(dtrack#)=S$RequestSense;			track.status (dtrack#)=j;			call count.retries(port#,track#);		end;	end;	else if (port.last.io(port#)=Tape.Write    )  /* write data       */	or      (port.last.io(port#)=Tape.WriteFile)  /* write file mrk   */	then do;                      /* request sense after write */				/* if writing to Jaz drive, update current position (soon to be LEOT)	*/		/* unless we are writing the directory												*/				if (tape.type(port#) == type.jaz)		{			if (((j&15)=S$RecoveredError)				/* if good status from the write, update	*/			||  ((j&15)=S$NoSense       ))			/* length & increment state					*/			{				if (port.jaz.update(port#) != 0)				{					port.jaz.sec.lsb(port#) = port.jaz.sec.lsb(port#) + port.jaz.update(port#);										if (port.jaz.sec.lsb(port#) ILT port.jaz.update(port#))						port.jaz.sec.msb(port#) = port.jaz.sec.msb(port#) + 1;				}								tape.state(port#)=tape.state(port#)+1;			}						else if ((j&15)<>S$UnitAttention)				/* ignore unit attention at this point, but	*/			{															/* indicates a serious error...  Post			*/				track.command(dtrack#)=S$RequestSense;		/* other likely fatal error...					*/				track.status (dtrack#)=j;				call count.retries(port#,track#);			}		}				/* else handle writes or write-file-marks to real tapes */				else		{			if (j&64)<>0               /* eof reached         */			then tape.eof(port#)=1;    /* but indicate data was written */				/* For wangdat  tapes,  the data most likely was not */			/* written at the end of the tape.  Check here.      */				if  ((j&64) <> 0)                        /* eot       */			and (port.last.io(port#) = Tape.Write )  /* on write  */			and (tape.type   (port#) = type.tan   )  /* to TAN    */			and (((j&15) = S$RecoveredError      )   /* some data */			or   ((j&15) = S$NoSense             ))  /* was not   */			and (VADD.Code.Seg       < 0          )  /* written   */			and (info2  <> 0                      )			then do;				/* nothing to do.  Data was not transferred */				/* to tape.  Tape.eof has been set.  Just   */				/* return without advancing tape.state      */				/* so that backup code asks for next        */				/* cartridge. The data will be written      */				/* in entirety to the next cartridge        */			end;				/* Ignore unit attentions - higher level       */			/* software will just try again.               */				/* anything else requires a closer look        */				else if (j&15)<>S$UnitAttention			then do;				if ((j&15)=S$RecoveredError)				or ((j&15)=S$NoSense       )				then do;					tape.state(port#)=tape.state(port#)+1;				end;					/* Tanberg drives report illegal requests when  */				/* writing to middle of tape.  Detect this and  */				/* report an error message to user:             */					else if  (port.last.io(port#) = Tape.Write)  /* write  */				and      (tape.type   (port#) = type.tan  )  /* to TAN */				and      ((j&15)              = S$IllegalRequest)				then do;					tape.write.code(port#) = 1;					port.retry(port#) = port.retry(port#) + 1; /* count as error in case code does not check tape.write.code!! */				end;					else do;					track.command(dtrack#)=S$RequestSense;					track.status (dtrack#)=j;					call count.retries(port#,track#);				end;			end;		}	end;	else if (port.last.io(port#)=Tape.Read ) /* tape read */	or      (port.last.io(port#)=Tape.Space) /* space     */	then do;                      /* request sense after read or space */		/* if reading from Jaz drive, update current position		*/		/* unless we are reading the directory							*/				if (tape.type(port#) == type.jaz)		{			if (((j&15)=S$RecoveredError)				/* if good status from the write, update	*/			||  ((j&15)=S$NoSense       ))			/* length & increment state					*/			{				if (port.jaz.update(port#) != 0)				{					port.jaz.sec.lsb(port#) = port.jaz.sec.lsb(port#) + port.jaz.update(port#);										if (port.jaz.sec.lsb(port#) ILT port.jaz.update(port#))						port.jaz.sec.msb(port#) = port.jaz.sec.msb(port#) + 1;				}								tape.state(port#)=tape.state(port#)+1;			}						else if ((j&15)<>S$UnitAttention)				/* ignore unit attention at this point, but	*/			{															/* indicates a serious error...  Post			*/				track.command(dtrack#)=S$RequestSense;		/* other likely fatal error...					*/				track.status (dtrack#)=j;				call count.retries(port#,track#);			}		}				/* else handle reads or space of real tapes */				else		{			if (j&15)=S$BlankCheck     /* blank check - eof reached */			then tape.eof(port#)=1;    /* indicate no data transferred */				/* fuj/exabyte/tandberg give an illegal request */			/* trying to read at the end of the tape after  */			/* having written some data.  treat as a        */			/* normal end of tape:                          */				else if  ((tape.type(port#) = type.fuj)			or        (tape.type(port#) = type.exa)			or        (tape.type(port#) = type.tan))			and ((j&15)=S$IllegalRequest)			then tape.eof(port#)=1;    /* for fuji indicates read at end of tape after a write.   do not treat as error */				else if (j&64)<>0          /* end of media (end of tape on fuji) */			then do;				tape.eof(port#)=1;      /* end of data record from fuji */				if  (tape.type    (port#) = type.fuj)				and (port.last.io (port#) = Tape.Read) /* read only */				then do;                /* back up one block to reposition tape for next read (should get consecutive end of tapes) */					i=start.tape.command(port#,track#,Tape.Space,-1);  /* space back 1 block */					if i<>0 then do;						call count.tape.retries(port#,track#);					end;					else port.space.info(port#)=1;  /* set space info to then go forward 1 block to reposition tape */				end;			end;				else if (j&128)<>0         /* file mark encountered */			then do;				tape.fmark(port#)=1;    /* file mark found       */				if  (tape.type    (port#) = type.fuj)				and (port.last.io (port#) = Tape.Space) /* file mark encountered during space + 1 or space - 1  : treat as normal termination */				then do;                /* back up one block to reposition tape for next read (should get consecutive end of tapes) */					if port.space.info(port#)=1 then do;  /* good status from space back 1 file mark on fuji */						i=start.tape.command(port#,track#,Tape.Space,1); /* now go forward 1 block */						if i<>0 then do;							call count.tape.retries(port#,track#);						end;						else port.space.info(port#)=2;					end;					else if port.space.info(port#)=2 then do; /* means we started with a read */						port.space.info(port#)=0;              /* tape.eof is set. tape is repositioned. do not increment tape state since we encountered eof during read */					end;                                      /* do not increment tape.state since we never read any data */					else do;    /* space from unknown source */						tape.state(port#)=tape.state(port#)+1;					end;				end;				end;				/* If we get a medium error while trying to read   */			/* the file mark at the end of a project,  then    */			/* treat as if a file mark was encountered.  This  */			/* will generally allow us to recover the data     */				else if ((j&15) = S$MediumError)			and     (tape.recover.code(port#) = 1)			then do;				tape.fmark(port#)=1;    /* file mark found       */				if tdebug then do;					print 'File Mark is bad ent end of project in drive ',port#+1;				end;			end;				else if (j&15)<>S$UnitAttention /* unit attention - do not even count retries */			then do;				if ((j&15)=S$RecoveredError)				or ((j&15)=S$NoSense       )				then do;					tape.state(port#)=tape.state(port#)+1;				end;				else do;					track.command(dtrack#)=S$RequestSense;					track.status (dtrack#)=j;					call count.retries(port#,track#);					if  (xdebug=0)   /* if I am not debugging */					and (tdebug=0)   /* the tapes...          */					and (((j&15)=S$MediumError  )					or   ((j&15)=S$HardwareError))					then call issue.reset(port#);				end;			end;		}	end;	/* for jaz drive: re-issue start unit on unit attention */		else if (port.last.io(port#) == Tape.LoadUnload)	{		j = (j and 15);              		/* extract sense key */				if (j == S$UnitAttention)			/* unit attention occurred */		{			zero.jaz.position(port#);		/* position and re-issue capacity request			*/						i=start.tape.command(port#, track#, Tape.LoadUnload, 1);	/* issue spin up 		*/						if i<>0 then do;					/* second spin-up bombed?   Wow!!!					*/				tape.state(port#)=tape.state(port#)+1;			end;		}				else				tape.state(port#) = tape.state(port#)+1;	}		else do;                      /* debugging? */		if i=0 then do;            /* good status */			tape.state(port#)=tape.state(port#)+1;		end;		else call count.retries(port#,track#);	end;end handle.tape.request.sense;handle.tape.mode.select:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl i               fixed;		/* see if phase is "Data Out" */	if (read(ScsiBus)&(S$SigMask))=S$DataOut	then do;				/* Write parameter list to tape */		/* Parameter List */		write(ScsiWord) = 0;                    /* Reserved */		if (tape.type(port#) = type.epi)		then write(ScsiByte) = shl(TapeBuffer,4) or TapeSpeed; /* Set buffer and speed */		else write(ScsiByte) = shl(TapeBuffer,4)             ; /* Set buffer mode only */		write(ScsiByte) = 8;                    /* Block descriptor length */		/* Block Descriptor List */		write(ScsiByte) = TapeDensity;          /* Set tape density */		write(ScsiWord) = 0;                    /* No. Blocks */		write(ScsiByte) = 0;		write(ScsiByte) = 0;                    /* Reserved */		write(ScsiByte) = 0;                    /* MSB of block size */		if tape.type(port#) <= type.fuj         /* EPI,FUJ: Variable */		then write(ScsiWord) = 0;               /* variable length blocks */		else if tape.type(port#) = type.tan		then write(ScsiWord) = 1024;            /* for Tandberg = 1024 only */		else write(ScsiWord) = TapeBlock;       /* Set tape block size    */		if tape.type(port#) = type.fuj then do;			write(ScsiByte) = shl(2,4);          /* use 2 channels         */		end;		else if tape.type(port#) = type.epi then do;			/* EPI Unique Parameters */			write(ScsiByte) = 0;                    /* Reserved */			write(ScsiByte) = shl(1,4) or shl(0,2) or shl(0,1) or 0; /* dual channel, error recover enabled, streaming, ECC enabled */			write(ScsiByte) = shl(1,1) or 0;        /* Message control bits */			write(ScsiByte) = 0;                    /* SCSI Burst Size */			write(ScsiWord) = 0;                    /* EOM Threshold */			write(ScsiWord) = 0;                    /* Reserved */			write(ScsiWord) = 0;                    /* Force Error Correction Vectors */		end;		else if tape.type(port#) = type.exa then do;			write(ScsiByte) = (4 \ 8);       /* set EBD and NBE bits */		end;		call deselect(port#);	end;	/* else assume is status phase at end of command */	else do;		i=shr(read(ScsiWord),8);       /* get status */		call deselect(port#);		port.io(port#)=0;   /* port is now free */		if  ((track#=xtrack)		and  (xdebug <>0   ))		or  ((tdebug <>0   )		and  (i      <>0   ))		then print 'Mode Select Status: ',port#,i;		if i = S$Good then do;      /* good status */			tape.state(port#)=tape.state(port#)+1;		end;		/* Many tapes will not allow a mode select */		/* if the tape is not at the start.  Treat */		/* as normal.                              */		else if (i = S$CheckCondition)		then do;			tape.state(port#)=tape.state(port#)+1;		end;		else if (i = S$Busy) then do; /* busy status      */			port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */			port.io   (port#) = Tape.Wait; /* go to this state to wait */		end;		else call count.retries(port#,track#);	end;end handle.tape.mode.select;handle.tape.mode.sense:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i)				  fixed;		/* see if phase is "data in" */	if (read(ScsiBus)&(S$SigMask))=S$DataIn	then do;		i = read(ScsiWord);		i = read(ScsiByte);		if (i&128) <> 0       /* if WP protect bit set */		then do;			if tape.to.use(port#) = 0			then tape.condition(port#) = tape.condition(port#)												\ t1.cond.wp;			else tape.condition(port#) = tape.condition(port#)												\ t2.cond.wp;		end;		i = read(ScsiByte);	end;	call toss.extra.data.bytes;	if (scanmessins(port#) != 0) toss.extra.mess.bytes();	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);          /* deselect   */	port.io(port#)=0;              /* done       */	if  ((track#=xtrack)	and  (xdebug <>0   ))	or  ((tdebug <>0   )	and  (i      <>0   ))	then print 'Mode Sense: ',port#,i,tape.to.use(port#),tape.condition(port#);	if i = S$Good then do;         /* good status */		tape.state(port#)=tape.state(port#)+1;	end;	else if i = S$Busy then do;    /* busy status */		port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */		port.io   (port#) = Tape.Wait; /* go to this state to wait, then retry */	end;	else call count.retries(port#,track#);end handle.tape.mode.sense;handle.tape.read.capacity: proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (i,j)			  fixed;		/* see if phase is "data in" */	if (read(ScsiBus)&(S$SigMask))=S$DataIn	then do;		port.jaz.cap.msb (port#) = read(ScsiWord);		/* get msb of lba */		port.jaz.cap.lsb (port#) = read(ScsiWord);		/* get lsb of lba */		i = read(ScsiWord);										/* get block size */		j = read(ScsiWord);				if (i != 0 || j != 512)									/* check blk size */		{			if (inc.jaz.prints)				print 'JAZ Drive: bad block size';						port.jaz.cap.msb (port#) = 0;			port.jaz.cap.lsb (port#) = 0;		}				if ((port.jaz.cap.msb(port#) != 0)					/* if nonzero, add	*/		||  (port.jaz.cap.lsb(port#) != 0))					/* one to get size   */		{			port.jaz.cap.lsb(port#) = port.jaz.cap.lsb(port#) + 1;						if (port.jaz.cap.lsb(port#) == 0)				port.jaz.cap.msb(port#) = port.jaz.cap.msb(port#)  + 1;							if (inc.jaz.prints)				print 'Got JAZ Capacity: ', port#, port.jaz.cap.msb(port#), port.jaz.cap.lsb(port#);		}	end;	call toss.extra.data.bytes;	if (scanmessins(port#) != 0) toss.extra.mess.bytes();	i=shr(read(ScsiWord),8);       /* get status */	call deselect(port#);          /* deselect   */	port.io(port#)=0;              /* done       */	if  ((track#=xtrack)	and  (xdebug <>0   ))	or  ((tdebug <>0   )	and  (i      <>0   ))	then print 'Read Capacity: ',port#, port.jaz.cap.msb (port#), port.jaz.cap.lsb (port#);	if i = S$Good then do;         /* good status */		tape.state(port#)=tape.state(port#)+1;	end;	else if i = S$CheckCondition 	/* check condition status */	then do;								/* e.g. not ready			  */		port.last.io(port#) = Tape.ReadCapacity;		i = start.tape.command(port#, track#, Tape.RequestSense, 7);		if i<>0 then do;			call count.tape.retries(port#,track#);		end;	end;	else if i = S$Busy then do;    /* busy status */		port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */		port.io   (port#) = Tape.Wait; /* go to this state to wait, then retry */	end;	else call count.retries(port#,track#);end handle.tape.read.capacity;port.check:proc;                        dcl (port#)       fixed;   dcl (track#)      fixed;   dcl (dtrack#)     fixed;   dcl (i,j,k)       fixed;   dcl (ourtrack#)   fixed;   dcl (count)       fixed;   dcl (sstatus)     fixed;   update.for.read.ok:proc;      dcl (buf#)   fixed;      dcl (len#)   fixed;      dcl (base)   fixed;      dcl (fade)   fixed;      dcl (local)  fixed;      len# = port.io.len#(port#);          /* get length handy */      do case (port.update(port#)-1);      /* branch on type   */      do;                                  /* normal data transfer to buf1 */         buf#  =port.io.buf#  (port#);     /* get buf # handy */         do case (buf#-1);                 /* update according to function */            do;               buf1.len(track#)=buf1.len(track#)+len#;            end;            do;               buf2.len(track#)=buf2.len(track#)+len#;               if buf2.len(track#) igt clob.len(track#)               then clob.len(track#) = buf2.len(track#);            end;            do;               buf3.len(track#)=buf3.len(track#)+len#;            end;            do;               clob.len(track#)=clob.len(track#)-len#;            end;         end;         fade = 0;                           /* assume no fade done   */         if (port.fadein(port#)        = 1)  /* if this is cue splice */         or (track.mode.change(track#) = 1)  /* or mode change        */         then do;                            /* then ramp out/ramp in */            call fadeout(port.pmemsec(port#),port.pmemwrd(port#));            call fadein (port.pmemsec(port#),port.pmemwrd(port#));            port.fadein (port#)       = 0;            track.mode.change(track#) = 0;            fade              = 1;         end;         if port.fadeout(port#)=1          /* construct fade out at end of */         then do;                          /* cue while reading backwards  */            call fadeout(port.pmemsec(port#)+len#,port.pmemwrd(port#));            call fadein (port.pmemsec(port#)+len#,port.pmemwrd(port#));            port.fadeout(port#)=0;         /* just in case                  */         end;         /* Process DDT data if doing multi-track Direct                    */         /* Digital Transfer:                                               */			#if (inc.multi.udio)				if  ((Dig.Xfer.Mode & (Dig.Out\Dig.In)) <> 0) /* doing ddt    */				and ( DDT.Connect.Mode         <> 0)   /* via multi-track     */				and ( Port.DDT(port#)          <> 0)   /* ddt available       */				and ( now.looping   =  0)       /* also skip while looping                   */				and ( func          =  0)       /* and not doing poly transfer items         */				and ( new.dtd.song# =  0)       /* and not trying to change DDT mode         */				and ( Stop.DDT.Units=  0)       /* and not trying to stop output             */				and (( tracks.per.port <= 2)    /* and normal system                         */				or   ((track# & (tracks.per.port-1)) < 2))   /* or first 2 trks              */				then do;						DDT.Mode = Port.DDT.Mode(port#);       /* look up mode          */						if  ((Dig.Xfer.Mode & Dig.Out)   <> 0) /* doing ddt output */					and ((DDT.Mode      & FE_Dir_In) =  0) /* to this box      */					then do;							call quickly.select.port(port#);							if buf# = 1                         /* get sample #     */						then base = buf1.lsb(track#) + shl(buf1.len(track#) - len#,8);						else base = buf2.lsb(track#) + shl(buf2.len(track#) - len#,8);							/* Construct fade out of data already in buffer if we just      */						/* did a fade out above.                                        */							if fade <> 0						then call Construct.DDT.Ramp.Out(track# & (tracks.per.port-1),																	base - output.s#.lsb);							/* Enable SCSI buffer memory for transfer of data out to        */						/* the DDT unit:                                                */							call targ0.connect(1);   /* connect to lun 1        */						write(ScsiByte)=3\shl((shr(port.pmemsec(port#),8)&"3"),2);						write(ScsiWord)=shl(port.pmemsec(port#),8);						port.lun1 (port#)=1;     /* inidicate lun1 enabled! */							port.io (port#) = Port.DDT.Write.Command.Code;    /* save our command code   */							call Start.DDT.Write(track# & (tracks.per.port-1), 													base - output.s#.lsb, 													shl(len#,8), 													SCSI_Target_Mode);						if DDT.Hardware.Bug#1 then do;							/* don't need to do anything because the buffer memory */							/* card will graciously provide an extra word without  */							/* complaining                                         */						end;							call deselect(port#);         /* disconnect from port */						end;						else if ((Dig.Xfer.Mode & Dig.In   ) <> 0) /* doing ddt input */					and     ((DDT.Mode      & FE_Dir_In) <> 0) /* from this box   */					and     ( Track.sampling(track#)     =  4) /* DIG in selected */					and     ( new.inputs                 =  0) /* not changing    */					then call Process.Multi.DDT.Input(Port#, Track#, 0);					end;			#endif      end;      do;        /* update diskread info during tape backup */         /* If we are writing to the AUX tapes,  update the variables */         /* for MAX.PORTS;  else update variables for our port.       */         local = port.upcode(port#);       /* get port# to update     */         if local <> port# then do;            if port.io(local) = Tape.Park  /* unblock the         */            then port.io(local) = 0;       /* process.            */         end;         tape.read.len          (local)=tape.read.len  (local)+len#;  /* update buffer position */         tape.data.lsb          (local)=tape.data.lsb  (local)+len#;  /* update start sector    */         if tape.data.lsb       (local) ilt len#                      /* of song                */         then tape.data.msb     (local)=tape.data.msb  (local)+1;             if tape.copy.len.lsb   (local) ilt len#                      /* reduce length of this  */         then tape.copy.len.msb (local)=tape.copy.len.msb(local)-1;   /* block left to copy     */         tape.copy.len.lsb      (local)=tape.copy.len.lsb(local)-len#;         if tape.len.lsb        (local) ilt len#                      /* reduce length of song  */         then tape.len.msb      (local)=tape.len.msb(local)-1;        /* left to copy           */         tape.len.lsb           (local)=tape.len.lsb(local)-len#;      end;      do;                       /* update DDT zeroing via diskread */         track.ddt.ptr (track#) = track.ddt.ptr(track#) + len#;         track.ddt.ctr (track#) = track.ddt.ctr(track#) + len#;      end;      end;   end update.for.read.ok;   update.for.write.ok:proc;      dcl (len#)   fixed;      dcl (local)  fixed;      len# = port.io.len#  (port#);           do case (port.update(port#)-1);         do;  /* 1: normal recording data write */            /* note: we could be writing significantly beyond the */            /* end of the buffer in the case of writing DDT input */            /* data.   Check for a new recb.msb,lsb carefully!    */            if (shr(rec.s#.lsb(track#) - recb.lsb(track#), 8) + len#)               >= buf.len            then do;                   /* update recb on wrap */               recb.lsb(track#)=recb.lsb(track#)+shl(buf.len,8);               if recb.lsb(track#) ilt (shl(buf.len,8))               then recb.msb(track#)=recb.msb(track#)+1;            end;            rec.s#.lsb(track#)=rec.s#.lsb(track#)+shl(len#,8);            if rec.s#.lsb(track#) ilt shl(len#,8)            then do;         /* wrap                 */               rec.s#.msb(track#)=rec.s#.msb(track#)+1;            end;            if piolen(track#)<>0                  /* if data came from punch */            then do;                              /* in cross fade, then     */               piolen(track#)=piolen(track#)-len#;  /* account for that        */            end;            call update.adir.after.write(port#, dtrack#);            /* Check for DDT multi-track input transfer */            /* needed after writing to disk.            */				#if (inc.multi.udio)					if  ((Dig.Xfer.Mode & (Dig.Out\Dig.In)) <> 0) /* doing ddt    */					and ( DDT.Connect.Mode         <> 0)   /* via multi-track     */					and ( Port.DDT(port#)          <> 0)   /* ddt available       */					and ( func          =  0)       /* and not doing poly transfer items         */					and (( tracks.per.port <= 2)    /* and normal system            */					or   ((track# & (tracks.per.port-1)) < 2))   /* or first 2 trks */					then do;							DDT.Mode = Port.DDT.Mode(port#);       /* look up mode          */							if  ((Dig.Xfer.Mode & Dig.Out)   <> 0) /* doing ddt output */						and ((DDT.Mode      & FE_Dir_In) =  0) /* to this box      */						then do;							/* if recording on track,  the track is READY,  so      */							/* the box should be receiving data rather than         */							/* sending any data.   So we should never get here.     */						end;							else if ((Dig.Xfer.Mode & Dig.In   ) <> 0) /* doing ddt input */						and     ((DDT.Mode      & FE_Dir_In) <> 0) /* from this box   */						and     ( Track.sampling(track#)     =  4) /* DIG in selected */						then call Process.Multi.DDT.Input(Port#, Track#, 0);					end;				#endif         end;         do;      /* 2: write to disk after tape read (load) */            /* If we are writing to the AUX tapes,  update the variables */            /* for MAX.PORTS;  else update variables for our port.       */            local = port.upcode(port#);       /* get port# to update     */            if local <> port# then do;               if port.io(local) = Tape.Park  /* unblock the         */               then port.io(local) = 0;       /* process.            */            end;            tape.buf.len (local)=tape.buf.len (local)+len#;            tape.data.lsb(local)=tape.data.lsb(local)+len#;            if tape.data.lsb(local) ilt len#            then tape.data.msb(local)=tape.data.msb(local)+1;            call update.adir.after.write(port#, dtrack#);         end;         do;     /* 3: write of cue data to disk */            if cue.write.sec#(track#)<>0 then do;   /* detect process being restarted while we are writing */               if cue.write.sec#(track#)=zero.sec#               then cue.info.to.write = cue.info.to.write & (not(bits(track#)));               else cue.write.sec#(track#) = cue.write.sec#(track#)+len#;            end;         end;         do;     /* 4: write of zeros to clean up adir */            call update.adir.after.write(port#, dtrack#);         end;         do;     /* 5: write of data from digital transfer from synclav */            read.track.written(track#) = read.track.written(track#) + port.io.len#(port#);            call update.adir.after.write(port#, dtrack#);            bitmsb=port.secmsb  (port#);              bitlsb=port.seclsb  (port#) + port.io.len#(port#);            if bitlsb ilt port.io.len#(port#) then bitmsb = bitmsb + 1;            call update.song.and.track.used(track#);  /* update used from sector # = bitmsb, bitlsb */         end;         do;     /* 6: successful track directory write */            write.magic.tracks = write.magic.tracks \ bits(track#);         end;      end;   end update.for.write.ok;   timeout:proc;                         /* issue reset after timeout */      print 'Port Timeout: ',port#, track#;      call count.retries(port#,track#);      call select.d24(port.d24.#(port#));      i=select.port.or.start.reset(port#,lun0.penable);      if i<>0 then do;   /* could not connect - issued reset */         call count.retries(port#,track#);      end;      else do;    /* we got onto bus */         j=wait.for.busfree.or.start.reset(port#);         if j<>0 then do;      /* same as above: could not */            /*   */            /* get bus,  but reset      */         end;                  /* has gone out             */         else do;              /* clean up target 1        */            if port# < max.ports then do;               call targ0.connect(1);               write(ScsiByte)=0;               port.lun1(port#)=0;            end;            port.io         (port#)=0;            call deselect   (port#);         /* disconnect from port */            call issue.reset(port#);         end;      end;   end timeout;   /* $page - check for status phase: */   /* see if port is in status phase  */   /* if so, get status byte          */   /* if status phase:                */   /*   return 1;  sstatus = status   */   check.for.status.phase:proc;     /* read,write,sense: check for status */      /* select port # */      if (sstatus&(L$SigMask\S$Req))=(L$Status\S$Req)      then do;         call select.d24(port.d24.#(port#));         i=select.port.or.start.reset(port#,lun0.penable);         if i<>0 then do;   /* could not connect - issued reset */            call count.retries(port#,track#);         end;         else do;    /* we got onto bus */            i=shr(read(ScsiWord),8);          /* get it    */            j=wait.for.busfree.or.start.reset(port#);            if j<>0 then do;      /* reset was issued      */                call count.retries(port#,track#);            end;                  /* has gone out             */            else do;              /* return sstatus           */               sstatus = i;               return 1;            end;         end;      end;      else if ((real.seconds  >= port.timer(port#)) \ xdebugreset)      and     (port.io(port#) <> Tape.Space                      )      then do;                    /* timeout occurred     */         call timeout;      end;      return 0;   end check.for.status.phase;   /* $page check.for.data.in.phase.after.sense */   /* see if bus is in data in phase.   used after a sense command */   /* to get the sense code                                        */   /* checks sense code                                            */   /* returns 1 if sense code was 'no error' or 'recovered error'  */   check.for.data.in.phase.after.sense:proc;      if (sstatus&S$Req)<>0      then do;         call select.d24(port.d24.#(port#));         i=select.port.or.start.reset(port#,lun0.penable);         if i<>0 then do;       /* reset was issued */            call count.retries(port#,track#);         end;         else do;    /* we got onto bus */            /* see if phase is "data in" */            if (read(ScsiBus)&(S$SigMask))=S$DataIn            then do;               i=read(ScsiWord);               j=read(Scsibyte) and "HF";               i=read(ScsiWord);               i=read(ScsiWord);            end;            else j=S$NoData;            call toss.extra.data.bytes;            i=shr(read(ScsiWord),8);       /* toss status */            port.io(port#)=0;         		 /* port is now free */				/* if not ready, issue a start unit and retry the command */								if (j == S$NotReady)				{            	call deselect(port#);         /* disconnect from port */										tptr = port.tptr(port#);										Issue.Start.Unit(0, 1);							port.io    (port#) = Port.Start.Unit.Code;      			port.timer (port#) = real.seconds + 45;				}								/* else if unit attention, just retry */								else if (j == S$UnitAttention)	            call deselect(port#);         /* disconnect from port */				/* else post errors for others */				else				{               if (j=S$RecoveredError)               or (j=S$NoSense       )               then return 1;                              track.command(track#)=S$RequestSense;               track.status (track#)=j;					call count.retries(port#,track#);            	call deselect(port#);         /* disconnect from port */           }				         end;      end;      else if (real.seconds >= port.timer(port#))      then do;                    /* timeout occurred     */         call timeout;      end;      return 0;   end check.for.data.in.phase.after.sense;   /* $page - check tape status */   /* this procedure is used after non-data tape commands */   /* it checks for S$REQ,  ignores extra message in bytes */   /* returns 1 if S$REQ is set                            */   check.tape.status:proc;      if (sstatus&S$Req)<>0      then do;         call select.d24(port.d24.#(port#));         i=select.port.or.start.reset(port#,lun0.penable);         if i<>0 then do;   /* could not connect - issued reset */            call count.retries(port#,track#);         end;         else do;    /* we got onto bus */            if  ((read(ScsiBus)&(S$SigMask))=S$MessIn)            and (scanmessins(port#)         <>      0)            then do;               write("300")=read(ScsiByte);  /* disconnects, save data pointers, identify */               call deselect(port#);         /* disconnect from port */            end;            else do;       /* return 1 if we have S$REQ and we */               return 1;   /* have connected to the bus.       */            end;         end;      end;      else if (real.seconds >= port.timer(port#))      then do;                    /* timeout occurred     */         call timeout;         if tdebug then do;            print 'Port',port#,' Tape Timeout';         end;      end;      return 0;   end check.tape.status;   /* $page procedure used with read and write commands */   /* 1: ignore message bytes                     */   /* 2: return 1 if status phase is on bus       */   check.tape.data.xfer.status:proc;      if  ((sstatus&(L$SigMask\S$Req))=(L$MessIn\S$Req))      and (scanmessins(port#)         <>      0)      then do;         call select.d24(port.d24.#(port#));         i=select.port.or.start.reset(port#,lun0.penable);         if i<>0 then do;      /* see if reset was issued */            call count.retries(port#,track#);         end;         else do;            write("300")=read(ScsiByte);  /* disconnects, save data pointers, identify */            call deselect(port#);         /* disconnect from port */         end;      end;      else if (sstatus&(L$SigMask\S$Req))=(L$Status\S$Req)      then do;         call select.d24(port.d24.#(port#));         i=select.port.or.start.reset(port#,lun0.penable);         if i<>0 then do;      /* see if reset was issued */            call count.retries(port#,track#);         end;         else do;              /* we got onto bus */            return 1;         end;      end;      else if ((real.seconds >= port.timer(port#)) \ xdebugreset)      then do;                    /* timeout occurred     */         call timeout;         if tdebug then do;            print 'Port',port#,' Tape Data Timeout';         end;      end;      return 0;   end check.tape.data.xfer.status;	/* Check for drive readiness before updating system info to disk */		check.for.disk.readiness: proc;   			tptr = (track#*total.stride);				/* Only check the first drive in the track list, since that's all			*/		/* we write system data to with readdata and writedata.						*/				if (((track.drive.exists & (16|32)) != 0)			/* if drive is remvable */		&&  ( track.data.msb(track#)        == 0)			/* or has been stopped  */		&&  ( track.data.lsb(track#)        == 0))		/* and is not shared    */		{																/* or we own it, look.. */			if (Test.Unit.Ready() != 0)		/* if drive is not ready, issue		*/			{											/* a start unit to try to wake it	*/				Issue.Start.Unit(0, 1);		 	/* up...										*/				port.io    (port#) = Port.Start.Unit.Code;      		port.timer (port#) = real.seconds + 45;				port.tptr  (port#) = tptr;								return 1;			}						/* once the drive tells us it's ready, we no longer						*/			/* have to check non-removable drives...										*/						track.drive.exists = track.drive.exists & (not(16));		}				return 0;		end check.for.disk.readiness;	   /* $page - begin port.check by checking for manual data transfer to AUX drive */   /* The auxiliary tape drive is connected to D24 #1.  This is     */   /* accessed in the software as port # 8.                         */   /* Since there is no buffer memory/DMA hardware on this port,    */   /* the computer must transfer data to this tape using            */   /* programmed I.O.   Do so here.                                 */   if port.io(max.ports) <> 0 then do;       /* D24 #1 is active    */      port# = max.ports;                     /* set port#           */      call select.d24(port.d24.#(port#));    /* select the d24      */      /* Check for occasional reselections here:                    */      if  ((read(ScsiBus ) & S$BusMask) = (S$SEL\S$I.O))      and ((read(ScsiData) & bits(Old.S.Initiator)) <> 0   )      then do;         write(ScsiBus) = S$BSY;         do while (read(ScsiBus) & S$SEL) <> 0; end;         write(ScsiBus) = 0;      end;      /* if REQ is asserted,  check for data transfer phase:        */      if (read(ScsiBus) & S$REQ) <> 0        /* check further only  */      then do;                               /* if REQ              */         if (port.io(max.ports) = tape.read       )  /* if reading  */         or (port.io(max.ports) = tape.readreverse)  /* then check  */         then do;                                    /* for data in */            call psmwrite(port.tape.addr(port#), 0);  /* set poly adr */            more.tape.read:;            if (read(ScsiBus)&(S$SigMask))=S$DataIn   /* if data in   */            then do;                                  /* then snarf   */               rpc 256;                               /* data         */               write(psd) = read(ScsiWord);           /* quickly ...  */               port.tape.addr(port#) = port.tape.addr(port#) + 1;               /* Wait a short moment here to see if REQ comes */               /* immediately back for the next sector         */               do i = 0 to 10;                  if (read(ScsiBus) & S$REQ) <> 0                   then goto more.tape.read;               end;            end;         end;         else if port.io(max.ports) = tape.write         then do;            call psmread(port.tape.addr(port#), 0);  /* set poly adr */            more.tape.write:;            if (read(ScsiBus)&(S$SigMask))=S$DataOut            then do;               rpc 256;               write(ScsiWord) = read(psd);               port.tape.addr(port#) = port.tape.addr(port#) + 1;               /* Wait a short moment here to see if REQ comes */               /* immediately back for the next sector         */               do i = 0 to 10;                  if (read(ScsiBus) & S$REQ) <> 0                   then goto more.tape.write;               end;            end;         end;      end;   end;