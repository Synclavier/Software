/* TALKSOUA - ROUTINES FOR COMMUNICATION WITH MAIN SYNCLAVIER *//* Syncl/Lod/Scsi Variables *//* 07/29/91 - cj - Added Dtd.Scrub for DSP add position tracking    */dcl (scsi.in.msg)        fixed PUBLIC;dcl (scsi.in.buf) (515)  fixed PUBLIC; /* need 0-512 (ie 513 words) */                                       /* to hold event info.       */                                       /* must match lod.cue.max.   */                                       /* also holds 2 words of     */                                       /* sync info for 130         */                                       /* messages.                 *//* variables for communicating with main synclavier. */dcl (send.screen.length) fixed PUBLIC;dcl (send.ddu.info)      fixed PUBLIC;  /* 1: send disk dump info                  */dcl (send.scroll.info)   fixed PUBLIC;  /* send current triggered time             */dcl (send.scrub.info)    fixed PUBLIC;  /* send current scrub position             */dcl (send.dtd.cue )      fixed PUBLIC;  /* send cue id# and maybe record over      */dcl Synclav.Time.Base.Adjust fixed PUBLIC; /* sent to adjust synclav time base     */dcl (new.dig.xfer.mode)   fixed PUBLIC; /* handles user changes gently  */dcl show.all.track.readys fixed PUBLIC; dcl (max.trax.enabled )   fixed PUBLIC; /* true if max trax enabled     *//* initialization info that synclavier likes to know about: *//* other variables sent to synclav */dcl (dtd.cue#          ) fixed PUBLIC;dcl (Cur.Dtd.Ms)     (1) fixed PUBLIC;  /* scroll information for synclavier */dcl (Dtd.Scrub )     (1) fixed PUBLIC;  /* current dtd scrub position        *//* Compute Bounds: this routine computes the sector address and length *//* of the current project, in sectors                                  *//* the global variables S.Start and S.End must be set up before        *//* calling compute.bounds.  Compute.Bounds computes the starting       *//* sector and length (in sectors) that go with the project start       *//* and end times.                                                      */Compute.Bounds: proc(DataArr, LenArr) PUBLIC;  /* compute bounds for current song */   dcl DataArr  array;   dcl LenArr   array;   call STR32(0, S.Start, Bit);   call ratio_multiply(50000,256);		/* get sector # to start     */   call unround;   call COPY32(Bit,DataArr);				/* copy to data array   */   call ADD16 (data.sec#,DataArr);		/* add data sec# offset */   if s.end ige s.start then do;			/* if end > start, use it    */      bitmsb=0; bitlsb=s.end;      call ratio_multiply(50000,256);	/* get sector # to end       */      call unround;      call COPY32(Bit,LenArr);       call ADD16 (data.sec#,LenArr);      call SUB32 (LenArr,DataArr,LenArr);      return 0;   end;   else do;      call STR32(0,0,LenArr);      return 1;   end;end Compute.Bounds;/* inverse of compute.bounds for adir graphic display *//* pass sector msb, sector lsb.  Compute what time (in seconds) corresponds *//* to this sector #                                                         */Compute.Start.Time: proc(sec#) PUBLIC;   dcl sec#      array;  /* pass 32 bit disk sector # */   /* remove data.sec# offset: */   call COPY32(sec#,    Bit);   call SUB16(data.sec#,Bit);   call ratio_multiply(256,50000);		/* get seconds start time */   return bitlsb;end Compute.Start.Time;