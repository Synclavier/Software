   /* LOD1-27 - now perform Direct Digital Transfer Output Routing */   /* 8/13/91 - cj - fixed DDT buffering bug (subtle DD prob)      */   /* 4/02/91 - cj - fixed don dorsey click & pop bug              */   /* 3/27/89 - cj - check for data available before bouncing to   */   /*                achieve 50 Khz data rate with max trax bounce */   /* The following code performs the digital transfer of audio  */   /* data out to both a DDT output,  and back to poly memory    */   /* to perform a digital bounce operation.                     */   /*                                                            */   /* For DDT Output:                                            */   /*    The above code has set up "Desired.Voice#" for each DDT.*/   /*    This holds 256 + the voice# of the voice that is routed */   /*    to this DDT (if any)                                    */   /*                                                            */   /* For BOUNCE Output:                                         */   /*    "Logical" DDT paths are used to perform bouncing.  For  */   /*    each path (max of 2) there is a source track/voice,     */   /*    and a destination track#.  We look up this information  */   /*    below.                                                  */   /*                                                            */   /* Our job is to loop over all DDTs,  see what voice/track    */   /* is routed to this DDT Output or Bounce,  and send the      */   /* right data to the correct source                           */   /*                                                            */   /* The following variables are set up below:                  */   /*                                                            */   /*    code    - holds code # for type of data to send to DDT  */   /*    track#  - holds track # to get data from if code <> 0   */   /*    ria     - 0 if repro data,  1 if input data is desired  */   /*    dest#   - dest track# for digital bounce                */   /*                                                            */   /* Then,  the desired transfer out to the DDT is performed.   */   dcl dest# fixed;   if  (((Dig.Xfer.Mode & Dig.Bounce) <> 0)    /* if doing digital bounce */   and  ( new.inputs                   = 0))   /* and inputs stable       */   or  (((Dig.Xfer.Mode & Dig.Out   ) <> 0)    /* if doing digital output */   and  ( DDT.Connect.Mode             = 0)    /* through routable unit   */   and  ((aux.d24.# <> ddt.d24.#) or (port.io(max.ports) = 0))) /* aux tape not busy using UDIO d24 */   and ( Check.DDT     <> 0)  /* skip DDT check during pre-startup instant */   and ( now.looping   =  0)  /* also skip while looping                   */   and ( func          =  0)  /* and not doing poly transfer items         */   and ( new.dtd.song# =  0)  /* and not trying to change DDT mode         */   then do;      /* loop over all DDTS:                                               */      /*    Set code to 0 if no voice/track is routed to this ddt.         */      /*    Set code to 1 if a voice is routed to this DDT                 */      /*    Set code to 2 if a track is routed to this DDT                 */      do ddt# = 0 to max.ddts-1;       /* perform transfer for each DDT  */         code = 0;                     /* assume no audio data avail     */         /* if performing digital bounce, look up source voice# or       */         /* track #,  and the destination track#:                        */         if (Dig.Xfer.Mode & Dig.Bounce) <> 0  /* BOUNCE Output:         */         then do;            /* quit quickly if this logical DDT is not being used */            /* for bouncing:                                      */            if DDT.Bounce.Trk(ddt#) = 0                         then goto next.ddt;            dest# = DDT.Bounce.Trk(ddt#) & 255;   /* get dest trk#       */            if (DDT.Bounce.Sou(ddt#) & 512) <> 0  /* see if data comes   */            then do;                              /* from a voice        */               Voice# = DDT.Bounce.Sou(ddt#) & 255;  /* if so, get which */               if Desired.Track#(voice#) <> 0     /* if track is routed  */               then do;                           /* to this voice...    */                  code = 1;                       /* data is from voice  */                  track# = Desired.Track#(voice#) & 255;  /* get trk#    */               end;            end;            /* else bounce data must be coming directly from */            /* a track:                                      */            else do;               code   = 2;                           /* data is from track */               track# = DDT.Bounce.Sou(ddt#) & 255;  /* which one          */            end;         end;         /* else if performing DDT output,  see if a voice is routed     */         /* to this DDT                                                  */         else do;                         /* DDT Output                  */            if Desired.Voice#(ddt#) = 0   /* if no voice is assigned to  */            then do;                      /* this DDT, then turn it off  */               ddt.on.priority(ddt#) = 0; /* turn off immediately        */            end;            /* else if voice is routed to this DDT,  then pick up the       */            /* data that goes with the voice                                */            else do;               voice# = Desired.Voice#(ddt#) & 255;               /* if track data is going to this voice,  and                */               /* this voice is going to a DDT,  get the data from the      */               /* correct track and route it to this DDT output             */               if Desired.Track#(voice#) <> 0               then do;                  code = 1;                              /* data from voice */                  track# = Desired.Track#(voice#) & 255; /* look up track#  */               end;            end;         end;         /* if any data is to be routed,  check to make sure */         /* data is available:                               */         if code <> 0 then do;            ria    = Last.Ria(track#);        /* look up repro/input    */            if  (ria        = 1)              /* source trk is INPUT    */            and (new.inputs = 0)              /* input setup complete   */            and (track.sampling(track#) <> 0) /* with data coming in    */            and (output.happening       <> 0) /* for now, can only      */            then do;                          /* DDT/Bounce while play'g*/               /* code is all set */          /* get input data from    */            end;                              /* this track             */            else if  (    ria                       = 0   )   /* repro desired        */            and      (    track.recording (track#)  = 0   )   /* not recording        */            and      (    zap.buffer      (track#)  = 0   )   /* and buffers are good */            and      (    buf1.len        (track#)  > Current.Offs)            and      (((  trig                      <>0  )    /* about to trigger     */            and        ( (trig.tracks&bits(track#)) <>0 ))    /* on this track        */            or        ((  play                      <>0 )     /* or about to play     */            and        (((play.tracks&bits(track#)) <>0)      /* on this track, or a cue */            or          ((source.or.cue   (track#)) <>0))))   /* has been triggered by the sequencer on this track */            then do;               /* code is all set */            end;            /* Voice is in input mode with no input assigned,  or */            /* in repro mode and track is muted (etc.).  just     */            /* send out digital zeroes                            */            else do;               code = 0;            end;         end;         /* $page - Send digital data out to DDT */         /* We have determined what type of data we would like to */         /* send out to this DDT (IE data from a track,  or all   */         /* digital zeroes                                        */         /* Now perform the data transfer                         */         /* First check for changes in the output routing (IE     */         /* turning the DDT output on or off,  or switching to    */         /* a different track in the case of Dynamic Output       */         /* Allocation.    Perform these real time changes        */         /* gracefully (IE with ramp ins/ramp outs and at the     */         /* precise correct time if possible)                     */         /* Code = 0:  send out digital zeroes                    */         if code = 0                       /* desired data consists of   */         then do;                          /* digital zeroes             */            if ddt.on(ddt#) <> 0           /* if we had been sending     */            then do;                       /* real audio data out this   */                                           /* DDT,  then ramp down       */                                           /* at the precise time        */               if output.happening <> 0    /* if actually playing, then  */               then do;                    /* must ramp down             */                  /* Get location in DDT output SCSI buffer       */                  /* or BOUNCE dest track poly buffer where       */                  /* we should start sending out digital zeroes.  */                  /* The sample at this location of the buffer    */                  /* will be going out the door approx 25 msecs   */                  /* from now                                     */                  /* if data going out to the DDT port is from a cue     */                  /* trigger,  and the track in question has just been   */                  /* re-routed to another voice (DOA software),  then    */                  /* delay turning off the DDT output to capture the     */                  /* exact end of the cue                                */                  if  (ddt.on.priority(ddt#) = 1) /* DAC'ing cue data      */                  and (Com32(loc(addr(DDT.On.End(2*ddt#))),Dac.S#) >= lw#ieq)                  and (Com32(loc(addr(DDT.On.End(2*ddt#))),Adv.S#) <= lw#ieq)                  then do;                     if (Dig.Xfer.Mode & Dig.Out) <> 0 /* if doing DDT output   */                     then do;                        k = DDT.On.End(2*ddt#+1) - DDT.Base.Lsb(ddt#);                     end;                     else do;               /* if doing bounce       */                        if COM32(loc(addr(DDT.On.End(2*ddt#))), Next.Buf) >= lw#ieq                        then k = DDT.On.End(2*ddt#+1) - next.buf.lsb;                        else k = DDT.On.End(2*ddt#+1) - current.lsb;                     end;                  end;                  /* else if the audio we had been playing did not   */                  /* com from a clearly defined cue,  then switch    */                  /* to playing out digital zeroes as soon as we     */                  /* can (IE now + 5 milliseconds).   this happens   */                  /* when the user changes the output routing        */                  /* manually,  or if a repro track is soloed/muted  */                  /* with the track buttons.                         */                  else do;                     if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                     then do;                        i = Read.Selected.DDT.Front.End.Address.Pointer;                        j = shr(Current.Rate, 1);  /* get # of samples in 5 ms */                        k = i + j + 32;                     end;                     else do;               /* if doing bounce       */                        write(psc)=32;            /* chan 32             */                        write(psf)=psadsc32;      /* chan 32 lsb address */                        i = read(psd) - buf.base; /* rel to buf start    */                        j = shr(Current.Rate, 1);  /* get # of samples in 5 ms */                        k = (i + 255 + j + 32) & "177400";                        if k IGT shl(buf.len,8)                        then k = k - shl(buf.len,8);                     end;                  end;                  /* provide ramp down and zeroes to DDT output: */                  if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                  then do;                     /* Provide a ramp down of the digital data in the */                     /* SCSI buffer preceding the digital zeroes       */                     call Construct.DDT.Ramp.Out(ddt#, k);                     /* and send out an "extra" batch of zeroes here   */                     /* so that we try not to fall behind              */                     call Start.DDT.Write(ddt#, k, DDT.Chunk.Size, SCSI_Target_Mode);                     l = DDT.Chunk.Size;     /* write extra chunk of zeroes */                     do while l <> 0;        /* during state change to      */                        rpc 256;             /* give extra breathing room   */                        write(ScsiWord) = 0;                        l = l - 256;                     end;                     if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */                     ddt.zero.ptr(ddt#) = k + DDT.Chunk.Size;                  end;                  /* provide ramp down and zeroes during BOUNCE */                  else do;      /* Bounce Output:               */                     /* Provide a ramp down of the digital data in the */                     /* POLY buffer preceding the digital zeroes       */                     call FadeOut(compute.base.adr(dest#)                                   + buf.base                                  + rec.base                                   + shr(k,8),0);                     /* and send out an "extra" batch of zeroes here   */                     /* so that we try not to fall behind              */                     call psmwrite(compute.base.adr(dest#)                                   + buf.base                                  + rec.base                                   + shr(k,8),0);                     /* set up ddt.zero.ptr here since */                     /* we clobber K below:            */                     ddt.zero.ptr(ddt#) = k + DDT.Chunk.Size;                     if ddt.zero.ptr(ddt#) IGE (shl(buf.len,8))                     then ddt.zero.ptr(ddt#) = ddt.zero.ptr(ddt#) - shl(buf.len,8);                     l = DDT.Chunk.Size;     /* write extra chunk of zeroes */                     do while l <> 0;        /* during state change to      */                        rpc 256;             /* give extra breathing room   */                        write(psd) = 0;                        l = l - 256;                        k = k + 256;                        if k = shl(buf.len,8)                        then do;                           k = 0;                           call psmwrite(compute.base.adr(dest#)                                         + buf.base                                        + rec.base, 0);                         end;                     end;                  end;                  /* Finally,  set up the variables to send more digital */                  /* zeroes out to the output buffer until it is         */                  /* entirely filled with zeroes.                        */                  /* Note: at slow sampling rates,  there is the         */                  /* potential to come back and zero out the nonzero     */                  /* data in the output buffer that has not yet been     */                  /* played.   To solve this,  we would need some        */                  /* kind of timer on the zeroing process.               */                  /* It is unlikely that this problem will show up       */                  /* at "normal" sampling rates                          */                  ddt.zeroed  (ddt#) = 0;                  ddt.zero.ctr(ddt#) = 0;               end;               /* if not doing output now,  then just set up to */               /* zero entire buffer from the start of it       */               else do;                  ddt.zeroed  (ddt#) = 0;                  ddt.zero.ctr(ddt#) = 0;                  ddt.zero.ptr(ddt#) = 0;               end;               ddt.on         (ddt#) = 0;               ddt.on.priority(ddt#) = 0;            end;            /* fill scsi buffer memory with zeroes */            /* just once.                          */            if ddt.zeroed(ddt#) = 0            then do;               if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */               then do;                  call Start.DDT.Write(ddt#, ddt.zero.ptr(ddt#), DDT.chunk.size, SCSI_Target_Mode);                                 i = ddt.chunk.size;                  do while i <> 0;                     rpc 256;                     write(ScsiWord) = 0;                     i = i - 256;                  end;                  if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */                  ddt.zero.ptr(ddt#) = ddt.zero.ptr(ddt#) + ddt.chunk.size;               end;               else do;     /* Digital Bounce */                  call psmwrite(compute.base.adr(dest#)                                + buf.base                               + rec.base                                + shr(ddt.zero.ptr(ddt#),8),0);                  l = DDT.Chunk.Size;     /* write extra chunk of zeroes */                  do while l <> 0;        /* during state change to      */                     rpc 256;             /* give extra breathing room   */                     write(psd) = 0;                     l = l - 256;                     ddt.zero.ptr(ddt#) = ddt.zero.ptr(ddt#) + 256;                     if ddt.zero.ptr(ddt#) = shl(buf.len,8)                     then do;                        ddt.zero.ptr(ddt#) = 0;                        call psmwrite(compute.base.adr(dest#)                                      + buf.base                                     + rec.base, 0);                      end;                  end;               end;               ddt.zero.ctr(ddt#) = ddt.zero.ctr(ddt#) + 1;               if ddt.zero.ctr(ddt#) >= (1 fdiv DDT.Chunk.Size)               then ddt.zeroed(ddt#) = 1;            end;         end;         /* $page - send digital data from a track to the DDT  */         /* Code <> 0 fill DDT output buffer with data from     */         /* a certain track's memory.                           */         else do;            /* Check here to see if we are about to send out the   */            /* first batch of "real" digital data.   This happens  */            /* in real time when the user is using the Dynamic     */            /* Output Allocation software,  or when he is manually */            /* changing the output routing                         */                        /* Provide the necessary ramp-ins when changing        */            /* from digital zeroes to digital audio data           */            /* Detect change in output routing:                    */            if ddt.on(ddt#) <> (1 + ria + shl(track#,8) + shl(now.monitoring,2))             then do;                       /* Oops:  change!!!     */               if Output.Happening <> 0    /* changing while playing:  */               then do;                    /* must do gently           */                  /* see what sample # is actually being played at     */                  /* this instant so we can ramp in accurately.        */                  /* update DDT.S# here to find out precise sample     */                  /* going out now.                                    */                  if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                  then do;                     i = (Read.Selected.DDT.Word.Clock - DDT.Last)                       + Current.Rate              /* add 10 milliseconds */                       + 127;                      /* +127 so round32     */                                                   /* actually rounds     */                     call COPY32(DDT.S#, a);       /* up.                 */                     call ADD16(i, a);                                                                              call ROUND32(a);      /* start loading more       */                                           /* audio data with this     */                                           /* sample.   Other sample   */                                           /* might be used (see       */                                           /* below) if precise cue    */                                           /* trigger information      */                                           /* is available.            */                  end;                  else do;                 /* Digital Bounce           */                     write(psc)=32;            /* chan 32             */                     write(psf)=psadsc32;      /* chan 32 lsb address */                     i = read(psd) - chan32.last                       + Current.Rate          /* add 10 milliseconds */                       + 127;                  /* +127 so round32     */                                               /* actually rounds     */                     call COPY32(DAC.S#, a);   /* up.                 */                     call ADD16(i, a);                                                                              call ROUND32(a);      /* start loading more       */                                           /* audio data with this     */                                           /* sample.   Other sample   */                                           /* might be used (see       */                                           /* below) if precise cue    */                                           /* trigger information      */                                           /* is available.            */                  end;                  /* set up base lsb in case we are just turning the   */                  /* channel on:                                       */                  ddt.base.msb(ddt#) = output.s#.msb; /* output started */                  ddt.base.lsb(ddt#) = output.s#.lsb; /* here           */                  /* if routing data from a cue trigger out to the      */                  /* DDT output,  then start the cue trigger            */                  /* accurately (if possible)                           */                  if  (ria                      = 0)    /* repro        */                  and (code                     = 1)    /* voice output */                  and (Desired.Priority(voice#) = 1)    /* cue trig     */                  and (Com32(loc(addr(Desired.Sync(2*voice#))),a     ) >= lw#ieq)                  and (Com32(loc(addr(Desired.Sync(2*voice#))),Adv.S#) <= lw#ieq)                  then do;                     ddt.next.msb(ddt#) = Desired.Sync(2*voice#+0);                     ddt.next.lsb(ddt#) = Desired.Sync(2*voice#+1);                       /* perform no fade-in on cue trigger since we */                     /* probably have provided a ramp-in when      */                     /* we read the data from the disk.            */                     /* performing two ramp-ins might cut off      */                     /* the front of the cue                       */                  end;                  /* else if we had been routing data from a cue       */                  /* trigger out this ddt,  and it is switching back   */                  /* to 'repro' or (cue pb zeroes),  then switch       */                  /* at the end of the prior cue:                      */                  else                  if  (ria                      = 0)   /* repro        */                  and (code                     = 1)   /* voice output */                  and (DDT.On.Priority(ddt#)    = 1)   /* cue trig     */                  and (Com32(loc(addr(DDT.On.End(2*ddt#))),a     ) >= lw#ieq)                  and (Com32(loc(addr(DDT.On.End(2*ddt#))),Adv.S#) <= lw#ieq)                  then do;                     ddt.next.msb(ddt#) = DDT.On.End(2*ddt#+0);                     ddt.next.lsb(ddt#) = DDT.On.End(2*ddt#+1);                       /* perform fade-in in this case because we are  */                     /* likely switching back to repro data,  or     */                     /* to the middle of another cue if the user     */                     /* is using the DOA software to perform editing */                     Perform.Fadein = 1;                  end;                  /* else just start with data approx 10 msecs from now */                  else do;                     ddt.next.msb(ddt#) = a(0);  /* sample #.  Approx      */                     ddt.next.lsb(ddt#) = a(1);  /* 10 msecs from now.     */                     /* and always provide fade out when changing from */                     /* input to repro,  or manual changes,  etc.      */                     Perform.Fadein = 1;                  end;                  /* if prior data was not all zeroes,  then provide */                  /* ramp down of prior data just before new data    */                  /* begins:                                         */                  if ddt.on(ddt#) <> 0                  then do;                     if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                     then do;                        call Construct.DDT.Ramp.Out(DDT#,                                                    ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#));                     end;                     else do;              /* Digital Bounce */                        if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                        or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                        and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                        then j = ddt.next.lsb(ddt#) - next.buf.lsb;                          else j = ddt.next.lsb(ddt#) - current.lsb;                         call FadeOut(compute.base.adr(dest#)                                     + buf.base                                     + rec.base                                      + shr(j,8),0);                     end;                  end;                  /* when switching to input monitoring at start of */                  /* playback,  then provide digital zeros until    */                  /* enough samples have accumulated for our        */                  /* ddt monitor delay                              */                  if ria = 1                  then ddt.on.delay(ddt#) = ddt.monitor.delay;               end;               /* else if no output happening,  just set up */               /* for start of buffer load                  */               else do;                  ddt.base.msb(ddt#) = Desired.Buf1.Msb;                  ddt.base.lsb(ddt#) = Desired.Buf1.Lsb;                  ddt.next.msb(ddt#) = Desired.Buf1.Msb;                  ddt.next.lsb(ddt#) = Desired.Buf1.Lsb;                  /* Provide ramp - in if switching to input mode,  or */                  /* if playing repro data from disk.   Skip the ramp  */                  /* in if manually triggering a cue so that the       */                  /* front of the cue is not muted.                    */                  if  (trig =  0)                  or  (ria  <> 0)                  then Perform.Fadein = 1;               end;               ddt.on(ddt#) = 1 + ria + shl(track#,8) + shl(now.monitoring,2);            end;            /* else if no state change,  just check for missing buffers */            /* or other unusual situtations                             */            else do;               if Output.Happening = 0     /* if no output yet,  then     */               then do;                    /* initialize variables        */                  /* see if data in scsi buffer is from the wrong */                  /* place on the disk.  mark buffer as empty     */                  /* if so                                        */                  if (ddt.base.msb(ddt#) <> Desired.Buf1.Msb)                  or (ddt.base.lsb(ddt#) <> Desired.Buf1.Lsb)                  then do;                     ddt.base.msb(ddt#) = Desired.Buf1.Msb;                     ddt.base.lsb(ddt#) = Desired.Buf1.Lsb;                     ddt.next.msb(ddt#) = Desired.Buf1.Msb;                     ddt.next.lsb(ddt#) = Desired.Buf1.Lsb;                  end;                  /* perform fade in at start of attack buffer */                  if  (ddt.next.msb(ddt#) = ddt.base.msb(ddt#))                  and (ddt.next.lsb(ddt#) = ddt.base.lsb(ddt#))                  and ((trig =  0)          /* ramp-in if repro or */                  or   (ria  <> 0))         /* input data          */                  then Perform.Fadein = 1;               end;               /* else if output happening,  make sure ddt.base got */               /* set up ok                                         */               else do;                  if (ddt.base.msb(ddt#) <> Output.S#.Msb)                  or (ddt.base.lsb(ddt#) <> Output.S#.Lsb)                  then do;                     ddt.base.msb(ddt#) = output.s#.msb;                     ddt.base.lsb(ddt#) = output.s#.lsb;                     ddt.next.msb(ddt#) = dac.s#(0);                     ddt.next.lsb(ddt#) = dac.s#(1) & "177400";                     Perform.Fadein = 1;                  end;               end;            end;            /* if playing repro data from disk,  then see if disk */            /* buffer has the data we are looking for:            */            k = 0;   /* assume there is no data to be copied      */            if ria = 0   /* source track is in repro mode         */            then do;               /* save away some information about the audio      */               /* segment being played right now,  so that we     */               /* can turn off the DDT outputs more gracefully    */               /* at the end of a cue trigger                     */               if code = 1               then do;                  ddt.on.priority(ddt#) = Desired.Priority(voice#);                  call COPY32(loc(addr(Desired.End (voice#*2))),                              loc(addr(DDT.On.End  (ddt#  *2))));               end;               else do;                      /* data is from track */                  ddt.on.priority(ddt#) = 0; /* directly           */               end;               /* begin by seeing if the disk buffers contain      */               /* valid data for this segment of audio:            */               /* note: desired.buf1 could have wrapped into next  */               /* buffer but buf1.msb could still point to last    */               /* buffer since we only check buf1.msb between      */               /* every disk command.                              */               if  ((buf1.msb(track#) = desired.buf1.msb)  /* if buffers   */               and  (buf1.lsb(track#) = desired.buf1.lsb)) /* valid, then  */               or  ((buf2.msb(track#) = desired.buf1.msb)  /* then check   */               and  (buf2.lsb(track#) = desired.buf1.lsb))               then do;                                                      a(0) = buf1.msb(track#);    /* get buf1 start in more      */                  a(1) = buf1.lsb(track#);    /* convenient form             */                  call add16(shl(buf1.len(track#),8), a); /* get end of buf1 */                  /* see if track data buffer has been tossed out or */                  /* shortened.   reduce valid data in scsi output   */                  /* buffer if so                                    */                  if  (buf1.len(track#) <> buf.len)       /* if buf1 is end of  */                  or  (buf2.len(track#) =  0      )                  then do;                                /* data, then check   */                     if  ((a(0) ILT ddt.next.msb(ddt#)))  /* see if buf1 has    */                     or  ((a(0)  =  ddt.next.msb(ddt#))   /* been shortened     */                     and  (a(1) ILT ddt.next.lsb(ddt#)))                     then do;                             /* if so, then trunc  */                        ddt.next.msb(ddt#) = a(0);        /* contents of scsi   */                        ddt.next.lsb(ddt#) = a(1);        /* ddt buffer to      */                                                          /* length of valid    */                                                          /* data               */                        /* also provide a ramp down of the data that */                        /* is in the buffer now,  so that we do not  */                        /* get a click at the start of the new       */                        /* data:                                     */                        if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                        then do;                           call Construct.DDT.Ramp.Out(ddt#, ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#));                        end;                        else do;                           if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                           or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                           and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                           then j = ddt.next.lsb(ddt#) - next.buf.lsb;                             else j = ddt.next.lsb(ddt#) - current.lsb;                            call FadeOut(compute.base.adr(dest#)                                        + buf.base                                        + rec.base                                         + shr(j,8),0);                        end;                     end;                  end;                  /* see if buf1 has data we need to send out */                  /* to the DDT                               */                  if  ((a(0) IGT ddt.next.msb(ddt#)))  /* see if buf1 has   */                  or  ((a(0)  =  ddt.next.msb(ddt#))   /* more data to be   */                  and  (a(1) IGT ddt.next.lsb(ddt#)))  /* written           */                  then do;                     /* get word offset in poly buffer where the next        */                     /* data sample should come from:                        */                     j = ddt.next.lsb(ddt#) - buf1.lsb(track#);                     /* get # of words in buf1 after ddt.next:               */                     k = a(1) - ddt.next.lsb(ddt#);                  end;                  /* Now check buf2 to see if it has some data for the DDT */                  if  (buf1.len(track#) =  buf.len)                  and (buf2.len(track#) <> 0      )                  and (buf2.msb(track#) =  a(0)   )                  and (buf2.lsb(track#) =  a(1)   )                  then do;                     b(0) = buf2.msb(track#);    /* get buf2 start in more      */                     b(1) = buf2.lsb(track#);    /* convenient form             */                     call add16(shl(buf2.len(track#),8), b); /* get end of buf2 */                     /* see if track data buffer has been tossed out or */                     /* shortened.   reduce valid data in scsi output   */                     /* buffer if so                                    */                     if  ((b(0) ILT ddt.next.msb(ddt#)))  /* see if buf2 has    */                     or  ((b(0)  =  ddt.next.msb(ddt#))   /* been shortened     */                     and  (b(1) ILT ddt.next.lsb(ddt#)))                     then do;                        ddt.next.msb(ddt#) = b(0);                        ddt.next.lsb(ddt#) = b(1);                        /* also provide a ramp down of the data that */                        /* is in the buffer now,  so that we do not  */                        /* get a click at the start of the new       */                        /* data:                                     */                        if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                        then do;                           call Construct.DDT.Ramp.Out(ddt#, ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#));                        end;                        else do;             /* dig bounce */                           if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                           or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                           and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                           then j = ddt.next.lsb(ddt#) - next.buf.lsb;                             else j = ddt.next.lsb(ddt#) - current.lsb;                            call FadeOut(compute.base.adr(dest#)                                        + buf.base                                        + rec.base                                         + shr(j,8),0);                        end;                     end;                     /* check buf2 to see if it has any data           */                     /* to be written out                              */                     if   ((b(0) IGT ddt.next.msb(ddt#)))  /* see if buf2 has  */                     or   ((b(0)  =  ddt.next.msb(ddt#))   /* more data to be  */                     and   (b(1) IGT ddt.next.lsb(ddt#)))  /* written          */                     then do;                        /* get word offset in poly buffer where the next      */                        /* data sample should come from:                      */                        if k = 0                        then j = ddt.next.lsb(ddt#) - buf2.lsb(track#);                        /* get # of words in buf2 after ddt.next:             */                        k = b(1) - ddt.next.lsb(ddt#);                     end;                  end;                  /* Limit the amount of data we copy to 1 sector before */                  /* the end of the data we have read in so that         */                  /* we wait for the cross fade to be constructed at     */                  /* the end of this segment.  The down-ramp at the end  */                  /* of this segment is actually constructed when the    */                  /* following block of information is read in !!!       */                  if k IGE 256 then k = k - 256;               end;            end;            /* else if we are monitoring data (INPUT) mode,  then    */            /* get data that we have stored in input buffer after    */            /* a short delay                                         */            else do;               ddt.on.priority(ddt#) = 0; /* no priority for input monitoring */               /* Provide digital zeroes during the first 75 milliseconds */               /* after switching to INPUT mode to erase random numbers   */               /* that might be sitting in the input buffer               */               if ddt.on.delay(ddt#) <> 0               then do;                  i = ddt.on.delay(ddt#);   /* get # of zeroes still needed */                  if i IGT ddt.chunk.size   /* limit to chunk size to keep  */                  then i = ddt.chunk.size;  /* machine from bogging down    */                  if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */                  then do;                     call Start.DDT.Write(ddt#,                                           ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#),                                           i, SCSI_Target_Mode);                     m = i;                     do while m <> 0;                        rpc 256;                        write(ScsiWord) = 0;                        m = m - 256;                     end;                     if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */                  end;                  else do;  /* Digital Bounce */                     if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                     or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                     and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                     then j = ddt.next.lsb(ddt#) - next.buf.lsb;                       else j = ddt.next.lsb(ddt#) - current.lsb;                      call psmwrite(compute.base.adr(dest#)                                   + buf.base                                  + rec.base                                   + shr(j,8),0);                     l = DDT.Chunk.Size;     /* write extra chunk of zeroes */                     do while l <> 0;        /* during state change to      */                        rpc 256;             /* give extra breathing room   */                        write(psd) = 0;                        l = l - 256;                        j = j + 256;                        if j = shl(buf.len,8)                        then do;                           j = 0;                           call psmwrite(compute.base.adr(dest#)                                         + buf.base                                        + rec.base, 0);                         end;                     end;                  end;                  /* account for data transfer: */                  ddt.next.lsb(ddt#) = ddt.next.lsb(ddt#) + i;                  if ddt.next.lsb(ddt#) ilt i                  then ddt.next.msb(ddt#) = ddt.next.msb(ddt#) + 1;                  ddt.on.delay(ddt#) = ddt.on.delay(ddt#) - i;                  if ddt.on.delay(ddt#) = 0       /* provide fade in to */                  then ddt.on.fade.in(ddt#) = 1;  /* next batch of data */               end;               /* otherwise see how many samples have come in the adc   */               /* that we can send out to the DDT                       */               /* (normally, ddt.next.lsb will be > dac.s#(1), since    */               /*  we hopefully have pre-filled the ddt output buffer   */               /*  with delayed audio input data.   ddt.next.lsb will   */               /*  be <= dac.s#(1) only when first switching to         */               /*  input mode)                                          */               else do;                  k = (Dac.S#(1) - ddt.next.lsb(ddt#) + ddt.monitor.delay) & "177400";                  /* but might be minus since we quickly wrote out a */                  /* stack of zeroes above.   might have to wait     */                  /* a while before we are ready to take the data    */                  if k < 0 then k = 0;                  /* compute where in poly memory the input data is:   */                  if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                  or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                  and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                  then j = ddt.next.lsb(ddt#) - next.buf.lsb;                    else j = ddt.next.lsb(ddt#) - current.lsb;                   /* now back up by 75 msecs of audio data       */                  /* to find out where data is in poly memory    */                  if j ILT ddt.monitor.delay                  then j = j - ddt.monitor.delay + shl(buf.len,8);                  else j = j - ddt.monitor.delay;                  Perform.Fadein = ddt.on.fade.in(ddt#);                  ddt.on.fade.in(ddt#) = 0;               end;            end;            /* transfer data from poly out to the DDT output buffer  */            /* if there is any data to transfer:                     */            if k <> 0 then do;               if   k IGT ddt.chunk.size  /* limit to non-time      */               then k  =  ddt.chunk.size; /* consuming chunk        */               l = compute.base.adr(track#);   /* get source base address */               if ria = 0               then call psmread(l + buf.base, j);  /* set pointer      */               else call psmread(l + buf.base + rec.base, j);               if (Dig.Xfer.Mode & Dig.Out) <> 0   /* if doing DDT output   */               then do;                  call Start.DDT.Write(ddt#,                                        ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#),                                        k, SCSI_Target_Mode);                                 m = k;                           /* transfer the audio */                  do while m <> 0;                 /* data from poly     */                     rpc 256;                      /* memory buffer      */                     write(ScsiWord) = read(psd);  /* to scsi buffer     */                     m = m - 256;                     j = j + 256;                     if j = shl(buf.len,8)                     then do;                        j = 0;                        if ria = 0                        then call psmread(l + buf.base, 0);                        else call psmread(l + buf.base + rec.base, 0);                     end;                  end;                  if DDT.Hardware.Bug#1 then write(ScsiWord) = 0; /* feed the hungry monster */                  if Perform.Fadein <> 0                  then call Construct.DDT.Ramp.In(DDT#,                                                  ddt.next.lsb(ddt#) - ddt.base.lsb(ddt#));               end;               else do;     /* Digital Bounce */                  /* Must check to see if we are over-writting data */                  /* in the input buffer that is not yet written    */                  /* to disk:                                       */                  if track.recording(dest#) <> 0   /* check further if    */                  then do;                         /* recording           */                     a(0) = rec.s#.msb(dest#);     /* get sample # we     */                     a(1) = rec.s#.lsb(dest#);     /* have written up to  */                     /* compute sample # where rotary buffer will wrap:   */                     call ADD16(shl(buf.len,8) - k, a);                     if  ((ddt.next.msb(ddt#) IGT a(0)))                     or  ((ddt.next.msb(ddt#)  =  a(0))                     and  (ddt.next.lsb(ddt#) IGT a(1)))                     then goto next.ddt;                /* just wait 'till */                  end;                                  /* next time       */                  /* move data to external memory temporarily: */                  write(mam) = bbuf.xmsec#;                                 m = k;                           /* transfer the audio */                  do while m <> 0;                 /* data from poly     */                     rpc 256;                      /* memory buffer      */                     write(mdi) = read(psd);       /* to ext memory      */                     m = m - 256;                     j = j + 256;                     if j = shl(buf.len,8)                     then do;                        j = 0;                        if ria = 0                        then call psmread(l + buf.base, 0);                        else call psmread(l + buf.base + rec.base, 0);                     end;                  end;                  /* now copy data from external memory */                  /* back to poly memory:               */                  if  ((ddt.next.msb(ddt#) IGT next.buf.msb))                  or  ((ddt.next.msb(ddt#)  =  next.buf.msb)                  and  (ddt.next.lsb(ddt#) IGE next.buf.lsb))                  then n = ddt.next.lsb(ddt#) - next.buf.lsb;                    else n = ddt.next.lsb(ddt#) - current.lsb;                   l = n;    /* save memory pointer for fade in */                  call psmwrite(compute.base.adr(dest#)                                + buf.base                               + rec.base                                + shr(n,8),0);                  write(mam) = bbuf.xmsec#;                  m = k;                           /* transfer the audio */                  do while m <> 0;                 /* data from ext      */                     rpc 256;                      /* memory buffer      */                     write(psd) = read(mdi);       /* to poly memory     */                     m = m - 256;                     n = n + 256;                     if n = shl(buf.len,8)                     then do;                        n = 0;                        call psmwrite(compute.base.adr(dest#)                                      + buf.base                                       + rec.base, 0);                      end;                  end;                  if Perform.Fadein <> 0                  then call FadeIn(compute.base.adr(dest#)                                   + buf.base                                  + rec.base                                   + shr(l,8),0);               end;               /* check for underrun here        */               if fastboot then do;                  if  (now.playing <> 0)                  and (((ddt.next.msb(ddt#) ILT Dac.S#(0)))                  or   ((ddt.next.msb(ddt#)  =  Dac.S#(0))                  and   (ddt.next.lsb(ddt#) ILT Dac.S#(1))))                  then print 'U',;               end;               /* account for the data transfer: */               ddt.next.lsb(ddt#) = ddt.next.lsb(ddt#) + k;               if ddt.next.lsb(ddt#) ilt k               then ddt.next.msb(ddt#) = ddt.next.msb(ddt#) + 1;            end;            perform.fadein  = 0;    /* hope we had the data above   */         end;         /* of nonzero digital audio to transfer */         next.ddt:;      end;            /* of loop over DDT's                   */   end;               /* of conditions met to transfer audio  */end voice.check;/* $page - perform DDT input data transfers *//* the routine Process.DDT.In is called to perform DDT transfers into *//* the synclavier from the DDT hardware.                              *//* It is passed the most recent sample # that corresponds to the      *//* sample that has most recently been stored in the DDT input         *//* memory                                                             *//* This routine is only used for the 2-track routable DDT             *//* hardware.                                                          */Process.DDT.In:proc (In.S#);   dcl In.S#     array;         /* holds sample # where poly system is at */   dcl (i,j,k,m) fixed;   dcl ddt#   fixed;   dcl track# fixed;   /* loop over all DDTS: */   do ddt# = 0 to max.ddts-1;       /* perform transfer for each DDT  */      if ddt.in.track#(ddt#) <> 0   /* see if this ddt input is       */      then do;                      /* routed anywhere                */         track# = ddt.in.track#(ddt#) & 255;  /* yes; get track#      */         /* if output is happening,  then get the data from */         /* the DDT unit and store in poly memory           */         if output.happening <> 0         then do;            /* provide 75 milliseconds of zeroes when starting up */            /* to provide digital silence during the input        */            /* monitoring delay period                            */                     if DDT.Input.Delay(ddt#) <> 0            then do;               i = DDT.Input.Delay(ddt#); /* get # of zeroes to write */               if i IGT DDT.Chunk.Size    /* limit to chunk to keep   */               then i = DDT.Chunk.Size;   /* machine from bogging.    */               /* get location in poly buffer where digital data      */               /* is to be stored                                     */               if  ((ddt.in.s#.msb(ddt#) IGT next.buf.msb))               or  ((ddt.in.s#.msb(ddt#)  =  next.buf.msb)               and  (ddt.in.s#.lsb(ddt#) IGE next.buf.lsb))               then j = ddt.in.s#.lsb(ddt#) - next.buf.lsb;                 else j = ddt.in.s#.lsb(ddt#) - current.lsb;                /* limit transfer to running into end of poly          */               /* buffer:                                             */               if (shl(buf.len,8) - j) ILT i               then i = shl(buf.len,8) - j;               call psmwrite(compute.base.adr(track#)                             + buf.base + rec.base, j);               /* write digital zeroes to provide monitoring delay */               k = i;               do while k <> 0;                  rpc 256;                         write(psd) = 0;                  k = k - 256;               end;               /* account for data transfer: */               ddt.in.s#.lsb(ddt#) = ddt.in.s#.lsb(ddt#) + i;               if ddt.in.s#.lsb(ddt#) ilt i               then ddt.in.s#.msb(ddt#) = ddt.in.s#.msb(ddt#) + 1;               ddt.input.delay(ddt#) = ddt.input.delay(ddt#) - i;               /* set flag to perform data fade in next time */               /* around if that will be our first bit       */               /* of real digital data:                      */               if   ddt.input.delay(ddt#) = 0               then ddt.in.fade.in (ddt#) = 1;            end;            /* else transfer data from DDT unit into poly memory */                    else do;               /* see how much data has been brought into the SCSI */               /* buffer in the DDT.                               */               i = (In.S#(1) - ddt.in.s#.lsb(ddt#) + ddt.monitor.delay) & "177400";               /* but might be minus since we quickly wrote out a */               /* stack of zeroes above.   might have to wait     */               /* a while before we are ready to take the data    */               if i > 0     /* transfer data into poly memory     */               then do;     /* if any is in the DDT               */                  if   i IGT ddt.chunk.size  /* limit to non-time      */                  then i  =  ddt.chunk.size; /* consuming chunk        */                  /* get location in poly buffer where digital data      */                  /* is to be stored                                     */                  if  ((ddt.in.s#.msb(ddt#) IGT next.buf.msb))                  or  ((ddt.in.s#.msb(ddt#)  =  next.buf.msb)                  and  (ddt.in.s#.lsb(ddt#) IGE next.buf.lsb))                  then j = ddt.in.s#.lsb(ddt#) - next.buf.lsb;                    else j = ddt.in.s#.lsb(ddt#) - current.lsb;                   /* limit transfer to running into end of poly          */                  /* buffer:                                             */                  if (shl(buf.len,8) - j) ILT i                  then i = shl(buf.len,8) - j;                  /* get location of scsi input buffer where the         */                  /* data we are looking for is sitting:                 */                  k = ddt.in.s#.lsb(ddt#) - output.s#.lsb - ddt.monitor.delay;                  call psmwrite(compute.base.adr(track#)                                + buf.base + rec.base, j);                  call Start.DDT.Read(ddt#,                                       k, i, SCSI_Target_Mode);                                 m = i;                           /* transfer the audio */                  do while m <> 0;                 /* data from scsi     */                     rpc 256;                      /* memory buffer      */                     write(psd) = read(ScsiWord);  /* to poly memory     */                     m = m - 256;                  end;                  /* construct digital fade in if this if our */                  /* first section of digital audio data      */                  if ddt.in.fade.in (ddt#) <> 0                  then do;                     call fadein(compute.base.adr(track#)                                 + buf.base + rec.base + shr(j,8), 0);                     ddt.in.fade.in (ddt#) = 0;                  end;                  /* account for the data transfer: */                  ddt.in.s#.lsb(ddt#) = ddt.in.s#.lsb(ddt#) + i;                  if ddt.in.s#.lsb(ddt#) ilt i                  then ddt.in.s#.msb(ddt#) = ddt.in.s#.msb(ddt#) + 1;                  ddt.in.zeroed(ddt#) = 0;  /* indicate no longer zeroed */               end;            end;         end;         /* $page - zero out ddt input signal if not playing  */         /* else if output is not happening, fill poly input  */         /* buffer with all zeros so that we don't get clicks */         /* and pops when we next start up:                   */         else do;    /* no output happeining */            if ddt.in.zeroed(ddt#) = 0       /* if input buffer is not */            then do;                         /* all zeroes,  begin     */               ddt.in.zeroed(ddt#)   = 1;    /* process to zero        */               ddt.in.zero.ptr(ddt#) = 0;    /* it out                 */            end;            if ddt.in.zeroed(ddt#) = 1       /* if not completely      */            then do;                         /* zeroed,  do so         */               /* get length of zeroes to write this time: */               i = shl(buf.len,8) - ddt.in.zero.ptr(ddt#);               if i IGT DDT.Chunk.Size       /* limit to tasty morsel  */               then i = DDT.Chunk.Size;                  call psmwrite(compute.base.adr(track#)                             + buf.base + rec.base, ddt.in.zero.ptr(ddt#));               /* write digital zeroes to provide silence */               k = i;               do while k <> 0;                  rpc 256;                         write(psd) = 0;                  k = k - 256;               end;               /* account for data transfer: */               ddt.in.zero.ptr(ddt#) = ddt.in.zero.ptr(ddt#) + i;               if ddt.in.zero.ptr(ddt#) = shl(buf.len,8)               then ddt.in.zeroed(ddt#) = 2;            end;         end;      end;   end;end Process.DDT.In;