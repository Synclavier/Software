/* INITSOUD - Variables for real time disk input/output, issue.port.command *//* The following variables are used to keep track of the state *//* of each track and port by the real time software.           */dcl buf1.msb         (max.tracks-1)  fixed PUBLIC; /* current buffer start     */dcl buf1.lsb         (max.tracks-1)  fixed PUBLIC; /* for buf1                 */dcl buf1.len         (max.tracks-1)  fixed PUBLIC;dcl buf2.msb         (max.tracks-1)  fixed PUBLIC; /* current buffer start     */dcl buf2.lsb         (max.tracks-1)  fixed PUBLIC; /* for buf2 (lies on top    */dcl buf2.len         (max.tracks-1)  fixed PUBLIC; /* of buf1)                 */dcl buf3.msb         (max.tracks-1)  fixed PUBLIC; /* rewind data stored at    */dcl buf3.lsb         (max.tracks-1)  fixed PUBLIC; /* end of buffer (past end  */dcl buf3.len         (max.tracks-1)  fixed PUBLIC; /* of buf1)                 */dcl clob.len         (max.tracks-1)  fixed PUBLIC; /* amount of data in the front of buffer #1 that has been clobbered by reading data into buffer #2 */dcl recb.msb         (max.tracks-1)  fixed PUBLIC; /* msb,lsb (sample#) of     */dcl recb.lsb         (max.tracks-1)  fixed PUBLIC; /* record buffer start      */dcl rec.s#.msb       (max.tracks-1)  fixed PUBLIC; /* sample # last written    */dcl rec.s#.lsb       (max.tracks-1)  fixed PUBLIC;dcl max.s#.msb       (max.tracks-1)  fixed PUBLIC; /* max sample # recorded    */dcl max.s#.lsb       (max.tracks-1)  fixed PUBLIC; dcl adir.ptr         (max.tracks-1)  fixed PUBLIC; /* store current pointer for speed optimize */dcl new.adir         (max.tracks-1)  fixed PUBLIC; /* true on adir change      */dcl track.eof        (max.tracks-1)  fixed PUBLIC; /* true if played past end  */dcl longconfig       (max.tracks-1)  fixed PUBLIC; /* true if long config      */dcl this.track.shares.an.input                      (max.tracks-1)  fixed PUBLIC; /* true if changing safe/ready on this track could re-route inputs */dcl piolen           (max.tracks-1)  fixed PUBLIC; /* sectors of punch data    */dcl track.plen       (max.tracks-1)  fixed PUBLIC; /* sampled punch length     */dcl track.toss       (max.tracks-1)  fixed PUBLIC; /* toss buffer on stop      */dcl zap.buffer       (max.tracks-1)  fixed PUBLIC; /* toss buffer immediately  */dcl track.recording  (max.tracks-1)  fixed PUBLIC; /* true if recording        */dcl track.sampling   (max.tracks-1)  fixed PUBLIC; /* contains code if an      */                                            /* input source is assigned */                                            /* for this track:          */                                            /*   -1: input was assigned */                                            /*       so must erase poly */                                            /*       memory some time   */                                            /*    0: no input assigned  */                                            /*    1: STM input          */                                            /*    2: DIG input (2 trk)  */                                            /*    3: OUT or TRK input   */                                            /*    4: DIG input (multi)  */dcl track.rvoice#    (max.tracks-1)  fixed PUBLIC; /* recording voice #        */dcl track.punch      (max.tracks-1)  fixed PUBLIC; /* true if cross fade needed */dcl punch.time       (max.tracks-1)  fixed PUBLIC; /* time of punch out         */dcl valid.info       (max.tracks-1)  fixed PUBLIC; /* track has valid catalog  */dcl valid.info.ctr   (max.tracks-1)  fixed PUBLIC; /* looks for matchin error# */dcl track.error.msb  (max.tracks-1)  fixed PUBLIC; /* error counter for this   */dcl track.error.lsb  (max.tracks-1)  fixed PUBLIC; /* track read during init   */dcl track.zero.sec#  (max.tracks-1)  fixed PUBLIC; /* additional info from     */dcl track.data.sec#  (max.tracks-1)  fixed PUBLIC; /* this track               */dcl cue.write.sec#   (max.tracks-1)  fixed PUBLIC; /* for writing cue directry */dcl cue.prior.sec#   (max.tracks-1)  fixed PUBLIC; /* for writing cue directry */dcl cue.prior.ctr    (max.tracks-1)  fixed PUBLIC; /* for writing cue directry */dcl track.mode.change(max.tracks-1)  fixed PUBLIC; /* for fading in            *//* $page - issue port command *//* Issue.Port.Command is called to initiate a data transfer between   Poly Memory and a disk.   it is passed a port#.   Information   to contraol the transfer has been stored in data arrays.             */   dcl port.io.buf#  (max.ports) fixed PUBLIC; /* buf#                     */dcl port.io.len#  (max.ports) fixed PUBLIC; /* length requested         */dcl port.update   (max.ports) fixed PUBLIC; /* action to take           */dcl port.upcode   (max.ports) fixed PUBLIC; /* code for update          */dcl port.secmsb   (max.ports) fixed PUBLIC; /* holds abs sect #         */dcl port.seclsb   (max.ports) fixed PUBLIC; /* for accounting after wr  */dcl port.pmemsec  (max.ports) fixed PUBLIC; /* pmem address             */dcl port.pmemwrd  (max.ports) fixed PUBLIC;dcl port.fadein   (max.ports) fixed PUBLIC; /* construct fade in        */dcl port.fadeout  (max.ports) fixed PUBLIC; /* construct fade out       */dcl port.toggle   (max.ports) fixed PUBLIC; /* track # to check         */Issue.Port.Command: proc(port#, dir)   PUBLIC; /* issue command for read/write        */   dcl (port#)             fixed;   dcl (dir)               fixed;            /* 1 if backing up */   dcl (track#)            fixed;   dcl (dtrack#)           fixed;   dcl (drive#)            fixed;   dcl (slen#)             fixed;   dcl (pmemsec,pmemwrd)   fixed;   dcl (Sec)   (1)         fixed;   dcl (secmsb)   lit      'Sec(0)';   dcl (seclsb)   lit      'Sec(1)';   dcl (msb,lsb)           fixed;   dcl (i)                 fixed;   /* procedure to update disk/poly pointers when reading */   /* backwards and we run into a boundary condition      */   limit:proc(lim);                /* when reading backwards, must */      dcl lim fixed;               /* be smarter when we run into  */      if dir <> 0 then do;         /* backwards - do with care     */         port.seclsb     (port#) = port.seclsb (port#) + lim;         if port.seclsb  (port#) ilt lim         then port.secmsb(port#) = port.secmsb (port#) + 1;		          port.pmemsec    (port#) = port.pmemsec(port#) + lim;         slen# = slen# - lim;      end;      else slen# = lim;   end limit;   /* look up passed info: */   track#  = port.io.track# (port#);   dtrack# = port.io.dtrack#(port#);   slen#   = port.io.len#   (port#);   retry:;   secmsb=port.secmsb       (port#);   seclsb=port.seclsb       (port#);   pmemsec=port.pmemsec     (port#);   pmemwrd=port.pmemwrd     (port#);   /* check for off end of disk: */   if  ((secmsb igt track.numsec.msb(dtrack#)))   or  ((secmsb  =  track.numsec.msb(dtrack#))   and  (seclsb ige track.numsec.lsb(dtrack#)))   then do;      port.io  (port#) = 0;         /* off end of hardware    */      track.eof(track#)= 1;         /* end of track reached   */      return;                       /* done                   */   end;   /* add in track data offset      */   /* in case 2 tracks/drive        */   if  (secmsb <> 0)                /* add in track data offset if reading actual track data */   or  (seclsb ige data.sec#)   then do;      secmsb=secmsb+track.data.msb(dtrack#);      seclsb=seclsb+track.data.lsb(dtrack#);      if seclsb ilt track.data.lsb(dtrack#)      then secmsb=secmsb+1;   end;   /* compute drive #: */   drive#=0;                                    /* find drive          */   tptr=(dtrack#*total.stride)+(drive#*track.info.stride);   do while  ((secmsb igt track.emsb))          /* find which drive    */   or        ((secmsb  =  track.emsb)           /* in table contains   */   and        (seclsb ige track.elsb));      if seclsb ilt track.elsb      then secmsb=secmsb-track.emsb-1;      else secmsb=secmsb-track.emsb;      seclsb=seclsb-track.elsb;      drive#=drive#+1;      tptr=(dtrack#*total.stride)+(drive#*track.info.stride);   end;      lsb=track.elsb-seclsb;         /* get sector distance */   msb=track.emsb-secmsb;         /* to end of this disk */   if track.elsb ilt seclsb   then msb=msb-1;   if (msb=0)&(lsb ilt slen#)     /* limit disk read to  */   then do;                       /* end of this disk    */      call limit(lsb);      if dir<>0 then goto retry;   end;            if slen# igt 128               /* limit to reasonable chunk size      */   then do;                       /* (limit here to zero length as well) */      if dir = 0                  /* forward - just limit length         */      then call limit(128);       else do;         call limit(slen# - 128);         goto retry;      end;   end;   port.io.len#  (port#) = slen#; /* save modified len   */	port.tptr     (port#) = tptr;	 /* save tptr too			*/   /* $page - issue command to disk to start operation: */   if port.io(port#) = 2 then do; /* read desired        */      i = Start.Disk.Read(secmsb,  seclsb ,                          slen# ,  pmemsec, pmemwrd);   end;   else if (port.io(port#) = 3) then do;      i = Start.Disk.Write(secmsb,  seclsb ,                           slen# ,  pmemsec, pmemwrd);   end;   else if (port.io(port#) = 4)        or (port.io(port#) = 5) then do;      i = Start.Request.Sense;                                  end;   else do;      i=-99;      track.status(track#)=i;   end;   if i<>0 then do;                 /* error occurred          */      port.retry(port#)=port.retry(port#)+1;      if port.retry(port#)>3        /* retry up to 3 times    */      then do;         track.eof(track#)= 1;      /* end of track reached   */      end;      if port.io(port#)<>1          /* clear port.io          */      then port.io  (port#) = 0;    /* unless reset was done  */         return;                         end;   else do;      port.timer(port#)=real.seconds+45;   end;end Issue.Port.Command;/* $Page - other routines for managing track io: */zap.read.track.info.tracks: proc PUBLIC swapable;   dcl i fixed;   dcl j fixed;   do i=0 to max.tracks-1;      if (((read.track.info&bits(i))<>0))      or (((clean.up.all.of.poly   )<>0)      and ((track.available     (i))<>0))      then do;         zap.buffer(i)=1;         adir.ptr  (i)=i*adir.len;          track.eof (i)=0;         status.tracks = status.tracks \ bits(i);      end;   end;   read.track.info      = 0;   track.info.direction = 0;   track.info.busy      = 0;   /* clean up necessary sections of poly memory after doing audition */   if clean.up.all.of.poly <> 0 then do;         /* must clean up all of */      do i=0 to max.tracks-1;                    /* poly.  Begin by      */         if track.available(i) <> 0 then do;     /* looking at each      */            track.sampling (i) = -1;             /* track.  mark         */            call psmwrite(track.base.adr(i),0);  /* track.sampling so    */            do j = 0 to buf.base-1;              /* new input routine    */               rpc 256;                          /* zeroes out record    */               write(psd) = 0;                   /* buffer.   Zero out   */            end;                                 /* up to buf.base here  */            call psmwrite(track.base.adr(i)+rec.base,0);            do j = 0 to buf.base-1;              /* also up in record    */               rpc 256;                          /* buffer area          */               write(psd) = 0;                 end;                            end;      end;      clean.up.all.of.poly = 0;   end;   if currently.auditioning <> 0                 /* also turn off audition */   then call Terminate.Audition(Base.Voice#, 1); /* if func timeout        */end zap.read.track.info.tracks;/* the LOD software often needs to know if any recording is going on *//* of if the allocation directory is being modified.   these two     *//* routines accomplish these functions                               */any.track.actually.recording: proc PUBLIC;   dcl (i) fixed;   do i=0 to max.tracks-1;            /* or recording punch out   */      if  ((track.available(i)<>0))   /* left to do               */      and ((track.recording(i)<>0))      then return 1;   end;   return 0;end any.track.actually.recording;any.track.recording.or.new.adir:proc PUBLIC;   dcl (i) fixed;   do i=0 to max.tracks-1;            /* or recording punch out   */      if  ((track.available(i)<>0))   /* left to do               */      and ((track.recording(i)<>0)      or   (new.adir       (i)<>0))   /* or adir still not up-to date */      then return 1;   end;   return 0;end any.track.recording.or.new.adir;