/* Routine for doing TSM and Optical <-> DTD with SRC *//* 09/21/89 - sjs - added support for THREE algorithm              *//* 09/07/89 - sjs - fixed stereo cue bug (not doing right channel) *//* 06/16/89 - sjs - fixed percent done bug                         *//* 05/03/89 - sjs - decoupled do.dsp from the DSP70                *//* 03/17/89 - sjs - added support for Opt <-> DTD                  */do.dsp: proc PUBLIC;   dcl DSP70.Event           fixed;   dcl ext.cmd               fixed;   dcl (i,j)                 fixed;   dcl track#                fixed;/* left/mono track number  */   dcl right.track#          fixed;/* right track number (valid only if sys.stereo is set) */   dcl t#                    fixed;   dcl ctr                   fixed;   dcl s#   (1)              fixed;   dcl b    (1)              fixed;   dcl c    (1)              fixed;   dcl left.limit(1)         fixed;   dcl right.limit(1)        fixed;   dcl dsp.read.len          fixed;   /* these variables are added to improve   */   /* the "readability" of the code          */   dcl left.buf.ready        fixed;   dcl right.buf.ready       fixed;   dcl left.track.not.busy   fixed;   dcl right.track.not.busy  fixed;   dcl left.busy.writing     fixed;   dcl right.busy.writing    fixed;   dcl left.found            fixed;/* indicated left/mono track is found on the disk (not zeros) */   dcl right.found           fixed;/* same for right.track */   dcl use.DSP70             fixed;/* true if we should use DSP70 */   /* subroutine to fabricate 256 samples of audio data (all zeroes) */   /* to write to unit if DSP unit needs some audio after the end    */   /* of file,  or numerous other cases.                             */   Write.256.Zeroes: proc(stereo);      dcl stereo    fixed;      call dsp.write(icr,dsp#write.ack.set); /* get in sync with DSP70 */      write(DSPCtl) = DSP16SE|DSPWrite;      /* set transfer mode */      rpc 256;      write(DSPData) = 0;                    /* write data */      call dsp.write(icr,dsp#write.ack.clr); /* clear flags init port */      if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)      then call ADD16(2, Dsp.In.Here);            /* account for sector    */      else call ADD16(1, Dsp.In.Here);            /* account for sector    */      if stereo then do;         call dsp.write(icr,dsp#write.ack.set); /* get in sync with DSP70 */         write(DSPCtl) = DSP16SE|DSPWrite;      /* set transfer mode */         rpc 256;         write(DSPData) = 0;                    /* write data */         call dsp.write(icr,dsp#write.ack.clr); /* clear flags init port */      end;   end Write.256.Zeroes;   Write.256.Zeroes.RAM: proc (stereo);      dcl stereo    fixed;      write(mam) = dsp.write.event.ptr;      rpc 256;      write(mdi) = 0;                    /* write data */      dsp.write.event.ptr = dsp.write.event.ptr + 1;      if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)      then call ADD16(2, Dsp.In.Here);            /* account for sector    */      else call ADD16(1, Dsp.In.Here);            /* account for sector    */      if stereo then do;         rpc 256;         write(mdi) = 0;                    /* write data */         dsp.write.event.ptr = dsp.write.event.ptr + 1;      end;   end Write.256.Zeroes.RAM;   Toss.256.Samples: proc(stereo);      dcl stereo   fixed;      if dspdebug <> 0 then do;         disable;         print 'Throwing out 256 samples';         enable;      end;      call dsp.write(icr,dsp#read.ack.set);  /* get in sync with the DSP70 */      write(DSPCtl) = DSP16SE|DSPRead;      rpc 256;      write("324") = read(DSPData);          /* chuck it */      call dsp.write(icr,dsp#read.ack.clr);      if (sys.stereo) and (syn.scsi.data.xfer = sys#DTDOpt)      then call ADD16(2, Dsp.Out.Here);            /* account for sector    */      else call ADD16(1, Dsp.Out.Here);            /* account for sector    */   end Toss.256.Samples;   Toss.256.Samples.RAM: proc(stereo);      dcl stereo   fixed;      if dspdebug <> 0 then do;         disable;         print 'Throwing out 256 samples';         enable;      end;      write(mam) = dsp.read.event.ptr;      rpc 256;      write("324") = read(mdi);          /* chuck it */      dsp.read.event.ptr= dsp.read.event.ptr + 1;      if stereo then do;         rpc 256;         write("324") = read(mdi);          /* chuck it */         dsp.read.event.ptr= dsp.read.event.ptr + 1;      end;      if (sys.stereo) and (syn.scsi.data.xfer = sys#DTDOpt)      then call ADD16(2, Dsp.Out.Here);            /* account for sector    */      else call ADD16(1, Dsp.Out.Here);            /* account for sector    */   end Toss.256.Samples.RAM;   /* Begin by seeing what state the DSP70 board is in.  It directs the  */   /* whole TSM operation.                                               */   if dsp.state = dsp#off then return;  /* oops ....                     */   if new.inputs <> 0 then return;      /* make sure record buffer is    */                                        /* available for us now.         */   call Select.DSP70;                   /* select dsp board              */   if  (dsp.function  = dsp#SynSCSI)    /* if we are doing Opt <-> DTD   */   and (dsp.algorithm = dsp#nosrc)      /* and not doing SRC             */   then use.DSP70 = 0;                  /* don't use DSP70               */   else use.DSP70 = 1;                  /* otherwise use it              */   /* See if we are done with prior track.  If so, wait for disk write   */   /* to finish, then move on to next track, or quit.                    */   if Dsp.Next.Track <> 0 then do;      track# = Dsp.Out.Track;    /* get track# to write to handy */      if sys.stereo      then right.track# = Dsp.Out.Track.r;/* right track too, if stereo */      if dspdebug <> 0 then do;         disable;         print 'Processing Next Track', (track.info.busy & bits(track#)), Read.Track.Len(track#), DSP.Buf.Len, track.eof(track#);         enable;      end;      /* Wait until the current disk read/write operation is done.  */      /* Start another one if there is any more data in the buffer. */      /* Move on to next track (or quit) when these conditions      */      /* are met.                                                   */      /* return if the tracks needed are busy */      if ((track.info.busy &bits(track#) <> 0) and not(sys.stereo))      or (track.info.busy &bits(track# or right.track#) <> 0)      then return;      /* If entire contents of buffer has been written to disk,  then */      /* empty out the buffer so we can start at the beginning of it  */      /* again.                                                       */      if  (Read.Track.Len(track#) = DSP.Buf.Len) /* if buffer is empty      */      and (DSP.State <> DSP#Abort)               /* and we are not aborting */      then do;         if (sys.stereo) and (syn.scsi.data.xfer = sys#dtdopt)         then j = 2*DSP.Buf.Len;         else j = DSP.Buf.Len;         b(1) = DSP.Buf.Lsb + j;         if b(1) ilt j         then b(0) = DSP.Buf.Msb + 1;         else b(0) = DSP.Buf.Msb;         if dsp.opt.data.stacked <> 0         then call Flush.Opt.Data(b(0), b(1));    /* write out final stacked data sector */         dsp.opt.data.stacked = 0; /* assume doesn't fail */         DSP.Buf.Len  = 0;         Read.Track.Len(track#) = 0;         if sys.stereo then do;            Read.Track.Len(right.track#) = 0;         end;      end;      if track.eof(track#) <> 0 then DSP.Buf.Len = 0;      if (sys.stereo) and (track.eof(right.track#)  <> 0)      then DSP.Buf.Len = 0;      /* Start another disk write if there is any data in the buffer: */      if  (DSP.Buf.Len <> 0)      and (DSP.State <> DSP#Abort)      then do;         if dspdebug <> 0 then do;            disable;            print 'Starting Final Write ',track#, DSP.Buf.Len;            enable;         end;         read.track.info             = read.track.info      \ bits(track#);         track.info.direction        = track.info.direction \ bits(track#);         track.info.busy             = track.info.busy      \ bits(track#);         read.track.msb(track#)      = DSP.Buf.Msb;   /* sector # to     */         read.track.lsb(track#)      = DSP.Buf.Lsb;   /* write too       */         read.track.len(track#)      = DSP.Buf.Len;   /* # of sectors    */         read.track.buf.base(track#) = shr(buf.len,1);         read.track.written (track#) = 0;         /* indicate none written  */         read.track.chunk   (track#) = shr(buf.len,1);         track.eof(track#)           = 0;         /* turn on record light */         if syn.scsi.data.xfer <> sys#DTDOpt                         then status.tracks = status.tracks \ bits(track#);          if sys.stereo then do;            read.track.info             = read.track.info      \ bits(right.track#);            track.info.direction        = track.info.direction \ bits(right.track#);            track.info.busy             = track.info.busy      \ bits(right.track#);            read.track.msb(right.track#)      = DSP.Buf.Msb;   /* sector # to     */            read.track.lsb(right.track#)      = DSP.Buf.Lsb;   /* write too       */            read.track.len(right.track#)      = DSP.Buf.Len;   /* # of sectors    */            read.track.buf.base(right.track#) = shr(buf.len,1);            read.track.written (right.track#) = 0;         /* indicate none written  */            read.track.chunk   (right.track#) = shr(buf.len,1);            track.eof(right.track#)           = 0;            if syn.scsi.data.xfer <> sys#DTDOpt                            then status.tracks = status.tracks \ bits(right.track#);         end;         return;      end;      /* done with this track */      if sys.stereo      then dsp.trk.ptr = dsp.trk.ptr + 2;      else dsp.trk.ptr = dsp.trk.ptr + 1;         /* move on to next trk */      if (dsp.trk.ptr >= dsp.#tracks)               /* see if done         */      or (DSP.State  =  dsp#abort)      then do;         /* turn off or reset all state variables related to DSP */         get.new.motion = get.new.motion \ 4;/* Send end cmd to Synclav */         if dspdebug <> 0         then print 'turning DSP off - really!';         if syn.scsi.data.xfer <> sys#off then do;            /* correct for 4000 sector offset */            b(0) = 0;            b(1) = 4000;            c(0) = dsp.buf.msb;            c(1) = dsp.buf.lsb;            if syn.scsi.data.xfer = sys#OptDTD            then call Sub32(c,b,b);            misc.buf(0) = dsp.out.track;            misc.buf(1) = dsp.percent.done;            misc.buf(2) = 1;/* signal stopped */            misc.buf(3) = (dsp.state = dsp#abort);/* abort flag */            misc.buf(4) = dsp.scsi.error;/* signal stopped */            misc.buf(5) = b(0);            misc.buf(6) = b(1);            if dspdebug <> 0 then do;               print 'dsp.out.track = ', misc.buf(0);               print '% done        = ', misc.buf(1);                print 'stopped       = ', misc.buf(2);               print 'Abort         = ', misc.buf(3);               print 'scsi error    = ', misc.buf(4);               print 'msb           = ', misc.buf(5);               print 'lsb           = ', misc.buf(6);            end;            call reselect.synclavier(7,misc.buf);            dsp.opt.data.stacked = 0;            dsp.scsi.error       = 0;            syn.scsi.data.xfer = sys#off;/* turn off any synclavier scsi action */         end;         do i = 0 to max.tracks-1;           /* set bit to erase input buffer */            if track.available (i) <> 0      /* when next assigning inputs.   */            then track.sampling(i) = (-1);         end;         dsp.state          = dsp#off;/* No more; we're done.                 */         sys.stereo         = 0;      /* reset to default state              */         return;      end;      /****** move on to next track ******/      if dspdebug <> 0      then print 'starting next track';      call COPY32(dsp.start,dsp.in.here);      call COPY32(dsp.out.s,dsp.out.here);      dsp.out.track = dsp.out.tracks(dsp.trk.ptr);      DSP.Buf.Len    = 0;      Dsp.Edit.Len  = 0;      do i = 0 to max.tracks-1;         track.eof          (i) = 0; /* time through                  */         read.track.len     (i) = 0; /* mark output buffer as         */         read.track.written (i) = 0; /* being empty                   */         track.eof          (i) = 0;      end;      Dsp.Next.Track = 0;   end;   if (DSP70.there) and (use.DSP70)   then DSP70.Event = DSP.Read(isr);              /* find out what it needs */   else DSP70.Event = Get.Next.Stacked.DSP.Event; /* simulate DSP70 event   */   read.track.time = real.milliseconds;   /* set timeout timer */   timeout.point   = real.milliseconds+10000;   if dspdebug <> 0 then do;      disable;      print 'Event: ',DSP70.event,'  ',octal(DSP70.event);      enable;   end;   /* If the dsp unit has audio for us, read it into memory for  */   /* the correct track.                                         */   if (DSP70.Event & dsp#event.mask) = dsp#read.audio   then do;      track# = Dsp.Out.Track;    /* get track# to write to handy */      if sys.stereo      then right.track# = Dsp.Out.Track.r;/* right track too, if stereo */      Next.Read:;                /* re-enter quickly for next    */      if dspdebug <> 0 then do;         if (COM32(Dsp.Out.Here, dsp.new.end) >= LW#IEQ)         or (COM32(Dsp.Out.Here, Dsp.Out.E  ) >= LW#IEQ)         then do;            disable;            print 'Tossing Samples (eof)',track#;            enable;         end;      end;      left.busy.writing =  ((read.track.info & bits(track#)) <> 0)  /* if doing   */                           and ((track.info.direction & bits(track#)) <> 0)  /* a write    */                           and ((track.info.busy      & bits(track#)) <> 0);  /* still bsy  */            right.busy.writing = ((read.track.info & bits(right.track#)) <> 0)  /* if doing   */                           and ((track.info.direction & bits(right.track#)) <> 0)  /* a write    */                           and ((track.info.busy      & bits(right.track#)) <> 0);  /* still bsy  */            if COM32(Dsp.Out.Here, dsp.new.end) >= LW#IEQ   /* toss data if it is */      then call Toss.256.Samples(sys.stereo);         /* past eof           */      else if COM32(Dsp.Out.Here, Dsp.Out.E) >= LW#IEQ   /* toss data if it is */      then call Toss.256.Samples(sys.stereo);            /* past end of proj   */      /* If we are currently writing data to this track, just append  */      /* one sector of information to the output buffer (if it will   */      /* fit).  That way the disk write chunk sizes will grow to      */      /* match the data rate of the algorithm.  Note: if optical disk */      /* write is happening, the tracks should not be busy here       */      else if (left.busy.writing and not(sys.stereo)   )      or      (left.busy.writing and right.busy.writing)      then do;         if  (syn.scsi.data.xfer = sys#dtdopt   )          and (dsp.first.write.to.opt = 1        )         and (DSP.Buf.Len = (shr(buf.len,1)-1)  )         then do; /* at the end of the special first buffer */            if dspdebug <> 0 then do;               disable;               print 'No room in first buffer';               enable;            end;         end;         else if DSP.Buf.Len < shr(buf.len,1) then do;/* if there is room in the buffer */                        i = (compute.base.adr(track#) + buf.base + shr(buf.len,1)              +  DSP.Buf.Len);            if sys.stereo then do;/* compute right track poly address too */               j = (compute.base.adr(right.track#) + buf.base + shr(buf.len,1)                 +  DSP.Buf.Len);            end;            else j = -1;            if dspdebug <> 0 then do;               disable;               if sys.stereo then do;                  disable;                  print 'Reading Audio ',track#,right.track#, DSP.Buf.Len;                  enable;               end;               else do;                  if i <> -1 then do;                     disable;                     print 'Reading Audio ',track#, DSP.Buf.Len;                     enable;                  end;                  else print 'Reading Zeros ',track#, DSP.Buf.Len;               end;                 enable;            end;            if (DSP70.there) and (use.DSP70)            then call Read.Audio.From.DSP70 (i,j,sys.stereo);            else call Read.Audio.From.RAM   (i,j,sys.stereo);            if (sys.stereo) and (syn.scsi.data.xfer = sys#DTDOpt)            then call ADD16(2, Dsp.Out.Here);    /* account for data xfer */            else call ADD16(1, Dsp.Out.Here);    /* account for data xfer */            dsp.time = real.milliseconds;            DSP.Buf.Len = DSP.Buf.Len + 1;            read.track.len(track#)       = read.track.len(track#) + 1;            if sys.stereo then do;               read.track.len(right.track#) = read.track.len(right.track#) + 1;            end;            /* compute percentage every 128 sectors */            if (Dsp.Out.Here(1) & 127) = 0            then do;            /* compute percentage done */               call SUB32(Dsp.Out.Here, Dsp.Out.s, B);               dsp.percent.done = Interpolate.Envelope.Segment(0,100,b,dsp.new.len);            end;            /* Quickly check for another sector */            if (DSP70.there) and (use.DSP70)            then DSP70.Event = DSP.Read(isr);         /* find out what it needs        */            else DSP70.Event = Get.Next.Stacked.DSP.Event;            if (DSP70.Event & dsp#event.mask) = dsp#read.audio            then goto Next.Read;         end;         /* else must wait for disk write to finish,  then we can start */         /* storing info away at the start of the buffer                */         else do;            if dspdebug <> 0 then do;               disable;               print 'Tracks are busy, but no room in the buffer',track#, DSP.Buf.Len;               print '   Left  ', (read.track.info & bits(track#));   /* if doing   */               print '         ', (track.info.direction & bits(track#));  /* a write    */               print '         ', (track.info.busy      & bits(track#));  /* still bsy  */               print '   Right ', (read.track.info & bits(right.track#));   /* if doing   */               print '         ', (track.info.direction & bits(right.track#));  /* a write    */               print '         ', (track.info.busy      & bits(right.track#));  /* still bsy  */               enable;            end;         end;      end;      /* Else if not busy reading or writing to the disk,  see if we    */      /* can put more data in the buffer.   Start a disk write if       */      /* we are not busy reading.                                       */      else do;         /* If entire contents of buffer has been written to disk,  then */         /* empty out the buffer so we can start at the beginning of it  */         /* again.                                                       */         if Read.Track.Len(track#) = DSP.Buf.Len         then do;            DSP.Buf.Len  = 0;            Read.Track.Len(track#) = 0;            /* assume that if left track is full, that the right */            /* will be too if sys.stereo is set                  */            if sys.stereo then do;                             Read.Track.Len(right.track#) = 0;            end;            if dspdebug <> 0 then do;               disable;               print 'Tossing Buffer';               enable;            end;         end;         /* Read audio into the buffer if there is room */         if  (syn.scsi.data.xfer = sys#dtdopt   )          and (dsp.first.write.to.opt = 1        )         and (DSP.Buf.Len = (shr(buf.len,1)-1)  )         then do;            if dspdebug <> 0 then do;               disable;               print 'No room in first buffer';               enable;            end;         end;         else if DSP.Buf.Len < shr(buf.len,1) then do;            if dspdebug <> 0 then do;               disable;               print 'Reading Audio #1 from dsp70',track#, DSP.Buf.Len;               enable;            end;            if  DSP.Buf.Len = 0                /* when putting first sector */            then do;                           /* in buffer,  save where    */               DSP.Buf.Msb = Dsp.Out.Here(0);  /* it goes on disk           */               DSP.Buf.Lsb = Dsp.Out.Here(1);            end;            i = (compute.base.adr(track#) + buf.base + shr(buf.len,1)              +  DSP.Buf.Len);            if sys.stereo then do;/* compute right track poly address too */               j = (compute.base.adr(right.track#) + buf.base + shr(buf.len,1)                 +  DSP.Buf.Len);            end;            else j = -1;            if (DSP70.there) and (use.DSP70)            then call Read.Audio.From.DSP70 ( i,j,sys.stereo);            else call Read.Audio.From.RAM   ( i,j,sys.stereo);            if (sys.stereo) and (syn.scsi.data.xfer = sys#DTDOpt)            then call ADD16(2, Dsp.Out.Here);    /* account for data xfer */            else call ADD16(1, Dsp.Out.Here);    /* account for data xfer */            dsp.time = real.milliseconds;            DSP.Buf.Len = DSP.Buf.Len + 1;            /* compute percentage every 128 sectors */            if (Dsp.Out.Here(1) & 127) = 0            then do;            /* compute percentage done */               call SUB32(Dsp.Out.Here, Dsp.Out.s, B);               dsp.percent.done = Interpolate.Envelope.Segment(0,100,b,dsp.new.len);            end;            /* Quickly check for another sector */            if (DSP70.there) and (use.DSP70)            then DSP70.Event = DSP.Read(isr);         /* find out what it needs        */            else DSP70.Event = Get.Next.Stacked.DSP.Event;            if (DSP70.Event & dsp#event.mask) = dsp#read.audio            then do;               if dspdebug <> 0 then do;                  disable;                  print 'Jumping to next read';                  enable;               end;               goto Next.Read;            end;         end;         else do;/* if buffer is full */            if dspdebug <> 0 then do;               disable;               print 'Buffer Full ',track#;               enable;            end;         end;         /* Start a disk write if there is any data in the buffer: */         left.track.not.busy  = ((track.info.busy&bits(track#))      = 0);         right.track.not.busy = ((track.info.busy&bits(right.track#))= 0);         if (left.track.not.busy and not(sys.stereo))         or (left.track.not.busy and right.track.not.busy)         then do;            /* Note: Dsp.Buf.Len must be a multiple of 2 sectors when       */            /* starting a write to the opt, since the sector length there   */            /* is 512.  Since buf.len must be a multiple of 16 secs         */            /* for tape commands, it should be safe to wait until           */            /* dsp.buf.len = buf.len/2 (size of write buffer when doing     */            /* DSP) to initiate a write.                                    */            if  (syn.scsi.data.xfer = sys#dtdopt   )             and (dsp.first.write.to.opt = 1        )            and (DSP.Buf.Len <> (shr(buf.len,1)-1) ) /* assume buf.len is mulitple of 4 */            then do;               /* Note: This special case is necessary because the very   */               /* first write to the optical disk occurs at an odd 256    */               /* word sector.  Since readwrite (initsoua) pads all odd   */               /* sector writes with 256 zeros at the start of the write, */               /* the number of "real" sectors to write must be odd, so   */               /* that 1 sector of zeros + odd "real" sectors = even total*/               /* sectors actually written to disk.                       */               /* SORRY FOR THE KLUDGE!                                   */               if dspdebug <> 0 then do;                  disable;                  print 'Waiting for write buffer to fill for first write';                  enable;               end;            end;            else if  (syn.scsi.data.xfer = sys#dtdopt)             and      (dsp.first.write.to.opt = 0     )            and      (DSP.Buf.Len <> shr(buf.len,1)  )            then do;               if dspdebug <> 0 then do;                  disable;                  print 'Waiting for write buffer to fill ';                  enable;               end;            end;            else do;               if dspdebug <> 0 then do;                  disable;                  print 'Starting Write ',track#, DSP.Buf.Len;                  enable;               end;               read.track.info             = read.track.info      \ bits(track#);               track.info.direction        = track.info.direction \ bits(track#);               track.info.busy             = track.info.busy      \ bits(track#);               read.track.msb(track#)      = DSP.Buf.Msb;   /* sector # to     */               read.track.lsb(track#)      = DSP.Buf.Lsb;   /* write too       */               read.track.len(track#)      = DSP.Buf.Len;   /* # of sectors    */               read.track.buf.base(track#) = shr(buf.len,1);               read.track.written (track#) = 0;         /* indicate none written  */               read.track.chunk   (track#) = shr(buf.len,1);               track.eof(track#)           = 0;               /* Turn on record light only if not writing to optical */               if syn.scsi.data.xfer <> sys#DTDOpt                               then status.tracks = status.tracks \ bits(track#);                if sys.stereo then do;                  read.track.info             = read.track.info      \ bits(right.track#);                  track.info.direction        = track.info.direction \ bits(right.track#);                  track.info.busy             = track.info.busy      \ bits(right.track#);                  read.track.msb(right.track#)      = DSP.Buf.Msb;   /* sector # to     */                  read.track.lsb(right.track#)      = DSP.Buf.Lsb;   /* write too       */                  read.track.len(right.track#)      = DSP.Buf.Len;   /* # of sectors    */                  read.track.buf.base(right.track#) = shr(buf.len,1);                  read.track.written (right.track#) = 0;         /* indicate none written  */                  read.track.chunk   (right.track#) = shr(buf.len,1);                  track.eof(right.track#)           = 0;                  if syn.scsi.data.xfer <> sys#DTDOpt                                  then status.tracks = status.tracks \ bits(right.track#);                end;               dsp.first.write.to.opt = 0;/* we have now started the first write */            end;/* of else do */         end;         else if dspdebug <> 0 then do;            disable;            if sys.stereo            then print 'Disk is busy ', track#,' or ',right.track#, DSP.Buf.Len;            else print 'Disk is busy', track#, DSP.Buf.Len;            enable;         end;      end;   end;   /* Feed audio data to the DSP70 */   else if (DSP70.Event & dsp#event.mask) = dsp#write.audio   then do;      /* The dsp70 needs another 256 words.                              */      /* Begin by seeing if we are off the end of the track, etc:        */      if COM32(Dsp.In.Here, Dsp.End) >= LW#IEQ  /* feed digital silence  */      then do;         if dspdebug <> 0 then do;            disable;            print 'Sending Zeroes (eof)';            enable;         end;         if (use.DSP70 <> 0)         then call Write.256.Zeroes(sys.stereo);     /* if past end of cue    */         else call Write.256.Zeroes.RAM(sys.stereo);      end;      /* Now find out which actual track (if reading from disk) contains */      /* the audio needed.  This may change during the cue as            */      /* different tracks are spliced in & out of the cue.               */      else do;         track# = 0;         call COPY32(Dsp.In.Here, S#);     /* get sample # that corresponds */         call SHL32 (S#, 8);               /* to the needed sector          */         if (syn.scsi.data.xfer = SyS#OptDTD) then do;/* if reading from synclavier SCSI bus */            /* we are assuming that if OptDTD is happening, then there */            /* will only be one or two tracks to process.  Also, out   */            /* tracks are the same as in tracks.                       */            track# = dsp.out.tracks(0);/* for left/mono channel of audio */            left.found = 1;            call Copy32(dsp.end, left.limit);            if sys.stereo then do;               right.track# = dsp.out.tracks(1);               right.found  = 1;               call Copy32(dsp.end, right.limit);            end;         end;         else do;/* find audio on disk */            if (syn.scsi.data.xfer = sys#DTDOpt)            or (sys.stereo <> 0                ) /* or if doing tsm w/ sys.stereo */            then do;               t# = Find.Track(dsp#left,S#, loc(addr(left.limit(0))));               if t# <> -1 then do;                  track#      = t#;                  left.found  = 1;               end;               else do;                  disable;                  print 'Find.Track returns -1';                  enable;                  left.found = 0;               end;               if sys.stereo then do;                  t# = Find.Track(dsp#right, s#, loc(addr(right.limit(0))));                  if t# <> -1 then do;                     right.track# = t#;                     right.found  = 1;                  end;                  else right.found = 0;/* no track audio on disk for this segment */               end;            end;            else do;/* TSM happening (this is redundant if only one or two tracks can be selected) */               t# = Find.Track(dsp.trk.ptr, S#, loc(addr(left.limit(0))));               if t# <> -1 then do;                  track# = t#;                  left.found = 1;                  if dspdebug <> 0 then do;                     disable;                     print 'Found audio on track ', track#,' at sample number ',S#(0), S#(1);                     enable;                  end;               end;               else do;                  left.found = 0;                  if dspdebug <> 0 then do;                     disable;                     print 'DID NOT FIND AUDIO at sample number ',S#(0), S#(1);                     enable;                  end;               end;            end;         end;         /* if track with correct audio was found,  see if any data is in */         /* its buffer.  Send audio or zeros to DSP-70.                   */         Next.Write:;         if left.found <> 0 then do;            b(0) = buf1.msb(track#);       /* get sample # we are buffered at  */            b(1) = buf1.lsb(track#);            call COPY32(B,C);                      /* get sample # up to which we have buffered */            /* if we are reading a stereo file from a device that */            /* interleaves the samples (i.e. optical), we need to */            /* multiply the buffer length by two to get the       */            /* correct disk address.                              */            if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)            then call ADD16(shl(buf1.len(track#),9),C);            else call ADD16(shl(buf1.len(track#),8),C);            left.buf.ready =  (clob.len(track#) = 0)     /* if nothing in buf2 has glommed buf1       */            and (COM32(S#, B) >= lw#ieq)   /* and desired sectors is after buffer start */            and (COM32(S#, C) <  lw#ieq)   /* and desired end is before end of buffer   */            and ((read.track.info&bits(track#))<>0);   /* force read first time through so data is at start of buffer */            left.track.not.busy = ((track.info.busy&bits(track#)) = 0);         end;         else do;            /* if left.found = 0 then we want to write zeros to the */            /* dsp70, so we don't care what is in memory, and the   */            /* as far as we are concerned, the left buffer is ready */            left.buf.ready = 1;            if dspdebug <> 0 then do;               disable;               print 'Could not find left track';               enable;            end;         end;         if (sys.stereo and (right.found <> 0)) then do;            /* see if right track is ready */            b(0) = buf1.msb(right.track#);/* get sample # we are buffered at  */            b(1) = buf1.lsb(right.track#);            call COPY32(B,C);                      /* get sample # up to which we have buffered */            /* if we are reading a stereo file from a device that */            /* interleaves the samples (i.e. optical), we need to */            /* multiply the buffer length by two to get the       */            /* correct disk address.                              */            if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)            then call ADD16(shl(buf1.len(right.track#),9),C);            else call ADD16(shl(buf1.len(right.track#),8),C);            right.buf.ready =  (clob.len(right.track#) = 0)     /* if nothing in buf2 has glommed buf1       */            and (COM32(S#, B) >= lw#ieq)   /* and desired sectors is after buffer start */            and (COM32(S#, C) <  lw#ieq)   /* and desired end is before end of buffer   */            and ((read.track.info&bits(right.track#))<>0);   /* force read first time through so data is at start of buffer */            right.track.not.busy = ((track.info.busy&bits(right.track#)) = 0);         end;         else if not(sys.stereo) then do;/* mono case */            right.buf.ready = 0;         end;         else do;/* right.found = 0, and sys.stereo */            /* if right.found = 0 then we want to write zeros to the    */            /* dsp70, so we don't care what is in memory, and the   */            /* as far as we are concerned, the right buffer is ready */            right.buf.ready = 1;         end;         /* if data is sitting in buffer, send it to the dsp70  */         /* otherwise, start a process going to get the data    */         /* into the buffer                                     */         if (left.buf.ready and not(sys.stereo))/* if left ready and mono */         or (left.buf.ready and right.buf.ready)/* or both ready          */         then do;                               /* data is in poly and set to go */            b(0) = buf1.msb(track#); b(1) = buf1.lsb(track#);            call Sub32(s#,b,b);            /* compute poly pointer to left track */            if left.found <> 0 then do;               if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)               then i = compute.base.adr(track#) + buf.base + shr(b(1), 9);               else i = compute.base.adr(track#) + buf.base + shr(b(1), 8);            end;            else i = -1;/* this will cause zeros to be written instead of data */            if sys.stereo and right.found <> 0 then do;/* compute poly pointer to right track */               b(0) = buf1.msb(right.track#); b(1) = buf1.lsb(right.track#);               call Sub32(s#,b,b);               if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)               then j = compute.base.adr(right.track#) + buf.base + shr(b(1), 9);               else j = compute.base.adr(right.track#) + buf.base + shr(b(1), 8);            end;            else j = -1;            if dspdebug <> 0 then do;               disable;               if sys.stereo then do;                  print 'Sending Audio ',track#,right.track#, DSP.Buf.Len;               end;               else do;                  if i <> -1 then do;                     print 'Sending Audio ',track#, DSP.Buf.Len;                  end;                  else print 'Sending Zeros ',track#, DSP.Buf.Len;               end;                 enable;            end;            if (DSP70.there) and (use.DSP70)            then call Send.Audio.To.DSP70 (i,j,sys.stereo);            else call Send.Audio.To.RAM   (i,j,sys.stereo);            if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)            then call ADD16(2, Dsp.In.Here);    /* account for data xfer */            else call ADD16(1, Dsp.In.Here);    /* account for data xfer */            /* Quickly check for another sector */            if (DSP70.there) and (use.DSP70)            then DSP70.Event = DSP.Read(isr);         /* find out what it needs        */            else DSP70.Event = Get.Next.Stacked.DSP.Event;            /* See if we are past the end of the current segment */            i = (COM32(Dsp.In.Here, left.limit) = lw#ilt) and not(sys.stereo);            j = (COM32(DSP.In.Here, left.limit) = lw#ilt) and (COM32(DSP.In.Here, right.limit) = lw#ilt);            if  ((DSP70.Event & dsp#event.mask) = dsp#write.audio)            and ( i or j )            and (COM32(Dsp.In.Here, Dsp.End) = lw#ilt)            then do;               if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)               then call ADD16(512, S#);     /* get next sample # */               else call ADD16(256, S#);     /* get next sample # */               if dspdebug <> 0 then do;                  disable;                  print 'Jumping to Next.Write';                  enable;               end;               goto Next.Write;            end;         end;         else if (track.eof(track#) <> 0)   /* past eof or drive has failed */         or      (sys.stereo and (track.eof(right.track#) <> 0))         then do;            if dspdebug then do;               disable;               print 'Error: past eof or drive has failed.';               enable;            end;            if (use.DSP70 <> 0)            then call Write.256.Zeroes(sys.stereo);     /* if past end of cue    */            else call Write.256.Zeroes.RAM(sys.stereo);         end;         /* issue disk read command to read data from disk provided */         /* that we are not busy writing data to this same track:   */         else if ((left.track.not.busy and not(sys.stereo))         or      (left.track.not.busy and right.track.not.busy))         then do;            call Copy32(dsp.end,C);            call SHL32(C,8);            call SUB32(C,s#,B);/* get ammount left to read */            if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)            then call SHR32(B,1);/* Correct for interleaved stereo file */            call copy32(B,C);            call SHR32(C,8); /* get sector number for comparison */            if (C(0) = 0) and (C(1) ilt shr(buf.len,1))            then dsp.read.len = C(1);/* read only remainder of file */            else dsp.read.len = shr(buf.len,1);/* read next buffer full */            if dspdebug <> 0 then do;               disable;               print 'Starting Read: ',track#, s#(0), s#(1), dsp.read.len;               print '     DSP.End = ', dsp.end(0), dsp.end(1);               enable;            end;            if left.found <> 0 then do;               if  ((read.track.info&bits(track#))=0)        /* if first read */               then zap.buffer    (track#) = 1;               /* then clear buffer contents */               read.track.info        = read.track.info \ bits(track#);               track.info.direction   = track.info.direction & (not(bits(track#)));               track.info.busy        = track.info.busy \ bits(track#);               status.tracks          = status.tracks   \ bits(track#);  /* switch back to NOT RECORDING if copying info on same track */               read.track.buf.len (track#) = dsp.read.len;  /* fill read buffer */               read.track.chunk   (track#) = 26;               read.track.msb     (track#) = s#(0);           /* sample # to read   */               read.track.lsb     (track#) = s#(1);               track.eof          (track#) = 0;            end;            if sys.stereo and right.found <> 0 then do;/* do the same for the second track. */               if dspdebug <> 0 then do;                  disable;                  print 'Starting Read (r): ', right.track#, s#(0), s#(1);                  enable;               end;               if  ((read.track.info&bits(right.track#))=0)        /* if first read */               then zap.buffer    (right.track#) = 1;               /* then clear buffer contents */               read.track.info        = read.track.info \ bits(right.track#);               track.info.direction   = track.info.direction & (not(bits(right.track#)));               track.info.busy        = track.info.busy \ bits(right.track#);               status.tracks          = status.tracks   \ bits(right.track#);  /* switch back to NOT RECORDING if copying info on same track */               read.track.buf.len (right.track#) = dsp.read.len;  /* fill read buffer */               read.track.chunk   (right.track#) = 26;               read.track.msb     (right.track#) = s#(0);           /* sample # to read   */               read.track.lsb     (right.track#) = s#(1);               track.eof          (right.track#) = 0;            end;/* of if sys.stereo */         end;/* of tracks not busy */         else do;            if dspdebug <> 0 then do;               disable;               print 'left.track.not.busy = ',left.track.not.busy;               if sys.stereo then               print 'right.track.not.busy= ',right.track.not.busy;               print 'track.eof(track#)   = ',track.eof(track#);               print 'left.buf.ready      = ',left.buf.ready;               if sys.stereo then               print 'right.buf.ready     = ',right.buf.ready;               enable;            end;         end;      end;   end;         /* Extended commands cover reading & writing of splice data, */   /* end of track, etc.                                        */   else if (DSP70.Event & dsp#event.mask) = dsp#extended.cmd   then do;      if (DSP70.there) and (use.DSP70)      then do;         call dsp.write(icr,dsp#ext.ack.set);         ext.cmd = dsp.read(isr);      end;      else ext.cmd = Get.Next.Stacked.DSP.Event;      if dspdebug <> 0      then print 'ext.cmd = ',ext.cmd;      if (ext.cmd & dsp#event.mask) = dsp#done      then do;         if dspdebug <> 0 then         print 'Done with track';         if (DSP70.there) and (use.DSP70)         then call dsp.write(icr,"h03");         Dsp.Next.Track = 1;            /* set flag for processing above */      end;      else if (ext.cmd & dsp#event.mask) = "h08"      then do;         if dspdebug <> 0         then print 'reading 512 words of edit data';         call dsp.write(icr,"h81");         do i = 1 to 2; /* do twice */            load Dsp.Edit.Len;          /* get which sector #    */            div  buf.len;               /* get track# and offset */            track# = res;            j      = rem;            if  (track# >= max.tracks)         /* if too many    */            or  (track.available(track#) = 0)  /* or not avail   */            then do;                           /* must toss      */               call dsp.write(icr,"h89");               write(DSPCtl) = DSPRead|DSP32SE;               rpc 256;               write("324") = read(DSPData);/* chuck it for now */               call dsp.write(icr,"h81");               call Log.Error('Out of room for Edit List Storage');            end;            else do;                        /* read & store in record buffer */               call psmwrite( compute.base.adr(track#)                            + buf.base                            + rec.base                            + j,0);               call dsp.write(icr,"h89");               write(DSPCtl) = DSPRead|DSP32SE;               rpc 256;               write(psd) = read(DSPData);/* chuck it for now */               call dsp.write(icr,"h81");            end;            Dsp.Edit.Len = Dsp.Edit.Len + 1;         end;      end;      else if (ext.cmd & dsp#event.mask) = "h10"      then do;         if dspdebug <> 0         then print 'writing 512 words of edit data';         call dsp.write(icr,"h82");         do i = 1 to 2; /* do twice */            load Dsp.Edit.Len;          /* get which sector #    */            div  buf.len;               /* get track# and offset */            track# = res;            j      = rem;            if  (track# >= max.tracks)         /* if too many    */            or  (track.available(track#) = 0)  /* or not avail   */            then do;                           /* must toss      */               call dsp.write(icr,"h92");               write(DSPCtl) = DSPWrite|DSP32SE;               rpc 256;               write(DSPData) = 0;/* garbage for now */               call dsp.write(icr,"h82");               call Log.Error('Out of room for Edit List Storage');            end;            else do;                        /* read & send splice info */               call psmread( compute.base.adr(track#)                           + buf.base                           + rec.base                           + j, 0);               call dsp.write(icr,"h92");               write(DSPCtl) = DSPWrite|DSP32SE;               rpc 256;               write(DSPData) = read(psd);               call dsp.write(icr,"h82");            end;            Dsp.Edit.Len = Dsp.Edit.Len + 1;         end;      end;   end;      /* detect crash of 56000: */   if (real.milliseconds - dsp.time) IGT 10000   then do;      call log.error('Timeout error with DSP70 hardware');      dsp.state = dsp#off;                  /* No more; we're done. */      get.new.motion = get.new.motion \ 4;  /* Send end cmd to Synclav */   end;   if  ((real.milliseconds - dsp.reselect.time) IGT 2000)   and (syn.scsi.data.xfer <> sys#off)   then do;      call SUB32(Dsp.Out.Here, Dsp.Out.s, B);      dsp.percent.done = Interpolate.Envelope.Segment(0,100,b,dsp.new.len);      /* correct for 4000 sector offset */      b(0) = 0;      b(1) = 4000;      c(0) = dsp.buf.msb;      c(1) = dsp.buf.lsb;      if syn.scsi.data.xfer = sys#OptDTD      then call Sub32(c,b,b);      /* select Synclavier so that it can get updated */      misc.buf(0) = dsp.out.track;      misc.buf(1) = dsp.percent.done;      misc.buf(2) = 0; /* not stopped */      misc.buf(3) = 0; /* no abort    */      misc.buf(4) = 0; /* no error    */      misc.buf(5) = b(0);      misc.buf(6) = b(1);      call Reselect.Synclavier(7, misc.buf);      dsp.paused = 1;/* pause the opertion so that the Synclavier may use the bus */      dsp.reselect.time = real.milliseconds;   end;end do.dsp;