/* Routines for SCSI read/write using the Synclavier SCSI bus   Used for Optical <-> DTD tansfer   11/28/94 -  pf - used scsi.active to reserve drives during dir reloads   02/13/89 - sjs*//* some assembler lits we will need */   dcl loa0  lit '"200"';   dcl and0  lit '"204"';   dcl or0   lit '"230"';   dcl tand0 lit '"244"';   dcl rtnz  lit '"335"';   dcl atnv  lit '"324"';   dcl rtze  lit '"331"';   dcl rtra  lit '"330"';   dcl bsor0 lit '"260"';/* the following routines handle real scsi transactions */get.scsi.command.byte: proc PUBLIC;   dcl (i) fixed;   // Assert REQ   write(ScsiBus)=S$Command \ S$REQ;   // Wait for ACK   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;   // Get the data   i=read(ScsiData)&S$DataMask;   // Remove REQ   write(ScsiBus)=S$Command;   // Wait for ack to go away   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;   return i;end get.scsi.command.byte;get.scsi.command.word: proc PUBLIC;   dcl (i) fixed;   i=get.scsi.command.byte;   return shl(i,8)\get.scsi.command.byte;end get.scsi.command.word;get.scsi.data.byte: proc PUBLIC;   dcl (i) fixed;   // Assert req   write(ScsiBus)=S$DataOut \ S$REQ;   // Wait for ack   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;   // Grab the data   i=read(ScsiData)&S$DataMask;   // Remove req   write(ScsiBus)=S$DataOut;   // Wait for ack to go away   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;   return i;end get.scsi.data.byte;get.scsi.data.word: proc PUBLIC;   dcl (b1,b2) fixed;   b1 = get.scsi.data.byte;   b2 = get.scsi.data.byte;   return (shl(b1,8) \ b2);end get.scsi.data.word;send.scsi.data.byte: proc(b) PUBLIC;   dcl (i,b) fixed;   // Post the data   write(ScsiData)=b;      // Assert REQ   write(ScsiBus)=S$DataIn \ S$REQ;   // Wait for ACK   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = 0;end;   // Remove REQ   write(ScsiBus)=S$DataIn;   // Wait for !ack   do while ((read(ScsiBus)&(S$ACK\S$ATN\S$RST))) = S$ACK;end;   write(ScsiData)=0;end send.scsi.data.byte;send.scsi.data.word: proc (b) PUBLIC;   dcl b fixed;   call send.scsi.data.byte(shr(b,8));   call send.scsi.data.byte(b&255);end send.scsi.data.word;finish.processing.scsi: proc (status) PUBLIC;   dcl status fixed;   // Handshake a status/message phase   write(ScsiBus) = S$Status;       /* status phase */      // Post the status data   write(ScsiData) = status&255;      // Assert REQ   write(ScsiBus) = S$Status | S$Req;      // Wait for ACK   do while (read(ScsiBus) & S$Ack) = 0;end;      // Release ACK   write(ScsiBus) = S$Status;                   /* release REQ */      // Wait for !ack   do while (read(ScsiBus) & S$Ack) <> 0;end;   /* wait for ACK to go false */   // Message phase   write(ScsiBus) = S$MessIn;       /* message phase */      // Post message byte of 0   write(ScsiData) = 0;             /* command complete */      // Assert req   write(ScsiBus) = S$MessIn | S$Req;      // Wait for ack   do while (read(ScsiBus) & S$Ack) = 0;end;      // Remove REQ   write(ScsiBus) = S$Messin;                   /* release REQ */      // Wait for !ack   do while (read(ScsiBus) & S$Ack) <> 0;end;   /* wait for ACK to go false */   write(ScsiData) = 0;             /* release data lines */   write(ScsiBus ) = 0;             /* free the buss */end finish.processing.scsi;/* $page - process an actual scsi msg */dcl scsi.comm.msb   fixed public;dcl scsi.comm.lsb   fixed public;dcl scsi.comm.len   fixed public;dcl scsi.comm.prt   fixed public;dcl scsi.comm.io    fixed public;dcl scsi.comm.write fixed public;scsi.comm.write = 0;dcl scsi.active     fixed public;scsi.active = 0;dcl LastSenseKey    fixed;LastSenseKey=0;process.scsi.msg: proc PUBLIC;   dcl (i,j)           fixed;   dcl scsi.command    fixed;   dcl scsi.in.msg     fixed;   dcl lun             fixed;   dcl data.buf(255)   fixed;   dcl (msb,lsb)       fixed;   dcl trk             fixed;   dcl len             fixed;   dcl saveR0          fixed;   dcl status          fixed;   dcl vendor data   ('ST C    ');   dcl product data  ('iDertct--oiDks  ');   dcl revision data ('.7 0');   status = S$Good;   do while ((read(Scsibus)&S$SEL)<>0);     /* SEL release                 */   end;   if ((read(Scsibus)&S$ATN)<>0)            /* see if attention set        */   then do;   end;   if ((read(Scsibus)&S$RST)<>0)            /* see if abort desired        */   then do;      write(ScsiData)=0;      write(ScsiBus)=0;                     /* done                        */      return;   end;   write(ScsiBus)=S$Command;                /* start command phase */   scsi.command = get.scsi.command.byte;   if scsi.command = "H08" then do;          /* SCSI Receive Command */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      i = get.scsi.command.byte;             /* skip mmsb len byte */      len = shr(get.scsi.command.word,1);    /* read lsb len only, convert byte count to word count */      i = get.scsi.command.byte;             /* read in control byte */      if (len igt 32768) then len = 32768;     /* limit to our buffer size */      write(ScsiBus)=S$DataIn;               /* go to data in phase */      if (port.exists(scsi.comm.prt&255)) then do;         write(mam)=xfer.buf.sec#;         do i = 0 to len - 1;            write("313")=read(mdi);            insert ':lod:sendword';         end;         len = shr(len,8);         scsi.comm.lsb = scsi.comm.lsb + len;  /* set up to get next buffer full */         if (scsi.comm.lsb ilt len) then scsi.comm.msb = scsi.comm.msb + 1;         scsi.comm.len = shl(len,8);         scsi.comm.prt = scsi.comm.prt | 256;         scsi.comm.io  = 1;          /* lod to initiator */      end;      else status = S$CheckCondition;      call finish.processing.scsi(status);   end;   else if scsi.command = "H0A" then do;     /* SCSI Send Command */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      i = get.scsi.command.byte;             /* skip msb len bytes */      len = get.scsi.command.word;           /* read len (in bytes) */      i = get.scsi.command.byte;             /* read in control byte */      if  ((scsi.comm.write) <> 0 )      and (scsi.comm.io = 0) then do;         scsi.comm.write = 0;                /* clear this right away to make sure */         if (shr(len,1) <> scsi.comm.len) then do;               status = S$CheckCondition;            call finish.processing.scsi(status);            return;         end;         write(ScsiBus) = S$DataOut;         /* switch to data out phase */               write(mam)=xfer.buf.sec#;         do i = 0 to shr(len,1) - 1;            write(mdi) = get.scsi.data.word;         end;         scsi.comm.prt = scsi.comm.prt | 256;         call finish.processing.scsi(status);         return;      end;      if (len > 256) then len = 256;         /* limit to our buffer size */      write(ScsiBus) = S$DataOut;            /* switch to data out phase */            do i = 0 to (len-1);         data.buf(i) = get.scsi.data.byte;   /* read in command data bytes */      end;      scsi.in.msg = data.buf(0);             /* get our command type */            if scsi.in.msg = 1                     /* read from dtd drives */      then do;         if port.exists(data.buf(7)) then do;            msb = shl(data.buf(1),8) \ (data.buf(2) & 255);            lsb = shl(data.buf(3),8) \ (data.buf(4) & 255);            len = shl(data.buf(5),8) \ (data.buf(6) & 255);            if ((msb <> scsi.comm.msb) or (lsb <> scsi.comm.lsb)            or (len igt scsi.comm.len) or (data.buf(7) <> (scsi.comm.prt&255))) then  do;               scsi.comm.msb = msb;               scsi.comm.lsb = lsb;               scsi.comm.len = len;               scsi.comm.prt = data.buf(7) | 256;               scsi.comm.io  = 1;          /* lod to initiator */            end;         end;         else status = S$CheckCondition;      end;      else if scsi.in.msg = 2                /* set up for write to dtd drives */      then do;         if port.exists(data.buf(7)) then do;            scsi.comm.msb = shl(data.buf(1),8) \ (data.buf(2) & 255);            scsi.comm.lsb = shl(data.buf(3),8) \ (data.buf(4) & 255);            scsi.comm.len = shl(data.buf(5),8) \ (data.buf(6) & 255);            scsi.comm.prt = data.buf(7);            scsi.comm.io  = 0;          /* initiator to lod */            if (scsi.comm.len igt 32768) then scsi.comm.len = 32768;     /* limit to our buffer size */            scsi.comm.write = 1;        /* set flag so next scsi send command is interpreted correctly */         end;         else status = S$CheckCondition;      end;      else if scsi.in.msg = 3 then do;         j = shl(data.buf(1),8) \ data.buf(2);  /* get 16 track bits */         adir.inval.trks=adir.inval.trks \ j;   /* or the bits in for main loop */         cue.dir.valid=0;            /* set flag to cause all relevant directories to be read back in from disk */         scsi.active=1;              /* set this until done loading */      end;      else do;         status = S$CheckCondition;      end;      call finish.processing.scsi(status);   end;   else if scsi.command = "H25" then do;     /* SCSI Read Capacity Command */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      i = get.scsi.command.word;             /* skip addr */      i = get.scsi.command.word;      i = get.scsi.command.word;             /* and 4 reserved bytes */      i = get.scsi.command.word;      /* check capacity */      if port.exists(lun) then do;         i = 0;j = 0;         tptr = lun*tracks.per.port*total.stride;     /* use lun to identify port - kinda kludgy */         if (readcapacity = 0) then do;            i = cap.msb;            j = cap.lsb;         end;         write(ScsiSel) = S$SelectEnable \ Scsibits (syn.d24.#);  /* reselect correct d24 board */         write(ScsiBus)=S$DataIn;               /* go to data in phase */         call send.scsi.data.word(i);           /* capacity msb */         call send.scsi.data.word(j);           /* lsb */         call send.scsi.data.word(0);           /* block size */         call send.scsi.data.word(512);      end;      else status = S$CheckCondition;      call finish.processing.scsi(status);   end;   else if scsi.command = "H12" then do;     /* SCSI Inquiry Command */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      j = get.scsi.command.word;             /* skip reserved */      i = get.scsi.command.byte;             /* get alloc length */      j = get.scsi.command.byte;             /* skip control byte */      data.buf( 0) = shl(3 ,8) or 0;          /* device type/qualifier */      data.buf( 1) = shl(1 ,8) or 0;          /* ANSI approved/reserved */      data.buf( 2) = shl(31,8) or 0;          /* addition length/unused */      data.buf( 3) = shl(0 ,8) or 0;          /* unused/features */      data.buf( 4) = vendor  (1);             /* vendor: 'Synclav' */      data.buf( 5) = vendor  (2);      data.buf( 6) = vendor  (3);      data.buf( 7) = vendor  (4);      data.buf( 8) = product (1);             /* product: 'Direct-to-Disk' */      data.buf( 9) = product (2);      data.buf(10) = product (3);      data.buf(11) = product (4);      data.buf(12) = product (5);      data.buf(13) = product (6);      data.buf(14) = product (7);      data.buf(15) = product (8);      data.buf(16) = revision(1);             /* revision: 7.0 */      data.buf(17) = revision(2);      if (i <> 0) then do;                    /* non-zero alloc length passed in */         write(ScsiBus)=S$DataIn;             /* go to data in phase */         j = 0;         do while (j < i);                    /* send as many bytes as caller asked for */            call send.scsi.data.byte(shr(data.buf(shr(j,1)),8));            j = j + 1;            if (j < i) then do;               call send.scsi.data.byte(data.buf(shr(j,1)) & 255);               j = j + 1;            end;         end;      end;      call finish.processing.scsi(status);   end;   else if scsi.command = "H03" then do;     /* SCSI Request Sense */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      j = get.scsi.command.word;             /* skip reserved */      i = get.scsi.command.byte;             /* get alloc length */      j = get.scsi.command.byte;             /* skip control byte */      if i = 0 then i = 4;                   /* default 'scsi spec' */      do j=0 to 255;data.buf(j)=0;end;      data.buf(0) = "H70";      data.buf(1) = 0;      data.buf(2) = LastSenseKey;      data.buf(3) = 0;      write(ScsiBus)=S$DataIn;             /* go to data in phase */      j = 0;      do while (j < i);                    /* send as many bytes as caller asked for */         call send.scsi.data.byte(data.buf(j));         j = j + 1;      end;      LastSenseKey=0;      call finish.processing.scsi(status);   end;   else if scsi.command = "H00" then do;     /* SCSI Test Unit Ready */      lun = shr(get.scsi.command.byte,5);    /* read in lun byte */      j = get.scsi.command.word;             /* skip reserved */      i = get.scsi.command.byte;             /* get alloc length */      j = get.scsi.command.byte;             /* skip control byte */      if scsi.active then status = S$Busy;   /* we are busy reading directories */      call finish.processing.scsi(status);   end;   else do;      LastSenseKey=5;      status = S$CheckCondition;      call finish.processing.scsi(status);   end;end process.scsi.msg;/* Note: Read.Last.Sector.For.Stereo is sort of a kludge.  If we are reading *//* a stereo file from the optical, our last read will always be a single     *//* sector (we should be reading 2 for stereo), and we need to handle the last *//* read as a special case.                                                    */Read.Last.Sector.For.Stereo: proc (base.l, base.r, msb, lsb);   dcl msb      fixed; /* disk address of data to read (msb) */   dcl lsb      fixed; /* disk address of data to read (lsb) */   dcl base.l   fixed; /* poly base address (left track)     */   dcl base.r   fixed; /* poly base address (right track)    */   dcl i        fixed;   tptr = optical.tptr;   write(mam) = dsp.xmsec#;   /* read a sector */   i = readdata(msb, lsb, loc(0), 256);   if i <> 0 then do;      return i;      dsp.scsi.error = i;    /* set error code           */      dsp.state = dsp#abort; /* abort and clean up       */      dsp.next.track = 1;    /* start cleanup processing */   end;   /* write odd to buffer, pad with zeros */   write(mam) = dsp.xmsec#;   call psmwrite(base.l,0);   do i = 0 to 255;      write(PSD)  = read(mdi);      write(ATNV) = read(mdi);   end;   RPC 128; /* fill rest of sector with zeros */   write(PSD) = 0;   /* write even to buffer pad with zeros */   write(mam) = dsp.xmsec#;   call psmwrite(base.r, 0);   do i = 0 to 255;      write(ATNV) = read(mdi);      write(PSD)  = read(mdi);   end;   RPC 128; /* fill rest of sector with zeros */   write(PSD) = 0;   return 0;end Read.Last.Sector.For.Stereo;Synclavier.SCSI.Check:proc public swapable;   dcl (sec.msb,sec.lsb)   fixed;   dcl (i,j,k,m)           fixed;   dcl temp(1)             fixed;   dcl track#              fixed;   dcl right.track#        fixed;   dcl base.addr.l         fixed;   dcl base.addr.r         fixed;   dcl the.zap             fixed;   /* at this point, we only support one or two channel transfers */   /* so we know right away which tracks are which, and we don't  */   /* have to loop over tracks as in port check.                  */   /* Note: if doing Opt <-> DTD, in tracks = out tracks          */   /*       if doing DTD <-> Opt, out tracks = first two in tracks*/   track# =dsp.out.track;    if sys.stereo   then right.track# =dsp.out.track.r;   /* we want to stop after first track & pair is done.  Don't want      to catch the same track twice.   */   if (read.track.info&bits(track#))<>0   then do;/* if action desired on this track */      /* check to see if buffers have been cleared */      if sys.stereo then do;         the.zap = ((zap.buffer(track#)) or (zap.buffer(right.track#)));      end;      else do;         the.zap = zap.buffer(track#);      end;      /* check for read/write of SCSI device to accomplish */      /* digital transfer:                                 */      /* NOTE: read.track is in SECTORS for a write */      if  ((track.info.direction&bits(track#))<>0)      and (syn.scsi.data.xfer = SyS#DTDOpt)      then do;                           /* writing data to SCSI device */         /* read.track.written holds the amount already written.  read.track.len    */         /* holds the total amount we need to write.                                 */         if read.track.written(track#) < read.track.len(track#)         then do;                            /* more data to write         */            /* if we are writing to a device that interleaves stereo  */            /* samples, we need to multiply by two to get the correct */            /* disk address.                                          */            if (sys.stereo)            then j = shl(read.track.written(track#),1);            else j = read.track.written(track#);            sec.msb = read.track.msb(track#);            sec.lsb = read.track.lsb(track#) + j;            if sec.lsb ilt j then sec.msb = sec.msb + 1;            i    = read.track.len (track#) - read.track.written(track#);            /* read.track.chunk should always be = buffer length here */            if i > read.track.chunk(track#) then i = read.track.chunk(track#);            /*  Read/Write SCSI bus */            base.addr.l = compute.base.adr(track#)                         + buf.base                         + read.track.written (track#)                         + read.track.buf.base(track#);/* poly source base address */            /* if you are modifying the program to deal with multiple               tracks at a time, then you'll need to change the following               logic.            */            if sys.stereo then do;               if right.track# <> 0 then do;                  base.addr.r = compute.base.adr(right.track#)                              + buf.base                              + read.track.written(right.track#)                              + read.track.buf.base(right.track#);               end;            end;                           m = Syncl.SCSI.Write(base.addr.l,base.addr.r,i,sec.msb,sec.lsb,sys.stereo); /* write data to SCSI bus */            if m = 0            then do;/* if write successful */               if dspdebug <> 0               then do;                  disable;                  print 'Write SUCCESSFUL ';                  enable;               end;               read.track.written(track#) = read.track.written(track#) + i;               if sys.stereo then               read.track.written(right.track#) = read.track.written(right.track#) + i;            end;                        else do; /* some kind of read error */               if dspdebug <> 0               then do;                  disable;                  print 'Error writing device ';                  enable;               end;               dsp.scsi.error = m;    /* set error code           */               dsp.state = dsp#abort; /* abort and clean up       */               dsp.next.track = 1;    /* start cleanup processing */               track.info.busy = track.info.busy & (not(bits(track#))); /* set to not busy for abort */               if sys.stereo then do;                  track.info.busy = track.info.busy & (not(bits(right.track#)));               end;               return; /* end this mess now */            end;            if read.track.written(track#) = read.track.len(track#)            then do;               track.info.busy = track.info.busy & (not(bits(track#)));               if sys.stereo then do;                  track.info.busy = track.info.busy & (not(bits(right.track#)));               end;            end;            else do;               if dspdebug <> 0 then do;                  disable;                  print 'READ.TRACK.WRITTEN <> READ.TRACK.LEN';                  print '  read.track.written = ', read.track.written(track#);                  print '  read.track.len     = ', read.track.len(track#);                  enable;               end;            end;         end;      end;      /* NOTE: buf1 and read.track are in SAMPLES, need to         convert to sector number for SCSI.      */      else if  (((track.info.direction&bits(track#))=0)      and      (syn.scsi.data.xfer = SyS#OptDTD))      and      (the.zap = 0)   /* wait for the buffer zapping to happen */      then do;                 /* reading data from SCSI device         */         /* handle reading data from SCSI */         if (buf1.msb(track#)<>read.track.msb(track#))         or (buf1.lsb(track#)<>read.track.lsb(track#))         then do;            buf1.len(track#) = 0;            buf1.msb(track#) = read.track.msb(track#);            buf1.lsb(track#) = read.track.lsb(track#);            /* assume tracks are in sync */            buf1.len(right.track#) = 0;            buf1.msb(right.track#) = read.track.msb(right.track#);            buf1.lsb(right.track#) = read.track.lsb(right.track#);         end;         if buf1.len(track#) ilt read.track.buf.len(track#) then do;            i    = read.track.buf.len(track#) - buf1.len(track#);            if i > read.track.chunk  (track#) then i = read.track.chunk(track#);            /* calculate buffer pointer */            base.addr.l = compute.base.adr(track#)                        + buf.base                        + buf1.len(track#);  /* read into this section of memory */            if (sys.stereo) then do;               if right.track# <> 0 then do;                  base.addr.r = compute.base.adr(right.track#)                              + buf.base                              + buf1.len(right.track#);               end;            end;            temp(0) = shr(buf1.msb(track#),8);            temp(1) = shl(buf1.msb(track#),8) | shr(buf1.lsb(track#),8);            /* if we are reading a stereo file from a device that    */            /* interleaves samples, then we need to multiply the     */            /* buffer length by two to get the correct disk address. */            if (sys.stereo) and (syn.scsi.data.xfer = sys#OptDTD)            then j = shl(buf1.len(track#),1);            else j = buf1.len(track#);            temp(1) = temp(1) + j;            if temp(1) ilt j            then temp(0) = temp(0) + 1;            j = Syncl.SCSI.Read(base.addr.l,base.addr.r,i,temp(0),temp(1),sys.stereo); /* read data to SCSI bus */            if j = 0            then do;/* if read was successful */               /* update appropriate variables */               buf1.len(track#) = buf1.len(track#)+i;               if sys.stereo then do;                  buf1.len(right.track#) = buf1.len(right.track#)+i;               end;            end;            else do;/* else if error occurred */               /* handle error */               if 1 then do;                  disable;                  print 'Error with Syncl.SCSI.Read';                  print 'Disk addr ', temp(0), temp(1);                  print 'Length = ',i;                  print 'Error code = ', j;                  enable;               end;               dsp.scsi.error = j;    /* set error code           */               dsp.state = dsp#abort; /* abort and clean up       */               dsp.next.track = 1;    /* start cleanup processing */               track.info.busy = track.info.busy & (not(bits(track#))); /* set to not busy for abort */               if sys.stereo then do;                  track.info.busy = track.info.busy & (not(bits(right.track#)));               end;               return;            end;            if buf1.len(track#) = read.track.buf.len(track#)            then do;               track.info.busy = track.info.busy & (not(bits(track#)));               if sys.stereo then do;                  track.info.busy = track.info.busy & (not(bits(right.track#)));               end;            end;         end;         else if (read.track.buf.len(track#)= 0) and (sys.stereo)         and     (syn.scsi.data.xfer = sys#OptDTD)         then do;            /* This is a special case.  If read.track.buf.len = 0     */            /* then we know that we                                   */            /* are trying to read the last sector (256 words) of a    */            /* stereo file, which translates to 1/2 a sector (128     */            /* words) per buffer                                      */            /* calculate buffer pointer */            base.addr.l = compute.base.adr(track#)                        + buf.base                        + buf1.len(track#);  /* read into this section of memory */            if (sys.stereo) then do;               if right.track# <> 0 then do;                  base.addr.r = compute.base.adr(right.track#)                              + buf.base                              + buf1.len(right.track#);               end;            end;            temp(0) = shr(buf1.msb(track#),8);            temp(1) = shl(buf1.msb(track#),8) | shr(buf1.lsb(track#),8);            /* if we are reading a stereo file from a device that    */            /* interleaves samples, then we need to multiply the     */            /* buffer length by two to get the correct disk address. */            j = shl(buf1.len(track#),1);            temp(1) = temp(1) + j;            if temp(1) ilt j            then temp(0) = temp(0) + 1;            j = Read.Last.Sector.For.Stereo(base.addr.l,base.addr.r,temp(0),temp(1));            if j = 0 then do;               buf1.len(track#) = buf1.len(track#)+1;               track.info.busy = track.info.busy & (not(bits(track#)));               if sys.stereo then do;                  track.info.busy = track.info.busy & (not(bits(right.track#)));                  buf1.len(right.track#) = buf1.len(right.track#)+1;               end;            end;            else do;               /* clean up error */            end;         end;      end;/* of else if */   end;/* of if read.track.info etc */end Synclavier.SCSI.Check;