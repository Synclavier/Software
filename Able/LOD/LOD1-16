/* LOD1-16:   punch in, punch out, recording *//* 8/14/91 - cj - Added UDIO/DDSYN stuff                        *//* 3/25/91 - cj - moved synch code here from lod1-15            *//* 3/27/89 - cj - change track priority to                      *//*                achieve 50 Khz data rate with max trax bounce *//* check synchronization between DTD, Poly, and Synclavier      *//* the check synchronization routine is called when output is actually   occurring.  it checks the poly synth to see how many samples   have been played out since the synth was started.   it then   examines the synclavier time base to see where we are playing   in the synclavier.   the frequency of the poly synth   is adjusted so that the LOD output is synced to the synclavier *//* In rev 7 (or later) of the synclavier software,  the synclavier *//* time base is modified (if not using smpte) to match the poly    *//* synth rate.                                                     *//* sync is checked every 200 milliseconds.   the constants in the   following routine assume that the sync is checked at approximately   that rate.  *//* If the DDT Hardware is active and we are syncing to the DDT input *//* signal,  then both the poly synth and the synclavier time base    *//* are adjusted to match the DDT input clocks                        */#if (HzDbug)	dcl check.timer fixed;#endifcheck.synchronization:proc;   dcl (i,k)            fixed;   dcl (Adv.DDT.S#) (1) fixed;   dcl (Master.S# ) (1) fixed;   dcl (Delta)      (1) fixed;   dcl samples          fixed;   dcl base.rate        fixed;   if Now.Playing <> 0       /* if Playing,  then check sequencer time */   then do;                  /* base variables for timing              */      /* compute sample # and sync time         */      /* for where we are.  By "Where we are"   */      /* we actually  mean "where we will be"   */      /* a short distance ( 20 msecs. or so)    */      /* in the future                          */      call compute.address.and.sync.time(0);    /* do not need a sector boundary */      /* now see what sample # is currently playing */      /* also measure accumulated DDT word clocks   */      call get.sync.s#;                         /* get d16 time and chan 32 sample # */      /* now project the current sample # into the future */      /* so that it matches play.sync.time                */      call SUB32(Play.Sync.Time, Our.Time, Bit);  /* get d16 ticks to sync point */      /*    samples = (current.rate/10) * (d16ticks/d16tim) */      call ratio_multiply(current.rate,10*d16tim);      if Apply.Drop.Frame.Correction <> 0 then do; /* sync samples to 30 frames */         if Apply.Drop.Frame.Correction > 0         then call ratio_multiply(2997, 3000);     /* instead of 29.97 frames   */         else call ratio_multiply(3000, 2997);      end;      if smpte.onoff<>0 then do;                /* will be scaled by smpte speed below */         call ratio_multiply(smpte.track.rate,smpte.mode.rate);      end;      call ADD32(Sync.S#, Bit, Sync.S#);      call ADD32(DDT.S#, Bit, Adv.DDT.S#);      /* project DDT word clock into */                                                /* the future as well          */   end;   else do;               /* else if not playing, then must be triggering */                          /* or monitoring                                */                          /* and we are trying to sync to DDT             */      call Get.Sync.S#;   /* Get chan 32 info + DDT info                  */      call COPY32(DDT.S#, Adv.DDT.S#); /* store in adv.ddt.s#             */   end;                                          /* $page - check for early/late          */   /* we have computed 3 synchronized times:                 */   /*    Play.S#     - sample # where synclavier is          */   /*    Sync.S#     - sample # where chanel 32 is           */   /*    Adv.DDT.S#  - sample # where DDT word clock is      */   /* now adjust the poly bin and/or the synclavier          */   /* to match the master clock                              */   /* Look at Sync.Mode and determine whether we should      */   /* sync the Poly bin to the Synclavier,  sync the         */   /* synclavier to the Poly Bin,  or sync both of them      */   /* to the DDT hardware                                    */   out.of.sync = 0;         /* assume synchronizing will not fail      */   do case (Sync.Mode);      do;         New.Sync.Info = 0; /* if no syncing going on (debugging only) */         return 0;          /* then no adjustments to make             */      end;      do;                   /* 1: sync poly bin to synclav   */                            /*    or synclav to poly bin     */                            /*    depending on software      */                            /*    version                    */         if  (Synclav.software.version >= 7)   /* modulate synclav time */         and (smpte.onoff              =  0)   /* base if possible      */         and (new.speed                =  0)   /* no new speed setting  */         then call COPY32(Sync.S#, Master.S#); /* sync to poly bin      */         else call COPY32(Play.S#, Master.S#); /* sync to d3/smpte      */      end;      do;                   /* 2: sync to DDT Hardware       */         call COPY32(Adv.DDT.S#, Master.S#);      end;   end;   /* $page - adjust poly synth to match master */   if COM32(Sync.S#, Master.S#) >= lw#ieq  /* poly synth is ahead of master */   then do;      call SUB32(Sync.S#, Master.S#, Delta);      if Com16(10000, Delta) = lw#ilt then samples = 10000;      else                                 samples = delta(1);   end;   else do;                                  /* behind       */      call SUB32(Master.S#, Sync.S#, Delta);      if Com16(10000, Delta) = lw#ilt then samples = -10000;      else                                 samples = -delta(1);   end;	#if (HzDbug)		if (check.timer == 0)		{			if  ((Synclav.software.version >= 7)   /* modulate synclav time */			and  (smpte.onoff              =  0)   /* base if possible      */			and  (new.speed                =  0))  /* no new speed setting  */				print 'Sync to Poly ', samples;			else				print 'Sync to Play ', samples;		}				check.timer = check.timer + 1;		if (check.timer == 25)			check.timer = 0;	#endif   if (samples>=(+10000))                    /* detect grossly out */   or (samples<=(-10000))                    /* of sync            */   then do;      if HzDbug <> 0      then do;         print 'Resynchronizing...';         print '   Sync.S#     :',Sync.s#(0),   Sync.S#(1);         print '   Master.S#   :',Master.s#(0), Master.S#(1);         print '   Delta       :',Delta(0),     Delta(1);         print;      end;      if  ( Smpte.OnOff   <> 0 )      and ((Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Dspin\Dig.Forcedsp)) <> 0)      then do;         call Log.Error('SMPTE signal is out of sync with Direct-Digital-Transfer');      end;      if samples<0 then return -1;    /* -1: means we are behind (sequencer jumped ahead) */      else              return +1;   end;   /* $page - apply correction to poly */   /* we are "samples" samples ahead (+) or behind (-) */   /* compute new rate that will correct               */   /* the error in .5 second                           */   /* algorithm for adjusting poly synth               */   /* rate:                                            */   /*    i.e. 100 samples late would require           */   /*    a .1 khz correction for 1 second, or          */   /*    or a .2 khz correction for .5 second          */   /*    so khz correction =samples.late/500           */   /*    but we want khz*40, so                        */   /*    correction=samples.late*40/500;               */   /*    or correction=samples.late*2/25               */                                      /*    also apply filter:  wait for two offsets in   */   /*    same direction before applying                */   /*    correction.   reduces jitter                  */                     /*    caused by interrupt latency in main           */   /*    synclavier.                                   */   if samples>=0 then do;             /* provide 20 sample dead band */      samples=samples-20;             /* 20 sample dead band         */      if samples<0 then samples=0;      i=(samples*2+49)/50;            /* round up if +               */      if  (previous.delta>0)          /* if + correction last time   */      and (samples       >0)          /* and this time               */      then do;                        /* two errors in same direction */         if (previous.correction<i)   /* correct minimum       */         then k=previous.correction;  /* amount                */         else k=i;      end;      else k=0;                 /* else no correction yet       */   end;   else do;                     /* <0 = means behind            */      samples=samples+20;      if samples>0 then samples=0;      i=(samples*2)/50;         /* round down if -              */      if  (previous.delta<0)    /* if - correction last time    */      and (samples       <0)    /* and this time                */      then do;                  /* two errors in same direction */         if (previous.correction>i)    /* correct minimum       */         then k=previous.correction;   /* amount                */         else k=i;      end;      else k=0;                 /* else no correction yet       */   end;   previous.delta      = samples; /* save for next time           */   previous.correction = i;   /* set new active rate */   active.rate=current.rate*4;   if  (Now.Playing      <> 0)        /* if synced with synclav   */   and (Smpte.Onoff      <> 0)        /* and using smpte sync     */   and (smpte.track.rate <> 0)		  /* and smpte still running  */   then do;                           /* scale for smpte speed    */      load active.rate;               /* active rate              */      mul smpte.track.rate; mwait;    /* times tracking rate      */      div smpte.mode.rate;            /* divide by mode rate      */      active.rate=res;                /* round below              */      if shl(rem,1) ige smpte.mode.rate      then active.rate=active.rate+1;	  if (hzdbug) & (active.rate <> current.rate*4) then do;	     print 'smpte ',active.rate, smpte.track.rate, smpte.mode.rate;	  end;   end;   active.rate=active.rate-k;         /* apply correction         */   if active.rate<    0 then active.rate=   0;   if active.rate>=4095 then active.rate=4095;   /* Limit frequency change if using DDSAD to avoid clicks/pops  */   /* out of DAC8.  We will eventually drop out of playback       */   /* if synchronization gets grossly out of wack.                */   if  (CREG_AVAIL   <> 0)         /* if using DDSAD              */   and (Now.Playing  <> 0)         /* if synced with synclav      */   and (Smpte.Onoff  <> 0)         /* and using smpte sync        */   then do;      base.rate = current.rate*4;  /* get base rate handy         */      if   active.rate < (base.rate - (DDSAD_WINDOW/50))      then active.rate = (base.rate - (DDSAD_WINDOW/50));      else if   active.rate > (base.rate + (DDSAD_WINDOW/50))      then      active.rate = (base.rate + (DDSAD_WINDOW/50));   end;   call set.lod.hz(active.rate,1);           /* set hz                      */   call set_ddsad_controls(active.rate,0);   /* enable/disable DDSAD too    */   if (hzdbug) & (k <> 0) then do;      print 'Correction: ',k;   end;   /* now adjust synclav time base                     */   /* algorithm for adjusting main synclav time        */   /* base:                                            */   /*    compute # of synclav time base msecs          */   /*    we are ahead or behind.   send this info      */   /*    to synclav so he can correct                  */   /*    A) samples = khz * millliseconds (definition) */   /*                                                  */   /*    B) Therefore: milliseconds = samples / khz    */   /*                                                  */   /*    C) since current.rate = khz*10, we get:       */   /*       milliseconds = (samples*10)/current.rate   */   /*                                                  */   /*    D) apply correction for synclavier speed,     */   /*       then we have it                            */   /*                                                  */   /*    also provide .7 msec hysteresis to avoid      */   /*    jitter in the time base.  In other words,  if */   /*    the poly synth gets ahead by > .7 msec, we    */   /*    will jump the synclavier time base ahead by   */   /*    1 msec.  this will make the poly synth .3     */   /*    msec behind next time around                  */   if Now.Playing <> 0       /* adjust synclav time base only while     */   then do;                  /* playing (not while triggering)          */      if COM32(Play.S#, Master.S#) >= lw#ieq  /* if synclavier is ahead */      then do;         call SUB32(Play.S#, Master.S#, Delta);         if Com16(10000, Delta) = lw#ilt then samples = 10000;         else                                 samples = delta(1);      end;      else do;                                  /* behind       */         call SUB32(Master.S#, Play.S#, Delta);         if Com16(10000, Delta) = lw#ilt then samples = -10000;         else                                 samples = -delta(1);      end;      if (samples>=(+10000))                    /* detect grossly out */      or (samples<=(-10000))                    /* of sync            */      then do;         if HzDbug <> 0         then do;            print 'Synclav Sync Error:';            print '   Play.S#     :',Play.s#(0),   Play.S#(1);            print '   Master.S#   :',Master.s#(0), Master.S#(1);            print '   Delta       :',Delta(0),     Delta(1);            print;         end;         if  ( Smpte.OnOff   <> 0 )         and ((Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Dspin\Dig.Forcedsp)) <> 0)         then do;            call Log.Error('SMPTE signal is out of sync with Direct-Digital-Transfer.');         end;         if samples<0 then return +1;    /* return -1 if sequencer is      */         else              return -1;    /* ahead, to better handle mark   */      end;                               /* starts                         */      if  (Synclav.software.version >= 7)  /* modulate synclav time */      and (smpte.onoff              =  0)  /* base if possible      */      then do;         /* compute number of samples in .3 msec to use as round up */         /* factor                                                  */         load Current.Rate;           /* current rate * .03 yields  */         div  33;                     /* samples in .3 msec.        */         i = res;                     /* approximate by .03 == 1/33 */         if samples >= 0 then do;     /* if sequencer is ahead      */            load samples+i;           /* samples                    */            mul   10;                 /* * 10                       */            mwait   ;            div current.rate;            samples = -res;           /* # of milliseconds to       */                                      /* retard synclav time base   */            if samples <   (-10)      /* but limit correction to    */            then samples = (-10);     /* +/- 10 milliseconds        */         end;         else do;                     /* sequencer is behind        */            load (-samples) + i;      /* get samples                */            mul   10;                 /* * 10                       */            mwait   ;            div current.rate;            samples = res;            /* # of milliseconds to       */                                      /* advance                    */            if samples >   (+10)      /* but limit correction to    */            then samples = (+10);     /* +/- 10 milliseconds        */         end;         Synclav.Time.Base.Adjust = samples;   /* save for Send.To.Lod    */         if (hzdbug) & (samples <> 0) then do;            print 'Syncl: ',samples;         end;      end;   end;   New.Sync.Info = 0;     /* done with this sync message */   return 0;end check.synchronization;/* compute scroll info *//* scroll.s# is a sample # with respect to the start of the current  *//* cue map                                                           *//* scroll.base is the trigger time (sync.s#.msb) at which that point *//* in the cue was triggered                                          *//* we must compute and return the current play time with respect     *//* to the start of the cue mapping                                   */compute.scroll.info: proc;                    dcl tmp(1) fixed;   /* if current sync.s# is before most recent cue trigger,  then */   /* treat as if current scroll time is at that trigger          */   if COM32(Sync.S#, Scroll.Base) = lw#ilt   then do;      call COPY32(Scroll.S#, tmp);   end;   else do;                  /* get time in this splice block */      call SUB32(Sync.S#, Scroll.Base, tmp);      call ADD32(Scroll.S#, tmp, tmp);   end;   call SUB32(tmp, Data.S#,      tmp); /* get with respect to start of disk */   call ADD32(tmp, Song.Data.S#, tmp); /* add to start of cur project       */   call compute.syncl.time(tmp,0,Syncl.Time); /* will yield time with respect to start of cue */   call COPY32(Syncl.Time, Cur.Dtd.Ms);   send.scroll.info=1;end compute.scroll.info;/* $page - buffer algorithm *//* basic algorithm:   we try to buffer ahead in poly memory.   this is done   by first figuring out what secion of data from the disk   should be in memory (desired.msb, desired.lsb, etc).   if we are not playing,  keep the buffer loaded from near the   start of the disk.   if playing,  load it from near the   play area.   once we figure out where the buffers should be loaded   from,  we look at each track to see if a disk command   should be started to fill the buffer. *//* variables for diskio:  */dcl (Desired.Buf1    )  (1) fixed;dcl (desired.buf1.msb)  lit 'Desired.Buf1(0)';dcl (desired.buf1.lsb)  lit 'Desired.Buf1(1)';dcl (desired.buf1.len)  fixed;dcl (Desired.Buf2    )  (1) fixed;dcl (desired.buf2.msb)  lit 'Desired.Buf2(0)';dcl (desired.buf2.lsb)  lit 'Desired.Buf2(1)';dcl (desired.buf2.len)  fixed;dcl (Desired.Buf3    )  (1) fixed;dcl (desired.buf3.msb)  lit 'Desired.Buf3(0)';dcl (desired.buf3.lsb)  lit 'Desired.Buf3(1)';dcl (desired.buf3.len)  fixed;/* note: buf2 refers to the first part of buf1 that has been *//* loaded with data for the next buffer                      *//* buf3 refers to the last part of buf1 that has been loaded *//* with data from the prior buffer (looped playback only)    *//* $page - perform punch in cross fade *//* punch in constructs a cross fade between newly recorded data *//* and data that is already recorded on the disk.  When         *//* punch in is called,   numerous input conditions have         *//* been met:                                                    *//*                                                              *//*    max.s#.lsb-rec.s#.lsb > pwlen     pwlen samples taken     *//*    max.s#.lsb-rec.s#.lsb > 256       full sector available   *//*    buf1/buf2 set up                  contain original data   */Start.Punch.Read: proc(track#, base, sec, wrd);   dcl track# fixed;   dcl base   fixed;   dcl sec    fixed;   dcl wrd    fixed;   if  (Correct.DDT.Sync       <> 0)  /* if we should correct for delay */   and (track.sampling(track#) =  2)  /* and doing DDT input            */   then do;      if (sec + shr(ddt.monitor.delay,8)) >= buf.len      then call psmread(base + buf.base + rec.base + sec                             + shr(ddt.monitor.delay,8) - buf.len, wrd);      else call psmread(base + buf.base + rec.base + sec                             + shr(ddt.monitor.delay,8), wrd);   end;   else call psmread(base + buf.base + rec.base + sec, wrd);   /* get newly recorded data */                                                               /* into misc.buf             */end Start.Punch.Read;punch.in:proc(track#,wlen);      /* perform cross fade             */   dcl (track#) fixed;           /* track #                        */   dcl (wlen  ) fixed;           /* word length of cross fade      */   dcl (i,j,k)  fixed;   dcl (accum)  fixed;           /* cross fade accumulator         */   dcl (incr )  fixed;           /* accumulator increment          */   dcl (base )  fixed;   dcl (sec  )  fixed;   dcl (wrd  )  fixed;   dcl (slen )  fixed;   /* first compute increment and accumulator */   /* for constructing the splice             */   if wlen=0 then wlen=1;           /* must copy one sector           */   if wlen = 1 then do;             /* special case to avoid math     */      accum=32768;                  /* math errors                    */      incr =32768;   end;   else do;      load 0; uload 1; div wlen;    /* 65536/wlen = desired increment */      incr=res;                     /* desired increment              */      if rem<>0 then incr=incr+1;   /* round up so wlen<=desired      */      load 0; uload 1; div incr;    /* recompute actual wlen achieved */      wlen=res;      accum=shr(incr-incr*wlen,1);  /* init accum to 1/2 of remainder */       end;   /* the punch in will start at the sample indicated */   /* by rec.s#.msb,  rec.s#.lsb (the first sample    */   /* recorded)                                       */   /* get word within sector to start cross fade at:  */   wrd = rec.s#.lsb(track#) & 255;     /* round rec.s#.lsb down to sector boundary since  */   /* we will be writing a full sector of data        */   /* back out to disk                                */   rec.s#.lsb(track#) = rec.s#.lsb(track#) & "177400";     /* compute starting sector # in buffer:            */   sec=shr(rec.s#.lsb(track#)-recb.lsb(track#),8);     /* sector # in buffer to start cross fade at */   base=compute.base.adr(track#);  /* get base sector #       */   slen=0;                         /* count full sectors      */   do while wlen<>0;      i=wlen;      if i igt 256-wrd then i=256-wrd;   /* stop at end of first sector.  also limit to 256 at a crack */      wlen=wlen-i;                       /* account now for splice constructed below                   */      call Start.Punch.Read(track#, base, sec, wrd);                                         /* into misc.buf             */      write("313")=addr(misc.buf(0));      rpc 256-wrd;                       /* read in rest of sector of */      write("373")=read(psd);            /* newly recorded data       */      call psmread(base+buf.base+sec,wrd);  /* get original data       */      write("313")=addr(misc.buf(0));      j=accum;                   /* set mr pointers         */      do while i<>0;         load (read("353") xor "100000");   /* get new data element     */         mul accum;                         /* punch in- start small    */         i=i-1;                             /* decrement while mul busy */         j=ures;                          load (read(psd)   xor "100000");   /* get old data element     */         mul -accum;                                accum=accum+incr;                  /* increment cross fade     */         write("373") = (j+ures) xor "100000";      end;      call psmwrite(base+buf.base+sec,wrd);  /* store cross faded data   */            write("313")=addr(misc.buf(0));      rpc 256-wrd;                           /* write out rest of sector */      write(psd)=read("373");      wrd=0;                      /* start at word 0 in next sector      */      sec=sec+1;                  /* advance sector pointer              */      if sec=buf.len then sec=0;  /* wrap                                */      slen=slen+1;                /* count # of full sectors stored      */   end;   piolen(track#)=slen;           /* # of sectors of punch in data       */end punch.in;/* $page - perform punch out cross fade */punch.out:proc(track#,wlen);     /* perform cross fade             */   dcl (track#) fixed;           /* track #                        */   dcl (wlen  ) fixed;           /* word length of cross fade      */   dcl (i,j,k)  fixed;   dcl (accum)  fixed;           /* cross fade accumulator         */   dcl (incr )  fixed;           /* accumulator increment          */   dcl (base )  fixed;   dcl (sec  )  fixed;   dcl (wrd  )  fixed;   dcl (xlen )  fixed;   /* compute increment/accumulator: */   if wlen=0 then wlen=1;           /* must copy one sector           */   if wlen = 1 then do;             /* special case to avoid math     */      accum=32768;                  /* math errors                    */      incr =32768;   end;   else do;      load 0; uload 1; div wlen;    /* 65536/wlen = desired increment */      incr=res;                     /* desired increment              */      if rem<>0 then incr=incr+1;   /* round up so wlen<=desired      */      load 0; uload 1; div incr;    /* recompute actual wlen achieved */      wlen=res;      accum=shr(incr-incr*wlen,1);          end;   /* we have written out the data up to the sector where the  */   /* punch out starts.   compute the word position in that    */   /* sector where we should start constructing the cross fade */   /* due to round down error in computing the incr/accum,     */   /* the punch in may not start exactly at the sector         */   /* indicated by rec.s#.lsb                                  */   base=compute.base.adr(track#);  /* get base sector #        */   sec = shr(rec.s#.lsb(track#)-recb.lsb(track#),8);     /* sector # in buffer we will next be writing to disk */   wrd = max.s#.lsb(track#) - wlen - rec.s#.lsb(track#); /* word position relative to that where we start the punch in - may be several sectors away due to round off */   /* copy data before the punch in point from the rec buf */   /* down to the play buf, since that is where we         */   /* write to the disk from after all punches.            */   i = wrd;   do while i <> 0;      call Start.Punch.Read(track#, base, sec, 0);      write("313")=addr(misc.buf(0));   /* copy in up to 256 words */      if i IGT 256 then do;         rpc 256;         write("373")=read(psd);      end;      else do;         rpc i;         write("373")=read(psd);      end;      call psmwrite(base+buf.base+sec,0);  /* store copied data for write */      write("313")=addr(misc.buf(0));      if i IGT 256 then do;         rpc 256;         write(psd) = read("373");         i = i - 256;      end;      else do;         rpc i;         write(psd) = read("373");         i = 0;      end;      if  (i <> 0)           /* if more to copy                     */      or  ((wrd & 255) = 0)  /* or this is end of copy and we       */      then do;               /* start on a sector boundary          */         sec = sec + 1;         if sec = buf.len then sec = 0;      end;   end;   wrd = wrd & 255;  /* start punch in on this word,  for wlen words */   /* now construct cross fade reading from record buffer */   /* and writing to play buffer                          */   do while wlen<>0;      i = wlen;      if i igt 256-wrd then i=256-wrd;   /* stop at end of first sector.  also limit to 256 at a crack */      wlen=wlen-i;                       /* account for following   */      xlen=i;                            /* save for write          */      call Start.Punch.Read(track#, base, sec, wrd);      write("313")=addr(misc.buf(0));      rpc xlen;                   /* read up through fade end or sector end */      write("373")=read(psd);      call psmread(base+buf.base+sec, wrd);  /* get orignal data starting at punch out point */      write("313")=addr(misc.buf(0));      j=accum;                   /* set mr pointers         */      do while i<>0;         load (read(psd)    xor "100000");  /* get original data element */         mul accum;          i=i-1;                             /* decrement while mul busy  */         j=ures;                          load (read("353")  xor "100000");  /* get new data element      */         mul -accum;                                accum=accum+incr;                  /* increment cross fade      */         write("373") = (j+ures) xor "100000";      end;      call psmwrite(base+buf.base+sec,wrd);  /* store cross faded data   */            write("313")=addr(misc.buf(0));      rpc xlen;      write(psd)=read("373");      wrd=0;                                 /* full sectors from now on */      sec=sec+1;                             /* advance sector pointer   */      if sec=buf.len then sec=0;             /* wrap                     */   end;   piolen(track#) = shr(max.s#.lsb(track#) + 255 - rec.s#.lsb(track#),8);end punch.out;/* called to update song used, modified, and track used fields *//* after recording or writing to disk                          *//* called with:  bitmsb,bitlsb  = sector #                 track.dir.song = song # */update.song.and.track.used:proc(track#);   dcl (track#) fixed;   dcl i fixed;   call SUB32(BIT, Song.Data, BIT);    /* sector relative to song start */   call ratio_multiply(256,50000);     /* get # of seconds       */   call unround;                       /* no rounding            */   if mul.llsb<>0                      /* but round up instead   */   then bitlsb=bitlsb+1;   i = gsong.dir(track.dir.song*song.len+song.end  )  /* limit used to length of song since */     - gsong.dir(track.dir.song*song.len+song.start); /* start.port.io did that for us      */   if bitlsb igt i then bitlsb = i;                   /* while we were recording            */   i=gsong.dir(track.dir.song*song.len+song.used);   if bitlsb igt i then do;            /* song is longer now     */      write(md)=bitlsb;      song.dir.updated=1;      if screen=1 then send.screen.info=1;    end;   i=gsong.dir(track.dir.song*song.len+song.status);   if (i&1)=0 then do;                 /* song was empty         */      write(md)=i\1;      song.dir.updated=1;      if screen=1 then send.screen.info=1;    end;   i=gsong.dir(track.dir.song*song.len+song.modified);   if (i&1)=0 then do;                 /* song was not modified  */      write(md)=i\1;      song.dir.updated=1;      if screen=1 then send.screen.info=1;    end;   i=track.dir(track#*track.len+track.used);   if bitlsb igt i then do;            /* track is longer now    */      track.dir(track#*track.len+track.used)=bitlsb;      track.dir.updated=1;      if screen=2 then send.screen.info=1;    end;end update.song.and.track.used;/* $page - track recording check *//* recording on a track - see what state of recording we are   in (punch in, recording, read data for punch out, cross fade,   punc out) and issue appropriate commands.   Stop recording when punch out is completed *//* track.punch contains bits that identify the state of the   recording process,  as follows:      1   -   waiting for enough samples to accumulate to construct              the punch-in cross fade.   the punch in routine assumes              the read buffer holds the correct data from the disk,              which it will as long as no serious disk errors have              occurred.      2   -   write results of punch-in out to disk.      4   -   normal recording.   punch-in was completed (or not done,              as is the case when recording the very first sector on              a track).   write data samples to the disk.  wait              for bit 8 to be set indicating end of recording.              finish writing all full sectors up to punch-out sector              before advancing state.      8   -   read data into buf1,buf2 for use by punch out routine              when all data has been read,  construct              cross fade     16   -   write out data resulting from cross fade.  clean              up recording process when that is done *//* handy routine to zero out variables after *//* recording                                 */Clean.Up.After.Recording: proc(track#);   dcl track#   fixed;   track.recording(track#) = 0;        track.punch    (track#) = 0;        if Synclav.software.version >= 3   then get.new.motion = get.new.motion \ 2;   recorded.tracks   = recorded.tracks \ bits(track#);end Clean.Up.After.Recording;/* See how much data has come in the ADC that we can write *//* to disk.   If doing DDT input,  then limit this amount  *//* by the amount of DDT data that we have actually         *//* copied into poly memory:                                */Compute.Recording.Data.Available: proc (track#);   dcl (i,j)  fixed;   dcl track# fixed;   i = (max.s#.lsb(track#) - rec.s#.lsb(track#)); /* # of samples taken */   if  (Correct.DDT.Sync       <> 0) /* if we should correct for delay */   and (track.sampling(track#) =  2) /* and doing DDT input            */   then do;      j = ddt.in.s#.lsb(track.rvoice#(track#)) - rec.s#.lsb(track#) - ddt.monitor.delay;      if j  <  0 then j = 0;         /* could be minus if zero filling */      if j ILT i then i = j;         /* limit available to that amount */   end;   else if track.sampling(track#)=4  /* else if doing multi track DDT  */   then do;                          /* than see how much has come in  */      j = track.ddt.lsb(track#) - rec.s#.lsb(track#);      if  ((track.ddt.msb(track#) ILT rec.s#.msb(track#)))      or  ((track.ddt.msb(track#)  =  rec.s#.msb(track#))      and  (track.ddt.lsb(track#) ILT rec.s#.lsb(track#)))      then j = 0;      if j ILT i then i = j;         /* limit available to that amount */   end;   return i;end Compute.Recording.Data.Available;track.recording.check:proc(port#,track#);   dcl (port#,track#,i,j,k,l) fixed;   /* declare i,j in order */   restore.priority: proc;      /* give priority to this track to fixed */                                /* max trax bounce data rate bugs       */      port.toggle(port#) = track# & (tracks.per.port-1);   end restore.priority;   /* begin recording by waiting for enough samples */   /* to construct punch-in cross fade              */   if  ((track.punch(track#)&1)<>0)    /* wait for data then punch in  */   then do;      /* make sure enough samples for */      /* punch in are sitting in      */      /* playback disk buffer         */      if zap.buffer(track#)<>0 then do;   /* trash contents     */         buf1.len  (track#)=0;            /* on change from cue */         buf2.len  (track#)=0;            /* to source playback */         buf3.len  (track#)=0;         clob.len  (track#)=0;         track.eof (track#)=0;            /* or other cases     */         zap.buffer(track#)=0;      end;      if track.eof(track#)=0              /* fill read buffers if */      then do;                            /* not at eof           */         i=recb.msb(track#);                    /* compute sample address */         j=recb.lsb(track#)+shl(buf.len,8);     /* of next buffer         */         if (buf.len=256)\(j ilt (shl(buf.len,8)))         then i=i+1;         /* check for shifting buf2 to buf1 here: */         if  (buf1.msb(track#) <> recb.msb(track#))  /* buf1 does not come */         or  (buf1.lsb(track#) <> recb.lsb(track#))  /* from right place   */         then do;                                    /* on disk            */            /* scroll forward if buf2 */            /* contains the data:     */            if  (buf2.msb(track#) = recb.msb(track#))            and (buf2.lsb(track#) = recb.lsb(track#))            and (buf2.len(track#) <> 0              )            then do;               buf1.msb(track#)=buf2.msb(track#);               buf1.lsb(track#)=buf2.lsb(track#);               buf1.len(track#)=buf2.len(track#);               buf2.msb(track#)=i;   /* set up empty buf2 */               buf2.lsb(track#)=j;   /* from the correct  */               buf2.len(track#)=0;   /* place.            */               clob.len(track#)=0;            end;            else do;               buf1.msb(track#) = recb.msb(track#);               buf1.lsb(track#) = recb.lsb(track#);               buf1.len(track#) = 0;            end;         end;         if  (buf2.msb(track#) <> i)  /* buf2 does not come */         or  (buf2.lsb(track#) <> j)  /* from right place   */         then do;                     /* on disk            */            buf2.msb(track#) = i;            buf2.lsb(track#) = j;            buf2.len(track#) = 0;         end;         if  (buf1.len(track#)<>buf.len)  /* buf2 is empty until buf1 is full */         and (buf2.len(track#)<>0      )         then buf2.len(track#)=0;         /* compute sector numbers relative to recb.msb,recb.lsb */         /* where we will need punch-in source data              */         k=shr(rec.s#.lsb(track#)-recb.lsb(track#),8); /* start of punch in */         l=k + shr(track.plen(track#)+511,8);          /* end of punch in   */         if buf1.len(track#) < k     /* pretend buf1 is filled up to point before */         then buf1.len(track#) = k;  /* cross fade, since we do not need the data */         /* read more data from disk if some is needed for the */         /* punch in.   this happens when doing immediate      */         /* cue recording                                      */         if (buf1.len(track#)+buf2.len(track#) < l)         then do;            if buf1.len(track#)<>buf.len   /* fill buf1 with data */            then do;               /* issue disk read command to fill */               /* buf1:                           */               if l > buf.len then i=buf.len-buf1.len(track#);               else                i=l-buf1.len(track#);;               port.io       (port#)=2;            /* read desired  */               port.io.track#(port#)=track#;       /* this track #  */               port.io.buf#  (port#)=1;            /* into this buf */               port.io.len#  (port#)=i;            /* for this len  */               call start.port.io(port#);          /* start it      */               call restore.priority;              /* come back     */               return;                             /* immediately   */            end;            /* issue disk read command to fill */            /* buffer #2                       */            i=l-buf1.len(track#)-buf2.len(track#);            port.io       (port#)=2;            /* read          */            port.io.track#(port#)=track#;       /* this track #  */            port.io.buf#  (port#)=2;            /* into this buf */            port.io.len#  (port#)=i;            /* for this len  */            call start.port.io(port#);          /* start it      */            call restore.priority;              /* come back     */            return;                             /* immediately   */         end;      end;      /* See how much data has come in the ADC that we can write */      /* to disk.   If doing DDT input,  then limit this amount  */      /* by the amount of DDT data that we have actually         */      /* copied into poly memory:                                */      i = Compute.Recording.Data.Available(track#);      if  ((track.punch(track#)&8)=0)   /* if not time to punch out yet */      then do;                          /* then wait for enough samples */         j=track.plen(track#);          /* look up sampled fade len  */         if (i ile (j+256+256+j))       /* leave room for punch in,  */         then return;                   /* 1 sector, 1 sector, p out */         call punch.in(track#,j);       /* perform punch in          */         track.punch(track#)=track.punch(track#) xor 3;  /* write punch */         track.eof  (track#)=0;                          /* in data to  */      end;                                               /* disk        */      else do;                         /* end of recording - must punch in with what we have */         if i ilt (512+1+1) then do;       /* did not record enough  */            call Clean.Up.After.Recording(track#);            return;                        /* in playback buffer     */         end;         j=track.plen(track#);             /* assume enough data is available for splice         */         if (i ile (j+j+512))          /* if not,  must construct smaller cross fade */         then j=shr(i-512,1);         call punch.in(track#,j);      /* perform punch in             */         track.punch(track#)=track.punch(track#) xor 3;  /* write punch */         track.eof  (track#)=0;      end;   end;      /* now write punch in cross fade data */   /* from disk buffer out to disk:      */   if  ((track.punch(track#)&2)<>0)    /* write data from punch in  */   then do;                            /* out to disk               */      if  ((track.eof(track#))=0)      /* if not at eof yet         */      and (piolen(track#)    <>0)      /* more punch-in data must   */      then do;                         /* be written out            */         i=piolen(track#);             /* get sectors left to write */         port.io       (port#)=3;             /* write desired  */         port.io.track#(port#)=track#;        /* this track #   */         port.io.len#  (port#)=i;             /* for this len   */         call start.port.io(port#);           /* start it       */         call restore.priority;               /* come back now  */         if (track.eof(track#))<>0            /* eof reached    */         then call log.proj.eof.error;         return;      end;      piolen(track#)=0;       /* clean up in case of eof */      track.punch(track#)=track.punch(track#) xor 6;   end;   /* basic recording - record here until */   /* punch out is desired                */   if  ((track.punch(track#)&4)<>0)    /* basic recording */   then do;      if track.eof(track#)=0           /* keep writing as long */      then do;                         /* as eof not reached   */         i = Compute.Recording.Data.Available(track#);         if (i ige (track.plen(track#)+1024))        /* more than enough for punch out */         then do;            i=shr(i-track.plen(track#)-512,8);   /* get # of sectors to write */            port.io       (port#)=3;             /* write desired  */            port.io.track#(port#)=track#;        /* this track #   */            port.io.len#  (port#)=i;             /* for this len   */            call start.port.io(port#);           /* start it       */            if (track.punch(track#)&8)<>0        /* if punch out pending */            then call restore.priority;          /* then return here now */            if (track.eof(track#))<>0            /* if eof reached       */            then call log.proj.eof.error;            return;         end;      end;      if (track.punch(track#)&8)=0     /* still recording - just */      then return;                     /* wait for enough data   */      /* end of recording desired */      i=(max.s#.lsb(track#)-rec.s#.lsb(track#)); /* number of words yet to be written */      if i<(256+1) then do;            /* will only happen if no punch-in */         call Clean.Up.After.Recording(track#);         return;                       /* recording right now             */      end;      /* set up for read of punch out data.  pretend the   */      /* buffer is full up to the point where we need it.  */      /* use regular read routine to fill buffer           */      buf1.msb(track#)=recb.msb(track#);      /* compute buffer info as if */      buf1.lsb(track#)=recb.lsb(track#);      /* we were reading.  read    */      buf2.msb(track#)=buf1.msb(track#);      /* data for punch in area    */      buf2.lsb(track#)=buf1.lsb(track#)+shl(buf.len,8);      if (buf2.lsb(track#) ilt (shl(buf.len,8)))      or (buf.len=256)      then buf2.msb(track#)=buf2.msb(track#)+1;      buf1.len(track#)=shr(rec.s#.lsb(track#)-recb.lsb(track#),8);  /* sector # in buffer where data sits */      buf2.len(track#)=0;      track.eof(track#)=0;                /* retry again even if eof reached during read (happens if punching towards end of track) */      track.punch(track#)=track.punch(track#) xor 4;  /* turn off 4 bit.  8 bit is already set */   end;   /* read in data to construct cross fade */   if ((track.punch(track#)&8)<>0)    /* read in data for cross fade */       then do;                    i=(max.s#.lsb(track#)-rec.s#.lsb(track#)); /* number of words yet to be written             */      i=(shr(i+255,8));                          /* number of sectors of cross fade data to write */      j=(rec.s#.lsb(track#)-recb.lsb(track#));   /* word # in buffer where data sits */      j=(shr(j    ,8));                          /* sector # */      i=i+j;                                     /* # of sectors we must have in buf1 and buf2 */      if  ((buf1.len(track#)+buf2.len(track#))<i)      and (track.eof(track#)=0)      then do;                                  /* must issue more disk reads to fill them */         if buf1.len(track#)<buf.len         then do;                               /* read data into buf1 */            if i>buf.len then i=buf.len;        /* stop at buffer end */            port.io       (port#)=2;            /* read desired  */            port.io.track#(port#)=track#;       /* this track #  */            port.io.buf#  (port#)=1;            /* into this buf */            port.io.len#  (port#)=i-buf1.len(track#);            call start.port.io(port#);          /* start it      */         end;         else do;                               /* buf2          */            port.io       (port#)=2;            /* read          */            port.io.track#(port#)=track#;       /* this track #  */            port.io.buf#  (port#)=2;            /* into this buf */            port.io.len#  (port#)=i-buf1.len(track#)-buf2.len(track#);            call start.port.io(port#);          /* start it      */         end;         call restore.priority;                 /* come back     */         return;                                /* immediately   */      end;      /* make sure enough DDT data has been transferred to input */      /* buffer to accommodate the cross fade                    */      /* provide time out timer on punch out waiting here        */      /* in case ddt word clock becomes disconnected             */      i = Compute.Recording.Data.Available(track#);      if  (i <> (max.s#.lsb(track#)-rec.s#.lsb(track#)))      and (real.milliseconds < punch.time(track#) + 200)      then return;      /* construct cross fade punch out */      /* note: rec.s#.lsb is on a sector boundary here since we */      /* have done the punch in.                                */      /* max.s#.lsb may not be on a sector boundary, however    */      call punch.out(track#,track.plen(track#)); /* compute cross fade  */      track.eof(track#)=0;             /* reset for write     */      track.punch(track#)=track.punch(track#) xor 24;   end;   if  ((track.punch(track#)&16)<>0)    /* write data from punch out */   then do;                             /* out to disk               */      if  ((track.eof(track#))=0)      /* if not at eof yet         */      and (piolen(track#)    <>0)      /* more punch-in data must   */      then do;                         /* be written out            */         i=piolen(track#);             /* get sectors left to write */         port.io       (port#)=3;             /* write desired  */         port.io.track#(port#)=track#;        /* this track #   */         port.io.len#  (port#)=i;             /* for this len   */         call start.port.io(port#);           /* start it       */         if (track.eof(track#))<>0            /* eof reached    */         then call log.proj.eof.error;         call restore.priority;               /* come back     */         return;                              /* immediately   */      end;      piolen(track#)=0;       /* clean up in case of eof */      /* done recording on track */      /* clean up variables:     */      call Clean.Up.After.Recording(track#);      track.toss(track#)=1;            /* toss data on next termination,  since we did not really load all the buffer */            /* compute max # of seconds */      bitmsb = rec.s#.msb   (track#);  /* get sample # last written */      bitlsb = rec.s#.lsb   (track#);  /* lsb                       */      if (source.or.cue(track#)<>0)    /* if mapped playback  then get use info assuming mapping occurred correctly */      then do;         call SUB32(BIT, Sync.Point.Used.Trig, BIT);         call ADD32(BIT, Sync.Point.Used.Disk, BIT);      end;      call SHR32(Bit, 8);    /* get sector # from sample # */      call update.song.and.track.used(track#);  /* update used from sector # = bitmsb, bitlsb */   end;end track.recording.check;