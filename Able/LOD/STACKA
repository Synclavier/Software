/* STACKA - routines for cue allocate recording,  real time segment stack *//* 08-15-91 - cj - Improved track routing ability for Lucas       *//* 07-29-91 - cj - Set control bits for DSP add on                *//* 06-21-91 - cj - Allowed audition cue to overrided 'input' mode *//* The following commands are used to perform "cue" recording.   Cue recording allows the user to construct a 'mapping' between   the sequencer time and where on the disk the data is recorded *//* auto allocate:   used to find the first available time on the   disk in the current song.       scsi.ptr(0) = 30        auto allocate code        scsi.ptr(1) =  0        to use 'ready' tracks                   <> 0        track bits specified       scsi.ptr(2) = 0;        spares.  must be zeroes.       scsi.ptr(3) = 0;       scsi.ptr(4) = 0;       scsi.ptr(5) = 0;       scsi.ptr(6) = 0;       scsi.ptr(7) = 0;       send.to.lod(144,16);   if dtd.cue# <> 0 after send.to.lod,  then the following information   has been returned       scsi.ptr(0) = synclavier time msb where to start recording       scsi.ptr(1) = synclavier time lsb where to start recording       scsi.ptr(2) = synclavier time msb of end of song       scsi.ptr(3) = synclavier time lsb of end of song   *//* initiate cue recording:   this command is used to initiate a cue   recording take.       scsi.ptr(0) =  0      means start recording immediately.                             if sequencer is playing then sample rate                             is controlled externally, otherwise                             internal sync is used.                   =  1      means wait for the synclavier sequencer                             to reach a certain point before starting                             to record.   Error condition results if                             sequencer is already playing >= punch in                             point.       scsi.ptr(1) =  synclavier sequencer time msb at which to                      start recording (only used if scsi.ptr(0)=1)       scsi.ptr(2) =  synclavier sequencer time lsb at which to                      start recording       scsi.ptr(3) =  0      means destination on disk is an already                             defined cue                   =  1      means destination on disk is a disk                             address that corresponds to a synclavier                             sequence time       ****************      PROBLEMS WITH PUNCH IN AT THE CURRENT TIME       scsi.ptr(4) =  0      for butt splice (no punch in/out)                   =  1      perform punch in/out as per crossfade                             time.       ****************      ALWAYS SET = 1 (I THINK)       scsi.ptr(5) =  cue id # if scsi.ptr(3) = 0.                      synclavier sequence time msb of disk address to                      start recording at if scsi.ptr(4) = 1; fade out                      starts here       scsi.ptr(6) =  synclavier sequence time lsb of disk address to                      start recording at       scsi.ptr(7) =  synclavier sequence time msb of disk address to                      stop recording at (fade out starts here)       scsi.ptr(8) =  synclavier sequence time lsb of disk address to                      stop recording at       scsi.ptr( 9) = 0;       scsi.ptr(10) = 0;       scsi.ptr(11) = 0;       scsi.ptr(12) = 0;       scsi.ptr(13) = 0;       scsi.ptr(14) = 0;       scsi.ptr(15) = 0;       call send.to.lod(135,32);   */dcl (recrec)        (recrec.size-1)  fixed PUBLIC; /* holds record record          */dcl (armed)                          fixed PUBLIC; /* true if armed for recording  */dcl (stackedrecrec) (recrec.size-1)  fixed PUBLIC; /* holds copy if new record record that came in during prior guy's punch out */dcl (recrec.is.stacked)              fixed PUBLIC;/* Sync.Point.Disk and Sync.Point.Trig are used to save away *//* the disk address and trigger time of when recording began *//* This info is later used by the AEE to establish the       *//* sync point for an auto allocate cue                       */dcl Sync.Point.Disk     (1) fixed PUBLIC;   /* disk sampl # (sector bound) */ dcl Sync.Point.Trig     (1) fixed PUBLIC;   /* trig sampl # (sector bound) *//* Duplicate information is needed to establish the *//* amount of used recording time correctly          */dcl Sync.Point.Used.Disk     (1) fixed PUBLIC;   /* disk sampl # (sector bound) */ dcl Sync.Point.Used.Trig     (1) fixed PUBLIC;   /* trig sampl # (sector bound) *//* $page - variables for real time playback of cues */dcl source.or.cue    (max.tracks-1) fixed PUBLIC;  /* 0 = source playback */                                                   /* 1 = cue    playback */                                                   /* 2 = src    playback after end of cue that got triggered while in source playback mode */dcl any.cues.stacked (max.tracks-1) fixed PUBLIC;dcl audit.cue.stacked(max.tracks-1) fixed PUBLIC;dcl record.cue.ptr   (max.tracks-1) fixed PUBLIC;dcl ff.speed                        fixed PUBLIC;  /* speed for loop ff/rew */dcl Scroll.S#      (1)   fixed PUBLIC;   /* sample # for scrolling base    */dcl Scroll.Base    (1)   fixed PUBLIC;   /* base sample #                  *//* These variables are set whenever changes are made in the data structure *//* so that the real time software that writes the data to the voices can   *//* be optimized:                                                           */dcl New.Cur.Env           fixed PUBLIC;  /* new cur.env.val set            */dcl New.Seg.List          fixed PUBLIC;  /* new block linked to seg list   */dcl New.Env.List          fixed PUBLIC;  /* new block linked to env list   *//* data storage literals *//* Internal memory working copy of Segment Record: */dcl Seg.Fptr     fixed PUBLIC;dcl Seg.Bptr     fixed PUBLIC;dcl Seg.Exists   fixed PUBLIC;   /* holds working copy of segment.     */dcl Seg.Sync (1) fixed PUBLIC;   /* must declare in order!!            */dcl Seg.Disk (1) fixed PUBLIC;;dcl Seg.End  (1) fixed PUBLIC;dcl Seg.Info     fixed PUBLIC;dcl Seg.Time (1) fixed PUBLIC;dcl Seg.Track    fixed PUBLIC;/* Internal memory working copy of Envelope Record: */dcl Env.Fptr     fixed PUBLIC;dcl Env.Bptr     fixed PUBLIC;dcl Env.Sync (1) fixed PUBLIC;   /* must declare in order!!            */dcl Env.Len  (1) fixed PUBLIC;dcl Env.Send (1) fixed PUBLIC;dcl Env.Sval     fixed PUBLIC;dcl Env.Adder    fixed PUBLIC;dcl Env.Delta    fixed PUBLIC;dcl Env.Limit    fixed PUBLIC;gseg.info: proc(ptr) PUBLIC;     /* set up mam & mal ptrs for seg stk  */   dcl ptr fixed;   write(mam) = cseg.xmsec# + shr(ptr,8);   write(mal) = ptr;   return read(md);              /* read and return value              */end gseg.info;dcl genv.info lit 'gseg.info';   /* use same routine for now           *//* Read.Seg.Stack reads in the entire record into the global           *//* variables.                                                          */read.seg.stack: proc(ptr) PUBLIC;  /* read in words from seg stack     */   dcl ptr fixed;   call gseg.info(ptr);            /* set up mam & mal                 */   write("313") = addr(Seg.Fptr);   rpc Seg.Record.Size;   write("373") = read(mdi);end read.seg.stack;read.env.stack: proc(ptr) PUBLIC;  /* read in words from env stack     */   dcl ptr fixed;   call genv.info(ptr);            /* set up mam & mal                 */   write("313") = addr(Env.Fptr);   rpc Env.Record.Size;   write("373") = read(mdi);end read.env.stack;/* Write.Seg.Stack writes Seg.Exists - Seg.Time out to external        *//* memory.                                                             */write.seg.stack: proc(ptr) PUBLIC;  /* write out words to seg stack    */   dcl ptr fixed;   call gseg.info(ptr + Seg.Exists.Loc);  /* set up mam & mal          */   write("313") = addr(Seg.Exists);   rpc Seg.Record.Size - Seg.Exists.Loc;   write(mdi) = read("373");end write.seg.stack;write.env.stack: proc(ptr) PUBLIC;  /* write out words to env stack    */   dcl ptr fixed;   call genv.info(ptr + Env.Sync.Loc);    /* set up mam & mal          */   write("313") = addr(Env.Sync(0));   rpc Env.Record.Size - Env.Sync.Loc;   write(mdi) = read("373");end write.env.stack;/* Free Storage:   Free Segment Records are linked on to the following *//* list:                                                               */dcl Seg.Free.Ptr  fixed  PUBLIC;dcl Seg.Free.Last fixed  PUBLIC;dcl Env.Free.Ptr  lit 'Seg.Free.Ptr';dcl Env.Free.Last lit 'Seg.Free.Last';Get.Segment.Record: proc PUBLIC;   /* routine to get a segment record */   dcl i fixed;                    /* returns pointer to block        */   if Seg.Free.Ptr = 0             /* if no storage, then quit        */   then return 0;   i = Seg.Free.Ptr;               /* save pointer to first block on  */   Seg.Free.Ptr = gseg.info(i);    /* list.   Advance pointer.        */   if Seg.Free.Ptr = 0             /* clear last pointer if list is   */   then Seg.Free.Last = 0;         /* now empty.                      */      return i;end Get.Segment.Record;Release.Segment.Record: proc(ptr) PUBLIC;  /* release a record        */   dcl ptr  fixed;   /* put the free block on the front of the free list:               */   call gseg.info(ptr);           /* set up mam, mal            */   write(md) = Seg.Free.Ptr;      /* store fptr in this block   */   if Seg.Free.Ptr = 0            /* if this is last on list,   */   then Seg.Free.Last = ptr;      /* save pointer to it         */   Seg.Free.Ptr = ptr;            /* set new free pointer       */end Release.Segment.Record;/* routine to link a block into a list for a track:             */Link.In.Segment.Record:proc (qptr, blockptr) PUBLIC;   dcl qptr     fixed;        /* pass current pointer in cue    */   dcl blockptr fixed;        /* and pointer to free block      */   dcl i        fixed;   i = gseg.info(qptr);       /* look up current forward ptr    */   write(md) = blockptr;      /* set pointer to new block       */   call gseg.info(blockptr);  /* set up mam & mal to new block  */   write(mdi) = i;            /* set its forward ...            */   write(md ) = qptr;         /* ... and reverse pointer        */   call gseg.info(i+1);       /* and set up back pointer in     */   write(mdi) = blockptr;     /* next block                     */end Link.In.Segment.Record;UnLink.Segment.Record:proc (blockptr) PUBLIC;   dcl blockptr fixed;        /* pass current block pointer     */   dcl i        fixed;   dcl j        fixed;   call gseg.info(blockptr);  /* look up forward and backwards  */   i = read(mdi);             /* pointer from this block        */   j = read(md );   call gseg.info(j);         /* point to previous block        */   write(md) = i;             /* set its forward pointer        */   call gseg.info(i+1);       /* point to next block            */   write(md) = j;             /* set its backwards pointer      */end UnLink.Segment.Record;dcl Get.Envelope.Record      lit 'Get.Segment.Record';dcl Release.Envelope.Record  lit 'Release.Segment.Record';dcl Link.In.Envelope.Record  lit 'Link.In.Segment.Record';dcl UnLink.Envelope.Record   lit 'UnLink.Segment.Record';/* Note: this routine cannot swap because it is called before   *//* the swap file is loaded:                                     */Initialize.Free.Seg.Records: proc PUBLIC;   dcl i fixed;   /* initialize pointers to head of list to point to themselves: */   write(mam) = cseg.xmsec#;   /* clean out head & tail pointers */   do i = 0 to 127;            /* for 128 possible que list      */      write(mdi) = shl(i,1);      write(mdi) = shl(i,1);   end;   /* create as many free blocks as we have storage for:         */   Seg.Free.Ptr  = 0;   Seg.Free.Last = 0;   i = 256;                    /* start blocks after que heads   */   do while (i + Seg.Record.Size) ILE (shl(cseg.xmsiz#, 8));      call Release.Segment.Record(i);      i = i + Seg.Record.Size;   end;end Initialize.Free.Seg.Records;dcl cue.read.ptr  (max.tracks-1) fixed PUBLIC;  /* pointer for reading stack    */dcl cue.rt.ptr    (max.tracks-1) fixed PUBLIC;  /* real time cue read pointer   */                                                /* for dynamic output allocation */                                                /* also used during data         */                                                /* function reading.             */clear.playback.cue.stack: proc(track#) PUBLIC;   dcl track# fixed;   cue.read.ptr      (track#) = 0;   cue.rt.ptr        (track#) = 0;   any.cues.stacked  (track#) = 0;   audit.cue.stacked (track#) = 0;   New.Seg.List              = 1;   /* link any blocks on this track back on to the free list   */   write(mam) = cseg.xmsec#;   write(mal) = shl(track#, 1);   Seg.Fptr   = read(md);       /* get forward & backward ptrs */   write(mdi) = shl(track#, 1); /* and zero them out           */   Seg.Bptr   = read(md);   write(mdi) = shl(track#, 1);   if Seg.Fptr <> shl(track#,1) then do; /* free up if any     */      /* put the free blocks for this track on the end of      */      /* the free list.                                        */      call gseg.info(Seg.Bptr);  /* zero out circular forward  */      write(md) = 0;             /* ptr in last block since    */                                 /* free list is not circular  */      if Seg.Free.Ptr <> 0 then do;         call gseg.info(Seg.Free.Last);         write(md) = Seg.Fptr;      end;      else Seg.Free.Ptr = Seg.Fptr;      Seg.Free.Last = Seg.Bptr;   end;end clear.playback.cue.stack;  clear.all.playback.cue.stacks: proc PUBLIC swapable;   dcl track# fixed;   do track#=0 to max.tracks-1;      call clear.playback.cue.stack(track#);   end;   recrec(recrec.stacked) = 0;end clear.all.playback.cue.stacks;/* $page - set up for source or cue playback *//* routines to clear,set,or look up source.or.cue playback */clear.all.source.or.cues: proc PUBLIC swapable;   dcl i fixed;   do i=0 to max.tracks-1;      if source.or.cue(i)<>0 then do;         zap.buffer(i)=1;         call clear.playback.cue.stack(i);       end;      source.or.cue(i)=0;   end;end clear.all.source.or.cues;;set.all.source.or.cues: proc PUBLIC swapable;   dcl i fixed;   do i=0 to max.tracks-1;      if source.or.cue(i)=0 then do;         zap.buffer(i)=1;         call clear.playback.cue.stack(i);       end;      source.or.cue(i)=1;   end;end set.all.source.or.cues;;lookup.this.source.or.cue:proc(track#) PUBLIC swapable;   dcl track# fixed;   dcl j      fixed;   dcl k      fixed;   j=track# * track.len;   k=shr(track.dir(j+track.stat),8);   /* look up t.ria */   if k=3 then do;                     /* cue pb        */      if source.or.cue(track#)=0 then do;         zap.buffer(track#)=1;         call clear.playback.cue.stack(track#);       end;      source.or.cue(track#)=1;   end;   else do;                            /* repro/inp/aut */      if source.or.cue(track#)<>0 then do;         zap.buffer(track#)=1;         call clear.playback.cue.stack(track#);       end;      source.or.cue(track#)=0;   end;end lookup.this.source.or.cue;lookup.all.source.or.cues:proc PUBLIC swapable;   dcl i fixed;   dcl j fixed;   dcl k fixed;   do i=0 to max.tracks-1;      call lookup.this.source.or.cue(i);   end;end lookup.all.source.or.cues;;/* $page - routines for envelope records *//* the following routines are used to manage records that *//* are linked to the envelope cues for each track.        *//* subroutine to perform 32-bit interpolation of envelope segment:      */Interpolate.Envelope.Segment: proc(sval, dval, percent, length) PUBLIC;   dcl sval    fixed;         /* starting segment value,  0 - 4095      */   dcl dval    fixed;         /* ending   segment value,  0 - 4095      */   dcl percent array;         /* # of samples into segment              */   dcl length  array;         /* segment length,  samples               */   dcl b(1)    fixed;   dcl c(1)    fixed;   dcl i       fixed;   dcl j       fixed;   if sval = dval             /* no interpolation needed                */   then return sval;          /* if horizontal segment                  */   call COPY32(percent, B);   /* get working copies of percent and      */   call COPY32(length,  C);   /* length we can change                   */   i = b(0) \ c(0);           /* get magnitude of segment length        */   j = 0;   if i < 0 then do;          /* perform fast shr32(x,16)               */      b(1) = b(0);            /* if all 32 bits are used                */      c(1) = c(0);   end;   else if i <> 0 then do;    /* else if any MSB's used, shift right    */      do while i <> 0;        /* so we can use 16-bit match.            */         i = shr(i,1); j = j + 1;      end;      call SHR32(b,j);        /* now perform long shifts quickly        */      call SHR32(c,j);   end;   /* Now scale the value using linear interpolation:                   */   if dval ILT sval           /* headed down.                           */   then do;      load (sval - dval);     /* get difference                         */      mul b(1);  mwait;       /* scale by ratio                         */      div c(1);      return (sval - res);    /* this is interpolated value             */   end;   else do;                   /* headed up.                             */      load (dval - sval);     /* get difference                         */      mul b(1);  mwait;       /* scale by ratio                         */      div c(1);      return (sval + res);   end;end Interpolate.Envelope.Segment;/* Find.Envelope.Value scans the list for a given track   *//* and finds the envelope value for the track at that     *//* time.  It also sets up the variables "Found.Point.Was  *//* Mid.Segment" (etc) if the point was in the middle of   *//* an existing envelope segment.   This makes it easy     *//* to punch a new envelope over the middle of another     *//* one.                                                   */dcl cur.env.val (max.tracks-1)    fixed PUBLIC;dcl Found.Point.Was.Mid.Segment   fixed PUBLIC;dcl Found.Point.Was.At.End        fixed PUBLIC;dcl Found.Point.Length  (1)       fixed PUBLIC;dcl Found.Point.Limit             fixed PUBLIC;Find.Envelope.Value: proc(track#, time) PUBLIC;   dcl track#     fixed;    /* pass track#                */   dcl time       array;    /* pass sample time           */   dcl i          fixed;   dcl tmp(1)     fixed;   i = genv.info(Env.Cue.Heads + shl(track#,1) + 1); /* point to last blk  */   Found.Point.Was.Mid.Segment = 0;                  /* assume no segmnt   */   Found.Point.Was.At.End      = 1;                  /* assume was at end  */   next.env:;   if i = Env.Cue.Heads + shl(track#,1)     /* if back to start of list,   */   then return cur.env.val(track#);         /* then use cur.env.val        */   call read.env.stack(i);                  /* get this record handy       */   if COM32(time, Env.Sync) <= lw#ieq       /* if at or before this, check */   then do;                                 /* segments                    */      Found.Point.Was.At.End = 0;           /* this point not at end       */      i = Env.Bptr;                         /* go back to check prior one  */      goto next.env;   end;   if COM32(time, Env.Send) >= lw#ieq       /* if after end of this        */   then return Env.Limit;                   /* segment,  this will be val  */                                            /* may or may not be at end.   */   Found.Point.Was.Mid.Segment = 1;                /* mid-segment          */   Found.Point.Was.At.End      = 0;                /* not at end of list   */   call SUB32(Env.Send, time, Found.Point.Length); /* save remainder       */   Found.Point.Limit           = Env.Limit;        /* and it's limit       */   call SUB32(time, Env.Sync, tmp);           /* get length into segment   */   return Interpolate.Envelope.Segment        /* and interpolate to value  */          (Env.Sval, Env.Limit, tmp, Env.Len);/* at that point.            */end Find.Envelope.Value;/* The following routine is a faster routine that just checks the          *//* first envelope segment.   It is used when turning voices on and off     */Quickly.Find.First.Envelope.Value: proc(track#, time) PUBLIC;   dcl track#     fixed;    /* pass track#                */   dcl time       array;    /* pass sample time           */   dcl i          fixed;   dcl tmp(1)     fixed;   write(mam)  = cseg.xmsec#;                     /* point to head         */   write(mal)  = (Env.Cue.Heads + shl(track#,1)); /* for this track        */   if read(md) = (Env.Cue.Heads + shl(track#,1))  /* if cue is empty, then */   then return cur.env.val(track#);               /* use cur.env.val       */   call read.env.stack(read(md));                 /* else get info handy   */   i = COM32(time, Env.Sync);                     /* get time relationship */   if i = lw#ilt                                  /* if time is before     */   then return cur.env.val(track#);               /* seg, use cur.env.val  */   if i = lw#ieq                                  /* if at precise start   */   then return Env.Sval;                          /* then use start value  */   if COM32(time, Env.Send) >= lw#ieq             /* if past end of seg,   */   then return Env.Limit;                         /* return dest value     */   call SUB32(time, Env.Sync, tmp);               /* get length into seg   */   return Interpolate.Envelope.Segment        /* and interpolate to value  */          (Env.Sval, Env.Limit, tmp, Env.Len);/* at that point.            */end Quickly.Find.First.Envelope.Value;/* Place.Envelope.Segment is used to place a volume envelope segment  *//* in the segment list for a particular track.                        */Place.Envelope.Segment: proc(track#, time, sval, length, dval) PUBLIC;   dcl track#   fixed;      /* pass track#                            */   dcl time     array;      /* pass sample time to start segment at   */   dcl sval     fixed;      /* starting value                         */   dcl length   array;      /* length of crossfade,  in samples       */   dcl dval     fixed;      /* destination value, 0 - 4095            */   dcl sectors       fixed;   dcl DA4           fixed;   dcl adder         fixed;   dcl delta         fixed;   dcl (i,j)    fixed;   /* Basic process:  use accumulator oscilator (PSEACU) and envelope delta */   /* (PSEDEL) to control rate.   Accumulator rate is added to accumulator  */   /* every 40 microseconds.   Whenever carry occurs,  the current value    */   /* is moved towards the limit by the delta amount.                       */   /* if Current.Rate = KHZ*10    (500 = 50 khz)                            */   /* sval            = starting envelope valur (0-4095)                    */   /* dval            = destination envelope value (0 - 4095)               */   /* sectors         = sector length of segment (sector = 256 samples)     */   /* formula ==>  delta*adder = (16/250) * (sval-dval)*current.rate/sectors*/   /* for compatibility with 16-bit math,  we will compute delat*adder/4.   */   if length(0) IGE 256              /* compute length of segment in      */   then sectors = (-1);              /* sectors                           */   else sectors = shl(length(0), 8) \ shr(length(1), 8);   if (sectors = 0   )               /* for 0 millisecond attack/decay,   */   or (sval    = dval)               /* or for horizontal segment         */   then do;      adder = 4095; delta = 64;      /* use 2.4 millisecond               */   end;   else do;                          /* else compute                      */      i = current.rate;              /* start with current rate           */      /* Scale current rate for smpte tracking                            */      if  (now.playing <> 0)         /* if actually playing now           */      and (smpte.onoff <> 0)         /* and using smpte syncing           */      and (smpte.track.rate ILT smpte.mode.rate)      then do;                           /* scale for smpte speed    */         load i;                         /* start with current rate  */         mul smpte.track.rate; mwait;    /* times tracking rate      */         div smpte.mode.rate;            /* divide by mode rate      */         i = res;                        /* yields effective rate    */         if rem<>0 then i = i + 1;       /* always make segment      */      end;                               /* shorter than needed.     */      if sectors ILT 512 then do;    /* for small sectors, is easy:       */         load sectors; mul 125;      /* compute 125 * sectors             */         j = res;                    /* without overflow                  */         load shl(abs(sval-dval),1); /* get 2*(sval-dval)*current.rate    */         mul i; mwait;         div j;                      /* /125/sectors                      */         DA4 = res;         if rem <> 0                 /* always round up so attack is over */         then DA4 = DA4 + 1;         /* sooner rather than later          */      end;      else do;                       /* larger sectors - divide twice     */         load shl(abs(sval-dval),1); /* get 2*(sval-dval)*current.rate    */         mul i; mwait;         div 125;                    /* /125                              */         DA4 = res;         if rem <> 0                 /* always round up so attack is over */         then DA4 = DA4 + 1;         /* sooner rather than later          */         load DA4;         div sectors;                /* /sectors                          */         DA4 = res;         if rem <> 0                 /* always round up so attack is over */         then DA4 = DA4 + 1;         /* sooner rather than later          */      end;      /* now compute delta & adder */      if DA4 = 0 then do;            /* use slowest possible attack       */         Delta = 1; Adder = 1;      end;      else do;         load DA4; div 1024;         /* compute delta to use                */         Delta = res;                /* to achieve this rate.  Use smallest */         if rem <> 0 then            /* delta that is possible (ie keep     */         Delta = Delta + 1;          /* adder as close to 4096 as possible  */         load DA4;         div Delta;         Adder = shl(res,2);         if rem <> 0         then Adder = Adder + 4;         if Adder >= 1               /* hardware wants adder - 1          */         then Adder = Adder - 1;      end;   end;   /* find point in list to insert record at.   Use a backwards search    */   /* since we normally add information to the end of the list.           */   i = genv.info(Env.Cue.Heads + shl(track#,1) + 1); /* pointer to last blk*/   if i <> (Env.Cue.Heads + shl(track#,1))  /* if block exists, see if we  */   then do;                                 /* should skip over it.        */      next.env:;                            /* re-enter to look at next    */      call read.env.stack(i);               /* get this record handy       */      j = COM32(time, Env.Sync);            /* get time relationship       */      if j = lw#ieq then do;                /* if same time,  replace      */         call COPY32(length, Env.Len);      /* seg length of segment       */         call ADD32 (time, length, Env.Send);  /* compute end time         */         Env.Sval  = sval;                  /* save starting value         */         Env.Adder = adder;                 /* save interpolator adder     */         Env.Delta = delta;                 /* and delta                   */         Env.Limit = dval;                  /* and limit                   */         call write.env.stack(i);           /* store in memory             */         return;                            /* that's all,  folks!         */      end;      if  j = lw#ilt then do;               /* if is before this block     */         if Env.Adder < 0 then do;          /* clear "written" bit         */            Env.Adder = Env.Adder & 32767;            call write.env.stack(i);         end;         i = Env.Bptr;                      /* must link in before us      */         if i <> (Env.Cue.Heads + shl(track#,1))  /* must check further    */         then goto next.env;                      /* if more blocks        */      end;      /* else if >,  then link on after this block.  Truncate the length   */      /* of this block,  and correct its limit in case we are punching     */      /* over.                                                             */      else if (COM32(time, Env.Send) = lw#ilt) /* if this new segment      */      then do;                                 /* actually cuts off an     */         call SUB32(Time, Env.Sync, Env.Len);  /* earlier segment, update  */         call COPY32(Time, Env.Send);         Env.Limit = sval;                     /* the info in it correctly */         call write.env.stack(i);              /* to simplify work later   */      end;                                     /* on.                      */   end;   /* else if que is empty,  link on to the front                          */   j = Get.Envelope.Record;              /* get a free block of storage    */   if j = 0 then return;                 /* if none, solly chollie         */   call COPY32(time, Env.Sync);          /* save time,                     */   call COPY32(length, Env.Len);         /* seg length of segment          */   call ADD32 (time, length, Env.Send);  /* compute end time               */   Env.Sval  = sval;                     /* save starting value            */   Env.Adder = adder;                    /* save interpolator adder        */   Env.Delta = delta;                    /* and delta                      */   Env.Limit = dval;                     /* and limit                      */   call write.env.stack(j);              /* store in memory                */   call Link.In.Envelope.Record(i,j);    /* link in to list                */end Place.Envelope.Segment;/* Delete.Envelope.Range is used to delete all the envelope segments       *//* that start between the two passed times.                                */Delete.Envelope.Range: proc(track#, time1, time2) PUBLIC;   dcl track#   fixed;      /* pass track#                            */   dcl time1     array;     /* pass first sample time                 */   dcl time2     array;     /* pass ending sample time                */   dcl (i,j)    fixed;   /* Scan backwards through list (for speed optimizing) and find     */   /* blocks to delete:                                               */   i = genv.info(Env.Cue.Heads + shl(track#,1) + 1); /* pointer to last blk*/   next.toss:;                              /* re-enter to look at next    */   if i <> (Env.Cue.Heads + shl(track#,1))  /* if block exists, see if we  */   then do;                                 /* should toss it.             */      call read.env.stack(i);               /* get this record handy       */      if COM32(Env.Sync, Time2) >= lw#ieq   /* if this block starts at or  */      then do;                              /* after region end,  keep it  */         i = Env.Bptr;                      /* back up to prior block      */         goto next.toss;                    /* and check it.               */      end;      if COM32(Env.Sync, Time1) >= lw#ieq   /* if this block starts        */      then do;                              /* within region,  toss it     */         j = Env.Bptr;                      /* save back pointer           */         call Unlink.Envelope.Record (i);   /* take this block off list    */         call Release.Envelope.Record(i);   /* release it to free storage  */         i = j;                             /* now look at possible prior  */         goto next.toss;                    /* block                       */      end;      /* else must keep this and all prior blocks as they are before       */      /* the region                                                        */   end;end Delete.Envelope.Range;/* Main procedure to place a complete envelope on the linked list for      *//* a given track.                                                          */Place.Envelope: proc(Track#, Time, Env);   dcl Track#    fixed;    /* track# to place envelope on                  */   dcl Time      array;    /* sync time envelope begins at                 */   dcl Env       array;    /* list of envelope segments                    */   dcl i         fixed;   dcl sval      fixed;   dcl eval      fixed;   dcl eval.point.was.mid.segment   fixed;   dcl eval.point.was.at.end        fixed;   dcl eval.point.length    (1)     fixed;   dcl eval.point.limit             fixed;   dcl EnvLen   (1)    fixed;   dcl EnvEnd   (1)    fixed;   dcl Tolerance(1)    fixed;   dcl a        (1)    fixed;   dcl rinval          fixed;   dcl routval         fixed;   dcl place.in        fixed;   dcl place.out       fixed;   dcl DelStart (1)    fixed;   dcl DelEnd   (1)    fixed;   New.Env.List = 1;       /* tell real time code of new envelope info     */   if Env(0) < 2           /* no envelope to place if null envelope        */   then return;   /* In order for the software to accurately construct the envelope       */   /* segments,  the software has to have a certain amount of time to      */   /* realize each envelope segment.   Currently, the envelope segments    */   /* are contstructed by the main loop,  and we will limit the segments   */   /* to 40 milliseconds apart at least.                                   */   /* If the envelope segments were constructed by the interrupt routine,  */   /* perhaps 5 millisecond or even 1 millisecond spacings could be        */   /* achieved.                                                            */   /* Figure out how many samples are in 40 milliseconds:                  */   Tolerance(0) = 0;   Tolerance(1) = Current.Rate*4;       /* # of samples in 40 msecs        */   /* Total up length of envelope so we can do a decent punch-over         */   call STR32(0, 0, EnvLen);            /* get ready to total up length    */   i = 1;                               /* start at top of list            */   do while (i + ESegStride) < Env(0);  /* add up all the lengths          */      call ADD32(EnvLen, loc(addr(Env(i + ESegLen))), EnvLen);      i = i + ESegStride;   end;   call ADD32(Time, EnvLen, EnvEnd);    /* get actual end time             */   /* Important optimization:  in order to keep hundreds of unnecessary    */   /* blocks being allocated for simple cue triggers,  optimize & combine  */   /* blocks when possible.                                                */   /* See if the envelope we need to place is a straight line              */   /* envelope (horizontal).  If so,  see if we can extend an earlier      */   /* envelope segment to incorporate this range.                          */   if (Env(0) = 2)                      /* if simple point value           */   or ((Env(0) = (2 + ESegStride))      /* or horizontal line              */   and (Env(1 + ESegSval) = Env(1 + ESegDval)))   then do;      i = genv.info(Env.Cue.Heads + shl(track#,1) + 1); /* point to end    */      next.skip:;                              /* re-enter to look at next */      if i <> (Env.Cue.Heads + shl(track#,1))  /* if we are pointing to    */      then do;                                 /* any block, look at it    */         call read.env.stack(i);               /* get all info handy       */         if COM32(Env.Sync, EnvEnd) >= lw#ieq  /* if this block starts     */         then do;                              /* after end of this        */            i = Env.Bptr;                      /* envlope,  check earlier  */            goto next.skip;                    /* blocks.                  */         end;         if  (COM32(Env.Sync, Time) <= lw#ieq) /* if this block starts     */         and (Env.Sval              =  Env(1)) /* at or before our envelope*/         and (Env.Limit             =  Env(1)) /* and it is horizontal too */         then do;                              /* then extend it           */            if COM32(EnvEnd, Env.Send) = lw#igt   /* extend it only if     */            then do;                              /* needed.               */               call SUB32 (EnvEnd, Env.Sync, Env.Len );               call COPY32(EnvEnd,           Env.Send);               call write.env.stack(i);            end;            return;         end;      end;   end;   /* See what the values of the currently placed envelope are             */   /* at the start of our envelope:                                        */   call COPY32(time,   DelStart);     /* assume we must only delete the    */   call COPY32(EnvEnd, DelEnd  );     /* prior envelope info here          */   place.in = 0;                      /* assume no in-ramp is needed       */   sval = Find.Envelope.Value(Track#, Time); /* get start value            */   if  (sval <> (Env(1)  ))      /* if already-placed segments do not      */   and (sval <> (Env(1)-1))      /* create the right starting value, then  */   and (sval <> (Env(1)+1))      /* we must do so.  Allow for round off    */   then do;                      /* error though.                          */      /* if list is empty, just change current value.  Provides best       */      /* startup of triggered playback (at level = 4095 for simple         */      /* triggers, at level = 0 for triggers with fade ins)                */      write(mam)  = cseg.xmsec#;      write(mal)  = (Env.Cue.Heads + shl(track#,1));      if read(md) = (Env.Cue.Heads + shl(track#,1))      then do;         cur.env.val(track#) = Env(1);       /* start oscilator here       */         New.Cur.Env         = New.Cur.Env   /* or set it to that now      */                             \ bits(track#);      end;      else do;         place.in = 1;                          /* then will need ramp-in  */         if COM32(Tolerance, DelStart) = lw#igt /* compute time 40 msecs   */         then call STR32(0, 0, DelStart);       /* before start            */         else call SUB32(DelStart, Tolerance, DelStart);         rinval = Find.Envelope.Value(Track#, DelStart);      end;   end;   eval = Find.Envelope.Value(Track#, EnvEnd);   eval.point.was.mid.segment = Found.Point.Was.Mid.Segment;   eval.point.was.at.end      = Found.Point.Was.At.End;   call COPY32(Found.Point.Length, eval.point.length);   eval.point.limit           = Found.Point.Limit;   if  (eval.point.was.at.end  = 0 ) /* if this was not end of env list    */   and (eval <> (Env(Env(0) - 1)  )) /* and our ending value is wrong,     */   and (eval <> (Env(Env(0) - 1)+1)) /* (allow for +/- one round off       */   and (eval <> (Env(Env(0) - 1)-1)) /* error)                             */   then do;                          /* then must do ramp out              */      place.out = 1;                 /* must do ramp out                   */      call ADD32(DelEnd, Tolerance, DelEnd);      routval = Find.Envelope.Value(Track#, DelEnd);      eval.point.was.mid.segment = Found.Point.Was.Mid.Segment;      eval.point.was.at.end      = Found.Point.Was.At.End;      call COPY32(Found.Point.Length, eval.point.length);      eval.point.limit           = Found.Point.Limit;   end;   else place.out = 0;   /* Delete prior envelope segments:                                      */   call Delete.Envelope.Range(Track#, DelStart, DelEnd);   /* Now place the envelope segments that we need:                        */   if place.in <> 0 then do;           /* place a fade ot our needed       */      call SUB32(Time, DelStart, A);   /* value first, if needed           */      call Place.Envelope.Segment(Track#, DelStart, rinval, A, Env(1));   end;   /* Now place our envelope segments:                                     */   call COPY32(Time, A);   /* get start time of complete envelope          */   i = 1;                  /* start at first segment                       */   do while (i + ESegStride) < Env(0);      call Place.Envelope.Segment(Track#, A, Env(i + ESegSval),                                  loc(addr(Env(i + ESegLen))),                                  Env(i + ESegDval));      call ADD32(A, loc(addr(Env(i + ESegLen))), A);      i = i + ESegStride;   end;      /* Place an envelope to restore audio to prior value in case            */   /* more cues are stacked after us that needed that information.  Or we  */   /* might have actually 'Punched' this envelope over the middle of an    */   /* earlier one,  or even the fade in/fade out portion thereof.          */   if place.out <> 0 then do;      call Place.Envelope.Segment(Track#, A, Env(Env(0) - 1), Tolerance, routval);      if eval.point.was.mid.segment then do;         call Place.Envelope.Segment(Track#, DelEnd, routval, eval.point.length, eval.point.limit);      end;   end;   else if eval.point.was.mid.segment then do;      call Place.Envelope.Segment(Track#, A, Env(Env(0) - 1), eval.point.length, eval.point.limit);   end;end Place.Envelope;/* Procedure to free up all envelope segments for a track:                 */Clear.Envelope.List: proc(track#) PUBLIC;   dcl track# fixed;   cur.env.val(track#) = 4095;   /* envelope limit defaults to max for     */                                 /* best compatibility with earlier        */                                 /* software.                              */   New.Cur.Env  = New.Cur.Env    /* tell real time code of possible new    */                \ bits(track#);   New.Env.List = 1;             /* values here & there                    */   /* link any blocks on this track back on to the free list   */   write(mam) = cseg.xmsec#;   write(mal) = Env.Cue.Heads + shl(track#, 1);   Env.Fptr   = read(md);                       /* get forward & backward ptrs */   write(mdi) = Env.Cue.Heads + shl(track#, 1); /* and zero them out           */   Env.Bptr   = read(md);   write(mdi) = Env.Cue.Heads + shl(track#, 1);   if Env.Fptr <> Env.Cue.Heads + shl(track#,1) then do; /* free up if any     */      /* put the free blocks for this track on the end of      */      /* the free list.                                        */      call genv.info(Env.Bptr);  /* zero out circular forward  */      write(md) = 0;             /* ptr in last block since    */                                 /* free list is not circular  */      if Env.Free.Ptr <> 0 then do;         call genv.info(Env.Free.Last);         write(md) = Env.Fptr;      end;      else Env.Free.Ptr = Env.Fptr;      Env.Free.Last = Env.Bptr;   end;end Clear.Envelope.List;clear.all.envelope.lists: proc PUBLIC swapable;   dcl track# fixed;   do track#=0 to max.tracks-1;      call Clear.Envelope.List(track#);   end;   if enabled.for.envelope.info <> 0   then env.control.bits = 1;     /* Set bit for dsp add on; clear other bits   */   env.num.of.envs       = 0;   env.env.len           = 0;end clear.all.envelope.lists;/* $page - routines to manipulate complete envelopes *//* routine to extract a region of a complex envelope list:                 *//* NOTE: should be able to extract regions in place.                       */Extract.Envelope.Region: proc(Env, In, Out, Outenv, Maxout);   dcl Env     array;   /* describes original envelope                     */   dcl In      array;   /* start of region we wish to extract              */   dcl Out     array;   /* end of region we wish to extract                */   dcl Outenv  array;   /* extracted envelope is here.                     */   dcl Maxout  fixed;   /* max size (words) of Outenv array                */   dcl NewLen  fixed;   dcl i       fixed;   dcl j       fixed;   dcl a(1)    fixed;   if Env(0) < 2        /* if trying to extract part of a null             */   then do;             /* envelope (0,0), then return another null        */      Outenv(0) = 0;    /* envelope                                        */      Outenv(1) = 0;      return;   end;   call COPY32(In,  A);          /* get working copy of in time            */   i = 1;                        /* point to first segment Sval            */   j = 1;                        /* initialize output pointer too          */   next.in:;   /* return last value if no more segments: */   if (Env(0) <= (i + ESegDval))       /* if no more segments on list,     */   then do;                            /* then use steady value.           */      Outenv(0) = j + ESegSval + 1;      Outenv(j + ESegSval) = Env(i + ESegSval);      return;   end;   /* skip over this segment if we should:   */   if COM32(A, loc(addr(Env(i + ESegLen)))) >= lw#ieq   then do;      call SUB32(A, loc(addr(Env(i + ESegLen))), A);      i = i + ESegStride;      goto next.in;   end;   /* our In time is somewhere in this segment.   Copy this segment to */   /* the output array,  and the interpolate the starting value based  */   /* upon how far into it our in time is.                             */   call blockmove(loc(addr(Env(i))), loc(addr(Outenv(j))), ESegStride+1);   i = i + ESegStride;               /* skip over this source segment  */   NewLen = j + ESegDval + 1;        /* set length of output list      */                                     /* but leave current dest ptr at 1*/                                     /* warning: special logic needed  */                                     /* in case ENV and OUTENV are the */                                     /* same array.                    */   /* delay the start of the envelope segment: */   if COM16(0, A) <> lw#ieq then do;      Outenv(j + ESegSval) = Interpolate.Envelope.Segment                            (Outenv(j + ESegSval),                             Outenv(j + ESegDval),                             A, loc(addr(Outenv(j + ESegLen))));      call SUB32(loc(addr(Outenv(j + ESegLen))), A,                 loc(addr(OutEnv(j + ESegLen))));   end;   /* Now keep any additional segments we need */   call SUB32 (Out, In, A);      /* get working copy of length */   next.out:;   /* skip over this segment if we should:   */   if COM32(A, loc(addr(Outenv(j + ESegLen)))) = lw#igt   then do;      call SUB32(A, loc(addr(Outenv(j + ESegLen))), A);      j = j + ESegStride;            /* skip over what we copied above   */      if (Env(0) <= (i + ESegDval))           /* if no other segment     */      or ((NewLen + EsegStride) > Maxout)     /* or out of output room   */      then do;                                /* then use what we have   */         Outenv(0) = NewLen;                  /* set length now in case  */         return;                              /* same!                   */      end;      call blockmove(loc(addr(Env(i))), loc(addr(Outenv(j))), ESegStride+1);      i = i + EsegStride;      NewLen = NewLen + EsegStride;           /* include this segment    */      goto next.out;                          /* in output list.         */   end;                                       /* & go back for more.     */   /* interpolate to value if we are mid-segment: */   if COM32(A, loc(addr(Outenv(j + ESegLen)))) <> lw#ieq   then do;      Outenv(j + ESegDval) = Interpolate.Envelope.Segment                            (Outenv(j + ESegSval),                             Outenv(j + ESegDval),                             A, loc(addr(Outenv(j + ESegLen))));      call COPY32(A,loc(addr(Outenv(j + ESegLen))));   end;   Outenv(0) = NewLen;                        /* set length now in case  */                                              /* same.                   */end Extract.Envelope.Region;/* Routine to approximately convert the cue fade in/fade out time *//* to how many samples that corresponds to (rounds to nearest     *//* 5 millisecond time)                                            */Conv.Msecs.To.Samples: proc(msecs, samples);   dcl msecs      fixed;   dcl samples    array;   if msecs ILE 50                          /* for < 50 msecs, can be     */   then do;                                 /* fully accurate             */      load msecs; mul current.rate;         /* get msecs, * khz*10        */      load res; div 10;      samples(0) = 0; samples(1) = res;   end;   else do;                                 /* else round up to 5 msec    */      load msecs + 4; div 5;                /* get msecs/5                */      load res; mul current.rate;           /* times khz*10               */      samples(0) = ures; samples(1) = res;  /* yields 2*samples (approx)  */      call SHR32(samples, 1);               /* get samples                */   end;   if enabled.for.envelope.info <> 0        /* round to sector bound      */   then do;                                 /* for dsp option             */      call ROUND32(samples);                /* get it on sector boundary  */      if COM16(0, samples) = lw#ieq      then call str32(0, 256, samples);   end;end Conv.Msecs.To.Samples;/* Add Envelope Segment is used to add an envelope segment to a           *//* envelope segment list                                                  */Add.Envelope.Segment: proc(Env, Len, Dval);   dcl Env   array;       /* Holds envelope segment list                  */   dcl Len   array;       /* segment length, in samples                   */   dcl Dval  fixed;       /* ending segment value                         */   Env(Env(0)    ) = Len(0);   Env(Env(0) + 1) = Len(1);   Env(Env(0) + 2) = Dval;   Env(0) = Env(0) + ESegStride;end Add.Envelope.Segment;