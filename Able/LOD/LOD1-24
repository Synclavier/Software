/* 11/28/94 - pf - clear scsi.active after track dir is read in for      *//*                 slink reserve/release management                      *//* 09/07/89 - cj - fixed bug where cue directory was not written to disk *//*                 while doing digital bouncing.                         *//* 2/9/89 - cj - fixed crashing bug if no DDT */         /* LOD1-24 - check idle port */         /* port is currently idle */         /* see if either track    */         /* requires disk i.o.     */         dcl (bmsb,blsb) fixed;    /* declare in order */         dcl (cmsb,clsb) fixed;         dcl (dmsb,dlsb) fixed;         dcl (emsb,elsb) fixed;         if  (port.io(port#)   = 0)    /* if last command has finished */         and (rezero.happening = 0)    /* and not rezeroing            */         then do;                      /* then maybe issue new command */           /* Check word clock of master iDDT whenever possible        */           /* (IE whenever port is free)                               */ 			  #if (inc.multi.udio)						 /* multi udio included	  */				  if  (port# = dig.xfer.clock.port)  /* if this is ddt port   */				  and (new.dtd.song# = 0          )  /* and done initing      */				  then do;						  call quickly.select.port(port#);						  DDT.Mode = Port.DDT.Mode(port#);       /* look up mode       */						  disable;					  call get.d16.time;                     /* get d16 time       */					  dig.xfer.clock.value = Read.Selected.DDT.Word.Clock;  /* get word clock      */					  enable;						  call deselect(port#);                  /* disconnect from port */						  dig.xfer.clock.time   = Our.Time.Lsb;						  /* Measure in-coming sample rate so we can interpolate the */					  /* DDT word clock to the sync point needed in get.sync.s#  */						  /* Perform a measurement whenever 32,768 samples have gone */					  /* by,  or whenever 32,768 (or more) d16 ticks have gone   */					  /* by.  (normally every .5 to every 1.0 second)            */						  i = dig.xfer.clock.value - dig.xfer.clock.pvalue;					  j = dig.xfer.clock.time  - dig.xfer.clock.ptime;						  if (i\j) IGE 32768 then do;   /* wait until we have enough resolution on either the sample counter or d16 clock */							  k = D16tim*500;            /* get # of d16 ticks in .5 second */						  load i; mul k; mwait; div j;							  dig.xfer.clock.rate   = res;  /* result is # of samples in .5 second */							  if rem IGE shr(j,1) then dig.xfer.clock.rate = dig.xfer.clock.rate + 1;							  dig.xfer.clock.pvalue = dig.xfer.clock.value;						  dig.xfer.clock.ptime  = dig.xfer.clock.time;							  if hzdbug then begin;							  dcl lastrate fixed static;							  if lastrate <> dig.xfer.clock.rate							  then print 'DDT: ',dig.xfer.clock.rate;							  lastrate = dig.xfer.clock.rate;						  end;							  /* Also read the 'In Sync' bit to know whether */						  /* we are in sync or not.                      */							  call quickly.select.port(port#);							  DDT.Mode = Port.DDT.Mode(port#);       /* look up mode       */							  DDT.In.Sync = Read.Selected.DDT.Byte(LAD_PLL_Lock_bit);						  call deselect(port#);                  /* disconnect from port */						  end;				  end;			  #endif           /* periodically check for reading/writing system info */           /* from this track                                    */           track# = port#*tracks.per.port + port.toggle(port#);           port.toggle(port#) = (port.toggle(port#)+1) & (tracks.per.port-1);           if  (track# < max.tracks)        /* if track# in range        */           and (track.available(track#)<>0) /* and available             */           then do;                         /* then look further         */             if  (track# = ourtrack#)      /* check 1 track/loop        */             and (func   = 0         )     /* and func is not using mem */             then do;                      /* then update system info   */               /* write track directory to all disks */               /* when changes are made:             */               if   ((track.dir.updated              ) =2)  /* write of track directory desired */               and  ((track.dir.to.write&bits(track#))<>0)  /* this track not written yet       */               then do;											if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  track.dir.to.write = track.dir.to.write & (not(bits(track#))); /* mark written */                  j=compute.base.adr(track#)+inf.base;/* get pmem sec#      */                  call psmwrite(j,0);                 /* set up for write   */                  write("313")=addr(track.dir(0));    /* move data to       */                  do k = 0 to (num.tracks/16) - 1;                     rpc 256;                         /* poly for write     */                     write(psd)=read("373");          /* do it              */                  end;                  i = track.sec# + gsong.dir(track.dir.song*song.len+song.index);                  port.io        (port#) = 3;             /* write desired  */                  port.io.track# (port#) = track#;        /* this track #   */                  port.io.dtrack#(port#) = track#;        /* this track #   */                  port.io.len#   (port#) = num.tracks/16; /* for this len   */                  port.secmsb    (port#) = 0;             /* save for       */                  port.seclsb    (port#) = i;             /* retries        */                  port.pmemsec   (port#) = j;                  port.pmemwrd   (port#) = 0;                  port.update    (port#) = 6;             /* write magic    */                  call issue.port.command(port#,0);                  goto skip.port.checks;            /* speedy exit - skip other checks */               end;               /* write song directory to all disks  */               /* when changes are made:             */               else if ((song.dir.updated              )= 2)  /* write song dir */               and     ((song.dir.to.write&bits(track#))<>0)               and     ((now.playing                   )= 0)               and     ((now.triggering                )= 0)               then do;						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  song.dir.to.write = song.dir.to.write & (not(bits(track#)));                  tptr=(track#*total.stride);                  write(mam)=song.xmsec#;                  i=writedata(0,song.sec#,loc(0),num.songs*song.len,1);                  if i<>0 then do;          /* write error encountered */                     valid.info(track#)=0;                     if screen=2 then send.screen.info=1;                  end;                  else write.magic.tracks = write.magic.tracks \ bits(track#);               end;               /* write alternate track directory to all disks  */               /* when changes are made:                        */               else if   ((write.alt.tdir              )<>0)               and       ((alt.tdir.tracks&bits(track#))<>0)                 then do;						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  alt.tdir.tracks = alt.tdir.tracks and (not(bits(track#)));                  if alt.tdir.tracks=0                  then write.alt.tdir=0;                  if command.song<>(-1)  /* double check for valid command.song */                  then do;                     j=compute.base.adr(track#)+inf.base;/* get pmem sec#      */                     call psmwrite(j,0);                 /* set up for write   */                     write("313")=addr(alt.tdir(0));     /* move data to       */                     do k = 0 to (num.tracks/16)-1;                        rpc 256;                         /* poly for write     */                        write(psd)=read("373");          /* do it              */                     end;                     i = track.sec# + gsong.dir(command.song*song.len+song.index);                     port.io        (port#) = 3;             /* write desired  */                     port.io.track# (port#) = track#;        /* this track #   */                     port.io.dtrack#(port#) = track#;        /* this track #   */                     port.io.len#   (port#) = num.tracks/16; /* for this len   */                     port.secmsb    (port#) = 0;             /* save for       */                     port.seclsb    (port#) = i;             /* retries        */                     port.pmemsec   (port#) = j;                     port.pmemwrd   (port#) = 0;                     port.update    (port#) = 6;             /* write magic    */                     call issue.port.command(port#,0);                     goto skip.port.checks;            /* speedy exit - skip other checks */                  end;               end;               /* read track directory from disk if we do not */               /* have one yet                                */               else if  (track.dir.valid  =0)  /* if waiting for track directory                */               and      (now.playing      =0)  /* must wait until all recording is finished     */               and      (now.triggering   =0)  /* must wait until all recording is finished     */               and      (track.dir.updated=0)  /* and we have written out any earlier changes   */               and      (song.dir.updated =0)  /* and we are not waiting to write out song info */               and      (write.alt.tdir   =0)  /* no alternate waiting to write   */               and      (song.dir.track=track#+1) /* and this is where we read directory from   */               then do;                        /* read track directory                          */						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  tptr=(track#*total.stride);                  if  (command.#       <> 0                    ) /* doing command */                  and (command.song     = (song.base+dtd.song#))                  and (alt.tdir.valid  <> 0                    )                  then do;                     call blockmove(alt.tdir,track.dir,max.tracks*track.len);                     i=0;                  end;                  else do;                     i=gsong.dir((song.base+dtd.song#)*song.len+song.index);                     i=readdata(0,track.sec#+i,track.dir,num.tracks*track.len);                  end;                  if i<>0 then do;       /* readdata error              */                     valid.info     (track#)=0;                     i=0; j=track#;              /* try to find another track      */                     do while (i<max.tracks)     /* with a valid catalog,  and     */                     and      (valid.info(j)=0); /* use it                         */                        j=j+1;                        if j=max.tracks then j=0;                        i=i+1;                     end;                     if i<max.tracks                      then song.dir.track = j+1;  /* now use that track  */                     else song.dir.track = 0;    /* else all are dead   */                  end;                  else do;                     track.dir.valid = 1;        /* have read it in     */                     track.dir.song  = song.base+dtd.song#;                     /* Clean up directory by safing tracks & checking  */                     /* Outputs:                                        */                     call Clean.Up.Track.Directory(Track.Dir);                     call Precompute.Volume.Information;                     call Mark.Stars;                     /* If we are not waiting for a new song#,  then */                     /* initialize several items here:               */                     if new.dtd.song# = 0                     then do;                        new.inputs   =1;                    /* now get inputs going       */                        get.new.motion=get.new.motion\1;    /* get new motion info        */                        if Synclav.software.version >= 3          /* update screen */                        then get.new.motion = get.new.motion \ 4; /* on aee        */                        if output.happening = 0                        then call set.new.play.buffer.position;   /* load new buffers now     */                     end;                  end;                  if screen=2 then send.screen.info=1;                  scsi.active = 0;                           /* release drives (for slink) */               end;               else if  (alt.tdir.needed     <>0)   /* if waiting for alternate track directory   */               and      (song.dir.track=track#+1)   /* and this is where we read directory from   */               then do;                             /* read track directory                       */						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  tptr=(track#*total.stride);                  if command.song=(-1)              /* if command is not for                      */                  then do;                          /* a particular song,  just get               */                     call init.alt.tdir;            /* an empty track directory                   */                     alt.tdir.needed  = 0;                            alt.tdir.valid   = 1;                         end;                  else do;                          /* else read in correct one from disk         */                     i = gsong.dir(command.song*song.len+song.index);                     i = readdata(0,track.sec#+i,alt.tdir,num.tracks*track.len);                     if i<>0 then do;       /* readdata error              */                        valid.info     (track#)=0;                        i=0; j=track#;              /* try to find another track      */                        do while (i<max.tracks)     /* with a valid catalog,  and     */                        and      (valid.info(j)=0); /* use it                         */                           j=j+1;                           if j=max.tracks then j=0;                           i=i+1;                        end;                        if i<max.tracks                         then song.dir.track = j+1;  /* now use that track  */                        else song.dir.track = 0;    /* else all are dead   */                     end;                     else do;                       /* else if data is     */                        alt.tdir.needed  = 0;       /* there,  just clean  */                        alt.tdir.valid   = 1;       /* it up               */                        call Clean.Up.Track.Directory(Alt.Tdir);                     end;                  end;               end;               else if ((new.adir       (track#) = 2))    /* 2: always        */               or      ((new.adir       (track#) = 1)     /* 1: not recording */                and      (track.recording(track#) = 0)               and      ( ((command.#                  )=0)               or         ((command.tracks&bits(track#))=0) ))               then do;                  /* check for garbage collect of adir */						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  i=track#*adir.len+200;                  call gadir(i);                  if (read(mdi)<>0)     /* see if adir is getting */                  or (read(mdi)<>0)     /* full                   */                  then do;                     i=track#*adir.len; /* point to start of adir */                     call gadir(i+2);                     bmsb=read(mdi);    /* set up for search      */                     blsb=read(mdi);    /* for smallest gap       */                     cmsb=read(mdi);                      clsb=read(mdi);                                           dmsb=cmsb-bmsb;    /* compute distance       */                     dlsb=clsb-blsb;    /* from end of this blk   */                     if clsb ilt blsb   /* to start of next       */                     then dmsb=dmsb-1;                     j=i;               /* to find smallest       */                     emsb=dmsb; elsb=dlsb;                     i=i+4;             /* compare with following */                     call gadir(i+4);                     cmsb=read(mdi);    /* search until end of    */                     clsb=read(mdi);    /* adir                   */                     do while (cmsb\clsb)<>0;                        call gadir(i+2);                        bmsb=read(mdi); /* end of this block      */                        blsb=read(mdi);                        dmsb=cmsb-bmsb; /* get delta to next      */                        dlsb=clsb-blsb;                        if clsb ilt blsb                        then dmsb=dmsb-1;                        if  ((dmsb ilt emsb))  /* if this gap     */                        or  ((dmsb  =  emsb)   /* is shorter      */                        and  (dlsb ilt elsb))                        then do;                           j=i;                /* save pointer    */                           emsb=dmsb; elsb=dlsb;                        end;                        i=i+4;                 /* advance         */                        call gadir(i+4);                        cmsb=read(mdi);        /* get next strt   */                        clsb=read(mdi);                      end;                     /* write out zeroes to remove gap */                     i=j;                     adir.ptr(track#)=j;                     call gadir(i+2);                     bmsb=read(mdi);       /* write zeroes */                     blsb=read(mdi);       /* to end of    */                                           /* block        */                     if  (emsb<>0)                     or  (elsb igt zer.len)                     then elsb=zer.len;    /* limit length */                     if  ((bmsb<>0)        /* check for ok adir */                     or   (blsb ige data.sec#))                     and (elsb <>0)                     then do;                        port.io        (port#) = 3;       /* write desired  */                        port.io.track# (port#) = track#;  /* this track #   */                        port.io.dtrack#(port#) = track#;  /* this track #   */                        port.io.len#   (port#) = elsb;    /* for this len   */                        port.secmsb    (port#) = bmsb;    /* also save in arrays in case     */                        port.seclsb    (port#) = blsb;    /* of retries                      */                        port.pmemsec   (port#) = compute.base.adr(track#)+zer.base;                        port.pmemwrd   (port#) = 0;                        port.update    (port#) = 4;       /* update adir only */                        call issue.port.command(port#,0);                        goto skip.port.checks;            /* speedy exit - skip other checks */                     end;                     else do;                        new.adir(track#)=0; /* system error - adir has bad blocks in it */                     end;                  end;                  else do;         /* write it out */                     j=compute.base.adr(track#)+inf.base;/* get pmem sec#      */                     call psmwrite(j,0);                 /* set up for write   */                     write(mam)=adir.xmsec#+track#;      /* move data to       */                     rpc 256;                            /* poly for write     */                     write(psd)=read(mdi);               /* do it              */                     i = track.adir.sec(track#);                     port.io        (port#) = 3;        /* write desired  */                     port.io.track# (port#) = track#;   /* this track #   */                     port.io.dtrack#(port#) = track#;   /* this track #   */                     port.io.len#   (port#) = 1;        /* for this len   */                     port.secmsb    (port#) = 0;        /* save for       */                     port.seclsb    (port#) = i;        /* retries        */                     port.pmemsec   (port#) = j;                     port.pmemwrd   (port#) = 0;                     port.update    (port#) = 0;        /* no update      */                     call issue.port.command(port#,0);                     /* try to write only once: */                     new.adir(track#)=0;                     goto skip.port.checks;            /* speedy exit - skip other checks */                  end;                                 end;             /* of new.adir write     */               else if ((cue.info.updated              )= 2)  /* write cue info */               and     ((cue.info.to.write&bits(track#))<>0)               and     (((cue.info.to.write&(bits(track#)-1)))=0) /* give priority to track 0 so that we do not lose all cue directories in the event of a power failure */               and     ((now.playing                   )= 0)  /* skip writing cue directory */               and     ((now.triggering                )= 0)  /* while playing    */               and     ((now.looping                   )= 0)               and     ((play                          )= 0)  /* or trying to start output             */               and     ((trig                          )= 0)  /* so multi-track DDT can do it's thing  */               then begin;						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  dcl (sector.limit) fixed;                  dcl (sector.count) fixed;                  local.advance:proc(first,last,maxs,maxw,base);                     dcl (first)     fixed;  /* first sector # */                     dcl (last)      fixed;  /* last  sector # */                     dcl (maxs,maxw) fixed;  /* max s, w       */                     dcl (base)      fixed;                     maxs = maxs + shr(maxw+255,8);                     if   (i>=first)                                and  (i< last)                     then do;                        j = i-first;      /* get rel sector pos  */                        if j ilt maxs                        then do;                           sector.count = maxs-j;                           if   sector.count IGT sector.limit                           then sector.count  =  sector.limit;                           call Copy.Ext.Mem.To.Poly(base+j,0,                                track.base.adr(track#)+inf.base,0,                                shl(sector.count,8));                        end;                        else i=last;           /* done with alloc   */                     end;                  end local.advance;                  sector.limit = inf.len;      /* write out block   */                  sector.count = 0;                  i=cue.write.sec#(track#);           /* get sector # handy */                  if i<disk.info.sec#                  then i=disk.info.sec#;              /* start here         */                  if i=disk.info.sec# then do;        /* write zeroes       */                     call psmwrite(track.base.adr(track#)+inf.base,0);                     rpc 256;                         /* to cue magic info  */                     write(psd) = 0;                  /* until all info     */                     sector.count = 1;                /* is stored.         */                  end;                  call local.advance(disk.alloc.sec#,                                     disk.alph.sec#,                                     0,shl(num.of.alloc,1),allc.sec#);                  call local.advance(disk.alph.sec#,                                     disk.time.sec#,                                     0,num.of(alph.sort),alph.sec#);                                     call local.advance(disk.time.sec#,                                     disk.smpt.sec#,                                     0,num.of(time.sort),time.sec#);                                     call local.advance(disk.smpt.sec#,                                     disk.cue.sec#,                                     0,num.of(smpt.sort),smpt.sec#);                                     call local.advance(disk.cue.sec#,                                     zero.sec#,                                     cue.numsec,cue.numwrd,cue.sec#);                                     if i=zero.sec#                    /* write magic info at end  */                  then do;                     call psmwrite(track.base.adr(track#)+inf.base,0);                     write(psd) = magic#1;          /* 0 - magic #1             */                     write(psd) = magic#2;          /* 1 - magic #2             */                     write(psd) = cue.num;          /* 2 - num of cues in data area */                     write(psd) = cue.numsec;       /* 3 - num of secs of cue def   */                     write(psd) = cue.numwrd;       /* 4 - num of wrds of cue def   */                     write(psd) = num.of.alloc;     /* 5 - num of entries in alloc  */                     do j=0 to 2;                        write(psd) = num.of(j);     /* 6, 7, 8 - num.of for total disk sort */                     end;                     rpc 256-9;                     write(psd) = 0;                     sector.count = 1;                  end;                  if sector.count = 0 then stop;    /* indicates system error with this software */                  cue.write.sec#(track#)=i;           /* restore sec#       */                                    /* detect broken disk drive by repeated writing to        */                  /* same sector.   Move on to other tracks so we don't     */                  /* loose the cue directory                                */                  if i=cue.prior.sec#(track#)                  then do;                     cue.prior.ctr(track#) = cue.prior.ctr(track#) + 1;                     if cue.prior.ctr(track#) IGE 10                     then do;                        cue.info.to.write = cue.info.to.write & (not(bits(track#)));                     end;                  end;                  cue.prior.sec#(track#) = i;                  if i=zero.sec# then i=disk.info.sec#;  /* but magic# goes back here */                  port.io        (port#) = 3;            /* write desired  */                  port.io.track# (port#) = track#;       /* this track #   */                  port.io.dtrack#(port#) = track#;       /* this track #   */                  port.io.len#   (port#) = sector.count; /* for this len   */                  port.secmsb    (port#) = 0;            /* also save in arrays in case     */                  port.seclsb    (port#) = i;            /* of retries                      */                  port.pmemsec   (port#) = track.base.adr(track#)+inf.base;                  port.pmemwrd   (port#) = 0;                  port.update    (port#) = 3;        /* update cue.write.sec# only */                  call issue.port.command(port#,0);                  goto skip.port.checks;            /* speedy exit - skip other checks */               end;               else if ((write.magic.tracks&bits(track#)) <> 0)               then do;						if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  write.magic.tracks = write.magic.tracks and (not(bits(track#)));                  if valid.info(track#)<>0 then do;                     do i=0 to 255;                        misc.buf(i)=0;                     end;                     misc.buf(0)=magic#1;                     misc.buf(1)=magic#2;                     misc.buf(2)=error.msb;                     misc.buf(3)=error.lsb;                     misc.buf(4)=longconfig(track#);                     misc.buf(5)=zero.sec#;                     misc.buf(6)=data.sec#;                     call fill.magic.sec#(port#, track#, misc.buf);                     j=compute.base.adr(track#)+inf.base;/* get pmem sec#      */                     call psmwrite(j,0);                 /* set up for write   */                     write("313")=addr(misc.buf(0));     /* move data to       */                     rpc 256;                            /* poly for write     */                     write(psd)=read("373");             /* do it              */                     i = magic.sec#;                     /* write here         */                     port.io        (port#) = 3;        /* write desired  */                     port.io.track# (port#) = track#;   /* this track #   */                     port.io.dtrack#(port#) = track#;   /* this track #   */                     port.io.len#   (port#) = 1;        /* for this len   */                     port.secmsb    (port#) = 0;        /* save for       */                     port.seclsb    (port#) = i;        /* retries        */                     port.pmemsec   (port#) = j;                     port.pmemwrd   (port#) = 0;                     port.update    (port#) = 0;        /* no update      */                     call issue.port.command(port#,0);                     goto skip.port.checks;            /* speedy exit - skip other checks */                  end;               end;               										else if (cue.dir.valid=0) and (track#=0)               then do;												if (check.for.disk.readiness() != 0)		/* make sure disk is spun up.  if	*/							goto skip.port.checks;						/* not, spin it up...					*/                  cue.dir.valid=1;                  call reload.project.dir;                  call reload.track.dir;                  call reload.cue.dir;                  do i = 0 to max.tracks-1;                     if ((adir.inval.trks & bits(i))<>0) then do;                        call reload.adir(i);                     end;                  end;                  adir.inval.trks = 0;                  if Synclav.software.version >= 3                  then get.new.motion = get.new.motion \ 4;                  if screen <> 0  then send.screen.info=1;               end;             end;             /* If we are trying to process a tape command on this */             /* port, then do so:                                  */             if  ( command.#                             <>0)  /* command desired */             and ((command.tracks&port.track.bits(port#))<>0)  /* on this port    */             then do;               if  ((new.dtd.song#        = 0)  /* and either no new song pending   */               or   (DDT.Connect.Mode     = 0)) /* or not MULTI track DDT           */               and (Stop.DDT.Units        = 0 ) /* and not trying to stop DDT units */               and (new.buffer.position   = 0 ) /* give priority to new buffers     */               then do;                  /* Skip processing commands while data function */                  /* reading as soon as poly buffers become       */                  /* free                                         */                  if  ((func                  <> 0)  /* func desired */                  or   (play                  <> 0)  /* play desired */                  or   (loop                  <> 0)  /* loop desired */                  or   (trig                  <> 0)  /* trig desired */                  or   (delay.command         <> 0)) /* delay needed */                  and (this.buf.in.use(port#) =  0 ) /* poly free    */                  then do;                     if (track.eof(track#) = 0)      /* no eof yet   */                     then call track.playback.check(port#,track#); /* perform special read instead of command check */                  end;                                    /* Process multi-cart load/backup here             */                  else if active.tape.config = 0                  then do;                     /* advance to first track on this port that is */                     /* involved in this command:                   */                     do while (command.tracks&bits(command.track#(port#))) = 0;                        command.track#(port#) = command.track#(port#)+1;                     end;                     call track.command.check(port#,command.track#(port#));                  end;               end;             end;                         /* Else if no command outstanding on this port,  check */             /* for disk commands needed to accomplish playback     */             /* or recording.                                       */             else do;               if (track.recording(track#)<>0)     /* recording          */               then do;                            /* happening          */                  call track.recording.check(port#,track#);                  /* We also must check here for transferring DDT input	*/                  /* data to the buffer memory card if the port is		*/                  /* idle.  Track.Recording.Check cannot issue a			*/                  /* disk write command until the data is in poly			*/                  /* memory, so we must begin by checking to see if		*/                  /* we should move some there.									*/						#if (inc.multi.udio)					/* multi udio included	  		  */							if  ( port.io(port#)           =  0)							and ((Dig.Xfer.Mode & (Dig.Out\Dig.In)) <> 0) /* doing ddt    */							and ( DDT.Connect.Mode         <> 0)   /* via multi-track     */							and ( Port.DDT(port#)          <> 0)   /* ddt available       */							and (( tracks.per.port <= 2)    /* and normal system            */							or   ((track# & (tracks.per.port-1)) < 2))   /* or first 2 trks */							then do;									/* turn on port/start up late,  or turn off port if needed */									DDT.Mode = Port.DDT.Mode(port#);       /* look up mode          */									if  ((Dig.Xfer.Mode & Dig.Out)   <> 0) /* doing ddt output */								and ((DDT.Mode      & FE_Dir_In) =  0) /* to this box      */								then do;									/* should not get here.  If we are recording on */									/* this track,  then the box should be          */									/* sending data in,  not out.                   */								end;									else if ((Dig.Xfer.Mode & Dig.In   ) <> 0) /* doing ddt input */								and     ((DDT.Mode      & FE_Dir_In) <> 0) /* from this box   */								and     ( Track.sampling(track#)     =  4) /* DIG in selected */								then call Process.Multi.DDT.Input(Port#, Track#, 1);							end;						#endif						               end;               /* If not recording,  then check for issuing a disk */               /* read command for playback,  or buffer loading    */               if  (track.recording(track#) = 0) /* recording not happening,  or maybe it just finished above */               and (new.dtd.song#           = 0) /* new song not sel'd */               and (new.buffer.position    <> 1) /* no new buffer positio */               and (Stop.DDT.Units          = 0) /* and not trying to stop DDT units   */               then do;                                if track.eof(track#) = 0                  then call track.playback.check(port#,track#);                   /* if no playback/recording disk activity is needed, */                  /* then check assorted DDT items                     */						#if (inc.multi.udio)					/* multi udio included	  		  */							if  ( port.io(port#)           =  0)							and ((Dig.Xfer.Mode & (Dig.Out\Dig.In)) <> 0) /* doing ddt    */							and ( DDT.Connect.Mode         <> 0)   /* via multi-track     */							and ( Port.DDT(port#)          <> 0)   /* ddt available       */							and ( now.looping   =  0)       /* also skip while looping                   */							and ( func          =  0)       /* and not doing poly transfer items         */							and (( tracks.per.port <= 2)    /* and normal system            */							or   ((track# & (tracks.per.port-1)) < 2))   /* or first 2 trks */							then do;									DDT.Mode = Port.DDT.Mode(port#);       /* look up mode          */									if  ((Dig.Xfer.Mode & Dig.Out)   <> 0) /* doing ddt output */								and ((DDT.Mode      & FE_Dir_In) =  0) /* to this box      */								then do;									/* if directions is out,  then the DDT buffer */									/* should be filled with the output data      */									/* from the disk buffers.                     */								end;									else if ((Dig.Xfer.Mode & Dig.In   ) <> 0) /* doing ddt input */								and     ((DDT.Mode      & FE_Dir_In) <> 0) /* from this box   */								and     ( Track.sampling(track#)     =  4) /* DIG in selected */								and     ( new.inputs                 =  0) /* not changing    */								then call Process.Multi.DDT.Input(Port#, Track#, 1);							end;						#endif						               end;             end;           end;           /* Else use special check for Auxiliary Tape Drive */           /* If there is no command outstanding on the aux tape port, */           /* see if we should start one here.                         */           else if ( port#     =   max.ports)           and     ( command.#          <> 0)  /* if processing load/backup */           and     ( command.tracks     <> 0)  /* safety check              */           and     ((active.tape.config <> 0)  /* to/from AUX tape          */           or       (interrogate.tapes  <> 0)) /* or looking for AUX tape   */           then do;                            /* then look further         */              do while (command.tracks&bits(command.track#(port#))) = 0;                 command.track#(port#) = command.track#(port#)+1;              end;              if  (new.dtd.song#         = 0 ) /* and no new song pending          */              and (Stop.DDT.Units        = 0 ) /* and not trying to stop DDT units */              and (new.buffer.position   = 0 ) /* give priority to new buffers     */              then do;                 /* Skip processing commands while data function */                 /* reading as soon as poly buffers become       */                 /* free                                         */                 if  ((func             =  0)  /* if  no func desired */                 and  (play             =  0)  /* and no play desired */                 and  (loop             =  0)  /* and no loop desired */                 and  (trig             =  0)  /* and no trig desired */                 and  (delay.command    =  0)) /* and no delay needed */                 or  (poly.buffs.in.use <> 0)  /* or poly is not free */                 then do;                    call track.command.check(port#,command.track#(port#));                 end;              end;           end;           skip.port.checks:;         end;                   /* of port.io = 0        */      end;                      /* of port is available  */   end;                         /* of loop over ports    */   count=count+1;               /* count iterations      */   if count >= (tracks.per.port+1) then do;      count=0;      ourtrack#=ourtrack#+1;      if ourtrack#=max.tracks      then ourtrack#=0;      /* Check for garbage collect of real time */      /* cue stack:                             */      if (now.playing \ now.triggering) <> 0 /* only garbage collect */      then do;                               /* during TRIG or PLAY  */         check.next:;                        /* re-enter to check    */         i = gseg.info(shl(ourtrack#, 1));   /* get pointer to list  */         if i <> (shl(ourtrack#, 1))         /* if block exists ...  */         then do;            j = gseg.info(i+Seg.Exists.Loc); /* get Seg.Exists bit   */            k = gseg.info(i+Seg.End.Loc   ); /* and Seg.End msb      */            /* if this is an expired cue segment (ie we have */            /* read all of it) and we have gone > 128,000    */            /* samples beyond the end of it,  and it is not  */            /* the recording cue,  then toss it to free      */            /* up storage,  knowing that we do not read      */            /* backwards while playing or triggering.        */            /* We had to keep it around for a while because  */            /* we might have received a cue trigger that     */            /* necessitated re-reading some of this data.    */            if  ((j & (32\64)) = 32)        /* expired, non-recording seg  */            and ((k+2) ILT Current.Buf(0))  /* getting old & grey ...      */            then do;                        /* then free it up             */               call Unlink.Segment.Record (i);               call Release.Segment.Record(i);               if cue.read.ptr  (ourtrack#) = i  /* just to be safe, clean */               then cue.read.ptr(ourtrack#) = 0; /* these pointers.  They  */                                                 /* should never be point- */               if cue.rt.ptr    (ourtrack#) = i  /* ing to the record we   */               then cue.rt.ptr  (ourtrack#) = 0; /* releasing.  would      */                                                 /* indicate a serious     */               goto check.next;                  /* error if they were.    */            end;         end;      end;   end;end port.check;