/* literals for Synchronized Recording record: *//* 05/29/91 - C. Jones - Added stack bit for extend       */dcl recrec.code      lit  '0';  /* 0 = immed,  1 = wait  2 = wait and resync if starting late (auto-allocate) */dcl recrec.sync.msb  lit  '1';  /* sequencer in time      */dcl recrec.sync.lsb  lit  '2';dcl RecRec.Sync      lit  'loc(addr(recrec(recrec.sync.msb)))';dcl recrec.dtype     lit  '3';  /* 0 = cue,  1 = times    */dcl recrec.pincode   lit  '4';  /* 0 = punch,1 = butt     */ /* probably not used */dcl recrec.cue.id    lit  '5';  /* cue id                 */dcl recrec.in.msb    lit  '5';  /* *** OR  *** dest msb   */dcl recrec.in.lsb    lit  '6';  /* in dest lsb            */dcl RecRec.In        lit  'loc(addr(recrec(recrec.in.msb)))';dcl recrec.out.msb   lit  '7';  /* out dest msb           */dcl recrec.out.lsb   lit  '8';  /* out dest lsb           */dcl RecRec.Out       lit  'loc(addr(recrec(recrec.out.msb)))';dcl recrec.rehearse  lit  '9';  /* true to rehearse only  */dcl recrec.newinfo   lit '10';  /* new info passed        */dcl recrec.tracks    lit '11';  /* will hold track bits   */dcl recrec.audio     lit '12';  /* audio tracks           */dcl recrec.stacked   lit '13';  /* nonzero when stacked   */dcl recrec.send.msb  lit '14';  /* sync end time          */dcl recrec.send.lsb  lit '15';dcl RecRec.Send      lit  'loc(addr(recrec(recrec.send.msb)))';dcl recrec.size      lit '16';/* Literals for cue playaback stack: *//* Each track uses a linked list of Segment Records to provide a  *//* list of the disk segments that should be played in the future. *//* The format for this record is:                                 */dcl seg.fptr.loc     lit ' 0';    /* forward pointer to block     */dcl seg.bptr.loc     lit ' 1';    /* backwards pointer to block   */dcl seg.exists.loc   lit ' 2';    /* bits: see below              */dcl seg.sync.loc     lit ' 3';    /* sample # when to play        */dcl seg.disk.loc     lit ' 5';    /* disk address of cue (s#)     */dcl seg.end.loc      lit ' 7';    /* ending sample # of cue       */dcl seg.info.loc     lit ' 9';    /* output & syncl track # info  */dcl seg.time.loc     lit '10';    /* original sync time for voice */dcl seg.track.loc    lit '12';    /* track # for polyphonic trks  */dcl seg.record.size  lit '13';    /* size of record,  in words    *//* bits in seg.exists field:    1 = entry exists.  this segment should be played    2 = loop.          repeat this segment at end    4 =                *** unused ***    8 = punch over.    play this cue then continue with any we interrupted                       priority is contained in 4 bit field  [shr(x,8)&15]   16 = ff/rew         perform ff/rew.  loop bit must also be set.   32 = expired        entire cue has been read into poly.  cue is still on stack                       however in case a later punch over is received   64 = record         record this cue    128 = switch back    to source playback at end of this cue   256                  |  512                  | priority bits 1024                  | stored here 2048                  | 4096                  info note trigger note - trigger play note even if not playing 8192                  truncate prior cues (ie no punch over)  16384                 this is a zero cue for silence (skip scrolling) 32768                 this cue is being started up in the middle,  so give                       priority to which ever segment is later in the                       sequence.  *//* Literals for Envelope Que                                             *//* A sorted linked list of blocks in external memory is used to          *//* construct a list of envelope segment points for each voice.           *//* NOTE:  these blocks are stored in the same memory space as the        *//* Segment Records described above and share many routines.              *//* Each record on this list looks as follows:                            */dcl env.fptr.loc     lit ' 0';    /* forward pointer to block     */dcl env.bptr.loc     lit ' 1';    /* backwards pointer to block   */dcl env.sync.loc     lit ' 2';    /* sample # when to play        */dcl env.len.loc      lit ' 4';    /* sample length of env segment */dcl env.send.loc     lit ' 6';    /* sample # of segment end      */dcl env.sval.loc     lit ' 8';    /* holds starting value.        */dcl env.adder.loc    lit ' 9';    /* adder for envelope computer  */                                  /* MSB of adder is set when     */                                  /* data is written to synth     */dcl env.delta.loc    lit '10';    /* delta for envelope computer  */dcl env.limit.loc    lit '11';    /* limit for envelope computer  */dcl env.record.size  lit '12';    /* size of envelope record      *//* Literals for que head/tail pointers in cseg.xmsec#:            */dcl Seg.Cue.Heads    lit  ' 0';   /* at 0:  two words for every   */                                  /* possible track               */dcl Temp.Cue.Head    lit  '(shl(max.tracks,1))';   /* stack.cue   */                                  /* temp list goes here          */dcl Env.Cue.Heads    lit  '(Temp.Cue.Head + 2)';   /* envelepe    */                                  /* ques start here              *//* Sometimes complete multi-segment envelopes are processed.      *//* Check out these literals:                                      */dcl ESegSval         lit '0';     /* starting value, 0 - 4095     */dcl ESegLen          lit '1';     /* segment length in samples    */dcl ESegDval         lit '3';     /* destination value, 0 - 4095  */dcl ESegStride       lit '3';     /* stride of this table         */dcl ESegSize         lit '11';    /* size of array needed for     */                                  /* complete 4-segment envelope  *//* Arguments for Stack.Entire.Cue:                                       *//* The arguement for Stack.Entire.Cue is a data structure of the         *//* following form.   For XPl compatibility,  it must always              *//* be call 'Stack.Record'                                                */dcl Stack.Record.Size     lit '30';        /* size of record needed      */dcl Stack.Bits     lit 'Stack.Record(0)';  /* codes what to do           */dcl   Stack.Whole.Map     lit ' 1';        /* set to stack whole map     */dcl   Stack.POVP          lit ' 2';        /* set to stack pri/out/vol   */dcl   Stack.Modify.In     lit ' 4';        /* modify in time for event   */dcl   Stack.Construct.Env lit ' 8';        /* construct envelope         */dcl   Stack.Extract       lit '16';        /* extract region & envelope  */dcl   Stack.Play.To       lit '32';        /* limit end to play to time  */dcl   Stack.Extend        lit '64';        /* extend event audio         */dcl Stack.Cue.Id   lit 'Stack.Record( 1)';   /* id to trigger             */dcl Stack.Sync     lit 'loc(addr(Stack.Record(2)))';  /* trigger time     */dcl Stack.Offset   lit 'loc(addr(Stack.Record(4)))';  /* offset point     */dcl Stack.Exists   lit 'Stack.Record( 6)';   /* for seg.exists            */dcl Stack.Track#   lit 'Stack.Record( 7)';   /* syncl trk# for trk volume */dcl Stack.Pri      lit 'Stack.Record( 8)';   /* priority info             */dcl Stack.Out      lit 'Stack.Record( 9)';   /* output info               */dcl Stack.Vol      lit 'Stack.Record(10)';   /* volume info               */dcl Stack.Pan      lit 'Stack.Record(11)';   /* pan    info               */dcl Stack.New.In   lit 'loc(addr(Stack.Record(12)))';   /* new in time    */dcl Stack.New.In.Msb   lit 'Stack.Record(12)';dcl Stack.New.In.Lsb   lit 'Stack.Record(13)';dcl Stack.New.Out  lit 'loc(addr(Stack.Record(14)))';  /* new out time    */dcl Stack.New.Out.Msb   lit 'Stack.Record(14)';dcl Stack.New.Out.Lsb   lit 'Stack.Record(15)';dcl Stack.Fin      lit 'Stack.Record(16)';  /* fade in time               */dcl Stack.Fout     lit 'Stack.Record(17)';  /* fade out time              */dcl Stack.Evbits   lit 'Stack.Record(18)';  /* event bits from record     */dcl Stack.Spare1   lit 'Stack.Record(19)';  /* spare 1 (pk volume)        */dcl Stack.Spare2   lit 'Stack.Record(20)';  /* spare 2 (sus volume)       */dcl Stack.Spare3   lit 'Stack.Record(21)';  /* spare 3                    */dcl Stack.Spare4   lit 'Stack.Record(22)';  /* spare 4                    */dcl Stack.Spare5   lit 'Stack.Record(23)';  /* spare 5                    */dcl Stack.Ext.In   lit 'loc(addr(Stack.Record(24)))'; /* extract region   */dcl Stack.Ext.Out  lit 'loc(addr(Stack.Record(26)))'; /* in & out times   */dcl Stack.To.Time  lit 'loc(addr(Stack.Record(28)))'; /* play to limit    */