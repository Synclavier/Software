/* TALKSOUC -  process synclav message *//* returns true if it is ok to record in current song *//* procedure is called when main synclavier has selected the Live Overdub *//* via SCSI.   This code scans an input message from the Synclav,  and    *//* then sends an answer message                                           */dcl scrollmode               fixed;  /* alph.sort = scroll through whole disk.  cs.alph.sort = scroll through current song *//* $page - subroutines for cue list scrolling *//* called from Process.Synclav.Msg to assist in scrolling *//* though cue directory                                   */get.next.forward.cue:proc(type) inc.multi.udio.swapable; /* routine for cue scrolling  */   dcl (type)    fixed;   dtd.cue#=0;                   /* assume end of list reached */   cc.rlen=0;                    /* in case no cue             */   if current.dtd.cue#<>0        /* advance if one found       */   then cur.ix(type)  = cur.ix(type) + 1;   if cur.ix(type) ige num.of(type)   then do;      if num.of(type)<>0 then cur.ix(type) = num.of(type)-1;      else                    cur.ix(type) = 0;   end;   else do;      dtd.cue#=get.sort.cue(type,cur.ix(type));      if dtd.cue# <> 0 then do;           /* one found            */         call lookup.cur.cue(dtd.cue#);   /* get record           */         if cc.rlen=0 then dtd.cue#=0;    /* see if was bad       */         else do;            call convert.basic.record.to.msecs(current.cue);            current.dtd.cue# = dtd.cue#;  /* save for update??    */         end;      end;   end;   send.dtd.cue=cc.rlen + 1;end get.next.forward.cue;get.next.prior.cue:proc(type) inc.multi.udio.swapable;   dcl (type) fixed;   dtd.cue#=0;                   /* assume end of list reached */   cc.rlen=0;                    /* in case no cue             */   cur.ix(type)  = cur.ix(type) - 1;   if cur.ix(type) >= num.of(type)       /* do not use ige here */   then cur.ix(type)  =  num.of(type)-1;   if cur.ix(type) < 0    then do;      cur.ix(type) = 0;   end;   else do;      dtd.cue#=get.sort.cue(type,cur.ix(type));      if dtd.cue# <> 0 then do;           /* one found            */         call lookup.cur.cue(dtd.cue#);   /* get record           */         if cc.rlen=0 then dtd.cue#=0;    /* see if was bad       */         else do;            call convert.basic.record.to.msecs(current.cue);            current.dtd.cue# = dtd.cue#;  /* save for update??    */         end;      end;   end;   send.dtd.cue=cc.rlen + 1;end get.next.prior.cue;return.search.result:proc inc.multi.udio.swapable;   current.dtd.cue# = dtd.cue#;       /* save cue# if any */   if dtd.cue#<>0 then do;            /* return a value   */      call lookup.cur.cue(dtd.cue#);  /* get cue          */      if cc.rlen=0 then dtd.cue#=0;    /* see if was bad       */      else do;         call find.cue.indexes(dtd.cue#,current.cue,scrollmode);         call lookup.cur.cue(dtd.cue#);  /* get cue again */         call convert.basic.record.to.msecs(current.cue);      end;   end;   else cc.rlen=0;                 /* no cue id, no cue */   send.dtd.cue=cc.rlen + 1;end return.search.result;return.nth.cue:proc(type,ix) inc.multi.udio.swapable;   dcl (type) fixed;   dcl (ix  ) fixed;   dtd.cue# = get.sort.cue(type,ix);   current.dtd.cue# = dtd.cue#;   if dtd.cue# <> 0 then do;       /* make sure in range */      call lookup.cur.cue(dtd.cue#);  /* get cue        */      call convert.basic.record.to.msecs(current.cue);   end;   else cc.rlen=0;                  /* only send cue# */   send.dtd.cue=cc.rlen + 1;end return.nth.cue;   /* Check Multi Track DDT Directions is called whenever the track  *//* safe/ready or input/repro settings are changed.  If we are     *//* in the process of doing multi track direct digital xfers,      *//* we might have to change the direction of a box if the          *//* mode & status settings change.  This routine looks through     *//* all the ports with DDT boxes and makes sure they are going     *//* in the right direction.  If they are not, the new.dtd.song#    *//* is set so they will get reloaded with the correct              */Check.Multi.Track.DDT.Direction: proc swapable;	#if (inc.multi.udio)  	 	dcl i fixed;				if  (DDT.Hardware.Avail <> 0)    /* if ddt hardware avail    */		and (DDT.Connect.Mode   <> 0)    /* in mutli trk config      */		and ((Dig.Xfer.Mode & (Dig.In \ Dig.Out)) <> 0) /* doing ddt */		then do i = 0 to max.ports-1;			if (port.ddt(i) <> 0)			then do;				if (look.up.port.ddt.direction(i) <> (Port.DDT.Mode(i) & FE_Dir_In))				then new.dtd.song# = 1;			end;		end;	#endifend Check.Multi.Track.DDT.Direction;/* $page - handle directory scrolling */Handle.Directory.Non.Data.Commands:proc swapable;   dcl (i,j,k,l,m)       fixed;   dcl (a,b,c,d,z)  (1)  fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';   dcl cmsb    lit  'c(0)';   dcl clsb    lit  'c(1)';   dcl dmsb    lit  'd(0)';   dcl dlsb    lit  'd(1)';   do case (scsi.in.msg-10);      do;                              /* 10: down arrow              */         if screen=1 then do;          /* song directory active       */            dtd.song#=dtd.song#+1;            if dtd.song#=10 then do;   /* scroll at bottom of screen  */               if song.base+dtd.song#<num.songs               then do;                  song.base=song.base+5;                  dtd.song#=dtd.song#-5;               end;               else dtd.song#=dtd.song#-1;            end;            call invalidate.track.dir; /* read in new one             */         end;         if screen=2 then do;          /* track directory active       */            dtd.track#=dtd.track#+1;            if dtd.track#=max.tracks then dtd.track#=dtd.track#-1;            call track.error.check;         end;         send.screen.info=1;           /* send screen info            */      end;      do;                              /* 11: up   arrow              */         if screen=1 then do;          /* song directory active       */            dtd.song#=dtd.song#-1;            if dtd.song#<0 then do;    /* scroll at top of screen  */               if song.base>0               then do;                  song.base=song.base-5;                  dtd.song#=dtd.song#+5;               end;               else dtd.song#=0;            end;            call invalidate.track.dir; /* read in new one             */         end;         if screen=2 then do;          /* track directory active     */            dtd.track#=dtd.track#-1;            if dtd.track#<0 then dtd.track#=0;            call track.error.check;         end;         send.screen.info=1;           /* send screen info           */      end;      do;                              /* 12: select song directory  */         screen=1;         send.screen.info=1;           /* send screen info           */         send.init.info  =1;      end;      do;                              /* 13: select track directory */         screen=2;         send.screen.info=1;           /* send screen info           */         send.init.info  =1;      end;      /* $page - process synclavier messages for directores: */      do;                              /* 14: toggle status          */         call song.lookup;         s.status=s.status xor 2;      /* lock/unlock                */         call song.store;      end;      do;                              /* 15: home cursor            */         if screen=1 then do;          /* song directory active      */            dtd.song#=0;            song.base=0;            call invalidate.track.dir; /* read in new one             */         end;         if screen=2 then do;          /* track directory active     */            dtd.track#=0;            call track.error.check;         end;         send.screen.info=1;           /* send screen info           */      end;      do;                              /* 16: toggle repro/input/auto*/         call track.lookup;         if track.avail.and.ready<>0         then do;                      /* change repro/input/auto  */            t.ria=t.ria+1;            if t.ria>=4 then t.ria=0;            /* allow cue pb */            call track.store;            call Check.Multi.Track.DDT.Direction;            if  ((t.ria=1) or (t.ria=2))/* input or auto            */            and (t.input=0)             /* but no input             */            and (log.buf(0)=0)          /* log.buf is empty         */            then do;               call log.error('Warning: Track ');               call append.decimal.number(dtd.track#+1);               call append.log.string(' Has No Input Channel');            end;            call handle.ria.change(dtd.track#);     /* handle real time rep-inp-aut change */         end;      end;      do;                              /* 17: toggle safe/ready     */         call song.lookup;         call track.lookup;         if  (track.avail.and.ready<>0)         then do;                      /* change safe/ready         */            if  ((s.status&2)<>0)      /* if song is locked         */            and ((t.sr    &1) =0)      /* and making track ready    */            then call log.error('Project is Lock Protected');            else if ((t.sr&2)<>0)            then call log.error('Track is Locked');            else do;               t.sr = t.sr xor 1;               call track.store;               call Check.Multi.Track.DDT.Direction;               new.armd.tracks = new.armd.tracks \ bits(dtd.track#);               if this.track.shares.an.input(dtd.track#) <> 0               then new.inputs=1;            end;         end;      end;      do;                              /* 18: send Allocation dir   */         do j=0 to 255;                /* zero out current.cue      */            current.cue(j)=0;         end;         i=0;                          /* convert adir to seconds   */         j=0;         k=dtd.track#*adir.len;        /* base adir pointer         */         do while i<>256;            call gadir(k);            if (read(mdi)\read(mdi))<>0 then do;               call gadir(k);               a(0) = read(mdi); a(1) = read(mdi);               current.cue(j  )=compute.start.time(a);               call gadir(k+2);               a(0) = read(mdi); a(1) = read(mdi);               current.cue(j+1)=compute.start.time(a);               j=j+2;            end;            i=i+4;            k=k+4;         end;         send.dtd.cue = 257; /* 128 data words in current.cue */         dtd.cue#     = 0;      end;      /* $page - directory line insert, append, delete */      do;                              /* 19: delete song line          */         call song.lookup;         if (s.status&2)<>0         then call log.error('Project is Locked - Cannot Delete');         else if (s.status&1)<>0       /* non-empty                 */         then call log.error('Must Erase Project before Delete');         else if track.dir.valid=0         then call log.sys.is.not.ready;         else if any.track.recording.or.new.adir<>0         then call log.error('Cannot Delete Project While Recording');         else if (command.#<>0)         or      (command.in<>command.out)         then call log.error('Delete Not Allowed while Backup/Load in Process');         else do;            call init.track.dir;       /* erase all track info      */            track.dir.updated = 1;     /* but indicate updated to write out all blanks */            call init.song.entry;      /* erase song info ,but save index # */            call shuffle.song.dir.down;/* perform shuffle           */            song.dir.updated=1;        /* write back out some time  */            call invalidate.track.dir; /* will need new track dir   */            send.screen.info=1;        /* send screen info          */         end;      end;      do;                              /* 20: append song line          */         if any.track.recording.or.new.adir<>0         then call log.error('Cannot Append Project Entry While Recording');         else if track.dir.updated<>0  /* make sure nothing waiting */         then call log.sys.is.not.ready;         else if (command.#<>0)         or      (command.in<>command.out)         then call log.error('Append Not Allowed while Backup/Load in Process');         else if room.in.song.dir<>0   /* make sure room in song    */         then do;                      /* dir (top entry blank)     */            if (song.base+dtd.song#)<(num.songs-1)            then do;                   /* move down one line for +  */               dtd.song#=dtd.song#+1;               if dtd.song#=10 then do;   /* scroll at bottom of screen */                  song.base=song.base+5;                  dtd.song#=dtd.song#-5;               end;            end;            call shuffle.song.dir.up;     /* make room for entry        */            call init.song.entry;         /* erase song info            */            song.dir.updated=1;           /* write to disk              */            call init.track.dir;          /* erase all track info       */            track.dir.updated = 1;        /* but indicate updated to write out all blanks */            track.dir.valid   = 1;        /* is actually valid          */            track.dir.song    = song.base+dtd.song#;     /* us          */            send.screen.info  = 1;        /* send screen info           */            new.dtd.song#     = 1;        /* look up new song items     */         end;      end;      do;                              /* 21: insert song line          */         if any.track.recording.or.new.adir<>0         then call log.error('Cannot Insert Project Entry While Recording');         else if track.dir.updated<>0  /* make sure nothing waiting */         then call log.sys.is.not.ready;         else if (command.#<>0)         or      (command.in<>command.out)         then call log.error('Insert Not Allowed while Backup/Load in Process');         else if room.in.song.dir<>0   /* make sure room in song     */         then do;                      /* dir (top entry blank)      */            call shuffle.song.dir.up;  /* make room for entry        */            call init.song.entry;      /* erase song info            */            song.dir.updated=1;        /* write to disk              */            call init.track.dir;       /* erase all track info       */            track.dir.updated = 1;     /* but indicate updated to write out all blanks */            track.dir.valid   = 1;     /* is actually valid          */            track.dir.song    = song.base+dtd.song#;  /* here        */            send.screen.info  = 1;     /* send screen info           */            new.dtd.song#     = 1;     /* look up new song items     */         end;      end;      do;                              /* 22: simple disk debug */         ddutrk=256;         ddusec=0;         send.screen.info=1;      end;   end;end Handle.Directory.Non.Data.Commands;Handle.Directory.Cue.Commands:proc inc.multi.udio.swapable;	dcl i fixed;	   do case (scsi.in.msg-23);      do;                              /* 23: null command */      end;      do;                              /* 24: get next forward alphabetic cue */         call get.next.forward.cue(scrollmode);      end;      do;                              /* 25: get next prior   alphabetic cue */         call get.next.prior.cue(scrollmode);      end;      do;                              /* 26: get next forward cue in time order */         call get.next.forward.cue(scrollmode+1);      end;      do;                              /* 27: get next prior cue in time order */         call get.next.prior.cue(scrollmode+1);      end;      do;                              /* 28: re-read current cue */         cc.rlen=0;                    /* in case no cue             */         if get.cue.ptrs(current.dtd.cue#)   /* make sure valid      */         then do;            dtd.cue# = current.dtd.cue#;            call lookup.cur.cue(dtd.cue#);   /* get record           */            if cc.rlen=0 then dtd.cue#=0;    /* see if was bad       */            else do;               call convert.basic.record.to.msecs(current.cue);            end;         end;         else dtd.cue#=0;         send.dtd.cue=cc.rlen + 1;      end;      do;             /* 29: send init info and cue info */         send.init.info=1;      end;      do;             /* 30: see if current song ready for command */         if (track.dir.valid=0) or (new.dtd.song#<>0) then dtd.cue#=0;         else                                              dtd.cue#=1;         send.dtd.cue=1;  /* send cue id# only */      end;      do;            /* 31: get next forward smpt bit sorted cue */         call get.next.forward.cue(scrollmode+2);      end;      do;            /* 32: get next prior smpt  */         call get.next.prior.cue(scrollmode+2);      end;      do;            /* 33: done with all read track info */         if dspdebug then do;            disable;            print 'SYNCLAVIER SETTING FUNC TO 0';            enable;         end;         call zap.read.track.info.tracks;         func       = 0;         new.inputs = 1;      end;      do;            /* 34: get current cross fade setting info */         call song.lookup;  /* get info for current song */         dtd.cue# = 0;         do i=0 to 15;            current.cue(i)=0;         end;         current.cue(0) = s.fade;         current.cue(1) = s.rate;         current.cue(2) = s.used;         current.cue(3) = pwlen;   /* cross fade word length */         send.dtd.cue=17;      end;   end;end Handle.Directory.Cue.Commands;