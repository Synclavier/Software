/* :LOD:MISCSOU - misc procedures for LOD Operating System *//*modified:2000/01/23 - TY  - Added ratio_multiply (3 times faster than RATIOMULTIPLY)1991/08/14 - cj  - added creg_avail1991/03/11 - cj  - Added routines for project info printout1988/02/09 - cj  - fixed AEE bugs with 31.9, 44.0, 47.9, 88.1, 95.9 KHZ*/module miscmod;insert ':lod:lodlits:globlits'; /* get main literals                */insert ':lod:lodlits:xmemlits'; /* get xmem allocation literals     */insert ':lod:lodlits:dbuglits'; /* get dbug literals                */dcl misc.buf   (512)         fixed PUBLIC;   /* general purpuse temp array		*/dcl Synclav.software.version fixed PUBLIC;   /* which RTP version is active	*/dcl creg_avail               lit   '0';      /* true if d130 avail (ddsad)		*/dcl bits data public (1,    2,    4,     8,                      16,   32,   64,    128,                      256,  512,  1024,  2048,                      4096, 8192, 16384, 32768);/* Special variables for main loop needed by several modules: */dcl Status.Tracks    fixed PUBLIC;  /* bits for tracks needing LED updates		*/dcl Send.Init.Info   fixed PUBLIC;  /* 1: send init info to syncl some time	*/dcl Send.Screen.Info fixed PUBLIC;  /* 1: send directory info to syncl			*/dcl Get.New.Motion   fixed PUBLIC;  /* request new motion							*/dcl Screen           fixed PUBLIC;  /* 1: user is on song directory screen		*/                                    /* 2: user is on trk  directory screen		*/dcl Buf.Len          fixed PUBLIC;  /* Buffer size in use							*/dcl Rec.Base         fixed PUBLIC;  /* Offset from playback to record buffer	*/dcl Tracks.Per.Port  fixed PUBLIC;  /* holds # of trks on each port				*//* $SUBTITLE  32 BIT MATH ROUTINES *//* store (msb,lsb) into dst32 */str32:proc(msb,lsb,dst32) public;   dcl msb fixed;   dcl lsb fixed;   dcl dst32 fixed array;                                 dst32(lw#msb) = msb;   dst32(lw#lsb) = lsb;end str32;/* adds 16-bit unsigned num16 into dst32 */add16:proc(num16,dst32) public;   dcl num16 fixed;   dcl dst32 fixed array;                                 dst32(lw#lsb) = dst32(lw#lsb) + num16;   if dst32(lw#lsb) ilt num16   then dst32(lw#msb) = dst32(lw#msb) + 1;end add16;/* subtracts 16-bit unsigned num16 from dst32 */sub16:proc(num16,dst32) public;   dcl num16 fixed;   dcl dst32 fixed array;                                 if dst32(lw#lsb) ilt num16   then dst32(lw#msb) = dst32(lw#msb) - 1;   dst32(lw#lsb) = dst32(lw#lsb) - num16;end sub16;dcl copy32 proc (array,array);/* add1 + add2 into dst */add32:proc(add1,add2,dst) public;   /* routines could be speed up by */   dcl add1 fixed array;            /* assembly language later if    */   dcl add2 fixed array;            /* desired.   add32 works on     */   dcl dst fixed array;             /* signed or unsigned 32 bit     */   dcl r (1) fixed;                 /* numbers                       */   r(lw#msb) = add1(lw#msb) + add2(lw#msb);   r(lw#lsb) = add1(lw#lsb) + add2(lw#lsb);   if r(lw#lsb) ilt add1(lw#lsb)   then r(lw#msb) = r(lw#msb) + 1;   call copy32(r,dst);                       /* 'r' copes with add1 = add2 = dst      */end add32;/* src - num into dst */sub32:proc(src,num,dst) public;    /* sub32 is only correct for     */   dcl src fixed array;            /* unsigned 32 bit numbers       */   dcl num fixed array;            /* but it yields a signed        */   dcl dst fixed array;            /* 32 bit difference             */   dcl borrow fixed;   borrow = 0;   if src(lw#lsb) ilt num(lw#lsb) then borrow = 1;   dst(lw#msb) = src(lw#msb) - num(lw#msb) - borrow;   dst(lw#lsb) = src(lw#lsb) - num(lw#lsb);end sub32;/* comparison:       *//* a < b  returns lw#ilt (-1) *//* a = b  returns lw#ieq (0)  *//* a > b  returns lw#igt (+1) */com32:proc(a,b) public;       /* com32 performs an unsigned    */   dcl a fixed array;         /* comparison                    */   dcl b fixed array;   if a(lw#msb) ilt b(lw#msb) then return (lw#ilt);   if a(lw#msb) igt b(lw#msb) then return (lw#igt);   if a(lw#lsb) ilt b(lw#lsb) then return (lw#ilt);   if a(lw#lsb) igt b(lw#lsb) then return (lw#igt);   return (lw#ieq);end com32;/* compare (a16 = 16 bits) with (b32 = 32 bits unsigned) */com16:proc(a16,b32) public;     /* com16 performs an unsigned    */   dcl a16 fixed;               /* comparison                    */   dcl b32 fixed array;   if b32(lw#msb) igt 0         or b32(lw#lsb) igt a16        then return (lw#ilt);   if a16 IGT b32(lw#lsb) then return (lw#igt);   return (lw#ieq);end com16;/* 32 bit copy src -> dst */copy32:proc(src,dst) public;   dcl src fixed array;   dcl dst fixed array;   dst(lw#msb) = src(lw#msb);   dst(lw#lsb) = src(lw#lsb);end copy32;/* shift num left by amount */shl32:proc(num,amount) public;   dcl num fixed array;   dcl amount fixed;   dcl i fixed;   if amount = 8 then do;    /* speedy check for shl by 8 */      num(lw#msb) = shl(num(lw#msb),8)\shr(num(lw#lsb),8);      num(lw#lsb) = shl(num(lw#lsb),8);   end;   else do i=1 to amount;      call add32(num,num,num);   end;end shl32;/* shift num right by amount */shr32:proc(num,amount) public;   dcl num fixed array;   dcl amount fixed;   dcl (i,bit) fixed;   if amount = 8 then do;    /* speedy check for shr by 8 */      num(lw#lsb) = shr(num(lw#lsb),8)\shl(num(lw#msb),8);      num(lw#msb) = shr(num(lw#msb),8);   end;   else do i=1 to amount;      if num(lw#msb) then bit = "100000";      /* if msb is odd... */      else bit = 0;      num(lw#msb) = shr(num(lw#msb),1);      num(lw#lsb) = shr(num(lw#lsb),1) \ bit;  /* ...lsb needs that bit */   end;end shr32;round32:proc(num) public;      /* routine to round up by 128 samples */   dcl num array;   call ADD16(128,num);   num(lw#lsb) = num(lw#lsb) & "177400";end round32;/* Read and write 32-bit variables from external memory: */READ32:proc(base,ptr,tmp) public;   dcl base fixed;   dcl ptr  fixed;   dcl tmp  array;   write(mam) = base + shr(ptr,8);   write(mal) = ptr;   tmp(0) = read(mdi);   tmp(1) = read(mdi);end READ32;WRITE32:proc(base,ptr,tmp) public;   dcl base fixed;   dcl ptr  fixed;   dcl tmp  array;   write(mam) = base + shr(ptr,8);   write(mal) = ptr;   write(mdi) = tmp(0);   write(mdi) = tmp(1);end WRITE32;/* $page MULTI-PRECISION MULTIPLY SUBROUTINE *//* MULTIPLY:   INPUTS :    32 BIT INTEGER   (BITMSB BITLSB)    (0-4,294,967,2XX)               64 BIT INTEGER   (A   B   C   D)    (0-65535.9999999)   OUTPUT:     48 BIT INTEGER   (BITMSB BITLSB).(MUL.LLSB)  *//* DECIMAL POINTS:   (BITMSB BITLSB)  =  32 BIT INTEGER LEFT OF DECIMAL POINT                     (A            )  =  16 BIT INTEGER LEFT OF DECIMAL POINT                     (    B   C   D)  =  48 BITS RIGHT       OF DECIMAL POINT                     SO: *//* OVERFLOW IS DETECTED - RETURNS  (-1) (-1) (-1) *//* ROUNDING IS PERFORMED */DCL BIT      (2)  FIXED PUBLIC;      /* 48-BITS OF PRECISION        */DCL BITMSB        LIT 'BIT(0)';      /* ALSO CALLED THIS SOME       */DCL BITLSB        LIT 'BIT(1)';      /* PLACES                      */DCL MUL.LLSB      LIT 'BIT(2)';MULTIPLY:PROC (A,B,C,D) PUBLIC;      /* SCALE BITMSB BITLSB BY A.BCD */   DCL (A,B,C,D)  FIXED;             /* ROUND INTO BITMSB, BITLSB    */   DCL (I,J)      FIXED;             /* FRACTIONAL PART IN MUL.LLSB  */   DCL (OV)       FIXED;   I=BITMSB; J=BITLSB; OV=0;   LOAD A; MUL I; BITMSB=RES;        /* A*I      */   IF READ(4)<>0 THEN OV=1;          /* OVERFLOW */   LOAD A; MUL J;                    /* A*J      */   BITMSB=BITMSB+READ(4);            /* ADD MSB  */   IF BITMSB ILT READ(4) THEN OV=1;  /* OVERFLOW */   BITLSB=RES;      LOAD B; MUL I;                    /* B*I */   BITMSB=BITMSB+READ(4);   IF BITMSB ILT READ(4) THEN OV=1;  /* OVERFLOW */   BITLSB=BITLSB+READ(5);   IF BITLSB ILT READ(5)   THEN DO;      BITMSB=BITMSB+1;      IF BITMSB=0 THEN OV=1;         /* OVERFLOW */   END;   LOAD B; MUL J;                    /* B*J */   BITLSB=BITLSB+READ(4);   IF BITLSB ILT READ(4)   THEN DO;      BITMSB=BITMSB+1;      IF BITMSB=0 THEN OV=1;         /* OVERFLOW */   END;   MUL.LLSB   =READ(5);   /* COMPUTE ADDITIONAL CROSS-PRODUCTS */   LOAD C; MUL I;                    /* C*I */   BITLSB=BITLSB+READ(4);   IF BITLSB ILT READ(4)   THEN BITMSB=BITMSB+1;   MUL.LLSB   =MUL.LLSB+READ(5);   IF MUL.LLSB ILT READ(5)   THEN DO;      BITLSB=BITLSB+1;      IF BITLSB=0      THEN BITMSB=BITMSB+1;   END;   LOAD C; MUL J;                    /* C*J */   MUL.LLSB=MUL.LLSB+READ(4);   IF MUL.LLSB ILT READ(4)   THEN DO;      BITLSB=BITLSB+1;      IF BITLSB=0      THEN DO;         BITMSB=BITMSB+1;         IF BITMSB=0 THEN OV=1;         /* OVERFLOW */      END;   END;   LOAD D; MUL I;                    /* D*I */   MUL.LLSB=MUL.LLSB+READ(4);   IF MUL.LLSB ILT READ(4)   THEN DO;      BITLSB=BITLSB+1;      IF BITLSB=0      THEN DO;         BITMSB=BITMSB+1;         IF BITMSB=0 THEN OV=1;         /* OVERFLOW */      END;   END;   /* LOAD D; MUL J; */              /* D*J - NOT USED */   /* NOW ROUND */   IF MUL.LLSB<0 THEN DO;            /* ROUND UP       */      BITLSB=BITLSB+1;      IF BITLSB=0      THEN DO;         BITMSB=BITMSB+1;         IF BITMSB=0 THEN OV=1;      END;   END;   IF OV<>0 THEN DO;            /* OVERFLOW */      BITMSB  =(-1);      BITLSB  =(-1);      MUL.LLSB=(-1);   END;END MULTIPLY;UNROUND:PROC PUBLIC;                 /* PROCEDURE TO PROVIDE TRUNCATED RESULT */   IF MUL.LLSB<0 THEN DO;            /* REMOVE ROUND UP       */      BITLSB=BITLSB-1;      IF BITLSB=(-1)      THEN DO;         BITMSB=BITMSB-1;      END;   END;END UNROUND;/* $PAGE - RATIO MULTIPLY *//* RATIOMULTIPLY -   COMPUTE  (BITMSB,BITLSB) * (NUM/DENOM) */RATIOMULTIPLY:PROC(NUM,DENOM) PUBLIC;   DCL (NUM,DENOM)     FIXED;   DCL (I,S1,S2,S3,S4) FIXED;   IF DENOM=0 THEN DENOM=1;            LOAD NUM;  DIV  DENOM; S1=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S2=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S3=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S4=RES;   CALL MULTIPLY(S1,S2,S3,S4);END RATIOMULTIPLY;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE ratio_multiply													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/ratio_multiply: proc (num,den) public;	dcl (num,den)	fixed;	//	multiply up to 48-bit, then divide back down to 32 bit	load BITLSB;	mul num;	BITLSB = res; write("313") = ures;	load BITMSB; uload read("313");	mul num; mwait;	div den;	BITMSB = res; write("313") = rem;	load BITLSB; uload read("313");	div den;	BITLSB = res; write("313") = rem;	//	round: the fdiv method	load 0; uload read("313");	div den;	if (res < 0) {		BITLSB = BITLSB+1;		if (BITLSB == 0) BITMSB = BITMSB+1;	//	carry	}	MUL.LLSB = res;	//	for possible later use by UNROUND()end ratio_multiply;/* $page - D03 Millisecond Timer Routine */dcl real.milliseconds        fixed PUBLIC;   /* counts msecs off of d03     */dcl real.seconds             fixed PUBLIC;   /* counts secs  off of d03     */when d03int then begin;                   /* basically only used to detect  */   dcl prior fixed static;   real.milliseconds=real.milliseconds+5; /* disk timeouts, etc.   not used */   if real.milliseconds >= prior + 1000   then do;                               /* count seconds as well for long timers */      prior = prior + 1000;      real.seconds = real.seconds + 1;   end;end;                                      /* as part of sync-up code        *//* $page - d16 timer routine *//* The Direct-to-Disk software contains code that precisely synchronizes *//* the direct to disk with an external synclavier.  To accomplish this,  *//* we use our internal d16 timer to measure precise time intervals       *//* from a point where the two time bases were synchronized.              *//*                                                                       *//* Our.time.msb, our.time.lsb form a 32-bit time base variable that      *//* can be measured at any time by calling get.d16.time.                  *//* The routine is called at least once during the main loop so that      *//* the counter does not overflow before we read it.                      */dcl (Our.Time)       (1)      fixed PUBLIC; /* holds 32-bit d16 time base    */Get.D16.Time: proc PUBLIC;   call ADD16(read(d16)-Our.Time(1), Our.Time);end Get.D16.Time;/* $page - Basic External Memory Routines *//* Poll.For.External.Memory interrogates the hardware to see how much *//* memory is in the system.   The number of sectors of this memory    *//* is returned.                                                       */POLL.FOR.EXTERNAL.MEMORY:  PROC PUBLIC;    /* DETERMINE THE AMOUNT OF M128K MEMORY AVAILABLE */   DCL AMOUNT FIXED;   IF (READ("51") and "1000") = 0 THEN RETURN (0); /* NO D60'S AT ALL */   WRITE(MAM) = 1;                       /* SELECT PAGE 1             */   IF READ(MAM) <> 1 THEN RETURN (0);    /* FIRST BOARD NOT PRESENT   */   WRITE(MD) = 0;                        /* WRITE DATA OF ALL ZEROES  */   IF READ(MD) <> 0 THEN RETURN (0);     /* FIRST HALF IS NOT STUFFED */   WRITE(MD) = (-1);                     /* TRY ALL ONES              */   IF READ(MD) <> (-1) THEN RETURN (0);  /* FIRST HALF IS NOT STUFFED */   AMOUNT = 256;                         /* FIRST HALF IS PRESENT */   DO WHILE AMOUNT ilt (-256);      WRITE(MAM) = AMOUNT; /* SELECT MEMORY PAGE */      IF READ(MAM) <> AMOUNT THEN DO;          WRITE(MAM) = 0;          RETURN (AMOUNT);       END;      WRITE(MD) = 0; /* STORE A ZERO THERE */      IF READ(MD) <> 0 THEN DO;          WRITE(MAM) = 0;          RETURN (AMOUNT);       END;      WRITE(MD) = -1; /* STORE ALL ONES AS WELL */      IF READ(MD) <> (-1) THEN DO;          WRITE(MAM) = 0;          RETURN (AMOUNT);       END;      AMOUNT = AMOUNT + 256; /* ADVANCE TO NEXT HALF A CARD */   END;   WRITE(MAM) = 0; /* RESET D60 REGISTER TO VALID ADDR */   RETURN (AMOUNT);END POLL.FOR.EXTERNAL.MEMORY;/* $page - user routines to access ext memory *//* The following routines are used to read/write data *//* in external memory.   They are mostly used to      *//* access the cue data base                           *//* They are modelled after a combination of the       *//* poly and external memories                         */dcl store.sec   fixed;   /* general purpose pointers  */dcl store.wrd   fixed;   /* to the cue storage area   */compute.store.ptrs:proc(sec,wrd) PUBLIC;   dcl (sec,wrd) fixed;   store.sec = sec + shr(wrd,8); /* normalize storage pointers */   store.wrd = wrd & 255;end compute.store.ptrs;read.store:proc(sec,wrd) PUBLIC; /* set up pointers to read storage */   dcl (sec,wrd) fixed;   call compute.store.ptrs(sec,wrd);   write(mam)=store.sec;   write(mal)=store.wrd;end read.store;read.word:proc PUBLIC;   return read(mdi);end read.word;read.len:proc(ptr,len) PUBLIC;   dcl (ptr,len) fixed;      write("313")=ptr;   do while len igt 256;      rpc 256;      write("373")=read(mdi);      len = len - 256;   end;   rpc len;   write("373")=read(mdi);end read.len;write.store:proc(sec,wrd) PUBLIC;  /* set up pointers to write storeage */   dcl (sec,wrd) fixed;   call compute.store.ptrs(sec,wrd);   write(mam)=store.sec;   write(mal)=store.wrd;end write.store;write.word:proc(val) PUBLIC;   dcl (val) fixed;   write(mdi)=val;end write.word;write.len:proc(ptr,len) PUBLIC;   dcl (ptr,len) fixed;   write("313")=ptr;   do while len igt 256;      rpc 256;      write(mdi)=read("373");      len = len - 256;   end;   rpc len;   write(mdi)=read("373");end write.len;/* $page - fast routine to copy info around *//* This routine performs a general purpose *//* data move in external memory            */move.store:proc(ssec,swrd,dsec,dwrd,slen,wlen) PUBLIC;   dcl ssec   fixed;   /* source sector address      */   dcl swrd   fixed;   /* source word address        */   dcl dsec   fixed;   /* destination sector address */   dcl dwrd   fixed;   /* destination word address   */   dcl slen   fixed;   /* sector length of copy      */   dcl wlen   fixed;   /* word length of copy        */   dcl i      fixed;   dcl copy.len lit '128';   dcl copy.buf (copy.len-1) fixed automatic;   ssec=ssec+shr(swrd,8); swrd=swrd&255; /* normalize things */   dsec=dsec+shr(dwrd,8); dwrd=dwrd&255;   slen=slen+shr(wlen,8); wlen=wlen&255;   if ((ssec=dsec) and (swrd=dwrd))    /* if data is in place */   or ((slen=0   ) and (wlen=0   ))    /* or not moving anything */   then return;   if  (ssec igt dsec)                 /* if copying down */   or  ((ssec =  dsec)    and  (swrd igt dwrd))    then do;      do while (slen<>0) or (wlen<>0);         if slen<>0 then i=256;         else            i=wlen;         if i igt copy.len then i = copy.len;         call read.store(ssec,swrd);         call read.len (addr(copy.buf(0)),i);         call write.store(dsec,dwrd);         call write.len(addr(copy.buf(0)),i);         wlen = wlen - i;         swrd = swrd + i;         dwrd = dwrd + i;         if wlen<0 then do;            wlen=wlen+256;            slen=slen-1;         end;         ssec=ssec+shr(swrd,8); swrd=swrd&255; /* normalize things */         dsec=dsec+shr(dwrd,8); dwrd=dwrd&255;      end;   end;   else do; /* copy up from the top down */      swrd=swrd+wlen; dwrd=dwrd+wlen;   /* compute pointers to the top */      ssec=ssec+slen+shr(swrd,8); swrd=swrd&255;      dsec=dsec+slen+shr(dwrd,8); dwrd=dwrd&255;      do while (slen<>0) or (wlen<>0);         if slen<>0 then i=256;         else            i=wlen;         if i igt copy.len then i = copy.len;         wlen = wlen - i;         swrd = swrd - i;         dwrd = dwrd - i;         if wlen<0 then do;            wlen=wlen+256;            slen=slen-1;         end;         if swrd<0 then do;            swrd=swrd+256;            ssec=ssec-1;         end;         if dwrd<0 then do;            dwrd=dwrd+256;            dsec=dsec-1;         end;         call read.store(ssec,swrd);         call read.len(addr(copy.buf(0)),i);         call write.store(dsec,dwrd);         call write.len(addr(copy.buf(0)),i);      end;   end;end move.store;/* $PAGE - routines to log error mesages on SYNTABULATOR *//* the live overdub computer can present error messages on   the main synclavier.   Error messages are constructed   in log.buf,  and sent to the synclavier whenever it   checks in. *//* NOTE: the log routines cannot swap because they are used to *//* print error messages (maybe) before the swap file is loaded *//* such as NO EXTERNAL MEMORY                                  */dcl log.buf(64) fixed PUBLIC;log.error: proc(msg)  PUBLIC;                     /* log error on main synclavier */   dcl msg array;   dcl i fixed;   if xdebug then do;      print;      print string(msg),;   end;   /* Only one message at a time can be sent to synclavier: */   if log.buf(0)<>0 then return 0;   /* Store message in log.buf so it will be sent over      */   /* later:                                                */   do i=0 to shr(msg(0)+1,1);      log.buf(i)=msg(i);   end;   return 1;end log.error;append.log.character: proc (ch) PUBLIC;   dcl ch fixed;      if xdebug then print character(ch),;   if log.buf(0)>=128 then return 0;   call pbyte(log.buf,log.buf(0),ch);   log.buf(0)=log.buf(0)+1;   if log.buf(0) then call pbyte(log.buf,log.buf(0),0);end append.log.character;append.log.string: proc (str) PUBLIC;   dcl str array;   dcl i fixed;   do i=0 to str(0)-1;      call append.log.character(byte(str,i));   end;end append.log.string;append.decimal.number: proc (status) PUBLIC swapable;  /* append number to string */   dcl status fixed;   dcl (i)    fixed;   dcl (j)    fixed;   j=0;   if status<0 then do;      call append.log.string('-');      status=(-status);   end;   i=10000;   do while i<>0;      load status; div i;       status=ures;      if res<>0 then j=1;      if i   =1 then j=1;      if (j<>0) then call append.log.character(48+res);      load i; div 10; i=res;   end;end append.decimal.number;/* used for STM inputs 1a, 1b, 1c, etc. */append.input.number: proc (i) PUBLIC swapable;   dcl (i)    fixed;   load i-1; div 4;   call append.log.character(48+res+1);   load i-1; div 4;   call append.log.character(65+rem  );end append.input.number;append.octal.number: proc (status) PUBLIC swapable;  /* append number to string */   dcl status fixed;   dcl (i,j,k)  fixed;   i="100000";   do while i<>0;      load status; div i;       status=ures;      call append.log.character(48+res);      load i; div  8; i=res;   end;end append.octal.number;append.min.sec: proc (minsec) PUBLIC swapable;  /* append min:sec to string */   dcl minsec fixed;   dcl (i,j)  fixed;   load minsec; div 60;   i = res; j = rem;          /* get minutes, seconds */   call append.decimal.number( i );   call append.log.string    (':');   load j; div 10;   i = res; j = rem;   call append.log.character(48 + i);   call append.log.character(48 + j);end append.min.sec;append.khz: proc (khz) PUBLIC swapable;  /* append khz to string */   dcl khz fixed;   dcl (i,j)  fixed;   load khz; div 10;   i = res; j = rem;          /* get khz, tenths */   call append.decimal.number( i );   if j <> 0 then do;      call append.log.string   ( '.'  );      call append.log.character(48 + j);   end;   call append.log.string   (' Khz');end append.khz;/* $page - variables for song and track directory */dcl (song.dir.valid )    fixed PUBLIC;  /* 1: song dir has been read in            */dcl (track.dir.valid)    fixed PUBLIC;  /* 0: must read in track directory         */dcl (cue.dir.valid)      fixed PUBLIC;  /* 0: must read in cue directory (et al) */cue.dir.valid=1;                        /* this should be 1 by default - only set to zero by scsi command from outside source ie the mac */dcl adir.inval.trks      fixed PUBLIC;  /* the adirs for these tracks need to be read in also */dcl (new.dtd.song#  )    fixed PUBLIC;  /* set when dtd.song# changes              */dcl (new.inputs     )    fixed PUBLIC;  /* set when input routing/gain changes     */dcl (song.dir.updated )  fixed PUBLIC;  /* nonzero - update song directory to disk */dcl (track.dir.updated)  fixed PUBLIC;  /* nonzero - update trk  directory to disk */dcl (track.dir.song   )  fixed PUBLIC;  /* song# which track directory goes with   *//* a 50-entry song directory is maintained by the live overdub software.   this directory contains one entry for each song.   the directory is presented to the user 10 lines at a time.   Song.Base contains the top of screen song pointer (start with 0).   dtd.song# contains the song # (0-9) that is the current song   on the screen.   the current song is song.base+dtd.song#.   it can change rather   unexpectedly if the user is madly typing arrow keys. */dcl song.base    fixed PUBLIC;      /* top of screen song# 0-40  */dcl dtd.song#    fixed PUBLIC;      /* song line 0-9             *//* Data Storage: *//* amount of song directory used = (num.songs+1)*song.len *//* Routine to look up word of song directory from external memory */gsong.dir: proc(loca) PUBLIC;   dcl loca fixed;   write(mam)=song.xmsec# + shr(loca,8);   write(mal)=loca;   return read(md);end gsong.dir;/* Global variables to hold current song directory entry: */dcl s.item       fixed PUBLIC;  /* declare these items in order */dcl s.title (12) fixed PUBLIC;dcl s.start      fixed PUBLIC;dcl s.end        fixed PUBLIC;dcl s.rate       fixed PUBLIC;dcl s.used       fixed PUBLIC;dcl s.status     fixed PUBLIC;dcl s.modified   fixed PUBLIC;dcl s.index      fixed PUBLIC;dcl s.fade       fixed PUBLIC;dcl s.star       fixed PUBLIC;dcl s.unused1    fixed PUBLIC;dcl s.unused2    fixed PUBLIC;/* $Page Routines for song directory: *//* The song directory is stored out on each track of the disk *//* the following routines look up info for a particular       *//* song and store it in handy variables:                      */song.lookup: proc PUBLIC;     /* get info for current song    */   dcl (i,j) fixed;   i=(song.base+dtd.song#)*song.len;   call gsong.dir(i);   s.item      = read(mdi);   s.title(0)  = 24;   write("313")=addr(s.title(1));   rpc song.len-song.title;   write("373")=read(mdi);end song.lookup;song.store:proc PUBLIC swapable;       /* store infor for current song */   dcl i fixed;                        /* except for song name         */   i=(song.base+dtd.song#)*song.len;   call gsong.dir(i);   write(mdi) = s.item;   call gsong.dir(i+song.start);   write("313")=addr(s.start);   rpc song.fade+1-song.start;    /* write out start through fade only */   write(mdi) = read("373");   song.dir.updated=1;   send.screen.info=1;end song.store;/* $page - routines to shuffle song directory up and down */reitemize.song.directory: proc PUBLIC swapable;      /* call to re-itemize after shuffle/insert */   dcl i fixed;   do i=0 to num.songs-1;      call gsong.dir(i*song.len+song.item);      write(md)=i+1;   end;end reitemize.song.directory;/* Note on shuffling song directory:  *//* must blank out track directory     *//* and project information before     *//* calling                            */shuffle.song.dir.down:proc PUBLIC swapable;       /* used for delete function */   dcl (i,j,k) fixed;   i=(song.base+dtd.song#)*song.len;       /* compute ptr to cur. song */   j=(num.songs          )*song.len;       /* pointer to above end     */   /* Move information for the current song (which by now is all       */   /* blanks)  up to top of song directory.   Duplicate index # here   */   call move.store(song.xmsec#, i, song.xmsec#, j, 0, song.len);   /* Now copy the entire song directory down.   The index # for this  */   /* track directory will be used by project # 50 now                 */   call move.store(song.xmsec#,i+song.len,                   song.xmsec#,i,                   0,j-i);    track.dir.song = num.songs-1;      /* current entry is now up here, but index number has not changed */    call reitemize.song.directory;       /* provide new item numbers                                       */end shuffle.song.dir.down;shuffle.song.dir.up: proc PUBLIC swapable;       /* used for insert function */   dcl (i,k) fixed;   i=(song.base+dtd.song#)*song.len;     /* get pointer to current song */   /* fetch top-most track index sector #.   We will use the track      */   /* directory that is there                                           */   k = gsong.dir((num.songs-1)*song.len+song.index);   /* save top most track index */   /* copy entire song directory up */   call move.store(song.xmsec#,i,                   song.xmsec#,i+song.len,                   0,num.songs*song.len-i-song.len);   call gsong.dir(i+song.index);   write(md)=k;                      /* re-use top most index         */   call reitemize.song.directory;      /* provide new item  numbers tho */end shuffle.song.dir.up;/* $page - check for overlapping songs */dcl overlap.item#1     fixed;         /* save away overlap item for */dcl overlap.item#2     fixed;         /* possible error message     */dcl songs.overlap      fixed PUBLIC;  /* 1: song start and end times overlap     */check.for.song.overlap: proc PUBLIC swapable;   dcl (i,j,k,l,m,n,x) fixed;   songs.overlap = 0;           /* assume none do                          */   do i=0 to num.songs-1;       /* love these n-squared algorithms ?       */      k=gsong.dir(i*song.len+song.start);      l=gsong.dir(i*song.len+song.end  );      if l ilt k then do;       /* out of order in song directory?         */         x=k; k=l; l=x;      end;      if (k\l)<>0               /* compare if nonzero                      */      then do j=i+1 to num.songs-1;         m=gsong.dir(j*song.len+song.start);         n=gsong.dir(j*song.len+song.end  );         if (m\n)<>0 then do;   /* compare                                 */            if n ilt m then do; /* again,  out of order???                 */               x=m; m=n; n=x;            end;            if ((m ige k)&(m ilt l))  /* song 2 starts in middle of song 1 */            or ((n igt k)&(n ilt l))  /* song 2 ends   in middle of song 1 */            or ((k ige m)&(k ilt n))  /* song 1 starts in middle of song 2 */            or ((l igt m)&(l ilt n))  /* song 1 ends   in middle of song 2 */            then do;               songs.overlap  = 1;               overlap.item#1 = i;               overlap.item#2 = j;               return 1;            end;         end;      end;   end;   return 0;end check.for.song.overlap;/* $page - variables for track directory *//* for each song,  a directory of 16 tracks has been created *//* directory holds title, status info, track volume,         *//* etc.    this directory is stored on disk.   current       *//* directory is kept in memory.                              */dcl (dtd.track#) fixed PUBLIC;   /* current cursor row       */dcl (track.dir) (num.tracks*track.len) fixed PUBLIC;  /* main tdir              */dcl (alt.tdir ) (num.tracks*track.len) fixed PUBLIC;  /* for use by load/backup *//* global variables to hold current entry: */dcl t.title(8) fixed PUBLIC;   /* 16 char track title.  Stored in directory */                               /* with no length field,  space filled       */dcl t.sr       fixed PUBLIC;   /* lower half of track.stat:                 */                               /*    0 = safe                               */                               /*    1 = ready                              */                               /*    2 = locked                             */dcl t.ria      fixed PUBLIC;   /* Upper half of Track.Stat:                 */                               /*    0 = repro        */                               /*    1 = input        */                               /*    2 = auto         */                               /*    3 = cue playback */dcl t.used     fixed PUBLIC;   /* # of seconds of recording used @ 50 Khz   */dcl t.input    fixed PUBLIC;   /* upper half:         */                               /*    0 = STM          */                               /*    1 = DIG          */                               /*    2 = OUT          */                               /*    3 = TRK          */                               /* lower half          */                               /*    0 = no channel   */                               /*    else 1-16        */dcl t.gain     fixed PUBLIC;   /* input gain, 0 - 100.0               */dcl t.volume   fixed PUBLIC;   /* track volume0 - 100.0               */dcl t.pan      fixed PUBLIC;   /* track pan     -50 - +50             */dcl t.routs    fixed PUBLIC;   /* upper half:                         */                               /*    digital routing for this output  */                               /* lower half:                         */                               /*    voice output for this track      */                               /* Bits word:                          */                               /*    bits 0,1 = code for command      */                               /*               outstanding           */                               /*    bit 2    = 0 means early         */                               /*               directory with no     */                               /*               routing information   *//* format for track status:   lower half:     0=safe      1=ready      2=locked      upper half:     0=repro     1=input      2=auto     3=cue playback *//* $page - track directory routines */this.track.lookup: proc(track#) PUBLIC;   dcl (track#) fixed;   dcl (i,j)    fixed;   i=track#*track.len;   t.title(0)=16;   do j=0 to 7;      t.title(j+1)=track.dir(i+track.title+j);   end;   t.sr      =    track.dir(i+track.stat  )&255;   t.ria     =shr(track.dir(i+track.stat  ),8);   t.used    =    track.dir(i+track.used  );    t.input   =    track.dir(i+track.input );    t.gain    =    track.dir(i+track.gain  );    t.volume  =    track.dir(i+track.volume);    t.pan     =    track.dir(i+track.pan   );    t.routs   =    track.dir(i+track.routs );end this.track.lookup;/* Look UP Port DDT direction looks at the SAFE/READY and INPUT/REPRO *//* status for a pair of tracks.   If either track is ready or either  *//* track is in INPUT,  then a 1 is returned.                          */look.up.port.ddt.direction: proc(port#) PUBLIC swapable;   dcl port# fixed;   dcl i     fixed;   i = port# * tracks.per.port;      /* get first track# */   /* If first track has a DIG input and is READY or in INPUT mode ...      */   if  (( shr(track.dir((i  )*track.len+track.input) , 8  ) = 1 )  /* DIG   */   and  ((   (track.dir((i  )*track.len+track.stat ) & 255) = 1)   /* READY */   or    (shr(track.dir((i  )*track.len+track.stat ) , 8  ) = 1))) /* INPUT */   /* or second track has a DIG input and is READY or in INPUT mode ...     */   or  (( shr(track.dir((i+1)*track.len+track.input) , 8  ) = 1 )  /* DIG   */   and  ((   (track.dir((i+1)*track.len+track.stat ) & 255) = 1)   /* READY */   or    (shr(track.dir((i+1)*track.len+track.stat ) , 8  ) = 1))) /* INPUT */   then return 1;   else return 0;end look.up.port.ddt.direction;track.lookup: proc PUBLIC;   call this.track.lookup(dtd.track#);end track.lookup;lookup.ready.tracks: proc PUBLIC; /* returns bits for all "ready" tracks */   dcl i fixed;   dcl j fixed;      if track.dir.valid = 0 then return 0;   i = 0;   do j=0 to max.tracks-1;      t.sr      =    track.dir(j*track.len+track.stat)&255;      if  ((t.sr&1)<>0)          /* ready      */      and ((t.sr&2) =0)          /* not locked */      then i = i \ bits(j);   end;   return i;end lookup.ready.tracks;track.store: proc PUBLIC;   dcl i fixed;   i=dtd.track#*track.len;   track.dir(i+track.stat  )=t.sr\shl(t.ria,8);   track.dir(i+track.used  )=t.used;     track.dir(i+track.input )=t.input;    track.dir(i+track.gain  )=t.gain;     track.dir(i+track.volume)=t.volume;   track.dir(i+track.pan   )=t.pan;      track.dir(i+track.routs )=t.routs;      track.dir.updated = 1;   send.screen.info  = 1;end track.store;/* $page - routines to init song and track directory *//* initialize current entry in song directory: */init.song.entry: proc PUBLIC swapable;   dcl (i) fixed;   s.item       =song.base+dtd.song#+1;   s.title(0)   =24;   do i=1 to 12;      s.title(i)=32\shl(32,8);   end;   s.start      =0;   s.end        =0;   s.rate       =500;   s.used       =0;   s.status     =0;   s.modified   =0;   s.index      =gsong.dir((song.base+dtd.song#)*song.len+song.index); /* keep original index */   s.fade       =5;   call song.store;   call gsong.dir((song.base+dtd.song#)*song.len+song.title);   do i=0 to 11;           /* store in directory          */      write(mdi)=s.title(i+1);   end;end init.song.entry;init.song.dir: proc PUBLIC swapable;   dcl (i) fixed;   song.base   =0;   do dtd.song#=0 to num.songs-1;      call init.song.entry;      call gsong.dir(dtd.song#*song.len+song.index);      write(md)=dtd.song#;   end;   dtd.song#=0;   song.dir.updated  = 0;       /* but clear flags so we do not     */   send.screen.info  = 0;       /* write this to disk yet           */end init.song.dir;/* $page - initialize track directory entry */dcl Precompute.Volume.Information proc recursive;init.track.dir: proc PUBLIC swapable;   dcl (i,j,k) fixed;   do i=0 to num.tracks-1;      j=i*track.len;      do k=0 to track.len-1;             /* zereo out entire     */         track.dir(j+k) = 0;             /* entry first          */      end;      track.dir(j+track.gain  ) = 10;    /* set gain to   1.0    */      track.dir(j+track.volume) = 1000;  /* set vol  to 100.0    */      track.dir(j+track.bits  ) = 4;     /* indicate routings    */      track.dir(j+track.routs ) = i+1;   /* set initial routings */      do k=0 to 7;                                 /* set name   */         track.dir(j+track.title+k)=32\shl(32,8);  /* to all     */      end;                                         /* spaces     */   end;   call Precompute.Volume.Information;   track.dir.updated = 0;   send.screen.info  = 0;end init.track.dir;invalidate.track.dir: proc PUBLIC; /* call when dtd.song# changes              */   if track.dir.updated=0          /* if not waiting to write new info to disk */   then call init.track.dir;       /* then erase it to avoid confustion        */   track.dir.valid=0;              /* contents not valid now                   */   new.dtd.song#  =1;              /* compute start and end time for new song  */end invalidate.track.dir;init.alt.tdir.entry: proc(track#) PUBLIC swapable;   dcl track#  fixed;   dcl (i,j) fixed;   i=track# * track.len;   do j=0 to track.len-1;               /* zero out entire      */      alt.tdir(i+j)=0;                  /* directory            */   end;   alt.tdir(i+track.gain  ) = 10;       /* set gain to   1.0    */   alt.tdir(i+track.volume) = 1000;     /* set vol  to 100.0    */   alt.tdir(i+track.bits  ) = 4;        /* indicate routings    */   alt.tdir(i+track.routs ) = track#+1; /* set initial routings */   do j=0 to 7;                                   /* name to    */      alt.tdir(i+track.title+j)=32\shl(32,8);     /* all spaces */   end;end init.alt.tdir.entry;init.alt.tdir: proc PUBLIC swapable;   dcl (j) fixed;   do j=0 to num.tracks-1;      call init.alt.tdir.entry(j);   end;end init.alt.tdir;/* $page - more track directory routines                                *//* Precompute Volume Information is called whenever the track.volume    *//* or track.pan entries in a track directory changes.   This routine    *//* pre-computes some information for the voice cards that makes         *//* real-time-updating of the outputs faster.                            */Precompute.Volume.Information: proc PUBLIC swapable;   dcl voice# fixed;   dcl vol    fixed;   dcl pan    fixed;   dcl j      fixed;   do voice# = 0 to max.voices-1;      if voice# < num.tracks        /* get voice info from track directory */      then do;                      /* if such info is available           */         vol = track.dir((voice#*track.len) + track.volume);         pan = track.dir((voice#*track.len) + track.pan   );         if vol < 0    then vol = 0;         if vol > 1000 then vol = 1000;         if pan < -50  then pan = (-50);         if pan >  50  then pan = ( 50);      end;      else do;                      /* else use max vol, centered          */         vol = 1000;         pan = 0;      end;      /* store information in ext memory for speedy reference later:       */      write(mam) = venv.xmsec#;      write(mal) = (voice#*venv.stride) + venv.tdvol;      write(mdi) = vol;             /* write out venv.tdvol                */      write(mdi) = pan;             /* write out venv.tdpan                */      load 4095; mul vol; mwait;    /* scale volume for 0 - 4095           */      div 1000; vol=res;      j=pan+50;                      /* get pan from 0 to 100              */      if j>50 then j=50;             /* limit to 50                        */      load vol; mul j; mwait; div 50;      write(mdi) = res;              /* write out venv.tdrvol, 0 - 4095    */      write(mdi) = res;              /* store in venv.rvol as well         */         j=100-(pan+50);                /* get pan from 0 to 100              */      if j>50 then j=50;      load vol; mul j; mwait; div 50;      write(mdi) = res;              /* write out venv.tdlvol, 0 - 4095    */      write(mdi) = res;              /* store in venv.lvol as well         */   end;end Precompute.Volume.Information;/* Routines to generate error messages for particular songs & tracks: */append.song.name: proc PUBLIC swapable;   dcl (i,j) fixed;   j=24;   do while (byte(s.title,j-1))=32;      j=j-1;   end;   do i=0 to j-1;      call append.log.character(byte(s.title,i));   end;end append.song.name;append.command.song.name: proc(song#) PUBLIC swapable;   dcl song# fixed;   dcl (i,j) fixed;   i=song#*song.len;   s.title(0)=24;   call gsong.dir(i+song.title);   do j=0 to 11;      s.title(j+1)=read(mdi);   end;   j=24;   do while (byte(s.title,j-1))=32;      j=j-1;   end;   do i=0 to j-1;      call append.log.character(byte(s.title,i));   end;end append.command.song.name;append.track.name: proc PUBLIC swapable;   dcl (i,j) fixed;   j=16;   do while (byte(t.title,j-1))=32;      j=j-1;   end;   do i=0 to j-1;      call append.log.character(byte(t.title,i));   end;end append.track.name;log.overlap.message: proc PUBLIC swapable;   call append.log.string(' Project ');   call append.decimal.number(overlap.item#1+1);   call append.log.string(' Overlaps Project ');   call append.decimal.number(overlap.item#2+1);end log.overlap.message;log.proj.eof.error: proc PUBLIC swapable;   call log.error('Warning: End of Project Reached');end log.proj.eof.error;log.sys.is.not.ready: proc PUBLIC swapable;   call log.error('System is Not Ready for Input');end log.sys.is.not.ready;/* $page - allocation directory *//* a directory is maintainted for each track the records which areas   of the disk have been recorded on.    This makes 'Erase' a tollerably   quick operation,   and also improves load/backup.   the directory is 256 words long for each track.   it contains   up to 63 4-word records.   the first two words of each record   are a starting sector number (32-bit).   the last two words of   each record are an ending sector number (plus 1) (32-bit).   space that is recorded in adir has been written to. *//* a background process goes on to garbage collect the adir blocks.   if the directory gets full,  then   zeroes are written over    an unrecored section,  so blocks will be coallesced *//* allocation directory */gadir: proc(loca) PUBLIC;     /* get entry from adir - non-real time only */   dcl loca fixed;   write(mam) = adir.xmsec# + shr(loca,8);   write(mal) = loca;   return read(md);end gadir;/* $page - variables and routines for Current Project *//* The LOD Operating system uses several variables to keep track of *//* where on the disk the current project resides.   This is done    *//* because REPRO tracks play the current project.                   */dcl samp.speed                  fixed PUBLIC; /* current synclav speed setting */dcl current.rate                fixed PUBLIC; /* current in-use samp rate      */dcl apply.drop.frame.correction fixed PUBLIC; /* 1: correcty by 2997/3000      */dcl (smpte.onoff)            fixed PUBLIC;dcl (smpte.mode.rate)        fixed PUBLIC;dcl (smpte.track.rate)       fixed PUBLIC;dcl (output.happening)       fixed PUBLIC;  /* true if chan 32 running */dcl (now.playing   )         fixed PUBLIC;  /* set if play request started output */dcl (now.triggering)         fixed PUBLIC;  /* set if trig request started output */dcl (now.looping   )         fixed PUBLIC;  /* set if doing point playback output */dcl (now.monitoring)         fixed PUBLIC;  /* set if runing poly to monitor DDT  */dcl (out.of.sync   )         fixed PUBLIC;  /* true if out of sync condition      */dcl Song.Data        (1)     fixed PUBLIC;   /* Sector # of start of song data  */dcl Song.Length      (1)     fixed PUBLIC;   /* # of sectors in current song    */dcl Song.Ending      (1)     fixed PUBLIC;   /* Ending sector # of cur song     */dcl Song.Data.S#     (1)     fixed PUBLIC;   /* Sample # of song start          */dcl Song.End.S#      (1)     fixed PUBLIC;   /* Sample # of song end            */dcl C.Data           (1)     fixed PUBLIC;   /* Sector # of command song        */dcl C.Len            (1)     fixed PUBLIC;   /* # of sectors in command song    */dcl C.End            (1)     fixed PUBLIC;   /* ending sector # of command song */dcl C.Data.S#        (1)     fixed PUBLIC;   /* sample # of command song start  */dcl C.End.S#         (1)     fixed PUBLIC;   /* sample # of end of command song *//* compute command song info (i.e. end sector # and sample #s) *//* from starting sector and sector length                      */compute.c.info: proc PUBLIC;   call ADD32 (C.Data,    C.Len, C.End);   call COPY32(C.Data,    C.Data.S#   );   call SHL32 (C.Data.S#, 8           );   call COPY32(C.End,     C.End.S#    );   call SHL32 (C.End.S#,  8           );end compute.c.info;/* $Page - convert milliseconds to disk address, etc. *//* compute.syncl.time is passed a 32 bit sample #.   it computes *//* the synclavier time at which that sample would be played.     *//* this is used for error printouts.  also for dtd scrolling.    *//* returns time = abs zero if is before < current song           *//* NOTE:  S#, S# is an absolute disk sample #.                   *//* The 32-bit millisecond time that is returned is the           *//* corresponding time in the current project where that          *//* sample would play if the track was in REPRO                   *//* General purpose array use to hold synclavier times:           */dcl Syncl.Time  (2)  fixed PUBLIC;compute.syncl.time:proc(S#,trunc,Stime) PUBLIC;   dcl S#      array;  /* input sample #                         */   dcl trunc   fixed;  /* 1: limit to end of current project     */   dcl Stime   array;  /* returns syncl time msb, lsb, acu       */   dcl syncl.time.msb lit  'Stime(0)';   dcl syncl.time.lsb lit  'Stime(1)';   dcl syncl.time.acu lit  'Stime(2)';   /* compute the syncl.time based upon sampling rate, speed: */   if  (COM32(S#, Song.Data.S#) = LW#ILT)  /* if sample # is before */   or  ((trunc <> 0)                       /* or after              */   and  (COM32(S#, Song.End.S#) = LW#IGT)) /* current project ...   */   then do;      syncl.time.msb=0;                    /* then return 0,0,0     */      syncl.time.lsb=0;      syncl.time.acu=0;      return;   end;   call SUB32(S#, Song.Data.S#, Bit);      /* get sample # into cur proj */      call ratio_multiply(samp.speed,current.rate);	/* un-correct for user specified sampling rate and synclav speed */      if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction < 0   /****** note reverse usage ******/      then call ratio_multiply(2997, 3000);      else call ratio_multiply(3000, 2997);   end;   call ratio_multiply(1,100);             /* get milliseconds based upon 100 khz sampling */   call unround;                           /* we want 48-bit result */   call COPY32(Bit, Stime);                /* get msecs             */   load mul.llsb; mul 1000;                /* and fractional part */   syncl.time.acu=ures;                    /* on 0 to 1000 scale  */   if res<0 then do;      syncl.time.acu=syncl.time.acu+1;     /* round               */      if syncl.time.acu=1000 then do;         syncl.time.acu=0;         call ADD16(1, Stime);      end;   end;   /* add zero.time from synclav time base      */   /* this will line up our recording with      */   /* the first click                           */   call ADD16(Zero.Time, Stime);end compute.syncl.time;/* round routine - round up so that cue time will point          *//* somewhere in desired sector when converted back to            *//* samples                                                       */round.syncl.time: proc (Stime) PUBLIC;   dcl Stime array;   if Stime(2) >= 500    then call ADD16(1,Stime);   Stime   (2) = 0;end round.syncl.time;/* $page - compute sample # for mark start *//* compute mark start point is passed a synclavier time (normally mark.button.msb,   mark.button.lsb, mark.button.acu).    it is normally the precise point   in the sequence designated for a mark start.   The sample#   returned is the sample # we would like to start playing with   to perform a correct mark start */compute.mark.start.point:proc(msb,acu,limit,output) PUBLIC;   dcl (msb)          array;               /* milliseconds, msb/lsb  */   dcl (acu)          fixed;               /* microseconds           */   dcl (limit)        fixed;               /* 1 = limit to song len  */   dcl (output)       array;   call COPY32(Msb,Bit);                   /* get temp copy         */   if acu igt 1000 then do;                /* normalize acu field   */      load acu;      div 1000;      acu=rem;      call ADD16(res,Bit);   end;   if COM16(zero.time,Bit) = lw#igt   then do;      bit(1) = 0;      acu    = 0;   end;   else do;      call SUB16(zero.time,Bit);   end;   /* now compute the sample # that corresponds */   /* to that synclavier time.                  */	ratio_multiply(100, 1);                 /* compute sample # based on 100 khz sampling */   if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction > 0      then call ratio_multiply(2997, 3000);      else call ratio_multiply(3000, 2997);   end;   call ratio_multiply(current.rate,samp.speed);	/* correct for user specified sampling rate and synclav speed */   call ADD32(Song.Data.S#, Bit, Output);   bitmsb=0; bitlsb=acu;   call ratio_multiply(current.rate,samp.speed);	/* correct for user specified sampling rate and synclav speed */   if Apply.Drop.Frame.Correction <> 0     /* if correcting for drop frame */   then do;                                /* usage, then do so            */      if Apply.Drop.Frame.Correction > 0      then call ratio_multiply(2997, 3000);      else call ratio_multiply(3000, 2997);   end;   call ratio_multiply(1,10);					/* 10 mcsec/sample					*/   call ADD32(Output,BIT,Output);      if limit<>0 then do;      if COM32(Output, Song.End.S#) = lw#igt      then call COPY32(Song.End.S#, Output);   end;end compute.mark.start.point;end miscmod;