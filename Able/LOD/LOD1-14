/* :LOD:LOD1-14  $TITLE  Digest a Synclavier Message   Modified:   08/14/91 - cj  - Added UDIO/DDSYN stuff   07/29/91 - CJ -  cleared send.scrub.info on stop message   05/29/91 - CJ -  Added stack.extend usage   05/03/91 - CJ -  Fixed crashing bug with SMPTE by disallowing                    SMPTE track rate of 0   11/05/90 - CJ  - Improved accuracy of "play to"   01/25/90 - MWH/CJ - Fix "300 msec delay starting cues" bug (from EditView)   06/09/89 - cj - fix project directory "wipe out" bug*//* digest synclav message is called to process a message from the *//* synclavier that either  A) does not get a particular response, *//* or B) cannot be responded to immediately for one reason        *//* or another.                                                    *//* these include sync-up messages,  load of the freq table        *//* messages, etc.                                                 *//* handy local routine to convert rte value to 0 - 100.0 */SCALE.RTE.TO.PERCENT: proc(val) fixed public SWAPABLE;	dcl val fixed;	dcl rte.max lit '225';	load val; mul 1000; mwait; div rte.max;	// scale value from 0-rte.max to 0-1000	if (shl(rem,1) ige rte.max) load res+1;	// round	return res;end SCALE.RTE.TO.PERCENT;digest.synclav.message:proc;   dcl (i) fixed;   dcl p.mark.button          fixed;   dcl p.mark.button.msb      fixed;   dcl p.mark.button.lsb      fixed;   dcl p.mark.button.acu      fixed;   dcl command.132.bits			fixed;   dcl command.132.rate			fixed;   dcl command.132.extract		fixed;   dcl command.132.in	(1)	fixed;   dcl command.132.out	(1)	fixed;   dcl (a)      (1)       fixed;   dcl Stack.Record (Stack.Record.Size-1) fixed;   /* digest a synchronization message */   /* from Mr. Synclav                 */   if scsi.in.msg=130 then do;      if (play<>0) & (move=0) then do;      /* only up to date on play */         if (scsi.in.buf(1) ilt play.time.lsb) /* carry   */         then play.time.msb=play.time.msb+1;         play.time.lsb    = scsi.in.buf(1);         play.time.acu    = scsi.in.buf(2);         smpte.track.rate = scsi.in.buf(3);         sync.time.msb    = scsi.in.buf(513);         sync.time.lsb    = scsi.in.buf(514);         New.Sync.Info    = 1;              /* precise sync info is now available */         if smpte.track.rate ILT 8000       /* limit to avoid hanging at          */         then smpte.track.rate = 8000;      /* very slow rates                    */      end;      /* see if sync message is accompanied by a list of */      /* cues to trigger                                 */      /* Information passed from synclavier:             */      /* W2=SHL(PRIINFO&"37",6)\SHL(OUTINFO&"37",11)  priority, output */      /* W3=VOLINFO;                                  volume info      */      /* W4=SHL(PANINFO,8);                           pan info         */      /* word 0 = id# of cue to trigger                                */      /* word 1 = syncl time msb to trigger cue at                     */      /* word 2 = syncl time lsb to trigger cue at                     */      /* word 3 = bits word for cue.exists field                       */      /*          (see STACKLIT for a description of cue exists bits)  */      /* word 4 = W2  (priority, output info)                          */      /* word 5 = W3  (volume info, sbits? )                           */      /* word 6 = W4  (paninfo, velnote)                               */      /* word 7 = Upper half = more bits                               */      /*          32768 = if set, means lower half as cue list trk #   */      /*          16384 = if set, means this block of 8 words is       */      /*                  followed by an additional 12 words of event  */      /*                  information.                                 */      /*          Lower half = synclavier cue list track# for vol info */      /* For events only,  an additional 12 words are sent over:       */      /* word  8 = ev.in.msb                                           */      /* word  9 = ev.in.lsb                                           */      /* word 10 = ev.out.msb                                          */      /* word 11 = ev.out.lsb                                          */      /* word 12 = ev.fade.in                                          */      /* word 13 = ev.fade.out                                         */      /* word 14 = ev.bits                                             */      /* word 15 = ev.spare1                                           */      /* word 16 = ev.spare2                                           */      /* word 17 = ev.spare3                                           */      /* word 18 = ev.spare4                                           */      /* word 19 = ev.spare5                                           */      if  (scsi.in.buf(0)  > 8)       /* see if cue playback info sent    */      and (now.looping     = 0)       /* and not looping                  */      and (Loop            = 0)       /* and not trying to loop           */      and (Func            = 0)       /* and no data function reading     */      and (Subsystem.Ready <>0)       /* and initialization complete      */      then do;         i = 5;                       /* start with word 5                */         do while i < shr(scsi.in.buf(0),1); /* process each record       */            /* trigger cues in synchronously with sequencer */            /* if sequencer is running (or is trying to run */            /* but it hasn't started yet).  This is the     */            /* normal trigger of a cue from the sequencer   */            /* If the sequencer is not running,  then it    */            /* is probably the press of an info button and  */            /* we should play the cue as if triggering it   */            /* make sure cue id is <> 0 before triggering   */            if scsi.in.buf(i) <> 0 then do; /* if id <> 0   */               /* Digest the information from the synclavier by       */               /* constructing a cue trigger record to pass to        */               /* stack.entire.cue                                    */               call Zero.Out.Stack.Record(Stack.Record);               Stack.Cue.Id = Scsi.In.Buf(i  ); /* get id.            */               Stack.Exists = Scsi.In.Buf(i+3)  /* and bits           */                            & (not(64));        /* without recording! */               Stack.Track# = Scsi.In.Buf(i+7); /* syncl track#       */               /* expand pri-out-vol-pan from note record:            */               Stack.Pri = shr(Scsi.In.Buf(i+4), 6) & "37";               Stack.Out = shr(Scsi.In.Buf(i+4),11) & "37";               Stack.Vol = SCALE.RTE.TO.PERCENT(Scsi.In.Buf(i+5) & 255);               Stack.Pan = shr(Scsi.In.Buf(i+6), 8);   /* get pan.    */               if (Stack.Pan & 128) <> 0               /* extend sign */               then Stack.Pan = Stack.Pan \ "177400";  /* if minus    */               Stack.Bits = Stack.Bits \ (Stack.POVP \ Stack.Construct.Env);               /* expand event information if any is there            */               if (Scsi.In.Buf(i+7) & 16384) <> 0               then do;                  write("313") = addr(Stack.New.In.Msb);                  write("300") = addr(Scsi.In.Buf(i+8));                  rpc 12;                  write("373") = read("360");                  Stack.Bits = Stack.Bits \ Stack.Modify.In;               end;               /* Now trigger cue either by stacking,  or */               /* starting Trig output                    */               if  (play           <> 0)       /* if playing          */               and (move            = 0)       /* and not moving      */               and (now.triggering  = 0)       /* and not trigging    */               then do;                        /* trigger synchly     */                  /* compute sample # at which we should trigger      */                  /* the cue                                          */                  call compute.mark.start.point(loc(addr(Scsi.In.Buf(i+1))),0,0,Stack.Sync);                  /* compute a sample # that is a short distance in   */                  /* the future                                       */                  call compute.delayed.sync.point(0,0,a);                                                                  if  (Delay.Cue.Starts       <> 0     )                  and (COM32(Delay.Cue.S#, a) >= lw#ieq)                  then call COPY32(Delay.Cue.S#, a);                  /* if we are late starting the note, then set       */                  /* offset point to start up cue in middle           */                  if COM32(Stack.Sync,a) = lw#ilt                  then call SUB32(a,Stack.Sync,Stack.Offset);                  /* Check for limiting cue to play to time:          */                  if (Play.Seq.To.A.Time <> 0)                  then do;                     Stack.Bits = Stack.Bits \ Stack.Play.To;                     call COPY32(Play.Seq.To.S#, Stack.To.Time);                  end;                  call Stack.Entire.Cue(Stack.Record); /* stack the cue */               end;               /* else if not playing,  then trigger cue manually     */               /* (only if special bit set) in case this is keyboard  */               /* triggering or info note triggering:                 */               else if (Stack.Exists&4096)<>0   /* if info note ...     */               then do;                  Stack.Exists = 1;             /* set up basic trigger */                  call Trigger.Cue(Stack.Record, 0);                  trig.tracks = (-1);               end;            end;                                   /* advance pointer past this cue trigger or event trigger */            /* record:                                                */            if (Scsi.In.Buf(i+7) & 16384) <> 0            then i = i + 20;            else i = i + 8;         end;      end;      if  Swap.Info.Loaded = 0                    /* if swap info is not loaded     */      then get.new.motion = get.new.motion \ 16;  /* then ask for object file again */      timeout.point   =real.milliseconds+10000;   end;   /* Check for a 'new motion' record */   else if scsi.in.msg=131 then do;      play.time.msb       = scsi.in.buf( 1);      play.time.lsb       = scsi.in.buf( 2);      play.time.acu       = scsi.in.buf( 3);      samp.speed          = scsi.in.buf( 4);      play                =(scsi.in.buf( 5)&1)   ;      recd                =(scsi.in.buf( 5)&2)<>0;      move                =(scsi.in.buf( 5)&4)<>0;      pnch                =(scsi.in.buf( 5)&8)<>0;      play.tracks         = scsi.in.buf( 6);      /*                  = scsi.in.buf( 7)     */      /*                  = scsi.in.buf( 8)     */      /*                  = scsi.in.buf( 9)     */      Lod.Recd.Tracks     = scsi.in.buf(10);    /* ready tracks from P page */      ready.tracks        = Lod.Recd.Tracks;      /*                  = scsi.in.buf(11)     */      /*                  = scsi.in.buf(12)     */      /*                  = scsi.in.buf(13)     */      mark.button.state   = scsi.in.buf(14);      mark.button.msb     = scsi.in.buf(15);      mark.button.lsb     = scsi.in.buf(16);      mark.button.acu     = scsi.in.buf(17);      smpte.onoff         = scsi.in.buf(18);      smpte.mode.rate     = scsi.in.buf(19);      Lod.Punch.In.Tracks = scsi.in.buf(20);      Delay.Cue.Starts    = scsi.in.buf(24);      Delay.Cue.Time (0)  = scsi.in.buf(25);      Delay.Cue.Time (1)  = scsi.in.buf(26);      Play.Seq.To.A.Time  = scsi.in.buf(27);      Play.Seq.To.Time(0) = scsi.in.buf(28);      Play.Seq.To.Time(1) = scsi.in.buf(29);      New.Sync.Info = 0;      timeout.point=real.milliseconds+10000;      call compute.mark.start.point(loc(addr(mark.button.msb)), mark.button.acu,                                    1, Mark.Button.S#);      /* compute new mark.s#'s  */      call Add16  (127, Mark.Button.S#);    /* round up to new sector boundary */      call ROUND32(Mark.Button.S#);      if  (now.playing     = 0)       /* if no output now happening */      and (now.triggering  = 0)       /* and no triggering          */      and (now.looping     = 0)       /* and no looping             */      and (func            = 0)       /* and no function reading    */      and (Subsystem.Ready <>0)       /* and initialization comple  */      and (play            = 0)       /* not trying to play now     */      and ((p.mark.button      <> mark.button.state) /* detect change  */      or   (p.mark.button.msb  <> mark.button.msb)   /* in mark start  */      or   (p.mark.button.lsb  <> mark.button.lsb)   /* position or    */      or   (p.mark.button.acu  <> mark.button.acu))  /* enable/disable */      then do;         call set.new.play.buffer.position;   /* reload buffers from new point */      end;      p.mark.button     = mark.button.state;      p.mark.button.msb = mark.button.msb;      p.mark.button.lsb = mark.button.lsb;      p.mark.button.acu = mark.button.acu;      if Delay.Cue.Starts <> 0 then do;         /* compute sample # to which we should delay        */         /* the cue triggers                                 */         call compute.mark.start.point(Delay.Cue.Time,0,0,Delay.Cue.S#);      end;      if Play.Seq.To.A.Time <> 0 then do;         call compute.mark.start.point(Play.Seq.To.Time,0,0,Play.Seq.To.S#);      end;      /* Suppress DTD to Synclav synchronization for 2 seconds after */      /* changing speed                                              */      if samp.speed <> prior.speed      then do;         prior.speed = samp.speed;         new.speed   = 1;         new.speed.time = Real.Milliseconds;      end;   end;   /* $page - handle cue trigger items */   /* code 132 is used to trigger playback from a section of  */   /* the dtd.   In some cases,  the actual output is         */   /* triggered by sending the 132 commmand (for convenience) */   /* In other cases (for compatibility with earlier software */   /* the output is not started until a 64 command id         */   /* received                                                */   /* 132 sets up a temp cue in ext memory to reflect the     */   /* area that should be played.   if point playback is      */   /* indicated,  then we start it directly.   Otherwise,     */   /* we just wait for a 64 command to start the triggered    */   /* output                                                  */   else if (scsi.in.msg     =  132)   and     (Subsystem.Ready <> 0  )          then do;   /* set trigger playback point    */      call compute.mark.start.point(loc(addr(scsi.in.buf(1))),0,0,                                    loc(addr(scsi.in.buf(1)))     );      call SUB32(loc(addr(scsi.in.buf(1))), Song.Data.S#, loc(addr(scsi.in.buf(1))));      call ADD32(loc(addr(scsi.in.buf(1))), Data.S#,      loc(addr(scsi.in.buf(1))));      if ((scsi.in.buf(3)\scsi.in.buf(4))<>0)      then do;                                 /* looped or section */         call compute.mark.start.point(loc(addr(scsi.in.buf(3))),0,0,                                       loc(addr(scsi.in.buf(3)))     );         call SUB32(loc(addr(scsi.in.buf(3))), Song.Data.S#, loc(addr(scsi.in.buf(3))));         call ADD32(loc(addr(scsi.in.buf(3))), Data.S#,      loc(addr(scsi.in.buf(3))));      end;      if  (play           <> 0)              /* if playing             */      and (move            = 0)              /* and not moving         */      and (now.triggering  = 0)              /* and not trigging       */      then i = trig.tracks;                  /* then only stack soloed */      else i = track.avail.bits;             /* tracks, else all       */      call Create.Temp.Cue(loc(addr(Scsi.In.Buf(1))), /* create cue image in */                           loc(addr(Scsi.In.Buf(3))), /* ext memory for      */                           i,                         /* later triggering    */                           Scsi.In.Buf(11)         ); /* (1 = use mapping)   */      if Scsi.In.Buf(7) = 0          /* normal segment playback - just save */      then do;                       /* info for later trigger with 64      */         command.132.bits = (scsi.in.buf(5)\1) and (not(64)); /* bits: do loop or stop. cue record safety check */         command.132.rate = (Scsi.In.Buf(6));    /* rate                          */         command.132.extract = Scsi.In.Buf(12);  /* perform extraction if needed  */         call COPY32(loc(addr(Scsi.In.Buf(13))), command.132.in );         call COPY32(loc(addr(Scsi.In.Buf(15))), command.132.out);      end;      /* handle looping playback trigger */      else do;                           /* loop playback desired */         call COPY32(loc(addr(scsi.in.buf(1))),newly.requested.loop.s#);      /* loop.mode===Scsi.In.Buf(8); */  /* 0 = point mode    1 = loop mode */         loop.resp = Scsi.In.Buf(9);     /* if point mode, is response      */         loop.post = Scsi.In.Buf(9);     /* if loop  mode, is pre/post      */         time.of.new.loop.request = Scsi.In.Buf(10);         hold.loop.for.stacking   = 0;   /* not waiting for stacking        */         if loop = 0 then do;            /* not looping yet - clean up      */            call clear.armed.info;       /* flip out of armed record        */            recrec.is.stacked = 0;       /* no arm pending                  */            call COPY32(Newly.Requested.Loop.S#, S#.To.Start.Looping.At);  /* stash as current   */            call COPY32(Newly.Requested.Loop.S#, Prior.Requested.Loop.S#);             time.of.prior.loop.request = time.of.new.loop.request;            loop         = 1;            /* start looping here */            new.loop.pos = 0;         end;         else new.loop.pos = 1;          /* else new position to process when we can */      end;   end;   /* $page - trigger cue from cue directory */   /* 133 command is used to trigger cue,  for example from the */   /* cue directory                                             */   /* it is also used to load cues onto the scrub stack for     */   /* scrubbing through cues in the sequence                    */   else if (scsi.in.msg     =  133)   and     (Subsystem.Ready <> 0  )          then do;      /* trigger cue for playback    */      /* note: cue id could be -1 for a reel that has just */      /* been loaded into the temp cue area                */      if Scsi.In.Buf(0) < 6 then do;     /* zero fill for old software  */         Scsi.In.Buf(2) = 0;         Scsi.In.Buf(3) = 0;      end;      /* Set up the Stack.Record to reflect the information:            */      call Zero.Out.Stack.Record(Stack.Record);      Stack.Cue.Id = Scsi.In.Buf(1);      /* get passed id#             */      Stack.Exists = 1;                   /* simple cue trigger         */      Stack.Track# = Scsi.In.Buf(2);      /* and syncl track#           */      /* If editview event scrub desired, extend region.  Else          */      /* stack the editview envelope.                                   */      if (Scsi.In.Buf(3) & 2) <> 0             then Stack.Bits = Stack.Bits \ Stack.Extend;      else Stack.Bits = Stack.Bits \ Stack.Construct.Env;      if (Scsi.In.Buf(3) & 1) <> 0 then do; /* get event info           */         Stack.Pri = Scsi.In.Buf(4);         Stack.Out = Scsi.In.Buf(5);         Stack.Vol = Scsi.In.Buf(6);         Stack.Pan = Scsi.In.Buf(7);         /* Get Stack.New.In, Stack.New.Out:                            */         call blockmove(loc(addr(Scsi.In.Buf(10))), Stack.New.In, 4);         /* Get other event info: (ignore offset mark point)            */         call blockmove(loc(addr(Scsi.In.Buf(16))), loc(addr(Stack.Fin)), 8);         Stack.Bits = Stack.Bits \ Stack.POVP \ Stack.Modify.In;      end;      if loop then do;                          /* stacking cue for scrub    */         call compute.mark.start.point(loc(addr(scsi.in.buf(8))),0,0,Stack.Sync);         call SUB32(Stack.Sync, Song.Data.S#, Stack.Sync);         call ADD32(Stack.Sync, Data.S#,      Stack.Sync);         call Stack.Entire.Cue(Stack.Record);   /* place on scrub stack      */      end;      else call Trigger.Cue(Stack.Record,       /* else trigger this cue     */                            0);                 /* use normal rate           */   end;   else if scsi.in.msg=134 then do;    /* set trigger tracks */      trig.tracks=scsi.in.buf(1);   end;   else if scsi.in.msg=135 then do;          /* initiate cue recording   */      do i=recrec.code  to recrec.audio;     /* store away record record */         stackedrecrec(i) = scsi.in.buf(1+i);      end;      recrec.is.stacked = 1;      if  (now.triggering<>0)    /* if triggered output is now occurring */      and (trig=0)               /* but user has requested end of trigger */      then do;                   /* then stack this armed request until prior punch-outs have occurred */         /* do nothing - wait until prior punch out is completed before glomming cue stack */      end;      else if (now.playing<>0)   /* else if still playing */      and     (play=0)           /* but trying to stop    */      then do;                   /* and next request      */         /* do nothing - wait until prior punch out is completed before glomming cue stack */      end;      else if (now.looping<>0)   /* looping here????      */      then do;      end;      else if (Subsystem.Ready <> 0)      then do;         call set.up.for.armed.recording;   /* else process stackedrecrec right now */      end;   end;   /* set cue trigger rate */   else if Scsi.In.Msg = 136   then do;                                 /* new cue trigger rate */      Trig.Rate = Scsi.In.Buf(1);           /* get new rate         */      if  ((Dig.Xfer.Mode & (Dig.In\Dig.Out\Dig.Dspin\Dig.Forcedsp)) <> 0)      then Trig.Rate = 0;                   /* cannot speedup/slow down  */                                            /* during DDT xfers.         */      if  (now.triggering<>0)               /* if now triggering    */      then call Set.Trigger.Rate(Active.Rate); /* update rate info */   end;   else if Scsi.In.Msg = 137                /* load entire cue      */   then do;                                 /* in tcue.xmsec#       */      /* complete reel is in tcue.xmsec#.   Convert all times */      /* to absolute disk samples now                         */      if (Subsystem.Ready <> 0)      then call convert.entire.record.to.samples(tcue.xmsec#);   end;      else if Scsi.In.Msg = 138                /* Track volume/routing info */   then do;      if Scsi.In.Buf(1) = THD.TVOL          /* new track volumes         */      then do;         write(mam) = tvol.xmsec#;         do i = 2 to 256;                   /* scale for fractional      */            if (Scsi.In.Buf(i) IGE 1000)    /* multiply.  if strange     */            then write(mdi) = (-1);         /* value,  use max.          */            else do;               load 0;               uload Scsi.In.Buf(i);               div 1000;               write(mdi) = res;            end;         end;      end;      if Scsi.In.Buf(1) = THD.CUE.OUT       /* new track routings        */      then do;         write(mam) = tout.xmsec#;         call write.len(addr(Scsi.In.Buf(2)),255);      end;   end;   /* Command 139 is used to  both:  A) start scrubbing through  */   /* a list of stacked events,  and B)  continue scrubbing by   */   /* setting a new scrub point.                                 */   else if Scsi.In.Msg = 139 then do;  /* set new scrub position */      call ADD32(loc(addr(scsi.in.buf(1))),  /* get sample # from start of sequence */                 Data.S#,                    /* add to scrubbing 0.0 time           */                 newly.requested.loop.s#);      time.of.new.loop.request = Scsi.In.Buf(3);      if hold.loop.for.stacking <> 0         /* if this is first one,  then         */      then do;                               /* actually start scrubbing            */         hold.loop.for.stacking = 0;         /* not waiting for stacking            */         call COPY32(Newly.Requested.Loop.S#, S#.To.Start.Looping.At);  /* stash as current   */         call COPY32(Newly.Requested.Loop.S#, Prior.Requested.Loop.S#);          time.of.prior.loop.request = time.of.new.loop.request;         new.loop.pos = 0;      end;      else new.loop.pos = 1;          /* else new position to process when we can */   end;   /* $page - handle break, trigger, stop from synclav */   /* 'reboot' message */      else if scsi.in.msg=4 then do;       if 0 then break.me=1;           /* treat as break - IGNORE NOW */   end;   else if scsi.in.msg=64 then do;     /* start triggered output      */      if (Subsystem.Ready <> 0)      then do;         call Zero.Out.Stack.Record(Stack.Record);         Stack.Cue.Id = (-1);             /* trigger contents of tcue.xmsec# */         Stack.Exists = command.132.bits; /* bits were set earlier           */         if command.132.extract <> 0      /* if extraction desired, do so.   */         then do;            Stack.Bits   = Stack.Bits \ Stack.Construct.Env \ Stack.Extract;            call COPY32(command.132.in , Stack.Ext.In );            call COPY32(command.132.out, Stack.Ext.Out);         end;         call Trigger.Cue(Stack.Record, command.132.rate);      end;   end;                                /* command                     */   else if scsi.in.msg=65 then do;       /* stop triggered output       */      trig  = 0;      if  (Any.Track.Actually.Recording = 0)  /* if not recording on a trk */      and (Subsystem.Ready             <> 0)      then do;                           /* then stop cue output now    */         do i=0 to max.tracks-1;         /* if doing cue pb             */            if source.or.cue(i)<>0       /* on this track               */            then do;                     /* then turn of it's audio     */               zap.buffer(i) = 1;        /* toss buffer contents        */               buf1.len  (i) = 0;        /* this will cause audio       */               buf2.len  (i) = 0;        /* to turn off right now       */               buf3.len  (i) = 0;               call clear.playback.cue.stack(i);            end;         end;      end;      call clear.armed.info;              recrec.is.stacked = 0;      /* no arm pending                   */   end;   else if scsi.in.msg=66 then do;     /* enable scrolling info       */      send.scrolling = 1;   end;   else if scsi.in.msg=67 then do;     /* disable scrolling info      */      send.scrolling   = 0;            /* toss any pending items      */      send.scroll.info = 0;      send.scrub.info  = 0;   end;   else if scsi.in.msg=68 then do;     /* start of data function reading */      if func = 0 then do;             /* not reading yet - clean up     */         call clear.armed.info;        /* flip out of armed record       */         recrec.is.stacked = 0;        /* no arm pending                 */         func              = 1;        /* start reading now              */         new.inputs        = 1;        /* free up inputs                 */         read.track.time = real.milliseconds;         timeout.point   = real.milliseconds+10000;      end;   end;   else if scsi.in.msg=69 then do;     /* stop point/function playback   */                                       /* get new motion at end of loop  */      if (loop\func) <> 0              /* to resume playing if we were   */      then get.new.motion=get.new.motion \ (1 \ 8);      loop = 0; func = 0;   end;   else if scsi.in.msg=70 then do;     /* Prepare the DTD for event      */                                       /* scrubbing                      */      if loop = 0 then do;              /* make sure we are not looping  */         call clear.armed.info;         /* flip out of armed record      */         recrec.is.stacked         = 0; /* no arm pending                */         hold.loop.for.stacking    = 1; /* wait for events               */         dtd.is.ready.for.stacking = 0; /* not ready for stacking yet    */         loop                      = 1; /* start process going           */      end;   end;   /* $page - Swap Table/Frequency Table loading */   /* handle synclav messages for snarfing swap code from reload of */   /* object file from early synclavier software                    */   else if Scsi.In.Msg = 200 then do;  /* 200: load address.  RTP is about */      Swap.Info.Sec# = 0;              /* to re-send the entire .LOD_7     */      Swap.Info.Skip = shr(core(C#Contab + C#Objlen) + 255, 8);   end;   else if Scsi.In.Msg = 201 then do;  /* 201: object code                 */      if Swap.Info.Skip <> 0      then Swap.Info.Skip = Swap.Info.Skip - 1;      else do;         if Swap.Info.Sec# IGE Swap.xmlen#         then do;				print;            print 'Swap File Too BIG!!';         end;         write(mam) = Swap.xmsec# + Swap.Info.Sec#;         call write.len(addr(Scsi.In.Buf(1)),256);         Swap.Info.Sec# = Swap.Info.Sec# + 1;      end;      timeout.point = real.milliseconds+10000;   end;   else if Scsi.In.Msg = 202 then do; /* end of swap area */      call SwapInit(Swap.Xmsec#);                  /* set up for swap code */      Swap.Info.Loaded = 1;                        /* mark loaded          */      get.new.motion = get.new.motion & (not(16)); /* clear bit here       */      if Initialize = 1 then do;       /* only do once!!                      */         call init.song.dir;           /* initialize to empty song  directory */         call init.track.dir;          /* initialize to empty track directory */         call Initialize.Free.Seg.Records;      end;   end;   else if Scsi.In.Msg = 203 then do;  /* 203: prepare for swap file load  */      Swap.Info.Sec# = 0;      Swap.Info.Skip = 0;   end;   /* handle synclav messages for frequency */   /* table loading                         */   else if scsi.in.msg=210 then do;      /* prepare for load of freq table */      ftabptr       = 0;                 /* and swapping code              */      fcont         = 0;       ftable.loaded = 0;   end;   else if scsi.in.msg=211 then do;      /* store ftable            */      if  (scsi.in.buf(0)= 512)          /* should be 1 sector      */      and (ftabptr      <  16 )          /* and in range            */      and (examount     <> 0  )          /* make sure storage       */      then do;         write(mam) = ftab.xmsec#+ftabptr;  /* note: can not use write.store        */         write("313")=addr(Scsi.In.Buf(1)); /* here because max amount has not      */         rpc 256;                           /* been set up yet!!!!!                 */         write(mdi)=read("373");         fcont=fcont\bits(ftabptr);      /* count bits              */         if fcont=(-1)         then ftable.loaded=1;           /* here                    */         else ftabptr=ftabptr+1;      end;   end;   /* $page - handle commands for reading disk         */   else if scsi.in.msg = 144 then do;    /* handle stuff here that cannot be */                                         /* handled in process synclav msg   */      if scsi.in.buf(1) = 47 then do;    /* handle read of scsi disk into poly */         /* 2 = disk sector msb          */         /* 3 = disk sector lsb          */         /* 4 = memory media             */ /* must be 0 for now */         /* 5 = memory sector # (mmsb)   */ /* must be 0 for now */         /* 6 = memory sector # (mlsb)   */         /* 7 = memory word offset       */         /* 8 = sectors to transfer      */ /* limit of 65535 words */         /* 9 = words to transfer        */ /* total at this time   */         tptr = optical.tptr;         PolyMemSec  = scsi.in.buf(6);         PolyMemWord = scsi.in.buf(7);         if optdebug then do;            print 'Reading (dsk ml, pol sw, len, st): ',scsi.in.buf(2)&255, scsi.in.buf(3), scsi.in.buf(6), scsi.in.buf(7), shl(scsi.in.buf(8),8)+scsi.in.buf(9),;         end;         misc.buf(0) = Readdata(scsi.in.buf(2) & 255, scsi.in.buf(3), loc(-1),                        scsi.in.buf(8)*256+scsi.in.buf(9));         		 clean.up.all.of.poly = 1;    /* set flag to clean up all of poly  */                                      /* when we are done because we don't */                                      /* know which track we are reading   */                                      /* for.                              */         if optdebug then print misc.buf(0);         call Reselect.Synclavier (1, misc.buf); /* send status back */      end;   end;   else do;      /* unrecognized message - probably a '1' .  in any case,  he knows we are running */   end;   scsi.in.msg=0;end digest.synclav.message;