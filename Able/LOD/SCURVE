/* S-curve splice computations *//* General floating point routine:      Input  - 0.0000 to 1.0000      Output - 1.0000 to 0.0000       *****                                           ****      Value @ .50000 = .50000                   ***                                                   **      Slope @ .50000 = P                             *                                                      **      Slope @ 0.0000 = 0.0000                           ***      Slope @ 1.0000 = 0.0000                              ****                                                               *****    *//* C. Jones - 12-17-88 */insert ':synlits:comlits';insert ':synlits:globlits';dcl scurve.sec#  lit '0';/* Routine to return S_Curve function: */S_Curve: proc(point, power) floating;   dcl point     floating;   /* 0.0000 - 1.0000 */   dcl power     floating;   /* power factor    */   if point = 0.0000         /* avoid math problems with */   then return 1.0000;       /* log of 0                 */   if point < .5000   then return (1.0000 - (exp(log(2*point)*power)/2.0000));   else return exp(log(2.0000*(1.0000 - point))*power)/2.0000;end S_Curve;/* Construct linear interpolation table in external memory: */Construct_S_Curve_Table: proc(power);   dcl power floating;   dcl (i,j,k) fixed;   dcl (a,b,c) floating;   dcl (last) fixed;   last = 65535;   write(mam) = scurve.sec#;   do i = 1 to 256;      a = i / 256.0;          /* get next fraction from 0 - .99999 */      b = s_curve(a, power);  /* get next value                    */      j = 1 + int(b*65534.0+.5); /* scale 1 - 65535, with rounding */      write(mdi) = last-j;    /* store NEGATIVE slope */      write(mdi) = last;      /* and value            */      last = j;   end;end Construct_S_Curve_Table;/* Routine to quickly compute s-curve value for 0-65535 input */Interpolate_S_Curve: proc(val);   dcl val   fixed;   write(mam) = scurve.sec# + (rot(val,1)&1);  /* index to 2 sector table */   write(mal) = shl(shr(val,8), 1);   load   read(mdi); mul (val&255); mwait; div 256;   if rem >= 128   then return read(md) - res - 1;   /* remember NEGATIVE slope was stored */   else return read(md) - res    ;   /* remember NEGATIVE slope was stored */end Interpolate_S_Curve;