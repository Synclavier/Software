*Loader program for Live Overdub**This program resides in the Live Overdub MFC Loader Rom.*It can load a program into memory over the D24 SCSI bus.***Bit definitions for D24:*selebl: equ 10000**Bit definitions for D25:*atn: equ 1bsy: equ 2ack: equ 4rst: equ 10msg: equ 20sel: equ 40c.d: equ 100req: equ 200i.o: equ 400**Register usage:**r0:  temporary*r1:  returns byte from gbyte subroutine*r2:  holds message type*r3:  holds byte counter for long messages**r4:  holds current load address*r5:  holds return location-2 for gbyte subroutine*r6:  holds byte during word assembly*r7:  holds original load address for execute*r10: holds working load address*r11: holds sector count (checksum)**Initialize:*im(-20) to d1        disable interrupts in case arrived from programim(0) to r4          initialize address pointer to 0im(0) to r7          save original copyim(0) to r11         initialize sector count**Clean up upon*entry or retry:*again:pci to d24     select scsi d24 board # 0data selebl+400      select scsi port 0im(0) to d24         clear all output data bitsim(0) to d25         command bus as well**Wait for us to      SEL*be selected:*d25 to r0            read command linespci to and0          extract scsi bitsdata atn+bsy+ack+rst+msg+sel+c.d+req+i.opci to tsub0         look for SEL onlydata selre(again) to rtnz    wait if no sel**                    DATA 6*d24 to r0            check for datapci to and0          extract data bitsdata 377pci to tsub0         check for bit 6 only setdata 100re(again) to rtnz    eject**We are selected.  Assert BSY:*pci to d25           set BSY line to acknowledgedata bsy**Wait for SEL*to be released:*wait1:d25 to r0      check SEL linepci to tand0         check for ATN or RSTdata atn+rstre(again) to rtnz    clear BSY and wait for another SEL if sopci to tand0data selre(wait1) to rtnz**Get message type byte:*r17 to r5            save returnpci to rtra          call getbyte subroutinedata gbyte-.-1r1 to r2             store comand byte in r2**Look at type byte:*pci to tand2         see if >=128data 200re(nomsg) to rtze**Scan message:*r17 to r5            save returnpci to rtra          call getbyte subroutinedata gbyte-.-1r1 to r6             store msb byte in r6r17 to r5            save returnpci to rtra          call getbyte subroutinedata gbyte-.-1r6 to r3             get msbr1 to bsor3          rotate; or in lsb**Check for zero*length message*im(1) to add3        round up - always even # of bytesim(-2) to and3       multiple of 2 as wellre(nomsg) to rtze    zero length message - skipeject**Read message into memory:*r4 to r10            get working copy of load address (in case abort)morem:r17 to r5      get bytepci to rtra          call getbyte subroutinedata gbyte-.-1r1 to r6             store msb byte in r6r17 to r5            save returnpci to rtra          call getbyte subroutinedata gbyte-.-1r6 to r0             get msbr1 to bsor0          rotate; or in lsbr0 to mr10i          store in memoryim(2) to sub3        decrement countre(morem) to rtnz**Send Answer Message*nomsg:im(2) to d24   send a 2 back (from loader)pci to d25           assert REQdata bsy+req**Wait for ACK*wait2:d25 to r0      read command buspci to tand0         see if reset or atndata atn+rstpci to rtnz          bomb out if atn or resetdata again-.-1       clear bsy and restart if ATN or RSTpci to tand0         check ACKdata ackre(wait2) to rtze**release REQ:*pci to d25data bsy**Wait for ACK to*be released:*wait3:d25 to r0pci to tand0         see if resetdata atn+rstpci to rtnz          bomb out if sodata again-.-1       clear bsy and restart if ATN or RSTpci to tand0data ackre(wait3) to rtnz**clear bits*im(0) to d24         clear data bitsim(0) to d25         done with bsy - bus if free now**Check message type 0:*chk000:im(0) to tsub2  check messagepci to rtze            not much to do if sodata again-.-1**Check message type 1:*chk001:im(1) to tsub2  check messagepci to rtze            done - we sent a '2' backdata again-.-1**Check message type 200:       LOAD ADDRESS*chk200:pci to tsub2  check messagedata 310             200 decimalre(chk201) to rtnzmr4 to r4            look at loaded data - get new load addressr4 to r7             save original for executeim(0) to r11         zero sector countpci to rtra          and wait for another messagedata again-.-1**Check message type 201:       LOAD DATA*chk201:pci to tsub2  check messagedata 311re(chk202) to rtnzr10 to r4            update address counter after successful loadr11i to atnv         increment sector countpci to rtra          we are done - message has been stored in memorydata again-.-1       and address counter has been incremented**Check for message 202:        CHECKSUM/EXECUTE*chk202:pci to tsub2  check messagedata 312re(unrec1) to rtnzmr4 to r0            get checksum/sector countr11 to tsub0         must matchr7 to atze           go to loaded codepci to rtra          else wait againdata again-.-1       **unrecognized message:*unrec1:pci to rtradata again-.-1eject**Scan Byte from SCSI**Return to AGAIN if ATN or RST**Call with (return-2) in r5**Return byte in R1**Assert REQ:*gbyte:pci to d25data bsy+req**Wait for ACK*gwait1:d25 to r0     read command buspci to tand0         see if reset or atndata atn+rstpci to rtnz          bomb out if atn or resetdata again-.-1       clear bsy and restart if ATN or RSTpci to tand0         check ACKdata ackre(gwait1) to rtze**Read byte:*d24 to r1pci to and1data 377**release REQ:*pci to d25data bsy**Wait for ACK to*be released:*gwait2:d25 to r0pci to tand0         see if resetdata atn+rstpci to rtnz          bomb out if sodata again-.-1       clear bsy and restart if ATN or RSTpci to tand0data ackre(gwait2) to rtnz**Return:*r5i to tloa0r5i to tloa0r5 to atra