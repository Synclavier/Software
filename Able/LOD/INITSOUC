/* INITSOUC : routines to issue tape commands *//* 03/26/90 - cj - Code for new tape format   *//* 02/21/90 - cj - moved code to lod1-22 to work around WANGDATA data delay *//* 01/16/90 - cj - added tandberg code        *//* 06/02/89 - cj - added exabyte code         *//* Variables for operating backup tapes: */dcl tape.type        (max.ports) fixed PUBLIC;dcl tape.recover.code(max.ports) fixed PUBLIC;dcl tape.to.use      (max.ports) fixed PUBLIC;dcl tape.condition   (max.ports)   fixed PUBLIC; /* holds bits that describe tape */dcl tape.state       (max.ports)   fixed PUBLIC; /* state of tape io         */dcl tape.return.state(max.ports)   fixed PUBLIC; /* for subroutine calls     */dcl tape.remove      (max.ports)   fixed PUBLIC;dcl tape.eof         (max.ports)   fixed PUBLIC; /*                          */dcl tape.track#      (max.ports)   fixed PUBLIC; /* track # being written    */dcl tape.data.msb    (max.ports)   fixed PUBLIC; /* for tape i/o             */dcl tape.data.lsb    (max.ports)   fixed PUBLIC;dcl tape.len.msb     (max.ports)   fixed PUBLIC;dcl tape.len.lsb     (max.ports)   fixed PUBLIC;dcl tape.copy.len.msb(max.ports)   fixed PUBLIC;dcl tape.copy.len.lsb(max.ports)   fixed PUBLIC;dcl tape.buf.len     (max.ports)   fixed PUBLIC;dcl tape.read.len    (max.ports)   fixed PUBLIC;dcl tape.issue.len   (max.ports)   fixed PUBLIC;dcl tape.fmark       (max.ports)   fixed PUBLIC;dcl port.empty       (max.ports)   fixed PUBLIC; /* true if trks 0 and 1 mpt */dcl tape.skip        (max.ports)   fixed PUBLIC; /* true to skip data        */dcl block.skip       (max.ports)   fixed PUBLIC; /* true to skip 1 block     */dcl port.thisdest    (max.ports)   fixed PUBLIC;dcl port.cue.ix      (max.ports)   fixed PUBLIC;dcl port.track.list  ((max.ports+1)*(max.tracks)-1) fixed PUBLIC;dcl port.dest.list   ((max.ports+1)*(max.tracks)-1) fixed PUBLIC;dcl port.jaz.sec.msb (max.ports)   fixed PUBLIC; /* holds current 'tape' position */dcl port.jaz.sec.lsb (max.ports)   fixed PUBLIC;dcl port.jaz.fmk.inx (max.ports)   fixed PUBLIC; /* holds current file mark index */dcl port.jaz.cap.msb (max.ports)   fixed PUBLIC; /* holds current tape capacity	 */dcl port.jaz.cap.lsb (max.ports)   fixed PUBLIC;dcl port.jaz.update  (max.ports)   fixed PUBLIC; /* update pos by this much		 */zero.jaz.position:proc (port#) public;	dcl port# fixed;		port.jaz.sec.msb (port#) = 0;	port.jaz.sec.lsb (port#) = 0;	port.jaz.fmk.inx (port#) = 0;	port.jaz.cap.msb (port#) = 0;	port.jaz.cap.lsb (port#) = 0;end zero.jaz.position;fixedmode: proc(port#) returns (fixed); /* 0: variable, 1: fixed */   dcl port# fixed;   if (tape.type(port#) >= type.cdc)   then return (1); /* fixed    */   else return (0); /* variable */end fixedmode;disconnect: proc(port#) returns (fixed); /* 0: no disconnect, 1: do disconnect */   dcl port# fixed;   if (tape.type(port#) >= type.cdc)   then return (0); /* no disconnect */   else return (1); /* do disconnect */end disconnect;identifyme: proc(port#) returns (fixed); /* "H80": no disconnect, "HC0": do disconnect */   dcl port# fixed;   if (tape.type(port#) >= type.cdc)   then return ("H80"); /* no disconnect */   else return ("HC0"); /* do disconnect */end identifyme;scanmessins: proc(port#) PUBLIC; /* 0: no scan, 1: scan and toss message in phases */   dcl port# fixed;   return 1;                     /* skip and toss all messages */end scanmessins;tapeconnect:proc(target#,disconnect,identifyme);   dcl (target#)    fixed;   dcl (i)          fixed;   dcl (disconnect,identifyme) fixed;   disable;   write(ScsiBus ) = S$BSY;   write(ScsiData) = bits(Old.S.initiator);     /* initiator bit */   do i=0 to 5; end;   write(ScsiBus ) =S$SEL\S$BSY;            do i=0 to 5;  end;   write(ScsiData) =bits(Old.S.initiator)\bits(target#);    if disconnect<>0 then do;               /* gnd atn if disconnect */      do i=0 to 5; end;      write(ScsiBus ) =S$SEL\S$BSY\S$ATN;      do i=0 to 5; end;      write(ScsiBus ) =S$SEL      \S$ATN;   end;   else do;      do i=0 to 10; end;      write(ScsiBus ) =S$SEL;            end;   /* wait 3000 msec for busy: */   enable;   i=real.milliseconds;   do while ((read(ScsiBus)&S$BSY)=0)      and   (real.milliseconds < i+3000);   end;   if ((read(ScsiBus)&S$BSY)=0)  /* no busy - failed */   then do;      write(ScsiBus )=0;         /* clean up bus     */      write(ScsiData)=0;      return S$SelFailed;   end;   disable;   if disconnect<>0 then do;               /* gnd atn if disconnect       */      write(ScsiBus )=S$ATN;               /* release sel                 */      write(ScsiData)=0;                   /* clean up data    */      i=wait.for.req;                      /* wait for ready for command  */      if i<>0 then return i;      write(ScsiBus ) = 0;                 /* clear atn                   */      do i=0 to 5; end;      write(ScsiByte) = identifyme;   end;   else do;      write(ScsiBus )=0;      write(ScsiData)=0;                   /* clean up data    */   end;   enable;   return 0;end tapeconnect;/* $page - commands for tape *//*   Inquiry:   track #,   Tape.Inquiry,       9     TestUnit:  track #,   Tape.TestUnit,      0     Load:      track #,   Tape.LoadUnload,    1     Unload:    track #,   Tape.LoadUnload,    0     Modesel:   track #,   Tape.ModeSelect,    12,13, or 22      Request:   track #,   Tape.RequestSense,  7  or 9       Write:     track #,   Tape.Write,         fixedmode = 1: # of 4k word blocks                                                fixedmode = 0: 1     Read:      track #,   Tape.Read,          fixedmode = 1: # of 4k word blocks                                               fixedmode =0 : 1     Space:     track #,   Tape.Space,              Fmark:     track #,   Tape.WriteFile,     # of file marks to write     ModeSense  track #,   Tape.ModeSense,     4     TrackSel   track #,   Tape.TrackSelect    tape track #     ReadRev    track #,   Tape.ReadReverse    1 block     BlockSpace track #,   Tape.BlockSpace     # of blocks	  Capacity   track #,   Tape.ReadCapacity   0*/dcl Tape.Space.Count   fixed PUBLIC;dcl Tape.Space.Limit   fixed PUBLIC;dcl Tape.Space.Dir     fixed PUBLIC;dcl Tape.Reverse.Chunk (max.ports) fixed PUBLIC;dcl Tape.Reverse.Count (max.ports) fixed PUBLIC;dcl Tape.Reverse.Left  (max.ports) fixed PUBLIC;dcl Tape.Pmem.Add     fixed PUBLIC; /* poly memory address for read/write of data */dcl Tape.Disk.Add.Msb fixed PUBLIC; /* disk address for jaz tapes						 */dcl Tape.Disk.Add.Lsb fixed PUBLIC;Start.Tape.Command:proc(port#,track#,tcmnd,arg1) PUBLIC;   dcl port#   fixed;     /* port  # for this command */   dcl track#  fixed;     /* track # for this command */   dcl tcmnd   fixed;     /* coded tape comand #      */   dcl arg1    fixed;     /* argument                 */   dcl i       fixed;   dcl j       fixed;   dcl command fixed;   dcl lookup  data  (S$Inquiry      , S$TestUnitReady,                      S$LoadUnload   , S$LoadUnload,                      S$Modeselect   , S$RequestSense,                      S$Write        , S$Read,                      S$Space        , S$WriteFileMarks,                      S$ModeSense    , 0,                      S$TrackSelect  , S$ReadReverse,                      S$Space        , S$ReadCapacity,							 S$ExtendedWrite, S$ExtendedRead);							 	handle.error:proc;		port.retry(port#) = port.retry(port#) + 1;		port.io   (port#) = 0;   end handle.error;		post.error:proc;		track.command(track#)=command;		track.status (track#)=i;		handle.error();	end post.error;	   /* set up TPTR for operation: */   if port# < max.ports then do;     /* if using buffer memory,  */      tptr=(track#*total.stride)     /* get info for that tape   */          +((max.drives.per.track+tape.to.use(port#))*track.info.stride);   end;   else do;                          /* else get info for        */      tptr=tape1.tptr                /* the aux tape.            */          +(tape.to.use(port#)*track.info.stride);   end;   if track.drive.exists=0 then do;  /* do this before looking up    */	   handle.error();      return S$Notape;               /* port number                  */   end;   port.io          (port#)=tcmnd;         /* save our command code  */   port.timer       (port#)=real.seconds+300;   port.io.track#   (port#)=track#;        /* save track # for retry */   port.io.dtrack#  (port#)=track#;        /* in case interested     */   if tcmnd <> Tape.RequestSense           /* initially assume no    */   then tape.recover.code(port#)=0;        /* error recovery possible*/   command=lookup(tcmnd-Tape.Inquiry);     /* get scsi command       */   if command <> S$RequestSense then do;   /* preserve on sense      */      port.space.info  (port#)=0;   end;   call select.d24(track.d24#);            /* select d24 for drive   */   i=select.port.or.start.reset(port#,lun0.penable);   if i<>0 then do;                        /* reset occurred          */		post.error();      return i;   end;   i=wait.for.busfree.or.start.reset(port#);   if i<>0 then do;		post.error();      return i;                        /* since we did a reset     */   end;                                /* on the port              */   /* Set/clear mouse trap bit if using buffer memory card:        */   if port# < max.ports                /* only if using buff       */   then do;                            /* memory card              */      if ((command == S$Write        ) /* turn on write            */		||  (command == S$ExtendedWrite))		{         call targ0.connect(1);         write(ScsiByte)=3\shl((shr(tape.pmem.add,8)&"3"),2);         write(ScsiWord)=shl(tape.pmem.add,8);         port.lun1 (port# )=1;            /* inidicate lun1 enabled!  */         i=wait.for.busfree.or.start.reset(port#);       /* make sure  */         if i<>0 then do;                                /* bus is     */				post.error();            return i;                        /* since we did a reset     */         end;                                /* on the port              */		}      else if ((command == S$Read        )      ||       (command == S$ReadReverse )		||       (command == S$ExtendedRead))      then do;         call targ0.connect(1);         write(ScsiByte)=2\shl((shr(tape.pmem.add,8)&"3"),2);  /* data in */         write(ScsiWord)=shl(tape.pmem.add,8);                 /* address */         port.lun1 (port# )=1;                /* inidicate lun1 enabled!  */         i=wait.for.busfree.or.start.reset(port#);             /* make sure  */         if i<>0 then do;                                      /* bus is     */				post.error();            return i;                        /* since we did a reset     */         end;                                /* on the port              */      end;      else do;         /* clear mouse trap always */         call targ0.connect(1);         write(ScsiByte)=0;         i=wait.for.busfree.or.start.reset(port#);             /* make sure  */         if i<>0 then do;                                      /* bus is     */				post.error();            return i;                        /* since we did a reset     */         end;                                /* on the port              */      end;   end;      /* else for data transfers with dedicated d24 devices,  save poly     */   /* mem address for later use                                          */   else	{      if ((command == S$Read         )      ||  (command == S$ReadReverse  )      ||  (command == S$Write        )      ||  (command == S$ExtendedWrite)      ||  (command == S$ExtendedRead ))         port.tape.addr(port#) = tape.pmem.add;   }   i=tapeconnect(track.target#,disconnect(port#),identifyme(port#));      /* now connect to drive     */   if i<>0 then do;      track.command(track#)=command;      track.status (track#)=i;      if port.lun1(port#)<>0 then do;         j=wait.for.busfree.or.start.reset(port#);         if j<>0 then do;				handle.error();				return i;           /* could not even reset lun 1 */			end;         call targ0.connect(1);           /* clear lun 1                */         write(ScsiByte)=0;               /* clear lun 1 bits           */         port.lun1(port#)=0;      end;      call deselect(port#);		handle.error();      return i;   end;   i=wait.for.req;                     /* wait for ready for command */   if i<>0 then do;      track.command(track#)=command;      track.status (track#)=i;      if port.lun1(port#)<>0 then do;         j=wait.for.busfree.or.start.reset(port#);         if j<>0 then do;				handle.error();				return i;           				/* could not even reset lun 1 */			end;         call targ0.connect(1);           /* clear lun 1                */         write(ScsiByte)=0;               /* clear lun 1 bits           */         port.lun1(port#)=0;      end;      call deselect(port#);		handle.error();      return i;   end;   if (read(ScsiBus)&S$SigMask)<>S$Command   then do;                                /* lun exists       */      print 'No Command Phase Port ',port#;      if log.buf(0)=0 then do;         call log.error('Command Phase Error (Port #');         call append.decimal.number(port#);         call append.log.string(')');      end;   end;   write(ScsiByte) = command;   /* write out command byte      */				/* SCSI Command byte 0		*/   if  (command=S$Write)   or  (command=S$Read )   or  (command=S$ReadReverse)   then do;      i = fixedmode(port#);     /* see if writing variable or fixed blocks */      		write(ScsiByte) = shl(track.lun#,5) \ i; 									/* SCSI Command byte 1		*/      		if i = 0 then arg1=8192;  /* get length in bytes if variable mode    */      else if tape.type(port#) = type.tan      then arg1 = shl(arg1,3);  /* get # of 1024 byte blocks for TAN       */   end;   else if (command=S$Space)   then do;      if arg1=0 then do;  /* 0 = space to end of tape */         write(ScsiByte) = shl(track.lun#,5) \ 3; /* logical end of tape space */ 	/* SCSI Command byte 1	*/      end;      else if (tape.type(port#) >= type.cdc)      then do;         if tcmnd = Tape.Space  /* normal space - by file marks */         then do;            write(ScsiByte) = shl(track.lun#,5) \ 1; /* cdc - must be file marks */	/* SCSI Command byte 1	*/         end;         else do;               /* blockspace   - by blocks     */            write(ScsiByte) = shl(track.lun#,5) \ 0; /* cdc - use blocks */			/* SCSI Command byte 1	*/         end;      end;      else do;         write(ScsiByte) = shl(track.lun#,5) \ 0; /* logical blocks */      end;   end;   else write(ScsiByte) = shl(track.lun#,5);									/* SCSI Command byte 1		*/   i=wait.for.req;                        /* wait for REQ */   if i<>0 then do;      track.command(track#)=command;      track.status (track#)=i;      if port.lun1(port#)<>0 then do;         j=wait.for.busfree.or.start.reset(port#);         if j<>0 then do;				handle.error();				return i;           			   /* could not even reset lun 1 */         end;			call targ0.connect(1);           /* clear lun 1                */         write(ScsiByte)=0;               /* clear lun 1 bits           */         port.lun1(port#)=0;      end;      call deselect(port#);		handle.error();      return i;   end;   /* Write out the rest of the command bytes if the LUN exists:        */   if ((read(ScsiBus)&S$SigMask) == S$Command)	/* if lune exists			*/   {		if (command == S$ExtendedWrite)		{			write(ScsiWord) = Tape.Disk.Add.Msb;			write(ScsiWord) = Tape.Disk.Add.Lsb;			write(ScsiByte) = 0;			write(ScsiWord) = arg1;			write(ScsiByte) = 0;  						port.io(port#)=Tape.Write;					/* map to write for result processing */		}				else if (command == S$ExtendedRead)		{			write(ScsiWord) = Tape.Disk.Add.Msb;			write(ScsiWord) = Tape.Disk.Add.Lsb;			write(ScsiByte) = 0;			write(ScsiWord) = arg1;			write(ScsiByte) = 0;  						port.io(port#)=Tape.Read;					/* map to read for result processing  */		}				else		{			if ((command == S$Space)			&&  (arg1    <  0      ))			then write(ScsiByte) = (-1);												/* SCSI Command byte 2		*/		  			else write(ScsiByte) = 0;													/* SCSI Command byte 2		*/				write(ScsiWord) = arg1;    				/* SCSI Command byte 3		*/	/* SCSI Command byte 4		*/				/* If ejecting a tanberg tape,  position at end of medio so */			/* that a retension function is performed next time the     */			/* tape is loaded:                                          */				if  (tape.type(port#) = type.tan)     /* if tape was a tandberg last time we used it */			and (command = S$LoadUnload     )     /* trying to unload it now                     */			and (arg1    = 0                )	  /* I think this is the tanberg retension bit?  */			then write(ScsiByte) = "200";			  /* SCSI Command byte 5		*/ 			else write(ScsiByte) = 0;				  /* SCSI Command byte 5		*/ 						if (command == S$ReadCapacity)			{				write(ScsiWord) = 0;					  /* finish ten-byte SCSI command sequence       */				write(ScsiWord) = 0;			}		}	}		else if (tcmnd == Tape.ExtendedWr)			/* oops: no command phase! Map type				*/  		port.io(port#) = Tape.Write;				/* to regular write for later processing		*/			else if (tcmnd == Tape.ExtendedRd)			/* oops: no command phase! Map type				*/  		port.io(port#) = Tape.Read;				/* to regular read for later processing		*/	   call deselect(port#);   return 0;end Start.Tape.Command;/* Append tape mess is passed a port #.   it lists the track #s that *//* go with this port                                                 */append.tape.mes: proc(port#) PUBLIC swapable;   dcl port# fixed;   dcl i     fixed;   if port# >= max.ports   then call append.log.string('Auxiliary Drive');   else do;      call append.log.string('Drive ');      call append.decimal.number(port# + 1);   end;end append.tape.mes;