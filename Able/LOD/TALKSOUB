/* TALKSOUB -   $TITLE routines to log error messages on synclavier   Modified:   02/06/92 - cj  - documented buf.len command (144:58), (144:59), (144:60)   07/29/91 - cj  - documented new syncl/lod commands for Envelope info   02/06/91 - cj  - documented new syncl/lod commands for tape skipping   06/14/89 - cj  - documentation of the SYNCL to LOD commands for scrubbing   03/13/89 - LSS - changed messages that still referred to "songs"   07/26/88 - MWH - Add DSP interface   03/21/88 - MWH - Add wave display data compression and transfer   *//* other error check routines for song & track directory *//* this.track.avail.and.ready - passed a track #.  returns true if *//* track is available and track directory is memory.   Logs an     *//* error message and returns a 0 if track is not available or      *//* system is not ready for input.                                  */this.track.avail.and.ready: proc(track#);   dcl track# fixed;   if track.dir.valid=0   then call log.sys.is.not.ready;   else if track.available(track#)=0   then call log.error('Track is Not Available');   else return 1;              /* track is available and ready              */   return 0;                   /* if not available or ready                 */end this.track.avail.and.ready;track.avail.and.ready: proc;   /* return status of DTD.TRACK#        */   return this.track.avail.and.ready(dtd.track#);end track.avail.and.ready;/* See if there is room in the song directory to do a 'shuffle up'          */room.in.song.dir: proc swapable;   dcl (i,j,k) fixed;   k=1;   i=(num.songs-1)*song.len;                    /* check top-most entry */   if (gsong.dir(i+song.start)<>0)   or (gsong.dir(i+song.end)  <>0)   then k=0;                                    /* no room              */   do j=0 to 11;      if gsong.dir(i+song.title+j)<>(32\shl(32,8))      then k=0;   end;   if k=0 then call log.error('Project Directory is Full (Check Last Entry)');   return k;end room.in.song.dir;/* track.error.check is called when a track is selected.   It logs an *//* error message if any i/o errors have occurred for this track.       */track.error.check: proc;   if  (track.command(dtd.track#)=0)   and (track.status (dtd.track#)=0)   then return;   if log.buf(0)<>0 then return;   call log.error('Track Error Status: Command ');   call append.decimal.number(track.command(dtd.track#));   call append.log.string(' Status ');   call append.decimal.number(track.status(dtd.track#));      if (track.status (dtd.track#) == S$BadDrive)									/* only show bad drive message	*/		{track.status (dtd.track#) = 0; track.command(dtd.track#) = 0;}	/* once...						*/end track.error.check;/* background commands *//* the system can perform load, backup, and erase functions in background *//* while the rest of the system is operating                              */dcl command.stack(max.commands*command.stride) fixed PUBLIC;dcl command.in                    fixed PUBLIC;  /* store pointer     */dcl command.out                   fixed PUBLIC;  /* read pointer      */dcl (command.#)                   fixed PUBLIC;  /* nonz: current command  */dcl (command.song)                fixed PUBLIC;  /* song # there of        */dcl (command.tracks)              fixed PUBLIC;  /* bits for affected trks */dcl (command.completed)           fixed PUBLIC;  /* 1: completed           */dcl (abort.command)               fixed PUBLIC;  /* 1: set by user to abrt */dcl (command.fatal)               fixed PUBLIC;  /* 1: fatal error hapnd   */dcl (command.aborted)             fixed PUBLIC;  /* 1: command was abrted  */dcl (command.song.dir.updated)    fixed PUBLIC;dcl (command.track#) (max.ports)  fixed PUBLIC;  /* which track to use     */dcl mark.stars procedure recursive;dcl (errmess) fixed PUBLIC;push.command:proc(com#,song#,tracks,code) swapable;   dcl com#    fixed;      /* command #  */   dcl song#   fixed;      /* song    #  */   dcl tracks  fixed;      /* track bits */   dcl code    fixed;      /* code       */   command.stack(command.in  )=com#;   command.stack(command.in+1)=song#;   command.stack(command.in+2)=tracks;   command.stack(command.in+3)=code;   command.in=command.in+command.stride;   call mark.stars;   errmess=0;                /* re-display "load" message after 2'nd command */   abort.command=0;end push.command;/* $page - more error message routines */room.for.commands:proc;   if (command.in+command.stride) < ((max.commands-1)*command.stride)   then return 1;   call log.error('System is Temporarily Overloaded');   return 0;end room.for.commands;/* see if song is stacked for a command *//* if so, disallow certain changes      */check.song: proc;   dcl i fixed;   dcl j fixed;   i=0;   if  (command.#<>0)   and (command.song=song.base+dtd.song#)   then i=1;   j=command.out;   do while j<command.in;      if (command.stack(j+1)=song.base+dtd.song#)  /* this song */      then i=1;      if command.stack(j)=c.bounce      then j = j + (command.stride + bounce.mix.rec.len);      else j = j + (command.stride                     );   end;   if i<>0 then do;      call log.error('Changes Not Allowed while Command Outstanding');      return 1;   end;   return 0;end check.song;mark.stars: proc PUBLIC swapable;  /* put stars by songs with outstanding commands */   dcl (c,i,j,k) fixed;   dcl (all    ) fixed;   dcl (stars  ) (num.tracks)  fixed;   all=0;   do i=0 to num.songs-1;                   /* clean out all stars */      call gsong.dir(i*song.len+song.star); /* in project records  */      write(md)=0;   end;   do i=0 to num.tracks-1;                  /* also clean out stars */      stars(i)=0;                           /* in local copy of     */   end;                                     /* track star info      */   if command.#<>0 then do;                 /* command is outstanding */      if (command.# = c.verfall)            /* need special case for verify all */      or (command.# = c.aall   )            /* need special case for add    all */      then all=1;      else if command.song=(-1) then all=1;      else do;         call gsong.dir(command.song*song.len+song.star);         write(md)=2;         if command.song=track.dir.song         then do i=0 to num.tracks-1;            if (command.tracks&track.avail.bits&bits(i))<>0            then stars(i) = 2;         end;      end;   end;   i=command.out;   do while i<command.in;      c=command.stack(i  );                 /* get comm # */      j=command.stack(i+1);                 /* get song # */      if (c = c.verfall)                    /* need special case for verify all */      then all=1;      else if (j=(-1)) then all=1;      else do;         if   gsong.dir(j*song.len+song.star)<>2         then write(md)=1;         if j=track.dir.song         then do k=0 to num.tracks-1;            if (command.stack(i+2)&track.avail.bits&bits(k))<>0            then do;               if   stars(k) <> 2               then stars(k) =  1;            end;         end;      end;      if c=c.bounce      then i = i + (command.stride + bounce.mix.rec.len);      else i = i + (command.stride                     );   end;   if all<>0 then do;                             /* if command involves  */      do i=0 to num.songs-1;                      /* all projects and all */         if gsong.dir  (i*song.len+song.star)<>2  /* tracks,  then set    */         then write(md)=1;                        /* all stars            */      end;      do k=0 to num.tracks-1;         if   stars(k) <> 2         then stars(k) =  1;      end;   end;   do i=0 to num.tracks-1;      track.dir(i*track.len+track.bits) = (track.dir(i*track.len+track.bits)                                           & "177774")                                         \ stars(i);   end;   send.screen.info=1;end mark.stars;/* $page - Clean Up Track Directory *//* This routine is called whenever a new track directory is read in *//* from disk or tape.   It checks to see if the default output      *//* routings have been set up,  and also 'SAFES' all unavailable     *//* tracks.                                                          */Clean.Up.Track.Directory: proc (tdir) PUBLIC swapable;   dcl tdir  array;   dcl i     fixed;   /* clean up track directory by "safing" all */   /* unavailable tracks,  and initializing    */   /* the routing for old track directorys:    */   do i=0 to max.tracks-1;               /* look at all tracks in directory */      t.sr=tdir(i*track.len+track.stat); /* get safe ready bit              */      if track.available(i)=0            /* turn all unavailable tracks     */      then t.sr=t.sr&"177776";           /* to "safe"                       */      tdir(i*track.len+track.stat)=t.sr;      /* Set up default output routings */      /* if none have been set up       */      /* before:                        */      if (tdir(i*track.len+track.bits) & 4) = 0      then do;          tdir(i*track.len+track.bits ) = tdir(i*track.len+track.bits)                                         \ 4;          tdir(i*track.len+track.routs) = i + 1;       end;   end;end Clean.Up.Track.Directory;/* $page - other error checks */check.tracks.for.erase: proc(idbits) swapable;   dcl idbits fixed;   dcl i      fixed;   dcl j      fixed;   call song.lookup;   if (s.status&2)<>0   /* protected                   */   then  call log.error('Project is Locked - Cannot Erase Track');   else if check.for.song.overlap<>0   then call log.error('Projects Overlap - Cannot Erase');   else if room.for.commands=0 then do;end;   else do;      do i=0 to max.tracks-1;         if  (idbits&bits(i))<>0 then do;            if this.track.avail.and.ready(i)=0 then return 0;            call this.track.lookup(i);            if (track.dir.valid=0) or (new.dtd.song#<>0)            then do;               call log.error('System is Not Ready for Commands');               return 0;            end;            if (t.sr&1)=0 then do;  /* track is safe               */               call log.error('Track is Safe - Cannot Erase');               return 0;            end;            if (t.sr&2)<>0 then do; /* track is locked             */               call log.error('Track is Locked - Cannot Erase');               return 0;            end;            if track.recording(i)<>0 then do;               call log.error('Cannot Erase Track While Recording');               return 0;            end;         end;      end;      return 1;       /* all specified tracks can be erased */   end;   return 0;end check.tracks.for.erase;/* $page - Synclavier/Lod Scsi Protocol Documentation *//* protocol:   0       Your basic 'Do Nothing' Message   1       Sent from Synclavier to Live Overdub  -  'HELLO'           Loader rom  returns a 2  (tells Synclav to LOAD LOD   )           LOD program returns a 3  (tells Synclav LOD is running)   4       Sent from Synclavier to Live Overdub  -  'REBOOT'   4       Sent from lod to synclavier:  'send new motion';   5       Sent from lod to synclavier:  punch in/out has occurred   6       Sent from lod to synclavier:  end of command (dtd info)   7       Sent from lod to synclavier:  start up cues in middle   10      Down arrow - sent from Synclav to Live Overdub on down arrow   11      Up   arrow - sent from Synclav to Live Overdub on up   arrow   12      Select song directory   13      Select track display   14      toggle song lock/unlock   15      home cursor   16      toggle repro/input/auto   17      toggle safe/ready   18      request adir for system bugs   19      delete song info from song directory   20      insert (+) song into directory   21      insert (-) song into directory   22      disk dump for debugging   23      null command - do nothing   24      get next forward alphabetic cue   25      get next prior   alphabetic cue   26      get next forward time       cue   27      get next prior   time       cue   28      re-read current cue   29      ask for init info + cue info   30      see if current song is ready for command   31      get next forward smpt       cue   32      get next prior   smpt       cue   33      free up all read.track activity   34      request current cross fade, and sample rate settings   64      Start triggered playback (cue definition process)   65      Stop  triggered playback (cue definition process)   66      scrolling on   67      scrolling off   68      start of data function reading   69      stop  point playback or data function read playback   70      Prepare DTD for cue scrubbing   128     From LOD to SYNCLAV - followed by message to be           printed on terminal (Error/Log messages)   130     From SYNCLAV to LOD - 'REAL TIME' Message           play.time.lsb           play.time.acu           smpte.track.rate (if smpte only)           followed by additional smpte information           followed by list of cue triggers if applicable   131     Motion message from Synclav to LOD           play.time.msb           play.time.lsb           play.time.acu           samp.speed           motion bits        (pnch move recd play)           play track bits           3 spare play track words           recd track bits           3 spare recd track words           mark.button.state           mark.button.msb           mark.button.lsb           mark.button.acu           smpte.onoff           smpte.mode.rate           0           0           0           0   132     Set buffer position for cue definition playback           msb time           lsb time           acu time           0           0           0           0           0           0           0           0           0           0           0           0           0   133     Trigger cue for playback   134     Send triggered source playback soloed bits   135     Send Initiate Cue Recording record   136     Change Cue Trigger Playback Rate   137     Send over cue for storage in tcue.xmsec#   138     Send over info for synclavier sequencer track (cue track volume, routing, etc)   139     Set current cue scrubbing position   140     Send song/track name - send from Synclavier to LOD.   enter           new song or track name in directory   141     Send start time - send a new start time from synclav to LOD   142     send end time   - send a new end   time from synclav to lod   143     set screen line - used with mouse to position cursor   144     send command              0: backup song    2: backup all     4: erase song              1: load   song    3: load   all     5: erase all              6: erase track    7: backup track   8: load track              9: abort         10: lock all      11: all safe             12: lock song     13: unlock song   14: unlock track             15: lock trk      16: all repro     17: all input             18: all auto      19: home tape     20: verify song             21: eject tape    22: verify all    23: read track data             24: erase long    25: all cue pb    26: bounce/mix (see below)             27: set ff/rew sp 28: set scroll md 29: get cue indexes             30: auto allocate 31: get armed     32: set ready display             33: check for record protection     34: zero out part of track buffer             35: get sync point                  36: update sync point for cue def             37: see if command completed        38: punch in/out of armed recording             39: get tdir info for track x       40: set dig xfer mode             41: erase 4 track                   42: Set DDT Format & Sync             43: set info for Optical.Ptr;       44: erase 2 track             45: get amount of poly memory       46: see if poly mem is available             47: read disk into poly memory      48: start audition             49: stop audition                   50: get cur proj sampling rate             51: see if ready for scrub stacking 52: add to project             53: add to all projects             54: show next project             55: skip forward                    56: skip backwards             57: enable for Envelope info        58: return buf.len             59: move poly around for bounce     60: set DDSYN mode   145     set input channel   146     set sampling rate   147     set gain   148     set volume   149     set pan   150     set crossfade   151     send software revision info   152     select new current song 0-50   153     set safe/ready   154     set repro/input/auto/cue pb   155     set track doa routing   156     set track(voice) DDT routing   179     general scsi to poly transfer   180     send new dtd cue definition   181     locate a cue   182     fetch a cue record   scsi.ptr(0) = id#; scsi.ptr(1) = 1 to see raw data (vs converted info)   183     re-write a cue record   184     delte a cue id#   185     partial name alphabetic search   186     search for cue at time x   187     get nth alphabetic cue   188     get nth time       cue   189     see song directory info   190     search for cue at smpte bit time x   191     get nth smpt cue     192     get sample data (quickly) - scsi.ptr(0) = track#; scsi.ptr(1) = disk sector msb; scsi.ptr(2) = disk.sector.lsb;   193     start compressing display data   194     fetch compressed display data (if it has finished compressing)   195     see if read/write command is finished (from data read/write)   196     store data in track buffer (to do digital to digital to dtd from synclav)   197     construct cross fade in data stored in buffer   198     write track data to disk from poly buffer   199     DSP command   200     Load Address           Sent from Synclavier to Overdub ROM code during software load.           Used to set the Load Address for following Load Data           Clears the check sum accumulator    201     Load Data           Sent from Synclavier to Overdub ROM code during software load.           Loads 256 word into LOD Computer Memory    202     Checksum/Execute        (Note: checksum not used now)           Sent from Synclavier to Overdub ROM code during software load.           Causes execute of loaded code.   210     Load Address - syncl program to LOD for Frequency Table   211     Load Data - syncl program to LOD for Frequency Table   212     debug disk writes    220     Send Song Info - followed by dtd.song# (0-9), plus           10 lines of song directory info.   221     Send Track Info - followed by dtd.track# (0-15), plus           16 lines of track directory information.              222     send initialize info - send dtd.max.secs,  dtd.max.tracks,           dtd.max.inputs              223     send 1 sector of debug info   224     send sectors of ddu data   225     send expanded initialization information   226     send current play time from lod to synclav   227     send cue id# and optional record from lod to synclav   228     send cue data to synclav to store in poly   229     send cue data to synclav to store in external memory   230     send time base adjust information   231     file load request (DSP -> SYNCLAV only)   232     current scrub position (DTD -> SYNCLAV only)   so: */   /* $page - bounce/mix */   /* a bounce mix command has been implemented that provides for      bouncing and or mixing direct to disk data.   this command      can be used to:          1) volume scale a track, part of a track, or a cue          2) bounce a track, part of a track, or a cue to part of             another track,  a whole track,  or a cue          3) combine tracks,parts of tracks, or cues with individual             volume control.      the command operates by specifying two sources and a destination.      One of the sources is null in the case of a bounce.      Volumes are specified on a scale of 1000 = 1.000;      Tracks must be in the current song;  cues can be anywhere on      the disk.   Track times are specified in milliseconds (msb,lsb).      Cues are specified by id#.      To start a bounce/misc command,  a special record must be set      up in external memory,  and passed to the LOD software.      this record looks like:           write(mam)=scsi.ptr;      0.   write(mdi)=26;         command code for bounce mix      *   source #1: *      1.   write(mdi)=1           if source #1 is a cue           or        =2           if source #1 is part of a track      2.   write(mdi)=0                      or        =start msb   if source #1 is part of a track      3.   write(mdi)=0           or        =start lsb   if source #1 is part of a track      4.   write(mdi)=0           or        =end msb     if source #1 is part of a track      5.   write(mdi)=0           or        =end lsb     if source #1 is part of a track      6.   write(mdi)=track# 0-15 source #1 track # (note: use 0-15)      7.   write(mdi)=volume      use 1000 if no volume change desired      8.   write(mdi)=fade(ms)    digital fade in/out time (milliseconds)                                  for source #1.  use 0 for butt splice      9.   write(mdi)=spare     10.   write(mdi)=spare     * source #2: *     11.   write(mdi)=0           if there is no source #2 to mix in           or        =1           if source #2 is a cue           or        =2           if source #2 is part of a track     12.   write(mdi)=0                      or        =start msb   if source #2 is part of a track     13.   write(mdi)=0           or        =start lsb   if source #2 is part of a track     14.   write(mdi)=0           or        =end msb     if source #2 is part of a track     15.   write(mdi)=0           or        =end lsb     if source #2 is part of a track     16.   write(mdi)=track# 0-15 source #2 track # (note: use 0-15)     17.   write(mdi)=volume      use 1000 if no volume change desired     18.   write(mdi)=fade (ms)   digital fade in/out time (milliseconds)                                  for source #2.  use 0 for butt splice     19.   write(mdi)=spare     20.   write(mdi)=spare     * Destination: *     21.   write(mdi)=1           if destination is a cue           or        =2           if destination is part of a track     22.   write(mdi)=0                      or        =start msb   if destination is part of a track     23.   write(mdi)=0           or        =start lsb   if destination is part of a track     24.   write(mdi)=0           or        =end msb     if destination is part of a track     25.   write(mdi)=0           or        =end lsb     if destination is part of a track     26.   write(mdi)=track# 0-15 destination track # (note: use 0-15)     27.   write(mdi)=volume      use 1000 if no volume change desired     28.   write(mdi)=fade (ms)   digital fade out/in time (milliseconds)                                  for destination.  use 0 for butt splice     29.   write(mdi)=spare     30.   write(mdi)=sparenote:  the destination track must be 'READY'warning:  not much other error checking is done!!send the info to direct to disk with     SEND.TO.LOD(144,64);Literals: */dcl bounce.mix.rec (bounce.mix.rec.len-1) fixed PUBLIC;convert.bounce.record.to.samples: proc(arr,type,msb);   dcl arr  array;   dcl type fixed;   dcl msb  fixed;   return; /* for now due to space shortage */  if arr(type)=1 then do;     /* look up cue */     call lookup.cur.cue(arr(msb));     /* arr(msb  )=cc.s.msb; */     /* arr(msb+1)=cc.s.lsb; */     /* arr(msb+2)=cc.e.msb; */     /* arr(msb+3)=cc.e.lsb; */  end;  else if arr(type)=2 then do;     /* call compute.mark.start.point(loc(addr(arr(msb))),0,1,loc(addr(arr(msb))));     */     /* call compute.mark.start.point(loc(addr(arr(msb+2))),0,1,loc(addr(arr(msb+2)))); */  end;    /* compute disk sector address here */  /* round down starting sample # to get start of cue */  arr(msb+1) = shr(arr(msb+1),8)\shl(arr(msb),8);  arr(msb  ) = shr(arr(msb  ),8);  /* round up ending sample # to get end of cue */  if (arr(msb+3)&255)<>0 then do;     /* round up ending sample # */     arr(msb+3) = arr(msb+3) + 255;     if arr(msb+3) ilt 255 then do;        arr(msb+2)=arr(msb+2)+1;     end;  end;  arr(msb+3) = shr(arr(msb+3),8)\shl(arr(msb+2),8);  arr(msb+2) = shr(arr(msb+2),8);end convert.bounce.record.to.samples;/* $page - check record protection *//* returns true if it is ok to record in current song *//* Note: Check.Record.Protection should not swap since it is *//* called every loop time from the main loop while recording */check.record.protection: proc PUBLIC;   if (gsong.dir((song.base+dtd.song#)*song.len+song.status)&2)<>0   then do;      call Log.Error('Cannot Record - Project is Lock Protected');      return 0;   end;   else if  (track.dir.valid=0)       /* track dir must be valid to check safe/ready */   then do;      call Log.Error('Direct-to-Disk System is Not Ready to Record');      return 0;   end;      else if songs.overlap <> 0         /* if any songs overlap        */   then do;      log.buf(0)=0;                   /* give this message priority  */      call log.error('Cannot Record:');      call log.overlap.message;      return 0;   end;   else if COM16(0, Song.Length) = LW#IEQ   then do;      call log.error('No Space Reserved for Project: Cannot Record');      return 0;   end;   return 1;end check.record.protection;/* Handy routine to see if any voice is on at the moment */any.chan.on: proc swapable;   dcl i fixed;   do i = 0 to max.voices-1;             /* if any poly voice is on */      if chan.on(i) <> 0 then return 1;  /* then return true        */   end;   return 0;                             /* else no voices on       */end any.chan.on;