/* STACKB - 'Stack.Cue' routine *//* 01-01/92 - cj - Fixed bug with extended cues going to wrong output      *//* 11-20/91 - cj - Removed butt splice from adjacent cues                  *//*                 to fix D2 click/pop bug                                 *//* 09-27/91 - cj - Sent envelope info to DSP during TRIG                   *//* 08-15-91 - cj - Improved track routing ability for Lucas                *//* 06-21-91 - cj - Allowed audition cue to overrided 'input' mode          *//* 05/16/90 - cj - changed polyphonic track logic to fix routing bugs      *//* 06/14/89 - cj - truncate play buffers if stacking cues during scrubbing *//* notes on cue recording:   When the Initiate Cue Recording record is received from the synclavier,three processes are started in the direct to disk.   First,  the RECRECarray is set up to contain the parameters of the armed recording,  andthe variable 'armed' is set.   Secondly,  a process is started thatwill eventually result in a cue being stacked for the desired tracks.If internal sync is being used (ie TRIG),  then the cue is stackedusing the TRIG.RECORD logic,  as if it were the trigger of a cueto play back.   If external sync is being used (ie PLAY),  then the cueis stacked by the main loop once the synclavier has entered play mode.   A third process is set underway to punch in at the correct synclaviertime and to punch out at the correct synclavier time.   If the cue isstacked correctly and the punch in/out occurs on time,  the desiredrecording will take place *//* ********* *//* Stack cue:   this routine is used to stack an audio segment on *//* the playback stack for a particular track.   it is passed      *//* a track #,  a bits word,  a sync time (the time to trigger     *//* the start of the segment), an in time (the disk sample # of    *//* the first sample to play at that time),  and an out time),     *//* and an info word to handle track routing & volume control.     *//* if the in time is 0,0  then the punch over is performed        *//* but no other audio is stacked                                  */dcl Stacked.End.Time (1) fixed PUBLIC; /* holds info for last cue */dcl (play,loop,trig)   fixed external; /* needed from mainsou     */dcl gap.window  lit '256';       /* gaps to delete                */dcl but.window  lit '256';       /* but splice window             */stack.cue:proc(track#, exists, s.arr, d.arr, e.arr, info, t.arr, Env, dtrack#);   dcl (track#)       fixed;     /* pass track# 0-15               */   dcl (exists)       fixed;     /* pass bit info                  */   dcl (s.arr)        array;     /* sync time                      */   dcl (d.arr)        array;     /* disk time                      */   dcl (e.arr)        array;     /* end time                       */   dcl (info)         fixed;     /* syncl track#, output #         */   dcl (t.arr)        array;     /* cue time for voice priority    */   dcl (Env)          array;     /* and envelope information       */   dcl (dtrack#)      fixed;     /* track# that has data on it     */   dcl (s,d,e,t) (1)  fixed;     /* working copy is stored here    */   dcl (x,y)     (1)  fixed;     /* temp arrays                    */   dcl emsb      lit  'e(0)';   dcl elsb      lit  'e(1)';   dcl xmsb      lit  'x(0)';   dcl xlsb      lit  'x(1)';   dcl ymsb      lit  'y(0)';   dcl ylsb      lit  'y(1)';   dcl (i,j,k)        fixed;   dcl (case)         fixed;   dcl (action)       fixed;   dcl (voice#)       fixed;   dcl (resolved)     fixed;   dcl (Tenv) (ESegSize) fixed;   dcl (Infinity)  data (-1,   -1);   dcl (ZZ)        data ( 0,    0);   dcl toss.old.cue   lit  '  1';   /* this bits control the action to */   dcl split.new.cue  lit  '  2';   /* take in the punch over cases    */   dcl split.old.cue  lit  '  4';   dcl delay.new.cue  lit  '  8';   dcl delay.old.cue  lit  ' 16';   dcl trunc.new.cue  lit  ' 32';   dcl trunc.old.cue  lit  ' 64';   dcl stack.new.data lit  '128';   dcl stack.old.cue  lit  '256';   dcl stack.src.cue  lit  '512';   dcl toss.new.cue   lit '1024';   dcl extend.old.cue lit '2048';   dcl stack.new.env  lit '4096';   dcl backup.data    lit '8192';   dcl Seg.Ptr        fixed;   /* Subroutine to back up READ and RT pointers if they happen */   /* to point to a block we are deleting:                      */   backup.read.and.rt: proc(bptr);      dcl bptr fixed;   /* pass new back pointer */      /* if this happens to be the cue we are reading */      /* then back up read pointer as well            */      if   bptr = shl(track#, 1)   /* if back pointer pointed to      */      then bptr = 0;               /* head of cue,  use 0 here        */      if cue.read.ptr  (track#) = Seg.Ptr   /* if we were pointint to */      then cue.read.ptr(track#) = bptr;     /* this block, back up    */      if cue.rt.ptr  (track#) = Seg.Ptr      then cue.rt.ptr(track#) = bptr;   end backup.read.and.rt;   set.read.and.rt: proc(bptr);      dcl bptr fixed;   /* pass new block pointer */      /* set read and rt pointing to this block when putting */      /* the first block on the list:                        */      if cue.read.ptr  (track#) = 0       /* if were pointing to no */      then cue.read.ptr(track#) = bptr;   /* block,  now point here */      if cue.rt.ptr  (track#) = 0      then cue.rt.ptr(track#) = bptr;   end set.read.and.rt;   /* see if begin & end times are out of order */   New.Seg.List        = 1;    /* segment list will likely change    */   call COPY32(s.arr, s);      /* copy sync, disk in, disk out times */   call COPY32(d.arr, d);      /* over to working copy array         */   call COPY32(e.arr, e);   call COPY32(t.arr, t);   /* round up/down to sector bounds:    */   /* this makes cue times always get    */   /* the right data when mapped back    */   /* and forth between samples and      */   /* a synclav time                     */   call ROUND32(s);              /* round all times to sector       */   call ROUND32(d);              /* boundaries for now              */   call ROUND32(e);   if COM32(e,d) <= lw#ieq     /* exchange disk in/disk out times    */   then do;                    /* if they are out of order           */      if COM32(e,d) = lw#ieq   /* also check for zero region left.   */      then return;      call COPY32(e,x);      call COPY32(d,e);      call COPY32(x,d);   end;   call SUB32(e,d,e);            /* now recompute sector length      */   call ADD32(e,s,e);            /* re-compute sync end sample#      */   if COM32(e, Stacked.End.Time) = lw#igt   /* save last end time so */   then call COPY32(e, Stacked.End.Time);   /* TRIG knows when to    */                                            /* stop.                 */   /* make sure track is available, etc. */   if  (track.available (track#) =  0 )    /* track is not available */   or  (track.recording (track#) <> 0 )    /* or being recorded??    */   then return;   /* set up info word if none provided:                             */   if (info & 63) = 0            /* if no routing specified...       */   then do;                      /* then use repro mode default      */      voice# = track.dir(track#*track.len+track.routs) & 255;      if voice# = 0 then voice# = 32;         /* for now, map off to 32, */      info = info \ 32 \ (voice#-1);          /* store in cue info       */   end;   if COM16(0, d) <> lw#ieq        /* if actual disk address is specified */   then do;      action = stack.new.data \ stack.new.env;      any.cues.stacked (track#) = 1;  /* and cause audio to switch        */      if (shr(info,6) = 512 + cue.audition.track)      then do;                            /* but if this is the audition  */         audit.cue.stacked(track#) = 1;   /* cue, set special flag and    */         if (source.or.cue(track#)<>1)    /* and check to see if we had   */         then do;                         /* been in input mode instead   */            zap.buffer(track#) = 1;       /* of cue playback.  If so,     */            source.or.cue(track#) = 1;    /* zap undesired repro audio    */         end;                             /* we don't want to hear.       */      end;   end;   else action = toss.new.cue;     /* else we are calling just to delete audio */   /* make sure this track is in cue playback mode */   if (source.or.cue(track#)<>1)   then do;      source.or.cue(track#)=1;      exists = exists \ 128;           /* set bit to switch back to source after cue playback */      action = action \ stack.src.cue; /* stack source before new cue      */   end;   /* $page - perform priorety punch over                       */   /* see if there are any prior cues on stack                  */   /* that should get deleted or punched over                   */   /* save their pieces on a temporary push                     */   /* so they can be re-stacked if we are                       */   /* doing a punch over                                        */   /* notes on punch over:                                      */   /*                                                           */   /* in the following description,  the 'new' sound            */   /* is the cue that is being started now.                     */   /* the 'old' sound is a prior cue on the stack.              */   /*                                                           */   /* there are 7 possible spacial arangements that             */   /* may exist between the new sound and the old sound         */   /* as shown here:                                            */   /*                                                           */   /*           [old sound extends here]                        */   /*     <=  <= >    >  <            <  >= >=                  */   /*  [#1]   [#2]    [#3]            [#4]  [#5]                */   /*         [#6------------------------]                      */   /*                                       [#7]                */   /*         <=                         >=                     */   /*                                                           */   /* #1 - new sound begins and ends <= start of old sound      */   /*         a: new sound gets stacked in entirety.            */   /*         b: old sound get tossed if not punching over,     */   /*            or kept in entirety regardless of priority     */   /*            if we are punching over                        */   /*                                                           */   /* #2 - new sound begins <= start of old sound but           */   /*      ends > start of old sound < end of old sound         */   /*         a: new cue gets shortened if lower priority       */   /*         b: start of old sound gets chopped off if new     */   /*            sound has higher priorety.  old sound gets     */   /*            tossed if not punching over                    */   /*                                                           */   /* #3 - new sound begins > start of old sound and            */   /*      ends < end of old sound                              */   /*         a: new sound gets tossed if lower priority        */   /*         b: old sound gets split up if new sound has       */   /*            higher priority                                */   /*         c: old sound gets truncated if not punching       */   /*            over                                           */   /*                                                           */   /* #4 - new sound begins < end of old sound and              */   /*      ends >= end of old sound                             */   /*         a: new cue gets delayed if it is lower priority   */   /*         b: old cue gets truncated if it is lower priority */   /*                                                           */   /* #5 - new sound begins and ends >= end of old sound        */   /*         a: no change to either cue regardless of priority */   /*                                                           */   /* #6 - new sound begins <= start of old sound and           */   /*      ends >= end of old sound                             */   /*         a. old sound gets tossed if it is lower           */   /*            priority                                       */   /*         b. new sound gets split up into 2 pieces if it    */   /*            is lower priority                              */   /* #7 - is a special case of #5 where the new audio is a     */   /*      continuation of the prior audio.  We want to extend  */   /*      the old cue, and just stack the new envelope and     */   /*      check the play buffers.                              */      next.cue:;   write(mam) = cseg.xmsec#;           /* look up  starting pointer  */   write(mal) = shl(track#, 1) + 1;    /* to see if list is empty    */   Seg.Ptr    = read(md);              /* point to last block on que */   if  (Seg.Ptr <> shl(track#, 1))     /* if que has any blocks      */   then do;                            /* then check for conflicts   */                                             call read.seg.stack(Seg.Ptr);    /* read record into memory    */      if (0)                           /* not used 11/20/91          */      /* if (Seg.Exists&2) <> 0           if prior segment loops,    */      then do;                         /* then clear it's loop bit   */         Seg.Exists = Seg.Exists & not(2); /* turn of loop bit       */         call write.seg.stack(Seg.Ptr);      end;      if (Seg.Exists&128)<>0         /* if prior cue indicated return to source */      then exists = exists \ 128;    /* then tell this guy to do so too         */      /* Figure out the time/overlap relationship between       */      /* this audio segment and any earlier one:                */      check.case.again:;      if COM32(e, Seg.Sync) <= lw#ieq      /* new cue ends      */      then case = 1;                       /* at or before      */                                           /* old cue starts    */                                           /* = case #1         */      else if COM32(s, Seg.End) >= lw#ieq  /* if new cue starts */      then do;                             /* at or after old   */         case = 5;                         /* cue, assume #5    */         call SUB32(s, Seg.End, x);        /* get gap size      */         if COM16(gap.window, x) >= lw#ieq /* toss tiny gaps    */         then do;                          /* that result from  */            call COPY32(Seg.End, s);       /* roundoff error... */            if  (dtrack# = Seg.Track)      /* if same data trk  */            and (info    = Seg.Info )      /* to same voice...  */            and ((exists&64) = 0)          /* stay away from    */            and ((Seg.Exists&64) = 0)      /* recording!!       */            then do;                       /* of old cue, check */               call SUB32(Seg.End, Seg.Sync, x);               call ADD32(Seg.Disk, x, x);               call SUB32(x, d, x);               if ((x(0) = ( 0)) & (x(1) ILE (+but.window)))               or ((x(0) = (-1)) & (x(1) IGE (-but.window)))               then case = 7;            end;         end;      end;      else do;                             /* must be smarter   */         i=0;                              /* cases #3, #4      */         if COM32(s, Seg.Sync) <= lw#ieq   /* see if new cue    */         then i = 1;                       /* starts <= old cue */                                           /* starts            */                                           /* cases #2, #6      */                                           /* cases #2, #3      */         if COM32(e, Seg.End) >= lw#ieq    /* see if new cue    */         then i = i \ 2;                   /* ends >= end of    */                                           /* old cue           */                                           /* cases #4, #6      */         dcl case.look.#1 data (3,2,4,6);         case = case.look.#1(i);         if case = 4                       /* see if overlap results  */         then do;                          /* from roundoff error     */            call SUB32(Seg.End, s, x);     /* toss tiny overlaps      */            if COM16(gap.window, x) >= lw#ieq            then do;               call COPY32(Seg.End, s);    /* convert from case 4     */               goto check.case.again;      /* to case 5 by sliding.   */            end;         end;      end;      /* now map cases as follows:        */      /* 1 - 7 : no punch over            */      /*         ie truncate prior cues   */      /* 8 -14 : punch over.  new cue     */      /*         has lower priority       */      /* 15-21 : punch over.  new cue     */      /*         has = or higher priority */      /* give absolute priority to        */      /* recording cue                    */      if (Seg.Exists&64)<>0             /* if prior cue was the    */      then do;                          /* recording cue           */         case = case + 7;               /* then give it priority   */      end;                              /* always                  */      else if (exists&64)<>0            /* else if new cue is the  */      then do;                          /* recording cue           */         case = case + 14;              /* then give it priority   */      end;      else if (exists&(2\8192))<>0      /* else if new cue loops   */      then do;                          /* or truncate desired     */      end;                              /* then no punch over      */      else if (exists&32768) <> 0       /* else if starting up     */      then do;                          /* this cue in middle,     */         if COM32(t,Seg.Time) >= lw#ieq /* then look at original   */         then case = case + 14;         /* sequence time.  give    */         else case = case + 7;          /* priority to later cue.  */      end;      else if (Seg.Exists&8)=0          /* else if old cue has no  */      then do;                          /* assigned priority       */         case = case + 14;              /* then assume new cue     */      end;                              /* would have higher       */      else if (exists&8)=0              /* else if new cue has no  */      then do;                          /* assigned priority       */         case = case + 7;               /* but old cue does, then  */      end;                              /* it wins the battle      */      /* else if both cues have assigned priorities, */      /* then compare them to determine who wins     */      else do;         if (exists&"007400")<=(Seg.Exists&"007400")         then case = case + 14;      /* new cue has higher      */         else case = case + 7;       /* old cue has higher      */      end;      dcl action.lookup data (0,     /* case 0 not used          */      toss.old.cue,                  /* case #1, no punch over   */      toss.old.cue,                  /* case #2, no punch over   */      trunc.old.cue,                 /* case #3, no punch over   */      trunc.old.cue,                 /* case #4, no punch over   */      0,                             /* case #5, no punch over   */      toss.old.cue,                  /* case #6, no punch over   */      extend.old.cue\backup.data,    /* case #7, no punch over   */            stack.old.cue,                 /* case #1, lower priority  */      trunc.new.cue+stack.old.cue,   /* case #2, lower priority  */      toss.new.cue,                  /* case #3, lower priority  */      delay.new.cue,                 /* case #4, lower priority  */      0,                             /* case #5, lower priority  */      split.new.cue,                 /* case #6, lower priority  */      extend.old.cue\backup.data,    /* case #7, lower priority  */      stack.old.cue,                 /* case #1, higher priority */      delay.old.cue+stack.old.cue,   /* case #2, higher priority */      split.old.cue,                 /* case #3, higher priority */      trunc.old.cue,                 /* case #4, higher priority */      0,                             /* case #5, higher priority */      toss.old.cue,                  /* case #6, higher priority */      extend.old.cue\backup.data);   /* case #7, higher priority */      action = action \ (action.lookup(case));  /* get action bits      */      /* check action bits */      if (action&split.new.cue) <> 0   /* split new cue into two halves */      then do;                         /* begin by stacking last half   */                                       /* on temp stack (ie must do     */                                       /* this whole process in reverse */                                       /* order).                       */         /* get distance from end of     */         /* old cue back to start of new */         /* cue                          */         call SUB32(Seg.End, S, X);         /* Extract the part of the envelope that matches this */         /* part of the new cue:                               */         call Extract.Envelope.Region(Env, X, Infinity, Tenv, ESegSize);         /* update disk sync point */         /* by amount of cue we    */         /* are chopping off       */         call ADD32(X, D, X);         /* stack split cue on temp stack */         if  (COM32(E, Seg.End) <> lw#ieq) /* detect empty cue. only stack */         and (Seg.Free.Ptr      <> 0     ) /* if storage is available      */         then do;                          /* and cue is non-empty         */            i = Get.Segment.Record;        /* get segment record here      */            call gseg.info(i + Seg.Exists.Loc);            write(mdi) = exists;           /* write out this segment       */            write(mdi) = Seg.End.msb;      /* record to the front of the   */            write(mdi) = Seg.End.lsb;      /* temp stack, sliding any      */            write(mdi) = xmsb;             /* other ones back.   We then   */            write(mdi) = xlsb;             /* append the temp stack to     */            write(mdi) = emsb;             /* the end of the real time     */            write(mdi) = elsb;             /* stack to restore these       */            write(mdi) = info;             /* segments.                    */            write(mdi) = t(0);            write(mdi) = t(1);            write(mdi) = dtrack#;            call Link.In.Segment.Record(Temp.Cue.Head, i); /* link to front*/            call Place.Envelope(Track#, Seg.End, Tenv);         end;         action = (action&(not(split.new.cue)))\trunc.new.cue\stack.old.cue;      end;      if (action&split.old.cue)<>0   /* split old cue into two halves */      then do;                       /* begin by stacking last half   */         /* get distance from end of     */         /* new cue back to start of old */         /* cue                          */         call SUB32(E, Seg.Sync, X);         /* update disk sync point */         /* by amount of cue we    */         /* are chopping off       */         call ADD32(X, Seg.Disk, X);         if  (COM32(Seg.End, E) <> lw#ieq)         and (Seg.Free.Ptr      <> 0     )         then do;            i = Get.Segment.Record;        /* get segment record here      */            call gseg.info(i + Seg.Exists.Loc);            write(mdi) = Seg.Exists & (not(32));            write(mdi) = emsb;            write(mdi) = elsb;            write(mdi) = xmsb;            write(mdi) = xlsb;            write(mdi) = Seg.End.msb;            write(mdi) = Seg.End.lsb;            write(mdi) = Seg.Info;            write(mdi) = Seg.Time(0);            write(mdi) = Seg.Time(1);            write(mdi) = Seg.Track;            call Link.In.Segment.Record(Temp.Cue.Head, i); /* link to front*/            /* note: leave the old envelope information intact */         end;         action = (action&(not(split.old.cue)))\trunc.old.cue;      end;      if (action&trunc.new.cue)<>0      then do;         call COPY32(Seg.Sync, E);  /* truncate end of new cue to stop */                                    /* at start of old cue             */         if COM32(S, E) = lw#ieq    /* if new cue truncated to zippo,  */         then action=0;             /* then we are done with it        */         else do;                   /* else adjust envelope as well    */            action = action & (not(trunc.new.cue));            call SUB32(E, S, X);    /* get truncated length of cue     */            call Extract.Envelope.Region(Env, ZZ, X, Env, ESegSize);         end;      end;      if (action&delay.new.cue)<>0   /* delay start of new cue until */      then do;                       /* after end of old cue         */         call SUB32(Seg.End, S, X);  /* get distance from end of     */                                     /* old cue back to start of new */                                     /* cue                          */                                       call COPY32(Seg.End, S);    /* new sync point for the new   */         call ADD32(D, X, D);        /* update disk sync point */                                     /* by amount of cue we    */                                     /* are chopping off       */                                       if COM32(S, E) = lw#ieq     /* new cue delayed to nothing    */         then action=0;         else do;                    /* else adjust envelope too.     */            action = action & (not(delay.new.cue));            call Extract.Envelope.Region(Env, X, Infinity, Env, ESegSize);         end;      end;      if (action&trunc.old.cue)<>0   /* trunc end of old cue to    */      then do;                       /* start of new cue           */         call COPY32(S, Seg.End);         call write.seg.stack(Seg.Ptr); /* and re-write cue        */         if COM32(Seg.Sync, Seg.End) = lw#ieq /* old cue truncated to nothing */         then action=(action&(not(stack.old.cue)))\toss.old.cue;         action = action & (not(trunc.old.cue));         /* note: leave old envelope info intact for now */      end;      if (action&extend.old.cue)<>0  /* extend end of old cue to   */      then do;                       /* to cover region of new     */         call SUB32(e, s, x);        /* get length of new cue      */         call ADD32(Seg.End, x, Seg.End);         Seg.Exists = Seg.Exists & (not(32)); /* clear expired bit */         call write.seg.stack(Seg.Ptr); /* and re-write cue        */         action=(action&(not(extend.old.cue\stack.new.data)));      end;      if (action&delay.old.cue)<>0   /* delay start of old cue until */      then do;                       /* after end of new cue         */         call SUB32(E, Seg.Sync, X); /* get distance from end of     */                                     /* new cue back to start of old */                                     /* cue                          */         call COPY32(E, Seg.Sync);   /* new sync point for the old   */                                     /* cue                          */         call ADD32(Seg.Disk, X, Seg.Disk);   /* update disk sync point */                                              /* by amount of cue we    */                                              /* are chopping off       */                                                       call write.seg.stack(Seg.Ptr);       /* and re-write cue       */         if COM32(Seg.Sync, Seg.End) = lw#ieq /* old cue truncated to nothing */         then action=(action&(not(stack.old.cue)))\toss.old.cue;         action = action & (not(delay.old.cue));         /* note: leave old envelope info intact for now */      end;      if (action&stack.old.cue)<>0   /* stack old cue          */      then do;                       /* after end of new cue   */         /* stack & toss the old segment by linking it on to   */         /* the temporary que.                                 */         if (Seg.Exists & 32) <> 0   /* clear expired bit      */         then do;                    /* always on temp stack   */            Seg.Exists = Seg.Exists & (not(32));            call write.seg.stack(Seg.Ptr);         end;         i = Seg.Bptr;               /* save back pointer      */         call Unlink.Segment.Record (Seg.Ptr);         call Link.In.Segment.Record(Temp.Cue.Head, Seg.Ptr);         /* if this happens to be the cue we are reading */         /* then back up read pointer as well:           */         call backup.read.and.rt(i);         action = action&(not(stack.old.cue\toss.old.cue));         /* note: envelope information is unaffected since we will be */         /* re-linking this audio back onto the list below.           */         goto next.cue;      end;      if (action&toss.old.cue)<>0    /* toss old cue now */      then do;         i = Seg.Bptr;               /* save back pointer               */         call Unlink.Segment.Record (Seg.Ptr);         call Release.Segment.Record(Seg.Ptr);         /* if this happens to be the cue we are reading */         /* then back up read pointer as well            */         call backup.read.and.rt(i);         action = action & (not(toss.old.cue));         /* also leave the envelope unaffected for now   */         goto next.cue;      end;   end;   /* check for stack of source material in front of */   /* cue trigger to try to handle mode switch       */   if  ((action&stack.src.cue) <> 0     )  /* stack source cue first  - but */   and (COM32(S, Song.Data.S#) <> lw#ieq)  /* only if it represents a       */   and (Seg.Free.Ptr           <> 0     )  /* nonzero amount of time        */   then do;      i = Get.Segment.Record;              /* get a free record             */      Seg.Fptr     = 0;      Seg.Bptr     = 0;      Seg.Exists   = 128\1;                /* for source material           */      call COPY32(Song.Data.S#, Seg.Sync); /* set up info to match          */      call COPY32(Song.Data.S#, Seg.Disk); /* variables for normal PLAY     */      call COPY32(S,            Seg.End );      Seg.Info     = 0;                    /* no syncl track # of interest  */      call COPY32(Song.Data.S#, Seg.Time);      Seg.Track    = track#;               /* use track# for repro          */      call write.seg.stack(i);             /* and re-write cue              */      call Link.In.Segment.Record(Seg.Ptr, i);      Seg.Ptr = i;                         /* now we are last               */      call set.read.and.rt(Seg.Ptr);      /* construct default envelope for repro section:                      */      Tenv(0) = 1 + ESegStride + 1;      Tenv(1 + ESegSval) = 4095;      call SUB32(Seg.End, Seg.Sync, loc(addr(Tenv(1 + ESegLen))));      Tenv(1 + ESegDval) = 4095;      call Place.Envelope(Track#, Seg.Sync, Tenv);   end;   /* now store new cue on stack */   if ((action&toss.new.cue )= 0)   then do;      if  ((action&stack.new.data)<>0)      and (Seg.Free.Ptr           <>0)      then do;         i = Get.Segment.Record;         Seg.Fptr     = 0;         Seg.Bptr     = 0;         Seg.Exists   = exists;         call COPY32(s, Seg.Sync);         call COPY32(d, Seg.Disk);         call COPY32(e, Seg.End );         Seg.Info     = info;         call COPY32(t, Seg.Time);         Seg.Track    = dtrack#;         call write.seg.stack(i);    /* and re-write cue           */         call Link.In.Segment.Record(Seg.Ptr, i);         Seg.Ptr = i;                /* now we are last            */         call set.read.and.rt(Seg.Ptr);         /* note: we are often storing back in sync.msb exactly what was there */         /* when triggering,  however, will be current immediate trigger time  */         /* save rounded disk time as well */         /* for setting sync point         */         /* save rounded end time          */         if (exists&64)<>0 then do;  /* will be recording here     */            call COPY32(S, RecRec.Sync);            call COPY32(D, RecRec.In  );            call COPY32(E, RecRec.Send);            recrec(recrec.stacked ) = 1;     /* is done for each track?    */            record.cue.ptr(track#)  = Seg.Ptr;         end;      end;      if  ((action&stack.new.env)<>0)      then call Place.Envelope(Track#, S, Env);   end;   /* now re-stack any cues or pieces of cues that should */   /* be played after the punch-over.  Do this by moving  */   /* the entire temp cue in one stroke.                  */   write(mam) = cseg.xmsec#;        /* look up  starting pointer  */   write(mal) = Temp.Cue.Head;      /* to see if list is empty    */   if read(md) <> Temp.Cue.Head     /* if temp list is non-empty  */   then do;                         /* then move entire cue       */      Seg.Fptr   = read(md);        /* get pointer to first block */      write(mdi) = Temp.Cue.Head;   /* on temp que.  reset.       */      Seg.Bptr   = read(md);        /* and get pointer to last    */      write(mdi) = Temp.Cue.Head;   /* block,  and reset it       */      i = gseg.info(Seg.Ptr);       /* set new forward pointer in */      write(md)  = Seg.Fptr;        /* prior block                */      call gseg.info(Seg.Bptr);     /* set new forward pointer in */      write(md)  = i;               /* last block of temp cue     */      call gseg.info(Seg.Fptr+1);   /* set new back pointer in    */      write(md)  = Seg.Ptr;         /* first block of temp cue    */      call gseg.info(i+1);          /* set new back pointer in    */      write(md)  = Seg.Bptr;        /* block after us             */      call set.read.and.rt(Seg.Fptr);  /* this may be first on    */   end;                                /* list now.               */   /* truncate play buffers to start of this cue */   /* in case we are playing (we may have        */   /* buffered too far ahead)                    */      dcl (b)    (1)    fixed;   dcl (bmsb) lit    'b(0)';   dcl (blsb) lit    'b(1)';   dcl (b1len,b2len) fixed;   dcl (port#)       fixed;   give.priority.to.this.track:proc;      port.toggle(port#) = track# & (tracks.per.port-1);   end;   if  ((action&backup.data) <> 0     )   /* if extending a cue, then  */   and (COM16(0, S)          <> lw#ieq)   /* backup up by extra sector */   then call SUB16(256, S);               /* in case we had already    */                                          /* constructed then fadeout  */   track.eof(track# ) = 0;            /* in case we had reached eof    */   b1len = 0;   b2len = 0;   port# = track.port.ix(track#);     /* get corresponding port# */   if  ((port.io      (port#)=2)      /* if read is outstanding */   or   (port.io      (port#)=4))   and (port.io.track#(port#)=track#) /* for this track         */   and (port.update   (port#)=1)      /* play data read         */   then do;      if port.io.buf#(port#)=1 then b1len=port.io.len#(port#);      else                          b2len=port.io.len#(port#);   end;   bmsb  = buf1.msb(track#);        /* get buffer contents     */   blsb  = buf1.lsb(track#);   if (buf1.len(track#)+b1len)<>0   /* check buffer 1 contents */   and (zap.buffer(track#)=0)       /* but only check if not zapping anyways */   then do;                         /* if any there or on way  */      if COM32(B, S) >= lw#ieq      /* if buffer starts at     */      then do;                      /* or after new cue start  */                                    /* then we are in big t    */         buf1.len(track#)=0;         if b1len<>0 then port.update(port#)=0;  /* toss command when through */         buf2.len(track#)=0;                     /* nothing in buf2 either */         if b2len<>0 then port.update(port#)=0;  /* toss command when through */         b2len=0;                                /* check no further for buf2 */         call give.priority.to.this.track;       /* issue next read for this track */      end;      else do;                      /* buffer 1 contains data and starts before sync point */         call COPY32(b,x);          /* get sample # at end of current buffer */         call ADD16(shl(buf1.len(track#),8),x);         if COM32(X, S) = lw#igt    /* see if ending sample # is */         then do;                   /* after our starting sample */                                          buf1.len(track#)=shr(s(1)-blsb,8);      /* get sectors in buffer up to where cue starts */            if b1len<>0 then port.update(port#)=0;  /* toss data when through with command */            buf2.len(track#)=0;                     /* nothing in buf2 either */            if b2len<>0 then port.update(port#)=0;  /* toss command when through */            b2len=0;                                /* check no further for buf2 */            call give.priority.to.this.track;       /* issue next read for this track */         end;         else if b1len<>0 then do;        /* current buffer is ok - check for outstanding operation */            call COPY32(x, y);            /* and at end of current op */            call ADD16(shl(b1len,8),y);            if COM32(y, s) = lw#igt    /* see if ending sample # is */            then do;                   /* after our starting sample */               b1len = shr(s(1)-xlsb,8); /* truncate op */               if b1len=0 then port.update(port#)=0;               else port.io.len#(port#)=b1len;               call give.priority.to.this.track;       /* issue next read for this track */            end;         end;      end;   end;   bmsb  = buf2.msb(track#);  /* get buffer contents */   blsb  = buf2.lsb(track#);   if (buf2.len(track#)+b2len)<>0   /* check buffer 2 contents */   and (zap.buffer(track#)=0)       /* but only check if not zapping anyways */   then do;                         /* if any there or on way  */      if COM32(B, S) >= lw#ieq      /* if buffer starts at     */      then do;                      /* or after new cue start  */                                    /* then we are in big t    */         buf2.len(track#)=0;         if b2len<>0 then port.update(port#)=0;  /* toss command when through */         call give.priority.to.this.track;       /* issue next read for this track */      end;      else do;         call COPY32(b, x);            /* get sample # at end of current buffer */         call ADD16(shl(buf2.len(track#),8),x);         if COM32(X, S) = lw#igt       /* see if ending sample # is */         then do;                      /* after our starting sample */                                          buf2.len(track#)=shr(s(1)-blsb,8); /* get sectors in buffer up to where cue starts */            if b2len<>0 then port.update(port#)=0;  /* toss command when through */            call give.priority.to.this.track;       /* issue next read for this track */         end;         else if b2len<>0 then do;      /* keep all of buffer and part of io */            call COPY32(x, y);            /* get sample # at end of current op */            call ADD16(shl(b2len,8),y);            if COM32(Y, S) = lw#igt    /* see if ending sample # is */            then do;                   /* see if ending sample # is */               b2len = shr(s(1)-xlsb,8); /* truncate op */               if b2len=0 then port.update(port#)=0;               else port.io.len#(port#)=b2len;               call give.priority.to.this.track;  /* issue next read for this track */            end;         end;      end;   end;   buf3.len(track#) = 0;    /* glom buf3 always in case scrubbing */end stack.cue;/* $page - convenient routines to stack armed cues */dcl (armd.tracks)          fixed PUBLIC;dcl (new.armd.tracks)      fixed PUBLIC;stack.armed.cue:proc(trkbits) PUBLIC;     /* stack armed cue */   dcl trkbits      fixed;   dcl i            fixed;   dcl (a,b,c,zz)   (1)    fixed;   dcl amsb    lit  'a(0)';   dcl alsb    lit  'a(1)';   dcl bmsb    lit  'b(0)';   dcl blsb    lit  'b(1)';   dcl cmsb    lit  'c(0)';   dcl clsb    lit  'c(1)';   /* if rehearsing,  put cue on stack that plays entire source */   /* so that audition is performed                             */   if recrec(recrec.rehearse)<>0 then do;   /* rehearsing */      /* get smaller for sync time, in time */      call COPY32(RecRec.Sync, A);          /* get sync time */      call ROUND32(A);      call COPY32(RecRec.In, B);            /* get disk time */      call ROUND32(B);      call COPY32(A, C);                    /* get smaller of the two */      if COM32(B, C) = lw#ilt      then call COPY32(B, C);      call SUB32(A, C, A);                  /* reset one of them */      call SUB32(B, C, B);                  /* to 0.000          */      call ADD32(A, Data.S#, A);            /* but start at      */      call ADD32(B, Data.S#, B);            /* data sec#         */   end;   /* use punch-over facility to place recording area           */   /* over source                                               */   do i=0 to max.tracks-1;              if  ((trkbits&bits(i)) <>0 )     /* cue on this trk      */      then do;         /* if rehearsing and not in cue plaback,  then stack  */         /* a source equivalent cue to hear the repro audio    */         /* during the rehearse period:                        */         if  (recrec(recrec.rehearse)<>0)         and (shr(track.dir(i*track.len+track.stat),8) <> 3)         then do;            call Stack.Cue(i,1,A,B,Song.End.S#,0,A,ZZ,i);         end;         call stack.cue(i,1\64,        /* trk,   bits  */           RecRec.Sync,                  /* sync   time  */         RecRec.In,                    /* disk   time  */         RecRec.Out, 0,                /* end    time  */         RecRec.Sync,ZZ,i);            /* voice  time  */      end;   end;   new.armd.tracks = 0;   /* no more tracks to stack, since we got them all */end stack.armed.cue;stack.armed.cue.if.needed:proc PUBLIC;     /* check for stack of armed cue */   if  (armed               <> 0)          /* armed                  */   and (recrec(recrec.code) <> 0)          /* synced recording       */   then do;                                /* stack cue to prepared  */      /* if cue is not stacked, then */      /* stack it now                */      if (recrec(recrec.stacked) = 0)            then call stack.armed.cue(armd.tracks);      /* if cue is stacked and there */      /* are some new ready tracks,  */      /* stack cues for them         */      else if (armd.tracks&new.armd.tracks) <> 0      then call stack.armed.cue(armd.tracks&new.armd.tracks);   end;end stack.armed.cue.if.needed;