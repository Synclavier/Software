/* lod1-19 - erase track, load song *//* 01/04/92 - cj - broke up load.song to make room     *//* 03/11/91 - cj - made skip backwards not prompt for  *//*                 additional cartridges that don't    *//*                 exist!!.  Also more info printed    *//*                 out for show proj info              *//* 02/09/91 - cj - added tape skipf, skipb & show      *//* 08/20/90 - cj - added code for 4 wangs/4 pats       *//* 03/05/90 - cj - fixed siemens/wangdat mode select bug *//* 02/20/90 - cj - fixed changing tapes/skip bug *//* 01/16/90 - cj - added tandberg code           *//* 06/02/89 - cj - added exabyte code            *//* LOD1-20   $TITLE  More Code for Load Project   Modified:   12/02/91 - cj - fixed "DTD timeout with lots of cues" bug (spr #1)   06/21/91 - cj - improved tracking of song modified during load   02/09/91 - cj - added tape skipf, skipb & show   08/20/90 - cj  - added code for 4 wangs/4 pats   02/12/90 - cj  - used verify literals to construct header   08/22/89 - MWH - Be sure cues are written to disk if they change   02/09/89 - cj  - fixed 'muted track load/backup bug'*/erase.track:proc(track#);   dcl (track#) fixed;   if alt.tdir.valid=0                  /* wait for valid alternate tdir  */   then return;   call erase.track.info(track#);   call finish.command  (track#);end erase.track;/* $page - find possible end time */find.possible.end.time:proc;   dcl (i,j,k,l,m,n,x) fixed;   k=s.start;   l=s.end;   if (k\l)=0   then return;              /* 0,0? */   do j=0 to num.songs-1;      if j<>command.song then do;         m=gsong.dir(j*song.len+song.start);         n=gsong.dir(j*song.len+song.end  );         if (m\n)<>0 then do;   /* compare                                 */            if n ilt m then do; /* again,  out of order???                 */               x=m; m=n; n=x;            end;            if      ((m ige k)&(m ilt l))  /* song 2 starts in middle of song 1 */            then l=m;            else if ((l igt m)&(l ilt n))  /* song 1 ends   in middle of song 2 */            then l=k;         end;      end;   end;   if l ilt s.start   then l=s.start;   return l;end find.possible.end.time;/* $page - load song or track from tape on to disk */dcl deadtapes         fixed;dcl notloadedtapes    fixed;dcl dirloaded         fixed;dcl eotreached        fixed;dcl updatetime        fixed;dcl songread          fixed;dcl trackswap         fixed;dcl tape.verify.error fixed;dcl verify.included (max.ports)  fixed;dcl verified.len    (max.ports)  fixed;dcl skipped.song    (12       )  fixed;dcl skipped.rate                 fixed;dcl skipped.used                 fixed;dcl load.song proc(fixed,fixed) external;dcl load.begin.real.interrogation.state  fixed;dcl load.process.next.chunk.state        fixed;dcl load.abort.state                     fixed;begin;               /* define variables local to "load.song" */   dcl (tport#      ) fixed;   dcl (dport#      ) fixed;   dcl (i,j,k,l,m,n ) fixed;   dcl (newlength   ) fixed;   dcl (thistrack   ) fixed;   dcl (mwrd#       ) fixed;   dcl (clen        ) fixed;   dcl (ptr         ) fixed;   dcl (len         ) fixed;   dcl (a,b,c)    (1) fixed;   dcl (tbits       ) fixed;   dcl (numerrs)      fixed;   dcl (headerok    ) fixed;/* Subroutine to examine header block: */examine.load.song.header:proc(port#, track#) swap;   dcl (port#, track#) fixed;   do i = 0 to max.tracks-1;                    /* assume all data  */      port.dest.list (port#*max.tracks+i) = 0;  /* will be tossed   */      port.track.list(port#*max.tracks+i) = 0;   end;   j=compute.base.adr(track#);   call psmread(j+buf.base,0);   do i=0 to 255;                     /* get first sector            */      misc.buf(i)=read(psd);   end;   if  ( misc.buf(0) <> 9999 )        /* tape is not at song header */   or  ( misc.buf(1) <> 8888 )   or  ( misc.buf(2) <> 7777 )   or  ((misc.buf(3) <> 6666)         /* check for original format  */   and  (misc.buf(3) <> 5555))        /* or tape with verify info   */   then do;      if  xdebug <> 0                 /* if this is debug version   */      then do;                        /* then fabricate info        */         headerok = false;         print 'Fabricating Header',port#;      end;      else do;                        /* else must give up          */         call log.error('Data Format Error with Backup ');         call append.tape.mes(port#);         call finish.port.command(port#);         command.fatal=1;         return ;      end;   end;   else headerok = true;             /* else header is ok           */   if headerok then do;              /* get info from tape          */      /* Get list of which source tracks were originally written    */      /* to tape.  This will allow us to intelligently map them     */      /* to our destination tracks:                                 */      do i = 0 to max.tracks-1;         port.track.list(port#*max.tracks+i) = misc.buf(100+i);      end;      verify.included (port#) = misc.buf(200); /* look up to see if   */      verified.len    (port#) = misc.buf(201); /* verify blocks there */   end;   else if xdebug then do;             /* fabricate info */      do i = 0 to max.tracks-1;         port.track.list(port#*max.tracks+i) = 0;      end;      i = 0;      do j = 0 to max.tracks-1;         if (command.tracks & bits(j) & port.track.bits(port#))<>0         then do;            port.track.list(port#*max.tracks+i)=256 + j;            i = i + 1;         end;      end;      if include.verify then do;         verify.included (port#) = get.stream.size(port#);         verified.len    (port#) = verify.len;      end;      else do;         verify.included (port#) = 0;         verified.len    (port#) = 0;      end;      call gsong.dir(command.song*song.len); /* get current song */      do i=0 to song.len-1;                  /* information      */         misc.buf(10+i)=read(mdi);      end;   end;   if fastboot then do;      if verify.included (port#) <> 0      then print 'Verify Size: ', verify.included(port#), verified.len(port#);   end;   /* Keep track of the size of the buffer that is in use.   */   /* This information is used to turn off inputs (ie STM's) */   /* when we need both the input and output buffers for     */   /* reading long tapes.  This happens when we are          */   /* reading on to a MAXTRAX system a tape (with verify)    */   /* that was written on NON-MAXTRAX config.                */   if verify.included(port#) > buf.size.in.use  /* find first       */   then do;                                     /* occurrence of    */      buf.size.in.use = verify.included(port#); /* buffer use that  */      new.inputs      = 1;                      /* is > buf.len     */   end;   if  (command.#=c.verf    )         /* for verify/skip/show		  */   or  (command.#=c.verfall )         /* just display info			  */   or  (command.#=c.skipf   )   or  (command.#=c.show    )   or  (command.#=c.skipfall)   then do;      if dirloaded=0                 /* show only one message      */      then do;         s.title     (0) = 24;          /* extract title of this      */         skipped.song(0) = 24;          /* song we are skipping       */         do j=0 to 11;            s.title     (j+1) = misc.buf(10+song.title+j);            skipped.song(j+1) = misc.buf(10+song.title+j);         end;         skipped.rate    = misc.buf(10+song.rate );         skipped.used    = misc.buf(10+song.used );         if (command.# = c.show)       /* present message here       */         then call log.error('Fetching Project Information...');         else do;            if (command.#=c.skipf   )            or (command.#=c.skipfall)            then call log.error('Skipping Over Project "');            else call log.error('Verifying Project "');            call append.song.name;            call append.log.string('"');         end;         dirloaded = 256+track#;      end;      tape.skip       (port#)=1;      emptybits = (-1);              /* do not require other tapes */                                     /* to be put in for skips     */   end;   /* not a skip/verify: must be load/add of song or load of track */   else do;      if  (command.#=c.lsong)       /* if song load happening       */      or  (command.#=c.lall )       /* or load all                  */      or  (command.#=c.asong)       /* or add to song               */      or  (command.#=c.aall )       /* or add to all songs          */      then do;         s.title(0)=24;             /* extract title of this        */         do j=0 to 11;              /* song                         */            s.title(j+1)=misc.buf(10+song.title+j);         end;         /* Print message & errase tracks when getting first        */         /* song header.                                            */         if dirloaded=0         then do;      /* Erase tracks here and get new song directory unless  */      /* we are adding to the song:                           */            if  (command.#=c.lsong)      /* if song load happening  */            or  (command.#=c.lall )      /* or load all             */            then do;               call log.error('Loading Project "');               call append.song.name;               call append.log.string('"');               do i=0 to max.tracks-1;        /* erase all tracks now      */                  if ((track.avail.bits&bits(i))<>0)                  then call erase.track.info(i);               end;               if headerok then do;               /* get tdir from tape if info is there */                  j=compute.base.adr(track#);     /* else leave command.# alt.tdir untouched */                  call psmread(j+buf.base+1,0);                  do i=0 to 255;                  /* initialize tdir entries    */                     alt.tdir(i)=read(psd);       /* in hopes that all tracks   */                  end;                            /* came from this song        */               end;               call Clean.Up.Track.Directory(Alt.Tdir);               do i=0 to max.tracks-1;                /* but let used be set    */                  alt.tdir(i*track.len+track.used)=0; /* as data is written     */               end;               alt.tdir.updated=1;               if (song.base+dtd.song#) = command.song  /* update entire track directory for anxious user */               then do;                  call blockmove(alt.tdir,track.dir,max.tracks*track.len);                  call Precompute.Volume.Information;                  call mark.stars;               end;            end;            /* Else present adding message: */            else do;               call log.error('Adding to Project "');               call append.song.name;               call append.log.string('"');            end;         end;         if  (dirloaded=0)                 /* load first one               */         or  ((256+track#)<dirloaded)      /* but give priority to track 0 */         then do;                          /* get song info                */            if headerok then do;               j=compute.base.adr(track#);               call psmread(j+buf.base,0);               do i=0 to 255;                 /* re-read misc.buf glommed  */                  misc.buf(i)=read(psd);      /* by erase track info above */               end;            end;            else do;               call gsong.dir(command.song*song.len); /* get current song */               do i=0 to song.len-1;                  /* information      */                  misc.buf(10+i)=read(mdi);               end;            end;            s.start   =misc.buf(10+song.start);            s.end     =misc.buf(10+song.end  );            s.rate    =misc.buf(10+song.rate );            s.used    =misc.buf(10+song.used );            s.fade    =misc.buf(10+song.fade );            if (command.#=c.lall)            or (command.#=c.aall)              /* load all - reserve */            then do;                           /* space the user     */               if s.end ige s.start            /* did before         */               then newlength=s.end-s.start;               else newlength=0;            end;            else newlength=s.used;             /* load song - just   */                                               /* the needed amount  */            i=command.song*song.len;            call gsong.dir(i+song.title);            do j=0 to 11;           /* store in directory          */               write(mdi)=s.title(j+1);            end;            call gsong.dir(i+song.rate);  /* assign new proj rate  */            write(mdi)  =  s.rate;        /* to this project       */            /* Set song used to zero in case of load song/all:     */            if  (command.#=c.lsong)       /* if song load happening       */            or  (command.#=c.lall )       /* or load all                  */            then do;               if dirloaded = 0 then do;  /* only first time, tho         */                  call gsong.dir(i+song.used);                  write(mdi)  =  0;                 /* let write code fill out used */               end;            end;            call gsong.dir(i+song.modified);        /* song.modified, song.fade */            write(md)   =  1;                       /* set modified now;  clear if load is all successful */            call gsong.dir(i+song.fade    );        /* store new crossfade setting */            write(md)   =  s.fade;            command.song.dir.updated =1;            send.screen.info         =1;             /* now figure out which tracks are empty */            /* to  optimize loading                  */            /* if no header,  then assume all tracks */            /* might have data                       */            emptybits=0;            if headerok then do;               j=compute.base.adr(track#);               call psmread(j+buf.base+1,0);               do i=0 to 255;                /* get tdir entries for */                  misc.buf(i)=read(psd);     /* these tracks         */               end;               do j=0 to max.tracks-1;                  if  ((command.tracks&bits(j))<>0)        /* track affected       */                  and (misc.buf(j*track.len+track.used)=0) /* but is empty in song on tape */                  then emptybits=emptybits\bits(j);               end;               dirloaded = 256+track#;            end;            /* else if we did not get a header from this track,  allow */            /* a header from any other track to be read in.            */            /* must set dirloaded <> 0 to avoid erasing the project    */            /* twice!                                                  */            else dirloaded = 256+max.tracks;         end;      end;      else do;        /* must be track load */         /* for now,  we only get here if command.tracks has */         /* exactly one bit set.  code is (sort of) written  */         /* to handle case when multple track loads are      */         /* combined at the same time.                       */         if  (dirloaded=0)  /* had better be! */         then do;            if log.buf(0)=0 then do;               call log.error('Loading to Track ');               call append.decimal.number(track#+1);            end;            dirloaded = 256+track#;         end;         /* Erase whatever tracks are going to be loaded */         /* from this tape:                              */         do i = 0 to max.tracks-1;            if (command.tracks & bits(i) & port.track.bits(port#)) <> 0            then do;               call erase.track.info(i);               do k=0 to 7;                      /* set name to all spaces */                  alt.tdir(i*track.len+track.title+k)=32\shl(32,8);               end;               alt.tdir(i*track.len+track.used)=0;            end;         end;         alt.tdir.updated=1;         newlength=0;      end;      /* Look at how many tracks were written to this record on tape. */      /* See how many tracks are being loaded,  and what our current  */      /* configuration is.   Make some intelligent choices.           */      /* begin by finding out how many tracks were written to         */      /* tape,  how many tracks are being loaded,  and whether        */      /* some adjacent tracks (on the next port) are being loaded     */      /* that in fact may wish to be loaded from this tape.           */      i = 0; j = 0;      do l = 0 to max.tracks-1;         if port.track.list(port#*max.tracks+l) <> 0         then i = i + 1;   /* count # of tracks written to tape       */         if (command.tracks & bits(l) & port.track.bits(port#)) <> 0         then j = j + 1;   /* count # of tracks loaded to this port   */      end;      if i <> j            /* don't prompt user for more carts        */      then trackswap = 1;  /* if he is changing configurations        */      /* Now perform some smart logic based on the relationship.    */      /* If the number on tape matches the number we are loading,   */      /* then it is easy: perform a 1:1 mapping.  Handles all       */      /* track bounces (1 on tape:1 on disk),  plus reloads to      */      /* same config as system writing the tape.                    */      /* Note: tricky code is used here in case some tracks are     */      /* not working now,  or were not working when data was        */      /* written out.                                               *//*1*/ if (i = j) then do;         l = 0;         do m = 0 to max.tracks-1;            if (command.tracks & bits(m) & port.track.bits(port#)) <> 0            then do;               port.dest.list(port#*max.tracks+l) = 256 + m;               l = l + 1;            end;         end;      end;      /* Else if using the aux tape,  look on the AUX tape for tracks */      /* that match the ones we are trying to load.                   *//*2*/ else if port# = max.ports then do;         do l = 0 to max.tracks-1;         /* look for each track being loaded */            if (command.tracks & bits(l) & port.track.bits(port#)) <> 0            then do m = 0 to max.tracks-1;      /* for each track on tape           */               if   port.track.list(port#*max.tracks+m) = (256+l)               then port.dest.list (port#*max.tracks+m) = (256+l);            end;         end;      end;      /* Else if using a port tape that was written using the same   */      /* drive configuration that is in use (maxtrax/normal), then   */      /* get corresponding relative tracks:                          *//*3*/ else if (i = tracks.per.port)       /* if same config          */      or      ((i=3)&(tracks.per.port=4)) /* or special case: tape was written with one bad track from max trax */      then do;                            /* and is now being loaded onto a good maxtrax system.                */         /* note: most likely a track load from project tapes        */         l = port.base.track(port#);         do m = 0 to (tracks.per.port-1);            if  ((command.tracks & bits(l+m)) <> 0)            and (m<i)   /* double check in case i=3 */            then do;               port.dest.list(port#*max.tracks+m) = 256 + l + m;            end;         end;      end;      /* Now for some special cases:                             */      /*    loading 1 track tape on to max trax                  */      /*    loading 1 track tape on to normal trax               */      /*    note: could be track load, or project add            *//*4*/ else if (i = 1) then do;   /* one track on tape: use first track */         /* see if corresponding track is being loaded: */         l = port.track.list(port#*max.tracks) & 255;  /* get source track */         if (command.tracks & port.track.bits(port#) & bits(l)) <> 0         then port.dest.list(port#*max.tracks) = 256 + l;         /* if matching track is not being loaded,  look for     */         /* same one modulo tracks.per.port:                     */         else do;            m = port.base.track(port#) + (l & (tracks.per.port-1));            if  ((command.tracks & bits(m)) <> 0)            then port.dest.list(port#*max.tracks) = 256 + m;            /* else just load this track.  Happens with track bouncing: */            else port.dest.list(port#*max.tracks) = 256 + track#;         end;      end;      /* More special cases:                                     */      /*    loading 2 track tape on to max trax                  *//*5*/ else if (i=2)&(tracks.per.port=4)      then do;         l = port.base.track(port#);   /* get base track handy   */         /* Detect special case where we are using add tracks.   */         /* Load tracks 2,3 from 2-track tape on to tracks 2,3   */         /* of the max trax system.  User will probably (or has  */         /* already) loaded tracks 0,1 from other tape.         */         if  (j=4)     /* if all 4 tracks being loaded.          */         and (port.track.list(port#*max.tracks  )=(256 + l + 2))         and (port.track.list(port#*max.tracks+1)=(256 + l + 3))         then do;            port.dest.list(port#*max.tracks  ) = 256 + l + 2;            port.dest.list(port#*max.tracks+1) = 256 + l + 3;         end;         /* Else load into which ever tracks are armed using    */         /* 0101 mapping.                                       */         else do m = 3 to 0 by (-1);            if (command.tracks & bits(l+m)) <> 0            then port.dest.list(port#*max.tracks+(m&1)) = 256 + l + m;         end;      end;      /* More special cases:                                     */      /*    loading 4   track tape on to normal trax             */      /*    loading aux       tape on to nromal trax             */      /*    loading aux       tape on to max    trax             *//*6*/ else if i > tracks.per.port then do;         /* Set up destinations that may be on other ports to     */         /* simplify transfer of aux tape on to port tape system  */         /* Begin by computing modulo mask based on how many      */         /* tracks were written to tape.  Is easy if no tracks    */         /* are broken (i=4, i=8, i=16).  Make a good guess       */         /* if other number is in use.                            */         if      i<=4 then n=4;   /* most likely a max track tape */         else if i<=8 then n=8;   /* aux tape from 8-trk DTD      */         else              n=16;  /* aux tape from 16-trk DTD     */         l = port.base.track(port#) & (not(n-1)); /* get base       */         do m = 0 to i-1;              /* for each track on tape  */            if  ((l+m)<max.tracks)     /* if track # in range     */            and ((command.tracks & bits(l+m)) <> 0) /* being read */            then do;               /* if track is on this port,  then go ahead and    */               /* load it.                                        */               if (port.track.bits(port#) & bits(l+m))<>0               then port.dest.list(port#*max.tracks+m) = 256 + l + m;               /* else only load if if there is no cartridge      */               /* in that port.                                   */               else do;                  if (tape.condition(track.port.ix(l+m)) & (t1.cond.rdy\t2.cond.rdy)) = 0                  then do;                     port.dest.list(port#*max.tracks+m) = 256 + l + m;                     bouncedbits = bouncedbits \ bits(l+m);                     /* special logic here: skip the verify */                     /* if manually bouncing data from      */                     /* more than 1 tape at once.  Other    */                     /* wise the WANGDATS cannot stream     */                     /* and it takes FOREVER to load 2      */                     /* maxtrax tapes on to an 8-track DTD  */                     if port# <> 0                     then skipverify = 1;                  end;               end;            end;         end;      end;      /* Erase the destination track here in case of an       */      /* add-to-song or add-to-all.                           */      if  (command.#=c.asong)      /* if adding to song ...   */      or  (command.#=c.aall )      then do;         do i = 0 to max.tracks-1;     /* loop over all possible */                                       /* tracks on tape.        */            j = port.dest.list(port#*max.tracks+i);            if j <> 0 then do;         /* track is being loaded  */               j = j & 255;               call erase.track.info(j);               alt.tdir(j*track.len+track.used)=0;               alt.tdir.updated=1;            end;         end;         if (song.base+dtd.song#)=command.song  /* update entire track directory for anxious user */         then do;            call blockmove(alt.tdir,track.dir,max.tracks*track.len);            call Precompute.Volume.Information;            call mark.stars;         end;      end;      /* make sure new song is long enough.  See which tracks we */      /* will be loading.  Get length of longest track we are    */      /* actually loading.  Make sure song length accommodates   */      /* that length.                                            */      j=compute.base.adr(track#);      call psmread(j+buf.base+1,0);            do i=0 to 255;                     /* get tdir entries for */         if headerok         then misc.buf(i)=read(psd);     /* these tracks         */         else misc.buf(i)=alt.tdir(i);      end;      do i = 0 to max.tracks-1;          /* loop over all possible */                                         /* tracks on tape.       */         j = port.dest.list(port#*max.tracks+i);         if j <> 0 then do;                    /* if track being read */                                               /* in,  then get       */            j = port.track.list(port#*max.tracks+i) & 255;/* original track #    */            k = misc.buf(j*track.len+track.used);            if k igt newlength then newlength = k;         end;      end;      /* look up current start and end time for this song */      s.start = gsong.dir(command.song*song.len+song.start);      s.end   = gsong.dir(command.song*song.len+song.end  );      if   s.end ilt s.start      then s.end  =  s.start;      if (s.start=0)&(s.end=0) then do;      /* no times specified - get one */         j=command.song-1;         do while j>=0;            k=gsong.dir(j*song.len+song.end); /* find last end time */            if k<>0 then do;               s.start=k;               s.end  =k;               j=0;            end;            j=j-1;         end;      end;      if (s.start+newlength) igt (s.end)      then do;                               /* make song longer */         s.end=s.start+newlength;            /* get new length   */         j=find.possible.end.time;           /* but shorten it   */         if  (s.end <> j)                    /* overlap probs    */         or  (s.end igt dtd.max.secs)        /* or off disk      */         then do;            log.buf(0)=0;   /* give this message instead!! */            call log.error('Not Enough Room on Disk');            command.fatal =1;            tape.skip(port#)=1;         end;         else do;                            /* was ok           */            call gsong.dir(command.song*song.len+song.start);            write(mdi)=s.start;            write(mdi)=s.end;            call compute.bounds(C.Data, C.Len);            call compute.c.info;            command.song.dir.updated=1;            send.screen.info=1;          end;      end;      /* get info from track directory for each track we are */      /* about to load.                                      */      do i = 0 to max.tracks-1;          /* loop over all possible */                                         /* tracks on tape.       */         j = port.dest.list(port#*max.tracks+i);         if j <> 0 then do;                     /* if track being     */                                                /* read in,  then get */            k = port.track.list(port#*max.tracks+i) & 255;/* original track #    */            j = j & 255;                        /* dest track#        */            if k <> j                           /* set flag if we are */            then trackswap = 1;                 /* bouncing for later */            /* Copy name of this track into alt tdir.   Leave other */            /* information (input routing,  output routing, etc)    */            /* the same.   This works the best for both load        */            /* project and load track                               */            do l=0 to 7;               alt.tdir(j*track.len+l) = misc.buf(k*track.len+l);            end;            alt.tdir(j*track.len+track.used)=0;  /* but not used yet - let write routine fill this out */            alt.tdir.updated=1;            if (song.base+dtd.song#)=command.song     /* update track dir info for this track for anxious user */            then do;               call blockmove(location(addr(alt.tdir (j*track.len))),                              location(addr(track.dir(j*track.len))),                              8);  /* get title only */               track.dir(j*track.len+track.used)=0;  /* and set used to 0 */            end;         end;      end;   end;   /* Look up new info for current song if we are loading */   /* right now and user wants to listen to it. Basically */   /* get the new sampling rate & start & end time        */   /* set up correctly now.                               */   if (song.base+dtd.song#) = command.song  /* update entire track directory for anxious user */   then new.dtd.song# = 1;   port.retry  (port# )=0;   /* if the header was fabricated, leave poly.buffs.in.use as is, */   /* set nextstate to our state + 1, then skip the issue of the   */   /* tape command since the next block is already in memory.      */   /* Of course, we do not do that if skipf'ing or showing since   */   /* we don't need the next block in those cases anyways          */   if (headerok=0)&(command.#<>c.skipf)&(command.#<>c.show)&(command.#<>c.skipfall) then do;      load.process.next.chunk.state  = tape.state(port#) + 7;      load.abort.state               = tape.state(port#) + 2;      tape.state(port#)              = tape.state(port#) + 9;   end;   else do;      poly.buffs.in.use        = poly.buffs.in.use       - 1;      this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;      tape.state      (port# ) = tape.state     (port# ) + 1;   end;end examine.load.song.header;load.cue.defs.from.song:proc(port#, track#) swap;   dcl (port#, track#) fixed;   /* load cue definitions from tape */   /* to disk for this song          */   if block.skip (port#)=0           /* if actually reading data    */   then do;                          /* then read cue defs as well  */      i = port.cue.ix(port#);        /* pick up where we left off   */      j = compute.base.adr(track#)+buf.base;      do while i ilt mwrd#;         call psmread(j,i);             /* get cue record length       */         clen = read(psd);         if  (clen igt cue.name )          /* if good record length    */         and (clen ile Max.Cue.Record.Len) /* not too long either      */         then do;                          /* define new cue           */            call Copy.Poly.To.Ext.Mem(j,i,ccue.xmsec#,0,clen);            /* Look up what track the cue came from.   Set */            /* track bits to reflect destination track     */            /* in case things are being bounced            */            write(mam) = ccue.xmsec#;            write(mal) = cue.trks;            if (read(md) & tbits) <> 0   /* if original bit was set */            then write(md) = bits(port.thisdest(port#));  /* then set it here too */            else write(md) = 0;            local.fix: proc(x,code);   /* fix bases      */               dcl x    fixed;               dcl code fixed;               call READ32(ccue.xmsec#,x,a);               if  (a(0) <> (-1))               or  (code =  ( 0))               then call ADD32(a,C.Data.S#,a);               call WRITE32(ccue.xmsec#,x,a);            end;            /* check for un-initialized cue area (old format) */            write(mam) = ccue.xmsec#;            write(mal) = Cue.List.Ptr;            ptr = read(mdi);            len = read(mdi);            /* if not a reel, update all pointers to current */            /* song position                                 */            if ptr = 0 then do;               call local.fix(cue.s.msb,0);               call local.fix(cue.e.msb,0);               call local.fix(cue.edit.in.msb,0);               call local.fix(cue.edit.out.msb,0);               call local.fix(cue.off.msb,0);               /* assign to cue.in.s#.msb to handle old cues */               call READ32 (ccue.xmsec#,cue.s.msb,a);               call WRITE32(ccue.xmsec#,cue.in.s#.msb,a);               call local.fix(event.in.s#.msb,0);            end;            /* else if reel, just adjust mapping */            else do;                           /* handle reel */               /* adjust in.s# since it is always somewhere */               /* in the current project (by definition)    */               call local.fix(cue.in.s#.msb,0);               do k = ptr to ptr + len - 1  by Cue.Seg.Stride;                  call READ32(ccue.xmsec#,k + S#In.Msb, a);      /* in  time rel to project */                  call READ32(ccue.xmsec#,k + S#Out.Msb,b);      /* out time rel to project */                  call ADD32(a,C.Data.S#,a);   /* add project start      */                  if b(0) <> (-1)                  then call ADD32(b,C.Data.S#,c);   /* add project start      */                  else call COPY32(b,c);            /* or leave at -1, -1     */                  /* if segment started before current project,  */                  /* and it now starts before the front of the   */                  /* disk,  must adjust things.   This happens   */                  /* if a project originally stored at the end   */                  /* of the disk is moved back towards the front */                  /* of the disk if cues contained material      */                  /* that was in an earlier project              */                  if  (a(0) < 0)                  or  (COM32(A, Data.S#) = lw#ilt)                  then do;                     if ( b(0) =  (-1) )       /* if segment went to end */                     or ((c(0) >= ( 0))        /* or is audible          */                     and (COM32(C, Data.S#) >= lw#ieq))                     then do;                  /* correct sync           */                        call READ32(ccue.xmsec#,k + S#Sync.Msb,b);                        call SUB32 (b,a,b);    /* a is negative now      */                        call ADD32 (b, Data.S#, b);                        call COPY32 (Data.S#, a);    /* new in time of 0,0     */                        call WRITE32(ccue.xmsec#,k + S#In.Msb,   a);                        call WRITE32(ccue.xmsec#,k + S#Out.Msb,  c);                        call WRITE32(ccue.xmsec#,k + S#Sync.Msb, b);                     end;                     else do;                  /* else zap segment       */                        call WRITE32(ccue.xmsec#,k + S#In.Msb,  Data.S#);                        call WRITE32(ccue.xmsec#,k + S#Out.Msb, Data.S#);                     end;                  end;                  else do;                     /* get all of it          */                     call WRITE32(ccue.xmsec#,k + S#In.Msb, a);                     call WRITE32(ccue.xmsec#,k + S#Out.Msb,c);                  end;                  /* Set track bits to just this track in */                  /* case just this track is being        */                  /* loaded.  Set the bit corresponding   */                  /* to the destination track in case     */                  /* things are being bounced:            */                  call read.store(ccue.xmsec#,k + S#DriveBits1);                  if (read(md) & tbits) <> 0                  then write(md) = bits(port.thisdest(port#));                  else write(md) = 0;               end;            end;            k=insert.cue.in.list(ccue.xmsec#,0,0);               /* If duplicate name and time,  means we are loading  */            /* the second track of a pair of tracks in the cue.   */            /* Just OR in the new track bit to the old definition */            if (k=(-2)) then do;                  /* duplicate name and time */               call get.cue.ptrs(found.cue.id#);/* get cue                 */               write(mam) = ccue.xmsec#;  /* see if our bit is set  */               write(mal) = cue.trks;     /* in cue we are loading  */               /* (check bits(port.thisdest(port#)) here */               /*  instead of tbits since we modified    */               /*  the cue data above:)                  */               if (read(md) & bits(port.thisdest(port#))) <> 0   /* if original bit was set */               then do;                  call read.store(cue.sec#+cue.sec, cue.wrd+cue.trks);                  write(md) = read(md) \ bits(port.thisdest(port#));                  cue.info.updated = 1;               end;               /* fix up track bits in segments */               call read.store(cue.sec#+cue.sec, cue.wrd + Cue.List.Ptr);               if  (ptr = read(mdi))   /* make sure the duplicate cue */               and (len = read(mdi))   /* has same # of segments      */               then do;                  if ptr <> 0 then do;   /* update all equal segment bits */                     do k = ptr to ptr + len - 1  by Cue.Seg.Stride;                        /* check bits(port.thisdest(port#)) here */                        /* instead of tbits since we modified    */                        /* the cue data above:                   */                        call read.store(ccue.xmsec#,k + S#DriveBits1);                        if (read(md) & bits(port.thisdest(port#))) <> 0                        then do;                           call read.store(cue.sec#+cue.sec, cue.wrd + k + S#DriveBits1);                           write(md) = read(md) \ bits(port.thisdest(port#));                           cue.info.updated = 1;                        end;                     end;                  end;               end;            end;         end;         i=i+clen;                     /* advance pointer always      */         port.cue.ix(port#) = i;       /* save current pointer        */         return;                       /* divide up workload...       */      end;   end;   port.retry(port#)=0;              /* read next block  */   poly.buffs.in.use        = poly.buffs.in.use       - 1;   this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;   tape.state      (port# ) = load.process.next.chunk.state;end load.cue.defs.from.song;/* Handle load song case of no cart in drive */handle.load.song.no.cart.case:proc(port#,track#) swap;	dcl (port#,track#) fixed;	zero.jaz.position(port#);					  /* reset possible jaz to BOT if no cart...	*/		/* only make the following checks if we are */	/* not waiting for the second               */	/* cartridge!                               */	/* Basically,  we are going to try to get   */	/* the user to insert all the carts that    */	/* go with this project.  If he backed up   */	/* the project and is trying to load it to  */	/* the same configuration,  make sure he    */	/* puts in any carts that contained         */	/* non-empty tracks.   Allow tracks to be   */	/* ignored if we are switching configs.     */	if tape.return.state(port#) = 0 then do;	   if  (((emptybits  &bits(track#))<>0))  /* if this track actually is empty */	   or  (((bouncedbits&bits(track#))<>0))  /* or being filled by bouncing     */	   or  (((songread                 <>0))  /* or one song read                */	   and  ((trackswap                <>0)   /* and tracks wer swapped          */	   or    (command.#          = c.asong)   /* or we are just adding what      */	   or    (command.#          = c.aall )   /* is available ...                */	   or    (command.#          = c.skipb))) /* or skiping backwards            */	   then do;                               /* as determined by one good song  */		  if songread <> 0                     /* directory, then quit.           */		  then do;                             /* finish off this track once      */			 call finish.command(track#);			 port.io(port#) = 0;                /* skip delay */		  end;		  return;                             /* we have read one good song.     */	   end;	end;	if errmess<>0                 /* other message waiting        */	then return;	if port# = max.ports          /* if reading from AUX tape,    */	then i = port#;               /* then ask for cart there      */	else if onetapeloaded = 0 then do; /* no tapes loaded - give generic error message */	   i=0;                            /* have them load first tape */	   do while (i < max.ports)	   and      ((command.tracks&port.track.bits(i))=0);		  i=i+1;	   end;	   if i = max.ports then i = port#;	end;	else i = port#;	if tape.return.state(port#)<>0 then do; /* second tape: */	   call log.error('Insert Next Cartridge in ');	   call append.tape.mes(port#);	   errmess=(256\port#);	end;	else do;	   call log.error('Insert Cartridge in ');	   call append.tape.mes(i);	   errmess=(256\i);	end;end handle.load.song.no.cart.case;/* Handle case of cart is, in fact, in the drive */handle.load.song.cart.in.case:proc(port#) swap;	dcl port# fixed;		onetapeloaded = 1;		/* If we had explicitly asked for a cartridge,       */	/* say thank you.                                    */		if errmess = (256\port#)  /* had been our message */	then do;		errmess = 0;		if tape.return.state(port#)=0		then do;		   call log.error('Thank You.');		end;		else do;		   if      (command.# = c.verf   )		   or      (command.# = c.verfall)		   then call log.error('Thank you. Continuing with Verify - ');		   else if (command.# = c.skipf   )		   or      (command.# = c.skipfall)		   then call log.error('Thank you. Continuing with Skip - ');		   else call log.error('Thank you. Continuing with Load - ');		   call append.tape.mes(port#);		end;	 end;	 /* Else if we had not explicitly asked for a cartridge, just */	 /* announce we are continuing with this track if we are not  */	 /* explicity asking for another cartridge.                   */	 else if tape.return.state(port#)<>0 then do; 		if errmess=0 then do;		   if      (command.# = c.verf   )		   or      (command.# = c.verfall)		   then call log.error('Continuing with Verify - ');		   else if (command.# = c.skipf   )		   or      (command.# = c.skipfall)		   then call log.error('Continuing with Skip - ');		   else if (command.# = c.show)		   then call log.error('Getting Project Information - ');		   else call log.error('Continuing with Load - ');		   call append.tape.mes(port#);		end;	end;		/* now that the tape is inserted - clear the notloadedtapes bits */	/* for all desired tracks on this port                           */		notloadedtapes = notloadedtapes and (not(port.track.bits(port#)));		port.retry  (port# )=0;		tape.state  (port# )=tape.state(port#) + 1;  /* issue mode select */end handle.load.song.cart.in.case;/* Create message for removing off cartridge if cart full change needed */handle.load.song.no.cart.remove.case:proc (port#) swap;	dcl port# fixed;		port.timer(port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */	port.io   (port#) = Tape.Wait; /* go to this state to wait   */	port.retry(port#) = 0;     	tape.state(port#) = load.begin.real.interrogation.state; /* re-issue inq       */	if errmess<>0                /* other message waiting        */	then return;	call log.error('End of Media - Insert Next Cartridge in ');	call append.tape.mes(port#);	errmess=(256\port#);end handle.load.song.no.cart.remove.case;handle.read.check.error.retry:proc (port#, track#) swap;	dcl (port#, track#) fixed;		if log.buf(0)<>0 then return 1;	if  (track.command(track#) = S$RequestSense)	and (track.status (track#) = S$MediumError )	then call log.error('A Medium Error occurred with Backup ');	else call log.error('Media Reading Error - Please Retry ');	call append.tape.mes(port#);	call finish.port.command(port#);	command.fatal=1;end handle.read.check.error.retry;handle.read.check.error.eof:proc (port#) swap;	dcl port# fixed;		tape.return.state(port#) = tape.state(port#);	tape.state (port#)       = 1;	tape.eof   (port#)       = 0;  /* clear eof flag              */	tape.remove(port#)       = 1;  /* wait for remove before load */end handle.read.check.error.eof;global.read.check.error:proc(port#, track#);	dcl (port#, track#) fixed;		if port.retry(port#)<>0 then do;		handle.read.check.error.retry(port#, track#);		return 1;	end;	if tape.eof(port#)<>0 then do;    /* end of tape reached - get next */		handle.read.check.error.eof(port#);		return 1;	end;	return 0;end global.read.check.error;init.for.load.song:proc(port#) swap;	dcl port# fixed;		port.retry       (port#)=0; /* initialize retry count            */	tape.return.state(port#)=0;	tape.remove      (port#)=0;	tape.eof         (port#)=0;	tape.skip        (port#)=0;	port.count       (port#)=0;	tape.type        (port#)=0;		numerrs = 0;		tape.state       (port#)=tape.state(port#) + 4;end init.for.load.song;prep.for.poly.mem.access:proc (port#, track#, tport#) swapable;	dcl (port#, track#, tport#) fixed;		port.retry(port#) = 0;				 /* ignore past errors				*/	tape.eof  (port#)	= 0;				 /* and reset file mark/eof		*/	tape.fmark(port#) = 0;            /* indications here       		*/		zap.buffer(track#) = 1;           /* zap buffers next time we try to play  */	poly.buffs.in.use        = poly.buffs.in.use       + 1;	this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;	tape.state      (port# ) = tape.state     (port# ) + 1;end prep.for.poly.mem.access;handle.possible.jaz.directory.read:proc (port#, track#) swapable;	dcl (port#, track#) fixed;		if (tape.type(port#) == type.jaz)	{		port.jaz.update(port#) = 0;									/* no update at this point */		tape.pmem.add = compute.base.adr(track#) + buf.base;	/* use regular buffer		*/		Tape.Disk.Add.Msb = 0;											/* disk block #				*/		Tape.Disk.Add.Lsb = 0;				start.tape.command(port#, track#, Tape.ExtendedRd, 1);/* read one block 			*/	}		else		tape.state (port#) = tape.state(port#)+1;end handle.possible.jaz.directory.read;finish.for.jaz.directory.read:proc (port#, track#, tport#) swapable;	dcl (port#, track#, tport#) fixed;		if (tape.type(port#) == type.jaz)	{		/* Copy the directory that we read into Poly memory into external memory					*/		/* where we can (more-or-less) keep it around...													*/				Copy.Poly.To.Ext.Mem(compute.base.adr(track#) + buf.base, 0,									jaz.dir.sec# + port#, 0, 256);	}	poly.buffs.in.use        = poly.buffs.in.use       - 1;	this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;	tape.state      (port# ) = tape.state     (port# ) + 1;end finish.for.jaz.directory.read;/* We get here when a cartridge has been inserted in a drive during a load.  If this	*//* is a removable media hard drive, the directory  has been read in.  We perform			*//* consistency checks on the directory, and then jump back to reading the					*//* project if this is a second cartridge.																*/handle.possible.load.return.state:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (magic1, magic2, numfmarks, eotmsb, eotlsb, fmkmsb, fmklsb) fixed;				/* For jaz tapes, perform consistency checking and verify the directory that			*/	/* we just read in.  Make sure the directory is real											*/		if (tape.type(port#) == type.jaz)	{		if ((port.jaz.cap.msb(port#) == 0)		/* if capacity information not available, then	*/		&&  (port.jaz.cap.lsb(port#) == 0))		/* something bombed										*/		{			if log.buf(0)<>0 then return;  		/* wait for prior msg   								*/			call log.error('Capacity error (fatal) occurred with ');			call append.tape.mes(port#);			call finish.port.command(port#);			command.fatal = 1;						zero.jaz.position(port#);			return;		}				write(mam) = jaz.dir.sec# + port#;		magic1     = read(mdi);					/* jaz.magic.#1.loc										*/		magic2     = read(mdi);					/* jaz.magic.#2.loc										*/		numfmarks  = read(mdi);					/* jaz.num.fmarks.loc									*/		eotmsb     = read(mdi);					/* jaz.leot.msb.loc										*/		eotlsb     = read(mdi);					/* jaz.leot.lsb.loc										*/					/* Consistency check the in-core directory */					if (( magic1                   != jaz.magic.#1   )	/* if unformatted media				*/		||  ((magic2						 != jaz.magic.#2  )		&&   (magic2						 != jaz.magic.#3  )))		{			if log.buf(0)<>0 then return;  		/* wait for prior msg   							*/			call log.error('Cartridge is not a DTD Backup in ');			call append.tape.mes(port#);			call finish.port.command(port#);			command.fatal = 1;			zero.jaz.position(port#);			return;		}				if (( numfmarks                >  jaz.max.fmarks )		||  ( port.jaz.fmk.inx(port#)  >  numfmarks      ))		{			if log.buf(0)<>0 then return;  		/* wait for prior msg   							*/			call log.error('Directory error (fatal) occurred with ');			call append.tape.mes(port#);			call finish.port.command(port#);			command.fatal = 1;			return;		}				/* Consistency check current position */				/* if current position is at 0, set up for read of first data block.  Note that  */		/* we could be at the start of a song, or the middle of a song if this is			*/		/* a continuation cartridge.																		*/				if (port.jaz.fmk.inx(port#) == 0)				/* if we just changed tapes, we		*/		{															/* end up here, by the way...			*/			port.jaz.sec.msb(port#) = 0;			port.jaz.sec.lsb(port#) = jaz.directory.space;		}				/* Else make sure we are sitting right after a file mark.  This will only happen	*/		/* if we just did a load or skip with this media...										*/				else		{			write(mam) = jaz.dir.sec# + port#;			write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);			fmkmsb = read(mdi);			fmklsb = read(mdi);						fmklsb = fmklsb + 1;			if (fmklsb == 0) fmkmsb = fmkmsb + 1;						if ((port.jaz.sec.msb(port#) != fmkmsb)			/* should match sector past		*/			||  (port.jaz.sec.lsb(port#) != fmklsb))			/* last file mark						*/			{				if log.buf(0)<>0 then return;  					/* wait for prior msg  				*/				call log.error('Filemark position error (fatal) occurred with ');				call append.tape.mes(port#);					call finish.port.command(port#);				command.fatal = 1;				return;			}		}	}		/* Return to loading the song if we just changed carts: */		if tape.return.state(port#)<> 0 then do;      /* return for next tape */		tape.state       (port#) = tape.return.state(port#);		tape.return.state(port#) = 0;	end;	/* Wait for 1 second here before reading song header.  This */	/* will allow us to look and see whether other tapes are in */	/* in case we want to read a bunch of data from this tape   */	/* and write it to another port.  This happens when         */	/* loading an AUX tape onto a port tape system,  or when    */	/* reading max trax tapes onto a normal system.             */	else do;		if command.# = c.skipb		then tape.state (port#) = tape.state(port#)+1; /* issue skip back     */		else tape.state (port#) = tape.state(port#)+4; /* or read first block */		port.timer (port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */		port.io    (port#) = Tape.Wait;		tape.eof   (port#) = 0;            /* clear eof and fmark    */		tape.fmark (port#) = 0;            /* indications here       */		port.retry (port#) = 0;  end;end handle.possible.load.return.state;handle.skip.back.step.1:proc (port#, track#) swapable;	dcl (port#, track#) fixed;		if dirloaded=0                 /* show only one message      */	then do;		call log.error('Starting Backwards Skip...');		dirloaded = 256+track#;	end;		/* for jaz: easy enough!  Back up to prior file mark or start of tape */		if (tape.type(port#) == type.jaz)	{		if (port.jaz.fmk.inx(port#) != 0)			port.jaz.fmk.inx(port#) = port.jaz.fmk.inx(port#) - 1;				if (port.jaz.fmk.inx(port#) == 0)		/* if now positioned at 0.  Note this could	*/		{													/* actually be the start of a continuation	*/			port.jaz.sec.msb(port#) = 0;			/* media, we don't really know....				*/			port.jaz.sec.lsb(port#) = 0;		}				else												/* back up to 1 after prior file mark 			*/		{			dcl (fmkmsb, fmklsb) fixed;						write(mam) = jaz.dir.sec# + port#;			write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);			fmkmsb = read(mdi);			fmklsb = read(mdi);						fmklsb = fmklsb + 1;			if (fmklsb == 0) fmkmsb = fmkmsb + 1;						port.jaz.sec.msb(port#) = fmkmsb;			port.jaz.sec.lsb(port#) = fmklsb;		}				call finish.port.command  (port#); /* done with this tape    */		songread = 1;                      /* terminate empty drives */		eotreached=0;                      /* allow messages now     */				return;	}		if tape.eof(port#)<>0 then do;     /* eof on space back      */		/* big oops: never handle multiple */		tape.state(port#)=tape.state(port#)+2;										/* cartridge case!!!					  */		return;                         /* means must be at top   */	end;                               /* of tape                */		if tape.fmark(port#)<>0             /* file mark encountered (normal */	then do;                            /* termination                   */		tape.fmark(port#)=0;             /* clear flag for next time      */		tape.state(port#)=tape.state(port#)+1;		return;	end;		if global.read.check.error(port#, track#)<>0 then return; /* check for tape errors */		start.tape.command(port#,track#,Tape.Space,-2);  /* skip backwards two file marks */end handle.skip.back.step.1;handle.load.song.eof.at.start:proc (port#, tport#) swapable;	dcl (port#, tport#) fixed;		if log.buf(0)<>0 then return 1;	eotreached=1;                  /* mark eot for load all, add all, verify all */	if  (command.#<>c.lall    )	and (command.#<>c.aall    )	and (command.#<>c.verfall )	and (command.#<>c.skipfall)	then do;		call log.error('End of Backup Media Reached in ');		call append.tape.mes(port#);		command.fatal=1;	end;	else do;                      /* do not ask for more carts on */		emptybits = (-1);          /* load all/add all/skip all if */		songread  = 1;             /* one cart is in there and     */	end;                          /* already at the end.          */	poly.buffs.in.use        = poly.buffs.in.use       - 1;	this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;	call finish.port.command(port#);end handle.load.song.eof.at.start;handle.skip.forward:proc (port#, track#) swapable;	dcl (port#, track#) fixed;	dcl (numfmarks, fmkmsb, fmklsb) fixed;	/* here's where we handle skipping forward (or aborting a real load command)	*/	/* for jaz drives.  Skip to the next file mark if it is on this media, or		*/	/* else ask for the next media and skip to the first file mark on it...			*/		if (tape.type(port#) == type.jaz)							/* if is a hard drive	*/	{		write(mam) = jaz.dir.sec# + port#;						/* access directory		*/		write(mal) = jaz.num.fmarks.loc;							/* get num of fmarks		*/		numfmarks  = read(mdi);						/* if we are already at or after the last file mark on this cart, then		*/		/* there must be another cart...															*/				if (port.jaz.fmk.inx(port#) >= numfmarks)		{			handle.read.check.error.eof(port#);			return;		}				/* else skip forward to after the next filemark */				port.jaz.fmk.inx(port#) = port.jaz.fmk.inx(port#) + 1;				write(mam) = jaz.dir.sec# + port#;		write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);		fmkmsb = read(mdi);		fmklsb = read(mdi);				fmklsb = fmklsb + 1;		if (fmklsb == 0) fmkmsb = fmkmsb + 1;				port.jaz.sec.msb(port#) = fmkmsb;		port.jaz.sec.lsb(port#) = fmklsb;		tape.state(port#)=tape.state(port#)+1;		return;	}		if tape.fmark(port#)<>0             /* file mark encountered (normal */	then do;                            /* termination                   */		tape.state(port#)=tape.state(port#)+1;		return;	end;	if global.read.check.error(port#, track#)<>0 then return; 	/* check for next tape or error 	*/	start.tape.command(port#,track#,Tape.Space,1);  				/* skip forward one file mark 	*/end handle.skip.forward;handle.reposition.step.1:proc (port#, track#) swapable;	dcl (port#,  track#) fixed;	dcl (fmkmsb, fmklsb) fixed;		/* For jaz drives, just reset to the start of the song header */		if (tape.type(port#) == type.jaz)							/* if is a hard drive	*/	{		if (port.jaz.fmk.inx(port#) == 0)						/* if at front, set		*/		{																	/* cur position to 0		*/			port.jaz.sec.msb(port#) = 0;			port.jaz.sec.lsb(port#) = 0;		}				else		{			write(mam) = jaz.dir.sec# + port#;			write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);			fmkmsb = read(mdi);			fmklsb = read(mdi);						fmklsb = fmklsb + 1;			if (fmklsb == 0) fmkmsb = fmkmsb + 1;						port.jaz.sec.msb(port#) = fmkmsb;			port.jaz.sec.lsb(port#) = fmklsb;		}				call finish.port.command  (port#); /* done with this tape    */		songread = 1;                      /* terminate empty drives */		eotreached=0;                      /* allow messages now     */				return;	}	if tape.eof(port#)<>0 then do;     /* eof on space back      */		tape.state(port#)=tape.state(port#)+2;		return;                         /* means must be at top   */	end;                               /* of tape                */	if tape.fmark(port#)<>0             /* file mark encountered (normal */	then do;                            /* termination                   */		tape.fmark(port#)=0;             /* clear flag for next time      */		tape.state(port#)=tape.state(port#)+1;		return;	end;	if global.read.check.error(port#, track#)<>0 then return; /* check for tape errors */	start.tape.command(port#,track#,Tape.Space,-1);  /* skip backwards one file mark */end handle.reposition.step.1;handle.space.over.fmark:proc (port#, track#) swapable;	dcl (port#,  track#) fixed;	dcl (fmkmsb, fmklsb) fixed;		/* For jaz drives, bump the file mark index and position */	/* after that...														*/		if (tape.type(port#) == type.jaz)							/* if is a hard drive	*/	{		port.jaz.fmk.inx(port#) = port.jaz.fmk.inx(port#) + 1;				write(mam) = jaz.dir.sec# + port#;		write(mal) = jaz.fmark.msb.loc + shl(port.jaz.fmk.inx(port#)-1, 1);		fmkmsb = read(mdi);		fmklsb = read(mdi);				fmklsb = fmklsb + 1;		if (fmklsb == 0) fmkmsb = fmkmsb + 1;				port.jaz.sec.msb(port#) = fmkmsb;		port.jaz.sec.lsb(port#) = fmklsb;				tape.state(port#)=tape.state(port#)+1;		return;	}	if tape.fmark(port#)<>0             /* file mark encountered (normal */	then do;                            /* termination                   */		tape.state(port#)=tape.state(port#)+1;		return;	end;	if global.read.check.error(port#, track#)<>0 then return;	j=compute.base.adr(track#);	tape.pmem.add=j+buf.base;	start.tape.command(port#,track#,Tape.Read,1);  /* read one block  -  should stop at expected file mark. */		if tdebug then tape.recover.code(port#) = 1;     /* perform eof error recovery if media error */end handle.space.over.fmark;/* main driver for loading: */load.song:proc(port#,track#) public swap;   dcl (port#,track#) fixed static;   read.check.error:proc;      if port.retry(port#)<>0 then do;			handle.read.check.error.retry(port#, track#);			return 1;      end;      if tape.eof(port#)<>0 then do;    /* end of tape reached - get next */			handle.read.check.error.eof(port#);         return 1;      end;      return 0;   end read.check.error;   /* deadtape.check: set bits in DEADTAPES for any port that contains */   /* an inoperative tape.  This routine is called when a port is      */   /* dead (ie tape does not respond to INQ.).  Set bits in deadtapes  */   /* for all tracks on this port we were supposed to load.            */   deadtape.check:proc;      deadtapes = deadtapes \ (port.track.bits(port#) & command.tracks);      /* Return true if there still may be tracks for which we */      /* do not have dead tapes (i.e. may have a live one)     */      if (command.tracks & (not(deadtapes))) <> 0      then return 1;      return 0;                            /* all tapes are dead         */   end deadtape.check;   /* not.loaded.check:  set bits in NOTLOADEDTAPES for any tracks in which */   /* no tape is loaded:                                                    */   not.loaded.check:proc;      notloadedtapes = notloadedtapes \ (port.track.bits(port#) & command.tracks);      /* return true if there still may be another tape which may be */      /* good or may be loaded.                                      */      if (command.tracks & (not(deadtapes)) & (not(notloadedtapes))) <> 0      then return 1;      return 0;                            /* all tapes are dead or unloaded - need one message */   end not.loaded.check; /* find.thisdest - routine looks at THISTRACK,  which is the original     */ /* track # (+256) that the next block of tape data came from.   It looks  */ /* to see what track # on this port the data should be written to.        */ /* Smart logic is required to handle bouncing of projects.                */   find.thisdest:proc;      dcl i fixed;      block.skip(port#) = tape.skip(port#);   /* skip block if skipping tape */      port.thisdest(port#) = (-1);            /* assume no dest found    */      do i = 0 to max.tracks-1;               /* check possible routings */         if   (thistrack = port.track.list(port#*max.tracks+i))         and  (port.dest.list(port#*max.tracks+i) <> 0)         then  port.thisdest(port#) = port.dest.list(port#*max.tracks+i)                                     & 255;      end;      /* if none found,  then we will skip over this info on tape.       */      /* This happens if we are reading info from tape and there is      */      /* no place to put it on disk (ie bad tracks, etc.)                */      if port.thisdest(port#) = (-1)      then do;         port.thisdest(port#)=0;         block.skip   (port#)=1;        /* skip data */      end;   end find.thisdest;	/* Read from jaz drive, checking for EOF */	/* note: at this point in time, all commands to the tapes are issued in 4096-word	*/	/* block (e.g. 8 k bytes).  This assures that the command boundaries are				*/	/* the same when reading or writing.  Therefore, we don't have to worry about			*/	/* partial block reads or writes at this time...												*/		issue.jaz.read.command:proc (blen);		dcl (blen, len)      fixed;		dcl (eotmsb, eotlsb) fixed;						len = shl(blen, 4);									/* get # of sectors  */				write(mam) = jaz.dir.sec# + port#;		write(mal) = jaz.leot.msb.loc;		eotmsb     = read(mdi);								/* jaz.leot.msb.loc	*/		eotlsb     = read(mdi);								/* jaz.leot.lsb.loc	*/		if (( port.jaz.sec.msb(port#) IGT eotmsb )	/* if starting read  */		||  ((port.jaz.sec.msb(port#) ==  eotmsb)		/* at (or after?) 	*/		&&   (port.jaz.sec.lsb(port#) IGE eotlsb)))	/* leot, then no		*/			tape.eof(port#) = 1;								/* data transferred	*/				else		{			Tape.Disk.Add.Msb      = port.jaz.sec.msb(port#);			Tape.Disk.Add.Lsb      = port.jaz.sec.lsb(port#);			port.jaz.update(port#) = len;			start.tape.command(port#, track#, Tape.ExtendedRd, len);		}	end issue.jaz.read.command;   /* $page - start of backup song/backup track */   tport# = track.port.ix(track#);   /* get track port in case using AUX   */   if  (buf.size.in.use > buf.len)   /* if need part of record buffer      */   then do;                          /* for load ...                       */      if (new.inputs <> 0)           /* wait for all inputs to be          */      then return;                   /* disconnected                       */      track.sampling(track#) = (-1); /* and set flag to zero out rec buf   */   end;                              /* at end of command                  */   if real.milliseconds>=updatetime   then do;      send.screen.info=1;      updatetime = real.milliseconds+5000;   end;   do case tape.state(port#);      /* initialize variables.  Jump ahead to state 4.  States 1, 2, and 3  */      /* are used to change cartridges.                                     */      do;                            	/* start of load for this port/track */			init.for.load.song(port#);      end;      /* State 1: eject tape to ask for next cartridge.                   	*/      do;   									/* load tape first						*/         if check.tape.ready(port#, track#) <> 0         then return;			handle.load.load (port#, track#);      end;      do;                            /* eject this tape							*/         if check.tape.ready(port#, track#) <> 0         then return;						handle.backup.eject(port#, track#);      end;      do;									 /* wait for next cart						*/         port.count (port#) = 0;         tape.state (port#) = load.begin.real.interrogation.state;      end;      /* State 4 - Begin by waiting for track directory               *//*4*/ do;         if check.tape.ready(port#, track#) <> 0         then return;         if alt.tdir.valid=0         /* wait for valid alternate tdir       */         then return;                /* although we may trash it            */         tape.state(port#) = tape.state(port#) + 1;      end;      /* Tape Interrogation phase - The following 3 states are executed */      /* to determine which type of drive to use for this command.      *//*5*/ do;         /* Check for abort,  error (no tape drive), end of interrogation */         if check.interrogation.condition(port#) <> 0         then return;         call issue.inquiry(port#, track#);      end;/*6*/ do;         /* Check for abort,  error (no tape drive), end of interrogation */         if check.interrogation.condition(port#) <> 0         then return;         call issue.test.unit.ready(port#,track#);      end;/*7*/ do;         call check.interrogation.result(port#);      end;      /* Now that we have selected the tape drive to use,  make sure */      /* a cart is in this drive if we need to.                      *//*8*/ do;         /* Perform special error recovery here for bad tapes */			/* This is where we pick up after changing tapes     */					load.begin.real.interrogation.state = tape.state(port#);			         if port.retry(port#)>3 then do;            if deadtape.check<>0      /* this tape is dead.  abort command */            then return;              /* if all tapes are dead.            */            /* all needed tapes are dead */            if (emptybits&bits(track#))<>0      /* if this track actually is empty */            then do;                            /* as determined by one good song  */               call finish.command(track#);     /* directory,  then track is empty */               return;                          /* so allow this tape to be dead   */            end;            call hardware.error(port#,track#); /* print error message */            return;         end;         tape.condition(port#) = 0; /* clear all condition bits for tape1 & tape2 */         tape.to.use   (port#) = tapetouse; /* select tape1 VS tape2   */         call issue.inquiry(port#, track#);      end;      /* Issue test unit ready to check ready info for cdc, wang       *//*9*/ do;          call issue.test.unit.ready(port#, track#);      end;      /* Examine inquiry status to see if cart is in drive *//*10*/do;                            /* inquiry status here                 */         if check.tape.ready(port#, track#) <> 0         then return;         if (tape.condition(port#) & (t1.cond.rdy\t2.cond.rdy)) = 0   /* if no cart in drive */         then do;                                    /* then ask for one    */            port.retry  (port#) = 0;                 tape.remove (port#) = 0;       /* has been removed, if needed */            port.timer  (port#) = real.milliseconds + cdc.busy.delay; /* wait a while before polling again */            port.io     (port#) = Tape.Wait;  /* go to this state to wait */            tape.state  (port#) = load.begin.real.interrogation.state; /* re-issue inq       */            if not.loaded.check<>0        /* return until all are unloaded or dead */            then return;				handle.load.song.no.cart.case(port#,track#);            return;         end;         /* Wait for catridge to be removed if we really need the */         /* next one.                                             */         if tape.remove (port#)<>0       /* must remove cartridge for second one */         then do;				handle.load.song.no.cart.remove.case(port#);            return;         end;         /* OK - Cartridge is in.                                */         /* perform a second check in case cartrdige was in      */         /* for the INQ but was removed for the TUN              */         if port.count(port#)=0 then do;            port.count(port#) = port.count(port#) + 1;            tape.state(port#) = load.begin.real.interrogation.state;    /* do another inq/sense command in case cartdridge was inserted for sense but was not in for inq */            return;         end;         /* Cart is really in.  Remove our messages and begin */         /* reading the tape.                                 */			handle.load.song.cart.in.case(port#);      end;      do;                            /* mode select, read capacity */			if (tape.type(port#) == type.jaz)				issue.read.capacity(port#, track#);   		else         	issue.mode.select(port#,track#);      end;		do;		/* lock poly memory to read jaz directory */         if  (port.io(tport#)  <> 0)       /* make sure this port is free        */         then return;                      /* is through.                        */						prep.for.poly.mem.access(port#, track#, tport#);		end;		do;									 /* read in directory for Jaz tape       */         if read.check.error<>0 then return;						handle.possible.jaz.directory.read(port#, track#);		end;				do;			finish.for.jaz.directory.read(port#, track#, tport#);		end;				/* now branch back to return state (if just changed to second media)   */		/* or actually start a load/verify/skip operation							  */      		do;                            /* reset retry count at start of backup */			handle.possible.load.return.state(port#, track#);      end;      /* handle skip back by skipping back 2 file marks and then      */      /* forward one file mark                                        *//*1*/ do;   /* issue step back two file marks:                        */			handle.skip.back.step.1(port#, track#);      end;/*2*/ do;   /* now space forward over the file mark */         if tape.fmark(port#)<>0             /* file mark encountered (normal */         then do;                            /* termination                   */            tape.state(port#)=tape.state(port#)+1;            return;         end;         if read.check.error<>0 then return; /* check for next tape or error */         start.tape.command(port#,track#,Tape.Space,1);  /* skip forward one file mark */      end;/*3*/ do;  /* normal termination for space back command */         call finish.port.command  (port#); /* done with this tape    */         songread = 1;                      /* terminate empty drives */         eotreached=0;                      /* allow messages now     */      end;      /* $page - read at least one song header *//*4*/ do;   /* lock poly buffer to check header & info */         if  (port.io(tport#)  <> 0)       /* make sure this port is free        */         then return;                      /* is through.                        */						prep.for.poly.mem.access(port#, track#, tport#);      end;      do;  /* locked */                			        /* end of tape before song - must mean legit end of tape */         if tape.eof(port#)<>0 then do;				handle.load.song.eof.at.start(port#, tport#);            return;         end;         if read.check.error<>0 then return;         j=compute.base.adr(track#);         tape.pmem.add=j+buf.base;			if (tape.type(port#) == type.jaz)					/* if jaz drive		  */				issue.jaz.read.command(1);			     		  	/* then check eot	  */         else         	start.tape.command(port#,track#,Tape.Read,1);  /* read one block */      end;      do;  /* locked */                  /* check song header block     */         /* Examine header from start of tape */         if log.buf(0)<>0 then return;      /* make sure error goes out    */         call examine.load.song.header(port#, track#);      end;      /* Check for skipf or show command and handle accordingly      *//*0*/ do;    /* unlocked */         tape.eof  (port#) = 0;            /* clear eof and fmark    */         tape.fmark(port#) = 0;            /* indications here       */         load.abort.state = tape.state(port#)+1; /* set abort state  */         if ((command.# = c.skipf   )       /* handle skip forward    */			||  (command.# = c.skipfall))         then tape.state(port#) = tape.state(port#) + 1;         else if command.# = c.show        /* handle show project    */         then tape.state(port#) = tape.state(port#) + 3;         else tape.state(port#) = tape.state(port#) + 6;      end;/*1*/ do;   /* unlocked - handle fast skip forward command */            /* or handle abort of load/verify              */			handle.skip.forward(port#, track#);      end;/*2*/ do;  /* unlocked - normal termination from skip forward command */         call finish.port.command  (port#); /* done with this tape    */         songread = 1;                      /* terminate empty drives */         eotreached=0;                      /* allow messages now     */      end;      /* handle show name by spacing back to filemark or start of     */      /* tape, then skipping back over the file mark if we need to    */				/* note: we printed out the name of the project as we processed */		/* the song header.  At this point, all we have to is 			 */		/* reposition the tape.														 *//*3*/ do;   /* unlocked - handle show project name command            */			handle.reposition.step.1(port#, track#);      end;/*4*/ do;   /* unlocked - now space forward over the file mark        */         if tape.fmark(port#)<>0             /* file mark encountered (normal */         then do;                            /* termination                   */            tape.state(port#)=tape.state(port#)+1;            return;         end;         if read.check.error<>0 then return; /* check for next tape or error */         start.tape.command(port#,track#,Tape.Space,1);  /* skip forward one file mark */      end;/*5*/ do;  /* unlocked - normal termination from show name command    */         call finish.port.command  (port#); /* done with this tape    */         songread = 1;                      /* terminate empty drives */         eotreached=0;                      /* allow messages now     */      end;      /* issue read for next block header, cue defs, or possibly end */		/* Here's where we start doing work for a load.  Read the		*/		/* next block on the tape.  The block will tell us whether		*/		/* we are at the end of the song, it contains some cue defs,	*/		/* or whether there is some audio data in yet following blocks	*//*6*/ do;   /* unlocked */ /* lock poly buffer to check block header & info */         if  (port.io(tport#)  <> 0)       /* make sure this port is free        */         then return;                      /* is through.                        */         zap.buffer(track#) = 1;           /* zap buffers next time we try to play  */         load.process.next.chunk.state = tape.state(port#);    /* return here for next block */         poly.buffs.in.use        = poly.buffs.in.use       + 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) + 1;         tape.state      (port# ) = tape.state     (port# ) + 1;         /* see special case above if headerok = 0 */      end;      do;                      if read.check.error<>0 then return;         j=compute.base.adr(track#);         tape.pmem.add=j+buf.base;			if (tape.type(port#) == type.jaz)					/* if jaz drive		  */				issue.jaz.read.command(1);			     		  	/* then check eot	  */         else         	start.tape.command(port#,track#,Tape.Read,1);  /* read one block */      end;            do;                         /* check for end of song block */         j=compute.base.adr(track#);         call psmread(j+buf.base,0);         do i=0 to 255;                     /* get first sector            */            misc.buf(i)=read(psd);         end;         if  (misc.buf(0) = 1111)    /* see if this is ending        */         and (misc.buf(1) = 2222)    /* block                        */         and (misc.buf(2) = 3333)         and (misc.buf(3) = 4444)         then do;            port.retry(port#) = 0;   /* process end of song          */            tape.state(port#) = tape.state(port#)+1;            tape.fmark(port#) = 0;   /* hopefully read file mark     */            poly.buffs.in.use        = poly.buffs.in.use       - 1;            this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;            return;         end;         /* must be block header or cue def - check witch - poly */         /* is still in use                                      */         port.cue.ix(port#) = 100;   /* set port.cue.ix          */         tape.state (port#) = tape.state(port#)+3;      end;		/* handle an end of song block.  Skip over the file mark */		/* and we are done.													*/		      do;                                    /* space to file mark */			handle.space.over.fmark(port#, track#);      end;      do;    /* load of this track pair is completed */         call finish.port.command  (port#);         send.screen.info = 1;         songread = 1;         eotreached=0;                     /* at least one tape may have more info */         if  ((command.#=c.lsong)                       /* load song       */         or   (command.#=c.lall ))                      /* or load all     */         and (command.fatal     =0)                     /* no errors       */         and ((command.tracks & (not(emptybits))) = 0)  /* no more data    */         then do;            i=command.song*song.len;            call gsong.dir(i+song.modified);            write(md)=0;                   /* un moded        */            command.song.dir.updated=1;         end;      end;      do;             /* look at block header - check for cue defs */                      /* note: poly is still in use                */         j=compute.base.adr(track#);         call psmread(j+buf.base,0);         call poly.in(addr(misc.buf(0)),256);         if  (misc.buf(0) <> 7777)          /* if not cue def header       */         or  (misc.buf(1) <> 6666)          /* then check for data block   */         or  (misc.buf(2) <> 5555)         or  (misc.buf(3) <> 4444)         then do;            tape.state(port#)=tape.state(port#) + 1;            return;                         /* with poly still in use      */         end;         thistrack = misc.buf(4);           /* get track #            */         tbits = bits(thistrack&255);       /* get original bit handy */         mwrd# = misc.buf(5);               /* words of cue data      */         call find.thisdest;                /* compute block.skip and port.thisdest */         call load.cue.defs.from.song(port#, track#);      end;      do;             /* look at block header     */                      /* note - poly still in use */         if log.buf(0)<>0 then return;      /* make sure error goes out    */         j=compute.base.adr(track#);         call psmread(j+buf.base,0);         do i=0 to 255;                     /* get first sector            */            misc.buf(i)=read(psd);         end;         if  (misc.buf(0) <> 5555)          /* tape is not at block header */         or  (misc.buf(1) <> 4444)         or  (misc.buf(2) <> 3333)         or  (misc.buf(3) <> 2222)         then do;            call log.error('Data Format Error with Backup ');            call append.tape.mes(port#);            poly.buffs.in.use        = poly.buffs.in.use       - 1;            this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;            call finish.port.command(port#);            command.fatal=1;            return ;         end;         thistrack=misc.buf(4);            /* get track #       */         tape.data.msb    (port#)=misc.buf(10);  /* relative sector # */         tape.data.lsb    (port#)=misc.buf(11);         tape.copy.len.msb(port#)=misc.buf(12);  /* number of sectors */         tape.copy.len.lsb(port#)=misc.buf(13);  /* in this block     */         call find.thisdest;               /* compute block.skip and port.thisdest */         port.retry      (port# ) = 0;              tape.read.len   (port# ) = 0;         poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (tport#) = this.buf.in.use(tport#) - 1;         tape.state      (port# ) = tape.state     (port# ) + 1;      end;/*0*/ do;     /* lock poly to perform copy */         thistrack = port.thisdest(port#);      /* get possible dest trk */         if (port#              <> max.ports)   /* if reading port tape */         or (block.skip (port#) <> 0        )   /* or tossing data      */         then do;                               /* then use track#      */            if  (port.io(tport#)  <> 0)         /* make sure this port is free        */            then return;                        /* is through.                        */            zap.buffer (track#) = 1;            /* zap buffers next time we try to play  */            port.polyadd(port#) = compute.base.adr(track#)+buf.base;            dport#              = tport#;       /* his port #           */         end;         else do;               /* else if reading aux tape and then    */                                /* writing data to disk,  read it       */                                /* into the buffer memory that goes     */                                /* with that port.                      */            dport# = track.port.ix(thistrack); /* get which port        */            port.polyadd(port#) = compute.base.adr(thistrack)+buf.base;            /* make sure that port is idle & park it in tape.park       */            /* so no one else tries to use it.                          */            if dport# <> tport# then do;               /* Unhang the wait state we are probably sitting in      */               /* while we are trying to poll the user for a tape       */               if   (port.io(dport#) = Tape.Wait)               or   (port.io(dport#) = Tape.Park)               then  port.io(dport#) = 0;               if port.io(dport#)<>0  /* there may be an INQ command    */               then return;           /* still outstanding.             */               port.io   (dport#) = Tape.Park;  /* park it there for    */               port.timer(dport#) = port#;      /* our use below.       */            end;            else do;               if  (port.io(tport#)  <> 0)      /* make sure this port is free        */               then return;                     /* is through.                        */            end;            zap.buffer(thistrack) = 1;         /* zap buffers next time we try to play  */         end;         port.dport#     (port# ) = dport#;     /* mark its buffer busy */         poly.buffs.in.use        = poly.buffs.in.use       + 1;         this.buf.in.use (dport#) = this.buf.in.use(dport#) + 1;         tape.state      (port# ) = tape.state     (port# ) + 1;         if block.skip (port#) = 0     /* if actually writing to disk,    */         then do;            track.eof(thistrack)=0;    /* reset eof to detect errors      */            /* also lock the poly that goes with the track where the      */            /* data is eventually going to be written.  Note that this    */            /* may be different than the dport# above in the case of      */            /* bouncing data from max track configurations                */            dport# = track.port.ix(thistrack);   /* get which port        */            this.buf.in.use (dport#) = this.buf.in.use(dport#) + 1;         end;      end;/*1*/ do;             /* read tape to perform copy */         nextcommand:;         if read.check.error<>0 then return;  /* handle possible tape switch at this point */         if verify.included(port#) <> 0       /* if verify info included, */         then i = verify.included(port#) - 1; /* use it's stream size     */         else i = get.stream.size(port#);     /* else use hardware limit  */                  if  (tape.copy.len.msb(port#)=0)     /* limit to end of block     */         and (tape.copy.len.lsb(port#) ilt i) /* at end of project         */         then i = tape.copy.len.lsb(port#);         if verify.included(port#) <> 0    /* now get total # of sectors   */         then i = i + 1;                   /* to read from tape            */         i = i - tape.read.len  (port#);   /* how many more to read        */         if i=0 then do; /* all read in         */            /* Check verify information here    */            if verify.included(port#) <> 0            then do;               tape.read.len(port#) = tape.read.len(port#) - 1; /* get # of sectors of actual user data */               if (skipverify = 0) /* skip the verify if we are manually   */               then do;            /* bouncing audio from more than 1 port */                  do j = 0 to tape.read.len(port#) - 1;                     call psmread(port.polyadd(port#)+j,0);                     k = verified.len(port#); /* get length handy    */                     write("303") = 0;        /* im(0) to r3         */                     rpc k;                     write("213") = read(psd);/* D(157) to ADD3      */                     k = read("303");         /* store in safe place */                     misc.buf(j) = k;                  end;                  call psmread(port.polyadd(port#)+tape.read.len(port#),0);                  k = 0;                  do j = 0 to tape.read.len(port#) - 1;                     if read(psd) <> misc.buf(j) then do;                        if numerrs < 200 then do;                           print 'Data Error';                           print 'Sector Base: ', tape.data.msb(port#), tape.data.lsb(port#);                           print '     Offset: ',j;                           numerrs = numerrs + 1;                        end;                        k = 1;                     end;                  end;                  if k <> 0 then do;                     if log.buf(0) = 0 then do;                        call Log.Error('Data Error has occurred with ');                        call append.tape.mes(port#);                     end;                     tape.verify.error = 1;                     command.fatal     = 1;                  end;               end;            end;            /* account here for user data transferred */            if tape.copy.len.lsb  (port#) ilt tape.read.len    (port#)            then tape.copy.len.msb(port#)  =  tape.copy.len.msb(port#)-1;            tape.copy.len.lsb     (port#)  =  tape.copy.len.lsb(port#)                                            -  tape.read.len    (port#);            tape.buf.len  (port#) = 0;            port.retry    (port#) = 0;            tape.state    (port#) = tape.state(port#)+2;            return;         end;			if (tape.type(port#) != type.jaz)		/* for real tapes			*/			{				if (i igt 16)                      	/* limit to 16 sectors */				then i = 16;			}			         tape.issue.len(port#) = i;         i=shr(i+15,4);                    /* 4096 WORD blocks, round up */         tape.pmem.add = port.polyadd(port#) + tape.read.len(port#);			if (tape.type(port#) == type.jaz)					/* if jaz drive		  */				issue.jaz.read.command(i);			     		  	/* then check eot	  */         else         	start.tape.command(port#,track#,Tape.Read,i);      end;/*2*/ do;             /* tape was successfully read */         tape.read.len(port#)=tape.read.len(port#) + tape.issue.len(port#);         tape.state(port#)=tape.state(port#)-1;          goto nextcommand;      end;/*3*/ do;             /* write disk to perform copy */         thistrack = port.thisdest(port#);      /* get destination track */         if  (block.skip(port#)   <>0)          /* if should skip data */         or  (track.eof(thistrack)<>0)          /* or end of disk      */         then do;            tape.state(port#)=tape.state(port#)+1;             return;         end;         i=thistrack*adir.len+220;         call gadir(i);         if (read(mdi)<>0)           /* see if adir is getting */         or (read(mdi)<>0)           /* full                   */         then do;            new.adir(thistrack)=2;   /* write anyways even though command */            return;                  /* is happening                      */         end;         if read.check.error<>0 then return;         i=tape.read.len(port#)-tape.buf.len(port#);  /* # of sectors left to write */         if i=0 then do;                   /* all written */            /* do accounting for song, track length */            /* compute max # of seconds */            bitmsb=tape.data.msb(port#);        /* get relative pointer to */            bitlsb=tape.data.lsb(port#);        /* dest sector             */            call ratio_multiply(256,50000);     /* get # of seconds       */            call unround;                       /* no rounding            */            if mul.llsb<>0                      /* but round up instead   */            then bitlsb=bitlsb+1;            i = gsong.dir(command.song*song.len+song.end  )  /* limit used to length of song since */              - gsong.dir(command.song*song.len+song.start); /* start.port.io did that for us      */            if bitlsb igt i then bitlsb = i;                 /* while we were recording            */            i=gsong.dir(command.song*song.len+song.used);            if bitlsb igt i then do;            /* song is longer now     */               write(md)=bitlsb;               command.song.dir.updated=1;            end;            i=gsong.dir(command.song*song.len+song.status);            if (i&1)=0 then do;                 /* song was empty         */               write(md)=i\1;               command.song.dir.updated=1;            end;            i=alt.tdir(thistrack*track.len+track.used);            if bitlsb igt i then do;            /* track is longer now    */               alt.tdir(thistrack*track.len+track.used)=bitlsb;               alt.tdir.updated=1;            end;            if (song.base+dtd.song#)=command.song  /* if this is current proj */            then do;               call blockmove(location(addr(alt.tdir (thistrack*track.len))),                              location(addr(track.dir(thistrack*track.len))),                              8);    /* get name again */               track.dir (thistrack*track.len + track.used)  /* and used */               = alt.tdir(thistrack*track.len + track.used); /* field    */            end;            tape.state(port#) = tape.state(port#)+1;            return;         end;         /* write to disk */         j=tape.data.msb(port#);           /* get relative pointer to */         k=tape.data.lsb(port#);           /* dest sector             */         if  ((j igt c.len.msb))           /* writing after end of    */         or  ((j  =  c.len.msb)            /* song                    */         and  (k ige c.len.lsb))         then do;            tape.state(port#)=tape.state(port#)+1;             return;         end;         k=k+i;                            /* get ending sector #     */         if k ilt i then j=j+1;         if  ((j igt c.len.msb))           /* writing after end of    */         or  ((j  =  c.len.msb)            /* song                    */         and  (k igt c.len.lsb))         then do;            i=c.len.lsb-tape.data.lsb(port#);         end;         j=tape.data.msb(port#);           /* get relative pointer to */         k=tape.data.lsb(port#);           /* dest sector             */         j=j+c.data.msb;                   /* compute absolute sector  */         k=k+c.data.lsb;                   /* relative to command song */         if k ilt c.data.lsb         then j=j+1;         /* Check here for writing data to a different port than the   */         /* one we are talking about here.  This happens when reading  */         /* max trax tapes onto 2-track configs, plus reading aux      */         /* tapes using systems without an aux drive.                  */         dport# = track.port.ix(thistrack);         if dport# <> tport# then do;   /* means bouncing data         */            /* Unhang the wait state we are probably sitting in        */            /* while we are trying to poll the user for a tape         */            if   (port.io(dport#) = Tape.Wait)            or   (port.io(dport#) = Tape.Park)            then  port.io(dport#) = 0;            /* check for someone putting a tape in here after          */            /* we had started to bounce some data!!                    */            if (tape.condition(dport#) & (t1.cond.rdy\t2.cond.rdy)) <> 0            then do;               tape.state(port#)=tape.state(port#)+1;                return;            end;            if port.io(dport#)<>0       /* if disk port is busy, hang  */            then return;                /* out.  Happings because of   */                                        /* occasional tape inq         */                                        /* commands.                   */         end;         port.io          (dport#) = 3;         /* write desired       */         port.io.track#   (dport#) = thistrack; /* this track #        */         port.io.dtrack#  (dport#) = thistrack; /* this track #        */         port.io.len#     (dport#) = i;         /* for this len        */         port.secmsb      (dport#) = j;         port.seclsb      (dport#) = k;         port.pmemsec     (dport#) = port.polyadd(port#) + tape.buf.len(port#);         if dport# = port.dport#(port#)         /* if disk and data port */         then port.pmemwrd(dport#) = ( 0);      /* are the same, then    */         else port.pmemwrd(dport#) = (-1);      /* use DMA; else don't   */         port.update      (dport#) = 2;         /* update on complete    */         port.upcode      (dport#) = port#;     /* update info           */         call issue.port.command(dport#,0);         if port.io(dport#)<>3 then do;        /* could not start command */            port.retry(port#)=port.retry(port#)+1;         end;         else if port# <> dport#               /* park this port on hold  */         then do;                              /* until the disk command  */            port.io   (port#) = Tape.Park;     /* completes               */            port.timer(port#) = dport#;         end;      end;      /* $page - disk was successfully written to *//*4*/ do;             /* data was written to disk */         thistrack = port.thisdest(port#);      /* get poss dest track  */         dport#    = port.dport#  (port#);      /* get actual port used */         poly.buffs.in.use        = poly.buffs.in.use       - 1;         this.buf.in.use (dport#) = this.buf.in.use(dport#) - 1;         /* Also unlock the poly buffer for where the data was          */         /* actually written to:                                        */         if block.skip (port#) = 0     /* if actually writing to disk,    */         then do;            dport# = track.port.ix(thistrack);   /* get which port        */            this.buf.in.use (dport#) = this.buf.in.use(dport#) - 1;         end;         /* account here in case some data */         /* was not written                */         i=tape.read.len(port#)-tape.buf.len(port#);  /* # of sectors left to write */         tape.data.lsb(port#)=tape.data.lsb(port#)+i;         if tape.data.lsb(port#) ilt i         then tape.data.msb(port#)=tape.data.msb(port#)+1;         /* check here for abort desired */         if abort.command<>0         /* bombed out on other track */         then do;            command.aborted=1;            tape.state(port#) = load.abort.state;         end;         /* see if more to copy */         else if (tape.copy.len.msb(port#)<>0)    /* more sectors to */         or      (tape.copy.len.lsb(port#)<>0)    /* copy in this    */         then do;                                 /* block           */            tape.read.len    (port#)=0;            port.retry       (port#)=0;            tape.state(port#)=tape.state(port#)-4;         end;         else do;  /* not abort; done with block */            if (song.base+dtd.song#)=command.song            then do;               /* copy name and used field to track directory */               /* for anxious user                            */               call blockmove(location(addr(alt.tdir (thistrack*track.len))),                              location(addr(track.dir(thistrack*track.len))),                              8);    /* get name again */               track.dir (thistrack*track.len + track.used)  /* and used */               = alt.tdir(thistrack*track.len + track.used); /* field    */            end;            port.retry(port#)=0;                     /* read next block  */            tape.state(port#)=load.process.next.chunk.state;         end;      end;   end;end load.song;end;    /* of variable localization for load.song */