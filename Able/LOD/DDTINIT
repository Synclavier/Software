/* DDTINIT - initialization routines for DDT unit(s) *//*  08/14/91 - cj  - Added UDIO/DDSYN stuff  06/02/89 - JSS - Delays w/D16, not Real.Milliseconds; SDIF M output bug.  04/14/89 - JSS - Computes correct AES/EBU Channel Status Data CRCC byte  04/11/89 - JSS - Fixed ext sync bugs, added S/PDIF Channel Status Data,                   added clear of SDIF emphasis bits, added ProDigi Multi                   ext sync option.  03/22/89 - JSS - support for AES (Rev 1)  02/23/89 - JSS - support for SDIF format*//* load.configuration  *//*------------------------------------------------------------------------------| PROCEDURE: load.configuration|   Loads the Xilinx chip (Logic Cell Array) with a desired circuit|   configuration from the serial PROM containing the configuration info.| METHOD: Obscure; see Xilinx product info and UDIO schematic.| PARAMETERS: config - the number of the configuration desired (0-8).|   There is a configuration for each serial format & direction.+-----------------------------------------------------------------------------*/load.configuration: proc (config) swapable;   dcl config fixed;  /* Number of Xilinx configuration to load (0-8) */   dcl i      fixed;  /* Counts configs as they're loaded sequentially */   dcl delay  fixed;  /* Used for delay with D16 */   call DDT.Connect(DDT.Connect.Mode);   /* (Sets dir bit to setup hardware for configuration) */   write (ScsiByte) = FE_Loc_Ad_Next \ FE_dir_in;   write (ScsiByte) = LAD_UDIO_Bus_Control \ FE_loc_Ad_Next \ LAD_write;   write (SCSIword) = "H0E00";                /* Turn off clocks         */   write (SCSIbyte) = LAD_IO_Control \ FE_Loc_Ad_Next;   /* Setup and... */   write (SCSIbyte) = "HD0";                  /* Enable PROM chip enable */   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   write (SCSIbyte) = 0;   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   write (SCSIbyte) = 6;   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   write (SCSIbyte) = 2;                       /* Reset Xilinx chip      */   /* Wait > 11us */   delay = read (d16);                        /* Setup to wait */   do while (read (d16) <= (delay+3)); end;   /* 3 10us ticks  */   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   write (SCSIbyte) = 3;                       /* (normal state)   */   /* Wait 35ms for powerup dummy load */   delay = read (d16);                          /* Setup to wait   */   do while (read (d16) <= (delay+3500)); end;  /* 3500 10us ticks */   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   /* Setup and... */   write (SCSIbyte) = 7;                      /* Reset configuration PROM */   write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;   write (SCSIbyte) = 3;                      /* (normal state)           */   /* Loop loading configurations, stop after the one we want */   do i = 0 to config;      write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next; /* Setup and... */      write (SCSIbyte) = 1;                   /* Start load of next config */      /* print '*',; */      /* Wait > 60us */      delay = read (d16);                        /* Setup to wait */      do while (read (d16) <= (delay+7)); end;   /* 7 10us ticks  */      write (SCSIbyte) = LAD_LCA_Control \ FE_Loc_Ad_Next;      write (SCSIbyte) = 3;                      /* (normal state) */      /* Wait 35ms for LCA load */      delay = read (d16);                          /* Setup to wait   */      do while (read (d16) <= (delay+3500)); end;  /* 3500 10us ticks */   end;   /* Clear pending Local Address Byte request to free SCSI */   write (SCSIbyte) = LAD_Revision_# \ LAD_Read;   i = read (SCSIbyte);              /* dummy read of rev # */end load.configuration;/* $subtitle  initialize_subcode  *//*------------------------------------------------------------------------------| PROCEDURE: initialize_subcode|   This procedure initializes what we are calling the "subcode" for AES/EBU|   and SDIF Out formats.  The "subcode" is any information that is|   transmitted on the serial line other than the raw audio data.  In the|   AES/EBU & S/PDIF cases, this includes the Channel Status Data, User Data,|   and Validity bits.  In SDIF it is the Emphasis Identification and Dubbing|   Prohibition (copy protect) bits.  (Note that the Dubbing Prohibition bit|   is cleared in the hardware (to allow dubbing); this procedure does not|   deal with it.)  This proc sets these subcode data like so:||   - AES/EBU User Data:  All zeros (unused)|   - AES/EBU Channel Status Data:|       Byte Data     Comment|       0    YYX00001 Bit 0: indicates Pro use (not consumer)|                     Bit 1: Normal audio mode|                     Bit 2-4: Emphasis not indicated|                     Bit 5-7 (YYX): If the sample_rate is 32, 44.1, or 48|                       kHz, then the YY bits are set to 11, 01, & 10 res-|                       pectively, and the X bit is 0 indicating source|                       sampling frequency locked.  If the sample_rate is|                       anything else, then YY is 00 (sampling frequency|                       not indicated) and X is 1 (source sampling frequency|                       unlocked).  This is the way that Sony does it.|       1    00000000 Encoded Channel Mode not indicated.|       2-21 00000000 Unused.|       22   00000000 This info does not conform to AES spec but Sony RDAT|                     doesn't work with "correct" info (11100000).|       23   CRCC     CRCC (Cyclic Redundancy Check Code) depends on data|                       above.|   - AES/EBU Validiy bits:  Set to 00 indicating data is valid.|   - S/PDIF Channel Status Data:|       Byte Data     Comment|       0    00000100 Consumer, Audio mode, Copy enabled, No emphasis|       1    00000000 "General" device type|   - SDIF Emphasis Identification:  Set to 00 indicating emphasis not used.| METHOD:|   Writes the subcode RAM to indicate the Channel Status Data and User Data|   information shown above.  Writes the LCA Pin 55 register to set the|   Validity and Emphasis bits.  Various other register writes are performed|   in order to set up the UDIO for these operations.  (See the document|   "Programming the UDIO".)| NOTE: Assumes that LCA configuration appropriate to format (AES/EBU or|   SDIF) is loaded.  Also, the value of the UDIO Bus Control register is|   wiped out in order to stop word clocks when setting the Validity bits|   in AES/EBU.  These two notes imply that this procedure must be called|   after the loading of the LCA configuration but before the initialization|   of the UDIO registers.+-----------------------------------------------------------------------------*/dcl out_byte  fixed;initialize_subcode: proc (format, sample_rate) swapable;   dcl format       fixed; /* Serial data format (e.g. AES/EBU, SDIF, etc.) */   dcl sample_rate  fixed; /* Sample rate in kHz X 10 (i.e. 44.1 kHz = 441) */   dcl delay        fixed; /* Used for delays */   dcl i            fixed; /* Counts through subcode RAM locations */   dcl byte_0_data  fixed; /* Channel Status Data byte 0  */   dcl byte_1_data  fixed; /* Channel Status Data byte 1  */   dcl byte_22_data fixed; /* Channel Status Data byte 22 */   dcl CRCC_data    fixed; /* Channel Status Data CRCC byte (byte 23) */   dcl word_clock_ctr_value fixed; /* Used to test if getting word clocks */   /****************  LOCAL PROCEDURE  ******************/   /*------------------------------------------------------------------------------   | LOCAL PROCEDURE: write_one_subcode_byte   |   Writes one byte of Channel Status Data into the subcode RAM,   |   formatting the bits properly.   | PARAMETERS: byte - Channel Status Data byte to write into RAM.   |   subcode_addr   - Address in subcode RAM at which to start placing   |                    the byte.  Each Data byte is spread across 4   |                    subcode RAM bytes.   | NOTE ON COMMENTS: Regarding inline comments of the form "CAx" and "CBx":    |   "C" refers to the Channel Status bits (as opposed to User Data bits),   |   "A" & "B" refer the channel of the info, "x" refers to the bit number   |   of the Channel Status Data being written.   +-----------------------------------------------------------------------------*/   write_one_subcode_byte: proc (byte, subcode_addr);      dcl byte          fixed;  /* Entered data byte to write */      dcl subcode_addr  fixed;  /* Subcode RAM address to start at */      /* Subcode RAM byte 0 (takes bits 0 & 1 of subcode data) */      call Write.Selected.DDT.Byte (LAD_AES_RAM_Ptr, subcode_addr); /* Write address */      call Write.Selected.DDT.Byte (LAD_AES_RAM_data,         (shl ((1 & byte), 2) \   /* CA0 */          shl ((1 & byte), 3) \   /* CB0 */          shl ((2 & byte), 5) \   /* CA1 */          shl ((2 & byte), 6)));  /* CB1 */      /* Subcode RAM byte 1 (takes bits 2 & 3 of subcode data) */      call Write.Selected.DDT.Byte (LAD_AES_RAM_Ptr, subcode_addr + 1); /* Write address */      call Write.Selected.DDT.Byte (LAD_AES_RAM_data,         (shl ((4 & byte), 0) \   /* CA2 */          shl ((4 & byte), 1) \   /* CB2 */          shl ((8 & byte), 3) \   /* CA3 */          shl ((8 & byte), 4)));  /* CB3 */      /* Subcode RAM byte 2 (takes bits 4 & 5 of subcode data) */      call Write.Selected.DDT.Byte (LAD_AES_RAM_Ptr, subcode_addr + 2); /* Write address */      call Write.Selected.DDT.Byte (LAD_AES_RAM_data,         (shr (("H10" & byte), 2) \   /* CA4 */          shr (("H10" & byte), 1) \   /* CB4 */          shl (("H20" & byte), 1) \   /* CA5 */          shl (("H20" & byte), 2)));  /* CB5 */      /* Subcode RAM byte 3 (takes bits 6 & 7 of subcode data) */      call Write.Selected.DDT.Byte (LAD_AES_RAM_Ptr, subcode_addr + 3); /* Write address */      call Write.Selected.DDT.Byte (LAD_AES_RAM_data,         (shr (("H40" & byte), 4) \   /* CA6 */          shr (("H40" & byte), 3) \   /* CB6 */          shr (("H80" & byte), 1) \   /* CA7 */          shr (("H80" & byte), 0)));  /* CB7 */   end write_one_subcode_byte;   /* $subtitle  compute_CRCC function  */   /*------------------------------------------------------------------------------   | LOCAL FUNCTION: compute_CRCC   |   Computes the CRCC byte from the Channel Status Data passed in.  All   |   other data bytes (not passes) are assumed to be zero.   | METHOD: Performs the CRCC algorithm of the AES/EBU specification:   |   G(x) = X^8 + X^4 + X^3 + X^2 + 1   | PARAMETERS: Nonzero Channel Status Data bytes   | RETURNS: CRCC byte computed from data passed in   +-----------------------------------------------------------------------------*/   compute_CRCC: proc (byte_0_data, byte_1_data, byte_22_data) returns (fixed);      dcl byte_0_data  fixed; /* Channel Status Data byte 0  */      dcl byte_1_data  fixed; /* Channel Status Data byte 1  */      dcl byte_22_data fixed; /* Channel Status Data byte 22 */      dcl i         fixed;      /*------------------------------------------------------------------------------      | LOCAL PROC: do_one_byte performs the CRCC encryption for one byte      |   of Channel Status Data.  This proc is called 23 times for 23      |   bytes of data.  The result is "accumulated" into out_byte       |   during each call.      | NOTE: out_byte is defined at the level of compute_CRCC and thus is      |   preserved from one call of do_one_byte to the next.      +-----------------------------------------------------------------------------*/      do_one_byte: proc (in_byte);         dcl in_byte fixed;  /* One Channel Status Data byte to encode */         dcl i    fixed; /* Counts through bits */         dcl temp fixed; /* First XOR gate result (input bit XOR output bit 0) */         do i = 0 to 7;  /* For each bit in the byte */            temp = ((in_byte XOR out_byte) & 1);            if temp = 1            then temp = "HFF";  /* Fill all bits with ones */            out_byte = ("H47" & shr (out_byte, 1))         /* non-XORed bits */                     \ (temp & "H80")                          /* into bit 7 */                     \ ((shr (out_byte, 1) XOR temp) & "H20")  /* into bit 5 */                     \ ((shr (out_byte, 1) XOR temp) & "H10")  /* into bit 4 */                     \ ((shr (out_byte, 1) XOR temp) & "H08"); /* into bit 3 */            in_byte = shr (in_byte, 1);        /* Get next input bit */         end;  /* for each bit in the byte */      end do_one_byte;      out_byte = "H00FF";   /* initialize output */      /* Encode Channel Status Data bytes 0 to 22 into the CRCC byte */      call do_one_byte (byte_0_data);  /* encode Channel Status Data byte 0 */      call do_one_byte (byte_1_data);  /* encode Channel Status Data byte 1 */      /* Encode most Channel Status Data bytes (as zero) */      do i = 2 to 21;           call do_one_byte (0);         /* bytes 1-21 are all zero */      end;      call do_one_byte (byte_22_data);  /* encode Channel Status Data byte 22    */      /* LSB of "out_byte" now contains the CRCC */      return (out_byte);   end compute_CRCC;   /* $subtitle  initialize_subcode body  ***************/   /* Initialize subcode data for format in use */   if (format = SDIF_2_20bit) or (format = SDIF_2_16bit)  /* SDIF case */   then do;  /* Initialize SDIF Emphasis bits */      /* Setup to write Emphasis bits */      call Write.Selected.DDT.Byte (LAD_LCA_pin_49, 0); /* Clear Pin 49 Bit */      /* Clear the Emphasis bits to indicate no emphasis */      call Write.Selected.DDT.Byte (LAD_LCA_pin_55, 0); /* Clear Emphasis bits */   end; /* SDIF case */   else if (format = AES_16bit) or (format = AES_24bit) /* AES/EBU or */   or      (format = SPDIF)                             /* S/PDIF     */   then do;   /* Init AES/EBU Channel Status & User Data, & Validity bits */      /* Setup for access of subcode RAM */      /* Check if word clock is running */      /* Get word clock counter value   */      word_clock_ctr_value = Read.Selected.DDT.Register (LAD_FE_word_clock);      /* Wait for at least one word clock period (for counter to change) */      /* Wait > 100us */      delay = read (d16);                         /* Setup to wait */      do while (read (d16) <= (delay+10)); end;   /* 10 10us ticks */      /* Reset LCA if word clock counter indicates no word clocks */      /* (if Word Clock Counter hasn't changed value).            */      if word_clock_ctr_value = Read.Selected.DDT.Register (LAD_FE_word_clock)      then do;  /* If counter value hasn't changed */         /* Reset LCA */         call Write.Selected.DDT.Byte (LAD_LCA_Control, 2); /* Reset LCA */         call Write.Selected.DDT.Byte (LAD_LCA_Control, 3); /* Normalize LCA */      end;      /* Setup for subcode read */      call Write.Selected.DDT.Byte (LAD_LCA_pin_49, 1); /* Set Pin 49 Bit */      /* Wait for at least two "blocks" of Channel Status Data go by     */      /* to allow Pin 49 Bit to take effect and freeze the subcode data. */      /* Wait 12ms (2 x 192 sample periods @ 32 kHz)                     */      delay = read (d16);                          /* Setup to wait   */      do while (read (d16) <= (delay+1200)); end;  /* 1200 10us ticks */      /* Done setting up for subcode RAM access */      /* Zero out subcode RAM prior to setting certain bytes */      do i = 0 to "H7F";         call Write.Selected.DDT.Byte (LAD_AES_RAM_Ptr, i);  /* Write address */         call Write.Selected.DDT.Byte (LAD_AES_RAM_data, 0); /* Clear one byte */      end;      /* Get data to write to subcode RAM depending on AES/EBU or S/PDIF */      if format = SPDIF then do;  /* Setup Channel Status Data for S/PDIF */         byte_0_data = "H04";  /* Consumer, Audio mode, Copy enable, No emphasis */         byte_1_data = "H00";  /* "General" source */         /* There is no CRCC or byte 22 in S/PDIF so make them 0 */         byte_22_data = 0;         CRCC_data = 0;      end;      else do;  /* Setup Channel Status Data for AES/EBU */         /* Compute byte 0 of Channel Status Data depending on sample rate */         if sample_rate = 320 then byte_0_data = "HC1";      /* indicate 32 kHz */         else if sample_rate = 441 then byte_0_data = "H41"; /* indicate 44.1 kHz */         else if sample_rate = 480 then byte_0_data = "H81"; /* indicate 48 kHz */         else byte_0_data = "H21";   /* SR not indicated & not locked */         byte_1_data = 0;   /* Byte 1 is zero */         /* Byte 22 according to AES/EBU spec should be "HE0" which    */         /* indicates byte 0-5 reliable, 6-21 unreliable but Sony RDAT */         /* may choke on this.  Works with 00 though so that's what    */         /* we're using.                                               */         byte_22_data = 0;         /* Compute the CRCC byte based on the Channel Status Data */         CRCC_data = compute_CRCC (byte_0_data, byte_1_data, byte_22_data);      end;      /* Write Channel Status Data into subcode RAM */      call write_one_subcode_byte (byte_0_data,  "H20"); /* Byte 0  */      call write_one_subcode_byte (byte_1_data,  "H24"); /* Byte 1  */      call write_one_subcode_byte (byte_22_data, "H78"); /* Byte 22 */      call write_one_subcode_byte (CRCC_data,    "H7C"); /* CRCC byte */      /* Setup to write Validity bits */      /* Stop clocks w/UDIO Bus Control word */      call Write.Selected.DDT.Register (LAD_UDIO_Bus_Control, "H0E00");      /* Reset LCA */      call Write.Selected.DDT.Byte (LAD_LCA_Control, 2); /* Reset LCA */      call Write.Selected.DDT.Byte (LAD_LCA_Control, 3); /* Normalize LCA */      call Write.Selected.DDT.Byte (LAD_LCA_pin_49, 0);  /* Clear Pin 49 Bit */      /* Wait 12ms (2 192 sample blocks @ 32 kHz) */      delay = read (d16);                          /* Setup to wait   */      do while (read (d16) <= (delay+1200)); end;  /* 1200 10us ticks */      /* Clear the Validity bits */      call Write.Selected.DDT.Byte (LAD_LCA_pin_55, 0); /* Clear Validity bits */   end;  /* Init AES/EBU Channel Status & User Data, & Validity bits */end initialize_subcode;/* $subtitle  initialize.universal.DDT  *//*------------------------------------------------------------------------------| PROCEDURE: initialize.universal.DDT|     This proc initializes a single UDIO unit for transfers based upon the|   information passed in.  Loads the Xilinx LCA chip configuration and|   writes appropriate data to various registers to set up for transfers with|   a given direction, serial format, sample rate, synchronisation source,|   Group number, Go Master unit, System Clock Master unit, & Group Master|   unit.|      Loads the appropriate LCA chip configuration by calling the proc|   "load.configuration".  Writes the appropriate data to the UDIO|   registers at local address locations H12, H14, H1E, H17, & H1F.|      Called by initialize.DDT.unit below.| METHOD: Creates vars corresponding to each of the 5 UDIO registers that|   require setup.  Makes several "passes" through those vars using the|   information passed in to make decisions about how various bit fields|   w/in the register vars should be set up.  Sometimes it is most convenient|   to use bit fields that have already been set up (w/in this proc) to help|   decide how to set up something else.  During each pass, new bits are|   ANDed and ORed into the register vars.  Sometimes register vars are|   simply rewritten (e.g. divider_control_A/B_data).  For these reasons,|   observe caution when modifying this routine to prevent side effects.|   Once all the register vars have been set up, the LCA configuration is|   first loaded, then each of the 5 registers is written with the data|   from its corresponding variable.| MODIFIED:|   3/17/89 JSS  Added "subcode" init in Out direction for AES/EBU, S/PDIF,|     & SDIF.  Fixed potential bug in PLL Control reg data.|   4/06/89 JSS  Fixed Output Sync source bugs & others.|   6/02/89 JSS  Fixed SDIF M output enable bug+-----------------------------------------------------------------------------*/initialize.universal.DDT: proc (direction, format, sample_rate, sync_source,                               group_info, go_master, system_clock_master)                               SWAPABLE;   dcl direction    fixed; /* A literal indicating direction to setup for */   dcl format       fixed; /* Serial xfer format literal (e.g. AES_16bit) */   dcl sample_rate  fixed; /* The Sample Rate in Khz*10 (e.g. 48 Khz = 480) */   dcl sync_source  fixed; /* Literal indicating synchronization source (e.g. House sync, Internal) */   dcl group_info   fixed; /* Number (0-3) of UDIO group this unit is in in MSB.  LSB = 1 if Group Master unit, 0 otherwise. */   dcl go_master           boolean; /* Is this board the Go Master unit? */   dcl system_clock_master boolean; /* Is this board the System Clock Master unit? */   /* Vars to hold data to be written to Loc Addr regs in UDIO */   dcl UDIO_bus_control_data  fixed;   dcl divider_control_A_data fixed;   dcl divider_control_B_data fixed;   dcl PLL_control_data       fixed;   dcl IO_control_data        fixed;   dcl configuration_number   fixed; /* LCA configuration # (not a reg) */   /* Initialize register data vars to zero */   UDIO_bus_control_data  = 0;   divider_control_A_data = 0;   divider_control_B_data = 0;   PLL_control_data       = 0;   IO_control_data        = 0;   configuration_number   = 0;   /* Setup register data vars based on SAMPLE RATE.                    */   /* (The divider_control_A/B_data is setup on the assumption that the */   /*  sync_source is one of the input format word clocks.  If the      */   /*  sync_source is actually House Sync or an internal clock, then    */   /*  these values will be overwritten later.)                         */   /* (Note that the PLL Crystal bits (8-9) of the PLL_control_data set */   /*  here are used below to help setup the divider_control_A/B_data.) */   if (sample_rate = 319) then do;      divider_control_A_data = divider_control_A_data \ "HFD00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0300";   end;   else if (sample_rate = 320) then do;      divider_control_A_data = divider_control_A_data \ "HFD00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0200";   end;   else if (sample_rate = 440) then do;      divider_control_A_data = divider_control_A_data \ "HFE00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0140";   end;   else if (sample_rate = 441) then do;      divider_control_A_data = divider_control_A_data \ "HFE00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0040";   end;   else if (sample_rate = 479) then do;      divider_control_A_data = divider_control_A_data \ "HFE00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0340";   end;   else if (sample_rate = 480) then do;      divider_control_A_data = divider_control_A_data \ "HFE00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0240";   end;   else if (sample_rate = 881) then do;      divider_control_A_data = divider_control_A_data \ "HFF00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0180";   end;   else if (sample_rate = 882) then do;      divider_control_A_data = divider_control_A_data \ "HFF00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0080";   end;   else if (sample_rate = 959) then do;      divider_control_A_data = divider_control_A_data \ "HFF00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0380";   end;   else if (sample_rate = 960) then do;      divider_control_A_data = divider_control_A_data \ "HFF00";      divider_control_B_data = divider_control_B_data \ "H1F";      PLL_control_data       = PLL_control_data \ "H0280";   end;   /* Setup some register data vars and the LCA configuration number  */   /* based on the FORMAT, DIRECTION, and GROUP MASTER (see below.)   */   /* (Sets Group Clock Drive bit in UDIO Bus Control reg in certain  */   /*  formats/directions if we're the GROUP MASTER.)                 */   /* (Sets up PLL Loop Filter and PLL Reference Clock Select bits    */   /*  in PLL_Control_data based on format in Input direction.        */   /*  If sync source is House Sync, an Internal Clock, or an         */   /*  external source (always true for Output dir), then these bits  */   /*  are overwritten below in the code that depends on SYNC SOURCE  */   /*  and SAMPLE RATE.)                                              */   if (format = ProDigi_2) then      if (direction = FE_Dir_In)      then do;         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0000";         PLL_control_data       = PLL_control_data \ "H1011";         IO_control_data        = IO_control_data \ "HF1";         configuration_number = 0;      end;      else do;   /* ProDigi 2, dir out */         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0900";         IO_control_data        = IO_control_data \ "HD0";         configuration_number = 1;      end;   else if (format = ProDigi_M) then do;      if (direction = FE_Dir_In)      then do;         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0D03";         PLL_control_data       = PLL_control_data \ "H1011";         IO_control_data        = IO_control_data \ "HF5";         configuration_number = 2;      end;      else do;   /* ProDigi M dir out */         UDIO_bus_control_data  = UDIO_bus_control_data \ "H1A01";         IO_control_data        = IO_control_data \ "HB0";         configuration_number = 3;      end;      if group_info    /* Set Group Clock Drive bit if Group Master */      then UDIO_bus_control_data = UDIO_bus_control_data \ "H0004";   end;   else if (format = SDIF_2_20bit) or (format = SDIF_2_16bit) then      if (direction = FE_Dir_In)      then do;         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0F00";         PLL_control_data       = PLL_control_data \ "H1012";         IO_control_data        = IO_control_data \ "HF2";         configuration_number = 4;      end;      else do;   /* direction = out */         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0B02";         IO_control_data        = IO_control_data \ "H70";         configuration_number = 5;         if group_info    /* Set Group Clock Drive bit if Group Master */         then UDIO_bus_control_data = UDIO_bus_control_data \ "H0004";      end;   else if (format = SDIF_M_20bit) or (format = SDIF_M_16bit) then      if (direction = FE_Dir_In)      then do;         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0F00";         PLL_control_data       = PLL_control_data \ "H1012";         IO_control_data        = IO_control_data \ "HF5";         configuration_number = 4;      end;      else do;   /* direction = out */         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0B02";         IO_control_data        = IO_control_data \ "H30";         configuration_number = 5;         if group_info    /* Set Group Clock Drive bit if Group Master */         then UDIO_bus_control_data = UDIO_bus_control_data \ "H0004";      end;   else if (format = AES_16bit) or (format = AES_24bit)   or      (format = SPDIF) then      if (direction = FE_Dir_In)      then do;         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0C00";         PLL_control_data       = PLL_control_data \ "H1000";         IO_control_data        = IO_control_data \ "HF0";         configuration_number = 6;      end;      else do;   /* direction = out */         UDIO_bus_control_data  = UDIO_bus_control_data \ "H0800";         IO_control_data        = IO_control_data \ "HE0";         configuration_number = 7;         if group_info    /* Set Group Clock Drive bit if Group Master */         then UDIO_bus_control_data = UDIO_bus_control_data \ "H0004";      end;   /* Sets up PLL Reference Clock Select bits (bits 0-2), PLL Loop     */   /* Filter bits (bits 12-14), & PLL Variable Clock Select bits (4-5) */   /* the PLL Control reg based on SYNC SOURCE and SAMPLE RATE when    */   /* the direction is OUTPUT.                                         */   /* (For direction INPUT, these bits have already                    */   /*  been setup in the code that depends on FORMAT and DIRECTION.    */   /* (Note that bits 0-2 set here are used below to help setup the    */   /*  divider_control_A/B_data.)                                      */   if (direction <> FE_dir_in) then do;   /* for output direction only */      /* House Sync */      if (sync_source = house_sync_25)      or (sync_source = house_sync_29)      or (sync_source = house_sync_30)      then PLL_control_data = PLL_control_data \ "H2013";      /* Internal clock Sync */      else if (sync_source = internal_sync) then do;         if (sample_rate = 320)         or (sample_rate = 480)         or (sample_rate = 960)         then PLL_control_data = PLL_control_data \ "H3014";         else if (sample_rate = 441)         or (sample_rate = 882)         then PLL_control_data = PLL_control_data \ "H3015";         else if (sample_rate = 440)         or (sample_rate = 881)         then PLL_control_data = PLL_control_data \ "H3016";         else do;            /* Note that Internal clocks of 31.97, 47.95 & 95.90 Khz    */            /* should not be desired and are not supported in hardware, */            /* so set up for 32, 48, or 96                              */            PLL_control_data = PLL_control_data \ "H3014";         end;      end; /* Internal sync */      /* AES/EBU signal derived input sync */      else if (sync_source = AES_in_sync) then do;         PLL_control_data = PLL_control_data \ "H1000";      end;      /* ProDigi 2-track word clock input sync */      else if (sync_source = ProDigi_2_in_sync) then do;         PLL_control_data = PLL_control_data \ "H1011";         IO_control_data  = IO_control_data  \ "H01";      end;      /* ProDigi Multitrack word clock input sync */      else if (sync_source = ProDigi_M_in_sync) then do;         PLL_control_data = PLL_control_data \ "H1011";         IO_control_data  = IO_control_data  \ "H05";      end;      /* SDIF word clock input sync */      else if (sync_source = SDIF_in_sync) then do;         PLL_control_data = PLL_control_data \ "H1012";         IO_control_data  = IO_control_data  \ "H02";      end;   end; /* direction OUT */   /* Setup Go Bus Input Line and Word Clock Ouput Line in UDIO Bus  */   /* Control register based on the GROUP NUMBER.                    */   UDIO_bus_control_data = UDIO_bus_control_data \   /* Put Group Number */      shl (group_info & "H0300", 6) \                /* in bits 14-15    */      shr (group_info & "H0300", 4);                 /* and bits 4-5.    */   /* Set System Clock Drive bit if we're the SYSTEM CLOCK MASTER. */   if system_clock_master   then UDIO_bus_control_data = UDIO_bus_control_data \ "H0008";   /* Set Go Bus Drive bit if we're the GO MASTER. */   if go_master   then UDIO_bus_control_data = UDIO_bus_control_data \ "H0080";   /* Set Word Clock Drive bit if we're a GROUP MASTER.            */   /* (The Group Clock Drive bit in the UDIO Bus Control reg gets  */   /*  set for appropriate format/directions in the code which     */   /*  depends on FORMAT and DIRECTION.)                           */   if group_info   then UDIO_bus_control_data = UDIO_bus_control_data \ "H0040";   /* Setup the 20-bit Divider (regs: 20-bit Divider Control A & B) */   /* based on the SYNC SOURCE and SAMPLE RATE.                     */   /* (The PLL Reference Clock Select bits (bits 0-2) in the        */   /*  PLL_Control_data which were previously set up are used to    */   /*  select amoung the various sync source cases.)                */   /* (The PLL Crystal bits (bits 8-9) in the PLL_Control_data,     */   /*  which were previously set up, are used to select amoung      */   /*  sample rates in the House Sync case.)                        */   if ((PLL_control_data & 7) <= 2) then do;      /* External Sync case */      /* Don't do anything; divider values were already setup for */      /* this case in the code that depends on the SAMPLE RATE.   */   end;   else if ((PLL_control_data & 7) = 3) then do;  /* House Sync case */      /* Determine 20-bit Divider values based on HOUSE SYNC FREQUENCY */      /* and the PLL CRYSTAL bits (the PLL Crystal bits are in the PLL */      /* Clock Control data and were previously setup in the code      */      /* depending on SAMPLE RATE.)                                    */      if (sync_source = house_sync_25) then do;          /* HS = 25 Hz */         do case (shr (PLL_control_data, 8) & "H0003");  /* Branch on PLL Xtal */            do;  /* 44.1 / 88.2 */               divider_control_A_data = "H3800";               divider_control_B_data = "H12";            end;            do;  /* 44.056 / 88.112 */               divider_control_A_data = "H3B86";               divider_control_B_data = "H12";            end;            do;  /* 32 / 48 / 96 */               divider_control_A_data = "H0000";               divider_control_B_data = "H11";            end;            do;  /* 31.97 / 47.95 / 95.90 */               divider_control_A_data = "H03D6";               divider_control_B_data = "H11";            end;         end; /* House Sync = 25 Hz case */      end;      else if (sync_source = house_sync_29) then do;   /* HS = 29.97 Hz */         do case (shr (PLL_control_data, 8) & "H0003");/* Branch on PLL Xtal */            do;  /* 44.1 / 88.2 */               divider_control_A_data = "H810F";               divider_control_B_data = "H14";            end;            do;  /* 44.056 / 88.112 */               divider_control_A_data = "H8400";               divider_control_B_data = "H14";            end;            do;  /* 32 / 48 / 96 */               divider_control_A_data = "H7CCD";               divider_control_B_data = "H13";            end;            do;  /* 31.97 / 47.95 / 95.90 */               divider_control_A_data = "H8000";               divider_control_B_data = "H13";            end;         end; /* House Sync = 29.97 Hz case */      end;      else if (sync_source = house_sync_30) then do;    /* HS = 30 Hz */         do case (shr (PLL_control_data, 8) & "H0003"); /* Branch on PLL Xtal */            do;  /* 44.1 / 88.2 */               divider_control_A_data = "H8400";               divider_control_B_data = "H14";            end;            do;  /* 44.056 / 88.112 */               divider_control_A_data = "H86F0";               divider_control_B_data = "H14";            end;            do;  /* 32 / 48 / 96 */               divider_control_A_data = "H8000";               divider_control_B_data = "H13";            end;            do;  /* 31.97 / 47.95 / 95.90 */               divider_control_A_data = "H8332";               divider_control_B_data = "H13";            end;         end; /* House Sync = 30 Hz case */      end;   end;       /* Sync source = House Sync case */   else if ((PLL_control_data & 7) >= 4) then do; /* Internal Sync case */      divider_control_A_data = "HFFF8";      divider_control_B_data = "H1F";   end;   /* Load Xilinx LCA configuration.  */   call load.configuration (configuration_number);   /* Initialize the "subcode" (e.g. AES/EBU Channel Status Data, SDIF */   /* Emphasis bits) appropriate to the format if direction is Out.    */   if direction = FE_dir_out   then call initialize_subcode (format, sample_rate);   /*      print;      print 'H12,14,1E,17,1F: ', UDIO_bus_control_data, divider_control_A_data,      divider_control_B_data, PLL_control_data, IO_control_data;   */   /* Write the data values that have been set up to the registers */   call Write.Selected.DDT.Register(LAD_UDIO_Bus_Control, UDIO_bus_control_data);  /* Write UDIO bus control */   call Write.Selected.DDT.Register(LAD_PLL_Divider_A,    divider_control_A_data); /* Write PLL Divider A */   call Write.Selected.DDT.Byte    (LAD_PLL_Divider_B,    divider_control_B_data); /* Write PLL Divider B */   call Write.Selected.DDT.Register(LAD_PLL_Control,      PLL_control_data);       /* Write PLL control */   call Write.Selected.DDT.Byte    (LAD_IO_Control,       IO_control_data);        /* Write IO control */end initialize.universal.DDT;/* $Page - initialize DDT unit *//* This routine is called to initialize a DDT unit.   This unit *//* may be connected to its own D24 (DDT.Connect.Mode = 0),  or  *//* may be connected to a SCSI buffer memory card (DDT.Connect   *//* .Mode = 1).    In the latter case,  the correct port for     *//* this DDT unit has been selected BEFORE the initialize        *//* routine is called.                                           *//* Basically,  this routine need not worry whether the unit     *//* is connected to a D24 or a buffer memory card.               *//* This routine is passed a hardware revision # (read from      *//* the DDT unit itself during startup)  and a sampling rate.    *//* The sampling rate is KHZ * 10  (IE 441 = 44.1 KHZ)           */Initialize.DDT.Unit: proc (Rev#, Rate, Dir, Format, Sync_source,                           group_info, go_master, system_clock_master)                           PUBLIC swapable;   dcl Rev#         fixed; /* Rev# for this unit,  read from the hardware  */   dcl Rate         fixed; /* Current DTD Sampling Rate (KHZ*10)           */   dcl Dir          fixed; /* Direction (FE_Dir_Out, FE_Dir_In)            */   dcl format       fixed; /* Serial xfer format (e.g. AES_16bit)          */   dcl sync_source  fixed; /* Literal indicating synchronization source (e.g. House sync, Internal) */   dcl group_info   fixed; /* Number (0-3) of UDIO group this unit is in in MSB.  LSB = 1 if Group Master unit, 0 otherwise. */   dcl go_master           boolean; /* Is this board the Go Master unit?           */   dcl system_clock_master boolean; /* Is this board the System Clock Master unit? */   if Rev# = DDT.MITSU.REV then do;     /* Mitsubishi type unit inits */      call DDT.Connect(DDT.Connect.Mode);  /* connect to DDT          */      /* Issue reset to board and set up desired */      /* clock rate:                             */      write(ScsiByte) = FE_Cmd_Byte \ FE_Loc_Ad_Next \ dir;      write(ScsiByte) = LAD_Write \ LAD_Loc_Ad_Next \ LAD_FE_Control_Byte;      write(ScsiByte) = FECB_Reset;   /* active low reset    */      write(ScsiByte) = LAD_Write \ LAD_Loc_Ad_Next \ LAD_FE_Control_Byte;      write(ScsiByte) = FECB_No_FE_Reset;      write(ScsiByte) = LAD_Write                   \ LAD_FE_Control_Byte;      if      Rate <= 460      then write(ScsiByte) = FECB_No_FE_Reset \ FECB_Clock_441;      else if Rate <= 500      then write(ScsiByte) = FECB_No_FE_Reset \ FECB_Clock_480;      else write(ScsiByte) = FECB_No_FE_Reset \ FECB_Clock_960;   end;  /* Mitsubishi type unit */   else if Rev# = DDT.DDSYN.REV then do;   /* DDSYN units:   */      call DDT.Connect(DDT.Connect.Mode);  /* connect to DDT     */      write(ScsiByte) = FE_Cmd_Byte \ dir; /* set stop, dir in   */   end;   /* Else set up all the control registers for the universal DDT: */   else do;  /* Universal type unit inits */      /* Prevent UDDT from choking on an unsupported rate */      if  (Rate <> 319) and (Rate <> 320)      and (Rate <> 440) and (Rate <> 441)      and (Rate <> 479) and (Rate <> 480)      and (Rate <> 881) and (Rate <> 882)      and (Rate <> 959) and (Rate <> 960)      then Rate = 441;  /* Set default 44.1 Khz rate instead */      call initialize.universal.DDT(Dir, format, Rate, sync_source,                                    group_info, go_master,                                    system_clock_master);      /* Zero out 20/24 bit format upper bits: */      call Write.Selected.DDT.Register(LAD_FEA_24_Mode, 0);      call Write.Selected.DDT.Register(LAD_FEB_24_Mode, 0);   end;   /* zero out front end registers so output data is */   /* digital zeroes for now                         */   call Write.Selected.DDT.Register(LAD_Scsi_Front_End_A, 0);   call Write.Selected.DDT.Register(LAD_Scsi_Front_End_B, 0);end Initialize.DDT.Unit;