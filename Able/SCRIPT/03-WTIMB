/* 03-WTIMB  $TITLE  Routine to Emit Timbre Definitions *//* 04/24/89 - cj - modified for "EVENT" storage format */dcl #.twrds lit '10'; /* number of header words in timbre def */dcl #.fwrds lit '12'; /* number of header words in file entry */dcl pinfo   lit '(-3)';  dcl pinfo.len lit '(32)';dcl tinfo   lit '(-4)';  dcl tinfo.len lit '(96)';dcl ti.name  lit '8';dcl ti.rte   lit '16';DCL S.STRING    DATA ('           '); /* TAB STRING FOR timbre frame CONVERSION */dcl tf.dps      data (0,0,0,2,1,1,0,0,0,0,2,0); /* decimal points for conversion */dcl tname(32) fixed;sampled:proc(w,i);        /* output coded words for vk rte patching */   dcl (i,j,k,w) fixed;   if w=0 then return;   j=1;   do k=0 to 15;          /* test each bit */      if (w&j)<>0 then do;         if i<>0 then call outs('I');         do case(k);            call outs('VkVattack ');            call outs('VkVidecay ');            call outs('VkVdelay  ');            call outs('VkHattack ');            call outs('VkHidecay ');            call outs('VkVfdecay ');            call outs('VkHdelay  ');            call outs('VkPrate   ');            call outs('VkHfdecay ');            call outs('VkVibatk  ');            call outs('VkDynenv  ');            call outs('VkSBit11  ');            call outs('VkSBit12  ');            call outs('VkSBit13  ');            call outs('VkSBit14  ');            call outs('VkSBit15  ');         end;      end;      j=shl(j,1);   end;end sampled;continuous:proc(w,i);   dcl (i,j,k,w) fixed;   if w=0 then return;   j=1;   do k=0 to 15;          /* test each bit */      if (w&j)<>0 then do;         if i<>0 then call outs('I');         do case(k);            call outs('VkVibrate ');            call outs('VkVibdep  ');            call outs('VkVpksus  ');            call outs('VkVibmdep ');            call outs('VkStRate  ');            call outs('VkHpeak   ');            call outs('VkHsust   ');            call outs('VkStDepth ');            call outs('VkStPan   ');            call outs('VkTuning  ');            call outs('VkFmRatio ');            call outs('VkRepRate ');            call outs('VkChorus  ');            call outs('VkTrkVol  ');            call outs('VkCBit14  ');            call outs('VkCBit15  ');         end;      end;      j=shl(j,1);   end;end continuous;step.timbre.pointer:  proc(base);  dcl (i,base) fixed;  if sfm.timbres then do; /* case for SFM timbres */    base=base+#.twrds; /* skip words at start of timbre */    do while p.lookup(base)<>0; /* skip to end of file list */      base=base+#.fwrds;    end;    base=base+1; /* skip over the zero */  end;  else do; /* skip over synclavier II timbre - new or old format */    do i=0 to 3; /* skip over 4 partials */      if p.lookup(base)=(-2) then base=base+1; /* skip over suppressed partial */      else do;        base=base+46; /* 46 basic parameters */        do while p.lookup(base)=(-1); base=base+p.lookup(base+2); end; /* skip over frames */        if p.lookup(base)=pinfo then base=base+pinfo.len;      end;    end;    if p.lookup(base)=tinfo then base=base+tinfo.len;    base=base+8; /* skip misc area */  end;  return base; /* return pointer */end step.timbre.pointer;write.strings:  proc(bits); /* write out string assignments given bits */  dcl (bits,mask,i) fixed;  if bits<>0 then do; /* only print if a bit is set */    call new.line; call outs('  Active.strings ');    mask=1;    do i=0 to 5;      if (bits&mask)=0 then do; call outi(i+1,false); call outb(A.SP); end;      mask=shl(mask,1);    end;  end;end write.strings;write.guitar.bits:  proc(bits); /* write out the guitar performance bits */  dcl (bits,mask,i) fixed;  if (bits&"177000")<>0 then do; /* only print if a bit is set */    call new.line; call outs('  ');    if (bits&"2000")=0 then do; /* filter is enabled */      if (bits&"100000")=0 then call outs('Hi.tfilter ');      else                      call outs('Lo.tfilter ');    end;    if (bits&"1000")=0 /* special case for guitar follow mode */    then call outs('Follow.guitar ');    mask="4000";    do i=0 to 3; /* loop over bits */      if (bits&mask)=0 then do case i;        call outs('Mono.string ');        call outs('Dynamic.vol ');        call outs('Pfilter ');        call outs('Quantize ');      end;      mask=shl(mask,1); /* update mask */    end; /* of loop over bits */  end; /* if bit is set */end write.guitar.bits;write.timbre:  proc(i,always); /* write out the timbre for track i (0-15). pass always=1 to emit definition even for null timbres */  dcl vol.env.dp.list      data ( 0, 0, 0, 0,     1,     1);  dcl vol.env.mask.list    data (-1,-1,-1,-1,"1777","1777");  dcl exist                fixed; /* existence bits for partials */  dcl rte_bits             fixed; /* overall rte control bits */  dcl string_bits          fixed; /* string assignment bits */  dcl guitar_bits          fixed; /* guitar performance bits */  dcl num_buffs            fixed; /* number of SFM attack buffers */  dcl wave                 fixed; /* number of non-zero waveform harmonics */  dcl mask                 fixed; /* bit mask */  dcl always               fixed; /* 1 = emit definition even for null timbres */  dcl (i,j,k,l,m,n,p,q,ch)   fixed;  exist=0; /* assume no partials */  mask=1; /* init bit mask */  l=PR_PTR(i); /* look up pointer to timbre for this file */  n=0; /* count # of frames in whole timbre */  if sfm.timbres then do; /* case for SFM timbres */    if p.lookup(l+#.twrds)<>0 then exist=1; /* check for file name */  end;  else do j=0 to 3; /* check each Synclavier partial */    if p.lookup(l)<>(-2) then do; /* if not suppressed, check further */      if syn.med<>2 then p=(n.lookup(DT_PTR(I)));      else               p=(         DT_PTR(I) );      if (((p.lookup(l+4)&"1777") or (p.lookup(l+5)&"1777"))<>0) /* non-zero volume */      or ((j=3) and (exist=0) and (p<>0)) then do; /* track is to be printed */        p=0; /* count # of frames in this partial */        exist=exist\mask; /* set bit to indicate partial exists */        if syn.med=0 then outw.lim=prm.ptr+l; /* release memory up to here */        call new.line; /* begin with blank line */        call new.line; call outs('Define Partial Timbre');        call outi(i+1,false);        call outs('.Partial'); call outb(a.1+j); /* partial Name.k */        call new.line; call outs('  Volenv    '); /* define volume envelope */        do k=0 to 5; /* emit numbers */          call outn(p.lookup(l+k)&vol.env.mask.list(k),vol.env.dp.list(k),true);        end;        if ((p.lookup(l+10)\p.lookup(l+11))&"1777")<>0 then do; /* Fm env */          call new.line; call outs('  FMenv     ');          do k=6 to 11;            call outn(p.lookup(l+k)&vol.env.mask.list(k-6),0,true);          end;        end;        string_bits=shr(p.lookup(l+12),10); /* get string assignments word */        wave=24; /* assume 24 harmonics to print */        do while (wave>1) and (p.lookup(l+11+wave)=0); /* find number to print */          wave=wave-1;        end;        if (wave>1) or (p.lookup(l+12)<>1000) then do; /* not a sine wave */          call new.line; call outs('  Harmonics ');          q=0; /* see if any phase info */          do k=1 to wave; /* loop over harmonics */            if (k=7) or (k=13) or (k=19) then do; /* start new line */              call new.line; call outs('            ');            end;            call outn(p.lookup(l+11+k)&"1777",1,true); /* print harmonic value */            if k<>1 then q=q\(p.lookup(l+11+k)&"176000"); /* see if any phase info */          end;          if q<>0 then do; /* print out phases */            call new.line; call outs('  Phases    ');            call outn(0,0,true); /* provide a 0 for first phase */            do k=2 to wave; /* loop over harmonics */              if (k=7) or (k=13) or (k=19) then do; /* start new line */                call new.line; call outs('            ');              end;              call outn(shr(p.lookup(l+11+k),10),0,true); /* print harmonic value */            end;          end;        end; /* not a sine wave */        if p.lookup(l+36)<>4400 then do; /* tuning */          call new.line; call outs('  Tuning    ');          call outn(p.lookup(l+36),1,true);        end;        if (p.lookup(l+39)&"177")<>0 then do; /* output vibrato information if present */          call new.line; call outs('  Vibrato      ');          do case (p.lookup(l+37)&"17"); /* wave */            call outs(' Sin');  call outs(' Tri');            call outs(' Ram');  call outs(' Inv');            call outs(' Sqr');  call outs('Sin2');            call outs('Tri2');  call outs('Ram2');            call outs('Inv2');  call outs('Sqr2');            call outs(' Rnd');  call outs('Rnd2');          end;          if (p.lookup(l+37)&"100")<>0 then call outs('  Raised');          if (p.lookup(l+37)&"040")<>0 then call outs('  Quantized');          if (p.lookup(l+37)&"020")<>0 then call outs('  Inverted');          call outn(p.lookup(l+38),2,true); /* write the vibrato numbers */          call outn(p.lookup(l+39),2,true); call outn(p.lookup(l+40),0,true);        end; /* of vibrato information */           if (p.lookup(l+41)) or ((p.lookup(l+42)&"1777")<>600) then do; /* port rate */          call new.line;          if p.lookup(l+41) then do; /* glide active */            port.active(i)=1;            call outs('  Portamento    ');          end;          else call outs('  Port.rate     ');          if (p.lookup(l+41)&2)=0 then call outs('Log');          else                     call outs('Lin');          call outn(p.lookup(l+42)&"1777",3,true);        end;        if p.lookup(l+43)<>1000 then do; /* ratio */          call new.line; call outs('  FMRatio   ');          if p.lookup(l+43)>=0 then call outn(p.lookup(l+43),3,true); /* pos ratio */          else                  call outn(p.lookup(l+43),1,true); /* negative ratio with 1 dp */        end;        if ((p.lookup(l+41)&"177774")\(p.lookup(l+37)&"177600")\(p.lookup(l+42)&"176000"))<>0 then do; /* stereo information */           call new.line; call outs('  Stereo    ');           call outn(((shr(p.lookup(l+41),2)+50)&"177")-50,0,true); /* center -50.0 to +50.0 */           call outn(shr(p.lookup(l+37),7), 0,true); /* mode */           call outn(shr(p.lookup(l+42),10),1,true); /* rate */           call outn(shr(p.lookup(l+41),9), 0,true); /* depth */        end;        if (p.lookup(l+44)&"1777")<>0 then do; /* decay */          call new.line; call outs('  Decay     ');          call outn(p.lookup(l+44)&"1777",3,true);        end;        if (p.lookup(l+44)&"176000")<>0 then do; /* harmadj */          call new.line; call outs('  Harmadj   ');          call outn(((shr(p.lookup(l+44),10)+32)&"77")-32,0,true); /* -30 to +30 */        end;        if ((p.lookup(l+4)\p.lookup(l+5)\p.lookup(l+10)\p.lookup(l+11))&"176000")<>0 then do;          call new.line; call outs('  Kbdenv    ');          call outn(shr(p.lookup(l+10),10),0,true);          call outn(shr(p.lookup(l+ 4),10),0,true);          call outn(shr(p.lookup(l+ 5),10),0,true);          call outn(shr(p.lookup(l+11),10),0,true);        end;        if (p.lookup(l+45)>31)&(p.lookup(l+45)<>1000) then do; /* partial chorus function */           call new.line; call outs('  Pchorus   ');           call outn(p.lookup(l+45),3,true);        end;        call write.strings(string_bits); /* emit the string assignments */        l=l+46; /* skip over frame 0 */        do while p.lookup(l)=(-1); /* process each t.f */           if syn.med=0 then outw.lim=prm.ptr+l; /* set up output limit if no .work */           if p.lookup(l+1)=0 then do;           /* type 0 - 8-bit timbre frame frame */             p=p+1; n=n+1; /* count # of frames */             call new.line; call outs('  /* Timbre Frame '); call outi(p,false); call outs(': */');             call new.line; call outs('  T.F.Info '); /* 12 parameters */             k=0;             do while k<12; /* emit 8 parameters */                call outs(' '); call outn(p.lookup(l+8+k),tf.dps(k),true); /* emit info - starting at location 8 of timbre frame */                if k=5 then k=10; else k=k+1;             end;             call new.line; call outs('  T.F.Harm '); /* harmonic list */             k=24; q=0; /* assume 24 harmonics */             do while (k>1)&(p.lookup(l+20+k-1)=0);k=k-1;end; /* find last nonzer one */             do k=0 to (k-1); /* output harmonics */                if (k<>0)&((k&7)=0) then do;call new.line; call outs(s.string);end;                call outs(' '); call outn(p.lookup(l+20+k)&"1777",1,true);                q=q\(p.lookup(l+20+k)&"176000");             end;             if q<>0 then do; /* print out phases */               call new.line; call outs('  T.F.Phase'); /* phase list */               do k=0 to (k-1); /* output phases */                  if (k<>0)&((k&7)=0) then do;call new.line; call outs(s.string);end;                  call outs(' '); call outn(shr(p.lookup(l+20+k),10),0,true);               end;             end;             call new.line; call outs('  T.F.Wave '); /* wave table */             do k=0 to 255; /* and process each wave table word */                if (k<>0)&((k&15)=0) then do;call new.line; call outs(s.string);end;                m=p.lookup(l+44+shr(k,1)); /* table starts at location 44 */                if k then m=rot(m,8);                m=m&255; /* get wave table byte */                call outb(32);ch=0; /* one space */                if m>=100 then do;call outb(48+m/100);m=m mod 100;ch=1;end;                else call outb(32);                if (m>=10)\(ch<>0)  then do;call outb(48+m/10 );m=m mod 10 ;end;                else call outb(32);                call outb(48+m);             end;           end;           else if p.lookup(l+1)=1 then do;   /* patch list frame */             call new.line; call outs('  File  ');             call outb(A.APOST);              /* emit file name   */             k=0;                             /* count null chars */             do m=0 to 3;                     /* loop over words of file name */               ch=p.lookup(l+3+m)&"377";      /* get char */               if ch>0 then call outb(ch); else k=k+1;   /* print or count */               ch=shr(p.lookup(l+3+m),8);               if ch>0 then call outb(ch); else k=k+1;             end;             call outb(A.APOST);             do m=0 to k+2; call outb(A.SP); end; /* line up and space out */             m=p.lookup(l+7)&255;             call outpi(m); call outs(' ');     /* starting key */             m=p.lookup(l+8)&255;             call outpi(m); call outs(' ');     /* ending key */             call outn(p.lookup(l+9),1,true);   /* volume */             m=p.lookup(l+10)&255;             if (m<>0) then do;                 /* transposition */               call outs('  '); call outpi(m);             end;             m=p.lookup(l+11)\p.lookup(l+12)\p.lookup(l+13);  /* if semi corr or loop info */             if (m<>0) then do;                call outs('  '); call outn(p.lookup(l+11),2,true); /* semi */             end;             m=p.lookup(l+12)\p.lookup(l+13);   /* if loop info  */             if (m<>0) then do;                 /* loop info     */                call outs('  '); call outn(p.lookup(l+12),0,false);                call outs('  '); call outn(p.lookup(l+13),0,true);                call outs('  '); call outn(p.lookup(l+14),0,false);                call outs('  '); call outn(p.lookup(l+15),0,true);             end;           end;           else if p.lookup(l+1)=CU.TYPE then do;   /* cue list */             call new.line;              call outs('  Cue  ');             call outn(p.lookup(l+CU.KEY),0,TRUE);   /* output key # */             call outs('  ');             call outb(A.APOST);              /* emit cue name    */             do m=0 to p.lookup(l+CU.NAME)-1;       /* loop over bytes  */               if m then k=shr(p.lookup(l+CU.NAME+1+shr(m,1)),8);               else      k=   (p.lookup(l+CU.NAME+1+shr(m,1))  )&255;               call outb(k);               if (k=a.apost) then call outb(k);             end;             call outb(A.APOST);           end;           else if p.lookup(l+1)=EV.TYPE then do;   /* event list */             call new.line;              call outs('  Event  ');             call outb(A.APOST);              /* emit cue name    */             do m=0 to p.lookup(l+EV.NAME)-1; /* loop over bytes  */               if m then k=shr(p.lookup(l+EV.NAME+1+shr(m,1)),8);               else      k=   (p.lookup(l+EV.NAME+1+shr(m,1))  )&255;               call outb(k);               if (k=a.apost) then call outb(k);             end;             call outb(A.APOST);             q=ev.name + shr(p.lookup(l+ev.name)+3,1); /* point to word after cue name */             if p.lookup(l+q)<>0 then do;              /* provide new line if comment exists */                call new.line;                 call outs('         ');             end;             else call outs('  ');             call outb(A.APOST);              /* emit cue name    */             do m=0 to p.lookup(l+q)-1; /* loop over bytes  */               if m then k=shr(p.lookup(l+q+1+shr(m,1)),8);               else      k=   (p.lookup(l+q+1+shr(m,1))  )&255;               call outb(k);               if (k=a.apost) then call outb(k);             end;             call outb(A.APOST);             call new.line;              call outs('         ');             call outn(p.lookup(l+EV.KEY),0,TRUE);   /* output key # */             /* Emit event information, including spares */             do m = EV.IN.MSB to EV.NAME-1;                if m = EV.FADE.IN then do;                   call new.line;                    call outs('         ');                end;                call outn(p.lookup(l+m),0,TRUE);             end;          end;          l=l+p.lookup(l+2); /* skip over frame */        end; /* of processing for each frame */        if p.lookup(l)=pinfo then do;  /* pinfo block */           wave=pinfo.len-1;           /* print out nonzero words - start at end */           do while (wave>1) and (p.lookup(l+wave)=0); /* find number to print */             wave=wave-1;           end;           call new.line; call outs('  Pinfo     ');           do k=1 to wave; /* loop over harmonics */             if (k<>1)&(((k-1)&7)=0) then do;               call new.line; call outs('            ');             end;             call outn(p.lookup(l+k),0,true);           end;           l=l+pinfo.len;        end;        call new.line; call outs('End Timbre'); /* end of definition */        call outi(i+1,false);        call outs('.Partial'); call outb(a.1+j);      end; /* of case for nonzero partial */      else do; /* zero partial - means no printout,  but must skip over frames */        l=l+46; /* skip over frame 0 */        do while p.lookup(l)=(-1); /* process each t.f */           l=l+p.lookup(l+2); /* skip over frame */        end;      end;    end;    else l=l+1; /* skip over suppressed partial */    mask=shl(mask,1);  end; /* of loop over partials */  if (exist <>0)      /* if any real partials */  or (always<>0)      /* or notes on track    */  then do;            /* emit timbre def      */    print 'Timbre ',; pnum(i+1,false); print ':  ',; /* prompt to user */    print ' has ',;    if n<>0 then do; /* print message */       pnum(n,false);     end;    else print 'no',;    print ' Timbre Frames',;    if syn.med=0 then outw.lim=prm.ptr+l; /* free memory up to sfm.timbre or misc timbre */    call new.line; /* blank line */    call new.line;    if sfm.timbres then call outs('Define SFM Timbre Timbre');    else                call outs('Define Timbre Timbre');    call outi(i+1,false);    if sfm.timbres then do; /* emit file list */      k=l; /* get pointer to timbre */      num_buffs=p.lookup(k)-1; /* get number of buffers */      string_bits=p.lookup(k+1)&"77"; /* get string bits */      guitar_bits=p.lookup(k+1); /* get guitar perf bits */      k=k+#.twrds; /* skip over header words */      do while p.lookup(k)<>0; /* loop over entries */        call new.line; call outs('  ');        call outb(A.APOST);        l=0; /* count null chars */        do j=0 to 3; /* loop over words of file name */          ch=p.lookup(k+j)&"377"; /* get char */          if ch>0 then call outb(ch); else l=l+1; /* print or count */          ch=shr(p.lookup(k+j),8);          if ch>0 then call outb(ch); else l=l+1;        end;        call outb(A.APOST);        do j=0 to l+2; call outb(A.SP); end; /* line up and space out */        j=p.lookup(k+4)&255; if j>=128 then j=j-256;       /* detect lowest octave */        call outpi(j+12); call outs('  '); /* starting key */        j=p.lookup(k+5)&255; if j>=128 then j=j-256;       /* detect lowest octave */        call outpi(j+12); call outs('  '); /* ending key */        call outn(p.lookup(k+6),1,true);        if p.lookup(k+7)<>0 then do;          j=p.lookup(k+7)&255; if j>=128 then j=j-256;       /* detect lowest octave */          call outs('  '); call outpi(j+12);        end;        k=k+#.fwrds;      end; /* end of loop on entries */      call new.line; call outs('  Num.buffs  '); call outi(num_buffs,false);      call write.strings(string_bits);      call write.guitar.bits(guitar_bits);    end; /* sfm timbres */    else do; /* Synclavier timbre - emit overall information */      mask=1; /* init bit mask */      do j=0 to 3; /* loop over partials */        if (exist&mask)<>0 then do; /* if partial used */          call new.line; call outs('  Partial Timbre');          call outi(i+1,false);          call outs('.Partial'); call outb(A.1+j);        end;        mask=shl(mask,1);      end;      if p.lookup(l)=tinfo then do;  /* tinfo block */         p=0;         call pbyte(tname,p,a.apost); p=p+1;         do k=1 to 16; /* process each byte */            if (k) then m=p.lookup(l+ti.name+shr(k,1));            n=m&LBYTE;            if (n<A.SP) or (n=A.LESS) or (n=A.APOST) then do; /* special chars */               call pbyte(tname,p,A.LESS);       /* use <<> for "<" */               if (n=a.less) or (n=a.apost)        /* use <'> for "'" */               then call pbyte(tname,p+1,n);     /* use <A> for control-a */               else call pbyte(tname,p+1,(A.A+n-1));               call pbyte(tname,p+2,(A.GREATER));               p=p+2;            end;            else call pbyte(tname,p,n); /* regular chars */            p=p+1;            m=shr(m,8); /* get other byte */         end;         do while (p<>0)&(Byte(tname,p-1)=32); p=p-1; end; /* remove spaces */         if p<>1 then do;      /* skip entirely if only single quote left */            call pbyte(tname,p,a.apost); p=p+1;            tname(0)=p; /* string length */            call new.line; call outs('  Tname     ');            call outs(tname);         end;         call new.line; call outs('  Tinfo     ');         wave=tinfo.len-1;           /* print out nonzero words - start at end */         do while (wave>1) and (p.lookup(l+wave)=0); /* find number to print */           if wave=ti.rte+40 then wave=ti.name; /* skip over name & rte's here */           wave=wave-1;         end;         m=1; k=1;         do while k ile wave; /* loop over info */           if (m<>1)&(((m-1)&7)=0) then do;             call new.line; call outs('            ');           end;           call outn(p.lookup(l+k),0,true);           k=k+1; m=m+1;           if k=ti.name then k=ti.rte+40; /* skip over name & rte */         end;         p=0; /* assume none */         do k=0 to 7; /* test each rte */            tname(k)=0; /* assume not there */            if p.lookup(l+ti.rte+k*5)<>15 then tname(k)=1; /* not all there */            do n=1 to 4; if p.lookup(l+ti.rte+k*5+n)<>0 then tname(k)=1; end;            p=p\tname(k); /* see if any needed */         end;         if p<>0 then do; /* output vk rte's */            call new.line; call outs('  Vkrte     ');            q=0;            do k=0 to 7;  /* each expression */               if tname(k)<>0 then do;    /* one exists */                  if q<>0 then do;                     call new.line; call outs('            ');                  end;                  q=1;                  do case (k);                     call outs('VkVel ');                     call outs('VkPre ');                     call outs('VkPe1 ');                     call outs('VkPe2 ');                     call outs('VkMod ');                     call outs('VkRib ');                     call outs('VkKcv ');                     call outs('VkBth ');                  end;                  m=p.lookup(l+ti.rte+k*5); /* get partials */                  mask=1;    /* set bit mask */                  do p=0 to 3;                    if (m&mask)<>0 then do;                      call outs('P'); call outb(A.1+p); call outb(A.SP);                    end;                    else if (m&(shl(mask,4)))<>0 then do;                      call outs('IP'); call outb(A.1+p); call outb(A.SP);                    end;                    mask=shl(mask,1);                  end;                  m=p.lookup(l+ti.rte+k*5+1);                  call sampled(m,0);                  m=p.lookup(l+ti.rte+k*5+2);                  call continuous(m,0);                  m=p.lookup(l+ti.rte+k*5+3);                  call sampled(m,1);                  m=p.lookup(l+ti.rte+k*5+4);                  call continuOus(m,1);               end;   /* of something there */            end;      /* of loop over expressions */         end;         /* rte's exist */         l=l+tinfo.len;      end;      if (p.lookup(l+6)<>1000)&(p.lookup(l+6)<>0) then do; /* chorus */        call new.line; call outs('  Chorus ');        call outn(p.lookup(l+6),3,true);      end;      if ((p.lookup(l)&"52")<>0) or (p.lookup(l+5)<>500) then do; /* Repeat, Arp */        call new.line; call outs('  ');        if (p.lookup(l)&32)<>0 then call outs('Autophrase  ');        if (p.lookup(l)&02)<>0 then call outs('Repeat  ');        if (p.lookup(l)&08)<>0 then call outs('Arpeggiate  ');        if (p.lookup(l)&"12")<>0 then do;           call outs('Rate');           call outn(p.lookup(l+5),2,true); /* repeat rate */        end;      end;      if (p.lookup(l)&"177400")<>0 then do; /* numvoices */        m=shr(p.lookup(l),8);      /* look up polyphony value */        call new.line; call outs('  Numvoices  '); call outi(m,false);      end;      rte_bits=p.lookup(l+7); /* look up rte assignments data */      if rte_bits=0 then rte_bits="172";  /* perform initialization */      if (rte_bits&2)=0 then rte_bits=rte_bits&"177577"; /* disallow inverted pedal if no pedal */      if (rte_bits&4)=0 then rte_bits=rte_bits&"177776"; /* ditto for vel */      if rte_bits<>"000172" then do; /* RTE is active */        call new.line; call outs('  Rte  ');        if (rte_bits&"2")<>0 then do;                 /* pedal */           if (rte_bits&128)<>0 then call outs('I');  /* use IPedal for Inverted Pedal */           call outs('Pedal ');        end;        if (rte_bits&"4")<>0 then do;                 /* velocity */           if (rte_bits&1)<>0 then call outs('I');    /* use IVelocity for Inverted velocity */           call outs('Velocity ');        end;        mask="10"; /* set bit mask */        do j=0 to 3;          if (rte_bits&mask)<>0 then do;            call outs('P'); call outb(A.1+j); call outb(A.SP);          end;          mask=shl(mask,1);        end;        mask="400"; /* set bit mask */        do j=0 to 7; /* loop over RTE fields */          if (rte_bits&mask)<>0 then do case (j);            call outs(' Veattack');            call outs(' Vedecays');            call outs(' Vepeak');            call outs(' Heattack');            call outs(' Hedecays');            call outs(' Hepeak');            call outs(' Hesustain');            call outs(' Prate');          end;          mask=shl(mask,1);        end; /* of loop over rte fields */      end; /* of rte is active */      call write.guitar.bits(p.lookup(l+1)); /* write guitar bits */    end; /* of normal timbre definition */    call new.line; call outs('End Timbre'); call outi(i+1,false);    print; /* end the prompting message */  end;end write.timbre;