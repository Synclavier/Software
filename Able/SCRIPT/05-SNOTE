/* 05-SNOTE  $TITLE  Routines for printing a notelist in SCRIPT Music Format *//* Standard Notelist Conversion Routine *//* Extracted from the Music Printing Program */write.snotelist:  procedure(N); /* write a SCRIPT notelist for track */   dcl N              fixed; /* track number 0-15 */   dcl TIME           fixed;   /* time of middle of block */   dcl TIME_CARRIES   fixed;   dcl BLOCKS         fixed;   dcl WRAP_MODE      boolean;   dcl FINAL_POS      fixed;   dcl VECTOR_POS     fixed;   dcl VECTOR_LEN     fixed;   dcl VOL_DATA       boolean; /* true if volume line must be emitted */   dcl RTE_DATA       boolean; /* true if rte    line must be emitted */   dcl NEXT_START     fixed;   /* time of next note */   dcl TEMPLATE(63)   fixed;   /* template area */   dcl VECTOR(150)    fixed;   /* chord vector storage */   dcl (I, J, K)      fixed;   dcl (nmsb,nlsb)    fixed;   /* time of next note in sequence */   dcl (zmsb,zlsb)    fixed;   /* time relative to script 0.000 */   dcl (wmsb,wlsb)    fixed;   /* window time                   */   dcl (nlsp,wd)      fixed;   SPACE_TRIM:  procedure(LINE); /* trim trailing spaces of line buffer */      dcl LINE fixed array;      do while (byte(LINE,LINE(0)-1) = 32) & (LINE(0) > 0);         LINE(0) = LINE(0) - 1;      end;   end SPACE_TRIM;   BUILD_TEMPLATE:  procedure; /* set up measure-long timing template */     dcl TICS fixed;     dcl (P,Q,R,DIF,I) fixed;     BLOCKS = (RESOLUTION(N) / BEAT_NOTE(N)) * BEAT_MEAS(N); /* number of blocks in measure */     TICS   = (CLICK_RATE * BEAT_MEAS(N) * TEMPO) / BEAT_NOTE(N); /* number of ticks (ms) in measure */     Q = TICS / BLOCKS; /* number of whole ticks per block */     R = TICS mod BLOCKS; /* remaining ticks in measure */     do P = 0 to BLOCKS - 1; /* Load template with rounded down integer values */       TEMPLATE (P) = Q;     end;     if R > 0 then do; /* account for remaining ticks by mutual prime cycling scheme */       DIF = BLOCKS / R; /* compute amount to skip */       if (BLOCKS mod R) <> 0 then do; /* find prime number to give extra skips */         I = 0;         do while (PRIME_TABLE(I) < DIF) or (BLOCKS mod PRIME_TABLE(I) = 0);           I = I + 1;           if I > 19 then call file.error(5); /* Out of Primes */         end;         DIF = PRIME_TABLE(I); /* get from prime table */       end;       Q = Q + 1;       P = 0; /* init pointer */       do I = 1 to R; /* loop over remaining ticks to be added */         TEMPLATE (P) = Q; /* add extra tick */         P = P + DIF; /* advance */         if P >= BLOCKS then P = P - BLOCKS; /* wrap around */       end;     end; /* of remaining ticks */   end BUILD_TEMPLATE;   LOOKUP_NOTE:PROC;                     /* get info from notelist */      dcl (i) fixed;      nextnls:;      if nlsp=0 then return;          /* no note list segment */      write(mam)=nah.ptr+nlsp;      if wd=0 then do;                /* first time through - init wd pointer */         write(mal)=nls.fp;         wd=read(md);                 /* get ptr to start     */      end;      write(mal)=wd;      note_data1=read(mdi);        /* get first word       */      if note_data1=nls.eos then do;         write(mam)=nah.ptr+nlsp;         write(mal)=nls.for;         nlsp=read(md);         wd  =0;         goto nextnls;      end;      note_data2=read(mdi);        /* get second word      */      if note_data1 then do;         note_data3=read(mdi);         note_data4=read(mdi);      end;      else do;         note_data3=225;         note_data4=vel.note;      end;      i=shr(note_data1,1)&1023;      nlsb=nlsb+i;      if nlsb ilt i then nmsb=nmsb+1;   end;   FILE_LOAD:  procedure(T1,T2); /* load any notes starting between T1 & T2 into VECTOR list */     /* also computes duration in blocks */     /* 16 track format: t1 and t2 are time window        */     /* 32 track format: t1 + msb, t2 = lsb of window end */     dcl (T1,T2)     fixed;     dcl (KEY,RTE)   fixed;     dcl (FT,DT,CT)  fixed;     dcl (MPSN,BLKS) fixed;     dcl START_TIME  fixed;     dcl DURATION    fixed;     dcl (ST,VOLUME) fixed;     dcl (zmsb,zlsb) fixed;  /* local zmsb */     dcl (dur,durmsb)fixed;  /* dur        */     dcl (i,j)       fixed;     MPSN = VECTOR_POS mod BLOCKS; /* find actual position in template */     do forever;                          if syn.med<>2 then do;         if syn.med=0 then outw.lim=seq.ptr+DT_PTR(N); /* allow output up to here now */         NOTE_DATA1 = n.lookup(DT_PTR(N)); /* get first word of note */         if NOTE_DATA1 = 0 then do;        /* abort if zero at notelist end is reached */           NEXT_START = (-1);              /* indicate end of list */           return;         end;         NOTE_DATA2 = n.lookup(DT_PTR(N)+1); /* get second word of note */         if NOTE_DATA1 then do; /* four word record */           NOTE_DATA3 = n.lookup(DT_PTR(N)+2); /* get additional info */           NOTE_DATA4 = n.lookup(DT_PTR(N)+3);         end; /* four word record */         KEY = NOTE_DATA2 & MASK6; /* extract key code */         START_TIME = shr(NOTE_DATA1-8, 1); /* get start time */         ST = START_TIME; /* adjust start time */         if (WRAP_MODE) and (START_TIME ilt T1) then ST = START_TIME + MAX_INT#; /* Convert to 16 bit */         if (T1 ile ST) and (ST ile T2) then do; /* within time range */           if not ((NOTE_DATA1) and ((NOTE_DATA3&"100000")<>0)) /* not update record */           and (KEY <> REST#) and (VECTOR_LEN < 147) then do; /* put on stack */             KEY=KEY+12;             DURATION = shr(NOTE_DATA2,6) & LBYTE; /* get duration information */             DURATION = DURATION * DUR.TABLE(rot(NOTE_DATA2,2)&MASK2); /* compute time, .005 sec */             VOLUME   = 255; /* assume full volume */             RTE      = 225; /* assume full RTE */             if CS.SEQ then DURATION = shl(DURATION,1); /* double time if cs data */             if NOTE_DATA1 then do; /* extract data from four word record */               if (NOTE_DATA3&b.vol)<>0 then VOLUME = shr(NOTE_DATA4,8);               RTE = NOTE_DATA3&LBYTE;               IF (NOTE_DATA4&LOWER.KEY)<>0 THEN KEY=KEY-12;               ELSE IF (NOTE_DATA4&RAISE.KEY)<>0 THEN KEY=KEY+12;             end;             FT = ST + DURATION; BLKS = 1; /* compute final time */             CT = TIME + TEMPLATE(MPSN); /* compute base time */             DT = TEMPLATE((MPSN+1) mod BLOCKS); /* ticks per position step */             do while FT igt CT + DT/2; /* sum up blocks covered by this note */               BLKS = BLKS + 1;               CT = CT + DT;                DT = TEMPLATE((MPSN+BLKS) mod BLOCKS);             end;             FT = VECTOR_POS + BLKS; /* first block after note */             if FINAL_POS ilt FT then FINAL_POS = FT;             VECTOR (VECTOR_LEN)   = KEY;             VECTOR (VECTOR_LEN+2) = BLKS;             VECTOR (VECTOR_LEN+3) = VOLUME;             VECTOR (VECTOR_LEN+4) = RTE;             VECTOR_LEN = VECTOR_LEN + 5;             if VOLUME <> 255 then VOL_DATA = true; /* must emit vol */             if RTE    <> 225 then RTE_DATA = true; /* must emit rte */             NOTE_CNT = NOTE_CNT + 1;           end; /* of put on stack */           if NOTE_DATA1 then DT_PTR(N) = DT_PTR(N) + 4; /* advance note pointer */           else               DT_PTR(N) = DT_PTR(N) + 2; /* 4 words or 2 words */         end; /* of within time range */         else do; /* out of time range */           NEXT_START = START_TIME; /* store start time of next note */           return;         end;       end;       else do;             /* 32-track format */         if nlsp=0 then return; /* end of track encountered */         /* compute time of note from script 0.000 */         if (nmsb=0)&(nlsb ilt zero.time) then do;            zmsb=0; zlsb=0;         end;         else do;              /* get time of this note relative to 0.000 */            zlsb=nlsb-zero.time;            if nlsb ilt zero.time then zmsb=nmsb-1;            else                       zmsb=nmsb;         end;         if  ((zmsb ilt t1))         or  ((zmsb  =  t1)         and  (zlsb ile t2))         then do;           if (note_data1&"174001")="100001"  /* long rest record  */           then do;              nmsb=nmsb+note_data2;           /* add in long delta */              nlsb=nlsb+note_data3;              if nlsb ilt note_data3              then nmsb=nmsb+1;              wd=wd+4;                        /* skip it          */              call lookup_note;               /* get next         */           end;           else if ((note_data1&"174001")="104001")  /* ils */           or      ((note_data1&"174001")="110001")  /* ile */           then do;              return;                         /* handled in main loop */           end;           else do;                           /* note or update  */             KEY = NOTE_DATA2 & MASK6;        /* extract key code */             if  ((NOTE_DATA3&"100000")=0)    /* not update record */             and (KEY <> REST#) and (VECTOR_LEN < 147) then do; /* put on stack */               KEY=KEY+12;               i=shr(note_data1,11)&15;               j=shr(note_data2,6)&1023;               dur=j\shl(i&3,10);         /* get 12 bit field */               write(5)=dur; write(6)=new.dur.table(shr(i,2));               durmsb=read(4); dur=read(5);               if (durmsb<>0)             /* check for overflow */               or (dur igt 20000)               then DURATION = 20000;               else DURATION = dur;               VOLUME   = 255; /* assume full volume */               RTE      = 225; /* assume full RTE */               if NOTE_DATA1 then do; /* extract data from four word record */                 if (NOTE_DATA3&b.vol)<>0 then VOLUME = shr(NOTE_DATA4,8);                 RTE = NOTE_DATA3&LBYTE;                 IF (NOTE_DATA4&LOWER.KEY)<>0 THEN KEY=KEY-12;                 ELSE IF (NOTE_DATA4&RAISE.KEY)<>0 THEN KEY=KEY+12;               end;               FT = zlsb + DURATION; BLKS = 1; /* compute final time */               CT = TIME + TEMPLATE(MPSN);     /* compute base time */               DT = TEMPLATE((MPSN+1) mod BLOCKS); /* ticks per position step */               do while FT > CT + DT/2; /* sum up blocks covered by this note */                 BLKS = BLKS + 1;                 CT = CT + DT;                  DT = TEMPLATE((MPSN+BLKS) mod BLOCKS);               end;               FT = VECTOR_POS + BLKS; /* first block after note */               if FINAL_POS ilt FT then FINAL_POS = FT;               VECTOR (VECTOR_LEN)   = KEY;               VECTOR (VECTOR_LEN+2) = BLKS;               VECTOR (VECTOR_LEN+3) = VOLUME;               VECTOR (VECTOR_LEN+4) = RTE;               VECTOR_LEN = VECTOR_LEN + 5;               if VOLUME <> 255 then VOL_DATA = true; /* must emit vol */               if RTE    <> 225 then RTE_DATA = true; /* must emit rte */               if NOTE_DATA1 >= 0 then NOTE_CNT = NOTE_CNT + 1;             end;             if NOTE_DATA1 then wd = wd + 4; /* advance note pointer */             else               wd = wd + 2; /* 4 words or 2 words */             call lookup_note;           end;      /* of put on stack */         end;        /* of within time range */         else do;    /* out of time range */           return;         end;       end;     end;    end FILE_LOAD;   ADD_REST:  procedure(DUR); /* add a rest note to vector */     dcl DUR fixed;     VECTOR (VECTOR_LEN)   = REST.MARK;     VECTOR (VECTOR_LEN+2) = DUR;     VECTOR (VECTOR_LEN+3) = 0;     VECTOR (VECTOR_LEN+4) = 0;     VECTOR_LEN = VECTOR_LEN + 5;   end ADD_REST;   SORT_VECTOR:  procedure; /* sort vector by decreasing duration */     dcl TEMP(4) fixed;     dcl (I,J)   fixed;     do I = 5 to VECTOR_LEN-1 by 5; /* insertion sort */       if VECTOR(I+2) > VECTOR(I+2-5) then do;         do K = 0 to 4; TEMP(K) = VECTOR(I+K); end;         J = I;         do while (J > 0) and (TEMP(2) > VECTOR(J+2-5));           do K = 0 to 4; VECTOR(J+K) = VECTOR(J+K-5); end;           J = J - 5;         end;         do K = 0 to 4; VECTOR(J+K) = TEMP(K); end;       end;     end;   end SORT_VECTOR;   EMIT_NOTE:  procedure(KEY_NO,BLKS,VOL,RTE); /* emit pitch and rhythm, decoding key */     dcl (KEY_NO,BLKS)   fixed; /* note and time value of note in blocks */     dcl (VOL,RTE)       fixed; /* volume and RTE values of note */     dcl (TYPE,SIZE,I,K) fixed;     if KEY_NO = (REST.MARK) then call PUSH (P_LINE,'R'); /* emit R for rest */     else                         call EMIT_PI (P_LINE,KEY_NO,N); /* pitch code */     TYPE = 1;  SIZE = RESOLUTION(N);     do while BLKS > 0; /* loop over rhythmic codes to emit */       do while (SIZE > BLKS); /* reduce */         SIZE = SIZE / 2;         TYPE = TYPE * 2;       end;       BLKS = BLKS - SIZE;       call NUM_PUSH (R_LINE,TYPE,0); /* push rhythmic value */       if BLKS > 0 then call PUSH (R_LINE,'+'); /* if tied note */     end;     I = R_LINE(0) - P_LINE(0) + 1;  if I < 1 then I = 1; /* line up lengths */     K = P_LINE(0) - R_LINE(0) + 1;  if K < 1 then K = 1;     SPACES(0) = I;  call PUSH (P_LINE,SPACES);     SPACES(0) = K;  call PUSH (R_LINE,SPACES);     call EMIT_VOL (V_LINE, VOL);      I = P_LINE(0) - V_LINE(0);  if I < 1 then I = 1;     SPACES(0) = I;  call PUSH (V_LINE,SPACES);     call EMIT_RTE (T_LINE, RTE);     I = P_LINE(0) - T_LINE(0);  if I < 1 then I = 1;     SPACES(0) = I;  call PUSH (T_LINE,SPACES);   end EMIT_NOTE;   EMIT_VECTOR:  procedure; /* emit all notes in vector */     dcl (FT,ST,CT)  fixed;     dcl (I,DT,MPSN) fixed;     if VECTOR_LEN > 5 then do; /* begin chord symbol */       if V_LINE(0) <= P_LINE(0) then call PUSH (V_LINE,' ');       if T_LINE(0) <= P_LINE(0) then call PUSH (T_LINE,' ');       call PUSH (P_LINE,'[');        call PUSH (R_LINE,' ');     end;     do I = 0 to VECTOR_LEN-1 by 5; /* loop over notes in vector */       call EMIT_NOTE(VECTOR(I),VECTOR(I+2),VECTOR(I+3),VECTOR(I+4)); /* emit the note to P and R lines */     end;     if VECTOR_LEN > 5 then do; /* close chord symbol */       if V_LINE(0) <= P_LINE(0) then call PUSH (V_LINE,' ');       if V_LINE(0) <= P_LINE(0) then call PUSH (T_LINE,' ');       P_LINE(0) = P_LINE(0) - 1;       call PUSH (P_LINE,'] ');       call PUSH (R_LINE,' ');     end;   end EMIT_VECTOR;   EMIT_MEASURE:  procedure(CODE); /* create SCRIPT lines for measure */      dcl CODE boolean;      if CODE then do; /* emit measure header */        call new.line; /* blank line */        call new.line; call outs('  /* Measure '); /* emit measure header */        call outi(VECTOR_POS/BLOCKS+1,0); call outs(' */');      end;      call SPACE_TRIM(P_LINE); /* clear extra spaces out */      if P_LINE(0) > 0 then do; /* measure exists */         call new.line; call outs('  P '); call outs(P_LINE); /* emit lines */         call SPACE_TRIM(R_LINE);         call new.line; call outs('  R '); call outs(R_LINE);         if VOL_DATA then do; /* volume line must be emitted */            call SPACE_TRIM(V_LINE);            call new.line; call outs('  V '); call outs(V_LINE);         end;         if RTE_DATA then do; /* RTE    line must be emitted */            call SPACE_TRIM(T_LINE);            call new.line; call outs('  T '); call outs(T_LINE);         end;      end;      P_LINE(0) = 0; R_LINE(0) = 0; /* clear P and R lines */      V_LINE(0) = 0; T_LINE(0) = 0; /* clear V and T lines */      VOL_DATA = false; RTE_DATA = false; /* assume no V or T needed */   end EMIT_MEASURE;   /* main code begins here */   dcl (DT,NS,PSN)    fixed;   dcl REAR_LIMIT     fixed;   dcl NEW_TIME       fixed;   dcl EMITTED_POS    fixed;   dcl NEW_MEAS_FLAG  boolean;   dcl EMIT_FLAG      boolean;   dcl STARTLOOP_FLAG boolean; /* true for loop start */   dcl ENDLOOP_FLAG   boolean; /* true for loop end */   dcl END_OF_LIST    boolean;   dcl LOOP_FLAGS     boolean;   if (CLICK_RATE * BEAT_MEAS(N)) mod BEAT_NOTE(N) <> 0   then print 'Warning:  There must be an integral number of clicks per measure';   call BUILD_TEMPLATE; /* template is the same for every measure */   P_LINE(0) = 0;  R_LINE(0) = 0; /* clear P and R lines */   V_LINE(0) = 0;  T_LINE(0) = 0; /* clear V and T lines */   TIME          = 0;   TIME_CARRIES  = 0;   if syn.med<>2 then do;      WRAP_MODE     = false;      NEXT_START    = shr(n.lookup(DT_PTR(N)) - 8,1); /* get first start time */      LOOP_FLAGS    = (SEQDATA(SEQ.ILS.PTRS+N) <> 0) \ shl(SEQDATA(SEQ.ILE.PTRS+N) <> 0,1);   end;   else do;      nmsb=0;                        /* init time */      nlsb=0;      write(mam)=dt_PTR(n);          /* get thd.for */      nlsp=read(md);                 /* rel to nah.ptr */      wd  =0;      call LOOKUP_NOTE;              /* see if another note (nlsp<>0), get contents, set nmsb, nlsb for delta field */   end;   PSN           = 0; /* init position in template */   EMITTED_POS   = 0;   VECTOR_POS    = 0;   VECTOR_LEN    = 0;   FINAL_POS     = 0;   EMIT_FLAG     = false;   NEW_MEAS_FLAG = true;   END_OF_LIST   = false; /* clear end of list flag */   do while not END_OF_LIST; /* emit measures until track runs out */     DT = TEMPLATE(PSN mod BLOCKS); /* get template value */     if syn.med<>2 then do;        NEW_TIME = TIME + DT/2;        /* max time of note for this block */        if NEW_TIME igt MAX_INT#   then WRAP_MODE = true; /* time has wrapped around */        if NEW_TIME igt MAX_INT#/2 then REAR_LIMIT = NEW_TIME - MAX_INT#/2;        else                            REAR_LIMIT = 0;        NS = NEXT_START; /* compute NS as NEXT_START adjusted for wrap around */        if WRAP_MODE & NEXT_START ilt REAR_LIMIT        then NS = NEXT_START + MAX_INT#;        if (LOOP_FLAGS&1) <> 0 then do; /* check indep loop start */          if  (TIME_CARRIES = SEQDATA(SEQ.ILS.PTCS+N))          and (shl(TIME,1) ige SEQDATA(SEQ.ILS.PLTS+N)-8)          then do;            STARTLOOP_FLAG = true;  LOOP_FLAGS = (LOOP_FLAGS&2);            EMIT_FLAG = true; /* force emit to this point */          end;        end; /* of check loop start */        if (LOOP_FLAGS&2) <> 0 then do; /* check indep loop end */          if  (TIME_CARRIES = SEQDATA(SEQ.ILE.PTCS+N))          and (shl(TIME,1) ige SEQDATA(SEQ.ILE.PLTS+N)-8)          then do;            ENDLOOP_FLAG = true;    LOOP_FLAGS = (LOOP_FLAGS&1);            EMIT_FLAG = true; /* force emit to this point */          end;        end; /* of check loop end */        if NEXT_START = (-1) and LOOP_FLAGS = 0 /* reached end of file list */        then END_OF_LIST = true; /* signal end */     end;     else do;            /* 32 track format */        wmsb=time_carries;        wlsb=time+(dt/2);        if wlsb ilt (dt/2)        then wmsb=wmsb+1;        if nlsp=0 then END_OF_LIST = true;  /* signal end */        else do;           if (nmsb=0)&(nlsb ilt zero.time) then do;              zmsb=0; zlsb=0;           end;           else do;              /* get time of this note relative to 0.000 */              zlsb=nlsb-zero.time;              if nlsb ilt zero.time then zmsb=nmsb-1;              else                       zmsb=nmsb;           end;           if  (nlsp<>0)           and (((zmsb ilt wmsb))           or   ((zmsb  =  wmsb)           and   (zlsb ile wlsb)))           and ((note_data1&"174001")="104001") then do;              STARTLOOP_FLAG = true;                EMIT_FLAG = true; /* force emit to this point */              wd=wd+4;              call lookup_note;           end; /* of check loop start */           else if  (nlsp<>0)           and      (((zmsb ilt wmsb))           or        ((zmsb  =  wmsb)           and        (zlsb ile wlsb)))           and      ((note_data1&"174001")="110001") then do;              ENDLOOP_FLAG = true;                  EMIT_FLAG = true; /* force emit to this point */              wd=wd+4;              call lookup_note;           end; /* of check loop end */        end;     end;     if  ((syn.med<>2)                /* 16 track format */     and  ((REAR_LIMIT ile NS) and (NS ile NEW_TIME)))     or  ((syn.med=2)     and  (((zmsb ilt wmsb))     or    ((zmsb  =  wmsb)     and    (zlsb ile wlsb))))     or  (END_OF_LIST)     or  (EMIT_FLAG)      then do; /* process stored notes further */       if VECTOR_LEN > 0 then do; /* notes were loaded */         if VECTOR_POS igt EMITTED_POS /* gap exists before this vector */         then call EMIT_NOTE (REST.MARK,VECTOR_POS-EMITTED_POS,0,0); /* emit rest */         EMITTED_POS = VECTOR_POS; /* have now emitted up to here */         call SORT_VECTOR; /* sort durations */         if (PSN ilt FINAL_POS) and (not END_OF_LIST) then do; /* next note is before prior note end */           call ADD_REST (PSN - VECTOR_POS); /* add rest interval into vector */           FINAL_POS = PSN; /* adjust final position */         end;         call EMIT_VECTOR; /* emit notes in stack to P and R lines */         EMITTED_POS = VECTOR_POS + VECTOR(VECTOR_LEN-5+2); /* update by shortest duration */         VECTOR_LEN = 0; /* clear vector */       end;       if EMIT_FLAG or END_OF_LIST then do; /* emit lines for measure */         if PSN igt EMITTED_POS /* gap exists after emitted vector */         then call EMIT_NOTE (REST.MARK,PSN-EMITTED_POS,0,0); /* emit rest */         EMITTED_POS = PSN; /* have now emitted up to here */         call EMIT_MEASURE (NEW_MEAS_FLAG); /* emit the measure */         EMIT_FLAG = false;         NEW_MEAS_FLAG = false;         if PSN mod BLOCKS = 0 then NEW_MEAS_FLAG = true;       end;       if STARTLOOP_FLAG then do; /* emit indep loop start statement */         call new.line; call outs('  Startloop Here');         STARTLOOP_FLAG = false;       end;       if ENDLOOP_FLAG   then do; /* emit indep loop end   statement */         call new.line; call outs('  Endloop Here');         ENDLOOP_FLAG = false;       end;       if not END_OF_LIST then do; /* read further */         VECTOR_POS = PSN; /* establish base position of vector */         if syn.med<>2 then do;            call FILE_LOAD (REAR_LIMIT,NEW_TIME); /* read notes in this block */         end;         else do;            call FILE_LOAD (wmsb,wlsb); /* read notes in this block */         end;       end;     end; /* of case for times in range */     TIME = TIME + DT; /* update time */     if syn.med<>2 then do;        if WRAP_MODE then do; /* wrap time */           TIME = TIME - MAX_INT#;           WRAP_MODE = false;           TIME_CARRIES = TIME_CARRIES + 1; /* count carries */        end;     end;     else do;        if time ilt dt        then time_carries=time_carries+1;     end;     PSN = PSN + 1; /* update position in template */     if PSN mod BLOCKS = 0 then EMIT_FLAG = true; /* set emit flag at end of measure */   end; /* of do while */   MEASURE_CNT = VECTOR_POS/BLOCKS + 1; /* determine number of measures emitted */end write.snotelist;