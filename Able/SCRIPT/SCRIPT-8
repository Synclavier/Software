/* Modification:   10/20/88 - LSS - added processor check into CAN.OVERLAY*/OVERLAY.ERROR: PROC(ERRCODE); /* PRINT OUT OVERLAY ERRORS */   DCL ERRCODE FIXED;   DCL INTERNAL.MSG DATA('Not enough internal memory for this software');   DCL EXTERNAL.MSG DATA('Not enough external memory for this software');   DO CASE ABS(ERRCODE); /* BRANCH ON VARIOUS ERROR TYPES */      ; /* No error */                              /* 0 */      PRINT 'This software is incompatable with your system software'; /* 1 */      PRINT STRING(INTERNAL.MSG);                   /* 2 */      PRINT STRING(INTERNAL.MSG);                   /* 3 */      PRINT STRING(EXTERNAL.MSG);                   /* 4 */      PRINT STRING(EXTERNAL.MSG);                   /* 5 */      PRINT 'System file not found or zero length'; /* 6 */      PRINT 'System file is not an XPL program';    /* 7 */      PRINT 'System file requires a later processor model'; /* 8 */   END;END OVERLAY.ERROR;can.overlay:  proc (dev,sec,int.reserved,ext.reserved,secbuf) fixed;   dcl (dev,sec)    fixed; /* DEVICE and starting SECTOR of program to overlay */   dcl int.reserved fixed; /* WORDS of internal memory to reserve */   dcl ext.reserved fixed; /* SECTORS of external memory to reserve */   dcl secbuf       fixed array; /* a 1 SECTOR work buffer */   dcl (i,j)        fixed;   /* NOTE:  this routine computes whether or not the program pointed to      by SEC can be overlayed to give certain memory constraints.  If      okay to overlay, routine returns 0; otherwise it returns a negative      value as follows:            0:  okay to overlay           -1:  desired pgm is an XPL-5 or earlier compilation           -2:  not enough int. memory to hold core procedures,vars, etc.           -3:  not enough int. memory for reserved words           -4:  not enough ext. memory to hold swap procedures           -5:  not enough ext. memory for reserved sectors           -6:  zero sector (means an empty file)           -7:  not an XPL program at all           -8:  program compiled with a newer processor revision    */    if ((dev=0) and (sec=0)) then return (-6); /* file not found (should return -8) */    if (((dev and "377")=0) and (sec=0)) then return (-6); /* empty file */    call readdata(dev,sec,secbuf,256); /* read first sector of target pgm */    j=secbuf(1);    i=secbuf(j+c#vstart)+secbuf(j+c#vlngth)+secbuf(j+c#stklen); /* words need for core procs, vars, pdl */    j=secbuf(j+c#swplen); /* sectors needed for swap procedures */    if (secbuf(0) <>  "100377")    or (secbuf(1) IGT (256-c#conlen))        then return (-7); /* not an XPL program */    if secbuf(secbuf(1)+c#version) <> c#current_version then return (-1); /* program compiled before -7 */    if (shr(secbuf(secbuf(1)+c#cmopt), 8) and "7") > processor_type    then return (-8); /* program compiled with later processor */    if                i IGT LOC.LOAD         then return (-2); /* not enough int mem for core procs */    if (int.reserved+i) IGT LOC.LOAD         then return (-3); /* not enough int mem for resrvd words */    if                j IGT core(LOC.EMSIZE) then return (-4); /* not enough ext mem for swap procs */    if (j+ext.reserved) IGT core(LOC.EMSIZE) then return (-5); /* not enough ext mem for resrvd secs */    return 0; /* okay to overlay */end can.overlay;/* $subtitle Main Code Section */DCL (I,J,K,L,CHR)     FIXED;DCL (MSW,LSW)         FIXED;DCL (OVPTR)           FIXED;DCL CNAM(F#NAME_LEN)  FIXED; /* NAME BUFFER */OVPTR=LOC.P2; /* NORMAL OVERLAY IS TO 'PASS 2' */IF CORE(LOC.RST)=3 /* IF PLOT COMMAND TYPED */THEN OVPTR=LOC.MPLT; /* OVERLAY FROM HERE TO MUSIC PRINTING */IF CORE(LOC.RST)=4 /* IF REVERSE COMMAND TYPED */THEN OVPTR=LOC.RT; /* OVERLAY FROM HERE TO REVERSE COMPILER */IF (OVPTR=LOC.MPLT) AND (CORE(OVPTR)=0)THEN DO; /* NO MUSIC PRINTING AVAILABLE */   PRINT 'Music Printing Software is not available on this system';   CALL EXIT(-1);END;/* CHECK FOR PRE-COMPILED FILE OR COMPILE IT */IF CORE(LOC.FTYP)=T#SYNC THEN DO; /* SYNCLAVIER FILE - INDICATES PRE-COMPILED */  IF EXAMOUNT=0 THEN DO; /* INTERNAL MEMORY */     IF (CFLNGTH IGT TIMBMAX+SEQNMAX)     OR (CFSLEN  IGE 255) THEN DO; /* FILE TOO BIG */       PRINT 'Compiled Program is too large for memory configuration.';       CALL EXIT(-1);     END;     CALL READDATA(CFDEVICE,CFSTART,LOCATION(TIMBLOC),CFLNGTH); /* READ IN CURRENT FILE */     DO I=0 TO 255; SEQDATA(I)=CORE(TIMBLOC+I); END; /* MOVE MISC AREA TO SEQDATA */     IF  SEQDATA(MAGIC.NUMBER)=MAGIC#5     THEN DO;  /* 32 TRACK FORMAT BUT NO EXTERNAL MEMORY */        PRINT 'External memory is required to play this sequence';        CALL EXIT(-1);     end;     IF   SEQDATA(MAGIC.NUMBER)<>MAGIC#4       /* NOT NEW FORMAT - SET CORRECT PARAMETER LENGTH FIELD */     THEN SEQDATA(SEQ.PLEN)=3072;              /* SAVE LENGTH OF OLD TIMBRE AREA FOR OVERLAY - BUT LEAVE AS OLD FORMAT SEQUENCE */     TIMBLOC=TIMBLOC+256;                      /* SKIP OVER MISC AREA JUST READ IN; POINT TO ACTUAL TIMBRES */     TIMBLEN=SEQDATA(SEQ.PLEN);                /* LOOK UP LENGTH OF TIMBRE INFO */     SEQNLOC=TIMBLOC+TIMBLEN;                  /* COMPUTE LOCATION OF SEQUENCER NOTES */     SEQNLEN=SEQDATA(SEQ.SLEN)-256;            /* LENGTH OF SEQUENCER NOTES (EXCLUDING MISC AREA) */     IF SEQDATA(MAGIC.NUMBER)=MAGIC#4          /* NEW FORMAT - SKIP OVER SECOND MISC AREA */     THEN SEQNLOC=SEQNLOC+256;                 /* SKIP SECOND MISC AREA; POINT TO NOTE INFO */     TIMBMAX=SEQNLOC-TIMBLOC;                  /* RECOMPUTE VALID MAX'S FOR LATER CALLS TO EMIT.T */     SEQNMAX=LOC.LOAD-SEQNLOC;  END;  ELSE DO;                                     /* EXTERNAL MEMORY */     IF (CFSLEN+1)  IGE EXAMOUNT THEN DO;      /* FILE TOO BIG - GIVE us ONE SECTOR LEEWAY */        PRINT 'Compiled Program is too large for external memory configuration';        CALL EXIT(-1);     END;     CALL READDATA(CFDEVICE,CFSTART,SEQDATA,256);     /* READ IN MISC AREA */     IF (SEQDATA(MAGIC.NUMBER)=MAGIC#5     ||  SEQDATA(MAGIC.NUMBER)=MAGIC#6     ||  SEQDATA(MAGIC.NUMBER)=MAGIC#7) then do;      /* 32 TRACK FORMAT */        IF TIMBLOC=0 then timbloc=1;                  /* NOT SECTOR 0    */        IF TIMBLOC+CFSLEN+1 IGE EXAMOUNT THEN DO;     /* FILE TOO BIG - GIVE us ONE SECTOR LEEWAY */           PRINT 'Compiled Program is too large for external memory available';           CALL EXIT(-1);        END;        RELEASEM=3;        CALL EXT.READDATA(CFDEVICE,CFSTART,STACKLOC,STACKLEN,TIMBLOC,CFSLEN); /* READ CURRENT FILE TO EXT MEMORY. USE STACKLOC/STACKLEN AS BUFFER. */     END;     ELSE DO;        MSW = CFDEVICE;        LSW = CFSTART + 1;        IF LSW ILT CFSTART THEN MSW = MSW + 1;        CALL EXT.READDATA(MSW,LSW,STACKLOC,STACKLEN,TIMBLOC,CFSLEN-1); /* READ CURRENT FILE TO EXT MEMORY. USE STACKLOC/STACKLEN AS BUFFER. */        TIMBLEN=SEQDATA(SEQ.PLEN);                /* LOOK UP LENGTH OF TIMBRE INFO (IF THERE) */        SEQNLEN=SEQDATA(SEQ.SLEN)-256;            /* LENGTH OF SEQUENCER NOTES (EXCLUDING MISC AREA) */        IF SEQDATA(MAGIC.NUMBER)<>MAGIC#4         /* NOT NEW FORMAT - SET CORRECT PARAMETER LENGTH FIELD */        THEN DO;                                  /* SET PLEN, MOVE NOTES UP */           SEQDATA(SEQ.PLEN)=3072;                /* SAVE LENGTH OF OLD TIMBRE AREA FOR OVERLAY - BUT LEAVE AS OLD FORMAT SEQUENCE */           TIMBLEN=3072;                          /* SET THESE ITEMS VALIDLY */           SEQNLOC=TIMBLOC+12;                    /* AND NOTES START HERE (12 SECTORS) */        END;        ELSE DO;                                  /* NEW FORMAT */           SEQNLOC=TIMBLOC+SHR(TIMBLEN+255,8);    /* NOTES SHOULD START HERE */           CALL COPY.EXT.MEM(TIMBLOC+1,TIMBLEN,SEQNLOC,0,SEQNLEN); /* COPY NOTES ON TO SECTOR BOUNDARY (SKIPPING EXTRA MISC COPY) */        END;        TIMBMAX=SHL(SEQNLOC-TIMBLOC,8);           /* RECOMPUTE VALID MAX'S FOR LATER CALLS TO EMIT.T */        IF DEFLOC-SEQNLOC IGE 255        THEN SEQNMAX="177400";        ELSE SEQNMAX=SHL(DEFLOC-SEQNLOC,8);     end;  END;END; /* SYNCLAVIER FILE *//* $PAGE - COMPILATION OF TEXT FILE */ELSE DO; /* MUST COMPILE */  IF CORE(LOC.FTYP)=T#TEXT THEN DO; /* UNCOMPILED FILE - COMPILE IT, OTHERWISE IGNORE CURRENT FILE */      RELEASEM=0; /* ASSUME NOT RELEASE M FORMAT */    IF CORE(LOC.CLEN)<>0 /* CURRENT FILE IS NOT NULL */    THEN DO; /* PRINT VERSION MSG ONLY IF ACTUALLY COMPILING */      PRINT; PRINT 'SCRIPT Compiler ',STRING(rel.version),' - ',string(rel.date);    END;    CHR=GC; /* INSTALL COMPILER SYMBOL TABLE IN MEMORY */    DO WHILE CHR<>0; /* LOOP UNTIL NULL AT END OF SYMBOL FILE */      TOKEN=0;      DO I=0 TO CHR-1; /* SCAN OFF BYTES */        CHR=GC; /* GET THE BYTE */        IF CHR>95 THEN CHR=CHR-32;  /* MAP TO UPPER CASE TO SIMPLIFY SYMBOL ENTRY */        IF I THEN NAME(TOKEN)=NAME(TOKEN)\SHL(CHR,8); /* OR IN SECOND */        ELSE DO; /* FIRST BYTE */          TOKEN=TOKEN+1; NAME(TOKEN)=CHR; /* SAVE IT */        END;      END;      NAME(0)=TOKEN; /* SAVE COUNT */      TOKEN=GC; INFO=GC; /* GET NEW STUFF */      CALL S.LOOKUP; /* GET THE SYMBOL */      CHR=S.DEFINE(NAME.PT,HASHCODE); /* DEFINE THE SYMBOL */      CALL PTOK(CHR,TOKEN); CORE(STLOC+CHR+2)=INFO; /* SAVE SYMBOL INFO */      CHR=GC; /* GET NEXT CHAR */    END; /* OF DO WHILE */    SFDEVICE=CFDEVICE; SFSTART=CFSTART; /* NOW SET UP FOR READ OF SOURCE FILE */    SFSLEN  =CFSLEN;   SFREM  =CFLNGTH;    BC=0; SFFLP=0; SFPOS=0; SFSEC=0; /* PRIME BUFFERS */    READL=SFBUFL; /* READ FOR LENGTH OF BUFFER */    IF SHR(READL,8) IGT SFSLEN THEN READL=SHL(SFSLEN,8);    CALL READDATA(SFDEVICE,SFSTART,LOCATION(SFLOC),READL); /* READ FIRST BLOCK */    CALL S.BLOCK;  /* ENTER USER SYMBOL BLOCK */    CALL SCAN;     /* GET FIRST TOKEN */    RELEASEM = 1;  /* ALWAYS DO RELEASE M FORMAT */    IF TOKEN=T.RELEASEM THEN DO;       /* RELEASE M DESIRED    */       CALL SCAN;                      /* GET NEXT TOKEN       */    END;    IF EXAMOUNT=0 THEN DO;       PRINT 'External memory is required for this software';       CALL EXIT(-1);    END;    SN2.TIMBRES=1;                  /* DISALLOW SFM TIMBRES */    IF TIMBLOC<3 THEN DO;           /* MOVE TIMBLOC UP      */       IF TIMBLOC<>0 THEN DO;          PRINT 'System error with TIMBLOC';          CALL EXIT(-1);       END;       TIMBLOC=3;                   /* start timbres here */       TIMBMAX=TIMBMAX-768;    end;    DO i=0 TO SEQ.OCTRATIO;        /* COPY OVER DEFAULTS UP TO OCTAVE RATIO */      SEQDATA(i)=BASIC.SEQ(i);     /* (THE REST ARE ZEROES) */    END;    DO I=0 TO 255;       CALL EMIT.N(0);                 /* EMIT EMPTY NAH */    END;    SEQDATA(NEW.SEQ.CLICK)=500;        /* MILLISECONDS */    SEQDATA(NEW.SEQ.CRM  )=4;    SEQDATA(MAGIC.NUMBER )=MAGIC#5;    DO WHILE TOKEN<>T.EOF; /* LOOP UNTIL EOF */      IF      TOKEN=T.TIME   THEN CALL NOTE.STATEMENT(T.TIME); /* EMIT NOTE */      ELSE IF TOKEN=T.STMT   THEN CALL STMT; /* PROCESS MOST STATEMENTS */      ELSE IF TOKEN=T.END    THEN CALL END.STATEMENT;      ELSE IF TOKEN=T.TIMBRE THEN CALL A.T.V.STATEMENT(1); /* TIMBRE STATEMENT */      ELSE IF (TOKEN=T.PFIELD)&(INFO=0) THEN CALL A.T.V.STATEMENT(2); /* 'VOL' */      ELSE DO; /* EXAMINE ERROR */        IF TOKEN=T.UND THEN CALL ER.UFLS(UFSP);        ELSE                CALL ER.UNS; /* UNRECOGNIZED STATEMENT */        CALL SCAN;      END;    END; /* OF DO WHILE */    CALL S.ENDBLOCK; /* EXIT USER SYMBOL BLOCK */  END; /* OF CASE FOR UNCOMPILED FILE */   /* $SUBTITLE  End of Compilation */  IF RELEASEM=0 THEN DO;     IF EDITINFO.PRESENT=0 THEN DO; /* CLOSE OUT NOTELIST/TIMBRE INFO HERE, IF NO EDIT INFO */        CALL WRITE.EMPTY.TRACKS; /* MUST FILL OUT TRACKS */        CALL PUSH(0); CALL PUSH(SEQNLEN); /* PUSH POINTERS FOR TOP TRACK */     END;     IF SFM.TIMBRES<>0 THEN DO;          /* FINISH UP SFM FORMAT SEQUENCE */       CALL EMIT.T(-1);                  /* TERMINATE TIMBRE LIST WITH A -1 */       DO WHILE TIMBLEN<3072; CALL EMIT.T(0); END; /* SFM SEQUENCE - FIXED 3072 WORDS FOR TIMBRE AREA */       SEQDATA(MAGIC.NUMBER)=MAGIC#3;    /* SET TO TYPE 3 */     END;     ELSE IF USE.NEW.FORMAT<>0     THEN SEQDATA(MAGIC.NUMBER)=MAGIC#4; /* SET TO TYPE 4 IF NEW FORMAT TIMBRE ENCOUNTERED */     DO I=0 TO 16; /* CREATE POINTERS FOR TRACKS & TOP */       SEQDATA(SEQ.POINTERS+I)=CORE(STACKLOC+I+I+1)+256;       IF  (SEQDATA(SEQ.ILS.PTRS+I)<> 0)       AND (SEQDATA(SEQ.ILE.PTRS+I) = 0) THEN CALL ER.MEL(I+1); /* MISSING END LOOP STATEMENT */     END;     SEQDATA(SEQ.PLEN)=TIMBLEN;          /* SAVE LENGTH OF TIMBRE STUFF */  END;  ELSE DO;                               /* RELM */  END;                                   /* NOT MUCH TO DO */END; /* OF COMPILATION *//* $SUBTITLE  Overlay to RTP, or to Monitor, as Required */ IF NUMERRS>0 THEN CALL EXIT(-1); /* ERROR(S) ENCOUNTERED - RETURN TO MONITOR *//* SUCCESSFUL COMPILATION *//* COMPACT FILE & PREPARE FOR OVERLAY */DCL (BAS.PTR,BAS.LEN) FIXED;DCL (PAR.PTR,PAR.LEN) FIXED;DCL (NAH.PTR,NAH.LEN) FIXED;DCL (INF.PTR,INF.LEN) FIXED;IF RELEASEM<>0 THEN DO;   BAS.PTR=1; BAS.LEN=2;   IF RELEASEM=1 THEN DO; /* WE HAD TO COMPILE THIS M-FORMAT SEQUENCE */      PAR.PTR=TIMBLOC; PAR.LEN=SHR(TIMBLEN+255,8);      NAH.PTR=SEQNLOC; NAH.LEN=SHR(SEQNLEN+255,8)-EDITINF.LEN;      IF NAH.PTR<>PAR.PTR+PAR.LEN THEN DO;         CALL COPY.EXT.MEM.SEC(NAH.PTR,PAR.PTR+PAR.LEN,NAH.LEN);         NAH.PTR=PAR.PTR+PAR.LEN;      END;      IF EDITINF.PTR<>0 THEN DO;         INF.PTR=SEQNLOC+EDITINF.PTR;         INF.LEN=EDITINF.LEN;         CALL COPY.EXT.MEM.SEC(INF.PTR,NAH.PTR+NAH.LEN,INF.LEN);         INF.PTR=NAH.PTR+NAH.LEN;      END;      ELSE INF.PTR=NAH.PTR+NAH.LEN;      SEQDATA(NEW.SEQ.NUMTIMBS) = PAR.NUMT;      SEQDATA(NEW.SEQ.NUMSEC) = INF.PTR+INF.LEN-BAS.PTR;      SEQDATA(NEW.SEQ.BAS  )  =0;      SEQDATA(NEW.SEQ.BAS+1)  =BAS.LEN;      SEQDATA(NEW.SEQ.PAR  )  =PAR.PTR-BAS.PTR;      SEQDATA(NEW.SEQ.PAR+1)  =PAR.LEN;      SEQDATA(NEW.SEQ.NAH  )  =NAH.PTR-BAS.PTR;      SEQDATA(NEW.SEQ.NAH+1)  =NAH.LEN;      SEQDATA(NEW.SEQ.INF  )  =INF.PTR-BAS.PTR;      SEQDATA(NEW.SEQ.INF+1)  =INF.LEN;      WRITE(MAM)=BAS.PTR;      CALL COPY.OUT(ADDR(SEQDATA(0)),512);      CFSLEN=INF.PTR-BAS.PTR+INF.LEN; /* LENGTH OF CURRENT FILE */   END;   ELSE; /* OTHERWISE EVERYTHING SHOULD BE SET UP CORRECTLY */END;IF CORE(LOC.RST)=1 THEN DO; /* CONVERT COMMAND:  RETURN CURRENT FILE */  IF RELEASEM=3 THEN DO;    /* CONVERT PRE-COMPILED FILE? */     PRINT 'Current file has already been converted';     CALL EXIT(-1);  END;  IF RELEASEM=0 THEN DO;     IF (SEQDATA(MAGIC.NUMBER)=MAGIC#4) THEN DO;     /* WRITE OUT EXTRA SEQDATA SECTOR FOR NEW FORMAT COMPILATION */        DO I=0 TO 255; CALL EMIT.T(SEQDATA(I)); END; /* EMIT SECOND COPY OF MISC AREA FOR EASIER READ IN */     END;     IF EXAMOUNT=0 THEN DO;           /* INTERNAL MEMORY - RETURN CURRENT FILE IN MEMORY */        DO I=0 TO 255; CORE(TIMBLOC-256+I)=SEQDATA(I); END; /* STORE MISC AREA ON FRONT OF COMPILED FILE */        I=0;                      /* COPY NOTE INFO DOWN AT END OF TIMBRES */        DO WHILE I<>SEQNLEN;      /* COPY EACH NOTE WORD */           CORE(TIMBLOC+TIMBLEN+I)=CORE(SEQNLOC+I); I=I+1;        END;        CORE(LOC.CMED)=1; /* INDICATE IN-CORE FILE */        CORE(LOC.CSEC+1) = 0; /* NO DEVICE */        CORE(LOC.CSEC)=TIMBLOC-256; /* START OF CURRENT FILE (PTR TO WHERE WE STORED MISC AREA) */        CORE(LOC.CLEN)=TIMBLEN+SEQNLEN+256; /* FILE LENGTH (SECOND MISC AREA INCLUDED IN TIMBLEN IF MAGIC#=4.  INCLUDE MAIN MISC AREA IN FILE LENGTH. */        CORE(LOC.CSLN)=SHR(CORE(LOC.CLEN)+255,8); /* FILE LENGTH IN SECTORS */        CORE(LOC.FTYP)=4; /* INDICATE NEW FILE IS SYNCLAVIER FILE */        CORE(LOC.STRD)=1; /* INDIC STORED FILE */        CORE(LOC.SVD) =0; /* INDICATE FILE IS NOT SAVED */     END;     ELSE DO;                      /* EXTERNAL MEMORY */        J=256; K=0;                /* COMPUTE FILE LENGTH IN WORDS, SECTORS.  START WITH MISC AREA */        J=J+TIMBLEN;               /* ADD IN TIMBRES, PLUS POSSIBLE SECOND MISC */        IF J ILT TIMBLEN THEN K=K+256;        J=J+SEQNLEN;               /* AND ACTUAL NOTES */        IF J ILT SEQNLEN THEN K=K+256;        IF J+255 ILT 255 THEN K=K+256; /* OVERFLOW DURING ROUNDING */        K=K+SHR(J+255,8);          /* GET # OF SECTORS IN FILE */        L=CORE(LOC.WSLN);          /* GET LENGTH OF WORK FILE IN SECTORS */        IF CORE(LOC.WMED)<>0 THEN L=SHR(LOC.LOAD-STACKLOC,8); /* START WORK SPACE AT STACK LOC IF IN CORE WORK FILE */        IF K IGT L THEN DO;        /* TOO BIG FOR .WORK */           PRINT 'Compiled Program is too large for .WORK space';           CALL EXIT(-1);        END;        IF CORE(LOC.WMED)=0 THEN DO;  /* STORE CURRENT FILE IN .WORK */           CALL COPY.EXT.MEM(SEQNLOC,0,TIMBLOC,TIMBLEN,SEQNLEN); /* COPY NOTES DOWN ON TOP OF TIMBRES (OR TIMBRES + SECOND MISC IF NEW FORMAT) */           MSW = CORE(LOC.WSEC+1); /* DEVICE AND MSB OF STARTING SECTOR */           LSW = CORE(LOC.WSEC);   /* LSW OF STARTING SECTOR */           CALL WRITEDATA(MSW,LSW,SEQDATA,256); /* MISC AREA */           I = ((LSW + 1) ILT LSW); /* I = 1 IF 32-BIT OVERFLOW WILL RESULT */           CALL EXT.WRITEDATA(MSW + I,LSW + 1,STACKLOC,STACKLEN,TIMBLOC,K-1); /* WRITE OUT INFO */           CORE(LOC.CMED)=0; /* INDICATE DISK FILE */        END;        ELSE DO; /* IN MEMORY WORK FILE - COPY BACK IN FROM EXT MEMORY */           MSW = 0;           LSW = STACKLOC;           DO L=0 TO 255; CORE(LSW+L)=SEQDATA(L); END; /* STORE SEQDATA WHERE .WORK GOES */           WRITE(MAM)=TIMBLOC;           CALL COPY.IN(LSW+256,TIMBLEN);           WRITE(MAM)=SEQNLOC;           CALL COPY.IN(LSW+256+TIMBLEN,SEQNLEN);           CORE(LOC.CMED)=1; /* INDICATE IN - CORE FILE */        END;        CORE(LOC.CSEC+1)=MSW; /* DEVICE AND MSB OF STARTING SECTOR */        CORE(LOC.CSEC)=LSW; /* START OF CURRENT FILE (PTR TO WHERE WE STORED MISC AREA- ON DISK OR IN MEMORY) */        CORE(LOC.CLEN)=J; /* FILE LENGTH WORDS */        CORE(LOC.CSLN)=K; /* FILE LENGTH IN SECTORS */        CORE(LOC.FTYP)=T#SYNC; /* INDICATE NEW FILE IS SYNCLAVIER FILE */        CORE(LOC.STRD)=1; /* INDIC STORED FILE */        CORE(LOC.SVD) =0; /* INDICATE FILE IS NOT SAVED */     END;  END;  ELSE DO;            /* RELEASE M CONVERSION */     J=SHL(INF.PTR+INF.LEN-BAS.PTR,8);    /* LENGTH IN WORDS */     K=INF.PTR+INF.LEN-BAS.PTR;           /* LENGTH IN SECTORS */     L=CORE(LOC.WSLN);          /* GET LENGTH OF WORK FILE IN SECTORS */     IF CORE(LOC.WMED)<>0 THEN L=SHR(LOC.LOAD-STACKLOC,8); /* START WORK SPACE AT STACK LOC IF IN CORE WORK FILE */     IF K IGT L THEN DO;        /* TOO BIG FOR .WORK */        PRINT 'Compiled Program is too large for .WORK space';        CALL EXIT(-1);     END;     IF CORE(LOC.WMED)=0 THEN DO;  /* STORE CURRENT FILE IN .WORK */        MSW = CORE(LOC.WSEC+1); /* DEVICE AND MSB OF STARTING SECTOR */        LSW = CORE(LOC.WSEC);   /* LSW OF STARTING SECTOR */        CALL EXT.WRITEDATA(MSW,LSW,STACKLOC,STACKLEN,BAS.PTR,K); /* WRITE OUT INFO */        CORE(LOC.CMED)=0; /* INDICATE DISK FILE */     END;     ELSE DO; /* IN MEMORY WORK FILE - COPY BACK IN FROM EXT MEMORY */        MSW = 0;        LSW = STACKLOC;        WRITE(MAM)=BAS.PTR;        CALL COPY.IN(LSW,J);     END;     CORE(LOC.CSEC+1)=MSW; /* DEVICE AND MSB OF STARTING SECTOR */     CORE(LOC.CSEC)=LSW; /* START OF CURRENT FILE (PTR TO WHERE WE STORED MISC AREA- ON DISK OR IN MEMORY) */     CORE(LOC.CLEN)=J; /* FILE LENGTH WORDS */     CORE(LOC.CSLN)=K; /* FILE LENGTH IN SECTORS */     CORE(LOC.FTYP)=4; /* INDICATE NEW FILE IS SYNCLAVIER FILE */     CORE(LOC.STRD)=1; /* INDIC STORED FILE */     CORE(LOC.SVD) =0; /* INDICATE FILE IS NOT SAVED */  END;  DO I=0 TO F#NAME_LEN; /* GET CURRENT FILE NAME */     CNAM(I)=CORE(LOC.CFN+I);  END;  I=CNAM(0); /* GET LENGTH OF CURRENT FILE NAME */  IF I<>0 THEN DO; /* REMOVE . OR * FROM NAME AS REQUIRED */    LSW = BYTE(CNAM,I-1); /* GET LAST CHARACTER IN FILE NAME */    IF (LSW=A.PERIOD) OR (LSW=A.STAR) THEN I=I-1; /* CHECK . or * */  END;  I=I+1; /* TRY TO ADD A PERIOD AT THE END */  IF I IGT SHL(F#NAME_LEN,1) THEN I = SHL(F#NAME_LEN,1); /* LIMIT TO LAST CHARACTER */  CALL PBYTE(CNAM,I-1,A.PERIOD); /* PUT PERIOD IN NAME */  CNAM(0)=I; /* STORE NEW LENGTH */  DO I=0 TO F#NAME_LEN; /* PUT NAME BACK */     CORE(LOC.CFN+I)=CNAM(I);  END; /* PUT BACK NEW NAME */  PRINT 'Conversion Successful - current file is now called "',STRING(CNAM),'"',;  CALL EXIT(2); /* RETURN TO MONITOR */END;/* OVERLAY TO SPECIFIED PROGRAM */IF EXAMOUNT=0 THEN DO;                      /* INTERNAL MEMORY - MUST CHECK LENGTH */   IF RELEASEM<>0 THEN DO;      PRINT 'External memory is required for this software';      CALL EXIT(-1);   END;   DO I=0 TO 255; CALL EMIT.T(SEQDATA(I)); END; /* STORE MISC AREA AFTER TIMBRES FOR OVERLAY */   I=CAN.OVERLAY(CORE(OVPTR+1),CORE(OVPTR),TIMBLEN+SEQNLEN,0,CATBUF); /* SEE IF OVERLAY IS OK */   IF I<>0 THEN DO; /* COULD NOT OVERLAY */      CALL OVERLAY.ERROR(I); /* PRINT ERROR */      CALL EXIT(-1); /* DIE */   END;   I=SEQNLEN; J=0;                       /* COPY NOTES UP TO HIGH MEMORY */   DO WHILE I<>0;      I=I-1; J=J+1;      CORE(LOC.LOAD-J)=CORE(SEQNLOC+I);  /* COPY NOTES UP */   END;   SEQNLOC=LOC.LOAD-SEQNLEN;             /* NEW POINTER TO NOTES */   I=TIMBLEN;                            /* NOW COPY TIMBRE INFO & MISC AREA UP TO HIGH MEMORY */   DO WHILE I<>0;      I=I-1; J=J+1;      CORE(LOC.LOAD-J)=CORE(TIMBLOC+I);  /* COPY TIMBRE INFO & MISC AREA UP */   END;   TIMBLOC=SEQNLOC-TIMBLEN;              /* NEW POINTER TO TIMBRES & MISC */   CORE(LOC.SYNMED )=0;                  /* INTERNAL MEMORY */   CORE(LOC.SYNMISC)=SEQNLOC-256;        /* MISC DATA */   CORE(LOC.SYNTIMB)=TIMBLOC;            /* TIMBRE DATA */   CORE(LOC.SYNSEQ )=SEQNLOC;            /* START OF NOTE DATA */   CORE(LOC.SYNSTAT)=0;                  /* STATUS OF 0 - MEANS TO DO WHATEVER YOU WANT */   CORE(LOC.SYNRET )=LOC.MON;            /* IF BOMB OUT (MPLT OR SYN2) RETURN TO MONITOR */END;ELSE DO;                                 /* EXTERNAL MEMORY - STORE MISC AREA UP */   IF RELEASEM=0 then do;      I=CAN.OVERLAY(CORE(OVPTR+1),CORE(OVPTR),1024,SEQNLOC+SHR(SEQNLEN+255,8),CATBUF); /* SEE IF OVERLAY IS OK */      IF I<>0 THEN DO; /* COULD NOT OVERLAY */         CALL OVERLAY.ERROR(I); /* PRINT ERROR */         CALL EXIT(-1); /* DIE */      END;      DO I=0 TO 255; CORE(LOC.LOAD-256+I)=SEQDATA(I); END;      CORE(LOC.SYNMED )=1;                  /* EXTERNAL MEMORY */      CORE(LOC.SYNMISC)=LOC.LOAD-256;       /* MISC DATA */      CORE(LOC.SYNTIMB)=TIMBLOC;            /* TIMBRE DATA - SECTOR */      CORE(LOC.SYNSEQ )=SEQNLOC;            /* START OF NOTE DATA */      CORE(LOC.SYNSTAT)=0;                  /* STATUS OF 0 - MEANS TO DO WHATEVER YOU WANT */      CORE(LOC.SYNRET )=LOC.MON;            /* IF BOMB OUT (MPLT OR SYN2) RETURN TO MONITOR */   END;   ELSE DO;  /* release m sequence */      I=CAN.OVERLAY(CORE(OVPTR+1),CORE(OVPTR),1024,BAS.PTR+CFSLEN,CATBUF); /* SEE IF OVERLAY IS OK */      IF I<>0 THEN DO; /* COULD NOT OVERLAY */         CALL OVERLAY.ERROR(I); /* PRINT ERROR */         CALL EXIT(-1); /* DIE */      END;      CORE(LOC.SYNMED )=2;      CORE(LOC.SYNMISC)=0;      CORE(LOC.SYNTIMB)=BAS.PTR;            /* TIMBRE DATA - SECTOR */      CORE(LOC.SYNSEQ )=0;      CORE(LOC.SYNSTAT)=0;                  /* STATUS OF 0 - MEANS TO DO WHATEVER YOU WANT */      CORE(LOC.SYNRET )=LOC.MON;            /* IF BOMB OUT (MPLT OR SYN2) RETURN TO MONITOR */   END;END;CORE(LOC.RST)=2; /* SET EVENTUAL RETURN TO MONITOR STATUS */CALL OVERLAY(CORE(OVPTR+1),CORE(OVPTR),CORE(OVPTR-1)); /* OVERLAY TO TARGET PROGRAM */