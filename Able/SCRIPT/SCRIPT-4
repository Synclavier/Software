/* $subtitle Process Tempo, Timbres, Definitions, Motifs *//* 04/24/89 - cj - modified for "EVENT" storage format   *//* SCAN.TEMPO COMPUTES TEMPO INFORMATION FOR WESTERN SCALE NOTELIST...  IT SCANS OF A TEMPO RATIO, AN EQUALS SIGN,  AND THEN EITHER.  A BEAT-PER-MINUTE, PERIOD IN SECONDS, OR PERIOD IN FRAMES...  SCAN.TEMPO THEN COMPUTES DATA FOR TWO VARIABLES: 'TEMPO.MSB' AND.  'TEMPO.LSB'.  THESE TWO VARIABLES (WITH THE DECIMAL POINT IN THE.  MIDDLE) HOLD THE NUMBER OF MILLISECONDS IN 1/4 OF A BEAT UNIT...  TWO OTHER GLOBAL VARIABLES 'BU.TOP' AND 'BU.BOTTOM' ARE SET UP.  TO INDICATE WHAT THE BEAT UNIT IS. */DCL (TEMPO.MSB,TEMPO.LSB) FIXED; /* NUMBER OF PERIODS IN WHOLE NOTE */DCL (BU.TOP,BU.BOTTOM)    FIXED;TEMPO.MSB=125; TEMPO.LSB=0; /* INITIALIZE TEMPO TO Q=120 */FRAMES.PER.SECOND=2400; /* START AT 24 FRAMES PER SECOND */BU.TOP=1; BU.BOTTOM=4; /* INDICATE DEFAULT BEAT UNIT OF QUARTER NOTE */DCL BEAT.SCANNED FIXED;SCAN.TEMPO:  PROC; /* CALLED WITH CURRENT TOKEN='TEMPO' */  DCL MSB   LIT 'TEMPO.MSB';  DCL LSB   LIT 'TEMPO.LSB';  DCL (I,J) FIXED;  CALL SCAN.AHEAD; /* SKIP TO RHYTHM SPECIFIER */  CALL SCAN.RHYTHM; /* SCAN OFF RATIO - RETURN IN TOP & BOTTOM */  BU.TOP=TOP; BU.BOTTOM=BOTTOM; /* SAVE THIS IN GLOBAL VARIABLES */  CALL SCAN.AHEAD; /* LOOK FOR = */  IF NCHR<>A.EQUALS THEN CALL ER.IFM;  CALL GET.CHAR; CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */  I=INFO; J=DP; /* SAVE NUMBER FOR LATER SCALING */  CALL SCAN; /* LOOK FOR 'SECONDS' */  /* COMPUTE PERIOD OF EACH BEAT IN MILLISECONDS. */  IF (TOKEN=T.SEC) OR (TOKEN=T.FRAMES) THEN DO; /* TIMING PERIOD SPECIFIED */    INFO=I; DP=J; /* RESTORE INFO */    IF TOKEN=T.SEC THEN DO; /* COMPUTE FOR SECONDS */      CALL ADJUST.NUM(3); /* GET PERIOD IN MILLISECONDS */      MSB=SHR(INFO,02); /* MILLISECONDS IN 1/4 OF A BEAT */      LSB=SHL(INFO,14); /* LOWER TWO BITS */    END;    ELSE DO; /* TEMPO IN FRAMES */      CALL ADJUST.NUM(2); /* GET FRAMES TO .XX */      WRITE(5)=250; WRITE(6)=INFO; /* 250 * FRAMES / FPS = DURATION IN MS. */      IF READ(4) IGE FRAMES.PER.SECOND THEN CALL ER.OVF;      WRITE(7)=FRAMES.PER.SECOND; /* DIVIDE BY FRAMES PER SECOND */      MSB=READ(5); LSB=READ(4); /* GET MSB & REMAINDER */      WRITE(5)=0; WRITE(4)=LSB; WRITE(7)=FRAMES.PER.SECOND; /* COMPUTE LSB */      LSB=READ(5); /* GET LSB'S */    END;    IF MSB=0 THEN CALL ER.TTS; /* TEMPO TOO SMALL */    CALL SCAN; /* SCAN TOKEN AFTER T.SECOND */  END; /* OF CASE FOR TIMING PERIOD */  ELSE DO; /* COMPUTE FROM BEATS PER MINUTE */    CALL PUSH(INFO); CALL PUSH(DP);    INFO=I; DP=J; /* RESTORE NUMBER */    CALL ADJUST.NUM(1); /* COMPUTE BEATS PER MINUTE */    IF INFO<100 THEN CALL ER.IFM; /* MUST BE 10.0 BEATS PER MINUTE */    WRITE(5)=150; WRITE(6)=1000; /* COMPUTE 150000/BPM.X TO GET PERIOD */    MSB=READ(5); /* TO AVOID HARDWARE BUG */    WRITE(7)=INFO; /* DIVIDE BY BPM */    MSB=READ(5); LSB=READ(4); /* GET MSB & REMAINDER */    WRITE(5)=0; WRITE(4)=LSB; WRITE(7)=INFO; /* COMPUTE LSB */    LSB=READ(5);    DP=POP; INFO=POP; /* RESTORE SCAN INFO */  END; /* OF COMPUTE FROM BEATS */END SCAN.TEMPO;/* $SUBTITLE  Scanning Subroutines for Parsing P, R, A, T, V statements *//*   SCAN.PR:    SCANS OF A PITCH & RHYTHM LINE ON TO THE STACK.  USED.                DURING MOTIF DEFINITIONS & P STATEMENT PROCESSING...    SCAN.ATV:   SCANS OF ARTICULATION, VOLUME, AND TIMBRE INFO LINES..                USED DURING MOTIF DEFINITION,  P STATEMENT PROCESSING,.                AND PERFORM STATEMENT PROCESSING. *//* THESE VARIABLES MUST BE IN ORDER (ACCESSED BY 'CORE'): */DCL (NUM.P,NUM.R,NUM.A,NUM.T,NUM.V) FIXED;DCL (PTR.P,PTR.R,PTR.A,PTR.T,PTR.V) FIXED;DCL RHYTHM.LINE# FIXED; /* HOLDS LINE# OF RHYTHM LINE FOR ERRORS */SCAN.PR:  PROC; /* SCAN OFF P AND R LINES */  DCL I FIXED;  I=LINE.NO; /* HOLD IN CASE OF ERROR */  PTR.P=STACKLOC+STACKPT; /* GET STACK POINTER - RESULT WILL BE HERE */  NUM.P=SCAN.PITCH.LINE;  /* SCAN OFF PITCH LINE */  IF NCHR=A.RPAREN        THEN DO; LINE.NO=I; CALL ER.MTMP; END;  IF (ENCLOSED\PHRASED) THEN DO; LINE.NO=I; CALL ER.MBB; END;  ENCLOSED=0; PHRASED=0; /* CLEAN UP AFTER POSSIBLE ERROR */  IF TOKEN<>T.R THEN DO; /* MISSING RHYTHM LINE */    LINE.NO=I; CALL ER.MRL;  END;  RHYTHM.LINE#=LINE.NO;    /* SAVE LINE NUMBER OF RHYTHM LINE */  PTR.R=STACKLOC+STACKPT;  /* RHYTHM LIST WILL START HERE */  NUM.R=SHR(SCAN.RHYTHM.LINE,1);   /* COMPUTE # OF RHYTHMS */  IF NCHR=A.RPAREN  THEN DO; LINE.NO=RHYTHM.LINE#; CALL ER.MTMP; END;  IF NUM.R<>NUM.P THEN DO; LINE.NO=RHYTHM.LINE#; CALL ER.MMR;  END;END SCAN.PR;SCAN.ATV:  PROC; /* SCAN OFF A,T,V LINES IF PRESENT */  DCL I FIXED;  NUM.A=0; NUM.T=0; NUM.V=0; /* ASSUME NO OTHER LINES */  PTR.A=0; PTR.T=0; PTR.V=0;  DO WHILE (TOKEN=T.A) OR (TOKEN=T.T) OR (TOKEN=T.V);    I=LINE.NO; /* HOLD IN CASE OF ERROR */    IF      TOKEN=T.A THEN DO; /* ARTICULATION */      IF NUM.A<>0 THEN CALL ER.EXL; /* DUPLICATE */      PTR.A=STACKLOC+STACKPT; NUM.A=SCAN.ATV.LINE(T.A); /* SCAN ARTICULATION */      IF NUM.A<>NUM.P THEN DO; LINE.NO=I; CALL ER.MMA; END;    END;    ELSE IF TOKEN=T.T THEN DO; /* TIMBRE LINE */      IF NUM.T<>0 THEN CALL ER.EXL; /* ERROR */      PTR.T=STACKLOC+STACKPT; NUM.T=SCAN.ATV.LINE(T.T); /* SCAN OFF TIMBRE */      IF NUM.T<>NUM.P THEN DO; LINE.NO=I; CALL ER.MMA; END;    END;    ELSE IF TOKEN=T.V THEN DO; /* VOLUME LINE */      IF NUM.V<>0 THEN CALL ER.EXL; /* ERROR */      PTR.V=STACKLOC+STACKPT; NUM.V=SCAN.ATV.LINE(T.V); /* SCAN OFF VOLUME */      IF NUM.V<>NUM.P THEN DO; LINE.NO=I; CALL ER.MMA; END;    END;    IF NCHR=A.RPAREN THEN DO; LINE.NO=I; CALL ER.MTMP; END;  END; /* OF DO WHILE */END SCAN.ATV;/* $SUBTITLE  Definitions for Partial, Timbres, Motifs *//* TIMBRE DATA STORAGE:PARTIAL TIMBRES, COMPLETE TIMBRES, AND MOTIFS ARE STORED IN SEVERAL SECTIONSOF UPPER MEMORY.   ..    PARTIAL DEFINITIONS - 'INFO' WORD POINTS TO (BASED OF STLOC) A.                          THREE WORD BLOCK:.                             0:  0 - PARTIAL INFO STORED IN DEFLOC  AREA.                                 1 - PARTIAL INFO STORED IN TIMBLOC AREA.                             1:  POINTER - INTO DEFLOC OR TIMBLOC   AREA.                             2:  LENGTH OF PARTIAL..    TIMBRE  DEFINITIONS - 'INFO' WORD POINTS TO BLOCK IN SYMBOL TABLE.                          AREA (BASED OF STLOC).                        - A 16 WORD RECORD AS FOLOWS:.                            1. (0) - 0 = UNEMITTED. NONZERO = ALREADY EMITTED TIMBRE # (INCLUDES NUM.KBD.TRKS).                            2. NUMBER OF PARTIALS ACTUALLY USED .                            3. 4 WORDS - POINTERS FOR UP TO 4 PARTIAL TIMBRES.                            4. 8 WORDS - 8 WORDS OF MISC DATA FOR SYNCL II PGM (CHORUS, ETC.).                            5. 0 = NO TINFO.  1 = TINFO IN DEFLOC 2=TINFO IN TIMBLOC.                            6. POINTER TO TINFO AREA..     FOR MOTIFS      - AN 12 WORD RECORD AS FOLLOWS:.                    1. KEYSIG OF DEFINITION.                    2. NUM.P,NUM.R,NUM.A,NUM.T,NUM.V.                    3. PTR.P,PTR.R,PTR.A,PTR.T,PTR.V .                    4. TOTAL # OF WORDS IN MOTIF DEF (FOR COPY-IN)..     FOR SFM TIMBRES - A 193 WORD RECORD, AS FOLLOWS:.                    0. A LENGTH WORD.                    1. 10 SPARE WORDS (ALL ZEROS).                    2. UP TO 15 FILE NAME ENTRIES, EACH WITH 12 WORDS.*/DCL TDATA.P.LEN  LIT   '3'; /* LENGTH OF PARTIAL RECORD */DCL TDATA.T.LEN  LIT  '16'; /* LENGTH OF TIMBRE  RECORD */DCL TDATA.M.LEN  LIT  '12'; /* LENGTH OF MOTIF   RECORD */DCL TDATA.S.LEN  LIT '193'; /* LENGTH OF SFM     RECORD *//* THE FOLLOWING DEFAULT PARTIAL IS USED */DCL BASIC.PARTIAL DATA (0,10,10,10,1000,1000, /* VOLUME ENVELOPE */0,10,10,10,0000,0000, /* FM ENVELOPE     */1000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* SINE WAVE */4400, /* TUNING */0,600,0,500, /* VIBRATO FUNCTION - ZERO DEPTH */0,600, /* NO PORTAMENTO */1000, /* RATIO 1.000 */0000,1000); /* NO DECAY ADJUST, NO CHORUS *//* PARTIAL SUBFIELD FORMATS: */DCL VOLENV     DATA (0,6,0,30000,0,26667,0,30000,0,30000,1,1000,1,1000);DCL FMENV      DATA (6,6,0,30000,0,26667,0,30000,0,30000,0,1000,0,1000);DCL HARMONICS  DATA (12,24,1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000);DCL PHASES     DATA (12,24,0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63,                           0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63,                           0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63);DCL TUNING     DATA (36,1,1,17600);DCL VIBRATO    DATA (38,3,2,5000,2,2400,0,9999);DCL PORTAMENTO DATA (42,1,3,1000);DCL FMRATIO    DATA (43,1,3,16000);DCL DECAY      DATA (44,1,3,1000);DCL PCHORUS    DATA (45,1,3,10000);DCL HARMADJ    DATA (46,1,0,30);DCL STEREO     DATA (47,4,0,50,0,24,1,60,0,50);DCL KBDENV     DATA (51,4,0,61,0,61,0,61,0,61);/* $page */DCL TF.INFO    DATA (8,12,0,20000,0,20000,0,1000,2,4800,1,1000,1,1000,                          0,    0,0,    0,0,   0,0,   0,2,4800,0,10000);DCL TF.HARM    DATA (20,24,1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000,                           1,1000,1,1000,1,1000,1,1000,1,1000,1,1000);DCL TF.PHASE   DATA (20,24,0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63,                           0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63,                           0,63,0,63,0,63,0,63,0,63,0,63,0,63,0,63);DCL TF.WAVE    DATA (44,256,0,255);/* BASIC TIMBRE: */DCL BASIC.TIMBRE DATA (0,0,0,0,0,500,1000,0);/* TIMBRE SUB-FIELD FORMATS: */DCL CHORUS DATA (-6,1,3,10000);   /* - NUMBER - INDICATE STORE IN CORE */DCL RATE   DATA (-5,1,2,10000);/* $SUBTITLE  Routine to Scan off Numeric Subfield */D.LOOKUP:PROC(PTR);       /* LOOK UP SINGLE WORD FROM DEFLOC AREA */   DCL PTR FIXED;    IF EXAMOUNT=0 THEN RETURN CORE(DEFLOC+PTR);   WRITE(MAM)=DEFLOC+SHR(PTR,8); WRITE(MAL)=PTR;   RETURN READ(MD);END D.LOOKUP;D.STORE:PROC(PTR,VAL);          /* STORE WORD IN DEFLOC AREA */   DCL (PTR,VAL) FIXED;   IF EXAMOUNT=0 THEN CORE(DEFLOC+PTR)=VAL;   ELSE DO;                     /* EXTERNAL MEM */      WRITE(MAM)=DEFLOC+SHR(PTR,8); WRITE(MAL)=PTR;      WRITE(MD)=VAL;   END;END D.STORE;T.LOOKUP:PROC(PTR);       /* LOOK UP SINGLE WORD FROM TIMBRE AREA */   DCL PTR FIXED;    IF EXAMOUNT=0 THEN RETURN CORE(TIMBLOC+PTR);   WRITE(MAM)=TIMBLOC+SHR(PTR,8); WRITE(MAL)=PTR;   RETURN READ(MD);END T.LOOKUP;SCAN.SUB.FIELD:  PROC(LNUM,PTR,LIST); /* PASS LINE.NO, DEFLOC PTR & LIST */  DCL (LNUM,PTR)    FIXED;  DCL (MEDIA)       FIXED;  DCL LIST          ARRAY; /* CONTAINS LOCATION, #, AND # OF DECIMAL POINTS REQD */  DCL (I,J,K,L,M,N) FIXED;  I=0; /* COUNT NUMBER */  CALL SCAN.AHEAD;  DO WHILE (NCHR=A.MINUS) OR (NCHR=A.PERIOD) OR ((NCHR>=A.0)&(NCHR<=A.9)); /* DO WHILE A NUMERIC FIELD ENCOUNTERED */    IF I>=LIST(1) THEN DO; /* TOO MANY */      LINE.NO=LNUM; CALL ER.TMA;      TOKEN=T.TIME; /* EXTRA NUMBER MUST BE TIME - GET OUT OF LOOP */      RETURN;    END;    ELSE DO; /* SCAN OFF FIELD */      CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */      IF LIST(1)=256 THEN DO; J=LIST(2);     K=LIST(3);     END; /* SPECIAL CASE FOR T.F. WAVE TABLE */                     ELSE DO; J=LIST(2+I+I); K=LIST(3+I+I); END; /* LOOK UP DP, MAX */      IF INFO<0 THEN DO; /* MINUS ARG - ONLY ALLOWED FOR RATIO, CENTER, HARMADJ */        IF (LIST(0)=8) THEN DO; IF (I<>10) THEN CALL ER.NAL; END; /* T.F INFO - ALLOW - NUMBER FOR PITCH DELTA */        ELSE IF (LIST(0)<>36) & (LIST(0)<>43) & (LIST(0)<>46) & (LIST(0)<>47) THEN CALL ER.NAL; /* NEGATIVE NUMBER NOT ALLOWED */        IF LIST(0)=43 THEN DO; J=1; K=9999; END; /* SPECIAL 1 DECIMAL POINT FOR - HZ (USES DIFFERENT DP FOR + & -) */        DO WHILE DP<J; /* SCALE */          IF INFO<-2000 THEN CALL ER.TMD;          INFO=INFO*10; DP=DP+1;        END;        DO WHILE DP>J; INFO=INFO/10; DP=DP-1; END; /* USE DP OF 1 */        IF INFO<(-K) THEN CALL ER.TMD; /* NUMBER IS TOO FAR MINUS */      END;      ELSE DO; /* POSITIVE ARG - JUST SCALE */        DO WHILE J<DP; INFO=INFO/10; DP=DP-1; END; /* SCALE */        DO WHILE J>DP; /* ADD DIGITS */          IF INFO>3000 THEN CALL ER.TMD; /* TOO BIG */          INFO=INFO*10; DP=DP+1;        END;        IF INFO>K THEN DO; /* TOO LARGE */          CALL ER.TMD; INFO=K;        END;      END;      IF LIST(1)=256 THEN DO; /* STORING WAVE TABLE ITEM */         M=PTR+LIST(0)+SHR(I,1); /* GET POINTER TO WHERE BYTE GOES */         N=D.LOOKUP(M);          /* GET WORD */         IF (I&1)=0 THEN DO; N=(N&"177400")\INFO; END;         ELSE            DO; N=(N&"000377")\SHL(INFO,8); END;         CALL D.STORE(M,N);      /* STORE BACK IN PARTIAL */      END;      ELSE DO; /* NON WAVE TABLE - STORE IN T.FRAME OR PARTIAL AREA, OR IN TIMBRE MISC AREA */         IF LIST(0)<0 THEN DO;  /* STORE IN CORE (MEANS MISC AREA) */            CORE(PTR-LIST(0))=INFO;  /* USE - TO GET POSITIVE OFFSET */         END;         ELSE DO;                    /* STORE IN DEFLOC AREA (INTERNAL/EXTERNAL) */            L=LIST(0)+I; /* COMPUTE LOCATION */            IF L<46 THEN DO; /* TIMBRE FRAME PARAM OR NORMAL PARTIAL PARAMETER - STORE WITH MASK */              IF LIST(3)=63 THEN DO; /* SPECIAL CHECK FOR STORING PHASE */                 CALL D.STORE(PTR+L,(D.LOOKUP(PTR+L)&"1777")\SHL(INFO,10));              END;              ELSE DO;                 J=-1; /* COMPUTE MASK FOR STORE BASED ON MAX */                 IF (LIST(0)=8)\(LIST(0)=36)\(LIST(0)=43) THEN J=0; /* PRESERVE NO BITS FOR T.FRAME INFO, FM RATIO, PTUING */                 ELSE DO WHILE ((J&K)<>0); J=J+J; END; /* COMPUTE MASK, BUT NOT FOR RATIO OR PTUNING */                 CALL D.STORE(PTR+L,(D.LOOKUP(PTR+L)&J)\INFO); /* STORE NUMBER IN LIST */              END;            END;            ELSE DO CASE (L-46); /* STORE SPECIAL PARAMETERS */               CALL D.STORE(PTR+44,(D.LOOKUP(PTR+44)&"1777")  \SHL(INFO,10)); /* STORE HARM ADJ */               CALL D.STORE(PTR+41,(D.LOOKUP(PTR+41)&"177003")\(SHL(INFO&"177",2))); /* STERO CENTER */               CALL D.STORE(PTR+37,(D.LOOKUP(PTR+37)&"177")   \SHL(INFO,7));  /* STEREO MODE */               CALL D.STORE(PTR+42,(D.LOOKUP(PTR+42)&"1777")  \SHL(INFO,10)); /* STEREO RATE */               CALL D.STORE(PTR+41,(D.LOOKUP(PTR+41)&"777")   \SHL(INFO,9));  /* STEREO DEPTH */               CALL D.STORE(PTR+10,(D.LOOKUP(PTR+10)&"1777")  \SHL(INFO,10)); /* KBD ENVELOPE */               CALL D.STORE(PTR+04,(D.LOOKUP(PTR+04)&"1777")  \SHL(INFO,10)); /* KBD ENVELOPE */               CALL D.STORE(PTR+05,(D.LOOKUP(PTR+05)&"1777")  \SHL(INFO,10)); /* KBD ENVELOPE */               CALL D.STORE(PTR+11,(D.LOOKUP(PTR+11)&"1777")  \SHL(INFO,10)); /* KBD ENVELOPE */            END;         END;      END;      I=I+1; /* COUNT SUBFIELDS */      IF (I=6)&(LIST(0)=8) THEN I=10; /* SKIP UNUSED BUTTONS IN T.FRAME INFO FIELD */    END;    CALL SCAN.AHEAD;  END;                              /* DO WHILE */  CALL SCAN;                        /* SCAN OFF NEXT TOKEN AFTER PARAMETER LIST */  IF LIST(1)=24 THEN RETURN;        /* DO NOT CHECK IF HARMONIC OR PHASE FIELD */  IF I<LIST(1) THEN DO;             /* NOT ENOUGH ARGUMENTS SUPPLIED */    LINE.NO=LNUM; CALL ER.NEA;  END;END SCAN.SUB.FIELD;/* $SUBTITLE  Process Define Statement */DCL SFM.TIMBRES    FIXED;    /* TRUE IF SFM TIMBRE DEFINED     */DCL SN2.TIMBRES    FIXED;    /* TRUE IF SYNCL 2 TIMBRE DEFINED */DCL USE.NEW.FORMAT FIXED;    /* SET TRUE TO USE NEW FORMAT FOR TIMBRE DEFS */DCL #.TWRDS LIT '10'; /* NUMBER OF OVERALL WORDS IN SFM TIMBRE */DCL #.FWRDS LIT '12'; /* NUMBER OF WORDS FOR EACH FILE ENTRY   */dcl pinfo   lit '(-3)';  dcl pinfo.len lit '(32)';dcl tinfo   lit '(-4)';  dcl tinfo.len lit '(96)';dcl ti.name  lit '8';dcl ti.rte   lit '16';DEFALC:PROC(AMT);     /* PROCEDURE TO ALLOCATE MEMORY IN 'DEFLOC' AREA */   DCL (I,AMT,NEW) FIXED;   I=DEFLEN+AMT;                        /* GET NEW DEFLEN */   IF EXAMOUNT=0 THEN DO;               /* INTERNAL MEMORY */      IF I ILE DEFMAX THEN RETURN;      /* ENOUGH ALLOCATED ALREADY */      NEW=(I-DEFMAX+511)&"177000";      /* ALLOCATE ENOUGH NEEDED, ROUNDED UP TO MULT OF 512 */      IF SEQNLEN+NEW IGT SEQNMAX THEN CALL ER.ORT;  /* NO MORE MEMORY AVAILABLE */      I=SEQNLOC+SEQNMAX;                /* GET POINTER TO START OF DEF AREA IN USE (MAY BE PAST DEFLOC HERE) */      DO WHILE I<>DEFLOC+DEFLEN;        /* COPY DOWN USED PART OF DEF AREA */         CORE(I-NEW)=CORE(I); I=I+1;      END;      SEQNMAX=SEQNMAX-NEW;              /* TOOK STORAGE FROM SEQUENCER AREA */      DEFLOC =DEFLOC -NEW;              /* DEF AREA MOVED DOWN */      DEFMAX =DEFMAX +NEW;              /* MORE DEF STORAGE NOW */   END;   ELSE DO;                             /* EXTERNAL MEMORY */      IF (I ILT DEFLEN)                 /* OVERFLOW OCCURRED */      OR (I IGE "177400")               /* MUST LIMIT TO 64K */      THEN CALL ER.ORT;                 /* DEF AREA ITSELF IS TOO BIG */      IF I ILE DEFMAX THEN RETURN;      /* ENOUGH ALLOCATED ALREADY */      NEW=(I-DEFMAX+4095)&"170000";     /* ALLOCATE ENOUGH NEEDED, ROUNDED UP TO MULT OF 4096 */      I=DEFLOC-SHR(NEW,8);              /* GET NEW DEFLOC START */      IF I ILT SEQNLOC+SHR(SEQNMAX,8)   /* IF WE ARE NOW ENCROACHING ON NOTE AREA */      THEN DO;                          /* THEN WE MUST REDUCE NOTE MAX */         IF I ILT (SEQNLOC+SHR(SEQNLEN+255,8))         THEN CALL ER.ORT;              /* BUT CAN NOT BACK DOWN ON TOP OF ALREADY EMITTED NOTES */         SEQNMAX=SHL(I-SEQNLOC,8);      /* SET UP NEW MAX */      END;      CALL COPY.EXT.MEM(DEFLOC,0,I,0,DEFLEN); /* COPY USED AREA DOWN */      DEFLOC=I;                         /* STARTS HERE */      DEFMAX =DEFMAX+NEW;               /* MORE DEF STORAGE NOW */      IF (DEFMAX ILT NEW)               /* BUT CHECK FOR OVERFLOW */      THEN DEFMAX="177400";             /* LIMIT TO USEFUL MAX */   END;END DEFALC;DEFINE.STATEMENT:   PROC;    /* HANDLE DEFINITION STATEMENT */  DCL (TPTR,IPTR)   FIXED;   /* INTERNAL POINTERS */  DCL TLEN          DATA     (TDATA.P.LEN,TDATA.T.LEN,TDATA.M.LEN,TDATA.S.LEN);  DCL (I,J,K,L,M)   FIXED;  DCL (W.SCANNED)   FIXED;  DCL (WORD)        FIXED;  DCL (R.SCANNED)   FIXED;  DCL (RTES)        FIXED;  DCL STR.BITS      DATA  ("002000","004000","010000","020000","040000","100000");  DCL G.BITS        DATA  ("102000","002000","000000","040000","020000","010000","004000","001000");  DCL IN.FRAME      FIXED; /* 0 = IN NO FRAME; 1 = IN TIMBRE FRAME; 2 = IN PATCH LIST; 3 = IN CUE LIST */  DCL CUENAME (EVENT.CUE.MAX.BYTES/2)  FIXED;  CALL SCAN; /* SCAN OFF DEFINITION TYPE */  IF      TOKEN=T.PARTIAL THEN I=0; /* PARTIAL DEFINITION */  ELSE IF TOKEN=T.TIMBRE  THEN I=1; /* TIMBRE DEFINITION */  ELSE IF TOKEN=T.MOTIF   THEN I=2; /* MOTIF DEFINITION */  ELSE IF TOKEN=T.SFM     THEN I=3; /* SFM TIMBRE DEFINITION */  ELSE DO; CALL ER.IFD; RETURN; END; /* INCORRECT FORMAT IN DEFINITION */  IF I=3 THEN DO; /* CHECK SFM TIMBRE DEF */    CALL SCAN; /* SHOULD GET 'TIMBRE' */    IF TOKEN<>T.TIMBRE THEN CALL ER.IFD;  END;  CALL SCAN; /* SKIP NOW TO SYMBOL NAME */  IF TOKEN<>T.UND THEN DO; /* FORMAT ERROR */    IF NAME.PT<>0 THEN CALL ER.LT(NAME.PT); /* CAN NOT DEFINE TWICE */    ELSE               CALL ER.IFM;    RETURN;  END;  CALL S.DEFINE(NAME.PT,HASHCODE); /* RECORD SYMBOL DEFINITION */  CALL PTOK(NAME.PT,T.PDEF+I);     /* STORE T.PDEF OR T.TDEF AS REQUIRED */  IPTR=STPTR;                      /* GET STORAGE AT END OF SYMBOL TABLE */  STPTR=STPTR+TLEN(I);             /* ALLOCATE WORDS FOR THIS SYMBOL */  IF STPTR IGT STSIZ THEN CALL ER.NST; /* NO MORE SYMBOL STORAGE */  CORE(STLOC+NAME.PT+2)=IPTR;      /* STORE INFO WORD */  J=LINE.NO; /* SAVE LINE NUMBER OF DEFINE STATEMENT */  CALL SCAN; /* SKIP OVER SYMBOL, GET FIRST SUBFIELD */    /* $page */  /* CASE FOR PARTIAL DEFINITION */  IF I=0 THEN DO; /* PARTIAL DEFINITION */    CALL DEFALC(46);                /* ALLOCATE STORAGE FOR 46 PARTIAL DATA WORDS */    CORE(STLOC+IPTR)=0;             /* INITIALIZE PARTIAL TO STORED IN DEFLOC AREA */    CORE(STLOC+IPTR+1)=DEFLEN;      /* STORE DEFLOC POINTER */    CORE(STLOC+IPTR+2)=46;          /* INITIALIZE LENGTH TO 46 WORDS */    TPTR=DEFLEN;                    /* SAVE CORE POINTER TO DATA  */    DEFLEN=DEFLEN+46;               /* 46 WORDS NOW USED             */    DO J=0 TO 45;                   /* COPY DEFAULT PARTIAL INTO RECORD */      CALL D.STORE(TPTR+J,BASIC.PARTIAL(J));    END;    W.SCANNED=0; WORD=0; /* INITIALIZE */    IN.FRAME=0;    DO WHILE TOKEN=T.PFIELD; /* SCAN OFF PARTIAL SUB FIELDS */      J=INFO; K=LINE.NO; /* GET TYPE & LINE.NO OF DEFINITION */      IF J=13 THEN J=5; /* MAP PORT.RATE TO PORTAMENTO FOR NOW */      DO CASE (J); /* BRANCH ON SUBFIELD TYPE */        CALL SCAN.SUB.FIELD(K,TPTR,VOLENV);        CALL SCAN.SUB.FIELD(K,TPTR,FMENV);        CALL SCAN.SUB.FIELD(K,TPTR,HARMONICS);        CALL SCAN.SUB.FIELD(K,TPTR,TUNING);        DO; /* VIBRATO - SCAN OFF WAVE SHAPE */          CALL SCAN; /* SCAN OFF VIBRATO WAVE SHAPE */          IF TOKEN=T.TIME THEN DO; /* NUMBER FOR WAVE */            INFO=SECONDS-1;            IF (INFO<0) OR (INFO>11) THEN CALL ER.MVW; /* INCORRECT VIB WAVE */          END;          ELSE IF TOKEN<>T.VWAVE THEN CALL ER.MVW;          CALL D.STORE(TPTR+37,(D.LOOKUP(TPTR+37)&"177600")\INFO); /* STORE WAVE SHAPE */          CALL SCAN.AHEAD;          DO WHILE (NCHR=A.R) OR (NCHR=A.Q) OR (NCHR=A.I); /* LOOK FOR MODIFIERS */             CALL SCAN;             IF (TOKEN=T.VWAVE) OR (INFO=3) THEN DO; TOKEN=T.VBIT; INFO=16; END; /* 'INVERTED' */             IF TOKEN<>T.VBIT THEN CALL ER.IFM; /* MUST BE VIBRATO BIT */             CALL D.STORE(TPTR+37,D.LOOKUP(TPTR+37)\INFO);             CALL SCAN.AHEAD;          END;          CALL SCAN.SUB.FIELD(K,TPTR,VIBRATO);        END;        DO; /* PORTAMENTO */          IF J=INFO THEN L=1;ELSE L=0; /* DETERMINE 'PORTAMENTO' OR 'PORT.RATE' ONLY */          CALL SCAN; /* SCAN OFF PORTAMENTO SHAPE */          IF TOKEN=T.TIME THEN DO; /* NUMBER FOR SHAPE */            INFO=SECONDS; /* INTEGER PART */            IF (INFO<>0) OR (INFO<>1) THEN CALL ER.MPS; /* INCORRECT SHAPE */          END;          ELSE IF TOKEN<>T.PSHAPE THEN CALL ER.MPS; /* MISSING SHAPE */          CALL D.STORE(TPTR+41,D.LOOKUP(TPTR+41)\(L+SHL(INFO,1))); /* SET GLIDE BITS */          CALL SCAN.SUB.FIELD(K,TPTR,PORTAMENTO); /* SCAN IT */        END;        CALL SCAN.SUB.FIELD(K,TPTR,FMRATIO);        CALL SCAN.SUB.FIELD(K,TPTR,DECAY);        CALL SCAN.SUB.FIELD(K,TPTR,PCHORUS);        CALL SCAN.SUB.FIELD(K,TPTR,HARMADJ);        CALL SCAN.SUB.FIELD(K,TPTR,STEREO);        CALL SCAN.SUB.FIELD(K,TPTR,KBDENV);        DO; /* SCAN OFF ACTIVE STRING BITS */           IF W.SCANNED=0 THEN DO;WORD="176000";W.SCANNED=1;END; /* INITIALIZE */           CALL SCAN.AHEAD; /* SKIP UP TO ACTIVE STRINGS */           DO WHILE ((NCHR>=A.0)&(NCHR<=A.9)); /* SCAN OFF STRING FIELD */              L=NCHR-A.0; /* GET DIGIT 1-X */              IF (L<1)\(L>6) THEN CALL ER.ASOR;              ELSE WORD=WORD & (NOT(STR.BITS(L-1)));              CALL GET.CHAR;CALL SCAN.AHEAD;           END;           CALL D.STORE(TPTR+12,(D.LOOKUP(TPTR+12)&"1777")\WORD);           CALL SCAN; /* GET NEXT TOKEN */        END;        ; /* UNUSED - PORT.RATE SCANNED ABOVE */        CALL SCAN.SUB.FIELD(K,TPTR,PHASES); /* SCAN PHASES */      END; /* OF DO CASE */    END; /* OF SUBFIELD SCAN */    DO WHILE TOKEN=T.FFIELD; /* LOOK FOR POSSIBLE FRAME FIELDS */       USE.NEW.FORMAT=1;     /* USE TIMBRE FRAME FORMAT IF FRAME FIELD FOUND */       IF (INFO>0)&(INFO<4)&(IN.FRAME<>1) THEN DO; CALL ER.IFM; CALL SCAN; END; /* MUST ENTER INFO LINE FIRST */       ELSE DO CASE (INFO); /* BRANCH ON FRAME FIELD TYPE */          DO; /* 0 - FRAME INFO FIELD - MEANS CREATE NEW FRAME */             IF ((IN.FRAME<>0)&(IN.FRAME<>1)) THEN CALL ER.IFM;  /* CAN'T COMBINE TIMBRES & PATCHES */             IN.FRAME=1;             CALL DEFALC(172);               /* ALLOCATE WORDS FOR TIMBRE FRAME */             TPTR=DEFLEN;                    /* COMPUTE NEW DEFLOC POINTER TO DATA FOR TIMBRE FRAME */             DEFLEN=DEFLEN+172;              /* INDICATE MORE  WORDS NOW USED */             CORE(STLOC+IPTR+2)=CORE(STLOC+IPTR+2)+172;  /* INCREASE PARTIAL LENGTH */             DO J=0 TO 171; CALL D.STORE(TPTR+J,0); END; /* INITIALIZE FRAME */             CALL D.STORE(TPTR,(-1)); /* INDICATE FRAME STORED */             CALL D.STORE(TPTR+2,172); /* SAVE LENGTH IN TIMBRE FRAME RECORD */             CALL SCAN.SUB.FIELD(LINE.NO,TPTR,TF.INFO); /* SCAN OFF INFO */          END;          CALL SCAN.SUB.FIELD(LINE.NO,TPTR,TF.HARM); /* TF HARMONICS */          CALL SCAN.SUB.FIELD(LINE.NO,TPTR,TF.PHASE); /* TF.PHASES */          CALL SCAN.SUB.FIELD(LINE.NO,TPTR,TF.WAVE); /* AND WAVE TABLE */          DO; /* 4 - "FILE" FIELD FOR PATCH-LIST */             IF (IN.FRAME<>0)&(IN.FRAME<>2) THEN CALL ER.IFM;        /* CAN NOT MIX FILE AND TIMBRE FRAMES */             IN.FRAME=2;             CALL DEFALC(48);                        /* ALLOCATE WORDS FOR FILE FRAME */             TPTR=DEFLEN;                            /* COMPUTE NEW DEFLOC POINTER TO DATA FOR TIMBRE FRAME */             DEFLEN=DEFLEN+48;                       /* INDICATE MORE  WORDS NOW USED */             CORE(STLOC+IPTR+2)=CORE(STLOC+IPTR+2)+48;  /* INCREASE PARTIAL LENGTH */             DO J=0 TO 47; CALL D.STORE(TPTR+J,0); END; /* INITIALIZE FRAME */             CALL D.STORE(TPTR  ,(-1));    /* INDICATE FRAME STORED */             CALL D.STORE(TPTR+1,  1 );    /* TYPE 1 = FILE FRAME */             CALL D.STORE(TPTR+2,  48);    /* SAVE LENGTH IN TIMBRE FRAME RECORD */             CALL SCAN;                    /* SHOULD GET STRING CONSTANT FILE NAME */             IF TOKEN<>T.SCONST THEN CALL ER.IFM;             DO J=0 TO NAME(0)-1;          /* COPY NAME INTO TDATA */               M=BYTE(NAME,J);             /* GET CHAR */               IF (M-L.A) ILE (L.Z-L.A) THEN M=M-"40"; /* UP CASE */               CALL PBYTE(NAME,J,M);             END;             DO J=NAME(0) TO 7;            /* FILL WITH NULLS */                CALL PBYTE(NAME,J,0);             END;             DO J=0 TO 3;                CALL D.STORE(TPTR+3+J,NAME(J+1));             END;             CALL SCAN.AHEAD;                /* GET TO PITCH */             CALL SCAN.PITCH;                /* GET PITCH */             CALL D.STORE(TPTR+7,INFO&255);  /* STORE STARTING PITCH */             CALL SCAN.AHEAD;             CALL SCAN.PITCH;                /* GET ENDING PITCH */             CALL D.STORE(TPTR+8,INFO&255);  /* GET ENDING PITCH */             ENABLE.EOL=1;                   /* STOP AT END OF LINE */             CALL SCAN.NUMERIC;              /* SCAN OFF NUMBER */             CALL ADJUST.NUM(1);             /* GET TO 1 DECIMAL */             IF INFO>1000 THEN CALL ER.TMD;  /* NUMBER TOO LARGE */             CALL D.STORE(TPTR+9,INFO);             CALL SCAN.AHEAD;                /* GET TO PITCH OR END OF LINE */             IF (TOKEN<>T.EOL)&(NCHR>=A.A) THEN DO; /* TRANSPOSITION */               CALL SCAN.PITCH;               CALL D.STORE(TPTR+10,(INFO&255)+256);               CALL SCAN.AHEAD;              /* TO BUFFER FIELD */             END;             IF TOKEN<>T.EOL THEN DO;        /* MUST BE SEMITONE INFO */                CALL SCAN.NUMERIC;                IF INFO<0 THEN DO;                   INFO=(-INFO);                   CALL ADJUST.NUM(2);                   INFO=(-INFO);                END;                ELSE CALL ADJUST.NUM(2);                CALL D.STORE(TPTR+11,INFO);                CALL SCAN.AHEAD;             END;             IF TOKEN<>T.EOL THEN DO;         /* TOTAL LENGTH */                CALL SCAN.NUMERIC;                CALL D.STORE(TPTR+12,INFO);                CALL SCAN.AHEAD;                CALL SCAN.NUMERIC;                CALL D.STORE(TPTR+13,INFO);                CALL SCAN.AHEAD;             END;             IF TOKEN<>T.EOL THEN DO;         /* LOOP LENGTH */                CALL SCAN.NUMERIC;                CALL D.STORE(TPTR+14,INFO);                CALL SCAN.AHEAD;                CALL SCAN.NUMERIC;                CALL D.STORE(TPTR+15,INFO);                CALL SCAN.AHEAD;             END;             ENABLE.EOL=0;             CALL SCAN;              /* GET NEXT TOKEN AFTER FILE LIST */          END;          DO; /* 5 - "CUE" FIELD FOR CUE TRIGGER LIST */             IF (IN.FRAME<>0)&(IN.FRAME<>3) THEN CALL ER.IFM;        /* CAN NOT MIX FILE AND TIMBRE FRAMES */             IN.FRAME=3;             CALL SCAN.AHEAD;             CALL SCAN.NUMERIC;           /* SCAN OFF NUMBER  */             CALL ADJUST.NUM(0);          /* GET TO 1 DECIMAL */             K=INFO;                      /* SAVE KEY #       */             CALL SCAN;                   /* SHOULD GET STRING CONSTANT CUE NAME */             IF TOKEN<>T.SCONST THEN CALL ER.IFM;             L=SHR(NAME(0)+3,1);          /* GET # OF WORDS IN CUE NAME */             CALL DEFALC(L+4);            /* ALLOCATE WORDS FOR CUE FRAME */             TPTR=DEFLEN;                 /* COMPUTE NEW DEFLOC POINTER TO DATA FOR TIMBRE FRAME */             DEFLEN=DEFLEN+L+4;           /* INDICATE MORE  WORDS NOW USED */             CORE(STLOC+IPTR+2)=CORE(STLOC+IPTR+2)+L+4;  /* INCREASE PARTIAL LENGTH */             CALL D.STORE(TPTR  ,(-1));    /* INDICATE FRAME STORED */             CALL D.STORE(TPTR+1, cu.type);/* TYPE 1 = CUE FRAME    */             CALL D.STORE(TPTR+2, L+4);    /* SAVE LENGTH IN TIMBRE FRAME RECORD */             CALL D.STORE(TPTR+3,   K);    /* SAVE CUE KEY #        */             DO J=0 TO L-1;                /* STORE CUE NAME        */                CALL D.STORE(TPTR+4+J,NAME(J));             END;             CALL SCAN;              /* GET NEXT TOKEN AFTER CUE NAME */          END;          DO; /* 6 - "EVENT" FIELD FOR CUE TRIGGER LIST */             IF (IN.FRAME<>0)&(IN.FRAME<>3) THEN CALL ER.IFM;        /* CAN NOT MIX FILE AND TIMBRE FRAMES */             IN.FRAME=3;             /* (CAN MIX CUES & EVENTS, HOWEVER) */             CALL SCAN;                   /* SHOULD GET STRING CONSTANT CUE NAME */             IF TOKEN<>T.SCONST THEN CALL ER.IFM;  /* must be cue name */             IF NAME(0) > Event.Cue.Max.Bytes      /* limit length to  */             THEN NAME(0) = Event.Cue.Max.Bytes;   /* what is allowed. */                          /* move cue name to temporary storage so we can scan      */             /* off cue length:                                        */             CALL BLOCKMOVE(NAME, CUENAME, Event.Cue.Max.Bytes/2 + 1);             CALL SCAN;      /* SHOULD GET STRING CONSTANT CUE CAPTION */             IF TOKEN<>T.SCONST THEN CALL ER.IFM;  /* must be caption */             IF NAME(0) > Event.Cap.Max.Bytes      /* string here.    */             THEN NAME(0) = Event.Cap.Max.Bytes;   /* limit length.   */                          L=SHR(NAME(0)+3,1) + shr(cuename(0)+3,1); /* get total words in name + caption */             CALL DEFALC(EV.NAME+L);      /* ALLOCATE WORDS FOR EVENT */             TPTR=DEFLEN;                 /* COMPUTE NEW DEFLOC POINTER TO DATA FOR TIMBRE FRAME */             DEFLEN=DEFLEN+EV.NAME+L;     /* INDICATE MORE  WORDS NOW USED */             CORE(STLOC+IPTR+2)=CORE(STLOC+IPTR+2)+EV.NAME+L;  /* INCREASE PARTIAL LENGTH */             CALL D.STORE(TPTR  ,(-1));    /* INDICATE FRAME STORED */             CALL D.STORE(TPTR+1,ev.type); /* TYPE 3 = event        */             CALL D.STORE(TPTR+2,ev.name+l);/* SAVE LENGTH IN TIMBRE FRAME RECORD */             DO J=0 TO shr(cuename(0)+3,1)-1;    /* STORE CUE NAME */                CALL D.STORE(TPTR+ev.name+J,cuename(J));             END;             k = ev.name + shr(cuename(0)+3,1);  /* pointer to caption */             DO J=0 TO shr(name(0)+3,1)-1;       /* STORE caption      */                CALL D.STORE(TPTR+K+J,NAME(J));             END;             CALL SCAN.AHEAD;             /* skip to key#      */             CALL SCAN.NUMERIC;           /* SCAN OFF NUMBER   */             CALL ADJUST.NUM(0);          /* GET TO 0 DECIMAL  */             CALL D.STORE(TPTR+ev.key,info); /* SAVE CUE KEY # */             CALL D.STORE(TPTR+ev.cue.id,0); /* init id to 0   */             do j = ev.in.msb to ev.name-1;                CALL SCAN.AHEAD;                CALL SCAN.NUMERIC;        /* SCAN OFF NUMBER   */                CALL D.STORE(TPTR+j,info);             end;             CALL SCAN;              /* GET NEXT TOKEN AFTER event info */          END;       END;    END;    IF TOKEN=T.PINFO THEN DO; /* SCAN OFF PINFO FRAME */       USE.NEW.FORMAT=1;               /* USE TIMBRE FRAME FORMAT IF PINFO FOUND */       CALL DEFALC(PINFO.LEN);         /* ALLOCATE WORDS FOR PINFO AREA */       TPTR=DEFLEN;                    /* COMPUTE NEW DEFLOC POINTER TO DATA FOR PINFO */       DEFLEN=DEFLEN+PINFO.LEN;        /* INDICATE MORE  WORDS NOW USED */       CORE(STLOC+IPTR+2)=CORE(STLOC+IPTR+2)+PINFO.LEN;  /* INCREASE PARTIAL LENGTH */       DO J=0 TO PINFO.LEN-1; CALL D.STORE(TPTR+J,0); END; /* INITIALIZE PINFO BLOCK */       CALL D.STORE(TPTR,PINFO);       /* INDICATE PINFO BLOCK STORED */       J=1;                    /* COUNT NUMBER */       CALL SCAN.AHEAD;       DO WHILE (NCHR=A.MINUS) OR (NCHR=A.PERIOD) OR ((NCHR>=A.0)&(NCHR<=A.9)); /* DO WHILE A NUMERIC FIELD ENCOUNTERED */          CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */          IF J<PINFO.LEN THEN CALL D.STORE(TPTR+J,INFO); /* SAVE NUMBER.  IGNORE DECIMAL POINTS FOR NOW */          J=J+1;          CALL SCAN.AHEAD;       END;       CALL SCAN;              /* NOT A NUMBER - MEANS END OF PINFO LIST.  SCAN NEXT TOKEN */    END;  END; /* OF CASE FOR PARTIAL DEFINITION */  /* $page */  /* CASE FOR TIMBRE DEFINITION */  ELSE IF I=1 THEN DO; /* TIMBRE DEFINITION */    IF SFM.TIMBRES THEN CALL ER.SFX; /* MUST USE SFM TIMBRE */    SN2.TIMBRES=1; /* INDICATE A SYNCLAVIER II TIMBRE DEFINED */    CORE(STLOC+IPTR)=0;     /* NOT YET EMITTED */    CORE(STLOC+IPTR+14)=0;  /* INITIALIZE TO NO TINFO AREA PRESENT */    J=0; /* INITIALIZE COUNT */    DO WHILE TOKEN=T.PARTIAL; /* SCAN OFF */      CALL SCAN; /* SKIP 'PARTIAL' AND GET NEXT SYMBOL */      IF TOKEN<>T.PDEF THEN CALL ER.NVP; /* NOT A VALID NAME */      ELSE DO;  /* SAVE POINTER */        IF J=4 THEN CALL ER.TMP; /* TOO MANY PARTIALS LISTED */        ELSE DO;          CORE(STLOC+IPTR+2+J)=INFO; /* SAVE POINTER TO PARTIAL INFO (ALSO OFF STLOC) */          J=J+1; /* COUNT IT */        END;        CALL SCAN; /* SKIP OVER PARTIAL NAME, GET NEXT TOKEN */      END;    END; /* OF DO WHILE */    CORE(STLOC+IPTR+1)=J; /* SAVE NUMBER OF PARTIALS SCANNED */    DO WHILE (TOKEN=T.TINFO)\(TOKEN=T.TNAME)\(TOKEN=T.VKRTE); /* SCAN OFF TINFO AREA STUFF */       USE.NEW.FORMAT=1;                  /* USE TIMBRE FRAME FORMAT IF TINFO/TNAME/VKRTE FOUND */       IF CORE(STLOC+IPTR+14)=0 THEN DO;  /* MUST ALLOCATE AREA FOR TINFO */          CALL DEFALC(TINFO.LEN);         /* ALLOCATE WORDS FOR TINFO AREA */          TPTR=DEFLEN;                    /* COMPUTE NEW DEFLOC POINTER TO DATA FOR TINFO */          CORE(STLOC+IPTR+14)=1;          /* INDICATE TINFO DEFINED, IN MEMORY */          CORE(STLOC+IPTR+15)=DEFLEN;     /* STORE POINTER TO TINFO */          DEFLEN=DEFLEN+TINFO.LEN;        /* INDICATE MORE  WORDS NOW USED */          DO J=0 TO TINFO.LEN-1; CALL D.STORE(TPTR+J,0); END; /* INITIALIZE TINFO BLOCK */          CALL D.STORE(TPTR,TINFO);       /* INDICATE TINFO BLOCK STORED */          DO J=TI.NAME TO TI.NAME+7; CALL D.STORE(TPTR+J,32\SHL(32,8)); END; /* INITIALIZE NAME TO SPACES */          DO J=TI.RTE TO TI.RTE+39 BY 5; CALL D.STORE(TPTR+J,15); END; /* INITIALIZE RTE'S TO ALL PARTIALS PATCHED */       END;       IF TOKEN=T.TINFO THEN DO;       /* TINFO BLOCK */          J=1;                            /* COUNT NUMBER */          CALL SCAN.AHEAD;          DO WHILE (NCHR=A.MINUS) OR (NCHR=A.PERIOD) OR ((NCHR>=A.0)&(NCHR<=A.9)); /* DO WHILE A NUMERIC FIELD ENCOUNTERED */             CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */             IF J<TINFO.LEN THEN CALL D.STORE(TPTR+J,INFO); /* SAVE NUMBER.  IGNORE DECIMAL POINTS FOR NOW */             J=J+1;             IF J=TI.NAME THEN J=TI.RTE+40;         /* SKIP OVER NAME + RTE AREA */             CALL SCAN.AHEAD;          END;          CALL SCAN; /* NOT NUMERIC - MEANS END OF TINFO LIST - GET NEXT TOKEN */       END;       ELSE IF TOKEN=T.TNAME THEN DO;  /* TIMBRE NAME */          CALL SCAN;                   /* GET STRING CONSTANT */          IF TOKEN<>T.SCONST THEN CALL ER.IFM; /* WHERE ARE YOU? */          IF NAME(0)>16 THEN NAME(0)=16;       /* LIMIT TO 16 LETTERS */          IF NAME(0) THEN CALL PBYTE(NAME,NAME(0),32); /* ADD TRAILING SPACE FOR WORD COPY */          DO J=1 TO SHR(NAME(0)+1,1); /* COPY WORDS INTO PLACE */             CALL D.STORE(TPTR+TI.NAME+J-1,NAME(J));          END;          CALL SCAN; /* DONE WITH NAME - GET NEXT TOKEN */       END;       ELSE DO;                        /* MUST BE VK RTE'S    */          CALL SCAN;                   /* GET EXPRESSION      */          DO WHILE TOKEN=T.EXPR;       /* SCAN OFF EXPRESSION */             J=INFO; CALL SCAN; K=0;   /* GET BASE POINTER. INITIALIZE    */             DO WHILE (TOKEN=T.RTEP);  /* GET PATCHINGS       */                IF INFO<4 THEN DO;     /* P1, P2, P3, P4 */                   K=K\SHL(1,INFO);       /* OR IN PTL BIT (0<=INFO<8) */                END;                ELSE IF (INFO>=8)&(INFO<12) THEN DO;                   K=K\SHL(1,INFO-8+4);   /* OR IN PTL BIT (0<=INFO<8) */                END;                ELSE CALL ER.IFM;                CALL SCAN;             END;             CALL D.STORE(TPTR+TI.RTE+J,K);     /* STORE PARTIALS */             DO WHILE TOKEN=T.ROUTING;          /* AND PROCESS EACH ROUTING */                K=INFO&15; L=SHR(INFO,4);       /* GET WORD OFFSET, BIT */                CALL D.STORE(TPTR+TI.RTE+J+K,D.LOOKUP(TPTR+TI.RTE+J+K)\SHL(1,L));                CALL SCAN;                      /* GET NEXT ROUTING,  OR NEXT EXPRESSION, OR SOMETHING ELSE */             END;          END;       END;    END;    TPTR=STLOC+IPTR+6;                /* COMPUTE TEMPORARY BASE POINTER TO TIMBRE INFO AREA */    DO J=0 TO 7; CORE(TPTR+J)=BASIC.TIMBRE(J); END;    /* INITIALIZE */    W.SCANNED=0; WORD=0; R.SCANNED=0; RTES=2;          /* INITIALIZE BITS, + RTES TO PEDAL ONLY */    DO WHILE TOKEN=T.TFIELD;          /* SCAN OF TIMBRE SUBFIELDS */      J=INFO; K=LINE.NO;              /* SAVE TYPE & LINE.NO */      DO CASE (J&15);                 /* BRANCH ON TYPE */        CALL SCAN.SUB.FIELD(K,TPTR,CHORUS); /* NOTE SPECIAL - KLUDGE */        DO; CORE(TPTR)=CORE(TPTR)\2; CALL SCAN; END; /* REPEAT */        DO; CORE(TPTR)=CORE(TPTR)\8; CALL SCAN; END; /* ARPEG  */        CALL SCAN.SUB.FIELD(K,TPTR,RATE);        DO; /* NUM VOICES */          CALL SCAN.NUMERIC;          CALL ADJUST.NUM(0);          IF (INFO>128)\(INFO<0) THEN CALL ER.TMD; /* TOO LARGE */          ELSE CORE(TPTR)=CORE(TPTR)+SHL(INFO,8);  /* UPPER HALF */          CALL SCAN;                               /* SKIP OVER IT */        END;        DO; /* SCAN OFF RTE BITS */          CALL SCAN; /* SCAN OFF FIRST PARTIAL SPECIFIER */          DO WHILE TOKEN=T.RTEP; /* STORE PARTIAL SPECIFIERS */            IF INFO<4 THEN CORE(TPTR+7)=CORE(TPTR+7)\SHL(8,INFO); /* OR IN PARTIAL BITS INTO RTE WORD */            ELSE IF INFO>8 THEN CALL ER.IFM;            ELSE DO; /* 4,5 - PEDAL & VELOCITY */               IF R.SCANNED=0 THEN DO;R.SCANNED=1;RTES=0;END; /* INITIALIZE TO NEITHER PEDAL NOR VELOCITY IF 'VELOCITY' OR 'PEDAL' ENCOUNTERED */               DO CASE (INFO-4);               /* OR IN BIT */                 RTES=RTES\2;                  /* PEDAL - OR IN BIT */                 RTES=RTES\4;                  /* VELOCITY - OR IN BIT */                 RTES=RTES\(2\128);            /* IPEDAL */                 RTES=RTES\(4\1);              /* I VELOCITY */               END;            END;            CALL SCAN;          END;          DO WHILE TOKEN=T.RTEFUN; /* SCAN THEM */            CORE(TPTR+7)=CORE(TPTR+7)\SHL(256,INFO);            CALL SCAN;          END;          CORE(TPTR+7)=(CORE(TPTR+7)&"177771")\RTES; /* SET PEDAL OR VELOCITY BIT, AS SPECIFIED */        END; /* OF RTE SCAN */        DO; /* SCAN OFF GUITAR PERFORMANCE PARAMETERS */           IF W.SCANNED=0 THEN DO;WORD="177000";W.SCANNED=1;END; /* INITIALIZE FOR FIRST ONE */           WORD=WORD & (NOT(G.BITS(SHR(J,4))));           CORE(TPTR+1)=(CORE(TPTR+1)&"777")\WORD; /* STORE IN UPPER HALF OF FILTER WORD */           CALL SCAN; /* GET NEXT TOKEN */        END;        DO; CORE(TPTR)=CORE(TPTR)\32; CALL SCAN; END; /* AUTOPHRASE */      END; /* OF DO CASE FOR TIMBRE SUB-FIELDS */    END; /* OF DO WHILE FOR SUBFIELD SCAN */  END; /* OF CASE FOR TIMBRE DEFINITION */  /* $page */  /* CASE FOR SFM TIMBRE DEFINITION */  ELSE IF I=3 THEN DO;               /* DEFINE SFM TIMBRE */    IF SN2.TIMBRES THEN CALL ER.SFM; /* SFM TIMBRE NOT ALLOWED */    SFM.TIMBRES=1;                   /* INDICATE SFM TIMBRE SCANNED */    TPTR=STLOC+IPTR+1;               /* COMPUTE TEMPORARY POINTER TO BLOCK OF SYMBOL TABLE WORDS (SKIP WHERE LENGTH WILL BE STORED) */    START.OVER:    DO J=0 TO (TDATA.S.LEN-1); CORE(TPTR+J)=0; END; /* FIRST, ZERO IT OUT */    J=#.TWRDS; /* LEAVE SPARE WORDS AS ZEROS */    L=0; /* COUNT NUMBER OF FILES */    WORD="176000";RTES="77"; /* INITIALIZE WORDS FOR SFM SCAN */    DO WHILE (TOKEN=T.SCONST) /* SCAN OFF FILE NAMES */    OR ((TOKEN=T.PFIELD)&(INFO=12)) /* OR ACTIVE STRINGS ENCOUNTERED */    OR ((TOKEN=T.TFIELD)&((INFO&15)=6)) /* OR GUITAR PERFORMANCE BITS */    OR (TOKEN=T.NUMBUFFS); /* OR NUMBER OF BUFFERS */      IF TOKEN=T.SCONST THEN DO; /* STRING CONSTANT - SCAN FILE NAME */        IF (J+#.FWRDS)>192 THEN DO; /* TOO BIG */          CALL ER.TTL;          GOTO START.OVER;        END;        L=L+1;        IF L>15 THEN CALL ER.TMF; /* TOO MANY FILES */        DO K=0 TO NAME(0)-1; /* COPY NAME INTO TDATA */          M=BYTE(NAME,K); /* GET CHAR */          IF (M-L.A) ILE (L.Z-L.A) THEN M=M-"40"; /* UP CASE */          CALL PBYTE(LOCATION(TPTR+J-1),K,M);        END;        DO K=NAME(0) TO 7; /* FILL WITH NULLS */          CALL PBYTE(LOCATION(TPTR+J-1),K,0);        END;        CALL SCAN.AHEAD; /* GET TO PITCH */        CALL SCAN.PITCH; /* GET PITCH */        CORE(TPTR+J+4)=(INFO-12)&255; /* STORE STARTING PITCH */        CALL SCAN.AHEAD;        CALL SCAN.PITCH; /* GET ENDING PITCH */        CORE(TPTR+J+5)=(INFO-12)&255; /* GET ENDING PITCH */        ENABLE.EOL=1; /* STOP AT END OF LINE */        CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */        CALL ADJUST.NUM(1); /* GET TO 1 DECIMAL */        IF INFO>1000 THEN CALL ER.TMD; /* NUMBER TOO LARGE */        CORE(TPTR+J+6)=INFO;        CALL SCAN.AHEAD; /* GET TO PITCH OR END OF LINE */        IF TOKEN<>T.EOL THEN DO;          CALL SCAN.PITCH;          CORE(TPTR+J+7)=((INFO-12)&255)+256;        END;        ENABLE.EOL=0;        J=J+#.FWRDS; /* SKIP TO NEXT FILE ENTRY */        CALL SCAN; /* GET NEXT ITEM */      END; /* IF DO FOR FILE NAMES */      ELSE IF TOKEN=T.PFIELD THEN DO; /* SCAN OFF ACTIVE STRINGS */        CALL SCAN.AHEAD; /* SKIP UP TO ACTIVE STRINGS */        DO WHILE ((NCHR>=A.0)&(NCHR<=A.9)); /* SCAN OFF STRING FIELD */           L=NCHR-A.0; /* GET DIGIT 1-X */           IF (L<1)\(L>6) THEN CALL ER.ASOR;           ELSE RTES=RTES & (NOT(SHR(STR.BITS(L-1),10))); /* MOVE TO LOWER 6 BITS HERE */           CALL GET.CHAR;CALL SCAN.AHEAD;        END;        CORE(TPTR+1)=(CORE(TPTR+1)&"177700")\RTES;        CALL SCAN; /* GET NEXT TOKEN */      END;      ELSE IF TOKEN=T.TFIELD THEN DO; /* SCAN OFF GUITAR STUFF */        DO WHILE (TOKEN=T.TFIELD)&((INFO&15)=6); /* SCAN OFF ALL PERFORMANCE PARAMETERS DESIRED */           WORD=WORD & (NOT(G.BITS(SHR(INFO,4))));           CORE(TPTR+1)=(CORE(TPTR+1)&"777")\WORD; /* STORE IN UPPER HALF OF FILTER WORD */           CALL SCAN; /* GET NEXT TOKEN */        END;      END;      ELSE DO; /* CAN NUM.BUFFS */        CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */        CALL ADJUST.NUM(0);        CORE(TPTR)=INFO+1; /* STORE IN FIRST WORD - ADD 1 TO MATCH DISPLAY */        CALL SCAN;      END;    END; /* OF DO WHILE FOR FILENAMES , STRINGS, GUITAR STUFF */    CORE(TPTR-1)=J+1; /* STORE LENGTH OF SFM TIMBRE (INCLUDE TRAILING ZERO) */    STPTR=STPTR-TLEN(I)+J+2;       /* FREE UP UNUSED SYMBOL TABLE STORAGE (SAVE LENGTH WORD + TRAILING ZERO) */  END; /* OF CASE FOR DEFINE SFM TIMBRE */  /* $page */  /* CASE FOR MOTIF DEFINITION */  ELSE DO; /* DEFINE MOTIF */    CORE(STLOC+IPTR)=ACTIVE.KEY; /* SAVE ACTIVE KEY # FOR LATER USE */    IF (TOKEN=T.STMT) AND (INFO=KEYSIG.STATEMENT.#) THEN DO;      CALL SCAN.KEY; /* SCAN OFF TEMPORARY KEYSIGNATURE */      CALL SETUP.KEY(INFO); /* SET UP FOR THIS KEY ONLY */      CORE(STLOC+IPTR)=INFO; /* SAVE KEY MOTIF DEFINED IN */      CALL SCAN; /* GET NEXT TOKEN - SHOULD BE P */    END;    IF (TOKEN<>T.STMT) OR (INFO<>P.STATEMENT.#) THEN DO; /* CHECK FOR PITCH LINE HERE */      LINE.NO=J; CALL ER.MPL;    END;    J=STACKPT;          /* SAVE STACK POINTER */    CALL SCAN.PR;       /* SCAN OFF PITCH & RHYTHM LINE - PITCH LINE ALWAYS FIRST */    CALL SCAN.ATV;      /* SCAN OFF A,T,V LINES IF PRESENT */    CALL DEFALC(STACKPT-J);  /* ALLOCATE ROOM IN UPPER MEMORY (DEFLOC AREA) */    K=DEFLEN;                /* COMPUTE POINTER TO MEMORY */    DEFLEN=DEFLEN+STACKPT-J; /* ACCOUNT FOR USED SPACE */    DO L=0 TO (STACKPT-J-1); /* COPY DATA FROM STACK INTO DEFLOC AREA */      CALL D.STORE(K+L,CORE(PTR.P+L));    END;    M=K-PTR.P;   /* GET CORRECTION FACTOR FOR POINTERS */    DO L=0 TO 4; /* UPDATE PTR.P,PTR.R,PTR.A,PTR.T,PTR.V */      CORE(ADDR(PTR.P)+L)=CORE(ADDR(PTR.P)+L)+M; /* COMPUTE POINTERS RELATIVE TO DEFLOC */    END;    DO L=0 TO 9; /* COPY NUM.X'S & PTR.X'S INTO (STORE POINTERS) */      CORE(STLOC+IPTR+L+1)=CORE(ADDR(NUM.P)+L);    END;    CORE(STLOC+IPTR+11)=STACKPT-J;   /* STORE TOTAL WORDS IN MOTIF DEF */    STACKPT=J; /* RESTORE STACK POINTER */    CALL SETUP.KEY(ACTIVE.KEY); /* RESTORE ACTIVE KEY */  END; /* OF CASE FOR MOTIF DEFINITION */  /* CHECK FOR PROPER END STATMENT */  IF TOKEN<>T.END THEN CALL ER.MEI;  ELSE DO; /* CHECK FOR MATCH */    ENABLE.EOL=1; /* STOP AT END OF LINE */    CALL SCAN; /* CHECK END LABEL */    ENABLE.EOL=0;    IF (TOKEN<>T.EOL) AND ((TOKEN<>T.PDEF+I)\(INFO<>IPTR)) THEN CALL ER.ELD;    ELSE CALL SCAN;  END;END DEFINE.STATEMENT;/* $SUBTITLE  Pitch Manipulation Routines *//*   CHECK.P   - COPIES PITCH  LIST ONTO STACK IF REQUIRED..    CHECK.R   - COPIES RHYTHM LIST ONTO STACK IF REQUIRED..    EXT.P     - EXTRACTS PITCH INFO FROM MEMORY INTO GLOBAL VARIABLES..    STR.P     - STORES   PITCH INFO INTO MEMORY FROM GLOBAL VARIABLES..    GET.PITCH - SCANS OFF A TRANSPOSITION PITCH IN PARENTHESES. */CHECK.P:  PROC; /* COPY PITCH LIST ON TO STACK FOR OPERATION */  DCL I FIXED;  IF EXAMOUNT<>0 THEN RETURN;       /* IF EXTERNAL MEMORY, WE KNOW THEY ARE ON STACK ALREADY */  IF PTR.P ILT SEQNLOC THEN RETURN; /* ALREADY ON STACK, AS OPPOSED TO DEFLOC */  IF STACKPT+NUM.P>STACKLEN THEN CALL ER.STK;  DO I=0 TO (NUM.P-1);    CORE(STACKLOC+STACKPT+I)=CORE(PTR.P+I);  END;  PTR.P=STACKLOC+STACKPT; /* NEW POINTER TO PITCHES */  STACKPT=STACKPT+NUM.P;END CHECK.P;CHECK.R:  PROC; /* COPY RHYTHM LIST ON TO STACK */  DCL I FIXED;  IF EXAMOUNT<>0 THEN RETURN;       /* IF EXTERNAL MEMORY, WE KNOW THEY ARE ON STACK ALREADY */  IF PTR.R ILT SEQNLOC THEN RETURN; /* ALREADY ON STACK */  IF STACKPT+(NUM.R+NUM.R)>STACKLEN THEN CALL ER.STK;  DO I=0 TO (NUM.R+NUM.R-1);    CORE(STACKLOC+STACKPT+I)=CORE(PTR.R+I);  END;  PTR.R=STACKLOC+STACKPT; /* NEW POINTER TO RHYTHMS */  STACKPT=STACKPT+NUM.R+NUM.R;END CHECK.R;DCL (UPPER,LOWER) FIXED; /* UPPER & LOWER HALVES OF PITCH INFO */EXT.P:  PROC(NUM); /* EXTRACT PITCH INFO */  DCL NUM FIXED;  UPPER=SHR(CORE(PTR.P+NUM),8)&"77";   /* white    key # 0-49   */  LOWER=CORE(PTR.P+NUM)&"177";         /* semitone key # 0-84   */END EXT.P;STR.P:  PROC(NUM); /* STORE PITCH INFO */  DCL NUM FIXED;  IF LOWER>84 THEN CALL ER.POR; /* PITCH OUT OF RANGE */  CORE(PTR.P+NUM)=(CORE(PTR.P+NUM)&"140200")\SHL(UPPER,8)\LOWER;END STR.P;GET.PITCH:  PROC; /* SCAN OFF PITCH IN PARENS */  CALL SCAN.AHEAD; /* SKIP TO PAREN */  IF NCHR<>A.LPAREN THEN CALL ER.TPM;  ELSE                 CALL GET.CHAR;  CALL SCAN.PITCH; /* SCAN OFF NEW PITCH */  CALL SCAN.AHEAD;  IF NCHR<>A.RPAREN THEN CALL ER.MTMP;  ELSE                 CALL GET.CHAR;  LOWER=INFO&"177"; UPPER=SHR(INFO,8)&"77"; /* EXTRACT FIELDS */END GET.PITCH;DCL KEY.CORRECTION(6) FIXED; /* HOLDS CORRECTION FOR KEY */DCL MOT.KEY           FIXED;SETUP.MOTIF.KEY:  PROC(ARG); /* SET UP FOR MOTIF */  DCL (ARG,I) FIXED;  DCL TABLE DATA (0, 4, 1, 5, 2, 6, 3, 0, 0, 0, 0, 3, 6, 2, 5, 1, 4, 0);  /*  FOR   KEYS  C  G  D  A  E  B F# C#  X  X  X  F BF EF AF DF GF CF */  /*  AND KEYSIGS 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 */  CALL SETUP.KEY(ARG); /* SET UP TABLES */  DO I=0 TO 6; /* SET UP INFO FOR EACH WHITE KEY */    KEY.CORRECTION(I)=SHARP.KEYS(I)-FLAT.KEYS(I); /* +1, 0, -1 */  END;  MOT.KEY=TABLE(ARG); /* STORE WHITE KEY OF KEYSIG - C,D,E,F,G,A,B */  CALL SETUP.KEY(ACTIVE.KEY); /* RESTORE KEY SIGNATURE */END SETUP.MOTIF.KEY;/* $SUBTITLE  Routines to Perform Motif Operations */DCL (WKEY,KEY#) FIXED; /* WKEY = WHITE KEY 0-6.   KEY# = SEMITONE KEY # 0-84 */CONVERT:  PROC(A); /* CONVERT 0-6 KEY DESIGNATION TO 0-11 SEMITONES */  DCL A     FIXED;  DCL TABLE DATA (0,2,4,5,7,9,11); /* MAPS WHITE KEYS TO SEMITONES - C,D,E,F,G,A,B */  WRITE(5)=A; WRITE(7)=7;          /* DIVIDE BY 7 */  WKEY=READ(4); A=READ(5);         /* COMPUTE WHITE KEY 0-6 & OCTAVE # */  KEY#=(A*12)+TABLE(WKEY);  KEY#=KEY#+KEY.CORRECTION(WKEY);  /* APPLY CORRECTION FOR KEY */END CONVERT;INVERT:  PROC; /* INVERT PITCHES ON STACK */  DCL (I,J) FIXED;  CALL CHECK.P; /* MOVE PITCHES TO STACK */  I=-1; /* NO FIRST PITCH YET */  DO J=0 TO (NUM.P-1); /* LOOP OVER PITCHES */    CALL EXT.P(J); /* LOOK UP PITCH */    IF LOWER<>(REST.MARK) THEN DO; /* SKIP OVER RESTS */      IF I=-1 THEN I=UPPER;           /* INVERT AROUND THIS PITCH */      CALL CONVERT(UPPER);            /* COMPUTE PITCH IN KEY */      LOWER=LOWER-KEY#;               /* COMPUTE SHARPNESS OF THIS NOTE */      UPPER=I+(I-UPPER);              /* INVERT AROUND WHITE KEYS ONLY */      CALL CONVERT(UPPER);            /* GET WHAT NEW PITCH WOULD BE */      LOWER=KEY#-LOWER;               /* APPLY SHARPNESS IN OPPOSITE DIRECTION */      CALL STR.P(J);                  /* RESTORE INVERTED PITCH */    END;  END;END INVERT;TRANSPOSE:  PROC; /* TRANSPOSE PITCHES ON STACK */  DCL (I,J,K,L) FIXED;  CALL CHECK.P; /* CHECK FOR PITCHES ON STACK */  CALL GET.PITCH; /* SCAN OFF SPECIFIED PITCH */  CALL CONVERT(UPPER); /* FIND OUT IF ANY CORRECTION REQUIRED */  I=UPPER; J=LOWER-KEY#; /* GET NEW WHITE KEY & SHARPNESS OF GOAL */  L=-1; /* NO FIRST PITCH YET */  DO K=0 TO (NUM.P-1); /* LOOP OVER PITCHES */    CALL EXT.P(K); /* LOOK UP PITCH */    IF LOWER<>REST.MARK THEN DO; /* IGNORE RESTS DURING TRANSPOSE */      IF L=-1 THEN DO; /* FIRST PITCH */        CALL CONVERT(UPPER); /* SEE WHAT CORECTION APPLIED */        I=I-UPPER; /* GET NUMBER OF WHITE KEYS TO TRANSPOSE */        J=J-(LOWER-KEY#); /* REDUCE CORRECTION FOR SHARPNESS OF FIRST NOTE */        L=0;      END;      CALL CONVERT(UPPER); /* COMPUTE WHAT KEY# SHOULD BE */      LOWER=LOWER-KEY#; /* COMPUTE SHARPNESS OF THIS NOTE */      UPPER=UPPER+I; /* ADD IN TRANSPOSE DISTANCE IN STEPS */      CALL CONVERT(UPPER); /* MAP TO UPPER */      LOWER=KEY#+J+LOWER; /* ADD IN OFFSET & CORRECTION */      CALL STR.P(K); /* STORE IT BACK */    END;  END;END TRANSPOSE;PITCH.RETROGRADE:  PROC; /* PERFORM PITCH RETROGRADE */  DCL (I,J) FIXED;  CALL CHECK.P;             /* MAKE SURE PITCHES ARE ON STACK */  DO I=0 TO SHR(NUM.P,1)-1; /* EXCHANGE PITCHES */    J=CORE(PTR.P+I);    CORE(PTR.P+I)=CORE(PTR.P+NUM.P-I-1);    CORE(PTR.P+NUM.P-1-I)=J;  END;    DO I=0 TO (NUM.P-1); /* CLEAN UP PHRASE, ENCLOSED, TIED TO BITS */    CORE(PTR.P+I)=CORE(PTR.P+I)&(NOT(B.ENCLOSED\B.PHRASED\B.TIEDTO));    IF I<>(NUM.P-1) THEN DO; /* CHECK NEXT NOTE FOR BITS */      CORE(PTR.P+I)=CORE(PTR.P+I)\(CORE(PTR.P+I+1)&(B.ENCLOSED\B.PHRASED));    END;  END;END PITCH.RETROGRADE;/* $page */RHYTHM.RETROGRADE:  PROC; /* PERFORM RHYTHM RETROGRADE */  DCL (I,J,K,L,M) FIXED;  CALL CHECK.R; /* COPY RHYTHM ON TO STACK */  DO I=0 TO SHR(NUM.R,1)-1; /* PROCESS EACH WORD PAIR */    J=PTR.R+I+I; K=PTR.R+NUM.R+NUM.R-I-I; /* COMPUTE POINTERS */    L=CORE(J); M=CORE(J+1); /* SWAP */    CORE(J)=CORE(K-2); CORE(J+1)=CORE(K-1);    CORE(K-2)=L; CORE(K-1)=M;  END;END RHYTHM.RETROGRADE;RETROGRADE:  PROC; /* PERFORM BOTH PITCH AND RHYTHM RETROGRADE */  CALL PITCH.RETROGRADE;  CALL RHYTHM.RETROGRADE;END RETROGRADE;STRICT.TRANSPOSE:  PROC; /* PERFORM STRICT TRANSPOSE */  DCL (I,J,K,L) FIXED;  CALL CHECK.P; /* COPY TO STACK */  CALL GET.PITCH; /* SCAN OFF PITCH IN PARENS & SET IT UP */  I=UPPER; J=LOWER; L=-1; /* NO FIRST PITCH YET */  DO K=0 TO (NUM.P-1); /* LOOP OVER PITCHES */    CALL EXT.P(K); /* GET PITCH */    IF LOWER<>(REST.MARK) THEN DO; /* IGNORE RESTS */      IF L=-1 THEN DO; /* FIRST PITCH */        I=I-UPPER; J=J-LOWER; /* GET TRANSPOSITION DISTANCES */        L=0;      END;      UPPER=UPPER+I; LOWER=LOWER+J;      CALL STR.P(K); /* PUT IT BACK */    END;  END;  I=MOT.KEY+I; /* COMPUTE NEW WHITE STEP KEY SIGNATURE */  DO WHILE I<0; I=I+7; J=J+12; END; /* UP AN OCTAVE   */  DO WHILE I>6; I=I-7; J=J-12; END; /* DOWN AN OCTAVE */  K=KEY.CORRECTION(MOT.KEY); /* GET ORIGINAL OFFSET FROM MOT.KEY */  DO WHILE MOT.KEY<>I; /* GO THROUGH CIRCLE OF FIFTHS TO FIND KEY */    MOT.KEY=MOT.KEY+3; J=J-7; /* GO UP A FOURTH; J GOES A FIFTH TOWARDS GOAL */    IF MOT.KEY>6 THEN DO; MOT.KEY=MOT.KEY-7; J=J+12; END;    KEY.CORRECTION(MOT.KEY)=KEY.CORRECTION(MOT.KEY)+1; /* SHARP SUB TONIC */    MOT.KEY=MOT.KEY+1; /* GO TO NEW TONIC (CIRCLE OF FIFTHS) */    IF MOT.KEY=7 THEN DO; MOT.KEY=0; J=J+12; END;  END;  DO I=0 TO 6; /* UPDATE KEY.CORRECTION FOR NEW OFFSET */    KEY.CORRECTION(I)=KEY.CORRECTION(I)+J-K; /* MOVE UP UNLESS STARTED SO */  END;END STRICT.TRANSPOSE;STRICT.INVERT:  PROC; /* PERFORM STRICT INVERT */  DCL (I,J,K) FIXED;  CALL CHECK.P; /* MOVE TO STACK */  I=-1; /* NO FIRST PITCH YET */  DO K=0 TO (NUM.P-1); /* LOOP OVER PITCHES */    CALL EXT.P(K); /* GET PITCH */    IF LOWER<>(REST.MARK) THEN DO;      IF I=-1 THEN DO; I=UPPER; J=LOWER; END; /* FIRST PITCH */      UPPER=I+(I-UPPER);      LOWER=J+(J-LOWER);      CALL STR.P(K); /* STORE IT */    END;  END;END STRICT.INVERT;