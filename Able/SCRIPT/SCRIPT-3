/* $subtitle Scan routines for pitch line, rhythm line, etc. *//* SCAN.PITCH RETURNS A 16 BIT NUMBER IN 'INFO'.  THE LOWER HALF IS THE.  STANDARD SYNCLAVIER II KEY NUMBER, 0-60.   THE UPPER HALF (USED FOR.  TONAL INVERSIONS & TRANSPOSITIONS) IS NUMBERED 0-35 REPRESENTING THE.  WHITE KEYS ONLY. */DCL DEFAULT.OCTAVE FIXED; /* DEFAULT TO USE IF NO OCTAVE SPECIFIED */DCL ACTIVE.KEY     FIXED; /* FOR THIS TRACK ONLY */DEFAULT.OCTAVE=3; /* START IN MIDDLE C OCTAVE (C3) */DCL SHARPS DATA (5,0,7,2,9,4,11); /* CAN YOUR FIGURE THIS OUT?? */DCL FLATS  DATA (11,4,9,2,7,0,5); /* IT REALLY WORKS WELL */DCL SHARPW DATA (3,0,4,1,5,2,6); /* SHARPED WHITE KEYS ONLY (GET IT NOW?) */DCL FLATW  DATA (6,2,5,1,4,0,3); /* FLATTED WHITE KEYS ONLY */DCL (SHARP.TABLE,FLAT.TABLE) (11) FIXED;DCL (SHARP.KEYS,FLAT.KEYS)    (6) FIXED;SETUP.KEY:  PROC(KEY); /* SET UP A KEY - PASS ARGUMENT */  DCL (I,KEY) FIXED;  DO I=0 TO 11; SHARP.TABLE(I)=0; FLAT.TABLE(I)=0; END; /* ASSUME C */  DO I=0 TO 6;  SHARP.KEYS(I)=0;  FLAT.KEYS(I)=0;  END;  IF KEY>10 THEN DO I=0 TO KEY-11; /* FLATTED KEY - LOOK UP EACH FLAT & MARK IT */    FLAT.TABLE(FLATS(I))=1;    FLAT.KEYS(FLATW(I)) =1;  END;  ELSE IF KEY>0 THEN DO I=0 TO KEY-1; /* SHARP KEY - MARK EACH SHARP */    SHARP.TABLE(SHARPS(I))=1;    SHARP.KEYS(SHARPW(I)) =1;  END;END SETUP.KEY;SCAN.KEY:  PROC; /* PROCEDURE TO SCAN OFF KEY SIGNATURE */  CALL SCAN; /* GET TOKEN TYPE */  IF TOKEN=T.A THEN DO; /* SPECIAL CHECK FOR 'A' */    TOKEN=T.KEY; INFO=3; /* 3 SHARPS FOR KEY OF A */  END;  IF TOKEN<>T.KEY THEN DO; CALL ER.MKI; INFO=0; END;END SCAN.KEY; /* DONE */SCAN.PITCH:  PROC; /* PROCEDURE TO SCAN PITCH FROM SOURCE FILE */  DCL (I,J)  FIXED;  DCL TABLE1 DATA (9,11,0,2,4,5,7); /* A, B, C, D, E, F, G */  DCL TABLE2 DATA (5,06,0,1,2,3,4); /* A, B, C, D, E, F, G */  IF (NCHR=A.R) OR (NCHR=A.PERIOD) THEN DO; /* USE R OR DOT FOR RESTS */    CALL GET.CHAR; INFO=REST.MARK; RETURN;  END;  IF (NCHR<A.A) OR (NCHR>A.G) THEN DO; /* PITCHES ARE A-G */    CALL ER.MPI; /* MISSING PITCH INFORMATION */    RETURN;  END;  INFO=TABLE1(NCHR-A.A)+SHL(TABLE2(NCHR-A.A),8); /* COMPUTE PITCH INFO - SEMITONES IN LOWER HALF, WHITE KEY # IN UPPER HALF */  CALL GET.CHAR; /* GET NEXT */  IF (NCHR=A.SHARP) OR (NCHR=A.F) OR (NCHR=A.N) THEN DO; /* ACCIDENTAL SPECIFIED */    DO WHILE (NCHR=A.SHARP) OR (NCHR=A.F) OR (NCHR=A.N);      IF NCHR=A.SHARP THEN INFO=INFO+1;      IF NCHR=A.F     THEN INFO=INFO-1;      CALL GET.CHAR;    END;  END; /* OF ACCIDENTAL SPECIFIED */  ELSE DO; /* NO NATURAL, SHARP, FLAT - CHECK FOR KEY SIGNATURE */    IF      SHARP.TABLE(INFO&"77") THEN INFO=INFO+1; /* SHARP */    ELSE IF FLAT.TABLE(INFO&"77")  THEN INFO=INFO-1; /* FLAT */  END;  IF (NCHR>=A.0) AND (NCHR<=A.9) THEN DO; /* OCTAVE SPECIFIED */    DEFAULT.OCTAVE=(NCHR-A.0); /* COMPUTE NEW OCTAVE NUMBER */    CALL GET.CHAR;  END;  INFO=INFO+(DEFAULT.OCTAVE*(12+7*256)); /* ADD IN OCTAVE */  IF (INFO&255)>84 THEN CALL ER.MPI;     /* INCORRECT PITCH */END SCAN.PITCH;/* $SUBTITLE  Scan Element of Rhythm Line *//*  THIS PROCEDURE IS USED TO SCAN A NOTE DURATION ELEMENT FROM THE.   SOURCE FILE.  THE DURATION OF THE NOTE IS RETURNED IN TWO NUMBERS.   (TOP & BOTTOM).  THE RATIO REPRESENTS THE FRACTION OF A BEAT IN.   THE NOTE.  FOR EXAMPLE,  FOR A QUARTER NOTE,  TOP=1 BOTTOM=4. */DCL (TOP,BOTTOM,LEVEL) FIXED;DCL POWERS DATA (1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768);DCL LCDS   DATA (3,5,7,11,13,17,19,23,29,31); /* PRIME NUMBERS FOR REDUCTION */SCAN.RHYTHM:  PROC; /* PROCESS AN ELEMENT OF RHYTHM LINE */  DCL (I,J,K) FIXED;  TOP=1; BOTTOM=1; /* INITIALIZE RATIO TO 1/1 (WHOLE NOTE) */  IF (NCHR>=A.A) AND (NCHR<=A.Z) THEN DO; /* LETTER - CHECK W, H, Q, E, S, T, X */    IF      NCHR=A.W THEN BOTTOM=1;    ELSE IF NCHR=A.H THEN BOTTOM=2;    ELSE IF NCHR=A.Q THEN BOTTOM=4;    ELSE IF NCHR=A.E THEN BOTTOM=8;    ELSE IF NCHR=A.S THEN BOTTOM=16;    ELSE IF NCHR=A.T THEN BOTTOM=32;    ELSE IF NCHR=A.X THEN BOTTOM=64;    ELSE CALL ER.MRI; /* MISSING OR INCORRECT RHYTHM LETTER */    CALL GET.CHAR; /* SKIP TO NEXT CHARACTER */  END;  ELSE DO; /* MUST BE NUMBER */    BOTTOM=SCAN.NUMBER; /* SCAN OFF NUMBER - PROBABLY BOTTOM */    IF NCHR=A.SLASH THEN DO; /* RATIO SPECIFIED */      CALL GET.CHAR;      TOP=BOTTOM; BOTTOM=SCAN.NUMBER; /* GET BOTTOM OF RATIO */    END;  END;  I=0; /* ASSUME NO DOTS */  DO WHILE (NCHR=A.T) OR (NCHR=A.PERIOD); /* ALLOW TRIPLETS & DOTTED NOTES */    IF NCHR=A.PERIOD THEN I=I+1; /* COUNT NUMBER OF DOTS */    ELSE DO; /* TRIPLET - MULTIPLY DURATION BY 2/3 */      IF BOTTOM<0 THEN CALL ER.OVF; /* OVERFLOW WILL HAPPEN */      J=TOP; K=SHL(BOTTOM,1); /* SAVE FOR OVERFLOW CHECK */      TOP=TOP+TOP; /* TIMES TWO */      BOTTOM=BOTTOM+BOTTOM+BOTTOM; /* TIMES THREE */      IF (TOP ILT J) OR (BOTTOM ILT K) THEN CALL ER.OVF;    END;    CALL GET.CHAR;  END; /* OF DO WHILE */  IF I<>0 THEN DO; /* DOTTED NOTES - EXTEND DURATION AS REQUIRED */    WRITE(5)=TOP; WRITE(6)=(POWERS(I+1)-1); TOP=READ(5); /*  * 3  7  15 */    IF READ(4)<>0 THEN CALL ER.OVF;    WRITE(5)=BOTTOM; WRITE(6)=POWERS(I); BOTTOM=READ(5); /*  * 2  4   8 */    IF READ(4)<>0 THEN CALL ER.OVF;  END;  /**/  /* CHECK FOR OCCURRENCES OF + AND - AND ADD RATIOS */  IF LEVEL<>0 THEN RETURN; /* DO NOT CHECK FOR + OR - UNLESS LEVEL 0 */  CALL SCAN.AHEAD; /* ALLOW SPACES & COMMENTS HERE */  DO WHILE (NCHR=A.PLUS) OR (NCHR=A.MINUS); /* SCAN OFF ADDED VALUES */    CALL PUSH(TOP); CALL PUSH(BOTTOM); CALL PUSH(NCHR); /* SAVE INFO */    LEVEL=1; /* KEEP PRIORITY */    CALL GET.CHAR; /* SKIP OVER + & - */    CALL SCAN.AHEAD; /* ALLOW SPACES AFTER + OR - */    CALL SCAN.RHYTHM; /* RECURSIVE CALL TO GET VALUE */    LEVEL=0; /* RESTORE LEVEL */    K=POP; J=POP; I=POP; /* GET NCHR,BOTTOM,TOP */    WRITE(5)=I; WRITE(6)=BOTTOM; I=READ(5);    IF (READ(4)<>0) THEN CALL ER.OVF; /* OVERFLOW */    WRITE(5)=TOP; WRITE(6)=J; TOP=READ(5);    IF (READ(4)<>0) THEN CALL ER.OVF;    WRITE(5)=J; WRITE(6)=BOTTOM; BOTTOM=READ(5);    IF (READ(4)<>0) THEN CALL ER.OVF;    IF K=A.PLUS THEN DO; /* ADD TO DURATION */      TOP=TOP+I;      IF TOP ILT I THEN CALL ER.OVF;    END;    ELSE DO; /* SUBTRACT FROM DURATION */      IF I ILT TOP THEN CALL ER.MRI;      TOP=I-TOP;    END;        /* CHECK FOR LCD'S TO REDUCE OVERFLOWS */        DO WHILE ((TOP\BOTTOM)&1)=0; /* SCALE BY 2'S */      TOP=SHR(TOP,1); BOTTOM=SHR(BOTTOM,1);    END;    DO I=0 TO 9; /* TEST 10 PRIME NUMBERS */      J=LCDS(I); /* GET LCD */      WRITE(5)=TOP; WRITE(7)=J;      IF READ(4)=0 THEN DO; /* NO REMAINDER */        K=READ(5); /* GET POSSIBLE NEW TOP */        WRITE(5)=BOTTOM; WRITE(7)=J;        IF READ(4)=0 THEN DO; /* COMPUTE NEW RATIO */           TOP=K; BOTTOM=READ(5); I=I-1; /* RESET I TO TRY AGAIN */        END;      END;    END; /* OF LOOP ON PRIME NUMBERS */    CALL SCAN.AHEAD;  END; /* OF DO WHILE */END SCAN.RHYTHM;  /* $SUBTITLE  Routines to Scan P, R, V, T, and A Lines *//*  EACH OF THE FOLLOWING ROUTINES HANDLES A SCRIPT NOTELIST LINE,.   AND ALLOWS FOR THE LINE TO BE CONTINUED.  THE SCANNED ITEMS ARE.   PLACED ON THE PUSH DOWN STACK.  EACH HANDLES REPEATED GROUPS,.   AS WELL AS SPECIAL PHRASING, CHORDS, OR N-TUPLETS, AS NEEDED. */DCL B.ENCLOSED  LIT '"000200"'; /* FLAG BITS FOR SPECIAL CODES - stored in pitch word */DCL B.PHRASED   LIT '"040000"';DCL B.TIEDTO    LIT '"100000"';/*  COPY.OVER IS USED TO REPLICATE PITCHES, RHYTHMS, ARTICULATIONS,    DYNAMICS, AND TIMBRES BY THE USE OF PARENTHESES AS IN:           P   C  D  E  (F  G  A) 3  B  C    IT SCANS OFF THE RIGHT PARENTHESIS,  THE # OF REPETITIONS,  AND    REPLICATES THE INFORMATION ON THE STACK AS REQUIRED */COPY.OVER:  PROC(TOTAL,LEN); /* PROC TO REPLICATE STACK INFO */  DCL (TOTAL,LEN,I,J,K,L) FIXED;  IF NCHR=A.RPAREN THEN CALL GET.CHAR; /* SHOULD BE RIGHT PAREN */  ELSE                CALL ER.MTMP; /* ELSE WRONG # OF PARENS */  CALL SCAN.AHEAD; /* SKIP SPACES */  I=SCAN.NUMBER; /* GET # OF TIMES TO REPEAT */  J=STACKPT+1; /* COMPUTE POINTER TO START OF DATA FOR FIRST COPY */  DO K=1 TO I; /* REPLICATE DATA */    DO L=0 TO (LEN-1); /* COPY OVER WORDS */      CALL PUSH(CORE(STACKLOC+J+L)); /* STORE WORD ON STACK */    END;    J=STACKPT-LEN; /* GET POINTER FOR NEXT COPY */    TOTAL=TOTAL+LEN; /* COMPUTE TOTAL # STORED */  END;  RETURN TOTAL;END COPY.OVER;/* SCAN ARTICULATION OR DYNAMIC LINE */SCAN.ATV.LINE:  PROC(TYP); /* SCAN OFF ARTIC, TIMBRE, OR VOLUME LINE */  DCL (TYP,I,J,K) FIXED;  IF (READ("312")-64) ILE PDL_BOTTOM THEN CALL ER.STK; /* TOO MUCH RECURSION */  I=0; /* INITIALIZE COUNT */  SCAN.START:;  ENABLE.EOL=1; /* SET FLAG TO STOP SCAN AT END OF LINE */  CALL SCAN.AHEAD; /* SKIP TO FIRST DIGIT */  DO WHILE (NCHR<>0) AND (NCHR<>A.RPAREN) AND (NCHR<>(-1)); /* SCAN UNTIL EOL OR R PAREN */    IF NCHR=A.LPAREN THEN DO; /* LEFT PAREN - REPEATED GROUP */      CALL GET.CHAR; CALL SCAN.AHEAD;      CALL PUSH(I); /* SAVE # SCANNED */      K=LINE.NO;      J=SCAN.ATV.LINE(TYP); /* SCAN OF # IN PARENS */      IF TOKEN<>TYP THEN DO; LINE.NO=K; CALL ER.MTMP; END;      ENABLE.EOL=1; /* KEEP FLAG AT 1 */      STACKPT=STACKPT-J; /* RESET STACK */      I=COPY.OVER(POP,J); /* REPLICATE INFO */    END;    ELSE DO; /* MUST BE NUMBER */      CALL SCAN.NUMERIC;      CALL ADJUST.NUM(1); /* GET TO .1% */      IF INFO>1000 THEN CALL ER.TMD; /* NUMBER TOO LARGE */      CALL PUSH(INFO); /* STORE ON STACK */      I=I+1;    END;    CALL SCAN.AHEAD;  END; /* OF DO WHILE */  ENABLE.EOL=0; /* ALLOW EOL'S TO BE SKIPPED */  IF NCHR=0 THEN DO; /* END OF LINE */    CALL SCAN; /* GET FIRST OF NEXT LINE */    IF TOKEN=TYP THEN GOTO SCAN.START;  END;  RETURN I;END SCAN.ATV.LINE;/* $page *//* SCAN.PITCH.LINE - SCANS A LINE OF PITCH VALUES ON TO STACK */DCL (ENCLOSED,PHRASED) FIXED; /* USED FOR [] AND {} */SCAN.PITCH.LINE:  PROC; /* SCAN A LINE OF PITCHES */  DCL (I,J,K) FIXED;  IF (READ("312")-64) ILE PDL_BOTTOM THEN CALL ER.STK; /* TOO MUCH RECURSION */  I=0; /* INITIALIZE COUNT OF NOTES SCANNED */  SCAN.START:;  ENABLE.EOL=1; /* SET FLAG TO STOP SCAN AT END OF LINE */  CALL SCAN.AHEAD; /* SKIP TO FIRST CHARACTER */  DO WHILE ((NCHR<>0) AND (NCHR<>A.RPAREN) AND (NCHR<>(-1))); /* SCAN UNTIL EOL OR R PAREN OR EOF */    IF NCHR=A.LPAREN THEN DO; /* LEFT PAREN - REPEATED GROUP */      CALL GET.CHAR; CALL SCAN.AHEAD; /* SKIP OVER PAREN */      CALL PUSH(I); /* SAVE # SCANNED */      K=LINE.NO; TOKEN=T.P; /* SET UNIQUE TOKEN TYPE HERE */      J=SCAN.PITCH.LINE; /* SCAN LIST ON TO STACK; GET # SCANNED */      IF TOKEN<>T.P THEN DO; LINE.NO=K; CALL ER.MTMP; END;      ENABLE.EOL=1; /* KEEP FLAG AT 1 */      STACKPT=STACKPT-J; /* RESET POINTER TO START OF LIST */      I=COPY.OVER(POP,J); /* LOOK OLD VALUE & REPLICATE DATA */    END;    ELSE IF NCHR=A.LBRACKET THEN DO; /* LEFT BRACKET - CHORD */      IF ENCLOSED THEN CALL ER.MBB; /* MISSING RIGHT BRACKET */      ENCLOSED=1; /* INDICATE CHORD */      CALL GET.CHAR; CALL SCAN.AHEAD;    END;    ELSE IF NCHR=A.LBRACE THEN DO; /* LEFT BRACE - PHRASED */      IF PHRASED THEN CALL ER.MBB;      PHRASED=1; /* INDICATE SLUR */      CALL GET.CHAR; CALL SCAN.AHEAD;    END;    ELSE IF NCHR=A.RBRACKET THEN DO; /* RIGHT BRACKET - END OF ENCLOSED */      IF ENCLOSED=0 THEN CALL ER.MBB; /* MISSING LEFT BRACKET */      ENCLOSED=0; /* END OF BRACKETS */      IF I=0 THEN CALL ER.IFM; /* NO NOTES SCANNED IN BRACKETS - ERROR */      ELSE DO; /* REMOVE BRACKET FROM LAST NOTE */        CORE(STACKLOC+STACKPT-1)=CORE(STACKLOC+STACKPT-1)&(NOT(B.ENCLOSED)); /* TURN OFF BIT */      END;      CALL GET.CHAR; CALL SCAN.AHEAD; /* MOVE ON TO NEXT CAHARACTER */    END;    ELSE IF NCHR=A.RBRACE THEN DO; /* RIGHT BRACE - END OF PHRASING */      IF PHRASED=0 THEN CALL ER.MBB; /* MISSING LEFT BRACE */      PHRASED=0; /* END OF PHRASE */      IF I=0 THEN CALL ER.IFM; /* NO NOTES SCANNED - ERROR */      ELSE DO; /* REMOVE PHRASING FROM LAST NOTE */        CORE(STACKLOC+STACKPT-1)=CORE(STACKLOC+STACKPT-1)&(NOT(B.PHRASED));      END;      CALL GET.CHAR; CALL SCAN.AHEAD;    END;    ELSE DO; /* MUST BE PITCH ITEM */      CALL SCAN.PITCH; /* SCAN OFF PITCH */      IF ENCLOSED THEN INFO=INFO\B.ENCLOSED; /* ENCLOSED IN BRACKETS */      IF PHRASED  THEN INFO=INFO\B.PHRASED;  /* BRACES */      CALL PUSH(INFO); /* PUSH IT */      I=I+1; /* ONE MORE PITCH SCANNED */    END;    CALL SCAN.AHEAD; /* GET NEXT CHARACTER */    IF (ENCLOSED AND PHRASED) THEN CALL ER.PHBR; /* NOT ALLOWED */  END; /* OF DO WHILE */  ENABLE.EOL=0; /* RESET FLAG TO SKIP EOL'S */  IF NCHR=0 THEN DO; /* END OF LINE */    CALL SCAN; /* GET FIRST OF NEXT LINE */    IF (TOKEN=T.STMT) AND (INFO=P.STATEMENT.#) THEN DO; /* CHECK FOR PITCH LINE */      TOKEN=T.P; /* INDICATE PITCH LINE */      GOTO SCAN.START;    END;  END;  RETURN I; /* RETURN # OF PITCHES SCANNED */END SCAN.PITCH.LINE;/* $page *//* SCAN.RHYTHM.LINE - SCANS A LINE OF NOTE DURATIONS ON TO STACK...  *** NOTE - THE VALUE RETURNED BY SCAN.RHYTHM.LINE IS THE NUMBER OF WORDS.             OF DATA THAT WAS PUSHED ON TO THE STACK.  THIS IS TWICE THE.             NUMBER OF RHYTHMS SCANNED. */SCAN.RHYTHM.LINE:  PROC; /* SCAN A RHYTHM LINE */  DCL (I,J,K) FIXED;  IF (READ("312")-64) ILE PDL_BOTTOM THEN CALL ER.STK; /* TOO MUCH RECURSION */  I=0; /* INITIALIZE COUNT */  SCAN.START:;  ENABLE.EOL=1;  CALL SCAN.AHEAD; /* SKIP TO FIRST RHYTHM */  DO WHILE (NCHR<>0) AND (NCHR<>A.RPAREN) AND (NCHR<>(-1)); /* SCAN UNTIL EOL OR R PAREN */    IF NCHR=A.LPAREN THEN DO; /* LEFT PAREN - REPEATED GROUP */      CALL GET.CHAR; CALL SCAN.AHEAD; /* SKIP OVER PAREN */      CALL PUSH(I); /* SAVE # SCANNED */      K=LINE.NO;      J=SCAN.RHYTHM.LINE; /* SCAN OFF ENCLOSED LINE */      IF TOKEN<>T.R THEN DO; LINE.NO=K; CALL ER.MTMP; END;      ENABLE.EOL=1; /* KEEP FLAG AT 1 */      STACKPT=STACKPT-J; /* RESET POINTER BY # OF WORDS ON STACK */      I=COPY.OVER(POP,J); /* LOOK UP OLD VALUE, COPY OVER NEW DATA */    END;    ELSE DO; /* MUST BE RHYTHM - SCAN IT */      CALL SCAN.RHYTHM; /* SCAN OFF RHYTHM */      CALL PUSH(TOP); CALL PUSH(BOTTOM); /* SAVE RATIO */      I=I+2; /* TWO WORDS ON STACK */    END;    CALL SCAN.AHEAD; /* SKIP TO NEXT CHARACTER */  END; /* OF DO WHILE */  ENABLE.EOL=0; /* ALLOW END OF LINE */  IF NCHR=0 THEN DO; /* END OF LINE */    CALL SCAN; /* GET FIRST OF NEXT LINE */    IF TOKEN=T.R THEN GOTO SCAN.START;  END;  RETURN I; /* RETURN # OF WORDS ON STACK */END SCAN.RHYTHM.LINE;