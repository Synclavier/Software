/* $subtitle Module of Tempo Control Routines *//* GLOBAL TEMPO INFORMATION IS STORED IN SEVERAL ARRAYS:.    1. BEAT.LIST - HOLDS LIST OF TEMPO CHANGE POINTS.    2. RIT.LIST  - ENTRY SET TRUE IF GRADUAL FS. INSTANT CHANGE.    3. SHAPE.LIST - ENTRY IS TRUE FOR LIN VS LOG ACCEL.    4. IN.LIST    - HOLDS NUMBER OF 1/4 BEAT UNITS OVER WHICH TO ACCEL/RIT.    5. NEWT.MSB,NEWT.LSB - HOLDS NEW TEMPO GOAL .    6. NEWT.TOP,NEWT.BOTTOM - HOLDS NEW BEAT UNIT */DCL MAX.TEMPO.POINTS LIT '100';DCL (AT.PTR)         FIXED; /* POINTER FOR 'AT' STATEMENT DATA ARRAYS */DCL (ANY.NOTES)      FIXED; /* SET TRUE IF ANY NOTES EMITTED */DCL (BEAT.LIST,RIT.LIST,SHAPE.LIST,IN.LIST,NEWT.MSB,NEWT.LSB) (MAX.TEMPO.POINTS) FIXED;DCL (NEWT.TOP,NEWT.BOTTOM) (MAX.TEMPO.POINTS) FIXED; /* NEW BEAT UNIT *//* THESE VARIABLES MUST BE DECLARED IN ORDER BECAUSE THEY ARE ACCESSED WITH 'CORE' */DCL (BA.MSB,BA.LSB,BA.LLSB) FIXED; /* THE BEAT ACCUMULATOR */DCL (MB.MSB,MB.LSB,MB.LLSB) FIXED; /* THE MODEL BEAT TIME ACCUMULATOR */DCL (MR.MMSB,MR.MSB,MR.LSB) FIXED; /* THE MODEL REAL TIME ACCUMULATOR */DCL (ACCEL.SHAPE)           FIXED;DCL (BEAT.PTR,TEMPO.DIST,GOAL.MSB,GOAL.LSB,RITARDING) FIXED;AT.STATEMENT:  PROC; /* PROCEDURE TO SCAN OFF AT STATEMENT */  IF ANY.NOTES THEN CALL ER.SYN9; /* AT NOT ALLOWED AFTER NOTELIST START */  IF BEAT.SCANNED THEN CALL ER.SYN7; /* NOT ALLOWED AFTER BEAT REFERENCE */  IF AT.PTR>=MAX.TEMPO.POINTS THEN DO; /* TOO MANY AT STATEMENTS */    CALL ER.SYN10; AT.PTR=AT.PTR-1;  END;  CALL SCAN; /* LOOK FOR 'BEAT' */  IF TOKEN<>T.BEAT THEN CALL ER.IFM; /* ERROR */  ELSE                  CALL SCAN.NUMERIC; /* SCAN OFF BEAT NUMBER */  CALL ADJUST.NUM(0); /* IGNORE DECIMAL POINTS HERE */  IF INFO=0 THEN CALL ER.IBN; /* ILLEGAL BEAT NUMBER */  ELSE           INFO=INFO-1;  IF AT.PTR=0 THEN DO; /* STORE STARTING TEMPO FOR RESETTING */    BEAT.LIST(0)=0; NEWT.MSB(0)=TEMPO.MSB; NEWT.LSB(0)=TEMPO.LSB;    NEWT.TOP(0)=BU.TOP; NEWT.BOTTOM(0)=BU.BOTTOM; /* SAVE BEAT UNIT AS WELL */    AT.PTR=AT.PTR+1;  END;  IF INFO ILT BEAT.LIST(AT.PTR-1) THEN CALL ER.BNOO; /* BEAT NUMBER OUT OF ORDER */  BEAT.LIST(AT.PTR)=INFO; /* SAVE BEAT NUMBER */  CALL SCAN; /* SCAN TO NEXT ITEM */  IF (TOKEN=T.STMT) AND (INFO=TEMPO.STATEMENT.#) THEN DO;    CALL SCAN.TEMPO; /* SCAN OFF A TEMPO */    NEWT.MSB(AT.PTR)=TEMPO.MSB; NEWT.LSB(AT.PTR)=TEMPO.LSB;    NEWT.TOP(AT.PTR)=BU.TOP; NEWT.BOTTOM(AT.PTR)=BU.BOTTOM;    IF TOKEN=T.IN THEN CALL ER.IFM; /* NOT ALLOWED AFTER TEMPO */  END;  ELSE DO; /* NOT TEMPO - CHECK FURTHER */    IF TOKEN=T.PSHAPE THEN DO; SHAPE.LIST(AT.PTR)=INFO; CALL SCAN; END; /* SAVE LOG/LIN */    ELSE SHAPE.LIST(AT.PTR)=1; /* DO LINEAR IF NOT SPECIFIED */    IF TOKEN<>T.RIT THEN CALL ER.IFM; /* LOOK FOR ACCEL/OR RIT */    ELSE                 CALL SCAN; /* SKIP OVER IT - GET TO */    IF TOKEN<>T.TO THEN CALL ER.IFM; /* LOOK FOR 'TO' */    CALL SCAN.TEMPO; /* SCAN OFF NEW TEMPO */    NEWT.MSB(AT.PTR)=TEMPO.MSB; NEWT.LSB(AT.PTR)=TEMPO.LSB;    NEWT.TOP(AT.PTR)=BU.TOP; NEWT.BOTTOM(AT.PTR)=BU.BOTTOM;    IF TOKEN=T.IN THEN DO; /* SCAN OFF GRADUAL ACCEL/RIT */      CALL SCAN.NUMERIC; /* GET DISTANCE */      CALL ADJUST.NUM(1); /* ALLOW .1 BEAT HERE */      WRITE(5)=INFO; WRITE(6)=10; INFO=READ(5); /* MULTIPLY BY 10 */      WRITE(7)=25; INFO=READ(5); /* COMPUTE # OF 1/4 BEAT SEGMENTS */      IF SHAPE.LIST(AT.PTR)=0 THEN IN.LIST(AT.PTR)=INFO+2; /* REACHES GOAL 1 EARLY */      ELSE IN.LIST(AT.PTR)=INFO+1; /* 5 TEMPOS FOR 4 STEPS (!!) */      IF INFO<>0 THEN RIT.LIST(AT.PTR)=1; /* SET TRUE FOR ACCEL/RIT */      CALL SCAN; /* GET NEXT TOKEN */    END;  END;  AT.PTR=AT.PTR+1; /* INCREMENT POINTER TO NEXT ON LIST */  BEAT.LIST(AT.PTR)=(-1); /* SET UP LARGE BEAT NUMBER END POINT */END AT.STATEMENT;/* $SUBTITLE  Compute New Tempo *//*   THIS ROUTINE IS CALLED TO PERFORM ACCELERANDOS AND RITARDS.  AT EACH.    1/4 BEAT POINT,  THE TEMPO IS EXAMINED AND CHANGED IF REQUIRED. */COMPUTE.NEW.TEMPO:  PROC; /* COMPUTE NEW TEMPO FOR THIS SEGMENT */  DCL (I,J,K,L) FIXED;  IF AT.PTR=0 THEN RETURN; /* NO AT STATEMENTS - TEMPO DOES NOT CHANGE */  DO WHILE (BEAT.LIST(BEAT.PTR) ILE MB.MSB); /* ASCAN LIST */    IF RIT.LIST(BEAT.PTR)=0 THEN DO; /* NO ACCEL/RIT - GO TO NEW TEMPO IMMED */      TEMPO.MSB=NEWT.MSB(BEAT.PTR); TEMPO.LSB=NEWT.LSB(BEAT.PTR);      BU.TOP=NEWT.TOP(BEAT.PTR); BU.BOTTOM=NEWT.BOTTOM(BEAT.PTR);      RITARDING=0; /* NOT RITARDING */    END;    ELSE DO; /* RITARDING - SET UP NEW GOAL */      BU.TOP=NEWT.TOP(BEAT.PTR); BU.BOTTOM=NEWT.BOTTOM(BEAT.PTR); /* CHANGE BEAT UNIT IMMED */      TEMPO.DIST=IN.LIST(BEAT.PTR); /* GET NUMBER OF 1/4 BEATS OVER WHICH TO CHANGE */      GOAL.MSB=NEWT.MSB(BEAT.PTR); GOAL.LSB=NEWT.LSB(BEAT.PTR); /* GOAL TEMPO */      ACCEL.SHAPE=SHAPE.LIST(BEAT.PTR); /* LOOK UP SHAPE TOO */      RITARDING=1;    END;    BEAT.PTR=BEAT.PTR+1; /* MOVE ON TO NEXT TEMPO SEGMENT */  END; /* OF DO WHILE */  IF RITARDING THEN DO; /* COMPUTE NEW ACTIVE TEMPO FOR THIS SEGMENT */    I=GOAL.MSB-TEMPO.MSB; J=GOAL.LSB-TEMPO.LSB; /* GET DISTANCE */    IF GOAL.LSB ILT TEMPO.LSB THEN I=I-1; /* BORROW */    IF (I\J)=0 THEN RITARDING=0; /* WE HAVE REACHED GOAL */    K=0; /* ASSUME POSITIVE */    IF I<0 THEN DO; /* NEGATE */      I=NOT(I); J=NOT(J)+1; IF J=0 THEN I=I+1;      K=1; /* INDICATE NEGATIVE NUMBER */    END;    WRITE(5)=I; WRITE(7)=TEMPO.DIST; I=READ(5); /* GET 1/N OF DISTANCE */    L=READ(4); WRITE(5)=J; WRITE(4)=L; WRITE(7)=TEMPO.DIST; J=READ(5);    IF K THEN DO; /* NEGATE */      I=NOT(I); J=NOT(J)+1; IF J=0 THEN I=I+1;    END;    IF TEMPO.DIST<>1 THEN TEMPO.DIST=TEMPO.DIST-1; /* REDUCE FOR NEXT TIME */    IF ACCEL.SHAPE=0 THEN DO; /* LOG CURVE - DOUBLE RATE */      I=SHL(I,1); IF J<0 THEN I=I\1; J=SHL(J,1);    END;    TEMPO.MSB=TEMPO.MSB+I; TEMPO.LSB=TEMPO.LSB+J; /* DO IT */    IF TEMPO.LSB ILT J THEN TEMPO.MSB=TEMPO.MSB+1; /* CARRY */    IF (K=0) THEN DO; /* OVERFLOW CHECK FOR POS MOVEMENTS */      IF (TEMPO.MSB IGT GOAL.MSB)      OR ((TEMPO.MSB=GOAL.MSB)&(TEMPO.LSB IGT GOAL.LSB)) THEN DO;        TEMPO.MSB=GOAL.MSB; TEMPO.LSB=GOAL.LSB;      END;    END;    ELSE DO; /* CHECK FOR UNDERFLOW */      IF (TEMPO.MSB ILT GOAL.MSB)      OR ((TEMPO.MSB=GOAL.MSB)&(TEMPO.LSB ILT GOAL.LSB)) THEN DO;        TEMPO.MSB=GOAL.MSB; TEMPO.LSB=GOAL.LSB;      END;    END;  END; /* OF CASE FOR RITARDING */END COMPUTE.NEW.TEMPO;INITIALIZE.BA:  PROC; /* PROCEDURE TO INITIALIZE TEMPO INFO FOR NOTELIST */  BA.MSB=0;  BA.LSB=0; BA.LLSB=0;  MB.MSB=0;  MB.LSB=0; MB.LLSB=0;  MR.MMSB=0; MR.MSB=0; MR.LSB=0;  BEAT.PTR=0; RITARDING=0;  CALL COMPUTE.NEW.TEMPO; /* LOOK UP INITIAL TEMPO & SET UP ACCEL IF REQD */END INITIALIZE.BA;/* $SUBTITLE  Routines to Compute Starting Times for Western Note List *//*   WHEN A WESTERN NOTE LIST IS BEING GENERATED,  THE STARTING TIME (IN.    BEATS) IS ACCUMULATED IN AN ACCUMULATOR...    THE COMPILER MODELS THE SYNCLAVIER II TIME BASE SO THAT.    ACCELLERANDOS & RITARDS CAN EASILY BE PERFORMED. */DCL (B.MSB,B.LSB,B.LLSB) FIXED; /* LENGTH OF A NOTE IN BEATS */DCL (NOTE.SEC,NOTE.MS)   FIXED; /* SECONDS & MILLISECONDS FOR NOTE START */COMPUTE.BEAT:  PROC; /* USES TOP & BOTTOM TO COMPUTE LENGTH OF NOTE IN BEATS */  DCL (I,B) FIXED;  IF (AT.PTR<>0) AND (BA.LSB IGE "177400") THEN DO; /* CHECK FOR IMINENT BEAT UNIT CHANGE */    I=BEAT.PTR; /* GET CURRENT POINTER TO LIST */    DO WHILE BEAT.LIST(I) ILE (BA.MSB+1); /* FIND NEXT POSSIBLE BEAT UNIT */      BU.TOP=NEWT.TOP(I); BU.BOTTOM=NEWT.BOTTOM(I); /* LOOK UP BEAT UNIT */      I=I+1;    END;  END;  WRITE(5)=BOTTOM; WRITE(6)=BU.TOP; B=READ(5); /* TO GET BEAT RATIO */  IF READ(4)<>0 THEN CALL ER.OVF;  WRITE(5)=TOP; WRITE(6)=BU.BOTTOM; /* COMPUTE NEW TOP */  IF READ(4) IGE B THEN CALL ER.OVF; /* OVERFLOW */  WRITE(7)=B; B.MSB=READ(5); /* COMPUTE MSB */  I=READ(4); WRITE(5)=0; WRITE(4)=I; WRITE(7)=B; B.LSB=READ(5);  I=READ(4); WRITE(5)=0; WRITE(4)=I; WRITE(7)=B; B.LLSB=READ(5);END COMPUTE.BEAT;COMPUTE.NOTE.START.TIME:  PROC; /* COMPUTE STARTING TIME OF NOTE (ROUNDED) */  DCL (I,J,NOTE.LSB)           FIXED;  DCL (SEC.CARRIES,MS.CARRIES) FIXED; /* CARRIES INTO SEC & MS */  I=MB.MSB; J=MB.LSB+"040000"; /* GET CURRENT MODEL TIME + 1/4 BEAT */  IF J=0 THEN DO; /* OUR MODEL CARRIED OUT */    I=I+1; IF I=0 THEN CALL ER.OVF;  END;  DO WHILE (BA.MSB IGT I)\((BA.MSB=I)&(BA.LSB IGE J));    MR.LSB=MR.LSB+TEMPO.LSB; /* LSB MILLISECONDS IN 1/4 BEAT */    IF MR.LSB ILT TEMPO.LSB THEN DO; /* CARRY */      MR.MSB=MR.MSB+1;      IF MR.MSB=0 THEN DO;        MR.MMSB=MR.MMSB+1; IF MR.MMSB=0 THEN CALL ER.OVF;      END;    END;    MR.MSB=MR.MSB+TEMPO.MSB; /* ADD IN MSB */    IF MR.MSB ILT TEMPO.MSB THEN DO;      MR.MMSB=MR.MMSB+1; IF MR.MMSB=0 THEN CALL ER.OVF;    END;    MB.MSB=I; MB.LSB=J; /* UPDATE MODEL BEAT TIME */    CALL COMPUTE.NEW.TEMPO; /* COMPUTE NEW TEMPO IF REQUIRED */    J=MB.LSB+"040000"; /* ADVANCE MODEL TIME BY 1/4 BEAT */    IF J=0 THEN DO; /* CARRY IN OUR MODEL ACCUMULATOR */      I=I+1; IF I=0 THEN CALL ER.OVF;    END;  END;  NOTE.SEC=MR.MMSB; NOTE.MS=MR.MSB; NOTE.LSB=MR.LSB; /* GET TIME AT 1/4 BEAT POINT */  I=BA.LSB-MB.LSB; /* GET FRACTION OF A BEAT WE ARE ABOVE 1/4 BEAT POINT */  I=SHL(I,2)+SHR(BA.LLSB,14); /* COMPUTE 16 BIT NUMBER FOR FRACTIONAL MULTIPLY */  SEC.CARRIES=0; MS.CARRIES=0; /* INITIALIZE CARRY COUNTS */  WRITE(5)=I; WRITE(6)=TEMPO.MSB; /* GET THE LAST FRACTION OF 1/4 BEAT */  NOTE.MS=NOTE.MS+READ(4); /* GET MSB HERE */  IF NOTE.MS ILT READ(4) THEN SEC.CARRIES=1; /* CARRY 1 */  NOTE.LSB=NOTE.LSB+READ(5); /* COMPUTE LSB HERE FOR MILLISECOND ROUNDING */  IF NOTE.LSB ILT READ(5) THEN MS.CARRIES=1;  WRITE(5)=I; WRITE(6)=TEMPO.LSB; /* COMPUTE FRACTION OF MILLISECOND */  NOTE.LSB=NOTE.LSB+READ(4);  IF NOTE.LSB ILT READ(4) THEN MS.CARRIES=MS.CARRIES+1;  IF NOTE.LSB  <  0       THEN MS.CARRIES=MS.CARRIES+1; /* ROUND BY 1/2 MS. */  NOTE.MS=NOTE.MS+MS.CARRIES;  IF NOTE.MS ILT MS.CARRIES THEN SEC.CARRIES=SEC.CARRIES+1;  NOTE.SEC=NOTE.SEC+SEC.CARRIES;  IF NOTE.SEC ILT SEC.CARRIES THEN CALL ER.OVF; /* OVERFLOW */  IF NOTE.SEC IGE 1000 THEN CALL ER.OVF; /* OVERFLOW WILL HAPPEN */  WRITE(5)=NOTE.MS; WRITE(4)=NOTE.SEC; WRITE(7)=1000; /* DIVIDE FOR SEC, MS */  NOTE.SEC=READ(5); NOTE.MS=READ(4);END COMPUTE.NOTE.START.TIME;/* $SUBTITLE  Subroutines for Synchronization *//* TIMES ARE REPRESENTED IN 32 BIT QUANTITIES, WITH THE UNIT BEING.  MILLISECONDS.  TIME RATIOS ARE EXPRESSED IN 48 BIT QUANTITIES, 16.  BITS TO THE LEFT OF THE DECIMAL POINT AND 32 BITS TO THE RIGHT...  COMPUTATION FOR SYNCHRONIZATION:..  SMOOTH SYNCHRONIZATION IS PERFORMED BY COMPUTING A FIFTH POWER SPLINE.  TO CONNECT TWO SEGMENTS OF MUSIC.   THIS METHOD PROVIDES FOR THE.  SMOOTHEST SPLICING OF TWO SEGMENTS.  *//* DATA STORAGE FOR SYNCHRONIZATION */DCL MAX.SYNC.POINTS  LIT '100'; /* MAX # OF SYNC POINTS */DCL (SYNC.PTR)       FIXED; /* CURRENT POINTER */DCL (SYNC.SCANNED)   FIXED; /* SET TRUE IF ANY SYNC POINTS */DCL (DELAY.SCANNED)  FIXED; /* SET TRUE IF DELAY SCANNED */DCL (SMOOTH.SCANNED) FIXED; /* SET TRUE IF ANY SMOOTH STATEMENT */DCL (BEAT.MSB,BEAT.LSB)        (MAX.SYNC.POINTS) FIXED;DCL (REAL.MSB,REAL.LSB)        (MAX.SYNC.POINTS) FIXED;DCL (RAT.MSB,RAT.LSB,RAT.LLSB) (MAX.SYNC.POINTS) FIXED;DCL (DEL.MSB,DEL.LSB,DEL.LLSB) (MAX.SYNC.POINTS) FIXED;DCL (SMOOTH)                   (MAX.SYNC.POINTS) FIXED;DCL (NEGATIVE.DELTA)           (MAX.SYNC.POINTS) FIXED;DCL (MIN.BEAT.MSB,MIN.BEAT.LSB) FIXED; /* MONOTONICITY CHECK */DCL (MIN.REAL.MSB,MIN.REAL.LSB) FIXED; /* MONOTONICITY CHECK */BEAT.MSB(1)=-1; BEAT.LSB(1)=-1; /* SET UP GUARENTEED END POINT */RAT.MSB(0)=1; /* SET UP AVERAGE RATIO FOR FIRST SEGMENT TO BE 1.00 */SYNC.PTR=1; /* START POINT IS 0.00 TO 0.00 - OTHERS FOLLOW */LOOKUP.BEAT.NUMBER:  PROC; /* PROCEDURE TO LOOK UP TIME FROM 'BEAT' */  CALL SCAN.NUMERIC; /* SCAN THE BEAT NUMBER AFTER 'BEAT' */  CALL ADJUST.NUM(0); /* TOSS DECIMALS IF HERE */  IF INFO=0 THEN CALL ER.IBN; /* ILLEGAL BEAT NUMBER */  ELSE           INFO=INFO-1; /* WE START AT BEAT 0 HERE */  IF (BEAT.SCANNED=0)\(INFO ILT MB.MSB)\(MB.LSB<>0) THEN CALL INITIALIZE.BA;  BEAT.SCANNED=1; /* INDICATE 'BEAT' WAS SCANNED - NO MORE TEMPO CHANGES */  BA.MSB=INFO; /* FIND TIME OF THIS EXACT BEAT NUMBER */  BA.LSB=0; BA.LLSB=0;  CALL COMPUTE.NOTE.START.TIME; /* FIND TIME */  SECONDS=NOTE.SEC; MILLISECONDS=NOTE.MS; MILLI.LSBS=0;END LOOKUP.BEAT.NUMBER;/* COMPUTE.MS COMPUTES A 32 BIT TIME (IN MILLISECONDS) FORM.  TWO PASSED VARIABLES - SECONDS, MILLISECONDS */DCL (MS.MSB,MS.LSB) FIXED; /* HOLDS 32 BIT # OF MILLISECONDS */COMPUTE.MS:  PROC(SEC,MS); /* COMPUTE 32 BIT MS FROM SECONDS, MILLISECONDS */  DCL (SEC,MS) FIXED;  WRITE(5)=SEC; WRITE(6)=1000; /* SECONDS*1000 */  MS.MSB=READ(4); MS.LSB=READ(5);  MS.LSB=MS.LSB+MS;  IF MS.LSB ILT MS THEN MS.MSB=MS.MSB+1;END COMPUTE.MS;/* $SUBTITLE  48 bit Math Computations *//*  COMPUTE.RATIO COMPUTES A 48 BIT RATIO FOR SYNCHRONIZATION COMPUTATIONS..   IT IS PASSED AS ARGUMENTS TWO 32 BIT INTEGERS.  THE 48 BIT RATIO THAT.   IS COMPUTED CONTAINS 16 BITS TO THE LEFT AND 32 BITS TO THE RIGHT OF.   THE DECIMAL POINT.  IT IS STORED IN THE THREE GLOBAL RESULT VARIABLES */DCL (R.MSB,R.LSB,R.LLSB) FIXED; /* RESULT VARS */COMPUTE.RATIO:  PROC(MS1.MSB,MS1.LSB,MS2.MSB,MS2.LSB);  DCL (MS1.MSB,MS1.LSB,MS2.MSB,MS2.LSB) FIXED;  DCL I                                 FIXED;  R.MSB=0; R.LSB=0; R.LLSB=0; /* INITIALIZE */  IF MS2.MSB=0 THEN DO; /* SMALL NUMBERS - USE MULTIPLY/DIVIDE */    WRITE(5)=MS1.LSB; WRITE(4)=MS1.MSB; WRITE(7)=MS2.LSB; /* DIVIDE */    R.MSB=READ(5); /* READ RESULT OF DIVIDE */    IF R.MSB IGE 50 THEN DO; /* LIMIT RATIO TO 50 */      R.MSB=50; RETURN;    END;    R.LSB= READ(4); WRITE(5)=0; WRITE(4)=R.LSB;  WRITE(7)=MS2.LSB; R.LSB =READ(5);    R.LLSB=READ(4); WRITE(5)=0; WRITE(4)=R.LLSB; WRITE(7)=MS2.LSB; R.LLSB=READ(5);    RETURN;  END;  DO WHILE (MS1.MSB IGT MS2.MSB) OR ((MS1.MSB=MS2.MSB)&(MS1.LSB IGE MS2.LSB));    R.MSB=R.MSB+1; /* ADD 1 TO RATIO */    IF R.MSB=50 THEN RETURN; /* LIMIT RATIO TO 50 */    MS1.MSB=MS1.MSB-MS2.MSB;    IF MS1.LSB ILT MS2.LSB THEN MS1.MSB=MS1.MSB-1;    MS1.LSB=MS1.LSB-MS2.LSB;  END;  DO I=0 TO 31; /* AND COMPUTE 32 BITS OF RATIO */    R.LSB=SHL(R.LSB,1); IF R.LLSB<0 THEN R.LSB=R.LSB\1;    R.LLSB=SHL(R.LLSB,1);    IF MS1.MSB<0 THEN R.LLSB=R.LLSB\1; /* ALWAYS CARRY */    MS1.MSB=SHL(MS1.MSB,1); IF MS1.LSB<0 THEN MS1.MSB=MS1.MSB\1;    MS1.LSB=SHL(MS1.LSB,1);    IF (R.LLSB)\(MS1.MSB IGT MS2.MSB)\((MS1.MSB=MS2.MSB)&(MS1.LSB IGE MS2.LSB))    THEN DO; /* SUBTRACT */      R.LLSB=R.LLSB\1;      MS1.MSB=MS1.MSB-MS2.MSB;      IF MS1.LSB ILT MS2.LSB THEN MS1.MSB=MS1.MSB-1;      MS1.LSB=MS1.LSB-MS2.LSB;    END;  END;END COMPUTE.RATIO;/* $page *//* MULTIPLY MULTIPLYS A RATIO IN THE GLOBAL VARIABLE R.MSB,R.LSB,R.LLSB.  TIMES A 32 BIT NUMBER IN THE GLOBAL VARIABLES MS.MSB, MS.LSB */MULTIPLY:  PROC; /* MULTIPLYS GLOBAL RATIO TIMES MS.MSB, MS.LSB AND ROUNDS */  DCL (MSB,LSB,LLSB) FIXED; /* HOLDS ANSWER */  WRITE(5)=MS.MSB; WRITE(6)=R.MSB;  IF READ(4)<>0 THEN CALL ER.OVF;  MSB=READ(5); /* GET INITIAL MSB */  WRITE(5)=MS.LSB; WRITE(6)=R.MSB;  MSB=MSB+READ(4); LSB=READ(5);  IF MSB ILT READ(4) THEN CALL ER.OVF;  WRITE(5)=MS.MSB; WRITE(6)=R.LSB; /* FRACTIONAL MULTIPLY */  MSB=MSB+READ(4); LSB=LSB+READ(5);  IF MSB ILT READ(4) THEN CALL ER.OVF;  IF LSB ILT READ(5) THEN DO;    MSB=MSB+1; IF MSB=0 THEN CALL ER.OVF;  END;  WRITE(5)=MS.LSB; WRITE(6)=R.LSB; /* LSB TO LSB */  LSB=LSB+READ(4); LLSB=READ(5); /* GET LLSB */  IF LSB ILT READ(4) THEN DO; /* CARRY */    MSB=MSB+1; IF MSB=0 THEN CALL ER.OVF;  END;  WRITE(5)=MS.MSB; WRITE(6)=R.LLSB; /* AND FINAL */  LSB=LSB+READ(4); LLSB=LLSB+READ(5); /* ADD IN AS REQUIRED */  IF LSB ILT READ(4) THEN DO;    MSB=MSB+1; IF MSB=0 THEN CALL ER.OVF;  END;  IF LLSB ILT READ(5) THEN DO; /* CARRY */    LSB=LSB+1;    IF LSB=0 THEN DO;      MSB=MSB+1; IF MSB=0 THEN CALL ER.OVF;    END;  END;  IF LLSB < 0 THEN DO; /* NOW ROUND FOR MULTIPLY */    LSB=LSB+1;    IF LSB=0 THEN DO;      MSB=MSB+1; IF MSB=0 THEN CALL ER.OVF;    END;  END;  MS.MSB=MSB; MS.LSB=LSB;END MULTIPLY;/* $page *//* OTHER SUBROUTINES: *//*   1. COMPUTE DELTA  - COMPUTE DIFFERENCE BETWEEN BEGINNING & AVERAGE RATIO *//*   2. NEGATE.RATIO   - TWO'S COMPLEMENT NEGATE OF RATIO *//*   3. ADD.RATIO      - ADDS 48 BIT NUMBER TO RATIO (ADDS TWO RATIOS) *//*   4. MULTIPLY.RATIO - MULTIPLYS TWO RATIOS - EACH 48 BITS *//*   5. SYNC.STATEMENT - SCAN OFF SYNC,DELAY,SMOOTH STATEMENTS */COMPUTE.DELTA:  PROC(PTR); /* COMPUTE DELTA RATIO - PASS POINTER */  DCL PTR FIXED;  R.MSB=RAT.MSB(PTR)-RAT.MSB(PTR-1); /* COMPUTE DELTA RATIO */  IF RAT.LSB(PTR) ILT RAT.LSB(PTR-1) THEN R.MSB=R.MSB-1;  R.LSB=RAT.LSB(PTR)-RAT.LSB(PTR-1);  IF RAT.LLSB(PTR) ILT RAT.LLSB(PTR-1) THEN DO;    R.LSB=R.LSB-1; /* CARRY */    IF R.LSB=(-1) THEN R.MSB=R.MSB-1;  END;  R.LLSB=RAT.LLSB(PTR)-RAT.LLSB(PTR-1);END;NEGATE.RATIO:  PROC; /* PROCEDURE TO NEGATE RATIO */  R.MSB=NOT(R.MSB);  R.LSB=NOT(R.LSB);  R.LLSB=NOT(R.LLSB); /* INVERT */  R.LLSB=R.LLSB+1; /* AND ADD 1 */  IF R.LLSB=0 THEN DO;    R.LSB=R.LSB+1;    IF R.LSB=0 THEN R.MSB=R.MSB+1;  END;END;ADD.RATIO:  PROC(NEW.MSB,NEW.LSB,NEW.LLSB);  DCL (NEW.MSB,NEW.LSB,NEW.LLSB) FIXED;  R.MSB=R.MSB+NEW.MSB; /* ADD TO BEGGINING RATIO */  R.LSB=R.LSB+NEW.LSB;  IF R.LSB ILT NEW.LSB THEN R.MSB=R.MSB+1;  R.LLSB=R.LLSB+NEW.LLSB;  IF R.LLSB ILT NEW.LLSB THEN DO;    R.LSB=R.LSB+1; IF R.LSB=0 THEN R.MSB=R.MSB+1;  END;END ADD.RATIO;/* $page *//* MULTIPLY.RATIO - MULTIPLYS GLOBAL RATIO R.MSB R.LSB R.LLSB TIMES.  A RATIO THAT IS PASSED AS THREE ARGUMENTS.  OVERFLOWS ARE NOT.  CHECKED BY THIS ROUTINE,  BECAUSE THE CURRENT ALGORITHM.  IS ALWAYS MULTIPLYING BY ONE NUMBER LESS THAN ONE. */MULTIPLY.RATIO:  PROC(NEW.MSB,NEW.LSB,NEW.LLSB) FIXED;   DCL (NEW.MSB,NEW.LSB,NEW.LLSB) FIXED;  DCL (K,L,M,N)                  FIXED;  K=0; L=0; M=0; N=0; /* INITIALIZE OUTPUT RATIO */  IF NEW.MSB<>0 THEN DO; /* MULTIPLY MSB */    WRITE(5)=R.MSB; WRITE(6)=NEW.MSB;    K=READ(5);    WRITE(5)=R.LSB; WRITE(6)=NEW.MSB;    K=K+READ(4); L=READ(5);    WRITE(5)=R.LLSB; WRITE(6)=NEW.MSB;    L=L+READ(4); M=READ(5);    IF L ILT READ(4) THEN K=K+1;  END;  IF NEW.LSB<>0 THEN DO; /* MULTIPLY BY LSB */    WRITE(5)=R.MSB; WRITE(6)=NEW.LSB; /* FRACTION TIMES MSB */    K=K+READ(4); L=L+READ(5);    IF L ILT READ(5) THEN K=K+1;    WRITE(5)=R.LSB; WRITE(6)=NEW.LSB; /* FRACTION TIMES FRACTION */    L=L+READ(4); M=M+READ(5);    IF L ILT READ(4) THEN K=K+1;    IF M ILT READ(5) THEN DO;      L=L+1; IF L=0 THEN K=K+1;    END;    WRITE(5)=R.LLSB; WRITE(6)=NEW.LSB; /* LSB * LLSB */    M=M+READ(4); N=READ(5);    IF M ILT READ(4) THEN DO;      L=L+1; IF L=0 THEN K=K+1;    END;  END;  IF NEW.LLSB<>0 THEN DO; /* MULTIPLY BY THAT */    WRITE(5)=R.MSB; WRITE(6)=NEW.LLSB;    L=L+READ(4); M=M+READ(5);    IF L ILT READ(4) THEN K=K+1;    IF M ILT READ(5) THEN DO;      L=L+1; IF L=0 THEN K=K+1;    END;    WRITE(5)=R.LSB; WRITE(6)=NEW.LLSB; /* LSB * LLSB */    M=M+READ(4); N=N+READ(5);    IF M ILT READ(4) THEN DO;      L=L+1; IF L=0 THEN K=K+1;    END;    IF N ILT READ(5) THEN DO;      M=M+1;      IF M=0 THEN DO; L=L+1; IF L=0 THEN K=K+1; END;    END;  END;  R.MSB=K; R.LSB=L; R.LLSB=M; /* STORE IN GLOBAL VARIABLE */END MULTIPLY.RATIO;/* $page *//* PROCESS SCRIPT SYNC STATEMENT:..   WHEN SYNC, DELAY, AND SMOOTH STATEMENTS ARE SCANNED,  SEVERAL.TABLES ARE SET UP:..   1.  THE STARTING COMPOSTION TIME (IN MILLISECONDS) IS STORED.       IN THE BEAT.MSB AND BEAT.LSB ARRAYS (32 BITS).   2.  THE STARTING REAL TIME (IN MILLISECONDS) IS STORED IN.       THE REAL.MSB AND REAL.LSB ARRAYS (32 BITS).   3.  THE REQUIRED AVERAGE & ENDING TEMPO RATIO IS STORED IN THE.       RAT.MSB, RAT.LSB, AND RAT.LLSB ARRAYS (48 BITS).   4.  THE DELTA RATIO (DIFFERENCE BETWEEEN BEGINNING AND ENDING.       RATIOS FOR THIS SEGMENT) IS COMPUTED AND STORED IN THE.       DEL.MSB,DEL.LSB,DEL.LLSB ARRAYS IF SMOOTHING IS CALLED FOR..   5.  THE SMOOTH ARRAY HAS ITS ENTRY SET TO 1 IF SMOOTHING IS CALLED FOR...THE DIFFERENT STATEMENTS ARE AS FOLLOWS:..   1  SYNC: COMPUTE AVERAGE RATIO AND ENDPOINTS. STORE THEM..   2  DELAY: USE SAME RATIO AS PREVIOUS SEGMENT.  COMPUTE X & Y POINTS..   3  SMOOTH: COMPUTE AVERAGE RATIO, DELTA RATIO, AND ENDPOINTS. */SYNC.STATEMENT:  PROC(TYP); /* SCAN OFF SYNC, DELAY, SMOOTH STATEMENTS */  DCL (TYP) FIXED;  DCL (X.MSB,X.LSB,Y.MSB,Y.LSB) FIXED;  IF ANY.NOTES THEN CALL ER.SYN1; /* SYNC STATEMENT NOT ALLOWED AFTER NOTELIST START */  SYNC.SCANNED=1; /* INDICATE SYNC STARTEMENT SCANNED */  CALL SCAN; /* SCAN OF START OF SEGMENT */  IF      TOKEN= T.BEAT THEN CALL LOOKUP.BEAT.NUMBER; /* COMPUTE TIME OF BEAT */  ELSE IF TOKEN<>T.TIME THEN CALL ER.IFM;  IF MILLI.LSBS<0 THEN MILLISECONDS=MILLISECONDS+1; /* ROUND */  CALL COMPUTE.MS(SECONDS,MILLISECONDS); /* COMPUTE MS.MSB,MS.LSB */  IF (MS.MSB ILT MIN.BEAT.MSB)  OR ((MS.MSB=MIN.BEAT.MSB)&(MS.LSB ILT MIN.BEAT.LSB)) THEN CALL ER.SYN2; /* OUT OF ORDER */  MIN.BEAT.MSB=MS.MSB; MIN.BEAT.LSB=MS.LSB; /* SAVE IN TEMPORARY VARIABLES */  BEAT.MSB(SYNC.PTR)=MS.MSB; BEAT.LSB(SYNC.PTR)=MS.LSB;  CALL SCAN; /* LOOK FOR 'TO' */  IF TOKEN<>T.TO THEN CALL ER.IFM;  CALL SCAN; /* GET NEXT TIME */  IF TOKEN<>T.TIME THEN CALL ER.IFM;  IF MILLI.LSBS<0 THEN MILLISECONDS=MILLISECONDS+1; /* ROUND HERE */  CALL COMPUTE.MS(SECONDS,MILLISECONDS); /* COMPUTE MS */  IF (MS.MSB ILT MIN.REAL.MSB)  OR ((MS.MSB=MIN.REAL.MSB)&(MS.LSB ILT MIN.REAL.LSB)) THEN CALL ER.SYN2;  MIN.REAL.MSB=MS.MSB; MIN.REAL.LSB=MS.LSB; /* CORRECT LATER FOR DELAY */  REAL.MSB(SYNC.PTR)=MS.MSB; REAL.LSB(SYNC.PTR)=MS.LSB;  X.MSB=MIN.BEAT.MSB-BEAT.MSB(SYNC.PTR-1); /* COMPUTE X LENGTH OF SEGMENT */  IF MIN.BEAT.LSB ILT BEAT.LSB(SYNC.PTR-1) THEN X.MSB=X.MSB-1;  X.LSB=MIN.BEAT.LSB-BEAT.LSB(SYNC.PTR-1);  Y.MSB=MIN.REAL.MSB-REAL.MSB(SYNC.PTR-1); /* COMPUTE Y LENGTH OF SEGMENT */  IF MIN.REAL.LSB ILT REAL.LSB(SYNC.PTR-1) THEN Y.MSB=Y.MSB-1;  Y.LSB=MIN.REAL.LSB-REAL.LSB(SYNC.PTR-1);/* $page *//* SYNC STATEMENT (CONTINUED): .      WE HAVE COMPUTED THE X (BEAT TIME) AND Y (REAL TIME) LENGTH OF.      THE SEGMENT.    NOW COMPUTE THE REQUIRED AVERAGE TEMPO RATIO.      THAT WILL MAKE THE SYNC POINT LINE UP TO THE REQUIRED REAL TIME. */  IF (X.MSB\X.LSB)=0 THEN TYP=T.DELAY; /* 0 LENGTH SEGMENT - TREAT AS DELAY */  IF TYP=T.SYNC THEN DO; /* USE CONSTANT RATIO FOR EARLIER SEGMENT */    CALL COMPUTE.RATIO(Y.MSB,Y.LSB,X.MSB,X.LSB); /* COMPUTE RATIO FOR SEGMENT */    RAT.MSB(SYNC.PTR-1)=R.MSB; RAT.LSB(SYNC.PTR-1)=R.LSB; RAT.LLSB(SYNC.PTR-1)=R.LLSB;    RAT.MSB(SYNC.PTR)=R.MSB; RAT.LSB(SYNC.PTR)=R.LSB; RAT.LLSB(SYNC.PTR)=R.LLSB;  END;  IF TYP=T.DELAY THEN DO; /* DELAY - NO CHANGE OF TEMPO REQUIRED */    DELAY.SCANNED=1; /* SET FLAG FOR POSSIBLE ERROR PRINTOUT */    RAT.MSB(SYNC.PTR)=RAT.MSB(SYNC.PTR-1); /* DEPART AT BEGINNING TEMPO */    RAT.LSB(SYNC.PTR)=RAT.LSB(SYNC.PTR-1);    RAT.LLSB(SYNC.PTR)=RAT.LLSB(SYNC.PTR-1);  END;  IF TYP=T.SMOOTH THEN DO; /* SMOOTH - SET UP DIFFERENT RATIOS */    SMOOTH.SCANNED=1;    CALL COMPUTE.RATIO(Y.MSB,Y.LSB,X.MSB,X.LSB);    RAT.MSB(SYNC.PTR)=R.MSB; RAT.LSB(SYNC.PTR)=R.LSB; RAT.LLSB(SYNC.PTR)=R.LLSB;    CALL COMPUTE.DELTA(SYNC.PTR); /* GET DELTA RATIO */    IF R.MSB<0 THEN DO; /* NEGATIVE DELTA - COMPUTE ABS & SET FLAG */      CALL NEGATE.RATIO;      NEGATIVE.DELTA(SYNC.PTR-1)=1;    END;    DEL.MSB(SYNC.PTR-1)=R.MSB; /* SAVE AS DELTA FOR PREVIOUS SEGMENT */    DEL.LSB(SYNC.PTR-1)=R.LSB;    DEL.LLSB(SYNC.PTR-1)=R.LLSB;    SMOOTH(SYNC.PTR-1)=1; /* SMOOTH EARLIER SEGMENT */  END;  SYNC.PTR=SYNC.PTR+1;  IF SYNC.PTR>MAX.SYNC.POINTS THEN DO; /* TOO MANY */    CALL ER.SYN5; /* TOO MANY SNC POINTS */    SYNC.PTR=SYNC.PTR-1; /* CLOBBER LAST ONE */  END;  BEAT.MSB(SYNC.PTR)=-1; BEAT.LSB(SYNC.PTR)=-1; /* TO SIMPLIFY COMPARISONS */  CALL SCAN; /* SCAN OFF NEXT STATEMENT */END SYNC.STATEMENT;/* $page *//* COMPUTE CORRECTED STARTING TIME FOR SYNCHRONIZATION *//* COMPUTE.REAL.TIME:.      1. PASS SECONDS,MILLISECONDS,FRACTION OF COMPOSITION TIME BASE..      2. COMPUTE.REAL.TIME SEES IF ANY SYNC,DELAY,SMOOTH STATEMENTS.         HAVE BEEN SCANNED.    IF NOT,  THEN THE OUTPUT VARIABLES.         ARE ASSIGNED TO THE INPUT VARIABLES,  THEN RETURN..      3. IF THERE IS SYNCHRONIZATION IN EFFECT,  THE SYNCH TABLE IS SEARCHED.         TO SEE WHICH SYNCHRONIZATION SEGMENT CONTAINS THE TIME..      4. ONCE THE SEGMENT IS FOUND,  A RELATIVE TIME WITHIN THAT SEGMENT.         IS COMPUTED (THE RELATIVE TIME IS ALWAYS LESS THAN THE LENGTH OF.         THE SEGMENT)..      5. IF A SMOOTH TEMPO FUNCTION IS IN EFFECT,  THEN AN EFFECTIVE.         AVERAGE TEMPO IS COMPUTED FOR THE SEGMENT FRAGMENT..      6. THE LENGTH OF THE SEGMENT FRAGMENT IS MULTIPLIED BY THE REQUIRED.         EFFECTIVE TIME RATIO TO COMPUTE THE RELATIVE LENGTH OF THE.         REAL TIME SEGMENT..      7. THE LENGTH OF THE Y SEGMENT IS ADDED TO THE START OF THE Y.         SEGMENT AND THAT VALUE IS RETURNED. */DCL (REAL.SECONDS,REAL.MILLISECONDS) FIXED; /* COMPUTE TIME BASE */COMPUTE.REAL.TIME:  PROC(SECS,MS,FRACT); /* MAP BEAT TIME TO REA TIME */  DCL (SECS,MS,FRACT)            FIXED;  DCL (X.MSB,X.LSB)              FIXED;  DCL (NEW.MSB,NEW.LSB,NEW.LLSB) FIXED; /* HOLDS NEW RATIO */  DCL I                          FIXED;  IF FRACT<0 THEN MS=MS+1; /* ROUND HERE */  IF MS>=1000 THEN DO;    SECS=SECS+1;    MS=MS-1000;    IF SECS=0 THEN CALL ER.OVF;  END;  IF SYNC.SCANNED=0 THEN DO; /* NO SYNC - SIMPLE MAPPING */    REAL.SECONDS=SECS; REAL.MILLISECONDS=MS;    RETURN;  END;  CALL COMPUTE.MS(SECS,MS); /* COMPUTE MSB & LSB */  I=0; /* INITIALIZE POINTER */  DO WHILE (MS.MSB IGT BEAT.MSB(I+1)) /* FIND SEGMENT */  OR ((MS.MSB=BEAT.MSB(I+1))&(MS.LSB IGE BEAT.LSB(I+1)));    I=I+1; /* GET NEXT SEGMENT */  END;  X.MSB=MS.MSB-BEAT.MSB(I); /* COMPUTE DELAT */  IF MS.LSB ILT BEAT.LSB(I) THEN X.MSB=X.MSB-1;  X.LSB=MS.LSB-BEAT.LSB(I);/* $page *//* SYNC STATEMENT (CONTINUED):..      COMPUTE SMOOTHED TEMPO RATIO IF REQUIRED: */  IF SMOOTH(I) THEN DO; /* MUST COMPUTE AVERAGE RATIO */    MS.MSB=BEAT.MSB(I+1)-BEAT.MSB(I); /* COMPUTE X' */    MS.LSB=BEAT.LSB(I+1)-BEAT.LSB(I);    IF BEAT.LSB(I+1) ILT BEAT.LSB(I) THEN MS.MSB=MS.MSB-1;    CALL COMPUTE.RATIO(X.MSB,X.LSB,MS.MSB,MS.LSB); /* COMPUTE % OF WAY IN SEGMENT */    NEW.MSB=R.MSB; NEW.LSB=R.LSB; NEW.LLSB=R.LLSB; /* SAVE RATIO */    CALL ADD.RATIO(NEW.MSB,NEW.LSB,NEW.LLSB); /* TIMES 3 */    CALL ADD.RATIO(NEW.MSB,NEW.LSB,NEW.LLSB);    CALL NEGATE.RATIO; /* GET NEGATIVE RATIO */    R.MSB=R.MSB+9; /* ADD 9 */    CALL MULTIPLY.RATIO(NEW.MSB,NEW.LSB,NEW.LLSB);    CALL NEGATE.RATIO; /* NEGATIVE */    R.MSB=R.MSB+10; /* ADD 10 */    CALL MULTIPLY.RATIO(NEW.MSB,NEW.LSB,NEW.LLSB);    CALL NEGATE.RATIO;    R.MSB=R.MSB+5;    CALL MULTIPLY.RATIO(DEL.MSB(I),DEL.LSB(I),DEL.LLSB(I)); /* * DELTA */    CALL MULTIPLY.RATIO(NEW.MSB,NEW.LSB,NEW.LLSB); /* TIMES RATIO AGAIN */    IF NEGATIVE.DELTA(I) THEN CALL NEGATE.RATIO; /* WAS MINUS */    CALL ADD.RATIO(RAT.MSB(I),RAT.LSB(I),RAT.LLSB(I)); /* ADD R1 */    IF R.MSB < 0 THEN CALL ER.SYN4; /* ERROR - TOO EXTREME */  END;  ELSE DO; /* NO SMOOTHING - USE AVERAGE RATIO */    R.MSB=RAT.MSB(I); R.LSB=RAT.LSB(I); R.LLSB=RAT.LLSB(I);  END;  MS.MSB=X.MSB; /* MOVE X DISTANCE TO GLOBAL RATIO */  MS.LSB=X.LSB;  CALL MULTIPLY; /* MULTIPLY BY RATIO TO GET TIME (ROUNDED) */  MS.MSB=MS.MSB+REAL.MSB(I); /* ADD IN STARTING TIME BASE */  MS.LSB=MS.LSB+REAL.LSB(I);  IF MS.LSB ILT REAL.LSB(I) THEN MS.MSB=MS.MSB+1;  IF MS.MSB IGE 1000 THEN CALL ER.SYN6; /* TOO BIG */  WRITE(5)=MS.LSB; WRITE(4)=MS.MSB; /* PERFORM DIVIDE TO GET SECODS, MS */  WRITE(7)=1000; /* DIVIDE BY 1000 TO GET SECONDS, MILLISECONDS */  REAL.SECONDS=READ(5); REAL.MILLISECONDS=READ(4);END COMPUTE.REAL.TIME;dcl releasem fixed;     /* true for release m compilations */ROUND.REAL.TIME:  PROC; /* TO DO ROUNDING */  if releasem=0 then do;     REAL.MILLISECONDS=((REAL.MILLISECONDS+2)/5)*5; /* ROUND TO 5 MS BONDARY */     IF REAL.MILLISECONDS>=1000 THEN DO;        REAL.MILLISECONDS=REAL.MILLISECONDS-1000;        REAL.SECONDS=REAL.SECONDS+1;     END;  end;END ROUND.REAL.TIME;/* OUTPUT WORD EMIT - THE COMPILED SEQUENCE IS STORED IN MEMORY */  FILE.TOO.BIG:  PROC; /* PROCEDURE FOR ERROR MESSAGE */  PRINT 'Program too large to compile (TOO MANY NOTES IN SEQUENCE)';  CALL EXIT(-1);END;  EMIT.T:PROC(WORD);   /* EMIT TIMBRE WORD */   DCL (I,WORD) FIXED;   IF EXAMOUNT=0 THEN DO;         /* INTERNAL MEMORY */      IF TIMBLEN=TIMBMAX THEN DO; /* OOPS - MUST BUMP UP SEQUENCE START */         TIMBMAX=TIMBMAX+1024;    /* TRY TO GRAB AN EXTRA K FOR TIMBRE INFO */         IF SEQNLEN+1024 IGT SEQNMAX THEN CALL FILE.TOO.BIG; /* CAN NOT MOVE SEQUENCE UP */         I=SEQNLEN;         DO WHILE I<>0;           /* COPY NOTES UP BY 1024 WORDS */            I=I-1; CORE(SEQNLOC+I+1024)=CORE(SEQNLOC+I);         END;         SEQNLOC=SEQNLOC+1024; SEQNMAX=SEQNMAX-1024;      END;      CORE(TIMBLOC+TIMBLEN)=WORD; TIMBLEN=TIMBLEN+1;   END;   ELSE DO;                       /* EXTERNAL MEMORY */      IF TIMBLEN=TIMBMAX THEN DO; /* OOPS - MUST BUMP UP SEQUENCE START */         IF TIMBMAX="177400" THEN CALL FILE.TOO.BIG; /* LIMIT TO 255 SECTORS */         TIMBMAX=TIMBMAX+4096;    /* TRY TO GRAB AN EXTRA 4K FOR TIMBRE INFO */         IF TIMBMAX ILT 4096      /* BUT CHECK FOR OVERFLOW */         THEN TIMBMAX="177400";   /* TIME IS RUNNING OUT...... */         IF (SEQNLOC+SHR(SEQNMAX,8)+16) IGT DEFLOC  /* OOPS - SEQUENCE WILL MOVE INTO DEFLOC AREA */         THEN DO;                 /* FREE UP STORAGE FROM SEQUENCE MAX */            IF (SEQNLOC+SHR(SEQNLEN+255,8)+16) IGT DEFLOC            THEN CALL FILE.TOO.BIG;   /* AREA IN USE WILL NOT FIT - TOO BIG */            SEQNMAX=SHL(DEFLOC-SEQNLOC-16,8);  /* GET NEW SEQN MAX */         END;         CALL COPY.EXT.MEM(SEQNLOC,0,SEQNLOC+16,0,SEQNLEN);         SEQNLOC=SEQNLOC+16;      END;      WRITE(MAM)=TIMBLOC+SHR(TIMBLEN,8); WRITE(MAL)=TIMBLEN;      WRITE(MD)=WORD;             /* STORE WORD */      TIMBLEN=TIMBLEN+1;   END;END EMIT.T;DCL PAR.NUMT FIXED;EMIT.NULL.TIMBRE:PROC;                   /* EMIT A NULL TIMBRE */   DCL (I,J) FIXED;   IF (SFM.TIMBRES\SN2.TIMBRES)=0 THEN SN2.TIMBRES=1; /* LOCK OURSELVES INTO SYN2 TIMBRES IF WE COME ACROSS A 'TRACK' STATEMENT FIRST */   IF SFM.TIMBRES<>0 THEN DO;                         /* EMIT SFM FORMAT TIMBRES */      DO I=0 TO (#.TWRDS-1); CALL EMIT.T(0); END;      CALL EMIT.T(0); /* AND TERMINATE THE FILE LIST WITH A ZERO */   END;   ELSE DO; /* EMIT SYNCLAVIER II TIMBRES */      DO I=0 TO 3;          IF USE.NEW.FORMAT=0 THEN DO J=0 TO 45; CALL EMIT.T(0); END; /* EMIT ZEROES IF STILL USING OLD FORMAT */         ELSE CALL EMIT.T(-2); /* NEW FORMAT DESIRED - EMIT SINGLE WORD SUPPRESSED TIMBRE */      END; /* 4 SUPPRESSED PARTIALS */      DO I=0 TO 7; CALL EMIT.T( 0); END; /* 8 MISC WORDS */   END;   PAR.NUMT=PAR.NUMT+1;END EMIT.NULL.TIMBRE;EMIT.N:PROC(WORD);  /* EMIT NOTE LIST WORD */  DCL WORD FIXED;  IF SEQNLEN IGE SEQNMAX THEN CALL FILE.TOO.BIG;/* NO MORE ROOM IN INTERMEDIATE FILE */  IF EXAMOUNT=0 THEN CORE(SEQNLOC+SEQNLEN)=WORD; /* STORE WORD IN MEMORY */  ELSE DO;          /* EXTERNAL MEMORY */     WRITE(MAM)=SEQNLOC+SHR(SEQNLEN,8); WRITE(MAL)=SEQNLEN;     WRITE(MD) =WORD;  END;  SEQNLEN=SEQNLEN+1;/* KEEP TRACK OF LENGTH */END EMIT.N;