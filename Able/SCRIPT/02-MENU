/* 02-MENU  $TITLE  Menu Display and Command Handler Routines */dcl MENU_TABLE data (7,17,23,31,38,45,55,66,74);dcl VT100      boolean;dcl ADM        boolean;#POS:  procedure(X,Y); /* move cursor to position */   dcl (X,Y) fixed;   if VT100 then do;      write("50")=(A.ESC); write("50")=(A.LBRACKET); /* esc [ */      pnum(X+1,false);      write("50")=(A.SEMICOLON); /* ; */      pnum(Y+1,false);      write("50")=(A.H); /* H */   end;   else if ADM then do;      write("50")=(A.ESC);  write("50")=(A.EQUALS); /* esc = */      write("50")=(X+A.SP); write("50")=(Y+A.SP); /* line and col */   end;end #POS;dcl POS lit 'call #POS';#CLEAR_SCREEN:  procedure;   if VT100 then do;      /* position cursor to top and erase rest of screen */      write("50")=A.GS;                         /* go to vector mode */      write("50")=(A.ESC); write("50")=A.FF;    /* esc ff - alpha mode, clear graphics screen */      write("50")=A.CAN;                        /* crtlx - transparent mode */      write("50")=(A.ESC); write("50")=(A.LBRACKET); /* esc [ */      write("50")=(A.H); /* H */      write("50")=(A.ESC); write("50")=(A.LBRACKET); /* esc [ */      write("50")=(A.J); /* J */   end;   else if ADM then do;      write("50")=(A.SUB); write(3)=0; /* wait for scope to respond */   end;end #CLEAR_SCREEN;dcl CLEAR_SCREEN lit 'call #clear_screen';ERASE.MOST.OF.LINE:PROC(ROW,COL);   DCL (ROW,COL) FIXED;   dcl (i,j)     fixed;   if col<0 then i=0;   else          i=menu_table(col);   pos(ROW+8, i); /* get into position */   do j=i to 79;      write("50")=a.sp;   end;END ERASE.MOST.OF.LINE;POWER:  procedure(X); /* return TRUE iff 0 < X <= 64 and X = 2^K */   dcl (X,I,P)  fixed;   P = 1; /* init power value */   do I = 0 to 6; /* loop over possible powers */      if X = P then return TRUE; /* found */      P = P + P;   end;   return FALSE; /* not found */end POWER;FIXEDBIN:  procedure(STR);   dcl STR        fixed array;   dcl (I,VAL,CH) fixed;   VAL = 0;   do I = 0 to STR(0) - 1;      CH = byte(STR,I);      if (48 <= CH) & (CH <= 57) then VAL = VAL * 10 + (CH - 48);   end;   return VAL;end FIXEDBIN;DISPLAY_PART:  procedure(ROW,COL); /* display the value at given row and col */   dcl (ROW,COL) fixed;   dcl BUFF(2)   fixed;   pos(ROW+8, MENU_TABLE(COL)); /* get into position */   BUFF(0) = 2;   do case COL; /* select column */      do; /* 0: format */         if      FORMAT(trk.base+ROW) = COMPUTER then do;            print 'Computer',;            pos(ROW+8, MENU_TABLE(4));            print '     ',;            pos(ROW+8, MENU_TABLE(5));            if TIMES(trk.base+ROW) = ABSOLUTE then print 'Absolute',;            else                          print 'Relative',;            pos(ROW+8, MENU_TABLE(6));            if      CODE(trk.base+ROW) = FRAME     then print 'Frames   ',;            else if CODE(trk.base+ROW) = FRMS_ONLY then print 'Frms-only',;            else                               print 'Seconds  ',;         end;         else if FORMAT(trk.base+ROW) = SCRIPT   then do;            print 'Script  ',;            pos(ROW+8, MENU_TABLE(4));            pnum(RESOLUTION(trk.base+ROW),0); print ' ',;            pos(ROW+8, MENU_TABLE(5));            print '                   ',;         end;         else do;            print 'Ignore  ',;            pos(ROW+8, MENU_TABLE(4));            print '     ',;         end;      end; /* 0: format */      do; BUFF(1) = KEY_NAMES(KEY(trk.base+ROW)); print string(BUFF),; end;            if ACCI(trk.base+ROW) = 0 then print '#',; else print 'f',;      do; pnum(BEAT_MEAS(trk.base+ROW),0);  print '/',; pnum(BEAT_NOTE(trk.base+ROW),0); print '   ',; end;      do; /* 4: resolution */         if FORMAT(trk.base+ROW) <> SCRIPT then print '     ',;         else do; pnum(RESOLUTION(trk.base+ROW),0); print ' ',; end;      end;      do; /* 5: abs/rel */         if      FORMAT(trk.base+ROW) <> COMPUTER then print '        ',;         else if TIMES(trk.base+ROW) = ABSOLUTE   then print 'Absolute',;         else                                 print 'Relative',;      end;      do; /* 6: sec/frames */         if      FORMAT(trk.base+ROW) <> COMPUTER then print '         ',;         else if CODE(trk.base+ROW) = FRAME       then print 'Frames   ',;         else if CODE(trk.base+ROW) = FRMS_ONLY   then print 'Frms-only',;         else                                 print 'Seconds  ',;      end;      do; pnum(FRAME_RATE,0); print ' ',; end;      do; pnum(CLICK_RATE,0); print ' ',; end;   end; /* of do case */   pos(ROW+8, MENU_TABLE(COL)); /* restore cursor */end DISPLAY_PART;GET_CHR:  procedure; /* get input char and decode arrow keys */   dcl (CH,I) fixed;   CH = read("50")&"177"; /* wait and get character */   if CH =  0 then do;               /* break */      do i=0 to 60; write(3)=0; end; /* pause */      return (8);                    /* break code */   end;   else if CH = A.CR then return (5); /* <Return> */   else if CH = A.ESC then do; /* ESC key or seq */      if (ADM) then return (0); /* done signal on ADM */      CH = read("50"); CH = read("50")&"177"; /* get VT100 esc seq */      if      CH = 65 then return (2); /* Move up */      else if CH = 66 then return (1); /* Move down */      else if CH = 67 then return (3); /* Move right */      else if CH = 68 then return (4); /* Move left */      else if CH = 69 then return (10); /* refresh the screen */      else if CH = 81 then return (7); /* PF2   - Return to Synclavier RTP */      else if CH = 82 then return (9); /* PF3   - Return to music printing */      else if CH = 77 then return (0); /* ENTER - Reverse compile */   end;   else if CH = A.BS then    return (4); /* Move left */   else if CH = A.LF then    return (1); /* Move down */   else if CH = A.VT then    return (2); /* Move up */   else if CH = A.FF then    return (3); /* Move right */   else if (CH = A.CAN) and ADM then return (7); /* Return to Synclavier RTP */   else if CH = A.SLASH then return (5); /* / for the middle of a time sig */   else                      return (CH);end GET_CHR;GET_STRING:  procedure(BUFF,LEN);   dcl BUFF     fixed array;   dcl (CH,LEN) fixed;   BUFF(0) = 0;   do forever;      CH = GET_CHR;      if CH < A.SI then return (CH); /* return on cursor movement or break */      else if CH = A.DELETE then do; /* char delete */         if BUFF(0) > 0 then do; /* if chars have been typed */            BUFF(0) = BUFF(0) - 1;            write("50") = A.BS;  write("50") = A.SP;  write("50") = A.BS;         end;         else return (6); /* reset to default */      end;      else if BUFF(0) < LEN then do; /* accept char */         write("50") = CH;         call pbyte(BUFF,BUFF(0),CH);         BUFF(0) = BUFF(0) + 1;      end;   end; /* of do forever */end GET_STRING;GET_ENTRY:  procedure(ROW,COL);   dcl (ROW,COL) fixed;   dcl STR(8)    fixed;   dcl (F,I,J)   fixed;   if syn.med<>2 then do;      if (n.lookup(DT_PTR(trk.base+ROW)) = 0) and (COL < 6) then return (GET_CHR);   end;   else do;      if ((DT_PTR(trk.base+ROW)) = 0) and (COL < 6) then return (GET_CHR);   end;   STR(0) = 0;   do case COL;        do; /* 0:  format (script, computer, or ignore) */         F = GET_CHR;         do while (F >= A.SI);            FORMAT(trk.base+ROW) = FORMAT(trk.base+ROW) + 1; /* jump to next mode */            if FORMAT(trk.base+ROW) > 2 then FORMAT(trk.base+ROW) = 0;            if FORMAT(trk.base+ROW) = SCRIPT then do; /* reset if SCRIPT selected */               TIMES(trk.base+ROW) = ABSOLUTE; CODE(trk.base+ROW) = SECOND;            end;            call DISPLAY_PART(ROW,COL); /* show it */            F = GET_CHR;         end;      end;      do; /* 1:  Get Key */         F = GET_STRING (STR,2);         if F = 6 then KEY(trk.base+ROW) = 1;         else if STR(0) > 0 then do;            if STR(0) = 1 then call pbyte(STR,1,A.SP); /* Add a space to a 1 char key */            do I = 1 to 42;               if STR(1) = KEY_NAMES(I) then KEY(trk.base+ROW) = I;            end;         end;         call DISPLAY_PART(ROW,COL); /* write the new value */      end;      do; /* 2:  Set accidental format */         F = GET_CHR;         do while (F >= A.SI);            if F = A.F or F = L.F then ACCI(trk.base+ROW) = 1;            else                       ACCI(trk.base+ROW) = 0;            call DISPLAY_PART(ROW,COL);            F = GET_CHR;         end;      end;      do; /* 3:  Get time signature */         F = GET_STRING(STR,3);         if F = 6 then do; /* use default */            BEAT_MEAS(trk.base+ROW) = 4; BEAT_NOTE(trk.base+ROW) = 4;         end;         else if STR(0) > 0 then do; /* got a string */            J = FIXEDBIN(STR);            if (J > 0) and (J < 256) then BEAT_MEAS(trk.base+ROW) = J;            if F = C.E then do;               print '/',; STR(0) = 0;               F = GET_STRING(STR,2);               if F = C.F then do; /* use default */                  BEAT_MEAS(trk.base+ROW) = 4; BEAT_NOTE(trk.base+ROW) = 4;               end;               else if STR(0) > 0 then do; /* got a string */                  J = FIXEDBIN(STR);                  if POWER(J) then BEAT_NOTE(trk.base+ROW) = J;               end;            end;         end;         call DISPLAY_PART(ROW,COL); /* write the new value */      end; /* of get time signature */      do; /* 4:  Get resolution */         F = GET_STRING(STR,2);         if F = 6 then RESOLUTION(trk.base+ROW) = 16;         else if STR(0) > 0 then do;            J = FIXEDBIN(STR);            if POWER(J) then RESOLUTION(trk.base+ROW) = J;         end;         call DISPLAY_PART(ROW,COL); /* write the new value */      end;      do; /* 5:  Absolute/Relative Mode */         F = GET_CHR;         do while (F > A.SI);            TIMES(trk.base+ROW) = TIMES(trk.base+ROW) xor 1;            call DISPLAY_PART(ROW,COL);            F = GET_CHR;         end;      end;      do; /* 6:  Seconds/Frames/Frms_only code */         F = GET_CHR;         do while (F > 15);            CODE(trk.base+ROW) = CODE(trk.base+ROW) + 1; /* jump to next code */            if CODE(trk.base+ROW) > 2 then CODE(trk.base+ROW) = 0;            call DISPLAY_PART(ROW,COL);            F = GET_CHR;         end;      end;      do; /* 7:  Frame Rate */         F = GET_STRING(STR,5);         if F = C.F then FRAME_RATE = 2400;         else if STR(0) > 0 then do;            J = FIXEDBIN(STR);            if (J > 99) and (J < 30000) then FRAME_RATE = J;         end;         call DISPLAY_PART(ROW,COL); /* write the new value */      end;      do; /* 8:  Get click rate */         F = GET_STRING(STR,2);         if F = C.F then CLICK_RATE = 4;         else if STR(0) > 0 then do;            J = FIXEDBIN(STR);            if J > 0 then CLICK_RATE = J;         end;         call DISPLAY_PART(ROW,COL); /* write the new value */      end;   end; /* of do case */   return (F);end GET_ENTRY;MENU:  procedure; /* main routine for options menu */   /* return 0 to proceed, 1 for abort back to RTP */   dcl (ROW,COL)  fixed;   dcl (STAVES,P) fixed;   dcl (I,J,K,TR) fixed;   dcl (mpr)      fixed;   dcl (anything) (15) fixed;    /* 0=blank; 1=track # only; 2=complete line */   /* set up defaults if known */   CLICK_RATE = 4;   FRAME_RATE = 2400;   do I = 0 to num.trks-1; /* loop over tracks and set up defaults */      FORMAT(I)     = COMPUTER; /* assign default values */      TIMES(I)      = ABSOLUTE;      CODE(I)       = SECOND;      KEY(I)        = 1; /* assume standard defaults */      ACCI(I)       = 0;      BEAT_MEAS(I)  = 4;      BEAT_NOTE(I)  = 4;      RESOLUTION(I) = 16;      /* Get some menu values from Music Printing area if present (L) */      if (SEQ.NPPW <> 0)      and (syn.med <> 2)      then do; /* preset area exists */         STAVES = shr(n.lookup(PRE.PTR+6),8); /* find number of staves */         mpr=shr(seqdata(seq.mprev),8); /* look up music printing rev */         if mpr=0 then mpr=n.lookup(pre.ptr+6)&LBYTE; /* get earlier music printing magic number */         if mpr = REV.B then do; /* if magic number is REV B */            P = PRE.PTR + 8 + 15; /* set pointer to data for first stave */            CLICK_RATE = shr(n.lookup(PRE.PTR+2),8); /* get overall click rate */            do J = 0 to STAVES; /* loop over staves */               TR = shr(n.lookup(P),8); /* get track references */               if I = (TR&"17") then do; /* found track match */                  KEY(I)        = n.lookup(P+4)&LBYTE;                  ACCI(I)       = (shr(n.lookup(P+4),8)&"200")<>0;                  BEAT_MEAS(I)  = shr(n.lookup(P+5),8);                  BEAT_NOTE(I)  = n.lookup(P+5)&LBYTE;                  RESOLUTION(I) = n.lookup(P+6)&LBYTE;               end;               P = P + 7; /* advance to next part */            end;         end; /* of rev B */         if mpr >= REV.C then do; /* rev C or later */            CLICK_RATE = n.lookup(PRE.PTR+2)&LBYTE; /* get click denominator */            BEAT_MEAS(I) = shr(n.lookup(PRE.PTR+3),8);            BEAT_NOTE(I) = n.lookup(PRE.PTR+3)&LBYTE;            P = PRE.PTR + n.lookup(PRE.PTR); /* point to first part preset area */            do J = 0 to STAVES; /* loop over staves */               TR = n.lookup(P+1); /* get track references */               if ((I+1) = (TR&LBYTE)) or ((I+1) = shr(TR,8)) then do; /* found track match */                  RESOLUTION(I) = n.lookup(P+2)&LBYTE;                  KEY(I)        = n.lookup(P+6)&LBYTE;                  ACCI(I)       = (n.lookup(P+8)&"020")<>0;               end;               P = P + n.lookup(P); /* advance to next part */            end;         end; /* of rev C */      end; /* preset area exists */      /* Get some menu values from Music Printing area if present. M-FORMAT         This is of course very slow (tracks * parts) and will only find         the data on the first use of the track, but it is only supposed         to make an attempt anyway. */      if inf.len ~= 0 and syn.med = 2 then do; /* inf area exists */         STAVES       = shr(i.lookup(6),8); /* find number of staves */         CLICK_RATE   = i.lookup(2)&LBYTE; /* get click denominator */         BEAT_MEAS(I) = shr(i.lookup(3),8);         BEAT_NOTE(I) = i.lookup(3)&LBYTE;         P = i.lookup(0); /* point to first part preset area */         do J = 0 to STAVES; /* loop over staves */            TR = i.lookup(P+1); /* get track references */            if (I+1) = (TR&LBYTE) then do; /* found voice 0 track match */               RESOLUTION(I) = i.lookup(P+2)&LBYTE;               KEY(I)        = i.lookup(P+6)&LBYTE;               ACCI(I)       = (i.lookup(P+8)&"020")<>0;            end;            else if (I+1) = shr(TR,8) then do; /* found voice 1 track match */               RESOLUTION(I) = shr(i.lookup(P+2),8);               KEY(I)        = i.lookup(P+6)&LBYTE;               ACCI(I)       = (i.lookup(P+8)&"020")<>0;            end;            P = P + i.lookup(P); /* advance to next part */         end;      end; /* preset area exists */      if syn.med<>2 then do;         if n.lookup(DT_PTR(I)) <> 0 then LAST_ROW = I; /* find last active track */      end;      else do;         if DT_PTR(I) <> 0 then LAST_ROW = I;           /* find last active track */      end;      do case (CNV.STA); /* branch to select conversion presets */         ; /* 0 */         ; /* 1:  absolute times in seconds */         TIMES(I) = RELATIVE; /* 2:  relative times */         ; /* 3:  not reachable */         FORMAT(I) = SCRIPT; /* 4:  SCRIPT format */         do; /* 5:  24 frame absolute */            CODE(I) = FRAME;         end;         do; /* 6:  24 frame relative */            CODE(I) = FRAME; TIMES(I) = RELATIVE;         end;         do; /* 7:  30 frame absolute */            CODE(I) = FRAME; FRAME_RATE = 3000;         end;         do; /* 8:  30 frame relative */            CODE(I) = FRAME; TIMES(I) = RELATIVE; FRAME_RATE = 3000;         end;         do; /* 9:  24 frame, frames only form */            CODE(I) = FRMS_ONLY;         end;      end; /* of do case */   end; /* of loop over tracks */   if VT100 then do; write("50")=A.ESC; write("50")=A.EQUALS; end; /* set keypad app */   clear_screen;   print string (module.title),' ',string(rel.version),' - ',string (rel.date);  do case (print.err); /* branch on various error types */      ;                 /* 0: no error defined */      do;               /* 1: print error message from overlay attempt */         print '            ******** Unable to ',;         if core(loc.synret)=loc.mplt then print 'Print',;         else                              print 'Play',;         print ' this sequence ********',;      end;      print '            ******** Music Printing Software not available ********',; /* 2 */      print '   **** Sequence too long for Conversion - Try Ignoring some Tracks ****',; /* 3 */      print '   ******** This Software is Incompatible with System Software ********',; /* 4 */      print '   *******  You Do Not Have Enough Memory to Run This Software ********',; /* 5 */      print '            ********  System file is not an XPL Program  ********',; /* 6 */      print '   Program requires a later processor type',;   end;   print;                             /* no error message */   print '  Use Directional Arrows to select item,  then ',;   if VT100 then print '<ENTER>',;   else          print '<ESCAPE> ',;   print ' to Reverse Compile.';   if ADM then   print '  Use <CNTRL-X> to return to Synclavier,  or   <BREAK> to return to Monitor.';   else   print '  Use <PF2> for Synclavier, <PF3> for Music Printing, or <BREAK> for Monitor.';   if  (syn.med=2)   and (last_row>15) then   print '  Use arrow keys to scroll to other tracks.';   else print ;   print '                 Key   Acc     Time   Note   Abs/      Sec/       Frame   Click';   print 'Track  Mode      Sig   Format  Sig    Res    Rel       Frames     Rate    Note';   ROW = 0; COL = 0;                /* init row and col */   redraw.screen.on.scroll:;        /* re-enter to redraw on scroll */   do i = 0 to 15;  /* check all possible rows */      if (trk.base+i)<=last_row then do; /* PRINT TRACK # AT LEAST */         pos(i+8,1);         pnum(trk.base+i+1,0); /* track number */         print '   ',;   /* erase earlier track info */         if syn.med<>2 then do;            if n.lookup(DT_PTR(trk.base+i)) <> 0 then do j = 0 to 6; /* if track exists */               call DISPLAY_PART(i,j); /* show parameter options */               anything(i)=2;            /* complete line          */            end;            else do;                       /* erase part             */               if anything(i)=2               then call erase.most.of.line(i,0);               anything(i)=1;            /* track # only           */            end;         end;         else do;            if DT_PTR(trk.base+i) <> 0 then do j = 0 to 6; /* if track exists */               call DISPLAY_PART(i,j);            /* show parameter options */               anything(i)=2;            /* complete line          */            end;            else do;                       /* erase part             */               if anything(i)=2               then call erase.most.of.line(i,0);               anything(i)=1;            /* track # only           */            end;         end;      end;      else do;                             /* blank lines after last trAck */         if anything(i)<>0         then call erase.most.of.line(i,-1);         anything(i)=0;      end;      if i=0 then do;         call DISPLAY_PART(0,8); /* click rate */         call DISPLAY_PART(0,7); /* frame rate */      end;   end; /* of loop over tracks */   do forever;      pos(ROW+8, MENU_TABLE(COL));      do case GET_ENTRY(ROW,COL);         do; /* 0:  end menu, proceed to reverse compile */            if VT100 then do; write("50")=A.ESC; write("50")=A.GREATER; end; /* set keypad num */            return 0; /* proceed */         end;         ROW = ROW + 1; /* 1:  Down one track */         ROW = ROW - 1; /* 2:  Up   one track */         COL = COL + 1; /* 3:  Right one item */         COL = COL - 1; /* 4:  Left  one item */         do; COL = 0; ROW = ROW + 1; end; /* 5:  <Return> */         ; /* 6:  reset to default - handled above */         do; /* 7:  abort - PF2/crtlx - back to rtp */            if VT100 then do; write("50")=A.ESC; write("50")=A.GREATER; end; /* set keypad num */            return 1; /* abort */         end;         do; /* 8:  abort - BREAK - back to monitor */            if VT100 then do; write("50")=A.ESC; write("50")=A.GREATER; end; /* set keypad num */            clear_screen;            print 'Reverse Compilation halted.';            call exit(-1);         end;         do; /* 9:  abort - PF3 - back to music printing */            if VT100 then do; write("50")=A.ESC; write("50")=A.GREATER; end; /* set keypad num */            return 2; /* music printing */         end;         do; /* 10: refresh the screen (received from Mac emulation program) */            return 3; /* redraw the screen */         end;      end; /* of do case */      if ROW < 0        then do;          /* check for scroll backwards */         if trk.base<>0 then do;            if col<=6 then do;            /* leave on top row if in frame.rate (etc.) field */               row=row+8;            end;            else row=0;            trk.base=trk.base-8;            goto redraw.screen.on.scroll;         end;         row=0;      end;      if (trk.base+ROW) > LAST_ROW then do;  /* stop at last non-empty track */         ROW = LAST_ROW-trk.base;      end;      if row>15 then do;                     /* scroll              */         if trk.base=232                     /* limit to 248 tracks */         then do;            row=15;                          /* stay at trk 248     */         end;         else do;                            /* scroll              */            row=row-8;            trk.base=trk.base+8;            goto redraw.screen.on.scroll;         end;      end;      if COL < 0        then COL = 0;      if COL > 8        then COL = 8;      if (COL > 6) & (ROW > 0) then COL = 6;   end; /* of do forver */end MENU;