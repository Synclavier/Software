/* 00-CONV  $TITLE  SCRIPT Reverse Compiler *//* CJ - 04/24/89 - changes for DTD EVENT processing *//* This program takes as input a Synclavier sequence, and outputs.  a SCRIPT file.  The format and conversion specifications for each.  track may be specified on the input menu.  */insert ':-xpl:reldat';dcl module.title  data ('Synclavier (r)   --   SCRIPT');dcl other.title data ('Reverse Compiler now running  --  SCRIPT');/* see release date changes in here + 02-menu *//* Modification History:.    Oct  1988 - Release 1.0   LSS - processor check in CAN.OVERLAY.    Apr  1988 -               LSS - Bug fixes in SCRIPT compiler.    Oct  1987 - Release N     ADT - Bugs fixed.    Aug  1987 -               CWJ - Update for Release N.    Sept 1986 -               LSS - New catalog structure support -7.    May  1986 -               CWJ - 32 track conversion (sort of).    Feb  1985 -               TSS - finished bomb out recovery.    Jan  1985 -               JSR - changes for MP D2, out of space handling.    Dec  1984 -               JSR - changes for -6 system.    Oct  1984 -               JSR - allowed MP rev D and E sequences.    Aug  1984 -  External Mem CWJ - handle sequences in internal/external memory.    Apr  1984 -  Release I    JSR - Integration of Rel I/R features.    Mar  1984 -  Release H5   CWJ - New features for timbre frame operating system release.    Feb  1984 -               JSR - fixed configuration and work file handling.    Dec  1983 -               JSR - added TEMPO statement.    Sept 1983 -  Release H2 - JSR - added code for guitar update records..    July 1983 -  Release H1 - JSR - added conversion to SCRIPT format,.                                    using code from Music Printing program..      1980-82 -  all earlier versions.   */configuration ModelC, Muldiv; /* uses muldiv everywhere with read & write */pdl 512;                /* extend pushdown stack  */insert ':-xpl:literals'; /* system literals */insert ':-xpl:syslits';  /* system literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:scsi';     /* SCSI device drivers */dcl f#name_len lit '4';  /* # of words in a filename - from CATRTNS */dcl num.tracks   lit '254'; /* number of tracks in sequencer memory *//* music print magic numbers */dcl rev.a        lit '0';dcl rev.b        lit '1';dcl rev.c        lit '2';dcl REV_A.1#     lit '"H0001"';dcl REV_B.1#     lit '"H0101"';dcl REV_B.2#     lit '"H0102"';dcl REV_C.1#     lit '"H0201"';dcl REV_C.2#     lit '"H0202"';dcl REV_D.1#     lit '"H0301"';dcl REV_D.2#     lit '"H0302"';dcl REV_E.0#     lit '"H0400"';dcl REV_E.1#     lit '"H0401"';dcl REV_F.1#     lit '"H0501"';dcl REV_F.2#     lit '"H0502"';dcl dur.table      data (1,4,16,32);dcl new.dur.table  data (1,4,16,64);dcl msc.ptr      pointer; /* pointer to misc data */dcl prm.ptr      pointer; /* pointer to timbre data */dcl seq.ptr      pointer; /* pointer to sequencer data */dcl pre.ptr      pointer; /* pointer to start of music printing preset area */dcl end.ptr      pointer;dcl bas.ptr      pointer; /* for 32 track format */dcl inf.ptr      pointer;dcl par.ptr      pointer;dcl nah.ptr      pointer;dcl bas.len      fixed; /* for 32 track format */dcl inf.len      fixed;dcl par.len      fixed;dcl nah.len      fixed;dcl num.tims     fixed;dcl num.trks     fixed;dcl trk.base     fixed;dcl zero.time    lit  '50';  /* synclav time of 0.000 for 32 track */dcl num.kbd.trks lit  ' 2';dcl syn.med      fixed;   /* 0 if internal, 1 if external memory for timbres, notes */                          /* 2 for 32 track format */dcl cnv.sta      fixed;   /* status from run time package */dcl print.err    fixed;   /* to display bomb out message  */dcl sfm.timbres  boolean; /* true for sfm sequence */dcl cs.seq       boolean; /* type of sequence */dcl cnam(4)      fixed;   /* output file name */dcl buff(10)     fixed;   /* working text buffer */dcl SPACES(128)  fixed;   /* big string of spaces for alignment */dcl P_LINE(200)  fixed;   /* work area for pitch  line */dcl R_LINE(200)  fixed;   /* work area for rhythm line */dcl V_LINE(200)  fixed;   /* work area for volume line */dcl T_LINE(200)  fixed;   /* work area for RTE    line */dcl port.active(num.tracks-1) fixed; /* true if portamento active on track */dcl DT_PTR     (num.tracks-1) pointer; /* notelist pointers */dcl PR_PTR     (num.tracks-1) pointer; /* timbre   pointers */insert ':script:seqdefs';      /* sequencer memory definitions */insert ':script:130-slit';     /* 32 track format literals     *//* $SUBTITLE  Reverse Compiler Options and Parameters */dcl FORMAT     (num.tracks-1) boolean; /* track format */dcl computer   lit '0';   dcl script   lit '1';   dcl ignore   lit '2';dcl TIMES      (num.tracks-1) boolean; /* time representation */dcl absolute   lit '0';   dcl relative lit '1';dcl CODE       (num.tracks-1) boolean; /* value representation */dcl second     lit '0';   dcl frame    lit '1';   dcl frms_only lit '2';dcl KEY        (num.tracks-1) fixed;dcl ACCI       (num.tracks-1) fixed;dcl BEAT_MEAS  (num.tracks-1) fixed;dcl BEAT_NOTE  (num.tracks-1) fixed;dcl RESOLUTION (num.tracks-1) fixed;dcl FRAME_RATE                fixed; /* 100*fps */dcl CLICK_RATE                fixed;dcl CLICKPERIOD               fixed;dcl TEMPO                     fixed;dcl MEASURE_CNT               fixed; /* measure number */dcl NOTE_CNT                  fixed; /* note number */dcl LAST_ROW                  fixed; /* last active row */dcl NONE.IGNORED              boolean; /* true if valid tracks ignored *//* Literal declarations */dcl REST#      lit '63';       /* key number for a rest */dcl LBYTE      lit '"000377"';dcl UBYTE      lit '"177400"';dcl MASK6      lit '"000077"';dcl MASK2      lit '"000003"';dcl SH         lit '"000400"'; /* accidental codes */dcl FL         lit '"001000"';dcl NA         lit '"002000"';dcl MAX_INT#   lit '"077777"';/* Key tables */dcl KEY_NAMES        fixed data (  'C G D A E B F#C#G#D#A#E#B#F BfEfAfDfGfCfFfc g d a e b f#c#g#d#a#e#b#f bfefafdfgfcfff');dcl KEY_CODES        fixed data (  0,0,1,2,3,4,5,6,7,-4,-3,-2,-1,0,-1,-2,-3,-4,-5,-6,-7,4,  /* Majors */  -3,-2,-1,0,1,2,3,4,5,6,7,-4,-3,-4,-5,-6,-7,4,3,2,1);    /* Minors */dcl KEY_MAJORS       fixed data (  'CFGFDFAFEFBFF C G D A E B F#C#'); /* major keys to emit *//* Note tables */dcl SHARP_TABLE      data (0,70,67,71,68,65,69,66);dcl FLAT_TABLE       data (0,66,69,65,68,71,67,70);dcl SHARP_NOTE_CHARS data (67,SH\67,68,SH\68,69,70,SH\70,71,SH\71,65,SH\65,66);dcl FLAT_NOTE_CHARS  data (67,FL\68,68,FL\69,69,70,FL\71,71,FL\65,65,FL\66,66);dcl PRIME_TABLE      data (2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71);dcl NOTE_DATA1       fixed; /* first  word of note record */dcl NOTE_DATA2       fixed; /* second word of note record */dcl NOTE_DATA3       fixed; /* third  word of note record */dcl NOTE_DATA4       fixed; /* fourth word of note record *//* $SUBTITLE  System and User Interface Routines */overlay:  proc(device,start,len); /* return to monitor */   dcl (device,start,len,i) fixed;   i=loc.load+1; /* enter loader */    write("300")=device;   write("301")=start;   write("302")=0;   write("303")=len;   write("320")=i;end overlay;file.error:  proc(code); /* fatal error */   dcl code fixed; /* code number of error */   print;   do case code;      print 'Sequence type identification number is not valid'; /* 0 */      print 'Too many notes in sequence.  Not enough memory to PLAY.'; /* 1 */      ; /* 2 */      print 'Sequence is too long for conversion.'; /* 3 */      print 'Sequence contains incorrect first note code.'; /* 4 */      print 'SYSTEM ERROR - Out of Primes in Build_Template'; /* 5 */      print 'Must install Release R to use Resynthesized Timbres'; /* 6 */      print 'Resynthesized timbre too long - must use External Memory Software'; /* 7 */   end;   print 'Unable to convert this sequence.';   if (core(loc.synret)=loc.p2)     /* came from Synclavier RTP */   or (core(loc.synret)=loc.mplt)   /* or   from Music Printing */   then do;                         /* return to them without dying */      core(loc.synstat)="400";      /* set bit to denote error message on screen */      call overlay(core(core(loc.synret)+1),core(core(loc.synret)),core(core(loc.synret)-1)); /* return to RTP or MP */   end;   else do;      core(loc.rst)=(-1); /* set error for SED */      call overlay(core(loc.mon+1),core(loc.mon),core(loc.mon-1)); /* return to monitor */   end;end file.error;can.overlay:  proc (dev,sec,int.reserved,ext.reserved,secbuf) fixed;   dcl (dev,sec)    fixed; /* DEVICE and starting SECTOR of program to overlay */   dcl int.reserved fixed; /* WORDS of internal memory to reserve */   dcl ext.reserved fixed; /* SECTORS of external memory to reserve */   dcl secbuf       fixed array; /* a 1 SECTOR work buffer */   dcl (i,j)        fixed;   /* NOTE:  this routine computes whether or not the program pointed to      by SEC can be overlayed to give certain memory constraints.  If      okay to overlay, routine returns 0; otherwise it returns a negative      value as follows:            0:  okay to overlay           -1:  desired pgm is an XPL-5 or earlier compilation           -2:  not enough int. memory to hold core procedures,vars, etc.           -3:  not enough int. memory for reserved words           -4:  not enough ext. memory to hold swap procedures           -5:  not enough ext. memory for reserved sectors           -6:  zero sector (means an empty file)           -7:  not an XPL program at all           -8:  program compiled with a newer processor revision    */    if ((dev=0) and (sec=0)) then return (-6); /* file not found (should return -8) */    if (((dev and "377")=0) and (sec=0)) then return (-6); /* empty file */    call readdata(dev,sec,secbuf,256); /* read first sector of target pgm */    j=secbuf(1);    i=secbuf(j+c#vstart)+secbuf(j+c#vlngth)+secbuf(j+c#stklen); /* words need for core procs, vars, pdl */    j=secbuf(j+c#swplen); /* sectors needed for swap procedures */    if (secbuf(0) <>  "100377")    or (secbuf(1) IGT (256-c#conlen))        then return (-7); /* not an XPL program */    if secbuf(secbuf(1)+c#version) <> c#current_version then return (-1); /* program compiled before -7 */    if (shr(secbuf(secbuf(1)+c#cmopt), 8) and "7") > processor_type    then return (-8); /* program compiled with later processor */    if                i IGT LOC.LOAD         then return (-2); /* not enough int mem for core procs */    if (int.reserved+i) IGT LOC.LOAD         then return (-3); /* not enough int mem for resrvd words */    if                j IGT core(LOC.EMSIZE) then return (-4); /* not enough ext mem for swap procs */    if (j+ext.reserved) IGT core(LOC.EMSIZE) then return (-5); /* not enough ext mem for resrvd secs */    return 0; /* okay to overlay */end can.overlay;/* $PAGE */mem.siz=memory.size;msc.ptr=core(loc.synmisc);prm.ptr=core(loc.syntimb);seq.ptr=core(loc.synseq );cnv.sta=core(loc.synstat);syn.med=core(loc.synmed );dcl (i,j,k,l) fixed;insert ':script:00-xsubs'; /* external memory subroutines */insert ':script:01-outpt'; /* formatted and buffered output routines */insert ':script:02-menu';  /* module to process user menu */insert ':script:03-wtimb'; /* module to write out a timbre definition */insert ':script:04-cnote'; /* module to write Computer Music format track */insert ':script:05-snote'; /* module to write SCRIPT format track */do case (terminal.type); /* select terminal type */   ;   ;   adm=1;     /* 2: ADM terminal */   vt100=1;   /* 3: all VT100-types, with or without graphics */   ;   vt100=1;   /* 5: Z19 terminal */   ;end; /* of do case *//* $SUBTITLE  Main Processing Section */if cnv.sta=(-1) then call file.error(1); /* too many notes error */if cnv.sta=(-3) then call file.error(6); /* release r needed     */if cnv.sta=(-4) then call file.error(7); /* resynthesized timbre too long */if cnv.sta<(-1) then call file.error(0); /* magic number error or new type of status return */if (cnv.sta&256)<>0 then do;   print.err=1;    /* set flag for error message printout (means we went to plotting or rtp, would not fit, and are back here) */   print 'Press  <RETURN>  to continue -->',;   i=get_chr;end;cnv.sta=cnv.sta&255;                     /* clear bits in upper half - ok to do since we do not ever bomb out */if syn.med=2 then do;                    /* 32 track format */   bas.ptr=prm.ptr;                      /* this is bas     */   write(mam)=bas.ptr;   write(mal)=new.seq.bas+1;   bas.len=read(mdi);   par.ptr=bas.ptr+read(mdi);   par.len=read(mdi);   nah.ptr=bas.ptr+read(mdi);   nah.len=read(mdi);   inf.ptr=bas.ptr+read(mdi);   inf.len=read(mdi);   write(mam)=bas.ptr;                   /* get base pointer in memory */   do i=0 to 511; seqdata(i)=read(mdi); end;    if nah.len ige 255 then do;           /* too big - we use 1 word pointers herein */      call file.error(3);                /* too long */   end;   pre.ptr=0;   if seqdata(new.seq.mprev) ige REV_F.1# then pre.ptr = 2;   num.trks=218;   num.tims=seqdata(new.seq.numtimbs);end;else do;   do i=0 to 255; seqdata(i)=core(msc.ptr+i); end; /* store misc info in our own array */   pre.ptr=seq.top-seq.nppw-256;         /* compute pointer to preset area */   num.trks=16;   num.tims=16;end;new.menu: /* try again */call set.up.output; /* set up output areas */do I = 0 to num.trks-1; /* loop over tracks and set up notelist pointer */   if syn.med<>2 then do;      DT_PTR(I) = seqdata(seq.pointers + I)-256; /* look up pointer to notes for this track - based off of seq.ptr */      if n.lookup(DT_PTR(I)) <> FIRST.NOTE then do; /* check notelist */         print 'In track ',I+1,;          call file.error(4);      end;      DT_PTR(I) = DT_PTR(I) + 1; /* move past first note code - point to first note record */   end;   else do;      write(mam)=nah.ptr;      write(mal)=i+num.kbd.trks;      if read(md)<>0      then do;         dt_ptr(i)=nah.ptr+read(md);   /* sector of track header */      end;   end;end;i=menu; /* ask the user for the information */if (i=3) then goto new.menu; /* code to refresh the screen */else if i<>0 then do;      /* overlay to RTP or Music Printing */   if i=1 then j=loc.p2;   /* figure out where we are going */   else        j=loc.mplt;   if core(j)=0 then do;   /* file missing */      if j=loc.mplt then print.err=2;      else               print.err=6;      goto new.menu;   end;   if (syn.med=0)          /* seq in internal memory */   then k=can.overlay(core(j+1),core(j),loc.load-prm.ptr,0,ofbuf);   else if (syn.med=1)   then k=can.overlay(core(j+1),core(j),256,core(loc.synseq)+shr(seqdata(seq.slen)+255-256,8),ofbuf);   else k=can.overlay(core(j+1),core(j),256,inf.ptr+inf.len,ofbuf);   if k<>0 then do;        /* cannot overlay for some reason */      do case abs(k+1);         print.err=4;      /* -1: incompatible xpl format         */         print.err=5;      /* -2: not enough core for software    */         print.err=1;      /* -3: sequence too long to play       */         print.err=5;      /* -4: not enough ext mem for software */         print.err=1;      /* -5: sequence too long to play       */         print.err=6;      /* -6: file is not an XPL program */         print.err=6;      /* -7: file is not an XPL program */         print.err=7;      /* -8: program compiled for later processor */      end;      goto new.menu;       /* return to conversion menu - display error */   end;   clear_screen;   if i=1 then do; /* overlaying to the Synclavier so print message */      print 'Starting the Synclavier (r).  Please wait...';   end;   core(loc.synstat)=0;    /* set conversion status to zero for no printout in target program */   core(loc.synret) =loc.rt; /* return to reverse compiler if bomb out */   call overlay(core(j+1),core(j),core(j-1)); /* back to rtp or mplt - use pointers already set up in memory */end;if      seqdata(magic.number)=magic#1 then cs.seq=true;    /* check sequence type */else if seqdata(magic.number)=magic#2 then cs.seq=false;else if seqdata(magic.number)=magic#3 then sfm.timbres=true;else if seqdata(magic.number)=magic#4 then cs.seq=false;   /* new format compilation - nothing else needed */else if (seqdata(magic.number) IGE magic#5)&(syn.med=2) then cs.seq=false;   /* 32 track */else    call file.error(0);               /* not a sequence */j=0;                          /* init pointer to timbre */do I = 0 to num.tims-1;       /* loop over timbres      */   PR_PTR(I) = j;             /* save pointer to timbre */   j=step.timbre.pointer(j);  /* step over sfm or synclavier II timbre */end;do I = 1 to 128;  SPACES(I) = "40"+"40"*256;  end; /* init spaces *//* $SUBTITLE  Emit Overall Information */clear_screen;print string(other.title),' ',string(rel.version),' - ',string(rel.date);print;call outs('/* Synclavier Digital Music System:  Reverse Compiler output */');call new.line;call outs('/* (');call outs(rel.version);call outs(' Software) */');call new.line; /* blank line */if syn.med=2 then do;   call new.line; /* blank line */   call outs('ReleaseM');   call new.line; /* blank line */end;if ((syn.med<>2)&(seq.nppw<>0))or ((syn.med =2)&(inf.len <>0))then do;                     /* preset area present */   if syn.med<>2 then do;    /* look up title       */      i=seqdata(seq.mprev);  /* look up music printing magic number */      if i = 0 then do case (n.lookup(pre.ptr+6)&LBYTE); /* Locate old MP magic # and update MUS_MAG */         i = REV_A.1#;         i = REV_B.1#;      end;      if (i=REV_B.1#) or (i=REV_B.2#) and (n.lookup(pre.ptr+7)<>0) then do; /* rev b title present */         call new.line; call outs('/* Title:  ');         call out.note.string(pre.ptr+n.lookup(pre.ptr+7));         call outs(' */');         call new.line;      end;      else if (i IGE REV_C.1#) then do; /* rev c.1 or later */         if i IGE REV_D.2# then j=65; /* rev D2 or later */         else                   j=35; /* rev D1 or earlier */         if (n.lookup(pre.ptr+j)<>0) then do; /* title present */            call new.line; call outs('/* Title:  ');            call out.note.string(pre.ptr+j);            call outs(' */');            call new.line;         end;      end;   end;   if syn.med = 2 then do;   /* look up title       */      i=seqdata(new.seq.mprev);  /* look up music printing magic number */      j = 11 + 24;                       /* up through Rev D.1 */      if i ige REV_D.2# then j = j + 30; /* Since Rev D.2 */      if i ige REV_F.1# then j = j +  8; /* Since Rev F.1 */      if i ige REV_F.2# then j = j + 24; /* Since Rev F.2 */      if i ige REV_C.1# and (i.lookup(j)<>0) then do; /* title present */         call new.line; call outs('/* Title:  ');         call out.inf.string(j);         call outs(' */');         call new.line;      end;   end;end; /* of preset area stuff *//* $PAGE - Check for scale, speed, etc. */i=0; /* assume no scale info required */do j=0 to 11; /* check each entry */   k=(j*1024+6)/12; /* compute what scale should be */   if k<>seqdata(j) then i=1;end;if (i) then do; /* emit scale */   call new.line; call outs('Scale ');   do j=0 to 11;      k=12000*seqdata(j)/1024; /* compute number */      if read(4)>=512 then k=k+1; /* round up */      l=seqdata(j) mod 256; /* compute step relative to semitone */      if l=85 then k=k+4; if l=171 then k=k-4; /* compute exact for semitones */      call outn(k,3,true);   end;end;if seqdata(seq.speed)<>1000 then do; /* speed */   call new.line; call outs('Speed ');   call outn(seqdata(seq.speed),3,true);end;if syn.med=2 then do;   i=seqdata(new.seq.bpm);   if (i<>4) and (i<>0) then do; /* Beats Per Measure */      call new.line; call outs('BeatsPerMeasure ');      call outi(i,0);   end;end;if syn.med<>2 then do;   clickperiod=seqdata(seq.click)*5; /* click period, msec    */   TEMPO = seqdata(seq.click);       /* leave tempo unchanged */end;else do;   clickperiod=seqdata(new.seq.click); /* click period, msec */   TEMPO = clickperiod;                /* use msec           */end;if clickperiod ~= 500 then do; /* non-default click period */   call new.line; call outs('Clickperiod '); /* define clicks */   call outn(clickperiod,3,true); /* in seconds */end;if clickperiod ~= 500 | click_rate ~= 4 then do; /* non-default click rate */   call new.line; call outs('Tempo'); /* define tempo */   call outn(click_rate,0,false); call outs(' = ');   call outn(clickperiod,3,false); call outs(' seconds');end;if syn.med<>2 then do;   i=seqdata(seq.live.click);   i=shl(i&256,1)\(i&255);end;else do;   i=seqdata(new.seq.live.click);end;if (i&511)>=4 then do;      /* live click track */   call new.line; call outs('Clicktrack ');   call outi((i&511)-3,0);  /* emit track # 1-16 */end;if crm>1 then do; /* output click rate multiplier */   call new.line; call outs('Clickmultiplier ');   call outi(crm,0);end;if syn.med<>2 then do;   i=seqdata(seq.octratio);end;else do;   i=seqdata(new.seq.octratio);end;if i<>1000 then do; /* octave ratio */   call new.line; call outs('Octaveratio ');   call outn(i,3,true);end;/* $page - check for loop, smpte info */if syn.med<>2 then do;   i=seqdata(seq.loop);   if i then do; /* LOOP statement */      call new.line; call outs('Loop ');      j=seqdata(seq.g.p.t);      k=seqdata(seq.g.p.t.c);      call outt(k,j,0,0,0); /* loop time in absolute format */   end;end;else do;   i=seqdata(new.seq.loop);   if i then do; /* LOOP statement */      call new.line; call outs('LoopStart ');      j=seqdata(new.seq.s.p.t);      k=seqdata(new.seq.s.p.t.c);      call outt(k,j,0,0,0); /* loop time in absolute format */      call new.line; call outs('Loop      ');      j=seqdata(new.seq.g.p.t);      k=seqdata(new.seq.g.p.t.c);      call outt(k,j,0,0,0); /* loop time in absolute format */   end;end;if syn.med=2 then do; /* check for Mark Point */   i=seqdata(new.seq.mark.msb);   j=seqdata(new.seq.mark.lsb);   if (i\j)<>0 then do;       /* MARKPOINT statement */      call new.line; call outs('MarkPoint ');      call outt(i,j,0,0,0); /* mark point time in abs format */   end;end;if frame_rate<>2400 then do; /* specify frame rate */   call new.line; call outs('FPS ');   call outn(frame_rate,2,true);end;i=0; /* assume no smpte info */do j=seq.smode to seq.hrsmin;   i=i\seqdata(j);end;if i<>0 then do;          /* smpte */   call new.line; call outs('SMPTEinfo ');   call outn(seqdata(seq.smode),0,false);   call outs('  ');   call out2(shr(seqdata(seq.hrsmin),8));   call out2(seqdata(seq.hrsmin)&255);   call out2(shr(seqdata(seq.secfra),8));   call out2(seqdata(seq.secfra)&255);   call out2(seqdata(seq.smbits)&255);end;if syn.med=2 then do; /* check for DTD SOLOS */   i=seqdata(SEQ.DTD.SOLOS);	if (i != 0)	{		call new.line; call outs('DTDSolos');				j = 1;		k = 1;				while (j != 0)		{			if ((i & j) != 0)			{				call outn(k, 0, false);							if ((j != 0x8000) && (i IGE shl(j,1)))					outs(',');			}						j = shl(j,1);			k = k + 1;		}	}end;/* $page - emit track info (multi, midi) for old format only */if syn.med<>2 then do;   if seqdata(seq.trout1)<>0 then do;  /* multi routing */      call new.line; call outs('MultiRouting ');      do j=0 to 15;         if (j&1)=0 then i=shr(seqdata(seq.trout1+shr(j,1)),8)&63;         else            i=    seqdata(seq.trout1+shr(j,1))   &63;         i=i+1;         if i<10 then call outs(' ');         call outi(i,false); call outs(' ');      end;      call new.line; call outs('             ');      do j=0 to 15;         if (j&1)=0 then i=shr(seqdata(seq.trout2+shr(j,1)),8)&63;         else            i=    seqdata(seq.trout2+shr(j,1))   &63;         i=i+1;         if i<10 then call outs(' ');         call outi(i,false); call outs(' ');      end;   end;   i=0;   do j=0 to 15;      i=i\seqdata(seq.trvols+j);   end;   if i<>0 then do;      call new.line; call outs('Trackvolumes ');      do j=0 to 15;         call outn(seqdata(seq.trvols+j),1,true);         if j=7 then do;            call new.line; call outs('             ');         end;      end;   end;   i=0;   do j=0 to 11;      i=i\seqdata(seq.midi+j);   end;   if i<>0 then do;             /* midi information included */      call new.line; call       outs('Midiinfo ');      do j=0 to 7;         call outn(    seqdata(seq.midi+j)&255,0,true);         call outn(shr(seqdata(seq.midi+j),8) ,0,true);         if j=3 then do;            call new.line; call outs('         ');         end;      end;      call new.line; call outs('         ');      do j=8 to 11;         call outn(    seqdata(seq.midi+j)    &15,0,true);         call outn(shr(seqdata(seq.midi+j), 4)&15,0,true);         call outn(shr(seqdata(seq.midi+j), 8)&15,0,true);         call outn(shr(seqdata(seq.midi+j),12)&15,0,true);         if j=9 then do;            call new.line; call outs('         ');         end;      end;   end;end;/* $SUBTITLE  Now emit timbre, notelist, and edit information */if syn.med<>2 then do;                  /* original format - loop over tracks */   do I=0 to num.trks-1;                /* loop over tracks */      if FORMAT(I)<>IGNORE then do;     /* ignore both notes and timbre */         if n.lookup(DT_PTR(i)) <> 0    /* if any notes on track        */         then call write.timbre(I,1);   /* then write out even null timbres */         else call write.timbre(I,0);   /* else put out timbre only if non-null */         if limit.reached then do;      /* buffer filled up */            if oftyp=0 then do;         /* disk output */               print.err=3; goto new.menu;            end;            else call file.error(3);         end;      end;    end; end;else do;                                /* new format - loop over timbres */   if num.tims = 0 then do;             /* write out null timbre */      call new.line;      call new.line; call outs ('Define Timbre Timbre1');      call new.line; call outs ('End Timbre1');   end;   do I=0 to num.tims-1;                /* loop over timbres              */      j=0;                              /* assume timbre is not used      */      do k=0 to num.trks-1;             /* see if timbre used by track    */         if FORMAT(k)<>IGNORE then do;  /* if track is not ignored        */            if (DT_PTR(k)) <> 0         /* see if track head exists       */            then do l=0 to thd.usage.len-1 by 2;               write(mam)=DT_ptr(k);    /* point to it                    */               write(mal)=thd.usage+l;               if  (read(mdi)=i+num.kbd.trks)  /* this timbre is used      */               and (read(mdi)<>0)              /* at least once            */               then j=1;                       /* must convert it          */            end;         end;      end;      if j<>0 then do;                         /* convert it               */         call write.timbre(I,1);               /* then write out even null timbres */      end;      if limit.reached then do;      /* buffer filled up */         if oftyp=0 then do;         /* disk output */            print.err=3; goto new.menu;         end;         else call file.error(3);      end;   end; end;NONE.IGNORED = true;        /* assume no valid tracks ignored */do I=0 to num.trks-1;       /* loop over tracks */   if syn.med<>2 then j=n.lookup(DT_PTR(I));   else               j=        (DT_PTR(I));   if j <> 0                      /* if any notes on track        */   then do;      print 'Track ',; pnum(I+1,false); print ':  ',;      if FORMAT(I)<>IGNORE then do; /* process this track */         NOTE_CNT = 0; /* clear note counter */         if syn.med<>2 then do;            seqdata(seq.ile.ptrs+I)=seqdata(seq.ils.ptrs+I); /* set nonzero if ind loop */         end;         call write.notelist.header(I);         if      FORMAT(I)=SCRIPT   then call write.snotelist(I); /* write SCRIPT notelist */         else if FORMAT(I)=COMPUTER then call write.cnotelist(I); /* write Computer Music notelist */         print 'contains ',; pnum(NOTE_CNT,false); print ' notes, ',;         pnum(MEASURE_CNT,false); print ' measures';         call new.line; call outs('End ');      end;      else do;  NONE.IGNORED = false;  print 'ignored';  end;   end; /* of track contains notes */   if limit.reached then do; /* buffer filled up */      if oftyp=0 then do;    /* disk output      */         print.err=3; goto new.menu;      end;      else call file.error(3);   end;end; /* of loop over tracks *//* $SUBTITLE  Dump Edit Information and then Exit */if ((syn.med<>2)&(seq.nppw IGT 0))or ((syn.med =2)&(inf.len  <>  0))then do;   /* if presets exist */           /* dump presets and edit info in hexadecimal block */   if syn.med<>2 then do;      K=shr(seqdata(seq.mprev),8); /* look up music printing rev */      if K=0 then K=n.lookup(pre.ptr+6)&LBYTE; /* get earlier music printing magic number */      if K=REV.A then print 'Rev A Music Printing edit info has been ignored';      if K>=REV.B then do; /* this is Rev B or later stuff */         call new.line; /* blank line */         call new.line; call outs('EditInformation');         i=pre.ptr; /* init pointer to presets and edit info */         l=0;       /* initialize check sum */         do while i ILT (pre.ptr+seq.nppw);  /* loop over words */            if ((i-pre.ptr) mod 15)=0 then do; /* start new line */               call new.line; call outs('  ');            end;            j=n.lookup(i); /* get word */            l=l+j; /* update checksum */            call outhword(j); /* emit hex word with space */            i=i+1;         end; /* of loop over words */         call new.line; call outs('  XXXX '); /* add ending mark */         call outhword(l+seqdata(seq.mprev)); /* output check sum */         call outhword(seqdata(seq.mprev));   /* output trailing (optional) mprev word */         call new.line; call outs('End');         print 'Sequence contains ',; pnum(seq.nppw,false);         print ' words of preset and Rev ',character("101" + k),               ' Music Printing data.';      end;   end;    else do;    /* M format */      K = seqdata(new.seq.mprev); /* look up music printing rev */      if K = 0 then K = shl(i.lookup(6),8) | 1; /* get earlier music printing magic number */      if K ige REV_C.1# then do; /* this is Rev C or later stuff */         call new.line; /* blank line */         call new.line; call outs('EditInformation');         i=0; /* init pointer to presets and edit info */         l=0; /* initialize check sum */         pre.ptr = 0; /* This is a kludge to allow i.lookup to be used */         do while i ILT shl(inf.len,8);  /* loop over words */            if (i mod 15)=0 then do; /* start new line */               call new.line; call outs('  ');            end;            j=i.lookup(i); /* get word */            l=l+j; /* update checksum */            call outhword(j); /* emit hex word with space */            i=i+1;         end; /* of loop over words */         call new.line; call outs('  XXXX '); /* add ending mark */         call outhword(l+K); /* output check sum */         call outhword(K);   /* output trailing (optional) mprev word */         call new.line; call outs('End');         print 'Sequence contains ',; pnum(shl(inf.len,8),false);         print ' words of Rev ',character("101" + shr(k,8)),               '.',             character("60" + (k&"377")),               ' Music Printing data.';      end;      else print 'Rev A or B Music Printing data has been ignored.';   end;end; /* of edit info exists and no tracks ignored */if bc then call outw(word); else call outw(0); /* emit end of last line */if oftyp=0 then call outf; /* force out disk buffer */if limit.reached then do; /* buffer filled up */   if oftyp=0 then do; /* disk output - we can recover */      print.err=3; goto new.menu;   end;   else call file.error(3);end;/* done with conversion - return to monitor */core(loc.cmed)  =core(loc.wmed); /* current file is in .WORK, or so */core(loc.csec+1)=ofdevice; /* device of output (WRKDEV) */core(loc.csec  )=ofstart; /* start of data (WRKSEC) */core(loc.csln)=shr(oflngth+255,8);core(loc.clen)=oflngth;core(loc.ftyp)=0; /* text file */core(loc.strd)=1; /* indicate stored file */core(loc.svd) =0; /* indicate that it is not saved anywhere */do i=0 to f#name_len; cnam(i)=core(loc.cfn+i); end; /* get current name */i=cnam(0); /* get length */if i<>0 then do; /* remove . or * */   j=byte(cnam,i-1); /* look up last byte */   if (j=A.PERIOD) or (j=A.STAR) or (j=A.DOLLAR) then i=i-1;end;if i>=shl(f#name_len, 1) then i=shl(f#name_len, 1) - 1;call pbyte(cnam,i,A.DOLLAR); /* append dollar sign to name */cnam(0)=i+1;do i=i+1 to shl(f#name_len, 1) - 1; call pbyte(cnam,i,0); end; /* zero fill */do i=0 to f#name_len; core(loc.cfn+i)=cnam(i); end; /* store name */print 'Conversion Successful - Current file is now called ',string(cnam);call overlay(core(loc.mon+1),core(loc.mon),core(loc.mon-1)); /* return to monitor */