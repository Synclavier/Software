/* $SUBTITLE  Source Scanning and Insert File Stacking Routines *//* SOURCE FILE VARIABLES */DCL SFPOS  FIXED; /* SOURCE FILE BUFFER POSITION */DCL SFSEC  FIXED; /* SOURCE FILE CURRENT SECTOR (NEXT ONE TO READ) */DCL SFFLP  FIXED; /* AND WORD EQUIVALENT OF FSEC */  DCL BC     FIXED; /* AND BYTE TOGGLE */DCL WORD   FIXED; /* CURRENT WORD (INSERT PROCESSING) */DCL READL  FIXED; /* LENGTH TO READ */DCL NCHR   FIXED; /* PRESENT CHAR */DCL LCHR   FIXED; /* PREVIOUS NCHR */  /* INSERT FILE STACK */  DCL ISTKLEN       LIT '60'; /* STACK SIZE FOR INSERT FILES */DCL ISTK(ISTKLEN) FIXED; /* STACK AREA FOR INSERT FILES */DCL ISPT          FIXED; /* STACK POINTER:  IF 0, MEANS IN SOURCE FILE *//* CATALOG VARIABLES */DCL NEWDISK       FIXED; /* SETS TO TRUE IF WE USED A NEW DISK HERE */DCL CATBUF(C#DIR_MAX - 1) FIXED; /* CATALOG BUFFER */DCL CACHE.NUM     FIXED; /* CACHE NUMBER */DCL DISABLED      BOOLEAN; /* TRUE IF CACHE IS DISABLED */CALL SET_CATBUF(ADDR(CATBUF (0)), 0); /* SET THE CATALOG BUFFER */DISABLED = TRUE; /* CACHE IS CURRENTLY DISABLED */GET.RESPONSE:  PROC; /* PROMPT AND WAIT FOR NEW DISK */   DCL I FIXED;   PRINT ' into the lower or right-most';   PRINT 'drive, and press <RETURN> when ready--',; /* PROMPT */   I=0;   DO WHILE I<>a.CR; /* WAIT FOR CARRIAGE RETURN */      I =  READ("50") AND "177"; /* READ CHAR */      IF I = C.S THEN DO WHILE I <> C.Q; I = READ("50") AND "177"; END; /* HANDLE  CTRL-S, CTRL-Q */      IF I = 0 THEN CALL EXIT(-1); /* STOP IF BREAK */   END; /* OF DO WHILE */   PRINT;   CALL DISABLE_CACHE(CACHE.NUM); /* DISABLE CACHING */   DISABLED = TRUE; /* CACHE HAS BEEN DISABLED */END GET.RESPONSE;FILESEARCH: PROC(NAM) RETURNS (BOOLEAN); /* SEARCH FOR GIVEN FILE */   DCL NAM   FIXED ARRAY; /* FILE NAME TO SEARCH FOR */   DCL FOUND BOOLEAN; /* TRUE IF A FILE IS FOUND */   DCL I     FIXED;   FOUND = FALSE; /* FILE NOT FOUND YET */   I = 1; /* START SEARCH ON CURRENT CATALOG */   DO WHILE (I >= 0) AND (NOT FOUND); /* SEARCH CATALOGS UNTIL FILE IS FOUND */      FOUND = LOCATE(NAM,I); /* SEARCH CATALOG */      I = I - 1;      IF DISABLED THEN DO; /* CACHE IS CURRENTLY DISABLED */         CACHE.NUM = CACHE(C#BUFPTR,C#BUFMED); /* CACHE THIS CATALOG */         DISABLED = FALSE; /* CACHE IS NOW ENABLED */      END;   END;   RETURN (FOUND); /* RETURN TRUE IF FILE WAS FOUND */END FILESEARCH;/*  OPENFILE IS CALLED TO OPEN UP AN INSERT FILE DURING AN 'INSERT' STATEMENT.    OPENFILE ASKS THE USER TO INSERT A SECOND DISK DURING COMPILATION IF    THE FILE IS NOT SAVED ON THE CURRENT DISK.  THE NEWDISK FLAG IS SET    IF A NEW DISK IS USED. */OPENFILE:  PROC(NAM); /* OPEN A FILE */   DCL NAM   FIXED ARRAY; /* NAME OF FILE TO OPEN */   DCL FOUND BOOLEAN; /* TRUE IF A FILE IS FOUND */   DCL I     FIXED;   NEWDISK = 0; /* ASSUME NO NEW DISK USED */   FOUND = FALSE; /* FILE NOT FOUND YET */   DO WHILE (NOT FOUND);      FOUND = FILESEARCH(NAM); /* SEARCH FOR THIS FILE ON CURRENT AND SYSTEM CATALOGS */      IF NOT FOUND THEN DO; /* FILE NOT FOUND */         PRINT;         IF SYSTYP=0 THEN DO; /* FLOPPY - ASK FOR NEXT DISK */            PRINT 'Insert diskette containing file "',STRING(NAM),'"',;            CALL GET.RESPONSE; /* PROMPT AND WAIT FOR REPLY */            NEWDISK=1; /* NEW DISK IS BEING USED */         END; /* FLOPPY */         ELSE DO; /* FATAL ERROR ON WINCHESTER */            PRINT 'Could not find file "',STRING(NAM),'"',;            CALL ER.COUNT; /* FINISH MESSAGE */            CALL EXIT(-1);         END; /* WINCHESTER */      END;   END; /* OF WHILE FILE NOT FOUND */   IF F#TYPE <> T#TEXT THEN DO; /* NOT A TEXT FILE */      PRINT;      PRINT 'File "',STRING(NAM),'" is not a text file',;      CALL ER.COUNT; /* FINISH MESSAGE */      CALL EXIT(-1);   END;   END OPENFILE;/* $subtitle Insert file stacking */IPUSH:  PROC(WORD); /* PUSH WORD ONTO STACK */  DCL WORD FIXED;  IF ISPT>ISTKLEN THEN DO; /* TOO LARGE */    PRINT 'Too many nested insert files.  Fatal Error';    CALL EXIT(-1);  END;  ISTK(ISPT)=WORD; /* STORE WORD ON BOTTOM OF STACK */  ISPT=ISPT+1; /* INCR */END IPUSH;  IPOP:  PROC; /* POP WORD FROM STACK */  ISPT=ISPT-1; /* DECR */  RETURN ISTK(ISPT); /* GET WORD & RETURN IT */END IPOP;/* THE PROCESSING OF INSERT FILES IS DONE BY THE STATEMENT SCANNER   ('STMT' PROCESSES THE INSERT STATEMENT),  AND THE SCANNER   ('SCAN' DETECTS THE END-OF-FILE CONDITION OF AN INSERTED FILE).   AS SUCH,  THE 'GC' PROCEDURE DOES NOT DIFFERENTIATE BETWEEN   THE END OF THE MAIN SOURCE FILE AND THE END OF AN INSERT FILE. */PUSHFILE:  PROC; /* PROCEDURE TO PUSH CURRENT FILE & OPEN INSERT FILE */  DCL I FIXED;  DO I=0 TO F#NAME_LEN; /* STORE CURRENT FILE NAME */     CALL IPUSH(CFNAME(I));  END;  CALL OPENFILE(NAME); /* LOOK IN DIRECTORY FOR FILE - GET "NEWDISK" VARIABLE  */  CALL IPUSH(SFDEVICE);  CALL IPUSH(SFSTART);  CALL IPUSH(SFSLEN);  CALL IPUSH(SFREM);  CALL IPUSH(SFFLP);  CALL IPUSH(SFSEC); /* PUSH CURRENT FILE POS */  CALL IPUSH(SFPOS);  CALL IPUSH(BC);  CALL IPUSH(WORD);  CALL IPUSH(LINE.NO);  CALL IPUSH(NCHR);  CALL IPUSH(NEWDISK);  SFDEVICE=F#MS_SECTOR;  SFSTART=F#LS_SECTOR; /* SET UP FOR NEW FILE */  SFSLEN  =F#LS_LENGTH;  SFREM  =F#WORDS;  DO I=0 TO F#NAME_LEN; /* store last name scanned off treename */     CFNAME(I)=F#NAME(I);  END; /* MOVE SPECIFIED FILE NAME TO 'CFNAME' */  READL=SFBUFL; /* READ FOR LENGTH OF BUFFER */  IF SHR(READL,8) IGT SFSLEN THEN READL=SHL(SFSLEN,8);  CALL READDATA(SFDEVICE,SFSTART,LOCATION(SFLOC),READL);  BC   =0;  SFFLP=0;  SFPOS=0;  SFSEC=0;   NCHR =0; /* SET TO ZERO SO WE SCAN OFF FIRST LINE NUMBER */END PUSHFILE;/* POPFILE:  USED TO RESTORE BACK TO AN EARLIER SOURCE FILE AFTER     PROCESSING AN INSERT STATEMENT.   WHILE PROCESSING AN INSERT FILE,     STATUS IS STORED ON A STACK TO ALLOW NESTED INSERT STATEMENTS. */POPFILE:  PROC; /* PROCEDURE TO POP UP ONE FILE */  DCL I FIXED;  DCL (MSW,LSW) FIXED;  NEWDISK =IPOP; /* RECORD WHETHER OR NOT A NEW DISK WAS REQD */  NCHR    =IPOP; /* RESTORE CHARACTER */  LINE.NO =IPOP; /* RESTORE LINENUMBER */  WORD    =IPOP;  BC      =IPOP;  SFPOS   =IPOP;  SFSEC   =IPOP; /* RECOVER INFO */  SFFLP   =IPOP;  SFREM   =IPOP;  SFSLEN  =IPOP;  SFSTART =IPOP;  SFDEVICE=IPOP;  DO I = F#NAME_LEN TO 0 BY -1; /* RECOVER NAME */     CFNAME(I)=IPOP;  END;    IF NEWDISK THEN DO; /* MUST RE-FETCH OLD DISK */    PRINT;    IF CFNAME(0)=0    THEN PRINT 'Re-insert original user diskette',; /* BACK TO ORIGINAL */    ELSE PRINT 'Re-insert the diskette containing "',STRING(CFNAME),'"',; /* INSERT CORRECT ONE */    CALL GET.RESPONSE;  END;  READL=SFBUFL; /* READ FOR LENGTH OF BUFFER */  IF SHR(READL,8) IGT (SFSLEN-SFSEC) THEN READL=SHL(SFSLEN-SFSEC,8);  MSW = SFDEVICE; /* COMPUTE STARTING SECTOR */  LSW = SFSTART + SFSEC;  IF LSW ILT SFSTART THEN MSW = MSW + 1;  CALL READDATA(MSW,LSW,LOCATION(SFLOC),READL); /* PRIME THE BUFFER */END POPFILE;/* $subtitle Character Processing Routines *//* THE ROUTINE 'GC' IS CALLED TO GET THE NEXT CHARACTER FROM THE SOURCE   FILE.  IT WILL RETURN THE NEXT 8-BIT CHARACTER.  IF AN END OF FILE   CONDITION IS ENCOUNTERED,  A VALUE OF '-1' WILL BE RETURNED. */  READL=SFBUFL;                        /* READ FOR LENGTH OF BUFFER */IF SHR(READL,8) IGT SFSLEN THEN READL=SHL(SFSLEN,8);CALL READDATA(SFDEVICE,SFSTART,LOCATION(SFLOC),READL); /* FILL UP FIRST BUFFER */  GC:  PROC; /* PROCEDURE TO GET NEXT CHARACTER */  DCL (MSW,LSW) FIXED;  IF BC=0 THEN DO; /* MUST GET NEXT WORD */    IF (SFFLP=SFREM)&(SFSEC+SHR(SFBUFL,8) IGE SFSLEN) THEN RETURN (-1); /* END OF FILE */    IF SFPOS=SFBUFL THEN DO; /* END OF THIS BUFFER LOAD - GET NEXT ONE */      SFSEC=SFSEC+(SHR(SFBUFL,8)); /* INCR LENGTH */      IF SFSEC IGE SFSLEN THEN RETURN (-1); /* PAST END OF FILE */      READL=SFBUFL;                        /* READ FOR LENGTH OF BUFFER */      IF SHR(READL,8) IGT SFSLEN-SFSEC THEN READL=SHL(SFSLEN-SFSEC,8);      MSW = SFDEVICE;      LSW = SFSTART + SFSEC;      IF LSW ILT SFSTART THEN MSW = MSW + 1;      CALL READDATA(MSW,LSW,LOCATION(SFLOC),READL); /* GET IT ALL */      SFPOS=0; /* START AT BEGINNING OF BUFFER */    END;    WORD=CORE(SFLOC+SFPOS);    SFPOS=SFPOS+1; /* INCREMENT BUFFER POSITION */    SFFLP=SFFLP+1; /* INCREMENT FILE   POSITION */    BC=1; /* SET BYTE TOGGLE */    RETURN (WORD&255);  END; /* OF CASE FOR NEXT WORD */  ELSE DO;    BC=0; /* CLEAR BYTE TOGGLE */    RETURN SHR(WORD,8);  END;END GC;  GET.CHAR:  PROC; /* SCAN NEXT CHARACTER, CONVERT TO LOWER CASE */  LCHR=NCHR; NCHR=GC; /* SCAN NEXT */  IF (NCHR>=L.A) AND (NCHR<=L.Z) THEN NCHR=NCHR-(L.A-A.A);END GET.CHAR;/* $SUBTITLE  Main token scanner - SCAN *//* 'SCAN' IS CALLED TO SCAN THE NEXT TOKEN FROM THE SOURCE FILE.   THE FOLLOWING ITEMS ARE RECOGNIZED:       1. END OF FILE       2. COMMENTS - IGNORED       3. STRING CONSTANTS - USED WITH INSERT       4. SYMBOLS - LOOK UP IN TABLE       5. NUMBERS - BEGIN WITH . OR DIGIT       6. SPECIAL CHARACTER ,*/DCL INFO       FIXED; /* CONTAINS INFO ON TOKEN */DCL DP         FIXED; /* INDICATES # OF DIGITS TO LEFT OF DP SCANNED */DCL ENABLE.EOL FIXED; /* SET TRUE IF CAN RETURN END OF LINE TOKEN *//* SCAN.EOL SCANS OFF LINE NUMBER WHEN NCHR=0 */SCAN.EOL:  PROC; /* SCAN THROUGH LINE NUMBERS & ETC. */  DCL TLNUM FIXED; /* HOLDS TEMP LINE # */  IF BC THEN CALL GC; /* SKIP OVER SECOND NULL IF ODD BYTE COUNT */  NCHR=GC; /* GET NEXT CHARACTER */  IF NCHR=-1 THEN RETURN; /* END OF FILE, RETURN -1 */  ELSE DO; /* SCAN LINE NUMBER */    TLNUM=WORD; CALL GC; /* GET LINE NUMBER, SCAN SECOND BYTE */    NCHR=LCHR; CALL GET.CHAR; /* KEEP LCHR; SCAN FIRST CHAR OF LINE */    IF TLNUM<>0 THEN LINE.NO=TLNUM;    ELSE             LINE.NO=LINE.NO+1;  END;END SCAN.EOL;SCAN.COMMENT:  PROC; /* SCAN AHEAD TO END OF COMMENT */  DCL I FIXED;  I=LINE.NO; /* GET LINE NUMBER OF START OF COMMENT */  CALL GET.CHAR;  IF NCHR<>A.STAR THEN DO;    CALL ER.SLA; RETURN; /* START OVER */  END;  DO WHILE (NCHR<>(-1))&((LCHR<>A.STAR)\(NCHR<>A.SLASH));    IF NCHR=0 THEN DO; /* END OF LINE */      IF ENABLE.EOL THEN DO; /* OOPS - NON TERMINATED COMMENT */        LINE.NO=I; CALL ER.NTC; RETURN;      END;      CALL SCAN.EOL; /* SKIP OVER END OF LINE */    END;    ELSE CALL GET.CHAR; /* GET NEXT */    IF (LCHR=A.SLASH) AND (NCHR=A.STAR) THEN DO; /* NESTED COMMENTS - MEANS MISSING END */      LINE.NO=I; CALL ER.NTC;    END;  END;  IF NCHR=(-1) THEN DO; /* END OF FILE */    LINE.NO=I; CALL ER.NTC;  END;  ELSE CALL GET.CHAR; /* NORMAL TERMINATION - SKIP OVER FINAL SLASH */END SCAN.COMMENT;SCAN.AHEAD:  PROC; /* PROCEDURE TO SKIP AHEAD TO NON SPACE/SEMICOLON CHAR */  DO WHILE (NCHR=A.SLASH)\(NCHR=0)\(NCHR=A.SEMICOLON)\(NCHR=A.SP); /* SKIP THESE */    IF NCHR=A.SLASH THEN CALL SCAN.COMMENT; /* SCAN COMMENT */    ELSE IF NCHR=0 THEN DO; /* END OF LINE */      IF ENABLE.EOL THEN DO; /* INSTEAD OF SCANNING IT, RETURN T.EOL */        TOKEN=T.EOL; RETURN 1;      END;      CALL SCAN.EOL; /* ELSE SKIP OVER END OF LINE */    END;    ELSE CALL GET.CHAR; /* SKIP OVER SPACE OR SEMICOLON */  END;  RETURN 0;END SCAN.AHEAD;/* $SUBTITLE  Scan off numeric quantities */SCAN.NUMBER:  PROC; /* INTERNAL ROUTINE TO SCAN OFF SMALL NUMBERS */  DCL I FIXED;  I=0; /* INITIALIZE */  IF (NCHR<A.0) OR (NCHR>A.9) THEN CALL ER.IFM; /* MUST BE DIGIT */  DO WHILE (NCHR>=A.0) AND (NCHR<=A.9); /* PROCESS UNTIL NON-DIGIT */    IF I>3000 THEN CALL ER.TMD; /* TOO MANY DIGITS */    I=I*10+(NCHR-A.0);    CALL GET.CHAR; /* GET NEXT */  END;  RETURN I;END;SCAN.NUMERIC:  PROC; /* SCAN OFF NUMERIC QUANTITY */  DCL (I,J,K) FIXED;  CALL SCAN.AHEAD;  IF (NCHR<>A.MINUS) AND (NCHR<>A.PERIOD) AND ((NCHR<A.0)\(NCHR>A.9)) THEN DO;    CALL ER.IFM; IF NCHR<>0 THEN CALL GET.CHAR; RETURN;  END;  INFO=0; DP=0; I=0; J=0; K=0; /* INITIALIZE */  IF NCHR=A.MINUS THEN DO; K=1; CALL GET.CHAR; END;  DO WHILE (NCHR=A.PERIOD) OR ((NCHR>=A.0)&(NCHR<=A.9));    IF NCHR=A.PERIOD THEN DO; /* DECIMAL POINT */      IF I THEN CALL ER.IFN; /* TWO DOTS? */      ELSE           I=1; /* INDICATE DECIMAL POINT FOUND */    END;    ELSE DO;       /* HANDLE DIGIT */      J=1;         /* INDICATE AT LEAST ONE DIGIT FOUND */      IF INFO IGT 3276 THEN DO;    /* ABOUT TO OVERFLOW */        IF I=0 THEN CALL ER.TMD;   /* TOO MANY DIGITS - IGNORE OTHERWISE */      END;      ELSE DO; /* ADD IN NEXT DIGIT */        INFO=(INFO*10)+NCHR-A.0; /* COMPUTE NUMBER */        IF I THEN DP=DP+1; /* INDICATE ONE AFTER DECIMAL POINT */      END;    END;    CALL GET.CHAR; /* SKIP OVER IT */  END; /* OF DO WHILE */  IF K THEN INFO=(-INFO); /* NEGATE */  IF J=0 THEN CALL ER.EDP; /* PERIOD BUT NO DIGITS */END SCAN.NUMERIC;SCAN.NUM.PAREN:PROC; /* SCAN OFF NUMBER IN PARENTHESES */   IF NCHR<>A.LPAREN THEN DO;CALL ER.MTMP;RETURN;END; /* R PAREN - SCAN OFF RTE */   CALL GET.CHAR; CALL SCAN.NUMERIC; /* SKIP (, SCAN OFF NUMBER */   CALL SCAN.AHEAD; /* LOOK FOR ) */   IF NCHR<>A.RPAREN THEN CALL ER.MTMP;   CALL GET.CHAR; /* SKIP OVER RP */END SCAN.NUM.PAREN;SCAN.HEX:  PROC; /* SCAN OFF HEX WORD */  DCL I FIXED;  CALL SCAN.AHEAD;  IF ((NCHR<A.A)\(NCHR>A.F)) AND ((NCHR<A.0)\(NCHR>A.9)) THEN DO;    CALL ER.IFM; IF NCHR<>0 THEN CALL GET.CHAR; RETURN;  END;  INFO=0; I=0; /* INITIALIZE */  DO WHILE ((NCHR>=A.A)&(NCHR<=A.F)) OR ((NCHR>=A.0)&(NCHR<=A.9));    IF I>3 THEN CALL ER.TMD; /* TOO MANY DIGITS */    ELSE DO; /* ADD IN NEXT DIGIT */      INFO=SHL(INFO,4); /* SHIFT */      IF NCHR>A.9 THEN INFO=INFO\(NCHR-A.A+10);      ELSE             INFO=INFO\(NCHR-A.0);      I=I+1; /* COUNT DIGIT */    END;    CALL GET.CHAR; /* GET NEXT CHAR */  END; /* OF DO WHILE */END SCAN.HEX;ADJUST.NUM:  PROC(DECIMALS); /* SCALE INFO & DP TO DESIRED SCALE */  DCL DECIMALS FIXED;  DO WHILE DECIMALS<DP; INFO=INFO/10; DP=DP-1; END;  IF INFO<0 THEN CALL ER.NAL; /* NOT ALLOWED */  DO WHILE DECIMALS>DP;       /* ADD SOME */    IF (INFO>3000) THEN CALL ER.TMD; /* TOO BIG */    INFO=INFO*10;DP=DP+1;  END;END ADJUST.NUM;/* $SUBTITLE  Scan off starting times in absolute or rel, secs or frames */DCL (SECONDS,MILLISECONDS,MILLI.LSBS) FIXED;DCL (REL.SECS,REL.MILLS,REL.LSBS)     FIXED; /* FOR RELATIVE TIMES */DCL (FRAMES.PER.SECOND)               FIXED;SCAN.TIME:  PROC; /* SCAN OFF STARTING TIME INTO SECS, MILLISECS */  DCL (HOURS,MINUTES,SECS,FRAMES) FIXED;  DCL (FRACTION,FRACTION.FOUND)   FIXED;  DCL (I,J)                       FIXED;  HOURS=0; MINUTES=0; SECS=0; FRAMES=0; FRACTION=0;  FRACTION.FOUND=0;  IF NCHR=A.COLON THEN DO; /* COLON - SCAN OFF STARTING TIME IN frames */    SCAN.FRAME.#:; /* ENTER HERE FROM BELOW IF : FOUND */    DO WHILE NCHR=A.COLON; /* SCAN OFF EACH FIELD */      CALL GET.CHAR; /* SKIP OVER COLON */      CALL SCAN.AHEAD; /* SKIP TO NUMBER */      IF FRACTION.FOUND THEN CALL ER.FNE; /* NO DECIMALS EXC WITH FRAME */      IF HOURS<>0       THEN CALL ER.IFM; /* TOO MANY FIELDS */      HOURS=MINUTES; MINUTES=SECS; SECS=FRAMES;      FRAMES=SCAN.NUMBER; /* SCAN OFF FRAMES */      IF NCHR=A.PERIOD THEN DO; /* GET 1/10 FRAME */        CALL GET.CHAR;        IF (NCHR>=A.0) AND (NCHR<=A.9) THEN DO; /* SCAN OFF DIGIT */          FRACTION.FOUND=1;          FRACTION=NCHR-A.0;          CALL GET.CHAR;          IF (NCHR>=A.0) AND (NCHR<=A.9) THEN CALL ER.FNE;        END;      END; /* OF 1/10 FRAME */      CALL SCAN.AHEAD; /* LOOK FOR MORE COLONS */    END; /* OF DO WHILE */    WRITE(5)=HOURS; WRITE(6)=3600; /* 3600 SECONDS PER HOUR */    SECONDS=READ(5); IF READ(4)<>0 THEN CALL ER.OVF;    WRITE(5)=MINUTES; WRITE(6)=60; /* 60 SECONDS PER MINUTE */    IF READ(4)<>0 THEN CALL ER.OVF;    SECONDS=SECONDS+READ(5); IF SECONDS ILT READ(5) THEN CALL ER.OVF;    SECONDS=SECONDS+SECS; /* ADD IN SCANNED SECONDS */    IF SECONDS ILT SECS THEN CALL ER.OVF;    WRITE(5)=FRAMES; WRITE(6)=100; /* COMPUTE FRAMES * 100 (32 BIT) */    MILLISECONDS=READ(5); /* READ 5 TO AVOID BUG */    WRITE(7)=FRAMES.PER.SECOND; /* COMPUTE INTEGER # OF SECONDS */    SECONDS=SECONDS+READ(5); /* DIVIDE CAN'T OVERFLOW SINCE FPS >= 100 */    IF SECONDS ILT READ(5) THEN CALL ER.OVF;    I=READ(4); /* GET REMAINDER OF FRAME*100 */    WRITE(5)=I+FRACTION*10; /* ADD IN FRACTIONAL PART 0-9 */    WRITE(6)=1000; /* MULTIPLY BY 1000 TO COMPUTE MILLISECONDS */    MILLISECONDS=READ(5); /* TO AVOID HARDWRE BUG */    WRITE(7)=FRAMES.PER.SECOND; /* COMPUTE MILLISECONDS */    MILLISECONDS=READ(5);    MILLI.LSBS=READ(4); /* GET REMAINDER */    WRITE(5)=0; WRITE(4)=MILLI.LSBS; WRITE(7)=FRAMES.PER.SECOND;    MILLI.LSBS=READ(5); /* AND ANOTHER 16 BITS TO AVOID ACCUMULATED ERRS */    DO WHILE MILLISECONDS>=1000; /* AND MOVE CARRIES TO SECONDS */      SECONDS=SECONDS+1; MILLISECONDS=MILLISECONDS-1000;      IF SECONDS=0 THEN CALL ER.OVF;    END;    IF SECONDS IGT 30000 THEN CALL ER.OVF; /* PREVENT FUTURE OVERFLOW */  END; /* OF CASE FOR COLON */  /**/  /* SCAN OFF STARTING TIME IN SECONDS.MILLISECONDS */  ELSE DO; /* NUMERIC FORMAT */    IF NCHR=A.PERIOD THEN SECONDS=0; /* NO INTEGER PART */    ELSE               SECONDS=SCAN.NUMBER;    IF NCHR=A.COLON THEN DO; /* OOPS - FRAME# FORMAT */      FRAMES=SECONDS; /* STORE IN FRAMES */      GOTO SCAN.FRAME.#; /* SCAN OFF REST */    END;    IF NCHR<>A.PERIOD THEN DO; /* NO PERIOD - MILLISECONDS ARE 0 */      MILLISECONDS=0; MILLI.LSBS=0;    END;    ELSE DO; /* PERIOD */      CALL GET.CHAR; /* GET DIGIT */      I=0; J=0;      DO WHILE (J<3) AND (NCHR>=A.0) AND (NCHR<=A.9); /* SCAN OFF */        I=I*10+NCHR-A.0;        CALL GET.CHAR;        J=J+1;      END;      DO WHILE J<3; I=I*10; J=J+1; END;      IF (NCHR>=A.0) AND (NCHR<=A.9) THEN CALL ER.TMD; /* TOO MANY DIGITS */      MILLISECONDS=I;      MILLI.LSBS=0;    END; /* OF CASE FOR PERIOD */  END; /* OF CASE FOR NUMERIC FORMAT */END SCAN.TIME;/* THE STACK IS USED FOR ANY IMPORTANT PARAMETERS DURING ANY OF THE   RECURSIVE ROUTINES IN THE COMPILER.  THIS IS TRUE NOT ONLY FOR THE   RECURSIVE DESCENT SCANNING ROUTINES, BUT ALSO, FOR EXAMPLE, FOR THE   RECURSIVE EXPRESSION COMPILER.  */ DCL STACKPT FIXED; /* POINTER TO STACK */ PUSH:  PROC(INFO); /* PUSH A VALUE ONTO THE STACK */  DCL INFO FIXED;  IF STACKPT > STACKLEN THEN CALL ER.STK;  CORE(STACKLOC+STACKPT) = INFO;  STACKPT = STACKPT + 1;END PUSH; POP:  PROC; /* POP A VALUE FROM THE STACK */  STACKPT = STACKPT - 1;  RETURN CORE(STACKLOC+STACKPT);END POP;/* $SUBTITLE  Scanner -- Main Routine */ SCAN:  PROC; /* MAIN SCANNING ROUTINE */  DCL (POINT,BC) FIXED; /* POINTER AND BYTE TOGGLE FOR STRINGS */  DCL (I,J,K)    FIXED;  SCAN.START:; /* RETURN HERE */  IF (READ("51")&2)<>0 THEN DO; /* SEE IF CHAR TYPED */    I=READ("50")&"177";         /* GET CHARACTER */    IF I=C.S THEN DO WHILE I<>C.Q; I=READ("50")&"177"; END;    IF (I=0) THEN BROKEN=1; /* BREAK KEY HIT */    ELSE DO;      PRINT 'Compiling:   Line:   ',LINE.NO,;      IF CFNAME(0)>0 THEN PRINT ' in file ',STRING(CFNAME);      ELSE                PRINT;    END;  END;  IF BROKEN<>0 THEN DO;           /* BREAK RECEIVED */    DO I=0 TO 60; WRITE(3)=0; IF SYSTYP=0 THEN WRITE("104")=0; END; /* WAIT .3 SECOND FOR VT640 TERMINAL; KEEP DISKS GOING IF FLOPPY SYSTEM */    CALL EXIT(-1);   END;  IF SYSTYP=0 THEN WRITE("104")=0; /* KEEP THE MOTOR GOING ON FLOPPY */  NAME.PT=0; /* ASSUME INITIALLY THAT TOKEN IS NOT SYMBOL */     /* IGNORE WHAT SHOULD BE IGNORED */     IF SCAN.AHEAD THEN RETURN; /* SCAN AHEAD.  RETURN IF T.EOL EXPECTED */  IF NCHR=(-1) THEN DO; /* END OF FILE */    TOKEN=T.EOF; NCHR=0; /* SET END OF LINE TERMINATOR */    IF ISPT=0 THEN RETURN; /* REAL END OF FILE */    CALL POPFILE; /* ELSE GO BACK UP INSERT FILE */    GOTO SCAN.START;  END;  /* STRING CONSTANTS:  WHEN A STRING CONSTANT IS ENCOUNTERED,  IT IS STORED IN THE ARRAY CALLED  'NAME'.  THE CHARACTER INFORMATION IS WRITTEN OUT TO THE OBJECT FILE AT  A LATER TIME. */      IF NCHR=A.APOST THEN DO; /* START OF STRING CONSTANT */    LCHR=NCHR; NCHR=GC; /* SKIP OVER APO */    IF NCHR<>0 THEN DO; LCHR=NCHR; NCHR=GC; END; /* DO NOT BLOW UP ON SINGLE ' */    ELSE            CALL ER.MAP;    I=0; /* INITIALIZE COUNT */    POINT=1; /* START WORDS HERE */    DO WHILE ((LCHR=A.APOST)&(NCHR=A.APOST)) OR ((LCHR<>A.APOST)&(NCHR<>0));      IF (LCHR=A.LESS) THEN DO; /* < - GET CONTROL CHARACTER, < OR ' */        IF NCHR>=64 THEN LCHR=NCHR-64; ELSE LCHR=NCHR; /* SAVE < */        NCHR=GC; IF NCHR=A.GREATER THEN NCHR=GC; /* SKIP OVER EXPECTED > */      END;      IF (LCHR=A.APOST) & (NCHR=A.APOST) THEN DO; LCHR=NCHR; NCHR=GC; END; /* SEE WHAT THIS DOES */      IF I>=128 THEN DO; CALL ER.SCTL; I=0; POINT=1; END; /* TOO LONG */      IF I THEN DO; NAME(POINT)=NAME(POINT)\SHL(LCHR,8); POINT=POINT+1; END;      ELSE      NAME(POINT)=LCHR; /* CLEAR UPPER HALF */      I=I+1;      IF NCHR<>0 THEN DO; LCHR=NCHR; NCHR=GC; END; /* IN CASE EOL SHOULD OCCUR HERE */      ELSE            CALL ER.MAP; /* MISSING APOSTROPHE */    END; /* OF DO WHILE */    NAME(0)=I; /* NUMBER OF BYTES */    IF LCHR<>A.APOST THEN CALL ER.MAP; /* MISSING APOSTROPHE */    TOKEN=T.SCONST; /* TOKEN IS STRING CONSTANT */    RETURN; /* END OF STRING CONSTANT */  END; /* OF CASE FOR STRING CONSTANT */      /* CHECK FOR LEADING SYMBOL CHARACTER (OTHER THAN DIGIT) */     IF (NCHR>=A.A) AND (NCHR<=A.Z) THEN DO; /* SYMBOL */    POINT=0; BC=1; /* INITIALIZE POINTER INTO NAME, AND BYTE COUNTER */    DO WHILE (NCHR=A.PERIOD)\(NCHR=A.SHARP)\((NCHR>=A.0)&(NCHR<=A.9))\((NCHR>=A.A)&(NCHR<=A.Z));      IF POINT>60 THEN DO; CALL ER.SCTL; POINT=1; END; /* TOO LONG */      IF BC THEN DO; /* FIRST BYTE */         POINT=POINT+1; NAME(POINT)=NCHR;      END;      ELSE NAME(POINT)=NAME(POINT)\SHL(NCHR,8);      BC=BC+1; /* INCREMENT BYTE COUNTER */      CALL GET.CHAR; /* PASS ON TO NEXT CHARACTER */    END; /* OF DO WHILE */        /* $page */    NAME(0)=POINT; /* FILL IN LENGTH FIELD */    POINT=S.LOOKUP; /* LOOK THE SYMBOL UP IN THE SYMBOL TABLE */        IF POINT=0 THEN DO; /* UNDEFINED SYMBOL */      TOKEN=T.UND;      INFO =NAME.PT; /* RETURN POINTER HERE */      UFSP =NAME.PT; /* AND SAVE HERE ALSO */      UFSLN=LINE.NO; /* SAVE LINE NUMBER */      RETURN;    END; /* OF UNDEFINED SYMBOL */       TOKEN=GTOK(NAME.PT);      /* GET TOKEN TYPE FOR THIS SYMBOL */    INFO=CORE(STLOC+NAME.PT+2);       /* AND PICK UP INFO FROM STACK */        IF TOKEN=T.INSERT THEN DO; /* 'INSERT' - SCAN FILE NAME & CONTINUE */      CALL SCAN; /* CALL OURSELVES RECURSIVELY TO SCAN FILE NAME */      IF TOKEN<>T.SCONST THEN DO; /* FORMAT ERROR */        CALL ER.INS; /* FORMAT ERROR WITH INSERT */        GOTO SCAN.START; /* AND START AT TOP OF SCAN AGAIN */      END;      CALL PUSHFILE; /* OPEN NEW FILE */      GOTO SCAN.START; /* AND SCAN OFF ITS FIRST TOKEN */    END; /* OF CASE FOR INSERT */    IF TOKEN<>T.EOF THEN RETURN; /* RETURN DIRECTLY WITH THAT */    IF ISPT=0 THEN RETURN; /* IF EOF OF ORIGINAL SOURCE THEN RETURN */    CALL POPFILE; /* GO BACK UP ONE FILE */    GOTO SCAN.START; /* AND RETRY */  END; /* OF SYMBOL SCAN */     /* SCAN DIGIT */  IF NCHR=A.PLUS THEN DO; /* PLUS SIGN - INDICATES RELATIVE START TIME */    CALL GET.CHAR; /* SKIP THE + */    DO WHILE NCHR=A.SP; CALL GET.CHAR; END; /* SKIP SPACES HERE */    IF (NCHR<>A.PERIOD) AND (NCHR<>A.COLON) AND ((NCHR<A.0)\(NCHR>A.9)) THEN CALL ER.IFM;    CALL SCAN.TIME;    SECONDS=SECONDS+REL.SECS;    IF SECONDS ILT REL.SECS THEN CALL ER.OVF; /* OVERFLOW */    MILLISECONDS=MILLISECONDS+REL.MILLS;    MILLI.LSBS=MILLI.LSBS+REL.LSBS;    IF MILLI.LSBS ILT REL.LSBS THEN MILLISECONDS=MILLISECONDS+1;    IF MILLISECONDS>=1000 THEN DO; /* CARRY TO SECONDS */      MILLISECONDS=MILLISECONDS-1000; SECONDS=SECONDS+1;      IF SECONDS=0 THEN CALL ER.OVF;    END;    TOKEN=T.TIME;    IF SECONDS IGT 30000 THEN CALL ER.OVF;    RETURN;  END; /* OF CASE FOR PLUS SIGN */  IF (NCHR=A.COLON) OR (NCHR=A.PERIOD) OR ((NCHR>=A.0)&(NCHR<=A.9)) THEN DO; /* NUMERIC */    CALL SCAN.TIME; /* SCAN OFF STARTING TIME */    TOKEN=T.TIME;    RETURN;  END;  IF NCHR=A.COMMA THEN DO; /* CHECK FOR COMMA */    CALL GET.CHAR; /* SCAN OFF COMMA */    TOKEN=T.COMMA;    RETURN;  END;     CALL ER.ILC; /* ILLEGAL CHARACTER -- PRINT ERROR */  CALL GET.CHAR; /* BY-PASS ILLEGAL CHARACTER */  GOTO SCAN.START; /* AND IGNORE IT */   END SCAN;