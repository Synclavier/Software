/* $subtitle Defs, I/O Primitives, and Symbol Table *//* $D  ASK FOR DUMP */PDL 512; /* DEFINE 512 WORD PDL */  /* POINTERS FOR STORAGE AREAS: */DCL (PDL_BOTTOM)        FIXED; /* LOWER LIMIT OF MODEL D PDL */DCL (STLOC,STSIZ)       FIXED; /* LOC & SIZ OF SYM TAB */DCL (SFLOC,SFBUFL)      FIXED; /* LOC & SIZ OF SFILE BUFFER */DCL (STACKLOC,STACKLEN) FIXED; /* LOC & SIZ OF STACK */DCL (TIMBLOC,TIMBLEN)   FIXED; /* LOC & SIZ OF TIMBRE STORAGE AREA */DCL (SEQNLOC,SEQNLEN)   FIXED; /* LOC & SIZ OF NOTE   STORAGE AREA */DCL (TIMBMAX,SEQNMAX)   FIXED; /* MAX ALLOCATED LENGTHS FOR SEQN & TIMB AREAS */DCL (DEFLOC,DEFLEN)     FIXED; /* POINTERS FOR PARTIAL & MOTIF DEFS */DCL (DEFMAX)            FIXED;DCL (DEFAVAIL)          FIXED; /* RELEASE SECTIONS OF DEFLOC - MAY BE USED FOR SEQUENCER NOTES IN A PINCH */DCL SFDEVICE            FIXED; /* SOURCE FILE DEVICE */DCL (SFSTART,SFSLEN)    FIXED; /* SOURCE FILE INFO */DCL (SFREM)             FIXED; /* WORDS IN LAST SECTOR */DCL CFDEVICE            FIXED; /* CURRENT FILE DEVICE */DCL (CFSTART,CFLNGTH)   FIXED; /* CURRENT FILE INFO */DCL (CFSLEN)            FIXED;DCL ABORT               FIXED; /* SET TO 1 IF ERROR ENCOUNTERED */  DCL HASHSIZE            LIT '63'; /* HASH TABLE SIZE */DCL NAME(64)            FIXED; /* HOLDS CURRENT SYMBOL/STRING CONSTANT */DCL HASHTAB(HASHSIZE)   FIXED; /* AND THIS IS HASH TABLE START */DCL LINE.NO             FIXED; /* HOLDS LINE NUMBER */DCL CFNAME(F#NAME_LEN)  FIXED; /* NAME OF CURRENT FILE *//* PROGRAM INITIALIZATION:..   LOOK UP MEMORY SIZE (ETC.) PASSED FROM MONITOR,  THEN COMPUTE.   OUR TABLE SIZES. CHECK FOR EXTERNAL MEMORY */  DCL STPTR FIXED; /* SYMBOL TABLE POINTER & INITIALIZATION VARIABLE */  IF MEM.SIZ ILT (40*1024) THEN DO; /* 40K MEMORY REQUIRED */   PRINT;   PRINT 'At least 40K memory required for Script.';   CALL EXIT(-1);END;/* GET SYMBOL TABLE FILE INFO (LENGTH IN SECTORS */SFDEVICE=CORE(LOC.ST+1);           SFSTART=CORE(LOC.ST); SFSLEN  =SHR(CORE(LOC.ST-1)+255,8);SFREM  =CORE(LOC.ST-1);/* GET CURRENT FILE INFO */CFDEVICE=CORE(LOC.CSEC+1); CFSTART=CORE(LOC.CSEC);CFLNGTH =CORE(LOC.CLEN  ); CFSLEN =CORE(LOC.CSLN); /* LENGTH */  /* $SUBTITLE - MEMORY ORGANIZATION FOR SCRIPT COMPILER: *//* 6 SEPARATE STORAGE AREAS ARE USED BY THIS SCRIPT COMPILER.  THEY ARE:..      1. PUSH DOWN STACK - STARTS AT 'STACKLOC' FOR 'STACKLEN' WORDS..                           USED FOR ALL SORTS OF TEMPORARY STORAGE DURING.                           COMPILATION.  P & R LINES ARE TEMPORARILY STORED ON .                           THE STACK,  AS WELL AS MOTIF INVOCATIONS..      2. SOURCE BUFFER   - STARTS AT 'SFLOC' FOR 'SFBUFL' WORDS..                           DISK READING BUFFER TO READ THROUGH SOURCE FILE.                           DURING COMPILATION.      3. SYMBOL TABLE    - STARTS AT 'STLOC' FOR 'STSIZ' WORDS..                           SYMBOLS (MOTIF DEFINITIONS, PARTIAL NAMES, RESERVED.                           WORDS) ARE STORED IN SYMBOL TABLE..      4. TIMBRE INFO     - STARTS AT 'TIMBLOC' FOR 'TIMBLEN' WORDS..                           SCRIPT TIMBRES ARE BUILT UP IN THIS AREA..                           'TIMBMAX' WORDS HAVE BEEN ALLOCATED FOR THIS AREA.      5. SEQUENCER NOTES - STARTS AT 'SEQNLOC' FOR 'SEQNLEN' WORDS..                           NOTELISTS ARE CONSTRUCTED IN THIS AREA..                           'SEQNMAX' WORDS HAVE BEEN ALLOCATED FOR THIS.                           AREA..      6. DEFINITION AREA - PARTIAL TIMBRE DEFINITIONS & MOTIF DEFINITIONS.                           AREA STORED IN A VARIABLE LENGTH AREA IN.                           UPPER MEMORY.  THIS AREA OVERLAPS WITH THE.                           SEQUENCER NOTE AREA AT TIMES...NOTE - THE TIMBRE STORAGE AREA IS INCREASED AS REQUIRED DURING COMPILATION.BY MOVING THE SEQUENCER NOTES UP IN MEMORY AND INCREASING 'TIMBMAX'...NOTE - DEFINED PARTIALS (AS OPPOSED TO 'USING' TIMBRES) ARE STORED IN.THE DEFLOC AREA UNTIL THEY ARE FIRST USED IN.A NOTELIST, AT WHICH POINT THEY ARE COPIED DOWN INTO THE TIMBRE.AREA.  THIS ASSURES THAT THE TIMBRES IN THE TIMBRE AREA ARE IN.TRACK ORDER, REGARDLESS OF THE ORDER OF TIMBRE DEFINITION..NOTE - THE TIMBLOC, SEQNLOC, AND DEFLOC AREAS ARE IN EXTERNAL MEMORY.       (IF ANY).NOTE - DEFINED MOTIFS ARE ALSO STORED IN THE DEF AREA. */EXAMOUNT=CORE(LOC.EMSIZE);                     /* CHECK FOR EXTERNAL MEMORY */IF EXAMOUNT=0 THEN DO;                         /* INTERNAL MEMORY */	PDL_BOTTOM = CORE(CORE(1))+CORE(CORE(1)+1); /* START OF VARIABLE AREA + LENGTH OF VARIABLE AREA = BOTTOM STACK */	STACKLOC   = PDL_BOTTOM + 512;              /* VSTART+VLENGTH+PDL=START OF STACK */   STACKLEN=4096;                              /* USE A 4K STACK FOR NOW */   SFLOC=STACKLOC+STACKLEN;                    /* SOURCE FILE BUFFER */   SFBUFL=1024;                                /* USE A 1K SOURCE FILE BUFFER */   STLOC=SFLOC+SFBUFL;                         /* START OF SYMBOL TABLE */   STSIZ=4*1024-256;                           /* USE 4K-256 FOR SYMBOL TABLE */   TIMBLOC=STLOC+STSIZ+256;                    /* STORE TIMBRES HERE - ALLOW EXTRA 256 WORDS FOR SYMBOL TABLE TO ACCOUNT FOR NAME STORAGE */   TIMBMAX=1024;                               /* ALLOW 1024 WORDS FOR TIMBRE - SEQUENCER NOTES MOVED UP IF MORE NEEDED */   SEQNLOC=TIMBLOC+TIMBMAX;                    /* BUILD UP NOTES HERE */   SEQNMAX=LOC.LOAD-SEQNLOC;                   /* MAX LENGTH FOR NOTES */   DEFLOC=LOC.LOAD;                            /* DEFINITIONS WILL START HERE (NONE YET) - MOVES DOWN IN MEMORY */END;ELSE DO;                                       /* EXTERNAL MEMORY */	PDL_BOTTOM = CORE(CORE(1))+CORE(CORE(1)+1); /* START OF VARIABLE AREA + LENGTH OF VARIABLE AREA = BOTTOM STACK */	STACKLOC   = PDL_BOTTOM + 512;              /* VSTART+VLENGTH+PDL=START OF STACK */   STPTR=LOC.LOAD-STACKLOC-1024;               /* GET TOTAL WORDS OF STORAGE, LESS SF BUFFER */   STACKLEN=SHR(STPTR,1); STSIZ=STACKLEN-256;  /* DIVIDE INTO STACK & SYMBOL TABLE AREAS */   IF STSIZ IGT 8192-256 THEN DO;              /* BUT LIMIT SYMBOL TABLE TO 8K */      STSIZ=8192-256;      STACKLEN=STPTR-STSIZ-256;      IF STACKLEN IGT 30000 THEN STACKLEN=30000; /* LIMIT TO ELIMINATE OVERFLOW PROBLEMS */   END;   STACKLEN=STACKLEN&"177400";   SFLOC=STACKLOC+STACKLEN;                    /* SOURCE FILE BUFFER */   SFBUFL=1024;                                /* USE A 1K SOURCE FILE BUFFER */   STLOC=SFLOC+SFBUFL;                         /* START OF SYMBOL TABLE */   STSIZ=STSIZ&"177400";   TIMBLOC=0;                                  /* START TIMBRES AT LOC 0 OF EXTERNAL MEMORY */   TIMBMAX=4096;                               /* INITIALIZE TO 4096 WORDS FOR TIMBRE - SEQUENCER NOTES MOVED UP IF MORE NEEDED */   SEQNLOC=TIMBLOC+SHR(TIMBMAX,8);             /* BUILD UP NOTES HERE */   IF (EXAMOUNT-SEQNLOC) ILT 256   THEN SEQNMAX=SHL(EXAMOUNT-SEQNLOC,8);       /* REST FOR SEQUENCE */   ELSE SEQNMAX="177400";                      /* MAX LENGTH FOR NOTES (FOR NOW) */   DEFLOC=EXAMOUNT;                            /* DEFINITIONS WILL START HERE (NONE YET) - MOVES DOWN IN MEMORY */END;DO STPTR=0 TO STSIZ-1;  CORE(STLOC+STPTR)=0; END; /* ZERO OUT SYMBOL TABLE & BUFFER */DO STPTR=0 TO SFBUFL-1; CORE(SFLOC+STPTR)=0; END;STPTR=1; /* INITIALIZE POINTER *//* $SUBTITLE  Define Special Overlay, Exit, and Diskio Routines */OVERLAY:  PROC(DEVICE,START,LEN); /* PERFORM OVERLAY OF DISK OBJECT */   DCL (DEVICE,START,LEN,I) FIXED;   I=LOC.LOAD+1; /* ENTER WORD 1 OF LOADER MEMORY */   WRITE("300")=DEVICE; /* DEVICE */   WRITE("301")=START;  /* START  */   WRITE("302")=0;      /* DEST   */   WRITE("303")=LEN;    /* LENGTH */   WRITE("320")=I; /* ENTER ROM COPY ROUTINE */END OVERLAY;  EXIT:  PROC(STA); /* AND PSEUDO ROUTINE 'EXIT' */   DCL STA FIXED;   CORE(LOC.RST)=STA; /* SAVE STATUS FOR SED */   PRINT;   CALL OVERLAY(CORE(LOC.MON+1),CORE(LOC.MON),CORE(LOC.MON-1)); /* OVERLAY BACK TO MONITOR */END EXIT;  IF CORE(LOC.CMED)=1 THEN DO;   PRINT 'System Error with Current File.   Compilation Aborted.';   CALL EXIT(-1);END;/* $SUBTITLE  Routines to print error messages */  DCL TOKEN      FIXED; /* HOLDS CURRENT TOKEN TYPE */DCL UFSP       FIXED; /* POINTER TO UNDEFINED SYMBOL */DCL UFSLN      FIXED; /* LINE NUMBER OF UNDEFINED SYMBOL */DCL NAME.PT    FIXED; /* POINTER TO SYMBOL TABLE */DCL NUMERRS    FIXED; /* NUMBER OF ERRORS FOUND */DCL BROKEN     FIXED; /* SET TRUE ON BREAK RECEIVED */DCL ERSYMB(16) FIXED; /* HOLDS SYMBOL FOR ERROR MESSAGE */  WHEN BREAK THEN BROKEN=1; /* STOP UPON BREAK WHILE PRINTING */ER.COUNT:  PROC; /* FINISH PRINT OF ERROR MESSAGE AND BUMP ERROR COUNT */  PRINT ' at line',LINE.NO,;  IF CFNAME(0)>0  THEN PRINT ' in file ',STRING(CFNAME);  ELSE PRINT;  NUMERRS=NUMERRS+1; /* COUNT ERRORS */  IF NUMERRS=10 THEN CALL EXIT(-1); /* ABORT AFTER 10 ERORRS */END ER.COUNT;ER.SYMB:  PROC(PTR); /* SELECT A ERSYMB FROM TABLE AND PUT IN 'ERSYMB' */  DCL (PTR,I) FIXED;  I=CORE(STLOC+PTR+1)&255; /* GET NUMBER OF WORDS IN SYMBOL */  IF I>16 THEN I=16; /* AND LIMIT FOR ERSYMB */  ERSYMB(0)=SHL(I,1); /* AND NUMBER OF BYTES TO PRINT */  DO I=1 TO I; ERSYMB(I)=CORE(STLOC+PTR+2+I); END;END ER.SYMB;  ER.EMES1:  PROCEDURE(STR,PTR); /* PRINT ERROR MSG FOR UNDEF/DUPL SYMB */  DCL STR  ARRAY;  DCL PTR  FIXED; /* PTR TO ARRAY */  DCL PPTR FIXED; /* AND ONLY ONCE PER MESSAGE */  IF PPTR=PTR THEN RETURN; /* HAVE ALREADY PRINTED THIS ONE */  PPTR=PTR; /* THIS IS LATEST ONE PRINTED */  CALL ER.SYMB(PTR); /* EXTRACT ERSYMB INTO 'ERSYMB' */  PRINT STRING(STR),' "',STRING(ERSYMB),'"',;  CALL ER.COUNT; /* FINISH MSG AND BUMP NUMBER OF ERRS */END ER.EMES1;  ER.UFLS:  PROC(PTR); /* UNDEFINED LABEL/ERSYMB MESSAGE */  DCL PTR FIXED;  CALL ER.EMES1('Undefined symbol',PTR);END ER.UFLS;  ER.LT:  PROC(PTR); /* DUPLICATE - DEFINED TWICE */  DCL PTR FIXED;  CALL ER.EMES1('Duplicate definition for',PTR);END ER.LT;  ER.EMES2:  PROCEDURE(STR); /* PRINT ERROR MESSAGE STRING */  DCL STR         ARRAY;  DCL (PLINENO,I) FIXED;  IF TOKEN=T.UND THEN DO; /* UNDEFINED SYMBOL */    I=LINE.NO; LINE.NO=UFSLN; CALL ER.UFLS(UFSP); LINE.NO=I;  END;  IF PLINENO=LINE.NO THEN RETURN; /* ONE PER LINE */  PLINENO=LINE.NO; /* SAVE - ONLY ONE USELESS MESSAGE PER LINE */  PRINT STRING(STR),;  CALL ER.COUNT; /* FINISH PRINT AND BUMP ERROR COUNT */END ER.EMES2;    ER.MEL:  PROC(T);   DCL T FIXED;   PRINT 'Missing ENDLOOP in Track',t;   NUMERRS=NUMERRS+1; /* COUNT ERRORS */END ER.MEL;/* $SUBTITLE  Script Error Messages */  ER.NST:  PROC;CALL ER.EMES2('Program too large for symbol table');CALL EXIT(-1);END;ER.STK:  PROC;CALL ER.EMES2('Line too complicated for Compiler Stack');CALL EXIT(-1);END;ER.TMB:  PROC;CALL ER.EMES2('Too many nested timbre definitions');CALL EXIT(-1);END;ER.ORT:  PROC;CALL ER.EMES2('Out of room for Definition');CALL EXIT(-1);END;ER.SLA:  PROC;CALL ER.EMES2('Format Error (Slash not allowed)');END;ER.NTC:  PROC;CALL ER.EMES2('Non-terminated comment');END;ER.MAP:  PROC;CALL ER.EMES2('Missing Apostrophe or Format Error');END;ER.ILC:  PROC;CALL ER.EMES2('Illegal Character or Punctuation');END;ER.IFN:  PROC;CALL ER.EMES2('Incorrect format in number');END;ER.TMD:  PROC;CALL ER.EMES2('Number Too Large');END;ER.EDP:  PROC;CALL ER.EMES2('Extraneous Decimal Point or Period');END;ER.UNS:  PROC;CALL ER.EMES2('Unrecognized Statement');END;ER.IFM:  PROC;CALL ER.EMES2('Incorrect Format');END;ER.IFD:  PROC;CALL ER.EMES2('Incorrect format in definition');END;ER.TMA:  PROC;CALL ER.EMES2('Too many arguments for sub-field');END;ER.NEA:  PROC;CALL ER.EMES2('Not enough arguments for sub-field');END;ER.MVW:  PROC;CALL ER.EMES2('Missing or Incorrect Vibrato Wave Shape Specified');END;ER.MPS:  PROC;CALL ER.EMES2('Missing or Incorrect Portamento Shape Specified');END;ER.MEI:  PROC;CALL ER.EMES2('Missing END statement or Incorrect Sub-Field Format');END;ER.ELD:  PROC;CALL ER.EMES2('End label does not match of is missing');END;ER.MPT:  PROC;CALL ER.EMES2('Missing Partial list in Timbre Definition');END;ER.TMP:  PROC;CALL ER.EMES2('Too many partials listed in Timbre Definition');END;ER.NVP:  PROC;CALL ER.EMES2('Unrecognized Partial Name in Timbre Definition');END;ER.RTP:  PROC;CALL ER.EMES2('Must specify Partials after ''RTE''');END;ER.RTF:  PROC;CALL ER.EMES2('Unrecognized RTE Parameter');END;ER.MTS:  PROC;CALL ER.EMES2('Missing or Unrecognized Timbre Name');END;ER.UNM:  PROC;CALL ER.EMES2('Missing, Unrecognized or Undefined MOTIF Name');END;ER.NAL:  PROC;CALL ER.EMES2('Negative Number not allowed for argument');END;ER.MPI:  PROC;CALL ER.EMES2('Missing or unrecognized pitch');END;ER.MLS:  PROC;CALL ER.EMES2('Missing length information');END;ER.INS:  PROC;CALL ER.EMES2('Incorrect format after "INSERT"');END;ER.NL1:  PROC;CALL ER.EMES2('Starting time out of order in notelist');END;ER.NL2:  PROC;CALL ER.EMES2('Starting time error or incorrect delay overlap');END;ER.NL3:  PROC;CALL ER.EMES2('Starting time error or smoothing to extreme for note');END;ER.TMT:  PROC;CALL ER.EMES2('Too many notelists (Only 200 allowed)');END;ER.TIM:  PROC;CALL ER.EMES2('Can not find TIMBRE FILE.  "USING" Feature not available');CALL EXIT(-1);END;ER.MKI:  PROC;CALL ER.EMES2('Missing or incorrect key signature');END;ER.MRI:  PROC;CALL ER.EMES2('Missing or incorrect Rhythm or Tempo');END;ER.TTS:  PROC;CALL ER.EMES2('Tempo too slow for computation');END;ER.MRL:  PROC;CALL ER.EMES2('Rhythm line required after pitch line');END;ER.MPL:  PROC;CALL ER.EMES2('Missing Pitch Line in MOTIF definition');END;ER.MMR:  PROC;CALL ER.EMES2('Rhythm line does not match pitch line');END;ER.MMA:  PROC;CALL ER.EMES2('Articulation, Volume, or Timbre line does not match Pitch Line');END;ER.MBB:  PROC;CALL ER.EMES2('Missing or extra bracket or brace');END;ER.SNA:  PROC;CALL ER.EMES2('Statement not allowed outside notelist');END;ER.EXL:  PROC;CALL ER.EMES2('Second A, T, or V line not allowed');END;ER.OVF:  PROC;CALL ER.EMES2('Numeric overflow in time computation');END;ER.UOP:  PROC;CALL ER.EMES2('Unrecognized operation specified in PERFORM');END;ER.POR:  PROC;CALL ER.EMES2('Pitch went out of range during inversion or transposition');end;ER.TPM:  PROC;CALL ER.EMES2('Transpose pitch must be enclosed in parentheses');END;ER.FNE:  PROC;CALL ER.EMES2('Incorrect frame number');END;ER.TMSC: PROC;CALL ER.EMES2('Too many numbers in list');END;ER.SCTL: PROC;CALL ER.EMES2('File name too long');END;ER.TFSC: PROC;CALL ER.EMES2('Not enough numbers in list');END;ER.PHBR: PROC;CALL ER.EMES2('Phrasing not allowed with bracketed notes');END;ER.MTMP: PROC;CALL ER.EMES2('Missing or Mismatched parentheses');END;ER.SYN1: PROC;CALL ER.EMES2('Synchronization not allowed after notelist statement');END;ER.SYN2: PROC;CALL ER.EMES2('Synchronization point out of order');END;ER.SYN3: PROC;CALL ER.EMES2('Not enough delay to permit synchronization');END;ER.SYN4: PROC;CALL ER.EMES2('Tempo to extreme for smooth synchronization');END;ER.SYN5: PROC;CALL ER.EMES2('Too many Sync Points for Memory');end;ER.SYN6: PROC;CALL ER.EMES2('Numeric Overflow during synchronization computation');END;ER.SYN7: PROC;CALL ER.EMES2('Tempo statement not allowed after beat synchronization');END;ER.SYN8: PROC;CALL ER.EMES2('Tempo statement not allowed after an "AT" statement');END;ER.SYN9: PROC;CALL ER.EMES2('"AT" Statement not allowed after notelist start');END;ER.SYN10:PROC;CALL ER.EMES2('Too many "AT" statements for compiler storage');END;ER.SYN11:PROC;CALL ER.EMES2('"AT" Statement not allowed with Computer Music Format'); end;ER.SYN12:PROC;CALL ER.EMES2('"AT" Statement not allowed with Independent Loops'); end;ER.IBN:  PROC;CALL ER.EMES2('Incorrect beat number (zero is not allowed)');END;ER.BNOO: PROC;CALL ER.EMES2('"AT" statement out of order');END;ER.SFM:  PROC;CALL ER.EMES2('SFM Timbre Definition not allowed');END;ER.SFX:  PROC;CALL ER.EMES2('Must use SFM Timbre Definition');END;ER.TTL:  PROC;CALL ER.EMES2('Timbre Definition too long');END;ER.TMF:  PROC;CALL ER.EMES2('Too many files in Timbre Definition');END;ER.EDI:  PROC;CALL ER.EMES2('Notelists Invalid after Edit Information'); END;ER.ASOR: PROC;CALL ER.EMES2('Error in Active String List');END;ER.TOO:  PROC;CALL ER.EMES2('Track out of order');END;ER.RELM: PROC;CALL ER.EMES2('Statement is only available in Release M');END;ER.RELL: PROC;CALL ER.EMES2('Statement is not available in Release M');END;/* $SUBTITLE  Symbol Table Storage Definitions */  /*  THE SYMBOL TABLE FORMS THE HEART OF PASS1 OF THE COMPILER.  A SINGLE    16-BIT TABLE IS USED.   THE TABLE IS USED AT BOTH ENDS (ONE GOING UP,    THE OTHER GOING DOWN) SO THAT WHEN IT DOES RUN OUT OF STORAGE, THERE    IS ABSOLUTELY NONE LEFT.      ******** DESCRIPTION OF SYMBOL TABLE ENTIRES *********      TWO FIXED POINT ARRAYS ARE USED FOR SYMBOL PROCESSING:       HASHTABLE, AND STABLE.  THE STABLE ARRAY IS ALLOCATED IN UPPER MEMORY.      ASSUME THE EXISTENCE OF A SYMBOL 'XYZ'.   A SIX-BIT HASH TABLE POINTER    IS COMPUTED FROM THE ASCII VALUES OF THE SYMBOL CHARACTERS.   THIS    POINTER IS USED AS AN INDEX INTO THE ARRAY 'HASHTABLE'.   THE CONTENTS    OF HASHTABLE(POINTER) IS A POINTER IN THE STABLE ARRAY.      THE STABLE ARRAY CONSISTS OF TWO PARTS - A LOWER SECTION GROWING UP,  AND AN    UPPER SECTION GROWING DOWN.   THE LOWER SECTION IS THE MAIN SECTION.      THE LOWER SECTION OF THE SYMBOL TABLE CONTAINS RECORDS.  THERE ARE    TWO TYPES OF RECORDS:  SYMBOL TABLE ENTRIES,  AND LITERAL STRINGS.      FOR EACH SYMBOL, THERE IS A SYMBOL TABLE ENTRY RECORD IN STABLE.    THIS RECORD LOOKS LIKE:        WORD 0:  3 BIT SYMBOL DEPTH FIELD,  13-BIT FORWARD POINTER TO                NEXT BUCKET ON THIS HASH LINKED LIST.      WORD 1:  LOWER HALF CONTAINS THE NUMBER OF 16-BIT WORDS IN CHARACTER               FIELD OF SYMBOL (IE (NUMBER OF CHARACTERS IN               SYMBOL PLUS ONE) DIVIDED BY 2).               UPPER HALF CONTAINS THE TOKEN TYPE OF THE SYMBO.       WORD 2:  16-BIT INFORMATION REGARDING SYMBOL (EITHER A               POINTER INTO THE VARIABLE AREA, OR ETC.)      WORDS 3 AND ON: HOLD THE ASCII CHARACTERS, PACKED TWO TO A WORD.  THE FOLLOWING VARIABLES ARE USED TO PROCESS SYMBOLS: */  DCL (S.DEPTH,S.DEPTH1) FIXED; /* HOLDS LEVEL INFORMATION */DCL S.DEPTH.MAX        LIT '7';           /* SEVEN LEVELS OF LOCALISATION */DCL (S.NL.STAK,S.SL.STAK) (S.DEPTH.MAX) FIXED; /* HOLDS RECURSIVE INFO */DCL S.STRIDE           LIT '8192';        /* STRIDE DEPTH IN TABLE */DCL S.PMASK            LIT '(S.STRIDE-1)'; /* MASK FIELD FOR ABOVE */DCL SMASK              LIT '(-S.STRIDE)'; /* MASK FOR DEPTH FIELD */DCL HASHCODE           FIXED; /* HOLDS COMPUTED HASH INFORMATION */ S.CHECK:  PROC(POINTER); /* CHECK IF SYMBOL IN 'NAME' IS IN DESIGNATED SPOT IN S.NAMES */  DCL (POINTER,I,J) FIXED;  I=CORE(STLOC+POINTER+1)&255; /* EXTRACT LENTH */  IF I<>NAME(0) THEN RETURN 0; /* LENGTH IS NOT THE SAME */  DO J=1 TO I; /* AND COMPARE */    IF NAME(J)<>CORE(STLOC+POINTER+2+J) THEN RETURN 0; /* NOTE EQUAL */  END;  RETURN 1; /* FOUND */END S.CHECK;  /* AND TWO ROUTINES TO STORE/GET TOKEN FIELD FROM RECORD (FOR CONVENIENCE) */  GTOK:  PROC(P); /* GET TOKEN, PASS POINTER */  DCL P FIXED;  RETURN SHR(CORE(STLOC+P+1),8);END GTOK;  PTOK:  PROC(P,TOKEN); /* STORE TOKEN; PASS POINTER, TOKEN */  DCL (P,TOKEN) FIXED;  CORE(STLOC+P+1)=(CORE(STLOC+P+1)&255)\SHL(TOKEN,8);END PTOK; /* $SUBTITLE  Symbol Table Management -- Symbol Look-up and Definition */ /* S.LOOKUP:     THIS PROCEDURE IS USED TO LOOK UP A SYMBOL IN THE TABLE.  UPON ENTRY,     THE SYMBOL IS STORED IN THE GLOBAL VARIABLE 'NAME'.  THE ROUTINE     RETURNS A POINTER TO THE SYMBOL OR A ZERO IN THE CASE OF A NEW SYMBOL */ S.LOOKUP:  PROC; /* LOOKUP SYMBOL */  DCL I FIXED;  HASHCODE = NAME(0)+SHL(NAME(1),2)+SHL(NAME(NAME(0)),4); /* HASH FUNCTION */  HASHCODE = HASHCODE & HASHSIZE; /* HASHING FUNCTION */  NAME.PT  = HASHTAB(HASHCODE) & S.PMASK; /* GET POINTER INTO STABLE */  DO WHILE NAME.PT<>0; /* AND SCAN EVERY SYMBOL THAT EXISTS ON THIS LINK */    IF S.CHECK(NAME.PT)<>0 THEN RETURN NAME.PT; /* FOUND - RETURN POINTER */    NAME.PT = CORE(STLOC+NAME.PT) & S.PMASK; /* EXTRACT NEXT POINTER */  END;   NAME.PT=STPTR; /* NEW SYMBOL - STORE CHARACTERS IN TABLE HERE SO 'NAME' IS FREE */  STPTR=STPTR+NAME(0)+3; /* 3 WORDS OF INFO + NUMBER OF WORDS */  IF STPTR>(STSIZ-1) THEN CALL ER.NST; /* CHECK FOR OVERFLOW */  CORE(STLOC+NAME.PT)  =-1; /* INDICATE A NEW SYMBOL HERE */  CORE(STLOC+NAME.PT+1)=NAME(0); /* SAVE LENGTH FIELD */  DO I=1 TO NAME(0); /* COPY CHARACTER INFO INTO TABLE, BECAUSE NAME GETS USED OFTEN */    CORE(STLOC+NAME.PT+2+I)=NAME(I);  END;  RETURN 0; /* INDICATES A NEW SYMBOL */END S.LOOKUP; /* THE S.DEFINE ROUTINE IS USED TO ENTER A SYMBOL ENTRY INTO THE SYMBOL   TABLE.   MULTI-LEVEL VARIABLE LOCALIZATION IS INCORPORATED.     S.DEFINE IS PASSED TO VARIABLES, A POINTER INTO THE SYMBOL TABLE   (NAME.PT) AND A HASH TABLE POINTER.      S.DEFINE RETURNS A VALUE THAT IS A POINTER INTO STABLE.  NOTE THAT   THE NAME.PT RETURNED BY S.DEFINE MIGHT BE DIFFERENT THAN THE NAME.PT   PASSED TO S.DEFINE, IN THE CASE OF A LOCALIZED RE-DEFINITION OF A VAR. */  S.DEFINE:  PROC(NAME.PT,HASHCODE); /* PASS SYMBOL TABLE PTR, HASH TABLE PTR */  DCL (NAME.PT,HASHCODE) FIXED;  DCL (I,J,K)            FIXED;  I=HASHTAB(HASHCODE); /* GET DEPTH & FORWARD PTR FOR THIS BUCKET */  DO WHILE ((I&SMASK)=S.DEPTH) AND (I<>0); /* DETECT END OF LIST */    I=I&S.PMASK; /* EXTRACT FORWARD POINTER */    IF I=NAME.PT THEN RETURN I; /* USE THIS AS POINTER - DEFINED ON THIS LEVEL */    I=CORE(STLOC+I); /* AND GET FORWARD POINTER */  END;    /* NEW SYMBOL, AT LEAST ON THIS LEVEL */    IF CORE(STLOC+NAME.PT)<>-1 THEN DO; /* IF DEFINED ON EARLIER LEVEL, MUST DUPLICATE ASCII */    I=NAME.PT; /* SAVE CURRENT POINTER */    NAME.PT=STPTR; /* AND POINTER TO CURRENT END */    J=CORE(STLOC+I+1)&255; /* EXTRACT LENGTH OF RECORD */    STPTR=STPTR+3+J; /* INCREMENT POINTER */    IF STPTR>(STSIZ-1) THEN CALL ER.NST; /* CHECK FOR OVERFLOW */    DO K=3 TO J+2; CORE(STLOC+NAME.PT+K)=CORE(STLOC+I+K); END; /* COPY OVER ASCII INFO */    CORE(STLOC+NAME.PT+1)=J; /* SAVE LENGTH,  WITH A ZERO TOKEN FIELD */  END;  CORE(STLOC+NAME.PT)=HASHTAB(HASHCODE); /* PICK UP NEXT GUY'S DEPTH AND POINTER TO HIM */  CALL PTOK(NAME.PT,T.UND); /* INDICATE UNDEFINED */  HASHTAB(HASHCODE)=S.DEPTH+NAME.PT; /* STORE DEPTH + FORWARD PTR IN HASH TABLE */  RETURN NAME.PT;END S.DEFINE;/* $SUBTITLE  Symbol Table Management -- Localize and Globalize Routines */ /* S.BLOCK PROCEDURE:     S.BLOCK IS CALLED AT THE BEGINNING OF A VARIABLE LOCALIZATION   EVENT (SUCH AS THE START OF A PROCEDURE DEFINITION).  THE   ROUTINE PUSHES THE CURRENT SYMBOL TABLE POINTERS ONTO AN   INTERNAL STACK, AND THEN INCREMENTS THE 'DEPTH' FIELD. */ S.BLOCK:  PROC; /* PROCESS START OF BLOCK */  S.NL.STAK(S.DEPTH1) = STPTR; /* SAVE CURRENT SYMBOL TABLE POINTER */  S.DEPTH  = S.DEPTH+S.STRIDE; /* INCREMENT BOTH DEPTH COUNTS */  S.DEPTH1 = S.DEPTH1+1;  IF S.DEPTH1 > S.DEPTH.MAX THEN CALL ER.TMB;END S.BLOCK; /* S.END BLOCK PROCEDURE:     S.ENDBLOCK IS CALLED AT THE END OF EVERY LEVEL OF BLOCK DEFINITIONS.     IT IS USED TO UN-DECLARE ALL VARIABLES, LABELS, AND PROCEDURES THAT   ARE DEFINED ON INNER BLOCKS.   UNDECLARED LABELS (FORWARD REFERENCE)   ARE DETECTED AT THIS LEVEL ALSO. */  S.ENDBLOCK:  PROC; /* PROCESS END OF BLOCK */  DCL (INDEX,LAST,TOKEN,INFO) FIXED;   DO INDEX=0 TO HASHSIZE; /* WIPE OUT ALL DEFS AT THIS LEVEL */    LAST=HASHTAB(INDEX); /* PICK UP START POINTER THIS BUCKET */    DO WHILE (LAST<>0) AND ((LAST&SMASK)=S.DEPTH); /* SCAN DEFINED SYMBOLS THIS DEPTH */      LAST=LAST&S.PMASK; /* EXTRACT DEPTH FIELD */      LAST=CORE(STLOC+LAST); /* PICK UP POINTER TO NEXT SYMBOL */    END;    HASHTAB(INDEX)=LAST; /* AND SAVE TOP POINTER IN HASHTAB */  END;   S.DEPTH  = S.DEPTH - S.STRIDE; /* DECREMENT BOTH DEPTH COUNTS */  S.DEPTH1 = S.DEPTH1 - 1;  STPTR    = S.NL.STAK(S.DEPTH1); END S.ENDBLOCK;