/* $subtitle Process Basic SCRIPT Statements and Emit Notes *//* SUBROUTINES FOR TIME BASE COMPUTATIONS */COMPUTE.LENGTH:  PROC(LEN); /* CONVERT LENGTH (MS.) TO SYNCL II FORMAT */   DCL LEN FIXED;   WRITE(5)=LEN; WRITE(7)=5; LEN=READ(5); /* DO NOT ROUND BY 2 MS. */   IF      LEN IGT 8160 THEN RETURN 8160; /* MAX 81.6 SECONDS */   ELSE IF LEN IGT 4095 THEN RETURN SHR(LEN,5)\SHL(3,8); /* SCALE */   ELSE IF LEN IGT 1023 THEN RETURN SHR(LEN,4)\SHL(2,8);   ELSE IF LEN IGT 255  THEN RETURN SHR(LEN,2)\SHL(1,8);   RETURN LEN; /* 0-255 - NO ADJUSTMENT NEEDED */END COMPUTE.LENGTH;dcl (dur.msb,dur.lsb) fixed; /* 4 bit and 10 bit fields for Release M format note record */compute.new.length: proc (secs, msecs); /* compute note duration for Release M format */   dcl (secs,msecs) fixed; /* seconds, milliseconds of note duration */   dcl (i) fixed;   write(5)=secs; write(4)=msecs; write(6)=1000; /* secs * 1000 + msec */   dur.msb=read(4); /* upper 4 bits of duration (2-bit exponent, 2 MS bits of mantissa) */   dur.lsb=read(5); /* bottom 10 bits of mantissa */   i=0;   do while  (dur.msb<>0)   or        ((dur.lsb&"170000")<>0);      i=i+1;      dur.lsb=shr(dur.lsb,2)\shl(dur.msb,14);      dur.msb=shr(dur.msb,2);   end;   if i>3 then do;      dur.msb=15; dur.lsb=4095;   end;   else do;      dur.msb=shr(dur.lsb,10)+shl(i,2);      dur.lsb=dur.lsb&4095;   end;end compute.new.length;DCL START.TIME         FIXED; /* STARTING TIME */DCL START.TIME.CARRIES FIXED; /* HOLDS CARRIES */COMPUTE.START:  PROC(SECONDS,MILLISECONDS); /* COMPUTE START TIME FROM REAL TIME */   DCL (MSB,LSB,TEMP)         FIXED;   DCL (SECONDS,MILLISECONDS) FIXED;   if releasem=0 then do;      WRITE(5)=SECONDS; WRITE(6)=200; /* SECONDS TIMES 200 =  PERIODS */      MSB=READ(4); LSB=READ(5);      TEMP=(MILLISECONDS+2)/5 + 3; /* OFFSET BY 3 HERE AND ROUND */      LSB=LSB+TEMP;      IF LSB ILT TEMP THEN MSB=MSB+1; /* CARRY */      WRITE(5)=LSB; WRITE(4)=MSB; /* NOW DIVIDE BY 32767 */      WRITE(7)=32767; /* COMPUTE CARRIES & START */      START.TIME.CARRIES=READ(5); /* COMPUTES CARRIES */      START.TIME=SHL(READ(4)+1,1); /* COMPUTE TIME, OFFSET BY 1 MORE */   end;   else do;      write(5)=seconds; write(4)=milliseconds; write(6)=1000; /* secs * 1000 + msec */      msb=read(4); lsb=read(5);      lsb=lsb+zero.time;      if lsb ilt zero.time      then msb=msb+1;      start.time.carries=msb;      start.time        =lsb;   end;END COMPUTE.START;/* $Subtitle  Articulation, Tempo, Speed, Loop Statements */DCL (ART.DEF,TIM.DEF,VOL.DEF) FIXED; /* DEFAULT PARAMETERS */DCL (ART.MUL,TIM.MUL,VOL.MUL) FIXED; /* MULTIPLIERS */ART.DEF=1000; TIM.DEF=1000; VOL.DEF=1000;ART.MUL=1000; TIM.MUL=1000; VOL.MUL=1000;A.T.V.STATEMENT:  PROC(ARG); /* PROCESS ARTICULATION,TIMBRE,VOLUME */   DCL ARG FIXED;   CALL SCAN; /* SCAN AHEAD */   IF TOKEN=T.TIME THEN DO; /* ARTICULATION DEFAULT */     INFO=SECONDS*10+MILLISECONDS/100; /* COMPUTE 1 DECIMAL PLACE */     IF INFO>1000 THEN CALL ER.TMD;     CORE(ADDR(ART.DEF)+ARG)=INFO; /* STORE DEFAULT */   END;   ELSE DO; /* MUL */     IF TOKEN<>T.MUL THEN CALL ER.IFM;     CALL SCAN.NUMERIC;     CALL ADJUST.NUM(1);     IF INFO>10000 THEN CALL ER.TMD;     CORE(ADDR(ART.MUL)+ARG)=INFO; /* STORE NUMBER */   END;   CALL SCAN;END A.T.V.STATEMENT;TEMPO.STATEMENT:  PROC; /* SCAN OFF TEMPO */   IF BEAT.SCANNED THEN CALL ER.SYN7; /* TEMPO NOT ALLOWED AFTER 'BEAT' */   IF AT.PTR<>0    THEN CALL ER.SYN8; /* TEMPO NOT ALLOWED AFTER 'AT' */   CALL SCAN.TEMPO;END TEMPO.STATEMENT;SPEED.STATEMENT:  PROC; /* SCAN OFF SPEED */   CALL SCAN.NUMERIC;   CALL ADJUST.NUM(3); /* 1.000 FOR SPEED CONTROL */   IF INFO>10000 THEN CALL ER.TMD; /* TOO BIG */   SEQDATA(SEQ.SPEED)=INFO;   CALL SCAN;END SPEED.STATEMENT;LOOP.STATEMENT:  PROC; /* SET UP GLOBAL LOOP */   CALL SCAN; /* SKIP TO LOOP TIME */   IF TOKEN=T.BEAT THEN DO; /* LOOK UP BEAT NUMBER */     CALL LOOKUP.BEAT.NUMBER; /* GET SECONDS, MILLISECONDS */     CALL INITIALIZE.BA; /* RESTORE BA IN CASE WE ARE MID-NOTELIST */   END;   ELSE IF TOKEN<>T.TIME THEN CALL ER.IFM; /* NUMBER REQUIRED */   CALL COMPUTE.REAL.TIME(SECONDS,MILLISECONDS,MILLI.LSBS);   CALL COMPUTE.START(REAL.SECONDS,REAL.MILLISECONDS);   if releasem=0 then do;      SEQDATA(SEQ.LOOP)   =1; /* SET UP LOOP */      SEQDATA(SEQ.G.P.T)  =START.TIME; /* SET UP GOBACK.PLAY.TIME */      SEQDATA(SEQ.G.P.T.C)=START.TIME.CARRIES; /* ASSUME MIN */   end;   else do;      seqdata(new.seq.loop)   =1;      seqdata(new.seq.g.p.t)  =start.time;      seqdata(new.seq.g.p.t.c)=start.time.carries;   end;   CALL SCAN; /* SKIP OVER NUMBER */END LOOP.STATEMENT;/* $SUBTITLE  Scale, Click, Octaveratio, Keysig Statements */SCALE.STATEMENT:  PROC; /* SET UP SPECIAL TUNING */   DCL I FIXED;   ENABLE.EOL=1; /* STOP SCAN AT END OF LINE */   DO I=0 TO 11; /* SCAN OFF 12 SCALE NUMBERS */     CALL SCAN.AHEAD;     IF NCHR=0 THEN CALL ER.TFSC; /* TOO FEW NUMBERS */     ELSE           CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */     CALL ADJUST.NUM(3); /* GET TO .00X SEMITONE */     IF INFO>=12000 THEN CALL ER.TMD; /* NUMBER TOO LARGE */     SEQDATA(SEQ.SCALE+I)=INFO*1024/12000; /* CONVERT TO 1024 STEPS/OCT */     IF READ(4)>=6000 THEN SEQDATA(SEQ.SCALE+I)=SEQDATA(SEQ.SCALE+I)+1;   END;   CALL SCAN;   IF TOKEN<>T.EOL THEN CALL ER.TMSC; /* TOO MANY SCALE ELEMENTS */   ENABLE.EOL=0;   CALL SCAN; /* SKIP OVER END OF LINE */END SCALE.STATEMENT;CLICKPERIOD.STATEMENT:  PROC; /* PROCESS CLICKPERIOD STATEMENT */   CALL SCAN.NUMERIC;   CALL ADJUST.NUM(3); /* GET .XXX */   if releasem=0 then do;      SEQDATA(SEQ.CLICK)=INFO/5; /* UNITS OF .005 SECONDS */   end;   else do;      seqdata(new.seq.click)=info;   end;   CALL SCAN;END;CLICKMULTIPLIER.STATEMENT:  PROC; /* PROCESS CLICKMULTIPLIER STATEMENT */   CALL SCAN.NUMERIC;   CALL ADJUST.NUM(0); /* GET X. */   IF ((INFO<1) OR (INFO>48)) THEN CALL ER.TMD; /* number too large */   CRM=INFO;   CALL SCAN;END;OCTAVERATIO.STATEMENT:  PROC; /* PROCESS OCTAVERATIO STATEMENT */   CALL SCAN.NUMERIC;   CALL ADJUST.NUM(3); /* .XXX */   IF INFO>4000 THEN CALL ER.TMD; /* TOO LARGE */   if releasem=0 then do;      SEQDATA(SEQ.OCTRATIO)=INFO; /* SAVE IT */   end;   else do;      seqdata(new.seq.octratio)=info;   end;   CALL SCAN;END OCTAVERATIO.STATEMENT;KEYSIG.STATEMENT:  PROC; /* PROCESS KEYSIG STATEMENT */   CALL SCAN.KEY; /* SCAN OFF KEY SIGNATURE */   ACTIVE.KEY=INFO; /* SAVE IT AS GLOBAL KEY */   CALL SETUP.KEY(ACTIVE.KEY); /* SET UP FOR PITCH SCAN IN THIS KEY */   CALL SCAN; /* DONE WITH KEY SIGNATURE, GET NEXT TOKEN */END KEYSIG.STATEMENT;DTDSOLOS.STATEMENT:  PROC; /* SET DTD SOLO STATE */   DCL I FIXED;   ENABLE.EOL=1; /* STOP SCAN AT END OF LINE */      MORE:;      CALL SCAN.AHEAD;   IF NCHR=0 THEN CALL ER.TFSC; 			/* TOO FEW NUMBERS */   ELSE           CALL SCAN.NUMERIC; 	/* SCAN OFF NUMBER */   IF (INFO == 0) OR (INFO IGT 16) THEN CALL ER.TMD; /* NUMBER TOO LARGE */   I = 1;   WHILE (INFO > 1)		{I = SHL(I,1); INFO = INFO-1;}	   SEQDATA(SEQ.DTD.SOLOS)=SEQDATA(SEQ.DTD.SOLOS) | I;	IF (NCHR == A.COMMA)	{		SCAN();		GOTO MORE;	}	   CALL SCAN;   IF TOKEN<>T.EOL THEN CALL ER.TMSC;   ENABLE.EOL=0;      CALL SCAN; /* SKIP OVER END OF LINE */END DTDSOLOS.STATEMENT;/* $PAGE - ROUTINES TO READ IN VARIABLE LENGTH TIMBRE BANKS FROM DISK */DCL BANK.MS.SECTOR  FIXED; /* DEVICE AND MS BITS OF STARTING SECTOR */DCL BANK.LS.SECTOR  FIXED; /* LS BITS OF STARTING SECTOR */DCL BANK.LENGTH     FIXED; /* LENGTH OF BANK IN SECTORS */DCL BFILE           FIXED; /* 0=.BNKDATA   1=.NEWDATA */FIND.NEW.BANK:PROC(BNUM,NEW.FORMAT) RETURNS (BOOLEAN); /* ALSO,  A PROCEDURE TO TRY TO FIND A NEW TIMBRE FILE ON THE DISK */   DCL BNUM        FIXED;   /* PASS DESIRED BANK # 0-7 */   DCL NEW.FORMAT  BOOLEAN; /* TRUE TO USE NEW BANK FORMAT */   DCL FOUND       BOOLEAN; /* TRUE IF BANK FOUND OK */   BANK.MS.SECTOR = 0; BANK.LS.SECTOR = 0; BANK.LENGTH = 0; /* CLEAR PREVIOUS BANK */   IF (NOT NEW.FORMAT) THEN DO;     /* LOOK FOR REL I */      FOUND = FILESEARCH('.BNKDATA'); /* SEARCH FOR '.BNKDATA' */      IF FOUND THEN BANK.LENGTH=6; /* IF THERE, USE OLD BANK FORMAT */   END;   ELSE DO;                /* LOOK FOR REL R */      FOUND = FILESEARCH('.NEWDATA'); /* SEARCH FOR '.NEWDATA' */      IF FOUND THEN DO; /* FILE FOUND */         IF F#LS_LENGTH IGE 24*8      /* BIGGER THAN 24 SECTORS/BANK */         THEN BANK.LENGTH=SHR(F#LS_LENGTH,3); /* DIVIDE FILE INTO 1/8 THS */         ELSE DO; /* SHORTER THAN 24*8 SECTORS - USE FEWER BANKS */            BANK.LENGTH=24;            IF F#LS_LENGTH ILT ((BNUM+1)*BANK.LENGTH) THEN FOUND = FALSE; /* BUT SELECTED BANK DOES NOT FIT */         END;      END;   END;   IF FOUND THEN DO; /* FILE FOUND, SO SET UP VARIABLES */      BANK.MS.SECTOR = F#MS_SECTOR; /* RECORD THE DEVICE AND MS BITS OF STARTING SECTOR */      BANK.LS.SECTOR = F#LS_SECTOR + BNUM*BANK.LENGTH; /* LS BITS OF BANK STARTING SECTOR */      IF BANK.LS.SECTOR ILT F#LS_SECTOR THEN BANK.MS.SECTOR = BANK.MS.SECTOR + 1;   END;   RETURN (FOUND); /* TRUE IF BANK FOUND */END FIND.NEW.BANK;    DCL CORE.START   FIXED; /* CORE LOCATION OF START OF BUFFER */DCL MAX.BUF.LEN  FIXED; /* MAX LENGTH OF BUFFER BEFORE WE CREAM SOMETHING */DCL ACT.BUF.LEN  FIXED; /* ACTIVE LENGTH OF BUFFER */DCL BUF.R.PTR    FIXED; /* BUFFER READING POINTER */DCL SECTORS.READ FIXED; /* NO. SECTORS OF BANK ALREADY READ AND PROCESSED */DCL (CHUNK.SIZE)  LIT '20 '; /* NORMALLY BUFFER IN 20 SECTOR CHUNKS, FOR SPEED */G.PRIME:PROC(WORDS.READ); /* ROUTINE TO ASSIST PRIMING */   DCL (WORDS.READ) FIXED; /* NO. WORDS READ IN LAST BUFFER */   DCL (MSW,LSW)    FIXED;   CORE.START=STACKLOC+STACKPT;                /* USE UNUSED PART OF STACK AS BUFFER */   MAX.BUF.LEN=(STACKLEN-STACKPT)&"177400";    /* MAX LENGTH OF BUFFER IN WORDLOCS; MULT OF 246 */   IF MAX.BUF.LEN=0 THEN CALL FILE.TOO.BIG;    /* NO ROOM */   SECTORS.READ = SECTORS.READ + SHR(WORDS.READ,8); /* ADD UP NO. SECTORS COMPLETELY READ */   BUF.R.PTR = (WORDS.READ AND "HFF");         /* OFFSET OF NEXT WORD TO READ */   ACT.BUF.LEN = BANK.LENGTH - SECTORS.READ;   /* SET TO NO. SECTORS LEFT TO READ */   IF ACT.BUF.LEN IGT CHUNK.SIZE THEN ACT.BUF.LEN=CHUNK.SIZE;   ACT.BUF.LEN=SHL(ACT.BUF.LEN,8);             /* GET SIZE IN WORDS */   IF ACT.BUF.LEN IGT MAX.BUF.LEN THEN ACT.BUF.LEN=MAX.BUF.LEN; /* LIMIT TO SIZE OF BUFFER */   MSW = BANK.MS.SECTOR;                       /* CALCULATE SECTOR TO READ FROM */   LSW = BANK.LS.SECTOR + SECTORS.READ;   IF LSW ILT BANK.LS.SECTOR THEN MSW = MSW + 1;   CALL READDATA(MSW,LSW,LOCATION(CORE.START),ACT.BUF.LEN);  /* PRIME BUFFER */END G.PRIME;G.NEXT:PROC; /* GET NEXT WORD */   IF BUF.R.PTR=ACT.BUF.LEN THEN DO; /* WE HAVE REACHED ACTIVE LENGTH OF BUFFER - MUST READ MORE */      CALL G.PRIME(ACT.BUF.LEN); /* ELSE MUST GET NEW BUFFER */   END;   BUF.R.PTR=BUF.R.PTR+1; /* INCREMENT POINTER */   RETURN CORE(CORE.START+BUF.R.PTR-1); /* AND RETURN THE WORD */END G.NEXT;/* $PAGE - ROUTINES TO BUFFER TIMBRE FROM DISK QUICKLY */SKIP.WRDS:PROC(NUM); /* SKIP N WORDS ON DISK */   DCL (I,NUM) FIXED;   DO WHILE NUM<>0; /* ADVANCE DISK POINTERS AS REQUIRED */      BUF.R.PTR=BUF.R.PTR+NUM; NUM=0; /* ADVANCE POINTER BY THIS MANY WRDS */      IF BUF.R.PTR IGT ACT.BUF.LEN THEN DO; /* OOPS - PAST BUFFER - ADD MORE OR GET NEXT */         NUM=BUF.R.PTR-ACT.BUF.LEN-1; BUF.R.PTR=ACT.BUF.LEN; /* SET POINTER TO END */         CALL G.NEXT; /* RELOAD BUFFER, INCREMENT POINTER */      END;   END;END SKIP.WRDS;SKIP.DISK.PAR:PROC; /* PROCEDURE TO SKIP OVER 1 PARTIAL TIMBRE ON DISK */   IF G.NEXT<>(-2) THEN DO;      /* IF NOT SUPPRESSED, SKIP OVER IT */      CALL SKIP.WRDS(46-1);      /* SKIP OVER REST OF UNSUPPRESSED TIMBRE */      DO WHILE G.NEXT=(-1);      /* GET NEXT WORD, ENTER LOOP IF CONTINUATION PARTIAL */        CALL SKIP.WRDS(1);       /* SKIP TO LENGTH FIELD */        CALL SKIP.WRDS(G.NEXT-3); /* SKIP OVER FRAME */      END;      BUF.R.PTR=BUF.R.PTR-1;     /* RESTORE WORD FOR NEXT GET.NEXT */      IF G.NEXT=PINFO THEN DO;   /* SKIP OVER PINFO BLOCK */         CALL SKIP.WRDS(PINFO.LEN-1);      END;      ELSE BUF.R.PTR=BUF.R.PTR-1;/* RESTORE WORD FOR NEXT GET.NEXT */   END;END SKIP.DISK.PAR;FIND.DISK.TIM:PROC(NUMBER); /* TIMBRE # - RETURN CORE POINTER TO TIMBRE */   DCL (I,J,NUMBER) FIXED;   DO I=0 TO (NUMBER-1); /* ADVANCE POINTER OVER TIMBRES */      DO J=0 TO 3; /* SKIP OVER PARTIALS */         CALL SKIP.DISK.PAR; /* SKIP OVER THE PARTIAL */      END;          IF G.NEXT=TINFO THEN CALL SKIP.WRDS(TINFO.LEN); /* SKIP TINFO + FIRST WORD OF MISC AREA */      CALL SKIP.WRDS(7); /* SKIP OVER REST OF MISC INFO */   END;END FIND.DISK.TIM;/* $SUBTITLE  Process Notelist Statement */DCL (THIS.TRACK.NUMBER,NEXT.TRACK.NUMBER) FIXED;DCL (LAST.SECONDS,LAST.MILLISECONDS)      FIXED; /* HOLDS REAL TIME */DCL (NEXT.SECONDS,NEXT.MILLISECONDS)      FIXED; /* HOLDS REAL TIME */DCL NOTELIST.ACTIVE  FIXED; /* TRUE IF NOTELIST STATEMENT SCANNED */DCL EDITINFO.PRESENT FIXED; /* TRUE IF EDIT INFO DEFINED */DCL (NMSB,NLSB)  FIXED;DCL (THEAD,NSEG) FIXED;EMIT.NEW.RECORD:PROC (W1,W2,W3,W4);   DCL (W1,W2,W3,W4) FIXED;   DCL (I,J)         FIXED;   GET.NSEG:PROC;      DCL (I,J) FIXED;      I=SHR(SEQNLEN,8);      DO J=0 TO 255;         CALL EMIT.N(0);      END;      IF NSEG=0 THEN DO;    /* FIRST ONE */         WRITE(MAM)=SEQNLOC+THEAD;         WRITE(MAL)=THD.FOR;         WRITE(MD )=I;         WRITE(MAM)=SEQNLOC+I;         WRITE(MAL)=THD.REV;         WRITE(MD )=THEAD;      END;      ELSE DO;         WRITE(MAM)=SEQNLOC+NSEG;         WRITE(MAL)=THD.FOR;         WRITE(MD )=I;         WRITE(MAM)=SEQNLOC+I;         WRITE(MAL)=THD.REV;         WRITE(MD )=NSEG;      END;      NSEG=I;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.NUM.NLS;      WRITE(MD )=READ(MD)+1;      WRITE(MAM)=SEQNLOC+NSEG;      WRITE(MAL)=NLS.TRK;      WRITE(MD )=THIS.TRACK.NUMBER+NUM.KBD.TRKS;      WRITE(MAL)=NLS.FP;      WRITE(MD )=NLS.FIRSTL;      WRITE(MAL)=NLS.LP;      WRITE(MD )=NLS.FIRSTL;      WRITE(MAL)=NLS.FIRSTL;      WRITE(MD )=NLS.EOS;   END;   IF NSEG=0 THEN CALL GET.NSEG;   /* $page */   AGAIN:;   WRITE(MAM)=SEQNLOC+NSEG;   WRITE(MAL)=NLS.LP;   I=READ(MD);   IF I>NLS.LAST THEN DO;      CALL GET.NSEG;      GOTO AGAIN;   END;      WRITE(MAL)=I;   WRITE(MDI)=W1;   WRITE(MDI)=W2;   J=I+2;   IF W1 THEN DO;      WRITE(MDI)=W3;      WRITE(MDI)=W4;      J=J+2;   END;   WRITE(MD )=NLS.EOS; /* FINISH WITH EOS */   WRITE(MAL)=NLS.LP;  /* UPDATE LP       */   WRITE(MD )=J;   IF (W1>=0) AND ((W2&"77")<>REST.NOTE) /* NOT ILP RECORD OR REST NOTE   */   THEN DO;                              /* INCREMENT NUMBER OF NOTES VAR */      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.NN.LSB;      WRITE(MD )=READ(MD)+1;      IF READ(MD)=0 THEN DO;         WRITE(MAL)=THD.NN.MSB;         WRITE(MD )=READ(MD)+1;      END;   END;   IF (W1&"174001")="104001" THEN DO; /* ILP START EMITTED */      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.ILS.WRD;      WRITE(MDI)=I;      WRITE(MD )=NSEG;   END;   IF (W1&"174001")="110001" THEN DO; /* ILE               */      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.ILE.WRD;      WRITE(MDI)=I;      WRITE(MD )=NSEG;      WRITE(MAL)=THD.ILP;      WRITE(MD )=1;   END;END EMIT.NEW.RECORD;END.OF.NOTELIST:  PROC; /* CLOSE OUT A NOTELIST */   IF NOTELIST.ACTIVE THEN DO;      IF RELEASEM=0 THEN DO;         CALL EMIT.N(0); /* FINISH PREVIOUS NOTE LIST */      END;      ELSE DO;         /* ANYTHING? */      END;   END;   NOTELIST.ACTIVE=0; /* NOTELIST IS NO LONGER ACTIVE */END END.OF.NOTELIST;/* $Subtitle - Process a notelist statement */NOTELIST.STATEMENT:  PROC; /* PROCESS NOTELIST STATEMENT */   DCL MISC.DATA(7)            FIXED;   DCL (I,J,K,L,TPTR)          FIXED;   DCL OUR.TIMNUM              FIXED;   TRACK.CHECK:PROC;           /* USEFUL PROCEDURE TO CHECK FOR 'TRACK' STATEMENT */      CALL SCAN;               /* DONE WITH TIMBRE - GET FIRST ITEM OF NOTELIST */      IF TOKEN=T.TRACK THEN DO;                      /* SCAN OFF TRACK SPECIFIER */         CALL SCAN.NUMERIC; CALL ADJUST.NUM(0);      /* SCAN OFF NUMBER  */         if releasem=0 then do;            IF (INFO=0)\(INFO>16) THEN CALL ER.TMD;     /* NUMBER TOO LARGE */            IF INFO<NEXT.TRACK.NUMBER THEN CALL ER.TOO; /* TRACKS OUT OF ORDER */            DO WHILE NEXT.TRACK.NUMBER<INFO;            /* EMIT NULL TRACKS UNTIL DESIRED ONE */               THIS.TRACK.NUMBER=NEXT.TRACK.NUMBER;     /* LOOK UP THIS TRACK NUMBER */               NEXT.TRACK.NUMBER=NEXT.TRACK.NUMBER+1;   /* COMPUTE NEXT */               CALL PUSH(TIMBLEN); CALL PUSH(SEQNLEN);  /* PUSH TIMBRE & SEQUENCE POINTERS */               CALL EMIT.NULL.TIMBRE;                   /* EMIT A NULL TIMBRE */               CALL EMIT.N(FIRST.NOTE);                 /* EMIT A FIRST.NOTE */               CALL EMIT.N(0);                          /* FINISH NOTE LIST */            END;         END;         ELSE DO;            IF (INFO=0)\(INFO>248) THEN CALL ER.TMD;    /* NUMBER TOO LARGE */            IF INFO<NEXT.TRACK.NUMBER THEN CALL ER.TOO; /* TRACKS OUT OF ORDER */            THIS.TRACK.NUMBER=INFO-1;            NEXT.TRACK.NUMBER=THIS.TRACK.NUMBER+1;      /* COMPUTE NEXT */         END;         CALL SCAN; /* GET START OF NOTELIST */      END;   END TRACK.CHECK;   CALL END.OF.NOTELIST;                     /* CHECK FOR END OF PRIOR NOTE LIST */   IF EDITINFO.PRESENT=1 THEN CALL ER.EDI;   /* CANNOT HAVE NOTELIST AFTER EDIT */   THIS.TRACK.NUMBER=NEXT.TRACK.NUMBER;      /* LOOK UP THIS TRACK NUMBER */   NEXT.TRACK.NUMBER=NEXT.TRACK.NUMBER+1;    /* COMPUTE NEXT */   IF RELEASEM=0 THEN DO;      IF THIS.TRACK.NUMBER>15 THEN CALL ER.TMT; /* TOO MANY TRACKS */   END;   ELSE DO;      IF THIS.TRACK.NUMBER>200 THEN CALL ER.TMT; /* TOO MANY TRACKS    */      THEAD=SHR(SEQNLEN,8);                  /* REL SECTOR # FOR THEAD */      DO I=0 TO 255;                         /* CREATE EMPTY TIMBRE HEAD */         CALL EMIT.N(0);      END;      NSEG=0;   END;   LAST.SECONDS=0; LAST.MILLISECONDS=0;      /* INITIALIZE TIME BASE NOW */   CALL COMPUTE.REAL.TIME(0,0,0);            /* CHECK FOR 0 BEING DELAYED (!!) */   CALL ROUND.REAL.TIME;                     /* ROUND TO FIND START TIME */   NEXT.SECONDS=REAL.SECONDS; NEXT.MILLISECONDS=REAL.MILLISECONDS;   REL.SECS=0; REL.MILLS=0; REL.LSBS=0;      /* INITIALIZE RELATIVE TIMES */   CALL INITIALIZE.BA;                       /* INITIALIZE OUR BEAT ACCUMULATOR MODEL */   CALL SCAN;                                /* SKIP OVER 'NOTELIST'; GET TIMBRE */   /* $page */   IF (TOKEN=T.TDEF) OR (TOKEN=T.SFMDEF) THEN DO; /* DEFINED TIMBRE SPECIFIED - SAVE POINTERS */      TPTR=STLOC+INFO;                            /* IF TIMBRE SPECIFIED, GET POINTER */      CALL TRACK.CHECK;                           /* CHECK FOR TRACK STATEMENT BEFORE EMITTING TIMBRE; ELSE SCAN FIRST TOKEN OF NOTELIST */      IF RELEASEM=0 THEN DO;         CALL PUSH(TIMBLEN); CALL PUSH(SEQNLEN);     /* PUSH TIMBRE POINTER & NOTELIST PTR */      END;      IF SFM.TIMBRES THEN DO;  /* EMIT SFM FORMAT TIMBRES */         IF RELEASEM<>0 THEN CALL EXIT(-1); /* WE PRINTED ERROR MESSAGE EARLIER */         DO I=1 TO CORE(TPTR); /* EMIT TIMBRE INFO TO FILE (INCLUDE TRAILING ZERO) */            CALL EMIT.T(CORE(TPTR+I));         END;      END;       /* EMIT SFM TIMBRE */      ELSE DO;   /* EMIT SYNCLAVIER II TIMBRES - FROM DEF AREA OR ALREADY IN TIMBLOC AREA */         IF CORE(TPTR)=0 THEN DO;          /* NOT EMITTED YET , OR 16-TRACK FORMAT */            IF (RELEASEM<>0) THEN DO;      /* RELEASE M       */               OUR.TIMNUM=PAR.NUMT+NUM.KBD.TRKS;               CORE(TPTR)=OUR.TIMNUM;               PAR.NUMT=PAR.NUMT+1;            END;            DO I=0 TO  CORE(TPTR+1)-1;     /* EMIT INFO FOR EACH DEFINED PARTIAL */               J=STLOC+CORE(TPTR+2+I);     /* GET POINTER TO PARTIAL INFO */               K=CORE(J+1);                /* GET RELATIVE POINTER TO PARTIAL CONTENTS (IN DEFLOC, OR TIMBLOC - INTERNAL OR EXTERNAL MEMORY) */               IF CORE(J)=0 THEN DO;       /* TIMBRE IN DEFLOC - RESET POINTER, GARBAGE COLLECT */                  CORE(J)=1;               /* SET TO INDICATE STORED IN TIMBRE AREA NOW */                  CORE(J+1)=TIMBLEN;       /* POINTER TO WHERE IN TIMBRE AREA */                  DO L=0 TO CORE(J+2)-1;   /* LOOP OVER WORDS TO EMIT THEM */                     CALL EMIT.T(D.LOOKUP(K+L));                  END;                  IF K=DEFAVAIL THEN DO;   /* FREEING UP STUFF AT START OF DEF AREA - ALLOW MORE NOTES */                     DEFAVAIL=DEFAVAIL+CORE(J+2); /* MAKE THAT MUCH MORE AVAILABLE */                     IF EXAMOUNT=0 THEN DO;/* INTERNAL MEMORY - COMPUTE NEW SEQNMAX */                        SEQNMAX=DEFLOC+DEFAVAIL-SEQNLOC; /* THIS MUCH IS NOW AVAILABLE */                     END;                     ELSE DO;              /* EXTERNAL MEMORY */                        L=DEFLOC+SHR(DEFAVAIL,8)-SEQNLOC;                        IF L IGT 255 THEN L=255; /* LIMIT TO 255 SECTORS */                        SEQNMAX=SHL(L,8);                     END;                  END;               END;               ELSE DO;                    /* EMIT TIMBRE FROM TIMBRE LOC */                  DO L=0 TO CORE(J+2)-1;   /* LOOP OVER WORDS TO EMIT THEM */                     CALL EMIT.T(T.LOOKUP(K+L));                  END;               END;            END;            DO I=CORE(TPTR+1) TO 3; /* AND SUPPRESSED PARTIALS FOR UNUSED PARTIALS */               IF USE.NEW.FORMAT=0 THEN DO J=0 TO 45; CALL EMIT.T(0); END; /* EMIT ZEROES IF STILL USING OLD FORMAT */               ELSE CALL EMIT.T(-2); /* NEW FORMAT DESIRED - EMIT SINGLE WORD SUPPRESSED TIMBRE */            END;            /* $page */            IF CORE(TPTR+14)<>0 THEN DO;     /* TINFO AREA DEFINED */               I=CORE(TPTR+15);              /* GET POINTER TO TINFO AREA */               IF CORE(TPTR+14)=1 THEN DO;   /* IS IN DEFLOC AREA */                  CORE(TPTR+14)=2;           /* IT WILL NOW BE IN TIMBRE AREA */                  CORE(TPTR+15)=TIMBLEN;     /* POINTER TO IT */                  DO J=0 TO TINFO.LEN-1;     /* LOOP OVER WORDS TO EMIT THEM */                     CALL EMIT.T(D.LOOKUP(I+J));                  END;                  IF I=DEFAVAIL THEN DO;   /* FREEING UP STUFF AT START OF DEF AREA - ALLOW MORE NOTES */                     DEFAVAIL=DEFAVAIL+TINFO.LEN; /* MAKE THAT MUCH MORE AVAILABLE */                     IF EXAMOUNT=0 THEN DO;/* INTERNAL MEMORY - COMPUTE NEW SEQNMAX */                        SEQNMAX=DEFLOC+DEFAVAIL-SEQNLOC; /* THIS MUCH IS NOW AVAILABLE */                     END;                     ELSE DO;              /* EXTERNAL MEMORY */                        L=DEFLOC+SHR(DEFAVAIL,8)-SEQNLOC;                        IF L IGT 255 THEN L=255; /* LIMIT TO 255 SECTORS */                        SEQNMAX=SHL(L,8);                     END;                  END;               END;               ELSE DO;                      /* COPY FROM TIMBRE AREA ALREADY */                  DO J=0 TO TINFO.LEN-1;     /* LOOP OVER WORDS TO EMIT THEM  */                     CALL EMIT.T(T.LOOKUP(I+J));                  END;               END;            END;            DO I=0 TO 7; CALL EMIT.T(CORE(TPTR+6+I)); END; /* AND MISC INFO */         END;         ELSE DO;                       /* LOOK UP TIMBRE NUMBER */            OUR.TIMNUM=CORE(TPTR);      /* IF ALREADY EMITTED    */         END;      END;   END;   ELSE IF TOKEN=T.USING THEN DO; /* 'USING' SPECIFIER - SCAN # */     IF SFM.TIMBRES THEN CALL ER.SFX; /* MUST USE SFM */     SN2.TIMBRES=1;      /* INDICATE SYNCLAVIER TIMBRE USED */     CALL SCAN.AHEAD;    /* PEEK AT NEXT CHARACTER */     BFILE=1;            /* ASSUME USE OF REL R    */     IF NCHR>A.9 THEN DO;   /* MUST BE 'I' OR 'R' */        CALL SCAN;        IF (TOKEN=T.I) THEN BFILE=0;      /* USE .BNKDATA */        ELSE IF (TOKEN=T.R) THEN BFILE=1; /* USE .NEWDATA */        ELSE CALL ER.IFM;     END;     CALL SCAN.NUMERIC;     CALL ADJUST.NUM(0);  /* GET INTEGER VALUE FOR BANK */     IF (INFO<1) OR (INFO>8) THEN CALL ER.MTS;     I=INFO;                                   /* SAVE BANK # 1-8 */     CALL SCAN.NUMERIC;     IF INFO>=0 THEN CALL ER.MTS;              /* ERROR */     INFO=-INFO;                               /* SHOULD HAVE BEEN NEGATIVE (-3, FOR EXAMPLE) */     CALL ADJUST.NUM(0);                       /* GET INTEGER VALUE FOR ENTRY */     IF (INFO<1) OR (INFO>8) THEN CALL ER.MTS;     J=INFO;                                   /* SAVE TIMBRE #, 1-8 */     CALL TRACK.CHECK;  /* CHECK FOR TRACK STATEMENT BEFORE EMITTING TIMBRE; ALSO SCAN FIRST TOKEN OF NOTELIST */     IF RELEASEM=0 THEN DO;        CALL PUSH(TIMBLEN); CALL PUSH(SEQNLEN);   /* PUSH TIMBRE POINTER & NOTELIST PTR */     END;     ELSE DO;        OUR.TIMNUM=PAR.NUMT+NUM.KBD.TRKS;        PAR.NUMT=PAR.NUMT+1;     END;     IF (NOT FIND.NEW.BANK(I-1,BFILE)) THEN CALL ER.TIM; /* OPEN UP .NEWDATA OR .BNKDATA */     SECTORS.READ = 0; /* NO SECTORS HAVE BEEN READ YET */     CALL G.PRIME(0); /* PRIME BUFFER */     CALL FIND.DISK.TIM(J-1);                  /* FIND START OF TIMBRE */     J=G.NEXT;                                 /* GET FIRST WORD OF PARTIAL */     DO I=0 TO 3;                              /* SCAN OFF 4 PARTIALS */        IF J=(-2) THEN DO; /* SUPPRESSED PARTIAL */           USE.NEW.FORMAT=1; CALL EMIT.T(-2);  /* EMIT NULL PARTIAL */           J=G.NEXT;                           /* PRESCAN AHEAD */        END;        ELSE DO;                               /* EMIT PARTIAL */           CALL EMIT.T(J);                     /* EMIT SCANNED WORD */           DO J=1 TO 46-1; CALL EMIT.T(G.NEXT); END;  /* EMIT REST OF FRAME 0 */           J=G.NEXT;                           /* PRESCAN AHEAD */           DO WHILE J=(-1);                    /* EMIT FRAMES   */              USE.NEW.FORMAT=1;                /* SET FLAG FOR NEW FORMAT COMPILATION IF TIMBRE FRAME ENCOUNTERED */              CALL EMIT.T(J); CALL EMIT.T(G.NEXT); /* -1, TYPE WORD */              J=G.NEXT;                        /* GET LENGTH WORD */              CALL EMIT.T(J);                  /* EMIT LENGTH WORD */              DO J=4 TO J;                     /* COPY LENGTH OF FRAME */                 CALL EMIT.T(G.NEXT);          /* DO IT */              END;              J=G.NEXT;                        /* PRESCAN AHEAD */           END;                                /* OF T.F LOOP */           IF J=PINFO THEN DO;                 /* EMIT PINFO AREA */              CALL EMIT.T(J);              DO J=1 TO PINFO.LEN-1;                 CALL EMIT.T(G.NEXT);              END;              J=G.NEXT;                        /* SCAN NEXT WORD */           END;        END;                                   /* OF DO FOR NON-SUPPRESSED PARTIAL */     END;                                      /* OF PARTIAL LOOP */     IF J=TINFO THEN DO;                       /* EMIT TINFO AREA */        CALL EMIT.T(J);        DO J=1 TO TINFO.LEN-1;           CALL EMIT.T(G.NEXT);        END;        J=G.NEXT;                        /* SCAN NEXT WORD */     END;     CALL EMIT.T(J);                     /* EMIT FIRST WORD OF TIMBRE MISC AREA */     DO J=1 TO 7; CALL EMIT.T(G.NEXT); END; /* EMIT 8 TIMBRE MISC WORDS */   END;   ELSE DO; CALL ER.MTS; RETURN; END; /* MISSING TIMBRE SPECIFIER */   CALL SETUP.KEY(ACTIVE.KEY); /* SET UP FOR PITCH SCANS IN THIS KEY */   NOTELIST.ACTIVE=1;          /* WE HAVE SET UP A NOTELIST HEADER */   ANY.NOTES=1;                /* DISABLE FURTHER SYNC STATEMENTS */   IF RELEASEM<>0 THEN DO;     /* NOW INITIALIZE TRACK HEAD       */      WRITE(MAM)=SEQNLOC;      /* POINTER IN NAH                  */      WRITE(MAL)=THIS.TRACK.NUMBER+NUM.KBD.TRKS;      WRITE(MD )=THEAD;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.TRK;      WRITE(MD )=THIS.TRACK.NUMBER+NUM.KBD.TRKS;      WRITE(MAL)=THD.TVOL;      WRITE(MD )=1000;      WRITE(MAL)=THD.STIMB;      WRITE(MD )=OUR.TIMNUM;      WRITE(MAL)=THD.USAGE;      WRITE(MDI)=OUR.TIMNUM;      WRITE(MD )=1;      WRITE(MAL)=THD.SCALE;      DO I=0 TO 11;         WRITE(MDI)=BASIC.SEQ(I);      END;      WRITE(MAL)=THD.ORATIO;      WRITE(MD )=1000;      WRITE(MAL)=THD.ACTIVE.MIDI.RTES;      WRITE(MD )=DEFAULT.ACTIVE.MIDI.RTES;            NMSB=0;      NLSB=0;   END;   ELSE DO;      CALL EMIT.N(FIRST.NOTE); /* EMIT A FIRST.NOTE - START OF TRACK DATA */   END;END NOTELIST.STATEMENT;/* $SUBTITLE  Process 'TRANPOSE' or 'GLIDEFROM' at Start of Track */TRANSPOSE.GLIDEFROM.STATEMENT:  PROC(TYPE); /* XPOS OR GFROM */   DCL (TYPE,I) FIXED;   IF (NOTELIST.ACTIVE=0) THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF TYPE=T.XPOS THEN CALL SETUP.KEY(0); /* SKIP KEYSIG FOR MODULATIONS */   CALL SCAN.AHEAD; CALL SCAN.PITCH; /* SCAN OFF PITCH */   CALL SETUP.KEY(ACTIVE.KEY); /* RESTORE SCAN FOR ACTIVE KEY */   IF RELEASEM=0 THEN DO;      I=((INFO&"177")-12)*1024/12; /* 1024 STEPS/OCTAVE - PRODUCE -1024 TO XXX */      IF READ(4)>=6 THEN I=I+1;    /* ROUND */      IF TYPE=T.XPOS THEN SEQDATA(SEQ.XPOS.DATA+THIS.TRACK.NUMBER)=I-2048;      ELSE                SEQDATA(SEQ.FIRSTS+   THIS.TRACK.NUMBER)=I; /* ELSE FIRST PITCH */   END;   ELSE DO;      I=(INFO&"177");      WRITE(MAM)=SEQNLOC+THEAD;      IF TYPE=T.XPOS THEN DO;         WRITE(MAL)=THD.SXPOS;         WRITE(MD )=I-36;      END;      ELSE DO;         WRITE(MAL)=THD.SLPITCH;         WRITE(MD )=I;      /* ELSE FIRST PITCH */      END;   END;   CALL SCAN;               /* SKIP OVER PITCH */END TRANSPOSE.GLIDEFROM.STATEMENT;ADD.TO.BA:  PROC(B.MSB,B.LSB,B.LLSB); /* ADD TO BEAT ACCUMULATOR */   DCL (B.MSB,B.LSB,B.LLSB) FIXED;   BA.LLSB=BA.LLSB+B.LLSB; /* COMPUTE BEAT TIME OF NEXT NOTE */   IF BA.LLSB ILT B.LLSB THEN DO;      BA.LSB=BA.LSB+1;      IF BA.LSB=0 THEN DO;         BA.MSB=BA.MSB+1;         IF BA.MSB=0 THEN CALL ER.OVF;      END;   END;   BA.LSB=BA.LSB+B.LSB;   IF BA.LSB ILT B.LSB THEN DO;      BA.MSB=BA.MSB+1;      IF BA.MSB=0 THEN CALL ER.OVF;   END;   BA.MSB=BA.MSB+B.MSB;   IF BA.MSB ILT B.MSB THEN CALL ER.OVF;END ADD.TO.BA;/* $SUBTITLE  Main Routine for Emitting Notes *//* USES POINTERS IN GLOBAL VARIABLES: PTR.P,PTR.R,PTR.A,PTR.T,PTR.V.                                     NUM.P,NUM.R,NUM.A,NUM.T,NUM.V *//* BIT DEFINITIONS FOR SYNCLAVIER SBITS WORD: */DCL B.GFSW  LIT '01'; /* GLIDE FOOT SWITCH (PORTAMENTO) */DCL B.RFSW  LIT '02'; /* REPEAT FOOT SWITCH */DCL B.AFSW  LIT '04'; /* ARPEGGIATE FOOT SWITCH */DCL B.GUI   LIT '08'; /* INDICATES GUITAR NOTE */DCL B.TIE   LIT '16'; /* INDICATES TIED NOTE */DCL B.VOL   LIT '32'; /* INDICATES VOLUME DATA */DCL B.MON   LIT '64'; /* INDICATES TO RE-ARTICULATE ATTACK AFTER TIE - CREATES MONOPHONIC STRINGS */DCL B.UPD   LIT'128'; /* INDICATES AN 'UPDATE' RECORD */DCL B.LOWER    LIT ' 64'; /* THIS BIT IS SET IN 4-WORD RECORDS TO LOWER KEY BY 1 OCTAVE */DCL B.RAISE    LIT '128'; /* THIS BIT IS SET IN 4-WORD RECORDS TO RAISE KEY ONE OCTAVE */EMIT.NOTES:  PROC; /* NOTE EMITTING ROUTINE */   DCL (PITCH,RTE,SBITS,VOLUME)         FIXED;   DCL (LENGTH.SEC, LENGTH.MS)          FIXED; /* computed duration of the note */   DCL TEMPSTOR(14)                     FIXED; /* FOR RESETTING MODEL */   DCL (T.MSB,T.LSB,TBU.TOP,TBU.BOTTOM) FIXED; /* FOR RESETTING */   DCL (TBA.MSB,TBA.LSB,TBA.LLSB)       FIXED;   DCL (I,J,K,L,M)                      FIXED;   DCL (RLBITS)                         FIXED;   DCL (MSB,LSB)                        FIXED;   DO I=0 TO (NUM.P)-1; /* EMIT RECORD FOR EVERY PITCH */      PITCH=CORE(PTR.P+I)&"177"; /* LOOK UP PITCH */      CALL COMPUTE.START(NEXT.SECONDS,NEXT.MILLISECONDS); /* START */      TOP=CORE(PTR.R+I+I); BOTTOM=CORE(PTR.R+I+I+1); /* GET DUR */      CALL COMPUTE.BEAT; /* COMPUTE BEAT # TO 48 BITS USING CURRENT TEMPO */      IF (CORE(PTR.P+I)&B.ENCLOSED)<>0 THEN DO; /* ENCLOSED NOTE - SAVE MODEL */         DO J=0 TO 14; TEMPSTOR(J)=CORE(ADDR(BA.MSB)+J); END;         T.MSB=TEMPO.MSB; T.LSB=TEMPO.LSB; /* SAVE INITIAL TEMPO */         TBU.TOP=BU.TOP; TBU.BOTTOM=BU.BOTTOM; /* SAVE BEAT UNIT AS WELL */      END;      TBA.MSB=BA.MSB; TBA.LSB=BA.LSB; TBA.LLSB=BA.LLSB;      IF (CORE(PTR.P+I)&B.PHRASED)<>0 THEN DO; /* BEGINNING OF PHRASED NOTE */         K=B.MSB; L=B.LSB; M=B.LLSB;         CORE(PTR.P+I+1)=CORE(PTR.P+I+1)\B.TIEDTO; /* INDICATE TIED TO */      END;      ELSE DO; /* NOT A PHRASED NOTE - COMPUTE AS REQUIRED */         IF NUM.A<>0 THEN J=CORE(PTR.A+I); /* LOOK UP ARTIC VALUE */         ELSE             J=ART.DEF; /* ELSE USE DEFAULT */         WRITE(5)=J; WRITE(6)=ART.MUL; J=READ(5); /* J * ART.MUL / 1000 */         WRITE(7)=1000; J=READ(5);         IF READ(4)>=500 THEN J=J+1; /* ROUND UP */         IF J>1000 THEN J=1000; /* MAX */         IF J=1000 THEN DO; /* USE 100% ARTICULATION */            K=B.MSB; L=B.LSB; M=B.LLSB;         END;         ELSE DO;            WRITE(5)=B.MSB; WRITE(6)=J; K=READ(5); /* COMPUTE ARTICULATION */            WRITE(7)=1000; K=READ(5);            L=READ(4); WRITE(5)=0; WRITE(4)=L; WRITE(7)=1000; L=READ(5);            WRITE(5)=B.LSB; WRITE(6)=J; J=READ(5);            WRITE(7)=1000; L=L+READ(5);            IF L ILT READ(5) THEN K=K+1;            M=0; /* IGNORE LLSB (1/65536 OF A BEAT) FOR ARTIC CALCULATIONS */         END;      END;      /* $page */      CALL ADD.TO.BA(K,L,M); /* ADVANCE BEAT TO ARTICULATION POINT */      CALL COMPUTE.NOTE.START.TIME; /* GET TIME OF END OF NOTE WITH ARTIC */      CALL COMPUTE.REAL.TIME(NOTE.SEC,NOTE.MS,0); /* END NOTE THERE */      CALL ROUND.REAL.TIME; /* FIND ACTUAL START TIME IN SYNCLAVIER TIME */      IF (REAL.SECONDS ILT NEXT.SECONDS) /* HAPPENS IF ELECTRONIC NOTES INSERTED */      OR ((REAL.SECONDS=NEXT.SECONDS)&(REAL.MILLISECONDS ILT NEXT.MILLISECONDS))      THEN DO;         IF      DELAY.SCANNED  THEN CALL ER.NL2;         ELSE IF SMOOTH.SCANNED THEN CALL ER.NL3;         ELSE CALL ER.NL1;      END;      /* compute the length of the note */      if RELEASEM = 0 then do; /* old format - just keep 16-bit millisecond value for length */         WRITE(5)=(REAL.SECONDS-NEXT.SECONDS); WRITE(6)=1000; /* compute milliseconds */         IF (READ(4)<>0)\(READ(5) IGE (-1200)) THEN CALL ER.OVF; /* check for overflow */         LENGTH.MS = READ(5)+(REAL.MILLISECONDS-NEXT.MILLISECONDS);         IF (CORE(PTR.P+I)&B.PHRASED)<>0 THEN LENGTH.MS=LENGTH.MS+100; /* ALLOW OVERLAP */         LENGTH.SEC = 0; /* just to be safe set this to zero */      end;      else do; /* new Release M format - calculate length in seconds and milliseconds */         length.sec = real.seconds - next.seconds;         length.ms  = real.milliseconds - next.milliseconds;         if length.ms < 0 then do; /* need to borrow */            length.ms = length.ms + 1000; /* normalize milliseconds */            length.sec = length.sec - 1; /* subtract one second */         end;         if (core(ptr.p+i)&B.PHRASED)<>0 then length.ms = length.ms + 100; /* allow overlap */         if length.ms >= 1000 then do; /* overflow */            length.ms = length.ms - 1000; /* normalize milliseconds */            length.sec = length.sec + 1; /* add one second */         end;      end;      BA.MSB=TBA.MSB; BA.LSB=TBA.LSB; BA.LLSB=TBA.LLSB; /* RESTORE ACCUM */      CALL ADD.TO.BA(B.MSB,B.LSB,B.LLSB); /* ADVANCE TO NEXT NOTE */      CALL COMPUTE.NOTE.START.TIME; /* GET START TIME OF NEXT NOTE */      CALL COMPUTE.REAL.TIME(NOTE.SEC,NOTE.MS,0); /* MAP FOR SYNC */      CALL ROUND.REAL.TIME; /* FIND ACTUAL END TIME FOR NOTE */      /* Now compute dynamics and timbre data, then emit note */      IF NUM.T<>0 THEN J=CORE(PTR.T+I); /* LOOK UP TIMBRE VALUE */      ELSE             J=TIM.DEF; /* ELSE USE DEFAULT */      WRITE(5)=J; WRITE(6)=TIM.MUL; J=READ(5); /* J * TIM.MUL / 1000 */      WRITE(7)=1000; J=READ(5);      IF READ(4)>=500 THEN J=J+1; /* ROUND */      IF J>1000 THEN J=1000; /* LIMIT TO 1000 */      WRITE(5)=225; WRITE(6)=J; RTE=READ(5); /* 225 * J / 1000 */      WRITE(7)=1000; RTE=READ(5);      IF READ(4)>=500 THEN RTE=RTE+1; /* ROUND */      IF NUM.V<>0 THEN J=CORE(PTR.V+I); /* LOOK UP VOLUME PARAM */      ELSE J=VOL.DEF; /* USE DEFAULT VOLUME */      WRITE(5)=J; WRITE(6)=VOL.MUL; J=READ(5); /* J * VOL.MUL / 1000 */      WRITE(7)=1000; J=READ(5);      IF READ(4)>=500 THEN J=J+1; /* ROUND */      IF J>1000 THEN J=1000; /* LIMIT IT */      WRITE(5)=255; WRITE(6)=J; VOLUME=READ(5); /* 255 * J / 1000 */      WRITE(7)=1000; VOLUME=READ(5);      IF READ(4)>=500 THEN VOLUME=VOLUME+1; /* ROUND */      if RELEASEM = 0 then do; /* old format */         WRITE(5)=LENGTH.MS; WRITE(7)=1000; J=READ(5); /* get seconds from milliseconds */      end;      else j = length.sec; /* if new format, seconds are here */      IF (PITCH<>REST.MARK) /* OMIT REST.NOTES UNLESS LONG DELAY */      OR ((NEXT.SECONDS+J)>LAST.SECONDS+60) THEN DO;         SBITS=0; /* ASSUME NO SPECIAL BITS SET */         IF (CORE(PTR.P+I)&B.TIEDTO)<>0 THEN SBITS=SBITS\B.TIE; /* TIED NOTE (ENCLOSED IN WHATEVER) */         IF VOLUME<>255 THEN SBITS=SBITS\B.VOL; /* SET BIT */         ELSE                VOLUME=0;    /* ELSE KEEP VOLUME DATA AT 0 */         /* $page - Emit the note */         IF RELEASEM=0 THEN DO;            LENGTH.MS=COMPUTE.LENGTH(LENGTH.MS); /* COMPUTE SYNCLAVIER II FORMAT */            IF PITCH=REST.MARK THEN DO;      /* MARKER RECORD */               CALL EMIT.N(START.TIME);               CALL EMIT.N(REST.NOTE);        /* EMIT REST NOTE RECORD */            END;            ELSE IF  (RTE=225)   AND (SBITS=0)    /* NO RTE OR BITS */            AND      (PITCH>=12) AND (PITCH<=72)  /* AND PITCH IS IN RANGE */            THEN DO; /* NO VELOCITY INFO NEEDED - EMIT TWO WORD RECORD */               CALL EMIT.N(START.TIME);               CALL EMIT.N((PITCH-12)\SHL(LENGTH.MS,6)); /* EMIT NOTE RECORD */            END;            ELSE DO; /* TIMBRE - EMIT FOUR WORD RECORD */              IF      PITCH<12 THEN DO; PITCH=PITCH+12; RLBITS=B.LOWER; END;              ELSE IF PITCH>72 THEN DO; PITCH=PITCH-12; RLBITS=B.RAISE; END;              ELSE                                      RLBITS=0;              CALL EMIT.N(START.TIME\1);              CALL EMIT.N((PITCH-12)\SHL(LENGTH.MS,6));              CALL EMIT.N(RTE+SHL(SBITS,8));              CALL EMIT.N(VEL.NOTE\RLBITS\SHL(VOLUME,8));            END;         END;         ELSE DO;                                    /* RELEASE M FORMAT */            CALL COMPUTE.NEW.LENGTH(LENGTH.SEC,LENGTH.MS);            IF PITCH<>REST.MARK THEN DO;             /* ONLY REAL NOTES */               MSB=START.TIME.CARRIES-NMSB;          /* COMPUTE DELTA   */               LSB=START.TIME        -NLSB;               IF START.TIME ILT NLSB THEN MSB=MSB-1;               IF (MSB<>0)               OR (LSB IGT 1023)               THEN DO;                              /* LONG REST REQUIRED */                  CALL EMIT.NEW.RECORD("100001",MSB,LSB,VEL.NOTE);                  NMSB=START.TIME.CARRIES;           /* UPDATE TIME        */                  NLSB=START.TIME;                  MSB=0;                  LSB=0;               END;               IF  (RTE=225)   AND (SBITS=0)            /* NO RTE OR BITS */               AND      (PITCH>=12) AND (PITCH<=72)  /* AND PITCH IS IN RANGE */               THEN DO; /* NO VELOCITY INFO NEEDED - EMIT TWO WORD RECORD */                  CALL EMIT.NEW.RECORD(SHL(LSB,1)\SHL(DUR.MSB,11),SHL(DUR.LSB,6)\(PITCH-12),0,0);               END;               ELSE DO; /* TIMBRE - EMIT FOUR WORD RECORD */                  IF      PITCH<12 THEN DO; PITCH=PITCH+12; RLBITS=B.LOWER; END;                  ELSE IF PITCH>72 THEN DO; PITCH=PITCH-12; RLBITS=B.RAISE; END;                  ELSE                                      RLBITS=0;                  CALL EMIT.NEW.RECORD(SHL(LSB,1)\SHL(DUR.MSB,11)\1,                                       SHL(DUR.LSB,6)\(PITCH-12),                                       RTE+SHL(SBITS,8),                                       VEL.NOTE\RLBITS\SHL(VOLUME,8));               END;               NLSB=NLSB+LSB;               IF NLSB ILT LSB THEN NMSB=NMSB+1;            END;         END;         LAST.SECONDS=NEXT.SECONDS; LAST.MILLISECONDS=NEXT.MILLISECONDS;      END;      IF (CORE(PTR.P+I)&B.ENCLOSED)<>0 THEN DO; /* ADVANCE TIME IF NO BRKT */         DO J=0 TO 14; CORE(ADDR(BA.MSB)+J)=TEMPSTOR(J); END; /* RESTORE MODEL */         TEMPO.MSB=T.MSB; TEMPO.LSB=T.LSB; /* RESTORE INITIAL TEMPO */         BU.TOP=TBU.TOP; BU.BOTTOM=TBU.BOTTOM; /* RESTORE BEAT UNIT */      END;      ELSE DO; /* NO BRACKETS - ADVANCE TIME BASE */         NEXT.SECONDS=REAL.SECONDS; NEXT.MILLISECONDS=REAL.MILLISECONDS;         REL.SECS=NEXT.SECONDS; REL.MILLS=NEXT.MILLISECONDS;         REL.LSBS=0;      END;   END;END EMIT.NOTES;/* $SUBTITLE  Scan Western Scale Notelist and Perform Statement */P.STATEMENT:  PROC; /* PROCEDURE TO PROCESS WESTERN SCALE STATEMENT */   DCL (SAVED.P,SAVED.L#) FIXED;   IF (NOTELIST.ACTIVE=0) THEN CALL ER.SNA; /* STAT NOT ALLOWED OUTSIDE OF NL */   SAVED.P=STACKPT; /* SAVE STACK POINTER FOR RESETTING */   CALL SCAN.PR; /* SCAN OFF PITCH & RHYTHM LINES */   CALL SCAN.ATV; /* SCAN OFF A T V LINES IF THERE */   SAVED.L#=LINE.NO; LINE.NO=RHYTHM.LINE#; /* FOR ERROR MESSAGES */   if NUMERRS<>0 then call EXIT(-1); /* bug fix in Release N - EMIT.NOTES gets into infinite loop in some pitch line error cases */   CALL EMIT.NOTES; /* EMIT NOTE INFO */   STACKPT=SAVED.P; /* RESTORE STACK POINTER */   LINE.NO=SAVED.L#; /* RESTORE LINE.NO */END P.STATEMENT;PERFORM.STATEMENT:  PROC; /* PROCESS 'PERFORM' STATEMENT (MOTIF) */   DCL (SAVED.P)  FIXED; /* SAVED STACK POINTER */   DCL (I,J,K,TPTR) FIXED;   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* NOT IN NOTELIST */   CALL SCAN; /* SCAN AHEAD TO MOTIF NAME */   IF TOKEN<>T.MDEF THEN DO; CALL ER.UNM; RETURN; END; /* ERROR - UNDEFINED MOTIF */   TPTR=STLOC+INFO; /* LOOK UP POINTER TO INFO (BASED OFF OF STLOC) */   CALL SETUP.MOTIF.KEY(CORE(TPTR)); /* SET UP MOTIF KEY */   CALL SCAN.AHEAD; /* SCAN AHEAD TO NEXT CHARACTER */   SAVED.P=STACKPT; /* SAVE STACK POINTER IN CASE INVERSION OPERATOR USED */   DO I=0 TO 9; CORE(ADDR(NUM.P)+I)=CORE(TPTR+I+1); END; /* SET UP NUM.X & PTR.X */   IF EXAMOUNT=0 THEN DO;  /* INTERNAL MEMORY - COMPUTE CORE POINTERS TO MOTIF AREA */      DO I=0 TO 4; CORE(ADDR(PTR.P)+I)=CORE(ADDR(PTR.P)+I)+DEFLOC; END; /* COMPUTE ABSOLUTE POINTERS IN DEF AREA */   END;   ELSE DO;                /* COPY ENTIRE MOTIF INFO INTO MEMORY - PUT ON STACK NOW */      I=CORE(TPTR+11);     /* LOOK UP TOTAL # OF WORDS IN MOTIF DEF */      IF STACKPT+I IGT STACKLEN THEN CALL ER.STK;  /* NO ROOM */      DO J=0 TO (I-1);        CORE(STACKLOC+STACKPT+J)=D.LOOKUP(PTR.P+J); /* GET WORD, STORE ON STACK */      END;      K=STACKLOC+STACKPT-PTR.P;  /* COMPUTE CORRECTION */      DO J=0 TO 4;               /* RECOMPUTE CORE POINTERS */         CORE(ADDR(PTR.P)+J)=CORE(ADDR(PTR.P)+J)+K;       END; /* COMPUTE ABSOLUTE POINTERS IN STACK AREA */      STACKPT=STACKPT+I;   END;   IF NCHR=A.LPAREN THEN DO; /* LEFT PAREN - SCAN OFF OPERATIONS */      CALL GET.CHAR; /* SKIP PAREN */      CALL SCAN.AHEAD;      DO WHILE NCHR<>A.RPAREN; /* LOOP UNTIL RIGHT PAREN */         CALL SCAN; /* GET OPERATOR TYPE */         CALL SCAN.AHEAD; /* FIND NEXT CHARACTER AFTER OP */         IF      TOKEN=T.I  THEN CALL INVERT;         ELSE IF TOKEN=T.T  THEN CALL TRANSPOSE;         ELSE IF TOKEN=T.R  THEN CALL RETROGRADE;         ELSE IF TOKEN=T.ST THEN CALL STRICT.TRANSPOSE;         ELSE IF TOKEN=T.SI THEN CALL STRICT.INVERT;         ELSE IF TOKEN=T.PR THEN CALL PITCH.RETROGRADE;         ELSE IF TOKEN=T.RR THEN CALL RHYTHM.RETROGRADE;         ELSE DO;            IF TOKEN=T.EOF THEN CALL ER.MTMP; /* UNMATCHED PARENS */            ELSE                CALL ER.UOP;            NCHR=A.RPAREN;         END;      END; /* OF DO WHILE */      CALL GET.CHAR; /* SKIP OVER RIGHT PAREN */   END; /* OF PARENTHESIZED GROUP */   CALL SCAN; /* DONE WITH PERFORM;  GET NEXT TOKEN */   IF (TOKEN=T.A) OR (TOKEN=T.T) OR (TOKEN=T.V) THEN DO; /* A T V LINES FOLLOW */      CALL SCAN.ATV; /* SCAN THESE ONTO STACK */      IF NUM.A=0 THEN DO; NUM.A=CORE(TPTR+3); PTR.A=CORE(TPTR+ 8)+DEFLOC;  END; /* PICK UP ART */      IF NUM.T=0 THEN DO; NUM.T=CORE(TPTR+4); PTR.T=CORE(TPTR+ 9)+DEFLOC;  END; /* PICK UP TIM */      IF NUM.V=0 THEN DO; NUM.V=CORE(TPTR+5); PTR.V=CORE(TPTR+10)+DEFLOC; END; /* PICK UP VOL */   END;   CALL EMIT.NOTES; /* EMIT NOTES FROM POINTERS */   STACKPT=SAVED.P; /* RESTORE POINTER */END PERFORM.STATEMENT;/* $SUBTITLE  Process Individual Note Statement */NOTE.STATEMENT:  PROC(TYPE); /* EMIT INDIVIDUAL NOTE */   DCL (TYPE,PITCH,LENGTH,RTE,SBITS,VOLUME) FIXED;   DCL (START.SEC,START.MS,START.LSB)       FIXED;   DCL (END.SEC,END.MS,END.LSB)             FIXED;   DCL (I,J,PITCH.DELTA)                    FIXED;   DCL (RLBITS)                             FIXED;   DCL (MSB,LSB)                            FIXED;   CHECK.FOR.LONG.REST:PROC;      MSB=START.TIME.CARRIES-NMSB;          /* COMPUTE DELTA   */      LSB=START.TIME        -NLSB;      IF START.TIME ILT NLSB THEN MSB=MSB-1;      IF (MSB<>0)      OR (LSB IGT 1023)      THEN DO;                              /* LONG REST REQUIRED */         CALL EMIT.NEW.RECORD("100001",MSB,LSB,VEL.NOTE);         NMSB=START.TIME.CARRIES;           /* UPDATE TIME        */         NLSB=START.TIME;         MSB=0;         LSB=0;      END;   END CHECK.FOR.LONG.REST;   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA;   /* NOT IN NOTELIST */   IF AT.PTR<>0 THEN DO;                    /* CAN'T USE AT STATEMENTS HERE */      IF (TYPE=T.STARTL) OR (TYPE=T.ENDL) THEN CALL ER.SYN12; /* NOT ALLOWED WITH LOOPS */      ELSE IF (TYPE=T.TIME)               THEN CALL ER.SYN11; /* NOT ALLOWED WITH COMPUTER MUSIC FORMAT */   END;   IF TYPE<>T.TIME THEN DO; /* SPECIAL FUNCTION */      IF (TYPE=T.STARTL) OR (TYPE=T.ENDL) THEN DO; /* SKIP TO START TIME */         enable.eol=1; /* Fred inserted this to fix startloop in frames bug */         CALL SCAN; /* SCAN OFF HERE OR TIME */         enable.eol=0; /* Fred inserted this too */         IF (TOKEN<>T.TIME) AND (TOKEN<>T.HERE) THEN CALL ER.IFM; /* ERROR */      END;      ELSE CALL ER.IFM; /* ERROR */   END;   IF TOKEN=T.TIME THEN DO; /* COMPUTE START.TIME & EMIT REST NOTES */      START.SEC=SECONDS; START.MS=MILLISECONDS; START.LSB=MILLI.LSBS; /* SAVE */      CALL COMPUTE.REAL.TIME(SECONDS,MILLISECONDS,MILLI.LSBS); /* MAP AS REQD */      CALL ROUND.REAL.TIME; /* ROUND UP TO 5 MS. BOUNDARY */      NEXT.SECONDS=REAL.SECONDS; NEXT.MILLISECONDS=REAL.MILLISECONDS;      IF (NEXT.SECONDS ILT LAST.SECONDS)      OR ((NEXT.SECONDS=LAST.SECONDS)&(NEXT.MILLISECONDS ILT LAST.MILLISECONDS))      THEN DO;         IF      DELAY.SCANNED  THEN CALL ER.NL2;         ELSE IF SMOOTH.SCANNED THEN CALL ER.NL3;         ELSE CALL ER.NL1;      END;      DO WHILE NEXT.SECONDS IGT (LAST.SECONDS+60); /* EMIT REST NOTE */         LAST.SECONDS=LAST.SECONDS+60; /* COMPUTE TIME OF REST NOTE */         IF RELEASEM=0 THEN DO;            CALL COMPUTE.START(LAST.SECONDS,LAST.MILLISECONDS);            CALL EMIT.N(START.TIME);            CALL EMIT.N(REST.NOTE); /* NULL RECORD */         END;      END;   END;   CALL COMPUTE.START(NEXT.SECONDS,NEXT.MILLISECONDS);   /* $page  EMIT NOTE RECORD FOR THIS NOTE */   IF TYPE=T.TIME THEN DO; /* STARTING TIME - GENERATE NOTE RECORD */      ENABLE.EOL=1;    /* ENABLE EOL TO STOP SCAN */      CALL SCAN.AHEAD; /* SKIP AHEAD TO START OF PITCH */      CALL SCAN.PITCH; /* SCAN OFF REQUIRED PITCH */      PITCH=INFO&"177"; /* PITCH */      IF PITCH=REST.MARK THEN CALL ER.MPI;      REL.SECS=0; REL.MILLS=0; REL.LSBS=0; /* IGNORE + HERE */      CALL SCAN; /* SCAN OFF DURATION */      IF TOKEN<>T.TIME THEN CALL ER.MLS; /* MISSING LENGTH */      WRITE(5)=SECONDS; WRITE(6)=ART.MUL; SECONDS=READ(5); /* FOR ARTIC MUL */      WRITE(7)=1000; SECONDS=READ(5); I=READ(4); /* SECONDS, MILLISECONDS */      WRITE(5)=MILLISECONDS; WRITE(6)=ART.MUL; MILLISECONDS=READ(5);      WRITE(7)=1000; MILLISECONDS=I+READ(5);      I=READ(4); WRITE(5)=0; WRITE(4)=I; WRITE(7)=1000; /* COMPUTE LSBS */      I=READ(5); /* GET LSBS */      WRITE(5)=MILLI.LSBS; WRITE(6)=ART.MUL; MILLI.LSBS=READ(5);      WRITE(7)=1000; MILLI.LSBS=READ(5);      MILLI.LSBS=MILLI.LSBS+I;      IF MILLI.LSBS ILT I THEN MILLISECONDS=MILLISECONDS+1;      DO WHILE MILLISECONDS>=1000;         MILLISECONDS=MILLISECONDS-1000; SECONDS=SECONDS+1;      END;      END.LSB=START.LSB+MILLI.LSBS; /* ADD TO START TIME */      END.MS =START.MS +MILLISECONDS;      END.SEC=START.SEC+SECONDS;      IF END.LSB ILT START.LSB THEN END.MS=END.MS+1;      IF END.MS>=1000 THEN DO;         END.SEC=END.SEC+1; END.MS=END.MS-1000;      END;      CALL COMPUTE.REAL.TIME(END.SEC,END.MS,END.LSB);      CALL ROUND.REAL.TIME; /* COMPUTE ROUNDED END TIME OF NOTE */      if RELEASEM = 0 then do; /* old format - duration is 16-bit milliseconds */         WRITE(5)=REAL.SECONDS-NEXT.SECONDS; WRITE(6)=1000;         IF (READ(4)<>0)OR(READ(5) IGE (-1200)) THEN CALL ER.OVF;         LENGTH=READ(5)+REAL.MILLISECONDS-NEXT.MILLISECONDS;         LENGTH=COMPUTE.LENGTH(LENGTH);      END;      ELSE DO; /* Release M format - duration is seconds and milliseconds */         i = real.seconds - next.seconds; /* subtract to get duration */         j = real.milliseconds - next.milliseconds;         if j < 0 then do; /* need to borrow */            j = j + 1000; /* normalize milliseconds */            i = i - 1;    /* subtract one second */         end;         call COMPUTE.NEW.LENGTH (i, j); /* get duration of note in Release M format */      END;      SBITS=0; RTE=TIM.DEF; VOLUME=VOL.DEF; /* SET UP FOR DEFAULT VALUES */      CALL SCAN.AHEAD; /* SKIP AHEAD TO NEXT CHARACTER */      /* $page - SCAN OFF VOLUME, TIMBRE, S,T,P,R,A,M,G(),U() AS REQUIRED */      DO WHILE (NCHR<>0) AND (NCHR<>A.COMMA); /* SCAN OFF REST OF LINE */         IF (NCHR=A.T) OR (NCHR=A.S) THEN DO; /* TIED OR SLURRED NOTES */            SBITS=SBITS\B.TIE;  CALL GET.CHAR;         END;         ELSE IF NCHR=A.M THEN DO; /* M FOR MONOPHONIC VOICE */            SBITS=SBITS\B.MON;  CALL GET.CHAR;/* SET THIS BIT.  LEAV OTHERS */         END;         ELSE IF NCHR=A.P THEN DO; /* PORTAMENTO FOOT SWITCH */            SBITS=(SBITS&(NOT(B.GUI\B.UPD)))\B.GFSW; CALL GET.CHAR;          END;         ELSE IF NCHR=A.R THEN DO; /* REPEAT FOOT SWITCH */            SBITS=(SBITS&(NOT(B.GUI\B.UPD)))\B.RFSW; CALL GET.CHAR;         END;         ELSE IF NCHR=A.A THEN DO; /* ARPEGGIATE FOOT SWITCH */            SBITS=(SBITS&(NOT(B.GUI\B.UPD)))\B.AFSW; CALL GET.CHAR;          END;         ELSE IF (NCHR=A.G) THEN DO; /* GUITAR NOTE - SCAN STRING NUMBER */            CALL GET.CHAR;CALL SCAN.AHEAD; /* SKIP G, GET TO (STRING) */            CALL SCAN.NUM.PAREN;IF DP<>0 THEN CALL ER.IFM;            IF (INFO<1)\(INFO>8) THEN CALL ER.TMD; /* TOO BIG - ALLOW UP TO 8 FOR FUTURE */            SBITS=(SBITS&(NOT(B.GFSW\B.RFSW\B.AFSW)))\B.GUI\(INFO-1);         END;         ELSE IF (NCHR=A.U) THEN DO;        /* UPDATE RECORD */            CALL GET.CHAR;CALL SCAN.AHEAD;   /* SKIP U, GET TO (PITCH DELTA) */            CALL SCAN.NUM.PAREN;IF DP<>0 THEN CALL ER.IFM;            IF (INFO<-512)\(INFO>511) THEN CALL ER.TMD; /* TOO BIG - ALLOW UP TO 8 FOR FUTURE */            SBITS=SBITS\B.UPD;               /* SET UPDATE BIT - LEAVE OTHERS FOR FUTURE */            PITCH.DELTA=INFO&"1777";         /* EXTRACT 10 BIT PITCH DELTA */         END;         ELSE IF NCHR=A.LPAREN THEN DO;   /* R PAREN - SCAN OFF RTE */            CALL SCAN.NUM.PAREN;         /* GET RTE VALUE ENCLOSED IN PARENS */            CALL ADJUST.NUM(1);            IF (INFO>1000)&((SBITS&B.UPD)=0)            THEN CALL ER.TMD;            /* ONLY PRINT ERROR IF NOT UPDATE RECORD */            RTE=INFO;         END;         ELSE DO; /* SCAN OFF VOLUME NUMBER */            CALL SCAN.NUMERIC;            CALL ADJUST.NUM(1);            IF (INFO>1000)&((SBITS&B.UPD)=0)            THEN CALL ER.TMD;  /* ONLY PRINT ERROR IF NOT UPDATE RECORD */            VOLUME=INFO;         END;         CALL SCAN.AHEAD;      END; /* OF SCAN REST OF LINE */      WRITE(5)=RTE; WRITE(6)=TIM.MUL; RTE=READ(5);      WRITE(7)=1000; RTE=READ(5);      IF READ(4)>=500 THEN RTE=RTE+1;      IF ((SBITS&B.UPD)=0)&(RTE>1000) THEN RTE=1000; /* LIMIT TO 1000 */      WRITE(5)=225; WRITE(6)=RTE; RTE=READ(5);      WRITE(7)=1000; RTE=READ(5);      IF READ(4)>=500 THEN RTE=RTE+1;      WRITE(5)=VOLUME; WRITE(6)=VOL.MUL; VOLUME=READ(5);      WRITE(7)=1000; VOLUME=READ(5);      IF READ(4)>=500 THEN VOLUME=VOLUME+1;      IF ((SBITS&B.UPD)=0)&(VOLUME>1000) THEN VOLUME=1000; /* LIMIT TO 1000 */      WRITE(5)=255; WRITE(6)=VOLUME; VOLUME=READ(5);      WRITE(7)=1000; VOLUME=READ(5);      IF READ(4)>=500 THEN VOLUME=VOLUME+1;      IF (SBITS&B.UPD)=0 THEN DO; /* IF NOT AN UPDATE RECORD,  SEE IF VOLUME IS ACTUALLY NEEDED */         IF (VOLUME<>255)\((SBITS&B.GUI)<>0) THEN SBITS=SBITS\B.VOL; /* PASS VALID VOLUME DATA IF NON-255, OR IS A GUITAR NOTE */         ELSE                VOLUME=0; /* NO VOLUME FIELD NEEDED FOR KEYBOARD NOTES AT FULL VOLUME */      END;      ELSE DO;         IF RELEASEM=0 THEN LENGTH=PITCH.DELTA; /* PASS PITCH DELTA IN LENGTH FIELD FOR UPDATE RECORDS */         ELSE DO;            DUR.MSB=0;            DUR.LSB=PITCH.DELTA;         END;      END;      /* $page */      IF RELEASEM=0 THEN DO;         IF  (RTE=225)   AND (SBITS=0)    /* NO RTE OR BITS        */         AND (PITCH>=12) AND (PITCH<=72)  /* AND PITCH IS IN RANGE */         THEN DO;            CALL EMIT.N(START.TIME);       CALL EMIT.N((PITCH-12)\SHL(LENGTH,6));         END;         ELSE DO; /* 4-WORD RECORD */            IF      PITCH<12 THEN DO; PITCH=PITCH+12; RLBITS=B.LOWER; END;            ELSE IF PITCH>72 THEN DO; PITCH=PITCH-12; RLBITS=B.RAISE; END;            ELSE                                      RLBITS=0;            CALL EMIT.N(START.TIME\1);     CALL EMIT.N((PITCH-12)\SHL(LENGTH,6));            CALL EMIT.N(RTE\SHL(SBITS,8)); CALL EMIT.N(VEL.NOTE\RLBITS\SHL(VOLUME,8));         END;      END;      ELSE DO;                                 /* RELEASE M      */         CALL CHECK.FOR.LONG.REST;         IF  (RTE=225)   AND (SBITS=0)         /* NO RTE OR BITS */         AND      (PITCH>=12) AND (PITCH<=72)  /* AND PITCH IS IN RANGE */         THEN DO; /* NO VELOCITY INFO NEEDED - EMIT TWO WORD RECORD */            CALL EMIT.NEW.RECORD(SHL(LSB,1)\SHL(DUR.MSB,11),SHL(DUR.LSB,6)\(PITCH-12),0,0);         END;         ELSE DO; /* TIMBRE - EMIT FOUR WORD RECORD */            IF      PITCH<12 THEN DO; PITCH=PITCH+12; RLBITS=B.LOWER; END;            ELSE IF PITCH>72 THEN DO; PITCH=PITCH-12; RLBITS=B.RAISE; END;            ELSE                                      RLBITS=0;            CALL EMIT.NEW.RECORD(SHL(LSB,1)\SHL(DUR.MSB,11)\1,                                 SHL(DUR.LSB,6)\(PITCH-12),                                 RTE+SHL(SBITS,8),                                 VEL.NOTE\RLBITS\SHL(VOLUME,8));         END;         NLSB=NLSB+LSB;         IF NLSB ILT LSB THEN NMSB=NMSB+1;      END;      LAST.SECONDS=NEXT.SECONDS; LAST.MILLISECONDS=NEXT.MILLISECONDS;      REL.SECS=START.SEC; REL.MILLS=START.MS; REL.LSBS=START.LSB;      ENABLE.EOL=0; /* DISABLE END OF LINE TOKEN TYPE */      IF NCHR=A.COMMA THEN CALL GET.CHAR; /* SKIP OVER COMMA */      CALL SCAN; /* TO GET NEXT TOKEN */   END; /* OF CASE TO GENERATE NOTE RECORD */   /* PROCESS STARTLOOP AND ENDLOOP STATEMENTS */   ELSE IF TYPE=T.STARTL THEN DO; /* START OF LOOP */      IF RELEASEM=0 THEN DO;         SEQDATA(SEQ.ILS.PTRS+THIS.TRACK.NUMBER)=SEQNLEN+256; /* STORE START PTR */         SEQDATA(SEQ.ILS.PTCS+THIS.TRACK.NUMBER)=START.TIME.CARRIES;         SEQDATA(SEQ.ILS.PLTS+THIS.TRACK.NUMBER)=START.TIME;      END;      ELSE DO;        CALL CHECK.FOR.LONG.REST;        CALL EMIT.NEW.RECORD("104001"+SHL(LSB,1),0,0,VEL.NOTE);        NLSB=NLSB+LSB;        IF NLSB ILT LSB THEN NMSB=NMSB+1;        WRITE(MAM)=SEQNLOC+THEAD;        WRITE(MAL)=THD.COUNTIN.MSB;        WRITE(MDI)=NMSB;     /* SET UP THD.COUNTIN.MSB */        WRITE(MD )=NLSB;     /* SET UP THD.COUNTIN.LSB */      END;      CALL SCAN; /* SKIP OVER STARTLOOP */   END;   /* $page */   ELSE IF TYPE=T.ENDL THEN DO; /*  'ENDLOOP' */      IF RELEASEM=0 THEN DO;         SEQDATA(SEQ.ILE.PTRS+THIS.TRACK.NUMBER)=SEQNLEN+256; /* END  PTR */         SEQDATA(SEQ.ILE.PTCS+THIS.TRACK.NUMBER)=START.TIME.CARRIES;         SEQDATA(SEQ.ILE.PLTS+THIS.TRACK.NUMBER)=START.TIME;         CALL COMPUTE.START(LAST.SECONDS,LAST.MILLISECONDS);         SEQDATA(SEQ.ILS.LTTS+THIS.TRACK.NUMBER)=START.TIME;         SEQDATA(SEQ.ILS.NPNS+THIS.TRACK.NUMBER)=0;      END;      ELSE DO;         CALL CHECK.FOR.LONG.REST;         CALL EMIT.NEW.RECORD("110001"+SHL(LSB,1),0,0,VEL.NOTE);         NLSB=NLSB+LSB;         IF NLSB ILT LSB THEN NMSB=NMSB+1;         WRITE(MAM)=SEQNLOC+THEAD;         WRITE(MAL)=THD.COUNTIN.MSB;         NMSB=NMSB-READ(MDI); /* COMPUTE LENGTH OF INDEPENDENT LOOP */         IF READ(MD) IGT NLSB THEN NMSB=NMSB-1;         NLSB=NLSB-READ(MD);         WRITE(MAL)=THD.LOOPLEN.MSB;         WRITE(MDI)=NMSB;     /* SET UP THD.LOOPLEN.MSB */         WRITE(MD )=NLSB;     /* SET UP THD.LOOPLEN.LSB */      END;      CALL SCAN; /* SKIP AHEAD */   END;END NOTE.STATEMENT;