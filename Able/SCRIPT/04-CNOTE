/* :SCRIPT:04-CNOTE  $TITLE  Write Notelist in Computer Music Format *//*Modified:2001/07/02 - TY  - Added code to handle muted multichannel outputs*//* General subroutines to emit notelist data and edit record data, followed.  by driver to emit notelists in Computer Music format */DCL LOWER.KEY    LIT ' 64'; /* THIS BIT IS SET IN 4-WORD RECORDS TO LOWER KEY BY 1 OCTAVE */DCL RAISE.KEY    LIT '128'; /* THIS BIT IS SET IN 4-WORD RECORDS TO RAISE KEY ONE OCTAVE */NUM_PUSH:  procedure(LINE,VAL,DP); /* append integer VAL onto LINE */   dcl LINE            array;   dcl (VAL,I,GO,R,DP) fixed;   if VAL<0 then do; /* negative number */      call PBYTE(LINE, LINE(0), A.MINUS);      LINE(0) = LINE(0) + 1;      VAL = -VAL;   end;   GO = 0; /* turn off print flag */   do I = 0 to 4; /* loop over digits */      R = 0; /* assume zero digit */      if VAL >= POWERS(I) then do; /* non-zero digit */         R   = VAL/POWERS(I);         GO  = 1;         VAL = VAL - R*POWERS(I);      end;      if (DP=1) and (I=4) then do; /* decimal point */         call PBYTE(LINE, LINE(0), A.PERIOD);         LINE(0) = LINE(0) + 1;      end;      if (GO) or (I>(4-DP)) or (I=4) then do; /* add digit to line */         call PBYTE(LINE, LINE(0), A.0+R);         LINE(0) = LINE(0) + 1;      end;   end; /* of loop over digits */end NUM_PUSH;PUSH:  procedure(LINE,STRING); /* append STRING onto LINE */   dcl (LINE,STRING) array;   dcl I             fixed;   do I = 0 to STRING(0)-1; /* loop over chars in STRING */      call PBYTE(LINE, LINE(0), byte(STRING, I));      LINE(0) = LINE(0) + 1;   end;end PUSH;EMIT_PI:  proc(LINE,KEY_NO,N); /* emit pitch according to key for track N */   dcl LINE              array;   dcl (KEY_NO,N)        fixed;   dcl (ACC,OCTAVE,NOTE) fixed;   dcl (I,K)             fixed;   OCTAVE = KEY_NO / 12; /* determine octave and note in octave */   if ACCI(N) then NOTE = FLAT_NOTE_CHARS  (KEY_NO mod 12); /* get coded representation of note */   else            NOTE = SHARP_NOTE_CHARS (KEY_NO mod 12);   ACC = NOTE & UBYTE; /* extract accidental */   K = KEY_CODES(KEY(N)); /* get number of sharps or flat */   if      K > 0 then do I = 1 to  K; /* sharps */      if NOTE = (SH \ SHARP_TABLE(I)) then ACC = 0; /* already in keysig */      if NOTE =       SHARP_TABLE(I)  then ACC = NA; /* natural out */   end;   else if K < 0 then do I = 1 to -K; /* flats */      if NOTE = (FL \ FLAT_TABLE(I) ) then ACC = 0; /* already in keysig */      if NOTE =       FLAT_TABLE(I)   then ACC = NA; /* natural out */   end;   BUFF(0) = 1;  BUFF(1) = NOTE & LBYTE; /* extract note value */   call PUSH (LINE,BUFF); /* push note value */   if      ACC = SH then call PUSH (LINE,'#'); /* push sharp   */   else if ACC = FL then call PUSH (LINE,'F'); /* push flat    */   else if ACC = NA then call PUSH (LINE,'N'); /* push natural */   call NUM_PUSH (LINE,OCTAVE,0); /* push octave number */end EMIT_PI;/* $SUBTITLE  Routines to Dump Information for Notelists */EMIT_VOL:  proc(LINE,VOL); /* output volume info:  0-255 mapped to 0-100.0 */   dcl LINE array;   dcl VOL  fixed;   VOL=VOL*1000/255; /* compute 0-1000 volume */   if read(4)>=128 then VOL=VOL+1; /* round up */   call NUM_PUSH(LINE,VOL,1);end EMIT_VOL;EMIT_RTE:  proc(LINE,RTE); /* output rte info:  mapped 0-100.0 */   dcl LINE array;   dcl RTE  fixed;   RTE=RTE*1000/225; /* compute 0-1000 */   if read(4)>=113 then RTE=RTE+1;   call NUM_PUSH(LINE,RTE,1);end EMIT_RTE;emit.startloop:  proc(i);   dcl i fixed;   call new.line; call outs('  Startloop ');   call outt(seqdata(seq.ils.ptcs+i),seqdata(seq.ils.plts+i),times(i),code(i),0);   seqdata(seq.ils.ptrs+i)=0; /* indicate startloop done */end emit.startloop;emit.endloop:  proc(i);   dcl i fixed;   call new.line; call outs('  Endloop   ');   call outt(seqdata(seq.ile.ptcs+i),seqdata(seq.ile.plts+i),times(i),code(i),0);   seqdata(seq.ile.ptrs+i)=0; /* indicate endloop done */end emit.endloop;thd.lookup:proc(tk,thd);   dcl (tk,thd) fixed;   write(mam)=DT_PTR(tk);   write(mal)=thd;   return read(md);end thd.lookup;write.notelist.header:  proc(i); /* notelist statment and overall info */   dcl (i,j,k,l,m,n) fixed;  if syn.med=0 then outw.lim=seq.ptr+DT_PTR(i); /* set output limit equal to start of data */  call new.line; /* blank line before notelist */  call new.line; call outs('Notelist Timbre');   if syn.med<>2 then do;     call outi(i+1,false);  end;  else do;     call outi(thd.lookup(i,thd.stimb)-num.kbd.trks+1,false);  end;  call outs('  Track ');call outi(i+1,false); /* emit track number for new compiler */  j = key_codes(key(i)); /* look up key type code */  buff(0) = 2; buff(1) = key_majors(j+8); /* get major key bame */  call new.line; call outs('  KeySig '); call outs(buff);  if key(i) > 21 then do; /* indicate actual minor key in comment */     call outs(' /* '); buff(1) = key_names(key(i)); call outs(buff);     call outs(' minor */');  end;  if syn.med<>2 then j=seqdata(seq.xpos.data+i);  else j=thd.lookup(i,thd.sxpos);  if j<>0 then do;           /* transpose */    call new.line; call outs('  Transpose ');    if syn.med<>2 then do;       j=(seqdata(seq.xpos.data+i)+1024+2048)*12/1024; /* compute pitch # 0-60 */       if read(4)>=512 then j=j+1;                     /* round in case of transpose w/octratio */    end;    else j=j+36;                                    /* get abs pitch # */    if j<0 then j=0; if j>84 then j=84;    P_LINE(0) = 0;    call EMIT_PI(P_LINE,J,I);                       /* generate pitch code */    call outs(P_LINE);                              /* emit */  end;  if syn.med<>2 then j=i;                           /* get timbre # */  else j=thd.lookup(i,thd.stimb)-num.kbd.trks;  if port.active(j) then do;                        /* emit glidefrom for portamento */    call new.line; call outs('  Glidefrom ');    if syn.med<>2 then do;       j=seqdata(seq.firsts+i);     end;    else do;       j=thd.lookup(i,thd.slpitch);    end;    j=(j+1024)*12/1024; /* compute pitch # 0-84 */    if read(4)>=512 then j=j+1;                if j<0 then j=0; if j>84 then j=84;    P_LINE(0) = 0;    call EMIT_PI(P_LINE,J,I); /* generate pitch code */    call outs(P_LINE); /* emit */  end;  if syn.med=2 then do;    /* check midi,tvol,trou,tpan,oratio,scale */     j=thd.lookup(i,thd.midi);     if j<>0 then do;              call new.line; call       outs('  MidiOut    ');        call outn(j,0,true);     end;     j=thd.lookup(i,thd.active.midi.rtes);     if (j<>0) & (j<>DEFAULT.ACTIVE.MIDI.RTES) then do;              call new.line; call       outs('  MidiRtes   ');        call outn(j&32767,0,true);     end;     j=thd.lookup(i,thd.tvol);     if j<>1000 then do;           call new.line; call       outs('  TrackVol   ');        call outn(j,1,true);     end;     j=thd.lookup(i,thd.trou);	  call new.line; call          outs('  MultiOut   ');	  if ((j&(!255)) == 0)	outi(0,false);	  else						outi((shr(j,8)&63)+1,false);	  call outs(' ');	  if ((j&(255)) == 0)	outi(0,true);	  else						outi((j&63)+1,true);     j=thd.lookup(i,thd.tpan);     if j<>0 then do;           call new.line; call       outs('  TrackPan     ');        call outi(j,true);     end;     j=thd.lookup(i,thd.oratio);     if j<>1000 then do;           call new.line; call       outs('  TrackRatio ');        call outn(j,3,true);     end;     k=0;                      /* assume no scale info required */     do l=0 to 11; /* check each entry */        m=(l*1024+6)/12; /* compute what scale should be */        if m<>thd.lookup(i,thd.scale+l) then k=1;     end;     if (k) then do; /* emit scale */        call new.line; call outs('  TrackScale ');        do l=0 to 11;           m=12000*thd.lookup(i,thd.scale+l)/1024; /* compute number */           if read(4)>=512 then m=m+1; /* round up */           n=thd.lookup(i,thd.scale+l) mod 256; /* compute step relative to semitone */           if n=85 then m=m+4; if n=171 then m=m-4; /* compute exact for semitones */           call outn(m,3,true);        end;     end;     j=thd.lookup(i,THD.POLY);     if j<>0 then do;           call new.line; call       outs('  TrackPolyB ');        call outi(j+1,false);     end;     j=thd.lookup(i, THD.ACTIVE);     if ((j&B.SOLOED.TRK)<>0) then do;           call new.line; call       outs('  TrackSolo');     end;	     j=thd.lookup(i, THD.TRACK.TITLE);     if (j != 0) then do;           call new.line; call       outs('  TrackName ');        call outb(A.APOST);		  k = 0;        while (k < j)		  {		     l = thd.lookup(i, THD.TRACK.TITLE + 1 + shr(k,1));						  if ((k&1) != 0)			  	  l = shr(l,8);		  		     l = l & 0xFF;			  if (l < 32)			  	 outb(32);			  else if (l != A.APOST)			  	 outb(l);			  else			  	 {outb(l); outb(l);}			  k = k + 1;		  }        call outb(A.APOST);     end;     j=thd.lookup(i,THD.GROUPLIST);     if j<>0 then do; 	 	dcl (but)     fixed;		dcl (members) fixed;		dcl (member)  fixed;				call new.line; call       outs('  GrpButtons ');				do l = 0 to 3;			write(mam)=nah.ptr+j;			write(mal)=GRPAUX.BUT+l;			but=read(mdi); 		           call outn(but-1,0,true);		end;		        write(mam)=nah.ptr+j;		write(mal)=GRPAUX.NUM;		members=read(mdi);				call new.line; call       outs('  GrpHowMany ');        call outn(members,0,true);		do l = 0 to members-1;					if (l == 0)				{call new.line; call       outs('  GrpMembers ');}			else if ((l&7) == 0)				{call new.line; call       outs('             ');}							write(mam)=nah.ptr+j;			write(mal)=GRPAUX.LST+l;			member=read(md);            			call outn(member-1,0,true);		end;	end;	  end;end write.notelist.header;/* $SUBTITLE  Notelist Emitting Routine *//* bit definitions for RTE bits: */dcl b.gfsw  lit '(01*256)'; /* glide foot switch */dcl b.rfsw  lit '(02*256)'; /* repeat foot switch */dcl b.afsw  lit '(04*256)'; /* arpeggiate foot switch */dcl b.gui   lit '(08*256)'; /* guitar note bit */dcl b.tie   lit '(16*256)'; /* tied note */dcl b.vol   lit '(32*256)'; /* volume data */dcl b.art   lit '(64*256)'; /* re articulated guitar glide */dcl b.updt  lit '(128*256)'; /* update record */write.cnotelist:  proc(N); /* emit notes for track N in Computer Music format */  dcl N              fixed; /* track number */  dcl (carries,last)        fixed;  dcl (key_no,dur,durmsb)   fixed; /* key and duration of note */  dcl start.measure         fixed; /* time at which measure starts */  dcl start.measure.carries fixed;  dcl measure.per           fixed; /* milliseconds per measure */  dcl (i,j,k,l)             fixed;  dcl (nmsb,nlsb)           fixed;  dcl (more)                fixed;  dcl (nlsp)                fixed; /* nls pointer              */  dcl (wd)                  fixed;  if syn.med<>2 then do;     start.measure = 8; /* measure 1 begins at time 0 or half tick 8 */     start.measure.carries=0;     measure.per   = 2 * (click_rate * beat_meas(N) * tempo) / beat_note(N); /* half-ticks */     measure_cnt   = 1; /* count from measure 1 */  end;  else do;     start.measure = zero.time; /* measure 1 begins at zero.time */     start.measure.carries=0;     measure.per   = (click_rate * beat_meas(N) * tempo) / beat_note(N); /* milliseconds/measure */     measure_cnt   = 1; /* count from measure 1 */     nlsp=thd.lookup(n,thd.for);     nmsb=0; nlsb=0;  end;  carries=0; /* clear carries */  last=0;  rel.seconds=0; rel.mills=0; /* intialize relative start time */  rel.hours=0; rel.minutes=0; rel.secs=0; rel.frame#=0;  rel.frame.msb=0; rel.frame.lsb=0;  more = 1;                   /* assume more              */  wd   = 0;                   /* init wd to illegal value */  morenotes:;  if syn.med<>2 then do;     note_data1=n.lookup(DT_PTR(N)); /* get first word of note info */     if note_data1=0 then more=0;  end;  else do;     nextnls:;     if nlsp=0 then more=0;          /* no note list segment */     else do;        write(mam)=nah.ptr+nlsp;        if wd=0 then do;             /* first time through - init wd pointer */           write(mal)=nls.fp;           wd=read(md);                 /* get ptr to start     */        end;        write(mal)=wd;        note_data1=read(mdi);        /* get first word       */        if note_data1=nls.eos then do;           write(mam)=nah.ptr+nlsp;           write(mal)=nls.for;           nlsp=read(md);           wd  =0;           goto nextnls;        end;        note_data2=read(mdi);        /* get second word      */        if note_data1 then do;           note_data3=read(mdi);           note_data4=read(mdi);        end;        else do;           note_data3=225;           note_data4=vel.note;        end;     end;  end;  if more <> 0 then do;     /* loop until zero word at end */    if syn.med<>2 then do;      if syn.med=0 then outw.lim=seq.ptr+DT_PTR(N); /* set up output limit */      note_data2=n.lookup(DT_PTR(N)+1); /* get second word of note info */      if (note_data1&"177776") < shl(last,1) then note_Data1=(note_data1&1)\shl(last,1); /* oops - notelist is out of order - happens during justify overdub (unfortunately) - just delay this note (as performed) */      if shr(note_data1,1) ILT last then carries=carries+1; /* count wrap around */      last   = shr(note_data1,1); /* store to check for wrap around */      key_no = note_data2 & MASK6; /* extract key number */      if seqdata(seq.ils.ptrs+N)<>0 then do; /* check ind loop start */        i=carries-seqdata(seq.ils.ptcs+N);        if (i>0) or ((i=0) and (note_data1 IGE seqdata(seq.ils.plts+N)))        then call emit.startloop(N); /* start of ind loop */      end;      if seqdata(seq.ile.ptrs+N)<>0 then do; /* check ind loop end */        i=carries-seqdata(seq.ile.ptcs+N);        if (i>0) or ((i=0) and (note_data1 IGE seqdata(seq.ile.plts+N)))        then call emit.endloop(N); /* end of ind loop */      end;      i=(note_data1-start.measure)/measure.per; /* check number of new measures */      if i > 0 then do; /* this is new measure */        call new.line; call outs('/* Measure ');        measure_cnt=measure_cnt+i; /* bump measure number */        call outi(measure_cnt,false);        call outs(' begins at ');        j=start.measure; /* store to check for wrap */        start.measure=start.measure+i*measure.per; /* start of measure */        if start.measure ILT j then do; /* wrap */          start.measure.carries=start.measure.carries+1;          start.measure=start.measure+2; /* add 2 half ticks */        end;        call outt(start.measure.carries,start.measure,times(N),code(N),0); call outs(' */');      end; /* of new measure */      if key_no <> REST.NOTE then do; /* emit note line */        key_no=key_no+12;        /* offset by 1 octave for following routine */        if (note_data1) then do; /* 4 word record:  get next two words */          note_data3 = n.lookup(DT_PTR(N)+2); /* get next two records */          note_data4 = n.lookup(DT_PTR(N)+3);          if (note_data4&lower.key)<>0 then key_no=key_no-12;          else if (note_data4&raise.key)<>0 then key_no=key_no+12;        end;        /* emit note record - start time, pitch, duration, volume, (RTE)  T */        call new.line;        call outt(carries,note_data1,times(N),code(N),1); /* print starting time */        call outb(A.SP); call outb(A.SP);        P_LINE(0) = 0;  call EMIT_PI(P_LINE,KEY_NO,N); /* generate pitch code */        if P_LINE(0)=2 then call PUSH(P_LINE,' '); /* add space to line up */        call outs(P_LINE); /* emit */        if (note_data1) and ((note_data3&b.updt)<>0) then dur = 0; /* zero dur for update record */        else do; /* compute duration */          dur = shr(note_data2,6) & LBYTE; /* get duration information */          dur = dur * dur.table(rot(note_data2,2)&MASK2); /* scale ticks */          if cs.seq then dur = shl(dur,1); /* double ticks if cs data */        end;        call outt(0,shl(dur+4,1),0,code(N),0); /* emit note duration (fudged for time format) */        if (note_data1) then do; /* 4 word record:  emit rte/vol info */          P_LINE(0) = 0; /* clear work area for note attributes */          if (note_data3&b.updt)<>0 then do; /* update note */            call PUSH(P_LINE,'  U(');            call NUM_PUSH(P_LINE,note_data2/64,0); /* generate update amount */            call PUSH(P_LINE,')');          end;          if (note_data3&b.gui)=0 then do; /* regular note */            if (note_data3&b.gfsw)<>0 then call PUSH(P_LINE,'  P'); /* glide  foot sw */            if (note_data3&b.rfsw)<>0 then call PUSH(P_LINE,'  R'); /* repeat foot sw */            if (note_data3&b.afsw)<>0 then call PUSH(P_LINE,'  A'); /* arpeggiate foot sw */          end; /* of regular note */          else do; /* guitar note */            call PUSH(P_LINE,'  G('); /* emit string number */            call NUM_PUSH(P_LINE,(shr(note_data3,8)&"7")+1,0);            call PUSH(P_LINE,')');          end; /* of guitar note */          if (note_data3&b.tie)<>0 then call PUSH(P_LINE,'  S'); /* tied note */          if (note_data3&b.art)<>0 then call PUSH(P_LINE,'  M'); /* re-art attack */          if (note_data3&b.vol) <>0 /* emit vol for update recs or if bit set */          or (note_data3&b.updt)<>0 then do;            call PUSH(P_LINE,'  ');            call EMIT_VOL(P_LINE,shr(note_data4,8)); /* output volume */          end;          if (note_data3&LBYTE)<>225 then do; /* output real time effects */            call PUSH(P_LINE,'  (');            call EMIT_RTE(P_LINE,note_data3 & LBYTE);            call PUSH(P_LINE,')');          end;          call outs(P_LINE); /* emit note attributes */        end; /* of four word record */        note_cnt = note_cnt + 1;  /* count note record */      end; /* of emit note line */      if note_data1 then DT_PTR(N) = DT_PTR(N) + 4;      else               DT_PTR(N) = DT_PTR(N) + 2;    end;    else do;             /* 32 track format */      i=shr(note_data1,1)&1023;         /* get delta to start */      nlsb=nlsb+i;                      /* get start time     */      if nlsb ilt i then nmsb=nmsb+1;      key_no = note_data2 & MASK6;      /* extract key number */      if  ((nmsb igt start.measure.carries))      or  ((nmsb  =  start.measure.carries)      and  (nlsb ige start.measure        ))      then do;                          /* this note is after measure start */         i=nlsb-start.measure;         if nlsb ilt start.measure         then j=nmsb-start.measure.carries-1;         else j=nmsb-start.measure.carries;         write(5)=i; write(4)=j; write(7)=measure.per;         i=read(5);                     /* number of measures to skip */         if i > 0 then do; /* this is new measure */           call new.line; call outs('/* Measure ');           measure_cnt=measure_cnt+i; /* bump measure number */           call outi(measure_cnt,false);           call outs(' begins at ');           j=start.measure; /* store to check for wrap */           write(5)=i; write(6)=measure.per;           start.measure.carries=start.measure.carries+read(4);           start.measure        =start.measure        +read(5);           if start.measure ilt read(5)           then start.measure.carries=start.measure.carries+1;           call outt(start.measure.carries,start.measure,times(N),code(N),0); call outs(' */');        end;      end;       if (note_data1&"174001")="100001" then do; /* extended rest note */         nmsb=nmsb+note_data2;         nlsb=nlsb+note_data3;         if nlsb ilt note_data3         then nmsb=nmsb+1;      end;      else if (note_data1&"174001")="104001" then do;  /* ilp start */         call new.line; call outs('  Startloop ');         call outt(nmsb,nlsb,times(i),code(i),0);      end;      else if (note_data1&"174001")="110001" then do; /* ilp end    */         call new.line; call outs('  Endloop   ');         call outt(nmsb,nlsb,times(i),code(i),0);      end;      else if key_no <> REST.NOTE then do; /* emit note line */        key_no=key_no+12;        /* offset by 1 octave for following routine */        if (note_data4&lower.key)<>0 then key_no=key_no-12;        else if (note_data4&raise.key)<>0 then key_no=key_no+12;        /* emit note record - start time, pitch, duration, volume, (RTE)  T */        call new.line;        call outt(nmsb,nlsb,times(N),code(N),1); /* print starting time */        call outb(A.SP); call outb(A.SP);        P_LINE(0) = 0;  call EMIT_PI(P_LINE,KEY_NO,N); /* generate pitch code */        if P_LINE(0)=2 then call PUSH(P_LINE,' '); /* add space to line up */        call outs(P_LINE); /* emit */        if ((note_data3&b.updt)<>0) then do;           dur = 0; durmsb=0; /* zero dur for update record */        end;        else do; /* compute duration */          i=shr(note_data1,11)&15;          j=shr(note_data2,6)&1023;          dur=j\shl(i&3,10);         /* get 12 bit field */          write(5)=dur; write(6)=new.dur.table(shr(i,2));          durmsb=read(4); dur=read(5);          dur=dur+zero.time;         /* fudget for call to outt */          if dur ilt zero.time then durmsb=durmsb+1;        end;        call outt(durmsb,dur,0,code(N),0); /* emit note duration (fudged for time format) */        if (note_data1) then do; /* 4 word record:  emit rte/vol info */          P_LINE(0) = 0; /* clear work area for note attributes */          if (note_data3&b.updt)<>0 then do; /* update note */            call PUSH(P_LINE,'  U(');            call NUM_PUSH(P_LINE,note_data2/64,0); /* generate update amount */            call PUSH(P_LINE,')');          end;          if (note_data3&b.gui)=0 then do; /* regular note */            if (note_data3&b.gfsw)<>0 then call PUSH(P_LINE,'  P'); /* glide  foot sw */            if (note_data3&b.rfsw)<>0 then call PUSH(P_LINE,'  R'); /* repeat foot sw */            if (note_data3&b.afsw)<>0 then call PUSH(P_LINE,'  A'); /* arpeggiate foot sw */          end; /* of regular note */          else do; /* guitar note */            call PUSH(P_LINE,'  G('); /* emit string number */            call NUM_PUSH(P_LINE,(shr(note_data3,8)&"7")+1,0);            call PUSH(P_LINE,')');          end; /* of guitar note */          if (note_data3&b.tie)<>0 then call PUSH(P_LINE,'  S'); /* tied note */          if (note_data3&b.art)<>0 then call PUSH(P_LINE,'  M'); /* re-art attack */          if (note_data3&b.vol) <>0 /* emit vol for update recs or if bit set */          or (note_data3&b.updt)<>0 then do;            call PUSH(P_LINE,'  ');            call EMIT_VOL(P_LINE,shr(note_data4,8)); /* output volume */          end;          if (note_data3&LBYTE)<>225 then do; /* output real time effects */            call PUSH(P_LINE,'  (');            call EMIT_RTE(P_LINE,note_data3 & LBYTE);            call PUSH(P_LINE,')');          end;          call outs(P_LINE); /* emit note attributes */        end; /* of four word record */        if note_data1 >= 0 then note_cnt = note_cnt + 1; /* not alternate format or rest - count note */      end; /* of emit note line */      if note_data1 then wd = wd + 4;      else               wd = wd + 2;    end;    goto morenotes;  end; /* of loop until zero word at end */  if syn.med<>2 then do;     if seqdata(seq.ils.ptrs+N)<>0 then call emit.startloop(N); /* start loop after last note */     if seqdata(seq.ile.ptrs+N)<>0 then call emit.endloop  (N); /* end   loop after last note */  end;end write.cnotelist;