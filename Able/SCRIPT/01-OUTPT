/* 01-OUTPT  $TITLE  Output routines for SCRIPT reverse compiler */dcl ofbufln          lit '(4*1024)'; /* use a 4K buffer */dcl ofbuf(ofbufln-1) fixed;dcl powers           data (10000,1000,100,10,1); /* powers of ten for numeric conversion */dcl (ofdevice,ofstart)            fixed; /* device has upper bits of start */dcl (oflngth,ofmaxln,ofpos)       fixed;dcl (ofsec,oftyp,word,bc,line.no) fixed;dcl outw.lim      fixed; /* set on the fly for output limits */dcl limit.reached fixed; /* set true when output limit reached */outf:  proc; /* procedure to force buffer - we know it is in .WORK */   dcl i fixed;   if ofpos<>0 then do; /* if something is in buffer */      if ofstart+ofsec ILT ofstart then i=1; else i=0;      call writedata(ofdevice+i,ofstart+ofsec,ofbuf,ofpos); /* write this section */      ofsec=ofsec+shr(ofpos+255,8); /* move to next sector */      ofpos=0; /* reset buffer position */   end;end outf;outw:  proc(w); /* output word to file */   dcl w fixed;   if limit.reached then return; /* skip if already past limit */   if oflngth IGE ofmaxln /* file too big */   then do; limit.reached=1; return; end;   if oftyp=0 then do; /* disk file */      if ofpos=ofbufln then call outf; /* force buffer */      ofbuf(ofpos)=w; /* store word */      ofpos=ofpos+1; /* advance pointer */   end;   else do; /* .WORK is in memory */      if (ofstart+oflngth) IGE outw.lim /* output file has caught up to input */      then do; limit.reached=1; return; end;      core(ofstart+oflngth)=w; /* store word */   end;   oflngth=oflngth+1; /* bump length of output file */   if systyp=0 then write("104")=0; /* keep disk head loaded */end outw;set.up.output:  proc; /* set up pointers */   dcl i fixed;   if core(loc.wmed)=0 then do;      /* work file on disk */      ofdevice = core(loc.wsec+1);   /* device     of work file */      ofstart  = core(loc.wsec);     /* start      of work file */      ofmaxln  = core(loc.wlen);     /* max length of work file */   end;   else do;                          /* work file in main memory */      ofdevice = 0;                  /* not really used */      ofstart  = core(loc.wsec)+256; /* start      of work file */      ofmaxln  = core(loc.wlen)-256; /* max length of work file */   end;   oftyp    = core(loc.wmed);        /* media */   oflngth  = 0;  ofpos = 0;  ofsec = 0; /* start at zero length */   limit.reached = 0;                /* limit has not been reached */   if core(loc.wsln) IGE 256 then ofmaxln=shl(255,8); /* limit max length */    i=core(core(1))+core(core(1)+1)+core(core(1)+2); /* get length of ourselves */   if (oftyp=1) and (ofstart ILT i) then do;  /* see if .WORK file is below us */      ofmaxln=(ofmaxln-(i-ofstart))&"177400"; /* adjust for shorter max work file */      ofstart=i;   end;   line.no=1;                               /* number lines from 1, by 1 */   if syn.med=0 then outw.lim=prm.ptr;      /* stop output at first word of parameters for now */   else              outw.lim=mem.siz-1024; /* else just protect upper 1024 words of memory */   call outw(line.no); line.no=line.no+1;   /* emit start of first line */   bc=0;                                    /* clear byte flag */end set.up.output;/* $SUBTITLE  Routines to Emit String, Integer, Scaled Number, and Frame */outb:  proc(b); /* output one byte */   dcl b fixed;   if bc=0 then word=b; /* if no byte carry then save this byte */   else         call outw(word\shl(b,8)); /* have complete word - output it */   bc=bc xor 1; /* flip byte toggle */end outb;outs:  proc(s); /* output a string */   dcl s array;   dcl i fixed;   do i=0 to s(0)-1; call outb(byte(s,i)); end;end;new.line:  proc; /* start a new line in the output file */   if bc then call outw(word); /* write upper byte of 0 */   else       call outw(0); /* else emit word of zeroes */   call outw(line.no); line.no=line.no+1; /* send line number and increment */   bc=0; /* clear byte carry */end new.line;outn:  proc(n,dp,fill); /* output a number, with decimal point and opt fill */   dcl (n,dp,i,r)           fixed;   dcl (fill,go,minus.flag) boolean;   go=false;  minus.flag=false; /* no zeroes yet */   if dp=0 then call outb(A.SP); /* no dp - use extra leading space */   if n<0 then do; /* negative value */      n=(-n);      minus.flag=true;   end;   else if fill then call outb(A.SP); /* allow extra space if positive */   do i=0 to 4; /* loop over 5 digits */      r=0; /* init to zero */      if n ige powers(i) then do; /* got a positive digit */         write(5)=n; write(7)=powers(i);  /* use unsigned math to Handel -32768 */         r=read(5); n=read(4);            /* get remain & mod */         go=true; /* turn printing on */      end;      if dp=(4-i) then go=true; /* output 1 char before dp */      if (go) and (minus.flag) then do; call outb(A.MINUS); minus.flag=false; end;      if      go   then call outb(A.0+r); /* output digit */      else if fill then call outb(A.SP); /* space fill */      if (dp<>0) and (dp=(4-i)) then call outb(A.PERIOD); /* put out period */   end; /* of loop over digits */end outn;outi:  proc(n,fill); /* output positive integer - flag to print leading spaces */   dcl (n,i,r)   fixed;   dcl (fill,go) boolean; /* fill: true => print leading zeroes */   go=false;   n=abs(n); /* make sure it is positive */   do i=0 to 4; /* loop over digits */      r=0; /* assume digit is zero */      if n>=powers(i) then do; /* got a positive digit */         r=n/powers(i); /* compute digit */         go=true; /* turn on printing */         n=n-r*powers(i); /* reduce value */      end;      if      (go) or (i=4) then call outb(A.0+r); /* output the digit */      else if fill          then call outb(A.SP); /* leading blank */   end;end outi;out2:  proc(i); /* output two digit number (for times) */   dcl i fixed;   call outb(A.COLON);  /* output a colon */   call outb(A.0+i/10); /* upper digit */   call outb(A.0+(i mod 10)); /* second digit */end out2;outframe:  proc(i,j); /* output frame# and fraction */   dcl (i,j) fixed;   if i<100 then call out2(i); /* do :xx */   else          do; call outb(A.SEMICOLON); call outi(i,false); end; /* :frame# */   call outb(A.PERIOD);   call outb(A.0+j);end outframe; outsec:  proc(seconds,milliseconds);   dcl (seconds,milliseconds) fixed;   call outi(seconds,false); /* emit the seconds */   call outb(A.PERIOD);   if milliseconds<100 then call outb(A.0);   if milliseconds<10  then call outb(A.0);   call outi(milliseconds,false);end outsec;outh:  proc(i); /* print hex digit for value */   dcl i fixed;   i=i&"17"; /* mask to four bits */   if i>9 then call outb(A.A+i-10);   else        call outb(A.0+i);end outh;outhword:proc(j);      /* emit hex word with space */   dcl j fixed;   call outh(shr(j,12)); call outh(shr(j,8)); /* put out hex */   call outh(shr(j, 4)); call outh(j);   call outb(A.SP);end outhword;out.note.string:  proc(p); /* output string from note area pointer */   dcl (p,i,j,ch) fixed;   call outb(A.APOST);   do i=1 to n.lookup(p); /* process each byte */      if (i) then j=n.lookup(p+shr(i+1,1));      ch=j&LBYTE;      if (ch<A.SP) or (ch=A.LESS) then do; /* special chars */         call outb(A.LESS); call outb(A.A+ch-1); call outb(A.GREATER);      end;      else call outb(ch); /* regular chars */      j=shr(j,8); /* get other byte */   end;   call outb(A.APOST);end out.note.string;out.inf.string:  proc(p); /* output string from inf area pointer */   dcl (p,i,j,ch) fixed;   call outb(A.APOST);   do i=1 to i.lookup(p); /* process each byte */      if (i) then j=i.lookup(p+shr(i+1,1));      ch=j&LBYTE;      if (ch<A.SP) or (ch=A.LESS) then do; /* special chars */         call outb(A.LESS); call outb(A.A+ch-1); call outb(A.GREATER);      end;      else call outb(ch); /* regular chars */      j=shr(j,8); /* get other byte */   end;   call outb(A.APOST);end out.inf.string;outpi:  proc(key); /* emit a pitch in sharps without keysig processing, C0-C7 */   dcl (key,octave,note) fixed;   octave = key / 12;   note   = SHARP_NOTE_CHARS (key mod 12);   call OUTB (note&255);   if (note&UBYTE) =  SH then call OUTB (A.SHARP);   call OUTB (A.0+octave);   if (note&UBYTE) <> SH then call OUTB (A.SP);end outpi;#pnum:  proc(n,fill); /* print positive integer - flag to print leading spaces */   dcl (n,i,r)   fixed;   dcl (fill,go) boolean; /* fill:  if true, then print leading zeroes */   go=false;   n=abs(n); /* make sure it is positive */   do i=0 to 4; /* loop over digits */      r=0; /* assume digit is zero */      if n>=powers(i) then do; /* got a positive digit */         r=n/powers(i); /* compute digit */         go=true; /* turn on printing */         n=n-r*powers(i); /* reduce value */      end;      if (go) or (i=4) then write("50")=(A.0+r); /* output the digit */      else if fill     then write("50")=A.SP;   end;end #pnum;dcl PNUM lit 'call #pnum';/* $SUBTITLE  Output Starting Time Routine */dcl (seconds,    milliseconds)                  fixed;dcl (rel.seconds,rel.mills)                     fixed; /* used for relative times */dcl (rel.hours,rel.minutes,rel.secs,rel.frame#) fixed;dcl (rel.frame.msb,rel.frame.lsb)               fixed;outt:  proc(carries,time,rel.flag,code,update);   dcl (carries,time) fixed;   /* time to print */   dcl rel.flag       boolean; /* true for relative time coding */   dcl code           fixed;   /* SECOND, FRAME, FRMS_ONLY */   dcl update         boolean; /* true to add time to relative time base */   dcl (hours,minutes,secs,frame#) fixed;   dcl (msb,lsb,i,j,k)             fixed;   if syn.med<>2 then do;       /* 5 msec */      if carries=0 then if time ILT 8 then time=8; /* check for start time < 8 */      if time ILT 8 then carries=carries-1; /* offset by 8 units */      time=time-8; /* compute carries and time relative to 0.000 */      write(5)=shr(time,1); write(6)=5; /* 5 milliseconds per tick of 2 */      msb=read(4); lsb=read(5); /* 32 bit #, units of ms. */      write(5)=carries*5; write(6)=32767; /* 32767 5 ms periods per carry */      msb=msb+read(4); /* add in msb */      lsb=lsb+read(5);      if lsb ILT read(5) then msb=msb+1; /* carry */      write(5)=lsb; write(4)=msb; write(7)=1000; /* compute seconds, ms */      seconds=read(5); milliseconds=read(4);   end;   else do;      if carries=0 then if time ILT zero.time then time=zero.time; /* check for start time < zero.time */      if time ILT zero.time then carries=carries-1;       time=time-zero.time;      write(5)=time; write(4)=carries; write(7)=1000;  /* milliseconds/1000 */      seconds=read(5); milliseconds=read(4);   end;   if code<>SECOND then do; /* compute frame # as well */      hours=0; minutes=0; secs=0; frame#=0; /* initialize */      write(5)=seconds; write(6)=frame_rate; /* compute 32 bit frame # */      msb=read(4); lsb=read(5);      write(5)=milliseconds; write(6)=frame_rate; /* and for ms. */      i=read(5); /* for hardware bug */      write(7)=1000; /* correct for milliseconds - computes frames */      lsb=lsb+read(5);      if lsb ILT read(5) then msb=msb+1;      secs=seconds; /* start with seconds */      hours=secs/3600; secs=secs mod 3600;      minutes=secs/60; secs=secs mod 60;      frame#=milliseconds*frame_rate/1000; /* get frame#*100 */   end; /* of compute frame number */   if (rel.flag) then do; /* subtract out relative base */      seconds=seconds-rel.seconds; milliseconds=milliseconds-rel.mills;      if milliseconds<0 then do; /* correct wrap */         seconds=seconds-1; milliseconds=milliseconds+1000;      end;      msb=msb-rel.frame.msb; /* subtract msb's */      if lsb ILT rel.frame.lsb then msb=msb-1; /* will be carry shortly */      lsb=lsb-rel.frame.lsb; /* and lsb's */      if msb<0 then do; msb=0; lsb=0; end; /* can happen with rounding */      frame#=frame#-rel.frame#; secs=secs-rel.secs;      minutes=minutes-rel.minutes; hours=hours-rel.hours;      if frame#<0 then do; /* add frame rate */         frame#=frame#+frame_rate; secs=secs-1;      end;      if secs<0    then do; secs=secs+60;       minutes=minutes-1; end;      if minutes<0 then do; minutes=minutes+60; hours=hours-1;     end;      if hours<0   then do; frame#=0; secs=0; minutes=0; hours=0;  end;   end; /* of subtract out relative base */   if (rel.flag) then do; /* indicate relative format */      call outb(43); /* output a + sign */      if (seconds<10) \(code<>SECOND) then call outb(A.SP);   end;   else do; /* indicate absolute time */      if (seconds<100)\(code<>SECOND) then call outb(A.SP); /* one leading space  */      if (seconds<10) \(code<>SECOND) then call outb(A.SP); /* two leading spaces */   end;   /* $SUBTITLE  Now that data has been computed, write to file in proper format */   if code<>SECOND then do; /* output frame - absolute or relative */      write(5)=lsb; write(4)=msb; /* see if too large for frames only format */      write(7)=29998; /* by seeing if too big */      if (read(5)<100) and (code=FRMS_ONLY) then do; /* frames only */         write(5)=lsb; write(4)=msb; /* compute numbers */         write(7)=100; /* compute frames */         i=read(5); j=read(4); /* get frame# and remainder */         j=j+5;         if j>=100 then do; j=j-100; i=i+1; end; /* round */         j=j/10; /* this is fraction */         write(5)=i; write(6)=100; /* compute new msb and lsb for rounding correction */         msb=read(4); lsb=read(5);         write(5)=j; write(6)=10; /* and fraction */         lsb=lsb+read(5);         if lsb ILT read(5) then msb=msb+1;         call outframe(i,j); /* output frame and decimal */      end;      else do; /* output hours:minutes:seconds:frames */         frame#=frame#+5; /* prepare to round the frame count */         if frame#>=frame_rate then do; /* adjust for rate */            secs=secs+1; frame#=frame#-frame_rate;            if secs   >=60 then do; minutes=minutes+1; secs=secs-60; end;            if minutes>=60 then do; hours=hours+1; minutes=minutes-60; end;         end;         frame#=(frame#/10)*10; /* and this is rounded result */         if hours<>0 then do; call out2(hours); call out2(minutes); end;         else             if minutes<>0 then call out2(minutes);         if (hours\minutes\seconds)<>0 then call out2(secs); /* always do seconds */         else                               call outs('   '); /* space over */         call outframe(frame#/100,(frame#/10) mod 10);      end;   end; /* of case for frames */   else call outsec(seconds,milliseconds); /* absolute time */   if (update) then do; /* update relative start times */      if rel.flag then do; /* relative mode */         rel.seconds=rel.seconds+seconds;         rel.mills=rel.mills+milliseconds;         if rel.mills>=1000 then do;            rel.mills=rel.mills-1000; rel.seconds=rel.seconds+1;         end;         rel.frame.msb=rel.frame.msb+msb;         rel.frame.lsb=rel.frame.lsb+lsb;         if rel.frame.lsb ilt lsb then rel.frame.msb=rel.frame.msb+1;         rel.frame#=rel.frame#+frame#;         rel.secs=rel.secs+secs;         rel.minutes=rel.minutes+minutes;         rel.hours=rel.hours+hours;         if rel.frame# >= frame_rate then do;            rel.secs=rel.secs+1; /* 1 more second */            rel.frame#=rel.frame#-frame_rate;         end;         if rel.secs   >=60 then do; rel.minutes=rel.minutes+1; rel.secs=rel.secs-60;end;         if rel.minutes>=60 then do; rel.hours=rel.hours+1; rel.minutes=rel.minutes-60;end;      end;      else do; /* not relative mode - just assign rather than adding */         rel.seconds=seconds; rel.mills=milliseconds;         rel.frame.msb=msb;   rel.frame.lsb=lsb;         rel.frame#=frame#;   rel.secs=secs;         rel.minutes=minutes; rel.hours=hours;      end;   end; /* of case for update */end outt;