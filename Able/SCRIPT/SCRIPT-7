/*	:SCRIPT:SCRIPT-7	*//*Modified:2001/07/02 - TY  - Modified MULTIOUT.STATEMENT() to handle muted multichannel outputs*/END.STATEMENT:  PROC;  IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */  CALL END.OF.NOTELIST;  CALL SCAN; /* GET NEXT TOKEN */END END.STATEMENT;FPS.STATEMENT:  PROC; /* PROCESS FRAMES PER SECOND */  CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */  CALL ADJUST.NUM(2); /* GET FRAMES.XX PER SECOND */  FRAMES.PER.SECOND=INFO; /* SAVE IN GLOBAL VARIABLE */  IF FRAMES.PER.SECOND<100 THEN CALL ER.IFM; /* CAN NOT GO */  CALL SCAN; /* SCAN NEXT STATEMENT */END FPS.STATEMENT;IGNORE.LINE:  PROC; /* SCAN OFF AND IGNORE THE REST OF THIS LINE */  CALL SCAN; /* SCAN TO NEXT */  DO WHILE (TOKEN<>T.STMT) AND (TOKEN<>T.EOF); /* SCAN TIL NEW STATEMENT OR EOF */    CALL SCAN;  END;END IGNORE.LINE;WRITE.EMPTY.TRACKS:  PROC;          /* CLOSE OUT LIST OF TRACKS (MUST BE DONE BEFORE SCAN OF EDIT INFO) */  DCL I FIXED;  CALL END.OF.NOTELIST;             /* CLOSE OFF ANY LAST NOTELIST */  DO I=NEXT.TRACK.NUMBER TO 15;     /* EMIT RECORDS FOR EMPTY TRACKS */    CALL PUSH(TIMBLEN); CALL PUSH(SEQNLEN); /* PUSH POINTERS */    CALL EMIT.NULL.TIMBRE;                  /* EMIT EMPTY TIMBRE INTO NOTELIST */    CALL EMIT.N(FIRST.NOTE); CALL EMIT.N(0);            /* AND EMPTY NOTE LIST */  END;END WRITE.EMPTY.TRACKS;DCL (EDITINF.PTR,EDITINF.LEN) FIXED;EDITINFORMATION.STATEMENT:  PROC; /* READ THE EDIT INFORMATION DUMP */  DCL (I,SUM)    FIXED;  DCL IGNORE.SUM FIXED;  IF RELEASEM=0 THEN DO;     CALL WRITE.EMPTY.TRACKS; /* FLUSH TRACK AREAS */  END;  ELSE DO;     CALL END.OF.NOTELIST;    /* CLOSE OFF ANY LAST NOTELIST */     EDITINF.PTR=SHR(SEQNLEN,8);  END;  EDITINFO.PRESENT=1;  I=0; SUM=0; /* INIT COUNT AND CHECKSUM */  CALL SCAN.AHEAD;  DO WHILE (NCHR<>A.X)      /* LOOP UNTIL 'XXXX' MARKER */     AND   (NCHR<>A.P);     /* OR   UNTIL 'PLOT' MARKER */    CALL SCAN.HEX;          /* READ NUMBER AS HEX */    CALL EMIT.N(INFO);      /* ELSE EMIT THE WORD FOR PRESET AREA */    SUM=SUM+INFO;           /* UPDATE CHECKSUM  */    I=I+1;                  /* COUNT IT */    CALL SCAN.AHEAD;        /*          */  END;  IF RELEASEM<>0 THEN DO;   /* SECTOR BOUNDARY */     DO WHILE (SEQNLEN&255)<>0;        CALL EMIT.N(0);        I=I+1;     END;     EDITINF.LEN=SHR(I,8);  END;  ELSE SEQ.NPPW=I;               /* STORE THE COUNT */  IF NCHR=A.P  THEN IGNORE.SUM=1; /* IF 'PLOT' THEN IGNORE THE CHECKSUM */  ELSE IGNORE.SUM=0; /* NORMALLY DO NOT IGNORE IT          */  CALL PUSH(0); CALL PUSH(SEQNLEN);       /* PUSH POINTERS FOR TOP TRACK */  CALL GET.CHAR; CALL GET.CHAR; CALL GET.CHAR; CALL GET.CHAR; /* SKIP OVER 'XXXX' OR 'PLOT' */  CALL SCAN.AHEAD; CALL SCAN.HEX; I=INFO; /* READ CHECKSUM, STORE IT  */  CALL SCAN.AHEAD;                        /* CHECK FOR OPTIONAL MUSIC REV CODE TRAILING */  IF (NCHR>=A.0)&(NCHR<=A.9) THEN DO;     /* DIGIT - SCAN OF MP REV # */     CALL SCAN.HEX;                       /* GET HEX MP REV */     IF RELEASEM=0     THEN SEQDATA(    SEQ.MPREV)=INFO;    /* STORE IN MISC(83) */     ELSE SEQDATA(NEW.SEQ.MPREV)=INFO;    /* STORE IN MISC(49) */     SUM=SUM+INFO;                        /* ALSO INCLUDED IN CHECK SUM */  END;  IF  (IGNORE.SUM=0)  AND (I<>SUM)  THEN CALL ER.EMES2('Checksum error in EDIT information block');  CALL SCAN; /* SKIP AHEAD */  IF TOKEN<>T.END THEN CALL ER.MEI; /* MISSING END */  ELSE                 CALL SCAN;END EDITINFORMATION.STATEMENT;/* $SUBTITLE  MULTI, SMPTE, TRACK VOL STATEMENT    */MULTI.STATEMENT:        PROC; /* PICK UP MULTI INFO */   DCL (I) FIXED;   IF RELEASEM<>0 THEN CALL ER.RELL;   DO I=0 TO 15;              /* SCAN OFF NUMBERS */      CALL SCAN.AHEAD;        /* GET TO NUMBER    */      CALL SCAN.NUMERIC;      /* GET INFO         */      CALL ADJUST.NUM(0);     /* NO DECIMALS      */      IF (INFO=0) THEN CALL ER.IFM;      ELSE IF INFO>64 THEN CALL ER.TMD;      IF (I&1)=0 THEN SEQDATA(SEQ.TROUT1+SHR(I,1))      =(SEQDATA(SEQ.TROUT1+SHR(I,1))&255)\(SHL((INFO-1)\64,8));                 ELSE SEQDATA(SEQ.TROUT1+SHR(I,1))      =(SEQDATA(SEQ.TROUT1+SHR(I,1))&"177400")\((INFO-1)\64);   END;   DO I=0 TO 15;              /* SCAN OFF NUMBERS */      CALL SCAN.AHEAD;        /* GET TO NUMBER    */      CALL SCAN.NUMERIC;      /* GET INFO         */      CALL ADJUST.NUM(0);     /* NO DECIMALS      */      IF (INFO=0) THEN CALL ER.IFM;      ELSE IF INFO>64 THEN CALL ER.TMD;      IF (I&1)=0 THEN SEQDATA(SEQ.TROUT2+SHR(I,1))      =(SEQDATA(SEQ.TROUT2+SHR(I,1))&255)\(SHL((INFO-1)\64,8));                 ELSE SEQDATA(SEQ.TROUT2+SHR(I,1))      =(SEQDATA(SEQ.TROUT2+SHR(I,1))&"177400")\((INFO-1)\64);   END;   CALL SCAN;       /* GET NEXT TOKEN */END MULTI.STATEMENT;      SMPTE.STATEMENT:        PROC; /* PICK UP SMPTE INFO */   DCL (I) FIXED;   CALL SCAN.AHEAD;           /* GET TO NUMBER    */   CALL SCAN.NUMERIC;         /* GET INFO         */   CALL ADJUST.NUM(0);        /* NO DECIMALS      */   IF (INFO<0) THEN CALL ER.IFM;   ELSE IF INFO>3 THEN CALL ER.TMD;   SEQDATA(SEQ.SMODE)=INFO;   DO I=0 TO 4;               /* SCAN INFO */      CALL SCAN.AHEAD;      IF NCHR<>A.COLON      THEN CALL ER.IFM;       /* OOPS */      ELSE DO;         CALL GET.CHAR;         CALL SCAN.NUMERIC;         CALL ADJUST.NUM(0);         DO CASE(I);            SEQDATA(SEQ.HRSMIN)=(SEQDATA(SEQ.HRSMIN)&"000377")\SHL(INFO,8);            SEQDATA(SEQ.HRSMIN)=(SEQDATA(SEQ.HRSMIN)&"177400")\   (INFO  );            SEQDATA(SEQ.SECFRA)=(SEQDATA(SEQ.SECFRA)&"000377")\SHL(INFO,8);            SEQDATA(SEQ.SECFRA)=(SEQDATA(SEQ.SECFRA)&"177400")\   (INFO  );            SEQDATA(SEQ.SMBITS)=INFO;         END;      END;   END;   CALL SCAN;END SMPTE.STATEMENT;TRVOL.STATEMENT:        PROC; /* PICK UP TRACK VOLUME INFO */   DCL (I) FIXED;   IF RELEASEM<>0 THEN CALL ER.RELL;   DO I=0 TO 15;              /* SCAN OFF NUMBERS */      CALL SCAN.AHEAD;        /* GET TO NUMBER    */      CALL SCAN.NUMERIC;      /* GET INFO         */      CALL ADJUST.NUM(1);     /* 1 DECIMALS      */      IF INFO>1000 THEN CALL ER.TMD;      SEQDATA(SEQ.TRVOLS+I)=INFO;   END;   CALL SCAN;       /* GET NEXT TOKEN */END TRVOL.STATEMENT;MIDII.STATEMENT:        PROC; /* PICK UP MIDI ROUTING INFO */   DCL (I,J) FIXED;   IF RELEASEM<>0 THEN CALL ER.RELL;   DO I=0 TO 15;               /* SCAN OFF NUMBERS */      CALL SCAN.AHEAD;         /* GET TO NUMBER    */      CALL SCAN.NUMERIC;       /* GET INFO         */      CALL ADJUST.NUM(0);      /* 1 DECIMALS      */      IF INFO>255 THEN CALL ER.TMD;      IF (I&1)=0 THEN J=INFO;      ELSE SEQDATA(SEQ.MIDI+SHR(I,1))=J\SHL(INFO,8);   END;   DO I=0 TO 15;               /* SCAN OFF NUMBERS */      CALL SCAN.AHEAD;         /* GET TO NUMBER    */      CALL SCAN.NUMERIC;       /* GET INFO         */      CALL ADJUST.NUM(0);      /* 1 DECIMALS       */      IF INFO>15 THEN CALL ER.TMD;      J=SHR(J,4)\SHL(INFO,12); /* SHIFT INTO POS   */      IF (I&3)=3 THEN SEQDATA(SEQ.MIDI+8+SHR(I,2))=J;   END;   CALL SCAN;       /* GET NEXT TOKEN */END MIDII.STATEMENT;CLICKTRACK.STATEMENT:  PROC; /* PROCESS CLICKTRACK STATEMENT */  CALL SCAN.NUMERIC;  CALL ADJUST.NUM(0); /* GET X. */  IF RELEASEM=0 THEN DO;     IF (INFO<1)\(INFO>16) THEN CALL ER.TMD;     SEQDATA(SEQ.LIVE.CLICK)=INFO+3;  END;  ELSE DO;     IF (INFO<1)\(INFO>200) THEN CALL ER.TMD;     SEQDATA(NEW.SEQ.LIVE.CLICK)=INFO+3;  END;  CALL SCAN;END CLICKTRACK.STATEMENT;LOOPSTART.STATEMENT:  PROC;  /* SET LOOP START */  if releasem=0 then CALL ER.RELM;  CALL SCAN;                 /* SKIP TO LOOP TIME */  IF TOKEN=T.BEAT THEN DO;   /* LOOK UP BEAT NUMBER */    CALL LOOKUP.BEAT.NUMBER; /* GET SECONDS, MILLISECONDS */    CALL INITIALIZE.BA;      /* RESTORE BA IN CASE WE ARE MID-NOTELIST */  END;  ELSE IF TOKEN<>T.TIME THEN CALL ER.IFM; /* NUMBER REQUIRED */  CALL COMPUTE.REAL.TIME(SECONDS,MILLISECONDS,MILLI.LSBS);  CALL COMPUTE.START(REAL.SECONDS,REAL.MILLISECONDS);  seqdata(new.seq.s.p.t)  =start.time;  seqdata(new.seq.s.p.t.c)=start.time.carries;  CALL SCAN;                 /* SKIP OVER NUMBER */END LOOPSTART.STATEMENT;MARKPOINT.STATEMENT: PROC;  if releasem=0 then CALL ER.RELM;  CALL SCAN;                 /* SKIP TO LOOP TIME */  IF TOKEN=T.BEAT THEN DO;   /* LOOK UP BEAT NUMBER */    CALL LOOKUP.BEAT.NUMBER; /* GET SECONDS, MILLISECONDS */    CALL INITIALIZE.BA;      /* RESTORE BA IN CASE WE ARE MID-NOTELIST */  END;  ELSE IF TOKEN<>T.TIME THEN CALL ER.IFM; /* NUMBER REQUIRED */  CALL COMPUTE.REAL.TIME(SECONDS,MILLISECONDS,MILLI.LSBS);  CALL COMPUTE.START(REAL.SECONDS,REAL.MILLISECONDS);  seqdata(new.seq.mark.msb)=start.time.carries;  seqdata(new.seq.mark.lsb)=start.time;  CALL SCAN;                 /* SKIP OVER NUMBER */END MARKPOINT.STATEMENT;TRACKPOLYB.STATEMENT: PROC;   DCL I FIXED;   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER    */   CALL SCAN.NUMERIC;      /* GET INFO         */   CALL ADJUST.NUM(0);     /* NO DECIMALS      */   IF (INFO=0) THEN CALL ER.IFM;   I = INFO;   CALL SCAN;              /* GET NEXT TOKEN   */   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.POLY;      WRITE(MD )=I-1;   END;END TRACKPOLYB.STATEMENT;TRACKSOLO.STATEMENT: PROC;   DCL I FIXED;   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; 	/* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.ACTIVE;      WRITE(MD )=B.SOLOED.TRK;   END;   CALL SCAN;              					/* GET NEXT TOKEN   */END TRACKSOLO.STATEMENT;TRACKNAME.STATEMENT: PROC;   DCL I FIXED;   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA;   /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN;              					/* GET NEXT TOKEN   */   IF TOKEN<>T.SCONST THEN CALL ER.IFM;   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      if (name(0) > 32) name(0) = 32;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.TRACK.TITLE;      do i = 0 to shr(name(0)+1,1);	  	write(mdi) = name(i);	  end;   END;   CALL SCAN;              					/* GET NEXT TOKEN   */END TRACKNAME.STATEMENT;GRPBUTTONS.STATEMENT: PROC;  IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; 		/* MUST BE IN NOTELIST */    ELSE IF RELEASEM=0 THEN CALL ER.RELM;  ELSE  {	DCL THE_SECTOR FIXED;						/* HOLDS RELATIVE SECTOR INTO WHICH TO CONSTRUCT GROUP LIST */	DCL J          FIXED;						/* TEMP */	DCL NUM_MEMBS  FIXED;						/* HOLDS NUMBER OF  MEMBERS IN GROUP */  	THE_SECTOR=SHR(SEQNLEN,8);					/* GET CURRENT LENGTH OF SEQUENCE */	DO J=0 TO 255;								/* MAKE IT 256 WORDS LONGER		  */	  CALL EMIT.N(0);							/* E.G. ALLOCATE A SECTOR FOR THE GROUP LIST */	END;		WRITE(MAM)=SEQNLOC+THEAD;					/* ACCESS TRACK HEAD			  */	WRITE(MAL)=THD.GROUPLIST;					/* INDEX TO GROUP LIST			  */	WRITE(MD )=THE_SECTOR;						/* STORE POINTER TO GROUP LIST	  */		WRITE(MAM)=SEQNLOC+THE_SECTOR;	WRITE(MAL)=GRPAUX.FOR;	WRITE(MDI)=0;								/* GRPAUX.FOR */	WRITE(MDI)=0;								/* GRPAUX.REV */		WRITE(MDI)=SEQ.GRPAUX.CODE + shl(0, 14) + (THIS.TRACK.NUMBER+NUM.KBD.TRKS); 	/* GRPAUX.TRK */		DO J = 0 TO 3;								/* SCAN OFF 4 BUTTON CODES */		CALL SCAN.AHEAD;        				/* GET TO NUMBER    */		CALL SCAN.NUMERIC;      				/* GET INFO         */		CALL ADJUST.NUM(0);     				/* NO DECIMALS      */		IF (INFO=0)   THEN CALL ER.IFM;		IF (INFO>200) THEN CALL ER.IFM;				WRITE(MAM)=SEQNLOC+THE_SECTOR;		WRITE(MAL)=GRPAUX.BUT+J;		WRITE(MD )=INFO+1;	END;		SCAN();              						/* GET NEXT TOKEN   */	IF (TOKEN<>T.GRPHOWMANY) ER.IFM();			/* BEST BE GRPHOWMANY */		CALL SCAN.AHEAD;        					/* GET TO NUMBER    */	CALL SCAN.NUMERIC;      					/* GET INFO         */	CALL ADJUST.NUM(0);     					/* NO DECIMALS      */	IF (INFO<=0)         THEN CALL ER.IFM;	IF (INFO>GRPAUX.MAX) THEN CALL ER.IFM;		WRITE(MAM)=SEQNLOC+THE_SECTOR;	WRITE(MAL)=GRPAUX.NUM;	WRITE(MD )=INFO;	NUM_MEMBS =INFO;		SCAN();              						/* GET NEXT TOKEN   */	IF (TOKEN<>T.GRPMEMBERS) ER.IFM();		DO J = 0 TO NUM_MEMBS-1;					/* SCAN OFF MEMBER LIST */		CALL SCAN.AHEAD;        				/* GET TO NUMBER    */		CALL SCAN.NUMERIC;      				/* GET INFO         */		CALL ADJUST.NUM(0);     				/* NO DECIMALS      */		IF (INFO<=0)   THEN CALL ER.IFM;		IF (INFO>200) THEN CALL ER.IFM;				WRITE(MAM)=SEQNLOC+THE_SECTOR;		WRITE(MAL)=GRPAUX.LST+J;		WRITE(MD )=INFO+1;	END;		SCAN();              						/* GET NEXT TOKEN   */  }END GRPBUTTONS.STATEMENT;/* $PAGE - ADDITIONAL STATEMENTS FOR RELEASE M ONLY */MULTIOUT.STATEMENT: PROC;	/*	PICK UP MULTI INFO FOR SINGLE TRACK */   DCL I FIXED automatic;	//	automatically inits to 0   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA;	/*	MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER	*/   CALL SCAN.NUMERIC;      /* GET INFO			*/   CALL ADJUST.NUM(0);     /* NO DECIMALS		*/   IF INFO>64 THEN CALL ER.TMD;	if (info != 0)	I = SHL(info-1+64,8);		//	left   CALL SCAN.AHEAD;        /* GET TO NUMBER	*/   CALL SCAN.NUMERIC;      /* GET INFO			*/   CALL ADJUST.NUM(0);     /* NO DECIMALS		*/   IF INFO>64 THEN CALL ER.TMD;	if (info != 0)	I = I\(info-1+64);			//	right   CALL SCAN;					/* GET NEXT TOKEN	*/   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.TROU;      WRITE(MD )=I;   END;END MULTIOUT.STATEMENT;MIDIOUT.STATEMENT:        PROC; /* PICK UP MIDI ROUTING INFO FOR TRACK */   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;         /* GET TO NUMBER    */   CALL SCAN.NUMERIC;       /* GET INFO         */   CALL ADJUST.NUM(0);      /* 1 DECIMALS      */   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.MIDI;      WRITE(MD )=INFO;   END;   CALL SCAN;       /* GET NEXT TOKEN */END MIDIOUT.STATEMENT;MIDIRTES.STATEMENT:        PROC; /* PICK UP MIDI ROUTING INFO FOR TRACK */   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;         /* GET TO NUMBER    */   CALL SCAN.NUMERIC;       /* GET INFO         */   CALL ADJUST.NUM(0);      /* 1 DECIMALS      */   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.ACTIVE.MIDI.RTES;      WRITE(MD )=INFO\32768;   END;   CALL SCAN;       /* GET NEXT TOKEN */END MIDIRTES.STATEMENT;TRACKVOL.STATEMENT:        PROC; /* PICK UP TRACK VOLUME INFO FOR REL M */   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER    */   CALL SCAN.NUMERIC;      /* GET INFO         */   CALL ADJUST.NUM(1);     /* 1 DECIMALS      */   IF INFO>1000 THEN CALL ER.TMD;   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.TVOL;      WRITE(MD )=INFO;   END;   CALL SCAN;       /* GET NEXT TOKEN */END TRACKVOL.STATEMENT;TRACKPAN.STATEMENT:        PROC; /* PICK UP TRACK PAN INFO FOR REL M */   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER    */   CALL SCAN.NUMERIC;      /* GET INFO         */   CALL ADJUST.NUM(0);     /* 0 DECIMALS      */   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.TPAN;      WRITE(MD )=INFO;   END;   CALL SCAN;       /* GET NEXT TOKEN */END TRACKPAN.STATEMENT;TRACKRATIO.STATEMENT:        PROC; /* PICK UP TRACK PAN INFO FOR REL M */   IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER    */   CALL SCAN.NUMERIC;      /* GET INFO         */   CALL ADJUST.NUM(3);     /* 0 DECIMALS      */   IF  (RELEASEM<>0)   AND (NOTELIST.ACTIVE<>0)   THEN DO;      WRITE(MAM)=SEQNLOC+THEAD;      WRITE(MAL)=THD.ORATIO;      WRITE(MD )=INFO;   END;   CALL SCAN;       /* GET NEXT TOKEN */END TRACKRATIO.STATEMENT;TRACKSCALE.STATEMENT:  PROC; /* SET UP SPECIAL TUNING */  DCL (I,J) FIXED;  IF NOTELIST.ACTIVE=0 THEN CALL ER.SNA; /* MUST BE IN NOTELIST */  IF RELEASEM=0 THEN CALL ER.RELM;  ENABLE.EOL=1;    /* STOP SCAN AT END OF LINE */  DO I=0 TO 11;    /* SCAN OFF 12 SCALE NUMBERS */    CALL SCAN.AHEAD;    IF NCHR=0 THEN CALL ER.TFSC;      /* TOO FEW NUMBERS */    ELSE           CALL SCAN.NUMERIC; /* SCAN OFF NUMBER */    CALL ADJUST.NUM(3);               /* GET TO .00X SEMITONE */    IF INFO>=12000 THEN CALL ER.TMD;  /* NUMBER TOO LARGE     */    J=INFO*1024/12000;                /* CONVERT TO 1024 STEPS/OCT */    IF READ(4)>=6000 THEN J=J+1;    IF  (RELEASEM<>0)    AND (NOTELIST.ACTIVE<>0)    THEN DO;       WRITE(MAM)=SEQNLOC+THEAD;       WRITE(MAL)=THD.SCALE+I;       WRITE(MD )=J;    END;  END;  CALL SCAN;  IF TOKEN<>T.EOL THEN CALL ER.TMSC; /* TOO MANY SCALE ELEMENTS */  ENABLE.EOL=0;  CALL SCAN; /* SKIP OVER END OF LINE */END TRACKSCALE.STATEMENT;BPM.STATEMENT: PROC;   IF RELEASEM=0 THEN CALL ER.RELM;   CALL SCAN.AHEAD;        /* GET TO NUMBER    */   CALL SCAN.NUMERIC;      /* GET INFO         */   CALL ADJUST.NUM(0);     /* 0 DECIMALS      */   IF (INFO>128) OR (INFO<1) THEN CALL ER.TMD; /* NUMBER TOO LARGE */   SEQDATA(NEW.SEQ.BPM)=INFO;   CALL SCAN;       /* GET NEXT TOKEN */END BPM.STATEMENT;/* $SUBTITLE  Process SCORE2 Statements */STMT:  PROC; /* PROCESS STATEMENT */  DO CASE (INFO); /* BRANCH ON STATEMENT TYPE */    CALL DEFINE.STATEMENT;    CALL A.T.V.STATEMENT(0); /* ARTIC  */    CALL A.T.V.STATEMENT(1); /* TIMBRE */    CALL A.T.V.STATEMENT(2); /* VOL    */    CALL TEMPO.STATEMENT;    CALL LOOP.STATEMENT;    CALL SCALE.STATEMENT;    CALL SPEED.STATEMENT;    CALL CLICKPERIOD.STATEMENT;    CALL OCTAVERATIO.STATEMENT;    CALL KEYSIG.STATEMENT;    CALL IGNORE.LINE; /* IGNORE TIMESIGNATURE STATEMENT */    CALL TRANSPOSE.GLIDEFROM.STATEMENT(T.XPOS);    CALL TRANSPOSE.GLIDEFROM.STATEMENT(T.GFROM);    CALL NOTELIST.STATEMENT;    CALL P.STATEMENT;    CALL PERFORM.STATEMENT;    CALL NOTE.STATEMENT(T.STARTL);    CALL NOTE.STATEMENT(T.ENDL);    CALL FPS.STATEMENT;    CALL SYNC.STATEMENT(T.SYNC);    CALL SYNC.STATEMENT(T.DELAY);    CALL SYNC.STATEMENT(T.SMOOTH);    CALL AT.STATEMENT;    CALL CLICKMULTIPLIER.STATEMENT;    CALL IGNORE.LINE;           /* IGNORE TITLE STATEMENT */    CALL EDITINFORMATION.STATEMENT;    CALL IGNORE.LINE;           /* IGNORE FORMAT STATEMENT */    CALL IGNORE.LINE;           /* IGNORE PRESETS STATEMENT */    CALL IGNORE.LINE;           /* IGNORE POSITION STATEMENT */    CALL MULTI.STATEMENT;       /* MULTI ROUTING */    CALL SMPTE.STATEMENT;       /* SMPTE INFO    */    CALL TRVOL.STATEMENT;       /* TRVOL INFO    */    CALL MIDII.STATEMENT;       /* MIDI  INFO    */    CALL CLICKTRACK.STATEMENT;    CALL LOOPSTART.STATEMENT;   /* RELM - LOOP START  */    CALL MULTIOUT.STATEMENT;    /* RELM - MULTI OUT   */    CALL TRACKVOL.STATEMENT;    /* RELM - TRACK VOL   */    CALL MIDIOUT.STATEMENT;     /* RELM - TRACK VOL   */    CALL TRACKSCALE.STATEMENT;  /* RELM - TRACK SCALE */    CALL TRACKPAN.STATEMENT;    /* RELM - TRACK PAN   */    CALL TRACKRATIO.STATEMENT;  /* RELM - TRACK RATIO */    CALL MIDIRTES.STATEMENT;    /* RELM - ACTIVE MIDI RTES */    CALL BPM.STATEMENT;         /* RELM - BEATS PER MEASURE */    CALL MARKPOINT.STATEMENT;   /* RELM - MARK POINT  */	CALL TRACKPOLYB.STATEMENT;	/* POLY BIN */	CALL GRPBUTTONS.STATEMENT;	/* TRACK GROUP INFORMATION */	CALL TRACKSOLO.STATEMENT;	/* TRACK SOLO STATE */	CALL DTDSOLOS.STATEMENT;	/* DTD SOLO STATE */	CALL TRACKNAME.STATEMENT;	/* TRACK SOLO STATE */  END;                          /* OF DO CASE    */END STMT;