TTL HIGH MEMORY PROGRAM FOR WINCHESTER DISK SYSTEMS**  10 Sep 82: Handles large catalogs and different winch controllers [C. Moses]*  23 Apr 84: Copy configuration before overlay (if config exists) [KJC]*  19 Oct 84: Handles dual drive winchester systems [KJC]*   8 Nov 84: Updated to true -5; no longer compatible with -4 [KJC]*  13 Nov 84: Updated to -6 configuration/highcore (but no W1 support); Added ECOPY [KJC]*  13 Dec 84: Added W1 support [KJC]*   7 Jan 85: Added automatic loading of any swap file [KJC]*   2 Jun 86: Updated to -7 high memory/configuration structure [KJC]**Note:  The total number of sectors in the system is limited to 65,520.**THIS PROGRAM RESIDES IN THE LOWER 512 OF THE UPPER 1024 WORDS OF MEMORY.*READ DATA FROM THE WINCHESTER AS REQUIRED:**RE(FBOOT) TO RTRA LOCATION 0 - LOAD 'MONITOR' FROM DRIVE ZERORE(OVLAY) TO RTRA LOCATION 1 - OVERLAY A PROGRAM (AC0=MS SECTOR, AC1=LS SECTOR, AC2=DEST, AC3=LENGTH)RE(NBOOT) TO RTRA LOCATION 2 - LOADS SPECIAL FILE NAME (PASSED IN AC0-AC3)RE(CCOPY) TO RTRA LOCATION 3 - PERFORMS CORE TO CORE COPY (AC0=SOURCE, AC1=DEST, AC2=LENGTH)RE(ECOPY) TO RTRA LOCATION 4 - PERFORMS EXTMEM TO CORE COPY (AC0=SECTOR, AC1=DEST, AC2=LENGTH)**CATLEN:EQU 2000 WINCHESTER CATALOG LENGTH (4 SECTORS)MEMDIF:EQU 2000 (MEM.SIZ - TOP OF THIS ROUTINE) [1024]CONTAB:EQU 1 POINTER TO LOCATION OF LOWCORE CONFIGURATION TABLETABLEN:EQU 150 104 WORDS IN THE CONFIGURATION TABLEOBJLEN:EQU 4 POINTER TO OBJECT CODE LENGTH (LOWCORE ONLY)SWPLEN:EQU 6 POINTER TO SWAP FILE LENGTH IN SECTORS (LOWCORE ONLY)CURTRK:EQU 14 POINTER TO DISKREAD/DISKWRITE HEAD POSITIONS (LOWCORE ONLY)CTABOF:EQU 357 LOCATION OF HIGHCORE CONFIGURATION = (MEM.SIZ - LOC.CTAB) [239]CONINF:EQU 20 CONFIGURATION INFO STARTS HERE IN CONTABCURDEV:EQU (CTABOF-27+CONINF) OFFSET FOR CURRENT DEVICESTRDEV:EQU (CTABOF-30+CONINF) OFFSET FOR STORAGE DEVICE TABLESYSTYP:EQU 0 OFFSET TO TYPE WORD IN STORAGE DEVICE TABLESYSSPC:EQU 1 OFFSET TO SECTORS/CYLINDER ENTRY IN STORAGE DEVICE TABLESYSCYL:EQU 2 OFFSET TO TOTAL CYLINDERS ENTRY IN STORAGE DEVICE TABLEDRVCON:EQU 3 OFFSET TO DRIVE/CONTROLLER WORD IN STORAGE DEVICE TABLEBLKLEN:EQU 4 LENGTH OF STORAGE DEVICE TABLE ENTRYSTREND:EQU (CTABOF-TABLEN+CONINF) END OF STORAGE DEVICE TABLE PLUS ONEHDPOS: EQU 363 OFFSET FOR TRUE HEAD POSITIONS (USED BY DISKREAD/DISKWRITE) [243]MAGIC: EQU 224 LOCATION OF MAGIC NUMBER IN HIGHCORE [148]EMSIZE:EQU 364 OFFSET FOR AVAILABLE EXTENDED MEMORY SIZE IN SECTORS [244]***Read states (for DSKRD routine):**  Since the overlay mechanism will now automatically load any swap file*  into extended memory for the calling program, various "read states"*  have been added to the DSKRD routine.  These states describe what*  is expected of the read routine.**  Note:  The swap file is read into the very top portion of the*         extended memory.*RCAT:   equ 0 read catalogRFIRST: equ 1 read first sector of the object fileRRESTN: equ 2 read the rest of the object file - no configurationRREST:  equ 3 read the rest of the object file - valid configuration foundRSWAP:  equ 4 read the swap file into the extended memoryEJECT**CORE TO CORE COPY ROUTINE*CCOPY:...IM(-20) TO D1 MAKE SURE INTERRUPTS ARE OFFPCI TO RTRA TRANSFER TO THE CORE-TO-CORE COPY ROUTINEDATA (CCOPY2-.-1)**EXTERNAL MEMORY TO CORE COPY:*ECOPY:...IM(-20) TO D1 DISABLE INTERRUPTSPCI TO RTRA TRANSFER TO THE EXTERNAL MEMORY-TO-CORE COPY ROUTINEDATA (ECOPY2-.-1)**OVERLAY A FILE*OVLAY:...IM(-20) TO D1 DISABLE INTERRUPTS FOR SURE FOR OVERLAYIM(RFIRST) TO R10 SET STATE TO READ FIRST SECTOR OF OBJECT FILERE(SETUP) TO RTRA GO READ IT IN**LOAD PROGRAM CALLED 'MONITOR'*FBOOT:...IM(-20) TO D1 MAKE SURE INTERRUPTS ARE OFFPCI TO R0DATA 47515 LOAD PROGRAM NAME INTO R0-R3 FOR LATER CODEPCI TO R1DATA 44516PCI TO R2DATA 47524PCI TO R3DATA 122**LOAD PROGRAM AS SPECIFIED IN AC0-AC1-AC2-AC3*NBOOT:...IM(-20) TO D1 MAKE SURE INTERRUPTS ARE OFFR0 TO R4R1 TO R5R2 TO R6R3 TO R7 MOVE NAME TO REGISTERS 4-7**SET UP FOR DISK READ*IM(0) TO R0 SET THE DEVICE ADDRESS TO THE SYSTEM DEVICEIM(0) TO R1 START READ FROM SECTOR 0 OF WINCHESTERIM(0) TO R2 READ CATALOG INTO START OF MEMORYPCI TO R3 THIS IS THE CATALOG'S LENGTHDATA CATLENIM(RCAT) TO R10 SET STATE TO READ IN THE CATALOGEJECT**SET UP FOR READING THE DISK - MAP LOGICAL DEVICE TO PHYSICAL DEVICE*SETUP:...im(-1) to R12 try to find the device/drive ID for the device passed in R0R0 to R14 set the logical drive ID asidePCI to AND0 extract just the logical device codedata 177000 (LSB in upper byte is the logical drive number - ignore it as well)re(DECODE) to RTNZ nonzero device type - go decode itR17 to R0 get our current locationPCI to ADD0 point to current device - following word is system devicedata (MEMDIF-CURDEV-(.-1))R0 to R12 save this pointerR14 to R0 recover the logical drive IDPCI to TAND0 see if the drive number is onedata 400 LSB in upper byteim(1) to RTNZ if non-zero, we want the current device (already point to it)R12I to ATNV otherwise, want system device - point to itMR12 to R0 pick up desired devicePCI to AND0 keep just the device typedata 377R0 to R12 and set asidere(CHKDEV) to RTRA and go check the device's validityDECODE: PCI to TSUB0 decode the device typedata 3000 Winchester?re(CHKDEV) to RTNZ no, we aren't interested in decoding any other devicesim(1) to R12 set Winchester device code in R12R14 to R0 pick up logical device againPCI to TAND0 check drive numberdata 400re(CHKDEV) to RTZE no drive number - R12 is the deviceim(21) to R12 set it to Winchester one (normally, we'd OR this bit in)CHKDEV: R12 to R0 pick up resultim(17) to AND0 extract just the device typeim(1) to TSUB0 make sure it's a Winchesterim(2) to RTZE it is okayim(7) to D50 it isn't - beep foreverim(-2) to RTRA*R1 to R14 save R1R2 to R11 save R2R17 to R0 get our current locationPCI to ADD0 point to the highcore storage device tabledata (MEMDIF-STRDEV-BLKLEN-(.-1)) or thereaboutsR17 to R2 get our current locationPCI to ADD2 point to the end of the highcore storage device tabledata (MEMDIF-STREND-(.-1))im(-1) to R13 initialize block pointerFNDBLK: R13I to ATNV point to next blockim(BLKLEN) to ADD0 here tooR2 to TSUB0 see if we went over the topim(2) to RTNZ if we didn't, we're okayim(7) to D50 otherwise, beepim(-2) to RTRA and loop foreverMR0 to R1 pick up device typePCI to AND1 extract just the device typedata 377R12 to TSUB1 is it the device we're looking for?re(FNDBLK) to RTNZ no, keep lookingR14 to R1 restore R1R11 to R2 restore R2**We can trash the MS sector now since it isn't supported by the catalog structure.*R1 to R0 shift everything down so the code that only had an LS sector worksR2 to R1R3 to R2 R3 is now freeEJECT**READ DATA FROM WINCHESTER*  R0 = STARTING SECTOR*  R1 = CORE LOCATION*  R2 = LENGTH*  R10= READ STATE (0: READ CATALOG, 1: READ FIRST SECTOR OF FILE, ETC.)*  R13= LOGICAL DRIVE NUMBER TO START AT*DSKRD:...R1 TO R11 SAVE STARTING MEMORY LOCATION**The following finds the appropriate Winchester in the configuration*and selects it.  The following registers are used:*   R0:  Logical or Physical sector number on current disk at entry*        Physical sector number on current disk after selection*   R1:  Location to copy to - Used as temp during selection (but preserved)*   R2:  Length to copy - Used as temp during selection (but preserved)*   R3:  Temporary*   R4-R7: Name of file to overlay to (state RCAT only)*   R4:  Address of swap file (state RSWAP only - passed to target program)*   R5-R6: Unused (all states except RCAT)*   R7:  Subroutine return address (all states except RCAT in which no subroutines are called)*   R10: Read state - See definitions above*   R11: Original location to copy to (R1 at OVLAY entry) - Target for transfer*   R12: Temporary (used only in selection to preserve R1)*   R13: Current logical drive number (storage device block number)*   R14: Physical drive number in MSB, READ command (2) in LSB*   R15: Negative number of sectors remaining on the current drive*   R16: Logical drive code of drive we're overlaying to (used only in selection)*WINSEL:... select the next (logical) WinchesterR1 to R12 preserve R1R17 TO R3 GET OUR CURRENT LOCATIONPCI TO ADD3 AND POINT TO STORAGE DEVICE TABLE IN HIGHCORE CONFIGDATA (MEMDIF-STRDEV-(.-1))R13 TO ADD3 POINT TO CURRENT LOGICAL DRIVER13 TO ADD3 [FOUR (BLKLEN) WORDS/TABLE ENTRY]R13 TO ADD3R13 TO ADD3**Find the logical drive that this sector is on*R2 to R14 preserve R2MR3 to R2 pick up logical drive code of drive we're looking forPCI to AND2 extract just the typedata 377R2 to R16 set aside logical drive code of drive we're looking forWIN0: PCI to TSUB3 are we at the end of the table?data (MEMDIF-STREND-(.-1))im(2) to RTNZ no, keep lookingWINERR: im(7) to D50 yes, the specified sector is beyond the end of the diskre(WINERR) to RTRA bomb outMR3 to R2 pick up logical drive/type wordPCI to AND2 extract just the device typedata 377R16 to TSUB2 is this a drive we're looking for?re(WINERR) to RTNZ no, either at end of table (-1) or past W0's listR3 to R2 get block pointer for current logical driveim(SYSSPC) to ADD2 point to sectors/cylinderMR2I to R15 pick up and save sectors/cylinder (and point to total cylinders)R0 to D5 divide the logical sector number (or physical if we're crossing a disk boundary)R15 to D7 by the number of sectors/cylinderD5 to R1 to get the logical cylinder number (### assumes cylinder number < 64K ###)MR2 to TSUB1 see if the target cylinder is on the current logical drivere(WIN2) to RTNC the cylinder is on this driveMR2 to SUB1 not on this drive; reduce the logical cylinder number by length of this driveD4 to R2 save remainder from division aboveR1 to D5 multiply new logical cylinder number by sectors/cylinderR2 to D4 and add in sector remainderR15 to D6 to get new logical sector numberD5 to R0 and move that to R0im(BLKLEN) to ADD3 point to the next drive (block)R13I to ATNV increment the logical drive as wellre(WIN0) to RTRA and keep lookingEJECT**Save target cylinder here*WIN2: R14 to R2 restore R2 hereD4 to R14 save remainder - this is the physical sector number on this cylinderR1 to D5 multiply the physical cylinder number by sectors/cylinderR14I to D4 and add in the physical sector number on this drive (and make R14 be that plus one)R15 to D6 perform the multiplication, then the additionD5 to R0 the result is the physical sector number on this logical drive**Find the negative number of sectors remaining on this drive*im(SYSCYL) to ADD3 point to total cylinders on diskMR3I to SUB1 get negative number of cylinders left on drive (and point to drive/controller)PCI to TADD1 limit to 512 to avoid overflowdata 1000im(2) to RTRC skip if less than 512 or 512 cylinders leftPCI to LOA1 else limit to 512data 177000 -512R1 to D5 multiply negative number of cylinders leftR15 to D6 by sectors/cylinderD5 to R1 to get negative number of sectors leftR14 to ADD1 less the sector we are starting with on this cylinder plus oneR1 to R15 save negative number of sectors remaining on drive**Put the physical drive number in the command word and select the proper controller*MR3 to R1 get drive #/controller #im(-10) to AND1 remove controller #im(2) to OR1 add in READ commandR1 to R14 and set asideR12 to R1 restore R1 hereMR3 TO D105 SELECT THE APPROPRIATE WINCHESTER CONTROLLERD105 TO R3 MAKE SURE STATUS IS OKIM(10) TO TAND3 SHOULD BE THEREIM(2) TO RTNZ IF SO, THEN OKIM(7) TO D50IM(-2) TO RTRA BEEP FOR GOODD106 TO LOA3 READ WINCHESTER STATUS INFORMATIONRE(WIN1) TO RTZE IF ZERO, THEN STATUS IS OKIM(7) TO D50 BEEP ONCEPCI TO D106 PULSE RESET LINEDATA 40PCI TO D106 SET CLEAR STATE MACHINE BITDATA 200D106 TO LOA3 WAIT FOR READY IM(-2) TO RTNZ WAIT FOR DISK READYWIN1:PCI TO D106 RESET ROM STATE MACHINEDATA 200IM(0) TO D106EJECT**NOW READ DATA FROM WINCHESTER*WIN5:R14 TO D107 WRITE OUT A READ COMMMAND WITH APPROPRIATE DRIVE NUMBERR0I TO D107 SPECIFY SECTOR NUMBERD106 TO R3 WE GET OCCASIONAL CRASHES DURING HANG MODE??IM(2) TO TAND3IM(-3) TO RTZE WAIT FOR BUS DIRECTION TO COME BACKD107 TO R3 GET RETURN CODEPCI TO TAND3 CHECK FOR ANY ERRORDATA 177IM(1) TO RTZE IF NOT, SKIPIM(7) TO D50PCI TO TAND3 CHECK FOR FATAL ERRORDATA 200IM(2) TO RTZE IF NOT, SKIPIM(7) TO D50IM(-2) TO RTRAR10 to LOA3 pick up read stateim(RSWAP) to TSUB3 are we reading the swap file?re(WIN6) to RTNZ no, read the next sector of the object file**Read data from Winchester to external memory*im(20) to R3 read a sector in a high speed loopWIN11: D107 to D63 to the extended memoryD107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63D107 to D63im(1) to SUB3 count the 16-word blocksre(WIN11) to RTNZ read until doneim(1) to SUB2 just read another sectorPCI to RTRA get ready for next sectordata WIN8-.-1EJECT**READ DATA FROM WINCHESTER TO MEMORY*WIN6:IM(20) TO R3 READ IN HIGH SPEED LOOPWIN9:D107 TO MR1ID107 TO MR1I FORCE READ OF ENTIRE FIRST SECTORD107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1ID107 TO MR1IIM(1) TO SUB3 COUNTERRE(WIN9) TO RTNZ GO BACKPCI TO SUB2 DECREMENT COUNTDATA 400 BY 256IM(1) TO RTRCIM(0) TO R2   IF WE'VE OVERSHOT, SET LENGTH TO ZEROEJECT**FINISH SECTOR READ - PREPARE FOR NEXT SECTOR*WIN8:D106 TO LOA3 WAIT FOR READY TO COME BACK AFTER READIM(1) TO TAND3RE(WIN8) TO RTNZ LOOP WHILE NOT READYR2 TO TLOA2 SEE IF DONE WITH READPCI to RTZE if done, prepare to exitDATA (WIN3-.-1)R10 to LOA3 check the read stateim(RFIRST) to TSUB3 are we reading the first sector?re(WIN4) to RTNZ no, keep goingR17I to R7 we are in state RFIRST - proceed to next statere(WIN4) to RTRA <= return here (skip the call - fall through)**End of RFIRST state - R11 points to the sector we just read in; R7 is return*  When we return, R2 will be the remaining length of the object file*  and R10 will be the new state.**To call this subroutine:*  R17I      to R7 save return in R7*  re(RETRN) to RTRA <= return here!*  re(ENDRF) to RTRA call this routine*  RETRN: ...*ENDRF: im(RRESTN) to R10 change state to read rest of object - assume no configurationMR11 to R3 check for valid XPL config - get first word of programPCI to TSUB3 make sure it matches the first instruction of all XPL programsPCI TO LOA0 <<---- this is the first instruction of all XPL programs ---->>R7 TO ATNZ doesn't match - no configim(CONTAB) to R3 point to pointer to config tableR11 to ADD3 add in address where we read this sectorMR3 to LOA3 point to config tableR7 to ATZE zero - no configim(3) to TSUB3 the pointer must be greater than threeR7 to ATNC not greater than three (ILE test) - no configPCI to TSUB3 make sure pointer's in rangedata 400-TABLEN has to fit within first sectorR7 to ATRC out of range - invalid configim(OBJLEN) to ADD3 point to object length in configMR3 to R2 pick up actual object file lengthPCI to SUB2 but subtract out the sector we just readdata 400IM(1) TO RTRC check for 1 sector filesIM(0) TO LOA2 set length of file to zero, the file has been readim(RREST) to R10 change state to read rest of object - valid configR7 to ATRA return here**Check for end of disk*WIN4: R15I to TLOA0 check for end of diskPCI TO RTNZ IF NOT, THEN GO BACK AND READ NEXT SECTORDATA WIN5-.-1PCI to RTRA else select the next drive and continue readingdata WINSEL-.-1EJECT**Done with the read*WIN3: R10 TO LOA3 TEST READ STATEPCI TO RTZE ZERO MEANS SEARCHING FOR A FILE (READING THE CATALOG)DATA CAT-.-1im(RFIRST) to TSUB3 read first sector of object file?re(WIN3A) to RTNZ no, keep lookingR17I to R7 set up to call end of RFIRST state routine (save return in R7)im(2) to RTRA <= return herePCI to RTRA call end of RFIRST state routinedata (ENDRF-.-1)R10 to R3 move the new state into R3WIN3A: im(RRESTN) to TSUB3 read rest of object file, no config?R11 to ATZE yes, we're all set - start up target program hereim(RREST) to TSUB3 read rest of object file, valid config?re(ERSWAP) to RTNZ no, go copy configR2 TO TLOA2 check to see if we've copied it allRE(WIN4) TO RTNZ no go copy moreR17I to R7 set up to call end of RREST routine (save return in R7)re(WIN4) to RTRA <= return here (skip the CALL - fall through)**End of state RREST - prepare to read in the swap file; R1, R2, and R3 are free*  R11 points to the object file just read in; R7 is the return*  When we return, R2 will contain the sector length of the swap file and*  both D60 and R4 will contain the address of the swap file.**Note:  If there is no swap file, this routine does NOT return!**To call this subroutine:*  R17I      to R7 save return in R7*  re(RETRN) to RTRA <= return here!*  re(ENDRR) to RTRA call this routine*  RETRN: ...*ENDRR: im(CONTAB) to R3 point to pointer to configurationR11 to ADD3 add in base of object fileMR3 to LOA3 pick up configuration pointerim(SWPLEN) to ADD3 point to swap file lengthMR3 to LOA2 pick up length (in sectors)re(CPYFIG) to RTZE no swap file - get outR17 to R3 get current locationPCI to ADD3 point to external memory size in highcoredata (MEMDIF-EMSIZE-(.-1))MR3 to LOA1 pick up extended memory sizeim(2) to RTNZ non-zero - we have extended memorySWERR: im(7) to D50 no extended memory or swap file too largere(SWERR) to RTRA beep foreverR2 to SUB1 find starting sector for swap file in extended memory (from top)re(SWERR) to RTMI too largeR1 to R4 save swap file startR1 to D60 and set up the extended memoryim(RSWAP) to R10 change state to read swap fileR7 to ATRA and go read in the swap file (return)EJECT**End of RSWAP - reset D60 (early boards would crash to D61 after loading)*ERSWAP: R4 to D60 reset D60 to start of swap file**COPY CONFIGURATION*CPYFIG:... VALIDATE/COPY THE CONFIGURATION AND START UP THE PROGRAMR17 TO R3 GET CURRENT LOCATIONPCI TO ADD3 POINT TO THE MAGIC NUMBER IN HIGHCOREDATA (MEMDIF-MAGIC-(.-1))MR3 TO R3 PICK UP MAGIC NUMBER FROM HIGHCOREPCI TO TSUB3 MAKE SURE IT'S CORRECTDATA 30071 THIS IS 12345 DECIMALR11 TO ATNZ IF NOT, DON'T COPY CONFIG (AS HIGHCORE ISN'T THERE)IM(CONTAB) TO R1 POINT TO POINTER TO CONFIG TABLER11 TO ADD1 OFFSET POINTER FROM START OF OBJECT FILEMR1 TO LOA1 POINT TO CONFIG TABLEIM(CURTRK) TO ADD1 POINT TO HEAD POSITION POINTERR17 TO R2 GET CURRENT LOCATIONPCI TO ADD2 POINT TO HIGHCORE HEAD POSITIONSDATA (MEMDIF-HDPOS-(.-1))R2 TO MR1 UPDATE LOWCORE HEAD POS POINTER TO POINT TO HIGHCORE**COPY THE CONFIGURATION*IM(CONTAB) TO R1 POINT TO CONFIGURATION POINTERR11 TO ADD1 ADD IN OBJECT FILE BASEMR1 TO R1 PICK UP CONFIGURATION POINTERIM(CONINF) TO ADD1 POINT TO THE FIRST WORD TO COPYR17 TO R2 GET OUR CURRENT POSITIONPCI TO ADD2 AND POINT TO THE HIGHCORE CONFIGURATION TABLEDATA (MEMDIF-CTABOF-(.-1))PCI TO R0 GET NUMBER OF WORDS TO COPYDATA TABLEN-CONINFMR2I TO MR1I AND COPY THE CONFIGURATIONIM(1) TO SUB0 SEE IF WE'RE DONEIM(-3) TO RTNZ NOT DONE YETR11 TO ATRA DONE - START UP PROGRAMEJECT**LOOK FOR FILE NAME*CAT:IM(0) TO R0 INITIALIZE COUNTCAT1:R0 TO R1 R0 CONTAINS OFFSET OF FILE ENTRY IN CATALOGMR1I TO R2 GET DATAR4 TO SUB2RE(CAT2) TO RTNZ NOT USMR1I TO R2 GET DATAR5 TO SUB2RE(CAT2) TO RTNZMR1I TO R2 GET DATAR6 TO SUB2 EQUALRE(CAT2) TO RTNZ NOT USMR1I TO R2 GET DATAR7 TO SUB2 EQUALRE(CAT2) TO RTNZ NOT USMR1I TO R0 GET BASE SECTORIM(1) TO ADD1 SKIP NEXTMR1I TO R2 AND GET FILE LENGTH = NUMBER OF WORDS TO READIM(0) TO R1 AND START AT MEMORY LOCATION 0IM(RFIRST) TO R10 SET STATE TO READ FIRST SECTOR OF OBJECT FILEPCI TO RTRA GO READ IN THE FILEDATA DSKRD-.-1CAT2:IM(10) TO ADD0 INCREMENT MEMORY POINTERPCI TO TSUB0 SEE IF DONEDATA CATLEN LENGTH OF THE WINCHESTER CATALOGRE(CAT1) TO RTNZ IF NOT DONE,  GO BACKIM(7) TO D50IM(-2) TO RTRAEJECT**Core-to-core copy:*  R0: source address*  R1: destination address*  R2: length*CCOPY2: R1 to R11 move starting address for later transferim(RFIRST) to R10 set state to read first sectorPCI to R3 read in first sectordata 400R3 to SUB2 save amount remaining to be copied (after first sector)re(CCOPY3) to RTRCim(0) to R2 no words left to copy, set to zeroCCOPY3: MR0I to MR1I copy one word at a timeim(1) to SUB3 keep track of how much we've copiedre(CCOPY3) to RTNZ loop until counter equals zeroR10 to R3 check stateim(RFIRST) to TSUB3 reading first sector?re(CCOPY8) to RTNZ R17I to R7 call end of RFIRST routine (save return in R7)re(CCOPY4) to RTRA <= return herePCI to RTRA and call end of RFIRST routinedata (ENDRF-.-1)CCOPY4: R2 to LOA3 set remaining lengthre(CCOPY3) to RTNZ begin copying remaining codeCCOPY8: R10 to R3 move the new state into R3im(RREST) to TSUB3 did we just read the rest of the object file (with valid config)?R11 to ATNZ no, start up the program here (states RFIRST and RRESTN)R17I to R7 call end of RREST routine (save return in R7)re(CCOPY5) to RTRA <= return here (if we return)PCI to RTRA and call end of RREST routinedata (ENDRR-.-1)CCOPY5: MR0I to TLOA3 find the end of the last sector of the object filere(CCOPY5) to RTZE ends when we find a non-zero wordim(1) to SUB0 and back up R0 (we overstepped by one)CCOPY6: PCI to R3 set word counterdata 400 to one sectorCCOPY7: MR0I to D63 copy the next wordim(1) to SUB3 decrement word countre(CCOPY7) to RTNZ loop until the whole sector is copiedim(1) to SUB2 decrement sector countre(CCOPY6) to RTNZ loop until whole swap file copiedPCI to RTRA and go to itdata (ERSWAP-.-1)EJECT**External memory-to-core copy:*  R0: source sector in external memory*  R1: destination address in main memory*  R2: length to copy*ECOPY2: R1 to R11 move starting address for later transferR0 to D60 send starting sector number to external memoryim(RFIRST) to R10 set state to read first sectorPCI to R3 read in first sectordata 400R3 to SUB2 save amount remaining to be copied (after first sector)re(ECOPY3) to RTRCim(0) to R2 no words left to copy, set to zeroECOPY3: D63 to MR1I copy one word at a timeim(1) to SUB3 keep track of how much we've copiedre(ECOPY3) to RTNZ loop until counter equals zeroR10 to R3 check stateim(RFIRST) to TSUB3 reading first sector?re(ECOPY8) to RTNZ copy completed?R17I to R7 call end of RFIRST routine (save return in R7)re(ECOPY4) to RTRA <= return herePCI to RTRA and call end of RFIRST routinedata (ENDRF-.-1)ECOPY4: R2 to LOA3 set remaining lengthre(ECOPY3) to RTNZ begin copying remaining codeECOPY8: R10 to R3 move the new state into R3im(RREST) to TSUB3 did we just read the rest of the object file (with valid config)?R11 to ATNZ no, start up the program here (states RFIRST and RRESTN)R1 to R0 save memory pointerD60 to R3 move to the end of the last sector of the object fileD61 to TLOA3 see if non-zero word pointerim(1) to RTZE it's zeroim(1) to ADD3 nonzero, point to next sectorR3 to R12 save start of swap file (ENDRR trashes D60)R17I to R7 call end of RREST routine (save return in R7)re(ECOPY5) to RTRA <= return here (if we return)PCI to RTRA and call end of RREST routinedata (ENDRR-.-1)ECOPY5: D60 to R13 set destination sector address asideR12 to D60 point back to the start of the swap file in extended memoryR0 to R1 set memory pointerPCI to R3 set word counterdata 400 to one sectorECOPY6: D63 to MR1I copy the next wordim(1) to SUB3 decrement word countre(ECOPY6) to RTNZ loop until the whole sector is copiedD60 to R12 save new source sector addressR13 to D60 set destination sector addressR0 to R1 set memory pointerPCI to R3 set word counterdata 400 to one sectorECOPY7: MR1I to D63 copy the next wordim(1) to SUB3 decrement word countre(ECOPY7) to RTNZ loop until the whole sector is copiedim(1) to SUB2 decrement sector countre(ECOPY5) to RTNZ loop until whole swap file copiedPCI to RTRA and go to itdata (ERSWAP-.-1)