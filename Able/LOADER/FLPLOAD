TTL HIGH MEMORY PROGRAM FOR FLOPPY DISK SYSTEMS**ENTRY LOCATIONS ARE:**  LOCATION 0 LOADS THE PROGRAM 'MONITOR' FROM THE FLOPPY*  LOCATION 1 PERFORMS OVERLAY - AC0=MS SECTOR, AC1=LS SECTOR, AC2=DEST, AC3=LENGTH*  LOCATION 2 LOADS THE FILE WITH THE FILENAME IN REG 0-3*  LOCATION 3 PERFORMS CORE TO CORE COPY - AC0=SOURCE, AC1=DEST, AC2=LENGTH*  LOCATION 4 PERFORMS EXTMEM TO CORE COPY - AC0=SECTOR, AC1=DEST, AC2=LENGTH**RE(FBOOT) TO RTRA LOCATION 0 - LOAD 'MONITOR' FROM DRIVE ZERORE(OVLAY) TO RTRA LOCATION 1 - OVERLAY A PROGRAMRE(NBOOT) TO RTRA LOCATION 2 - LOADS SPECIAL FILE NAMERE(CCOPY) TO RTRA LOCATION 3 - PERFORMS CORE TO CORE COPYRE(ECOPY) TO RTRA LOCATION 4 - PERFORMS EXTERNAL MEMORY TO CORE COPY***DEFINITIONS:*CATLEN:EQU 400 FLOPPY CATALOG LENGTH (1 SECTOR)MEMDIF:EQU 2000 (MEM.SIZ - TOP OF THIS ROUTINE) [1024]CONTAB:EQU 1 POINTER TO LOCATION OF LOWCORE CONFIGURATION TABLETABLEN:EQU 150 LENGTH OF LOWCORE CONFIGURATION TABLE [104]OBJLEN:EQU 4 POINTER TO OBJECT CODE LENGTH (LOWCORE ONLY)SWPLEN:EQU 6 POINTER TO SWAP FILE LENGTH IN SECTORS (LOWCORE ONLY)CURTRK:EQU 14 POINTER TO DISKREAD/DISKWRITE HEAD POSITIONS (LOWCORE ONLY)CTABOF:EQU 357 LOCATION OF HIGHCORE CONFIGURATION = (MEM.SIZ - LOC.CTAB) [239]CONINF:EQU 20 HIGHCORE CONFIGURATION INFO STARTS HERE IN CONTABCURDEV:EQU (CTABOF-27+CONINF) OFFSET FOR CURRENT DEVICESTRDEV:EQU (CTABOF-30+CONINF) OFFSET FOR STORAGE DEVICE TABLESYSTYP:EQU 0 OFFSET TO TYPE WORD IN STORAGE DEVICE TABLESECPT: EQU 1 OFFSET FOR SECTORS/CYLINDER WORD IN STORAGE DEVICE TABLESTPSP: EQU 3 OFFSET FOR STEPPING SPEED IN STORAGE DEVICE TABLEBLKLEN:EQU 4 LENGTH OF STORAGE DEVICE TABLE ENTRYSTREND:EQU (CTABOF-TABLEN+CONINF) END OF STORAGE DEVICE TABLE PLUS ONEHDPOS: EQU 363 OFFSET FOR TRUE HEAD POSITIONS (USED BY DISKREAD/DISKWRITE) [243]MAGIC: EQU 224 OFFSET FOR MAGIC NUMBER [148]EMSIZE:EQU 364 OFFSET FOR AVAILABLE EXTENDED MEMORY SIZE IN SECTORS [244]***Read states (for DSKRD routine):**  Since the overlay mechanism will now automatically load any swap file*  into extended memory for the calling program, various "read states"*  have been added to the DSKRD routine.  These states describe what*  is expected of the read routine.**  Note:  The swap file is read into the very top portion of the*         extended memory.*RCAT:   equ 0 read catalogRFIRST: equ 1 read first sector of the object fileRRESTN: equ 2 read the rest of the object file - no configurationRREST:  equ 3 read the rest of the object file - valid configuration foundRSWAP:  equ 4 read the swap file into the extended memoryEJECT**CORE TO CORE COPY ROUTINE*CCOPY:...IM(-20) TO D1 MAKE SURE INTERRUPTS ARE OFFPCI TO RTRA TRANSFER TO THE CORE-TO-CORE COPY ROUTINEDATA (CCOPY2-.-1)**EXTERNAL MEMORY TO CORE COPY:*ECOPY:...IM(-20) TO D1 DISABLE INTERRUPTSPCI TO RTRA TRANSFER TO THE EXTERNAL MEMORY-TO-CORE COPY ROUTINEDATA (ECOPY2-.-1)**OVERLAY A FILE*OVLAY:... ENTER HERE TO OVERLAY SECTOR NUMBERIM(-20) TO D1 DISABLE INTERRUPTS FOR SURE DURING LOADR2 TO R6 PRESERVE THE DESTINATION ADDRESS FOR FINAL TRANSFERIM(RFIRST) TO R16 SET STATE TO READ FIRST SECTOR OF OBJECT FILERE(RDCAT) TO RTRA GO READ IN THE FILE**LOAD PROGRAM NAMED 'MONITOR'*FBOOT:...IM(-20) TO D1 DISABLE INTERRUPTSPCI TO R0 SET UPDATA 47515 MOPCI TO R1 SET UPDATA 44516 NIPCI TO R2 SET UPDATA 47524 TOPCI TO R3 SET UPDATA 122 R**MAIN LOOP: LOAD FILE NAMED IN R0-R3*NBOOT:...IM(-20) TO D1 DISABLE INTERRUPTSR0 TO R4 SAVE FILENAME IN R4-R7R1 TO R5R2 TO R6R3 TO R7**NOW SET UP FOR READ OF FLOPPY*IM(0) TO R0 SET THE DEVICE ADDRESS TO THE SYSTEM DEVICEIM(0) TO R1 SECTOR 0 TRACK 0IM(0) TO R2 AND CORE LOCATION 0 IS DESTINATIONPCI TO R3 AND SET UP CATALOG LENGTHDATA CATLENIM(RCAT) TO R16 SET STATE TO READ IN THE CATALOGEJECT**READ THE CATALOG OR A FILE*RDCAT:... READ CATALOG ENTRANCEim(-1) to R12 try to find the device/drive ID for the device passed in R0R0 to R14 set the logical drive ID asidePCI to AND0 extract just the logical device codedata 177000 (LSB in upper byte is the logical drive number - ignore it as well)re(DECODE) to RTNZ nonzero device type - go decode itR17 to R0 get our current locationPCI to ADD0 point to current device - following word is system devicedata (MEMDIF-CURDEV-(.-1))R0 to R12 save this pointerR14 to R0 recover the logical drive IDPCI to TAND0 see if the drive number is onedata 400 LSB in upper byteim(1) to RTNZ if non-zero, we want the current device (already point to it)R12I to ATNV otherwise, want system device - point to itMR12 to R0 pick up desired devicePCI to AND0 keep just the devicedata 377R0 to R12 move to R12re(CHKDEV) to RTRA and go check the device's validityDECODE: PCI to TSUB0 decode the device typedata 1000 floppy?re(CHKDEV) to RTNZ no, we aren't interested in decoding any other devicesim(0) to R12 set device code in R12R14 to R0 pick up logical device againPCI to TAND0 check drive numberdata 400re(CHKDEV) to RTZE no drive number - R12 is the deviceim(20) to R12 set it to floppy drive one (normally, we'd OR this bit in)CHKDEV: R12 to R0 pick up resultim(17) to TAND0 mask off everything except device type (lower nibble)re(FNDERR) to RTNZ it had better be zero**We can trash the MS sector now since it isn't supported by the catalog structure.*im(0) to R14 assume we are reading drive zeroPCI to TAND0 check if it's zero or onedata 360 any drive number is treated as drive one for nowim(1) to RTZE it's drive zeroim(1) to R14 otherwise, it's drive oneR1 to R0 shift everything down so the code that only had an LS sector worksR2 to R1R3 to R2 R3 is now free*R14 TO R3 GET DRIVE INFOIM(1) TO AND3 EXTRACT DRIVE NUMBERR17 TO ADD3 ADD IN OUR CURRENT LOCATION IN MEMORYPCI TO ADD3 POINT TO HIGHCORE HEAD POSITION OF THIS DRIVEDATA (MEMDIF-HDPOS-(.-1))MR3 TO D101 SET TRACK REGISTER TO THAT DRIVE'S CURRENT POSITIONEJECT**MAIN DISK READ ROUTINE - RETURNS IF READ OF CATALOG*DSKRD:... SET UP TO READ THE DISKPCI TO ADD2 ROUND LENGTH TO NEXT SECTORDATA 377 (ADD 255)PCI TO AND2 IGNORE OFFSET INTO SECTORDATA 177400R1 TO R11 PRESERVE R1R2 TO R10 PRESERVE R2R17 TO R3 GET CURRENT LOCATIONPCI TO ADD3 POINT TO SYSTEM DEVICE TABLE IN CONFIGURATIONDATA (MEMDIF-STRDEV-BLKLEN-(.-1))R17 TO R1 GET CURRENT LOCATIONPCI TO ADD1 POINT TO END OF SYSTEM DEVICE TABLE IN CONFIGURATIONDATA (MEMDIF-STREND-(.-1))FNDBLK:... SEARCH THE TABLE FOR THE PROPER BLOCKIM(BLKLEN) TO ADD3 LOOK AT NEXT BLOCKR1 TO TSUB3 MAKE SURE WE AREN'T AT THE END OF THE TABLEIM(2) TO RTNZ NOT AT THE END YETFNDERR: IM(7) TO D50 AT THE END WITHOUT FINDING ITIM(-2) TO RTRA LOOP FOREVERMR3 TO R2 PICK UP DEVICE TYPEPCI TO AND2 EXTRACT JUST THE DEVICE TYPEDATA 377R12 TO TSUB2 IS THIS THE DEVICE WE WANT?RE(FNDBLK) TO RTNZ NO, KEEP LOOKINGR3 TO R15 SAVE POINTER TO BLOCK FOR DRIVEIM(SECPT) TO ADD3 POINT TO SECTORS/CYLINDERMR3 TO R2 AND SAVE SECTORS/CYLINDERim(0) to R1 set default drive IDD51 to R3 pick up device identifier bitsPCI to TAND3 see if floppy controller is D100Adata 10000re(SETINF) to RTZE no, can't read drive IDR14 to R3 get drive infoPCI to OR3 set sign bit to signify D100Adata 100000R3 to R14R14 to D104 select driveD104 to R1 get drive IDSETINF: im(10) to AND1 get rate bit from drive IDR14 to OR1 OR it into drive infoMR15 to R3 get config bitsPCI to TAND3 check densitydata 400im(1) to RTZE already correctim(4) to OR1 set MFM densityPCI to TAND3 check for rate overridedata 1000im(1) to RTZE no overrideim(10) to OR1 override to 8" rateIM(-1) TO R13 DIVIDE BY SECCYL TO GET DEVICE ADDRESSR13I TO ATNV INCREMENTR2 TO SUB0 AND SUBTRACT SECCYL FROM DEVICE ADDRESSIM(-3) TO RTRC IF CARRY, THEN RETRYR2 TO ADD0 AND GENERATE SECTORS 0 TO (SECCYL-1)R15 to R3 point to device table entryim(STPSP) to ADD3 point to sectors/trackMR3 to R3 pick up sectors/trackim(0) to BSOR3 move to lowerPCI to AND3 and extract just sectors/trackdata 377R3 to TSUB0 see if sector number is greater than SECPTre(SIDE0) to RTMI no, we're on side zeroR3 to SUB0 restrict sector number to SECPTim(2) to OR1 set side oneSIDE0: IM(1) TO ADD0 GENERATE SECTORS 1 TO SECPTR1 to R14 put drive info backR11 TO R1 RESTORE R1R10 TO R2 RESTORE R2EJECT**RETRY WITH SEEK *  R0 = SECTOR NUMBER, 1 TO SECPT*  R1 = MEMORY POINTER*  R2 = LENGTH TO READ*  R3 = SCRATCH REGISTER*  R4-R7 = NAME OF FILE TO LOAD (STATE RCAT ONLY)*  R4 = ADDRESS OF SWAP FILE (STATE RSWAP ONLY - PASSED TO TARGET PROGRAM)*  R5 = UNUSED (ALL STATES EXCEPT RCAT)*  R6 = DESTINATION POINTER [R2 AT ENTRANCE] (ALL STATES EXCEPT RCAT)*  R7 = SUBROUTINE RETURN ADDRESS (ALL STATES EXCEPT RCAT IN WHICH NO SUBROUTINES ARE CALLED)*  R10 = SAVED R1 (UPDATED AFTER EACH TRACK READ)*  R11 = STEPPING SPEED*  R12 = COMMAND TO EXECUTE AND SCRATCH*  R13 = TRACK NUMBER*  R14 = DRIVE/SIDE NUMBER*  R15 = POINTER TO STORAGE DEVICE ENTRY FOR THIS DRIVE*  R16 = READ STATE (SEE ABOVE)*K.RFL: R14 TO D104 RETRY HERE - TURN ON THE MOTOR AT THIS POINT*B.RFL: D100 TO R3 CHECK STATUSIM(1) TO TAND3 SEE IF BUSY FROM RESTOREIM(-3) TO RTNZ IF SO,  THEN GO BACKR13 TO D103 SET UP DESIRED TRACKR15 TO R3 GET POINTER TO STORAGE DEVICE ENTRYIM(STPSP) TO ADD3 POINT TO STEPPING SPEEDMR3 TO R3 AND PICK UP STEPPING SPEEDPCI TO AND3 EXTRACT LOWER BYTEDATA 377R3 TO R11 SET STEPPING SPEED ASIDEIM(20) TO ADD3 SET SEEK FLAGR3 TO D100 AND PERFORM SEEK AT CORRECT RATED100 TO R3 AND WAIT HEREIM(1) TO TAND3 WHILE BUSYIM(-3) TO RTNZ GO BACK WHILE BUSYR14 to LOA3 see if we're talking to a D100Are(P.RFL) to RTPL we aren'tim(2) to AND3 get sideim(1) to RTZE side zeroim(10) to R3 side onePCI to OR3 get commanddata 206 delay, verify sideR3 to R12 move to R12re(D.RFL) to RTRA start the readP.RFL: PCI TO R12 AND SET UP INITIAL COMMANDDATA 214 TO BE READ, NOT MUL, IBM + WAIT FOR 10 MS FOR HEAD TO SETTLE**PERFORM READ, R12 = COMMAND*D.RFL: R14 TO D104 TURN ON MOTOR FOR SURE HERED100 TO R3 WAIT FOR READYPCI TO TAND3DATA 200IM(-4) TO RTNZ SHOULD GO TO ZEROR0 TO D102 SET UP SECTOR REGISTER HERER16 TO LOA3 CHECK READ STATEIM(RSWAP) TO TSUB3 LOADING SWAP FILE?IM(2) TO RTNZ NO, SAVE R1D60 TO R10 YES, SET R10 POINTING TO START OF THIS TRACK'S DATA USING D60IM(1) TO RTRA AND SKIP R1 ASSIGNMENTR1 TO R10 SET R10 POINTING TO START OF THIS TRACK'S DATA IN CASE OF RETRYR16 TO LOA3IM(RFIRST) TO TSUB3 Force read of entire first sectorRE(A.RFL) TO RTZER2 TO LOA2 TEST FOR ZERO AT THIS POINTPCI TO RTZE IF ZERO,  THEN WE ARE DONEDATA E.RFL-.-1 RELATIVE POINTERA.RFL: D102 TO TSUB0 MAKE SURE SECTOR REG LOADED OKD102 TO TSUB0 MAKE SURE SECTOR REG LOADED OKRE(D.RFL) TO RTNZ TRY AGAIN WITH LOAD IF NOT THERER12 TO D100 AND START READ COMMANDEJECT**FLOPPY READ:  DATA LOOP**THE READ COMMAND HAS BEEN STARTED.  PERFORM LOOP, CHECKING STATUS, AND*READ AS MANY BYTES FROM THE DISK AS THE CHIP WILL GIVE TO US.*RE(N.RFL) TO RTRA LOOP HERE FOR NEXT WORDIM(1) TO TAND3 CHECK IF STILL BUSYRE(G.RFL) TO RTZE IF NOT, THEN SKIP OUT OF ITN.RFL: D100 TO R3 PICK UP DISK STATUSIM(2) TO TAND3 SEE IF DATA REQUESTIM(-5) TO RTZE IF NOT, THEN CONTINUE TO LOOPD103 TO R12 PICK UP BYTEIM(2) TO R3 GET DATA REQUEST BITD100 TO TAND3 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET DATAD103 TO R3 GET BYTER12 TO BSOR3 FORM NEXT WORDR3 TO R12 SET WORD ASIDER16 TO LOA3 CHECK READ STATEIM(RSWAP) TO TSUB3 READING IN THE SWAP FILE?RE(O.RFL) TO RTNZ NO, STORE IN MEMORYR12 TO D63 YES, STORE IN EXTERNAL MEMORYRE(N.RFL) TO RTRA GO BACK FOR MORE WORDSO.RFL: R12 TO MR1I STORE INTO MEMORYRE(N.RFL) TO RTRA GO BACK FOR MORE WORDS*G.RFL:PCI TO TAND3 CHECK FOR CRC, DATA LATE, OR LOOSING READYDATA 214RE(H.RFL) TO RTZE IF NOT,  THEN AN OK DATA TRANSFERR16 TO LOA3 CHECK READ STATEIM(RSWAP) TO TSUB3 LOADING SWAP FILE?IM(2) TO RTNZ NO, RESET R1R10 TO D60 YES, RESET D60IM(1) TO RTRA AND SKIP R1 ASSIGNMENTR10 TO R1 RETRY - RESET R1 TO START OF DATA AREAIM(7) TO D50 RING BELL FOR ATTENTIONI.RFL:PCI TO R12 AND SET UP R12 CONTAINING COMMANDDATA 210 THIS IS READ COMMAND, NOT MULTIPLE, IBM FORMAT, NO HEAD DELAYR14 to LOA3 see if we're talking to a D100APCI to RTPL not D100ADATA D.RFL-.-1im(2) to AND3 get sideim(1) to RTZE side zeroim(10) to R3 side onePCI to OR3 add in commanddata 202 verify sideR3 to R12 move command to R12PCI TO RTRA AND GO BACK AND TRY AGAINDATA D.RFL-.-1 RELATIVE DISTANCEEJECT**FLOPPY READ:  CHECK STATUS**MAKE SURE ALL DATA WAS READ BY THE COMPUTER,  AND*THAT NO ERRORS WERE ENCOUNTERRED*H.RFL:IM(20) TO TAND3 CHECK FOR RECORD NOT FOUNDRE(J.RFL) TO RTZE IF NOT,  THEN WAS OK DATA & CORRECT ITEMR11 TO R3 GET STEPPING SPEEDPCI TO ADD3 ADD IN STEP FLAGDATA 100R3 TO D100 PERFORM A STEP IN IN ANY CASED100 TO R3IM(1) TO TAND3 WAIT FOR STEP TO FINISHIM(-3) TO RTNZ WAIT WHILE BUSYR11 TO D100 START A RESTORE OPERATIONR16 TO LOA3 CHECK READ STATEIM(RSWAP) TO TSUB3 LOADING SWAP FILE?IM(2) TO RTNZ NO, RESET R1R10 TO D60 YES, RESET D60IM(1) TO RTRA AND SKIP R1 ASSIGNMENTR10 TO R1 AND RESET POINTERIM(7) TO D50 RING BELL ON SEEK ERRORPCI TO RTRA AND GO BACK ANDDATA B.RFL-.-1 AND PERFORM IT**CHECK FOR NEXT*J.RFL:R16 to R3 check read stateim(RSWAP) to TSUB3 reading swap file?im(2) to RTNZ noim(1) to SUB2 yes, subtract one sector (R2 is sector length)im(2) to RTRAPCI to SUB2 otherwise, subtract one sector in wordsdata 400IM(1) TO RTRC Set lengthIM(0) TO LOA2PCI TO RTZE IF DONE, THEN NO MORE TO GODATA E.RFL-.-1im(RFIRST) to TSUB3 are we reading the first sector?re(M.RFL) to RTNZ no, keep goingR17I to R7 set up to call end of RFIRST state routine (save return)re(M.RFL) to RTRA <= return here (skip the call - fall through)EJECT**End of RFIRST state - R6 points to the sector we just read in; R7 is return*  When we return, R2 will be the remaining length of the object file*  and R16 will be the new state.**To call this subroutine:*  R17I      to R7 save return in R7*  re(RETRN) to RTRA <= return here!*  re(ENDRF) to RTRA call this routine*  RETRN: ...*ENDRF: im(RRESTN) to R16 change state to read rest of object - assume no configurationMR6 to R3 check for valid XPL config - get first word of programPCI to TSUB3 make sure it matches the first instruction of all XPL programsPCI TO LOA0 <<---- this is the first instruction of all XPL programs ---->>R7 TO ATNZ doesn't match - no configim(CONTAB) to R3 point to pointer to config tableR6 to ADD3 add in address where we read this sectorMR3 to LOA3 point to config tableR7 to ATZE zero - no configPCI to TSUB3 make sure pointer's in rangedata 400-TABLEN has to fit within first sectorR7 to ATRC out of range (IGT test) - invalid configim(OBJLEN) to ADD3 point to object length in configMR3 to R2 pick up actual object file lengthim(400-377) to SUB2 but subtract out the sector we just read and round to nearest sector (add 377)PCI to AND2 ignore offset into sectordata 177400im(RREST) to R16 change state to read rest of object - valid configR7 to ATRA return hereEJECT**CHECK FOR END OF TRACK**M.RFL: R15 TO R3 GET POINTER TO STORAGE DEVICE ENTRYIM(STPSP) TO ADD3 POINT TO SECTORS/TRACKMR3 TO R3 AND PICK UP SECTORS/TRACKim(0) to BSOR3 move to lowerPCI to AND3 keep just sectors/trackdata 377R0I TO TSUB3 SEE IF AT END OF TRACK (COMPARE WITH SECTORS/TRACK); INCREMENT SECTOR NUMBERPCI TO RTNZ IF NOT, SAME TRACK, NEXT SECTORDATA I.RFL-.-1IM(1) TO R0 BACK TO SECTOR 1R15 to R12 point to storage device table entryR12I to ATNV point to sectors/cylinderMR12 to TSUB3 see if double-sided (double-sided if SECPT <> SECCYL)re(C.RFL) to RTZE single-sidedR14 to R3 change sidesim(2) to XOR3 like soR3 to R14im(2) to TAND3 back at side zero?PCI to RTNZ no, keep reading same trackdata I.RFL-.-1C.RFL: R13I TO ATNV INCREMENT TRACKPCI TO RTRA ELSE GO BACK AND SEEK TO NEXT TRACKDATA B.RFL-.-1 POINTER FOR SEEK TO NEXT TRACK & COUNTC.RFLB: re(M.RFL) to RTRA midway jump point**Handle state transitions after read*E.RFLB: R16 to R3 move the new state into R3E.RFLA: im(RRESTN) to TSUB3 read rest of object file, no config?R6 to ATZE yes, we're all set - start up target program hereim(RREST) to TSUB3 read rest of object file, valid config?PCI to RTNZ no, go copy configdata ERSWAP-.-1R2 TO TLOA2 Check to see if we've read it allre(M.RFL) to RTNZR17I to R7 set up to call end of RREST routine (save return in R7)re(C.RFLB) to RTRA <= return herere(ENDRR) to RTRA call end of RREST routine**DONE WITH READ - NOW CHECK IF CATALOG READ OR PROGRAM READ** SEE IF WE JUST READ CATALOG OR MONITOR OR PROGRAME.RFL: R16 TO LOA3 TEST READ STATEPCI TO RTZE ZERO MEANS SEARCHING FOR A FILE (READING THE CATALOG)DATA CAT-.-1R14 TO R3 GET DRIVE INFOIM(1) TO AND3 EXTRACT DRIVE NUMBERR17 TO ADD3 ADD IN CURRENT POSITIONPCI TO ADD3 POINT TO HIGHCORE HEAD POSITION FOR THIS DRIVEDATA (MEMDIF-HDPOS-(.-1))D101 TO MR3 SET THE HEAD POSITION TO THE CONTENTS OF THE TRACK REGISTERR16 TO LOA3im(RFIRST) to TSUB3 read first sector of object file?re(E.RFLA) to RTNZ no, keep lookingR17I to R7 set up to call end of RFIRST state routine (save return in R7)re(E.RFLB) to RTRA <= return herePCI to RTRA call end of RFIRST state routinedata ENDRF-.-1EJECT**End of state RREST - prepare to read in the swap file; R1, R2, and R3 are free*  R6 points to the object file just read in; R7 is the return*  When we return, R2 will contain the sector length of the swap file and*  both D60 and R4 will contain the address of the swap file.**Note:  If there is no swap file, this routine does NOT return!**To call this subroutine:*  R17I      to R7 save return in R7*  re(RETRN) to RTRA <= return here!*  re(ENDRR) to RTRA call this routine*  RETRN: ...*ENDRR: im(CONTAB) to R3 point to pointer to configurationR6 to ADD3 add in base of object fileMR3 to LOA3 pick up configuration pointerim(SWPLEN) to ADD3 point to swap file lengthMR3 to LOA2 pick up length (in sectors)re(CPYFIG) to RTZE no swap file - get outR17 to R3 get current locationPCI to ADD3 point to external memory size in highcoredata (MEMDIF-EMSIZE-(.-1))MR3 to LOA1 pick up extended memory sizeim(2) to RTNZ non-zero - we have extended memorySWERR: im(7) to D50 no extended memory or swap file too largere(SWERR) to RTRA beep foreverR2 to SUB1 find starting sector for swap file in extended memory (from top)re(SWERR) to RTMI too largeR1 to R4 save swap file startR1 to D60 and set up the extended memoryim(RSWAP) to R16 change state to read swap fileR7 to ATRA and go read in the swap file (return)EJECT**End of RSWAP - reset D60 (early boards would crash to D61 after loading)*ERSWAP: R4 to D60 reset D60 to start of swap file**COPY CONFIGURATION*CPYFIG:... VALIDATE AND COPY CONFIGURATIONR17 TO R3 GET CURRENT POSITIONPCI TO ADD3 POINT TO THE MAGIC NUMBER IN HIGHCOREDATA (MEMDIF-MAGIC-(.-1))MR3 TO R3 PICK UP MAGIC NUMBER FROM HIGHCOREPCI TO TSUB3 MAKE SURE IT'S CORRECTDATA 30071 THIS IS 12345 DECIMALR6 TO ATNZ IF NOT, DON'T COPY CONFIG (AS HIGHCORE ISN'T THERE)IM(CONTAB) TO R2 POINT TO THE CONFIGURATION TABLE POINTERR6 TO ADD2 OFFSET POINTER FROM START OF OBJECT FILEMR2 TO LOA2 LOAD THE POINTERIM(CURTRK) TO ADD2 POINT TO CURRENT TRACK POINTERR17 TO R1 GET CURRENT POSITIONPCI TO ADD1 POINT TO FLOPPY HEAD POSITIONSDATA (MEMDIF-HDPOS-(.-1))R1 TO MR2 UPDATE LOWCORE POINTER TO POINT TO HIGHCORE**WE HAVE A VALID CONFIG - COPY CONFIGURATION*IM(CONTAB) TO R1 POINT TO LOWCORE CONFIGURATION POINTERR6 TO ADD1 OFFSET POINTER FROM START OF OBJECT FILEMR1 TO R1 GET LOWCORE CONFIGURATION POINTERIM(CONINF) TO ADD1 SKIP OVER AREA THAT ONLY RESIDES IN LOWCORER17 TO R2 GET CURRENT LOCATIONPCI TO ADD2 POINT TO START OF HIGHCORE CONFIGURATIONDATA (MEMDIF-CTABOF-(.-1))PCI TO R0 GET LENGTH TO COPYDATA TABLEN-CONINFMR2I TO MR1I COPY AWAYIM(1) TO SUB0 SEE IF WE'RE DONE YETIM(-3) TO RTNZ NOT DONE YETR6 TO ATRA DONE - GO START PROGRAM**SEARCH FOR FILE*CAT:IM(0) TO R0 START HERECAT1:R0 TO R1 SET UP WORD POINTER IN R1MR1I TO R2 GET DATAR4 TO SUB2RE(CAT2) TO RTNZ NOT USMR1I TO R2 GET DATAR5 TO SUB2RE(CAT2) TO RTNZMR1I TO R2 GET DATAR6 TO SUB2 EQUALRE(CAT2) TO RTNZ NOT USMR1I TO R2 GET DATAR7 TO SUB2 EQUALRE(CAT2) TO RTNZ NOT USMR1I TO R0 GET BASE SECTORIM(1) TO ADD1 SKIP NEXTMR1I TO R2 AND GET FILE LENGTH = NUMBER OF WORDS TO READIM(0) TO R1 AND MEMORY POINTER IS LOCATION 0R1 TO R6 REMEMBER INITIAL MEMORY POINTER HEREIM(0) TO R12 PUT THE DRIVE ID IN R12 (ASSUME F0 - THE SYSTEM DEVICE)IM(RFIRST) TO R16 SET STATE TO READ FIRST SECTOR OF OBJECT FILEPCI TO RTRA AND GO READ IN THE FILEDATA DSKRD-.-1CAT2:IM(10) TO ADD0 INCREMENT MEMORY POINTERPCI TO TSUB0 SEE IF DONEDATA CATLENRE(CAT1) TO RTNZ IF NOT DONE,  GO BACKIM(7) TO D50IM(-2) TO RTRA BEEP FOREVEREJECT**Core-to-core copy:*  R0: source address*  R1: destination address*  R2: length*CCOPY2: R1 to R6 move starting address for later transferim(RFIRST) to R16 set state to read first sectorPCI to R3 read in first sectordata 400R3 to SUB2 save amount remaining to be copied (after first sector)re(CCOPY3) to RTRCim(0) to R2 no words left to copy, set to zeroCCOPY3: MR0I to MR1I copy one word at a timeim(1) to SUB3 keep track of how much we've copiedre(CCOPY3) to RTNZ loop until counter equals zeroR16 to R3 check stateim(RFIRST) to TSUB3 reading first sector?re(CCOPY8) to RTNZ R17I to R7 call end of RFIRST routine (save return in R7)re(CCOPY4) to RTRA <= return herePCI to RTRA and call end of RFIRST routinedata (ENDRF-.-1)CCOPY4: R2 to LOA3 set remaining lengthre(CCOPY3) to RTNZ begin copying remaining codeCCOPY8: R16 to R3 move the new state into R3im(RREST) to TSUB3 did we just read the rest of the object file (with valid config)?R6 to ATNZ no, start up the program here (states RFIRST and RRESTN)R17I to R7 call end of RREST routine (save return in R7)re(CCOPY5) to RTRA <= return here (if we return)PCI to RTRA and call end of RREST routinedata (ENDRR-.-1)CCOPY5: MR0I to TLOA3 find the end of the last sector of the object filere(CCOPY5) to RTZE ends when we find a non-zero wordim(1) to SUB0 and back up R0 (we overstepped by one)CCOPY6: PCI to R3 set word counterdata 400 to one sectorCCOPY7: MR0I to D63 copy the next wordim(1) to SUB3 decrement word countre(CCOPY7) to RTNZ loop until the whole sector is copiedim(1) to SUB2 decrement sector countre(CCOPY6) to RTNZ loop until whole swap file copiedPCI to RTRA and go to itdata (ERSWAP-.-1)EJECT**External memory-to-core copy:*  R0: source sector in external memory*  R1: destination address in main memory*  R2: length to copy*ECOPY2: R1 to R6 move starting address for later transferR0 to D60 send starting sector number to external memoryim(RFIRST) to R16 set state to read first sectorPCI to R3 read in first sectordata 400R3 to SUB2 save amount remaining to be copied (after first sector)re(ECOPY3) to RTRCim(0) to R2 no words left to copy, set to zeroECOPY3: D63 to MR1I copy one word at a timeim(1) to SUB3 keep track of how much we've copiedre(ECOPY3) to RTNZ loop until counter equals zeroR16 to R3 check stateim(RFIRST) to TSUB3 reading first sector?re(ECOPY8) to RTNZ copy completed?R17I to R7 call end of RFIRST routine (save return in R7)re(ECOPY4) to RTRA <= return herePCI to RTRA and call end of RFIRST routinedata (ENDRF-.-1)ECOPY4: R2 to LOA3 set remaining lengthre(ECOPY3) to RTNZ begin copying remaining codeECOPY8: R16 to R3 move the new state into R3im(RREST) to TSUB3 did we just read the rest of the object file (with valid config)?R6 to ATNZ no, start up the program here (states RFIRST and RRESTN)R1 to R0 save memory pointerD60 to R3 move to the end of the last sector of the object fileD61 to TLOA3 see if non-zero word pointerim(1) to RTZE it's zeroim(1) to ADD3 nonzero, point to next sectorR3 to R12 save start of swap file (ENDRR trashes D60)R17I to R7 call end of RREST routine (save return in R7)re(ECOPY5) to RTRA <= return here (if we return)PCI to RTRA and call end of RREST routinedata (ENDRR-.-1)ECOPY5: D60 to R13 set destination sector address asideR12 to D60 point back to the start of the swap file in extended memoryR0 to R1 set memory pointerPCI to R3 set word counterdata 400 to one sectorECOPY6: D63 to MR1I copy the next wordim(1) to SUB3 decrement word countre(ECOPY6) to RTNZ loop until the whole sector is copiedD60 to R12 save new source sector addressR13 to D60 set destination sector addressR0 to R1 set memory pointerPCI to R3 set word counterdata 400 to one sectorECOPY7: MR1I to D63 copy the next wordim(1) to SUB3 decrement word countre(ECOPY7) to RTNZ loop until the whole sector is copiedim(1) to SUB2 decrement sector countre(ECOPY5) to RTNZ loop until whole swap file copiedPCI to RTRA and go to itdata (ERSWAP-.-1)