/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: S-STAB0CONTAINS: SOURCE CODE FOR PROGRAM "STAB"REVISION HISTORY:00	1998/07/16	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*THIS PROGRAM WILL CONSTRUCT THE SYNCLAVIER LOOKUP TABLES IN THE ARRAY "file",THEN PRESENT THE USER WITH A "SAVE TO DISK" DIALOG WITH "W0:.SYSTEM:.STAB-7"AS THE DEFAULT TREENAME..STAB-7 IS STRUCTURED AS FOLLOWS:SECTORS 00 THROUGH 03 (4 SECTORS):	FM FREQ TABLE, LOW RANGE	(WORDS 0000 THROUGH 1023)SECTORS 04 THROUGH 07 (4 SECTORS):	FM FREQ TABLE, HIGH RANGE	(WORDS 1024 THROUGH 2047)SECTORS 08 THROUGH 08 (1 SECTOR):	SINE TABLE						(WORDS 2048 THROUGH 2303)SECTORS 09 THROUGH 12 (4 SECTORS):	LOG TABLE						(WORDS 2304 THROUGH 3327)SECTORS 13 THROUGH 28 (16 SECTORS):	POLY FREQ TABLE				(WORDS 3328 THROUGH 7423)*//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/enter	 ':Z.XPL:LIBRARYS';insert 'L#GNRL.0';		// TY'S AND NED'S LITERALSdcl round lit 'true';	// TO ENHANCE COMPREHENSIBILITY OF CALLS TO "integer_component"/*ииииииииииииииии  R E L O C A T A B L E   B I N A R Y S  ииииииииииииииии*//*ииииииииииии  A N D   E X T E R N A L   R E F E R E N C E S  ииииииииииии*/lib 'R#GNRL.0'; ins 'E#GNRL.0';lib 'R#FLOA.0'; ins 'E#FLOA.0';lib 'R#TINT.0';lib 'R#APPL.0'; ins 'E#APPL.0';lib 'R#LINE.0';lib 'R#DISK.0'; ins 'E#DISK.0';lib 'R#DISK.1'; ins 'E#DISK.1';ent '*';lib ':-xpl:libs:intrprtr';	//	For PPC compatibility/*иииииииииииииииииии  P U B L I C   V A R I A B L E S  иииииииииииииииииии*/dcl file(shl(29,8)-1)	fixed;	//	ARRAY TO CONSTRUCT THE FILE INdcl file.index				pointer;	//	POINTER INTO THE ARRAYdcl pi						floating;//	STRING CONSTANTSdcl $program_name	data pub ('');	//	Must declare this to make R#APPL.0 happy/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FUNCTION "approximate.float" IS PASSED A FLOATING POINT VALUE (TYPICALLY THE OUTPUT OF A TRANSCENDENTAL FUNCTION) IN THE//	RANGE OF 1/256 TO 256/1.  IT FINDS THE PAIR OF 8-BIT INTEGERS (0 INTERPRETED AS 256) WHO'S RATIO MOST CLOSELY APPROXIMATES THE//	VALUE OF THE PASSED FLOAT, THEN RETURNS A 16-BIT WORD WITH THE NUMERATOR IN THE UPPER BYTE AND THE DENOMINATOR IN THE LOWER BYTE.//	NOTE: CURRENTLY, COMMON FACTORS ARE NOT REMOVED FROM THE PAIR OF 8-BIT INTEGERS.  FOR EXAMPLE, THE INPUT 0.666666667 WILL YIELD//	170,255 RATHER THAN 2,3.//	 //	These ratios provide 24513 discreet gradations between 1/256 and 1, and the same number between 1 and 256, although the gradations//	are not evenly spaced.  It's best to avoid ranges approaching 1/256 or 256 since the gradations get farther apart there.//	//	The general formulae for the number of gradations between 1/max_denom and 1 is://	for even max_denom, (3*max_denom^2 - 2*max_denom + 8)/8//	for odd max_denom,  (3*max_denom^2 + 5)/8////	NOTE: The information above was written when the upper limit of the numerator and denominator werw assumed to be 256.//	The procedure has since been modified to allow other limits to be passed to it.////	NOTE: Currently this procedure only works reliably with values of max.numerator and max.denominator up to 32766.//	In order for this to be extended to 65534, a procedure will have to be written to give a float the quotient of//	two fixed values interpreted as UNSIGNED integers.//approximate.float: proc (float,max.numerator,max.denominator) returns (fixed);	dcl float floating;	dcl (max.numerator,max.denominator)	fixed;	dcl difference				floating;	dcl minimum.difference	floating;	dcl (numerator,denominator)				 fixed;	dcl (final.numerator,final.denominator) fixed;	minimum.difference = 1;					// START WITH "minimum.difference" SET TO JUST ABOVE THE MAXIMUM POSSIBLE VALUE	// DETERMINE THE INITIAL (HIGHEST) VALUES FOR THE NUMERATOR AND DENOMINATOR	do case compare_floats(max.numerator/max.denominator,float);		//	CASE 0: THE TWO FLOATS ARE IDENTICAL - NO NEED TO SEARCH.		return (shl(max.numerator,8)|(max.denominator&255));		//	CASE 1: THE TWO FLOATS HAVE DIFFERENT SIGNS - NOT APPLICABLE HERE.		;		//	CASE 2: max.numerator/max.denominator IS LESS THAN float: max.denominator MUST BE REDUCED.		{	max.denominator = int(integer_component(max.numerator/float,round));			if (int(max.denominator*float) igt max.numerator) max.denominator = max.denominator-1;		}		// CASE 3: max.numerator/max.denominator IS GREATER THAN float: numerator MUST BE REDUCED.  (THIS IS DONE BELOW, SO DO NOTHING HERE.)		;	end;	//	CHECK WITH ALL DENOMINATORS STARTING WITH THE HIGHEST (YIELDING THE SMALLEST INCREMENTS)	// NOTE: ALL DENOMINATORS <= shr(denominator,1) ARE REDUNDANT	do denominator = max.denominator to shr(max.denominator,1)+1 by -1;		// CHECK WITH FLOOR NUMERATOR		numerator = int(denominator*float);		difference = float-(numerator/denominator);	//	SHOULD ALWAYS BE >= 0		if (compare_floats(difference,minimum.difference) == #ilt)	// if abs(difference) < abs(minimum.difference)		{	minimum.difference = difference; final.numerator = numerator; final.denominator = denominator;}		// CHECK WITH CEILING NUMERATOR		if (numerator ilt max.numerator) {			numerator = numerator+1;			difference = (numerator/denominator)-float;	//	SHOULD ALWAYS BE >= 0			if (compare_floats(difference,minimum.difference) == #ilt)			{	minimum.difference = difference; final.numerator = numerator; final.denominator = denominator;}		}		// NO NEED TO CONTINUE SEARCHING IF WE'VE NAILED OUR TARGET		if ((core(addr(minimum.difference))|core(addr(minimum.difference)+1)) == 0) return (shl(final.numerator,8)|(final.denominator&255));	end;	return (shl(final.numerator,8)|(final.denominator&255));end approximate.float;/*иииииииииииииииииииииии  M A I N   P R O G R A M  иииииииииииииииииииииии*/set_catbuf(addr(cat_buf(0)),0);pri cls,;//	Either of the following lines will give the variable "pi" the closest value//	to actual pi that an XPL floating point variable is capable of representing.//	This accuracy cannot be achieved with "pi = 3.14159265"//	core(addr(pi)) = 25735; core(addr(pi)+1) = 60866;pi = 8165/2599;pri LF,'GENERATING FM FREQ TABLE, LOW RANGE  ',;do file.index = 0 to shl(4,8)-1;				//	4 SECTORS STARTING AT SECTOR 0, (0 THROUGH 1023)	if ((file.index & 255) == 0) pri ascii_asterisk,;	// GIVE THE USER SOME INDICATION OF PROGRESS	file(file.index) = approximate.float((99/100)*exp(log(2)*(file.index-308)/1024),128,255);end;pri LF,'GENERATING FM FREQ TABLE, HIGH RANGE ',;do file.index = shl(4,8) to shl(8,8)-1;	//	4 SECTORS STARTING AT SECTOR 4, (1024 THROUGH 2047) MAPPED TO (0 THROUGH 1023)	if ((file.index & 255) == 0) pri ascii_asterisk,;	// GIVE THE USER SOME INDICATION OF PROGRESS	file(file.index) = approximate.float((99/50)*exp(log(2)*(file.index-shl(4,8)-154)/512),128,255);end;pri LF,'GENERATING SINE TABLE    ',;do file.index = shl(8,8) to shl(9,8)-1;	//	1 SECTOR STARTING AT SECTOR 8, (2048 THROUGH 2303) MAPPED TO (0 THROUGH 255)	if ((file.index & 255) == 0) pri ascii_asterisk,;	// GIVE THE USER SOME INDICATION OF PROGRESS	file(file.index) = int(integer_component((sin(2*pi*(file.index-shl(8,8))/256)+1)*2047/2,round));end;pri LF,'GENERATING LOG TABLE     ',;do file.index = shl(9,8) to shl(13,8)-1;	//	4 SECTORS STARTING AT SECTOR 9, (2304 THROUGH 3327) MAPPED TO (0 THROUGH 1023)	if ((file.index & 255) == 0) pri ascii_asterisk,;	// GIVE THE USER SOME INDICATION OF PROGRESS	file(file.index) = int(integer_component((log(1+((file.index-shl(9,8))/1000))/log(2))*1024,round));end;pri LF,'GENERATING PS FREQ TABLE ',;do file.index = shl(13,8) to shl(29,8)-1;	//	16 SECTORS STARTING AT SECTOR 13, (3328 THROUGH 7423) MAPPED TO (0 THROUGH 4095)	if ((file.index & 255) == 0) pri ascii_asterisk,;	// GIVE THE USER SOME INDICATION OF PROGRESS	file(file.index) = approximate.float((99/200)*exp(log(2)*(file.index-shl(13,8)-3057)/1024),256,256);end;// NOW SAVE THE FILE TO DISK.//	THE NEXT LINE PLACES THE STRING 'W0:.SYSTEM:.STAB-7' IN THE LINE EDITOR FOR THE USER'S CONVENIENCE.// THE USER STILL HAS THE OPTION TO ENTER AN ALTERNATE NAME.copy_str('W0:.SYSTEM:.STAB-7',treename);if (save(t#data,file,file.index,false) == false) pri info_line,erase_to_eol,;