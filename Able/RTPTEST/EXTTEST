dcl (extsect, extword, seclen, wordlen) fixed;dcl device     lit '2';dcl start      lit '0';dcl track_size lit '30'; /* sectors/cylinder (we COULD look this up, but...) */dcl tracks     lit '16';dcl sectors    lit 'tracks*track_size';dcl buffer (track_size*256) fixed;dcl (i, j, k) fixed;when break then call exit (-1);print 'Please place the disk to be tested into ',;do case (device - 2);   print 'F0',;   print 'F1',;   print 'R0',;   print 'R1',;end;print ' and press RETURN ->',;linput buffer;print;call extset (0, 0, shl(sectors, 8), 0); /* zero out external memory */extsect = 0; extword = 0;seclen = sectors; wordlen = 0;print '*** Reading into external memory';call extread (shl(device,8), start, location(addr(extsect)));do i = 0 to tracks - 1;   call import (i*track_size, 0, buffer, track_size*256); /* read back what we wrote */   do j = 0 to track_size*256 - 1; /* check buffer */      if buffer (j) <> j then do; /* oops! */         k = i*track_size + j/256; /* compute sector number */         print 'Sector', k, ' (', octal(k),;         print '):  expected ', octal(j), ' got ', octal(buffer (j));         j = (j/256 + 1)*256 - 1; /* move to next sector boundary */      end;   end; /* of check buffer */end; /* of checking external memory */print '*** Writing from external memory';call extwrite (shl(device,8), start, location(addr(extsect)));print '*** Reading back into external memory';call extread (shl(device,8), start, location(addr(extsect)));do i = 0 to tracks - 1;   call import (i*track_size, 0, buffer, track_size*256); /* read back what we wrote */   do j = 0 to track_size*256 - 1; /* check buffer */      if buffer (j) <> j then do; /* oops! */         k = i*track_size + j/256; /* compute sector number */         print 'Sector', k, ' (', octal(k),;         print '):  expected ', octal(j), ' got ', octal(buffer (j));         j = (j/256 + 1)*256 - 1; /* move to next sector boundary */      end;   end; /* of check buffer */end; /* of checking external memory */