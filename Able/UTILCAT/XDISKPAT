/* DISKPAT  $TITLE  Winchester Disk Catalog Patch Program *//* It seems to be possible for the catalog sector of an old (UNSaved)  catalog to be around while the catalog sectors of true catalogs  are contained within the area previously occupied by said old  catalog.  This causes a terrible dilemma since both LOCATE.SUBCATS  and LOCATE.TEXT.FILES skip over catalogs in their searches (to  eliminate the appearance of files in SUBCATS at the topmost level).  There is a solution, but we haven't the time to fix it now.  If  some of your catalogs are still missing after running this, REMOVE  the code that skips over catalogs in LOCATE.SUBCATS and try again.  But be prepared to see all the catalogs in your subcatalogs appear! */dcl debug   lit '0';dcl boolean lit 'fixed';dcl true    lit '1';dcl false   lit '0';dcl buf (256)             fixed;   /* one sector buffer */dcl bufptr                fixed;   /* ptr into BUF */dcl cur.drive             lit '0'; /* hardwire for now */dcl (cur.sector,cur.word) fixed;   /* sec from which BUF came and word at BUF(BUFPTR) */dcl size.of.drive         fixed;   /* number of sectors on current disk */dcl more.on.drive         boolean; /* false after last sector on disk is read *//* prefix names and counters to use in patched file types */dcl snd.name  data ('SND');dcl lcat.name data ('LCAT');dcl cat.name  data ('CAT');dcl text.name data ('TEXT');dcl (snd.cnt,lcat.cnt,cat.cnt,text.cnt) fixed; /* counts of files patched so far *//* literals for offsets into various parts of FCB */dcl nam      lit '0'; dcl ori                lit '4';dcl sec      lit '5'; dcl wds                lit '6';dcl typ      lit '7'; /* file type literals */dcl text.file.type     lit '0';dcl sound.file.type    lit '5';dcl subcat.type        lit '6';dcl large.subcat.type  lit '7';dcl spectral.file.type lit '9';dcl a            lit 'write("360")=read("107")';dcl b            lit 'a;a;a;a;a;a;a;a;a;a;a;a;a;a;a;a';dcl transfer_256 lit 'write("300")=addr(buf(0)); b;b;b;b;b;b;b;b;b;b;b;b;b;b;b;b';nextsec:  proc boolean; /* loads global BUF with next sector */   cur.sector=cur.sector+1;  /* increment current sec number */   if cur.sector ILT size.of.drive then do;      if (cur.sector&"377")=0 then print cur.sector,character("15"),;      call readdata(shl(2,8),cur.sector,buf,256);  /* read the current sector   */      bufptr  =0;            /* reset global ptr          */      cur.word=buf(bufptr);  /* set CUR.WORD to first word of sector */      more.on.drive=true;    /* not end of disk           */   end;   else more.on.drive=false; /* have read last sector on disk */end nextsec;nextword:  proc; /* sets CUR.WORD to next word on disk */   bufptr=bufptr+1;             /* incr buf ptr */   if bufptr>=256 then do;      /* time to read in next sector */      cur.sector=cur.sector+1;  /* increment current sec number */      if cur.sector ILT size.of.drive then do;         call readdata(shl(2,8),cur.sector,buf,256);  /* read the current sector   */         bufptr=0;              /* reset global ptr */         more.on.drive=true;    /* not end of disk */      end;      else more.on.drive=false; /* have read last sector on disk */   end;   cur.word=buf(bufptr);end nextword;check.fcb.name:  proc(fcb) boolean; /* returns true if FCB name is non-zero */   dcl fcb     fixed array;   dcl nonzero boolean;   dcl i       fixed;   nonzero=false;   do i=0 to 3;      if fcb(nam+i)<>0 then nonzero=true;   end;   return nonzero;end check.fcb.name;valid.fcb: proc(fcb) boolean; /* returns true if 8 word array could be an XPL FCB */   dcl fcb      fixed array; /* 8 word block to test */   dcl valid    boolean;   dcl all_zero boolean;   dcl name (4) fixed;   dcl ch       fixed;   dcl (i,j)    fixed;   valid=true; /* assume FCB could be valid */   all_zero = true; /* assume all zero */   do i = 0 to 7;      if fcb(i) <> 0 then all_zero = false;   end;   if not all_zero then do; /* if it isn't all zero, check it out */      do i=0 to 3; name(i+1)=fcb(nam+i); end; name(0)=8; /* make string of filename */      /* bytes in name must be valid letters or zero */      j=false;      do i=0 to 7;         ch=byte(name,i);         if ((ch<="40") and (ch<>0)) or (ch>="177") then valid=false;         if ch=0 then j=true; /* once zero is found, subsequent chrs must be zero */         if j and (ch<>0) then valid=false;      end;      /* starting sector must be on disk and nonzero */      if (cur.sector + fcb(ori) IGE size.of.drive)      or (cur.sector + fcb(ori) ILE cur.sector) or (cur.sector + fcb(ori) ILT fcb(ori)) /* check overflow and zero */      then valid = false;      /* number of sectors must not run off disk and must be nonzero */      if (cur.sector + fcb(ori) + fcb(sec) IGE size.of.drive) or (fcb(sec) IGE size.of.drive) /* make sure it doesn't run off end */      or (cur.sector + fcb(ori) + fcb(sec) ILE cur.sector + fcb(ori)) or (cur.sector + fcb(ori) + fcb(sec) ILE fcb(sec)) /* check overflow and zero */      then valid = false;      /* sector length and word length must agree if there's a name */      if check.fcb.name (fcb) /* if there's a name */      then if (fcb(sec) & 255) <> shr(fcb(wds) + 255, 8) then valid=false;      /* file type must be less than SPECTRAL FILE type */      if fcb(typ) IGT spectral.file.type then valid=false;      if debug then do;         if valid and (byte(name,0)<>0) then do;            print '****** Valid File **********';            print string(name);            print 'Origin is',fcb(ori);            print 'Sectors =',fcb(sec),'  Words=',fcb(wds);            print 'Type is',fcb(typ);            print '****************************       ',;            print 'Press <RETURN> to continue ',; input i;         end;         else if not valid then do;            print 'Trashed FCB: ',;            do i=0 to 7; print fcb(i),; end;            print;         end;      end;   end; /* of not all zero */   return valid;end valid.fcb;clean.cat: proc(catbuf,len) fixed;; /* zeroes out invalid FCBs in a cat buffer */   dcl catbuf  fixed array; /* catalog buffer to use */   dcl len     fixed;       /* length of CATBUF in words */   dcl fcb (8) fixed;       /* an FCB buffer */   dcl (i,j,k) fixed;   k=0;   do i=0 to len-1 by 8; /* loop over FCBs */      if not valid.fcb(location(addr(catbuf(i)))) then do; /* bad FCB */         do j=0 to 7; catbuf(i+j)=0; end; /* zero out bad FCB */         k=k+1;      end;   end;   return k; /* return number of invalid FCBs found */end clean.cat;find.free.fcb:  proc(catbuf,len) fixed; /* returns ptr to a free FCB block */   dcl catbuf fixed array;   dcl len    fixed;   dcl ptr    fixed;   dcl (i,j)  fixed;   ptr=(-1); /* return (-1) if no free FCBs found */   i=0;   do while (i<len) and (ptr=(-1)); /* loop over words in cat buffer */      ptr=i;      do j=0 to 5; if catbuf(i+j)<>0 then ptr=(-1); end;      i=i+8;   end;   return ptr;end find.free.fcb;append.num:  proc(str,num,maxlen); /* puts number on end of string */   dcl str        fixed array;   dcl num        fixed;   dcl maxlen     fixed;   dcl divisors   data (-10000,-1000,-100,-10,-1);   dcl (go,i,chr) fixed;   if num<0 then do;      if str(0) ILT maxlen then do;         call pbyte(str,str(0),"55");         str(0)=str(0)+1;      end;   end;   else num=-num;   go=false;   do i=0 to 4;      chr=num/divisors(i);      if chr<>0 then go=true;      if (go or (i=4)) and (str(0) ILT maxlen) then do;         call pbyte(str,str(0),"60"+chr);         str(0)=str(0)+1;      end;      num=num-(divisors(i)*chr);   end;end append.num;origin.unique:  proc(catbuf,len,start) boolean; /* returns true if origin not in CATBUF */   dcl catbuf    fixed array;   dcl len       fixed;   dcl start     fixed;   dcl unique    boolean;   dcl i         fixed;   unique=true; /* assume entry is not already in cat */   i=0;   do while (i<len) and unique;      if catbuf(i+ori)=start then unique=false;      i=i+8;   end;   return unique;end origin.unique;print.chars:  proc(buf,len); /* prints chars of array not in string format */   dcl buf    fixed array;   dcl len    fixed; /* number of chars to print */   dcl (i,ch) fixed;   do i=0 to len-1; /* loop over chars to print */      if i then ch=shr(buf(shr(i,1)),8);      else      ch=buf(shr(i,1))&"377";      if ch<"40" then ch="40"; /* if char not printable, print a space */      print character(ch),;   end;end print.chars;new.cat.entry:  proc(catbuf,len,start,secs,words,type) boolean; /* patches entry into catalog */   dcl catbuf       fixed array; /* buffer containging catalog info */   dcl len          fixed; /* word length of CATBUF */   dcl start        fixed; /* start sector of file to patch */   dcl (secs,words) fixed; /* length in sectors and words of file */   dcl type         fixed; /* file type code */   dcl name (4)     fixed;   dcl success      boolean;   dcl free         boolean;   dcl ptr          fixed;   dcl (i,j,k)      fixed;   success=true; /* assume catalog patch will be successful */   ptr=(-1); /* initially no free FCB found */   do while (i<len) and (ptr=(-1));      if catbuf(i)=0 then ptr=i; else i=i+8;   end;      if (ptr<>(-1)) and origin.unique(catbuf,len,start) then do; /* entry not already in cat */      print 'Patching new FCB into catalog: ',;      /* set up a name for patched file */      name(0)=0; name(1)=0; name(2)=0; name(3)=0; name(4)=0;      if type=large.subcat.type then do;         lcat.cnt=lcat.cnt+1;         do i=0 to lcat.name(0)-1; call pbyte(name,i,byte(lcat.name,i)); end;         name(0)=lcat.name(0);         call append.num(name,lcat.cnt,8);      end;      else if type=subcat.type then do;         cat.cnt=cat.cnt+1;         do i=0 to cat.name(0)-1; call pbyte(name,i,byte(cat.name,i)); end;         name(0)=cat.name(0);         call append.num(name,cat.cnt,8);      end;      else if type=text.file.type then do;         text.cnt=text.cnt+1;         do i=0 to text.name(0)-1; call pbyte(name,i,byte(text.name,i)); end;         name(0)=text.name(0);         call append.num(name,text.cnt,8);      end;      else if type=sound.file.type then do;         snd.cnt=snd.cnt+1;         do i=0 to snd.name(0)-1; call pbyte(name,i,byte(snd.name,i)); end;         name(0)=snd.name(0);         call append.num(name,snd.cnt,8);      end;      do i=0 to 3; catbuf(ptr+i)=name(i+1); end;      call print.chars(location(addr(catbuf(ptr))),8);      catbuf(ptr+ori)=start;      catbuf(ptr+sec)=secs;      catbuf(ptr+wds)=words;      catbuf(ptr+typ)=type;      do i=ori to typ; print catbuf(ptr+i),; end; print;   end;   else do;      success=false; print '**** Patch Unsuccessful'; /* no free FCBs in cat */   end;   return success;end new.cat.entry;locate.subcats:  proc(catbuf,len); /* patch subcatalogs into CATBUF */   dcl catbuf         fixed array; /* catalog to patch into */   dcl len            fixed;       /* length of CATBUF in words */   dcl have.cat       boolean;   dcl have.large.cat boolean;   dcl nonzero.fcb    boolean;   dcl cat.start      fixed;   dcl cat.length     fixed;   dcl (i,j,k)        fixed;   lcat.cnt=0; cat.cnt=0; /* initialize */   cur.sector   =3;    /* start with first sector past main catalog */   bufptr       =256;  /* force read of disk in NEXTSEC */   more.on.drive=true; /* initialize */   call nextsec; /* get first sector */   do while more.on.drive; /* read through looking for subcats */      have.large.cat=false; have.cat=true;      i=0; nonzero.fcb=false;      do while (i<256) and have.cat; /* loop over 8 word blocks */         if not valid.fcb(location(addr(buf(i)))) then have.cat=false;         else if check.fcb.name(location(addr(buf(i)))) then nonzero.fcb=true;         i=i+8;      end;      if have.cat and nonzero.fcb then do; /* have at least a small cat - check for large cat */         cat.start=cur.sector; /* save start sector of subcatalog */         have.large.cat=true; /* assume have large cat */         do j=0 to 2; /* loop over next three sectors */            call nextsec;            i=0;            do while (i<256) and have.large.cat; /* loop over 8 word blocks */               if not valid.fcb(location(addr(buf(i)))) then have.large.cat=false;               i=i+8;            end;         end;         /* compute size of subcat */         cur.sector=cat.start-1;         j=0; /* assume have small subcat */         if have.large.cat then j=3;         cat.length=j+1; /* initialize */         do i=0 to j; /* loop over sectors in cat */            call nextsec;            do k=0 to 255 by 8;               if (buf(k+ori)+buf(k+sec)) IGT cat.length               then cat.length=buf(k+ori)+buf(k+sec);            end;         end;         if cat.length IGT (j+1) then do; /* have a non-empty cat */            k=subcat.type;            if have.large.cat then k=large.subcat.type;            if not new.cat.entry(catbuf,len,cat.start,cat.length,shl(cat.length,8),k) then return;         end; /* of have a non-empty catalog */         cur.sector=cat.start+cat.length-1; /* jump over any stuff in subcat */      end; /* of have a cat, patch FCB into cat buf */      call nextsec; /* get next sector */   end; /* of read through looking for subcats */   print;end locate.subcats;compare.times:  proc(time1,time2) fixed; /* -1 if time1<time2,0 if equal, +1 if time1>time2 */   dcl (time1,time2) fixed array;   dcl relation      fixed; /* (-1)->(time1<time2), 0->(time1=time2), (+1)->(time1>time2) */   dcl (i,j,k)       fixed;   relation=0; /* assume times are equal */   do i=0 to 2;      if      time1(i) IGT time2(i) then relation=(+1);      else if time1(i) ILT time2(i) then relation=(-1);   end;   return relation;end compare.times;locate.sound.files:  proc(catbuf,len); /* patches sound files back into catalog */   dcl catbuf         fixed array; /* catalog to patch into */   dcl len            fixed; /* length of CATBUF in words */   dcl have.snd       boolean;   dcl snd.start      fixed;   dcl snd.length     fixed;   dcl (i,j,k)        fixed;   snd.cnt=0; /* initialize */   cur.sector   =3;    /* start with first sector past main catalog */   bufptr       =256;  /* force read of disk in NEXTSEC */   more.on.drive=true; /* initialize */   call nextsec; /* get first sector */   do while more.on.drive; /* read through looking for subcats */      have.snd=true;      if (buf( 0) IGT 3)   /* compatability number must be 3 or less */      or (buf( 4) IGT 255)      or (buf( 8) IGT 255)      or (buf(21) ILT 600) or (buf(21) IGT 4095) then have.snd=false;      if (compare.times(location(addr(buf( 9))),location(addr(buf(23))))<0)      or (compare.times(location(addr(buf( 9))),location(addr(buf(26))))<0)      or (compare.times(location(addr(buf( 9))),location(addr(buf(29))))<0)      or (compare.times(location(addr(buf(26))),location(addr(buf(23))))<0)      then have.snd=false;      if buf(127) IGT 128 then have.snd=false;      if have.snd then do i=0 to buf(127)-1;         j=byte(location(addr(buf(127))),i);         if (j IGE "177") or (j ILT "40") then have.snd=false;      end;      if have.snd then do; /* have a sound file */         snd.start =cur.sector;         snd.length=buf(3)+shr(buf(4)+255,8)+3; /* compute length of sound file */         if not new.cat.entry(catbuf,len,snd.start,snd.length,shl(buf(3),8)+buf(4),sound.file.type) then return;      end;      /* don't jump over sound file since there is a good possibility         that lots of old sound files will be sitting around on the         disk.  Patch them all in and then resolve conflicts later */      call nextsec; /* get next sector */   end; /* of read through looking for subcats */   print;end locate.sound.files;locate.text.files:  proc(catbuf,len); /* patches text files back into CATBUF */   dcl catbuf         fixed array; /* catalog to patch into */   dcl len            fixed; /* length of CATBUF in words */   dcl have.text      boolean;   dcl text.start     fixed;   dcl text.length    fixed;   dcl last.sec       fixed;   dcl last           fixed;   dcl desequenced    boolean;   dcl skip           boolean;   dcl (i,j,k)        fixed;   text.cnt=0; /* initialize */   cur.sector   =3;    /* start with first sector past main catalog */   bufptr       =256;  /* force read of disk in NEXTSEC */   more.on.drive=true; /* initialize */   call nextsec; /* get first sector */   do while more.on.drive; /* read through looking for text files */      skip=false; i = 0;      do while ((not skip) and (i < len)); /* step through CATBUF */         if cur.sector=catbuf(i+ori)         then do; skip=true; cur.sector=cur.sector+catbuf(i+sec)-1; end;         i = i + 8;      end;      if (not skip) and ((cur.word & "177400") = 0) then do; /* search for good line number (assumes 1st line # < 256 to avoid file segements) */         have.text = true;         text.start=cur.sector;         last.sec=cur.sector;         last=cur.word-1; /* start line number */                  if cur.word = 0 /* is the first line number zero? */         then desequenced = true; /* yes, assume desequenced */         else desequenced = false;         do while more.on.drive & have.text & ((cur.word IGT last) or (desequenced & (cur.word = 0))); /* while line numbers ascend */            last=cur.word;                       /* remember new line number */            call nextword;                /* skip line number */            do while more.on.drive & ((cur.word & "177400")^=0) & have.text; /* search for end of line */               if ((cur.word & "100200") <> 0) or ((cur.word & "140") = 0) or ((shr(cur.word, 8) & "140") = 0) then have.text = false;               else call nextword; /* get next word */            end;            if ((cur.word & "177400") = 0) and (cur.word <> 0) /* ends with a null byte? */            then if ((cur.word & "200") <> 0) or ((cur.word & "140") = 0) then have.text = false; /* check last byte */            if cur.sector <> last.sec then do; /* just changed sectors - look for overlapping files */               skip=false; i = 0;               do while ((not skip) and (i < len)); /* step through CATBUF */                  if cur.sector=catbuf(i+ori)                  then do; skip=true; cur.sector=cur.sector+catbuf(i+sec)-1; end;                  i = i + 8;               end;               if skip then have.text = false; /* if we overlap with something already there, we only have a scrap of a text file */               last.sec = cur.sector;            end;            text.length=cur.sector-text.start+1;    /* set lengths in case done */            call nextword;                        /* get new line number */         end;         if cur.word <> 0 then have.text = false;         do i = bufptr to 255; /* finish off the sector */            if buf (i) <> 0 then have.text = false;         end;         if have.text & ((text.length igt 1) \ (bufptr igt 8))         then if not new.cat.entry(catbuf,len,text.start,text.length,shl(text.length-1,8)+bufptr,text.file.type) then return;      end;      call nextsec; /* get next sector */   end;end locate.text.files;/* $SUBTITLE  Main Driver for Disk Patch Program */dcl catbuf (255) fixed; /* buffer for main catalog */dcl fcb    (7)    fixed; /* buffer for one fcb */dcl str   (16)    fixed;dcl ch            fixed;dcl (i,j,k)       fixed;call readdata (shl(2,8), 0, catbuf, 256);print 'How many sectors are on your Winchester drive',;input size.of.drive;print; print;print 'Cleaning up Main Catalog';print '   Invalid FCBs zeroed out was: ',clean.cat(catbuf,256);print 'Looking for Subcatalogs';call locate.subcats(catbuf,256);print 'Looking for Text Files';call locate.text.files(catbuf,256);print 'Press <RETURN> to see patched catalog ',; input i; print;print 'Filename  Origin Secs   Words  Type';print '--------  ------ ------ ------ ------';do i=0 to 255 by 8; /* dump patched cat to screen */   call print.chars(location(addr(catbuf(i))),8); /* prints chars of array not in string format */   print ' ',catbuf(i+ori),' ',catbuf(i+sec),;   print ' ',catbuf(i+wds),' ',catbuf(i+typ);end;print;print 'Enter 1 to rewrite patched catalog to Winchester, 0 to quit',; input i;if i=1 /* write patched catalog to Winchester */then call writedata(shl(2,8),0,catbuf,256);