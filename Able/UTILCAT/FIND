/* $Title  F I N D  --  Search For A Pattern In One Or More Files *//* This program locates a string pattern in one or more files. .  It also handles the user interface by issuing prompts and.  interpreting them. */configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */Insert ':-xpl:literals'; /* general literals */Insert ':-xpl:asciilit'; /* ASCII literal definitions */Insert ':-xpl:termutil'; /* Terminal utilities */insert ':-xpl:catrtns'; /* catalog routines */Insert ':-xpl:fileio'; /* Buffer file I/O */insert ':-xpl:catutil'; /* catalog utilities */Insert ':-xpl:strings'; /* String processing */insert ':-xpl:scanargs'; /* scan command line arguments */Insert ':utilcat:searchit'; /* Searching and matching routines */Insert ':utilcat:getfiles'; /* Insert the get filename routines */Dcl Ticks       Fixed; /* clock ticks */Dcl ElapsedTime Fixed; /* Time elapsed in seconds */When D03INT Then Do;          /* Time the matching process */   Ticks = Ticks + 1;   If Ticks = D03_Speed*100 Then Do;    /* Time in seconds */      ElapsedTime = ElapsedTime + 1;      Ticks = 0;   End;End;/* $SubTitle   GetOpt *//* This procedure gets a list of options and interprets them. */Dcl Exclusive  Boolean;  /*  x: all lines but those matching are printed */Dcl Status     Boolean;  /*  s: status information is printed */Dcl NoCase     Boolean;  /* ~c: distinction made between cases when matching */Dcl Line#      Boolean;  /*  l: lines  are preceeded by the line number */Dcl No_Header  Boolean;  /*  n: filenames will not be printed */Dcl Count      Boolean;  /*  #: only the count of matching lines is printed */Dcl List       Boolean;  /* ~f: list lines with matches (rather than just their filenames) */Dcl Tree       Boolean;  /*  t: climb tree */Exclusive = False;Status = False;NoCase = True;Line#  = False;No_Header = False;Count = False;List = True;Tree = False;GetOpt:  Procedure (Options);   Dcl Options    Fixed Array; /* A list of matching options */   /* This procedure provides documentation for the user if he so desires. */   Helpful:  Procedure;      CRLF;      PStringr ('The following search options may be specified: ');      PStringr ('   c :  Distinguish between uppercase and lowercase.');      PStringr ('   x :  List files/lines without a match.');      PStringr ('   t :  Search files in subcatalogs also.');      CRLF;      PStringr ('The following display options may be specified:');      PStringr ('   f :  List filenames and lines.');      PStringr ('   l :  List filenames, lines, and line numbers.');      PStringr ('   n :  Exclude filenames from F or L.');      PStringr ('   # :  List filenames with the number of matches.');      PStringr ('   s :  Include search status information.');      CRLF;   End Helpful;   Dcl OptPtr  Fixed;       /* A pointer to the list of options */   Dcl OptChar Fixed;       /* a character in the list of options */   Dcl Done    Fixed;       /* TRUE when we have a set of options */   Dcl I       Fixed;   Dcl Valid_Options Data ('?cxln#fts ');   Done = False; /* haven't even started yet */   Do While (not Done); /* get options */      Done = True; /* assume we'll finish this time */      Get_String ('Options (type ? for help)? ', 0, Options, 11);   /* Prompt the user until a valid response */      CRLF;      Call Lower (Options);      /* Lower case the list of options to insure consistency */      /* $Page */      OptPtr = 0;      Do While (OptPtr < Options (0)); /* scan off options */         OptChar = Byte (Options, Optptr);  /* Get an option */         I = 0;                            /* Check to see that it is valid */         Do While ((I < Valid_Options (0)) and (OptChar <> Byte(Valid_Options, I)));            I = I + 1;         End;         If I >= Valid_Options(0) Then Do;  /* did we find an option? */            WChar (OptChar); PStringr (' is an invalid option.' );            Done = False;         End;         Else Do Case (I);            Do;                           /* 0: ? - Give them help */               Call Helpful;               Done = False;            End;            NoCase = False;               /* 1: c - lower case doesn't match upper */            Exclusive = True;             /* 2: x - Exclusive option */            Do;                           /* 3: l - line number preceeds each line */               List = False; /* must set F option also */               If Not Count               Then Line# = True;               Else Do;                  PStringr ('Cannot mix the option ''l'' with ''#''.');                  Done = False;               End;            End;            Do;                          /* 4: n - do not print filename headers */               If Not Count               Then No_Header = True;               Else Do;                  PStringr ('Cannot mix the option ''n'' with ''#''.');                  Done = False;               End;            End;            Do;                           /* 5: # - count of matching lines */               If (Not Line#) and (Not No_Header) Then Do;                  List = False; /* must set F option also */                  Count = True;               End;               Else Do;                  PStringr ('Cannot mix the option ''#'' with ''l'' or ''n''.');                  Done = False;               End;            End;            List = False;                 /* 6: f - list lines that match */            Tree = True;                  /* 7: t - subcatalogs also */            Status = True;                /* 8: s - no output, just status */            ;                             /* 9: Space - ignore it */         End;         /* Of case */         OptPtr = OptPtr + 1 ;      End;               /* Of While Option pointer is less than the number of characters in the list of options. */   End; /* of get options */End GetOpt;      /* $subtitle Fast String Search *//* This procedure does a VERY fast search for a pattern in a string..  It assumes both the pattern and string are chiefly alphabetic.  and that characters are not generally repeated in either.  It.  still works if these conditions aren't met; it just isn't as.  fast.  It is based on Boyer and Moore's mismatched character.  algorithm.  If CASE is TRUE, it is assumed the pattern has been.  uppercased by the same algorithm used here...  By:  Karim J. Chichakly on 25 April 1986 */dcl skip (255)  fixed; /* source skip amounts */create_skip: proc(pattern, pat_word); /* set up SKIP array for pattern */   dcl pattern  fixed array; /* pattern to search for */   dcl pat_word fixed array; /* word aligned/upcased pattern */   dcl i        fixed; /* byte counter for PATTERN */   do i = 0 to 255; /* initialize SKIP */      skip (i) = pattern (0); /* we can skip the whole pattern length in most cases */   end;   do i = 0 to pattern (0) - 1; /* now add pattern characters */      pat_word (i) = (byte(pattern, i) and "137"); /* uppercase next character from string */      skip (pat_word (i)) = pattern (0) - i - 1; /* we can skip this much if this character fails */   end; /* of adding pattern characters */end create_skip;speed_search: proc(string, pattern, plen) returns (fixed); /* find PATTERN in STRING */   dcl string  fixed array; /* string to search */   dcl pattern fixed array; /* pattern to search for (word aligned) */   dcl plen    fixed; /* length of pattern */   dcl c       fixed; /* current string character */   dcl (i, j)  fixed; /* byte counters for STRING and PATTERN, respectively */   if string (0) ilt plen /* any chance? */   then return (0); /* no */   j = plen - 1; /* start searching from right side of pattern */   i = j;   c = string (0) + pattern (0); /* point to all vars */   do while ((j >= 0) and (i ilt string (0))); /* scan the entire string */      c = (byte(string, i) and "137"); /* uppercase next character from string */      if c = pattern (j) then do; /* do the characters match? */         i = i - 1; /* proceed from right to left */         j = j - 1;      end;      else do; /* no match - skip ahead */         if skip (c) > plen - j /* see how far we can skip */         then c = skip (c); /* as far as the pattern allows */         else c = plen - j; /* only as far as what we've already checked */         i = i + c; /* skip ahead */         j = plen - 1; /* start searching again */      end;   end; /* of scanning string */   if i ilt string (0) /* if we found it */   then return (1); /* return pointer */   else return (0); /* not there */end speed_search;/* $subtitle Speedy Find Code */dcl static lit ''; /* documentation */dcl (cat_ms, cat_ls) fixed; /* address of last catalog that had a match */cat_ms = -1; cat_ls = -1; /* force display of first name */display: proc(treename, name); /* display indented name */   dcl treename  fixed array; /* treename to display */   dcl name      fixed array; /* name to display (last portion of treename) */   dcl indent    fixed static; /* indent levels */   dcl num_files fixed static; /* number of files output on THIS line */   dcl i         fixed;   dcl name_field lit '(shl(f#name_len, 1) + 2)'; /* number of characters in name field */   if not (((c#ms_sector = cat_ms) and (c#ls_sector = cat_ls))) then do; /* if new catalog */      cat_ms = c#ms_sector; cat_ls = c#ls_sector; /* store which catalog matched */      crlf;      indent = 0; num_files = 0; /* assume no indentation */      if treename (0) <> 0 then do; /* no header at top level */         crlf;         do i = 0 to treename (0) - 1; /* find colons in path */            if byte(treename, i) = a.colon then indent = indent + 1;         end;         do i = 1 to indent; /* indent an appropriate amount */            pstring ('   ');         end;         pstring (treename); /* output treename */      end; /* of no header */   end; /* of new catalog */   if num_files = 0 then do; /* need to start a new line */      crlf;      if treename (0) <> 0 /* if not at top level */      then do i = 0 to indent; /* indent the correct amount */         pstring ('   ');      end;   end; /* of new line */   pstring (name);   do i = name (0) + 1 to name_field; /* pad with spaces */      wchar (a.sp);   end;   num_files = num_files + 1; /* one more */   if indent*3 + (num_files + 1)*name_field >= 80 then num_files = 0; /* start again next time */end display;Dcl StringMax Lit '79';Dcl Pattern (StringMax)         Fixed; /* Pattern of string characters for which to search */dcl searchfile proc(fixed array); /* SLOW search */dcl bufptr  fixed; /* pointer to buffer */dcl bufmax  fixed; /* size of buffer */dcl plen    fixed; /* length of pattern */dcl matches fixed; /* number of files that had a match */speedy: proc(fname); /* speedy find */   dcl fname fixed array;   call locate (fname, 1); /* find the file */   if ((f#type = t#text) and (f#ms_length = 0) and (f#ls_length < 256)   and (byte(f#name, 0) <> a.period)) then do; /* okay text file (ignore system files) */      if not term_idle then do; /* if any terminal activity */         if rchar = 0 then do; flush_term; call exit (0); end; /* get out */         else do; pstring ('*** Searching '); pstringr (fname); end;      end;      if f#words ilt bufmax then do; /* enough memory */         call readdata (f#ms_sector, f#ls_sector, loc(bufptr + 1), f#words); /* read it in! */         core(bufptr) = shl(f#words, 1); /* set string length */         if (speed_search (loc(bufptr), pattern, plen) xor exclusive) <> 0 then do; /* if a match */            call display (treename, f#name);            matches = matches + 1; /* found one more */         end;      end; /* of enough memory */      else call searchfile (fname); /* not enough memory */   end; /* of okay text file */end speedy;/* $SubTitle  Main Code of Find */Dcl LineMax   Lit '132';Dcl FName (TreeMax / 2)         Fixed; /* File name of file to be searched */Dcl Line ((LineMax + 1) / 2)    Fixed; /* A line from a file */Dcl Options ((StringMax + 1)/2) Fixed; /* The line of input options by which to match */Dcl Files ((StringMax + 1)/2)   Fixed; /* List of files to search */Dcl Found          Fixed; /* A mark indicating that a match was found */Dcl Speed          Boolean; /* TRUE if speedy search can be used */Dcl Number         Fixed; /* The line number */Dcl File_Count     Fixed; /* The number of files searched */Dcl Line_Count     Fixed; /* The number of lines in a file searched for a match */Dcl MS_Total_Words Fixed; /* The total number of words searched */Dcl LS_Total_Words Fixed;Dcl MS_Total_Secs  Fixed; /* The total number of sectors searched */Dcl LS_Total_Secs  Fixed;Dcl Total_Lines    Fixed; /* The total number of lines searched */Dcl Total_Matches  Fixed; /* The total number of matches found */Dcl Total_Seconds  Fixed; /* The total number of seconds elapsed while searching */Dcl FCount         Fixed; /* Number of filenames on current output line */Dcl Timex          Fixed; /* Elapsed time in finding pattern matches */Dcl FNChar         Fixed; /* A character in the filename */Dcl Output_Device  Fixed; /* User specified output device */Dcl F              File;  /* File we currently have open */Dcl I              Fixed;SearchFile: proc(FName); /* search the given file */   dcl FName fixed array; /* file name to open */   Dcl Temp ((LineMax + 1) / 2) Fixed; /* A line from a file */   F = FOpen (FName, 'r');         /* Open the file */   If ((F <> NullF) and (F#Type = T#Text)) Then Do;   /* Make sure it's a text file */      if Status then do;         File_Count =  File_Count + 1;                /* Sum up all of the files */         LS_Total_Words = LS_Total_Words + F#Words;   /* Add all of the words */         If LS_Total_Words ILT F#Words Then MS_Total_Words = MS_Total_Words + 1;         MS_Total_Secs = MS_Total_Secs + F#MS_Length; /* Add up all of the sectors searched */         LS_Total_Secs = LS_Total_Secs + F#LS_Length;         if LS_Total_Secs ILT F#LS_Length Then MS_Total_Secs = MS_Total_Secs + 1;      end;      Matches = 0;      /* Initialize the count of matching lines */      Line_Count = 0;        /* Initialize the count of lines searched for a match */      Number = FGetS (Line, LineMax, F);  /* Get the first line number of the first line from the file */      Do While (Number <> EOF_Mark);      /* Pattern match until end of file */         If Not Term_Idle Then Do;        /* Check for input */            If RChar = 0                  /* Break? */            Then Call Exit (0);           /* Yes, get out */            Else Do; /* No, let them know where we are */               Pstring('*** Searching '); Pstring(FName); Pstring(' (line '); Unum(Number, 0); Pstringr(')');            End;         End;         call strcpy (temp, line);         If NoCase Then Call Lower (Temp);      /* If no distinction between lower and upper case */         Found = Search (Temp, Pattern); /* Look for a match */         If ((Found <> -1) and (Not Exclusive)) or ((Found = -1) and (Exclusive)) Then Do;            If (Not Count) and (Not List) Then Do; /* don't print the lines out if we're just counting */               If Not No_Header Then Do; /* Do not print the name unless specified */                  PString (FName);                  PString (': '); /* Print the file name */               End;               If Line# Then Do;                  UNum(Number, 0);           /* If line number option */                  PString (': ');            /* Print the line number */               End;               PStringr (Line);            End; /* of printing out matched lines */            Matches = Matches + 1;   /* Count number of matches */         End;   /* of matching */         Line_Count = Line_Count + 1;      /* Count the number of lines searched */         Number = FGetS (Line, LineMax, F); /* Get the next line number of the next line of the file */         If (List and (Matches <> 0)) Then Number = EOF_Mark; /* Exit if and when we find a match if only listing names */      End;      If (List) and (Matches <> 0) /* Print list of filenames */      then call display (treename, f#name);      If Count Then Do; /* Print number of matches found */         PString(FName); PString (':  '); UNum (Matches, 0); CRLF;      End;      If Status Then Do;         Total_Lines = Total_Lines + Line_Count;      /* Add all of the lines */         Total_Matches = Total_Matches + Matches; /* add all of the matches up */      End;   End; /* of finding match in text file */   Else If F = NullF Then Do; /* not there */      PString (Fname);      PStringr (' does not exist.');   End;   Else If Not Wildcard Then Do; /* not a text file */      PString (FName);      PStringr (' is not a text file.');   End;   Call FClose (F); /* Close it now */end SearchFile;Screen_Size (24, 79); /* don't print in 80th column */Output_Device = Directed_Output; /* save specified output device */Redirection_Word = 0; /* redirect back to the terminal */Files (0) = 0; /* no explicit files to search yet */call setup_args (pattern); /* don't care about program name or if it's a RUN */call strtok (pattern, ''); /* get entire argument list into PATTERN */if pattern (0) <> 0 then do; /* if we grabbed a pattern from the command line */   i = index (pattern, ' -f', 0); /* look for a file list */   if i = -1 then i = index (pattern, ' -F', 0); /* uppercase is also allowed */   if i <> -1 then do; /* file list given */      call strncpy (files, pattern, i + 3, pattern (0) - 1); /* pull off filenames */      pattern (0) = i; /* set actual length of string to compare */   end; /* of file list given */   if pattern (0) <> 0 /* if pattern given */   then call strncpy (pattern, pattern, 1, pattern (0) - 1); /* get rid of initial space */end; /* of grabbing a pattern from the command line */if pattern (0) = 0 then do; /* if we don't have a pattern yet */   PString ('Find String Utility - '); pstringr (Rel.Date); CRLF;   Get_String ('Pattern to search for [RETURN for help] ->', 0, Pattern, StringMax);  /* Get pattern to be matched */   CRLF;end; /* of don't have a pattern yet */if Pattern (0) = 0 then do; /* still no pattern - user wants to enter options */   If Get_YN ('Do you need instructions? ') Then Do; /* Give instructions if necessary */      CRLF;      CRLF;      PStringr ('This program searches selected files and lists those in which a');      PStringr ('given pattern is found.  A pattern may include the following');      PStringr ('wildcards:');      CRLF;      PStringr ( '     * :  any string of zero or more characters');      PStringr ( '     ? :  any single character');      PStringr ( '     / :  indicates that the following *, ?, or / is not a wildcard');      CRLF;      PStringr ('Filenames specified for the search may also include wildcards.');   End; /* of instructions */   CRLF;   Get_String ('Pattern to search for? ', 0, Pattern, StringMax);  /* Get pattern to be matched */   CRLF;   Call GetOpt (Options);                /* Parse the options from the input line */   if files (0) = 0 then do; /* if files not given yet */      Get_String ('Files (separate by spaces)? ', 0, Files, StringMax);      CRLF;   end;end;else if files (0) = 0 then do; /* no options set and no files given */   Files (0) = 1;   Files (1) = a.star; /* all files */   Tree = true; /* set T option */end;Speed = ((not Prescan (Pattern)) and NoCase and List); /* see if can use speed search */Redirection_Word = Output_Device; /* use the user specified output device */File_Count = 0;                     /* Initialize file count */Write (3) = 0; Write (3) = 0; /* Synchronize with the real time clock */Ticks = 0;                    /* Initialize tick count */ElapsedTime = 0;              /* Initialize time in seconds *//* $Page */if speed then do; /* if speedy search */   bufptr = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* point to heap */   call set_catbuf (bufptr, 0); /* set catalog buffer */   bufptr = bufptr + c#dir_max; /* point past catalog buffer */   bufmax = loc.load - bufptr - 1; /* size of buffer (minus one so can save length) */   if bufmax ige 32768 then bufmax = 32767; /* limit buffer size */   call strcpy (loc(bufptr), pattern); /* copy pattern over */   plen = core(bufptr); /* save pattern length */   clear_screen;   pstring ('Searching for "'); pstring (loc(bufptr));   pstring ('" on '); call name (1);   call create_skip (loc(bufptr), pattern); /* create skip list */   matches = 0; /* no matches yet */end;else do;   If NoCase Then Call Lower(Pattern); /* Lower case the input pattern */end;Call Start_Search (Files, Tree, 1);      /* Search for the specified files in the current catalog */Do While (GetFName (FName)); /* Loop over all files */   if peek = 0 then do; flush_term; call exit (0); end; /* get out */   If Speed                  /* If speed searching */   Then Call Speedy (FName);     /* FAST search */   Else Call SearchFile (FName); /* SLOW search */End; /* of looping over filenames */Total_Seconds = ElapsedTime;     /* Stop the clock */if speed then do; /* speed searching */   crlf; crlf;   if matches = 0 /* if no files matched */   then pstring ('No');   else unum (matches, 0);   pstring (' file');   if matches <> 1 then wchar (l.s); /* plural please */   pstringr (' found with match.');end;else do;   If Count Then Do;      PString ('TOTAL: ');      UNum (Total_Matches, 0); CRLF; /* output the total */   End;   If Status Then Do;      CRLF;      PString ('Text files searched:'); UNum (File_Count, 10);        PString ('       Lines searched:  '); UNum (Total_Lines, 10); CRLF;      PString ('Words searched:     '); LNum (MS_Total_Words, LS_Total_Words, 10);        PString ('       Sectors searched:'); LNum (MS_Total_Secs, LS_Total_Secs, 10); CRLF;      PString ('Matches performed:  '); UNum (Match_Count, 10);        PString ('       Matches found:   '); UNum (Total_Matches, 10); CRLF;      PString ('Elapsed time (secs):'); UNum (Total_Seconds, 10); CRLF;   End;end;flush_term; /* flush the terminal's buffer before stopping */