/* FORMAT  $TITLE  Main Format Setup and Check */module format_device;configuration modelC, MULDIV;insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:syslits'; /* system literals */insert ':-xpl:termutil'; /* terminal utilities */insert ':-xpl:scsi'; /* SCSI device drivers */insert ':-xpl:scsicmds'; /* SCSI device drivers */insert ':-xpl:devutil'; /* device utilities */insert ':-xpl:catutil'; /* catalog utilities */insert ':-xpl:strings'; /* string processing */insert ':utilcat:diskform'; /* floppy formatting */insert ':utilcat:winform'; 	/* winchester formatting */insert ':utilcat:tapeform'; /* cartridge tape formatting */insert ':utilcat:optform'; 	/* optical media formatting *//* Winchester formatting definitions (in WIN_STATUS): */dcl w_format lit '1'; /* format this Winchester if set */dcl p_format lit '2'; /* do a PRIMARY format if set */dcl primary_format lit '(w_format or p_format)';dcl win.was.formatted fixed public; /* true if (0,5,0) or (0,0) W0: disk was formatted */dcl first_imi   lit '2'; /* index of first IMI-type winchester entry */dcl type_to_IMI data (7, 0, 5, 7, 8, 1, 2, 4); /* maps winchester type into WIN_SIZ and WIN_CYL indexes */winchester_type: proc(win, p) fixed; /* determine the type of Winchester configured */   dcl win   fixed array; /* storage table for all Winchesters in system */   dcl p     fixed; /* pointer to storage table entry for said Winchester */   dcl found boolean; /* TRUE if IMI type found */   dcl i     fixed;   if (shr(win (p + s#devtyp), 8) and "17") = 1 then do; /* SCSI drive */      return (1); /* SCSI drive type */   end;   else do;      i = first_imi; found = false; /* not found yet */      do while ((i <= type_to_IMI (0)) and (not found)); /* search for IMI type */         if  (win (p + s#totcyl) = win_siz (type_to_IMI (i))) /* same total cylinders */         and (win (p + s#seccyl) = win_cyl (type_to_IMI (i))) /* same sectors/cylinder */         then found = true; /* found this IMI type */         else i = i + 1; /* not found, so check next type */      end;      if not found then i = 0; /* unknown Winchester */      return (i); /* return type */   end;end winchester_type;print_winchester: proc(win, p); /* print Winchester type to menu */   dcl win  fixed array; /* storage table for all Winchesters in system */   dcl p    fixed; /* pointer to storage table entry for said Winchester */   dcl i    fixed; /* type */   dcl size fixed; /* size of SCSI winchester */   i = winchester_type (win, p); /* find type of winchester */   do case (i); /* print various winchester types */      pstring ('Unknown  ');      do; /* SCSI */         write("5") = win (p + s#totcyl); /* calculate the number of sectors on this drive: */         write("6") = win (p + s#seccyl); /* sectors = cylinders * sectors/cylinder */         size = read("5"); /* D4567 bug */         write("7") = 2048; /* multiply by 512 (bytes/sector) and divide by 1024*1024 (bytes/Mbyte) */         size = read(5) + (read(4) ige 1024); /* size of disk in Mbytes (rounded up) */         size = ((size + 4)/5)*5; /* round up to next multiple of five (+ 2 for nearest) */         pstring ('5", '); unum (size, 0); pstring (' MB SCSI');      end;      pstring ('5", 5 MB '); /* IMI 5007    */      pstring ('5", 10 MB'); /* IMI 5012H   */      pstring ('5", 15 MB'); /* IMI 5018H   */      pstring ('8", 10 MB'); /* IMI 7710    */      pstring ('8", 20 MB'); /* IMI 7720    */      pstring ('8", 40 MB'); /* IMI 7740    */   end;end print_winchester;print_scsi_name: proc (DevAdr) recursive;   dcl DevAdr     fixed;	dcl inqbuf(32) fixed;	dcl it(1)		fixed;	dcl i      		fixed;		if (Inquiry(DevAdr, 32, inqbuf) != S$Good)		return;	if (inqbuf(0) > 8)					/* print out name */	{		do i = 8 to inqbuf(0)-1;			it(0) = 1;			it(1) = byte(inqbuf, i);						if (it(1) < 32 || it(1) >= 127)				it(1) = 32;							pstring(it);		end;	}end print_scsi_name;		/* $subtitle Storage Device Table Handling */st_find_nonwinch: proc(config, len) fixed; /* find a non-Winchester entry in CONFIG */   dcl config fixed array; /* storage table we're searching */   dcl len    fixed; /* length of storage table */   dcl found  boolean; /* TRUE when we find it */   dcl p      fixed; /* pointer into storage table */   p = 0; found = false; /* start at the very beginning */   do while ((p < len) and (config (p) <> s#freblk) and (not found)); /* search the table till we find one */      if (config (p + s#devtyp) and "17") <> 1 /* if it isn't a Winchester */      then found = true; /* we found it */      else p = p + s#blklen; /* keep looking */   end; /* of searching table */   if found /* did we find it? */   then return (p); /* yes, return the pointer */   else return (-1); /* no, return invalid pointer */end st_find_nonwinch;st_find: proc(block, config, len) fixed; /* find a matching storage BLOCK in CONFIG (currently only works for Winchesters) */   dcl block  fixed array; /* storage block we're looking for */   dcl config fixed array; /* storage table we're searching */   dcl len    fixed; /* length of storage table */   dcl found  boolean; /* TRUE when we find it */   dcl p      fixed; /* pointer into storage table */   p = 0; found = false; /* start at the very beginning */   do while ((p < len) and (config (p) <> s#freblk) and (not found)); /* search the table till we find it */      if ((config (p + s#devadr) = block (s#devadr)) /* check device addresses */      and (winchester_type (config, p) = winchester_type (block, 0))) /* make sure everything else matches */      then found = true; /* we found it */      else p = p + s#blklen; /* keep looking */   end; /* of searching table */   if found /* did we find it? */   then return (p); /* yes, return the pointer */   else return (-1); /* no, return invalid pointer */end st_find;st_insert: proc(block, p, config, len) boolean; /* insert BLOCK at location P of CONFIG */   dcl block  fixed array; /* storage block we're inserting */   dcl p      fixed; /* pointer to where to insert in storage table */   dcl config fixed array; /* storage table we're inserting into */   dcl len    fixed; /* length of storage table */   if config (len - s#blklen) = s#freblk then do; /* if there's a free entry */      call blockmove (loc(addr(config (p))), loc(addr(config (p + s#blklen))), len - p - s#blklen); /* push data above us up */      call blockmove (block, loc(addr(config (p))), s#blklen); /* and copy the block into its place */      return (true); /* we successfully inserted it */   end;   return (false); /* no room to insert it */end st_insert;st_delete: proc(p, config, len); /* delete the block pointed to by P in CONFIG */   dcl p      fixed; /* pointer to block to delete */   dcl config fixed array; /* storage table we're deleting from */   dcl len    fixed; /* length of storage table */   call blockmove (loc(addr(config (p + s#blklen))), loc(addr(config (p))), len - p - s#blklen); /* delete the block */   call blockset (loc(addr(config (len - s#blklen))), s#blklen, s#freblk); /* put free block at end */end st_delete;/* $subtitle User Interface:  Print List Of Available Winchesters On Screen */print_winchesters: proc(level, win_config, win_status, xref) fixed; /* print out list of Winchesters on LEVEL */   dcl level      fixed; /* level to print winchesters from */   dcl win_config fixed array; /* winchester configuration of system */   dcl win_status fixed array; /* winchester disk status (format or don't) */   dcl xref       fixed array; /* cross-reference of screen to WIN_CONFIG */   dcl type       fixed; /* device type */   dcl (i, j)     fixed;   dcl (m, n, p)  fixed;   m = 0; n = 0; /* no winchesters printed or selectable yet */   if win_config (0) = s#freblk /* no Winchesters in system? */   then pstringr ('*** No Winchester disk drives are attached to your system.');   else do; /* some winchesters in system */      i = st_find_nonwinch (win_config, c#strlen); /* look for a non-Winchester */      do while (i <> -1); /* delete any non-Winchesters from the configuration */         call st_delete (i, win_config, c#strlen); /* delete this one */         i = st_find_nonwinch (win_config, c#strlen); /* and look for another */      end;      if level = 6 /* if formatting W0 */      then p = find_device (7); /* find W1's config */      else p = find_device (6); /* otherwise we're formatting W1, so get W0's config */      if p <> 0 then do; /* if the other logical disk is configured, delete its drives from the format list */         type = (core(p) and "377"); j = 0; /* get desired type */         do while ((core(p + j*s#blklen) and "377") = type); /* print out all drives */            i = st_find (location(p + j*s#blklen), win_config, c#strlen); /* see if this Winchester's connected */            if i <> -1 then call st_delete (i, win_config, c#strlen); /* it is, delete it */            j = j + 1; /* look at next configured drive */         end; /* delete all drives on other logical disk */      end; /* of other disk is configured */      if win_config (0) = s#freblk /* no Winchesters after deleting other drive? */      then do; pstring ('*** No Winchester disk drives are attached to '); call name (level); pstringr ('.'); end;      else do; /* some Winchesters to select */         p = find_device (level); /* see if this device is even configured */         if p <> 0 then do; /* this device is configured */            type = (core(p) and "377"); j = 0; /* get desired type */            do while ((core(p + j*s#blklen) and "377") = type); /* print out all drives */               i = st_find (location(p + j*s#blklen), win_config, c#strlen); /* see if this Winchester's connected */               j = j + 1; /* look at next configured drive */               pstring ('    '); /* indent */               if i <> -1 /* if the drive's connected */               then pstring ('> '); /* mark as selected */               else pstring ('  '); /* or deselected as appropriate */               if level = 6 /* W0? */               then pstring ('W0'); /* yes */               else pstring ('W1'); /* no, must be W1 */               pstring (' ('); unum (j, 0); pstring ('):  ');               if i <> -1 then do; /* did we find the drive in the system? */                  call print_winchester (win_config, i); /* print the winchester name */                  pstring ('   ');						print_scsi_name(win_config(i + s#devadr));                  xref (10 + m) = i; /* remember which winchester this is */                  win_status (i/s#blklen) = true; /* we printed it - select it for formatting */                  n = n + 1; /* we've found another selectable drive */               end;               else pstring ('not connected');               crlf;               m = m + 1; /* we've printed another Winchester */            end; /* of print out all drives */         end; /* of this device is configured */         i = 0; /* compute total Winchesters in system */         do while ((i < c#strlen) and (win_config (i) <> s#freblk));            i = i + s#blklen; /* look at next block */         end;         if i/s#blklen - n > 0 then do; /* if any unprinted winchesters left */            crlf; /* skip a line to be neat */            i = 0;            do while (win_config (i) <> s#freblk); /* search list */               if not win_status (i/s#blklen) then do; /* not printed yet */                  pstring ('      NConf:   ');                  call print_winchester (win_config, i); /* print the winchester name */                  pstring ('    ');                  if (shr(win_config (i), 8) and "3") = 1 then do; /* if SCSI Winchester */                     unum (shr(win_config (i + s#devadr), 4) and "17", 0); pstring (','); /* output D24 number */                  end;                  unum (win_config (i + s#devadr) and "17", 0); /* print controller and drive */                  pstring (','); unum (shr(win_config (i + s#devadr), 8) and "17", 0);                  crlf;                  xref (11 + m) = i; /* remember which winchester this is */                  n = n + 1; /* we've found another selectable drive */                  m = m + 1; /* we've printed another Winchester */               end;               i = i + s#blklen; /* point to next block */            end; /* of searching list */         end; /* of extra winchesters in system */      end; /* of winchester disks on LEVEL in system */   end; /* of winchester disks in system */   return (n); /* return number of selectable disks in system */end print_winchesters;/* $subtitle User Interface:  Select Winchesters To Format */select_winchesters: proc(xref, win_config, win_status) boolean; /* select Winchesters to format */   dcl xref       fixed array; /* cross-reference of screen to WIN_CONFIG and WIN_STATUS (times S#BLKLEN) */   dcl win_config fixed array; /* winchester configuration of system */   dcl win_status fixed array; /* winchester disk status (format or don't) */   dcl ibuf (2)   fixed; /* input buffer */   dcl cur.y      fixed; /* current Y position on screen */   dcl (i, j, k)  fixed;   clear_typeahead; i = pf.1; /* clear any typeahead/force a HOME */   do while ((i <> a.cr) and (i <> a.q) and (i <> l.q) and (i <> a.nul)); /* wait for a RETURN or Q for quit */      if i = a.sp then do; /* space - toggle selection */         j = xref (cur.y); /* point to table entry */         if win_status (j/s#blklen) then do; /* format? */            if ((win_status (j/s#blklen) = primary_format) /* primary format? */            or ((shr(win_config (j), 8) and "3") = 1)) then do; /* don't allow primary format of SCSIs */               win_status (j/s#blklen) = 0; /* we're NOT formatting it anymore */               wchar(a.bs); pstring ('  '); /* mark it as such */            end;            else do; /* move on to primary format */               win_status (j/s#blklen) = primary_format; /* do a primary format */               wchar(a.bs); pstring ('P'); /* mark it as such */            end;         end;         else do; /* not set at all */            win_status (j/s#blklen) = true; /* do a normal format */            pstring ('>'); /* mark that we're formatting it */         end;      end; /* of toggle selection */      else if ((i = cur.up) or (i = a.vt)) then do; /* cursor up */         j = cur.y - 1;         do while (j >= 0); /* look for next selectable disk above this one */            if xref (j) <> -1 then do; /* if we found one */               cur.y = j; /* find new line */               j = -1; /* get out */            end;            else j = j - 1; /* look at next line up */         end;      end; /* of cursor up */      else if ((i = cur.down) or (i = a.lf)) then do; /* cursor down */         j = cur.y + 1;         do while (j < 24); /* look for next selectable disk below this one */            if xref (j) <> -1 then do; /* if we found one */               cur.y = j; /* find new line */               j = 24; /* get out */            end;            else j = j + 1; /* look at next line down */         end;      end; /* of cursor down */      else if ((i = cur.home) or (i = c.r) or (i = c.y) or (i = a.rs) or (i = pf.1)) then do; /* home */         cur.y = 0;         do while (xref (cur.y) = -1); /* find first selectable disk */            cur.y = cur.y + 1;         end;      end;      pos (cur.y, 4); i = rchar; /* move to the proper position and get next character */      if i = a.cr then do; /* if they want to proceed, double-check */         j = 0; k = false;         do while (j < c#strlen/s#blklen); /* see if any Winchesters to format */            if win_status (j) then k = true;            j = j + 1;         end;         if k then do; /* if there ARE Winchesters to format */            pcmd ('*** Warning:  ALL files saved on the selected Winchesters will be destroyed.'); crlf;            get_string ('Please verify selection, then type ''OK'' followed by RETURN ->', false, ibuf, 2);            if not compare (ibuf, 'OK') then do; /* if not OK */               i = -1; /* make sure we don't do anything */               erase_command; crlf; erase_line; /* be neat */            end;         end; /* of Winchesters to format */         else i = a.q; /* no Winchesters to format - get out */      end; /* of double-check */   end; /* of wait for return or Q */   if i <> a.cr then do; /* if they don't want to proceed, get out */      pos (cmdline - 2, 0); erase_line;      pstring ('*** No Winchester disks were formatted.');      return (false);   end;   else return (true); /* go ahead and format the Winchesters */end select_winchesters;/* $subtitle Format The Media On A Given Device */format: proc(level, buf) fixed public;   dcl level     	fixed; /* pass disk level in */   dcl buf       	fixed array; /* pass a track buffer in */   dcl xref (23) 	fixed; /* cross reference of screen lines to winchester table */   dcl f.err     	fixed; /* signals error status */   dcl sta       	fixed; /* status */   dcl ibuf (2)  	fixed; /* input buffer */   dcl (i, j)    	fixed;   dcl win_config (c#strlen - 1)          fixed; /* winchester configuration */   dcl win_status (c#strlen/s#blklen - 1) fixed; /* selection status of each winchester in WIN_CONFIG */   clear_screen;   if level igt 11 then do; /* invalid disk level */      crlf;      pstring('*** System Error:  Invalid disk level '); pnum (level, 0); pstringr (' passed to FORMAT.'); flush_term;      call exit(-1);   end;   if      level = 0 then level = shr(core(loc.scat + 1), 8); /* convert level zero to actual device */   else if level = 1 then level = shr(core(loc.ucat + 1), 8); /* convert level one to actual device */   if ((level > 1) and (level < 6)) then do; /* dealing with floppies */      sta = disk.form (level, buf); /* see if we can format */      if sta = 0 /* format succeeded */      then sta = test; /* test disk */      if sta <> 0 then do;         if sta <> 3 then do; /* don't print out message for write-protected */            wchar (a.bel); wchar (a.bel);            crlf;            pstringr ('    ***********************************************************');            pstringr ('     This disk did not format and may be permanently defective.');            pstringr ('                  Do NOT use this disk!');            pstringr ('    ***********************************************************');            crlf;         end;         f.err = false;      end;      else do; /* passed format and read test */         crlf;         pstringr ('*** Format complete.');         f.err = true; /* signal no error */      end;   end; /* of floppies section */   /* $page */   else if winchester (level) then do; /* winchester formatting? */      pstring ('Formatting:  '); call name (level); crlf;      pstringr ('-------------------------------------------------------------------------------');      pstringr ('You have elected to format your Winchester disk.  This will erase ALL files');      pstringr ('saved on it.  Use cursor keys to move over Winchester disk drives.  Press');      pstringr ('space bar to select or deselect a drive to format.  Press RETURN to initiate');      pstringr ('format.  Press Q to abort format.  Selected drives are marked with a >.');      crlf;      pstringr ('');      pstringr ('');      crlf; flush_term;      if (read("51") and scsiboard) <> 0 then do; /* if SCSI is in the system */         call poll_scsi (win_config, c#strlen); /* see what SCSI winchesters we have */         j = 0;         do i = 6 to 7; /* see if any IMI Winchesters configured */            if find_device (i) <> 0 then do; /* if configured */               if (shr(core(find_device (i)), 8) and "3") = 0 then j = 1; /* we have an IMI drive */            end;         end; /* of looking for configured IMI Winchesters */         if j then do; /* look for any IMIs */            i = 0;            do while ((i < c#strlen) and (win_config (i) <> s#freblk)); /* look for the first free entry */               i = i + s#blklen; /* point to next entry */            end;            call poll_winchesters (location(addr(win_config (i))), c#strlen - i); /* see what IMI winchesters we have */         end;      end; /* of SCSI in system */      else call poll_winchesters (win_config, c#strlen); /* see what winchesters we have */      call blockset (win_status, c#strlen/s#blklen, 0); /* don't format any */      call blockset (xref, 24, -1); /* initialize cross reference table to include nothing */      if print_winchesters (level, win_config, win_status, xref) <> 0 then do; /* if any Winchesters selectable */         if not select_winchesters (xref, win_config, win_status) then return (false); /* select the winchesters to format */         i = 0; f.err = true; /* start formatting, assume no errors */         do while ((i < c#strlen/s#blklen) and f.err); /* format each Winchester in turn */            if win_status (i) then do; /* format this drive */               clear_screen; /* be neat */               if win_status (i) = primary_format then do;                  crlf; pstringr ('*** Preparing for a PRIMARY format.');               end;               j = i*s#blklen; /* point to block in win_config */               f.err = winform (win_status (i) = primary_format, win_config (j + s#devtyp), win_config (j + s#devadr), buf);               if (shr(win_config (j + s#devtyp), 8) and "3") = 1 then do; /* if SCSI device */                  if (win_config (j + s#devadr) = 5) and (level = 6) then win.was.formatted = 1;               end;               else if (win_config (j + s#devadr) = 0) and (level = 6) then win.was.formatted = 1; /* not a SCSI Winchester */            end;            i = i + 1; /* look at next winchester configured */         end; /* of formatting selected drives */      end; /* of some Winchesters selectable */   end; /* of winchester format */    else if tape (level) then do; /* cartridge tape formatting */      sta = tapeform (level, buf); /* format the tape */      if sta <> 0 then do; /* check the status */         wchar (a.bel);         crlf; crlf; crlf;         pstringr ('     **********************************************************');         pstringr ('     This tape did not format and may be permanently defective.');         pstringr ('                     Do NOT use this tape!');         pstringr ('     **********************************************************');         crlf; crlf; crlf;         wchar (a.bel);         f.err = false; /* flag there was a format error */      end;      else do; /* status okay */         pstringr ('*** Format complete.');         f.err = true; /* flag there was no error */      end;   end; /* of tape formatting */   else if optical (level) then do; 	/* 5-inch optical media formatting */      pstring  ('Formatting:  '); call name (level); pstring ('   ');				i = find_device (level);			/* find the device */		if (i != 0)			print_scsi_name(core(i + s#devadr));		crlf;		      pstringr ('-------------------------------------------------------------------------------');      pstringr ('You have elected to FORMAT the optical media in the optical drive.');      pstringr ('This will erase ALL files saved on it.'); crlf;      pstringr ('Press RETURN to initiate format.  Press Q to abort format.');      pos (cmdline, 0); flush_term;      i = 0; i = rchar; /* move to bottom of screen and get next character */      if i = a.cr then do; /* if they want to proceed, double-check */         pcmd ('*** Warning:  ALL files saved on this optical media will be destroyed.'); crlf;         get_string ('Please verify format, then type ''OK'' followed by RETURN ->', false, ibuf, 2);         if not compare (ibuf, 'OK') then do; /* if not OK */            i = -1; /* make sure we don't do anything */            erase_command; crlf; erase_line; /* be neat */            pos (cmdline - 2, 0); erase_line;            pstring ('*** The optical media was not formatted.');         end;         else do;				pos (cmdline,   0); erase_line;				pos (cmdline+1, 0); erase_line;				pos (8, 0);            sta = format_optical_media(level); /* attempt the format */            if sta = 0 then do;               pstringr ('*** Format complete.');               f.err = true; /* no error */            end;            else if sta = 1 then do; /* user aborted the format - do nothing */               f.err = true;            end;            else do; /* error */               erase_command; crlf; erase_line; flush_term; /* clean up the screen */               wchar (a.bel); wchar (a.bel); /* beep terminal so they notice */               pos (cmdline - 2, 0); erase_line; /* position for error message */               do case (sta + 1); /* branch on return status */                  pstring ('*** SCSI connect error.  Format aborted.');                  ;          /* format okay, case already handled above */                  ;          /* user aborted, case already handled above */                  pstring ('*** There is no media present in the optical drive.  Format aborted.');                  pstring ('*** Optical media format must be 1024 bytes/sector.  Format aborted.');                  pstring ('*** This media is write-protected.  Format aborted.');                  pstring ('*** An medium error occurred while writing to this media.  Format aborted.');                  pstring ('*** A SCSI error occurred while writing to this media.  Format aborted.');                  pstring ('*** The SCSI device could not report its capacity.  Format aborted.');               end;            end;         f.err = false; /* flag there was a format error */         end;          end;      else do; /* reassure that the format did not occur */         pos (cmdline - 2, 0); erase_line;         pstring ('*** The optical media was not formatted.');      end;   end;   return (f.err); /* return the status */end format;      end format_device;