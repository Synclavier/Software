/* $TITLE  Cartridge Tape Formatting and Directory Maintenance Routines *//* This procedure formats a cartridge tape on the Kennedy Model 6455  tape drive unit.  It initializes the directory to empty FCBs  (except the first FCB which is the free list pointer) and writes  this (followed by a extended filemark) to the beginning of the tape.  The cartridge tape library TAPELIB is used to create the directory.  Both the LEVEL and a BUFFER are passed to this routine.   If the directory write fails, TRUE is returned.  Otherwise, FALSE  is returned.  By:  Karim J. Chichakly on 27 July 1983 */module format_tape;   configuration modelC, MULDIV;   insert ':-xpl:literals'; /* literals */   insert ':-xpl:termrout'; /* need terminal utilities */   insert ':-xpl:tapebrdg'; /* need system I/O routines with tape support */   insert ':-xpl:catrtns';  /* need catalog routines */   insert ':-xpl:devutil';  /* need device handlers */   insert ':-xpl:catutil';  /* and catalog utilities */   tapeform: proc(level, buffer) returns(boolean) public;      dcl level  fixed; /* the level number of the device */      dcl buffer fixed array; /* a buffer for the directory */      dcl i      fixed;      if      level = 0 then level = shr(core(loc.scat + 1), 8); /* map to actual device */      else if level = 1 then level = shr(core(loc.ucat + 1), 8);      if not tape (level) /* make sure it's the tape drive */      then do; /* it isn't */         crlf;         pstring ('Invalid tape level ');  pnum (level, 0);  pstringr (' passed to TAPEFORM.'); flush_term;         call exit(-1);      end;      pstring ('*** Beginning format pass on '); call name (level); crlf; flush_term;      do i = 0 to f#name_len - 1; /* initialize the first FCB of the directory */         buffer (c#nm + i) = 0; /* zero out the name */      end;      buffer (c#ls) = 1; /* initialize LSB of starting sector (track zero, file one) */      buffer (c#ll) = -1; /* there are many consecutive sectors */      buffer (c#wd) = 0; /* no file so no word length */      buffer (c#ty) = 0; /* set type and MS bits to zero */      do i = c#len to dir_size - 1; /* zero out the rest of the directory */         buffer (i) = 0; /* since they're all empty FCBs */      end;      call tension_tape (level); /* force a tape conditioning/tensioning */      call writedata (shl(level,8), 0, buffer, dir_size); /* write out the directory */      if (tape_status and status_mask) <> 0 /* did we succeed? */      then return (true); /* no, bomb out here */      call write_filemark (level, true); /* write filemark extended */      if (tape_status and status_mask) <> 0 /* did we succeed? */      then return (true); /* no, bomb out */      call rewind (level); /* rewind the tape */      if (tape_status and status_mask) = 0 /* did we rewind the tape successfully? */      then tape_position (level and 1) = 0; /* yes, we're now at the beginning of the tape */      else tape_position (level and 1) = -1; /* no, we don't know where we are */      return (false); /* we did it */   end tapeform;/* $page *//* This procedure sets the "tape full" flag in the tape directory.  It  is assumed that it the tape has previously been checked and is in  fact full.  The LEVEL number is passed, but is currently unused. */   set_full: proc(level) public;      dcl level            fixed; /* the device level */      dcl free (f#len - 1) fixed; /* the free list pointer block */      if      level = 0 then level = shr(core(loc.scat + 1), 8); /* map to actual device */      else if level = 1 then level = shr(core(loc.ucat + 1), 8);      if not tape (level) /* is this the tape drive? */      then do; /* no, complain a bit */         crlf;         pstring ('Invalid tape level ');  pnum (level, 0);  pstringr (' passed to SET_FULL.'); flush_term;         call exit(-1);      end;      call read_catalog ('', level); /* read in the catalog */      call get_fcb (0, free); /* get the first FCB */      free (f#ms) = 0; /* set MSB starting sector */      free (f#ls) = -1; /* set LSB starting sector equal to the "tape full" flag */      free (f#ml) = 0; /* set MSB of number of consecutive sectors */      free (f#ll) = 0; /* set number of consecutive sectors equal to zero */      call put_fcb (0, free); /* and put it back */      call write_catalog; /* write it back out */      tape_position (level and 1) = -1; /* we're off the tape */   end set_full;/* $page *//* This procedure is used to finish off a file which was written to the  tape.  It writes a filemark at the current position on the current  track and then checks the catalog free list to see if we're on a  different track than we were when we started the file.  If we are  on a different track, the free list is updated.  If we're at the  physical end-of-tape (track LAST_TRACK, leot), the "tape full" flag  is set in the directory.  The device LEVEL number is passed, but is  not presently used. */   end_file: proc(level) public;      dcl level            fixed; /* the device level number */      dcl free (f#len - 1) fixed; /* the free list FCB */      dcl track            fixed; /* the current track */      if      level = 0 then level = shr(core(loc.scat + 1), 8); /* map to actual device */      else if level = 1 then level = shr(core(loc.ucat + 1), 8);      if not tape (level) /* is this a tape drive? */      then do; /* no... */         crlf;         pstring ('Invalid tape level ');  pnum (level, 0);  pstringr (' passed to END_FILE.'); flush_term;         call exit(-1);      end;      call write_filemark (level, false); /* write the filemark */      call check_tape; /* check the status */      call read_catalog ('', level); /* and read in the catalog */      call get_fcb (0, free); /* get the free list FCB */      track = shr(tape_status and track_mask, track_shift); /* get the current track number */      if track <> shr(free (f#ls), track_shift) /* same track as when we started the file? */      then free (f#ls) = (shl(track, track_shift) or 1); /* no, update the track and file number */      if (tape_status and end_of_tape) <> 0 /* are we at the logical end of a track? */      then do; /* yes, we'd better point the free list to the next track */         if track = core(find_device (level) + s#totcyl) - 1 /* are we at the physical end-of-tape? (i.e., at LEOT on last track) */         then do; /* yes, set "tape full" flag */            free (f#ms) = 0; /* set MSB starting sector */            free (f#ls) = -1; /* set LSB starting sector equal to the "tape full" flag */            free (f#ml) = 0; /* set MSB of number of consecutive sectors */            free (f#ll) = 0; /* set number of consecutive sectors equal to zero */         end;         else free (f#ls) = shl(track + 1, track_shift); /* no, point to beginning of next track */      end;      call put_fcb (0, free); /* put the free list FCB back */      call write_catalog; /* and write it out */      tape_position (level and 1) = free (f#ls); /* update the tape position */   end end_file;end format_tape;