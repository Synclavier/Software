/* $subtitle GETFILES - Get Wildcarded Filenames *//* GETFILES consists of two procedures which may be inserted into any program..  The first procedure, FINDWILD, searches the current catalog for zero or.  more occurrences of a file.  The second procedure, GETFNAME, gets a filename.  from a line of input.  If a filename exists, it is returned.  Otherwise,.  a null string is returned and boolean FALSE is returned...  Before GETFNAME can be called, START_SEARCH must be called once to set.  up the list of files to search for...  Written by Karim J. Chichakly and Betsy S. Wakeman on 16 July 1984.  Totally rewritten by Karim J. Chichakly on 26 November 1986.  Tree climbing code added by Kip J. Olson on 4 November 1986 */module get_filenames;   configuration modelC, MULDIV;   insert ':-xpl:literals'; 		/* ascii literal representations */   insert ':-xpl:asciilit'; 		/* more ascii literal representations */   insert ':-xpl:syslits';  		/* system literals */   insert ':-xpl:catrout';  		/* catalog routines */   insert ':-xpl:strings';  		/* string processing */   insert ':utilcat:searchit'; 		/* search and matching routines */   dcl max_len lit '128'; /* maximum number of characters allowed in FILES */   dcl treemax lit '132'; /* max no. characters in treename */   dcl stkmax  lit '512'; /* max no. words on stack */   dcl treename (treemax/2) fixed public; /* array for treename */   dcl wildcard             boolean public; /* indicates wildcard character */   dcl fcb (f#len) fixed; /* fcb array (MUST be F#LEN words, not F#LEN - 1; see FINDWILD) */   dcl fcbs        fixed; /* number of fcbs in this catalog */   dcl fcb_index   fixed; /* index into the catalog buffer */   dcl level       fixed; /* level of catalog we're searching in */   dcl catcache    fixed; catcache = -1; /* catalog cache number */   dcl climb       boolean; /* TRUE if subcatalogs should also be searched */   dcl files (max_len/2) fixed; /* list of files to search for */   dcl fnptr             fixed; /* byte pointer into FILES */   dcl stack (stkmax - 1) fixed; /* stack for treename processing */   dcl stkptr             fixed; /* stack pointer */   push: proc(n); /* push new value onto stack */      dcl n fixed;      if stkptr = stkmax then do; /* stack overflow */         write("50") = a.sharp; write("50") = a.s; write("50") = a.o; /* #SO */         call exit(-1);      end;      stack (stkptr) = n;      stkptr = stkptr + 1;   end push;   pop: proc returns (fixed); /* pop value from stack */      if stkptr = 0 then do; /* stack underflow */         write("50") = a.sharp; write("50") = a.s; write("50") = a.u; /* #SU */         call exit(-1);      end;      stkptr = stkptr - 1;      return (stack (stkptr));   end pop;   /* $subtitle Start The Search */   /* This procedure initializes the search by saving the list of filenames   .  as well as information about the catalog. */   start_search: proc(filenames, tree, lev) public; /* start search */      dcl filenames fixed array; /* string containing list of filenames */      dcl tree      boolean; /* TRUE if we should search all subcatalogs of LEV */      dcl lev       fixed; /* level of device to search for filenames on */      dcl (i, j)    fixed;      /* initialize FINDWILD */      level = lev; /* save the level number */      call disable_cache (catcache); /* disable catalog cache just in case */      catcache = cache (c#bufptr, c#bufmed); /* cache the catalog if at all possible */      call read_catalog ('', level); /* read the first catalog */      fcbs = c#dir_size/c#len; /* calculate the number of FCBs */      fcb_index = 0; /* reset FCB pointer */      /* initialize GETNEXT */      if filenames (0) ige max_len /* j = min (max_len - 1, filenames (0)); */      then j = max_len - 1;      else j = filenames (0);      call strncpy (files, filenames, 0, j - 1); /* copy list of files over */      call pbyte(files, j, a.sp); /* end string with a space to ease parsing */      files (0) = j + 1; /* set string length */      fnptr = j + 1; /* point to end of string (to force initial GET_NEXT_CAT call) */      /* initialize GET_NEXT_CAT */      climb = tree; /* remember whether or not to climb */      treename (0) = 0; /* no treename yet */      call cache_treename (true); /* cache any treenames */      stkptr = 0; /* stack is currently empty */      do i = 0 to f#name_len; /* put empty file on stack */         call push (0);      end;      call push (0); /* current treename length is zero */   end start_search;   /* $subtitle Find Next Wildcard Match In Catalog */   /* This procedure searches the catalog (specified by TREENAME and   .  LEVEL) for the next filename that matches the passed FNAME.  If   .  such a filename is found, FNAME is changed to that filename and   .  a boolean TRUE is returned.  Otherwise, a boolean FALSE is returned.   .  It is assumed that any wildcards in the filename have been prescanned. */   findwild: proc(fname) returns (boolean); /* search catalog for next occurrence of name */      dcl fname  fixed array; /* file name */      dcl a_name boolean;     /* true if there is a match of filenames in the current catalog. */      dcl i      fixed;      call read_catalog (treename, level); /* read the catalog in (hopefully it's still cached) */      a_name = false;      do while ((fcb_index < fcbs) and (not a_name)); /* do while pointer is less than # of fcb's in current catalog and a match has not been found */         call get_fcb (fcb_index, loc(addr(fcb (1)))); /* get an fcb from the current catalog */         if fcb (f#nm + 1) <> 0 then do; /* if FCB in use */            call clean_fcbname (loc(addr(fcb (1))), fcb); /* set length of filename */            i = search (fcb, fname); /* see if any match */            if ((i = 0) and (fcb (0) = match_length)) then do; /* if wildcard name matches filename exactly */               call strcpy (fname, fcb); /* copy filename */               a_name = true; /* found a name */            end;         end;         fcb_index = fcb_index + 1; /* point to next fcb in the current catalog */      end;      if ((not a_name) and (fcb_index >= fcbs)) /* if at end of catalog with no match */      then fcb_index = 0; /* reset pointer for next time through */      return (a_name);   end findwild;         /* $subtitle Scan Next Filename */   /* This procedure scans the next filename from the string FILES.  The   .  filename is returned in FNAME.  If no filenames are left, a boolean   .  FALSE is returned.  If a wildcard is specified, the next match in   .  the catalog is returned.  If no more matches exist, the next filename   .  is scanned off.  If searching subcatalogs, a filename is returned   .  ONLY if the filename exists in catalog TREENAME/LEVEL. */   getnext: proc(fname) returns (boolean); /* get next filename from input line */      dcl fname  fixed array; /* the next file name from files */      dcl fnend  fixed;       /* pointer to end of filename */      dcl a_name boolean;     /* true if there is a file name in files */      a_name = false; /* no file found yet */      do while ((fnptr < files (0)) and (not a_name)); /* ignore matches that fail (only wildcard or subcats) */         wildcard = false; /* assume no wildcard in name */         do while ((fnptr < files (0)) and (byte(files, fnptr) = a.sp)); /* skip leading spaces */            fnptr = fnptr + 1;         end;         fnend = index (files, ' ', fnptr); /* find end of filename (delimited by spaces) */         if fnend <> -1 then do; /* if not at end of string */            call upper (loc(strncpy (fname, files, fnptr, fnend - 1))); /* pick up uppercased filename */            if prescan (fname) then do; /* if wildcard present */               wildcard = true; /* remember a wildcard was encountered */               if findwild (fname) /* if a wildcard match was found */               then a_name = true; /* we have a filename */               else fnptr = fnend; /* no filename - advance pointer */            end; /* of wildcard */            else do; /* have a filename */               if climb then do; /* if climbing tree */                  call read_catalog (treename, level); /* read the catalog in (hopefully it's still cached) */                  if findfile (fname) <> -1 /* only return a name if it's there */                  then a_name = true; /* remember we have a name */               end; /* of climbing tree */               else a_name = true; /* always return name if not climbing */               fnptr = fnend; /* advance pointer */            end; /* of have a filename */         end; /* of not at end of string */      end; /* of ignore names that fail */      return (a_name);   end getnext;   /* $subtitle Get Next Catalog */      /* This procedure finds the next subcatalog to search when climbing the   .  tree for files.  It returns TRUE if it found another catalog. */   get_next_cat: proc returns (boolean); /* get next catalog in tree */      dcl cat_index (c#dir_max/c#len - 1) fixed; /* pointer array for sorting */      dcl numcats                         fixed; /* no. catalogs found */      subcatalogs: proc returns (fixed); /* finds all subcatalogs in this catalog */         dcl len fixed; /* no. files stored */         dcl i   fixed;         len = 0; /* no valid files found yet */         do i = 0 to c#dir_size/c#len - 1; /* loop over all catalog entries */            call get_fcb (cat_index (i), fcb); /* get fcb from catalog */            if fcb (f#nm) <> 0 then do; /* if FCB in use */               if ((fcb (f#ty) = t#subc) or (fcb (f#ty) = t#lsubc)) then do; /* subcatalog? */                  cat_index (len) = cat_index (i); /* store this index */                  len = len + 1; /* one more fcb found */               end;            end; /* of FCB in use */         end; /* of loop over all catalog entries */         return (len); /* return no. files stored */      end subcatalogs;      sortcatalog: proc (fcb_index, fcb_count); /* sorts FCBS in catalog starting at given index */         dcl fcb_index        fixed; /* first fcb index to start sorting at */         dcl fcb_count        fixed; /* no. fcbs to sort */         dcl fcb2 (f#len - 1) fixed; /* FCB for sort */         dcl temp             fixed;         dcl (i, j)           fixed;         compare_fcbs: proc (i) returns (fixed); /* compares adjacent FCB names */            dcl i fixed; /* fcb index in catalog */            call get_fcb (cat_index (i - 1), fcb); /* get fcb's needed from catalog */            call get_fcb (cat_index (i), fcb2);            i = f#nm; /* start at beginning of name */            do while ((i < f#nm + f#name_len) and (fcb (i) = fcb2 (i))); /* loop over all equal characters in name */               i = i + 1; /* next two characters in name */            end;            if i = f#nm + f#name_len then return (0); /* names are equal */            else if rot(fcb (i), 8) ilt rot(fcb2 (i), 8) then return (-1); /* fcb < fcb2 */            else return (1); /* fcb > fcb2 */         end compare_fcbs;         do i = 1 to fcb_count - 1; /* insertion sort */            j = fcb_index + i; /* get fcb index in catalog */            do while ((j <> fcb_index) and (compare_fcbs (j) = -1)); /* loop until required order is not met */               temp = cat_index (j - 1); /* swap */               cat_index (j - 1) = cat_index (j);               cat_index (j) = temp;               j = j - 1;            end;         end; /* of insertion sort */      end sortcatalog;      /* $page */      dcl (i, j) fixed;      if stkptr <> 0 then do; /* something on stack */         treename (0) = pop; /* restore treename length */         if ((treename (0) <> 0) and (treename (0) < treemax)) then do; /* not a null tree name */            call pbyte(treename, treename (0), a.colon); /* put colon at end of treename */            treename (0) = treename (0) + 1; /* adjust length for colon */         end;         do i = f#name_len to 0 by -1; /* restore subcat name */            fcb (i + 1) = pop;         end;         do i = 0 to shl(f#name_len, 1) - 1; /* add new subcatalog name to tree name */            if ((byte(fcb, i) <> 0) and (treename (0) < treemax)) then do; /* valid character */               call pbyte(treename, treename (0), byte(fcb, i)); /* add character */               treename (0) = treename (0) + 1; /* adjust length for new character */            end;         end;         if not read_catalog (treename, level) then return (false); /* try to read catalog */         fcbs = c#dir_size/c#len; /* calculate the number of FCBs */         if climb then do; /* if climbing the tree */            do i = 0 to c#dir_size/c#len - 1; /* prime catalog pointers */               cat_index (i) = i;            end;            numcats = subcatalogs;   /* find all subcats in this catalog */            call sortcatalog (0, numcats); /* sort subcat names in reverse alphabetical order */            do i = 0 to numcats - 1; /* loop over subcats in this catalog */               if stkptr + f#name_len + 2 ile stkmax then do; /* there is room on stack */                  call get_fcb (cat_index (i), fcb); /* get next fcb in catalog */                  do j = 0 to f#name_len; /* push subcatalog name */                     call push (fcb (f#nm + j));                  end;                  call push (treename (0)); /* push current length of treename */               end; /* of room on stack */            end; /* of loop over subcats in this catalog */         end; /* of climbing the tree */         return (true); /* got a catalog */      end; /* of something on stack */      else return (false); /* nothing on stack - all done */   end get_next_cat;   /* $subtitle Get Next Filename */   /* This procedure finds and returns the next filename in the list of   .  FILES.  If climb is set, it searches all subcatalogs on LEVEL and   .  returns the appropriate TREENAME.  A boolean TRUE is returned if   .  another file is found.  Otherwise, a boolean FALSE is returned   .  and FNAME contains the null string. */   getfname: proc(fname) returns (boolean) public; /* get next filename */      dcl fname  fixed array; /* the next filename */      dcl a_name boolean; /* TRUE if a name is found */      dcl done   boolean; /* TRUE if all done */      a_name = getnext (fname); /* get next filename from this catalog */      done = false; /* not done yet */      do while ((not done) and (not a_name)); /* loop until a name is found */         if get_next_cat then do; /* read in the next catalog */            fnptr = 0; /* scan the list of filenames once more */            a_name = getnext (fname); /* get the name */         end;         else done = true; /* all out of catalogs and names */      end; /* of looping until a name if found */      if a_name then do; /* if a name was found */         if treename (0) <> 0 then do; /* if a treename */            call strncat (fname, ':', 0); /* insert colon */            call strncat (fname, treename, 0); /* and treename */         end;      end; /* of name was found */      else do; /* no name found - we're done (DONE better be TRUE) */         call disable_cache (catcache); /* stop caching catalog */         call cache_treename (false); /* and treename */         fname (0) = 0; /* make sure the name is null */      end;      return (a_name); /* return whether a name was found */   end getfname;end get_filenames;