/*  DISKFORM  $TITLE  Disk Setup and Format Routines */module format_floppy;configuration modelC, MULDIV;insert ':-xpl:literals'; /* literals */insert ':-xpl:termrout'; /* terminal utilities */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:devutil'; /* device handlers */insert ':-xpl:catutil'; /* catalog utilities */insert ':utilcat:literals'; /* utilcat literals */dcl cpmflag boolean public; /* TRUE if this is a CP/M format; FALSE if XPL format *//* DISK RELATED VARIABLES */DCL SPD   fixed; /* SPEED of DISKETTE               */DCL NUMT  fixed; /* NUMBER OF TRACKS ON DISKETTE    */DCL SECT  fixed; /* SECTORS PER TRACK               */DCL GAP1  fixed; /* AT START OF DISK                */DCL GAP2  fixed; /* BETWEEN SECTORS                 */DCL OFFS  fixed; /* OFFSET BETWEEN DIFFERENT TRACKS */DCL FCOD  fixed; /* FORMAT CODE                     */DCL MFM   fixed; /* TRUE if MFM                     */DCL SIDES fixed; /* NUMBER OF SIDES - 1             */DCL DEV   fixed; /* device ID for device we're formatting/testing */DCL STS   fixed; /* STATUS/COMMAND REGISTER */DCL TRK   fixed; /* TRACK REGISTER          */DCL SEC   fixed; /* SECTOR REGISTER         */DCL DAT   fixed; /* DATA REGISTER           */DCL MOT   fixed; /* MOTOR ON ADDRESS        */DCL DR    fixed; /* DISK DRIVE 0 OR 1 */d100a: proc(device) boolean; /* TRUE if DEVICE is controlled by a D100A */   dcl device fixed; /* device number of device to check */   device = (device and "17"); /* remove drive number from device */   if      device = 0 then return ((read("51") and "010000") <> 0); /* floppy */   else if device = 2 then return ((read("51") and "020000") <> 0); /* remote */   else                    return (false); /* nothing else is controlled by any type of d100 */end d100a;/* $PAGE *//*  S E T . U P  */SET.UP:  proc(level) public;   dcl level  fixed;   assign.conf:  proc(list); /* assign config to disk vars */      dcl list fixed array;      dcl ID   fixed; /* drive ID */      DEV = (list(s#devtyp) and "377"); /* get device */      DR = (shr(dev,4) and "17"); /* get drive number */      NUMT = list(s#totcyl); /* total cylinders */      SECT = shr(list(s#spdtrk), 8); /* sectors/track */      SPD  = (list(s#spdtrk) and "377"); /* stepping speed */      MFM = ((list(s#devtyp) and "400") <> 0); /* set density */      if d100a (dev) then do; /* get drive ID */         write(MOT)=DR; ID=read(MOT);      end;      else ID=0; /* d100 ID cannot be read - all drives on it had an ID of 0 */      sides=((ID and "2")<>0); /* determine number of sides */      if (ID and "4")=0 then DR=(DR or "20"); /* set precomp if necessary */      gap1=16;      if (numt=mini_config(s#totcyl)) or (numt=dmin_config(s#totcyl)) then do; /* minidiskette? */         offs=2; /* rotational offset of 2 */         if sect=shr(smin_config(s#spdtrk),8) then do; /* supermini? */            gap1=32; gap2=90;            if cpmflag then do; /* select CP/M format */               sect=26; gap2=54; sides=0; mfm=0;            end;         end; /* of supermini */         else do; /* SD or DD floppy */            gap2=62; /* use a gap2 of 62 */            if cpmflag then do; /* select CPM format */               sect=16; gap2=30;            end;         end; /* of SD or DD floppy */      end; /* of minidiskette */      else do; /* must be large diskette */         offs=1;         gap2=80;         if cpmflag then do; /* select CPM format */            sect=26; gap2=33;         end;      end;      if mfm then fcod="H4E"; else fcod="HFF"; /* set format code */      DR=(DR or (ID and "10") or shl(mfm, 2)); /* set rate and density */      if (list(s#devtyp) and "1000") <> 0 then DR=(DR or "10"); /* override rate if necessary */   end assign.conf;   /* set up interfaces */   if (level=0) or ((level=1) and (curtyp=0)) or (level=2) or (level=3) then do; /* dealing with main floppies */      STS = "100";      TRK = "101";      SEC = "102";      DAT = "103";      MOT = "104";   end;   else do; /* remote mini's */      STS = "110";      TRK = "111";      SEC = "112";      DAT = "113";      MOT = "114";   end;   call assign.conf (location(find_device (level))); /* assign the floppy's configuration */END SET.UP;/* $SUBTITLE  D I S K . F O R M  *//* A PROCEDURE TO FORMAT A DISK BASED ON CONFIG TABLE INFO *//* RETURNS 0 IF OK, 1 IF NOT OK, 3 IF WRITE-PROTECTED      *//* 5 IF THE PROBLEM SEEMS TO BE IN THE DISK DRIVE          */DISK.FORM:  PROC(LEVEL,BUF) FIXED PUBLIC; /* CALL TO FORMAT DISKETTE AS INDICATED BY CONFIG TABLE */  DCL LEVEL       FIXED; /* disk/system level */  DCL BUF         FIXED ARRAY; /* BUFFER TO HOLD TRACK FORMAT DATA */  DCL PTR         FIXED; /* GLOBAL POINTER TO BUF */  DCL IDFLIST(50) FIXED; /* HOLDS POINTERS TO START OF ID FIELDS */  DCL IDFPTR      FIXED; /* POINTER INTO IDFLIST */  DCL SECTOR      FIXED; /* SECTOR COUNTER - TO DO OFFSET */  DCL DATATOP     FIXED; /* MINIMUM NUMBER TO WRITE */  dcl state       fixed; /* processor state */  DCL (I,J,K)     FIXED;    DEP:  PROC(NUM,VAL); /* STORE DATA IN ARRAY */     DCL (NUM,VAL) FIXED;     DO NUM=0 TO NUM-1;        BUF(PTR)=VAL;        PTR=PTR+1;     END;  END DEP;  CALL SET.UP (LEVEL); /* SET UP INTERFACES */  IF NOT (READ(STS)) THEN WRITE(STS)=SPD; /* PERFORM A RESTORE COMMAND */  PTR=0; /* INITIALIZE POINTER */  IDFPTR=0;  SECTOR=1; /* START WITH SECTOR ONE */  /* SET UP CONTENTS OF TRACK */  CALL DEP(GAP1,FCOD);  /* FIRST OF ALL, THE FORMAT CODE   */  DO I=0 TO SECT-1;     /* AND THEN FOR EACH SECTOR        */    CALL DEP(6,0);      /* THEN SIX ZEROES                 */    IF mfm THEN DO; /* MFM needs extra data */       CALL DEP(6,0); /* EXTRA ZEROES */       CALL DEP(3,"HF5"); /* and generate A1 */    END;    CALL DEP(1,"HFE");  /* GENERATES ID FIELD ADDRESS MARK */    IDFLIST(IDFPTR)=PTR;IDFPTR=IDFPTR+1; /* STACK PTR TO START OF ID FIELD  */    CALL DEP(1,0);      /* THIS WILL CONTAIN TRACK #       */    CALL DEP(1,0);      /* THIS WILL CONTAIN SIDE #        */    CALL DEP(1,0);      /* AND THIS WILL CONTAIN SECTOR #  */    IF cpmflag THEN CALL DEP(1,0); /* FOR 128 BYTE SECTORS            */    ELSE CALL DEP(1,2); /* THEN A 2 TO INDICATE 512 BYTES  */    CALL DEP(1,"HF7");  /* THEN GENERATE 2 CRC'S           */    CALL DEP(11,FCOD);  /* THEN 11 FORMAT CODES            */    IF mfm THEN DO; /* MFM needs more */       CALL DEP(11,FCOD); /* twice as much */       CALL DEP(12,0); /* TWELVE ZEROES */       CALL DEP(3,"HF5"); /* and generate A1 */    END;    ELSE CALL DEP(6,0);      /* THEN 6 ZEROS                    */    CALL DEP(1,"HFB");  /* THEN DATA MARK                  */    IF cpmflag THEN CALL DEP(128,"HE5"); /* USE E5'S FOR CPM FORMAT         */    ELSE              CALL DEP(512,"H80"); /* THEN 512 BYTES OF set 1 bit     */    CALL DEP(1,"HF7");  /* THEN CRC                        */    CALL DEP(GAP2,FCOD); /* THEN GAP AFTER DATA FIELD       */  END;  DATATOP=PTR;  CALL DEP(MIN.BUF.SECS*256-PTR,FCOD);  /**/  WRITE(MOT)=DR; /* TURN ON MOTOR & SELECT DRIVE AT THIS TIME */  DO WHILE READ(STS); END; /* WAIT FOR RESTORE TO FINISH NOW */  WRITE(STS)=SPD; /* PERFORM A SECOND RESTORE - WILL TAKE NO TIME IF AT 0 */  DO WHILE READ(STS); END;  IF (READ(STS)&"4")=0 THEN DO;    pstringr ('ERROR detected:  performed a RESTORE command and');    pstringr ('received no track zero indication.  Must be a hardware error.');    RETURN 5;  END;  IF (READ(STS)&"100")<>0 THEN DO; /* WRITE PROTECTED */    crlf;    pstring ('The diskette in '); call name(LEVEL); pstringr (' is WRITE protected.');     if (SECT=shr(maxi_config(s#spdtrk),8)) & (NUMT=maxi_config(s#totcyl)) & (SPD=(maxi_config(s#spdtrk) and "377")) then /* main large floppies */       pstringr ('The WRITE TAPE must be put over the slot on this large floppy.');    else /* main MINI's or remotes */           pstringr ('The WRITE PROTECT tape must be removed from this MINI floppy.');    crlf;    RETURN 3;  END;  pstring ('*** Beginning FORMAT pass on '); call name(LEVEL); crlf;  if cpmflag then pstringr ('    (CP/M format option is selected)');  flush_term;    state = read(r14); /* save the machine's state */  disable; /* and disable interrupts */  DO I=0 TO NUMT-1; /* NOW PROCESS EACH TRACK */     DO J=0 TO IDFPTR-1; /* SET UP EACH ID FIELD FOR THIS TRACK-SIDE-SECTOR */        BUF(IDFLIST(J))=I; /* SET UP TRACK NUMBER */        BUF(IDFLIST(J)+2)=SECTOR; /* AND SECTOR # */        SECTOR=SECTOR+1; IF SECTOR>SECT THEN SECTOR=SECTOR-SECT; /* WRAP */     END;     DO K=0 TO SIDES; /* FORMAT EACH SIDE IN SYNC */        DO J=0 TO IDFPTR-1; /* SET UP SIDE NUMBER IN EACH ID FIELD FOR THIS TRACK-SIDE-SECTOR */           BUF(IDFLIST(J)+1)=K; /* SET UP SIDE NUMBER */        END;        WRITE(MOT)=(DR or shl(K, 1)); /* TURN ON MOTOR AND WAIT FOR READY */        DO WHILE (READ(STS)&128)<>0; END; /* WAIT FOR READY TO GOTO ZERO */        IF STS = "110" THEN DO; /* FOR REMOTE FLOPPIES */           WRITE("300")=ADDR(BUF(0)); /* point to format buffer [im(addr(buf(0))) to R0] */           WRITE("301")=1; /* get busy bit [im(1) to R1] */           WRITE("302")=2; /* get data request bit [im(2) to R2] */           WRITE("303")=0; /* initialize byte count [im(0) to R3] */           WRITE("110")="364"; /* start format command [im(364) to D110] */           WRITE("330")=2; /* skip writing code [im(2) to RTRA] */           WRITE("113")=READ("360"); /* write next byte [MR0I to D113] */           WRITE("213")=1; /* increment count [im(1) to ADD3] */           WRITE("246")=READ("110"); /* see if data request yet [D110 to TAND2] */           WRITE("335")=-4; /* yes, write next byte [im(-4) to RTNZ] */           WRITE("245")=READ("110"); /* see if still busy [D110 to TAND1] */           WRITE("335")=-4; /* yes, check fo DRQ [im(-4) to RTNZ] */        END;        ELSE DO; /* FOR MAIN */           WRITE("300")=ADDR(BUF(0)); /* point to format buffer [im(addr(buf(0))) to R0] */           WRITE("301")=1; /* get busy bit [im(1) to R1] */           WRITE("302")=2; /* get data request bit [im(2) to R2] */           WRITE("303")=0; /* initialize byte count [im(0) to R3] */           WRITE("100")="364"; /* start format command [im(364) to D100] */           WRITE("330")=2; /* skip writing code [im(2) to RTRA] */           WRITE("103")=READ("360"); /* write next byte [MR0I to D103] */           WRITE("213")=1; /* increment count [im(1) to ADD3] */           WRITE("246")=READ("100"); /* see if data request yet [D100 to TAND2] */           WRITE("335")=-4; /* yes, write next byte [im(-4) to RTNZ] */           WRITE("245")=READ("100"); /* see if still busy [D100 to TAND1] */           WRITE("335")=-4; /* yes, check fo DRQ [im(-4) to RTNZ] */        END;        /**/        J=READ("303"); /* GET NUMBER OF BYTES WRITTEN */        IF J<DATATOP THEN DO;           write(r14) = state; /* restore the machine's state (from compiler's viewpoint) */           write(pcw) = state; /* (and from the machine's viewpoint) */           crlf;           pstringr ('ERROR detected in disk FORMAT operation - chip timed out on');           pstring ('track ');pnum(I+1,0);pstring(' side ');pnum(K,0);pstring(' before entire track was written.  Only ');pnum(J,0);crlf;           pstring ('bytes were written to diskette instead of the ');pnum(DATATOP,0);pstringr(' minimum.');           crlf;           RETURN 5;        END;        J=READ(STS); IF (J&"344")<>0 THEN DO;            write(r14) = state; /* restore the machine's state (from compiler's viewpoint) */           write(pcw) = state; /* (and from the machine's viewpoint) */           crlf;           pstringr ('Status ERROR detected in disk FORMAT operation');           pstring ('status should have been  000000  but was ');onum(J,0);crlf;           crlf;           RETURN 1;        END;     END;     SECTOR=SECTOR-OFFS; /* OFFSET EACH TRACK BY OFFSET */     IF SECTOR<1 THEN SECTOR=SECTOR+SECT; /* BUT KEEP IN RANGE */     IF I<>NUMT-1 THEN DO; /* STEP OUT IF NOT LAST TRACK */        WRITE(3)=0; WRITE(3)=0; WRITE(3)=0; WRITE(3)=0; /* WAIT FOR WRITE TO FINISH */        WRITE(STS)="123"; /* STEP IN COMMAND */        DO WHILE READ(STS); END; /* WAIT FOR THAT TO FINISH */     END;  END; /* OF TRACK LOOP */  write(sts)=spd; /* perform a restore */  do while read(sts); end; /* wait for restore to finish */  if (not cpmflag) then do; /* zero out nedco catalog sector */    do i=0 to 255; buf(i)=0; end; /* zero catalog sector only */    buf(c#ls)=1; buf(c#ll)=numt*sect*(sides+1)-1; /* create null block */    call writedata(shl(level,8),0,buf,256);  end;  write(r14) = state; /* restore the machine's state (from compiler's viewpoint) */  write(pcw) = state; /* (and from the machine's viewpoint) */  RETURN 0; /* NO ERRORS FOUND */END DISK.FORM;/* $SUBTITLE READ THROUGH AN ENTIRE DISKETTE  */TEST:  PROC PUBLIC; /* TESTS DISK SPECIFIED BY SET.UP */  DCL STA         FIXED; /* STATUS TO RETURN - 0 MEANS NO ERRORS */  dcl state       fixed; /* processor state */  DCL (I,J,K,L,S) FIXED; /* AND TEMPORARY VARIABLES */    STA=0;  WRITE(MOT)=DR; /* SELECT DRIVE FOR RESTORE OPERATION */  WRITE(STS)=SPD; /* PERFORM A RESTORE COMMAND TO POSITION HEAD OVER TRACK ZERO */  DO WHILE READ(STS); END;  IF (READ(STS)&4)=0 THEN DO; /* MUST BE OVER TRACK ZERO */    crlf;    pstringr ('Performed a ''RESTORE'' command but got no ''TRACK ZERO''');    pstringr ('indication -- fatal error!');    crlf;    return 1; /* return an error flag */  END;  IF (READ(STS)&64)<>0 THEN DO;    crlf;    pstringr ('The diskette/drive is WRITE protected -- check to make');    pstringr ('sure the media is protected,  otherwise there is a drive problem.');    crlf;    return 1; /* return error flag */  END;/* NOW READ THROUGH DISKETTE */pstringr ('*** Beginning TEST pass.'); flush_term;    state = read(r14); /* save the processor's state */disable; /* and disable interrupts */DO J=0 TO NUMT-1; /* AND TRY EACH TRACK */  WRITE(DAT)=J; /* SET UP DESIRED TRACK */  WRITE(STS)=("20"\SPD); /* AND START THE SEEK TO DESIRED TRACK */  DO WHILE READ(STS);END; /* WAIT FOR SEEK COMPLETION */  DO S=0 TO SIDES; /* CHECK EACH SIDE IN TURN */    DO K=1 TO SECT; /* AND READ SECT SECTORS */      WRITE(MOT)=(DR or shl(S,1)); /* TURN ON MOTOR */      DO WHILE (READ(STS)&"200")^=0;END; /* AND WAIT UNTIL READY */      WRITE(SEC)=K; /* SET UP SECTOR REGISTER */      if d100a (DEV) /* if D100A */      then write(STS)=("202" or shl(S,3)); /* start read, verify side, no delay */      else WRITE(STS)="210"; /* START READ COMMAND, NOT MULTIPLE, IBM, NO DELAY */      /* XPL takes longer READing and WRITing to variables.. hence the need for two loops again */      if STS = "110" then do; /* remote floppies */         write("301")=1; /* get busy bit [im(1) to R1] */         write("302")=2; /* get data request bit [im(2) to R2] */         write("300")=0; /* initialize byte count [im(0) to R0] */         write("330")=2; /* skip reading code [im(2) to RTRA] */         write("324")=read("113"); /* read next byte [D113 to ATNV] */         write("210")=1; /* increment count [im(1) to ADD0] */         write("246")=read("110"); /* see if data request yet [D110 to TAND2] */         write("335")=-4; /* yes, write next byte [im(-4) to RTNZ] */         write("245")=read("110"); /* see if still busy [D110 to TAND1] */         write("335")=-4; /* yes, check fo DRQ [im(-4) to RTNZ] */      end;      else do; /* main floppies */         write("301")=1; /* get busy bit [im(1) to R1] */         write("302")=2; /* get data request bit [im(2) to R2] */         write("300")=0; /* initialize byte count [im(0) to R0] */         write("330")=2; /* skip reading code [im(2) to RTRA] */         write("324")=read("103"); /* read next byte [D103 to ATNV] */         write("210")=1; /* increment count [im(1) to ADD0] */         write("246")=read("100"); /* see if data request yet [D100 to TAND2] */         write("335")=-4; /* yes, write next byte [im(-4) to RTNZ] */         write("245")=read("100"); /* see if still busy [D100 to TAND1] */         write("335")=-4; /* yes, check fo DRQ [im(-4) to RTNZ] */      end;            /* NOW CHECK IT ALL */            I=READ("300"); /* GET COUNT */      IF ((not cpmflag)&(I^=512)) /* NED FORMAT ERROR */      OR ((cpmflag)    &(I^=128)) /* CPM FORMAT ERROR */      THEN DO; /* NOT MULTIPLE - ERROR */        write(r14) = state; /* restore the processor state */        write(pcw) = state;        crlf;        pstringr ('Incorrect sector length in FORMAT field:');        pstring ('Track ');pnum(J,0);pstring(' Side ');pnum(S,0);pstring(' Sector ');pnum(K,0);        pstring('  Number of bytes read: ');pnum(I,0);pstringr('  should have been 512');        flush_term; disable;        STA = STA + 1; /* count errors */        if sta=10 then do;           write(r14) = state; /* restore the processor state */           write(pcw) = state;           return 1;        end;      END;      I=READ(STS); /* GET STATUS FROM INTERFACE */      IF (I&"37")^=0 THEN DO; /* WAS AN ERROR */        write(r14) = state; /* restore the processor state */        write(pcw) = state;        crlf;        pstringr ('Data/Address error in FORMAT field/data field:');        pstring ('track ');pnum(J,0);pstring(' side ');pnum(S,0);pstring(' sector ');pnum(K,0);pstring(' status ');onum(I,0);        pstring ('   (  ');        IF (I&1 )<>0 THEN pstring ('BUSY ERROR');        IF (I&2 )<>0 THEN pstring ('DATA REQUEST BIT STILL SET');        IF (I&4 )<>0 THEN pstring ('DATA WAS LOST');        IF (I&8 )<>0 THEN pstring ('CRC ERROR');        IF (I&16)<>0 THEN pstring ('RECORD NOT FOUND');        pstringr ('  )');        flush_term; disable;        STA = STA + 1; /* count errors */        IF STA=10 THEN do;           write(r14) = state; /* restore the processor state */           write(pcw) = state;           RETURN 1;        end;      END;    END; /* OF SECTOR LOOP */  END; /* OF SIDE LOOP */END; /* OF TRACK LOOP */write(sts)=spd; /* preform a restore */do while read(sts); end;write(r14) = state; /* restore the processor state */write(pcw) = state;if cpmflag then do;  pstringr ('*** CP/M format complete.');  pstringr ('    NOTE:  Label this disk for CP/M use only!');end;IF STA=0THEN RETURN 0;ELSE RETURN 1;END TEST;end format_floppy;