/* $title String Search Routines *//*  This module handles text pattern matching.  It searches for a string.   pattern in a given line and finds the pattern if there is a match...   Written by Betsy Wakeman   July 16, 1984 */module in_search_of;   configuration modelC, MULDIV;   insert ':-xpl:literals';   insert ':-xpl:asciilit';   dcl eschr      lit 'a.slash'; /* character used to force the next character to be taken literally */   dcl single     lit 'a.question'; /* character used to represent any character */   dcl group      lit 'a.star'; /* character used to represent zero or more characters */   dcl any_single lit '"276"'; /* meta character to represent any single character */   dcl any_group  lit '"277"'; /* meta character to represent any group of zero or more characters */   dcl match_length fixed public; /* the length of the match in bytes of the pattern in the line. */   dcl match_count  fixed public; /* the count of the number of matches performed */   dcl find_pattern proc(fixed array, fixed array, fixed, fixed) returns (fixed) recursive;   match_count = 0;   /* $subtitle Match */   /* This procedure matches input patterns and counts the number of matches   .  performed.  If there is a match between two patterns, then TRUE is   .  returned.  Otherwise, the procedure returns FALSE.  All wild cards   .  and escape characters are accounted for.  This procedure assumes that   .  neither line nor string is null and that there is a character at   .  LINE_POS and STRING_POS.   .   .  '*'  matches zero or more characters.   .  '?'  matches any single character.   .  '/'  escape delimiter. (i.e., '/?' = '?', '//' = '/', etc.) */   match: proc(line, string, line_pos, string_pos) returns (boolean) recursive;      dcl line       fixed array; /* line of input to be searched */      dcl string     fixed array; /* pattern or string to search for */      dcl line_pos   fixed; /* starting byte position in the line */      dcl string_pos fixed; /* starting byte position in the string */      dcl linchar    fixed; /* character in the line of input */      dcl strchar    fixed; /* character in the pattern to be matched */      dcl found      boolean; /* TRUE if pattern found; FALSE if not found */      dcl (i, j)     fixed; /* byte counters */      dcl match_length fixed external; /* length of the match in bytes (MUST be here - RECURSIVE proc!) */      dcl match_count  fixed external; /* count of number of matches performed */      found = false;      match_count = match_count + 1; /* keep track of the number of matches performed */      linchar = byte(line, line_pos); /* get the starting byte position in the line */      strchar = byte(string, string_pos); /* get the starting byte position in the string */      if strchar = any_single /* if the leading character is a ? */      then strchar = linchar; /* then peel it off */      i = line_pos + 1; /* initialize the line charcter pointer */      j = string_pos + 1; /* initialize the pattern character pointer */      do while ((linchar = strchar) and (strchar <> any_group)      and (i < line (0)) and (j < string (0))); /* see if there is a match */         linchar = byte(line, i); /* get next character in the line */         strchar = byte(string, j); /* get next character in string */         do while ((strchar = any_single) and (i < line (0) - 1) and (j < string (0) - 1)); /* skip over question marks */            i = i + 1;            j = j + 1;            linchar = byte(line, i); /* get next character in the line */            strchar = byte(string, j); /* get next character in string */         end;         i = i + 1;         j = j + 1;      end; /* of matching  */      if strchar = any_group then do; /* if the string character is '*' */         if j = string (0) then do; /* if at the end of the pattern to be matched */            found = true; /* then there is a match */            match_length = line (0); /* the ending point of the match is the length of the line, here. */         end;         else if find_pattern (line, string, i - 1, j) <> -1 then do; /* otherwise, see if the rest of the pattern matches */            found = true; /* find the last possible ending point of the match */            do while (find_pattern (line, string, i, j) <> -1);              i = i + 1;            end;         end; /* of matching rest of pattern */      end; /* of string character is any group */      else do; /* string character isn't any group */         if ((linchar = strchar) or (strchar = any_single)) then do; /* if the trailing characters match or the string character is any single wild character */            found = true; /* assume that there is a match until proven otherwise */            if j <> string (0) then do; /* if not at the end of the search string */               if ((j <> string (0) - 1) or (byte(string, j) <> any_group)) /* if the trailing character is not any wild character */               then found = false; /* then there is not a match */            end;         end;         if found then match_length = i; /* the ending point of the match is the last line character position of the match */      end;      return (found);   end match;   /* $subtitle Find_Pattern */   /* This procedure finds a pattern in a line of input given the line of   .  input and the string pattern starting positions (indexes). */   find_pattern: proc(line, string, line_pos, string_pos) returns (fixed) recursive;      dcl line       fixed array; /* line of input to be searched */      dcl string     fixed array; /* pattern or string to search for */      dcl line_pos   fixed; /* starting byte position in the line */      dcl string_pos fixed; /* starting byte position in the string */      dcl found      boolean; /* TRUE if pattern found; FALSE if not found */      dcl match_length fixed external; /* length of the match in bytes (MUST be here - RECURSIVE proc!) */      dcl match_count  fixed external; /* count of number of matches performed */      found = false;      if line (0) = line_pos then do; /* if we are at the end of the line */         if ((string (0) = string_pos) /* if we are also at the end of the search string */         or ((string (0) = string_pos + 1) and (byte(string, string_pos) = any_group))) then do;            found = true; /* then we have a match! */            line_pos = line_pos + 1; /* compensate for decrement before return */            match_length = 0; /* the length of the match is zero */            match_count = match_count + 1; /* increase the number of matches performed */         end; /* if only one string is null, no match */      end;      else if string (0) <> string_pos /* if we are not at the end of the search string */      then do while ((line_pos < line (0)) and (not found)); /* scan for a match */         found = match (line, string, line_pos, string_pos);         line_pos = line_pos + 1;      end;      if found /* did we find it? */      then return (line_pos - 1); /* return where we found it */      else return (-1); /* no match */   end find_pattern;   /* $subtitle Prescan */   /* This procedure scans a string for wild cards.  If it encounters an   .  escape delimiter, it erases it from the string and ignores the next   .  character.  If the procedure finds a wild card character that is not   .  preceded by an escape delimiter, it substitutes a meta character for   .  a single or a group of zero or more occurrences.  If any wildcards   .  are found, a boolean TRUE is returned. */   prescan: proc(string) returns (boolean) public;      dcl string   fixed array; /* pattern or string to scan */      dcl strchar  fixed; /* character in the pattern to be matched */      dcl wildcard fixed; /* TRUE if any wildcards are found */      dcl (i, j)   fixed; /* byte counters */         delete_char: proc(string, string_pos);         dcl string     fixed array; /* a string of characters */         dcl string_pos fixed; /* starting byte position in the string */                  string (0) = string (0) - 1; /* decrement string byte count */         do while (string_pos < string (0)); /* shuffle up chars after delete point */            call pbyte(string, string_pos, byte(string, string_pos + 1)); /* shift the remainder of the string over by one */            string_pos = string_pos + 1;         end;      end delete_char;      wildcard = false; /* no wildcard found yet */      i = 0; /* prescan search string for wild cards and escape characters */      do while (i < string (0)); /* scan until end of search string */         strchar = byte(string, i);         if strchar = eschr /* if the character is the escape character '/' */         then call delete_char (string, i); /* get rid of the escape delimiter */         else if strchar = single then do; /* if a question mark and not preceeded by an escape character */            call pbyte(string, i, any_single); /* then substitute internal representation */            wildcard = true; /* and remember a wildcard was found */         end;         else if strchar = group then do; /* if zero or more occurrences of any group */            call pbyte(string, i, any_group); /* substitute the meta character as an internal representation */            wildcard = true; /* and remember a wildcard was found */            i = i + 1; /* peek ahead */            do while ((i < string (0)) and (byte(string, i) = group)); /* delete the rest of the multiple group characters */               call delete_char (string, i);               i = i + 1;            end;            if byte(string, i) = group /* if the very last character represents zero or more occurrences */            then call delete_char (string, i); /* delete that too */            else i = i - 1; /* otherwise, compensate for peeking ahead */         end;         i = i + 1;      end;      return (wildcard); /* return whether a wildcard was found */   end prescan;      /* $subtitle Search and Index */   /* This procedure searches for a pattern in a line of input.  If there   .  is a match, it returns the starting position of the match.  Otherwise,    .  it returns a value of -1.  This procedure also calculates the length   .  of the match.  If there is no match, the length is zero. */   search: proc(line, string) fixed public;      dcl line        fixed array; /* line of input to be searched */      dcl string      fixed array; /* pattern or string to search for */      dcl match_start fixed; /* the starting position of the match */      match_length = 0;      match_start = find_pattern (line, string, 0, 0); /* get the starting position of the match */      if match_start <> -1 /* if there is a match */      then match_length = match_length - match_start; /* calculate length of match */      else match_length = 0; /* otherwise, set match length to zero */      return (match_start);   end search;   end in_search_of;eof   /* This procedure searches for a pattern in a line given an index.    .  If there is a match, it returns the starting position of the match.   .  Otherwise, it returns a value of -1.  This procedure also calculates   .  the length of the match.  If there is no match, the length is zero. */   index:  proc(line, string, line_pos) fixed public;      dcl line        fixed array; /* line of input to be searched */      dcl string      fixed array; /* pattern or string to search for */      dcl line_pos    fixed; /* starting byte position in the line */      dcl match_start fixed; /* the starting position of the match */      match_length = 0;      match_start = find_pattern (line, string, line_pos, 0); /* get the starting position of the match */      if match_start <> -1 /* if there is a match */      then match_length = match_length - match_start; /* calculate the length of the match */      else match_length = 0; /* otherwise, set the length to zero */      return (match_start);   end index;end in_search_of;