/* COPY  $TITLE Copy Routines */module copy_routines;configuration modelC, MULDIV;insert ':-xpl:literals'; 	/* general literals */insert ':-xpl:asciilit'; 	/* ASCII literals */insert ':-xpl:termutil'; 	/* terminal utilities */insert ':-xpl:tapebrdg'; 	/* tape drive device drivers */insert ':-xpl:catrtns'; 	/* catalog routines */insert ':-xpl:devutil'; 	/* device utilities */insert ':-xpl:catutil'; 	/* catalog utilities */insert ':-xpl:strings'; 	/* string processing */insert ':-xpl:plotlib'; 	/* plotting library */insert ':-xpl:intrprtr';insert ':utilcat:literals'; /* get utilcat literals */insert ':utilcat:tapeform'; /* tape formatting and catalog handlers */dcl entry_max literally 'c#dir_max/c#len'; /* maximum catalog entries */library ':utilcat:libs:format'; /* format routines */dcl format proc(fixed, fixed array) returns(fixed) external; /* format device */dcl formflag  boolean external; /* TRUE if format destination before copying */dcl eraseflag boolean external; /* TRUE if erase destination before copying */dcl alphaflag boolean external; /* TRUE if copy over alphabetically */dcl pickflag  boolean external; /* TRUE if the user wants to PICK which files to copy */dcl moveflag  boolean external; /* TRUE if move files from source to dest (erase copied files from source) */dcl delflag   boolean external; /* TRUE if delete files from source (e.g. no copy) */dcl cache1 (c#dir_max - 1) fixed; /* source catalog cache */dcl cache2 (c#dir_max - 1) fixed; /* destination catalog cache */dcl nam (f#name_len)       fixed; /* file name to print out during transfer */dcl blk (f#len - 1)        fixed; /* array to hold fcb from catalog */dcl sour                   fixed; /* source */dcl dest                   fixed; /* destination */dcl scache                 fixed; /* source catalog cache number */dcl dcache                 fixed; /* destination catalog cache number */dcl sour.fcb               fixed; /* max # of files in source catalog */dcl ms.dest.size           fixed; /* MSB of destination disk size (in sectors) */dcl ls.dest.size           fixed; /* LSB of destination disk size (in sectors) */dcl ms.start               fixed; /* MSB of starting sector of catalog to copy */dcl ls.start               fixed; /* LSB of starting sector of catalog to copy */dcl file.count             fixed; /* number of files transferred */dcl fullflag               boolean; /* TRUE if the destination is full (and cannot change destination media) */dcl dir_full               boolean; /* TRUE if the directory is full, false if no more storage space */dcl need.to.copy (entry_max - 1) fixed; /* set TRUE if the corresponding FCB needs to be copied *//* special codes for NEED.TO.COPY */dcl copy.file      lit '"001"'; /* file needs to be copied (= TRUE) */dcl file.too.big   lit '"002"'; /* file is bigger than destination disk */dcl dump.file      lit '"004"'; /* if set, dump the file; else reload it */dcl multidisk      lit '"010"'; /* file involves a multidisk copy */dcl file.copied    lit '"020"'; /* file has been copied (and hence should be on screen) */dcl multidisk.load lit '(multidisk or copy.file)'; /* file needs to be reconstructed from many disks */dcl multidisk.dump lit '(multidisk or dump.file or copy.file)'; /* file is needs to split up and spread over many disks *//* $subtitle System routines:  Handle Catalog Caches */min: proc (a, b) returns (fixed) public; /* unsigned minimum function */   dcl (a, b) fixed;   if a ilt b then return a;   else            return b;end min;read.cache: proc (source); /* read the specified catalog (cached or otherwise) */   dcl source fixed; /* TRUE if we're reading the source */   if source /* reading the source? */   then do; /* yes, set up for the source read */      call disable_cache (dcache);      call read_catalog ('', sour);      call enable_cache (dcache);   end;   else do; /* no, set up for dest read */      if (dest <> (-256)) then do;         call disable_cache (scache);         call read_catalog ('', dest);         call enable_cache (scache);      end;   end;          end read.cache;write.cache: proc (source); /* write the specified catalog (cached or otherwise - READ.CACHE must be called first) */   dcl source fixed; /* TRUE if we're writing the source */   if source /* writing the source? */   then do;  /* yes, set up for a source write */      call disable_cache (dcache);      call write_catalog; /* write catalog buffer to source */      call enable_cache (dcache);   end;   else do;  /* no, set up for a destination write */      if (dest <> (-256)) then do;         call disable_cache (scache);         call write_catalog; /* write catalog buffer to destination */         call enable_cache (scache);      end;   end;end write.cache;dcl get.disk proc (fixed array);setup.caches: proc (source_also); /* set up cached catalogs */   dcl source_also   boolean; /* TRUE if we want to set up the source cache as well */   if (dest <> (-256)) then do;  /* if not just deleting... */      call disable_cache (dcache);      call get.disk ('DESTINATION'); /* prompt user for destination disk */      call trigger_motor (dest); /* get motor going */      call read.cache (false); /* read destination catalog */      dcache = cache (addr(cache2 (0)), 0); /* store destination catalog in cache */   end;   if source_also then do; /* read in source if necessary */      call disable_cache (scache);      call get.disk ('SOURCE'); /* prompt user for source disk */      call trigger_motor (sour); /* get motor going */      call read.cache (true); /* read source catalog */      if alphaflag or delflag then call sort_catalog;      scache = cache (addr(cache1 (0)), 0); /* store source catalog in cache */      ms.start = c#ms_sector;      ls.start = c#ls_sector;      sour.fcb = c#dir_size/c#len; /* number of files in the source catalog */     end; /* of reading in source */end setup.caches;write.out.caches: proc; /* restore cached catalogs - assumes destination disk is already in drive */   if (dest <> (-256)) then do;      call trigger_motor (dest);      call flush_cache (dcache); /* write the cache to the destination catalog */   end;end write.out.caches;/* $subtitle User Interface:  Utility routines */print.menu: proc; /* print the copy menu */   dcl blk (f#len - 1) fixed; /* local FCB (so doesn't interfere with any calling routines) */   dcl nam (f#name_len) fixed; /* local NAME of file (so doesn't interfere with any calling routines) */   dcl (i, j, k)       fixed;   clear_screen;   if      delflag  then pstring ('Deleting from: ');   else if moveflag then pstring ('Moving from: ');   else                  pstring ('Copying from: ');   call name (sour); pos (0, 38); pstring ('|  ');   if      delflag  then pstring ('Delet');   else if moveflag then pstring ('Mov');   else                  pstring ('Copy');    pstringr ('ing file:');   if    delflag  then pstringr ('');   else do;      if moveflag then pstring ('Moving to:   ');      else             pstring ('Copying to:   ');      call name (dest); pos (1, 38); pstringr ('|  Total disks:');   end;   pstringr ('');   pstring  ('Files ');    if      moveflag then pstring ('mov');    else if delflag  then pstring ('delet');   else                  pstring ('copi');   pstring ('ed:');   if file.count <> 0 then do; /* output names of files copied */      j = 0;      call read.cache (true); /* read the source catalog */      do i = 0 to file.count - 1; /* output every name */         do while (need.to.copy (j) <> file.copied); j = j + 1; end; /* look for the next one */         pos ((i/8) + 5, (i mod 8)*10 + 1); /* put cursor back to correct spot */         call get_fcb (j, blk); j = j + 1; /* get the correct FCB */         call clean_fcbname (blk, nam); nam (0) = shl(f#name_len,1); /* extract filename from FCB */         pstring (nam); /* print out file name */      end;   end;   pos (21, 0); pstringr ('');   flush_term; /* wait for terminal output buffer */end print.menu;load.tape: proc (dev) returns (boolean); /* load tape drive DEV */   dcl dev  fixed; /* the device to load */   call load (dev); /* load the tape */   call check_tape; /* check the status */   if ((dev = dest) and ((tape_status and write_protect) <> 0)) /* are we loading the dest and is it write protected? */   then do; /* yes, this is a no-no */      pcmd ('This tape is write-protected and hence cannot be copied to.'); crlf;      call unload (dev, true); /* unload the tape, wait for tape to unload */      return (false);   end;   return (true); /* we loaded the tape successfully */end load.tape;get.disk: proc (msg); /* ask for a different disk (one disk copy only) */   dcl msg           fixed array; /* message modifier in string format */   dcl disk_inserted boolean; /* TRUE when a new disk is inserted */   disk_inserted = (sour <> dest); /* if two disk copy, they don't need to insert any disks */   do while (not disk_inserted); /* loop until they insert a disk */      pcmd ('Please insert '); pstring (msg);      pstring (' disk into '); call name (sour);      pstring (' and press RETURN ->');      if rchar = a.refresh /* wait for RETURN/check for refresh */      then call print.menu; /* print out copy menu again */      else do;         erase_command; flush_term;         disk_inserted = disk_check (sour); /* make sure they really put it in */      end;   end;end get.disk;/* $subtitle User Interface:  Select Files To Copy */select_files: proc returns (boolean); /* select files to copy from source catalog */   dcl xref (entry_max - 1)        fixed; /* cross reference printed names to their corresponding FCBs */   dcl file.status (entry_max - 1) fixed; /* cross reference FCBs to the order to copy */   dcl ordered (entry_max - 1)     fixed; /* cross reference ordered files to their FCBs */   dcl blk2 (f#len - 1)            fixed; /* local FCB for selecting file order */   dcl (cur.x, cur.y)              fixed; /* current position on menu */   dcl (i, j, k, m, n)             fixed;   dcl input_length lit '24'; /* maximum length of input string */   dcl ibuf (input_length) fixed; /* user input buffer */   print.name: proc (blk, n); /* print filename */      dcl blk              fixed array; /* FCB of file whose name we want printed */      dcl n                fixed; /* number of this file on screen */      dcl nam (f#name_len) fixed; /* place to store the name */      call clean_fcbname (blk, nam); /* extract filename from FCB */      nam (0) = shl(f#name_len, 1); /* set length to use whole name */      pstring (nam); /* print out the name */      if (n mod 8) = 0 then crlf; /* be neat (can fit eight names across) */      else                  pstring (' ');   end print.name;   print_header: proc; /* print selection menu header */      clear_screen;      if (terminal.graphics <> 0) then clear;      if      delflag  then pstring ('Deleting from:  ');      else if moveflag then pstring ('Moving from:  ');      else                  pstring ('Copying from:  ');      call name (sour); crlf;      if    delflag then pstringr ('');      else do;         if moveflag then pstring ('Moving to:    ');         else             pstring ('Copying to:    ');         call name (dest); crlf;      end;      if (terminal.graphics <> 0) then do;         vector_mode;         iconnect(gposx(0), gposy(100), gposx(7800), gposy(100));         iconnect(gposx(0), gposy(200), gposx(7800), gposy(200));         transparent_mode;      end;      pos (2, 0);      pstring(  '1 = select all sound files;  2 = select all sequences;  3 = select all patches');      pos (3, 0);      pstringr ('SELECT option:  Use cursor keys to move over files.  Press space bar to select');      if delflag then do;         pstringr ('or deselect a file to delete.  Press R to review order.  Press RETURN to');         pstringr ('initiate delete.  Press Q to abort.  Selected files are marked with a >.');      end;      else if moveflag then do;         pstringr ('or deselect a file to move.  Press R to review copying order.  Press RETURN to');         pstringr ('initiate move.  Press Q to abort move.  Selected files are marked with a >.');      end;      else do;         pstringr ('or deselect a file to copy.  Press R to review copying order.  Press RETURN to');         pstringr ('initiate copy.  Press Q to abort copy.  Selected files are marked with a >.');      end;   end print_header;   call print_header;   call read.cache (true); /* read in the source catalog */   n = 0;   do i = 0 to sour.fcb - 1; /* no files have been selected yet */      if need.to.copy (i) then do; /* make sure this is a file (this was set for all files before we were called) */         need.to.copy (i) = (need.to.copy (i) xor copy.file); /* we don't want to copy this yet */         n = n + 1; /* count the names */      end;      file.status (i) = -1; /* don't copy any files */   end;   if n <> 0 then do; /* there are files to copy - let user edit list */      /* note: n takes on a different meaning after R is processed... */      k = 0; /* haven't selected any files yet */      i = a.r; /* force ourselves to print the filenames */      do while ((i <> a.cr) and (i <> a.q) and (i <> l.q) and (i <> a.nul)); /* wait for a RETURN or Q for quit */         if i = a.refresh then do; /* refresh screen */            call print_header; /* print menu header */            i = a.r; /* and force a review of the filenames */         end;         if (i = a.1 or i = a.2 or i = a.3) then do;            dcl (new.x, new.y, z) fixed;            new.x = 0; new.y = 0;            do z = 0 to n;                 /* loop over shown files  */               j = xref (new.y*8 + new.x); /* pick up the FCB number of the selected file */               call get_fcb (j, blk); /* get the fcb */               if  ((blk (f#nm) <> 0)               and  (((i = a.1) and (blk (f#ty) = t#sound ))               or    ((i = a.2) and (blk (f#ty) = t#sync  ))               or    ((i = a.3) and (blk (f#ty) = t#timbre)))               and  (file.status (j) = -1))               then do; /* select this file */                  dcl z1 fixed;                  pos (7 + new.y, new.x * 10);                  need.to.copy (j) = (need.to.copy (j) or copy.file);                  pstring ('>'); /* mark that we're copying it */                  file.status (j) = k; /* select it */                  ordered (k) = j; /* remember it */                  k = k + 1; /* we've just selected another file */                  do z1 = 0 to 20; write(3) = 0; end;               end;               new.x = new.x + 1;               if (new.x = 8) then do;                   new.x = 0; new.y = new.y + 1;               end;            end;            pos (7 + cur.y, cur.x*10);         end;         else if i = a.sp then do; /* space - toggle selection */            j = xref (cur.y*8 + cur.x); /* pick up the FCB number of the selected file */            need.to.copy (j) = (need.to.copy (j) xor copy.file);            if file.status (j) = -1 then do; /* selected a file */               pstring ('>'); /* mark that we're copying it */               file.status (j) = k; /* select it */               ordered (k) = j; /* remember it */               k = k + 1; /* we've just selected another file */            end;            else do; /* deselected it */               pstring ('|'); /* mark that we're NOT copying it */               k = k - 1; /* we now have one less file selected */               do m = file.status (j) + 1 to k; /* remove it from the list */                  ordered (m - 1) = ordered (m); /* remove by shifting everything past it down */                  file.status (ordered (m)) = file.status (ordered (m)) - 1; /* and update FCB pointers */               end;               file.status (j) = -1; /* deselect it */            end;            i = cur.right; /* automatically move right */         end;         if ((i = cur.up) or (i = a.vt)) then do; /* cursor up */            if cur.y > 0 /* if we can, move up */            then cur.y = cur.y - 1;         end;         else if ((i = cur.down) or (i = a.lf)) then do; /* cursor down */            if ((cur.y < n/8 - 1) or ((cur.y = n/8 - 1) and (cur.x <= n mod 8))) /* if we can, move down */            then cur.y = cur.y + 1;         end;         else if ((i = cur.right) or (i = a.ff)) then do; /* cursor right */            if (((cur.y < n/8) and (cur.x < 8 - 1)) or ((cur.y = n/8) and (cur.x < n mod 8))) /* if we can, move right */            then cur.x = cur.x + 1;            else if cur.y < n/8 then do; /* wrap to next line if we can */               cur.x = 0; /* wrap to beginning if line */               cur.y = cur.y + 1; /* move to next line */            end;         end;         else if ((i = cur.left) or (i = a.bs)) then do; /* cursor left */            if cur.x > 0 /* if we can, move left */            then cur.x = cur.x - 1;            else if cur.y > 0 then do; /* wrap to previous line if we can */               cur.x = 7; /* move to the end of the line */               cur.y = cur.y - 1; /* move to previous line */            end;         end;         else if ((i = cur.home) or (i = c.r) or (i = c.y) or (i = a.rs) or (i = pf.1)) then do; /* home */            cur.x = 0;  cur.y = 0;         end;         /* handle R type, plus always entered here first time thru: */         else if ((i = a.r) or (i = l.r)) then do; /* review order */            pos (7, 0); n = 0; /* move to top of display */            do j = 0 to k - 1; /* print out the selected files */               call get_fcb (ordered (j), blk); /* get the fcb */               if blk (f#nm) <> 0 then do; /* valid filename */                  xref (n) = ordered (j); n = n + 1; /* remember what entry this name was */                  pstring ('>'); call print.name (blk, n); /* and print the name */               end;            end; /* of loop over fcb's */            do j = 0 to sour.fcb - 1; /* print out the unselected files */               call get_fcb (j, blk); /* get the fcb */               if ((file.status (j) = -1) and (blk (f#nm) <> 0)) then do; /* valid filename */                  xref (n) = j; n = n + 1; /* remember what entry this name was */                  pstring ('|'); call print.name (blk, n); /* and print the name */               end;            end; /* of loop over fcb's */            cur.x = 0; cur.y = 0; /* we're pointing to the first entry */            n = n - 1; /* move the number of names's base to zero */            clear_typeahead; /* clear any typeahead */         end;         pos (7 + cur.y, cur.x*10);         i = rchar;                 /* move to the proper position and get next character */      end; /* of wait for return or Q */      do j = 0 to sour.fcb - 1; /* fix up NEED.TO.COPY */         if (not need.to.copy (j)) then need.to.copy (j) = false; /* get rid of flags for files not chosen */         else if (need.to.copy (j) and file.too.big) <> 0          then need.to.copy (j) = file.too.big; /* make sure we don't try to copy files that are too big */      end;   end; /* of let user edit list *//* $page */   /* confirm file deletion here in detail: */   if ((n <> 0) and (delflag) and (i = a.cr)) then do;      pos(23, 0); erase_line;      pos(23, 0);      get_string ('Enter ''OK'' followed by RETURN to delete the selected files  ->', false, ibuf, 2);      if compare (ibuf, 'OK') then i = a.cr;      else                         i = a.q;   end;   do j = 3 to 23; pos (j, 0); erase_line; end; /* clean up the screen */   if n = 0 then do; /* no files to copy */      pos (5, 0);      if      delflag  then pstring ('*** No files to delete.');      else if moveflag then pstring ('*** No files to move.');      else                  pstring ('*** No files to copy.');   end;   if i <> a.cr /* did we exit with a return? */   then return (true); /* no, abort the copy */   do i = 0 to sour.fcb - 1; /* set up to sort the catalog by the selected order */      file.status (i) = i; /* no FCBs have been moved yet */   end;   do i = 0 to k - 1; /* sort the catalog in the selected order */      call get_fcb (file.status (ordered (i)), blk); /* get first block */      call get_fcb (i, blk2); /* and second */      call put_fcb (file.status (ordered (i)), blk2); /* write second over first */      call put_fcb (i, blk); /* and first over second to complete the swap */      j = need.to.copy (i); /* make sure we move copy flags with it */      need.to.copy (i) = need.to.copy (file.status (ordered (i)));      need.to.copy (file.status (ordered (i))) = j;      j = 0;      do while (file.status (j) <> i); /* look for the FCB # of the Ith FCB */         j = j + 1; /* look at next entry */      end;      file.status (j) = file.status (ordered (i)); /* swap FCB pointers */      file.status (ordered (i)) = i;   end;   call write.cache (true); /* update the cache */   return (false); /* don't abort the copy */end select_files; /* $subtitle User Interface:  Format the Destination & Erase the Destination */format.destination: proc (buffer, buffer_size) returns (boolean); /* format the destination media */   dcl buffer      fixed array; /* the format buffer */   dcl buffer_size fixed; /* size of buffer */   dcl formatted   boolean; /* TRUE if we successfully formatted the media */   dcl loaded      boolean; /* TRUE if we successfully loaded a cartridge tape */   dcl i           fixed;   formatted = false; /* assume we can't (or don't) format the media */   if dest = 1 /* don't allow them to format the current catalog */   then formflag = false;   if delflag   then formflag = false;   if formflag then do; /* format the media */      if ((buffer_size ILT (min.buf.secs*256)) and (dest < 6)) then do; /* not enough memory to do formatting */         pcmd ('Not enough memory available to perform format operation.'); crlf;         pstring ('Press RETURN to continue ->'); i = rchar;         erase_command; pos (cmdline + 1, 0); erase_line;      end;      else do;         call get.disk ('DESTINATION'); /* prompt user for correct disk */         if tape (dest) /* tape drive? */         then loaded = load.tape (dest); /* yes, load the destination */         else loaded = true; /* no need to load a disk */         if loaded then do; /* continue with the format ONLY if we successfully loaded a tape */            if format (dest, location(addr(buffer (0)))) then do;               formatted = true;               wait (800);            end;            else do;               pcmd ('Press RETURN to continue ->');               clear_typeahead; i = rchar;            end;         end;      end;   end;   return (formatted);end format.destination;erase.destination: proc; /* erase the destination catalog */   dcl ibuf (2) fixed; /* input buffer */   dcl level    fixed; /* preserve trashed cache level here */   if delflag then return;   if ((not formflag) and eraseflag) then do; /* should we erase the destination catalog? */      if ((winchester (dest)) and (((dest <> 1) or (core(loc.ccnm) = 0)) and ((dest <> -1) or (a#name(0) = 0)))) then do; /* top level winchester catalog? */         clear_screen; pos (5, 0);         pstringr ('WARNING:  You have elected to ERASE your Winchester disk.  This will');         pstringr ('destroy all files that are saved on it.');         crlf;         pstringr ('Note:  ALL files saved on your Winchester disk are about to be destroyed.');         crlf;         pstringr ('Type ''OK'' if you want to ERASE your Winchester disk (typing anything');         get_string ('else will cancel the ERASE option) --> ', 0, ibuf, 2);         do level = 5 to 11; /* be neat */            pos (level, 0); erase_line;         end;         if not compare (ibuf, 'OK') then return; /* skip it */      end;      call disable_cache (scache); /* make sure we only access the destination (in case SOUR = DEST) */      call erase_catalog (dest); /* erase the desination */      call enable_cache (scache); /* get the source cached catalog back */   end;end erase.destination;/* $subtitle User Interface:  Request Another Disk/Tape */get.new.dest: proc returns (boolean); /* asks user for a new destination disk */   dcl cur.y    fixed; /* current (relative) Y position on menu */   dcl bottom   fixed; /* CUR.Y at bottom of screen */   dcl new.disk boolean; /* TRUE if we get a new disk */   dcl i        fixed;   print.options: proc; /* print out new destination options */      pos (1, 56);      if moveflag then do; /* MOVE */         if formflag then pstring ('Format and Move');         else             pstring ('Move');      end; /* of MOVE */      else do; /* COPY */         if formflag then pstring ('Format and Copy');         else             pstring ('Copy');      end; /* of COPY */      erase_line;      pos (2, 56); if eraseflag then pstring ('Yes'); else pstring ('No'); erase_line;      bottom = 1;   end print.options;   display_menu: proc; /* display special menu */      pos (1, 38); pstring ('|  Mode:'); erase_line;      pos (2, 38); pstring ('|  Erase:'); erase_line;      pos (3, 38 + 1); pstring ('');      call print.options; /* output options */      pcmd    ('Insert the next disk/tape into '); call name (dest); pstringr ('.  Then verify selected');      pstring ('modes.  Change modes with space bar.  Press RETURN to continue or Q to quit.');   end display_menu;   new.disk = false; /* no new disk yet */   if delflag                  /* if deleting, have no business prompting */   then return (new.disk);     /* for a new disk/tape...                  */   if ((dest = 2) or (dest = 3) or (dest = 4) or (dest = 5) or tape (dest)) /* if floppy or tape */   or ((systyp = 0) and (dest = 0)) or ((curtyp = 0) and (dest = 1)) then do; /* ask user for second floppy or tape */      if tape (dest) then call unload (dest, true); /* unload the previous tape */      erase_command;      i = a.refresh; /* enter loop */      do while (i = a.refresh); /* watch out for Mac refreshes */         if dir_full /* the directory is full, as opposed to no storage available */         then pcmd ('The destination directory is full.  You may continue with a new disk/tape.');         else pcmd ('The destination is now full.  You may elect to continue with a new disk/tape.');         crlf;         pstring ('Type Q to quit or press RETURN to continue copying with a new disk/tape ->');         clear_typeahead; i = rchar; /* get response */         if i = a.refresh then call print.menu; /* draw screen */      end;      erase_command; pos (cmdline + 1, 0); erase_line; /* clear message */      if ((i <> a.q) and (i <> l.q) and (i <> a.nul)) then do; /* if we aren't quitting */         new.disk = true; /* we got a new disk */         call display_menu; /* display new menu */         i = 0; cur.y = 0; clear_typeahead;         do while ((i <> a.cr) and new.disk); /* loop until they input a CR or Q */            pos (1 + cur.y, 56); i = rchar; /* get next character */            if i = a.refresh then do; /* refresh screen? */               call print.menu; /* put up copy menu */               call display_menu; /* add our special menu */            end;            else if i = a.sp then do; /* change specified mode */               do case (cur.y); /* branch on current position */                  formflag = (formflag xor 1); /* case 0: change format mode */                  eraseflag = (eraseflag xor 1); /* case 1: change erase mode */               end;               call print.options; /* output new options */            end; /* of change specified mode */            else if ((i = cur.up) or (i = a.vt)) then do; /* cursor up */               if cur.y > 0 then cur.y = cur.y - 1; /* move up if we can */            end;            else if ((i = cur.down) or (i = a.lf)) then do; /* cursor down */               if cur.y < bottom then cur.y = cur.y + 1; /* move down if we can */            end;            else if ((i = a.q) or (i = l.q) or (i = a.nul)) then new.disk = false; /* quit */         end; /* of loop until we get a CR */         erase_command; pos (cmdline + 1, 0); erase_line;         if i = a.cr then do; /* check for floppy disk before proceeding */            i = disk_check (dest); /* see if there's a floppy in the destination */            do while ((not i) or ((i and d#protect) <> 0)); /* get a floppy disk in the destination */               pos (cmdline, 0); /* move to command line */               if (i and d#protect) <> 0 /* make sure it isn't write-protected */               then do; pstring ('The floppy disk in '); call name (dest); pstringr (' is write-protected.'); end;               pstring ('Please insert the next floppy disk into '); call name (dest);               pstring (' and press RETURN ->'); call rchar;            end; /* of getting a floppy disk in the destination */            erase_command; crlf; erase_line; /* be neat */         end; /* of CR */         if ((not formflag) or (not new.disk)) then do; /* if we didn't format, fix up the menu */            pos (1, 38); pstring ('|  Total disks:'); erase_line;            pos (2, 38); pstring ('');            pos (3, 38); erase_line; pos (4, 38); erase_line; flush_term;         end;      end; /* of if not quitting */   end; /* of if floppy or tape */   else fullflag = true; /* means a winchester destination - must be full */   return (new.disk); /* return true if user supplied new disk */end get.new.dest;/* $subtitle Copy routines:  Copy a Source Disk/Tape To a Destination Disk/Tape */dcl files_skipped fixed;	/* set by transfer if files skipped due to disk errors */perform.copy: proc (buf, max.buf.size) returns (boolean); /* copies files from one place to another */   dcl buf           fixed array; /* transfer buffer */   dcl max.buf.size  fixed; /* size of BUF */   dcl index         fixed; /* FCB index counter */   dcl abort.copy    boolean; /* TRUE if the user wishes to abort the copy operation */   dcl i             fixed;	dcl read_error    fixed;	dcl write_error   fixed;	insert ':-xpl:whendisk';	 	/* disk IO error routines */   insert ':utilcat:transfer'; 	/* get file transfer routines */   abort.copy    = false; 				/* don't abort the copy yet */	read_error    = false;	write_error   = false;   index = 0; /* initialize FCB index counter */   do while ((index < sour.fcb) and (not need.to.copy (index))); /* find first file to copy */      index = index + 1;   end;   if      delflag  then pcmd ('Press any key to quit deleting.');   else if moveflag then pcmd ('Press any key to quit moving.');   else                  pcmd ('Press any key to quit copying.');   erase_line; flush_term;   do while ((index < sour.fcb) and (not abort.copy)); /* we ALWAYS need.to.copy in this loop */      call read.cache (true);      call get_fcb (index, blk); /* get fcb */      call clean_fcbname (blk, nam); /* extract filename from FCB */      if delflag then do;								/* for deleting, just show the name.  that was		*/																/* easy															*/         do i = 0 to 10; write(3) = 0; end;         pos ((file.count/8) + 5, (file.count mod 8) * 10 + 1); /* put cursor back to correct spot */         pstring (nam); /* print out file name */         need.to.copy (index) = file.copied;         file.count = file.count + 1;      end;      else if transfer (blk, buf, max.buf.size) then do; /* transfer the file (WARNING: TRANSFER trashes both BLK and BUF) */         if not tape (dest) /* if this isn't a tape */         then call flush_cache (dcache); /* write cache to destination catalog */         pos ((file.count/8) + 5, (file.count mod 8) * 10 + 1); /* put cursor back to correct spot */         pstring (nam); /* print out file name */         file.count = file.count + 1;      end; /* of if file not too big */      if ((not term_idle) and (not abort.copy)) then do; /* see if user wants to abort copy operation */         do while (not term_idle); /* read all characters */            i = rchar; /* get next character */            if i = a.refresh then clear_typeahead; /* get out on REFRESH */         end;         if i = a.refresh /* refresh display? */         then call print.menu; /* yes, do it */         else do; /* no, see if they want out */            erase_command; /* move to and erase command line */            clear_typeahead; /* empty the typeahead buffer */            abort.copy = get_yn ('Do you want to ABORT (Y or N)? ');            erase_command;         end;      end; /* of see if user wants to abort */      if need.to.copy (index) /* if we didn't copy this file */      then do; /* look at the next file */         if alphaflag or pickflag or delflag /* sorted? */         then index = sour.fcb + 1; /* yes, stop copying here */         else index = index + 1; /* no, try to copy the next file */      end;      do while ((index < sour.fcb) and (not need.to.copy (index))); /* find next file to copy */         index = index + 1;      end;   end; /* of main do while block */   erase_command;   return (abort.copy);end perform.copy;/* $subtitle Copy routines:  Copy a Source Disk/Tape To Many Destination Disks/Tapes */copy: proc (source, destination, buf, max.buf.size) public;   dcl source       fixed; /* source device */   dcl destination  fixed; /* destination device */   dcl buf          fixed array; /* area to be used as data buffer */   dcl max.buf.size fixed; /* max size of buf in words */   dcl format.success boolean; /* true if the format succeeds */   dcl abort.copy     boolean; /* true if user wants to abort the copy operation */   dcl more.to.copy   boolean;   dcl (i, j, k, n)   fixed;   sour = source; dest = destination; /* set global source and destination */   scache = -1; /* initialize SCACHE for first copy */   dcache = -1; /* initialize DCACHE for first copy */   file.count = 0; /* no files copied yet */   fullflag = false; /* destination isn't full until proven so */   more.to.copy = true;   abort.copy = false;   if delflag then dest = -256;  /* assure no access to destination... */   format.success = format.destination (buf, max.buf.size); /* format the disk/tape if necessary */   if ((not formflag) or (format.success)) then do; /* only do this if the format succeeded */      if tape (sour) then if not load.tape (sour) then return; /* load the source tape (if there) */      if ((dest <> (-256)) and (tape (dest)) and (not formflag)) then if not load.tape (dest) then return; /* load the tape if necessary */      if ((dest <> (-256)) and (sour = dest) and ((dest < 2) or (dest >= 6))) then do; /* verify copy parameters */         pcmd ('*** FORMCOPY system error:  invalid copy operation.'); flush_term;         call exit(-1);      end;      call setup.caches (true); /* set up catalog caches */      call erase.destination; /* erase the disk/tape */      if (delflag <> true) then do;         call read.cache (false); /* read the destination catalog */         ms.dest.size = c#ms_length; /* MSB of catalog length in sectors */         if c#ls_length ilt shr(c#dir_size, 8) then ms.dest.size = ms.dest.size - 1; /* borrow */         ls.dest.size = c#ls_length - shr(c#dir_size , 8); /* LSB of catalog length in sectors */      end;      clear_screen;      call read.cache (true); /* read in the cached (and perhaps sorted) source catalog */      do i = 0 to sour.fcb - 1; /* set up move status (get source catalog!) */         call get_fcb (i, blk); /* get the next FCB */         if ((blk (f#nm) = 0) or ((blk (f#ml) = 0) and (blk (f#ll) = 0))) /* is this a file? */         then need.to.copy (i) = false; /* no, don't copy it */         else if delflag then need.to.copy (i) = copy.file; /* just do it */         else do; /* yes, assume we should copy it */            if ((blk (f#ml) igt ms.dest.size) /* will this fit on destination disk? */            or ((blk (f#ml) = ms.dest.size) and (blk (f#ll) igt ls.dest.size)))            then do; /* no, see if we can split it up */               if ((winchester (sour)) and (not winchester (dest)) and (dest <> 1) and (dest <> -1) and (not tape (dest))) /* winchester to other than winchester? */               then need.to.copy (i) = multidisk.dump; /* yes, this file needs to be split */               else need.to.copy (i) = file.too.big; /* no, this file cannot be copied */            end;            else do; /* yes, see if it spans many disks */               if ((not winchester (sour)) and winchester (dest) and (blk (f#ty) = t#dump) and (sour <> 1) and (sour <> -1) and (not tape (sour))) /* multidisk file? */               then need.to.copy (i) = multidisk.load; /* yes, flag the reload */               else need.to.copy (i) = copy.file; /* no, just copy it */            end;         end; /* of assume we should copy it */      end; /* of set move status */      if (pickflag or delflag) then abort.copy = select_files; /* let the user select the files to copy */      if not abort.copy then do;         do i = 0 to sour.fcb - 1; /* don't copy multidisk files during first pass */            if need.to.copy (i) = multidisk.load then need.to.copy (i) = (need.to.copy (i) xor copy.file);         end;         call print.menu; /* print the copy menu */      end;   end;   else abort.copy = true; /* abort the copy operation if the format failed *//* $page */	files_skipped = 0;   	do while (more.to.copy and (not abort.copy));      abort.copy = perform.copy (buf, max.buf.size); /* initiate the copy */      if (file.count = 0) /* if nothing was copied */      and (sour = dest) /* and we're doing floppy to floppy */      then call get.disk ('DESTINATION'); /* prompt user for destination disk */      call write.out.caches; /* write out the caches */      more.to.copy = false; /* assume there's nothing more to copy */      do i = 0 to sour.fcb - 1; if need.to.copy (i) then more.to.copy = true; end; /* find out if there's more to copy */      if not abort.copy then do; /* if the user hasn't asked to abort, try to copy more */         if more.to.copy then do; /* is there more to copy? */            more.to.copy = get.new.dest; /* get a new destination */            format.success = false; /* assume we can't format the disk */            do while (more.to.copy and (not format.success)); /* repeat if the format fails */               format.success = format.destination (buf, max.buf.size); /* format this disk */               format.success = (format.success or (not formflag)); /* avoid side effects */               if format.success /* can we do the copy? */               then do; /* yes, set up the catalogs */                  if ((dest <> (-256)) and (tape (dest)) and (not formflag)) then if not load.tape (dest) then return; /* load the tape if necessary */                  call setup.caches (false);                  call erase.destination; /* erase the destination */               end;               if ((formflag) or ((dest <> (-256)) and (tape (dest)))) then call print.menu; /* print menu only if we need to */               if not format.success then more.to.copy = get.new.dest; /* get a new destination */            end; /* of do while more.to.copy */         end; /* of if more.to.copy */         else do; /* no more to copy */            do i = 0 to sour.fcb - 1; /* now copy multidisk files */               if (need.to.copy (i) xor multidisk.load) = copy.file then need.to.copy (i) = (need.to.copy (i) or copy.file);               if need.to.copy (i) then more.to.copy = true; /* there's more to copy if we found some multidisk files */            end;         end; /* of no more to copy */      end; /* of not abort.copy */      		interp_run_host_250();   end; /* of main do while (more.to.copy) *//* $page */   if (tape (sour) or ((dest <> (-256)) and (tape (dest)))) then do; /* end of tape operation */      wchar (a.bel); wchar (a.bel);   end;   if file.count = 0 then do; /* no files transferred */      pos (cmdline, 0);      if fullflag then do; /* is the destination full? */         if dir_full then do; /* the directory is full */            pstring ('The directory is full on ');             call name (dest); pstringr ('.');         end;         else do; /* not enough storage is available */            pstring ('No more files will fit on ');             call name (dest); pstringr ('.');         end;      end;      else if delflag then pstring ('No files were deleted.');      else                 pstring ('No files were transferred.');   end;   else do; /* transferred some files */      if moveflag or delflag then do; /* if MOVE files from source to destination (e.g. just delete them if we didn't copy them) */         call get.disk ('SOURCE'); /* prompt user for source disk */         /* set up dest to access the actual unsorted source catalog */         /* so we can delete the source files after move or delete   */         k    = dest;         dest = sour; /* set up to use the destination cache for the source */         sour = -256; /* glom the source so GET.DISK fails in SETUP.CACHES */         call setup.caches (false); /* and put the actual (unsorted) source catalog in the destination cache */         sour = dest; /* set source back */         do i = 0 to sour.fcb - 1; /* delete all files that were copied */            if need.to.copy (i) = file.copied then do; /* if file was copied */               call read.cache (true); /* get the (possibly sorted) source catalog */               call get_fcb (i, blk); /* get the next fcb */               call clean_fcbname (blk, nam); /* extract filename from FCB */               call read.cache (false); /* get the actual source catalog */               call removefile (nam); /* delete file from source */               call write.cache (false); /* and write it back out */            end;         end; /* of delete all files that were copied */         call write.out.caches; /* write the modified source catalog back out again */         dest = k; /* reset destination */         if delflag then call strcpy (buf, 'Delete');         else            call strcpy (buf, 'Move');      end; /* of MOVE */      else call strcpy (buf, 'Copy');      if abort.copy then do; /* copy was aborted - tell them where it left off */         if      delflag  then pcmd ('The last file deleted is the last name printed above.');         else if moveflag then pcmd ('The last file moved is the last name printed above.');         else                  pcmd ('The last file copied is the last name printed above.');         crlf;			erase_line;         pstring (buf); pstring (' aborted');			if (files_skipped != 0)				{pstring('; '); pnum(files_skipped, 0); pstring (' file(s) skipped due to errors!');}			else				pstring('!');      end;      else do; /* copy wasn't aborted */         j = 0; /* initialize counter */         do i = 0 to sour.fcb - 1; if (need.to.copy (i) and file.too.big) <> 0 then j = j + 1; end;         if j <> 0 then do; /* some files are too big */            pos ((file.count - 1)/8 + 7, 0); /* move cursor to end of list */            pstringr ('The following files were too large to copy:');            call read.cache (true);            n = 0;            do i = 0 to sour.fcb - 1; /* loop on files */               if (need.to.copy (i) and file.too.big) <> 0 then do; /* print out file name */                  call get_fcb (i, blk);                  wchar (a.sp);                  do j = 0 to f#name_len - 1;                     k = blk (f#nm + j);                     if (k and 255) <= a.sp then wchar (a.sp);                     else                        wchar (k);                     k = shr(k, 8);                      if k <= a.sp then wchar (a.sp);                     else              wchar (k);                  end;                  wchar (a.sp);                  n = n + 1;                  if (n mod 7) = 0 then crlf;               end;            end; /* of files loop */            if (n mod 7) <> 0 then crlf;            crlf;         end; /* of if num.too.big then do */         pos (cmdline, 0);         if fullflag then do; /* is the destination full? */            if dir_full then do; /* the directory is full */               pstring ('The directory is full on ');                call name (dest); pstringr ('.');            end;            else do; /* not enough storage is available */               pstring ('No more files will fit on ');                call name (dest); pstringr ('.');            end;        		pstring (buf); pstring (' complete.');         end;			else			{				if (files_skipped != 0)					{pnum(files_skipped, 0); pstring (' file(s) skipped due to errors; ');}         	pstring (buf); pstring (' complete.');						}      end; /* of copy wasn't aborted */   end; /* of some files were transferred */   pstring ('  '); /* be neat */   call disable_cache (scache); call disable_cache (dcache); /* get rid of caches here */end copy;end copy_routines;