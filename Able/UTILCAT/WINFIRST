/* $title Format A SCSI Winchester For The First Time *//* This program allows you to enter the bad sector list for a SCSI Winchester   disk.  It then performs a primary format on that disk, entering the bad   sector list into the bad sector table on the drive.  It assumes the drive   is attached to D24 0 with SCSI target ID 5 and LUN 0.    By:  Kip Olson   December 1985 */configuration modelC, MULDIV;/* LIBRARIES */library ':utilcat:libs:set_term'; /* set terminal type */insert ':-xpl:literals'; 	/* get literals */insert ':-xpl:catrtns'; 	/* catalog routines/system literals */insert ':-xpl:scsi'; 		/* SCSI drivers */insert ':-xpl:termut'; 		/* terminal utilities */insert ':utilcat:winform'; 	/* formatting code *//* VARIABLES */dcl BufPtr      fixed;                          /* Buffer pointer */dcl NumEntries  fixed;                          /* No. entries in the bad sector list */dcl DevAdr      fixed;                          /* SCSI device address of winchester to format */dcl i           fixed;/* PROCEDURES *//* This procedure gets the SCSI drive parameters from the user. It is   passed the default parameters, and returns the SCSI address in a   configuration-like format */GetDrive: procedure(D24,Target,LUN) returns(fixed);   dcl D24    fixed;                       /* Default D24 number */   dcl Target fixed;                       /* Default Target number */   dcl LUN    fixed;                       /* Default Logical Unit number */   dcl done boolean;   done = false;                           /* Not done yet */   do while not done;                      /* Repeat until correct parameters are entered */      crlf;      pstringr('The Winchester to format is connected to:'); /* Show current parameters */      pstring(' D24 board:  '); unum(D24,1); crlf;      pstring(' Controller: '); unum(Target,1); crlf;      pstring(' Drive:      '); unum(LUN,1); crlf;      crlf;      if Get_YN('Are these parameters correct [Y(es) or N(o)]? ') /* Do they want to change parameters? */      then done = true;      else do;         crlf;         pstring(' Enter new D24 number: '); D24 = GetUns; CrLf; /* Get new parameters */         pstring(' Enter new Controller number: '); Target = GetUns; CrLf;         pstring(' Enter new Drive number: '); LUN = GetUns;      end;      crlf;   end;   return(shl(LUN,8) or shl(D24,4) or Target);       /* Return configuration-like SCSI device address */end GetDrive;/* The following procedure finds a slot in the buffer for the given   entry, using a binary search. MSW and LSW give the target entry number,   BUFFER and NUMENTRIES are the buffer and number of entries to search.   If the target entry is found in the buffer, then then its location is   returned as an entry number. Otherwise the entry number where the target   should be inserted is returned. */ FindSlot: procedure(MSW,LSW,Buffer,NEntries) returns (fixed);   dcl (MSW,LSW)  fixed;                  /* Target entry to search for */   dcl Buffer     fixed array;            /* Buffer containing present entries */   dcl NEntries   fixed;                  /* No. entries already in buffer */   dcl First      fixed;                  /* First entry to search */   dcl Num        fixed;                  /* No. entries to search */   dcl (i,r)      fixed;   Num = NEntries;                        /* Start by searching entire buffer */   First = 0;                             /* Element 0 is first entry */   do while Num > 0;                      /* Repeat until entire array has been searched */      i = First + (Num / 2);              /* Get midpoint */      if (Buffer(i*2) = MSW) and (Buffer(i*2 + 1) = LSW) /* Target entry already exists in buffer */      then return(i);                     /* Return target entry location */      else do;         r = MSW - Buffer(i*2);           /* Subtract value in buffer from given entry */         if LSW ilt Buffer(i*2 + 1) then r = r - 1; /* Using 32 bits, of course */         if r < 0                         /* Did above subtraction result in a negative 32-bit number? */         then Num = Num / 2;              /* Yes, then buffer entry > target entry */         else do;                         /* Otherwise buffer entry < target entry */            First = First + (Num / 2) + 1; /* Start search at new index */            Num = (Num - 1) / 2;          /* Search this many entries */         end;      end;   end;   return(First);                         /* Return entry location to insert target entry */end FindSlot;/* This procedure prompts the user for the flag track log, each entry of   which is given by a cylinder number, a head number and a byte count.   This information is converted into a logical bad sector number and stored   in the array BUFFER. The procedure returns the number of entries entered   into the buffer */EnterList: procedure(SecTrack,NumHeads,NumCyl,Buffer) returns (fixed);   dcl IndexGap    lit '0';                /* Length of index gap (bytes) */   dcl BytesSec    lit '593';              /* No. bytes per sector, including gaps and other fields */   dcl SecTrack   fixed;                   /* No. sectors per track */   dcl NumHeads   fixed;                   /* No. heads on drive */   dcl NumCyl     fixed;                   /* No. logical cylinders on drive */   dcl Buffer     fixed array;             /* Buffer to put bad sectors in */   dcl FirstByte  fixed;                   /* First usable byte on a track */   dcl LastByte   fixed;                   /* Last usable byte on a track */   dcl NumBad     fixed;                   /* Number of bad sectors entered */   dcl EntryNum   fixed;                   /* Bad sector currently being entered */   dcl InsertEntry fixed;                  /* Entry number in buffer to insert at */   dcl Cylinder   fixed;                   /* Cylinder entered */   dcl Head       fixed;                   /* Head entered */   dcl ByteCount  fixed;                   /* Byte count entered */   dcl (MSW,LSW)  fixed;                   /* Logical bad sector number */   dcl (i,j)      fixed;   clear_screen;   FirstByte = IndexGap;                   /* First usable byte on a track */   LastByte = FirstByte + SecTrack * BytesSec - 1;  /* Last usable byte on a track */   NumBad = 0;   EntryNum = 1;   Cylinder = 1;   do while Cylinder <> 0;      CrLf;      pstring('Entry '); UNum(EntryNum,1); CrLf;      pstring(' Enter cylinder: '); Cylinder = GetUns; CrLf;      if Cylinder <> 0 then do;         pstring(' Enter head: '); Head = GetUns; CrLf;         pstring(' Enter byte: '); ByteCount = GetUns; CrLf;                                            pstring(' You have entered:  Cylinder ='); UNum(Cylinder,5);         pstring('  Head ='); UNum(Head,5);         pstring('  Byte ='); UNum(ByteCount,5); CrLf;         if Get_YN(' Is this information correct [Y(es) or N(o)]? ') then do;            EntryNum = EntryNum + 1;           /* One more entry */            if ( Cylinder ile NumCyl ) and ( Head ilt NumHeads ) and /* Make sure this is a valid cylinder and head */               (ByteCount ige FirstByte) and (ByteCount ile LastByte) then do; /* and this byte is located inside a sector */               i = (Cylinder - 1) * NumHeads + Head; /* Find logical track number for the given cylinder and head */               j = (ByteCount - IndexGap) / BytesSec; /* Find the physical sector number for the given byte */               write("5") = i;                    /* Logical track */               write("4") = j;                    /* Sector on that track */               write("6") = SecTrack;             /* Multiply logical track by sectors per track and add in physical sector */               LSW = read("5");                   /* LSW of logical sector number */               MSW = read("4");                   /* MSW of logical sector number */               CrLf;               pstring(' Maps to bad sector (hex): ');               HNum(MSW,1); HNum(LSW,4);               InsertEntry = FindSlot(MSW,LSW,Buffer,NumBad); /* Find slot in buffer for this sector */               if (Buffer(InsertEntry*2) <> MSW) or /* If this bad sector is not already in buffer */                  (Buffer(InsertEntry*2 + 1) <> LSW) or                  (InsertEntry = NumBad) then do;       /* or this entry will be inserted at the end of the buffer */                  /* Make room in buffer for this new bad sector */                  call BlockMove(location(addr(Buffer(InsertEntry*2))),                                 location(addr(Buffer(InsertEntry*2 + 2))),                                 NumBad*2 - InsertEntry*2);                  /* Insert this new bad sector in buffer */                  Buffer(InsertEntry*2) = MSW;    /* Store MSW of bad sector entry */                  Buffer(InsertEntry*2 + 1) = LSW; /* Store LSW of bad sector entry */                  NumBad = NumBad + 1;            /* One more bad sector */               end;            end;                               /* if bytecount ok */         end;                                  /* if data ok */         CrLf;      end;                                     /* if cylinder ok */      if Cylinder = 0 then do;                 /* See if they really want to quit */         if not Get_YN('Have you entered ALL bad sector entries [Y(es) or N(o)]? ')         then Cylinder = 1;                    /* Kludge to make loop repeat */         CrLf;      end;   end;                                        /* while cylinder <> 0 */   return(NumBad);                             /* Return no. entries entered */end EnterList;/* This procedure first makes sure it can connect to the bus without error.   Then it does a Mode Sense command to find the number of heads on the   drive and the number of sectors per track. The procedure EnterList is   then called to have the user enter the Flag Track Log and convert it   to logical bad sectors. These bad sectors are returned in the array   BUFFER and the number of entries in the buffer are returned by the   procedure */GetBadSectors: procedure(DAdr,Buffer) returns (fixed);   dcl DAdr        fixed;                  /* Contains device parameters */   dcl Buffer      fixed array;            /* Buffer with bad sector list */   dcl SecTrack    fixed;                  /* No. sectors per track */   dcl NumHeads    fixed;                  /* No. heads on the disk */   dcl NumCyl      fixed;                  /* No. logical cylinders on disk */   dcl Stat        fixed;                  /* Status word */   dcl (i,j)       fixed;   Stat = -1;   do while (Stat <> S$Good);                 /* Loop until drive is ready */      i = BusConnect(DAdr);                   /* Connect Initiator to Target on SCSI Bus */      if i <> S$GoodConnect then do;          /* Connection failed */         if i < 0 then return(i);         else return (-i);                    /* make negative if necessary */      end;      /*** Send Test Unit Ready command ***/      write(ScsiByte) = S$TestUnitReady;      /* Operation Code */      write(ScsiByte) = shr(DAdr and "HF00",8 - 5); /* Target LUN */      write(ScsiWord) = 0;                    /* Reserved */      write(ScsiByte) = 0;                    /* Reserved */      write(ScsiByte) = 0;                    /* Control byte */      Stat = shr(read(ScsiWord) and S$StatMask, 8); /* Get Status word - only look at MSB */      if Stat = S$CheckCondition then do;     /* Status says Check Condition - see what is wrong */         i = BusConnect(DAdr);                /* Connect Initiator to Target on SCSI Bus */         if i <> S$GoodConnect then do;       /* Connection failed */            if i < 0 then return(i);            else return (-i);                 /* make negative if necessary */         end;         /*** Send Request Sense command ***/         write(ScsiByte) = S$RequestSense;    /* Command code */         write(ScsiByte) = shr(DAdr and "HF00",8 - 5); /* Logical unit number */         write(ScsiWord) = 0;                 /* Reserved */         write(ScsiByte) = 7;                 /* Get 7 extended sense bytes */         write(ScsiByte) = 0;                 /* Control byte - no link */         /*** Get Sense data ***/         i = read(ScsiWord);                  /* Throw away first 2 bytes */         j = read(ScsiByte) and "HF";         /* Get Sense Key */         i = read(ScsiWord);                  /* Throw away last 4 bytes */         i = read(ScsiWord);         i = read(ScsiWord);                  /* Get status word */         if j <> S$UnitAttention then return(DeviceFailed); /* Problem other than Unit Attention occurred - format fails */      end;                                 /* if stat = S$CheckCondition */   end;                                    /* while */   i = BusConnect(DAdr);                   /* Connect to SCSI bus */   if i <> S$GoodConnect then do;          /* Connection failed */      if i < 0 then return(i);      else return (-i);                    /* make negative if necessary */   end;   /*** Mode Sense Command ***/   write(ScsiByte) = S$ModeSense;          /* Operation Code */   write(ScsiByte) = shr(DAdr and "HF00",8 - 5); /* Target LUN */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 21;                   /* Allocation Length */   write(ScsiByte) = 0;                    /* Control */   do i = 0 to 12;      j = read(ScsiByte);                  /* Throw away first 13 bytes */   end;   NumHeads = shr(read(ScsiByte),4);       /* Keep no. heads on the drive */   SecTrack = read(ScsiByte);              /* Keep no. sectors per track */   NumCyl = read(ScsiWord) - 2;            /* Keep no. logical cylinders on drive (minus dedicated cylinders) */   do i = 17 to 20;      j = read(ScsiByte);                  /* Throw away last 4 bytes */   end;   Stat = read(ScsiWord);                  /* Get status word */   i = EnterList(SecTrack,NumHeads,NumCyl,Buffer); /* Get the bad sector list from the user */   return(i);                              /* Return the no. bad sector entries in the buffer */end GetBadSectors;/* This procedure displays the bad sector list */ShowBadSectors: procedure(Entries, Ptr);   dcl Entries  fixed;                   /* No. entries in table */   dcl Ptr      fixed;                   /* Location in memory of first entry */   dcl i fixed;   clear_screen;   pstring('Number of Bad Sectors: ');   UNum(Entries,1); CrLf; CrLf;   do i = 1 to 8;      pstring('--------');   end;   CrLf;   do i = 0 to (Entries - 1);            /* Print out table of bad sectors */      pstring('   ');      HNum(core(Ptr + i*2),1); HNum(core(Ptr + i*2 + 1),4);      if (i <> (Entries - 1)) and (((i + 1) mod 8) = 0) then CrLf;   end;   CrLf;   do i = 1 to 8;      pstring('--------');   end;   CrLf;end ShowBadSectors;/* This procedures zeros out the catalog area (the first four sectors of the disk ) */ZeroCatalog: procedure(DAdr) returns(fixed);   dcl DAdr fixed;                      /* Device address to zero */   dcl i    fixed;   i = BusConnect(DAdr);                /* Connect to SCSI bus */   if i <> S$GoodConnect then return(i); /* Return if connection failed */   /* Send Extended Write command */   write(ScsiByte) = "H2A";             /* Operation code */   write(ScsiByte) = shr(DAdr and "HF00",8 - 5); /* Logical unit number */   write(ScsiWord) = 0;                 /* MSW of starting sector */   write(ScsiWord) = 0;                 /* LSW of starting sector */   write(ScsiByte) = 0;                 /* Reserved */   write(ScsiWord) = 4;                 /* No. blocks to write */   write(ScsiByte) = 0;                 /* Control byte */   do i = 1 to 1024;                    /* Write 4 sectors of zeros */      write(ScsiWord) = 0;   end;   return(read(ScsiWord));              /* Return status word */end ZeroCatalog;/* MAIN PROGRAM */clear_screen;pstringr('This program formats a SCSI Winchester disk for the first time.');crlf;pstringr('Enter the bad sectors as they appear on the Flag Track Log attached to');pstringr('the drive (i.e., by Cylinder, Head, and Byte Count (or Length or BCAI)).');pstringr('When done entering the list, enter a cylinder number of zero to initiate');pstringr('the format.');DevAdr = GetDrive(0,5,0);                       /* Get SCSI device address, given these default parameters */BufPtr = core(core(1) + c#vstart) + core(core(1) + c#vlngth) + core(core(1) + c#stklen); /* Start buffer at end of program */i = GetBadSectors(DevAdr,location(BufPtr));     /* Get bad sector list from user */if i < 0 then do;                               /* Halt if error occurs during connection */   if i < -255 then i = -i;                     /* Map real statuses back again */   pstring('ERROR getting bad sectors: ');   PNum(i,1); CrLf;   stop;end;NumEntries = i;                                 /* Store number of entries entered */call ShowBadSectors(NumEntries,BufPtr);         /* Show the bad sectors entered */crlf;pstringr('These will be the ONLY bad sectors on this disk - any existing bad');pstringr('sector list will be replaced.');crlf;if Get_YN('Do you still wish to format this Winchester [Y(es) or N(o)]? ') then do;   crlf; pstringr('Performing primary format.  Please wait...');   i = ScsiFormat(1,DevAdr,location(BufPtr),NumEntries); /* Format this winchester */   if i <> GoodFormat then do;                  /* If error occurred during format */      crlf;      pstring('ERROR detected during format:  '); pnum(i,0); crlf;      pstringr('Format aborted.');   end;   else do;                                     /* Format successful, so zero out catalog area */      pstringr('Zeroing catalog area...');      i = ZeroCatalog(DevAdr);      if i <> S$Good then do;                   /* Error occurred zeroing catalog */         crlf;         pstring('ERROR zeroing catalog: '); PNum(i,1); crlf;      end;      else pstringr('Format complete.');   end;end;else pstringr('Format aborted.');stop;