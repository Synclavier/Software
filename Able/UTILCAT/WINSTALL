/* WINSTALL  $TITLE Winchester Installation Program *//* Winchester disk installation and update utility...  This program installs new software releases onto a Winchester.    system from superfloppy diskettes...  Modification history:.    2/07/91 - MWH - Combine 3200, 6400 and 9600 RTP's.    8/29/90 - LSS - magneto optical drives.    8/24/89 - LSS - Rel 2.03, install Tripp keyboard calibration.    4/11/89 - LSS - Rel 2.0, RTPs, defaults preserved.   12/01/88 - LSS - Rel 1.0, Model D, .SINF-7 no longer installed here.    7/08/88 - LSS - bug fix in Mac/mouse setup     .    5/16/88 - LSS - beta Release O, Macintosh, mouse   .    1/18/88 - LSS - final Release N, M64K board        .    8/14/87 - LSS - beta Release N, optical disk       .    1/28/87 - LSS - new 8 Winchester configuration support.    6/20/86 - LSS - updated for -7 catalog change  .    2/11/84 - KJC - totally rewritten for Release J*/dcl RTP_name         data ('Release 5.3 Real-time Program Disk  ');					//	leave the two trailing spacesdcl RTP_guitar_name  data ('Release 5.3 Real-time Program with Guitar Disk  ');	//	leave the two trailing spacesdcl profile_contents data ('       SET RTP SYN-5.3');configuration modelc, muldiv, memory 60*1024, smini;library ':utilcat:libs:set_term'; /* set the terminal type */insert ':-xpl:reldat';	 	/* get releasae date */insert ':-xpl:literals'; 	/* general literals */insert ':-xpl:asciilit'; 	/* ASCII literals */insert ':-xpl:scsilits'; 	/* SCSI literals */insert ':-xpl:scsicmds'; 	/* SCSI commmands */insert ':-xpl:catrtns';  	/* catalog routines */insert ':-xpl:termut';   	/* DEVCAT references this */insert ':-xpl:plotlib';  	/* SET_GRAPHICS references this */insert ':-xpl:devutil';  	/* device handlers */insert ':-xpl:optical';  	/* optical routines */insert ':-xpl:strings';  	/* string processing */insert ':utilcat:getfiles'; /* catalog searching */insert ':utilcat:winform';  /* Winchester formatting */insert ':synauxs:audauxs:adeflits'; /* for preserving the AEE defaults */dcl buf.len         lit '10240'; /* length of work buffer */dcl sync_memsiz     lit '60';    /* Synclavier system memory size (in K) */dcl work_size       lit '1000';  /* sector length of default work file */dcl scsi_work_size  lit '4000';  /* sector length of default SCSI work file */dcl index_size      lit '10000'; /* size for the optical disk index catalog */dcl profile_size    lit '2';     /* approx. sector length of default PROFILE */dcl RTP_size        lit '3300';  /* approx. sector length of each version of the Synclavier RTP */dcl MP_size         lit '1000';  /* approx. sector length of music printing (plus MP utilities) */dcl poll.len        lit '(c#strlen + s#blklen)'; /* length of polled Winchester array */dcl conf.len        lit '(s#blklen*8 + s#blklen)'; /* length of configured Winchester array */dcl win.config (s#blklen*4) fixed; /* configuration of W0, as many as four drives */dcl sync_versions   fixed; /* number of Synclavier RTP versions to install */dcl guitar_versions fixed; /* number of guitar RTP versions to install */dcl ibuf (64) fixed; /* global input buffer */dcl monitor      data ('MONITOR'); 	/* name of MONITOR program */dcl monitor_name data ('MONITOR7'); /* fake name of MONITOR on installation disk */dcl system_cat   data ('.SYSTEM'); 	/* name of path catalog */dcl work         data ('.WORK'); 	/* name of system work file */dcl index_name   data ('.INDEX'); 	/* name of optical disk index subcatalog */dcl profile      data ('PROFILE'); 	/* name of start-up command file */dcl sequence     data ('.SQ0DATA'); /* sequence file template */dcl srtp         data ('.SRTP0'); 	/* SRTP template for checking for room */dcl VPk_file     data ('.SMAP-7'); 	/* file with Tripp VPk maps and calibration data */dcl system_label data ('.SYSTEM Disk 1'); /* label for .SYSTEM disks */dcl catalog (c#dir_max - 1) fixed; /* catalog buffer */dcl cache1  (c#dir_max - 1) fixed; /* catalog cache */dcl dcache                  fixed; /* Winchester cache number */dcl extend               fixed; /* number of sectors to extend system catalog to fit in options */dcl extended.len         fixed; /* length of system catalog after extension */dcl old_work_size        fixed; /* size of the work file that was already on the disk */dcl (ms_total, ls_total) fixed; /* total free sectors needed to install this software */dcl format         boolean; /* true if user wants to format Winchester */dcl synclavier     boolean; /* true if it's a Synclavier (R) system */dcl guitar         boolean; /* true if user has Guitar option */dcl music_printing boolean; /* true to install Music Printing */dcl optical_option boolean; /* true if user has an Optical Disk */dcl keyboard_type  fixed;   /* 0:none, 1:ORK, 2:Vel/Pressure, 3:JTripp VPK */dcl processor      fixed;   /* processor type 0:A, 1:B, 2:C, 3:D */dcl index_there      boolean; /* true if optical index subcatalog already exists on disk */dcl valid_old_config boolean; /* true if there is valid info from the old Monitor */dcl defaults_tree data ('W0:.SYSTEM:.SDEF-7'); /* the AEE defaults file */dcl defaults_buf (shl(Info#Sectors.Used, 8)) fixed; /* currently only 2 sectors */dcl valid_defaults boolean; /* true if we find valid AEE default info in the old .SYSTEM */dcl ask proc (fixed array) returns (boolean); /* file WINSTAL2 inserted below uses this */insert ':utilcat:winstcpy'; /* get procedures for copying files (based on FORMCOPY) */insert ':utilcat:winstal2'; /* additional procedures for Winstall *//* $subtitle Check and Resolve Old Configuration */check_defaults: proc; /* preserve the AEE default information if we can */   dcl i fixed;   call blockset (defaults_buf, shl(Info#Sectors.Used, 8), 0);   if locate (defaults_tree, 6) then do; /* the file is in .SYSTEM */      call readdata (f#ms_sector, f#ls_sector, defaults_buf, shl(Info#Sectors.Used, 8)); /* read in the valid sectors */      if defaults_buf (shl(Info#AEEDefaults, 8) + AEE#DefsInit) = 1 /* the defaults have been initialized */      then valid_defaults = true; /* we have real data in the buffer */      else valid_defaults = false; /* probably all zeroes in the buffer */   end;   else do;      valid_defaults = false; /* no file, so no valid data */   end;end check_defaults;current_config: proc (win.config, polled.wins, config.buf); /* check and resolve configuration of old Monitor */   dcl win.config                     fixed array; /* winchester configuration */   dcl polled.wins                    fixed array; /* buffer with polled winchesters */   dcl config.buf                     fixed array; /* buffer for old configuration */   dcl old.config (conf.len)          fixed; /* Winchesters configured in old MONITOR */   dcl poll.match (poll.len/s#blklen) boolean; /* true if polled disk exists in old config */   dcl system_type                    fixed; /* either IMI (zero) or SCSI (one) */   dcl contab                         pointer; /* pointer to configuration table */   dcl W0_missing                     boolean; /* true if a configured  W0 drive is not on system */   dcl delete_W1                      boolean; /* true if we should throw out W1 because a drive is missing */   dcl found                          boolean; /* loop control */   dcl ptr                            pointer;   dcl (i, j, k)                      fixed;   /* do this procedure ONLY if there is a MONITOR on W0 */   if not locate (monitor, 6) then return; /* get location of current monitor on W0 */   call blockset (old.config, conf.len, s#freblk); /* initialize array to hold old config */   call blockset (poll.match, poll.len/s#blklen, false); /* no matches yet */   W0_missing = false; /* assume that W0 configuration is correct */   delete_W1 = false; /* assume that W1 configuration is correct */   valid_old_config = false; /* old config is not valid until proven so */   system_type = (shr(polled.wins (s#devtyp),8) and "3"); /* system type is W0 drive (0: IMI, 1: SCSI) */   call readdata (f#ms_sector, f#ls_sector, config.buf, 256); /* get first sector of MONITOR */   if valid_config (config.buf) then do; /* check the configuration */      valid_old_config = true; /* have valid info from old configuration */      /* Loop through the configuration table for the old MONITOR, storing         all Winchester disks in the array OLD.CONFIG */               i = 0;      contab = config.buf (1); /* location of configuration table */      ptr = contab + c#strdev; /* start of device table */      if config.buf (contab + c#version) = 0 then j = c#strlen/2; /* check for -6 version */      else j = 0; /* -7 version device table is twice as long as -6 */      do while ((ptr ilt contab + c#strend - j) and (config.buf (ptr + s#devtyp) <> s#freblk)); /* loop until free block */         if (config.buf (ptr + s#devtyp) and "17") = 1 then do; /* found a Winchester */            call blockmove (loc(addr(config.buf(ptr))), loc(addr(old.config(i))), s#blklen); /* store entry in config array */            i = i + s#blklen; /* next entry in OLD.CONFIG Winchester array */         end;         ptr = ptr + s#blklen; /* next device in table */      end;      if (old.config (s#devtyp) <> s#freblk) then do; /* if we found any Winchesters */         /* Loop through all the configured drives that were found.  If the            Winchester exists on the system (it is in POLLED.WIN), set the            flag for that drive in POLL.MATCH to true.  If the drive is not            on the system, decide if it was suppposed to be W0 or W1 and            set the appropriate error flag (W0_MISSING or DELETE_W1).  */         ptr = 0;         if (shr(old.config(s#devtyp),8) and "3") = system_type then do; /* if system disk types match */            do while (old.config (ptr + s#devtyp) <> s#freblk); /* do for all configured drives */               if (shr(old.config(ptr + s#devtyp),8) and "3") = system_type then do; /* if disk types match */                  i = st_find (loc(addr(old.config (ptr))), polled.wins, poll.len); /* see if drive is on system */                  if i <> -1 then do; /* the drive is present in system */                     poll.match (i/s#blklen) = true; /* this polled drive is in configuration */                  end;                  else do;                     if (shr(old.config(ptr + s#devtyp),4) and "17") = 0 /* this drive was supposed to be on W0 */                     then W0_missing = true; /* one of W0 disks is not on system */                     else delete_W1 = true; /* part of W1 is missing, so we should get rid of W1 */                  end;               end;               ptr = ptr + s#blklen; /* look at next Winchester in OLD.CONFIG */            end; /* of doing all configured drives */            /* $page */            /* If one of the W0 drives is not in the system, we cannot               install unless they format. */            if W0_missing then do; /* one of the W0 drives is not there */               print;               print 'There are Winchester disks configured on W0 that are not found in';               print 'the system.  If you want to install ',;               print string (rel.version),; print ' with this hardware';               print 'setup, you MUST format the Winchester disk.';               print;               print string (rel.version),;               print ' has not been installed on your system.';               core(loc.magic) = 0; stop; /* stop the program right here */            end;            /* If it is a SCSI system, check for extra drives on the system.               If the system is set up with the standard configuration, try               to add the nonconfigured Winchesters where they should go in               the configuration.  NOTE:  this uses the D24 number as               a device indicator - D24 zero is W0, and D24 one is W1. */            if system_type = 1 then do; /* SCSI system */               j = (poll.len/s#blklen); /* start at the end of the configuration list */               do while (j >= 0); /* loop through all polled drives */                  if (not poll.match (j)) and (polled.wins(j*s#blklen + s#devtyp) <> s#freblk) then do; /* not configured and it is there, try to add it on */                     i = (shr(polled.wins (j*s#blklen + s#devadr),4) and "17"); /* get D24 number - use as W0/W1 indicator */                     if ((i <> 1) or ((i = 1) and (not delete_W1))) then do; /* don't add W1's if W1 is invalid */                        ptr = SCSI_standard_config (i, old.config, conf.len); /* if config is standard, PTR points to last drive on device */                        if (ptr <> -1) then do; /* it is a standard configuration */                           if ((ptr = 0) and ((polled.wins (j*s#blklen + s#devadr) and "17") = 5)) /* this disk is the first one on device */                           or ((polled.wins (j*s#blklen + s#devadr) and "17") = old.config ((ptr + s#devadr) and "17") - 1) /* it is next in series */                           then do; /* okay, we can add the drive */                              polled.wins (j*s#blklen + s#devtyp) = /* setup the correct config info */                              (polled.wins (j*s#blklen + s#devtyp) or (shl(i, 4) or 1)); /* set logical drive number */                              call st_insert (loc(addr(polled.wins (j*s#blklen))), ptr + s#blklen, old.config, conf.len); /* insert it into configuration */                           end;                        end;                     end; /* don't add W1's if W1 is invalid */                  end; /* if drive is not configured */                  j = j - 1; /* look at previous unconfigured drive */               end; /* loop through all polled drives */            end; /* if a SCSI system */                    /* If one or more of the W1 drives were not on the system,               delete all the W1 drives. */            if delete_W1 then do; /* some W1 disks were missing */               i = 0;               do while (old.config (i + s#devtyp) <> s#freblk) and (i < conf.len); /* do for all configured drives */                  if (shr(old.config (i + s#devtyp),4) and "17") = 1 /* if it is a W1 drive */                  then call st_delete (i, old.config, conf.len); /* delete it */                  else i = i + s#blklen; /* go on to next one */               end;            end; /* of deleting W1 */            /* $page */            /* Now assign this configuration to the low core configuration               area, overwriting the one that we put there before.  */            found = false;            ptr = c#contab + c#strdev; /* point to the start of the low core device table */            do while ((ptr < c#contab + c#strend) and (core(ptr) <> s#freblk) and (not found)); /* look for first Winchester disk */               if (core (ptr + s#devtyp) and "17") = 1 /* a Winchester disk */               then found = true; /* we know there is a W0 and it is at the end (and no W1) */               else ptr = ptr + s#blklen; /* point to next block */            end;            i = 0;            win.config (0) = 0; /* we are going to replace this with current configuration */            do while ((ptr < c#contab + c#strend) and (old.config (i) <> s#freblk)); /* loop through old configuration */               core(ptr + s#devtyp) = old.config (i + s#devtyp); /* save the Winchester in memory */               win.config (i + s#devtyp + 1) = old.config (i + s#devtyp); /* and replace it here for UPDATE_CONFIG */               if (shr(old.config (i + s#devtyp), 8) and "3") = 1 then do; /* SCSI winchester? */                  k = st_find (loc(addr(old.config (i))), polled.wins, poll.len); /* look up drive's actual configuration */                  do j = 1 to s#blklen - 1; /* assign the configuration: ASSUMES S#DEVTYP = 0 */                     core(ptr + j) = polled.wins (k + j); /* save the Winchester in memory */                     win.config (i + j + 1) = polled.wins (k + j); /* and replace it here for UPDATE_CONFIG */                  end; /* of assigning configuration */               end; /* of SCSI winchester */               else do; /* non-SCSI Winchesters */                  do j = 1 to s#blklen - 1; /* assign the configuration: ASSUMES S#DEVTYP = 0 */                     core(ptr + j) = old.config (i + j); /* save the Winchester in memory */                     win.config (i + j + 1) = old.config (i + j); /* and replace it here for UPDATE_CONFIG */                  end; /* of assigning configuration */               end; /* of non-SCSI Winchesters */               win.config (0) = win.config (0) + s#blklen; /* one more winchester configured */               ptr = ptr + s#blklen; /* advance to the next block in memory */               i = i + s#blklen; /* point to next block */            end; /* of looping through old configuration */            if (ptr < c#contab + c#strend) then do; /* if we are not at the end */               call blockset (loc(addr(core(ptr))), (c#contab + c#strend - ptr), s#freblk); /* pad with FREBLK if necessary */           /*    call blockset (loc(addr(win.config (ptr))), (c#contab + c#strend - ptr), s#freblk); */ /* pad with FREBLK if necessary */           /* The above line of code overwrites internal memory for              some reason, hence it is commented out for now.                Have not had time to debug.  LSS 12/88 */            end;         end; /* if system types match */      end; /* of if we found any Winchesters */   end; /* of checking the old config */end current_config;/* $subtitle Update the Configuration of the new Monitor */search_config: proc (buf, dev_type, drive) returns (pointer); /* searches a buffer for a drive type */   dcl buf       fixed array; /* buffer holding first sector of a program */   dcl dev_type  fixed; /* device type to look for (0: floppy, 1: Winch, etc.) */   dcl drive     fixed; /* logical drive to look for (0 or 1) */   dcl found     boolean; /* loop control variable */   dcl p         pointer; /* pointer into the buffer */   dcl (i, j)    fixed;   found = false; /* haven't found it yet */   p = buf (1) + c#strdev; /* pointer to start of device table */   if buf (buf (1) + c#version) = 0 /* if -6 configuration */   then j = c#strlen/2; else j = 0; /* compensate for short table */   do while ((p < (buf (1) + c#strend - j)) and (p <> s#freblk) and (not found)); /* not at the end of table */      if (buf (p + s#devtyp) and "377") = (shl(drive, 4) or dev_type) /* look for the drive */      then found = true; /* found the drive we're looking for */      else p = p + s#blklen; /* otherwise look at next entry */   end;   if found then return (p); /* return the pointer into array */   else return (-1); /* we didn't find it */end search_config;update_config: proc (win.config, synclavier, old.config, buf); /* update configuration of new Monitor */   dcl win.config  fixed array; /* winchester configuration */   dcl synclavier  boolean; /* TRUE if this is a synclavier system */   dcl old.config  fixed array; /* contains the first sector of old MONITOR */   dcl buf         fixed array; /* buffer to store first sector of new MONITOR */   dcl found       boolean; /* loop control */   dcl mono_option boolean;   dcl p           pointer;   dcl (i, j)      fixed;   call locate (monitor, 6); 								/* get location of monitor */   call readdata (f#ms_sector, f#ls_sector, buf, 256); 		/* get first sector */   call set_graphics; 										/* set up terminal graphics type */   buf (buf (1) + c#memsiz) = memory_sectors; 				/* set memory size to 60K */   /* determine processor type */   write(r0) = -1; 						/* im(-1) to R0 */   write("210") = 1; 					/* im(1) to ADD0 (generate carry) */   write("270") = 0; 					/* im(0) to ADC0 (try to add in carry - only works on Model C) */   if read(r0) <> 1 then i = shl(1, 8); /* set to B processor */   else i = shl(2, 8); 					/* set to C processor */   if (read("51") and "100000") <> 0 then do; /* if there are extended bits */      if ((read("57") and "1") <> 0) 	/* there is a Model D here */      then i = shl(3, 8); 				/* set to D processor */   end;   processor = shr(i, 8); 				/* set this variable for use when loading RTPs */   if synclavier /* synclavier system? */   then buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt) and (not (o#d66 or shl("7", 8)))) or o#d130 or o#d160 or i);   else buf (buf (1) + c#cmopt) =  (buf (buf (1) + c#cmopt) and (not (o#d66 or o#d130 or o#d160 or shl("7", 8))) or i); /* scientific */   /* set mouse bit in configuration */   if ((((read("51") and "100000") <> 0) and ((read("57") and "2") <> 0)) /* if a D40Q is in the system */   or (terminal.model = t#macintosh)) then do; /* or if there is a Macintosh */      buf (buf (1) + c#cmopt) = (buf (buf (1) + c#cmopt)) or o#d44; /* set the mouse bit */   end;   else if valid_old_config then do; /* no D40Q or Mac, so use setting from the old Monitor (in case they have a D44) */      buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or (old.config (old.config (1) + c#cmopt) and o#d44)); /* preserve bit from old Monitor */   end;   else do; /* if none of the above, turn off mouse bit just to be sure */      buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) and (not o#d44));   end;   if ((terminal.type = t#vt100) or ((shr(buf (buf (1) + c#ptype), 8) and "37") <> terminal.type)) /* is this configured for the right kind of terminal? */   then buf (buf (1) + c#ptype) = terminal_info; /* no, set it up */   if valid_old_config then do; /* preserve some things from old config */      /* preserve the D66 configuration */      buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or (old.config (old.config (1) + c#cmopt) and o#d66)); /* set the D66 in new system */      /* set the printer type to what was in the old configuration */      if (old.config (old.config (1) + c#stype) <> 0) /* if there is a printer in old system */      then buf (buf (1) + c#stype) = old.config (old.config (1) + c#stype); /* add it here */   end;   /* On 7-Feb-91, we added 2 new option bits: "D164 present" and    */   /* "mono/3200 voices".  If we find a previous configuration where */   /* both of these bits are zero, we need to ask how they should be */   /* set (since there are not likely to be systems with no D164 but */   /* also with stereo voices).  Per Lisa Thompson, only the first   */   /* 30 3200 systems were delivered without a D164, and all of them */   /* had MONO poly voice cards.  If any bits are NON-zero, we       */   /* will assume the old configuration is valid and presere it.     */   if  (NOT valid_old_config) /* No old config OR both new bits zero */   OR  (((old.config (old.config (1) + c#cmopt) and o#d164)   = 0)   AND  ((old.config (old.config (1) + c#cmopt) and o#pvoice) = 0))   then do;      if keyboard_type <> 0      then buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or o#d164);      mono_option = ask ('Are your polyphonic voices 3200/6400 mono voices [Y(es) or N(o)]? ');      if mono_option      then buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or o#pvoice);   end;   else do;  /* Preserve D164 and MONO VOICE options from the old config */      buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or (old.config (old.config (1) + c#cmopt) and o#d164));      buf (buf (1) + c#cmopt) = ((buf (buf (1) + c#cmopt)) or (old.config (old.config (1) + c#cmopt) and o#pvoice));   end;   /* $page */   do i = 1 to win.config (0); /* copy Winchester config into BUF */      buf (buf (1) + c#strdev + i - 1) = win.config (i);   end;   buf (buf (1) + c#curdev) = (buf (buf (1) + c#strdev) and "377"); /* set current device to system device */   do i = c#strdev + win.config (0) to c#strend - 1; /* free up rest of storage device table */      buf (buf (1) + i) = s#freblk;   end;   p = find_device (2); /* find F0 [MUST be there] */   if p <> 0 then do; /* if F0 was found */      do i = 0 to s#blklen - 1; /* add F0 into table after the Winchesters */         buf (buf (1) + c#strdev + win.config (0) + i) = core(p + i);      end;      if valid_old_config then do; /* preserve F1 if it exists in the old configuration */         p = search_config (old.config, 0, 1); /* try to find floppy (0) one (1) */         if p <> -1 then do; /* if we found an F1 drive */            do i = 0 to s#blklen - 1; /* copy F1 into config - assume F0 is right after the Winchesters */               buf (buf (1) + c#strdev + win.config (0) + s#blklen + i) = old.config (p + i); /* add F1 after F0 */            end;         end;      end;   end;   if valid_old_config then do; /* preserve T0 if it exists in the old configuration */      p = search_config (old.config, 3, 0); /* try to find tape (3) zero (0) */      if p <> -1 then do; /* if we found a T0 drive */         i = buf (1) + c#strdev + win.config (0); /* start at end of Winchesters */         if buf (buf (1) + c#version) = 0 /* if -6 configuration */         then j = c#strlen/2; else j = 0; /* compensate for short table */         do while ((i < (buf (1) + c#strend - j)) and (buf (i) <> s#freblk)); /* look for the end of table */            i = i + s#blklen; /* look at next entry */         end;         if i < (buf (1) + c#strend - j) then do; /* if there is room in the table */            call blockmove (loc(addr (old.config (p))), loc(addr (buf (i))), s#blklen); /* copy tape config to BUF */         end;      end; /* of if we found a T0 drive */   end;   /* Now add in the configuration for the optical disk if they have one.      This assumes they will only have ONE optical drive.  This must be      changed if the storage device entries for opticals change. */         if optical_option then do; /* if they say they have an optical disk */      i = find_optical(1); /* poll system for optical at (0,1,0) */            if i <> -1 then do; /* add this optical into configuration */         p = buf (1) + c#strdev + win.config (0); /* start at end of Winchesters */         if buf (buf (1) + c#version) = 0 /* if -6 configuration */         then j = c#strlen/2; else j = 0; /* compensate for short table */         do while ((p < (buf (1) + c#strend - j)) and (buf (p) <> s#freblk)); /* look for the end of table */            p = p + s#blklen; /* look at next entry */         end;         if p < (buf (1) + c#strend - j) then do; /* if there is room in the table */            if i = 0 then do; /* LMS WORM device */               buf (p + s#devtyp) = shl(1,8) or shl(0,4) or 4; /* 1: SCSI, 0: logical drive, 4: optical drive type */               buf (p + s#seccyl) = 1000; /* total sectors on LMS platter */               buf (p + s#totcyl) = 2048;               buf (p + s#devadr) = shl(0,8) or shl(0,4) or 1; /* 0: LUN, 0: D24, 1: target */            end;            else if i = 1 then do; /* magneto optical device */               buf (p + s#devtyp) = shl (1,10) or shl(1,8) or shl(0,4) or 4; /* 1: magneto, 1: SCSI, 0: logical drive, 4: optical drive type */               buf (p + s#seccyl) = 144; /* reasonable size for a 1-gig media */               buf (p + s#totcyl) = 6815;               buf (p + s#devadr) = shl(0,8) or shl(0,4) or 1; /* 0: LUN, 0: D24, 1: target */           end;        end;      end;   end; /* of if they have the optical disk */   call writedata (f#ms_sector, f#ls_sector, buf, 256); /* write updated configuration to Monitor */end update_config;/* $subtitle User Interface - General Procedures */copy_file: proc (name, buf, bufsize); /* copy file NAME to destination (save it on destination first) */   dcl name      fixed array; /* name of file to transfer */   dcl buf       fixed array; /* the buffer */   dcl bufsize   fixed; /* size of buffer */   call get_fileinfo (name); /* get all related file information for this file */   if replace (name, f#type, f#ms_length, f#ls_length, f#words, dest) /* save it */   then call transfer_file (name, buf, bufsize); /* and transfer the contents */   else print '*** Not enough room on your Winchester disk to install file:  ', string(name);end copy_file;ask: proc (prompt) returns (boolean); /* print the prompting string, return TRUE for yes and FALSE for no */   dcl prompt fixed array;   dcl ch     fixed;   ch = 0;   do while ((ch <> a.y) and (ch <> a.n));      print string(prompt),;      linput ibuf;      ch = (byte(ibuf, 0) and (not (l.a - a.a))); /* get and uppercase first character */   end;   if ch = a.y then return (true); /* yes */   return (false); /* no */end ask;get_disk: proc (diskname, identity) returns (boolean); /* get required disk */   dcl diskname fixed array; /* the "name" of the disk */   dcl identity fixed array; /* the name of an identifying file on that disk */   dcl found    boolean; /* true if we found that disk */   dcl no_abort boolean; /* true if the user didn't abort the MOVE operation */   no_abort = true; /* no user intervention yet */   found = false; /* haven't found that disk yet */   do while ((not found) and no_abort); /* look for specified disk */      print;      print 'Insert the ', string(diskname), ' into';      print 'the LEFTMOST diskette drive and press RETURN ->',;      linput ibuf;      found = locate (identity, 2); /* search for a file we know is on the disk */      if not found then do; /* not there */         print 'Error:  this disk is not the ', string(diskname);         no_abort = ask ('Do you want to try again with another diskette? ');      end;   end;   return (found); /* return whether we found it (FALSE if user aborted) */end get_disk;/* $subtitle User Interface - Install the Synclavier (R) RTP Versions */install_rtp: proc (keyboard_type, guitar, buf, buflen); /* install a version of the RTP */   dcl keyboard_type      boolean; /* type of keyboard on system */   dcl guitar             boolean; /* true if user has guitar option */   dcl buf                fixed array; /* copy buffer (must be at least BUF.LEN words) */   dcl buflen             fixed; /* length of copy buffer */   dcl nam (f#name_len-1) fixed; /* filename array */   dcl i                  fixed;   load_rtp: proc (label, rtp); /* load one version of the Real-time Program */      dcl label fixed array; /* label of the diskette with the RTP */      dcl rtp   fixed array; /* name of the RTP program to install */      dcl okay  boolean; /* true if we have the disk and can load RTP */      if not locate (rtp, 2) /* see if the RTP is on the diskette in the F0 drive */      then okay = get_disk (label, rtp); /* ask user for the disk */      else okay = true; /* already there, so it's okay to copy */      if okay then do; /* we have a diskette with RTP, so start copying */         if (locate (profile, 2) and (not locate (profile, 6))) /* only copy PROFILE if it's on F0 and not on W0 */         then call copy_file (profile, buf, buflen); /* copy it */         disk.label = addr(label (0)); /* set disk label just in case */         call copy_file (rtp, buf, buflen); /* copy first RTP */      end;   end load_rtp;   load_disk: proc (disk_name); /* finds and loads an RTP version */      dcl disk_name fixed array; /* name of the disk to load */      dcl found     boolean; /* true if we found a version we can install */      if get_disk (disk_name, 'PROFILE') then do; /* we have a disk with an RTP on it */         if keyboard_type = 1 then call start_search ('ORK-*', false, 2); /* search floppy for original keyboard versions to load */         else call start_search ('SYN-*', false, 2); /* search for velocity keyboard versions (non-keyboard systems get these too) */         found = false; /* assume we did not find an RTP to install */         if getfname (nam) then do; /* load an RTP version - should have only one there */            call load_rtp (disk_name, nam); /* load the RTP */            found = true; /* yes, we did install an RTP version */         end;         /* If RTP just loaded was a dump file, we are in a caching crisis, hence the next line */         do while getfname (nam); end; /* loop through the rest of the names, if there are any */                  if not found then do; /* did not find an RTP to install - so give them a clue about the problem */            print 'Error: could not locate a Real-time Program for your system';            print 'configuration on this diskette.';            if keyboard_type = 1            then print 'The RTP name for this release begins with the characters ''ORK-''.';            else print 'The RTP name for this release begins with the characters ''SYN-''.';         end;      end; /* of we have a disk with an RTP on it */   end load_disk;   call pbyte (loc(addr(RTP_name(0))), core(addr(RTP_name(0))) - 1, a.1); /* store a "1" at the end */   call pbyte (loc(addr(RTP_guitar_name(0))), core(addr(RTP_guitar_name(0))) - 1, a.1); /* store a "1" at the end */   call                load_disk (RTP_name); /* get an RTP and install it */   if guitar then call load_disk (RTP_guitar_name); /* also do a guitar version */end install_rtp;/* $subtitle User Interface - Compute Sectors Needed for this Software */compute_total: proc; /* computes how many total free sectors are needed to install the software */    dcl nam (f#name_len-1) fixed; /* filename array */   dcl i                  fixed;      ls_total = 0; ms_total = 0; /* don't need any yet */   ls_total = extended.len; /* start with size needed for .SYSTEM */   call start_search ('*', false, 2); /* now look on F0 for files there */   do while (getfname (nam)); /* get all files on F0 */      if (not (compare (nam, monitor) or compare (nam, system_cat))) then do; /* skip MONITOR (WINSTALL) and .SYSTEM (already done) */         call locate (nam, 2); /* search for file on F0 */         ms_total = ms_total + f#ms_length; /* update the total sectors needed */         ls_total = ls_total + f#ls_length;         if ls_total ILT f#ls_length then ms_total = ms_total + 1;      end;   end; /* of getting all the F0 files */   i = work_size;  /* default work file size */   if (shr(win.config (1), 8) and "3") = 1 then i = scsi_work_size; /* different for SCSI */   if old_work_size IGT i then i = old_work_size; /* the old work file is bigger, so use that size */   ls_total = ls_total + i; /* add in the size of .WORK */   if ls_total ILT i then ms_total = ms_total + 1;   if synclavier then do; /* add in Synclavier files */      ls_total = ls_total + profile_size; /* add in the size of PROFILE file */      if ls_total ILT profile_size then ms_total = ms_total + 1;      do i = 1 to sync_versions + guitar*guitar_versions; /* add in size of total RTP versions they need */         ls_total = ls_total + RTP_size; /* add in an RTP size */         if ls_total ILT RTP_size then ms_total = ms_total + 1;      end;   end; /* of adding in the Synclavier files */   if (optical_option and (not index_there)) then do; /* optical disk and don't already have a .INDEX */      ls_total = ls_total + index_size; /* add in the index file needed */      if ls_total ILT index_size then ms_total = ms_total + 1;   end;end compute_total;      /* $subtitle User Interface - Report an Error */catalog_error: proc; /* print catalog error and exit */   wchar (a.bel); /* beep the terminal */   print;   if c#status = e#invalid then do; /* catalog validation error */      print 'There is a validation error in your Winchester directory.  You must';      print 'FORMAT your Winchester disk before installing ',;      print string (rel.version), '.';   end;   else if c#status = e#name then do; /* special code meaning no room on first disk for Monitor */      print 'The ',; print string (rel.version),;      print ' MONITOR program will not fit on your system.  Use the';      print 'Winchester Bootload Diskette to activate the prior software, unsave';      print 'a few files near the beginning of W0:, and then try again.';   end;   else do; /* out of space (or contiguous space) on the disk */      call compute_total; /* get the total sectors they need to install */      print '--> ', string (rel.version), ' will not fit on your system.'; crlf;      print 'You need at least ',;      lnum (ms_total, ls_total, 0);      print ' sectors of contiguous space to install this release.';      print 'Use the Winchester Bootload Diskette to activate the prior software and';      print 'check the free space left on your disk.  If you have ',; lnum (ms_total, ls_total, 0); print ' free sectors';      print '(or more) on your Winchester disk, run the SHUFFLE utility and try';      print 'installing again.'; crlf;      print 'If you do not have enough space, unsave files until you have enough';      print 'free sectors on your disk.  Then run the SHUFFLE utility and try';      print 'installing again.';      if (optical_option and (not index_there)) then do; /* special hint about the optical disk index file */         print;         print 'Note that a 10,000 sector index subcatalog for using your Optical Disk';         print 'must be created on W0.';      end;   end;   print;   print 'Formatting your Winchester disk will assure that ',;   print string (rel.version), ' can be installed.';   print;   print string (rel.version), ' has NOT been installed on your system.';   core(loc.magic) = 0; /* make sure we do a full reboot */   stop; /* since there's probably no system there */end catalog_error;/* $subtitle Main Program */dcl buf (buf.len)         fixed; /* work buffer */dcl config.buf (256)      fixed; /* buffer for configuration of old MONITOR */dcl filename (f#name_len) fixed; /* name of next file to operate on is saved here */dcl (i, j)                fixed;call set_catbuf (addr(catalog (0)), 0); /* set the catalog buffer */call init_optical_controller; /* set up for LMS or Quantum controller */mem.siz = (60*1024); /* set system for 60K words internal memory */memory_sectors = shr(mem.siz, 8); /* and size in sectors *//* check to see if system has hardware for 63K internal memory */if (read("51") and "100000") <> 0 then do; /* if there are extended bits */   if  ((read("57") and "4") <> 0) /* there is an M64K board in system */   and ((read("57") and "2") <> 0) /* and a D40Q board in system */   then do; /* set system to have 63K words internal memory */      mem.siz = (63*1024); /* set word size to 63K */      memory_sectors = shr(mem.siz, 8); /* and size in sectors */   end;end;core(loc.magic) = 12345; /* pretend a system's here - this is all we need providing we don't use level 0 or 1 */core(loc.emsize) = 0; /* this so the catalog routines don't try to set bit in external memory */if terminal.type = t#vt100 then do; /* if this is a VT100 */   print character(a.esc), '[H', character(a.esc), '[J',; /* clear screen on VT100 */   do i = 1 to 42; write(3) = 0; end; /* pause for 200 ms (includes synching w/clock) */end; /* of clearing VT100 */else print character(c.z),; /* clear screen on ADM */print string (rel.version), ' Winchester Disk Installation Program    ', string (rel.date);print;print 'This program is used to install ', string (rel.version), ' software on your system';print 'Winchester disk (device W0).  Your system Winchester disk(s) can be';print 'either SCSI drives or IMI drives, depending on your hardware setup.';/* GET_WIN_CONFIG prompts the user to make sure we install the system   on SCSI or IMI Winchesters, whichever one they want. */call get_win_config (win.config, buf); /* poll system to get winchester configuration */print;print 'You can use this opportunity to format your system Winchester disk.';print 'Formatting your Winchester disk will erase all information on it and';print 'prepare for optimal installation of ', string (rel.version), '.';print;print 'NOTE:  Formatting your Winchester disk will erase all files on it and';print 'should only be done if you have all your sound files, sequences, timbres,';print 'and other user files backed up on diskette, tape or optical disk.';print;if ((shr(win.config (1), 8) == 1)	/* if is SCSI	*/&&  (win.config(0) <= s#blklen))	/* one found	*/{	print 'Note: This revised installation program will only format';	print '*     the SCSI hard drive at address 0,5,0 (W0).  Other';	print '*     hard drives will not be formatted';}else{	print 'Warning:  If you choose to format, both your W0 and W1 Winchester';	print '          devices may be formatted.';}print;format = ask ('Would you like to FORMAT the Winchester disk [Y(es) or N(o)]? ');if format then format = ask ('Please CONFIRM that you want to FORMAT the Winchester disk [Y(es) or N(o)] ->'); /* double check */if format then do; /* do the format */   do i = 1 to win.config (0) by s#blklen; /* loop over winchesters */      call winform (0, win.config (i + s#devtyp), win.config (i + s#devadr), buf);   end;   print;   print 'The Winchester disk has now been formatted.';end; /* of do format *//* $subtitle Main Program - Ask User about System Options *//* This program first asks the user what options the system has, then.  tries to find room on their disk for the software they need..  The directory is cached, so if all the files can be saved in the.  cached directory, it is assumed there is room on the disk.  The.  cache is written to the disk and the copying of files commences. */call setup_cache (6); /* cache the Winchester's catalog */if not format then do; /* if we didn't format the disk, check config and get rid of old versions */   if locate (work, 6) then do; /* check the size of the old .WORK file */      if f#ls_length IGT scsi_work_size /* if the old .WORK is larger than the SCSI default */      then old_work_size = f#ls_length; /* use this size for the new .WORK file */      else old_work_size = 0; /* otherwise, we'll use the default size */   end;   call check_defaults; /* preserve the data in the AEE defaults file */   call current_config (win.config, buf, config.buf); /* resolve the Winchester configuration of the old Monitor */   call start_search ('MONITOR .WORK .SYSTEM .*-7 NED-* SYN-* ORK-* CONFIGUR FORMCOPY RESIZE SHUFFLE', false, 6); /* set up to delete old files on Winchester */   do while (getfname (filename)); /* delete all copies of these files that we find */      if locate (filename, 6) /* if the file's really there (wildcard files ARE there) */      then call delete (filename, 6); /* then delete it */   end;end;print;synclavier = true;   /* assume they have a Synclavier system */if ask ('Do you have a Synclavier keyboard on your system [Y(es) or N(o)]? ')then keyboard_type = 2; /* Regular VP keyboard */else keyboard_type = 0; /* No keyboard */if keyboard_type <> 0 then do;   print;   print 'In 1989 an Enhanced version of the Synclavier Velocity/Pressure';   print 'Keyboard was introduced.  These keyboards have serial numbers on the back';   print 'of the keyboard case which contain the phrase ''V/KPT'' in them.';   print;   if ask ('Do you have the Enhanced Velocity/Pressure Keyboard [Y(es) or N(o)]? ')   then keyboard_type = 3; /* Tripp enhanced keyboard option */end;optical_option = ask ('Do you have the Optical Disk Option [Y(es) or N(o)]? ');guitar         = ask ('Do you have the Digital Guitar Option [Y(es) or N(o)]? ');music_printing = ask ('Do you have the Music Printing Option [Y(es) or N(o)]? ');/* $subtitle Main Program - Verify there is Room for System Software */sync_versions = 1; /* install one version of the RTP */if guitar then guitar_versions = 1; /* they want a guitar version, too */else           guitar_versions = 0; /* no guitar versions */extend = music_printing*MP_size; /* determine how much larger .SYSTEM has to be (only music printing goes in .SYSTEM) */call get_fileinfo (system_cat); /* get current size/info of .SYSTEM catalog */extended.len = f#ls_length + extend; /* how much to increase .SYSTEM */if extended.len ILT extend then j = 1; else j = 0; /* carry for call to REPLACE below *//* This optical check is here because the amount of disk space needed to.  install depends on whether or not they already have a .INDEX file.  The.  procedure CATALOG_ERROR called below uses the variable INDEX_THERE while.  determining how many free sectors needed to install the software. */if optical_option then do; /* see if we have to save an index subcatalog */   if not locate (index_name, 6) then do; /* if they don't already have an index file */      index_there = false; /* there is no idex file on W0 */      if not replace (index_name, t#lsubc, 0, index_size, shl(index_size, 8), 6) /* try to save index subcatalog on W0 */      then call catalog_error; /* if no room, print error message and die */   end;   else index_there = true; /* there is already an index file on the disk */end;call get_fileinfo (system_cat); /* reset catalog variables for .SYSTEM file */if not replace (system_cat, f#type, f#ms_length + j, extended.len, shl(extended.len, 8), 6) /* try to save on W0 */then call catalog_error; /* if no room, print error message and die *//* Start a search of files on the F0 floppy disk */call start_search ('*', false, 2); /* start search of floppy disk - look for all files */do while (getfname (filename)); /* save all these files */   if (not (compare (filename, monitor) or compare (filename, system_cat))) then do; /* skip MONITOR (WINSTALL) and .SYSTEM (saved above) */      call locate (filename, 2); /* search for file on F0 */      if compare (filename, monitor_name) /* is this the MONITOR in disguise ? */      then do i = 0 to shr(monitor_name (0) + 1, 1); /* yes, change its name */         filename (i) = monitor (i); /* to MONITOR */      end;      if not replace (filename, f#type, f#ms_length, f#ls_length, f#words, 6) /* try to save on W0 */      then call catalog_error; /* if no room, print error message and die */      if (compare (filename, monitor)) then do; /* if file is the MONITOR */         write(5) = win.config (1 + s#seccyl); /* multiply to get total sectors on the first Winchester disk */         write(6) = win.config (1 + s#totcyl);         if (((f#ms_sector and "377") IGT read(4)) /* if the MONITOR is not on the first disk */         or (((f#ms_sector and "377") IEQ read(4)) and (f#ls_sector IGT read(5)))) then do;            c#status = e#name; /* MONITOR must go on the first disk to bootload (use NAME error to signal this) */            call catalog_error; /* print error message and die */         end;      end; /* of if compare */   end;end; /* of saving all files on this disk */i = work_size; /* default work file size */if (shr(win.config (1), 8) and "3") = 1 then i = scsi_work_size; /* different for SCSI */if old_work_size IGT i then i = old_work_size; /* their old work file was bigger, so use that size */if not replace (work, t#data, 0, i, shl(i, 8), 6) /* try to save the work file */then call catalog_error; /* if no room, print error message and die *//* $subtitle Main Program - Verify there is Room for Real-time Software */if synclavier then do; /* if there's a synclavier we have to install RTP versions */   if locate (profile, 6) then do; /* there's a profile on W0 */      print;      print string (rel.version), ' requires the use of a PROFILE file for proper operation.';      print 'You can modify your current PROFILE file for use with this release';      print 'or a new one can be installed automatically for you right now.';      print;      if ask ('Would you like to install a new PROFILE file [Y(es) or N(o)]? ')      then call delete (profile, 6); /* if okay, delete it */      else do; /* not okay to install profile - leave theirs intact */         print;         print 'After installing ', string (rel.version), ', be sure to add a SET RTP command to your';         print 'PROFILE file which specifies the new Real-time Program that you will';         print 'be using.  For example:';         print;         print string(profile_contents); /* Model D general RTP */      end; /* of not okay */   end; /* of there's a profile on W0 */   if not locate (profile, 6) then do; /* if no profile on W0, we need to save one */      call pbyte(srtp, srtp (0) - 1, a.0); /* change the number of the RTP template for the PROFILE */      if not replace (srtp, t#text, 0, profile_size, shl(profile_size, 8), 6) /* try to save profile on W0 */      then call catalog_error; /* if no room, print error message and die */   end; /* of saving profile */   do i = 1 to sync_versions + guitar*guitar_versions; /* try to save RTP versions */      call pbyte(srtp, srtp (0) - 1, a.0 + i); /* change the number of the template */      if not replace (srtp, t#exec, 0, RTP_size, shl(RTP_size, 8), 6) /* try to save on W0 */      then call catalog_error; /* if no room, print error message and die */   end;end; /* of accounting for RTP versions *//* $subtitle Main Program - Copy the Files to the Winchester *//* Since it looks as if all the files will fit, write the cache to   the Winchester disk and copy all the files. */print;call start_search ('*', false, 2); /* start search of floppy disk - look for all files */do while (getfname (filename)); /* copy all these files */   if (not (compare (filename, monitor) or compare (filename, system_cat))) then do; /* skip MONITOR (WINSTALL) and .SYSTEM (copied below) */      if compare (filename, monitor_name) /* is this the MONITOR in disguise? */      then do i = 0 to shr(monitor_name (0) + 1, 1); /* yes, change its name */         filename (i) = monitor (i); /* to MONITOR */      end;      call transfer_file (filename, buf, buf.len); /* copy the file */   end;end; /* of copying all files on this disk */if synclavier /* if a synclavier system, get rid of dummy RTPs we saved in the cache */then do i = 0 to sync_versions + guitar*guitar_versions; /* delete dummy RTP versions and profile (saved above) */   call pbyte(srtp, srtp (0) - 1, a.0 + i); /* change the number of the template */   if locate (srtp, 6) /* if it's there (only the PROFILE may not be there) */   then call delete (srtp, 6); /* take it out of the Winchester catalog */end;call write_out_cache (6); /* write out this new directory to disk */ call disable_cache (dcache); /* destroy the cache */call update_config (win.config, synclavier, config.buf, buf); /* set up the Monitor configuration */disk.label = addr(system_label (0)); /* point to disk label */call transfer_file (system_cat, buf, buf.len); /* copy the system catalog */call enter_catalog (system_cat, 6); /* enter system catalog (W0) */if synclavier /* if we're installing on a synclavier */then call install_rtp (keyboard_type, guitar, buf, buf.len); /* install RTP versions */if (optical_option and (not index_there)) then do; /* optical disk but no index file */   if replace (index_name, t#lsubc, 0, index_size, shl(index_size, 8), 6) /* save the index file on W0 */   then do; /* saved the subcatalog, so zero the directory (four sectors) */     call blockset (buf, 1024, 0); /* fill this buffer with all zeroes */     call writedata (f#ms_sector, f#ls_sector, buf, 1024); /* write it out as the directory */   end;   else print '*** Not enough room on your Winchester disk to install file: .INDEX';end; /* of if they have the optical disk and no index file *//* Now install Music Printing */if music_printing then do; /* install music printing if they have it */   if get_disk ('Music Printing Disk', '.SPLT-7') then do; /* get the disk first */      call start_search ('*', false, 2); /* start search of floppy disk - look for all files */      do while (getfname (filename)); /* copy system files */         if byte (filename, 0) = a.period then do; /* only install system programs (beginning with '.') */            dest = 1; /* set system catalog as destination */            call copy_file (filename, buf, buf.len); /* copy the file to system catalog */         end;         else if ((compare (filename, 'SYMED')) /* if file is the Symbol Editor */         or (compare (filename, 'LASERCOM')) /* or the laser printer utility */         or (compare (filename, 'PRNTBAUD')) /* or the BAUD rate program */         or (compare (filename, 'FRAMED'))) then do; /* or the guitar frame program */            dest = 6; /* set top-level of W0: as destination */            call copy_file (filename, buf, buf.len); /* copy the file */         end;      end; /* of copying system files */      dest = 6; /* restore destination to top level catalog of W0 */   end; /* of we got the music printing disk */end; /* of installing music printing *//* $page *//* The Enhanced Velocity/Pressure keyboard has a separate file which   contains the pressure calibration data for the keyboard.  This file is   sent to the customer with the keyboard on a separate superfloppy   diskette.  This file must be installed into .SYSTEM. */if keyboard_type = 3 then do; /* if they have the enhanced VPk */   call enter_catalog (system_cat, 6); /* enter system catalog (W0) */   if not locate (VPk_file, 6) then do; /* only put the file there if it is not there already */      if get_disk ('Enhanced Keyboard Calibration Disk', VPk_file) then do; /* get the disk */         dest = 1; /* set system catalog as destination */         call copy_file (VPk_file, buf, buf.len); /* copy the file to system catalog */         dest = 6; /* set this back to top-level */      end;   end; /* of installing the calibration data */end;/* Now install any timbres/sequences/demos the user wants installed. */if synclavier then do; /* only do all this if we're installing on a synclavier */   print;   print 'Installing Synclavier (R) Timbre Banks will erase any timbres';   print 'currently saved on the top-level of your Winchester disk.';   if ask ('Do you want to install Synclavier (R) Timbre Banks [Y(es) or N(o)]? ') then do;      if get_disk ('diskette containing timbres', '.NEWDATA') /* get the disk */      then call copy_file ('.NEWDATA', buf, buf.len); /* copy the file */   end; /* of installing timbres */   print;   print 'Installing Synclavier (R) sequences will erase any sequences';   print 'currently saved on the top-level of your Winchester disk.';   if ask ('Do you want to install Synclavier (R) sequences [Y(es) or N(o)]? ') then do;      if get_disk ('diskette containing sequences', sequence) /* get the disk */      then do i = 0 to 7; /* loop over possible names */         call pbyte(sequence, 3, a.0 + i); /* form name */         if locate (sequence, 2) /* if there */         then call copy_file (sequence, buf, buf.len); /* copy it */      end; /* of looping over possible names on sequence disk */      print;      if ask ('Do you want to create additional sequence files? ')      then do i = 0 to 7; /* loop over possible names */         call pbyte(sequence, 3, a.0 + i); /* form name */         if not locate (sequence, 6) then do; /* create it */            print 'Creating file:  ', string(sequence);            if not replace (sequence, t#sync, 0, 125, shl(125, 8), 6)            then print '*** Not enough room on your Winchester disk to create file:  ', string(sequence);         end;      end;   end; /* of asking to install sequences */   print;   if ask ('Do you want to install the SCRIPT Demo Files/Sequences? ') then do;      if get_disk ('SCRIPT Demo Files/Sequences', 'SCRPTCAT') then do; /* get the disk */         call copy_file ('SCRPTCAT', buf, buf.len); /* copy the file */      end; /* of got the disk */   end; /* of installing SCRIPT demo sequences */end; /* of installing on a synclavier system */if valid_defaults then do; /* replace the valid AEE default data */   if locate (defaults_tree, 6) then do; /* find new default file */      call writedata (f#ms_sector, f#ls_sector, defaults_buf, shl(Info#Sectors.Used, 8)); /* write out the valid sectors */   end;end;/* $page */print;print string (rel.version), ' is now installed on your system.';print;print 'You should use the CONFIGUR program to check your system configuration.';print;print 'Use the Winchester Bootload Diskette to activate ', string (rel.version), '.';if synclavier then do; /* wipe out all possible LOC.MAGICs */   do i = 40 to sync_memsiz - 1 by 8; /* multiples of 8 starting at 40K */      mem.siz = i*1024;       core(loc.magic) = 0; /* zap next loc */   end;   mem.siz = 60*1024; /* must get rid of what's at 60K, too */   core(loc.magic) = 0; /* zap it */   mem.siz = memory.size;end;core(loc.magic) = 0; stop; /* make sure we look up new .WORK on restart and halt */