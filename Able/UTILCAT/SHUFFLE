/* SHUFFLE  $TITLE  Shuffle Utility *//* Modification History:.    15 Jun 1981 - Created this non-verbose version (CJ).    16 Dec 1981 - Modified for XPL/4, added screen-clear capability..                  Cleaned it up a bit, and made it possible to shuffle.                  any system attached (JEO).    27 Sep 1982 - added COLLECT system for sound files (JSR).    27 Jul 1983 - disallowed tape usage, fixed test in SLIDE.FILE (KJC and CJ).    01 Nov 1983 - forced reboot after SHUFFLE termination (KJC).    05 Jul 1984 - fixed COLLECT bugs, no boot after SHUFFLE in subcat (TSS and KJC).    15 Dec 1984 - changed menu structure, added -6 changes (JSR).    17 May 1985 - added ordered COLLECT (KJC).    25 Apr 1986 - updated for -7 catalog change (LSS).    19 Nov 1987 - added poly cache flag check (KJC).    10 May 1988 - added macintosh support (KJC).    29 Jul 1988 - non interactive version on -q (MWH)*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:termut';   /* terminal utilities */insert ':-xpl:catrtns';  /* catalog routines */insert ':-xpl:devutil';  /* device handlers */insert ':-xpl:catutil';  /* catalog utilities */insert ':-xpl:whendisk'; /* special ERROR handling */insert ':-xpl:strings';  /* string handling */insert ':-xpl:scanargs'; /* cmd line args *//* global variables */dcl quiet         fixed;dcl quiet_done    fixed;dcl entry_max literally 'c#dir_max/c#len'; /* maximum catalog entries */dcl disk.level    fixed; /* level number of device to shuffle */dcl collect.flag  boolean; /* true if COLLECT mode is active */dcl ms.max.sec    fixed; /* total number of sectors on disk to shuffle */dcl ls.max.sec    fixed;dcl fcb (f#len-1) fixed; /* file data array */dcl #fcbs         fixed; /* number of catalog entries (32 or 128) */dcl collect                                  fixed; /* number of files to collect (zero if none)	*/dcl ms.collect.sec                           fixed; /* number of sectors needed for collect 		*/dcl ls.collect.sec                           fixed;dcl collect.nam ((f#name_len*entry_max) - 1) fixed; /* FCB numbers of files to collect				*/ dcl buflen       lit '(18*1024)';					/* make a large buffer less than 20k			*/dcl buf (buflen) fixed;								/* work buffer 									*/dcl catalog (c#dir_max - 1) fixed; /* catalog buffer */dcl breakset        boolean; /* true if BREAK key was struck */dcl ms.error.sector fixed; /* sector where a read or write error occurred */dcl ls.error.sector fixed;dcl validity.flag fixed; /* DEBUG code for validity errors in Beta test of -7 software *//* $page */check.break: proc returns (boolean); /* returns TRUE if the user hit BREAK */   dcl get.out boolean;   get.out = false; /* assume user does not want to break */   ckread; /* check terminal for input */   do while not term_idle; /* there is something in type ahead buffer */      if rchar = 0 then get.out = true; /* the BREAK key was hit */   end;   if get.out then return (true); /* user wants to BREAK out of program */   else return (false); /* no BREAK key found */end check.break;/* This procedure checks to see if the catalog operation being.  performed invalidates the poly cache.  Basically, if a sound.  file or subcatalog is being operated on, the poly cache is.  considered invalid.  The file TYPE of the file being affected.  is passed. */check_polycache: proc(type); /* trash poly cache if necessary */   dcl type fixed; /* type of file being operated upon */   if core(loc.emsize) <> 0 then do; /* no poly cache if no external memory */      if ((type = t#sound) or (type = t#lsubc) or (type = t#subc)) /* if sound file or subcatalog */      then call extset (core(loc.emarea), em.polycache, 1, false); /* invalidate the cache */   end; /* of have external memory */end check_polycache;print.filename:  proc (fcb); /* print out filename from an FCB */   dcl fcb              array; /* file data */   dcl nam (f#name_len) fixed; /* array to hold name */   dcl i                fixed;   call clean_fcbname (fcb, nam); /* extract filename from FCB */   pstring (nam); /* print filename */end print.filename;disk.error:  proc (string); /* print instructions for a disk error */   dcl string fixed array; /* either "reading" or "writing" */   wchar (a.bel); crlf; crlf;    pstringr ('*****************************************************');    pstringr ('                SHUFFLE DISK ERROR                   ');   pstringr ('*****************************************************'); crlf;   pstring  ('   An error was detected '); pstring (string); pstringr (' this disk.'); crlf;   pstringr ('   All the files should be okay, but before writing');   pstringr ('   any more data you should backup all files and');   pstringr ('   FORMAT this disk using the FORMCOPY utility');   pstringr ('   program.  If you do not do this, more errors');   pstringr ('   will occur and data will be lost.'); crlf; crlf;end disk.error;/* $page */fatal.error: proc (string, fcb); /* prints message for unrecoverable file error */   dcl string fixed array; /* either "reading" or "writing" */   dcl fcb    fixed array; /* file that could not be recovered */   wchar (a.bel); crlf; crlf;    pstringr ('***************************************************** ');    pstringr ('                SHUFFLE DISK ERROR                    ');   pstringr ('***************************************************** '); crlf;   pstring  ('   A fatal error was detected '); pstring (string); pstringr (' this disk.'); crlf;   pstring  ('   File '); call print.filename (fcb); pstringr (' is probably partially or totally');   pstringr ('   destroyed.'); crlf;   pstringr ('   Before writing any more data to this disk, you');   pstringr ('   should backup all other files and FORMAT this');   pstringr ('   disk using the FORMCOPY utility program.');    pstringr ('   If you do not do this, more errors will occur');    pstringr ('   and data will be lost.'); crlf; crlf;end fatal.error;check.disk:  proc (ms.start, ls.start, ms.secs, ls.secs) returns (fixed); /* read destination area */   dcl (ms.start, ls.start) fixed; /* starting sector */   dcl (ms.secs, ls.secs)   fixed; /* total length to read */   dcl (chunk, j)           fixed;   breakset = false; /* assume no BREAK desired */   pstringr ('   Checking disk areas');   do while (((ms.secs igt 0) or ((ms.secs = 0) and (ls.secs igt 0))) and not breakset); /* do until all sectors checked */      if check.break then breakset = true; /* BREAK key was struck */      if not breakset then do; /* no BREAK key so go ahead */         chunk = shr(buflen, 8); /* chunk is size of buffer */         if ((ms.secs = 0) and (ls.secs ilt shr(buflen, 8))) then chunk = ls.secs; /* or chunk is what's left to check */         call disk.io.setup; /* set up in case of error */         if (c#ls_sector + ls.start) ilt c#ls_sector then j = 1; else j = 0; /* carry */         call readdata (c#ms_sector + ms.start + j, c#ls_sector + ls.start, buf, shl(chunk, 8));         if (disk.io.cleanup()) then do; /* error reading destination area */            call disk.error ('reading'); /* print error instructions */            return (1); /* error status for a read error */         end;         ls.start = ls.start + chunk; /* update the starting point */         if ls.start ilt chunk then ms.start = ms.start + 1; /* carry */         if ls.secs ilt chunk then ms.secs = ms.secs - 1; /* borrow */         ls.secs = ls.secs - chunk; /* decrease total left to check */      end;   end;   return (0); /* good status returned */end check.disk; /* $page */sort.cat:  proc returns (fixed); /* sort by starting sector and delete trailing holes */   dcl zblk (f#len - 1)       fixed; /* null FCB */   dcl (fcb1, fcb2) (f#len-1) fixed; /* FCB arrays for file data */   dcl fcb_num                fixed; /* number of used FCBs in catalog */   dcl (small, i, j, n)       fixed;    do i = 0 to f#len - 1; zblk (i) = 0; end; /* create a null FCB */   pstringr ('   Sorting catalog');   call findmax; 					/* consolidates free blocks in the catalog */   j = -1;							/* destination pointer */   do i = 0 to #fcbs - 1;			/* move all used FCBs to the front of the catalog */      call get_fcb (i, fcb1);		/* get an FCB */      call put_fcb (i, zblk);		/* zero out the source block */      if (fcb1(f#nm) <> 0) or (fcb1(f#ml) <> 0) or (fcb1(f#ll) <> 0) then do; /* either name or length is there */         j = j + 1; 				/* point to next location */         if fcb1(f#nm) = 0 then do; /* found a free block */            fcb1(f#wd) = 0; fcb1(f#ty) = 0; /* no word length or type */            do n = 1 to f#name_len - 1; fcb1(f#nm + n) = 0; end; /* zero name completely */         end; /* free block */         if (fcb1(f#ml) = 0 and fcb1(f#ll) = 0) then do; /* no length, so zero starting sector */            fcb1(f#ms) = 0; fcb1(f#ls) = 0;          end;         call put_fcb (j, fcb1);	/* write FCB back out */      end;   end;    fcb_num = j + 1;					/* save the number of used FCBs in the catalog */   do i = 0 to fcb_num - 1;			/* sort FCBs by origin (selection sort) */      small = i;					/* assume FCB at index i is the smallest */      call get_fcb (small, fcb1);	/* get this FCB */      do j = i + 1 to fcb_num - 1;	/* check the rest of the FCBs */         call get_fcb (j, fcb2);	/* get FCB at index j */         if ((fcb2(f#ms) ilt fcb1(f#ms)) or /* if second FCB occurs earlier than first */         (fcb2(f#ms) = fcb1(f#ms) and fcb2(f#ls) ilt fcb1(f#ls))) then do;            small = j;				/* update the smallest */            call get_fcb (j, fcb1); /* put the new smallest FCB into fcb1 */         end;      end;      call get_fcb (i, fcb2); /* swap FCBs */      call put_fcb (small, fcb2); /* put first file in small's location */      call put_fcb (i, fcb1); /* put smallest in first position */   end;   return (fcb_num); /* return number of used FCBs */end sort.cat;/* $page */move:  proc (ms.source, ls.source, ms.dest, ls.dest, ms.secs, ls.secs, breakflag) returns (fixed); /* copies a block of data */   dcl (ms.source, ls.source) fixed; /* starting sector of file to transfer */   dcl (ms.dest, ls.dest)     fixed; /* starting sector of destination hole */   dcl (ms.secs, ls.secs)     fixed; /* total sectors to move */   dcl (ms.count, ls.count)   fixed; /* sectors left to move */   dcl breakflag              boolean; /* true if BREAK should be checked */   dcl (chunk, j)             fixed;       ms.error.sector = 0; ls.error.sector = 0; /* no error yet */   ms.count = ms.secs; /* initilize sector counter to total sectors */   ls.count = ls.secs;   do while ((ms.count igt 0) or ((ms.count = 0) and (ls.count igt 0))); /* do until finished */      if breakflag then if check.break then return (1); /* BREAK out of program */      chunk = shr(buflen, 8); /* chunk is size of buffer */      if ((ms.count = 0) and (ls.count ilt shr(buflen, 8))) then chunk = ls.count; /* or chunk is what's left to copy */      call disk.io.setup; /* set up in case of error */      if (c#ls_sector + ls.source) ilt c#ls_sector then j = 1; else j = 0; /* carry */      call readdata (c#ms_sector + ms.source + j, c#ls_sector + ls.source, buf, shl(chunk, 8));      if (disk.io.cleanup()) then do;         ms.error.sector = (c#ms_sector and "377") + ms.source + j; /* save start of buffer that caused error (can't tell exactly what sector is bad) */         ls.error.sector = c#ls_sector + ls.source;           return (2); /* return read error status */      end;      call disk.io.setup;      if (c#ls_sector + ls.dest) ilt c#ls_sector then j = 1; else j = 0; /* carry */      call writedata (c#ms_sector + ms.dest + j, c#ls_sector + ls.dest, buf, shl(chunk, 8));      if (disk.io.cleanup()) then do;         ms.error.sector = (c#ms_sector and "377") + ms.source + j; /* save start of buffer that caused error (can't tell exactly what sector is bad) */         ls.error.sector = c#ls_sector + ls.source;         return (3); /* return write error status */      end;      ls.source = ls.source + chunk; /* update source start */      if ls.source ilt chunk then ms.source = ms.source + 1; /* carry */      ls.dest = ls.dest + chunk; /* update destination start */      if ls.dest ilt chunk then ms.dest = ms.dest + 1; /* carry */      if ls.count ilt chunk then ms.count = ms.count - 1; /* borrow */      ls.count = ls.count - chunk; /* decrease count by chunk just transferred */   end;   return (0); /* no error */ end move;/* $page */back.move:  proc (ms.source, ls.source, ms.dest, ls.dest, ms.secs, ls.secs, breakflag) returns (fixed); /* copies a block of data backwards after an error */   dcl (ms.source, ls.source) fixed; /* end of source section */   dcl (ms.dest, ls.dest)     fixed; /* end of destination hole */   dcl (ms.secs, ls.secs)     fixed; /* total sectors to move */   dcl (ms.count, ls.count)   fixed; /* sectors left to move */   dcl breakflag              boolean; /* true if BREAK should be checked */   dcl (chunk, j)             fixed;       ms.count = ms.secs; /* initilize sector counter to total sectors */   ls.count = ls.secs;   do while ((ms.count igt 0) or ((ms.count = 0) and (ls.count igt 0))); /* do until finished */      if breakflag then if check.break then return (1); /* BREAK out of program */      chunk = shr(buflen, 8); /* chunk is size of buffer */      if ((ms.count = 0) and (ls.count ilt shr(buflen, 8))) then chunk = ls.count; /* or chunk is what's left to copy */      call disk.io.setup; /* set up in case of error */      if (c#ls_sector + ls.source) ilt chunk then j = 1; else j = 0; /* carry */      call readdata (c#ms_sector + ms.source - j, c#ls_sector + ls.source - chunk, buf, shl(chunk, 8));      if (disk.io.cleanup()) then return (2); /* error on a read */      call disk.io.setup; /* set up in case of error */      if (c#ls_sector + ls.dest) ilt chunk then j = 1; else j = 0; /* carry */      call writedata (c#ms_sector + ms.dest - j, c#ls_sector + ls.dest - chunk, buf, shl(chunk, 8));      call disk.io.cleanup;      if (disk.io.cleanup()) then return (3); /* error on a write */      if ls.source ilt chunk then ms.source = ms.source - 1; /* borrow */      ls.source = ls.source - chunk; /* update source start */      if ls.dest ilt chunk then ms.dest = ms.dest - 1; /* borrow */      ls.dest = ls.dest - chunk; /* update destination start */      if ls.count ilt chunk then ms.count = ms.count - 1; /* borrow */      ls.count = ls.count - chunk; /* decrease count by chunk just transferred */   end;   return (0); /* no error */ end back.move;/* $page */move.file:  proc (hole, sour) returns (fixed); /* move an exact fit file */   dcl (hole, sour)               fixed; /* FCB numbers (dest, source) */   dcl (fcb1, fcb2) (f#len-1)     fixed; /* FCB data arrays */   dcl (status, ms.temp, ls.temp) fixed;    call get_fcb (hole, fcb1); /* get FCB of hole */   call get_fcb (sour, fcb2); /* get FCB of file to be moved */   status = check.disk (fcb1(f#ms), fcb1(f#ls), fcb2(f#ml), fcb2(f#ll));  /* verify that destination can be read (and hopefully written) */   if breakset then return (1); /* if BREAK was struck, get out */   if status <> 0 then return (1); /* error reading disk, BREAK out of program */   pstring ('   Moving file '); call print.filename (fcb2); crlf;   call check_polycache (fcb2 (f#ty)); /* zap polycache if necessary */   status = move (fcb2(f#ms), fcb2(f#ls), fcb1(f#ms), fcb1(f#ls), fcb2(f#ml), fcb2(f#ll), true); /* move the file */         do case (status); /* do according to how the MOVE went */      do; /* 0: good status */         ms.temp = fcb2(f#ms); ls.temp = fcb2(f#ls); /* swap the starting sector in the FCBs */         fcb2(f#ms) = fcb1(f#ms); fcb2(f#ls) = fcb1(f#ls);         fcb1(f#ms) = ms.temp; fcb1(f#ls) = ls.temp;         call put_fcb (hole, fcb1); /* write out the new FCBs */         call put_fcb (sour, fcb2);      end;      return (1); /* 1: BREAK key was struck while moving the file */      do; /* 2: error reading the file from the disk */         wchar (a.bel); pstring ('*** Could not read file ');         call print.filename (fcb2); crlf; return (2);      end;       do; /* 3: error writing the file to disk */         call disk.error ('writing'); return (3); /* print error instructions */      end;   end; /* do case status */   return (0); /* move completed with good status */end move.file;/* $page */exact.fit:  proc (hole) returns (fixed); /* find a file that fits this hole exactly */   dcl hole                   fixed; /* FCB number of hole to be filled */   dcl match                  boolean; /* true if file is a collect file */   dcl (fcb1, fcb2) (f#len-1) fixed; /* FCB data arrays */   dcl (i, j, k)              fixed;   call get_fcb (hole, fcb1); /* get the FCB of the hole */   do i = hole + 1 to #fcbs - 1; /* start searching for a file */      call get_fcb (i, fcb2); /* get an FCB */      if fcb2(f#nm) <> 0 then do; /* if this is not a free block */         match = false; /* assume file is not a collect file */         if collect > 0 then do; /* make sure file is not a collect file */            j = -1; /* start at the beginning of the catalog */            do while ((j < collect - 1) and (not match)); /* do until done or match found */               j = j + 1; /* advance to next FCB */               match = true; /* assume file is a collect file */               do k = 0 to f#name_len - 1; if collect.nam (j*f#name_len + k) <> fcb2 (f#nm + k) then match = false; end; /* not a collect file */            end; /* check of collected files */         end;         if not match then do; /* check if file is length of hole */            if ((fcb2(f#ml) = fcb1(f#ml)) and (fcb2(f#ll) = fcb1(f#ll))) /* file is exactly the size of the hole */            then return (i); /* FCB number of exact fit file */         end;      end; /* if not free block */   end; /* search for a file */   return (-1); /* no exact fit found */end exact.fit;transfer.file:  proc (dest, sour) returns (fixed); /* transfer a file to temporary collect area */   dcl (dest, sour)           fixed; /* FCB numbers */   dcl (fcb1, fcb2) (f#len-1) fixed; /* FCB data arrays */   dcl nam (f#name_len - 1)   fixed; /* array to hold name */   dcl (status, i)            fixed;    call get_fcb (dest, fcb1); /* get destination place */   call get_fcb (sour, fcb2); /* get file to move there */   pstring ('   Moving file '); call print.filename (fcb2); pstringr (' to collect area');   call check_polycache (fcb2 (f#ty)); /* zap polycache if necessary */   status = move (fcb2(f#ms), fcb2(f#ls), fcb1(f#ms), fcb1(f#ls), fcb2(f#ml), fcb2(f#ll), true); /* move the file */         do case (status); /* do according to how the MOVE went */      do; /* 0: good status */         do i = 0 to f#name_len - 1; nam (i) = fcb2(i); fcb2(i) = 0; end; /* zero name in source FCB */         call put_fcb (sour, fcb2); /* write out to source FCB slot */         do i = 0 to f#name_len - 1; fcb2(i) = nam(i); end; /* restore name */         fcb2(f#ms) = fcb1(f#ms); fcb2(f#ls) = fcb1(f#ls); /* shift the starting sector data */         call put_fcb (dest, fcb2); /* write FCB into dest slot */         fcb1(f#ml) = fcb1(f#ml) - fcb2(f#ml); /* adjust dest FCB sector length */         if fcb1(f#ll) ilt fcb2(f#ll) then fcb1(f#ml) = fcb1(f#ml) - 1;         fcb1(f#ll) = fcb1(f#ll) - fcb2(f#ll);         fcb1(f#ms) = fcb1(f#ms) + fcb2(f#ml); /* adjust dest FCB starting sector */         fcb1(f#ls) = fcb1(f#ls) + fcb2(f#ll);         if fcb1(f#ls) ilt fcb2(f#ll) then fcb1(f#ms) = fcb1(f#ms) + 1;               call put_fcb (dest + 1, fcb1); /* write it out */      end;      return (1); /* 1: the BREAK key was struck */      do; /* 2: error reading the file from the disk */         wchar (a.bel); pstring ('*** Could not read file ');         call print.filename (fcb2); crlf; return (2);      end;       do; /* 3: error writing the file to the disk */         wchar (a.bel); return (3);      end;   end;   return (0); /* good status */end transfer.file;/* $page */slide.file:  proc (hole) returns (boolean); /* slides a file down the disk */   dcl hole                   fixed; /* FCB number of hole to slide to */   dcl (fcb1, fcb2) (f#len-1) fixed; /* FCB data arrays */   dcl (ms.mins, ls.mins)     fixed; /* size of block to move the first time */   dcl (ms.more, ls.more)     fixed; /* size of move the second time */   dcl status                 fixed; /* 0- OK, 1- bad file, 2- bad disk sector */   dcl thefile						fixed;	dcl (msb, lsb)					fixed;   dcl (i, j)                 fixed;   recover: proc (error) returns (boolean); /* recovers the overwritten part of file */      dcl error            fixed; /* 2- read error, 3- write error */      dcl overwrite        boolean; /* true if overwrite occurred */      dcl stat             fixed; /* status return from back.move */      dcl (ms.src, ls.src) fixed; /* ending sector of source block */      dcl (ms.dst, ls.dst) fixed; /* ending sector of destination hole */      dcl (ms.lgt, ls.lgt) fixed; /* length of block to recover */      overwrite = false; /* assume no overwrite */      if (((error = 2) and ((ms.error.sector > fcb2(f#ms) + ms.mins) or /* check if file overwritten - first for read error */         ((ms.error.sector = fcb2(f#ms) + ms.mins) and (ls.error.sector > fcb2(f#ls) + ls.mins)))) or         ((error = 3) and ((ms.error.sector > fcb2(f#ms)) or /* then for write error */         ((ms.error.sector = fcb2(f#ms)) and (ls.error.sector > fcb2(f#ls)))))) then overwrite = true;      if overwrite then do; /* the file has overwritten part of itself */         pstring ('   Recovering file '); call print.filename (fcb2); crlf;         if error = 2 then do; /* read error */            ms.dst = ms.error.sector; /* set destination start where error occurred */            ls.dst= ls.error.sector;            ms.src = ms.dst - ms.mins; /* set source start */            if ls.dst ilt ls.mins then ms.src = ms.src - 1;            ls.src = ls.dst - ls.mins;         end;         else if error = 3 then do; /* write error */            ms.src = ms.error.sector; /* set source start where error occurred */            ls.src = ls.error.sector;            ms.dst = ms.src + ms.mins; /* set destination start */            ls.dst = ls.src + ls.mins;            if ls.dst ilt ls.src then ms.dst = ms.dst + 1;         end;         ms.lgt = ms.src - fcb1(f#ms); /* set the length of segment to move back */         ls.lgt = ls.src - fcb1(f#ls);         stat = back.move (ms.src, ls.src, ms.dst, ls.dst, ms.lgt, ls.lgt, false); /* recover file if possible */         if (stat = 2) then do; /* read error */            call fatal.error ('reading', fcb2); /* if error now, can't recover */            return (false);         end;         else if (stat = 3) then do; /* write error */            call fatal.error ('writing', fcb2); /* if error now, can't recover */            return (false);         end;      end;      return (true); /* recover was successful */   end recover;   if (hole >= #fcbs)									/* handle gross system error withtout crashing...				*/		return (4);											/* hole is at the end of directory									*/   call get_fcb (hole, fcb1);							/* get FCB of hole														*/		thefile = hole + 1;									/* next block is presumably the file we need to slide			*/	if (thefile == #fcbs)								/* if no file is after us, check for clearing out hole		*/	{		if ((c#ms_sector == shl(6, 8) && c#ls_sector == 0)		/* if shuffle of W0 or W1, clean out trailing	*/		||  (c#ms_sector == shl(7, 8) && c#ls_sector == 0))	/* blocks to simplify concatenation problems		*/		{			do i = 0 to f#len - 1; fcb1 (i) = 0; end;				/* create a null FCB										*/					call put_fcb(hole, fcb1);						return (0);										/* successful shuffle													*/		}				return (6);											/* at end; do nothing...												*/	}	   call get_fcb (thefile, fcb2);						/* get FCB of file that presumably sits after this hole		*/   	while ((fcb2 [f#nm] == 0)							/* if next file is a hole ...											*/	&&     (fcb2 [f#ml] != 0 || fcb2 [f#ll] !=0)	/* that has some storage ...											*/	&&     (thefile < #fcbs))							/* and there is yet another block after it						*/	{		fcb1 (f#ml) = fcb1 (f#ml) + fcb2 (f#ml);	/* add the two free blocks together, at least for now			*/		fcb1 (f#ll) = fcb1 (f#ll) + fcb2 (f#ll);		if (fcb1 (f#ll) ILT fcb2 (f#ll))			fcb1 (f#ml) = fcb1 (f#ml) + 1; 				thefile = thefile + 1;				if (thefile < #fcbs)	   	call get_fcb (thefile, fcb2);				/* get FCB of file that presumably sits after this hole		*/	}		if ((thefile     == #fcbs)							/* if at end of directory (either by reaching limit or by	*/	||  (fcb2 [f#nm] == 0    ))						/* finding a totally empty block)									*/	{															/* we are done; clean out trailing holes if need to do so	*/		if ((c#ms_sector == shl(6, 8) && c#ls_sector == 0)		/* if shuffle of W0 or W1, clean out trailing	*/		||  (c#ms_sector == shl(7, 8) && c#ls_sector == 0))	/* blocks to simplify concatenation problems		*/		{			while (hole < thefile)						/* clean out hole and all trailing holes							*/			{				do i = 0 to f#len - 1; fcb1 (i) = 0; end;							call put_fcb(hole, fcb1);							hole = hole + 1;			}						return (0);										/* successful shuffle													*/		}				return (6);											/* at end; do nothing...												*/	}	   status = check.disk (fcb1(f#ms), fcb1(f#ls), fcb2(f#ml), fcb2(f#ll));  /* verify that destination can be read (and hopefully written) */   if breakset then return (1);						/* if BREAK was struck, get out */   if status = 1 then return (1);					/* error reading disk, BREAK out of program */   /* move a section the size of the hole or the file length, whichever */   /* is smaller, as this leaves the file in better shape in case of error */   ms.mins = fcb1(f#ml); ls.mins = fcb1(f#ll); /* set minimum length to the size of the hole */   if (ms.mins igt fcb2(f#ml)) or ((ms.mins = fcb2(f#ml)) and (ls.mins igt fcb2(f#ll))) then do; /* if file to move is smaller than hole */      ms.mins = fcb2(f#ml); ls.mins = fcb2(f#ll); /* set the minimum length to size of file */   end;   pstring ('   Sliding file '); call print.filename (fcb2); crlf;   call check_polycache (fcb2 (f#ty)); /* zap polycache if necessary */   status = move (fcb2(f#ms), fcb2(f#ls), fcb1(f#ms), fcb1(f#ls), ms.mins, ls.mins, true);   do case (status); /* do according to how the MOVE went */      do; /* 0: good status, so continue */         if (ms.mins ilt fcb2(f#ml)) or ((ms.mins = fcb2(f#ml)) and (ls.mins ilt fcb2(f#ll))) then do; /* more to do */            ms.more = fcb2(f#ml);					/* get amount left to do */            if fcb2(f#ll) ilt ls.mins then ms.more = ms.more - 1; /* borrow */            ls.more = fcb2(f#ll) - ls.mins;           		    	pstring ('   Sliding remainder of file '); call print.filename(fcb2); crlf;           		    	if (fcb2(f#ls) + ls.mins) ilt fcb2(f#ls) then j = 1; else j = 0; /* carry */            if (fcb1(f#ls) + ls.mins) ilt fcb1(f#ls) then i = 1; else i = 0; /* carry */            				status  = move (fcb2(f#ms) + ms.mins + j, fcb2(f#ls) + ls.mins, fcb1(f#ms) + ms.mins + i,                             fcb1(f#ls) + ls.mins, ms.more, ls.more, false);           		    	do case (status); /* do according to how the MOVE went */               ; /* 0: no error returned */               ; /* 1: BREAK not valid in when sliding remainder of file */               do; /* 2: error reading the file from the disk */                  wchar (a.bel); pstring ('*** Could not read file ');                  call print.filename (fcb2); crlf;                   if recover (status) then return (2); /* copy the file back if necessary */                  else return (5); /* couldn't recover the file */               end;                do; /* 3: error writing the file */                  wchar (a.bel); pstring ('*** Could not write file ');                  call print.filename (fcb2); crlf;                  if recover (status) then do; /* copy the file back */                     call disk.error ('writing'); /* print error instructions */                     return (3); /* BREAK out of the program */                  end;                  else return (5); /* couldn't recover the file */               end;            end; /* do case */         end; /* if more to do */      end;      return (1); /* 1: BREAK key was struck */      do; /* 2: error reading the file from the disk */         wchar (a.bel); pstring ('*** Could not read file ');         call print.filename (fcb2); crlf; return (2);      end;       do; /* 3: error writing the file to the disk */         call disk.error ('writing'); return (3); /* print error instructions */      end;   end; /* do case status */         /* update the FCB data */   fcb2(f#ms) = fcb1(f#ms); fcb2(f#ls) = fcb1(f#ls);	/* file now starts where the hole did			*/   fcb1(f#ms) = fcb2(f#ms) + fcb2(f#ml);					/* hole now starts after the file (start + length) */   fcb1(f#ls) = fcb2(f#ls) + fcb2(f#ll);					/* but note that it's length did not change. */   if fcb1(f#ls) ilt fcb2(f#ll) then fcb1(f#ms) = fcb1(f#ms) + 1; /* carry */   	/* put the files FCB where the hole's was.  Then synthesize huge holes as needed.  Thens tore	*/	/* the remaining hole, or null out where the file's fcb used to be, as needed							*/		call put_fcb (hole,  fcb2);								/* put the files fcb where the holes fcb was */	hole = hole + 1;												/* advance to where to put the hole				*/		while (fcb1 [f#ml] IGE 0x0010)							/* synth 512 meg holes as needed					*/	{		msb = fcb1 [f#ml] - 0x000F;							/* compute how much hole will be left after	*/		lsb = fcb1 [f#ll] - 0xFFFF;							/* we synth a 512 meg hole							*/		if (fcb1 [f#ll] ILT 0xFFFF)			msb = msb - 1;				fcb1 [f#ml] = 0x000F;									/* synth a length of 512 megs						*/		fcb1 [f#ll] = 0xFFFF;				call put_fcb(hole, fcb1);								/* store that											*/				fcb1 [f#ms] = fcb1 [f#ms] + 0x000F;					/* compute start of next hole						*/		fcb1 [f#ls] = fcb1 [f#ls] + 0xFFFF;		if (fcb1 [f#ls] ILT 0xFFFF)			fcb1 [f#ms] = fcb1 [f#ms] + 1;					fcb1 [f#ml] = msb;										/* and store remaining length of hole			*/		fcb1 [f#ll] = lsb;				hole = hole + 1;											/* and advance to where to store it				*/	}	call put_fcb(hole, fcb1);									/* store hole											*/	hole = hole + 1;		while (hole <= thefile)										/* might have to null out last block if		*/	{																	/* two huge holes can now fit in one			*/		do i = 0 to f#len - 1; fcb1 (i) = 0; end;			/* create a null FCB									*/			call put_fcb(hole, fcb1);		hole = hole + 1;	}    	return (0);														/* slide was completed								*/   end slide.file;/* $page */find.hole:  proc (start) returns (fixed); /* find next free FCB if there is one */   dcl start          fixed; /* start looking from this FCB */   dcl fcb1 (f#len-1) fixed; /* FCB data array */   dcl i              fixed;   do i = start to #fcbs - 1; /* search through FCBs */      call get_fcb (i, fcb1); /* get an FCB */      if ((fcb1(f#nm) = 0) and ((fcb1(f#ml) <> 0) or (fcb1(f#ll) <> 0))) then return (i);   end;   return (-1); /* no free hole found */end find.hole; shuffle:  proc returns (fixed); /* shuffle the device */   dcl files            fixed; /* number of used FCBs in catalog */   dcl max.pos          fixed; /* last used FCB in catalog */   dcl fcb1 (f#len-1)   fixed; /* FCB data array */   dcl nam (f#name_len) fixed; /* name of collect file */   dcl status           fixed;   dcl (i, j, k)        fixed;   do.shuffle:  proc returns (boolean); /* do the shuffle */      dcl start       fixed; /* FCB number to start from */      dcl (hole, fit) fixed; /* hole FCB, exact fit FCB */      dcl stat        fixed; /* status returned */      start = 0;      do while ((start < files) and (start <> -1));	/* loop over file entries */         			hole = find.hole (start);							/* look for a hole */         			if hole <> -1 then do;								/* found a hole to fill */            				/* look for a file after this that we can copy down into this hole */								fit = exact.fit (hole);							/* look for an exact fit file after the hole */           			   if fit <> -1 then do;							/* exact fit file found */               stat = move.file (hole, fit);				/* move the exact fit file */               do case (stat);                  do; /* 0: good status */                     call write_catalog; /* keep catalog info up to date */                     files = sort.cat;                  end;                  return (true); /* 1: BREAK key was struck */                  hole = hole + 1; /* 2: can't read the file, advance past that hole */                  return (true); /* 3: error on a write, BREAK out */               end;            end;            				/* if no exact fit, find following file to slide down... */							else do;											/* no exact fit file */            						stat = slide.file (hole);				/* try to slide a file up */               					do case (stat);                  do;										/* 0: good status */                     call write_catalog;				/* keep catalog info up to date */                     if check.break then return (true); /* BREAK key was struck during slide */                     files = sort.cat;					/* sort the catalog */                  end;                  return (true); /* 1: BREAK key was struck */                  hole = hole + 1; /* 2: can't read a file, advance past that hole */                  return (true); /* 3: error on a write, BREAK out */                  do; /* 4: hole is already at end of directory */                     if validity.flag > 30 then do; /* done the loop too many times - catalog is messed up */                        wchar (a.bel); crlf;                        pstringr ('Suspected validity error in catalog!');                        pstringr ('Re-boot the system and check the free blocks for errors.');                        return (true);                     end;                  end;                  return (true);		/* 5: couldn't recover partially copied file */						hole = hole + 1;	/* 6: holes at end of catalog; move on...		*/               end;            end; /* no exact fit file */         			end; /* found a hole to fit */						start = hole; /* start here next time */      		end; /* of start loop */      return (false); /* no need to BREAK out */   end do.shuffle;   call read_catalog ('', disk.level); /* get the catalog */   files = sort.cat; /* sort and clean it up */   call write_catalog; /* keep catalog info up to date */   if check.break then return (0); /* check for BREAK key *//* $page */   if collect <> 0 then do; /* we need to do a collect */      k = findstorage (ms.collect.sec, ls.collect.sec); /* try to find a block for collect */      if ((k <> files - 1) and (k <> (files))) or ((k + collect) > #fcbs - 1) then do;         if k <> -1 then files = sort.cat; /* sort the catalog */         pstringr ('*** Performing Initial Shuffle to Obtain Space for Collect Files');         if do.shuffle then return (0); /* must shuffle to find space for collect (return if BREAK)*/         k = findstorage (ms.collect.sec, ls.collect.sec); /* try to find a block for collect */      end;      if (k <> -1) and ((k + collect) < #fcbs) then do; /* can transfer collected files */         i = 0;         do while (i < collect); /* loop over files to be moved */            do j = 0 to f#name_len - 1; nam (j + 1) = collect.nam (i*f#name_len + j); end; /* get name */            j = 0; do while ((j < shl(f#name_len, 1)) and (byte(nam, j) <> 0)); j = j + 1; end; nam (0) = j; /* set filename length */            j = findfile (nam); /* get FCB number of file */            status = transfer.file (k, j); /* move file to collect area */            if (status = 1) then return (0); /* BREAK out of program */            else if (status = 3) then do; /* write error */               pstringr ('*** Error writing to COLLECT area, Option Cancelled');               call disk.error ('writing'); /* print error instructions */               return (0); /* BREAK out of the program */            end;            k = k + 1; /* keep track of added FCB */            i = i + 1; /* advance to next collect file */         end;         files = sort.cat; /* resort catalog */         call write_catalog; /* write catalog to disk */      end;      else do; /* can't do the collect */         wchar (a.bel);         pstringr ('*** No Disk Space to Perform COLLECT, Option Cancelled');      end;   end; /* if collect then do */   if do.shuffle then return (0); /* perform final shuffle (return if BREAK) */   max.pos = #fcbs; /* assume maximum number of FCB's */   call write_catalog; /* perform final write of catalog */   if files > 0 then do; /* adjust for sectors used */      call get_fcb (files - 1, fcb1); /* get the last block */      if fcb1(f#nm) = 0 then do; /* if it's a free block */         files = files - 1; /* ignore it - decrease number of files */         max.pos = max.pos - 1; /* and decrease total possible */      end;   end; /* adjust */   crlf; pstringr ('Shuffle completed.'); crlf;   pstring ('Number of files = ');  pnum (files, 0);   pstring (' [max. possible is '); pnum (max.pos, 0); pstringr ('] ');   if files <> 0 then do;      call get_fcb (files - 1, fcb1); /* get last entry */      i = fcb1(f#ms) + fcb1(f#ml); /* compute total sectors used (start + length) */      j = fcb1(f#ls) + fcb1(f#ll);      if j ilt fcb1(f#ls) then i = i + 1; /* carry */      pstring ('Sectors used    = ');  lnum (i, j, 0);      pstring (' [max. possible is '); lnum (ms.max.sec, ls.max.sec, 0); pstringr ('] ');   end;   else pstringr ('No Sectors are used.');end shuffle;/* $SUBTITLE  User Interface:  Menu processing Routines */show.entry:  proc (row); /* write options and info to menu */   dcl row fixed; /* current row on the menu */   pos (10 + row, 53); /* position to field */   do case (row);      do; call name (disk.level); erase_line; end; /* 0:  device */      if collect.flag /* 1:  collect option */      then pstring ('Yes');      else pstring ('No ');   end;end show.entry;process_menu:  proc; /* print and update the menu */   dcl show.menu boolean; /* true if we need to print menu outline */   dcl row       fixed; /* row number of option */   dcl (i,ch)    fixed;   show.menu = true; /* set first time flag */   if quiet = true then show.menu = false;   do forever;      if show.menu then do;         clear_screen;         crlf;         pstring ('S H U F F L E  Utility                       version of '); pstringr(REL.DATE);         pstringr('');          pstringr('    To issue a command, press the key that represents the command.');         pstringr('    To change an option, move the cursor over the option and press');         pstringr('    the space bar or type the new value.');         crlf;         pstringr('-----------------------------------------------------------------------------');         pstringr('COMMANDS:                      |   OPTIONS: ');         pstringr('                               |');         pstringr('C to display Catalog           |   Storage Device: ');         pstringr('Q to Quit (return to system)   |   Collect Mode: ');         pstringr('                               |');         pstringr('RETURN to start shuffle        |');         pstringr('                               |');         pstringr('-----------------------------------------------------------------------------');         cmdline = 16; /* set command line at bottom */         do i = 0 to 1; call show.entry (i); end; /* put up values */         show.menu = false; /* we just put up the outline */      end;      pos (10 + row, 53); /* position to field */      if quiet = false then ch = rchar; /* get input code */      else if quiet_done = false then do;         ch = a.cr;                   /* pretend <CR>   */         quiet_done = true;           /* next time: Q   */      end;      else ch = a.q;                  /* pretend Quit */      if ch = a.cr then do; /* start the shuffle? */         i = disk_check (disk.level); /* make sure there's a floppy disk in the source device */         if not i /* make sure there's a floppy disk in the source device */         then do; pcmd ('Please insert a floppy disk into '); call name (disk.level); pstring (' and try again.'); end;         else if (i and d#protect) <> 0 /* make sure it isn't write-protected */         then do; pcmd ('The floppy disk in '); call name (disk.level); pstring (' is write-protected.'); end;         else return (false); /* yes, we have a floppy - start the run */      end;      else if (ch = a.q) or (ch = l.q) or (ch = a.nul) /* quit or break */      then return (true); /* abort the run */      else if (ch = a.c) or (ch = l.c) then do; /* show catalog */         if not disk_check (disk.level) /* make sure there's a floppy disk in the source device */         then do; pcmd ('Please insert a floppy disk into '); call name (disk.level); pstring (' and try again.'); end;         else do; /* we have a floppy disk */            clear_screen;            call print_catalog (disk.level);            show.menu = true; /* must reprint menu */         end;      end;      else if (ch = cur.up  ) or (ch = a.vt) then row = row - 1; /* cursor moves */      else if (ch = cur.down) or (ch = a.lf) then row = row + 1;      else if ch = a.refresh then show.menu = true; /* refresh display *//* $page */      else if ch = a.sp then do; /* toggle or change */         do case (row);            do; /* 0:  source location */               disk.level = (disk.level mod 7) + 1; /* get next choice */               do while ((find_device (disk.level) = 0)                   or    ((disk.level = 1) and (core(loc.ucat) = 0) and (core(loc.ucat + 1) and "377") = 0));                  disk.level = (disk.level mod 7) + 1; /* get next choice */               end;            end;            collect.flag = collect.flag xor 1; /* 1:  collect option */         end;         call show.entry (row); /* show updated value */      end;      if row < 0 then row = 0; /* limit movement */      if row > 1 then row = 1;   end; /* of do forever */end process_menu;/* $SUBTITLE  User Interface:  Select Files To Collect */select_files: proc returns (boolean); /* select files to collect together */   dcl xref (entry_max - 1)        fixed; /* cross reference printed names to their corresponding FIBs */   dcl file.status (entry_max - 1) fixed; /* whether file is selected or not */   dcl ordered (entry_max - 1)     fixed; /* cross reference selected names in order to their corresponding FCBs */   dcl blk (f#len - 1)             fixed; /* FCB data array */   dcl (cur.x, cur.y)              fixed; /* current position on menu */   dcl (i, j, k, m, n)             fixed;   print.name: proc (blk, n); /* print filename */      dcl blk              fixed array; /* FCB of file whose name we want printed */      dcl n                fixed; /* number of this file on screen */      dcl nam (f#name_len) fixed; /* place to store the name */      dcl i                fixed;      call clean_fcbname (blk, nam); /* extract filename from FCB */      nam (0) = shl(f#name_len,1); /* set length to use whole name */      pstring (nam); /* print out the name */      if (n mod 8) = 0 then crlf; /* be neat (can fit eight names across) */      else                  pstring (' ');   end print.name;   print_header: proc; /* print selection menu header */      clear_screen;      pstring ('Shuffling:  '); call name (disk.level); crlf;      pstringr ('-------------------------------------------------------------------------------');      pstringr ('COLLECT option:  Use cursor keys to move over files.  Press the space bar');      pstringr ('to select or deselect a file to be collected.  Press R to review the order');      pstringr ('in which the files will be collected.  Press RETURN to initiate the shuffle.');      pstringr ('Press Q to abort the shuffle.  Selected files are marked with a >.');   end print_header;   call print_header; /* print menu header */   call read_catalog ('', disk.level); /* read catalog now */   do i = 0 to entry_max - 1; /* no files have been selected */      file.status (i) = -1;   end;   k = 0; /* haven't selected any files yet */   i = a.r; /* force ourselves to print the filenames */   do while ((i <> a.cr) and (i <> a.q) and (i <> l.q) and (i <> a.nul)); /* wait for a RETURN or Q for quit */      if i = a.refresh then do; /* refresh screen */         call print_header; /* print menu header */         i = a.r; /* and force a review of the filenames */      end;      if i = a.sp then do; /* space - toggle selection */         j = xref (cur.y*8 + cur.x); /* pick up the FCB number of the selected file */         if file.status (j) = -1 then do; /* selected a file */            pstring ('>'); /* mark that we're copying it */            file.status (j) = k; /* select it */            ordered (k) = j; /* remember it */            k = k + 1; /* we've selected a file */         end;         else do; /* deselected it */            k = k - 1; /* we now have one less file selected */            pstring ('|'); /* mark that we're NOT copying it */            do m = file.status (j) + 1 to k; /* remove it from the list */               ordered (m - 1) = ordered (m); /* remove by shifting everything past it down */               file.status (ordered (m)) = file.status (ordered (m)) - 1; /* and update FCB pointers */            end;            file.status (j) = -1; /* deselect it */         end;         i = cur.right; /* automatically move right */      end;      if ((i = cur.up) or (i = a.vt)) then do; /* cursor up */         if cur.y > 0 /* if we can, move up */         then cur.y = cur.y - 1;      end;      else if ((i = cur.down) or (i = a.lf)) then do; /* cursor down */         if ((cur.y < n/8 - 1) or ((cur.y = n/8 - 1) and (cur.x <= n mod 8))) /* if we can, move down */         then cur.y = cur.y + 1;      end;      else if ((i = cur.right) or (i = a.ff)) then do; /* cursor right */         if (((cur.y < n/8) and (cur.x < 8 - 1)) or ((cur.y = n/8) and (cur.x < n mod 8))) /* if we can, move right */         then cur.x = cur.x + 1;         else if cur.y < n/8 then do; /* wrap to next line if we can */            cur.x = 0; /* wrap to beginning if line */            cur.y = cur.y + 1; /* move to next line */         end;      end;/* $page */      else if ((i = cur.left) or (i = a.bs)) then do; /* cursor left */         if cur.x > 0 /* if we can, move left */         then cur.x = cur.x - 1;         else if cur.y > 0 then do; /* wrap to previous line if we can */            cur.x = 7; /* move to the end of the line */            cur.y = cur.y - 1; /* move to previous line */         end;      end;      else if ((i = cur.home) or (i = c.r) or (i = c.y) or (i = a.rs) or (i = pf.1)) then do; /* home */         cur.x = 0;  cur.y = 0;      end;      else if ((i = a.r) or (i = l.r)) then do; /* review order */         pos (7, 0); n = 0; /* move to top of display */         do j = 0 to k - 1; /* print out the selected files */            call get_fcb (ordered (j), blk); /* get the fcb */            if blk (f#nm) <> 0 then do; /* valid filename */               xref (n) = ordered (j); n = n + 1; /* remember what entry this name was */               pstring ('>'); call print.name (blk, n); /* and print the name */            end;         end; /* of loop over fcb's */         do j = 0 to entry_max - 1; /* print out the unselected files */            call get_fcb (j, blk); /* get the fcb */            if ((file.status (j) = -1) and (blk (f#nm) <> 0)) then do; /* valid filename */               xref (n) = j; n = n + 1; /* remember what entry this name was */               pstring ('|'); call print.name (blk, n); /* and print the name */            end;         end; /* of loop over fcb's */         cur.x = 0; cur.y = 0; /* we're pointing to the first entry */         n = n - 1; /* move the number of names's base to zero */         clear_typeahead; /* clear any typeahead */      end;      pos (7 + cur.y, cur.x*10); i = rchar; /* move to the proper position and get next character */   end; /* of wait for return or Q */   do j = 2 to 23; pos (j, 0); erase_line; end; /* clean up the screen */   if i <> a.cr /* did we exit with a abort */   then return (true); /* yes, abort the shuffle */   collect = k; /* set number of files to collect */   ms.collect.sec = 0; ls.collect.sec = 0; /* clear out any prior list */   do i = 0 to collect - 1; /* loop over selected files */      call get_fcb (ordered (i), blk); /* get its name */      do j = 0 to f#name_len - 1; collect.nam (i*f#name_len + j) = blk (f#nm + j); end; /* store name */      ms.collect.sec = ms.collect.sec + blk (f#ml); /* sum MSB length */      ls.collect.sec = ls.collect.sec + blk (f#ll); /* sum LSB length */      if ls.collect.sec ilt blk (f#ll) then ms.collect.sec = ms.collect.sec + 1; /* carry */   end; /* of loop over fcb's */   return (false); /* start the shuffle */end select_files;/* $SUBTITLE  Main Program */dcl ch            fixed; /* input character */dcl ready         boolean; /* true if we should start the shuffle */dcl disk_inserted boolean; /* TRUE if a disk has been inserted into the drive */dcl progname (64) fixed;   /* Program name */dcl arg (64)      fixed;   /* Command line args parsed into here */validity.flag = 0; /* DEBUG code for validity errors in Beta test of -7 software */call set_catbuf (addr(catalog(0)), 0); /* set catalog buffer */quiet      = false;quiet_done = false;call setup_args(progname);         /* Get command name and set up to parse args */call next_arg(arg);                /* Get first command line argument */call lower(arg);                   /* Note: null string if no args */if strcmp(arg,'-q') = 0 then do;   quiet = true;end;if systyp = 0 then core(loc.strd) = 0; /* leave no program stored */collect.flag = 0; /* assume no collect */if core(loc.ucat) = 0 and (core(loc.ucat + 1) and "377") = 0 /* if not in a subcatalog */then disk.level = shr(core(loc.ucat + 1), 8); /* then use current device */else disk.level = 1; /* else default to current cat/dev */do forever; /* main loop */   collect = 0; /* assume no collect files */   ready = false;   do while not ready; /* loop until ready to shuffle */      if process_menu /* get user menu */      then do; /* quit was specified */         disk_inserted = not (systyp = 0); /* assume there's no disk inserted on floppy systems */         do while (not disk_inserted); /* make sure there's a system disk */            pcmd ('Insert a SYSTEM disk into '); call name (2); pstring (' and press RETURN ->');            clear_typeahead; call rchar; erase_command;            disk_inserted = disk_check (2); /* see if they put the disk in */         end;         pcmd('End of SHUFFLE utility'); flush_term;         if locate ('.current', 1) then do; /* look for .CURRENT (in case it's moved) */            core(loc.csec + 1) = f#ms_sector; /* save its location */            core(loc.csec)     = f#ls_sector;         end; /* of look for .CURRENT */         if ((systyp = 0) and (disk.level = 2)) /* check for shuffling system catalog */         or ((systyp = 1) and (disk.level = 6))         then core(loc.magic) = 0; /* reset magic number to force reboot on termination */         if ((disk.level = 1) and (core(loc.ucat) = 0) and ((core(loc.ucat + 1) and "377") = 0) and (system_device = current_device))         or (disk.level = shr(core(loc.pcat + 1), 8)) /* or path device */         or ((disk.level = 1) and (core(loc.ucat) = 0) and ((core(loc.ucat + 1) and "377") = 0) and (shr(core(loc.pcat + 1), 8) = shr(core(loc.ucat + 1), 8)))         then core(loc.magic) = 0; /* reset magic number to force reboot on termination */         call exit(0);      end;      ready = true; /* user wants to start the shuffle */      if collect.flag then do; /* user will select group of files to list */         if select_files then ready = false; /* abort */      end;   end; /* of wait until ready */   clear_screen;   pstringr ('  Warning:   D O    N O T    S T O P    T H I S    P R O G R A M');   pstringr ('           while it is running (except by using the BREAK key) ');   pstringr ('           or else the disk will be left in an  UNUSABLE  state.'); crlf;   pstringr ('  Shuffle Times may be as long as 15-20 minutes for Winchester disks.'); crlf;   pstring  ('Beginning SHUFFLE of '); call name (disk.level); crlf;	   if (read_catalog ('', disk.level) == 0) /* read in the catalog */	{  		pstringr ('   ... Failed.  Could not read catalog.'); crlf;		exit(1);	}	   ms.max.sec = c#ms_length; /* set maximum catalog size */   ls.max.sec = c#ls_length;   #fcbs = c#dir_size/c#len; /* number of FCBs in catalog */   call shuffle; /* do the shuffle */   crlf; /* go to start of line */   if quiet = false then do;      pstring ('Press RETURN to continue ->');      ch = rchar; /* wait for char */   end;end; /* of main loop */