/* $title Sound File Caption Program *//* This program lists out all sound files in the current catalog.  It.  includes information about the sound file such as whether it's stereo.  or mono, how long it is (in seconds), and its caption.  This list.  is also saved in a disk file to keep as a permanent record with the.  catalogued sound files...  This program will also update the captions of specified sound files..  This is done by running this program to create the original sound.  file list, changing the captions in the caption column using the.  screen editor, and then running this program again asking to update.  the captions...  By:  Martin Royer, Fall 1986..  Modification history:.     2 Dec 86  KJC  Updated for -7 catalog structure, fixed some bugs.     5 Dec 86  KJC  Added update of sound file captions.    27 Mar 87  KJC  Added command line args*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII definitions */insert ':-xpl:termut';   /* terminal utilities */insert ':-xpl:catrtns';  /* catalog routines */insert ':-xpl:fileio';   /* file input/output */insert ':-xpl:strings';  /* string processing */insert ':-xpl:scanargs'; /* command line argument scanning */insert ':utilcat:getfiles'; /* file searching */dcl level        lit '1'; /* set read catalog to current catalog  */dcl cap_column   lit '41'; /* caption starts at this column */dcl cap_length   lit '128'; /* maximum length of a caption */dcl line_length  lit '(cap_column + cap_length)'; /* maximum line length */dcl cap_size     lit '(((((line_length + 1)/2) + 1)*(c#dir_max/c#len) + 255)/256)'; /* sector length of caption file *//* $subtitle Formatting Routines *//* This procedure converts a fixed point binary number to ASCII and.  stores it in the passed string.  Both the minimum field width and.  and the fill character can be specified. */put_unum: proc(s, n, field, fill); /* output an unsigned number (0 to 65535) */   dcl s      fixed array; /* output string */   dcl n      fixed; /* value to output */   dcl field  fixed; /* minimum field width */   dcl fill   fixed; /* fill character */   dcl go     boolean; /* TRUE when outputting number */   dcl (i, r) fixed;   dcl #divisors data (10000, 1000, 100, 10, 1); /* powers of ten */   s (0) = 0; /* no characters output yet */   do i = 1 to field - 5; /* print out any necessary leading fill characters */      call pbyte(s, i - 1, fill);      s (0) = s (0) + 1;   end;   go = false; /* suppress leading zeroes */   do i = 0 to 4; /* loop over 5 digits */      r = 0; /* assume digit is zero */      do while (n ige #divisors (i)); /* simulate unsigned divide:  */         n = n - #divisors (i);       /* n = (n mod #divisors (i)); */         r = r + 1;                   /* r = r/#divisors (i);       */      end;      if r <> 0 then go = true; /* turn on printing */      if ((go) or (i = 4)) then do; /* outputting digits or at last position */         call pbyte(s, s (0), a.0 + r); /* output digit */         s (0) = s (0) + 1;      end;      else if field - (4 - i) > 0 then do; /* output fill character if necessary */         call pbyte(s, s (0), fill);         s (0) = s (0) + 1;      end;   end; /* of digits loop */end put_unum;/* This procedure outputs a line to both the screen and the captions.  file.  In this way the user can see the file being created.  The.  number of lines output thus far is returned. */put_line: proc(line, number, f) returns (fixed); /* output a line */   dcl line   fixed array; /* line to output */   dcl number fixed; /* line number of this line */   dcl f      file; /* file to output to */   call fputs (line, number, f); /* write data to caption file */   pstringr (line); /* and to terminal for user's benefit */   return (number + 1); /* one more line */end put_line;/* $subtitle Format A Line For Output *//* This procedure pulls the proper information from the next sound file,.  formats it, and arranges it in a string. */build_line: proc(line); /* build output line */   dcl line      fixed array; /* output line */   dcl sound     file; /* sound file to get information from (name is in LINE) */   dcl buf (256) fixed; /* sound file header buffer */   dcl s (10)    fixed; /* temporary ASCII number storage */   dcl srate     fixed; /* sampling rate */   dcl i         fixed;   sound = fopen (line, 'r'); /* open sound file */   do i = 0 to 255; /* read in header */      buf (i) = getw (sound);   end;   call fclose (sound); /* all done with file */   do i = line (0) to f#name_len*2 - 1; /* pad filename with blanks */      call pbyte(line, i, a.sp);   end;   line (0) = f#name_len*2;   if buf (41) = 0 /* stereo or mono? */   then call strcat (line, '   M  '); /* mono */   else call strcat (line, '   S  '); /* stereo */   /* Get the appropriate sampling-rate or period.index from this   .  sound file.  See Sound file data description for details on   .  why the sampling rate is stored in 1 of 2 places in the file.   .  Sampling rate is in ddd.d kHz format. */   if buf (42) <> 0 /* if STM created sound file */   then srate = buf (42)/10; /* it's sample rate*10 */   else srate = 30000/buf (21); /* SFM created sound file */   call put_unum (s, srate, 6, a.sp); /* convert sample rate to ASCII */   if buf (42) <> 0 /* if STM created sound file */   then srate = buf (42) - (buf (42)/10*10); /* pick up fraction */   else do; /* SFM created sound file - pick up fraction */      srate = int(30000.0/buf (21));      srate = int((30000.0/buf (21) - srate)*10.0);    end;   call strcat (line, s); /* add sampling rate to output */   call pbyte(line, line (0), a.period); line (0) = line (0) + 1;   call pbyte(line, line (0), srate + a.0); line (0) = line (0) + 1;   /* get length of sound file in seconds */   call put_unum (s, buf (9), 5, a.sp); /* convert seconds */   call strcat (line, s); /* add to output */   call strcat (line, '.'); /* period */   call put_unum (s, buf (10), 3, a.0); /* convert milliseconds */   call strcat (line, s);   call strcat (line, '  ');   call put_unum (s, f#ls_length, 5, a.sp); /* convert sectors */   call strcat (line, s);   call strcat (line, '  ');   /* get caption */   if buf (127) > cap_length then buf (127) = cap_length;  /* limit */   call strcat (line, loc(addr(buf (127)))); /* copy caption to output buffer */end build_line;/* $subtitle Update A Sound File Caption *//* This procedure pulls the filename of the next sound file and its new.  caption from LINE (which was originally formatted by BUILD_LINE)..  The file's caption is changed to the caption specified.  It returns.  FALSE if the file couldn't be opened or wasn't a sound file. */update_caption: proc(name, caption) returns (boolean); /* update sound file caption */   dcl name    fixed array; /* filename of sound file to update */   dcl caption fixed array; /* new caption */   dcl sound   file; /* sound file to update caption of */   dcl index   fixed; /* pointer to index data */   dcl i       fixed;   sound = fopen (name, 'a'); /* open sound file */   if sound = nullf then return (false); /* couldn't do it */   if f#type <> t#sound then do; /* not a sound file */      call fclose (sound); /* close it */      return (false);   end;   call seek (sound, 52*2, 0); /* seek to start of caption in sound file */   index = getw (sound); /* get pointer to bottom of index data */   if index = 0 then index = 256; /* no index area */   if caption (0) > shl(index - 128, 1) /* if caption will spill over into index area */   then caption (0) = shl(index - 128, 1); /* limit to available caption area */   call seek (sound, 127*2, 0); /* seek to start of caption in sound file */   if caption (0) then call pbyte(caption, caption (0), a.nul); /* pad odd length caption with null */   do i = 0 to shr(caption (0) + 1, 1); /* copy caption into sound file */      call putw (caption (i), sound);   end;   do i = i to index - 128; /* pad with zeroes to be neat */      call putw (0, sound);   end;   call fclose (sound); /* all done with sound file */   return (true); /* updated it */end update_caption;/* $subtitle Main Program */dcl tree_max lit '48'; /* maximum length of a treename */dcl buffer (line_length/2) fixed; /* buffer for a complete line of text */dcl name (tree_max/2)      fixed; /* treename of caption file */dcl caption file; /* caption file */dcl number  fixed; /* line number in output file */dcl update  boolean; /* TRUE if we should update sound files */dcl capname data ('-CAPTION'); /* name of caption file *//* headers to be output to the caption file */dcl head1 data('   *****  Directory of Sound Files in Current Catalog  *****');dcl head2 data('Sound    Mono/  Sample  Length  Length          Caption        ');dcl head3 data('Filename Stereo  Rate   Seconds Sectors       Information      ');dcl head4 data('-------- ------ -(KHz)- ------- ------- -----------------------');when break then do; /* user hit BREAK */   call fclose (caption); /* close the file */   call exit (0);end;call setup_args (name); /* set up to scan command line arguments (ignore progname and run flag) */if core(next_arg (name)) <> 0 then do; /* pick up sound file name if there */   call strtok (buffer, ''); /* pick up rest of command line (caption) */   call strncpy (buffer, buffer, 1, buffer (0) - 1); /* toss out leading space */   if not update_caption (name, buffer) then do; /* update the caption */      pstring ('Sound file '); pstring (name); pstringr (' not found.');   end;   call exit (0); /* get out here */end; /* of command line sound file argument */clear_screen;pstring ('Sound File Caption Utility Program - '); pstringr (rel.date);crlf;pstringr ('This program lists out all sound files in the current catalog.  It');pstringr ('includes information about the sound file such as whether it''s stereo');pstringr ('or mono, how long it is (in seconds), and its caption.  This list');pstringr ('is also saved in a disk file to keep as a permanent record with the');pstringr ('catalogued sound files.');crlf;pstringr ('This program will also update the captions of specified sound files.');pstringr ('This is done by running this program to create the original sound');pstringr ('file list, changing the captions in the caption column using the');pstringr ('screen editor, and then running this program again asking to update');pstringr ('the captions.');crlf;if not get_yn ('Do you wish to view sound file captions [Y(es) or N(o)]? ') then do;   crlf;   if get_yn ('Do you wish to update sound file captions [Y(es) or N(o)]? ') then do;      crlf;      update = get_yn ('This will modify the specified sound files.  Do you still wish to proceed? ');   end;   if not update then do; /* if not okay to update */      crlf; crlf;      pstringr ('End of CAPTION utility');      call exit (0);   end;   else do;      crlf; crlf;      pstringr ('The captions are updated from a previously created caption file.');   end;end; /* of caption file already there */else do; /* create caption file */   crlf; crlf;   pstringr ('The captions will be output to the screen as well as to a file.');   update = false; /* don't update */end;get_string ('Caption file treename [RETURN for default]? ', 0, name, tree_max); crlf;if name (0) = 0 then call strcpy (name, capname); /* set up default treename */if update then do; /* update sound file captions from caption file */   crlf;   caption = fopen (name, 'r');   call fgets (buffer, line_length, caption); /* get first line from caption file */   if strcmp (head1, buffer) <> 0 then do; /* oops! not a caption file */      pstring (name); pstringr (' was not originally created by this utility and cannot be used.');      call exit (-1);   end;   do while (byte(buffer, 0) <> a.minus); /* look for end of header */      if fgets (buffer, line_length, caption) = eof_mark /* get next line from caption file */      then call pbyte(buffer, 0, a.minus); /* get out if reach end */   end;   do while (not feof (caption)); /* until the end of the caption file is reached */      call fgets (buffer, line_length, caption); /* get line from caption file */      if buffer (0) >= cap_column then do; /* don't bother unless there's a caption */         call strncpy (name, buffer, 0, strspn (buffer, ' ', 0) - 1); /* pull off filename */         call strncpy (buffer, buffer, cap_column - 1, buffer (0) - 1); /* pull off caption */         if update_caption (name, buffer) then do; /* update the caption */            pstring ('Sound file '); pstring (name); pstringr (' has been updated.');         end;         else do; /* didn't do it */            pstring ('Sound file '); pstring (name); pstringr (' not found.');         end;      end; /* of there's a caption */   end; /* of until end of caption file is reached */   call fclose (caption);   crlf; pstringr ('End of CAPTION utility');end; /* of updating sound file captions *//* $page *//* create caption file */else do; /* not updating captions - create caption file */   if not replace (name, t#text, 0, cap_size, 0, level) then do; /* try to save caption file */      crlf;      pstring ('No space in catalog for '); pstringr (name);      call exit (-1);   end;   caption = fopen (name, 'w'); /* open the caption file */   number = 0; /* no lines output yet */   call start_search ('*', false, level); /* start search for all files */   do while (getfname (buffer)); /* loop over all files in catalog */      call locate (buffer, level); /* find the file */      if f#type = t#sound then do; /* sound file */         if number = 0 then do; /* is this the first sound file we have found? */            number = 1; /* found a sound file - increment line number */            clear_screen; /* clear the screen first */            number = put_line (head1, number, caption); /* write out header */            number = put_line ('',    number, caption);            number = put_line (head2, number, caption);            number = put_line (head3, number, caption);            number = put_line (head4, number, caption);         end; /* of 1st sound file found exception */         call build_line (buffer);         number = put_line (buffer, number, caption); /* output line */      end; /* of valid file if statement */   end;  /* of loop over all files in catalog */   if number <> 0 then do; /* if caption file created */      call fclose (caption); /* close caption file */      crlf;      pstring (name); pstringr (' was created.');   end;   else do; /* no caption file */      call delete (name, level); /* get rid of empty caption file */      crlf;      pstringr ('*** No Sound files exist in this catalog.');   end;end; /* of creating caption file */flush_term;