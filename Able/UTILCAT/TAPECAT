/* $title Tape Drive Management Utility *//* This program allow the user to access the Kennedy tape drive in  a number of ways which are normally unavailable (due to a lack of  tape drive support in the MONITOR).  By:  Karim J. Chichakly on 5 July 1984*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:termut'; /* terminal management routines */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:tapebrdg'; /* tape drive device drivers */insert ':-xpl:catutil'; /* catalog utilities */insert ':utilcat:tapeform'; /* handy tape drive routines */dcl (k#enable_retries, k#disable_retries) proc external; /* enable and disable retries on Kennedy */dcl catalog (c#dir_max - 1) fixed; /* catalog buffer */dcl catcache                fixed; /* cache number of catalog cache */setup.cache: proc(level); /* set up cached catalog (not a general proc) */   dcl level fixed; /* level to set up cached catalog for */   call enable_cache (catcache); /* recache the catalog cache */   call read_catalog ('', level); /* read in the desired catalog */end setup.cache;dump: proc(level); /* dump the catalog of the specified device */   dcl level             fixed; /* level of device to dump */   dcl fcb (f#len - 1)   fixed; /* file control block */   dcl name (f#name_len) fixed; /* filename */   dcl (ms_len, ls_len)  fixed; /* sectors used */   dcl (i, j)            fixed;   ms_len = 0; ls_len = 0; /* no sectors used */   call read_catalog ('', level);   print 'Offset  --Name--   Origin     Secs     Words  Secs(10)   Type';   do i = 0 to c#dir_size/c#len - 1; /* dump out the catalog */      call get_fcb (i, fcb); /* get next fcb */      if ((fcb (f#nm) <> 0) or ((fcb (f#ml) <> 0) or (fcb (f#ll) <> 0))) then do; /* skip free blocks */         print octal(i - 1), '  ',; /* start with address */         if fcb (f#nm) = 0 /* hole? */         then print '* hole *',; /* better be - free blocks are ignored */         else do; /* not a hole, but a file */            ms_len = ms_len + fcb (f#ml); /* count sectors used */            ls_len = ls_len + fcb (f#ll);            if ls_len ilt fcb (f#ll) then ms_len = ms_len + 1;            do j = 1 to f#name_len; /* copy name over */               name (j) = fcb (f#nm + j - 1);            end;            name (0) = shl(f#name_len, 1); /* up to F#NAME_LEN*2 letters */            do j = 0 to name (0) - 1; /* fill with spaces */               if byte(name, j) = 0 then call pbyte(name, j, a.space);            end;            print string(name),; /* add filename */         end; /* of file */         print '  ',; lonum (fcb (f#ms), fcb (f#ls), 8); print '  ',; lonum (fcb (f#ml), fcb (f#ll), 8); onum (fcb (f#wd), 8); lnum (fcb (f#ml), fcb (f#ll), 10); print '   ',;         if fcb (f#ty) igt t#max /* type out of range? */         then print octal(fcb (f#ty)); /* yes, print # */         else do case (fcb (f#ty)); /* branch on type */            print 'Text',;            print 'Exec',;            print 'Reloc',;            print 'Data',;            print 'Sync',;            print 'Sound';            print 'Subc',;            print 'LSubc',;            print 'Dump',;            print 'Spect',;            print 'Index',;            print 'Timb',;         end; /* of branch on type */         crlf; /* keep WCHAR happy */      end; /* of enslaved (not free) blocks */   end; /* of dump out catalog */   print;   lnum (ms_len, ls_len, 0); print ' sectors used',; crlf;end dump;help: proc; /* print out help */   print 'This program is used to clean up and rearrange a catalog on a cartridge tape.';   print 'To enter a command, just type the command name when you see the ''=>'' prompt.';   print;   print 'Command        Action';   print '-------        ------';   print 'LOAD           Loads a tape in the tape drive.';   print 'UNLOAD         Unloads a tape from the tape drive.';   print 'CATALOG        Prints the tape catalog plus any changes you''ve made.';   print 'DUMP           Prints all catalog info (including SECONDS for sound files).';   print 'HARDCOPY       Creates a hardcopy of the DUMP output.';   print 'SORT           Sorts the tape''s catalog alphabetically.';   print 'UNSAVE         Unsaves a file from the tape.';   print 'RENAME         Renames a file on the tape.';   print 'UPDATE         Updates the catalog on the tape.';   print 'UNDO           Undo any SORT, UNSAVE, or RENAME done since last UPDATE.';   print 'QUIT           Return to MONITOR.';   print 'HELP           Prints these instructions.';   print;   print 'No changes are made to the tape until the UPDATE command is issued.';   print 'If you make a series of changes and then change your mind, the';   print 'UNDO command will read back the original catalog from the tape.';end help;dcl commands data ('LOA UNL CAT UNS UPD REN DUM HAR SOR UND SEE REA REV HEL QUI');dcl loadflag data (false, true, true, true, true, true, true, true, true, true, true, true, true, false, false); /* set to TRUE if corresponding command requires tape to be loaded */dcl writflag data (false, false, false, true, true, true, false, false, true, false, false, false, false, false, false); /* set to TRUE if corresponding command won't work on a write-protected tape */dcl buf (block_size - 1) fixed; /* input/data buffer */dcl ibuf (64)            fixed; /* alternate input buffer */dcl command              fixed; /* command letter */dcl loaded               boolean; /* TRUE if the tape is loaded */dcl updated              boolean; /* TRUE if the catalog tape catalog matches the cached catalog */dcl found                boolean; /* TRUE if we found the command */dcl invalid              boolean; /* TRUEif invalid character found */dcl (i, j)               fixed;screen_size (-1, -1); /* turn off line truncation by WCHAR */call set_catbuf (addr(catalog (0)), 0); /* set up catalog buffer */catcache = cache (c#bufptr, c#bufmed); /* cache the catalog in itself */loaded = false; /* no tape is loaded yet */updated = true; /* they don't match quite yet, but we don't need to update the catalog */print 'Tape Drive Management Utility - ', string(rel.date);print;call help; /* print out the instructions */do forever; /* don'tcha stop, don'tcha stop */   print '=> ',; /* prompt them */   linput buf; /* get response */   if buf (0) > 3 then do; /* ignore empty and too short lines */      command = (byte(buf, 0) and (not "040")); /* get first letter of command (uppercased) */      found = false; /* haven't found the command yet */      i = 0;      do while ((i < commands (0)) and (not found )); /* find the command */         do while ((i < commands (0)) and (command <> byte(commands, i))); /* look for a command match */            i = i + 4;         end;         if i < commands (0) then do; /* look for an exact match */            if (((byte(buf, 1) and (not "040")) = byte(commands, i + 1)) /* check next two characters */            and ((byte(buf, 2) and (not "040")) = byte(commands, i + 2)))            then found = true; /* we found the command */            else i = i + 4; /* didn't find it, keep searching */         end; /* of looking for an exact match */      end; /* of find the command */      if i >= commands (0) /* out of range? */      then print 'Invalid command.';      else do; /* valid command - process it */         i = shr(i, 2); /* byte position of command divided by 4 is command number */         if (loadflag (i) and (not loaded)) /* certain commands require the tape to be loaded */         then print 'Tape is not loaded.';         else if (writflag (i) and ((tape_status and write_protect) <> 0)) then do; /* certain commands don't work on WP tapes */            print 'The tape is write-protected.  Remove the tape from the drive';            print 'and type UNLOAD.  Remove the write-protection from the tape,';            print 're-insert the tape into the drive, and type LOAD.';         end; /* of write protected tape */         else do case (i); /* act on command */            do; /* 0: LOAD */               if not loaded then do; /* make sure it isn't loaded already */                  print 'Please wait - loading tape...';                  call load (8); /* load the tape */                  call check_tape; /* check the status */                  tape_position (0) = 0; /* we're at the beginning of the tape */                  loaded = true;                  call setup.cache (8); /* read in the tape drive catalog and set up our cache */               end;               else print 'Tape is already loaded.';            end; /* of case 0 */            do; /* 1: UNLOAD */               if not updated then do; /* if the cached catalog differs from the tape catalog */                  if get_yn ('Do you want your changes saved before unloading? ') then do;                     call write_catalog; /* save changes */                     updated = true; /* cache now matches tape */                  end;                  crlf;               end; /* of updating catalog */               print 'Please wait - unloading tape...';               call unload (8, true); /* unload the tape */               tape_position (0) = -1; /* we've never seen this tape before */               loaded = false; /* the tape is no longer loaded */            end; /* of case 1 */            do; /* 2: CATALOG */               call print_catalog (8);               print 'Type HELP for assistance.';            end; /* of case 2 */            do; /* 3: UNSAVE */               print 'File to unsave? ',;               linput buf; buf (0) = buf (0) - 1; /* get filename */               if removefile (buf) /* get rid of it */               then updated = false; /* cached catalog no longer matches tape catalog */               else print 'File "', string(buf), '" does not exist.';            end; /* of case 3 */            do; /* 4: UPDATE */               if not updated then do; /* don't update if it's not different */                  call write_catalog; /* write out the cache */                  updated = true; /* cached catalog now matches tape catalog */               end;            end; /* of case 4 */            do; /* 5: RENAME */               print 'Old filename? ',;               linput buf; buf (0) = buf (0) - 1; /* get old name */               if findfile (buf) <> -1 then do; /* make sure it's there */                  print 'New filename? ',;                  linput ibuf; ibuf (0) = ibuf (0) - 1; /* get new name */                  invalid = false; /* assume name is valid */                  do j = 0 to ibuf (0) - 1; /* check name */                     if not valid_filechar (byte(ibuf, j)) then invalid = true;                  end; /* of checking name */                  if invalid then print 'Invalid character in filename.';                  else if not findfile (ibuf) <> -1 then do; /* make sure new name isn't there */                     call renamefile (buf, ibuf); /* rename the file on the tape drive */                     updated = false; /* cached catalog no longer matches tape catalog */                  end; /* of new name isn't there */                  else print 'File "', string(ibuf), '" already exists.';               end; /* of old name is there */               else print 'File "', string(buf), '" does not exist.';            end; /* of case 5 */            call dump (8); /* 6: DUMP */            do; /* 7: HARDCOPY */               print 'Please wait - printing catalog...';               j = redirection_word; redirection_word = 1; /* redirect output to printer */               call dump (8); /* dump out the catalog */               redirection_word = j; /* reset redirection */            end; /* of case 7 */            do; /* 8: SORT */               call sort_catalog; /* sort it alphabetically */               updated = false; /* cached catalog no longer matches tape catalog */            end; /* of case 8 */            do; /* 9: UNDO */               call setup.cache (8); /* read in the catalog again */               updated = true; /* cached catalog matches tape catalog */            end; /* of case 9 */            do; /* 10: SEEK */               print 'Seek to file? ',;               linput buf; buf (0) = buf (0) - 1; /* get file to seek to */               if findfile (buf) <> -1 then do; /* make sure it's there */                  print 'Please wait - seeking to file "', string(buf), '"...';                  call readdata (f#ms_sector, f#ls_sector, buf, 0); /* seek to it */               end; /* of old name is there */               else print 'File "', string(buf), '" does not exist.';            end; /* of case 10 */            do; /* 11: READ */               call k#disable_retries; /* disable any retries (Kennedy only) */               j = read_tape (8, buf, block_size); /* try to read a block */               print 'Tape pos: ', octal(tape_position (0)), ', status: ',; hnum (tape_status, 4); print ', len: ', j;               call k#enable_retries; /* reenable retries here (Kennedy only) */            end; /* of case 11 */            do; /* 12: REVERSE SPACE RECORD */               call k#disable_retries; /* disable any retries (Kennedy only) */               call reverse_space (8, 0, 1); /* reverse space record */               print 'Status: ',; hnum (tape_status, 4); print;               call k#enable_retries; /* reenable retries here (Kennedy only) */            end; /* of case 12 */            call help; /* 13: HELP */            do; /* 14: QUIT */               if not updated then do; /* if the cached catalog differs from the tape catalog */                  if get_yn ('Do you want your changes saved before exiting? ')                  then call write_catalog; /* save changes */                  crlf;               end; /* of updating catalog */               if loaded then call unload (8, false); /* unload tape if necessary */               print 'So long...';               call exit(0);            end; /* of case 14 */         end; /* of act on command */      end; /* of processing valid command */   end; /* of non-empty line */   else do; /* empty line or command too short */      if buf (0) <> 1 then print 'Command too short.';   end; /* of empty line or command too short */end; /* of do forever */