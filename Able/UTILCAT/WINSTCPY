/* $subtitle Get The Next Dump File Segment *//* These routines are based on the FORMCOPY transfer routines. */dcl h.name          lit '0';  /* dump file header: name */dcl h.file.type     lit '5';  /*                   type */dcl h.file.length   lit '6';  /*                   length (mod 64K) */dcl h.sector.length lit '7';  /*                   LSB sector length */dcl h.disk.number   lit '8';  /*                   disk number */dcl h.ms.sector     lit '9';  /*                   MSB sector length */dcl h.end           lit '10'; /*                   length of header */dcl sour         fixed; sour = 2; /* source is ALWAYS F0 in WINSTALL */dcl dest         fixed; dest = 6; /* destination is ALWAYS W0 in WINSTALL */dcl ms.read.sec  fixed; /* sector to read from */dcl ls.read.sec  fixed;dcl ms.write.sec fixed; /* sector to write to */dcl ls.write.sec fixed;dcl disk.number  fixed; /* disk number for files that span many disks (multidisk copies) */dcl total.disks  fixed; /* total disks for multidisk copies */dcl disk.label  fixed; /* label of disk in question (MUST end with disk number) */dcl dummy_label data ('disk 1'); /* dummy disk label so we don't blow up due to programmer error */disk.label = addr(dummy_label (0)); /* initialize disk.label */get_next_segment: proc (name, blk, buf); /* get next dump file segment - set BLK to new segment's FCB */   dcl name                    fixed array; /* name of dump file */   dcl blk                     fixed array; /* FCB */   dcl buf                     fixed array; /* buffer */   dcl user.num                fixed; /* the disk number as the USER sees it (from label) */   dcl prompt                  boolean; /* TRUE if we should prompt and inform user during first pass */   dcl i                       fixed;   buf (h.disk.number) = 0; /* set this to an invalid disk number */   prompt = (disk.number <> 1); /* always skip the messages the first time through with disk one */   user.num = byte(location(disk.label), core(disk.label) - 1) - a.0; /* get label's disk number */   if disk.number <> 1 then user.num = user.num + 1; /* increment label's disk number */   call pbyte (location(disk.label), core(disk.label) - 1, a.0 + user.num); /* store it back */   do while (buf (h.disk.number) <> disk.number); /* get proper disk */      if prompt then do; /* only prompt user if absolutely necessary */         print;          print 'Please place the ', string(location(disk.label));         print 'into F0 (Leftmost floppy) and press RETURN ->',;         linput ibuf; /* wait for input */      end;      call read_catalog ('', sour); /* read the source catalog */      i = findfile (name); /* find the file we're looking for */      if i = -1 then do; /* we didn't find it! */         if prompt then print 'This is not the ', string(location(disk.label));      end;      else do; /* we found it */         call get_fcb (i, blk); /* get the file's FCB */         if blk (f#ty) <> t#dump then do; /* this file isn't a dump file! */            if prompt then print 'This is not the ', string(location(disk.label)); /* not a dump file */         end;         else do; /* it's a dump file */            if (c#ls_sector + blk (f#ls)) ILT c#ls_sector then i = 1; else i = 0;            call readdata (c#ms_sector + blk (f#ms) + i, c#ls_sector + blk (f#ls), buf, h.end); /* read in header */            if buf (h.disk.number) <> disk.number then do; /* this isn't the right disk! */               if prompt /* only tell them of their error when it was their error */               then print 'This is disk', user.num + (buf (h.disk.number) - disk.number), ', not disk', user.num, '.';            end;            else do; /* remember we read the first sector in */               blk (f#ls) = blk (f#ls) + 1; /* increment starting sector */               if blk (f#ls) = 0 then blk (f#ms) = blk (f#ms) + 1;               if blk (f#ll) = 0 then blk (f#ml) = blk (f#ml) - 1;               else blk (f#ll) = blk (f#ll) - 1; /* decrease sector length */            end;         end;      end;      prompt = true; /* after first pass, always output messages */   end;end get_next_segment;/* $subtitle Get File Info, Copy a File Segment From the Source to the Destination */get_fileinfo: proc (name); /* get cat info of any file on the source */   dcl name                    fixed array; /* name of file to get length of */   dcl blk (f#len - 1)         fixed; /* FCB of file to get length of */   dcl buf (h.end - 1)         fixed; /* buffer to hold any dump file information */   call read_catalog ('', sour); /* read source catalog */   call get_fcb (findfile (name), blk);   if blk (f#ty) = t#dump then do; /* if dump file, we need to read header */      disk.number = 1; /* we are about to read the header from disk number one (we hope) */      call get_next_segment (name, blk, buf); /* read in header */      f#ms_length = buf (h.ms.sector); /* get MSB sector length */      f#ls_length = buf (h.sector.length); /* get LSB sector length */      f#words = buf (h.file.length); /* get word length */      f#type = buf (h.file.type); /* and file type */   end; /* of dump file */   else do; /* not a dump file - return what FINDFILE returned */      f#ms_length = blk (f#ml); /* set sector length */      f#ls_length = blk (f#ll);       f#words = blk (f#wd); /* word length */      f#type = blk (f#ty); /* file type */   end;   f#ms_sector = blk (f#ms); /* also set starting sector */   f#ls_sector = blk (f#ls);end get_fileinfo;transfer_segment: proc (buf, bufsize, ms.sec.left, ls.sec.left); /* transfer a file segment */   dcl buf         fixed array; /* transfer buffer */   dcl bufsize     fixed; /* size of the transfer buffer */   dcl ms.sec.left fixed; /* number of sectors (on this disk) yet to transfer */   dcl ls.sec.left fixed;   dcl hunk        fixed; /* size of transfer block */      do while (ms.sec.left <> 0) or (ls.sec.left <> 0);  /* transfer in chunks if need be */      if ((ms.sec.left = 0) and (ls.sec.left < shr(bufsize, 8))) /* find the size of hunk to transfer */      then hunk = ls.sec.left; /* hunk is either what is left to copy */      else hunk = shr(bufsize, 8); /* or the buffer size */      call trigger_motor (sour);      call readdata (ms.read.sec, ls.read.sec, buf, shl(hunk, 8));      call trigger_motor (dest);      call writedata (ms.write.sec, ls.write.sec, buf, shl(hunk, 8));      ls.read.sec = ls.read.sec + hunk; /* read from next sector */      if ls.read.sec ILT hunk then ms.read.sec = ms.read.sec + 1;      ls.write.sec = ls.write.sec + hunk; /* write to next sector */      if ls.write.sec ILT hunk then ms.write.sec = ms.write.sec + 1;      if ls.sec.left ILT hunk then ms.sec.left = ms.sec.left - 1;      ls.sec.left = ls.sec.left - hunk; /* update what is left to copy */   end;end transfer_segment;/* $subtitle Copy a File From Many Sources to One Destination */transfer_file: proc (name, buf, bufsize); /* copy file NAME to destination */   dcl name                    fixed array; /* name of file to transfer */   dcl buf                     fixed array; /* the buffer */   dcl bufsize                 fixed; /* size of buffer */   dcl blk (f#len - 1)         fixed; /* FCB of file we're transferring */   dcl ms_num_secs             fixed; /* number of sectors of this file on this disk */   dcl ls_num_secs             fixed;   dcl ms_cat_start            fixed; /* starting sector of source catalog */   dcl ls_cat_start            fixed;   dcl load.dump               boolean; /* TRUE if we're reloading a dump file (multidisk source) */   print 'Installing file:  ', string(name);   call read_catalog ('', sour); /* read in the catalog */   ms_cat_start = c#ms_sector; /* save source catalog starting sector */   ls_cat_start = c#ls_sector;   if compare (name, monitor) /* are we copying MONITOR? */   then call get_fcb (findfile (monitor_name), blk); /* get FCB of file in question (better be there!) */   else call get_fcb (findfile (name), blk);   load.dump = (blk (f#ty) = t#dump); /* see if many source disks */   if load.dump then do; /* if we're reloading a dump file */      disk.number = 1; /* we're starting with the first disk */      call get_next_segment (name, blk, buf); /* if this isn't the right disk, get the right one! */      call read_catalog ('', sour); /* get source info */      ms_num_secs = c#ms_length; /* set number of sectors for this file on this disk */      ls_num_secs = c#ls_length - shr(c#dir_size, 8); /* get source size */      total.disks = (buf (h.sector.length) + (ls_num_secs - 2))/(ls_num_secs - 1); /* determine number of empty disks needed to save file */      ls_num_secs = buf (h.sector.length); /* reset the LSB sector length */   end;   else do; /* not a multidisk load */      disk.number = 0; /* no disks yet */      total.disks = 0; /* only one source disk */      ms_num_secs = blk (f#ml); /* get the number of sectors for this file on this disk */      ls_num_secs = blk (f#ll);   end;   if locate (name, dest) then do; /* make sure it's already on the destination */      ms.read.sec = ms_cat_start + blk (f#ms); /* initialize sector to read from */      ls.read.sec = ls_cat_start + blk (f#ls);      if ls.read.sec ILT ls_cat_start then ms.read.sec = ms.read.sec + 1;      ms.write.sec = f#ms_sector; /* initialize sector to write to */      ls.write.sec = f#ls_sector;      do while (ms_num_secs <> 0) or (ls_num_secs <> 0); /* loop over source disks if necessary */         call transfer_segment (buf, bufsize, blk (f#ml), blk (f#ll)); /* transfer this segment */         ms_num_secs = ms_num_secs - blk (f#ml); /* keep track of what we've transferred */         if ls_num_secs ILT blk (f#ll) then ms_num_secs = ms_num_secs - 1;         ls_num_secs = ls_num_secs - blk (f#ll); /* keep track of what we've transferred */         if (load.dump and ((ms_num_secs <> 0) or (ls_num_secs <> 0))) then do; /* get next source disk if we're reloading a dump file */            disk.number = disk.number + 1; /* increment the disk number */            call get_next_segment (name, blk, buf); /* get the next file segment */            ms.read.sec = ms_cat_start + blk (f#ms); /* get source starting sector */            ls.read.sec = ls_cat_start + blk (f#ls); /* get source starting sector */            if ls.read.sec ILT ls_cat_start then ms.read.sec = ms.read.sec + 1;         end;      end; /* of loop over source disks */   end; /* of make sure it's on the destination */   else print '*** System error:  file ', string(name), ' not installed.';   disk.label = addr(dummy_label (0)); /* reinitialize disk.label (so we don't risk blowing up) */end transfer_file;