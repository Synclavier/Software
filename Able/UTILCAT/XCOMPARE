/* COMPARE  $title Source Compare Utility *//* This program compares the contents of two files and prints the results.  to the screen.  The program is designed for text files, but it will.  also compare binary files...  By:  Karim J. Chichakly on 27 October 1986*/configuration modelC, MULDIV;dcl rel.date data ('15 January 1987');insert ':-xpl:literals'; /* get general literals */insert ':-xpl:asciilit'; /* get ASCII literals */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:fileio'; /* get buffered file I/O */insert ':-xpl:termut'; /* terminal utilities */insert ':-xpl:strings'; /* string processing *//* literals */dcl match_default lit '3'; /* default match size */dcl match_limit   lit '10'; /* maximum match size */dcl line_max      lit '80'; /* maximum word length of a line (160 chars) */dcl treename_len  lit '24'; /* treename buffer size */dcl buf_size      lit '1024'; /* input file buffer size */dcl null          lit '0'; /* NULL pointer *//* linked list structure */dcl l.next   lit '0'; /* pointer to next element */dcl l.number lit '1'; /* line number of line */dcl l.line   lit '2'; /* line from file (XPL string format) */dcl l.header lit '2'; /* length of header *//* global variables */dcl free_list pointer; /* linked list of free blocks */dcl old_match pointer; /* pointer to line where we sync'd up with NEW (returned by MATCH) */dcl new_match pointer; /* pointer to line where we sync'd up with OLD (returned by MATCH) */dcl binary    boolean; binary = false; /* TRUE if binary rather than source compare */dcl different boolean; different = false; /* assume the same */when break then do; /* let them out on BREAK */   if systyp = 0 then do; /* make sure there's a system disk on floppy systems */      redirection_word = no_redirection; /* don't redirect this message */      pstring ('Insert a SYSTEM disk into F0 and press RETURN ->');      clear_typeahead; call rchar;   end;   call exit (0);end;/* $subtitle Linked List Management:  Insert, Append, Remove *//* This procedure inserts the item at address NEW at the head of linked  list LIST.  The new value of LIST is returned. */insert: proc(list, new) returns (pointer); /* insert block at beginning of linked list */   dcl list pointer; /* list to append to */   dcl new  pointer; /* address of new block to append */   core(new + l.next) = list; /* set new one pointing to first block */   return (new); /* return new head of list */end insert;/* This procedure appends the item at address NEW to the tail of linked  list LIST.  The new value of LIST is returned. */append: proc(list, new) returns (pointer); /* append block to end of linked list */   dcl list pointer; /* list to append to */   dcl new  pointer; /* address of new block to append */   dcl p    pointer;   if list <> null then do; /* make sure it isn't a null pointer */      p = list; /* start at head of list */      do while (core(p + l.next) <> null); /* look for end of list */         p = core(p + l.next); /* pick up next pointer */      end;      core(p + l.next) = new; /* set this one pointing to the new block */   end; /* of non-null pointer */   else list = new; /* start list */   core(new + l.next) = null; /* new end of list */   return (list); /* return head of list */end append;/* This procedure removes the item at the head of linked list LIST.  The  new value of LIST is returned. */remove: proc(list) returns (pointer); /* remove first element from linked list */   dcl list pointer; /* list to remove first element from */   if list <> null /* if non-null list */   then list = core(list + l.next); /* pick up next pointer from first record */   return (list); /* return new pointer */end remove;/* $subtitle Free List Management:  Get_Block, Free_Block, Create_Free *//* This procedure removes a block from the free list and returns a pointer  to it.  This block can then be used by the programmer as he chooses.  All blocks are fixed length.  The block is pulled off the front of  the list.  The main code assumes GET_BLOCK returns the block at the head of the free  list while FREE_BLOCK puts the passed block at the head of the free list. */get_block: proc returns (pointer); /* get a free block */   dcl p pointer;   p = free_list; /* pick up first block */   free_list = remove (free_list); /* and remove it from free list */   return (p); /* return pointer to block */end get_block;/* This procedure returns the block pointed to by P to the free list.  The block is inserted at the beginning of the free list. */free_block: proc(p); /* free a block */   dcl p pointer; /* pointer to block to free */   free_list = insert (free_list, p); /* just insert at beginning of free list */end free_block;/* This procedure creates the initial free list with fixed size blocks  of size SIZE words. */create_free: proc(size); /* create free list */   dcl size   fixed; /* size of each block */   dcl (i, j) fixed;   free_list = null; /* no list yet */   j = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* find the heap */   i = loc.load; /* and end of heap */   do while (i ige j); /* create free list */      i = i - size; /* point to next block */      call free_block (i); /* this block is free */   end;end create_free;/* $subtitle Data List Management:  Add_Line, Delete_Line *//* This procedure reads a line from file F and appends it to LIST.  If  there isn't a free block for the new line, the program is terminated.  It returns the new value of LIST. */add_line: proc(f, list) returns (pointer); /* get next line from file F and add it to LIST */   dcl f               file; /* file to get line from */   dcl list            pointer; /* linked list to add line to */   dcl line (line_max) fixed; /* line buffer */   dcl end_of_file     boolean; /* TRUE if at end of file */   dcl p               pointer;   dcl i               fixed;   if binary then do; /* if a binary compare */      end_of_file = feof (f); /* check BEFORE reading */      i = getw (f); /* get next word from file F */   end;   else do; /* source compare */      i = fgets (line, shl(line_max, 1), f); /* get next line from file F */      end_of_file = (i = EOF_mark); /* check AFTER reading in case was a binary file in disguise */   end;   if not end_of_file then do; /* if not at end-of-file (can't use EOF_MARK w/binaries) */      p = get_block; /* get a block of storage */      if p = null then do; /* out of memory? */         pstring ('Too many differences (at ');         if binary then do; pstring ('address '); onum (core(list + l.number), 6); end;         else do;           pstring ('line ');    unum (core(list + l.number), 0); end;         pstringr (')!');         call exit(-1);      end;      list = append (list, p); /* add this line to the list */      if binary then do; /* if a binary compare */         core(p + l.number) = shr(seek (f, 0, 1), 1) - 1; /* save address (SEEK points to next word now) */         core(p + l.line) = i; /* and value */      end;      else do; /* text compare */         core(p + l.number) = i; /* save line number */         call strcpy (loc(p + l.line), line); /* copy the string over */      end;      xon_xoff (-1); /* let break pass through */      if not term_idle then do; /* see if terminal input */         i = rchar; /* get character */         if i = a.nul then do; pstring ('Comparison aborted at '); p = list; end; /* break */         else                  pstring ('*** comparing '); /* print status */         if binary then do; pstring ('address '); onum (core(p + l.number), 6); end;         else do;           pstring ('line ');    unum (core(p + l.number), 0); end;         crlf;         if i = a.nul then do; flush_term; call exit (0); end; /* break - get out */      end; /* of terminal input */      xon_xoff (true);   end; /* of if not at end-of-file */   return (list); /* return the new list pointer */end add_line;/* This procedure deletes the first line from LIST.  Note that the block  MUST be removed from LIST before it can be freed.  It returns the  new value of LIST. */delete_line: proc(list) returns (pointer); /* delete first line from LIST */   dcl list pointer; /* list to delete line from */   dcl p    pointer;   p = remove (list); /* remove block from list */   call free_block (list); /* free the block */   return (p); /* return new start of list */end delete_line;/* $subtitle Source Comparison:  Equal *//* This procedure compares N lines in a linked list starting at pointers  OLDP and NEWP.  If all N lines match between the two lists, a boolean  TRUE is returned.  Otherwise, a boolean FALSE is returned. */equal: proc(oldp, newp, n) returns (boolean); /* see if next N lines of OLD match next N lines of NEW */   dcl oldp    pointer; /* pointer to lines from OLD file */   dcl newp    pointer; /* pointer to lines from NEW file */   dcl n       fixed; /* number of lines to compare (essentially MATCH_SIZE) */   dcl matched boolean; /* TRUE if all the lines match */   dcl i       fixed;   i = 0; matched = true; /* assume a match */   do while (matched and (i < n) and (oldp <> null) and (newp <> null)); /* check all N lines (assume match if either file ends) */      if binary /* binary compare? */      then matched = (core(oldp + l.line) = core(newp + l.line)); /* compare words */      else matched = (strcmp (loc(oldp + l.line), loc(newp + l.line)) = 0); /* compare the lines */      if matched then do; /* if a match */         oldp = core(oldp + l.next); /* point to next line */         newp = core(newp + l.next);         i = i + 1;      end; /* of a match */   end; /* of checking all N lines */   return (matched); /* return whether they're equal */end equal;/* $subtitle Source Comparison:  Match *//* This procedure attempts to resynchronize two mismatched lists.  OLDP  and NEWP initially represent the start of each list.  OLD_ANCHOR and  NEW_ANCHOR represent the end of each list (although MATCH_SIZE records  should be present starting at these points).  MATCH_SIZE is the number  of lines that must match between the two files for a resynchronization  to occur.  If the lists resynchronize, a boolean TRUE is returned  and OLD_MATCH, NEW_MATCH contain pointers to where the resynchronization  occurred in each list.  Otherwise, a boolean FALSE is returned.  This algorithm works by "anchoring" one end of one list (the end point,  in particular) and varying the other list's pointer.  A comparison is  made at each value of the other list's pointer.  This is then repeated  with the other list's end point anchored.  The implementation does  this in one, rather than two, loops and therefore does not appear  this simple. */match: proc(oldp, newp, old_anchor, new_anchor, match_size) returns (boolean); /* try to sync up the two files by finding MATCH_SIZE lines that match */   dcl oldp       pointer; /* pointer into list of OLD lines (start search here) */   dcl newp       pointer; /* pointer into list of NEW lines (start search here) */   dcl old_anchor pointer; /* pointer to anchor point at end of list of OLD lines */   dcl new_anchor pointer; /* pointer to anchor point at end of list of NEW lines */   dcl match_size fixed; /* number of lines that must match */   dcl matched    boolean; /* TRUE if a match is found */   old_match = old_anchor; /* assume we match at anchor point */   new_match = new_anchor;   matched = equal (old_anchor, new_anchor, match_size); /* see if sync'd at anchor point */   do while ((not matched) and ((oldp <> old_anchor) or (newp <> new_anchor))); /* check all the way up to the anchor point */      if newp <> new_anchor then do; /* if new pointer not to anchor point yet */         matched = equal (old_anchor, newp, match_size); /* see if sync'd up */         if matched then new_match = newp; /* sync'd with NEW at NEWP */         newp = core(newp + l.next); /* point to next line */      end; /* of new pointer not to anchor point yet */      if ((not matched) and (oldp <> old_anchor)) then do; /* if old pointer not to anchor point yet */         matched = equal (oldp, new_anchor, match_size); /* see if sync'd up */         if matched then old_match = oldp; /* sync'd with OLD at OLDP */         oldp = core(oldp + l.next); /* point to next line */      end; /* of old pointer not to anchor point yet */   end; /* of checking up to anchor point */   return (matched); /* return whethr we sync'd up */end match;/* $subtitle Formatted Output:  Print_Lines, Header *//* This procedure prints lines from list LIST.  It starts printing  from the beginning of the list and stops at the record which  points to LAST (i.e., the record before).  It also deletes  every line it outputs.  It returns the new value of LIST. */print_lines: proc(list, last) returns (pointer); /* print and delete lines from start of LIST to one before LAST */   dcl list pointer; /* pointer to start of list */   dcl last pointer; /* pointer to last line to print */   different = true; /* the files are different if we print any lines */   do while (list <> last); /* until we reach LAST */      if binary then do; /* if binary compare */         pstring (' '); onum (core(list + l.number), 6); pstring (':  '); /* start with address */         onum (core(list + l.line), 6); crlf; /* then output value */      end;      else do; /* text compare */         pstring (' '); unum (core(list + l.number), 0); pstring (' '); /* start with line number */         pstringr (loc(list + l.line)); /* then output line */      end;      list = delete_line (list); /* delete this line and point to next line */   end; /* of until reach LAST */   return (list); /* return new list pointer */end print_lines;/* This procedure prints a header before a block of changes. */header: proc(redirect); /* output header before a block of changes */   dcl redirect fixed; /* user specified redirection */   if redirect = no_redirection /* if no redirection specified */   then clear_screen; /* clear the screen */   else do; crlf; crlf; end; /* skip a few lines on printer */end header;/* $subtitle Main Program:  Compare Two Source Files */dcl old_name (treename_len) fixed; /* name of old file */dcl new_name (treename_len) fixed; /* name of new file */dcl old_buf  (buf_size - 1) fixed; /* old file buffer */dcl new_buf  (buf_size - 1) fixed; /* new file buffer */dcl (old, new) file; /* two files to compare */dcl match_size fixed; /* number of successive lines to match to be considered equal */dcl redirect   fixed; /* current redirection */dcl i          fixed;dcl old_list   pointer; old_list = null; /* linked list for old file */dcl new_list   pointer; new_list = null; /* linked list for new file */dcl old_anchor pointer; /* pointer to current anchor in list of old lines */dcl new_anchor pointer; /* pointer to current anchor in list of new lines */dcl old_tail   pointer; /* pointer to tail (minus MATCH_SIZE) of list of old lines */dcl new_tail   pointer; /* pointer to tail (minus MATCH_SIZE) of list of new lines */redirect = directed_output; /* save specified output device */redirection_word = no_redirection; /* temporarily turn off redirection */pstring ('Compare Utility - '); pstringr (rel.date); crlf;get_string ('Old file: ', 0, old_name, shl(treename_len, 1)); crlf;if old_name (0) = 0 then call exit (0);old = fopen (old_name, 'r'); /* open old file */if old = nullf then do; /* file probably missing */   pstring ('File "'); pstring (old_name); pstringr ('" not found.');   call exit (-1);end;call setbuf (old, addr(old_buf (0)), 0, buf_size); /* set up buffer (FILEIO's default interferes w/free list) */if f#type <> t#text then binary = true; /* if not a text file, do binary compare */get_string ('New file: ', 0, new_name, shl(treename_len, 1)); crlf;if new_name (0) = 0 then call exit (0);new = fopen (new_name, 'r'); /* open new file */if new = nullf then do; /* file probably missing */   pstring ('File "'); pstring (new_name); pstringr ('" not found.');   call exit (-1);end;if ((not binary) and (f#type <> t#text)) then do; /* is it a text file? */   pstring ('File "'); pstring (new_name); pstringr ('" is not a text file.');   call exit (-1);end;call setbuf (new, addr(new_buf (0)), 0, buf_size); /* set up buffer (FILEIO's default interferes w/free list) *//* pstring ('Match size? '); match_size = getnum; crlf; */if match_size = 0 then match_size = match_default; /* set default */else if match_size igt match_limit then match_size = match_limit; /* limit match size *//* Warning:  The free list overwrites the catalog buffer allocated by FILEIO! */if binary /* if binary compare */then call create_free (1 + l.header); /* create free list with one data word */else call create_free (line_max + 1 + l.header); /* create free list for text */do i = 1 to match_size; /* start the ball rolling */   old_list = add_line (old, old_list); /* get next line from OLD and add it to OLD_LIST */   new_list = add_line (new, new_list); /* get next line from NEW and add it to NEW_LIST */end; /* of getting the ball rolling */old_tail = old_list; new_tail = new_list; /* end of list is at start here */redirection_word = redirect; /* redirect according to user's wishes */if redirect <> no_redirection then do; /* if output was redirected to printer */   screen_size (-1, -1); /* don't truncate printer */   crlf; crlf;   pstring ('Old file:  '); pstring (old_name);   pstring ('                       New file:  '); pstringr (new_name);end;/* $page */do while ((old_list <> null) and (new_list <> null)); /* stop when either file ends (should end together) */   if not equal (old_list, new_list, 1) then do; /* if current line doesn't match */      old_anchor = old_list; /* start searching from start of list */      new_anchor = new_list;      do while (not match (old_list, new_list, old_anchor, new_anchor, match_size)); /* try to sync up the files */         old_list = add_line (old, old_list); /* get another line from OLD */         new_list = add_line (new, new_list); /* and from NEW */         if not feof (old) then old_tail = core(old_tail + l.next); /* advance till end of file */         if not feof (new) then new_tail = core(new_tail + l.next); /* advance till end of file */         if ((old_anchor = old_tail) and (new_anchor = new_tail)) then do; /* if at end of both */            old_tail = null; new_tail = null; /* zap tail pointers */         end; /* of at end of both files */         if old_anchor <> old_tail /* if not at end of old file */         then old_anchor = core(old_anchor + l.next); /* move anchor point up a line (MATCH succeeds if it ever goes NULL) */         if new_anchor <> new_tail /* or end of new */         then new_anchor = core(new_anchor + l.next);      end; /* of syncing up the files */      call header (redirect); /* output header */      if old_match = old_list then do; /* if lines inserted in NEW file */         pstring ('Inserted in "'); pstring (new_name); pstringr ('":');         new_list = print_lines (new_list, new_match); /* print new lines */      end;      else if new_match = new_list then do; /* if lines deleted from OLD file */         pstring ('Deleted from "'); pstring (old_name); pstringr ('":');         old_list = print_lines (old_list, old_match); /* print original lines */      end;      else do; /* lines changed */         pstring ('File "'); pstring (old_name); pstringr ('":');         old_list = print_lines (old_list, old_match); /* print original lines */         pstring ('Changed in "'); pstring (new_name); pstringr ('" to:');         new_list = print_lines (new_list, new_match); /* print new lines */      end;      if redirect = no_redirection then do; /* pause if no redirection */         pstring ('Press RETURN to continue >');         clear_typeahead; call rchar; crlf;      end;   end; /* of current line doesn't match */   else do; /* current line matches - move on */      /* Note:  OLD_TAIL and NEW_TAIL do not need to be maintained since the         added line's block will overwrite the deleted line's block and these         variables are only used to resolve end of file problems. */      old_list = delete_line (old_list); /* get rid of current line from OLD */      old_list = add_line (old, old_list); /* add another line */      new_list = delete_line (new_list); /* get rid of current line from NEW */      new_list = add_line (new, new_list); /* add another line */   end; /* of moving on */end; /* of while both files haven't ended */if old_list <> null then do; /* if old file hasn't ended */   call header (redirect); /* output header */   pstring ('Deleted from "'); pstring (old_name); pstringr ('":');   do while (old_list <> null); /* output rest of old file */      old_list = print_lines (old_list, core(old_list + l.next)); /* print this line */      old_list = add_line (old, old_list); /* and get another */   end;end; /* of old file hasn't ended */else if new_list <> null then do; /* if new file hasn't ended */   call header (redirect); /* output header */   pstring ('Appended to "'); pstring (new_name); pstringr ('":');   do while (new_list <> null); /* output rest of new file */      new_list = print_lines (new_list, core(new_list + l.next)); /* print this line */      new_list = add_line (new, new_list); /* and get another */   end;end; /* of new file hasn't ended */else if not different then pstringr ('No differences.'); /* no differences found */if redirect <> no_redirection /* if output was redirected to printer */then wchar (a.ff); /* end with formfeed */call fclose (old); /* close the files */call fclose (new);flush_term; /* and flush the terminal's buffer before leaving */if systyp = 0 then do; /* make sure there's a system disk on floppy systems */   redirection_word = no_redirection; /* don't redirect this message */   pstring ('Insert a SYSTEM disk into F0 and press RETURN ->');   clear_typeahead; call rchar;end;