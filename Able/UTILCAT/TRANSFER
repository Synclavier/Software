/* $subtitle Get The Next Dump File Segment *//* These routines access the PERFORM.COPY variable INDEX and alter the  global NEED.TO.COPY and the PERFORM.COPY variable ABORT.COPY. */dcl h.name          lit '0';  /* dump file header: name */dcl h.file.type     lit '5';  /*                   type */dcl h.file.length   lit '6';  /*                   length (mod 64K) */dcl h.sector.length lit '7';  /*                   LSB sector length */dcl h.disk.number   lit '8';  /*                   disk number */dcl h.ms.sector     lit '9';  /*                   MSB sector length */dcl h.len           lit '10'; /*                   length of header */dcl ms.read.sec    fixed; /* MSB of sector to read from */dcl ls.read.sec    fixed; /* LSB of sector to read from */dcl ms.write.sec   fixed; /* MSB of sector to write to  */dcl ls.write.sec   fixed; /* LSB of sector to write to  */dcl disk.number    fixed; /* disk number for files that span many disks (multidisk copies) */dcl total.disks    fixed; /* total disks for multidisk copies */dcl last_track     fixed; /* last track on destination if tape drive */dcl dump.multidisk boolean; /* TRUE if we're dumping a large file (multidisk dest) */dcl load.multidisk boolean; /* TRUE if we're reloading a dump file (multidisk source) *//* $page */get.next.segment: proc (blk, buf); /* get next dump file segment - set BLK to new segment's FCB */   dcl blk           fixed array; /* FCB */   dcl buf           fixed array; /* buffer */   dcl prompt        boolean; /* TRUE if we should prompt and inform user during first pass */   dcl disk_inserted boolean; /* TRUE if they've inserted a disk */   dcl (i, j)        fixed;   buf (h.disk.number) = 0; /* set this to an invalid disk number */   prompt = (disk.number <> 1); /* always skip the messages the first time through with disk one */   do while (buf (h.disk.number) <> disk.number); /* get proper disk */      disk_inserted = (not prompt); /* the disk is already inserted if we aren't prompting */      do while (not disk_inserted); /* keep asking until they give us the disk */         erase_command;         pcmd ('Please place disk number '); unum (disk.number, 0); pstring (' for file '); pstring (nam); pstring (' into '); call name (sour); crlf;         pstring ('and press RETURN (or type Q to quit copying) ->');         clear_typeahead; i = rchar; /* wait for input */         erase_command; pos (cmdline + 1, 0); erase_line;         if ((i = a.q) or (i = l.q) or (i = a.nul)) /* did they type Q or q? */         then do; abort.copy = true; return; end; /* yes, quit here */         else if i = a.refresh then call print.menu; /* refresh display */         else disk_inserted = disk_check (sour); /* make sure we got it */      end;      call read.cache (true); /* read the source catalog */      i = findfile (nam); /* find the file we're looking for */      if i = -1 then do; /* we didn't find it! */         if prompt then do; pcmd ('File '); pstring (nam); pstring (' is not on this disk.'); flush_term; wait (400); end;      end;      else do; /* we found it */         call get_fcb (i, blk); /* get the file's FCB */         if blk (f#ty) <> t#dump then do; /* this file isn't a dump file! */            if prompt then do; pcmd ('File '); pstring (nam); pstring (' is not a dump file.'); flush_term; wait (400); end;         end;         else do; /* it's a dump file */            if c#ls_sector + blk (f#ls) ilt c#ls_sector then j = 1; else j = 0; /* increment j if carry to MSB */            call readdata (c#ms_sector + blk (f#ms) + j, c#ls_sector + blk (f#ls), buf, h.len);  /* read in header */            if buf (h.disk.number) <> disk.number then do; /* this isn't the right disk! */               if prompt then do; /* only tell them of their error when it was their error */                  pcmd ('This is disk number '); unum (buf (h.disk.number), 0);                  pstring (', not disk number '); unum (disk.number, 0); pstring (' (file '); pstring (nam); pstring (').'); flush_term; wait (400);               end;            end;            else do; /* remember we read the first sector in */               blk (f#ls) = blk (f#ls) + 1; /* increment the LSB of starting sector */               if blk (f#ls) = 0 then blk (f#ms) = blk (f#ms) + 1; /* carry */               if blk (f#ll) = 0 then blk (f#ml) = blk (f#ml) - 1; /* borrow */               else blk (f#ll) = blk (f#ll) - 1; /* decrease LSB of sector length */            end;         end;      end;      prompt = true; /* after first pass, always output messages */   end;   pos (22, 0); erase_line; /* clean up */end get.next.segment;/* $subtitle Copy a File Segment From the Source to the Destination */transfer_segment: proc (buf, bufsize, ms.sec.left, ls.sec.left) returns (boolean); /* transfer a file segment - return status indication */   dcl buf         fixed array; /* transfer buffer */   dcl bufsize     fixed; /* size of the transfer buffer */   dcl ms.sec.left fixed; /* MSB number of sectors (on this disk) yet to transfer */   dcl ls.sec.left fixed; /* LSB number of sectors (on this disk) yet to transfer */   dcl hunk        fixed; /* size of transfer block */   dcl stype       fixed; /* source device type */   dcl sadr        fixed; /* source device address */   dcl dtype       fixed; /* destination device type */   dcl dadr        fixed; /* destination device address */   dcl copied      boolean; /* set FALSE if the transfer fails */   dcl s#copy proc(fixed, fixed, fixed, fixed, fixed, fixed, fixed) returns (boolean) external; /* SCSI tape to disk copy */   dcl typmsk    lit '"H30F"'; /* used to preserve the device type bits */   dcl scsi.disk lit '"H101"'; /* device type bits for a SCSI winchester */   dcl scsi.tape lit '"H103"'; /* device type bits for a SCSI tape drive */   /* The following conditions must prevail to do a SCSI Copy command:        1. Both the source and destination devices must be SCSI.        2. One device must be a disk drive, and one must be a tape drive.        3. Both must use the same D24 board.        4. The length of the file to transfer must be greater than the buffer.      If all these conditions are met, the copy is performed.   */   copied = true; /* assume we can transfer the segment with no problems */   hunk = find_device (sour); /* look up source device in configuration */   stype = (core(hunk + s#devtyp) and typmsk); /* source device type from configuration */   sadr = core(hunk + s#devadr); /* source device address from configuration */   hunk = find_device (dest); /* look up destination device in configuration */   dtype = (core(hunk + s#devtyp) and typmsk); /* destination device type */   dadr = core(hunk + s#devadr); /* destination device address */   if (((ms.sec.left <> 0) or (ls.sec.left igt shr(bufsize, 8))) /* check if a SCSI copy can be performed */   and (((stype = scsi.disk) and (dtype = scsi.tape)) or ((stype = scsi.tape) and (dtype = scsi.disk))) /* SCSI disk and SCSI tape */   and ((sadr and "HF0") = (dadr and "HF0"))) then do; /* same D24 # */      if stype = scsi.tape then do; /* if source is a tape... */         call readdata (ms.read.sec, ls.read.sec, buf, 0); /* seek to the starting tape block */         copied = s#copy (sour, dest, ms.write.sec, ls.write.sec, ms.sec.left, ls.sec.left, true); /* copy tape to disk */      end;      else do; /* if source is a disk... */         call readdata (ms.write.sec, ls.write.sec, buf, 0); /* seek to the starting tape block */         copied = s#copy (dest, sour, ms.read.sec, ls.read.sec, ms.sec.left, ls.sec.left, false); /* copy disk to tape */      end;   end; /* of SCSI copy */   /* $page */   /* transfer the file the hard way */   else do; /* otherwise do a normal transfer */      if ms.sec.left = 0 /* find size of transfer */      then hunk = min (shr(bufsize, 8), ls.sec.left);      else hunk = shr(bufsize, 8); /* if MSB exists use buffer size for transfer size */      do while ((ms.sec.left <> 0) or (ls.sec.left <> 0)); /* transfer in chunks if need be */         call get.disk ('SOURCE'); /* prompt user for source disk */         call trigger_motor (sour);      	call disk.io.setup;         call readdata (ms.read.sec, ls.read.sec, buf, shl(hunk,8));			if (disk.io.cleanup()) then do;				read_error = true;				return (false);			end;         call get.disk ('DESTINATION'); /* prompt user for destination disk */         call trigger_motor (dest);      	call disk.io.setup;         call writedata (ms.write.sec, ls.write.sec, buf, shl(hunk,8));			call disk.io.cleanup;			if (disk.io.cleanup()) then do;				write_error = true;				return (false);			end;         if tape (sour) /* tape drive source? */         then ls.read.sec = -1; /* ensure we don't seek in the middle */         else do; /* no, read from next sector */            ls.read.sec = ls.read.sec + hunk;            if ls.read.sec ilt hunk then ms.read.sec = ms.read.sec + 1; /* carry */         end;         if tape (dest) /* tape drive destination? */         then ls.write.sec = -1; /* ensure we don't seek in the middle */         else do; /* no, write to next sector */            ls.write.sec = ls.write.sec + hunk;            if ls.write.sec ilt hunk then ms.write.sec = ms.write.sec + 1; /* carry */         end;           if ls.sec.left ilt hunk then ms.sec.left = ms.sec.left - 1; /* borrow */         ls.sec.left = ls.sec.left - hunk; /* subtract hunk from sectors remaining */         if ms.sec.left = 0 /* find size of transfer */         then hunk = min (shr(bufsize, 8), ls.sec.left);         else hunk = shr(bufsize, 8); /* if MSB exists use buffer size for transfer size */         if tape (dest) /* tape drive destination? */         then do; /* yes, see if we've run off the tape */            if ((shr(tape_status and track_mask, track_shift) = last_track) /* if on last track */            and ((tape_status and end_of_tape) <> 0) /* and at logical end of tape */            and ((ms.sec.left <> 0) or (ls.sec.left <> 0))) /* and some sectors left to transfer */            then do; /* we've run off the tape */               ms.sec.left = 0; ls.sec.left = 0; /* make sure we exit loop */               ms.write.sec = 0; /* set MSB to zero */               ls.write.sec = 0; /* and flag the error */               copied = false; /* we didn't succeed in transferring it */            end;         end;                  interp_run_host_250();      end; /* of transfer in chunks */   end; /* of normal transfer */   return (copied); /* return operation status */end transfer_segment;/* $subtitle Copy a File From Many Sources to One Destination */transfer_file: proc (blk, buf, bufsize) returns (boolean); /* copy file described by BLK to destination */   dcl blk         fixed array; /* FCB of file to transfer */   dcl buf         fixed array; /* the buffer */   dcl bufsize     fixed; /* size of buffer */   dcl ms_num_secs fixed; /* MSB of number of sectors of this file on this disk */   dcl ls_num_secs fixed; /* LSB of number of sectors of this file on this disk */   dcl copied      boolean; /* set TRUE if we successfully copy the file */   dcl i           fixed;   copied = false; /* assume we can't copy the file */   if load.multidisk then do; /* if we're reloading a dump file */      disk.number = 1; /* we're starting with the first disk */      call get.next.segment (blk, buf); /* if this isn't the right disk, get the right one! */      if abort.copy then return (false); /* get out of here if the user wants to quit */      blk (f#wd) = buf (h.file.length); /* reset the file word length */      blk (f#ty) = buf (h.file.type); /* and the file type */      call read.cache (true); /* read the source catalog */      ms_num_secs = c#ms_length; /* MSB of catalog length in sectors */      ls_num_secs = c#ls_length - shr(c#dir_size, 8); /* LSB of catalog length in sectors */      total.disks = (buf (h.sector.length) + (ls_num_secs - 2))/(ls_num_secs - 1); /* number of empty disks needed to save file (assume always dump to floppies, file length < 32MB) */      ls_num_secs = buf (h.sector.length); /* reset the LSB sector length */   end;   else do;      ms_num_secs = blk (f#ml); /* MSB of number of sectors for this file on this disk */      ls_num_secs = blk (f#ll); /* LSB of number of sectors for this file on this disk */   end;   if (dump.multidisk and (ls_num_secs + 1 = 0)) then i = 1; else i = 0; /* MS carry */   if replace (nam, blk (f#ty), ms_num_secs + i, ls_num_secs + (dump.multidisk and 1), blk (f#wd), dest) then do;      ms.read.sec = ms.start + blk (f#ms); /* initialize LSB of sector to read from */      ls.read.sec = ls.start + blk (f#ls); /* initialize MSB of sector to read from */      if ls.read.sec ilt ls.start then ms.read.sec = ms.read.sec + 1; /* carry */      ms.write.sec = f#ms_sector; /* file variables set by REPLACE */      ls.write.sec = f#ls_sector; /* LSB of sector to write to */      if dump.multidisk then do;           ls.write.sec = ls.write.sec + 1; /* add one if multidisk copy */         if ls.write.sec = 0 then ms.write.sec = ms.write.sec + 1;      end;      pos (0, 56); pstring (nam); erase_line;      if total.disks <> 0 then do; pos (1, 56); unum (total.disks, 0); erase_line; end;		      do while (ms_num_secs <> 0) or (ls_num_secs <> 0); /* loop over source disks if necessary */         if total.disks <> 0 then do;            pos (0, 56 + nam (0) + 1);            if dump.multidisk then pstring ('to'); else pstring ('from');            pstring (' disk '); unum (disk.number, 0);         end;         flush_term; /* flush the terminal output buffer */         if transfer_segment (buf, bufsize, blk (f#ml), blk (f#ll)) then do; /* transfer this segment */            ms_num_secs = ms_num_secs - blk (f#ml); /* keep track of what we've transferred already */            if ls_num_secs ilt blk (f#ll) then ms_num_secs = ms_num_secs - 1; /* borrow */            ls_num_secs = ls_num_secs - blk (f#ll);         end;         else do;            ms_num_secs = 0; ls_num_secs = 0; /* transfer failed - get out of here */ 								if (read_error != 0 || write_error != 0)				{					delete(nam, dest);				 /* delete the partial file */					return (false);				}				         end;         if (load.multidisk and ((ms_num_secs <> 0) or (ls_num_secs <> 0))) then do; /* get next source disk if we're reloading a dumpfile */            disk.number = disk.number + 1; /* increment the disk number */            call get.next.segment (blk, buf); /* get the next file segment */            if abort.copy then return (false); /* get out of here if the user wants to quit */            ms.read.sec = ms.start + blk (f#ms); /* get source MSB starting sector */            ls.read.sec = ls.start + blk (f#ls); /* get source LSB starting sector */            if ls.read.sec ilt ls.start then ms.read.sec = ms.read.sec + 1; /* carry */         end;      end; /* of loop over source disks *//* $page */      if tape (dest) /* tape drive destination? */      then do; /* yes, finish up file */         if ((ms.write.sec = 0) and (ls.write.sec = 0)) /* did we run off the end of the tape? */         then do; /* yes, clean up */            call delete (nam, dest); /* delete the filename from the catalog */            if ((shr(f#ls_sector, track_shift) = last_track) /* did the file start on the last track? */            and ((f#ls_sector and file_mask) > 1)) then do; /* and this isn't the first file on this track, then tape is full */               call reverse_file  (dest, 0, 1); call check_tape; /* reverse space file */               call forward_space (dest, 0, 1); call check_tape; /* forward space record (so we're after the filemark) */               call erase (dest, true); call check_tape; /* clean up to the end of the file */               call set_full (dest); /* and set the tape to full */            end; /* of tape is full */            else do; /* tape isn't quite full yet */               call read_catalog ('', dest); /* pick up catalog */               call get_fcb (0, buf); /* pick up free block pointer */               buf (f#ls) = f#ls_sector; /* reset next file pointer */               call put_fcb (0, buf); /* put it back */               call write_catalog; /* write it back out *//*               call reverse_file  (dest, 0, 1); call check_tape; * reverse space file *//*               call forward_space (dest, 0, 1); call check_tape; * forward space record (so we're after the filemark) */               tape_position (dest and 1) = -1; /* force a seek from the beginning of the track we started on */               call readdata (f#ms_sector, f#ls_sector, buf, 0); /* seek back to start of file (assumes 16-bit tape position) */               call erase (dest, true); call check_tape; /* clean up to the end of the file *//*               call reverse_file  (dest, 0, 1); call check_tape; * reverse space file *//*               call forward_space (dest, 0, 1); call check_tape; * forward space record (so we're after the filemark) */               tape_position (dest and 1) = -1; /* force a seek from the beginning of the track we started on */               call readdata (f#ms_sector, f#ls_sector, buf, 0); /* seek back to start of file (assumes 16-bit tape position) */            end; /* of tape isn't full yet */         end;         else do; /* no, end the file */            call end_file (dest); /* like so */            copied = true; /* file successfully copied */         end;      end;      else copied = true; /* file successfully copied */      if not dump.multidisk then do; pos (0, 56); erase_line; pos (1, 56); erase_line; end; /* clean up here unless multidisk dump */   end; /* of if replace then do */   else do; /* REPLACE failed, set this error flag for later */      if c#status = e#dir_full then dir_full = true; /* full directory */      else dir_full = false; /* no storage available */   end;   return (copied); /* return whether or not the file was copied */end transfer_file;/* $subtitle Copy a File From the Source to the Destination */transfer: proc (blk, buf, bufsize) returns (boolean); /* copies file described by BLK - totally destroys BLK */   dcl blk             fixed array; /* FCB of file to transfer */   dcl buf             fixed array; /* the buffer */   dcl bufsize         fixed; /* size of buffer */   dcl ms.sectors.left fixed; /* MSB of sectors left to copy (multidisk dumps) */   dcl ls.sectors.left fixed; /* LSB of sectors left to copy (multidisk dumps) */   dcl ms.start.sec    fixed; /* MSB of starting sector of next "hunk" (multidisk dumps) */   dcl ls.start.sec    fixed; /* LSB of starting sector of next hunk */   dcl (ml, ll)        fixed; /* blk (f#ml), blk (f#ll) */   dcl (wd, ty, i)     fixed; /* blk (f#wd), blk (f#ty) */   dcl level           fixed; /* preserve trashed cache level here */   dcl format.success  boolean; /* TRUE if the destination format is successful */   dcl replace.file    boolean; /* TRUE if we should overwrite an existing file */   dump.multidisk = (need.to.copy (index) = multidisk.dump); /* multidisk destination? */   load.multidisk = (need.to.copy (index) = multidisk.load); /* multidisk source? */   disk.number = 0; /* no disks yet */   total.disks = 0; /* assume only one disk */   call disable_cache (scache); /* forget we know the source catalog (in case SOUR = DEST) */   if tape (sour) then do; /* tape drive source? */      i = find_device (sour); /* find it in the configuration */      if (shr(core(i + s#devtyp), 8) and "3") = 1 /* SCSI? */      then bufsize = (bufsize/block_size)*block_size; /* round down to nearest multiple of the block size */      else bufsize = block_size; /* otherwise, it's the Kennedy and we need to read/write in block size chunks */   end; /* of tape drive source */   if tape (dest) then do; /* if tape drive destination */      i = find_device (dest); /* find it in the configuration */      last_track = core(i + s#totcyl) - 1; /* look up the last track */      if (shr(core(i + s#devtyp), 8) and "3") = 1 /* SCSI? */      then bufsize = (bufsize/block_size)*block_size; /* round down to nearest multiple of the block size */      else bufsize = block_size; /* otherwise, it's the Kennedy and we need to read/write in block size chunks */   end; /* of tape drive destination */   if dump.multidisk then do; /* if we're dumping a multidisk file */      total.disks = (blk (f#ll) + (ls.dest.size - 2))/(ls.dest.size - 1); /* number of empty disks needed to save file (assume always dump to floppies, file < 32 MB) */      ms.sectors.left = blk (f#ml); /* MSB of total sectors to copy (multidisk copies only) */      ls.sectors.left = blk (f#ll); /* LSB of total sectors to copy (multidisk dumps only) */      ms.start.sec = blk (f#ms); /* MSB of sector to start from (multidisk dumps only) */      ls.start.sec = blk (f#ls); /* LSB of sector to start from (multidisk dumps only) */      ml = blk (f#ml); ll = blk (f#ll); /* remember info for header */      wd = blk (f#wd); ty = blk (f#ty);   end;   else do; /* we're not dumping a multidisk file - just enter the destination disk loop */      ms.sectors.left = 0;      ls.sectors.left = -1;   end;   /* $page */   do while ((ms.sectors.left <> 0) or (ls.sectors.left <> 0)); /* loop over destination disks */      if locate (nam, dest) then do; /* see if file exists already */         erase_command; pcmd ('"'); pstring (nam); pstring ('" is already saved on '); call name (dest);         crlf; clear_typeahead;         replace.file = get_yn ('Press Y to overwrite this file, or N to skip over it -> ');         if ((not replace.file) and (not dump.multidisk)) then need.to.copy (index) = false;         if ((replace.file) and (blk(f#ty) <> t#dump) and (f#type <> t#dump) and (f#type <> blk(f#ty))) then do; /* not a dump file, and file types don't match */            erase_command; pos (cmdline + 1, 0); erase_line;            pcmd ('File types do not match for "'); pstring (nam); pstring ('".');            crlf; clear_typeahead;            replace.file = get_yn ('Press Y to overwrite this file, or N to skip over it -> ');            if replace.file /* okay to replace the file despite type difference */            then call delete (nam, dest); /* delete it so REPLACE will work later on */            if ((not replace.file) and (not dump.multidisk)) then need.to.copy (index) = false;         end;         erase_command; pos (cmdline + 1, 0); erase_line;      end;      else replace.file = true; /* file not already on destination */      if not dump.multidisk then do; /* are we dumping a multidisk file? */         ms.sectors.left = 0; ls.sectors.left = 0; /* no, make sure we don't loop over destination disks */      end;      if replace.file then do; /* only attempt the write if necessary */         if dump.multidisk then do; /* do we have to split this file up? */            disk.number = disk.number + 1; /* we're copying to the next disk */            blk (f#ms) = ms.start.sec; /* MSB of starting sector of the next segment */            blk (f#ls) = ls.start.sec; /* LSB of starting sector of the next segment */            call lookmax ('', dest); /* find largest free block on destination */            blk (f#ml) = 0; /* set MSB of dump to zero */            if ms.sectors.left = 0 /* if no sectors left MSB [calculate min(sectors.left, dest_remaining)] */            then blk (f#ll) = min (ls.sectors.left, f#ls_length - 1); /* smaller of size and maximum block on dest */            else blk (f#ll) = f#ls_length - 1; /* MSB is there, destination will always be smaller than file length */            blk (f#wd) = shl(blk (f#ll) + 1, 8); /* set proper file length for dump file */            blk (f#ty) = t#dump; /* change the type to dump file */            ms.sectors.left = ms.sectors.left - blk (f#ml); /* keep track of sectors left to copy */            if ls.sectors.left ilt blk (f#ll) then ms.sectors.left = ms.sectors.left - 1; /* borrow */            ls.sectors.left = ls.sectors.left - blk (f#ll);            ms.start.sec = ms.start.sec + blk (f#ml); /* MSB start of next block */            ls.start.sec = ls.start.sec + blk (f#ll); /* LSB start of next block */            if ls.start.sec ilt blk (f#ll) then ms.start.sec = ms.start.sec + 1; /* carry */         end;         if transfer_file (blk, buf, bufsize) then do; /* transfer a file from many sources to one destination */            if dump.multidisk then do; /* we have to write out the dump file header */               do i = 0 to f#name_len; buf (h.name + i) = nam (i); end; /* create the header */               buf (h.ms.sector) = ml; /* MSB of sector length */               buf (h.sector.length) = ll; /* LSB of sector length */               buf (h.file.length) = wd;               buf (h.file.type) = ty;               buf (h.disk.number) = disk.number;               call writedata (f#ms_sector, f#ls_sector, buf, h.len); /* write it out (file variables set by REPLACE) */            end; /* of write out the dump file header */            if ((ls.sectors.left = 0) and (ms.sectors.left = 0)) /* if we're done transferring this file */            then need.to.copy (index) = file.copied; /* then we transferred the file successfully */         end; /* of transfer a file */			if (read_error != 0 || write_error != 0)			{         	erase_command;								if (read_error != 0)				{					pcmd ('Disk Error: The file "'); pstring (nam); pstring ('" could not be read from '); call name (sour);				}								else if (write_error != 0)				{					pcmd ('Disk Error: The file "'); pstring (nam); pstring ('" could not be written to '); call name (dest);				}				         	crlf; clear_typeahead;         					if (get_yn ('Do you wish to continue copying other files -> ') == 0)	/* check for abort desired 	*/					abort.copy = true;								/* quit if so						*/								erase_command;				crlf;				erase_line;				      		if not dump.multidisk then do; pos (0, 56); erase_line; pos (1, 56); erase_line; end;								files_skipped = files_skipped + 1;				/* count skipped files			*/				read_error  = false;									/* acknowledge error here		*/				write_error = false;									/* user has been given a		*/				need.to.copy (index) = false;						/* chance to quit					*/								ms.sectors.left = 0; ls.sectors.left = 0;			}			      end; /* of if replace.file */      if (dump.multidisk and (ms.sectors.left <> 0) or (ls.sectors.left <> 0)) then do; /* get next destination disk if necessary */         call write.out.caches; /* write out the destination cache */         abort.copy = (not get.new.dest); /* get a new disk */         format.success = false; /* assume we can't format the disk */         do while (not (abort.copy or format.success)); /* repeat if the format fails */            format.success = format.destination (buf, bufsize); /* format this disk */            format.success = (format.success or (not formflag)); /* avoid side effects */            if format.success /* can we do the copy? */            then do; /* yes, set up the catalogs */               call setup.caches (false); /* set up the caches */               call erase.destination; /* erase the destination if necessary */            end;            if formflag then do;                call enable_cache (scache);                call print.menu; /* print the source catalog */               call disable_cache (scache);             end;            if not format.success then abort.copy = get.new.dest; /* get a new destination */         end; /* of do while not abort.copy */         if ((not formflag) and (total.disks <> 0)) then do; pos (1, 56); unum (total.disks, 0); erase_line; end; /* GET.NEW.DEST walloped this */         if abort.copy then do; /* get out of here if the user wants to */            ms.sectors.left = 0; ls.sectors.left = 0;         end;      end;   end; /* of loop over destination disks */   if dump.multidisk then do; pos (0, 56); erase_line; pos (1, 56); erase_line; end; /* clean up here for multidisk dump */   call enable_cache (scache); /* remember the source catalog if we already knew it */   return (need.to.copy (index) = file.copied); /* return whether or not we copied the file */end transfer;