/* REBUILD  $TITLE  Disk Catalog Rebuilding Program *//* It seems to be possible for the catalog sector of an old (UNSaved)  catalog to be around while the catalog sectors of true catalogs  are contained within the area previously occupied by said old  catalog.  This causes a terrible dilemma since both LOCATE.SUBCATS  and LOCATE.TEXT.FILES skip over catalogs in their searches (to  eliminate the appearance of files in SUBCATS at the topmost level).  There is a solution, but we haven't the time to fix it now.  If  some of your catalogs are still missing after running this, REMOVE  the code that skips over catalogs in LOCATE.SUBCATS and try again.  But be prepared to see all the catalogs in your subcatalogs appear! */configuration modelC, MULDIV;insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:strings'; /* string processing */dcl debug lit '0';dcl sub_size  lit '1'; /* size of subcatalog */dcl lsub_size lit 'shr(c#dir_max, 8)'; /* size of large subcatalog */dcl buf (256)     fixed; /* one sector buffer */dcl bufptr        fixed; /* ptr into BUF */dcl ms_sector     fixed; /* MS sector from which BUF came */dcl ls_sector     fixed; /* LS sector from which BUF came */dcl ls_start      fixed; /* LS starting sector of catalog (for progress report only) */dcl ms_end        fixed; /* MS ending sector of catalog (plus one) */dcl ls_end        fixed; /* LS ending sector of catalog (plus one) */dcl cur.word      fixed; /* word at BUF (BUFPTR) */dcl more.on.drive boolean; /* false after last sector on disk is read *//* prefix names and counters to use in patched file types */dcl snd.name  data ('SND');dcl lcat.name data ('LCAT');dcl cat.name  data ('CAT');dcl text.name data ('TEXT');dcl (snd.cnt, lcat.cnt, cat.cnt, text.cnt) fixed; /* counts of files patched so far */when break then call exit (-1); /* get out */nextsec: proc; /* loads global BUF with next sector */   ls_sector = ls_sector + 1;  /* increment current sec number */   if ls_sector = 0 then ms_sector = ms_sector + 1;   if ((ms_sector ILT ms_end) /* if more information on disk */   or ((ms_sector = ms_end) and (ls_sector ILT ls_end))) then do;      if (ls_sector - ls_start and "377") = 0 then print ls_sector - ls_start, character("15"),;      call readdata (ms_sector, ls_sector, buf, 256);  /* ######use WHENDISK?######read the current sector   */      bufptr   = 0;            /* reset global ptr          */      cur.word = buf (bufptr);  /* set CUR.WORD to first word of sector */      more.on.drive = true;    /* not end of disk           */   end;   else more.on.drive = false; /* have read last sector on disk */end nextsec;nextword: proc; /* sets CUR.WORD to next word on disk */   bufptr = bufptr + 1; /* incr buf ptr */   if bufptr >= 256 /* time to read in next sector */   then call nextsec;   else cur.word = buf (bufptr);end nextword;valid.fcb: proc(fcb) boolean; /* returns true if FCB could be a valid -7 FCB */   dcl fcb      fixed array; /* FCB to test */   dcl name     (f#name_len) fixed;   dcl uname    (f#name_len) fixed;   dcl valid    boolean;   dcl all_zero boolean;   dcl (i, j)   fixed;   valid = true; /* assume FCB could be valid */   all_zero = true; /* assume all zero */   do i = 0 to f#len - 1; /* see if any information */      if fcb (i) <> 0 then all_zero = false;   end;   if not all_zero then do; /* if it isn't all zero, check it out */      if fcb (f#nm) <> 0 then do; /* if there's a name */         call clean_fcbname (fcb, name); /* convert name to XPL string format */         valid = valid_filename (name); /* see if filename is okay (fails if FCB name had nulls in middle because string length is number of non-nulls) */         if strcmp (name, loc(upper (loc(strcpy (uname, name))))) <> 0 then valid = false; /* must be all uppercase */         /* sector length and word length must agree if there's a name */         if shr(fcb (f#wd) + 255, 8) > (fcb (f#ll) and "377") then valid = false;      end; /* of if there's a name */      else do i = f#nm to f#nm + f#name_len - 1; /* no name, make sure it's all zeroes */         if fcb (i) <> 0 then valid = false;      end; /* of no name */      /* starting sector must be on disk */      i = ms_sector + fcb (f#ms); /* compute absolute starting sector of file */      j = ls_sector + fcb (f#ls);      if j ILT ls_sector then i = i + 1;      if ((i IGT ms_end) /* starting sector must be on disk */      or ((i = ms_end) and (j IGE ls_end)))      then valid = false;      /* number of sectors must not run off disk */      i = i + fcb (f#ml); /* compute absolute ending sector of file */      j = j + fcb (f#ll);      if j ILT fcb (f#ll) then i = i + 1;      if ((i IGT ms_end) /* ending sector must not exceed size */      or ((i = ms_end) and (j IGT ls_end)))      then valid = false;      /* file type must be less than maximum type */      if fcb (f#ty) IGT t#max then valid = false;      if debug then do;         if valid and (fcb (f#nm) <> 0) then do;            print '****** Valid File **********';            print string(name);            print 'Origin:  ', octal(fcb (f#ms)), ' ', octal(fcb (f#ls));            print 'Sectors: ', octal(fcb (f#ml)), ' ', octal(fcb (f#ll));            print 'Words:   ', octal(fcb (f#wd)), '  Type: ', octal(fcb (f#ty));            print '****************************       ',;            print 'Press RETURN to continue ->',; input i;         end;         else if not valid then do;            print 'Bad FCB: ',;            do i = 0 to f#len - 1; print octal(fcb (i)), ' ',; end;            print;         end;      end;   end; /* of not all zero */   return (valid);end valid.fcb;clean.cat: proc(treename) returns (fixed); /* zeroes out invalid FCBs in catalog TREENAME on CC */   dcl treename        fixed array; /* catalog to clean */   dcl fcb (f#len - 1) fixed; /* FCB */   dcl (i, j, k)       fixed;   call read_catalog (treename, 1); /* get the catalog */   k = 0; /* no invalid FCBs found yet */   do i = 0 to c#dir_size/c#len - 1; /* loop over FCBs */      call get_fcb (i, fcb); /* get next FCB */      if not valid.fcb (fcb) then do; /* bad FCB */         do j = 0 to f#len - 1; fcb (j) = 0; end; /* zero out bad FCB */         call put_fcb (i, fcb); /* write it out again */         k = k + 1; /* count number of invalid FCBs */      end;   end; /* of loop over FCBs */   call write_catalog; /* write it back out */   return (k); /* return number of invalid FCBs found */end clean.cat;append.num: proc(str, num, maxlen); /* puts number on end of string */   dcl str        fixed array;   dcl num        fixed;   dcl maxlen     fixed;   dcl divisors   data (-10000, -1000, -100, -10, -1);   dcl (go, i, chr) fixed;   if num < 0 then do;      if str (0) ILT maxlen then do;         call pbyte(str, str (0), "55");         str (0) = str (0) + 1;      end;   end;   else num = -num;   go = false;   do i = 0 to 4;      chr = num/divisors (i);      if chr <> 0 then go = true;      if (go or (i = 4)) and (str (0) ILT maxlen) then do;         call pbyte(str, str (0), "60" + chr);         str (0) = str (0) + 1;      end;      num = num - (divisors (i)*chr);   end;end append.num;origin.unique: proc(ms_start, ls_start) returns (fixed); /* returns TRUE if origin not in catalog */   dcl ms_start        fixed; /* origin to check for uniqueness */   dcl ls_start        fixed;   dcl fcb (f#len - 1) fixed; /* FCB */   dcl i               fixed;   ms_start = ms_start - c#ms_sector; /* normalize starting sector to start of catalog */   if ls_start ILT c#ls_sector then ms_start = ms_start - 1;   ls_start = ls_start - c#ls_sector;   do i = 0 to c#dir_size/c#len - 1; /* loop over FCBs */      call get_fcb (i, fcb); /* get next FCB */      if ((fcb (f#ms) = ms_start) and (fcb (f#ls) = ls_start)) /* if not unique */      then return (i);   end; /* of loop over FCBs */   return (-1); /* it's unique */end origin.unique;new.cat.entry:  proc(level, ms_start, ls_start, ms_secs, ls_secs, words, type) boolean; /* patches entry into catalog */   dcl level    fixed; /* level number of catalog to add entry to */   dcl ms_start fixed; /* start sector of file to patch */   dcl ls_start fixed;   dcl ms_secs  fixed; /* sector length of file to patch */   dcl ls_secs  fixed;   dcl words    fixed; /* length in words of file */   dcl type     fixed; /* file type */   dcl name     (f#name_len) fixed; /* constructed name of file */   dcl fcb      (f#len - 1)  fixed; /* FCB */   dcl success  boolean;   dcl ptr      fixed;   dcl i        fixed;   success = true; /* assume catalog patch will be successful */   call read_catalog ('', level); /* make sure we have the right catalog */   ms_start = ms_start - c#ms_sector; /* normalize starting sector to start of catalog */   if ls_start ILT c#ls_sector then ms_start = ms_start - 1;   ls_start = ls_start - c#ls_sector;   i = c#dir_size/c#len - 1; /* get number of FCBs less one */   ptr = -1; fcb (f#nm) = -1;   do while ((ptr < i) and (fcb (f#nm) <> 0)); /* find a free block */      ptr = ptr + 1;      call get_fcb (ptr, fcb); /* get next FCB */   end; /* of looking for a free block */      if ((fcb (f#nm) = 0) and (origin.unique (ms_start, ls_start) = -1)) then do; /* entry not already in cat */      /* set up a name for patched file */      if type = t#lsubc then do;         lcat.cnt = lcat.cnt + 1;         call strcpy (name, lcat.name); /* get prefix */         call append.num (name, lcat.cnt, shl(f#name_len, 1));      end;      else if type = t#subc then do;         cat.cnt = cat.cnt + 1;         call strcpy (name, cat.name); /* get prefix */         call append.num (name, cat.cnt, shl(f#name_len, 1));      end;      else if type = t#text then do;         text.cnt = text.cnt + 1;         call strcpy (name, text.name); /* get prefix */         call append.num (name, text.cnt, shl(f#name_len, 1));      end;      else if type = t#sound then do;         snd.cnt = snd.cnt + 1;         call strcpy (name, snd.name); /* get prefix */         call append.num (name, snd.cnt, shl(f#name_len, 1));      end;      print 'Patching new FCB: ',;      call clean_filename (name, fcb); /* move to FCB */      fcb (f#ms) = ms_start;      fcb (f#ls) = ls_start;      fcb (f#ll) = ms_secs;      fcb (f#ll) = ls_secs;      fcb (f#wd) = words;      fcb (f#ty) = type;      call put_fcb (ptr, fcb); /* write it out */      call write_catalog; /* write patched catalog to cache */      call clean_fcbname (fcb, name); /* space pad name */      name (0) = shl(f#name_len, 1); /* use the spaces */      print string (name), ' ', octal(fcb (f#ms)), ' ', octal(fcb (f#ls)),;      print ' ', octal(fcb (f#ml)), ' ', octal(fcb (f#ll)),;      print ' ', octal(fcb (f#wd)), ' ', octal(fcb (f#ty));   end; /* of entry not already in catalog */   else do; /* no free FCBs (or entry already in catalog) */      success = false; print '**** Patch Unsuccessful'; /* no free FCBs in cat */   end;   return (success);end new.cat.entry;locate.subcats: proc(level); /* patch subcatalogs into CATBUF */   dcl level           fixed; /* catalog to patch into */   dcl fcb (f#len - 1) fixed; /* FCB */   dcl ms_length       fixed; /* length of catalog */   dcl ls_length       fixed;   dcl have.cat        boolean;   dcl have.large.cat  boolean;   dcl nonzero.fcb     boolean;   dcl (i, j, k)       fixed;   lcat.cnt = 0; cat.cnt = 0; /* initialize */   call read_catalog ('', level); /* read in catalog to patch */   ms_sector = c#ms_sector; /* start with first sector past main catalog */   ls_sector = c#ls_sector + shr(c#dir_size, 8);   if ls_sector ILT c#ls_sector then ms_sector = ms_sector + 1;   ls_start = ls_sector - 1; /* save start */   do while ((ms_sector ILT ms_end) /* read through looking for subcats */         or ((ms_sector = ms_end) and (ls_sector ILT ls_end)));      if (ls_sector - ls_start and "377") = 0 then print ls_sector - ls_start, character("15"),;      have.large.cat = false; /* no large cat */      have.cat = readcat (ms_sector, ls_sector, shl(sub_size, 8), 0, sub_size); /* see if CATRTNS thinks we have a small catalog */      i = 0; j = c#dir_size/c#len; nonzero.fcb = false;      do while ((i < j) and have.cat); /* loop over FCBs */         call get_fcb (i, fcb); /* get next FCB */         if not valid.fcb (fcb) then have.cat = false; /* if invalid FCB, no catalog */         else if fcb (f#nm) <> 0 then nonzero.fcb = true; /* see if we get non-zero FCBs */         i = i + 1;      end;      if have.cat and nonzero.fcb then do; /* have at least a small cat - check for large cat */         if ls_sector + lsub_size - 1 ILT lsub_size - 1 then i = 1; else i = 0; /* check for carry */         if ((ms_sector + i ILT ms_end) /* it not at end of disk */         or ((ms_sector + i = ms_end) and (ls_sector + lsub_size - 1 ILT ls_end)))         then have.large.cat = readcat (ms_sector, ls_sector, shl(lsub_size, 8), 0, lsub_size); /* see if CATRTNS thinks it's a catalog */         i = j; j = c#dir_size/c#len; /* pick up at end of small cat */         do while ((i < j) and have.large.cat); /* loop over FCBs */            call get_fcb (i, fcb); /* get next FCB */            if not valid.fcb (fcb) then have.large.cat = false; /* if invalid FCB, no catalog */            i = i + 1;         end;         /* compute size of subcat */         if not have.large.cat then c#dir_size = shl(sub_size, 8); /* get small catalog back */         ms_length = 0; /* initialize catalog length */         ls_length = shr(c#dir_size, 8);         do i = 0 to c#dir_size/c#len - 1; /* loop over entries to compute size */            call get_fcb (i, fcb); /* get next FCB */            j = fcb (f#ms) + fcb (f#ml); /* point to end of block */            k = fcb (f#ls) + fcb (f#ll);            if k ILT fcb (f#ls) then j = j + 1;            if ((j IGT ms_length) /* if this block points past current known length */            or ((j = ms_length) and (k IGT ls_length))) then do;               ms_length = j; ls_length = k; /* save new length */            end;         end; /* of loop over entries to compute size */         if ((ms_length <> 0) or (ls_length IGT shr(c#dir_size, 8))) then do; /* have a non-empty cat */            k = t#subc;            if have.large.cat then k = t#lsubc;            if not new.cat.entry (level, ms_sector, ls_sector, ms_length, ls_length, shl(ls_length, 8), k) then return; /* update the catalog */         end; /* of have a non-empty catalog */         ms_sector = ms_sector + ms_length; /* jump over subcatalog */         ls_sector = ls_sector + ls_length;         if ls_sector ILT ls_length then ms_sector = ms_sector + 1;      end; /* of have a cat, patch FCB into cat buf */      else do; /* no cat - look at next sector */         ls_sector = ls_sector + 1; /* look at next sector */         if ls_sector = 0 then ms_sector = ms_sector + 1;      end; /* of look at next sector */   end; /* of read through looking for subcats */end locate.subcats;compare.times: proc(time1, time2) returns (fixed); /* -1 if time1 < time2, 0 if equal, +1 if time1 > time2 */   dcl (time1, time2) fixed array;   dcl relation       fixed; /* -1 -> (time1 < time2), 0 -> (time1 = time2), +1 -> (time1 > time2) */   dcl i              fixed;   relation = 0; /* assume times are equal */   do i = 0 to 2;      if      time1 (i) IGT time2 (i) then relation = +1;      else if time1 (i) ILT time2 (i) then relation = -1;   end;   return (relation);end compare.times;locate.sound.files: proc(level); /* patches sound files back into catalog */   dcl level      fixed; /* catalog to patch into */   dcl have.snd   boolean;   dcl snd.length fixed;   dcl (i, j)     fixed;   snd.cnt = 0; /* initialize */   call read_catalog ('', level); /* read in catalog to patch */   ms_sector = c#ms_sector; /* start with first sector past main catalog */   ls_sector = c#ls_sector + shr(c#dir_size, 8);   if ls_sector ILT c#ls_sector then ms_sector = ms_sector + 1;   if ls_sector = 0 then ms_sector = ms_sector - 1; /* back up for NEXTSEC */   ls_sector = ls_sector - 1;   ls_start = ls_sector; /* save start */   call nextsec; /* get first sector */   do while (more.on.drive); /* read through looking for subcats */      have.snd = true;      if (buf ( 0) IGT 4)   /* compatability number must be 4 or less */      or (buf ( 4) IGT 255)      or (buf ( 8) IGT 255)      or (buf (21) ILT 600) or (buf (21) IGT 4095) then have.snd = false;      if (compare.times (location(addr(buf ( 9))), location(addr(buf (23)))) < 0)      or (compare.times (location(addr(buf ( 9))), location(addr(buf (26)))) < 0)      or (compare.times (location(addr(buf ( 9))), location(addr(buf (29)))) < 0)      or (compare.times (location(addr(buf (26))), location(addr(buf (23)))) < 0)      then have.snd = false;      if buf (127) IGT 128 then have.snd = false;      if have.snd then do i = 0 to buf (127) - 1;         j = byte(location(addr(buf (127))), i);         if (j IGE "177") or (j ILT "40") then have.snd = false;      end;      if have.snd then do; /* have a sound file */         snd.length = buf (3) + shr(buf (4) + 255, 8) + 3; /* compute length of sound file */         if not new.cat.entry (level, ms_sector, ls_sector, 0, snd.length, shl(buf (3), 8) + buf (4), t#sound) then return;      end;      /* don't jump over sound file since there is a good possibility         that lots of old sound files will be sitting around on the         disk.  Patch them all in and then resolve conflicts later */      call nextsec; /* get next sector */   end; /* of read through looking for subcats */end locate.sound.files;locate.text.files: proc(level); /* patches text files back into CATBUF */   dcl level           fixed; /* catalog to patch into */   dcl fcb (f#len - 1) fixed; /* FCB */   dcl have.text       boolean;   dcl text_ms_start   fixed;   dcl text_ls_start   fixed;   dcl text_length     fixed;   dcl last_ms_sec     fixed;   dcl last_ls_sec     fixed;   dcl last            fixed;   dcl desequenced     boolean;   dcl i               fixed;   text.cnt = 0; /* initialize */   call read_catalog ('', level); /* read in catalog to patch */   ms_sector = c#ms_sector; /* start with first sector past main catalog */   ls_sector = c#ls_sector + shr(c#dir_size, 8);   if ls_sector ILT c#ls_sector then ms_sector = ms_sector + 1;   if ls_sector = 0 then ms_sector = ms_sector - 1; /* back up for NEXTSEC */   ls_sector = ls_sector - 1;   ls_start = ls_sector; /* save start */   call nextsec; /* get first sector */   do while (more.on.drive); /* read through looking for text files */      i = origin.unique (ms_sector, ls_sector); /* see if this address already in catalog */      if i <> -1 then do; /* if something already lives here */         call get_fcb (i, fcb); /* get that FCB */         ms_sector = ms_sector + fcb (f#ml); /* skip over it */         ls_sector = ls_sector + fcb (f#ll);         if ls_sector ILT fcb (f#ll) then ms_sector = ms_sector + 1;         if ls_sector = 0 then ms_sector = ms_sector - 1;         ls_sector = ls_sector - 1;      end; /* of something already lives here */      else if (cur.word and "177400") = 0 then do; /* search for good line number (assumes 1st line # < 256 to avoid file segements) */         have.text = true;         text_ms_start = ms_sector;         text_ls_start = ls_sector;         last_ms_sec = ms_sector;         last_ls_sec = ls_sector;         last = cur.word - 1; /* start line number */                  if cur.word = 0 /* is the first line number zero? */         then desequenced = true; /* yes, assume desequenced */         else desequenced = false;         do while (more.on.drive and have.text and ((cur.word IGT last) or (desequenced and (cur.word = 0)))); /* while line numbers ascend */            last = cur.word; /* remember new line number */            call nextword; /* skip line number */            do while (more.on.drive and ((cur.word and "177400") <> 0) and have.text); /* search for end of line */               if ((cur.word and "100200") <> 0) or ((cur.word and "140") = 0) or ((shr(cur.word, 8) and "140") = 0) /* disallow parity and controls */               then have.text = false;               else call nextword; /* get next word */            end; /* of search for end of line */            if ((cur.word and "177400") = 0) and (cur.word <> 0) /* ends with a null byte? */            then if ((cur.word and "200") <> 0) or ((cur.word and "140") = 0) then have.text = false; /* check last byte */            if ((ms_sector <> last_ms_sec) or (ls_sector <> last_ls_sec)) then do; /* just changed sectors - look for overlapping files */               i = origin.unique (ms_sector, ls_sector); /* look for this one */               if i <> -1 then do; /* if something already lives here */                  call get_fcb (i, fcb); /* get that FCB */                  ms_sector = ms_sector + fcb (f#ml); /* skip over it */                  ls_sector = ls_sector + fcb (f#ll);                  if ls_sector ILT fcb (f#ll) then ms_sector = ms_sector + 1;                  if ls_sector = 0 then ms_sector = ms_sector - 1;                  ls_sector = ls_sector - 1;                  have.text = false; /* if we overlap with something already there, we only have a scrap of a text file */               end; /* of something already lives here */               last_ms_sec = ms_sector; /* remember sector we're on */               last_ls_sec = ls_sector;            end; /* of just changed sectors */            text_length = ls_sector - text_ls_start + 1; /* set length in case done (must be < 65536 sectors) */            call nextword; /* get new line number */         end; /* of while line numbers ascend */         if cur.word <> 0 then have.text = false;         do i = bufptr to 255; /* finish off the sector */            if buf (i) <> 0 then have.text = false;         end;         if have.text and ((text_length igt 1) or (bufptr igt 8))         then if not new.cat.entry (level, text_ms_start, text_ls_start, 0, text_length, shl(text_length - 1, 8) + bufptr, t#text) then return;      end; /* of good starting line number */      call nextsec; /* get next sector */   end; /* of read through looking for text files */end locate.text.files;/* $SUBTITLE  Main Driver for Disk Patch Program */dcl catbuf   (c#dir_max - 1) fixed; /* catalog buffer */dcl cachebuf (c#dir_max - 1) fixed; /* cache for main catalog */dcl fcb (f#len - 1)          fixed; /* FCB */dcl treename (64)            fixed; /* treename of catalog to rebuild */dcl name (f#name_len)        fixed; /* filename */dcl main_cache               fixed; /* cache number of main catalog's cache */dcl i                        fixed;print 'Name of directory to rebuild? ',;linput treename; /* get name */treename (0) = treename (0) - 1;call set_catbuf (addr(catbuf (0)), 0); /* set up catalog buffer */call read_catalog (treename, 1); /* try to read in the catalog (at least set catalog vars)####WHENDISK??######*/if ((c#status = e#none) or (c#status = e#invalid)) then do; /* we have the size */   ms_end = c#ms_sector + c#ms_length; /* save the last sector (plus one) */   ls_end = c#ls_sector + c#ls_length;   if ls_end ILT c#ls_sector then ms_end = ms_end + 1;end; /* of we have the size */else do; /* can't get the size */   print;   if ((c#status = e#no_file) or (c#status = e#no_path) /* not there */   or (c#status = e#not_cat) or (c#status = e#treename)) /* bad name */   then print 'Catalog "', string(treename), '" not found.';   else print '### Fatal system error - unable to read directory:', c#status;   call exit (-1);end;main_cache = cache (addr(cachebuf (0)), 0); /* cache this catalog away */print;print 'Cleaning up Main Catalog';print '   Invalid FCBs zeroed out was: ', clean.cat (treename);print;if not enter_alternate (treename, 1) then do; /* move to the alternate catalog to save TREENAME parsing */   print '### Fatal system error - unable to enter alternate:', c#status;   call exit (-1);end;print 'Looking for Subcatalogs';call locate.subcats (-1);print;print 'Looking for Text Files';call locate.text.files (-1);print;print 'Looking for Sound Files';call locate.sound.files (-1);print;print 'Press RETURN to see patched catalog ->',; input i; print;print 'Filename     Origin        Sectors    Words  Type';print '--------  ------------- ------------- ------ ------';do i = 0 to c#dir_size/c#len - 1; /* dump patched cat to screen */   call get_fcb (i, fcb); /* get next FCB */   call clean_fcbname (fcb, name); /* clean up the name */   name (0) = shl(f#name_len, 1); /* use the spaces */   print string (name), ' ', octal(fcb (f#ms)), ' ', octal(fcb (f#ls)),;   print ' ', octal(fcb (f#ml)), ' ', octal(fcb (f#ll)),;   print ' ', octal(fcb (f#wd)), ' ', octal(fcb (f#ty));end;print;print 'Enter 123 to rewrite catalog "', string(treename), '", 0 to quit',; input i;if i = 123 then call flush_cache (main_cache); /* write patched catalog to Winchester */