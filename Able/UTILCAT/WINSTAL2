/* WINSTAL2  $title Additional procedures for WINSTALL *//*.  This file contains procedures that are inserted in the Winchester.  Installation Program (WINSTALL).*/setup_cache: proc (level); /* set up cached catalog */   dcl level fixed; /* level to set up cached catalog for */   dcache = -1; /* get rid of old cache just in case */   call trigger_motor (level); /* get motor going */   call read_catalog ('', level); /* read the specified catalog */   dcache = cache (addr(cache1 (0)), 0); /* cache the catalog */end setup_cache;write_out_cache: proc (level); /* write cached catalog to disk */   dcl level fixed; /* cached level */   call trigger_motor (level); /* get motor going */   call flush_cache (dcache); /* write the cache */end write_out_cache;set_graphics: proc; /* get graphics type for terminal */   dcl timeout   lit 'shl(d03_speed, 6)'; /* timeout for reading status from terminal (currently 640 ms) */   dcl terminal  fixed; /* set to suspected terminal type */   dcl (i, j, k) fixed;   vector_mode; /* get into vector mode */   write(d03) = 0; write(d03) = 0; 		/* get in sync with D3 clock */   clear_typeahead; 					/* clear terminal input */   wchar(a.esc); wchar(a.enq); 			/* request VT640 status */   terminal = t#vt100; /* assume no graphics */   i = 0; j = 0;   do while (i < timeout); /* get all characters sent in next TIMEOUT */      if read(d03) then do; /* clock tick */         i = i + 1;         write(d03) = 0; /* clear clock */      end;      ckread; /* check for any terminal input pending */      if not term_idle_wait then do; /* if we got a character from terminal */         k = rchar; /* get char */         if j = 0 then do; /* look at the first character */            if ((k and "30") = "30") 		/* bits 4 and 3 set indicate the Macintosh */            then terminal = t#macintosh; 	/* set terminal type to Macintosh */            else do;               if (k and "10") <> 0 		/* bit 3 is set by the MG600 */               then terminal = t#mg600; 	/* set terminal type to MG600 */               else terminal = t#vt640; 	/* otherwise, assume VT640 (or DQ640) */            end;         end;         j = j + 1; /* count chars received */      end; /* of get next character from terminal */   end; /* of get all characters sent in next TIMEOUT */   transparent_mode; /* out of vector mode */   terminal_info = shl(terminal, 8); /* set config to terminal type (but don't wipe out DQ640 in config if we think it's a VT640) */end set_graphics;/* $subtitle Winchester Configuration */get_win_config: proc (win.config, polled.wins); /* poll system to get Winchester configuration */   dcl win.config     fixed array; /* winchester configuration to write out */   dcl polled.wins    fixed array; /* buffer for polling drives */   dcl drive_address  fixed; /* address for first SCSI W0 drive (0,5,0) */   dcl target         fixed; /* SCSI target to look for (5-2) */   dcl found          boolean; /* true if first SCSI W0 Winchester found */   dcl SCSI_win_there boolean; /* true if a Winchester exists on the SCSI chain */   dcl in_sequence    boolean; /* true as long as the W0 drives are in order */   dcl (i, j, p)      fixed;   IMI_prompt: proc returns (boolean); /* print instructions and get response for installing on IMI drive */      print;      print 'If you have an IMI Winchester in your computer that is set up';      print 'to be W0, this program can install ', string (rel.version), ' on your IMI Winchester.';      print 'This IMI Winchester must be connected to D107 board zero (0).';      print;      if not ask ('Do you want to install on an IMI drive [Y(es) or N(o)]? ') then do;         print;         print string (rel.version), ' has not been installed on your system.';         core(loc.magic) = 0; stop; /* there is nowhere to install */      end;      else return (true); /* they do want to install on an IMI drive */   end IMI_prompt;      get_IMI_config: proc (win.config, polled.wins) returns (boolean); /* poll the IMI drives on system */      dcl win.config    fixed array; /* winchester configuration to write out */      dcl polled.wins   fixed array; /* buffer for polling drives */      dcl (i, j)        fixed;      call poll_winchesters (polled.wins, poll.len); /* see what IMI winchesters we have (one extra block so we exit) */      i = 0;      do while (polled.wins (i) <> s#freblk); /* loop over IMI winchesters */         if (polled.wins (i + s#devadr) and "17") = 0 then do; /* we have an IMI on controller 0 */            do j = 1 to s#blklen; /* save W0's configuration */               win.config (win.config (0) + j) = polled.wins (i + j - 1);            end;            win.config (0) = win.config (0) + s#blklen; /* look at next Winchester */         end;         i = i + s#blklen; /* look at next block in polled data */      end; /* of looping over Winchesters */      if win.config (0) = 0 then do; /* no Winchesters in system? */         if i = 0 then do; /* no drives at all? */            /* Note that for this case, POLL_WINCHESTERS will have died by               now if there is no D107 in the computer or if the drive has               no power but is still connected to the D107. */            print;            print 'There is a D107 board in your computer, but there are no IMI Winchesters';            print 'connected to it.';         end;         else do; /* there are drives, just no W0 */            print;            print 'This program only installs software on W0 (Winchester disk).';            print 'There are IMI Winchester disks in your system, but they are not';            print 'configured to be W0.  In order for an IMI drive to be W0, it must be';            print 'connected to D107 board zero (0).';         end;         print;         print string (rel.version), ' has not been installed on your system.';         core(loc.magic) = 0; stop; /* get out */      end;      else return (true); /* got a W0 SCSI Winchester disk */   end get_IMI_config;/* $page */   assign_config: proc (win.config); /* write the Winchester config to low memory storage device table */      dcl win.config fixed array; /* winchester configuration to write out */      dcl p          pointer; /* pointer into configuration table */      dcl (i, j)     fixed;      if find_device (6) = 0 then do; /* if no Winchester configured (let's HOPE not!) */         p = c#contab + c#strdev; /* point to the start of the device table */         do while ((p < c#contab + c#strend) and (core(p) <> s#freblk)); /* look for a free device table entry */            p = p + s#blklen; /* point to next block */         end;         i = 1;         do while ((p < c#contab + c#strend) and (i < win.config (0))); /* don't configure it unless we find an empty block */            do j = 0 to s#blklen - 1; /* assign the configuration */               core(p + j) = win.config (i + j); /* polling routines set type to W0 and create configuration records */            end; /* of assigning configuration */            p = p + s#blklen; i = i + s#blklen;         end;      end; /* of assigning winchester config */   end assign_config;   p = 0; win.config (0) = 0; /* initialize these */   /* POLL_SCSI returns the SCSI Winchester disks found on the system in      configuration table format, arranged in ascending D24, target, LUN      order.  So this SCSI loop finds (0,5,0), which should be last      in the list for W0 drives, and then works backwards to find      the other W0 drives. */   if (read("51") and scsiboard) <> 0 then do; /* we have SCSI Winchesters */      call poll_scsi (polled.wins, poll.len); /* see what SCSI winchesters we have (one extra block so we exit) */      i = 0; found = false;      SCSI_win_there = false; /* assume we have no Winchesters until we find one */      drive_address = shl(0, 8) or shl(0, 4) or 5; /* address of W0 is LUN 0, D24 0, SCSI target 5 */      do while ((polled.wins (i) <> s#freblk) and (not found)); /* look for first drive (0,5,0) */         if (polled.wins (i + s#devtyp) and "17") = 1 then SCSI_win_there = true; /* yes, we have a SCSI Winchester somewhere in the system */         if (polled.wins (i + s#devadr) = drive_address) then found = true; /* found the first drive */         else i = i + s#blklen; /* go on to next entry */      end;      /* $page */      if found then do; /* if the first drive was found, look for others */         print;         print string (rel.version), ' will be installed on your SCSI Winchester disk.';         if not ask ('Is this okay [Y(es) or N(o)]? ') then do; /* they do not want to install on SCSI */            print;            print 'You do NOT want this release to be installed on your SCSI Winchester.';                        if IMI_prompt then do; /* they want software on their IMI drive */               if get_IMI_config (win.config, polled.wins) /* poll the IMI drives */               then call assign_config (win.config); /* got a W0, so save config in memory */            end;         end;         else do; /* they want it on SCSI, so find the rest of the W0 SCSI drives */            target = 5; /* just looking at SCSI target now */            in_sequence = true; /* so far we are in order */            do while ((i >= 0) and (target >= 5) and (in_sequence)); /* go through all Winchesters that have this target */               in_sequence = false; /* assume we will not find next in sequence until we do find it */               do while ((polled.wins (i + s#devadr) and "17") = target); /* while we still have drives with this target number */                  if (polled.wins (i + s#devadr) and "7760") = 0 then do; /* D24 and LUN are zero - it's W0 */                     in_sequence = true; /* found the next one in sequence */                     do j = 1 to s#blklen; /* save that drive in configuration */                        win.config (win.config (0) + j) = polled.wins (i + j - 1);                     end;                     win.config (0) = win.config (0) + s#blklen; /* increase pointer into config array */                  end;                  i = i - s#blklen; /* decrease pointer into polled drives */               end;               target = target - 1; /* go on to next target */            end;            call assign_config (win.config); /* save configuration in memory */         end; /* of finding the rest of the W0 SCSI drives */      end; /* if first drive was found */      else do; /* found a D24 in system, but no W0 Winchester disk */         if SCSI_win_there then do; /* there is a Winchester, it's just not W0 */            print;            print 'This program only installs software on W0 (Winchester disk).';            print 'There are SCSI Winchesters in your system, but they are not configured to be W0.';            print' In order for a SCSI drive to be W0, it must be connected to';            print' D24 board zero (0) and have a SCSI target ID of five (5).';         end;         else do; /* no Winchester disk exists on the SCSI chain */            print;            print 'There are no SCSI Winchesters in your system.';         end;         if IMI_prompt then do; /* they want software on their IMI drive */            if get_IMI_config (win.config, polled.wins) /* poll the IMI drives */            then call assign_config (win.config); /* got a W0, so save config in memory */         end;      end;   end;   else do; /* IMI winchesters are system device */      if get_IMI_config (win.config, polled.wins) then do; /* poll the IMI drives */         print;         print string (rel.version), ' will be installed on your IMI Winchester disk.';         if ask ('Is this okay [Y(es) or N(o)]? ') /* if they want to install IMI drive */         then call assign_config (win.config); /* save config in memory */         else do; /* cannot install system */            print; print string (rel.version), ' has not been installed on your system.';            core(loc.magic) = 0; stop; /* get out */         end;      end;   end; /* else if IMI is system device */end get_win_config;/* $subtitle Storage Device Table Handling */dcl first_imi   lit '2'; /* index of first IMI-type winchester entry */dcl type_to_IMI data (7, 0, 5, 7, 8, 1, 2, 4); /* maps winchester type into WIN_SIZ and WIN_CYL indexes */winchester_type: proc (win, p) returns (fixed); /* determine the type of Winchester configured */   dcl win   fixed array; /* storage table for all Winchesters in system */   dcl p     fixed; /* pointer to storage table entry for said Winchester */   dcl found boolean; /* TRUE if IMI type found */   dcl i     fixed;   if (shr(win (p + s#devtyp), 8) and "17") = 1 then do; /* SCSI drive */      return (1); /* SCSI drive type */   end;   else do;      i = first_imi; found = false; /* not found yet */      do while ((i <= type_to_IMI (0)) and (not found)); /* search for IMI type */         if  (win (p + s#totcyl) = win_siz (type_to_IMI (i))) /* same total cylinders */         and (win (p + s#seccyl) = win_cyl (type_to_IMI (i))) /* same sectors/cylinder */         then found = true; /* found this IMI type */         else i = i + 1; /* not found, so check next type */      end;      if not found then i = 0; /* unknown Winchester */      return (i); /* return type */   end;end winchester_type;st_find: proc (block, config, len) returns (fixed); /* find a matching storage BLOCK in CONFIG (currently only works for Winchesters) */   dcl block  fixed array; /* storage block we're looking for */   dcl config fixed array; /* storage table we're searching */   dcl len    fixed; /* length to search */   dcl found  boolean; /* TRUE when we find it */   dcl p      fixed; /* pointer into storage table */   p = 0; found = false; /* start at the very beginning */   do while ((p < len) and (config (p) <> s#freblk) and (not found)); /* search the table till we find it */      if ((config (p + s#devadr) = block (s#devadr)) /* check device addresses */      and (winchester_type (config, p) = winchester_type (block, 0))) /* make sure everything else matches */      then found = true; /* we found it */      else p = p + s#blklen; /* keep looking */   end; /* of searching table */   if found /* did we find it? */   then return (p); /* yes, return the pointer */   else return (-1); /* no, return invalid pointer */end st_find;st_insert: proc (block, p, config, len) returns (boolean); /* insert BLOCK at location P of CONFIG */   dcl block  fixed array; /* storage block we're inserting */   dcl p      fixed; /* pointer to where to insert in storage table */   dcl config fixed array; /* storage table we're inserting into */   dcl len    fixed; /* length of storage table */   if config (len - s#blklen) = s#freblk then do; /* if there's a free entry */      call blockmove (loc(addr(config (p))), loc(addr(config (p + s#blklen))), len - p - s#blklen); /* push data above us up */      call blockmove (block, loc(addr(config (p))), s#blklen); /* and copy the block into its place */      return (true); /* we successfully inserted it */   end;   return (false); /* no room to insert it */end st_insert;st_delete: proc (p, config, len); /* delete the block pointed to by P in CONFIG */   dcl p      fixed; /* pointer to block to delete */   dcl config fixed array; /* storage table we're deleting from */   dcl len    fixed; /* length of storage table */   call blockmove (loc(addr(config (p + s#blklen))), loc(addr(config (p))), len - p - s#blklen); /* delete the block */   call blockset (loc(addr(config (len - s#blklen))), s#blklen, s#freblk); /* put free block at end */end st_delete;/* $subtitle Test Valid Configuration and Standard SCSI Configuration */valid_config: proc (buf) returns (boolean); /* checks the old MONITOR configuration */   dcl buf fixed array; /* first sector of the old MONITOR */   if buf (0) <> "100377"          then return (false); /* valid XPL program */   if buf (1) IGT (256 - c#conlen) then return (false); /* fits in first sector */   if buf (1) = "64"               then return (false); /* not a pre -6 program (### temporary ###) */   if ((buf (buf (1) + 14)) and (buf (buf (1) + 15))) <> 0 then return (false); /* check reserveds */   if buf (buf (1) + 22) <> 0                              then return (false);   if buf (buf (1) + c#memsiz) IGT 256                     then return (false); /* memory size is restricted to 64K */   if (buf (buf (1) + c#cmopt) and "014200") <> 0          then return (false); /* reserved option bits */   if (buf (buf (1) + c#redrct)) <> 0                      then return (false); /* redirection can't be set */   if buf (buf (1) + c#version) > c#current_version        then return (false); /* check version */   return (true); /* configuration seems valid */end valid_config;/* Current standard configuration for SCSI Winchesters is below.  The.  address represents D24 number, SCSI target, then LUN...           W0:  0,5,0    W1:  1,5,0.                0,4,0         1,4,0.                0,3,0         1,3,0.                0,2,0         1,2,0*/SCSI_standard_config: proc (dev, config, len) returns (fixed); /* checks for standard config for Winchester device */   dcl dev        fixed; /* device to look at (0: W0, 1: W1) */   dcl config     fixed array; /* winchester storage table */   dcl len        fixed; /* length of array */   dcl controller fixed; /* SCSI controller number to look for */   dcl D24_number fixed; /* D24 board number for this device */   dcl p          fixed;   controller = 5; /* start with the first drive in default configuration */   D24_number = dev; /* D24 number is zero for W0, one for W1 */   p = 0;   do while ((p < len) and (config (p + s#devtyp) <> s#freblk) /* not at the end of table */   and ((config (p + s#devtyp) and "377") <> (shl(dev,4) or 1))); /* not the correct Winchester device */      p = p + s#blklen; /* look at next device */   end;   do while ((p < len) and (config (p + s#devtyp) <> s#freblk) /* not at the end of table */   and ((config (p + s#devtyp) and "377") = (shl(dev,4) or 1)) /* a Winchester, and correct device */   and (controller >= 2)); /* keep controller in range (5 -> 2 for now) */      if ((config (p + s#devadr) and "17") = controller) then do; /* correct controller */         controller = controller - 1; /* go on to next controller */         p = p + s#blklen; /* check next drive */      end;      else return (-1); /* not the standard configuration */   end;   if ((p < len) and (config (p + s#devtyp) <> s#freblk) /* not at the end of table */   and ((config (p + s#devtyp) and "377") = (shl(dev,4) or 1))) /* still on the same Winchester device */   then return (-1); /* not the standard configuration */   else return (p - s#blklen); /* okay, so return pointer to last drive on device */end SCSI_standard_config;