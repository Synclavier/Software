/* $TITLE  RECOVER - Recover A File From A Damaged Disk *//* This program recovers files from damaged floppies and Winchester disks.  It is of most use recovering TEXT files, as these can be easily edited  and repaired under the Screen Editor.  By:  Karim J. Chichakly in June 1984*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:termut'; /* terminal utilities */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:devutil'; /* device handlers */insert ':-xpl:catutil'; /* catalog handlers */insert ':-xpl:strings'; /* string processing */insert ':-xpl:whendisk'; /* WHEN DISKERROR handler */dcl cat (c#dir_max - 1) fixed; /* catalog buffer */dcl buf (255)  fixed; /* sector buffer */dcl f (64)     fixed; /* source filename */dcl f2 (64)    fixed; /* destination filename if different than source filename */dcl (s, d)     fixed; /* source and destination level numbers */dcl (sms, sls) fixed; /* source starting sector */dcl (dms, dls) fixed; /* destination starting sector */dcl (sme, sle) fixed; /* source ending sector */dcl (oml, oll) fixed; /* offset (length copied) */dcl saved      boolean; /* TRUE if the new copy was saved on the destination */dcl disk_in    boolean; /* TRUE if the disk is in the drive */screen_size (-1, -1); /* make sure TERMUTIL doesn't truncate our text */call set_catbuf (addr(cat (0)), 0); /* define catalog buffer */print;print 'Recover File Utility - ', string(rel.date);print;print 'This program allows you to recover text files from damaged disks.';print 'This program cannot recover damaged data.  After running this';print 'program, small sections of your file will still be damaged, but';print 'these sections can easily be re-entered using the Screen Editor.';print 'The program tries to give you an indication of where the damaged';print 'information is in the file, but the best way to find the damaged';print 'sections is to scroll through the recovered file using the';print 'Screen Editor.';print;print 'Type ''OK'' and press RETURN if you want to proceed ->',;linput f; f (0) = f (0) - 1;if not compare (f, 'OK') then call exit(0); /* if not okay, get out */print;s = -1; /* make the source invalid */do while (find_device (s) = 0); /* loop until we get a configured source device */   print 'Where is the damaged file [CC, F0, F1, R0, R1, W0, or W1]? ',;   linput f; f (0) = f (0) - 1;   s = get_device (f, false); /* get the device number (disallow T0/T1) */   if s = -1 then do; /* bad device name */      print 'Invalid device name ''', string(f), '''.  Please try again.';      print;   end;   else if find_device (s) = 0 then do; /* not configured */      print 'Device ''', string(f), ''' is not configured.  Please try again.';      print;   end;end; /* of getting source device */if ((s = 1) and ((core(loc.ucat) = 0) and ((core(loc.ucat + 1) and "377") = 0))) /* if CC specified and no CC */then s = shr(core(loc.ucat + 1), 8); /* map it into the real device */disk_in = not ((s >= 2) and (s < 6)); /* assume there's no disk inserted on floppy source */do while (not disk_in); /* make sure there's a source disk */   print 'Insert damaged diskette into ',; call name (s); print ' and press RETURN ->',;   linput f;   disk_in = disk_check (s); /* see if they put the disk in */end;if systyp = 0 then do; /* floppy based system? */   d = 2; /* destination level is F0 */   disk_in = not ((s <> d) and ((s <> 1) or (shr(core(loc.ucat + 1), 8) <> d))); /* assume no disk inserted if we need a different disk */   do while (not disk_in); /* make sure there's a system disk */      print 'Insert a formatted diskette into ',; call name (d); print ' and press RETURN ->',;      linput f;      disk_in = disk_check (d); /* see if they put the disk in */      if (disk_in and d#protect) <> 0 then do; /* write-protected? */         print 'This diskette is write-protected and therefore cannot be used.';         disk_in = false;      end;   end;end;else do; /* on Winchesters, we need to be careful */   if curtyp = 1 /* if the current device is a Winchester */   then d = 1; /* destination is CC */   else d = 6; /* otherwise, use W0 */end;print 'Name of file to recover? ',; linput f; f (0) = f (0) - 1;if not locate (f, s) then do;   print;   print 'File ''', string(f), ''' is not saved on ',; call name (s); print '.';end;else do; /* the file is there */   if locate (f, d) then do; /* ask for destination name */      print 'Name of new file? ',; linput f2; f2 (0) = f2 (0) - 1;      do while (locate (f2, d) or (not valid_filename (f2))); /* loop while the name's there or invalid */         if not valid_filename (f2) /* if the name's bad */         then print 'I am sorry, but there is an invalid filename character in ''', string(f2), '''.';         else print 'I am sorry, but file ''', string(f2), ''' is already saved.';         print 'You will have to choose a different name.';         print;         print 'Name of new file? ',; linput f2; f2 (0) = f2 (0) - 1;      end;   end;   else f2 (0) = 0; /* no second name */   call locate (f, s); /* find file on source */   sms = (f#ms_sector and "377"); sls = f#ls_sector; /* save start */   sme = sms + f#ms_length; /* save end */   sle = sls + f#ls_length;   if sle ilt f#ls_length then sme = sme + 1;   if f2 (0) <> 0 /* on CC */   then saved = replace (f2, f#type, f#ms_length, f#ls_length, f#words, d);   else saved = replace (f,  f#type, f#ms_length, f#ls_length, f#words, d);   if saved then do; /* if there was room on the disk */      dms = (f#ms_sector and "377"); dls = f#ls_sector; /* pointer into dest file */      oml = 0; oll = 0; /* no sectors copied yet */      print '              Source  Src(8)      Dest  Dst(8)    Offset  Off(8)'; /* print header */      do while ((sms ILT sme) /* copy the file over to the dest */      or ((sms = sme) and (sls ILT sle)));      	 call disk.io.setup; 	/* initialize WHENDISK */         call readdata (shl(s, 8) or sms, sls, buf, 256);         if disk.io.cleanup <> 0 then do;            print 'Bad sector:',;            lnum (sms, sls, 9); wchar (a.sp); lonum (sms, sls, 8);            lnum (dms, dls, 9); wchar (a.sp); lonum (dms, dls, 8);            lnum (oml, oll, 9); wchar (a.sp); lonum (oml, oll, 8); crlf;         end;         call writedata (shl(d, 8) or dms, dls, buf, 256);         sls = sls + 1; /* point to next source sector */         if sls = 0 then sms = sms + 1;         dls = dls + 1; /* and next dest sector */         if dls = 0 then dms = dms + 1;         oll = oll + 1; /* increment offset */         if oll = 0 then oml = oml + 1;      end;      print;      print 'File ''', string(f), ''' is now stored on ',; call name (d);      if f2 (0) <> 0 then print ' as ''', string(f2), '''',;      print '.';   end; /* of copying damaged file */   else do; /* no go, geronimo */      print;      print 'Sorry, but there is not enough disk space to recover file ''', string(f), '''.';      if ((s = d) and (s >= 2) and (s < 6)) then do; /* they may be able to make room */         print 'Copy all undamaged files from this disk to a good disk.  Then UNSAVE';         print 'these same undamaged files from this disk and try again.';      end;   end; /* of can't save file */end; /* of we found the file to recover */disk_in = not (systyp = 0); /* assume there's no disk inserted on floppy systems */do while (not disk_in); /* make sure there's a system disk */   print 'Insert a SYSTEM disk into ',; call name (2); print ' and press RETURN ->',;   linput f;   disk_in = disk_check (2); /* see if they put the disk in */end;