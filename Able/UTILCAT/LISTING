/* LISTING  $TITLE  LISTING utility */configuration modelC, MULDIV;/* 08/29/82 - JSR - Total rewrite to add improved parser, index option,                 procedure index, titles, subtitles09/07/82 - JSR - Changes to terminal and printer buffering for VT10002/01/83 - JSR - Fixed parsing of quotes containing comments11/10/83 - JSR - Improved Menu to work like FORMCOPY01/01/84 - JSR - Added XPL-5 keywords to parser12/14/84 - JSR - Change to -6, new Menu to match new FORMCOPY05/23/85 - KJC - Added ordered selection of files03/24/86 - KJC/KJO - Fixed block comment indentation04/10/86 - KJC/KJO - Revised for -7 catalog structure05/10/88 - KJC - Added Macintosh support05/15/89 - MWH - Add support for printing through Macintosh, improvements*//* global variables */DCL BREAKSET  FIXED; /* set to one when break is hit */DCL INDENT    FIXED; /* amount to indent for each level */DCL LINE      FIXED; /* counter for line on actual page */DCL PASS      FIXED; /* set to 0 for index pass, 1 for print pass */DCL PAGENUM   FIXED; /* output page number */DCL TOT_PAGES FIXED; /* total number of pages (if we printed an index) *//* insert TERMINAL MANAGEMENT PACKAGE and CATALOG processing package */insert ':-xpl:reldat';	 /* get releasae date */insert ':-XPL:LITERALS'; /* general literals */insert ':-XPL:ASCIILIT'; /* ascii definitions */insert ':-XPL:TERMUT';   /* the terminal management utilities */insert ':-XPL:CATRTNS';  /* catalog routines */insert ':-XPL:DEVUTIL'; /* device utilities */insert ':-XPL:CATUTIL'; /* catalog utilities *//* Printer characteristics */DCL FORMFEED.WORKS FIXED; /* SET TRUE WHEN FORMFEED OPERATION WORKS */DCL PAGEWIDTH      FIXED; /* WIDTH OF PAGE   */DCL PAGELENGTH     FIXED; /* LENGTH OF PAGE  */DCL VMARGIN        FIXED; /* VERTICAL MARGIN */DCL COMTAB         FIXED; /* COLUMN TO START COMMENT ON  */DCL BAUDRATE       FIXED; /* BAUD RATE OF THIS PRINTER *//* User-selected options */DCL G.TITLE(64)      FIXED; /* possible LISTING TITLE */DCL P.TITLE(64)      FIXED; /* possible procedure title */DCL S.TITLE(64)      FIXED; /* possible procedure subtitle */DCL NO.COPIES        FIXED; /* number of copies of this file */DCL SELECT.FLAG      FIXED; /* true => select files, false => whole catalog */DCL PRINT.INDEX.FLAG FIXED; /* true => index is to be printed */DCL PRINT.VIA.MAC    FIXED; /* true => printing through MAC to network printer */DCL DISK.LEVEL       FIXED; /* (see SYSIORTN package for discussion of 'levels') */DCL Redirection      FIXED; /* Redirection word from configuration */DCL Disk_Inserted    BOOLEAN; /* TRUE if a disk has been inserted into the drive */DCL OUT.TERM.TYPE    FIXED;/*  can be:  0) Terminal, 1) Decwriter, 2) La-34, 3) Printronix, 4) PaperTiger, 5) Diablo, 6) Other *//* MAC terminal special escape sequences (precede these with an ESCAPE) */DCL MAC.BAUD.9600    LIT '''%B''';   /* Set MAC printer port to 9600 baud */DCL MAC.BAUD.19200   LIT '''%D''';   /* Set MAC printer port to 19200 baud */DCL MAC.OPEN.PRINT   LIT '''%P''';   /* Open MAC printer port at current baud rate */DCL MAC.CLOSE.PRINT  LIT '''%C''';   /* Close MAC printer port */DCL MAC.TO.SCREEN    LIT '''%X''';   /* Direct output to MAC screen */DCL MAC.TO.PRINTER   LIT '''%T''';   /* Direct output to MAC printer port *//* $Page *//* buffers, counters, and print states */DCL CATALOG (C#Dir_Max - 1) FIXED; /* Catalog buffer */DCL ENTRY.MAX               LIT 'C#Dir_Max/C#Len'; /* Maximum no. of catalog entries */DCL PRINT.THIS.FILE (ENTRY.MAX - 1) FIXED; /* indicators for FCB's to be printed */DCL (MS_TOTAL,LS_TOTAL)   FIXED; /* total number of sectors used on disk */DCL BUFSIZE               LIT '1024'; /* input buffer size */DCL IBUF(BUFSIZE - 1)     FIXED; /* input buffer */DCL BUFMAX LIT '160'; /* maximum number of characters allowed in program buffers */DCL NEW.PAGE              FIXED; /* 0: no new page, 1: new page, 2: page and skip space in index */DCL INDEX.ENTRY           BOOLEAN; /* true when line is to be printed in index */DCL FILE.LINE             FIXED; /* line position of file when being printed */DCL LEVEL                 FIXED; /* indent level */DCL PRIOR.LEVEL           FIXED; /* indent level of previous line */DCL LABEL.BUF  (BUFMAX/2) FIXED; /* buffer for statement label */DCL STMT.BUF   (BUFMAX/2) FIXED; /* buffer for statement line text */DCL COMMENT.BUF(BUFMAX/2) FIXED; /* buffer to hold comment text */DCL LINE.NUMBER           FIXED; /* program's line number */DCL TOKEN(12)             FIXED; /* token buffer in parser */DCL LITERAL.MODE          BOOLEAN; /* true when in literal (as is) mode */DCL COMMENT               BOOLEAN; /* true when parser in comment */DCL QUOTED                BOOLEAN; /* parse state for quoted string */DCL NEW.FILE              BOOLEAN; /* true for start of new file */DCL NAM(4)                FIXED; /* name of current file */DCL (MS_SEC,LS_SEC)       FIXED; /* starting sector of current file */DCL ISEC                  FIXED; /* sector currently being processed */DCL LEN                   FIXED; /* length of file in sectors */DCL (IPOS,WPOS)           FIXED; /* pointers into buffer *//*  S E T . O U T . T E R M  */set.out.term:  proc (printer);   dcl printer  fixed; /* 0) Terminal, 1) Decwriter, 2) La-34, 3) Printronix, 4) PaperTiger, 5) Diablo, 6) Other */   OUT.TERM.TYPE = printer; /* set the type */   Redirection = 1; /* no input redirection, direct output to printer */   do case(printer); /* get characteristics */      do; /* 0:  user terminal default */         Redirection = no_redirection; /* turn off redirection */         PAGELENGTH =22;    PAGEWIDTH  =80;            COMTAB     =40;    VMARGIN    =1;         baudrate = b#9600; /* unimportant here */      end;      do; /* 1:  Decwriter */         PAGELENGTH =66;    PAGEWIDTH  =132;           COMTAB     =60;    VMARGIN    =5;         baudrate = b#300;      end;      do; /* 2:  La-34 */         PAGELENGTH =66;    PAGEWIDTH  =132;           COMTAB     =60;    VMARGIN    =5;         baudrate = b#1200;      end;      do; /* 3:  Printronix */         PAGELENGTH =88;    PAGEWIDTH  =132;           COMTAB     =60;    VMARGIN    =5;         baudrate = b#19200;      end;      do; /* 4:  Paper Tiger (Dataproducts) */         PAGELENGTH =66;    PAGEWIDTH  =132;         COMTAB     =60;    VMARGIN    =5;         baudrate = b#9600;      end;      do; /* 5:  Diablo */         PAGELENGTH =88;    PAGEWIDTH  =132;           COMTAB     =60;    VMARGIN    =5;         baudrate = b#300;      end;      do; /* 6:  Other (pick reasonable defaults) */         PAGELENGTH =66;    PAGEWIDTH  =132;           COMTAB     =60;    VMARGIN    =5;         baudrate = b#9600; /* guess */      end;   end; /* of case */   write("41") = (shl(baudrate, 8) or b#enable); /* set baud rate (if D40Q) */end set.out.term;/* $SUBTITLE I/O Routines *//*  NewLine  -  Does a line feed */newline: proc;   Line = Line + 1; /* update line counter */   crlf;end newline;/*  T O P  */TOP:  proc; /* called to advance to top of page */   do while Line < PageLength;      call newline;   end;   Line = 0;END TOP; /*  B L K T R N  -  BLOCK TRANSFER  */BLKTRN:  proc(SOUR,DEST,LEN); /* block transfer of words */   DCL (SOUR,DEST) ARRAY;   DCL (LEN,I)     FIXED;   DO I=0 TO LEN-1; DEST(I)=SOUR(I); END;END BLKTRN;/* Min - returns min of a and b */min: proc(a, b) fixed public; /* unsigned minimum function */   dcl (a, b) fixed;   if a ILT b then return a;   else            return b;end min;GC:  proc returns (fixed); /* call to get next character */   dcl i fixed;   dcl (MSW,LSW) fixed;   if (PASS = 0) then call trigger_motor(DISK.LEVEL); /* if on index pass, keep motors going */   if IPOS = shl(BufSize,1) then do; /* get new buffer load */      if peek <> -1 then do; /* character typed */         if rchar = 0 then BreakSet = 1; /* catch when break key is hit */      end;      IPOS = 0; ISEC = ISEC + shr(BUFSIZE,8); /* advance sectors */      MSW = MS_SEC; /* calculate new starting sector */      LSW = LS_SEC + ISEC;      if LSW ilt LS_SEC then MSW = MSW + 1;      i = LEN - WPOS; /* calculate amount remaining */      if i ige BUFSIZE then i = BUFSIZE; /* no larger than buffer */      call ReadData (MSW, LSW, IBUF, i);   end;   if (IPOS) then WPOS = WPOS + 1; /* update word position */   i = IBUF(shr(IPOS,1)); /* get word contents */   IPOS = IPOS + 1;   if (IPOS) then return (i and "377");   else return (shr(i,8));end GC; DELIM:  proc(ch) returns (boolean); /* returns true if char is a delimeter for current file type */   dcl ch fixed;   if (ch >= L.A) and (ch <= L.Z) then ch = ch - (L.A - A.A); /* up the case */   if (ch >= A.A)   and (ch <= A.Z)   then return (false); /* letters are never delims */   if (ch >= A.0)   and (ch <= A.9)   then return (false); /* digits are never delims */   if ch = A.SP then return (true); /* spaces are always delims */   if (ch = A.PERIOD) or (ch = A.SCORE) or (ch = A.DOLLAR) or (ch = A.SHARP) then return (false); /* not delims in XPL */   return (true); /* all others are delims */end DELIM;/* $Page */SCANNER:  proc; /* looks for indent keywords in indicated line */   dcl (ch,prev.ch,i) fixed;   dcl save.state     fixed; /* 0: skip, 1: label, 2: statment, 3: comment */   dcl gap_length     fixed; /* number of spaces before hitting non-space */   dcl comment_gap    fixed; /* number of spaces before first line in block comment */   dcl num.keys1      lit '6';   dcl num.keys2      lit '5';   dcl num.keys3      lit '5';   dcl key.list1 data ('DO0       BEGIN0    DEFINE1   MODULE1   PROC2     PROCEDURE2');   dcl key.list2 data ('NOTELIST3 END4      WHEN5     INSERT5   LIBRARY5');   dcl key.list3 data ('$TITLE6   $SUBTITLE7$PAGE8    $NOFORMAT9$FORMAT:');   save.char:  proc(ch);      dcl ch fixed;      do case save.state; /* branch to load in correct buffer */         ; /* 0: skip */         do; /* 1: label */            if label.buf(0) < bufmax then do; /* check limits */               call pbyte(label.buf,label.buf(0),ch);               label.buf(0) = label.buf(0) + 1;            end;         end;         do; /* 2: statement */            if stmt.buf(0) < bufmax then do; /* check limits */               call pbyte(stmt.buf,stmt.buf(0),ch);               stmt.buf(0) = stmt.buf(0) + 1;            end;         end;         do; /* 3: comment */            if comment.buf(0) < bufmax then do; /* check limits */               call pbyte(comment.buf,comment.buf(0),ch);               comment.buf(0) = comment.buf(0) + 1;            end;         end;      end; /* of do case */   end save.char;   get.string:  proc(str); /* load up the specified string */      dcl str array;      str(0) = 0; /* clear the string */      do while (ch = A.SP); /* skip over blanks */         call save.char(prev.ch); prev.ch = ch; ch = (GC and "177"); /* record and advance */      end;      call save.char(prev.ch); prev.ch = ch; ch = (GC and "177"); /* get next char */      do while ((prev.ch <> A.STAR) or (ch <> A.SLASH)) and (ch > A.NUL); /* loop until end of comment */         call pbyte(str,str(0),prev.ch); /* store */         str(0) = str(0) + 1; /* bump the length */         call save.char(prev.ch); prev.ch = ch; ch = (GC and "177"); /* get next char */      end; /* end loop */      if ch > 0 then comment = false; /* reached end */      else do; call pbyte(str,str(0),prev.ch); str(0) = str(0) + 1; end;   end get.string;   token.check:  proc(key.list,num.keys); /* check token against reserved words */      dcl key.list              array;      dcl num.keys              fixed;      dcl (i,ptr1,ch1,ptr2,ch2) fixed;      do i = 0 to (num.keys - 1); /* loop over possible keys */         ptr1 = 10*i; /* point to start of i'th key */         ch1 = byte(key.list,ptr1) and "177"; /* get char of key */         do ptr2 = 1 to token(0); /* scan token for match */            ch2 = token(ptr2); /* char of token */            if (ch2 >= L.A) and (ch2 <= L.Z) then ch2 = ch2 - (L.A - A.A); /* up the case */            if ch1 <> ch2 then goto break.out1; /* match fails, try next key */            ptr1 = ptr1 + 1; ch1 = byte(key.list,ptr1) and "177"; /* next char of key */         end;         if (ch1 >= A.0) and (ch1 <= A.COLON) then do; /* got a keyword */            do case (ch1 - A.0); /* get its code and branch */               if not comment then level = level + 1; /* 0: indent */               if not comment then do; level = level + 1; index.entry = true; end; /* 1: indent and index */               if not comment then do; /* 2: procedure */                  index.entry = true; /* mark name */                  if stmt.buf(0) > 0 then level = level + 1; /* indent if past label */               end;               if (not comment) and (ch = A.SP) then do; level = 1; prior.level=0; index.entry=true; end; /* 3: notelist */               if not comment then level = level - 1; /* 4: undent */               if not comment then index.entry = true; /* 5: index entry */               if comment then do; index.entry = true; new.page = 2; call get.string(P.TITLE); end; /* 6: TITLE */               if comment then do; index.entry = true; new.page = 2; call get.string(S.TITLE); end; /* 7: SUBTITLE */               if comment then new.page = 1; /* 8: PAGE */               literal.mode = true; /* 9: NOFORMAT */               literal.mode = false; /* :: FORMAT */            end; /* of do case */            token(0) = 0; /* clear out the token */            return; /* done */         end; /* of got a keyword */         BREAK.OUT1:      end; /* loop over possible keys */   end token.check;   if literal.mode then save.state = 3; /* preset the parse state */   else                 save.state = 0;   token(0) = 0; /* no token yet */   gap_length = 0; /* no characters (let alone spaces) encountered yet */   prev.ch = 0; ch = (GC and "177"); /* no previous char, get first char and mask parity */   do while ch <> 0; /* step along chars of input line */      if ch = A.FF then new.page = (new.page or 1); /* go to new page on form feed */      if (not quoted)  and (ch = A.STAR and prev.ch = A.SLASH) then do; comment = true; comment_gap = gap_length; save.state=3; end; /* start of comment */      if (not quoted)  and (ch = A.SLASH and prev.ch = A.STAR) then comment = false; /* end of comment */      if (not comment) and (ch = A.APOST) then quoted = quoted xor 1; /* quoted string */      if not quoted then do; /* program or comment char */         if delim(ch) then do; /* end of identifier, check for key */            if token(0) > 0 then do; /* if token exists */               call token.check(key.list1,num.keys1);               call token.check(key.list2,num.keys2);               call token.check(key.list3,num.keys3);            end;            token(0) = 0; /* clear out identifier */         end; /* of identifier test */         else if token(0) < 12 then do; /* add to token */            token(0) = token(0) + 1; token(token(0)) = ch;         end;      end; /* program text or comment char */      if save.state = 0 then do; /* no real chars yet */         if prev.ch = A.SP then do; /* in gap before stmt? */            if (comment and (gap_length = comment_gap)) then save.state = 3;            gap_length = gap_length + 1; /* one more char in front */         end;         else if prev.ch > A.SP then do; /* did we just hit real chars? */            if comment then save.state = 3;            else            save.state = 1;         end;      end; /* end of no real chars yet */      call save.char(prev.ch); /* save it */      if (prev.ch = A.COLON) and (not quoted) and (save.state = 1)      then save.state = 2; /* past stmt label */      prev.ch = ch; ch = (GC and "177"); /* get next char and mask parity */   end;   if token(0) > 0 then do; /* if token exists */      call token.check(key.list1,num.keys1); /* process last token */      call token.check(key.list2,num.keys2);      call token.check(key.list3,num.keys3);   end;   if (prev.ch > A.SP) and (save.state = 0) then do;      if comment then save.state = 3;      else            save.state = 1;   end;   call save.char(prev.ch); /* save the last char */end SCANNER;/* $Page */FILE.HEADER:  proc; /* print page header for files */   DCL SPACES DATA ('                                 ');   if LINE <> 0 then call TOP; /* make sure at top of page here */   call newline;   pstring (NAM); /* print filename */   pstring ('          -');   unum (PAGENUM, 0); pstring ('-');   if G.TITLE(0) <> 0 then do; /* print the global title */      if PAGENUM < 1000 then wchar (A.SP); /* get spacing to line up */      if PAGENUM < 100  then wchar (A.SP);      if PAGENUM < 10   then wchar (A.SP);      pstring ('         '); pstring (G.TITLE);   end;   call newline;   if P.TITLE(0) <> 0 then do; /* print the procedure title */      pstring (SPACES); pstring (P.TITLE);   end;   call newline;   if S.TITLE(0) <> 0 then do; /* print the procedure subtitle */      pstring ('   '); pstring (SPACES); pstring (S.TITLE);   end;   call newline;   if (PASS = 1)      /* if printout is on remote printer OR through MAC */   AND ((Redirection <> No_Redirection)   OR   (PRINT.VIA.MAC = true))   then do;      redirection_word = no_redirection; /* be sure redirection is off */      if PRINT.VIA.MAC = true then do;          wchar(A.ESC);          pstring(MAC.TO.SCREEN);        /* redirect text to MAC screen */      end;      if PAGENUM = 1 then do; /* first page */         clear_screen;         pstring ('*** Listing Utility              Listing files from '); call name(disk.level); crlf; crlf;         pstring ('Printing page #');      end;      else pstring ('               ');      pnum(PAGENUM, 0);                  /* show page number */      if TOT_PAGES <> -1 then do;        /* show total pages if we know it */         pstring(' / ');         pnum(TOT_PAGES,0);      end;      if (NEW.FILE) then do;         pstring (' File:  '); pstring (NAM); /* show file name */      end;      crlf;      redirection_word = redirection;      /* restore redirection */      if PRINT.VIA.MAC = true then do;          wchar(A.ESC);          pstring(MAC.TO.PRINTER);         /* redirect text to MAC printer */      end;   end;   PAGENUM = PAGENUM + 1; /* increment page number */   NEW.FILE = FALSE;   call newline;end FILE.HEADER;INDEX.HEADER:  proc; /* print page header for index section */   if LINE <> 0 then call TOP; /* get to top of page */   call newline; call newline; pstring ('INDEX');   if G.TITLE(0) <> 0 then do;      pstring ('      '); pstring (G.TITLE);   end;   call newline; call newline; pstring ('Filename   Page  Line');   call newline; call newline;end INDEX.HEADER;/* $SUBTITLE File and Index print routines */PRINT.FILE:  proc returns (boolean); /* print the given file */   dcl i fixed;   PRINT.LINE:  proc;      dcl hpos fixed; /* horizontal position */      if pass = 0  /* is the index page being printed? */      then hpos = 15; /* yes, so 15 characters have already been output for this line */      else hpos = 0;  /* no, so 0 characters have been output */      unum (LINE.NUMBER, 5); /* print the line number */      hpos = hpos + 5;      do i = 1 to (PRIOR.LEVEL*INDENT) + 3;         wchar (A.SP); /* space to position */         hpos = hpos + 1;      end;      pstring (LABEL.BUF); /* print the label */      hpos = hpos + LABEL.BUF(0);      if (pass = 0) and (LABEL.BUF(0) > 0)      then do while HPOS < 40;         wchar (A.SP);         hpos = hpos + 1;      end;      pstring (STMT.BUF); /* print the statement */      hpos = hpos + STMT.BUF(0);      if (LABEL.BUF(0) > 0) or (STMT.BUF(0) > 0)      then do while HPOS < COMTAB;         wchar (A.SP);         hpos = hpos + 1;      end;      pstring (COMMENT.BUF); /* print comment field */      call newline; /* end the line */   end PRINT.LINE;   BREAKSET = 0; /* cancel a break if set */   NEW.FILE = TRUE; /* force new file */   LEVEL = 0; /* indent level is zero */   LITERAL.MODE = FALSE; /* not in literal mode */   P.TITLE(0) = 0; S.TITLE(0) = 0; /* clear procedure title and subtitle */   COMMENT = FALSE; QUOTED = FALSE; /* init the parse states */   FILE.LINE = PAGELENGTH + 1; /* force to start on new page */   i = LEN; /* size to read at this time */   if i ige BUFSIZE then i = BUFSIZE; /* limit to length of buffer */   call ReadData (MS_SEC, LS_SEC, IBUF, i); /* read block */   IPOS = 0; WPOS = 0; ISEC = 0; /* init buffer pointers */   do while (WPOS ilt LEN) and (not BREAKSET); /* loop over file */      NEW.PAGE = 0; INDEX.ENTRY = FALSE; /* assume nothing special about line */      LABEL.BUF(0) = 0; STMT.BUF(0) = 0; COMMENT.BUF(0) = 0; /* clear strings */      LINE.NUMBER = GC + shl(GC,8); /* get the line number */      PRIOR.LEVEL = LEVEL; /* remember the present level */      call SCANNER; /* scan for keywords */      if LEVEL < 0 then LEVEL = 0; /* limit undents */      if LEVEL < PRIOR.LEVEL then PRIOR.LEVEL = LEVEL; /* apply 'end' level change now */      if PASS = 0 then do; /* process index pass */         if NEW.PAGE > 1 then call newline; /* skip a space */         if (NEW.PAGE > 0) or (FILE.LINE > (PAGELENGTH - VMARGIN)) then do;             FILE.LINE = 6; PAGENUM = PAGENUM + 1; /* count page advance and 6 line header */         end;         if LINE > (PAGELENGTH - VMARGIN) then call INDEX.HEADER; /* check real pages of index */         if INDEX.ENTRY then do; /* print the entry */            pstring ('         '); unum (PAGENUM-1, 5); /* print the page number */            wchar (A.SP); call PRINT.LINE; /* print the line */         end;      end;      else do; /* process fileprint pass */         if (NEW.PAGE > 0) or (FILE.LINE > (PAGELENGTH - VMARGIN)) then do; /* next page */            call FILE.HEADER; /* start new page */            FILE.LINE = 6; /* 6 lines on page for header */         end;         call PRINT.LINE; /* print the line */      end;      FILE.LINE = FILE.LINE + 1; /* add this line to page */      if IPOS then call GC; /* skip extra null */   end; /* of do while */   if PASS = 1 then call TOP; /* end of file, go to top of page */   if breakset then return(false); /* exit if we broke out */   return(true);end PRINT.FILE;/*  P R I N T . I N D E X  */PRINT.INDEX:  proc returns (boolean); /* print an index for the current file */   call newline;   if LINE > (PAGELENGTH - VMARGIN) then call INDEX.HEADER; /* check read pages of index */   pstring (NAM); pstring (' '); unum (PAGENUM, 5);    pstring ('     '); unum (LEN, 5); pstring (' words'); call newline;   if Redirection <> No_Redirection   /* if we aren't listing to the console */   OR PRINT.VIA.MAC = true then do;      redirection_word = no_redirection; /* be sure redirection is off */      if PRINT.VIA.MAC = true then do;          wchar(A.ESC);          pstring(MAC.TO.SCREEN);        /* redirect text to MAC screen */      end;      pstring (NAM); pstring (' '); unum (PAGENUM, 5);       pstring ('     '); unum (LEN, 5); pstring (' words'); crlf;      redirection_word = redirection; /* restore redirection */      if PRINT.VIA.MAC = true then do;          wchar(A.ESC);          pstring(MAC.TO.PRINTER);       /* redirect text to MAC printer */      end;   end;   return (PRINT.FILE); /* print file with pass=0 will give index */end PRINT.INDEX;/* $SUBTITLE  Menu Routines (Print, Alter, Catalog, Change)   *//*  Procs to print out a MENU of current default values,      *//*  and then alter any of these displayed defaults.           *//*  User may also stack up a list of filenames to be printed  *//*  in the entered order.                                     *//*  F I L E . P R I N T A B L E  */FILE.PRINTABLE:  proc(FCB) returns (boolean); /* return true if this file is to be printed */   dcl FCB       fixed array;   dcl i         fixed;   dcl (MSW,LSW) fixed;   if (FCB(F#NM) = 0)                     then return (FALSE); /* no file name */   if (FCB(F#ML) = 0) and (FCB(F#LL) = 0) then return (FALSE); /* file of zero length */   if (FCB(F#TY) <> t#text)               then return (FALSE); /* not of type text */   if (FCB(F#NM) and "177") = A.PERIOD    then return (FALSE); /* begins with dot */   MSW = C#MS_Sector + FCB(F#MS); /* calculate first sector of this file */   LSW = C#LS_Sector + FCB(F#LS);   if LSW ilt C#LS_Sector then MSW = MSW + 1;   call ReadData(MSW, LSW, IBUF, 256); /* get first sector of file */   if IBUF (0) < 0 then return (FALSE); /* not a good line number */   do i = 0 to 510; /* check first few bytes */      if byte(IBUF, i) = 0 then return (TRUE); /* look for end of line code */   end;   return (FALSE); /* looks bad to print */END FILE.PRINTABLE;sort_cat: proc(NameSort,Last_FCB); /* sorts catalog buffer contents */   dcl NameSort         boolean; /* TRUE to sort by name, FALSE to sort by origin */   dcl Last_FCB         fixed; /* last used FCB in catalog */   dcl fcb1 (f#len - 1) fixed; /* temporary FCB's */   dcl fcb2 (f#len - 1) fixed;   dcl small            fixed; /* smallest index */   dcl Less             boolean; /* less-than status */   dcl (i, j)  fixed;                  compare_name: proc(f1,f2) returns (boolean); /* returns TRUE if f1 name < f2 name */      dcl (f1,f2) fixed array; /* FCB arrays to use */      dcl result  boolean; /* result of compare */      dcl i       fixed;      if f1(F#NM) = 0 /* is first name blank? */      then result = false;  /* yes, so f1 > f2 */      else if f2(F#NM) = 0 /* is second name blank? */      then result = true; /* yes, so f1 < f2 */      else do; /* determine which one is smaller */         i = f#nm; /* start at first word in name */         do while (i < f#nm + f#name_len - 1) and (f1(i) = f2(i)); i = i + 1; end; /* advance until inequality found */         result = (rot(f1(i), 8) ilt rot(f2(i), 8)); /* TRUE if f1 < f2 */      end;      return (result); /* return result of compare */   end compare_name;   /* Selection Sort */   do i = 0 to Last_FCB; /* sort all known FCB's in catalog */      small = i; /* assume FCB at index I is the smallest */      call Get_FCB(small,fcb1); /* get this FCB */      do j = i + 1 to Last_FCB; /* check the rest of the FCB's */         call Get_FCB(j,fcb2); /* get FCB at index J */         if NameSort /* if sorting by name */         then Less = compare_name(fcb2,fcb1); /* TRUE if fcb2 name < fcb1 name */         else Less = ( ( fcb2(F#MS) ilt fcb1(F#MS) ) or /* if sorting by origin */                       ((fcb2(F#MS)  =  fcb1(F#MS)) and (fcb2(F#LS) ilt fcb1(F#LS))) );         if Less then do; /* is new FCB is smaller than smallest FCB? */            small = j; /* yes, so store new smallest entry */            call BlockMove(fcb2,fcb1,F#Len); /* store smallest FCB */         end;      end;      call get_fcb (i, fcb2); /* swap FCB's */      call put_fcb (small, fcb2);      call put_fcb (i, fcb1);      j = print.this.file (small); /* swap printable status */      print.this.file (small) = print.this.file (i);      print.this.file (i) = j;   end;end sort_cat;/* $SUBTITLE  User Interface:  Select Files To List */select_files: proc returns (boolean); /* select files to copy from source catalog */   dcl xref (Entry.Max - 1)  fixed; /* cross reference printed names to their corresponding FCBs */   dcl file.status (Entry.Max - 1) fixed; /* cross reference FCBs to the order to copy */   dcl ordered (Entry.Max - 1) fixed; /* cross reference ordered files to their FCBs */   dcl blk (f#len - 1)   fixed; /* local FCB for selecting file order */   dcl blk2 (f#len - 1)  fixed; /* local FCB for selecting file order */   dcl (cur.x, cur.y)    fixed; /* current position on menu */   dcl (i, j, k, m, n)   fixed;   print.name: proc (blk, n); /* print filename */      dcl blk              fixed array; /* FCB of file whose name we want printed */      dcl n                fixed; /* number of this file on screen */      dcl nam (f#name_len) fixed; /* place to store the name */      call clean_fcbname (blk, nam); /* convert FCB name to string */      nam (0) = shl(f#name_len, 1); /* use all characters of name */      pstring (nam); /* print out the name */      if (n mod 8) = 0 then crlf; /* be neat (can fit eight names across) */      else                  pstring (' ');   end print.name;   print_header: proc; /* print selection menu header */      clear_screen;      pstring ('Listing from:  '); call name (disk.level); crlf;      pstringr ('-------------------------------------------------------------------------------');      pstringr ('SELECT option:  Use cursor keys to move over files.  Press the space bar');      pstringr ('to select or deselect a file to list.  Press R to review the order in');      pstringr ('which the files will be listed.  Press RETURN to initiate the listing.');      pstringr ('Press Q to abort the list operation.  Selected files are marked with a >.');   end print_header;   call print_header; /* print menu header */   do i = 0 to c#dir_size/c#len - 1; /* no files have been selected yet */      file.status (i) = -1; /* don't copy any files */   end;   k = 0; /* haven't selected any files yet */   i = a.r; /* force ourselves to print the filenames */   do while ((i <> a.cr) and (i <> a.q) and (i <> l.q) and (i <> a.nul)); /* wait for a RETURN or Q for quit */      if i = a.refresh then do; /* refresh screen */         call print_header; /* print menu header */         i = a.r; /* and force a review of the filenames */      end;      if i = a.sp then do; /* space - toggle selection */         j = xref (cur.y*8 + cur.x); /* pick up the FCB number of the selected file */         if file.status (j) = -1 then do; /* selected a file */            pstring ('>'); /* mark that we're copying it */            file.status (j) = k; /* select it */            ordered (k) = j; /* remember it */            k = k + 1; /* we've just selected another file */         end;         else do; /* deselected it */            pstring ('|'); /* mark that we're NOT copying it */            k = k - 1; /* we now have one less file selected */            do m = file.status (j) + 1 to k; /* remove it from the list */               ordered (m - 1) = ordered (m); /* remove by shifting everything past it down */               file.status (ordered (m)) = file.status (ordered (m)) - 1; /* and update FCB pointers */            end;            file.status (j) = -1; /* deselect it */         end;         i = cur.right; /* automatically move right */      end;      if ((i = cur.up) or (i = a.vt)) then do; /* cursor up */         if cur.y > 0 /* if we can, move up */         then cur.y = cur.y - 1;      end;      else if ((i = cur.down) or (i = a.lf)) then do; /* cursor down */         if ((cur.y < n/8 - 1) or ((cur.y = n/8 - 1) and (cur.x <= n mod 8))) /* if we can, move down */         then cur.y = cur.y + 1;      end;      else if ((i = cur.right) or (i = a.ff)) then do; /* cursor right */         if (((cur.y < n/8) and (cur.x < 8 - 1)) or ((cur.y = n/8) and (cur.x < n mod 8))) /* if we can, move right */         then cur.x = cur.x + 1;         else if cur.y < n/8 then do; /* wrap to next line if we can */            cur.x = 0; /* wrap to beginning if line */            cur.y = cur.y + 1; /* move to next line */         end;      end;      else if ((i = cur.left) or (i = a.bs)) then do; /* cursor left */         if cur.x > 0 /* if we can, move left */         then cur.x = cur.x - 1;         else if cur.y > 0 then do; /* wrap to previous line if we can */            cur.x = 7; /* move to the end of the line */            cur.y = cur.y - 1; /* move to previous line */         end;      end;      else if ((i = cur.home) or (i = c.r) or (i = c.y) or (i = a.rs) or (i = pf.1)) then do; /* home */         cur.x = 0;  cur.y = 0;      end;      else if ((i = a.r) or (i = l.r)) then do; /* review order */         pos (7, 0); n = 0; /* move to top of display */         do j = 0 to k - 1; /* print out the selected files */            call get_fcb (ordered (j), blk); /* get the fcb */            if blk (f#nm) <> 0 then do; /* valid filename */               xref (n) = ordered (j); n = n + 1; /* remember what entry this name was */               pstring ('>'); call print.name (blk, n); /* and print the name */            end;         end; /* of loop over fcb's */         do j = 0 to c#dir_size/c#len - 1; /* print out the unselected files */            call get_fcb (j, blk); /* get the fcb */            if (file.status (j) = -1) and (blk (f#nm) <> 0) and (print.this.file (j)) then do; /* valid filename */               xref (n) = j; n = n + 1; /* remember what entry this name was */               pstring ('|'); call print.name (blk, n); /* and print the name */            end;         end; /* of loop over fcb's */         cur.x = 0; cur.y = 0; /* we're pointing to the first entry */         n = n - 1; /* move the number of names's base to zero */         clear_typeahead; /* clear any typeahead */      end;      pos (7 + cur.y, cur.x*10); i = rchar; /* move to the proper position and get next character */   end; /* of wait for return or Q */   do j = 2 to 23; pos (j, 0); erase_line; end; /* clean up the screen */   if i <> a.cr /* did we exit with a return? */   then return (false); /* no, abort the listing */   do i = 0 to c#dir_size/c#len - 1; /* set up to sort the catalog by the selected order */      file.status (i) = i; /* no FCBs have been moved yet */      print.this.file (i) = false;   end;   do i = 0 to k - 1; /* sort the catalog in the selected order */      call get_fcb (file.status (ordered (i)), blk); /* get first block */      call get_fcb (i, blk2); /* and second */      call put_fcb (file.status (ordered (i)), blk2); /* write second over first */      call put_fcb (i, blk); /* and first over second to complete the swap */      j = 0;      do while (file.status (j) <> i); /* look for the FCB # of the Ith FCB */         j = j + 1; /* look at next entry */      end;      file.status (j) = file.status (ordered (i)); /* swap FCB pointers */      file.status (ordered (i)) = i;      print.this.file (i) = true;   end;   return (true); /* don't abort the listing */end select_files; /* $SUBTITLE  Print specified files */print_files: proc; /* print specified files */   dcl fcb (F#Len - 1)  fixed;   dcl (i,j,ch) fixed;   /* set up printer redirection */   if PRINT.VIA.MAC = true then do;  /* redirect through the MAC */       if baudrate = b#9600 then do;          wchar(A.ESC);          pstring(MAC.BAUD.9600);    /* set MAC printer port to 9600 */       end;       else if baudrate = b#19200 then do;          wchar(A.ESC);          pstring(MAC.BAUD.19200);   /* set MAC printer port to 19200 */       end;       wchar(A.ESC);       pstring(MAC.OPEN.PRINT);      /* open the MAC printer port */       redirection = no_redirection; /* turn off ABLE printer port */   end;   /* of print via MAC */   redirection_word = redirection;   /* possibly redirect to the ABLE printer port */   screen_size (PageLength, PageWidth); /* set screen size to printer parameters */   PASS = 0;                    /* this is index pass */   TOT_PAGES = -1;              /* we don't know until we complete an index */   if PRINT.INDEX.FLAG then do; /* print an index of the files */      call INDEX.HEADER; /* put up header */      if Redirection <> No_Redirection   /* if we aren't listing to the console */      OR PRINT.VIA.MAC = true then do;         redirection_word = no_redirection; /* be sure redirection is off */         if PRINT.VIA.MAC = true then do;             wchar(A.ESC);             pstring(MAC.TO.SCREEN);        /* redirect text to MAC screen */         end;         clear_screen;         pstring ('*** Listing Utility              Listing files from '); call name(disk.level); crlf;         crlf; pstring ('INDEX'); /* put header on console */         if G.TITLE(0) <> 0 then do; pstring ('      '); pstring (G.TITLE); end;         crlf; crlf; pstringr ('Filename   Page    Length'); crlf;         redirection_word = redirection;    /* restore redirection */         if PRINT.VIA.MAC = true then do;             wchar(A.ESC);             pstring(MAC.TO.PRINTER);       /* redirect text to MAC printer */         end;      end;      MS_Total = 0; /* clear sector counter for index */      LS_Total = 0;      PAGENUM = 1; /* start with page 1 */      do i = 0 to ((C#Dir_Size / C#Len) - 1); /* loop over files */         if print.this.file(i) then do; /* if file is to be printed */            call Get_FCB (i,FCB); /* get it */            call Clean_FCBname (FCB, NAM); /* convert FCB name to string */            NAM(0) = shl(F#Name_Len,1);            MS_SEC = C#MS_Sector + FCB(F#MS); /* calculate starting sector address */            LS_SEC = C#LS_Sector + FCB(F#LS);            if LS_SEC ilt C#LS_Sector then MS_SEC = MS_SEC + 1;            LEN = FCB(F#WD); /* no. words in file */            MS_Total = MS_Total + FCB(F#ML); /* count up total sectors */            LS_Total = LS_Total + FCB(F#LL);            if LS_Total ilt FCB(F#LL) then MS_Total = MS_Total + 1;            if not PRINT.INDEX then do; /* print index (stop here if user wants) */               redirection_word = no_redirection; /* turn off printer redirection here */               if PRINT.VIA.MAC = true then do;                   wchar(A.ESC);                   pstring(MAC.CLOSE.PRINT);      /* close the MAC printer port */               end;               crlf;               pstring('Printing aborted.  Press RETURN to continue ->'); call rchar;               screen_size (24, 80); /* set to terminal screen size */               return; /* stop here */            end;         end;      end; /* of file list loop */      call newline;      pstring ('Last Page: '); unum (PAGENUM - 1, 0);      pstring ('    Total Sectors: '); lnum (MS_Total, LS_Total, 0);       call newline;      if Redirection <> No_Redirection      /* if we aren't listing to the console */      OR PRINT.VIA.MAC = true then do;         redirection_word = no_redirection; /* be sure redirection is off */         if PRINT.VIA.MAC = true then do;             wchar(A.ESC);             pstring(MAC.TO.SCREEN);        /* redirect text to MAC screen */         end;         crlf; pstring ('Last Page: '); unum (PAGENUM - 1, 0);         pstring ('    Total Sectors: '); lnum (MS_Total, LS_Total, 0); crlf;         redirection_word = redirection; /* restore redirection */         if PRINT.VIA.MAC = true then do;             wchar(A.ESC);             pstring(MAC.TO.PRINTER);    /* redirect text to MAC printer */         end;      end;      TOT_PAGES = (PAGENUM - 1) * NO.COPIES;   end; /* of print index */   PASS = 1; /* this is print pass */   PAGENUM = 1; /* start from page 1 */   do i = 0 to ((C#Dir_Size / C#Len) - 1); /* loop over files */      if print.this.file(i) then do; /* if file is to be printed */         call Get_FCB (i,FCB); /* get it */         call Clean_FCBname (FCB, NAM); /* convert FCB name to string */         MS_SEC = C#MS_Sector + FCB(F#MS); /* calculate starting sector address */         LS_SEC = C#LS_Sector + FCB(F#LS);         if LS_SEC ilt C#LS_Sector then MS_SEC = MS_SEC + 1;         LEN = FCB(F#WD); /* no. words in file */         do J = 1 to NO.COPIES;            if not PRINT.INDEX.FLAG then PAGENUM = 1; /* if no index, number each from page 1 */            if not PRINT.FILE then do; /* print file (stop here if user wants) */               redirection_word = no_redirection; /* turn off printer redirection here */               if PRINT.VIA.MAC = true then do;                   wchar(A.ESC);                   pstring(MAC.CLOSE.PRINT);      /* close the MAC printer port */               end;               crlf;               pstring ('Printing aborted.  Press RETURN to continue ->'); call rchar;               screen_size (24, 80); /* set to terminal screen size */               return; /* stop here */            end;         end;      end; /* of file is to be printed */   end; /* of printing loop */   redirection_word = no_redirection; /* turn off printer redirection here */   if PRINT.VIA.MAC = true then do;   /* redirected through the MAC */       wchar(A.ESC);       pstring(MAC.CLOSE.PRINT);      /* close the MAC printer port */   end;   crlf; /* go to start of line */   pstring ('Printing completed.  Press RETURN to continue ->'); call rchar;   screen_size (24, 80); /* set to terminal screen size */end print_files;/* $SUBTITLE Start listing files */list_files: proc returns (boolean); /* list files (returns TRUE if the screen has been cleared) */   dcl fcb (F#Len - 1) fixed; /* temporary FCB */   dcl Last_FCB        fixed; /* index of last FCB in catalog */   dcl (i,j,k)  fixed;   pcmd ('Searching for text files - please wait...');   if not Read_Catalog('', disk.level) then do; /* try to read in the source catalog */      wchar(a.bel); /* ring bell */      erase_command; pcmd ('Could not read catalog!'); /* catalog read failed */      return (false);   end;   Last_FCB = C#Dir_Size / C#Len - 1; /* start at last entry in catalog */   call Get_FCB (Last_FCB, FCB); /* get this FCB */   do while (Last_FCB <> 0) and (FCB(F#NM) = 0); /* search backwards for a non-zero name */      Last_FCB = Last_FCB - 1;      call Get_FCB (Last_FCB, FCB); /* Get next FCB */   end;   call Sort_Cat(false, Last_FCB); /* sort catalog by origin */   k = 0;   do i = 0 to Last_FCB; /* Check all items in catalog */      call Get_FCB (i, FCB); /* get the fcb */      if FILE.PRINTABLE (FCB) then do; /* if file is printable */         print.this.file(i) = true; /* record this fact */         k = k + 1; /* count number of printable files */      end;      else print.this.file (i) = false; /* otherwise its not printable */   end; /* of loop over fcb's */   if k = 0 then do; /* no printable files on this level */      erase_command; pcmd ('None of the files on '); call name (disk.level); pstring (' can be printed.');      return (false);   end;   else do; /* there are files to print */      call Sort_Cat(true, Last_FCB); /* sort catalog by name */      if SELECT.FLAG then do; /* user will select group of files to list */         if not select_files then return (true); /* get out if user wants */      end;      erase_command;      pcmd ('Line up paper and press <RETURN> to start Printout ->'); i = rchar;      do while i <> A.CR;         if (i = a.nul) or (i = a.q) or (i = l.q) then return (select.flag); /* exit on break */         i = rchar;      end;      call print_files; /* print the files */      return (true); /* need to update the screen */   end; /* of list any files */end list_files;/* $SUBTITLE  Routine to Display Menu and Process changes */show.entry:  proc(row); /* display the value for given row */   dcl row fixed;   if row < 5 then pos (10 + row, 55); /* move to field position */   else pos (11 + row, 55);   do case (row);      do; /* 0:  source device */         call name(disk.level); erase_line;      end;      do; /* 1: output device */         do case (out.term.type);            pstring('Terminal        ');            pstring('DECwriter       ');            pstring('LA-34           ');             pstring('Printronix      ');             pstring('IDS/Dataproducts');             pstring('Diablo 630      ');             pstring('Other           ');         end;         erase_command; /* bottom line of menu */         if (out.term.type <> 0) and (not d40_present)         then pcmd ('NOTE:  Configuration data indicates no printer interface in system.');      end;      do; /* 2:  selection flag */         if SELECT.FLAG         then pstring('Yes');         else pstring('No ');      end;      do; /* 3:  index option */         if PRINT.INDEX.FLAG then pstring('Yes');         else                     pstring('No ');      end;      do; /* 4:  print via MAC */         if PRINT.VIA.MAC    then pstring('Yes');         else                     pstring('No ');      end;      do; /* 5:  number of copies */         unum(no.copies,0); erase_line;      end;      do; /* 6:  page length */         unum(pagelength,0); erase_line;      end;      do; /* 7:  page width */         unum(pagewidth,0); erase_line;      end;   end; /* of do case */end show.entry;process_menu:  proc; /* set up menu and process changes */   dcl show.menu  boolean;   dcl row        fixed;   dcl dashes     data ('-----------------------------------------------------------------------------');   dcl (i,j,ch)   fixed;   SHOW.MENU = true; /* put up menu first time */   row = 0; /* start at top row */   ch = -1; /* set to junk */   do while ((ch <> A.Q) and (ch <> L.Q) and (ch <> A.NUL)); /* loop until they ask to quit */      if SHOW.MENU then do;         CLEAR_SCREEN;         crlf;         pstring ('L I S T I N G  Utility                       version of '); pstringr(REL.DATE);         pstringr('');          pstringr('    To issue a command, press the key that represents the command.');         pstringr('    To change an option, move the cursor over the option and press');         pstringr('    the space bar or type the new value.');         pstringr('');         pstringr(dashes);         pstringr('COMMANDS:                      |   OPTIONS: ');         pstringr('                               |');         pstringr('C to display Catalog           |   Storage Device: ');         pstringr('T to change Title              |   Printer Type: ');         pstringr('Q to Quit (return to system)   |   File Select: ');         pstringr('                               |   Print Index Page: ');         pstringr('RETURN to start printout       |   Print on the MAC: ');         pstringr('                               |');         pstringr('                               |   Number of Copies: ');         pstringr('                               |   Page Length: ');         pstringr('                               |   Page Width: ');         pstringr(dashes);         pstringr('Title: ');         pstringr(dashes);         do i = 0 to 7; call show.entry(i); end; /* put up values */         pos(20,8); pstring(g.title); /* put up title */         SHOW.MENU=false;      end;      if row < 5 then pos(10 + row, 55); /* move to field position */      else pos(11 + row, 55);	  do while (term_idle_wait); end; 	/* wait for a character */      ch = peek; erase_command; 		/* get input code */      if row < 5 then pos(10 + row, 55); /* move back to field position (so #s are correct) */      else pos(11 + row, 55);      if ch = A.CR then do; /* start the listing? */         call rchar; /* eat up the return here */         if not disk_check (disk.level) /* make sure there's a floppy disk in the source device */         then do; pcmd ('Please insert a floppy disk into '); call name (disk.level); pstring (' and try again.'); end;         else SHOW.MENU = list_files; /* otherwise, list the files */      end;      else if ((ch = A.C) or (ch = L.C)) then do; /* show catalog */         if not disk_check (disk.level) /* make sure there's a floppy disk in the source device */         then do; pcmd ('Please insert a floppy disk into '); call name (disk.level); pstring (' and try again.'); end;         else do; /* we have a floppy */            clear_screen;            call PRINT_CATALOG(disk.level);            SHOW.MENU=TRUE; /* must reprint menu */         end;      end;      else if ((ch = A.T) or (ch = L.T)) then do; /* set title */         pos(20,8); /* move into position */         erase_line; /* clear current title from screen */         call rchar; /* get rid of command character */         gstring ('', false, g.title, min (69, PAGEWIDTH-33), g#return or g#delete); /* get title */      end; /* of set title */      else if ch = a.refresh then do; /* refresh display */         show.menu = true;      end;      else if ((ch = A.SP) or (ch - A.0 ile A.9)) then do; /* change value */         do case (row);            if ch = A.SP then do; /* 0:  source location */               disk.level = (disk.level mod 7) + 1; /* get next choice */               do while ((find_device (disk.level) = 0)                   or     ((disk.level = 1) and ((core(loc.ucat + 1) and "377") = 0) and (core(loc.ucat) = 0)));                  disk.level = (disk.level mod 7) + 1; /* get next choice */               end;            end;            if ch = A.SP then do; /* 1:  output device */               j = OUT.TERM.TYPE + 1; /* get next choice */               if j > 6 then j = 0; /* wrap */               call SET.OUT.TERM(j); /* set up parameters */               call show.entry(6); /* update related parameters on screen */               call show.entry(7);            end; /* of output device section */            if ch = A.SP then SELECT.FLAG=SELECT.FLAG xor 1; /* 2:  Selection Flag */            if ch = A.SP then PRINT.INDEX.FLAG=PRINT.INDEX.FLAG xor 1; /* 3:  index page */            if ch = A.SP then PRINT.VIA.MAC=PRINT.VIA.MAC xor 1; /* 4:  print via MAC */            if ch <> A.SP then NO.COPIES = guns (g#return or g#updown); /* 5:  COPIES */            if ch <> A.SP then PAGELENGTH = guns (g#return or g#updown); /* 6:  PAGE LENGTH */            if ch <> A.SP then PAGEWIDTH = guns (g#return or g#updown); /* 7:  page width */         end; /* of do case */               call show.entry(row); /* show new value for row */         ch = peek; /* pick up GUNS terminated character (or original character) */      end; /* of change value */      if      (ch = CUR.UP  ) or (ch = A.VT) then row = row - 1; /* cursor moves */      else if (ch = CUR.DOWN) or (ch = A.LF) then row = row + 1;      if row < 0 then row = 0; /* limit position */      if row > 7 then row = 7;      clear_typeahead; /* toss out any characters sitting in the buffer */   end; /* of do until quit */end process_menu;/* $SUBTITLE  Main Program */if SYSTYP = 0 then CORE(LOC.STRD) = 0; /* clear current file if floppy */redirection_word = no_redirection; /* cancel a "RUN,P" */call Set_CatBuf (addr(CATALOG (0)), 0); /* set the catalog buffer *//* initialize some options */SELECT.FLAG      = FALSE; /* default to whole catalog */NO.COPIES        = 1; /* default to one */PRINT.INDEX.FLAG = false; /* default to no index */PRINT.VIA.MAC    = false; /* default to no MAC */INDENT           = 3; /* amount to indent */if (((core(loc.ucat + 1) and "377") = 0) and (core(loc.ucat) = 0)) /* if not in a subcatalog */then DISK.LEVEL = shr(core(loc.ucat + 1), 8); /* then use current device */else DISK.LEVEL = 1; /* else default to current cat/dev *//* set up Output Terminal type */if PRINTER.TYPE < 5 then call SET.OUT.TERM(0); /* set to user terminal */else if (PRINTER.TYPE < 9) or (PRINTER.TYPE > 13) then call SET.OUT.TERM(6);              /* Other type */else call SET.OUT.TERM(PRINTER.TYPE - 8); /* Valid types; Translate "9-13" to "1-5" */call process_menu; /* do as the user requests */disk_inserted = not (systyp = 0); /* assume there's no disk inserted on floppy systems */do while (not disk_inserted); /* make sure there's a system disk */   pcmd ('Insert a SYSTEM disk into '); call name (2); pstring (' and press RETURN ->');   clear_typeahead; call rchar; erase_command;   disk_inserted = disk_check (2); /* see if they put the disk in */end;pcmd ('End of LISTING utility'); flush_term;