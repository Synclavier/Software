/* $title Subcatalog Resize Utility *//*    Program to resize subcatalogs   by Kip Olson, December 1986   Modification history:     23 Jun 87:  Changed screen, added command line support [KJO]     10 May 88:  Added Macintosh support [KJC]*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:devutil';  /* device utilities */insert ':-xpl:termut';   /* terminal utilities */insert ':-xpl:catrtns';  /* catalog routines */insert ':-xpl:scanargs'; /* command line scanning routines */dcl treename_max          lit '80'; /* max no. characters in treename */dcl (parent_name,child_name)(treename_max / 2) fixed; /* treenames for parent and child subcatalogs */dcl cat_name(f#name_len)  fixed; /* subcatalog name */dcl arg_max               lit '80'; /* max no. characters in argument */dcl parent_cache          fixed; /* cache number of parent subcatalog */dcl cache1(C#Dir_Max - 1) fixed; /* cache space for parent subcatalog */dcl child_cache           fixed; /* cache number of child subcatalog */dcl cache2(C#Dir_Max - 1) fixed; /* cache space for child subcatalog */dcl fcb_index(C#Dir_Max / C#Len - 1) fixed; /* fcb indexes for sort */dcl (fcb1,fcb2)(F#Len - 1)           fixed; /* fcbs to use */dcl last_fcb     fixed; /* last fcb in catalog */dcl ResizeParent  boolean; /* TRUE if a parent of the current catalog is being resized */dcl ResizeCurCat  boolean; /* TRUE if current catalog is being resized */dcl ResizePathCat boolean; /* TRUE if path catalog is being resized */dcl MS_CurSec  lit 'core(loc.ucat+1)'; /* Device and MS sector of current catalog */dcl LS_CurSec  lit 'core(loc.ucat)';   /* LS sector of current catalog */dcl MS_CurLen  lit 'core(loc.umax+1)'; /* MS sector length of current catalog */dcl LS_CurLen  lit 'core(loc.umax)';   /* LS sector length of current catalog */dcl MS_PathSec lit 'core(loc.pcat+1)'; /* Device and MS sector of path catalog */dcl LS_PathSec lit 'core(loc.pcat)';   /* LS sector of path catalog *//* $subtitle Data Structures *//*An array is used to store sector information about each catalog. Theinformation is stored as follows:Words            Literals              Function0 - 1        MS_Total,LS_Total         Total number of sectors in catalog2 - 3        MS_Used, LS_Used          Number of sectors actually used in catalog4 - 5        MS_Alloc,LS_Alloc         Number of sectors allocated in catalog6 - 9        (see below)               Sector increase/decrease information*/dcl MS_Total lit '0'; /* General Sector Information */dcl LS_Total lit '1';dcl MS_Used  lit '2';dcl LS_Used  lit '3';dcl MS_Alloc lit '4';dcl LS_Alloc lit '5';/* Words 6-9 in the array PARENT are defined as follows: */dcl MS_Move   lit '6';  /* Max sector increase by moving subcat */dcl LS_Move   lit '7';dcl MS_NoMove lit '8';  /* Max sector increase w/o moving subcat */dcl LS_NoMove lit '9';/* Words 6-9 in the array CHILD are defined as follows: */dcl MS_Shuf   lit '6'; /* Max sector decrease by shuffling subcat */dcl LS_Shuf   lit '7';dcl MS_NoShuf lit '8'; /* Max sector decrease w/o shuffling subcat */dcl LS_NoShuf lit '9';dcl Info_Siz  lit '10'; /* No. words in array */dcl Parent(Info_Siz-1) fixed; /* information about parent subcatalog */dcl Child(Info_Siz-1)  fixed; /* information about child subcatalog */dcl (MS_NewSecs,LS_NewSecs) fixed; /* new sectors to add/subtract from subcatalog */dcl (MS_NewSize,LS_NewSize) fixed; /* new size of subcatalog */dcl (MSW,LSW)               fixed;/* $subtitle Output Routines */Cat_Error:  proc; /* prints out catalog routine error messages */   print.name: proc;      if F#Name(0) <> 0 then do;         pstring(F#Name); wchar(a.SP);      end;   end print.name;   do case C#Status;      pstringr('>> No catalog error! <<');             /* E#None */      pstringr('>> Magic number not set! <<');         /* E#OS */      pstringr('>> No catalog buffer allocated! <<');  /* E#Buffer */      pstringr('>> No catalog in memory! <<');         /* E#No_Dir */      do;                                              /* E#No_Config */         pstring('Device ');         call print.name;         pstringr(' is not in configuration');      end;      pstringr('No floppy disk in drive');             /* E#No_Floppy */      pstringr('>> FCB number out of bounds! <<');     /* E#FCB */      pstringr('>> Level number out of bounds! <<');   /* E#Level */      pstringr('No Available Space on Disk');          /* E#Storage */      pstringr('No Contiguous Space on Disk');         /* E#CStorage */      pstringr('No Room for More Entries in Catalog'); /* E#Dir_Full */      pstringr('Validity Error in Catalog');           /* E#Invalid */      pstringr('Invalid character in filename');       /* E#Name */      pstringr('>> Duplicate file name! <<');          /* E#Duplicate */      do;                                              /* E#No_File */         pstring('File '); call print.name; pstringr('is not on disk');      end;      do;                                              /* E#Not_Cat */         pstring('File '); call print.name; pstringr('is not a subcatalog');      end;      pstringr('Incorrect format for treename');       /* E#Treename */      do;                                              /* E#No_Path */         pstring('Subcatalog '); call print.name; pstringr('is not on disk');      end;      pstringr('File type must match for Replace');    /* E#Type */      pstringr('>> File too large! <<');               /* E#Too_Large */   end;end Cat_Error;#snum:  proc(ms,ls,field,leading); /* output an unsigned number (0 to 4,294,967,295) */   dcl (ms,ls,i,r) fixed; /* ms, ls:  value to print */   dcl (field,go)  fixed; /* field:  field size */   dcl leading     fixed; /* leading character to print (0 means no leading character) */   dcl show_leading boolean; /* true to show leading character */   dcl #ms_divisors data (15258, 1525,  152,   15,    1,    0,   0,  0, 0,0); /* powers of ten */   dcl #ls_divisors data (51712,57600,38528,16960,34464,10000,1000,100,10,1);   show_leading = (leading <> 0);   if (ms = 0) and (ls = 0) then show_leading = false;   do i=1 to field-10; wchar(a.sp); end; /* print out any necessary leading spaces */   go=false; /* suppress leading zeroes */   do i=0 to 9; /* loop over 10 digits */      r=0; /* assume digit is zero */      do while ((ms IGT #ms_divisors(i)) /* must simulate unsigned 32-bit divide */         or ((ms=#ms_divisors (i)) and (ls IGE #ls_divisors (i))));         ms=ms-#ms_divisors(i);         if ls ilt #ls_divisors(i) then ms=ms-1;         ls=ls-#ls_divisors(i);         r=r+1;      end;      if r<>0 then do;         if (not go) and (show_leading) then wchar(leading); /* print leading character */         go=true; /* turn on printing */      end;      if (go) or (i=9)        then wchar(a.0+r); /* print digit */      else if field-((9+show_leading)-i) > 0 then wchar(a.sp); /* or print space */   end; /* of digits loop */end #snum;dcl SNUM lit 'call #snum';/* $subtitle Input Routines */GetNumStr: proc(str,strlen) returns (fixed); /* get a string of digits from the user */   dcl str    fixed array; /* array to return string in */   dcl strlen fixed; /* max no. characters in string */   dcl ch     fixed;   ch = 0; str(0) = 0; /* got nothing yet */   do while ((ch <> a.CR) and (ch <> a.refresh)); /* get string from user */      ch = rchar;      if ((ch = a.DEL) or (ch = a.BS)) and (str(0) <> 0) then do; /* delete character */         wchar(a.BS); wchar(a.SP); wchar(a.BS); /* remove it from the screen */         str(0) = str(0) - 1; /* remove if from the string */      end;      else if ( (ch = a.plus)  and (str(0) = 0) )  /* '+' */      or      ( (ch = a.minus) and (str(0) = 0) )  /* '-' */      or      ( (ch >= a.0) and (ch <= a.9) and (str(0) < strlen) ) then do; /* '0'..'9' */         wchar(ch); /* print this character */         call pbyte(str,str(0),ch); /* save this character */         str(0) = str(0) + 1;      end;   end;   return (ch); /* return ending character */end GetNumStr;ConvertNumStr: proc(str) returns (boolean); /* convert string to 32-bit number */   dcl str    fixed array; /* string to convert */   dcl index  fixed; /* index in string */   dcl (i,ch) fixed;   MS_NewSecs = 0; LS_NewSecs = 0; /* no number yet */   index = 0;   do while index < str(0); /* loop over all digits */      ch = byte(str,index); /* get character */      if (ch >= a.0) and (ch <= a.9) then do; /* scan in number */         msw = MS_NewSecs; lsw = LS_NewSecs;         do i = 1 to 9; /* multiply current 32-bit number by 10 */            MS_NewSecs = MS_NewSecs + msw;            LS_NewSecs = LS_NewSecs + lsw;            if LS_NewSecs ilt lsw then MS_NewSecs = MS_NewSecs + 1;         end;         ch = ch - a.0; /* convert to digit */         LS_NewSecs = LS_NewSecs + ch; /* add new digit to 32-bit number */         if LS_NewSecs ilt ch then MS_NewSecs = MS_NewSecs + 1;      end;      else if not ( ((ch = a.plus) or (ch = a.minus)) and (index = 0) ) then do; /* not a leading + or - */         return (false); /* die */      end;      index = index + 1;   end;   return (true); /* scanned successfully */end ConvertNumStr;/* $page */GetOption: proc(str) returns (fixed); /* get options from user */   dcl str    fixed array; /* option string */   dcl option fixed; /* option: 0 = quit, 1 = increase, 2 = decrease */   if str(0) = 0 then return (0); /* do nothing */   if not ConvertNumStr(str) then do; /* convert string into a number */      pstringr('Invalid size argument'); /* print error */      return (0); /* die */   end;   if      byte(str,0) = a.plus  then option = 1; /* increase catalog size */    else if byte(str,0) = a.minus then option = 2; /* decrease catalog size */   else do; /* find out if increase or decrease needed */      if (MS_NewSecs = Child(MS_Total)) and (LS_NewSecs = Child(LS_Total)) then do; /* same size */         option = 0; /* no size change */      end;      else if  (MS_NewSecs igt Child(MS_Total))           or ((MS_NewSecs  =  Child(MS_Total)) and (LS_NewSecs igt Child(LS_Total))) then do; /* make subcat larger */         option = 1; /* increase catalog size */         MS_NewSecs = MS_NewSecs - Child(MS_Total); /* calculate the amount to increase */         if LS_NewSecs ilt Child(LS_Total) then MS_NewSecs = MS_NewSecs - 1;         LS_NewSecs = LS_NewSecs - Child(LS_Total);      end;      else do; /* make subcat smaller */         option = 2; /* decrease catalog size */         MS_NewSecs = Child(MS_Total) - MS_NewSecs; /* calculate the amount to decrease */         if Child(LS_Total) ilt LS_NewSecs then MS_NewSecs = MS_NewSecs - 1;         LS_NewSecs = Child(LS_Total) - LS_NewSecs;      end;   end;   return (option); /* return option selected */end GetOption;/* $subtitle Outline Routines */PrintOutline:  proc; /* put up the screen template */   clear_screen;   pstring  ('R E S I Z E  Utility                         version of '); pstringr (rel.date);   crlf;   crlf;   pstringr ('Options:  +n    Increase subcatalog size by n sectors');   pstringr ('          -n    Decrease subcatalog size by n sectors');   pstringr ('           n    Set subcatalog size to n sectors');   crlf;   crlf;   pstringr ('Subcatalog:                             Current Size:');   pstringr ('---------------------------------------------------------------------------');   pstringr ('                                     |');   pstringr ('Increase Subcatalog Size             |  Decrease Subcatalog Size');   pstringr ('                                     |');              pstringr ('  Without moving                     |    Without shuffling');   pstringr ('     Maximum increase:               |       Maximum decrease:');   pstringr ('     Maximum size:                   |       Minimum size:');   pstringr ('                                     |');   pstringr ('  By moving                          |    By shuffling');   pstringr ('     Maximum increase:               |       Maximum decrease:');   pstringr ('     Maximum size:                   |       Minimum size:');   pstringr ('                                     |');   pstring  ('---------------------------------------------------------------------------');end PrintOutline;/* $page */PrintInfo: proc;   /* Header Info */   pos(8,12); pstring(cat_name); /* subcatalog name */   pos(8,54); snum(Child(MS_Total),Child(LS_Total),1,0); /* subcatalog size */   /* Increase Info */   pos(14,23); snum(Parent(MS_NoMove),Parent(LS_NoMove),10,a.plus); /* maximum increase w/o moving */   msw = Child(MS_Total) + Parent(MS_NoMove);   lsw = Child(LS_Total) + Parent(LS_NoMove);   if lsw ilt Child(LS_Total) then msw = msw + 1;   pos(15,23); snum(msw,lsw,10,0); /* maximum size w/o moving */   pos(18,23); snum(Parent(MS_Move),Parent(LS_Move),10,a.plus); /* maximum increase by moving */   msw = Child(MS_Total) + Parent(MS_Move);   lsw = Child(LS_Total) + Parent(LS_Move);   if lsw ilt Child(LS_Total) then msw = msw + 1;   pos(19,23); snum(msw,lsw,10,0); /* maximum size by moving */   /* Decrease Info */   pos(14,63); snum(Child(MS_NoShuf),Child(LS_NoShuf),10,a.minus); /* maximum decrease w/o shuffling */   pos(15,63); snum(Child(MS_Alloc),Child(LS_Alloc),10,0); /* minimum size w/o shuffling */   pos(18,63); snum(Child(MS_Shuf),Child(LS_Shuf),10,a.minus); /* maximum decrease by shuffling */   pos(19,63); snum(Child(MS_Used),Child(LS_Used),10,0); /* minimum size by shuffling */end PrintInfo;/* $subtitle Get Catalogs */Check_Child: proc(MS_Start,LS_Start) returns (boolean); /* returns TRUE if the given catalog is contained in the catalog to be resized */   dcl (MS_Start,LS_Start) fixed; /* start of catalog to check */   dcl (MS_End,LS_End)     fixed;   if  (C#MS_Sector ilt MS_Start) /* given catalog starts after this catalog start */   or ((C#MS_Sector  =  MS_Start) and (C#LS_Sector ilt LS_Start)) then do;      MS_End = C#MS_Sector + C#MS_Length;      LS_End = C#LS_Sector + C#LS_Length;      if LS_End ilt C#LS_Sector then MS_End = MS_End + 1;      if  (MS_Start ilt MS_End) /* given catalog starts before this catalog ends */      or ((MS_Start  =  MS_End) and (LS_Start ilt LS_End)) then do;         return (TRUE); /* so, catalog to resize is a parent of the given catalog */      end;   end;   return (FALSE); /* no problem */end Check_Child;Get_Catalogs: proc returns (boolean); /* get data on catalogs */   dcl i fixed;   dcl (MS_End,LS_End) fixed;   if child_name(0) = 0 then return (false); /* quit */   call cache_treename(TRUE); /* allow treename caching */   if locate(child_name,1) then do; /* look for file */      parent_cache = cache(addr(cache1(0)),0); /* cache this catalog */      if read_catalog(child_name,1) then do; /* read subcatalog */         child_cache = cache(addr(cache2(0)),0); /* cache this catalog */         do i = 0 to F#Name_Len; /* store subcatalog name */            cat_name(i) = F#Name(i);         end;         do i = 0 to shr(child_name(0) + 1,1); /* store parent name */            parent_name(i) = child_name(i);         end;         parent_name(0) = parent_name(0) - cat_name(0); /* subtract catalog name to get parent name */         if parent_name(0) igt 1 then do; /* parent catalog must have a real name of some sort, not just "" or ":" */            parent_name(0) = parent_name(0) - 1; /* get rid of possible colon */            if get_device(parent_name,FALSE) <> -1 /* parent is a device */            then parent_name(0) = parent_name(0) + 1; /* put colon back */         end;         ResizeParent = Check_Child(MS_CurSec,LS_CurSec); /* TRUE if a parent of the current catalog is being resized */         ResizeCurCat =  ( (C#MS_Sector = MS_CurSec ) and (C#LS_Sector = LS_CurSec) ); /* TRUE if current catalog is being resized */         ResizePathCat = ( ((C#MS_Sector = MS_PathSec) and (C#LS_Sector = LS_PathSec)) /* TRUE if path catalog is being resized */                         or (Check_Child(MS_PathSec,LS_PathSec))); /* or parent of path catalog is being resized */         return (true); /* success */      end; /* reading child catalog */   end; /* reading parent catalog */   call Cat_Error; /* print catalog error */   return (false); /* die */end Get_Catalogs;/* $subtitle Sort Catalog */Sort_Cat: proc(FCB_Index) returns (fixed); /* sort catalog buffer, return index of last entry */   dcl FCB_Index  fixed array; /* array of FCB indexes */   dcl Trailing   boolean; /* TRUE to clear trailing free blocks */   dcl Last_FCB   fixed; /* index of last FCB in catalog */   dcl Less       boolean; /* TRUE if fcb2 < fcb1 */   dcl Small      fixed; /* smallest index found so far */   dcl (i,j)      fixed;   /* scan catalog backwards from end until a non-null fcb entry is found */   Less = TRUE; /* entry not found yet */   Last_FCB = C#Dir_Size / C#Len; /* start at last entry in catalog */   do while (Last_FCB > 0) and (Less); /* search backwards for first non-null entry */      Last_FCB = Last_FCB - 1; /* next FCB */      call Get_FCB (Last_FCB, fcb1); /* Get this FCB */      Less = ((fcb1(F#ML) = 0) and (fcb1(F#LL) = 0)); /* TRUE when file length is null */   end;   if Less then Last_FCB = -1; /* all entries in catalog are null, so set flag */   do i = 0 to Last_FCB; /* prime FCB index table */      FCB_Index(i) = i;   end;   /* Selection Sort by FCB index pointers */   do i = 0 to Last_FCB; /* sort all known FCB's in catalog */      Small = i; /* assume FCB at index I is the smallest */      call Get_FCB(FCB_Index(Small),fcb1); /* get this FCB */      do j = i + 1 to Last_FCB; /* check the rest of the FCB's */         call Get_FCB(FCB_Index(j),fcb2); /* get FCB at index J */         Less = ( ( fcb2(F#MS) ilt fcb1(F#MS) ) or                  ((fcb2(F#MS)  =  fcb1(F#MS)) and (fcb2(F#LS) ilt fcb1(F#LS))) ); /* compare by sector origin */         if Less then do; /* new FCB is smaller than smallest FCB */            Small = j; /* save new smallest entry */            call BlockMove(fcb2,fcb1,F#Len); /* save smallest FCB */         end;      end; /* of inner sort for-loop */      j = FCB_Index(Small); /* swap fcb indexes */      FCB_Index(Small) = FCB_Index(i);      FCB_Index(i) = j;   end; /* of outer sort for-loop */   return (Last_FCB); /* return index of last non-null FCB */end Sort_Cat;Skip_Trailing: proc(Void); /* skip trailing free blocks and optionally clear them */   dcl Void boolean; /* TRUE to clear trailing free blocks from catalog */   dcl Null boolean; /* TRUE if FCB entry is null */   dcl i    fixed;   do i = 0 to F#Len - 1; fcb2(i) = 0; end; /* clear this fcb */   Null = TRUE; /* assume null entry found */   Last_FCB = Last_FCB + 1; /* start at last entry in catalog */   do while (Last_FCB > 0) and (Null); /* search backwards for first non-zero name */      Last_FCB = Last_FCB - 1; /* next FCB */      call Get_FCB (FCB_Index(Last_FCB), fcb1); /* Get this FCB */      Null = (fcb1(F#NM) = 0); /* TRUE when null name */      if (Null) and (Void) then call Put_FCB (FCB_Index(Last_FCB), fcb2); /* nuke this entry */   end;   if Null then Last_FCB = -1; /* all entries in catalog are null, so set flag */end Skip_Trailing;/* $subtitle Examine Subcatalog Information */Find_Alloc: proc(Info); /* find no. sectors used and allocated in this subcat */   dcl Info fixed array; /* array to return information in */   dcl i fixed;   Info(MS_Total) = C#MS_Length; Info(LS_Total) = C#LS_Length;   Info(MS_Used)  = 0; Info(LS_Used)  = shr(C#Dir_Size,8); /* start with space taken up by directory */   Info(MS_Alloc) = 0; Info(LS_Alloc) = Info(LS_Used);   do i = 0 to last_fcb; /* loop over valid fcbs */      call get_fcb(fcb_index(i),fcb1); /* get fcb */      if fcb1(F#NM) <> 0 then do; /* valid file name */         Info(MS_Used) = Info(MS_Used) + fcb1(F#ML); /* count up no. sectors used */         Info(LS_Used) = Info(LS_Used) + fcb1(F#LL);         if Info(LS_Used) ilt fcb1(F#LL) then Info(MS_Used) = Info(MS_Used) + 1;      end;      Info(MS_Alloc) = Info(MS_Alloc) + fcb1(F#ML); /* count up no. sectors allocated */      Info(LS_Alloc) = Info(LS_Alloc) + fcb1(F#LL);      if Info(LS_Alloc) ilt fcb1(F#LL) then Info(MS_Alloc) = Info(MS_Alloc) + 1;   end;end Find_Alloc;Examine_Catalogs: proc; /* examine catalogs and return needed data about them */   Get_Decrease_Info: proc; /* get information needed for decreasing */      if not read_catalog(child_name,1) then do; /* get child subcatalog into buffer */         pstringr('CHILD SUBCAT NOT FOUND'); call exit(-1);      end;      last_fcb = Sort_Cat(fcb_index); /* sort by origin */      call Skip_Trailing(true); /* skip and clear trailing free blocks */      call write_catalog; /* write this back out */      call Find_Alloc(Child); /* count up used sectors */      Child(MS_Shuf) = Child(MS_Total) - Child(MS_Used); /* subtract sectors used from total sectors */      if Child(LS_Total) ilt Child(LS_Used) then Child(MS_Shuf) = Child(MS_Shuf) - 1;      Child(LS_Shuf) = Child(LS_Total) - Child(LS_Used);      Child(MS_NoShuf) = Child(MS_Total) - Child(MS_Alloc); /* subtract sectors Alloc from total sectors */      if Child(LS_Total) ilt Child(LS_Alloc) then Child(MS_NoShuf) = Child(MS_NoShuf) - 1;      Child(LS_NoShuf) = Child(LS_Total) - Child(LS_Alloc);   end Get_Decrease_Info;   Limit_Increase: proc(Info,MS_Index,LS_Index); /* limit max catalog size to 2^20 - 1 sectors */      dcl Info fixed array; /* subcatalog information array */      dcl (MS_Index,LS_Index) fixed; /* value in info array to check */      msw = Child(MS_Total) + Info(MS_Index); /* calculate new size of subcatalog */      lsw = Child(LS_Total) + Info(LS_Index);      if lsw ilt Child(LS_Total) then msw = msw + 1;      /* if new sector total is greater than 2^20 - 1, this increase must be truncated */      if msw ige "H10" then do;         Info(MS_Index) = "HF" - Child(MS_Total); /* new increase = (2^20 - 1) - (subcat size) */         if "HFFFF" ilt Child(LS_Total) then Info(MS_Index) = Info(MS_Index) - 1; /* sectors allowed = 2^24 - sectors used */         Info(LS_Index) = "HFFFF" - Child(LS_Total);      end;   end Limit_Increase;   /* $page */   Get_Increase_Info: proc; /* get information needed for increasing */      dcl (i,p)   fixed;      if not read_catalog(parent_name,1) then do; /* get parent subcatalog */         pstringr('PARENT SUBCAT NOT FOUND'); call exit(-1);      end;      Parent(MS_Move) = 0; /* assume subcat cannot be moved */      Parent(LS_Move) = 0;      if findmax then do; /* consolidate catalog and find largest hole */         if  (F#MS_Length igt Child(MS_Total)) /* is largest hole greater than size of subcat */         or ((F#MS_Length  =  Child(MS_Total)) and (F#LS_Length igt Child(LS_Total))) then do;            Parent(MS_Move) = F#MS_Length - Child(MS_Total); /* subtract subcat size from hole size */            if F#LS_Length ilt Child(LS_Total) then Parent(MS_Move) = Parent(MS_Move) - 1;            Parent(LS_Move) = F#LS_Length - Child(LS_Total);            call Limit_Increase(Parent,MS_Move,LS_Move); /* limit size of increase */         end;      end;      p = findfile(cat_name); /* search for given subcatalog */      if p = -1 then do; pstringr('SUBCAT NOT FOUND'); call exit(-1); end;      last_fcb = Sort_Cat(fcb_index); /* sort by origin */      call Skip_Trailing(false); /* skip trailing free blocks */      call Find_Alloc(Parent); /* count up used sectors */      i = 0;      do while (i < last_fcb) and (fcb_index(i) <> p); /* search for this fcb in sorted index array */         i = i + 1;      end;      if fcb_index(i) <> p then do; pstringr('INDEX NOT FOUND!'); call exit(-1); end; /* this should not happen */      if i = last_fcb then do; /* nothing after this file, so subcat can increased the remaining sectors without moving */         Parent(MS_NoMove) = Parent(MS_Total) - Parent(MS_Alloc); /* subtract sectors used from total sectors */         if Parent(LS_Total) ilt Parent(LS_Alloc) then Parent(MS_NoMove) = Parent(MS_NoMove) - 1;         Parent(LS_NoMove) = Parent(LS_Total) - Parent(LS_Alloc);      end;      else do; /* not the last entry */         call get_fcb(fcb_index(i + 1),fcb1); /* look at next entry */         if fcb1(F#NM) = 0 then do; /* free block? */            Parent(MS_NoMove) = fcb1(F#ML); /* subcat can be increased the length of this free block without moving */            Parent(LS_NoMove) = fcb1(F#LL);         end;         else do; /* a file is right after this subcat, so subcat cannot be increased without moving */            Parent(MS_NoMove) = 0;            Parent(LS_NoMove) = 0;         end;      end;      call Limit_Increase(Parent,MS_NoMove,LS_NoMove); /* limit size of increase */   end Get_Increase_Info;   /* Main procedure */   call Get_Decrease_Info; /* MUST call this before Get_Increase_Info */   call Get_Increase_Info;end Examine_Catalogs;/* $subtitle Move File */MoveFile: proc(MS_CatSec,LS_CatSec,MS_Source,LS_Source,MS_Dest,LS_Dest,MS_Total,LS_Total) returns (boolean); /* move file */   dcl (MS_CatSec,LS_CatSec) fixed; /* first sector of catalog */   dcl (MS_Source,LS_Source) fixed; /* first sector of source file in catalog */   dcl (MS_Dest,LS_Dest)     fixed; /* first sector of destination file in catalog */   dcl (MS_Total,LS_Total)   fixed; /* total no. sectors to transfer */   dcl (MS_Moved,LS_Moved)   fixed; /* no. sectors transferred so far */   dcl chunk                 fixed; /* sector chunk of file */   dcl freestart             fixed; /* first word of free memory */   dcl freestop              fixed; /* last word of free memory */   dcl BufSecSize            fixed; /* size of free memory in sectors */   dcl AllowBreak            boolean; /* TRUE to allow user to break out */   freestart = core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen); /* calc first word of free memory */   freestop  = loc.load - 1; /* calc last word of free memory */   BufSecSize = shr(freestop - freestart + 1,8); /* find size of buffer in sectors */   AllowBreak = TRUE; /* assume break will be allowed */   if (MS_Dest ilt MS_Source) or ((MS_Dest = MS_Source) and (LS_Dest ilt LS_Source)) then do; /* destination is before source on disk */      msw = MS_Dest + MS_Total; /* calculate last sector of destination + 1 */      lsw = LS_Dest + LS_Total;      if lsw ilt LS_Dest then msw = msw + 1;      if (msw igt MS_Source) or ((msw = MS_Source) and (lsw igt LS_Source)) /* destination overlaps source */      then AllowBreak = FALSE; /* do not let user break out */   end;   MS_Source = MS_CatSec + MS_Source; /* compute actual first sector of source */   LS_Source = LS_CatSec + LS_Source;   if LS_Source ilt LS_CatSec then MS_Source = MS_Source + 1;   MS_Dest = MS_CatSec + MS_Dest; /* compute actual first sector of destination */   LS_Dest = LS_CatSec + LS_Dest;   if LS_Dest ilt LS_CatSec then MS_Dest = MS_Dest + 1;   MS_Moved = 0; LS_Moved = 0; /* no sectors moved yet */   do while (MS_Moved ilt MS_Total) or ((MS_Moved = MS_Total) and (LS_Moved ilt LS_Total)); /* repeat until file is transferred */      msw = MS_Total - MS_Moved; /* find amount left to transfer */      if LS_Total ilt LS_Moved then msw = msw - 1;      lsw = LS_Total - LS_Moved;      if msw <> 0 /* more than 64k sectors to move */      then chunk = 65535; /* set to 64K */      else chunk = lsw; /* set to amount left to move */      if chunk igt BufSecSize then chunk = BufSecSize; /* limit to size of buffer */      call readdata(MS_Source,LS_Source,location(freestart),shl(chunk,8)); /* get buffer full */      LS_Source = LS_Source + chunk; /* update starting sector */      if LS_Source ilt chunk then MS_Source = MS_Source + 1;      call writedata(MS_Dest,LS_Dest,location(freestart),shl(chunk,8)); /* write this buffer */      LS_Dest = LS_Dest + chunk; /* update starting sector */      if LS_Dest ilt chunk then MS_Dest = MS_Dest + 1;      LS_Moved = LS_Moved + chunk; /* count sectors moved */      if LS_Moved ilt chunk then MS_Moved = MS_Moved + 1;      if AllowBreak then do; /* user can break out */         ckread;         if peek <> -1 then do; /* key struck */            if rchar = 0 then return (false); /* quit if they hit break */         end;      end;   end;   return (true); /* transfer completed */end MoveFile;/* $subtitle Increase Catalog Size */Increase_Cat: proc returns (boolean); /* increase the size of this catalog */   dcl p         fixed;   if (MS_NewSecs = 0) and (LS_NewSecs = 0) then return (false); /* do nothing */   if not read_catalog(parent_name,1) then do; /* read in parent subcatalog */      pstringr('PARENT SUBCAT NOT FOUND'); call exit(-1);   end;   p = findfile(cat_name); /* look for specified name */   if p = -1 then do; pstringr('SUBCAT NOT FOUND'); return (false); end;   call get_fcb(p,fcb1); /* get fcb */   MS_NewSize = fcb1(F#ML) + MS_NewSecs; /* calculate new length */   LS_NewSize = fcb1(F#LL) + LS_NewSecs;   if LS_NewSize ilt LS_NewSecs then MS_NewSize = MS_NewSize + 1;   if MS_NewSize ige "20" then do; /* new length is greater than 2~20 - 1 sectors */      pstringr('Subcatalog cannot be made larger than 1,048,575 sectors');      return (false); /* die */   end;   if addfile(cat_name,fcb1(F#TY),MS_NewSize,LS_NewSize,shl(LS_NewSize,8)) then do; /* file could be added */      p = findfile(cat_name); /* look for file */      call get_fcb(p,fcb2); /* get fcb */      if not ( (fcb1(F#MS) = fcb2(F#MS)) and (fcb1(F#LS) = fcb2(F#LS)) ) then do; /* origin changed, so move file */         if ResizeParent then do; /* cannot move this, or current catalog would get lost */            pstringr('This subcatalog cannot be moved because it contains the current catalog.');            pstringr('Please enter the top level of this device and try again.');            return (false);         end;         else do; /* OK to move */            pstring('Moving subcatalog - please wait...');            if MoveFile(C#MS_Sector,C#LS_Sector,fcb1(F#MS),fcb1(F#LS),fcb2(F#MS),fcb2(F#LS),Child(MS_Alloc),Child(LS_Alloc)) /* move file */            then pstringr('Done'); /* move was successful */            else do; /* user hit break key */               pstringr('Aborted');               return (false); /* quit */            end;         end;      end;      else ResizePathCat = false; /* path catalog did not move */      call disable_cache(parent_cache); /* disable this cache */      if write_catalog /* write out this catalog */      then return (true); /* success */   end; /* adding file */   call Cat_Error; /* print catalog error */   return (false); /* failed */end Increase_Cat;/* $subtitle Decrease Catalog Size */Decrease_Cat: proc returns (boolean); /* decrease the size of this catalog by the given no. sectors */   dcl found boolean; /* TRUE if free block found */   dcl (f,p) fixed;   if (MS_NewSecs = 0) and (LS_NewSecs = 0) then return (false); /* do nothing */   if  (MS_NewSecs igt Child(MS_NoShuf))   or ((MS_NewSecs  =  Child(MS_NoShuf)) and (LS_NewSecs igt Child(LS_NoShuf))) then do; /* decrease too large */      pstring('Subcatalog cannot be made smaller than ');      snum(Child(MS_Alloc),Child(LS_Alloc),1,0); pstringr(' sectors');      return (false); /* die */   end;   if not read_catalog(parent_name,1) then do; /* read parent subcatalog */      pstringr('PARENT SUBCAT NOT FOUND'); call exit(-1);   end;   call findmax; /* consolidate the catalog */   f = 0; found = false; /* entry not found yet */   do while (f < C#Dir_Size / C#Len) and (not found); /* search for a free catalog entry */      call get_fcb(f,fcb2); /* get fcb */      if (fcb2(f#nm) = 0) and (fcb2(f#ml) = 0) and (fcb2(f#ll) = 0) /* found a free catalog entry */      then found = true; /* found it */      else f = f + 1; /* look at next entry */    end;   if not found then do; /* free block not found */      pstringr('There are no free blocks available in parent subcatalog');      return (false);   end;   p = findfile(cat_name); /* look for specified name */   if p = -1 then do; pstringr('SUBCAT NOT FOUND'); return (false); end;   call get_fcb(p,fcb1); /* get fcb */         MS_NewSize = fcb1(F#ML) - MS_NewSecs; /* calculate new length */   if fcb1(F#LL) ilt LS_NewSecs then MS_NewSize = MS_NewSize - 1;   LS_NewSize = fcb1(F#LL) - LS_NewSecs;   /* Set up FCB2 to mark space to be freed up */   fcb2(f#ms) = fcb1(f#ms) + MS_NewSize; /* set sector start of free block */   fcb2(f#ls) = fcb1(f#ls) + LS_NewSize; /* start = start of subcat + new length of subcat */   if fcb2(f#ls) ILT LS_NewSize then fcb2(f#ms) = fcb2(f#ms) + 1;   fcb2(f#ml) = MS_NewSecs; /* set sector length of free block */   fcb2(f#ll) = LS_NewSecs; /* length = no. sectors subtracted above */   fcb2(f#wd) = shl(fcb2(f#ll),8); /* set word length of free block */   /* Set up FCB1 to reflect new length of subcat */   fcb1(f#ml) = MS_NewSize; /* set sector length of subcat */   fcb1(f#ll) = LS_NewSize;   fcb1(f#wd) = shl(fcb1(f#ll),8); /* set word length of subcat */   /* Store these fcbs back where they came from */   call put_fcb(p,fcb1);   call put_fcb(f,fcb2);   if flush_cache(child_cache) then do; /* save subcat catalog to disk (erases trailing free blocks) */      call disable_cache(parent_cache); /* disable caching */      if write_catalog then return (true); /* save current catalog to disk */   end;   call Cat_Error; /* print out error */   return (false); /* died */end Decrease_Cat;/* $subtitle Main Program */dcl arg_str(arg_max / 2)  fixed; /* string for argument */dcl catbuf(C#Dir_Max - 1) fixed; /* space for catalog buffer */dcl printed boolean; /* TRUE if outline has been printed */dcl choice  fixed;/* Main Program */call set_catbuf(addr(catbuf(0)),0);call Setup_Args (child_name); /* set up for argument scanning */call Next_Arg(child_name); /* get treename of subcatalog to resize */call Next_Arg(arg_str); /* get new size argument */printed = FALSE; /* outline has not been printed yet */if child_name(0) = 0 then do; /* no file name given */   call PrintOutline; printed = TRUE; /* print outline */   pcmd('Enter name of subcatalog to resize or <RETURN> to quit: ');   get_string('',TRUE,child_name,treename_max); crlf; /* get file name */end;if Get_Catalogs then do; /* read in parent and child subcatalogs */   call Examine_Catalogs; /* get statistics about these catalogs */   choice = a.refresh; /* get into loop */   if arg_str(0) = 0 /* no size given */   then do while (choice = a.refresh); /* ask for size */      if not printed then call PrintOutline; /* print outline if needed */      call PrintInfo; /* print subcatalog size information */      pcmd('Enter amount of increase or decrease, new size, or <RETURN> to quit: ');      choice = GetNumStr(arg_str,8); crlf; /* get numeric argument from user */      printed = false; /* not printed if we need to loop */   end;   choice = GetOption(arg_str); /* find option to perform, based on argument given */   if choice = 1 then do; /* make subcatalog larger */      if not Increase_Cat then choice = 0; /* could not increase subcat */   end;   else if choice = 2 then do; /* make subcatalog smaller */      if not Decrease_Cat then choice = 0; /* could not decrease subcat */   end;   if choice = 0 then do; /* do nothing */      pstringr('Subcatalog size was not changed');   end;   else do; /* subcatalog resized */      pstring('Subcatalog '); pstring(cat_name);      if choice = 1 then pstring(' in'); else pstring(' de');      pstring('creased by '); snum(MS_NewSecs,LS_NewSecs,0,0); pstringr(' sectors');      pstring('New size is '); snum(MS_NewSize,LS_NewSize,0,0); pstringr(' sectors');      if ResizeCurCat then do; /* current catalog resized, so enter it */         call disable_cache(Parent_Cache); /* turn off all caching */         call disable_cache(Child_Cache);         call cache_treename(FALSE);         if Enter_Catalog(Child_Name,1) then do; /* try to enter it */            if locate ('.current', 1) then do; /* look for .CURRENT (in case it's moved) */               core(loc.csec + 1) = f#ms_sector; /* save its location */               core(loc.csec)     = f#ls_sector;            end; /* of look for .CURRENT */         end;         else core(loc.magic) = 0; /* enter failed, so reboot */      end;      else if ResizePathCat then core(loc.magic) = 0; /* reboot to initialize path catalog */   end; /* of subcatalog resized */end; /* of reading in parent and child subcatalogs */