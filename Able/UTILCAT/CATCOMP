/* CATCOMP  $title Catalog Compare Utility *//* This program compares the contents of two files and prints the results.  to the screen.  The program is designed for text files, but it will.  also compare binary files...  By:  Karim J. Chichakly on 24 November 1986..  Modified:   05/01/89 - MWH - Speed up, -q, command line arguments, ? help*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* get general literals */insert ':-xpl:asciilit'; /* get ASCII literals */insert ':-xpl:catrtns'; /* catalog routines */insert ':-xpl:fileio'; /* get buffered file I/O */insert ':-xpl:termut'; /* terminal utilities */insert ':-xpl:catutil'; /* catalog utilities */insert ':-xpl:strings'; /* string processing */insert ':-xpl:scanargs'; /* command line argument processing */dcl treename_len  lit '24';     /* treename buffer size */dcl buf_len       lit '5120';   /* fileio cache size    */dcl read_len      lit '256';    /* words to read        */when break then call exit (0); /* let them out on BREAK *//* $subtitle Main Program:  Compare Two Catalogs */dcl old_name  (treename_len)  fixed; /* name of old catalog */dcl new_name  (treename_len)  fixed; /* name of new catalog */dcl treename  (treename_len)  fixed; /* buffer to construct file's treename */dcl oname     (f#name_len)    fixed; /* name of next file in old catalog */dcl nname     (f#name_len)    fixed; /* name of next file in new catalog */dcl old_cache (c#dir_max - 1) fixed; /* old catalog's cache */dcl new_cache (c#dir_max - 1) fixed; /* new catalog's cache */dcl old_buf   (buf_len - 1)   fixed; /* fileio cache        */dcl new_buf   (buf_len - 1)   fixed; /* fileio cache        */dcl old_cbuf  (read_len - 1)  fixed; /* read into here      */dcl new_cbuf  (read_len - 1)  fixed; /* read into here      */dcl old_fcb   (f#len - 1)     fixed; /* FCB from old catalog */dcl new_fcb   (f#len - 1)     fixed; /* FCB from new catalog */dcl (old, new)  file; /* two files to compare */dcl (o, n)      fixed; /* pointers to current entry in old and new catalogs */dcl old_entries fixed; /* number of entries in old catalog */dcl new_entries fixed; /* number of entries in new catalog */dcl redirect    fixed; /* current redirection */dcl progname (64) fixed; /* program name */dcl arg (64)    fixed; /* command line args parsed into here */dcl quick       fixed; /* 0=normal, 1=quick: don't compare if same byte length */dcl (i, j)      fixed;dcl any_diff    fixed; /* 0 initially, set to 1 if ANY differences found ever */dcl different   fixed;quick = 0;                  /* assume we're not in quick mode */any_diff = 0;redirect = directed_output; /* save specified output device */redirection_word = no_redirection; /* temporarily turn off redirection */call setup_args(progname);   /* Get command name and set up to parse args */call next_arg(arg);          /* Get first command line argument */if strcmp(arg,'?') = 0 then do;   print 'CATCOMP compares the files in two catalogs, showing any differences.';   print;   print 'Usage: "CATCOMP catalog1 catalog2"    OR';   print '       "CATCOMP -q catalog1 catalog2"';   print;   print 'If -q is specified, it will compare "quickly", presuming that files';   print 'with the same byte length are identical.  The default is to compare';   print 'every file byte for byte before declaring they are the same.';   call exit(0);end;pstring ('Catalog Compare Utility - '); pstringr (rel.date);call cache_treename (true); /* cache any treename */call lower(arg);if strcmp(arg,'-q') = 0 then do;      /* Do a quick compare */   quick = 1;   call next_arg(arg);   call lower(arg);end;if strlen(arg) = 0 then do;           /* There must be a catalog name */   crlf;   get_string ('Old catalog: ', 0, old_name, shl(treename_len, 1)); crlf;   if old_name (0) = 0 then call exit (0);end;else do;   call strcpy(old_name,arg);       /* Save name of first catalog */   call next_arg(arg);              /* Fetch the next argument */   call lower(arg);end;if not enter_alternate (old_name, 1) then do; /* can't read the catalog - probably missing */   pstring ('Catalog "'); pstring (old_name); pstringr ('" not found.');   call exit (-1);end;call sort_catalog; /* sort the catalog */call cache (addr(old_cache (0)), 0); /* and cache it */old_entries = c#dir_size/c#len; /* determine number of entries in catalog */if strlen(arg) = 0 then do;           /* There must be a catalog name */   get_string ('New catalog: ', 0, new_name, shl(treename_len, 1)); crlf;   if new_name (0) = 0 then call exit (0);end;else do;   call strcpy(new_name,arg);       /* Save name of second catalog */end;if not read_catalog (new_name, 1) then do; /* can't read the catalog - probably missing */   pstring ('Catalog "'); pstring (new_name); pstringr ('" not found.');   call exit (-1);end;call sort_catalog; /* sort the catalog */call cache (addr(new_cache (0)), 0); /* and cache it */new_entries = c#dir_size/c#len; /* determine number of entries in catalog */if quick <> 0 thenpstring ('Warning: In QUICK mode; assuming files with identical length are the same.'); crlf;redirection_word = redirect; /* redirect according to user's wishes */if redirect <> no_redirection then do; /* if output was redirected to printer */   crlf; crlf;   pstring ('Old catalog:  '); pstring (old_name);   pstring ('                       New catalog:  '); pstringr (new_name);   crlf; crlf;end;o = 0; n = 0; /* point to first entry in each */do while ((o < old_entries) and (n < new_entries)); /* keep checking until either runs out of entries */   call read_catalog ('', -1); /* get old catalog */   call get_fcb (o, old_fcb); /* get next FCB */   call read_catalog (new_name, 1); /* get new catalog */   call get_fcb (n, new_fcb); /* and get next FCB */   if old_fcb (f#nm) = 0 /* if no more files in old catalog */   then o = old_entries; /* get out */   else if new_fcb (f#nm) = 0 /* if no more files in new catalog */   then n = new_entries; /* get out */   else do; /* check files */      call clean_fcbname (old_fcb, oname); /* clean up filenames */      call clean_fcbname (new_fcb, nname);      i = strcmp (oname, nname); /* compare the names */      if i = 0 then do; /* same filename */         if ((old_fcb (f#ml) = new_fcb (f#ml)) /* check lengths */         and (old_fcb (f#ll) = new_fcb (f#ll))         and (old_fcb (f#wd) = new_fcb (f#wd))) then do; /* if equal, must compare word by word */            if quick = 0 then do;      /* not quick mode; compare byte for byte */               call strcpy (treename, old_name); /* construct treename */               if byte(treename, treename (0) - 1) <> a.colon /* if doesn't end with colon already */               then call strcat (treename, ':');               call strcat (treename, oname);               old = fopen (treename, 'r'); /* open old file */               call setbuf (old, addr(old_buf(0)), 0, buf_len);   /* set up cache for speed */               call strcpy (treename, new_name); /* construct treename */               if byte(treename, treename (0) - 1) <> a.colon /* if doesn't end with colon already */               then call strcat (treename, ':');               call strcat (treename, nname);               new = fopen (treename, 'r'); /* open new file */               call setbuf (new, addr(new_buf(0)), 0, buf_len);   /* set up cache for speed */               different = 0;               do while ((different = 0) and (not feof (old))); /* compare the files */                  i = fread(old_cbuf,2,read_len,old);                  j = fread(new_cbuf,2,read_len,new);                  if i <> j then different = 1;                  else do i = 0 to (j-1);                     if old_cbuf(i) <> new_cbuf(i)                     then different = 1;                  end;                  if not term_idle then do; /* see if terminal input */                     if rchar = 0 then call exit (0); /* exit on BREAK */                     else do; /* print status */                        pstring ('*** comparing '); pstringr (oname);                     end;                  end; /* of terminal input */               end;               if different <> 0 then do; /* files different */                  pstring (oname); pstringr (' is different.');                  any_diff = 1;               end;               call fclose (old); /* close the files */               call fclose (new);            end;   /* of not quick mode */         end;      /* of must compare files word by word */         else do; /* lengths different, therefore files different */            pstring (oname); pstringr (' is different.');            any_diff = 1;         end;         o = o + 1; /* look at next entry */         n = n + 1;      end; /* of same filename */      else if i < 0 then do; /* file in OLD does not appear in NEW */         pstring (oname); pstring (' not found in "'); pstring (new_name); pstringr ('".');         o = o + 1; /* look at next entry */         any_diff = 1;      end;      else do; /* file in NEW does not appear in OLD */         pstring (nname); pstring (' not found in "'); pstring (old_name); pstringr ('".');         n = n + 1; /* look at next entry */         any_diff = 1;      end;   end; /* of checking files */end; /* of until either runs out */do while (o < old_entries); /* print out any remaining in old catalog */   call read_catalog ('', -1); /* get old catalog */   call get_fcb (o, old_fcb); /* get next FCB */   if old_fcb (f#nm) = 0 /* if no more files in old catalog */   then o = old_entries; /* get out */   else do; /* more files */      call clean_fcbname (old_fcb, oname); /* clean up filename */      pstring (oname); pstring (' not found in "'); pstring (new_name); pstringr ('".');      o = o + 1; /* look at next entry */      any_diff = 1;   end;end; /* of printing any remaining in old catalog */do while (n < new_entries); /* print out any remaining in new catalog */   call read_catalog (new_name, 1); /* get new catalog */   call get_fcb (n, new_fcb); /* get next FCB */   if new_fcb (f#nm) = 0 /* if no more files in new catalog */   then n = new_entries; /* get out */   else do; /* more files */      call clean_fcbname (new_fcb, nname); /* clean up filename */      pstring (nname); pstring (' not found in "'); pstring (old_name); pstringr ('".');      n = n + 1; /* look at next entry */      any_diff = 1;   end;end; /* of printing any remaining in old catalog */if any_diff = 0    /* if absolutely NO differences were found */then do;   pstringr ('No differences found.');end;if redirect <> no_redirection /* if output was redirected to printer */then wchar (a.ff); /* end with formfeed */flush_term; /* and flush the terminal's buffer before leaving */if systyp = 0 then do; /* make sure there's a system disk on floppy systems */   redirection_word = no_redirection; /* don't redirect this message */   pstring ('Insert a SYSTEM disk into '); call name (2); pstring (' and press RETURN ->');   clear_typeahead; call rchar;end;