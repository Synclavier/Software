/* $subtitle Fast String Search *//* This procedure does a VERY fast search for a pattern in a string..  It assumes both the pattern and string are chiefly alphabetic.  and that characters are not generally repeated in either.  It.  still works if these conditions aren't met; it just isn't as.  fast.  It is based on Boyer and Moore's mismatched character.  algorithm.  If CASE is TRUE, it is assumed the pattern has been.  uppercased by the same algorithm used here...  By:  Karim J. Chichakly on 25 April 1986 */dcl skip (255) fixed; /* source skip amounts */create_skip: proc(pattern, pat_word); /* set up SKIP array for pattern */   dcl pattern  fixed array; /* pattern to search for */   dcl pat_word fixed array; /* word aligned/upcased pattern */   dcl i        fixed; /* byte counter for PATTERN */   do i = 0 to 255; /* initialize SKIP */      skip (i) = pattern (0); /* we can skip the whole pattern length in most cases */   end;   do i = 0 to pattern (0) - 1; /* now add pattern characters */      pat_word (i) = (byte(pattern, i) and "137"); /* uppercase next character from string */      skip (pat_word (i)) = pattern (0) - i - 1; /* we can skip this much if this character fails */   end; /* of adding pattern characters */end create_skip;speed_search: proc(string, pattern, plen) returns (fixed); /* find PATTERN in STRING */   dcl string  fixed array; /* string to search */   dcl pattern fixed array; /* pattern to search for (word aligned) */   dcl plen    fixed; /* length of pattern */   dcl c       fixed; /* current string character */   dcl (i, j)  fixed; /* byte counters for STRING and PATTERN, respectively */   if string (0) ilt plen /* any chance? */   then return (0); /* no */   j = plen - 1; /* start searching from right side of pattern */   i = j;   c = string (0) + pattern (0); /* point to all vars */   do while ((j >= 0) and (i ilt string (0))); /* scan the entire string */      c = (byte(string, i) and "137"); /* uppercase next character from string */      if c = pattern (j) then do; /* do the characters match? */         i = i - 1; /* proceed from right to left */         j = j - 1;      end;      else do; /* no match - skip ahead */         if skip (c) > plen - j /* see how far we can skip */         then c = skip (c); /* as far as the pattern allows */         else c = plen - j; /* only as far as what we've already checked */         i = i + c; /* skip ahead */         j = plen - 1; /* start searching again */      end;   end; /* of scanning string */   if i ilt string (0) /* if we found it */   then return (1); /* return pointer */   else return (0); /* not there */end speed_search;insert ':-xpl:literals'; /* get literals */insert ':-xpl:asciilit'; /* get ASCII literals */insert ':-xpl:catrtns'; /* get catalog routines */insert ':-xpl:termutil'; /* terminal utilities */insert ':-xpl:catutil'; /* catalog utilities */insert ':-xpl:strings'; /* string processing */insert ':-xpl:scanargs'; /* scan command line arguments */insert ':utilcat:getfiles'; /* get tree climber */dcl pat_max lit '128'; /* only 128 characters allowed in pattern */dcl (cat_ms, cat_ls) fixed; /* address of last catalog that had a match */cat_ms = -1; cat_ls = -1; /* force display of first name */display: proc(treename, name); /* display indented name */   dcl treename  fixed array; /* treename to display */   dcl name      fixed array; /* name to display (last portion of treename) */   dcl indent    fixed static; /* indent levels */   dcl num_files fixed static; /* number of files output on THIS line */   dcl i         fixed;   dcl name_field lit '(shl(f#name_len, 1) + 2)'; /* number of characters in name field */   if not (((c#ms_sector = cat_ms) and (c#ls_sector = cat_ls))) then do; /* if new catalog */      cat_ms = c#ms_sector; cat_ls = c#ls_sector; /* store which catalog matched */      crlf;      indent = 0; num_files = 0; /* assume no indentation */      if treename (0) <> 0 then do; /* no header at top level */         crlf;         do i = 0 to treename (0) - 1; /* find colons in path */            if byte(treename, i) = a.colon then indent = indent + 1;         end;         do i = 1 to indent; /* indent an appropriate amount */            pstring ('   ');         end;         pstring (treename); /* output treename */      end; /* of no header */   end; /* of new catalog */   if num_files = 0 then do; /* need to start a new line */      crlf;      if treename (0) <> 0 /* if not at top level */      then do i = 0 to indent; /* indent the correct amount */         pstring ('   ');      end;   end; /* of new line */   pstring (name);   do i = name (0) + 1 to name_field; /* pad with spaces */      wchar (a.sp);   end;   num_files = num_files + 1; /* one more */   if indent*3 + (num_files + 1)*name_field >= 80 then num_files = 0; /* start again next time */end display;/* This procedure gets the pattern and list of files to search from.  the user.  It returns the length of the pattern. */get_pattern: proc(pattern, files) returns (fixed); /* get pattern from user */   dcl pattern  fixed array; /* pattern from user */   dcl files    fixed array; /* file list (maybe from user) */   dcl list_pos fixed; /* position of file list in command line */   call strcpy (files, '*'); /* default to search all files */   call setup_args (pattern); /* don't care about program name or if it's a RUN */   call strtok (pattern, ''); /* get entire argument list into PATTERN */   if pattern (0) <> 0 then do; /* if we grabbed a pattern from the command line */      list_pos = index (pattern, ' -f', 0); /* look for a file list */      if list_pos = -1 then list_pos = index (pattern, ' -F', 0); /* uppercase is also allowed */      if list_pos <> -1 then do; /* file list given */         call strncpy (files, pattern, list_pos + 3, pattern (0) - 1); /* pull off filenames */         pattern (0) = list_pos; /* set actual length of string to compare */      end; /* of file list given */      if pattern (0) <> 0 /* if pattern given */      then call strncpy (pattern, pattern, 1, pattern (0) - 1); /* get rid of initial space */   end; /* of grabbing a pattern from the command line */   if pattern (0) = 0 then do; /* if we don't have a pattern yet */      get_string ('Pattern to search for -> ', 0, pattern, pat_max); crlf;   end;   return (pattern (0)); /* return length of pattern */end get_pattern;dcl fname (treemax/2)      fixed; /* file name of file to be searched */dcl catbuf (c#dir_max - 1) fixed; /* catalog buffer */dcl pattern (pat_max - 1)  fixed; /* pattern to search for */dcl files (pat_max/2)      fixed; /* file list to search */dcl exclusive boolean; /* TRUE to show files that don't match */dcl bufptr  fixed; /* pointer to buffer */dcl bufmax  fixed; /* size of buffer */dcl plen    fixed; /* length of pattern */dcl matches fixed; /* number of files that had a match *//* This procedure searches a file for a given string. */find: proc(fname, buffer, buflen); /* find a string in a file */   dcl fname  fixed array; /* name of file to search */   dcl buffer fixed array; /* buffer to use for search */   dcl buflen fixed; /* length of buffer */   call locate (fname, 1); /* find the file */   if ((f#type = t#text) and (f#ms_length = 0) and (f#ls_length < 256)   and (byte(f#name, 0) <> a.period)) then do; /* okay text file (ignore system files) */      if not term_idle then do; /* if any terminal activity */         if rchar = 0 then do; flush_term; call exit (0); end; /* get out */         else do; pstring ('*** Searching '); pstringr (fname); end;      end;      if f#words ilt buflen then do; /* enough memory */         call readdata (f#ms_sector, f#ls_sector, loc(addr(buffer (1))), f#words); /* read it in! */         buffer (0) = shl(f#words, 1); /* set string length */         if (speed_search (buffer, pattern, plen) xor exclusive) <> 0 then do; /* if a match */            call display (treename, f#name);            matches = matches + 1; /* found one more */         end;      end; /* of enough memory */      else do; end; /* ######not enough memory */   end; /* of okay text file */end find;call set_catbuf (addr(catbuf (0)), 0); /* set catalog buffer */bufptr = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* point to heap */bufmax = loc.load - bufptr - 1; /* size of buffer (minus one so can save length) */if bufmax ige 32768 then bufmax = 32767; /* limit buffer size */plen = get_pattern (loc(bufptr), files); /* get pattern and save its length */clear_screen;pstring ('Searching for "'); pstring (loc(bufptr));pstring ('" on '); call name (1);call create_skip (loc(bufptr), pattern); /* create skip list */call start_search (files, true, 1); /* initialize for catalog searching */matches = 0; /* no matches yet */do while (getfname (fname)); /* loop over all files found */   call find (fname, loc(bufptr), bufmax); /* go find it */end; /* of loop over all files found */crlf; crlf;if matches = 0 /* if no files matched */then pstring ('No');else unum (matches, 0);pstring (' file');if matches <> 1 then wchar (l.s); /* plural please */pstringr (' found with match.');flush_term;