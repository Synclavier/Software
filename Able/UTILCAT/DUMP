/* $title Dump Utility *//* Produces interpreted dump of XPL programs Modification history:   Aug/Sep 82:  Major improvements [JSR]    17 Dec 84:  Updated for -6 configuration and Model C processor [KJC]    18 Dec 84:  Added WHEN table, Interrupt handler, and Swap table output [KJC]    16 Jan 85:  Changed to dump swap files [KJC]    31 Jul 85:  Changed to handle new swap table format [KJC]     5 Nov 85:  Added Device Driver table [KJC]    15 Apr 86:  Revised and updated for -7 catalog structure [KJO]    29 May 87:  Updated WHEN table labels (again on 10 Sep 87) [KJC]    23 Jun 87:  Added command line support [KJO]    28 Sep 88:  Added Model D support [AWG]*/configuration modelC, MULDIV;insert ':-xpl:reldat';	 /* get releasae date */insert ':-xpl:literals'; /* literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:termut';   /* terminal utilities */insert ':-xpl:catrtns';  /* catalog routines */insert ':-xpl:scanargs'; /* command line scanning routines *//* Strings */dcl title.max       lit '60'; /* maximum no. characters in title */dcl title(title.max / 2) fixed; /* title for dump */dcl filename.max    lit '80'; /* maximum no. characters in treename */dcl filename(filename.max / 2) fixed; /* filename to dump *//* Buffers */dcl cache.max       lit '4'; /* number of sector caches */dcl cache.buf(cache.max*256 - 1) fixed; /* sector caches */dcl cache.sec(cache.max - 1) fixed; /* sector number of each cache */dcl catalog(C#Dir_Max - 1) fixed; /* Catalog buffer *//* Tables */dcl when.max        lit '48'; /* maximum WHEN statements supported */dcl when.tab (when.max - 1) fixed; /* WHEN statement pointers */dcl driver.max      lit '14'; /* maximum number of device drivers supported */dcl driver.tab (driver.max-1) fixed; /* device driver pointers */dcl subr.max        lit '1000'; /* maximum number of subroutine entry points supported */dcl subr.tab(subr.max - 1) fixed; /* subroutine pointers */dcl subr.count      fixed;    /* no. subroutines found *//* Dump Regions */dcl region.start    fixed; /* first word of code to display */dcl region.end      fixed; /* last word of code to display */dcl swap.start      fixed; /* first word of swapping procedure */dcl swap.end        fixed; /* last word of swapping procedure */dcl swap.sector     fixed; /* starting sector of swapping procedure */dcl swap.count      fixed; /* number of swapping procedure in swap file */dcl swap.proc       fixed; /* swapping procedure to dump */dcl swap.offset     fixed; /* internal memory offset of swapping code *//* File Locations */dcl (MS_Base,LS_Base) fixed; /* base sector to use for file buffering operations */dcl (MS_Code,LS_Code) fixed; /* starting sector of program code */dcl (MS_Swap,LS_Swap) fixed; /* starting sector of swapping code *//* Flags */dcl scon.opt        boolean; /* TRUE to dump strings and data constants */dcl swap.opt        boolean; /* TRUE to dump swap file */dcl stab.opt        boolean; /* TRUE to dump swap table */dcl printing        boolean; /* TRUE if output to printer, FALSE if to terminal *//* Processor dependent printout literals (The printed output is de-  *//* pendent on whether or not the processor type is prior to Model D) */dcl tableLen    fixed; /* swap table stride length */dcl tableOffset fixed; /* starting word of swap table *//* For processors A, B, & C */dcl C_Len       lit '3'; /* table stride length */dcl C_Offset    lit '0'; /* starting word of swap table */dcl C_Width     lit '9'; /* number of entries/columns per screen line */dcl C_Adj       lit '0'; /* offset due to 4 stride table (none for models <= 2) */dcl C_remainder lit '0'; /* mod result required *//* For processors D and later */dcl D_Len       lit '4';  /* table stride length */dcl D_Offset    lit '64'; /* starting word of swap table */dcl D_Width     lit '8';  /* number of entries/columns per screen line */dcl D_Adj       lit '1';  /* offset due to 4 stride table */dcl D_remainder lit '3';  /* mod result required *//* Page Parameters */dcl page.length     lit '88';  /* lines/page on Printronix */dcl page.width      lit '132'; /* columns/line on Printronix */ dcl vmargin         lit '6';   /* no. lines for margin */dcl page.number     fixed;     /* current page number of hardcopy */dcl line            fixed;     /* current line on page *//* Configuration Parameters */dcl config.loc      fixed; /* location of configuration table */dcl code.start      fixed;dcl code.end        fixed;dcl var.start       fixed;dcl var.len         fixed;dcl swap.ram        fixed;dcl swap.len        fixed;dcl rtp.start       fixed;dcl when.loc        fixed;dcl int.handler     fixed;dcl driver.loc      fixed;dcl proc.type       fixed; /* processor type of file we're dumping (if not MONITOR, this is processor type compiled for) */dcl redirection     fixed; /* redirection word on program entry */dcl ps lit 'pstring';when break then do; /* let them out */   redirection_word = no_redirection; /* direct output to terminal */   crlf; crlf; ps('Output Halted.'); crlf; /* display message */   call exit(-1); /* quit program */end; /* of when break *//* $subtitle Paging, Get Number */page.header:  procedure; /* print the page header */   page.number = page.number + 1; /* new page */   ps(filename); ps('  -  DUMP  UTILITY      Page:  ');   unum(page.number,0); ps('   Title:  ');   ps(title); crlf; crlf;   line = 3; /* we are now on line three */end page.header;#newline:  procedure; /* go to a new line */   dcl i fixed;   crlf;   line = line + 1;   if (printing) and (line > page.length - vmargin) then do; /* start new page */      do i = 1 to vmargin; crlf; end; /* get to top of page */      call page.header;   end; /* of new page */end #newline;dcl newline lit 'call #newline';get.value:  procedure(Prompt,Default) returns (fixed); /* Get a value from the user */   dcl Prompt  fixed array; /* prompt to display */   dcl Default fixed; /* default value to use */   dcl i fixed;   ps(Prompt); ps(' ('); onum(Default,6); ps('): ');   i = getoct;   if i = 0 then do; /* user hit RETURN */      onum(Default,0); /* display default value */      i = Default; /* use default value */   end;   crlf;   return (i); /* return value */end get.value;/* $subtitle File I/O */set.base:  procedure(MSW,LSW); /* set the base sector for all further disk operations */   dcl (MSW,LSW) fixed; /* new base sector location */   dcl i fixed;   MS_Base = MSW; /* set base sector */   LS_Base = LSW;   do i = 0 to (cache.max - 1);  /* indicate cache is empty */      cache.sec(i) = -1;   end;end;get.file:  procedure(Nam); /* get file name to dump and set file variables */   dcl Nam       fixed array; /* file name */   dcl ValidFile boolean; /* TRUE if a valid file has been entered */   ValidFile = FALSE; /* Haven't got a valid file name yet */   do while not ValidFile;      crlf;      if Nam(0) = 0 then do; /* name not given in command line */         get_string('Enter file to dump or <RETURN> to quit: ',TRUE,Nam,filename.max); /* get file name */         crlf;                   end;      if Nam(0) = 0  /* if null file name entered */      then call exit(-1); /* exit program */      else if locate(Nam,1) then do;/* if file in current catalog */         if F#Type = T#Text /* if this is a text file */         then pstringr('Text files cannot be dumped! Please try again.');         else ValidFile = TRUE; /* this file is OK to dump */      end;      else pstringr('File not found. Please try again.');      Nam(0) = 0;   end;end get.file;get.word:  procedure(loc) returns (fixed); /* get word at given location in file */   dcl (loc,sec,i) fixed;   dcl rotary.ptr  fixed; /* rotary point to indicate which cache to use next */   dcl (MSW,LSW)   fixed; /* sector location of needed sector */   sec = shr(loc,8); /* compute sector number */   do i = 0 to (cache.max - 1); /* look at the caches */      if sec = cache.sec(i) then return (cache.buf(shl(i,8)+(loc-shl(sec,8)))); /* found it */   end;   i = rotary.ptr; /* select cache to load */   cache.sec(i) = sec; /* store sector number */   MSW = MS_Base; /* calculate sector */   LSW = LS_Base + sec;   if LSW ilt sec then MSW = MSW + 1;   call readdata(MSW,LSW,location(addr(cache.buf(shl(i,8)))),256); /* read sector */   rotary.ptr = (rotary.ptr + 1) mod cache.max; /* advance rotary */   return (cache.buf(shl(i,8) + (loc - shl(sec,8)))); /* found in cache just loaded */end get.word;/* $subtitle Instruction and Subroutine Scan */scan:  procedure(loc,n) returns (fixed); /* scan n instructions ahead from loc */   dcl (loc,n,i,j,k) fixed;   do i = 1 to n; /* scan n lines ahead */      j = get.word(loc); /* get instruction */      k = j and "377"; /* get source field */      if (k = "377") or (k = "376") or (j = "736") /* two-word instruction? */      then loc = loc + 2; /* skip second word */      else loc = loc + 1; /* one word */   end;   return (loc);end scan;subr.point:  procedure(loc,inst) returns (boolean); /* TRUE if given location is in the subroutine table */   dcl loc  fixed; /* address of instruction */   dcl inst fixed; /* instruction itself */   dcl found boolean; /* TRUE if this is a subroutine entry point */   dcl i    fixed;   found = FALSE;   if proc.type < 2 then do; /* before Model C? */      i = 0;      do while (subr.tab(i) <> loc) and (i < (subr.count - 1)); /* search table to see if this address is there */         i = i + 1;      end;      found = (subr.tab(i) = loc); /* TRUE if subroutine address found */   end;   else do; /* Model C and later - look at instruction */      if (inst = (shl("352",8) or "10")) or (inst = (shl("372",8) or "10")) then do; /* D10 TO MR12 or D10 TO MR12D ??? */         subr.count = subr.count + 1; /* yes, found a subroutine */         found = TRUE;      end;   end;   return (found); /* not found */end subr.point;subr.scan:  procedure(start,finish,lower,upper); /* scan for subroutines */   dcl start      fixed; /* start of code to scan */   dcl finish     fixed; /* end of code to scan */   dcl lower      fixed; /* lowest allowable subroutine address */   dcl upper      fixed; /* highest allowable subroutine address */   dcl (loc1,i,j) fixed;   redirection_word = no_redirection; /* direct output to terminal */   crlf; ps('Searching for subroutines - please wait... ');   loc1 = start; /* start at beginning of code */   do while loc1 ilt finish; /* loop over code */      if (when.loc <> 0) and (loc1 = when.loc) then loc1 = loc1 + when.max; /* skip over WHEN table */      if (driver.loc <> 0) and (loc1 = driver.loc) then loc1 = loc1 + driver.max; /* skip over device driver table */      if loc1 ilt finish then do; /* still not done? */         i = get.word(loc1); /* get instruction */         if i = "736" then do; /* subroutine call? */            j = get.word(loc1 + 1); /* yes, so get address of subroutine */            if (j ige lower) and (j ile upper) and (not subr.point(j,0)) and (subr.count ilt subr.max) then do; /* valid call address? */               subr.count = subr.count + 1; /* another subroutine */               subr.tab(subr.count - 1) = j; /* put it in list */            end;         end; /* of call found */      end; /* of not done */      loc1 = scan(loc1,1); /* get next instruction location */   end; /* while not done */   onum(subr.count,0); ps(' subroutine(s) located'); crlf;   if printing then redirection_word = redirection; /* redirect output to printer again */end subr.scan;/* $subtitle Octal Dump */octal.dump:  procedure(start,finish,offset); /* dump from start to finish */   dcl (start,finish) fixed; /* beginning and ending address to dump */   dcl offset         fixed; /* internal memory offset */   dcl (i,j,k,ch,loc) fixed;   if start IGT finish then do; /* no region to dump */      ps('-- NONE --'); newline;      return;    end;   do i = (start and "177770") to (finish or "7"); /* loop over area */      if (i and "7") = 0 then do; /* start new line */         newline; /* go to new line */         onum(offset + i,6); ps(':');         if printing then ps('  '); /* be neater if not on terminal */      end;      else ps(' ');      if (i IGE start) and (i ILE finish) /* print word */      then onum(get.word(i),6);      else ps('      '); /* skip space */      if (printing) and (i and "7") = 3 then ps('  ');      if ((i + 1) and "7") = 0 then do; /* print ASCII interpretation */         if not printing then ps(' ');         do j = (i and "177770") to i; /* print interpretation stuff */            if printing then do;               if (j mod 4) = 0 then ps('   ');               else ps(' ');             end;            k = get.word(j);            ch = k and "377"; /* get left char */            if ch > a.space and ch < "177" then wchar(ch);            else wchar(a.period);            ch = shr(k,8); /* get right char */            if ch > a.space and ch < "177" then wchar(ch);            else wchar(a.period);         end; /* of interp line */      end; /* of printing ASCII interpretation */   end; /* of loop over area */   newline;end octal.dump;/* $subtitle WHEN handling */when.point:  procedure(loc) returns (fixed); /* return entry number if given location is in the WHEN table; otherwise, return -1 */   dcl (loc,i) fixed;   do i = 0 to when.max - 1; /* search the table */      if loc = when.tab(i) then return (i);   end;   return (-1); /* not found */end when.point;print.when:  procedure(number); /* print the name of the given WHEN statement */   dcl number fixed;   do case (number); /* branch on statement number */      ps('break    ');      ps('ttoint   ');      ps('ttiint   ');      ps('unknown3 ');      ps('unknown4 ');      ps('d16int   ');      ps('unknown6 ');      ps('d03int   ');      ps('diskerror');      ps('d140int  ');      ps('d136int  ');      ps('d137int  ');      ps('unknown12');      ps('d115int  ');      ps('bdb14int ');      ps('bdb15int ');      ps('d40int   ');      ps('d42int   ');      ps('d44int   ');      ps('d46int   ');      ps('d66int   ');      ps('unknown21');      ps('unknown22');      ps('d24int   ');      ps('d30int   ');      ps('d31int   ');      ps('d32int   ');      ps('d33int   ');      ps('d34int   ');      ps('d35int   ');      ps('d36int   ');      ps('d37int   ');      ps('unknown32');      ps('unknown33');      ps('unknown34');      ps('unknown35');      ps('unknown36');      ps('unknown37');      ps('unknown38');      ps('unknown39');      ps('dsp70int ');      ps('unknown41');      ps('unknown42');      ps('d132int  ');      ps('unknown44');      ps('unknown45');      ps('unknown46');      ps('unknown47');   end;end print.when;/* $subtitle WHEN and Device Driver handling */dump.when:  procedure; /* dump the WHEN table */   dcl (i,j) fixed;   do i = 0 to (when.max - 1); /* read in the WHEN table */      when.tab(i) = get.word(when.loc + i);   end;   newline; ps('When Table'); newline;   j = 0;   do i = 0 to (when.max - 1); /* look for when statements */      if when.tab(i) <> 0 then do; /* if a WHEN table entry */         if (j mod 4) = 0 then newline; else ps('   ');         call print.when(i); /* print the name */         ps(': '); onum(when.tab(i),6);         j = j + 1; /* count those printed */      end; /* of WHEN table entry */   end; /* of look for WHEN statements */   newline;end dump.when;driver.point:  procedure(loc) returns (fixed); /* return entry number if given location is a device driver; otherwise, return -1 */   dcl (loc,i) fixed;   do i = 0 to driver.max - 1; /* search the table */      if loc = driver.tab(i) then return (i);   end;   return (-1); /* not found */end driver.point;print.driver:  procedure(number); /* print the name of the given device driver */   dcl number fixed;   do case (number); /* branch on statement number */      ps('win1read  ');      ps('win1write ');      ps('dev8read  ');      ps('dev8write ');      ps('dev10read ');      ps('dev10write');      ps('dev12read ');      ps('dev12write');      ps('dev14read ');      ps('dev14write');      ps('dev8type  ');      ps('dev10type ');      ps('dev12type ');      ps('dev14type ');   end;end print.driver;dump.driver:  procedure; /* dump the device drivers table */   dcl (i,j) fixed;   do i = 0 to (driver.max - 1); /* read in the device driver table */      driver.tab(i) = get.word(driver.loc + i);   end;   newline; ps('Device Driver Table'); newline;   j = 0;   do i = 0 to (driver.max - 1); /* look for device drivers */      if driver.tab(i) <> 0 then do; /* if a device driver table entry */         if (j mod 3) = 0 then newline; else ps('   ');         call print.driver(i); /* print the name */         ps(': '); onum(driver.tab(i),6);         j = j + 1; /* count those printed */      end; /* of device driver table entry */   end; /* of look for device drivers */   newline;end dump.driver;/* $subtitle  Instruction Decode and Print */print.instruction: procedure(loc,offset) returns (fixed); /* print instruction at loc, return number of words */   dcl (loc, offset, inst,i,i.len) fixed; // line number offset   print.regname:  procedure(name); /* print the name of a register */      dcl name fixed;      name = name and "77"; /* mask down */      if (name and "40") <> 0 then ps('M');      do case (name and "17"); /* indicate the register */         ps('R0');         ps('R1');         ps('R2');         ps('R3');         ps('R4');         ps('R5');         ps('R6');         ps('R7');         ps('R10');         ps('R11');         ps('R12');         ps('R13');         ps('R14');         ps('R15');         ps('R16');         ps('R17');      end; /* of do case */      if (name and "20") <> 0 then ps('I');      else ps(' ');      if (name and "17") < 8 then ps(' ');      if (name and "40") = 0 then ps(' ');      ps('   '); /* space out */   end print.regname;   arith.code:  proc(inst);      dcl (inst,code) fixed;      code = shr(inst,2) and "7"; /* get code type */      if (code > 3) and ((inst and "40") <> 0) then do case code - 4; /* special codes */         ps('Bsor');         ps('Shra');         ps('Adc');         ps('Sbb');      end; /* case for special codes */      else do; /* regular */         if (inst and "40") <> 0 then ps('T');         do case code;            ps('Loa');            ps('And');            ps('Add');            ps('Sub');            ps('Xor');            ps('Rtl');            ps('Or ');            ps('Lcm');         end; /* of case */      end; /* regular */      wchar(a.0 + (inst and 3)); /* print accum number */      if (code > 3) and ((inst and "40") <> 0) then ps('   '); /* special codes */      else if (inst and "40") = 0 then ps('    '); /* op */      else ps('   '); /* T op */   end arith.code;      /* $Page */   jump.name:  procedure(inst); /* print a transfer instruction */      dcl inst fixed;      if (inst and "10") <> 0 then ps('R');      else ps('A');      do case (inst and "7");         ps('Tra');         ps('Tze');         ps('Trc');         ps('Tmi');         ps('Tnv');         ps('Tnz');         ps('Tnc');         ps('Tpl');      end; /* of case */      ps('    ');   end jump.name;   source:  procedure(inst);      dcl (inst,i) fixed;      if (inst and "200") = 0 then do; ps('Dev('); onum(inst,3); ps(')'); end; /* I/O ref */      else if inst = "377" then do; /* PCI data */         ps('#'); onum(get.word(loc + 1),6); ps(' ');      end;      else if inst = "376" then do; /* R16I data */         ps('%'); onum(get.word(loc + 1),6); ps(' ');      end;      else do; /* not I/O or PCI */         inst = (inst and "177"); /* mask down */         do case shr(inst,5);            do; ps('Im(0'); onum(inst,2); ps(') '); end; /* immed source positive */            do; /* immed source negative */               ps('Im(-');               i=((inst or "177700") xor "177777")+1; /* two's complement */               onum(i,2);               ps(') ');             end;             call print.regname(inst); /* register source */            call print.regname(inst); /* register indirect source */         end;      end; /* not I/O */   end source;   destination:  procedure(inst);      dcl inst fixed;      if (inst and "200") = 0 then do; ps('Dev('); onum(inst,3); ps(')'); end;      else do; /* not I/O */         if (inst and "100") = 0 then call arith.code(inst); /* arithmetic */         else do case shr(inst,4) and "3";            call print.regname(inst);            call jump.name(inst);            call print.regname(inst);            call print.regname(inst);         end;      end;   end destination;   /* Print Instruction Code */   inst = get.word(loc); /* get the instruction */   onum(offset + loc,6); ps('  '); onum(inst,6); ps('  ');   i = (inst and "377"); /* get the source field */   if (i = "377") or (i = "376") or (inst = "736") then do; /* two-word instruction */      onum(get.word(loc + 1),6); i.len = 2;   end;   else do; /* one-word instruction */      ps('      '); i.len = 1;   end;   if when.point(offset + loc) <> -1         then ps(' $ ');   else if (int.handler <> 0 )       and (offset + loc = int.handler)      then ps(' > ');   else if driver.point(offset + loc) <> -1  then ps(' @ ');   else if subr.point(offset + loc,inst)     then ps(' * ');   else if (code.start <> 0) and (printing)       and (offset + loc = code.start)       then ps(' ->');   else                                           ps('   ');   if inst = "736" then do; /* call instruction */      ps('CALL  '); onum(get.word(loc + 1),6); ps('         ');   end;   else do; /* regular instruction */      call source(i); /* print the source */      ps(' TO  ');      call destination(shr(inst,8)); /* print the destination */   end;   ps('    '); /* space out for next col */   return (i.len); /* return instruction length */end print.instruction;dump.code:  procedure; /* dump the program code */   dcl (loc1,loc2) fixed;   newline; ps('Object Code Dump'); newline; newline;   loc1 = region.start;   if printing /* output to printer? */   then loc2 = scan(loc1,page.length - vmargin - 2 - (line - 3)); /* compute where to start second column */   else loc2 = region.end + 1; /* end where user specified */   do while (loc1 ILT region.end) or (loc2 ILT region.end); /* loop until end of file */      if not printing then do; /* if outputting to terminal */         if (driver.loc <> 0) and (loc1 = driver.loc) then loc1 = loc1 + driver.max; /* skip device driver table */         if (when.loc <> 0) and (loc1 = when.loc) then loc1 = loc1 + when.max; /* skip WHEN table */         if loc1 = code.start then do; /* highlight start of code */            if (region.start <> code.start) then newline;            ps('Execution Entry Point'); newline;         end;      end; /* outputting to terminal */      loc1 = loc1 + print.instruction(loc1,0); /* print first column and advance */      if (printing) and (loc2 ILT region.end) then do; /* print second column and advance */         ps('      '); loc2 = loc2 + print.instruction(loc2,0);      end;      newline;      if line = 3 then do; /* have started new page */         loc1 = loc2; loc2 = scan(loc1,page.length - vmargin - 2); /* compute new starting locs */      end; /* of new page */   end;   newline; onum(subr.count,0); ps(' subroutine(s) located'); newline; /* on Model C and later, we only know this now */end dump.code;/* $subtitle Swapping Procedure Dump *//* dump the swap table */dump.swap.table: procedure(tableWidth,tableAdj,remainder);    /* The following variables are set once the processor type */   /* has been determined.  They are used for printed output. */   dcl tableWidth  fixed; /* number of entries/columns per screen line */   dcl tableAdj    fixed; /* offset due to 4 stride table (none for proc types <= 2) */   dcl remainder   fixed; /* mod result required */   dcl (i,j,k,l,len) fixed;   dcl (small.proc,small.size) (10) fixed;   dcl (large.proc,large.size) (10) fixed;   do i = 0 to 9;      small.size(i) = -1;      large.size(i) = 0;   end;   newline;   onum(swap.count,0); ps(' entries in Swap Table:'); newline;   newline;   if proc.type <= 2   then ps(' Proc   Sector   Word   Length  Sector   Word   Length  Sector   Word   Length');   else do;      ps('                        Total    SCON                   Total    SCON');newline;      ps(' Proc   Sector   Word   Length  Length  Sector   Word   Length  Length'); newline;   end;   newline;   len = swap.count * tableLen; /* If Model D processor or later, swap table looks like the following:.               (Processor models prior to Model D do .                  not include the SCON length word)..                     word    description.                     ----    ----------.                      1      sector location.                      2      word location.                      3      total length (includes scon length).                      4      SCON length.*/   do i = 1 to len;     /* loop over swap table */      if ((i - 1) mod tableWidth) = 0 then do; /* start of line */         onum (i/tableLen + 1, 6); ps ('  ');      end; /* of start of line */      j = get.word (tableOffset + i);      onum (j, 6);      if (i mod tableLen) = remainder then do; /* this word gives total length */         k = 0;         do while k <> 10; /* loop over current smallest procedures */            if j ilt small.size(k) then do; /* this procedure is smaller */               l = 9;               do while l <> k; /* make room for new procedure */                  small.size(l) = small.size(l - 1);                  small.proc(l) = small.proc(l - 1);                  l = l - 1;               end;               small.proc(k) = (i / tableLen + tableAdj); /* store procedure number */               small.size(k) = j; /* store length */               k = 10; /* exit loop */            end;            else k = k + 1;         end;         k = 0;         do while k <> 10; /* loop over current largest procedures */            if j igt large.size(k) then do; /* this procedure is larger */               l = 9;               do while l <> k; /* make room for new procedure */                  large.size(l) = large.size(l - 1);                  large.proc(l) = large.proc(l - 1);                  l = l - 1;               end;               large.proc (k) = (i / tableLen + tableAdj); /* store procedure number */               large.size (k) = j; /* store length */               k = 10; /* exit loop */            end;            else k = k + 1;         end;      end;      if (i mod tableWidth) = 0 then newline; else ps('  ');   end; /* of loop over swap table */   if (len mod tableWidth) <> 0 then newline;   newline;   ps('Top 10 smallest and largest swapping procedures:'); newline;   newline;   ps('         Smallest                  Largest'); newline;   ps('      Proc     Length           Proc     Length'); newline;   do i = 0 to 9; /* print top 10 smallest and largest procedures */      unum(i + 1,2); ps('.  ');      onum(small.proc(i),6); onum(small.size(i),10);      ps('          ');      onum(large.proc(i),6); onum(large.size(i),10);      newline;   end;   newline;end dump.swap.table;dump.swap.proc:  procedure; /* dump the swapping procedure code */   dcl (loc1,loc2,i) fixed;   dcl const.start   fixed; /* address of end of procedure/beginning of swapping strings area */   dcl entry.count   fixed; /* no. entry points found */   dcl found         boolean; /* TRUE when return code found in a procedure */   subr.count = 0; /* no subroutines found yet */   if proc.type < 2 then do; /* if less than Model C */      subr.count = 1;      subr.tab(0) = swap.offset + swap.start; /* record initial subroutine entry point */      call subr.scan(swap.start,swap.end,swap.offset + swap.start,swap.offset + swap.end); /* scan for any nested subroutines */   end;   const.start = swap.start; /* start at beginning of procedure swap code */   found = false; /* have not found a return yet */   entry.count = 0; /* no subroutines found yet */   do while (const.start ilt swap.end) and (not found); /* search for return instruction in swapping code */      i = get.word(const.start); /* get instruction */      if subr.point(swap.offset + const.start,i) then do; /* is this address a subroutine entry point? */         entry.count = entry.count + 1; /* one more subroutine */         if proc.type >= 2 then do; /* for Model C, need to check if next instruction is: im(SREG) to ATRA */            const.start = scan(const.start,1); /* get location of next instruction */            i = get.word(const.start); /* get instruction */            if ((i ige (shl("320",8) or "204")) and (i ile (shl("320",8) or "237")))  /* instruction: im(RETN) to ATRA */            then do;               const.start = scan(const.start,1); /* get location of next instruction */               i = get.word(const.start); /* get instruction */            end;         end; /* of Model C */      end; /* of subroutine entry point */      if ((proc.type < 2) and ((i ige (shl("320",8) or "204")) and (i ile (shl("320",8) or "237"))))  /* instruction: im(RETN) to ATRA */      or ((proc.type >= 2) and (i = (shl("320",8) or "352"))) /* Model C instruction: MR12 to ATRA */      then do; /* is this instruction the return from a subroutine? */         entry.count = entry.count - 1; /* one less subroutine */         found = (entry.count = 0); /* TRUE if at end of main procedure */      end;      const.start = scan(const.start,1); /* get location of next instruction */   end;   i = subr.count; /* store no. subroutines found */   region.start = region.start - swap.offset; /* convert back to swap file address */   region.end = region.end - swap.offset;   if region.end igt const.start then region.end = const.start; /* do not dump the string constants */   loc1 = region.start; /* start here (swap file start) */   if printing /* use double column for printer output */   then loc2 = scan(loc1,page.length - vmargin - 2 - (line - 3)); /* compute where to start second column */   else loc2 = region.end + 1; /* assume no second column */   newline; ps('Dump of Swapping Procedure '); onum(swap.proc,6);   ps('  (sector '); lonum (MS_Base and "377", LS_Base, 8); ps(')'); newline; newline;   do while (loc1 ILT region.end) or (loc2 ILT region.end); /* loop over region to dump */      loc1 = loc1 + print.instruction(loc1,swap.offset); /* print it and advance */      if (printing) and (loc2 ILT region.end) then do;         ps('      '); loc2 = loc2 + print.instruction(loc2,swap.offset);      end;      newline;      if line = 3 then do; /* have started new page */         loc1 = loc2; loc2 = scan(loc1,page.length - vmargin - 2); /* compute new starting locs */      end;   end;   newline; onum(i,0); ps(' subroutine(s) located'); newline; /* on Model C and later, we only know this now */   if found and scon.opt then do; /* if a return was found */      newline; ps('Swapping Procedure '); onum(swap.proc,6);      ps(' Strings and Constants Area'); newline;      call octal.dump(const.start,swap.end - 1,swap.offset); /* dump the constants and strings */   end;end dump.swap.proc;/* $subtitle  Main Section */dcl (i,j)       fixed;redirection = directed_output; /* save initial output redirection */printing = (redirection <> no_redirection); /* set printing flag */redirection_word = no_redirection; /* send output to terminal */ps('File Dump Utility         version of '); ps(rel.date); crlf;scon.opt = false; swap.opt = false; /* all dump options initially off */call set_catbuf (addr(catalog (0)), 0); /* set the catalog buffer */call Setup_Args (filename); /* set up for argument scanning */call Next_Arg(filename); /* get treename of file to dump */call get.file(filename); /* Get name and beginning sector of file to dump */do i = 0 to F#Name_Len; /* Store file name */   filename(i) = F#Name(i);end;MS_Code = F#MS_Sector; /* Store beginning sector of program code */LS_Code = F#LS_Sector;call set.base(MS_Code,LS_Code); /* Set base to beginning of program code */config.loc = get.word(1); /* locate configuration table */if config.loc ilt 256 then do; /* if there's a valid configuration pointer, must be an XPL program */   proc.type = (shr(get.word(config.loc + c#cmopt), 8) and "7"); /* get processor type */   if proc.type <= 2 then do;       tableLen    = C_len;    /* set swap table stride length       */      tableOffset = C_offset; /* offset for first word of swap file */   end;   else do; /* Model D or later */      tableLen    = D_len;    /* set swap table stride length           */      tableOffset = D_offset; /* Each page for Model D & later includes */   end;                       /* 64 words of transfer vector locations  */   var.start  = get.word(config.loc + c#vstart); /* Get parameters from configuration */   var.len    = get.word(config.loc + c#vlngth);   code.start = get.word(config.loc + c#objloc);   code.end   = get.word(config.loc + c#objlen);   rtp.start  = get.word(config.loc + c#rtploc);   swap.ram   = get.word(config.loc + c#swpram);   swap.len   = get.word(config.loc + c#swplen);   when.loc   = get.word(config.loc + c#inttab);   driver.loc = get.word(config.loc + c#devtab);   if swap.ram <> 0 then do; /* swap file present? */      swap.opt = Get_YN('Dump the Swapping Code [Y(es) or N(o)]? '); crlf;      scon.opt = Get_YN('Dump Strings and Data Constants [Y(es) or N(o)]? '); crlf;      if swap.opt then do;         stab.opt = Get_YN('Dump Swap Table [Y(es) or N(o)]? '); crlf;         MS_Swap = MS_Code; /* store beginning sector of swap file */         LS_Swap = LS_Code + shr(code.end + 255,8);         if LS_Swap ilt LS_Code then MS_Swap = MS_Swap + 1;         call set.base(MS_Swap,LS_Swap); /* set base to beginning of swap file */         swap.count = get.word(tableOffset); /* get no. swapping procedures in swap table */         swap.proc = 0;         do while (swap.proc < 1) or (swap.proc > swap.count); /* get swapping procedure to dump */            ps('There are '); onum(swap.count,6); ps(' swapping procedures. Enter procedure to dump: ');            swap.proc = getoct; crlf;         end;                 i = (swap.proc - 1) * tableLen + tableOffset + 1; /* find location of procedure entry in swap table */         swap.sector = get.word(i); /* get starting sector of swapping procedure */         swap.start = get.word(i + 1); /* get code starting word within that sector */         swap.end = swap.start + get.word(i + 2); /* get code end */         if proc.type <= 2 /* internal memory offset */         then swap.offset = code.end - swap.start;         else swap.offset = shl(swap.sector,8);         crlf;         ps('Swapping Code start:'); onum(swap.offset + swap.start,7); ps(', end:'); onum(swap.offset + swap.end,7); crlf;         region.start = get.value('Enter start of swap dump region',swap.offset + swap.start); /* starting value */         region.end = get.value('Enter end of swap dump region  ',swap.offset + swap.end); /* ending value */         call set.base(MS_Code,LS_Code); /* set base back to beginning of program code */      end; /* of swap option selected */   end; /* of swap file present */   else do;      scon.opt = Get_YN('Dump Strings and Data Constants [Y(es) or N(o)]? '); crlf;   end;end; /* of dumping xpl program */else do; /* no configuration table, so dump entire file */   code.start = 0;   code.end = F#Words; /* word length of file */end;if not swap.opt then do; /* swap option not chosen, get program code range */   crlf;   if rtp.start <> 0 then do; /* RTP present */      ps('Run Time Package start:'); onum(rtp.start,7); ps(', ');   end;   ps('Code start:'); onum(code.start,7); ps(', Code end:'); onum(code.end,7); crlf;   region.start = get.value('Enter start of code dump region',code.start); /* starting value */   region.end =   get.value('Enter end of code dump region  ',code.end); /* ending value */end;if printing then do; /* set up for printer */   crlf;   get_string('Enter dump title: ',false,title,title.max); crlf;   ps('Line up paper and press RETURN > '); i = rchar; crlf; crlf;   screen_size (page.length, page.width); /* set screen size */   redirection_word = redirection; /* redirect output to printer */   call page.header; /* print first page header */end;if config.loc ilt 256 then do; /* configuration is only valid if within firts sector */   newline;   ps('Configuration Table Location: '); onum(config.loc,6); newline;   ps('String and Data Constants:    '); onum(config.loc+c#conlen,6); newline;   ps('RTP Location:                 '); onum(rtp.start,6);  newline;   ps('Program Code Start Location:  '); onum(code.start,6); newline;   ps('Swap Area Location:           '); onum(code.end,6);   newline;   ps('Variable Area Location:       '); onum(var.start,6);  newline;   ps('Variable Area Length:         '); onum(var.len,6);    newline;   ps('Stack Area Location:          '); onum(var.start+var.len,6); newline;   ps('Stack Area Length:            '); onum(get.word(config.loc+c#stklen),6); newline;   ps('Swapping Mechanism Variables: '); onum(swap.ram,6);   newline;   ps('Swap File Length (sectors):   '); onum(swap.len,6);   newline;   ps('Processor Type:               '); onum(proc.type,6);  newline;   newline;   ps('Configuration Table Words 0 to '); onum(c#conlen-1,0); ps(': '); newline; newline; /* print config information */   do i = 0 to c#conlen - 1; /* loop over configuration area */      onum(get.word(config.loc + i),6);      if ((i + 1) mod 8) = 0 then newline;      else ps('  ');   end;end; /* of valid configuration */int.handler = 0; /* assume no interrupt handler */do i = 0 to driver.max - 1; /* set driver table table to no entries */   driver.tab(i) = -1;end;do i = 0 to when.max - 1; /* set WHEN table to no entries */  when.tab(i) = -1;end;if swap.opt then do; /* dump the swap file */   if stab.opt then do; /* dump swap table? */      call set.base(MS_Swap,LS_Swap); /* set base to beginning of swap file */      if proc.type <= 2 /* output is dependent on processor type */      then call dump.swap.table (C_width,C_adj,C_remainder);      else call dump.swap.table (D_width,D_adj,D_remainder);   end;   if region.start ilt region.end then do; /* dump the swapping code */      LS_Swap = LS_Swap + swap.sector; /* calculate beginning sector of swapping procedure */      if LS_Swap ilt swap.sector then MS_Swap = MS_Swap + 1;      call set.base(MS_Swap,LS_Swap); /* set base to this sector */      call dump.swap.proc; /* dump the swapping procedure */   end;end;else do; /* dump the program code */   subr.count = 0; /* assume no subroutines */   if proc.type < 2 then call subr.scan(region.start,region.end,region.start,region.end); /* before Model C, scan for subroutines */   j = 2; /* start searching for interrupt handler pointer after configuration table pointer */   do while ((j < config.loc) and (get.word(j) <> (shl("320",8) or "376"))); /* look for MR16I to ATRA */      j = j + 1;   end;   if ((j < config.loc) and (get.word(j + 1) <> j)) then do; /* is this a valid interrupt handler pointer? */      int.handler = get.word(j + 1); /* remember where it is */      newline; ps('Interrupt Handler is present'); newline;   end;   if driver.loc <> 0 then call dump.driver; /* dump device driver table */   if when.loc <> 0 then call dump.when; /* dump WHEN table */   if scon.opt then do; /* print the SCON only if requested */      newline; ps('Strings and Constants Area'); newline;      call octal.dump(config.loc + c#conlen,rtp.start - 1,0); /* dump the constants and strings */   end;   if region.start ilt region.end then call dump.code; /* otherwise dump the program code */end; /* dumping program code */if printing then wchar(a.ff); /* do a form feed */redirection_word = no_redirection; /* direct output to terminal */crlf; pstringr('End of DUMP utility');