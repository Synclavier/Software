/* $TITLE  Configuration Device Routines */get.device: proc(devtyp) fixed; /* converts logical device type into system device number */   dcl devtyp fixed; /* 0: Floppy, 1: Winchester, 2: Remote, 3: Tape, 4: Optical */   dcl i      fixed;   i = (devtyp and "17"); /* logical device type */   do case i;      i = 2;  /* Floppy */      i = 6;  /* Winchester */      i = 4;  /* Remote floppy */      i = 8;  /* Tape */      i = 10; /* Optical */   end;   return (i or (shr(devtyp, 4) and "1")); /* return device number (drives zero and one supported only) */end get.device;get_devtyp: proc(device) fixed; /* converts system device number into logical device type */   dcl device fixed; /* system device number */   dcl i      fixed;   i = shr(device - 2, 1); /* get device */   if      i = 2 then i = 1; /* convert W0 to Winchester */   else if i = 1 then i = 2; /* and     R0 to Remote     */   return (shl(device and "1", 4) or i);end get_devtyp;print_device: proc(device); /* prints device name to menu */   dcl device fixed; /* device to print */   dcl (i, j) fixed;   device = get_devtyp (device); /* get physical encoding */   i = device         and "17"; /* logical device type   */   j = shr(device, 4) and "17"; /* logical drive  number */   wchar (byte('FWRTO', i)); wchar (a.0 + j);end print_device;find_device: proc(device) fixed; /* search for device in configuration */   dcl device fixed; /* device to look for */   dcl type   fixed; /* type of that device */   dcl i      fixed;   type = get_devtyp (device);   i = contab + c#strdev;   do while ((i < contab + c#strend) and ((buf (i + s#devtyp) and "377") <> type)); /* look for a free block */      i = i + s#blklen;   end;   if i < contab + c#strend /* still in the table? */   then return (i); /* yes, return pointer */   else return (0);end find_device;/* $SUBTITLE Set System and Current Devices */system.device:  proc(action); /* set the system device on menu (F0 or W0) */   dcl action fixed; /* TRUE to bump and print */   dcl pdev   fixed;   if action then do; /* OK to bump */      pdev = sysdev; /* save current system device */      if sysdev = i#F0 then sysdev = i#W0; /* toggle between F0 and W0 */      else sysdev = i#F0;      if (get_info(sysdev,0,i#dev_type) and "377") = 0 /* if that device isn't configured */      then sysdev = pdev; /* don't change sysdev */   end;   call print_device (sysdev); /* print it on the menu */end system.device;current.device:  proc(action); /* set the current device on menu */   dcl action fixed; /* TRUE to bump and print */   if action then do; /* OK to bump */      curdev = curdev + 1; /* advance current device */      if curdev > i#W1 then curdev = i#F0; /* wrap to F0 */      do while (get_info(curdev,0,i#dev_type) and "377") = 0; /* only allow valid current devices */         curdev = curdev + 1; /* advance current device */         if curdev > i#W1 then curdev = i#F0; /* wrap to F0 */      end;   end;   call print_device (curdev); /* print it on the menu */end current.device;/* $SUBTITLE Floppy Drive Type Decoding */floppy_type: proc(p) fixed; /* determine the type of floppy configured */   dcl p      fixed; /* pointer to storage table entry for floppy */   dcl (i, j) fixed;   if p = 0 then i = unknown; /* force an unknown type if no configuration */   else do; /* it's configured */      i = 1; /* assume Super Mini */      do j = 1 to s#blklen - 1; /* check for Super Mini */         if buf (p + j) <> smin_config (j) then i = 0; /* not Super Mini */      end;      if i = 0 then do; /* not a Super Mini? */         i = 2; /* assume DD Mini */         do j = 1 to s#blklen - 1; /* check for DD Mini */            if buf (p + j) <> dmin_config (j) then i = 0; /* not DD Mini */         end;         if i = 0 then do; /* not a DD Mini? */            i = 3; /* assume Maxi */            do j = 1 to s#blklen - 1; /* check for Maxi */               if buf (p + j) <> maxi_config (j) then i = 0; /* not Maxi */            end;            if i = 0 then do; /* not a Maxi? */               i = 4; /* assume SD Mini */               do j = 1 to s#blklen - 1; /* check for SD Mini */                  if buf (p + j) <> mini_config (j) then i = 0; /* not SD Mini */               end;            end; /* of not Maxi */         end; /* of not DD Mini */      end; /* of not Super Mini */   end; /* of it's configured */   return (i); /* return type */end floppy_type;print_floppy: proc(dev); /* print the floppy type on the menu */   dcl dev fixed; /* device to print */   dcl i   fixed;   i = (get_info(dev,0,i#dev_type) and "377"); /* get device type */   if i = unknown then px ('Unknown     ');   else do case (i); /* print drive type */      px ('None        ');      px ('5" Supermini');      px ('5" DD Mini  ');      px ('8" Maxi     ');      px ('5" SD Mini  ');   end; /* of print drive type */end print_floppy;/* $SUBTITLE Winchester and Tape Type Decoding */winchester_type: proc(p) fixed; /* determine the type of Winchester configured */   dcl p     fixed; /* pointer to storage table entry for said Winchester */   dcl found boolean; /* TRUE if IMI type found */   dcl i     fixed;   if (shr(buf(p + s#devtyp),8) and "17") = 1 then do; /* SCSI drive */      return (1); /* SCSI drive type */   end;   else do;      i = first_imi; found = false; /* not found yet */      do while (i <= type_to_IMI(0)) and (not found); /* search for IMI type */         if  (buf(p + s#totcyl) = win_siz(type_to_IMI(i))) /* same total cylinders */         and (buf(p + s#seccyl) = win_cyl(type_to_IMI(i))) /* same sectors/cylinder */         then found = true; /* found this IMI type */         else i = i + 1; /* not found, so check next type */      end;      if not found then i = unknown; /* unknown Winchester */      return (i); /* return type */   end;end winchester_type;print_winchester: proc(dev,drive); /* print Winchester type to menu */   dcl dev   fixed; /* device */   dcl drive fixed; /* physical drive on that device */   dcl i     fixed; /* type */   i = (get_info(dev,drive,i#dev_type) and "377"); /* get device type */   if i = unknown then px ('Unknown  ');   else do case (i); /* print various winchester types */      px ('None     ');      px ('5", SCSI '); /*"*/ /* "SCSI 		*/      px ('5", 5 MB '); /*"*/ /* IMI 5007    */      px ('5", 10 MB'); /*"*/ /* IMI 5012H   */      px ('5", 15 MB'); /*"*/ /* IMI 5018H   */      px ('8", 10 MB'); /*"*/ /* IMI 7710    */      px ('8", 20 MB'); /*"*/ /* IMI 7720    */      px ('8", 40 MB'); /*"*/ /* IMI 7740    */   end;end print_winchester;print_win_adr: proc(type,adr);   dcl type fixed; /* winchester type (0 = IMI, 1 = SCSI) */   dcl adr  fixed; /* device address */   if type = 1 then do;      unum(shr(adr,4) and "HF",0); wchar(a.comma);   end;   unum(adr and "HF",0); wchar(a.comma);   unum(shr(adr,8) and "HF",0);end print_win_adr;tape_type: proc(p) fixed; /* determine the type of tape configured */   dcl p fixed; /* pointer to storage table entry for tape */   if p = 0 /* if it isn't configured */   then return (unknown); /* return unknown type */   else return ((shr(buf (p), 8) and "3") + 1); /* otherwise, bits 8-9 give tape type */end tape_type;print_tape: proc(dev); /* print tape type on menu */   dcl dev fixed; /* device to print */   dcl i   fixed; /* tape type */   i = (get_info(dev,0,i#dev_type) and "377"); /* get device type */   if i = unknown then px ('Unknown  ');   else do case (i);      px ('None          ');      px ('1/4" Cartridge');      px ('1/2" Cartridge');   end;end print_tape;optical_type: proc(p) fixed; /* determine the type of optical disk configured */   dcl p fixed; /* pointer to storage table entry for optical disk */   if p = 0 /* if it isn't configured */   then return (unknown); /* return unknown type */   else return ((shr(buf (p), 10) and "3") + 1); /* otherwise, bits 10-11 give optical type */end optical_type;print_optical: proc(dev); /* print optical type on menu */   dcl dev fixed; /* device to print */   dcl i   fixed; /* optical type */   i = (get_info(dev,0,i#dev_type) and "377"); /* get device type */   if i = unknown then px ('Unknown       ');   else do case (i);      px ('None       ');      px ('"Optical"  ');      px ('"Optical"  ');   end;end print_optical;/* $SUBTITLE Winchester Address Routines */win_interface: proc(device,drive,action);	/* update Winchester interface (D24) number */   dcl device    fixed; 		/* device */   dcl drive     fixed;			/* drive on this device */   dcl action    boolean;		/* TRUE if we want to change the interface address */   dcl interface fixed;			/* interface number for Winchester */   dcl scsi_dev  fixed; 		/* 0 = IMI, 1 = SCSI */   dcl devadr    fixed;			/* device address */   scsi_dev = shr(get_info(device, drive, i#dev_type), 8);	/* find out if it is a SCSI */      if scsi_dev = 0 then return;								/* must be SCSI to change this field */      devadr = get_info(device, drive, i#scsi_adr);			/* get SCSI device address */      interface = shr(devadr,4) and "17"; /* get D24 number */   if action then do; /* find a new controller address if necessary */      interface = ((interface + 1) mod 4); /* look at next interface */      devadr = (devadr and "HFF0F") or shl(interface,4); /* insert new D24 number */      call put_info(device,drive,i#scsi_adr,devadr); /* replace word in info array */   end;      pnum (interface, 0); /* print the interface number */end win_interface;win_controller: proc(device,drive,action); /* update Winchester controller number */   dcl device     fixed;	/* device */   dcl drive      fixed;	/* drive on this device */   dcl action     boolean;	/* TRUE if we want to change the interface address */   dcl controller fixed;	/* interface number for Winchester */   dcl adr_index  fixed;	/* holds which device address in record to use (IMI or SCSI) */   dcl devadr     fixed;	/* device address */   if shr(get_info(device, drive, i#dev_type), 8) = 0 /* IMI? */   then adr_index = i#imi_adr; /* remember where IMI device address goes */   else adr_index = i#scsi_adr; /* remember where SCSI device address goes */   devadr     = get_info(device,drive,adr_index);	/* get SCSI device address */   controller = (devadr and "17"); 					/* get controller number */   if action then do; /* find a new controller address if necessary */      controller = ((controller + 1) mod 8); /* look at next controller */      devadr = (devadr and "HFFF0") or controller; /* put new controller number into device address */      call put_info(device,drive,adr_index,devadr); /* store new device address */   end; /* of finding new controller address */   pnum (controller, 0); /* print the controller number */end win_controller;win_drive: proc(device,drive,action);	/* update Winchester drive number (LUN) */   dcl device     fixed;	/* device */   dcl drive      fixed;	/* drive on this device */   dcl action     boolean;	/* TRUE if we want to change the interface address */   dcl drive_num  fixed;	/* interface number for Winchester */   dcl adr_index  fixed;	/* holds which device address in record to use (IMI or SCSI) */   dcl devadr     fixed;	/* device address */	dcl limit      fixed;   if (shr(get_info(device, drive, i#dev_type), 8) == 0) /* IMI? */	{		adr_index = i#imi_adr;	/* remember where IMI device address goes */		limit = 2;	}   else	{		adr_index = i#scsi_adr; /* remember where SCSI device address goes */		limit = 8;	}   devadr = get_info(device, drive, adr_index);	/* get SCSI device address */   drive_num = (shr(devadr, 8) and "17");		/* get drive number (e.g. lun) */   if action then do; /* find a new drive address if necessary */      drive_num = ((drive_num + 1) mod limit); /* look at next drive */      devadr = (devadr and "HF0FF") or shl(drive_num,8); /* put new drive number into device address */      call put_info(device,drive,adr_index,devadr); /* store new device address */   end; /* of finding new drive address */   pnum (drive_num, 0); /* print the drive number */end win_drive;/* $SUBTITLE Update Storage Devices */storage_device:  proc (device, drive, action, row); /* change a storage device */   dcl device    fixed;		/* device to change */   dcl drive     fixed;		/* drive on that device to change */   dcl action    fixed;		/* TRUE to bump and print */   dcl row       fixed;		/* current row */   dcl same_type boolean;	/* check for configuring like drives only */   dcl (i,j,k)   fixed;   i = get_info(device, drive, i#dev_type) and "377"; /* get device index for this drive */   if ((device = i#W0) or (device = i#W1)) then do; /* Winchester? */      if action then do;				/* change drive type */         if i = unknown then i = 0; /* skip to next configured drive */         same_type = false;			/* assume drives are not the same type (IMI/SCSI) */         do while not same_type;		/* do until choice is same kind of Winchester */            if (action == 3)					i = 0;				else					i = ((i + 1) mod (type_to_IMI(0) + 1)); /* point to next drive type */				            if ((i = 0) and (drive = 0) and ((device = sysdev) or (device = curdev))) then i = 1; /* disallow freeing the system or current device */            if (i = 0) and (drive < i#num_wins - 1) then do;	/* selection is "NONE" and not the last drive on this device */               if (get_info(device,drive + 1,i#dev_type) and "377") <> 0 /* drive just after this one is configured */               then i = 1;										/* so do not allow "NONE" to be selected */            end;            j = get_info(device,0,i#dev_type); /* get type of first drive (IMI or SCSI) */            if (drive <> 0) and ((j and "377") <> 0) then do; /* if not first drive and first drive is configured */               j = shr(j,8); /* get IMI/SCSI flag */               if      (j = 0) and ((i = 0) or (i >= first_imi)) then same_type = true; /* IMI */               else if (j = 1) and ((i = 0) or (i <  first_imi)) then same_type = true; /* SCSI */            end;            else same_type = true; /* don't need to check in this case */         end;         if i = 0 then do; /* unconfigure this drive */            call go_to (row, column_two + 1); px ('     '); call go_to (row, column_two);            do j = column_two + 1 to column_two + 3; /* can no longer move to these columns */               valid (row*columns + j) = false;            end;            call put_info(device, drive, i#dev_type, 0); /* unconfigur this slot */         end;         else do; /* configure the drive */            if i < first_imi then j = 1; else j = 0; /* set IMI/SCSI flag to appropriate value */            call put_info(device,drive,i#dev_type,shl(j,8) or i); /* replace the word back into info array */            /* Swap IMI Defaults if W0 has a SCSI configured and W1 is not configured */            if device = i#W1 then do; /* device to configure is W1 */               if (W1_Not_Set) /* we have not configured W1 yet */               and (drive = 0) /* this is drive 0 */               and ((get_info(i#W0,drive,i#dev_type) and "377") <> 0) /* W0 is there */               and (shr(get_info(i#W0,drive,i#dev_type),8) = 1) /* W0 is a SCSI */               then do; /* change W1 IMI defaults to W0 IMI defaults */                  do j = 0 to i#num_wins - 1; /* loop over drives */                     k = shl(W1_IMI_Defaults(j*2 + 1),8) or W1_IMI_Defaults(j*2); /* construct IMI device address */                     call put_info(i#W0,j,i#imi_adr,k); /* store address */                     k = shl(W0_IMI_Defaults(j*2 + 1),8) or W0_IMI_Defaults(j*2); /* construct IMI device address */                     call put_info(i#W1,j,i#imi_adr,k); /* store address */                  end;               end; /* changing defaults */               W1_Not_Set = false; /* W1 is now set */            end; /* changing W1 */         end; /* of configure the drive */         call put_info(device,drive,i#sec_cyl,0); /* get rid of any stored size info */         call put_info(device,drive,i#tot_cyl,0);      end; /* of changing drive type */      if drive < i#num_wins - 1 then do; /* not the last drive on this device */         if i = 0 /* drive is not configured */          then valid ((row + 1)*columns + column_two) = false; /* cannot move to next drive */         else valid ((row + 1)*columns + column_two) = true;  /* can move to next drive */      end;      call print_winchester(device,drive); /* print out the type */      if (i <> 0) and (i <> unknown) and (using_interpreters_device_list == 0) then do; 	/* if we have a device and controller */         valid (row*columns + column_two + 2) = true; 				/* make Winchester address columns valid */         valid (row*columns + column_two + 3) = true;         call go_to (row, column_two + 1);         if shr(get_info(device,drive,i#dev_type),8) = 1 then do; /* if it's a SCSI drive */            call win_interface(device,drive,false); px (',');            valid (row*columns + column_two + 1) = true; 			/* make D24 column valid too */         end;         else do; /* not a SCSI drive */            px ('  ');            valid (row*columns + column_two + 1) = false; 			/* zap this in case we didn't go by NONE */         end;         call win_controller (device,drive,false); px (','); call win_drive (device, drive, false);      end; /* of we have a device and controller */   end; /* of winchester */   	else if ((device = i#T0) or (device = i#T1)) then do; /* Tape? */      if action then do; /* change drive type if necessary */         if i = unknown then i = 0; /* skip to next configured drive */         if (action == 3)				i = 0;			else         	i = ((i + 1) mod 3); /* point to next tape type */         if i = 1 then do; /* kludge to make sure a Kennedy is not already selected */            if ((device = i#T0) and ((get_info(i#T1,0,i#dev_type) and "377") = 1)) /* T1 is also a Kennedy */            or ((device = i#T1) and ((get_info(i#T0,0,i#dev_type) and "377") = 1)) /* T0 is also a Kennedy */            then i = ((i + 1) mod 3); /* point to next tape type */         end;         if i = 1 then j = 0; else j = 1; /* set SCSI flag - hyper kludge! */         call put_info(device,drive,i#dev_type,shl(j,8) or i);      end;      call print_tape (device); /* print the tape type */   end; /* of tape */     else if ((device = i#O0) or (device = i#O1)) then do; /* Optical Disk */      if action then do;					/* change drive type if necessary */         if i = unknown then i = 0;		/* skip to next configured drive */         if (action == 3)					/* delete; set type to 0 */				i = 0;			else			{         	i = (i + 1);					/* point to next optical disk type */				if (i >= 2) i = 0;			/* wrap from either value to 0 */			}			         call put_info(device, drive, i#dev_type, shl(1,8) or i);      end;		if i = 0 then do;						/* unconfigure this drive */			call go_to (row, column_two + 1); px ('     ');			/* erase x,x,x */			call go_to (row, column_two);			do j = column_two + 1 to column_two + 3; /* can no longer move to these columns */				valid (row*columns + j) = false;			end;		end;      else if (i <> unknown) and (using_interpreters_device_list == 0) then do;		/* if we have a device and controller 	*/			valid (row*columns + column_two + 1) = true; 										/* make D24 column valid 					*/         valid (row*columns + column_two + 2) = true;											/* make SCSI address columns valid 		*/         valid (row*columns + column_two + 3) = true;         			call go_to (row, column_two + 1);						call win_interface(device,drive,false); px (',');         call win_controller (device,drive,false); px (',');			call win_drive (device, drive, false);			call go_to (row, column_two);      end; /* of we have a device and controller */      		call print_optical (device); /* print the optical disk type */   end; /* of optical disk */      else do; /* floppy */      if action then do; /* change drive type if necessary */         if i = unknown then i = 0; /* skip to next configured drive */         if (action == 3)				i = 0;			else         	i = ((i + 1) mod 5); /* point to next drive type */         			if ((i = 0) and ((device = sysdev) or (device = curdev) or (device = 2))) then i = 1; /* disallow freeing the system or current device (or F0) */         call put_info(device,drive,i#dev_type,i);      end;      call print_floppy (device); /* print the drive type */   end; /* of floppy */end storage_device;/* $SUBTITLE Set up device defaults */set_device_defaults: proc; /* set default device addresses and types */   dcl j fixed;   set_winchester: proc(dev,IMI_Def,SCSI_Def); /* set up device address defaults for the given Winchester device */      dcl dev      fixed; /* device to set up */      dcl IMI_Def  fixed array; /* array containing default IMI device addresses */      dcl SCSI_Def fixed array; /* array containing default SCSI device addresses */      dcl (i,j)    fixed;      do i = 0 to i#num_wins - 1; /* store defaults for all Winchesters */         call put_info(dev,i,i#dev_type,0); /* no type yet */         j = shl(IMI_Def(i*2 + 1),8) or IMI_Def(i*2); /* construct IMI device address */         call put_info(dev,i,i#imi_adr,j); /* store address */         j = shl(SCSI_Def(i*3 + 2),8) or shl(SCSI_Def(i*3),4) or SCSI_Def(i*3 + 1); /* construct SCSI device address */         call put_info(dev,i,i#scsi_adr,j); /* store address */      end;   end set_winchester;   /* Set up default device addresses and types */   call put_info(i#F0,0,i#dev_type,0); /* no floppies yet */   call put_info(i#F1,0,i#dev_type,0);   call put_info(i#R0,0,i#dev_type,0); /* no remotes yet */   call put_info(i#R1,0,i#dev_type,0);   call set_winchester(i#W0,W0_IMI_Defaults,W0_SCSI_Defaults); /* set up W0 */   call set_winchester(i#W1,W1_IMI_Defaults,W1_SCSI_Defaults); /* set up W1 */   call put_info(i#T0,0,i#dev_type,0); /* no T0 yet */   j = shl(T0_SCSI_Defaults(2),8) or shl(T0_SCSI_Defaults(0),4) or T0_SCSI_Defaults(1); /* construct SCSI device address */   call put_info(i#T0,0,i#scsi_adr,j); /* set default address */   call put_info(i#T1,0,i#dev_type,0); /* no T1 yet */   j = shl(T1_SCSI_Defaults(2),8) or shl(T1_SCSI_Defaults(0),4) or T1_SCSI_Defaults(1); /* construct SCSI device address */   call put_info(i#T1,0,i#scsi_adr,j); /* set default address */   call put_info(i#O0,0,i#dev_type,0); /* no O0 yet */   j = shl(O0_SCSI_Defaults(2),8) or shl(O0_SCSI_Defaults(0),4) or O0_SCSI_Defaults(1); /* construct SCSI device address */   call put_info(i#O0,0,i#scsi_adr,j); /* set default address */   call put_info(i#O1,0,i#dev_type,0); /* no O1 yet */   j = shl(O1_SCSI_Defaults(2),8) or shl(O1_SCSI_Defaults(0),4) or O1_SCSI_Defaults(1); /* construct SCSI device address */   call put_info(i#O1,0,i#scsi_adr,j); /* set default address */end set_device_defaults;/* $SUBTITLE Get current device configuration */get_device_config: proc; /* get current config info for all devices */   dcl dev fixed; /* device found */   dcl typ fixed; /* type of device found */   dcl ptr fixed; /* pointer into device table */   get_floppy: proc(dev); /* get floppy device configuration */      dcl dev       fixed; /* device to get */      dcl i         fixed;      i = (buf(ptr + s#devtyp) and "HFF00") or floppy_type(ptr);      call put_info(dev,0,i#dev_type,i); /* store type */      call put_info(dev,0,i#sec_cyl,buf(ptr + s#seccyl)); /* store sectors/cylinder */      call put_info(dev,0,i#tot_cyl,buf(ptr + s#totcyl)); /* store total cylinders */      call put_info(dev,0,i#imi_adr,buf(ptr + s#spdtrk)); /* store floppy info */      ptr = ptr + s#blklen; /* next configuration entry */   end get_floppy;   get_winchester: proc(dev); /* get winchester device configuration */      dcl (dev, drive) fixed; /* device and drive to store */      dcl win_type     fixed; /* device type found */      dcl (i,j)        fixed;      win_type = buf(ptr + s#devtyp) and "377"; /* get winchester type */      drive = 0; /* start at drive zero */      do while (buf(ptr + s#devtyp) and "377") = win_type; /* loop until device type changes (not W0 or W1 anymore) */         if drive < i#num_wins then do; /* max number of drives not exceeded */            j = (buf(ptr + s#devtyp) and "H300"); /* first get IMI or SCSI flag */            j = j or winchester_type(ptr); /* add in winchester type */            call put_info(dev,drive,i#dev_type,j); /* store type */            call put_info(dev,drive,i#sec_cyl,buf(ptr + s#seccyl)); /* store sectors/cylinder */            call put_info(dev,drive,i#tot_cyl,buf(ptr + s#totcyl)); /* store total cylinders */            if (shr(j,8) and "3") = 0  /* IMI? */            then call put_info(dev,drive,i#imi_adr ,buf(ptr + s#devadr)); /* store IMI address */            else call put_info(dev,drive,i#scsi_adr,buf(ptr + s#devadr)); /* store SCSI address */            ptr = ptr + s#blklen; /* next configuration entry */         end; /* valid drive */         else do; /* too many drives */            pcmd('Additional Winchesters in configuration ignored.');         end;         drive = drive + 1; /* next drive */      end; /* looping over drives */   end get_winchester;   get_tape: proc(dev); /* get tape device configuration */      dcl dev   fixed; /* device to get */      dcl i     fixed;      i = (buf(ptr + s#devtyp) and "H300") or tape_type(ptr); /* get tape type */      call put_info(dev,0,i#dev_type,i); /* store type */      call put_info(dev,0,i#sec_cyl,buf(ptr + s#seccyl)); /* store sectors/cylinder */      call put_info(dev,0,i#tot_cyl,buf(ptr + s#totcyl)); /* store total cylinders */      call put_info(dev,0,i#imi_adr,buf(ptr + s#devadr)); /* store device address */      call put_info(dev,0,i#scsi_adr,buf(ptr + s#devadr)); /* store device address (again) */      ptr = ptr + s#blklen; /* next configuration entry */   end get_tape;   get_optical: proc(dev); /* get optical device configuration */      dcl dev   fixed; /* device to get */      dcl i     fixed;      i = shl(1,8) or optical_type(ptr);								/* get optical type */      call put_info(dev, 0, i#dev_type, i);							/* store type */      call put_info(dev, 0, i#sec_cyl,  buf(ptr + s#seccyl));	/* store sectors/cylinder */      call put_info(dev, 0, i#tot_cyl,  buf(ptr + s#totcyl));	/* store total cylinders */      call put_info(dev, 0, i#imi_adr,  buf(ptr + s#devadr));	/* store device address */      call put_info(dev, 0, i#scsi_adr, buf(ptr + s#devadr));	/* store device address (again) */      ptr = ptr + s#blklen; /* next configuration entry */   end get_optical;   ptr = contab + c#strdev; /* start at beginning of storage device table */   do while (ptr ilt contab + c#strend) and (buf(ptr + s#devtyp) <> s#freblk); /* loop until free block encountered */      dev = get.device(buf(ptr + s#devtyp));	/* get device code for this device (e.g. 6 for W0, 10 for O0, etc. */      typ = (buf(ptr + s#devtyp) and "17");	/* get system device type (e.g. 1 = winch, 4 = optical, etc. */      if (typ >= 0) and (typ <= 4) /* known device type */      then do case typ; /* branch depending on device */         call get_floppy(dev);     /* 0: floppy */         call get_winchester(dev); /* 1: winchester */         call get_floppy(dev);     /* 2: remote */         call get_tape(dev);       /* 3: tapes */         call get_optical(dev);    /* 4: optical */      end; /* case */      else ptr = ptr + s#blklen; /* unknown type, so skip to next configuration entry */   end; /* while free block not yet encountered */end get_device_config;/* $SUBTITLE Verify configuration */count_devices: proc returns (fixed); /* count the number of devices currently configured */   dcl count fixed; /* number of devices found */   dcl i     fixed;   count = 0; /* no devices found yet */   do i = 0 to i#entry_max - 1; /* loop over all entries in Dev_Info */      if (dev_info(i*i#entry_size) and "377") <> 0  /* device is configured */      then count = count + 1; /* another device found */   end;   return (count); /* return number of devices found */end count_devices;/* This procedure returns the following error codes:   0:  No error   1:  IMI and SCSI drives mixed on same device   2:  Duplicate device address   3:  Device address of W0 (1) is not the standard   4:  All drives on a device do not have the same D24 number	5:	 Optical SCSI address conflicts with Winchester address	6:	 Optical addresses conflict*/check_winchesters: proc returns (fixed); /* make sure Winchester configuration is valid */   dcl dev    fixed; /* device to look at */   dcl type   fixed; /* 0: IMI, 1: SCSI */   dcl drive  fixed; /* physical drive on the device */   dcl devadr fixed; /* Winchester device address */   dcl d24    fixed; /* D24 number of first drive */   dcl (i,j)  fixed;   do j = 0 to 5*8*8 - 1; used_controllers (j) = false; end; /* no controllers have been assigned */   do dev = i#W0 to i#W1; /* do for all Winchester devices */      		i = get_info(dev,0,i#dev_type); /* get config info for first drive on this device */      		if (i and "377") <> 0 then do; /* if device is configured */         type = shr(i,8);            /* get IMI or SCSI Winchester type */         if dev = i#W0 then do; /* make sure W0 has proper configuration */            if ((type = 0) and (get_info(dev,0,i#imi_adr)  <> W0_IMI_Adr)) /* IMI but not correct address */            or ((type = 1) and (get_info(dev,0,i#scsi_adr) <> W0_SCSI_Adr)) /* SCSI but not correct address */            then return (3); /* return error flag */         end;                  if type = 1 then d24 = shr(get_info(dev,0,i#scsi_adr),4) and "HF"; /* get d24 number */         do drive = 0 to i#num_wins - 1; /* do for all other drives on the device */            				j = get_info(dev,drive,i#dev_type); /* get config info for this drive */             				if ((j and "377") <> 0) then do; /* drive is configured */               j = shr(j,8); /* get IMI/SCSI flag */               if j = type then do; /* this drive is the same type as the first drive */                  if j = 0 /* IMI? */                  then devadr = get_info(dev,drive,i#imi_adr); /* get IMI device address */                  else devadr = get_info(dev,drive,i#scsi_adr); /* get SCSI device address */                  if (j = 1) and (d24 <> (shr(devadr,4) and "HF")) /* SCSI drive with different D24 number from first drive */                  then return (4); /* must have same D24 number, so return error */                  if not used_controller(devadr,j) /* device address not already allocated */                  then call set_controller(devadr,j,true); /* allocate this new device address */                  else return (2); /* device already allocated, so return error flag */               end;               else return (1); /* not same type, so return error flag */            end; /* drive is configured */         end; /* looping over drives */      end; /* if device is configured */   end; /* do for all Winchester devices */   do dev = i#O0 to i#O1; /* do for all optical devices */      		i = get_info(dev, 0, i#dev_type);		/* get config info for first drive on this device */      		if (i and "377") <> 0 then do;			/* if device is configured */         			devadr = get_info(dev, 0, i#scsi_adr); /* get SCSI device address */                  if (used_controller(devadr, 1) != 0)				return (5);								/* must conflict with a winchester */     	   end;												/* if device is configured */   end;													/* do for all Optical devices */   do dev = i#O0 to i#O1; /* do for all optical devices */      		i = get_info(dev, 0, i#dev_type);		/* get config info for first drive on this device */      		if (i and "377") <> 0 then do;			/* if device is configured */         			devadr = get_info(dev, 0, i#scsi_adr); /* get SCSI device address */                  if (used_controller(devadr, 1) != 0)				return (6);								/* must conflict with other optical */     					call set_controller(devadr, 1, true);	   end;												/* if device is configured */   end;													/* do for all Optical devices */   return (0); /* no errors occurred, so configuration is valid! */end check_winchesters;/* $SUBTITLE Save the device configuration */save_device_config: proc; /* put device info in config buffer */   dcl dev      fixed; /* device found */   dcl drive    fixed; /* drive on this device */   dcl ptr      fixed; /* pointer into device table */   assign_conf: proc(dev,config); /* assign configuration */      dcl dev     fixed; /* device to reconfigure */      dcl config  fixed array; /* new configuration */      dcl i       fixed;      do i = 0 to s#blklen - 1; /* copy the configuration over */         buf (ptr + i) = config (i);      end;      buf (ptr + s#devtyp) = ((buf (ptr + s#devtyp) and (not "377")) or get_devtyp (dev)); /* set device */      ptr = ptr + s#blklen; /* next configuration entry */   end assign_conf;   store_floppy: proc(dev); /* store the floppy configuration */      dcl dev         fixed; /* device to store */      dcl floppy.type fixed; /* type of floppy to store */      dcl floppy_config(s#blklen - 1) fixed; /* array for config info */      floppy.type = (get_info(dev,0,i#dev_type) and "377"); /* get floppy type */      if floppy.type = unknown then do; /* unknown floppy */         floppy_config (s#devtyp) = get_info(dev,0,i#dev_type); /* store device type */         floppy_config (s#seccyl) = get_info(dev,0,i#sec_cyl);  /* store sectors/cylinder */         floppy_config (s#totcyl) = get_info(dev,0,i#tot_cyl);  /* store total sectors */         floppy_config (s#spdtrk) = get_info(dev,0,i#imi_adr);  /* store speed/sectors per track */         call assign_conf (dev, floppy_config); /* store this information */      end;      else do case (floppy.type); /* update config */         ;                                    /* 0: no floppy configured! */         call assign_conf (dev, smin_config); /* 1: Super Mini */         call assign_conf (dev, dmin_config); /* 2: DD Mini */         call assign_conf (dev, maxi_config); /* 3: 8-inch Maxi */         call assign_conf (dev, mini_config); /* 4: SD Mini */      end; /* of updating config */   end store_floppy;   store_winchester: proc(dev); /* store the Winchester configuration */      dcl dev      fixed; /* device to store */      dcl drive    fixed; /* drive on this device */      dcl win_type fixed; /* device type to store */      dcl win_config(s#blklen - 1) fixed; /* array for config info */      do drive = 0 to i#num_wins - 1; /* loop over all possible drives on this device */         if  ((get_info(dev,drive,i#dev_type) and "377") <> 0) /* drive found */         and (ptr ilt contab + c#strend) then do; /* and still room in config table */            win_type = get_info(dev,drive,i#dev_type); /* get type of winchester to store */            win_config (s#devtyp) = win_type and "HFF00"; /* store IMI/SCSI flag */            if shr(win_type,8) = 0 then do; /* IMI drive, so use info in tables */               win_config (s#seccyl) = win_cyl (type_to_IMI(win_type and "377")); /* get sectors/cylinder from table */               win_config (s#totcyl) = win_siz (type_to_IMI(win_type and "377")); /* got total cylinders from table */            end;            else do; /* SCSI or unknown type - use whatever was in configuration already */               win_config (s#seccyl) = get_info(dev,drive,i#sec_cyl); /* store sectors/cylinder */               win_config (s#totcyl) = get_info(dev,drive,i#tot_cyl); /* store total cylinders */            end;            if shr(win_type,8) = 0 /* IMI? */            then win_config(s#devadr) = get_info(dev,drive,i#imi_adr); /* store IMI device address */            else win_config(s#devadr) = get_info(dev,drive,i#scsi_adr); /* store SCSI device address */                        call assign_conf (dev,win_config); /* store this info in config buffer */         end;      end;   end store_winchester;   store_tape: proc(dev); /* store tape configuration */      dcl dev       fixed; /* device to store */      dcl tape_type fixed; /* type of tape to store */      dcl tape_config(s#blklen - 1) fixed; /* array for config info */      tape_type = (get_info(dev,0,i#dev_type) and "377"); /* get tape type */      if tape_type = unknown then do; /* unknown tape */         tape_config (s#devtyp) = get_info(dev,0,i#dev_type); /* store device type */         tape_config (s#seccyl) = get_info(dev,0,i#sec_cyl);  /* store sectors/cylinder */         tape_config (s#totcyl) = get_info(dev,0,i#tot_cyl);  /* store total sectors */         tape_config (s#devadr) = get_info(dev,0,i#imi_adr);  /* store device address */         call assign_conf (dev, tape_config); /* store this information */      end;      else do case (tape_type); /* update config */         ;   /* 0: no tape configured! */         do; /* 1: Kennedy configuration */            tape_config (s#devtyp) = 0;   /* kennedy drive */            tape_config (s#seccyl) = 464; /* blocks / track */            tape_config (s#totcyl) = 4;   /* number of tracks */            tape_config (s#devadr) = 0;   /* reserved */            call assign_conf (dev, tape_config); /* Kennedy 1/4" cartridge */         end;         do; /* 2: SCSI configuration */            tape_config (s#devtyp) = shl(1,8); /* SCSI drive */            tape_config (s#seccyl) = 17024; /* blocks / track */            tape_config (s#totcyl) = 1;   /* number of tracks */            tape_config (s#devadr) = get_info(dev,0,i#scsi_adr); /* SCSI device address */            call assign_conf (dev, tape_config); /* SCSI 1/2" reel */         end;      end; /* of updating config */   end store_tape;   store_optical: proc(dev); /* store optical configuration */      dcl dev       fixed; /* device to store */      dcl opt_type fixed; /* type of tape to store */      dcl opt_config(s#blklen - 1) fixed; /* array for config info */      opt_type = (get_info(dev,0,i#dev_type) and "377"); /* get optical type */      		if opt_type = unknown then do; /* unknown type */         opt_config (s#devtyp) = get_info(dev,0,i#dev_type); /* store device type */         opt_config (s#seccyl) = get_info(dev,0,i#sec_cyl);  /* store sectors/cylinder */         opt_config (s#totcyl) = get_info(dev,0,i#tot_cyl);  /* store total sectors */         opt_config (s#devadr) = get_info(dev,0,i#imi_adr);  /* store device address */         call assign_conf (dev, opt_config); /* store this information */      end;     	   else do case (opt_type); /* update config */         ;   /* 0: no optical configured */         do; /* 1: CDC 12-inch optical */            opt_config (s#devtyp) = shl(1,8);	/* SCSI drive */            opt_config (s#seccyl) = 1000;			/* values to get correct size */            opt_config (s#totcyl) = 2048;             opt_config (s#devadr) = get_info(dev,0,i#scsi_adr); /* SCSI device address */            call assign_conf (dev, opt_config);         end;         do; /* 2: 5-inch M/O optical device */            opt_config (s#devtyp) = (shl(1,8) or shl(1,10));		/* Bit 10:Magneto optical, Bit 8:SCSI */            opt_config (s#seccyl) = 144;									/* reasonable size for a 1-gig media */            opt_config (s#totcyl) = 6815;            opt_config (s#devadr) = get_info(dev,0,i#scsi_adr);	/* SCSI device address */            call assign_conf (dev, opt_config);         end;      end; /* of updating config */   end store_optical;   buf (contab + c#curdev) = get_devtyp (curdev); /* set current device */   ptr = contab + c#strdev; /* start at beginning of storage device table */   /* Store system device first */   if sysdev = i#F0 /* is system device a floppy? */   then call store_floppy(i#F0); /* save F0 configuration first */   else call store_winchester(i#W0); /* save W0 configuration first */   /* Store all the other devices */   do dev = i#F0 to i#O1; /* loop over all possible devices (floppy, remote, winchester, tape, optical) */      if  ((get_info(dev,0,i#dev_type) and "377") <> 0) /* if device is there */      and (dev <> sysdev) /* and its not the system device (already saved above) */      and (ptr ilt contab + c#strend) then do; /* and there is room in config table */         do case (get_devtyp(dev) and "17"); /* branch depending on device */            call store_floppy(dev);     /* 0: store floppy */            call store_winchester(dev); /* 1: store winchester */            call store_floppy(dev);     /* 2: store remote floppy */            call store_tape(dev);       /* 3: store tape */            call store_optical(dev);    /* 4: store optical */         end; /* case */      end; /* inserting device in table */   end; /* looping over all devices */   do while ptr ilt contab + c#strend; /* loop over any remaining entries */      buf(ptr) = s#freblk; /* set to free block */      ptr = ptr + 1;   end;end save_device_config;