/*New England Digital CorporationAudio testing programSept 1986, Bill LeathersModification History:   05/17/90  - WSL added configuration statement for Model D compilation   07/11/89  - WSL corrected 50.5 KHz limit for PRM chans C & D   06/01/89  - WSL corrected 2's comp math for extended memory PSPA2               also required modifications to polylib3*/configuration modelc, MULDIV;insert ':-xpl:syslits';insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:plotlib';insert ':-xpl:intrprtr';insert ':newdiags:AUDIOCAT:04-angle';insert ':newdiags:AUDIOCAT:04-ifast';insert ':newdiags:AUDIOCAT:40-windo';insert ':newdiags:sysinit';insert ':newdiags:AUDIOCAT:polylib3';insert ':newdiags:datelit';/* these dcls/lits pertain to the analogic upgrade */dcl bin# lit '0';/*dcl daughter_type fixed */;dcl ned_daughter lit '0';dcl analogic_daughter lit '1';/* end of dcls/lits for analogic upgrade */dcl vt640.term     lit '0';dcl pericom.term   lit '1';dcl pericom.punits          lit '1023,779';dcl pericom.max.view        lit '0,1023,0,779';dcl pericom.yhash.view      lit '95,1023,98,779';dcl pericom.xhash.view      lit '102,1023,93,779';dcl pericom.border.view     lit '102,1023,98,779';dcl pericom.graph.view      lit '103,1022,99,778';dcl pericom.dots.in.x.axis  lit '920';dcl pericom.x.dots.per.div  lit '46';dcl vt640.punits            lit '640,480';dcl vt640.max.view          lit '0,639,0,479';dcl vt640.yhash.view        lit '54,639,48,479';dcl vt640.xhash.view        lit '56,639,44,479';dcl vt640.border.view       lit '56,639,48,479';dcl vt640.graph.view        lit '59,638,49,478';dcl vt640.dots.in.x.axis    lit '580';dcl vt640.x.dots.per.div    lit '29';dcl sindata data (  0,    201,  402,  603, 804, 1005, 1206, 1407, 1608, 1809, 2009, 2210, 2411, 2611, 2811, 3012, 3212, 3412, 3612, 3812, 4011, 4211, 4410, 4609, 4808, 5007, 5205, 5404, 5602, 5800, 5998, 6195, 6393, 6590, 6787, 6983, 7180, 7376, 7571, 7767, 7962, 8157, 8351, 8546, 8740, 8933, 9127, 9319, 9512, 9704, 9896,10088,10279,10469,10660,10850,11039,11228,11417,11605,11793,11980,12167,12354,12540,12725,12910,13095,13279,13463,13646,13828,14010,14192,14373,14553,14733,14912,15091,15269,15447,15624,15800,15976,16151,16326,16500,16673,16846,17018,17190,17361,17531,17700,17869,18037,18205,18372,18538,18703,18868,19032,19195,19358,19520,19681,19841,20001,20160,20318,20475,20632,20788,20943,21097,21251,21403,21555,21706,21856,22006,22154,22302,22449,22595,22740,22884,23028,23170,23312,23453,23593,23732,23870,24008,24144,24279,24414,24548,24680,24812,24943,25073,25202,25330,25457,25583,25708,25833,25956,26078,26199,26320,26439,26557,26674,26791,26906,27020,27133,27246,27357,27467,27576,27684,27791,27897,28002,28106,28209,28311,28411,28511,28610,28707,28803,28899,28993,29086,29178,29269,29359,29448,29535,29622,29707,29792,29875,29957,30038,30118,30196,30274,30350,30425,30499,30572,30644,30715,30784,30853,30920,30986,31050,31114,31177,31238,31298,31357,31415,31471,31527,31581,31634,31686,31737,31786,31834,31881,31927,31972,32015,32058,32099,32138,32177,32214,32251,32286,32319,32352,32383,32413,32442,32470,32496,32522,32546,32568,32590,32610,32629,32647,32664,32679,32693,32706,32718,32729,32738,32746,32753,32758,32762,32766,32767,32767, 0,  6, 13, 19, 25, 31, 38, 44, 50, 57, 63, 69, 75, 82, 88,94,101,107,113,119,126,132,138,145,151,157,163,170,176,182,188,195,201,207,214,220,226,232,239,245,251,258,264,270,276,283,289,295,302,308,314,320,327,333,339,346,352,358,364,371,377,383,390,396,  0);dcl impulse.data data ( 00000, 32626, 04608, 05525, 06791, 00234, 05799, 00354, 02944, 02119, 00453, 03018,-00232, 02235, 00656, 00639, 01725,-00347, 01775,-00081, 00788, 00856,-00295, 01351,-00505, 00854, 00173,-00164, 00903,-00743, 00849,-00401, 00000, 00401,-00849, 00743,-00903, 00164,-00173,-00854, 00505,-01351, 00295,-00856,-00779, 00081,-01775, 00347,-01725,-00639,-00656,-02235, 00232,-03018,-00453,-02119,-02944,-00354,-05799,-00234,-06791,-05525,-04608,-32626 );dcl menu.max lit 'asc.c';dcl sample.rate      lit '50000'; /* sample rate in Hz              */dcl half.sample.rate lit '25000';dcl fft.len        fixed;dcl wave.len       lit 'fft.len'; /* length of waveform to generate */dcl low.freq  lit '390';dcl buf     (8192) fixed;       /* buffer to hold samples & FFT coefficients */dcl ebuf    (4096) fixed;dcl avgbuf  (4096) floating;dcl (i,j,k)        fixed;dcl stm.sample.mode fixed;dcl (ppi,pinc,pmod) fixed;dcl (spi,sinc,smod) fixed;dcl (chr,cmd) fixed;dcl freq fixed;dcl first.pass boolean;dcl sweep.stopped boolean;dcl sweeping      boolean;dcl peak.track    boolean;dcl cursor.on     boolean;dcl (old.x.cursor,old.y.cursor,new.x.cursor,new.y.cursor) fixed;dcl (old.x.cursor.val,old.y.cursor.val,new.x.cursor.val,new.y.cursor.val) floating;dcl (graph.x.min,graph.x.max,graph.y.min,graph.y.max) fixed;dcl (graph.x.division,graph.y.division) fixed;dcl (hz.per.buf.cell) floating;dcl (ms.per.buf.cell) floating;dcl (spect.x.start,spect.x.stop,spect.y.bottom,spect.y.top) fixed;dcl (spect.x.min,  spect.x.max, spect.y.min,   spect.y.max) fixed;dcl (time.x.start,time.x.stop) floating;dcl (time.x.min,time.x.max)    floating;dcl (time.y.bottom,time.y.top) floating;dcl (time.y.min,time.y.max)    floating;dcl stm.channel fixed;dcl stm.gain    fixed;dcl ad.input.type fixed;dcl num.daughters fixed;dcl mono.sampling     lit '0';dcl sample.to.memory  lit '1';dcl input.off         lit '2';dcl poly.voices       lit '0';dcl trace.type      fixed;dcl spectral.trace  lit '0';dcl time.trace      lit '1';dcl num.averages    fixed;dcl millivolts.per.bit lit '.15259256';dcl millivolts floating;fft.len = 1024;hz.per.buf.cell = half.sample.rate / shr(fft.len,1);spect.x.start = 0;       spect.x.stop = 20000;spect.x.min   = 0;       /*spect.x.max  = shr(fft.len,1);*/spect.x.max = int(spect.x.stop / hz.per.buf.cell);spect.y.bottom = -150;   spect.y.top   = 0;    spect.y.min    = -15000; spect.y.max   = 0;graph.x.min = spect.x.min;graph.x.max = spect.x.max;graph.y.min = spect.y.min;graph.y.max = spect.y.max;ad.input.type = sample.to.memory;stm.channel = 0;trace.type = spectral.trace;num.averages = 1;cursor.on = true;dcl tvt640 lit '"43"';dcl tmg600 lit '"143"';dcl term.type  fixed;if terminal.model = tvt640 then term.type = vt640.term;else term.type = pericom.term;if term.type = pericom.term then do;  punits(pericom.punits);  viewport(pericom.max.view);   iwindow(pericom.max.view);end;else do;  punits(vt640.punits);  viewport(vt640.max.view);   iwindow(vt640.max.view);end;if #_poly_mbytes(bin#) = 0 then do;   print 'No poly memory.';   call exit(0);end;num.daughters = #_daughters(bin#);daughter_type(bin#) = ned_daughter;   stm.gain = 1; /* unity gain */if #_daughters(bin#) > 0 then  if (ad_config(bin#) & "H8000") <> 0 then do;     daughter_type(bin#) = analogic_daughter;     stm.gain = 0;  /* unity gain(db) */  end;dcl output.mode fixed;dcl output.off  lit '0';dcl output.poly lit '1';dcl output.fm   lit '2';dcl current.channel fixed;dcl (current.volume,current.user.volume)  fixed;dcl current.poly.khz     floating;dcl current.stm.khz      floating;dcl (stm.max.chan,poly.min.chan,poly.max.chan) fixed;dcl pan fixed;dcl wave.type fixed;  dcl sine.100k           lit '0';  dcl sine.100k.6bit      lit '1';  dcl random.wave         lit '2';  dcl multi.harm          lit '3';stm.max.chan      = (2 * num.daughters) - 1;if num.daughters = 0 then poly.min.chan = 0;else poly.min.chan = 1;poly.max.chan = #_poly_voices(bin#) - 1;current.channel   = poly.min.chan;current.volume    = 4095;              /* max poly volume */current.user.volume = 100;current.poly.khz  = 50.0;  ppi = 1; pinc = 99; pmod = 200;            /* phase increment of 1    */current.stm.khz = 50;  spi = 1; sinc = 99; smod = 200;  ms.per.buf.cell = 1 / current.stm.khz;time.x.start = 0.0;  time.x.stop = (shr(fft.len,1) * ms.per.buf.cell);time.x.min   = time.x.start / ms.per.buf.cell; time.x.max   = time.x.stop  / ms.per.buf.cell;time.y.bottom  = -5.0;  time.y.top    = 5.0;time.y.min     = (time.y.bottom / millivolts.per.bit) * 1000;time.y.max     = (time.y.top    / millivolts.per.bit) * 1000;wave.type = 0;stm.sample.mode = 0;dcl cursor.increment fixed;dcl clock.ticks fixed; clock.ticks = 0;dcl last.chr fixed; last.chr = 0;write("3") = 0; write("3") = 0;cursor.increment = 1;/***************************************************************************/when d03int then begin;  dcl max.clk fixed;  if sweep.stopped then do;    if term.type = pericom.term then max.clk = 50;  /* was 50 */    else max.clk = 100;  /* 100 */    clock.ticks = clock.ticks + 1;    if clock.ticks > max.clk then do;      last.chr = 0; clock.ticks = 0;    end;  end;end;/***************************************************************************/get_fnum: proc(integer.length,fraction.length) returns (floating);  dcl (length,integer.length,fraction.length) fixed;  dcl input.string(10) fixed;  dcl (i,j,k) fixed;  dcl value floating;  dcl place.value floating;  dcl (chr,point.mark,digit.count) fixed;  dcl (integer.found,fraction.found,invalid.entry,negative) boolean;  length = integer.length + fraction.length + 3;  get_string('',1,input.string,length);  negative = false;  invalid.entry = false;  integer.found = true;  fraction.found = true;   value = 0.0;  i = 0;    chr = -1;              point.mark = -1;  do while (i < input.string(0)) & (chr <> dot);    chr = byte(input.string,i);    if chr = dot then point.mark = i;    if chr = asc.min then do;      negative = true;      call pbyte(input.string,i,sp);    end;    i = i + 1;  end;  if (point.mark < 0) or (point.mark = input.string(0) - 1)    then fraction.found = false;  if point.mark = 0 then integer.found = false;  digit.count = 0;  place.value = 1.0;  value = 0.0;   if integer.found then do;    if point.mark < 0 then do;      i = input.string(0) - 1;      do while byte(input.string,i) = sp;        i = i - 1;      end;    end;    else i = point.mark - 1;    do while (i >= 0) & (not invalid.entry);      chr = byte(input.string,i);      if chr = sp then i = -1;      else do;        if (chr >= asc.0) & (chr <= asc.9)          then value = value + (( chr - "60") * place.value);        else invalid.entry = true;        place.value = place.value * 10;        digit.count = digit.count + 1;      end;      i = i - 1;      if digit.count > integer.length then invalid.entry = true;    end;  end;  if fraction.found & (not invalid.entry) then do;    digit.count = 0;    place.value = .10;    i = point.mark + 1;    do while (i < input.string(0)) & (not invalid.entry);      chr = byte(input.string,i);      if chr = sp then i = input.string(0);      else do;        if (chr >= asc.0) & (chr <= asc.9)          then value = value + (( chr - "60") * place.value);        else invalid.entry = true;        place.value = place.value / 10;        digit.count = digit.count + 1;      end;      i = i + 1;      if digit.count > fraction.length then invalid.entry = true;    end;  end;  if invalid.entry then value = 0.0;  if negative then value = 0.0 - value;  return value;end get_fnum;/***************************************************************************/dcl set_stm_gain lit 'call #set_stm_gain';#set_stm_gain: proc(channel,gain) fixed;  dcl (channel,gain) fixed;  dcl mult    fixed; /* multiplier to write to A/D */  dcl multiplier data (4, 1,    3,     9,    27); /* table of multipliers */  dcl mult_value data (4, 0, "40", "140", "340"); /* values to write to A/D */  dcl chr fixed;  if daughter_type(bin#) = analogic_daughter then gain = gain + 3;  else do;   /* NED daughter */     mult = 1;     do while ((mult <= multiplier (0)) and (gain >= multiplier (mult))); /* find multiplier */       mult = mult + 1;     end;     mult = mult - 1;                         /* point to correct multiplier */     gain = mult_value (mult) + 16*gain/multiplier (mult) - 16; /* get A/D gain */  end;  write(psc) = channel;                              /* select A/D channel */  write(psf) = psadvol;                              /* set gain */  write(psd) = gain;   end #set_stm_gain;/***************************************************************************/dcl set.poly.rate lit 'call hzcomp';hzcomp: proc(khz,rate.type);  /* program to compute frequency table for Live Overdub */dcl (khz)     floating;dcl rate.type fixed;dcl (i,j,k,l) fixed;dcl (inc,div) fixed;dcl (error)   floating;dcl (bestinc) fixed;dcl (bestdiv) fixed;dcl (besterr) floating;compute.rate:proc(inc,div) floating;   /* khz = (10000*inc)/(99*div); */   dcl (inc,div) fixed;   return (10000.0*inc)/(99.0*div);end compute.rate;bestinc=0; bestdiv=0; besterr=0;do div=175 to 225;       /* limit divisor range to avoid increment/remainder problems */   inc=int(khz*99.0*div/10000.0);   do i=0 to 1;          /* try inc, inc+1       */      if inc>div then inc=div;    /* limit to max */      error=abs(compute.rate(inc,div)-khz);      if bestdiv=0 then do;       /* first one     */         bestinc=inc;         bestdiv=div;         besterr=error;      end;      else if error<besterr      then do;         bestinc=inc;         bestdiv=div;         besterr=error;      end;      inc=inc+1;   end;end;if rate.type = sample.to.memory then do;  sinc = inc; smod = div;end;else do;  pinc = inc;  pmod = div;end;end hzcomp;/***************************************************************************/dcl (randomlsb,randommsb) fixed; /* seed for random number generator *//* initialize seed to 123457 */randommsb=1;randomlsb=57921;randomgen:proc fixed; /* returns random deviate -32768 to 32767 */  /*  A linear congruential generator with multiplier 16807 and modulus      2**31-1.  These are the same values as the IMSL routine GGUBS,      and the same logic is used, but RANDOMGEN is implemented in       fixed point.  RANDOMMSB and RANDOMLSB are the most and least       significant bits of the seed. */   dcl root lit '16807';   dcl msb  lit 'randommsb';   dcl lsb  lit 'randomlsb';   dcl x    fixed;   write(5)=root;   write(6)=lsb;   x=read(4);   lsb=read(5);   write(5)=root;   write(6)=msb;   msb=x+read(5);   if msb ilt read(5) then x=shl(read(4)+1,1); /* carry */   else                    x=shl(read(4),1);  /* no carry */   x=x+((msb&"100000")<>0); /* add most sig. bit of msb */   lsb=lsb+x; /* adjust modulus by multiple of 2**31-1 */   if lsb ilt x then msb=msb+1; /* carry */   msb=msb&"077777"; /* mod 2**31 */   return (shl(msb,1)+((lsb&"100000")<>0));end randomgen;/***************************************************************************/dcl load.random.wave lit 'call load.rwave';load.rwave: proc;  dcl (i,j,k,sec.cnt) fixed;  call psmwrite(70,0);  do sec.cnt = 70 to 2047;    do i = 0 to 255;      k = randomgen;      write(psd) = k;    end;  end;  pos(18,10); erase_line;end load.rwave;/***************************************************************************/dcl set.random.wave lit 'call set.rwave';set.rwave: proc;  dcl (i,j,k) fixed;  do j = 0 to 63;     WRITE(PSC)= I+J; WRITE(PSF)=PSWL;     WRITE(PSD)=  -8192; WRITE(PSD) = "HFF00";   /* wave table length of 256 */     WRITE(PSD)=   70; WRITE(PSD) = 0;      /* base address of 70    */     WRITE(PSD)=  -8122; WRITE(PSD) = "HFF00";   /* loop length of 256       */     write(psd) = 0;  write(psd) = ppi;  /* phase increment of PI */     write(psd) = pinc - 1;      write(psd) = 256 - pmod; /* increment of INC/modulus of MOD (if MOD = 2, 50 kHz) */     WRITE(PSD)=   0;                  /*  OFF NO LOOP           */  end;end set.rwave;/***************************************************************************/poly.turn.off: proc(chan);  dcl chan fixed;  dcl (i,j,k) fixed;  if current.channel = (poly.max.chan + 1) then do;    do i = 0 to poly.max.chan;      write(psc) = i;      write(psf) = pselim;      write(psd) = 0;        write(psd) = 0;   /* Zero envelope */      write(psf) = psrcvol;      write(psd) = 0;        write(psd) = 0;   /* Zero volume */      write(psd) = 0;        write(psd) = 0;      write(psf) = pson;                       /* on/off function */      write(psd) = 0;                          /* off */    end;  end;  else do;    write(psc) = chan;    write(psf) = pselim;    write(psd) = 0;        write(psd) = 0;   /* Zero envelope */    write(psf) = psrcvol;    write(psd) = 0;        write(psd) = 0;   /* Zero volume */    write(psd) = 0;        write(psd) = 0;    write(psf) = pson;                       /* on/off function */    write(psd) = 0;                          /* off */  end;end poly.turn.off;/***************************************************************************/poly.turn.on: proc(chan,pan,vol,env);    dcl (chan,pan,vol,env) fixed;    dcl (l.vol,r.vol) fixed;    l.vol = 0; r.vol = 0;    if pan = 0 then l.vol = vol;    else r.vol = vol;    if pan = -1 then l.vol = vol;    write(psc) = chan;    write(psf) = pselim;    write(psd) = env;    write(psd) = env;    write(psf) = psrcvol;    write(psd) = r.vol;  write(psd) = l.vol;    write(psd) = r.vol;  write(psd) = l.vol;    write(PSF) = 10;  write(PSD) = 3;           end poly.turn.on;/***************************************************************************/dcl mono.sample lit 'call mono.samp';mono.samp: proc;    dcl (i,j) fixed;    write("66") = "11";    /* select card 0, control register (1)     */    write("67") = "370";   /* disable time base, initialize dac & adc */    write("67") = "0";     /* keep control register normally at zero  */    write("66") = "12";    /* select card 0, divisor register         */    write("67") = 598;     /* set up for 50 Khz sampling              */    write("66") = "15";    /* select card 0, clear input buffer       */    write("67") = 0;       /* purge input buffer                      */    write("66") = "11";    /* select control register                 */    write("67") = "1";     /* start time base & enable input          */    write("66") = "10";    /* select card 0 data register             */    do i = 0 to 9;      j = read("67");      /* toss 1st 10 samples */    end;    i = 0;    do while i ilt fft.len;  /* copy data into buffer                   */      buf(i) = read("67");      i = i + 1;    end;    write("66") = "11";    /* select control register                 */    write("67") = 0;       /* stop the converter                      */end mono.samp;/***************************************************************************/dcl stm.sample lit 'call stm.samp';stm.samp: proc(channel);  dcl (channel)     fixed;  dcl (i,j,sample.sectors)    fixed;  dcl channels lit '1'; /* number of A/D channels */  dcl (poly_address, AD_channel) fixed;  dcl (incr, modulus)                fixed;  do k = 0 to 15 by 4;         /* do once for each box */    write(psc) = k;            /* deactivate all channels */    write(psf) = psadact;    write(psd) = 0;  end;  if ^prm_exists(bin#) then do;  /* if no PRM */    if (stm.sample.mode = 1) & ((channel mod 4) > 0)  /* sample rate > 50 KHz & chan B*/     then channel = channel + 1;  /* really use C (sort of) */  end;  sample.sectors = (fft.len / 256) + 1; /* 1 xtra sector */  poly_address = 0; /* sector address of where to store sampled data */  AD_channel = channel;   incr = sinc; modulus = smod;   /*if ^prm_exists(bin#) then call ps_setmode (0); @@ just in case */  /*else */  call ps_setmode (stm.sample.mode);  /* set mode to 2 channel, no autogain */  call ps_actchan (AD_channel, channels); /* activate the channel */  set_stm_gain(AD_channel,stm.gain);   call ps_wave (0, sample.sectors, poly_address); /* set up wave table (use channel zero) */  call ps_freq (0, 1, incr, modulus); /* set up channel for phase increment of one */  call ps_maxchan (channels, 0); /* turn on the A/D channels again */  call ps_on (0, 1); /* turn channel back on without looping */  do while ps_ron(0);  end;         call ps_on (0, 0); /* turn channel zero off */  call ps_maxchan (0, 0); /* turn off A/D */  call psmread(0,0);  do i = 0 to 9; j = read(psd); end;  /* discard trash samples */  do i = 0 to fft.len;    buf(i) = read(psd);  end;end stm.samp;/***************************************************************************/dcl display.menu lit 'call menu';menu: proc;   clear;   transparent_mode;   clear_screen;   pos(2,25); pstring('Audio Testing Program ');   display_release_date;   pos(3,25); pstring('--------------------------------');   pos(5,25);  pstring('A.  Sweep');   pos(6,25);  pstring('B.  Set up');   pos(18,10); pstring('Enter a command letter or press <BREAK> to exit. ');end menu;/***************************************************************************/dcl setup.channel lit 'call setup.chan';setup.chan: proc;  dcl (i,j,k) fixed;  dcl nop lit 'i = i';  call psmwrite(64,0);  do i=0 to 255;     do case wave.type;      write(psd)=int((32767*sin(i*2*3.14159265/256))); /* 100k sine wave  */      write(psd)=int((31*sin(i*2*3.14159265/256)));    /* 100k 6 bit sine */      nop;      /* random wave */      if i < 64 then write(psd) = impulse.data(i);      else write(psd) = 0;    end; /* case */  end;  if wave.type < 2 then   do j = 0 to 63;     WRITE(PSC)= I+J; WRITE(PSF)=PSWL;     WRITE(PSD)=  -1; WRITE(PSD)="HFF00";   /* wave table length of 256 */     WRITE(PSD)=  64; WRITE(PSD)=0;         /* base address of 64        */     WRITE(PSD)=  -1; WRITE(PSD)="HFF00";   /* loop length of 256       */     write(psd) = 0;  write(psd) = ppi;     /* phase increment of PI */     write(psd) = pinc - 1;      write(psd) = 256 - pmod; /* increment of INC/modulus of MOD (if MOD = 2, 50 kHz) */     WRITE(PSD)=   0;                  /*  OFF NO LOOP           */  end;  if wave.type = 2 then do j = 0 to 63;    WRITE(PSC)= I+J; WRITE(PSF)=PSWL;    WRITE(PSD)=  -1977; WRITE(PSD)= "HFF00";   /* wave table length of 256 */    WRITE(PSD)=   70; WRITE(PSD)=0;      /* base address of 70    */    WRITE(PSD)=  -1977; WRITE(PSD)= "HFF00";   /* loop length of 256       */    write(psd) = 0;  write(psd) = ppi;  /* phase increment of PI */    write(psd) = pinc - 1;     write(psd) = 256 - pmod; /* increment of INC/modulus of MOD (if MOD = 2, 50 kHz) */    WRITE(PSD)=   0;                  /*  OFF NO LOOP           */  end;  if wave.type = 3 then do j = 0 to 63;     WRITE(PSC)= I+J; WRITE(PSF)=PSWL;     WRITE(PSD)=  -1; WRITE(PSD)= -64;      WRITE(PSD)=  64; WRITE(PSD)=0;   /* base address of 64        */     WRITE(PSD)=  -1; WRITE(PSD)= -64;     write(psd) = 0;  write(psd) = ppi; /* phase increment of PI */     write(psd) = pinc - 1;      write(psd) = 256 - pmod; /* increment of INC/modulus of MOD (if MOD = 2, 50 kHz) */     WRITE(PSD)=   0;                  /*  OFF NO LOOP           */  end;  if output.mode = output.poly then do;    if current.channel = (poly.max.chan + 1) then do;      do i = poly.min.chan to poly.max.chan;        call poly.turn.on(i,pan,current.volume,4095);      end;    end;    else call poly.turn.on(current.channel,pan,current.volume,4095);  end;end setup.chan;/***************************************************************************/dcl sweep.setup lit 'call s.setup';s.setup: proc;  dcl (i,j,k,chr) fixed;  dcl nop lit 'i = i';  dcl left.c lit '22'; dcl right.c lit '62';  dcl current.field fixed;  /*************************************************************************/  dcl go.up lit 'call g.up';  g.up: proc;    current.field = current.field - 1;    if current.field <  0 then current.field =  0;    if current.field =  9 then current.field =  8;    if current.field = 16 then current.field = 15;  end g.up;  /*************************************************************************/  dcl go.down lit 'call g.down';  g.down: proc;    current.field = current.field + 1;    if current.field > 19 then current.field =  0;    if current.field =  9 then current.field = 10;    if current.field = 16 then current.field = 17;  end g.down;  /*************************************************************************/  dcl go.lr lit 'call g.lr';  g.lr: proc;    if current.field < 10 then current.field = current.field + 10;    else current.field = current.field - 10;    if current.field =  9 then current.field = 8;    if current.field = 16 then current.field = 4;  end g.lr;  /*************************************************************************/  clear;  current.field = 0;  transparent_mode;  pos(1,30); pstring('System setup');  pos(2,30); pstring('------------');  pos(3,6);  pstring('Input channels:');  pos(4,8);  pnum((2*num.daughters),2); pstring(' Sample-to-memory');  pos(7,6);  pstring('Current input:');  pos(7,left.c);   if ad.input.type = mono.sampling then pstring('Mono-Sampling');  else pstring('Sample-to-Memory');  pos(8,8);  pstring('Channel:');     pos(8,left.c + 1);    do case stm.channel;    pstring('1A'); pstring('1B'); pstring('1C'); pstring('1D');    pstring('2A'); pstring('2B'); pstring('2C'); pstring('2D');    pstring('3A'); pstring('3B'); pstring('3C'); pstring('3D');    pstring('4A'); pstring('4B'); pstring('4C'); pstring('4D');  end;  pos(9,8);  pstring('Sample rate:'); pos(9,left.c - 1);    fprint(current.stm.khz,3,3);        pstring(' kHz');  pos(10,8);  if daughter_type(bin#) = analogic_daughter then pstring('Gain (dB):');  else pstring('Gain:');          pos(10,left.c); pnum(stm.gain,3);  pos(16,6); pstring('Display type:'); pos(16,left.c);  if trace.type = spectral.trace then pstring('Spectral');  else pstring('Time    ');  pos(17,6); pstring('X-axis start:');  pos(18,6); pstring('X-axis stop:');  pos(19,6); pstring('Y-axis top:');    pos(20,6); pstring('Y-axis bottom:');   if trace.type = spectral.trace then do;    pos(17,left.c); pnum(spect.x.start,5);  pstring(' Hz');     pos(18,left.c); pnum(spect.x.stop,5);   pstring(' Hz');    pos(19,left.c); pnum(spect.y.top,5);    pstring(' dbr');     pos(20,left.c); pnum(spect.y.bottom,5); pstring(' dbr');   end;  else do;    pos(17,left.c); fprint(time.x.start,2,2);   pstring(' ms ');    pos(18,left.c); fprint(time.x.stop,2,2);    pstring(' ms ');    pos(19,left.c); fprint(time.y.top,2,2);     pstring('  V ');    pos(20,left.c); fprint(time.y.bottom,2,2);  pstring('  V ');  end;  /* Right column */  pos(3,46); pstring('Output channels:');  pos(4,48); pnum(#_poly_voices(bin#),2); pstring(' Poly sampling');  pos(7,46); pstring('Current output:'); pos(7,right.c);  do case output.mode;    pstring('Off ');    pstring('Poly'); pstring('FM  ');  end;  /* case */  pos(8,48); pstring('Wave type:'); pos(8,right.c);  do case wave.type;    pstring('100K sine      ');    pstring('100k 6-bit sine');    pstring('Random noise   ');    pstring('Impulse train  ');  end; /* case */  pos(9,48); pstring('Channel:'); pos(9,right.c);   if current.channel = (poly.max.chan + 1) then pstring(' All');  else pnum(current.channel,4);  pos(10,48); pstring('Pan: ');   pos(10,right.c);    if Pan = 0 then pstring('Left ');  else pstring('Right');  pos(11,48);       pstring('Sample rate:');    pos(11,right.c);  fprint(current.poly.khz,3,3);  pos(12,48);       pstring('Volume:');   pos(12,right.c);  pnum(current.user.volume,4);  pos(16,46);       pstring('FFT length:');  pos(16,right.c);  pnum(fft.len,4);  pos(17,46);       pstring('Number of avgs:');  pos(17,right.c);  pnum(num.averages,3);  pos(18,46);  pstring('Cursor:');  pos(18,right.c);  if cursor.on then pstring(' On ');  else pstring(' Off');  pos(7,left.c);  do forever;    chr = rchar; if (chr = 0) \ (chr = cr) then return;    if chr = cur.up    then go.up;    if chr = cur.down  then go.down;    if (chr = cur.left) or (chr = cur.right) then go.lr;    if chr = sp then do case current.field;      do; /* case 0 */        pos(7,left.c);        do case ad.input.type;          do; /* mono -> stm */            ad.input.type = sample.to.memory;            pstring('Sample-to-Memory');            poly.min.chan = 1;            if current.channel = 0 then do;              call poly.turn.off(current.channel);              current.channel = 1;              pos(9,right.c);               pnum(current.channel,4);              setup.channel;            end;            if current.channel = poly.max.chan + 1 then do;              call poly.turn.off(current.channel);              setup.channel;            end;          end;          do; /* stm -> off */            ad.input.type = input.off;            pstring('Off             ');            poly.min.chan = 0;          end;          do; /* off -> mono */            ad.input.type = mono.sampling;            pstring('Mono-Sampling   ');            poly.min.chan = 0;          end;        end; /* case */        pos(7,left.c);      end;      do; /* case 1 */        pos(8,left.c + 1);        stm.channel = (stm.channel + 1) mod 16;        if stm.channel > ((2 * num.daughters) - 1) then stm.channel = 0;        if ^prm_exists(bin#) then do;          if current.stm.khz > 50.0 then do;            if ((stm.channel mod 4) > 1) then stm.channel = stm.channel + 2;            if ((stm.channel mod 4) = 1) &                (stm.channel = ((2 * num.daughters)-1)) then stm.channel = 0;            if stm.channel > ((2 * num.daughters) - 1) then stm.channel = 0;          end;        end;        do case stm.channel;          pstring('1A'); pstring('1B'); pstring('1C'); pstring('1D');          pstring('2A'); pstring('2B'); pstring('2C'); pstring('2D');          pstring('3A'); pstring('3B'); pstring('3C'); pstring('3D');          pstring('4A'); pstring('4B'); pstring('4C'); pstring('4D');        end;        pos(8,left.c);      end;      do; /* case 2 */        pos(22,10); pstring('Enter new frequency in kHz: ');        current.stm.khz = get_fnum(3,3);        if current.stm.khz <  40.0 then current.stm.khz =  40.0;         if current.stm.khz > 101.0 then current.stm.khz = 101.0;        stm.sample.mode = 0;        if ^prm_exists(bin#) then do;  /* if no PRM */          if current.stm.khz > 50.5 then do;            if (stm.channel mod 4) < 2 then stm.sample.mode = 1; /* A,B set relay */            else current.stm.khz = 50.5; /* C,D limit sample rate */          end;        end;        pos(22,10); erase_line;        set.poly.rate(current.stm.khz,sample.to.memory);        ms.per.buf.cell = 1 / current.stm.khz;        time.x.min   = time.x.start / ms.per.buf.cell;         time.x.max   = time.x.stop  / ms.per.buf.cell;        if trace.type = time.trace then do;          graph.x.min = int(time.x.min);          graph.x.max = int(time.x.max);        end;        pos(9,left.c - 1); fprint(current.stm.khz,3,3);  pos(9,left.c - 1);      end;      do; /* case 3 */        if daughter_type(bin#) = ned_daughter then do;          pos(22,10); pstring('Enter new STM gain: (1 - 80) ');          stm.gain = getnum;          if stm.gain < 1 then stm.gain = 1;          if stm.gain > 80 then stm.gain = 80;        end;        else do;          pos(22,10); pstring('Enter new STM gain in dB: ((-3) - 28)');          stm.gain = getnum;          if stm.gain < -3 then stm.gain = -3;          if stm.gain > 28 then stm.gain = 28;        end;        pos(22,10); erase_line;         pos(10,left.c); pnum(stm.gain,3); pos(10,left.c);      end;      do;  /* case 4 */        pos(16,left.c);        if trace.type = spectral.trace then do;           trace.type = time.trace; pstring('  Time  ');          graph.x.min = int(time.x.min);   graph.x.max = int(time.x.max);          graph.y.min = int(time.y.min);   graph.y.max = int(time.y.max);           pos(17,left.c); fprint(time.x.start,2,2);  pstring(' ms ');           pos(18,left.c); fprint(time.x.stop,2,2);   pstring(' ms ');          pos(19,left.c); fprint(time.y.top,2,2);    pstring('  V ');           pos(20,left.c); fprint(time.y.bottom,2,2); pstring('  V ');         end;        else do;          trace.type = spectral.trace; pstring('Spectral');          graph.x.min = spect.x.min; graph.x.max = spect.x.max;          graph.y.min = spect.y.min; graph.y.max = spect.y.max;          pos(17,left.c); pnum(spect.x.start,5);  pstring(' Hz ');           pos(18,left.c); pnum(spect.x.stop,5);   pstring(' Hz ');          pos(19,left.c); pnum(spect.y.top,5);    pstring(' dbr');           pos(20,left.c); pnum(spect.y.bottom,5); pstring(' dbr');         end;        pos(16,left.c);      end;      do;  /* case 5 */        pos(22,10);        if trace.type = spectral.trace then do;           pstring('Enter new X-axis start: (Hz) ');          spect.x.start = getnum;          if (spect.x.start > (spect.x.stop-1000))              then spect.x.start = spect.x.stop - 1000;          if spect.x.start < 0 then spect.x.start = 0;          spect.x.min   = int(spect.x.start / hz.per.buf.cell);          graph.x.min   = spect.x.min;          pos(17,left.c); pnum(spect.x.start,5); pstring(' Hz');        end;        else do;          pstring('Enter new X-axis start: (ms) ');          time.x.start = get_fnum(2,2);          if (time.x.start < 0.0) then time.x.start = 0.0;          if (time.x.start > time.x.stop - .4)            then time.x.start = time.x.stop - .4;          time.x.min = time.x.start/ms.per.buf.cell;          graph.x.min = int(time.x.min);          pos(17,left.c); fprint(time.x.start,2,2); pstring(' ms');        end;        pos(22,10); erase_line;        pos(17,left.c);      end;      do; /* case 6 */        pos(22,10);        if trace.type = spectral.trace then do;          pstring('Enter new X-axis stop: (Hz) ');          spect.x.stop = getnum;          if (spect.x.stop > 25000) then spect.x.stop = 25000;          if (spect.x.stop < (spect.x.start + 1000))            then spect.x.stop = spect.x.start + 1000;          spect.x.max = int(spect.x.stop / hz.per.buf.cell);          graph.x.max = spect.x.max;          pos(18,left.c); pnum(spect.x.stop,5); pstring(' Hz');        end;        else do;          pos(22,10); pstring('Enter new X-axis stop: (ms) ');          time.x.stop = get_fnum(2,2);          if (time.x.stop < time.x.start + .4)             then time.x.stop = (time.x.start + .4);          if (time.x.stop > fft.len/100) then time.x.stop = fft.len/100;          time.x.max  = time.x.stop/ms.per.buf.cell;          graph.x.max = int(time.x.max);          pos(18,left.c); fprint(time.x.stop,2,2); pstring(' ms');        end;        pos(22,10); erase_line;        pos(18,left.c);      end;      do; /* case 7 */        pos(22,10);        if trace.type = spectral.trace then do;       /* case 7 */          pstring('Enter new Y-axis top: (dbr) ');          spect.y.top = getnum;          if (spect.y.top > 0) or (spect.y.top < spect.y.bottom + 10)            then spect.y.top = 0;          spect.y.max = spect.y.top * 100;          graph.y.max = spect.y.max;          pos(19,left.c); pnum(spect.y.top,5); pstring(' dbr');        end;        else do;          pstring('Enter new Y-axis top: (V) ');          time.y.top = get_fnum(2,2);          if (time.y.top > 5.0) or (time.y.top <= time.y.bottom)            then time.y.top = 5.0;          time.y.max = (time.y.top / millivolts.per.bit) * 1000;          graph.y.max = int(time.y.max);          pos(19,left.c); fprint(time.y.top,2,2); pstring('  V ');        end;        pos(22,10); erase_line;        pos(19,left.c);      end;      do; /* case 8 */        pos(22,10);        if trace.type = spectral.trace then do;           pstring('Enter new Y-axis bottom: (dbr) ');          spect.y.bottom = getnum;          if (spect.y.bottom < -150) or (spect.y.bottom > spect.y.top - 10)           then spect.y.bottom = -150;          spect.y.min = (spect.y.bottom * 100);          graph.y.min = spect.y.min;          pos(20,left.c); pnum(spect.y.bottom,5); pstring(' dbr');        end;        else do;          pstring('Enter new Y-axis bottom: (V) ');          time.y.bottom = get_fnum(2,2);          if (time.y.bottom < -5.0) or (time.y.bottom >= time.y.top)            then time.y.bottom = -5.0;          time.y.min = (time.y.bottom / millivolts.per.bit) * 1000;          graph.y.min = int(time.y.min);          pos(20,left.c); fprint(time.y.bottom,2,2); pstring('  V ');        end;        pos(22,10); erase_line;        pos(20,left.c);      end;      nop; /* case 9 */      /* Right column *******************************************/      do; /* case 10 */        pos(7,right.c);        if output.mode = output.off then do;          output.mode = output.poly;          pstring('Poly');          setup.channel;        end;        else do;          output.mode = output.off;          pstring('Off ');          call poly.turn.off(current.channel);        end;        pos(7,right.c);      end;      do;       /* case 11 */        pos(8,right.c);        call poly.turn.off(current.channel);        wave.type = (wave.type + 1) mod 4;        do case wave.type;          pstring('100K sine      ');          pstring('100k 6-bit sine');          pstring('Random noise   ');          pstring('Impulse train  ');        end; /* case */        setup.channel;        pos(8,right.c);      end;      do;     /* case 12 */        pos(9,right.c);         call poly.turn.off(current.channel);        current.channel = current.channel + 1;        if current.channel > (poly.max.chan + 1) then current.channel = poly.min.chan;        if current.channel = (poly.max.chan + 1) then pstring(' All');        else pnum(current.channel,4);        setup.channel;        pos(9,right.c);       end;      do;   /* case 13 */        pos(10,right.c);        call poly.turn.off(current.channel);        if pan = 0 then do;          pan = 1;          pstring('Right');        end;        else do;          pan = 0;          pstring('Left ');        end;        setup.channel;        pos(10,right.c);      end;      do;  /* case 14 */        pos(22,10); pstring('Enter new frequency in kHz: ');        current.poly.khz = get_fnum(3,3);        if current.poly.khz < 5.0 then current.poly.khz = 5.0;        pos(22,10); erase_line;        set.poly.rate(current.poly.khz,poly.voices);        pos(11,right.c); fprint(current.poly.khz,3,3);        setup.channel;        pos(11,right.c);      end;      do; /* case 15 */        pos(22,10); pstring('Enter new volume (0 - 100): ');        current.user.volume = getnum;        if (current.user.volume < 0) \ (current.user.volume > 100)           then current.user.volume = 100;        current.volume = int((4095 * current.user.volume)/100);        pos(22,10); erase_line;        pos(12,right.c); pnum(current.user.volume,4);        setup.channel;        pos(12,right.c);      end;      nop; /* case 16 */      do; /* case 17 */        pos(16,right.c);        if fft.len < 8192 then fft.len = fft.len * 2;        else fft.len = 1024;        pnum(fft.len,4);        hz.per.buf.cell = half.sample.rate / shr(fft.len,1);        if time.x.stop > (shr(fft.len,1) * ms.per.buf.cell) then do;           time.x.stop = (shr(fft.len,1) * ms.per.buf.cell);           time.x.max  = shr(fft.len,1);           if trace.type = time.trace then do;             pos(18,left.c); fprint(time.x.stop,2,2);             graph.x.max = int(time.x.max);           end;        end;        spect.x.min  = int(spect.x.start/hz.per.buf.cell);        spect.x.max  = int(spect.x.stop/hz.per.buf.cell);        if trace.type = spectral.trace then do;          graph.x.min  = spect.x.min; graph.x.max = spect.x.max;        end;        pos(16,right.c);      end;      do; /* case 18 */        pos(22,10); pstring('Enter number of averages: (1 - 100) ');        num.averages = getnum;        if num.averages < 1 then num.averages = 1;        if num.averages > 100 then num.averages = 100;        pos(22,10); erase_line;        pos(17,right.c);        pnum(num.averages,3);        pos(17,right.c);      end;      do; /* case 19 */        pos(18,right.c);        if cursor.on then do;          cursor.on = false;          pstring(' Off');        end;        else do;          cursor.on = true;          pstring(' On ');        end;        pos(18,right.c);      end;    end; /* case */    else do case current.field;      pos(7,left.c);   pos(8,left.c);   pos(9,left.c);   pos(10,left.c);      pos(16,left.c);  pos(17,left.c);  pos(18,left.c);  pos(19,left.c);        pos(20,left.c);  nop;             pos(7,right.c);  pos(8,right.c);        pos(9,right.c);  pos(10,right.c); pos(11,right.c); pos(12,right.c);       nop;             pos(16,right.c); pos(17,right.c); pos(18,right.c);     end;  /* case */  end; /* do forever */end s.setup;/***************************************************************************/dcl check.terminal lit 'call term.chk';term.chk: proc;  dcl (i,chr) fixed;  chr = peek;  if chr >= 0 then do;    chr = rchar; clear_typeahead;    if (chr = sp) then do;      if sweep.stopped then sweep.stopped = false;      else sweep.stopped = true;      return;    end;    if (chr = cr) or (chr = 0) then do;      sweep.stopped = false;      sweeping = false;      return;    end;    if (chr = asc.p) or (chr = lower.p) then do;      peak.track = true;      return;    end;    if sweep.stopped then do;      if (chr = asc.h) or (chr = lower.h) then do;        hardcopy;        return;      end;      /* @@ cursor */      if chr = last.chr        then cursor.increment = cursor.increment + 16/(8192/fft.len);       else cursor.increment = 1;      if cursor.increment > 256/(8192/fft.len)      then cursor.increment = 256/(8192/fft.len);      if chr = cur.right then do;        clear_typeahead; /* @@ cursor */        new.x.cursor = new.x.cursor + cursor.increment;        if (new.x.cursor < graph.x.min) or (new.x.cursor > graph.x.max)          then new.x.cursor = graph.x.max;        peak.track = false;      end;      if chr = cur.left then do;        clear_typeahead; /* @@ cursor */        if cursor.increment < 1 then cursor.increment = 1;        new.x.cursor = new.x.cursor - cursor.increment;        if (new.x.cursor < graph.x.min) or (new.x.cursor > graph.x.max)          then new.x.cursor = graph.x.min;        peak.track = false;      end;      do i = 0 to 10000; end;      clock.ticks = 0;      last.chr = chr;    end;  end;end term.chk;/***************************************************************************/dcl erase.cursor lit 'call erase.curs';erase.curs: proc;  dcl (i,j,k) fixed;  if term.type = pericom.term then viewport(pericom.graph.view);   else viewport(vt640.graph.view);  iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  if cursor.on then do;     data_level(2);         /* comp */    iconnect(old.x.cursor,graph.y.min,old.x.cursor,graph.y.max);    iconnect(graph.x.min,old.y.cursor,graph.x.max,old.y.cursor);    if term.type = pericom.term then viewport(pericom.max.view);     else viewport(vt640.max.view);    data_level(1);  /* dots off */    if trace.type = spectral.trace then do;      move_to(100,0); ps('X: '); pn(int(old.x.cursor.val));       move_to(850,0); ps('Y: '); pn(int(old.y.cursor.val));     end;    else do;      move_to(100,0); ps('X:       ms');      move_to(850,0); ps('Y:       V');      move_to(100,0); ps('X: '); fprint(old.x.cursor.val,2,2);      move_to(850,0); ps('Y: '); fprint(old.y.cursor.val,2,2);       move_to(430,0); ps('Hex value: '); hnum(old.y.cursor,4);    end;    if term.type = pericom.term then viewport(pericom.graph.view);     else viewport(vt640.graph.view);    iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  end;end erase.curs;/***************************************************************************/dcl draw.cursor lit 'call draw.curs';draw.curs: proc;   dcl (i,j,k) fixed;  if term.type = pericom.term then viewport(pericom.graph.view);   else viewport(vt640.graph.view);  iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  if cursor.on then do;    if peak.track then do;      j = graph.y.min;      do i = graph.x.min to graph.x.max;         if buf(i) > j then do;           j = buf(i);           new.x.cursor = i;         end;      end;    end;    new.y.cursor = buf(new.x.cursor);    if trace.type = time.trace then do;      new.y.cursor.val = (millivolts.per.bit * new.y.cursor)/1000;      new.x.cursor.val = (new.x.cursor * ms.per.buf.cell);    end;    else do;      new.y.cursor.val = int(new.y.cursor/100);      new.x.cursor.val = new.x.cursor * hz.per.buf.cell;    end;    data_level(2);   /* dots complemented */    iconnect(new.x.cursor,graph.y.min,new.x.cursor,graph.y.max);    iconnect(graph.x.min,new.y.cursor,graph.x.max,new.y.cursor);    old.x.cursor = new.x.cursor;    old.y.cursor = new.y.cursor;    if term.type = pericom.term then viewport(pericom.max.view);     else viewport(vt640.max.view);    data_level(0);  /* dots on */    if trace.type = spectral.trace then do;      move_to(100,0); ps('X:       Hz');      move_to(850,0); ps('Y:      dbr');      move_to(100,0); ps('X: '); pn(int(new.x.cursor.val));       move_to(850,0); ps('Y: '); pn(int(new.y.cursor.val));     end;    else do;      move_to(100,0); ps('X:       ms');      move_to(850,0); ps('Y:       V');      move_to(100,0); ps('X: ');   fprint(new.x.cursor.val,2,2);      move_to(850,0); ps('Y: ');   fprint(new.y.cursor.val,2,2);       move_to(430,0); ps('Hex value: '); hnum(new.y.cursor,4);    end;    old.x.cursor.val = new.x.cursor.val;    old.y.cursor.val = new.y.cursor.val;    if term.type = pericom.term then viewport(pericom.graph.view);     else viewport(vt640.graph.view);    iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  end;end draw.curs;/***************************************************************************/dcl draw.graph lit 'call draw.g';draw.g: proc;  dcl (v,volts.per.division) floating;  data_level(0);     /* dots on */  if term.type = pericom.term then viewport(pericom.border.view);   else viewport(vt640.border.view);  border;  graph.x.division = int((graph.x.max - graph.x.min) / 16 + .5);  if trace.type = time.trace then do;    volts.per.division = (time.y.top - time.y.bottom) / 10;    graph.y.division = int(((volts.per.division / millivolts.per.bit) * 1000) + .5);   end;  else do;    graph.y.division = int(((graph.y.max - graph.y.min) / 15) + .5);  end;  /* hash x axis */  if term.type = pericom.term then viewport(pericom.xhash.view);   else viewport(vt640.xhash.view);  iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  do i = (graph.x.min + graph.x.division) to (graph.x.max - graph.x.division) by graph.x.division;   if trace.type = spectral.trace    then iconnect(i,graph.y.min,i,(graph.y.min + int((graph.y.division/8) + .5)));   else iconnect(i,graph.y.min,i,(graph.y.min + int((graph.y.division/16) + .5)));  end;  /* hash y axis */  if term.type = pericom.term then viewport(pericom.yhash.view);   else viewport(vt640.yhash.view);  iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);  if trace.type = spectral.trace then    do i = (graph.y.min + graph.y.division) to (graph.y.max - graph.y.division) by graph.y.division;      iconnect(graph.x.min,i,(graph.x.min + int((graph.x.division/8) + .5)),i);    end;  else do;    do v  = (time.y.bottom + volts.per.division)          to (time.y.top - volts.per.division) by volts.per.division;       i = int((v/millivolts.per.bit) * 1000);       iconnect(graph.x.min,i,(graph.x.min + int((graph.x.division/8) + .5)),i);    end;  end;  if term.type = pericom.term then viewport(pericom.graph.view);   else viewport(vt640.graph.view);  iwindow(graph.x.min,graph.x.max,graph.y.min,graph.y.max);end draw.g;/***************************************************************************/dcl draw.screen lit 'call d.screen';d.screen: proc;  if term.type = pericom.term then viewport(pericom.max.view);   else viewport(vt640.max.view);  data_level(0);                      /* dots on */  clear;    char_size(0);  if trace.type = spectral.trace then do;    move_to(100,50); ps('Start: '); pn(spect.x.start); ps(' Hz');     move_to(825,50); ps('Stop: ');  pn(spect.x.stop);  ps(' Hz');    move_to(475,50);  ps('FREQUENCY');     move_to(20,750); pn(spect.y.top);     move_to(20,725); ps(' dbr');    move_to(20,125); pn(spect.y.bottom);  move_to(20,100); ps(' dbr');  end;  else do;    move_to(100,50);    ps('Start:');        fprint(time.x.start,2,2); ps('ms');     move_to(825,50);    ps('Stop:');      fprint(time.x.stop,2,2);  ps('ms');    move_to(500,50);  ps('TIME');     move_to(0,760);   alpha_mode;  fprint(time.y.top,2,2);       move_to(0,100);   alpha_mode;  fprint(time.y.bottom,2,2);    move_to(10,430);  ps('Volts');    vector_mode;  end;  draw.graph;end d.screen;/***************************************************************************/compute.spectrum:  proc (samples,fft.len);  /* compute spectrum of samples passed to routine */   dcl samples         fixed array; /* array of input samples, output values put here */   dcl fft.len         fixed;       /* length of fft to perform (max is 8192) */   dcl lsb      (8192) fixed;   dcl spectral.factor floating;   dcl density         floating;   dcl window.type     lit '1'; /* 0=Boxcar, 1=Hanning, 2=Hamming */   dcl (i,j)           fixed;   /* Routine computes spectrum of passed points. */   /* Replaces input samples with (FFT.LEN/2+1)   */   /* fixed-point DB measurements. (Actual value  */   /* is DB*100)  Measurements are relative to a  */   /* full scale 16-bit Sine wave.                */   /* Coefficient 0 will be DC component, Coef. 1 */   /* will be power in the 1st Harmonic, Coef. 2  */   /* will be power in the 2nd Harmonic, etc.     */                                       square:proc(b,blsb); /* squares complex elements */     dcl b           fixed array;     dcl blsb        fixed array;     dcl (i,msb,lsb) fixed;     dcl (real,imag) fixed;     dcl (tmsb,tlsb) fixed;     do i=0 to fft.len/2; /* loop over points up to nyquist */         real=shl(i,1); imag=real+1;         if b(real)<0 then do;            b(real)=-b(real);            if blsb(real)<>0 then b(real)=b(real)-1;            blsb(real)=-blsb(real);         end;         load b(real); mul b(real);         msb=ures; lsb=res;         load b(real); mul blsb(real);         lsb=lsb+ures;         if lsb ilt ures then msb=msb+1;         lsb=lsb+ures;         if lsb ilt ures then msb=msb+1;         if b(imag)<0 then do;            b(imag)=-b(imag);            if blsb(imag)<>0 then b(imag)=b(imag)-1;            blsb(imag)=-blsb(imag);         end;         load b(imag); mul b(imag);         msb=msb+ures;         lsb=lsb+res;         if lsb ilt res then msb=msb+1;         load b(imag); mul blsb(imag);         lsb=lsb+ures;         if lsb ilt ures then msb=msb+1;         lsb=lsb+ures;         if lsb ilt read(4) then msb=msb+1;         b(i)=msb; blsb(i)=lsb;      end; /* of loop over points */   end square;     compute_u: proc floating; /* window energy normalization factor */      dcl u            floating;      dcl (i,u1,u2,u3) fixed;      if window.type=0 then return fft.len;      u1=0; u2=0; u3=0;      do i=0 to fft.len-1; /* loop over points */         load 0; uload i; div fft.len;         call angle(res);               if window.type=1 then do; /* hanning window */            cosine=32767-cosine;   /* a positive number <65536 */         end;         else do;                  /* hamming window */            load cosine; mul 60293;            if cosine<0 then cosine=ures-60293;            else             cosine=ures;            cosine=35389-cosine;         end;         load cosine; mul cosine;         u2=u2+ures;         if u2 ILT ures then u1=u1+1;         u3=u3+res;         if u3 ILT res then do;            u2=u2+1;            if u2=0 then u1=u1+1;         end;      end;                         /* end of loop over points */      /* convert 48-bit fixed pt number */      /* into 32-bit floating format    */      /* u=u1+((u2+(u3/64k)/64k))       */      u=u2+u3/65536.;      if u3<0 then u=u+1.0;      u=u1+u/65536.;      if u2<0 then u=u+1.0;      return u;   end compute_u;   if fft.len igt 8192 then fft.len=8192;      /* limit fft length */   rescale=0;                                  /* reset scale factor */   call data_window(samples,lsb,fft.len,window.type,fft.len); /* apply Hanning window */   call normalize1 (samples,lsb,fft.len,15);   /* normalize data for best resolution */   call ifast      (samples,lsb,fft.len);      /* compute complex spectrum */   call normalize1 (samples,lsb,fft.len+1,15); /* renormalize spectral coefficients */   call square     (samples,lsb);              /* square elements to get linear spectral density */   rescale=rescale*2;   spectral.factor = exp(log(2)*(rescale-12))/compute_u/fft.len; /* used to correct magnitudes for window attenuation */   do i=0 to shr(fft.len,1);     /* convert fixed point rep to floating-pt DB */      density=spectral.factor*(samples(i)+lsb(i)/65536.);      if lsb(i)<0 then density=density+spectral.factor;      if density<=0      then density=-150;      else density=10*log(density)/2.3025851; /* log(10)=2.3025851 */      if density<-150 then density=-150;      samples(i)=int(100*density+.5);     /* convert to fixed point DB */   end;end compute.spectrum;/***************************************************************************/read.sine.table:  proc; /* reads in sine table data used by FFT code */   /*   dcl (i,j,k) fixed;   call locate('.STBL-6',1);   call readdata(shl(1,8),starting.sector,location(sintable),sintable.len+intpol.len+1);    */   do i = 0 to 320;     sintable.(i) = sindata(i);   end;end read.sine.table;/***************************************************************************/dcl sweep lit 'call g.sweep';g.sweep: proc;  dcl (i,j,k) fixed;  vector_mode;  clear;  first.pass = true;  sweeping = true;  draw.screen;  old.x.cursor = graph.x.min;        old.y.cursor = graph.y.min;  new.x.cursor = graph.x.min;        new.y.cursor = graph.y.min;  old.x.cursor.val = 0;  old.y.cursor.val = int(graph.y.min/100);  new.x.cursor.val = 0;  new.y.cursor.val = int(graph.y.min/100);  clear_typeahead;  chr = -1;  do while sweeping;    if (num.averages = 1) or (trace.type = time.trace) then do;      if ad.input.type = mono.sampling then mono.sample;      else stm.sample(stm.channel);      if trace.type = spectral.trace then call compute.spectrum(buf,fft.len);     end;    else do;      do i = 0 to shr(fft.len,1);        avgbuf(i) = 0.0;      end;      if term.type = pericom.term then viewport(pericom.max.view);       else viewport(vt640.max.view);      do i = 1 to num.averages;        data_level(0);                      /* dots on */        move_to(475,20);  ps('Avg. #');  pn(i);        if ad.input.type = mono.sampling then mono.sample;        else stm.sample(stm.channel);        if trace.type = spectral.trace then call compute.spectrum(buf,fft.len);         do j = 0 to shr(fft.len,1);          avgbuf(j) = avgbuf(j) + buf(j);        end;        data_level(1);                      /* dots off */        move_to(475,20);  ps('Avg. #'); pn(i);      end;      data_level(0);      if term.type = pericom.term then viewport(pericom.graph.view);       else viewport(vt640.graph.view);      do i = 0 to shr(fft.len,1);        buf(i) = int(avgbuf(i)/num.averages);      end;      sweep.stopped = true;    end;    if first.pass then do;      first.pass = false;      sweep.stopped = true;    end;    else do;      erase.cursor;      data_level(1);       imove_to(0,ebuf(0));      do i = 1 to graph.x.max; /* loop through FFT components */         iplot(i,ebuf(i));         check.terminal;      end;    end;    draw.graph;    data_level(0);    if trace.type = time.trace then do;      data_level(0);    /* dots on */      iconnect(graph.x.min,0,graph.x.max,0);    end;    imove_to(0,buf(0));    ebuf(0) = buf(0);    do i = 1 to graph.x.max; /* loop through FFT components */       iplot(i,buf(i));       ebuf(i) = buf(i);       check.terminal;    end;    draw.cursor;    do while sweep.stopped;      check.terminal;       if old.x.cursor <> new.x.cursor then do;        erase.cursor;      draw.cursor;      end;    end;  end;  clear_typeahead;  clear;  transparent_mode;  flush_term;end g.sweep;/***************************************************************************//**********************    Main Program     ********************************/sweep.stopped = false;peak.track = true;display.menu;pos(18,10); erase_line;pstring('Creating test waves...');call read.sine.table;load.random.wave;display.menu;do forever;  chr = peek;  if chr <> -1 then do;    cmd = rchar;    if cmd = 0 then call exit(0);    if cmd >= lower.a then cmd = cmd - "40";    if (cmd >= asc.a) & (cmd <= menu.max) then cmd = cmd - asc.a;    else cmd = menu.max + 1;    do case cmd;      do;        if (ad.input.type <> input.off) then do;        /* do graph sweep */          if (current.stm.khz <> 50.0) & (trace.type = spectral.trace) then do;            pos(18,6);             pstring('Input sampling rate is not 50 khz. Frequency units will be incorrect.');            pos(19,6); pstring('Press <RETURN> to continue...');            chr = rchar;            pos(18,6); erase_line; pos(19,6); erase_line;          end;          sweep;        end;        else do;          pos(18,10); pstring('Error: input is off. Press <RETURN> to continue...');          chr = rchar;          pos(18,10); erase_line;        end;      end;      sweep.setup;      end;  /* case */    display.menu;  end;end;