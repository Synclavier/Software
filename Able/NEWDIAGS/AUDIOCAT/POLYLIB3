/*New England Digital CorporationAudio testing programSept 1986, Bill LeathersModification History:   06/01/89  - modified ps_wave for extended memory*/ps_setmode: proc(mode); /* set A/D mode */   dcl mode fixed;   write(psf) = psadmode;   write(psd) = mode;end ps_setmode;ps_actchan: proc(channel, number); /* activate A/D channel(s) */   dcl channel fixed; /* channel to activate (0-15) */   dcl number  fixed; /* number of channels to activate at once */   dcl code    fixed;   write(psc) = (channel and "14"); /* set first channel in box */   write(psf) = psadact;   code = 0; /* no channels yet */   do channel = channel to channel + number - 1; /* activate all channels required */      code = (code or shl(1, channel and "3")); /* set channel number in that box */   end;   write(psd) = code; /* set channel number(s) in that box */end ps_actchan;ps_maxchan: proc(channels, LOD); /* turn on A/D channels */   dcl channels fixed; /* number of sampling channels */   dcl LOD      fixed; /* 1: LOD, 0: STM, 3: LOD w/Monitor */   if LOD then channels = (channels or shl(LOD, 5)); /* set LOD bit */   write(psf) = psadmc;   write(psd) = channels;end ps_maxchan;ps_gain: proc(channel, gain); /* set gain on A/D channel */   dcl channel fixed; /* channel to set gain on */   dcl gain    fixed; /* gain to set it to */   dcl mult    fixed; /* multiplier to write to A/D */   dcl multiplier data (4, 1,    3,     9,    27); /* table of multipliers */   dcl mult_value data (4, 0, "40", "140", "340"); /* values to write to A/D */   if gain < 0 then gain = 1; /* cannot have gains less than one */   if gain > 79 then gain = 79; /* or greater than this */   mult = 1;   do while ((mult <= multiplier (0)) and (gain >= multiplier (mult))); /* find multiplier */      mult = mult + 1;   end;   mult = mult - 1; /* point to correct multiplier */   gain = mult_value (mult) + 16*gain/multiplier (mult) - 16; /* get A/D gain */   write(psc) = channel; /* select A/D channel */   write(psf) = psadvol; /* set gain */   write(psd) = gain;end ps_gain;ps_on: proc(channel, type); /* turn poly channel on/off */   dcl channel fixed; /* channel to change */   dcl type fixed;    /* type of channel (0: off, 1: stop, 3: loop) */   write(psc) = channel; /* select poly channel */   write(psf) = pson; /* turn the channel on */   write(psd) = type;end ps_on;ps_ron: proc(channel); /* read channel on status */   dcl channel fixed;/* channel to poll */   write(psc) = channel; /* select channel */   write(psf) = psron;   return (read(psd));end ps_ron;ps_wave: proc(channel, wavelen, waveaddr); /* set up poly wave table */   dcl channel  fixed; /* channel to set up */   dcl wavelen  fixed; /* wave table length (sectors) */   dcl waveaddr fixed; /* wave table address (sector) */   write(psc) = channel; /* select channel */   write(psf) = pswl; /* start with wave table length */   write(psd) = -wavelen; write(psd) = "HFF00"; /* wave table length */   write(psd) = waveaddr; write(psd) = 0; /* base address */   write(psd) = -wavelen; write(psd) = "HFF00"; /* loop length (entire wave table) */end ps_wave;ps_freq: proc(channel, pi, inc, mod); /* set poly channel frequency */   dcl channel fixed; /* channel to set up */   dcl pi      fixed; /* phase increment (LSB) */   dcl inc     fixed; /* increment */   dcl mod     fixed; /* modulus */   write(psc) = channel; /* select channel */   write(psf) = pspi; /* write phase increment first */   write(psd) = 0;       write(psd) = pi; /* phase increment of PI */   write(psd) = inc - 1; write(psd) = 256 - mod; /* increment of INC/modulus of MOD (if MOD = 2, 50 kHz) */end ps_freq;