/* MAXVIO  $TITLE  MAX Velocity Keyboard I/O Library */DCL PULSE_EXWR0     LIT 'WRITE("131")="40"\0; WRITE("131")=0; WRITE("131")="100"\0'; /* MODE 0 WRITE THEN READ */DCL PULSE_EXWR1     LIT 'WRITE("131")="40"\1; WRITE("131")=1; WRITE("131")="100"\1'; /* MODE 1 WRITE THEN READ */DCL NUM.OCTAVES     LIT '5';  /* # SUPEROCTAVES (16 KEY) */DCL NUM.SW.PANS     LIT '10'; /* # BUTTON BANKS */DCL NUM.ALPHA.CHARS LIT '32'; /* # ALPHA CHARS */DCL LIST.SIZE                  LIT '12';DCL NEW.NOTE.LIST  (LIST.SIZE) FIXED;DCL NEW.NOTE.KEY#  (LIST.SIZE) FIXED;DCL NEW.NOTE.VEL   (LIST.SIZE) FIXED;DCL NEW.BUTTON.LIST(LIST.SIZE) FIXED;DCL PANSW      (NUM.SW.PANS)   FIXED; /* CURRENT BUTTON BITS */DCL CLAVIER    (NUM.OCTAVES)   FIXED; /* CURRENT KEY BITS */DCL OLD.CLAVIER(NUM.OCTAVES)   FIXED;DCL DP.WORDS   (3)             FIXED; /* CURRENT DECIMAL POINT BITS */DCL DP.TABLE                   DATA (32,48,36,52); /* DECIMAL PT ADDRESSES */DCL SWITCHDATA(7)              FIXED;DCL ANALOG.IN (7)              FIXED;DCL KNOB.POS                   LIT 'ANALOG.IN(0)';DCL RIBBON.POS                 LIT 'ANALOG.IN(1)';DCL PEDAL2.POS                 LIT 'ANALOG.IN(2)';DCL PEDAL1.POS                 LIT 'ANALOG.IN(3)';DCL PWHEEL.POS                 LIT 'ANALOG.IN(4)';DCL MWHEEL.POS                 LIT 'ANALOG.IN(5)';DCL BREATH.POS                 LIT 'ANALOG.IN(6)';DCL UNUSED.POS                 LIT 'ANALOG.IN(7)';DCL KNOB.BASE                  FIXED;DCL KNOB.CHANGE                FIXED;DCL PITCH.BASE                 FIXED;DCL PITCH.CHANGE               FIXED;SCAN.NEW.NOTES:  PROC; /* CREATE LIST OF NEW NOTES ON KEYBOARD */   DCL (MASK1,MASK2,KCR)   FIXED;   DCL (KEYS.NEW,KEYS.REL) FIXED;   DCL (I,J,K)             FIXED;   WRITE("131")=0; WRITE("131")="40"\0;  /* EX WRITE IN MODE 0 */   WRITE("131")=0; WRITE("131")="100"\0; /* EX READ  IN MODE 0 */   KCR=READ("130"); /* GET KEYBOARD CHANGE REG */   KCR=KCR\SHR(KCR,8); /* OR UP AND DOWN BYTES TOGETHER */   WRITE("131")=1; /* SET D130 ADDRESSS TO INDICATE EXPANDED OPCODES */   MASK1=1; /* INIT BIT MASK FOR KCR */   NEW.NOTE.LIST(0)=0; /* NO NEW NOTES */   DO I=0 TO (NUM.OCTAVES-1); /* CHECK FOR CHANGE IN EACH SUPEROCTAVE */      IF (MASK1&KCR)<>0 THEN DO; /* CHECK FOR CHANGE IN OCTAVE */         WRITE("130")="417"\SHL(I,4); /* REQUEST ACTIVITY WORD */         PULSE_EXWR1;         CLAVIER(I)=READ("130"); /* GET ACTIVITY WORD */         KEYS.NEW=CLAVIER(I) AND (NOT OLD.CLAVIER(I)); /* NEW KEYS DOWN */         KEYS.REL=OLD.CLAVIER(I) AND (NOT CLAVIER(I)); /* RELEASED KEYS */         OLD.CLAVIER(I)=CLAVIER(I);         K=SHL(I,4); /* PRECOMPUTE SUPEROCTAVE NUMBER */         MASK2=1; /* INIT BIT MASK FOR KEYS */         DO J=0 TO 15; /* LOOP OVER KEYS IN OCTAVE */            IF (MASK2&KEYS.NEW)<>0 THEN DO; /* NEW KEY DOWN */               IF NEW.NOTE.LIST(0)<LIST.SIZE THEN DO; /* ADD TO LIST */                  NEW.NOTE.LIST(0)=NEW.NOTE.LIST(0)+1;                  NEW.NOTE.LIST(NEW.NOTE.LIST(0))=1; /* CODE FOR NEW NOTE */                  NEW.NOTE.KEY#(NEW.NOTE.LIST(0))=K\J;                  WRITE("130")="000"\K\J; /* REQUEST KEY VEL/TIME DATA */                  PULSE_EXWR1;                  NEW.NOTE.VEL(NEW.NOTE.LIST(0))=READ("130")&"1777"; /* STORE VELOCITY DATA */               END;            END; /* NEW KEY DOWN */            IF (MASK2&KEYS.REL)<>0 THEN DO; /* NEW KEY UP */               IF NEW.NOTE.LIST(0)<LIST.SIZE THEN DO; /* ADD TO LIST */                  NEW.NOTE.LIST(0)=NEW.NOTE.LIST(0)+1;                  NEW.NOTE.LIST(NEW.NOTE.LIST(0))=2; /* CODE FOR NOTE RELEASE */                  NEW.NOTE.KEY#(NEW.NOTE.LIST(0))=K\J;               END;            END; /* NEW KEY UP */            MASK2=SHL(MASK2,1);         END; /* OF LOOP OVER KEYS */      END; /* OF CHANGE IN OCTAVE */      MASK1=SHL(MASK1,1);   END; /* OF LOOP OVER OCTAVES */END SCAN.NEW.NOTES;SCAN.PRESSURE:  PROC(KEY#);   DCL KEY# FIXED;   WRITE("131")=1; /* INDICATE KEYBOARD OPCODES */   WRITE("130")="200"\KEY#; /* REQUEST PRESSURE DATA */   PULSE_EXWR1;   RETURN READ("130")&"377"; /* GET PRESSURE DATA */END SCAN.PRESSURE;SCAN.NEW.BUTTONS:  PROC; /* CREATE LIST OF NEW BUTTONS DOWN */   DCL (MASK1,MASK2) FIXED;   DCL (SAR,OLD.SAR) FIXED;   DCL (I,J,K,L)     FIXED;   NEW.BUTTON.LIST(0)=0; /* CLEAR LIST */   WRITE("131")=1; /* SET D130 ADDRESS TO INDICATE EXTENDED OPCODES */   WRITE("130")="600"; /* REQUEST SWITCH ACTIVITY REGISTER */   PULSE_EXWR1;   SAR=READ("130"); /* GET SWITCH ACTIVITY REGISTER */   L=SAR\(SAR XOR OLD.SAR); /* OR IN SAR BITS WHICH HAVE CHANGED */   OLD.SAR=SAR; /* STORE SAR */   MASK1=1; /* INIT BIT MASK */   DO I=1 TO NUM.SW.PANS; /* LOOP OVER PANELS */      IF (MASK1&L)<>0 THEN DO; /* ACTIVITY OCCURRED HERE */         WRITE("130")="600"\I; /* REQUEST DATA FOR BANK */         PULSE_EXWR1;         J=READ("130"); /* READ NEW DATA */         K=J AND (NOT PANSW(I)); /* DETERMINE NEW ONES */         PANSW(I)=J; /* STORE CURRENT ONES */         MASK2=1; /* INIT BIT MASK */         DO J=0 TO 15; /* LOOP OVER BITS */            IF ((K&MASK2)<>0) AND (NEW.BUTTON.LIST(0)<LIST.SIZE) /* BIT SET */            THEN DO; /* ADD TO LIST */               NEW.BUTTON.LIST(0)=NEW.BUTTON.LIST(0)+1;               NEW.BUTTON.LIST(NEW.BUTTON.LIST(0))=SHL(I-1,4)+J;            END;            MASK2=SHL(MASK2,1);         END;      END; /* OF ACTIVITY OCCURRED */      ELSE PANSW(I)=0; /* NO ACTIVITY */      MASK1=SHL(MASK1,1);   END; /* OF LOOP OVER PANELS */END SCAN.NEW.BUTTONS;SCAN.ANALOG.INPUTS:  PROC; /* READ ANALOG INPUTS AND DIGITAL SWITCHES */   DCL (I,J,K,MASK)              FIXED;   DCL (BASE.ADJUST,DELTA,ACCUM) FIXED;   DCL (PSW,NSW)                 FIXED;   WRITE("131")=1; /* SET D130 ADDRESS TO INDICATE EXTENDED OPCODES */   WRITE("313")=ADDR(ANALOG.IN(0));   /* USE R13 FOR SPEED */   DO I=88 TO 95; /* LOOP OVER ADDRESSES OF ANALOG CONTROLLERS */      WRITE("130")="200"\I; /* REQUEST VEL/TIME DATA */      PULSE_EXWR1;      WRITE("373")=READ("130")&255; /* STORE DATA */   END;   WRITE("313")=ADDR(SWITCHDATA(0)); /* USE R13 AGAIN */   MASK="400";   WRITE("130")="200"\89; /* GET SWITCH BITS */   PULSE_EXWR1;   NSW=READ("130")&"177400"; /* GET NEW SWITCHES */   IF NSW<>PSW THEN DO; /* CHECK FOR DIFFERENT TO AVOID LOOP TIMES */      DO I=0 TO 7; /* LOOP OVER BITS */         IF (NSW&MASK)<>0 THEN WRITE("373")=1;         ELSE                  WRITE("373")=0;         MASK=SHL(MASK,1);      END; /* OF LOOP OVER BITS */      PSW=NSW; /* SAVE FOR NEXT COMPARISON */   END;   BASE.ADJUST=BASE.ADJUST+1; /* COUNT TO ADJUSTMENT FOR DRIFTING BASE LINE */   IF BASE.ADJUST=1000 THEN DO; /* DO THE ADJUSTMENT */      IF KNOB.POS<KNOB.BASE THEN KNOB.BASE=KNOB.BASE-1; /* NUDGE IT ONE WAY */      ELSE                       KNOB.BASE=KNOB.BASE+1; /* OR THE OTHER */      BASE.ADJUST=0; /* RESET COUNT */   END;   KNOB.CHANGE=0; /* START WITH ZERO */   DELTA=KNOB.POS-KNOB.BASE; /* GET POSITION */   IF DELTA<0 THEN DELTA=-DELTA; /* COMPUTE ABSOLUTE VALUE */   IF DELTA>12 THEN DO; /* HAVE A 12 WIDE DEAD BAND */      DELTA=DELTA+DELTA-20; /* SCALE FOR MIN OF 4 */      IF DELTA>31 THEN DELTA=31; /* MAX OF 31 TO PREVENT OVERFLOW */      DELTA=SHL(4+(DELTA&3),SHR(DELTA,2)+5);      ACCUM=ACCUM+DELTA; /* ACCUMULATE MOD 16 BITS */      IF ACCUM<0 THEN DO; /* IF CARRY INTO SIGN */         ACCUM=ACCUM-"100000"; /* ALLOW REMAINDER */         KNOB.CHANGE=SHR(DELTA,11)+1; /* CHANGE BY THIS AMOUNT */         IF KNOB.POS<KNOB.BASE THEN KNOB.CHANGE=-KNOB.CHANGE;      END;   END;   ELSE IF DELTA<8 THEN ACCUM="077777"; /* SET UP HYSTERESIS */END SCAN.ANALOG.INPUTS;CLEAR.LIGHT:  PROC(LIGHT.NUM);   DCL LIGHT.NUM FIXED;   WRITE("131")=3; /* SET UP D130 TO INDICATE LIGHTS */   WRITE("130")=SHL(LIGHT.NUM,8)\0;   WRITE("131")=3\"40"; WRITE("131")=3; /* PULSE EXW */END CLEAR.LIGHT;SET.LIGHT:  PROC(LIGHT.NUM);   DCL LIGHT.NUM FIXED;   WRITE("131")=3; /* SET UP D130 TO INDICATE LIGHTS */   WRITE("130")=SHL(LIGHT.NUM,8)\1;   WRITE("131")=3\"40"; WRITE("131")=3; /* PULSE EXW */END SET.LIGHT;BLINK.LIGHT:  PROC(LIGHT.NUM);   DCL LIGHT.NUM FIXED;   WRITE("131")=3; /* SET UP D130 TO INDICATE LIGHTS */   WRITE("130")=SHL(LIGHT.NUM,8)\2;   WRITE("131")=3\"40"; WRITE("131")=3; /* PULSE EXW */END BLINK.LIGHT;CLEAR.BANK:  PROC(BANK); /* CLEAR ENTIRE BANK */   DCL (BANK,I) FIXED;   WRITE("131")=3; /* SET UP D130 TO INDICATE LIGHTS */   BANK=SHL(BANK,4); /* COMPUTE LIGHT NUMBER */   DO I=0 TO 15; /* LOOP OVER LIGHTS IN BANK */      WRITE("130")=SHL(BANK+I,8)\0; /* CLEAR I'TH LIGHT */      WRITE("131")=3\"40"; WRITE("131")=3; /* PULSE EXW */   END;END CLEAR.BANK;CLEAR.DEC.POINT:  PROC(POS); /* UPDATED FOR NEW DISPLAY BOARD */   DCL (POS,I,J) FIXED;   I=(POS&3); /* WORD NUMBER */   IF POS<16 THEN J=  SHL(SHR(POS,   2),1); /* BIT NUMBER */   ELSE           J=1+SHL(SHR(POS-16,2),1);   WRITE("131")=2; /* SET UP D130 TO INDICATE ALPHA DISPLAY */   DP.WORDS(I)=DP.WORDS(I)&(NOT SHL(1,J)); /* MASK OUT BIT */   WRITE("130")=SHL(DP.TABLE(I),8)\DP.WORDS(I); /* EMIT WORD */   WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */END CLEAR.DEC.POINT;SET.DEC.POINT:  PROC(POS); /* UPDATED FOR NEW DISPLAY BOARD */   DCL (POS,I,J) FIXED;   I=(POS&3); /* WORD NUMBER */   IF POS<16 THEN J=  SHL(SHR(POS,   2),1); /* BIT NUMBER */   ELSE           J=1+SHL(SHR(POS-16,2),1);   WRITE("131")=2; /* SET UP D130 TO INDICATE ALPHA DISPLAY */   DP.WORDS(I)=DP.WORDS(I)\SHL(1,J); /* OR IN BIT */   WRITE("130")=SHL(DP.TABLE(I),8)\DP.WORDS(I); /* EMIT WORD */   WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */END SET.DEC.POINT;EMIT.NUMBER:  PROC(POS,VALUE,DP); /* WRITE VALUE TO ALPHA, STARTING AT POS */   DCL (POS,VALUE,DP) FIXED;   DCL (I,R,GO)       FIXED;   DCL POWERS         DATA (10000,1000,100,10,1);   WRITE("131")=2; /* SET UP D130 TO INDICATE ALPHA DISPLAY */   GO=0; /* SUPPRESS LEADING ZEROES */   DO I=0 TO 4; /* LOOP OVER CHARS OF NUMBER */      R=0; /* ASSUME ZERO DIGIT */      IF VALUE>=POWERS(I) THEN DO; /* NON-ZERO DIGIT */         R=VALUE/POWERS(I); /* GET DIGIT */         GO=1;         VALUE=VALUE-R*POWERS(I); /* REDUCE VALUE */      END;      IF (GO) OR (I=4) /* VALID DIGIT */      THEN WRITE("130")=SHL(POS+I,8)\("60"+R); /* WRITE OUT DIGIT */      ELSE WRITE("130")=SHL(POS+I,8)\("40"  ); /* WRITE OUT SPACE */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */      IF I=(5-DP) THEN CALL SET.DEC.POINT  (POS+I);      ELSE             CALL CLEAR.DEC.POINT(POS+I);   END; /* OF LOOP OVER CHARS */END EMIT.NUMBER;EMIT.STRING:  PROC(POS,STR); /* WRITE STRING TO ALPHA, STARTING AT POS */   DCL (POS,I) FIXED;   DCL STR     ARRAY;   WRITE("131")=2; /* INDICATE ALPHA DISPLAY */   DO I=0 TO STR(0)-1; /* LOOP OVER CHARS */      WRITE("130")=SHL(POS+I,8)\BYTE(STR,I); /* WRITE OUT DIGIT */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */      CALL CLEAR.DEC.POINT(POS+I); /* REMOVE DECIMAL POINT */   END;END EMIT.STRING;CLEAR.UPPER:  PROC; /* CLEAR THE UPPER ROW OF DISPLAY */   DCL I FIXED;   WRITE("131")=2; /* INDICATE ALPHA DISPLAY */   DO I=0 TO 15; /* CLEAR CHARS */      WRITE("130")=SHL(I,8)\"40"; /* WRITE OUT A SPACE */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */   END;END CLEAR.UPPER;CLEAR.LOWER:  PROC; /* CLEAR THE LOWER ROW OF DISPLAY */   DCL I FIXED;   WRITE("131")=2; /* INDICATE ALPHA DISPLAY */   DO I=16 TO 31; /* CLEAR CHARS */      WRITE("130")=SHL(I,8)\"40"; /* WRITE OUT A SPACE */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */   END;END CLEAR.LOWER;CLEAR.DISPLAY:  PROC; /* CLEAR THE WHOLE ALPHA DISPLAY */   DCL I FIXED;   WRITE("131")=2; /* INDICATE ALPHA DISPLAY */   DO I=0 TO 31; /* CLEAR CHARS */      WRITE("130")=SHL(I,8)\"40"; /* WRITE OUT A SPACE */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */   END;   DO I=32 TO 44 BY 4; /* CLEAR DECIMAL POINTS */      WRITE("130")=SHL(I,8)\"0"; /* WRITE ZERO */      WRITE("131")=2\"40"; WRITE("131")=2; /* PULSE EXW */   END;   DO I=0 TO 3; DP.WORDS(I)=0; END; /* CLEAR DP BITS */END CLEAR.DISPLAY;