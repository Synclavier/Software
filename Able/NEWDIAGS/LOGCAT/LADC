/*

Title           : PSADC test module  - inserted in LOGGER
Project Engineer: William Leathers
Project Start   : Feb 1986
New England Digital Corporation

Modification History:

   02/15/89  WSL - Cleanup & optimization
*/

/***************************************************************************/
/************     Required for stand - alone compilation    ****************/
/*
insert ':-xpl:asciidef';
insert ':-xpl:termutil';
insert ':-xpl:intrprtr';
insert ':NEWDIAGS:sysinit';

dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; 
dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; 

dcl erase_status_lines lit 'call clr_status';
clr_status: proc;
  pos(status_line4); erase_line;  pos(status_line3); erase_line;
  pos(status_line2); erase_line;  pos(status_line1); erase_line;
end clr_status;
*/
/***************************************************************************/
/***************************************************************************/


dcl test_ad_controller lit 'call adc_test';
dcl ad_controller_errors(psmaxbins) fixed;

/*******************************************************************/
adc_test: proc(bin#);
  dcl bin# fixed;
  dcl bin_base fixed;

  dcl (i,j,k)      fixed;

  dcl chan         fixed;
  dcl data_read    fixed;
  dcl peak         fixed;

  /*************************************************************************/
  dcl log_adc_error lit 'call add_adc_err';
  add_adc_err: proc;

     if ad_controller_errors(bin#) = 0 then do;
        pos(status_line4); erase_line;
        pstring ('  - Error in A/D controller');
        flush_term;
     end;

     if ad_controller_errors(bin#) <> "HFFFF" then
        ad_controller_errors(bin#) = ad_controller_errors(bin#) + 1;

     Really.Run.Host();
  end add_adc_err;
  /*************************************************************************/
  /*************************************************************************/

  erase_status_lines;
  pstring('Testing A/D controller in bin ');
  pnum(bin#+1,1); pstring('...');
  flush_term;
  Really.Run.Host();

  call polyinit;
  if not psadc_exists(bin#) then return;

  bin_base = bin# * 64;
  write(psc) = bin_base;

  write(psf) = psnumv;             
  if (read(psd) & "H80") = "H80" then do;
    if ad_controller_errors(bin#) <> "HFFFF" then
       ad_controller_errors(bin#) = ad_controller_errors(bin#) + 1;
    pos(status_line4); erase_line;
    pstring('Error: The PSADC should be disconnected from the STM box');
    flush_term;
    Really.Run.Host();
  end;

  pos(status_line2); erase_line;
  pstring('  - Checking IDENT data paths'); 
  pos(status_line3);
  flush_term;
  Really.Run.Host();

  /* Check out data paths using the IDENT command */
  write(psc) = bin_base;
  write(psf) = psadid;     

  do i = 0 to 15;                                    /* Check upper 8 bits */
     if Really.Peek() >= 0 then return;
     write(psc) = bin_base + i; write(psd) = 0;

     Really.Do.Delay(2);

     data_read = shr(read(psd),8);               /* get upper byte */
     data_read = (shl(data_read,2) & "HC0")      /* swap bits 4,5 and 6,7 */
               \ (shr(data_read,2) & "H30") 
               \ (data_read & "H0F");
     if data_read <> (shl(i,4) \ "H7") then log_adc_error;
  end;

  do i = 0 to 255;                                   /* Check lower 8 bits */
     if Really.Peek() >= 0 then return;
     write(psd) = i;

     Really.Do.Delay(2);

     data_read = (read(psd) & 255);
     if data_read <> i then log_adc_error;
  end;

  pos(status_line2); erase_line;
  pstring('  - Testing the envelope extractor...');
  flush_term;
  Really.Run.Host();

  do chan = 0 to 15;
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Channel '); pnum(chan,0);
     pos(status_line4);
     Really.Run.Host();

     write(psc) = bin_base + chan;
     write(psf) = psadenv;                  /* Clear the register          */
     i = read(psd);

     do i = 0 to 511;                       /* Test all of the bits first  */
        if Really.Peek() >= 0 then return;
        write(psf) = psadread;              /* Send a read to sync state   */
        write(psd) = 0;                     /*   machine                   */
        write(psf) = psaddout;              /* Send 9 bits of data         */
        if i then k = ("H8000" + shr(i,1));
        else k = shr(i,1);                  /* Bit 0 is written as bit 15  */
        do j = 0 to chan;                   /* Send data for N channels    */
          write(psd) = k;
        end;

        if ((i<>0) & (i<256)) then do;     /* write values less than this  */
                                           /* to make sure the peak is held*/
           do j = 0 to i-1;                /* write positive values first  */
              write(psf) = psadread;       /* Send a RD to sync state mach */
              write(psd) = 0;               
              write(psf) = psaddout;       /* Send 9 bits of data          */
              if j then k = ("H8000" + shr(j,1)); 
              else k = shr(j,1);           /* Bit 0 is written as bit 15   */
              write(psd) = k;             
           end;
           do j = 512-i to 511;            /* write negative values */
              write(psf) = psadread;       /* Send a read to sync state machine */
              write(psd) = 0;
              write(psf) = psaddout;       /* Send 9 bits of data                */
              if J then k = ("H8000" + shr(J,1));
              else k = shr(J,1);           /* Bit 0 is written as bit 15         */
              write(psd) = k;
           end;
        end;
                                    /* Sign bit is bit 8, written as bit 7 */
        if ((i & "H100") <> 0) then peak = i xor "H1FF"; /* 511 */
                               else peak = i;
        write(psf) = psadenv;
        k = read(psd);
        if k <> peak then do;
           log_adc_error;
           if k = 0 then i = 511;
        end;
     end;
  end;

  /* Check out the sample count registers */
  do chan = 0 to 32 by 32;
     if Really.Peek() >= 0 then return;
     pos(status_line2); erase_line;
     if chan = 0 then pstring('  - Testing the sample count register for channel 0');
                 else pstring('  - Testing the sample count register for channel 32');

     do j = 1 to 2;
        pos(status_line3); erase_line;
        if j = 1 then pstring('  - Testing the lower 8 bits...');
                 else pstring('  - Testing the upper 8 bits...');
        pos(status_line4);

        do i = 1 to 255;
           if Really.Peek() >= 0 then return;
           write(psf) = psadmc; write(psd) = 0; /* clear sample count regs */
           /* Check out sample count register for channel 0  */
           /* Set up channel 0 or 32 for 100 Khz             */
           write(psc)= bin_base + chan;
           write(psf)= pswl;
           write(psd)= -1; write(psd)= -1;    /* wave table length of 1 word */
           write(psd)=  i; write(psd)= i;     /* base address of sec i,wrd i */
           write(psd)= -1; write(psd)= -1;    /* loop length of 1         */
           write(psd)=  0; write(psd)= 0;     /* phase incr = 0           */
           write(psd)=  0;                    /* incr of 1                */
           write(psd)=  255;                  /* modulus of 1             */
           write(psd)=  1;                    /* turn on, stop            */

           Really.Do.Delay(2);

           if chan = 0 then write(psf) = psadsc0;
           else write(psf) = psadsc32;

           if J = 1 then do;                   /* lower 8 bits            */
              if (read(psd) & "HFF") <> i then do;
                 log_adc_error;
                 if k = 0 then i = 255;
              end;
           end;
           else do;
              if shr(read(psd),8) <> i then do;
                 log_adc_error;
                 if k = 0 then i = 255;
              end;
           end;
           write(psf) = pson;               /* Turn channel off */
           write(psd) = 0;

        end;
     end;
  end;

  /* Check out fifo and fifo controller */
  pos(status_line2); erase_line;
  pstring('  - Testing the FIFO');
  flush_term;
  Really.Run.Host();

  do chan = 0 to 15;
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Channel '); unum(chan,0);
     pos(status_line4);
     flush_term;
     Really.Run.Host();

     write(psc) = bin_base + chan;

     do i = 0 TO 255; 
        if Really.Peek() >= 0 then return;
        write(psf) = psadmc;
        write(psd) = chan+1;            /* Sample on n channels       */
        do J = 0 to chan;
           write(psc) = bin_base + J;
           write(psf)= pswl;
           write(psd)= -1; write(psd)= -1;    /* wave table length of 1 word */
           write(psd)=  0; write(psd)= 0;     /* base address of 0        */
           write(psd)= -1; write(psd)= -1;    /* loop length of 1         */
           write(psd)=  0; write(psd)= 0;     /* phase incr = 0           */
           write(psd)=  0;                    /* incr of 1                */
           write(psd)=  255;                  /* modulus of 1             */
           write(psd) = 1;
        end;

        write(psf) = psadread;          /* Send a read to sync state machine */
        write(psd) = 0;
        do J = 0 to chan;
           write(psf) = psaddout;          /* Send DATA to N channels      */
           write(psd) = i;
        end;

        Really.Do.Delay(2);

        do J = 0 to chan;
           write(psc) = bin_base + chan;
           write(psf) = pson;
           write(psd) = 0;
        end;
        write(psf) = psadmc;            
        write(psd) = 0;                 /* Turn off channel                  */

        call pbmread(bin#,0,0);
        k = read(psd);
        if shr(k,8) <> i then do;
           log_adc_error;
           if k = 0 then i = 255;
        end;
     end;
  end;

  flush_term;
  Really.Run.Host();

end adc_test;
/*******************************************************************/
/*
clear_screen;
begin;
     dcl i fixed;

  do i = 0 to #_poly_bins - 1;
    test_ad_controller(i);  
    crlf;
    unum(ad_controller_errors(i),5);
  end;
  flush_term;
end;
*/
