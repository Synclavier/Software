/*

Title           : LOGGER II  - Synclavier / Direct-To-Disk testing program
Project Engineer: William Leathers
Project Start   : Feb 1986
New England Digital Corporation

Modified:

05/23/89 - WSL modified modules LPAC & LSRG for unmoded PSPA2
02/29/89 - WSL modified LPSX, LPAC, & LSRG for extended memory
09/15/88 - WSL added support for three poly bins.

Jan 88   - To support two poly bins. Inserted Modules will support 4
           Note: to this program, bin #s are 0-3 but 1-4 is displayed
           to the user.

*/

insert ':NEWDIAGS:datelit';
configuration modelc, MULDIV;

dcl customer_version lit '1';  /* 0 - Troubleshooting   1 - No troubleshooting */
dcl dbug             lit 'if (0) then send';

insert ':-xpl:asciidef';
insert ':-xpl:termutil';
insert ':-xpl:intrprtr';
insert ':NEWDIAGS:sysinit';
insert ':NEWDIAGS:dtdchk';
insert ':NEWDIAGS:LOGCAT:sysscan';

/* More inserts follow. Lits and dcls below are required by those inserts */

dcl status_line1 lit '18,10';
dcl status_line2 lit '19,10';
dcl status_line3 lit '20,10';
dcl status_line4 lit '21,10';

dcl iteration_number fixed;

dcl milliseconds fixed;
/***************************************************************************/
dcl erase_status_lines lit 'call clr_status';
clr_status: proc;

pos(status_line4); erase_line;
pos(status_line3); erase_line;
pos(status_line2); erase_line;
pos(status_line1); erase_line;

end clr_status;

dcl RPC LIT 'WRITE("010")=(-1)+';

insert ':NEWDIAGS:LOGCAT:lchain';
insert ':NEWDIAGS:LOGCAT:lcad';
insert ':NEWDIAGS:LOGCAT:lpsx';
insert ':NEWDIAGS:LOGCAT:lpac';
insert ':NEWDIAGS:LOGCAT:lsrg';
insert ':NEWDIAGS:LOGCAT:ladc';
insert ':NEWDIAGS:LOGCAT:lamp';
insert ':NEWDIAGS:LOGCAT:ldddac';

insert ':NEWDIAGS:LOGCAT:ld16';
insert ':NEWDIAGS:LOGCAT:ld16_3';
insert ':NEWDIAGS:LOGCAT:ld4567';
insert ':NEWDIAGS:LOGCAT:lext';
insert ':NEWDIAGS:LOGCAT:lm64k';

dcl test_max lit '35';                  /* Maximum # of tests selected     */

dcl column1  lit '0';                   /* Columns are for cursor position */
dcl column2  lit '24';
dcl column3  lit '33';
dcl column4  lit '42';
dcl column5  lit '53';
dcl column6  lit '72';

dcl (i,j,k)          fixed;
dcl bin#             fixed;
dcl chr              fixed;
dcl test_number      fixed;

dcl serial_chain_selected          (psmaxbins) boolean;
dcl addressing_selected            (psmaxbins) boolean;
dcl poly_memory_selected           (psmaxbins) boolean;
dcl phase_accumulator1_selected    (psmaxbins) boolean;
dcl phase_accumulator2_selected    (psmaxbins) boolean;
dcl sample_rate_generator_selected (psmaxbins) boolean;
dcl ad_controller_selected         (psmaxbins) boolean;
dcl amplitude_computer1_selected   (psmaxbins) boolean;
dcl amplitude_computer2_selected   (psmaxbins) boolean;
dcl dddac_selected                 (psmaxbins) boolean;

dcl d16_timer_selected             boolean;
dcl d16_3_timer_selected           boolean;
dcl d4567_selected                 boolean;
dcl external_memory_selected       boolean;
dcl m64k_selected                  boolean;

/***************************************************************************/
when d03int then milliseconds = milliseconds + 5;

/***************************************************************************/
dcl display_test_screen lit 'call display_test_scr';
display_test_scr: proc;

   /***********************************************************************/
   dcl print_dashes lit 'call dashes';
   dashes: proc;  pstring('------');  end dashes;
   /***********************************************************************/

   clear_screen;
   pos(0,10); pstring('Error log diagnostic  - ');   display_release_date;
   pos( 3,column1);  pstring('       Test');

   pos( 2,column2);  pstring('Bin #1');
   pos( 3,column2);  pstring('Errors');

   if #_poly_bins > 1 then do;
     pos( 2,column3);  pstring('Bin #2');
     pos( 3,column3);  pstring('Errors');
   end;

   if #_poly_bins > 2 then do;
     pos( 2,column4);  pstring('Bin #3');
     pos( 3,column4);  pstring('Errors');
   end;

   pos( 3,column5);  pstring('       Test');
   pos( 3,column6);  pstring('Errors');

   pos( 5,column1);  pstring('Serial chain');
   pos( 6,column1);  pstring('Poly memory addressing');
   pos( 7,column1);  pstring('Poly Memory');
   pos( 8,column1);  pstring('Phase accumulator #1');
   pos( 9,column1);  pstring('Phase accumulator #2');
   pos(10,column1);  pstring('Sample rate generator');
   pos(11,column1);  pstring('A/D controller');
   pos(12,column1);  pstring('Amplitude computer #1');
   pos(13,column1);  pstring('Amplitude computer #2');
   pos(14,column1);  pstring('Wave bus');
   pos(15,column1);  pstring('Envelope bus');
   pos(16,column1);  pstring('Oscillator swap');

   do i = 0 to #_poly_bins - 1;
     do j = 5 to 16;
       do case i;
         do; pos(j,column2); print_dashes; end;
         do; pos(j,column3); print_dashes; end;
         do; pos(j,column4); print_dashes; end;
       end;
     end;
   end;
   
   pos(5,column5);   pstring('D16 timer load');   
   pos(6,column5);   pstring('D16 vs. D3 timer');
   pos(7,column5);   pstring('D4567 Mpy./Divide');
   pos(8,column5);   pstring('External memory');
   pos(9,column5);   pstring('M64K clocks');

   do i = 5 to 9;
     pos(i,column6); print_dashes;
   end;

   if (interp_is_running != 0) {
      reverse(true);
      pos(10,column5);  pstring('For accurate results');
      pos(11,column5);  pstring('you must prevent your');
      pos(12,column5);  pstring('computer display from');
      pos(13,column5);  pstring('sleeping while the');
      pos(14,column5);  pstring('tests are running.');
      reverse(false);
   }

   pos(23,5);
   if customer_version 
     then pstring('<S> - Select tests                                <BREAK> - Exit');
     else pstring('<S> - Select tests       <T> - Troubleshoot       <BREAK> - Exit');

end display_test_scr;

/***************************************************************************/
dcl display_select_message lit 'call display_select_msg';
display_select_msg: proc;
   reverse(true);
   pos(16,10); pstring('This screen shows you the tests that are selected.          ');
   pos(17,10); pstring('All tests are selected by default.                          ');
   pos(18,10); pstring('Change the selections by using arrow keys and the space bar.');
   pos(19,10); pstring('Press <RETURN> to start the selected tests.                 ');
   reverse(false);
end display_select_msg;

/***************************************************************************/
dcl display_select_screen lit 'call display_select_scr';
display_select_scr: proc;
   dcl num_mbytes fixed;
   dcl i fixed;

   clear_screen;
   pos(0,24); pstring('Error log diagnostic  - ');   display_release_date;
   pos(3,column2-1);   pstring('Bin #1');
   pos(4,column2-1);   pstring('------');

   pos(3,column3-1); pstring('Bin #2');
   pos(4,column3-1); pstring('------');

   pos(3,column4-1); pstring('Bin #3');
   pos(4,column4-1); pstring('------');

   pos( 5,column1);  pstring('Serial chain');
   pos( 6,column1);  pstring('Poly memory addressing');
   pos( 7,column1);  pstring('Poly Memory');
   pos( 8,column1);  pstring('Phase accumulator #1');
   pos( 9,column1);  pstring('Phase accumulator #2');
   pos(10,column1);  pstring('Sample rate generator');
   pos(11,column1);  pstring('A/D controller');
   pos(12,column1);  pstring('Amplitude computer #1');
   pos(13,column1);  pstring('Amplitude computer #2');
   pos(14,column1);  pstring('Wave/Env bus, Osc swap');

   pos(5,column5);   pstring('D16 timer load');   
   pos(6,column5);   pstring('D16 vs. D3 timer');
   pos(7,column5);   pstring('D4567 Mpy./Divide');
   pos(8,column5);   pstring('External memory');
   pos(9,column5);   pstring('M64K clocks');

   if (interp_is_running != 0) {
      reverse(true);
      pos(10,column5);  pstring('For accurate results');
      pos(11,column5);  pstring('you must prevent your');
      pos(12,column5);  pstring('computer display from');
      pos(13,column5);  pstring('sleeping while the');
      pos(14,column5);  pstring('tests are running.');
      reverse(false);
   }

   display_select_message;

   pos(22,10); pstring('<S> - Select all tests              <D> - De-select all tests');
   pos(23,10); pstring('<SPACE BAR> - Select/De-select      <C> - System Configuration');
   
end display_select_scr;

/***************************************************************************/
dcl display_selected_tests lit 'call display_selected_t';
display_selected_t: proc;
   dcl bin# fixed;
   /************************************************************************/
   dcl onoff lit 'call #onoff';
   #onoff: proc(flag);
      dcl flag fixed;
      if flag then pstring(' On');
      else pstring('Off');
   end #onoff;
   /************************************************************************/

   bin# = 0;
   pos( 5,column2);    onoff(serial_chain_selected(bin#));
   pos( 6,column2);    onoff(addressing_selected(bin#));
   pos( 7,column2);    onoff(poly_memory_selected(bin#));
   pos( 8,column2);    onoff(phase_accumulator1_selected(bin#));
   pos( 9,column2);    onoff(phase_accumulator2_selected(bin#));
   pos(10,column2);    onoff(sample_rate_generator_selected(bin#));
   pos(11,column2);    onoff(ad_controller_selected(bin#));
   pos(12,column2);    onoff(amplitude_computer1_selected(bin#));
   pos(13,column2);    onoff(amplitude_computer2_selected(bin#));
   pos(14,column2);    onoff(dddac_selected(bin#));

   bin# = 1;
   pos( 5,column3);    onoff(serial_chain_selected(bin#));
   pos( 6,column3);    onoff(addressing_selected(bin#));
   pos( 7,column3);    onoff(poly_memory_selected(bin#));
   pos( 8,column3);    onoff(phase_accumulator1_selected(bin#));
   pos( 9,column3);    onoff(phase_accumulator2_selected(bin#));
   pos(10,column3);    onoff(sample_rate_generator_selected(bin#));
   pos(11,column3);    onoff(ad_controller_selected(bin#));
   pos(12,column3);    onoff(amplitude_computer1_selected(bin#));
   pos(13,column3);    onoff(amplitude_computer2_selected(bin#));
   pos(14,column3);    onoff(dddac_selected(bin#));

   bin# = 2;
   pos( 5,column4);    onoff(serial_chain_selected(bin#));
   pos( 6,column4);    onoff(addressing_selected(bin#));
   pos( 7,column4);    onoff(poly_memory_selected(bin#));
   pos( 8,column4);    onoff(phase_accumulator1_selected(bin#));
   pos( 9,column4);    onoff(phase_accumulator2_selected(bin#));
   pos(10,column4);    onoff(sample_rate_generator_selected(bin#));
   pos(11,column4);    onoff(ad_controller_selected(bin#));
   pos(12,column4);    onoff(amplitude_computer1_selected(bin#));
   pos(13,column4);    onoff(amplitude_computer2_selected(bin#));
   pos(14,column4);    onoff(dddac_selected(bin#));

   pos(5,column6);   onoff(D16_timer_selected);
   pos(6,column6);   onoff(D16_3_timer_selected);
   pos(7,column6);   onoff(d4567_selected);
   pos(8,column6);   onoff(external_memory_selected);
   pos(9,column6);   onoff(m64k_selected);

end display_selected_t;
/***************************************************************************/
dcl select_tests lit 'call #select_tests';
#select_tests:proc;
   dcl (i,field) fixed;
   dcl chr fixed;
   dcl bin# fixed;
   dcl case_field fixed;  /* case selector for modified field */

   dcl max_field lit '34';
   dcl max_row lit '9';
   dcl max_col lit '3';
  /*************************************************************************/
  dcl position_cursor lit 'call pos_curs';
  pos_curs: proc(field);
     dcl field fixed;

     do case field;
       pos( 5,column2); 
       pos( 6,column2); 
       pos( 7,column2); 
       pos( 8,column2); 
       pos( 9,column2); 
       pos(10,column2); 
       pos(11,column2); 
       pos(12,column2); 
       pos(13,column2); 
       pos(14,column2); 

       pos( 5,column3); 
       pos( 6,column3); 
       pos( 7,column3); 
       pos( 8,column3); 
       pos( 9,column3); 
       pos(10,column3); 
       pos(11,column3); 
       pos(12,column3); 
       pos(13,column3); 
       pos(14,column3); 

       pos( 5,column4); 
       pos( 6,column4); 
       pos( 7,column4); 
       pos( 8,column4); 
       pos( 9,column4); 
       pos(10,column4); 
       pos(11,column4); 
       pos(12,column4); 
       pos(13,column4); 
       pos(14,column4); 

       pos( 5,column6); 
       pos( 6,column6); 
       pos( 7,column6); 
       pos( 8,column6); 
       pos( 9,column6); 
       pos(10,column6);

     end; /* case */

  end pos_curs;
  /*************************************************************************/
  stm_connected: proc(bin#) returns (boolean);
     dcl (bin#,bin_base) fixed;
     dcl bit7 lit '"H0080"';

     bin_base = bin# * 64;
     write(psc) = bin_base;
     write(psf) = psnumv;
     if (read(psd) & bit7) = bit7 then return true;
     else return false;
  end stm_connected;

  /*************************************************************************/
   dcl display_no_poly_msg lit 'call #display_no_poly_msg';
   #display_no_poly_msg: proc(bin#);
      dcl bin# fixed;
      dcl chr fixed;

     pos(status_line2); erase_line;
     pstring('Can''t select test, Poly system #');
     pnum(bin#+1,1); pstring(' not found. ');
     pos(status_line3); erase_line;
     pstring('Press <RETURN> to continue ...  ');
     chr = rchar;
     display_select_message;
   end #display_no_poly_msg;
   /************************************************************************/

   dcl select_all_tests lit 'call #select_all_tests';
   #select_all_tests: proc;
      if poly_exists then do;
         do bin# = 0 to #_poly_bins - 1;
            serial_chain_selected(bin#)                       = true;
            if dddac_exists(bin#)
              then dddac_selected(bin#)                       = true;
            if psac1_exists(bin#)
              then amplitude_computer1_selected(bin#)         = true;
            if psac2_exists(bin#)
              then amplitude_computer2_selected(bin#)         = true;

            addressing_selected(bin#)                         = true;
            sample_rate_generator_selected(bin#)              = true;
            phase_accumulator1_selected(bin#)                 = true;
            phase_accumulator2_selected(bin#)                 = true;
            if (#_poly_mbytes(bin#) > 0)
              then poly_memory_selected(bin#)                 = true;
            if psadc_exists(bin#) & (not stm_connected(bin#))
              then ad_controller_selected(bin#)               = true;
            // Can't run ADC test on sync
            if (interp_is_running != 0)
               ad_controller_selected(bin#) = false;
         end;
      end;

      bin# = 0; /* restore bin# to default 0 */

      if d16_exists then d16_timer_selected     = true;
      if d16_exists then d16_3_timer_selected   = true;
      d4567_selected                            = true;
      if (#_external_memory_sectors > 0)
        then external_memory_selected           = true;
      if m64k_exists then m64k_selected         = true;
   end #select_all_tests;

   bin# = 0;
   display_select_screen;

   // Init to all tests
   dcl firstTime fixed static;

   if (firstTime == 0)
      select_all_tests();

   firstTime = 1;

   display_selected_tests;

   field = 0;
   position_cursor(field);

   // Wait for characters to select or start test
   do forever;
     chr = rchar;
     if chr = 0 then do;
        pos(22,0);
        flush_term;
        Really.Run.Host();
        erase_status_lines;
        do i=21 to 23;
            pos(i,0);erase_line;flush_term;Really.Run.Host();
        end;
        pos(22,0);flush_term;Really.Run.Host();Really.Run.Host();
        exit_to_firmware;
     end;
     if chr = cr then return;
     if (chr = asc.c) or (chr = lower.c) then do;
       display_system_configuration;
       display_select_screen;
       display_selected_tests;
       position_cursor(field);
     end;
     if (chr = asc.d) or (chr = lower.d) then do;
       do bin# = 0 to #_poly_bins - 1;
         serial_chain_selected(bin#)           = false;
         dddac_selected(bin#)                  = false;
         amplitude_computer1_selected(bin#)    = false;
         amplitude_computer2_selected(bin#)    = false;
         addressing_selected(bin#)             = false;
         sample_rate_generator_selected(bin#)  = false;
         phase_accumulator1_selected(bin#)     = false;
         phase_accumulator2_selected(bin#)     = false;
         poly_memory_selected(bin#)            = false;
         ad_controller_selected(bin#)          = false;
       end;
       bin# = 0; /* restore default bin # 0 */

       d16_timer_selected              = false;
       d16_3_timer_selected            = false;
       d4567_selected                  = false;
       external_memory_selected        = false;
       m64k_selected                   = false;

       display_selected_tests;
       position_cursor(field);
     end;

     if (chr = asc.s) or (chr = lower.s) then do;
       select_all_tests();
       display_selected_tests;
       position_cursor(field);
     end;
     if (chr = cur.up) or (chr = vt) then do;
        field = field - 1;
        if field < 0 then field = 0;
        position_cursor(field);
     end;
     if (chr = cur.down) or (chr = lf) then do;
        field = field + 1;
        if field > max_field then field = max_field;
        position_cursor(field);
     end;
     if (chr = cur.left) or (chr = bs) then do;
        if field > max_row then field = field - (max_row+1);
        position_cursor(field);
     end;
     if (chr = cur.right) or (chr = ht) or (chr = ff) then do;
        if field <= ((max_col * max_row) + 1) then field = field + (max_row+1);
        if field > max_field then field = max_field;
        position_cursor(field);
     end;
     if chr = sp then do;
       bin# = 0;
       if (field <= max_row) then case_field = field;
       if (field >  max_row) & (field < (2*(max_row+1))) then do;
         bin# = 1; case_field = field - (max_row+1);
       end;
       if (field >= (2*(max_row+1)))  then do;
         bin# = 2; case_field = field - (2*(max_row+1));
       end;

       do case case_field;
         if (bin#+1) <= #_poly_bins then  /* 0 */
           serial_chain_selected(bin#) = not(serial_chain_selected(bin#)) & 1;  
         else if not(serial_chain_selected(bin#)) then display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then  /* 1 */
           addressing_selected(bin#) = not(addressing_selected(bin#)) & 1; 
         else display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then do; /* 2 */
           if #_poly_mbytes(bin#) > 0 then 
            poly_memory_selected(bin#) = not(poly_memory_selected(bin#)) & 1; 
           else do;
             pos(status_line2); erase_line;
             pstring('Can''t select test, no poly memory found. ');
             pos(status_line3); erase_line;
             pstring('Press <RETURN> to continue ...  ');
             chr = rchar;
           end;
         end;
         else display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then  /* 3 */
           phase_accumulator1_selected(bin#) = not(phase_accumulator1_selected(bin#)) & 1;   
         else display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then  /* 4 */
           phase_accumulator2_selected(bin#) = not(phase_accumulator2_selected(bin#)) & 1;   
         else display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then  /* 5 */
           sample_rate_generator_selected(bin#) = not(sample_rate_generator_selected(bin#))&1; 
         else display_no_poly_msg(bin#);

         if (bin#+1) <= #_poly_bins then do; /* 6 */
           if (interp_is_running != 0)
             ad_controller_selected(bin#) = false;
           else if (psadc_exists(bin#) & not(stm_connected(bin#)))
           then ad_controller_selected(bin#) = not(ad_controller_selected(bin#)) & 1; 
           else do;
            if stm_connected(bin#) > 0 then do;
               pos(status_line2); erase_line;
               pstring('Can''t select test, PSADC not disconnected from STM box.');
               pos(status_line3); erase_line;
               pstring('Disconnect STM boxes and press <RETURN> to continue ...  ');
               chr = rchar;
             end;
             else if not psadc_exists(bin#) then do;
               pos(status_line2); erase_line;
               pstring('Can''t select test, PSADC not found_');
               pos(status_line3); erase_line;
               pstring('Press <RETURN> to continue ...  ');
               chr = rchar;
             end;
           end;
         end;
         else display_no_poly_msg(bin#);

         if (poly_exists & psac1_exists(bin#)) then  /* 7 */
           amplitude_computer1_selected(bin#) = not(amplitude_computer1_selected(bin#)) & 1;   
         else do;
            if not poly_exists then display_no_poly_msg(bin#);
            else do;
               pos(status_line2); erase_line;
               pstring('Can''t select test, PSAC #1 not found.');
               pos(status_line3); erase_line;
               pstring('Press <RETURN> to continue ...  ');
               chr = rchar;
            end;
         end;

         if (poly_exists & psac2_exists(bin#)) then  /* 8 */
           amplitude_computer2_selected(bin#) = not(amplitude_computer2_selected(bin#)) & 1;   
         else do;
            if not poly_exists then display_no_poly_msg(bin#);
            else do;
               pos(status_line2); erase_line;
               pstring('Can''t select test, PSAC #2 not found.');
               pos(status_line3); erase_line;
               pstring('Press <RETURN> to continue ...  ');
               chr = rchar;
            end;
         end;

         if (poly_exists & dddac_exists(bin#)) then /* 9 */
           dddac_selected(bin#) = not(dddac_selected(bin#)) & 1; 
         else do;
            if not poly_exists then display_no_poly_msg(bin#);
            else do;
               pos(status_line2); erase_line;
               pstring('Can''t select test, DDDAC not found.');
               pos(status_line3); erase_line;
               pstring('Press <RETURN> to continue ...  ');
               chr = rchar;
            end;
         end;


         if d16_exists then  /* 10 */
           d16_timer_selected = not(d16_timer_selected) & 1;
         else do;
           pos(status_line2); erase_line;
           pstring('Can''t select test, D16 timer not found.');
           pos(status_line3); erase_line;
           pstring('Press <RETURN> to continue ...  ');
           chr = rchar;
         end;

         if d16_exists then  /* 11 */
           d16_3_timer_selected = not(d16_3_timer_selected) & 1;
         else do;
           pos(status_line2); erase_line;
           pstring('Can''t select test, D16 timer not found.');
           pos(status_line3); erase_line;
           pstring('Press <RETURN> to continue ...  ');
           chr = rchar;
         end;

         d4567_selected = not(d4567_selected) & 1; /* 12 */

         if (#_external_memory_sectors > 0) then            /* 13 */
            external_memory_selected = not(external_memory_selected) & 1;
         else do;
           pos(status_line2); erase_line;
           pstring('Can''t select test, external memory not found.');
           pos(status_line3); erase_line;
           pstring('Press <RETURN> to continue ...  ');
           chr = rchar;
         end;

         if m64k_exists then            /* 14 */
            m64k_selected = not(m64k_selected) & 1;
         else do;
           pos(status_line2); erase_line;
           pstring('Can''t select test, M64K not found.');
           pos(status_line3); erase_line;
           pstring('Press <RETURN> to continue ...  ');
           chr = rchar;
         end;

       end;  /* case */
       bin# = 0; /* restore bin# to default bin 0 */

       erase_status_lines;
       display_selected_tests;
       display_select_message;
       position_cursor(field);
     end;

   end;

end #select_tests;

/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/**********************     Initializations     ****************************/
dcl initialize_error_log lit 'call init_log';
init_log: proc;
  dcl bin# fixed;

  d16_timer_errors = 0;
  d16_3_timer_errors = 0;
  d4567_errors = 0;
  external_memory_errors = 0;
  m64k_errors = 0;

  do bin# = 0 to #_poly_bins - 1;
    serial_chain_errors(bin#) = 0;
    wave_bus_errors(bin#) = 0;
    envelope_bus_errors(bin#) = 0;
    oscillator_swap_errors(bin#) = 0;
    amplitude_computer1_errors(bin#) = 0;
    amplitude_computer2_errors(bin#) = 0;
    addressing_errors(bin#) = 0;
    sample_rate_generator_errors(bin#) = 0;
    phase_accumulator1_errors(bin#) = 0;
    phase_accumulator2_errors(bin#) = 0;
    poly_memory_errors(bin#) = 0;
    ad_controller_errors(bin#) = 0;
  end;
end init_log;

/***************************************************************************/
/*******************     Main Program     **********************************/
/***************************************************************************/

if ((interp_is_running != 0)
&&  (interp_hardware_avail(0) == 0)) {
   pstring('No hardware to test.');
   flush_term;
   exit_to_firmware;
}

do bin# = 0 to #_poly_bins - 1;
  serial_chain_selected(bin#)           = false;
  dddac_selected(bin#)                  = false;
  amplitude_computer2_selected(bin#)    = false;
  amplitude_computer1_selected(bin#)    = false;
  addressing_selected(bin#)             = false;
  sample_rate_generator_selected(bin#)  = false;
  phase_accumulator1_selected(bin#)     = false;
  phase_accumulator2_selected(bin#)     = false;
  poly_memory_selected(bin#)            = false;
  ad_controller_selected(bin#)          = false;
end;
bin# = 0;  /* restore bin# */

d16_timer_selected              = false;
d16_3_timer_selected            = false;
d4567_selected                  = false;
external_memory_selected        = false;
m64k_selected                   = false;

display_system_configuration;
initialize_error_log;
select_tests;

display_test_screen;
iteration_number = 1;
pos(0,55); pstring('Iteration #'); unum(iteration_number,5);

test_number = 0;

// Jump to hyper space
Activate.Deferred.Interpretation();

// Come back at deferred task
Really.Run.Host();

do forever;

START:;

   if Really.Peek() >= 0 then  do;
      chr = rchar;
      if chr = 0 then do;
         erase_status_lines;
         do i=21 to 23;
             pos(i,0);erase_line;flush_term;Really.Run.Host();
         end;
         pos(22,0);flush_term;Really.Run.Host();Really.Run.Host();
         exit_to_firmware;
      end;
      if (chr = asc.s) \ (chr = lower.s) then do;
        select_tests;
        display_test_screen;
        iteration_number = 1;
        test_number = 0;
        pos(0,55); pstring('Iteration #'); unum(iteration_number,5);
        initialize_error_log;
      end;
      if chr = sp then do;
         test_number = test_number + 1;
         if test_number > test_max then test_number = 0;
      end;
      if 0 & ((chr = asc.t) \ (chr = lower.t) & not(customer_version)) then do;
        /*troubleshoot;*/
        iteration_number = 1;
        initialize_error_log;
        display_test_screen;
      end;
      Really.Run.Host();
   end;

   
   if not ( d16_timer_selected 
          \ d16_3_timer_selected
          \ d4567_selected
          \ external_memory_selected
          \ m64k_selected
          \ serial_chain_selected(0)         
          \ dddac_selected(0)                 
          \ amplitude_computer1_selected(0)    
          \ amplitude_computer2_selected(0)    
          \ addressing_selected(0)            
          \ sample_rate_generator_selected(0) 
          \ phase_accumulator1_selected(0)    
          \ phase_accumulator2_selected(0)    
          \ poly_memory_selected(0)                
          \ ad_controller_selected(0)     
          \ serial_chain_selected(1)         
          \ dddac_selected(1)                 
          \ amplitude_computer1_selected(1)    
          \ amplitude_computer2_selected(1)    
          \ addressing_selected(1)            
          \ sample_rate_generator_selected(1) 
          \ phase_accumulator1_selected(1)    
          \ phase_accumulator2_selected(1)    
          \ poly_memory_selected(1)                
          \ ad_controller_selected(1) 
          \ serial_chain_selected(2)
          \ dddac_selected(2)          
          \ amplitude_computer1_selected(2)    
          \ amplitude_computer2_selected(2)    
          \ addressing_selected(2)            
          \ sample_rate_generator_selected(2) 
          \ phase_accumulator1_selected(2)    
          \ phase_accumulator2_selected(2)    
          \ poly_memory_selected(2)                
          \ ad_controller_selected(2)     
          ) then do;        

          pos(status_line1); pstring('No tests are selected !');
          do while Really.Peek() = -1; end;
          goto start;
   end; /* if */

   bin# = 0;
   if (test_number >  9) & (test_number < 20) then bin# = 1;
   if (test_number > 19) & (test_number < 30) then bin# = 2;

   do case test_number;
   if serial_chain_selected(bin#) then do;
     call polyinit;
     test_serial_chain(bin#);
     pos(5,column2);  unum(serial_chain_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if addressing_selected(bin#) then do;
     call polyinit;
     test_addressing(bin#);
     pos( 6,column2);     unum(addressing_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if poly_memory_selected(bin#) then do;
     call polyinit;
     test_poly_memory(bin#);
     pos( 7,column2);     unum(poly_memory_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator1_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,1);
     pos( 8,column2);     unum(phase_accumulator1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator2_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,2);
     pos( 9,column2);    unum(phase_accumulator2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if sample_rate_generator_selected(bin#) then do;
     call polyinit;
     test_sample_rate_generator(bin#);
     pos(10,column2);     unum(sample_rate_generator_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if ad_controller_selected(bin#) then do;
     test_ad_controller(bin#);
     pos(11,column2);     unum(ad_controller_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer1_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,1);
     enable;
     pos(12,column2);     unum(amplitude_computer1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer2_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,2);
     enable;
     pos(13,column2);   unum(amplitude_computer2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if dddac_selected(bin#) then do;
     call polyinit;
     test_dddac(bin#);
     pos(14,column2);     unum(wave_bus_errors(bin#),6);
     pos(15,column2);     unum(envelope_bus_errors(bin#),6);
     pos(16,column2);     unum(oscillator_swap_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if serial_chain_selected(bin#) then do;
     call polyinit;
     test_serial_chain(bin#);
     pos(5,column3);  unum(serial_chain_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if addressing_selected(bin#) then do;
     call polyinit;
     test_addressing(bin#);
     pos( 6,column3);     unum(addressing_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if poly_memory_selected(bin#) then do;
     call polyinit;
     test_poly_memory(bin#);
     pos( 7,column3);     unum(poly_memory_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator1_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,1);
     pos( 8,column3);     unum(phase_accumulator1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator2_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,2);
     pos( 9,column3);    unum(phase_accumulator2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if sample_rate_generator_selected(bin#) then do;
     call polyinit;
     test_sample_rate_generator(bin#);
     pos(10,column3);     unum(sample_rate_generator_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if ad_controller_selected(bin#) then do;
     test_ad_controller(bin#);
     pos(11,column3);     unum(ad_controller_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer1_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,1);
     enable;
     pos(12,column3);     unum(amplitude_computer1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer2_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,2);
     enable;
     pos(13,column3);   unum(amplitude_computer2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if dddac_selected(bin#) then do;
     call polyinit;
     test_dddac(bin#);
     pos(14,column3);     unum(wave_bus_errors(bin#),6);
     pos(15,column3);     unum(envelope_bus_errors(bin#),6);
     pos(16,column3);     unum(oscillator_swap_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if serial_chain_selected(bin#) then do;
     call polyinit;
     test_serial_chain(bin#);
     pos(5,column4);  unum(serial_chain_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if addressing_selected(bin#) then do;
     call polyinit;
     test_addressing(bin#);
     pos( 6,column4);     unum(addressing_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if poly_memory_selected(bin#) then do;
     call polyinit;
     test_poly_memory(bin#);
     pos( 7,column4);     unum(poly_memory_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator1_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,1);
     pos( 8,column4);     unum(phase_accumulator1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if phase_accumulator2_selected(bin#) then do;
     call polyinit;
     test_phase_accumulator(bin#,2);
     pos( 9,column4);    unum(phase_accumulator2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if sample_rate_generator_selected(bin#) then do;
     call polyinit;
     test_sample_rate_generator(bin#);
     pos(10,column4);     unum(sample_rate_generator_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if ad_controller_selected(bin#) then do;
     test_ad_controller(bin#);
     pos(11,column4);     unum(ad_controller_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer1_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,1);
     enable;
     pos(12,column4);     unum(amplitude_computer1_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if amplitude_computer2_selected(bin#) then do;
     call polyinit;
     test_amplitude_computer(bin#,2);
     enable;
     pos(13,column4);   unum(amplitude_computer2_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if dddac_selected(bin#) then do;
     call polyinit;
     test_dddac(bin#);
     pos(14,column4);     unum(wave_bus_errors(bin#),6);
     pos(15,column4);     unum(envelope_bus_errors(bin#),6);
     pos(16,column4);     unum(oscillator_swap_errors(bin#),6);
     erase_status_lines;
     if Really.Peek() >= 0 then goto start;
   end;

   if d16_timer_selected then do;
      test_d16_timer;
      pos(5,column6);      unum(d16_timer_errors,6);
      erase_status_lines;
      if Really.Peek() >= 0 then goto start;
    end;

   if d16_3_timer_selected then do;
      test_d16_3_timers;
      pos(6,column6);      unum(d16_3_timer_errors,6);
      erase_status_lines;
      if Really.Peek() >= 0 then goto start;
    end;

    if d4567_selected then do;
       test_d4567;
       pos(7,column6);  unum(d4567_errors,6);
       erase_status_lines;
      if Really.Peek() >= 0 then goto start;
    end;

    if external_memory_selected then do;
       test_external_memory;
       pos(8,column6);  unum(external_memory_errors,6);
       erase_status_lines;
      if Really.Peek() >= 0 then goto start;
    end;

    if m64k_selected then do;
       test_m64k;
       pos(9,column6);  unum(m64k_errors,6);
       erase_status_lines;
       if Really.Peek() >= 0 then goto start;
    end;

   end; /* case */

   bin# = 0;
   test_number = test_number + 1;
   if test_number > test_max then do;
     test_number = 0;
     iteration_number = iteration_number + 1;
     pos(0,55); pstring('Iteration #'); unum(iteration_number,5);
     flush_term;
     Really.Run.Host();
   end;
end;
