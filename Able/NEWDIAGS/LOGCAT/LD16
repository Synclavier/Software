/*

Title           : D16 timer test module  - inserted in LOGGER
Project Engineer: William Leathers
Project Start   : Feb 1986
New England Digital Corporation

Last modified:   09/01/88  - Writing a 0 to d16 to cause an immediate turnover
                             was causing intermittant failures. 0 was replaced with 1.
*/

/***************************************************************************/
/************     Required for stand - alone compilation    ****************/
/*
insert ':-xpl:asciidef';
insert ':-xpl:termutil';
insert ':-xpl:intrprtr';
insert ':NEWDIAGS:sysinit';

dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; 
dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; 

dcl erase_status_lines lit 'call clr_status';
clr_status: proc;
  pos(status_line4); erase_line;  pos(status_line3); erase_line;
  pos(status_line2); erase_line;  pos(status_line1); erase_line;
end clr_status;

dcl chr fixed;
dcl iteration_number fixed;
*/
/***************************************************************************/
/***************************************************************************/


dcl d16_timer_errors fixed;

dcl test_d16_timer lit 'call #test_d16_timer';

/**************************************************************************/
#test_d16_timer: proc;

  dcl r13 lit '"313"';
  dcl d16 lit '"16"';
  dcl d17 lit '"17"';
  dcl d137 lit '"137"';

  dcl (i,j,k,l) fixed;
  dcl value fixed;
  dcl done boolean;

  /************************************************************************/
  dcl log_d16_error lit 'call #log_d16_error';
  #log_d16_error: proc;

     if d16_timer_errors <> "HFFFF" then
        d16_timer_errors = d16_timer_errors + 1;
  end #log_d16_error;
  /************************************************************************/

  Really.Run.Host();

  // No D16 in interpreter
  if (interp_is_running != 0)
  	return;
  
  if m64k_exists then write(d137) = shl (5,8);     /* 5 - Set 10uS (normal D16 rate)  */
  pos(status_line1); erase_line;
  pstring('Testing D16 Timer ... '); 
  pos(status_line2);  pstring('  - Testing timer load functon ... ');
  pos(status_line3);     flush_term;


   /*
   Test timer load function by writing every value and reading it back
   quickly to see if it is the same. The M64K d16 needs 1 count slack
   due to hardware change of load function.
   */

   done = false;
   value = 0;                   /* value written to d16 */
   do while not done;
    if Really.Peek() >= 0 then return;   /* if a character was typed */

      write(r13) = ^value;
      disable;
      write(d16) = read(r13);     /* use r13 for speed */
      write(r13) = read(d16);     /* should get same value if d16 and */
     /* enable; */                    /* same value or value + 1 for M64K */
      k = read(r13);

      if (m64k_exists & ((k <> value) & (k <> (value + 1))))
      or ((not m64k_exists) & (k <> value)) then do;
         log_d16_error;
         pos(status_line3); erase_line;
         pstring('  - Timer load error.   Wrote: ');  hnum(value,5);
         pstring('      Read: ');  hnum(k,5); 
         flush_term;  disable;
       end;

       value = value + 1;
       if value = 0 then done = true;
    end;

    enable;
    pos(status_line2); erase_line; pstring('  - Testing status flag ...');
    pos(status_line3); flush_term;
    disable;

    write (d16) = 1;           /* (was 0) Prepare d16 to turn over and set flag */
    do i = 1 to 100; end;      /* wait to guarantee flag set */
    if (read (d17) <> 1)       /* error if flag isn't set     */
    then do;
       log_d16_error;
       pos(status_line3); erase_line;
       pstring('  - Error: Status flag not set on timer turn-over');
       flush_term;  disable;
    end;

    i = read (d16);
    if (read (d17) <> 0)   /* error if flag isn't clear   */
    then do;
       log_d16_error;
       pos(status_line3); erase_line;
       pstring('  - Error: Status flag not reset on read of D16');
       flush_term; disable;
    end;

    /* Test reset on write d17 */
    write (d16) = 1;                  /* (was 0) Prepare d16 to turn over and set flag */
    do i = 1 to 100; end;             /* wait to guarantee flag set */
    write (d17) = 10;                 /* Arbitrary number            */
    if (read (d17) <> 0) then do;     /* error if flag isn't clear   */
       log_d16_error;
       pos(status_line3); erase_line;
       pstring('  - Error: Status flag not reset on write to D17');
       flush_term; disable;
    end;

    pos(status_line2); erase_line;
    pstring('  - Testing hang on write to d17 ... ');
    pos(status_line3); 
    flush_term; disable;

    /* Test hang on write to D17    */
    /* Make sure it's not too short */
    write (3) = 0;
    write (3) = 0;   /* Sync execution to D136 clock     */
    write (d16) = 495; /* A hair short of one D136 period  */
    write (d17) = 0;    /* Hang for that interval           */
    if (read(3) <> 0) then do;
       log_d16_error;
       pos(status_line2); erase_line;
       pstring('  - Error: Hang on D17 write is too short');
       pos(status_line3);
    end;

    /* Make sure it's not too long */
    write(3) = 0;
    write(3) = 0;   /* Sync execution to D136 clock        */
    write(d16) = 505; /* A hair longer than one D136 period  */
    write(d17) = 0;    /* Hang for that interval              */
    if (read(3) <> 1) then do;
       log_d16_error;
       pos(status_line2); erase_line;
       pstring('  - Error: Hang on D17 write is too long');
       pos(status_line3);
    end;

    pos(status_line2); erase_line; 
    pstring('  - Testing interrupt bit ... ');
    pos(status_line3);
    flush_term; disable;

    /* Test D16 interrupt enable on load  */
    write (d16) = 1;            /* (was 0) Set up to get int in < 5mS      */
    if read(1) & "H0080" = 0 then do;
       log_d16_error;
       pos(status_line2); erase_line;
       pstring('  - Error: Interrupt not generated on turn-over');
       pos(status_line3);
       crlf;
    end;

    enable;
    if read(1) & "H0080" <> 0 then do;
       log_d16_error;
       pos(status_line2); erase_line;
       pstring('  - Error: Interrupt bit not cleared on enable');
       pos(status_line3);
    end;
    
    erase_status_lines;
    flush_term; 

end #test_d16_timer;
/**************************************************************************/
/*
clear_screen;
iteration_number = 1;
do forever;
  pos(2,10); pstring('Iteration #'); unum(iteration_number,0);
  flush_term;
  if peek <> -1 then call exit(0);
  test_d16_timer; 
  crlf; pnum(d16_timer_errors,5);
  flush_term;
  iteration_number = iteration_number + 1;
end;
*/
