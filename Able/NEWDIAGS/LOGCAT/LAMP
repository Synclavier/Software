/*

Title           : PSAC test module  - inserted in LOGGER
Project Engineer: William Leathers
Project Start   : Feb 1986
New England Digital Corporation

Modification History:

    02/16/89  WSL - Cleanup & optimization

    Warning: this test has been found to report errors on some functionally
    correct PSACs since its origination as AMPTEST by CJ. The errors have
    been seen to be affected by physical differences such as low poly bin
    voltages, power-down/up, or swapping PSACs. The errors can sometimes
    "flushed" out by certain versions of AMPTEST (FLUSHTST,DRAINO).

    This module as it is inserted in LOGGER would on occaision flag errors
    on tests 8 & 9,  Left & right volume going up. For this reason, these
    two tests do not count any errors found during the first iteration.
    A truly bad PSAC usually racks up maximum errors in just a few iterations
    and should be caught on the secon iteration. 


*/

/***************************************************************************/
/************     Required for stand - alone compilation    ****************/
/*
insert ':-xpl:asciidef';
insert ':-xpl:termutil';
insert ':-xpl:intrprtr';
insert ':NEWDIAGS:sysinit';

dcl status_line1 lit '18,10';  dcl status_line2 lit '19,10'; 
dcl status_line3 lit '20,10';  dcl status_line4 lit '21,10'; 

dcl erase_status_lines lit 'call clr_status';
clr_status: proc;
  pos(status_line4); erase_line;  pos(status_line3); erase_line;
  pos(status_line2); erase_line;  pos(status_line1); erase_line;
end clr_status;

*/
/***************************************************************************/
/***************************************************************************/


dcl amplitude_computer1_errors(psmaxbins) fixed;
dcl amplitude_computer2_errors(psmaxbins) fixed;

/**********************************************************************/
dcl test_amplitude_computer lit 'call amp_com';
amp_com: proc(bin#,ac_number);
  dcl (bin#,ac_number) fixed;      /* 1 or 2 */
  dcl bin_base fixed;

  bin_base = 64 * bin#;
  dcl (i,j,k,l,m,n,o,p) fixed;
  dcl (x,y,z) fixed;
  dcl (x_msecs,y_msecs,z_msecs) fixed;
  dcl (x_micros,y_micros,z_micros) fixed;
  dcl (shouldbe,is) (2000) fixed;

  /**********************************************************************/
  dcl log_error lit 'call error_log';
  error_log: proc;

    if ac_number = 0 then do;
      if amplitude_computer1_errors(bin#) = 0 then do;
         enable;
         pos(status_line4); erase_line;
         pstring('  - Error in amplitude computer ');
         pos(status_line4);
         flush_term; Really.Run.Host(); disable;
      end;
      if amplitude_computer1_errors(bin#) <> "HFFFF" then
         amplitude_computer1_errors(bin#) = amplitude_computer1_errors(bin#) + 1;
    end;
    else do;
      if amplitude_computer2_errors(bin#) = 0 then do;
         enable;
         pos(status_line4); erase_line;
         pstring('  - Error in amplitude computer ');
         pos(status_line4);
         flush_term; Really.Run.Host(); disable;
      end;
      if amplitude_computer2_errors(bin#) <> "HFFFF" then
         amplitude_computer2_errors(bin#) = amplitude_computer2_errors(bin#) + 1;
    end;
  end error_log;

  /*************************************************************************/
  /**********************     Procedure  Start    **************************/
  erase_status_lines;
  pstring('Testing amplitude computer #');
  pnum(ac_number,1); pstring(' in bin '); pnum(bin#+1,1); pstring('... ');
  ac_number = ac_number - 1;

  do i = 0 + (ac_number*16) to 15 + (ac_number*16);     /* test channels */
     if Really.Peek() >= 0 then return;

     pos(status_line2);
     pstring('  - Channel ');  pnum(i,2); 
     
     // Write channel number
     write(psc) = bin_base + i;

     /* TEST 1 *********************************************************************/
     
     // This test makes sure the envelope counter increments at a 25 khz rate
     
     pos(status_line3); erase_line;
     pstring('  - Test # 1:   Modulus/delay counter');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 retry_test_1:;
	 	 
         GetConsistentTimes();
         x_msecs = consistent_msecs;
         
	     write(psf)=PSELIM; write(psd)=0;           // limit to 0
	     write(psf)=PSEVAL; write(psd)=0;           // value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // delta to 1
	     write(psf)=PSEINC; write(psd)=4095;        // increment rate to max
	     write(psf)=PSEACU; write(psd)=0;        	// init accumulator to 0
	     write(psf)=PSEMOD; write(psd)=0;           // modulus 4096
	     write(psf)=PSECNT; write(psd)=4000;        // start counter at 4000
	 
	     write(psf)=psecnt;
	 
	 	 // Sync to counter value of 0; that is, wait for counter to wrap
	 	 x = GetConsistentValues();

         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_1;
         
	 	 x_msecs = consistent_msecs;
	 	 
	 	 while (x >= 4000)
	 	 {
	 	 	x = GetConsistentValues();
	 	 	
	 	 	if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_1;
	 	 
	 		x_msecs = consistent_msecs;
	 	}
	 	 	
	 	 // Measure rate
	 	 y       = GetConsistentValues();
	 	 y_msecs = consistent_msecs;
	 	 
	 	 while (y < 4000)
	 	 {
	 	 	y = GetConsistentValues();
	 	
	 	 	if (consistent_msecs - y_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_1;
	 	 
	 		y_msecs = consistent_msecs;
	 	 }
	 	 
	 	 load (y-x); div (y_msecs-x_msecs); z = res;		// Compute incrementers per millisecond
	 	 
	 	 if (rem >= shr(y_msecs-x_msecs, 1)) z = z + 1;		// round
	 	 
	 	 // Check for 25 khz increment rate
	 	 if (z != 25)
	 	 {
	 	 	dbug 'Test # 1 Error ', (y - x), (y_msecs-x_msecs), z;
	 	 	log_error;
	 	 }
	 }
	 
	 else
	 {
	     write(psf)=psemod; write(psd)=0;           /* modulus 4096     */
	     write(psf)=psecnt; write(psd)=4095;
	     write(psf)=psecnt;

	     do while read(psd)=4095; end; /* sync to zero */

	     do k = 0 to 1;
	        do j = 0 to 4095;
	           do while read(psd)=j; end;              /* wait for next    */
	           if read(psd)<>((j+1)&4095) then log_error;
	        end;
	     end;
	  }
	  

     /* TEST 2 *********************************************************************/
     
     // This test makes sure the envelope counter is preset to the modulus value upon a wrap
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 2:   Modulus/delay counter preset');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 retry_test_2:;
	 	 
         GetConsistentTimes();
         x_msecs  = consistent_msecs;
         x_micros = consistent_micros;

         write(psf)=PSELIM; write(psd)=0;           // limit to 0
	     write(psf)=PSEVAL; write(psd)=0;           // value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // delta to 1
	     write(psf)=PSEINC; write(psd)=4095;        // increment rate to max
	     write(psf)=PSEACU; write(psd)=0;        	// init accumulator to 0
	     write(psf)=PSEMOD; write(psd)=3000;        // modulus 1096 - that is counts 3000 ... 4095 ... 3000 ... 4095
	     write(psf)=PSECNT; write(psd)=4000;        // start counter at 4000
	 
	     write(psf)=psecnt;
	 
	 	 // Observer a wrap
	 	 x = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_2;
         
	 	 x_msecs  = consistent_msecs;
	 	 x_micros = consistent_micros;
	 	 
	 	 if (x < 4000)								// make sure we saw value < 4000
            goto retry_test_2;
	 	 	
	 	 y = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_2;
         
	 	 y_msecs  = consistent_msecs;
	 	 y_micros = consistent_micros;
	 	 
         while (y >= 4000)
	 	 {
	 	 	y = GetConsistentValues();
	 	 	
	 	 	if (consistent_msecs - y_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_2;
	 	 
	 	 	y_msecs  = consistent_msecs;
	 	 	y_micros = consistent_micros;
	 	}
	 	
	 	// Make sure wrap was to 3000
	 	if (y < 3000)
	 	{
	 	 	dbug 'Test # 2 Error 1 ', y;
	 	 	log_error;
	 	}
	 	
	 	z        = 4096 - x + y - 3000;				// compute number of counts; that is, counter should have wrapped from 4095 to 3000
	 	z_micros = z * 40;							// should be 40 micros per tick we could be off by 80 micorseconds if we read the first sample late and the last sample early.
	 	
	 	if (y_micros - x_micros < z_micros - 120) || (y_micros - x_micros > z_micros + 120)
	 	{
	 	 	dbug 'Test # 2 Error 2 ', x, y, z, y_micros - x_micros, z_micros;
	 	 	log_error;
	 	}
	 }
	 
	 else
	 {
	     write(psf)=psemod; write(psd)=4000;
	     write(psf)=psecnt; write(psd)=3900;
	     write(psf)=psecnt;

	     do while read(psd)<4000; end;              /* sync to 4000     */

	     do k = 0 to 3;
	        do while read(psd)<4000; end;        /** BUG BAND-AID! Hardware ? **/
	        do j = 4000 to 4095;
	           do while read(psd)=j; end;              /* wait for next    */
	           k = j+1;
	           if k = 4096 then k = 4000;
	           if read(psd) <> k then log_error;
	        end;
	     end;
	 }
	 
     /* TEST 3 *********************************************************************/
     
     // This test makes sure the envelope accumulator increments by 1 correctly
     
     if Really.Peek() >= 0 then return;
     pos(status_line3);  erase_line;
     pstring('  - Test # 3:   Envelope octave accumulator counting');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 retry_test_3:;
	 	 
         GetConsistentTimes();
         x_msecs = consistent_msecs;
         
	     write(psf)=PSELIM; write(psd)=0;           // env limit to 0
	     write(psf)=PSEVAL; write(psd)=0;           // env value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // env delta to 1
	     write(psf)=PSEINC; write(psd)=0;        	// increment rate set to 1 = e.g. increment accumulator by 1
	     write(psf)=PSEACU; write(psd)=4000;        // init accumulator to 4000
	     write(psf)=PSEMOD; write(psd)=4095;        // modulus 1
	     write(psf)=PSECNT; write(psd)=4095;        // start counter at 4095 - e.g. immediately
	 
	     write(psf)=pseacu;							// Read the accumulator directly for this test
	 
	 	 // Wait for accumlator to wrap
	 	 x = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_3;
         
	 	 x_msecs = consistent_msecs;
	 	 
	 	 while (x >= 4000)
	 	 {
	 	 	x = GetConsistentValues();
	 	 	
	 	 	if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_3;
	 	 
	 		x_msecs = consistent_msecs;
	 	}
	 	 	
	 	 // Measure rate
	 	 y       = GetConsistentValues();
	 	 y_msecs = consistent_msecs;
	 	 
	 	 while (y < 4000)
	 	 {
	 	 	y = GetConsistentValues();
	 	
	 	 	if (consistent_msecs - y_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_3;
	 	 
	 		y_msecs = consistent_msecs;
	 	 }
	 	 
	 	 load (y-x); div (y_msecs-x_msecs); z = res;		// Compute incrementers per millisecond
	 	 
	 	 if (rem >= shr(y_msecs-x_msecs, 1)) z = z + 1;		// round
	 	 
	 	 // Check for 25 khz increment rate
	 	 if (z != 25)
	 	 {
	 	 	dbug 'Test # 3 Error ', (y - x), (y_msecs-x_msecs), z;
	 	 	log_error;
	 	 }
	 }
	 
	 else
	 {
	     write(psf)=psemod; write(psd)=4095;           /* modulus 1     */
	     write(psf)=psecnt; write(psd)=4095;
	     write(psf)=pseinc; write(psd)=0;              /* increment by 1 */
	     write(psf)=pseacu; write(psd)=4095;           /* init to 4095   */

	     write(psf)=pseacu;

	     do while read(psd)=4095; end;                 /* sync to zero     */

	     do k = 0 to 1;
	        do j = 0 to 4095;
	           do while read(psd)=j; end;              /* wait for next    */
	           if read(psd)<>((j+1)&4095) then log_error;
	        end;
	     end;
	 }


     /* TEST 4 *********************************************************************/
     
     // Test bits of envelope accumulator - that is, increment at different rates
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 4:   Envelope octave accumulator rates');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	     do k = 0 to 11;                                 /* test each bit */
	         l = shl(1,k);                               /* generate 1,2,4....2048 */
		 	 
		 	 retry_test_4:;
		 	 
             GetConsistentTimes();
             x_msecs = consistent_msecs;
             
		     write(psf)=PSELIM; write(psd)=0;           // env limit to 0
		     write(psf)=PSEVAL; write(psd)=0;           // env value to 0
		     write(psf)=PSEDEL; write(psd)=1;           // env delta to 1
		     write(psf)=PSEINC; write(psd)=l-1;        	// increment rate set to 1, 2, 4, 8 ... 2048
		     write(psf)=PSEACU; write(psd)=4096-l;      // init accumulator so first wrap yields 0
		     write(psf)=PSEMOD; write(psd)=4096-25;     // modulus 25 - use 1 millisecond rate
		     write(psf)=PSECNT; write(psd)=4096-25;     // start counter at 4095 - e.g. immediately
		 
		     write(psf)=pseacu;							// Read the accumulator directly for this test
		 
		 	 // Wait for accumlator to wrap once
		 	 x = GetConsistentValues();
             
             if (consistent_msecs - x_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
                goto retry_test_4;
             
		 	 x_msecs = consistent_msecs;
		 	 
		 	 while (x >= 4096-l)
		 	 {
		 	 	x = GetConsistentValues();
		 	 	
		 	 	if (consistent_msecs - x_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
		 	 		goto retry_test_4;
		 	 
		 		x_msecs = consistent_msecs;
		 	}
		 	 	
		 	 // Measure rate
		 	 y       = GetConsistentValues();
		 	 y_msecs = consistent_msecs;
		 	 
		 	 m = l*10;									// Normally count 10 increments
		 	 
		 	 if (m > 4096-l)							// But limit for larger numbers
		 	 	m = 4096-l;
		 	 
		 	 n = m/l;									// Compute number of increments we should see
		 	 
		 	 while (y < m)
		 	 {
		 	 	y = GetConsistentValues();
		 	
		 	 	if (consistent_msecs - y_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
		 	 		goto retry_test_4;
		 	 
		 		y_msecs = consistent_msecs;
		 	 }
		 	 
		 	 // Test should take N milliseconds
		 	 if ( y_msecs-x_msecs < n-3 || y_msecs-x_msecs > n+3)
		 	 {
		 	 	dbug 'Test # 4 Error ', l, m, n, y_msecs-x_msecs;
		 	 	log_error;
		 	 }
		 end;
	 }
	 
	 else
	 {
	     do k = 0 to 12;                                 /* test each bit */
	        l = shl(1,k);                                /* generate 1,2,4....4096 */
	        if l = 4096 then l = 4095;                     /* but can not test 4095 */
	        write(psf)=pseinc; write(psd)=l-1;         /* increment by l */
	        write(psf)=pseacu; write(psd)=4096-l;      /* simplify test by making next sample a zero */
	        write(psf)=pseacu;                         /* set up for read */

	        do while read(psd)<>0; end;                /* sync to zero     */

	        n=0;
	        do m=0 to 1000;                            /* test 1001 additions */
	           do while read(psd)=n; end;
	           n=(n+l)&4095;
	           if read(psd)<>n then log_error;
	        end;
	     end;
	  }
	  
     /* TEST 5 *********************************************************************/

     // Test envelope value at increment of 1 - make sure it goes up towards envelope limit
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 5:   Envelope accumulator counting');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 retry_test_5:;
	 	 
         GetConsistentTimes();
         x_msecs = consistent_msecs;
         
	     write(psf)=PSELIM; write(psd)=0;           // limit to 0
	     write(psf)=PSEVAL; write(psd)=0;           // value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // delta to 1
	     write(psf)=PSEINC; write(psd)=4095;        // increment rate to max
	     write(psf)=PSEACU; write(psd)=4095;        // init accumulator to 4095
	     write(psf)=PSEMOD; write(psd)=4095;        // modulus 1
	     write(psf)=PSECNT; write(psd)=4095;        // start counter at 4095
	     
	     // Now should start counting up with delta of 1
	     write(psf)=PSELIM; write(psd)=4095;
	 
	     write(psf)=PSEVAL;
	 
	 	 x = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_5;
         
	 	 x_msecs = consistent_msecs;
	 	 
	 	 // Measure rate
	 	 y       = GetConsistentValues();
	 	 y_msecs = consistent_msecs;
	 	 
         if (consistent_msecs - x_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
            goto retry_test_5;
         
	 	 while (y < 4000)
	 	 {
	 	 	y = GetConsistentValues();
	 	
	 	 	if (consistent_msecs - y_msecs > 4)		// Interrupt longer than 4 milliseconds: restart test
	 	 		goto retry_test_5;
	 	 
	 		y_msecs = consistent_msecs;
	 	 }
	 	 
	 	 load (y-x); div (y_msecs-x_msecs); z = res;		// Compute incrementers per millisecond
	 	 
	 	 if (rem >= shr(y_msecs-x_msecs, 1)) z = z + 1;		// round
	 	 
	 	 // Check for 25 khz increment rate
	 	 if (z != 25)
	 	 {
	 	 	dbug 'Test # 5 Error ', (y - x), (y_msecs-x_msecs), z;
	 	 	log_error;
	 	 }
	 }
	 
	 else
	 {
	     write(psf)=psemod; write(psd)=4095;           /* modulus 1     */
	     write(psf)=psecnt; write(psd)=4095;

	     write(psf)=pseinc; write(psd)=4095;           /* increment by 4096 */
	     write(psf)=pseacu; write(psd)=4095;           /* init to 4095   */

	     do k=0 to 1;
	        write(psf)=psedel; write(psd)=1;           /* try delta of 1 */
	        write(psf)=pselim; write(psd)=4095;
	        write(psf)=pseval; write(psd)=0;

	        write(psf)=pseval;

	        do while read(psd)=0; end;                    /* sync to zero     */

	        do j=1 to 4094;                            /* stays at 4095    */
	           do while read(psd)=j; end;              /* wait for next    */
	           if read(psd)<>(j+1) then log_error;
	        end;
	     end;
	 }


     /* TEST 6 *********************************************************************/
     
     // Test envelope current value delta bits
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 6:   Envelope accumulator deltas');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

     if (interp_is_running != 0)
	 {
	     do k = 0 to 11;                                 /* test each bit */
	         l = shl(1,k);                               /* generate 1,2,4....2048 */
		 	 
		 	 retry_test_6:;
		 	 
             GetConsistentTimes();
             x_msecs = consistent_msecs;
             
		     write(psf)=PSELIM; write(psd)=0;           // env limit to 0
		     write(psf)=PSEVAL; write(psd)=0;           // env value to 0
		     write(psf)=PSEDEL; write(psd)=l;           // env delta to 1, 2, 4 ... 2048
		     write(psf)=PSEINC; write(psd)=4095;        // increment rate at max
		     write(psf)=PSEACU; write(psd)=4095;        // init accumulator to 4095
		     write(psf)=PSEMOD; write(psd)=4096-25;     // modulus 25 - use 1 millisecond rate
		     write(psf)=PSECNT; write(psd)=4095-25;     // start counter at for first full millisecond
		 
		     // Now should start counting up with delta of l
		     write(psf)=PSELIM; write(psd)=4095;

	 	     write(psf)=PSEVAL;							// Read the current value
		 
		 	 x = GetConsistentValues();                 // Starting value
             
             if (consistent_msecs - x_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
                goto retry_test_6;
             
		 	 x_msecs = consistent_msecs;
		 	 		 	 	
		 	 // Measure rate
		 	 y = GetConsistentValues();
             
             if (consistent_msecs - x_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
                goto retry_test_6;
             
		 	 y_msecs = consistent_msecs;
		 	 
		 	 m = l*10;									// Normally count 10 increments
		 	 
		 	 if (m > 4096-l)							// But limit for larger numbers
		 	 	m = 4096-l;
		 	 
		 	 n = m/l;									// Compute number of increments we should see
		 	 
		 	 while (y < m)								// Wait for current value to reach limit
		 	 {
		 	 	y = GetConsistentValues();
		 	
		 	 	if (consistent_msecs - y_msecs > 1)		// Interrupt longer than 1 milliseconds: restart test
		 	 		goto retry_test_6;
		 	 
		 		y_msecs = consistent_msecs;
		 	 }
		 	 
		 	 // Test should take N milliseconds. might be off by 2 if read first sample late, second sample early
		 	 if ( y_msecs-x_msecs < n-3 || y_msecs-x_msecs > n+3)
		 	 {
		 	 	dbug 'Test # 6 Error 1 ', l, m, n, y_msecs-x_msecs;
		 	 	log_error;
		 	 }
		 end;
	 }
	 
	 else
	 {
	     do k=0 to 11;                                 /* test each bit */
	        l=shl(1,k);                                /* generate 1,2,4...2048 */

	        write(psf)=psedel; write(psd)=L;           /* try delta of L */
	        write(psf)=pselim; write(psd)=4095;
	        write(psf)=pseval; write(psd)=0;

	        write(psf)=pseval;

	        do while read(psd)=0; end;                    /* sync to zero     */

	        n=0;
	        do while n<>4095;
	           do while read(psd)=n; end;
	           n=n+l; if n>4095 then n=4095;
	           if read(psd)<>n then log_error;
	        end;
	     end;
	 }

     /* TEST 7 *********************************************************************/
     
     // Test envelope limit headding down
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 7:   Envelope accumulator heading down');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 retry_test_7:;
	 	 
         GetConsistentTimes();
         x_msecs = consistent_msecs;
         
	     write(psf)=PSELIM; write(psd)=4095;        // limit to 4095
	     write(psf)=PSEVAL; write(psd)=4095;        // value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // delta to 1
	     write(psf)=PSEINC; write(psd)=4095;        // increment rate to max
	     write(psf)=PSEACU; write(psd)=4095;        // init accumulator to 4095
	     write(psf)=PSEMOD; write(psd)=4095;        // modulus 1
	     write(psf)=PSECNT; write(psd)=4095;        // start counter at 4095
	     
	     // Now should start counting down with delta of 1
	     write(psf)=PSELIM; write(psd)=0;
	 
	     write(psf)=PSEVAL;
	 
	 	 x = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 2)		// Interrupt longer than 2 milliseconds: restart test
            goto retry_test_7;
         
	 	 x_msecs = consistent_msecs;
	 	 
	 	 // Measure rate
	 	 y = GetConsistentValues();
         
         if (consistent_msecs - x_msecs > 2)		// Interrupt longer than 2 milliseconds: restart test
            goto retry_test_7;
         
	 	 y_msecs = consistent_msecs;
	 	 
	 	 while (y > 100)
	 	 {
	 	 	y = GetConsistentValues();
	 	
	 	 	if (consistent_msecs - y_msecs > 2)		// Interrupt longer than 2 milliseconds: restart test
	 	 		goto retry_test_7;
	 	 
	 		y_msecs = consistent_msecs;
	 	 }
	 	 
	 	 load (x-y); div (y_msecs-x_msecs); z = res;		// Compute incrementers per millisecond
	 	 
	 	 if (rem >= shr(y_msecs-x_msecs, 1)) z = z + 1;		// round
	 	 
	 	 // Check for 25 khz decrement rate
	 	 if (z != 25)
	 	 {
	 	 	dbug 'Test # 7 Error ', (x - y), (y_msecs-x_msecs), z;
	 	 	log_error;
	 	 }
	 }
	 
	 else
	 {
	     do k=0 to 11;                                 /* test each bit */
	        l=shl(1,k);                                /* generate 1,2,4....2048 */

	        write(psf)=psedel; write(psd)=L;           /* try delta of L */
	        write(psf)=pselim; write(psd)=0;
	        write(psf)=pseval; write(psd)=4095;

	        write(psf)=pseval;

	        do while read(psd)=4095; end;                    /* sync to zero     */

	        n=4095-l;
	        do while n<>0;
	           do while read(psd)=n; end;
	           n=n-l; if n<0 then n=0;
	           if read(psd)<>n then log_error;
	        end;
	     end;
	 }
	
     /* TEST 8 *********************************************************************/
     
     // Test left volume going up
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 8:   Left volume going up');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	 	 // Init envelope interpolator - though not used for this test
	     write(psf)=PSELIM; write(psd)=0;           // limit to 0
	     write(psf)=PSEVAL; write(psd)=0;           // value to 0
	     write(psf)=PSEDEL; write(psd)=1;           // delta to 1
	     write(psf)=PSEINC; write(psd)=4095;        // increment rate to max
	     write(psf)=PSEACU; write(psd)=4095;        // init accumulator to 4095
	     write(psf)=PSEMOD; write(psd)=4095;        // modulus 1
	     write(psf)=PSECNT; write(psd)=4095;        // start counter at 4095
	     
	     write(psf)=PSLDVOL; write(psd)=0;			// dest vol to 0
	     write(psf)=PSLCVOL; write(psd)=0;			// current vol to 0
	     
	     // Start volume going up. But first read it so we can see if an interrupt comes in
	     write(psf)=PSLCVOL;
	 	 x        = GetConsistentValues();
	 	 x_msecs  = consistent_msecs;
	 	 x_micros = consistent_micros;
	 	 
	 	 write(psf)=PSLDVOL; write(psd)=4095;
	   
	     write(psf)=PSLCVOL;
	 	 y        = GetConsistentValues();
	 	 y_msecs  = consistent_msecs;
	 	 y_micros = consistent_micros;
	 	 
	 	 // Make sure pattern is correct. Test for 100 msecs. Advance shouldbe value according to hardware formula. We might have missed values
	 	 // due to interrupt.
	 	 j=0;
	 	 while (y_msecs - x_msecs < 100)
	 	 {
	 	  	 while (j<y)
	 	 	 {
	 	 		if (shr(4095-j,9) == 0)		// This is algorithm performed by amplitude computer every 40 microseconds
	 	 			j = j + 1;
	 	 		else
	 	 			j = j + shr(4095-j,9);
	 	 	 }
	 	 		
	 	 	 if (y != j)
	 	 	 {
	 	 		dbug 'Test # 8 Error 1 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
	 	 	 	log_error;
	 	 	 }
	 	 	 
		 	 y        = GetConsistentValues();
		 	 y_msecs  = consistent_msecs;
		 	 y_micros = consistent_micros;
	 	 }
	 	 
	 	 // Reaches 4095 after 1838 counts or 73.520  msecs
 	 	 if (y != 4095)
 	 	 {
 	 		dbug 'Test # 8 Error 2 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
 	 	 	log_error;
 	 	 }
	 }
	 
	 else
	 {
		 // Should use first-order algorithm 1/512 of current value. e.g. 0, 
	     j=0; k=0;
	     do while j<>4096;
	        shouldbe(k)=j; k=k+1;
	        L = shr(4095-j,9);
	        if L = 0 then L = 1;
	        j=j+L;
	     end;

	     j=0; k=0;              /* set up for following loop */
	     is(k)=0; k=k+1;

	     write(psf)=psedel;  write(psd)=1;           /* try delta of 1 */
	     write(psf)=psemod;  write(psd)=25;
	     write(psf)=pseinc;  write(psd) = 1;
	     write(psf)=pslcvol; write(psd)=   0;
	     write(psf)=psldvol; write(psd)=4095;

	     write(psf)=pslcvol;
	     do while j<>4095;
	        do while read(psd)=j; end;
	        j=read(psd);
	        is(k)=j; k=k+1;
	     end;
	     do l=0 to k-1;
	        if (is(l)<>shouldbe(l)) & (iteration_number <> 1) then log_error;
	     end;
	 }


     /* TEST 9 *********************************************************************/
     
     // Test right volume going up
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test # 9:   Right volume going up');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	     write(psf)=PSRDVOL; write(psd)=0;			// dest vol to 0
	     write(psf)=PSRCVOL; write(psd)=0;			// current vol to 0
	     
	     // Start volume going up. But first read it so we can see if an interrupt comes in
	     write(psf)=PSRCVOL;
	 	 x        = GetConsistentValues();
	 	 x_msecs  = consistent_msecs;
	 	 x_micros = consistent_micros;
	 	 
	 	 write(psf)=PSRDVOL; write(psd)=4095;
	   
	     write(psf)=PSRCVOL;
	 	 y        = GetConsistentValues();
	 	 y_msecs  = consistent_msecs;
	 	 y_micros = consistent_micros;
	 	 
	 	 // Make sure pattern is correct. Test for 100 msecs. Advance shouldbe value according to hardware formula. We might have missed values
	 	 // due to interrupt.
	 	 j=0;
	 	 while (y_msecs - x_msecs < 100)
	 	 {
	 	  	 while (j<y)
	 	 	 {
	 	 		if (shr(4095-j,9) == 0)		// This is algorithm performed by amplitude computer every 40 microseconds
	 	 			j = j + 1;
	 	 		else
	 	 			j = j + shr(4095-j,9);
	 	 	 }
	 	 		
	 	 	 if (y != j)
	 	 	 {
	 	 		dbug 'Test # 9 Error 1 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
	 	 	 	log_error;
	 	 	 }
	 	 	 
		 	 y        = GetConsistentValues();
		 	 y_msecs  = consistent_msecs;
		 	 y_micros = consistent_micros;
	 	 }
	 	 
	 	 // Reaches 4095 after 1838 counts or 73.520  msecs
 	 	 if (y != 4095)
 	 	 {
 	 		dbug 'Test # 9 Error 2 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
 	 	 	log_error;
 	 	 }
	 }
	 
	 else
	 {
	     j=0; k=0;              /* set up for following loop */
	     is(k)=0; k=k+1;

	      write(psf)=psedel;  write(psd)=1;           /* try delta of 1 */
	      write(psf)=psemod; write(psd)=25;
	      write(psf)=pseinc; write(psd) = 1;
	     write(psf)=psrcvol; write(psd)=   0;
	     write(psf)=psrdvol; write(psd)=4095;

	     write(psf)=psrcvol;

	     do while j<>4095;
	        do while read(psd)=j; end;
	        j=read(psd);
	        is(k)=j; k=k+1;
	     end;

	     do l=0 to k-1;
	        if (is(l)<>shouldbe(l)) & (iteration_number <> 1) then log_error;
	     end;
	 }

     /* TEST 10 *********************************************************************/
     
     // Test 10 left volume going down
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test #10:   Left volume going down');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	     // Start volume going down - was at max from last test
	     write(psf)=PSLCVOL;
	 	 x        = GetConsistentValues();
	 	 x_msecs  = consistent_msecs;
	 	 x_micros = consistent_micros;
	 	 
	 	 write(psf)=PSLDVOL; write(psd)=0;
	   
	     write(psf)=PSLCVOL;
	 	 y        = GetConsistentValues();
	 	 y_msecs  = consistent_msecs;
	 	 y_micros = consistent_micros;
	 	 
	 	 // Make sure pattern is correct. Test for 100 msecs. Advance shouldbe value according to hardware formula. We might have missed values
	 	 // due to interrupt.
	 	 j=4095;
	 	 while (y_msecs - x_msecs < 100)
	 	 {
	 	  	 while (j>y)
	 	 	 {
		        l=shr(0-j,9);
		        if l=0 then l=(-1);
		        else do;
		           l=l\"177600";
		           if (l&7)=0 then l=l+1; /* correct for hardware tri-z obfuscation */
		        end;
		        j=j+l;
	 	 	 }
	 	 		
	 	 	 if (y != j)
	 	 	 {
	 	 		dbug 'Test # 10 Error 1 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
	 	 	 	log_error;
	 	 	 }
	 	 	 
		 	 y        = GetConsistentValues();
		 	 y_msecs  = consistent_msecs;
		 	 y_micros = consistent_micros;
	 	 }
	 	 
 	 	 if (y != 0)
 	 	 {
 	 		dbug 'Test # 10 Error 2 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
 	 	 	log_error;
 	 	 }
	 }
	 
	 else
	 {
	     j=4095; k=0;
	     do while j<>(-1);
	        shouldbe(k)=j; k=k+1;
	        l=shr(0-j,9);
	        if l=0 then l=(-1);
	        else do;
	           l=l\"177600";
	           if (l&7)=0 then l=l+1; /* correct for hardware tri-z obfuscation */
	        end;
	        j=j+l;
	     end;

	     j=4095; k=0;              /* set up for following loop */
	     is(k)=4095; k=k+1;

	      write(psf)=psedel;  write(psd)=1;           /* try delta of 1 */
	      write(psf)=psemod; write(psd)=25;
	      write(psf)=pseinc; write(psd) = 1;
	     write(psf)=pslcvol; write(psd)=4095;
	     write(psf)=psldvol; write(psd)=0;

	     write(psf)=pslcvol;

	     do while j<>0;
	        do while read(psd)=j; end;
	        j=read(psd);
	        is(k)=j; k=k+1;
	     end;

	     do l=0 to k-1;
	        if is(l)<>shouldbe(l) then log_error;
	     end;
	  }

     /* TEST 11 *********************************************************************/
     
     // Test 11 right volume going down
     
     if Really.Peek() >= 0 then return;
     pos(status_line3); erase_line;
     pstring('  - Test #11:   Right volume going down');
     pos(status_line4);
     flush_term;    disable;
     Really.Run.Host();

	 if (interp_is_running != 0)
	 {
	     // Start volume going down - was at max from last test
	     write(psf)=PSRCVOL;
	 	 x        = GetConsistentValues();
	 	 x_msecs  = consistent_msecs;
	 	 x_micros = consistent_micros;
	 	 
	 	 write(psf)=PSRDVOL; write(psd)=0;
	   
	     write(psf)=PSRCVOL;
	 	 y        = GetConsistentValues();
	 	 y_msecs  = consistent_msecs;
	 	 y_micros = consistent_micros;
	 	 
	 	 // Make sure pattern is correct. Test for 100 msecs. Advance shouldbe value according to hardware formula. We might have missed values
	 	 // due to interrupt.
	 	 j=4095;
	 	 while (y_msecs - x_msecs < 100)
	 	 {
	 	  	 while (j>y)
	 	 	 {
		        l=shr(0-j,9);
		        if l=0 then l=(-1);
		        else do;
		           l=l\"177600";
		           if (l&7)=0 then l=l+1; /* correct for hardware tri-z obfuscation */
		        end;
		        j=j+l;
	 	 	 }
	 	 		
	 	 	 if (y != j)
	 	 	 {
	 	 		dbug 'Test # 11 Error 1 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
	 	 	 	log_error;
	 	 	 }
	 	 	 
		 	 y        = GetConsistentValues();
		 	 y_msecs  = consistent_msecs;
		 	 y_micros = consistent_micros;
	 	 }
	 	 
 	 	 if (y != 0)
 	 	 {
 	 		dbug 'Test # 11 Error 2 ', y, j, y_msecs - x_msecs, y_micros - x_micros;
 	 	 	log_error;
 	 	 }
	 }
	 
	 else
	 {
	     j=4095; k=0;              /* set up for following loop */
	     is(k)=4095; k=k+1;

	     write(psf)=psedel;  write(psd)=1;           /* try delta of 1 */
	     write(psf)=psemod;  write(psd)=25;
	     write(psf)=pseinc;  write(psd) = 1;
	     write(psf)=psrcvol; write(psd)=4095;
	     write(psf)=psrdvol; write(psd)=0;

	     write(psf)=psrcvol;

	     do while j<>0;
	        do while read(psd)=j; end;
	        j=read(psd);
	        is(k)=j; k=k+1;
	     end;

	     do l=0 to k-1;
	        if is(l)<>shouldbe(l) then log_error;
	     end;
	 }
  end;
end;
/**********************************************************************/
/*
begin;
  dcl i fixed;

  do i = 0 to #_poly_bins - 1;
    test_amplitude_computer(i,1);  
    crlf; pnum(amplitude_computer1_errors(i),5);
    test_amplitude_computer(i,2);  
    crlf; pnum(amplitude_computer2_errors(i),5);
  end;

end;
*/
