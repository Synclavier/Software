/* literals for live overdub module                *//*   11/04/91 - PF - Added 'Quick Update' feature  *//*   06/20/89 - cj - added cue scrub literals      *//*   05/01/89 - cj - added event.in.s#.msb         *//*   04/26/89 - cj - moved lits from adtdlits      *//* include special remote control code for d34/d35 *//* Note: code is always compiled in.  Only set     *//* this literal to 1 to active the code for OLD    *//* style d34 cards that do not return a sense bit  *//* on a read of "51":                              */dcl inc.d34.remote.control.code lit '0';/* Bit definitions for motion control words        */dcl M$MasterRecordIn       lit '  1';dcl M$MasterRecordOut      lit '  2';dcl M$MasterInput          lit '  4';dcl M$MasterOutput         lit '  8';dcl M$Play                 lit ' 16';dcl M$FF                   lit ' 32';dcl M$REW                  lit ' 64';dcl M$Stop                 lit '128';dcl M$Locate               lit '256';dcl M$RecordRelease        lit '512';dcl lod.update.rate     lit '200';   /* milliseconds between check of lod */dcl Max.Cue.Record.Len  lit '2560';  /* max cue record length             */                                     /* must be set carefully in lod code *//* cue record format */dcl cue.rlen         lit '  0';   /* word length of cue record */dcl cue.s.msb        lit '  1';   /* start msb sample #        */dcl cue.s.lsb        lit '  2';   /* start lsb sample #        */dcl cue.e.msb        lit '  3';   /* end   msb sample #        */dcl cue.e.lsb        lit '  4';   /* end   lsb sample #        */dcl cue.fin          lit '  5';   /* fade in time              */dcl cue.fout         lit '  6';   /* fade out time             */dcl cue.trks         lit '  7';   /* holds track id bits       *//*                          8                                  *//*                          9                                  *//*                         10                                  */dcl cue.alloc#       lit ' 11';   /* id #    to index cue      */dcl cue.smpt.msb     lit ' 12';   /* sorted smpte bit msb      */dcl cue.smpt.lsb     lit ' 13';   /* sorted smpte bit lsb      */dcl cue.smpt.mode    lit ' 14';   /* mode code for smpt bits   */dcl cue.edit.in.msb  lit ' 15';   /* edit in msb sample #      */dcl cue.edit.in.lsb  lit ' 16';   /* edit in lsb sample #      */dcl cue.edit.out.msb lit ' 17';   /* edit out msb sample #     */dcl cue.edit.out.lsb lit ' 18';   /* edit out lsb sample #     */dcl cue.off.msb      lit ' 19';   /* mark offset msb msec time */dcl cue.off.lsb      lit ' 20';   /* mark offset lsb msec time */dcl cue.bits         lit ' 21';   /* 1   = protect or not      *//*                                   2,4 = cue offset switch   *//*                                   8   = cue.smpt.msb is     *//*                                         absolute            *//*                                   16  = event.in.s#.msb has *//*                                         been set.           */dcl cue.srate        lit ' 22';   /* holds sample rate         */dcl cue.len.msb      lit ' 23';   /* cue length, msecs         */dcl cue.len.lsb      lit ' 24';   /* lsb                       */dcl cue.list.ptr     lit ' 25';   /* pointer to splice list    */dcl cue.list.len     lit ' 26';   /* length of splice list     */dcl cue.in.s#.msb    lit ' 27';   /* actual disk sample # of   */dcl cue.in.s#.lsb    lit ' 28';   /* first audio segment       */dcl event.in.s#.msb  lit ' 29';   /* base in time for event    */dcl event.in.s#.lsb  lit ' 30';   /* relative times            *//*                         31        spare                     */dcl cue.name         lit ' 32';   /* cue name stored here      */dcl cue.name.l       lit ' 32';   /* max byte len of cue name  *//* Format of Cue Record Edit Segments */dcl Cue.Seg.Stride      lit '16';  /* words per edit segment    */dcl S#Sync.Msb          lit ' 0';  /* 32-Bit Sync     Address   */dcl S#Sync.Lsb          lit ' 1';dcl S#In.Msb            lit ' 2';  /* 32-Bit Disk In  Address   */dcl S#In.Lsb            lit ' 3';dcl S#Out.Msb           lit ' 4';  /* 32-Bit Disk Out Address   */dcl S#Out.Lsb           lit ' 5';dcl S#DriveBits1        lit ' 6';  /* 64-Bits for Drive ON/OFF  */dcl S#DriveBits2        lit ' 7';  /* Control Bits              */dcl S#DriveBits3        lit ' 8';dcl S#DriveBits4        lit ' 9';dcl S#Fade.In           lit '10';  /* Fade In  Milliseconds     */dcl S#Fade.Out          lit '11';  /* Fade Out Milliseconds     */dcl S#Reserved1         lit '12';  /* Unused                    */dcl S#Reserved2         lit '13';  /* Unused                    */dcl S#SPixelPointer     lit '14';  /* Seg start pixel ptr       */dcl S#EPixelPointer     lit '15';  /* Seg end   pixel ptr       *//* $page - literal definitions for track directory */dcl DTD.Track.Directory.Len     lit '16';   /* length of track directory record    */dcl DTD.Track.Directory.Title   lit ' 0';   /* title - 16 characters, space filled */dcl DTD.Track.Directory.Status  lit ' 8';   /* status (see below)                  */                                            /* lower half:                         */                                            /*       0 = safe                      */                                            /*       1 = ready                     */                                            /* upper half:                         */                                            /*       0 = repro                     */                                            /*       1 = input                     */                                            /*       2 = auto                      */                                            /*       3 = cue playback              */dcl DTD.Track.Directory.Used    lit ' 9';   /* seconds actually used (50 khz)      */dcl DTD.Track.Directory.Input   lit '10';   /* input routing # (0 = none, 1 = 1A   */dcl DTD.Track.Directory.Gain    lit '11';   /* input gain (0 - 100.0)              */dcl DTD.Track.Directory.Volume  lit '12';   /* volume, 0 - 100.0                   */dcl DTD.Track.Directory.Pan     lit '13';   /* pan, -50 to +50                     */dcl DTD.Track.Directory.Stars   lit '14';   /* 14: 0=none 1= '*'  2 = '+'          */dcl DTD.Track.Directory.Spare   lit '15';/* For lod.cue.ptr - size of external memory area reserved for *//* holding real time information waiting to be sent to the     *//* DTD:                                                        */dcl lod.cue.max  lit '512';/* Literals that document some of the SCSI commands that are   *//* sent between the synclav and the direct-to-disk.            */dcl DTD.Buf.Pos              lit '132';dcl DTD.Trig.Start           lit ' 64';dcl DTD.Trig.Stop            lit ' 65';dcl DTD.Scrolling.On         lit ' 66';dcl DTD.Scrolling.Off        lit ' 67';dcl DTD.Loop.Stop            lit ' 69';dcl DTD.Prepare.For.Scrub    lit ' 70';dcl DTD.Define.Cue           lit '180';dcl DTD.Locate.Cue           lit '181';dcl DTD.Fetch.Cue            lit '182';dcl DTD.Rewrite.Cue          lit '183';dcl DTD.Delete.Cue           lit '184';dcl DTD.Reset.Cue.Ptr        lit ' 23';dcl DTD.Fetch.Alpha.Forward  lit ' 24';dcl DTD.Fetch.Alpha.Backward lit ' 25';/* Literals for current cue definitions */dcl #.Of.DTD.Reels.To.Allocate   lit '18';/* Define the switch settings of the Coarse Bar switch                */dcl CS.Cue.Setting   lit '0';  /* pos of coarse switch that is 'CUE'  */dcl CS.Hold.Setting  lit '1';  /* pos of coarse switch that is 'HOLD' */dcl CS.Proj.Setting  lit '2';  /* pos of coarse switch that is 'PROJ' *//* Literals for CUE.HIST.BUF and POLY.HIST.BUF */dcl Cue.Hist.Rec.Len  lit ' 27';  /* length of actual cue history entry */dcl Cue.Hist.Num.Recs lit '128';  /* !!!MUST BE MULTIPLE OF 2!!! - number of records kept in rotary file */dcl Cue.Hist.Hdr.Len  lit '  2';  /* for now hdr holds only current stamp value */dcl Poly.Hist.Rec.Len  lit ' 10'; /* length of actual poly history entry */dcl Poly.Hist.Num.Recs lit '128'; /* !!!MUST BE MULTIPLE OF 2!!! - number of records kept in rotary file */dcl Poly.Hist.Hdr.Len  lit '  2'; /* for now hdr holds only current stamp value */