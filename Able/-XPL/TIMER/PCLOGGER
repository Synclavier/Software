/* pc logger - log the PC every interrupt *//* by: Dave Pearson  */dcl #samp lit '1024';/*    Insert this file in some appropriate interrupt handler.   You must also insert CATRTNS and set up the catalog buffer.   You must define #samp (number of samples you want).  The   output will be put into file 'PCLOG'.  If you want some   header on this file, put it into the array "pcbuf" before   starting to sample.  We output the information when the   buffer gets full, and then stop logging.    WARNING:  This only works for programs compiled that are             compiled for the Model B processor.*//* interrupt-time pc logger */dcl pcbuf (#samp-1) fixed;dcl pcbptr          fixed;dcl (pc, sp, r12)   fixed;if pcbptr <> #samp then do; /* if not over the top */   sp = core(read(r15)); /* pick up stack back pointer (point to interrupt frame) */   pc = core(sp - 3); /* pick up interrupt PC (-0: return, -1: back pointer, -2: R12) */   if pc ilt c#contab then do; /* call/return handlers -- use return addr */      r12 = core(sp - 2); /* pick up R12 (which may hold the stack pointer) */      sp  = core(sp - 1) - 7; /* point back to before interrupt frame (7 = 4 ACs, PSW, and 2 NOPs) */      if      pc >= "15" and pc < "21" then pc = core(sp + 1); /* inside RETN - SP is before return address */      else if pc >= "26" and pc < "35" then pc = core(r12 - 1); /* inside SREG - R12 points to back pointer */      else if core(sp) = sp - 2 then pc = core(sp - 1); /* if back pointer is two away, no regs saved */      else                           pc = core(core(sp) - 1); /* skip over regs saved */   end;   pcbuf (pcbptr) = pc; /* log the value of the PC */   pcbptr = pcbptr + 1;   if pcbptr = #samp then do; /* buffer full - save PC values */      if replace ('pclog', t#data, 0, shr(#samp + 255, 8), #samp, 1)      then call writedata (f#ms_sector, f#ls_sector, pcbuf, #samp);   end;end;