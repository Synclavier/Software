/* FILEIO Code *//* This module handles file input and output.  It is primarily used for text   files which have the following format:   <file>  := <line>*   <line>  := <line#> [<text>] <eol>   <line#> := 16-bit binary representation of the line number   <text>  := {A|B|C...Y|Z|a|b|c...y|z|0|1...8|9|$...}   <eol>   := null byte or null word   Designed and written by Karim J. Chichakly:  August 30, 1984   From original GET routines implemented by Betsy Wakeman:  July 16, 1984     WARNING:  These routines assume the logical end-of-file occurs within             the last 256-sector block of the file.   Notes:     1) Make use of accesses.  E.g., don't change word length unless open for append.           'r':  Read only (disallow all PUTs & SHUFFLE)           'w':  Write only (disallow all GETs); truncate if there, create if not           'a':  Append (disallow all GETs); position to end if there, create if not           'r+': Update - file MUST be there           'w+': Update - truncate if there, create if not           'a+': Update - position to end if there, create if not*/   insert ':-xpl:literals'; /* general literals */   insert ':-xpl:asciilit'; /* ASCII literals */   insert ':-xpl:syslits'; /* get system literals */   insert ':-xpl:catrout'; /* catalog routines */   insert ':-xpl:devutil'; /* device utilities */   dcl EOF_mark    lit '-1'; /* end-of-file flag */   dcl nullf       lit '-1'; /* null file pointer - returned by FOPEN if it fails */   dcl buffer_size lit '1024'; /* recommended file buffer size */   dcl file        lit 'fixed'; /* type FILE */   dcl max_files   lit '4'; /* maximum number of files allowed open */   /* File errors */   dcl f$okay       lit '0'; /* no errors */   dcl f$no_file    lit '1'; /* file does not exist */   dcl f$bad_file   lit '2'; /* invalid file descriptor */   dcl f$no_buffer  lit '3'; /* no buffer assigned to the file */   dcl f$bad_arg    lit '4'; /* invalid argument or improper operation requested */   dcl f$too_many   lit '5'; /* too many files open */   dcl f$bad_access lit '6'; /* invalid access request */   dcl f$too_big    lit '7'; /* file is too large to process - files are limited to 32 Mbytes */   dcl file_error fixed public; /* global file error indicator */   /* file status bits (in DIRTY) */   dcl b$dirty lit '1'; /* if buffer's changed (dirty) */   dcl b$len   lit '2'; /* length's changed (only when dirty) */   /* $page */   dcl ms_catalog (max_files - 1) fixed; /* starting sector of catalog file is in */   dcl ls_catalog (max_files - 1) fixed;   dcl cat_entry  (max_files - 1) fixed; /* catalog entry where file is located */   dcl ms_start   (max_files - 1) fixed; /* starting sector of file */   dcl ls_start   (max_files - 1) fixed;   dcl seclen     (max_files - 1) fixed; /* length of file in sectors */   dcl filelen    (max_files - 1) fixed; /* length of file in words */   dcl secpos     (max_files - 1) fixed; /* current file position (sector) */   dcl filepos    (max_files - 1) fixed; /* current file position (word) */   dcl bufptr (max_files - 1) fixed; /* pointer to our buffer */   dcl bufmed (max_files - 1) fixed; /* buffer medium (0: internal, 1: external, 2: poly) */   dcl bufsiz (max_files - 1) fixed; /* size of our buffer */   dcl buflen (max_files - 1) fixed; /* length of valid data in file buffer */   dcl bufpos (max_files - 1) fixed; /* character position in file buffer */   dcl dirty  (max_files - 1) boolean; /* TRUE if the file buffer has been changed */   dcl extdata (3) fixed; call blockset (extdata, 4, 0); /* global EXT/POLY READ/WRITE parameter list (never preserved) */   dcl ms_sector   fixed; /* global current sector (never preserved) */   dcl ls_sector   fixed;   dcl current_file data ('%current'); /* canonical name of current file (must be 2N letters and lowercase) */   ms_sector = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen) + c#dir_max; /* point to free area */   if ms_sector ilt loc.load then call set_catbuf (ms_sector - c#dir_max, 0); /* set the catalog buffer */   do ls_sector = 0 to max_files - 1; /* free all FCBs */      cat_entry (ls_sector) = -1; ms_start (ls_sector) = -1; ls_start (ls_sector) = -1; bufmed (ls_sector) = -1;      if ms_sector + buffer_size ilt loc.load then do; /* allocate more memory */         bufptr (ls_sector) = ms_sector; bufmed (ls_sector) = 0; bufsiz (ls_sector) = buffer_size;         ms_sector = ms_sector + buffer_size; /* allocate another buffer */      end;   end;   /* $subtitle Poly Memory Drivers */   dcl mam    lit '"60"'; /* external memory sector address */   dcl mal    lit '"61"'; /* external memory word address */   dcl md     lit '"62"'; /* external memory */   dcl mdi    lit '"63"'; /* external memory then increment */   dcl r1     lit '"301"'; /* register one */   dcl sub1   lit '"215"'; /* subtract from register one */   dcl repeat lit 'write("10")='; /* repeat macro */   dcl psc    lit '"155"'; /* write channel # */   dcl psf    lit '"156"'; /* write function code */   dcl psd    lit '"157"'; /* write data here */   dcl psx    lit '"154"'; /* write extended data here */   dcl pswma  lit '16';  /* fc 16 - write memory address    */   dcl psrma  lit '20';  /* fc 20 - read memory  address    */   psmread: proc(msb, lsb) recursive swappable; /* set up for poly synth memory read */      dcl (msb, lsb) fixed;      msb = msb + shr(lsb, 8);     /* normalize  */      lsb = (lsb and "HFF");      disable;      write(psc) = 0;           /* select channel 0 for consistency */      write(psf) = psrma;       /* read memory address fc */      write(psd) = msb;         /* upper 16 bits       */      write(psd) = lsb;         /* lower  8 bits       */      enable;   end psmread;   psmwrite: proc(msb, lsb) recursive swappable;    /* poly synth memory write */      dcl (msb, lsb) fixed;      msb = msb + shr(lsb, 8);     /* normalize  */      lsb = (lsb and "HFF");      disable;      write(psc) = 0;           /* select channel 0 for consistency */      write(psf) = pswma;       /* write memory address fc */      write(psd) = msb;         /* upper 16 bits */      write(psd) = lsb;         /* lower  8 bits */      enable;   end psmwrite;   polyset: proc(msb, lsb, len, val) recursive swappable; /* set a chunk of poly memory */      dcl (msb, lsb, len, val) fixed;      call psmwrite (msb, lsb); /* set up poly for write */      do len = 1 to len; /* write LEN words */         write(psd) = val; /* of VAL */      end;   end polyset;   /* $subtitle Internal Buffer Management Routines */   /* This procedure computes the last logical sector in file F (rounded up).     The last logical word (plus one) is FILELEN; the last physical sector     is SECLEN; the last physical word is zero. */   logical_EOF: proc(f) returns (fixed); /* compute last logical sector (rounded up) */      dcl f file; /* file to determine logical EOF of */      if seclen (f) = 0 /* see if empty file (this is the only anomaly) */      then return (0); /* if so, the logical end is sector zero */      else return (((seclen (f) - 1) and "HFF00") + shr(filelen (f), 8) + ((filelen (f) and "HFF") <> 0)); /* else compute it */   end logical_EOF;   /* This procedure updates file F's catalog entry if necessary. */   update_cat: proc(f) recursive swappable; /* update catalog entry for file F */      dcl f               file; /* file to update */      dcl fcb (f#len - 1) fixed; /* catalog FCB */      if cat_entry (f) < 0 then return; /* ignore current file (until accesses are implemented) */      call readcat (ms_catalog (f), ls_catalog (f), (((cat_entry (f) + 1)*c#len + 255) and (not "HFF")), 0, 0); /* read in its catalog */      call get_fcb (cat_entry (f), fcb); /* get its FCB */      ms_sector = c#ms_sector + fcb (f#ms); /* get starting sector */      ls_sector = c#ls_sector + fcb (f#ls);      if ls_sector ilt c#ls_sector then ms_sector = ms_sector + 1;      if ((ms_sector = ms_start (f)) and (ls_sector = ls_start (f)) and (fcb (f#ml) = 0) /* if it's the same file */      and ((seclen (f) <> fcb (f#ll)) or (filelen (f) <> fcb (f#wd)))) then do; /* if the sector or file length has changed, update the catalog */         fcb (f#ll) = seclen (f); /* update sector length */         fcb (f#wd) = filelen (f); /* update file length */         call put_fcb (cat_entry (f), fcb); /* and put it back */         call write_catalog; /* write the catalog back out */      end; /* of updating the catalog */   end update_cat;   /* This procedure flushes file F's buffer if it's been modified. */   flush: proc(f) recursive swappable; /* flush the current buffer for file F */      dcl f file; /* file to flush the buffer of */      if dirty (f) then do; /* flush the buffer if necessary */         ms_sector = ms_start (f); /* determine where the buffer was read from */         ls_sector = ls_start (f) + (secpos (f) - shr(buflen (f) + 255, 8));         if ls_sector ilt ls_start (f) then ms_sector = ms_sector + 1;         extdata (0) = bufptr (f); extdata (3) = buflen (f); /* set up start and length */         do case (bufmed (f)); /* write out buffer */            call writedata (ms_sector, ls_sector, location(bufptr (f)), buflen (f));            call extwrite  (ms_sector, ls_sector, extdata); /* external memory */            call polywrite (ms_sector, ls_sector, extdata, 0); /* poly memory */         end; /* of write out buffer */         if (dirty (f) and b$len) <> 0 /* if its length has changed */         then call update_cat (f); /* update its catalog entry */         dirty (f) = false; /* buffer now matches the disk */      end; /* of flushing the buffer */   end flush;   /* $page */   /* This procedure reads the next buffer from file F. */   readbuf: proc(f) recursive swappable; /* read in the next buffer from the file F */      dcl f file; /* file to read the next buffer from */      call flush (f); /* write out any buffer changes */      if ((secpos (f) + shr(bufsiz (f), 8) ige logical_EOF (f)) /* check if we'll go past the logical EOF */      and ((filepos (f) + bufsiz (f) igt filelen (f)) or (filepos (f) + bufsiz (f) ilt bufsiz (f)))) /* be careful of wrapping around */      then buflen (f) = filelen (f) - filepos (f); /* restrict length to read (don't read past EOF) */      else buflen (f) = bufsiz (f); /* we can read a whole buffer full */      ms_sector = ms_start (f); /* find where next buffer is located */      ls_sector = ls_start (f) + secpos (f);      if ls_sector ilt ls_start (f) then ms_sector = ms_sector + 1;      extdata (0) = bufptr (f); extdata (3) = buflen (f); /* set up start and length */      do case (bufmed (f)); /* read in next buffer */         call readdata (ms_sector, ls_sector, location(bufptr (f)), buflen (f));         call extread  (ms_sector, ls_sector, extdata); /* external memory */         call polyread (ms_sector, ls_sector, extdata, 0); /* poly memory */      end; /* of read in next buffer */      secpos (f) = secpos (f) + shr(buflen (f) + 255, 8); /* point past this buffer */      filepos (f) = filepos (f) + buflen (f); /* move the word pointer as well */      bufpos (f) = 0; /* reset character position */      if buflen (f) <> bufsiz (f) /* zero out to the end of the buffer */      then do case (bufmed (f)); /* (so PUTC works properly!) */         call blockset (location(bufptr (f) + buflen (f)), bufsiz (f) - buflen (f) - 1, 0);         call extset   (bufptr (f), buflen (f), bufsiz (f) - buflen (f) - 1, 0);         call polyset  (bufptr (f), buflen (f), bufsiz (f) - buflen (f) - 1, 0);      end; /* of zeroing out to end of buffer */   end readbuf;   /* $page */   /* This procedure reads the next buffer from file F.  It differs from     READBUF in that it will go past the logical end-of-file if the next     buffer goes past it.  This routine is used only by PUTC and PUTW     to allow you to APPEND to the file. */   read_next: proc(f) recursive swappable; /* read the next bufferfull from file F (go past logical eof if necessary) */      dcl f file; /* pointer to file to read */      dcl i fixed;      if ((filepos (f) = filelen (f)) and (secpos (f) = logical_EOF (f))) then do; /* check for logical end of file */         filelen (f) = filelen (f) + 1; /* increase the length of the file by one word */         dirty (f) = (dirty (f) or b$len); /* flag length change */         if buflen (f) = bufsiz (f) /* if we're now at the physical end of the buffer */         then do; /* then read in the next buffer */            call readbuf (f); /* like so */            do case (bufmed (f)); /* zero the upper byte of the first word */               call pbyte(location(bufptr (f) - 1), bufpos (f) + 1, 0); /* internal */               do; /* external */                  write(mam) = bufptr (f); /* point to start of buffer */                  write(md) = (read(md) and "HFF"); /* toss out upper byte */               end; /* external */               do; /* poly */                  call psmread (bufptr (f), 0); /* set up to read first word of buffer */                  i = (read(psd) and "HFF"); /* toss out upper byte */                  call psmwrite (bufptr (f), 0); /* set up to write first word */                  write(psd) = i; /* write it */               end; /* poly */            end; /* of zeroing upper byte of first word */         end; /* of read in the next buffer */         else do; /* otherwise move forward in current buffer */            if (filepos (f) and "HFF") = 0 /* are we entering an uncharted sector? */            then secpos (f) = secpos (f) + 1; /* yes, we need to increment the sector position */            filepos (f) = filepos (f) + 1; /* increment the file (word) position */            buflen (f) = buflen (f) + 1; /* increase the buffer length by one */         end;      end; /* of at eof */      else call readbuf (f); /* read the next bufferfull if not at end of file */   end read_next;   /* $subtitle FOpen, FClose, & SetBuf */   /* This procedure opens a file and initializes file variables. */   fopen: proc(filename, access) returns (file) public recursive swappable; /* open a file */      dcl filename fixed array;      dcl access   fixed array; /* 'r' for read, 'w' for write, 'a' for append, 'r+' for read/append, 'w+' for read/write, 'a+' for write/append */      dcl f        file; /* file descriptor for opened file */      dcl current  boolean; /* TRUE if opening current file */      if filename (0) <> current_file (0) /* if lengths don't match */      then current = false; /* not opening current file */      else do; /* may be opening current file */         current = true; f = 1; /* assume opening current file */         do while (current and (f < shr(current_file (0), 1))); /* check every word */            if (filename (f) or shl("040", 8) or "040") <> current_file (f) /* if this word doesn't match */            then current = false; /* no go */            else f = f + 1; /* look at next word */         end; /* check every word */      end; /* of may be opening current file */            file_error = f$okay; /* no errors yet */      f = nullf; /* assume we can't open the file */      if (current or (locate (filename, 1) and ((f#ms_length and "HFF") = 0))) then do; /* we found it/it's not too big - open it up */         f = 0;         do while ((f < max_files) and (cat_entry (f) <> -1)); /* look for a free file descriptor */            f = f + 1;         end;         if f = max_files then do; /* if no free file descriptors */            file_error = f$too_many; /* too many files open */            f = nullf;         end;         else do; /* we found one */            if current then do; /* current file? don't allow write access */               ms_catalog (f) = -1; ls_catalog (f) = -2; cat_entry (f) = -2; /* no catalog (-2 so it isn't considered free) */               ms_start (f) = core(loc.csec + 1); /* ge origin */               ls_start (f) = core(loc.csec);               seclen (f) = core(loc.csln); /* length */               filelen (f) = core(loc.clen); /* word length */            end; /* of current file */            else do; /* opened file */               ms_catalog (f) = c#ms_sector; /* remember catalog origin */               ls_catalog (f) = c#ls_sector;               cat_entry (f) = findfile (f#name); /* and its catalog entry (FCB number) */               ms_start (f) = f#ms_sector; /* remember file origin */               ls_start (f) = f#ls_sector;               seclen (f) = f#ls_length; /* and length */               filelen (f) = f#words; /* and word length */            end; /* of opened file */            secpos (f) = 0; filepos (f) = 0; /* point to start of file */            buflen (f) = 0; bufpos (f) = 0; dirty (f) = false; /* initialize buffer variables */         end; /* of found one */      end; /* of opening it */      else if (f#ms_length and "HFF") <> 0 then file_error = f$too_big; /* file is too large to process */      else file_error = f$no_file; /* file doesn't exist */      return (f); /* return the associated file pointer */   end fopen;   /* $page */   /* This procedure closes a previously opened file. */   fclose: proc(f) returns (fixed) public recursive swappable; /* close a file */      dcl f file; /* pointer to file to read */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      call flush (f); /* flush the buffer if the buffer has changed */      ms_start (f) = -1; ls_start (f) = -1; seclen (f) = 0; filelen (f) = 0; secpos (f) = 0; filepos (f) = 0; /* set file parameters to zero */      cat_entry (f) = -1; buflen (f) = 0; bufpos (f) = 0; /* and buffer parameters */      return (0); /* closed it okay */   end fclose;   /* This procedure sets the file buffer for the last opened file to     a buffer passed by the user of these routines. */   setbuf: proc(f, buf, med, siz) returns (fixed) public recursive swappable; /* set the file buffer to a user's buffer - operates on last file opened ONLY */      dcl f   file; /* file to set buffer for */      dcl buf fixed; /* the buffer in question */      dcl med fixed; /* medium of the buffer in question (0: internal, 1: external, 2: poly) */      dcl siz fixed; /* size of buffer in question */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      if ((buflen (f) <> 0) or ((buflen (f) = 0) and (secpos (f) <> 0)) /* have we read the file yet? */      or ((ms_start (f) = -1) and (ls_start (f) = -1))) then do; /* or is it closed? */         file_error = f$bad_arg;         return (EOF_mark);      end;      bufptr (f) = buf; /* set the pointer */      bufmed (f) = med; /* save the medium */      bufsiz (f) = (siz and (not "HFF")); /* and the size (to nearest sector) */      return (0); /* okay */   end setbuf;   /* $subtitle FFlush & FEOF */   /* This procedure flushes file F's buffer. */   fflush: proc(f) returns (fixed) public recursive swappable; /* flush file F's buffer */      dcl f file; /* pointer to file to read */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      call flush (f); /* flush the buffer if the buffer has changed */      return (0); /* done */   end fflush;   /* This procedure returns TRUE if we're at the end of file F, FALSE otherwise. */   feof: proc(f) returns (boolean) public; /* return TRUE if at end-of-file */      dcl f file; /* file to check */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (true);      end;      if bufmed (f) = -1 then do; /* oops - no buffer */         file_error = f$no_buffer;         return (true);      end;      file_error = f$okay; /* clear the air */      if ((filepos (f) = filelen (f)) and (secpos (f) = logical_EOF (f)) and (bufpos (f) = shl(buflen (f), 1)))      then return (true); /* at logical end-of-file */      else return (false); /* not at end */   end feof;   /* $subtitle GetC & GetW */   /* This procedure reads a file into a buffer and returns the     next character or EOF mark (EOF_MARK) of the file. */   getc: proc(f) returns (fixed) public swappable; /* get next character from F */      dcl f    file; /* file to read */      dcl char fixed; /* character or EOF */      if feof (f) /* check for logical end of file */      then char = EOF_mark; /* end of file */      else do; /* otherwise get next character */         call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */         if bufpos (f) = shl(buflen (f), 1) then call readbuf (f); /* read the next bufferfull */         char = shr(bufpos (f), 1); /* get word offset of next char */         do case (bufmed (f)); /* get word with next character in it */            char = core(bufptr (f) + char); /* internal */            do; /* external */               write(mam) = bufptr (f) + shr(char, 8); /* point to next word in buffer */               write(mal) = char;               char = read(md); /* get it */            end; /* external */            do; /* poly */               call psmread (bufptr (f), char); /* set up to read next word */               char = read(psd); /* get it */            end; /* poly */         end; /* of get next character */         if bufpos (f) /* if looking for an odd byte */         then char = shr(char, 8); /* get next from upper */         else char = (char and "HFF"); /* even - keep lower */         bufpos (f) = bufpos (f) + 1;      end;      return (char);   end getc;   /* $page */   /* This procedure returns the next word in a line or an EOF mark.     NOTE:  If the next word in the file is a -1, it will be returned     even though the EOF may not have been reached. */   getw: proc(f) returns (fixed) public swappable; /* get next word from F */      dcl f    file; /* pointer to file to read */      dcl word fixed;      dcl temp fixed;      if bufpos (f) then do; /* if starting from an odd character, do it the hard way */         word = getc (f); /* get first character */         if word <> EOF_mark then do; /* if not at end */            temp = getc (f); /* get second character */            if temp <> EOF_mark /* if not at end */            then word = (word or shl(temp, 8)); /* construct word */            else word = EOF_mark; /* else return EOF */         end;      end; /* of starting on an odd character */      else do; /* starting on a word boundary - do it FAST */         if feof (f) /* check for logical end of file */         then word = EOF_mark; /* end of file */         else do; /* otherwise get next word */            call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */            if bufpos (f) = shl(buflen (f), 1) then call readbuf (f); /* read the next bufferfull */            do case (bufmed (f)); /* get the next word */               word = core(bufptr (f) + shr(bufpos (f), 1)); /* internal */               do; /* external */                  word = shr(bufpos (f), 1); /* get word offset */                  write(mam) = bufptr (f) + shr(word, 8);                  write(mal) = word;                  word = read(md); /* get it */               end; /* of external */               do; /* poly */                  call psmread (bufptr (f), shr(bufpos (f), 1));                  word = read(psd); /* get it */               end; /* of poly */            end; /* of get the next word */            bufpos (f) = bufpos (f) + 2;         end;      end; /* of on a word boundary */      return (word);   end getw;      /* $subtitle FGetS */   /* This procedure returns the next line of a file and the line number.      When it reaches the end of the file, it then returns an EOF mark.     NOTE:  The line# could be -1 and hence could be confused with the EOF. */   fgets: proc(line, maxline, f) returns (fixed) public recursive swappable; /* get next line (and line #) from F */      dcl line    fixed array;      dcl maxline fixed;      dcl f       file; /* pointer to file to read */      dcl number  fixed;      dcl nword   fixed;      dcl i       fixed;      number = getw (f); /* get line number */      if number <> EOF_mark then do; /* if not at end of file */         line (0) = 0; /* initialize the number of bytes in the line */         i = 1; /* and the index into line */         nword = getw (f); /* get first word */         do while (((nword and "177") <> 0) and ((nword and shl("177", 8)) <> 0) and ((nword and "100200") = 0)); /* look for valid text (both end-of-line and end-of-file are invalid text) */            if line (0) < maxline then do; /* if we haven't exceeded the line length */               line (i) = nword; /* save next word */               line (0) = line (0) + 2; /* increase # of bytes stored */               i = i + 1; /* point to next entry in LINE */            end;            nword = getw (f); /* get next character */         end;         if (nword and "HFF00") = 0 then do; /* if we found an end-of-line, it's a text file */            if (nword and "HFF") <> 0 then do; /* if one last byte */               if line (0) < maxline then do; /* if we haven't gone over */                  line (i) = nword; /* save last byte */                  line (0) = line (0) + 1; /* increase # of bytes stored */               end;            end;            if line (0) > maxline /* if we went a little too far (only one character max!) */            then line (0) = maxline; /* truncate down */         end; /* of valid text file */         else do; /* not a text file */            file_error = f$bad_arg; /* invalid operation requested - cannot FGETS non-text files */            number = EOF_mark; /* return EOF */         end;      end; /* of not at end of file */      return (number); /* return line number */   end fgets;   /* $subtitle PutC & PutW */   /* This procedure writes the passed character to the specified file     at the current location.  The passed character is returned if we     succeed.  Otherwise, EOF_MARK is returned. */   putc: proc(char, f) returns (fixed) public swappable; /* put specified character to F */      dcl char fixed; /* the character to write */      dcl f    file; /* file to read */      dcl i    fixed;      if (((not feof (f)) and (file_error <> f$okay)) /* check for bad file descriptor */      or ((secpos (f) = seclen (f)) and (filepos (f) = filelen (f)) and (bufpos (f) = shl((buflen (f) + 255) and "HFF00", 1)))) /* at physical eof? */      then char = EOF_mark; /* we're at end of file */      else do; /* not at physical eof, write next character */         call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */         if bufpos (f) = shl(buflen (f), 1) then call read_next (f); /* read the next bufferfull */         char = (char and "HFF"); /* make sure we save and return one character */         do case (bufmed (f)); /* write the next character */            call pbyte(location(bufptr (f) - 1), bufpos (f), char); /* internal */            do; /* external */               write(mam) = bufptr (f) + shr(bufpos (f), 8 + 1); /* point to next word in buffer */               write(mal) = shr(bufpos (f), 1);               if bufpos (f) /* if odd */               then write(md) = (shl(char, 8) or (read(md) and "HFF")); /* put in upper */               else write(md) = ((read(md) and (not "HFF")) or char); /* else put in lower */            end; /* external */            do; /* poly */               call psmread (bufptr (f), shr(bufpos (f), 1)); /* set up to read containing word */               i = read(psd); /* get it */               call psmwrite (bufptr (f), shr(bufpos (f), 1)); /* set up to read containing word */               if bufpos (f) /* if odd */               then write(psd) = (shl(char, 8) or (i and "HFF")); /* put in upper */               else write(psd) = ((i and (not "HFF")) or char); /* else put in lower */            end; /* poly */         end; /* of write the next character */         bufpos (f) = bufpos (f) + 1;         dirty (f) = (dirty (f) or b$dirty); /* the buffer is now dirty */      end; /* of not at physical eof */      return (char);   end putc;   /* $page */   /* This procedure writes the passed word to the specified file.  If we     succeed, the same word is returned.  Otherwise, EOF_MARK is returned.     NOTE:  If the word is -1, the procedure will return a -1 even though            it may not have reached an EOF mark.  It is therefore best to            use such constructs as IF PUTW (WORD, F) <> WORD instead of            the more obvious IF PUTW (WORD, F) = EOF_MARK which will            fail under some circumstances. */   putw: proc(word, f) returns (fixed) public; /* put specified word to F */      dcl word fixed; /* word to write */      dcl f    file; /* pointer to file to read */      dcl temp fixed;      if bufpos (f) then do; /* if starting from an odd character, do it the hard way */         temp = putc (word, f); /* write out first character */         if temp <> EOF_mark /* if not at end */         then temp = putc (shr(word, 8), f); /* write second character */         if temp = EOF_mark /* at end of file? */         then word = EOF_mark; /* yes, return EOF_MARK */      end; /* of starting on an odd character */      else do; /* starting on a word boundary - do it FAST */         if (((not feof (f)) and (file_error <> f$okay)) /* check for bad file descriptor */         or ((secpos (f) = seclen (f)) and (filepos (f) = filelen (f)) and (bufpos (f) = shl((buflen (f) + 255) and "HFF00", 1)))) /* at physical eof? */         then word = EOF_mark; /* we're at end of file */         else do; /* not at physical eof, write next word */            call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */            if bufpos (f) = shl(buflen (f), 1) then call read_next (f); /* read the next bufferfull */            do case (bufmed (f)); /* store the next word */               core(bufptr (f) + shr(bufpos (f), 1)) = word; /* internal */               do; /* external */                  write(mam) = bufptr (f) + shr(bufpos (f), 8 + 1);                  write(mal) = shr(bufpos (f), 1);                  write(md) = word; /* put it */               end; /* of external */               do; /* poly */                  call psmwrite (bufptr (f), shr(bufpos (f), 1));                  write(psd) = word; /* put it */               end; /* of poly */            end; /* of store the next word */            bufpos (f) = bufpos (f) + 2;            dirty (f) = (dirty (f) or b$dirty); /* the buffer is now dirty */         end; /* of not at physical eof */      end; /* of on a word boundary */      return (word);   end putw;      /* $subtitle FPutS */   /* This procedure writes the passed line to the specified file.  If     we succeed, the passed line number is returned.  Otherwise, EOF_MARK     is returned.     NOTE:  Since -1 is a valid line number, there may be some confusion            regarding whether we've reached the end-of-file.  See the            comments under PUTW above. */   dcl seek proc(file, fixed, fixed) returns (fixed) recursive; /* seek to a position in the file */   fputs: proc(line, number, f) returns (fixed) public recursive swappable; /* put specified line (and line #) to F */      dcl line   fixed array; /* the line to write */      dcl number fixed; /* the line number to give said line */      dcl f      file; /* pointer to file to write */      dcl i      fixed;      if putw (number, f) = number then do; /* if not at end of file */         i = 1; /* initialize the index into LINE */         do while ((i <= shr(line (0), 1)) and (number <> EOF_mark)); /* look for end-of-line or end-of-file */            if putw (line (i), f) <> line (i) /* try to write next word */            then number = EOF_mark; /* couldn't do it; flag the end */            i = i + 1; /* point to next word */         end;         if number <> EOF_mark then do; /* watch out for EOF */            if line (0) /* is number of bytes odd? */            then i = (line (i) and "HFF"); /* yes, get last byte and EOL byte */            else i = 0; /* no, get EOL word */            if putw (i, f) <> i /* write out the last word */            then number = EOF_mark; /* oops, we're at the end */         end;         if number = EOF_mark then do; /* if the entire line couldn't be written out */            call seek (f, -1, 1); /* try to clean up */            call putc (f, a.nul); /* by ending with a null */         end; /* of entire line couldn't be written */      end; /* of not at end of file */      else number = EOF_mark; /* end of file */      return (number); /* return line number */   end fputs;   /* $subtitle FFull */   /* This procedure checks to see if writing the specified number of bytes     to the specified file will cause its file buffer to become full and     hence be flushed.  A boolean TRUE is returned if the buffer will be     flushed.  Otherwise, a boolean FALSE is returned. */   ffull: proc(bytes, fputs, f) returns (boolean) public recursive swappable; /* see if this many bytes fills F's buffer */      dcl bytes fixed; /* number of bytes to write to the file */      dcl fputs boolean; /* TRUE if we are going to call FPUTS with these bytes */      dcl f     file; /* pointer to file to check */      dcl pos   fixed; /* buffer lookahead pointer */      dcl full  boolean; /* TRUE when the buffer's full */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      file_error = f$okay; /* clear the air */      if fputs then do; /* if we are putting a line */         bytes = bytes + 2 + 1; /* account for line number and end-of-line bytes */         if bytes /* number of bytes odd? */         then bytes = bytes + 1; /* make even - must end lines on word boundaries */      end; /* of putting a line */      pos = bufpos (f); /* pick up current buffer position */      full = false; /* the buffer isn't full yet */      do while ((pos ilt bufpos (f) + bytes) and (not full)); /* loop until we've "written" all bytes (or buffer's full) */         if pos = shl(buflen (f), 1) /* if the buffer's full */         then full = true; /* remember it */         else pos = pos + 1; /* "write" next byte */      end; /* of "writing" all bytes */      return (full); /* return whether the buffer's full */   end ffull;   /* $subtitle FRead & FWrite */   /* This procedure reads a NUMBER of records of size SIZE bytes     from file F into BUFFER.  It returns the number of records     actually read. */   fread: proc(buf, size, number, f) returns (fixed) public recursive swappable; /* read one or more records from F */      dcl buf    fixed array; /* buffer to read into */      dcl size   fixed; /* size of record in bytes */      dcl number fixed; /* number of records to read */      dcl f      file; /* pointer to file to read */      dcl words  fixed; /* number of words to transfer */      dcl pos    fixed; /* current buffer word position */      dcl modelc boolean; /* TRUE if Model C or later processor */      dcl (i, j) fixed;      modelc = (processor_type >= 2); /* determine if Model C processor */      number = size*number; /* calculate total bytes to transfer */      words = shr(number, 1); /* calculate number of words to transfer */      i = 0; /* initialize word counter */      if bufpos (f) /* if buffer position odd */      then do while ((i < words) and (not feof (f))); /* transfer a word at a time */         buf (i) = getw (f);         i = i + 1;      end; /* of transfer a word at a time (buffer position odd) */      else do while ((i < words) and (not feof (f))); /* buffer position even - blast the buffer over */         call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */         if bufpos (f) = shl(buflen (f), 1) then call readbuf (f); /* read the next bufferfull */         pos = shr(bufpos (f), 1); /* get word position */         if (words - i) <= buflen (f) - pos /* if it's all in the buffer */         then j = (words - i); /* copy WORDS */         else j = buflen (f) - pos; /* just get what's left in the buffer */         do case (bufmed (f)); /* get the next word */            do; /* internal */               write(r13) = bufptr (f) + pos; /* set up internal memory pointer */               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(mr0i) = read(mr13i);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  buf (i) = read(mr13i);               end; /* of read it in */            end; /* of internal */            do; /* external */               write(mam) = bufptr (f) + shr(pos, 8); /* set up external memory pointer */               write(mal) = pos;               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(mr0i) = read(mdi);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  buf (i) = read(mdi);               end; /* of read it in */            end; /* of external */            do; /* poly */               call psmread (bufptr (f), pos); /* set up poly memory pointer */               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(mr0i) = read(psd);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  buf (i) = read(psd);               end; /* of read it in */            end; /* of poly */         end; /* of get the next word */         bufpos (f) = bufpos (f) + shl(j, 1); /* bump up buffer position */      end; /* of buffer position even - blast the buffer over */      i = shl(i, 1); /* get bytes transferred */      if (number and (not feof (f))) then do; /* if an odd byte at the end */         buf (shr(i, 1)) = getc (f); /* get last byte */         i = i + 1; /* one more byte */      end;      return (i/size); /* return number of records transferred */   end fread;   /* $page */   /* This procedure writes a NUMBER of records of size SIZE bytes     from BUFFER to file F.  It returns the number of records     actually written. */   fwrite: proc(buf, size, number, f) returns (fixed) public recursive swappable; /* write one or more records to F */      dcl buf    fixed array; /* buffer to write from */      dcl size   fixed; /* size of record in bytes */      dcl number fixed; /* number of records to read */      dcl f      file; /* pointer to file to write */      dcl words  fixed; /* number of words to transfer */      dcl pos    fixed; /* current buffer word position */      dcl modelc boolean; /* TRUE if Model C or later processor */      dcl (i, j) fixed;      if ((not feof (f)) and (file_error <> f$okay)) then return (0); /* check for bad file descriptor */      modelc = (processor_type >= 2); /* determine if Model C processor */      number = size*number; /* calculate total bytes to transfer */      words = shr(number, 1); /* calculate number of words to transfer */      i = 0; /* initialize word counter */      if bufpos (f) /* if buffer position odd */      then do while ((i < words) and (putw (buf (i), f) = buf (i))); /* transfer a word at a time */         i = i + 1;      end; /* of transfer a word at a time (buffer position odd) */      else do while ((i < words) /* buffer position even - blast the buffer over */      and not ((secpos (f) = seclen (f)) and (filepos (f) = filelen (f)) and (bufpos (f) = shl((buflen (f) + 255) and "HFF00", 1)))); /* while not at physical eof */         call trigger_motor (shr(ms_start (f), 8)); /* keep floppies going */         if bufpos (f) = shl(buflen (f), 1) then call read_next (f); /* read the next bufferfull */         pos = shr(bufpos (f), 1); /* get word position */         if (words - i) <= buflen (f) - pos /* if more is in the buffer than what we're copying */         then j = (words - i); /* copy WORDS */         else j = buflen (f) - pos; /* just copy over the rest of the buffer */         do case (bufmed (f)); /* branch on buffer media */            do; /* internal */               write(r13) = bufptr (f) + pos; /* set up internal memory pointer */               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(mr13i) = read(mr0i);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  write(mr13i) = buf (i);               end; /* of read it in */            end; /* of internal */            do; /* external */               write(mam) = bufptr (f) + shr(pos, 8); /* set up external memory pointer */               write(mal) = pos;               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(mdi) = read(mr0i);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  write(mdi) = buf (i);               end; /* of read it in */            end; /* of external */            do; /* poly */               call psmwrite (bufptr (f), pos); /* set up poly memory pointer */               if modelc then do; /* for model C */                  if j igt 256 then j = 256; /* limit to 256 words */                  write(r0) = addr(buf (i)); /* pick up buffer address */                  write(r1) = j; write(sub1) = 1; /* get repeat count */                  repeat read(r1); /* read it in */                  write(psd) = read(mr0i);                  i = i + j; /* account for xfer */               end; /* of model C */               else do i = i to i + j - 1; /* not model C - read it in */                  write(psd) = buf (i);               end; /* of read it in */            end; /* of poly */         end; /* of branch on buffer media */         bufpos (f) = bufpos (f) + shl(j, 1); /* bump up buffer position */         dirty (f) = (dirty (f) or b$dirty); /* the buffer is now dirty */      end; /* of buffer position even - blast the buffer over */      i = shl(i, 1); /* get bytes transferred */      if (number and (putc (buf (shr(i, 1)), f) = (buf (shr(i, 1)) and "HFF"))) /* if an odd byte at the end */      then i = i + 1; /* one more byte */      return (i/size); /* return number of records transferred */   end fwrite;   /* $subtitle Seek */   /* This procedure seeks to a given place in the specified file.  It     returns the logical position of the file after the SEEK.  (This is     really a cross between FSEEK and SEEK since we need SEEK's args for now.) */   seek: proc(f, offset, origin) returns (fixed) public recursive swappable; /* seek to a given place in the given file */      dcl f      file; /* pointer to file to seek through */      dcl offset fixed; /* where to seek to (word offset) */      dcl origin fixed; /* 0: seek from byte zero, 1: seek from current position, 2: seek from end of file, 3-5: same as 0-2, but treat OFFSET as a sector offset */      dcl newsec fixed; /* new sector position to seek to */      dcl newpos fixed; /* new byte position (in sector NEWSEC) to seek to (0 -> 511) */      dcl to_EOF boolean; /* TRUE if we're trying to seek right to the logical EOF */      sector_seek: proc(f, newsec); /* seek to sector NEWSEC */         dcl f      file; /* pointer to file to seek through */         dcl newsec fixed; /* new sector to seek to */         if ((newsec ige secpos (f) - shr(buflen (f) + 255, 8)) and (newsec ilt secpos (f))) /* see if we're moving to someplace in the buffer */         then bufpos (f) = shl(newsec - (secpos (f) - shr(buflen (f) + 255, 8)), 8 + 1); /* if so, just reset buffer pointer */         else do; /* we need to read in a new buffer */            call flush (f); /* flush this buffer */            secpos (f) = newsec; /* set new sector position */            filepos (f) = shl(secpos (f), 8); /* and new word position */            call readbuf (f); /* and read it in */         end; /* of reading in new buffer */      end sector_seek;      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      if bufmed (f) = -1 then do; /* oops - no buffer */         file_error = f$no_buffer;         return (EOF_mark);      end;      if origin igt 5 then do; /* origin out of bounds? */         file_error = f$bad_arg;         return (EOF_mark);      end;      /* $page */      file_error = f$okay; /* no error */      to_EOF = false; /* assume we're NOT trying to seek right to the logical EOF */      if origin < 3 then do; /* offset is in words */         do case (origin); /* set base according to the origin */            do; /* move relative to the start of file */               newsec = 0; newpos = 0; /* point to start of file */            end;            do; /* move relative to current position */               newsec = (secpos (f) - shr(buflen (f) + 255, 8)) + shr(bufpos (f), 9); /* current sector */               newpos = (bufpos (f) and "H1FF"); /* current byte position in that sector */            end;            do; /* move relative to the logical end-of-file */               newsec = logical_EOF (f) - 1; /* point to logical end-of-file */               newpos = shl(filelen (f) and "HFF", 1); /* and current byte position in last sector */               if newpos = 0 then newsec = newsec + 1; /* we are in the last sector exactly */            end;         end; /* of setting base */         if offset < 0 then do; /* negative offset? */            newsec = newsec - shr(abs(offset), 9); /* get pointer to new sector */            newpos = newpos - (abs(offset) and "H1FF"); /* and new position in that sector */            if newpos < 0 then do; /* if NEWPOS is now out of range */               newsec = newsec - 1; /* means we're moving to the previous sector */               newpos = newpos + 512; /* and put NEWPOS back in range */            end;         end; /* of negative offset */         else do; /* positive or zero offset */            newsec = newsec + shr(offset, 9); /* get pointer to new sector */            newpos = newpos + (offset and "H1FF"); /* and new position in that sector */            if newpos >= 512 then do; /* if NEWPOS is now out of range */               newsec = newsec + 1; /* means we're moving to the next sector */               newpos = newpos - 512; /* and put NEWPOS back in range */            end;         end; /* of positive or zero offset */         if newsec ige logical_EOF (f) then do; /* if sector is out of bounds */            if offset < 0 then do; /* if negative offset given */               newsec = 0; newpos = 0; /* seek back to beginning of file */            end;            else do; /* if positive or zero offset given */               newsec = logical_EOF (f) - 1; /* seek to end of file */               newpos = ((shl(filelen (f), 1) - 1) and "H1FF"); /* less one byte */               to_EOF = true; /* we're trying to seek right up to the logical EOF */            end;         end; /* of forcing back into range */         call sector_seek (f, newsec); /* seek to the new sector */         bufpos (f) = bufpos (f) + newpos; /* and to the new byte in that sector */         if to_EOF /* if we're searching to logical EOF */         then bufpos (f) = bufpos (f) + 1; /* point right to logical EOF */         return (shl(filepos (f) - buflen (f), 1) + bufpos (f)); /* return the character position of the file */      end; /* of offset is in words */      /* $page */      else do; /* offset is in sectors */         do case (origin - 3); /* set target according to the origin */            newsec = offset; /* move relative to the start of file */            newsec = (secpos (f) - shr(buflen (f) + 255, 8)) + shr(bufpos (f) + 511, 9) + offset; /* move relative to where we currently are */            newsec = logical_EOF (f) + offset; /* move relative to the logical end of file (physical eof is SECLEN) */         end; /* of setting target */         if newsec ige logical_EOF (f) then do; /* check if out of range */            if offset < 0 /* if negative offset */            then newsec = 0; /* force to start of file */            else do; /* if positive or zero offset */               newsec = logical_EOF (f) - 1; /* force to end of file */               to_EOF = true; /* and remember we want to go right to the logical EOF */            end;         end; /* of forcing in range */         call sector_seek (f, newsec); /* seek to new sector */         if to_EOF /* if we want to go right up to the logical EOF */         then bufpos (f) = shl(buflen (f), 1); /* put buffer pointer at end of file */         return ((secpos (f) - shr(buflen (f) + 255, 8)) + shr(bufpos (f) + 511, 9)); /* return the sector position of the file */      end; /* of offset is in sectors */   end seek;   /* $subtitle Shuffle */   /* This procedure shuffles part of a disk file up or down on the disk. */   shuffle: proc(f, source, destination, length) returns (fixed) public recursive swappable; /* shuffle an area of the disk somewhere else */      dcl f           file; /* file to shuffle */      dcl source      fixed; /* starting sector for shuffle */      dcl destination fixed; /* destination sector for shuffle */      dcl length      fixed; /* length to shuffle (in sectors) */      dcl ms_source   fixed; /* MS starting sector for shuffle */      dcl ms_dest     fixed; /* MS destination sector for shuffle */      dcl amount      fixed; /* amount to shuffle at one time */      if f ige max_files then do; /* bad file descriptor? */         file_error = f$bad_file;         return (EOF_mark);      end;      if bufmed (f) = -1 then do; /* oops - no buffer */         file_error = f$no_buffer;         return (EOF_mark);      end;      file_error = f$okay; /* clear the air */      if ((source ige logical_EOF (f)) or (destination ige seclen (f)) or (length igt logical_EOF (f)) /* out of bounds? */      or (source + length igt logical_EOF (f)) or (destination + length igt seclen (f))) /* make sure source within logical and destination within physical */      then return (EOF_mark); /* return EOF if out of range */      /* $page */      call flush (f); /* flush the file buffer */      secpos (f) = 0; filepos (f) = 0; buflen (f) = 0; bufpos (f) = 0; /* zap all pointers */      dirty (f) = (dirty (f) or b$len); /* flag length change */      if destination igt source then do; /* to shuffle up, we need to start from the top */         if destination + length igt logical_EOF (f) /* are we increasing the logical size of the file? */         then filelen (f) = filelen (f) + shl(destination + length - logical_EOF (f), 8); /* yes, increase it */         source = source + length; /* start at the end of the block */         destination = destination + length; /* same for the target block */      end; /* of shuffling up */      else do; /* we are shuffling down */         if source + length = logical_EOF (f) then do; /* are we decreasing the logical size of the file? */            if shr(filelen (f), 8) ilt source - destination /* do we need to decrease the sector length as well (are we crossing a 256-sector block boundary? */            then seclen (f) = ((seclen (f) - (source - destination)) and "HFF00"); /* yes, decrease the sector length as well */            filelen (f) = filelen (f) - shl(source - destination, 8); /* decrease logical size of file */         end;      end; /* of shuffling down */      ms_source = ms_start (f); /* determine absolute source sector */      source = ls_start (f) + source;      if source ilt ls_start (f) then ms_source = ms_source + 1;      ms_dest = ms_start (f); /* and the absolute destination sector */      destination = ls_start (f) + destination;      if destination ilt ls_start (f) then ms_dest = ms_dest + 1;      do while (length <> 0); /* shuffle until no more sectors to shuffle */         if length igt shr(bufsiz (f), 8) then amount = shr(bufsiz (f), 8); else amount = length; /* amount = min(length, bufsiz/256); */         if destination igt source then do; /* moving up? */            if source ilt amount then ms_source = ms_source - 1; /* borrow */            source = source - amount; /* yes, point to next block (below us) */            if destination ilt amount then ms_dest = ms_dest - 1; /* borrow */            destination = destination - amount; /* and next destination */         end;         extdata (0) = bufptr (f); extdata (3) = shl(amount, 8);         do case (bufmed (f)); /* shuffle next block */            do; /* internal */               call readdata (ms_source, source, location(bufptr (f)), shl(amount, 8)); /* read next block in */               call writedata (ms_dest, destination, location(bufptr (f)), shl(amount, 8)); /* write it out */            end; /* of internal */            do; /* external */               call extread (ms_source, source, extdata); /* read next block in */               call extwrite (ms_dest, destination, extdata); /* write it out */            end; /* of external */            do; /* poly */               call polyread (ms_source, source, extdata, 0); /* read next block in */               call polywrite (ms_dest, destination, extdata, 0); /* write it out */            end; /* of poly */         end; /* of shuffle next block */         if destination ile source then do; /* no, moving down */            source = source + amount; /* point to next block (above us) */            if source ilt amount then ms_source = ms_source + 1;            destination = destination + amount; /* and next destination */            if destination ilt amount then ms_dest = ms_dest + 1;         end;         length = length - amount; /* keep track of amount left to shuffle */      end; /* of until no more sectors left */      return (0); /* we shuffled okay */   end shuffle;