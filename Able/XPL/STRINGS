/* Some string processing routines (modeled after C):..       TOUPPER (WORD):  Converts WORD to uppercase..              Returns:  The uppercased word..       TOLOWER (WORD):  Converts WORD to lowercase..              Returns:  The lowercased word..       UPPER (S)     :  Converts string S to uppercase..              Returns:  Pointer to S..       LOWER (S)     :  Converts string S to lowercase..              Returns:  Pointer to S..       STRLEN (S)    :  Determine length of string S..              Returns:  Character length of string S..       STRCMP (S, T) :  Compares strings S with string T..              Returns:  0 if S = T, <0 if S < T, >0 if S > T. STRNCMP (S, T, I, J):  Compares N chars of string T (from I to J) with string S..              Returns:  0 if S = T, <0 if S < T, >0 if S > T.       STRCPY (S, T) :  Copy string T to string S..              Returns:  Pointer to S.. STRNCPY (S, T, I, J):  Copy N chars from string T (from I to J) to string S..              Returns:  Pointer to S..       STRCAT (S, T) :  Concatenate string T to the end of string S..              Returns:  Pointer to S..    STRNCAT (S, T, P):  Insert string T at position P of string S..              Returns:  Pointer to S..      INDEX (S, T, P):  Find position of string T in string S; start at position P..              Returns:  Position of string T in string S or -1 if not found..     STRSPN (S, T, P):  Find first occurrence of any char of string T in string S; start at pos P..              Returns:  Position of char from string T in string S or -1 if none found..    STRCSPN (S, T, P):  Find first occurrence of any char not of string T in string S; start at pos P..              Returns:  Position of char not from string T in string S or -1 if none found..    STRNTIN (S, P, Q):  Initializes token scanner w/string S.  Start at position P, stop at position Q..       STRTIN (S)    :  Initializes token scanner w/string S..       STRTOK (S, T) :  Extract next token S (delimited by chars in T) from STRTOKIN string..              Returns:  Pointer to S..       COMPARE (S, T):  Compares strings S with string T ignoring case..              Returns:  TRUE if S = T, FALSE otherwise*/module strings; /* string processing routines */   configuration modelC, NOmuldiv;   insert ':-xpl:literals'; /* get general literals */   insert ':-xpl:asciilit'; /* and ASCII literals */   dcl tokptr pointer; tokptr = -1; /* pointer to string to search */   dcl tokpos fixed; /* current character position in string to search */   dcl tokend fixed; /* position of end of string to search */   dcl bit data ("1",     "2",     "4",     "10",   "20",   "40", /* BIT (I) = shl(1, I) */               "100",   "200",   "400",   "1000", "2000", "4000",             "10000", "20000", "40000", "100000");   toupper: proc(word) returns (fixed) public; /* uppercase an ASCII word */      dcl word fixed; /* the word to uppercase */      if (word and "377") - l.a ile (l.z - l.a) /* is the lower byte lowercase? */      then word = word - (l.a - a.a); /* yes, make it upper */      if (word and "177400") - shl(l.a, 8) ile shl(l.z - l.a, 8) /* and the upper byte? */      then word = word - shl(l.a - a.a, 8); /* yes, make it upper */      return (word); /* return the converted word */   end toupper;   tolower: proc(word) returns (fixed) public; /* lowercase an ASCII word */      dcl word fixed; /* the word to lowercase */      if (word and "377") - a.a ile (a.z - a.a) /* is the lower byte uppercase? */      then word = word + (l.a - a.a); /* yes, make it lower */      if (word and "177400") - shl(a.a, 8) ile shl(a.z - a.a, 8) /* and the upper byte? */      then word = word + shl(l.a - a.a, 8); /* yes, make it lower */      return (word); /* return the converted word */   end tolower;   upper: proc(s) returns (pointer) public; /* convert S to uppercase */      dcl s    fixed array; /* the string to convert */      dcl word fixed;      dcl i    fixed;      do i = 1 to shr(s (0) + 1, 1); /* convert the entire string */         word = s (i); /* get next word */         if (word and "377") - l.a ile (l.z - l.a) /* is the lower byte lowercase? */         then word = word - (l.a - a.a); /* yes, make it upper */         if (word and "177400") - shl(l.a, 8) ile shl(l.z - l.a, 8) /* and the upper byte? */         then word = word - shl(l.a - a.a, 8); /* yes, make it upper */         s (i) = word; /* save result */      end;      return (addr(s (0))); /* return address of passed string */   end upper;   lower: proc(s) returns (pointer) public; /* convert S to lowercase */      dcl s    fixed array; /* the string to convert */      dcl word fixed;      dcl i    fixed;      do i = 1 to shr(s (0) + 1, 1); /* convert the entire string */         word = s (i); /* get next word */         if (word and "377") - a.a ile (a.z - a.a) /* is the lower byte uppercase? */         then word = word + (l.a - a.a); /* yes, make it lower */         if (word and "177400") - shl(a.a, 8) ile shl(a.z - a.a, 8) /* and the upper byte? */         then word = word + shl(l.a - a.a, 8); /* yes, make it lower */         s (i) = word; /* save result */      end;      return (addr(s (0))); /* return address of passed string */   end lower;   strlen: proc(s) returns (fixed) public; /* length of string S */      dcl s fixed array; /* string to determine length of */      return (s (0)); /* return length */   end strlen;   strcmp: proc(s, t) returns (fixed) public; /* string compare a la C: 0 if equal, <0 if s < t, >0 if s > t */      dcl (s, t) fixed array; /* the strings to compare */      dcl len    fixed; /* length of the smallest string */      dcl (i, j) fixed;      if s (0) > t (0) /* is S larger than T? */      then len = t (0); /* yes, min(s (0), t (0)) = t (0) */      else len = s (0); /* no,  min(s (0), t (0)) = s (0) */      i = 0; /* start comparing from first byte */      if s (1) = t (1) then do; /* do word compare if looks like a match */         i = 1; /* start comparing from the first word */         j = shr(len + 1, 1); /* end the comparison at the last word */         do while ((i < j) and (s (i) = t (i))); /* compare each word */            i = i + 1;         end;         i = shl(i - 1, 1); /* go back to starting character of last word compared */      end; /* of word compare */      do while ((i < len) and (byte(s, i) = byte(t, i))); /* compare each byte in last word */         i = i + 1;      end;      if ((i = s (0)) and (i = t (0))) /* perfect match? */      then return (0); /* yes, return zero */      else do; /* no, return difference */         if i = len /* are we at the end of one of the strings? */         then return (s (0) - t (0)); /* yes, return difference in their lengths */         else return (byte(s, i) - byte(t, i)); /* no, return difference in last byte compared */      end;   end strcmp;   strncmp: proc(s, t, i, j) returns (fixed) public; /* compare N chars of string T with string S (i.e., strcmp (S, substr(T, I, J));) */      dcl (s, t) fixed array; /* the strings to compare */      dcl (i, j) fixed; /* indices into T (start & end of substring) */      dcl len    fixed; /* length of smallest string (length to compare) */      dcl slen   fixed; /* length of substring */      dcl (k, l) fixed;      if i ige t (0) then do; /* if I is out of range */         i = 0; j = -1; /* force back in range; compare null string */      end;      else if j ige t (0) then j = t (0) - 1; /* force J back in range */      slen = j - i + 1; /* determine substring length */      if s (0) > slen /* is S larger than substring? */      then len = slen;  /* yes, min(s (0), slen) = slen */      else len = s (0); /* no,  min(s (0), slen) = s (0) */      k = 0; /* start at beginning of S */      if ((not i) and (s (1) = t (shr(i, 1) + 1))) then do; /* if starting on an even byte, start off word by word */         i = shr(i, 1) + 1; /* convert to word offset */         k = 1;         l = shr(len + 1, 1); /* end the comparison at the last word */         do while ((k < l) and (s (k) = t (i))); /* compare each word */            i = i + 1; k = k + 1;         end;         i = shl(i - 1, 1); k = shl(k - 1, 1); /* go back to starting character of last word compared */      end; /* of even byte */      do while ((k < len) and (byte(s, k) = byte(t, i))); /* compare each byte */         i = i + 1; k = k + 1;      end;      if ((k = s (0)) and (i = j + 1)) /* perfect match? */      then return (0); /* yes, return zero */      else do; /* no, return difference */         if k = len /* are we at the end of one of the strings? */         then return (s (0) - slen); /* yes, return difference in their lengths */         else return (byte(s, k) - byte(t, i)); /* no, return difference in last byte compared */      end;   end strncmp;   strcpy: proc(s, t) returns (pointer) public; /* copy string T to string S (i.e., interpret S = T;) */      dcl (s, t) fixed array; /* the strings to copy to and from */      dcl i      fixed;      do i = 0 to shr(t (0) + 1, 1); /* copy all of T over */         s (i) = t (i); /* word for word */      end;      return (addr(s (0))); /* return address of passed string */   end strcpy;   strncpy: proc(s, t, i, j) returns (pointer) public; /* copy N chars from string T to string S (i.e., S = substr(T, I, J);) */      dcl (s, t) fixed array; /* the strings to copy to and from */      dcl (i, j) fixed; /* indices into T (start & end of substring) */      if i ilt t (0) then do; /* make sure in range */         if j ige t (0) then j = t (0) - 1; /* force end point into range */         s (0) = j - i + 1; /* set string length */         if i /* if starting on an odd byte */         then do j = i to j; /* copy this part of T */            call pbyte(s, j - i, byte(t, j)); /* byte by byte */         end;         else do; /* even byte - copy word by word */            i = shr(i, 1); /* convert to word offset */            do j = 1 to shr(s (0) + 1, 1); /* and copy the words */               s (j) = t (j + i);            end;         end;      end; /* of in range */      else s (0) = 0; /* return null string */      return (addr(s (0))); /* return address of passed string */   end strncpy;   strcat: proc(s, t) returns (pointer) public; /* concatenate string T to the end of string S (i.e., interpret S = S || T;) */      dcl (s, t) fixed array; /* the strings to concatenate to and from */      dcl (i, j) fixed;      if s (0) then do i = 0 to t (0) - 1; /* concatenate byte by byte */         call pbyte(s, s (0) + i, byte(t, i)); /* copy the next byte */      end;      else do; /* concatenate word by word */         j = shr(s (0), 1); /* point to ending word of S */         do i = 1 to shr(t (0) + 1, 1); /* concatenate word by word */            s (j + i) = t (i); /* copy next word */         end;      end;      s (0) = s (0) + t (0); /* set new string length */      return (addr(s (0))); /* return address of passed string */   end strcat;   strncat: proc(s, t, p) returns (pointer) public; /* insert string T at position P of string S */      dcl (s, t) fixed array; /* the strings to insert to and from */      dcl p      fixed; /* position in S to insert in */      dcl (i, j) fixed;      if p ile s (0) then do; /* only do if in range */         if t (0) then do; /* must move up by bytes */            do i = s (0) - 1 to p by -1; /* move end of string up (byte by byte) */               call pbyte(s, i + t (0), byte(s, i));            end;         end;         else do; /* move up by words */            j = shr(t (0), 1); /* get word length of insertion string */            do i = shr(s (0) + 1, 1) to 1 + shr(p + 1, 1) by -1; /* move end of string up (word by word) */               s (i + j) = s (i);            end;            if p then call pbyte(s, p + t (0), byte(s, p)); /* move first byte up if odd start */         end;         if p then do; /* must copy T by bytes */            do i = p to p + t (0) - 1; /* copy T's bytes into S */               call pbyte(s, i, byte(t, i - p));            end;         end;         else do; /* copy by words */            if t (0) then call pbyte(s, p + t (0) - 1, byte(t, t (0) - 1)); /* copy last byte if odd length */            p = shr(p, 1); /* convert to word pointer */            do i = 1 + p to p + shr(t (0), 1); /* copy T's words into S */               s (i) = t (i - p);            end;         end;         s (0) = s (0) + t (0); /* set new string length */      end; /* of in range */      return (addr(s (0))); /* return address of passed string */   end strncat;   index: proc(s, t, p) returns (fixed) public; /* find position of string T in string S at or after position P */      dcl (s, t) fixed array; /* string to search, search string */      dcl p      fixed; /* index position to search from */      dcl found  boolean; /* TRUE if found match */      dcl (i, j) fixed;      found = false; /* not found yet */      if p >= 0 /* if positive index */      then do while ((p <= s (0) - t (0)) and (not found)); /* search it */         if p then do; /* if odd, must do byte by byte check */            i = 0; /* start at byte zero */            do while ((i < t (0)) and (byte(s, p + i) = byte(t, i))); /* compare each byte */               i = i + 1;            end;            if i = t (0) then found = true; /* found it */         end;         else do; /* word by word check */            i = 1; /* start at word one */            j = 1 + shr(t (0), 1); /* get ending word location */            p = shr(p, 1); /* convert P to word pointer */            do while ((i < j) and (s (p + i) = t (i))); /* compare each word */               i = i + 1;            end;            p = shl(p, 1); /* convert P back to byte pointer */            if i = j then do; /* if matched to end of line */               if t (0) then do; /* if one last character, check it */                  i = t (0) - 1; /* point to last byte */                  if byte(s, p + i) = byte(t, i) then found = true; /* matched */               end;               else found = true; /* found it */            end;         end; /* of word by word check */         if not found then p = p + 1; /* look at next position */      end; /* of searching */      if found /* if we found it */      then return (p); /* return byte position of match */      else return (-1); /* no match */   end index;   strspn: proc(s, t, p) returns (fixed) public recursive; /* find position of char from T in string S at or after position P (search) */      dcl (s, t)    fixed array; /* string to search, string with chars to find */      dcl p         fixed; /* index position to search from */      dcl char (15) fixed; /* characters to search for (bitmap) */      dcl (i, j)    fixed;      dcl bset lit 'char (shr(i, 4)) = (char (shr(i, 4)) or bit (i and "17"))'; /* set a bit (wants to be a macro) */      dcl bclr lit 'char (shr(i, 4)) = (char (shr(i, 4)) and (not bit (i and "17")))'; /* clear a bit (wants to be a macro) */      dcl btst lit '((char (shr(i, 4)) and bit (i and "17")) = 0)'; /* test if bit is clear (also a macro) */      if p ilt s (0) then do; /* make sure in range */         call blockset (char, 16, 0); /* clear all bits */         do j = 0 to t (0) - 1; /* set bitmap bits for characters we're looking for */            i = byte(t, j); bset;         end;         i = byte(s, p); /* pick up first byte of S (for macro) */         do while ((p ilt s (0)) and btst); /* search for a character match */            p = p + 1; i = byte(s, p);         end;      end; /* of in range */      if p ilt s (0) /* if we didn't run off the end */      then return (p); /* return position where found */      else return (-1); /* none of the characters appear in S */   end strspn;   strcspn: proc(s, t, p) returns (fixed) public recursive; /* find position of char not from T in string S at or after position P (verify) */      dcl (s, t)    fixed array; /* string to search, string with chars to find */      dcl p         fixed; /* index position to search from */      dcl char (15) fixed; /* characters to search for (bitmap) */      dcl (i, j)    fixed;      dcl bset lit 'char (shr(i, 4)) = (char (shr(i, 4)) or bit (i and "17"))'; /* set a bit (wants to be a macro) */      dcl bclr lit 'char (shr(i, 4)) = (char (shr(i, 4)) and (not bit (i and "17")))'; /* clear a bit (wants to be a macro) */      dcl btst lit '((char (shr(i, 4)) and bit (i and "17")) = 0)'; /* test if bit is clear (also a macro) */      if p ilt s (0) then do; /* make sure in range */         call blockset (char, 16, -1); /* set all bits */         do j = 0 to t (0) - 1; /* clear bitmap bits for characters we're not looking for */            i = byte(t, j); bclr;         end;         i = byte(s, p); /* pick up first byte of S (for macro) */         do while ((p ilt s (0)) and btst); /* search for a character match */            p = p + 1; i = byte(s, p);         end;      end; /* of in range */      if p ilt s (0) /* if we didn't run off the end */      then return (p); /* return position where found */      else return (-1); /* none of the characters appear in S */   end strcspn;   strntin: proc(s, p, q) public; /* initialize STRTOK with string S; start at P, end at Q */      dcl s      fixed array; /* string to search */      dcl (p, q) fixed; /* start position, end position */      tokptr = addr(s (0)); /* save where it is */      tokpos = p; /* start at byte P */      tokend = q; /* end at byte Q */   end strntin;   strtin: proc(s) public; /* initialize STRTOK with string S */      dcl s fixed array; /* string to search */      call strntin (s, 0, s (0)); /* use entire string */   end strtin;   strtok: proc(s, t) returns (pointer) public; /* find next token S (delimited by chars in T) from STRTOKIN string */      dcl (s, t) fixed array; /* token, delimiters */      dcl i      fixed;      i = strcspn (loc(tokptr), t, tokpos); /* search for first non-occurrence of a delimiter */      tokpos = strspn (loc(tokptr), t, i); /* and then the first delimiter after that */      if ((i <> -1) and (tokpos igt tokend)) then tokpos = tokend; /* if no delimiter at end, use rest of string (implicitly checks -1) */      return (strncpy (s, loc(tokptr), i, tokpos - 1)); /* return pointer to token */   end strtok;   compare: proc(s, t) returns (boolean) public; /* return TRUE if equal with nocase */      dcl (s, t) fixed array; /* strings to compare */      dcl (i, j) fixed;      if s (0) <> t (0) then return (false); /* lengths not equal */      i = 1; j = 1 + shr(s (0), 1); /* determine word end */      do while ((i < j) and (tolower (s (i)) = tolower (t (i)))); /* loop over words */         i = i + 1;      end;      if i < j then return (false); /* if didn't reach end of line */      if s (0) then do; /* if one last byte to check */         if byte(s, s (0) - 1) <> byte(t, s (0) - 1) then return (false);      end;      return (true); /* equal */   end compare;end strings;