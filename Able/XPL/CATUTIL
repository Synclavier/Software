/* $title Catalog Utilities *//* This module contains the following catalog utilities:.    SORT_CATALOG          - sorts contents of catalog buffer.    ERASE_CATALOG (level) - erases all files from specified catalog.    NAME (level)          - prints the name of the device specified by LEVEL.    PRINT_CATALOG (level) - prints contents of the catalog on device LEVEL*/module catalog_utilities;   configuration modelC, noMULDIV; /* don't need anything special here */   insert ':-xpl:literals'; /* get general literals */   insert ':-xpl:asciilit'; /* get ASCII literals */   insert ':-xpl:termrout'; /* and terminal library definitions */   insert ':-xpl:catrout';  /* catalog routines */   insert ':-xpl:syslits';   insert ':-xpl:devutil';  /* device utilities */   sort_catalog: proc public; /* sorts catalog buffer contents */      dcl fcb1 (f#len - 1) fixed;      dcl fcb2 (f#len - 1) fixed;      dcl (start, small)   fixed;      dcl last_fcb         fixed;      dcl (i, j, k)        fixed;      if tape (shr(c#ms_sector, 8)) /* device is tape drive? */      then start = 1; /* yes, skip over hole in first slot */      else start = 0; /* no, sort from beginning */      i = findfile ('MONITOR'); /* look for monitor */            if i <> -1 then do; /* move MONITOR to the front if there */         call get_fcb (i, fcb1); /* FCB of MONITOR */         call get_fcb (0, fcb2); /* FCB of first entry */         call put_fcb (i, fcb2); /* write first entry to MONITOR position */         call put_fcb (0, fcb1); /* write MONITOR in first position */         start = start + 1; /* start sorting from the second entry */      end;      i = 1; /* entry not found yet */      last_fcb = c#dir_size/c#len; /* start at last entry in catalog */      do while (last_fcb > start) and (i = 1); /* search for non-zero name or non-null entry */         last_fcb = last_fcb - 1; /* next FCB */         call get_fcb (last_fcb, fcb1); /* get this FCB */         i = (fcb1 (f#nm) = 0); /* I = 1 if this is a null name */      end;      if last_fcb <= start then last_fcb = -1; /* no need to sort catalog, so set flag */            do i = start to last_fcb; /* sort alphabetically using selection sort */         call get_fcb (i, fcb1); /* get first filename for this pass */         small = i; /* assume it is the smallest */         do j = i + 1 to last_fcb; /* check the rest of the names */            call get_fcb (j, fcb2);            if fcb2 (f#nm) <> 0 then do; /* don't swap free blocks down */               k = f#nm;               do while (k < f#nm + f#name_len) and (fcb1 (k) = fcb2 (k)); k = k + 1; end; /* advance until inequality found */               if k <> f#nm + f#name_len then do;                  if ((rot(fcb2 (k), 8) ilt rot(fcb1 (k), 8)) /* if FCB2 is smaller */                  or (fcb1 (f#nm) = 0)) then do; /* or our current smallest is a free block */                     small = j; /* update the smallest */                     call blockmove (fcb2, fcb1, f#len); /* save the smallest FCB as well */                  end;                end;            end; /* of skip over free blocks */         end;         call get_fcb (i, fcb2); /* swap the first with the smallest */         call put_fcb (i, fcb1);         call put_fcb (small, fcb2);      end;   end sort_catalog;   /* $subtitle Erase the Catalog on a Device & Print Device Name */   erase_catalog: proc(level) public; /* erase catalog on a device */      dcl level           fixed; /* device about to be erased */      dcl fcb (f#len - 1) fixed; /* local FCB */      dcl (i, j)          fixed;      call read_catalog ('', level); /* read in the device catalog */      do i = 0 to c#dir_size/c#len - 1; /* zero out the catalog */         call get_fcb (i, fcb); /* read in each fcb */         do j = 0 to f#len - 1; /* fill with zeros */            fcb (j) = 0;         end;         call put_fcb (i, fcb); /* write it back out */      end; /* of zero out catalog */      if tape (level) then do; /* special case for tapes */         call get_fcb (0, fcb); /* read in first entry */         fcb (f#ls) = 1; /* track zero, file one */         fcb (f#ll) = -1; /* infinite storage */         call put_fcb (0, fcb); /* write entry back out */      end; /* of tape */      else if floppy (level) then do; /* special case for floppies */         if ((level <> 1) or (((core(loc.ucat + 1) and "377") = 0) and (core(loc.ucat) = 0))) then do; /* don't do for subcatalog */            call get_fcb (0, fcb); /* read in first entry */            fcb (f#ls) = shr(c#dir_size, 8); /* starts after the catalog */            fcb (f#ml) = c#ms_length; /* and its length is the entire device (less the catalog) */            if c#ls_length ilt shr(c#dir_size, 8) then fcb (f#ml) = fcb (f#ml) - 1; /* check for borrow */            fcb (f#ll) = c#ls_length - shr(c#dir_size, 8);            call put_fcb (0, fcb); /* write entry back out */         end; /* of not for subcatalog */      end; /* of floppy */      call write_catalog; /* write the result to the device */         end erase_catalog;      name: proc(level) public; /* print name of specified device */      dcl level fixed;      do case (level + 2); /* output what it's called */         do; /* path catalog */            pstring ('PC');            if (((core(loc.pcat + 1) and "377") = 0) and (core(loc.pcat) = 0))  /* if entire device */            then level = shr(core(loc.pcat + 1), 8); /* map to actual device */         end;         do; /* alternate catalog */            pstring ('AC');            if (((a#ms_sector and "377") = 0) and (a#ls_sector = 0))  /* if entire device */            then level = shr(a#ms_sector, 8); /* map to actual device */         end;         do; /* system catalog */            pstring ('SC');            level = shr(core(loc.scat + 1), 8); /* convert to actual level number */         end;         do; /* current catalog */            pstring ('CC');            if (((core(loc.ucat + 1) and "377") = 0) and (core(loc.ucat) = 0))  /* if entire device */            then level = shr(core(loc.ucat + 1), 8); /* map to actual device */         end;         pstring ('F0');         pstring ('F1');         pstring ('R0');         pstring ('R1');         pstring ('W0');         pstring ('W1');         pstring ('T0');         pstring ('T1');         pstring ('O0');         pstring ('O1');      end;      pstring (' (');      if level < 2 then do; /* subcatalogs (except SC) */         pstring ('Catalog ');         do case (level + 2); /* output name of catalog */            pstring (location(loc.pcnm)); /* PC */            pstring (a#name); /* AC */            ; /* SC - can't happen */            pstring (location(loc.ccnm)); /* CC */         end;      end; /* of subcatalogs */      else do case (level - 2); /* output device names */         pstring ('Leftmost floppy');         pstring ('Rightmost floppy');         pstring ('Remote floppy');         pstring ('Remote floppy');         pstring ('Winchester disk');         pstring ('Winchester disk');         pstring ('Tape drive');         pstring ('Tape drive');         pstring ('Optical disk');         pstring ('Optical disk');      end;      pstring (')');   end name;   /* $subtitle Print Catalog Contents */   print_catalog: proc(level) public; /* print the catalog for given level */      dcl level            fixed;      dcl fcb (f#len - 1)  fixed;      dcl str (f#name_len) fixed;      dcl count            fixed;      dcl (i, j)           fixed;      pause: proc; /* pause for input */         pos (23, 0);         pstring ('Press RETURN to continue ->');         clear_typeahead; call rchar;         clear_screen;      end pause;      print.header: proc(first); /* print out the screen header */         dcl first boolean; /* TRUE if this is the first screen */         if first then pstring ('C'); else pstring ('Further c');         pstring ('ontents of '); call name (level); crlf; crlf;         pstringr ('--Name--  Type   Sectors  Wds/Seconds    --Name--  Type   Sectors  Wds/Seconds');      end;      call read_catalog ('', level); /* read in the catalog */      call print.header (true);      count = 0;      str (0) = shl(f#name_len, 1); /* set up length */      /* $page */      /* print each catalog entry */      do i = 0 to c#dir_size/c#len - 1; /* loop over FCB entries */         call get_fcb (i, fcb);         if fcb (0) <> 0 then do; /* something to print */            if ((count <> 0) and ((count mod 38) = 0)) then call print.header (false);            do j = 0 to f#name_len - 1; str (j + 1) = fcb (f#nm + j); end; /* copy name */            do j = 0 to shl(f#name_len, 1) - 1; if byte(str, j) < a.space then call pbyte(str, j, a.space); end; /* space fill */            pstring (str); pstring ('  ');            if fcb (f#ty) <= t#max then do case (fcb (f#ty)); /* print file type */               pstring ('Text ');               pstring ('Exec ');               pstring ('Reloc');               pstring ('Data ');               pstring ('Sync ');               pstring ('Sound');               pstring ('Subc ');               pstring ('LSubc');               pstring ('Dump ');               pstring ('Spect');               pstring ('Index');               pstring ('Timb ');            end; /* of do case */            else do; pstring('Typ'); pnum(fcb (f#ty), 2); end; /* all other types */            lnum (fcb (f#ml), fcb (f#ll), 9); /* output sectors */            if ((fcb (f#ty) = t#sound) and d4567_present) then do; /* sound file? (length limited to 32 MB)*/               write(5) = fcb (f#ll); /* multiply LSB number of sectors */               write(6) = 256; /* by words/sector */               j = read(5); /* to get 32-bit words */               write(7) = 500; /* and divide that by 500 (assume 50KHz sampling) */               j = read(5); /* to get seconds times 100 */               if read(4) ige 250 then j = j + 1; /* round up */               unum(shr(j, 1)/50, 5); wchar(a.period); /* shr(j, 1)/50 is really the unsigned division j/100 */               if j < 0 then j = j - 32800; /* make J positive (but don't change the 10's or 1's place!) */               if j < 0 then j = j + 100; /* if we overshot, come back - this is the fractional part */               else j = (j mod 100); /* get fractional part (unsigned!) */               if j < 10 then wchar(a.0); unum(j, 0); /* print fractional part */               pstring(' secs');            end;            else if ((fcb (f#ml) = 0) and (fcb (f#ll) ilt 256)) then do; /* else print words */               unum(fcb (f#wd), 8); pstring(' wds '); /* print words */            end;            else pstring('             '); /* else print nothing */            count = count + 1;            if (count mod 2) = 0 then crlf; else pstring('    '); /* go to new line */            if (count mod 38) = 0 then call pause; /* pause every 38 entries */         end; /* something to print */      end; /* for all blocks */      if count = 0 then do; crlf; pstringr ('*** No files are saved.'); end;      if ((count = 0) or ((count mod 38) <> 0)) then call pause;   end print_catalog;end catalog_utilities;