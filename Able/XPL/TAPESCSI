/* $title SCSI Tape Library *//* This library of routines allows access to any type of SCSI   sequential access device. There are two public variables which   calling routines may access to obtain status information:     Tape_Status     - A word containing the status of the last tape                       operation. The contents of this word are described                       above the Read_Status procedure.     Tape_Sense()    - A fixed array containing the Extended Sense bytes                       returned by the SCSI Request Sense command.   In addition, there are two arrays that are used by these routines   but are not public. These are:     DevAdr()        - A fixed array of SCSI device address words. Each word                       contains the D24 number, SCSI Target ID and LUN of                       the given device, looked up from configuration. If a                       device has not been loaded, its word in DevAdr will                       be set to -1 (Unloaded).     DevStat()       - A fixed array containing the status of the last                       operation completed on each device. */module Tape_IO;configuration modelC,noMULDIV;          /* Use model B or later */insert ':-xpl:literals';insert ':-xpl:syslits';insert ':-xpl:tapelits';insert ':-xpl:scsirout';/* Local Literals */dcl Save_Mask        lit '"HF300"';     /* AND with this to clear all bits except track, write protect, and LLP bits */dcl Unloaded         lit '-1';          /* Value in DEVADR() if device is not loaded *//* Public Variables */dcl Tape_Operation   fixed public;      /* Global tape operation variable */dcl Tape_Status      fixed public;      /* Global tape status variable */dcl Tape_Sense(shr(SenseMax + 1,1)) fixed public; /* Global array to hold Extended Sense bytes */dcl Dev8Type fixed public; Dev8Type = 3; /* Tape device number *//* Local Variables */dcl Reselected  boolean;                /* TRUE when D24 reselection interrupt has occurred */dcl DevStat(1)  fixed;                  /* Table of device status's */dcl DevAdr(1)   fixed;                  /* Table of device addresses */DevAdr(0) = Unloaded;                   /* Devices are initially unloaded */DevAdr(1) = Unloaded;when D24Int then begin;   do while ( (read(ScsiBus) and S$SEL) <> 0 ); end; /* Wait until target releases SEL */   write(ScsiBus) = 0; /* release BSY */   Reselected = true;end;/* $subtitle Check device and SCSI command set up *//* This procedure checks the given device to make sure it is a proper   tape device. If the system or current device numbers are passed (0 or 1),   it looks up the device type to make sure it is a tape drive, and   then converts to the appropriate tape device number (8 or 9). This   number is returned by the procedure */CheckDevice: procedure(Device) returns (fixed);   dcl Device fixed;                    /* Device number to check */   dcl i      fixed;   if (Device = 0) or (Device = 1) then do; /* System or current device? */      i = Find_Device(Device);             /* Look up device definition in configuration */      if (core(i + s#devtyp) and "H30F") = "H103" /* Is this device a SCSI tape drive? */      then Device = 8 + (shr(core(i + s#devtyp),4) and "HF"); /* Yes, so map to device 8 or 9, depending on logical drive number */   end;   if (Device = 8) or (Device = 9)      /* Is this a tape device? */   then return(Device);                 /* Yes, so return it */   else return(S$BadDevice);            /* No, so return bad device status */end CheckDevice;/*This procedure is used to set up the given device for a SCSI command.It first checks for a valid device number (8 or 9), and then makes surethe tape is loaded. If all goes well it connects to the SCSI bus usingthe SCSI device parameters found in the array DEVADR. It also sets theglobal variable TAPEOPERATION to the given SCSI command. It returns theSCSI device address of this device. */SetupCmd: procedure(Device,Cmd,Disconnect) returns (fixed);   dcl Device     fixed;                   /* Device number to use */   dcl Cmd        fixed;                   /* SCSI command to be used */   dcl DAdr       fixed;                   /* SCSI device address */   dcl Disconnect fixed;                   /* TRUE to enable Disconnect/Reconnect */   dcl i      fixed;   Tape_Operation = Cmd;                   /* Set global variable to the given command */   DAdr = Unloaded;                        /* Device assumed to be unloaded */   Device = CheckDevice(Device);           /* Make sure this is a valid tape device */   if Device = S$BadDevice                 /* Is this device invalid? */   then Tape_Status = abs(S$BadDevice) + 15; /* Yes, so set global status variable */   else do;                                /* No, so continue */      DAdr = DevAdr(Device - 8);           /* Look up the SCSI device address */      if DAdr = Unloaded                   /* Is this device currently unloaded? */      then Tape_Status = abs(S$NotLoaded) + 15; /* Yes, so return NOT LOADED error */      else do;                             /* Device is loaded, so connect to SCSI bus */                  if Disconnect then Disconnect = "H40"; /* Allow disconnect */         i = S$DeviceBusy;                 /* Call connect until error conditions go away */         do while (i = S$DeviceBusy) or (i = S$ArbFailed) or (i = S$BadBusState);            i = ScsiConnect(shr(DAdr,4) and "HF", S.Initiator, DAdr and "HF", Disconnect or (shr(DAdr,8) and "HF"));            if i = S$BadBusState then call ScsiAbort;  /* Clear bus if out of whack */         end;         if i = S$GoodConnect              /* Was a good connection made? */         then DevStat(Device - 8) = (DevStat(Device - 8) and Save_Mask) or S$NoSense;  /* Yes, so no error occurred */         else if i < 0                     /* Otherwise an error occurred during connection */         then DevStat(Device - 8) = (DevStat(Device - 8) and Save_Mask) or (abs(i) + 15);  /* Return connect error code */         Tape_Status = DevStat(Device - 8); /* Set global status variable */      end;                                 /* of connection to bus */   end;                                    /* of valid tape device */   return(DAdr);                           /* Return device address */end SetupCmd;/* $subtitle Get Extended Sense Information *//* This procedure issues the Request Sense command to the   controller to get the Extended Sense bytes. The sense bytes   are stored in the global array Tape_Sense. */Read_Sense: procedure(Device);   dcl Device  fixed;                       /* Device number */   dcl TapeAdr fixed;                       /* Device address */   TapeAdr = SetupCmd(Device,S$RequestSense,false);  /* Setup for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* If no error occurred during command setup */      write(ScsiByte) = S$RequestSense;       /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */      write(ScsiWord) = 0;                    /* Reserved */      write(ScsiByte) = SenseMax;             /* Maximum no. sense bytes that can be accomidated */      write(ScsiByte) = 0;                    /* Control */      do while ( (read(ScsiBus) and S$REQ) = 0 ); end; /* Wait for Target assert REQ */      Tape_Sense(0) = 0;                      /* Start with nothing */      do while ( (read(ScsiBus) and S$SigMask) = S$DataIn ); /* Repeat until phase changes */         call pbyte(Tape_Sense,Tape_Sense(0),read(ScsiByte)); /* Store sense byte in array */         Tape_Sense(0) = Tape_Sense(0) + 1;   /* One more byte */          do while ( (read(ScsiBus) and S$REQ) = 0 ); end; /* Wait for Target assert REQ */      end;      TapeAdr = read(ScsiWord);               /* Get status word - ignore it */   end;end Read_Sense;/* $subtitle Read Tape Status *//* This procedure calls the Read_Sense procedure and constructs   the global variable Tape_Status, as follows:     15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0   +---------------+---+---+---+---+-------------------------------+   | Current Track |FIL|EOM|LLP| WP|           Sense Key           |   +---------------+---+---+---+---+-------------------------------+Where: Bits 0-7       Sense Key                - Contains the Sense Key from the last command.                  The Sense Key may have the following values:                    0       No error occurred.                    1-15    Error returned by Extended Sense command.                    > 15    Error returned by SCSICONNECT. Subtract                            15 and negate to get errors in SCSILITS. Bit 8          Write Protect                - Set if tape is write protected. Bit 9          Logical Load Point                - Set if logical load point reached on tape. Bit 10         End of Medium                - Set if the end of the tape is encountered. Bit 11         File Mark                - Set if a file mark is read. Bits 12-15     Current Track                - Contains the track number of the currently                  selected track on the tape drive.*/Read_Status: procedure(Device);   dcl Device  fixed;                      /* Device to get status from */   dcl i fixed;   i = read(ScsiWord);                     /* Get status from command */   if shr(i and S$StatMask,8) = S$CheckCondition then do; /* If check condition status returned */      call Read_Sense(Device);             /* Get Extended Sense bytes */      if (Tape_Status and Status_Mask) = S$NoSense /* Did command complete succesfully? */      then i = byte(Tape_Sense,2);         /* Yes, so sense byte 2 has Sense Key and other information */      else i = (Tape_Status and Status_Mask); /* No, so Tape_Status contains error */   end;   else i = S$NoSense;                     /* Otherwise no error occurred */   Device = CheckDevice(Device);           /* Map to a proper tape device (8 or 9) */   if Device = S$BadDevice                 /* Is this a device invalid? */   then Tape_Status = abs(S$BadDevice) + 15; /* Yes, so set global status variable */   else do;                                /* No, so construct the status word for this device */      DevStat(Device - 8) = (DevStat(Device - 8) and Save_Mask) or shl(i and "HC0",4) or (i and "HF"); /* Construct status word for this device */      Tape_Status = DevStat(Device - 8);   /* Set global status variable */   end;end Read_Status;/* $subtitle Decode Status *//* This procedure decodes the status word constructed above in Read_Status   into a word which defines logical errors which are easily handled   by a do case statement. The format of this word is:      Bits 0-7     Decoded status byte      Bits 8-15    Position status byte from drive */S#Decode_Status: procedure returns (fixed) public;   dcl Status   fixed;                     /* Decoded status */   dcl StatByte fixed;                     /* Status byte extracted from Tape_Status */   StatByte = (Tape_Status and Status_Mask); /* Get status byte */   if (StatByte = S$NoSense) or (StatByte = S$RecoveredError) /* No error has occurred */   then Status = S#No_Error;   else if StatByte = S$NotReady           /* Drive not ready */   then Status = S#Not_Ready;   else if (StatByte = (abs(S$NotLoaded) + 15)) or (StatByte = S$UnitAttention) /* Drive not loaded */   then Status = S#Not_Loaded;   else if StatByte = S$MediumError        /* Unrecoverable media error */   then Status = S#Data_Error;   else if StatByte = S$HardwareError      /* Serious hardware failure */   then Status = S#Drive_Fault;   else if StatByte = S$BlankCheck         /* Blank tape encountered */   then Status = S#No_Data;   else if StatByte = S$DataProtect        /* Device is write protected */   then Status = S#Write_Protected;   else if StatByte = (abs(S$BadDevice) + 15) /* Not device 8 or 9 */   then Status = S#Bad_Device;   else if StatByte = (abs(S$SelFailed) + 15) /* Device could not be selected */   then Status = S#Select_Failed;   else if StatByte = (abs(S$D24NotThere) + 15) /* D24 board not present on system */   then Status = S#D24_Missing;   else if StatByte = (abs(S$BadInitiator) + 15) /* Not SCSI Initiators 6 or 7 */   then Status = S#Bad_Initiator;   else if StatByte = S$IllegalRequest     /* Illegal parameter in SCSI command */   then Status = S#Illegal_Request;   else Status = S#Unknown;                /* Otherwise an unknown error has occurred */   return( Status or (Tape_Status and Position_Mask) ); /* Return full decoded status */end S#Decode_Status;/* $subtitle Load and Unload the Tape *//* This procedure loads the tape drive */S#Load: procedure(Device) public;   dcl Device  fixed;                      /* Device number */   dcl TapeAdr fixed;                      /* Tape device address */   dcl LogTape fixed;                      /* Logical tape number */   dcl i       fixed;   Tape_Operation = -1;                    /* No tape operation yet */   Device = CheckDevice(Device);           /* Make sure this is a valid tape device */   if Device = S$BadDevice then do;        /* Is this a valid device? */      Tape_Status = abs(S$BadDevice) + 15; /* No, so return bad device status */      return;   end;   LogTape = Device - 8;                   /* Subtract 8 to get logical tape number */   DevStat(LogTape) = 0;                   /* This device currently has no status information yet */   i = Find_Device(Device);                /* Find configuration block for this device */   if i = 0 then do;                       /* Is device configured? */      Tape_Status = abs(S$BadDevice) + 15; /* No, so return bad device status */      return;   end;   else if (shr(core(i + s#devtyp),8) and "3") <> 1 then do; /* Is this a SCSI tape drive? */      Tape_Status = abs(S$BadDevice) + 15; /* No, so return bad device status */      return;   end;   DevAdr(LogTape) = core(i + s#devadr);   /* Get SCSI device address for this device from configuration */   TapeAdr = SetupCmd(Device,S$TestUnitReady,false); /* Set up for command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if connection failed */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   /* Issue Test Unit Ready command */   write(ScsiByte) = S$TestUnitReady;      /* Operation Code */   write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 0;                    /* Reserved */   write(ScsiByte) = 0;                    /* Control */   call Read_Status(Device);               /* Get status of this command */   i = Tape_Status and Status_Mask;        /* Get Sense Key */   if (i <> S$NoSense) and (i <> S$UnitAttention) then do; /* Return if something other than Unit Attention occurs */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   TapeAdr = SetupCmd(Device,S$LoadUnload,false); /* Set up for command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if connection failed */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   /* Issue Load command */   write(ScsiByte) = S$LoadUnload;         /* Operation Code */   write(ScsiByte) = shr(TapeAdr and "HF00", 8 - 5) or 1; /* Target LUN, Immediate bit set */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 1;                    /* Load bit set - causes load */   write(ScsiByte) = 0;                    /* Control */   call Read_Status(Device);               /* Get status of this command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if bad status encountered */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;   end;   TapeAdr = SetupCmd(Device,S$ModeSense,false); /* Set up for command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if connection failed */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   /* Issue Mode Sense command */   write(ScsiByte) = S$ModeSense;          /* Operation Code */   write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 4;                    /* Allocation Length */   write(ScsiByte) = 0;                    /* Control */   i = read(ScsiWord);                     /* Throw away first word */   i = read(ScsiWord) and "H8000";         /* MS bit gives write protect status */   DevStat(LogTape) = DevStat(LogTape) or shr(i,7); /* Put write protect bit into device status word */   call Read_Status(Device);               /* Get status of this command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if bad status encountered */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   TapeAdr = SetupCmd(Device,S$ModeSelect,false); /* Set up for command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if connection failed */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */      return;                              /* Return */   end;   /* Issue Mode Select command */   write(ScsiByte) = S$ModeSelect;         /* Operation Code */   write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 12;                   /* Allocation Length */   write(ScsiByte) = 0;                    /* Control */   /* Parameter List */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = shl(TapeBuffer,4) or TapeSpeed; /* Set buffer and speed */   write(ScsiByte) = 8;                    /* Block descriptor length */   /* Block Descriptor List */   write(ScsiByte) = TapeDensity;          /* Set tape density */   write(ScsiWord) = 0;                    /* No. Blocks */   write(ScsiWord) = 0;                    /* Reserved */   write(ScsiByte) = 0;                    /* MSB of block size */   write(ScsiWord) = TapeBlock;            /* Set tape block size */   call Read_Status(Device);               /* Get status of this command */   if (Tape_Status and Status_Mask) <> S$NoSense then do; /* Return if bad status encountered */      DevAdr(LogTape) = Unloaded;          /* Device is not loaded yet */   end;end S#Load;/* This procedure unloads the tape from the tape drive. */S#Unload: procedure(Device) public;   dcl Device fixed;                       /* Device number */   dcl TapeAdr fixed;                      /* Device address */   TapeAdr = SetupCmd(Device,S$LoadUnload,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$LoadUnload;      /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 1; /* Target LUN, Immediate bit set */      write(ScsiWord) = 0;                 /* Reserved */      write(ScsiByte) = 0;                 /* Load bit not set - causes unload */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */      if (Tape_Status and Status_Mask) = S$NoSense then do; /* Good status received after command */         Device = CheckDevice(Device);     /* Map to device 8 or 9 */         DevAdr(Device - 8) = Unloaded;    /* This device is now unloaded */         DevStat(Device - 8) = 0;          /* This device now has no status */         Tape_Status = 0;                  /* Global status variable is also cleared */      end;   end;end S#Unload;/* $subtitle Rewind the Tape and Select a Track *//* This procedure rewinds the tape to BOT */S#Rewind: procedure(Device)  public;   dcl Device fixed;                       /* Device number */   dcl TapeAdr fixed;                      /* Device address */   TapeAdr = SetupCmd(Device,S$Rewind,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command setup */      write(ScsiByte) = S$Rewind;          /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 0; /* Target LUN, Immediate bit not set */      write(ScsiWord) = 0;                 /* Reserved */      write(ScsiByte) = 0;                 /* Reserved */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Rewind;/* This procedure selects a track on the tape */S#Select: procedure(Device,track) public;   dcl Device  fixed;                      /* Device number */   dcl Track   fixed;                      /* Track to select */   dcl TapeAdr fixed;                      /* Device address */   TapeAdr = SetupCmd(Device,S$TrackSelect,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$TrackSelect;     /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */      write(ScsiWord) = 0;                 /* Reserved */      write(ScsiByte) = Track;             /* Track value */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Select;/* $subtitle Space Over Blocks *//* This procedure spaces forward the given number of blocks */S#Forward_Space: procedure(Device,MSW,LSW) public;   dcl Device    fixed;                    /* Device number */   dcl (MSW,LSW) fixed;                    /* No. blocks to space forward */   dcl TapeAdr   fixed;                    /* Device address */   TapeAdr = SetupCmd(Device,S$Space,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$Space;           /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 0; /* Target LUN, space by block */      write(ScsiByte) = MSW;               /* Spacing count (MSW) */      write(ScsiWord) = LSW;               /* Spacing count (LSW) */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Forward_Space;/* This procedure spaces backwards the given number of blocks */S#Reverse_Space: procedure(Device,MSW,LSW) public;   dcl Device    fixed;                    /* Device number */   dcl (MSW,LSW) fixed;                    /* No. blocks to space backwards */   dcl TapeAdr   fixed;                    /* Device address */   MSW = -MSW;                             /* Make the no. blocks negative, so reverse space happens */   if LSW <> 0 then MSW = MSW - 1;   LSW = -LSW;   TapeAdr = SetupCmd(Device,S$Space,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$Space;           /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 0; /* Target LUN, space by block */      write(ScsiByte) = MSW;               /* Spacing count (MSW) */      write(ScsiWord) = LSW;               /* Spacing count (LSW) */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Reverse_Space;/* $subtitle Space Over Filemarks *//* This procedure spaces forward the given number of filemarks */S#Forward_File: procedure(Device,MSW,LSW) public;   dcl Device    fixed;                    /* Device number */   dcl (MSW,LSW) fixed;                    /* No. filemarks to space forward */   dcl TapeAdr   fixed;                    /* Device address */   TapeAdr = SetupCmd(Device,S$Space,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$Space;           /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 1; /* Target LUN, space by filemarks */      write(ScsiByte) = MSW;               /* Spacing count (MSW) */      write(ScsiWord) = LSW;               /* Spacing count (LSW) */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Forward_File;/* This procedure spaces backwards the given number of filemarks */S#Reverse_File: procedure(Device,MSW,LSW) public;   dcl Device    fixed;                    /* Device number */   dcl (MSW,LSW) fixed;                    /* No. filemarks to space backwards */   dcl TapeAdr   fixed;                    /* Device address */   MSW = -MSW;                             /* Make the no. filemarks negative, so reverse space happens */   if LSW <> 0 then MSW = MSW - 1;   LSW = -LSW;   TapeAdr = SetupCmd(Device,S$Space,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$Space;           /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or 1; /* Target LUN, space by filemarks */      write(ScsiByte) = MSW;               /* Spacing count (MSW) */      write(ScsiWord) = LSW;               /* Spacing count (LSW) */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Reverse_File;/* $subtitle Erase Tape and Write Filemarks *//* This procedure erases the tape from the current position. The   variable EOT determines whether the entire tape is erased or   only a short gap is erased. */S#Erase: procedure(Device,EOT) public;   dcl Device    fixed;                    /* Device number */   dcl EOT       boolean;                  /* True to erase remaining tape, false to erase a short gap */   dcl TapeAdr   fixed;                    /* Device address */   TapeAdr = SetupCmd(Device,S$Erase,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$Erase;           /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5) or EOT; /* Target LUN and Long bit */      write(ScsiWord) = 0;                 /* Reserved */      write(ScsiByte) = 0;                 /* Reserved */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Erase;/* This procedure writes a file mark at the current tape position. The   variable EXTENDED determines whether a gap is erased before the file   mark is written. */S#Write_Filemark: procedure(Device,Extended) public;   dcl Device   fixed;                     /* Device number */   dcl Extended boolean;                   /* True if a gap should be erased before filemark */   dcl TapeAdr  fixed;                     /* Device address */   if Extended then do;                    /* This is an extended file mark */      call S#Erase(Device,false);          /* Erase short gap on tape */      if (Tape_Status and Status_Mask) <> S$NoSense then return; /* Return if error occurred */   end;   TapeAdr = SetupCmd(Device,S$WriteFileMarks,false); /* Set up for command */   if (Tape_Status and Status_Mask) = S$NoSense then do; /* No error occurred during command set up */      write(ScsiByte) = S$WriteFileMarks;  /* Operation Code */      write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* Target LUN */      write(ScsiByte) = 0;                 /* No. File Marks (MSW) */      write(ScsiWord) = 1;                 /* No. File Marks (LSW) */      write(ScsiByte) = 0;                 /* Control */      call Read_Status(Device);            /* Get status of this command */   end;end S#Write_Filemark;/* $subtitle Read and Write Blocks *//* This procedure reads the given number of words from the tape */S#Read_Tape: procedure(Device,Buffer,Length) public;   dcl Device    fixed;                    /* Device number */   dcl Buffer    fixed array;              /* Buffer for data */   dcl Length    fixed;                    /* No. of words to read */   call ScsiIO(shl(Device,8),0,addr(Buffer(0)),Length,0,0,S$Read);   return (Length);end S#Read_Tape;/* This procedure writes the given number of words to the tape */S#Write_Tape: procedure(Device,Buffer,Length) public;   dcl Device    fixed;                    /* Device number */   dcl Buffer    fixed array;              /* Buffer with data */   dcl Length    fixed;                    /* No. of words to write */   call ScsiIO(shl(Device,8),0,addr(Buffer(0)),Length,0,0,S$Write);   return (Length);end S#Write_Tape;/* $subtitle SCSI Copy *//* This procedure copies blocks from disk to tape or vice-versa. TAPEDEVICE   and DISKDEVICE specify the devices to use for the copy. LOGSEC is the   sector on the disk to start the copy from, and LOGLEN is the number   of disk sectors to copy. RESTORE controls the direction of the transfer. */S#Copy: procedure(TapeDevice,DiskDevice,LogSecMSW,LogSecLSW,LogLenMSW,LogLenLSW,Restore) returns(boolean) public;   dcl TapeDevice  fixed;                  /* Device number of tape drive */   dcl DiskDevice  fixed;                  /* Device number of disk drive */   dcl (LogSecMSW,LogSecLSW) fixed;        /* Logical starting sector number on disk */   dcl (LogLenMSW,LogLenLSW) fixed;        /* Logical no. disk blocks to transfer */   dcl Restore     boolean;                /* TRUE to copy tape to disk, FALSE to copy disk to tape */   dcl TapeAdr     fixed;                  /* Device address of tape drive */   dcl DiskAdr     fixed;                  /* Device address of disk drive */   dcl (PhyLenMSW,PhyLenLSW) fixed;        /* Physical no. disk blocks to transfer */   dcl err         boolean;                /* TRUE if an error occurred during the copy loop */   dcl IntState    fixed;                  /* Used for saving interrupt state */   dcl i           fixed;   err = false;                         /* No error yet */   do while ( (LogLenMSW <> 0) or (LogLenLSW <> 0) ) and (not err); /* Repeat until all logical blocks have been transferred */      i = MapSector(LogSecMSW,LogSecLSW,DiskDevice); /* Map logical sector to a physical sector on a device */      if i = 0 then do;                 /* This logical sector maps to no physical drive */         Tape_Status = abs(S$BadDevice) + 15; /* Return bad device status */         err = true;                    /* Signal error condition */      end;      else if (shr(core(i + s#devtyp),8) and "3") <> 1 then do; /* This is not a SCSI winchester */         Tape_Status = abs(S$BadDevice) + 15; /* Return bad device status */         err = true;                    /* Signal error condition */      end;      else do;                          /* Good disk device, so start copy */         /* See if there are enough sectors remaining on this disk for all the logical sectors */         if ( (RemSecMSW ilt LogLenMSW) or ( (RemSecMSW = LogLenMSW) and (RemSecLSW ilt LogLenLSW) ) ) then do;            PhyLenMSW = RemSecMSW;      /* Remaining < total, so only write remaining sectors */            PhyLenLSW = RemSecLSW;         end;         else do;            PhyLenMSW = LogLenMSW;      /* Remaining >= total, so write all logical sectors */            PhyLenLSW = LogLenLSW;         end;         DiskAdr = core(i + s#devadr);  /* Get SCSI device address of disk */         TapeAdr = SetupCmd(TapeDevice,S$Copy,true); /* Get SCSI device address of tape and set up for a disconnectable command */         if (Tape_Status and Status_Mask) <> S$NoSense /* Did an error occur connecting to the tape device? */         then err = true;               /* Yes, so signal error condition */         else do;                       /* No, so tape is ready to receive the Copy command */            /* Send Copy command */            write(ScsiByte) = S$Copy;            /* Operation code */            write(ScsiByte) = shr(TapeAdr and "HF00",8 - 5); /* LUN of tape drive */            write(ScsiByte) = 0;                 /* MSW of transfer length */            write(ScsiWord) = 16;                /* LSW of transfer length */            write(ScsiByte) = 0;                 /* Control byte */            /* Parameter list */            write(ScsiByte) = shl(Restore,3);    /* Copy function code */            write(ScsiByte) = 0;                 /* Vendor unique code */            write(ScsiWord) = 0;                 /* Reserved */            /* Segment Descriptor */            if Restore then do;                  /* Copy tape to disk */               write(ScsiByte) = shl(TapeAdr and "HF",5) or (shr(TapeAdr,8) and "HF"); /* Source SCSI ID and LUN */               write(ScsiByte) = shl(DiskAdr and "HF",5) or (shr(DiskAdr,8) and "HF"); /* Destination SCSI ID and LUN */            end;            else do;                             /* Copy disk to tape */               write(ScsiByte) = shl(DiskAdr and "HF",5) or (shr(DiskAdr,8) and "HF"); /* Source SCSI ID and LUN */               write(ScsiByte) = shl(TapeAdr and "HF",5) or (shr(TapeAdr,8) and "HF"); /* Destination SCSI ID and LUN */            end;            write(ScsiWord) = TapeBlock;         /* Tape block size */            write(ScsiWord) = PhyLenMSW;            write(ScsiWord) = PhyLenLSW;         /* No. blocks to copy on this disk */            write(ScsiWord) = PhySecMSW;            write(ScsiWord) = PhySecLSW;         /* Starting block on this disk */            do while (read(ScsiBus) and S$REQ) = 0; end; /* Wait for REQ asserted */            if (read(ScsiBus) and S$SigMask) = S$MessIn then do; /* Message In phase appeared, so let device disconnect */               Reselected = false;                  /* Not reselected yet */               write(ScsiBus) = shl(2,S$IntShift);  /* Enable D24 reselection interrupts for ID 7 */               i = read(ScsiWord);                  /* Get disconnect message */               if i = "H0204" then do;              /* Is this a good disconnect message? */                  IntState = read(R14);             /* Yes, so save interrupt state */                  enable;                           /* Enable interrupts */                  do while not Reselected; end;     /* Wait for D24 reselection interrupt */                  write(PCW) = IntState;            /* Restore interrupt state */                  write(R14) = IntState;                  i = read(ScsiByte);               /* Get identify message */                  call Read_Status(TapeDevice);     /* Get status */                  if (Tape_Status and Status_Mask) = S$NoSense then do; /* Good status received */                     LogSecMSW = LogSecMSW + PhyLenMSW; /* Add no. blocks just transferred to logical starting sector */                     LogSecLSW = LogSecLSW + PhyLenLSW;                     if LogSecLSW ilt PhyLenLSW then LogSecMSW = LogSecMSW + 1;                     LogLenMSW = LogLenMSW - PhyLenMSW; /* Subtract no. blocks just transferred from total no. logical blocks */                     if LogLenLSW ilt PhyLenLSW then LogLenMSW = LogLenMSW - 1;                     LogLenLSW = LogLenLSW - PhyLenLSW;                  end;                  else if (Tape_Status and Status_Mask) = S$CopyAborted then do; /* Copy aborted - find out what happened */                     IntState = CheckDevice(TapeDevice) - 8;   /* Map to device 8 or 9 */                     i = byte(Tape_Sense,13);         /* Get Copy Sense byte */                     DevStat(IntState) = (DevStat(IntState) and Save_Mask) or shl(i and "HC0",4) or (i and "HF");                     Tape_Status = DevStat(IntState); /* Set global tape status variable */                     if (Tape_Status and Status_Mask) <> S$UnitAttention /* Did some error besides Unit Attention cause the abort? */                     then err = true;                  end;                  else err = true;                  /* Some other error occurred */               end;               else do;                             /* Bad disconnect message */                  write(ScsiBus) = 0;               /* Disable reselect interrupt */                  Tape_Status = S$CopyAborted;      /* Return Copy Aborted status */                  err = true;                       /* Signal error condition */               end;            end;                                    /* of disconnect */            else do;                                /* Status Phase appeared */               call Read_Status(TapeDevice);        /* Get status from the tape */               if (Tape_Status and Status_Mask) <> S$UnitAttention /* Did some error other than unit attention occur? */               then err = true;                     /* Signal error condition */            end;         end;                                       /* of good tape device */      end;                                          /* of good disk device */   end;                                             /* of while not all logical blocks transferred */   return(not err);                                 /* Return TRUE if no error occurred */end S#Copy;end Tape_IO;