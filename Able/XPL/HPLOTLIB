/* $D HPLOTLIB  $TITLE  Plotting Procedures *//* Copyright (c) 1982 by New England Digital Corporation *//* Copyright (c) 1983 by New England Digital Corporation *//* Copyright (c) 1984 by New England Digital Corporation *//* fix to boundary clipping    21 November  1983.  added DQ640 code            11 April     1984  [KJC].  added high-res output       17 April     1984  [KJC].  added BUFPORT               14 September 1984  [KJC].  modified to use ext mem     19 September 1984  [JSR].  modified for ext or int mem  1 October   1984  [KJC].  added MG600 code             8 August    1985  [KJC]*//* This module contains all the routines for plotting on.  a Retrographics VT640 plotter. ..  To access this module, INSERT ':-XPL:PLOTLIB';.  In addition,.  insert :-XPL:TERMUTIL (if you want interrupts enabled) or.  :-XPL:TERMUT (if you want interrupts disabled). */module PLOTTING_LIBRARY;configuration modelC, MULDIV; /* HARDCOPY won't work on modelA; #TRANSMIT_COORDS & #SHOWPIXEL won't work without the MULDIV */insert ':-xpl:asciidef';insert ':-xpl:syslits'; /* terminal definitions */insert ':-xpl:termrout'; /* get TERMUTIL procedure definitions *//* GLOBAL VARIABLE DECLARATIONS */dcl #mode              fixed public; /* 0=transparent,1=alpha,2=vector, 3=point */dcl #initialize        fixed public; /* flag to mark first point in point or vector sequence */dcl #phys.limits       data (0,1023,0,779); /* physical device limits (same as TEK10) */dcl (#lastx,#lasty)    fixed; /* coordinates of last point */dcl #data.level        fixed; /* 0 for white, 1 for black, 2 for complemented  */dcl #line.type         fixed; /* save line type */dcl #char.size         fixed; /* save character size */dcl #window.limits (3) floating; /* problem coords for floating pt conversions */dcl #iwindow.limits(3) fixed; /* user units */ dcl #view.limits   (3) fixed; /* plotter units of viewport */dcl #buf.limits    (3) fixed; /* where the buffer lies on the viewport */dcl (#xnum,#ynum)      fixed; /* numerator to scale point */dcl (#xden,#yden)      fixed; /* denominator to scale point */dcl (#px,#py)          fixed; /* user's plot units */dcl (#bwidth,#bheight) fixed; /* width and height of buffer */dcl mg600              boolean; /* TRUE if this is an MG600 terminal */dcl #xwbase      lit '#iwindow.limits(0)'; /* x axis base in user coordinates */dcl #ywbase      lit '#iwindow.limits(2)'; /* y axis base in user coordinates */dcl #xvbase      lit '#view.limits(0)';    /* x axis base of viewport - ONLY USED FOR SCALING */dcl #yvbase      lit '#view.limits(2)';    /* y axis base of viewport - ONLY USED FOR SCALING */dcl #transparent lit '0';dcl #alpha       lit '1';dcl #vector      lit '2';dcl #point       lit '3';dcl #punits proc(fixed,fixed); /* routines used for initialization */dcl #map    proc;begin; /* initial setup */   dcl punits lit 'call #punits';   dcl i fixed;     do i=0 to 3;      #iwindow.limits(i)=#phys.limits(i);      #window.limits (i)=#phys.limits(i);      #view.limits   (i)=#phys.limits(i);      #buf.limits    (i)=#phys.limits(i);   end;     punits(#phys.limits(1),#phys.limits(3));   call #map;   #mode=#transparent;   #data.level=0; /* white */   mg600=(terminal.model=t#mg600); /* TRUE if Monterey MG600 */end; /* of initialize *//* $SUBTITLE  Device Dependent Code Section */dcl #buffer  fixed; /* buffer address for printer output */dcl #bufsize fixed public; /* size of buffer (in words for #BUFMED = 0, in sectors for #BUFMED = 1) */dcl #bufmed  fixed; /* media of buffer (0: internal memory, 1: external memory) *//*  SET_BUFFER  */#set_buffer: proc(buffer, bufsize, bufmed) public; /* set the buffer address (and size) - pass (0, 0, 0) for output to screen */   dcl buffer  fixed; /* address of outout buffer */   dcl bufsize fixed; /* size of buffer (in words for BUFMED = 0, in sectors for BUFMED = 1) */   dcl bufmed  fixed; /* media of buffer (0: internal memory; 1: external memory) */   if #bufmed IGT 1 then return; /* BUFMED can only be zero or one */   #buffer = buffer; /* set the buffer address */   #bufsize = bufsize; /* and the size */   #bufmed = bufmed; /* and the media */end #set_buffer;dcl set_buf lit 'call #set_buffer';dcl draft     lit '0'; /* draft quality */dcl copyist   lit '1'; /* publishing quality (for copyists) */dcl engraving lit '2'; /* engraving quality *//*  SQUISH  */#squish: proc(word, upper) fixed; /* squish down a 16-bit word */   dcl word  fixed; /* the word to squish */   dcl upper boolean; /* TRUE if we want the UPPER part of the squished word */   dcl byte  fixed; /* byte result */   dcl i     fixed;   if upper then word = rot(word, 1); else word = rot(word, 2); /* start it up */   byte = 0; /* start with no data */   do i = 0 to 7; /* squish away */      byte = (shl(byte, 1) or (word and 1)); /* get next bit */      word = rot(word, 2); /* rotate around */   end;   return (byte); /* return result */end #squish;/*  SCAN_SWATH  */#scan_swath: proc(swath.h, swath.l, swath_length, quality) fixed; /* change the current swath so it only takes one horizontal pass */   dcl swath.h      fixed; /* the swath we need to scan (upper 16 bits for #BUFMED = 1) */   dcl swath.l      fixed; /* the swath we need to scan (lower 8 bits for #BUFMED = 1) */   dcl swath_length fixed; /* the length of the swath */   dcl quality      fixed; /* quality of printing desired (draft, copyist, or engraving) */   dcl length       fixed; /* length of current swath */   dcl bit          fixed; /* bit to check */   dcl (s0, s1, s2) fixed; /* swath (i + 0), swath (i + 1), and swath (i + 2) respectively */   dcl prev_s0      fixed; /* previous value of swath (i + 0) */   dcl i            fixed;   if #bufmed = 1 then do; /* external memory */      write("60") = swath.h; write("61") = swath.l; /* set external address */      s1 = read("63"); s2 = read("63"); /* start things going */   end;   else do; /* internal memory */      s1 = core(swath.l); s2 = core(swath.l + 1); /* start things going */   end;   length = 0; /* initialize length of current swath */   do i = 0 to swath_length - 2; /* scan the swath */      s0 = s1; s1 = s2; /* get next set of values */      if i <> swath_length - 2 then do; /* don't read past buffer */         if #bufmed = 1 /* swath (i + 2) is from next word */         then s2 = read("63"); /* external memory */         else s2 = core(swath.l + i + 2); /* internal memory */      end;      prev_s0 = s0; /* save current value to detect change */      bit = 1; /* look at LSB first */      do while (bit <> 0); /* look out for edges of line segments */         if (s0 and bit) <> 0 then do; /* is this bit set in the swath? */            if quality <> engraving then do; /* don't alter the image for engraving quality */               if i = swath_length - 2 then do; /* last case? */                  if (s1 and bit) <> 0 /* is the last one set? */                  then s0 = (s0 xor bit); /* yes, skip this one */               end; /* of last case */               else do; /* not last case */                  if (((s1 and bit) <> 0) and ((s2 and bit) = 0)) /* end of line segment? */                  then s0 = (s0 xor bit); /* yes, skip this dot */               end; /* of not last case */            end; /* of altering the image */            length = i + 1; /* reset length */         end; /* of is this bit set in swath */         bit = shl(bit, 1); /* look at next bit */      end; /* of looking for edges of line segments */      if s0 <> prev_s0 then do; /* if swath (i + 0) changed */         if #bufmed = 1 then do; /* if the buffer is in external memory */            prev_s0 = read("61"); /* point to swath (i + 2) [or swath (i + 1) at end] */            if i = swath_length - 2 then prev_s0 = prev_s0 - 2; else prev_s0 = prev_s0 - 3; /* point to swath (i + 0) */            if prev_s0 < 0 then write("60") = read("60") - 1; /* if we wrapped, decrease sector number */            write("61") = (prev_s0 and "377"); /* write word address */            write("63") = s0; /* update value and increment */            s0 = read("63"); s0 = read("63"); /* increment to next swath (i + 2) */         end;         else core(swath.l + i) = s0; /* internal memory, update swath (i + 0) */      end; /* of if it changed */   end; /* of scanning the swath */   if s1 <> 0 /* is swath (swath_length - 1) [i.e., swath (i)] non-zero? */   then length = swath_length; /* yes, it's this long */   return (length); /* return the length */end #scan_swath;/*  PRINT_SWATH  */#print_swath: proc(swath.h, swath.l, swath_length, quality); /* print contents of screen to AMT printer */   dcl swath.h      fixed; /* the swath we're about to print (upper 16 bits for #BUFMED = 1) */   dcl swath.l      fixed; /* the swath we're about to print (lower 8 bits for #BUFMED = 1) */   dcl swath_length fixed; /* length of the swath */   dcl quality      fixed; /* quality of printing desired (draft, copyist, or engraving) */   dcl horiz.passes fixed; /* number of horizontal passes to make */   dcl horiz.pass   fixed; /* current horizontal pass over swath */   dcl len          fixed; /* length of swath */   dcl swath_word   fixed; /* next word from swath */   dcl (i, b)       fixed;   len = #scan_swath (swath.h, swath.l, swath_length, quality); /* optimize the swath for 120v x 240h */   if len <> 0 then do; /* only send something if something's there */      if quality = engraving /* engraving quality? */      then horiz.passes = 1; /* yes, make two horizontal passes */      else horiz.passes = 0; /* no, only make one */      do horiz.pass = 0 to horiz.passes; /* do as many horizontal passes as necessary */         send character(esc), '@N',; /* send GON for 120 x 240 */         send character(len and "177"), character(shr(len, 7)),; /* number of chars we're sending (mod 128 and /128) */         if #bufmed = 1 then do; /* is the buffer in external memory? */            write("60") = swath.h; write("61") = swath.l; /* set address */         end;         do i = 0 to len - 1; /* output lower section of swath */            if #bufmed = 1 /* get next word from swath */            then swath_word = read("63"); /* external */            else swath_word = core(swath.l + i); /* internal */            if ((quality <> engraving) or ((i and 1) = horiz.pass)) /* send the next byte? */            then do; /* yes, get lower segment */               b = #squish (swath_word, false); /* get lower segment */               if quality = draft /* draft mode? */               then b = (b or #squish (swath_word, true)); /* yes, OR in the upper section */            end; /* of getting lower segment */            else b = 0; /* no, skip the next byte */            send character(b),;         end; /* of lower section of swath */         send character(cr),; /* carriage return */      end; /* of horizontal passes over lower section */      if quality <> draft then do; /* only do the upper pass if this isn't draft mode */         do horiz.pass = 0 to horiz.passes; /* do as many horizontal passes as necessary */            send character(esc), '@B',; /* vertical shift UP */            send character(esc), '@N',; /* send GON for 120 x 240 */            send character(len and "177"), character(shr(len, 7)),; /* number of characters we're sending (mod 128 and /128) */            if #bufmed = 1 then do; /* is the buffer in external memory? */               write("60") = swath.h; write("61") = swath.l; /* set address */            end;            do i = 0 to len - 1; /* output upper section of swath */               if #bufmed = 1 /* get next word from swath */               then swath_word = read("63"); /* external */               else swath_word = core(swath.l + i); /* internal */               if ((quality <> engraving) or ((i and 1) = horiz.pass)) /* send the next byte? */               then b = #squish (swath_word, true); /* yes, get upper segment */               else b = 0; /* no, skip this one */               send character(b),;            end; /* of upper section of swath */            send character(cr),; /* return */         end; /* of horizontal passes over upper section */      end; /* of not draft mode */   end; /* of only send something if something's there */   send; /* end the swath */end #print_swath;/*  PRINT_BUFFER  */#print_buffer: proc(quality) public; /* print the contents of the printer buffer */   dcl quality fixed; /* quality of printing desired (draft, copyist, or engraving) */   dcl swath.h fixed; /* the swath we're about to print (upper 16 bits for #BUFMED = 1) */   dcl swath.l fixed; /* the swath we're about to print (lower 8 bits for #BUFMED = 1) */   dcl sector  fixed; /* external memory state - sector address */   dcl word    fixed; /* external memory state - word address */   dcl state   fixed; /* processor state */   dcl i       fixed;   state = read("314"); /* get processor state */   disable; /* and disable interrupts */   send character(esc), '@A(',; /* set linefeed width (8 bits at 1/120" vert. resolution) */   if #bufmed = 1 then do; /* initialize swath location */      sector = read("60"); word = read("61"); /* save external memory state */      swath.h = #buffer; swath.l = 0; /* external memory */   end;   else do; /* internal memory */      swath.h = 0; swath.l = #buffer;   end;   do i = 0 to shr(#bheight, 4) - 1; /* print all swaths */      call #print_swath (swath.h, swath.l, #bwidth, quality);      swath.l = swath.l + #bwidth; /* advance word pointer to next swath */      if #bufmed = 1 then do; /* for external memory, adjust sector pointer as well */         swath.h = swath.h + shr(swath.l, 8); /* advance sector pointer */         swath.l = (swath.l and "377"); /* mask word offset */      end;   end; /* of print all swaths */   send character(esc), '@A/',; /* set linefeed width back to 8 lpi (for 6 lpi, change '@A/' to '@A4') */   if #bufmed = 1 then do; /* restore external memory state */      write("60") = sector; write("61") = word; /* restore external memory state */   end;   write("314") = state; /* set processor state back to what it was */   write("1") = state;end #print_buffer;dcl print_buf lit 'call #print_buffer';/*  SHOWPIXEL *//* The screen buffer is organized as follows (numbers in boxes  are indices into #BUFFER; parenthesized number pairs are screen  coordinates for X's; LSB = bit 0, MSB = bit 15):     (0, #bheight - 1)                                  (#bwidth - 1, #bheight - 1)         --- X-------------------------------------------------X         MSB |   |   |   |   |   |   |   |   |   |   |         |             | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |  . . .  |         LSB |   |   |   |   |   |   |   |   |   |   |         |         --- |---+---+---+---+---+---+---+---+---+---+---------|         MSB |   |   |   |   |   |   |   |   |   |   |         |             |   |   |   |   |   |   |   |   |   |   |  . . .  |         LSB |   |   |   |   |   |   |   |   |   |   |         |         --- |---+---+---+---+---+---+---+---+---+---+---------|             |   |   |   |   |   |   |   |   |   |   |         |             | . | . | . | . | . | . | . | . | . | . |    .    |             | . | . | . | . | . | . | . | . | . | . |  . . .  |             | . | . | . | . | . | . | . | . | . | . |    .    |             |   |   |   |   |   |   |   |   |   |   |         |         --- |---+---+---+---+---+---+---+---+---+---+---------|         MSB |   |   |   |   |   |   |   |   |   |   |         |             |   |   |   |   |   |   |   |   |   |   |  . . .  |         LSB |   |   |   |   |   |   |   |   |   |   |         |         --- X-------------------------------------------------X          (0, 0)                                        (#bwidth - 1, 0)*/#showpixel: proc(x, y); /* light the specified pixel */   dcl (x, y) fixed; /* pixel to light */   dcl addr.h fixed; /* sector/word address of word within #BUFFER where pixel (X, Y) lives */   dcl addr.l fixed; /* address of word within #BUFFER where pixel (X, Y) lives */   dcl pixel  fixed; /* pixel to set within word */   x = x - #buf.limits (0); /* adjust X to start of buffer */   y = #bheight - (y - #buf.limits (2)) - 1; /* adjust Y to start of buffer and then adjust so (0, 0) is at base of buffer */   /* calculate address of word (in memory) where pixel lives: #buffer + (#bwidth*(shr(y, 4)) + x) */   write(5) = shr(y, 4); write(6) = #bwidth; /* calculate #bwidth*shr(y, 4) */   addr.h = read(4); addr.l = read(5) + x; /* get 32-bit multiplication result plus X */   if #bufmed = 1 then do; /* get address of word in external memory */      if addr.l ILT x then addr.h = addr.h + 1; /* detect overflow in "plus X" calculation */      addr.h = #buffer + shl(addr.h, 8) + shr(addr.l, 8); /* form 12/8 bit pair */      addr.l = (addr.l and "377");   end;   else addr.h = #buffer + addr.l; /* move internal memory pointer to ADDR.H */   if addr.h - #buffer ILT #bufsize then do; /* double check that we're in range */      pixel = shr("100000", y and "17"); /* get which pixel to show */      if #bufmed = 1 then do; /* external memory */         write("60") = addr.h; write("61") = addr.l; /* set address */         do case (#data.level); /* branch on data level */            write("62") = (read("62") or pixel); /* light the pixel */            write("62") = (read("62") and (not pixel)); /* erase the pixel */            write("62") = (read("62") xor pixel); /* complement the pixel */         end; /* of branching on data level */      end; /* of external memory */      else do case (#data.level); /* branch on data level for internal memory */         core (addr.h) = (core (addr.h) or pixel); /* light the pixel */         core (addr.h) = (core (addr.h) and (not pixel)); /* erase the pixel */         core (addr.h) = (core (addr.h) xor pixel); /* complement the pixel */      end; /* of branching on data level */   end; /* of showing pixel */end #showpixel;/*  SHOWLINE  */#showline: proc(x1, y1, x2, y2, x, y, dx, dy); /* draw a line on the "screen" using Bresenham's algorithm */   dcl (x1, y1, x2, y2)       fixed; /* endpoints of line */   dcl (x, y, dx, dy)         fixed; /* initial (x, y) of unclipped line, change in X and Y of unclipped line */   dcl (delta, dy2, xy_diff2) fixed; /* line length approximation, (change in y)*2, (difference between dx and dy)*2 */   dcl (odx, sgn_dx, sgn_dy)  fixed; /* original value of DX, sign of DX and DY */   dcl (e, swap, i)           fixed; /* E is the error term; SWAP is TRUE if we swapped X and Y */   sgn: proc(x) fixed; /* our old friend Signum(x) */      dcl x fixed;      if x < 0 then return (-1);      else if x = 0 then return (0);      else return (1);   end sgn;   if abs(dx) < abs(dy) then do; /* swap X and Y for this case */      delta = abs(y2 - y1); /* line length estimate is in terms of Y */      i = x1; x1 = y1; y1 = i; /* swap X and Y */      i = x;  x  = y;  y  = i;/* swap initial X and Y */      i = dx; dx = dy; dy = i; /* swap DX and DY */      swap = true; /* we swapped */   end;   else do; /* don't swap */      delta = abs(x2 - x1); /* line length estimate is in terms of X */      swap = false; /* no swap */   end;   if dx < 0 then do; /* draw negative-going lines positively (temporary KLUDGE until we find out why DX < 0 doesn't work) */      x = x + dx; y = y + dy; /* move start of unclipped line to end */      dx = -dx; dy = -dy; /* the change in X and Y is now opposite */      if swap then do; /* move x1 and y1 to the other end of the line */         x1 = y2; y1 = x2;      end;      else do;         x1 = x2; y1 = y2;      end;   end; /* of making negative-going lines positive */   sgn_dx = sgn(dx); sgn_dy = sgn(dy); odx = dx; /* save original DX (before multiplying by the sign of the slope) */   if sgn_dx <> sgn_dy then dx = -dx; /* multiply DX by the sign of the slope */   dy2 = shl(dy, 1); xy_diff2 = shl(dy - dx, 1);   e = dy2 - dx + shl((x1 - x)*dy - (y1 - y)*odx, 1); /* get initial error term */   do i = 0 to delta; /* traverse the side with the greatest change */      if swap then call #showpixel (y1, x1); else call #showpixel (x1, y1);      if ((sgn (e) = sgn_dy) and (sgn_dy <> 0)) then do; /* is the error too large? */         y1 = y1 + sgn_dy; /* correct for the error */         e = e + xy_diff2;      end;      else e = e + dy2; /* error isn't too large */      x1 = x1 + sgn_dx;   end;end #showline;/* $SUBTITLE  Device Dependent Code Section:  for VT-640 */dcl (#highy,#lowy,#highx) fixed; /* last coordinates transmitted */         dcl point_mode       lit 'do;if #bufsize=0 then do;control.seq=1;wchar("34");#initialize=1;end;#mode=#point;end;';dcl vector_mode      lit 'do;if #bufsize=0 then do;control.seq=1;wchar("35");#initialize=1;end;#mode=#vector;end;'; dcl transparent_mode lit 'if #mode<>#transparent then do;if #bufsize=0 then do;control.seq=0;wchar("30");end;#mode=#transparent;end;';dcl alpha_mode       lit 'do;if #bufsize=0 then do;control.seq=1;wchar("37");end;#mode=#alpha;end;';/*  CLEAR  */#clear:proc public; /* clear screen, leave in transparent mode */   dcl sector fixed; /* external memory card state */   dcl word   fixed; /* lower 8 bits of ext mem state */   dcl (i, j) fixed;   if #bufsize = 0 then do; /* normal tek10 = esc,ff,cr  */      vector_mode;      wchar(esc);      wchar(ff);      transparent_mode;      pos(0,0); /* move back to the top of the screen */   end; /* of normal tek10 */   else do; /* clear printer buffer */      if #bufmed = 1 then do; /* is it in external memory? */         sector = read("60"); word = read("61"); /* save state */         write("60") = #buffer; /* start at the beginning of the buffer */         do i = 0 to #bufsize - 1; /* loop over sectors */            do j = 0 to 255; write("63") = 0; end;         end;         write("60") = sector; write("61") = word; /* restore state */      end; /* of external memory clear */      else do i = #buffer to #buffer + #bufsize - 1; /* internal memory clear */         core(i) = 0;      end;   end; /* of clearing printer buffer */end #clear;dcl CLEAR lit 'call #clear';/*  C H A R _ S I Z E  */#char_size:proc(i) public; /* char size 0 - 80 per line;  1-40 per line */  dcl i fixed;    if (i < 0) or (i > 3) or (#bufsize <> 0) then return;  wchar(ESC);  wchar(ASC.0+i);  #char.size=i;end #char_size;dcl CHAR_SIZE lit 'call #char_size';/*  D A T A _ L E V E L  */#data_level:proc(i) public; /* sets line to on, off, or complement */  dcl i fixed;  if (i < 0) or (i > 2) then return; /* error return */  if #bufsize = 0 then do; /* set the mode on the terminal */     wchar(ESC);  wchar(SLASH);     do case i;       wchar(ASC.0); /* dots on */       wchar(ASC.1); /* dots off */       wchar("062"); /* dots complemented */     end;       wchar("144");  end; /* of setting mode on terminal */  #data.level=i; /* save value */end #data_level;dcl DATA_LEVEL lit 'call #data_level';/*  L I N E _ T Y P E  */#line_type:proc(i) public; /* sets line type */  dcl i fixed;             if (i < 0) or (i > 4) or (#bufsize <> 0) then return; /* user defined types not implemented */  wchar(ESC);  do case i;    wchar("140"); /* normal line, note 140 not 134 */    wchar("141"); /* dotted line */    wchar("142"); /* dot-dashed line */    wchar("143"); /* short-dashed line */    wchar("144"); /* long-dashed line */  end;    #line.type=i; /* save value */end #line_type;dcl LINE_TYPE lit 'call #line_type';/* Some Internal Procedures */#greater:proc(a,b) fixed; /* returns 1 if a>b, in range -32768,+32767 */   dcl (a,b)   fixed;   dcl (g1,g2) fixed;   g1=((a&"100000")=0); /* test to see if positive number */   g2=((b&"100000")=0);   if (g1 xor g2) then return g1;   if a > b then return 1;   return 0;end #greater;#converty:proc(y) fixed;   dcl (y,sign) fixed;   sign=0;   if #greater(y,#ywbase) then write(5)=y-#ywbase;   else do;      sign=1;      write(5)=#ywbase-y;   end;   write(6)=#ynum; y=read(5); write(7)=#yden; /* compute (y-base)*num/den */   if sign then return #yvbase-read(5);   else         return #yvbase+read(5);end #converty;#convertx:proc(x) fixed;   dcl (x,sign) fixed;   sign=0;   if #greater(x,#xwbase) then write(5)=x-#xwbase;   else do;      sign=1;      write(5)=#xwbase-x;   end;   write(6)=#xnum; x=read(5); write(7)=#xden; /* compute (x-base)*num/den */   if sign then return #xvbase-read(5);   else         return #xvbase+read(5);end #convertx;dcl #convert_x lit 'x=#convertx(x)';dcl #convert_y lit 'y=#converty(y)';dcl #convert_coordinates lit '#convert_x;#convert_y';#fconvert_x:proc(x) fixed;   dcl x floating;   return int((x-#window.limits(0))*#xnum/(#window.limits(1)-#window.limits(0))+#xvbase);end #fconvert_x;#fconvert_y:proc(y) fixed;   dcl y floating;   return int((y-#window.limits(2))*#ynum/(#window.limits(3)-#window.limits(2))+#yvbase);end #fconvert_y;#transmit_coords:proc(x,y); /* emit vector coordinates according to protocol */   dcl (x,y)                   fixed;                               dcl (highy,lowy,highx,lowx) fixed;   if #bufsize <> 0 then return; /* don't transmit unless plotting to the screen */   /* scale from user's punits to physical plotter units */   write(5)=x;   write(6)=#phys.limits(1);   x=read(5); /* this is needed because of a 4567 bug */   write(7)=#px;   x=read(5);   if (dq640 and (read(4) >= shr(#px + 1, 1))) then x = x + 1; /* round up */   write(5)=y;   write(6)=#phys.limits(3);   y=read(5); /* this is needed because of a 4567 bug */   write(7)=#py;   y=read(5);   if (dq640 and (read(4) >= shr(#py + 1, 1))) then y = y + 1; /* round up */     highy=(shr(y,5)+32); /* high y */   lowy=((y&"37")+96);  /* low  y */   highx=(shr(x,5)+32); /* high x */   lowx=((x&"37")+64);  /* low  x */   if #initialize then do; /* must write all bytes */      #initialize=0;      wchar(highy); wchar(lowy); wchar(highx);   end;   else do; /* conditionally write bytes */      if #highy<>highy then wchar(highy);      if #highx<>highx then do;         wchar(lowy); wchar(highx);      end;      else if #lowy<>lowy then wchar(lowy);   end;      wchar(lowx);   #highy=highy;  #lowy=lowy;  #highx=highx; /* keep track of last values */end #transmit_coords;/* $PAGE */#hardcopy: proc public; /* dumps from the screen to the I.D.S. */   dcl gon      lit 'character(03)';   dcl goff     lit 'gon,character(02)';   dcl linefeed lit 'gon,character(14)';   dcl formfeed lit 'gon,character(ff)';   dcl storage ((((1024 + 3)/4)*4 + 1)/2) fixed; /* this is just (GROUPS*4 + 1)/2 for largest screen (and N) supported */   dcl bit      fixed;   dcl last_byt fixed;   read_screen: proc(y, groups, screen_width, n);      map_bits: proc(c, byt, bits); /* map screen bits to printer bits */         dcl c    fixed; /* character to map */         dcl byt  fixed; /* byte position in mapped printer array */         dcl bits fixed; /* number of bits in C that are valid */         dcl j    fixed;         if mg600 then c = rot(c, 16 - bits); /* bits are in reverse order on MG600 */         if c <> 0 /* don't waste time if C = 0 */         then do j = 0 to bits; /* map all bits that are valid */            byt = byt - 1;            if c then do; /* if the bit is set, map it onto the printer */               call pbyte(storage, byt, (byte(storage, byt) or bit));               if last_byt < byt then last_byt = byt; /* look for the end */            end;            if mg600 /* if MG600 */            then c = rot(c, 1); /* take next bit from top */            else c = shr(c, 1); /* look at the next bit (from bottom) */         end; /* of mapping bits */      end map_bits;      dcl y                 fixed; /* Y position of line to read */      dcl groups            fixed; /* number of 5-pixel or 6-pixel groups in line */      dcl screen_width      fixed; /* width (in pixels) of screen */      dcl n                 fixed; /* number of bits in a group */      dcl buf (((1024 + 3)/4 + 1)/2) fixed; /* input buffer (size is # groups for largest screen (and N) supported) */      dcl byt               fixed; /* byte position in printer array */      dcl c                 fixed; /* next character from screen */      dcl count             fixed; /* number of consecutive bytes */      dcl last_bit          fixed; /* last bit on line */      dcl (i, j)            fixed;      if mg600 then do; /* if an MG600 */         i = shr(y, 5) + 32; j = (y and "37") + 96; /* high y, low y */         wchar(esc); pstring ('}9'); wchar(i); wchar(j); wchar(i); wchar(j); /* ask for line Y */      end; /* of MG600 */      else do; /* VT640 or DQ640 */         wchar (esc); pstring ('"0;'); pnum (y, 0); wchar(scolon); /* ask for line Y */         if dq640 then do; /* for DQ640 */            pnum (screen_width, 0); wchar (asc.c);         end;         else do; /* for VT640 */            pnum (groups, 0); wchar (lower.c);         end;      end; /* of VT640 or DQ640 */      i = 0; /* start reading bytes at byte zero */      buf (0) = groups; /* there are GROUPS bytes in the buffer */      do while (i <= groups - 1); /* read all bytes */         c = rchar; /* get next character */         if c = asc.dollr then do; /* repeating bytes of all zeroes */            c = 0; /* pattern is all zeros */            count = (rchar & "077"); /* get count */         end; /* of repeating zeroes */         else if c = percent then do; /* repeating bytes of all ones */            c = "077"; /* pattern is all ones */            count = (rchar & "077"); /* get count */         end; /* of repeating ones */         else if c = asc.amp then do; /* repeating bytes of an arbitrary pattern */            c = rchar; /* get the pattern */            count = (rchar & "077"); /* and the count */         end; /* of repeating pattern */         else count = 1; /* just a single byte */         do j = 1 to count; /* save the bytes */            call pbyte(buf, i, c); /* save this character */            i = i + 1; /* advance screen counter */         end; /* of saving bytes */      end; /* of reading all bytes */      c = rchar; /* read trailer */      last_bit = ((screen_width - 1) mod n); /* last bit on line */      byt = 0; /* start at beginning of printer array */      do i = 0 to groups - 1; /* map the screen bytes onto the printer */         if i = groups - 1 then do; /* make sure we don't map too many bits on last byte */            byt = byt + last_bit + 1; /* advance printer counter */            call map_bits (byte(buf, i), byt, last_bit); /* map bits */         end; /* of mapping bits on last pass */         else do; /* no need to be careful the rest of the time */            byt = byt + n; /* advance printer counter */            call map_bits (byte(buf, i), byt, n - 1); /* map bits */         end; /* of rest of the time */      end; /* of mapping screen bytes onto printer */   end read_screen;   dcl screen_width  fixed; /* width of screen in pixels */   dcl screen_height fixed; /* height of screen in pixels */   dcl groups        fixed; /* width of screen in 6-pixel units */   dcl swaths        fixed; /* height of screen in swaths (7-pixel units) */   dcl save          fixed;   dcl (i,j,k,n,y)   fixed;   save = read("314"); /* save interrupt status */   vector_mode;   disable; send gon,; write("314") = save; write("1") = save; /* turn printer graphics on */   if mg600 then do; /* mg600 */      screen_width = 1024; /* for MG600 */      screen_height = 780;      n = 4; /* readback is in 4-pixel groups */   end;   else if dq640 then do; /* dq640 */      screen_width = 800; /* for DQ640 */      screen_height = 480;      n = 6; /* readback is in 6-pixel groups */   end;   else do; /* vt640 */      screen_width = 640; /* for VT640 */      screen_height = 480;      n = 5; /* readback is in 5-pixel groups */   end;   groups = (screen_width + (n - 1))/n; /* round up to nearest N-pixel boundary */   swaths = (screen_height + 6)/7; /* round up to nearest 7-pixel boundary */      do i = 0 to swaths - 1;      do j = 0 to (groups*n + 1)/2; storage (j) = 0; end;      last_byt = -1; bit = 1;      if i = swaths - 1 then k = ((screen_height - 1) mod 7); /* restrict last swath to screen size */      else k = 6; /* not last swath - create all 7 swath lines */      do j = 0 to k;         y = (screen_height - 1) - i*7 - j; /* calculate next line address */         call read_screen (y, groups, screen_width, n);         bit = shl(bit, 1);      end;      disable;      do j = 0 to last_byt;         k = byte(storage, j);         if k = 3 then send gon,;         send character(k),;      end;      send linefeed,;      write("314") = save; write("1") = save; /* restore interrupt status */   end;   transparent_mode;   disable; send goff,; write("314") = save; write("1") = save; /* turn printer graphics off */end #hardcopy;dcl HARDCOPY lit 'call #hardcopy';/* end device dependent code *//* $SUBTITLE  Non Device Dependent Code *//* MORE INTERNALS */#code:proc(x,y) fixed; /* endpoint codes for 9 regions of screen - check against viewport/bufport */   dcl (x,y) fixed;   dcl c     fixed;   c=0; /* initialize */   if      #greater(#buf.limits(0),x) then c=1;   else if #greater(x,#buf.limits(1)) then c=2;   if      #greater(#buf.limits(2),y) then c=(c|4);   else if #greater(y,#buf.limits(3)) then c=(c|8);   return c;end #code;#move:proc(h,v) fixed; /* begin new vector drawing sequence at (h,v), return 1 if out of bounds */   dcl (h,v) fixed;   #lastx=h;   #lasty=v;   if #mode <> #point then vector_mode;   if #code(h,v) <> 0 then return 1;   call #transmit_coords(h,v);   return 0;end #move;#draw: proc(x, y); /* called to draw vector to or put point at (x,y) */                dcl (x, y) fixed;   dcl sector fixed; /* external memory card state */   dcl word   fixed; /* lower 8 bits of ext mem state */   /* CLIP is derived from the midpoint subdivision algorithm on page 68 of Newman & Sproull      and the Cohen-Sutherland algorithm on pages 66-67 of Newman and Sproull.      This particular algorithm was invented by Karim J. Chichakly in April 1984. */   clip: proc(x1, y1, x2, y2); /* clips vector from (x1,y1) to (x2,y2) at viewport (or bufport) */      dcl (x1, y1, x2, y2)     fixed; /* vector to clip */      dcl (deltax, deltay)     fixed; /* change in X, change in Y */      dcl (s1, t1, s2, t2)     fixed; /* temporary vector */      dcl (cx1, cy1, cx2, cy2) fixed; /* clipped vector */      dcl (x, y)               fixed; /* midpoint */      dcl (c, c1, c2)          fixed; /* coded midpoint, and two endpoints */      dcl swap                 boolean; /* TRUE if Cohen-Sutherland (CS) was used */         cx1 = x1; cy1 = y1; cx2 = x2; cy2 = y2; /* set default clipped vector */      c1 = #code (cx1, cy1); c2 = #code (cx2, cy2); /* find the clipped vector's endpoints' positions relative to the viewport */      deltax = x2 - x1; deltay = y2 - y1; /* find change in X, change in Y */      do while ((c1 or c2) <> 0); /* loop until the clipped vector is trivially accepted */         if c1 = 0 then do; /* if c1 is already accepted, set up to clip c2 */            s1 = x2; t1 = y2; s2 = x1; t2 = y1; /* set up temporary point */            c1 = c2; c2 = 0; swap = true; /* swap the two endpoints */         end; /* of set up to clip c2 */         else do; /* set up to clip c1 */            s1 = x1; t1 = y1; s2 = x2; t2 = y2; swap = false; /* set up temporary point */         end; /* of set up to clip c1 */         do while (c1 <> 0); /* loop until c1 is trivially accepted */            if (c1 and c2) <> 0 then return; /* trivially reject the line if it's outside the viewport */            if abs(deltax) > abs(deltay) then do; /* subdivide in the direction of greatest change */               if (c1 and "3") = c1 then do; /* see if Cohen-Sutherland is accurate enough */                  if (c1 and "1") <> 0 /* CS is accurate enough here */                  then x = #buf.limits (0); /* clip on left edge */                  else x = #buf.limits (1); /* clip on right edge */               end; /* of Cohen-Sutherland */               else x = (s1 + s2)/2; /* can't use CS - subdivide X */               y = y1 + deltay*(x - x1)/deltax; /* compute the actual value of Y for the new value of X */               if read(4) >= shr(abs(deltax) + 1, 1) then y = y + 1; /* round up */            end;            else do; /* subdivide in the y-direction */               if (c1 and "14") = c1 then do; /* see if Cohen-Sutherland is accurate enough */                  if (c1 and "4") <> 0 /* CS is accurate enough here */                  then y = #buf.limits (2); /* clip on bottom edge */                  else y = #buf.limits (3); /* clip on top edge */               end; /* of Cohen-Sutherland */               else y = (t1 + t2)/2; /* can't use CS - subdivide Y */               x = x1 + deltax*(y - y1)/deltay; /* compute the actual value of X for the new value of Y */               if read(4) >= shr(abs(deltay) + 1, 1) then x = x + 1; /* round up */            end;            if (((x = s1) and (y = t1)) or ((x = s2) and (y = t2))) /* see if the new midpoint is an endpoint */            then c1 = 0; /* we're done - exit loop ((s1, t1) or (s2, t2) is the clipped point) */            else do; /* not done yet */               c = #code (x, y); /* find the midpoint's position relative to the viewport */               if (c and c1) <> 0 then do; /* if we can trivially reject (x, y) to (s1, t1) */                  s1 = x; t1 = y; c1 = c; /* get rid of it */               end;               else do; /* can't reject it yet (or we used the Cohen-Sutherland algorithm) */                  s2 = x; t2 = y; c2 = c; /* prepare to subdivide it again */               end;            end; /* of not done yet */         end; /* of trivially accepting it */         if c2 = 0 then do; /* the point we're looking for is (s2, t2) */            if swap then do; /* if we swapped, this is clipped endpoint two */               cx2 = s2; cy2 = t2;            end;            else do; /* didn't swap - it's clipped endpoint one */               cx1 = s2; cy1 = t2;            end;         end; /* of the point we're looking for is (s2, t2) */         else do; /* the point we're looking for is (s1, t1) */            if swap then do; /* if we swapped this is clipped endpoint two */               cx2 = s1; cy2 = t1;            end;            else do; /* didn't swap - it's clipped endpoint one */               cx1 = s1; cy1 = t1;            end;         end; /* of the point we're looking for is (s1, t1) */         c1 = #code (cx1, cy1); c2 = #code (cx2, cy2); /* retrieve the clipped endpoints' positions relative to the viewport */      end; /* of clipping the vector */            if (cx1 <> #lastx) or (cy1 <> #lasty) then call #move (cx1, cy1); /* begin new vector if start of vector has been clipped */      if #bufsize = 0 then call #transmit_coords (cx2, cy2);      else call #showline (cx1, cy1, cx2, cy2, x1, y1, deltax, deltay);   end clip;   if #bufmed = 1 then do; /* save external memory state if necessary */      sector = read("60"); word = read("61"); /* save ext mem state */   end;   if #mode = #point then do;      if #code (x, y) = 0 then do;         if #bufsize = 0 then call #transmit_coords (x, y);         else call #showpixel (x, y);      end;      #lastx=x;      #lasty=y;   end;   else if #mode<>#vector then call #move(x,y);   else do;        call clip(#lastx,#lasty,x,y);      #lastx=x;      #lasty=y;   end;   if #bufmed = 1 then do; /* restore external memory state */      write("60") = sector; write("61") = word; /* restore ext mem state */   end;end #draw; #map:proc; /* computes numerator and denominator for scaling */   #xnum=#view.limits(1)   -#view.limits(0);     #ynum=#view.limits(3)   -#view.limits(2);   #xden=#iwindow.limits(1)-#iwindow.limits(0);   #yden=#iwindow.limits(3)-#iwindow.limits(2);end #map;#frame:proc(vector,x1,x2,y1,y2); /* to store viewport or window coordinates */   dcl vector        fixed array;        dcl (x1,x2,y1,y2) fixed;   vector(0)=x1;   vector(1)=x2;   vector(2)=y1;   vector(3)=y2;end #frame;/*  P S  */#plotstring:proc(string) public; /* plots string in TEK4010 alpha characters */   dcl string fixed array; /* string to be printed */   if (#mode<>#alpha) and (#mode<>#transparent) then alpha_mode;   if #bufsize = 0 then pstring(string); /* for now, don't plot to printer */end #plotstring;  dcl PS lit 'call #plotstring';/*  P N  */#plotnum:proc(num) public; /* plots number in TEK4010 alpha characters */   dcl num fixed; /* number to plot */   if (#mode<>#alpha) and (#mode<>#transparent) then alpha_mode;   if #bufsize = 0 then pnum(num,0); /* for now, don't plot to printer */end #plotnum;dcl PN lit 'call #plotnum';/*  I P L O T  */#iplot:proc(x,y) public; /* continues vector sequence to (x,y) in user units */   dcl (x,y) fixed;     #convert_coordinates;   if (#mode=#vector) or (#mode=#point) then call #draw(x,y);   else                                      call #move(x,y);end #iplot;dcl IPLOT lit 'call #iplot';/*  P L O T  */#plot:proc(x,y) public; /* continues vector sequence to FLOATING POINT problem (x,y) coord's */   dcl (x,y) floating;     if (#mode=#vector) or (#mode=#point) then call #draw(#fconvert_x(x),#fconvert_y(y));   else                                      call #move(#fconvert_x(x),#fconvert_y(y));end #plot;dcl PLOT lit 'call #plot';/*  I M O V E _ T O  */#imove_to:proc(x,y) fixed public; /* begin vector sequence at user's (x,y), return 1 if out  */   dcl (x,y) fixed;      #convert_coordinates;   return #move(x,y);end #imove_to;dcl IMOVE_TO lit 'call #imove_to';/*  M O V E _ T O  */#move_to:proc(x,y) fixed public; /* begin vector sequence at FLOATING POINT problem (x,y) coords, return 1 if out  */   dcl (x,y) floating;     return #move(#fconvert_x(x),#fconvert_y(y));end #move_to;dcl MOVE_TO lit 'call #move_to';/*  I C O N N E C T  */#iconnect:proc(a,b,c,d) public; /* connects users (a,b) to (c,d) */   /* moves to (a,b) with pen in present state and     then connects (a,b) with (c,d) and leaves pen up at the end */   dcl (a,b,c,d) fixed;   call #imove_to(a,b);   call #iplot (c,d);end #iconnect;dcl ICONNECT lit 'call #iconnect';/*  C O N N E C T  */#connect:proc(a,b,c,d) public; /* connects FLOATING POINT problem (a,b) to (c,d) */   /* moves to (a,b) with pen in present state and     then connects (a,b) with (c,d) and leaves pen up at the end */   dcl (a,b,c,d) floating;   call #move_to(a,b);   call #plot (c,d);end #connect;dcl CONNECT lit 'call #connect';/*  I A X E S  */#iaxes:proc(x,y) public; /* axes through (x,y) */    dcl (x,y) fixed;   iconnect(x,#iwindow.limits(3),  x,#iwindow.limits(2));   iconnect(#iwindow.limits(0),y,  #iwindow.limits(1),y); end #iaxes;dcl IAXES lit 'call #iaxes';/*  A X E S  */#axes:proc(x,y) public; /* axes through FLOATING POINT problem (x,y) */    dcl (x,y) floating;   connect(x,#window.limits(3),  x,#window.limits(2));   connect(#window.limits(0),y,  #window.limits(1),y); end #axes;dcl AXES lit 'call #axes';/*  B O R D E R  */#border:proc public; /* draw border around viewport */   call #move(#view.limits(0),#view.limits(2));   call #draw(#view.limits(1),#view.limits(2));   call #draw(#view.limits(1),#view.limits(3));   call #draw(#view.limits(0),#view.limits(3));   call #draw(#view.limits(0),#view.limits(2));end #border;dcl BORDER lit 'call #border';/*  C H A R _ B O U N D */#char_bound:proc(x,y,xsize,ysize) returns (fixed) public; /* check to see if char can be plotted */   dcl (x,y,xsize,ysize) fixed;      #convert_coordinates;   if x < 0 \ x > #px-xsize then return (false);   if y < 0 \ y > #py-ysize then return (false);   return (true);end #char_bound;dcl CHAR_BOUND lit '#char_bound';/*  P U N I T S  */#punits:proc(x,y) public; /* user units for viewports */   /* for VT-640, call with (639,479) */   dcl (x,y) fixed;   #px=x;   #py=y;end #punits;dcl PUNITS lit 'call #punits';/*  I W I N D O W  */#iwindow:proc(x1,x2,y1,y2) public; /* set plot limits in user units */   dcl (x1,x2,y1,y2) fixed;     call #frame(#iwindow.limits,x1,x2,y1,y2); /* sets window limits */   call #map; /* update scaling */end #iwindow;dcl IWINDOW lit 'call #iwindow';/*  W I N D O W  */#window:proc(x1,x2,y1,y2) public; /* set plot limits in floating user units */   dcl (x1,x2,y1,y2) floating;   #window.limits(0)=x1;   #window.limits(1)=x2;   #window.limits(2)=y1;   #window.limits(3)=y2;end #window;dcl WINDOW lit 'call #window';/*  V I E W P O R T  */#viewport:proc(x1,x2,y1,y2) public; /* set plot limits in plotter units */   dcl (x1,x2,y1,y2) fixed;   call #frame(#view.limits,x1,x2,y1,y2); /* set view limits */   call #map; /* update scaling */   if #bufsize = 0 then call #frame(#buf.limits,x1,x2,y1,y2); /* set buffer limits to match viewport so CLIP works on screen */end #viewport;dcl VIEWPORT lit 'call #viewport';/*  B U F P O R T  */#bufport:proc(x1,x2,y1,y2) public; /* set buffer limits */   dcl (x1,x2,y1,y2) fixed;      if #bufsize <> 0 then do; /* don't do this unless we're plotting to screen */      #bwidth = x2 - x1 + 1; /* determine buffer width and height */      #bheight = y2 - y1 + 1;      call #frame(#buf.limits,x1,x2,y1,y2); /* set view limits */   end;end #bufport;dcl BUFPORT lit 'call #bufport';end PLOTTING_LIBRARY;