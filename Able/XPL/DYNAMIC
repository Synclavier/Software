/* DYNAMIC  $title Dynamic Memory Allocation *//* This module forms the basis of a heap management library.  The.  programmer is allowed allocate and release blocks of memory via.  pointers or handles.  When using handles, garbage collection is.  performed on the heap when a block of the proper size cannot be.  found.  The size of an allocated block can also be changed (at.  the moment, they can only grow)...  The allocation scheme is first fit (we always start searching from.  where the last search left off or from the last block freed) and.  the garbage collection is a simple compaction algorithm...  The heap is divided into blocks.  Each block looks like:..                        ---------------.          (PTR - 2) -> | size of block |.                       |---------------|.          (PTR - 1) -> | active/locked |.                       |---------------|.                PTR -> |               |.                       |  application  |.                       |               |.                       |     data      |.                       |               |.                        ---------------..  where the first two words form a block header.  The size of the.  block includes the header, but all block pointers point after.  the header (including HEAP_PTR).  The size of each free block.  is forced even (and hence the length of the heap is even).  The.  active/locked word is non-zero for allocated blocks and zero.  for free blocks.  There is a two word (just the header) allocated.  and locked block at the end of the heap.  This is only there to.  allow the garbage collection to set up the last free block in the.  heap correctly...  Each handle record is two words long.  The first word is a pointer.  to this handle's block.  The second word is the number of users.  of this handle.  This is incremented every time a new handle is.  created for this same block and decremented every time a handle.  to this block is destroyed.  A handle is free when its pointer is.  NULL (and/or its number of users is zero).  Note that the block.  pointer must have an offset of zero in the handle record so that.  CORE(handle) is the pointer to the block...  By:  Karim J. Chichakly during April/May 1987*/module dynamic_memory; /* dynamic memory allocation */   configuration modelC, nomuldiv;   dcl handle lit 'pointer'; /* handle definition */   /* block header */   dcl b.size lit '(-2)'; /* size of block (including header) */   dcl b.used lit '(-1)'; /* active/lock bits (non-zero if locked) */   dcl b.len  lit '2'; /* header length */   dcl b$active lit '"1"'; /* active */   dcl b$locked lit '"2"'; /* locked */   /* handle records */   dcl h.ptr lit '0'; /* pointer to block */   dcl h.usr lit '1'; /* number of users of block */   dcl h.len lit '2'; /* record length */   dcl handle_ptr pointer; handle_ptr = null; /* pointer to list of handles */   dcl handle_end pointer; handle_end = null; /* pointer to end of handles (plus one) */   dcl heap_ptr  pointer; heap_ptr  = null; /* pointer to heap */   dcl heap_end  pointer; heap_end  = null; /* pointer to end of heap (plus one) */   dcl heap_free pointer; heap_free = null; /* pointer to where last allocation occurred */   /* $subtitle Handle Allocation:  Find_Handle, Get_Handle, Rel_Handle */   /* This procedure finds a handle that points to PTR and returns that   .  handle.  If no handle points to PTR, a NULL pointer is returned. */   find_handle: proc(ptr) returns (handle); /* find handle pointing to PTR */      dcl ptr pointer; /* look for this pointer's handle */      dcl p   handle;      p = handle_ptr;      do while ((p ilt handle_end) and (core(p + h.ptr) <> ptr)); /* look for it */         p = p + h.len;      end;      if p ilt handle_end /* if we found a match */      then return (p); /* return pointer to handle */      else return (null); /* no match */   end find_handle;   /* This procedure gets (allocates) a handle to point to PTR.  If one   .  already exists, it is used rather than allocating a new one.  If   .  a handle cannot be allocated, a NULL pointer is returned. */   get_handle: proc(ptr) returns (handle); /* get a handle to PTR */      dcl ptr pointer; /* pointer to get a handle to */      dcl p   handle;      p = find_handle (ptr); /* see if one already exists */      if p = null /* if didn't find one */      then p = find_handle (null); /* see if there's a free one */      if p <> null then do; /* if we got a handle */         core(p + h.ptr) = ptr; /* set pointer (may already be set) */         core(p + h.usr) = core(p + h.usr) + 1; /* one more user */      end; /* of got a handle */      return (p); /* return handle pointer */   end get_handle;   /* This procedure releases (frees) the handle pointing to PTR.  If one   .  already exists, it is only freed if it has no users. */   rel_handle: proc(ptr); /* release handle pointing to PTR */      dcl ptr pointer; /* release this pointer's handle */      dcl p   handle;      p = find_handle (ptr); /* look for its handle */      if p <> null then do; /* if we found it */         core(p + h.usr) = core(p + h.usr) - 1; /* one less user */         if core(p + h.usr) = 0 /* if no more users */         then core(p + h.ptr) = null; /* free the handle */      end; /* of we found it */   end rel_handle;   /* $subtitle Handle Modification:  Update_Handle, Destroy_Handle, Clear_Handles */   /* This procedure updates all handles that point to OLD so that they   .  point to NEW.  This is necessary for memory compaction (where blocks   .  are moved in memory on demand). */   update_handle: proc(old, new); /* update handles that point to OLD to point to NEW */      dcl old pointer; /* old pointer */      dcl new pointer; /* new pointer */      dcl p   handle;      p = handle_ptr;      do while (p ilt handle_end); /* update all pointers that point to OLD */         if core(p + h.ptr) = old /* if this one points to OLD */         then core(p + h.ptr) = new; /* make it point to NEW */         p = p + h.len; /* point to next handle */      end;   end update_handle;   /* This procedure destroys a handle. */   destroy_handle: proc(p); /* clear a handle */      dcl p handle; /* pointer to handle to clear */      if p <> null then do; /* make sure it's a valid handle */         core(p + h.usr) = 0; /* no more users */         core(p + h.ptr) = null; /* free handle */      end;   end destroy_handle;   /* This procedure releases all handles. */   clear_handles: proc; /* free every handle */      dcl p handle;      p = handle_ptr;      do while (p ilt handle_end); /* loop over all handles */         call destroy_handle (p); /* destroy next handle */         p = p + h.len; /* point to next handle */      end; /* of looping over all handles */   end clear_handles;   dump_handles: proc; /* dump handle records */      dcl p handle;      if handle_ptr <> null then do; /* if there are handles */         print; print 'handle  pointr  users   [handles]';         p = handle_ptr;         do while (p ilt handle_end); /* loop over all handles */            if core(p + h.ptr) <> null /* if handle in use */            then print octal(p), '  ', octal(core(p + h.ptr)), ' ', core(p + h.usr);            p = p + h.len; /* point to next handle */         end;      end; /* of there are handles */   end dump_handles;   /* $subtitle Heap Traversal:  Next, Prev */   /* This procedure returns a pointer to the block following PTR.  If   .  PTR points to the end of the heap, a pointer to the first block   .  is returned. */   next: proc(ptr) returns (pointer); /* get pointer to next block */      dcl ptr fixed;      if ptr = heap_end /* if at end */      then return (heap_ptr); /* return first block */      else return (ptr + ((core(ptr + b.size) + 1) and (not 1))); /* length must be even */   end next;   /* This procedure returns a pointer to the block preceding PTR.  If   .  PTR is the first block in the heap, it returns a pointer to the   .  last block. */   prev: proc(ptr) returns (pointer); /* get pointer to previous block */      dcl ptr fixed;      dcl p   fixed;      p = heap_ptr; /* start beginning of heap */      do while (next (p) <> ptr); /* look for block before this one */         p = next (p); /* advance pointer */      end;      return (p); /* return pointer */   end prev;   /* $subtitle Heap Block Allocation:  Free_Block, Rel_Block */   /* This procedure frees a block much as REL_BLOCK does.  The only   .  difference is that the previous block is NOT combined with this   .  block if it is free. */   free_block: proc(ptr); /* free block PTR; does NOT combine with previous */      dcl ptr pointer; /* block to free */      dcl p   pointer;      heap_free = ptr; /* start next allocate from this freed block */      p = next (ptr); /* point to next block */      core(ptr + b.used) = 0; /* this is all it takes */      core(ptr + b.size) = p - ptr; /* force free block size even (by using next) */      if core(p + b.used) = 0 /* if next block is free (control fragmentation) */      then core(ptr + b.size) = core(ptr + b.size) + core(p + b.size); /* coalesce with next */   end free_block;   /* This procedure releases the block pointed to by PTR.  This block   .  is merged with the previous and or next block if it is free to   .  control heap fragmentation.  In particular, ALLOC_HANDLE   .  allocates a block and then frees it if it can't get a handle. */   rel_block: proc(ptr); /* release block PTR */      dcl ptr pointer; /* block to release */      dcl p   pointer;      call free_block (ptr); /* free the block; coalesce with next */      p = prev (ptr); /* point to previous block */      if core(p + b.used) = 0 then do; /* if previous block is free (fails at HEAP_END) */         core(p + b.size) = core(p + b.size) + core(ptr + b.size); /* coalesce previous with this */         heap_free = p; /* start next allocate from this freed block */      end; /* of previous block free */   end rel_block;   /* $subtitle Heap Block Allocation:  Split_Block, Get_Block */   /* This procedure splits a block into two pieces.  It is used when   .  allocating memory. */   split_block: proc(ptr, len); /* split block PTR so first piece has LEN words */      dcl ptr pointer; /* pointer to block to split */      dcl len fixed; /* desired length of first piece of split block */      dcl i   fixed;      i = ((len + 1) and (not 1)); /* force even (round up) */      if core(ptr + b.size) igt i then do; /* if we didn't absorb the entire block */         i = core(ptr + b.size) - i; /* subtract out first part */         core(ptr + b.size) = len; /* split the free block */         ptr = next (ptr); /* point to where the second piece goes */         core(ptr + b.size) = i; /* set length of new block (so NEXT works) */         call free_block (ptr); /* free the block */      end;   end split_block;   /* This procedure gets a free block large enough to hold SIZE words.   .  If no such block exists, a NULL pointer is returned.  Otherwise,   .  a pointer to a block that size is returned. */   get_block: proc(size, end_heap) returns (pointer); /* get a block of SIZE words */      dcl size     fixed; /* size of block to get (including header) */      dcl end_heap pointer; /* end of heap area */      dcl at_end   boolean; /* TRUE when we've reached the end of the list */      dcl p        pointer;      if end_heap = heap_end then do; /* if using entire heap */         p = heap_free; /* start where we last left off */         end_heap = heap_free; /* circle all the way around before stopping */         at_end = false; /* must go through at least once */      end; /* of using entire heap */      else do; /* using partial heap (compacting) */         p = heap_ptr; /* start at beginning of heap */         at_end = (p = end_heap); /* see if it's over before it starts */      end; /* of using partial heap (compacting) */      do while ((not at_end) /* find a free block */      and ((core(p + b.used) <> 0) or (core(p + b.size) ilt size))); /* make sure it's the right size */         p = next (p); /* skip to next block */         at_end = (p = end_heap); /* see if we're at the end */      end;      if not at_end then do; /* if we found one */         call split_block (p, size); /* split the block */         core(p + b.used) = (b$active or b$locked); /* assume it will be used and it's locked */         return (p); /* return pointer to block */      end; /* of we found one */      else return (null); /* no luck */   end get_block;   /* $subtitle Heap Garbage Collection:  Compact */   /* This procedure garbage collects the heap.  The algorithm is a simple   .  compaction scheme (which has the ultimate effect of coalescing all   .  free blocks into one large free block). */   compact: proc; /* compact heap */      dcl free   pointer; /* pointer to top of used storage (start of free) */      dcl ptr    pointer; /* pointer to a free block */      dcl done   boolean; /* TRUE when we're done compacting */      dcl (p, q) pointer;      heap_free = heap_ptr; /* start allocation at beginning of heap (default) */      p = heap_ptr; free = heap_ptr; /* start at beginning of heap */      done = false; /* not done yet */      do while (not done); /* look over entire heap */         done = (p = heap_end); /* we're done when we reach the end */         q = next (p); /* pick up NEXT here in case we invalidate this block */         if core(p + b.used) <> 0 then do; /* if block is in use */            if (core(p + b.used) and b$locked) <> 0 then do; /* if this block is locked */               if p <> free then do; /* if there is free space before this block */                  core(free + b.used) = 0; /* mark it as free */                  core(free + b.size) = p - free; /* save length */                  heap_free = free; /* start allocation at last free block */                  free = p; /* move free pointer up to locked block */               end; /* of free space before this block */            end; /* of locked block */            else do; /* unlocked block - move it if we can */               ptr = get_block (core(p + b.size), free); /* look for a free block before FREE (i.e., between LOCKED blocks) */               if ((ptr <> null) or (p <> free)) then do; /* if free space before this block */                  if ptr = null /* if no free space before FREE */                  then ptr = free; /* we have some at FREE */                  else free = prev (free); /* move FREE back a block so we don't move up below */                  call blockmove (loc(p - b.len), loc(ptr - b.len), core(p + b.size)); /* move the block down */                  call update_handle (p, ptr); /* handle needs to point here now */               end; /* of free space before block */            end; /* of unlocked block */            free = next (free); /* move pointer to free space up */         end; /* of block in use */         p = q; /* point to next block */      end; /* of look over entire list */   end compact;   dump_heap: proc public; /* dump contents of heap */      dcl done boolean; /* TRUE when we're done dumping */      dcl p    pointer;      call dump_handles;      print; print 'start   length  state   [heap]';      p = heap_ptr; done = false; /* not done yet */      do while (not done); /* dump out all blocks */         done = (p = heap_end); /* we're done when we reach the end */         print octal(p), '  ', octal(core(p + b.size)), '  ',;         if core(p + b.used) <> 0 then do;            print 'active',;            if (core(p + b.used) and b$locked) <> 0 then print ' locked',;         end;         else do;            print 'free',;            if p = heap_free then print '    <= heap_free',;         end;         print;         p = next (p); /* look at next block */      end; /* of dumping out all blocks */   end dump_heap;   /* $subtitle Heap Interface:  Clear_Heap, Create_Heap */   /* This procedure releases all blocks of memory. */   clear_heap: proc public; /* free all memory */      core(heap_ptr + b.used) = 0; /* set up free block */      core(heap_ptr + b.size) = heap_end - heap_ptr; /* it's all free (but the last block) */      core(heap_end + b.used) = (b$active or b$locked); /* set up locked block at end so compaction sets up final free block */      core(heap_end + b.size) = b.len; /* only a header here */      heap_free = heap_ptr; /* start searching for free blocks at the heap start */      call clear_handles; /* and clear all handles into the heap */   end clear_heap;   /* This procedure sets up the heap and the handles initially.  If   .  no handles are needed, the handle pointer should be NULL. */   create_heap: proc(heap, size, handles, len) public; /* set up heap */      dcl heap    pointer; /* pointer to heap */      dcl size    fixed; /* size of heap */      dcl handles pointer; /* pointer to handles (or NULL if none) */      dcl len     fixed; /* size of handle area */      heap_ptr = heap + b.len; /* start heap after first record */      heap_end = heap + (size and (not 1)); /* point to end (force size even) */      if handles <> null then do; /* if handles provided */         handle_ptr = handles; /* point to handles */         handle_end = handles + (len and (not 1)); /* point to end (force length even) */      end; /* of handles provided */      call clear_heap; /* initialize heap and handles */   end create_heap;   /* $subtitle Heap Interface:  Allocate, Free, Block_Size */   /* This procedure gets (allocates) a block of SIZE words of free   .  memory.  If there isn't a block large enough, a NULL pointer   .  is returned.  Memory is compacted if necessary. */   allocate: proc(size) returns (pointer) public; /* get a block */      dcl size fixed; /* size of block to get */      dcl p    pointer;      size = size + b.len; /* must include header */      p = get_block (size, heap_end); /* get a block of storage */      if p = null then do; /* if nothing this size */         call compact; /* garbage collect */         p = get_block (size, heap_end); /* try again */      end; /* of nothing this size */      return (p); /* return what we got */   end allocate;   /* This procedure releases (frees) the block pointed to by PTR. */   free: proc(ptr) public; /* release a block */      dcl ptr pointer; /* pointer to block to release */      if ((ptr ige heap_ptr) and (ptr ilt heap_end)) then do; /* check range */         call rel_block (ptr); /* release the block */         call destroy_handle (find_handle (ptr)); /* destroy any handle to it */      end; /* of in range */   end free;   /* This procedure returns the size of a block of memory pointed to   .  by PTR.  A zero is returned for invalid pointers. */   block_size: proc(ptr) returns (fixed) public; /* get size of block PTR */      dcl ptr pointer; /* pointer to block to find size of */      if ((ptr ige heap_ptr) and (ptr ilt heap_end)) /* check range */      then return (core(ptr + b.size) - b.len); /* return user size */      else return (0); /* pointer out of range */   end block_size;   /* $subtitle Heap Interface:  Expand */   /* This procedure expands (or shrinks) a block by LEN words.  A new   .  block is allocated and the data is copied over if necessary. */   expand: proc(ptr, len) returns (pointer) public; /* expand block PTR by LEN words */      dcl ptr pointer; /* pointer to block to expand */      dcl len fixed; /* length to expand block by */      dcl p   pointer;      dcl i   fixed;      if ((ptr ilt heap_ptr) or (ptr ige heap_end)) then return (null); /* check range */      if len < 0 then do; /* shrink */         if abs(len) > core(ptr + b.size) - b.len /* if smaller than block */         then len = -(core(ptr + b.size) - b.len); /* shrink to zero */         if ((len <> 0) and (not core(ptr + b.size))) then do; /* if even size block */            core(ptr + b.size) = core(ptr + b.size) - 1; /* make it odd */            len = len + 1; /* and decrease the required length */         end; /* of even size block */         if len <> 0 /* if we didn't shrink it above */         then call split_block (ptr, core(ptr + b.size) + len); /* just split it up */      end; /* of shrink */      else if len <> 0 then do; /* expand */         if core(ptr + b.size) then do; /* if odd size block */            core(ptr + b.size) = core(ptr + b.size) + 1; /* make it even */            len = len - 1; /* and decrease the required length */         end; /* of odd size block */         if len <> 0 then do; /* if the above check didn't expand it */            p = next (ptr); /* get pointer to next block */            if ((p ilt heap_end) and (core(p + b.used) = 0) /* if next block is free */            and (core(p + b.size) ige len)) then do; /* and it's large enough to hold our expansion */               core(ptr + b.size) = core(ptr + b.size) + len; /* increase list length */               call split_block (p, len); /* split up free block */            end; /* of next block is free */            else do; /* need to get a block */               i = core(ptr + b.used); /* save usage bits */               core(ptr + b.used) = (core(ptr + b.used) or b$locked); /* lock the block */               p = allocate (core(ptr + b.size) - b.len + len); /* allocate a new block */               core(ptr + b.used) = i; /* restore usage bits */               if p <> null then do; /* if we successfully got a block */                  call blockmove (loc(ptr - b.len), loc(p - b.len), core(ptr + b.size)); /* move data to its new location */                  core(p + b.size) = core(p + b.size) + len; /* increase list length (BLOCKMOVE overwrote it) */                  call update_handle (ptr, p); /* handle must now point here */                  call free (ptr); /* release old block (must be last to preserve handle) */               end; /* of got a block */               ptr = p;            end; /* of getting a block */         end; /* of don't have room in this block */      end; /* of expand */      return (ptr); /* return pointer to the new block */   end expand;   /* $subtitle Handle Interface:  Alloc_Handle, Free_Handle */   /* This procedure allocates a block and returns a handle to it.  A NULL   .  is returned if the block cannot be allocated. */   alloc_handle: proc(size) returns (handle) public; /* allocate a block; return a handle to it */      dcl size fixed; /* size of block to get */      dcl ptr  pointer; /* pointer to allocated block */      dcl p    handle; /* handle to allocated block */      ptr = allocate (size); /* get the block */      if ptr <> null then do; /* if we got a block */         core(ptr + b.used) = (core(ptr + b.used) and (not b$locked)); /* not locked if accessed by handle */         p = get_handle (ptr); /* get a handle to the block */         if p = null then call free (ptr); /* free it if no more handles */      end; /* of got a block */      else p = null; /* if no block, no handle */      return (p); /* return the handle */   end alloc_handle;   /* This procedure frees the block referred to by the passed handle. */   free_handle: proc(p) public; /* free block referred to by handle */      dcl p handle; /* handle to block to free */      if p - handle_ptr ilt handle_end - handle_ptr /* if in range */      then call free (core(p + h.ptr)); /* release the block (and handle) */   end free_handle;   /* $subtitle Handle Interface:  Expand_Handle, Handle_Size */   /* This procedure expands the block referred to by the passed handle   .  by LEN words.  A NULL is returned if the block cannot be expanded. */   expand_handle: proc(p, len) returns (handle) public; /* expand block P by LEN words */      dcl p   handle; /* handle to block to expand */      dcl len fixed; /* number of words to expand block by */      if p - handle_ptr ilt handle_end - handle_ptr then do; /* if in range */         if expand (core(p + h.ptr), len) <> null /* try to expand block */         then return (p); /* we succeeded */      end; /* of in range */      return (null); /* unable to expand block */   end expand_handle;   /* This procedure returns the size of a block of memory pointed to   .  by a handle.  A zero is returned for invalid handles. */   handle_size: proc(p) returns (fixed) public; /* get size of block P */      dcl p handle; /* handle to block to find size of */      if p - handle_ptr ilt handle_end - handle_ptr then do; /* if in range */         p = core(p + h.ptr); /* point to associated block */         if p <> null /* if the handle points somewhere */         then return (core(p + b.size) - b.len); /* return user size */      end; /* of in range */      return (0); /* no such handle */   end handle_size;end dynamic_memory;