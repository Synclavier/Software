/* $title TAPELIB  Cartridge Tape I/O Library *//* This set of routines defines the I/O interface to the Kennedy  model 6455 tape cartridge system.  For more information, refer to  Kennedy's Model 6455 Application Notes (spec. # 102-0032-002) and  Kennedy's Model 6455 Operation and Maintenance Manual (spec. #  006-0002-001).  NOTE:  Any program which inserts these routines must call INIT_TAPE         before any other routines in this library.  By:  Karim J. Chichakly on 15 June 1983  Language:  Scientific XPL  Modified:    27 Feb 86: Altered for coexistence w/SCSI tape drives [KJC]*/module tape_IO;configuration modelC, noMULDIV; /* must use model B or later */insert ':-xpl:literals';insert ':-xpl:tapeface'; /* get tape interface library */dcl last_track lit '3'; /* last track on tape drive *//* GLOBAL variables: */dcl tape_operation fixed external; /* global tape operation */dcl tape_status    fixed external; /* global tape status */tape_status = 0; /* initialize the tape status so we think we're at the LLP */dcl retries_enabled boolean; /* TRUE if retries are enabled */retries_enabled = true; /* default to enabled *//* This procedure enables retries after errors. */k#enable_retries: proc public; /* enable tape retries */   retries_enabled = true;end k#enable_retries;/* This procedure disables retries after errors. */k#disable_retries: proc public; /* disable tape retries */   retries_enabled = false;end k#disable_retries;/* $subtitle Read The Cartridge Tape Drive Status *//* This procedure reads the status from the cartridge tape unit and  stores that status in a full word fixed point quantity arranged  as follows:        MSB (most  significant byte):  Position Status from drive        LSB (least significant byte):  Summary Status from drive  The status is stored in the global variable TAPE_STATUS. */k#read_status: proc public;   dcl summary  fixed; /* summary status from drive */   dcl position fixed; /* position status from drive */   dcl retry    fixed; /* retry counter */   if retries_enabled /* are retries enabled? */   then retry = 0; /* yes, try RETRY_MAX times */   else retry = retry_max - 1; /* no, only go through once */   summary = -1; /* initialize statuses to garbage */   position = -1;   do while ((retry < retry_max) and ((summary < 0) or (position < 0)));      if not send_command (sense_status) /* send the status command */      then do; /* the command bombed out */         print 'Invalid command ', octal(sense_status), ' issued in k#read_status.';         call exit(-1); /* terminate our existence */      end;      summary = receive_argument; /* get the summary status */      position = receive_argument; /* and the position status */      if ((summary = no_cbsy) or (position = no_cbsy)) /* command rejected? */      then do; /* not accepted by formatter */         print 'Tape drive formatter did not accept sense status command.';         call exit(-1);      end;      retry = retry + 1; /* count the retries */   end;   if ((retry >= retry_max) and ((summary < 0) or (position < 0)))   then do; /* did we retry too many times? */      print 'Parity error reading tape drive formatter status.';      call exit(-1);   end;   position = shl(shl(position and "3", 4) or shr(position, 4), 8); /* swap position nibbles to more closely match SCSI */   position = ((position and (track_mask or end_of_tape or write_protect))   or shr(position and file_mark, 2) or shl(position and load_point, 2)); /* swap filemark and load point to match SCSI */   tape_status = (position or summary); /* compute and store the full word status */end k#read_status;/* $subtitle Decode The Status Into Known Logical Errors *//* This routine decodes the status word into a word which defines logical  errors which are easily handled by a do case statement.  The format of  this word is:    MSB:  Position status byte from tape drive    LSB:  Decoded status byte (defined in TAPELITS)  The device status (as returned by k#read_status) is stored in the global  variable TAPE_STATUS.  To decode that status into something more  meaningful to your program:    length = read_tape (buffer, length);         issue read command    do case (decode_status and status_mask);    do something different for each different status       ; case 0       ; case 1                                  remember the tape position is in the MSB       .       .       .       ;case n    end;  This routine accesses the global variable TAPE_STATUS.  The decoded  status is returned. */k#decode_status: proc fixed public;   dcl status    fixed; /* the decoded status */   dcl s_byte    fixed; /* the status byte (from TAPE_STATUS) */   dcl op_status fixed; /* the status from the operation (TAPE_STATUS on entry) */   s_byte = (tape_status and status_mask); /* extract the status byte from the tape status */   if s_byte = 0 /* any errors? */   then status = s#no_error; /* no errors */   else   if s_byte = not_ready /* just powered up? */   then status = s#not_ready;   else   if s_byte = (not_ready or drive_fault) /* possible drive fault? */   then do; /* yes, make sure */      op_status = tape_status; /* preserve the device status */      call k#read_status; /* by reading the status again */      if (tape_status and drive_fault) <> 0 /* is there still a drive fault? */      then status = s#drive_fault; /* yes, this is serious */      else status = s#broken_tape; /* no, the tape must be broken or off the reel */      tape_status = op_status; /* retrieve the device status */   end;   else   if s_byte = (not_ready or command_error) /* is the tape not loaded? */   then status = s#not_loaded;   else   if (s_byte and (not_ready or no_cartridge)) = (not_ready or no_cartridge) /* no cartridge? */   then status = s#no_cartridge;   else   if (s_byte and parity_error) <> 0 /* parity error? */   then status = s#parity_error;   else   if (s_byte and data_error) <> 0 /* data error? */   then status = s#data_error;   else   if s_byte = (not_ready or formatter_error) /* self-test failure? */   then status = s#inoperative;   else   if s_byte = command_error /* command error? */   then do; /* yes, find out what type */      if (((tape_status and end_of_tape) <> 0) and (tape_operation = read_record)) /* no data before leot? */      then status = s#no_data;      else      if (tape_status and write_protect) <> 0 /* write protected? */      then status = s#write_protected;      else status = s#unknown;   end;   else status = s#unknown; /* unknown error */   return (status or (tape_status and position_mask));end k#decode_status;/* $subtitle Load A Tape Cartridge *//* This procedure loads a cartridge onto the cartridge tape drive.  Basically, we ensure the tape cartridge is inserted and that the  drive is not ready.  We then issue the load command and wait for  the drive to come ready.  The load status is stored in the global  variable TAPE_STATUS. */k#load: proc public;   dcl retry  fixed; /* retry counter */   dcl i      fixed; /* dummy input variable */   dcl loaded boolean; /* set to true when the drive is loaded */   if not reset_tape /* reset the tape drive */   then do; /* can't reset it */      print 'Cannot LOAD tape - check the cable from the computer to the tape';      print 'drive unit and make sure the tape drive unit is turned on.';      call exit(-1);   end;   call k#read_status; /* read the device status */   do while ((tape_status and no_cartridge) <> 0); /* can't load without a cartridge */      print 'Insert tape cartridge in tape drive unit and press return ',;      input i;      call k#read_status; /* get the device status */   end;   if (tape_status and not_ready) <> 0 /* make sure the drive isn't ready */   then do; /* it isn't - issue the load */      loaded = false; /* the tape drive is not loaded */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      do while ((retry < retry_max) and (not loaded));         if send_command (load_tape) /* send the load command */         then call k#read_status; /* read the drive status (and wait for command to complete) */         retry = retry + 1; /* count number of times we retry */         loaded = (((tape_status and not_ready) = 0) and ((tape_status and load_point) <> 0));      end;   end;end k#load;/* $subtitle Unload A Tape Cartridge *//* This procedure unloads a cartridge from the tape cartridge unit.  Once it is ensured that the drive is ready, an unload command is  issued.  We do NOT wait for the unload to finish, we do NOT check  the unload status or retry if an error occurred, and we do NOT  update the global variable TAPE_STATUS to the unload status.  The global variable TAPE_STATUS is updated to the tape drive  status BEFORE the unload. */k#unload: proc public;   dcl retry fixed; /* retry counter */   if retries_enabled /* are retries enabled? */   then retry = 0; /* yes, try up to RETRY_MAX times */   else retry = retry_max - 1; /* no, try only once */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do while ((not send_command (unload_tape)) and (retry < retry_max)); /* it is - issue the unload */      retry = retry + 1; /* count the retries */   end;end k#unload;/* $subtitle Rewind A Tape Cartridge *//* This procedure rewinds a tape cartridge to the logical load point of  track zero.  The rewind status is stored in the global variable  TAPE_STATUS. */k#rewind: proc public;   dcl retry  fixed; /* retry counter */   call k#read_status; /* get the tape drive status */   if (tape_status and not_ready) = 0 /* is the tape drive ready? */   then do; /* yes, rewind the tape */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      do while ((retry < retry_max) and (((tape_status and load_point) = 0) or ((tape_status and track_mask) <> 0)));         if send_command (rewind_tape) /* send the rewind command */         then call k#read_status; /* read the drive status (and wait for command to finish) */         retry = retry + 1; /* count number of times we retry */      end;   end;   else call k#load; /* if not ready, load the tape so TAPESEEK works */end k#rewind;/* $subtitle Select A Specific Track On A Tape Cartridge *//* This procedure moves the tape to either the logical load point or the  logical end of tape of the selected track.  It is passed two parameters:  TRACK (the selected track) and LOGICAL_EOT (TRUE or LEOT if the tape  should be positioned at the logical end-of-tape of that track; FALSE  or LLP if the tape should be positioned at the logical load point).  The select status is stored in the global variable TAPE_STATUS. */k#select: proc(track, logical_eot) public;   dcl track          fixed; /* the track to select */   dcl logical_eot    boolean; /* TRUE if the tape should be positioned at LEOT */   dcl selected_track fixed; /* SELECT_TRACK argument */   dcl retry          fixed; /* number of times we've retried */   dcl positioned     boolean; /* true only if we're positioned properly */   call k#read_status; /* get the device status */   if (tape_status and not_ready) = 0 /* is the drive ready? */   then do; /* yes, select the track */      if logical_eot /* should we position at the logical end-of-tape? */      then selected_track = (track or select_leot); /* yes, set the leot bit */      else selected_track = track; /* no, don't set the leot bit */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      positioned = false; /* we're not at the right spot yet */      do while ((retry < retry_max) and (not positioned));         if send_command (select_track) /* send the select track command */         then do; /* the command was accepted */            if send_argument (selected_track) /* send the selected track */            then call k#read_status; /* read the status and wait for command to complete */         end;         retry = retry + 1; /* count number of times we retry */         positioned = ((shr(tape_status and track_mask, track_shift) = track) /* check track */                and ((((tape_status and load_point)  <> 0) and (not logical_eot)) /* check position on track */                or   (((tape_status and end_of_tape) <> 0) and logical_eot)));      end;   end;end k#select;/* $subtitle Forward Space One Record *//* This procedure forward spaces the tape one record from the current  position.  The forward space status is stored in the global variable  TAPE_STATUS. */k#forward_space: proc public;   dcl track  fixed; /* the current track */   dcl status fixed; /* tape drive status */   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE when we're done */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't tried yet */      do while ((retry < retry_max) and (not done));         if send_command (forward_space_tape) /* send the forward space command */         then do; /* it was accepted */            call k#read_status; /* get the status */            if ((tape_status and (status_mask or end_of_tape)) = (command_error or end_of_tape))            then do; /* we're at the end of the track */               track = shr(tape_status and track_mask, track_shift); /* get the current track number */               if track = last_track /* are we at the physical end-of-tape? */               then done = true; /* yes, we're done here */               else do; /* no, move to the next track */                  status = tape_status; /* preserve the tape status */                  call k#select (track + 1, llp); /* move to the next track */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* select failed - abort retry */                  else retry = retry - 1; /* don't count this as a retry */                  tape_status = status; /* restore the tape status */               end;            end;            else done = true; /* we're done now */         end;         retry = retry + 1; /* count the number of times we retry */      end;   end;end k#forward_space;/* $subtitle Reverse Space One Record *//* This procedure reverse spaces the tape one record from the current  position.  The reverse space status is stored in the global variable  TAPE_STATUS. */k#reverse_space: proc public;   dcl track  fixed; /* the current track */   dcl status fixed; /* the tape drive status */   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE when we're done */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't tried yet */      do while ((retry < retry_max) and (not done));         if send_command (reverse_space_tape) /* send the reverse space command */         then do; /* it was accepted */            call k#read_status; /* get the status */            if ((tape_status and (status_mask or load_point)) = (command_error or load_point))            then do; /* we're at the beginning of the track */               track = shr(tape_status and track_mask, track_shift); /* get the current track number */               if track = 0 /* are we at the physical beginning-of-tape? */               then done = true; /* yes, we're done here */               else do; /* no, move to the previous track */                  status = tape_status; /* preserve the tape status */                  call k#select (track - 1, leot); /* move to the previous track */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* select failed - abort retry */                  else retry = retry - 1; /* don't count this as a retry */                  tape_status = status; /* restore the tape status */               end;            end;            else done = true; /* we're done now */         end;         retry = retry + 1; /* count the number of times we retry */      end;   end;end k#reverse_space;/* $subtitle Forward Space One File *//* This procedure forward spaces the tape one file from the current  position.  The forward space file status is stored in the global  variable TAPE_STATUS. */k#forward_file: proc public;   dcl track  fixed; /* the current track */   dcl status fixed; /* the tape drive status */   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE when we're done */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't tried yet */      do while ((retry < retry_max) and (not done));         if send_command (forward_space_file) /* send the forward space file command */         then do; /* it was accepted */            call k#read_status; /* get the status */            if (((tape_status and end_of_tape) <> 0) and ((tape_status and file_mark) = 0))            then do; /* we're at the end of the track and we didn't find a filemark */               track = shr(tape_status and track_mask, track_shift); /* get the current track number */               if track = last_track /* are we at the physical end-of-tape? */               then done = true; /* yes, we're done here */               else do; /* no, move to the next track */                  status = tape_status; /* preserve the tape status */                  call k#select (track + 1, llp); /* move to the next track */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* select failed - abort retry */                  else retry = retry - 1; /* don't count this as a retry */                  tape_status = status; /* restore the tape status */               end;            end;            else done = true; /* we're done now */         end;         retry = retry + 1; /* count the number of times we retry */      end;   end;end k#forward_file;/* $subtitle Reverse Space One File *//* This procedure reverse spaces the tape one file from the current  position.  The reverse space file status is stored in the global  variable TAPE_STATUS. */k#reverse_file: proc public;   dcl track  fixed; /* the current track */   dcl status fixed; /* the tape drive status */   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE when we're done */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't tried yet */      do while ((retry < retry_max) and (not done));         if send_command (reverse_space_file) /* send the reverse space file command */         then do; /* it was accepted */            call k#read_status; /* get the status */            if (((tape_status and load_point) <> 0) and ((tape_status and file_mark) = 0))            then do; /* we're at the beginning of the track and didn't find a filemark */               track = shr(tape_status and track_mask, track_shift); /* get the current track number */               if track = 0 /* are we at the physical beginning-of-tape? */               then done = true; /* yes, we're done here */               else do; /* no, move to the previous track */                  status = tape_status; /* preserve the tape status */                  call k#select (track - 1, leot); /* move to the previous track */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* select failed - abort retry */                  else retry = retry - 1; /* don't count this as a retry */                  tape_status = status; /* restore the tape status */               end;            end;            else done = true; /* we're done now */         end;         retry = retry + 1; /* count the number of times we retry */      end;   end;end k#reverse_file;/* $subtitle Erase To End-Of-Tape *//* This procedure erases the current track of the tape from the current  position to the logical end-of-tape.  The erase status is stored in  the global variable TAPE_STATUS. */k#erase: proc public;   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE when we're done */   call k#read_status; /* read the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't tried yet */      do while ((retry < retry_max) and (not done));         if send_command (erase_tape) /* send the erase command */         then do; /* it was accepted */            call k#read_status; /* get the status */            done = true; /* we're done now */         end;         retry = retry + 1; /* count the number of times we retry */      end;   end;end k#erase;/* $subtitle Read A Record From Tape *//* This procedure reads a record from tape at the current tape position and  on the current track.  If the tape is positioned past the last record on  the current track, this routine will read the first record of the next  track (if possible).  Two parameters are passed:  BUFFER (where to read  in the record) and LENGTH (number of words to read).  The number of words  read is returned.  The read status is stored in the global variable  TAPE_STATUS. */k#read_tape: proc(buffer, length) fixed public;   dcl buffer fixed array; /* where to read in the record */   dcl length fixed; /* number of words to read */   dcl words  fixed; /* number of words actually read */   dcl track  fixed; /* the current track */   dcl status fixed; /* status of the read operation */   dcl retry  fixed; /* retry counter */   dcl done   boolean; /* set TRUE if we're done */   call k#read_status; /* get the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      words = 0; /* no words have been written yet */      done = false; /* haven't even started yet */      do while ((retry < retry_max) and (not done)); /* loop until we're done */         if send_command (read_record) /* send the read command */         then do; /* it was successful */            words = receive_record (buffer, length); /* read the record into the buffer */            call k#read_status; /* get the status */            status = tape_status; /* preserve the read status */            if (status and (status_mask or end_of_tape)) = (command_error or end_of_tape) /* is there a record here? */            then do; /* no, move to the next track if possible */               track = shr(status and track_mask, track_shift); /* get the track number */                           if track = last_track /* are we at the physical end-of-tape? */               then done = true; /* yes, consider the task done */               else do; /* no, select the load point of the next track */                  call k#select (track + 1, llp); /* like so */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* select failed - abort retry */                  else retry = retry - 1; /* don't count this as a retry */               end;            end; /* of end-of-tape */            else if (((words < length) or ((tape_status and (parity_error or data_error)) <> 0)) and (retry < retry_max - 1))            then do; /* there was an error - reverse space and try again */               if words <> 0 /* if no words transferred then don't reverse */               then do; /* some words were transferred */                  call k#reverse_space; /* reverse space */                  if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                  then done = true; /* the reverse failed - abort the retry */               end;            end;            else done = true; /* no, we transferred the block with no errors (or ran out of retries) */            tape_status = status; /* replace the read status in the global */         end;         retry = retry + 1; /* try again */      end;   end;   return (words); /* return the number of words read */end k#read_tape;/* $subtitle Write A Record To Tape *//* This procedure writes a record to tape at the current tape position and  on the current track.  If there isn't enough room on the current track to  write the record, this routine will attempt to write the record at the  start of the next track.  Two parameters are passed:  BUFFER (the record  to write) and LENGTH (number of words to write).  The number of words  written is returned.  The write status is stored in the global variable  TAPE_STATUS. */k#write_tape: proc(buffer, length) fixed public;   dcl buffer  fixed array; /* the record to write */   dcl length  fixed; /* number of words to write */   dcl words   fixed; /* number of words actually written */   dcl command fixed; /* command to send */   dcl track   fixed; /* current track */   dcl status  fixed; /* status from the write operation */   dcl retry   fixed; /* retry counter */   dcl done    boolean; /* set TRUE if we're done */   command = write_record; /* don't start with a write extended */   words = 0; /* no words have been written yet */   /* $page */   call k#read_status; /* get the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't even started yet */      do while ((retry < retry_max) and (not done)); /* no, loop until we're done */         track = shr(tape_status and track_mask, track_shift); /* extract the track number */         if ((track = last_track) and ((tape_status and end_of_tape) <> 0)) /* are we past the end of tape? */         then do; /* yes, stop here */            tape_status = (tape_status or command_error); /* set command error */            done = true; /* we're done now */         end;         else /* no, issue command */         if send_command (command) /* send the write command */         then do; /* the command was accepted */            words = send_record (buffer, length); /* send the buffer to tape */            call k#read_status; /* read the status from the command */            if ((((words < length) or ((tape_status and (parity_error or data_error)) <> 0)) and (retry < retry_max - 1))            or (((tape_status and end_of_tape) <> 0) and (track <> last_track))) /* retry unconditionally at the logical end-of-tape */            then do; /* there was an error - prepare for retry */               status = tape_status; /* remember the write status */               if words <> 0 /* make sure some words were written before reversing */               then call k#reverse_space; /* reverse space so we can clean up and try again */               else tape_status = 0; /* no reverse, so no errors */               if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))               then done = true; /* the reverse space failed - abort the retry */               else do; /* the reverse space succeeded */                  if (status and end_of_tape) <> 0 /* are we at the logical end-of-tape? */                  then do; /* yes, treat this specially */                     call k#erase; /* erase to end-of-tape (this better work) */                     if (((tape_status and parity_error) <> 0) or ((tape_status and data_error) <> 0))                     then print '*** Warning:  Unable to erase faulty record at end of tape.  Replace your tape.';                     if track = last_track /* are we at the physical end-of-tape? */                     then done = true; /* yes, consider the task done */                     else do; /* no, select the load point of the next track */                        call k#select (track + 1, llp); /* like so */                        if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                        then done = true; /* select failed - abort retry */                        else do; /* select succeeded */                           command = write_record; /* don't write the next record extended */                           retry = retry - 1; /* don't count this as a retry */                        end;                     end;                  end;                  else do; /* no, we're somewhere in the middle of the tape */                     if (status and parity_error) <> 0 /* was this a parity error? */                     then command = write_record; /* yes, just retransmit the record */                     else command = write_extended; /* no, there's a bad spot on the tape */                  end;               end;               tape_status = status; /* place the write status back in the global */            end;            else done = true; /* we transferred it successfully */         end;         retry = retry + 1; /* try again */      end;   end;   return (words); /* return the number of words written */end k#write_tape;/* $subtitle Write An Extended Record To Tape (with NO retries) *//* This procedure write extends the passed record to tape at the current  tape position and on the current track.  No retries are performed.  This  procedure is necessary because the directory must be written extended  with no retries.  It is passed two parameters:  BUFFER (the directory  buffer) and LENGTH (the length to write).  The number of words written  is returned.  The write extended status is stores in the global variable  TAPE_STATUS. */k#write_tapex: proc(buffer, length) fixed public;   dcl buffer fixed array; /* the buffer to write */   dcl length fixed; /* the number of words to write */   dcl words  fixed; /* number of words written */   dcl track  fixed; /* the current track number */   dcl retry  fixed; /* retry counter */   words = 0; /* initialize number of words written */   call k#read_status; /* get the device status */   if (tape_status and not_ready) = 0 /* ensure the drive is ready */   then do; /* it's ready */      track = shr(tape_status and track_mask, track_shift); /* extract the track number */      if ((track = last_track) and ((tape_status and end_of_tape) <> 0)) /* are we past the end of tape? */      then tape_status = (tape_status or command_error); /* yes, set command error */      else do; /* no, perform the write */         if retries_enabled /* are retries enabled? */         then retry = 0; /* yes, try up to RETRY_MAX times */         else retry = retry_max - 1; /* no, try only once */         do while ((not send_command (write_extended)) and (retry < retry_max));            retry = retry + 1; /* retry handshaking errors */         end;         words = send_record (buffer, dir_size); /* send the record */               call k#read_status; /* and get the write status */      end;   end;   return (words); /* return the number of words written */end k#write_tapex;/* $subtitle Write A Filemark To Tape *//* This procedure writes a filemark to the tape at the current tape position  and on the current track.  If there isn't enough space at the end of the  current track, this routine will attempt to write the filemark at the  beginning of the next track.  One parameter is passed:  EXTENDED (TRUE  if the filemark should be written extended).  The write filemark status  is stored in the global variable TAPE_STATUS. */k#write_filemark: proc(extended) public;   dcl extended boolean; /* if TRUE always write extended */   dcl command  fixed; /* command to send */   dcl track    fixed; /* current track */   dcl status   fixed; /* write filemark status */   dcl retry    fixed; /* retry counter */   dcl done     boolean; /* set TRUE if we're done */   if extended /* should we write the filemark extended? */   then command = write_fmx; /* yes */   else command = write_file_mark; /* no, don't start with a write filemark extended */   /* $page */   call k#read_status; /* get the device status */   if (tape_status and not_ready) = 0 /* make sure the drive is ready */   then do; /* it is */      if retries_enabled /* are retries enabled? */      then retry = 0; /* yes, try up to RETRY_MAX times */      else retry = retry_max - 1; /* no, try only once */      done = false; /* haven't even started yet */      do while ((retry < retry_max) and (not done)); /* no, loop until we're done */         track = shr(tape_status and track_mask, track_shift); /* extract the track number */         if ((track = last_track) and ((tape_status and end_of_tape) <> 0)) /* are we past the end of tape? */         then do; /* yes, stop here */            tape_status = (tape_status or command_error); /* set command error */            done = true; /* we're done now */         end;         else /* no, issue write filemark command */         if send_command (command) /* send the write filemark command */         then do; /* the command was accepted */            call k#read_status; /* read the status from the command */            if ((((tape_status and (parity_error or data_error)) <> 0) and (retry < retry_max - 1)) /* was there an error? */            or ((tape_status and end_of_tape) <> 0)) /* retry unconditionally at the logical end-of-tape */            then do; /* yes, prepare for retry */               status = tape_status; /* remember the write filemark status */               call k#reverse_space; /* reverse space so we can clean up and try again */               if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))               then done = true; /* the reverse space failed - abort the retry */               else do; /* the reverse space succeeded */                  if (status and end_of_tape) <> 0 /* are we at the logical end-of-tape? */                  then do; /* yes, treat this specially */                     call k#erase; /* erase to end-of-tape */                     if (((tape_status and parity_error) <> 0) or ((tape_status and data_error) <> 0))                     then print '*** Warning:  Unable to erase faulty filemark at end of tape.  Replace your tape.';                     track = shr(status and track_mask, track_shift); /* get the track number */                                          if track = last_track /* are we at the physical end-of-tape? */                     then done = true; /* yes, consider the task done */                     else do; /* no, select the load point of the next track */                        call k#select (track + 1, llp); /* like so */                        if (((tape_status and command_error) <> 0) or ((tape_status and not_ready) <> 0))                        then done = true; /* select failed - abort retry */                        else do; /* select succeeded */                           if not extended /* so if this isn't supposed to be an extended filemark */                           then command = write_file_mark; /* then don't make it one */                           retry = retry - 1; /* don't count this as a retry */                        end;                     end;                  end;                  else command = write_fmx; /* no, there's a bad spot on the tape */               end;               tape_status = status; /* restore the write filemark status into the global */            end;            else done = true; /* we successfully wrote the filemark */         end;         retry = retry + 1; /* try again */      end;   end;end k#write_filemark;end tape_IO;