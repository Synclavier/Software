/* Dynamic memory allocation simulator by Karim J. Chichakly */when break then call exit(-1);dcl seed fixed; seed = 7; /* originally long seed = 7L; */insert ':-xpl:dynamic';dcl dump_heap proc external;dcl random    proc;dcl rnd       proc(fixed) returns (fixed);dcl psize lit '256';dcl hsize lit '20';dcl heap (psize - 1) fixed;dcl hand (hsize - 1) fixed;dcl h      handle;dcl p      pointer;dcl (i, j) fixed;call create_heap (addr(heap (0)), psize, addr(hand (0)), hsize);print 'Dynamic Memory Allocation Simulator';print;print 'Press RETURN to start simulation ->',;do while ((read("51") and "2") = 0); /* wait for input */   call random; /* use up a random number */   write(3) = 0; /* wait one D3 tick */end;print;do i = 1 to 100; /* loop 100 times */   if rnd (100) >= 97 then call allocate (rnd (10) + 1); /* toss in a random locked block (3%) */   do case (rnd (3)); /* decide what operation to perform */      do; /* allocate */         j = rnd (50) + 1; /* get size */         h = alloc_handle (j); /* allocate it */         if h <> null         then print 'Allocated ', octal(j), ' words:  ', octal(h);      end;      do; /* free */         j = (rnd (hsize) and (not 1));         if hand (j) <> null then do;            print 'Freeing handle ', octal(addr(hand (j)));            call free_handle (addr(hand (j)));            h = -1;         end;         else h = null;      end;      do; /* expand */         j = (rnd (10) + 1)*(shl(rnd (2) + 1, 1) - 3); /* last part is +1 or -1 */         h = expand_handle (addr(hand (rnd (hsize) and (not 1))), j);         if h <> null then do;            if j < 0 then print 'Shrunk',; else print 'Expanded',;            print ' block ', octal(h), ' by ', octal(abs (j)), ' words';         end;      end;   end; /* of DO CASE */   if h <> null then do;      call dump_heap; input j;   end;end; /* of looping */call dump_heap;random: proc; /* originally long random (size); */   dcl a lit '25173'; /* originally 25173L */   dcl c lit '13849'; /* originally 13849L */   write(5) = a; /* seed = seed*a + c; */   write(4) = c;   write(6) = seed;   seed = read(5); /* use D4567 directly so it's unsigned */   return (seed); /* SIZE = 65536 */end random;rnd: proc(range); /* return a number between zero and RANGE - 1 */   dcl range fixed;   write(5) = random; /* get next random number */   write(7) = range; /* unsigned division */   return (read(4)); /* return remainder */end rnd;