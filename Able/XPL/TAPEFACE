/* $title TAPEFACE  Cartridge Tape Interface Library *//* This set of routines defines the hardware interface to the Kennedy  model 6455 tape cartridge system.  For more information, refer to  Kennedy's Model 6455 Application Notes (spec. # 102-0032-002),  Kennedy's Model 6455 Operation and Maintenance Manual (spec. #  006-0002-001), and Kennedy's Pico Formatter Interface Definition  (spec. # 102-7002-001).  On May 23, 1984, all routines were altered to poll the D30 TWICE  before deciding CBSY has been denied (during a read or write operation).  This is to compensate for a noise spike that occurs on the CBSY line.  NOTE:  These routines cannot be used on a model A processor.  By:    Karim J. Chichakly on 14 June 1983  Language:  Scientific XPL   GLOBAL data */module tape_interface;configuration modelC, noMULDIV; /* compile for the model B processor */insert ':-xpl:literals';insert ':-xpl:tapelits'; /* get tape literals */dcl tape_operation   fixed external; /* last tape operation performed */dcl odd_parity (255) fixed; /* parity lookup table *//* $subtitle Initialize Parity Lookup Table *//* This routine initializes the parity lookup table for odd parity.  The parity table entry for a given byte (where the value of the  byte is the index into the lookup table) is the high true logic  value of that byte's parity bit.  Parity is defined as the sum  of bits "on" in a byte and odd parity refers to an odd number  of bits "on" always (the parity bit is set to enforce this).  For an odd number of bits then, the parity bit should be "off"  (or a "0" in high true logic) and for an even number of bits,  the parity bit should be "on" (a "1" in high true logic). */dcl bits   fixed; /* number of bits "on" in this byte */dcl temp   fixed; /* a temporary used to shift bits over */dcl (i, j) fixed;write(r0) = 12345; /* check for model B processor */write("HB0") = 0; /* IM(0) to BSOR0 */if read(r0) <> rot(12345, 8) /* model A doesn't have a BSOR instruction */then do; /* this must be a model A */   print 'Cannot use the tape cartridge unit with a model A processor.';   call exit(-1); /* abort */end;do i = 0 to 255; /* determine parity for all 8-bit combinations */   bits = 0; /* no bits "on" yet */   temp = i; /* set temporary to the pattern we're examining */   do j = 1 to 8; /* check all eight bits */      if (temp and "H01") = 1 /* is this bit "on" (high true) */      then bits = bits + 1; /* yes, count the bits "on" */      temp = shr(temp, 1); /* look at next bit */   end;   if (bits and "H01") = 0 /* is the number of bits even? */   then odd_parity (i) = (i or "H100"); /* yes, need the parity bit set for odd parity */   else odd_parity (i) = i; /* no, it's odd */end;/* $subtitle Send A Command Byte To The Formatter *//* This procedure sends a command byte to the formatter using the  handshaking protocol described in the Pico Formatter Interface  Definition (it's also described in all the tape cartridge manuals).  The algorithm proceeds as follows:     1. Wait for CBSY to be denied.     2. Place the command byte on the data bus.     3. Assert CREQ.     4. Wait for CBSY or STRB to be asserted.     5. Wait for STRB to be asserted.     6. Deny CREQ.     7. Remove the command byte from the data bus.     8. Wait for STRB to be denied.  If CBSY is never asserted, the command is invalid and a boolean  FALSE is returned by this routine.  Otherwise, a boolean TRUE is  returned. */send_command: proc(command) boolean public;   dcl command fixed; /* the command to send */   dcl state   fixed; /* the machine's state when this routine is entered */   dcl valid   boolean; /* set TRUE if the command was valid */   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   if command <> sense_status /* if this isn't a status command */   then tape_operation = command; /* save the command type for error processing */   command = odd_parity (command and data_mask); /* ensure no command signals are set and set the parity */   do while (((read(tape_drive) or read(tape_drive)) and cbsy) <> 0);      /* 1. wait for CBSY to be denied */   end;   write(tape_drive) = command; /* 2. put command on the data bus */   write(tape_drive) = (command or creq); /* 3. assert CREQ */   do while (((read(tape_drive) or read(tape_drive)) and (cbsy or strb)) = 0);      /* 4. wait for CBSY or STRB to be asserted */   end;   if ((read(tape_drive) or read(tape_drive)) and cbsy) <> 0 /* was CBSY asserted? */   then do; /* yes, this was a valid command */      valid = true; /* remember this was a valid command */      do while ((read(tape_drive) and strb) = 0);         /* 5. wait for STRB to be asserted */      end;   end;   else valid = false; /* remember this wasn't a valid command */   write(tape_drive) = command; /* 6. deny CREQ */   write(tape_drive) = idle; /* 7. remove the command byte */   do while ((read(tape_drive) and strb) <> 0);      /* 8. wait for STRB to be denied */   end;   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (valid); /* return the status */end send_command;/* $subtitle Send An Argument Byte To The Formatter *//* This procedure sends an argument byte to the formatter using  the handshaking protocol described in the Pico Formatter Interface  Definition.  The algorithm proceeds as follows:     1. Assure CBSY is asserted.     2. Place the argument byte on the data bus.     3. Assert CREQ.     4. Wait for STRB to be asserted.     5. Deny CREQ.     6. Remove the argument byte from the data bus.     7. Wait for STRB to be denied.  If CBSY is not asserted upon entry to this routine, a boolean FALSE  is returned.  Otherwise, a boolean TRUE is returned. */send_argument: proc(argument) boolean public;   dcl argument fixed; /* the argument to send */   dcl state    fixed; /* the machine's state upon entering this routine */   dcl no_error boolean; /* set TRUE if CBSY is asserted upon entry */   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   argument = odd_parity (argument and data_mask); /* ensure no command signals are set and set parity */   if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* 1. is CBSY asserted? */   then no_error = false; /* no, this is an error */   else do; /* yes, send the byte */      no_error = true; /* the byte is being sent */      write(tape_drive) = argument; /* 2. put argument on the data bus */      write(tape_drive) = (argument or creq); /* 3. assert CREQ */      do while ((read(tape_drive) and strb) = 0);         /* 4. wait for STRB to be asserted */      end;      write(tape_drive) = argument; /* 5. deny CREQ */      write(tape_drive) = idle; /* 6. remove the argument byte */      do while ((read(tape_drive) and strb) <> 0);         /* 7. wait for STRB to be denied */      end;   end;   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (no_error); /* return the status */end send_argument;/* $subtitle Receive An Argument Byte From The Formatter *//* This procedure receives an argument byte from the formatter using  the handshaking protocol described in the Pico Formatter Interface  Definition.  The algorithm proceeds as follows:     1. Assure CBSY is asserted.     2. Assert CREQ.     3. Wait for STRB to be asserted.     4. Read the argument byte from the data bus.     5. Deny CREQ.     6. Wait for STRB to be denied.  The argument byte is returned.  If a parity error was encountered,  the returned word will be negative.  If CBSY isn't asserted when  this routine is entered, the least significant bit in the upper  byte of the returned word (NO_CBSY) will be the only bit set in  the returned word. */receive_argument: proc fixed public;   dcl argument fixed; /* the received argument */   dcl state    fixed; /* the machine state upon entry */   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* 1. make sure CBSY is asserted */   then argument = no_cbsy; /* it isn't - don't attempt the read */   else do; /* it's asserted - read the argument byte */      write(tape_drive) = creq; /* 2. assert CREQ */      do while ((read(tape_drive) and strb) = 0);         /* 3. wait for STRB to be asserted */      end;      argument = (read(tape_drive) and data_parity); /* 4. read the argument byte */      write(tape_drive) = idle; /* 5. deny CREQ */      if odd_parity (argument and data_mask) = argument /* check the parity */      then argument = (argument and data_mask); /* no parity error, return positive result */      else do; /* parity error */         if argument = 0 /* make sure the result is negative */         then argument = sign_bit; /* just set the sign bit */         else argument = -(argument and data_mask); /* return negative result */      end;      do while ((read(tape_drive) and strb) <> 0);         /* 6. wait for STRB to be denied */      end;   end;   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (argument); /* return the received argument */end receive_argument;/* $subtitle Send A Data Record To The Formatter *//* This procedure sends a data record to the formatter using the  handshaking protocol described in the Pico Formatter Interface  Definition.  The algorithm proceeds as follows:     1. Assure CBSY is asserted.     2. Extract first word.     3. Write first byte and assert DRDY.     4. Loop until all data words are written.        a. Wait until STROBE is set (STRB is asserted).        b. Place next data byte (MSB) on the data bus and assert DRDY (and clear STROBE).        c. Extract next word.        d. Wait until STROBE is set (STRB is asserted).        e. Place next data byte (LSB) on data bus and assert DRDY (and clear STROBE).     5. Place last data byte on the data bus and assert DRDY.     6. Wait until STROBE is set (STRB is asserted).     7. Deny DRDY.  Two parameters are passed:  BUFFER (the record to write) and LENGTH  (number of words to write).  BUFFER is arranged such that the least  significant byte preceeds the most significant (in ascending order).  The number of words transferred is returned.  If CBSY was not asserted  upon entering this routine, the number of words transferred will be  zero. */send_record: proc(buffer, length) fixed public;   dcl buffer    fixed array; /* the record to write */   dcl length    fixed; /* number of words to write */   dcl next_word fixed; /* the next word pulled out of the buffer */   dcl next_byte fixed; /* the next byte to write */   dcl state     fixed; /* the machine's state upon entry */   dcl i         fixed;   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   /* $page */   i = 0; /* initialize word counter */   if ((read(tape_drive) or read(tape_drive)) and cbsy) <> 0 /* 1. make sure CBSY is asserted */   then do; /* CBSY is asserted */      next_word = buffer (0); /* 2. pull out the first word */      next_byte = (odd_parity (next_word and "HFF") or drdy); /* set parity on first byte and assert DRDY */      write(tape_drive) = next_byte; /* 3. write out the first byte */      do while (i < length); /* 4. write all the words */         next_byte = (odd_parity (shr(next_word, 8)) or drdy); /* set parity and assert DRDY */         do while ((read(tape_drive) and strobe) = 0); /* 4.a. wait until STROBE is set (when STRB is asserted) */            if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* was there an error? */            then goto ABORT; /* yes, abort */         end;         write(tape_drive) = next_byte; /* 4.b. write the most significant byte (and clear STROBE) */         i = i + 1; /* look at next word */         next_word = buffer (i); /* 4.c. pull out the next word */         next_byte = (odd_parity (next_word and "HFF") or drdy); /* set parity on next byte and assert DRDY */         do while ((read(tape_drive) and strobe) = 0); /* 4.d. wait until STROBE is set (when STRB is asserted) */            if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* was there an error? */            then goto ABORT; /* yes, abort */         end;         write(tape_drive) = next_byte; /* 4.e. write out the least significant byte */      end;      next_byte = (odd_parity (shr(next_word, 8)) or drdy); /* set parity and assert DRDY */      write(tape_drive) = next_byte; /* 5. write the last byte (and clear STROBE) */      do while ((read(tape_drive) and strobe) = 0); /* 6. wait until STROBE is set (when STRB is asserted) */         if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* was there an error? */         then goto ABORT; /* yes, abort */      end;      ABORT: write(tape_drive) = idle; /* 7. deny DRDY (and remove data from bus) */   end;   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (i); /* return number of words transferred */end send_record;/* $subtitle Receive A Data Record From The Formatter *//* This procedure receives a data record from the formatter using  the handshaking protocol described in the Pico Formatter Interface  Definition.  The algorithm proceeds as follows:     1. Assure CBSY is asserted.     2. Assert DRDY (and clear STROBE).     3. Wait until DBSY is asserted.     4. Loop until all data words are read.        a. Wait until STROBE is set (STRB is asserted).        b. Remove the next data byte (LSB) from the data bus.        c. Clear STROBE.        d. Wait until STROBE is set (STRB is asserted).        e. Remove the next data byte (MSB) from the data bus.        f. Clear STROBE.        g. Save the word just read.     5. Keep reading until the end of the data block.     6. Deny DRDY.  Two parameters are passed:  BUFFER (the buffer to read into) and  LENGTH (number of words to read).  BUFFER is arranged such that the  least significant byte preceeds the most significant in ascending  order.  The number of words transferred is returned.  If a parity  error is detected during the block transfer, the negative number  of words transferred will be returned.  If CBSY is not asserted  upon entering this routine, the number of words transferred will  be zero (this can also happen when we're at the logical end of  tape). */receive_record: proc(buffer, length) fixed public;      dcl buffer     fixed array; /* the buffer to read into */   dcl length     fixed; /* number of words to read */   dcl next_byte  fixed; /* the next byte read off the bus */   dcl last_byte  fixed; /* last byte read off the bus */   dcl parity_sum fixed; /* sum of all parities */   dcl state      fixed; /* the machine's state upon entry */   dcl (i, j)     fixed;   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   /* $page */   i = -1; /* initialize word counter */   parity_sum = 1; /* start off the sum with odd parity */   if ((read(tape_drive) or read(tape_drive)) and cbsy) <> 0 /* 1. make sure CBSY is asserted */   then do; /* CBSY is asserted */      last_byte = 1; /* initialize last byte */      next_byte = 0; /* set up a register pointing to NEXT_BYTE */      length = length - 1; /* stop reading when we're close */      write(r13) = addr(buffer (0)); /* point to buffer */      write(tape_drive) = drdy; /* 2. assert DRDY (and clear STRB) */      do while ((read(tape_drive) and dbsy) = 0); /* 3. wait until DBSY is asserted */         if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* make sure the command is still active */         then goto ABORT; /* no, better abort */      end;      do while (i < length); /* 4. write out all words */         do while (((read(tape_drive) or read(tape_drive)) and (strobe or cbsy)) = cbsy);            /* 4.a. wait until STROBE is set (STRB is asserted) */         end;         next_byte = read(tape_drive); /* 4.b. remove the next byte from the data bus */         write(tape_drive) = drdy; /* 4.c. clear STROBE */         if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* is CBSY still asserted? */         then goto ABORT; /* no, abort */         parity_sum = (parity_sum xor last_byte xor next_byte); /* keep track of the parity */         last_byte = (next_byte and data_mask); /* remember the least significant */         do while (((read(tape_drive) or read(tape_drive)) and (strobe or cbsy)) = cbsy);            /* 4.d. wait until STROBE is set (STRB is asserted) */         end;         next_byte = read(tape_drive); /* 4.e. remove the next byte from the data bus */         write(tape_drive) = drdy; /* 4.f. clear STROBE */         i = i + 1; /* increment word counter */         write(mr13i) = (last_byte or shl(next_byte,8)); /* 4.g. compute and save next word */         last_byte = next_byte; /* preserve this byte */      end;      i = i + 1; /* count the last word read */      j = 0; /* initialize byte counter */      do while (read(tape_drive) and dbsy) <> 0; /* 5. loop while more data in record */         if (read(tape_drive) and strobe) <> 0 /* did strobe come in? */         then do; /* yes, count it and clear it */            if j /* did another word go by? */            then i = i + 1; /* yes, count extra words */            j = (j xor "H01"); /* toggle byte counter */            write(tape_drive) = drdy; /* clear STROBE */         end;      end;      ABORT: write(tape_drive) = idle; /* 7. deny DRDY (and remove data from bus) */   end;   if i = -1 /* did the command fail? */   then i = 0; /* yes, return a zero */   if odd_parity (parity_sum and data_mask) <> (parity_sum and data_parity) /* did we get the proper parity? */   then i = -i; /* no, return negative number of words transferred */   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (i); /* return number of words transferred */end receive_record;/* $subtitle Reset The Tape Drive *//* This procedure resets the formatter.  It should be called before any  other routine in this library since it puts the formatter in a known  state and ensures the cable from the computer to the tape drive is  properly connected.  The reset algorithm proceeds as follows:     1. Assure CMON is asserted.     2. Assert FCLR.     3. Wait more than 20 microseconds.     4. Assure CBSY is asserted.     5. Deny FCLR.     6. Wait until CBSY is denied.     7. Assure only CMON and PARITY (FPAR) are asserted.  If the tape drive is not connected properly or if the reset fails,  a boolean FALSE is returned. */reset_tape: proc boolean public;   dcl state       fixed; /* the machine state upon entry */   dcl operational boolean; /* the operational status of the tape drive */   state = read(r14); /* save the machine's state */   disable; /* and disable inteerupts */   if (read(tape_drive) and cmon) = 0 /* 1. assure CMON is asserted */   then operational = false; /* it isn't - the cable isn't connected properly */   else do; /* it is - try to clear the formatter */      write(tape_drive) = fclr; /* 2. assert FCLR */      write(d03) = 0; /* 3. synchronize and wait at least 20 microseconds */      write(d03) = 0;      write(d03) = 0;      if ((read(tape_drive) or read(tape_drive)) and cbsy) = 0 /* 4. is CBSY asserted? */      then do; /* no, this means the formatter's not powered up */         write(tape_drive) = idle; /* idle the bus */         operational = false; /* and return a bad status */      end;      else do; /* yes, the formatter's powered up */         write(tape_drive) = idle; /* 5. deny FCLR */         do while (((read(tape_drive) or read(tape_drive)) and cbsy) <> 0);            /* 6. wait until CBSY is denied */         end;         if (read(tape_drive) and (cmon or parity)) <> (cmon or parity) /* is it properly reset? */         then operational = false; /* no, return a bad status */         else operational = true; /* yes, return a good status */      end;   end;   write(r14) = state; /* restore the previous state of the machine (from the compiler's viewpoint) */   write(pcw) = state; /* from the machine's viewpoint */   return (operational); /* return the operational status of the drive */end reset_tape;end tape_interface;