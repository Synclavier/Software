/* $subtitle Bridge the Gap Between the Kennedy and the SCSI Tape Drives *//* These routines bridge the gap between the Kennedy and the SCSI tape  drives by calling the appropriate routines.  The parameters are identical  to those of the SCSI routines (which require more arguments).  By:  Karim J. Chichakly on 26 February 1986    This module also contains the XPL device drivers for the Kennedy  cartridge tape drive and the SCSI tape drive.  They are invoked via  a CALL to READDATA and WRITEDATA with a device number of 8 or 9.  By:  Karim J. Chichakly on 7/22/83 and 9/26/83 (error recovery)  SCSI tape code (by Kip J. Olson) added on 2/28/86*/module tape_bridge;   configuration modelC, nomuldiv;   insert ':-xpl:literals'; /* get literals */   insert ':-xpl:syslits'; /* get system literals */   insert ':-xpl:tapelib'; /* get kennedy tape library */   insert ':-xpl:tapescsi'; /* get SCSI tape library */   insert ':-xpl:scsi'; /* get SCSI tape routines - THIS version doesn't swap! */   dcl r4 lit '"304"'; /* register four */   dcl r5 lit '"305"'; /* register five */   dcl tape_position (1) fixed public; tape_position (0) = -1; tape_position (1) = -1; /* global tape position (track and file position) */   dcl tape_device       fixed public; /* device last operation applies to */   dcl type  (1) fixed; /* tape drive type */   dcl drive (9) fixed; /* drive number associated with device number */   dcl notLoaded fixed;   decode_status: proc returns (fixed) public; /* decode the status from the last operation */      if (notLoaded != 0)        return notLoaded;      if type (drive (tape_device)) = 0 /* if Kennedy */      then return (k#decode_status);      else return (s#decode_status); /* must be SCSI */   end decode_status;   load: proc(device) public; /* load the specified tape device */      dcl device fixed; /* device to load */      dcl i      fixed;      i = find_device (device); /* look up device */      if ((i <> 0) and ((core(i + s#devtyp) and "17") = 3)) then do; /* if a tape drive */         tape_device = device; /* save last operation's device number */         device = 8 + (shr(core(i + s#devtyp), 4) and "17"); /* map to actual device number */         drive (device) = (device and 1); /* save drive number */         if (core(i + s#devtyp) and "377") = system_device  then drive (0) = drive (device); /* remember it if it's the system device */         if (core(i + s#devtyp) and "377") = current_device then drive (1) = drive (device); /* or the current device (this assumes another device won't be ENTERed while the tape is loaded!!!) */         type (drive (device)) = (shr(core(i + s#devtyp), 8) and "3"); /* pick up drive type */         if type (drive (device)) = 0 /* if Kennedy */         then call k#load;         else call s#load (device); /* must be SCSI */         tape_position (drive (device)) = 0; /* assume it succeeded */      end; /* of tape drive */            else do;           notLoaded = s#not_configured;      end;   end load;   unload: proc(device, wait) public; /* unload the specified tape device */      dcl device fixed; /* device to unload */      dcl wait   boolean; /* TRUE if should wait for the UNLOAD to complete */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 then do; /* if Kennedy */         call k#unload; /* unload */         if wait then call k#read_status; /* read status - wait here */      end; /* of Kennedy */      else do; /* must be SCSI */         if wait then call s#rewind (device); /* rewind - wait here */         call s#unload (device); /* unload */      end; /* of SCSI */      tape_position (drive (device)) = -1; /* assume it succeeded */   end unload;   rewind: proc(device) public; /* rewind the specified tape device */      dcl device fixed; /* device to rewind */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#rewind;      else call s#rewind (device); /* must be SCSI */      tape_position (drive (device)) = 0; /* assume it succeeded */   end rewind;   erase: proc(device, eot) public; /* erase the specified tape device */      dcl device fixed; /* device to erase */      dcl eot    boolean; /* TRUE if we should erase to EOT */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#erase; /* always erase to EOT - we could do a fixed erase instead, but... */      else call s#erase (device, eot); /* must be SCSI */   end erase;   select: proc(device, track) public; /* select the specified track on the specified tape device */      dcl device fixed; /* device to select track */      dcl track  fixed; /* track to select */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#select (track, llp);      else call s#select (device, track); /* must be SCSI */      tape_position (drive (device)) = shl(track, track_shift); /* assume it succeeded */   end select;   forward_space: proc(device, MSW, LSW) public; /* forward space record on the specified tape device */      dcl device     fixed; /* device to forward space */      dcl (MSW, LSW) fixed; /* number of records to forward space */      tape_device = device; /* save last opration's device number */      tape_status = 0;      if type (drive (device)) = 0 /* if Kennedy */      then do while ((LSW <> 0) and ((k#decode_status and status_mask) = s#no_error)); /* space as many as required */         call k#forward_space;         LSW = LSW - 1;      end; /* of Kennedy */      else call s#forward_space (device, MSW, LSW); /* must be SCSI */   end forward_space;   reverse_space: proc(device, MSW, LSW) public; /* reverse space record on the specified tape device */      dcl device     fixed; /* device to reverse space */      dcl (MSW, LSW) fixed; /* number of records to reverse space */      tape_device = device; /* save last opration's device number */      tape_status = 0;      if type (drive (device)) = 0 /* if Kennedy */      then do while ((LSW <> 0) and ((k#decode_status and status_mask) = s#no_error)); /* space as many as required */         call k#reverse_space;         LSW = LSW - 1;      end; /* of Kennedy */      else call s#reverse_space (device, MSW, LSW); /* must be SCSI */   end reverse_space;   forward_file: proc(device, MSW, LSW) public; /* forward space file on the specified tape device */      dcl device     fixed; /* device to forward space file */      dcl (MSW, LSW) fixed; /* number of records to forward space file */      tape_device = device; /* save last opration's device number */      tape_status = 0;      if type (drive (device)) = 0 /* if Kennedy */      then do while ((LSW <> 0) and ((k#decode_status and status_mask) = s#no_error)); /* space as many as required */         call k#forward_file;         LSW = LSW - 1;      end; /* of Kennedy */      else call s#forward_file (device, MSW, LSW); /* must be SCSI */   end forward_file;   reverse_file: proc(device, MSW, LSW) public; /* reverse space file on the specified tape device */      dcl device     fixed; /* device to reverse space file */      dcl (MSW, LSW) fixed; /* number of records to reverse space file */      tape_device = device; /* save last opration's device number */      tape_status = 0;      if type (drive (device)) = 0 /* if Kennedy */      then do while ((LSW <> 0) and ((k#decode_status and status_mask) = s#no_error)); /* space as many as required */         call k#reverse_file;         if (k#decode_status and status_mask) = s#no_error /* check status */         then call k#reverse_space; /* position BEFORE filemark like the 1/2" drives */         LSW = LSW - 1;      end; /* of Kennedy */      else call s#reverse_file (device, MSW, LSW); /* must be SCSI */   end reverse_file;   read_tape: proc(device, buffer, length) public; /* read data from the specified tape device */      dcl device fixed; /* device to read from */      dcl buffer fixed array; /* buffer to read into */      dcl length fixed; /* length to read */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#read_tape (buffer, length);      else call s#read_tape (device, buffer, length); /* must be SCSI */   end read_tape;   write_tape: proc(device, buffer, length) public; /* write data to the specified tape device */      dcl device fixed; /* device to write to */      dcl buffer fixed array; /* buffer to write from */      dcl length fixed; /* length to write */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#write_tape (buffer, length);      else call s#write_tape (device, buffer, length); /* must be SCSI */   end write_tape;   write_filemark: proc(device, extended) public; /* write a filemark to the specified tape device */      dcl device   fixed; /* device to write to */      dcl extended boolean; /* TRUE if this should be a write extended */      tape_device = device; /* save last opration's device number */      if type (drive (device)) = 0 /* if Kennedy */      then call k#write_filemark (extended);      else call s#write_filemark (device, extended); /* must be SCSI */   end write_filemark;   tension_tape: proc(device) public; /* tension the tape if it's a cartridge */      dcl device fixed; /* device to tension */      if type (drive (device)) = 0 then do; /* if Kennedy */         call unload (device, true); call load (device); /* force it to wind across the tape */      end;   end tension_tape;   /* This procedure aborts the tape subsystem in the event of an unrecoverable     tape error.  It is passed the MESSAGE to output.  The following global     variables are referenced:  TAPE_OPERATION, TAPE_STATUS, and TAPE_POSITION. */   abort_tape: proc(message) public;      dcl message fixed array;      print; print;      print '*** Tape system error:  ', string(message);      print '    device = ', tape_device,;      print ', position = ', octal(tape_position (drive (tape_device))),;      print ', command = ',  octal(tape_operation),;      print ', status = ', octal(tape_status);      call exit(-1);   end abort_tape;   /* $page */   /* This procedure checks the global TAPE_STATUS after a tape operation     is completed and acts appropriately based upon the status received     from the global TAPE_OPERATION.  If the status is fatal, this     procedure aborts the program. */   check_tape: proc public;      dcl status  fixed; /* the decoded status */      status = (decode_status and status_mask); /* get the decoded status */      if ((status < 0) or (status > s#maximum)) /* check the range */      then do; /* out of range */         print '*** System error:  decoded tape status ', status, ' out of range.';         call exit(-1);      end;      do case (status); /* interpret and recover from errors */         ; /* no errors */         if tape_operation <> unload_tape /* drive not ready */         then call abort_tape ('drive not ready');         call abort_tape ('drive not loaded'); /* drive not loaded */         call abort_tape ('no cartridge in drive'); /* no cartridge */         call abort_tape ('parity error detected during command or data transmission'); /* parity error */         do; /* data (CRC) error */            print; print;            if tape_operation = erase_tape /* erase tape? */            then do; /* yes */               print '*** The tape you''re using has a permanent defect.';               print '    Do NOT use this tape.';            end;            else do;               print '*** The tape you''re using is highly unreliable.';               print '    It is recommended that you don''t use this tape.';            end;            call unload (tape_device, false); /* unload the tape */            call exit(-1); /* die here */         end;         call abort_tape ('tape has broken or run off its reel'); /* tape broken */         call abort_tape ('drive fault detected in tape drive'); /* drive fault */         call abort_tape ('tape drive formatter failed its on-line self-test'); /* self-test failed on LOAD */         call abort_tape ('data expected before logical end-of-tape, but not found'); /* no data before leot */         do; /* write protected */            print; print;            print '*** Cannot write to a write protected tape.  If you wish to write';            print '    to this tape, turn the write protection screw on the tape';            print '    cartridge away from SAFE and try again.';            call unload (tape_device, false); /* unload the tape */            call exit(-1); /* die here */         end;         call abort_tape ('unknown error'); /* unknown error */         call abort_tape ('logical device specified is not a tape drive'); /* tape drive not specified */         call abort_tape ('specified tape drive is not connected'); /* selection failed on SCSI bus */         call abort_tape ('specified D24 not in system'); /* d24 board not in system */         call abort_tape ('bad SCSI initiator'); /* invalid initiator specified (not 6 or 7) */         call abort_tape ('bad SCSI command'); /* illegal parameter in SCSI command */         call abort_tape ('tape not configured'); /* not configured */      end;   end check_tape;   /* $subtitle Tape Read and Write Routines */   /* This procedure seeks to the appropriate track and file number on     the Kennedy Model 6455 Tape Drive using the Cartridge Tape Library     TAPELIB.  It is passed one parameter:  SECTOR (the track and file     number to seek to).  If SECTOR equals -1, no seek is performed.     If a seek is successfully performed, the tape is guaranteed to be     positioned at the very beginning of the specified SECTOR.  The status     from the seek operation is stored in the global variable TAPE_STATUS.     If the seek succeeded, the global variable TAPE_POSITION is updated     to the tape's new position.  Otherwise, TAPE_POSITION is set to the     "unknown position" value -1.  TAPE_POSITION is also updated in most     of the TAPEFORM routines.  Note that it is the user's responsibility     to initialize and update TAPE_POSITION whenever any TAPELIB routines     which affect the tape position are called directly. */   tapeseek: proc(device, sector); /* seek to SECTOR on the Kennedy */      dcl device fixed; /* device number of device to seek on */      dcl sector fixed; /* the track and file number to seek to */      dcl ldrive fixed; /* logical drive number of device we're seeking on */      dcl track  fixed; /* the track we want to seek to */      dcl start  fixed; /* what sector to start seeking from */      dcl status fixed; /* intermediate tape status */      dcl i      fixed;      if sector <> -1 /* should we seek? */      then do; /* yes, seek away */         ldrive = drive (device); /* pick up logical drive number */         if sector = 0 /* is this really a rewind? (are we looking for the catalog?) */         then do; /* yes, rewind the tape */            call k#rewind; /* like so */            call check_tape; /* and check the operation's success */         end;         else do; /* no, select the proper track and file number */            if sector <> tape_position (ldrive) /* are we at the proper file yet? */            then do; /* no, move there */               track = shr(sector, track_shift); /* determine the destination track */               if ((track <> shr(tape_position (ldrive), track_shift)) or (tape_position (ldrive) = -1)) /* already on destination track? */               then do; /* no, select the proper track */                  call k#select (track, llp); /* like so */                  call check_tape; /* and check the status */                  tape_position (ldrive) = shl(track, track_shift); /* remember where we are */               end;               do i = 1 to abs(sector - tape_position (ldrive)); /* seek the proper file */                  if sector ige tape_position (ldrive) /* which direction are we seeking in? */                  then call k#forward_file; /* forward - move to the next file */                  else call k#reverse_file; /* reverse */                  call check_tape; /* check the status */               end;               if sector ilt tape_position (ldrive) /* did we seek in the reverse direction? */               then do; /* yes, we need to go back one more file */                  call k#reverse_file; /* backup a file */                  call check_tape; /* and check the status */               end;            end; /* of not at proper file yet */            else do; /* yes, move to the beginning of the file */               call k#reverse_space; /* move back one record */               call check_tape; /* check the status */               status = tape_status; /* remember the status */               call k#forward_space; /* move back to where we were */               call check_tape; /* check the status */               if (status and file_mark) = 0 /* did we detect a filemark when we reversed? */               then do; /* no, we're not already at the beginning of the file */                  call k#reverse_file; /* move to the beginning of the file */                  call check_tape; /* and check the status */               end;            end; /* of move to beginning of file */         end; /* of select proper track and file number */         tape_position (ldrive) = sector; /* update the tape position */      end; /* of seek */   end tapeseek;   /* $page */   /* This procedure seeks to the given file on the given track of the     SCSI tape drive.  SECTOR has the following format:        Bits 1-11     File number        Bits 12-15    Track number   */   s#tapeseek: proc(device, sector);              /* seek to SECTOR on tape drive DEVICE */      dcl device fixed;                           /* device number to do seeks on */      dcl sector fixed;                           /* track and filemark to seek to */      dcl ldrive fixed;                           /* logical drive number of device we're seeking on */      dcl track  fixed;                           /* holds track to seek to */      dcl err    boolean;      if sector <> -1 then do;                    /* do not seek if sector = -1 */         ldrive = drive (device);                 /* pick up logical drive number */         if sector = 0                            /* if seeking to start of tape */         then call s#rewind (device);             /* rewind the tape */         else do;                                 /* otherwise seek to a new file */            track = shr(sector, track_shift);     /* get track for this file */            /* select this track if it is different from the current track */            err = false;                          /* no error has yet occurred */            if (track <> shr(tape_position (ldrive), track_shift)) or (tape_position (ldrive) = -1) then do;               call s#select (device, track);     /* select this new track */               if (tape_status and status_mask) = s$nosense /* check if an error occurred */               then tape_position (ldrive) = shl(track, track_shift); /* no error, so update position to new track */               else err = true;                   /* error occurred, so set flag */            end;                                  /* of selecting a track */            if not err then do;                   /* don't seek to the file if an error occurred */               if (sector igt tape_position (ldrive)) /* space forward if no error occurred */               then call s#forward_file (device, 0, sector - tape_position (ldrive)); /* space forward this many filemarks */               else do;                           /* space backwards if no error occurred */                  call s#reverse_file (device, 0, tape_position (ldrive) - sector + 1); /* space backwards this many filemarks */                  if (tape_status and status_mask) = s$nosense /* don't reposition if an error occurred */                  then call s#forward_space (device, 0, 1); /* reposition so first block in file is read (instead of filemark) */               end;            end;                                  /* of seeking to a file */         end;                                     /* of seeking to a new file */         if (tape_status and status_mask) = s$nosense /* see if an error occurred */         then tape_position (ldrive) = sector;    /* no error, so update global position variable */         else tape_position (ldrive) = -1;        /* error occurred, so set unknown position flag */      end;                                        /* of need to seek */   end s#tapeseek;   /* $page */   /* This procedure reads data from the Kennedy Model 6455 Tape Drive     or from a SCSI tape drive.  It is passed four parameters:  DEVICE     (device # in MSB), START (the track and the file number to start from),     BUFFER (the buffer to read the data into), and LENGTH (the number of     words to read).  If START equals -1, data is read starting at the     current tape position.  The status from the read operation is stored     in the global variable TAPE_STATUS. */   dev8read: proc(device, start, buffer, length) public;      dcl device fixed; /* devuce to read */      dcl start  fixed; /* starting track and file number */      dcl buffer fixed array; /* buffer to read data into */      dcl length fixed; /* number of words to read */      dcl sector fixed; /* starting sector in poly/ext memory */      dcl word   fixed; /* starting word in poly/ext memory */      dcl len    fixed; /* number of words to read this operation */      dcl words  fixed; /* number of words read in one operation */      dcl i      fixed;      word = read(r5); /* save starting word */      sector = read(r4); /* save starting sector */      i = find_device (shr(device, 8)); /* look it up */      if i = 0 then do; /* have to have a tape drive */         print 'There is no tape drive configured in your system.';         call exit(-1);      end;      if (shr(core(i + s#devtyp), 8) and "3") <> 0 then do; /* SCSI? */         call s#tapeseek (shr(device, 8), start); /* seek to given tape file */         if (tape_status and status_mask) <> s$nosense /* if an error occurred */         then do forever; /* loop forever */            write("50") = 7; /* ring bell */            invoke diskerror; /* invoke disk error */         end;         call scsiio (device, start, addr(buffer (0)), length, sector, word, s$read); /* read the data */      end; /* of SCSI */      else do; /* Kennedy */         if ((length = -1) or (length = -2)) then do; /* polyread or extread? */            print 'Cannot POLYREAD or EXTREAD from the cartridge tape drive.';            call exit(-1);         end;         call tapeseek (shr(device, 8), start); /* seek the proper track and file */         do while (length > 0); /* read LENGTH words */            if length > block_size /* reading more than one block? */            then len = block_size; /* yes, just read one block */            else len = length; /* no, read as much as they want */            words = k#read_tape (buffer, len); /* read the next block */            call check_tape; /* check the read status */                        if words < len /* was the block too short? */            then call abort_tape ('block shorter than expected - your tape may be damaged');            if words > len /* was the block too long? */            then do; /* yes, warn the user */               print;               print '*** Warning:  tape block was longer than expected - some data may be missing.';            end;            length = length - len; /* count the words read */         end; /* of read LENGTH words */      end; /* of Kennedy */   end dev8read;   /* $page */         /* This procedure writes data to the Kennedy Model 6455 Tape Drive.     or to a SCSI tape drive.  It is passed four parameters:  DEVICE     (device # in MSB), START (the track and the file number to start from),     BUFFER (the buffer to write the data from), and LENGTH (the number     of words to write).  If START equals -1, data is written starting     at the current tape position.  If START is zero, it is assumed that     the directory is to be written and WRITE_TAPEX is called in place     of WRITE_TAPE.  The status from the write operation is stored in     the global variable TAPE_STATUS. */   dev8write: proc(device, start, buffer, length) public;      dcl device fixed; /* device to write */      dcl start  fixed; /* starting track and file number */      dcl buffer fixed array; /* buffer to write data from */      dcl length fixed; /* number of words to write */      dcl sector fixed; /* starting sector in poly/ext memory */      dcl word   fixed; /* starting word in poly/ext memory */      dcl len    fixed; /* number of words to write this operation */      dcl words  fixed; /* number of words written in one operation */      dcl i      fixed;      word = read(r5); /* save starting word */      sector = read(r4); /* save starting sector */      i = find_device (shr(device, 8)); /* look it up */      if i = 0 then do; /* have to have a tape drive */         print 'There is no tape drive configured in your system.';         call exit(-1);      end;      if (shr(core(i + s#devtyp), 8) and "3") <> 0 then do; /* SCSI? */         call s#tapeseek (shr(device, 8), start); /* seek to given tape file */         if (tape_status and status_mask) <> s$nosense /* if an error occurred */         then do forever; /* loop forever */            write("50") = 7; /* ring bell */            invoke diskerror; /* invoke disk error */         end;         call scsiio (device, start, addr(buffer (0)), length, sector, word, s$write); /* write the data */         if start = 0 then do; /* are we writing the directory? */            call s#erase (shr(device, 8), false); /* yes, keep the tape clean */            call check_tape;         end;      end; /* of SCSI */      else do; /* Kennedy */         if ((length = -1) or (length = -2)) then do; /* polywrite or extwrite? */            print 'Cannot POLYWRITE or EXTWRITE from the cartridge tape drive.';            call exit(-1);         end;         call tapeseek (shr(device, 8), start); /* seek the proper track and file */         if start = 0 /* are we writing the directory? */         then do; /* yes */            words = k#write_tapex (buffer, length); /* write out the tape directory */            call check_tape; /* and check the status */            if words <> length /* did we write out the entire length? */            then call abort_tape ('unable to write the directory properly');         end;         else do while (length > 0); /* write LENGTH words */            if length > block_size /* writing more than one block? */            then len = block_size; /* yes, write one block */            else len = length; /* no, write as much as they want */            words = k#write_tape (buffer, len); /* write this block out */            call check_tape; /* check the tape status */            if words <> len /* were we able to write the block? */            then call abort_tape ('unable to write the next block to the tape properly');            length = length - len; /* count the words written */         end; /* or write LENGTH words */      end; /* of Kennedy */   end dev8write;end tape_bridge;