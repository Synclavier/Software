   /* $subtitle Storage Management:  Consolidate */   /* This (internal) procedure makes a pass through the catalog buffer,   .  consolidating all contiguous blocks of free storage into one block.   .  This procedure returns FALSE if GET_FCB fails for any reason. */   consolidate: proc returns (boolean) recursive swappable; /* consolidate contiguous blocks of free storage */      dcl (ams, als) fixed; /* ending sector of block in A */      dcl (bms, bls) fixed; /* and in B */      dcl (x, y)     fixed;      dcl a lit 'fcb'; dcl b lit 'fcb2'; /* rename our global FCBs */      dcl zero data (0, 0, 0, 0, 0, 0, 0, 0, 0, 0); /* a zeroed out fcb */      if ((shr(c#ms_sector, 8) <> 8) and (shr(c#ms_sector, 8) <> 9)) /* don't consolidate the tape drive! */      then do x = 0 to shr(c#dir_size, 3) - 1; /* look at all FCBs */         if not get_fcb (x, a) then return (false); /* get this one */         if (((a (f#nm) = 0) and (a (f#ml) = 0) and (a (f#ll) = 0)) /* if deleted block */         or ((a (f#ms) = 0) and (a (f#ls) = 0) and ((a (f#ml) <> 0) or (a (f#ll) <> 0))))         then call put_fcb (x, zero); /* no data in this section of catalog */         else if ((a (f#nm) = 0) and ((a (f#ml) <> 0) or (a (f#ll) <> 0))) then do; /* hole */            do y = 0 to x - 1; /* now look through cat up to where we are */               call get_fcb (y, b); /* get it */               if ((b (f#nm) = 0) and ((b (f#ml) <> 0) or (b (f#ll) <> 0))) then do; /* B is a hole with some sectors in it */                  ams = a (f#ms) + a (f#ml); /* find where block A ends */                  als = a (f#ls) + a (f#ll);                  if als ilt a (f#ll) then ams = ams + 1;                  bms = b (f#ms) + b (f#ml); /* find where block B ends */                  bls = b (f#ls) + b (f#ll);                  if bls ilt b (f#ll) then bms = bms + 1;                  if ((bms = a (f#ms)) and (bls = a (f#ls))) then do; /* hole b ends at start of a */                     a (f#ms) = b (f#ms);							/* a hole starts here */                     a (f#ls) = b (f#ls);                     a (f#ml) = a (f#ml) + b (f#ml);                     a (f#ll) = a (f#ll) + b (f#ll);                     if a (f#ll) ilt b (f#ll) then a (f#ml) = a (f#ml) + 1;					 					 if (a (f#ml) ILT 0x0010)						/* if combined length will fit in block	*/					 {												/* then combine them					*/                     	call put_fcb (y, zero); /* zero it */                     	call put_fcb (x, a);	/* new a */					 }					 else											/* else limit to 2^20-1					*/					 {					 	b (f#ml) = 0x000F;							/* limit length of b to 2^20-1			*/						b (f#ll) = 0xFFFF;												a (f#ms) = b (f#ms) + b (f#ml);				/* compute start of a to be at end of	*/						a (f#ls) = b (f#ls) + b (f#ll);				/* truncated b							*/						if (a (f#ls) ILT b (f#ll))							a (f#ms) = a (f#ms) + 1;												if (a (f#ll) ILT 0xFFFF)					/* and compute length of a to be that	*/							a (f#ml) = a (f#ml) - 1;				/* part above 0x FF FFFF				*/												 	a (f#ll) = a (f#ll) - 0xFFFF;						a (f#ml) = a (f#ml) - 0x000F;						                     	call put_fcb (y, b);    /* new b */                     	call put_fcb (x, a);	/* new a */					 }                  end;                  else if ((ams = b (f#ms)) and (als = b (f#ls))) then do; /* hole b starts at end of a */                     a (f#ml) = a (f#ml) + b (f#ml);                     a (f#ll) = a (f#ll) + b (f#ll);                     if a (f#ll) ilt b (f#ll) then a (f#ml) = a (f#ml) + 1;					 					 if (a (f#ml) ILT 0x0010)						/* if combined length will fit in block	*/					 {												/* then combine them					*/                     	call put_fcb (y, zero); /* zero it */                     	call put_fcb (x, a);	/* new a */					 }					 else											/* else limit to 2^20-1					*/					 {					    b (f#ms) = a (f#ms);					    b (f#ls) = a (f#ls);					 	b (f#ml) = 0x000F;							/* limit length of b to 2^20-1			*/						b (f#ll) = 0xFFFF;												a (f#ms) = b (f#ms) + b (f#ml);				/* compute start of a to be at end of	*/						a (f#ls) = b (f#ls) + b (f#ll);				/* truncated b							*/						if (a (f#ls) ILT b (f#ll))							a (f#ms) = a (f#ms) + 1;												if (a (f#ll) ILT 0xFFFF)					/* and compute length of a to be that	*/							a (f#ml) = a (f#ml) - 1;				/* part above 0x FF FFFF				*/												 	a (f#ll) = a (f#ll) - 0xFFFF;						a (f#ml) = a (f#ml) - 0x000F;						                     	call put_fcb (y, b);    /* new b */                     	call put_fcb (x, a);	/* new a */					 }                  end;               end;            end; /* of looking through cat up to where we are */         end;      end; /* of looking at all FCBs */      return (true); /* we consolidated it okay */   end consolidate;   /* $subtitle Storage Management:  Find_Exact */   /* This (internal) procedure looks for a block exactly MS_SIZE|LS_SIZE   .  sectors long.  If it finds one (and SEARCHING is TRUE), it returns   .  that block.  Otherwise, it calculates the remaining sectors in the   .  catalog (returned in MS_REMAINING|LS_REMAINING), finds the FCB number   .  of the last free block (returned in LAST_FREE) along with its sector   .  address (returned in MS_LASTFREE|LS_LASTFREE), and returns the FCB   .  number of the first free block in the catalog (or -1 if there are   .  no free blocks). */   find_exact: proc(ms_size, ls_size, searching) returns (fixed) recursive swappable; /* find a block exactly MS_SIZE|LS_SIZE sectors long */      dcl (ms_size, ls_size) fixed; /* size of block to find */      dcl searching          boolean; /* TRUE if we're really searching for a match (i.e., MS_SIZE|LS_SIZE is valid) */      dcl last_used          fixed; /* FCB number of last used block */      dcl ms_lastused        fixed; /* sector address of last used block */      dcl ls_lastused        fixed;      dcl (x, hole)          fixed;      hole = -1; /* assume not found */      last_free = -1; ms_lastfree = 0; ls_lastfree = 0; /* initialize */      last_used = -1; ms_lastused = 0; ls_lastused = 0;      ms_remaining = c#ms_length; /* so far the entire catalog is free */      if c#ls_length ilt shr(c#dir_size, 8) then ms_remaining = ms_remaining - 1; /* borrow */      ls_remaining = c#ls_length - shr(c#dir_size, 8); /* except the directory */      do x = 0 to shr(c#dir_size, 3) - 1; /* look for perfect fit */         if not get_fcb (x, fcb) then return (-1); /* get next block */         if fcb (f#nm) = 0 then do; /* hole */            if (searching and (fcb (f#ml) = ms_size) and (fcb (f#ll) = ls_size)) then return (x); /* exact fit */            if ((fcb (f#ml) = 0) and (fcb (f#ll) = 0)) then do; /* if a hole */               if hole = -1 then hole = x; /* if first hole, keep it */            end;            else do; /* has some storage with it */               if ((fcb (f#ms) igt ms_lastfree) /* if FCB starts after last */               or ((fcb (f#ms) = ms_lastfree) and (fcb (f#ls) igt ls_lastfree))) then do;                  ms_lastfree = fcb (f#ms); ls_lastfree = fcb (f#ls); last_free = x;               end;            end;         end; /* of hole */         else do; /* used */            if ((fcb (f#ms) igt ms_lastused) /* if FCB starts after last_used */            or ((fcb (f#ms) = ms_lastused) and (fcb (f#ls) igt ls_lastused))) then do;               ms_lastused = fcb (f#ms); ls_lastused = fcb (f#ls); last_used = x;            end;            ms_remaining = ms_remaining - fcb (f#ml); /* subtract out used sectors */            if ls_remaining ilt fcb (f#ll) then ms_remaining = ms_remaining - 1;            ls_remaining = ls_remaining - fcb (f#ll);         end;      end;      if hole = -1 then c#status = e#dir_full; /* if we didn't find a block, the directory is full */      else if ((ms_lastfree ilt ms_lastused) /* last thing isn't hole */      or ((ms_lastfree = ms_lastused) and (ls_lastfree ilt ls_lastused))) then do;         call get_fcb (last_used, fcb2);         ms_lastfree = ms_lastused + fcb2 (f#ml); /* and this is where free stuff starts */         ls_lastfree = ls_lastused + fcb2 (f#ll);         if ls_lastfree ilt ls_lastused then ms_lastfree = ms_lastfree + 1;         last_free = -1; /* and there is no half filled block */      end;      else if ((ms_lastfree = 0) and (ls_lastfree = 0)) then do; /* nothing anywhere */         ms_lastfree = 0; ls_lastfree = shr(c#dir_size, 8); /* start saving files after directory */         last_free = -1; /* and no half filled blocks */      end;      return (hole); /* return FCB number of found block */   end find_exact;   /* $subtitle Storage Management:  Tape_Free */   /* This (internal) procedure searches for a free block of storage on   .  the tape drive.  It does this by looking at the first FCB in the tape   .  drive directory.  If the starting sector is not -1, it increments the   .  starting sector (which is really the starting file number) in the   .  FCB and returns an FCB which points to the original sector.  If the   .  starting sector is -1, it means the tape is full.  In this case, -1   .  is returned and C#STATUS is set to E#STORAGE.   .   .  NOTE:  It is the user's responsibility to watch for END_OF_TAPE on   .  on track LAST_TRACK (i.e., that you've run out of space).  When this   .  happens, it is necessary to update the starting sector in the first   .  FCB to -1.  If you are writing on a new track after finishing a file,   .  it is necessary to update the starting sector of the first FCB to point   .  to the first file position on this new track.  It is also the user's   .  responsibility to end every file written with a filemark by calling   .  WRITE_FILEMARK.  The routines SET_FULL and END_FILE (in file TAPEFORM)   .  will correctly perform these functions for the user. */   tape_free: proc(ms_size, ls_size) returns (fixed) recursive swappable; /* find a free block on the tape drive */      dcl (ms_size, ls_size) fixed; /* size of block to find */      dcl i                  fixed;      if not get_fcb (0, fcb) then return (-1); /* get the first fcb */            if fcb (f#ls) = -1 /* are we out of room? */      then do; /* yes, this is an error */         c#status = e#storage; /* set up global error flag (no space) */         return (-1);      end;      fcb2 (f#ls) = -1; /* initialize starting sector pointer */      i = 0; /* initialize counter */      do while ((i < shr(c#dir_size, 3) - 1) and (fcb2 (f#ls) <> 0)); /* look for the next available fcb */         i = i + 1; /* look at the next block */         call get_fcb (i, fcb2); /* read the next fcb */      end;      if fcb2 (f#ls) <> 0 /* did we find a free fcb? */      then do; /* no, this is an error */         c#status = e#dir_full; /* set global flag (no directory space) */         return (-1);      end;      fcb2 (f#ml) = ms_size; fcb2 (f#ll) = ls_size; /* set sector length of block */      fcb2 (f#ls) = fcb (f#ls); /* get the starting track and file number */      fcb (f#ls) = fcb (f#ls) + 1; /* increment file number */      call put_fcb (0, fcb); /* put back the free pointer */      call put_fcb (i, fcb2); /* and the next available block */      return (i); /* return the fcb index */   end tape_free;   /* $subtitle Storage Management:  FindFree */   /* This (internal) procedure searches the catalog buffer for a free   .  contiguous block of storage that has a size of MS_SIZE|LS_SIZE sectors.   .  If such a block is found, the FCB number of that block is returned.   .  Otherwise, a minus one (-1) is returned and C#STATUS contains   .  the reason for failure.   .   .  The algorithm proceeds as follows:   .     1. Consolidate free blocks.   .     2. Look for a perfect fit - a free block that is the exact size.   .     3. If there is no perfect fit, look for a large block and then   .        divide the block into two halves - the one nearest the front   .        of the disk is returned.   .     4. If there is no large block, see if there is enough room   .        between the last file stored and the end of the disk. */   findfree: proc(ms_size, ls_size) returns (fixed) recursive swappable; /* find contiguous free block for saving file */      dcl (ms_size, ls_size)     fixed; /* size of block to find */      dcl (x, blk, hole, ms, ls) fixed;      dcl a lit 'fcb'; dcl b lit 'fcb2'; /* rename our global FCBs */      if ms_size ige shl(1, 20 - 16) then do; /* file is larger than 2^20 sectors */         c#status = e#too_large; /* set status */         return (-1);      end;      if ((shr(c#ms_sector, 8) = 8) or (shr(c#ms_sector, 8) = 9)) /* is this the tape drive? */      then return (tape_free (ms_size, ls_size)); /* yes, use special routine */      if not consolidate then return (-1); /* consolidate free blocks */      hole = find_exact (ms_size, ls_size, true); /* look for a block the right size */      if hole = -1 then return (-1); /* no room for it in directory */      call get_fcb (hole, a); /* pick up FCB */      if ((a (f#ml) = ms_size) and (a (f#ll) = ls_size)) then return (hole); /* exact fit */      if ((ms_size igt ms_remaining) /* no room on the disk? */      or ((ms_size = ms_remaining) and (ls_size igt ls_remaining))) then do;         c#status = e#storage; /* no room */         return (-1);      end;      /* $page */      /* perfect match not found:  look for a large free area on the disk */      blk = -1; /* have not found any */      do x = 0 to shr(c#dir_size, 3) - 1; /* look again */         call get_fcb (x, a); /* get it */         if ((a (f#nm) = 0) and ((a (f#ml) igt ms_size) /* hole found that's large enough */         or ((a (f#ml) = ms_size) and (a (f#ll) ige ls_size)))) then do;            if ((blk = -1) or (a (f#ms) ilt b (f#ms)) /* use one closest to front */            or ((a (f#ms) = b (f#ms)) and (a (f#ls) ilt b (f#ls)))) then do;               blk = x; call get_fcb (blk, b); /* get block for comparisons */            end;         end;      end; /* of look again */      if blk <> -1 then do; /* one found - divide up and use it */         call get_fcb (hole, a); /* get absolute hole */         call get_fcb (blk, b); /* and get header with an empty block */         a (f#ms) = b (f#ms); a (f#ls) = b (f#ls);         a (f#ml) = ms_size;  a (f#ll) = ls_size;         b (f#ms) = b (f#ms) + ms_size;         b (f#ls) = b (f#ls) + ls_size;         if b (f#ls) ilt ls_size then b (f#ms) = b (f#ms) + 1;         b (f#ml) = b (f#ml) - ms_size;         if b (f#ll) ilt ls_size then b (f#ml) = b (f#ml) - 1;         b (f#ll) = b (f#ll) - ls_size;         call put_fcb (hole, a);         call put_fcb (blk, b);         return (hole); /* contains a block of desired size */      end;      /* check for one at end of disk */      if last_free = -1 then do; /* fill up disk */         call get_fcb (hole, a);         a (f#ms) = ms_lastfree; a (f#ls) = ls_lastfree; /* use last free block */         a (f#ml) = ms_size; a (f#ll) = ls_size; /* would you believe we just grabbed some storage */         ms = c#ms_length - ms_lastfree; /* calculate storage at end of disk */         if c#ls_length ilt ls_lastfree then ms = ms - 1;         ls = c#ls_length - ls_lastfree;         if ((ms_size igt ms) /* will not fit */         or ((ms_size = ms) and (ls_size igt ls))) then do;            c#status = e#cstorage; /* not enough contiguous space on disk */            return (-1);         end;         call put_fcb (hole, a);         return (hole);      end;      call get_fcb (last_free, a); /* half empty block at end of disk */      a (f#ml) = ms_size; a (f#ll) = ls_size; /* would you believe we just grabbed some storage */      ms = c#ms_length - a (f#ms); /* calculate storage at end of disk */      if c#ls_length ilt a (f#ls) then ms = ms - 1;      ls = c#ls_length - a (f#ls);      if ((ms_size igt ms) /* too big? */      or ((ms_size = ms) and (ls_size igt ls))) then do;         c#status = e#cstorage; /* not enough contiguous space on disk */         return (-1);      end;      call put_fcb (last_free, a);      return (last_free);   end findfree;   /* $subtitle Storage Management:  MaxFree */   /* This (internal) procedure searches the catalog buffer for the largest   .  free block.  If such an FCB is found, the file variables are set to   .  contain the relevant information and TRUE is returned.  Otherwise,   .  FALSE is returned and C#STATUS contains the reason for failure. */   maxfree: proc returns (boolean) recursive swappable; /* find largest contiguous free block */      dcl (x, blk, ms, ls) fixed;      if ((shr(c#ms_sector, 8) = 8) or (shr(c#ms_sector, 8) = 9)) then do; /* is this the tape drive? */         if not get_fcb (0, fcb) then return (false); /* get first FCB */         if fcb (f#ls) = -1 then do; /* are we out of room? */            c#status = e#storage; /* set up global error flag (no space) */            return (false);         end;         f#ms_sector = fcb (f#ms); f#ls_sector = fcb (f#ls); /* pick up starting sector */         f#ms_length = fcb (f#ml); f#ls_length = fcb (f#ll); /* and length */      end; /* of tape drive */      else do; /* not the tape drive */         if not consolidate then return (false); /* consolidate free blocks */         blk = find_exact (-1, -1, false); /* see if there are any free blocks */         if blk = -1 then return (false); /* no room for it in directory */         /* look in directory for largest free area */         fcb2 (f#ml) = 0; fcb2 (f#ll) = 0; /* zero length thus far */         blk = -1; /* have not found any */         do x = 0 to shr(c#dir_size, 3) - 1; /* look again */            call get_fcb (x, fcb); /* get it */            if ((fcb (f#nm) = 0) and ((fcb (f#ml) igt fcb2 (f#ml)) /* hole found that's large enough */            or ((fcb (f#ml) = fcb2 (f#ml)) and (fcb (f#ll) ige fcb2 (f#ll))))) then do;               blk = x; call get_fcb (blk, fcb2); /* get block for comparisons */            end;         end; /* of look again */         ms = c#ms_length - ms_lastfree; /* calculate storage at end of disk */         if c#ls_length ilt ls_lastfree then ms = ms - 1;         ls = c#ls_length - ls_lastfree;         if ((ms igt fcb2 (f#ml)) /* is the end block larger than what we found? */         or ((ms = fcb2 (f#ml)) and (ls igt fcb2 (f#ll)))) then do;            f#ms_sector = ms_lastfree; f#ls_sector = ls_lastfree; /* save starting sector */            f#ms_length = ms; f#ls_length = ls; /* save sector length */         end;         else do; /* we found the largest block */            f#ms_sector = fcb2 (f#ms); f#ls_sector = fcb2 (f#ls); /* save starting sector */            f#ms_length = fcb2 (f#ml); f#ls_length = fcb2 (f#ll); /* save sector length */         end;         f#ms_sector = f#ms_sector + c#ms_sector; /* add in catalog base */         f#ls_sector = f#ls_sector + c#ls_sector;         if f#ls_sector ilt c#ls_sector then f#ms_sector = f#ms_sector + 1;      end; /* of not a tape drive */      f#words = shl(f#ls_length, 8); /* set number of words */      return (true);   end maxfree;   /* $subtitle Catalog Utilities:  Set_Size */   /* This (internal) procedure calculates the size (in sectors) of the   .  catalog in the catalog buffer (which must be from the top level   .  of some device).  It sets C#MS_LENGTH and C#LS_LENGTH based on this   .  value.  If the size cannot be determined by this routine, then   .  C#MS_LENGTH and C#LS_LENGTH are set to the passed MS_LENGTH and LS_LENGTH. */   set_size: proc(ms_length, ls_length) recursive swappable; /* calculate device size (in sectors) */      dcl ms_length  fixed; /* MS sector length of catalog estimate */      dcl ls_length  fixed; /* LS sector length of catalog estimate */      dcl device     fixed; /* device number of catalog in memory */      dcl config_ptr fixed; /* pointer to this device's stored configuration */      dcl type       fixed; /* the device's internally coded type */      dcl ms_sectors fixed; /* MS sectors on this drive */      dcl ls_sectors fixed; /* LS sectors on this drive */      device = shr(c#ms_sector, 8); /* pick up device */      if (((c#ms_sector and "377") <> 0) or (c#ls_sector <> 0)) then do; /* if not at top level of device */         c#ms_length = ms_length; /* we don't know the size */         c#ls_length = ls_length; /* so use user's estimate */      end; /* of not at top level of device */      else if ((device = 8) or (device = 9)) then do; /* tape drive? */         c#ms_length = -1; /* the tape drive holds a lot */         c#ls_length = -1;      end;      else do; /* search the configuration */         c#ms_length = 0; c#ls_length = 0; /* initialize device size */         config_ptr = find_device (device); /* look up the device in the lowcore configuration */         if config_ptr <> 0 then do; /* if the device is there, compute how large it is */            if ((c#status = e#none) /* if no catalog errors */            and (((core(config_ptr + s#devtyp) and "2017") = "2000") or ((core(config_ptr + s#devtyp) and "2017") = "2002")))            then do; /* on a super floppy drive -- compute C#LENGTH from catalog */               /* Since the floppy being used may be an old double density               .  disk, you need to count the number of sectors accounted for               .  in the catalog.  This assumes every sector on the disk will               .  be accounted for in the catalog. */               do type = 0 to c#dir_size - 1 by 8; /* add up sectors accounted for */                  if c#bufmed = 0 /* if the catalog buffer's in main memory */                  then c#ls_length = c#ls_length + core(c#bufptr + type + c#ll);                  else do; /* it's in external memory */                     call import (c#bufptr, type, fcb2, c#len); /* read in the catalog entry */                     c#ls_length = c#ls_length + fcb2 (c#ll);                  end;               end; /* of adding up sectors accounted for */               c#ls_length = c#ls_length + shr(c#dir_size, 8); /* add in catalog */            end;            else do; /* not a super floppy -- use config info */               type = (core(config_ptr + s#devtyp) and "377"); /* get device type */               do while ((core(config_ptr + s#devtyp) and "377") = type); /* make sure we look at all entries for this device */                  if d4567_present then do; /* if they have a D4567, do it the easy way */                     write(5) = core(config_ptr + s#seccyl); /* multiply sectors/cylinder */                     write(6) = core(config_ptr + s#totcyl); /* by total cylinders */                     ms_sectors = read(4); ls_sectors = read(5); /* to get total sectors */                  end;                  else do; /* do it the hard way [this only works if both multiplicands are < 32768] */                     ms_sectors = core(config_ptr + s#seccyl)%core(config_ptr + s#totcyl); /* get MS sectors */                     ls_sectors = core(config_ptr + s#seccyl)*core(config_ptr + s#totcyl); /* and LS sectors */                  end;                  c#ms_length = c#ms_length + ms_sectors; /* add in number of sectors on this drive */                  c#ls_length = c#ls_length + ls_sectors;                  if c#ls_length ilt ls_sectors then c#ms_length = c#ms_length + 1;                  config_ptr = config_ptr + s#blklen; /* look at next entry */               end;            end;         end; /* of computing size of device */      end; /* of searching the configuration */      end set_size;   /* $subtitle Catalog Utilities:  Check_Polycache */   /* This (internal) procedure checks to see if the catalog operation   .  being performed invalidates the poly cache.  Basically, if a   .  sound file or subcatalog is being operated on, the poly cache   .  is considered invalid.  The file TYPE of the file being affected   .  is passed. */   check_polycache: proc(type) public recursive swappable; /* trash poly cache if necessary; public so pass3 finds it (special driver; internal memory only) */      dcl type fixed; /* type of file being operated upon */      if core(loc.emsize) <> 0 then do; /* no poly cache if no external memory */         if ((type = t#sound) or (type = t#lsubc) or (type = t#subc)) /* if sound file or subcatalog */         then call extset (core(loc.emarea), em.polycache, 1, false); /* invalidate the cache */      end; /* of have external memory */   end check_polycache;   /* $subtitle Catalog Caching:  Find_Cache */   /* This (internal) procedure searches the caches available for the   .  catalog at MS_SECTOR|LS_SECTOR.  If it is found, the pointer to   .  the cache is returned.  Otherwise, -1 is returned. */   find_cache: proc(ms_sector, ls_sector) returns (boolean) recursive swappable; /* search for catalog's cache */      dcl ms_sector fixed; /* device/MS sector of catalog to read */      dcl ls_sector fixed; /* LS sector of catalog to read */      dcl found     boolean; /* TRUE if we find a cache */      dcl (i, j)    fixed;      i = caches; j = 0; found = false;      do while ((j ilt max_caches) and (not found)); /* thumb through caches */         if (core(i + $_enabled) and (core(i + $_ms_sector) = ms_sector) and (core(i + $_ls_sector) = ls_sector))         then found = true; /* we found a cache for this catalog */         else do; /* keep looking */            i = i + $_vars; /* look at next cache */            j = j + 1;         end;      end; /* of thumbing through caches */      if found /* if we found it */      then return (i); /* return an absolute pointer to it */      else return (-1); /* didn't find it */   end find_cache;   /* $subtitle Catalog Caching:  Read_Cache, Write_Cache */   /* This (internal) procedure searches the caches available for the   .  catalog at MS_SECTOR|LS_SECTOR.  If one is found, the catalog is   .  read in from the cache and a boolean TRUE is returned.  Otherwise,   .  a boolean FALSE is returned and the catalog must be read in from   .  the disk. */   read_cache: proc(ms_sector, ls_sector, dir_size) returns (boolean) recursive swappable; /* search for and read in cached catalog */      dcl ms_sector fixed; /* device/MS sector of catalog to read */      dcl ls_sector fixed; /* LS sector of catalog to read */      dcl dir_size  fixed; /* word length of catalog directory */      dcl (i, j)    fixed;      i = find_cache (ms_sector, ls_sector); /* find the cache for this catalog */      if ((i <> -1) /* if we found such a cache (and it isn't just the catalog buffer), read it in */      and ((core(i + $_bufptr) <> c#bufptr) or (shr(core(i + $_bufmed), 8) <> c#bufmed))) then do;         if shr(core(i + $_bufmed), 8) = 0 then do; /* if cached in main memory */            if c#bufmed = 0 /* if the catalog buffer is in main memory */            then call blockmove (loc(core(i + $_bufptr)), loc(c#bufptr), dir_size); /* copy from main to main */            else call export (c#bufptr, 0, loc(core(i + $_bufptr)), dir_size); /* copy from main to external */         end; /* of cached in main memory */         else do; /* cached in external memory */            if c#bufmed = 0 /* if the catalog buffer is in main memory */            then call import (core(i + $_bufptr), 0, loc(c#bufptr), dir_size); /* copy from external to main */            else do j = 0 to dir_size - 1 by 16; /* copy from external to external */               call import (core(i + $_bufptr), j, fcb, 16); /* get a chunk from the cache */               call export (c#bufptr, j, fcb, 16); /* and write it to the catalog buffer */            end;         end; /* of cached in external memory */      end; /* of reading it in */      return (i <> -1); /* return whether we read in the catalog */   end read_cache;   /* This (internal) procedure searches the caches available for the   .  catalog in the catalog buffer.  If one is found, the catalog is   .  written to the cache and a boolean TRUE is returned.  Otherwise,   .  a boolean FALSE is returned and the catalog must be written to   .  the disk.  The cache search is preempted if a cache address other   .  than -1 is passed. */   write_cache: proc(i) returns (boolean) recursive swappable; /* search for and write to cached catalog */      dcl (i, j) fixed;      if i = -1 /* if we should look for the cache */      then i = find_cache (c#ms_sector, c#ls_sector); /* find the cache for this catalog */      if ((core(i + $_bufptr) = c#bufptr) and (shr(core(i + $_bufmed), 8) = c#bufmed)) /* if it's the catalog buffer */      then i = -1; /* force the catalog buffer to disk */      if i <> -1 then do; /* if we found such a cache, write it out */         if shr(core(i + $_bufmed), 8) = 0 then do; /* if cached in main memory */            if c#bufmed = 0 /* if the catalog buffer is in main memory */            then call blockmove (loc(c#bufptr), loc(core(i + $_bufptr)), c#dir_size); /* copy from main to main */            else call import (c#bufptr, 0, loc(core(i + $_bufptr)), c#dir_size); /* copy from external to main */         end; /* of cached in main memory */         else do; /* cached in external memory */            if c#bufmed = 0 /* if the catalog buffer is in main memory */            then call export (core(i + $_bufptr), 0, loc(c#bufptr), c#dir_size); /* copy from main to external */            else do j = 0 to c#dir_size - 1 by 16; /* copy from external to external */               call import (c#bufptr, j, fcb, 16); /* get a chunk from the catalog buffer */               call export (core(i + $_bufptr), j, fcb, 16); /* and write it to the cache */            end;         end; /* of cached in external memory */      end; /* of writing it out */      return (i <> -1); /* return whether we write out the catalog */   end write_cache;   /* $subtitle Treename Caching:  Store_Catalog, Retrieve_Catalog */   /* This procedure saves information about this level of the treename   .  so that it is possible traverse the same tree again without looking   .  up the addresses of the intermediate levels from the disk. */   store_catalog: proc(depth, level) recursive swappable; /* save a catalog at this DEPTH */      dcl depth  fixed; /* depth (level) of catalog we're saving */      dcl level  fixed; /* level of catalog treename starts in */      dcl (i, j) fixed;      if (path_cached and (depth > 0) and (depth <= max_depth)) then do; /* make sure we don't overflow the table */         if depth = 1 then do; /* if we're on level one */            topmost_level = level; /* remember catalog we started from */            name (0) = 0; /* no names known - point to start of NAMES */         end; /* of level one */         path_depth = depth; /* we now know about one more level */         ms_sector (depth - 1) = c#ms_sector; /* save the starting sector */         ls_sector (depth - 1) = c#ls_sector;         ms_length (depth - 1) = c#ms_length; /* save the sector length */         ls_length (depth - 1) = c#ls_length;         dir_siz   (depth - 1) = c#dir_size; /* and the directory size */         j = name (depth - 1); /* start NAMES pointer */         do i = 0 to shr(f#name (0) + 1, 1); /* copy the name into global area */            if j >= max_depth*(f#name_len + 1) /* did we overflow? */            then do; /* yes, clean up */               path_depth = depth - 1; /* we know about one less level */               i = f#name (0); /* spring out of this loop */            end;            else do; /* no overflow - copy the name over */               names (j) = f#name (i); /* word for word */               j = j + 1; /* point to next available word */            end;         end; /* of copying name into global area */         if depth < max_depth /* if next one still in range */         then name (depth) = j; /* save start of next name */      end; /* of not overflowing table */   end store_catalog;   /* This procedure retrieves information about the current level of the   .  treename if said information was previously saved.  A boolean TRUE   .  is returned if the information was retrieved. */   retrieve_catalog: proc(depth, level) returns (boolean) recursive swappable; /* search for and load a saved catalog at this DEPTH */      dcl depth   fixed; /* depth (level) of catalog we're looking for */      dcl level   fixed; /* level of catalog treename starts in */      dcl matched boolean; /* TRUE if F#NAME matches the previously saved name at the same depth */      dcl i       fixed;      if (path_cached and (depth > 0) and (depth <= path_depth) /* is there a known catalog at this level? */      and (f#name (0) = names (name (depth - 1)))) /* and can the names match? */      then do; /* yes, see if it matches */         matched = true; i = 0; /* assume a match */         do while (matched and (i < f#name (0))); /* see if the name matches at this level */            if byte(f#name, i) <> byte(loc(addr(names (name (depth - 1)))), i)            then matched = false; /* no match */            i = i + 1;         end;         if depth = 1 /* are we on the first level? */         then matched = (matched and (topmost_level = level)); /* yes, this is dependent on the start */         if matched /* did they match? */         then do; /* yes, get the catalog location */            c#ms_sector = ms_sector (depth - 1); /* retrieve the starting sector */            c#ls_sector = ls_sector (depth - 1);            c#ms_length = ms_length (depth - 1); /* retrieve the starting sector */            c#ls_length = ls_length (depth - 1);            c#dir_size  = dir_siz   (depth - 1); /* and the directory size */         end;      end; /* of known catalog at this level */      else matched = false; /* no known catalog at this level */      return (matched); /* return whether we found a match and loaded location */   end retrieve_catalog;   /* $subtitle Treename Scanning:  Search */   /* This procedure finds the file pointed to by TREENAME (starting at   .  character position INDEX).  The search commences from the catalog   .  specified by LEVEL.  A boolean TRUE is returned is the catalog   .  containing the file is found.  The search proceeds as follows:   .     1) Scan a SUBNAME off the TREENAME (SUBNAME delimited by a colon or end of string).   .     2) Find SUBNAME in last catalog read.   .     3) If a colon was found, goto 1. with catalog SUBNAME in catalog buffer.   .   .  At the conclusion of a successful search, F#NAME contains the name   .  of the final file and the catalog variables are set to the catalog   .  containing the final file.  The final file is NOT located. */   dcl readcat  proc(fixed, fixed, fixed, fixed, fixed) returns (boolean) recursive; /* read catalog routines */   dcl readdir  proc(fixed array) returns (boolean) recursive;   dcl read_cat proc(fixed) returns (boolean) recursive;   search: proc(treename, index, level, catalog) returns (boolean) swappable; /* open the passed treename starting in the specified catalog */      dcl treename fixed array; /* treename of file to find */      dcl index    fixed; /* character of treename to start scan from */      dcl level    fixed; /* catalog number of catalog to start looking in */      dcl catalog  boolean; /* TRUE if we're reading a catalog, rather than finding a file */         /* This procedure scans the next filename off of the treename.  This      .  filename is converted to uppercase and stored in F#NAME.  A boolean      .  TRUE is returned if a COLON was found after the name.  Otherwise,      .  a boolean FALSE is returned. */      scan_name: proc returns (boolean) recursive; /* scan the next SUBNAME from TREENAME */         dcl sublen fixed; /* subname length */         dcl c      fixed; /* next character from treename */         dcl colon  boolean; /* TRUE if we find a colon */         sublen = 0; /* initialize the character count */         colon = false; /* no colon found yet */         do while ((index < treename (0)) and (sublen <= shl(f#name_len, 1)) and (not colon)); /* scan off the name */            if byte(treename, index) = a.colon /* is this a colon? */            then colon = true; /* yes, remember we found it */            else do; /* we didn't find it - keep copying */               if sublen < shl(f#name_len, 1) then do; /* make sure we don't overflow SUBNAME (need to go one past to get the COLON) */                  c = byte(treename, index); /* get next character from treename */                  if c - l.a ile (l.z - l.a) then c = c - (l.a - a.a); /* uppercase it */                  call pbyte(f#name, sublen, c); /* copy the character into SUBNAME */               end;               else index = index - 1; /* don't pont past this character if we didn't process it */               sublen = sublen + 1; /* count characters in SUBNAME */            end;            index = index + 1; /* point to next character in TREENAME */         end;         if sublen > shl(f#name_len, 1) /* the filename or catalog name must be <= 2*F#NAME_LEN chars long */         then sublen = shl(f#name_len, 1); /* so truncate it */         f#name (0) = sublen; /* set the character length */         return (colon); /* return whether we found a colon */      end scan_name;      /* $page */      dcl depth   fixed automatic; /* current pathname level being processed */      dcl start   fixed automatic; /* starting value of INDEX */      dcl colon   boolean automatic; /* TRUE if we scan a colon */      dcl matched boolean automatic; /* TRUE if we have a known catalog at DEPTH */      dcl found   boolean automatic; /* TRUE if we've found the specified file */      depth = 1; /* the default first level is the specified catalog */      start = index; /* save starting value of index */      matched = true; /* assume match to read in first catalog */      found = true; /* assume we've found the file */      do while (found and (index < treename (0))); /* open every level of the treename */         colon = scan_name; /* scan off next name */         if (((not colon) and (index < treename (0))) /* if there's no colon after an intermediate name */         or (colon and (index = treename (0)) and (index <> start + 1)) /* or there's a colon at the end (except leading colons) */         or ((f#name (0) = 0) and (index <> start + 1))) then do; /* or there's a missing name in the middle */            c#status = e#treename; /* incorrect format for treename */            found = false; /* didn't find it */         end;         else if f#name (0) = 0 then depth = 0; /* start from the top w/leading colon */         else do; /* look up next name */            if ((colon or catalog) and retrieve_catalog (depth, level)) then do; /* if this isn't the last name */               if not colon then do; /* if no colon, must be last cat of a cat lookup */                  if not readcat (c#ms_sector, c#ls_sector, c#dir_size, c#ms_length, c#ls_length) then return (false);               end;               matched = true; /* we retrieved a known catalog from this level */            end; /* of if isn't last name */            else do; /* force a READ CATALOG at end or if no match */               if matched then do; /* if previous name matched and this one doesn't, haven't read in cat yet */                  if depth = 1 then do; /* if haven't read in starting cat yet */                     if not read_cat (level) then return (false); /* read in first catalog */                  end;                  else do; /* read in catalog from last level */                     if not readcat (c#ms_sector, c#ls_sector, c#dir_size, c#ms_length, c#ls_length) then return (false);                  end;               end; /* of previous name matched; read in first cat */               matched = false; /* no match */            end;            if ((colon or catalog) and (not matched)) then do; /* if don't have a known catalog at this level */               if readdir (f#name) /* find/read in the catalog */               then call store_catalog (depth, level); /* keep the catalog table up to date */               else found = false; /* probably not there */            end; /* of no known catalog at this level */         end; /* of look up next name */         depth = depth + 1; /* we're about to scan another level */      end; /* of opening every level of treename */      if depth = 1 then do; /* if haven't read in top level yet (i.e., TREENAME = ':') */         if not read_cat (level) then return (false); /* read in first catalog */      end;      return (found); /* return whether or not we found it */   end search;   /* $subtitle Treename Scanning:  Device_Specified */   /* This procedure identifies any device specification in the TREENAME   .  and returns the level number associated with that device.  If no   .  device is specified, a zero is returned. */   device_specified: proc(treename) returns (fixed) public recursive swappable; /* get any remote device specification */      dcl treename fixed array; /* treename to scan device from */      dcl c        fixed; /* next device name character */      dcl i        fixed;      if ((treename (0) < 3) or (byte(treename, 2) <> a.colon)) /* device is 2 chars and a colon */      then return (0); /* no device specified */      f#name (0) = 2; f#name (1) = treename (1); /* pick up suspected device name */      c = byte(f#name, 0); /* get first character */      if c - l.a ile (l.z - l.a) then c = c - (l.a - a.a); /* uppercase it */      call pbyte(f#name, 0, c); /* replace first character uppercased */      if      c = a.f then i = 2; /* floppy? */      else if c = a.r then i = 4; /* remote? */      else if c = a.w then i = 6; /* winchester? */      else if c = a.t then i = 8; /* tape? */      else return (0); /* no device specified */      c = byte(f#name, 1); /* get second character */      if      c =  a.1 then i = (i or 1); /* or in drive bit if drive one */      else if c <> a.0 then return (0); /* if not zero, no device specified */      return (i); /* we found a legal device specification - return device */   end device_specified;   /* $subtitle Treename Scanning:  Get_Catalog */   /* This procedure gets the catalog that contains the file specified by   .  TREENAME.  The search begins on LEVEL.  If a device name is specified   .  in the treename, it overrides the passed level number.  If the catalog   .  is found, a boolean TRUE is returned, the catalog variables contain   .  information about this catalog, and F#NAME is the name of the file.   .   .  The algorithm for finding the catalog is:   .     1) If a device name is specified, start search on THAT device.   .     2) Else if treename starts with a colon, start search on the   .        device the specified catalog (LEVEL) is stored on.   .     3) Else start search on specified catalog (LEVEL). */   get_catalog: proc(treename, level, catalog) returns (boolean) recursive swappable; /* get last catalog of TREENAME starting at LEVEL */      dcl treename fixed array; /* the treename of the file to locate */      dcl level    fixed; /* level of catalog to start searching from (ignored in device specified in TREENAME) */      dcl catalog  boolean; /* TRUE if we're reading a catalog, rather than finding a file */      dcl index    fixed; /* initial character index into TREENAME */      dcl device   fixed; /* number of any specified device */      dcl found    boolean; /* TRUE if we find the file */      c#status = e#none; /* no errors yet */      f#name (0) = 0; /* there is no name either */      if treename (0) = 0 then do; /* check for an empty treename */         c#status = e#treename; /* this is invalid */         found = false; /* didn't find it */      end;      else do; /* there's a treename */         index = 0; /* start at beginning of treename */         device = device_specified (treename); /* pick up any device specified */         if device <> 0 then do; /* if a device name was specified */            level = device; /* start searching on specified device */            index = 2; /* start scanning after device name */         end;         else do; /* no device name specified */            if level < 2 /* if special level (actually, 0 and 1 aren't special, but we need this info) */            then do case (level + 2); /* determine device number of specified catalog */               device = shr(core(loc.pcat + 1), 8); /* path catalog */               device = shr(a#ms_sector, 8); /* alternate catalog */               device = shr(core(loc.scat + 1), 8); /* system catalog */               device = shr(core(loc.ucat + 1), 8); /* user catalog */            end; /* of decoding device number of specified catalog */            else device = level; /* level number matches the device number here */            if byte(treename, 0) = a.colon /* if name starts with colon */            then level = device; /* use device number of specified catalog */         end; /* of no device name specified */         if find_device (device) = 0 then do; /* if the specified device isn't configured */            c#status = e#no_config; /* don't start scanning */            found = false; /* needless to say, we didn't find the file */         end;         else found = search (treename, index, level, catalog); /* open file on LEVEL; start scanning at INDEX */      end; /* of there's a treename */      return (found); /* return whether we found it */   end get_catalog;