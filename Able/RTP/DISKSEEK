TTL DISK I/O ROUTINES:  DEVICE HANDLERS, SEEK, AND SELECT**Find device entry corresponding to a logical device number.  The logical*device number is encoded into internal format before searching the*configuration.**Logical device numbers are as follows:*   0: System device (represented by first entry in storage device table)*   1: Current device (encoded device number just before storage device table)*   2: F0 - floppy 0*   3: F1 - floppy 1*   4: R0 - remote 0*   5: R1 - remote 1*   6: W0 - winchester 0*   7: W1 - winchester 1*   8-15: user devices**Note that the LSB of each logical code represents a drive number while*the rest of the code represents a class of device.  This happens to be*coincidental, but the code takes advantage of this fact.  If this changes,*the code must also change.**Encoded device numbers are formatted as follows:*   bits  0-3: Device type (0: floppy, 1: winchester, 2: remote)*   bits  4-7: Drive number (currently only zero or one)*   bits 8-15: Zero**This routine is called with:*  R0: Logical device number**This routine returns:*  R0: Pointer to STRDEV entry or zero if no such device (not configured or invalid)**Registers trashed:  R0, R1, R2*R.FDE: data Z.FDE find device entry in configurationif ModelCD10 to MR12 stack returnendifR0 to R1 save R0im(-1) to R2 assume R0 contains an invalid logical device numberim(^1) to AND0 remove drive bit (LSB)re(A.FDE) to RTNZ direct physical device mapping if non-zero**passed arg is 0 or 1; see which*PCI to R2 point to current device - system device follows immediatelydata CONTAB+CURDEVim(1) to TAND1 see if the drive bit is set in the logical device numberim(1) to RTNZ it's set - R2 already points to the current deviceR2I to ATNV increment R2 to point to the system device [im(STRDEV-CURDEV) to ADD2]MR2 to R2 pick up the requested device (e.g curdev if arg == 1; else first word of storage table)PCI to AND2 make sure we keep just the device codedata 377re(C.FDE) to RTRA and find that deviceA.FDE: im(2) to TSUB0 first check if it's a floppyim(2) to RTNZ no, keep checkingim(0) to R2 yes, set floppy devicere(B.FDE) to RTRA and go tack on drive numberim(4) to TSUB0 next check for remoteim(2) to RTNZ no, keep checkingim(2) to R2 yes, set remote devicere(B.FDE) to RTRA and go tack on drive numberim(6) to TSUB0 now check for Winchesterre(G.FDE) to RTNZ no, it isn't a valid logical device number - check user devicesim(1) to R2 yes, set Winchester devicere(B.FDE) to RTRA and go tack on drive numberG.FDE: im(10) to SUB0 normalize device number (8 -> 0)im(0) to SHRA0 and turn into a table pointerim(DEVDRS) to TSUB0 see if entry number is in boundsre(E.FDE) to RTRC out of range - fatal errorim(DEVDRV) to ADD0 device codes follow device driver pointersPCI to R3 get pointer to device driver table pointerdata CONTAB+DEVTABMR3 to TLOA0 see if there's a tablere(E.FDE) to RTZE if no table, we have a fatal errorMR3 to ADD0 point to table entry for our device's driverMR0 to LOA0 pick up pointer to device typere(E.FDE) to RTZE if no pointer, we have a fatal errorMR0 to LOA2 pick up device type of requested deviceB.FDE: im(1) to TAND1 is drive bit set?re(C.FDE) to RTZE no, the drive number is zeroim(20) to ADD2 yes, the drive number is one - ADD it inEJECT**Now look for the encoded device in the configuration*C.FDE: PCI to R0 pick up pointer to first entry (or thereabouts)data CONTAB+STRDEV-BLKLEND.FDE: im(BLKLEN) to ADD0 point to next entryPCI to TSUB0 see if past the enddata CONTAB+STRENDre(E.FDE) to RTZE device not in table - get outMR0 to R1 pick up device codePCI to AND1 extract just the codedata 377 lower byteR1 to TSUB2 see if this is the device we're looking forre(D.FDE) to RTNZ it isn't - keep lookingR0 to LOA0 set flags for returnre(F.FDE) to RTRA found it - returnE.FDE: im(0) to LOA0 error returnF.FDE: ... return hereRETURN to ATRA and returnZ.FDE: data 0 end of segment, no patches**Set the current device.**This routine is called with:*  R0: Logical device number to set the current device to**This routine returns:*  R0: Success flag*      0: current device NOT set (either invalid device or not configured)*      1: current device set**Registers trashed:  R0, R1, R2*R.SCUR: data Z.SCUR set current deviceif ModelCD10 to MR12D stack returnendifJUMP to PROC find the device in the configurationA.SCUR: data 0 pointer to routinere(B.SCUR) to RTZE if zero, bad device number passedMR0 to R0 pick up device typePCI to AND0 keep just the typedata 377PCI to R1 get pointer to current devicedata CONTAB+CURDEVR0 to MR1 and save the new current deviceim(1) to LOA0 make sure we return TRUEB.SCUR: ... return hereif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and returnZ.SCUR: data A.SCUR start of patch listdata L.FDE find device entrydata 0 end of patch listEJECT**FLOPPY DISK SEEK ROUTINE:**THE FOLLOWING ROUTINE IS USED TO POSITION THE HEAD OVER A GIVEN TRACK*OF THE FLOPPY DISK.  THIS ROUTINE TURNS THE MOTOR ON.**IT IS CALLED FROM THE READ & WRITE ROUTINES WITH:*  R1 = SECTOR NUMBER (NOT AFFECTED BY SEEK)*  R2 = POINTER TO MEMORY (NOT AFFECTED BY SEEK)*  R3 = NUMBER OF WORDS TO READ/WRITE FROM DISK (NOT USED BY SEEK)*  R4 = FLAGS (256*POLY/EXTERNAL + 512*SPECIAL)/PREVIOUS DRIVE INFO*  R5 = 0: USE NORMAL SPEED, 1: USE ALTERNATE SPEED (IF THERE IS ONE)*  R7 = POINTER TO DEVICE'S STORAGE DEVICE TABLE (STRDEV) ENTRY (NOT AFFECTED BY SEEK)**"SEEK" RETURNS WITH:*  R0 = 0 IF NO SEEK WAS PERFORMED, OR 4 IF WE DID A SEEK*  R4 = DRIVE + 2*SIDE + 4*DENSITY + 8*RATE + 16*PRECOMP + 32*MOTOR SPEED + 32K*D100A*  R5 = TRACK NUMBER*  R6 = SECTOR NUMBER, STARTS WITH ONE* R10, R11 = TRASHED*  R.SEE:DATA Z.SEE POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(-20) TO D1 DISABLE INTERRUPTS HERE; READ OR WRITE WILL TURN THEM ON AGAINR1 to R11 preserve R1R2 to R6 preserve R2MR7 to R0 pick up device typeim(1) to R1 assume drive onePCI to TAND0 isolate drive numberdata 360 (drive number is the upper nibble of the lower byte)im(1) to RTNZ non-zero, assume one (larger drive numbers may someday be supported)im(0) to R1 zero, must be drive zeroR4 to R2 get previous speed (0: normal, 1: alternate)PCI to AND2 only keep alternate bitdata 40im(1) to RTZE normal speedim(1) to R2 alternate speedim(0) to R10 assume same speedR5 to SUB2 see if we're requesting a change in speedim(1) to RTZE no change in speedim(1) to R10 we are changing the drive speedR4 to R2 pick up flagsim(^1) to AND2 keep everything but first bitR10 to OR2 set first bit based on speed change flagR2 to R10 and put back in R10PCI to TAND0 see if alternate speed on drivedata 2000re(T.SEE) to RTZE no alternate motor speed on driveR5 to TLOA0 see if we want alternate motor speedre(T.SEE) to RTZE no, don't set itPCI to OR1 set alternate motor speeddata 40PCI to TAND0 check alternate ratedata 4000im(1) to RTZE 5" rateim(10) to OR1 8" rateim(5) to R2 set 5 sectors/track (old disks)R1 to R4 set drive info asidePCI to RTRA and go compute track and sectordata U.SEE-.-1EJECT**CALC DRIVE, TRACK, SECTOR, POINTER*T.SEE: R1 to R4 move drive info to R4R7 to R0 move device table pointer to R0im(SECCYL) to ADD0 point to sectors/cylinderMR0 to R2 set it asideim(0) to R1 set default drive IDMR7 to R0 main or remote drives?im(17) to AND0 extract drive type (0: floppy, 1: remote)re(A.SEE) to RTNZ non-zero means remotesD51 to R0 pick up device identifier bitsPCI to TAND0 see if floppy controller is D100Adata 10000re(D.SEE) to RTZE no, can't read drive IDR4 to D104 select driveD104 to R1 get drive IDre(H.SEE) to RTRAA.SEE: D51 to R0 pick up device identifier bitsPCI to TAND0 see if remote controller is D110Adata 20000re(D.SEE) to RTZE no, can't read drive IDR4 to D114 select driveD114 to R1 get drive IDH.SEE: R4 to R0 get drive infoPCI to OR0 set sign bit to signify D100Adata 100000R0 to R4D.SEE: R4 to R0 get drive infoim(4) to TAND1 see if precomp is required by this driveim(1) to RTNZ noim(20) to OR0 yes, OR it inim(10) to AND1 get rate bitR1 to OR0 and OR it inMR7 to R1 get config bitsPCI to TAND1 check densitydata 400im(1) to RTZE already setim(4) to OR0 set densityPCI to TAND1 check rate override (for 8" drives)data 1000im(1) to RTZE no overrideim(10) to OR0 override to 8" rateR0 to R4 set drive info asideU.SEE: R11 to R1 and restore sector numberIM(-1) TO R0 COMPUTE REQUESTED TRACK NUMBERIM(1) TO ADD0 INCREMENTR2 TO SUB1 COMPUTE TRACK (CYLINDER) NUMBERIM(-3) TO RTRC IF CARRY THEN >= SECTORS/CYLINDER, SO SUBTRACT ONE MORER0 TO R5 SAVE TRACK NUMBER IN R5R2 TO ADD1 RESTORE REMAINDER (SECTOR NUMBER ON CYLINDER)R4 to R0 check if alternate speed is setPCI to TAND0 is it?data 40re(I.SEE) to RTNZ yes, can't be double-sidedR7 to R0 point to device table entryim(SPDTRK) to ADD0 point to sectors/trackMR0 to R0 pick it upim(0) to BSOR0 move to lowerPCI to AND0 and extract itdata 377R0 to TSUB1 see if sector number is greater than SECPTre(I.SEE) to RTMI no, side zeroR0 to SUB1 restrict the sector number to within SECPTR4 to R0 pick up drive infoim(2) to OR0 set side oneR0 to R4 and restore drive infoI.SEE: R6 TO R2 RESTORE R2 HEREIM(1) TO ADD1 INCREMENT IT - STARTS WITH 1R1 TO R6 AND THIS IS STORED IN R6EJECT**Change motor speeds on the drive*R10 to R0 pick up flagsPCI to AND0 keep global flags onlydata 177400R4 to OR0 add in drive infoR0 to R4 and store back in flags/drive infoR10 to R0 pick up flags againim(1) to TAND0 see if we need to change speedsre(V.SEE) to RTZE no, we don'tR4 to R1 pick up drive infoim(1) to XOR1 select other driveMR7 to R0 pick up device typeim(17) to TAND0 see if floppy or remoteim(4) to RTNZ if non-zero must be remote (only zero and two are allowed)R1 to D104 select other drive on controllerim(1) to XOR1 now select our driveR1 to D104 like soim(3) to RTRAR1 to D114 select other drive on controllerim(1) to XOR1 now select our driveR1 to D114 like soPCI to R0 pick up 500 ms count at 100 Hz (50 ticks)if ^ModelCdata 62+1 (one extra to sync to D3)endifif ModelCdata 62+1-1 (one extra to sync to D3)endifPCI to R1 get pointer to clock speeddata CONTAB+CMOPTMR1 to R1 pick up clock speed wordim(7) to AND1 extract speed bits - assume only zero or one for nowim(1) to RTZE skip for 100 HzR0 to ADD0 set up for 200 Hz (twice as long)if ^ModelCIM(0) TO D3 WAIT 5 MSIM(1) TO SUB0 COUNT HOW LONGIM(-3) TO RTNZ LOOP IF NOT DONE YETendifif ModelCR0 to D10 wait 500 msim(0) to D3 wait 5 msendifEJECT**SEEK OPERATION:**WE HAVE COMPUTED THE DRIVE AND TRACK NUMBER.  NOW PERFORM THE SEEK COMMAND*TO POSITION THE HEAD OVER THE TRACK*V.SEE: R11 TO R1 AND RESTORE DEVICE ADDRESS INTO R1PCI TO R11 FIRST GET PTR TO HEAD POSITION POINTERDATA CONTAB+CURTRKR4 TO R0 GET DRIVE/SIDE SELECTIONIM(1) TO AND0 EXTRACT THE DRIVE NUMBERMR11 TO ADD0 POINT TO HEAD POSITION OF DRIVE WE'RE SELECTINGR0 TO R11 AND SAVE POINTER TO CURRENT TRACK NUMBERR7 to R0 get storage device table entry pointerim(TOTCYL) to ADD0 point to total cylindersR0 to R10 and set that asideMR7 TO R0 NOW SEE IF WE'RE SEEKING THE MAINS OR THE REMOTESIM(17) TO AND0 EXTRACT DEVICE TYPE (0: FLOPPY, 2: REMOTE - NO OTHERS ARE VALID!)PCI TO RTNZ NON-ZERO MEANS REMOTESDATA M.SEE-.-1 GO TO REMOTE SEEKD100 TO R0 READ STATUS TO MAKE SURE RESTORE OPERATION IS COMPLETEDIM(1) TO TAND0 BY SEEING IF BUSYIM(-3) TO RTNZ IF STILL BUSY, GO BACKR5 TO R0 GET DESIRED TRACKMR10I TO TSUB0 SEE IF OUT OF RANGE, POINT TO STEPPING SPEED/SECTORS PER TRACKRE(B.SEE) TO RTMI IF MINUS, THEN OKIM(7) TO D50 RING BELLIM(10) TO R0 CALL WHEN STATEMENT #8 - DISKERRORJUMP TO PROC CALL BRK ROUTINEF.SEE:DATA 0 PTR TO R.BRKIM(-5) TO RTRA AND LOOP INDEFINITELYB.SEE:R4 TO D104 TURN ON MOTOR AND SELECT SIDEMR11 TO D101 LOAD TRACK REGISTER WITH WHERE WE THINK WE ARED101 TO SUB0 CHECK BIG CHIP, AND SEE IF SEEK IS REQUIREDRE(S.SEE) TO RTNZ IF WE MUST PERFORM SEEK,  THEN DO ITIM(0) TO LOA0 INDICATE NO SEEK PERFORMEDif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and return to caller*S.SEE: MR10 TO R0 PICK UP STEPPING SPEED WORDPCI TO AND0 EXTRACT STEPPING SPEEDDATA 377R0 TO R10 AND SET ASIDEE.SEE:... RE-ENTER TO RETRY SEEK IN CASE OF INCORRECT TRACK REGR5 TO D103 AND LOAD DATA REGISTER WITH DESIRED TRACK NUMBERIM(20) TO R0 GET BASIC SEEK COMMANDR10 TO OR0 OR IN STEPPING SPEEDR0 TO D100 ISSUE THE SEEK COMMAND*C.SEE:D100 TO R0 GET THE STATUSPCI TO TAND0 CHECK NOT READYDATA 200IM(1) TO RTNZ IF NOT READY, DO NOT RE-TRIGGER MOTOR ON PULSER4 TO D104 IF BECAME READY DURING SEEK, KEEP MOTOR ON DURING SEEKIM(1) TO TAND0 CHECK BUSYRE(C.SEE) TO RTNZ IF BUSY, THEN LOOP BACK**CHECK FOR CORRECT TRK REG (BAD BIG CHIP)*R5 TO R0 GET DESIRED TRACKD101 TO SUB0 SHOULD BE EQUALRE(E.SEE) TO RTNZ RE-SEEK IF INCORRECT LOAD OF BIG CHIP**SEEK WAS PERFORMED:*D101 TO MR11 READ TRACK REGISTER, STORE IN OUR POSITION KEEPERIM(4) TO LOA0 RETURN A 4 TO INDICATE SEEK PERFORMEDif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and return to callerEJECT**REMOTE FLOPPY SEEK (IDENTICAL TO NORMAL SEEK EXCEPT USES D110 INSTEAD OF D100)*M.SEE:R11 TO ADD0 R0 IS TWO HERE - POINT TO REMOTE HEAD POSITIONSR0 TO R11 AND SET THAT ASIDED110 TO R0 READ STATUS TO MAKE SURE RESTORE OPERATION IS COMPLETEDIM(1) TO TAND0 BY SEEING IF BUSYIM(-3) TO RTNZ IF STILL BUSY, GO BACKR5 TO R0 GET DESIRED TRACKMR10I TO TSUB0 SEE IF OUT OF RANGE, POINT TO STEPPING SPEED/SECTORS PER TRACKRE(N.SEE) TO RTMI IF MINUS, THEN OKIM(7) TO D50 RING BELLIM(10) TO R0 CALL WHEN STATEMENT #8 - DISKERRORJUMP TO PROC CALL BRK ROUTINEG.SEE:DATA 0 PTR TO R.BRKIM(-5) TO RTRA AND LOOP INDEFINITELYN.SEE:R4 TO D114 TURN ON MOTOR AND SELECT SIDEMR11 TO D111 LOAD TRACK REGISTER WITH WHERE WE THINK WE ARED111 TO SUB0 CHECK BIG CHIP, AND SEE IF SEEK IS REQUIREDRE(O.SEE) TO RTNZ IF WE MUST PERFORM SEEK,  THEN DO ITIM(0) TO LOA0 INDICATE NO SEEK PERFORMEDif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and return to caller*O.SEE: MR10 TO R0 PICK UP STEPPING SPEED WORDPCI TO AND0 EXTRACT STEPPING SPEEDDATA 377R0 TO R10 AND SET ASIDEP.SEE:... RE-ENTER TO RETRY SEEK IN CASE OF INCORRECT TRACK REGR5 TO D113 AND LOAD DATA REGISTER WITH DESIRED TRACK NUMBERIM(20) TO R0 GET BASIC SEEK COMMANDR10 TO OR0 OR IN STEPPING SPEEDR0 TO D110 ISSUE THE SEEK COMMAND*Q.SEE:D110 TO R0 GET THE STATUSPCI TO TAND0 CHECK NOT READYDATA 200IM(1) TO RTNZ IF NOT READY, DO NOT RE-TRIGGER MOTOR ON PULSER4 TO D114 IF BECAME READY DURING SEEK, KEEP MOTOR ON DURING SEEKIM(1) TO TAND0 CHECK BUSYRE(Q.SEE) TO RTNZ IF BUSY, THEN LOOP BACK**CHECK FOR CORRECT TRK REG (BAD BIG CHIP)*R5 TO R0 GET DESIRED TRACKD111 TO SUB0 SHOULD BE EQUALRE(P.SEE) TO RTNZ RE-SEEK IF INCORRECT LOAD OF BIG CHIP**SEEK WAS PERFORMED:*D111 TO MR11 READ TRACK REGISTER, STORE IN OUR POSITION KEEPERIM(4) TO LOA0 RETURN A 4 TO INDICATE SEEK PERFORMEDif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and return to caller*Z.SEE: DATA F.SEE BEGIN PATCH LISTDATA L.BRK BREAKDATA G.SEEDATA L.BRK BREAKDATA 0 END OF SEGMENTEJECT**ROUTINE TO SELECT WINCHESTER DISK:**WINCHESTER DISK IS ACCESSED THROUGH DEVICE ADDRESS 105,106,107*THIS ROUTINE IS CALLED WITH:*  R0 = SECTOR MSB*  R1 = SECTOR LSB*  R2 = BUFFER POINTER*  R3 = LENGTH TO READ OR WRITE*  R7 = POINTER TO DEVICE ENTRY TO START WITH IN STORAGE DEVICE TABLE (STRDEV)**IT RETURNS WITH:*  R0 = FREE*  R1 = FREE*  R2 = BUFFER POINTER (NOT AFFECTED BY WSL)*  R3 = LENGTH (NOT AFFECTED BY WSL)*  R4 = NEWLY COMPUTED SECTOR MSB*  R5 = NEWLY COMPUTED SECTOR LSB*  R6 = SECTOR MSB, IN SPECIAL IMI FORMAT*  R7 = POINTER TO DEVICE ENTRY FOR SELECTED PHYSICAL DEVICE (IN THE LOGICAL SET)*  R11= NEGATIVE NUMBER OF SECTORS LEFT ON DRIVE*R.WSL:DATA Z.WSL POINTER TO END OF SEGMENTif ModelCD10 to MR12 stack returnendifR2 TO R11 PRESERVE R2R3 TO R6 PRESERVE R3MR7 TO R2 PICK UP DEVICE TYPE OF THE DESIRED LOGICAL DEVICEPCI TO AND2 EXTRACT JUST THE DEVICE TYPEDATA 377R7 TO R3 MAKE R3 POINT TO THE PROPER DEVICE ENTRYR2 TO R7 AND MAKE R7 THE DEVICE TYPE OF THE DESIRED LOGICAL DEVICE**FIND DRIVE*C.WSL: PCI TO TSUB3 ARE WE AT THE END OF THE TABLE?DATA CONTAB+STRENDRE(B.WSL) TO RTNZ NOT YET, KEEP LOOKINGA.WSL: IM(7) TO D50 AT END OF LOGICAL LIST - BEEP FOREVERIM(10) TO R0 SPECIFY DISKERRORJUMP TO PROC CALL BREAK ROUTINEH.WSL: DATA 0 POINTER TO BREAK ROUTINERE(A.WSL) TO RTRA LOOP FOREVERB.WSL: MR3 TO R2 PICK UP DEVICE TYPEPCI TO AND2 EXTRACT JUST THE DEVICE TYPEDATA 377R7 TO TSUB2 IS THIS THE SAME LOGICAL DEVICE?RE(A.WSL) TO RTNZ NO, SECTOR OUT OF BOUNDSR1 TO D5 DIVIDE STARTING SECTORR0 TO D4R3 TO R2 BY SECTORS/CYLINDERIM(SECCYL) TO ADD2MR2I TO D7 PERFORM DIVIDE TO GET CYLINDER NUMBER, POINT TO TOTAL CYLINDERSD5 TO R0 GET CYLINDER NUMBER (MUST BE < 64K)MR2 TO TSUB0 SEE IF CYLINDER IS PAST THE END OF THIS DRIVERE(D.WSL) TO RTNC IF NO CARRY, THEN CYLINDER IS ON THIS DRIVEMR2 TO SUB0 REDUCE CYLINDER COUNTD4 TO R1 SAVE REMAINDER FROM ABOVE DIVISIONR0 TO D5 MULTIPLY NEW LOGICAL CYLINDER NUMBER BY SECTORS/CYLINDERR1 TO D4 AND ADD IN SECTOR REMAINDERIM(SECCYL-TOTCYL) TO ADD2 MOVE POINTER BACK TO SECTORS/CYLINDERMR2 TO D6 PERFORM THE MULTIPLICATIOND5 TO R1 AND MOVE NEW LOGICAL SECTOR NUMBER TO R0/R1D4 TO R0IM(BLKLEN) TO ADD3 SKIP TO NEXT ENTRYRE(C.WSL) TO RTRA GO BACKEJECT*D.WSL: R3I TO R7 UPDATE ENTRY POINTER, POINT TO SECTORS/CYLINDER FOR THIS DEVICER3 TO R1 MOVE THAT TO R1R6 TO R3 RESTORE R3R11 TO R2 AND R2R1I TO R11 MOVE SECTORS/CYLINDER TO R11, POINT TO TOTAL CYLINDERSD4 TO R6 SAVE REMAINDER OF DIVISION (SECTOR # ON THIS CYLINDER)R0 TO D5 LOAD CYL NUMBER INTO MULTIPLIERR6 TO D4 THIS NUMBER IS ADDED INMR11 TO D6 MULTIPLY OUT TO GET SECTOR NUMBER, POINT TO TOTAL CYLINDERSD4 TO R4 GET SECTOR NUMBER ON THIS DRIVE IN R4, R5D5 TO R5**COMPUTE REMAINDER*MR1I TO SUB0 GET NEGATIVE NUMBER OF CYLINDERS REMAINING ON DISKPCI TO TADD0 LIMIT TO 512 TO AVOID OVERFLOWSDATA 1000IM(2) TO RTRC IF CARRY, THEN LESS THAN 512 CYLINDERS LEFTPCI TO LOA0 ELSE LIMIT TO 512DATA 177000 -512R0 TO D5 MULTIPLYMR11 TO D6 BY SECTORS PER CYLINDERD5 TO R0 GET REMAINING SECTORSR6 TO ADD0 LESS SECTOR WE ARE STARTING WITH ON THIS CYLINDERR0 TO R11 AND RETURN THIS IN R11**SELECT WINCHESTER DRIVE* MR1 TO D105 SELECT WINCHESTER CONTROLLER CARD (LOWER HALF INFO)D105 TO R0 MAKE SURE BOARD EXISTSIM(10) TO TAND0 LOOK FOR BITre(G.WSL) TO RTNZ SHOULD BE NONZEROIM(7) TO D50 beepim(10) to R0 indicate diskerrorJUMP TO PROC call BREAKF.WSL: data 0 patch L.BRK hereIM(-5) TO RTRA HANG UP BEEPINGG.WSL: D106 TO LOA0 GET STATUS FROM DRIVERE(E.WSL) TO RTZE IF ZERO, THEN OKIM(7) TO D50 BEEPPCI TO D106 PULSE RESET LINEDATA 40PCI TO D106 CLEAR RESET LINE BUT RESET STATE MACHINEDATA 200D106 TO TLOA0 CHECK STATUSIM(-2) TO RTNZ WHEN STATUS BECOMES 0, CONTINUEE.WSL:PCI TO D106 RESET INTERFACE MACHINE STATE ROMDATA 200IM(0) TO D106 SEND RESET*R4 TO R0 GET SECTOR MSB'SIM(0) TO BSOR0 SHIFT LEFT 8 TIMESR0 TO ADD0 SHIFT LEFT ONE MORE TIMEIM(0) TO D107 SEE IF MFM WINCHESTER CONTROLLERD107 TO TLOA0IM(3) TO RTNZ YES, SKIP EXTRA IMI FORMAT CODER0 TO ADD0 AND 3 MORE TIMES FOR IMI FORMATR0 TO ADD0R0 TO ADD0D106 TO TLOA0 WAIT FOR READY TO COME BACKIM(-2) TO RTNZR0 to R6 set asideMR1 TO R0 get drive bitPCI to AND0 only keep drive numberdata 7400 drive number fieldR6 to OR0 add MS sector bitsR0 TO R6 THIS IS SPECIAL IMI FORMAT - 20 BITS OF SECTOR NUMBER (or MFM format - 23 bits)RETURN to ATRA and return to callerZ.WSL: data F.WSL start of patch listdata L.BRK BREAKdata H.WSLdata L.BRK BREAKdata 0 end of segment