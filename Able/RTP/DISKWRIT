TTL DISK I/O ROUTINES:  WRITE TO DISK**DISK WRITE ROUTINE FOR FLOPPY OR WINCHESTER**THE FOLLOWING ROUTINE ACTS MUCH AS THE READ ROUTINE.   IT IS ENTERED WITH:*  AC0 = LOGICAL DEVICE TO WRITE/DISK SECTOR ADDRESS (UPPER 8 BITS)*  AC1 = DISK SECTOR ADDRESS (LOWER 16 BITS)*  AC2 = POINTER TO MEMORY BUFFER*  AC3 = NUMBER OF WORDS TO WRITE**IF AC3 = -1 (WRITE FROM POLY MEMORY TO DISK) OR AC3 = -2 (WRITE FROM EXTERNAL*MEMORY TO DISK), THE FOLLOWING IS TRUE:*  AC2 = NUMBER OF SECTORS TO WRITE*  R10 = STARTING SECTOR IN POLY/EXTERNAL MEMORY*  R11 = (NUMBER OF WORDS BEYOND LAST SECTOR TO WRITE) (POLY PAGE POINTER)*      / STARTING WORD IN POLY/EXTERNAL MEMORY**WRITEDATA ENTRANCE:*R.WFL:DATA Z.WFL POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKim(-2) to TSUB3 see if special writere(AA.WFL) to RTRC yes, set up for itim(0) to R4 turn flags offre(AB.WFL) to RTRA skip special write setupAA.WFL: R3 to R5 set R3 asideim(1) to AND3 extract poly/external memory flagre(AC.WFL) to RTNZ skip external memory setup if polyR10 to D60 write out starting sectorR11 to D61 and starting wordre(AD.WFL) to RTRA and skip over poly codeAC.WFL: im(24) to D156 and "read from poly memory" commandR10 to D157 write out starting sectorR11 to D157 and starting word/page pointerAD.WFL: im(2) to OR3 set special write flagim(0) to BSOR3 shift to proper positionR3 to R4 and save flagsR5 to R3 restore R3AB.WFL: R0 to R5 set R0 asideim(0) to BSOR0 move logical device number to the LSBytePCI to AND0 extract JUST the device numberdata 377im(10) to TSUB0 check rangere(AE.WFL) to RTMI in rangeim(-10/2+1) to SHRA0 convert device to device driver table entry numberPCI to RTRA and go call user driverdata A.WDRV-.-1AE.WFL: R1 to R6 preserve R1R2 to R7 and R2JUMP to PROC find device entryA.WFL: data 0 patched to find device entry routinere(K.WFL) to RTNZ if non-zero, valid device codeim(7) to D50 beep forever if bad device codeim(10) to R0 indicate diskerrorJUMP to PROC call BREAKF.WFL: data 0 pointer to BREAKim(-5) to RTRA loop foreverK.WFL: R6 to R1 restore R1R7 to R2 and R2R3 to TLOA3 see if nothing to readim(LREG) to ATZE if so, we are doneR0 to R7 save the pointer to the device table entry in R7MR7 to R0 and pick up the device typeim(17) to AND0 extract device typeim(1) to TSUB0 see if it's the WinchesterR5 to R0 restore R0 (at least the MSByte of the sector number)PCI to RTZE if equals one, then use Winchester codedata WW1-.-1 pointer to Winchester codeEJECTim(0) to R5 start with normal speedB.WFL: R4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000re(BA.WFL) to RTZE noif ^ModelCR15I to R12R10 to MR15I preserve R10 (current sector in poly/external memory)R11 to MR15I preserve R11 (word length/word offset in poly/external memory)R12 to MR15endifif ModelCR10 to MR12D preserve R10 (current sector in poly/external memory)R11 to MR12D preserve R11 (word length/word offset in poly/external memory)endifBA.WFL: JUMP TO PROC CALL FLOPPY SEEK ROUTINEC.WFL: DATA 0 POINT TO SEEK ROUTINER0 to R5 set delay bit asideR4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000re(BB.WFL) to RTZE noif ^ModelCMR15 to R12R12I to ATNVMR12I to R10 restore R10MR12 to R11 restore R11MR15 to R15endifif ModelCR12I to ATNVMR12I to R11 restore R11MR12 to R10 restore R10endifBB.WFL: R4 to LOA0 see if we're talking to a D100Are(Y.WFL) to RTPL we aren'tim(2) to AND0 get sideim(1) to RTZE side zeroim(10) to R0 side onePCI to OR0 get commanddata 242 write sector, verify sideim(2) to RTRA skip old style commandY.WFL: PCI TO R0 get old D100 commandDATA 250 WRITE COMMMAND, NOT MULTIPLE, IBM FORMATR5 to OR0 add in delay bitR0 TO R5 AND SAVE IN R5 TEMPORARILYEJECT**FLOPPY WRITE CONTINUED:**PERFORM WRITE, COMMAND CODE IN R5*D.WFL: R4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000re(DA.WFL) to RTNZ yes, go to itR2 TO R10 SET UP R10 POINTING TO START OF DATA IN CASE OF RETRYR3 TO R11 SAVE LENGTH IN CASE OF RESTARTre(DB.WFL) to RTRADA.WFL: R11 to R3 get final word lengthim(0) to BSOR3PCI to AND3     (note:  if this result is zero, then sectors leftdata 377        must be at least one since this case exits at J.WFL)PCI to TAND0    see if poly or external memorydata 400im(1) to RTZE   skip if ext memoryim(0) to R3     else force # of words to 0 for polyR2 to TLOA0 see if any sectors left to copyre(DB.WFL) to RTZE no, only a few words (words remaining cannot be zero here!)im(1) to TSUB2 see if just one sector leftre(DC.WFL) to RTNZ no, go set up working word lengthPCI to ADD3 yes, add one sector so we exit at J.WFL if final word len is zerodata 400re(DB.WFL) to RTRA go start writeDC.WFL: PCI to R3 more than one sector left to copy - set up working word lengthdata 401 make longer than a sector so we don't exit prematurely at J.WFLDB.WFL: R3 to TLOA3 make sure R3 is non-zero (in case zero-length write!)im(LREG) to ATZE if so, don't ever start writingMR7 TO R0 PICK UP DEVICE TYPEIM(17) TO TAND0 EXTRACT JUST THE DEVICE TYPEPCI TO RTNZ SKIP TO REMOTE CODE FOR REMOTESDATA M.WFL-.-1V.WFL: D100 TO R0 GET STATUS REGPCI TO TAND0 TEST NOT READY BITDATA 200RE(V.WFL) TO RTNZ WAIT UNTIL READYR6 TO D102 SET UP SECTOR REGISTERR6 TO R0 GET DESIRED SECTORD102 TO SUB0 MAKE SURE SECTOR REGISTER WAS LOADED CORRECTLYRE(V.WFL) TO RTNZ IF NOT EQUAL, THEN GO BACKR4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000R5 TO D100 AND ISSUE COMMAND - WITH OR WITHOUT THE 10 MILLISECOND DELAYre(N.WFL) to RTZE no, normal writePCI to TAND0 see if poly writedata 400PCI to RTNZ yesdata NP.WFL-.-1re(NE.WFL) to RTRA external write**THE WRITE COMMAND HAS BEEN STARTED - PERFORM THE DATA LOOP*N.WFL: ... reenter for each wordMR2 to R5 get next wordim(3) to RTRA skipIM(1) TO TAND0 SEE IF STILL BUSYPCI TO RTZE IF NOT THEN DONEDATA G.WFL-.-1D100 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYR5 TO D103 WRITE OUT DISK DATAR5 to R0 get word againim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL DATA REQUESTR5 TO D103 WRITE OUT DATAR2I to ATNV point to next wordIM(1) TO SUB3 SEE IF DONERE(N.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUTPCI to RTRA go finish incomplete sectordata S.WFL-.-1eject***Perform write from external and poly memory to main floppies*NE.WFL: ... reenter for each external wordD62 to R5 get next wordim(3) to RTRA skipIM(1) TO TAND0 SEE IF STILL BUSYPCI TO RTZE IF NOT THEN DONEDATA G.WFL-.-1D100 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYR5 TO D103 WRITE OUT DISK DATAR5 to R0 get word againim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL DATA REQUESTR5 TO D103 WRITE OUT DATAD63 to ATNV point to next wordIM(1) TO SUB3 SEE IF DONERE(NE.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUTre(S.WFL) to RTRA go finish incomplete sector*IM(1) TO TAND0 SEE IF STILL BUSYPCI TO RTZE IF NOT THEN DONEDATA G.WFL-.-1NP.WFL: D100 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYD157 to R0 pick up next wordR0 TO D103 WRITE OUT DISK DATAim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL DATA REQUESTR5 TO D103 WRITE OUT DATAIM(1) TO SUB3 SEE IF DONERE(NP.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUT*S.WFL: D100 TO R0 CHECK STATUS HEREIM(2) TO TAND0 SEE IF DATA REQUESTIM(1) TO RTZE SKIP IF NO DRQIM(0) TO D103 WRITE A ZERO TO FILL SECTORIM(1) TO TAND0 SEE IF STILL BUSYRE(S.WFL) TO RTNZ IF STILL BUSY, LOOPPCI TO RTRA GO CHECK STATUSDATA G.WFL-.-1EJECT**FLOPPY WRITE CONTINUED:**PERFORM WRITE ON REMOTES, COMMAND CODE IN R5*M.WFL: D110 TO R0 GET STATUS REGPCI TO TAND0 TEST NOT READY BITDATA 200RE(M.WFL) TO RTNZ WAIT UNTIL READYR6 TO D112 SET UP SECTOR REGISTERR6 TO R0 GET DESIRED SECTORD112 TO SUB0 MAKE SURE SECTOR REGISTER WAS LOADED CORRECTLYRE(M.WFL) TO RTNZ IF NOT EQUAL, THEN GO BACKR4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000R5 TO D110 AND ISSUE COMMAND - WITH OR WITHOUT THE 10 MILLISECOND DELAYre(O.WFL) to RTZE no, normal writePCI to TAND0 see if poly writedata 400PCI to RTNZ yesdata OP.WFL-.-1re(OE.WFL) to RTRA external write**THE WRITE COMMAND HAS BEEN STARTED - PERFORM THE DATA LOOP*O.WFL: ... reenter for each wordMR2 to R5 get next wordim(3) to RTRA skipIM(1) TO TAND0 SEE IF STILL BUSYPCI TO RTZE IF NOT THEN DONEdata G.WFL-.-1D110 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYR5 TO D113 WRITE OUT DISK DATAR5 to R0 get word againim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITR5 TO D113 WRITE OUT DATAR2I to ATNV point to next wordIM(1) TO SUB3 SEE IF DONERE(O.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUTPCI to RTRA go finish incomplete sectordata P.WFL-.-1eject***Perform write from external and poly memory to main floppies*OE.WFL: ... reenter for each external wordD62 to R5 get next wordim(3) to RTRA skipIM(1) TO TAND0 SEE IF STILL BUSYPCI TO RTZE IF NOT THEN DONEdata G.WFL-.-1D110 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYR5 TO D113 WRITE OUT DISK DATAR5 to R0 get word againim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITR5 TO D113 WRITE OUT DATAD63 to ATNV point to next wordIM(1) TO SUB3 SEE IF DONERE(OE.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUTre(P.WFL) to RTRA go finish incomplete sector*IM(1) TO TAND0 SEE IF STILL BUSYRE(G.WFL) TO RTZE IF NOT THEN DONEOP.WFL: D110 TO R0 READ STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-5) TO RTZE IF NOT,  THEN CHECK FOR STILL BUSYD157 to R0 pick up next poly wordR0 TO D113 WRITE OUT DISK DATAim(0) to BSOR0 swap bytesR0 TO R5 saveIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITR5 TO D113 WRITE OUT DATAIM(1) TO SUB3 SEE IF DONERE(OP.WFL) TO RTNZ IF MORE TO GO,  GET WORD & SEND OUT*P.WFL: D110 TO R0 CHECK STATUS HEREIM(2) TO TAND0 SEE IF DATA REQUESTIM(1) TO RTZE SKIP IF NO DRQIM(0) TO D113 WRITE A ZERO TO FILL SECTORIM(1) TO TAND0 SEE IF STILL BUSYRE(P.WFL) TO RTNZ IF STILL BUSY, LOOPEJECT**FLOPPY WRITE CONTINUED:  CHECK STATUS*G.WFL:PCI TO TAND0 WHEN THROUGH, CHECK FOR ERRORSDATA 356 WRITE PROTECT, WRITE FAULT, CRC ERROR, LOST DATA, OR DRQ LEFTRE(Q.WFL) TO RTNZ IF SO, THEN A BAD DATA TRANSFERIM(20) TO TAND0 CHECK FOR RECORD NOT FOUNDPCI TO RTZE IF NOT, THEN WAS OK DATA & CORRECT ITEMDATA J.WFL-.-1Q.WFL: R4 to R3 pick up flagsPCI to TAND3 see if special writedata 1000re(QA.WFL) to RTNZ yesR10 to R2 retry - reset R2 to start of data areaR11 to R3 and reset R3 to correct length fieldre(QB.WFL) to RTRA skip over special codeQA.WFL: PCI to TAND3 see if poly or external memorydata 400re(QC.WFL) to RTNZ it's polyR10 to D60 reload external memory sectorR11 to D61 and wordre(QB.WFL) to RTRA and skip over poly codeQC.WFL: im(24) to D156 and "read from poly memory" commandR10 to D157 reload poly memory sectorR11 to D157 and word/page pointerQB.WFL: PCI to TAND0 check for data errorsdata 356 write protect, write fault, CRC error, lost data, or DRQ leftre(H.WFL) to RTZE if not, okay data transferIM(7) TO D50 BEEP HERER14 TO R5 SAVE USER INTERRUPT FLAGIM(-20) TO R14 KEEP INTERRUPTS OFFIM(10) TO R0 ACTIVATE DISKERROR STMTJUMP TO PROC CALLT.WFL:DATA 0 BREAKR5 TO R14 RESTORE USER INTERRUPT FLAGI.WFL: MR7 TO R0 PICK UP DEVICE TYPEIM(17) TO TAND0 EXTRACT JUST THE TYPEIM(2) TO RTNZ SKIP FLOPPY CODE FOR REMOTESR4 TO D104 KEEP MOTOR ON FOR RETRYIM(1) TO RTRA SKIP REMOTE CODER4 TO D114 KEEP MOTOR ON FOR RETRYPCI TO R5 AND RESET UP R5 FOR OPERATIONDATA 250  WRITE OPERATION, NOT MUL, IBM FORMAT, NO HEAD LOAD, DATA MARKR4 to LOA0 see if we're talking to a D100APCI to RTPL we aren'tDATA D.WFL-.-1 go writeim(2) to AND0 get sideim(1) to RTZE side zeroim(10) to R0 side onePCI to OR0 get commanddata 242 write sector, verify sideR0 to R5 and move to R5PCI TO RTRA AND GO BACDATA D.WFL-.-1 POINTER TO RETRYEJECT**FLOPPY WRITE CONTINUED:  CHECK FOR SEEK ERROR*H.WFL: PCI TO R5 PICK UP POINTER TO POINTER TO HEAD POSITIONSDATA CONTAB+CURTRKMR5 TO R5 PICK UP POINTER TO HEAD POSITIONSMR7 TO R0 GET DEVICE TYPEIM(17) TO TAND0 EXTRACT JUST THE DEVICE TYPERE(HR.WFL) TO RTNZ SKIP FLOPPY CODE FOR REMOTESPCI TO D100 STEP IN ONCE TO JOG DISKDATA 103 STEP IN AT SLOWEST RATED100 TO R0 WAIT FOR DONEIM(1) TO TAND0 SEE IF STILL BUSYIM(-3) TO RTNZ IF SO, THEN LOOPRE(HS.WFL) TO RTRA SKIP REMOTE CODEHR.WFL: PCI TO D110 STEP IN ONCE TO JOG DISK (REMOTES)DATA 103 STEP IN AT SLOWEST RATED110 TO R0 WAIT FOR DONEIM(1) TO TAND0 SEE IF STILL BUSYIM(-3) TO RTNZ IF SO, THEN LOOPR5I to ATNV point to remote head positionsR5I to ATNVHS.WFL: R4 TO R0 GET DRIVE NUMBER/SIDE NUMBERIM(1) TO AND0 EXTRACT DRIVE NUMBERR5 TO ADD0 AND POINT TO APPROPRIATE HEAD POSITION WORDIM(0) TO MR0 RESET OUR ESTIMATED POSITIONR7 TO R0 GET POINTER TO DEVICE ENTRY IN STRDEVIM(SPDTRK) TO ADD0 POINT TO STEPPING SPEED/SECTORS PER TRACK WORDMR0 TO R0 PICK UP STEPPING SPEEDPCI TO AND0 EXTRACT STEPPING SPEEDDATA 377R3 to R5 save R3MR7 TO R3 PICK UP DEVICE TYPEIM(17) TO TAND3 EXTRACT DEVICE TYPEIM(2) TO RTNZ SKIP FOR REMOTESR0 TO D100 START A RESTORE COMMANDIM(1) TO RTRA SKIP OVER REMOTE CODER0 TO D110 START A RESTORE COMMAND (REMOTES)R5 to R3 restore R3im(1) to R5 assume alternate speedMR7 to R0 get config bitsPCI to TAND0 see if alternate motor speed supported by drivedata 2000re(HA.WFL) to RTZE no, this is always an errorR4 to R0 get drive infoPCI to TAND0 see if alternate motor speed was useddata 40re(HA.WFL) to RTNZ yes, this is now an error (previous problem wasn't incorrect speed)PCI to TSUB1 see if beyond end of old disksdata 5*120 (5 sectors/track * 80 tracks)PCI to RTNC no, skip the error and try alternate motor speeddata B.WFL-.-1HA.WFL: IM(7) TO D50 RING BELL FOR ATTENTIONR14 to R5 save internal stateim(-20) to R14 keep internal state consistentIM(10) TO R0 TRY FOR WHEN DISKERROR ROUTINEJUMP TO PROC SUB CALLU.WFL:DATA 0R5 to R14 restore interanl stateim(0) to R5 use normal speedPCI TO RTRA AND GO BACKDATA B.WFL-.-1 AND RESTART WITH THE SEEKEJECT**FLOPPY WRITE CONTINUED:**CHECK FOR COMPLETION*J.WFL: MR7 TO R0 PICK UP DEVICE TYPEIM(17) TO TAND0 EXTRACT DEVICE TYPER6 TO R0 GET DESIRED SECTORIM(2) TO RTNZ SKIP FOR REMOTESD102 TO SUB0 SHOULD BE EQUAL TO SECTOR REG IN DEVICEIM(1) TO RTRA SKIP OVER REMOTE CODED112 TO SUB0 SHOULD BE EQUAL TO SECTOR REG IN DEVICE (REMOTES)im(14) to R0 set up so Q.WFL recognizes this as an errorPCI TO RTNZ IF NOT, THEN RETRYDATA Q.WFL-.-1R3 TO TLOA3 SEE IF DONEPCI TO RTZE IF DONE,  NO MORE TO GOdata E.WFL-.-1IM(1) TO ADD1 INCREMENT PHYSICAL ADDRESSR4 to R0 pick up drive infoPCI to TAND0 see if special writedata 1000re(JB.WFL) to RTZE noR10I to ATNV increment poly/external sector to write fromim(1) to SUB2 decrement sectors to writeJB.WFL: PCI to TAND0 see if alternate speed useddata 40re(JC.WFL) to RTZE no, keep using normal speedim(1) to R5 yes, keep using alternate speedim(5) to R0 and use 5 sectors/trackre(JA.WFL) to RTRA and skip over normal speed codeJC.WFL: im(0) to R5 use normal speedR7 to R0 point to device table entryim(SPDTRK) to ADD0 point to sectors/trackMR0 to R0 pick up sectors/trackim(0) to BSOR0 move to lowerPCI to AND0 and extractdata 377JA.WFL: R6 to TSUB0 see if at end of track yetR6I to ATNV increment sectorPCI to RTNZ same track, next sectordata I.WFL-.-1R7 to R6 point to device table entry [R6 is trash here - SEEK resets it]R6I to ATNV point to sectors/cylinderMR6 to TSUB0 see if double-sidedPCI to RTZE not double-sided (single-sided if SECPT = SECCYL)data B.WFL-.-1 must be single-sided - stepR4 to R0 change sidesPCI to TAND0 see if alternate speed useddata 40PCI to RTNZ alternate speed - not double-sideddata B.WFL-.-1 just stepim(2) to XOR0 like soR0 to R4im(1) to R6 back to sector oneim(2) to TAND0 back to side zero?PCI TO RTNZ IF NOT,  SAME TRACK, NEXT SECTORDATA I.WFL-.-1PCI TO RTRA ELSE GO BACK AND SEEK TO NEXT TRACKDATA B.WFL-.-1**DONE WITH WRITE*E.WFL: R4 to R0 pick up drive infoPCI to TAND0 see if alternate speed selecteddata 40im(3) to RTZE no, we're already at normal speedim(0) to R5 return to normal speedJUMP to PROC seek back to last sector read to change speedEA.WFL: data 0R14 TO D1 RESET THE INTERRUPT FLAGIM(LREG) TO ATRA RESTORE REGS AND RETURNEJECT**Transfer to user device driver.  Registers at entry:*   R0:  Device driver table entry number for device requested*   R1:  Disk sector address (lower 16 bits)*   R2:  Pointer to memory buffer*   R3:  Number of words to write*   R5:  Logical device to write/disk sector address (upper 8 bits)**If R3 = -1 (write to disk from poly memory) or R3 = -2 (write to disk from*external memory), the following is true:*   R2:  Number of sectors to write*  R10:  Starting sector in poly/external memory*  R11:  (Number of words beyond last sector to write) (poly page pointer)*        / starting word in poly/external memory**A device driver should expect the following register settings at entry:*   R0:  Logical device to write/disk sector address (upper 8 bits)*   R1:  Disk sector address (lower 16 bits)*   R2:  Pointer to memory buffer*   R3:  Number of words to write**If R3 = -1 (write to disk from poly memory) or R3 = -2 (write to disk from*external memory), the following is true:*   R2:  Number of sectors to write*   R4:  Starting sector in poly/external memory*   R5:  Number of words beyond last sector to write/starting word in poly/external memory*A.WDRV: im(DEVDRV/2) to TSUB0 see if entry number is in boundsre(F.WDRV) to RTRC out of range - fatal errorR0 to ADD0 multiply entry number by two to get READ device driver table offsetim(1) to ADD0 and add one to get WRITE device driver table offsetPCI to R6 get pointer to device driver table pointerdata CONTAB+DEVTABMR6 to TLOA0 see if there's a tablere(F.WDRV) to RTZE if no table, we have a fatal errorMR6 to ADD0 point to table entry for our device's driverMR0 to LOA0 pick up pointer to device driver routinere(B.WDRV) to RTNZ we have a driverF.WDRV: im(7) to D50 no driver, beep at themim(10) to R0 point to DISKERRORJUMP to PROC call BREAK routineC.WDRV: data 0 pointer to BREAK routinere(F.WDRV) to RTRA loop foreverB.WDRV: R0 to R6 save driver addressif ^ModelCR15I to R12 save stack startR17 to R0 compute return addressim(D.WDRV-.-1) to ADD0R0 to MR15I stack return addressR12 to MR15 finish stack frameendif of ^ModelCR5 to R0 restore R0R10 to R4 move R10 to R4R11 to R5 move R11 to R5R6 to ATRA and "call" the driverD.WDRV: im(LREG) to ATRA returnEJECT**WRITE DATA TO WINCHESTER DISK*WW1:R0 to R5 set sector MSB asideMR7 to R0 pick up device typePCI to AND0 see if SCSI or IMI type drivedata 1400 drive type fieldim(0) to R0 table entry 0 is for SCSI drivePCI to RTNZ it's SCSI (no other type supported yet)data A.WDRV-.-1im(0) to R10 clear flagsR4 to R0 pick up flagsPCI to TAND0 see if special writedata 1000re(WW15) to RTZE nopeR11 to R3 get word lengthim(0) to BSOR3 move to lowerPCI to AND3data 377PCI to TAND0 see if actually ext memorydata 400im(1) to RTZE   skip ahead if ext memoryim(0) to R3     else force word length field to 0R3 to OR0 add into flagsPCI to OR0 set sign bit so we can do a quick check with no regs useddata 100000R0 to R10 and move to R10WW15: R5 to R0 restore sector MSBPCI to AND0 but only keep the sector MSBdata 377WW3:JUMP TO PROC PERFORM SUBROUTINE CALLWW2:DATA 0 WILL POINT TO SELECT ROUTINEWW8: R10 to TLOA0 see if special writere(WW85) to RTPL noPCI to R3 set word lengthdata 401 longer than a sector so we don't prematurely terminateR2 to TLOA0 check sector lengthre(WW85) to RTNZ still sectors leftR10 to R3 we've written all sectors - get final word countPCI to AND3data 377im(LREG) to ATZE get out here if ends on sector boundaryWW85: R6 TO R0 GET SECTOR MSB'SIM(13) TO OR0 OR IN WRITE WITHOUT VERIFY COMMANDR0 TO D107 SEND IT OUTD106 TO R0 **WAIT FOR READY IN CASE DIFFERENT DRIVED106 TO OR0 CHECK TWICE IN CASE WE GET IT BETWEEN BYTESIM(1) TO TAND0IM(-4) TO RTNZR5 TO D107 SEND OUT SECTOR LSB'SR10 to TLOA0 see if special writere(WW8M) to RTPL no, normal writeR10 to R0 pick up flagsPCI to TAND0 see if poly writedata 400PCI to RTNZ yesdata WW8P-.-1PCI to RTRA external writedata WW8E-.-1***Data loop - Main memory to D107*WW8M: PCI TO TSUB3 CHECK FOR LENGTH OF 256 OR GREATERDATA 400RE(WW4) TO RTRC IF 256 OR GREATERPCI TO R0 GET LOOP COUNTERDATA 400WW5:R3 TO TLOA3 CHECK FOR ZERO LENGTHIM(3) TO RTZE SKIP 3 INSTRUCTIONS IF 0MR2I TO D107 WRITE OUT DATA TO DISKIM(1) TO SUB3 DECREMENT LENGTH FIELDIM(1) TO RTRA SKIP AHEADIM(0) TO D107 ELSE FILL WITH ZEROESIM(1) TO SUB0 CHECK COUNTERRE(WW5) TO RTNZ GO BACK FOR MOREPCI TO RTRA SKIP AHEADdata WW6-.-1WW4: ...if ^ModelCIM(20) TO R0 SET UP LOOP COUNTER FOR FAST WRITESWW7:MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107MR2I TO D107IM(1) TO SUB0 COUNTERRE(WW7) TO RTNZ GO BACK TO WWFendif of ^ModelCif ModelCPCI to D10 write entire sectordata 377 (256 words)MR2I to D107 copy next word to WinchesterendifPCI TO SUB3 REDUCE LENGTH FIELD FOR 256 WORDS TRANSFERREDDATA 400PCI to RTRA finished writing the sectordata WW6-.-1eject***Data loop - External memory to D107*WW8E:PCI TO TSUB3 CHECK FOR LENGTH OF 256 OR GREATERDATA 400RE(WW4E) TO RTRC IF 256 OR GREATERPCI TO R0 GET LOOP COUNTERDATA 400WW5E:R3 TO TLOA3 CHECK FOR ZERO LENGTHIM(3) TO RTZE SKIP 3 INSTRUCTIONS IF 0D63 TO D107 WRITE OUT DATA TO DISKIM(1) TO SUB3 DECREMENT LENGTH FIELDIM(1) TO RTRA SKIP AHEADIM(0) TO D107 ELSE FILL WITH ZEROESIM(1) TO SUB0 CHECK COUNTERRE(WW5E) TO RTNZ GO BACK FOR MOREPCI TO RTRA SKIP AHEADdata WW6-.-1WW4E: ...if ^ModelCIM(20) TO R0 SET UP LOOP COUNTER FOR FAST WRITESWW7E:D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107D63 TO D107IM(1) TO SUB0 COUNTERRE(WW7E) TO RTNZ GO BACK TO WWFendif of ^ModelCif ModelCPCI to D10 write entire sectordata 377 (256 words)D63 to D107 copy next word to WinchesterendifPCI TO SUB3 REDUCE LENGTH FIELD FOR 256 WORDS TRANSFERREDDATA 400PCI to RTRA finished writing the sectordata WW6-.-1eject***Data loop - Polyphonic sampling memory to D107*WW8P: PCI TO TSUB3 CHECK FOR LENGTH OF 256 OR GREATERDATA 400RE(WW4P) TO RTRC IF 256 OR GREATERPCI TO R0 GET LOOP COUNTERDATA 400WW5P:R3 TO TLOA3 CHECK FOR ZERO LENGTHIM(3) TO RTZE SKIP 3 INSTRUCTIONS IF 0D157 TO D107 WRITE OUT DATA TO DISKIM(1) TO SUB3 DECREMENT LENGTH FIELDIM(1) TO RTRA SKIP AHEADIM(0) TO D107 ELSE FILL WITH ZEROESIM(1) TO SUB0 CHECK COUNTERRE(WW5P) TO RTNZ GO BACK FOR MORERE(WW6) TO RTRA SKIP AHEADWW4P: ...if ^ModelCIM(20) TO R0 SET UP LOOP COUNTER FOR FAST WRITESWW7P:D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107D157 TO D107IM(1) TO SUB0 COUNTERRE(WW7P) TO RTNZ GO BACK TO WWFendif of ^ModelCif ModelCPCI to D10 write entire sectordata 377 (256 words)D157 to D107 copy next word to WinchesterendifPCI TO SUB3 REDUCE LENGTH FIELD FOR 256 WORDS TRANSFERREDDATA 400eject***End of writing sector - check status*WW6:D106 TO R0 WAIT FOR STATUS RETURNIM(2) TO TAND0 WITH INTERRUPTS ENABLED IF SORE(WW6) TO RTZE GO BACK - WAIT FOR RETURN CODED107 TO R1 READ RETURN CODEPCI TO TAND1 CHECK FOR ANY ERRORDATA 177re(WW9) to RTZE if none, skipIM(7) TO D50 beep once if recoverable errorim(10) to R0 indicate diskerrorJUMP TO PROC call BREAKWW10: data 0 point to BREAKWW9: PCI TO TAND1 CHECK FOR FATAL ERRORDATA 200re(WW0) to RTZE if none, skipIM(7) TO D50 beep forever for fatal errorsim(10) to R0 indicate diskerrorJUMP TO PROC call BREAKWW11: data 0 point to BREAKIM(-5) TO RTRA GO BACK AND BEEP FOR GOOD - FATAL ERRORWW0: IM(1) TO R0 LOAD A 1 INTO R0R5I TO TADD0 INCREMENT SECTOR LSBRE(WW20) TO RTNZ SKIP IF NO CARRY OUTR4I TO ATNV INCREMENT MSBR6 TO R1 AND IMI FORMAT MSBim(0) to D107 see if MFM Winchester controllerD106 TO TLOA0 WAIT FOR READY TO COME BACK FROM WRITEIM(-2) TO RTNZD107 to TLOA0im(3) to RTNZ yes, skip IMI carryPCI TO ADD1DATA 010000 UPPER 4 BITS FOR IMI FORMATim(2) to RTRA skip MFM carryPCI to ADD1data 001000 upper 7 bits for MFM formatR1 TO R6 BACK TO R6WW20: D106 TO R1 WAIT FOR READY TO COME BACK ONIM(1) TO TAND1IM(-3) TO RTNZ WAIT WHILE NOT READYR3 TO TLOA3 SEE IF MORE WORDS TO WRITEIM(LREG) TO ATZE NO MORE TO DO - LOAD REGISTERS AND RETURNR10 to TLOA0 see if special writeim(1) to RTPL nopeim(1) to SUB2 decrement sector countR11I TO TADD0 CHECK FOR REACHING END OF DISKPCI TO RTNZ IF NOT END OF DISK, JUST GIVE ANOTHER COMMANDDATA WW8-.-1R4 TO R0 ELSE MUST SELECT NEXT DISKR5 TO R1 BY RESTORING SECTOR NUMBER TO R0-R1PCI TO RTRA AND CALLINGDATA WW3-.-1 THE SUBROUTINE*Z.WFL: DATA A.WFL BEGIN PATCH LISTDATA L.FDE FIND DEVICE ENTRYDATA F.WFLDATA L.BRK BREAKDATA C.WFLDATA L.SEE SEEKDATA T.WFL TDATA L.BRK BREAKDATA U.WFL UDATA L.BRK BREAKDATA EA.WFLDATA L.SEE SEEKDATA C.WDRVDATA L.BRK BREAKDATA WW2DATA L.WSL SELECTDATA WW10DATA L.BRK BREAKDATA WW11DATA L.BRK BREAKDATA 0 END OF SEGMENTeject***EXTWRITE Entrance:**EXTWRITE is passed:*  R0: Logical device to write/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Pointer to buffer containing (at offset):*      0: Base sector in external memory*      1: Offset word from base in external memory*      2: Number of sectors to write*      3: Number of words beyond last sector to write**EXTWRITE normalizes the sector/word addresses and calls WRITEDATA with:*  R0: Logical device to write/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Number of sectors to write*  R3: -2* R10: Starting sector in external memory* R11: Number of words beyond last sector to write/starting word in external memory*R.EWR: data Z.EWR pointer to patch listif ModelCD10 to MR12D stack returnendifim(SREG) to ATRA save registers on stackD60 to R6 save sector registerD61 to R7 and word register***Normalize the starting address*MR2I to R5 pick up the baseMR2 to R3 and the offsetim(0) to BSOR3 get the sector specified in the offsetPCI to AND3data 377R5 to ADD3 add in the base - this is the starting sectorR3 to R10 set base aside for WRITEDATAMR2I to R3 pick up offset againPCI to AND3 keep starting word address onlydata 377R3 to R11 set aside for WRITEDATA***Normalize the length to write*MR2I to R5 pick up the sector lengthMR2 to R3 and the word lengthim(0) to BSOR3 get sector length specified in word lengthPCI to AND3data 377R5 to ADD3 add in the number of sectors specified - this is the sector lengthR3 to R5 set sector length asideMR2 to R3 pick up word address againPCI to AND3 keep word length onlydata 377im(0) to BSOR3 move to upperR11 to OR3 add in starting wordR3 to R11 and put back for WRITEDATA*R5 to R2 set up sector length for WRITEDATAim(-2) to R3 and flag that we're writing from external memoryJUMP to PROC call WRITEDATAA.EWR: data 0 pointer to WRITEDATA*R6 to D60 restore sector registerR7 to D61 and word registerim(LREG) to ATRA and get out*Z.EWR: data A.EWR start of patch listdata L.WFL WRITEDATAdata 0 end of patch listeject***POLYWRITE Entrance:**POLYWRITE is passed:*  R0: Logical device to write/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Pointer to buffer containing (at offset):*      0: Base sector in poly memory*      1: Offset word from base in poly memory*      2: Number of complete sectors to write*      3: Poly memory page pointer*  R3: Polyphonic sampling channel number**POLYWRITE normalizes the sector/word addresses and calls WRITEDATA with:*  R0: Logical device to write/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Number of sectors to write*  R3: -1* R10: Starting sector in poly memory* R11: Page pointer/starting word in poly memory*R.PWR: data Z.PWR pointer to patch listif ModelCD10 to MR12D stack returnendifim(SREG) to ATRA save registers on stackR3 to D155 select poly channel here***Normalize the starting address*MR2I to R5 pick up the baseMR2 to R3 and the offsetim(0) to BSOR3 get the sector specified in the offsetPCI to AND3data 377R5 to ADD3 add in the base - this is the starting sectorR3 to R10 set base aside for WRITEDATAMR2I to R3 pick up offset againPCI to AND3 keep starting word address onlydata 377R3 to R11 set aside for WRITEDATA***Get sector length,  poly sector page address*MR2I to R5 pick up and store away the sector lengthMR2 to R3  get page pointerPCI to AND3  extract itdata 377im(0) to BSOR3 get in upper halfR11 to OR3 add in starting wordR3 to R11 and put back for WRITEDATA*R5 to R2 set up sector length for WRITEDATAim(-1) to R3 and flag that we're writing from polyphonic sampling memoryJUMP to PROC call WRITEDATAA.PWR: data 0 pointer to WRITEDATA*im(LREG) to ATRA and get out*Z.PWR: data A.PWR start of patch listdata L.WFL WRITEDATAdata 0 end of patch list