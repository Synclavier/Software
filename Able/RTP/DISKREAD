TTL DISK I/O ROUTINES:  READ FROM DISK**DISK READ ROUTINE FOR FLOPPY OR WINCHESTER**IT IS ENTERED WITH:*  AC0 = LOGICAL DEVICE TO READ/DISK SECTOR ADDRESS (UPPER 8 BITS)*  AC1 = DISK SECTOR ADDRESS (LOWER 16 BITS)*  AC2 = POINTER TO MEMORY BUFFER*  AC3 = NUMBER OF WORDS TO READ**IF AC3 = -1 (READ FROM DISK TO POLY MEMORY) OR AC3 = -2 (READ FROM DISK TO*EXTERNAL MEMORY), THE FOLLOWING IS TRUE:*  AC2 = NUMBER OF SECTORS TO READ*  R10 = STARTING SECTOR IN POLY/EXTERNAL MEMORY*  R11 = (NUMBER OF WORDS BEYOND LAST SECTOR TO READ) (OR PAGE POINTER)*      / STARTING WORD IN POLY/EXTERNAL MEMORY**READDATA ENTRANCE:*R.RFL:DATA Z.RFL POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERS ON STACKim(-2) to TSUB3 see if special readre(AA.RFL) to RTRC yes, set up for itim(0) to R4 turn flags offre(AB.RFL) to RTRA skip special read setupAA.RFL: R3 to R5 set R3 asideim(1) to AND3 extract poly/external memory flagre(AC.RFL) to RTNZ skip external memory setup if polyR10 to D60 write out starting sectorR11 to D61 and starting wordre(AD.RFL) to RTRA and skip over poly codeAC.RFL: im(20) to D156 and "write to poly memory" commandR10 to D157 write out starting sectorR11 to D157 and starting word and page pointerAD.RFL: im(2) to OR3 set special read flagim(0) to BSOR3 shift to proper positionR3 to R4 and save flagsR5 to R3 restore R3AB.RFL: R0 to R5 set R0 asideim(0) to BSOR0 move logical device number to the LSBytePCI to AND0 extract JUST the device numberdata 377im(10) to TSUB0 check rangere(AE.RFL) to RTMI in rangeim(-10/2+1) to SHRA0 convert device to device driver table entry numberPCI to RTRA go handle user device driversdata A.RDRV-.-1AE.RFL: R1 to R6 preserve R1R2 to R7 and R2JUMP to PROC find device entryA.RFL: data 0 patched to find device entry routinere(K.RFL) to RTNZ if non-zero, valid device codeim(7) to D50 beep forever if bad device codeim(10) to R0 indicate diskerrorJUMP to PROC call BREAKF.RFL: data 0 pointer to BREAKim(-5) to RTRA loop foreverK.RFL: R6 to R1 restore R1R7 to R2 and R2R3 to TLOA3 see if nothing to readim(LREG) to ATZE if so, we are doneR0 to R7 save the pointer to the device table entry in R7MR7 to R0 and pick up the device typeim(17) to AND0 extract device typeim(1) to TSUB0 see if it's the WinchesterR5 to R0 restore R0 (at least the MSByte of the sector number)PCI to RTZE if equals one, then use Winchester codedata WR1-.-1 pointer to Winchester codeEJECTim(0) to R5 start with normal speedB.RFL: R4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000re(BA.RFL) to RTZE noif ^ModelCR15I to R12R10 to MR15I preserve R10 (current sector in poly/external memory)R11 to MR15I preserve R11 (word length/word offset in poly/external memory)R12 to MR15endifif ModelCR10 to MR12D preserve R10 (current sector in poly/external memory)R11 to MR12D preserve R11 (word length/word offset in poly/external memory)endifBA.RFL: JUMP TO PROC CALL FLOPPY SEEK ROUTINEC.RFL: DATA 0 POINT TO SEEK ROUTINER0 to R5 set delay bit asideR4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000re(BB.RFL) to RTZE noif ^ModelCMR15 to R12R12I to ATNVMR12I to R10 restore R10MR12 to R11 restore R11MR15 to R15endifif ModelCR12I to ATNVMR12I to R11 restore R11MR12 to R10 restore R10endifBB.RFL: R4 to LOA0 see if we're talking to a D100Are(Y.RFL) to RTPL we aren'tim(2) to AND0 get sideim(1) to RTZE side zeroim(10) to R0 side onePCI to OR0 get commanddata 202 read sector, verify sideim(2) to RTRA skip old style commandY.RFL: PCI TO R0 get old D100 commandDATA 210 READ COMMAND, NOT MULTIPLE, IBM FORMATR5 to OR0 add in delay bitR0 TO R5 SAVE COMMAND IN R5EJECT**PERFORM READ, COMMAND CODE IN R5*D.RFL: R4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000re(DA.RFL) to RTNZ yes, go to itR2 TO R10 SET UP R10 POINTING TO START OF DATA IN CASE OF RETRYR3 TO R11 SAVE LENGTH IN CASE OF RESTARTre(DB.RFL) to RTRADA.RFL:R11 to R3    get final word length (ext memory only) (page pointer for poly)im(0) to BSOR3      in lower halfPCI to AND3         (note:  if this result is zero, then sectors leftdata 377            must be at least one since this case exits at J.RFL)PCI to TAND0        see if it is poly or ext memoryDATA 400im(1) to RTZE       skip if external memoryim(0) to R3         else treat as if word length = 0R2 to TLOA0 see if any sectors left to copyre(DB.RFL) to RTZE no, only a few words (words remaining cannot be zero here!)im(1) to TSUB2 see if just one sector leftre(DC.RFL) to RTNZ no, go set up working word lengthPCI to ADD3 yes, add one sector so we exit at J.RFL if final word len is zerodata 400re(DB.RFL) to RTRA go start readDC.RFL: PCI to R3 more than one sector left to copy - set up working word lengthdata 401 make longer than a sector so we don't exit prematurely at J.RFLDB.RFL: R3 to TLOA3 make sure R3 is non-zero (in case zero-length read!)im(LREG) to ATZE if so, don't ever start readingMR7 TO R0 PICK UP DEVICE TYPEIM(17) TO TAND0 SEE IF FLOPPY OR REMOTEPCI TO RTNZ IF REMOTE, USE REMOTE READDATA M.RFL-.-1V.RFL: D100 TO R0 GET FLOPPY STATUS REGPCI TO TAND0 TEST NOT READY BITDATA 200 MASK FOR NOT READYRE(V.RFL) TO RTNZ LOOP UNTIL READYR6 TO D102 SET UP SECTOR REGISTER HERER6 TO R0 CHECK SECTOR REGISTER TO SEE IF LOADED PROPERLYD102 TO SUB0 COMPARERE(V.RFL) TO RTNZ TRY AGAIN WITH LOAD IF NOT THERER4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000*R5 TO D100 ISSUE READ COMMAND, AS COMPUTED ABOVE*re(N.RFL) to RTZE no, normal readPCI to TAND0 see if poly readdata 400PCI to RTNZ yesdata NP.RFL-.-1re(NE.RFL) to RTRA external read**THE READ COMMAND HAS BEEN STARTED.  LOOP, CHECKING STATUS, AND READ DATA*IM(1) TO TAND0 CHECK IF STILL BUSYPCI TO RTZE IF NOT, THEN SKIP OUT OF ITDATA G.RFL-.-1N.RFL:D100 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT, THEN CONTINUE TO LOOPD103 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD103 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO MR2I STORE WORD INTO MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(N.RFL) TO RTNZ IF MORE TO READ, LOOP BACKRE(S.RFL) to RTRA finish reading incomplete sectoreject***Perform read to external and poly memory from main floppies*IM(1) TO TAND0 CHECK IF STILL BUSYPCI TO RTZE IF NOT, THEN SKIP OUT OF ITDATA G.RFL-.-1NE.RFL:D100 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT, THEN CONTINUE TO LOOPD103 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD103 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO D63 STORE WORD INTO EXTERNAL MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(NE.RFL) TO RTNZ IF MORE TO READ, LOOP BACKRE(S.RFL) to RTRA finish reading incomplete sector*IM(1) TO TAND0 CHECK IF STILL BUSYPCI TO RTZE IF NOT, THEN SKIP OUT OF ITDATA G.RFL-.-1NP.RFL:D100 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT, THEN CONTINUE TO LOOPD103 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD100 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD103 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO D157 STORE WORD INTO POLY MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(NP.RFL) TO RTNZ IF MORE TO READ, LOOP BACK*S.RFL:D100 TO R0 CHECK STATUS TILL NDIM(2) TO TAND0 DRQ?IM(1) TO RTZE IF NOT, THEN SKIPD103 TO ATNV SKIP DATA, BUT COMPUTE CRCIM(1) TO TAND0 SEE IF BUSYRE(S.RFL) TO RTNZ BRANCH BACK IF BUSYPCI TO RTRA GO CHECK STATUSDATA G.RFL-.-1EJECT**FLOPPY READ CONTINUED:**PERFORM READ COMMAND FOR REMOTES - COMMAND CODE IN R5*M.RFL: D110 TO R0 GET FLOPPY STATUS REGPCI TO TAND0 TEST NOT READY BITDATA 200 MASK FOR NOT READYRE(M.RFL) TO RTNZ LOOP UNTIL READYR6 TO D112 SET UP SECTOR REGISTER HERER6 TO R0 CHECK SECTOR REGISTER TO SEE IF LOADED PROPERLYD112 TO SUB0 COMPARERE(M.RFL) TO RTNZ TRY AGAIN WITH LOAD IF NOT THERER4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000R5 TO D110 ISSUE READ COMMAND, AS COMPUTED ABOVEre(O.RFL) to RTZE no, normal readPCI to TAND0 see if poly readdata 400PCI to RTNZ yesdata OP.RFL-.-1re(OE.RFL) to RTRA external read**THE READ COMMAND HAS BEEN STARTED.  LOOP, CHECKING STATUS, AND READ DATA*IM(1) TO TAND0 CHECK IF STILL BUSYPCI TO RTZE IF NOT, THEN SKIP OUT OF ITdata G.RFL-.-1O.RFL:D110 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT, THEN CONTINUE TO LOOPD113 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD113 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO MR2I STORE WORD INTO MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(O.RFL) TO RTNZ IF MORE TO READ, LOOP BACKre(P.RFL) to RTRA go finish incomplete sectoreject***Perform read to external and poly memory from remote floppies*IM(1) TO TAND0 CHECK IF STILL BUSYPCI TO RTZE IF NOT, THEN SKIP OUT OF ITdata G.RFL-.-1OE.RFL:D110 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-6) TO RTZE IF NOT, THEN CONTINUE TO LOOPD113 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD113 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO D63 STORE WORD INTO MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(OE.RFL) TO RTNZ IF MORE TO READ, LOOP BACKre(P.RFL) to RTRA go finish incomplete sector*IM(1) TO TAND0 CHECK IF STILL BUSYRE(G.RFL) TO RTZE IF NOT, THEN SKIP OUT OF ITOP.RFL:D110 TO R0 PICK UP DISK STATUSIM(2) TO TAND0 SEE IF DATA REQUESTIM(-5) TO RTZE IF NOT, THEN CONTINUE TO LOOPD113 TO R5 PICK UP BYTEIM(2) TO R0 GET DATA REQUEST BITD110 TO TAND0 SEE IF DATA REQUESTIM(-2) TO RTZE LOOP UNTIL WE GET ITD113 TO R0 GET DATA BYTER5 to BSOR0 byte swapR0 TO D157 STORE WORD INTO MEMORYIM(1) TO SUB3 DECREMENT COUNTRE(OP.RFL) TO RTNZ IF MORE TO READ, LOOP BACK*P.RFL:D110 TO R0 CHECK STATUS TILL NDIM(2) TO TAND0 DRQ?IM(1) TO RTZE IF NOT, THEN SKIPD113 TO ATNV SKIP DATA, BUT COMPUTE CRCIM(1) TO TAND0 SEE IF BUSYRE(P.RFL) TO RTNZ BRANCH BACK IF BUSYEJECT**FLOPPY READ CONTINUED:  CHECK STATUS*G.RFL: PCI TO TAND0 CHECK FOR CRC, DATA LATE, OR LOSING READYDATA 214RE(Q.RFL) TO RTNZ IF SO, THEN A BAD DATA TRANSFERIM(20) TO TAND0 CHECK FOR RECORD NOT FOUNDPCI TO RTZE IF NOT, THEN WAS OK DATA & CORRECT ITEMDATA J.RFL-.-1Q.RFL: R4 to R3 pick up flagsPCI to TAND3 see if special readdata 1000re(QA.RFL) to RTNZ yesR10 to R2 retry - reset R2 to start of data areaR11 to R3 and reset R3 to correct length fieldre(QB.RFL) to RTRA skip over special codeQA.RFL: PCI to TAND3 see if poly or external memorydata 400re(QC.RFL) to RTNZ it's polyR10 to D60 reload external memory sectorR11 to D61 and wordre(QB.RFL) to RTRA skip over poly codeQC.RFL: im(20) to D156 and "write to poly memory" commandR10 to D157 reload poly memory sectorR11 to D157 and word and page pointerQB.RFL: PCI to TAND0 check for CRC, data late, or loosing readydata 214re(H.RFL) to RTZE if not, okay data transferIM(7) TO D50 RING BELL FOR ATTENTIONR14 TO R5 AND SAVE REGISTER INFORMATIONIM(-20) TO R14 KEEP INTERRUPTS OFF AT ALL TIMES HEREIM(10) TO R0 ACTIVATE WHEN DISKERROR ROUTINEJUMP TO PROC CALL BREAK ROUTINET.RFL:DATA 0 POINTER TO BREAK ROUTINER5 TO R14 AND RESTORE USER INTERRUPT FLAGI.RFL: MR7 TO R0 GET DEVICE TYPEIM(17) TO TAND0 EXTRACT JUST THE TYPEIM(2) TO RTNZ SKIP IF REMOTER4 TO D104 KEEP THE MOTOR ON FOR NEXT READIM(1) TO RTRA SKIP REMOTER4 TO D114 KEEP THE MOTOR ON FOR NEXT READ (REMOTE)PCI TO R5 AND SET UP R5 CONTAINING COMMANDDATA 210 THIS IS READ COMMAND, NOT MULTIPLE, IBM FORMAT, NO HEAD DELAYR4 to LOA0 see if we're talking to a D100APCI to RTPL we aren'tdata D.RFL-.-1 go back and try againim(2) to AND0 get sideim(1) to RTZE side zeroim(10) to R0 side onePCI to OR0 get commanddata 202 read sector, verify sideR0 to R5 move command to R5PCI TO RTRA AND GO BACK AND TRY AGAINDATA D.RFL-.-1 RELATIVE DISTANCEEJECT**FLOPPY READ CONTINUED:*   MAKE SURE ALL DATA WAS READ BY COMPUTER,  AND THAT NO ERRORS WERE ENCOUNTERED*H.RFL: PCI TO R5 PICK UP POINTER TO POINTER TO HEAD POSITIONSDATA CONTAB+CURTRKMR5 TO R5 PICK UP POINTER TO HEAD POSITIONSMR7 TO R0 GET DEVICE TYPEIM(17) TO TAND0 EXTRACT JUST DEVICE TYPERE(HR.RFL) TO RTNZ SKIP FLOPPY CODE FOR REMOTESPCI TO D100 STEP IN ONCE TO JOG POSITIONDATA 103 STEP IN COMMANDD100 TO R0 GET STATUSIM(1) TO TAND0 SEE IF BUSYIM(-3) TO RTNZ WAIT FOR NO LONGER BUSYRE(HS.RFL) TO RTRA SKIP REMOTE CODEHR.RFL: PCI TO D110 STEP IN ONCE TO JOG POSITION (REMOTES)DATA 103 STEP IN COMMANDD110 TO R0 GET STATUSIM(1) TO TAND0 SEE IF BUSYIM(-3) TO RTNZ WAIT FOR NO LONGER BUSYR5I to ATNV point to remote head positionsR5I to ATNVHS.RFL: R4 TO R0 GET DRIVE NUMBER/SIDE NUMBERIM(1) TO AND0 EXTRACT DRIVE NUMBERR5 TO ADD0 AND POINT TO APPROPRIATE HEAD POSITION WORDIM(0) TO MR0 RESET OUR ESTIMATED POSITIONR7 TO R0 GET POINTER TO DEVICE ENTRY IN STRDEVIM(SPDTRK) TO ADD0 POINT TO STEPPING SPEED/SECTORS PER TRACK WORDMR0 TO R0 PICK UP STEPPING SPEEDPCI TO AND0 EXTRACT STEPPING SPEEDDATA 377R3 to R5 save R3MR7 TO R3 GET DEVICE TYPEIM(17) TO TAND3 EXTRACT JUST THE TYPEIM(2) TO RTNZ SKIP FLOPPY CODE FOR REMOTESR0 TO D100 START A RESTORE COMMANDIM(1) TO RTRA SKIP REMOTE CODER0 TO D110 START A RESTORE COMMAND (REMOTES)R5 to R3 restore R3im(1) to R5 assume alternate speedMR7 to R0 get config bitsPCI to TAND0 see if alternate motor speed supported by drivedata 2000re(HA.RFL) to RTZE no, this is always an errorR4 to R0 get drive infoPCI to TAND0 see if alternate motor speed was useddata 40re(HA.RFL) to RTNZ yes, this is now an error (previous problem wasn't incorrect speed)PCI to TSUB1 see if beyond end of old disksdata 5*120 (5 sectors/track * 80 tracks)PCI to RTNC no, skip the error and try alternate motor speeddata B.RFL-.-1HA.RFL: IM(7) TO D50 RING BELL ON SEEK ERRORR14 to R5 save internal stateim(-20) to R14 keep internal state consistentIM(10) TO R0 INDICATE WHEN DISKERRORJUMP TO PROC CALL BREAK ROUTINEU.RFL:DATA 0 POINTER TO BREAK ROUTINER5 to R14 restore internal stateim(0) to R5 use normal speedPCI TO RTRA LOOP BACK TO RE-SEEKDATA B.RFL-.-1EJECT**FLOPPY READ CONTINUED:**CHECK FOR NEXT*J.RFL: MR7 TO R0 GET DEVICE TYPEIM(17) TO AND0 EXTRACT JUST THE TYPER6 TO R0 MAKE SURE SECTOR REGISTER WAS OKIM(2) TO RTNZ SKIP FLOPPY CODE FOR REMOTESD102 TO SUB0 SHOULD BE EQUALIM(1) TO RTRA SKIP REMOTE CODE FOR FLOPPIESD112 TO SUB0 SHOULD BE EQUAL (REMOTES)im(14) to R0 set bad status so Q.RFL knows this is an errorPCI TO RTNZ IF NOT, THEN ERRORDATA Q.RFL-.-1R3 TO TLOA3 SEE IF DONEPCI TO RTZE IF DONE,  THEN NO MORE TO GOdata E.RFL-.-1IM(1) TO ADD1 GET NEXT DEVICE ADDRESSR4 to R0 pick up drive infoPCI to TAND0 see if special readdata 1000re(JB.RFL) to RTZE noR10I to ATNV increment poly/external sector to read intoim(1) to SUB2 decrement sectors to readJB.RFL: PCI to TAND0 see if alternate speed useddata 40re(JC.RFL) to RTZE no, keep using normal speedim(1) to R5 yes, keep using alternate speedim(5) to R0 and use 5 sectors/trackre(JA.RFL) to RTRA and skip over normal speed codeJC.RFL: im(0) to R5 use normal speedR7 to R0 point to device table entryim(SPDTRK) to ADD0 point to sectors/trackMR0 to R0 pick up sectors/trackim(0) to BSOR0 move to lowerPCI to AND0 extract itdata 377JA.RFL: R6 to TSUB0 see if at end of track yetR6I to ATNV increment sectorPCI to RTNZ same track, next sectordata I.RFL-.-1R7 to R6 point to device table entry [R6 is trash here - SEEK resets it]R6I to ATNV point to sectors/cylinderMR6 to TSUB0 see if double-sidedPCI to RTZE not double-sided (single-sided if SECPT = SECCYL)data B.RFL-.-1 therefore must be single-sided - just stepR4 to R0 change sidesPCI to TAND0 see if alternate speed useddata 40PCI to RTNZ alternate speed - not double-sideddata B.RFL-.-1 just stepim(2) to XOR0 like soR0 to R4im(1) to R6 back to sector oneim(2) to TAND0 back to side zero?PCI TO RTNZ IF NOT,  SAME TRACK, NEXT SECTORDATA I.RFL-.-1PCI TO RTRA ELSE GO BACK AND SEEK TO NEXT TRACKDATA B.RFL-.-1**DONE WITH READ*E.RFL: R4 to R0 get drive infoPCI to TAND0 see if alternate speed useddata 40im(3) to RTZE no, we're already at normal speedim(0) to R5 return to normal speedJUMP to PROC seek back to last sector read to change speedEA.RFL: data 0R14 TO D1 RESTORE INTERRUPT FLAG TO PROPER STATEIM(LREG) TO ATRA LOAD REGS AND RETURNEJECT**Transfer to user device driver.  Registers at entry:*   R0:  Device driver table entry number for device requested*   R1:  Disk sector address (lower 16 bits)*   R2:  Pointer to memory buffer*   R3:  Number of words to read*   R5:  Logical device to read/disk sector address (upper 8 bits)**If R3 = -1 (read from disk to poly memory) or R3 = -2 (read from disk to*external memory), the following is true:*   R2:  Number of sectors to read*  R10:  Starting sector in poly/external memory*  R11:  (Number of words beyond last sector to read) (poly page pointer) *        / starting word in poly/external memory**A device driver should expect the following register settings at entry:*   R0:  Logical device to read/disk sector address (upper 8 bits)*   R1:  Disk sector address (lower 16 bits)*   R2:  Pointer to memory buffer*   R3:  Number of words to read**If R3 = -1 (read from disk to poly memory) or R3 = -2 (read from disk to*external memory), the following is true:*   R2:  Number of sectors to read*   R4:  Starting sector in poly/external memory*   R5:  (Number of words beyond last sector to read) (poly page pointer) *   /    starting word in poly/external memory*A.RDRV: im(DEVDRV/2) to TSUB0 see if entry number is in boundsre(F.RDRV) to RTRC out of range - fatal errorR0 to ADD0 multiply entry number by two to get READ device driver table offsetPCI to R6 get pointer to device driver table pointerdata CONTAB+DEVTABMR6 to TLOA0 see if there's a tablere(F.RDRV) to RTZE if no table, we have a fatal errorMR6 to ADD0 point to table entry for our device's driverMR0 to LOA0 pick up pointer to device driver routinere(B.RDRV) to RTNZ we have a driverF.RDRV: im(7) to D50 no driver, beep at themim(10) to R0 point to DISKERRORJUMP to PROC call BREAK routineC.RDRV: data 0 pointer to BREAK routinere(F.RDRV) to RTRA loop foreverB.RDRV: R0 to R6 save driver addressif ^ModelCR15I to R12 save stack startR17 to R0 compute return addressim(D.RDRV-.-1) to ADD0R0 to MR15I stack return addressR12 to MR15 finish stack frameendif of ^ModelCR5 to R0 restore R0R10 to R4 move R10 to R4R11 to R5 move R11 to R5R6 to ATRA and "call" the driverD.RDRV: im(LREG) to ATRA returnEJECT**READ DATA FROM WINCHESTER DISK*WR1:R0 to R5 set sector MSB asideMR7 to R0 pick up device typePCI to AND0 see if SCSI or IMI type drivedata 1400 drive type fieldim(0) to R0 table entry 0 is for SCSI drivePCI to RTNZ it's SCSI (no others supprted yet)data A.RDRV-.-1im(0) to R10 clear flagsR4 to R0 pick up flagsPCI to TAND0 see if special readdata 1000re(WR15) to RTZE nopeim(0) to R3  assume we are polyPCI to TAND0 see if we are polydata 400im(1) to RTNZ if so, then word length will be zeroR11 to R3 get word lengthim(0) to BSOR3 move to lowerPCI to AND3data 377R3 to OR0 add into flagsPCI to OR0 set sign bit so we can do a quick check with no regs useddata 100000R0 to R10 and move to R10WR15: R5 to R0 restore sector MSBPCI to AND0 but only keep the sector MSBdata 377WR3:JUMP TO PROC CALL WINCHESTER SELECT ROUTINEWR2:DATA 0 POINT TO SELECTWR8: R10 to TLOA0 see if special readre(WR85) to RTPL noPCI to R3 set word lengthdata 401 longer than a sector so we don't prematurely terminateR2 to TLOA0 check sector lengthre(WR85) to RTNZ still sectors leftR10 to R3 we've read all sectors - get final word countPCI to AND3data 377im(LREG) to ATZE get out here if ends on sector boundaryWR85: R6 TO R0 GET MSB OF SECTOR NUMBERIM(2) TO OR0 OR IN READ COMMANDR0 TO D107 SEND ON READ COMMANDD106 TO R0 **WAIT FOR READY IN CASE DIFFERENT DRIVED106 TO OR0 CHECK TWICE IN CASE WE GET IT BETWEEN BYTESIM(1) TO TAND0IM(-4) TO RTNZR5 TO D107 SEND ON SECTOR LSB'SD106 TO R0 LOOP FOR STATUS RETURN IN CASE INTERRUPTS ONIM(2) TO TAND0 WAIT FOR RETURN CODEIM(-3) TO RTZE WAIT FOR NONZEROD107 TO R1 GET RETURN CODEPCI TO TAND1 CHECK FOR NONZERO RETURN CODEDATA 177re(WR9) to RTZE skip if no errorIM(7) TO D50 beep once if recovered errorim(10) to R0 indicate diskerrorJUMP TO PROC call BREAKWR10: data 0 point to BREAKWR9: PCI TO TAND1 CHECK FOR FATAL ERRORDATA 200re(WR0) to RTZE skip if no errorIM(7) TO D50 beep forever if can't recoverim(10) to R0 indicate diskerrorJUMP TO PROC call BREAKWR11: data 0 point to BREAKIM(-5) to RTRA loop foreverWR0: R10 to TLOA0 see if special readre(WR0M) to RTPL no, normal readR10 to R0 pick up flagsPCI to TAND0 see if poly readdata 400PCI to RTNZ yesdata WR0P-.-1PCI to RTRA external readdata WR0E-.-1eject***Data loop - D107 to main memory*WR0M: PCI TO TSUB3 CHECK FOR 256 LENGTHDATA 400RE(WR4) TO RTRC 256 OR GREATER LENGTHPCI TO R0 GET 256 COUNTERDATA 400WR5:D107 TO R1 GET DATA FROM WINCHESTERR3 TO TLOA3 SEE IF SHOULD PUT INTO MEMORYIM(2) TO RTZE IF NOT, THEN SKIPR1 TO MR2IIM(1) TO SUB3 REDUCE LENGTHIM(1) TO SUB0 DECREMENT COUNTRE(WR5) TO RTNZ GO BACK IF MOREPCI TO RTRA ELSE DONEdata WR6-.-1WR4: ...if ^ModelCIM(20) TO R0 HIGH SPEED LOOP - TRY TO READ/WRITE CONSECUTIVE SECTORSWR7:D107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2ID107 TO MR2IIM(1) TO SUB0RE(WR7) TO RTNZendif of ^ModelCif ModelCPCI to D10 read entire sectordata 377 (256 words)D107 to MR2I read the next wordendifPCI TO SUB3 REDUCE LENGTH BY 256DATA 400PCI to RTRA done with sector transferdata WR6-.-1eject***Data loop - D107 to external memory*WR0E: PCI TO TSUB3 CHECK FOR 256 LENGTHDATA 400RE(WR4E) TO RTRC 256 OR GREATER LENGTHPCI TO R0 GET 256 COUNTERDATA 400WR5E:D107 TO R1 GET DATA FROM WINCHESTERR3 TO TLOA3 SEE IF SHOULD PUT INTO MEMORYIM(2) TO RTZE IF NOT, THEN SKIPR1 TO D63IM(1) TO SUB3 REDUCE LENGTHIM(1) TO SUB0 DECREMENT COUNTRE(WR5E) TO RTNZ GO BACK IF MOREPCI TO RTRA ELSE DONEdata WR6-.-1WR4E: ...if ^ModelCIM(20) TO R0 HIGH SPEED LOOP - TRY TO READ/WRITE CONSECUTIVE SECTORSWR7E:D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63D107 TO D63IM(1) TO SUB0RE(WR7E) TO RTNZendif of ^ModelCif ModelCPCI to D10 read entire sectordata 377 (256 words)D107 to D63 read the next wordendifPCI TO SUB3 REDUCE LENGTH BY 256DATA 400PCI to RTRA done with sector transferdata WR6-.-1eject***Data loop - D107 to polyphonic sampling memory*WR0P: PCI TO TSUB3 CHECK FOR 256 LENGTHDATA 400RE(WR4P) TO RTRC 256 OR GREATER LENGTHPCI TO R0 GET 256 COUNTERDATA 400WR5P:D107 TO R1 GET DATA FROM WINCHESTERR3 TO TLOA3 SEE IF SHOULD PUT INTO MEMORYIM(2) TO RTZE IF NOT, THEN SKIPR1 TO D157IM(1) TO SUB3 REDUCE LENGTHIM(1) TO SUB0 DECREMENT COUNTRE(WR5P) TO RTNZ GO BACK IF MORERE(WR6) TO RTRA ELSE DONEWR4P: ...if ^ModelCIM(20) TO R0 HIGH SPEED LOOP - TRY TO READ/WRITE CONSECUTIVE SECTORSWR7P:D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157D107 TO D157IM(1) TO SUB0RE(WR7P) TO RTNZendif of ^ModelCif ModelCPCI to D10 read entire sectordata 377 (256 words)D107 to D157 read the next wordendifPCI TO SUB3 REDUCE LENGTH BY 256DATA 400eject***End of reading a sector*WR6:IM(1) TO R0 PUT A 1 IN R0R5I TO TADD0 INCREMENT SECTOR LSBRE(WR20) TO RTNZ CHECK FOR CARRYR4I TO ATNV carry into normal MSBR6 TO R1 carry into IMI format MSBD106 TO TLOA0 WAIT FOR READY TO COME BACK FROM READIM(-2) TO RTNZim(0) to D107 see if MFM Winchester controllerD107 to TLOA0im(3) to RTNZ yes, skip IMI carryPCI TO ADD1DATA 010000 UPPER 4 BITS FOR IMI FORMATim(2) to RTRA skip MFM carryPCI to ADD1data 001000 upper 7 bits for MFM formatR1 TO R6WR20: D106 TO R1 WAIT FOR READY TO COME BACK HERE (GOES AWAY FOR A MOMENT)IM(1) TO TAND1 BETWEEN OPERATIONSIM(-3) TO RTNZ IF NOT READY, LOOP BACKR3 TO TLOA3 CHECK FOR DONE WITH DATAIM(LREG) TO ATZE NO MORE TO DO - LOAD REGISTERS AND RETURNR10 to TLOA0 see if special readim(1) to RTPL nopeim(1) to SUB2 decrement sector countR11I TO TADD0 CHECK FOR REACHING END OF DISKPCI TO RTNZ IF NOT AT END OF DISK, THEN JUST GO BACKDATA WR8-.-1 TO GIVE NEXT COMMANDR4 TO R0 RESTORE NEXT SECTOR NUMBERR5 TO R1 TO R0/R1 FOR WSL CALLPCI TO RTRA ELSE MUST SELECT NEXT DRIVEDATA WR3-.-1*Z.RFL: DATA A.RFL BEGIN PATCH LISTDATA L.FDE FIND DEVICE ENTRYDATA F.RFLDATA L.BRK BREAKDATA C.RFLDATA L.SEE SEEKDATA T.RFL TDATA L.BRK BREAKDATA U.RFL UDATA L.BRK BREAKDATA EA.RFLDATA L.SEE SEEKDATA C.RDRVDATA L.BRK BREAKDATA WR2DATA L.WSL SELECTDATA WR10DATA L.BRK BREAKDATA WR11DATA L.BRK BREAKDATA 0 END OF SEGMENTeject***EXTREAD Entrance:**EXTREAD is passed:*  R0: Logical device to read/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Pointer to buffer containing (at offset):*      0: Base sector in external memory*      1: Offset word from base in external memory*      2: Number of sectors to read*      3: Number of words beyond last sector to read**EXTREAD normalizes the sector/word addresses and calls READDATA with:*  R0: Logical device to read/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Number of sectors to read*  R3: -2* R10: Starting sector in external memory* R11: Number of words beyond last sector to read/starting word in external memory*R.ERD: data Z.ERD pointer to patch listif ModelCD10 to MR12D stack returnendifim(SREG) to ATRA save registers on stackD60 to R6 save sector registerD61 to R7 and word register***Normalize the starting address*MR2I to R5 pick up the baseMR2 to R3 and the offsetim(0) to BSOR3 get the sector specified in the offsetPCI to AND3data 377R5 to ADD3 add in the base - this is the starting sectorR3 to R10 set base aside for READDATAMR2I to R3 pick up offset againPCI to AND3 keep starting word address onlydata 377R3 to R11 set aside for READDATA***Normalize the length to read*MR2I to R5 pick up the sector lengthMR2 to R3 and the word lengthim(0) to BSOR3 get sector length specified in word lengthPCI to AND3data 377R5 to ADD3 add in the number of sectors specified - this is the sector lengthR3 to R5 set sector length asideMR2 to R3 pick up word address againPCI to AND3 keep word length onlydata 377im(0) to BSOR3 move to upperR11 to OR3 add in starting wordR3 to R11 and put back for READDATA*R5 to R2 set up sector length for READDATAim(-2) to R3 and flag that we're reading into external memoryJUMP to PROC call READDATAA.ERD: data 0 pointer to READDATA*R6 to D60 restore sector registerR7 to D61 and word registerim(LREG) to ATRA and get out*Z.ERD: data A.ERD start of patch listdata L.RFL READDATAdata 0 end of patch listeject***POLYREAD Entrance:**POLYREAD is passed:*  R0: Logical device to read/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Pointer to buffer containing (at offset):*      0: Base sector in poly memory*      1: Offset word from base in poly memory*      2: Number of complete sectors to read*      3: Page number of poly memory*  R3: Polyphonic sampling channel number**POLYREAD normalizes the sector/word addresses and calls READDATA with:*  R0: Logical device to read/Upper 8 bits of disk sector address*  R1: Lower 16 bits of disk sector address*  R2: Number of sectors to read*  R3: -2* R10: Starting sector in poly memory* R11: Poly memory page number/starting word in poly memory*R.PRD: data Z.PRD pointer to patch listif ModelCD10 to MR12D stack returnendifim(SREG) to ATRA save registers on stackR3 to D155 select poly channel here***Normalize the starting address*MR2I to R5 pick up the baseMR2 to R3 and the offsetim(0) to BSOR3 get the sector specified in the offsetPCI to AND3data 377R5 to ADD3 add in the base - this is the starting sectorR3 to R10 set base aside for READDATAMR2I to R3 pick up offset againPCI to AND3 keep starting word address onlydata 377R3 to R11 set aside for READDATA***Store away the sector length to read,  also page #*MR2I to R5   pick up the sector length; save it asideMR2  to R3   get poly memory page #PCI to AND3  extract page bitsdata   377im(0) to BSOR3 get it in upper halfR11 to OR3 add in starting wordR3 to R11  and put back for READDATA*R5 to R2 set up sector length for READDATAim(-1) to R3 and flag that we're reading into polyphonic sampling memoryJUMP to PROC call READDATAA.PRD: data 0 pointer to READDATA*im(LREG) to ATRA and get out*Z.PRD: data A.PRD start of patch listdata L.RFL READDATAdata 0 end of patch list