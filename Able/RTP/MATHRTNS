TTL MATHEMATICAL FUNCTION ROUTINES (SQRT, SIN, LOG, ETC.)**SQUARE ROOT ROUTINE*  AC0 = POINTER TO FLOATING POINT VARIABLE*  RETURNS AC0-AC1 = FLOATING SQUARE ROOT*R.SQR:DATA Z.SQR END OF SEGMENTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGSITER ON STACKPCI TO AND0 SET NUMBER TO POSITIVEDATA 077777 SET IT POSITIVEPCI TO RTZE IF ZERO,  THEN RESULT IS ZERO & RETURNDATA J.SQR-.-1 RELATIVE DISTANCER0 TO R4 GET UPPER HALF (SIGN & MANTISSA) IN R4R1 TO R5 GET ULOWER IN R5 (MAN & EXP)im(0) to SHRA1 shr by onePCI TO AND1 EXTRACT OFF USEFUL EXPONENT FIELD DATA 077677 SO EXPONENT FIELD IS STILL OKIM(-40) TO SUB1 ADD 32 TO BRING EXPONENT FIELD BACK UPR1 TO R7 AND PUT IN R7R4 TO R6 AND THIS IS UPPER PART IF ESTIMATEIM(0) TO R10 INITIAL ERRORIM(0) TO R11 IS ZEROC.SQR:R6 TO R0 GET ESTIMATER7 TO R1 IN FAC0R6 TO R2 IN BOTHR7 TO R3 DITTOJUMP TO PROC AND CALLD.SQR:DATA 0 THE MULTIPLY ROUTINER0 TO R2 GET IN R2 FOR SUBTRACTR1 TO R3 DITTOR4 TO R0 GET XR5 TO R1 DITTOJUMP TO PROC AND CALLE.SQR:DATA 0 SUBTRACT TO GENERATE X-Y*YR6 TO R2 NOW GET Y AGAINR7 TO R3 BOTH PARTSIM(1) TO ADD3 GET Y*2 BY ADDING ONE TO EXPONENTJUMP TO PROC AND CALL NOWF.SQR:DATA 0 THE DIVIDE ROUTINE TO GET (X-Y*Y)/(2*Y)R10 TO TSUB0 SEE IF THIS ERROR IS WHAT WE GOT LAST TIMERE(G.SQR) TO RTNZ IF NOT, THEN ADD IN ERROR AND RECALCULATER11 TO TSUB1 CHECK BOTH PARTSRE(B.SQR) TO RTZE IF ZERO, THEN NO CHANGE - WE ARE AS ACCURATE AS WE CAN GETG.SQR:R6 TO R2 GET CURRENT ESTIMATER7 TO R3 DITTOR0 TO R10 SAVE THE ERROR THAT WE GOT THIS TIMER1 TO R11 DITTOJUMP TO PROC AND CALLH.SQR:DATA 0 THE ADD ROUTINER0 TO R6 AND GET NEW ESTIMATER1 TO R7 SAVE BOTH PARTSRE(C.SQR) TO RTRA AND GO BACK FOR NEXT ESTIMATEB.SQR:R7 TO R1 DITTOR6 TO LOA0 RESTORE RESULT TO R0, CHECK SIGNJ.SQR:IM(LREG) TO ATRA AND GO BACK THERE*Z.SQR:DATA D.SQR BEGIN PATCH LISTDATA L.FPM FLOATING MULDATA E.SQR EDATA L.FPS FLOATING SUBTRACTDATA F.SQR FDATA L.FPD AND DIVIDEDATA H.SQR HDATA L.FPA AND ADD ROUTINEDATA 0 END OF SEGMENTEJECT**POLY - POLYNOMIAL ROUTINE**THE ROUTINE 'R.PLY' (POLY) IS CALLED TO COMPUTE A POLYNOMIAL EXPRESSION*DURING THE MATH CALCULATION ROUTINES.**POLY IS PASSED:*  IN AC0-AC1,  A FLOATING POINT ARGUMENT*  IN AC2,  A  POINTER (ABSOLUTE) TO A COEFFICIENT LIST**THE COEFFICIENT LIST IS TERMINATED WITH A ZERO.**POLY COMPUTES THE EXPRESSION*  C3*(X^3) + C2*(X^2) + C1*(X) + C0**POLY USES AC0-AC3, AND RETURN RESULT IN AC0-AC1.*POLY ALSO USES R7,R10,R11*R.PLY:DATA Z.PLY POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifR0 TO R10 SAVE ARG MSBR1 TO R11 SAVE ARG LSBR2 TO R7 AND SAVE PTR TO COEF LISTMR7I TO R0 GET FIRST COEFMR7I TO R1 DITTOA.PLY:R10 TO R2 GET MSBR11 TO R3 IN BOTH REGSJUMP TO PROC PERFORM SUB CALLB.PLY:DATA 0 WILL POINT TO MULTIPLYMR7I TO R2 GET NEXT COEFMR7I TO R3 AND NEXTJUMP TO PROC PERFORM SUB CALC.PLY:DATA 0 WILL POINT TO ADDMR7 TO TLOA2 SEE IF END OF COEF LISTRE(A.PLY) TO RTNZ IF NOT,  THEN GO BACKif ModelCim(0) to TADD0 make sure M & Z represent R0R12I to ATNV back up stack pointerendifRETURN to ATRA and return to caller*Z.PLY:DATA B.PLY BEGIN PATCH LISTDATA L.FPM MULTIPLY ROUTINEDATA C.PLY CDATA L.FPA ADD ROUTINEDATA 0 END OF SEGMENTEJECT**MATH ROUTINES:**THE FLOATING POINT FUNCTIONS ABS, LOG, ATN, COS, SINE, TAN, AND EXPONENET*ARE COMPUTED BY THE FOLLOWING ROUTINES.**EACH ROUTINE IS PASSED A FLOATING POINT NUMBER IN AC0, AND THE ROUTINE*PROCEEDS TO CALCULATE THE APPROPRIATE FUNCTION FOR SAME.***FLOATING POINT ABS FUNCTION:*R.ABS:DATA Z.ABS POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifPCI TO AND0 FOR HERE,  JUST SET SIGN BIT TO ZERODATA 077777 MAKE SIGN BIT A ZERORETURN TO ATRA AND RETURN TO CALLERZ.ABS:DATA 0 END OF SEGMENTEJECT**FLOATING POINT NATURAL LOG FUNCTION:*R.LOG:DATA Z.LOG POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSPCI TO AND0 TAKE ABS HEREDATA 077777 MASK TO NON-SINERE(C.LOG) TO RTNZ IF NONZERO,  THEN OK - CONTINUEIM(-1) TO LOA1 ELSE RETURN - INFINITY = LOG(0)IM(-1) TO LOA0PCI TO RTRA AND GO TO RETURNDATA D.LOG-.-1 EXIT HEREC.LOG:R1 TO R2 LET'S EXTRACT THE EXPONENTPCI TO AND2 EXTRACT ITDATA 177 EXPONENT FIELDPCI TO SUB2 AND SET GENUINE TWO'S COMPLEMENT OF EXPONENT -64 TO +63DATA 100R2 TO R6 SAVE EXPONENT FOR POWER OF TWO CALUCULATIONPCI TO AND1 MASK OF EXPONENT IN ORIGINAL WORDDATA 177600 HEREPCI TO OR1 AND SET EXPONENT = 64 = .5-.99999999DATA 100R0 TO R4 SAVE .5-.999999R1 TO R5 DITTOPCI TO R2 AND GET SQR(1/2)DATA 055202PCI TO R3 SAMEDATA 074500JUMP TO PROC AND PERFORM SUBTRACTE.LOG:DATA 0 POINTER TO SUBTRACT ROUTINE AFTER PATCHINGR0 TO TADD0 CHECK SIGN OF RESULTRE(F.LOG) TO RTZE IF =, THEN OKRE(F.LOG) TO RTRC IF -, THEN Y<.707XXX AND OK**IF Y>.707XXX A=1*PCI TO R10DATA 040000PCI TO R11DATA 000101 FLOATING POINT 1.0000000RE(G.LOG) TO RTRA AND CONTINUE**Y<=.707,  A=.5 AND REDUCE EXPONENT*F.LOG:PCI TO R10 GET .5DATA 040000PCI TO R11 DITTDATA 000100R6 TO R0 GET EXPONENT CURRENTLYIM(1) TO SUB0 REDUCE ITR0 TO R6 AND SAVE AGAIN**PERFORM POLYNOMIAL*G.LOG:R4 TO R0 GET YR5 TO R1 SAMER10 TO R2 AND GET A SELECTED ABOVE (.5 OR 1.0)R11 TO R3 SAMEJUMP TO PROC PERFORM SUB CALLH.LOG:DATA 0 PTR TO ADDITION ROUTINER10 TO R2 GET A AGAIN,  IN THESE NOW FREE REGISTERSR11 TO R3 AND SAMER0 TO R10 AND SAVE Y+A IN HERER1 TO R11 DITTOR4 TO R0 AND GET Y AGAINR5 TO R1 DITTOJUMP TO PROC PERFORM SUB CALLI.LOG:DATA 0 POINTER TO SUBTRACTR10 TO R2 MOVE Y+A TO FR1R11 TO R3 HERE TOOJUMP TO PROC PERFORM SUB CALJ.LOG:DATA 0 POINTER TO DIVIDE - COMPUTE (Y+A)/(Y-A)R0 TO R4 SAVE Z=(Y+A)/(Y-A)R1 TO R5 DITTOR0 TO R2 NOW SQUARE IT,  FOR POLY ROUTINER1 TO R3 DITTOJUMP TO PROC AND PERFORM SUB CALLK.LOG:DATA 0 MULTIPLY ROUTINER17 TO R2 GET CURRENT LOCATION OF MEMORYIM(LOGTB-.) TO ADD2 ADD IN OFFSET ROM HERE,  GENERATE POINTER TO TABLEJUMP TO PROC PERFORM SUB CALLM.LOG:DATA 0 PTR TO POLY ROUTINER4 TO R2 NOW COMPUTE Z*POLY(Z*Z)R5 TO R3 DITTOJUMP TO PROC PERFORM SUB CALN.LOG:DATA 0 PTR TO MULR0 TO R4 SAVE Z*POLY(Z*Z)R1 TO R5 SAVER6 TO R0 GET EXPONENT, CALUCLATED ABOVEJUMP TO PROC PERFORM SUB CALLP.LOG:DATA 0 PTR TO FLOATPCI TO R2 AND GET LOG2(E)DATA 054271PCI TO R3 DITTODATA 005700JUMP TO PROC PERFORM SUB CALLQ.LOG:DATA 0 MULTIPLYR4 TO R2 GET RESULT OF ABOVER5 TO R3 DITTOJUMP TO PROC PERFORM SUB CALLS.LOG:DATA 0 PTR TO ADD ROUTINE          D.LOG:IM(LREG) TO ATRA EXIT ROUTINE*LOGTB:DATA 065111 TABLE OF COEFFICIENTS FOR LOG ROUTINEDATA 010077 DATA 052515 C1DATA 167100DATA 040000 C0DATA 001102DATA 0 FINAL ZERO*Z.LOG:DATA E.LOG BEGIN PATCH LISTDATA L.FPS TO SUBTRACTDATA H.LOG HDATA L.FPA FLOATING POINT ADDDATA I.LOG IDATA L.FPS TO SUBTRACTDATA J.LOG JDATA L.FPD DIVIDEDATA K.LOG KDATA L.FPM MULTIPLYDATA M.LOG MDATA L.PLY POLY ROUTINEDATA N.LOG NDATA L.FPM MULTIPLYDATA P.LOG PDATA L.FLO FLOATDATA Q.LOG QDATA L.FPM FLOATING MULTIPLYDATA S.LOG SDATA L.FPA ADDDATA 0 END OF SEGMENTEJECT**FLOATING POINT ARC TANGENT ROUTINE*R.ATN:DATA Z.ATN POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKIM(0) TO R6 INITIALIZE FLAGR0 TO TADD0 CHECK SIGN BIT OF ARGUMENTRE(C.ATN) TO RTNC IF PLUS,  THEN OKIM(1) TO R6 IF NEGATIVE,  THEN SET FLAG AS SUCHPCI TO AND0 AND SET TO POSITIVEDATA 077777C.ATN:R0 TO R4 SAVE ABS(X)R1 TO R5 DITTOPCI TO R2 GET A 1.00000DATA 040000 PCI TO R3 DISTODATA 000101JUMP TO PROC PERFORM SUB CALLD.ATN:DATA 0 TO SUBTRACTK ROUTINER0 TO TADD0 CHECK SIGN OF ARG-1.00000RE(E.ATN) TO RTZE IF =, THEN OKRE(E.ATN) TO RTRC IF < THEN HERE**IF >1,  THEN USE 1/X,  AND CHECK LATER*PCI TO R0 GET A 1.000000DATA 040000PCI TO R1DATA 000101R4 TO R2 AND GET ABS(X)R5 TO R3JUMP TO PROC PERFORM SUB CALLF.ATN:DATA 0 DIVIDE ROUTINER6 TO R2 GET BITSIM(2) TO OR2 SET THIS BITR2 TO R6 AND RESTORE BITSR0 TO R4 SAVE 1/X HERER1 TO R5 FOR FUTURE USE*E.ATN:R4 TO R2 GET Y=ABS(X) OR 1/(ABS(X)R5 TO R3 SAME HEREPCI TO R0 SEE IF <,=,OR> TAN(PI/12)DATA 042230 TAN PI/12PCI TO R1 HEREDATA 050477JUMP TO PROC PERFORM SUB CALLG.ATN:DATA 0 POINTER TO SUBR0 TO TADD0 CHECK SIGN OF RESULTPCI TO RTNC IF <= THEN OKDATA H.ATN-.-1 RELATIVE DISTANCEEJECT**ARG > TAN(PI/12)  FUDGE HERE, SET BIT *COMPUTE(Z=(Y*SQR(3)-1)/(Y+SQR(3)))*R4 TO R0 GET Y=ABS(X) OR 1/ABS(X)R5 TO R1 DITTOPCI TO R2 GET SQR3DATA 067331PCI TO R3DATA 166101JUMP TO PROC PERFORM SUB CALLI.ATN:DATA 0 POINTER TO ADD COMPUTE Y+SQR(3)R0 TO R10 SAVE Y+SQR(3)R1 TO R11R4 TO R0 GET Y AGAINR5 TO R1 DITTOPCI TO R2 GET SQR(3) AGAIN FOR MULTIPLYDATA 067331PCI TO R3 DATA 166101JUMP TO PROC PERFORM SUB CALLJ.ATN:DATA 0 MULTIPLY COMPYUTE Y*SQR(3)PCI TO R2 GET A 1.000000DATA 040000PCI TO R3DATA 000101JUMP TO PROC PERFORM SUB CALLK.ATN:DATA 0 SUBTRACT - COMPUTE Y*SQR(3)-1R10 TO R2 NOW GET Y+SQR(3)R11 TO R3 DITTOJUMP TO PROC PERFORM SUB CALLM.ATN:DATA 0 DIVIDE - COMPUTE (Y*SQR(3)-1)/(Y+SQR(3))R0 TO R4 SAVE Z=XXX HERER1 TO R5 SAVER6 TO R2 GET BITS WORDIM(4) TO OR2 SET BIT INDICATING MURPHEY'S CONSTANTR2 TO R6 SAVE**NOW COMPUTE PROPER POLY*H.ATN:R4 TO R0 GET ZR5 TO R1R4 TO R2 AND SQUARE ITR5 TO R3JUMP TO PROC PERFORM SUB CALLN.ATN:DATA 0 TO MULTIPY - COMPUTE Z*ZR17 TO R2 GET PTR TO COEF LISTPCI TO ADD2 ADD IN OFFSET TO TABLEDATA ATNTB-.+1 GENERATES PTR TO COEFSJUMP TO PROC PERFORM SUB CALLP.ATN:DATA 0 WILL POINT TO POLYR4 TO R2 AND MULTIPLY AGAINR5 TO R3 TO COMPUTE Z*POLY(Z*Z)JUMP TO PROC SUB CALLQ.ATN:DATA 0 COMPUTE Z*POLY(Z)R6 TO R2 NOW CHECK BITSIM(4) TO AND2 SEE IF WE USED Z=XF(SQR(3))RE(W.ATN) TO RTZE IF NOT, THEN OKEJECT**JUSTIFY ANSWER FOR SQR(3)*PCI TO R2 GET PI/6DATA 041405PCI TO R3DATA 044300JUMP TO PROC AND ADD THAT IN TO POLY CALCS.ATN:DATA 0 PTR TO ADDW.ATN:R6 TO R2 CHECK BIT AGAIN FOR 1/XIM(2) TO AND2 THIS BITRE(T.ATN) TO RTZE IF NOT,  THEN ANSWER IS OK**CORRECT FOR USING 1/X*R0 TO R2 MOVE TO R2, R3R1 TO R3PCI TO R0 GET PI/2 TO FR0DATA 062207PCI TO R1DATA 166101 HEREJUMP TO PROC AND SUBTRACT THATU.ATN:DATA 0 SUBTRACT**NOW CHECK FOR NEGATIVE*T.ATN:R6 TO R2 GET BITSIM(1) TO AND2 CHECK THAT BITRE(V.ATN) TO RTZE IF WAS POS,  THEN IS OKPCI TO XOR0 SET ANSWER TO NEGATIVEDATA 100000V.ATN:...if ModelCim(0) to TADD0 make sure M & Z represent R0endifIM(LREG) TO ATRA AND GO BACK**COEFS FOR ATN COMPUTATION*ATNTB:DATA 140632DATA 130076DATA 063022 C2DATA 023076DATA 152524 C1DATA 136077DATA 040000 C0DATA 000101DATA 0 END OF LIST*Z.ATN:DATA D.ATN BEGIN PATCH LISTDATA L.FPS SUBTRACTDATA F.ATN FDATA L.FPD DIVIDEDATA G.ATN GDATA L.FPS SUBTRACTDATA I.ATN IDATA L.FPA ADDDATA J.ATN JDATA L.FPM MULTIPLYDATA K.ATN KDATA L.FPS SUBTRACTDATA M.ATN MDATA L.FPD DIVIDEDATA N.ATN NDATA L.FPM MULTIPLYDATA P.ATN PDATA L.PLY POLY ROUTINEDATA Q.ATN QDATA L.FPM MULTIPLYDATA S.ATN SDATA L.FPA ADDDATA U.ATN UDATA L.FPSDATA 0 END OF PATCH LISTEJECT**FLOATING POINT COSINE ROUTINE:**  SET OPERATION TYPE AND CALL SINE ROUTINE*R.COS:DATA Z.COS POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SVE REGS ON STACIM(2) TO R2 SET UP R2 CONTAINING FLAG BITSPCI TO R3 GET POINTER TO SINE ROUTINEA.COS:DATA 0 SINEIM(C.SNE-D.SNE) TO ADD3 ADD IN OFFSETR3 TO ATRA AND GO ENTER SINE ROUTINE MIDAZ.COS:DATA A.COS BEGIN PATCH LISTDATA L.SNE SINE ROUTINEDATA 0 END OF SEGMENT**FLOATING POINT SINE ROUTINE*R.SNE:DATA Z.SNE POINTER TO PATCH LISTD.SNE:... START OF SINE ROUTINEif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKIM(0) TO R2 INITIAL QUADRANT ESTIMATE FOR SINE IS 0.R0 TO TADD0 SEE IF MINUSIM(1) TO RTNC IF IS +, THEN OKIM(4) TO R2 IF WAS -, THEN OK - SET WUADRANT TO 4C.SNE:... ENTER HERE WITH RR2 SET UP FROM COSINE ROUTINER2 TO R6 SAVE INITIAL QUADRANT ESTIMATE IN R6PCI TO AND0 AND SET TO POSITIVEDATA 077777PCI TO R2 GET PI/4DATA 062207PCI TO R3DATA 166500 HEREJUMP TO PROC DIVIDEE.SNE:DATA 0 DIVIDE ROUTINE - GET X/(PI/4)R0 TO R4 SAVE X/(PI/4)R1 TO R5JUMP TO PROC SUB CALLF.SNE:DATA 0 FIX ROUTINE - GET INT(X/(PI/4))R0 TO R1 SAVE INTEGER VALUE HERER6 TO ADD1 ADD IN BASE QUADRANT - 2 FOR COS, 0 FIR SINE, 4 FOR -SINEIM(7) TO AND1 AND MODULO 2PIR1 TO R6 AND SAVE BASE QUADRANT - 0-7 * PI/4JUMP TO PROC PERFORM SUB CALL TO REFLOAT INT PARTG.SNE:DATA 0 FLOAT - REFLOAT THE INTEGEAR PARTR0 TO R2 MOVE TO R2-R3R1 TO R3 FLOATING (INT(X))R4 TO R0 AND GET XR5 TO R1JUMP TO PROC AND SUBTRACT - X-INT(X) = FRACTIONAL PARTH.SNE:DATA 0 SUBTRACTR6 TO R2 CHECK FOR QUADRANTIM(1) TO AND2 SEE IF FIRST 45DEG OR SECOND 45DEG OF A QQUADRANTRE(I.SNE) TO RTZE IF IN FIRST HALF,  THEBN OKR0 TO R2 MOVE TO R2, R3R1 TO R3PCI TO R0 GET 1.000DATA 040000PCI TO R1DATA 000101JUMP TO PROC AND SUBTACT 1-INT PART FOR SECOND 45DEG QUADJ.SNE:DATA 0 PTREJECT**CONTINUE WITH SINE CALCULATION**COMPUTE POLY,  R0-R1 = 0.000000-1.000000, QUADRANT BITS IN R6*I.SNE:R0 TO R4 SAE ITR1 TO R5 SAVE INITIAL ARG = 0.000000-1.00000R0 TO R2 AND SQUARER1 TO R3JUMP TO PROC SQUARE ITK.SNE:DATA 0 PTR TO MULR6 TO R2 SEE IF SHOULD USE SINE/COSINE TABLEIM(1) TO ADD2 INCREMENT - LOOK FOR 00 OR 11 IN LXBIM(2) TO AND2 SEE IF BECAME 10 OR 11 (FROM 01 OR 10)RE(M.SNE) TO RTZE IF ZERO, WAS 00 OR 11R17 TO R2 GET CURRENT POINTERIM(COSTB-.) TO ADD2 GENERATE POINTERJUMP TO PROC AND CALL POLY TO GET POLY(X)N.SNE:DATA 0 POLY ROUTINERE(P.SNE) TO RTRA AND CONINUEM.SNE:R17 TO R2 USE SINE LIST - GET CURRENT POINTERIM(SINTB-.) TO ADD2 GET POINTERJUMP TO PROC CALL POLYQ.SNE:DATA 0 POLY ROUTNER4 TO R2 AND POLY*ZR5 TO R3JUMP TO PROC AND MULTS.SNE:DATA 0 MUL Z*POLY(Z)P.SNE:R6 TO R2 CONTINUE - SEE IF NEGATIVEPCI TO AND0 SET POSITIVEDATA 077777IM(4) TO AND2 SEE IF SHOULD BE MINUSIM(2) TO RTZE IF NOT,  THEN OKPCI TO OR0 SET MINUSDATA 100000IM(LREG) TO ATRA AND RETURN*COSTB:DATA 151615 C3  COSINE TABLEDATA 072065DATA 040353 C2DATA 114473DATA 147364 C1DATA 161077DATA 040000 C0DATA 000101DATA 0*SINTB:DATA 145544 C3  SIN TABLEDATA 137062DATA 050627 C2DATA 122070DATA 151256 C1DATA 166075DATA 062207 C0DATA 166500DATA 0*Z.SNE:DATA E.SNE BEGIN PATCH LISTDATA L.FPD DIVIDEDATA F.SNE FDATA L.FIX FIXDATA G.SNE GDATA L.FLO FLOATDATA H.SNE HDATA L.FPS SUBTRACTDATA J.SNE JDATA L.FPS SUBTRACTDATA K.SNE KDATA L.FPM MULTIPLYDATA N.SNE NDATA L.PLY POLYDATA Q.SNE QDATA L.PLY POLYDATA S.SNE SDATA L.FPM MULTIPLYDATA 0 END OF SEGMENTEJECT**FLOATING POINT TANGENT ROUTINE*R.TAN:DATA Z.TAN POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSR0 TO R2 MOVE SIGN & MANTISSA TO R2PCI TO AND2 EXTRACT SIGN BITDATA 100000R2 TO R6 AND SAVE THAT IN R6 DURING CALUCLATIONR6 TO XOR0 AND TURN OF SIGN BIT IF IT IS ON**MODULO PI/4:*PCI TO R2 GET PI/4DATA 062207PCI TO R3DATA 166500JUMP TO PROC AND PERFORM DIVIDE - COMPUTE ARG/(PI/4)C.TAN:DATA 0 DIVIDE ROUTINER0 TO R4 AND SAVE ARGR1 TO R5JUMP TO PROC AND NOW GET FIXED POINT EQUIVD.TAN:DATA 0 FIXR0 TO R1 GET INTEGER EQUIVALENTIM(3) TO AND1 AND GET SECTOR NUMBERR6 TO OR1 OR IN SIGN BIT - SAVE IN THIS REGISTERR1 TO R6 SAVE BASE QUADRANTJUMP TO PROC AND REFLOAT THE R0 INTEGER PARTE.TAN:DATA 0 PTR TO FLOATR0 TO R2 AND MOVE TO R2-R3R1 TO R3 DITTOR4 TO R0 GET XR5 TO R1JUMP TO PROC SUB CALLF.TAN:DATA 0 PTR TO SUB - COMPUTE X-INT(X)R6 TO R2 CHECK ORIGINAL QUADRANT BITIM(1) TO AND2RE(G.TAN) TO RTZE IF THIS,  THEN OKR0 TO R2 ELSE COMPUTE 1-XR1 TO R3PCI TO R0 GET 1.000000DATA 040000PCI TO R1DATA 000101JUMP TO PROC SUB CALLH.TAN:DATA 0 SUBTRACT - COMPUTE 1-Y.EJECT**NOW COMPUTE POLY FOR TAN*G.TAN:R0 TO R4 SAVE ARGUMENTR1 TO R5 HERE TOOR0 TO R2 AND SQUARE TO COMPUTE Z*POLY(Z*Z)R1 TO R3 DITTOJUMP TO PROC AND PERFORM SUB CALLN.TAN:DATA 0 POINTER TO MULTIPLYR17 TO R2 GET BASE PTRIM(TANTB-.) TO ADD2 SET UP PTR TO COEF LISTJUMP TO PROC PERFORM SUB CALLI.TAN:DATA 0 PTR TO POLY ROUTINER4 TO R2 NOW POLY(Z)*ZR5 TO R3JUMP TO PROC MULTIPLYJ.TAN:DATA 0 MUL ROUTINER6 TO R2 CHECK QUADRANTIM(1) TO ADD2 LOOK FOR 00 OR 11 (BECOMES 01,00IM(2) TO AND2 SEE IF WASIM(K.TAN-.-1) TO RTZE IF 00 OR 11,  THE IS OKR0 TO R2 ELSE MUST CORRECT - USE 1/XR1 TO R3PCI TO R0 GET 1.00000DATA 040000PCI TO R1DATA 000101JUMP TO PROC AND DIVIDEM.TAN:DATA 0 PTR TO DIVIDE**NOW COMPUTE SIGN OF TANGENT,  AND RETURN*K.TAN:R6 TO R2 SEE IF NEGATIBVER2 TO R3 DUPLICATE IN R3PCI TO AND3 EXTRACT SIGN BITDATA 100000IM(2) TO AND2 SEE IF FIRST SECTORIM(2) TO RTZE IF NOT, THEN DSKIPPCI TO XOR3 ELSE FLIPDATA 100000 FLIP IF SHOULDR3 TO OR0 SET PROPER SIGN BIT IF SHOULDIM(LREG) TO ATRA LOAD REGS AND RETURN*TANTB:DATA 062544 C5  TANGENT TABLEDATA 146067DATA 044150 C4DATA 075467DATA 054365 C3DATA 123072DATA 050406 C2DATA 141474DATA 051263 C1DATA 147076DATA 062207 C0DATA 160700DATA 0*Z.TAN:DATA C.TAN BEGIN PATCH LISTDATA L.FPD DIVDATA D.TAN DDATA L.FIX FIXDATA E.TAN EDATA L.FLO FLOATDATA F.TAN FDATA L.FPS SUBTRACTDATA H.TAN HDATA L.FPS SUBTRACTDATA N.TAN NDATA L.FPM MULTIPLYDATA I.TAN IDATA L.PLY POLYDATA J.TAN JDATA L.FPM MULTIPLYDATA M.TAN MDATA L.FPD DIVIDEDATA 0 END OF SEGMENTEJECT**FLOATING POINT EXPONENTIATION ROUTINE**COMPUTE E TO THE X WHERE X =- R0*R.EXP:DATA Z.EXP POINTER TO END PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKPCI TO R2 GET LOG2(E)DATA 056125PCI TO R3 GET LOG2(E)DATA 016101JUMP TO PROC AND PERFORM SUB CALLC.EXP:DATA 0 PTR TO MUL - COMPUTE ARG*LOG2(E)R0 TO R4 SAVE X*LOG2(E)R1 TO R5 DITTOJUMP TO PROC PERFORM SUB CALLD.EXP:DATA 0 INT - TAKE INTEGER VALUE OF LOGR0 TO R6 SAVE INTEGER VALUEJUMP TO PROC PERFORM SUB CALLE.EXP:DATA 0 POINTER TO FLOAT - FLOAT INTEGER VALUEIM(2) TO RTZE IF ZERO,  THEN DO NOT NEGATEPCI TO XOR0 NEGATE THE INTEGER VALUEDATA 100000R4 TO R2 GET XR5 TO R3JUMP TO PROC PERFORM SUB CALLF.EXP:DATA 0 POINTER TO ADD - COMPUTE X-INT(X) = 0-.999999PCI TO R2 GET 1/2DATA 040000PCI TO R3DATA 000100JUMP TO PROC AND PERFORM SUB CALLG.EXP:DATA 0 WILL POINT TO SUB AFTER BINDING - COMPUTE FRACT(X)-.5R0 TO R4 AND SAVE SIGN HEREPCI TO AND0 AND TAKE ABSDATA 077777R17 TO R2 GET POINTER TO COEF LISTPCI TO ADD2 ADD IN RELATIVE DISTANCEDATA EXPTB-.+1 RELATIVE DISTANCE ROM .-2+1JUMP TO PROC AND PERFORM SUB CALLH.EXP:DATA 0 POINTER TO POLY ROUTINER4 TO LOA2 GET ORIGINAL SIGNR2 TO ADD2 CHECK FOR MINUSRE(I.EXP) TO RTNC IF WAS POSITIVE (>=1/2) THEN OKR0 TO R2 ELSE MUST COMPUTE 1/R1 TO R3PCI TO R0 GET 1.000000DATA 040000PCI TO R1DATA 000101JUMP TO PROC AND SUB CALL HEREJ.EXP:DATA 0 POINTER TO DIVIDEEJECT**NOW ADJUST EXPONENT FOR POWER OF TWO*I.EXP:R6 TO R3 T ORIGINAL EXPONENTPCI TO ADD3 ADD IN EXPONENT FOR SQR(2)DATA 101R3 TO TADD3 SEE IF STILL NEGATIVE - TOO SMALLIM(1) TO RTNC IF NOT NEGATIVE,  THEN MAY BE OKIM(0) TO R3 ELSE USE EXPONENT OV XZEROPCI TO TSUB3 SEE IF >200DATA 200IM(2) TO RTNC IF LESS THAN 200, THEN ALSO IN RANGEPCI TO R3 ELSE USE 177DATA 177 = LARGEST EXPONENTPCI TO R2 GET SIGN & MANTISSA MSB OF SQR(2)DATA 055202PCI TO OR3 AND OR IN LEAST MSBDATA 074000 TO EXPONENT FIELDJUMP TO PROC PERFORM MULTIPLYK.EXP:DATA 0 PTRIM(LREG) TO ATRA LOAD REGS AND RETURN*EXPTB:DATA 056625 C4  EXP TABLEDATA 017072DATA 070011 C3DATA 122274DATA 075421 C2DATA 026076DATA 054270 C1DATA 142100DATA 040000 C0DATA 000101DATA 0*Z.EXP:DATA C.EXP BEGIN PATCH LISTDATA L.FPM MULTIPLYDATA D.EXP DDATA L.FIX FIXDATA E.EXP EDATA L.FLO FLOATDATA F.EXP FDATA L.FPA FLOATING ADDDATA G.EXP GDATA L.FPS FLOATING SUBDATA H.EXP HDATA L.PLY POLYDATA J.EXP JDATA L.FPD DIVIDEDATA K.EXP KDATA L.FPM MULTIPLYDATA 0 END OF SEGMENT