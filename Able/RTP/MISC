TTL MISC ROUTINES - TERM, SBR/W, SHIFT, ROT, BYTE, PBYTE, BLOCKMOVE, BLOCKSET**TERMINATE ROUTINE.  RE-BOOTS TO MONITOR.*R.TER:DATA Z.TER POINTER TO END OF SEGMENTif ModelCD10 to MR12 *** this is only here so the DUMP pgm will recognize this routineendifIM(-20) TO D1 DISABLE INTERRUPTS HEREPCI TO R1 GET POINTER TO CONFIG TABLEDATA CONTAB+MEMSIZMR1 TO R1 GET POINTER TO TOP OF MEMORY (IN SECTORS)im(0) to BSOR1 shl(memsiz, 8) - no need to mask off top 8 bits since MEMSIZ is currently < 256R1 to R2 move to R2PCI to SUB2 COME BACK BY 75 WORDS (CALCULATE LOC.RST)data 113R0 to MR2 save termination status in LOC.RSTPCI TO SUB1 COME BACK BY 1024 WORDS (CALCULATE LOC.LOAD)DATA 2000R1 TO ATRA AND GO THERE - LOAD FROM DISK OR WINCHESTER AS REQ'DZ.TER:DATA 0 END OF SEGMENT, NO PATCHES**SPECIAL READ AND WRITE ROUTINES: SBR AND SBW (USED TO READ AND WRITE VARIABLE DEVICE ADDRESSES)**READ:*R.SBR:DATA Z.SBR POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifPCI TO AND0 EXTRACT 8-BIT DEVICE ADDRESSDATA 377PCI TO OR0 AND OR IN DESTINATION REGISTER ZERO BITSDATA 140000PCI TO R1 GET POINTER TO OUR WORD PAIRDATA CONTAB+SBRSBWMR1 TO R1 PICK UP POINTER TO RAM AREAR1 TO R2 AND DUPLICATE POINTER FOR TRANSFERIM(-20) TO D1 DISABLE INTERRUPTS FOR THING.R0 TO MR1I STORE INSTRUCTION IN MEMORYPCI TO MR1I AND STORE THE FOLLOWING INSTRUCTION IN MEMORYR3 TO ATRA AND RETURN TO WHENCE CAMER17I TO R3 SET UP RETURN IN R3,  SKIP NEXTRE(A.SBR) TO RTRA INSTRUCTION IS SKIPPED FIRST TIME THROUGH (we return here!)R2 TO ATRA AND GO TO RAM PAIR TO EXECUTE INSTRUCTIONSA.SBR:R14 TO D1 RE-ENABLE INTERRUPTS IF WE SHOULDRETURN TO ATRA AND RETURN TO CALLERZ.SBR:DATA 0 END OF SEGMENT, NO PATCHES**WRITE:*R.SBW:DATA Z.SBW POINTER TO ENDif ModelCD10 to MR12 save returnendifPCI TO AND0 EXTRACT MEANINGFUL DEVICE ADDRESS BITSDATA 377im(0) to BSOR0 shift address field left by 8PCI TO OR0 OR IN R1 SOURCE BITSDATA 301 REGISTER ONE SOURCEPCI TO R2 GET POINTER TO SPECIAL WORD-PAIRDATA CONTAB+SBRSBWMR2 TO R2 PICK UP POINTER TO RAM AREAR2 TO R3 AND SAVE POINTER FOR USIM(-20) TO D1 DISABLE INTERRUPTS WHILE WE USE CELLR0 TO MR2I STORE 'R1 TO SPECIFIED DEVICE' INSTRUCTIONPCI TO MR2I AND STORE A RETURN INSTRUCTIONR2 TO ATRA AND THIS INSTRUCTION RETURNS FROM RAM AREAR17I TO R2 SET UP R2 POINTING TO .+1,  SKIP INSTRRE(A.SBW) TO RTRA TRANSFER HERE (we return from instruction pair here)R3 TO ATRA AND  ENTER RAM AREA TO EXECUTE INSTRUCTIONA.SBW:R14 TO D1 RE-ENABLE OR KEEP INTS OFF,  AS APPROPRIATERETURN TO ATRA AND RETURN FROM ROUTINEZ.SBW:DATA 0 END OF SEGMENT, NO PATCHESEJECT**MULTIPLY ROUTINE - FIXED POINT (USED IF NO D4567)**R1*R2=R0R1**THE FOLLOWING ROUTINE PERFORMS A MULTIPLY BETWEEN TWO SIGNED 16-BIT*OPERANDS TO PERFORM A 32-BIT SIGNED PRODUCT.**FIRST,  AN INTEGER MULTIPLY IS PERFORMED.  THEN THE FOLLOWING*CORRECTIONS ARE PERFORMED:**  COMPUTE A*B;*  IF A<0 THEN (A*B)=(A*B)-(2^16)*B;*  IF B<0 THEN (A*B)=(A*B)-(2^16)*A;*R.FMU:DATA Z.FMU POINTER TO END OF THIS SEGMENTif ModelCD10 to MR12D stack returnR4 to MR12 save R4endifR1 TO R3 MOVE R1IM(0) TO R0 ZERO RESULTIM(0) TO R1 ZERO RESULTif ^ModelCIM(-17) TO R12 GET LOOP COUNTERB.MUL:R0 TO ADD0 SHIFT LEFTR1 TO ADD1 DITTOIM(1) TO RTNC IF NO CARRYIM(1) TO OR0 IF CARRY OUT OF 1endifif ModelCim(-17) to R4 get loop count in R4B.MUL: R1 to ADD1 shift LS leftR0 to ADC0 shift MS left, propagate carryendifIM(0) TO RTL3 ROTATE LEFT R3RE(A.MUL) TO RTNC NO ADD IF NO CARRYR2 TO ADD1 ELSE ADD INif ^ModelCIM(1) TO RTNC AND PROPAGATE CARRYIM(1) TO ADD0A.MUL:R12I TO TLOA0 SEE IF END OF LOOPendifif ModelCim(0) to ADC0 propagate carryA.MUL: R4I to TLOA0 see if end of loopendifRE(B.MUL) TO RTNZ GO BACK FOR MOREIM(0) TO ADD3 SEE IF OP1 WAS NEGATIVEIM(1) TO RTPL IF POS,  THEN SKIPR2 TO SUB0 ELSE FIX UP FRACTIONAL MULTIPLYIM(0) TO ADD2 SEE IF OP2 WAS NEGATIVEIM(1) TO RTPL IF POS,  THEN SKIPR3 TO SUB0 SUBTRACTif ModelCMR12I to R4 restore R4endifRETURN to ATRA and return to callerZ.FMU:DATA 0 END OF SEGMENT, NO PATCHESEJECT**DIVIDE ROUTINE - FIXED POINT (USED IF NO D4567)**R0R1 / R2 == R1(QUOTIENT);R0(REMAINDER);**THE FOLLOWING ROUTINE PERFORMS A DIVIDE BETWEEN A SIGNED 32 BIT*DIVISOR AND A SIGNED 16 BIT DIVIDEND TO FORM A SIGNED 16-BIT QUOTIENT,*AND A SIGNED 16-BIT REMAINDER.   NOTE THAT THE DEFINITION OF DIVISION*RESULTS IN THE REMAINDER ALWAYS BEING POSITIVE.**A=32-BIT DIVISOR,   B=16-BIT DIVIDENT**IF B<0 THEN DO;A=-A;B=-B;END;*IF A<0 THEN A=A+(2^16)*B;*R.FDI:DATA Z.FDI POINTER TO END OF THIS SEGMENTif ModelCD10 to MR12 save returnendifIM(0) TO ADD2 SEE IF B IS NEGATIVERE(C.FDI) TO RTPL IF NO,  THEN SKIPR2 TO LCM2 COMPLEMENT HERE IM(1) TO ADD2 THIS PERFOMS NEGATER1 TO LCM1 COMPL R1R0 TO LCM0 COMPL R0IM(1) TO ADD1 PERFORM NEGATEIM(1) TO RTNC IF NO CARRY,  THEN THROUGHIM(1) TO ADD0 ELSE PROPC.FDI:IM(0) TO ADD0 SEE IF A IS MINUSIM(1) TO RTPL IF POS, NO CORRECTION REQDR2 TO ADD0 ELSE CORRECT HEREif ^ModelCIM(-17) TO R12 SO WE CAN USE R12B.FDI:R0 TO ADD0 SHL MSBD1 TO R3 GET STATE OF CARRYR1 TO ADD1 SHL LSBIM(1) TO RTNC TRANSFER CARRYIM(1) TO OR0 PROPAGATEIM(2) TO TAND3 SEE IF CARRY IS SETIM(2) TO RTNZ IF CARRY, THEN SUBTRACTR2 TO TSUB0 COMPARE VALUESIM(2) TO RTNC IF TO SMALL TO SUBTRACT,  THEN DO NOTIM(1) TO OR1 SET ANSWER BITR2 TO SUB0 AND SUBTRACT NOWR12I TO TLOA0 SEE IF DONE?RE(B.FDI) TO RTNZ GO BACK IF MOREendif of ^ModelCif ModelCim(20) to R3 put loop count in R3B.FDI: R1 to ADD1 shl LSR0 to ADC0 shl MS, propagate carryim(2) to RTRC if carry, subtract out the dividendR2 to TSUB0 see if too small to subtractim(2) to RTNC too small, don't subtract the dividendR2 to SUB0 subtract the dividendim(1) to OR1 set "answer" bit in quotient since we subtractedim(1) to SUB3 see if we're done yetre(B.FDI) to RTNZ go back if not doneim(0) to TADD0 make sure M & Z are set based on R0 after returningendif of ModelCRETURN TO ATRA ELSE RETURN FROM DIVIDEZ.FDI:DATA 0 END OF SEGMENT, NO PATCHESEJECT**ROTATE  (MODS A & B) - LEAVE FOR MODEL C RELOC FILE COMPATIBILITY*R.ROT:DATA Z.ROT POINTER TO END OF ROUTINEif ModelCD10 to MR12 save returnendifIM(0) TO TSUB1 SEE IF ZERO SHIFTSRETURN TO ATZE DONE - AC0 = UNSHIFTED VALUEif ModelCim(1) to SUB1 decrement countR1 to D10 send to repeat counterendifIM(0) TO RTL0 ROTATE LEFTif ^ModelCIM(1) TO SUB1 DECREMENT COUNTIM(-3) TO RTNZ GO BACK FORE MORE IF MOREendifRETURN TO ATRA GO HOMEZ.ROT:DATA 0 END OF ROUTINE, NO PATCHES**SHIFT LEFT (MODS A & B) - LEAVE FOR MODEL C RELOC FILE COMPATIBILITY*R.SHL:DATA Z.SHL POINTER TO END OF ROUTINEif ModelCD10 to MR12 save returnendifIM(0) TO TSUB1 SEE IF NO SHIFT LEFTRETURN TO ATZE DONE - EXITif ModelCim(1) to SUB1 decrement countR1 to D10 send to repeat counterendifR0 TO ADD0 SHIFT LEFTif ^ModelCIM(1) TO SUB1 DECREMENT COUNTIM(-3) TO RTNZ GO BACKendifRETURN TO ATRA ELSE GO HOMEZ.SHL:DATA 0 END OF ROUTINE, NO PATCHES**MODEL B SHIFT RIGHT - LEAVE FOR MODEL C RELOC FILE COMPATIBILITY*R.SHR:DATA Z.SHR POINTER TO END OF ROUTINEif ModelCD10 to MR12 save returnendifIM(0) TO TSUB1 SEE IF ZERO SHIFTSRETURN TO ATZE RETURN OFF OF STACKif ModelCim(1) to SUB1 decrement countR1 to D10 send to repeat counterendifIM(0) TO SHRA0 SHIFT RIGHT REG 0if ^ModelCIM(1) TO SUB1 DECREMENT COUNTIM(-3) TO RTNZ GO BACK FOR MOREendifRETURN TO ATRA ELSE GO HOMEZ.SHR:DATA 0 END OF ROUTINE, NO PATCHESEJECT**BYTE ROUTINE - MODEL B**THE 'BYTE' ROUTINE IS USED TO EXTRACT ONE BYTE OUT OF*A FIXED POINT ARRAY.**IT IS PASSED:*  AC0 = POINTER TO START OF ARRAY*  AC1 = THE BYTE NUMBER,  STARTING WITH ZERO*R.BYT:DATA Z.BYT POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifIM(1) TO ADD0 MOVE POINTER PAST # OF BYTES FIELDR0 TO SHRA1 SHIFT RIGHT BYTE COUNT,  ADD IN BASEMR1 TO R0 GET WORD OF MEMORY,   LEAVE CARRY UNCHANGEDIM(1) TO RTNC IF NO CARRY FROM ABOVE SHRA,  THEN SKIPIM(0) TO BSOR0 ELSE GET UPPER HALFA.BYT:PCI TO AND0 EXTRACT 8 BITSDATA 377RETURN TO ATRA AND RETURN TO CALLERZ.BYT:DATA 0 END OF SEGMENT, NO PATCHES**PBYTE ROUTINE - MODEL B**ROUTINE IS USED TO INSERT AN 8 BIT BYTE INTO A 16-BIT WORD*IN A FIXED POINT ARRAY.**PASSED:*  AC0=POINTER TO ARRAY BASE*  AC1=WHICH BYTE*  AC2=BYTE TO STORE*R.PBT:DATA Z.PBT POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifPCI TO AND2 EXTRACT 8-BITS OF BYTEDATA 377IM(1) TO ADD0 SKIP POINTER PAST # OF BYTESR0 TO SHRA1 GENERATE WORD POINTERRE(A.PBT) TO RTNC IF NOT CARRY,  THEN BYTE 0IM(0) TO BSOR2 BRING BYTE TO SAVE TO UPPER HALFMR1 TO R3 GET CURRENT WORDPCI TO AND3 EXTRACT LOWER HALF OF EXISTING WORDDATA 377RE(B.PBT) TO RTRA AND SKIP THE NEXT N INSTRUCTIONSA.PBT:MR1 TO R3 GET CURRENT WORDPCI TO AND3 EXTRACT UPPER HALF OF EXISTING WORDDATA 377*400 MASKB.PBT:R2 TO OR3 OR IN BYTER3 TO MR1 AND STORE WORD IN MEMORYRETURN TO ATRA AND RETURN TO CALLERZ.PBT:DATA 0 END OF SEGMENT, NO PATCHESeject***BlockMove Routine - Model A & Model B**The 'BlockMove' routine moves data from consecutive memory locations*in one area of memory to consecutive memory locations in another area.*Overlapping blocks work correctly.**This routine is passed:*   AC0 = pointer to block to move from (source)*   AC1 = pointer to block to move to (destination)*   AC2 = length to move*if ^ModelCR.BMV: data Z.BMV pointer to end of segmentR1 to TSUB0 is the destination above the sourcere(X.BMV) to RTRC no, copy from the bottom of memory to the topR0 to R3 yes, see if the blocks overlapR2 to ADD3 find the end of the sourceR1 to TSUB3 does it overlap the destination?im(1) to RTZE just touching is okayre(Y.BMV) to RTRC yes, we must copy from the top of memory to the bottom**The following copies from the bottom of memory to the top of memory*in 16 word chunks.*X.BMV: im(20) to SUB2 do we have at least 16 words?re(B.BMV) to RTNC no, copy a word at a time*A.BMV: MR0I to MR1I copy 16 wordsMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1Iim(20) to SUB2 decrement the lengthre(A.BMV) to RTRC loop back until done*B.BMV: im(20) to ADD2 get number of words left to copyim(RETN) to ATZE none left - returnC.BMV: MR0I to MR1I copy the next wordim(1) to SUB2 decrement word countre(C.BMV) to RTNZ loop until we move the rest of the blockim(RETN) to ATRA and return to callereject**The following copies from the top of memory to the bottom of memory*in 16 word chunks.*Y.BMV: R3 to R0 move the pointer to the end of the source block to R0R2 to ADD1 point to the end of the destination blockim(20) to SUB2 do we have at least 16 words?re(E.BMV) to RTNC skip if not enoughR1 to SUB3 get the difference between the source and the destination (this is negative!)im(20) to TADD3 is it at least 16?im(1) to RTZE zero is okayre(E.BMV) to RTRC no, we have to do it one word at a time*D.BMV: im(20) to SUB0 subtract 16 from source (to point to next 16 word block)im(20) to SUB1 do same for destinationMR0I to MR1I copy 16 wordsMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1IMR0I to MR1Iim(20) to SUB0 subtract 16 from source to point to start of block just copiedim(20) to SUB1 and from destinationim(20) to SUB2 decrement length to copyre(D.BMV) to RTRC keep going until we're done*E.BMV: im(20) to ADD2 get remainderim(RETN) to ATZE no more to copyF.BMV: im(1) to SUB0 back up source pointerim(1) to SUB1 and destination pointerMR0 to MR1 copy the next wordim(1) to SUB2 decrement countre(F.BMV) to RTNZ loop until doneim(RETN) to ATRA returnZ.BMV: data 0 end of segment, no patchesendif of ^ModelCeject***BlockSet Routine - Model A & Model B**The 'BlockSet' routine sets consecutive memory locations in the given*area of memory to the passed value.  The operation proceeds towards*the top of memory in blocks of 16 words.**This routine is passed:*   AC0 = pointer to block to set*   AC1 = length of block*   AC2 = value to set every word in block to*if ^ModelCR.BST: data Z.BST pointer to end of segmentim(20) to SUB1 enough to set 16 words?re(B.BST) to RTNC no, set word by word*A.BST: R2 to MR0I set the next 16 wordsR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0IR2 to MR0Iim(20) to SUB1 subtract 16 from lengthre(A.BST) to RTRC loop until we move most of the block*B.BST: im(20) to ADD1 get remaining words to setim(RETN) to ATZE none left - exitC.BST: R2 to MR0I set next wordim(1) to SUB1 decrement countre(C.BST) to RTNZ loop until doneim(RETN) to ATRA and return to callerZ.BST: data 0 end of segment, no patchesendif of ^ModelCeject***BlockMove Routine - Model C & later**The 'BlockMove' routine moves data from consecutive memory locations*in one area of memory to consecutive memory locations in another area.*Overlapping blocks work correctly.**This routine is passed:*   AC0 = pointer to block to move from (source)*   AC1 = pointer to block to move to (destination)*   AC2 = length to move*if ModelCR.BMV: data Z.BMV pointer to end of segmentD10 to MR12 save returnR2 to LOA2 make sure the length is nonzeroMR12 to ATZE exit if nothing to doR1 to TSUB0 is the destination above the sourcere(A.BMV) to RTRC no, copy from the bottom of memory to the topR0 to R3 yes, see if the blocks overlapR2 to ADD3 find the end of the sourceR1 to TSUB3 does it overlap the destination?im(1) to RTZE just touching is okayre(B.BMV) to RTRC yes, we must copy from the top of memory to the bottom**Copy from the bottom of memory towards the top.*A.BMV: im(1) to SUB2 subtract one from length (REPEAT adds one)R2 to D10 REPEAT the next instruction (R2 mod 256) + 1 timesMR0I to MR1I copy the next wordPCI to AND2 keep only the MSB'sdata ^377 subtract out number already REPEATedre(A.BMV) to RTNZ loop until we've move the entire blockMR12 to ATRA and return to caller**Copy from the top of memory towards the bottom.*B.BMV: R3 to R0 move the source pointer backR2 to ADD1 point to the end of the destination blockR1 to R3 move destination to R3R0 to SUB3 and get positive difference between the source and destinationPCI to TSUB3 is it greater than 256 (the repeat counter's limit)data 400im(2) to RTNC no, move by blocks the size of the differencePCI to R3 yes, move by 256 word blocksdata  400R3 to SUB2 do we have at least R3 words?re(D.BMV) to RTNC no, copy only the remainder*C.BMV: R3 to SUB0 point to the beginning of the next block to copyR3 to SUB1 back up destination as wellim(1) to SUB3 subtract one from repeat count (REPEAT adds one)R3 to D10 copy (R3)+1 wordsMR0I to MR1I copy one wordim(1) to ADD3 restore repeat countR3 to SUB0 point to the beginning of the block we just copiedR3 to SUB1 back up the destination as wellR3 to SUB2 decrement the length to copyre(C.BMV) to RTRC keep going until we've moved as much as we can*D.BMV: R3 to ADD2 get remaining words to copyMR12 to ATZE none left - exitR2 to SUB0 point to the beginning of the final block to copyR2 to SUB1 backup the destination as wellim(1) to SUB2 subtract one from the remainder (now the repeat count - REPEAT adds one)R2 to D10 copy (R2)+1 wordsMR0I to MR1I copy one wordMR12 to ATRA and return to callerZ.BMV: data 0 end of segment, no patchesendif of ModelCeject***BlockSet Routine - Model C & later**The 'BlockSet' routine sets consecutive memory locations in the given*area of memory to the passed value.  The operation proceeds towards*the top of memory.**This routine is passed:*   AC0 = pointer to block to set*   AC1 = length of block*   AC2 = value to set every word in block to*if ModelCR.BST: data Z.BST pointer to end of segmentD10 to MR12 save returnR1 to LOA1 make sure the length is nonzeroMR12 to ATZE exit if nothing to do*A.BST: im(1) to SUB1 subtract one from length (REPEAT adds one)R1 to D10 REPEAT the next instruction (R1 mod 256) + 1 timesR2 to MR0I set the next wordPCI to AND1 keep only the MSB'sdata ^377 subtract out number already REPEATedre(A.BST) to RTNZ loop until we've move the entire blockMR12 to ATRA and return to callerZ.BST: data 0 end of segment, no patchesendif of ModelCeject***Export Routine - Model B**The 'Export' routine moves data from consecutive memory locations*in main memory to consecutive memory locations in external memory.*The operation proceeds towards the top of memory.**This routine is passed:*   AC0 = starting sector in external memory (destination)*   AC1 = starting word in external memory (destination)*   AC2 = pointer to block to move (source)*   AC3 = length to move*if ^ModelCR.EPT: data Z.EPT pointer to end of segmentR15I to R12 preserve D60 and D61 on the stackD60 to MR15ID61 to MR15IR12 to MR15*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*R3 to LOA3 make sure there's something to copyre(F.EPT) to RTNZ there is - enter loopre(D.EPT) to RTRA nothing to copy - get out*E.EPT: MR2I to D63 copy next wordim(1) to SUB3 subtract one from length since we just copied a wordre(D.EPT) to RTZE no more words, get outF.EPT: D61 to TLOA0 see if we're on a sector boundary (M128K boundary bug)re(E.EPT) to RTNZ loop until we run out or hit an M128K sector boundary*im(20) to SUB3 do we need to copy at least 16 words?re(B.EPT) to RTNC no, copy word by word*A.EPT: MR2I to D63 copy the next 16 wordsMR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63MR2I to D63im(20) to SUB3 decrement the lengthre(A.EPT) to RTRC copy as much as we can*B.EPT: im(20) to ADD3 get remaining wordsre(D.EPT) to RTZE none left - exitC.EPT: MR2I to D63 copy the next wordim(1) to SUB3 subtract one from length since we just copied a wordre(C.EPT) to RTNZ loop until we move the rest of the block*D.EPT: MR15 to R12 restore D60/D61 and returnR12I to ATNVMR12I to D60MR12 to D61MR15 to R15 get rid of the stack frameim(RETN) to ATRA and return to callerZ.EPT: data 0 end of segment, no patchesendif of ^ModelCeject***Import Routine - Model B**The 'Import' routine moves data from consecutive memory locations*in external memory to consecutive memory locations in main memory.*The operation proceeds towards the top of memory.**This routine is passed:*   AC0 = starting sector in external memory (source)*   AC1 = starting word in external memory (source)*   AC2 = pointer to block to move to (destination)*   AC3 = length to move*if ^ModelCR.IPT: data Z.IPT pointer to end of segmentR15I to R12 preserve D60 and D61 on the stackD60 to MR15ID61 to MR15IR12 to MR15*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*im(20) to SUB3 do we need to copy at least 16 words?re(B.IPT) to RTNC no, copy word by word*A.IPT: D63 to MR2I copy the next 16 wordsD63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2ID63 to MR2Iim(20) to SUB3 decrement the lengthre(A.IPT) to RTRC copy as much as we can*B.IPT: im(20) to ADD3 get remaining wordsre(D.IPT) to RTZE none left - exitC.IPT: D63 to MR2I copy the next wordim(1) to SUB3 subtract one from length since we just copied a wordre(C.IPT) to RTNZ loop until we move the rest of the block*D.IPT: MR15 to R12 restore D60/D61 and returnR12I to ATNVMR12I to D60MR12 to D61MR15 to R15 get rid of the stack frameim(RETN) to ATRA and return to callerZ.IPT: data 0 end of segment, no patchesendif of ^ModelCeject***ExtSet Routine - Model B**The 'ExtSet' routine sets consecutive locations in external memory*to a given value.**This routine is passed:*   AC0 = starting sector in external memory*   AC1 = starting word in external memory*   AC2 = length to set*   AC3 = value to set every word to*if ^ModelCR.EST: data Z.EST pointer to end of segmentR15I to R12 preserve D60 and D61 on the stackD60 to MR15ID61 to MR15IR12 to MR15*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*R2 to LOA2 make sure there's something to setre(F.EST) to RTNZ there is - enter loopre(D.EST) to RTRA nothing to set - get out*E.EST: R3 to D63 set the next wordim(1) to SUB2 subtract one from length since we just set a wordre(D.EST) to RTZE no more words, get outF.EST: D61 to TLOA0 see if we're on a sector boundary (M128K boundary bug)re(E.EST) to RTNZ loop until we run out or hit an M128K sector boundary*im(20) to SUB2 do we need to set at least 16 words?re(B.EST) to RTNC no, set word by word*A.EST: R3 to D63 set the next 16 wordsR3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63R3 to D63im(20) to SUB2 decrement the lengthre(A.EST) to RTRC set as many words as we can*B.EST: im(20) to ADD2 get remaining wordsre(D.EST) to RTZE none left - exitC.EST: R3 to D63 set the next wordim(1) to SUB2 subtract one from length since we just set a wordre(C.EST) to RTNZ loop until we set the rest of the block*D.EST: MR15 to R12 restore D60/D61 and returnR12I to ATNVMR12I to D60MR12 to D61MR15 to R15 get rid of the stack frameim(RETN) to ATRA and return to callerZ.EST: data 0 end of segment, no patchesendif of ^ModelCeject***Export Routine - Model C & later***The 'Export' routine moves data from consecutive memory locations*in main memory to consecutive memory locations in external memory.*The operation proceeds towards the top of memory.**This routine is passed:*   AC0 = starting sector in external memory (destination)*   AC1 = starting word in external memory (destination)*   AC2 = pointer to block to move (source)*   AC3 = length to move*if ModelCR.EPT: data Z.EPT pointer to end of segmentD10 to MR12D save returnD61 to MR12D preserve D60/D61D60 to MR12*R3 to LOA3 make sure the length is nonzerore(D.EPT) to RTZE exit if nothing to do*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*PCI to R1 (256 - D61) = number of words left in this external sectordata 400 (this is a kludge to fix hardware bug writing across M128K boundaries)D61 to SUB1R1 to TSUB3 make sure we aren't out of rangere(C.EPT) to RTNC this copy won't cross a sector boundaryR1 to SUB3 we've copied this muchim(1) to SUB1 subtract one from length to copy for REPEATR1 to D10 REPEAT the next instruction (R1 mod 256) + 1 timesMR2I to D63 copy the next word*C.EPT: PCI to R0 pick up transfer lengthdata 400 256 wordsR0 to R1 pick up amount to write to the repeat counterim(1) to SUB1 (one less than the transfer length)re(B.EPT) to RTRA enter the loop*A.EPT: R1 to D10 REPEAT the next instruction (R1 mod 256) + 1 timesMR2I to D63 copy the next wordB.EPT: R0 to SUB3 stop when less than 256 words leftre(A.EPT) to RTRC loop until we've moved the entire block*R0 to ADD3 get remainderre(D.EPT) to RTZE no words leftim(1) to SUB3 subtract one from length (REPEAT adds one)R3 to D10 REPEAT the next instruction (R3 mod 256) + 1 timesMR2I to D63 copy the next word*D.EPT: MR12I to D60 restore D60/D61MR12I to D61MR12 to ATRA and return to callerZ.EPT: data 0 end of segment, no patcheseject***Import Routine - Model C & later***The 'Import' routine moves data from consecutive memory locations*in external memory to consecutive memory locations in main memory.*The operation proceeds towards the top of memory.**This routine is passed:*   AC0 = starting sector in external memory (source)*   AC1 = starting word in external memory (source)*   AC2 = pointer to block to move to (destination)*   AC3 = length to move*R.IPT: data Z.IPT pointer to end of segmentD10 to MR12D save returnD61 to MR12D preserve D60/D61D60 to MR12*R3 to LOA3 make sure the length is nonzerore(B.IPT) to RTZE exit if nothing to do*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*A.IPT: im(1) to SUB3 subtract one from length (REPEAT adds one)R3 to D10 REPEAT the next instruction (R3 mod 256) + 1 timesD63 to MR2I copy the next wordPCI to AND3 keep only the MSB'sdata ^377 subtract out number already REPEATedre(A.IPT) to RTNZ loop until we've moved the entire block*B.IPT: MR12I to D60 restore D60/D61MR12I to D61MR12 to ATRA and return to callerZ.IPT: data 0 end of segment, no patcheseject***ExtSet Routine - Model C & later**The 'ExtSet' routine sets consecutive locations in external memory*to a given value.**This routine is passed:*   AC0 = starting sector in external memory*   AC1 = starting word in external memory*   AC2 = length to set*   AC3 = value to set every word to*R.EST: data Z.EST pointer to end of segmentD10 to MR12D save returnD61 to MR12D preserve D60/D61D60 to MR12*R2 to LOA2 make sure the length is nonzerore(D.EST) to RTZE exit if nothing to do*R1 to D61 set word address asideim(0) to BSOR1 SHR by 8PCI to AND1data 377R1 to ADD0 add result to starting sectorD61 to R1 and restore R1*R0 to D60 send page address to external memory controllerR1 to D61 and word address*PCI to R1 (256 - D61) = number of words left in this external sectordata 400 (this is a kludge to fix hardware bug writing across M128K boundaries)D61 to SUB1R1 to TSUB2 make sure we aren't out of rangere(C.EST) to RTNC this copy won't cross a sector boundaryR1 to SUB2 we've copied this muchim(1) to SUB1 subtract one from length to copy for REPEATR1 to D10 REPEAT the next instruction (R1 mod 256) + 1 timesR3 to D63 set the next word*C.EST: PCI to R0 pick up transfer lengthdata 400 256 wordsR0 to R1 pick up amount to write to the repeat counterim(1) to SUB1 (one less than the transfer length)re(B.EST) to RTRA enter the loop*A.EST: R1 to D10 REPEAT the next instruction (R1 mod 256) + 1 timesR3 to D63 set the next wordB.EST: R0 to SUB2 stop when less than 256 words leftre(A.EST) to RTRC loop until we've moved the entire block*R0 to ADD2 get remainderre(D.EST) to RTZE no words leftim(1) to SUB2 subtract one from length (REPEAT adds one)R2 to D10 REPEAT the next instruction (R2 mod 256) + 1 timesR3 to D63 set the next word*D.EST: MR12I to D60 restore D60/D61MR12I to D61MR12 to ATRA and return to callerZ.EST: data 0 end of segment, no patchesendif of ModelC