* INTRO**  Modified:*  01/19/90 - MWH - Allow breakpoints on enter and exit of swap procedures***Transfer vector:  startup, interrupt patch, interrupt routine*L.STA:  DATA R.STA       STARTUP ROUTINEL.PAT:  DATA IN1-ZERO    LOCATION TO PATCH IF INTERRUPT ROUTINE INCLUDEDL.IN1:  DATA R.IN1       INTERRUPT PROCESSING ROUTINE**Transfer vector - models A, B*IF ^MODELC        DATA R.NON        DATA R.NON        DATA R.NONL.SREG: DATA SREG      SAVE REGISTER ROUTINEL.LREG: DATA LREG      LOAD REGISTER ROUTINEL.RETN: DATA RETN      RETURN ROUTINE        DATA R.NON        DATA R.NONL.SWAP: DATA R.SWAP    CALL A (PERHAPS) SWAPPED PROCEDUREENDIF**Transfer Vector - model C only*IF MODELC-MODELD         MODEL C ONLY - POINTERS TO PATCH INTRPT ROUTINEL.IN2:  DATA IN2L.IN3:  DATA IN3        DATA R.NONL.SREG: DATA SREG      SAVE REGISTER ROUTINEL.LREG: DATA LREG      LOAD REGISTER ROUTINEL.SWE:  DATA SWAP          FOR MODEL C & LATER - POINTER TO SWAP ENTRYL.SW2:  DATA SWAP1-ZERO    FOR MODEL C & LATER - PATCH TO POINT TO R.SWAP        DATA R.NONL.SWAP: DATA R.SWAP    CALL A (PERHAPS) SWAPPED PROCEDUREENDIF**Transfer vector - model D and later*IF MODELDL.SW1:  DATA B.PGSW-ZERO LOCATION TO PATCH IF SWAP ROUTINE INCLUDEDL.PGSW: DATA PGSW-ZERO   START OF PAGE SWITCH CODE (switch to page 0)L.PGX:  DATA PGX-ZERO    PAGE SWITCH CODE TO GO QUICKLY TO PROC IN DIFFERENT PAGEL.SREG: DATA SREG      SAVE REGISTER ROUTINEL.LREG: DATA LREG      LOAD REGISTER ROUTINEL.SWE:  DATA SWAP          FOR MODEL C & LATER - POINTER TO SWAP ENTRYL.SW2:  DATA SWAP1-ZERO    FOR MODEL C & LATER - PATCH TO POINT TO R.SWAPL.SWPP: DATA G.SWAP-H.SWAP RELATIVE DISTANCE INTO SWAP ROUTINE OF G.SWAPL.SWAP: DATA R.SWAP    CALL A (PERHAPS) SWAPPED PROCEDUREENDIF**FLOATING POINT*L.FPM:  DATA R.FPM     FLOATING POINT MULTL.FPD:  DATA R.FPD     FLOATING POINT DIVIDEL.FPA:  DATA R.FPA     FLOATING POINT ADDL.FPS:  DATA R.FPS     FLOATING POINT SUBTRACTL.FIX:  DATA R.FIX     FLOATING TO FIXED POINTL.FLO:  DATA R.FLO     FIXED TO FLOATING POINTL.NOR:  DATA R.NOR     INTERNAL NORMALIZE ROUTINEL.MLS:  DATA R.MLS     MULTIPLY SUBROUTINEL.DVS:  DATA R.DVS     FLOATING DIVIDE INTERNAL SUBROUTINEL.ABS:  DATA R.ABS     ABSOLUTE VALL.LOG:  DATA R.LOG     NATURAL LOGL.ATN:  DATA R.ATN     ARC TANGENTL.COS:  DATA R.COS     COSINEL.SNE:  DATA R.SNE     SINEL.TAN:  DATA R.TAN     TANGENT ROUTINEL.EXP:  DATA R.EXP     EXPONENTIATIONL.SQR:  DATA R.SQR     SQUARE ROOT ROUTINEif HFloatL.XTI:  DATA R.XTI     XPL TO IEEE FLOATING POINT CONVERSION ROUTINEL.ITX:  DATA R.ITX     IEEE TO XPL FLOATING POINT CONVERSION ROUTINEendifif ^HFloat        DATA R.NON        DATA R.NONendifL.PLY:  DATA R.PLY     SUBROUTINE FOR POLYNOMIAL COMPUTATION**MISC ROUTINES*        DATA R.NONL.ROT:  DATA R.ROT     MODEL B ROTATE LEFTL.SHL:  DATA R.SHL     MODEL B SHIFT LEFTL.SHR:  DATA R.SHR     MODEL B SHIFT RIGHT        DATA R.NONL.BMV:  DATA R.BMV     BLOCK MOVEL.BST:  DATA R.BST     BLOCK SETL.BRK:  DATA R.BRK     ROUTINE TO ACTIVATE WHEN BREAK STATEMENTEJECT**OUTPUT ROUTINES*L.NPR:  DATA R.NPR     FIXED POINT NUMBER PRINTL.SPR:  DATA R.SPR     STRING PRINTL.PRI:  DATA R.PRI     PRINT A CARRIAGE RETURN LINE FEEDL.FPR:  DATA R.FPR     FLOATING POINT NUMBER PRINT        DATA R.NON L.OPR:  DATA R.OPR     PRINT IN OCTAL FORMATL.PCH:  DATA R.PCH     USER ROUTINE TO PRINT ONE CHARACTER (AC0) ON DEVICEL.PC:   DATA R.PC      INTERNAL ROUTINE TO PRINT CHARACTER**TERMINAL INPUT ROUTINES*L.FIN:  DATA R.FIN     FLOATING POINT NUMERIC INPUTL.SIN:  DATA R.SIN     STRING INPUT INTO DATA ARRAYL.IPR:  DATA R.IPR     INPUT PRIME - PRIME INPUT BUFFER FOR NUMERIC INPUTL.IDN:  DATA R.IDN     INPUT DONE - CHECK FOR PROPER TERMINATION OF NUMERIC INPUTL.ICH:  DATA R.ICH     INPUT CHARACTER - IS THE RECEIVED CHARACTER FUNCTIONL.GTC:  DATA R.GTC     ROUTINE TO GET NEXT CHARACTER DURING NUMERIC INPUTL.IER:  DATA R.IER     ROUTINE TO PRINT OUT 'INPUT FORMAT ERROR',  ETC.L.FXI:  DATA R.FXI     ROUTINE FOR FIXED POINT NUMERIC INPUT**BYTE/STRING FUNCTIONS*L.BYT:  DATA R.BYT     THE 'BYTE' FUNCTIONL.PBT:  DATA R.PBT     THE 'PBYTE' FUNCTION        DATA R.NONL.ERD:  DATA R.ERD     READ FROM DISK DIRECTLY INTO EXTERNAL MEMORYL.EWR:  DATA R.EWR     WRITE TO DISK DIRECTLY FROM EXTERNAL MEMORYL.EPT:  DATA R.EPT     EXPORT TO EXTERNAL MEMORYL.IPT:  DATA R.IPT     IMPORT FROM EXTERNAL MEMORYL.EST:  DATA R.EST     SET EXTERNAL MEMORY**SPECIAL FUNCTIONS*L.TER:  DATA R.TER     TERMINATE ROUTINEL.SBR:  DATA R.SBR     SPECIAL ROUTINE TO READ FROM A VARIABLE ADDRESSL.SBW:  DATA R.SBW     SPECIAL ROUTINE TO WRITE TO  A VARIABLE ADDRESSL.SEE:  DATA R.SEE     FLOPPY SEEK ROUTINE        DATA R.NON        DATA R.NONL.FDE:  DATA R.FDE     FIND DEVICE ENTRY IN CONFIGURATION (USED BY READDATA/WRITEDATA)L.SCUR: DATA R.SCUR    SET CURRENT DEVICE**OTHER ROUTINES*L.FMU:  DATA R.FMU     FIXED POINT MULTIPLYL.FDI:  DATA R.FDI     FIXED POINT DIVIDEL.RFL:  DATA R.RFL     READDATA  ROUTINEL.WFL:  DATA R.WFL     WRITEDATA ROUTINEL.WSL:  DATA R.WSL     WINCHESTER DISK SELECT ROUTINEL.PRD:  DATA R.PRD     READ FROM DISK DIRECTLY INTO POLYPHONIC SAMPLING MEMORYL.PWR:  DATA R.PWR     WRITE TO DISK DIRECTLY FROM POLYPHONIC SAMPLING MEMORYL.SWI:  DATA R.SWI     SWAP INITIALIZATIONTTL START-UP, AND REG SAVE/LOAD ROUTINES, CONFIGURATION TABLE***THE FOLLOWING ROUTINES ARE AT THE START OF EACH COMPILED FILE:**  THE STARTUP ROUTINE - ZERO OUT THE VARIABLE AREA AND GOTO OBJECT CODE**  THE CALL    ROUTINE - PUSH THE PC ON A STACK AND CALL SUBROUTINE (MODEL A & MODEL B ONLY)*  THE RETURN  ROUTINE - RETURN FROM SUBROUTINE (MODEL A & MODEL B ONLY)**ADDITIONALLY,  THERE ARE TWO SPECIAL ROUTINES THAT ARE INVOKED BY*JUMPING TO A LOCATION WITHIN THE FIRST 32 WORDS OF MEMORY:**  THE SREG    ROUTINE - SAVE 6 INDEX REGISTERS ON THE STACK*  THE LREG    ROUTINE - LOAD 6 INDEX REGISTERS FROM STACK, THEN RETURN**RUN TIME CORE MEMORY ORGANIZATION:**000000:   START OF ENVIRONMENT (START-UP/CALL/RETURN/SREG/LREG GO HERE)*000064:   START OF CONFIGURATION (THIS IS POINTED TO BY WORD 1 AND MAY START ELSEWHERE)*000124:   START OF STRING CONSTANTS/DATA AREA (RIGHT AFTER CONFIGURATION)*00????:   START OF RTP ROUTINES (RIGHT AFTER SCON/DATA AREA)*00????:   START OF OBJECT CODE (RIGHT AFTER RTP)*020000:   START OF VARIABLE AREA (DEFAULT IS RIGHT AFTER OBJECT CODE, BUT NOT BEFORE 20000)*0?????:   START OF STACK AREA - BOTTOM OF STACK ON MODEL A & MODEL B; TOP OF STACK AREA ON LATER MODELS (RIGHT AFTER VARIABLE AREA)***RUN TIME REGISTER USAGE ON MODEL A AND MODEL B PROCESSORS:**R17 - NORMAL PROGRAM COUNTER**R16 - POINTS TO INTERRUPT ROUTINE,  AND JSR SUBROUTINE*      INTERRUPT CAUSES EXECUTION OF INSTRUCTIONS AT PC=R16.*      TO DO A JUMP SUBROUTINE,  THE SEQUENCE IS 'R16I TO D1''DATA (POINTER)'*      R16 IS INCREMENTED TO POINT TO R.JSR (WHICH IS ALWAYS R16L+1).*      R16 IS SUCH THAT, WHEN WRITTEN TO DEVICE 1,  PC SELECT=R16.**R15 - PUSH DOWN STACK POINTER.  STACK GROWS TOWARD UPPER MEMORY.**R14 - USER INTERRUPT CONTROL -20 FOR INTERRUPTS OFF,  -10 FOR INTERRUPTS ON.*      R14 IS WRITTEN TO DEVICE 1 WHEN THE SYSTEM WISHES TO RETURN*      INTERRUPTS TO THE USER DESIRED STATE.   THIS IS NECESSARY SOMETIMES*      FOR EXAMPLE WHEN THE SYSTEM REQUIRES INTERRUPTS TO BE OFF (WHEN*      DOING STACK MANIPULATION).  R14 IS SET TO REENABLE INTERRUPTS,*      OR KEEP THEM OFF,  DEPENDING ON WHAT THE USER PROGRAM DESIRES.**R13 - R13 IS NOT USED BY XPL AND IS ENTIRELY AVAILABLE TO THE USER PGM*R12 - TEMPORARY REGISTER USED BY MANY RTP SUBROUTINES AND FOR CONTEXT SWITCHING**R11 R10 R7 R6 R5 R4 - XPL MEMORY POINTERS*R0 R1 R2 R3 -         XPL ACCUMULATORS***RUN TIME REGISTER USAGE ON MODEL C AND LATER PROCESSORS:**R17 - NORMAL PROGRAM COUNTER**R16 - POINTS TO INTERRUPT ROUTINE**R15 - TEMPORARY USED TO CALL SWAPPABLE PROCS - UNUSED ELSEWHERE (BUT RESERVED)**R14 - USER INTERRUPT CONTROL. -20 FOR INTERRUPTS OFF,  -10 FOR INTERRUPTS ON.*      R14 IS WRITTEN TO DEVICE 1 WHEN THE SYSTEM WISHES TO RETURN*      INTERRUPTS TO THE USER DESIRED STATE.   THIS IS NECESSARY SOMETIMES*      FOR EXAMPLE WHEN THE SYSTEM REQUIRES INTERRUPTS TO BE OFF (WHEN*      DOING STACK MANIPULATION).  R14 IS SET TO REENABLE INTERRUPTS,*      OR KEEP THEM OFF,  DEPENDING ON WHAT THE USER PROGRAM DESIRES.**R13 - R13 IS NOT USED BY XPL AND IS ENTIRELY AVAILABLE TO THE USER PGM**R12 - PUSH DOWN STACK POINTER.  STACK GROWS TOWARD LOWER MEMORY.**R11 R10 R7 R6 R5 R4 - XPL MEMORY POINTERS*R0 R1 R2 R3 -         XPL ACCUMULATORSEJECT***STARTUP ROUTINE:**ZERO OUT VARIABLE AREA, SET UP INITIAL PDL, TRANSFER CONTROL TO OBJECT CODE*R.NON: DATA .+1 R.NON IS A NULL RTP ROUTINEDATA 0*R.STA:... STARTUP ROUTINEDATA Z.STA POINTER TO END OF STARTUP ROUTINEZERO:... ENDS UP AT LOCATION ZERO OF CODE AT RUN TIME.PCI TO LOA0 LOAD R0 WITH POINTER TO CONFIGURATION TABLEDATA CONTAB POINTER TO CONFIGURATION TABLEPCI to RTRA GO START UPdata G.STA-.-1**THE CALL/INTERRUPT ROUTINE:*CALL:EQU .-ZERO+1 COMPUTE NORMAL CALL ENTRY (ENTER AT .+1+1)R14 TO D1 RETURN TO PC=17 AND RESTORE INTERRUPT TO USER'S DESIRED ON/OFF (RETURN FROM CALL/INTERRUPT)EJECT**Low core routines for Models A, B:**During normal program execution,  R16 points to the following*location of memory.*if ^ModelCRE(A.INT) TO RTRA    WE COME HERE ON INTERRUPT,  .+1 FOR SUB CALLR15I TO R12          GET CURRENT STACK POINTER;INCREMENT PAST SAVED BPTRR17 TO MR15I         SAVE CURRENT PC - IT POINTS TO RESTART LOCATION - 1R12 TO MR15          SAVE BACK POINTER ON TOP OF STACK WITHOUT INCREMENTMR17 TO R17          LOAD PC 17 WITH POINTER TO GO TOIM(CALL-1) TO ATRA   GO BACK, SET PC=17,  RESTORE R14, RESTORE INTERRUPTS**THE RETURN ROUTINE:*RETN:EQU .-ZERO   COMPUTE ABS LOC OF RETN ROUTINEMR15 TO R12       GET BACK POINTER TO PUSH STACKR12I TO R15       PUT THIS IN R15;INCREMENT TO PT TO RETURN-1;INTR SAVES THISMR12 TO R12       PICK UP POINTER TO RETURN-1R12I TO ATNV      INCREMENT R12 SO IT POINTS TO RETURNIM(0) TO ADD0     SET M&Z FLAGS ON SUB RETURNR12 TO ATRA       AND GO BACK TO THE CALLING ROUTINE**THERE ARE SEVERAL ROUTINES THAT WANT TO BE ACCESSIBLE BY A SIMPLE*JUMP TO A LOCATION WITHIN THE FIRST 32 WORDS OF MEMORY.  THIS*APPLIES TO IMPORTANT SYSTEM ROUTINES THAT ARE INVOKED OFTEN.**AT PRESENT, THESE ROUTINES INCLUDE:*SREG:EQU .-ZERO      ABS LOC OF SREG ROUTINERE(SREG1) TO RTRA    JUMP TO SAVE REGISTER ROUTINELREG:EQU .-ZERO      ABS LOC OF LREG ROUTINERE(LREG1) TO RTRA    JUMP TO LOAD REGISTER & RETURN ROUTINE**Perform long jump to interrupt routine:**Model B and earlierA.INT:MR16I TO ATRA (PC=16) GO TO INTERRUPT PROCESSING ROUTINEIN1:DATA A.INT-ZERO HANG UP IN INFINITE LOOP IF ENABLE WITH NO WHEN**Sreg, Lreg:**Model B and earlierSREG1:R15I TO R12 MOVE CURRENT PTR TO R12;INCREMENT R15 PAST SAVED BPTRR4 TO MR15I SAVE R4R5 TO MR15I SAVE R5R6 TO MR15I SAVE R6R7 TO MR15I SAVE R7R10 TO MR15I SAVE R10R11 TO MR15I SAVE R11R12 TO MR15 SAVE BACK POINTERMR12 TO R12 MOVE BACK DOWN ONE LEVEL ON PUSH STACKR12I TO ATNV INCREMENT THIS PAST THAT BACK POINTERMR12 TO R12 GET POINTER TO USERS RETURN-1 (THIS IS PTR TO CALLED ROUTINE)MR12 TO R12 PICK UP POINTER TO THE ROUTINE WICH CALLED SREGR12I TO ATNV INCREMENT THIS TO SKIP OVER SREG CALLR12 TO ATRA AND CONTINUE WITH ROUTINE AFTER SAVING REGS**LOAD REGS AND RETURN:**Model B and earlierLREG1:MR15 TO R12 BACK UP POINTER TO STACK BY ONE LEVELR12I TO ATNV INCREMENT BY ONE TO POINT TO R4MR12I TO R4 LOAD R4MR12I TO R5 LOAD R5MR12I TO R6 LOAD R6MR12I TO R7 LOAD R7MR12I TO R10 LOAD R10MR12I TO R11 LOAD R11MR15 TO R15 NOW WE CAN BACK UP STACK POINTERIM(RETN) TO ATRA AND NOW PERFORM A NORMAL RETURNendif of ^ModelCeject**Low core routines for Models C, D, and later*if ModelcA.INT:MR16I TO ATRA    (PC=16) GO TO INTERRUPT PROCESSING ROUTINEIN1:DATA A.INT-ZERO    PATCHED BY COMPILER TO POINT TO INTRPT ROUTINE**Frequently invoked system routines (in first 32 words of memory)*  Note that SREG must NOT be transferred to indirectly and that*  it should be the last entry in this table (to maximize the size*  of the table).**WARNING:  R.IER is very closely tied to LREG/SREG!  If either one*          changes, update L.IER accordingly.***Save all six index registers.  Any procedure which calls this routine*  at entry should adhere strictly to the following calling convention:*      PROC: ...*            D10      to MR12D  Save where we came from on the stack*            im(SREG) to ATRA   Save the index registers*SREG: equ .-ZERO   Abs loc of SREG entry      im(-20) to D1 disable interrupts (preserve D10)      R4 to MR12D stack R4      R5 to MR12D stack R5      R6 to MR12D stack R6      R7 to MR12D stack R7      R10 to MR12D stack R10      R11 to MR12D stack R11      R14 to D1 restore interrupts as they were before entry      D10 to ATRA and return to our caller (this two instruction enable/transfer sequence will NOT be interrupted)**Load all six index registers and return.  To exit a procedure which was*  entered via SREG, simply:*            im(LREG) to ATRA   Restore index registers and return*LREG:  equ .-ZERO     Abs loc of LREG entry       R12I  to ATNV  back up stack pointer       MR12I to R11   restore R11       MR12I to R10   restore R10       MR12I to R7    restore R7       MR12I to R6    restore R6       MR12I to R5    restore R5       MR12I to R4    restore R4       MR12 to ATRA   and return to original callerendif**Swap Entry for Model C Only:*if ModelC-ModelD        Model C onlySWAP:  equ .-ZERO       Abs loc of SWAP entryD10    to  MR12D        save return on stackPCI    to  ATRA         jump to swap entrySWAP1: DATA .-ZERO-1    patched to point to r.swapR12I   to ATNV          pre-increment stack pointerMR12   to ATRA          and return to callerendifeject**More transfer vector,  and low core routines to switch pages*for Model D processor**The following two sections of code must start within the first 32 words*of memory,  and end within the first 64 words of memory.   This code*is duplicated in the lower part of internal memory,  as well as*on the front of every page of external memory.**The object code is as follows:**   To call a swap procedure that acually needs data swapped in:*      PCI to r15         get swapping procedure number*      (swap proc id)*      im(SWAP) to ATRA   go to low memory routine to read in proc & go there**   To switch from page x to page y (to call a SWAPCODE procedure*   that resides on a different page: (only available if proc*   takes 3 or fewer args) - (very important for real time code)**      (page delta) to r3  delta, plus or minus, from current page*      pci to r15          location in page to jump to*      im(pgx) to atra     go there**   To transfer to page 0 from external memory:*      PCI to r15         get pointer to page 0 location*      (pointer)*      im(PGSW) to ATRA   jump to page switch code*if ModelD                  Model D OnlySWAP:     equ .-ZERO       Abs loc of SWAP entryD10       to MR12D         save return on stackRE(SWAP2) to RTRA          continue with routine off of first 32 words**Special code use by interrupt routine for Model D to return to*code on any page:*C.PGSW:MR12I to D11    RESTORE PAGE POINTER                 (INT)       R14   to D1     RESTORE C,Z,M BITS - ENABLE INTS     (INT OR EXT)       MR12I to ATRA   RETURN FROM INTERRUPT                (INT OR EXT)**Routine to quickly switch BETWEEN external memory pages to quickly*call external memory procedures:*PGX:   D10       to MR12D  SAVE RETURN ON CURRENT PAGE       RE(A.PGX) to RTRA   JUMP TO CODE BELOW**Routine to quickly switch to page 0 to call RTP*or other page 0 routine:*PGSW:  D10   to  MR12D  SAVE OUR RETURN ON STACK              (EXT)       D11   to  MR12D  SAVE CURRENT PAGE PTR ON STACK        (EXT)       IM(0) to  D11    SWITCH TO PAGE 0                      (EXT)       R15   to  ATRA   JUMP TO DESIRED PAGE 0 ROUTINE        (INT)       R12I  to  ATNV   PRE-INCREMENT STACK POINTER           (INT)       MR12I to  D11    RESTORE PAGE POINTER                  (INT)       MR12  to  ATRA   RETURN TO DESIRED LOCATION            (EXT)**Continuation of Swap Entry Routine:*SWAP2: D11    to MR12D       save page pointer on stack       IM(0)  to D11         select page 0       PCI    to ATRA        jump to swap entry       SWAP1: DATA .-ZERO-1  patched to point to r.swap       R12I   to ATNV        pre-increment stack pointer       MR12I  to D11         restore page pointer       MR12   to ATRA        and return to caller**Continuation of code to switch BETWEEN external memory pages*A.PGX: D11   to MR12D   SAVE CURRENT PAGE POINTER       IM(0) to BSOR3   MOVE PAGE DELTA TO UPPER HALF (LOWER HALF IS RANDOM NOW)       D11   to ADD3    COMPUTE NEW PAGE POINTER (UPPER HALF ONLY)       R3    to D11     SET NEW PAGE POINTER (UPPER HALF IS EFFECTIVE ONLY)       R15   to ATRA    GO THERE (CALL SWAPCODE PROC WITH 3 OR FEWER ARGS)       R12I  to ATNV    PRE-INCREMENT R12 FOR RETURN       MR12I to D11     RESTORE PAGE POINTER       MR12  to ATRA    AND RETURN TO CORRECT LOCATION ON THIS PAGE**Subroutine of R.SWAP that is used to enter the code in external*memory after it has loaded the strings/data into internal*memory:*A.PGSW: MR12  to D11    SET NEW PAGE BITS                     (INT)        R15   to ATRA   JUMP TO CORRECT LOCATION ON THIS PAGE (EXT)        IM(0) to D11    RETURN TO PAGE 0                      (EXT)        PCI   to ATRA   RETURN TO L.SWAP                      (INT)B.PGSW: DATA  0         patched to point to l.swap*ENDIFEJECTLISTOFF**Start-up routine - R0 points to the configuration table*G.STA:... GO START UPif ^ModelCMR0I TO R15 GET POINTER TO START OF VARIABLE AREAMR0I TO LOA1 GET NUMBER OF WORDS IN VARIABLE AREAIM(3) TO RTZE IF NONE,  THEN DO NOT ZEROIM(0) TO MR15I ZERO OUT MEMORYIM(1) TO SUB1 ARE WE DONE YET?IM(-3) TO RTNZ IF NOT,  THEN GO BACKR0I to ATNV skip over stack lengthendif of ^ModelCif ModelCMR0I to R2 get pointer to start of variable areaMR0I to LOA1 get number of words in variable areare(B.STA) to RTZE don't zero if no variables*A.STA: im(1) to SUB1 subtract one for REPEAT (REPEAT adds one)R1 to D10 REPEAT (R1 mod 256) + 1 timesim(0) to MR2I clear the next wordPCI to AND1 subtract out the amount we just diddata ^377 REPEAT used the low order byte as the countre(A.STA) to RTNZ loop until the entire block is zeroed*B.STA: im(1) to SUB2 point to the top of the variable area (rather than the bottom of the stack area)MR0I to ADD2 add in the stack length (point to top of stack area)R2 to R12 and set up the stack pointerendif of ModelC*PCI to R3 pick up pointer to swap RAM pointerdata CONTAB+SWPRAM point to swap RAM pointerMR3 to LOA3 pick up swap RAM pointerre(C.STA) to RTZE no swappingR4 to MR3 save swap file pointer - R4 is passed to us by the OVERLAY routine (when used)*C.STA: IM(CALL) TO R16 SET UP R16 POINTING TO CALL/INTERRUPT ROUTINEIM(-20) TO R14 SET UP R14 TO INITIALLY KEEP INTERRUPTS OFFMR0 TO ATRA AND NOW TRANSFER TO START OF OBJECT CODEEJECT**CONFIGURATION TABLE:**A CONFIGURATION TABLE IS INCLUDED IN EVERY XPL PROGRAM.  IT IS USED TO HOLD*POINTERS TO IMPORTANT LOCATIONS (SUCH AS THE START OF THE OBJECT CODE), AS*WELL AS INFORMATION REGARDING THE DEVICES CONNECTED TO THE SYSTEM.  WORD 1*OF EVERY PROGRAM POINTS TO THE START OF THE CONFIGURATION TABLE.**THE CONFIGURATION TABLE IS A 64 WORD BLOCK OF INFORMATION, AS FOLLOWS:*VSTART:EQU 0  LOCATION 0 - POINTS TO START OF VARIABLE AREAVLNGTH:EQU 1  LOCATION 1 - CONTAINS NUMBER OF WORDS IN VARIABLE AREASTKLEN:EQU 2  LOCATION 2 - STACK LENGTH (IN WORDS)OBJLOC:EQU 3  LOCATION 3 - POINTS TO START OF OBJECT CODEOBJLEN:EQU 4  LOCATION 4 - LENGTH OF OBJECT CODE (IN WORDS)SWPLOC:EQU 4  LOCATION 4 - ALSO POINTS TO SWAP AREASWPRAM:EQU 5  LOCATION 5 - POINTS TO FOUR WORD RAM AREA FOR SWAPPING MECHANISMSWPLEN:EQU 6  LOCATION 6 - LENGTH OF SWAP FILE (IN SECTORS)RTPLOC:EQU 7  LOCATION 7 - POINTS TO START OF RTPINTTAB:EQU 10 LOCATION 10- POINTS TO 'WHEN' STATEMENT TRANSFER TABLERCVPTR:EQU 11 LOCATION 11- POINTS TO 'RCVDCHARACTER' RAM LOCATIONINPBUF:EQU 12 LOCATION 12- POINTS TO INPUT BUFFER FOR 'INPUT' STATEMENTSBRSBW:EQU 13 LOCATION 13- POINTS TO RAM WORD PAIR FOR SBR/SBW ROUTINECURTRK:EQU 14 LOCATION 14- POINTS TO DOUBLE WORD PAIR IN RAM CONTAINING HEAD POS OF FLOPPIESDEVTAB:EQU 15 LOCATION 15- POINTS TO ADDITIONAL DEVICE DRIVER TABLEMEMSIZ:EQU 20 LOCATION 20- AMOUNT OF MAIN MEMORY CONNECTED TO MACHINE (IN SECTORS)CMOPT: EQU 21 LOCATION 21- COMPUTER/MUSIC OPTIONSPTYPE: EQU 22 LOCATION 22- TERMINAL TYPE | NUMBER OF NULLS AFTER CR/LFSTYPE: EQU 23 LOCATION 23- PRINTER  TYPE | NUMBER OF NULLS FOR PRINTERREDRCT:EQU 24 LOCATION 24- REDIRECTION WORD - UPPER: INPUT; LOWER: PRINTVERSN: EQU 25 LOCATION 25- SYSTEM VERSION NUMBER MINUS 6*CURDEV:EQU 27 LOCATION 27- POINTER TO CURRENT DEVICE IN STORAGE DEVICE TABLESTRDEV:EQU 30 LOCATION 30- START OF STORAGE DEVICE TABLESTREND:EQU 100 LOCATION 100-END OF STORAGE DEVICE TABLE PLUS ONE**THE FOLLOWING LOCATIONS DEFINE THE FIVE WORD STORAGE DEVICE TABLE ENTRIES:*DEVTYP:EQU 0 UPPER: ZERO; LOWER: DEVICE TYPESECCYL:EQU 1 SECTORS/CYLINDERTOTCYL:EQU 2 TOTAL CYLINDERSSPDTRK:EQU 3 UPPER: SECTORS/TRACK; LOWER: STEPPING SPEEDDEVADR:EQU 3 DEVICE ADDRESS (UPPER: DRIVE; LOWER: CONTROLLER)*BLKLEN:EQU 4 LENGTH OF A STORAGE DEVICE ENTRYFREBLK:EQU -1 END OF DEVICE TABLE FLAG*DEVDRV:EQU 12 NUMBER OF DEVICE DRIVER POINTERS IN DEVICE DRIVER TABLEDEVDRS:EQU 4 NUMBER OF USER DEVICE DRIVERSEJECT***DEFAULT CONFIGURATION TABLE IS AS FOLLOWS:*CONTAB:EQU .-ZERO COMPUTE ABS LOC OF CONFIG TABLEDATA 0      POINTER TO VARIABLESDATA 0      LENGTH  OF VARIABLESDATA 0      STACK LENGTHDATA 0      POINTER TO OBJECT CODEDATA 0      LENGTH OF OBJECT CODEDATA 0      POINTER TO SWAP TABLEDATA 0      LENGTH OF SWAP FILE (IN SECTORS)DATA 0      POINTER TO RTPDATA 0      POINTER TO WHEN STATEMENT TABLEDATA 0      POINTER TO 'RCVDCHARACTER'DATA 0      POINTER TO INPUT BUFFERDATA 0      POINTER TO SPECIAL READ/WRITE WORD PAIR (IMPURE)DATA 0      POINTER TO DISK HEAD POSITION WORDSDATA 0      RESERVED (MBZ)DATA 0      RESERVED (MBZ)DATA 0      RESERVED (MBZ)DATA 000200 DEFAULT MEMORY SIZE IS 128 SECTORS (32K WORDS)IF ^modelcDATA 000401 DEFAULT OPTIONS: MODEL B, 200 HZ, NO OPTIONSendifif Modelc-ModeldDATA 001001 DEFAULT OPTIONS: MODEL C, 200 HZ, NO OPTIONSendifif ModeldDATA 001401 DEFAULT OPTIONS: MODEL D, 200 HZ, NO OPTIONSendifDATA 000000 DEFAULT TERMINAL TYPE IS UNKNOWN WITH NO NULLS (PRINT)0DATA 000000 DEFAULT PRINTER TYPE IS UNKNOWN WITH NO NULLS (SEND)DATA 000000 DEFAULT REDIRECTION IS NONE (PRINT TO TERMINAL, INPUT FROM TERMINAL)DATA 000001 SYSTEM VERSION NUMBER MINUS 6 (-7)DATA 000000 RESERVED (MBZ)DATA 000000 CURRENT DEVICE IS F0DATA 002400 DEFAULT SYSTEM DEVICE IS F0: SUPER MINIFLOPPYDATA 000036 NUMBER OF SECTORS PER CYLINDER ON SYSTEM DEVICE - 30DATA 000120 NUMBER OF CYLINDERS ON SYSTEM DEVICE - 80DATA 007400 NUMBER OF SECTORS PER TRACK ON SYSTEM DEVICE - 15/STEPPING SPEED = 0DATA FREBLK FILL OUT THE REST OF THE TABLE WITH FREE ENTRIES (DEVICE 2)DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 3DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 4DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 5DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 6DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 7DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 8DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 9DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 10DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 11DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 12DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 13DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 14DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 15DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 16DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 17DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 18DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 19DATA FREBLKDATA FREBLKDATA FREBLKDATA FREBLK DEVICE 20DATA FREBLKDATA FREBLKDATA FREBLKZ.STA:DATA 0 END OF STARTUP ROUTINE, NO PATCHESttl Swappable Procedure Handling**The following routines are called to set up for and then to call a*procedure which may be swapped out to external memory (or disk).*In the following discussion, "overlay" is synonymous to "swappable*procedure".**Each swappable proc has a procedure ID between one and N (the total*number of swappable procs) inclusive.  Only one swappable proc can*be in memory at one time, although swappable procs can call each*other.  An area in memory (the swap area) is reserved for reading*in a swappable proc.**A word in the configuration (CONTAB + SWPRAM) points to the swapping*mechanism's RAM area.  Another word in the configuration (CONTAB + SWPLOC)*points to the swap area.**The RAM reserved for swapping is organized as follows:*  0: sector offset for start of overlay file*  1: proc ID for overlay to swap to (parameter to L.SWAP)*  2: proc ID of overlay currently active (zero if nothing active)*  3: proc ID of overlay currently in memory (zero if nothing in memory)**The overlay file has a swap lookup table at the very start of it.*The header for the lookup table is set up as follows:*  0: number of swappable procs N**The header is immediately followed by N table entries by proc ID:*  0: relative sector address of procedure (relative to start of file)*  1: word address (within that sector) where the procedure starts*  2: word length of the procedure*  3: amount of swapping scon and data array - Model D only**The swapping procedures immediately follow the swap lookup table*in the overlay file.***SWAPINIT: Initialize swapping mechanism.**Registers at entry:*  R0 - sector offset for start of overlay file**Registers trashed:  R0, R2, R3**Registers at exit:*  R0 - previous sector offset*R.SWI: data Z.SWI initialize swapping mechanismif ModelCD10 to MR12 save returnendifPCI to R2 pick up pointer to pointer to swap RAM areadata CONTAB+SWPRAM point to pointerMR2 to LOA2 pick up pointer to swap RAM areare(A.SWI) to RTZE can't set it if it's zeroMR2 to R3 pick up previous valueR0 to MR2 save new valueim(2) to ADD2 point to active proc IDim(0) to MR2 and zap it (there is no active proc)R3 to LOA0 return previous valueA.SWI: RETURN to ATRA and that is itZ.SWI: data 0 end of segment; no patcheseject***SWAP: Call a swappable procedure.**Registers at entry:*  R0 - 1st parameter to called procedure*  R1 - 2nd parameter to called procedure*  R2 - 3rd parameter to called procedure*  R3 - 4th parameter to called procedure**For Models C, D:*  R15 - id# or proc to call**Registers trashed:  R0, R1, R2, R3**Registers at exit:*  R0, R1 - return value from called procedure*R.SWAP: data Z.SWAP call a swappable procedureH.SWAP: ...         start of swap procedure codeif ModelC   D10 to MR12D     stack return (point to low memory for model D page switch code)endifim(SREG) to ATRA save registersR0 to R4 preserve procedure parametersR1 to R5R2 to R6R3 to R7*PCI to R10           pick up pointer to swap RAM pointerdata CONTAB+SWPRAM   point to swapping RAM pointerMR10  to R11         pick up pointer to RAM area for swappingMR11I to R1          pick up sector offset of overlay fileif ^ModelC   MR11I to LOA0     pick up proc ID of proc to call   R15I to R12       get back pointer   MR11 to MR15I     stack proc ID of proc currently in memory   R12  to MR15      save backpointerendifif ModelC   R15  to MR11I     save id# of proc to call (not needed now?)   R15  to LOA0      and get proc id# in r0   MR11 to MR12D     stack proc ID of proc currently in memoryendifif Debug   R0 to R2          move proc # to r2   Im(0) to R3       zero indicates we're calling the procedure   Im(0) to R0       invoke BREAK routine   jump to proc   sw.xxx:  DATA 0   will point to R.BRK routine   R2 to R0          restore r0endifR0 to MR11I          save proc ID of proc we're about to callif ^Modeld   MR11 to TSUB0     is this proc the same as the one currently in memory?   pci to rtze       yes, skip the read   data e.swap-.-1endifif ModelD            save id of proc in memory for later compare if model D   mr11 to r10       get id of current in-memory procedureendifR0 to MR11           save proc ID of proc we're about to read ineject**At this point, the registers contain:*  R0:  proc ID of proc to call*  R1:  sector offset of overlay file*  *Read in desired procedure:*if ^ModelD     if not model d,  save d60, d61 in r10 and r11  D60 to R10   to preserve them for the user  D61 to R11endifif ModelD      if model d,  use the stack to store them  d61 to mr12d  d60 to mr12dendifim(1) to SUB0   map proc ID to range 0 thru N-1if ^ModelD      If not model d, use stride of 3,  plus 1 for # of procs   R0 to R3     copy in r3   R0I to ADD3  compute X2, increment r0   R0  to ADD3  compute x3 plus 1   R3 to R0     duplicate result in r0endifif ModelD       use stride of 4 for model D   r0 to ADD0   compute X2   r0 to ADD0   compute X4   pci to ADD0  add in header of 64 words + 1 for max procs   data 101   R0 to R3     duplicate in r3endifim(0) to BSOR0  compute sector offset (pointer into swap table)PCI to AND0data 377R1 to ADD0      make sector absoluteR0 to D60       point to table entryR3 to D61D63 to R0       get relative sector offsetR1 to ADD0      put absolute sector address in R0D63 to R1       put word offset in R1*At this point:*   r0 = absolute sector # where swap proc sits*   r1 = word within that sector where swapping proc starts*   mam,mal = point to object code length entry of swap table for this procif ModelD       if ModelD,  compute page & location of proc   R0 to R3     duplicate absolute sector # of proc   pci to and3  mask lower half   data 377   r1 to bsor3  compute location in page to jump to   r10 to r2    get id or proc that was in memory   MR11 to TSUB2  is this proc the same as the one currently in memory?   r3 to r11    move absolute page location to r11 (Z flags unchanged)   r0 to r10    move page # to r10 (z flags unchange)   pci to rtze       if proc in memory was the same as the one we are   data e.swap-.-1   reading in,  skip call to import   D63 to R3    get word length of entire proc   D62 to SUB3  subtrack word length of strings to get pointer to strings   r3 to ADD1   add that to word offset (ie point to string consts only) (let import normalize this sum)   D62 to LOA3  get length of string constants only; see if 0   re(e.swap) to rtze    if no strings to copy in, skip call to import   PCI to R2    pick up pointer to swap area pointer   data CONTAB+SWPLOC point to swap area pointer   MR2 to r2    set up pointer for the import routine   PCI to ATra  call import routine   A.SWAP: data 0 patch pointer to IMPORT routineendifif ^Modeld      if not model D, just look up word length for import   D63 to R3    and word length of entire proc + data in R3   R10 to D60   restore D60/D61   R11 to D61   PCI to R11    pick up pointer to swap area pointer   data CONTAB+SWPLOC point to swap area pointer   mr11 to r2    get location to read code into   JUMP to PROC import code to swap area   A.SWAP: data 0 patch pointer to IMPORT routineendif**Enter from above if desired swap proc is the one in memory:*E.SWAP: ...      set up and call the desired procedure**Restore d60 pointers here if model D*if ModelD         for model d, switch page and jump to location   r12i to atnv   pre-increment to info on stack   mr12i to d60   restore user's d60   mr12  to d61   and            d61endifif ^ModelC   R15I to R12   set up stack so we return here   R17 to R0     get current location   im(D.SWAP-.-1) to ADD0 compute pointer to D.SWAP-1   R0 to MR15I   stack return   R12 to MR15   save back pointerendifR4 to R0 restore procedures parametersR5 to R1R6 to R2R7 to R3if ^ModelD       if not model D, jump to swap area   PCI to R11    pick up pointer to swap area pointer   data CONTAB+SWPLOC point to swap area pointer   MR11 to ATRA  and call the swapped in procendifif ModelD         for model d, switch page and jump to location   r10 to mr12    save new page to go to in mr12   r11 to r15     get new program counter on that page   pci to atra    go to low memory page swap routine   data a.pgsw-zero   G.SWAP: ...     restore r11 for following code   PCI to R11      pick up pointer to swap area pointer   data CONTAB+SWPLOC point to swap area pointerendifeject***We return here after calling said procedure.  The registers contain:*  R0, R1: return value from called proc*  R11:    pointer to pointer to swap area*D.SWAP: ...R0 to R4    preserve the return valueR1 to R5PCI to R6   pick up pointer to swap RAM pointerdata CONTAB+SWPRAM point to swapping RAM pointerMR6 to R6   pick up pointer to swap RAMMR6I to R1  pick up sector offset of overlay fileR6I to ATNV point to proc ID of procedure currently activeif ^ModelCMR15 to R12 pick up back pointerR12I to R15 reset stack pointer and point to previous proc IDendifif ModelCif Debug   MR6 to R2            move proc # to r2   Im(1) to R3          one indicates we're returning from the procedure   Im(0) to R0          invoke BREAK routine   jump to proc   sr.xxx:  DATA 0      will point to R.BRK routineendifR12I to ATNV back up stack pointer (point to previous proc ID)endifMR6 to R0 pick up current proc IDMR12 to MR6 set current proc ID to previous proc IDMR12 to TSUB0 is the current proc the same as the previous?re(C.SWAP) to RTZE yes, skip the read in (just return)MR6I to LOA0 see if there was a previously active procre(C.SWAP) to RTZE there wasn't - don't read one back in (just return)R0 to MR6 save proc ID of the proc we're about to read in**At this point, the registers contain:*  R0:  proc ID of calling proc*  R1:  sector offset of overlay file*  R4:  contains user return value r0*  r5:  contains user return value r1*  R11: pointer to pointer to swap area**Read in the original procedure:*D60 to R6 preserve D60/D61D61 to R7im(1) to SUB0 map proc ID to range 0 thru N-1if ^ModelD    use stride if 3 if not modeldR0 to R3 move to R3R0I to ADD3 multiply by 4 (which is the same as adding that number 4 times) AWGR0 to ADD3 add one extra (see R0I just above) to skip over headerR3 to R0 duplicate resultendifif ModelD   user stride of 4 for modelDr0 to add0  compute X2r0 to add0  compute X4pci to add0 plus 64 for header, plus 1 for # of procsdata 101r0 to r3    duplicate in r3endifim(0) to BSOR0 get sector number specifiedPCI to AND0data 377R1 to ADD0 make sector absoluteR0 to D60 point to table entryR3 to D61D63 to R0 get relative sector offsetR1 to ADD0 put absolute sector address in R0D63 to R1 put word offset in R1D63 to R3 and word length in R3if ModelD   read just string consts if modeldD62 to sub3 back up total length to be just length of object coder3 to add1  advance word offset to point to start of scon aread62 to loa3   now only this much to copy inendifMR11 to R2 move the swap area address into R2R6 to D60 restore D60/D61R7 to D61if ModelDpci to atnz   only call import if any to doendifif ^ModelDJUMP to PROC import code to swap areaendifB.SWAP: data 0 patch pointer to IMPORT routine*C.SWAP: R4 to LOA0 recover return value (with flags)R5 to R1im(LREG) to ATRA and return*Z.SWAP: data A.SWAP patch tabledata L.IPTdata B.SWAPdata L.IPTif debug   DATA sw.xxx   DATA L.BRK   DATA sr.xxx   DATA L.BRKendifdata 0 end of segmentTTL INTERRUPT PROCESSING ROUTINES**THE FOLLOWING CODE IS ENTERED TO PROCESS AN INTERRUPT IN XPL.**THE IMPORTANT REGISTERS ARE SAVED ON THE PUSH DOWN STACK,  THE PROCESSOR*STATUS WORD IS INTERROGATED TO DETERMINE WHICH DEVICE CAUSED THE*INTERRUPT,  AND THE APPROPRIATE 'WHEN' STATEMENT IS INVOKED. **SAVE THE 4 ACCUMULATORS AND THE STATUS FLAGS ON THE STACK.*R.IN1:DATA Z.IN1 PC=R16!!!*if ^ModelC VERSION THAT DOES NOT USE PRIORITY ENCODER (Model A & Model B)R15I TO ATNV INCREMENT STACK PTR TWICE IN CASE WE INTERRUPTED OUT OF RETNR15I TO ATNV DITTOD1 TO MR15I  READ & STORE C, Z, AND M BITSR3 TO MR15I  STORE R3R2 TO MR15I  STORE R2R1 TO MR15I  STORE R1R0 TO MR15I  AND PUT R0 ON TOP OF STACK - THIS IS LAST TO COME OFFR15 TO R3    SAVE STACK POINTER FOR FUTURE BACK POINTER**THE FOLLOWING SEGMENT PERFORMS THE NECESSARY INTERRUPT*BRANCHING WITHOUT USING THE PRIORITY ENCODER.*D1 TO LOA0 GET PROCESSOR STATUS WORDIM(1) TO OR0 SET LSB IN ANY CASE TO PREVENT LOOPINGMR16I TO R1 START WITH 32DATA 40IM(2) TO SUB1 DECREMENT DISTANCER0 TO ADD0 SHIFT LEFT TO LOOK FOR CARRYIM(-3) TO RTNC IF NO CARRY,  THEN CONTINUE TO HANGR1 TO RTRA AND THEN BRANCH DEPENDING ON BITMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA B04INT-.-1 REL DIST FOR BDB4MR16I TO RTRA PERFORM JUMPDATA B05INT-.-1 REL DIST FOR BDB5MR16I TO RTRA PERFORM JUMPDATA B06INT-.-1 REL DIST FOR BDB6MR16I TO RTRA PERFORM JUMPDATA B07INT-.-1 REL DIST FOR BDB7MR16I TO RTRA PERFORM JUMPDATA B08INT-.-1 REL DIST FOR BDB8MR16I TO RTRA PERFORM JUMPDATA B09IN3-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D140MR16I TO RTRA PERFORM JUMPDATA B10IN3-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D54MR16I TO RTRA PERFORM JUMPDATA B11IN3-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D55MR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DIST FOR BDB12MR16I TO RTRA PERFORM JUMPDATA B13INT-.-1 REL DIST FOR BDB13MR16I TO RTRA PERFORM JUMPDATA B14INT-.-1 REL DIST FOR BDB14MR16I TO RTRA PERFORM JUMPDATA B15INT-.-1 REL DIST FOR BDB15EJECT**SPECIAL SUBROUTINES TO PROCESS*INTERRUPTS WITHOUT USING THE PRIORITY ENCODER*B09IN3:... ROUTINE FOR D140 COMMUNICATION PROCESSORIM(0) TO MR15I INDICATE D140, D141 SAVEDD140 TO MR15I SAVE CURRENT D140 REGISTERD141 TO MR15I SAVE CURRENT D141 REGISTERD143 TO LOA1 GET BIT WORDIM(1) TO OR1 PROTECT FROM LOOPING BY FORCING BDB0MR16I TO LOA0 START WITH 64DATA 100IM(4) TO SUB0 DECREMENTR1 TO ADD1 SHLIM(-3) TO RTNC IF NO CARRY, LOOPR0 TO D140 AND SELECT THE CARD IN QUESTIOND144 TO LOA1 GET BIT WORD TO SELECT PORTIM(16) TO TAND1 SEE IF BITS 1, 2, OR 3 SETIM(1) TO RTZE SKIP IF NOTIM(1) TO ADD0 IM(14) TO TAND1 SEE IF BITS 2, OR 3 SETIM(1) TO RTZE SKIP IF NOTIM(1) TO ADD0IM(10) TO TAND1 SEE IF BIT 3 SETIM(1) TO RTZE IF NOT,  THEN SKIPIM(1) TO ADD0R0 TO D140 SELECT DESSIRED PORTIM(11) TO R0 TRY TO CALL WHEN ROUTINE #9MR16I TO RTRA AND CONTINUE PROCESSING WITH MAIN ROUTINEDATA CUIR+1-.-1 RELATIVE DISTANCE TO CUIR+1B10IN3:... INTERRUPTS FROM D54 - INVOKE WHEN STATEMENTD54 TO LOA1 GET BIT WORD ROM D54MR16I TO LOA0 START WITH 32DATA 40IM(3) TO RTRA AND SKIP AHEAD (!!!!!)B11IN3:... INTERRUPTS FROM D55 - INVOKE WHEN STATEMENTD55 TO LOA1 GET BIT WORD FROM D55MR16I TO LOA0 START WITH 48DATA 60IM(1) TO OR1 MAKE SURE ONE BIT IS SETIM(1) TO SUB0 DECREMENTR1 TO ADD1 SHIFT LEFTIM(-3) TO RTNC BRANCH BACKMR16I TO RTRA AND INVOKE USER ROUTINEDATA CUIR-.-1 RELATIVE DISTANCEendif of ^ModelCEJECT**Interrupt processing on the ABLE Series Model C Only*if ModelC-ModelD VERSION USING PRIORITY ENCODER (Model C Only)        MR12  to MR12D decrement stack pointer in case we interrupted out of a return        R0    to MR12D save R0        R1    to MR12D save R1        R2    to MR12D save R2        R3    to MR12D save R3        D1    to MR12D save C, Z, and Min2:    im(1) to rtra    patched to be D61 to MR12D if swapping included        im(0) to rtra    patched to be D60 to MR12D if swapping included**READ THE PROCESSOR STATUS WORD,  SEE WHICH DEVICE IS REQUESTING AN INTERRUPT,*(USING PRIORITY ENCODER), THEN CALL THE APPROPRIATE USER ROUTINE IF IT EXISTS.*D1 TO D2   READ STATUS WORD,  WRITE TO PRIORITY ENCODERD2 TO RTRA BRANCH ON WHICH BIT IS SET*MR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTMR16I TO RTRA PERFORM JUMPDATA B04INT-.-1 REL DIST FOR BDB4MR16I TO RTRA PERFORM JUMPDATA B05INT-.-1 REL DIST FOR BDB5MR16I TO RTRA PERFORM JUMPDATA B06INT-.-1 REL DIST FOR BDB6MR16I TO RTRA PERFORM JUMPDATA B07INT-.-1 REL DIST FOR BDB7MR16I TO RTRA PERFORM JUMPDATA B08INT-.-1 REL DIST FOR BDB8MR16I TO RTRA PERFORM JUMPDATA B09INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D140MR16I TO RTRA PERFORM JUMPDATA B10INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D54MR16I TO RTRA PERFORM JUMPDATA B11INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D55MR16I TO RTRA PERFORM JUMPDATA INTRET-.-1 REL DIST FOR BDB12MR16I TO RTRA PERFORM JUMPDATA B13INT-.-1 REL DIST FOR BDB13MR16I TO RTRA PERFORM JUMPDATA B14INT-.-1 REL DIST FOR BDB14MR16I TO RTRA PERFORM JUMPDATA B15INT-.-1 REL DIST FOR BDB15EJECT**SPECIAL SUBROUTINES TO USE THE PRIORITY ENCODER*B09INT:... ROUTINE FOR D140 COMMUNICATION PROCESSORD141 TO MR12D SAVE CURRENT D141 REGISTERD140 TO MR12D SAVE CURRENT D140 REGISTERIM(0) TO MR12D SAVE A ZERO TO INDICATE D140 INFO SAVEDD143 TO D2 GET BIT WORD WHICH SELECTS CARDD2 TO LOA0 AND GET 2 X CARD #R0 TO ADD0 COMPUTE 4 X CARD #R0 TO D140 AND SELECT THE CARD IN QUESTIOND144 TO D2 GET BIT WORD TO SELECT PORT ON THIS CARDD2 TO R1 GET THIS NUMBER X 2R0 TO SHRA1 SHIFT RIGHT (divide by 2),  AND THEN ADD 4 X CARDR1 TO D140 AND SELECT THE PORT IN QUESTIONIM(11) TO R0 TRY TO CALL WHEN STATEMENT #9MR16I TO RTRA AND CONTINUE PROCESSING WITH MAIN ROUTINEDATA CUIR+1-.-1 ENTER CUIR AT CUIR+1B10INT:... INTERRUPTS FROM D54 - INVOKE WHEN STATEMENTD54 TO D2 GET BIT WORD FROM D54D2 TO R0 GET 2X BIT #IM(20) TO SHRA0 DIV BY 2 AND ADD IN BASE OF 16MR16I TO RTRA AND INVOKE USER ROUTINEDATA CUIR-.-1 RELATIVE DISTANCEB11INT:... INTERRUPTS FROM D55 - INVOKE WHEN STATEMENTD55 TO D2 GET BIT WORD FROM D55D2 TO R0 GET 2X BIT #MR16I TO SHRA0 divide by 2, ADD IN BASE OF 32DATA 40MR16I TO RTRA AND INVOKE USER ROUTINEDATA CUIR-.-1 RELATIVE DISTANCEendif of ModelC-ModelDEJECT**DEVICE INTERRUPT ROUTINES:**THE FOLLOWING ROUTINES ARE ENTERRED IN RESPONSE TO A CERTAIN BIT ON THE*BDB LINES DURING A READ OF DEVICE 1.**EACH ROUTINE:*  ACKNOWLEDGES THE INTERRUPT,  BY READING/WRITING THE APPROPRIATE DEVICE*  THEN PROCEEDS TO CALL A USER INTERRUPT ROUTINE (WHEN) IF IT IS THERE .**PROCESS BDB BITS FOR USER DEVICES:*if ^ModelDB15INT:IM(17) TO R0 TRY TO CALL USER ROUTT1:    MR16I TO RTRA AND TRY TO CALL USER ROUTINE       DATA CUIR-.-1B14INT:IM(16) TO R0 TRY TO CALL USER ROUTINE 14       RE(T1) TO RTRA AND CALL IT**D03 REAL TIME CLOCK*B08INT:IM(0) TO D3 ACKNOWLEDGE D3 INTERRUPTIM(7) TO R0 CALL USER ROUTINE #7RE(T1) TO RTRA AND CALL USER WHEN ROUTINE**D16 TIMER*B07INT:D16 TO ATNV READ SCT TO CLEAR THE FLAGIM(5) TO R0 TRY TO CALL USER ROUTINE #5RE(T1) TO RTRA**D115 COMMUNICATIONS PROCESSOR*B13INT:IM(15) TO R0 CALL USER ROUTINE #13RE(T1) TO RTRA**D50 USER TERMINAL*B06INT:D51 TO R0 GET STATUS FROM TERETYPEIM(2) TO AND0 SEE IF RCVD CHARACTERRE(TTIINT) TO RTNZ IF BIT IS SET,  THEN RECEIVED CHARACTERIM(0) TO D51 CLEAR THE XMIT DONE INTERRUPTIM(1) TO R0 AND TRTY TO CALL USER ROUTINE #1RE(T1) TO RTRA CALL USER ROUTINETTIINT:IM(2) TO R0 TRY TO CALL USER ROUTINE #2D50 TO R1 AND GET CHARACTER & CLEAR INTERRUPTMR16I TO R2 GET POINTER TO RCVD CHARACTER ADDRESSDATA CONTAB+RCVPTR POINTER TO RAM POINTERMR2 TO R2 PICK UP POINTER TO RCVDCHARACTER LOCATIONR1 TO MR2 STORE RCVD CHARACTERRE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**D136 REAL-TIME CLOCK*B05INT:IM(0) TO D136 ACKNOWLEDGE D136 INTERRUPTIM(12) TO R0 CALL USER ROUTINE #10RE(T1) TO RTRA AND CALL USER WHEN ROUTINE**D137 CLOCK/CALENDAR*B04INT:IM(13) TO R0 CALL WHEN D137INT (#11)endifEJECT*ROUTINE TO INVOKE A USER 'WHEN' STATEMENT (Model A & Model B):*C U I R  STANDS FOR CALL USER INTERRUPT ROUTINE**ENTER AT CUIR+1 FOR D140 INTERRUPT*if ^ModelCCUIR:IM(2) TO MR15I STORE A 2 TO INDICATE NO D140 INFORMATION SAVEDMR16I TO R1 PICK UP POINTER TO CONFIG TABLEDATA CONTAB+INTTAB POINTER TO INTERRUPT TABLEMR1 TO ADD0 ADD IN BASE OF INTERRUPT TABLE TO WHEN NUMBER (PASSED HERE)MR0 TO LOA0 PICK UP POINTER TO WHEN ROUTINEMR16I TO RTZE IF NO USER ROUTINE, EXITDATA CUIR1-.-1 REL DIST*IM(CMOPT-INTTAB) TO ADD1 UPDATE R1 TO POINT TO MUL/DIV ENTRYMR1 TO R1 SEE IF MULDIVIM(10) TO TAND1 BY LOOKING AT PROPER BITIM(4) TO RTZE IF NOT,  THEN SKIP*IM(0) TO MR15I SAVE A 0 TO INDICATE INFO IS THERED5 TO MR15I SAVE MUL/DIV REGSD4 TO MR15I DITTOIM(1) TO RTRA AND SKIPIM(2) TO MR15I ELSE STORE A 2 TO INDICATE NO MUL/DIV REGSR17 TO MR15I SAVE USER RETURNR12 TO MR15I SAVE SYSTEM'S R12R3 TO MR15I SAVE BACK POINTER FOR RELOADIM(-20) TO R14 SET FLAG TO KEEP INTERRUPTS OFFR0 TO R17 SET UP CORRECT 17R16I TO MR15 AND SAVE RETURNIM(1) TO RTRA NOTICE WE RETURN HERE WITH PC=17IM(CALL-1) TO ATRA RESET R16, SET PC=17, AND GO**RETURN FROM INTERRUPT PROCESSING*R17 TO R16 SET UP R16 TO .+1IM(0) TO D1 GOTO PC=16 FOR NOW;EXECUTE THIS INSTRUCTION TWICER15 TO R0 GET STACK POINTERIM(3) TO SUB0 BACK UP THE STACKMR0I TO R17 RESTORE USER R17MR0I TO R12 RESTORE SYSTEM R12MR0I TO R3 GET PTR TO D140/D141 FLAGR3 TO R0 SAVE IN R0 FOR FINAL LOADMR3I TO RTRA SEE IF SHOULD RELOAD D140 D141MR3I TO D140 RESTORE D140MR3I TO D141 RESTORE D141MR3I TO RTRA SEE IF MUL/DIVIDEMR3I TO D5 LOAD B REGMR3I TO D4 LOAD A REGCUIR2:IM(7) TO SUB0 BACK UP STACK POINTER FOR FINAL RETURNR0 TO R15 THIS IS NEW STACK POINTERIM(2) TO ADD0 SKIP TWO PROTECTED WORDSMR0I TO R1 GET C,Z,M BITSIM(-10) TO OR1 OR IN THIS INFO - ENABLE INTERRUPTS,  SET C & ZR1 TO R14 PUT IN R14MR0I TO R3 RESTORE R3MR0I TO R2 RESTORE R2MR0I TO R1 RESTORE R1MR0 TO R0 RESTORE R0IM(CALL-1) TO ATRA AND RETURN FROM POINT OF INTERRUPT (RESET R16 IMPLICITLY)**SPECIAL FUNCTIONS*CUIR1: R3 TO R0          SET UP R0 TO STACK       MR3I TO RTRA      RELOAD D140, D141 IF THERE       MR3I TO D140      RELOAD D140       MR3I TO D141      HERE       RE(CUIR2) TO RTRA**INTRET - ENTER IF NO INTERRUPT TO PROCESS*INTRET:R15 TO R0         GET STACK POINTER IN R0       RE(CUIR2) TO RTRA RESTORE INFO & RETURNendif of ^ModelCEJECT**ROUTINE TO INVOKE A USER 'WHEN' STATEMENT (Model C Only)*C U I R  STANDS FOR CALL USER INTERRUPT ROUTINE**ENTER AT CUIR+1 FOR D140 INTERRUPT*if ModelC-ModelD  Model C onlyCUIR:IM(2) TO MR12D STORE A 2 TO INDICATE NO D140 INFORMATION SAVEDMR16I TO R1 PICK UP POINTER TO CONFIG TABLEDATA CONTAB+INTTAB POINTER TO INTERRUPT TABLEMR1 TO ADD0 ADD IN BASE OF INTERRUPT TABLE TO WHEN NUMBER (PASSED HERE)MR0 TO LOA0 PICK UP POINTER TO WHEN ROUTINERE(CUIR1) TO RTZE IF NO USER ROUTINE, EXIT*IM(CMOPT-INTTAB) TO ADD1 UPDATE R1 TO POINT TO MUL/DIV ENTRYMR1 TO R1 SEE IF MULDIVIM(10) TO TAND1 BY LOOKING AT PROPER BITIM(4) TO RTZE IF NOT,  THEN SKIP*D4 TO MR12D SAVE MUL/DIV REGSD5 TO MR12DIM(0) TO MR12D SAVE A 0 TO INDICATE INFO IS THEREIM(1) TO RTRA AND SKIPIM(2) TO MR12D ELSE STORE A 2 TO INDICATE NO MUL/DIV REGSR15 to MR12D save R15 in case it's in useR17 TO MR12D SAVE USER RETURNIM(-20) TO R14 SET FLAG TO KEEP INTERRUPTS OFFR0 TO R17 SET UP CORRECT 17IM(CALL-1) TO ATRA SAVE RETURN IN D10, RESET R16, SET PC=17, AND GO**RETURN FROM INTERRUPT PROCESSING*R17 TO R16 SET UP R16 TO .+1IM(0) TO D1 GOTO PC=16 FOR NOW;EXECUTE THIS INSTRUCTION TWICER12I TO ATNV BACK UP STACK POINTERMR12I TO R17 RESTORE USER R17MR12I TO R15 RESTORE R15MR12I TO RTRA RELOAD D4567 IF NECESSARYMR12I TO D5 RELOAD B REGISTER (AND ZERO A REGISTER)MR12I TO D4 RELOAD A REGISTERim(1) to RTRA skip over error recovery*CUIR1: R12I to ATNV if no user routine, back up stack pointerMR12I TO RTRA RELOAD D140/D141 IF NECESSARYMR12I TO D140 RELOAD CHANNELMR12I TO D141 RELOAD PORT*CUIR2:...IN3:...im(1) to rtra      patched by compiler to be MR12I to d60 if swap includedim(0) to rtra      patched by compiler to be MR12I to d61 if swap includedMR12I TO R1 GET C,Z,M BITSIM(-10) TO OR1 OR IN THIS INFO - ENABLE INTERRUPTS,  SET C & ZR1 TO R14 PUT IN R14MR12I TO R3 RESTORE R3MR12I TO R2 RESTORE R2MR12I TO R1 RESTORE R1MR12I TO R0 RESTORE R0IM(CALL-1) TO ATRA AND RETURN FROM POINT OF INTERRUPT (RESET R16 ON THE WAY)*INTRET: ... RETURN HERE IF NO INTERRUPT TO PROCESSR12I to ATNV back up stack pointerre(CUIR2) to RTRA and return from interruptendif of ModelC-ModelD*TTL INTERRUPT PROCESSING ROUTINES - MODELS D AND LATER**THE FOLLOWING CODE IS ENTERED TO PROCESS AN INTERRUPT IN XPL.**THE IMPORTANT REGISTERS ARE SAVED ON THE PUSH DOWN STACK,  THE PROCESSOR*STATUS WORD IS INTERROGATED TO DETERMINE WHICH DEVICE CAUSED THE*INTERRUPT,  AND THE APPROPRIATE 'WHEN' STATEMENT IS INVOKED. **Begin by saving all necessary registers,  selecting page 0, and*switching back to pc = 17**if ModelD    VERSION USING PRIORITY ENCODER (Model D & later)MR12     to MR12D   decrement stack pointer in case we interrupted out of a returnR17      to MR12D   save user PCD11      to MR12D   save page pointerR15      to MR12D   save r15R3       to MR12D   save R3R2       to MR12D   save R2R1       to MR12D   save R1R0       to MR12D   save R0D1       to MR12D   save C, Z, and MD4       to MR12D   save mul/div infoD5       to MR12D   as wellD61      to MR12D   save mam/mal pointersD60      to MR12D   as well**switch back to r17 now to save time later*IM(0)    to D11     select page 0IM(-20)  to R14     set r14 to keep interrupts offR16I     to R17     set up r17 for usIM(1)    to RTRA    fast way to skip instruction after switchingIM(-20)  to D1      disable interrupts, switch to PC = 17IM(call) to R16     restore r16 now**READ THE PROCESSOR STATUS WORD,  SEE WHICH DEVICE IS REQUESTING AN INTERRUPT,*(USING PRIORITY ENCODER), THEN CALL THE APPROPRIATE USER ROUTINE IF IT EXISTS.*D1 TO D2   READ STATUS WORD,  WRITE TO PRIORITY ENCODERD2 TO RTRA BRANCH ON WHICH BIT IS SET*PCI  to  RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTPCI  to  RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTPCI  to  RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTPCI  to  RTRA PERFORM JUMPDATA INTRET-.-1 REL DISTPCI  to  RTRA PERFORM JUMPDATA B04INT-.-1 REL DIST FOR BDB4PCI  to  RTRA PERFORM JUMPDATA B05INT-.-1 REL DIST FOR BDB5PCI  to  RTRA PERFORM JUMPDATA B06INT-.-1 REL DIST FOR BDB6PCI  to  RTRA PERFORM JUMPDATA B07INT-.-1 REL DIST FOR BDB7PCI  to  RTRA PERFORM JUMPDATA B08INT-.-1 REL DIST FOR BDB8PCI  to  RTRA PERFORM JUMPDATA B09INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D140PCI  to  RTRA PERFORM JUMPDATA B10INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D54PCI  to  RTRA PERFORM JUMPDATA B11INT-.-1 SPECIAL ROUTINE IN THIS SEGMENT FOR D55PCI  to  RTRA PERFORM JUMPDATA INTRET-.-1 REL DIST FOR BDB12PCI  to  RTRA PERFORM JUMPDATA B13INT-.-1 REL DIST FOR BDB13PCI  to  RTRA PERFORM JUMPDATA B14INT-.-1 REL DIST FOR BDB14PCI  to  RTRA PERFORM JUMPDATA B15INT-.-1 REL DIST FOR BDB15EJECT**SPECIAL SUBROUTINES TO USE THE PRIORITY ENCODER**Note: Model D does not save current d140 contents*B09INT:... ROUTINE FOR D140 COMMUNICATION PROCESSORD143 TO D2 GET BIT WORD WHICH SELECTS CARDD2 TO LOA0 AND GET 2 X CARD #R0 TO ADD0 COMPUTE 4 X CARD #R0 TO D140 AND SELECT THE CARD IN QUESTIOND144 TO D2 GET BIT WORD TO SELECT PORT ON THIS CARDD2 TO R1 GET THIS NUMBER X 2R0 TO SHRA1 SHIFT RIGHT (divide by 2),  AND THEN ADD 4 X CARDR1 TO D140 AND SELECT THE PORT IN QUESTIONIM(11) TO R0 TRY TO CALL WHEN STATEMENT #9PCI TO RTRA AND CONTINUE PROCESSING WITH MAIN ROUTINEDATA CUIR+1-.-1 ENTER CUIR AT CUIR+1B10INT:... INTERRUPTS FROM D54 - INVOKE WHEN STATEMENTD54 TO D2 GET BIT WORD FROM D54D2 TO R0 GET 2X BIT #IM(20) TO SHRA0 DIV BY 2 AND ADD IN BASE OF 16PCI TO RTRA AND INVOKE USER ROUTINEDATA CUIR-.-1 RELATIVE DISTANCEB11INT:... INTERRUPTS FROM D55 - INVOKE WHEN STATEMENTD55 TO D2 GET BIT WORD FROM D55D2 TO R0 GET 2X BIT #PCI TO SHRA0 divide by 2, ADD IN BASE OF 32DATA 40PCI TO RTRA AND INVOKE USER ROUTINEDATA CUIR-.-1 RELATIVE DISTANCEEJECT**DEVICE INTERRUPT ROUTINES:**THE FOLLOWING ROUTINES ARE ENTERRED IN RESPONSE TO A CERTAIN BIT ON THE*BDB LINES DURING A READ OF DEVICE 1.**EACH ROUTINE:*  ACKNOWLEDGES THE INTERRUPT,  BY READING/WRITING THE APPROPRIATE DEVICE*  THEN PROCEEDS TO CALL A USER INTERRUPT ROUTINE (WHEN) IF IT IS THERE .**Note: Put d50 first because it is a longer routine**D50 USER TERMINAL*B06INT:D51 TO R0 GET STATUS FROM TERETYPEIM(2) TO AND0 SEE IF RCVD CHARACTERRE(TTIINT) TO RTNZ IF BIT IS SET,  THEN RECEIVED CHARACTERIM(0) TO D51 CLEAR THE XMIT DONE INTERRUPTIM(1) TO R0 AND TRY TO CALL USER ROUTINE #1RE(CUIR) TO RTRA CALL USER ROUTINETTIINT:IM(2) TO R0 TRY TO CALL USER ROUTINE #2D50 TO R1 AND GET CHARACTER & CLEAR INTERRUPTPCI TO R2 GET POINTER TO RCVD CHARACTER ADDRESSDATA CONTAB+RCVPTR POINTER TO RAM POINTERMR2 TO R2 PICK UP POINTER TO RCVDCHARACTER LOCATIONR1 TO MR2 STORE RCVD CHARACTERRE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**PROCESS BDB BITS FOR USER DEVICES:*B15INT:IM(17) TO R0 TRY TO CALL USER ROUT       RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THEREB14INT:IM(16) TO R0 TRY TO CALL USER ROUTINE 14       RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**D03 REAL TIME CLOCK*B08INT:IM(0) TO D3 ACKNOWLEDGE D3 INTERRUPTIM(7) TO R0 CALL USER ROUTINE #7RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**D115 COMMUNICATIONS PROCESSOR*B13INT:IM(15) TO R0 CALL USER ROUTINE #13RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**D136 REAL-TIME CLOCK*B05INT:IM(0) TO D136 ACKNOWLEDGE D136 INTERRUPTIM(12) TO R0 CALL USER ROUTINE #10RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**D137 CLOCK/CALENDAR*B04INT:IM(13) TO R0 CALL WHEN D137INT (#11)RE(CUIR) TO RTRA AND CALL USER ROUTINE IF THERE**Note: put d16 timer last since it is the one we want to be fast**D16 TIMER*B07INT:D16 TO ATNV READ SCT TO CLEAR THE FLAGIM(5) TO R0 TRY TO CALL USER ROUTINE #5*EJECT**ROUTINE TO INVOKE A USER 'WHEN' STATEMENT (Model D & later):*C U I R  STANDS FOR CALL USER INTERRUPT ROUTINE*CUIR:...PCI   TO    R1        PICK UP POINTER TO CONFIG TABLEDATA  CONTAB+INTTAB   POINTER TO INTERRUPT TABLEMR1   TO    ADD0      ADD IN BASE OF INTERRUPT TABLE TO WHEN NUMBER (PASSED HERE)MR0   TO    TLOA0      SEE IF WHEN POINTER IS NONZERO**CALL THE USER'S ROUTINE IF IT EXISTS:*MR0   TO    ATNZ      CALL USER ROUTINE IF IT EXISTS**RETURN FROM INTERRUPT PROCESSING*INTRET:...R12I    TO ATNV       PRE-INCREMENT STACK POINTERMR12I   to D60        restore mam/malMR12I   to D61MR12I   to D5         restore mul/divMR12I   to D4MR12I   to R0         get czmIM(-10) to OR0        set bits to enable interrupts, restore CZMR0      to R14        set up in R14MR12I   to R0         restore R0MR12I   to R1         restore R1MR12I   to R2         restore R2MR12I   to R3         restore R3MR12I   to R15        restore r15**Jump to low core to set page bits & restore r17.   The low core*code is on every page*IM(c.pgsw-zero) to atraendif of ModelDZ.IN1: DATA 0         END OF INTERRUPT SEGMENT, NO PATCHES