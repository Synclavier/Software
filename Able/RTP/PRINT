TTL PRINT ROUTINES - CHAR, STRING, NUMBER, OCTAL, CRLF**PC:  USED TO PRINT A CHARACTER TO A D40/D50 TYPE DEVICE (INTERNAL ROUTINE)**CALLED WITH:*  AC2=INDICATOR FOR DESTINATION DEVICE (0=D40, 1=D50)*  AC3=CHARACTER TO PRINT**AC0 IS USED FOR STATUS CHECKS.  ALL OTHER REGISTERS ARE PRESERVED.*R.PC:DATA Z.PC POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifA.PC:IM(0) TO ADD2     SEE IF R2 IS =0 OR =1RE(PCD40) TO RTZE      IF =0 THEN IS FOR D40PCI TO R0              SEE IF REDIRECTED OUTPUTDATA CONTAB+REDRCTMR0 TO LOA0            GET FLAG FROM CONFIGURATIONPCI TO AND0            EXTRACT OUTPUT REDIRECTION BITSDATA 377PCI TO RTZE            IF =0 THEN D50DATA PCD50-.-1PCI TO R0              PICK UP POINTER TO COMPUTER AND MUSIC OPTIONS WORDDATA CONTAB+CMOPTMR0 TO R0              PICK UP COMPUTER AND MUSIC OPTIONS WORDIM(20) TO TAND0        MAKE SURE THERE'S A D40 IN THE SYSTEMRE(PCD40) TO RTNZ      IF THERE IS, GO AHEAD AND OUTPUT THIS CHARACTERif ModelCR12I to ATNV           back up stack pointerendifRETURN to ATRA         and return to callerEJECT**CODE FOR D40 OUTPUT*PCD40:D1 TO R0         SEE IF INTERRUPTS ONIM(10) TO TAND0RE(A4.PC) TO RTNZ      IF ON, SKIP CONTROL-S CHECK**CHECK FOR CONTROL-S BEING SENT*D41 TO R0              SEE IF THERE IS AN INPUT CHARACTERIM(2) TO TAND0RE(A4.PC) TO RTZE      NONE-SKIP READ**LOOP WHILE CHARACTER=CONTROL-S*D40 TO R0              GET THE CHARACTERPCI TO AND0            MASK PARITYDATA 177IM(23) TO TSUB0        SEE IF CONTROL-SIM(5) TO RTNZ          IF NOT, SKIP AHEADD40 TO R0              GET NEXT CHARACTERPCI TO AND0            MASKDATA 177IM(21) TO TSUB0        CHECK FOR CONTROL QIM(-5) TO RTNZ         IF NOT, GO BACK**CHECK FOR BREAK*IM(0) TO TSUB0         CHECK FOR BREAKRE(A4.PC) TO RTNZ      SKIP IF NOT BREAK**DETECTED A BREAK*PCI to R0              get pointer to clock speeddata CONTAB+CMOPTMR0 to R0              pick up clock speed wordim(7) to AND0          extract speed bits - assume only zero or one for nowim(3) to RTZE          skip for 100 HzPCI to R0              set up for 200 Hzif ^ModelCdata 74+2              (add two extra writes to synchronize)im(2) to RTRA          skip 100 Hz set upPCI to R0              set up for 100 Hzdata 36+2              (add two extra writes to synchronize)IM(0) TO D3            WAIT 5 MSIM(1) TO SUB0          COUNT HOW LONGIM(-3) TO RTNZ         LOOP IF NOT DONE YETendif of ^ModelCif ModelCdata 74+2-1            (add two extra writes to synchronize)im(1) to RTRA          skip 100 Hz set upim(36+2-1) to R0       (add two extra writes to synchronize)R0 to D10              wait 300 msim(0) to D3            wait 5 msendif of ModelC*IM(0) TO R0JUMP TO PROC           CALL BREAK ROUTINED4.PC:DATA 0           L.BRK*A4.PC:D41 TO R0        CHECK FOR XMTR BUFFER EMPTYIM(4) TO TAND0PCI TO RTZE            NO- TRY AGAINDATA PCD40-.-1R3 TO D40              WRITE OUT THE CHARACTERif ModelCR12I to ATNV           back up stack pointerendifRETURN to ATRA         and return to callerEJECT**CODE FOR D50 OUTPUT*PCD50:D1 TO R0         SEE IF INTERRUPTS ONIM(10) TO TAND0PCI TO RTNZ            IF ON, SKIP CONTROL-S CHECKDATA A5.PC-.-1**CHECK FOR CONTROL-S BEING SENT*D51 TO R0              SEE IF THERE IS AN INPUT CHARACTERIM(2) TO TAND0PCI TO RTZE            NONE-SKIP READDATA A5.PC-.-1**LOOP WHILE CHARACTER=CONTROL-S*D50 TO R0              GET THE CHARACTERPCI TO AND0            MASK PARITYDATA 177IM(23) TO TSUB0        SEE IF CONTROL-SRE(CHKB50) TO RTNZ     SKIP IF NOT CONTROL-SD50 TO R0              GET NEXT CHARACTERPCI TO AND0            MASK ITDATA 177IM(1) TO RTNZ          CHECK FOR BREAKIM(2) TO R2            FLAG A BREAKIM(21) TO TSUB0        CHECK FOR CONTROL-QIM(-7) TO RTNZ         IF NOT, LOOP BACK**CHECK FOR BREAK*IM(2) TO TSUB2         CHECK IF BREAK IN CTRL-S/CTRL-Q LOOPRE(CHKB50) TO RTNZ     NO, SKIPIM(1) TO R2            RESTORE R2IM(2) TO RTRA          AND PROCESS THE BREAKCHKB50:IM(0) TO TSUB0  CHECK FOR BREAKRE(A5.PC) TO RTNZ      SKIP IF NOT BREAKEJECT**DETECTED A BREAK*PCI to R0              get pointer to clock speeddata CONTAB+CMOPTMR0 to R0              pick up clock speed wordim(7) to AND0          extract speed bits - assume only zero and one for nowim(3) to RTZE          skip for 100 HzPCI to R0              set up for 200 Hzif ^ModelCdata 74+2              (add two extra writes to synchronize)im(2) to RTRA          skip 100 Hz set upPCI to R0              set up for 100 Hzdata 36+2              (add two extra writes to synchronize)IM(0) TO D3            WAIT 5 MSIM(1) TO SUB0          COUNT HOW LONGIM(-3) TO RTNZ         LOOP IF NOT DONE YETendif of ^ModelCif ModelCdata 74+2-1            (add two extra writes to synchronize)im(1) to RTRA          skip 100 Hz set upim(36+2-1) to R0       (add two extra writes to synchronize)R0 to D10              wait 300 msim(0) to D3            wait 5 msendif of ModelC*IM(0) TO R0JUMP TO PROC           CALL BREAK ROUTINED5.PC:DATA 0           L.BRK*A5.PC:D51 TO R0        CHECK FOR XMTR BUFFER EMPTYIM(4) TO TAND0PCI TO RTZE            NO- TRY AGAINDATA PCD50-.-1R3 TO D50              WRITE OUT THE CHARACTERif ModelCR12I to ATNV           back up stack pointerendifRETURN to ATRA         and return to caller*Z.PC:DATA D5.PC        BEGIN PATCH LISTDATA L.BRKDATA D4.PCDATA L.BRKDATA 0                 END OF SEGMENTEJECT**PCH:  PRINT ONE CHARACTER (USER ROUTINE)*  *CALLED WITH:*  AC0=CHARACTER*  AC2=0 FOR D40, 1 FOR D50*R.PCH:DATA Z.PCH POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifR0 TO R3 MOVE CHARACTER TO PRINT TO R3 FOR R.PCPCI TO R0 get address of PC routineA.PCH:DATA 0 PATCHED TO POINT TO INTERNAL PRINT CHAR ROUTINEim(A.PC-R.PC-1) to ADD0 compute pointer to start of PC routineR0 to ATRA and go there*Z.PCH:DATA A.PCH BEGIN PATCH LISTDATA L.PCDATA 0 END OF SEGMENT***SPR:  STRING PRINT ROUTINE**OBJECT CODE:*  SET UP AC0 POINTING TO ARRAY*  SET UP AC2 CONTAINING ENCODED DEVICE # TO SEND TO*  JSR SPRINT*R.SPR:DATA Z.SPR POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGSR0 TO R4 MOVE STRING POINTER TO R4MR4I TO LOA1 GET # OF CHARS TO PRINTRE(A.SPR) TO RTZE IF ZERO, THEN JUST RETURNC.SPR:MR4I TO R3 GET DATA TO PRINTJUMP TO PROC SUB CALL TO PRINT CHARACTERG.SPR:DATA 0 PATCHED UP TO POINT TO R.PCIM(1) TO SUB1 SEE IF DONE PRINTINGRE(A.SPR) TO RTZE IF DONEim(0) to BSOR3 rotate data to lower halfJUMP TO PROC CALL PC TO PRINTH.SPR:DATA 0 WILL POINT TO R.PCIM(1) TO SUB1 SEE IF DONE WITH PRINTRE(C.SPR) TO RTNZ GO BACK FOR MORE IF MOREA.SPR:IM(LREG) TO ATRA RESTORE REGS AND RETURN*Z.SPR:DATA G.SPR BEGIN PATCH LISTDATA L.PCDATA H.SPRDATA L.PCDATA 0 END OF SEGMENTEJECT**NPR:  PRINT A FIXED POINT (16 BIT NUMBER) ON THE TERMINAL**OBJECT CODE:*  AC0=FIXED POINT NUMBER TO PRINT*  AC2=CODED DEVICE NUMBER TO LOAD OFF TO*  JSR NPRINT*R.NPR:DATA Z.NPR POINT TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRAR0 TO TADD0 SEE IF MSB=1RE(A.NPR) TO RTNC IF NOT, THEN POSITIVE NUMBERPCI TO R3 GET A - SIGN TO PRINTDATA 55 MINUS SIGNR0 TO LCM0 NEGATE NUMBERIM(1) TO ADD0 BY THISRE(B.NPR) TO RTRA AND SKIPA.NPR:PCI TO R3 GET A SPACE, IF NO MINUS SIGNDATA 40B.NPR:R0 TO R1 SAVE NUMBER TO PRINTJUMP TO PROC JSR TO PC TO PRINT SPACE OR -K.NPR:DATA 0 WILL POINT TO PCC.NPR:R17 TO R0 GENERATE POINTER TO POWERS TABLEIM(D.NPR-.) TO ADD0 GENERATE ABSOLUTE POINTERR0 TO R4 SAVE PTR TO NUMBER LISTF.NPR:MR4 TO TLOA0 SEE IF END OF LISTRE(G.NPR) TO RTZE IF ZERO, THEN DONEPCI TO R3 START WITH ASCII ZERODATA 60 ASCII ZEROI.NPR:MR4 TO TSUB1 SEE IF WE CAN SUBTRACTRE(H.NPR) TO RTNC IF NOT, THEN RESULT IS ZEROMR4 TO SUB1 SUBTRACTIM(1) TO ADD3 INCREMENT DIGIT COUNTRE(I.NPR) TO RTRA AND GO BACKH.NPR:JUMP TO PROC CALL PCN.NPR:DATA 0 WILL POINT TO R.PCR4I TO ATNV INCREMENT NUMBER POINTERRE(F.NPR) TO RTRA AND GO BACK TO PRINT NEXT DIGITG.NPR:IM(LREG) TO ATRA LOAD REGS AND RETURN*D.NPR:DATA  23420 10000 DIVISOR LISTDATA 1750 1000DATA 144 100DATA 12 10DATA 1 1DATA 0*Z.NPR:DATA K.NPR BEGIN PATCH LISTDATA L.PC DATA N.NPRDATA L.PCDATA 0 END OF SEGMENTEJECT**OPR:  PRINT NUMBER IN OCTAL**OBJECT CODE:*  SET UP AC0 CONTAINING NUMBER*  SET UP AC2 CONTINING 0 FOR D40, 1 FOR D50*  CALL OPR*R.OPR:DATA Z.OPR POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKR0 TO R1 MOVE NUMBER TO R1 FOR R.NPR ROUTINER17 TO R0 FIND OUT WHERE WE ARE TO GENERATE POINTER TO LISTIM(B.OPR-.) TO ADD0 ADD IN RELATIVE DISTANCE TO GENERATE POINTERR0 TO R4 AND PUT THAT IN R4 FOR COMMON ROUTINEPCI TO R0 GET POINTER TO R.NPR ROUTINEC.OPR:DATA 0 PATCHED UP TO BE R.NPRIM(F.NPR-R.NPR-1) TO ADD0 COMPUTE POINTER TO F.NPRR0 TO ATRA AND ENTER THE R.NPR ROUTINE TO PERFORM THE PRINT CALCULATION*B.OPR:DATA 100000 DIVISOR LIST FOR OCTAL PRINTDATA 10000DATA 1000DATA 100DATA 10DATA 1DATA 0*Z.OPR:DATA C.OPR END OF SEGMENT, BEGIN PATCH LISTDATA L.NPRDATA 0 END OF SEGMENT***PRI:  PRINT CR-LF**CALLED WITH:*  AC2=DEVICE TO PRINT CR-LF TO*R.PRI:DATA Z.PRI POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(15) TO R3 GET A CRJUMP TO PROC CALL PRINT CHARA.PRI:DATA 0 POINT TO R.PCPCI TO R1 DETERMINE NUMBER OF NULLS TO PRINTDATA CONTAB+STYPEPCI TO R3 SEE IF WE ARE DIRECTING OUTPUTDATA CONTAB+REDRCTMR3 TO LOA3 PICK UP REDIRECTION WORDPCI TO AND3 EXTRACT OUTPUT REDIRECTION BITSDATA 377IM(1) TO RTNZ IF REDIRECTED, THEN USE STYPE FOR PRINTERR2 TO SUB1 CORRECT FOR 0=SEND, 1=PRINTMR1 TO R1 PICK UP NUMBER OF NULLS TO PRINTPCI TO AND1 MASK DOWN (CEW - 10 MAR 1981)DATA 377IM(12) TO R3 GET A LINE FEEDB.PRI:...JUMP TO PROC CALL PRINT CHARC.PRI:DATA 0 POINT TO R.PCIM(0) TO R3 NOW FOR THE NULL CHARACTERSIM(1) TO SUB1 DECREMENT COUNT RE(B.PRI) TO RTPL GO BACK AN PRINT NULL IF REQUIREDif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and return to caller*Z.PRI:DATA A.PRI BEGIN PATCH LISTDATA L.PC  PRINT CHARDATA C.PRI CDATA L.PC  PRINT CHARDATA 0 END OF SEGMENT