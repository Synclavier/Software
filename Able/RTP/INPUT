TTL TERMINAL INPUT ROUTINES**SEQUENCE FOR NUMERIC FROM TERMINAL:**  ROUTINE R.IPR IS CALLED TO PRIME THE INPUT BUFFER.   THIS ROUTINE SCANS*    A LINE OF INPUT FROM TERMINAL,  STORES IT IN THE BUFFER, AND RETURNS.**  ROUTINE R.FIN STARTS CONVERTING DIGITS INTO FLOATING POINT REPRESENTATIONS*    AND RETURNS SAME IN REGISTERS 0-1* *  ROUTINE R.IDN IS CALLED TO MAKE SURE THAT ALL OF THE NUMERIC INPUT WAS*    SCANNED.*R.FIN:DATA Z.FIN POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSIM(0) TO R4 ZERO INITIAL VALUEIM(0) TO R5IM(0) TO R6 ZERO OUT SIGN FLAGIM(0) TO R7 ZERO OUT POWER COUNT/DECIMAL POINT FLAGJUMP TO PROC PERFORM SUB CALLC.FIN:DATA 0 POINTER TO GET CHARPCI TO TSUB0 SEE IF FIRST CHARACTER IS A MINUS SIGNDATA 55 MINUS SIGNRE(D.FIN) TO RTNZ IF NOT, THEN CONTINUEPCI TO R6 SET SIGN BIT IN R6DATA 100000E.FIN:...JUMP TO PROC PERFORM SUB CALLF.FIN:DATA 0 POINTER TO GET CHARD.FIN:PCI TO TSUB0 CHECK FOR DECIMAL POINTDATA 56 CHECK FOR PERIODRE(G.FIN) TO RTNZ IF NOT, THEN CHECK FOR DIGITR7 TO LOA1 SEE IF ONE ALREADYIM(2) TO RTZE IF NOT, THEN OKPCI TO ATRA JUST GO TO INPUT ERROR IF DOUBLEH.FIN:DATA 0 PATCH TO IERIM(1) TO R7 SET UP R7 TO INDICATE DECIMAL POINT FOUNDRE(E.FIN) TO RTRA AND GO BACK, GET NEXT CHARACTER, CONTINUE**CHECK FOR PROPER DIGIT*G.FIN:PCI TO SUB0 SUBTRACT ASCII ZERODATA 60RE(I.FIN) TO RTNC IF NO CARRY,  THEN LESS THAN 60 = NON-DIGITIM(12) TO TSUB0 SEE IF 10 OR GREATERRE(I.FIN) TO RTRC IF CARRY, >=10,  AND NON-DIGITJUMP TO PROC PERFORM SUB CALL TO FLOAT THE DIGITJ.FIN:DATA 0 FLOAT ROUTINER0 TO R10 SAVE DIGIT HERER1 TO R11 DITTOR4 TO R0 VET CURRENT VALUER5 TO R1PCI TO R2 GET A 10.0000 = MULTIPLY BYDATA 050000 FP 10PCI TO R3 AND XPONENT PARTDATA 000104JUMP TO PROC PERFORM SUB CALK.FIN:DATA 0 MULTIPLY ROUTINER10 TO R2 GET DIGIT TYPEDR11 TO R3 SECOND PARTJUMP TO PROC SUB CALL AGAINT.FIN:DATA 0 PATCHED TO ADD ROUTINER0 TO R4 SAVE NEW DIGITR1 TO R5 DITTOR7 TO LOA2 CHECK FOR EARLIER DECIMAL POINTIM(2) TO RTZE IF NOT,  THEN KEEPIM(1) TO ADD2 INCREMENT DECIMAL COUNTR2 TO R7 AND RESTOREPCI TO RTRA AND GO BACK AND HANDLE NEXT CHARACTERDATA E.FIN-.-1 RELATIVE DISTANCEEJECT**DONE WITH FLOATING INPUT:*CHECK FOR PROPER TERMINATION (COMMA OR RETURN)*CHECK DIGIT COUNT - DIVIDE IF SHOULD*I.FIN:PCI TO TADD0 HAVING SUBTRACTED 60,  CHECK FOR RETURNDATA 60-15RE(M.FIN) TO RTZE IF SO,  THEN OK = RETURNIM(60-54) TO TADD0 CHECK FOR COMMA ALSORE(M.FIN) TO RTZE IF SO,  THEN OK RETURNPCI TO ATRA ELSE HANDLE INPUT FORMAT ERR N.FIN:DATA 0 PATCHED FOR IERM.FIN:R4 TO R0 GET FINAL VALUE IN R0R5 TO R1 DITTOR7 TO LOA2 CHECK FOR DPRE(P.FIN) TO RTZE IF ZERO,  THEN NO DP = ALL SETQ.FIN:IM(1) TO SUB2 DECREMENT ITRE(P.FIN) TO RTZE IF GOT TO ZERO, DONE WITH ITR2 TO R7 RESTORE POINTPCI TO R2 GET 10DATA 050000PCI TO R3 DITTODATA 000104JUMP TO PROC CALL DIVIDE - DIVIDE NUMBER BY 10S.FIN:DATA 0 POINTERR7 TO R2 GET DIGIT COUNT AGAINRE(Q.FIN) TO RTRA AND GO BACKP.FIN:R6 TO OR0 OR IN SIGN BITIM(LREG) TO ATRA AND RETURN*Z.FIN:DATA C.FIN BEGIN PATCH LISTDATA L.GTC GET CHARDATA F.FIN FDATA L.GTC GET CHARDATA H.FIN HDATA L.IER INPUT ERRORDATA J.FIN JDATA L.FLO FLOATDATA K.FIN KDATA L.FPM FLOATING MULDATA N.FIN NDATA L.IER INPUT ERRORDATA S.FIN SDATA L.FPD DIVIDEDATA T.FIN TDATA L.FPA ADDDATA 0 END OF SEGMENTEJECT**FIXED POINT INPUT ROUTINE**THE ROUTINE R.FXI IS USED TO CONVERT TERMINAL INPUT INTO A FIXED*POINT NUMBER.**NUMBER IS RETURNED IN AC0, WITH AN EXIT TO IER IF AN ERROR IS FOUND*R.FXI:DATA Z.FXI POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKIM(0) TO R4 ZERO SIGN FLAGIM(0) TO R5 ZERO OUT AND INITIAL VALUEJUMP TO PROC PERFORM SUB CALL TO GET CHARACTERB.FXI:DATA 0 TO GETCPCI TO TSUB0 CHECK FOR LEADING MINUS SIGNDATA 55RE(C.FXI) TO RTNZ IF NOT,  THEN SKIPIM(1) TO R4 SET FLAG IN R4D.FXI:...JUMP TO PROC PERFORM SUB CALLE.FXI:DATA 0 PATCHED GETCC.FXI:PCI TO SUB0 GET DIGITDATA 60RE(F.FXI) TO RTNC IF NO CARRY, <60 = NON DIGITIM(12) TO TSUB0 CHECK FOR >12RE(F.FXI) TO RTRC IF >=12,  THEN TOO BIGR5 TO R1 GET CURRENT VALUER1 TO ADD1 TIMES 2R1 TO R2 MOVE HERER1 TO ADD1 TIMES 4R1 TO ADD1 TIMES 8R1 TO ADD2 GENERATES TIMES 10R0 TO ADD2 ADD IN NEW DIGITR2 TO R5 SAVE NEW VALUERE(D.FXI) TO RTRA GO BACK FOR MOREF.FXI:PCI TO TADD0 CHECK FOR RETURNDATA 60-15RE(G.FXI) TO RTZE IF SO,  THEN OKIM(60-54) TO TADD0 CHECK FOR COMMARE(G.FXI) TO RTZE IF SO,  THEN BLEEPPCI TO ATRA ELSE INPUT FORMAT ERRORH.FXI:DATA 0 PATCHED TO IERG.FXI:R5 TO R0 GET ANSWER IN R0R4 TO LOA1 CHECK SIGN BITIM(2) TO RTZE IF SIGN IS PLUS, LEAVE ITR0 TO LCM0 ELSE COMPLEMENTIM(1) TO ADD0 ELSE INCREMENT/NEGATEIM(LREG) TO ATRA RESTORE REGS AND RETURN*Z.FXI:DATA B.FXI BEGIN PATCH LISTDATA L.GTC GET CHARDATA E.FXI EDATA L.GTC GET CHARDATA H.FXI HDATA L.IER INPUT ERRORDATA 0 END OF SEGMENTEJECT**STRING INPUT:*  ROUTINE IS PASSED (IN R0) A POINTER TO A LOCATION OF RAM.  ROUTINE*  INPUTS A STRING OF CHARACTERS INTO THAT SECTION,  TERMINATED WITH CR.*R.SIN:DATA Z.SIN POINTER TO END OF SEGMENTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKIM(-20) TO D1 DISABLE INTERRUPTS DURING LINPUTM.SIN:R0I TO R4 SAVE BASE POINTER FOR RESTART, INCREMENT PAST HEADERPCI TO R3 AND SAVE BYTE COUNTER TO 128DATA -200 WHEN GETS TO ZERO, DONEC.SIN:IM(0) TO R1 ZERO R1 TO INDICATE NO SAVED UP BYTED51 TO R2 CHECK STATUS OF TERMINALIM(2) TO AND2 CHECK FOR CHARACTER IN BUFFER (LEFT FROM BEFORE)RE(D.SIN) TO RTZE IF NOT, THEN SKIP AHEADD50 TO R2 GET CHARACTER - SPECIAL CHECK FOR CONTROL SPCI TO AND2 MASK OFF PARITYDATA 177IM(23) TO TSUB2 CHECK FOR CONTROL SRE(K.SIN) TO RTZE SKIP READ OF NEXT CHARACTER IF CONTROL S RECEIVEDD.SIN:D50 TO R2 GET NEXT CHARACTERK.SIN:PCI TO AND2 EXTRACT CHARACTER INFORMATIONDATA 177 7 BITS OF ASCII DATARE(N.SIN) TO RTNZ SKIP IF NOT BREAKR0 TO R5 SAVE MEMORY POINTERIM(0) TO R0 BREAK RECEIVEDJUMP TO PROC CALL BREAK ROUTINE (SAVE ACCUMULATORS)O.SIN:DATA 0 PATCH TO L.BRKR5 TO R0 RESTORE MEMORY POINTERRE(D.SIN) TO RTRA AND IGNOREN.SIN:IM(23) TO TSUB2 CHECK FOR CONTROL-SPCI TO RTZE ENTER ROUTINE TO HANDLE CONTROL-SDATA X.SIN-.-1IM(21) TO TSUB2 CHECK FOR CONTROL-Q RE(D.SIN) TO RTZE IGNORE (MEANS SOMEONE LOST A CONTROL-S)**CHECK FOR SPECIAL CHARACTERS*W.SIN:IM(33) TO TSUB2 CHECK FOR ESCAPE CHARACTER (VT100 CURSOR KEYS)RE(I.SIN) TO RTNZ SKIP AHEAD IF NOTD50 TO R2  SKIP OVER BRACKETD50 TO R2  GET A, B, C, DIM(3) TO AND2 MASK TO 1 FOR A, 2 FOR B, 3 FOR C, 0 FOR DR2 TO ADD2 SHIFT LEFTR2 TO RTRA SKIP AHEAD THROUGH TABLE IM(32) TO R2 BACK CURSOR TO CONTROL ZRE(I.SIN) TO RTRA SKIP AHEADIM(36) TO ADD2 CONVERT '2' (A) TO "40" (UP ARROW TO SPACE)RE(I.SIN) TO RTRA SKIP AHEADIM(6) TO ADD2 CONVERT '4' (B) TO "12" (DOWN ARROW TO LINE FEED)RE(I.SIN) TO RTRA SKIP AHEADIM(32) TO ADD2 CONVERT '6' (C) TO "40" (RIGHT ARROW TO SPACE)I.SIN:IM(13) TO TSUB2 CHECK FOR UP ARROW FROM ADM3IM(1) TO RTNZ SKIP IF NOTIM(25) TO ADD2 CONVERT "13" TO "40" (SPACE) TO AVOID SCREEN EDITINGIM(10) TO TSUB2 CHECK FOR BACK SPACEIM(1) TO RTNZ SKIP AHEAD IF NOTIM(22) TO ADD2 CONVERT "10" TO "32" (CONTROL Z) FOR EDITING IM(30) TO TSUB2 CHECK FOR CONTROL XRE(E.SIN) TO RTZE IF SO, ECHO 'DELETED'PCI TO TSUB2 CHECK FOR RUBOUTDATA 177RE(F.SIN) TO RTZE IF SO,  THEN BACK ARROW - DELETE CHARIM(32) TO TSUB2 CHECK FOR CONTROL ZPCI TO RTNZ IF NOT CRTL Z,THEN CONTINUEDATA J.SIN-.-1EJECT**BACK ARROW/CRTL Z/RUBOUT*F.SIN:PCI TO TSUB3 SEE IF NO BYTES RECEIVEDDATA -200PCI TO RTZE IF NO BYTES RECEIVED, CONTROL Z IS NULLDATA D.SIN-.-1*IM(10) TO D50 BACKSPACEPCI    TO D50 SEND SPACEDATA 40IM(10) TO D50 AND BACKSPACE AGAINIM(1) TO SUB3  DECREMENT BYTE COUNTR1    TO TLOA1 SEE IF SAVED BYTEPCI TO RTNZ IF SAVED UP BYTE IN R1, JUST TOSS ITDATA C.SIN-.-1IM(1) TO SUB0 DECREMENT POINTER TO MEMORYMR0   TO R1   GET SAVED UP BYTE FROM LAST TIMEPCI   TO AND1 EXTRACT THE SAVED BYTEDATA 377PCI TO RTRA GO BACK FOR NEXT WORDDATA D.SIN-.-1*E.SIN:PCI TO D50 PRINTED 'DELETED' MESSAGE FOR CONTROL XDATA 40 SPACEPCI TO D50DATA 144 dPCI TO D50DATA 145 ePCI TO D50 DATA 154 lPCI TO D50DATA 145 ePCI TO D50DATA 164 tPCI TO D50DATA 145 ePCI TO D50DATA 144 dIM(15) TO D50 CRIM(12) TO D50 LFR4 TO R0 RESET R0PCI TO RTRA AND GO BACKDATA M.SIN-.-1 RESTORE R0, SET UP R1, R3EJECT**NORMAL CHARACTER - STORE IT*J.SIN:R2 TO D50 ECHO THE BYTE ON THE TERMINALR1 TO TLOA1 SEE IF THERE IS A SAVED UP BYTE RE(G.SIN) TO RTNZ IF SO,  THEN STORE COMPLETE WORDR2 TO R1 SAVE THIS BYTE IN R2IM(1) TO ADD3 INCREMENT THE COUNTER (WILL NOT GET TO ZERO HERE)IM(15) TO TSUB2 SEE IF IT WAS CARRIAGE RETURNPCI TO RTNZ IF NOT CR,  THEN GET NEXT CHARACTERDATA D.SIN-.-1 RELATIVE DISTANCER1 TO MR0I AND SAVE WORD CONTAINING BOTH BYTESH.SIN:PCI TO ADD3 AND CALCULATE NUMBER OF BYTES RECEIVEDDATA 200R3 TO MR4 AND SAVE THAT IN WORD 0 OF THE ARRAYIM(15) TO D50 ECHO CARRIAGE RETURNIM(12) TO D50 ECHO LINE FEED TOOR14 TO D1 RE-ENABLE INTERRUPTS IF USER SO PREFERSIM(LREG) TO ATRA RESTORE REGS AND RETURN*G.SIN: ... WE HAVE TWO BYTES - BRING TO UPPER HALFim(0) to BSOR2R2 TO OR1 OR THAT INTO WORDR1 TO MR0I AND STORE IN USER SPACEIM(1) TO ADD3 INCREMENT POINTERPCI TO RTZE IF ZERO,  THEN DONE -- ECHO DELETED AND RESTART IF TOO LONGDATA E.SIN-.-1 REL DISTPCI TO SUB2 CHECK FOR CARRIAGE RETURNDATA 15*400 IF THIS,  THEN CARRIAGE RETURNRE(H.SIN) TO RTZE CARRIAGE RETURN - JUST RETURN TO USERPCI TO RTRA STILL SOME ROOM LEFT - GO BACK, CLEAR AC1,  AND CONTINUEDATA C.SIN-.-1 REL DIST**HANDLE CONTROL-S TYPED IN.  GET THE NEXT NON-CONTROL-S AND THROW IT AWAY.*DO NOT ECHO THESE CHARACTERS; THEY CAN SCREW UP SOME TERMINALS.*X.SIN:D50 TO R2 GET ANOTHER CHARACTERPCI TO AND2 MASK OFF PARITYDATA 177IM(21) TO TSUB2 SEE IF CONTROL-QRE(X.SIN) TO RTNZ IF NOT, THEN GET ANOTHER CHARACTERPCI TO RTRA GET ANOTHER USEFUL CHARACTERDATA D.SIN-.-1Z.SIN:DATA O.SIN BEGIN PATCH LISTDATA L.BRK BREAKDATA 0 END OF SEGMENTEJECT**INPUT PRIME:**ROUTINE IS USED TO SCAN A LINE OF INPUT FROM THE TERMINAL.*R.IPR:DATA Z.IPR POINTER TO PATCH LISTif ModelCD10 to R1 save our returnR1 to MR12D stack itendifPCI TO D50 PRINT QUESTION MARK ON TERMINALDATA 77 QUESTION MARKPCI TO D50 FOLLOW QMARK WITH SPACEDATA 40 SPACEPCI TO R0 GET POINTER TO BUFFERDATA CONTAB+INPBUFMR0 TO R0 GET ACTUAL POINTER TO BUFFERif ^ModelCMR15 TO R12 BACK UP STACK POINTERR12I TO ATNV INCR BY ONEMR12 TO R1 GET RETURN FROM CALL TO IPRendifIM(2) TO SUB1 BACK UP RETURN BY ONE FOR RESTARTR1 TO MR0I SAVE RESTART ADDRESS IN FIRST WORD OF AREAIM(0) TO MR0I AND ZERO OUT BYTE POINTER = NUMBER PROCESSEDJUMP TO PROC AND PERFORM SUB CALLA.IPR:DATA 0 PATCHED TO STRING INPUT ROUTINEif ModelCR12I to ATNV back up stack pointerendifRETURN TO ATRA AND RETURN WITH EVERYTHING INTACT*Z.IPR:DATA A.IPR BEGIN PATCH LISTDATA L.SIN DATA 0 END OF SEGMENTEJECT**GET CHARACTER**THE ROUTINE 'R.GTC' IS CALLED TO GET THE NEXT CHARACTER DURING NUMERIC*INPUT PROCESSING.  IT RETURNS, IN R0,  THE NEXT CHARACTER FROM THE INPUT*BUFFER.  THE BUFFER POINTER IS INCREMENTED BY THIS ROUTINE.**IF THE LAST CHARACTER HAS BEEN READ (USING GTC) THEN 0 IS RETURNED.*R.GTC:DATA Z.GTC POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifPCI TO R0 GET POINTER TO INPUT BUFFERDATA CONTAB+INPBUFMR0 TO R0 PICK UP RAM POINTERIM(1) TO ADD0 INCREMENT IT TO POINT TO BYTE POSITION WORDMR0 TO R1 GET BYTE POINTER FIELDR1 TO R2 AND SAVE CURRENT POINTER HERER1 TO TADD1 CHECK SIGN BITif ^ModelCIM(1) TO RTNC IF NO CARRY, THEN LEAVE ITIM(1) TO ADD1 ELSE INCREMENT WORD PONERendifif ModelCim(0) to ADC1 increment word pointer on carryendifPCI TO XOR1 FLIP BYTE BITDATA 100000R1 TO MR0I AND RESTORE INCREMENT BYTE POINTERMR0 TO LOA3 GET # PF BYTES LEFTIM(2) TO RTNZ MUST BE SOME TO CONTIUEIM(0) TO LOA0 ELSE RETURN WITH ZERORETURN TO ATRA GO BACK NOW IF NONE LEFTIM(1) TO SUB3 DECREMENT NUMBER LEGFTR3 TO MR0I STORE THATPCI TO AND2 EXTRACT WORD POSITIONDATA 077777R0 TO ADD2 AND GENERATE WORD POINTER TO MEMORYMR2 TO R0 GET WORDR1 TO TADD1 SEE IF WE WANT UPPER BITRE(A.GTC) TO RTRC IF SET, THEN WE WANTED BYTE ZERO (INCREMENT FIRST)im(0) to BSOR0 byte swap (rotate left 8)A.GTC:PCI TO AND0 EXTRACT WORDDATA 377 EXTRACT THATRETURN TO ATRA AND GO BACK TO CALLERZ.GTC:DATA 0 END OF SEGMENT, NO PATCHESEJECT**ROUTINE TO SET UP RCVDCHARACTER**WHEN INTERRUPTS ARE ENABLED,  AND AN INTERRUPT COMES FROM DEVICE 40 OR*DEVICE 50,  THE SYSTEM ROUTINE READS THE CHARACTER FROM THE INTERFACE (AND*THUS CLEARS THE INTERRUPT REQUEST) AND STORES IT IN A UNIQUE LOCATION OF MEMORY.**DURING THE PROCESSING OF THE USER INTERRUPT ROUTINE, THE USER CAN CALL*'RCVDCHARACTER' TO GET THE CHARACTER FROM THE INTERRUPTING DEVICE.*R.ICH:DATA Z.ICH POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifPCI TO R0 GET POINTER TO OUR SPECIAL MEMORY LOCATIONDATA CONTAB+RCVPTRMR0 TO R0 GET POINTERMR0 TO LOA0 AND PICK UP CHARACTER IN R0RETURN TO ATRA RETURN TO USERZ.ICH:DATA 0 END OF SEGMENT, NO PATCHES**INPUT DONE PROCEDURE:**CALLED AT END OF NUMERIC INPUT,  TO CHECK FOR PROPER COMPLETION ON INPUT LINE.*R.IDN:DATA Z.IDN POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACK IN CASE OF FAILJUMP TO PROC CALL GETCHARB.IDN:DATA 0 POINTER TO GTCIM(LREG) TO ATZE IF ZERO, IT'S OKAYPCI TO ATRA ELSE INPUT ERRORD.IDN:DATA 0 PATCHED TO IER*Z.IDN:DATA B.IDN BEGIN PATCH LISTDATA L.GTCDATA D.IDNDATA L.IERDATA 0 END OF SEGMENTEJECT**INPUT ERROR ROUTINE:**THE FOLLOWING ROUTINE IS CALLED WHEN AN INPUT FORMAT ERROR HAS OCCURRED.*CALLING ROUTINE HAS CALLED L.SREG FIRST.**ROUTINE PRINTS MESSAGE ON TERMINAL,  AND THEN CONTINUES*R.IER:DATA Z.IER POINTER TO PATCH LISTR17 TO R0 GET CURRENT LOCATIONIM(IERMS-.) TO ADD0 GENERATE POINTER TO STRING MESSAGEIM(1) TO R2 AND ON TERMINALJUMP TO PROC AND PERFORM SUB CALLA.IER:DATA 0 POINT TO STRING PRINT ROUTINEPCI TO R0 GET POINTER TO BUFFERDATA CONTAB+INPBUFMR0 TO R0 PICK UP BUFFER POINTERif ^ModelCMR15 TO R1 BACK UP TO RETURNIM(1) TO SUB1 GET POINTER TO RETURNendifif ModelCR12 to R1 get stack pointerim(7) to ADD1 back up to point to return address **** TIED TIGHTLY TO SREG/LREG ****endifMR0 TO MR1 AND FUDGE RETURN BACK TO START OF INPUTIM(LREG) TO ATRA GO BACK - IN THIS CASE TO RESTART INPUTIERMS:DATA 42 34 CHARACTERSTEXT Format error - please retry lineDATA 400*12+15 CR-LFZ.IER:DATA A.IER BEGIN PATCH LISTDATA L.SPRDATA 0 END OF SEGMENT