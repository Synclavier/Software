TTL MATHEMATICAL OPERATIONS (FLOATING)**INTERNAL NORMALIZE ROUTINE--*  CALLED WITH:*    AC0-AC1 = MANTISSA*    AC3=EXPONENT (OFFSET BINARY - 64 )*    AC4=DESIRED FINAL SIGN BIT (000000 FOR POSITIVE, 100000 FOR NEGATIVE */*R.NOR:DATA Z.NOR POINTER TO END OF SEGMENTif ModelCD10 to MR12 save returnendifIM(0) TO TSUB1 CHECK IF LSB'S ZERORE(A.NOR) TO RTNZ NONZERO - NORMALIZEIM(0) TO TSUB0 SEE IF ZERORE(A.NOR) TO RTNZ NONZERO - NORMALIZERETURN TO ATRA IF ZERO AND ZERO, THEN RETURN = SIGN=MANTISSA=EXPONENT=0**NONZERO - SHIFT AND NORMALIZE **A.NOR:PCI TO TAND0 SEE IF PROPER BIT IS A ONEDATA 040000 NAMELY THIS BITRE(B.NOR) TO RTNZ IF SO, THEN NORMALIZE IS DONEif ^ModelCR0 TO ADD0 SHLR1 TO ADD1 SHLIM(1) TO RTNC IF NO CARRY, THEN NO INCREMENT OF R0IM(1) TO OR0 OR IN BIT IF SHIFT ACROSS BOUNDARYendifif ModelCR1 to ADD1 shl lsR0 to ADC0 shl ms, propagate carryendifIM(1) TO SUB3 REDUCE EXPONENT SINCE WE SHIFTED LEFT RE(A.NOR) TO RTRA AND GO BACK**DONE - PATCH UP AND RETURN*B.NOR:PCI TO TSUB3 SEE IF EXPONENT TOO LARGE OR TOO SMALLDATA 200  LARGEST EXPONENT+1RE(C.NOR) TO RTNC IF NO CARRY, THEN EXPONENT IS IN RANGER3 TO ADD3 SEE IF OVER OR UNDERRE(D.NOR) TO RTNC EXPONENT TOO LARGE IF OUT OF BOUNDS AND NOT NEGATIVEIM(0) TO LOA1 RETURN A ZERO IF UNDERFLOWIM(0) TO LOA0 BY ZEROING BOTH R0, R1RETURN TO ATRA AND RETURN WITH THAT VALUED.NOR:IM(-1) TO LOA1 ELSE RETURN POSITIVE INFINITY (A LARGE EXPONENT HERE)  PCI TO LOA0 AND A LARGE MANTISSADATA 077777 LOTS OF BITSR4 TO OR0 MAKE NEGATIVE INFINITY IF APPROPRIATERETURN TO ATRA AND RETURN WITH VALUEC.NOR:PCI TO AND1 AND EXTRACT MANTISSADATA 177600 LEAVING ROOM FOR EXPONENTR3 TO OR1 OR IN EXPONENT - RETURN PACKED FORMR4 TO OR0 AND OR IN FINAL SIGN,  SET C&ZRETURN TO ATRA AND RETURNZ.NOR:DATA 0 END OF SEGMENT, NO PATCHESEJECT**FLOAT ROUTINE:**ENTERED WITH FIXED POINT NUMBER IN AC0*RETURNS WITH FLOATING NUMBER IN AC0-AC1*R.FLO:DATA Z.FLO POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSR0 TO R2 MOVE TO R2PCI TO R3 SET UP INITIAL EXPONENT FOR NORMALIZE ROUTINEDATA 100+17 THIS PUTS DECIMAL POINT AT RIGHT END OF R0PCI TO AND2 EXTRACT SIGNDATA 100000 SIGN BITRE(B.FLO) TO RTZE IF ZERO SIGN BIT,  MEANS POSITIVER0 TO LCM0 NEGATE NUMBERIM(1) TO ADD0 TWO'S COMPLEMENTRE(B.FLO) TO RTPL IF POSATIVE,  THEN OKPCI TO R0 +32K WOULD BLOW UP NORMALIZE ROUTINEDATA 040000IM(1) TO ADD3 PUSH UP EXPONENT BY ONE TO HANDLE + OR - 32KB.FLO:R2 TO R4 STORE SIGN BIT IN R4IM(0) TO R1 AND OF COURSE NO LSB'SJUMP TO PROC JSRF.FLO:DATA 0 WILL POINT TO NORMALIZE ROUTINEIM(LREG) TO ATRA RESTORE REGS AND RETURNZ.FLO:DATA F.FLO BEGIN PATCH LISTDATA L.NORDATA 0 AND END OF SEGMENTEJECT**FIX ROUTINE:**ENTERED WITH FLOATING POINT NUMBER IN AC0-AC1*RETURNS WITH INTEGER PORTION IN AC0*R.FIX:DATA Z.FIX POINTER TO END OF SEGMENTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSR0 TO R2 GET MSBPCI TO AND2 EXTRACT FINAL SIGNDATA 100000 SIGN BITR2 TO R4 STORE SIGN BITPCI TO AND0 AND REMOVE IT FROM WORDDATA 077777R1 TO R3 GET EXPONENTPCI TO AND3 EXTRACT ITDATA 177 EXPONENT FIELDPCI TO AND1 AND REMOVE THESE BITSDATA 177600IM(0) TO R2 CLEAR R2 FOR RESULTB.FIX:PCI TO TSUB3 SEE IF EXPONENT IS SMALL ENOUTH YETDATA 100RE(C.FIX) TO RTNC IF NO CARRY, THEN EXPONENT IS LESS THAN 64if ^ModelCR2 TO ADD2 SHLR0 TO ADD0 SHLIM(1) TO RTNC IF NO CARRY, SKIPIM(1) TO OR2 ELSE OR IN RESULTR1 TO ADD1 AND CONTINUE SHIFTIM(1) TO RTNC AND KEEP ITIM(1) TO OR0 IF CARRY PROPAGATIONendifif ModelCR0 to ADD0 shlR2 to ADC2 shl, propagate carryR1 to ADD1 shlim(0) to ADC0 and propagate carryendifIM(1) TO SUB3 MAKE EXPONENT SMALLER SINCE WE SHIFTED LEFTRE(B.FIX) TO RTRA AND GO BACK FOR MOREC.FIX:R4 TO TLOA0 DONE WITH FIX, SEE IF POSITIVERE(F.FIX) TO RTZE IF POSITIVE,  THEN NO CHANGER2 TO LCM2 COMPLEMENT THE INTEGERR0 TO OR1 AND OR TOGENTERH THE LSB'S - IF ZERO,  THEN BRING UPRE(F.FIX) TO RTNZ IF NOT ZERO,  THEN LEAVE INT(-1.1) IS -2.IM(1) TO ADD2 BUT INT(-1.0) IS 1.0F.FIX:R2 TO LOA0 GET ANSWER, FIXED PT, IN R0IM(LREG) TO ATRA RESTORE REGS AND RETURNZ.FIX:DATA 0 END OF SEGMENT, NO PATCHESEJECT**SPECIAL MULTIPLY SUBROUTINE:*CALLED FROM FLOATING MULTIPLY TO PERFORM LOOP*R.MLS:DATA Z.MLS POINTER TO END OF SEGMENTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSPCI TO AND0 EXTRACT FIRST MANTISSADATA 077777R0 TO R4 THAT ONEPCI TO AND1 DITTODATA 177600R1 TO R5 MOVEPCI TO AND2DATA 077777R2 TO R6PCI TO AND3DATA 177600R3 TO R7 AND MOVE IT**NOW MULTIPLY (AC4-AC5) * (AC6-AC7) = (AC0-AC1-AC2-AC3)*PCI TO R10 PICK UP PTR TO COMPUTER AND MUSIC OPTIONSDATA CONTAB+CMOPTMR10 TO R3 PICK UP OPTIONS WORDIM(10) TO TAND3 IS THE HARDWARE MUL/DIV PRESENT?RE(H.MLS) TO RTZE IF NOT, THEN SKIPR4 TO D5 FIRST R4*R6R6 TO D6 MULTIPLYD4 TO R0 GET MSBD5 TO R1 AND LSBR5 TO D5 NOW R5*R7R7 TO D6 MULTIPLYD4 TO R2 GET MSBD5 TO R3 AND GET LSBR4 TO D5 NOW FOR FIRST CROSS PRODUCTR7 TO D6 MULTIPLYif ^ModelCD4 TO ADD1 ADD IN MSBIM(1) TO RTNC IF NO CARRY, SKIPIM(1) TO ADD0 PROPAGATED5 TO ADD2 ADD INIM(3) TO RTNC IF NO CARRY, SKIPIM(1) TO ADD1 PROP CARRYIM(1) TO RTNC IF NO CARRY, SKIPIM(1) TO ADD0endif of ^ModelCif ModelCD5 to ADD2 add in LSD4 to ADC1 add in MS, propagate carryim(0) to ADC0 propagate carryendifR5 TO D5 NOW SECOND CROSS PRODUCTR6 TO D6 MULTIPLYif ^ModelCD4 TO ADD1 ADD IN MSBIM(1) TO RTNC SKIP IF NO CARRYIM(1) TO ADD0D5 TO ADD2 ADD IN LSBIM(3) TO RTNC IF NO CARRY,  SKIPIM(1) TO ADD1 INCRIM(1) TO RTNC IF NO CARRY, SKIPIM(1) TO ADD0endif of ^ModelCif ModelCD5 to ADD2 add in LSD4 to ADC1 add in MS, propagate carryim(0) to ADC0 propagate carryendifIM(LREG) TO ATRA AND RETURN WITH ANSWERH.MLS:IM(-37) TO R10 STORE LOOP COUNTER HEREIM(0) TO R0 INITIALIZE ANSWERIM(0) TO R1IM(0) TO R2IM(0) TO R3B.MLS: ... main loopif ^ModelCR0 TO ADD0 SHLR1 TO ADD1IM(1) TO RTNC NO PROPIM(1) TO OR0R2 TO ADD2 SHLIM(1) TO RTNCIM(1) TO OR1R3 TO ADD3 SHLIM(1) TO RTNCIM(1) TO OR2endif of ^ModelCif ModelCR3 to ADD3 shlR2 to ADC2 shl, propagate carryR1 to ADC1 shl, propagate carryR0 to ADC0 shl, propagate carryendifR3 TO R11 STORE R3 TEMPORARILYR4 TO R3 TO TEST THIS MSBPCI TO TAND3 SEE IF WE SHOULD ADD INDATA 100000 BY TESTING MSB FIRSTRE(C.MLS) TO RTZE NO ADD INR11 TO R3 RESTORE R3R7 TO ADD3 ADD LSB FIRSTif ^ModelCRE(D.MLS) TO RTNC NO CARRYIM(1) TO ADD2RE(D.MLS) TO RTNCIM(1) TO ADD1RE(D.MLS) TO RTNCIM(1) TO ADD0 INCREMENT ITD.MLS:R6 TO ADD2 AND ADD IN THISRE(F.MLS) TO RTNCIM(1) TO ADD1 PROPAGATE CARRYRE(F.MLS) TO RTNCIM(1) TO ADD0 PROPATGATEF.MLS: ...endif of ^ModelCif ModelCR6 to ADC2 add in this, propagate carryim(0) to ADC1 propagate carryim(0) to ADC0 propagate carryendif of ModelCR3 TO R11 RESAVE R3 IN R11 TEMPR4 TO R3 AND GET R4 IN R3 FOR SHIFTC.MLS:R3 TO ADD3 SHLR3 TO R4 MOVER5 TO R3 GET HANDYR3 TO ADD3 SHLR3 TO R5 ***** DOES NOT CHANGE C OR ZRE(G.MLS) TO RTNC NO PROPR4I TO ATNV SET LSB OF R4 TO 1 IF WE GOT CARRY OUT OF R5G.MLS:R11 TO R3 RESTORE LSB'S TO R3R10I TO TLOA0 INCREMENT LOOP COUNTERPCI TO RTNZ GO BACK FOR MORE IF MOREDATA B.MLS-.-1 RELATIVE BACK DISTANCEIM(LREG) TO ATRA RESTORE REGS AND RETURNZ.MLS:DATA 0 END OF SEGMENT, NO PATCHESEJECT**MAIN MULTIPLY ROUTINE*  FLOATING MULTIPLY OF (AC0-AC1) BY (AC2-AC3) = (AC0-AC1)*R.FPM:DATA Z.FPM POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKR0 TO R4 SAVE UNALTERED NUMBERSR1 TO R5R2 TO R6R3 TO R7 BECAUSE MLS SAVES REGISTERS AGAINif HFloat only if we want hardware floating pointD51 TO R0 PICK UP DEVICE BITSPCI TO TAND0 SEE IF HARDWARE FLOATING POINT BOARD IN SYSTEMDATA 40000R4 TO R0 RESTORE FIRST NUMBERRE(A.FPM) TO RTZE NOT THERE**Hardware multiply*JUMP to PROC call XPL to IEEE conversion routine with first argumentM.FPM: data 0R0 to R4 set aside resultR1 to R5R6 to R0 get second operandR7 to R1JUMP to PROC call XPL to IEEE conversion routine with second argumentN.FPM: data 0PCI to D121 write opcode to hardware floating point unitdata 30512 single-precision multiply (in upper half - 112 in lower half)R4 to D122 write first operandR5 to D122R0 to D122 write second operandR1 to D122D120 to R2 pick up statusD122 to R0 pick up resultD122 to R1JUMP to PROC call IEEE to XPL conversion routine with resultO.FPM: data 0im(LREG) to ATRA load registers and return**Software multiply*A.FPM: ...endif of HFloatJUMP TO PROC AND CALL MLS TO PERFORM THE MULTB.FPM:DATA 0 WILL POINT TO R.MLS**AT THIS POINT, AC0-AC1 = FINAL MANTISSA*R4 TO R2 CALCULATE RESULT SIGN BITR6 TO XOR2 - TIMES - = +PCI TO AND2 EXTRACT NEW SIGNDATA 100000 SIGN BITR2 TO R4 AND PUT SIGN IN R4R5 TO R3 NOW CALCULATE EXPONENTPCI TO AND3DATA 177R7 TO R2 AND OTHER EXPONENTPCI TO AND2DATA 177 EXTRACT OTHER EXPONENTR2 TO ADD3 GENERATE EXPONENTPCI TO SUB3 AND ADJUST FOR OFFSET BIANRY,  SHIFTDATA 100-1JUMP TO PROC AND CALL NORMALIZERC.FPM:DATA 0 WILL POINT TO NORMALIZEIM(LREG) TO ATRA LOAD REGS AND RETURN*Z.FPM:DATA B.FPM BEGIN PATCH LISTDATA L.MLSDATA C.FPMDATA L.NORif HFloat only if we want hardware floating pointDATA M.FPMDATA L.XTIDATA N.FPMDATA L.XTIDATA O.FPMDATA L.ITXendif of HFloatDATA 0 END OF SEGMENTEJECT**MAIN DIVIDE SUBROUTINE*  CALLED WITH AC0-AC1,  AC2-AC3 FLOATING VARIABLES*  PERFORMS (AC0-AC1) / (AC2-AC3) = (AC0-AC1)*R.DVS:DATA Z.DVS POINTER TO END OF SEGMENTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKPCI TO AND0 EXTRACT THISDATA 077777PCI TO AND1 EXTRACT THISDATA 177600PCI TO AND2 EXTRACT THISDATA 077777R2 TO R4 MOVE HEREPCI TO AND3 EXTRACTDATA 177600R3 TO R5IM(0) TO R2 INITIALIZE ANSWERIM(0) TO R3IM(-36) TO R10 SET UP LOOP COUNTER**AC0-AC1 / R4-R5*B.DVS:R2 TO ADD2 SHL ANSWERR3 TO ADD3 SHLIM(1) TO RTNC PROPIM(1) TO OR2 PROP CARRY IF ONER4 TO TSUB0 SEE IF BIG ENOUGH TO SUBTRACTRE(C.DVS) TO RTNC IF NO CARRY THEN NOT BIG ENOUGHRE(D.DVS) TO RTNZ IF NOT EQUAL, THEN MUST BE BIG ENOUGH TO SUBTRACTR5 TO TSUB1 CHECK LSB'SRE(C.DVS) TO RTNC IF NO CARRY, THEN NOT BIG ENOUGH TO SUBTRACTD.DVS: ...if ^ModelCR5 TO SUB1 SUBTRACT LSB'S FIRSTIM(1) TO RTRC BORROW IF WE DID NOT CARRYIM(1) TO SUB0 BORROW HERER4 TO SUB0 SUBTRACT UPPERSendifif ModelCR5 to SUB1 subtract LSR4 to SBB0 subtract MS, propagate borrowendifIM(1) TO OR3 AND SET BIT IN ANSWERC.DVS: ...if ^ModelCR0 TO ADD0 SHL UPPERR1 TO ADD1IM(1) TO RTNC CARRY PROP?IM(1) TO OR0 OR IN BITendifif ModelCR1 to ADD1 shl lowerR0 to ADC0 shl upper, propagate carryendifR10I TO TLOA0 SEE IF DONE?RE(B.DVS) TO RTNZ GO BACK IF NOT DONER3 TO LOA1 AND PUT RESULT IN AC0/AC1R2 TO LOA0IM(LREG) TO ATRA LOAD REGS AND RETURNZ.DVS:DATA 0 END OF SEGMENT, NO PATCHESEJECT**FLOATING POINT DIVIDE ROUTINE*  PERFORMS AC0-AC1 / AC2-AC3 = AC0-AC1*R.FPD:DATA Z.FPD POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGS ON STACKIM(0) TO TSUB2 CHECK FOR DIVISION BY ZERORE(F.FPD) TO RTNZ NOT ZEROR0 TO XOR2 GET SIGN OF RESULTPCI TO AND2 KEEP SIGNDATA 100000IM(-1) TO LOA1 RETURN INFINITYPCI TO LOA0 MSB INFINITYDATA 077777R2 TO OR0 RETURN NEGATIVE INFINITY IF APPROPRIATEIM(LREG) TO ATRA LOAD REGS AND RETURNF.FPD:R0 TO R4R1 TO R5R2 TO R6R3 TO R7  SAVE CALLING DATAif HFloat only if we want hardware floating pointD51 TO R0 PICK UP DEVICE BITSPCI TO TAND0 SEE IF HARDWARE FLOATING POINT BOARD IN SYSTEMDATA 40000R4 TO R0 RESTORE FIRST NUMBERRE(A.FPD) TO RTZE NOT THERE**Hardware divide*JUMP to PROC call XPL to IEEE conversion routine with first argumentM.FPD: data 0R0 to R4 set aside resultR1 to R5R6 to R0 get second operandR7 to R1JUMP to PROC call XPL to IEEE conversion routine with second argumentN.FPD: data 0PCI to D121 write opcode to hardware floating point unitdata 20512 single-precision divide (in upper half - 112 in lower half)R0 to D122 write second operandR1 to D122R4 to D122 write first operandR5 to D122D120 to R2 pick up statusD122 to R0 pick up resultD122 to R1JUMP to PROC call IEEE to XPL conversion routine with resultO.FPD: data 0im(LREG) to ATRA load registers and return**Software divide*A.FPD: ...endif of HFloatJUMP TO PROC AND NOW CALL OUR INTERNAL SUBROUTINEB.FPD:DATA 0 POINTER TO R.DVS**AC0-AC1 = MANTISSA*R4 TO R2 GET SIGNR6 TO XOR2 FIND SIGN OF RESULTPCI TO AND2 EXTRACT ITDATA 100000R2 TO R4 AND PUT IN R4 FOR NORMALIZER5 TO R3 NOW GET EXPONENTPCI TO AND3 EXTRACT ITDATA 177R7 TO R2 SAME WITH OTHERPCI TO AND2DATA 177 EXTRACT ITR2 TO SUB3 SUBTRACT EXPONENTS FOR  DIVIDEPCI TO ADD3 BUT COMPENSATE HEREDATA 100+1 FOR SHIFT TOOJUMP TO PROC AND NOW CALL NORMALIZEC.FPD:DATA 0 POINTER TO NORMALIZEIM(LREG) TO ATRA LOAD REGS AND RETURN*Z.FPD:DATA B.FPD BEGIN PATCH LISTDATA L.DVSDATA C.FPDDATA L.NORif HFloat only if we want hardware floating pointDATA M.FPDDATA L.XTIDATA N.FPDDATA L.XTIDATA O.FPDDATA L.ITXendifDATA 0 END OF SEGMENTEJECT**FLOATING POINT ADDITION ROUTINE**AC0-AC1 + AC2-AC3 = AC0-AC1*R.FPA:DATA Z.FPA POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERSR0 TO R6 MOVE FIRST VARIABLE TO OTHER REGISTERR1 TO R7 BOTH HALVESif HFloat only if we want hardware floating pointD51 TO R0 PICK UP DEVICE BITSPCI TO TAND0 SEE IF HARDWARE FLOATING POINT BOARD IN SYSTEMDATA 40000RE(A.FPA) TO RTZE NOT THERE**Hardware add*R6 to R0 restore first part of first operandR2 to R4 save second operandR3 to R5JUMP to PROC call XPL to IEEE conversion routine with first argumentV.FPA: data 0R0 to R6 set aside resultR1 to R7R4 to R0 get second operandR5 to R1JUMP to PROC call XPL to IEEE conversion routine with second argumentW.FPA: data 0PCI to D121 write opcode to hardware floating point unitdata 512 single-precision add (in upper half - 112 in lower half)R6 to D122 write first operandR7 to D122R0 to D122 write second operandR1 to D122D120 to R2 pick up statusD122 to R0 pick up resultD122 to R1JUMP to PROC call IEEE to XPL conversion routine with resultX.FPA: data 0im(LREG) to ATRA load registers and return**Software add*A.FPA: ...endif of HFloatR3 TO R0 PLAY WITH SECOND EXPONENTPCI TO AND0 EXTRACT ITDATA 177PCI TO AND1 AND FIRST ONEDATA 177R1 TO TSUB0 GENERATE CARRY IF SECOND EXPONENT GREATER THAN FIRSTRE(B.FPA) TO RTRC IF SECOND EXP IS GREATER, THEN OK**AC0-AC1 ARG HAD BIGGER EXPONENT - SWAP THEM*R2 TO R10R3 TO R11R6 TO R2R7 TO R3R10 TO R6R11 TO R7R1 TO R10 MOVE EXPONENT TOR0 TO R1R10 TO R0B.FPA:R0 TO SUB1 GENERATE MINUS # OF PLACES TO SHIFT (OR ZERO)RE(C.FPA) TO RTZE IF ZERO, THEN NO SHIFT TO PERFORMIM(35) TO TADD1 SEE IF TOO FAR TO SHIFTRE(C.FPA) TO RTRC IF CARRY HERE, THEN SHIFT COUNT <=35**TOO MANY SHIFTS REQUIRED:*ANSWER IS JUST THE NUMBER WITH THE LARGER EXPONENT*R3 TO LOA1 GET LARGER EXPONENT NUMBERR2 TO LOA0 BOTH HALVESS.FPA:IM(LREG) TO ATRA EXIT POINT - LOAD REGS AND RETURN**SHIFT LARGER NUMBER LEFT AND REDUCE EXPONENT UNTIL EXPS ARE EQUAL*C.FPA:R1 TO R10 SAVE MINUS SHIFT COUNT IN R10R0 TO ADD1 RESTORE SMALLER EXPONENT TO ACTUAL VALUEPCI TO ADD1 ADD 32 TO GIVE RESULT EXPONENTDATA 40R1 TO R11 AND STORE RESULT EXPONENT IN R11**SET UP R4-R5 SIGN BIT*R6 TO R0 GET SMALLER NUMBERR7 TO R1 BOTH PARTSPCI TO AND1 BAG EXPONENTDATA 177600R1 TO R7 AND RESTORE NUMBER WITHOUT EXPONENTPCI TO TAND0 SEE IF NEGATIVE NUMBERDATA 100000RE(G.FPA) TO RTZE IF ZERO, THEN IS POSITIVEPCI TO AND0 BAG SIGN BIT NOW - WE KNOW IT IS NEGATIVEDATA 077777IM(-1) TO R4 NEGATIVE - EXTEND SIGN TO R4IM(-1) TO R5 AND R5R0 TO LCM0 COMPLR1 TO LCM1 HERE TOIM(1) TO ADD1 NEGATEif ^ModelCIM(1) TO RTNC PROPAGATE CARRYIM(1) TO ADD0 COMPUTEendifif ModelCim(0) to ADC0 propagate carryendifR0 TO R6 SET UP R6 FINALLYR1 TO R7 NOW R4-R5-R6-R7 CONTAINS TWOS COMPLEMENT  SMALLER NUMBERRE(H.FPA) TO RTRA AND CONTINUEG.FPA:IM(0) TO R4 POSITIVE NUMBER - EXTEND POSITIVE SIGNIM(0) TO R5 DITTO**NOW LARGER NUMBER*H.FPA:PCI TO AND3 BAG EXPONENTDATA 177600PCI TO TAND2 NOW CHECK SIGN OF LARGERDATA 100000RE(I.FPA) TO RTZE LARGER IS POSITIVEPCI TO AND2 BAG SIGN - WE ARE NEGATIVEDATA 077777IM(-1) TO R0 EXTEND NEGATIVE SIGNIM(-1) TO R1 DITTOR2 TO LCM2 NEGATER3 TO LCM3 DITTOIM(1) TO ADD3 TWO'S COMPLEMENTif ^ModelCIM(1) TO RTNC SKIP IF NO CARRYIM(1) TO ADD2 PROPAGATEendifif ModelCim(0) to ADC2 propagate carryendifRE(K.FPA) TO RTRA AND CONTINUEI.FPA:IM(0) TO R0 EXTEND POSITIVE SIGNIM(0) TO R1 DITTO**NOW SHL LARGER NUMBER AND REDUCE ITS EXPONENT UNTIL EXPS ARE EQUAL *K.FPA:R10I TO TLOA0 SEE IF ZERO SHIFT COUNTRE(M.FPA) TO RTZE NO MORE SHIFTSif ^ModelCR0 TO ADD0 SHLR1 TO ADD1 SHLIM(1) TO RTNCIM(1) TO OR0R2 TO ADD2 SHLIM(1) TO RTNCIM(1) TO OR1R3 TO ADD3 SHLIM(1) TO RTNCIM(1) TO OR2 PROPendif of ^ModelCif ModelCR3 to ADD3 shlR2 to ADC2 shl, propagate carryR1 to ADC1 shl, propagate carryR0 to ADC0 shl, propagate carryendifRE(K.FPA) TO RTRA AND GO BACK AGAIN**NOW ADD UP BITS*M.FPA:R7 TO ADD3 ADD IT INif ^ModelCRE(N.FPA) TO RTNC NO CARRY TO PROPIM(1) TO ADD2 PROPRE(N.FPA) TO RTNCIM(1) TO ADD1 PROPRE(N.FPA) TO RTNCIM(1) TO ADD0 PROPN.FPA:R6 TO ADD2 ADD UP NEXTRE(O.FPA) TO RTNC CARRY?IM(1) TO ADD1 PROPRE(O.FPA) TO RTNCIM(1) TO ADD0O.FPA:R5 TO ADD1 ADD UP THISIM(1) TO RTNCIM(1) TO ADD0 PROPAGATER4 TO ADD0 AND FINAL WORDendif of ^ModelCif ModelCR6 to ADC2 add up next, propagate carryR5 to ADC1 add up, propagate carryR4 to ADC0 add last, propagate carryendif**NOW OUR OWN SPECIAL NORMALIZE**FIND SIGN OF RESULT*IM(0) TO R4 ASSUME SIGN OF ZEROPCI TO TAND0 TEST SIGN BITDATA 100000RE(P.FPA) TO RTZE IS POSITIVE - NOTHING TO DOPCI TO R4 SET SIGN BIT OF NEGATIVEDATA 100000 SIGN BITR0 TO LCM0 COMPL RESULTR1 TO LCM1R2 TO LCM2R3 TO LCM3IM(1) TO ADD3 ADD A ONERE(P.FPA) TO RTNC NO CARRYIM(1) TO ADD2 ADD A ONERE(P.FPA) TO RTNCIM(1) TO ADD1 PROPAGATERE(P.FPA) TO RTNC NO CARRYIM(1) TO ADD0 PROPAGATE CARRY TO HERE**NOW CHECK FOR A RESULT OF ZERO*P.FPA:IM(0) TO TSUB3 TESTRE(Q.FPA) TO RTNZIM(0) TO TSUB2 TESTRE(Q.FPA) TO RTNZ NONZIM(0) TO TSUB1 TESTRE(Q.FPA) TO RTNZ NONZIM(0) TO TSUB0 TESTPCI TO RTZE ALL ZERO - EXIT WITH ZERODATA S.FPA-.-1 EXIT ROUTINE**NORMALIZE AND COLLATE RESULT*Q.FPA:PCI TO TAND0 SEE IF NORMALIZED YETDATA 040000RE(T.FPA) TO RTNZ DONEif ^ModelCR0 TO ADD0R1 TO ADD1IM(1) TO RTNC SKIP IF NO CARRAYIM(1) TO OR0R2 TO ADD2IM(1) TO RTNC SKIP IF NO CARRYIM(1) TO OR1R3 TO ADD3IM(1) TO RTNC SKIP IF NO CARRYIM(1) TO OR2endif of ^ModelCif ModelCR3 to ADD3 shlR2 to ADC2 shl, propagate carryR1 to ADC1 shl, propagate carryR0 to ADC0 shl, propagate carryendifR3 TO R10 SAVE R3R11 TO R3 FOR DECREMENTIM(1) TO SUB3 REDUCE EXPONENT DURING SHLR3 TO R11 RESTORE EXPR10 TO R3 AND RESTORE R3RE(Q.FPA) TO RTRA AND GO BACK FOR ANOTHER CHECK**DONE*T.FPA:R11 TO R3 SET UP EXPONENT FOR NORMALIZEJUMP TO PROC CALL NORMALIZEU.FPA:DATA 0 POINTER TO NORMALIZEPCI TO RTRA AND THEN RETURNDATA S.FPA-.-1 RETURN BACK HEREZ.FPA:DATA U.FPA BEGIN PATCH LISTDATA L.NORif HFloat only if we want hardware floating pointDATA V.FPADATA L.XTIDATA W.FPADATA L.XTIDATA X.FPADATA L.ITXendifDATA 0 END OF SEGMENTEJECT***FLOATING SUBTRACT ROUTINE:*  CHANGES SIGN AND USES FLOATING ADD**CHANGE SIGN OF AC2-AC3 AND CALL ADD*R.FPS:DATA Z.FPS POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(0) TO TSUB2 CHECK FOR SUBTRACT OF ZEROIM(2) TO RTZE DO NOT CHANGE SIGN IF MINUSPCI TO XOR2 CHANGE SIGNDATA 100000JUMP TO PROC CALL THE NORMAL ADD ROUTINEA.FPS:DATA 0 PATCHED TO ADD ROUTINEif ModelCR12I to ATNV back up stack pointerendifRETURN to ATRA and then return*Z.FPS:DATA A.FPS BEGIN PATCH LISTDATA L.FPADATA 0 END OF SEGMENTEJECT**FLOATING PRINT ROUTINE:*  CALLED WITH FLOATING NUMBER IN AC0-AC1*  PRINTS ON TERMINAL*R.FPR:DATA Z.FPR POINTER TO PATCH LISTif ModelCD10 to MR12D stack returnendifIM(SREG) TO ATRA SAVE REGISTERS HERER2 TO R6 SAV DEVICE #R0 TO R2 GET SIGN OF NUMBER WE ARE PRINTINGPCI TO AND2 AND EXTRACT IT ONLY - SET SAME SIGNDATA 100000PCI TO OR2 AND GET .00000005 OR -.00000005 DEPENDINGDATA 065537PCI TO R3DATA 145050 .00000005JUMP TO PROC AND NOW CALLA.FPR:DATA 0 THE ADD ROUTINER0 TO R4 SAVE NUM TO PRINTR1 TO R5PCI TO TAND0 SEE IF NEGATIVE NUMBERDATA 100000 SIGN BITRE(B.FPR) TO RTZE ZERO SIGN BIT IF POSITIVEPCI TO AND0 CHANGE TO POSITIVE FOR PRINTINGDATA 077777R0 TO R4 AND SAVE WITHOUT SIGNPCI TO R3 PRINT A MINUS SIGNDATA 55RE(C.FPR) TO RTRA GO PRINT ITB.FPR:PCI TO R3 PRINT A PLUS SIGN IF POSITIVEDATA 53C.FPR:R6 TO R2 GET DEVICE # TO PRINT TOJUMP TO PROC SUB CALLD.FPR:DATA 0 POINTER TO PRINT CHARACTER ROUTINEIM(0) TO R7 ZERO DIGIT COUNTIM(0) TO R10 ZERO POWER COUNT*F.FPR:R4 TO R0 MAIN PRINT LOOP:  DIVIDE NUM BY 1000000R5 TO R1PCI TO R2 GET 1000000DATA 075022PCI TO R3 LSBDATA 124JUMP TO PROC CALL DIVIDEG.FPR:DATA 0 POINTER TO DIVIDE ROUTINER1 TO R2 DUPLICATE WORD WITH EXPONENT IN ITPCI TO AND2 EXTRACT EXPONENTDATA 177 EXPONENT FIELDPCI TO SUB2 SEE IF EXPONENT TOO LARG FOR FIXDATA 100+10RE(H.FPR) TO RTNC NO CARRY MEANS ANSWER OF DIVISION IS SMALL ENOUGH FOR FIX**DIGIT TOO LARGE*I.FPR:PCI TO R3 GET A *DATA 52R6 TO R2 GET DEVICE #JUMP TO PROC AND CALL SUBROUTINEX.FPR:DATA 0 POINT TO PCR7I TO ATNV INCREMENT DIGIT COUNTPCI TO RTRA AND NOW GO TO JDATA J.FPR-.-1 TO SEE IF DONE WITH DIGITS**SEE IF RESULT OF DIVISION IS A DIGIT*H.FPR: JUMP TO PROC SUB CALL TO FIX ROUTINEK.FPR:DATA 0 POINTER TO FIXIM(12) TO TSUB0 SEE IF DIGIT EQUAL TO TEN OR LARGERRE(I.FPR) TO RTRC IF SO, THEN JUST PRINT *R0 TO R1 DUPLICATE IN R1R7 TO OR1 IGNORE LEADING ZEROS, BUT NOT OTHER ONESRE(M.FPR) TO RTZE LEADING ZEROR0 TO R11 SAVE DIGIT FOR MULTIPLICATIONR0 TO R3 GET DIGIT IN AC3 FOR PRINTPCI TO ADD3 ADD IN ASCII ZERODATA 60R6 TO R2 GET D# IN R2JUMP TO PROC SUB CALL TO PRINT CHARACTERN.FPR:DATA 0 POINTER TO PRINT CHARACTER ROUTINER11 TO R0 AND RESTORE DIGIT TO AC0JUMP TO PROC FLOAT IT FOR MULTIPLYP.FPR:DATA 0 POINTER TO FLOATPCI TO R2 GET A 1000000DATA 075022PCI TO R3 TO MULTIPLY DIGIT BYDATA 124JUMP TO PROC AND CALL MULTIPLY TO GET WHAT WE PRINTEDQ.FPR:DATA 0 MULTIPLY ROUTINEIM(0) TO TSUB0 CHECK FOR ZEROIM(2) TO RTZE IF ZERO, THEN DO NOT CHANGE SIGN BIT !!!PCI TO XOR0 NEGATE THE RESULT OF MULTIPLYDATA 100000R4 TO R2 GET NUMBERR5 TO R3JUMP TO PROC AND CALL ADD TO SUBTRACT OUT THE DIGIT WE JUST PRINTEDY.FPR:DATA 0 POINTER TO ADDR7I TO ATNV INCREMENT DIGIT COUNTR0 TO R4 RESTORE NEW NUMR1 TO R5 DITTOM.FPR:R10I TO R0 GET POWER COUNT TO CHECK FOR DECIMAL POINTERIM(6) TO SUB0 CHECK FOR 6RE(S.FPR) TO RTNZ IF NOT 6, THEN NO DECIMNAL POINTERPCI TO R3 GET DIGIT . TO PRINTDATA 56R6 TO R2 GET DEVICE #JUMP TO PROC AND SUB CALLT.FPR:DATA 0 TO PC ROUTINER7I TO ATNV AND INCREMENT DIGIT COUNT FOR DECIMAL POINT PRINTEDS.FPR:R4 TO R0 NOW MULTIPLY NUM BY 10 FOR NEXT DIGITR5 TO R1 NUM IN R0-R1PCI TO R2 GET A 10./00000DATA 050000PCI TO R3DATA 104 10.000000JUMP TO PROC AND SUB CALLU.FPR:DATA 0 TO THE MULTIPLY ROUTINER0 TO R4 AND RESTORE NEW NUMR1 TO R5 DITTO**TEST FOR DONE*J.FPR:R7 TO R0 CHECK FOR DIGIT COUNT OF 8IM(10) TO SUB0 CHECK FOR 8PCI TO RTNZ IF NOT EIGHT, THEN GO BACK FOR MOREDATA F.FPR-.-1 START OF LOOPIM(LREG) TO ATRA AND LOAD REGISTER & RETURN*Z.FPR:DATA A.FPR BEGIN PATCH LISTDATA L.FPADATA D.FPRDATA L.PC DATA G.FPRDATA L.FPDDATA X.FPRDATA L.PC DATA K.FPRDATA L.FIXDATA N.FPRDATA L.PC DATA P.FPRDATA L.FLODATA Q.FPRDATA L.FPMDATA Y.FPRDATA L.FPADATA T.FPRDATA L.PC DATA U.FPRDATA L.FPMDATA 0 END OF SEGMENT