/* EVENTDCL - Declarations and documentation for event routines          *//* The following routines are used to access events stored               *//* in the sequencer.                                                     *//* Events are passed around in 100-word 16-bit arrays that               *//* are described by the literals in :SYNAUXS:SEQLITS. Sequencer Pointers *//* are passed around in 4 word arrays also described in SEQLITS.         *//*************************************************************************/dcl Get.Default.Event proc (ARRAY, FIXED) external;/* Get Default Event fills the passed ARRAY with a default event of      *//* the type that is specified by FIXED.   This is used when creating     *//* a new event in the sequence (as opposed to editing an existing event).*//* By starting with an ARRAY that is filled with a default event,  the   *//* volume will start out at 100.0,  the IN time will default to the      *//* start of the cue,  etc., etc., etc.                                   *//* Example:   call Get.Default.Event (Event, Event.Type.Event);          *//********************************* $page *********************************/dcl Locate.Sequencer.Event                proc (array, fixed) external;dcl Expand.Sequencer.Event.Information    proc (array, fixed) external;dcl Get.Sequencer.Event.Information       proc (array) external;dcl Get.Next.Sequencer.Event.Information  proc (array) external;dcl Get.Prior.Sequencer.Event.Information proc (array) external;dcl Quickly.Get.Next.Sequencer.Event.Information  proc (array) external;dcl Quickly.Get.Prior.Sequencer.Event.Information proc (array) external;/* These three routines are the main routines for looking up event       *//* information from the sequence.                                        *//* In all cases,  they are passed a Sequencer Pointer in the first 4     *//* words of the array.                                                   *//*   Get.Sequencer.Event.Information - will get the info for the         *//*       specified event,  or if that event does not exist (ie there is  *//*       no event at that time),  it will get the information for the    *//*       next event in the sequence (it will return Get.Info.Next in     *//*       that case).                                                     *//*   Get.Next.Sequencer.Event.Information - is normally passed a pointer *//*       to an event that does exist.   That event is skipped,  and      *//*       the information for the next event in the sequence is returned  *//*       (or Get.Info.EOT if end-of-track reached).                      *//*   Get.Prior.Sequencer.Event.Information - is normally passed a        *//*       to an event that does exist.   The event immediately PRIOR      *//*       to that event is returned,  or a Get.Info.EOT if the start      *//*       of the track was reached.   Can also be used to find the end    *//*       of a track.                                                     *//*   Here are some sample uses:                                          *//*       1. use Get.Sequencer.Event.Information passing msb = 0, lsb = 0,*//*          and count = 0 to find the first event on the track.   Status *//*          will be Good.Event.Status (if an event starts at 0:0:0), or  *//*          will be Get.Info.Next,  or will be Get.Info.EOT if the       *//*          track is empty.                                              *//*       2. pass the pointer you got back from step 1 to                 *//*          Get.Next.Sequencer.Event.Information to get info about the   *//*          next event in the sequence.                                  *//*       3. use Get.Prior.Sequencer.Event.Information passing msb = (-1),*//*          lsb = (-1), count = (-1) to find the last event on a track   *//********************************* $page *********************************/dcl Remove.Sequencer.Event proc (array) external;/* Remove Sequencer Event is used to remove an event from the sequencer. *//* It is passed a Sequencer Pointer that identifies a certain note       *//* in the sequencer.   A note must exist in the sequencer on that track  *//* at that time in order for it to be deleted.                           *//* NOTE:  you MUST call Garbage.Collect.Event.List to actually free      *//* up all the storage that may be available after EVENTS are deleted.    *//* See possible status codes in SEQLITS.                                 *//* Note: several precautions must be taken when removing notes from      *//* the sequencer:                                                        *//*    1.  When removing multiple notes from the sequencer,  they might   *//*        have to be removed in reverse order.  This is because removing *//*        a particular note will change the address of additional notes  *//*        in the sequence on that track that start at the same time.     *//*    2.  If the event being deleted is an ILS or ILE record,  then      *//*        the entire independent loop is removed from the track.         *//*        This normally removes both the ILS and ILE record at the       *//*        same time.                                                     *//*    3.  When removing notes from the Live Click Track (if one), the    *//*        beat numbers that are displayed with other events will         *//*        likely have to be recomputed.                                  *//*************************************************************************/dcl Garbage.Collect.Event.Area proc (fixed) external;dcl Garbage.Collect.Event.List proc (fixed) external;/* Garbage Collect Event Area is used to rid the timbre area of any      *//* events that are no longer being used by a track.   Normally it is not *//* called directly - use Garbage Collect Event List                      *//* Garbage Collect Event List is used to garbage collect an entire       *//* sequencer track.   Call this routine after deleting an event from     *//* a track.   The sequencer is stopped,  the note list itself is         *//* cleaned up,  then the event storage area is purged of any event       *//* info that is not used any more.                                       *//* NOTE: sequencer motion is stopped as part of the garbage collect.     *//* The current sequencer position, however, is preserved.                *//* See possible status codes in SEQLITS.                                 *//********************************* $page *********************************/dcl Place.Event.In.Sequence proc (array) external;/* Place Event In Sequence is used to place an event on a particular     *//* sequence track.  If an event already exists at that sequencer         *//* time, the new event is put BEFORE the existing event.  That way       *//* the address of the new event will always be equal to the address      *//* that was passed to Place Event In Sequence.                           *//* note: the address of other events in the sequence on this track       *//* that start at the same time as this event may be changed by           *//* placing the event on this track.                                      *//* See possible status codes in SEQLITS.                                 *//* Special notes on placing events:                                      *//* 1.  ILPS - To place an independent loop on a track,  set up the       *//*     event record as follows:                                          *//*        event.track# = the track # (absolute) you want the loop on     *//*        event.time   = msb,lsb = start of ilp, COUNT MUST BE ZERO      *//*        event.type   = event.type.ilp                                  *//*        event.duration = msb,lsb must be the length of the loop        *//*                         in sequencer units                            *//*        other fields are not looked at for ILPS.                       *//*     NOTE: the sequencer is stopped for you when an ILP is placed      *//*        on a track (isn't that convenient?)                            *//* 2.   RTES - To place an RTE on a track, set up the event record       *//*      as follows:                                                      *//*         track#, time.msb, time.lsb, count ==> as needed.              *//*         event.type = event.type.rte                                   *//*         event.w1-event.w4 = construct 4-word note record as defined   *//*            for the effect.                                            *//*         all other information is not looked at                        *//* 3.   NOTES - to place a musical note on a track:                      *//*         If the track is empty,  allocate the track header and         *//*            copy the desired timbre to the track.                      *//*         track#, time.msb, time.lsb, count ==> as needed.              *//*         event.type = event.type.note                                  *//*         event.w1-event.w4 = construct 4-word note record for the      *//*            note.   Seqsou:Build.Note.Record may be handy to do this   *//*            for you.   Seqsou:Compute.Default.Note is a conventient    *//*            routine to get the correct duration for a sound file.      *//*            Set special tied bits, volume, etc. etc. etc. as needed.   *//*            Use Scale.Percent.To.RTE to get scaled velocity value.     *//*         all other information is not looked at                        *//********************************* $page *********************************//* 4.   CUES - to place a simple cue on a track:                         *//*         note: cues cannot be placed on music tracks.   Track must     *//*            be empty or must be a cuelist track.  Simple cue triggers  *//*            or complex cue events can be placed on the same track.     *//*         track#, time.msb, time.lsb, count ==> set to place the cue    *//*            trigger at the right time in the right place.              *//*         event.type = event.type.cue                                   *//*         event.w1-event.w4  ==>  these will be computed for you and    *//*            returned in the not record.  No need to set them.          *//*         event.key# - ==> not used.  will be set for you.              *//*         event.cue.id ==> you must get the ID of the cue in            *//*            question and pass it here.   If the cue does not exist     *//*            at the moment on the direct-to-disk,  then be sure to pass *//*            a cue.id of 0.   The cue will be placed correctly but      *//*            will not be heard (obviously).   If the cue does exist     *//*            on the DTD then you can use Locate.DTD.Cue to get its ID.  *//*         event.duration (msb,lsb) = not used for cue triggers.         *//*         event.priority = must be zero for now                         *//*         event.output   = also must be zero for now                    *//*         event.volume   = set to desired volume.  1000 = max.          *//*         event.pan      = also must be zero for now.                   *//*         event.cue.name = correct name must be stored here.            *//*                          Upper and lower case is ok (case is ignored) *//*                          But do not have any control characters       *//*                          in the name.                                 *//*         all other information (event in/out, caption) etc. is not     *//*            used for cue triggers.                                     *//********************************* $page *********************************//* 5.   EVENTS - to place a complex cue event on a cue track.            *//*         note: complex cue events cannot be placed on music tracks.    *//*            Track must be empty or must be a cuelist track.            *//*            Simple cue triggers or complex cue events CAN be placed    *//*            the same cuelist track.                                    *//*         track#, time.msb, time.lsb, count ==> set to place the event  *//*            to start at the right time in the right place.             *//*         event.type = event.type.event                                 *//*         event.w1-event.w4  ==>  these will be computed for you and    *//*            returned in the not record.  No need to set them.          *//*         event.key# - ==> not used.  will be set for you.              *//*         event.cue.id ==> you must get the ID of the cue in            *//*            question and pass it here.   If the cue does not exist     *//*            at the moment on the direct-to-disk,  then be sure to pass *//*            a cue.id of 0.   The cue will be placed correctly but      *//*            will not be heard (obviously).   If the cue does exist     *//*            on the DTD then you can use Locate.DTD.Cue to get its ID.  *//*         event.duration (msb,lsb) = ignored for placing events.        *//*         event.priority = must be zero for now                         *//*         event.output   = also must be zero for now                    *//*         event.volume   = set to desired volume.  1000 = max.          *//*         event.pan      = also must be zero for now.                   *//*         event.cue.name = correct name must be stored here.            *//*                          Upper and lower case is ok (case is ignored) *//*                          But do not have any control characters       *//*                          in the name.                                 *//*         event.in(msb,lsb) = pass a twos complement (signed) relative  *//*                          in samples                                   *//*         event.out(msb,lsb) = relative (signed) out time.              *//*         event.mark(msb,lsb) = relative (signed) time for offset       *//*                          point                                        *//*         event.fade(in,out) = set in milliseconds.                     *//*         event.spare1       = peak volume,  0 - 1000                   *//*         event.spare2       = sustain volume,  0 - 1000                *//*         event.caption    = store a caption string here if desired     *//********************************* $page *********************************/dcl Trigger.Event.For.Audition proc (array) external;/* Trigger Event For Audition is used to trigger an event without        *//* respect to the sequencer time base.   It plays the event at normal    *//* play speed.                                                           *//* note:  be sure to specify a legit synclavier track# in the            *//* event.track# field,  or put a 0 there.   If the track# is <> 0 then   *//* the Track Volume and Track Routing for that track are used to         *//* affect the cue or event routing and volume.                           *//* IN OTHER WORDS:  use a track # of 0 to trigger a cue or an event      *//* from the cue directory,  or set the track# as needed to here an       *//* event AS IT WOULD SOUND on that track.                                *//* of course,  for a music note,  the track# would be used to indicate   *//* which timbre to use for the note.  YOU MUST SET UP EVENT.W1           *//* THROUGH EVENT.W4 OF THE EVENT RECORD BEFORE AUDITIONING A MUSIC       *//* NOTE.                                                                 */dcl Stop.Event.Auditions proc external;/* Stop Event Auditions is used to stop the auditioning of events.       *//* Any event that is currently auditioning will be stopped.              *//*************************************************************************//* coming later - routines to scrub through events                       */