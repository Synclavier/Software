/* SYNDUMM1   $TITLE  Real time program dummy variables/routines   Modified:	2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202   10/18/90 - TSS - added stuff to decouple ttymod from promod   03/21/90 - PF  - optimize use of CLAV.PTR   03/09/90 - PF  - Increase MAX.INPUTS to 128   06/05/89 - TSS - Added interface stuff for Keyboard Mapping   09/29/88 - MWH - Add Remote Box interface variables   *//* to use this file by itself,  these other routines     *//*   must be defined elsewhere:                          *//*   RUN.SYN.LOOP:  PROC   PUBLIC; END;    (410-tty)  *//*   DCL MEM.SIZ    FIXED  PUBLIC;         (catswap)  *//*   ABORT.SCSI:    PROC   PUBLIC; END;    (lodmod )  */begin;   STOP.DISK:     PROC     PUBLIC; END;   PERFORM:       PROC     PUBLIC; END;   RUN.PROTOCOL:  PROC (I) PUBLIC; DCL I FIXED; END;   CHECK.FOR.PROTOCOL.STOP.BUTTON: PROC PUBLIC; END;end;begin;   DCL I FIXED;   insert ':synmods:globdcl';   insert ':synauxs:mouselit';   insert ':synmods:giddcl';   insert ':synmods:tformdcl';   DCL LAST.NOTE.KEY# FIXED PUBLIC;   DCL LAST.NOTE.VEL  FIXED PUBLIC;   DCL LAST.NOTE.TYPE FIXED PUBLIC;   dcl Map.There fixed public;   dcl MapDev    fixed public;   dcl MapSec    fixed public;   dcl TTMap.Ptr fixed public;   dcl VMap.Ptr  fixed public;   dcl Clav.Ptr  fixed public;   DCL TTIME.MIN FIXED PUBLIC; /* TRANSIT TIME REQUIRED TO ACHIEVE MAX VOLUME */   TTMAP.PTR=ALLOC.EXAMOUNT(3); /* TRANSIT TIME & PRESSURE MAPS */   VMAP.PTR =ALLOC.EXAMOUNT(2); /* MIDI VELOCITY MAP IN & OUT MAPS */   CLAV.PTR =ALLOC.EXAMOUNT(((MAX.INPUTS*NUM.KEYS)+255)/256);   COMPUTE.MIDI.VELMAPS: PROC PUBLIC SWAPABLE; /* COMPUTES NEW VELOCITY TO VOLUME TABLE */   END COMPUTE.MIDI.VELMAPS;   COMPUTE.SYNC.TTIME.MAP:  PROC (VEL.MODE) PUBLIC SWAPABLE; /* COMPUTES A LOOKUP TABLE FOR TRANSIT TIME TO VOLUME */      DCL VEL.MODE FIXED;   END COMPUTE.SYNC.TTIME.MAP;   TRD.LEN=34;   TRD.PTR=ALLOC.EXAMOUNT(TRD.LEN);    DCL TBUT.PTR                      FIXED PUBLIC;   TBUT.PTR=ALLOC.EXAMOUNT(1);   DO I=0 TO 31;      write(mam)=tbut.ptr;         /* update track button table */      write(mal)=I;      WRITE(MD )=I+2;   END;   dcl bas.ptr fixed public;   bas.PTR=ALLOC.EXAMOUNT(1);   DCL CACHE.PTR               FIXED     PUBLIC; /* ptr to next free word in cache */   DCL CACHE.SECS              FIXED     PUBLIC; /* cache length in sectors */   DCL CACHE.BASE     (1)      FIXED     PUBLIC; /* base sector/bin of cache */   DCL NUM.SNDS.IN.CACHE       FIXED     PUBLIC; /* number of sound files in cache */   DCL (ERAS)                        FIXED PUBLIC;   DCL (MOVE.SPEED)                  FIXED PUBLIC;   DCL (SAMP.SPEED)                  FIXED PUBLIC; SAMP.SPEED=1000;   DCL (SAMP.CLICK.RATE)             FIXED PUBLIC; SAMP.CLICK.RATE=500;   DCL (SAMP.CRM)                    FIXED PUBLIC; SAMP.CRM=4;   DCL (SAMP.BPM)                    FIXED PUBLIC; SAMP.BPM=4;   DCL (SM.HRS,SM.MIN,SM.SEC)        FIXED PUBLIC;   /* SAMPLED INFO                 */   DCL (SM.FRA,SM.BIT,SM.MODE)       FIXED PUBLIC;   /* FOR USE BY INTERRUPT ROUTINE */   DCL (BSTAT.PTR)                   FIXED PUBLIC;   /* ( 1) LOOK UP TABLE FOR CLAVIER BUTTON PANEL STATUS */   /*  following extracted from ':synmods:prodcl' */   dcl Allow.Proto.Msgs         fixed public;   dcl protocol.in.ptr          fixed public;  /* ext mem buffer for D50 protocol input stream */   dcl p.in.wptr                fixed public;  /* ptr to next free loc in input buffer         */   dcl p.in.rptr                fixed public;  /* ptr to next good message byte to be read     */   dcl p.in.prior               fixed public;   dcl protocol.out.ptr         fixed public;  /* ext mem buffer for protocol output stream */   dcl use.protocol.for.d50     fixed public;  /* use protocol for d50 output */   dcl num.of.new.packets       fixed public;  /* number of unprocessed D50 packets in buffer */   dcl ok.to.xmit.mac.protocol  fixed public;  /* Set if Mac II wants protocol info */   dcl disable.protocol.output  fixed public;  /* set to non-zero to stop output processing */   dcl our.timbre            fixed public;   dcl our.bank              fixed public;   lookup.timbre.name:proc(x,y) public;      dcl x fixed; dcl y array;      y(0)=0;   end;   dcl sequencer.control.reg    fixed public;   dcl call.convert             fixed public;   dcl call.terminate           fixed public;   dcl cnv.sta                  fixed public;   store.new.timbre.name:proc(name) public; dcl name array; end;   leave.synclavier.program:proc public; end;   display.err :proc (x) PUBLIC;      dcl x fixed;   end;   DISPLAY.LINE.25.ERROR: proc (id,attr,str1,arg1,arg2,arg3) public;      dcl id     fixed;      dcl attr   fixed;      dcl str1   array;      dcl arg1   fixed;      dcl arg2   fixed;      dcl arg3   fixed;   end DISPLAY.LINE.25.ERROR;   /* needed by lod mod */   real.time.loop:        proc  public; end;   display.track.buttons: proc public; end;   dcl smpte.onoff        fixed public;   dcl ext.clock.mode     fixed public;   dcl time.base.mode     fixed public;   dcl play.time.msb      fixed public;   dcl play.time.lsb      fixed public;   dcl play.time.acu      fixed public;   dcl next.click         fixed public;   dcl d16tim             fixed public;   dcl smpte.track.rate   fixed public;   dcl smpte.rate.accum   fixed public;   dcl smpte.mode.rate    fixed public;   dcl new.motion         fixed public;   dcl lod.play.tracks      fixed public; lod.play.tracks=-1;   dcl lod.recd.tracks      fixed public;   dcl mark.button.msb      fixed public;   dcl mark.button.lsb      fixed public;   dcl mark.button.disabled fixed public;   dcl first.play.time.msb  fixed public;   dcl first.play.time.lsb  fixed public;   dcl first.play.time.acu  fixed public;   dcl recd.trk             fixed public;   dcl trkindex(15) fixed public;   trkindex(0) = 2;   advance.time.base: proc (numc); /* a dummy play time advance routine */      dcl numc fixed;      if (move=0)&(play<>0) then do;         load samp.speed; mul numc; mwait; div 1000; numc=res;         play.time.lsb=play.time.lsb+numc;         if play.time.lsb ilt numc then play.time.msb=play.time.msb+1;         do while play.time.lsb>=next.click;            next.click=next.click+samp.click.rate;         end;      end;      else if (move<>0)&(play<>0) then do;         load abs(move.speed); mul numc; mwait; div 1000; numc=res;         if move.speed<0 then do;            if play.time.lsb ilt numc then do;               if play.time.msb=0               then do;                  play.time.lsb=0;                   play=0; recd=0; pnch=0; move=0; move.speed=0;               end;               else do;                  play.time.msb=play.time.msb-1;                  play.time.lsb=play.time.lsb-numc;               end;            end;            else play.time.lsb=play.time.lsb-numc;            do while play.time.lsb<=(next.click-samp.click.rate);               next.click=next.click-samp.click.rate;            end;         end;         else do;            play.time.lsb=play.time.lsb+numc;            if play.time.lsb ilt numc then play.time.msb=play.time.msb+1;            do while play.time.lsb>=next.click;               next.click=next.click+samp.click.rate;            end;         end;      end;   end advance.time.base;   when d03int then begin;      dcl i fixed;      real.milliseconds=real.milliseconds+5;      if (play\move)<>0 then call advance.time.base(5);   end;   COMPUTE.DSEL.BUTTON :PROC PUBLIC; END;   dcl par.numt fixed public;   trk.head.lookup:proc(a,b) public;      dcl (a,b) fixed;      return 0;   end;   tim.head.lookup:proc(a,b) public;      dcl (a,b) fixed;      return 0;   end;   trk.head.store:proc(a,b,c) public;      dcl (a,b,c) fixed;      write(mam)=0;      return 0;   end;   tim.head.store:proc(a,b,c) public;      dcl (a,b,c) fixed;      write(mam)=0;      return 0;   end;   p.lookup:proc (a) public;      dcl a fixed;      return 0;   end;   dcl tim.ptr               fixed public;   DCL POWERS.MSB       DATA PUBLIC   (   15,    1,    0,   0,  0, 0,0);  /* FOR 1,000,000 # OF NOTES LEFT */   DCL POWERS.LSB       DATA PUBLIC   (16960,34464,10000,1000,100,10,1);   CONSTRUCT.SYNC.MODE.SWITCH.STRING:proc (str) PUBLIC SWAPABLE;      dcl str  array;      dcl tmp  fixed;      str(0)=0;      call append.to.str(str, 'Internal');      call append.to.str(str, '|Ext 50hz');      call append.to.str(str, '|Beat');      tmp=3;      call append.to.str(str, '|MIDI In');      call pid(sync.mode.switch0+tmp, 3);      tmp=tmp+1;      call append.to.str(str, '|MIDI Aux');      call pid(sync.mode.switch0+tmp, 4);      tmp=tmp+1;      call append.to.str(str, '|SMPTE');      call pid(sync.mode.switch0+tmp, 5);      tmp=tmp+1;   end CONSTRUCT.SYNC.MODE.SWITCH.STRING;   /* set.synclav.sync.mode: pass a mode variable which came from fetch.switch */   SET.SYNCLAV.SYNC.MODE: proc (mode) PUBLIC SWAPABLE;      dcl mode fixed;      mode = gid(sync.mode.switch0+mode);              /* get code for entry */      if (mode=5) then do;                 /* smpte desired                  */         if (smpte.onoff=0) then do;       /* smpte desired, not on          */            smpte.onoff=1;            ext.clock.mode=0;         end;      end;      else do;                          /* something other than smpte desired */         if (smpte.onoff<>0) then do;      /* smpte is on - turn off         */            smpte.onoff=0;         end;         if ext.clock.mode<>mode then do;  /* acual mode change */            ext.clock.mode = mode;         end;      end;   end SET.SYNCLAV.SYNC.MODE;   GET.SYNCLAV.SYNC.MODE:proc returns (fixed) PUBLIC SWAPABLE;      dcl mode fixed;      if (smpte.onoff<>0)       then mode=5;      else mode=ext.clock.mode;      do i=0 to 5;         /* see which switch pos is this sync mode */         if (gid(sync.mode.switch0+i)=mode)         then return i;      end;      return 0;            /* mode mismatch?                         */   end GET.SYNCLAV.SYNC.MODE;end;