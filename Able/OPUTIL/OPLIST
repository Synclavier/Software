/*   Optical Disk Listing Utility   by Kip Olson, June 1988   Modified:   03/07/89 - cj - prevent control character printout from date field   10/05/96 - cj - recompiled for tahiti-4*/insert ':-xpl:reldat';insert ':-xpl:literals';insert ':-xpl:asciilit';insert ':-xpl:optlits';insert ':-xpl:termut';insert ':-xpl:catrtns';insert ':-xpl:fileio';insert ':synauxs:tformlit'; /* synclavier program stuff - ack! */dcl POWERS data (10000,1000,100,10,1);dcl Path1   data ('W0:.INDEX:' );dcl Path2   data ('W0:.INDEX1:');dcl PageMax    lit '62';dcl PageWidth  lit '80';dcl PageHeight lit '66';dcl FileList file;dcl CatList  file;dcl Header(H#Rec_Length - 1) fixed;dcl DisplayingCategory boolean;dcl DisplayingAllInfo  boolean;dcl VolumeName(H#Name_Max)   fixed;dcl IndexName(132 / 2)    fixed;dcl LineCount fixed;dcl PageCount fixed;#newline: proc; /* generate a new line, and header if needed */   dcl i fixed;   crlf;   LineCount = LineCount + 1;   if LineCount ige PageMax then do; /* print page header */      wchar(a.FF); /* send a form feed */      PageCount = PageCount + 1;      crlf;      pstring('Page '); unum(PageCount,3);      pstring('  '); pstring(VolumeName);      crlf;      if (DisplayingCategory)      then pstring('Category: ');      else pstring('File:     ');      pstring(IndexName);      crlf;      if DisplayingAllInfo then do;         crlf;         do i = 0 to 79;            wchar(a.minus);         end;         crlf;         pstring('  Name    S/M   Sec.   MB  Caption');         crlf;         do i = 0 to 79;            wchar(a.minus);         end;         LineCount = 7;      end;      else LineCount = 4;      crlf;   end;end #newline;dcl newline lit 'call #newline';APPENDC:  proc(str,ch) fixed;    /* add ch to end of str */   dcl str fixed array;   dcl ch  fixed;   call pbyte(str,str(0),ch);   str(0)=str(0)+1;   return str(0);   /* return new length of string */end APPENDC;APPEND.TO.STR: proc(s1,s2) fixed;  /* appends s2 to s1 */   dcl (s1,s2) fixed array;   dcl i       fixed;   do i=0 to s2(0)-1;      call pbyte(s1,s1(0)+i,byte(s2,i));   end;      s1(0)=s1(0)+s2(0);   return(s1(0));          /* return length of new string */end APPEND.TO.STR;CONV.FIXED.TO.STR:  proc(val,dp,field.width,format,str) fixed;  /* put a decimal number into str */   dcl val          fixed; /* 16-bit value to convert */   dcl dp           fixed; /* decimal point position */   dcl field.width  fixed; /* string length used for filling */   dcl format       fixed; /* collection of formatting control bits */   dcl str          array; /* output string */   dcl outstate     fixed; /* output state control */   dcl orig.len     fixed; /* original length of STR */   dcl digit        fixed;   dcl sign.flag    fixed;   dcl temp.str (4) fixed;   dcl extra.char   fixed;   dcl i            fixed;   /* NOTE:  This routine will append at least (DP + SIGN + 2) chars */   /*        to the end of the output string.                        */   if  ((format&cf#justmask)=cf#right) /* right justifying output   */   and ((format&cf#fillmask)=0)        /* but no fill specified     */   then format=format\cf#spfill;       /* default to use space fill */   if (format&cf#appendmask)=0 then str(0)=0; /* erase current string to start */   orig.len=str(0);   if ((format&cf#signmask)<>0) then do;      if (val < 0) then do;         val = -val;         sign.flag=(-1);      end;      else sign.flag=(+1);   end;   temp.str(0)=0;                   /* init temp str to null */   if  ((format&cf#justmask)=cf#left)   /* left justifying output */   and (sign.flag<>0)                   /* and doing signed conversion */   then do;      if      sign.flag< 0 then call appendc(str,a.minus);      else if sign.flag<>0 then call appendc(str,a.sp);      sign.flag=0; extra.char=1;   end;   outstate=0;                      /* not printing digits yet */   do i=0 to 4;                     /* loop over digits - build temp string left justified */      if (i+dp)=5 then do;         if (outstate=0)&(sign.flag<>0) then do;            if      sign.flag< 0 then call appendc(temp.str,a.minus);            else if sign.flag<>0 then call appendc(temp.str,a.sp);            sign.flag=0;         end;         if outstate=0 then call appendc(temp.str,a.0);         call appendc(temp.str,a.period);      end;      digit=0;                      /* assume zero */      if val IGE powers(i) then do; /* non-zero digit */         write("5") = val; write("7") = powers(i); digit=read("5"); val=read("4");         outstate=1;                /* start printing */         if sign.flag<>0 then do;            if      sign.flag< 0 then call appendc(temp.str,a.minus);            else if sign.flag<>0 then call appendc(temp.str,a.sp);            sign.flag=0;         end;      end;      if (outstate<>0) or (i=4) or ((i+dp)>=5)       then call appendc(temp.str,a.0+digit);   end;                           /* of digit loop */   if field.width=0 then field.width=temp.str(0)+extra.char; /* defaults to min length */   if (temp.str(0)+extra.char) igt field.width /* out string is too long */   then do;                                    /* string won't fit in field */      temp.str(0)=field.width-extra.char;      /* limit it to max len */      do i=0 to temp.str(0)-1;                 /* loop over remaining chars */         digit=byte(temp.str,i);         if (digit>=a.0) & (digit<=a.9)    /* replace all digits  */         then call pbyte(temp.str,i,a.star); /* with asterisks      */      end;   end;   if (format&cf#justmask)=cf#left then call append.to.str(str,temp.str);      if (format&cf#fillmask)<>0 then do;      do i=temp.str(0)+extra.char to field.width-1; /* put fill chars into output string */         if (format&cf#spfill)<>0         then call appendc(str,a.sp);        /* fill with spaces */         else call appendc(str,a.0);     /* fill with zeroes */      end;   end;   if (format&cf#justmask)=cf#right then call append.to.str(str,temp.str);      return (str(0)-orig.len);      /* return # of chars appended to output string */end CONV.FIXED.TO.STR;GetName: proc(index,length,buf,s); /* get name from buffer */   dcl index  fixed;   dcl length fixed;   dcl buf    fixed array;   dcl s      fixed array;   dcl i      fixed;   do i = 0 to length - 1; /* copy name over */      s(1 + i) = buf(index + i);   end;   i = shl(length,1);   do while (i <> 0) and (byte(s,i - 1) = 0);      i = i - 1;   end;   s(0) = i; /* store length of name */end;Print_Num: proc(number); /* print a 2-digit number padded with leading zeros */   dcl number fixed; /* number to print */   if number < 10 then wchar(a.0); /* print leading zero */   unum(number,0); /* print number */end Print_Num;Print_Date: proc(Date); /* print date */   dcl Date   fixed; /* date to print */   dcl (i,j)  fixed;   dcl Months data ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC   '); /* month names */   call Print_Num(Date and "H1F"); /* print day */   wchar(a.minus);   j = (shr(Date,5) and "HF")*3; /* get index into month name array */   if j>=36 then j = 36;         /* limit in case bad date          */   do i = 0 to 2;      wchar(byte(Months,j + i)); /* print character */   end;   wchar(a.minus);   call Print_Num(shr(Date,9)); /* print year */end Print_Date;Print_Time: proc(Time); /* print time */   dcl Time fixed; /* Time to print */   call Print_Num(shr(Time,11) and "HF"); /* print hours */   wchar(a.colon);   call Print_Num(shr(Time,5) and "H3F"); /* print minutes */   wchar(a.colon);   call Print_Num(shl(Time and "H1F",1)); /* print seconds */   if Time < 0 then pstring(' PM'); else pstring(' AM'); /* print AM/PM */end Print_Time;Print_String: proc(Start,Length,Buf); /* print string from buffer */   dcl Start  fixed; /* first word of string */   dcl Length fixed; /* byte length of string */   dcl Buf    fixed array;   dcl (i,j)  fixed;   do i = 0 to Length - 1; /* loop over characters of name */      j = Buf(Start + shr(i,1)); /* get word of name */      if (i and "1") = 0 then j = (j and "377"); else j = shr(j,8);      if j <> 0 then wchar(j); else wchar(a.SP);   end;end Print_String;Print_Entry: proc(Buf); /* print out a directory entry */   dcl Buf     fixed array;   dcl s(10)   fixed;   dcl (i,j)   fixed;   newline;   pstring('  ');   call Print_String(L$Name,8,Buf); /* print file name */   if (Buf(L$Flags) and "2000") <> 0 /* check for stereo (bit 10 of this word) */   then pstring('  S'); /* stereo */   else pstring('  M'); /* mono */   i = Buf(L$Sample_Rate) * 10;    /* sampling rate * 100 */   if (Buf(L$Flags) and "2000") <> 0 then i = i * 2; /* check for stereo (bit 10 of this word) */   write("5") = Buf(L$LS_SecLen) - 3; /* sector length of file minus header */   write("6") = 256;   write("324") = read("5");   write("7") = i;   j = read("5") + (read("4") ige shr(i,1));  /* seconds * 10 */   if j = 0 then j = 1; /* at least display 0.1 */   s(0) = 0;   call Conv.Fixed.To.Str(j,1,6,CF#Unsigned|CF#Append|CF#Right|CF#SPFill,s);   pstring(s);   write("5") = Buf(L$LS_SecLen); /* calculate megabytes */   write("6") = 100;   write("324") = read("5");   write("7") = 2048;   j = read("5") + (read("4") ige shr(2048,1));   if (j = 0) and (Buf(L$LS_SecLen) <> 0) then j = 1; /* at least .01 MBytes */   s(0) = 0;   call Conv.Fixed.To.Str(j,2,6,CF#Unsigned|CF#Append|CF#Right|CF#SPFill,s);   pstring(s);   i = Buf(L$Caption); /* get length of caption */   pstring('  ');   call Print_String(L$Caption + 1,i,Buf); /* print caption */end Print_Entry;Print_Cat: proc(SA,Buf); /* print files in category */   dcl SA       boolean;   dcl Buf      fixed array;   dcl NameLen  fixed;   dcl NumFiles fixed;   dcl (index,sector,word) fixed;   dcl (j,p) fixed;   j = GetW(CatList); /* get forward pointer */   NameLen = GetW(CatList); /* get length of category name */   do j = 1 to shr(NameLen + 1,1); /* store category name */      IndexName(j) = GetW(CatList);   end;   IndexName(0) = NameLen;   newline;   pstring(IndexName); /* print name */   NumFiles = GetW(CatList); /* get no. file pointers */   do j = 0 to NumFiles - 1; /* print files in this category */      index = GetW(CatList); /* get record index */      write("5") = index; /* multiply index by record length to get word offset in file list */      write("6") = L#Rec_Length;      write("324") = read("5");      write("7") = 256; /* divide by 256 to get sector offset */      sector = read("5"); /* store sector offset */      word = read("4"); /* store word offset in that sector */      call Seek(FileList,Header(H$LS_DataStart) + sector,3); /* seek to appropriate sector in file list */      call Seek(FileList,shl(word,1),1); /* sector to appropriate word in this sector */      if SA then do; /* show all information for this entry */         call FRead(Buf,shl(L#Rec_Length,1),1,FileList); /* get file list record */         call Print_Entry(Buf);      end;      else do; /* show only file name */         call FRead(Buf,shl(L#Name_Max,1),1,FileList); /* get file list record */         if (j and "H7") = 0 then newline;         pstring('  ');         call Print_String(L$Name,8,Buf); /* print file name */      end;      if not term_idle then do;         if rchar = 0 then call exit(-1);      end;   end;   j = GetW(CatList); /* get back pointer */end Print_Cat;Catalog: proc(SF,SC,SA,Buf); /* print out catalog of files on optical disk */   dcl (SF,SC,SA) boolean;   dcl Buf fixed array;   dcl (i,j) fixed;   call GetName(H$Name,H#Name_Max,Header,VolumeName);   newline;   newline;   pstring('Volume Name:    '); pstring(VolumeName); newline;   newline;   pstring('Creation Date:  '); call Print_Date(Header(H$Date)); newline;   pstring('Creation Time:  '); call Print_Time(Header(H$Time)); newline;   pstring('Caption:        '); call Print_String(H$Caption + 1,shl(Header(H$Caption),1),Header); newline;   newline;   pstring('No. Files:      '); unum(Header(H$FileCount),0); newline;   pstring('No. Categories: '); unum(Header(H$CatCount),0); newline;   newline;   if SF then do; /* print file list */      DisplayingCategory = false;      LineCount = PageMax; /* force new page */      call Seek(FileList,Header(H$LS_DataStart),3); /* seek to beginning of file list */      do i = 0 to Header(H$FileCount) - 1; /* get all files from file list */         call FRead(Buf,shl(L#Rec_Length,1),1,FileList); /* get file list record */         call GetName(L$Name,L#Name_Max,Buf,IndexName);         if SA then do; /* print all information for this entry */            call Print_Entry(Buf);         end;         else do; /* print only name */            if (i and "H7") = 0 then newline;            pstring('  ');            call Print_String(L$Name,8,Buf); /* print file name */         end;         if not term_idle then do;            if rchar = 0 then call exit(-1);         end;      end;   end;   if SC then do; /* print category list */      DisplayingCategory = true;      LineCount = PageMax; /* force new page */      call Seek(CatList,Header(H$LS_CatStart),3); /* seek to beginning of category list */      do i = 0 to Header(H$CatCount) - 1; /* get all categories from category list */         call Print_Cat(SA,Buf); /* print category */      end;   end;end Catalog;GetFileName: proc(Name,Buf) returns (boolean); /* get file name from user */   dcl Name fixed array;   dcl Buf  fixed array;   do while 1;      get_string('Enter name of index file or <RETURN> to quit: ', TRUE, Name, 64); crlf; /* get file name */      if Name(0) = 0 then return (false); /* die */      if (locate(Name,1)) and (F#Type = t#index) then return (true); /* found it */      Buf(0) = 0;      call Append.To.Str(Buf,Path1);      call Append.To.Str(Buf,Name);      if (locate(Buf,1)) and (F#Type = t#index) then do;         Name(0) = 0;         call Append.To.Str(Name,Buf);         return (true); /* found it */      end;      Buf(0) = 0;      call Append.To.Str(Buf,Path2);      call Append.To.Str(Buf,Name);      if (locate(Buf,1)) and (F#Type = t#index) then do;         Name(0) = 0;         call Append.To.Str(Name,Buf);         return (true); /* found it */      end;      pstring('File '); pstring(Name); pstringr(' not found - please try again');   end;end;/* Main program: Oplist */dcl Name(32)     fixed;dcl Buf(511)     fixed;dcl done         boolean;dcl redirection  fixed;dcl ShowFileList boolean;dcl ShowCatList  boolean;dcl ShowAllInfo  boolean;dcl Printing     boolean;redirection = directed_output; /* save initial output redirection */redirection_word = no_redirection; /* send output to terminal */clear_screen;pstring('Optical Disk Listing Utility  version of ');pstringr(rel.date);crlf;if GetFileName(Name,Buf) then do;   FileList = FOpen(Name,'r'); 			/* try to open index file for input */   if FileList = NullF then do;      pstring('File '); pstring(Name); pstringr(' could not be opened');      call exit(-1);   end;   CatList = FOpen(Name,'r'); /* try to open index file for input */   call Seek(FileList,0,3); /* seek to index file header */   call FRead(Header,shl(H#Rec_Length,1),1,FileList); /* get index file header */   ShowFileList = Get_YN('Display File List [Y(es) or N(o)]? '); crlf;   ShowCatList =  Get_YN('Display Category List [Y(es) or N(o)]? '); crlf;   ShowAllInfo =  Get_YN('Display all file information [Y(es) or N(o)]? '); crlf;   Printing =     Get_YN('Send output to printer [Y(es) or N(o)]? '); crlf;   DisplayingAllInfo = ShowAllInfo;   if Printing then redirection_word = 1; /* redirect output to printer, if neccessary */   screen_size(PageHeight,PageWidth); /* set screen size */   call Catalog(ShowFileList,ShowCatList,ShowAllInfo,Buf);   wchar(a.FF);end;