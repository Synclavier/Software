/*   Optical Disk Repair Utility   note:  This source can be compiled to create either:       1: OPREPAIR   (repairs disks from write errors)       2: ????????   (change serial # or remove it   )       3: ????????   (change name of optical disk    )   see literals defined below.   by Kip Olson, June 1988   modified:  02/27/89 - c. jones to handle error recovery,  header errors.   10/05/96 - CJ - Recompiled with new date for Tahiti-4*/insert ':-xpl:reldat';insert ':-xpl:asciilit';insert ':-xpl:termutil';insert ':-xpl:scsirout';insert ':-xpl:catrtns';insert ':-xpl:scsicmds';insert ':-xpl:optical';insert ':-xpl:messages';insert ':-xpl:intrprtr';dcl debug         lit '0';   /* set to 1 causes a prompt before writing to disk */dcl remove.serial lit '0';   /* set to 1 to compile 'SERIAL # CHANGE' program */dcl OpticalLevel lit '10'; /* level to repair */dcl BufEntryMax  fixed;                       /* buf size in blocks    */dcl ObufSiz      lit '(shl(BufEntryMax,1))';  /* buf size in sectors   */dcl Rsiz         lit '256';dcl Hbuf(Rsiz)   fixed;dcl Dbuf(Rsiz)   fixed;dcl milliseconds  fixed;dcl seconds       fixed;when d03int then do;   milliseconds = milliseconds + 5;   if milliseconds = 1000 then do;      milliseconds = 0;      seconds = seconds + 1;   end;end;PrintError: proc(msg); /* print error message */   dcl msg fixed array; /* message to display */	dcl SenseMes (MESSAGE_BUF_SIZE/2) fixed;	dcl CatMes   (MESSAGE_BUF_SIZE/2) fixed;		get_sense_code_message        (S$SenseKey, SenseMes);	add_optical_sense_code_message(S$SenseKey, SenseMes);	get_cat_code_message          (C#Status,   CatMes  );	add_optical_cat_code_message  (C#Status,   CatMes  );	   pstring  ('ERROR: ');   pstringr (msg);  	pstring  ('   S$SenseKey = '); pnum (S$SenseKey, 6); pstring ('  '); pstringr(SenseMes);	pstring  ('   C#Status   = '); pnum (c#status,   6); pstring ('  '); pstringr(CatMes  );	flush_term;end PrintError;PrintName: proc;   dcl (i,j) fixed;   do i = 0 to H#Name_Max - 1; /* print out volume name */      j = gbuf(H$Name + i);      if (j and "HFF") <> 0 then wchar(j);      if shr(j,8) <> 0 then wchar(shr(j,8));   end;end PrintName;PrintCaption: proc;   dcl (i,j) fixed;   do i = 1 to 32; /* print out volume caption */      j = gbuf(H$Caption + i);      if (j and "HFF") <> 0 then wchar(j);      if shr(j,8) <> 0 then wchar(shr(j,8));   end;end PrintCaption;/* VerifyOpticalRegion - this routine is used to read through a *//* section of the optical disk.  It returns a description of    *//* the region indicating where the region has been written,     *//* where the region has never been written, and where the       *//* written data can still be read.                              *//* it returns the following information:                        *//*                                                              *//*    return value     -  true : was able to verify             *//*                     -  false: could not verify region (no    *//*                               optical configured,  no disk   *//*                               in drive,  etc.)               *//*                                                              *//*    in RegionList    - 0:  number of words of region info,    *//*                           including itself (ie 1, 6, 11 ...) *//*                     followed by 5 word records:              *//*                     - word 0:   0 = blank                    *//*                                 1 = written,  can read       *//*                                 2 = written,  cannot read    *//*                                 3 = other error during read  *//*                     - word 1:   sector msb                   *//*                     - word 2:   sector lsb                   *//*                     - word 3:   sector length msb            *//*                     - word 4:   sector length lsb            */dcl v$blank   lit '0';dcl v$written lit '1';dcl v$bad     lit '2';dcl v$error   lit '3';dcl v$type    lit '0';dcl v$smsb    lit '1';dcl v$slsb    lit '2';dcl v$lmsb    lit '3';dcl v$llsb    lit '4';dcl v$size    lit '5';VerifyOpticalRegion: proc(SecMsb, SecLsb, LenMsb, LenLsb,                           RegionList, RegionListSize, Level) public swap;   dcl SecMsb             fixed;   /* sector address msb                */   dcl SecLsb             fixed;   dcl LenMsb             fixed;   /* sector length                     */   dcl LenLsb             fixed;   dcl RegionList         array;   /* info returned here                */   dcl RegionListSize     fixed;   /* size (words) of region list array */   dcl Level              fixed;   /* level for reading & writing       */   dcl (i,j,k,l,m,n,o,p)  fixed;   dcl prior.type         fixed static;   dcl prior.base.msb     fixed static;   dcl prior.base.lsb     fixed static;   dcl prior.len.msb      fixed static;   dcl prior.len.lsb      fixed static;   dcl list.ptr           lit 'RegionList(0)';   dcl op.size            fixed static;   dcl time               fixed;   /* Routine to erase verify info    */   EraseVerifyInfo: proc;      pstring('                                              '); wchar(a.cr);   end EraseVerifyInfo;   /* Routine to push block onto list */   PushType: proc(RegionList, SecMsb, SecLsb);      dcl RegionList array;      dcl SecMsb     fixed;      dcl SecLsb     fixed;      if (prior.len.msb\prior.len.lsb)=0  /* nothing to push if no prior */      then return true;                   /* region                      */      if (list.ptr + v$size) IGT RegionListSize   /* give a partial printout  */      then return true;                           /* rather than bombing      */      RegionList(list.ptr+v$type) = prior.type;      RegionList(list.ptr+v$smsb) = prior.base.msb;      RegionList(list.ptr+v$slsb) = prior.base.lsb;      RegionList(list.ptr+v$lmsb) = prior.len.msb;      RegionList(list.ptr+v$llsb) = prior.len.lsb;      prior.base.msb = SecMsb;      prior.base.lsb = SecLsb;      prior.len.msb  = 0;      prior.len.lsb  = 0;      list.ptr = list.ptr + v$size;      return true;   end PushType;   /* initialize for read of first sector */   if RegionListSize = 0   then return 0;   prior.base.msb = SecMsb;   prior.base.lsb = SecLsb;   prior.len.msb  = 0;   prior.len.lsb  = 0;   list.ptr       = 1;   op.size        = ObufSiz;   prior.type = v$written; /* assume section begins with read-able data */   /* read on block to get the process going */   j = TransferOptical(S$ExtendedRead, SecMsb, SecLsb, 2, Level);   if j = S$UnitAttention   then j = TransferOptical(S$ExtendedRead, SecMsb, SecLsb, 2, Level);   if  (j <> S$Good       )   and (j <> S$BlankCheck )   and (j <> S$MediumError)   then return false;   /* now verify media region: */   time = seconds;                  /* detect flaky media that would take */                                    /* several days to read through the   */                                    /* blank area                         */   do while (LenMsb\LenLsb) <> 0;      i = op.size;                        /* try to process 1 bufferload */      if (LenMsb = 0) and (i IGT LenLsb)  /* limit to length of          */      then i = LenLsb;                    /* region to check             */      if prior.type = v$blank      /* if prior block was blank,  look  */      then do;                     /* for more blank region            */         if i <> 2 then do;        /* look for empty blocks quickly    */            j = SearchEmptyBlocks(SecMsb, SecLsb, i, i, Level);         end;         else do;                  /* else use read to check 1 blank blk */            j = TransferOptical(S$ExtendedRead, SecMsb, SecLsb, i, Level);            if j = S$BlankCheck then j = true;            else                     j = false;         end;         if j = true then do;      /* more blanks found - add to block */            pnum(i,0); pstring(' Blank Sectors at '); pnum(SecMsb,0); pstring(' '); pnum(SecLsb,0); pstring('                '); wchar(a.cr);            prior.len.lsb = prior.len.lsb + i;            if prior.len.lsb ILT i then prior.len.msb = prior.len.msb + 1;            SecLsb = SecLsb + i;            if SecLsb ILT i then SecMsb = SecMsb + 1;            if LenLsb ILT i then LenMsb = LenMsb - 1;            LenLsb = LenLsb - i;            op.size = shl(op.size,2);   /* try larger operation next */            if op.size IGT ObufSiz      /* time up to limit of       */            then op.size = ObufSiz;     /* ObufSiz                   */            /* detect degraded media after 2 minutes of finding blank */            /* sectors one at a time.   Assume the rest is blank      */            if (seconds - time) IGT 120 then do;               prior.len.lsb = prior.len.lsb + LenLsb;               if prior.len.lsb ILT LenLsb then prior.len.msb = prior.len.msb + 1;               prior.len.msb = prior.len.msb + LenMsb;               SecLsb = SecLsb + LenLsb;               if SecLsb ILT LenLsb then SecMsb = SecMsb + 1;               SecMsb = SecMsb + LenMsb;               LenLsb = 0; LenMsb = 0;            end;         end;         else if i <> 2                     /* else try smaller block    */         then do;                           /* size to most quickly      */            op.size = shr(i,2) & "177776";  /* find error                */            if op.size = 0 then op.size = 2;         end;         else do;                   /* else muse be 1 non-blank sector   */            if PushType(RegionList, SecMsb, SecLsb) = false then return false;            prior.type = v$written; /* try a read next time through */         end;      end;      else do;                     /* not blank - try to read      */         j = TransferOptical(S$ExtendedRead, SecMsb, SecLsb, i, Level);         if j = S$Good then do;            pnum(i,0); pstring(' Good  Sectors at '); pnum(SecMsb,0); pstring(' '); pnum(SecLsb,0); pstring('                '); wchar(a.cr);            if prior.type <> v$written     /* push block of medium errors  */            then do;               if PushType(RegionList, SecMsb, SecLsb) = false then return false;               prior.type = v$written;     /* now we have good data        */            end;            prior.len.lsb = prior.len.lsb + i;            if prior.len.lsb ILT i then prior.len.msb = prior.len.msb + 1;            SecLsb = SecLsb + i;            if SecLsb ILT i then SecMsb = SecMsb + 1;            if LenLsb ILT i then LenMsb = LenMsb - 1;            LenLsb = LenLsb - i;            op.size = shl(op.size,2);   /* try larger operation next */            if op.size IGT ObufSiz      /* time up to limit of       */            then op.size = ObufSiz;     /* ObufSiz                   */         end;         else if i <> 2                     /* else try smaller block    */         then do;                           /* size to most quickly      */            op.size = shr(i,2) & "177776";  /* find error                */            if op.size = 0 then op.size = 2;         end;         else if j = S$BlankCheck then do;            if PushType(RegionList, SecMsb, SecLsb) = false then return false;            prior.type = v$blank;        /* now look for blanks               */            time       = seconds;        /* reset blank timer here            */         end;         else if j = S$MediumError then do;            if prior.type <> v$bad     /* push prior block                  */            then do;               if PushType(RegionList, SecMsb, SecLsb) = false then return false;               prior.type = v$bad;     /* now we have medium errors         */            end;            pnum(i,0); pstring(' Bad   Sectors at '); pnum(SecMsb,0); pstring(' '); pnum(SecLsb,0); pstring('                '); wchar(a.cr);            prior.len.lsb = prior.len.lsb + i;            if prior.len.lsb ILT i then prior.len.msb = prior.len.msb + 1;            SecLsb = SecLsb + i;            if SecLsb ILT i then SecMsb = SecMsb + 1;            if LenLsb ILT i then LenMsb = LenMsb - 1;            LenLsb = LenLsb - i;         end;         else do;                  /* un-identified errors            */            if prior.type <> v$error     /* push prior block                */            then do;               if PushType(RegionList, SecMsb, SecLsb) = false then return false;               prior.type = v$error;     /* now we have unkown errors         */            end;            pnum(i,0); pstring(' Bad   Sectors at '); pnum(SecMsb,0); pstring(' '); pnum(SecLsb,0); pstring(' '); pnum(j,0); pstring('                '); wchar(a.cr);            prior.len.lsb = prior.len.lsb + i;            if prior.len.lsb ILT i then prior.len.msb = prior.len.msb + 1;            SecLsb = SecLsb + i;            if SecLsb ILT i then SecMsb = SecMsb + 1;            if LenLsb ILT i then LenMsb = LenMsb - 1;            LenLsb = LenLsb - i;         end;      end;   end;   if PushType(RegionList, SecMsb, SecLsb) = false then return false;   call EraseVerifyInfo;   return true;end VerifyOpticalRegion;PrintOpticalRegion: proc(RegionList, Name) public swap;   dcl RegionList    array;   dcl Name          array;   dcl (i,j,k)       fixed;   if RegionList(0) <= 1 then do;      pstringr('No information is available');      crlf;      return;   end;   pstring('Description of Region '); pstringr(Name); crlf;   flush_term;   i = 1;   do while i ILT RegionList(0);      print shr(RegionList(i+v$llsb),1),;      do case (RegionList(i+v$type));         print ' Blank   Blocks at ',;         print ' Good    Blocks at ',;         print ' Bad     Blocks at ',;         print ' Unknown Blocks at ',;      end;      print regionlist(i+v$smsb), regionlist(i+v$slsb);      i = i + v$size;   end;   print;end PrintOpticalRegion;/* Remove Optical Serial - Removes serial */RemoveOpticalSerial: proc (level) swap;   dcl level                  fixed;   dcl header(H#Rec_Length-1) fixed;   dcl i                      fixed;   if ReadHeader(level) = 0 then return false;   do i = 0 to H#Rec_Length - 1; /* copy header info into buffer */      header(i) = gbuf(i);   end;   pstring('Enter new serial number --');   flush_term;   input header(H$Serial);   return WriteHeader(header, level);end RemoveOpticalSerial;/* Rename Optical Volume */CleanName: proc(OldName,NewName,Max);   dcl OldName fixed array; /* name to check */   dcl NewName fixed array; /* space to put cleaned name */   dcl Max     fixed; /* max no. words in name */   dcl (i,ch)  fixed; /* word length of name */   do i = 0 to shl(Max,1) - 1; /* loop over name */      if i ilt OldName(0) then do; /* process character */         ch = byte(OldName,i); /* get character */         if (ch >= l.a) and (ch <= l.z) then ch = ch - "40"; /* make upper case */      end;      else ch = 0; /* pad with nulls */      call pbyte(loc(addr(NewName(0)) - 1),i,ch);   end;end CleanName;RenameOpticalVolume: proc(level);   dcl level                  fixed;   dcl newname(64)            fixed;   dcl header(H#Rec_Length-1) fixed;   dcl HeaderName(H#Name_Max) fixed;   dcl i                      fixed;   if ReadHeader(level) = 0 then return false;   do i = 0 to H#Rec_Length - 1; /* copy header info into buffer */      header(i) = gbuf(i);   end;   retry2:;   pstring('Enter new volume name --');   flush_term;   linput newname;   newname(0) = newname(0) - 1;   /* remove CR */   if not Valid_FileName(newname) then do; /* not a valid file name */      pstring('Invalid file name.   Try again.');      crlf;      goto retry2;   end;   call CleanName(newname,HeaderName,H#Name_Max); /* clean and fill name */   do i = 0 to H#Name_Max - 1; /* volume name */      header(H$Name + i) = HeaderName(i);   end;   return WriteHeader(header, level);end RenameOpticalVolume;RepairDisk: proc(Level, EntryCount, AnyVolErrors);   dcl Level        fixed;   /* level of drive                  */   dcl EntryCount   fixed;   /* no. of entries to copy          */   dcl AnyVolErrors fixed;   /* true if already has vol errors  */   dcl (MS_OldDirStart,LS_OldDirStart) fixed; /* start of original directory area */   dcl Header   (H#Rec_Length     - 1) fixed; /* old header */   dcl Entry    fixed;                        /* entry to process */   dcl chunk    fixed;   dcl i        fixed;   dcl j        fixed;   dcl k        fixed;   dcl Dir_Size fixed;   dcl Cur_Size fixed;   noroom: proc;      crlf;      pstringr('There is no room on this optical volume for additional');      pstringr('directory entries.');      crlf;      pstringr('This optical volume is full.');      crlf;      pstringr('You will not be able to store any more sound files on');      pstringr('this optical volume.');      crlf;      pstringr('OPREPAIR halted.');   end noroom;   if ReadHeader(level) = false then do;      pstringr('System error occurred reading header a second time.');      pstringr('Did you change the disk?');      flush_term;      call exit(-1);   end;   do i = 0 to H#Rec_Length - 1; /* copy header into buffer */      Header(i) = gbuf(i);   end;   pstring('Repairing volume ');   call PrintName;   crlf;   MS_OldDirStart = Header(H$MS_DirStart); /* get location of original directory */   LS_OldDirStart = Header(H$LS_DirStart);   /* look up size of current directory (in entries): */   Cur_Size = shr(Header(H$LS_DirLen), 1) \ shl(Header(H$MS_DirLen),15);   /* Compute what size directory would represent     */   /* 1% of available storage left:                   */   if  (Header(H$MS_DataLen) ige 199)   then Dir_Size = 65534;     /* so limit to 65534 entries */   else do;      write("5") = Header(H$LS_DataLen); /* divide sectors avail by 200 */      write("4") = Header(H$MS_DataLen); /* to get # of blocks that     */      write("7") = 200;                  /* equals 1% of space          */      Dir_Size = read("5");   end;   /* Expand truncated directories back up to 1%: */   if Cur_Size ILT Dir_Size then do;      Cur_Size = Dir_Size;      pstring('Expanding directory (had been truncated) to: ');      pnum(Cur_Size, 0); pstring(' entries.'); crlf;   end;      /* Make directory larger if it is more than    */   /* 1/2 full:                                   */   if shr(Cur_Size,1) ILE EntryCount then do;      if EntryCount IGE 32768 then Cur_Size = 65534;      else Cur_Size = shl(EntryCount,1);      pstring('Expanding directory (was almost full) to: ');      pnum(Cur_Size, 0); pstring(' entries.'); crlf;   end;   /* Store that away as directory size in new header */   Header(H$MS_DirLen) = shr(Cur_Size, 15);   Header(H$LS_DirLen) = shl(Cur_Size,  1);RETRY: /* re-entry point if directory write fails below */   /* Allocate new directory area at end of disk: */   Header(H$MS_DirStart) = Header(H$MS_DataStart) + Header(H$MS_DataLen); /* compute end of data area */   Header(H$LS_DirStart) = Header(H$LS_DataStart) + Header(H$LS_DataLen);   if Header(H$LS_DirStart) ilt Header(H$LS_DataStart)    then Header(H$MS_DirStart) = Header(H$MS_DirStart) + 1;   Header(H$MS_DirStart) = Header(H$MS_DirStart) - Header(H$MS_DirLen); /* subtract length of directory to get start address */   if Header(H$LS_DirStart) ilt Header(H$LS_DirLen) then Header(H$MS_DirStart) = Header(H$MS_DirStart) - 1;   Header(H$LS_DirStart) = Header(H$LS_DirStart) - Header(H$LS_DirLen);   if Header(H$MS_DirStart) < 0   /* check for underflow */   then do;      call noroom;      flush_term;      call exit(-1);   end;   Header(H$MS_DataLen) = Header(H$MS_DataLen) - Header(H$MS_DirLen); /* subtract length of directory from length of data area */   if Header(H$LS_DataLen) ilt Header(H$LS_DirLen) then Header(H$MS_DataLen) = Header(H$MS_DataLen) - 1;   Header(H$LS_DataLen) = Header(H$LS_DataLen) - Header(H$LS_DirLen);   if Header(H$MS_DataLen) < 0    /* check for underflow */   then do;      call noroom;      flush_term;      call exit(-1);   end;   write("5") = shl(Header(H$MS_DataLen),15) or shr(Header(H$LS_DataLen),1); /* calculate size of data area gap (in 1024-byte sectors) */   write("4") = shr(Header(H$MS_DataLen),1);   write("7") = 1000; /* assume .1% of the data sectors will be bad */   chunk = shl(read("5"),1); /* size of data area gap (in 512-byte sectors) */   if Header(H$LS_DataLen) ilt chunk then Header(H$MS_DataLen) = Header(H$MS_DataLen) - 1; /* subtract data gap from data area */   Header(H$LS_DataLen) = Header(H$LS_DataLen) - chunk;   if Header(H$MS_DataLen) < 0    /* check for underflow */   then do;      call noroom;      flush_term;      call exit(-1);   end;   pstring('Verifying new Directory Region (');   pnum(Header(H$MS_DirStart),0); pstring(' ');pnum(Header(H$LS_Dirstart),0); pstring(') ...'); crlf;      /* see if a prior OPREPAIR attempt was done here: */   k = TransferOptical(S$ExtendedRead, Header(H$MS_DirStart), Header(H$LS_DirStart),                       2, Level);      if (k = S$Good       )  /* good or medium error would mean either */   or (k = S$MediumError)  /* disk is full, or prior oprepair try    */   then do;      /* oops - this point of the disk is not blank.  See if the reason */      /* is because there is data written to the disk, or if we are     */      /* seeing the effects of an earlier OPREPAIR messup               */      /* Back up to the new logical end of disk,  and see if there      */      /* is some blank area there:                                      */      i = Header(H$MS_DataStart) + Header(H$MS_DataLen); /* compute end of data area */      j = Header(H$LS_DataStart) + Header(H$LS_DataLen);      if j ilt Header(H$LS_DataStart)       then i = i + 1;      k = TransferOptical(S$ExtendedRead, i, j, 2, Level);            if (k <> S$BlankCheck )      then do;         pstring('Verify Code: '); pnum(k,0); crlf;         call noroom;         flush_term;         call exit(-1);      end;      pstringr('Skipping over prior OPREPAIR attempt...');      goto RETRY;   end;   crlf;   pstring('Copying directory information.  Number of entries: '); pnum(EntryCount,0); crlf;   if debug then do;      flush_term;      print 'New Directory Start: ',Header(H$MS_dirstart), Header(h$ls_dirstart);      print '              Len  : ',Header(H$MS_dirlen),   header(H$LS_dirlen);      print 'New Data      Start: ',Header(H$MS_datastart),header(H$LS_datastart);      print '              Len  : ',Header(H$MS_datalen),  header(H$LS_datalen);      crlf;      flush_term; input i;   end;   Entry = 0;   do while Entry ilt EntryCount; /* copy over all entries *//**/  try.last.segment.again:;      chunk = EntryCount - Entry; /* find no. entries to move */      if chunk igt BufEntryMax then chunk = BufEntryMax; /* limit to size of buffer */      O$MS_DirStart = MS_OldDirStart; /* set to original directory */      O$LS_DirStart = LS_OldDirStart;      pstring('Reading entries '); unum(Entry,0);      pstring(' to '); unum(Entry + chunk - 1,0); crlf;      S$SenseKey = ReadEntries(Entry,chunk,Level); /* read entries *//**/  if  (S$SenseKey = S$MediumError)     /* if we get a medium error *//**/  and ((Entry + chunk) = EntryCount)   /* reading the last segment *//**/  and (chunk IGT 1)                    /* and more left in this chunk *//**/  then do;/**/     EntryCount = EntryCount - 1;/**/     crlf;/**/     pstringr('Retrying last entry...');/**/     goto try.last.segment.again;/**/  end;      if S$SenseKey <> S$Good then do; /* an error occurred */         crlf;         pstringr('OPREPAIR is having trouble reading the directory of');         pstringr('your optical volume.   You may try to run OPREPAIR');         pstringr('again, or you might wish to try running OPREPAIR');         pstringr('on a different system.');         crlf;         pstringr('Please contact New England Digital Customer Service');         pstringr('to have your Optical Disk system tested.');         crlf;         pstring ('S$SenseKey = '); pnum (S$SenseKey, 0); crlf;         pstringr('OPREPAIR halted.');         flush_term;         call exit(-1);      end;      O$MS_DirStart = Header(H$MS_DirStart); /* set to new directory */      O$LS_DirStart = Header(H$LS_DirStart);      pstring('Writing entries '); unum(Entry,0);      pstring(' to '); unum(Entry + chunk - 1,0); crlf;      S$SenseKey = WriteEntries(Entry,chunk,Level); /* write entries */      if S$SenseKey <> S$Good then do; /* an error occurred */         call PrintError('Could not write directory entries');         if (S$SenseKey = S$MediumError) or (S$SenseKey = S$HardwareError) or (S$SenseKey = S$BlankCheck) then do; /* unrecoverable write error occurred */            crlf;            pstringr('Another "unrecoverable write error" has occurred, which may mean the optical');            pstringr('disk drive laser focus is out of alignment and needs to be adjusted by Customer');            pstringr('Service. You can elect to try a repair again (which will take up another 1%');            pstringr('of your disk), or you can exit the program by answering "No" below.');            crlf;            i = Get_YN('Do you want to attempt another repair [Y(es) or N(o)]? '); crlf;            crlf;            if i then GOTO RETRY;         end;         return (false);      end;      Entry = Entry + chunk;   end;   pstringr('All directory entries copied');   O$MS_DirStart = MS_OldDirStart; /* set to original directory */   O$LS_DirStart = LS_OldDirStart;   i = 0;   RetryHeader: ;   if WriteHeader(Header,Level) then do; /* write new header to disk */      if (i            <> 0)      or (AnyVolErrors <> 0) then do;         crlf;         pstringr('OPREPAIR has completed the repair of your disk.');         pstringr('However, the type of error that was encountered means');         pstringr('this optical disk can only be used with Software 2.0');         pstringr('or later.');         crlf;         pstringr('You may read sound files from this disk using earlier');         pstringr('software, BUT:');         crlf;         pstringr('  ===>   Do NOT write any more sound files to this disk');         pstringr('         using software prior to Release 2.0!');      end;      crlf;      pstringr('Repair Completed.');      flush_term;      return true;   end;   if (S$SenseKey = S$Good) and (C#Status = E#Dir_Full)   then do;      call noroom;      flush_term;      return;   end;   pstringr('Retrying header...');   i = i + 1;   if i < 10 then goto RetryHeader;   crlf;   pstringr('OPREPAIR is having trouble writing the Volume Header on');   pstringr('this optical disk.  You may try to run OPREPAIR again,');   pstringr('but you should have your Optical Disk system tested');   pstringr('before doing so.');   crlf;   pstringr('Please contact New England Digital Customer Service');   pstringr('to have your Optical Disk system tested.');   crlf;   pstringr('OPREPAIR halted.');   flush_term;   call exit(-1);end RepairDisk;/* Main Program */dcl (i,j,ExtBlocks,IntBlocks) fixed;dcl (AnyVolErrors)            fixed;enable;   /* for timers */i = core(c#contab + c#vstart) + core(c#contab + c#vlngth) + core(c#contab + c#stklen); /* first free word in internal memory */IntBlocks = shr(loc.load - i,8 + 1); /* find max no. entries in internal memory */ExtBlocks = shr(core(loc.emsize) - core(c#contab + c#swplen),1); /* find max no. entries in external memory */clear_screen;pstring('Optical Disk Rename/Repair Utility  version of ');pstringr(rel.date);if ExtBlocks igt IntBlocks then do; /* more external memory */   BufEntryMax = ExtBlocks; /* put optical disk buffer in external memory */   call set_optbuf(0,1);   pstring('Using external memory ('); pnum(ExtBlocks,0); pstringr(')');end;else do; /* more internal memory */   BufEntryMax = IntBlocks; /* put optical disk buffer in internal memory */   call set_optbuf(i,0);   pstring('Using internal memory ('); pnum(ExtBlocks,0); pstringr(')');end;crlf;flush_term;pstringr('Please stand by while we perform a quick check of the');pstringr('optical disk hardware...');/* make sure the optical is configured in: */call init_optical_controller;							/* init controller */if find_device(OpticalLevel) = 0 then do;   crlf;   pstringr('The optical disk is not correctly configured in your system.');		if (interp_is_running != 0)	{		pstringr('Please use InterChange to tell the system where');		pstringr('the optical disk is connected to you system.');	}	else	{		pstringr('Please run the CONFIGUR program to tell the system where');		pstringr('the optical disk is connected to you system.');	}	   crlf;   pstringr('OPREPAIR cannot repair your disk at this time.');   flush_term;   call exit(-1);end;/* now see if the hardware responds */retry1:;if ReadHeader(OpticalLevel) = false then do;   if S$SenseKey = S$UnitAttention then goto retry1;   if (S$SenseKey = S$ArbFailed  )   or (S$SenseKey = S$D24NotThere)   or (S$SenseKey = S$BadBusState)   or (S$SenseKey = S$BadInitiator)   then do;      crlf;      pstringr('The SCSI hardware in your system is not operating correctly.');      pstringr('This problem is not necessarily related to your optical');      pstringr('disk.   You will need to have your system serviced before');      pstringr('OPREPAIR will work');      crlf;      call PrintError('Scsi Problem');      flush_term;      call exit(-1);   end;   if (S$SenseKey = S$SelFailed  )   then do;      crlf;      pstringr('Your optical disk drive did not respond when we tried');      pstringr('to talk to it.  Most likely the power is off, or');      pstringr('the cables connecting your optical drive to your system');      pstringr('are not connected properly or are malfunctioning.');      crlf;      pstringr('You will need to have your system serviced before');      pstringr('OPREPAIR will work.');      crlf;      call PrintError('Selection Failed');      flush_term;      call exit(-1);   end;   if (S$SenseKey = S$SelFailed  )   or (S$SenseKey = S$DeviceBusy )   then do;      crlf;      pstringr('Your optical disk drive did not respond when we tried');      pstringr('to talk to it.  Most likely the power is off, or');      pstringr('the cables connecting your optical drive to your system');      pstringr('are not connected properly or are malfunctioning.');      crlf;      pstringr('You will need to have your system serviced before');      pstringr('OPREPAIR will work.');      crlf;      call PrintError('Selection Failed');      flush_term;      call exit(-1);   end;   if (S$SenseKey = S$NotReady)   then do;      crlf;      pstringr('Your optical disk drive says that it is not ready to');      pstringr('be used.  Either there is no optical disk cartridge');      pstringr('inserted in the unit, or it has not been Started');      pstringr('with the START/STOP button.');      crlf;      pstringr('Check the optical disk cartridge, or press the START/STOP');      pstringr('button and try OPREPAIR again.');      crlf;      call PrintError('Not Ready');      flush_term;      call exit(-1);   end;   if (S$SenseKey = S$BlankCheck)   then do;      crlf;      pstringr('The optical disk cartridge that is inserted in your');      pstringr('drive appears to be blank.  It apparently has never');      pstringr('been formated.');      crlf;      pstringr('You do not need to OPREPAIR this disk.');      crlf;      call PrintError('Blank Check');      flush_term;      call exit(-1);   end;   if (S$SenseKey <> S$MediumError)   then do;      crlf;      pstringr('Your optical disk drive is reporting that an error has');      pstringr('occurred inside the unit.  Your system must be serviced');      pstringr('before OPREPAIR can function.');      crlf;      call PrintError('Hardware Error/Unknown');      flush_term;      call exit(-1);   end;   /* Medium error during reading of header --? */   crlf;   pstringr('The Volume Header on your optical volume cannot be read');   pstringr('at this time (medium error).  You will not be able to');   pstringr('use this disk.');   crlf;   pstringr('Please contact New England Digital and report that the');   pstringr('Volume Header could not be read.  They may be able to');   pstringr('retrieve some of the data from this volume.');   crlf;   call PrintError('Medium Error with Volume Header');   flush_term;   call exit(-1);end;pstringr('Hardware seems okay.');crlf;pstringr('Here is some information about this optical disk volume:');crlf;pstring('Name     : '); call PrintName; crlf;pstring('Caption  : '); call PrintCaption; crlf;pstring('Serial # : '); Pnum(gbuf(H$Serial),0); crlf;flush_term;       print   'Directory:',O$MS_DirStart, O$LS_DirStart;print   '   length:',O$MS_DirLen,   O$LS_DirLen;print   'Data     :',O$MS_DataStart, O$LS_DataStart;print   '   length:',O$MS_DataLen,   O$LS_DataLen;print;if not Get_YN('Do you want to continue [Y(es) or N(o)]? ') then do;   crlf;   call exit(0); /* get out here */end;crlf; crlf;/* Verify Header Area */pstringr('We are now going to analyze this optical volume to see what');pstringr('condition it is in.  This may take 1-2 minutes if there are');pstringr('numerous blocks that cannot be read.');crlf;pstringr('Analyzing Header Region...');if VerifyOpticalRegion(0, 0, 0, shl(HeaderGapSize,1),                           Hbuf, Rsiz, OpticalLevel) = false then do;   pstringr('Could not analyze Header Region');   flush_term;   call exit(-1);end;pstringr('Header Region has been analyzed'); crlf;call PrintOpticalRegion(Hbuf, '"Header Region"');flush_term;/* Verify Directory Area */pstringr('Analyzing Directory Region...');if VerifyOpticalRegion(O$MS_DirStart, O$LS_DirStart, O$MS_DirLen, O$LS_DirLen,                          Dbuf, Rsiz, OpticalLevel) = false then do;   pstringr('Could not analyze Directory Region');   flush_term;   call exit(-1);end;pstringr('Directory Region has been analyzed'); crlf;call PrintOpticalRegion(Dbuf, '"Directory Region"');flush_term;/* now check header region to see if we can even oprepair the disk: */i = hbuf(0);                          /* get size of stat record for header */if (i < (1+v$size))                   /* if not at least one v$ record      */or (hbuf(i-v$size+v$type) <> v$blank) /* or header did not end in blanks    */or (hbuf(i-v$size+v$llsb) ILT 20)     /* at least 20 of them                */then do;                              /* than cannot op repair.             */   crlf;   pstringr('There is no room available on your optical volume for');   pstringr('OPREPAIR to store a new Volume Header.');   crlf;   pstringr('You may not add any sound files to this volume.');   crlf;   pstringr('You may still use this Cartridge as a READ-ONLY volume.');   crlf;   pstringr('There is nothing else OPREPAIR can do that would allow you');   pstringr('to store additional information on this volume.');   crlf;   pstringr('OPREPAIR completed.');   flush_term;   call exit(-1);end;i = dbuf(0);                       /* get size of stat record for dir    */if (i < (1+v$size))                /* if not at least one v$ record      */or (dbuf(1+v$type) <> v$written)   /* or no good records at start        */then do;                           /* then no directory to copy over     */   O$EntryCount = 0;end;else O$EntryCount = shr(Dbuf(1+v$llsb),1) \ shl(Dbuf(1+v$lmsb),15);  /* # of entries to copy */if remove.serial <> 0 then do; /* change serial # program */   crlf;   if not Get_YN('Do you want to re-serialize this optical volume [Y(es) or N(o)]? ') then do;      crlf;      call exit(0); /* get out */   end;   crlf;   crlf;   pstringr('Changing serial number...');   if RemoveOpticalSerial(OpticalLevel) then do;      pstringr('Serial number has been changed.');   end;   else call PrintError('Could not write new header');   flush_term;   call exit(0);end;else if rename.disk <> 0 then do; /* change volume name */   crlf;   if not Get_YN('Do you want to rename this optical volume [Y(es) or N(o)]? ') then do;      crlf;      call exit(0); /* get out */   end;   crlf;   crlf;   pstringr('Renaming disk ...');   if RenameOpticalVolume(OpticalLevel) then do;      pstringr('Disk has been renamed.');   end;   else call PrintError('Could not write new header');   flush_term;   call exit(0);end;else do;   /* OPREPAIR program */   pstringr('We are now ready to OPREPAIR this disk.');   crlf;   if not Get_YN('Do you want to repair this optical volume [Y(es) or N(o)]? ') then do;      crlf;      call exit(0); /* get out */   end;   crlf;   crlf;   /* See if header area can be used with prior software: */   i = hbuf(0);                          /* get size of stat record for header */   if (i <> (1+v$size+v$size))           /* if not exactly two v$ records      */   or (hbuf(1+v$type) <> v$written)      /* or first few not readable          */   or (hbuf(i-v$size+v$type) <> v$blank) /* or header did not end in blanks    */   then AnyVolErrors = 1;   else AnyVolErrors = 0;   call RepairDisk(OpticalLevel, O$EntryCount, AnyVolErrors); /* recover optical disk on level 10 */end;