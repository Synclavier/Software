/* Output Routines for the Optical Copy Utility   by Kip Olson, July 1988*/#pc: proc(ch); /* print character */   dcl ch fixed; /* character to print */   if (OutputDev and TerminalDev) <> 0 then do; /* output to terminal */      wchar(ch);   end;   if (OutputDev and PrinterDev) <> 0 then do; /* output to printer */      redirection_word = 1; /* redirect output to printer */      wchar(ch);      redirection_word = no_redirection; /* cancel redirection */   end;   if (OutputDev and FileDev) <> 0 then do; /* output to file */      call pbyte(Line,Line(0),ch); /* add character to line */      Line(0) = Line(0) + 1;   end;end #pc;dcl pc lit 'call #pc';#newline: proc; /* start a new line */   if (OutputDev and TerminalDev) <> 0 then do; /* output to terminal */      crlf;   end;   if (OutputDev and PrinterDev) <> 0 then do; /* output to printer */      redirection_word = 1; /* redirect output to printer */      crlf;      redirection_word = no_redirection; /* cancel redirection */   end;   if (OutputDev and FileDev) <> 0 then do; /* output to file */      call FPutS(Line,LineNum,OutFile); /* output line to file */      LineNum = LineNum + 1;      Line(0) = 0;      LogSaved = false; /* log contents not necessarily saved to disk now */   end;end #newline;dcl newline lit 'call #newline';#ps: proc(s); /* print string */   dcl s fixed array; /* string to print */   dcl i fixed;   do i = 0 to s(0) - 1;      pc(byte(s,i));   end;end #ps;dcl ps lit 'call #ps';#pn:  proc(n,field) public; /* output a signed number (-32768 to 32767) */   dcl (n,i,r)    fixed; /* n:  value to print */   dcl (field,go) boolean; /* field:  field size */   dcl sign       fixed; /* true for negative numbers */   dcl #divisors  data (-10000,-1000,-100,-10,-1); /* powers of ten */   do i=1 to field-6; /* print out any necessary leading spaces */      pc(a.sp);   end;   sign=0; /* assume no minus sign */   if n<0 then sign=1; /* input number is negative */   else do; /* input number is positive */      n=(-n); /* use negative number so that -32768 won't blow up */      if field-6 >= 0 then pc(a.sp); /* print space */   end;   go=0; /* suppress leading zeroes */   do i=0 to 4; /* loop over 5 digits */      r=n/#divisors(i);      if r>0 then do; /* digit is non-zero */         if (not go) and (sign) then pc(a.minus); /* print minus sign now */         go=true; /* turn on printing */         n=n-r*#divisors(i); /* reduce the number */      end;      if (go) or (i=4)               then pc(a.0+r); /* print digit */      else if field-((4+sign)-i) > 0 then pc(a.sp); /* or print space */   end; /* of digits loop */end #pn;dcl pn lit 'call #pn';#pln: proc(ms,ls,field); /* print an unsigned 32-bit number */   dcl (ms,ls)   fixed; /* number to print */   dcl field     fixed; /* field width */   dcl (i,r,go)  fixed;   dcl #ms_divisors data (15258, 1525,  152,   15,    1,    0,   0,  0, 0,0); /* powers of ten */   dcl #ls_divisors data (51712,57600,38528,16960,34464,10000,1000,100,10,1);   do i = 1 to field - 10; pc(a.sp); end; /* print out any necessary leading spaces */   go = false; /* suppress leading zeroes */   do i = 0 to 9; /* loop over 10 digits */      r = 0; /* assume digit is zero */      do while ((ms IGT #ms_divisors(i)) /* must simulate unsigned 32-bit divide */         or    ((ms  =  #ms_divisors(i)) and (ls IGE #ls_divisors (i))));         ms = ms - #ms_divisors(i);         if ls ilt #ls_divisors(i) then ms = ms - 1;         ls = ls - #ls_divisors(i);         r = r + 1;      end;      if r <> 0 then go = true;      if (go) or (i = 9) then pc(a.0 + r); /* print digit */      else if field - (9 - i) > 0 then pc(a.sp); /* or print space */   end; /* of digits loop */end #pln;dcl pln lit 'call #pln';#pt: proc(MS_Secs,LS_Secs,FieldWidth,ShowSeconds,AMPM); /* print time elapsed */   dcl (MS_Secs,LS_Secs) fixed; /* no. seconds elapsed */   dcl FieldWidth        fixed; /* display field width */   dcl ShowSeconds       boolean; /* TRUE to show seconds */   dcl AMPM              boolean; /* TRUE to show AM/PM, FALSE to show 24 hour time */   dcl (hours,minutes,seconds) fixed;   dcl i                 fixed;   PrintNum: proc(Num); /* print a number less than 100 */      dcl Num fixed; /* number to print */      pc(a.0 + (Num / 10));      pc(a.0 + (Num mod 10));   end PrintNum;   write("5") = LS_Secs; /* load total seconds */   write("4") = MS_Secs;   write("7") = 60;   seconds = read("4"); /* no. seconds */   write("5") = read("5");   write("7") = 60;   minutes = read("4"); /* no. minutes */   write("5") = read("5");   write("7") = 60;   hours = read("4"); /* no. hours */   write("5") = read("5");   FieldWidth = FieldWidth - (1 + 2 + (ShowSeconds * 3) + (AMPM * 3)); /* subtract colon, minutes and maybe seconds field */   if FieldWidth < 0 then FieldWidth = 0;   i = hours;   if AMPM then do; /* deal with AM/PM stuff */      if hours = 0 then i = 12;      else if hours ige 13 then i = hours - 12;   end;   pn(i,FieldWidth); /* print hours */   pc(a.colon);   call PrintNum(minutes); /* print minutes */   if ShowSeconds then do; /* print seconds */      pc(a.colon);      call PrintNum(seconds);   end;   if AMPM then do; /* deal with AM/PM stuff */      if hours ilt 12 then ps(' AM'); else ps(' PM');   end;end #pt;dcl pt lit 'call #pt';PrintDTL: proc(DevAdr); /* print device,target,lun of SCSI address */   dcl DevAdr fixed; /* device address to print */   pc(a.0 + (shr(DevAdr,4) and "HF")); pc(a.comma);   pc(a.0 + (DevAdr and "HF")); pc(a.comma);   pc(a.0 + (shr(DevAdr,8) and "HF"));end PrintDTL;PrintCatError:  proc; /* prints out catalog routine error messages */   dcl space_on_disk        data (' Space on Disk');   dcl is_not_on_disk       data ('is not on disk');   dcl number_out_of_bounds data (' number out of bounds! <<');   print.device:  proc(dev); /* print the device name */      dcl dev fixed;      dev = shr(dev,8); /* shift into LS byte */      pc(byte('*FRW',shr(dev,1))); pc(a.0 + (dev and "1"));   end print.device;   print.name: proc;      if f#name (0) <> 0 then do;         ps(f#name); pc(a.sp);      end;   end print.name;   do case (c#status); /* branch on catalog status */      ps('>> No catalog error! <<');     /* E#None */      ps('Disk is unreadable'); /* E#OS */      ps('>> No catalog buffer allocated! <<'); /* E#Buffer */      ps('>> No catalog in memory! <<'); /* E#No_Dir */      do;                                            /* E#No_Config */         ps('Device ');         if f#name (0) = 0         then call print.device(c#ms_sector); /* print device name */         else ps(f#name);         ps(' is not in configuration');      end;      ps('No floppy disk in drive');     /* E#No_Floppy */      do;                                            /* E#FCB */         ps('>> FCB'); ps(number_out_of_bounds);      end;      do;                                            /* E#Level */         ps('>> Level'); ps(number_out_of_bounds);      end;      do;                                            /* E#Storage */         ps('No Available'); ps(space_on_disk);      end;      do;                                            /* E#CStorage */         ps('No Contiguous'); ps(space_on_disk);      end;      ps('No Room for More Entries in Catalog'); /* E#Dir_Full */      do;                                            /* E#Invalid */         ps('Validity Error in Catalog ');         if not (((c#ms_sector and "HFF") = 0) and (c#ls_sector = 0)) then do; /* not top-level catalog */            if (c#ms_sector = core(loc.ucat + 1)) and (c#ls_sector = core(loc.ucat)) /* error occurred on current catalog */            then do; ps(location(loc.ccnm)); pc(a.sp); end; /* print current catalog name */            else call print.name; /* print given name */         end;         ps('on device '); call print.device(c#ms_sector);      end;      ps('Invalid character in filename'); /* E#Name */      ps('>> Duplicate file name! <<');  /* E#Duplicate */      do;                                            /* E#No_File */         ps('File '); call print.name; ps(is_not_on_disk);      end;      do;                                            /* E#Not_Cat */         ps('File '); call print.name; ps('is not a subcatalog');      end;      ps('Incorrect format for treename'); /* E#Treename */      do;                                            /* E#No_Path */         ps('Subcatalog '); call print.name; ps(is_not_on_disk);      end;      ps('File type must match for Replace'); /* E#Type */      ps('Disk is write-protected'); /* E#Protect */      ps('Subcatalog cannot be larger than 1,048,575 sectors'); /* E#Too_Large */   end;end PrintCatError;PrintError: proc; /* print various errors */   if S$SenseKey = S$Good then do; /* no sense - must be in c#status */      if c#status ilt 1000 /* catalog routines error */      then call PrintCatError;      else do case c#status - 1000;         ps('Volume header in incorrect format'); /* e#bad_volume */         ps('Index file header in incorrect format'); /* e#bad_index */         ps('No index file open for this volume'); /* e#no_index */         ps('Volume changed, need to remount'); /* e#volume_changed */         ps('Current index file not up to date'); /* e#not_uptodate */         ps('Volume already formatted'); /* e#formatted */      end;   end;   else if S$SenseKey > 0 then do; /* SCSI sense key */      do case S$SenseKey;         ; /* S$Good */         ps('Recovered Error'); /* S$RecoveredError */         ps('Drive not ready - Cartridge not loaded'); /* S$NotReady */         ps('Medium Failure - Cartridge is defective'); /* S$ MediumError */         ps('Hardware Failure - Drive is defective'); /* S$HardwareFailure */         ps('Illegal Request - System Software is defective'); /* S$Illegal Request */         ps('Cartridge changed during copy'); /* S$Unit Attention */         ps('Cartridge write-protected'); /* S$DataProtect */         ps('Cartridge not formatted'); /* S$Blank Check */      end;   end;   else do; /* Connection failure */      if S$SenseKey = S$BadDevice      then ps('Drive not in configuration');      else do case abs(S$SenseKey);         ; /* S$GoodConnect */         ps('Arbitration failed'); /* S$ArbFailed */         ps('Drive not responding - check power and cabling'); /* S$SelFailed */         ps('Identify failed'); /* S$IdentFailed */         ps('D24 board not found'); /* S$D24NotFound */         ps('Bad bus state'); /* S$BadBusState */         ps('Bad initiator'); /* S$BadInitiator */      end;   end;end PrintError;/* Output Routines */PrintErrorMessage: proc(d,ErrMsg,SCSIError); /* print error message */   dcl d         fixed; /* device address where error occurred */   dcl ErrMsg    fixed array; /* error message to display */   dcl SCSIError boolean; /* true to include SCSI error message */   ps('ERROR');   if ErrMsg(0) <> 0 then do; /* print error message */      ps(' '); ps(ErrMsg);   end;   ps(' on '); call PrintDTL(d); /* where error occurred */   if SCSIError then do; /* also print SCSI error */      if S$SenseKey <> 0 then do;         ps(': S$SenseKey = '); pn(S$SenseKey,0);      end;      else do;         ps(': C#Status = '); pn(c#status,0);      end;      newline;      call PrintError; /* print error in S$SenseKey or c#status */   end;end PrintErrorMessage;