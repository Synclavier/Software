/***** LaserDrive 1200 Information Record Format *****/dcl i$Vendor       lit '0';  /* Vendor name (8 characters) */dcl i$Model        lit '5';  /* Model name (16 characters) */dcl i$RevLevel     lit '14'; /* Firmware revision level (4 characters) */dcl i$RevDate      lit '17'; /* Firmware revision date (8 characters) */dcl i$Serial       lit '22'; /* Serial number (8 characters) */dcl i$Customer     lit '27'; /* Customer name (32 characters) */dcl i$MS_Sectors   lit '44'; /* No. sectors on entire disk */dcl i$LS_Sectors   lit '45';dcl i$MS_ZoneSize  lit '46'; /* No. sectors in each zone */dcl i$LS_ZoneSize  lit '47';dcl i$RandomZone   lit '48'; /* Random zone */dcl i$RandomSector lit '49'; /* Random sector in this zone */dcl i$Zones        lit '50'; /* Start of zone record area *//* Zone Record */dcl i$ZoneStatus    lit '0'; /* Status of zone */dcl i$MS_ZoneOrigin lit '1'; /* First sector of zone */dcl i$LS_ZoneOrigin lit '2';dcl i$MS_ZoneSector lit '3'; /* Sector to read/write in zone */dcl i$LS_ZoneSector lit '4'; /* Zone Errors */dcl i#NoError       lit '0'; /* no error has occurred */dcl i#ZoneFull      lit '1'; /* all sectors have been written for this zone */dcl i#SearchError   lit '2'; /* an error occurred during a search */dcl i#WriteError    lit '3'; /* an error occurred during a write */dcl i#ReadError     lit '3'; /* an error occurred during a read */dcl i#ZoneMax       lit '4'; /* no. zones */dcl i#ZoneRecLen    lit '5'; /* no. words required for zone record */dcl i#InfoRecLen    lit '(i$Zones + i#ZoneMax * i#ZoneRecLen)'; /* no. words required for this record *//***** LaserDrive 1200 Error Record Format *****//* Additional Data for Text Errors */dcl e#TextRecLen   lit '0'; /* no. words in record */dcl e#TextError    lit '0'; /* error type for this record *//* Additional Data for SCSI Errors */dcl e$SenseKey     lit '0';  /* SCSI sense key */dcl e$MS_Info      lit '1';  /* Information bytes (used only if Valid bit set) */dcl e$LS_Info      lit '2';dcl e$SkipCount    lit '3';  /* Skip/Residue count */dcl e$StatusFault  lit '4';  /* MS byte = Status, LS byte = Fault */dcl e$DeviceStatus lit '5'; /* MS byte = Stat 1, LS byte = Stat 2 */dcl e$ErrorStatus  lit '6'; /* MS byte = Err 1,  LS byte = Err 2 */dcl e#ScsiRecLen   lit '7'; /* no. words in record */dcl e#ScsiError    lit '1';  /* error type for this record *//* Additional Data for Connect Errors */dcl e$ConnectCode   lit '0';  /* connection failure code (signed!) */dcl e#ConnectRecLen lit '1'; /* no. words in record */dcl e#ConnectError  lit '2'; /* error type for this record *//* Additional Data for Diagnostic Errors */dcl e$FaultCode    lit '0'; /* MS byte = Primary Fault Code, LS byte = Secondary Fault Code */dcl e$MPVoltage    lit '1'; /* MS byte = Failing MP test number, LS byte = Voltage margining case */dcl e$PassFail     lit '2'; /* MS byte = Pass Count, LS byte = Fail Count */dcl e#DiagRecLen   lit '3'; /* no. words in record */dcl e#DiagError    lit '3'; /* error type for this record *//* Additional Data for Mismatch Errors */dcl e$MS_Sector      lit '0'; /* MS sector where error occurred */dcl e$LS_Sector      lit '1'; /* LS sector where error occurred */dcl e$Word           lit '2'; /* word where error occurred */dcl e$Expected       lit '3'; /* pattern expected */dcl e$Found          lit '4'; /* pattern found */dcl e#MismatchRecLen lit '5'; /* no. words in record */dcl e#MismatchError  lit '4'; /* error type for this record *//***** LaserDrive 1200 Test Record Format *****//* Additional Test Data */dcl t$SeekRetries      lit '(t#TestRecLen + 0)'; /* no. seek retries */dcl t$DataRetries      lit '(t#TestRecLen + 1)'; /* no. data retries */dcl t$ECCRetries       lit '(t#TestRecLen + 2)'; /* no. ECC retries */dcl t$Mismatches       lit '(t#TestRecLen + 3)'; /* no. read mismatches */dcl t#ExtraTestRecLen  lit '4'; /* no. words in extra test record */dcl t$NoTest           lit '0'; /* test number */dcl t$SelfTest         lit '1';dcl t$SeekTest         lit '2';dcl t$SearchTest       lit '3';dcl t$WriteTest        lit '4';dcl t$ReadTest         lit '5';dcl t#TestCount        lit '6'; /* no. tests */dcl t#SeekMax          lit '1000'; /* no. seeks to perform */dcl t#ReadMax          lit '1000'; /* no. random reads to perform */dcl t#PatternMax       lit '32'; /* no. write/read patterns */dcl t#Patterns         data  /* write/read patterns */("H8686","H9090","H0909","H6868",   "H6886","H0990","H9009","H8668", "H0968","H9068","H0986","H9086",   "H6809","H8609","H6890","H8690", "H8080","H6969","H9696","H0808",   "H0880","H9669","H6996","H8008", "H56F8","H65F8","H568F","H658F",   "HF856","H8F56","HF865","H8F65");GetErrorRecLen: proc(ErrorType) returns (fixed); /* get error record length */   dcl ErrorType fixed;   dcl Len       fixed;   do case ErrorType; /* get static size of record to add */      Len = e#TextRecLen; /* Text error record */      Len = e#ScsiRecLen; /* SCSI error record */      Len = e#ConnectRecLen; /* Connection error record */      Len = e#DiagRecLen; /* Diagnostic error record */      Len = e#MismatchRecLen; /* Mismatch error record */   end;   return (Len);end GetErrorRecLen;GetTestOffset: proc(Test) returns (fixed); /* get offset of test subrecord */   dcl Test fixed; /* test to use */   return (Test * (t#TestRecLen + t#ExtraTestRecLen));end GetTestOffset;GetZoneOffset: proc(Zone) returns (fixed); /* get offset of zone record in info record */   dcl Zone fixed; /* zone to use */   return (i$Zones + Zone * i#ZoneRecLen);end GetZoneOffset;PrintOpticalState: proc(state);   dcl state fixed;   do case state;      ps('Init Drive      ');      ps('Check Drive     ');      ps('Check Cartridge ');      ps('No Cartridge    ');      ps('Not Started     ');      ps('Write Protected ');      ps('Cartridge Full  ');      ps('Offline         ');      ps('Going Offline   ');      ps('Self Test       ');      ps('Seek Test       ');      ps('Search Test     ');      ps('Write Test      ');      ps('Read Test       ');      ps('Read Test       ');   end;end PrintOpticalState;PrintTestResults: proc(DriveHdl); /* print all test data for this test */   dcl DriveHdl handle; /* handle to drive record */   dcl TestPtr  pointer; /* pointer to test record */   Fill: proc(ch,count); /* fill with given character */      dcl ch fixed; /* character to fill with */      dcl count fixed; /* no. characters to fill */      do count = 1 to count; /* print given no. characters */         pc(ch);      end;   end Fill;   Print16BitValues: proc(FirstTest,LastTest,field); /* print given range of test values */      dcl FirstTest fixed; /* first test to print */      dcl LastTest  fixed; /* last test to print */      dcl field     fixed; /* field to print */      dcl i         fixed;      do i = FirstTest to LastTest;         pn(0,core(TestPtr + GetTestOffset(i) + field),9); ps(' |');      end;   end Print16BitValues;   Print32BitValues: proc(FirstTest,LastTest,MS_field); /* print given range of test values */      dcl FirstTest fixed; /* first test to print */      dcl LastTest  fixed; /* last test to print */      dcl MS_field  fixed; /* field to print */      dcl p         pointer;      dcl i         fixed;      do i = FirstTest to LastTest;         p = TestPtr + GetTestOffset(i);         pn(core(p + MS_field),core(p + MS_field + 1),9); ps(' |');      end;   end Print32BitValues;   PrintTimes: proc(FirstTest,LastTest); /* print given range of test values */      dcl FirstTest fixed; /* first test to print */      dcl LastTest  fixed; /* last test to print */      dcl field     fixed; /* field to print */      dcl p         pointer;      dcl i         fixed;      do i = FirstTest to LastTest;         p = TestPtr + GetTestOffset(i);         pt(core(p + t$MS_Seconds),core(p + t$LS_Seconds),9,true,false); ps(' |');      end;   end PrintTimes;   PrintBlanks: proc(FirstTest,LastTest); /* print given range of blank values */      dcl FirstTest fixed; /* first test to print */      dcl LastTest  fixed; /* last test to print */      dcl i         fixed;      do i = FirstTest to LastTest;         call Fill(a.SP,9); ps(' |');      end;   end PrintBlanks;   TestPtr = GetTestPtr(DriveHdl); /* get pointer to test record */   newline;   call Fill(a.SP,28); psr('Test Results');   newline;   call Fill(a.SP,15); ps('Self Test       Seek     Search      Write       Read'); newline;   call Fill(a.minus,70); newline;   ps('Iterations    |'); call Print16BitValues(t$SelfTest,t$ReadTest,t$Iterations); newline;   ps('Time          |'); call PrintTimes(t$SelfTest,t$ReadTest); newline;   call Fill(a.SP,14); pc(a.bar); call PrintBlanks(t$SelfTest,t$ReadTest); newline;   ps('Attempts      |'); call Print32BitValues(t$SelfTest,t$ReadTest,t$MS_Attempts); newline;   ps('Failures      |'); call Print32BitValues(t$SelfTest,t$ReadTest,t$MS_Failures); newline;   call Fill(a.SP,14); pc(a.bar); call PrintBlanks(t$SelfTest,t$ReadTest); newline;   ps('Seek Retries  |'); call PrintBlanks(t$SelfTest,t$SelfTest);   call Print16BitValues(t$SeekTest,t$ReadTest,t$SeekRetries); newline;   ps('Data Retries  |'); call PrintBlanks(t$SelfTest,t$SelfTest);   call Print16BitValues(t$SeekTest,t$ReadTest,t$DataRetries); newline;   ps('ECC  Retries  |'); call PrintBlanks(t$SelfTest,t$WriteTest);   call Print16BitValues(t$ReadTest,t$ReadTest,t$ECCRetries); newline;   call Fill(a.SP,14); pc(a.bar); call PrintBlanks(t$SelfTest,t$ReadTest); newline;   ps('Data Mismatch |'); call PrintBlanks(t$SelfTest,t$WriteTest);   call Print16BitValues(t$ReadTest,t$ReadTest,t$Mismatches); newline;   call Fill(a.minus,70); newline;   newline;end PrintTestResults;PrintTestErrors: proc(DriveHdl); /* print all errors logged for this test */   dcl DriveHdl  handle;  /* handle to drive record */   dcl Test      fixed;   /* test to print errors from */   dcl ErrHdl    handle;  /* handle to error record */   dcl NextField pointer; /* pointer to next error field */   dcl TestPtr   pointer; /* pointer to test record */   dcl (MS_Errors,LS_Errors) fixed; /* no. errors */   dcl (p,q)     pointer;   dcl Margin    data ('   ');   newline;   psr('Error Log');   do Test = t$NoTest to t$ReadTest; /* loop over tests */      TestPtr = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      newline;      pn(0,Test + 1,1); ps('. ');      do case Test;         ps('Initialization: ');         ps('Self Test:      ');         ps('Seek Test:      ');         ps('Search Test:    ');         ps('Write Test:     ');         ps('Read Test:      ');      end;      MS_Errors = core(TestPtr + t$MS_Failures); /* get no. failures */      LS_Errors = core(TestPtr + t$LS_Failures);      if (MS_Errors = 0) and (LS_Errors = 0)      then psr('No Errors');      else if (MS_Errors = 0) and (LS_Errors = 1)      then psr('1 Error');      else do; pn(MS_Errors,LS_Errors,1); psr(' Errors'); end;      ErrHdl = core(core(DriveHdl) + d$ErrorHandle); /* get handle to error record */      NextField = TestPtr + t$FirstError; /* get pointer to next error field */      do while core(NextField) <> 0; /* loop until entire list has been traversed */         p = core(ErrHdl) + core(NextField); /* get pointer to error data */         q = p + e#ErrorRecLen + 1 + shr(core(p + e$ErrorMsg) + 1,1); /* skip over standard error data */         newline;         ps(Margin);         ps('Iteration '); pn(0,core(p + e$Iteration),1); /* print test iteration */         ps('  ');         call PrintDate(core(p + e$MS_ErrorTime),core(p + e$LS_ErrorTime),0); /* print error date */         ps('  ');         call PrintTime(core(p + e$MS_ErrorTime),core(p + e$LS_ErrorTime),0); /* print error time */         ps('  ');         psr(loc(p + e$ErrorMsg)); /* print error message */         newline;         do case core(p + e$ErrorType);            ; /* Text error */            do; /* SCSI error */               ps(Margin);               ps('   Sense Key :     '); hnum(core(q + e$SenseKey),2);               ps('    Status Byte    :  '); hnum(shr(core(q + e$StatusFault),8),2);               ps('    Fault Code    :  '); hnum(core(q + e$StatusFault) and "HFF",2);               newline;               ps(Margin);               ps('   Info Bytes:  '); hnum(core(q + e$MS_Info),1); hnum(core(q + e$LS_Info),4);               ps('    Device Status 1:  '); hnum(shr(core(q + e$DeviceStatus),8),2);               ps('    Error Status 1:  '); hnum(shr(core(q + e$ErrorStatus),8),2);               newline;               ps(Margin);               ps('   Skip Count:   '); hnum(core(q + e$SkipCount),4);               ps('    Device Status 2:  '); hnum(core(q + e$DeviceStatus) and "HFF",2);               ps('    Error Status 2:  '); hnum(core(q + e$ErrorStatus) and "HFF",2);               newline;            end;            do; /* Connect error */               ps(Margin);               ps('   Connect Code:  -'); pn(0,abs(core(q + e$ConnectCode)),0);               newline;            end;            do; /* diagnostic error */               ps(Margin);               ps('   Primary Fault Code  :  '); hnum(shr(core(q + e$FaultCode),8),2);               ps('    Pass Count:  '); hnum(shr(core(q + e$PassFail),8),2);               ps('    MP Test:  '); hnum(shr(core(q + e$MPVoltage),8),2);               newline;               ps(Margin);               ps('   Secondary Fault Code:  '); hnum(core(q + e$FaultCode) and "HFF",2);               ps('    Fail Count:  '); hnum(core(q + e$PassFail) and "HFF",2);               ps('    Voltage:  '); hnum(core(q + e$MPVoltage) and "HFF",2);               newline;            end;            do; /* Mismatch error */               ps(Margin);               ps('   Sector:  '); hnum(core(q + e$MS_Sector),1); hnum(core(q + e$LS_Sector),4);               ps('    Pattern Expected:  '); hnum(core(q + e$Expected),4);               newline;               ps(Margin);               ps('   Word  :   '); hnum(core(q + e$Word),4);               ps('    Pattern Found   :  '); hnum(core(q + e$Found),4);               newline;            end;         end; /* case */         NextField = p + e$NextError; /* get location of next error field */      end; /* looping over errors */   end; /* looping over tests */end PrintTestErrors;PrintOpticalLog: proc(D24,Target); /* display log for given drive */   dcl D24       fixed; /* D24 to display */   dcl Target    fixed; /* Target to display */   dcl DriveHdl  handle; /* handle to drive record */   dcl Size      fixed; /* size of drive in megabytes */   dcl (MS_Secs,LS_Secs) fixed; /* no. seconds drive has been tested */   dcl p         pointer; /* record pointer */   dcl i         fixed;   pl: proc(s,FieldWidth); /* print string with trailing spaces */      dcl s          fixed array; /* string to display */      dcl FieldWidth fixed; /* field width */      dcl i          fixed;      ps(s);      do i = 1 to FieldWidth - s(0); /* put in trailing spaces */         pc(a.SP);      end;   end pl;   DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */   p = GetInfoPtr(DriveHdl); /* get pointer to info record */   write("5") = core(p + i$LS_Sectors); /* size in sectors */   write("4") = core(p + i$MS_Sectors);   write("7") = 1024; /* find out size in MB */   Size = read("5") + (read("4") ige 512); /* found up */   if OutputDev = TerminalDev then clear_screen; /* clear screen on terminal */   ps('Customer: '); call pl(loc(p + i$Customer),32);   call PrintDate(MS_Seconds,LS_Seconds,1); ps('  ');   call PrintTime(MS_Seconds,LS_Seconds,1); newline;   newline;   ps('Serial Number:   '); call pl(loc(p + i$Serial),20);   ps('Drive Vendor:    '); ps(loc(p + i$Vendor)); newline;   ps('Revision Level:  '); call pl(loc(p + i$RevLevel),20);   ps('Drive Model:     '); ps(loc(p + i$Model)); newline;   ps('Revision Date:   '); call pl(loc(p + i$RevDate),20);   ps('Drive Size:      '); pn(0,Size,0); psr(' Megabytes');   call PrintTestResults(DriveHdl); /* print out test results */   if OutputDev = TerminalDev then do; /* don't scroll */      pcmd(WaitMsg);      call rchar; crlf;      crlf;   end;   p = core(DriveHdl); /* get pointer to drive record */   MS_Secs = MS_Seconds - core(p + d$MS_FirstTime); /* calculate how long drive has been tested */   if LS_Seconds ilt core(p + d$LS_FirstTime) then MS_Secs = MS_Secs - 1;   LS_Secs = LS_Seconds - core(p + d$LS_FirstTime);   ps('Total Test Time: '); pt(MS_Secs,LS_Secs,7,true,false); newline;   ps('Total Errors:    '); pn(core(p + d$MS_Errors),core(p + d$LS_Errors),0); newline;   ps('Total Cycles:    '); pn(0,0,0); newline;   newline;   psr('Visual Inspection by: ________________________');   psr('Real-Time Tests by:   ________________________');   newline;   call PrintTestErrors(DriveHdl); /* print out test errors */   if OutputDev = TerminalDev then do; /* don't scroll */      crlf;      pcmd(WaitMsg);      call rchar;   end;end PrintOpticalLog;dcl OpticalPath data (':USER:OPTLOG'); /* pathname name to optical subcatalog */SaveOpticalLog: proc(D24,Target); /* save test log to disk */   dcl D24       fixed; /* D24 to save */   dcl Target    fixed; /* Target to save */   dcl DriveHdl  handle; /* handle to drive record */   dcl p         pointer; /* record pointer */   dcl ok        boolean;   DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */   p = GetInfoPtr(DriveHdl); /* get pointer to info record */   pstring('Saving test log for D24, '); unum(D24,1);   pstring(', Target '); unum(Target,1); pstring('...');   do while (core(p + i$Serial) = 0) or (core(p + i$Customer) = 0); /* make sure they have entered the customer data */      crlf;      pstringr('You must enter the serial number and customer name to save the test log data.');      crlf;      get_string('Enter Serial Number: ',true,loc(p + i$Serial),8); crlf;      get_string('Enter Customer Name: ',true,loc(p + i$Customer),32); crlf;   end;   ErrMsg(0) = 0; /* construct treename for log file */   call AppendStr(ErrMsg,OpticalPath);   call AppendStr(ErrMsg,':');   call AppendStr(ErrMsg,loc(p + i$Serial));   if locate(ErrMsg,1) then do; /* a file is already there */      crlf;      pstringr('WARNING: A test log has already been saved for this optical disk drive.');      ok = Get_YN('Do you wish to overwrite it [Y(es) or N(o)]? '); crlf;   end;   else ok = true;   if ok then do; /* OK to save file */      if OpenLogFile(OpticalPath,ErrMsg) then do; /* file opened */         OutputDev = FileDev; /* send output to file */         call PrintOpticalLog(D24,Target); /* print log to file */         OutputDev = TerminalDev;         if CloseLogFile(ErrMsg) then do; /* log file closed successfully */            pstringr('Test log saved');            return;         end;      end;      pstring('Test log not saved: '); unum(c#status,1); crlf;   end;end SaveOpticalLog;OpticalMenu: proc; /* show menu of optical options */   dcl DriveHdl  handle; /* handle to drive record */   dcl p         pointer; /* record pointer */   dcl choice    fixed;   clear_screen;   DriveHdl = GetDriveHandle(CurrentD24,CurrentTarget); /* get handle to drive record */   p = GetInfoPtr(DriveHdl); /* get pointer to info record */   choice = 0;   do while choice <> 7;      crlf;      pstring('Options for optical disk at D24 '); unum(CurrentD24,0);      pstring(', Target '); unum(CurrentTarget,0); pstringr(':');      crlf;      pstringr('1. Enter Serial Number');      pstringr('2. Enter Customer Name');      crlf;      pstringr('3. Display test log on screen');      pstringr('4. Print test log');      pstringr('5. Save test log to disk');      pstringr('6. Clear test log');      crlf;      pstringr('7. Continue Testing');      crlf;      pstring('Enter choice: '); choice = getuns; crlf;      crlf;      do case choice;         ;         do; /* get serial number */            get_string('Enter Serial Number: ',true,loc(p + i$Serial),8); crlf;         end;         do; /* get customer name */            get_string('Enter Customer Name: ',true,loc(p + i$Customer),32); crlf;         end;         do; /* display test log */            call PrintOpticalLog(CurrentD24,CurrentTarget); /* show log on screen */         end;         do; /* print test log */            pstring('Printing test log for D24, '); unum(CurrentD24,1);            pstring(', Target '); unum(CurrentTarget,1); pstring('...');            redirection_word = 1; /* redirect output to printer */            OutputDev = PrinterDev;            call PrintOpticalLog(CurrentD24,CurrentTarget); /* print log on printer */            OutputDev = TerminalDev;            redirection_word = no_redirection; /* cancel redirection */            pstringr('Test log printed');         end;         do; /* save test log to disk */            call SaveOpticalLog(CurrentD24,CurrentTarget); /* save log to disk file */         end;         do;            if Get_YN('Do you wish to clear all test results for this drive? [Y(es) or N(o)]? ')            then core(core(DriveHdl) + d$Process) = InitProcess; /* initialize processing */            crlf;         end;         ;      end;   end;end OpticalMenu;