ProcessOptical: proc(D24,Target) returns (fixed); /* process this state */   dcl D24       fixed; /* D24 address of drive */   dcl Target    fixed; /* SCSI Target ID of drive */   dcl State     fixed; /* new state */   dcl DriveHdl  handle; /* handle to drive record */   dcl DrivePtr  pointer; /* pointer to drive record */   dcl done      boolean; /* TRUE if done processing states */   dcl Sense     fixed; /* SCSI sense key */   dcl delay     fixed; /* amount of time to delay next command */   dcl (p,q)     pointer;   dcl (msw,lsw) fixed;   dcl (i,j)     fixed;   /* Optical Disk States */   dcl InitDrive       lit '0';   dcl CheckDrive      lit '1';   dcl CheckCartridge  lit '2';   dcl NoCartridge     lit '3';   dcl NotStarted      lit '4';   dcl WriteProtect    lit '5';   dcl CartridgeFull   lit '6';   dcl OffLine         lit '7';   dcl GoingOffline    lit '8';   dcl SelfTest        lit '9';   dcl SeekTest        lit '10';   dcl SearchTest      lit '11';   dcl WriteTest       lit '12';   dcl ReadTest        lit '13';   dcl RandomReadTest  lit '14';   InitInfoRec: proc; /* initialize the info record for this drive */      dcl (h,p) pointer;      h = Alloc_Handle(i#InfoRecLen); /* allocate space for this record */      if h <> Null then do; /* a record was allocated */         core(core(DriveHdl) + d$InfoHandle) = h; /* store this handle */         p = core(h); /* get pointer to record */         call GetBufferString(DataBuf, 8, 8,loc(p + i$Vendor)); /* store vendor name */         call GetBufferString(DataBuf,16,16,loc(p + i$Model)); /* store model name */         call GetBufferString(DataBuf,32, 4,loc(p + i$RevLevel)); /* store firmware revision level */         call GetBufferString(DataBuf,36, 8,loc(p + i$RevDate)); /* store firmware revision date */         core(p + i$Serial) = 0; /* no serial number yet */         core(p + i$Customer) = 0; /* no customer number yet */      end;   end InitInfoRec;   InitTestRec: proc; /* initialize the test records for this drive */      dcl (h,p)   pointer;      dcl (i,len) fixed;      len = (t#TestRecLen + t#ExtraTestRecLen) * t#TestCount; /* calculate size of test record */      h = Alloc_Handle(len); /* allocate space for the test record */      if h <> Null then do; /* the records were allocated */         core(core(DriveHdl) + d$TestHandle) = h; /* store this handle */         p = core(h); /* get pointer to record */         do i = 0 to len - 1; /* zero out all test records */            core(p + i) = 0;         end;      end;   end InitTestRec;   InitErrorRec: proc; /* intialize the error record for this drive */      dcl (h,p)   pointer;      dcl (i,len) fixed;      h = Alloc_Handle(1); /* create empty handle */      if h <> Null then do; /* the record was allocated */         core(core(DriveHdl) + d$ErrorHandle) = h; /* store this handle */      end;   end InitErrorRec;   LogTestIteration: proc(Test); /* log iteration */      dcl Test       fixed; /* test to log */      dcl p          pointer;      p = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      core(p + t$Iterations) = core(p + t$Iterations) + 1; /* add another iteration */   end LogTestIteration;   LogTestAttempt: proc(Test); /* log attempt */      dcl Test       fixed; /* test to log */      dcl p          pointer;      p = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      core(p + t$LS_Attempts) = core(p + t$LS_Attempts) + 1; /* add another attempt */      if core(p + t$LS_Attempts) = 0 /* overflow */      then core(p + t$MS_Attempts) = core(p + t$MS_Attempts) + 1;   end LogTestAttempt;   LogTestRetries: proc(Test); /* log retries required */      dcl Test       fixed; /* test to log */      dcl p          pointer;      dcl Stat       fixed;      p = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      Stat = byte(SenseBuf,10); /* get status byte */      if (Stat and "H08") <> 0      then core(p + t$SeekRetries) = core(p + t$SeekRetries) + 1; /* seek retry required */      else if (Stat and "H10") <> 0      then core(p + t$DataRetries) = core(p + t$DataRetries) + 1; /* data retry required */      else if (Stat and "H20") <> 0      then core(p + t$ECCRetries) = core(p + t$ECCRetries) + 1; /* ECC retry required */   end LogTestRetries;   LogTestError: proc(Test,ErrorType,ErrorMsg,ErrorBuf); /* display and log error messages */      dcl Test        fixed; /* test where error occurred */      dcl ErrorType   fixed; /* type of error which occurred */      dcl ErrorMsg    fixed array; /* text message for error */      dcl ErrorBuf    fixed array; /* buffer with error data */      dcl StandardLen fixed; /* length of standard error record data */      dcl ExtraLen    fixed; /* length of extra error record data */      dcl Iterations  fixed; /* no. test iterations */      dcl p           pointer;      pcmd('Error on D24 '); unum(D24,0); pstring(', Target '); unum(Target,0); /* print message on screen */      pstring(': '); pstring(ErrorMsg); call RestoreCursor;      p = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      Iterations = core(p + t$Iterations); /* get no. iterations of this test */      if (ErrorType <> e#TextError) and (ErrorType <> e#MismatchError) then do; /* don't count this as a failure */         core(p + t$LS_Failures) = core(p + t$LS_Failures) + 1; /* count failures on this test */         if core(p + t$LS_Failures) = 0 /* overflow */         then core(p + t$MS_Failures) = core(p + t$MS_Failures) + 1;      end;      p = core(DriveHdl); /* get pointer to drive record */      core(p + d$LS_Errors) = core(p + d$LS_Errors) + 1; /* count total failures */      if core(p + d$LS_Errors) = 0 /* overflow */      then core(p + d$MS_Errors) = core(p + d$MS_Errors) + 1;      if  (core(p + d$MS_Errors) <> 0)      or ((core(p + d$MS_Errors) =  0) and (core(p + d$LS_Errors) igt e#ErrorMax)) /* too many errors */      then return; /* don't store errors beyond limit */      StandardLen = e#ErrorRecLen + 1 + shr(ErrorMsg(0) + 1,1); /* length of standard error information */      ExtraLen = GetErrorRecLen(ErrorType); /* get length of additional data for this error */      p = AddErrorRecord(DriveHdl,GetTestOffset(Test),StandardLen + ExtraLen); /* create record for this data */      if p = Null then return; /* record could not be created */      call UpdateErrorRecord(p,ErrorType,ErrorMsg,Iterations); /* set standard error data */      p = p + StandardLen; /* skip over standard error data */      do case ErrorType; /* set additional error data for the various error types */         ;   /* Text error */         do; /* SCSI error */            core(p + e$SenseKey) = byte(ErrorBuf,2); /* SCSI sense key */            core(p + e$MS_Info) = (shl(byte(ErrorBuf,3),8) or byte(ErrorBuf,4)); /* Information bytes (used only if Valid bit set) */            core(p + e$LS_Info) = (shl(byte(ErrorBuf,5),8) or byte(ErrorBuf,6)); /* Information bytes (used only if Valid bit set) */            core(p + e$SkipCount) = (shl(byte(ErrorBuf,8),8) or byte(ErrorBuf,9)); /* Skip/Residue count */            core(p + e$StatusFault) = (shl(byte(ErrorBuf,10),8) or byte(ErrorBuf,11)); /* MS byte = Status, LS byte = Fault */            core(p + e$DeviceStatus) = (shl(byte(ErrorBuf,12),8) or byte(ErrorBuf,13)); /* MS byte = Stat 1, LS byte = Stat 2 */            core(p + e$ErrorStatus) = (shl(byte(ErrorBuf,14),8) or byte(ErrorBuf,15)); /* MS byte = Err 1, LS byte = Err 2 */         end;         do; /* Connection error */            core(p + e$ConnectCode) = ErrorBuf(0); /* store connection code */         end;         do; /* Diagnostic error */            core(p + e$FaultCode) = (shl(byte(ErrorBuf,0),8) or byte(ErrorBuf,1)); /* SAMS primary and secondary fault codes */            core(p + e$MPVoltage) = (shl(byte(ErrorBuf,2),8) or byte(ErrorBuf,5)); /* MS byte = Failing MP test number, LS byte = Voltage margining case */            core(p + e$PassFail) = (shl(byte(ErrorBuf,3),8) or byte(ErrorBuf,4)); /* MS byte = Pass Count, LS byte = Fail Count */         end;         do; /* Mismatch error */            core(p + e$MS_Sector) = ErrorBuf(e$MS_Sector);            core(p + e$LS_Sector) = ErrorBuf(e$LS_Sector);            core(p + e$Word) = ErrorBuf(e$Word);            core(p + e$Expected) = ErrorBuf(e$Expected);            core(p + e$Found) = ErrorBuf(e$Found);         end;      end;   end LogTestError;   LogUnknownError: proc(Test,SenseKey) returns (fixed); /* log unknown SCSI error */      dcl Test         fixed; /* test where error occurred */      dcl SenseKey     fixed; /* sense key */      dcl NewState     fixed; /* new state to go to */      if SenseKey > 0 then do; /* SCSI error */         call LogTestError(Test,e#ScsiError,'Unexpected Sense Key',SenseBuf); /* store SCSI sense information and display error */         if (SenseKey = S$NotReady) or (SenseKey = S$UnitAttention) /* drive is not ready or cartridge changed */         then NewState = CheckDrive; /* start over again */         else NewState = State; /* stay in same state */      end;      else do; /* connection error */         DataBuf(0) = SenseKey;         call LogTestError(Test,e#ConnectError,'Unexpected Connection Failure',DataBuf); /* store connect status and display error */         if (SenseKey = S$SelFailed) or (SenseKey = S$D24NotThere) /* drive not there */         then NewState = Offline; /* wait for drive to come on again */         else NewState = State; /* stay in same state */      end;      done = true; /* done for now */      return (NewState); /* return new state for this error condition */   end LogUnknownError;   LogTestResults: proc(Test); /* update standard test record contents */      dcl Test       fixed; /* test to log */      dcl p          pointer;      dcl (msw,lsw)  fixed;      p = core(DriveHdl); /* get pointer to drive record */      msw = MS_Seconds - core(p + d$MS_StateTime); /* get the elapsed time */      if LS_Seconds ilt core(p + d$LS_StateTime) then msw = msw - 1;      lsw = LS_Seconds - core(p + d$LS_StateTime);      p = GetTestPtr(DriveHdl) + GetTestOffset(Test); /* get pointer to test record */      core(p + t$MS_Seconds) = core(p + t$MS_Seconds) + msw;      core(p + t$LS_Seconds) = core(p + t$LS_Seconds) + lsw;      if core(p + t$LS_Seconds) ilt lsw       then core(p + t$MS_Seconds) = core(p + t$MS_Seconds) + 1;   end LogTestResults;   WritePattern: proc; /* write pattern to disk */      dcl i fixed;      do while (read(ScsiBus) and S$REQ) = 0; end; /* wait for REQ */      i = 0;      do while (read(ScsiBus) and S$SigMask) = S$DataOut; /* continue while Data Out phase is on bus */         write(r13) = t#Patterns(i); /* get pattern in register */         repeat 255; write("27") = read(r13); /* write 256 words */         repeat 255; write("27") = read(r13); /* write 256 words */         do while (read(ScsiBus) and S$REQ) = 0; end; /* wait for REQ */         i = i + 1; /* go to next pattern */      end;   end WritePattern;    ReadPattern: proc(MS_Sec,LS_Sec,PatIndex); /* read pattern from disk */      dcl (MS_Sec,LS_Sec) fixed; /* starting sector of read */      dcl PatIndex        fixed; /* index of first pattern to read */      dcl (i,j,pattern)   fixed;      dcl p               pointer;      do while (read(ScsiBus) and S$REQ) = 0; end; /* wait for REQ */      i = PatIndex;      do while (read(ScsiBus) and S$SigMask) = S$DataIn; /* continue while Data In phase is on bus */         pattern = t#Patterns(i); /* get pattern */         write(r13) = addr(DataBuf(0)); /* use data buffer */         repeat 255; write(mr13i) = read("27"); /* read 256 words */         repeat 255; write(mr13i) = read("27"); /* read 256 words */         write(r13) = addr(DataBuf(0)); /* start of buffer */         j = addr(DataBuf(0)) + 512; /* end of buffer */         do while read(r13) <> j;            if read(mr13i) <> pattern then do;               DataBuf(e$MS_Sector) = MS_Sec + ((LS_Sec + i) ilt i); /* computer sector where error occurred */               DataBuf(e$LS_Sector) = LS_Sec + i;               DataBuf(e$Word) = read(r13) - 1 - addr(DataBuf(0));               DataBuf(e$Expected) = pattern;               DataBuf(e$Found) = core(read(r13) - 1);               call LogTestError(t$ReadTest,e#MismatchError,'Data Miscompare',DataBuf); /* log this error */               p = GetTestPtr(DriveHdl) + GetTestOffset(t$ReadTest); /* get pointer to test record */               core(p + t$Mismatches) = core(p + t$Mismatches) + 1; /* count mismatchs */            end;         end;         do while (read(ScsiBus) and S$REQ) = 0; end; /* wait for REQ */         i = i + 1; /* go to next pattern */      end;   end ReadPattern;   /* main procedure */   DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */   done = false; /* not done yet */   delay = 10; /* default delay */   if DriveHdl = Null then do; /* no drive handle, so create it */      DriveHdl = Alloc_Handle(d#DriveRecLen); /* allocate space */      if DriveHdl = Null then return (60); /* quit */      dev(GetDeviceIndex(D24,Target) + v$DriveHandle) = DriveHdl; /* store drive handle */      State = InitDrive; /* initialize stuff */   end;   else do; /* use current drive record */      DrivePtr = core(DriveHdl); /* get pointer to drive record */      State = core(DrivePtr + d$State); /* get current state */      if  (core(DrivePtr + d$Process) <> ContProcess) /* an override state is set */      and (PendingTarget(D24) <> Target) then do; /* and nothing is pending for this target */         if core(DrivePtr + d$Process) = StopProcess /* stop all processing for this drive */         then State = GoingOffline; /* prepare to go offline */         else if core(DrivePtr + d$Process) = InitProcess /* initialize drive again */         then State = InitDrive; /* clear all fields and start over */         core(DrivePtr + d$Process) = ContProcess; /* clear the override */      end;      if core(DrivePtr + d$PrevState) <> core(DrivePtr + d$State) then do; /* state has changed */         core(DrivePtr + d$MS_StateTime) = MS_Seconds; /* store the time */         core(DrivePtr + d$LS_StateTime) = LS_Seconds;         core(DrivePtr + d$StateIteration) = 0; /* first iteration for this state */      end;   end;   do while not done;      DrivePtr = core(DriveHdl); /* get pointer to drive record */      p = GetInfoPtr(DriveHdl); /* get pointer to info record */      q = p + GetZoneOffset(core(DrivePtr + d$StateIteration)); /* get pointer to zone record */      do case State; /* process the states */         do; /* Init Drive */            call Inquiry(CmdBuf,LUN,56); /* get LD 1200 inquiry bytes */            Sense = SendCommand(D24,Target,true);            if Sense = S$Good then do;               call InitDriveRec(D24,Target); /* initialize drive record */               DrivePtr = core(DriveHdl); /* get pointer to drive record */               core(DrivePtr + d$MS_FirstTime) = MS_Seconds; /* store time drive was found */               core(DrivePtr + d$LS_FirstTime) = LS_Seconds;               core(DrivePtr + d$DevType) = S$WriteOnce; /* this is an optical disk */               call InitInfoRec; /* initialize info record */               call InitTestRec; /* initialize test record */               call InitErrorRec;/* initialize error record */               State = CheckCartridge; /* check the cartridge */            end;            else State = LogUnknownError(t$NoTest,Sense);         end;         do; /* Check Drive */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$Good then do; /* drive is ready to go */               call Inquiry(CmdBuf,LUN,4); /* get first 4 inquiry bytes */               Sense = SendCommand(D24,Target,true);               if Sense = S$Good then do; /* got the inquiry bytes */                  if byte(DataBuf,0) = S$WriteOnce /* this is an optical disk */                  then State = CheckCartridge; /* go and check the cartridge */                  else do; /* not an optical disk */                     call InitDriveRec(D24,Target); /* clear out drive record */                     call Free_Handle(DriveHdl); /* remove this handle */                     dev(GetDeviceIndex(D24,Target) + v$DriveHandle) = Null; /* no drive record now */                     return (0); /* get out right away */                  end;               end;               else State = LogUnknownError(t$NoTest,Sense); /* something wierd has happened */            end;            else if Sense = S$NotReady /* drive is not ready */            then State = NoCartridge; /* assume no cartridge is in drive */            else if Sense = S$UnitAttention /* reset or unit attention */            then; /* stay in this state */            else if (Sense = S$SelFailed) or (Sense = S$D24NotThere) /* drive has gone away */            then State = Offline; /* wait for drive to come online */            else State = LogUnknownError(t$NoTest,Sense); /* some other SCSI error has occurred */         end;         do; /* Check Cartridge */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$Good then do; /* drive is there */               State = SelfTest; /* go do self tests */               call ReadCapacity(CmdBuf,LUN);               Sense = SendCommand(D24,Target,true); /* seek how many sectors are on this disk */               if Sense = S$Good then do; /* got capacity information */                  p = GetInfoPtr(DriveHdl); /* get pointer to info record */                  msw = rot(DataBuf(1),8); /* get largest sector */                  lsw = rot(DataBuf(2),8) + 1; /* add one to get total sectors */                  if lsw = 0 then msw = msw + 1;                  core(p + i$MS_Sectors) = msw; /* store no. sectors */                  core(p + i$LS_Sectors) = lsw;                  lsw = (shl(msw,14) or shr(lsw,2)); /* divide by 4 to get zone size in blocks */                  msw = shr(msw,2);                  core(p + i$MS_ZoneSize) = msw; /* store size of zone */                  core(p + i$LS_ZoneSize) = lsw;                  msw = 0; /* first zone starts at sector zero */                  lsw = 0;                  do i = 0 to i#ZoneMax - 1; /* compute zone information for all zones */                     q = p + GetZoneOffset(i); /* get pointer to zone record */                     core(q + i$MS_ZoneOrigin) = msw; /* starting sector of zone */                     core(q + i$LS_ZoneOrigin) = lsw;                     core(q + i$MS_ZoneSector) = msw; /* search begins at first sector of zone */                     core(q + i$LS_ZoneSector) = lsw;                     core(q + i$ZoneStatus) = i#NoError; /* no errors yet */                     msw = msw + core(p + i$MS_ZoneSize); /* compute start of next zone */                     lsw = lsw + core(p + i$LS_ZoneSize);                     if lsw ilt core(p + i$LS_ZoneSize) then msw = msw + 1;                  end;                  call ModeSense(CmdBuf,LUN,0,0,16); /* get mode sense data */                  Sense = SendCommand(D24,Target,true);                  if Sense = S$Good then do; /* got it */                     if (byte(DataBuf,2) and "H80") = 0 then do; /* cartridge is not write-protected */                        call pbyte(DataBuf,0,0); /* clear sense data length */                        call pbyte(DataBuf,1,0); /* clear medium type */                        call pbyte(DataBuf,2,byte(DataBuf,2) and "H7F"); /* clear WP bit */                        call pbyte(DataBuf,12,byte(DataBuf,12) or "H10"); /* set Report Soft Errors bit */                        call ModeSelect(CmdBuf,LUN,16); /* send this mode select data */                        Sense = SendCommand(D24,Target,true);                        if Sense = S$Good then do; /* the LaserDrive is ready to go */                           State = SelfTest; /* go do self tests */                           delay = 1;                           done = true;                        end;                     end;                     else State = WriteProtect; /* cartridge is write-protected */                  end; /* getting mode sense data */               end; /* getting capacity data */               if Sense <> S$Good then do; /* an unexpected error occurred */                  call LogUnknownError(t$NoTest,Sense);                  State = CheckDrive; /* check drive */               end;            end;            else State = CheckDrive; /* check drive */         end;         do; /* No Cartridge */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$NotReady then do; /* drive is not ready */               if (byte(SenseBuf,12) and "H10") <> 0 /* cartridge is in drive */               then State = NotStarted; /* wait for START button to get pressed */               else done = true; /* wait for cartridge to be inserted */            end;            else State = CheckDrive; /* check drive */         end;         do; /* Not Started */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$NotReady then do; /* drive is not ready */               if (byte(SenseBuf,12) and "H10") = 0 /* no cartridge is in drive */               then State = NoCartridge; /* wait for cartridge to be inserted */               else done = true; /* wait for START button to be pressed */            end;            else State = CheckDrive; /* check drive */         end;         do; /* Write Protect */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$Good /* nothing has changed */            then done = true; /* wait for them to remove the cartridge */            else State = CheckDrive; /* check drive */         end;         do; /* Cartridge Full */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if Sense = S$Good /* nothing has changed */            then done = true; /* wait for them to remove the cartridge */            else State = CheckDrive; /* check drive */         end;         do; /* Offline */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if (Sense = S$SelFailed) or (Sense = S$D24NotThere) /* drive is not responding */            then done = true; /* stay in this state */            else do; /* drive is responding */               MS_NextOffline = MS_Seconds + MS_Interval; /* compute next time power will go off */               LS_NextOffline = LS_Seconds + LS_Interval;               if LS_NextOffline ilt LS_Interval then MS_NextOffline = MS_NextOffline + 1;               State = CheckDrive; /* check drive */            end;         end;         do; /* Going Offline */            call TestUnitReady(CmdBuf,LUN);            Sense = SendCommand(D24,Target,true); /* see if drive is there */            if (Sense = S$SelFailed) or (Sense = S$D24NotThere) /* drive not responding */            then State = Offline; /* go and wait for it to come online again */            else done = true; /* wait for it to go offline */         end;         do; /* Self Test *//*            if 1 then do; state = searchtest; delay = 1; done = true; end;            else  */            if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               call SendDiagnostic(CmdBuf,LUN,0);               call pbyte(CmdBuf,1,byte(CmdBuf,1) or "H4"); /* do self tests */               Sense = SendCommand(D24,Target,false); /* send diagnostic command */               call LogTestIteration(t$SelfTest); /* log iteration */               call LogTestAttempt(t$SelfTest); /* log attempt */               if Sense = S$Good then do; /* command sent OK */                  PendingTarget(D24) = Target; /* there is now a command waiting */                  delay = 0;                  done = true; /* go and wait for status */               end;               else State = LogUnknownError(t$SelfTest,Sense); /* something weird happened */            end;            else do; /* get status from diagnostic command */               delay = 10;               if REQPresent(D24) then do; /* there is a REQ out there */                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if (Sense = S$HardwareError) and (byte(SenseBuf,11) = "HA6") then do; /* diagnostic fault detected */                     call ReceiveDiagnostic(CmdBuf,LUN,8);                     Sense = SendCommand(D24,Target,true); /* receive diagnostic command */                     if Sense = S$Good then do; /* got the diagnostic info */                        call LogTestError(t$SelfTest,e#DiagError,'Diagnostic Fault Detected',DataBuf); /* store diagnostic information */                     end;                  end;                  call LogTestResults(t$SelfTest); /* log results */                  State = SeekTest; /* go do seek tests */                  if Sense <> S$Good /* an unexpected error occurred */                  then State = LogUnknownError(t$SelfTest,Sense); /* log it */               end; /* REQ found */               done = true;            end;         end;         do; /* Seek Test */            if core(DrivePtr + d$StateIteration) = t#SeekMax then do; /* maximum seeks performed for this test */               call LogTestResults(t$SeekTest); /* log test */               State = SearchTest; /* go do search test */               delay = 1;               done = true;            end;            else if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               if core(DrivePtr + d$StateIteration) = 0 /* first seek */               then call LogTestIteration(t$SeekTest); /* log iteration */               call LogTestAttempt(t$SeekTest); /* log attempt */               msw = random(core(p + i$MS_Sectors) + 1); /* get random MS sector */               if msw = core(p + i$MS_Sectors)               then lsw = random(core(p + i$LS_Sectors)); /* do not exceed address space of disk */               else lsw = random(65535); /* get random LS sector */               call ExtendedSeek(CmdBuf,LUN,msw,lsw); /* seek to a random sector */               Sense = SendCommand(D24,Target,false); /* send command */               if Sense = S$Good then do; /* command sent OK */                  PendingTarget(D24) = Target; /* there is now a command waiting */                  delay = 0;                  done = true; /* go and wait for status */               end;               else State = LogUnknownError(t$SeekTest,Sense); /* something weird happened */            end;            else do; /* get status from command */               delay = 0;               if REQPresent(D24) then do; /* there is a REQ out there */                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if Sense = S$Good then do; /* seek completed successfully */                  end;                  else if Sense = S$RecoveredError then do; /* a retry of some type was needed */                     call LogTestRetries(t$SeekTest); /* log the retries */                  end;                  else if (Sense = S$MediumError) or (Sense = S$HardwareError) then do; /* the seek failed */                     call LogTestError(t$SeekTest,e#ScsiError,'Unable to Seek',SenseBuf); /* store SCSI sense information */                  end;                  else State = LogUnknownError(t$SeekTest,Sense);                  DrivePtr = core(DriveHdl); /* get pointer to drive record */                  core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* count no. times state has been repeated */                  if (core(DrivePtr + d$StateIteration) mod 100) = 0                  then delay = 1; /* allow screen update once and a while */               end;               done = true;            end;         end;         do; /* Search Test */            if core(DrivePtr + d$StateIteration) = i#ZoneMax then do; /* all searches have completed */               /* Construct Mode Select Parameter list */               DataBuf(0) = 4;               call pbyte(DataBuf,0,0); /* reserved */               call pbyte(DataBuf,1,0); /* reserved */               call pbyte(DataBuf,2,0); /* clear EBC bit */               call pbyte(DataBuf,3,0); /* block descriptor length */               call ModeSelect(CmdBuf,LUN,4); /* disable blank check using Mode Select */               Sense = SendCommand(D24,Target,true);               State = WriteTest; /* go do write tests */               if Sense <> S$Good               then State = LogUnknownError(t$SearchTest,Sense); /* something weird happened */               call LogTestResults(t$SearchTest); /* log test with no errors */               j = 0;               do i = 0 to i#ZoneMax - 1;                  q = GetInfoPtr(DriveHdl) + GetZoneOffset(i);                  if core(q + i$ZoneStatus) = i#ZoneFull then j = j + 1;               end;               if j = i#ZoneMax then do; /* all zones are full */                  call LogTestError(t$SearchTest,e#TextError,'Cartridge is Full',DataBuf); /* log error */                  State = CartridgeFull; /* cannot continue tests */               end;               delay = 1;               done = true;            end;            else if core(q + i$ZoneStatus) = i#ZoneFull then do; /* nothing to search for this zone */               core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1;            end;            else if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               call LogTestAttempt(t$SearchTest); /* log attempt */               Sense = S$Good;               if core(DrivePtr + d$StateIteration) = 0 then do; /* this is the first search */                  call LogTestIteration(t$SearchTest); /* log iteration */                  /* Construct Mode Select Parameter list */                  DataBuf(0) = 4;                  call pbyte(DataBuf,0,0); /* reserved */                  call pbyte(DataBuf,1,0); /* reserved */                  call pbyte(DataBuf,2,1); /* set EBC bit */                  call pbyte(DataBuf,3,0); /* block descriptor length */                  call ModeSelect(CmdBuf,LUN,4); /* enable blank check using Mode Select */                  Sense = SendCommand(D24,Target,true);               end;               if Sense = S$Good then do; /* bit is set */                  msw = core(q + i$MS_ZoneSector) - core(q + i$MS_ZoneOrigin); /* compute amount already written */                  if core(q + i$LS_ZoneSector) ilt core(q + i$LS_ZoneOrigin) then msw = msw - 1;                  lsw = core(q + i$LS_ZoneSector) - core(q + i$LS_ZoneOrigin);                  msw = core(p + i$MS_ZoneSize) - msw; /* compute amount not written */                  if core(p + i$LS_ZoneSize) ilt lsw then msw = msw - 1;                  lsw = core(p + i$LS_ZoneSize) - lsw;                  if lsw = 0 then msw = msw - 1; /* subtract one so it won't search first sector of next zone */                  lsw = lsw - 1;                  /* Construct Search for Empty Blocks Parameter Block */                  DataBuf(0) = 10;                  DataBuf(1) = rot(core(q + i$MS_ZoneSector),8); /* starting block */                  DataBuf(2) = rot(core(q + i$LS_ZoneSector),8);                  DataBuf(3) = rot(msw,8); /* no. blocks to scan */                  DataBuf(4) = rot(lsw,8);                  DataBuf(5) = rot(t#PatternMax,8); /* no. empty blocks to look for */                  /* Construct Search For Empty Blocks Command */                  CmdBuf(0) = 6;                  call pbyte(CmdBuf,0,"H0C"); /* search for empty blocks command */                  call pbyte(CmdBuf,1,shl(LUN,5));                  call pbyte(CmdBuf,2,0);                  call pbyte(CmdBuf,3,0);                  call pbyte(CmdBuf,4,0);                  call pbyte(CmdBuf,5,0);                  Sense = SendCommand(D24,Target,false); /* send command */                  if Sense = S$Good then do; /* command sent OK */                     do while (read(ScsiBus) and S$REQ) = 0; end; /* wait for REQ */                     if (read(ScsiBus) and S$SigMask) = S$DataOut /* data out phase has appeared */                     then do i = 0 to DataBuf(0) - 1; /* write out parameter block bytes */                        write(ScsiByte) = byte(DataBuf,i);                     end;                     core(q + i$ZoneStatus) = i#NoError; /* no errors on this zone */                     PendingTarget(D24) = Target; /* there is now a command waiting */                     delay = 4;                     done = true; /* go and wait for status */                  end;               end;               if Sense <> S$Good then do;                  core(q + i$ZoneStatus) = i#SearchError; /* an error occurred during search */                  State = LogUnknownError(t$SearchTest,Sense); /* something weird happened */               end;            end;            else do; /* get status from command */               delay = 10;               if REQPresent(D24) then do; /* there is a REQ out there */                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if Sense = S$Good then do; /* search did not find the requested empty blocks */                     core(q + i$ZoneStatus) = i#ZoneFull; /* no more room in this zone */                  end;                  else if Sense = S$ConditionMet then do; /* the empty blocks were found */                     call RequestSense(CmdBuf,LUN,8); /* get information bytes */                     Sense = SendCommand(D24,Target,true);                     if Sense = S$Good then do; /* got 'em */                        core(q + i$MS_ZoneSector) = (shl(byte(DataBuf,3),8) or byte(DataBuf,4)); /* get block where empty blocks were found */                        core(q + i$LS_ZoneSector) = (shl(byte(DataBuf,5),8) or byte(DataBuf,6));                        core(q + i$ZoneStatus) = i#NoError; /* no errors on this zone */                     end;                  end;                  else do; /* something else happened */                     if Sense = S$RecoveredError /* a retry of some type was needed */                     then call LogTestRetries(t$SearchTest); /* log the retries */                  end;                  if Sense <> S$Good then do;                     core(q + i$ZoneStatus) = i#SearchError; /* an error occurred during search */                     State = LogUnknownError(t$SearchTest,Sense); /* something weird happened */                  end;                  core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* count no. times state has been repeated */                  delay = 0;               end;               done = true;            end;         end;         do; /* Write Test */            if core(DrivePtr + d$StateIteration) = i#ZoneMax then do; /* all writes have completed */               call LogTestResults(t$WriteTest); /* log test results */               State = ReadTest;               delay = 1;               done = true;            end;            else if core(q + i$ZoneStatus) <> i#NoError then do; /* there has been an error */               core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* skip this zone */            end;            else if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               if core(DrivePtr + d$StateIteration) = 0 /* first write */               then call LogTestIteration(t$WriteTest); /* log iteration *//*             pcmd('Writing to Zone, Sector: ');               j = p + GetZoneOffset(core(DrivePtr + d$StateIteration));               unum(core(DrivePtr + d$StateIteration),6);               pn(core(j + i$MS_ZoneSector),core(j + i$LS_ZoneSector),10);               call rchar; call RestoreCursor; */               call LogTestAttempt(t$WriteTest); /* log attempt */               call ExtendedWrite(CmdBuf,LUN,core(q + i$MS_ZoneSector),core(q + i$LS_ZoneSector),t#PatternMax); /* write the data pattern */               Sense = SendCommand(D24,Target,false); /* send command */               if Sense = S$Good then do; /* command sent OK */                  PendingTarget(D24) = Target; /* there is now a command waiting */                  delay = 0;                  done = true; /* go and wait for status */               end;               else State = LogUnknownError(t$WriteTest,Sense); /* something weird happened */            end;            else do; /* get status from command */               delay = 0;               if REQPresent(D24) then do; /* there is a REQ out there */                  if (read(ScsiBus) and S$SigMask) = s$DataOut then do; /* data out phase is around */                     call WritePattern; /* write the data */                  end;                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if Sense = S$Good then do; /* write completed successfully */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if Sense = S$RecoveredError then do; /* a retry of some type was needed */                     call LogTestRetries(t$WriteTest); /* log the retries */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if (Sense = S$MediumError) or (Sense = S$HardwareError) then do; /* the write failed */                     call LogTestError(t$WriteTest,e#ScsiError,'Unable to Write',SenseBuf); /* store SCSI sense information */                     core(q + i$ZoneStatus) = i#WriteError;                  end;                  else do;                     State = LogUnknownError(t$WriteTest,Sense);                     core(q + i$ZoneStatus) = i#WriteError;                  end;                  DrivePtr = core(DriveHdl); /* get pointer to drive record */                  core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* count no. times state has been repeated */                  delay = 1;               end;               done = true;            end;         end;         do; /* Read Test */            if core(DrivePtr + d$StateIteration) = i#ZoneMax then do; /* all reads have completed */               call LogTestResults(t$ReadTest); /* log test results */               State = RandomReadTest;               delay = 1;               done = true;            end;            else if core(q + i$ZoneStatus) <> i#NoError then do; /* there has been an error */               core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* skip this zone */            end;            else if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               if core(DrivePtr + d$StateIteration) = 0 /* first read */               then call LogTestIteration(t$ReadTest); /* log iteration *//*             pcmd('Reading from Zone, Sector: ');               j = p + GetZoneOffset(core(DrivePtr + d$StateIteration));               unum(core(DrivePtr + d$StateIteration),6);               pn(core(j + i$MS_ZoneSector),core(j + i$LS_ZoneSector),10);               call rchar; call RestoreCursor; */               call LogTestAttempt(t$ReadTest); /* log attempt */               call ExtendedRead(CmdBuf,LUN,core(q + i$MS_ZoneSector),core(q + i$LS_ZoneSector),t#PatternMax); /* write the data pattern */               Sense = SendCommand(D24,Target,false); /* send command */               if Sense = S$Good then do; /* command sent OK */                  PendingTarget(D24) = Target; /* there is now a command waiting */                  delay = 0;                  done = true; /* go and wait for status */               end;               else State = LogUnknownError(t$ReadTest,Sense); /* something weird happened */            end;            else do; /* get status from command */               delay = 0;               if REQPresent(D24) then do; /* there is a REQ out there */                  if (read(ScsiBus) and S$SigMask) = s$DataIn /* data in phase is around */                  then call ReadPattern(core(q + i$MS_ZoneSector),core(q + i$LS_ZoneSector),0); /* read the data */                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if Sense = S$Good then do; /* read completed successfully */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if Sense = S$RecoveredError then do; /* a retry of some type was needed */                     call LogTestRetries(t$ReadTest); /* log the retries */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if (Sense = S$MediumError) or (Sense = S$HardwareError) then do; /* the write failed */                     call LogTestError(t$ReadTest,e#ScsiError,'Unable to Read',SenseBuf); /* store SCSI sense information */                     core(q + i$ZoneStatus) = i#ReadError;                  end;                  else do;                     State = LogUnknownError(t$ReadTest,Sense);                     core(q + i$ZoneStatus) = i#ReadError;                  end;                  DrivePtr = core(DriveHdl); /* get pointer to drive record */                  core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* count no. times state has been repeated */                  delay = 1;               end;               done = true;            end;         end;         do; /* Random Read Test */            i = random(i#ZoneMax); /* generate a random zone */            q = p + GetZoneOffset(i); /* get pointer to this zone record */            if core(DrivePtr + d$StateIteration) = t#ReadMax then do; /* all reads have completed */               call LogTestResults(t$ReadTest); /* log test results */               State = SelfTest; /* go do self tests again */               delay = 1;               done = true;            end;            else if core(q + i$ZoneStatus) <> i#NoError then do; /* there has been an error */               core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* skip this zone */            end;            else if PendingTarget(D24) = -1 then do; /* nothing pending, so start command */               core(p + i$RandomZone) = i; /* store random zone */               core(p + i$RandomSector) = random(t#PatternMax); /* get a random sector in this zone */               msw = core(q + i$MS_ZoneSector);               lsw = core(q + i$LS_ZoneSector) + core(p + i$RandomSector); /* computer sector address */               if lsw ilt core(q + i$LS_ZoneSector) then msw = msw + 1;               call LogTestAttempt(t$ReadTest); /* log attempt */               call ExtendedRead(CmdBuf,LUN,msw,lsw,1); /* read one block */               Sense = SendCommand(D24,Target,false); /* send command */               if Sense = S$Good then do; /* command sent OK */                  PendingTarget(D24) = Target; /* there is now a command waiting */                  delay = 0;                  done = true; /* go and wait for status */               end;               else State = LogUnknownError(t$ReadTest,Sense); /* something weird happened */            end;            else do; /* get status from command */               delay = 0;               if REQPresent(D24) then do; /* there is a REQ out there */                  q = p + GetZoneOffset(core(p + i$RandomZone)); /* get pointer to zone record */                  msw = core(q + i$MS_ZoneSector);                  lsw = core(q + i$LS_ZoneSector) + core(p + i$RandomSector); /* computer sector address */                  if lsw ilt core(q + i$LS_ZoneSector) then msw = msw + 1;                  if (read(ScsiBus) and S$SigMask) = s$DataIn /* data in phase is around */                  then call ReadPattern(msw,lsw,core(p + i$RandomSector)); /* read the data */                  Sense = GetStatus(D24,Target); /* get status */                  PendingTarget(D24) = -1; /* no command pending now */                  if Sense = S$Good then do; /* read completed successfully */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if Sense = S$RecoveredError then do; /* a retry of some type was needed */                     call LogTestRetries(t$ReadTest); /* log the retries */                     core(q + i$ZoneStatus) = i#NoError;                  end;                  else if (Sense = S$MediumError) or (Sense = S$HardwareError) then do; /* the write failed */                     call LogTestError(t$ReadTest,e#ScsiError,'Unable to Read',SenseBuf); /* store SCSI sense information */                     core(q + i$ZoneStatus) = i#ReadError;                  end;                  else do;                     State = LogUnknownError(t$ReadTest,Sense);                     core(q + i$ZoneStatus) = i#ReadError;                  end;                  DrivePtr = core(DriveHdl); /* get pointer to drive record */                  core(DrivePtr + d$StateIteration) = core(DrivePtr + d$StateIteration) + 1; /* count no. times state has been repeated */                  if (core(DrivePtr + d$StateIteration) mod 100) = 0                  then delay = 1; /* allow screen update once and a while */               end;               done = true;            end;         end;      end; /* case states */   end; /* while not done */   DrivePtr = core(DriveHdl); /* get pointer to drive record */   core(DrivePtr + d$PrevState) = core(DrivePtr + d$State); /* save previous state */   core(DrivePtr + d$State) = State; /* store new state */   return (delay);end ProcessOptical;