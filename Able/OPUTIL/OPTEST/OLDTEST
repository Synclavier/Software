/* Optical Disk Test Program *//* by Kip Olson, July 1987 */configuration ModelC,MulDiv;insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:termut';   /* terminat utilites */insert ':-xpl:catswap';  /* catalog routines */ /* ##### Get Rid of this and abort.scsi */insert ':-xpl:scsirout'; /* scsi drivers */insert ':-xpl:scsicmds'; /* scsi commands */insert ':-xpl:optical';  /* optical disk routines */abort.scsi: proc public; end;dcl rel.date data ('9 October 1987');dcl OptBuf(H#Rec_Length - 1) fixed; /* optical disk buffer */dcl Vendor(8 / 2)         fixed; /* vendor name */dcl Model(16 / 2)         fixed; /* model name */dcl Revision(4 / 2)       fixed; /* revision level */dcl Release(8 / 2)        fixed; /* release date */dcl PartNo(12 / 2)        fixed; /* part no. */dcl VolName(H#Name_Max)   fixed; /* volume name */dcl freestart             fixed; /* first word of free memory */dcl freesecs              fixed; /* size of free memory in sectors */dcl StatBuf(Stat#Rec_Length - 1) fixed; /* buffer for statistics data */dcl FileEntry             fixed; /* no. file being read */dcl choice                fixed;dcl ReadIterations        fixed; /* no. iterations of read test to perform */dcl SeekIterations        fixed; /* no. seeks to do per file */dcl (MS_TestLen,LS_TestLen) fixed; /* no. sectors to test */dcl TestLevel             fixed; /* level to test */dcl Errors                fixed; /* error counter *//* Random number generator */dcl a         lit '25173';                 /* Random constant */dcl c         lit '13849';                 /* Random constant */dcl seed      fixed;random: proc(size); /* originally long random (size); */   dcl size fixed; /* originally long size; */   seed = seed * a + c;   return (seed mod size);end random;Print_Error: proc; /* print various errors */   pstring('ERROR: ');   if S$SenseKey = S$Good then do; /* no sense - must be in c#status */      if c#status = e#dir_full /* no more directory entries */      then pstringr('Directory area full - no more files may be added.');      else if c#status = e#storage /* no more space on disk */      then pstringr('Data area full - no more files may be added.');      else do; pstring('Catalog error: '); pnum(c#status,0); crlf; end;   end;   else if S$SenseKey > 0 then do; /* SCSI sense key */      do case S$SenseKey;         ; /* S$Good */         hnum(S$SenseKey,4); /* S$RecoveredError */         pstringr('Drive not ready - insert cartridge and press START.'); /* S$NotReady */         pstringr('Medium Failure - Cartridge is defective.'); /* S$ MediumError */         pstringr('Hardware Failure - Drive is defective.'); /* S$HardwareFailure */         pstringr('Illegal Request - System Software is defective.'); /* S$Illegal Request */         pstringr('Cartridge was changed during test.'); /* S$Unit Attention */         pstringr('Cartridge is write-protected.'); /* S$DataProtect */         pstringr('Cartridge has not been formatted.'); /* S$Blank Check */      end;   end;   else do; /* Connection failure */      if S$SenseKey = S$BadDevice      then pstringr('Drive not in configuration.');      else do case abs(S$SenseKey);         ; /* S$GoodConnect */         pnum(S$SenseKey,0); /* S$ArbFailed */         pstringr('Drive not responding - check power and cabling.');         pnum(S$SenseKey,0); /* S$IdentFailed */         pstringr('D24 board not found.'); /* S$D24NotFound */         pnum(S$SenseKey,0); /* S$BadBusState */         pnum(S$SenseKey,0); /* S$BadInitiator */      end;   end;end Print_Error;Get_File_Name: proc(BufIndex,Len,Name); /* get file name from optical disk buffer */   dcl BufIndex fixed; /* starting index of name in buffer */   dcl Len      fixed; /* length of name in words */   dcl Name     fixed array; /* array space to return name in */   dcl (i,c)   fixed;   Name(0) = 0; i = 0; c = -1; /* get the name of the file */   do while (i ilt Len) and (c <> 0); /* loop over characters of file name */      c = gbuf(BufIndex + i); /* get word of file name */      if c <> 0 then do; /* there's a character in there somewhere */         Name(1 + i) = c; /* store character(s) */         Name(0) = Name(0) + 1 + (shr(c,8) <> 0); /* count the no. characters */      end;      i = i + 1; /* next word */   end;end Get_File_Name;Get_Buffer_String: proc(Buf,BufIndex,Len,Str); /* get string from buffer */   dcl Buf      fixed array; /* buffer to use */   dcl BufIndex fixed; /* starting index of name in buffer */   dcl Len      fixed; /* length of string in bytes */   dcl Str      fixed array; /* array space to return string in */   dcl EndIndex fixed; /* last index to check */   EndIndex = BufIndex + Len; /* calculate last index */   do while (EndIndex > BufIndex)   and ((byte(Buf,EndIndex - 1) = a.SP) or (byte(Buf,EndIndex - 1) = 0)); /* skip over trailing spaces */      EndIndex = EndIndex - 1;   end;   do while (BufIndex < EndIndex)    and ((byte(Buf,BufIndex) = a.SP) or (byte(Buf,BufIndex) = 0)); /* skip over leading spaces */      BufIndex = BufIndex + 1;   end;   Str(0) = 0; /* nothing in string yet */   do while BufIndex < EndIndex; /* loop over valid characters */      call pbyte(Str,Str(0),byte(Buf,BufIndex)); /* put character in string */      Str(0) = Str(0) + 1; /* add to string length */      BufIndex = BufIndex + 1; /* go to next character in buffer */   end;end Get_Buffer_String;Open_Drive: proc(StatBuf,Level) returns (boolean); /* open up drive for testing */   dcl StatBuf fixed array; /* buffer for statistics */   dcl Level   fixed; /* level to open */   dcl DevAdr  fixed; /* SCSI device address of drive */   dcl BufMax  lit '32'; /* no. bytes required for Inquiry buffer */   dcl Buf(BufMax / 2) fixed; /* buffer */   dcl (i,ch)  fixed;   if not ReadHeader(Level) then do; /* could not read header */      if S$SenseKey = S$UnitAttention then do; /* clear unit attention */         if not ReadHeader(Level) /* still won't read */         then return (false); /* die */      end;      else return (false); /* die */   end;   call Get_File_Name(H$Name,H#Name_Max,VolName); /* get volume name */   i = find_device(Level); /* search in configuration for this device */   DevAdr = core(i + s#devadr); /* get device address */   S$SenseKey = Inquiry(DevAdr,56,Buf); /* get inquiry information */   if S$SenseKey <> S$Good then return (false); /* die */   if byte(Buf,0) <> 4 then do; /* not an optical disk */      S$SenseKey = S$BadDevice; /* invalid device */      return (false); /* die */   end;   if (Buf(0) = 56) and (byte(Buf,3) igt 0) then do; /* CCS format */      call Get_Buffer_String(Buf,8,8,Vendor); /* get vendor name */      call Get_Buffer_String(Buf,16,16,Model); /* get model */      call Get_Buffer_String(Buf,32,4,Revision); /* get revision level */      call Get_Buffer_String(Buf,36,8,Release); /* get release date */      call Get_Buffer_String(Buf,44,12,PartNo); /* get part no. */   end;   else do; /* non-CCS format */      Vendor(0) = 0; /* no vendor name */      Model(0) = 0; /* no Model name */   end;   if not Get_Statistics(Level,StatBuf) /* get disk statistics */   then return (false);   O$EntryCount = StatBuf(Stat$Dir_Start); /* set to first free directory entry */   return (true); /* everything is cool */end Open_Drive;Print_Stats: proc(StatBuf);   dcl StatBuf fixed array;   dcl (msw,lsw) fixed;   PrintNum: proc(msw,lsw,field);      dcl (msw,lsw) fixed; /* no. blocks */      dcl field     fixed; /* field width */      lnum(msw,lsw,field); pstring(' sectors');      write("5") = lsw; /* find no. megabytes */      write("4") = msw;      write("7") = 2048; /* MB = Sectors / 2048 */      lsw = read("5") + (read("4") igt shr(2048,1)); /* round up if neccessary */      if lsw <> 0 then do;         pstring(' ('); unum(lsw,0); pstring(' megabyte');         if lsw <> 1 then wchar(l.s);         wchar(a.rparen);      end;   end PrintNum;   msw = StatBuf(stat$MS_Used) + StatBuf(stat$MS_Free); /* calculate total no. blocks */   lsw = StatBuf(stat$LS_Used) + StatBuf(stat$LS_Free);   if lsw ilt StatBuf(stat$LS_Used) then msw = msw + 1;   pstringr('Drive');   pstring ('  Vendor:   '); pstringr(Vendor);   pstring ('  Model:    '); pstringr(Model);   pstringr('Firmware');   pstring ('  Revision: '); pstringr(Revision);   pstring ('  Date:     '); pstringr(Release);   pstring ('  Part No.: '); pstringr(PartNo);   pstringr('Volume');   pstring ('  Name:     '); pstringr(VolName);   pstringr('Capacity');   pstring ('  Total: '); call PrintNum(msw,lsw,10); crlf;   pstring ('  Used:  '); call PrintNum(StatBuf(stat$MS_Used),StatBuf(stat$LS_Used),10); crlf;   pstring ('  Free:  '); call PrintNum(StatBuf(stat$MS_Free),StatBuf(stat$LS_Free),10); crlf;end Print_Stats;Change_Parameters: procedure; /* change test parameters */   dcl choice fixed; /* menu choice */   choice = -1;   do while choice <> 0;      crlf;      pstringr('Current parameters are:');      crlf;      pstring('1. Test pattern:         '); pstringr('Ramp');      pstring('2. Write test sectors:   '); lnum(MS_TestLen,LS_TestLen,0); crlf;      pstring('3. Read test iterations: '); unum(ReadIterations,0); crlf;      pstring('4. Seek test iterations: '); unum(SeekIterations,0); crlf;      crlf;      pstring('Enter parameter to change, <RETURN> when done: '); choice = getuns; crlf;      crlf;            do case choice;         ;         do;            pstringr('The test pattern cannot be changed at this time.');         end;         do;            pstring('Enter new no. sectors to write: '); LS_TestLen = getuns; crlf;         end;         do;            pstring('Enter new no. read test iterations: '); ReadIterations = getuns; crlf;         end;         do;            pstring('Enter new no. seek test iterations: '); SeekIterations = getuns; crlf;         end;      end;   end;end Change_Parameters;Transfer_Pattern: proc(Writing,MS_Source,LS_Source,Offset,MS_Total,LS_Total,Level) returns (boolean); /* transfer pattern */   dcl Writing               boolean; /* TRUE to write the pattern, FALSE to read it */   dcl (MS_Source,LS_Source) fixed; /* starting sector */   dcl Offset                fixed; /* offset from starting sector */   dcl (MS_Total,LS_Total)   fixed; /* total no. sectors to transfer */   dcl Pattern               fixed; /* pattern to transfer */   dcl Level                 fixed; /* level to transfer */   dcl (MS_Trans,LS_Trans)   fixed; /* no. sectors transferred so far */   dcl chunk                 fixed; /* sector chunk to transfer */   dcl (msw,lsw)             fixed;   dcl ErrCount              fixed;   WriteRamp: proc(buf,words); /* read and verify ramp wave */      dcl buf   fixed array; /* buffer to use */      dcl words fixed; /* no. words to write */      dcl i     fixed;      i = 0; words = words;      do while i <> words;         buf(i) = read(r13i); /* fill buffer with pattern */         i = i + 1;      end;   end WriteRamp;   PrintMismatch: proc(index,expected,received);      dcl index     fixed; /* index with the 64K section */      dcl expected  fixed; /* expected value */      dcl received  fixed; /* received value */      dcl (msw,lsw) fixed;      if ErrCount ilt 10 then do;         msw = (MS_Source and "HFF"); /* calulate sector */         lsw = LS_Source + shr(index,8);         if lsw ilt LS_Source then msw = msw + 1;         if ErrCount = 0 then crlf;         pstring('Mismatch in file '); unum(FileEntry,0);         pstring(', sector '); unum(offset,0);         pstring(', word '); unum(index and "HFF",0);         pstring(': Expected = '); hnum(expected,4);         pstring(', Received = '); hnum(received,4); crlf;      end;      else if ErrCount = 10 then pstringr('more...');      Errors = Errors + 1;      ErrCount = ErrCount + 1;   end PrintMismatch;   ReadRamp: proc(buf,words); /* read and verify ramp wave */      dcl buf   fixed array; /* buffer to use */      dcl words fixed; /* no. words to check */      dcl i     fixed;      i = 0; words = words;      do while i <> words;         if buf(i) <> read(r13i)         then call PrintMismatch(i,read(r13) - 1,buf(i));         i = i + 1;      end;   end ReadRamp;   /* main procedure */   ErrCount = 0;   write(r13) = shl(Offset,8); /* start accumulator at correct value */   MS_Source = (shl(Level,8) or MS_Source); /* calculate actual starting sector */   LS_Source = LS_Source + Offset;   if LS_Source ilt Offset then MS_Source = MS_Source + 1;   MS_Trans = 0; LS_Trans = 0; /* no sectors transferred yet */   do while (MS_Trans ilt MS_Total) or ((MS_Trans = MS_Total) and (LS_Trans ilt LS_Total)); /* repeat until file is transferred */      msw = MS_Total - MS_Trans; /* find amount left to transfer */      if LS_Total ilt LS_Trans then msw = msw - 1;      lsw = LS_Total - LS_Trans;      if msw <> 0 /* more than 64k sectors to transfer */      then chunk = freesecs; /* set to buffer size */      else if lsw igt freesecs /* more than a buffer load to transfer */      then chunk = freesecs; /* limit to size of buffer */      else chunk = lsw; /* set to amount left to transfer */      if writing then do; /* write to disk */         call WriteRamp(loc(freestart),shl(chunk,8)); /* write pattern to buffer */         call writedata(MS_Source,LS_Source,loc(freestart),shl(chunk,8)); /* write buffer to disk */      end;      else do; /* read from disk */         call readdata(MS_Source,LS_Source,loc(freestart),shl(chunk,8)); /* get buffer full */         call ReadRamp(loc(freestart),shl(chunk,8)); /* verify pattern in buffer */      end;      LS_Source = LS_Source + chunk; /* update starting sector */      if LS_Source ilt chunk then MS_Source = MS_Source + 1;      LS_Trans = LS_Trans + chunk; /* count sectors transferred */      if LS_Trans ilt chunk then MS_Trans = MS_Trans + 1;      ckread;      if peek <> -1 then do; /* key struck */         if rchar = 0 then return (false); /* quit if they hit break */      end;   end;   return (true); /* pattern was transferred */end Transfer_Pattern;Write_Pattern: proc(Header,Level); /* write pattern to disk */   dcl Header fixed array; /* array space for sound file header */   dcl Level  fixed; /* level to write to */   dcl Name   data ('FIL00000'); /* file name */   dcl (i,j)  fixed;   crlf;   pstringr('**************************************************************');   pstringr('*                                                            *');   pstringr('*    This test writes data to a section of the disk. Once    *');   pstringr('*    written, this section cannot be used again. The free    *');   pstringr('*    space on the disk will be reduced accordingly.          *');   pstringr('*                                                            *');   pstringr('**************************************************************');   crlf;   if Get_YN('Do you wish to write this section [Y(es) or N(o)]? ') then do; /* do it */      crlf;      do i = 0 to E#Header_Max - 1; /* zero out sound file header */         Header(i) = 0;      end;      j = O$EntryCount; /* entry number of new file */      do i = 7 to 3 by -1; /* put file number into name */         call pbyte(Name,i,a.0 + (j mod 10));         j = j / 10;      end;               pstring('Creating file '); pstring(Name); pstringr('...');      if Optical_Replace(Name,t#data,MS_TestLen,LS_TestLen,shl(LS_TestLen,8),Header,-1,Level) then do; /* replace file on optical */         pstringr('Writing Section...');         if Transfer_Pattern(TRUE,F#MS_Sector and "HFF",F#LS_Sector,0,MS_TestLen,LS_TestLen,Level) then do; /* write pattern */            pstringr('Reading Section...');            if Transfer_Pattern(FALSE,F#MS_Sector and "HFF",F#LS_Sector,0,MS_TestLen,LS_TestLen,Level) then do; /* read pattern */               pstringr('Write Test Complete');            end;            else pstringr('Test Aborted');         end;         else pstringr('Test Aborted');      end; /* replace successful */      else call Print_Error;   end; /* do test */   else crlf;end Write_Pattern;Read_Pattern: proc(Level); /* read pattern from disk */   dcl Level     fixed; /* level to read */   dcl Iteration fixed; /* test iteration */   dcl Name(E#Name_Max) fixed; /* string for name */   dcl (MS_Start,LS_Start) fixed; /* starting sector of file */   dcl SecMax    fixed; /* no. sectors in file */   dcl (i,j)     fixed;   do Iteration = 1 to ReadIterations; /* loop over required iterations */      FileEntry = random(O$EntryCount); /* get random entry to read */      S$SenseKey = ReadEntry(FileEntry,Level); /* try to read it */      if S$SenseKey <> S$Good then do;         call Print_Error;         return;      end;      Name(0) = 0; /* get name of file */      do i = 0 to shl(E#Name_Max,1) - 1; /* loop over characters of name */         j = gbuf(E$Name + shr(i,1));         if (i and "1") <> 0 then j = shr(j,8); else j = (j and "HFF");         if j <> 0 then do;            call pbyte(Name,Name(0),j);            Name(0) = Name(0) + 1;         end;      end;      MS_Start = gbuf(E$MS_SecStart); /* get first sector of file */      LS_Start = gbuf(E$LS_SecStart);      SecMax = gbuf(E$LS_SecLen); /* get no. sectors in file */      if gbuf(E$MS_SecLen) <> 0 then SecMax = 65535; /* limit to 64 K sectors */      wchar(a.CR); pstring('Iteration: '); unum(Iteration,5);      pstring(', File: '); unum(FileEntry,5);      pstring(', Total Errors: '); unum(Errors,5);      do i = 1 to SeekIterations; /* seek to various sectors in the file */         j = random(SecMax); /* get random sector */         if not Transfer_Pattern(FALSE,MS_Start,LS_Start,j,0,1,Level) then do; /* could not read pattern */            crlf;            pstringr('Test Aborted');            return;         end;      end;   end;   crlf;   pstringr('Read Test Complete');end Read_Pattern;/* Main Program */pstring('Optical Disk Test Program - '); pstringr(rel.date);call Set_OptBuf(addr(OptBuf(0)),0); /* set optical disk buffer */ReadIterations = 100; /* no. read iterations to perform */SeekIterations = 100; /* no. seeks / file */MS_TestLen = 0; /* no. sectors / file to write */LS_TestLen = 20480;TestLevel = 10; /* level to test */Errors = 0;seed = read(r15); /* use stack pointer for seed */freestart = core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen); /* calc first word of free memory */freesecs = shr(loc.load - freestart,8); /* find size of free memory in sectors */if (freesecs and "1") <> 0 then freesecs = freesecs - 1; /* make sure its not odd */unum(freesecs,0); pstringr(' sectors of internal memory available');crlf;if not Open_Drive(StatBuf,TestLevel) then do; /* try to mount optical disk */   call Print_Error; /* print error messages */   call exit(-1); /* die */end;call Print_Stats(StatBuf); /* print statistics */choice = -1;do while choice <> 0;   crlf;   pstringr('1. Change Parameters');   pstringr('2. Write Test');   pstringr('3. Read Test');   crlf;   pstring('Enter choice or RETURN to quit: '); choice = getuns; crlf;   crlf;   do case choice;      ;      call Change_Parameters;      call Write_Pattern(loc(freestart),TestLevel);      call Read_Pattern(TestLevel);   end;end;