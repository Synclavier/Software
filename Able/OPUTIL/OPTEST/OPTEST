/*   Optical Disk Test Program   by Kip Olson, February 1988   Modification History:   02/24/96 - CWJ - copy protection removed   03/15/89 - LSS - copy protection and warning message added   06/20/88 - KJO - Fixed bugs saving files, added prompt for time info*/configuration ModelC,MulDiv;insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:literals'; /* General literals */insert ':-xpl:termutil'; /* Interrupt terminal utilities */insert ':-xpl:dynamic';  /* Dynamic memory allocation */insert ':-xpl:scsirout'; /* SCSI routines */insert ':-xpl:catrtns';  /* Catalog routines */insert ':-xpl:fileio';   /* File managment routines */insert ':scsidev:comlib'; /* SCSI commands */dcl ReleaseDate data ('1 April 1989');/***** Drive Record Format ******/dcl d$State          lit '0'; /* current state */dcl d$PrevState      lit '1'; /* previous state */dcl d$Process        lit '2'; /* process mode */dcl d$MS_FirstTime   lit '3'; /* time drive was first found */dcl d$LS_FirstTime   lit '4';dcl d$MS_StateTime   lit '5'; /* time state was first entered */dcl d$LS_StateTime   lit '6';dcl d$StateIteration lit '7'; /* no. times in a row state has been repeated */dcl d$DevType        lit '8'; /* device type of drive at this address */dcl d$Iterations     lit '9'; /* no. iterations of state */dcl d$MS_Errors      lit '10'; /* no. errors encountered so far */dcl d$LS_Errors      lit '11'; /* no. errors encountered so far */dcl d$InfoHandle     lit '13'; /* handle to drive information */dcl d$TestHandle     lit '14'; /* handle to test log */dcl d$ErrorHandle    lit '15'; /* handle to error log */dcl d#DriveRecLen    lit '16'; /* no. words in drive record *//***** Device Record Format *****/dcl v$DriveHandle  lit '0'; /* handle to drive record */dcl v$MS_NextTime  lit '1'; /* next time to process this device */dcl v$LS_NextTime  lit '2';dcl v#DevRecLen    lit '3'; /* no. words in device record */dcl D24Max         lit '4';  /* no. D24 boards allowed */dcl TargetMax      lit '7';  /* no. SCSI target IDs allowed */dcl dev(D24Max * TargetMax * v#DevRecLen - 1) fixed; /* device record for each possible device *//***** Error Record Format *****//*   The error record is made up of variable length subrecords.   The general format of a subrecord is as follows:   Words   0 - n:  Error data required for all errors   Words n+1 - m:  Error data specific to this error   When an error is logged, a subrecord for that error is   added to the end of the error record.*//* Data required for all errors */dcl e$ErrorType    lit '0'; /* type of error which occurred */dcl e$NextError    lit '1'; /* offset of next error subrecord in error record */dcl e$Iteration    lit '2'; /* test iteration in which error occurred */dcl e$MS_ErrorTime lit '3'; /* time error occurred */dcl e$LS_ErrorTime lit '4';dcl e$ErrorMsg     lit '5'; /* start of error message string */dcl e#ErrorRecLen  lit '5'; /* no. words in static part of record */dcl e#ErrorMax     lit '100'; /* maximum no. errors to store for each device *//***** Test Record Format *****//*   The test record is made up of fixed length subrecords.   The general format of a subrecord is as follows:   Words   0 - n:  Test data required for all tests   Words n+1 - m:  Test data specific to this test   The precise format of the various subrecords is given below.   Since the number of tests is known in advance, there is a fixed   number of subrecords in the test record. For each test, there is   a linked list of pointers to error subrecords, recording all the   errors which have occurred during the test.*//* Data required for all tests */dcl t$Iterations       lit '0'; /* no. test iterations */dcl t$FirstError       lit '1'; /* offset of first subrecord in error record */dcl t$MS_Seconds       lit '2'; /* no. seconds spent on test */dcl t$LS_Seconds       lit '3';dcl t$MS_Attempts      lit '4'; /* no. times test was attempted */dcl t$LS_Attempts      lit '5';dcl t$MS_Failures      lit '6'; /* no. times test failed */dcl t$LS_Failures      lit '7';dcl t#TestRecLen       lit '8'; /* no. words in record *//* SCSI Device Types */dcl S$DirectAccess     lit '0'; /* Direct access */dcl S$SequentialAccess lit '1'; /* Sequential access */dcl S$Printer          lit '2'; /* Printer */dcl S$Processor        lit '3'; /* Processor */dcl S$WriteOnce        lit '4'; /* Write-once, read-multiple *//* Process Modes */dcl ContProcess  lit '0'; /* continue processing */dcl StopProcess  lit '1'; /* stop processing */dcl InitProcess  lit '2'; /* initialize processing *//* Screen Definitions */dcl NameRow     lit '0';  /* position of program name */dcl NameCol     lit '0';dcl DateRow     lit '0';  /* position of date */dcl DateCol     lit '58';dcl TimeRow     lit '0';  /* position of time */dcl TimeCol     lit '69';dcl FirstRow    lit '2';  /* position of first table */dcl FirstCol    lit '0';dcl TableHeight lit '10'; /* height of table */dcl TableWidth  lit '38'; /* width of table */dcl TimeUpdateDelay  lit '1'; /* delay between time of day updates */dcl (MS_Seconds,LS_Seconds) fixed; /* seconds counter */dcl (MS_NextTime,LS_NextTime) fixed; /* time when screen should be updated */dcl (MS_Interval,LS_Interval) fixed; /* time interval between power-off cycles */dcl (MS_NextOffline,LS_NextOffline) fixed; /* time when next power-off cycle will occur */dcl ClockTicks      fixed;dcl CurrentD24      fixed;dcl CurrentTarget   fixed;dcl StartDate       fixed;dcl DayCounter      fixed;dcl PendingTarget(D24Max - 1) fixed; /* target with command outstanding for each D24 */dcl (Quit,Quitting,SaveResults) boolean;dcl TerminalDev   lit '0'; /* output to terminal */dcl PrinterDev    lit '1'; /* output to printer */dcl FileDev       lit '2'; /* output to file */dcl OutputDev     fixed;   /* device to output to */dcl OutFile           file;  /* output file */dcl OutBufLen         lit '1024'; /* size of output buffer in words */dcl OutBuf(OutBufLen - 1) fixed; /* output buffer */dcl OutBufPtr         lit 'addr(OutBuf(0))'; /* pointer to output buffer */dcl OutBufMed         lit '0'; /* buffer is in internal memory */dcl Line(80 / 2)      fixed; /* output line */dcl LineNum           fixed; /* line number */dcl HandleBufSize lit '(D24Max * TargetMax * 4)'; /* space for handles */dcl HandleBuf(HandleBufSize - 1) fixed;dcl CatBuf(C#Dir_Max - 1)        fixed;dcl CatCache fixed;dcl LUN               lit '0'; /* use LUN 0 */dcl CmdBuf(10 / 2)    fixed;  /* space for extended command */dcl DataBuf(1024 / 2) fixed; /* space for a 1K block */dcl SenseBuf(100 / 2) fixed;  /* space for 100 sense bytes */dcl WaitMsg           data ('Strike any key to continue...');dcl ErrMsg(80 / 2)    fixed;dcl rpt               lit  '"10"'; /* repeat counter */dcl repeat            lit 'write(rpt)='; /* repeat macro */when d03int then begin;   ClockTicks = ClockTicks + 1;   if ClockTicks ige d03_speed*100 then do; /* a second has gone by */      ClockTicks = 0;      LS_Seconds = LS_Seconds + 1; /* count the total no. seconds */      if LS_Seconds = 0 then MS_Seconds = MS_Seconds + 1;   end;end;GetDeviceIndex: proc(D24,Target) returns (fixed); /* get index in device array of a device */   dcl D24    fixed; /* D24 of drive */   dcl Target fixed; /* Target of drive */   return (D24 * (TargetMax * v#DevRecLen) + Target * v#DevRecLen); /* return index into device array */end GetDeviceIndex;GetDriveHandle: proc(D24,Target) returns (handle); /* get handle to drive record */   dcl D24    fixed; /* D24 of drive */   dcl Target fixed; /* Target of drive */   return (dev(GetDeviceIndex(D24,Target) + v$DriveHandle)); /* return handle */end GetDriveHandle;GetInfoPtr: proc(DriveHdl) returns (pointer); /* get pointer to info record */   dcl DriveHdl handle; /* handle to drive record */   return (core(core(core(DriveHdl) + d$InfoHandle))); /* return pointer */end GetInfoPtr;GetTestPtr: proc(DriveHdl) returns (fixed); /* get pointer to test record for this drive */   dcl DriveHdl handle; /* handle to drive record */   return (core(core(core(DriveHdl) + d$TestHandle))); /* return pointer to test record */end GetTestPtr;GetErrorPtr: proc(DriveHdl) returns (pointer); /* get pointer to error record */   dcl DriveHdl handle; /* handle to drive record */   return (core(core(core(DriveHdl) + d$ErrorHandle))); /* return pointer */end GetErrorPtr;/* Random number generator */dcl a         lit '25173';                 /* Random constant */dcl c         lit '13849';                 /* Random constant */dcl seed      fixed;random: proc(size); /* originally long random (size); */   dcl size fixed; /* originally long size; */   /* seed = seed * a + c; */   write("5") = a;   write("4") = c;   write("6") = seed;   seed = read("5");   /* return (seed mod size) */   write("5") = seed;   write("7") = size;   return (read("4"));end random;/* Output Routines */#pc: proc(ch); /* print character */   dcl ch fixed; /* character to print */   if OutputDev = FileDev then do; /* output to file */      call pbyte(Line,Line(0),ch); /* add character to line */      Line(0) = Line(0) + 1;   end;   else wchar(ch);end #pc;dcl pc lit 'call #pc';#newline: proc; /* start a new line */   if OutputDev = FileDev then do; /* output to file */      call FPutS(Line,LineNum,OutFile); /* output line to file */      Line(0) = 0;      LineNum = LineNum + 1;   end;   else crlf;end #newline;dcl newline lit 'call #newline';#ps: proc(s); /* print string */   dcl s fixed array; /* string to print */   dcl i fixed;   if OutputDev = FileDev then do; /* output to file */      do i = 0 to s(0) - 1;         pc(byte(s,i));      end;   end;   else pstring(s);end #ps;dcl ps lit 'call #ps';#psr: proc(s); /* print string with a carriage return */   dcl s fixed array; /* string to print */   if OutputDev = FileDev then do; /* output to file */      ps(s); newline;   end;   else pstringr(s);end #psr;dcl psr lit 'call #psr';#pn: proc(ms,ls,field); /* print number */   dcl (ms,ls)   fixed; /* number to print */   dcl field     fixed; /* field width */   dcl (i,r,go)  fixed;   dcl #ms_divisors data (15258, 1525,  152,   15,    1,    0,   0,  0, 0,0); /* powers of ten */   dcl #ls_divisors data (51712,57600,38528,16960,34464,10000,1000,100,10,1);   do i = 1 to field - 10; pc(a.sp); end; /* print out any necessary leading spaces */   go = false; /* suppress leading zeroes */   do i = 0 to 9; /* loop over 10 digits */      r = 0; /* assume digit is zero */      do while ((ms IGT #ms_divisors(i)) /* must simulate unsigned 32-bit divide */         or    ((ms  =  #ms_divisors(i)) and (ls IGE #ls_divisors (i))));         ms = ms - #ms_divisors(i);         if ls ilt #ls_divisors(i) then ms = ms - 1;         ls = ls - #ls_divisors(i);         r = r + 1;      end;      if r <> 0 then go = true;      if (go) or (i = 9) then pc(a.0 + r); /* print digit */      else if field - (9 - i) > 0 then pc(a.sp); /* or print space */   end; /* of digits loop */end #pn;dcl pn lit 'call #pn';PrintNum: proc(Num); /* print a number less than 100 */   dcl Num fixed; /* number to print */   pc(a.0 + (Num / 10));   pc(a.0 + (Num mod 10));end PrintNum;#pt: proc(MS_Secs,LS_Secs,FieldWidth,ShowSeconds,AMPM); /* print time elapsed */   dcl (MS_Secs,LS_Secs) fixed; /* no. seconds elapsed */   dcl FieldWidth        fixed; /* display field width */   dcl ShowSeconds       boolean; /* TRUE to show seconds */   dcl AMPM              boolean; /* TRUE to show AM/PM, FALSE to show 24 hour time */   dcl (hours,minutes,seconds) fixed;   dcl i                 fixed;   write("5") = LS_Secs; /* load total seconds */   write("4") = MS_Secs;   write("7") = 60;   seconds = read("4"); /* no. seconds */   write("5") = read("5");   write("7") = 60;   minutes = read("4"); /* no. minutes */   write("5") = read("5");   write("7") = 60;   hours = read("4"); /* no. hours */   write("5") = read("5");   FieldWidth = FieldWidth - (1 + 2 + (ShowSeconds * 3) + (AMPM * 3)); /* subtract colon, minutes and maybe seconds field */   if FieldWidth < 0 then FieldWidth = 0;   i = hours;   if AMPM then do; /* deal with AM/PM stuff */      if hours = 0 then i = 12;      else if hours ige 13 then i = hours - 12;   end;   pn(0,i,FieldWidth); /* print hours */   pc(a.colon);   call PrintNum(minutes); /* print minutes */   if ShowSeconds then do; /* print seconds */      pc(a.colon);      call PrintNum(seconds);   end;   if AMPM then do; /* deal with AM/PM stuff */      if hours ilt 12 then ps(' AM'); else ps(' PM');   end;end #pt;dcl pt lit 'call #pt';#pd: proc(Date,FieldWidth); /* print date */   dcl Date       fixed; /* date to print */   dcl FieldWidth fixed; /* display field width */   dcl (i,j)  fixed;   dcl Months data ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'); /* month names */   if Date = 0 then return;   do i = 1 to FieldWidth - 9; /* print any leading spaces */      wchar(a.SP);   end;   call PrintNum(Date and "H1F"); /* print day */   pc(a.minus);   j = ((shr(Date,5) and "HF") - 1)*3; /* get index into month name array */   do i = 0 to 2;      pc(byte(Months,j + i)); /* print character */   end;   pc(a.minus);   call PrintNum(shr(Date,9)); /* print year */end #pd;dcl pd lit 'call #pd';PrintTime: proc(MS_Secs,LS_Secs,FieldWidth) returns (fixed); /* print time of day */   dcl (MS_Secs,LS_Secs) fixed; /* no. seconds */   dcl FieldWidth        fixed; /* display field width */   dcl days              fixed; /* no. days gone by */   days = 0;   do while (MS_Secs igt "H1") or ((MS_Secs = "H1") and (LS_Secs ige "H5180")); /* see how many days have gone by */      MS_Secs = MS_Secs - "H1"; /* subract the no. seconds in a day */      if LS_Secs ilt "H5180" then MS_Secs = MS_Secs - 1;      LS_Secs = LS_Secs - "H5180";      days = days + 1; /* count the no. days */   end;   pt(MS_Secs,LS_Secs,FieldWidth,true,true); /* print time of day */   return (days); /* return the no. days gone by */end PrintTime;PrintDate: proc(MS_Secs,LS_Secs,FieldWidth) returns (fixed); /* print the date */   dcl (MS_Secs,LS_Secs) fixed; /* no. seconds */   dcl FieldWidth        fixed; /* display field width */   dcl days              fixed; /* no. days gone by */   dcl (day,month,year)  fixed;   dcl MonthLen          data (31,28,31,30,31,30,31,31,30,31,30,31); /* no. days in each month */   days = 0;   do while (MS_Secs igt "H1") or ((MS_Secs = "H1") and (LS_Secs ige "H5180")); /* see how many days have gone by */      MS_Secs = MS_Secs - "H1"; /* subract the no. seconds in a day */      if LS_Secs ilt "H5180" then MS_Secs = MS_Secs - 1;      LS_Secs = LS_Secs - "H5180";      days = days + 1; /* count the no. days */   end;   year = shr(StartDate,9); /* get current date into variables */   month = (shr(StartDate,5) and "HF");   day = (StartDate and "H1F");   day = day + days; /* add the no. days that have passed */   do while day igt MonthLen(month - 1); /* find day, month and year */      day = day - MonthLen(month - 1);      month = month + 1;      if month = 13 then do; /* go to new year */         year = year + 1;         month = 1;      end;   end;   pd(shl(year,9) or shl(month,5) or day,FieldWidth); /* put date back together again and print it */   return (days); /* return the no. days gone by */end PrintDate;RestoreCursor: proc; /* restore cursor to current drive address */   pos(FirstRow + 2 + 6 - CurrentTarget + shr(CurrentD24,1) * (TableHeight + 1),FirstCol + TableWidth - 2 + (CurrentD24 and "1") * (TableWidth + 4));end RestoreCursor;GetStringField: proc(Source,Field,Index,Terminator) returns (fixed); /* get field from string */   dcl Source     fixed array; /* source string */   dcl Field      fixed array; /* field string */   dcl Index      fixed; /* starting index in source string */   dcl Terminator fixed; /* terminating character */   dcl ch         fixed;   Field(0) = 0; /* nothing in field string */   ch = -1; /* get into loop */   do while (Index < Source(0)) and (ch <> Terminator); /* loop over source characters until terminating character is found */      ch = byte(Source,Index); /* get character from source */      if ch <> Terminator then do; /* not the terminating character */         call pbyte(Field,Field(0),ch); /* add character to field string */         Field(0) = Field(0) + 1; /* adjust length */         Index = Index + 1; /* go to next source character */      end;   end;   return (Index); /* return character of next */end GetStringField;GetStringNumber: proc(Source) returns (fixed); /* get number from string */   dcl Source   fixed array; /* source array */   dcl Number   fixed; /* number to return */   dcl (i,j,ch) fixed;   Number = 0;   do i = 0 to Source(0) - 1; /* loop over characters */      ch = byte(Source,i); /* get character */      if (ch >= a.0) and (ch <= a.9) then do; /* got a digit */         j = Number;         Number = Number*10 + (ch - a.0); /* add to number */         if Number ilt j then return (-1); /* overflow */      end;      else return (-1); /* bad numeric character */   end;   return (Number); /* return number */end GetStringNumber;CONV.STR.TO.TIME: proc(TimeStr) returns (fixed); /* convert time string to encoded time format */   dcl TimeStr      fixed array; /* string to convert */   dcl FieldStr(10) fixed; /* field parsed out of time string */   dcl (hours,minutes,seconds,PM) fixed; /* time parameters */   dcl i            fixed;   i = 0;   do while (i < TimeStr(0)) and (byte(TimeStr,i) = a.SP); /* get rid of leading spaces */      i = i + 1;   end;   i = GetStringField(TimeStr,FieldStr,i,a.colon); /* get hours field */   if FieldStr(0) = 0 then return (0); /* no hours entered */   hours = GetStringNumber(FieldStr); /* convert to number */   if (hours igt 23) then return (0); /* bad number entered */   i = GetStringField(TimeStr,FieldStr,i + 1,a.SP); /* get minutes field */   if FieldStr(0) = 0 then return (0); /* no minutes entered */   minutes = GetStringNumber(FieldStr); /* convert to number */   if (minutes igt 59) then return (0); /* bad number entered */   seconds = 0; /* user cannot enter seconds */   i = GetStringField(TimeStr,FieldStr,i + 1,a.SP); /* get AM/PM field */   if FieldStr(0) = 0 then do; /* nothing in this field, so assume military time */      if hours ilt 12 then do; /* this is AM */         if hours = 0 then hours = 12; /* zero is midnight */         PM = 0; /* set to AM */      end;      else do; /* this is PM */         hours = hours - 12; /* adjust */         if hours = 0 then hours = 12; /* zero is noon */         PM = 1; /* set to PM */      end;   end;   else do; /* got something to process */      if FieldStr(0) <> 2 then return (0); /* wrong size */      i = shr(FieldStr(1),8); /* get second character */      if (i <> a.M) and (i <> l.m) then return (0); /* not an "M" */      i = (FieldStr(1) and "HFF"); /* get first character */      if      (i = a.A) or (i = l.a) then PM = 0; /* AM */      else if (i = a.P) or (i = l.p) then PM = 1; /* PM */      else return (0); /* something random */      if (hours = 0) or (hours igt 12) then return (0); /* trying to use military time with AM/PM modifier */   end;      i = ( shl(PM,15) or shl(hours,11) or shl(minutes,5) or shr(seconds,1) ); /* construct encoded time */   return (i); /* return encoded time */end CONV.STR.TO.TIME;CONV.STR.TO.DATE: proc(DateStr) returns (fixed); /* convert date string to encoded date format */   dcl DateStr      fixed array; /* string to convert */   dcl FieldStr(10) fixed; /* field parsed out of date string */   dcl (day,month,year) fixed; /* date parameters */   dcl i            fixed;   FindMonth: proc(Str) returns (boolean);      dcl Str    fixed array;      dcl Months data ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'); /* month names */      dcl (i,j)  fixed;      do i = 0 to 2;         if (byte(Str,i) >= l.a) and (byte(Str,i) <= l.z) /* lowercase */         then call pbyte(Str,i,byte(Str,i) - "40"); /* make uppercase */      end;      j = 0;      do i = 0 to 11;         if  (byte(Str,0) = byte(Months,j))         and (byte(Str,1) = byte(Months,j + 1))         and (byte(Str,2) = byte(Months,j + 2)) /* all three characters match */         then return (i + 1); /* return month found */         j = j + 3; /* go to next month */      end;      return (0); /* month not found */   end FindMonth;   i = 0;   do while (i < DateStr(0)) and (byte(DateStr,i) = a.SP); /* get rid of leading spaces */      i = i + 1;   end;   i = GetStringField(DateStr,FieldStr,i,a.SP); /* get day field */   if FieldStr(0) = 0 then return (0); /* no day entered */   day = GetStringNumber(FieldStr); /* convert to number */   if (day = 0) or (day igt 31) then return (0); /* bad number entered */   i = GetStringField(DateStr,FieldStr,i + 1,a.SP); /* get month field */   if FieldStr(0) ilt 3 then return (0); /* no month entered */   month = FindMonth(FieldStr); /* find month */   if (month = 0) or (month igt 12) then return (0); /* bad month entered */   i = GetStringField(DateStr,FieldStr,i + 1,a.SP); /* get year field */   if FieldStr(0) = 0 then return (0); /* no year entered */   year = GetStringNumber(FieldStr); /* convert to number */   if (year ige 1900) and (year ile 2027) /* convert to proper year format */   then year = year - 1900;   if (year igt 127) then return (0); /* bad year entered */   i = ( shl(year,9) or shl(month,5) or day ); /* construct encoded date */   return (i); /* return encoded date */end CONV.STR.TO.DATE;AddErrorRecord: proc(DriveHdl,TestOffset,RecLen) returns (pointer); /* make room for a subrecord in the error record */   dcl DriveHdl   handle; /* handle to drive record */   dcl TestOffset fixed; /* offset of test subrecord where error occurred */   dcl RecLen     fixed; /* size of subrecord to add */   dcl ErrHdl     handle; /* handle to error record */   dcl OldLen     fixed; /* old length of error record */   dcl p          pointer;   ErrHdl = core(core(DriveHdl) + d$ErrorHandle); /* get handle to error record */   if ErrHdl = Null then return (Null);   OldLen = Handle_Size(ErrHdl); /* store current length of error record */   ErrHdl = Expand_Handle(ErrHdl,RecLen); /* make room for new error data */   if ErrHdl = Null then return (Null); /* no more room */   /* Now connect this error to the linked list of errors for this test */   p = (GetTestPtr(DriveHdl) + TestOffset) + t$FirstError; /* get pointer to first error link */   do while core(p) <> 0; /* loop until end of list reached */      p = core(ErrHdl) + core(p) + e$NextError; /* get pointer to next error link */   end;   core(p) = OldLen; /* store offset of error from beginning of handle */   return (core(ErrHdl) + OldLen); /* return pointer to new subrecord */end AddErrorRecord;UpdateErrorRecord: proc(p,ErrorType,ErrorMsg,Iteration); /* update standard error record contents */   dcl p         pointer; /* pointer to error record */   dcl ErrorType fixed; /* type of error which occurred */   dcl ErrorMsg  fixed array; /* text of error which occurred */   dcl Iteration fixed; /* test iteration where error occurred */   dcl i         fixed;   core(p + e$ErrorType) = ErrorType; /* store type of error that occurred */   core(p + e$NextError) = 0; /* there is no error after this one */   core(p + e$Iteration) = Iteration; /* test iteration */   core(p + e$MS_ErrorTime) = MS_Seconds; /* store time error occurred */   core(p + e$LS_ErrorTime) = LS_Seconds;   do i = 0 to shr(ErrorMsg(0) + 1,1); /* copy over error message */      core(p + e$ErrorMsg + i) = ErrorMsg(i);   end;end UpdateErrorRecord;/* SCSI Routines */REQPresent: proc(D24) returns (boolean); /* see if REQ present on this D24 */   dcl D24 fixed; /* D24 to look at */   dcl i   fixed;   dcl Bit data (1, 2, 4, 8); /* Binary to Bit mapping */   if (read("51") and ScsiBoard) = 0   then return (false); /* no D24 board in computer at all */   i = shl(Bit(D24), 8);   write(ScsiSel) = (S$SelectEnable or i); /* enable the D24 */   if (read(ScsiSel) and S$SelMask) <> i /* board not there */   then return(false); /* die */   write(ScsiData) = 0; /* clear data bus */   return ( (read(ScsiBus) and S$REQ) <> 0 ); /* return TRUE if REQ present */end REQPresent;SendByte: proc(b) returns (fixed); /* send byte with software handshake */   dcl b fixed; /* byte to send */   dcl t fixed;   t = LS_Seconds + 4; /* wait 4 seconds max */   do while (LS_Seconds <> t) and ((read(ScsiBus) and S$REQ) = 0); end; /* wait for REQ */   if LS_Seconds = t then return (S$SelFailed); /* timed out */   write(ScsiData) = b; /* put byte on bus */   write(ScsiBus) = S$ACK; /* assert ACK */   t = LS_Seconds + 4; /* wait 4 seconds max */   do while (LS_Seconds <> t) and ((read(ScsiBus) and S$REQ) <> 0); end; /* wait for REQ to go away */   write(ScsiData) = 0; /* clear bus */   write(ScsiBus) = 0; /* remove ACK */   if LS_Seconds = t then return (S$SelFailed); /* timed out */   return (S$GoodConnect); /* byte was sent */end SendByte;ReceiveByte: proc returns (fixed); /* receive byte with software handshake */   dcl b fixed; /* byte to return */   dcl t fixed;   t = LS_Seconds + 4; /* wait 4 seconds max */   do while (LS_Seconds <> t) and ((read(ScsiBus) and S$REQ) = 0); end; /* wait for REQ */   if LS_Seconds = t then return (S$SelFailed); /* timed out */   b = (read(ScsiData) and S$DataMask); /* get byte from bus */   write(ScsiBus) = S$ACK; /* assert ACK */   t = LS_Seconds + 4; /* wait 4 seconds max */   do while (LS_Seconds <> t) and ((read(ScsiBus) and S$REQ) <> 0); end; /* wait for REQ to go away */   write(ScsiBus) = 0; /* remove ACK */   if LS_Seconds = t then return (S$SelFailed); /* timed out */   return (b); /* return byte */end ReceiveByte;DoCommand: proc(DevAdr,CBuf,DBuf) returns (fixed); /* do the SCSI command in CBUF */   dcl DevAdr fixed; /* SCSI device address */   dcl CBuf   fixed array; /* buffer with SCSI command to perform */   dcl DBuf   fixed array; /* data buffer */   dcl Bus    fixed; /* SCSI bus signals */   dcl done   boolean; /* TRUE if status phase found */   dcl Stat   fixed;   dcl i      fixed;   Stat = BusConnect(DevAdr); /* connect to SCSI bus */   if Stat <> S$GoodConnect then return (Stat); /* bad connection status */   done = false; /* not done yet */   do while not done; /* Repeat until command is over */      i = LS_Seconds + 10; /* wait 10 seconds max */      do while (LS_Seconds <> i) and ((read(ScsiBus) and S$REQ) = 0); end; /* Wait for REQ asserted */      if LS_Seconds = i then return (S$SelFailed); /* timed out */      Bus = (read(ScsiBus) and S$SigMask); /* See what is on the bus */      if Bus = S$Command then do; /* Command Phase */         do i = 0 to Cbuf(0) - 1; /* use software handshake so power-off time out doesn't crash everything */            if SendByte(byte(Cbuf,i)) <> S$GoodConnect            then return (S$SelFailed);         end;      end;      else if Bus = S$DataOut then do; /* Data Out Phase */         i = SendData(DBuf,S$DataOut); /* send the data */      end;      else if Bus = S$DataIn then do; /* Data In Phase */         DBuf(0) = ReceiveData(DBuf,S$DataIn); /* get the data */      end;      else if Bus = S$MessIn then do; /* Message In Phase */         i = read(ScsiByte); /* throw away any messages */      end;      else if Bus = S$Status then do; /* Status Phase */         Stat = shr(read(ScsiWord),8); /* Get status byte */         done = true;      end;      else do; /* Illegal phase */         Stat = S$BadBusState;         done = true;      end;   end; /* while not done */   return (Stat);end DoCommand;need different argument passing due to d24 #1 LUN handling...GetStatus: proc(D24,Target) returns (fixed); /* get status for this device */   dcl D24    fixed; /* D24 to get status from */   dcl Target fixed; /* Target to get status from */   dcl Stat   fixed; /* status to return */   Stat = shr(read(ScsiWord),8); /* get status byte */   if Stat = S$CheckCondition then do; /* do a request sense */      call RequestSense(CmdBuf,LUN,32); /* get a lot of sense information */      Stat = DoCommand(shl(LUN,8) or shl(D24,4) or Target,CmdBuf,SenseBuf);      if Stat = S$Good then Stat = byte(SenseBuf,2); /* return sense key */   end;   return (Stat);end GetStatus;SendCommand: proc(D24,Target,ReturnStatus) returns (fixed); /* send SCSI command to drive */   dcl D24          fixed; /* D24 to send command to */   dcl Target       fixed; /* Target to send command to */   dcl ReturnStatus boolean; /* TRUE to wait for status, FALSE to just send command */   dcl DevAdr       fixed; /* SCSI device address */   dcl Sense        fixed;   dcl i            fixed;   DevAdr = (shl(LUN,8) or shl(D24,4) or Target); /* construct SCSI device address */   if ReturnStatus then do; /* send command and wait for status */      Sense = DoCommand(DevAdr,CmdBuf,DataBuf); /* send command and get status */      if Sense = S$CheckCondition then do; /* something happened */         call RequestSense(CmdBuf,LUN,32); /* get a lot of sense information */         Sense = DoCommand(DevAdr,CmdBuf,SenseBuf);        if Sense = S$Good then Sense = byte(SenseBuf,2); /* return sense key */      end;   end;   else do; /* just send command */      Sense = BusConnect(DevAdr); /* connect to SCSI bus */      if Sense = S$GoodConnect then do;         do i = 0 to CmdBuf(0) - 1; /* send command bytes */            write(ScsiByte) = byte(CmdBuf,i);         end;      end;   end;   return (Sense);end SendCommand;AppendStr: proc(Source,Addition); /* append string to source */   dcl Source   fixed array; /* source string */   dcl Addition fixed array; /* string to append to source */   dcl i        fixed;   do i = 0 to Addition(0) - 1;      call pbyte(Source,Source(0) + i,byte(Addition,i));   end;   Source(0) = Source(0) + Addition(0);end AppendStr;dcl Digits data ('0123456789ABCDEF'); /* digits */AppendHex: proc(Source,Number); /* append hex digit to source */   dcl Source   fixed array; /* source string */   dcl Number   fixed; /* number to append */   dcl i        fixed;   do i = 3 to 0 by -1;      call pbyte(Source,Source(0) + i,byte(Digits,Number and "HF"));      Number = shr(Number,4);   end;   Source(0) = Source(0) + 4;end AppendHex;AppendNum: proc(Source,Number); /* append signed number to source */   dcl Source   fixed array; /* source string */   dcl Number   fixed; /* number to append */   dcl i        fixed;   if Number < 0   then call pbyte(Source,Source(0),a.minus); /* insert minus sign */   else call pbyte(Source,Source(0),a.SP); /* just leave a space */   Number = abs(Number);   do i = 5 to 1 by -1;      call pbyte(Source,Source(0) + i,byte(Digits,Number mod 10));      Number = Number / 10;   end;   Source(0) = Source(0) + 6;end AppendNum;Close_File: proc(F) returns (file); /* close file */   dcl F file; /* file to close */   dcl (i,j,k) fixed;   i = c#status; /* store statuses */   j = file_error;   k = s$sensekey;   call FClose(F); /* close file */   c#status = i; /* restore statuses */   file_error = j;   s$sensekey = k;   return (NullF); /* file is closed */end Close_File;Open_File: proc(Name,Access,BufPtr,BufMed,BufLen) returns (file); /* open disk file */   dcl Name   fixed array; /* treename of file to open */   dcl Access fixed array; /* access type */   dcl BufPtr fixed; /* pointer to file buffer */   dcl BufMed fixed; /* medium of file buffer */   dcl BufLen fixed; /* size of file buffer */   dcl F      file;  /* file variable returned by FOPEN */   F = FOpen(Name,Access); /* try to open file with given access */   if F <> NullF then do; /* opened successfully */      if SetBuf(F,BufPtr,BufMed,BufLen) <> EOF_Mark then do; /* buffer paremeters setup ok */         return (F); /* return file pointer */      end;   end;   if F <> NullF then F = Close_File(F); /* close up file variable if it was opened */   return (NullF); /* file not opened */end Open_File;OpenLogFile: proc(PathName,TreeName) returns (boolean); /* open log file */   dcl PathName fixed array; /* pathname of log file */   dcl TreeName fixed array; /* treename of log file */   call Cache_Treename(true); /* start treename caching */   CatCache = Cache(C#BufPtr,C#BufMed); /* cache catalog buffer into itself */   if (Read_Catalog(PathName,1)) and (FindMax) then do; /* read index subcat and find largest block */      if (F#LS_Length and "HFF") = 0  then do; /* sector length is a multiple of 256 */         if F#LS_Length = 0 then F#MS_Length = F#MS_Length - 1;         F#LS_Length = F#LS_Length - 1; /* subtract one so FILEIO doesn't barf on this file */      end;      if Replace(TreeName,t#text,F#MS_Length,F#LS_Length,0,1) then do; /* room for this file */         OutFile = Open_File(TreeName,'w',OutBufPtr,OutBufMed,OutBufLen); /* try to open this file for output */         if OutFile <> NullF then do; /* file opened successfully */            Line(0) = 0; /* initialize file variables */            LineNum = 1;            return (TRUE); /* output file is ready to go */         end;      end;   end;   call Cache_Treename(false); /* stop treename caching */   call Disable_Cache(CatCache); /* disable caching */   return (FALSE); /* output file not ready to go */end OpenLogFile;CloseLogFile: proc(TreeName) returns (boolean); /* close log file */   dcl TreeName fixed array; /* treename of index file */   dcl Closed   boolean; /* TRUE if file was closed successfully */   dcl WordLen  fixed; /* length of file in words */   WordLen = shr(Seek(OutFile,0,1) + 1,1); /* turn current byte position into words */   Closed = false; /* assume close will fail */   OutFile = Close_File(OutFile); /* close output file */   if truncate(TreeName,0,shr(WordLen + 255,8),WordLen,1) then do; /* truncate log file to proper size */      Closed = true; /* close was successful */   end;   call Cache_Treename(false); /* stop treename caching */   call Disable_Cache(CatCache); /* disable caching */   return (Closed); /* return status of close */end CloseLogFile;GetBufferString: proc(Buf,BufIndex,Len,Str); /* get string from buffer */   dcl Buf      fixed array; /* buffer to use */   dcl BufIndex fixed; /* starting index of name in buffer */   dcl Len      fixed; /* length of string in bytes */   dcl Str      fixed array; /* array space to return string in */   dcl EndIndex fixed; /* last index to check */   EndIndex = BufIndex + Len; /* calculate last index */   do while (EndIndex > BufIndex)   and ((byte(Buf,EndIndex - 1) = a.SP) or (byte(Buf,EndIndex - 1) = 0)); /* skip over trailing spaces */      EndIndex = EndIndex - 1;   end;   do while (BufIndex < EndIndex)    and ((byte(Buf,BufIndex) = a.SP) or (byte(Buf,BufIndex) = 0)); /* skip over leading spaces */      BufIndex = BufIndex + 1;   end;   Str(0) = 0; /* nothing in string yet */   do while BufIndex < EndIndex; /* loop over valid characters */      call pbyte(Str,Str(0),byte(Buf,BufIndex)); /* put character in string */      Str(0) = Str(0) + 1; /* add to string length */      BufIndex = BufIndex + 1; /* go to next character in buffer */   end;end GetBufferString;InitDriveRec: proc(D24,Target); /* initialize drive record for this device */   dcl D24      fixed; /* D24 board */   dcl Target   fixed; /* SCSI target */   dcl DriveHdl handle;   dcl p        pointer;   dcl i        fixed;   DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */   if DriveHdl = Null then return;   p = core(DriveHdl); /* get pointer to drive record */   if core(p + d$InfoHandle) <> Null   then call Free_Handle(core(p + d$InfoHandle)); /* dispose of old information record */   if core(p + d$TestHandle) <> Null   then call Free_Handle(core(p + d$TestHandle)); /* dispose of old test record */   if core(p + d$ErrorHandle) <> Null   then call Free_Handle(core(p + d$ErrorHandle)); /* dispose of old error record */   do i = 0 to d#DriveRecLen - 1; /* clear out drive record */      core(p + i) = 0;   end;end InitDriveRec;/* Drive Processing */insert ':oputil:optest:diskproc'; /* winchester disk processing */insert ':oputil:optest:optprint';  /* optical disk printing */insert ':oputil:optest:optproc';  /* optical disk processing *//* Output Routines */PrintWindow: proc(row,col,width,height,title);   dcl (row,col)         fixed; /* cursor position of upper left corner */   dcl (width,height)    fixed; /* size of window */   dcl title             fixed array; /* title string */   dcl (ltc,rtc,lbc,rbc) fixed; /* corners */   dcl (hbar,vbar)       fixed; /* bars */   dcl (i,top)           fixed;   if terminal.type = t#VT100 then do; /* box definiton for VT100 terminals */      ltc = l.l; rtc = l.k; lbc = l.m; rbc = l.j;      hbar = l.q; vbar = l.x;      pos(0,0);      wchar(a.ESC); pstring('(0'); /* turn on special graphics mode */   end;   else do; /* box definition for everything else */      ltc = a.period; rtc = a.period; lbc = a.grave; rbc = a.apost;      hbar = a.minus; vbar = a.bar;   end;   top = row; /* store top row */   pos(row,col); /* upper divider */   wchar(ltc);   do i = 1 to width - 2;      wchar(hbar);   end;   wchar(rtc);   row = row + 1; /* sides of window */   do i = 1 to height - 2;      pos(row,col);      wchar(vbar);      pos(row,col + width - 1);      wchar(vbar);      row = row + 1;   end;   pos(row,col); /* lower divider */   wchar(lbc);   do i = 1 to width - 2;      wchar(hbar);   end;   wchar(rbc);   if terminal.type = t#VT100 then do;      pos(0,0);      wchar(a.ESC); pstring('(B'); /* turn off special graphics mode */   end;   pos(top,col + ((width - (title(0) + 2)) / 2)); /* print title */   wchar(a.SP); pstring(Title); wchar(a.SP);end PrintWindow;PrintDriveDisplay: proc(D24,Target); /* update display for this drive */   dcl D24       fixed;   dcl Target    fixed;   dcl DriveHdl  handle;   dcl p         pointer;   dcl (msw,lsw) fixed;   dcl i         fixed;   pos(FirstRow + 2 + 6 - Target + shr(D24,1) * (TableHeight + 1),FirstCol + 2 + (D24 and "1") * (TableWidth + 4));   if (D24 = CurrentD24) and (Target = CurrentTarget) then do; /* hilight this drive */      if terminal.type = t#vt100 then do; /* turn on reverse video on VT100 types */         reverse(true);         wchar(a.SP);      end;      else wchar(a.greater); /* some other terminal */   end;   else wchar(a.SP);   unum(Target,1); /* target number */   DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */   if DriveHdl = Null then do; /* no drive here */      do i = 1 to TableWidth - 7; /* write blanks */         wchar(a.SP);      end;   end;   else do; /* found a drive */      pstring('  ');      p = core(DriveHdl); /* get pointer to drive record */      i = core(p + d$DevType); /* get device type */      if i = S$DirectAccess /* disk drive */      then call PrintWinchesterState(core(p + d$State)); /* state */      else if i = S$WriteOnce /* optical disk */      then call PrintOpticalState(core(p + d$State)); /* state */      msw = MS_Seconds - core(p + d$MS_FirstTime); /* calculate how long drive has been tested */      if LS_Seconds ilt core(p + d$LS_FirstTime) then msw = msw - 1;      lsw = LS_Seconds - core(p + d$LS_FirstTime);      pt(msw,lsw,6,false,false); /* time */      pn(core(p + d$MS_Errors),core(p + d$LS_Errors),7); /* errors */   end;   if (D24 = CurrentD24) and (Target = CurrentTarget) then do; /* unhilight this drive */      if terminal.type = t#vt100 then do; /* turn off reverse video on VT100 types */         wchar(a.SP);         reverse(false);      end;      else wchar(a.less); /* some other terminal */   end;   else wchar(a.SP);end PrintDriveDisplay;UpdateTime: proc;   dcl days fixed; /* no. days gone by */   pos(TimeRow,TimeCol);   days = PrintTime(MS_Seconds,LS_Seconds,11); /* print new time */   MS_NextTime = MS_Seconds; /* next time update */   LS_NextTime = LS_Seconds + TimeUpdateDelay;   if LS_NextTime ilt TimeUpdateDelay then MS_NextTime = MS_NextTime + 1;   if days igt DayCounter then do; /* another day has gone by */      pos(DateRow,DateCol);      call PrintDate(MS_Seconds,LS_Seconds,9); /* print new date */      DayCounter = days;   end;   call RestoreCursor; /* restore cursor to current position */end UpdateTime;GetDate: proc(Msg,Str) returns (fixed); /* get a date from user */   dcl Msg fixed array; /* message to display */   dcl Str fixed array; /* buffer space to use */   dcl d   fixed;   d = 0;   do while d = 0;      get_string(Msg,true,Str,12); crlf;      d = Conv.Str.To.Date(Str); /* convert to date format */      if d = 0 then pstringr('Please enter the date in this format: 10 FEB 88');   end;   return (d); /* return date */end GetDate;GetTime: proc(Msg,Str) returns (fixed); /* get a time from user */   dcl Msg fixed array; /* message to display */   dcl Str fixed array; /* buffer space to use */   dcl t   fixed;   t = 0;   do while t = 0;      get_string(Msg,true,Str,12); crlf;      t = Conv.Str.To.Time(Str); /* convert to date format */      if t = 0 then pstringr('Please enter the time in this format: 10:32 AM');   end;   return (t); /* return time */end GetTime;ConvertTime: proc(t); /* convert time to seconds */   dcl t     fixed; /* time to convert */   dcl hours fixed;   hours = (shr(t,11) and "HF"); /* hours */   if t < 0 then do; /* PM bit is set */      if hours ilt 12 then hours = hours + 12;   end;   else do; /* AM */      if hours = 12 then hours = 0;   end;   write("5") = hours;   write("6") = 3600; /* get total seconds in these hours */   LS_Seconds = read("5"); /* store total seconds */   MS_Seconds = read("4");   write("5") = (shr(t,5) and "H3F"); /* minutes */   write("6") = 60; /* get total seconds in these minutes */   LS_Seconds = LS_Seconds + read("5"); /* add to count */   MS_Seconds = MS_Seconds + read("4");   if LS_Seconds ilt read("5") then MS_Seconds = MS_Seconds + 1;   LS_Seconds = LS_Seconds + (shl(t and "H1F",1)); /* add seconds to count */   if LS_Seconds ilt (shl(t and "H1F",1)) then MS_Seconds = MS_Seconds + 1;end ConvertTime;StopProcessing: proc; /* stop processing on all devices */   dcl DriveHdl handle;   dcl (i,j)    fixed;   do i = 0 to D24Max - 1; /* loop over all drives */      do j = 0 to TargetMax - 1;         DriveHdl = GetDriveHandle(i,j); /* get handle to drive record */         if DriveHdl <> Null /* there is a drive here */         then core(core(DriveHdl) + d$Process) = StopProcess; /* stop all processing on this drive */      end;   end;   MS_NextOffline = -1; /* don't do this again */   LS_NextOffline = -1;end StopProcessing;PrintScreen: proc;   dcl (D24,Target) fixed;   dcl (i,row,col)  fixed;   dcl Title(3)     fixed;   dcl D24Label     data ('D24 #0');   clear_screen;   pos(NameRow,NameCol); pstring('Optical Disk Test - '); pstring(ReleaseDate);   pos(DateRow,DateCol);   call PrintDate(MS_Seconds,LS_Seconds,9); /* print new date */   call UpdateTime;   do i = 0 to shr(D24Label(0) + 1,1); /* copy over D24 label */      Title(i) = D24Label(i);   end;   do D24 = 0 to D24Max - 1;      row = FirstRow + shr(D24,1)*(TableHeight + 1);      col = FirstCol + (D24 and "1")*(TableWidth + 4);      call pbyte(Title,Title(0) - 1,a.0 + D24); /* put D24 number in */      call PrintWindow(row,col,TableWidth,TableHeight,Title); /* print window frame */      row = row + 1; /* column bar */      pos(row,col + 6);      pstring('Test              Time Errors');      do Target = TargetMax - 1 to 0 by -1;         call PrintDriveDisplay(D24,Target);      end;   end;   call RestoreCursor; /* restore cursor to current address */end PrintScreen;HandleCharacterEvent: proc; /* deal with keypress */   dcl ch       fixed;   dcl DriveHdl handle;   dcl p        pointer;   dcl (OldD24,OldTarget) fixed;   ch = rchar; /* get character */   OldD24 = CurrentD24; OldTarget = CurrentTarget;   if ((ch = cur.left) or (ch = a.bs)) then do; /* cursor left */      if (CurrentD24 and "1") = 0      then CurrentD24 = CurrentD24 + 1; /* wrap around */      else CurrentD24 = CurrentD24 - 1; /* goto next */   end;   else if ((ch = cur.right) or (ch = a.ff)) then do; /* cursor right */      if (CurrentD24 and "1") <> 0      then CurrentD24 = CurrentD24 - 1; /* wrap around */      else CurrentD24 = CurrentD24 + 1; /* goto next */   end;   else if ((ch = cur.up) or (ch = a.vt)) then do; /* cursor up */      if CurrentTarget = (TargetMax - 1) then do; /* need to change D24 */         if CurrentD24 > 1          then CurrentD24 = CurrentD24 - 2;         else CurrentD24 = CurrentD24 + 2;      end;      CurrentTarget = (CurrentTarget + 1) mod TargetMax; /* wrap around */   end;   else if ((ch = cur.down) or (ch = a.lf)) then do; /* cursor down */      if CurrentTarget = 0 then do; /* need to change D24 */         if CurrentD24 > 1          then CurrentD24 = CurrentD24 - 2;         else CurrentD24 = CurrentD24 + 2;      end;      CurrentTarget = (CurrentTarget - 1) mod TargetMax; /* wrap around */   end;   else if ((ch = cur.home) or (ch = c.r) or (ch = c.y) or (ch = a.rs) or (ch = pf.1)) then do; /* home */      CurrentD24 = 0;      CurrentTarget = TargetMax - 1;   end;   else if (ch = a.CR) then do; /* display log */      DriveHdl = GetDriveHandle(CurrentD24,CurrentTarget); /* get handle to drive record */      if DriveHdl = Null then do; /* no drive at this address */         pcmd('No drive found at this address');         call RestoreCursor; /* restore cursor to current address */      end;      else do; /* display menu for this drive */         p = core(DriveHdl); /* get pointer to drive record */         if core(p + d$DevType) = S$DirectAccess         then call WinchesterMenu; /* display menu for winchester */         else if core(p + d$DevType) = S$WriteOnce         then call OpticalMenu; /* display menu for optical disk */         call PrintScreen;      end;   end;   else if (ch = 0) then do; /* break key */      pcmd('');      SaveResults = Get_YN('Do you wish save test results to disk? [Y(es) or N(o)]? ');      call StopProcessing; /* stop processing on all devices */      Quitting = true; /* trying to quit */   end;   if (OldD24 <> CurrentD24) or (OldTarget <> CurrentTarget) then do;      call PrintDriveDisplay(OldD24,OldTarget); /* unhighlight old one */      call PrintDriveDisplay(CurrentD24,CurrentTarget); /* highlight new one */   end;end HandleCharacterEvent;/* Device Processing */ProcessDrives: proc;   dcl D24      fixed; /* D24 to process */   dcl Target   fixed; /* target to process */   dcl Sense    fixed; /* SCSI sense key */   dcl TimesUp  boolean; /* TRUE if it is time for the next command */   dcl DriveHdl handle; /* handle to drive record */   dcl delay    fixed; /* amount of time to wait until next command */   dcl p        pointer;   dcl index    fixed;   UpdateDisplay: proc;      if delay <> 0 then do;         call PrintDriveDisplay(D24,Target); /* update display */         call RestoreCursor; /* put cursor back at current address */      end;   end UpdateDisplay;   do D24 = 0 to D24Max - 1;      do Target = TargetMax - 1 to 0 by -1;         index = GetDeviceIndex(D24,Target); /* get index for this device */         if  (MS_Seconds igt dev(index + v$MS_NextTime))         or ((MS_Seconds  =  dev(index + v$MS_NextTime)) and (LS_Seconds ige dev(index + v$LS_NextTime))) /* time for next command */         then TimesUp = true; /* time for next command */         else TimesUp = false; /* wait some more */         if  ((PendingTarget(D24) = Target) or (PendingTarget(D24) = -1)) /* a command is pending for this target */         and (TimesUp) then do; /* the bus is free and it is time for the next command */            DriveHdl = GetDriveHandle(D24,Target); /* get handle to drive record */            if DriveHdl = Null then do; /* there is no device at this address */               call Inquiry(CmdBuf,LUN,4); /* get first 4 inquiry bytes */               Sense = SendCommand(D24,Target,true);               if Sense = S$Good then do; /* got the inquiry bytes */                  if byte(DataBuf,0) = S$DirectAccess then do; /* found a disk drive */                     delay = ProcessWinchester(D24,Target); /* process it */                     call UpdateDisplay; /* update the display */                  end;                  else if byte(DataBuf,0) = S$WriteOnce then do; /* found an optical disk */                     delay = ProcessOptical(D24,Target); /* process it */                     call UpdateDisplay; /* update the display */                  end;                  else delay = 60; /* wait a while before the next poll */               end;               else delay = 60; /* wait a while before the next poll */            end;            else do; /* drive is currently processing something */               p = core(DriveHdl); /* get pointer to drive record */               if core(p + d$DevType) = S$DirectAccess then do; /* optical disk */                  delay = ProcessWinchester(D24,Target);                  call UpdateDisplay; /* update the display */               end;               else if core(p + d$DevType) = S$WriteOnce then do; /* optical disk */                  delay = ProcessOptical(D24,Target);                  call UpdateDisplay; /* update the display */               end;               else delay = 60;            end;            dev(index + v$MS_NextTime) = MS_Seconds; /* calculate next time to poll */            dev(index + v$LS_NextTime) = LS_Seconds + delay;            if dev(index + v$LS_NextTime) ilt delay then dev(index + v$MS_NextTime) = dev(index + v$MS_NextTime) + 1;         end; /* command pending or bus free */         if not term_idle then do; /* got a character */            call HandleCharacterEvent; /* see what needs to be done */         end;         if  (MS_Seconds igt MS_NextTime) /* time to update time */         or ((MS_Seconds  =  MS_NextTime) and (LS_Seconds ige LS_NextTime))         then call UpdateTime;         if  (MS_Seconds igt MS_NextOffline) /* time to go offline */         or ((MS_Seconds  =  MS_NextOffline) and (LS_Seconds ige LS_NextOffline))         then call StopProcessing;      end; /* looping over targets */   end; /* looping over D24s */end ProcessDrives;/* Main Program */dcl (i,j,k)   fixed;dcl DriveHdl  handle;enable;CurrentD24 = 0;CurrentTarget = 6;CmdLine = 23;OutputDev = TerminalDev;do i = 0 to D24Max - 1; /* no targets have pending commands */   PendingTarget(i) = -1;end;call Set_CatBuf(addr(CatBuf(0)),0);i = core(c#contab+c#vstart)+core(c#contab+c#vlngth)+core(c#contab+c#stklen); /* calc first word of free memory */call Create_Heap(i,loc.load - i,addr(HandleBuf(0)),HandleBufSize);DayCounter = 0; /* no days have gone by yet */clear_screen;pstringr ('');pstringr ('   --------------------------------------------');pstringr ('   --------------------------------------------');pstringr ('                    WARNING!                   ');pstringr ('   --------------------------------------------');pstringr ('   --------------------------------------------');pstringr ('');pstringr ('This program can quickly and easily destroy valuable optical media.');pstringr ('');pstringr ('DO NOT use this program unless specifically instructed to by');pstringr ('New England Digital Customer Service personnel.');pstringr ('');pstringr ('Make sure you call NED Customer Service if you have any questions about');pstringr ('using this program.');pstringr ('');if not Get_YN('Do you wish to continue [Y(es) or N(o)]? ')then do;   pstringr('');   call exit(-1); /* get out of here */end;else do; pstringr(''); pstringr(''); end; /* continue on with program */if Get_YN('Do you wish to enter timing informtion [Y(es) or N(o)]? ') then do;   crlf;   StartDate = GetDate('Enter current date: ',DataBuf); /* get starting date */   i = GetTime('Enter current time: ',DataBuf); /* get starting time */   j = GetTime('Enter time of next power off: ',DataBuf); /* find out when power will next go off */   pstring('Enter number of minutes power will remain on: '); k = getuns; crlf;   write("5") = k; /* get power-on interval in seconds */   write("6") = 60;   LS_Interval = read("5");   MS_Interval = read("4");   call ConvertTime(j); /* get next power-off time in seconds */   MS_NextOffline = MS_Seconds;   LS_NextOffline = LS_Seconds;   call ConvertTime(i); /* get time of day in seconds */end;else do;   crlf;   StartDate = (shl(88,9) or shl(6,5) or 20); /* starting date */   i = (shl(0,15) or shl(12,11) or shl(1,5) or 0);/* starting time */   call ConvertTime(i); /* get time of day in seconds */   MS_NextOffline = -1; /* next power-off time in seconds */   LS_NextOffline = -1;   LS_Interval = 0; /* length of power-off time */   MS_Interval = 0;end;call PrintScreen;seed = ClockTicks;Quit = false; Quitting = false;do while (not Quit); /* repeat until user wants to quit */   call ProcessDrives;   if Quitting then do; /* user wants to quit - see if anything is pending */      Quit = true; /* assume you will be able to quit */      do i = 0 to D24Max - 1;         if PendingTarget(i) <> -1 then Quit = false; /* cannot quit if something is pending */      end;   end;end;pos(0,0);clear_screen;if SaveResults then do; /* user wants to save log */   do i = 0 to D24Max - 1; /* loop over all drives */      do j = 0 to TargetMax - 1;         DriveHdl = GetDriveHandle(i,j); /* get handle to drive record */         if core(core(DriveHdl) + d$DevType) = S$WriteOnce /* optical disk */         then call SaveOpticalLog(i,j); /* save log to disk */      end;   end;end;flush_term;