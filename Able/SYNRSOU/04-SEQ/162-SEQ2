/* :SYNRSOU:04-SEQ:162-SEQ2  $TITLE  MORE SEQUENCER ROUTINES */

/*
Modified:
1999/11/10 - CJ  - Initialized pedal1 to full scale
1998/06/19 - TY  - Initialized monopolar RTE values in THD.RTES to (0\shl(rte.max,8)) instead of 0
						 in INIT.TRACK.HEAD.FOR.PLAY.  This repairs two bugs, one of which caused the
						 controllers to be recorded at record start even though their values were 0.
						 (The inverted upper byte was apparently overlooked.)
1991/04/26 - cj  - Got rid of sampled.time.of.prior.tempo...
1991/03/14 - KJC - Modified STOP.PLAY to clear EXT.REC.TRIGGER.STATE
1991/01/09 - PF  - click track/overall loop bug fixes
1991/01/04 - TSS - CLEAR DELAY.NOTE.AND.CUE.STARTS IN START.MOVING.FORWARD & START.MOVING.BACKWARDS
1990/11/06 - PF  - Support new sustain method
1990/10/10 - PF  - Begin using Sampled.Time.Of.Next/Prior.Tempo/Meter
						 to support VK panel map interface
1990/10/10 - PF  - Add Loop.Seq.Time.Of.Next.Click to support tempo map editing
1990/08/27 - PF  - Support all MIDI controllers
1990/07/10 - PF  - Replaced call to DISPLAY.BEAT.NUMBER with NEW.BEAT.NUMBER flag
1990/07/10 - PF  - Modified PLAY.INITIALIZE in support of meter map:
						 Init REAL.TIME.OF.NEXT.CLICK, ACTUALLY.EMIT.CLICK,
						 REAL.TIME.OF.NEXT.BEAT and compute LOOP.REAL.TIME.OF.NEXT.CLICK
1990/06/15 - CJ  - SET SAMPLED.MOVE IN START.MOVING.FORWARD, START.MOVING.BACKWARDS
1990/02/21 - MWH - Re-enable check for THD.MIDI.PATH in OK.TO.COPY.TIMBRE
1990/01/25 - MWH - Fix "300 msec delay starting cues" bug (from EditView)
1989/11/22 - MWH - Finished previous change for MIDInet
1989/11/14 - MWH - Disabled check for THD.MIDI.PATH in OK.TO.COPY.TIMBRE (for PAUL)
1989/10/11 - CJ  - fixed bug with loop.time.is.at.0 that gloms the Mark Start point
1989/10/10 - cj  - give event only to ABLE screens on indep loop change
1989/09/23 - CJ  - Mapped tempos in play.initialize
1989/07/17 - PF  - Add read and write of THD.MIDI.PATH in START.RECORD
1989/07/17 - PF  - Add check of THD.MIDI.PATH in OK.TO.COPY.TIMBRE
1989/07/28 - CJ  - Added comments in START.RECORD
1989/06/20 - MWH - Add "play to" time for the sequencer
1989/01/16 - MWH - Add Auto Punch feature
1988/12/09 - CJ  - FIXED BUG WITH TRIGGERING FIRST CUE OF SEQUENCE,
						 PLUS BUG WITH MARK START AND SEQUENCER TRIGGERING
1988/10/03 - CJ  - ADDED COMMENT TO STOP.MOVE.  CORRECT USAGE OF
						 LOOP.TRIGGER.CLICK, LOOP.LAST.CLICK
1988/08/30 - PF  - REMOVED THD.SEQ.RTES
1988/06/24 - MWH - Stop LOD notes as well as SEQ notes
1988/04/13 - PF  - ADDED THD.SEQ.RTES
1988/03/15 - CJ  - send over new track volume when recording on cue track
1987/12/18 - MWH - Merge poly updates with N-Final plus AEE sources
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/09/09 - MWH - ADDED PREFERED POLY BIN TO TRACK HEADER
1987/07/07 - cj  - start.time.base, stop.time.base, etc swapping
1987/01/06 - CJ  - BACKUPD UP BY SEQ.MONO3 IN PRESET PLAY TIME
1986/12/30 - CJ  - REMOVED MONO SYNC & MONO START FROM STOP.PLAY
1986/12/04 -CJ,TS- ADDED MIDI SONG PTR SYNC UP
1986/11/18 - TS  - MADE CHECK IN START.MOVING.FORWARD FOR PLAYING PAST END OF LOOP
1986/10/24 - TS  - INIT THD.RTES TO 0 INSTEAD OF RTE.MAX IN PLAY.INITIALIZE
1986/10/17 - TS  - MODIFIED PLAY.INITIALIZE TO DO OVERALL LOOP START BETTER
1986/09/17 - TS  - MODIFIED MARK BUTTON CODE FOR 32-BIT TIME
1986/09/11 -CJ,EG- MARK.BUTTON VARIABLES TO PUBLIC
1986/08/21 - TS  - CHANGED NEW.SEQ.NOTES=1 TO CHECK.TRACK.DISPLAY=1
1986/08/24 - TS  - PUT THD.ACTIVE.MIDI.RTES CODE IN OK.TO.COPY.TIMBRE AND START.RECORD
1986/08/21 - TS  - CHANGED CHECK.WINDOW.BOUNDARIES CALL TO NEW.SEQ.NOTES=1
1986/08/20 - TS  - ADDED CALL TO CHECK.WINDOW.BOUNDARIES TO STOP.PLAY
1986/08/19 - TS  - MOVED TIME.DELTA DCL TO 161-SEQ1
1986/08/07 - CJ  - LOD CHANGES TO START.TIME.BASE
1986/08/05 - TS  - FIXED BUG IN START.RECORD/STOP.RECORD
1986/07/31 - CJ  - CHANGES TO STOP RECORD, START RECORD FOR LOD
1986/07/28 - TS  - WROTE OK.TO.COPY.TIMBRE FOR USE IN START.RECORD & BOUNCE.DOWN
1986/07/28 - TS  - RESET THD.ILD.SCANNED IN INIT.TRACK.HEAD.FOR.PLAY
1986/07/25 - TS  - WHEN FREEING UP NLS, PUT (-1) IN NLS.REV, NLS.TRK
1986/07/21 - TS  - FIXED SOME BUGS IN GARBAGE COLLECT IN STOP.RECORD
1986/07/17 - TS  - MADE OPTIMIZATION IN STOP.RECORD
1986/07/15 -CJ,TS- CALLED CHECK.ALL.MIDI.TRACKS
1986/07/14 - CJ  - CHANGED PLAYINITIALIZE FOR FIRST.SEQ.MSB,LSB
1986/07/11 -CJ,TS- CLEANED UP PLAY INIT FOR LIVE CLICK TRACK. ALSO RECORDER SCREEN TITLE CHANGE (NEW.SEQ=2)
1986/07/10 -CJ,TS- MIDI IN SYNC, PLAY.INITIALIZE CHANGES
1986/07/10 - CJ  - 50 HZ SYNC INPUT ITEMS (START.TIME.BASE, ETC.)
1986/07/09 - CJ  - EXTERNAL CLOCK OUTPUT ITEMS
1986/06/30 - TSS - REMOVED SOME EXTRANEOUS CODE IN START.RECORD FOR MATT
1986/06/28 - CJ  - EXTERNAL CLICK STUFF (TRIGGER.CLICK)
1986/06/20 - CJ  - SET TIME.BASE.MODE FOR SMPTE SYNC
1986/06/18 - CJ  - FIRST.PLAY.TIME.ACU DECLARATION
1986/06/09 - TSS - New code for START.RECORD and STOP.RECORD
1986/05/15 - "official" creation of release-M modules
*/


DCL FIRST.PLAY.TIME.MSB FIXED PUBLIC;	/* 32-BIT TICK COUNT CORRESPONDING */
DCL FIRST.PLAY.TIME.LSB FIXED PUBLIC;	/* TO TIME OF FIRST EVENT ON TRACK */
DCL FIRST.PLAY.TIME.ACU FIXED PUBLIC;	/* PRECISION FOR LIVE OVERDUB      */

DCL (FIRST.SEQ.MSB)  FIXED;			/* FIRST TIME OF ANY NOTE IN */
DCL (FIRST.SEQ.LSB)  FIXED;			/* SEQUENCE FOR ANY TRACK    */
DCL UPDATE.MIDI      FIXED PUBLIC;

INIT.TRACK.HEAD.FOR.PLAY: PROC (PTR) PUBLIC SWAPABLE;	/* INITS TRACK HEADER INFO FOR PLAY START */
	DCL PTR FIXED;							/* ABS POINTER TO TRACK HEAD TO INITALIZE */

	/* THIS ROUTINE ASSUMES THE DESIRED TRACK ACTUALLY EXISTS */
	/* ONLY CALL THIS ROUTINE IF PLAY=0                       */

	FIND.ANY.NOTE: PROC;	/* FINDS ANY NOTE ON TRACK */
		DCL TRK.PTR    FIXED;	/* ABSOLUTE PTR TO THIS TRK HEADER       */
		DCL (SEC,WRD)  FIXED;	/* TEMPS TO HOLD CURRENT SEC AND WRD PTR */
		DCL (NLSB)     FIXED;	/* TEMPS TO HOLD NEXT     EVENT TIME     */
		DCL (CONTENTS) FIXED;	/* WORD POINTED TO BY CURRENT POINTER    */

		/* THIS ROUTINE ASSUMES THE DESIRED TRACK HEADER EXISTS. IT */
		/* ALSO EXPECTS THE MAM/MAL PTRS TO BE POINTING AT THE TRK  */
		/* HEAD FOR THE TRACK.  ROUTINE SETS THE TRK HEADER         */
		/* VARIABLES LISTED BELOW:                                  */
		/*               THD.NMSB  AND  THD.NLSB                    */
		/*               THD.LMSB  AND  THD.LLSB                    */
		/*               THD.WRD   AND  THD.SEC                     */

		TRK.PTR=READ(MAM);						/* SAVE PTR TO OUR TRK HEAD       */
		WRITE(MAL)=THD.FOR;						/* GET FORWARD PTR TO 1ST NLS     */
		SEC=READ(MD);								/* SAVE RELATIVE PTR TO FIRST NLS */

		/* FIRST INITIALIZE TEMP TRK VARIABLES TO START OF SEQ */

		CONTENTS=0;
		NLSB    =0;									/* NEXT EVENT BEFORE SCRIPT 0.000 */
		WRD     =0;									/* IN CASE WE BOMB OUT            */

		IF SEC=0 THEN DO;
			CONTENTS=NLS.EOS;						/* FAKE END OF LIST             */
			GOTO DONE;								/* NO NOTE LIST SEGMENTS ON TRK */
		END;

		NEXT.SECTOR:								/* JUMP HERE FOR NEW NLS     */

		WRITE(MAM)=NAH.PTR+SEC;					/* SET UP ABS PTRS TO NLS    */
		WRITE(MAL)=NLS.FP;						/* GET FIRST POINTER         */
		WRD=READ(MD);								/* USE FIRST AVAILABLE WORD  */

		NEXT.NOTE:									/* JUMP HERE FOR NEXT WRD IN SAME NLS */
		WRITE(MAL)=WRD;

		IF READ(MD)=NLS.EOS THEN DO;			/* END OF THIS NLS           */

			WRITE(MAL)=NLS.FOR;					/* LOOK UP FORWARD PTR       */

			IF READ(MD)=0 THEN DO;				/* END OF TRACK -- BOMB OUT  */
				CONTENTS=NLS.EOS;					/* FAKE END OF LIST          */
				GOTO DONE;							/* PUT FINAL VALS INTO TRK   */
			END;

			SEC=READ(MD);							/* UPDATE CURRENT SECTOR PTR */

			GOTO NEXT.SECTOR;						/* CONTINUE FROM NEXT NLS    */
		END;


		/* $PAGE */


		NLSB=SHR(READ(MD),1)&1023;				/* EXTRACT START TIME DELTA FOR NOTE RECORD */

		DONE:											/* PUT NEW INFO INTO TRK HEAD */

		WRITE(MAM)=TRK.PTR;						/* POINT TO TRK HEADER AGAIN */
		WRITE(MAL)=THD.NMSB;						/* SET PTR TO START OF BLOCK */
		WRITE(MDI)=0;								/* THD.NMSB                  */
		WRITE(MDI)=NLSB;							/* THD.NLSB                  */
		WRITE(MDI)=0;								/* THD.LMSB                  */
		WRITE(MDI)=0;								/* THD.LLSB                  */
		WRITE(MDI)=WRD;							/* THD.WRD                   */
		WRITE(MD )=SEC;							/* THD.SEC                   */

		IF CONTENTS<>NLS.EOS THEN DO;			/* A NOTE IS THERE - LINK UP */

			WRITE(MAL)=THD.ANY.FOR;				/* WE FOUND ANOTHER NOTE */
			WRITE(MDI)=1;							/* IN FORWARD DIRECTION  */
			WRITE(MD )=0;							/* BUT THD.ANY.REV IS ALWAYS ZERO */

			CALL FORWARD.MERGE.INTO.EVENT.QUEUE(TRK.PTR);

		END;
		ELSE DO;										/* NO NOTES - INIT THD.ANY VARS */

			WRITE(MAL)=THD.ANY.FOR;				/* NO MORE NOTES IN FORWARD */
			WRITE(MDI)=0;							/* DIRECTION OR REVERSE DIR */
			WRITE(MD )=0;							/* SO THD.ANY.REV=0 TOO     */

		END;

		WRITE(MAM)=TRK.PTR;						/* RESTORE POINTER TO TRK HEADER */

	END FIND.ANY.NOTE;

	/* $PAGE */

	/* FIRST WE WILL INITIALIZE THE TRANSPOSE,  */
	/* TIMBRE NUMBER, AND LAST PITCH VALUES FOR */
	/* THE TRACK.  GET STARTING VALUES FROM TRK */
	/* HEADER AND COPY INTO APPROPRIATE CURRENT */
	/* VALUE VARS.                              */

	WRITE(MAM)=PTR;

	WRITE(MAL)=THD.SXPOS;		/* GET STARTING XPOS, TIMBRE, AND LPITCH */
	WRITE("300")=READ(MDI);		/* STARTING TRANSPOSE, THD.SXPOS         */
	WRITE("301")=READ(MDI);		/* STARTING TIMBRE,    THD.STIMB         */
	WRITE("302")=READ(MD );		/* STARTING LPITCH,    THD.SLPITCH       */

	WRITE(MAL)=THD.CXPOS;		/* NOW RESET THE CURRENT VALUES TO THESE */
	WRITE(MDI)=READ("300");		/* CURRENT TRANSPOSE,  THD.CXPOS         */
	WRITE(MDI)=READ("301");		/* CURRENT TIMBRE,     THD.CTIMB         */
	WRITE(MDI)=READ("302");		/* CURRENT LPITCH,     THD.CLPITCH       */

	WRITE(MDI)=0;					/* INIT TOGGLE BITS     TO ZERO (THD.CTBITS)   */
	WRITE(MDI)=0;					/* INIT MIDI PORTAMENTO TO OFF  (THD.CG.VAL)   */
	WRITE(MDI)=0;					/* INIT MIDI PROGRAM #  TO ZERO (THD.CPROGRAM) */

	/* INIT THE RTE DATA (THD.RTES)  */
	/* UNIPOLAR CONTROLLERS GET SET  */
	/* TO ZERO, INVERTED VALUES TO   */
	/* RTE.MAX.  BIPOLAR CONTROLLERS */
	/* GET SET TO ZERO.              */

	/* Each word in THD.RTES should contain the inverted value in the upper byte and the normal value in the lower.
		So to clarify what is stated above, unipolar controllers should be set to ZERO\SHL(RTE.MAX,8).
	*/

	WRITE(MAL)=THD.RTES;

	WRITE("313") = shl(rte.max,8);
	write(MDI) = rte.max;				/* PEDAL 1                                        */
	rpc 3; WRITE(MDI) = READ("313");	/* PEDAL 2, MOD WHEEL, BREATH CONTROLLER          */
	rpc 4; WRITE(MDI) = 0;				/* PITCH WHEEL, RAW RIBBON, +FRIBBON, -FRIBBON	  */

	/* RESET CURRENT SUSTAIN STATE */
	WRITE(MAL)=THD.SUSTAIN;
	WRITE(MD)=(READ(MD)&(NOT B.CURRENT.SUSTAIN));

	/* INITIALIZE A FEW OTHER MISCELLANEOUS */
	/* TRACK STATE VARIABLES                */

	WRITE(MAL)=THD.TRIGGER;			/* AND INIT TRIGGER SIDE */
	WRITE(MD )=0;						/* FOR STEREO PING-PONG  */

	WRITE(MAL)=THD.ILS.SCANNED;	/* INIT FLAG TO DENOTE WE HAVE  */
	WRITE(MD )=0;						/* NOT PROCESSED ILS RECORD YET */

	WRITE(MAL)=THD.ILPCTR;			/* INIT ILP COUNTER TO ZERO     */
	WRITE(MD )=0;

	WRITE(MAL)=THD.ILS.TIME.MSB;
	WRITE(MDI)=0;
	WRITE(MD )=0;

	CALL FIND.ANY.NOTE;			/* FIND ANY NOTE & INIT POINTERS */

	IF ((MARK.BUTTON.MSB=0)&(MARK.BUTTON.LSB ILT ZERO.TIME))
	OR  (MARK.BUTTON.DISABLED<>0)		/* NO MARK BUTTON DEFINED         */
	THEN DO;									/* LOOK FOR FIRST SOUNDING NOTE   */
		WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.S.P.T;			/* CHECK CURRENT LOOP START TIME  */
		IF (OVERALL.LOOP=0)				/* NO OVERALL LOOP                */
		OR (NUM.OF.SOLOED.TRACKS<>0)	/* OR HAVE SOME TRACKS SOLOED     */
		OR ((READ(MDI)\READ(MD))=0)	/* SEQ.S.P.T & SEQ.S.P.T.C BOTH ZERO */
		THEN DO;								/* FIND FIRST NOTE & START THERE  */
			WRITE(MAM)=PTR;				/* RESTORE POINTER                */
			WRITE(MAL)=THD.TRK;			/* LOOK UP OUR TRK NUMBER         */

			IF FIND.FIRST.NOTE(READ(MD))<>0 THEN DO;	/* NON-EMPTY       */

				IF  ((TRACK.FIRST.TIME.MSB  ILT  FIRST.SEQ.MSB))
				OR  ((TRACK.FIRST.TIME.MSB   =   FIRST.SEQ.MSB)
				AND  (TRACK.FIRST.TIME.LSB  ILT  FIRST.SEQ.LSB))
				THEN DO;					/* NOTE IS EARLIEST YET */
					FIRST.SEQ.MSB=TRACK.FIRST.TIME.MSB;
					FIRST.SEQ.LSB=TRACK.FIRST.TIME.LSB;
				END;

				WRITE(MAM)=PTR;				/* RESTORE POINTER                  */
				WRITE(MAL)=THD.ACTIVE;		/* IF TRACK IS ACTIVE THEN ADVANCE  */

				IF (READ(MD)<>0) THEN DO;	/* FIND FIRST NOTE OF ACTIVE TRACKS */

					IF  ((TRACK.FIRST.TIME.MSB  ILT  FIRST.PLAY.TIME.MSB))
					OR  ((TRACK.FIRST.TIME.MSB   =   FIRST.PLAY.TIME.MSB)
					AND  (TRACK.FIRST.TIME.LSB  ILT  FIRST.PLAY.TIME.LSB))
					THEN DO;					/* NOTE IS EARLIEST YET */
						FIRST.PLAY.TIME.MSB=TRACK.FIRST.TIME.MSB;
						FIRST.PLAY.TIME.LSB=TRACK.FIRST.TIME.LSB;
					END;
				END;
			END;
		END;
	END;

	/* FIND FIRST ACTUAL NOTE ON TRACK FOR TRANPOSE TRACKS */

	WRITE(MAM) = PTR;
	WRITE(MAL) = THD.IGNORE;

	IF ((READ(MD) & THD.IGNORE.XPOS) != 0)
	{
		WRITE(MAM)=PTR;				/* RESTORE POINTER        */
		WRITE(MAL)=THD.TRK;			/* LOOK UP OUR TRK NUMBER */

		IF (FIND.FIRST.NOTE(READ(MD)) != 0)
		{
			WRITE(MAM) = PTR;
			WRITE(MAL) = THD.XPOSBASE;
			WRITE(MD ) = TRACK.FIRST.KEYN;
		}
	}

END INIT.TRACK.HEAD.FOR.PLAY;


/* $SUBTITLE  Set Up to Play Sequence from Start */


/* NOTE: PLAY.INITIALIZE CAN ONLY CALLED WITH PLAY=0 */

DCL OVERLAY.STATUS   FIXED PUBLIC;
DCL NOTES.SKIPPED    FIXED PUBLIC;
DCL MARK.BUTTON.VALM FIXED PUBLIC;		/* MARK.BUTTON.MSB VALUE AT PLAY.INITIALIZE CALL */
DCL MARK.BUTTON.VALL FIXED PUBLIC;		/* MARK.BUTTON.LSB VALUE AT PLAY.INITIALIZE CALL */
DCL MARK.CLICK.RATE  FIXED PUBLIC;		/* CLICK RATE DURING MARK BUTTON COMPUTATION */
DCL MARK.CLICK.MODE  FIXED PUBLIC;

PLAY.INITIALIZE: PROC PUBLIC SWAPABLE;	/* PROCEDURE TO SET UP VARIABLES FOR PLAYING */
	DCL I       FIXED;
	DCL TEMP(1) FIXED;
	DCL TIME(1) FIXED;

	INIT.NEXT.CLICK.FOR.LIVE.TRACK:PROC;
		IF CLICK.TRACK.MODE igt 3 THEN DO;	/* LIVE CLICK TRACK */

         /* find sequence time of first click: */

         CALL REMAP.WITH.LIVE.CLICK(0,ZERO.TIME,0,0,0);

         /* get corresponding real time:       */

         call Map.Sequence.Time.To.Real.Time(loc(addr(remapped.time.msb)), 
                                             loc(addr(remapped.time.msb)));
         NEXT.CLICK=REMAPPED.TIME.LSB; /* SYNC TIME OF FIRST CLICK      */

         /* find sequence time of next click: */

         CALL REMAP.WITH.LIVE.CLICK(0,1000 + ZERO.TIME,0,0,0);

         /* get corresponding real time:       */

         call Map.Sequence.Time.To.Real.Time(loc(addr(remapped.time.msb)), 
                                             loc(addr(remapped.time.msb)));
         EST.RATE = REMAPPED.TIME.LSB - NEXT.CLICK;  /* LENGTH OF FIRST BEAT          */

		END;

		ELSE EST.RATE = SAMP.CLICK.RATE;	/* APPROXIMATE RATE */

	END INIT.NEXT.CLICK.FOR.LIVE.TRACK;

	CALL SPEED.COMP;						/* SETS UP SAMP.CLICK.RATE AMONG OTHER THINGS */

	/* Create a "new notes" event whenever we jump over an independent */
	/* loop.  This makes the screen software redraw the notes at the   */
	/* new time.  This allows the screen software to "approximately"   */
	/* un-wrap the independent loop.  Give this event only to the ABLE */
	/* screens, since it will be handled other ways over the protocol. */

	NEW.ABLE.SEQ.INFO = NEW.ABLE.SEQ.INFO \ 4;	/* NEW NOTES INFO IN SEQUENCER */

	/* COMPUTE DESIRED FIRST.PLAY.TIME     */
	/* BASED UPON SOLOED TRACKS,  MARK     */
	/* BUTTON, FIRST NOTE TIME, LOOP START */

	IF (((MARK.BUTTON.MSB=0)&(MARK.BUTTON.LSB ILT ZERO.TIME))
	OR  (MARK.BUTTON.DISABLED<>0))
	THEN DO;										/* NO MARK BUTTON DEFINED         */

		WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.S.P.T;				/* ASSUME LOOP START TIME IS DESIRED */
		FIRST.PLAY.TIME.LSB=READ(MDI);	/* GET SEQ.S.P.T   */
		FIRST.PLAY.TIME.MSB=READ(MD );	/* GET SEQ.S.P.T.C */

		IF (OVERALL.LOOP=0)					/* NO OVERALL LOOP                */
		OR (NUM.OF.SOLOED.TRACKS<>0)		/* OR HAVE SOME TRACKS SOLOED     */
		OR ((FIRST.PLAY.TIME.MSB\FIRST.PLAY.TIME.LSB)=0)	/* SEQ.S.P.T & SEQ.S.P.T.C BOTH ZERO */
		THEN DO;									/* FIND FIRST NOTE & START THERE  */
			FIRST.PLAY.TIME.MSB=(-1);		/* SPECIAL TARGET TIME -- DENOTES */
			FIRST.PLAY.TIME.LSB=(-1);		/* ADVANCE TO FIRST REAL NOTE     */
		END;
		FIRST.SEQ.MSB      =(-1);
		FIRST.SEQ.LSB      =(-1);
		MARK.BUTTON.VALM   =0;				/* NO MARK IN EFFECT              */
		MARK.BUTTON.VALL   =0;
		MARK.CLICK.RATE    =0;
		MARK.CLICK.MODE    =0;
	END;
	ELSE DO;										/* COMPUTE FIRST PLAY TIME IF MARK START ACTIVE */
		MARK.BUTTON.VALM = MARK.BUTTON.MSB;		/* SAVE SETTING TO DETECT CHANGES     */
		MARK.BUTTON.VALL = MARK.BUTTON.LSB;
		MARK.CLICK.RATE  = SAMP.CLICK.RATE;
		MARK.CLICK.MODE  = CLICK.TRACK.MODE;

		FIRST.PLAY.TIME.MSB=MARK.BUTTON.MSB;	/* 32-BIT TICK COUNT FOR DESIRED BEAT */
		FIRST.PLAY.TIME.LSB=MARK.BUTTON.LSB;
	END;

	PLAY.TIME.MSB  =0;					/* INITIALIZE TIME TO START */
	PLAY.TIME.LSB  =0;
	PLAY.TIME.ACU  =0;
	NEXT.CLICK     =ZERO.TIME;			/* FIRST CLICK AT SCRIPT 0.000 */
	NEXT.SEQ.EVENT =ZERO.TIME;
	BEAT.NUMBER    =0;					/* INCREMENTED TO 1 WHEN SEQ STARTS */

	PRIOR.CLICK.MSB = 0;					/* SET UP SEQ TIMES OF PRIOR AND NEXT CLICKS */
	PRIOR.CLICK.LSB = 0;
	NEXT.CLICK.MSB  = 0;
	NEXT.CLICK.LSB  = ZERO.TIME;

	REAL.TIME.OF.NEXT.CLICK.MSB = 0;				/* FIRST CLICK AT SCRIPT 0.000 */
	REAL.TIME.OF.NEXT.CLICK.LSB = ZERO.TIME;
	ACTUALLY.EMIT.CLICK         = 0;				/* DON'T LET ANY CLICKS OUT YET */

	REAL.TIME.OF.NEXT.BEAT.MSB  = 0;				/* FIRST BEAT AT SCRIPT 0.000 */
	REAL.TIME.OF.NEXT.BEAT.LSB  = ZERO.TIME;

	NEXT.EVENT.QUEUE=0;								/* START WITH EMPTY LIST */

	DO I=NUM.KBD.TRACKS TO (MAX.TRACKS-1);		/* INIT EACH SEQUENCER TRACK */

		WRITE(MAM)=TRK.HEAD;							/* GET PTR TO TRACK HEADER FOR THIS TRACK */
		WRITE(MAL)=I;

		IF READ(MD)<>0									/* TRACK EXISTS */
		THEN CALL INIT.TRACK.HEAD.FOR.PLAY(READ(MD));	/* SET UP FOR PLAYING */

	END;													/* OF LOOP OVER SEQUENCER TRACKS */

	CALL INIT.MIDI.RTE.AREA;						/* INITIALIZE MIDI TRACK RTES */

	CALL INIT.NEXT.CLICK.FOR.LIVE.TRACK;		/* SET UP NEXT.CLICK IF LIVE TRACK */

	/* $PAGE */


	IF (((MARK.BUTTON.MSB=0)&(MARK.BUTTON.LSB ILT ZERO.TIME))
	OR  (MARK.BUTTON.DISABLED<>0))	/* NO MARK BUTTON DEFINED       */
	AND (FIRST.PLAY.TIME.MSB=(-1))	/* AND NO EARLIER NOTE FOUND    */
	AND (FIRST.PLAY.TIME.LSB=(-1))	/* BY INIT.TRACK.HEAD...        */
	THEN DO;									/* ON A SOLOED TRACK            */
		FIRST.PLAY.TIME.MSB=FIRST.SEQ.MSB;	/* THEN TRY ANY TRACK     */
		FIRST.PLAY.TIME.LSB=FIRST.SEQ.LSB;	/* AT ALL                 */
	END;

	/* IF NO MARK BUTTON DEFINED (OR SEQUENCE IS EMPTY), THEN SET    */
	/* LOOP START POINT TO START PRECISELY AT ZERO.TIME (THE TIME OF */
	/* THE FIRST CLICK)                                              */

	IF (((MARK.BUTTON.MSB=0)&(MARK.BUTTON.LSB ILT ZERO.TIME))
	OR  (MARK.BUTTON.DISABLED<>0))	/* NO MARK BUTTON DEFINED       */
	AND (FIRST.PLAY.TIME.MSB=(-1))	/* AND NO EARLIER NOTE FOUND    */
	AND (FIRST.PLAY.TIME.LSB=(-1))	/* BY INIT.TRACK.HEAD...        */
	THEN DO;									/* DETECT EMPTY SEQUENCE        */
		FIRST.PLAY.TIME.MSB=0;			/* RESET TIME TO ZERO           */
		FIRST.PLAY.TIME.LSB=ZERO.TIME;
		FIRST.PLAY.TIME.ACU=0;
	END;

	/* find real time that corresponds to this first note:           */

	call Map.Sequence.Time.To.Real.Time(loc(addr(FIRST.PLAY.TIME.MSB)),
													temp);

	/* back up the real time until the corresponding sequence time */
	/* is BEFORE the sequence time we wish to start at:            */

	call Map.Real.Time.To.Sequence.Time(temp, time);

	do while (COM32(time, loc(addr(first.play.time.msb))) >= lw#ieq)
	and      (COM16(   0, temp                          ) <> lw#ieq);
		call SUB16(1, temp);
		call Map.Real.Time.To.Sequence.Time(temp, time);
	end;

	CALL ADVANCE.SEQUENCER(TEMP(0), TEMP(1));		/* positions sequencer for start of loop */

	CALL LOOP.SAMPLE;	/* sample all track pointers for overall loop */

	LOOP.SEQ.TIME.MSB  = FIRST.PLAY.TIME.MSB;
	LOOP.SEQ.TIME.LSB  = FIRST.PLAY.TIME.LSB;

	LOOP.PLAY.TIME.MSB = PLAY.TIME.MSB;
	LOOP.PLAY.TIME.LSB = PLAY.TIME.LSB;
	LOOP.PLAY.TIME.ACU = PLAY.TIME.ACU;
	LOOP.NEXT.CLICK    = NEXT.CLICK;
	LOOP.BEAT.NUMBER   = BEAT.NUMBER;
	LOOP.TRIGGER.CLICK = TRIGGER.CLICK;
	LOOP.LAST.CLICK    = LAST.CLICK;

	IF COM16(ZERO.TIME, LOC(ADDR(LOOP.SEQ.TIME.MSB))) = LW#IEQ
	THEN LOOP.TIME.IS.AT.0 = 1;

	call Compute.Loop.Next.Click;		/* loop.seq.time must be setup for this call */

	/* RESET SEQUENCER TO 0 FOR GOOD */

	PLAY.TIME.MSB   = 0;					/* INITIALIZE TIME TO START */
	PLAY.TIME.LSB   = 0;
	PLAY.TIME.ACU   = 0;
	NEXT.CLICK      = ZERO.TIME;		/* FIRST CLICK AT SCRIPT 0.000      */
	NEXT.SEQ.EVENT  = ZERO.TIME;
	BEAT.NUMBER     = 0;					/* INCREMENTED TO 1 WHEN SEQ STARTS */

	PRIOR.CLICK.MSB = 0;					/* SET UP SEQ TIMES OF PRIOR AND NEXT CLICKS */
	PRIOR.CLICK.LSB = 0;
	NEXT.CLICK.MSB  = 0;
	NEXT.CLICK.LSB  = ZERO.TIME;

	REAL.TIME.OF.NEXT.CLICK.MSB = 0;				/* FIRST CLICK AT SCRIPT 0.000 */
	REAL.TIME.OF.NEXT.CLICK.LSB = ZERO.TIME;
	ACTUALLY.EMIT.CLICK         = 1;				/* TELL INT CODE OK TO CLICK */

	REAL.TIME.OF.NEXT.BEAT.MSB  = 0;				/* FIRST BEAT AT SCRIPT 0.000 */
	REAL.TIME.OF.NEXT.BEAT.LSB  = ZERO.TIME;

	TRIGGER.CLICK   = 0;					/* NO RECORDED CLICK TRACK TRIGGER */
	LOOP.TRIG.CLICK = 0;					/* ALSO NO LOOP TRIGGER CLICK      */

	NEW.MOTION   =1;

	NEXT.EVENT.QUEUE=0;					/* START WITH EMPTY LIST */

	DO I=NUM.KBD.TRACKS TO (MAX.TRACKS-1);	/* INIT EACH SEQUENCER TRACK */

		WRITE(MAM)=TRK.HEAD;				/* GET PTR TO TRACK HEADER FOR THIS TRACK */
		WRITE(MAL)=I;

		IF READ(MD)<>0						/* TRACK EXISTS */
		THEN CALL INIT.TRACK.HEAD.FOR.PLAY(READ(MD));	/* SET UP FOR PLAYING */

	END;										/* OF LOOP OVER SEQUENCER TRACKS */

	CALL INIT.NEXT.CLICK.FOR.LIVE.TRACK;	/* SET UP NEXT.CLICK FOR LIVE TRACK */

	CALL COMPUTE.ARLIST;					/* SET UP ARLIST NOW             */

	CALL RESYNC.TIME.BASE;				/* GET SEQUENCER INFO CORRECT FOR SYNC PURPOSES */

	IF INC.FM
	THEN CLOCK.DATA=READ("160")&2;	/* INIT CLOCK SIGNAL TO CURRENT STATE */

	RANDOM#         =0;			/* INITIALIZE RANDOM # SEQUENCE SO IT IS ALWAYS THE SAME */
	NOTES.SKIPPED   =0;			/* INITIALIZE TO NO NOTES SKIPPED   */
	PTRS.LOOPED     =0;			/* CLEAR FLAG FROM LOOPING POINTERS */
	LOOP.RESTART    =0;			/* AND CLEAR LOOP RESTART FLAG IN CASE IT WAS LEFT OVER  */
	TRIGGER.CLICK   =0;
	LOOP.TRIG.CLICK =0;
	LAST.CLICK      =0;			/* INIT FOR EXTERNAL JUSTIFICATION */

	MIDI.CLOCK.RATE=SAMP.CLICK.RATE;	/* INITIALIZE MIDI CLOCK RATE FOR ACCURACY */
	IF CLICK.TRACK.MODE igt 3 THEN DO;
		MIDI.CLOCK.RATE=EST.RATE;		/* GET ACTUAL EST.RATE COMPUTED ABOVE */
		IF (MIDI.CLOCK.RATE=0) OR (MIDI.CLOCK.RATE IGT 10000)	/* KEEP NEXT.CLICK */
		THEN MIDI.CLOCK.RATE=500;
	END;
	
	if (NEXT.EVENT.QUEUE<>0)
	{
		if tempo.map.ptr <> 0
		{
			dcl (msb, lsb) fixed;
			call Map.Sequence.Time.To.Real.Time(loc(addr(NEXT.EVENT.MSB)), loc(addr(msb)));
			next.seq.event = lsb - prescan;
		}
		
		else
			next.seq.event = NEXT.EVENT.LSB - prescan;
	}
	
	else
		next.seq.event = play.time.lsb + 5000;

END PLAY.INITIALIZE;


/* $SUBTITLE */


START.TIME.BASE: PROC PUBLIC SWAPABLE;		/* SETS TIME.BASE.MODE TO ENABLE TIME ADVANCING */

	PLAY               =1;
	NEW.MOTION         =1;				/* TELL LIVE OVERDUB ABOUT IT */
	PLAY.SEQ.TO.A.TIME =0;				/* NO "PLAY TO"               */
	DELAY.NOTE.AND.CUE.STARTS = 0;	/* NO PRE-ROLL WITHOUT AUDIO  */

	DISABLE.SMPTE.START=0;

	IF SMPTE.ONOFF<>0					/* SMPTE SYNC - WAIT FOR LOCKUP */
	THEN TIME.BASE.MODE=0;
	ELSE IF EXT.CLOCK.MODE=1		/* 50 HERTZ SYNC                */
	THEN TIME.BASE.MODE=5;
	ELSE IF EXT.CLOCK.MODE>=2		/* BEAT SYNC, MIDI SYNC         */
	THEN TIME.BASE.MODE=6;
	ELSE IF LOD.RUNNING<>0			/* LIVE OVERDUB - WAIT FOR SYNC */
	THEN TIME.BASE.MODE=7;			/* MESSAGE FOR BETTER STARTUP   */
	ELSE TIME.BASE.MODE=1;			/* NORMAL INTERNAL SYNC         */

	IF TIME.BASE.MODE <> 0
	THEN NEW.SEQUENCER.FORWARD.MOTION = 1;	/* NEW FORWARD MOTION NOW */

	interpret_set_timebase_mode(TIME.BASE.MODE);
END START.TIME.BASE;


STOP.TIME.BASE: PROC PUBLIC SWAPABLE;	/* SETS TIME.BASE.MODE TO DISABLE TIME ADVANCING note - called sometimes with interrupts on, sometimes with interrupts off */
	PLAY               =0;
	TIME.BASE.MODE     =0;
	NEW.MOTION         =1;			/* TELL LIVE OVERDUB ABOUT IT */
	PLAY.SEQ.TO.A.TIME =0;			/* NO "PLAY TO"               */
	
	interpret_set_timebase_mode(TIME.BASE.MODE);
END STOP.TIME.BASE;


START.PLAY: PROC PUBLIC SWAPABLE;	/* PROCEDURE TO START PLAYING - CALLED ONLY WHEN PLAY=0 */
	CALL PLAY.INITIALIZE;			/* SET UP FOR PLAY FROM THE TOP */

	NEW.BEAT.NUMBER = 1;				/* PUT 0 IN DISPLAY IN CASE OF EXT SYNC */

	CALL CHECK.ALL.MIDI.TRACKS;
	CALL CHECK.ALL.MIDI.RTES;
	CALL START.MIDI.SUSTAIN;

	IF  (MIDI.SYNC.OUT<>0)		/* SEND MIDI START AT THIS POINT IF NOT USING SMPTE.  IF USING SMPTE, */
	AND (SMPTE.ONOFF=0)			/* THE MIDI START IS SENT OUT DURING THE SMPTE LOCK-UP PROCESS			 */
	THEN DO;
		IF (MIDI.SYNC.IS.TC)
		THEN DO;
			PREP.FOR.MTC.OUTPUT(PLAY.TIME.MSB, PLAY.TIME.LSB, FALSE);
			CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN       */
		END;

		ELSE IF ((MIDI.LIMIT.MSB=0)&(MIDI.LIMIT.LSB ILE ZERO.TIME))
		THEN DO;
			DISABLE;
			CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN    */
			CALL SEND.MIDI.START;		/* TELL MIDI DEVICES TO START */
			/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/
		END;

		ELSE DO;
			CALL MIDI.SONG.POS.PTR(MIDI.LIMIT.MSB, MIDI.LIMIT.LSB);	/* TELL MIDI DEVICES TO LOCATE */
			DISABLE;
			CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN       */
			CALL SEND.MIDI.CONTINUE;	/* TELL MIDI DEVICES TO CONTINUE */
			/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/
		END;
	END;
	ELSE CALL START.TIME.BASE;	/* ENABLE SEQUENCER TO RUN */

END START.PLAY;


/* $PAGE */


STOP.PLAY: PROC PUBLIC SWAPABLE;	/* PROCEDURE TO CLEAN UP AT END OF PLAYING */
	ABORT.SEQ.NOTES=1;				/* ABORT ALL SEQUENCER NOTES   */
	STOP.INFO.CUES =1;				/* ABORT LOD NOTES (IF ANY)    */
	LOD.CUE.LEN    =0;
	AUTO.PUNCH.IN.ARMED = 0;		/* TURN OFF PENDING AUTO PUNCH */
	PLAY.SEQ.TO.A.TIME =0;			/* NO "PLAY TO"                */
	RESET.BITS = RESET.BITS & (NOT(R.XPOS));

	IF EXT.REC.TRIGGER.STATE > 1				/* IF ANYTHING HAS BEEN TRIGGERED */
	THEN DO;											/* TRIGGER RECORD OUT SIGNAL */
		IF D34_TRIGGER_BITS <> 0 THEN DO;	/* FIRST CLEAR OUT ANY TRIGGERS BEING HELD */
			WRITE("34") = D34_CCC_BITS;
			D34_TRIGGER_BITS = 0;
		END;
		WRITE("34") = (D34_CCC_BITS | BITS(B#REC_OUT));	/* TRIGGER RECORD OUT */
		DO EXT.REC.TRIGGER.STATE = 0 TO 10; END;			/* WAIT A SHORT TIME  */
		WRITE("34") = D34_CCC_BITS;	/* CLEAR RECORD OUT */
	END;
	EXT.REC.TRIGGER.STATE = 0;			/* TURN OFF EXTERNAL RECORD TRIGGERS */

	IF (MIDI.SYNC.OUT   != 0)			/* WE ARE SENDING MIDI REAL-TIME BYTES	(MTC or MCLK) */
	{
		if (MIDI.SYNC.IS.TC == 0)		/* MIDI CLOCKS	*/
		{
			DISABLE;
			CALL STOP.TIME.BASE;		/* STOP SEQUENCER */
			CALL SEND.MIDI.STOP;		/* TELL MIDI DEVICES TO STOP */
			/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/
		}
		
		else
		{
			CALL STOP.TIME.BASE;
			BROADCAST.MTC();
		}
	}
	
	// Else no midi clocks/midi time code going out - just stop sequencer
	ELSE CALL STOP.TIME.BASE;	/* STOP SEQUENCER */

	IF  (INC.MONO<>0)				/* MONO COMPILATION */
	AND (OVERLAY.STATUS<>0)		/* OVERLAY MODE */
	THEN DO;							/* PRESENT DISPLAY */
		CALL DISPLAY.MORE.NOTES(NOTES.SKIPPED);
		NOTES.SKIPPED=0;			/* RESET AFTER DISPLAY */
	END;

	CREATE.50HZ.CLOCK=0;			/* TO KEEP INTERRUPT FROM CLOBBERING US */
	IF  (EXT.CLOCK.OUT<>0)
	THEN DO;							/* KEEP CLOCK AT ZERO VOLTS             */
		IF INC.FM
		THEN WRITE("163")=1;		/* TOGGLE EXT CLOCK TO GENERATE 15 MS PULSE */
		EXT.CLOCK.OUT=EXT.CLOCK.OUT XOR 1;
	END;

	SLOCKED=0;						/* NOT LOCKED                      */
	SMPTE.RECD=0;					/* DISABLE FURTHER SMPTE RECORDING */

	CALL STOP.MIDI.SUSTAIN;		/* CLEAR MIDI SUSTAIN PEDAL */

END STOP.PLAY;


START.MOVING.FORWARD: PROC PUBLIC SWAPABLE;	/* START SEQUENCER FAST FORWARDING SLOWLY */
	PLAY.SEQ.TO.A.TIME = 0;				/* NO "PLAY TO"              */
	DELAY.NOTE.AND.CUE.STARTS = 0;	/* NO PRE-ROLL WITHOUT AUDIO */

	IF PLAY<>0 THEN DO;		/* ALREADY POTENTIALLY PLAYING NOTES  */
		ABORT.SEQ.NOTES=1;	/* THEN MAKE SURE THEY GET TURNED OFF */
		STOP.INFO.CUES =1;	/* ABORT LOD NOTES TOO (IF ANY)       */
		LOD.CUE.LEN    =0;
	END;

	IF OVERALL.LOOP<>0 THEN DO;	/* CHECK FOR TIME PAST LOOP */
		IF ( LOOP.PLAY.TIME.MSB IGT GOBACK.PLAY.TIME.MSB)	/* COULD BE LOOP START OR MARK POINT */
		OR ((LOOP.PLAY.TIME.MSB  =  GOBACK.PLAY.TIME.MSB)
		AND (LOOP.PLAY.TIME.LSB IGE GOBACK.PLAY.TIME.LSB ))
		THEN DO;
			CALL DISPLAY.ERR(28);	/* CANNOT PLAY/FF PAST END OF LOOP */
			RETURN;
		END;
	END;

	TIME.BASE.MODE=0;			/* NOT USING NORMAL TIMEBASE  */
	PLAY=1;						/* ENABLE PLAYING             */

	DISABLE;
	MOVE.LIMIT.MSB=-1;		/* TARGET TIME IS INFINITY (BEYOND END OF SEQ) */
	MOVE.LIMIT.LSB=-1;
	MOVE.SPEED=(+2000);		/* SLOWEST FAST FORWARD SPEED */
	MOVE=1;						/* FF/REWIND ACTIVE           */
	SAMPLED.MOVE=1;			/* TELL INTERRUPT ROUTINE     */
	SAMPLED.MOVE.SPEED = MOVE.SPEED;
	ENABLE;

	CALL REBUILD.EVENT.QUEUE;		/* SET UP EVENT QUEUE   */
	CALL COMPUTE.VOLUME.LEVELS;	/* SET UP MUTED VOLUMES */

	NEW.MOTION    =1;			/* TELL LIVE OVERDUB ABOUT IT */

	interpret_set_timebase_mode(TIME.BASE.MODE);
END START.MOVING.FORWARD;


/* $PAGE */


START.MOVING.BACKWARDS:  PROC PUBLIC SWAPABLE;	/* START SEQUENCER REWINDING SLOWLY */
	PLAY.SEQ.TO.A.TIME = 0;				/* NO "PLAY TO"              */
	DELAY.NOTE.AND.CUE.STARTS = 0;	/* NO PRE-ROLL WITHOUT AUDIO */

	IF PLAY<>0 THEN DO;		/* ALREADY POTENTIALLY PLAYING NOTES  */
		ABORT.SEQ.NOTES=1;	/* THEN MAKE SURE THEY GET TURNED OFF */
		STOP.INFO.CUES =1;	/* ABORT LOD NOTES TOO (IF ANY)       */
		LOD.CUE.LEN    =0;
	END;

	TIME.BASE.MODE=0;			/* NOT USING NORMAL TIMEBASE */
	PLAY=1;						/* ENABLE PLAYING            */

	IF  (LOOP.RESTART<>0)	/* TIME BASE HAS LOOPED      */
	AND (PTRS.LOOPED  =0)	/* BUT PLAY PTRS HAVE NOT    */
	THEN DO;

		CALL MOVE.LOOP.PTRS;	/* RESET THE PLAY PTRS TO LOOP START */

		LOOP.RESTART=0;		/* AND CLEAR BOTH OF THESE   */
		PTRS.LOOPED =0;
	END;

	DISABLE;
	MOVE.LIMIT.MSB=0;			/* TARGET TIME IS ZERO (BEGINNING OF SEQ) */
	MOVE.LIMIT.LSB=0;
	MOVE.SPEED=(-2000);		/* SLOWEST REWIND SPEED      */
	MOVE=1;						/* FF/REWIND ACTIVE          */
	SAMPLED.MOVE=1;			/* TELL INTERRUPT ROUTINE    */
	SAMPLED.MOVE.SPEED = MOVE.SPEED;
	ENABLE;

	CALL REBUILD.EVENT.QUEUE;		/* SET UP EVENT QUEUE   */
	CALL COMPUTE.VOLUME.LEVELS;	/* SET UP MUTED VOLUMES */

	IF  (PTRS.LOOPED<>0)		/* HAVE RESET OUR PLAY PTRS          */
	AND (LOOP.RESTART=0)		/* BUT HAVE NOT LOOPED OUR TIME BASE */
	THEN DO;

		PLAY.TIME.MSB=GOBACK.PLAY.TIME.MSB;	/* ADVANCE TIME BASE TO END */
		PLAY.TIME.LSB=GOBACK.PLAY.TIME.LSB;	/* OF OVERALL LOOP          */

		/* NOTE: FOR A MOMENT OUR NEXT.CLICK IS NOT NORMALIZED.		*/
		/*			THIS SITUATION WILL BE RESOLVED IN THE CALL BELOW.	*/

		CALL LOOP.TIME.BASE;	/* NOW LOOP THE TIME BASE INFO */

	END;

	NEW.MOTION    =1;			/* TELL LIVE OVERDUB ABOUT IT */

	interpret_set_timebase_mode(TIME.BASE.MODE);
END START.MOVING.BACKWARDS;


STOP.MOVE: PROC PUBLIC SWAPABLE;				/* PROCEDURE TO STOP MOVEMENT - RETURN TO FORWARD PLAY */
	ABORT.SEQ.NOTES=1;							/* STOP ALL SEQUENCER NOTES */
	STOP.INFO.CUES =1;							/* ABORT LOD NOTES (IF ANY) */
	LOD.CUE.LEN    =0;
	PLAY.SEQ.TO.A.TIME =0;						/* NO "PLAY TO"             */

	IF MOVE.SPEED<0								/* IF WE ARE REWINDING */
	THEN DO;											/* RECOVER FROM REWIND */
	  MOVE=0; MOVE.SPEED=0;						/* NEED TO CHANGE BEFORE REBUILD */
	  CALL REBUILD.EVENT.QUEUE;				/* SET UP EVENT QUEUE       */
	END;

	MOVE=0; MOVE.SPEED=0;						/* NOT MOVING ANYMORE         */
	PLAY=0;											/* GO DIRECTLY TO STOPPED NOW */
														/* SINCE TIME BASE MODE = 0   */

	CALL COMPUTE.VOLUME.LEVELS;				/* RESTORE UN-MUTED VOLUMES   */
	CALL COMPUTE.ACTIVE.TRKS;					/* IN CASE END OF SMPTE MOVE  */

	NEW.MOTION    =1;								/* TELL LIVE OVERDUB ABOUT IT */

END STOP.MOVE;


/* $SUBTITLE  ROUTINE TO SEE IF THE TIMBRES ON TWO TRACKS ARE THE SAME  */


/* OK.TO.COPY.TIMBRE COMPARES THE TIMBRES ON THE SOURCE AND DESTINATION */
/* TRACKS.  IF THEY ARE THE SAME, ROUTINE RETURNS A 1. OTHERWISE IT     */
/* RETURNS A 0.  IF EITHER THE SOURCE OR THE DEST TRACK IS THE KEYBOARD */
/* TRACK, THEN YOU MUST BE SURE TO CALL COMPUTE.USAGE.KEY# FOR THE      */
/* KEYBOARD TIMBRE IMMEDIATELY PRIOR TO CALLING THIS PROC.  OTHERWISE   */
/* THE USAGE KEY # IN THE KEYBOARD TIMBRE HEAD MAY NOT BE CORRECT.      */


OK.TO.COPY.TIMBRE: PROC (SOU,DES) FIXED PUBLIC SWAPABLE;	/* SEE IF SOU TIMBRE SAME AS DES TIMBRE */
	DCL (SOU,DES)   FIXED;
	DCL TRK         FIXED;	/* TRACK/TIMBRE TO COMPARE WITH KEYBOARD */
	DCL (I,J,K,L,M) FIXED;

	POINT.AT.KEY#: PROC (TRK);				/* SETS UP MAM & MAL PTRS TO TIM.RANDOM.KEY# */
		DCL TRK FIXED;							/* TRK TO SET UP FOR         */

		WRITE(MAM)=TRK;						/* POINT AT TRK HEAD         */
		WRITE(MAL)=THD.CTIMB;				/* GET CURRENT TIMBRE #      */
		TRK=READ(MD);
		WRITE(MAM)=TIM.HEAD;					/* POINT TO TIMBRE HEAD      */
		WRITE(MAL)=TRK;						/* ASSUME TIMBRE HEAD EXISTS */
		WRITE(MAM)=READ(MD);					/* POINT TO IT               */
		WRITE(MAL)=TIM.RANDOM.KEY#;		/* GET AT 64-BIT KEY #       */

	END POINT.AT.KEY#;


	/* 1. COMPARE TRACK VOLUMES                    */
	/* 2. COMPARE MIDI ROUTINGS & ACTIVE MIDI RTES */
	/* 3. COMPARE TIMBRE RND KEY #S                */

	IF SOU=DES THEN RETURN 1;			/* SOU AND DEST ARE THE SAME */

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=SOU;
	SOU=READ(MD);							/* SAVE PTR TO SOU TRK HEAD  */
	WRITE(MAL)=DES;
	DES=READ(MD);							/* SAVE PTR TO DES TRK HEAD  */

	IF (SOU\DES)=0 THEN RETURN 1;		/* NEITHER HAVE TRK HEADS - INSTANT MATCH */

	IF ((SOU<>0) AND (DES =0))			/* SOU HAS TRK HEAD, DES DOES NOT */
	OR ((SOU =0) AND (DES<>0))			/* DES HAS TRK HEAD, SOU DOES NOT */
	THEN RETURN 0;							/* NO MATCH                       */


	/* WE KNOW BOTH TRKS HAVE TRK HEADS */

	WRITE(MAM)=SOU;																	/* POINT AT SOU TRK HEAD */
	WRITE(MAL)=THD.TVOL; I=READ(MD);												/* LOOK UP TRACK VOLUME  */
	WRITE(MAL)=THD.MIDI; J=(READ(MD) & (not(THD.MIDI.MIDINET)));		/* AND MIDI ROUTING without midinet bit set (e.g. THD.MIDI.OMS and THD.MIDI.ORIG) */
	WRITE(MAL)=THD.ACTIVE.MIDI.RTES; K=READ(MD);								/* AND ACTIVE MIDI RTE BITS */
   WRITE(MAL)=THD.MIDI.PATH; L=READ(MD);										/* AND MIDINET ROUTING      */
   WRITE(MAL)=THD.MIDX; M=READ(MD);                                  /* AND MIDI XPOS            */

	WRITE(MAM)=DES;						/* POINT AT DES TRK HEAD */
	WRITE(MAL)=THD.TVOL;
	IF READ(MD)<>I THEN RETURN 0;		/* TRACK VOLUMES ARE DIFFERENT */

	WRITE(MAL)=THD.MIDI;
	IF (READ(MD) & (not(THD.MIDI.MIDINET))) <> J THEN RETURN 0;	/* MIDI ROUTINGS ARE DIFFERENT (disregarding midinet setting) */

	WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
	IF READ(MD)<>K THEN RETURN 0;		/* MIDI RTE BITS ARE DIFFERENT */

	WRITE(MAL)=THD.MIDI.PATH;
	IF READ(MD)<>L THEN RETURN 0;		/* MIDINET ROUTINGS ARE DIFFERENT */

	WRITE(MAL)=THD.MIDX;
	IF READ(MD)<>M THEN RETURN 0;		/* MIDI OUTPUT XPOS IS DIFFERENT */

	CALL POINT.AT.KEY#(SOU);			/* SET UP FOR READ OF TIM.RANDOM.KEY# */

	I=READ(MDI); J=READ(MDI);			/* SAVE SOU KEY IN TEMPS    */
	K=READ(MDI); L=READ(MD );

	CALL POINT.AT.KEY#(DES);			/* SET UP FOR READ OF TIM.RANDOM.KEY# */

	IF (READ(MDI)<>I)						/* IF 64-BIT RANDOM KEY     */
	OR (READ(MDI)<>J)						/* NUMBERS DIFFER BETWEEN   */
	OR (READ(MDI)<>K)						/* THE TWO TIMBRES, THEN    */
	OR (READ(MD )<>L)						/* WE CANNOT RECORD ON THIS */
	THEN RETURN 0;							/* TRK.  SO BOMB OUT!       */

	RETURN 1;								/* EVERYTHING MATCHES!!     */

END OK.TO.COPY.TIMBRE;
