/* :SYNRSOU:04-SEQ:160-SEQ0  $TITLE  SEQUENCER ROUTINES */

/*
1998/07/08 - TY  - Updated KBD.PHOTO.  It was working on variables that haven't been used since
						 1990/07/10 except when using a click track.  Modified accordingly.
1991/12/11 - PF  - Fix sequencer song position pointer bug
1991/01/09 - PF  - click track/overall loop bug fixes
1990/11/12 - PF  - Fix sustain bug at overall loop jump back
1990/11/06 - PF  - Support for new sustain update records
1990/10/11 - PF  - Begin using Loop.Seq.Time.Of.Next.Click
1990/08/27 - PF  - Support all MIDI controllers
1990/08/28 - PF  - Split off last half of file into 160seq0a
1990/07/16 - PF  - Made MIDI SYNC and EXTERNAL BEAT/MIDI SYNC work with Tempo Maps
1990/07/10 - PF  - Begin using REAL.TIME.OF.NEXT.CLICK in RESYNC.TIME.BASE
1990/07/10 - PF  - Begin using LOOP.REAL.TIME.OF.NEXT.CLICK etc in
						 LOOP.SAMPLE and KBD.PHOTO
1989/10/10 - cj  - give event only to ABLE screens on indep loop change
1989/09/23 - CJ  - Checked for several tempo mapping items
1988/10/03 - CJ  - CHANGED USE OF TRIGGER.CLICK TO PROVIDE FOR EXTENDED
						 CLICK TRACK AT END OF LIVE CLICK TRACK
1987/07/24 - cj  - made isa.normal.or.ilp call other routines to save object code
1986/10/21 - TS  - ADDED SOME LOOP.START.MSB/LSB CODE
1986/10/09 - TS  - ADDED INCREMENT.NUM.NOTES & DECREMENT.NUM.NOTES
1986/09/23 - eeg - added store.note.info
1986/09/10 - tss - bug fixed with thd.ils.scanned in load.play.info
1986/09/10 - eg  - added isa.rte.note
1986/08/13 - TS  - ADDED MORE CONSISTENCY CHECKS TO HANDLE.LOOP.JUMP
1986/08/04 - TS  - SPED UP LOOK.UP.NOTE.INFO
1986/07/30 - eg  - made reverse.merge.into.event.queue swapable
1986/07/28 - TS  - ADDED CODE TO USE THD.ILS.SCANNED AND THD.LP.ILS.SCANNED - SET NEW.SEQ.NOTES IN HANDLE.LOOP.JUMP
1986/07/25 - TS  - ADDED CONSISTENCY CHECK TO HANDLE.LOOP.JUMP
1986/07/15 -     - CALLED CHECK.MIDI.EFFECTS.  MOVE OTHER ROUTINES HERE
1986/07/11 -CJ,TS- ADDED RESYNC.TO.MIDI, LOOP.SAMPLE, KBD.PHOTO
1986/07/09 - CJ  - ADDED CLOCK OUTPUT ITEMS TO SET.CLOCK.CASE
1986/07/08 - eg  - inserted set.clock.case
1986/06/18 - CJ  - ADDED LOOP.PLAY.TIME.ACU
1986/05/15 - "official" creation of release-M modules
*/

SET.CLOCK.CASE:PROC PUBLIC SWAPABLE;

	EXT.CLOCK.CASE = 0;             /* ASSUME NO EXT CLOCK USE */

	IF (PLAY=0          )           /* IF NOT PLAYING          */
	OR (MOVE<>0         )           /* OR WE ARE MOVING        */
	OR (EXT.CLOCK.MODE=0)           /* OR NOT EXTERNAL SYNCING */
	OR (EXT.CLOCK.MODE>2)           /* OR SYNCHED TO MIDI      */
	THEN DO;
		IF CLICK.TRACK.MODE=3 THEN DO;      /* USING EXTERNAL CLICK TRACK */
			IF (PLAY<>0)&(MOVE=0) THEN DO;   /* IF PLAY ONLY, THEN COUNT CLICK */
				EXT.CLOCK.CASE=1;             /* USE EXTERNAL CLOCK FOR CLICK   */
			END;
		END;
		ELSE IF EXT.REP.ARP<>0 THEN DO;     /* REPEAT/ARPEGGIATE */
			EXT.CLOCK.CASE=2;                /* EXT REP/ARP       */
		END;
		ELSE IF (ENABLE.KEY.TRIG<>0)
		AND     (EXT.CLOCK.MODE  =0)
		THEN DO;                            /* TRIGGER MOST RECENT NOTE */
			EXT.CLOCK.CASE=3;                /* TRIGGER NOTE             */
		END;
	END;

	ELSE DO;                               /* MUST BE EXT SYNCING   */
		IF (EXT.CLOCK.MODE=1) THEN DO;      /* 50 HZ SYNC            */
			EXT.CLOCK.CASE=4;
		END;
		ELSE DO;                            /* MEANS EXTERNAL BEAT SYNCHRONIZATION */
			EXT.CLOCK.CASE=5;
		END;                      /* OF EXT BEAT SYNC      */
	END;                         /* OF EXT SYNC CASE      */

	IF  (PLAY<>0)                /* PLAYING - CREATE SYNC SIGNAL */
	AND (MOVE=0)                 // pass in SYNCLAVIER_PREF_CREATE_CLOCK - should return that to default to ON on model D
   AND ((interp_real_time_prefs(SYNCLAVIER_PREF_CREATE_CLOCK) & SYNCLAVIER_PREF_CREATE_CLOCK) != 0)
	THEN DO;
		IF EXT.CLOCK.MODE=2
		THEN DO;
			CREATE.50HZ.CLOCK=0;
			CREATE.BEAT.CLOCK=1;
		END;
		ELSE DO;
			CREATE.BEAT.CLOCK=0;
			CREATE.50HZ.CLOCK=1;
		END;
	END;
	ELSE DO;
		CREATE.50HZ.CLOCK=0;
		CREATE.BEAT.CLOCK=0;
	END;

END SET.CLOCK.CASE;

/* COMPUTE.NEXT.MIDI.LIMIT IS CALLED TO COMPUTE THE SEQUENCE TIME WHEN WE	*/
/* SHOULD EMIT OUR NEXT MIDI CLOCK BYTE.  IN OTHER WORDS, WHEN WE CONTINUE	*/
/* PLAYBACK, WE NOTE THE CURRENT SEQUENCER POSITION, PROJECT FORWARD			*/
/* FROM THAT POINT TO THE NEXT MIDI CLOCK BOUNDARY, AND COMPUTE THE			*/
/* SEQUENCER TIME OF THAT POSITION.														*/

/* IT'S ALL COMPLICATED BY THE FACT THAT MIDI SONG POINTER POINTS TO 		*/
/* EVERY SIXTH CLOCK!!																		*/

/* SO FOR OUR PURPOSES, WE COMPUTE THE TIME OF THE NEXT MULTIPLE-OF-SIX		*/
/* MIDI CLOCK.  THAT WAY WE CAN SEND OUT A SPP MESSAGE FOR THAT TIME,		*/
/* THEN START EMITTING CLOCKS AT THAT TIME, AND THE SLAVE SEQUENCER STARTS	*/
/* UP IN SYNC...																				*/

/*	SO:																							*/

/* DIVISIONS == NUMBER OF CLICK TICKS IN A MQN										*/
/* THERE ARE 24 MIDI CLOCK TICKS IN A MQN												*/
/* THERE ARE 6  MIDI CLOCK TICKS IN A SPP												*/
/* SO THERE ARE 4 SPP'S IN A MQN															*/

/* SO BASICALLY WE COMPUTE WHICH MQN WE ARE AT, MULTIPLY THAT BY 4 TO		*/
/* GET WHICH SPP GOES WITH IT.															*/

/* THE COMPUTED VALUE IS BOTH USED TO COMPUTE A MIDI SPP TO SEND OUT, AND	*/
/* TO IDENTIFY THE REAL TIME THAT WE NEXT SEND OUT A MIDI CLOCK BYTE			*/

COMPUTE.NEXT.MIDI.LIMIT: PROC (SEQ.TIME, LIMIT.TIME) PUBLIC SWAPABLE;
	DCL SEQ.TIME   ARRAY;
	DCL LIMIT.TIME ARRAY;
	DCL (MSB,LSB)  FIXED;
	DCL SPP        FIXED;          /* SONG POSITION POINTER 						*/

	MSB=SEQ.TIME(0);               /* COPY OF PASSED SEQUENCE TIME  			*/
	LSB=SEQ.TIME(1);

	IF  (MSB=0)                    /* CHECK FOR TIME BEFORE ZERO    			*/
	AND (LSB ILT ZERO.TIME)
	THEN LSB=ZERO.TIME;

	IF LSB ILT ZERO.TIME				 /* REMOVE ZERO.TIME OFFSET		 			*/
	THEN MSB=MSB-1;
	LSB=LSB-ZERO.TIME;

	LOAD  SHL(LSB,2);			  		  /* GET SEQ TIME MULTIPLIED BY 4 			*/
	ULOAD SHL(MSB,2) | SHR(LSB,14); /* IN D4-D5							 			*/
	DIV   DIVISIONS;					  /* DIVIDE BY DIVISIONS, YIELDS SPP		*/

	SPP = RES;							 /* YIELDS SPP EQUIV VALUE		 				*/

	IF REM<>0 THEN SPP=SPP+1;      /* ROUND UP TO NEXT SPP POSITION			*/

	LOAD  SPP;                     /* CONVERT THE ROUNDED SPP BACK TO SEQ TIME */
	MUL   DIVISIONS;					 /* MUL BY DIVISIONS								*/
	MSB=URES;							 /* YIELDS 4*SEQ TIME							*/
	LSB=RES;

	LSB = LSB + 3;                 /* ROUND BY 3 UP TO NEXT SEQ TIME			*/
	IF LSB ILT 3
	THEN MSB = MSB + 1;

	LSB = SHR(LSB,2)\SHL(MSB,14);	 /* THEN DIVIDE BY 4								*/
	MSB = SHR(MSB,2);

	LSB = LSB + ZERO.TIME;         /* RESTORE ZERO.TIME OFFSET 					*/
	IF LSB ILT ZERO.TIME
	THEN MSB = MSB + 1;

	LIMIT.TIME(0)=MSB;             /* COPY INTO RETURN ARGUMENT 				*/
	LIMIT.TIME(1)=LSB;
END COMPUTE.NEXT.MIDI.LIMIT;

COMPUTE.NEXT.CLOCK.LIMIT: PROC (SEQ.TIME,LIMIT.TIME) PUBLIC SWAPABLE; // COULD BE PRIVATE
	DCL SEQ.TIME   ARRAY;
	DCL LIMIT.TIME ARRAY;
	DCL (MSB,LSB)  FIXED;
	DCL SPP        FIXED;          /* SONG POSITION POINTER */
	DCL I          FIXED;

	I = SAMP.EXT.DIV;					 /* GET CRM FOR BEAT SYNC, 24 FOR MIDI SYNC */

	MSB=SEQ.TIME(0);               /* COPY OF PASSED SEQUENCE TIME */
	LSB=SEQ.TIME(1);

	IF  (MSB=0)                    /* REMOVE ZERO TIME OFFSET */
	AND (LSB ILT ZERO.TIME)
	THEN LSB=ZERO.TIME;

	IF LSB ILT ZERO.TIME
	THEN MSB=MSB-1;
	LSB=LSB-ZERO.TIME;

	/* ROUND UP TO THE NEAREST MIDI CLOCK */

	CALL COPY32(LOC(ADDR(MSB)),LOC(ADDR(BITMSB)));
	CALL ratio_multiply(I,DIVISIONS);

	/* MULTIPLY BACK UP TO SEQUENCER TIME */

	CALL ratio_multiply(DIVISIONS,I);

	MSB = BITMSB;
	LSB = BITLSB + ZERO.TIME;      /* RESTORE ZERO.TIME OFFSET */
	IF LSB ILT ZERO.TIME
	THEN MSB = MSB + 1;

	LIMIT.TIME(0)=MSB;             /* COPY INTO RETURN ARGUMENT */
	LIMIT.TIME(1)=LSB;

END COMPUTE.NEXT.CLOCK.LIMIT;

RESYNC.TIME.BASE: PROC PUBLIC SWAPABLE; /* RESET EXT CLOCK ACCUMULATOR FOR PROPER SYNC */
	DCL (MSB,LSB) FIXED;

	CALL SET.CLOCK.CASE;                 /* SET EXTERNAL CLOCK MODES        */

	IF PLAY=0 THEN DO;                   /* NOT PLAYING - INITIALIZE        */
		EXT.CLOCK.TOGGLE    =0;           /* INIT TOGGLE FOR 50 HZ CLOCK OUTPUT   */
		EXT.SPEED.ACCUM     =0;           /* INIT SPEED ACCUM FOR BEAT SYNC SPEED */
		EXT.CLOCK.ACCUM     =SAMP.CLICK.RATE-ZERO.TIME*SAMP.EXT.DIV; /* FOR BEAT OUT     */
		EXT.BEAT.TRIGGER    =0;           /* STATE OF BEAT SYNC OUTPUT            */
		CLOCK.ADVANCES      =0;           /* NO 50 HZ CLOCKS RECEIVED             */
		CLOCK.RECEIVED      =0;           /* NO BEAT SYNC CLOCK RECEIVED          */
		NUM.RECEIVED.CLOCKS =0;           /* RESET */
		CLOCK.LIMIT.LSB     =REAL.TIME.OF.NEXT.CLICK.LSB; /* STOP JUST BEFORE NEXT CLICK          */
		CLOCK.LIMIT.REM     =0;           /* NO REMAINDER AS OF YET               */

		CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),LOC(ADDR(MSB)));

		IF (MIDI.SYNC.OUT<>0) THEN DO;    /* SENDING MIDI SYNC */
			IF (MIDI.SYNC.IS.TC != 0)		 /* IF MIDI SYNC OUT IS MIDI TIME CODE, PREP FOR	*/
			{										 /* EMITTING QUARTER FRAME MESSAGES					*/
				PREP.FOR.MTC.OUTPUT(PLAY.TIME.MSB, PLAY.TIME.LSB, FALSE);
			}
			ELSE
			{
				CALL COMPUTE.NEXT.MIDI.LIMIT(LOC(ADDR(MSB)),LOC(ADDR(MIDI.LIMIT.MSB)));
				CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(MIDI.LIMIT.MSB)),
																LOC(ADDR(REAL.TIME.OF.MIDI.LIMIT.MSB)));
				CALL COMPUTE.REAL.MIDI.CLOCK.RATES(LOC(ADDR(MIDI.LIMIT.MSB)));
			}
		END;

		IF EXT.CLOCK.MODE>=2 THEN DO;     /* EXTERNAL BEAT/MIDI SYNC */
			CALL COMPUTE.NEXT.CLOCK.LIMIT(LOC(ADDR(MSB)),LOC(ADDR(CLOCK.LIMIT.MSB)));
			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(CLOCK.LIMIT.MSB)),
															LOC(ADDR(REAL.TIME.OF.CLOCK.LIMIT.MSB)));
			CALL COMPUTE.REAL.CLOCK.RATES(LOC(ADDR(CLOCK.LIMIT.MSB)));
		END;

		MIDI.LIMIT.REM      =0;           /* RESET MIDI REMAINDER */
		CLOCK.LIMIT.REM     =0;

		MISSED.BEAT.CLOCKS  =0;           /* NO MISSED CLOCKS */
		NUM.MIDI.CLOCKS     =0;           /* RESET MIDI CLOCK COUNTER */
		NUM.RECEIVED.CLOCKS =0;           /* RESET RECEIVED CLOCK COUNTER */

	END;

	ELSE DO;                             /* CAN NOT ACCURATELY CHANGE SYNC MODE WHILE PLAYING */
	END;
END RESYNC.TIME.BASE;


RESYNC.TO.MIDI: PROC PUBLIC SWAPABLE;
	DISABLE;
	NUM.RECEIVED.CLOCKS=NUM.RECEIVED.CLOCKS+MISSED.MIDI.CLOCKS;   /* SAVE FOR MAIN LOOP CALIBRATION */
	MISSED.MIDI.CLOCKS=0;
	ENABLE;
END RESYNC.TO.MIDI;


/* GOAL: JUSTIFY THE STARTING POINT OF A LOOP                      */
/* LOOP.SAMPLE HAS JUST BEEN CALLED.  LOOP.XXX'S ARE SET UP        */
/* ADVANCE/RETARD TIMES AND POINTERS TO REFLECT CORRECT LOOP START */

ADJUST.LOOP.PTRS: PROC PUBLIC SWAPABLE;    /* ADJUST LOOP POINTERS TO CORRESPOND TO LOOP.PLAY.TIME.MSB, LOOP.PLAY.TIME.LSB */
	/* hello? */
END ADJUST.LOOP.PTRS;

LOOP.JUSTIFY: PROC PUBLIC SWAPABLE;        /* PROCEDURE TO JUSTIFY A SAMPLED LOOP POINT */
	/* COMPUTE JUSTIFIED LOOP.SEQ.TIME.MSB, LOOP.SEQ.TIME.LSB */
	CALL ADJUST.LOOP.PTRS;
END LOOP.JUSTIFY;


/* $SUBTITLE  ROUTINES TO MERGE TRACK INTO NEXT EVENT QUEUE */


FORWARD.MERGE.INTO.EVENT.QUEUE:  PROC (PTR) PUBLIC; /* SORTS TRK INTO EVENT QUEUE IF MOVING FORWARD */
	DCL PTR         FIXED;    /* ABS POINTER TO TRACK HEAD */
	DCL (MSB,LSB)   FIXED;    /* HOLDS NEXT EVENT TIMES    */
	DCL (FPTR,RPTR) FIXED;    /* HOLDS FORWARD AND REVERSE LINK PTRS */

	/* NOTE: THIS ROUTINE SORTS IN ASCENDING ORDER USING     */
	/*       THE TRACK HEAD VARIABLES, THD.NMSB AND THD.NLSB */

	WRITE(MAM)=PTR;                   /* LOOK AT TRACK HEAD         */
	WRITE(MAL)=THD.NMSB;              /* LOOK AT NEXT EVENT TIME    */
	MSB=READ(MDI);                    /* THD.NMSB                   */
	LSB=READ(MD );                    /* THD.NLSB                   */

	WRITE(MAL)=THD.CUE.TRACK;              /* SEE IF THIS IS CUE TRK */
	IF READ(MD)<>0 THEN DO;                /* IF SO,  THEN QUE UP    */

		/* back up cue time by 1 second:                              */

		if tempo.map.ptr <> 0
		then call Map.Sequence.Time.To.Real.Time(loc(addr(msb)), loc(addr(msb)));

		IF  LSB ILT SAMP.SPEED THEN DO;     /* NOTE AT AN EARLIER     */
			IF MSB=0 THEN LSB = SAMP.SPEED;  /* TIME SO THE D.T.D HAS  */
			ELSE MSB=MSB-1;                  /* TIME TO DO IT'S THING  */
		END;
		LSB=LSB-SAMP.SPEED;

		if tempo.map.ptr <> 0
		then call Map.Real.Time.To.Sequence.Time(loc(addr(msb)), loc(addr(msb)));

		WRITE(MAM)=PTR;                /* RESTORE MAM POINTER        */

	END;

	WRITE(MAL)=THD.NEV.MSB;           /* SAVE QUE TIME FOR          */
	WRITE(MDI)=MSB;                   /* THIS TRACK                 */
	WRITE(MD )=LSB;

	/* PUT EVENT INTO PROPER POSITION IN QUEUE */

	IF NEXT.EVENT.QUEUE=0 THEN DO;    /* BLOCK GOES ON FRONT        */
		NEXT.EVENT.QUEUE=PTR-NAH.PTR;  /* SAVE AS RELATIVE PTR       */
		WRITE(MAL)=THD.NEVF;           /* ZERO OUT QUE POINTERS      */
		WRITE(MDI)=0;                  /* THD.NEVF                   */
		WRITE(MD )=0;                  /* THD.NEVR                   */
		NEXT.EVENT.MSB=MSB;            /* SAVE TIME IN MEMORY        */
		NEXT.EVENT.LSB=LSB;
		RETURN;
	END;

	WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE; /* START AT FRONT OF QUEUE */

	NEXT.TRACK:

	WRITE(MAL)=THD.NEVF;              /* LOOK UP FOR & REV PTRS FOR TRK */
	FPTR=READ(MDI);                   /* THD.NEVF                   */
	RPTR=READ(MD );                   /* THD.NEVR                   */

	WRITE(MAL)=THD.NEV.MSB;           /* COMPARE MSB,LSB WITH THIS TRK */

	IF  ((MSB IGT READ(MD )))         /* OUR NEXT EVENT IS LATER    */
	OR  ((MSB  =  READ(MDI))          /* THAN THE NEXT EVENT FOR    */
	AND  (LSB IGE READ(MD )))         /* THIS TRACK                 */
	THEN DO;                          /* STEP TO NEXT TRK IN QUEUE  */

		IF FPTR<>0                     /* HAVE NOT HIT END OF QUEUE  */
		THEN DO;                       /* APPEND OUR TRACK HERE      */
			WRITE(MAM)=NAH.PTR+FPTR;    /* CONVERT TO ABS. PTR        */
			GOTO NEXT.TRACK;            /* COMPARE OUR NEXT TIME WITH NEXT TRK */
		END;

		ELSE DO;                       /* PUT BLOCK ON END OF LIST      */
			RPTR=READ(MAM)-NAH.PTR;     /* COMPUTE OUR REVERSE POINTER   */
			WRITE(MAL)=THD.NEVF;        /* STORE NEW FORWARD PTR         */
			WRITE(MD )=PTR-NAH.PTR;     /* THD.NEVF NOW POINTS TO US     */
			WRITE(MAM)=PTR;             /* NOW SET LINK VARS ON OUR TRK  */
			WRITE(MAL)=THD.NEVF;
			WRITE(MDI)=0;               /* NO FORWARD PTR -- WE ARE LAST */
			WRITE(MD )=RPTR;            /* THD.NEVR POINTS TO PREV TRK   */
			RETURN;
		END;

	END;

	/* $PAGE */


	/* INSERT BLOCK INTO QUE */
	/* AT THIS POINT         */

	WRITE(MAL)=THD.NEVR;           /* THD.NEVR FOR TRK NOW     */
	WRITE(MD)=PTR-NAH.PTR;         /* POINTS BACK TO US        */

	IF RPTR<>0                     /* WE ARE NOT FIRST IN LIST */
	THEN DO;                       /* DO NORMAL INSERT         */
		FPTR=READ(MAM)-NAH.PTR;     /* GET REL PTR TO NEXT TRK  */
		WRITE(MAM)=PTR;             /* SET LINK VARS ON OUR TRK */
		WRITE(MAL)=THD.NEVF;
		WRITE(MDI)=FPTR;            /* THD.NEVF PTS TO NEXT     */
		WRITE(MD )=RPTR;            /* THD.NEVR PTS TO PREV     */
		WRITE(MAM)=NAH.PTR+RPTR;    /* POINT TO PREV TRK        */
		WRITE(MAL)=THD.NEVF;
		WRITE(MD )=PTR-NAH.PTR;     /* THD.NEVF PTS TO US       */
	END;
	ELSE DO;                          /* INSERT AT HEAD OF LIST   */
		WRITE(MAM)=PTR;                /* SET LINK VARS ON OUR TRK */
		WRITE(MAL)=THD.NEVF;
		WRITE(MDI)=NEXT.EVENT.QUEUE;   /* NEW THD.NEVF            */
		WRITE(MD )=0;                  /* THD.NEVR IS NULL         */
		NEXT.EVENT.QUEUE=PTR-NAH.PTR;  /* AND LAST OF ALL FIX LIST HEAD PTR */
		NEXT.EVENT.MSB=MSB;            /* SAVE TIME IN MEMORY        */
		NEXT.EVENT.LSB=LSB;
	END;

END FORWARD.MERGE.INTO.EVENT.QUEUE;


/* $PAGE */


REVERSE.MERGE.INTO.EVENT.QUEUE:  PROC (PTR) SWAPABLE; /* SORTS TRK INTO EVENT QUEUE IF MOVING BACKWARDS */
	DCL PTR         FIXED;    /* ABS POINTER TO TRACK HEAD */
	DCL (MSB,LSB)   FIXED;    /* HOLDS NEXT EVENT TIMES    */
	DCL (FPTR,RPTR) FIXED;    /* HOLDS FORWARD AND REVERSE LINK PTRS */

	/* NOTE: THIS ROUTINE SORTS IN DESCENDING ORDER USING    */
	/*       THE TRACK HEAD VARIABLES, THD.LMSB AND THD.LLSB */

	WRITE(MAM)=PTR;                   /* LOOK AT TRACK HEAD         */
	WRITE(MAL)=THD.LMSB;              /* LOOK AT LAST EVENT TIME    */
	MSB=READ(MDI);                    /* THD.LMSB                   */
	LSB=READ(MD );                    /* THD.LLSB                   */

	WRITE(MAL)=THD.NEV.MSB;           /* SAVE QUE TIME FOR          */
	WRITE(MDI)=MSB;                   /* THIS TRACK                 */
	WRITE(MD )=LSB;

	/* PUT EVENT INTO PROPER POSITION IN QUEUE */

	IF NEXT.EVENT.QUEUE=0 THEN DO;    /* BLOCK GOES ON FRONT        */
		NEXT.EVENT.QUEUE=PTR-NAH.PTR;  /* SAVE AS RELATIVE PTR       */
		WRITE(MAL)=THD.NEVF;           /* ZERO OUT QUE POINTERS      */
		WRITE(MDI)=0;                  /* THD.NEVF                   */
		WRITE(MD )=0;                  /* THD.NEVR                   */
		NEXT.EVENT.MSB=MSB;            /* SAVE TIME IN MEMORY        */
		NEXT.EVENT.LSB=LSB;
		RETURN;
	END;

	WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE; /* START AT FRONT OF QUEUE */

	NEXT.TRACK:

	WRITE(MAL)=THD.NEVF;              /* LOOK UP FOR & REV PTRS FOR TRK */
	FPTR=READ(MDI);                   /* THD.NEVF                   */
	RPTR=READ(MD );                   /* THD.NEVR                   */

	WRITE(MAL)=THD.NEV.MSB;           /* COMPARE MSB,LSB WITH THIS TRK */

	IF  ((MSB ILT READ(MD )))         /* OUR NEXT EVENT IS EARLIER  */
	OR  ((MSB  =  READ(MDI))          /* THAN THE NEXT EVENT FOR    */
	AND  (LSB ILE READ(MD )))         /* THIS TRACK                 */
	THEN DO;                          /* STEP TO NEXT TRK IN QUEUE  */

		IF FPTR<>0                     /* HAVE NOT HIT END OF QUEUE  */
		THEN DO;                       /* APPEND OUR TRACK HERE      */
			WRITE(MAM)=NAH.PTR+FPTR;    /* CONVERT TO ABS. PTR        */
			GOTO NEXT.TRACK;            /* COMPARE OUR NEXT TIME WITH NEXT TRK */
		END;

		ELSE DO;                       /* PUT BLOCK ON END OF LIST      */
			RPTR=READ(MAM)-NAH.PTR;     /* COMPUTE OUR REVERSE POINTER   */
			WRITE(MAL)=THD.NEVF;        /* STORE NEW FORWARD PTR         */
			WRITE(MD )=PTR-NAH.PTR;     /* THD.NEVF NOW POINTS TO US     */
			WRITE(MAM)=PTR;             /* NOW SET LINK VARS ON OUR TRK  */
			WRITE(MAL)=THD.NEVF;
			WRITE(MDI)=0;               /* NO FORWARD PTR -- WE ARE LAST */
			WRITE(MD )=RPTR;            /* THD.NEVR POINTS TO PREV TRK   */
			RETURN;
		END;

	END;

	/* $PAGE */


	/* INSERT BLOCK INTO QUE */
	/* AT THIS POINT         */

	WRITE(MAL)=THD.NEVR;           /* THD.NEVR FOR TRK NOW     */
	WRITE(MD)=PTR-NAH.PTR;         /* POINTS BACK TO US        */

	IF RPTR<>0                     /* WE ARE NOT FIRST IN LIST */
	THEN DO;                       /* DO NORMAL INSERT         */
		FPTR=READ(MAM)-NAH.PTR;     /* GET REL PTR TO NEXT TRK  */
		WRITE(MAM)=PTR;             /* SET LINK VARS ON OUR TRK */
		WRITE(MAL)=THD.NEVF;
		WRITE(MDI)=FPTR;            /* THD.NEVF PTS TO NEXT     */
		WRITE(MD )=RPTR;            /* THD.NEVR PTS TO PREV     */
		WRITE(MAM)=NAH.PTR+RPTR;    /* POINT TO PREV TRK        */
		WRITE(MAL)=THD.NEVF;
		WRITE(MD )=PTR-NAH.PTR;     /* THD.NEVF PTS TO US       */
	END;
	ELSE DO;                          /* INSERT AT HEAD OF LIST   */
		WRITE(MAM)=PTR;                /* SET LINK VARS ON OUR TRK */
		WRITE(MAL)=THD.NEVF;
		WRITE(MDI)=NEXT.EVENT.QUEUE;   /* NEW THD.NEVF            */
		WRITE(MD )=0;                  /* THD.NEVR IS NULL         */
		NEXT.EVENT.QUEUE=PTR-NAH.PTR;  /* AND LAST OF ALL FIX LIST HEAD PTR */
		NEXT.EVENT.MSB=MSB;            /* SAVE TIME IN MEMORY        */
		NEXT.EVENT.LSB=LSB;
	END;

END REVERSE.MERGE.INTO.EVENT.QUEUE;


REBUILD.EVENT.QUEUE:  PROC PUBLIC SWAPABLE; /* RECREATES EVENT QUEUE AFTER OVERALL LOOP, DIRECTION CHANGE */
	DCL I FIXED;

	/**** ASSUMES ALL TRK HEADERS ARE CORRECT AND UP TO DATE ****/

	NEXT.EVENT.QUEUE=0;     /* CLEAR OUT PREVIOUS LIST */

	DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1;

		WRITE(MAM)=TRK.HEAD; /* LOOK UP PTR TO THIS */
		WRITE(MAL)=I;        /* TRK HEADER          */

		IF READ(MD)<>0       /* TRACK HEADER EXISTS */
		THEN DO;

			WRITE(MAM)=READ(MD); /* POINT TO TRACK HEADER */

			IF (MOVE=0)          /* EITHER NOT FAST MOVE      */
			OR (MOVE.SPEED>0)    /* OR GOING FORWARDS         */
			THEN DO;

				WRITE(MAL)=THD.ANY.FOR; /* SEE IF MORE NOTES */

				IF READ(MD)<>0
				THEN CALL FORWARD.MERGE.INTO.EVENT.QUEUE(READ(MAM));

			END;
			ELSE DO;

				WRITE(MAL)=THD.ANY.REV; /* SEE IF ANY MORE NOTES */

				IF READ(MD)<>0
				THEN CALL REVERSE.MERGE.INTO.EVENT.QUEUE(READ(MAM));

			END;

		END;
	END;
	
	// Set up next.seq.event
	if (MOVE=0 && NEXT.EVENT.QUEUE<>0)
	{
		if tempo.map.ptr <> 0
		{
			dcl (msb, lsb) fixed;
			call Map.Sequence.Time.To.Real.Time(loc(addr(NEXT.EVENT.MSB)), loc(addr(msb)));
			next.seq.event = lsb - prescan;
		}
		
		else
			next.seq.event = NEXT.EVENT.LSB - prescan;
	}
	
	else
		next.seq.event = play.time.lsb + 5000;

END REBUILD.EVENT.QUEUE;


/* $SUBTITLE  ROUTINE TO DO QUICK COPY OF PLAY INFO FROM TRK HEAD TO TEMP BUF */


LOAD.PLAY.INFO:  PROC PUBLIC; /* DOES FAST COPY OF PLAY INFO FROM TRK HEAD TO COPY.BUF */
	DCL (I,WRD)   FIXED;

	/* NOTE: ROUTINE EXPECTS MAM/MAL TO BE SET UP BEFORE CALLING */

	WRD=READ(MAL);                  /* SAVE STARTING MAL PTR     */
	WRITE("313")=ADDR(COPY.BUF(0)); /* SET IMEM PTR TO TEMP ARRAY      */

	IF (READ(MAL)=THD.LP.NMSB)      /* LOADING OVERALL LOOP INFO       */
	OR (READ(MAL)=THD.NMSB)         /* OR LOADING CURRENT PLAY INFO    */
	THEN DO;                        /* SAMPLE EVENT TIME INFO TOO      */
		WRITE("373")=READ(MDI);      /* COPY NMSB TO IMEM               */
		WRITE("373")=READ(MDI);      /* COPY NLSB TO IMEM               */
		WRITE("373")=READ(MDI);      /* COPY LMSB TO IMEM               */
		WRITE("373")=READ(MDI);      /* COPY LLSB TO IMEM               */
	END;

	IF (INC.POLY<>0)                /* IF WE ARE SURE IT IS       */
	OR (MODC    <>0)                /* OKAY TO USE THE REPEAT     */
	THEN DO;                        /* INSTRUCTION                */
		RPC 20;                      /* 20 WRDS OF PLAY INFO       */
		WRITE("373")=READ(MDI);      /* COPY XMEM TO IMEM          */
	END;
	ELSE DO;                        /* USE NORMAL MODEL B CODE      */
		DO I=1 TO 5;                 /* 20 WRDS OF PLAY INFO         */
			WRITE("373")=READ(MDI);   /* COPY XMEM TO IMEM            */
			WRITE("373")=READ(MDI);   /* COPY XMEM TO IMEM            */
			WRITE("373")=READ(MDI);   /* COPY XMEM TO IMEM            */
			WRITE("373")=READ(MDI);   /* COPY XMEM TO IMEM            */
		END;
	END;

	IF WRD=THD.LP.NMSB              /* LOADING OVERALL LOOP INFO       */
	THEN DO;                        /* SAVE THD.LP.ILPCTR              */
		WRITE(MAL)=THD.LP.ILPCTR;
		WRITE("373")=READ(MDI);      /* COPY THD.LP.ILPCTR              */
		WRITE("373")=READ(MDI);      /* COPY THD.LP.ANY.FOR             */
		WRITE("373")=READ(MD );      /* COPY THD.LP.ANY.REV             */
		WRITE(MAL)=THD.LP.ILS.SCANNED;
		WRITE("353")=READ(MD);       /* COPY THD.LP.ILS.SCANNED         */
	END;
	ELSE IF WRD=THD.NMSB            /* LOADING CURRENT PLAY INFO       */
	THEN DO;                        /* SAVE THD.ILPCTR                 */
		WRITE(MAL)=THD.ILPCTR;
		WRITE("373")=READ(MDI);      /* COPY THD.ILPCTR                 */
		WRITE("373")=READ(MDI);      /* COPY THD.ANY.FOR                */
		WRITE("373")=READ(MD );      /* COPY THD.ANY.REV                */
		WRITE(MAL)=THD.ILS.SCANNED;
		WRITE("353")=READ(MD);       /* COPY THD.ILS.SCANNED         */
	END;

END LOAD.PLAY.INFO;


/* $SUBTITLE  ROUTINE TO SAMPLE INFO FOR INDEPENDENT LOOP */


SAMPLE.INFO.FOR.LOOP:  PROC (SEC,WRD) PUBLIC; /* SAVE CUR PLAY INFO IN LOOP VARS */
	DCL (SEC,WRD) FIXED; /* ABS PTR TO LOOP INFO IN TRK HEAD TO SAMPLE */
	DCL (I,J)     FIXED;

	/* FIRST, SAMPLE CURRENT PLAY VARIABLES INTO TEMP ARRAY (I.E., SAVE    */
	/* COPY OF VARS THD.NMSB, THD.NLSB, THD.LMSB, THD.LLSB, THD.WRD,       */
	/* THD.SEC, THD.CXPOS, THD.CTIMB, THD.CLPITCH, THD.CTBITS, THD.CG.VAL, */
	/* THD.CPROGRAM AND THE 8 WORDS OF THD.RTES IN COPY.BUF).              */

	WRITE(MAM)=SEC;                 /* POINT AT TRACK HEADER             */

	IF WRD=THD.LP.NMSB              /* SAMPLING FOR OVERALL LOOP         */
	THEN WRITE(MAL)=THD.NMSB;       /* GET EVENT TIMES, LOOP COUNTER TOO */
	ELSE WRITE(MAL)=THD.WRD;        /* JUST GET NORMAL STUFF             */

	CALL LOAD.PLAY.INFO;            /* READ INFO INTO 'COPY.BUF'         */

	WRITE(MAL)=WRD;                 /* SET XMEM PTR TO ILP PLAY PTRS */
	WRITE("313")=ADDR(COPY.BUF(0)); /* SET IMEM PTR TO TEMP ARRAY */

	IF WRD=THD.LP.NMSB              /* SAMPLING INFO FOR OVERALL LOOP */
	THEN DO;                        /* SAVE EVENT TIMES IN OVERALL LOOP VARS */
		WRITE(MDI)=READ("373");      /* COPY IMEM TO THD.LP.NMSB */
		WRITE(MDI)=READ("373");      /* COPY IMEM TO THD.LP.NLSB */
		WRITE(MDI)=READ("373");      /* COPY IMEM TO THD.LP.LMSB */
		WRITE(MDI)=READ("373");      /* COPY IMEM TO THD.LP.LLSB */
	END;

	IF (INC.POLY<>0)                /* IF WE ARE SURE IT IS       */
	OR (MODC    <>0)                /* OKAY TO USE THE REPEAT     */
	THEN DO;                        /* INSTRUCTION                */
		RPC 20;                      /* 20 WRDS OF PLAY INFO       */
		WRITE(MDI)=READ("373");      /* COPY IMEM TO XMEM          */
	END;
	ELSE DO;                        /* USE NORMAL MODEL B CODE      */
		DO I=1 TO 5;                 /* 20 WRDS OF PLAY INFO         */
			WRITE(MDI)=READ("373");   /* COPY IMEM TO XMEM            */
			WRITE(MDI)=READ("373");   /* COPY IMEM TO XMEM            */
			WRITE(MDI)=READ("373");   /* COPY IMEM TO XMEM            */
			WRITE(MDI)=READ("373");   /* COPY IMEM TO XMEM            */
		END;
	END;

	IF WRD=THD.LP.NMSB              /* WE ARE SAMPLING FOR OVERALL LOOP */
	THEN DO;
		WRITE(MAL)=THD.LP.ILPCTR;
		WRITE(MDI)=READ("373");      /* STORE THD.ILPCTR  INTO THD.LP.ILPCTR  */
		WRITE(MDI)=READ("373");      /* STORE THD.ANY.FOR INTO THD.LP.ANY.FOR */
		WRITE(MD )=READ("373");      /* STORE THD.ANY.REV INTO THD.LP.ANY.REV */
		WRITE(MAL)=THD.LP.ILS.SCANNED;
		WRITE(MD )=READ("353");      /* STORE THD.ILS.SCANNED INTO THD.LP.ILS.SCANNED */
	END;

	IF WRD=THD.LP.NMSB              /* WE ARE SAMPLING FOR OVERALL LOOP */
	THEN DO;
		WRITE(MAM)=SEC;              /* SAMPLE MIDI RTES */
		WRITE(MAL)=THD.TRK;
		J=READ(MD);

		WRITE(MAM)=MIDI.TRACK.RTES+J;

		DO I=0 TO 127;
			WRITE(MAL)=I;
			J=READ(MD);
			WRITE(MAL)=128+I;
			WRITE(MD)=J;
		END;
	END;

	WRITE(MAM)=SEC;                        /* NOW SAMPLE THE CURRENT SUSTAIN STATE */
	WRITE(MAL)=THD.SUSTAIN;
	I=READ(MD)&B.CURRENT.SUSTAIN;          /* LOOKUP CURRENT SUSTAIN STATE */

	IF WRD=THD.LP.NMSB                     /* COMPUTE WHICH BIT TO STORE SAMPLED STATE IN */
	THEN J=B.LOOP.SUSTAIN;                 /* OVERALL LOOP */
	ELSE IF WRD=THD.ILS.WRD
	THEN J=B.ILS.SUSTAIN;                  /* INDEPENDENT LOOP START */
	ELSE IF WRD=THD.ILE.WRD
	THEN J=B.ILE.SUSTAIN;                  /* INDEPENDENT LOOP END */

	IF I=0                                 /* CURRENT STATE IS OFF */
	THEN WRITE(MD)=(READ(MD)&(NOT J));     /* CLEAR BIT */
	ELSE WRITE(MD)=(READ(MD)\J);           /* SET BIT */

END SAMPLE.INFO.FOR.LOOP;


/* $SUBTITLE  ROUTINE TO SAMPLE CURRENT PLAY INFO FOR OVERALL LOOPS */


DCL LOOP.TIME.IS.AT.0 FIXED PUBLIC; /* INDICATES PRESET LOOP TIMES ON FIRST NOTE RECORDED */

LOOP.SAMPLE: PROC PUBLIC SWAPABLE; /* TAKE SNAP SHOT OF CURRENT SEQUENCER POINTERS */
	DCL I FIXED;

	DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1; /* SAMPLE PLAY INFO FOR EACH TRACK */
		WRITE(MAM)=TRK.HEAD;       /* LOOK UP ABS PTR TO TRK HEAD */
		WRITE(MAL)=I;
		IF READ(MD)<>0             /* TRACK HEADER EXISTS */
		THEN DO;                   /* OK TO SAMPLE CURRENT PLAY INFO */
			CALL SAMPLE.INFO.FOR.LOOP(READ(MD),THD.LP.NMSB);
		END;
	END;

	/* SAMPLE THE FOUR KEY GLOBAL */
	/* SEQUENCER STATE VARS       */

	LOOP.PLAY.TIME.MSB=SAMPLED.ACTUAL.PLAY.TIME.MSB;
	LOOP.PLAY.TIME.LSB=SAMPLED.ACTUAL.PLAY.TIME.LSB;
	LOOP.PLAY.TIME.ACU=SAMPLED.ACTUAL.PLAY.TIME.ACU;
	LOOP.NEXT.CLICK   =SAMPLED.ACTUAL.NEXT.CLICK;
	LOOP.BEAT.NUMBER  =SAMPLED.ACTUAL.BEAT.NUMBER;
	LOOP.TRIGGER.CLICK=TRIGGER.CLICK;
	LOOP.LAST.CLICK   =LOOP.NEXT.CLICK-EST.RATE;
	LOOP.TIME.IS.AT.0 =0;         /* ASSUME LOOP START IS NOT AT TIME 0 */

	call Map.Real.Time.To.Sequence.Time(loc(addr(loop.play.time.msb)),
													loc(addr(loop.seq.time.msb )));

	call Compute.Loop.Next.Click;       /* loop.seq.time must be setup for this call */

END LOOP.SAMPLE;


/* $PAGE - KBDPHOTO */

/* THIS ROUTINE IS USED TO SET THE LOOP STARTING TIME TO THE EXACT   */
/* TIME OF A PARTICULAR NOTE                                         */

/* KBD.PHOTO IS CALLED TO STORE THE PASSED SEQUENCER TIME AS A LOOP  */
/* STARTING POINT.  THE CURRENT SEQUENCER TIME BASE IS SAMPLED INTO  */
/* THE LOOP.XXX VARIABLES.  THE TIMES ARE THEN ADJUSTED BASED ON THE */
/* AMOUNT WE ARE EARLY OR LATE.                                      */

/* UNLIKE THE SIMILAR ROUTINE LOOP.JUSTIFY, HERE WE DO NOT HAVE TO   */
/* CHANGE ANY SEQUENCER POINTERS.  SINCE THIS IS CALLED WHEN WE      */
/* ARE SCANNING A NOTE FROM THE SEQUENCER, IF WE ARE LATE, THEN      */
/* WE HAVE NOT PLAYED THE NOTES ON TIME ANYWAYS.                     */

/* WHEN CALLED, THE PASSED MSB,LSB MUST BE FAIRLY CLOSE TO           */
/* THE CURRENT SEQUENCER TIME.                                       */

DCL DISPLAY.PAR PROC;

KBD.PHOTO:PROC (MSB,LSB) PUBLIC SWAPABLE;  /* PASS START TIME WE DESIRE FOR LOOP START */
	DCL (MSB,LSB)    FIXED;

	CALL LOOP.SAMPLE;                   /* SET UP LOOP START POINTERS AND LOOP.TIMES */

	IF CONTINUE.BUTTON.ACTIVE<>0        /* STORE OUT IN EXTERNAL MEMORY */
	THEN CALL SET.LOOP.START.TIME(MSB,LSB);

	CONTINUE.BUTTON.ACTIVE=0;           /* RESET FLAG      */

	LOOP.SEQ.TIME.MSB=MSB;              /* GO TO THIS TIME HOWEVER */
	LOOP.SEQ.TIME.LSB=LSB;

	call Map.Sequence.Time.To.Real.Time(loc(addr(loop.seq.time.msb )),
													loc(addr(loop.play.time.msb)));

	call Compute.Loop.Next.Click;       /* loop.seq.time must be setup for this call */

	/*	************************************ B E G I N   D E L E T I O N ************************************	*\
	IF LOOP.PLAY.TIME.LSB>LOOP.NEXT.CLICK
	THEN DO;										\* ADVANCE "LOOP.NEXT.CLICK" TO NEXT CLICK *\
		IF CLICK.TRACK.MODE igt 3
		THEN LOOP.NEXT.CLICK = LOOP.NEXT.CLICK+EST.RATE;
		ELSE DO;
			LOOP.NEXT.CLICK=LOOP.NEXT.CLICK+SAMP.CLICK.RATE;
			\* ADJUST BEAT # IF INT BEAT COUNTER *\
			IF CLICK.TRACK.MODE<>3 THEN LOOP.BEAT.NUMBER = LOOP.BEAT.NUMBER+1;
		END;
	END;

	ELSE DO;										\* BACK UP "LOOP.NEXT.CLICK" TO PRIOR CLICK *\
		IF CLICK.TRACK.MODE igt 3
		THEN DO;
			IF LOOP.PLAY.TIME.LSB<=(LOOP.NEXT.CLICK-EST.RATE)
			THEN LOOP.NEXT.CLICK=LOOP.NEXT.CLICK-EST.RATE;
		END;
		ELSE DO;
			IF LOOP.PLAY.TIME.LSB<=(LOOP.NEXT.CLICK-SAMP.CLICK.RATE)
			THEN DO;
				LOOP.NEXT.CLICK=LOOP.NEXT.CLICK-SAMP.CLICK.RATE;
				IF CLICK.TRACK.MODE<>3 THEN DO;	\* ADJUST BEAT # IF INT BEAT COUNTER *\
					IF LOOP.BEAT.NUMBER<>0 THEN LOOP.BEAT.NUMBER=LOOP.BEAT.NUMBER-1;
				END;
			END;
		END;
	END;
	\*	************************************** E N D   D E L E T I O N **************************************	*/
	/*	**********************  Replaced the above with the following - TY 1998/07/08  **********************	*/
	IF CLICK.TRACK.MODE igt 3
	{
		/* ADVANCE "LOOP.NEXT.CLICK" TO NEXT CLICK IF NECESSARY */
		IF (LOOP.PLAY.TIME.LSB>LOOP.NEXT.CLICK) THEN LOOP.NEXT.CLICK=LOOP.NEXT.CLICK+EST.RATE;
		/* BACKUP "LOOP.NEXT.CLICK" TO PRIOR CLICK IF NECESSARY */
		ELSE IF (LOOP.PLAY.TIME.LSB<=(LOOP.NEXT.CLICK-EST.RATE)) THEN LOOP.NEXT.CLICK=LOOP.NEXT.CLICK-EST.RATE;
	}
END KBD.PHOTO;

/* $SUBTITLE  ROUTINE TO DO LOOP BACK AT BOUNDARY OF INDEP. OR OVERALL LOOPS */


HANDLE.LOOP.JUMP:  PROC (SEC,WRD) PUBLIC; /* HANDLES LOOP BACK AT LOOP BOUNDARIES */
	DCL SEC         FIXED; /* ABS PTR TO TRACK HEAD TO LOOP ON */
	DCL WRD         FIXED; /* PTR TO BLOCK OF LOOP INFO TO RESET CURRENT PLAY INFO FROM */
	DCL CALL.COMPUTE.ARLIST FIXED; /* SET TO 1 IF NEED TO RECONSTRUCT ARLIST */
	DCL (UPDATES,I) FIXED; /* LOCAL COPY OF RTE UPDATES TO PERFORM   */
	DCL (MSB,LSB)   FIXED;
	DCL J           FIXED;
	DCL LOOP.SUS    FIXED; /* HOLDS NEW SUSTAIN STATE AFTER LOOP JUMP */

	/* 1A. IF WE ARE MOVING FORWARD, THEN WE MUST HAVE HIT THE END OF     */
	/*     THE INDEPENDENT LOOP.  IN THAT CASE, WE WANT TO SAMPLE THE     */
	/*     CURRENT PLAY INFO INTO THE ILP END VARS, SO WE WILL BE ABLE TO */
	/*     DO THE REWIND CASE CORRECTLY.  THEN WE NEED TO INCREMENT THE   */
	/*     LOOP CTR BY ONE.                                               */
	/* 1B. IF WE ARE MOVING BACKWARDS, THEN WE MUST HAVE HIT THE START    */
	/*     OF THE INDEPENDENT LOOP.  IN THAT CASE, WE NEED TO LOOK AT THE */
	/*     CURRENT VALUE OF THE ILP COUNTER.  IF IT IS ZERO, THEN WE HAVE */
	/*     UNWOUND THE LOOP ALL THE WAY BACK TO THE BEGINNING.  WE SIMPLY */
	/*     RETURN AND LET THE NORMAL REWIND LOGIC CONTINUE.  IF THE LOOP  */
	/*     CTR IS NON-ZERO, THEN WE NEED TO DECREMENT IT BY ONE.          */
	/* 1C. IF DOING JUMP BACK FOR AN OVERALL LOOP, WE NEED TO RESET       */
	/*     THD.ILPCTR BACK TO THE VALUE SAVED IN THD.LP.ILPCTR.           */

	/* Create a "new notes" event whenever we jump over an independent    */
	/* loop.  This makes the screen software redraw the notes at the      */
	/* new time.  This is allows the screen software to "approximately"   */
	/* un-wrap the independent loop.  Give this event only to the ABLE    */
	/* screens, since it will be handled other ways over the protocol.    */

	NEW.ABLE.SEQ.INFO = NEW.ABLE.SEQ.INFO \ 4; /* NEW NOTES INFO IN SEQUENCER       */

	IF WRD=THD.ILS.WRD               /* JUMPING BACK TO ILP START (MOVING FORWARD) */
	THEN DO;

		WRITE(MAM)=SEC;               /* POINT AT TRK HEADER */

		WRITE(MAL)=THD.ILS.SCANNED;   /* SEE IF ILS RECORD HAS BEEN SCANNED */
		IF READ(MD)=0 THEN RETURN;    /* IF NOT THEN DON'T LOOP BACK        */

		WRITE(MAL)=THD.ILS.WRD;       /* CHECK FOR OUT OF ORDER OR TRASHED LOOP INFO */
		IF (READ(MDI)\READ(MD))=0     /* PLAY PTRS FOR ILP START ARE UNDEFINED */
		THEN RETURN;                  /* IGNORE LOOP - ASSUME THIS MEANS LOOP RECORDS MESSED UP */

		WRITE(MAL)=THD.NMSB;          /* LOOK UP CURRENT TIME   */
		MSB=READ(MDI); LSB=READ(MD);  /* LOOP START             */

		WRITE(MAL)=THD.ILS.TIME.MSB;  /* LOOK UP TIME OF LAST   */
		IF  (MSB=READ(MDI))           /* SEE IF LAST LOOP WAS   */
		AND (LSB=READ(MD ))           /* DONE AT THIS TIME      */
		THEN RETURN;                  /* MUST BE 0 LENGTH LOOP  */

		WRITE(MAL)=THD.ILS.TIME.MSB;  /* SAVE TIME OF THIS LOOP */
		WRITE(MDI)=MSB; WRITE(MD)=LSB;

		CALL SAMPLE.INFO.FOR.LOOP(SEC,THD.ILE.WRD); /* SAMPLE CUR PLAY INFO INTO ILP END VARS */

		WRITE(MAM)=SEC;               /* POINT AT TRK HEADER */
		WRITE(MAL)=THD.ILPCTR;        /* GET ILP COUNTER     */
		WRITE(MD )=READ(MD)+1;        /* AND INCREMENT IT    */

		WRITE(MAL)=THD.SUSTAIN;       /* GET SUSTAIN STATE AT INDEPENDENT LOOP START */
		LOOP.SUS=READ(MD)&B.ILS.SUSTAIN;

	END;
	ELSE IF WRD=THD.ILE.WRD          /* JUMPING BACK TO ILP END (MOVING BACKWARDS) */
	THEN DO;

		WRITE(MAM)=SEC;               /* POINT AT TRK HEADER      */

		WRITE(MAL)=THD.ILS.TIME.MSB;  /* RESET ILS TIME TO ZERO   */
		WRITE(MDI)=0; WRITE(MD)=0;    /* DURING REWIND JUMP BACKS */

		WRITE(MAL)=THD.ILPCTR;        /* GET ILP COUNTER     */

		IF READ(MD)=0 THEN DO;        /* HAVE COMPLETELY UNWOUND ILP */
			WRITE(MAL)=THD.ILS.SCANNED;
			WRITE(MD )=0;              /* RESET FLAG */
			RETURN;                    /* DO NOTHING IF DONE REWINDING LOOP */
		END;

		WRITE(MD)=READ(MD)-1;         /* OTHERWISE DECREMENT LOOP COUNTER */

		WRITE(MAL)=THD.SUSTAIN;       /* GET SUSTAIN STATE AT INDEPENDENT LOOP END */
		LOOP.SUS=READ(MD)&B.ILE.SUSTAIN;

	END;
	ELSE DO;                         /* THIS IS AN OVERALL LOOP JUMP BACK */

		WRITE(MAM)=SEC;               /* POINT AT TRK HEADER      */
		WRITE(MAL)=THD.LP.ILPCTR;     /* GET LOOPED ILP COUNTER   */
		WRITE("300")=READ(MDI);       /* SAVE THD.LP.ILPCTR       */
		WRITE("301")=READ(MDI);       /* SAVE THD.LP.ANY.FOR      */
		WRITE("302")=READ(MD );       /* SAVE THD.LP.ANY.REV      */
		WRITE(MAL)=THD.LP.ILS.SCANNED; /* GET LOOPED ILS SCANNED FLAG */
		WRITE("303")=READ(MD);        /* SAVE IN REG              */

		WRITE(MAL)=THD.ILPCTR;        /* POINT TO CURRENT ILP CTR */
		WRITE(MDI)=READ("300");       /* RESET ILP CTR TO OVERALL LP VAL */
		WRITE(MDI)=READ("301");       /* RESET THD.ANY.FOR        */
		WRITE(MD )=READ("302");       /* RESET THD.ANY.REV        */
		WRITE(MAL)=THD.ILS.SCANNED;   /* RESET ILS SCANNED FLAG   */
		WRITE(MD )=READ("303");       /* TO LOOPED VALUE          */

		WRITE(MAL)=THD.ILS.TIME.MSB;  /* RESET TIME OF LAST ILS START */
		WRITE(MDI)=0;                 /* ON ANY OVERALL LOOP          */
		WRITE(MD )=0;

		/* CHECK ALL MIDI RTES AT LOOP START */

		WRITE(MAL)=THD.TRK;
		J=READ(MD);

		WRITE(MAM)=MIDI.TRACK.RTES+J;

		DO I=0 TO 127;
			WRITE(MAL)=128+I;
			J=READ(MD);
			WRITE(MAL)=I;
			WRITE(MD)=J;
		END;

		WRITE(MAM)=SEC;
		WRITE(MAL)=THD.MIDI;

		IF  (READ(MD)<>0)                /* MIDI ROUTED         */
		AND (TIME.BASE.MODE<>0)          /* ACTUALLY PLAYING    */
		THEN CALL CHECK.MIDI.RTES;       /* SEND OUT NEW VALUES */

		WRITE(MAM)=SEC;                  /* CALL TO CHECK.MIDI.RTES TRASHES MAM */
		WRITE(MAL)=THD.SUSTAIN;          /* GET SUSTAIN STATE AT OVERALL LOOP START */
		LOOP.SUS=READ(MD)&B.LOOP.SUSTAIN;

	END;

	/* $PAGE */


	/* 2. READ BLOCK OF INFORMATION FROM THE LOOP INFO AREA INTO       */
	/*    'COPY.BUF'.  THESE VALUES WILL BE COMPARED WITH THE          */
	/*    CURRENT VALUES SO SYNTH UPDATES CAN BE HANDLED PROPERLY      */

	WRITE(MAM)=SEC;                 /* POINT AT TRACK HEADER */
	WRITE(MAL)=WRD;                 /* SET XMEM PTR TO ILP PLAY PTR */

	CALL LOAD.PLAY.INFO;            /* LOAD LOOP VALUES INTO TEMP */
											  /* POINTING AT TRK HEAD HERE  */

	/* DO SOME CONSISTENCY CHECKING HERE TO CATCH  */
	/* PROGRAMMING ERRORS WHICH MIGHT HAVE TRASHED */
	/* THE NAH.AREA (I.E. SCREWED UP NLS LISTS)    */

	WRITE(MAM)=SEC;                 /* POINT AT TRACK HEADER      */
	WRITE(MAL)=THD.TRK;             /* SAVE OUR TRK IN TEMP       */
	I=READ(MD);

	IF WRD=THD.LP.NMSB                   /* IF OVERALL LOOP JUMP BACK */
	THEN WRITE(MAM)=NAH.PTR+COPY.BUF(5); /* NEW PLAY PTR IS AT 4 & 5  */
	ELSE WRITE(MAM)=NAH.PTR+COPY.BUF(1); /* OTHERWISE IT IS AT 0 & 1  */

	IF (READ(MDI)< 0)               /* SERIOUS PROBLEM IF NLS.FOR=(-1)   */
	OR (READ(MDI)< 0)               /* OR NLS.REV=(-1)                   */
	OR (READ(MD )<>I)               /* OR NLS.TRK<>THD.TRK               */
	THEN DO;                        /* LOOP BACK WILL DEFINITELY BLOW UP */

		RETURN;                      /* DON'T CRASH - JUST QUIT           */
		/* STOP (3\SHL(I,8)); */     /* WILL GIVE USEFUL INFO ON HOP      */
		/*****************************************/
		/******** IF WE DID ABOVE STOP,  *********/
		/******** WE HAVE JUST CRASHED!! *********/
		/*****************************************/
	END;
	WRITE(MAM)=SEC;                 /* RESTORE PTR TO TRACK HEADER */

	/* 3. NEXT RESET OUR CURRENT TRACK PLAY PTRS BACK TO THE */
	/*    ILP INFO VALUES.  WE DON'T HAVE TO WORRY ABOUT    */
	/*    INADVERTENTLY USING ITS START TIME DELTA, SINCE WE */
	/*    ARE GOING TO SKIP OVER THIS RECORD IN THE ROUTINE  */
	/*    THAT CALLED THIS PROC.                             */

	WRITE("313")=ADDR(COPY.BUF(0)); /* SET UP TO READ FROM BUF      */

	IF WRD=THD.LP.NMSB              /* DOING OVERALL LOOP JUMP BACK */
	THEN DO;                        /* RESET EVENT TIME VARIABLES   */
		WRITE(MAL)=THD.NMSB;         /* POINT TO EVENT TIME BLOCK    */
		WRITE(MDI)=READ("373");      /* RESET THD.NMSB               */
		WRITE(MDI)=READ("373");      /* RESET THD.NLSB               */
		WRITE(MDI)=READ("373");      /* RESET THD.LMSB               */
		WRITE(MDI)=READ("373");      /* RESET THD.LLSB               */
	END;
	ELSE WRITE(MAL)=THD.WRD;        /* POINT TO CURRENT PLAY PTRS */

	IF READ("353")=0 THEN RETURN;   /* UNDEFINED NEW PLAY PTR WRD - BOMB OUT */
	WRITE(MDI)=READ("373");         /* COPY NEW PLAY PTR INTO THD.WRD */
	IF READ("353")=0 THEN RETURN;   /* UNDEFINED NEW PLAY PTR SEC - BOMB OUT */
	WRITE(MDI)=READ("373");         /* COPY NEW PLAY PTR INTO THD.SEC */


	/* 4.  NEXT, DO UPDATING OF CURRENT XPOS, TIMBRE, LAST PITCH,     */
	/*     TOGGLE BITS, MIDI PORTAMENTO SWITCH, MIDI PROGRAM NUMBER,  */
	/*     AND THE SIX RTE CONTROLLERS AVAILABLE IN THE SYNCLAVIER.   */
	/*     BASICALLY WE NEED TO COMPARE THE CURRENT VALUES FOR THESE  */
	/*     DATA WITH THE ILP START VALUES, AND HANDLE THE UPDATES AS  */
	/*     IF THESE ARE UPDATE RECORDS, OR WHATEVER, IN ORDER TO MAKE */
	/*     SURE THAT THE PROPER SYNTH UPDATES WILL OCCUR.             */

	WRITE(MDI)=READ("373");         /* COPY LOOP XPOS OVER THD.CXPOS */

	IF READ(MDI)<>READ("373")       /* LOOP TIMBRE # DIFFERS FROM THD.CTIMB */
	THEN DO;                        /* SET FLAG TO RECOMPUTE ARLIST */
		WRITE(MAL)=THD.CTIMB;        /* RESET PTR XMEM AND IMEM PTRS */
		WRITE("313")=READ("313")-1;  /* UNDO EFFECT OF AUTO-INCREMENT     */
		WRITE(MDI)=READ("373");      /* COPY LOOP TIMBRE # OVER THD.CTIMB */
		CALL.COMPUTE.ARLIST=1;       /* CAUSE CALL TO COMPUTE.ARLIST BELOW */
	END;

	WRITE(MDI)=READ("373");         /* COPY LOOP LPITCH OVER THD.CLPITCH */

	IF READ(MDI)<>READ("373")       /* LOOP TBITS DIFFERS FROM THD.CTBITS */
	THEN DO;                        /* HANDLE CHANGE LIKE UPDATE RECORD */
		WRITE(MAL)=THD.CTBITS;       /* RESET PTR XMEM AND IMEM PTRS     */
		WRITE("313")=READ("313")-1;  /* UNDO EFFECT OF AUTO-INCREMENT    */
		WRITE(MDI)=READ("373");      /* COPY LOOP TBITS OVER THD.CTBITS  */

		UPDATES=UPDATES\N.REPRATE;   /* SET BIT FOR UPDATE IN TEMP WORD */
	END;

	WRITE(MDI)=READ("373");         /* COPY LOOP CG.VAL OVER THD.CG.VAL */

	WRITE(MDI)=READ("373");         /* COPY LOOP MIDI PROGRAM # OVER THD.CPROGRAM */


	/* $PAGE */


	/* ALTHOUGH WE WANT TO RESET ALL 8 CURRENT RTE VALUES TO  */
	/* THE APPROPRIATE LOOP VALUES, WE ONLY COMPARE THE 1ST   */
	/* SIX OF THEM FOR SYNTH UPDATES, SINCE THE LAST TWO ARE  */
	/* SPECIAL VALUES USED FOR THE RIBBON FILTER COMPUTATIONS */

	IF WRD=THD.LP.NMSB               /* HANDLING OVERALL LOOP */
	THEN WRD=16;                     /* WE HAVE PROCESSED 16 WDS SO FAR */
	ELSE WRD=12;                     /* ILP ONLY PROCESSED 12 WORDS     */

	WRITE(MAL)=THD.RTES;             /* SET UP TO READ RTE INFO          */
	DO I=0 TO 5;                     /* NOW CHECK RTE CONTROLLERS FOR CHANGES */

		WRITE("313") = COPY.BUF(WRD+I); /* LOOK UP ONCE FOR SPEED */

		IF READ(MDI)<>READ("313")     /* VALUE AT LOOP START DIFFERS FROM CURRENT VAL */
		THEN DO;                      /* HANDLE LIKE AN UPDATE RECORD  */

			WRITE(MAL)  =THD.CTIMB;    /* LOOK UP CURRENT TIMBRE NUMBER */
			WRITE("300")=READ(MD);     /* SAVE IN R0 FOR AN INSTRUCTION */
			WRITE(MAM)  =TIM.HEAD;     /* POINT TO TIMBRE HEADER FOR    */
			WRITE(MAL)  =READ("300");  /* THIS TRACK'S CURRENT TIMBRE   */
			WRITE(MAM)  =READ(MD);     /* THEN POINT TO THE TIMBRE INFO */
			WRITE(MAL)  =TIM.ACT.PARS+I; /* AND LOOK UP ITS ACTIVE RTE PARMS */

			UPDATES=UPDATES\READ(MD);  /* SAVE IN TEMP FOR ONE UPDATE BELOW */

			WRITE(MAM)=SEC;            /* RESTORE PTR TO TRACK HEADER         */
			WRITE(MAL)=THD.RTES+I;     /* RESTORE PTR TO THIS RTE CONTROLLER  */
			WRITE(MDI)=READ("313");    /* COPY LOOP VALUES OVER THD.RTE VALUES */
		END;

	END;                             /* OF LOOP OVER RTE CONTROLLERS  */

	WRITE("313")=ADDR(COPY.BUF(WRD+6)); /* POINT TO 7TH RTE INFO WORD */
	WRITE(MDI)=READ("373");          /* COPY +RIBBON FILTER VAL    */
	WRITE(MD )=READ("353");          /* COPY -RIBBON FILTER VAL    */

	IF UPDATES<>0 THEN DO;           /* NEED TO DO RTE UPDATES       */
		WRITE(MAL)=THD.UPD.PARS;      /* POINT AT UPD.PARS WORD       */
		WRITE(MDI)=READ(MD)\UPDATES;  /* OR IN BITS FOR RTES AFFECTED */

		IF  (READ(MD)=0)              /* CHECK THD.UPD.QUED          */
		THEN DO;                      /* NOT IN LIST SO PUT IT THERE */
			WRITE(MDI)=1;              /* THD.UPD.QUED TO NONZERO     */
			WRITE(MD)=UPLIST0;         /* STORE REL. FORWARD PTR      */
			UPLIST0=READ(MAM)-NAH.PTR; /* IN THD.UPD.LINK             */
		END;

		UPDATES=0;                    /* THEN RESET LOCAL FLAG       */
		NEW.INFO=1;                   /* SET FLAG TO DO UPDATES ASAP */
	END;

	IF CALL.COMPUTE.ARLIST<>0        /* NEED TO RECONSTRUCT */
	THEN DO;                         /* ACTIVE RIBBON LIST  */
		CALL.COMPUTE.ARLIST=0;        /* RESET FLAG          */
		CALL COMPUTE.ARLIST;          /* AND THEN DO IT      */
	END;

	WRITE(MAM)=SEC;
	WRITE(MAL)=THD.MIDI;

	IF  (READ(MD)<>0)             /* MIDI ROUTED         */
	AND (TIME.BASE.MODE<>0)       /* ACTUALLY PLAYING    */
	THEN DO;
		CALL CHECK.MIDI.EFFECTS;   /* MAKE SURE CORRECT   */

		WRITE(MAL)=THD.SUSTAIN;                       /* NOW CHECK PRIOR SUSTAIN STATE */
		IF (READ(MD)&B.CURRENT.SUSTAIN)<>0            /* IF IT WAS ON */
		THEN CALL REAL.MIDI.CONTROL.CHANGE(64,0);     /* MUST TURN OFF MIDI HERE */

		IF (LOOP.SUS)<>0                              /* AND THEN IF NEW STATE IS ON */
		THEN CALL REAL.MIDI.CONTROL.CHANGE(64,127);   /* TURN MIDI BACK ON NOW */

	END;

	WRITE(MAL)=THD.SUSTAIN;          /* COPY LOOP SUSTAIN VALUE OVER CURRENT */
	IF (LOOP.SUS)=0                  /* NEW SUSTAIN STATE IS OFF */
	THEN WRITE(MD)=(READ(MD)&(NOT B.CURRENT.SUSTAIN));    /* CLEAR BIT */
	ELSE WRITE(MD)=(READ(MD)\B.CURRENT.SUSTAIN);          /* SET BIT */

END HANDLE.LOOP.JUMP;

INSERT '160SEQ0A';

