/* :SYNRSOU:04-SEQ:163-SEQ3  -  ROUTINE TO INITIALIZE SEQUENCER TO START RECORDING */

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
1998/07/11 - TY  - Small additions to PRESET.PLAY.TIME to fix two bugs:
						 1) Prevent spurious click when first pressing play after setting
							 a start mark when using a click track.
						 2) Emit clicks at the proper rate when starting beyond the last
							 note on the click track. 
1998/06/14 - TY  - Simplified the way START.RECORD sets bits in the RTE.CHANGES array.
1998/06/03 - CJ  - Cleaned up logic associated with selecting and deselecting a track
						 automatically at start of recording
1991/09/04 - PF  - record sustain records at correct sequence time
1991/08/09 - PF  - Use same record time for all tracks when placing sustain
						 update records in STOP.RECORD
1991/08/05 - PF  - come out of sustain in stop record
1991/01/30 - MWH - Report which tracks have had new notes
1990/11/06 - PF  - Add call to START.MIDI.SUSTAIN in PRESET.PLAY.TIME
1990/08/27 - PF  - Support all MIDI controllers
1990/07/10 - PF  - Replace calls to DISPLAY.BEAT.NUMBER with NEW.BEAT.NUMBER flag
1990/07/10 - PF  - Compute REAL.TIME.OF.NEXT.CLICK in PRESET.PLAY.TIME
1990/05/30 - PF  - Build CPLIST0 in START.RECORD if using Channel Pressure
1990/05/21 - CJ  - FIXED STOP.RECORD GARBAGE COLLECT TRACK SLIDE BUG
1990/03/21 - PF  - Optimize setting of RTE.CHANGES in START.RECORD
1990/03/09 - PF  - Increase MAX.INPUTS to 128
*/


DCL UNSOLO.TRACK.AFTER.RECORDING		FIXED;	/* USED TO DO BLINKING TRK BUTTON NICELY */
DCL CLEAR.RECD.TRK.AFTER.RECORDING	FIXED;	/* USED TO DO BLINKING TRK BUTTON NICELY */
DCL AUTO.RECD.TRK							FIXED;	/* FLAG FOR AUTO KBD RECORD TRACK LOGIC */
DCL ALLOCATE.TRK.HEADER PROC (FIXED) RETURNS(FIXED) RECURSIVE;	/* QUICKLY SETS UP A NEW TRK HEAD */
DCL STM.RECORD.ACTIVE   FIXED PUBLIC;
DCL FORCE.MIDI.EFFECTS  BOOLEAN PUBLIC;	/* SET TO TRUE TO CAUSE EVENTUAL CALL TO CHECK.MIDI.EFFECTS ON RECD.TRK */

START.RECORD: PROC FIXED PUBLIC SWAPABLE;	/* DOES EVERYTHING NEEDED TO BEGIN RECORDING */
	DCL (I,J,K,L,M,N) FIXED;
	DCL THP           FIXED EXTERNAL;

	/* STEPS REQUIRED TO START RECORDING:                */
	/*		0.  CHECK FOR LIVE OVERDUB RECORDING           */
	/*		1.  COMPUTE USAGE KEY # FOR KBD TIMBRE         */
	/*		2.  FIGURE OUT WHICH TRACK TO USE              */
	/*		3.  TRY TO DETERMINE IF ENOUGH ROOM FOR TIMBRE */
	/*		4.  TURN ON RECD FLAG                          */


	/* DISABLE "PLAY TO" LIMIT WHEN USER PRESSES "START":                  */

	PLAY.SEQ.TO.A.TIME =0;					/* NO "PLAY TO"                    */

	/* CHECK FOR DOING DTD PUNCH-IN RECORDING FROM THE P PAGE:             */

	IF LOD.RECD.TRACKS<>0 THEN DO;		/* LIVE OVERDUB RECORDING SELECTED */
		RECD.TRK=0;
		IF NEW.PAN<>0 THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'*LIVE RECORDING*');
		END;
		NEW.BEAT.NUMBER = 1;					/* DISPLAY BEAT # HERE      */
		RECD=1;									/* INDICATE RECORDING NOW         */
		NEW.MOTION=1;							/* TELL LIVE OVERDUB ABOUT IT     */
		CALL COMPUTE.ACTIVE.TRKS;			/* COMPUTE ACTIVE TRACKS FOR RECORD */
		CALL DISPLAY.TRACK.BUTTONS;		/* NEW TRACKS TO DISPLAY */
		IF AUTO.PUNCH.ON = 0					/* IF NOT IN AUTO PUNCH NOW */
		THEN CALL TAKE.RECORD.TIME(0);	/* REMEMBER WHERE WE DID START RECORD */
		RETURN 1;
	END;

	IF  (STORE.DTD.INFO=2)					/* IF USER IS ON TRACK SCREEN      */
	AND (RECD.TRK      =0)					/* BUT NO LOD OR SYNCL TRACKS SELECTED */
	THEN DO;										/* DISALLOW RECORDING                  */
		CALL DISPLAY.ERR(47);
		RETURN 0;
	END;


	/* COMPUTE USAGE KEY # FOR KBD TIMBRE */
	/* HERE SO WE ONLY DO IT ONCE. MAKES  */
	/* CHECK.TIMBRE A LOT FASTER          */

	CALL COMPUTE.USAGE.KEY#(0);			/* COMPUTE KEY# FOR CURRENT KBD TIMBRE */


   UNSOLO.TRACK.AFTER.RECORDING   = FALSE;  /* SAVE VALUE FOR USE IN STOP.RECORD */
   CLEAR.RECD.TRK.AFTER.RECORDING = FALSE;

	IF RECD.TRK<>0 THEN DO;	/* USER HAS SELECTED A TRACK TO RECORD ON */

		/* SEE IF KEYBOARD TIMBRE MATCHES ANY TIMBRE     */
		/* ALREADY ON THAT TRACK IF TRACK HAS SOME NOTES */

		WRITE(MAM)=TRK.HEAD;				/* LOOK UP PTR TO TRK HEAD      */
		WRITE(MAL)=RECD.TRK;

		IF READ(MD)<>0 THEN DO;			/* TRACK HAS A TRK HEAD         */

			WRITE(MAM)=READ(MD);			/* POINT TO IT                  */
			WRITE(MAL)=THD.NN.MSB;		/* LOOK UP NUMBER OF NOTES ON TRK */
			I=READ(MDI)\READ(MD);		/* NON-ZERO IF ANY NOTES ON TRACK */

			WRITE(MAL)=THD.CTIMB;		/* LOOK UP CTIMB ON TRK */
			J=READ(MD);

			IF STM.RECORD.ACTIVE <> 0 THEN DO;	/* ARE IN SPECIAL STM RECD MODE */
				IF I<>0 THEN DO;						/* HAVE SOME NOTES ON TRK */
					CALL DISPLAY.ERR(41);			/* CAN'T RECD ON TRACK W/NOTES */
					RETURN(0);							/* START RECORD NOT SUCCESSFUL */
				END;
			END;

			ELSE DO;								/* NOT IN STM RECORDING MODE */

				IF J<>0											/* IF TIMBRE ON TRK */
				THEN J=OK.TO.COPY.TIMBRE(0,RECD.TRK);	/* THEN COMPARE TO KBD TIMBRE */
				ELSE J=1;										/* ELSE OK TO PUT ANY TIMBRE ON TRK */

				IF (I<>0) AND (J=0)			/* TRK HAS NOTES BUT   */
				THEN DO;							/* TIMBRES DON'T MATCH */
					CALL DISPLAY.ERR(7);		/* DISPLAY 'TIMBRES MUST MATCH' */
					RETURN 0;					/* START RECORD NOT SUCCESSFUL  */
				END;
				ELSE IF (I=0) AND (J=0)		/* NO NOTES BUT TIMBRE DOES NOT MATCH KBD */
				THEN DO;							/* GET RID OF EXISTING TIMBRE */
					CALL TRK.HEAD.STORE(RECD.TRK,THD.CTIMB,0);	/* ZERO ANY OUT EXISTING TIMBRE #S */
					WRITE(MAL)=THD.ILS.CTIMB; WRITE(MD)=0;
					WRITE(MAL)=THD.ILE.CTIMB; WRITE(MD)=0;
					WRITE(MAL)=THD.LP.CTIMB;  WRITE(MD)=0;
				END;

			END;									/* OF NOT IN STM RECORDING MODE */

		END;										/* OF TRK HAS A TRK HEAD        */

	END;					/* OF MAKE SURE USER SELECTED TRACK OK TO RECORD ON */

	ELSE DO;				/* SEARCH THROUGH TRACKS TO GET A TRACK TO RECORD ON */

		/* FIRST SEE IF THERE IS A TRACK THAT ALREADY HAS */
		/* THE SAME TIMBRE AS OUR KEYBOARD TIMBRE         */

		CLEAR.RECD.TRK.AFTER.RECORDING = TRUE;

		IF STM.RECORD.ACTIVE = 0 THEN DO;	/* NOT TRYING TO DO STM RECORDING FROM KBD */

			DO I=0 TO NUM.TRACK.BUTTONS-1;	/* LOOP OVER TRACK BUTTONS     */
				WRITE(MAM)=TBUT.PTR;				/* MAP BUTTON TO TRK NUMBER    */
				WRITE(MAL)=I;
				RECD.TRK=READ(MD)&255;			/* EXTRACT ABSOLUTE TRK NUMBER */

				WRITE(MAM)=TRK.HEAD;				/* SEE IF TRK HEADER EXISTS    */
				WRITE(MAL)=RECD.TRK;

				IF READ(MD)<>0 THEN DO;			/* TRK HAS A HEADER            */
					WRITE(MAM)=READ(MD);
					WRITE(MAL)=THD.CTIMB;		/* GET CURRENT TIMBRE FOR TRACK */

					IF (READ(MD)<>0)				/* TRACK HAS A VALID TIMBRE #  */
					OR (RECD.TRK=KEYBOARD.TIMBRE.CONTROL)	/* TRACK IS SHARING KBD TIMBRE */
					THEN DO;
						IF (RECD.TRK=KEYBOARD.TIMBRE.CONTROL)	/* TRACK IS SHARING KBD TIMBRE */
						OR (OK.TO.COPY.TIMBRE(0,RECD.TRK)<>0)	/* OR IT MATCHES KBD   */
						THEN GOTO USE.IT;								/* THEN USE THIS TRACK */
					END;
				END;
			END;

		END;										/* OF NOT DOING STM RECORDING */


		/* $PAGE */


		/* NEXT, TRY TO FIND AN EMPTY TRACK ON WHICH WE CAN RECORD */

		DO I=0 TO NUM.TRACK.BUTTONS-1;	/* LOOP OVER TRACK BUTTONS     */
			WRITE(MAM)=TBUT.PTR;				/* MAP BUTTON TO TRK NUMBER    */
			WRITE(MAL)=I;
			RECD.TRK=READ(MD)&255;			/* EXTRACT ABSOLUTE TRK NUMBER */

			IF (RECD.TRK <  FIRST.LOD.TRACK)
			OR (RECD.TRK >= LAST.LOD.TRACK )
			THEN DO;
				WRITE(MAM)=TRK.HEAD;			/* SEE IF TRK HEADER EXISTS    */
				WRITE(MAL)=RECD.TRK;
				IF READ(MD)=0
				THEN GOTO USE.IT;				/* NO TRK HEADER, OK TO USE IT */
			END;
		END;

		RECD.TRK=0;							/* RESET */
		CALL DISPLAY.ERR(8);				/* DISPLAY 'OUT OF TRACKS' */
		RETURN 0;							/* BOMB OUT - NO TRACKS AVAILABLE */


		USE.IT:								/* WE FOUND A TRACK TO USE */

		/* PRETEND THE CORRECT TRACK   */
		/* BUTTON WAS ACTUALLY PRESSED */

		WRITE(MAM)=TBUT.PTR;				/* SET SOLOED BIT IN       */
		WRITE(MAL)=RECD.TRK;				/* SOLOED TRK LOOKUP TABLE */

		IF (READ(MD)&B.SOLOED.TRK)=0	/* IF TRACK IS NOT SOLOED  */
		THEN DO;
			WRITE(MD)=READ(MD)\B.SOLOED.TRK;	/* SET SOLOED BIT */
			NUM.OF.SOLOED.TRACKS=NUM.OF.SOLOED.TRACKS+1;
			UNSOLO.TRACK.AFTER.RECORDING = TRUE;
		END;

	END;

	WRITE(MAM)=TRK.HEAD;					/* SEE IF TRK TO RECORD ON HAS */
	WRITE(MAL)=RECD.TRK;					/* A TRACK HEADER              */

	IF READ(MD)=0 THEN DO;				/* DON'T HAVE A TRK HEAD YET SO TRY TO CREATE ONE */

		/* ALLOCATE STORAGE FOR TRK HEADER */

		J=ALLOCATE.TRK.HEADER(RECD.TRK);	/* GET TRACK HEADER        */
		IF J=0 THEN DO;						/* NONE AVAILABLE            */
			CALL DISPLAY.ERR(14);			/* DISPLAY 'OUT OF MEMORY'   */
			RETURN 0;
		END;

	END;										/* OF ALLOCATE NEW TRK HEAD */

	DO I=NUM.KBD.TRACKS						/* LOOP THRU ALL TRACKS */
	TO FIRST.LOD.TRACK-1;
		WRITE(MAM)=TBUT.PTR;					/* LOOKUP TABLE FOR READY TRACKS */
		WRITE(MAL)=I;
		IF (READ(MD)&B.READY.TRK)<>0 THEN DO;	/* THIS TRACK IS ARMED */
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=I;
			IF  ((READ(MD)=0)								/* NO TRACK HEAD */
			OR  (TRK.HEAD.LOOKUP(I,THD.STIMB)=0))	/* NO TIMBRE     */
			AND (I<>RECD.TRK)								/* THIS IS NOT THE KBD RECORD TRACK */
			AND (I<>KEYBOARD.TIMBRE.CONTROL)			/* THIS IS NOT UNDER KEYBOARD CONTROL */
			THEN DO;
				CALL COPY.TIMBRE(-3,I);		/* PLACE NULL TIMBRE ON TRACK */
			END;
		END;
	END;

	IF (NUM.ENABLED.TRKS<>0)		/* RECORDING ON MORE THAN ONE TRACK */
	AND (NEW.PAN<>0) THEN DO;
		CALL CLEAR.UPPER;
		CALL EMIT.STRING(0,'Kbd Track -');				/* TELL USER WHICH TRACK */
		CALL EMIT.NUMBER(12,RECD.TRK-1,0,LEFT.JUST);	/* KBD IS RECORDING ON   */
		UPPER.DISP=KBDTRACK.DISP;
	END;

	/* $PAGE */

	IF DEBUG THEN DO;
		/* PUT CODE HERE WHICH MIGHT TRY TO SEE IF */
		/* THE KEYBOARD TIMBRE WILL FIT IN MEMORY  */
		/* WHEN WE COPY IT IN STOP.RECORD.         */
	END;

	WRITE(MAM)=TRK.HEAD;					/* COPY KBD MIDI,TVOL,TROU */
	WRITE(MAM)=READ(MD);					/* ONTO RECD.TRK HEADER    */
	WRITE(MAL)=THD.MIDI;
	I=READ(MDI);							/* THD.MIDI */
	J=READ(MD );							/* THD.TVOL */
	WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
	K=READ(MD);
	WRITE(MAL)=THD.CUE.TRACK;
	L=READ(MD);
	WRITE(MAL)=THD.MIDI.PATH;
	M=READ(MD);								/* MIDINET ROUTING */
	WRITE(MAL)=THD.MIDX;
	N=READ(MD);								/* MIDI OUT XPOS   */

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=RECD.TRK;
	WRITE(MAM)=READ(MD);
	WRITE(MAL)=THD.MIDI;
	WRITE(MDI)=I;							/* THD.MIDI */
	WRITE(MD )=J;							/* THD.TVOL */
	WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
	WRITE(MD )=K;
	WRITE(MAL)=THD.CUE.TRACK;
	WRITE(MD )=L;
	WRITE(MAL)=THD.MIDI.PATH;
	WRITE(MD )=M;
   WRITE(MAL)=THD.MIDX;
   WRITE(MD )=N;

	IF (I&THD.MIDI.CHANP)<>0		   /* SENDING CHANNEL PRESSURE */
	THEN CALL COMPUTE.MISC.INFO;		/* BUILD CPLIST0 */

	IF L<>0 THEN DO;						/* IF RECORDING ON CUE TRACK          */
		NEW.MOTION             = 1;	/* SEND NEW CUE TRACK CONSTANTS       */
		NEW.CUE.TRACK.SETTINGS = 1;	/* OVER AFTER TRACK HEAD ALLOCATE     */
	END;

	WRITE(MAL)=THD.NN.MSB;
	IF (READ(MDI)\READ(MD))=0			/* RECORD TRK HAS NO NOTES ON IT */
	THEN DO;
		WRITE(MAM)=TRK.HEAD;				/* COPY TRACK ROUTING FROM KBD */
		WRITE(MAM)=READ(MD);				/* TO OUR RECD TRK HEAD        */
		WRITE(MAL)=THD.TROU;
		I=READ(MD);
		WRITE(MAL)=THD.POLY;
		J=READ(MD);
		WRITE(MAL)=THD.CUE.OUT;
		K=READ(MD);
		WRITE(MAM)=TRK.HEAD;
		WRITE(MAL)=RECD.TRK;
		WRITE(MAM)=READ(MD);
		WRITE(MAL)=THD.TROU;
		WRITE(MD )=I;
		WRITE(MAL)=THD.POLY;
		WRITE(MD )=J;
		WRITE(MAL)=THD.CUE.OUT;
		WRITE(MD )=K;
	END;

	WRITE(MAL)=THD.MIDI;
	IF READ(MD)<>0
	THEN CALL SET.MIDI.OUT.CONTROLLERS  (RECD.TRK);
	ELSE CALL CLEAR.MIDI.OUT.CONTROLLERS(RECD.TRK);

	IF SOLOED.PARTIALS<>0 THEN DO;	/* ELIMINATE PARTIAL SOLOING */
		SOLOED.PARTIALS=0;
		CALL DISPLAY.PARTIAL.BUTTONS;
	END;
	CALL COMPUTE.VOLUME.LEVELS;		/* COMPUTE NEW VOLUME LEVELS AFTER SOLOING CHANGE */

	CALL RESYNC.TIME.BASE;				/* SYNC UP EXT SYNC PULSES WITH CLICKS */
	NEW.BEAT.NUMBER = 1;					/* DISPLAY BEAT # HERE */
	RECD=1;									/* INDICATE RECORDING NOW */
	NEW.MOTION=1;							/* TELL LIVE OVERDUB ABOUT IT */

	CALL COMPUTE.ACTIVE.TRKS;			/* COMPUTE ACTIVE TRACKS FOR RECORD */
	CALL DISPLAY.TRACK.BUTTONS;		/* NEW TRACKS TO DISPLAY */

	/*	PRETEND THAT P1, P2, MW, RIB, BR & PW HAVE ALL CHANGED.  THOSE NOT ENABLED	BY TIM.USED.RTES */
	/*	OR BY THD.ACTIVE.MIDI.RTES WILL BE FILTERED OUT BEFORE THE EVENTUAL CALL TO CHECK.EFFECTS.  */

	/* SET BITS FOR KEYBOARD CHANNEL */
	RTE.CHANGES(0)=(2\4\8\16\64\128);
	RTE.CHANGETABLE(0)=RTE.CHANGETABLE(0)\1;				/* SET CHANGETABLE BIT FOR KEYBOARD */
	RTE.CHANGEBITS    = RTE.CHANGEBITS   \1;				/* SET CHANGEBITS  BIT FOR KEYBOARD */

	/* SET BITS FOR MIDI INPUT CHANNELS.  ONLY NEED TO DO THIS IF MIDI MAPPED TO RECORDER. */
	IF MIDI.INPUT.ENABLED<>0 THEN DO;
		WRITE(MAM)=TBUT.PTR;	/* NO NEED TO DO THIS 126 TIMES */
		DO I=NUM.KBD.TRACKS TO MAX.INPUTS-1;		/* LOOP THRU ALL OF THE MIDI INPUTS */
			WRITE(MAL)=I;								   /* POINT AT TRACK STATUS BITS FOR THIS INPUT'S TRACK */ // was midi  mapped
			IF (READ(MD)&B.READY.TRK)<>0 THEN DO;	/* THIS TRACK IS ARMED FOR RECORD */
				J = SHR(I,4);
				RTE.CHANGES    (I) = (2\4\8\16\64\128);						/* SET ALL RTE BITS */
				RTE.CHANGETABLE(J) = RTE.CHANGETABLE(J)\BITS(I & "17");	/* AND THE CORRESPONDING CHANGETABLE BIT */
				RTE.CHANGEBITS     = RTE.CHANGEBITS    \BITS(J);			/* AND THE CORRESPONDING CHANGEBITS  BIT */
			END;
		END;
	END;

	FORCE.MIDI.EFFECTS=TRUE;	/* SET TO FORCE UPDATE OF MIDI.EFFECTS */

	#if (0)							// THIS IS REDUNDANT SINCE ALL 6 RTE BITS ARE ALREADY SET.
	/* ADD BITS TO RTE.CHANGES FOR MIDI RTES IF ANY */
	WRITE(MAM)=TRK.HEAD;
	WRITE(MAM)=READ(MD);
	WRITE(MAL)=THD.MIDI;
	IF READ(MD)<>0 THEN DO;
		WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
		DO I=0 TO 5;
			IF (READ(MD) & BITS(I))<>0
			THEN RTE.CHANGES(0)=RTE.CHANGES(0)\R.LOOK(I);
		END;
	END;
   #endif

	NEW.TOGGLES=1;							/* ALSO FORCE CHECK OF TOGGLES */
	NEW.SEQ.INFO = NEW.SEQ.INFO \ 2;	/* NEW TIMBRE NAMES HERE       */
	WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
	WRITE(MAL) = RECD.TRK;				/* REMEMBER TRACK # ON NEW.SEQ.INFO */
	WRITE(MD) = "177777";				/*   "NEW NOTES" OR "NEW TIMBRE"    */
	TIME.DELTA=0;							/* SET WHEN NOTE IS PLAYED EARLY OR LATE */

	DISABLE;
	NEW.PROGRAM.STAK(0)=0;				/* ZERO OUT MIDI PROGRAM CHANGES */
	ENABLE;

	WRITE(MAM)=TBUT.PTR;									/* NOW CHECK TO SEE IF THIS TRACK IS "READY" */
	WRITE(MAL)=RECD.TRK;
	IF ((READ(MD) & B.READY.TRK) = 0) THEN DO;
		AUTO.RECD.TRK=RECD.TRK;							/* FLAG FOR STOP RECORD TO INDICATE WE HAD TO READY THIS TRACK */
		WRITE(MD) = READ(MD) \ B.READY.TRK;			/* SET READY BIT IN ARRAY */
		NUM.ENABLED.TRKS = NUM.ENABLED.TRKS + 1;	/* KEEP COUNT ACCURATE    */
		NEW.SEQ.INFO = NEW.SEQ.INFO \ 4096;			/* NEW READIED TRACK      */
		CALL DISPLAY.TRACK.BUTTONS;					/* UPDATE DISPLAY         */
	END;

	IF AUTO.PUNCH.ON = 0						/* IF NOT IN AUTO PUNCH NOW */
	THEN CALL TAKE.RECORD.TIME(0);		/* REMEMBER WHERE WE DID START RECORD */
	
	interp_seq_dirtyness(1);

	RETURN 1;

END START.RECORD;


/* $SUBTITLE  ROUTINE TO STOP RECORDING */


STOP.RECORD: PROC PUBLIC SWAPABLE;	/* PROCEDURE TO STOP RECORDING */
	DCL (I,J,K)           FIXED;
	DCL (RLEN)            FIXED;
	DCL (OURFP,OURLP)     FIXED STATIC;
	DCL (PRIORFP,PRIORLP) FIXED;
	DCL (FP,RP          ) FIXED;
	DCL (MSB,LSB)         FIXED;
	DCL (TRK,THP)         FIXED EXTERNAL;

	SLIDE.DOWN:PROC;
		CALL COPY.EXT.MEM(NAH.PTR+#SEC,OURFP,
								NAH.PTR+#SEC,NLS.FIRSTL,OURLP-OURFP);

		WRITE(MAM)=NAH.PTR+#SEC;
		WRITE(MAL)=NLS.FP;
		WRITE(MDI)=NLS.FIRSTL;
		WRITE(MD )=NLS.FIRSTL+(OURLP-OURFP);
		WRITE(MAL)=READ(MD);
		WRITE(MD )=NLS.EOS;

		#WRD = 0;					/* FUDGE CALL TO ADJUST.SEQUENCER.PTRS */
		CALL ADJUST.SEQUENCER.PTRS(#SEC,NLS.FIRSTL-OURFP);
	END;

	/* TO STOP RECORDING PROCESS:                        */
	/*		0. CHECK FOR END OF LIVE OVERDUB RECORDING     */
	/*		1. COMPRESS THE NOTELIST WE JUST RECORDED ON   */
	/*		2. COPY KEYBOARD TIMBRE TO NEW TIMBRE NUMBER   */
	/*		3. RESET MISC. INFO AND TURN OFF RECD AND PNCH */

	RECD=0; PNCH=0;				/* STOP RECORDING AND PUNCHING IN  */

	ABRT.RECORDING=1;				/* INDICATE END TO RECORDING NOTES */
	NEW.MOTION    =1;				/* TELL LIVE OVERDUB ABOUT IT      */
	PLAY.SEQ.TO.A.TIME =0;		/* NO "PLAY TO"                    */

	IF RECD.TRK=0 THEN DO;				/* LOD RECORDING */
		CALL COMPUTE.ACTIVE.TRKS;		/* SET UP ACTIVE.TRACKS ARRAY AS REQUIRED */
		CALL DISPLAY.TRACK.BUTTONS;	/* AND DISPLAY */
		SMPTE.RECD=0;						/* DISABLE SMPTE RECORDING AFTER CALL */
		IF NEW.PAN<>0 THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'*LIVE RECORDING**COMPLETED     *');
			SUPRESS.BEAT.DISPLAY=1;							/* STOP BEAT DISPLAYS MOMENTARILY */
			BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/* HOLD DISPLAY FOR 5 SECONDS */
			BOTH.DISPLAY=1;
		END;
		IF AUTO.PUNCH.ON = 0						/* IF NOT IN AUTO PUNCH NOW */
		THEN CALL TAKE.RECORD.TIME(1);		/* REMEMBER WHERE WE DID STOP RECORD */
		RETURN;
	END;

	/* NOW MAKE SURE WE DON'T LEAVE ANY TRACKS STUCK WITH SUSTAIN ON. */
	/* LATCH RECORD TIME FIRST SO ALL TRACKS USE SAME MILLISECOND.    */

	DISABLE;
		MSB=PLAY.TIME.MSB;
		LSB=PLAY.TIME.LSB;
	ENABLE;

	LSB=LSB+PRESCAN;							/* ADD PRESCAN AMOUNT TO RECORD TIME */
	IF LSB ILT PRESCAN
	THEN MSB=MSB+1;

	CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(MSB)),LOC(ADDR(MSB)));

	DO I=NUM.KBD.TRACKS						/* LOOP THRU ALL TRACKS */
	TO FIRST.LOD.TRACK-1;
		WRITE(MAM)=TBUT.PTR;					/* LOOKUP TABLE FOR READY TRACKS */
		WRITE(MAL)=I;
		IF (READ(MD)&B.READY.TRK)<>0 THEN DO;	/* THIS TRACK WAS ARMED */
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=I;
			IF  (READ(MD)<>0)								/* MAKE SURE WE HAVE TRK HEAD */
			THEN DO;

				WRITE(MAM)=READ(MD);						/* CHECK CURRENT SUSTAIN STATE */
				WRITE(MAL)=THD.SUSTAIN;
				IF (READ(MD)&B.CURRENT.SUSTAIN)<>0	/* SUSTAIN IS ON */
				THEN DO;

					WRITE(MD)=(READ(MD)&(NOT B.CURRENT.SUSTAIN));	/* CLEAR STATE IN TRK HEAD */

					WRITE(MAL)=THD.MIDI;						/* CHECK FOR MIDI OUTPUT */
					IF  (READ(MD)<>0)
					THEN CALL REAL.MIDI.CONTROL.CHANGE(64,0);

					TRK=I;										/* SET GLOBAL TRK */
					WRITE(MAM)=TRK.HEAD;						/* AND LOOKUP THP */
					WRITE(MAL)=TRK;
					THP=READ(MD);

					CALL STORE.DATA.RECORD (MSB,	LSB,		/* TIME       */
													24,	11,		/* KEY, SUSTAIN CODE */
													0,		B.UPD,	/* NEW, B.UPD */
													127	);			/* OLD        */

				END;
			END;
		END;
	END;

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=RECD.TRK;
	IF READ(MD)<>0 THEN DO;						/* TRK HAS THD (JUST IN CASE) */
		#PTR=READ(MD);
		#TRK=RECD.TRK;

		CALL LOAD.#.INFO(THD.NMSB);			/* GET CURRENT PLAY INFO      */

		I=10;											/* GARBAGE COLLECT 10 SECTORS */
		DO WHILE I<>0;

			IF #SEC<>0 THEN DO;

				/* create a system event when we garbage collect the   */
				/* track since pointers to the notes may have changed: */

				NEW.SEQ.INFO = NEW.SEQ.INFO \ 4;
				WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
				WRITE(MAL) = RECD.TRK;			/* REMEMBER TRACK # ON NEW.SEQ.INFO */
				WRITE(MD) = "177777";			/*   "NEW NOTES" OR "NEW TIMBRE"    */

				WRITE(MAM)=NAH.PTR+#SEC;

				WRITE(MAL)=NLS.FP;
				OURFP=READ(MDI);					/* NLS.FP */
				OURLP=READ(MD );					/* NLS.LP */

				/* FIND LENGTH OF LAST RECORD */
				/* IN OUR SECTOR              */

				IF OURFP=OURLP THEN RLEN=4;	/* ?????  */
				ELSE DO;
					WRITE(MAL)=OURLP-1;
					IF ((READ(MD)&"77")=VEL.NOTE)
					THEN RLEN=4;
					ELSE RLEN=2;
				END;

				WRITE(MAL)=NLS.REV;

				IF READ(MD)<>#PTR-NAH.PTR THEN DO;
					J=READ(MD);
					WRITE(MAM)=NAH.PTR+J;
					WRITE(MAL)=NLS.FP;
					PRIORFP=READ(MDI);			/* NLS.FP */
					PRIORLP=READ(MD );			/* NLS.LP */

					/* SEE IF WE CAN COMBINE TWO */
					/* NLS'S (HAPPENS AFTER      */
					/* PUNCH                     */

					IF PRIORLP+(OURLP-OURFP) <= (NLS.LAST+RLEN)
					THEN DO;							/* COMBINE NLS'S */

						CALL COPY.EXT.MEM(NAH.PTR+#SEC,OURFP,
												NAH.PTR+J   ,PRIORLP, OURLP-OURFP);
						WRITE(MAM)=NAH.PTR+J;
						WRITE(MAL)=NLS.LP;
						WRITE(MD )=PRIORLP+(OURLP-OURFP);
						WRITE(MAL)=READ(MD);
						WRITE(MD )=NLS.EOS;

						#WRD = 0;					/* FUDGE CALL TO ADJUST.SEQUENCER.PTRS */
						CALL ADJUST.SEQUENCER.PTRS(J,PRIORLP-OURFP);

						WRITE(MAM)=#PTR;				/* FREE UP NLS */
						WRITE(MAL)=THD.NUM.NLS;		/* ONE FEWER   */
						WRITE(MD )=READ(MD)-1;

						WRITE(MAM)=NAH.PTR+#SEC;	/* GET FORWARD AND REV */
						FP=READ(MDI);					/* POINTERS FROM NOW   */
						RP=READ(MD );					/* EMPTY BLOCK         */

						WRITE(MAL)=NLS.FOR;
						WRITE(MDI)=NAH.FREE;			/* LINK ON TO FREE LIST      */
						WRITE(MDI)=(-1);				/* STORE (-1) IN NLS.REV AND */
						WRITE(MD )=(-1);				/* NLS.TRK TO CATCH PROGRAMMING BUGS */
						NAH.FREE  =#SEC;
						NAH.#FREE =NAH.#FREE+1;

						WRITE(MAM)=NAH.PTR+RP;		/* BACK UP TO NLS.REV - MAY POINT TO TRACK HEAD */
						WRITE(MD )=FP;					/* NEW FP (MAY BE 0)   (MAY BE STORING IN THD HERE) */

						IF FP<>0 THEN DO;				/* UPDATE BACK POINTER */
							WRITE(MAM)=NAH.PTR+FP;
							WRITE(MAL)=NLS.REV;
							WRITE(MD )=RP;				/* RP MAY  POINT TO THD */
						END;

						#SEC=RP;							/* SET TO RP;  LOOK UP FP BELOW */

					END;

					ELSE IF PRIORLP<=NLS.LAST	/* SEE IF PART OF NLS WILL */
					THEN DO;							/* FIT                     */

						WRITE(MAM)=NAH.PTR+#SEC;	/* LOOK AT THIS NLS     */
						RLEN=0;							/* INIT LENGTH TO COPY  */
						DO WHILE ((RLEN+PRIORLP) ILE NLS.LAST);	/* LOOP WHILE MORE ROOM IN PRIOR NLS */
							WRITE(MAL)=OURFP+RLEN;
							IF READ(MD)
							THEN RLEN=RLEN+4;
							ELSE RLEN=RLEN+2;
						END;

						CALL COPY.EXT.MEM(NAH.PTR+#SEC,OURFP,
												NAH.PTR+J   ,PRIORLP, RLEN);
						WRITE(MAM)=NAH.PTR+J;
						WRITE(MAL)=NLS.LP;
						WRITE(MD )=PRIORLP+RLEN;
						WRITE(MAL)=READ(MD);
						WRITE(MD )=NLS.EOS;

						CALL COPY.EXT.MEM(NAH.PTR+#SEC,OURFP+RLEN,
												NAH.PTR+#SEC,NLS.FIRSTL,OURLP-(OURFP+RLEN));

						WRITE(MAM)=NAH.PTR+#SEC;
						WRITE(MAL)=NLS.FP;
						WRITE(MDI)=NLS.FIRSTL;
						WRITE(MD )=NLS.FIRSTL+(OURLP-(OURFP+RLEN));
						WRITE(MAL)=READ(MD);
						WRITE(MD )=NLS.EOS;

						#WRD = 0;					/* FUDGE CALL TO ADJUST.SEQUENCER.PTRS */
						CALL ADJUST.SEQUENCER.PTRS(J,PRIORLP-OURFP);

						K=#SEC;						/* SAVE TEMPORARILY                    */
						#SEC = J;					/* FOR CALL TO ADJUST.SEQUENCER.PTRS   */
						#WRD = PRIORLP+RLEN-1;

						CALL ADJUST.SEQUENCER.PTRS(K,NLS.FIRSTL-(PRIORLP+RLEN));

						#SEC = K;

					END;

					ELSE DO;							/* MAKE SURE #SEC STARTS AT NLS.FIRSTL */
						CALL SLIDE.DOWN;
					END;

				END;
				ELSE DO;
					CALL SLIDE.DOWN;
				END;

				WRITE(MAM)=NAH.PTR+#SEC;		/* POINT TO NEXT BLOCK  */
				#SEC=READ(MD);						/* BUT MAY BE ZERO      */

				I=I-1;

			END;

			ELSE I=0;								/* COULD BE EMPTY TRACK */

		END;

		/* IF OUR RECD.TRK DOES NOT HAVE ANY TIMBRE ON IT */
		/* THEN GO AHEAD AND COPY THE KEYBOARD TIMBRE FOR */
		/* THIS TRACK                                     */

		WRITE(MAM)=#PTR;									/* POINT TO IT */
		WRITE(MAL)=THD.CTIMB;							/* SEE WHAT TIMBRE IS ON TRACK */
		IF (READ(MD)=0)									/* NO TIMBRE CURRENTLY ON TRK  */
		AND (RECD.TRK<>KEYBOARD.TIMBRE.CONTROL)	/* THIS IS NOT THE SKT TRACK   */
		THEN DO;
			DISPLAY.EBL=0;							/* DISALLOW MESSAGES DURING THIS   */
			CALL COPY.TIMBRE(0,RECD.TRK);		/* COPY KEYBOARD TIMBRE ONTO TRACK */
			DISPLAY.EBL=1;							/* RE-ENABLE MESSAGES              */
		END;
	END;

	CALL TRK.HEAD.STORE(0,THD.CTBITS,0);	/* INITIALIZE TOGGLE BITS ON RECORD EXIT */

  IF UNSOLO.TRACK.AFTER.RECORDING THEN DO;	/* WE HAD TO COMPUTE WHICH TRK TO RECORD ON */
		WRITE(MAM)=TBUT.PTR;			/* CLEAR SOLOED BIT IN     */
		WRITE(MAL)=RECD.TRK;			/* SOLOED TRK LOOKUP TABLE */

		IF (READ(MD)&B.SOLOED.TRK)<>0					/* UNSOLO TRACK IF WE DID IT FOR THE GUY */
		THEN DO;
			WRITE(MD)=READ(MD)&(NOT B.SOLOED.TRK);	/* CLEAR SOLOED BIT */
			NUM.OF.SOLOED.TRACKS=NUM.OF.SOLOED.TRACKS-1;
		END;
		RECD.TRK=0;					/* TURN RECD.TRK OFF AGAIN */
	END;
	ELSE IF (CLEAR.RECD.TRK.AFTER.RECORDING != 0)
		RECD.TRK=0;											/* TURN RECD.TRK OFF AGAIN */

	IF (AUTO.RECD.TRK<>0) THEN DO;					/* WE HAD TO READY THIS TRACK FOR RECORD */
		WRITE(MAM)=TBUT.PTR;
		WRITE(MAL)=AUTO.RECD.TRK;
		IF (READ(MD) & B.READY.TRK) <> 0
		THEN DO;
			WRITE(MD) =READ(MD) & (NOT B.READY.TRK);	/* UNREADY TRACK */
			NUM.ENABLED.TRKS = NUM.ENABLED.TRKS - 1;	/* UPDATE COUNT  */
			NEW.SEQ.INFO = NEW.SEQ.INFO \ 4096;			/* CREATE EVENT  */
		END;
		AUTO.RECD.TRK=0;									/* ZERO AUTO RECORD TRACK FLAG */
		CALL DISPLAY.TRACK.BUTTONS;					/* NEW READYS TO DISPLAY */
	END;

	CALL COMPUTE.NUMB.LEFT;		/* RECOMPUTE # LEFT IF NEW FORMAT */

	IF (LENGTH.OVERFLOW<>0) THEN DO;	/* TIMBRE WOULD NOT FIT          */
		IF DEBUG THEN DO; END;
		/* NEED TO DO SOMETHING DIFFERENT HERE */
		CALL DISPLAY.ERR(11);			/* DISPLAY 'OUT OF MEMORY ERROR' */
	END;
	ELSE CALL DISPLAY.NUMB.LEFT;		/* DISPLAY # LEFT */

	CALL COMPUTE.ACTIVE.TRKS;		/* SET UP ACTIVE.TRACKS ARRAY AS REQUIRED */
	CALL DISPLAY.TRACK.BUTTONS;	/* AND DISPLAY */
	SMPTE.RECD=0;						/* DISABLE SMPTE RECORDING AFTER CALL     */

	CALL CHECK.MEMORY.FOR.RECORD;
	IF AUTO.PUNCH.ON = 0					/* IF NOT IN AUTO PUNCH NOW */
	THEN CALL TAKE.RECORD.TIME(1);	/* REMEMBER WHERE WE DID STOP RECORD */

END STOP.RECORD;


/* $PAGE */


STOP.RECD.MOVE.PLAY:  PROC PUBLIC SWAPABLE;	/* PROCEDURE TO STOP SEQUENCER */
  IF RECD<>0 THEN CALL STOP.RECORD;
  IF MOVE<>0 THEN CALL STOP.MOVE;
  IF PLAY<>0 THEN CALL STOP.PLAY;
END STOP.RECD.MOVE.PLAY;


STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS: PROC PUBLIC SWAPABLE;	/* STOP SEQUENCER & CLEAN UP OPTIONS */
  CALL STOP.RECD.MOVE.PLAY;
  XPOS=0; CONT=0;									/* TURN OFF SEQUENCER LIGHTS */
  CLEAR.ERAS.BUTTON();
  CALL DISPLAY.SEQUENCER.STATUS;				/* DISPLAY INFO HERE FOR CONVENIENCE */
END STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS;


BACK.UP.100.MSEC: PROC PUBLIC SWAPABLE;	/* GIVE THE SEQUENCER ROOM TO GET GOING */
	DCL I FIXED;

	LOAD 100; MUL SAMP.SPEED;			/* BACK UP BY 100 MSEC       */
	MWAIT; DIV 1000;						/* COMPUTE ACU AND ACCUM     */
	I=RES;									/* BACK UP PLAY.TIME.LSB     */
	PLAY.TIME.ACU=PLAY.TIME.ACU-REM;	/* GET ACU REMAINDER         */
	IF PLAY.TIME.ACU<0 THEN DO;
		PLAY.TIME.ACU=PLAY.TIME.ACU+1000;
		I=I+1;								/* BACK UP ONE MORE          */
	END;

	IF INC.MONO THEN DO;					/* SYNC UP CORRECTLY AT      */
		IF I ILT SHL(SEQ.MONO3,1)		/* VERY FIRST NOTE           */
		THEN I=SHL(SEQ.MONO3,1);		/* AT VERY SLOW SPEEDS       */
	END;
	ELSE DO;
		IF I ILT SHL(SEQ.SPL.TIM,1)
		THEN I=SHL(SEQ.SPL.TIM,1);
	END;

	IF  (PLAY.TIME.MSB=0)				/* IF WE WOULD BE BACKING UP */
	AND (I IGT PLAY.TIME.LSB)			/* TO BEFORE TIME ZERO       */
	THEN DO;
		PLAY.TIME.LSB=0;
		PLAY.TIME.ACU=0;
	END;
	ELSE DO;
		IF PLAY.TIME.LSB ILT I					/* WRAP IMMINENT       */
		THEN PLAY.TIME.MSB=PLAY.TIME.MSB-1;	/* SO BORROW FROM MSB  */
		PLAY.TIME.LSB=PLAY.TIME.LSB-I;		/* BACK UP THIS FAR    */
	END;

END BACK.UP.100.MSEC;

/* $SUBTITLE  PRESET.PLAY.TIME ROUTINE */


/* CALLED WITH :  PLAY = 0                       */
/*                TIME.BASE.MODE = 0             */

/* RETURNS WITH:  PLAY = 1                       */
/*                TIME.BASE.MODE = SET CORRECTLY */

PRESET.PLAY.TIME:  PROC (STARTIT) PUBLIC SWAPABLE;	/* STARTS SEQUENCER RUNNING */
  DCL STARTIT FIXED;		/* 1 TO ACTUALLY START IT.  0 TO JUST PRESET TIME */

	DCL MSB FIXED;
	DCL LSB FIXED;
	
	IF  ((MARK.BUTTON.MSB<>0)\(MARK.BUTTON.LSB IGE ZERO.TIME))
	AND (MARK.BUTTON.DISABLED=0)	/* MARK BUTTON ACTIVE */
	THEN DO;
		IF  (MARK.BUTTON.MSB <>MARK.BUTTON.VALM)	/* MARK BUTTON HAS CHANGED */
		OR  (MARK.BUTTON.LSB <>MARK.BUTTON.VALL)	/* MARK BUTTON HAS CHANGED */
		OR  (SAMP.CLICK.RATE <>MARK.CLICK.RATE )	/* CLICK RATE  HAS CHANGED */
		OR  (CLICK.TRACK.MODE<>MARK.CLICK.MODE )	/* CLICK MODE  HAS CHANGED */
		THEN CALL PLAY.INITIALIZE;	/* ONLY RECOMPUTE IF DIFFERENT */
	END;

	ELSE CALL PLAY.INITIALIZE;		/* COMPUTE NEW FIRST NOTE TIME FOR SOLOED TRACKS */

	IF OVERALL.LOOP<>0 THEN DO;	/* CHECK FOR TIME PAST LOOP */
		IF  ( LOOP.PLAY.TIME.MSB IGT GOBACK.PLAY.TIME.MSB)
		OR  ((LOOP.PLAY.TIME.MSB  =  GOBACK.PLAY.TIME.MSB)
		AND  (LOOP.PLAY.TIME.LSB IGE GOBACK.PLAY.TIME.LSB    ))
		THEN DO;
			CALL DISPLAY.ERR(28);
			RETURN;
		END;
	END;

	PLAY.TIME.MSB	 = LOOP.PLAY.TIME.MSB;	/* PRESET TO LOOP START POINT */
	PLAY.TIME.LSB	 = LOOP.PLAY.TIME.LSB;
	PLAY.TIME.ACU	 = LOOP.PLAY.TIME.ACU;
	BEAT.NUMBER		 = LOOP.BEAT.NUMBER;
	TRIGGER.CLICK	 = LOOP.TRIGGER.CLICK;
	LAST.CLICK		 = LOOP.LAST.CLICK;
	NEXT.CLICK		 = LOOP.NEXT.CLICK;
	NEXT.SEQ.EVENT  = LOOP.PLAY.TIME.LSB + 5000;	// Set shortly in future until things get settled.
	EST.RATE			 = NEXT.CLICK-LAST.CLICK;
	LOOP.TRIG.CLICK = 0;

	CALL COMPUTE.REAL.TIME.OF.NEXT.CLICK(LOC(ADDR(PLAY.TIME.MSB)));

	NEW.MOTION    = 1;

	CALL RESYNC.TIME.BASE;			/* SYNC EXT CLOCK TO NEW PLAY.TIME */
	PTRS.LOOPED    =0;				/* INDICATE MUST LOOP POINTERS WHEN WE SAMPLE TIME */
	LOOP.RESTART   =1;				/* PRETEND AS IF LOOP START        */
	ABORT.SEQ.NOTES=1;				/* BUT ABORT ALL SEQUENCER NOTES AS WELL */
	STOP.INFO.CUES =0;				/* ALLOW DTD CUES TO HAPPEN NOW    */
	LOD.CUE.LEN    =0;

	IF (STARTIT <> 0 && SMPTE.ONOFF == 0) THEN DO;

		NEW.BEAT.NUMBER = 1;			/* PRESENT TO USER */

		CALL BACK.UP.100.MSEC;		/* GIVE THE SEQUENCER ROOM TO GET GOING */

		IF MIDI.SYNC.OUT<>0			/* WE ARE SENDING MIDI REAL-TIME BYTES */
		THEN DO;
			IF (MIDI.SYNC.IS.TC)
			THEN DO;
				PREP.FOR.MTC.OUTPUT(PLAY.TIME.MSB, PLAY.TIME.LSB, TRUE);
				CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN */
			END;

			ELSE IF  ((MIDI.LIMIT.MSB=0)&(MIDI.LIMIT.LSB ILE ZERO.TIME))
			THEN DO;
				DISABLE;
				CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN    */
				CALL SEND.MIDI.START;		/* TELL MIDI DEVICES TO START */
				/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/
			END;

			ELSE DO;
				CALL MIDI.SONG.POS.PTR(MIDI.LIMIT.MSB, MIDI.LIMIT.LSB);	/* TELL MIDI DEVICES TO LOCATE */
				DISABLE;
				CALL START.TIME.BASE;		/* ENABLE SEQUENCER TO RUN       */
				CALL SEND.MIDI.CONTINUE;	/* TELL MIDI DEVICES TO CONTINUE */
				/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/
			END;
		END;
		ELSE CALL START.TIME.BASE;	/* ENABLE SEQUENCER TO RUN */
		UPDATE.MIDI=1;					/* CAUSES 302-SUB2 TO DO A FORCED MIDI UPDATE */

		CALL START.MIDI.SUSTAIN;	/* CHECK ALL TRACKS FOR CURRENT SUSTAIN STATE */
	END;

	ELSE BROADCAST.MTC();			/* ELSE IF MIDI TIME CODE, BROAD CAST OUT WHERE WE LOCATED TOO */

END PRESET.PLAY.TIME;
