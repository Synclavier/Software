/*	:SYNRSOU:04-SEQ:193-NEW3  SUBTITLE - Procedure to link up new Guitar notes onto 'new' list	*//*2002/07/31 - TY  - Further modified compute.gtpitch to improve the tuning accuracy of high notes on the Guitar.						 (The results now match the equivalent rounded algebraic solution.)1998/07/15 - TY  - Modified compute.gtpitch to improve the tuning accuracy of high notes on the Guitar.1998/06/22 - TY  - Added code to SCAN.AXE to accommodate the new Transpose Lock (blinking) feature.1996/09/25 - KJO - UPDATED FOR -7 CATALOG STRUCTURE1986/08/24 - TS  - PUT THD.ACTIVE.MIDI.RTES CODE IN1986/08/15 - CJ  - ADDED STRING.TIME1986/07/13 - CJ  - ADDED NORIG1986/06/28 - CJ  - USED KBD.SYNC.DELAY FOR PRESCAN1986/05/15 - "official" creation of release-M modules*/dcl equiv.kbd.key	fixed public;	/*	returns equivalent syncl II key - (0-87)	*/dcl remainder		fixed public;	/*	and remainder - plus and minus				*//*	external declarations needed for this file	*/dcl (pk.vol,c.vol,p.vol)		array	external;dcl (string.active)				array	external;dcl (c.per)							array	external;dcl (open.strings)				array	external;dcl (string.pitch)				array	external;dcl (standard.tuning)			data	external;dcl tuning.info					fixed	external;dcl tuning.error					fixed	external;dcl cur.st							fixed	external;dcl cur.stbank						fixed	external;dcl tuning.bank					array	external;dcl tuning.bank.in.memory		fixed	external;dcl (new.string.list)			array	external;dcl (new.in,new.out,s.new.in)	fixed	external;dcl (string.done)					fixed	external;dcl (next.string.done)			fixed	external;dcl (new.string.decays)			fixed	external;dcl g.split.loc					fixed	external;dcl (string.time)					array	external;compute.gtpitch:proc(str,per) public;		/*	compute frequency for passed string, period	*/	dcl (str, per)	fixed;	dcl (i, j, l)	fixed;//	write(5)="045304";write(4)="000351";	/*	load 15,289,020 into d4/d5	*/	//	Note the value quoted above wasn't quite accurate.  The Guitar hardware reports the number of microseconds per cycle of vibration.	//	For C1 this would be...	//	1,000,000 / (440^(-33/12)) = 15,289,026	//	...not 15,289,020 as indicated above.	//	Oddly enough, contrary to the documentation the value written to the D4567 wasn't 15,289,020 anyway	//	"000351"<<16 | "045304" = 15,289,028	write(5)=19138; write(4)=233;									//	(233<<16 | 19138) = 15,289,026	write(7)=per;														//	15,289,026/period = 1000 for C1 (lowest c of 61-note clavier)	if (shl(read(4),1) igt per) write(5) = read(5) + 1;	//	round	if (read(5) == 0) return 0;									//	special check to avoid crashing	i=read(5); j=0; l=0;												//	get result, initialize octave variables	if (i igt 1999)	{		dcl shift	fixed;		shift	= 1;		if (i igt 64000)	//	special case	(would loop infinitely otherwise)		{			dcl bExitLoop	boolean;			bExitLoop		= false;			write("313")	= shl(2000, shift);			while ((i igt read("313")) && (bExitLoop == false))			{	shift	= shift + 1;				if (read("313") == 64000)	bExitLoop		= true;				else								write("313")	= shl(2000, shift);			}		}		else		{			while (i igt shl(2000, shift))	shift	= shift + 1;		}		i = shr(i, shift) + (shr(i, shift-1) & 1);	//	round		if (i == 2000)		{			i		= 1000;			shift	= shift + 1;		}		load 1024; mul shift; j = res;					//	j = 1024 * shift;	}	else	{	//	NOTE: the maximum period allowed is 14000.  This will translate into i = 1092		do while i ilt 1000; i=i+i; l=l-1024; end;	/*	should never happen, but detect lower notes - bring into range of clavier	*/	}	i=i-1000;													/*	transpose into range 0 through 999	*/	write(mam)=ltb.ptr+shr(i,8); write(mal)=i;		/*	set up ptr to log table	*/	i=j+read(md);												/*	compute frequency number - 0 for lowest key of 61 note clavier.	*/	string.pitch(str)=i;										/*	save actual pitch of vibrating string for special tuning setup		*/	i=i-open.strings(str)+standard.tuning(str);		/*	correct for desired tuning	*/	do while i<0;i=i+1024;l=l-1024;end;					/*	bring up into valid octaves of clavier	*/	do while i>5160;i=i-1024;l=l+1024;end;				/*	also check for off end of clavier to right	*/	//	using 43 as an addend in the multipication below will effectively round the result after division to the nearest semitone	load i; uload 43;	mul 12; mwait; div 1024; equiv.kbd.key=res+12;	/*	compute the equivalent synclavier II key number	*/	load res; mul 256; mwait; div 3;						/*	re-compute corresponding frequency number	*/	if (rem == 2) then load res+1;						/*	perform ROUNDING to match syncl II exactly - yields 0, 85, 171, 256, 337, etc.	*/	j=res;	if quant then i=j;										/*	quantize - go directly to nearest semitone	*/	else if pfilt then do;									/*	apply pitch filter	*/		dcl k	fixed;		if i igt j+20 then do;								//	pitch is over dead band			k=i-j-20;											//	get amount over			load k; mul 32; mwait; div 17;				//	scale the amount by (1024/12)/((1024/12)-(2*20))																	//	(This maps any movement in the area between two adjacent dead-bands to proportional																	//	movement spanning the area between the two adjacent tempered pitches.)			i=j+read(5);										//	add scaled amount to tempered pitch		end;		else if i ilt j-20 then do;						//	pitch is under dead band			k=j-20-i;											//	get amount under			load k; mul 32; mwait; div 17;				//	scale amount by (1024/12)/((1024/12)-(2*20))			i=j-read(5);										//	subtract scaled amount from tempered pitch		end;		else i=j;												//	within dead band - go directly to tempered pitch	end;	remainder=i-j+l;											/*	compute & return plus or minus remainder (based on A440/1.000 tuning)	*/	return i+l;													/*	Should be ok to return negative numbers now	*/end compute.gtpitch;/*	$PAGE - routines to read & store special guitar tunings	*/tune.guitar:proc public swapable;	/*	call this procedure to store current measurements	*/	dcl (i,j,k)	fixed;	DO I=0 TO 5;	/*	CHECK EACH STRING	*/		DISABLE;			J=STRING.ACTIVE(I);K=C.PER(I);	/*	GET DATA CHANGE DURING INTERRUPTS	*/		ENABLE;		IF J<>0 THEN DO;	/*	ONLY ACTIVE STRINGS	*/			CALL COMPUTE.GTPITCH(I,K);	/*	COMPUTE NEW PITCH. IGNORE COMPUTED PITCH, BUT STRING.PITCH IS   STORED	*/			OPEN.STRINGS(I)=STRING.PITCH(I);	/*	TUNE TO OPEN STRINGS	*/		END;	END;end tune.guitar;restore.tuning:proc public swapable;	dcl (i)	fixed;	do i=0 to 5; open.strings(i)=standard.tuning(i); end;	/*	use guitar is tuned to e-a-d-g-b-e	*/	cur.st=0; cur.stbank=0;end restore.tuning;dcl tuning.bank.device	fixed public;dcl tuning.bank.sector	fixed public;read.tuning.bank:proc public swapable;	dcl tundata data ('.TUNDATA');	if inc.mono<>0 then call stop.disk;	if (locate(tundata,0) || locate(tundata,-2)) then do;	/*	look for '.TUNDATA' in path or system catalog	*/		tuning.bank.device=f#ms_sector;		tuning.bank.sector=f#ls_sector;		tuning.error=0;		if (tuning.bank.sector + tuning.info) ilt tuning.bank.sector then tuning.error=1;		call readdata(tuning.bank.device+tuning.error,tuning.bank.sector+tuning.info,tuning.bank,48);	/*	read bank	*/		tuning.error=0;		cur.stbank=tuning.info; tuning.bank.in.memory=1;	end;	else do;	/*	error occurred	*/		call display.err(4);		tuning.error=1;	/*	file not there	*/	end;end read.tuning.bank;read.tuning :proc public swapable;	dcl (i)	fixed;	if tuning.bank.in.memory=0 then do;		tuning.error=1; return;	/*	disallow if no bank	*/	end;	do i=0 to 5; open.strings(i)=tuning.bank(tuning.info*6+i); end;	/*	get tuning from bank	*/	cur.st=tuning.info;end read.tuning;store.tuning:proc public swapable;	dcl (i,j)	fixed;	i=tuning.info;							/*	save tuning#	*/	tuning.info=cur.stbank;				/*	read in bank	*/	call read.tuning.bank;				/*	read it in		*/	if tuning.error<>0 then return;	/*	done				*/	do j=0 to 5; tuning.bank(i*6+j)=open.strings(j); end;	/*	store in bank	*/	j = 0;	if (tuning.bank.sector + cur.stbank) ilt cur.stbank then j = 1;	call writedata(tuning.bank.device+j,tuning.bank.sector+cur.stbank,tuning.bank,48);	/*	read bank	*/	cur.st=i;end store.tuning;compute.guitar.octave.ratio:proc(pitch) public;	/*	compute guitar pitch from octave ratio	*/	dcl pitch	fixed;	pitch=(pitch-2816)*octratio/1000;		/*	correct for octave ratio	*/	if read(4) ige 500 then pitch=pitch+1;	/*	perform rounding				*/	return pitch+2816;							/*	add in from a-440 again		*/end compute.guitar.octave.ratio;/*	$PAGE - Routine to check guitar for new notes	*/SCAN.AXE:proc public;	/*	LOOKS FOR NEW NOTES		*/	DCL (I,J,K,L,M,NEW.STRINGS)				FIXED;	DCL (TRANSPOSING,T.STR.#,T.XPOS.DIST)	FIXED;	DISABLE;	/*	FOR QUICK TEST	*/		S.NEW.IN=NEW.IN;				/*	SIMPLIFY PROBLEMS BY SAMPLING NEW.IN	*/		NEW.STRING.DECAYS="100";	/*	NO REAL NEW ONES YET, OBVIOUSLY. BUT SET STRING 6 BIT TO KEEP UPDATE ROUTINE FROM LOOKING AT HELD NOTES	*/	ENABLE;	STRING.DONE=STRING.DONE\NEXT.STRING.DONE;	/*	STOP ANY 1-LOOP NOTES STARTED LAST TIME	*/	NEXT.STRING.DONE=0;NEW.STRINGS=0;	DO WHILE NEW.OUT<>S.NEW.IN;	/*	PROCESS EACH NEW STRING	*/		DISABLE;			I			=NEW.STRING.LIST (NEW.OUT);			NEW.OUT	=NEW.OUT+1;IF NEW.OUT=NEW.MAX THEN NEW.OUT=0;		ENABLE;		IF (I&256)<>0 THEN DO;		/*	MEANS A DECAY - STOP ANY STRINGS	*/			I=I&255;						/*	EXTRACT STRING NUMBER	*/			I=BITS(I);					/*	GET BIT FOR THIS STRING	*/			IF (NEW.STRINGS&I)<>0 THEN NEXT.STRING.DONE=NEXT.STRING.DONE\I;	/*	SET FLAG TO STOP NOTE ONE CYCLE AFTER STARTING IT	*/			ELSE STRING.DONE=STRING.DONE\I;	/*	ELSE STOP CURRENT NOTE	*/			IF I=T.STR.# THEN TRANSPOSING=0;	/*	CLEAR FLAG - NOT TRANSPOSING ANY MORE	*/		END;		ELSE DO;							/*	MEANS START A NEW STRING	*/			NEW.STRINGS=NEW.STRINGS\BITS(I);	/*	SET BIT TO INDICATE A NEW STRING THIS CYCLE	*/			J=COMPUTE.GTPITCH(I,C.PER(I));	/*	GET GUITAR PITCH.  HOPEFULLY C.PER HAS NOT CHANGED YET!!	*/			IF (RECALL.STATE<>0) THEN G.SPLIT.LOC=I;	/*	DEFINE SPLIT KEYBOARD LOC	*/			IF XPOS<>0 THEN DO;		/*	SET UP FOR TRANPOSITION		*/				TRANSPOSING=1;				T.STR.#=I;				T.XPOS.DIST=EQUIV.KBD.KEY;				/*	GET DISTANCE TO TRANSPOSE				*/				CALL TRANSPOSE.TRACKS(T.XPOS.DIST);	/*	SET XPOS - TRANSPOSE TO NEAREST KEY	*/				/*	CALL ADVANCE.CLOCK;	*/				/*	ADVACE CLOCK UPON STRING PRESS		*/			END;			/*	$PAGE - ALLOCATE BLOCK FOR GUITAR NOTE	*/			ELSE DO;	/*	ALLOCATE BLOCK	*/				NPTR=NFREEP;							/*	GET NOTE BLOCK		*/				IF NPTR<>0 THEN DO;					/*	SET UP BLOCK		*/					NFREEP=CORE(NFREEP);				/*	UNLINK BLOCK		*/					WRITE("313")=NPTR;				/*	USE R13 FOR SPEED	*/					WRITE("373")=KBDLIST;			/*	NFPTR = KBDLIST	*/					KBDLIST=NPTR;						/*	KEYBOARD NOTES CAN GO IN ANY ORDER		*/					IF (RECD<>0) THEN DO;			/*	RECORDING			*/						WRITE("373")=0;				/*	TIMBRE =				*/						WRITE("373")=RECD.TRK;		/*	TRACK  =				*/					END;					ELSE DO;								/*	NOT RECORDING		*/						IF  (SPLIT.KEYBOARD<>0)		/*	SPLIT KEYBOARD		*/						AND (I>G.SPLIT.LOC)			/*	LOWER HALF			*/						THEN WRITE("373")=1;			/*	USE SPLIT TB		*/						ELSE WRITE("373")=0;						WRITE("373")=0;				/*	TRACK	=		*/					END;					WRITE("373")=0;					/*	NORIG	=		*/					WRITE("373")=EQUIV.KBD.KEY;	/*	KEYN	=		*/					IF VTRACK THEN DO;				/*	VOLUME TRACKING	*/						WRITE("373")=(B.GUI\B.VOL)\SHL(PK.VOL(I),8)\I;	/*	SBITS =	*/					END;					ELSE DO;								/*	NO VOLUME TRACKING		*/						WRITE("373")=(B.GUI\B.VOL\SHL(255,8))\I;			/*	SBITS =	*/					END;					WRITE(MAM)=TRK.HEAD;				/*	POINT TO LOOK UP TABLE			*/					WRITE(MAM)=READ(MD);				/*	FOR KEYBOARD						*/					WRITE(MAL)=THD.ACTIVE.MIDI.RTES;	/*	CHECK FOR VELOCITY ENABLED	*/					IF ((READ(MD)&B.VELOCITY)<>0)	/*	IF MIDI VELOCITY ENABLED		*/					OR (MEMORIZE.RTE<>0)				/*	OR VELOCITY USED					*/					THEN DO;						LOAD PK.VOL(I); MUL RTE.MAX; K=RES; DIV 255;	/*	COMPUTE 0-RTE.MAX	*/						WRITE("373")=RES;				/*	VELD - STORE 0-RTE.MAX AS VELOCITY	*/					END;					ELSE WRITE("373")=RTE.MAX;		/*	ELSE MAX	*/					IF DCONT THEN SBITS=SBITS\(B.TIE+B.ART);	/*	PERFORM ARTICULATED TIE IF USER WANTS TO CAN EARLIER NOTE	*/					OTIML= STRING.TIME(I)+KBD.SYNC.DELAY;					GDATA=SHL(PK.VOL(I),8)+I;	/*	SAVE STRING NUMBER PLUS VOLUME - MUST BE NONZERO	*/					GPITCH=J;						/*	SAVE RAW PITCH				*/					NUPDT=REMAINDER;				/*	SAVE REMAINDER FOR INITIAL COMPUTATION - ONLY DONE FOR GUITAR NOTES	*/					QME=0;							/*	NOTE IS NOT FROM MIDI	*/					CHORIG=0;						/*	NO MIDI CHANNEL ORIGIN	*/				END;									/*	OF DO IF WAS ABLE TO GET A NOTE BLOCK	*/			END;	/*	OF ACTUAL BLOCK ALLOCATION (VERSUS TRANSPOSE)	*/		END;	/*	OF DO IF STRING WAS STILL VIBRATING WHEN 'SCANAXE' WAS CALLED			*/	END;	/*	OF DO WHILE LOOP	*/	/*	$PAGE - CHECK FOR END OF NOTE, OR GUITAR TRANSPOSITION	*/	IF TRANSPOSING THEN DO;	/*	IF TRANSPOSING - CHECK FOR PITCH CHANGES ON STRING			*/		I=C.PER(T.STR.#);		/*	GET CURRENT PERIOD FOR STRING, BEFORE POSSIBLE INTERRUPT	*/		IF (XPOS=0)				/*	CHECK FOR TRANSPOSE BUTTON BEING RELEASED		*/		OR (((STRING.DONE\NEXT.STRING.DONE\NEW.STRING.DECAYS)&BITS(T.STR.#))<>0)		THEN TRANSPOSING=0;	/*	THROUGH TRANSPOSING AFTER STRING RELEASE, OR XPOS BUTTON RELEASED		*/		ELSE DO;					/*	CHECK FOR POSSIBLE NEW PITCH	*/			CALL COMPUTE.GTPITCH(T.STR.#,I);	/*	GET PITCH	*/			IF EQUIV.KBD.KEY<>T.XPOS.DIST			THEN DO;				/*	TRANSPOSE TRACKS WITHOUT ADVANCING BEAT	*/				T.XPOS.DIST=EQUIV.KBD.KEY;				CALL TRANSPOSE.TRACKS(T.XPOS.DIST);			END;		END;	END;END SCAN.AXE;