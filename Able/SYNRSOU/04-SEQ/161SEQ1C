/* 161SEQ1C  $TITLE  SCAN TRACKS TO START UP NOTES MID-STREAM   Modified:   08/05/91 - PF  - look up duration from patch list for poly RAM events   09/27/90 - cj  - added start up control (used startup.value)   01/25/90 - MWH - Fix "300 msec delay starting cues" bug (from EditView)*//* Start.Up.Notes.In.Middle is called from the main loop whenever     *//* New.Sequencer.Forward.Motion is <> 0.   This routine looks at all  *//* the sequencer tracks and tries to find cues that can be triggered. *//* It also looks at music tracks and starts up music notes in the     *//* middle.                                                            */dcl Look.At.Real.Notes.Only  lit '0';  /* 1 = back up N real notes    */                                       /* 0 = back up N note records  */dcl Records.To.Look.Back.At  lit 'startup.value'; /* # of note records to  look  */                                        /* back at                     */START.UP.NOTES.IN.MIDDLE:PROC PUBLIC swapable;  dcl (i,j)      fixed;  dcl (trk)      fixed;  dcl (BaseTrk)  fixed static;  dcl (time) (1) fixed;  dcl (temp) (1) fixed;  dcl (comp) (1) fixed;  dcl (msb,lsb)  fixed;  dcl ptlptr     fixed;  dcl Key#       fixed;  dcl Cueid      fixed;  dcl Evptr      fixed;  dcl Poly.Evt   fixed;  /* Make sure sequencer is still moving forward: */  if (time.base.mode = 0)                 /* only start notes when */  then do;                                /* actual output needed  */     New.Sequencer.Forward.Motion = 0;     Send.All.Cue.Info            = 0;     return;  end;  /* Wait for actual SMPTE lockup to occur to provide micro-precise */  /* sound file synchronization:                                    */  if (time.base.mode = 2)  or (time.base.mode = 3)  or (time.base.mode = 7)  then return;  /* make sure any prior cue trigger requests get sent over: */  if dtd.max.secs <> 0                    /* if we have a DTD     */  then do;                                /* then wait for cue    */     if (lod.cue.len <> 0)                /* triggers and new     */     or (new.motion  <> 0)                /* motions to be        */     then do;                             /* sent over.           */        lod.update.time = real.milliseconds - lod.update.rate;  /* send update now       */        return;     end;  end;  else lod.cue.len = 0;                   /* always leave at 0    */                                          /* if no dtd            */  /* If first time through,  see if there are any   */  /* cue tracks at all.  If so,  then set variables */  /* to return here for more processing,  else      */  /* we can just quit:                              */  /* Note: if New.Sequencer.Forward.Motion = 1      */  /*       then start both poly, fm, and cues.      */  /*       if New.Sequencer.Forward.Motion = 2      */  /*       then start up cues only (happens after   */  /*       direct-to-disk reset).                   */  if New.Sequencer.Forward.Motion <= 2  then do;     i = 0;     do trk = num.kbd.tracks to max.tracks-1;        WRITE(MAM)=TRK.HEAD;                   /* LOOK UP TABLE     */        WRITE(MAL)=TRK;                        /* INDEX             */        if read(md)<>0 then do;                /* trk head exists   */           if   (trk.head.lookup(trk,thd.active) <> 0)  /* trk is activ  */           and  (LOAD.SEQ.GLOBALS          (trk) <> 0)  /* with info     */           and  (#wrd                            <> 0)  /* and notes     */           and  (#anyr                           <> 0)  /* behind us     */           and  ((New.Sequencer.Forward.Motion = 1)     /* and all trks  */           or    (trk.head.lookup(trk,thd.cue.track)<>0))  /* or is cue  */           then do;              i = i + 1;              /* save current #NMSB time away so we can detect notes that are */              /* at or after this time when we come back to actually look     */              /* at each track.   This will avoid triggering notes twice      */              /* that lie near the front of the start-up point.               */              if #anyf <> 0 then do;  /* if pointing to note - only start those before */                 call trk.head.store(trk, thd.start.msb, #NMSB);                 call trk.head.store(trk, thd.start.lsb, #NLSB);              end;              else do;                /* start any notes before -1, -1 (ie all) */                 call trk.head.store(trk, thd.start.msb, -1);                 call trk.head.store(trk, thd.start.lsb, -1);              end;           end;           else do;   /* else mark track has having no notes to start */              call trk.head.store(trk, thd.start.msb, 0);              call trk.head.store(trk, thd.start.lsb, 0);           end;        end;     end;     BaseTrk = Num.Kbd.Tracks;     if i = 0   /* if no active tracks with notes,  then done */     then do;        New.Sequencer.Forward.Motion = 0;        Send.All.Cue.Info            = 0;     end;     else do;        New.Sequencer.Forward.Motion = 3;        /* send over a null 'cue trigger record'. This will likely    */        /* be sent over with the first '130' message to the dtd,      */        /* when the synclavier is not ready to play.   This will      */        /* cause us to not send any more start up notes in middle     */        /* records until the DTD is ready for us.                     */        if dtd.max.secs <> 0           /* if we have a DTD            */        then do;           write(mam) = lod.cue.ptr;   /* send over cue trig record   */           rpc 8;                      /* with id# = 0 to cause       */           write(mdi) = 0;             /* things to wait.             */           lod.cue.len = 8;        end;     end;     return;  end;  /* wait a short while to give the DTD a chance to get up to speed: */  if New.Sequencer.Forward.Motion < 6  then do;     New.Sequencer.Forward.Motion = New.Sequencer.Forward.Motion + 1;     return;  end;  /* now process each track, one at a time,  to make sure all */  /* notes get started:                                       */  do while BaseTrk < Max.Tracks;     trk = BaseTrk;     BaseTrk = BaseTrk + 1;     WRITE(MAM)=TRK.HEAD;                   /* LOOK UP TABLE     */     WRITE(MAL)=TRK;                        /* INDEX             */     if read(md)<>0 then do;                /* trk head exists   */        time(0) = trk.head.lookup(trk, thd.start.msb);        time(1) = trk.head.lookup(trk, thd.start.lsb);        /* compute what the sequencer time will be approx 800 msec in */        /* front of us.   only bother to start up notes in middle     */        /* that last at least that far in front of us.                */        call COPY32(loc(addr(advanced.play.time.msb)), comp);        call ADD16(prescan*10, comp);        call Map.Real.Time.To.Sequence.Time(comp, comp);        if   (trk.head.lookup(trk,thd.active) <> 0)  /* trk is activ  */        and  (LOAD.SEQ.GLOBALS          (trk) <> 0)  /* with info     */        and  (#wrd                            <> 0)  /* and notes     */        and  (#anyr                           <> 0)  /* behind us     */        then do;           if (trk.head.lookup(trk,thd.cue.track)<>0)   /* if cue track  */           then do;                                     /* then handle   */              i=0;              do while  (i           <  20                ) /* only look at 20 notes per track         */              and       (lod.cue.len <  (lod.cue.max - 32)) /* only look back until cue stack is full */              and       (#anyr       <> 0                 );/* and notes behind us                    */                 call Backup.To.Prior.Real.Note;                 call Look.Up.Note.Info;       /* get note info                  */                 if  (isa.rest.note=0)         /* never know what you get when */                 and (isa.rte.note =0)         /* backing up to the start      */                 and (isa.ilp.note =0)                 then do;                    i=i+1;                     /* count to prevent computer load */                    Key# = (#W2&"77") \ (SHR(#W1&"074000",6)); /* get key */                    write(mam) = #ptr;         /* point to trk head       */                    WRITE(MAL)  = THD.CTIMB;  /* LOOK UP CURRENT TIMBRE NUMBER */                    WRITE("313")= READ(MD);   /* GET CUR TIMBRE      */                    WRITE(MAM)  = TIM.HEAD;                    WRITE(MAL)  = READ("313");                    WRITE(MAM)  = READ(MD);   /* PT TO TIMBRE HEAD   */                    WRITE(MAL)  = TIM.PARTIAL.POINTERS + SHR(KEY#, 8);                    PTLPTR      = READ(MD);   /* SAVE PTR TO PTL     */                    WRITE(MAL)  = TIM.KBDTAB.PTR       + SHR(KEY#, 8);                    IF READ(MD)<>0 THEN DO;   /* MAKE SURE KBDTAB IS THERE */                       WRITE(MAM) = TIM.PTR + READ(MD) - 1;                       WRITE(MAL) = KEY#;     /* PICK UP CUE ID OR PTR     */                       CUEID      = READ(MD); /* GET CUE ID OR POINTER     */                       /* look up event info if this is an event:          */                       if Cueid < 0 then do;  /* means this is event       */                          call p.lookup(ptlptr-Cueid+ev.in.msb);                          write("300") = addr(copy.buf(0));                          rpc (ev.name - ev.in.msb);                          write("360") = read(mdi);                          call p.lookup(ptlptr-Cueid+ev.cue.id);                          Cueid = read(md);                          Evptr = addr(copy.buf(0));                       end;                       else Evptr = 0;    /* no event info for cue trigs */                       if Cueid <> 0      /* if id exists, then send it  */                       then do;                          j = lod.cue.len;   /* save how much info is there now */                          call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)),                                                              loc(addr(msb)));                          call Store.Real.Time.Event.Info                           (Cueid, loc(addr(msb)),     /* cue id,  time    */                           32768 \ 1, loc(addr(#W1)), /* bits, w1-w4      */                           32768 \ trk, loc(Evptr));  /* trk, event info  */                          /* move the block if info we just added to the  */                          /* buffer up in ext memory so that the new      */                          /* record gets inserted on the front.  this     */                          /* make it seem like we scanned the sequence    */                          /* forward.                                     */                          if lod.cue.len <> j then do; /* copy the new block */    write(mam) = lod.cue.ptr + shr(j,8); /* into misc.buf.     */    write(mal) = j;                             call copy.in(addr(misc.buf(0)), lod.cue.len - j); /* move memory up to  */    call copy.ext.mem(lod.cue.ptr, 0, /* make room for the  */                      lod.cue.ptr, lod.cue.len - j, /* new block.         */                      j); /* copy the new block */    write(mam) = lod.cue.ptr; /* back out.          */    call copy.out(addr(misc.buf(0)), lod.cue.len - j);                          end;                       end;                    end;                              end;                  /* of check for ilp    */              end;                     /* of loop looking     */              /* If we found some cues for this track,  send them over */              /* to the dtd right now so they do not get lost.  Just   */              /* return here;  we will come back later to process      */              /* the next track                                        */              if lod.cue.len <> 0              then do;                 lod.update.time = real.milliseconds - lod.update.rate;  /* send update now       */                 return;              end;           end;           /* else handle music tracks */           else if (inc.mono=0)        /* only do for fm/poly since we cannot */                                       /* start up mono notes in the middle   */           and  ((time(0)\time(1))<>0) /* and we should do music tracks       */           then do;              /* Clear start flags here so we don't accidentally look */              /* at the flags twice:                                  */              call trk.head.store(trk, thd.start.msb, 0);              call trk.head.store(trk, thd.start.lsb, 0);              i=0;              do while  (i           <  Records.To.Look.Back.At)   /* only look at N   notes per track */              and       (#anyr       <> 0                      )   /* and notes behind us                    */              and       (nfreep      <> 0                      );  /* and note block is available            */                 if Look.At.Real.Notes.Only                  then call Backup.To.Prior.Real.Note;                 else call Backup.To.Prior.Note;                 call Look.Up.Note.Info;       /* get note info                  */                 i=i+1;                        /* count to prevent computer load */                 if  (isa.rest.note=0)         /* never know what you get when */                 and (isa.rte.note =0)         /* backing up to the start      */                 and (COM32(loc(addr(#NMSB)), time) = LW#ILT)                 then do;                    /* if is a ilp note,  then assume it is an ilp */                    /* start record.  only keep going back if we   */                    /* have not looped yet:                        */                    if isa.ilp.note                    then do;                       if trk.head.lookup (trk,THD.ILPCTR) <> 0                       then i = 10000;                    end;                    /* else normal note record: play note (maybe)  */                    else do;                       /* COMPUTE DURATION - IF ZERO DURATION, DON'T QUEUE UP NOTE */                       /* FIRST CHECK TO SEE IF THIS IS ACTUALLY A  */                       /* RAM EVENT TRIGGER IN WHICH CASE WE WILL   */                       /* EXTRACT THE DURATION FOR THIS "NOTE" FROM */                       /* THE PATCH LIST.                           */                       POLY.EVT = 0;             /* INIT POLY EVENT BOOL TO FALSE */                       KEY#=(#W2&"77")+12;       /* GET KEY NUMBER */                       IF (#W4&LOWER.KEY)<>0 THEN KEY#=KEY#-12;                       IF (#W4&RAISE.KEY)<>0 THEN KEY#=KEY#+12;                       WRITE(MAM)  = #PTR;                       WRITE(MAL)  = THD.CTIMB;  /* LOOK UP CURRENT TIMBRE NUMBER */                       WRITE("313")= READ(MD);   /* GET CUR TIMBRE      */                       WRITE(MAM)  = TIM.HEAD;                       WRITE(MAL)  = READ("313");                       WRITE(MAM)  = READ(MD);   /* PT TO TIMBRE HEAD   */                       WRITE(MAL)  = TIM.POLY.EVENT;                       IF (READ(MD)<>0) THEN DO;              /* POLY EVENTS USED IN THIS TIMBRE */                          WRITE(MAL)=TIM.PARTIAL.POINTERS;                          J         =READ(MD);                /* SAVE POINTER TO OUR PARTIAL */                          WRITE(MAL)=TIM.KBDTAB.PTR;          /* POINT TO KBD LOOKUP TABLE */                          WRITE(MAM)=TIM.PTR+READ(MD)-1;                          WRITE(MAL)=(KEY#*KLT.SIZE)+KLT.PATCH.TIM.PTR;                          IF READ(MD)<>0 THEN DO;             /* MAKE SURE KBDTAB EXISTS */                             CALL P.LOOKUP(J+READ(MD)+PT.TLEN);                             DO J=PT.TLEN TO PT.KHZ;          /* COPY INFO WE NEED INTO MISC.BUF */                                MISC.BUF(J)=READ(MDI);                             END;                             IF  (MISC.BUF(PT.EVENT)<>0)      /* ONLY IF THIS IS A NON-LOOPING POLY "EVENT" */                             AND (MISC.BUF(PT.ONLOOP)<>3)                             THEN DO;                                POLY.EVT=1;                                /* PT.TLEN (TOTAL LENGTH) IS STORED IN THE  */                                /* PARTIAL AREA IN 32 BIT FORMAT.  CHANGE   */                                /* TO 24 BIT FORMAT FOR CONVERSION ROUTINES */                                MSB=SHL(MISC.BUF(PT.TLEN),8)\SHR(MISC.BUF(PT.TLEN+1),8);                                LSB=MISC.BUF(PT.TLEN+1)&255;                                CALL INDEX_TO_TIME(0,MSB,LSB,MISC.BUF(PT.KHZ),MISC.BUF(PT.STEREO));                                /* NOW CONVERT RESULT TO 32 BIT MSEC DURATION */                                LOAD TIME.SECONDS;                                MUL  1000;                                MSB = URES;                                LSB = RES;                                LSB = LSB + TIME.MILLISECONDS;                                IF LSB ILT TIME.MILLISECONDS                                THEN MSB = MSB + 1;                                /* AND FINALLY, MAP THIS DURATION TO SEQUENCER */                                /* UNITS FOR COMPUTATIONS BELOW.               */                                call Map.Real.Duration.To.Sequence.Duration(loc(addr(NEXT.EVENT.MSB)),loc(addr(MSB)),loc(addr(MSB)));                             END;                          END;                       END;                       IF (POLY.EVT=0) THEN DO;     /* NOT A POLY EVENT */                          MSB=#W1&"074000";         /* UPPER DURATION BITS */                          LSB=SHR(#W2,6);           /* LOWER DURATION BITS */                       END;                       IF (MSB\LSB)<>0 THEN DO;     /* NOTE HAS SOME DURATION - START NOTE */                          IF  (POLY.EVT=0)          /* NOT A POLY EVENT */                          AND (MSB<>0) THEN DO;     /* INFO IN UPPER BITS */                             LSB=LSB\SHR(MSB&"014000",1);                             MSB=MSB&"060000";                             IF MSB<>0 THEN DO;     /* LONG SHIFT     */                                LOAD LSB;                                MUL DUR.MUL.DATA(ROT(MSB,3)&3);                                MSB=URES; LSB=RES;                             END;                          END;                          /* compute end time for note.  start the note */                          /* if it lasts beyond where we are playing    */                          /* at the current time.                       */                          call ADD32(loc(addr(#NMSB)), loc(addr(msb)), temp);                          if COM32(temp, comp) = lw#IGT                          then do;                             NPTR=NFREEP;                              NFREEP=CORE(NFREEP);                             WRITE("313")=NPTR;           /* USE R13 FOR SPEED */                             WRITE("373")=0;              /* NFPTR - ALWAYS 0  */                                                       WRITE(MAM)=#PTR;             /* POINT TO THD         */                             WRITE(MAL)=THD.CTIMB;        /* GET CURRENT TIMBRE # */                             WRITE("373")=READ(MD);       /* TIMBRE =             */                             WRITE(MAL)=THD.TRK;                             WRITE("373")=READ(MD);       /* TRACK  =             */                             WRITE("373")=3;              /* NORIG  =             */                             WRITE("373")=KEY#;            /* KEYN   =             */                             WRITE("373")=SHR(#W3,8);      /* SBITS  =             */                             WRITE("373")=#W3&255;         /* VELD   =             */                             OTIMM=#NMSB;                             OTIML=#NLSB;                             FENDM=temp(0);                             FENDL=temp(1);                             call Map.Sequence.Time.To.Real.Time(loc(addr(OTIMM)),                                                                 loc(addr(OTIMM)));                             call Map.Sequence.Time.To.Real.Time(loc(addr(FENDM)),                                                                 loc(addr(FENDM)));                             IF INC.AXE<>0 THEN GDATA=0;     /* NOT A GUITAR NOTE */                             IF (#W4<>VEL.NOTE) THEN DO;     /* PROCESS INFO */                                SBITS=SBITS\(#W4&"177400");                             END;                             IF INC.MONO<>0 THEN DO;                                WRITE(MAL)=THD.WRD;          /* SAVE POINTER TO */                                TFLAG     =READ(MDI);        /* NOTE RECORD IN  */                                REMAIN    =READ(MD );        /* CASE OVERLAY    */                             END;                            /* MODE            */                             QME=0;                          /* NON-MIDI       */                             /* Note: don't bother to check the tie */                             /* bits here,  because we know it is   */                             /* time to process the note.           */                             /* Note: put the block on the FRONT    */                             /* of SEQLIST,  because we are         */                             /* scanning the sequencer backwards    */                             /* at this point.                      */                             if seqlist = 0 then do;                                seqlist = nptr;                                seqlast = nptr;                             end;                             else do;                                nfptr   = seqlist;                                seqlist = nptr;                             end;                          END;                       END;                    end;                 end;              end;              /* if any notes were scanned,  return here so we will */              /* re-enter above for the next track.                 */              if i <> 0              then return;           end;        end;                        /* must look at trk    */     end;                           /* of trk head there   */  end;                              /* of loop over tracks */  /* wait a while longer after checking all tracks because the */  /* queing routines make some special checks only while       */  /* new.sequencer.forward.motion  <> 0.                       */  if New.Sequencer.Forward.Motion < 9  then do;     New.Sequencer.Forward.Motion = New.Sequencer.Forward.Motion + 1;     return;  end;  /* Done with all note startups: */  if Send.All.Cue.Info <> 0               /* if dtd restarted in middle of sending */  then New.Sequencer.Forward.Motion = 2;  /* cue info,  then start again from top  */  else New.Sequencer.Forward.Motion = 0;  /* end send only cues.   else done.      */  Send.All.Cue.Info = 0;end START.UP.NOTES.IN.MIDDLE;