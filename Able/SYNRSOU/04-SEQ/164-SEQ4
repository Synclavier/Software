/* :SYNRSOU:04-SEQ:164-SEQ4  $TITLE  MORE SEQUENCER ROUTINES */

/*
Modified:
2000/11/16 - TY  - Fixed a bug in ALLOCATE.TRK.HEADER() that prevented proper initialization
						 of track volumes and output routings for all tracks > MULTI.MAX
						 Changed default outputs for tracks > MULTI.MAX from 0 to (track_number mod MULTI.MAX)
1998/06/20 - TY  - Added initialization of THD.RTES to ALLOCATE.TRK.HEADER to prevent the
						 unnecessary recording of RTEs when recording onto a newly allocated track.
1991/04/24 - PF  - Init pedal 1 of THD.LIVE.RTES to RTE.MAX instead of zero
						 in ALLOCATE.TRK.HEADER
1991/02/01 - CJ  - fixed "Grover Jackson" track slide bug.
1991/01/30 - MWH - Report which tracks have had new notes
1988/03/14 - CJ  - SENT NEW CUE TRACK CONSTANTS OVER ON TRACK HEAD ALLOCATE
1987/11/17 - CJ  - MAKE ALLOCATE.NEXT.NLS PUBLIC
1986/10/09 -TS,EG- FIXED THD.NN.MSB BUG IN INSERT.NOTE.RECORD
1986/05/15 - "official" creation of release-M modules
*/


/* ALLOCATE.NAH.BLOCK RETURNS 0 IF OUT OF ROOM */
/* ELSE RETURNS RELATIVE PTR TO NAH BLOCK      */

ALLOCATE.NAH.BLOCK: PROC FIXED PUBLIC;	/* ALLOCATES ONE SECTOR OF NAH STORAGE FOR TRK HEAD OR NLS */
	DCL (I) FIXED;

	IF NAH.FREE<>0 THEN DO;
		I=NAH.FREE;
		WRITE(MAM)=NAH.PTR+NAH.FREE;
		NAH.FREE=READ(MD);
		NAH.#FREE=NAH.#FREE-1;
		RETURN I;
	END;

	IF (NAH.PTR+NAH.LEN) IGE BNK.PTR
	THEN DO;										/* OUT OF ROOM DURING CONVERSION */
		IF BNK.LEN<>0 THEN DO;				/* TOSS BANK & MOVE UP FURTHER */
			BNK.PTR=BNK.PTR+BNK.LEN;
			BNK.LEN=0;
		END;
	END;

	IF (NAH.PTR+NAH.LEN) IGE BNK.PTR		/* FINALLY OUT OF ROOM */
	THEN RETURN 0;

	I=NAH.LEN;
	NAH.LEN=NAH.LEN+1;

	RETURN I;									/* RETURN REL. PTR TO BLOCK */

END ALLOCATE.NAH.BLOCK;

DEALLOCATE.NAH.BLOCK: PROC (SEC) PUBLIC SWAPABLE;	/* PUTS SECTOR ONTO FREE LIST */
	DCL SEC FIXED;

	WRITE(MAM)=NAH.PTR+SEC;		/* LINK SEC ON TO FREE LIST  */
	WRITE(MDI)=NAH.FREE;			/* LINK ON TO FREE LIST      */
	WRITE(MDI)=(-1);				/* STORE (-1) IN NLS.REV AND */
	WRITE(MD )=(-1);				/* NLS.TRK TO CATCH PROGRAMMING BUGS */
	NAH.FREE  =SEC;
	NAH.#FREE =NAH.#FREE+1;

END DEALLOCATE.NAH.BLOCK;

/* $SUBTITLE  ROUTINE TO ALLOCATE AND INIT FIRST NOTE LIST SEGMENT ON TRK */


ALLOCATE.FIRST.NLS: PROC FIXED PUBLIC SWAPABLE;
	DCL I FIXED;

	I=ALLOCATE.NAH.BLOCK;		/* GET THE FIRST NLS BLOCK */
	IF I=0 THEN RETURN 0;		/* NO ROOM - BOMB OUT      */

	WRITE(MAM)=#PTR;			/* RESTORE PTR TO TRK HEAD */
	WRITE(MAL)=THD.FOR;			/* ACCESS FORWARD PTR      */
	WRITE(MD )=I;				/* POINT TO 1ST NLS        */

	WRITE(MAL)=THD.WRD;
	WRITE(MDI)=NLS.FIRSTL;
	WRITE(MD )=I;				/* THD.SEC                 */

	WRITE(MAL)=THD.LP.WRD;
	WRITE(MDI)=NLS.FIRSTL;
	WRITE(MD )=I;				/* THD.LP.SEC              */

	WRITE(MAL)=THD.NUM.NLS;
	WRITE(MD )=1;

	WRITE(MAM)=NAH.PTR+I;		/* INIT NLS HEADER INFO    */
	WRITE(MDI)=0;				/* NLS.FOR                 */
	WRITE(MDI)=#PTR-NAH.PTR;	/* NLS.REV                 */
	WRITE(MDI)=#TRK;			/* NLS.TRK                 */
	WRITE(MDI)=NLS.FIRSTL;		/* NLS.FP                  */
	WRITE(MDI)=NLS.FIRSTL;		/* NLS.LP                  */
	WRITE(MDI)=0;				/* ZERO RESERVED LOC 5     */
	WRITE(MDI)=0;				/* ZERO RESERVED LOC 6     */
	WRITE(MD )=0;				/* ZERO RESERVED LOC 7     */

	WRITE(MAL)=NLS.FIRSTL;		/* FIRST NOTE GOES HERE    */
	WRITE(MD )=NLS.EOS;

	#SEC=I; #WRD=NLS.FIRSTL;	/* INIT THESE VARS         */

	RETURN I;

END ALLOCATE.FIRST.NLS;


/* $SUBTITLE - CHANGE THD INFO - CHANGE PLAY AND LOOP POINTERS */


CHANGE.THD.INFO:PROC (SEC,WRD);	/* MOVE PLAY AND LOOP INFO TO NEW SECTOR */
	DCL (SEC,WRD) FIXED;

	WRITE(MAM)=#PTR;
	WRITE(MAL)=THD.WRD;				/* ADVANCE PLAY AND LOOP */

	IF  (READ(MDI)=#WRD)				/* POINTERS TO THE NEW   */
	AND (READ(MD )=#SEC)				/* SECTOR SINCE TIMES    */
	THEN DO;								/* DO NOT CHANGE         */
		WRITE(MAL)=THD.WRD;
		WRITE(MDI)=WRD;
		WRITE(MD )=SEC;
	END;

	WRITE(MAL)=THD.LP.WRD;
	IF  (READ(MDI)=#WRD)
	AND (READ(MD )=#SEC)
	THEN DO;
		WRITE(MAL)=THD.LP.WRD;
		WRITE(MDI)=WRD;
		WRITE(MD )=SEC;
	END;

	#SEC=SEC;
	#WRD=WRD;

END CHANGE.THD.INFO;

/* $PAGE - ALLOCATE ANOTHER NLS ONCE THERE IS ONE */


/* ALLOCATE.NEXT.NLS - GET ANOTHER NLS AND LINK IT ON AFTER */
/* THE CURRENT NLS (#SEC)                                   */

/* PASS A 1 TO MOVE THE PLAY POINTERS TO THE BEGINNING      */
/* OF THE NEW SECTOR (IF = #SEC, #WRD).                     */

/* #SEC, #WRD ALWAYS CHANGED                                */

ALLOCATE.NEXT.NLS:PROC (MOVEPTRS) PUBLIC SWAPABLE;
	DCL (NLS,FP)   FIXED;
	DCL (MOVEPTRS) FIXED;

	NLS=ALLOCATE.NAH.BLOCK;			/* GET ANOTHER NLS BLOCK    */

	IF NLS=0 THEN RETURN 0;			/* NO ROOM - BOMB OUT       */

	WRITE(MAM)=NAH.PTR+#SEC;		/* RESTORE MAM TO PRIOR NLS */
	WRITE(MAL)=NLS.FOR;				/* ACCESS FORWARD PTR       */
	FP=READ(MD);						/* SAVE PREV FORWARD PTR    */
	WRITE(MD)=NLS;						/* PTR POINTS TO NEW NLS    */

	IF FP<>0 THEN DO;					/* UPDATE REVERSE POINTER   */
		WRITE(MAM)=NAH.PTR+FP;		/* IN NEXT BLOCK            */
		WRITE(MAL)=NLS.REV;
		WRITE(MD )=NLS;
	END;

	WRITE(MAM)=NAH.PTR+NLS;			/* INITALIZE THE NLS        */
	WRITE(MDI)=FP;						/* NLS.FOR                  */
	WRITE(MDI)=#SEC;					/* NLS.REV                  */
	WRITE(MDI)=#TRK;					/* NLS.TRK                  */
	WRITE(MDI)=NLS.FIRSTL;			/* NLS.FP                   */
	WRITE(MDI)=NLS.FIRSTL;			/* NLS.LP                   */
	WRITE(MDI)=0;						/* ZERO RESERVED LOC 5      */
	WRITE(MDI)=0;						/* ZERO RESERVED LOC 6      */
	WRITE(MD )=0;						/* ZERO RESERVED LOC 7      */

	WRITE(MAL)=NLS.FIRSTL;			/* INITIALIZE THE EOS       */
	WRITE(MD )=NLS.EOS;

	WRITE(MAM)=#PTR;					/* FIX UP TRACK HEAD        */
	WRITE(MAL)=THD.NUM.NLS;
	WRITE(MD )=READ(MD)+1;

	IF MOVEPTRS<>0
	THEN CALL CHANGE.THD.INFO(NLS,NLS.FIRSTL);	/* MOVE PLAY, LOOP, AND #SEC #WRD  INFO TO NEW SECTOR */
	ELSE DO;
		#SEC=NLS;
		#WRD=NLS.FIRSTL;
	END;

	RETURN 1;
END ALLOCATE.NEXT.NLS;


/* ALLOCATE.PRIOR.NLS - GET ANOTHER NLS AND LINK IT ON BEFORE */
/* THE CURRENT NLS (#SEC)                                     */

ALLOCATE.PRIOR.NLS:PROC PUBLIC SWAPABLE;
	DCL (NLS,RP) FIXED;

	NLS=ALLOCATE.NAH.BLOCK;			/* GET ANOTHER NLS BLOCK    */

	IF NLS=0 THEN RETURN 0;			/* NO ROOM - BOMB OUT       */

	WRITE(MAM)=NAH.PTR+#SEC;		/* RESTORE MAM TO NLS       */
	WRITE(MAL)=NLS.REV;				/* ACCESS REVERSE           */
	RP=READ(MD);						/* GET CURRENT REV P        */
	WRITE(MD)=NLS;						/* PTR POINTS TO NEW NLS    */

	WRITE(MAM)=NAH.PTR+RP;
	WRITE(MAL)=NLS.FOR;				/* OR MAY BE THD.FOR        */
	WRITE(MD )=NLS;

	WRITE(MAM)=NAH.PTR+NLS;			/* FILL OUT NEW NLS         */
	WRITE(MDI)=#SEC;					/* NLS.FOR                  */
	WRITE(MDI)=RP;						/* NLS.REV                  */
	WRITE(MDI)=#TRK;					/* NLS.TRK                  */
	WRITE(MDI)=NLS.FIRSTL;			/* NLS.FP                   */
	WRITE(MDI)=NLS.FIRSTL;			/* NLS.LP                   */
	WRITE(MDI)=0;						/* ZERO RESERVED LOC 5      */
	WRITE(MDI)=0;						/* ZERO RESERVED LOC 6      */
	WRITE(MD )=0;						/* ZERO RESERVED LOC 7      */

	WRITE(MAL)=NLS.FIRSTL;
	WRITE(MD )=NLS.EOS;

	WRITE(MAM)=#PTR;
	WRITE(MAL)=THD.NUM.NLS;
	WRITE(MD )=READ(MD)+1;

	CALL CHANGE.THD.INFO(NLS,NLS.FIRSTL);	/* MOVE PLAY AND LOOP INFO TO NEW SECTOR */

	RETURN 1;

END ALLOCATE.PRIOR.NLS;

/* $SUBTITLE  ROUTINE TO ALLOCATE AND INIT A TRACK HEADER */


/* ALLOCATE.TRK.HEADER RETURNS 0 IF IT FAILS */
/* ELSE RETURNS AN ABS PTR TO TRK HEAD       */

ALLOCATE.TRK.HEADER:PROC(TRK) FIXED PUBLIC SWAPABLE;	/* ALLOCATES AND INITS NAH BLOCK FOR TRK HEAD */
	DCL (TRK,THP,I) FIXED;

	THP=ALLOCATE.NAH.BLOCK;					/* GET TRACK HEADER        */
	IF THP=0 THEN RETURN 0;					/* NONE AVAILABLE          */

	WRITE(MAM)=NAH.PTR+THP;

	IF (INC.POLY)\(MODC<>0) THEN DO;		/* ZERO OUT THE SECTOR     */
		RPC 256;
		WRITE(MDI)=0;
	END;
	ELSE DO I=0 TO 63;						/* ZERO OUT THE SECTOR     */
		WRITE(MDI)=0; WRITE(MDI)=0;
		WRITE(MDI)=0; WRITE(MDI)=0;
	END;

	WRITE(MAM)=NAH.PTR;						/* STORE REL PTR IN NAH TABLE */
	WRITE(MAL)=TRK;
	WRITE(MD )=THP;

	THP=NAH.PTR+THP;							/* COMPUTE ABSOLUTE PTR    */

	WRITE(MAM)=TRK.HEAD;						/* SAVE ABS PTR IN TRK HEAD TABLE */
	WRITE(MAL)=TRK;
	WRITE(MD )=THP;

	WRITE(MAM)=THP;							/* INITIALIZE TRACK HEADER */
	WRITE(MAL)=THD.TRK;
	WRITE(MD )=TRK;
	WRITE(MAL)=THD.TVOL;						/* TRACK VOLUME  */
	WRITE(MD )=1000;
   WRITE(MAL)=THD.MIDX;						/* TRACK VOLUME  */
   WRITE(MD )=0;


	IF MULTI.THERE<>0 THEN DO;				/* TRACK ROUTING */
		WRITE(MAL)=THD.TROU;					/* MUTLI ROUTING */
		write(5) = TRK - NUM.KBD.TRACKS;
		write(7) = MULTI.MAX;
		write(5) = read(4);					//	read(4) = (TRK - NUM.KBD.TRACKS) mod MULTI.MAX
		write(4) = 64;							//	addend
		write(6) = 1;							//	initiate add
		write(md) = shl(read(5), 8) | read(5);
	END;

	WRITE(MAL)=THD.ORATIO;					/* INDIVIDUAL OCTAVE RATIO */
	WRITE(MD )=OCTRATIO;
	WRITE(MAL)=THD.STIMB;					/* STARTING TIMBRE */
	WRITE(MD )=0;

	WRITE("313") = shl(rte.max,8);

	WRITE(MAL)=THD.RTES;					/* INITIALIZE "PREVIOUS" RTE VALUES					  */
	WRITE(MDI)=RTE.MAX;					/* PEDAL 1													  */
	rpc 3; WRITE(MDI) = READ("313");	/* PEDAL 2, MOD WHEEL, BREATH CONTROLLER			  */
	rpc 4; WRITE(MDI) = 0;				/* PITCH WHEEL, RAW RIBBON, +FRIBBON, -FRIBBON	  */

	WRITE(MAL)=THD.LIVE.RTES;			/* INITIALIZE "LIVE" RTE VALUES						  */
	WRITE(MDI)=RTE.MAX;					/* PEDAL 1													  */
	rpc 3; WRITE(MDI) = READ("313");	/* PEDAL 2, MOD WHEEL, BREATH CONTROLLER			  */
	rpc 4; WRITE(MDI) = 0;				/* PITCH WHEEL, RAW RIBBON, +FRIBBON, -FRIBBON	  */

	WRITE(MAM)=BAS.PTR;					/* INDIVIDUAL SCALE FROM SEQ.SCALE */
	DO I=0 TO 11;
		COPY.BUF(I)=READ(MDI);
	END;

	WRITE(MAM)=THP;						/* RESTORE PTR TO TRK HEAD */
	WRITE(MAL)=THD.SCALE;
	DO I=0 TO 11;
		WRITE(MDI)=COPY.BUF(I);
	END;

	CALL COMPUTE.ACTIVE.TRKS;			/* SET THD.ACTIVE FOR TRK HEAD  */
	CALL COMPUTE.MISC.INFO;				/* AND SET CPLIST, ARLIST STUFF */

	NEW.MOTION             = 1;		/* SEND NEW CUE TRACK CONSTANTS       */
	NEW.CUE.TRACK.SETTINGS = 1;		/* OVER AFTER TRACK HEAD ALLOCATE     */

	RETURN THP;

END ALLOCATE.TRK.HEADER;


/* $SUBTITLE  ROUTINE TO ADJUST SEQUENCER PTRS AFTER INSERT/DELETE */


/* ADJUST.SEQUENCER.PTRS:                                        */

/* CALLED WHEN MOVING SEQUENCER DATA AROUND (NON REAL-TIME).     */
/* USUALLY THIS IS AFTER DOING A NOTE INSERT OR DELETE.          */

/* BEFORE CALLING THIS ROUTINE, SET #TRK TO THE ABSOLUTE TRK     */
/* NUMBER OF THE TRACK ON WHICH THE CHANGE OCCURRED. SET #SEC    */
/* AND #WRD TO THE LOCATION OF THE CHANGE (RELATIVE TO NAH.PTR). */
/* PASS THE ROUTINE THE NEW SECTORE NUMBER TO WHICH PTRS WHICH   */
/* POINTED TO THE OLD LOCATION SHOULD BE ADJUSTED (NEW.SEC),     */
/* AND PASS THE NUMBER OF WORDS BY WHICH THE WORD POINTERS       */
/* SHOULD BE ADJUSTED (DELTA).                                   */


ADJUST.SEQUENCER.PTRS: PROC (NEW.SEC,DELTA) PUBLIC;
	DCL NEW.SEC FIXED;	/* NEW DEST SECTOR                        */
	DCL DELTA   FIXED;	/* AMOUNT TO ADJUST WORD PTRS BY (+ OR -) */
	DCL NPTR    FIXED;	/* ********* LOCAL NPTR *********** */

	WRITE(MAM)=#PTR;							/* POINT TO TRK HEAD        */

	WRITE(MAL)=THD.WRD;						/* CHECK PLAY POINTER       */
	IF  (READ(MDI)>#WRD)						/* IF > THEN CHANGE         */
	AND (READ(MD )=#SEC)
	THEN DO;
		WRITE(MAL)=THD.WRD;
		WRITE(MDI)=READ(MD)+DELTA;
		WRITE(MD )=NEW.SEC;
	END;

	WRITE(MAL)=THD.LP.WRD;					/* CHECK LOOP POINTER       */
	IF  (READ(MDI)>#WRD)						/* IF > THEN CHANGE         */
	AND (READ(MD )=#SEC)
	THEN DO;
		WRITE(MAL)=THD.LP.WRD;
		WRITE(MDI)=READ(MD)+DELTA;
		WRITE(MD )=NEW.SEC;
	END;

	WRITE(MAL)=THD.ILS.WRD;					/* CHECK ILP POINTER        */
	IF  (READ(MDI)>=#WRD)					/* USE *** >= *** HERE      */
	AND (READ(MD ) =#SEC)
	THEN DO;
		WRITE(MAL)=THD.ILS.WRD;
		WRITE(MDI)=READ(MD)+DELTA;
		WRITE(MD )=NEW.SEC;
	END;

	WRITE(MAL)=THD.ILE.WRD;					/* CHECK ILP POINTER        */
	IF  (READ(MDI)>=#WRD)					/* USE *** >= *** HERE      */
	AND (READ(MD ) =#SEC)
	THEN DO;
		WRITE(MAL)=THD.ILE.WRD;
		WRITE(MDI)=READ(MD)+DELTA;
		WRITE(MD )=NEW.SEC;
	END;

	/* ALSO LOOK THROUGH ACTIVE NOTE LIST */
	/* AND ADJUST ANY BACK PTRS TO NOTES  */
	/* WE ARE IN THE PROCESS OF RECORDING */

	IF RECD<>0 THEN DO;						/* ONLY IF RECORDING        */
		NPTR=NOTELIST;							/* PICK UP FIRST NOTE BLOCK */
		DO WHILE NPTR<>0;						/* PROCESS EACH ONE         */

			IF #SEC=RECS THEN DO;				/* SECTOR MATCHES - CHECK WORD PTR */
				WRITE("313")=RECW;				/* SAVE IN REGISTER FOR SPEED      */
				IF #WRD<=READ("313") THEN DO;	/* BACK PTR ABOVE EDIT POINT       */
					RECW=READ("313")+DELTA;		/* ADJUST PTR BY DELTA             */
					RECS=NEW.SEC;					/* AND ADJUST SEC PTR              */
				END;
			END;

			NPTR=NFPTR;							/* PICK UP POINTER TO NEXT NOTE */
		END;	/* OF NOTE LOOP */
	END;

END ADJUST.SEQUENCER.PTRS;


/* $SUBTITLE - SPLIT OR MOVE NOTE LIST SEGMENT */

/* CALLED TO COPY PART OF A NOTE LIST SEGMENT INTO A NEW BLOCK */
/* PASSED #SEC, #WRD POINTING INTO A NOTE LIST SEGMENT         */
/* WILL MOVE INFO UP IN NOTE LIST SEGMENT IF ROOM              */

SPLIT.OR.MOVE.NLS:PROC(RLEN);
	DCL (RLEN)        FIXED;
	DCL (WRD,SEC,LEN) FIXED;
	DCL (I,J)         FIXED;

	WRITE(MAM)=NAH.PTR+#SEC;		/* COMPUTE LENGTH OF WORDS        */
	WRITE(MAL)=NLS.LP;				/* TO COPY UP OR COPY INTO NEW    */
	LEN=READ(MD)-#WRD;				/* BLOCK                          */

	WRD=#WRD; SEC=#SEC;				/* SAVE ORIGINAL #WRD, #SEC       */

	IF READ(MD)<=NLS.LAST THEN DO;	/* SEE IF WE CAN SHUFFLE DATA     */
		#WRD=#WRD+RLEN;					/* IN SAME BLOCK.   JUST MOVE     */
	END;										/* DATA IN SAME SECTOR IF SO      */
	ELSE DO;									/* ELSE GET ANOTHER NLS           */
		IF ALLOCATE.NEXT.NLS(0)=0		/* ALLOCATE NLS; DO NOT MOVE PTRS */
		THEN RETURN 0;
	END;

	WRITE(MAM)=NAH.PTR+SEC;			/* GET ORIGINAL INFORMATION       */
	WRITE(MAL)=WRD;

	IF (INC.POLY) OR (MODC<>0)		/* READ IN OLD INFO               */
	THEN DO;
		WRITE("300")=ADDR(MISC.BUF(0));
		RPC LEN;
		WRITE("360")=READ(MDI);
	END;
	ELSE CALL COPY.IN(ADDR(MISC.BUF(0)),LEN);

	WRITE(MAL)=NLS.LP;				/* UPDATE LP TO REFLECT END OF    */
	WRITE(MD )=WRD;					/* SECTOR. DO NOT BOTHER WITH EOS */

	WRITE(MAM)=NAH.PTR+#SEC;		/* POINT TO WHERE WE PUT NEW INFO */
	WRITE(MAL)=#WRD;

	IF (INC.POLY) OR (MODC<>0)
	THEN DO;
		WRITE("300")=ADDR(MISC.BUF(0));
		RPC LEN;
		WRITE(MDI)=READ("360");
	END;
	ELSE CALL COPY.OUT(ADDR(MISC.BUF(0)),LEN);

	WRITE(MD )=NLS.EOS;				/* PUT AN EOS AT END OF SECTOR    */
	WRITE(MAL)=NLS.LP;				/* UPDATE LP;  MAY OVERWRITE LP   */
	WRITE(MD )=#WRD+LEN;				/* WRITTEN ABOVE IF SAME SECTOR   */

	I=#SEC;			/* DATA WAS WRITTEN OUT TO THIS SECTOR           */
	J=#WRD-WRD;		/* DELTA                                         */

	#SEC=SEC;		/* RESTORE POINTERS TO ORIGINAL WORD             */
	#WRD=WRD;

	CALL ADJUST.SEQUENCER.PTRS(I,J);

	RETURN 1;
END SPLIT.OR.MOVE.NLS;

/* $SUBTITLE  CHECK.POINTER.TIMES ROUTINE */


CHECK.POINTER.TIMES: PROC;

	WRITE(MAM)  =#PTR;				/* SET PTR TO TRK HEAD  */
	WRITE(MAL)  =THD.WRD;			/* LOOK AT PLAY PTRS    */
	WRITE("313")=ADDR(#WRD);		/* SET UP REG FOR SPEED */

	IF  (READ(MDI)=READ("373"))	/* THD.WRD = EDIT #WRD  */
	AND (READ(MD )=READ("353"))	/* THD.SEC = EDIT #SEC  */
	THEN DO;								/* COPY INFO            */
		WRITE(MAL)=THD.NMSB;
		WRITE("313")=ADDR(#NMSB);	/* SET UP REG FOR SPEED */
		WRITE(MDI)=READ("373");		/* COPY EDIT #NMSB OVER THD.NMSB */
		WRITE(MDI)=READ("373");		/* COPY EDIT #NLSB OVER THD.NLSB */
		WRITE(MDI)=READ("373");		/* COPY EDIT #LMSB OVER THD.LMSB */
		WRITE(MD )=READ("373");		/* COPY EDIT #LLSB OVER THD.LLSB */
		WRITE(MAL)=THD.ANY.FOR;
		WRITE("313")=ADDR(#ANYF);	/* SET UP REGISTER FOR SPEED        */
		WRITE(MDI)=READ("373");		/* COPY EDIT #ANYF OVER THD.ANY.FOR */
		WRITE(MD )=READ("353");		/* COPY EDIT #ANYR OVER THD.ANY.REV */
	END;

	WRITE(MAL)=THD.LP.WRD;			/* LOOK AT LOOP PLAY PTRS */
	WRITE("313")=ADDR(#WRD);		/* SET UP REG FOR SPEED   */

	IF  (READ(MDI)=READ("373"))	/* THD.LP.WRD = EDIT #WRD */
	AND (READ(MD )=READ("353"))	/* THD.LP.SEC = EDIT #SEC */
	THEN DO;								/* COPY INFO              */
		WRITE(MAL)=THD.LP.NMSB;
		WRITE("313")=ADDR(#NMSB);	/* SET UP REG FOR SPEED */
		WRITE(MDI)=READ("373");		/* COPY EDIT #NMSB OVER THD.LP.NMSB */
		WRITE(MDI)=READ("373");		/* COPY EDIT #NLSB OVER THD.LP.NLSB */
		WRITE(MDI)=READ("373");		/* COPY EDIT #LMSB OVER THD.LP.LMSB */
		WRITE(MD )=READ("373");		/* COPY EDIT #LLSB OVER THD.LP.LLSB */
		WRITE(MAL)=THD.LP.ANY.FOR;
		WRITE("313")=ADDR(#ANYF);	/* SET UP REGISTER FOR SPEED           */
		WRITE(MDI)=READ("373");		/* COPY EDIT #ANYF OVER THD.LP.ANY.FOR */
		WRITE(MD )=READ("353");		/* COPY EDIT #ANYR OVER THD.LP.ANY.REV */
	END;

END CHECK.POINTER.TIMES;


/* $SUBTITLE  NON-REAL-TIME ROUTINE TO INSERT A REST NOTE ON A TRACK */


/* INSERT.REST.RECORD:                                             */

/*    BEFORE CALLING, SET #TRK TO THE ABSOLUTE TRACK NUMBER OF THE */
/*    TRACK TO INSERT ON. SET (#SEC,#WRD) TO THE REL LOCATION AT   */
/*    WHICH INSERT IS TO OCCUR.  IF THE ROUTINE IS SUCCESSFUL,     */
/*    IT WILL RETURN A 1.  IF NOT, IT WILL RETURN A 0. THIS        */
/*    ROUTINE INSERTS A REST WITH A START DELTA OF 0 AND AN        */
/*    EXTENDED REST OF 0. #TRK,#SEC, AND #WRD WILL NOT BE AFFECTED */
/*    BY THIS ROUTINE                                              */


INSERT.REST.RECORD: PROC (RLEN) FIXED PUBLIC;
	DCL (RLEN)      FIXED;	/* 2 OR 4 WORD REST RECORD */
	DCL (DELTA,FP)  FIXED;
	DCL (NLS,LEN)   FIXED;
	DCL (I,J)       FIXED;

	/* Create a system event when a note is added or removed */
	/* from the sequencer:                                   */

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 4;
	WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
	WRITE(MAL) = #TRK;					/* REMEMBER TRACK # ON NEW.SEQ.INFO */
	WRITE(MD) = "177777";				/*   "NEW NOTES" OR "NEW TIMBRE"    */

	IF #SEC=0 THEN DO;					/* TRK HAS NO NOTE LIST SEGMENTS */
		IF ALLOCATE.FIRST.NLS=0			/* SET UP FIRST NOTE SEGMENT     */
		THEN RETURN 0;						/* NO ROOM - BOMB OUT            */
	END;


	WRITE(MAM)=NAH.PTR+#SEC;			/* POINT TO NLS                  */


	/* EXTRACT DELTA FOR INSERT */

	WRITE(MAL)=#WRD;							/* GET CURRENT DELTA IF NEEDED */
	IF READ(MD)=NLS.EOS THEN DELTA=0;	/* NO DELTA IF AT END OF TRACK */
	ELSE DELTA=SHR(READ(MD),1)&1023;		/* ELSE USE THIS NOTE'S DELTA  */


	/* CHECK FOR ROOM IN PRIOR SECTOR */
	/* ON LINKED LIST:                */

	WRITE(MAL)=NLS.FP;						/* POINTER TO FIRST WORD      */

	IF  (READ(MD)=#WRD)						/* INSERTING AT FRONT OF NLS  */
	THEN DO;

		WRITE(MAL)=NLS.REV;					/* SEE IF NLS BEHIND US       */
		IF READ(MD)<>(#PTR-NAH.PTR)		/* BACK POINTER IS NOT TO THD */
		THEN DO;									/* SEE IF ROOM THERE          */

			WRITE(MAM)=NAH.PTR+READ(MD);	/* BACK UP TO PRIOR NLS       */
			WRITE(MAL)=NLS.LP;				/* SEE IF ROOM IN IT          */

			IF READ(MD)<=NLS.LAST			/* ROOM IN PRIOR NLS FOR NOTE */
			THEN DO;
				CALL CHANGE.THD.INFO(READ(MAM)-NAH.PTR,READ(MD));	/* MOVE PLAY AND LOOP INFO TO NEW SECTOR */
				GOTO CONTINUE.INSERT;
			END;

		END;

		IF #WRD<>NLS.FIRSTL				/* WE WANT TO BE AT BOTTOM */
		THEN DO;								/* GARBAGE COLLECT         */
			IF ALLOCATE.PRIOR.NLS=0		/* GET PRIOR ONE           */
			THEN RETURN 0;
		END;

	END;


	CONTINUE.INSERT:;

	WRITE(MAM)=NAH.PTR+#SEC;			/* RESTORE MAM POINTER           */

	IF #WRD>NLS.LAST THEN DO;			/* # WORD IS AT END OF SECTOR    */
		IF ALLOCATE.NEXT.NLS(1)=0		/* GET ANOTHER ONE, POINT TO IT  */
		THEN RETURN 0;						/* NO ROOM - BOMB OUT            */
		WRITE(MAM)=NAH.PTR+#SEC;		/* POINT TO IT                   */
	END;


	WRITE(MAL)=NLS.LP;					/* SEE IF NOTES AFTER US         */

	IF READ(MD)>#WRD THEN DO;			/* MUST SPLIT UP NOTE SEG        */
		IF SPLIT.OR.MOVE.NLS(RLEN)=0	/* CREATE GAP OR ALLOCATE NLS    */
		THEN RETURN 0;
		WRITE(MAM)=NAH.PTR+#SEC;		/* POINT TO IT                   */
	END;

	/* INSERT NOTE HERE */

	WRITE(MAL)=#WRD;						/* PUT NOTE RECORD INTO NLS  */

	IF RLEN=4 THEN DO;					/* 4 WORD LONG REST          */
		WRITE(MDI)="100001"\SHL(DELTA,1);	/* LONG REST WITH DELTA FROM ORIGINAL NOTE */
		WRITE(MDI)=0;
		WRITE(MDI)=0;
		WRITE(MD )=VEL.NOTE;
	END;
	ELSE DO;									/* 2 WORD NORMAL REST        */
		WRITE(MDI)=SHL(DELTA,1);
		WRITE(MD )=REST.NOTE;
	END;

	WRITE(MAL)=NLS.LP;
	IF READ(MD)=#WRD THEN DO;			/* IF APPENDING TO NLS  */
		WRITE(MD)=#WRD+RLEN;				/* WRITE OUT NEW NLS.LP */
		WRITE(MAL)=READ(MD);				/* POINT TO IT          */
		WRITE(MD )=NLS.EOS;				/* STORE NLS.EOS HERE   */
	END;

	/* HOUSE CLEANING */

	#ANYF=1;

	I=#SEC; J=#WRD;						/* SAVE ORIGINAL INFO FOR CHECKS     */

	CALL ADVANCE.TO.NEXT.NOTE;			/* ADVANCE FOR POINTER & TIME CHECKS */

	IF #ANYF<>0 THEN DO;					/* TRASH DELTA FIELD IF THERE        */
		WRITE(MD )=READ(MD)&"174001";	/* ZAP DELTA FIELD                   */
		#NMSB=#LMSB;						/* CORRECT #NMSB FOR DELTA FIELD     */
		#NLSB=#LLSB;						/* ADDED IN TWICE                    */
	END;

	WRITE(MAM)=#PTR;						/* CHECK PLAY TIMES                  */
	WRITE(MAL)=THD.WRD;

	IF  (READ(MDI)=J)						/* INSERTING REST AT PLAY PTR        */
	AND (READ(MD )=I)
	THEN DO;
		IF MOVE.SPEED>=0 THEN DO;
			IF  (RECD=0)					/* IF NOT RECORDING     */
			AND (((#LMSB IGT ADVANCED.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
			OR   ((#LMSB  =  ADVANCED.SEQ.TIME.MSB)	/* PLAYED YET        */
			AND   (#LLSB IGE ADVANCED.SEQ.TIME.LSB)))
			THEN DO;											/* MAKE SURE IT WILL GET PLAYED */
				WRITE(MAL)=THD.ANY.FOR;					/* NOTE NOW EXISTS HERE         */
				WRITE(MD )=1;
				CALL REBUILD.EVENT.QUEUE;
			END;
			ELSE DO;							/* BUMP PLAY POINTER OVER NOTE              */
				CALL STORE.#.INFO(THD.NMSB);
			END;
		END;
		WRITE(MAM)=#PTR;
	END;

	WRITE(MAL)=THD.LP.WRD;

	IF  (READ(MDI)=J)						/* INSERTING REST AT LOOP PTR  */
	AND (READ(MD )=I)
	THEN DO;

		IF ((#LMSB IGT LOOP.SEQ.TIME.MSB))
		OR ((#LMSB  =  LOOP.SEQ.TIME.MSB)
		AND (#LLSB IGE LOOP.SEQ.TIME.LSB))
		THEN DO;
			WRITE(MAL)=THD.LP.ANY.FOR;
			WRITE(MD )=1;
		END;
		ELSE DO;								/* BUMP LOOP POINTER OVER NOTE */
			CALL STORE.#.INFO(THD.LP.NMSB);			/* SKIP OVER IT    */
		END;
	END;

	CALL BACKUP.TO.PRIOR.NOTE;			/* BACK UP TO REST NOTE WE INSERTED */

	RETURN 1;

END INSERT.REST.RECORD;


/* $SUBTITLE  NON-REAL-TIME ROUTINE TO INSERT A NOTE ON A TRACK */


/* PASSED:

	GLOBAL INFO IN #TRK,#PTR,#WRD,#SEC
						#NMSB,#NLSB
						#LMSB,#LLSB
						#ANYF,#ANYR
						#W1,#W2,#W3,#W4

	PASSED SPECIFIC TIME AS ARGUMENTS (MSB,LSB)

	RETURNS 0 FOR FAIL, 1 FOR OK */


INSERT.NOTE.RECORD: PROC (MSB,LSB) FIXED PUBLIC;	/* INSERT NOTE RECORD */
	DCL (MSB, LSB)  FIXED;			/* START TIME OF INSERTED NOTE */
	DCL (AMSB,ALSB) FIXED;			/* 32-BIT TEMPS */
	DCL (BMSB,BLSB) FIXED;
	DCL (PSEC,PWRD) FIXED;
	DCL (I,J)       FIXED;
	DCL (LEN)       FIXED;

	IF #SEC=0 THEN DO;				/* TRK HAS NO NOTE LIST SEGMENTS */
		IF ALLOCATE.FIRST.NLS=0		/* SET UP FIRST NOTE SEGMENT     */
		THEN RETURN 0;				/* NO ROOM - BOMB OUT            */
	END;

	/* Create a system event when a note is added or removed */
	/* from the sequencer:                                   */

	interp_seq_dirtyness(1);

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 4;
	WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
	WRITE(MAL) = #TRK;				/* REMEMBER TRACK # ON NEW.SEQ.INFO */
	WRITE(MD) = "177777";			/*   "NEW NOTES" OR "NEW TIMBRE"    */

	DO WHILE (((MSB ILT #LMSB))	    /* AND INSERT TIME IS BEFORE CURRENT */
	OR        ((MSB  =  #LMSB)		/* LAST EVENT TIME                 */
	AND        (LSB ILT #LLSB)));
		IF #ANYR=0 THEN RETURN 0;	/* MEANS WE ARE INSIDE ILP         */
		CALL BACKUP.TO.PRIOR.NOTE;	/* KEEPS OUR GLOBAL INFO CORRECT   */
	END;

	DO WHILE ((#ANYF<>0))
	AND      (((MSB IGT #NMSB))	    /* INSERT TIME IS BEYOND CURRENT */
	OR        ((MSB  =  #NMSB)		/* NEXT EVENT TIME               */
	AND        (LSB IGT #NLSB)));
		CALL ADVANCE.TO.NEXT.NOTE;	/* STEP FORWARD BY ONE NOTE      */
	END;

	IF #ANYF=0 THEN DO;				/* END OF TRACK REACHED          */

		AMSB=MSB-#NMSB;				/* TIME LEFT TO REACH INSERT POINT */
		ALSB=LSB-#NLSB;
		IF ALSB IGT LSB THEN AMSB=AMSB-1;

		IF AMSB<0 THEN DO;				/* MEANS TRACK WAS ACTUALLY TOO LONG */
												/* BUT #LMSB IS TOO FAR BACK         */
												/* MUST MEAN REST NOTE AT END OF TRK */
			IF #ANYR=0 THEN RETURN 0;	/* SYSTEM ERROR OF SORTS             */
			CALL BACKUP.TO.PRIOR.NOTE;	/* GO TO IT                          */

			IF (READ(MDI)&"174001")<>"100001"
			THEN RETURN 0;					/* ALSO A SYSTEM ERROR OF SORTS      */

			AMSB=MSB-#NMSB;				/* TIME LEFT TO REACH INSERT POINT   */
			ALSB=LSB-#NLSB;
			IF ALSB IGT LSB THEN AMSB=AMSB-1;

			WRITE(MDI)=AMSB;
			WRITE(MDI)=ALSB;

			CALL ADVANCE.TO.NEXT.NOTE;	/* SKIP OVER ALTERED REST NOTE    */
			CALL CHECK.POINTER.TIMES;	/* POSSIBLY UPDATE TIMES          */

			AMSB=0;
			ALSB=0;

		END;

		ELSE DO;							/* CHECK FOR LONG REST NOTE NEEDED */
			IF (ALSB IGT 1023) OR (AMSB<>0)
			THEN DO;								/* EXTEND TRACK TO INSERT POINT */
				IF INSERT.REST.RECORD(4)=0	/* NO ROOM        */
				THEN RETURN 0;					/* BOMB OUT       */

				WRITE("324")=READ(MDI);		/* STORE EXTRA DELTA IN REST */
				WRITE(MDI  )=AMSB;
				WRITE(MD   )=ALSB;

				CALL ADVANCE.TO.NEXT.NOTE;	/* PROCESS REST RECORD       */
				CALL CHECK.POINTER.TIMES;	/* AND KEEP TRACK HEAD CORRECT */

				AMSB=0;
				ALSB=0;

			END;
		END;


		/* $PAGE - ADD NOTE TO END OF TRACK */

		IF #W1 THEN LEN=4; ELSE LEN=2;	/* COMPUTE LENGTH OF NOTE RECORD */

		IF INSERT.REST.RECORD(LEN)=0 THEN DO;	/* OUT OF MEMORY */
			RETURN 0;									/* BOMB OUT !!! */
		END;

		WRITE(MDI)=(#W1&"174001")\SHL(ALSB,1);	/* WRITE NOTE INFO */
		WRITE(MDI)=#W2;								/* INTO TRACK      */
		IF #W1 THEN DO;
			WRITE(MDI)=#W3; WRITE(MDI)=#W4;
			J=#WRD+4;
		END;
		ELSE J=#WRD+2;

		IF  ((#W1&"100000")=0)				/* NOT AN ALTERNATE FORMAT NOTE  */
		AND ((#W2&"77")<>REST.NOTE)		/* OR A REST NOTE                */
		THEN DO;									/* INCREMENT NUMBER OF NOTES CTR */
			CALL INCREMENT.NUM.NOTES;		/* #PTR MUST BE VALID */
		END;

		WRITE(MAM)=#PTR;						/* MAKE SURE MAM POINTS AT TRK HEAD */

		IF ALSB<>0 THEN DO;					/* WE HAVE CHANGED THE TRACK LENGTH */

			#NMSB=MSB; #NLSB=LSB;			/* NOTE OCCURS AT THIS TIME */

			WRITE(MAL)=THD.WRD;				/* CHECK PLAY POINTER       */
			IF  (READ(MDI)=J)					/* SEE IF PLAY POINTER      */
			AND (READ(MD )=#SEC)				/* IS JUST AFTER US         */
			THEN DO;

				IF ((#NMSB IGT ADVANCED.SEQ.TIME.MSB))	/* TRACK HEAD SHOULD LOOK */
				OR ((#NMSB  =  ADVANCED.SEQ.TIME.MSB)	/* LIKE WE ARE ABOUT TO   */
				AND (#NLSB IGE ADVANCED.SEQ.TIME.LSB))	/* PLAY OUR NEW NOTE      */
				THEN DO;
					CALL STORE.#.INFO(THD.NMSB);			/* NEW #NMSB TIME         */
					IF RECD=0 THEN CALL REBUILD.EVENT.QUEUE;
					WRITE(MAM)=#PTR;
				END;
				ELSE DO;					/* UPDATE THD.NMSB, THD.LSB */
					WRITE(MAL)=THD.NMSB;
					WRITE(MDI)=#NMSB;
					WRITE(MDI)=#NLSB;
					WRITE(MDI)=#NMSB;
					WRITE(MD )=#NLSB;
				END;
			END;
			ELSE DO;
				WRITE(MAL)=THD.WRD;				/* CHECK PLAY POINTER  */
				IF  (READ(MDI)=#WRD)				/* SEE IF PLAY POINTER */
				AND (READ(MD )=#SEC)				/* IS RIGHT HERE       */
				THEN DO;
					WRITE(MAL)=THD.NMSB;
					WRITE(MDI)=#NMSB;
					WRITE(MD )=#NLSB;
					IF RECD=0 THEN CALL REBUILD.EVENT.QUEUE;
					WRITE(MAM)=#PTR;
				END;
			END;

			WRITE(MAL)=THD.LP.WRD;				/* CHECK LOOP POINTER  */
			IF  (READ(MDI)=J)						/* SEE IF PLAY POINTER */
			AND (READ(MD )=#SEC)					/* IS JUST AFTER US    */
			THEN DO;

				IF ((#NMSB IGT LOOP.SEQ.TIME.MSB))	/* THIS NOTE WANTS TO BE */
				OR ((#NMSB  =  LOOP.SEQ.TIME.MSB)	/* INSIDE THE LOOP       */
				AND (#NLSB IGE LOOP.SEQ.TIME.LSB))
				THEN DO;
					CALL STORE.#.INFO(THD.LP.NMSB);	/* NEW #NMSB TIME         */
					WRITE(MAM)=#PTR;
				END;
				ELSE DO;								/* UPDATE THD.LP.NMSB, LMSB */
					WRITE(MAL)=THD.LP.NMSB;
					WRITE(MDI)=#NMSB;
					WRITE(MDI)=#NLSB;
					WRITE(MDI)=#NMSB;
					WRITE(MD )=#NLSB;
				END;
			END;
			ELSE DO;
				WRITE(MAL)=THD.LP.WRD;			/* CHECK LOOP POINTER  */
				IF  (READ(MDI)=#WRD)				/* SEE IF PLAY POINTER */
				AND (READ(MD )=#SEC)				/* IS RIGHT HERE       */
				THEN DO;
					WRITE(MAL)=THD.LP.NMSB;
					WRITE(MDI)=#NMSB;
					WRITE(MDI)=#NLSB;
				END;
			END;

		END;									/* OF HAVE LENGTHED THE TRACK */

		RETURN 1;							/* SUCCESSFUL INSERT */
	END;										/* OF #ANYF=0 CASE   */


	/* $PAGE */


	/* INSERT NOTE IN MIDDLE OF TRACK: */

	IF #W1 THEN LEN=4;						/* SET UP LEN HERE */
	ELSE        LEN=2;

	/* CHECK FOR TIME DIFFERENCE TO NOTE */
	/* BEHIND US.  IF <=1023, AND PRIOR  */
	/* NOTE IS A REST, MOVE IT TO AFTER  */
	/* US                                */

	AMSB=MSB-#LMSB;							/* GET TIME TIME FROM DISTANCE FROM  */
	ALSB=LSB-#LLSB;							/* TIME TO #NMSB */
	IF LSB ILT #LLSB THEN AMSB=AMSB-1;

	IF  ((AMSB=0)&(ALSB ILE 1023))		/* WILL FIT IN SINGLE DELTA FIELD */
	AND (#ANYR<>0)								/* AND A NOTE BEHIN US            */
	THEN DO;

		CALL BACKUP.TO.PRIOR.NOTE;

		IF  ((READ(MD)&"174001")="100001")	/* LONG REST SITS THERE    */
		OR  (((READ(MDI)&1)=0)					/* OR TWO WORD REST RECORD */
		AND  ((READ(MD )&"77")=REST.NOTE))	/* SITS HERE               */
		THEN DO;

			WRITE(MAL)=#WRD;						/* RESTORE MAL POINTER     */

			IF ((SHR(READ(MD),1)&1023)+ALSB) ILE 1023
			THEN DO;

				IF INSERT.REST.RECORD(LEN)=0	/* INSERT NOTE TO USE HERE */
				THEN RETURN 0;

				I=SHR(READ(MD),1)&1023;			/* GET CURRENT DELTA */

				WRITE(MDI)=(#W1&"174001")\SHL(I+ALSB,1);	/* SET TYPE    */
				WRITE(MDI)=#W2;
				IF #W1 THEN DO;
					WRITE(MDI)=#W3; WRITE(MDI)=#W4;
				END;

				#NLSB=#NLSB+ALSB;					/* BRING #NMSB UP TO WHERE IT BELONGS */
				IF #NLSB ILT ALSB THEN #NMSB=#NMSB+1;

				CALL ADVANCE.TO.NEXT.NOTE;		/* ADVANCE TO ORIG REST     */

				IF ((READ(MDI)&"174001")="100001")	/* 4 WORD REST - SUBTRACT */
				THEN DO;										/* WHAT DELTA WE CAN HERE */
					BMSB=READ(MDI); BLSB=READ(MD);
					WRITE(MAL)=#WRD+1;
					IF (BMSB=0)&(BLSB ILT ALSB)
					THEN DO;
						WRITE(MDI)=0;
						WRITE(MD )=0;
						ALSB=ALSB-BLSB;
					END;
					ELSE DO;
						IF BLSB ILT ALSB THEN BMSB=BMSB-1;
						BLSB=BLSB-ALSB;
						ALSB=0;
						WRITE(MDI)=BMSB;
						WRITE(MD )=BLSB;
					END;
				END;

				CALL ADVANCE.TO.NEXT.NOTE;		/* NOW NEXT ONE          */

				IF ALSB<>0 THEN DO;				/* MORE TO SUBTRACT HERE */
					WRITE(MD)=READ(MD)-SHL(ALSB,1);
					IF #NLSB ILT ALSB THEN #NMSB=#NMSB-1;
					#NLSB=#NLSB-ALSB;
				END;

				PSEC=#SEC; PWRD=#WRD;			/* SAVE PTRS TO NOTE AFTER US */

				CALL BACKUP.TO.PRIOR.NOTE;		/* BACK UP TO REST NOTE       */

				WRITE(MAM)=#PTR;					/* CHECK PLAY TIMES           */
				WRITE(MAL)=THD.WRD;

				IF  (READ(MDI)=PWRD)				/* NOTE WAS INSERTED AT PLAY POINTER */
				AND (READ(MD )=PSEC)
				THEN DO;
					IF  (RECD=0)					/* IF NOT RECORDING     */
					AND (((#NMSB IGT ADVANCED.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
					OR   ((#NMSB  =  ADVANCED.SEQ.TIME.MSB)	/* PLAYED YET        */
					AND   (#NLSB IGE ADVANCED.SEQ.TIME.LSB)))
					THEN DO;												/* MAKE SURE IT WILL GET PLAYED */
						CALL STORE.#.INFO(THD.NMSB);
						CALL REBUILD.EVENT.QUEUE;
						WRITE(MAM)=#PTR;
					END;
					ELSE DO;								/* SET CORRECT LMSB */
						WRITE(MAL)=THD.LMSB;			/* IN TRACK HEAD    */
						WRITE(MDI)=#NMSB;
						WRITE(MDI)=#NLSB;
					END;
				END;

				WRITE(MAL)=THD.LP.WRD;

				IF  (READ(MDI)=PWRD)				/* NOTE WAS INSERTED AT PLAY POINTER */
				AND (READ(MD )=PSEC)
				THEN DO;
					IF (((#NMSB IGT LOOP.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
					OR  ((#NMSB  =  LOOP.SEQ.TIME.MSB)	/* PLAYED YET        */
					AND  (#NLSB IGE LOOP.SEQ.TIME.LSB)))
					THEN DO;										/* MAKE SURE IT WILL GET PLAYED */
						CALL STORE.#.INFO(THD.LP.NMSB);	/* BRING LOOP POINTERS BACK TO INCLUDE NOTE */
					END;
					ELSE DO;										/* SET CORRECT LMSB  */
						WRITE(MAL)=THD.LP.LMSB;				/* IN TRACK HEAD     */
						WRITE(MDI)=#NMSB;						/* SET CORRECT LAST  */
						WRITE(MDI)=#NLSB;						/* TIME IN NEXT NOTE */
					END;
				END;

				CALL CHECK.POINTER.TIMES;	/* CHECK #NMSB, #LMSB HERE    */

				PSEC=#SEC; PWRD=#WRD;		/* SAVE PTRS TO ORIGINAL REST */

				CALL BACKUP.TO.PRIOR.NOTE;	/* BACK UP TO NEW NOTE        */

				WRITE(MAM)=#PTR;				/* CHECK PLAY TIMES           */
				WRITE(MAL)=THD.WRD;

				IF  (READ(MDI)=PWRD)			/* NOTE WAS INSERTED AT PLAY POINTER */
				AND (READ(MD )=PSEC)
				THEN DO;
					IF  (RECD=0)										/* IF NOT RECORDING  */
					AND (((#NMSB IGT ADVANCED.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
					OR   ((#NMSB  =  ADVANCED.SEQ.TIME.MSB)	/* PLAYED YET        */
					AND   (#NLSB IGE ADVANCED.SEQ.TIME.LSB)))
					THEN DO;												/* MAKE SURE IT WILL GET PLAYED */
						CALL STORE.#.INFO(THD.NMSB);
						CALL REBUILD.EVENT.QUEUE;
						WRITE(MAM)=#PTR;
					END;
				END;

				WRITE(MAL)=THD.LP.WRD;

				IF  (READ(MDI)=PWRD)			/* NOTE WAS INSERTED AT PLAY POINTER */
				AND (READ(MD )=PSEC)
				THEN DO;
					IF (((#NMSB IGT LOOP.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
					OR  ((#NMSB  =  LOOP.SEQ.TIME.MSB)	/* PLAYED YET        */
					AND  (#NLSB IGE LOOP.SEQ.TIME.LSB)))
					THEN DO;										/* MAKE SURE IT WILL GET PLAYED */
						CALL STORE.#.INFO(THD.LP.NMSB);	/* BRING LOOP POINTERS BACK TO INCLUDE NOTE */
					END;
				END;

				CALL CHECK.POINTER.TIMES;			/* CHECK #NMSB, #LMSB HERE */

				IF  ((#W1&"100000")=0)				/* NOT AN ALTERNATE FORMAT NOTE  */
				AND ((#W2&"77")<>REST.NOTE)		/* OR A REST NOTE                */
				THEN DO;									/* INCREMENT NUMBER OF NOTES CTR */
					CALL INCREMENT.NUM.NOTES;		/* #PTR MUST BE VALID */
				END;

				RETURN 1;

			END;

			ELSE DO;
				CALL ADVANCE.TO.NEXT.NOTE;	/* FAILED - TRY BELOW */
			END;
		END;
		ELSE DO;
			CALL ADVANCE.TO.NEXT.NOTE;		/* FAILED - TRY BELOW */
		END;
	END;

	/* BEGIN BY COMPUTING TIME FROM DESIRED */
	/* NOTE START POINT TO #NMSB,#NLSB      */

	AMSB=#NMSB-MSB;							/* GET TIME TIME FROM DISTANCE FROM */
	ALSB=#NLSB-LSB;							/* TIME TO #NMSB */
	IF #NLSB ILT LSB THEN AMSB=AMSB-1;

	/* INSERT REST RECORD AT #NMSB,#NLSB TIME FOR NOW */
	/* THIS RECORD WILL EVENTUALLY BECOME NOTE RECORD */
	/* RECORD WILL SIT AT TIME=#NMSB,#NLSB            */

	WRITE(MAM)=NAH.PTR+#SEC;				/* POINT TO WORD IN CASE NO BACK UP DONE */
	WRITE(MAL)=#WRD;

	IF LEN=2 THEN DO;							/* TWO WORD RECORD NEEDED        */
		IF  ((READ(MDI)&1)=0)				/* IF TWO WORD RECORD SITS THERE */
		AND ((READ(MD)&"77")=REST.NOTE)	/* WHICH IS A REST NOTE          */
		THEN DO;									/* USE IT                        */
			WRITE(MAL)=#WRD;					/* POINT TO IT                   */
		END;
		ELSE DO;
		  IF INSERT.REST.RECORD(LEN)=0	/* ELSE PUT IN ONE WE CAN USE    */
		  THEN RETURN 0;
		END;
	END;
	ELSE DO;											/* 4 WORD RECORD NEEDED       */
		IF  ((READ(MDI)&"174001")="100001")	/* IF LONG REST SITS HERE     */
		AND (READ(MDI)=0)							/* IF IT HAS DELTA OF 0       */
		AND (READ(MDI)=0)							/* THEN USE IT FOR NOTE       */
		THEN DO;
			WRITE(MAL)=#WRD;						/* POINT TO IT                */
		END;
		ELSE DO;
		  IF INSERT.REST.RECORD(LEN)=0		/* ELSE PUT IN ONE WE CAN USE */
		  THEN RETURN 0;
		END;
	END;

	CALL ADVANCE.TO.NEXT.NOTE;
	IF  (ALSB IGT 1023)
	OR  (AMSB<>0)							/* WILL NEED LONG REST RECORD AFTER NEW NOTE RECORD */
	OR  ((ALSB + (SHR(READ(MD),1)&1023)) IGT 1023)
	THEN DO;
		IF (READ(MD)&"174001")<>"100001"	/* SEE IF LONG REST IS THERE */
		THEN IF INSERT.REST.RECORD(4)=0	/* IF NOT, MUST ADD ONE      */
		THEN RETURN 0;
	END;
	CALL BACKUP.TO.PRIOR.NOTE;				/* BACK UP TO WHERE NEW NOTE GOES */

	I=SHR(READ(MD),1)&1023;					/* GET CURRENT DELTA */

	WRITE(MDI)=(#W1&"174001")\SHL(I,1);	/* SET TYPE          */
	WRITE(MDI)=#W2;
	IF #W1 THEN DO;
		WRITE(MDI)=#W3; WRITE(MDI)=#W4;
	END;

	WRITE(MAL)=#WRD;							/* RESTORE POINTER   */

	/* NOW BACK UP THE NOTE TO THE CORRECT TIME. */

	IF (AMSB\ALSB)<>0 THEN DO;				/* MUST BACK UP TIME */

		BMSB=AMSB; BLSB=ALSB;				/* GET WORKING COPY        */

		IF  (BMSB=0) AND (BLSB ILE I)
		THEN J=BLSB;							/* BACK UP THIS MUCH IN DELTA FIELD */
		ELSE J=I;

		I=I-J;									/* NEW DELTA TIME    */

		WRITE(MD)=(READ(MD)&"174001")\SHL(I,1);	/* SAVE IT BACK IN NOTE RECORD */

		IF BLSB ILT J THEN BMSB=BMSB-1;		/* CORRECT BMSB,BLSB FOR AMOUNT BACKED UP */
		BLSB=BLSB-J;

		IF #NLSB ILT J THEN #NMSB=#NMSB-1;	/* CORRECT #NMSB,#NLSB FOR AMOUNT BACKED UP */
		#NLSB=#NLSB-J;

		IF (BMSB\BLSB)<>0 THEN DO;				/* LONG REST INVOLVED - MUST BACK UP MORE */

			CALL BACKUP.TO.PRIOR.NOTE;			/* BACK UP TO PRIOR REST NOTE     */

			WRITE("324")=READ(MDI);				/* SKIP OVER 1ST WORD OF LONG REST */
			BMSB=READ(MDI)-BMSB;					/* GET NEW DELTA */
			IF READ(MD) ILT BLSB THEN BMSB=BMSB-1;
			BLSB=READ(MD)-BLSB;

			WRITE(MAL)=READ(MAL)-1;
			WRITE(MDI)=BMSB;
			WRITE(MD )=BLSB;

			CALL ADVANCE.TO.NEXT.NOTE;		/* STEP TO OUR INSERTED NOTE */

		END;

		PSEC=#SEC; PWRD=#WRD;				/* SAVE EDIT POINTERS        */

		CALL ADVANCE.TO.NEXT.NOTE;			/* STEP TO NOTE AFTER OUR INSERTED NOTE */

		/* NOW ADD TIME IN AFTER INSERTED NOTE */

		WRITE(MAM)=NAH.PTR+#SEC;
		WRITE(MAL)=#WRD;

		I=SHR(READ(MD),1)&1023;				/* GET ITS DELTA    */
		BMSB=AMSB; BLSB=ALSB;				/* GET WORKING COPY */

		IF  (BMSB<>0) OR (BLSB IGT (1023-I))
		THEN J=1023-I;							/* ADVANCE THIS MUCH IN DELTA FIELD */
		ELSE J=BLSB;

		I=I+J;									/* NEW DELTA TIME    */

		WRITE(MD)=(READ(MD)&"174001")\SHL(I,1);	/* SAVE IT    */

		IF BLSB ILT J THEN BMSB=BMSB-1;	/* CORRECT BMSB,BLSB FOR AMOUNT LEFT */
		BLSB=BLSB-J;

		#NLSB=#NLSB+J;							/* BRING #NMSB UP TO WHERE IT BELONGS */
		IF #NLSB ILT J THEN #NMSB=#NMSB+1;

		WRITE(MAM)=#PTR;						/* CHECK PLAY TIMES */
		WRITE(MAL)=THD.WRD;

		IF  (READ(MDI)=PWRD)					/* NOTE WAS INSERTED AT PLAY POINTER */
		AND (READ(MD )=PSEC)
		THEN DO;
			IF MOVE.SPEED>=0 THEN DO;
				IF RECD<>0										/* IF RECORDING, BUMP */
				THEN CALL STORE.#.INFO(THD.NMSB);		/* POINTER ALWAYS SO  */
																	/* RTE RECORDS DO NOT */
																	/* GET PUNCHED OUT    */
				ELSE IF ((#LMSB IGT ADVANCED.SEQ.TIME.MSB))	/* NOTE HAS NOT BEEN */
				OR ((#LMSB  =  ADVANCED.SEQ.TIME.MSB)			/* PLAYED YET        */
				AND (#LLSB IGE ADVANCED.SEQ.TIME.LSB))
				THEN DO;											/* MAKE SURE IT WILL GET PLAYED */
					WRITE(MAL)=THD.NMSB;						/* GET TIMES CORRECT     */
					WRITE(MDI)=#LMSB;							/* UPDATE THD.NMSB */
					WRITE(MDI)=#LLSB;							/* IN TRACK HEAD   */
					CALL REBUILD.EVENT.QUEUE;
				END;
				ELSE DO;						/* BUMP PLAY POINTER OVER NOTE    */
					CALL STORE.#.INFO(THD.NMSB);
				END;
				WRITE(MAM)=#PTR;
			END;
		END;
		ELSE DO;								/* SEE IF POINTS TO ONE AFTER US  */
			WRITE(MAL)=THD.WRD;
			IF  (READ(MDI)=#WRD)			/* NOTE WAS INSERTED JUST BEFORE PLAY POINTER */
			AND (READ(MD )=#SEC)
			THEN DO;
				WRITE(MAL)=THD.NMSB;		/* UPDATE TIMES WHICH MAY HAVE CHANGED */
				WRITE(MDI)=#NMSB;			/* #NMSB,#NLSB MAY HAVE CHANGED IF     */
				WRITE(MDI)=#NLSB;			/* THE NOTE IS A REST NOTE (I.E. BMSB, */
				WRITE(MDI)=#LMSB;			/* BLSB <> 0).  #LMSB,#LLSB WILL       */
				WRITE(MDI)=#LLSB;			/* HAVE CHANGED IN MOST CASES          */
			END;
		END;


		WRITE(MAL)=THD.LP.WRD;

		IF  (READ(MDI)=PWRD)				/* INSERTING REST AT LOOP PTR        */
		AND (READ(MD )=PSEC)
		THEN DO;
			IF ((#LMSB IGT LOOP.SEQ.TIME.MSB))	/* NOTE WANTS TO BE IN LOOP */
			OR ((#LMSB  =  LOOP.SEQ.TIME.MSB)
			AND (#LLSB IGE LOOP.SEQ.TIME.LSB))
			THEN DO;
				WRITE(MAL)=THD.LP.NMSB;				/* GET TIMES CORRECT  */
				WRITE(MDI)=#LMSB;						/* UPDATE THD.LP.NMSB */
				WRITE(MDI)=#LLSB;						/* IN TRACK HEAD      */
			END;
			ELSE DO;
				CALL STORE.#.INFO(THD.LP.NMSB);
				WRITE(MAM)=#PTR;
			END;
		END;
		ELSE DO;								/* SEE IF POINTS TO ONE AFTER US  */
			WRITE(MAL)=THD.LP.WRD;
			IF  (READ(MDI)=#WRD)			/* NOTE WAS INSERTED JUST BEFORE LOOP POINTER */
			AND (READ(MD )=#SEC)
			THEN DO;
				WRITE(MAL)=THD.LP.NMSB;	/* UPDATE TIMES WHICH MAY HAVE CHANGED */
				WRITE(MDI)=#NMSB;			/* #NMSB,#NLSB MAY HAVE CHANGED IF     */
				WRITE(MDI)=#NLSB;			/* THE NOTE IS A REST NOTE (I.E. BMSB, */
				WRITE(MDI)=#LMSB;			/* BLSB <> 0).  #LMSB,#LLSB WILL       */
				WRITE(MDI)=#LLSB;			/* HAVE CHANGED IN MOST CASES          */
			END;
		END;

		IF (BMSB\BLSB)<>0 THEN DO;		/* LONG REST INVOLVED - MUST RETARD NOTE BY MORE */

			WRITE(MAM)=NAH.PTR+#SEC;	/* RESTORE PTR TO NOTE */
			WRITE(MAL)=#WRD+1;

			BMSB=READ(MDI)+BMSB;			/* GET NEW DELTA */
			BLSB=READ(MD )+BLSB;
			IF BLSB ILT READ(MD) THEN BMSB=BMSB+1;

			WRITE(MAL)=READ(MAL)-1;
			WRITE(MDI)=BMSB;
			WRITE(MD )=BLSB;

			CALL ADVANCE.TO.NEXT.NOTE;	/* COMPUTE A NEW LAST TIME */
			CALL CHECK.POINTER.TIMES;	/* KEEP TRK HEAD INFO CORRECT */
			CALL BACKUP.TO.PRIOR.NOTE;	/* BACKUP AGAIN TO KEEP PTRS OK */

		END;

		CALL BACKUP.TO.PRIOR.NOTE;		/* MAKE SURE WE QUIT POINTING AT INSERTED NOTE */
	END;

	IF  ((#W1&"100000")=0)				/* NOT AN ALTERNATE FORMAT NOTE  */
	AND ((#W2&"77")<>REST.NOTE)		/* OR A REST NOTE                */
	THEN DO;									/* INCREMENT NUMBER OF NOTES CTR */
		CALL INCREMENT.NUM.NOTES;		/* #PTR MUST BE VALID */
	END;

	/* UPON EXITING THIS ROUTINE, WE SHOULD BE POINTING */
	/* AT THE NOTE WE INSERTED WITH (#SEC,#WRD).        */

	RETURN 1;								/* SUCCESSFUL INSERT */

END INSERT.NOTE.RECORD;
