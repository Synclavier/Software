/* :SYNRSOU:04-SEQ:131-MAP  $TITLE  Non-Real-Time Live Click Track Mapping Routine *//*1998/06/24 - TY  - Updated expressions containing (CLICK.TRACK.MODE & 511) to account for						 the independence of CLICK.TRACK.MODE from CLICKON.1988/10/03 - cj  - extended live click after last click at "most recent" rate1987/04/04 - CJ  - DETECTED ZERO LENGTH INDEP LOOP ON LIVE CLICK TRACK1986/07/24 - ts  - removed insert.debug code1986/06/11 - TSS - Deleted references to RECORD.SEC,RECORD.WRD,CONTINUE.SEC,CONTINUE.WRD1986/05/15 - "official" creation of release-M modules*//* The following routine assists in the use of a Live Click Track   recorded into the Synclavier:   REMAP.WITH.LIVE.CLICK(time.msb,time.lsb,dur.msb,dur.lsb,sync.to.beats);      Passed a 32-bit note start time in msec.      Passed a 32-bit note duration   in msec.      Passed a flag which determines direction of mapping.         SYNC.TO.BEATS=0 --> map Beats to Synclavier times.         SYNC.TO.BEATS=1 --> map Synclavier times to Beats.         SYNC.TO.BEATS=2 --> map Synclavier time to Beat for starting                             time,  then map duraton (in beats) to                             duration (in synclav time)      Routine scans Live Click Track and converts passed info into      REMAPPED.TIME.MSB, REMAPPED.TIME.LSB, REMAPPED.DUR.MSB, and      REMAPPED.DUR.LSB.      All outputs are based on 1000 ticks per second      and 1000 ticks per beat.*//* $PAGE *//* KEEP THESE IN ORDER!!!! */dcl REMAPPED.TIME.MSB fixed public;dcl REMAPPED.TIME.LSB fixed public;dcl REMAPPED.DUR.MSB  fixed public;dcl REMAPPED.DUR.LSB  fixed public;REMAP.WITH.LIVE.CLICK:  proc (time.msb,time.lsb,dur.msb,dur.lsb,sync.to.beats) public swap;   dcl (time.msb,time.lsb)   fixed; /* 32-bit start time to convert */   dcl ( dur.msb, dur.lsb)   fixed; /* 32-bit duration   to convert */   dcl (sync.to.beats)       fixed; /* 1=remap Sync time to Beats, 0=remap Beats to Sync time */   dcl (oursec,ourwd)        fixed; /* current ptrs into sequence track */   dcl ( abs.tmsb, abs.tlsb) fixed; /* absolute time while stepping through track */   dcl (last.tmsb,last.tlsb) fixed; /* absolute time of last click during processing */   dcl ( our.tmsb, our.tlsb) fixed; /* mapped time corresponding to previous click */   dcl (goal.tmsb,goal.tlsb) fixed; /* base and goal are the sync points */   dcl (base.tmsb,base.tlsb) fixed; /* between the two time bases        */   dcl (extra.dur)           fixed; /* ticks from last click to desired time */   dcl (beat.zero)           fixed; /* set to 1 at start of seq scan */   dcl (loopmsb,looplsb)     fixed; /* time of last indep loop       */   dcl (last.rate)           fixed; /* duration of last click        */   GET.NEXT.NLS:  proc; /* advances OURSEC,OURWD to next notelist segment */      dcl i fixed;      /* assumes we have reached the end of the */      /* current note list segment. i.e. we are */      /* pointing at a NLS.EOS                  */      i=NLS.EOS;                    /* we are at end of NLS or would not have been called */      do while i=NLS.EOS;           /* loop here until note found or end of track */         write(mam)=NAH.PTR+oursec; /* restore mam in case increment across sector boundary */         i=read(md);                /* look up NLS.FOR */         if i=0 then return 0;      /* end of track reached -- BOMB OUT */         oursec=i;                  /* advance pointer to next NLS    */         write(mal)=NLS.FP;      /* look up starting pointer       */         ourwd=read(md);         /* start at first word            */         write(mam)=NAH.PTR+oursec; /* set up MAM and MAL ptrs to new segment */         write(mal)=ourwd;         i=read(md);                /* get the word */      end;            return 1;                     /* denotes we have a new segment */   end GET.NEXT.NLS;   ADVANCE.TO.FIRST.NOTE:  proc; /* advances ABS.TMSB,ABS.TLSB,OURSEC,OURWD to first note record */      /* (click.track.mode+NUM.KBD.TRACKS-4) is track number (0 to MAX.TRACK-1) of live click track */      write(mam)=TRK.HEAD;             /* get abs ptrs to desired track */      write(mal)=(click.track.mode+NUM.KBD.TRACKS-4);      if read(md)=0 then return 0;     /* no track here -- BOMB OUT!!! */      write(mam)=read(md);             /* set up to read track header */      oursec=read(md);                 /* relative ptr to first note list segment */      if oursec=0 then do;             /* forward ptr=NIL -- no notes on track -- BOMB OUT!!! */         return 0;                     /* no track here -- BOMB OUT!!! */      end;      write(mam)=NAH.PTR+oursec;       /* set up new MAM and MAL ptrs */      write(mal)=NLS.FP;      ourwd=read(md);                  /* point to actual first note  */      write(mal)=ourwd;      if read(md)=NLS.EOS then do;     /* at end of first note list segment */         if GET.NEXT.NLS=0             /* try to advance ptrs to next notelist segment */         then return 0;                /* no more note segements -- BOMB OUT!! */         /* GET.NEXT.NLS sets up the MAM and MAL ptrs to the */         /* first data word of the new segment.              */      end;      abs.tlsb=shr(read(md),1)&1023;   /* store the time of the note    */      abs.tmsb=0;      return 1;                        /* have found a real note record */   end ADVANCE.TO.FIRST.NOTE;   /* $PAGE */   ADVANCE.OURTIME:  proc; /* subroutine to advance OUR.TMSB, OUR.TLSB */      dcl (i,j,k)           fixed; /* temps to hold note record info */      /* On entry to this procedure, ABS.TMSB and ABS.TLSB correspond */      /* to the Synclavier time at which the note pointed to by       */      /* OURSEC and OURWD should occur.                               */      REPROCESS.NEXT.NOTE:      write(mam)=NAH.PTR+oursec;       /* set up ptrs to our next note */      write(mal)=ourwd;      i=read(mdi);                     /* get first word of next note in seq */      PROCESS.NEXT.NOTE:      /* see if current note is a rest note or update     */      /* record.  if so, just advance ptrs to next note.  */      /* click only occurs on "real" notes.               */      if i>=0 then do;                 /* normal format note record */         j=read(mdi);                  /* duration and key # for this note */         if i                          /* have a 4-word record             */         then k=read(mdi);             /* read sbits and rte stuff         */         else k=0;                     /* zero out sbits on 2-word records */         if  ((j&63)=REST.NOTE)        /* if note is a rest note    */         or  ((k&shl(B.UPD,8))<>0)     /* or an update record       */         then do;                      /* then skip over it         */            SKIP.NOTE:                 /* jump here to skip note record */            if i <> NLS.EOS            /* advance word pointer if we    */            then do;                   /* are not at end of track       */               if i then ourwd=ourwd+4;               else      ourwd=ourwd+2;            end;            write(mal)=ourwd;          /* set up MAL ptr to next note */            i=read(mdi);               /* get first word of next note in seq */            if i=NLS.EOS then do;      /* have reached end of this segment */               if GET.NEXT.NLS=0 then do;  /* end of track !!              */                  if last.rate   = 0       /* prevent hang up if bad       */                  then last.rate = 1000;   /* last.rate                    */                  /* at end of click track - ignore extraneous rest        */                  /* records at the end of the track by resetting to the   */                  /* last actual time.                                     */                  if beat.zero <> 0 then do;  /* if we go through whole    */                     abs.tmsb = 0;            /* track with no real notes, */                     abs.tlsb = zero.time;    /* fake click track at 0.000 */                  end;                  else do;                          /* else create a new   */                     abs.tmsb=goal.tmsb;            /* note at last.rate   */                     abs.tlsb=goal.tlsb+last.rate;  /* beyond the last     */                     if abs.tlsb ilt last.rate      /* one scanned         */                     then abs.tmsb=abs.tmsb+1;                  end;                                                             goto REPROCESS.NEXT.NOTE;               end;               i=read(mdi);            /* read the first word of this new note */            end;            /* Compute abs time of this record by  */            /* adding in delta of current note.    */            j=shr(i,1)&1023;           /* extract delta                */            abs.tlsb=abs.tlsb+j;       /* add delta to 32-bit abs time */            if abs.tlsb ilt j            then abs.tmsb=abs.tmsb+1;            goto PROCESS.NEXT.NOTE;    /* advance other stuff for this note */         end;      end;      /* $PAGE */      else if i <> NLS.EOS             /* else skip over alternate note */      then do;                         /* records if not at end of trk  */         j=rot(i,5)&15;                /* extract note record type code */         if j=0 then do;               /* long rest record              */            abs.tmsb=abs.tmsb+read(mdi); /* add in msb of delta   */            abs.tlsb=abs.tlsb+read(md ); /* and then lsb of delta */            if abs.tlsb ILT read(md)     /* had a carry           */            then abs.tmsb=abs.tmsb+1;    /* increment msb         */         end;         else if j=2 then do;          /* ILP end-loop record */            /* look up ILP info from track   */            /* header sector for this track. */            /* reset current ptrs OURSEC,    */            /* OURWD to ILP start values.    */            if  (abs.tmsb<>loopmsb)            or  (abs.tlsb<>looplsb)            then do;                   /* handle only if not zero length loop */               loopmsb=abs.tmsb;               looplsb=abs.tlsb;               write(mam)=TRK.HEAD;       /* look up addr of track header */               write(mal)=(click.track.mode+NUM.KBD.TRACKS-4);               write(mam)=read(md);       /* now point to track header    */               write(mal)=THD.ILS.WRD;    /* get ptr to start of ILP      */               ourwd =read(mdi);          /* store in current pos ptrs    */               oursec=read(mdi);               write(mam)=NAH.PTR+oursec; /* set up ptrs to our next note */               write(mal)=ourwd;               i=read(mdi);               /* read first word of ILP start-loop record */            end;            /* and then skip over it in the next statement below */         end;         goto SKIP.NOTE;               /* skip over alternate format records */      end;      /* $PAGE */      /* Once we get here, it means OURSEC and OURWD are    */      /* pointing at a real note, and ABS.TMSB and ABS.TLSB */      /* are the 32-bit Synclavier time of that note.       */      /* Note: we could also be pointing to the end         */      /* of the track.                                      */      /* abs.tmsb, abs.tlsb  = abs sync time of this click  */      /* our.tmsb, our.tlsb  = abs beat time of this click  */      if sync.to.beats<>0 then do;     /* mapping sync time to beats */         if  ((abs.tmsb ILT time.msb)) /* not there yet */         or  ((abs.tmsb  =  time.msb)          and  (abs.tlsb ILE time.lsb))         then do;            if i = NLS.EOS             /* if past end of track,  do some */            then do;                   /* math to get there quickly      */               call SUB32(loc(addr(time.msb)),                          loc(addr(abs.tmsb)),                          BitMsbArray);               load bitlsb; uload bitmsb;               div last.rate;          /* get # of beats at last rate    */               j = res;               if j <> 0 then do;                  load j;                 /* advance syncl time by this     */                  mul  last.rate;         /* many beats (rounded down)      */                  bitmsb = ures; bitlsb = res;                  call ADD32(loc(addr(abs.tmsb)),                             BitMsbArray,                             loc(addr(abs.tmsb)));                  call COPY32(loc(addr(abs.tmsb)),   /* set last time correctly */                              loc(addr(last.tmsb)));                  call SUB16 (last.rate, loc(addr(last.tmsb)));                  load j;                 /* advance logical time by this   */                  mul  1000;              /* many beats as well             */                  bitmsb = ures; bitlsb = res;                  call ADD32(loc(addr(our.tmsb)),                             BitMsbArray,                             loc(addr(our.tmsb)));               end;            end;            /* advance logical time if not a chord: */            ADVANCE.AND.SKIP:            if  (abs.tmsb<>last.tmsb)            or  (abs.tlsb<>last.tlsb)            then do;               goal.tmsb = abs.tmsb;      /* save synclav time      */               goal.tlsb = abs.tlsb;      /* away ...               */               base.tmsb = our.tmsb;      /* and corresponding      */               base.tlsb = our.tlsb;      /* beat time              */               our.tlsb  = our.tlsb+1000; /* advance by 1 second    */               if our.tlsb ILT 1000       /* had a carry            */               then our.tmsb=our.tmsb+1;  /* increment msb          */               if beat.zero <> 0          /* save away rate after   */               then beat.zero = 0;        /* second beat            */               else last.rate = abs.tlsb - last.tlsb;            end;            last.tmsb=abs.tmsb;        /* save seq time of last record */            last.tlsb=abs.tlsb;            goto SKIP.NOTE;            /* advance ptr to next record  */         end;         /* return 0,zero.time (already stored in results) if       */         /* synclav time is before the first note:                  */         if  (beat.zero <> 0)          /* if passed synclav time is */         then do;                      /* before the time of the    */            extra.dur = 0;             /* first click ...           */            return;         end;         /* compute new last.rate going forward from sync point:    */         last.rate = abs.tlsb - last.tlsb;         /* now compute fractional part into this next beat:        */         load 1000;                    /* get "logical" beat rate   */         mul (time.lsb - goal.tlsb);   /* get actual time into it   */         mwait;                        /* scale to get fractional   */         div last.rate;                /* beats                     */         extra.dur = res + (shl(rem,1) IGE last.rate); /* round */         return;      end;      else do;                         /* mapping beats to sync time */         if  ((our.tmsb ILT time.msb)) /* not there yet              */         or  ((our.tmsb  =  time.msb)          and  (our.tlsb ILE time.lsb))         then do;            if i = NLS.EOS             /* if past end of track,  do some */            then do;                   /* math to get there quickly      */               call SUB32(loc(addr(time.msb)),                          loc(addr(our.tmsb)),                          BitMsbArray);               load bitlsb; uload bitmsb;               div 1000;               /* get # of logical beats         */               j = res;               if j <> 0 then do;                  load j;                 /* advance syncl time by this     */                  mul  last.rate;         /* many beats (rounded down)      */                  bitmsb = ures; bitlsb = res;                  call ADD32(loc(addr(abs.tmsb)),                             BitMsbArray,                             loc(addr(abs.tmsb)));                  call COPY32(loc(addr(abs.tmsb)),   /* set last time correctly */                              loc(addr(last.tmsb)));                  call SUB16 (last.rate, loc(addr(last.tmsb)));                  load j;                 /* advance logical time by this   */                  mul  1000;              /* many beats as well             */                  bitmsb = ures; bitlsb = res;                  call ADD32(loc(addr(our.tmsb)),                             BitMsbArray,                             loc(addr(our.tmsb)));               end;            end;            goto ADVANCE.AND.SKIP;         end;         /* compute new last.rate going forward from sync point:    */         last.rate = abs.tlsb - last.tlsb;         /* compute fractional part into the next beat: */         load last.rate;               /* get "actual" beat rate     */         mul (time.lsb - base.tlsb);   /* get "logical" time into it */         mwait;                        /* scale to get fractional    */         div 1000;                     /* beats                      */         extra.dur = res + (shl(rem,1) IGE 1000); /* round */         return;      end;   end ADVANCE.OURTIME;   /* $PAGE */   last.rate = 1000;                   /* set up useful last.rate     */                                       /* in case no track            */   if  (time.msb  =  0        )        /* make sure passed start time */   and (time.lsb ILT zero.time)        /* is not before zero.time     */   then time.lsb  =  zero.time;   /* Check for non-empty track,  and advance pointers (and time)     */   /* to first note.  First note may be a RTE however.                */   if (time.msb < 0)                   /* if dealing with minus times */   or (ADVANCE.TO.FIRST.NOTE=0)        /* or is an empty track        */   then do;                            /* then return same time       */      remapped.time.msb = time.msb;    /* treat it as if on first beat */      remapped.time.lsb = time.lsb;      remapped.dur.msb  = dur.msb;     /* but just copy duration over */      remapped.dur.lsb  = dur.lsb;      return;   end;   /* Initialize for time scan: */   beat.zero = 1;                        /* detect two notes before  */                                         /* setting rate.            */   our.tmsb  = 0; our.tlsb  = zero.time; /* init "logical" time      */   goal.tmsb = 0; goal.tlsb = zero.time; /* init sync point times    */   base.tmsb = 0; base.tlsb = zero.time; /* in case before 1st note  */   last.tmsb = 0; last.tlsb = 0;   loopmsb   = 0; looplsb   = 0;   call ADVANCE.OURTIME;               /* get OUR.TMSB & OUR.TLSB for TIME.MSB & TIME.LSB */   if sync.to.beats<>0 then do;      remapped.time.msb=base.tmsb;     /* store whole beats as output time */      remapped.time.lsb=base.tlsb;   end;   else do;      remapped.time.msb=goal.tmsb;     /* store synclav time as output     */      remapped.time.lsb=goal.tlsb;   end;   call ADD16(extra.dur, loc(addr(remapped.time.msb)));   if Sync.To.Beats = 2                /* if desires to get synclav beats  */   then do;                            /* duration ...                     */      Sync.To.Beats = 0;               /* now go from beats to sync        */      call COPY32(loc(addr(time.msb)), BitMsbArray); /* get orig sync time */      call COPY32(loc(addr(remapped.time.msb)),      /* save its beat time */                  loc(addr(time.msb         )));     /* for duratoin calc  */      call COPY32(BitMsbArray, loc(addr(remapped.time.msb)));   end;   /* compute new time for end */   /* of note relative to live */   /* click track              */   call ADD32(loc(addr(time.msb)),               loc(addr(dur.msb)),               loc(addr(time.msb)));   call ADVANCE.OURTIME;               /* find out where it is */   if sync.to.beats<>0 then do;      remapped.dur.msb=base.tmsb;     /* store whole beats as output dur */      remapped.dur.lsb=base.tlsb;   end;   else do;      remapped.dur.msb=goal.tmsb;     /* store synclav dur as output     */      remapped.dur.lsb=goal.tlsb;   end;   call ADD16(extra.dur, loc(addr(remapped.dur.msb)));   /* compute new duration by    */   /* subtracting re-mapped time */   /* of note start from         */   /* re-mapped time of note end */   call SUB32(loc(addr(remapped.dur.msb)),              loc(addr(remapped.time.msb)),              loc(addr(remapped.dur.msb)));end REMAP.WITH.LIVE.CLICK;