dcl dbug lit '1';dcl seg.start.lsb fixed;dcl seq.time(1) fixed;dcl click.rate fixed;dcl rmsb fixed;dcl rlsb fixed;dcl divisions fixed;dcl zero.time fixed;dcl ext.clock.mode fixed;dcl samp.crm fixed;   samp.crm = 4;   ext.clock.mode = 5;   seg.start.lsb = 2000;   seq.time(0)   = 0;   seq.time(1)   = 4050;   click.rate    = 500;   rmsb          = 131;   rlsb          = 4719;   divisions     = 500;   zero.time     = 50;DCL RPC   LIT 'WRITE("010")=(-1)+';dcl mam    lit '"60"';     /* memory address msb */dcl mal    lit '"61"';     /* memory address lsb */dcl md     lit '"62"';     /* memory data */dcl mdi    lit '"63"';     /* memory data with increment */DCL LOAD  LIT 'WRITE(5)=';        /* LOAD               */DCL ULOAD LIT 'WRITE(4)=';        /* LOAD UPPER         */DCL REM   LIT 'READ(4)'  ;        /* QUOTIENT REMAINDER */DCL MUL   LIT 'WRITE(6)=';        /* PERFORM MULTIPLY   */DCL DIV   LIT 'WRITE(7)=';        /* PERFORM DIVIDE     */DCL RES   LIT 'READ(5)'  ;        /* RESULT LSB         */DCL URES  LIT 'READ(4)'  ;        /* RESULT MSB         */DCL MWAIT LIT 'WRITE("324")=RES'; /* D5 TO ATNV TO WAIT FOR MUL/DIV */COMPUTE.NEXT.CLOCK.LIMIT: PROC (SEQ.TIME,LIMIT.TIME) PUBLIC;   DCL SEQ.TIME   ARRAY;   DCL LIMIT.TIME ARRAY;   DCL (MSB,LSB)  FIXED;   DCL SPP        FIXED;          /* SONG POSITION POINTER */   DCL X          FIXED;   IF EXT.CLOCK.MODE=2   THEN X=SAMP.CRM;   ELSE X=4;   MSB=SEQ.TIME(0);               /* COPY OF PASSED SEQUENCE TIME */   LSB=SEQ.TIME(1);   IF  (MSB=0)                    /* REMOVE ZERO TIME OFFSET */   AND (LSB ILT ZERO.TIME)   THEN LSB=ZERO.TIME;   IF LSB ILT ZERO.TIME   THEN MSB=MSB-1;   LSB=LSB-ZERO.TIME;   LOAD  LSB;                     /* COMPUTE THE CURRENT SONG POSITION */   ULOAD MSB;   MUL   X;MWAIT;   CAN'T DO THIS...   DIV   DIVISIONS;   SPP = RES;   IF REM<>0 THEN SPP=SPP+1;      /* IF WE ARE BETWEEN BEATS ROUND UP */   LOAD  SPP;                     /* CONVERT THE ROUNDED SPP BACK TO SEQ TIME */   MUL   DIVISIONS;   MSB = URES;   LSB = RES;   LOAD  LSB;   ULOAD MSB;   DIV   X;   MSB = URES;   LSB = RES;   IF (REM>SHR(X+1,1))   THEN DO;      LSB=LSB+1;      IF LSB=0 THEN MSB=MSB+1;   END;   LSB = LSB + ZERO.TIME;         /* RESTORE ZERO.TIME OFFSET */   IF LSB ILT ZERO.TIME   THEN MSB = MSB + 1;   LIMIT.TIME(0)=MSB;             /* COPY INTO RETURN ARGUMENT */   LIMIT.TIME(1)=LSB;END COMPUTE.NEXT.CLOCK.LIMIT;do;   dcl temp(1) fixed;   dcl ret(1)  fixed;   temp(0) = 0;   temp(1) = 0;   ret(0) = 0;   ret(1) = 0;   call compute.next.clock.limit(temp,ret);   print ret(0),;print '   ',;   print ret(1);end;