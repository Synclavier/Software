/*	:SYNRSOU:04-SEQ:166-SEQ6  $TITLE  MORE SEQUENCER ROUTINES	*/

/*
Modified:
1999/04/11 - TY  - Modified "SEQ.INIT" to utilize 4.20 user defaults.
1999/03/31 - TY  - Added calls to "Rebuild.Record.Numbers" in "READ.ENTIRE.SEQUENCE" to correct
						 mapped sequences saved prior to Release 4.20
1998/06/24 - TY  - Simplified code mentioned in the 1998/05/22 entry now that CLICK.TRACK.MODE
						 and CLICKON are independent from each other.
1998/05/22 - TY  - Exorcised Paul's evil and insidious code to "Try to create Tempo Map from
						 Live Click when recalling old sequences".  If you saved a sequence with
						 a click track, you could never get it back as saved, for crying out loud!
						 I replaced it with code that sets up CLICK.TRACK.MODE appropriately based
						 on the existing mode and the mode saved in the sequence.
1991/04/24 - PF  - Init pedal 1 of THD.LIVE.RTES to RTE.MAX instead of zero
1991/03/24 - PF  - Try to create Tempo Map from Live Click when recalling old sequences
1991/02/13 - CJ  - Checked for magic#6
1991/02/01 - PF  - Initialize Divisions in SEQ.INIT
1989/09/23 - CJ  - Mapped sequence times in & out of SEQ.G.P.T (etc)
1989/09/08 - PF  - (MWH) Merged in Paul's MIDI changes; add seq saved bit
1989/07/24 - PF  - SEND T#ARCH_SAVE_SEQUENCE TO MIDINET SCREEN IN WRITE.SEQUENCE
1989/07/17 - PF  - SAVE AND RESTORE THD.MIDI.PATH IN READ.SEQUENCE.TRACKS
1989/07/24 - cj  - moved routines for saving undo sequence here
1988/07/22 - EG  - MODIFIED SAVE SEQ SO THAT IT WON'T REDUCE THE SIZE OF .SQnDATA FILES
1988/06/22 - EG  - ERASE TEMP UNDO TRACKS BEFORE NAH.COLLECT IN SAVE.SEQUENCE
1987/11/17 - cj  - check SEQ.PORT in save.sequence
1987/09/29 - cj  - changed clean.up.after.recall to erase cue audition track
1987/08/25 - EG  - ADDED SAVE.SEQUENCE ROUTINE
1987/06/26 - EG  - CHANGED CLEAN.UP.AFTER.RECALL TO SET MARK.BUTTON.DISABLED TO TRUE
1987/01/16 -TS,CJ- FIXED BUG IN READ.ENTIRE.SEQ CALLING UP GIANT L-FORMAT SEQS
1986/11/03 - TS  - MASSAGED CODE TO SET/STORE OVERALL LOOP START INFO
1986/10/29 - TS  - FIXED TYPO BUG IN WRITE.SEQUENCE (CAUSED MAJOR SEQ TRASHING)
1986/10/20 - TS  - LOAD LOOP PARMS IF OVERALL LOOP IN SETUP.SQ
1986/10/04 - KJO - updated for -7 catalog structure
1986/10/01 - TS  - NOTED SOME BUGS IN READ.ENTIRE.SEQ
1986/09/17 - TS  - MODIFIED SOME MARK BUTTON STUFF
1986/09/12 - TS  - REMOVED ALL DEBUG STUFF AND PUT IN SEQ.BPM INIT FOR OLDER SEQS
1986/08/31 - cj  - removed terminal i/o from loading sequences
1986/08/26 - EG  - ADDED MESSAGE 'LOADING SEQUENCE...'
1986/08/26 - EG  - CHANGED DISPLAY.ERR(11) TO DISPLAY.ERR(14) - NOT ENOUGH ROOM IN MEMORY
1986/08/24 - TS  - PUT THD.ACTIVE.MIDI.RTES CODE INTO SELECTIVE TRK RECALL
1986/08/15 - TS  - COMPRESSES OUT UNUSED TIMBRES IN SETUP.SQ
1986/08/15 - cj  - fixed csem bug.  FIXED STEALOK BUG
1986/08/14 - TS  - ADDED SOME SEQ DBUG STUFF, ADDED ERROR MESSAGE IN SEL TRK RECALL
1986/08/13 - TS  - FIXED THD.USAGE AND THD.REV BUG.; SEQDBUG(0) -> SEQDBUG(1)
1986/08/12 - EG  - changed forward declaration of convert.old.sequence to an external
1986/08/12 - TS  - GOT SELECTIVE TRACK RECALL UP & RUNNING
1986/07/31 - cj  - changes to try.to.read.seq for track soloing
1986/07/15 - CJ  - ZEROED RECS, RECW ON SEQINIT, RECALL
1986/05/15 - "official" creation of release-M modules
*/

DISPLAY.PAR: PROC PUBLIC;	/*	PROCEDURE TO DISPLAY TIMBRE INFO	*/
	AMOUNT="100000";			/*	CAUSES UPDATE BY 0 AMOUNT (SEE 'UPDATE')	*/
END DISPLAY.PAR;

/*	$SUBTITLE  ROUTINE TO ERASE/INITIALIZE SEQUENCER MEMORY	*/

SEQ.INIT: PROC PUBLIC SWAPABLE;	/*	INITIALIZE THE SEQUENCER (ERASE FUNCTION) - ALSO CALLED DURING PROGRAM INITIALIZATION	*/
	DCL (I) FIXED;						/*															- APPARENTLY NOT ANYMORE -TY 1999/04/11		*/

	CALL DEALLOC.ALL;					/*	FREE UP ANY MEMORIES, SOUND FILES, ETC.	*/

	//	Since calls to GID() will change the value written to MAM, we should get the user defaults from GID/PID area
	//	into internal variables before pointing MAM to the base sector.
	SAMP.SPEED		 = GID(Default.Speed);
	SAMP.CLICK.RATE = GID(Default.Click.Rate);

	WRITE(MAM)=BAS.PTR;					/*	INITIALIZE BASE SECTOR	*/
	WRITE(MAL)=SEQ.MARK.MSB;			/*	RESET MARK START TO ZERO	*/
	WRITE(MDI)=0; WRITE(MD)=0;

	write(mal) = SEQ.SPEED;
	write(mdi) = SAMP.SPEED;			//	Set default Sequence Speed
	write(md ) = SAMP.CLICK.RATE;		//	Set default Click Rate

	WRITE(MAL) = SEQ.DTD.SOLOS;
	WRITE(MD ) = 0;

	WRITE(MAL)=NUM.SEQ.PARAMS;			/*	ZERO PARMS ABOVE KNOB AREA	*/
	DO I=NUM.SEQ.PARAMS TO 511; WRITE(MDI)=0; END;

	WRITE(MAM)=BAS.PTR;									/*	NEW MAGIC #					*/
	WRITE(MAL)=MAGIC.NUMBER; WRITE(MD )=MAGIC#5;	/*	no temp map, no groups	*/

	IF POLY.FRE.PTR<>FRE.PTR THEN DO;		/*	THE NEW POLY FREQ TABLE IS LOADED	*/
		WRITE(MAL)=SEQ.POLY.FREQ.TABLE;		/*	SET UP TO MAKE SEQUENCE USE IT		*/
		WRITE(MD )=1;								/*	SET FLAG TO USE NEW POLY SAMPLING FREQ LOOKUP TABLE	*/
		POLY.FREQ.TABLE.PTR=POLY.FRE.PTR;	/*	AND SET PTR TO THE POLY LOOKUP TABLE	*/
	END;

	BAS.LEN=2;

	I=FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS);	/*	FIND END OF KEYBOARD TIMBRES -  ZAP TIMBRES FROM HERE ON	*/
	CALL GET.PAR.STORAGE(SHR(I+255,8));		/*	SET PAR.LEN	*/

	WRITE(MAM)=NAH.PTR;							/*	ZERO OUT NAH (E.G. GET RID OF ALL TRACKS)	*/
	DO I=0 TO 255; WRITE(MDI)=0; END;

	NAH.LEN=1; NAH.FREE=0; NAH.#FREE=0;

	CPLIST0=0;
	ARLIST0=0;
	UPLIST0=0;

	INF.LEN=0;

	TIM.LEN=0; TIM.FREE=0; TIM.#FREE=0;

	WRITE(MAM)=TIM.HEAD;								/*	KEYBOARD TIM.HEAD IS ABSOLUTE	*/
	WRITE(MAL)=1;										/*	SO START WITH 1	*/
	DO I=1 TO MAX.TIMBRES-1; WRITE(MDI)=0; END;

	CALL COMPUTE.TRK.HEADS;
	CALL CLEAN.TRACK.HEADS(NUM.KBD.TRACKS);

	CALL COMPACT.TIMBRES(PAR.PTR,NUM.KBD.TRACKS);	/*	SET UP TIMBRE POINTERS, PAR.NUMT	*/

	CALL ALLOC.AND.COMPUTE;								/*	ALLOC AND PRECOMPUTE 0-PAR.NUMT-1	*/
	CALL COMPUTE.NUMB.LEFT;								/*	CALL PROCEDURE	*/

	CALL CHECK.MEMORY.FOR.RECORD;

	OVERALL.LOOP=0;

	CALL SET.CLOCK.CASE;			/*	SET EXT.CLOCK.CASE TO APPROPRIATE VALUE	*/

	MARK.BUTTON.MSB=0;			/*	RESET MARK START WHEN ERASE	*/
	MARK.BUTTON.LSB=0;
	MARK.BUTTON.DISABLED=0;
	CALL DISPLAY.PARAMETER.BUTTONS;

	CALL COMPUTE.ACTIVE.TRKS;

	CALL PLAY.INITIALIZE;		/*	INITIALIZE PLAY VARIABLES	*/

	NPTR=NOTELIST;					/*	GO THROUGH NOTELIST AND		*/
	DO WHILE NPTR<>0;				/*	SET NACT/NDEC SO NOT			*/
		IF TRACK>=NUM.KBD.TRACKS THEN DO;
			STEALOK=(-2);
		END;
		RECS=0; RECW=0;
		NPTR=NFPTR;
	END;

	/*	Create a system event when sequence is called up:		*/

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 1;

	IF UPPER.DISP<>ERR.DISP
	THEN CALL CLEAR.PARAMETERS;

   interp_seq_dirtyness(2);								 /* remove path in sync3 */
   interp_seq_dirtyness(0);								 /* seq no longer dirty */
END SEQ.INIT;


/*	$SUBTITLE  SETUP.SQ: ROUTINE TO INITIALIZE SEQUENCER AFTER SEQ RECALL	*/

DCL INITIALCSEM FIXED PUBLIC;

SETUP.SQ: PROC PUBLIC SWAPABLE;	/*	INITIALIZE SEQUENCER VARIABLES - USED AFTER SEQUENCE RECALL	*/
	DCL (PTL,TBP,I,J,L,MISC.BASE)	FIXED;

	WRITE(MAM)=BAS.PTR;
	WRITE(MAL)=SEQ.OCTRATIO; OCTRATIO=READ(MD);
	WRITE(MAL)=SEQ.LOOP;		 OVERALL.LOOP=READ(MD)&1;	/*	GET LOOP STATUS	*/

	WRITE(MAL)=SEQ.G.P.T;	 GOBACK.SEQ.TIME.LSB=READ(MD);
	WRITE(MAL)=SEQ.G.P.T.C;	 GOBACK.SEQ.TIME.MSB=READ(MD);

	WRITE(MAL)=SEQ.BPM;		/*	SET BEATS PER MEASURE TO 4 IF WE FIND 0	*/
	IF READ(MD)=0 THEN WRITE(MD)=4;
	SAMP.BPM=READ(MD);

	WRITE(MAL)=SEQ.MARK.MSB;	/*	SET MARK BUTTON	*/
	MARK.BUTTON.MSB=READ(MDI);
	MARK.BUTTON.LSB=READ(MD );

	WRITE(MAL)=SEQ.POLY.FREQ.TABLE;		/*	DETERMINE WHICH POLY SAMPLING FREQ LOOKUP TABLE TO USE	*/
	IF READ(MD)=0
	THEN POLY.FREQ.TABLE.PTR=FRE.PTR;		/*	USE ORIGINAL FREQ LOOKUP TABLE	*/
	ELSE POLY.FREQ.TABLE.PTR=POLY.FRE.PTR;	/*	SET PTR TO THE NEW POLY LOOKUP TABLE	*/

	NEW.KBD.PRE=1;								/*	RECOMPUTE LOOK UP TABLE FOR NEW OCTAVE RATIO	*/

	WRITE(MAL)=SEQ.LIVE.CLICK;
	L=READ(MD)&511;							/*	SEE IF LIVE CLICK TRACK RECORDED IN SEQUENCE	*/

	IF (L ige 4) & (L ilt (4+FIRST.LOD.TRACK-NUM.KBD.TRACKS))
	THEN CLICK.TRACK.MODE = L;
	ELSE IF (CLICK.TRACK.MODE ige 4)		/*	IF CURRENTLY USING LIVE TRACK	*/
	THEN CLICK.TRACK.MODE=0;				/*	THEN RESET TO INTERNAL CLICK	*/

	IF OVERALL.LOOP<>0 THEN DO;
		WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.G.P.T;		/*	PUT LOOP TIMES INTO LOOP PARMS	*/
		LOOP.END.LSB=READ(MDI);		/*	SEQ.G.P.T	*/
		LOOP.END.MSB=READ(MDI);		/*	SEQ.G.P.T.C	*/
		LOOP.START.LSB=READ(MDI);	/*	SEQ.S.P.T	*/
		LOOP.START.MSB=READ(MD );	/*	SEQ.S.P.T.C	*/
		IF (LOOP.START.MSB=0) AND (LOOP.START.LSB ILT ZERO.TIME)
		THEN LOOP.START.LSB=ZERO.TIME;
	END;

	/*	Map the saved sequence times into real times:	*/

	call Map.Sequence.Time.To.Real.Time(loc(addr(goback.seq.time.msb)),
													loc(addr(goback.play.time.msb)));

	/*	RECALL TRACK BUTTON SETTINGS	*/

	DO I = 0 TO SEQ.BUTTON.LEN-1;					/*	LOOP OVER EACH ENTRY					*/
		WRITE(MAM) = BAS.PTR;						/*	FETCH IT									*/
		WRITE(MAL) = SEQ.BUTTON.LIST + I;
		J			  = READ(MD);

		IF ((J >= NUM.KBD.TRACKS  )				/*	IF IS LEGIT ENTRY (EG DETECT OLD	*/
		&&  (J <= LAST.LOD.TRACK-8))				/*	SEQUENCES...							*/
		{
			DO L = 0 TO 7;								/*	SET UP EACH BUTTON ON ROW			*/
				WRITE(MAM) = TBUT.PTR;
				WRITE(MAL) = SHL(I, 3) + L;
				WRITE(MD ) = (READ(MD) & 0xFF00) + J + L;
			END;
		}
	END;

	CALL DISPLAY.SEQUENCER.STATUS;		/*	LIGHT LOOP LIGHT IF LOOPING	*/

	CALL ALLOC.ALL.TIMBRES;					/*	ALLOCATE MEMORIES - SEE IF ENOUGH	*/

	CALL COMPUTE.NUMB.LEFT;					/*	COMPUTE FROM NEW FORMAT	*/

	DO L=0 TO (PAR.NUMT-1);					/*	CHECK TIMBRES	*/

		WRITE(MAM)=TIM.HEAD;					/*	LOOK UP TABLE	*/
		WRITE(MAL)=L;							/*	INDEX				*/

		TBP=READ(MD);							/*	TIMBRE HEAD		*/

		IF TBP<>0 THEN DO;					/*	SET UP TIMBRE HEAD		*/

			INITIALCSEM=INITIALCSEM+1;

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.CSEM;
			WRITE(MD )=INITIALCSEM;

			DO PTL=0 TO NUM.PARTIALS-1;			/*	LOOP OVER PARTIALS	*/

				WRITE(MAM)=TBP;
				WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
				PTPTR=READ(MD);						/*	LOOK UP POINTER HERE FOR NEW FORMAT	*/

				WRITE(MAL)=TIM.PAN.PHASE+PTL;
				WRITE(MD )=0;							/*	RESYNC PARTIAL PHASES DURING RECALL	*/

				IF (P.LOOKUP(PTPTR)<>SUP) THEN DO;		/*	ACTIVE PARTIAL - LOOK FURTHER	*/
					IF P.LOOKUP(PTPTR+P.NEW.CHORUS)<32 THEN WRITE(MD)=1000;	/*	PARTIAL CHORUS - SET TO 1.000 IF UNINITIALIZED	*/
					PTPTR=PTPTR+NUM.PARAMS;					/*	GET TO FIRST ONE		*/
					IF  (P.LOOKUP(PTPTR)=MOR)				/*	IF THERE ARE FRAMES	*/
					AND (P.LOOKUP(PTPTR+TYPE)=TF.TYPE)	/*	OF THE CORRECT VARIETY	*/
					THEN DO;										/*	MARK TIMBRE FRAMES	*/
						IF P.LOOKUP(PTPTR+P.E.SEG.VOL)=0 THEN WRITE(MD)=1000;	/*	INITIALIZE PARTIAL VOLUME IF NOT THERE	*/
					END;
				END;

			END;	/*	OF PARTIALS LOOP	*/

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.MISC.POINTER;
			MISC.BASE=READ(MD);			/*	LOOK UP POINTER	*/

			IF P.LOOKUP(MISC.BASE+CHORUS.LOC)= 0000
			THEN WRITE(MD)=1000;						/*	DETECT VERY OLD TIMBRES WITH NO CHORUS VALUE	*/
			IF P.LOOKUP(MISC.BASE+RTE.LOC   )= 0000
			THEN WRITE(MD)="172";					/*	INITIALIZE OLD RTE'S	*/

			J=SHR(P.LOOKUP(MISC.BASE),8);			/*	GET MAX # OF NOTES	*/
			IF J=0 THEN J=128;
			WRITE(MD)=(READ(MD)&255)\SHL(J,8);	/*	STORE MAX OF 128 IN TIMBRE IF WE GET A ZERO	*/

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.MAX.NUM.NOTES;
			WRITE(MD )=J;

			WRITE(MAL)=TIM.ANY.DPAN;
			WRITE(MD )=0;

		END;

		CALL COMPUTE.ENV.PARAMS(L);		/*	PRECOMPUTE ENVELOPE PARAMETERS	*/
		CALL COMPUTE.LOGS(L);				/*	PRECOMPUTE LOGS	*/
		CALL COMPUTE.RBITS(L);				/*	COMPUTE RTE BITS - ALWAYS CALL AFTER CALL TO COMPUTE.ENV.PARAMS SO TOPTIONS IS SET UP	*/

		IF L>=NUM.KBD.TRACKS					/*	IF NOT A KEYBOARD TIMBRE	*/
		THEN CALL COMPUTE.USAGE.KEY#(L);	/*	RECOMPUTE USAGE KEY # (MUST BE DONE AFTER COMPUTE.ENV.PARAMS)	*/

	END;


	CALL ALLOC.ALL.TIMBRE.USES;	/*	INIT USE.PTR TABLE	*/

	WRITE(MAM)=USE.PTR;				/*	POINT AT TIMBRE USAGE TABLE	*/
	J=NUM.KBD.TRACKS;					/*	ASSUME NO TIMBRES ARE USED	*/
	DO L=NUM.KBD.TRACKS TO MAX.TIMBRES-1;	/*	LOOP OVER ALL NON-KBD TIMBRES	*/
		WRITE(MAL)=L;
		IF READ(MD)<>0 THEN J=L;	/*	THIS TIMBRE IS USED - KEEP ALL BELOW IT AS WELL	*/
	END;

	IF (J+1)<PAR.NUMT					/*	PAR AREA HAS MORE TIMBRES THAN WE NEED	*/
	THEN CALL COMPACT.TIMBRES(PAR.PTR,J+1);	/*	GET RID OF EXTRAS	*/

	CALL COMPUTE.MISC.INFO;			/*	COMPUTE RIBBON & PRESSURE FILTERS	*/

	CALL PLAY.INITIALIZE;			/*	SET UP FOR CONTINUE BUTTON	*/

	IF (MARK.BUTTON.LSB\MARK.BUTTON.MSB)=0	/*	NO MARK BUTTON	*/
	THEN DO;									/*	THEN FIRST.PLAY.TIME.MSB/LSB CONTAINS LOOP START TIME	*/
		WRITE(MAM)=BAS.PTR;				/*	LOOK AT SEQUENCE HEADER				*/
		WRITE(MAL)=SEQ.S.P.T;			/*	SEE IF LOOP START IS AT ZERO		*/
		IF (READ(MDI)\READ(MDI))=0		/*	IF SO, GET INFO FROM PLAY.INIT	*/
		THEN DO;								/*	AND USE IT								*/
			WRITE(MAL)		= SEQ.S.P.T;
			WRITE(MDI)		= LOOP.SEQ.TIME.LSB;		/*	SET NEW SEQ.S.P.T		*/
			WRITE(MD )		= LOOP.SEQ.TIME.MSB;		/*	SET NEW SEQ.S.P.T.C	*/
			LOOP.START.LSB	= LOOP.SEQ.TIME.LSB;
			LOOP.START.MSB	= LOOP.SEQ.TIME.MSB;
			IF (LOOP.START.MSB=0) AND (LOOP.START.LSB ILT ZERO.TIME)
			THEN LOOP.START.LSB=ZERO.TIME;
			CALL DISPLAY.SEQUENCER.STATUS;
		END;
	END;

	/*	Create a system event when sequence is called up:	*/

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 1;

	NEW.BEAT.NUMBER = 0;

	IF UPPER.DISP <> ERR.DISP
	THEN CALL DISPLAY.NUMB.LEFT;	/*	DISPLAY # LEFT EXCEPT DURING STARTUP	*/
END SETUP.SQ;

DCL CONVERT.OLD.SEQUENCE PROC(FIXED,FIXED,FIXED,FIXED) EXTERNAL;

/*	$SUBTITLE  ROUTINES TO WRITE SEQUENCES OUT TO THE DISK	*/

STORE.SEQUENCE.INFO: PROC PUBLIC SWAPABLE;		/*	STORE GLOBAL INFO FOR SEQUENCE STORE	*/
	DCL (I,J)		FIXED;
	DCL BUTTON.1	FIXED;
	DCL BUTTON.9	FIXED;
	DCL BUTTON.17	FIXED;
	DCL BUTTON.25	FIXED;
	DCL DTD.SOLOS	FIXED;


	/*	FETCH CURRENT BUTTON ASSIGNMENTS TO SAVE IN SEQUENCE	*/

	WRITE(MAM) = TBUT.PTR;
	WRITE(MAL) = 0;
	BUTTON.1   = (READ(MD) & 0xFF);

	WRITE(MAL) = 8;
	BUTTON.9   = (READ(MD) & 0xFF);

	WRITE(MAL) = 16;
	BUTTON.17  = (READ(MD) & 0xFF);

	WRITE(MAL) = 24;
	BUTTON.25  = (READ(MD) & 0xFF);


	/*	Save solo state for each track	*/

	DTD.SOLOS = 0;

	DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1;
		WRITE(MAM) = TBUT.PTR;
		WRITE(MAL) = I;
		J			  = READ(MD);

		CALL TRK.HEAD.STORE(I, THD.ACTIVE, J);

		IF  (I>=FIRST.LOD.TRACK)
		AND (I< LAST.LOD.TRACK )
		THEN DO;
			IF ((J & B.SOLOED.TRK) != 0)
				DTD.SOLOS = DTD.SOLOS | BITS(I - FIRST.LOD.TRACK);
		END;

		END;


	/*	STORE INFO IN SEQUENCE BEFORE WRITING TO DISK	*/

	WRITE(MAM) = BAS.PTR;

	WRITE(MAL) = SEQ.BPM;
	WRITE(MD ) = SAMP.BPM;

	WRITE(MAL) = SEQ.MARK.MSB;
	WRITE(MDI) = MARK.BUTTON.MSB;
	WRITE(MD ) = MARK.BUTTON.LSB;

	WRITE(MAL) = SEQ.OCTRATIO;
	WRITE(MD ) = OCTRATIO;							/*	SAVE OCTAVE RATIO	*/

	WRITE(MAL) = SEQ.LOOP;							/*	SEQ.LOOP				*/
	WRITE(MDI) = OVERALL.LOOP;
	WRITE(MDI) = GOBACK.SEQ.TIME.LSB;			/*	SEQ.G.P.T			*/
	WRITE(MDI) = GOBACK.SEQ.TIME.MSB;			/*	SEQ.G.P.T.C			*/

	/*	DON'T WRITE OUT SEQ.S.P.T & SEQ.S.P.T.C	*/
	/*	SINCE THEY ARE ALREADY SET CORRECTLY		*/

	WRITE(MAL) = SEQ.LIVE.CLICK;
	WRITE(MD ) = CLICK.TRACK.MODE;

	WRITE(MAL) = SEQ.NUMTIMBS;
	WRITE(MD ) = PAR.NUMT-NUM.KBD.TRACKS;

	WRITE(MAL) = SEQ.BUTTON.LIST;
	WRITE(MDI) = BUTTON.1;
	WRITE(MDI) = BUTTON.9;
	WRITE(MDI) = BUTTON.17;
	WRITE(MDI) = BUTTON.25;

	WRITE(MAL) = SEQ.DTD.SOLOS;
	WRITE(MD ) = DTD.SOLOS;

	I=FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS);	/*	GET POINTER TO AFTER KEYBOARD TIMBRES	*/
	I=SHR(PAR.TOP-I+255,8);						/*	LENGTH OF SEQ TIMBRES IN SECTORS	*/

	WRITE(MAM) = BAS.PTR;
	WRITE(MAL) = SEQ.NUMSEC;
	WRITE(MDI) = BAS.LEN+I+NAH.LEN+INF.LEN;

	WRITE(MDI) = 0;								/*	SEQ.BAS	*/
	WRITE(MDI) = BAS.LEN;						/*	BAS.LEN	*/

	WRITE(MDI) = BAS.LEN;						/*	SEQ.PAR	*/
	WRITE(MDI) = I;								/*	PAR.LEN	*/

	WRITE(MDI) = BAS.LEN+I;						/*	SEQ.NAH	*/
	WRITE(MDI) = NAH.LEN;						/*	NAH.LEN	*/

	WRITE(MDI) = BAS.LEN+I+NAH.LEN;			/*	SEQ.INF	*/
	WRITE(MDI) = INF.LEN;						/*	INF.LEN	*/

	WRITE(MDI)=0;  WRITE(MDI) = 0;
	WRITE(MDI)=0;  WRITE(MDI) = 0;
	WRITE(MDI)=0;  WRITE(MDI) = 0;
	WRITE(MDI)=0;  WRITE(MDI) = 0;

END STORE.SEQUENCE.INFO;


/*	$PAGE	*/


WRITE.SEQUENCE: PROC (DEV,SEC) PUBLIC SWAPABLE;	/*	WRITE SEQUENCE TO SECTOR OF DISK.  THIS ROUTINE ASSUMES COMPACTED MEMORY.	*/
	DCL (I,J,K,DEV,SEC)	FIXED;
	DCL (MSB,LSB)			FIXED;

	NEW.SEQ.INFO = NEW.SEQ.INFO | 32768;		/*	INFORM MIDINET OF SEQUENCE STORE	*/

	CALL STORE.SEQUENCE.INFO;						/*	STORE OCTRATIO, SOLOS, ETC.		*/

	I=FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS);		/*	GET POINTER TO AFTER KEYBOARD TIMBRES	*/
	J=SHR(PAR.TOP-I+255,8);							/*	LENGTH OF SEQ TIMBRES IN SECTORS	*/

	IF INC.MONO<>0  THEN CALL STOP.DISK;		/*	STOP OUTPUT SO WE CAN READ DISK	*/

	DO K=0 TO 255;										/*	ZERO OUT MISC BUF FOR NOW			*/
		MISC.BUF(K)=0;
	END;

   interp_seq_dirtyness(2);                  /* Remove current sequence path; new one will be assigned if this is a write to a Mac file */

	CALL WRITEDATA(DEV,SEC,MISC.BUF,256);		/*	ZERO OUT FIRST SECTOR UNTIL OTHER WRITES COMPLETED	*/

	MSB=DEV; LSB=SEC;

	LSB=LSB+BAS.LEN;
	IF LSB ILT BAS.LEN THEN MSB=MSB+1;

	IF J<>0 THEN DO;
		CALL EXT.WRITEDATA(MSB,LSB,PAR.PTR,I,0,PAR.TOP-I);	/*	PARS	*/
	END;

	LSB=LSB+J;
	IF LSB ILT J THEN MSB=MSB+1;

	CALL EXT.WRITEDATA(MSB,LSB,NAH.PTR,0,NAH.LEN,0);		/*	NOTES	*/

	LSB=LSB+NAH.LEN;
	IF LSB ILT NAH.LEN THEN MSB=MSB+1;

	IF INF.LEN<>0 THEN DO;
		CALL EXT.WRITEDATA(MSB,LSB,INF.PTR,0,INF.LEN,0);	/*	INF	*/
	END;

	CALL EXT.WRITEDATA(DEV,SEC,BAS.PTR,0,BAS.LEN,0);		/*	NOW BASE AREA	*/

	CALL COMPUTE.ACTIVE.TRKS;										/*	RECOMPUTE THD.ACTIVE	*/
	CALL DISK.MESSAGE(BAS.LEN+J+NAH.LEN+INF.LEN);

	interp_seq_dirtyness(0);                              /* seq no longer dirty */
END WRITE.SEQUENCE;

PUBLISH.SEQ.FILE.NAME:PROC(TREENAME, LEVEL) PUBLIC SWAPABLE;
	DCL TREENAME	ARRAY;
	DCL LEVEL		FIXED;
	dcl file(AEE.Sequence.Name.Wlen+8)	fixed;

	dcl Get.Complete.Tree.Name proc (array, array) external;

	IF (LEVEL != 1)			/*	ONLY WORKS FOR LEVEL == 1	*/
		RETURN;

	if (TREENAME(0) > shl(Cur.Seq.Path.Name.Wlen-1,1))
		 TREENAME(0) = shl(Cur.Seq.Path.Name.Wlen-1,1);

	Get.Complete.Tree.Name(TREENAME, file);

	if (file(0) > shl(Cur.Seq.Path.Name.Wlen-1,1))
		 file(0) = shl(Cur.Seq.Path.Name.Wlen-1,1);

	call GID(Cur.Seq.Path.Name);
	call COPY.OUT(addr(file(0)), Cur.Seq.Path.Name.Wlen);

END PUBLISH.SEQ.FILE.NAME;

SAVE.SEQUENCE: PROC (TREENAME, LEVEL, TERM) FIXED PUBLIC SWAPABLE;
	DCL TREENAME	ARRAY;	/*	TREE/FILENAME TO SAVE SEQUENCE	*/
	DCL LEVEL		FIXED;	/*	LEVEL TO SAVE AT	*/
	DCL TERM			BOOLEAN;	/*	0=KBD, 1=TERM; USED TO DETERMINE WHERE TO SHOW ERROR MSGS.	*/
	DCL LEN			FIXED;
	DCL FILENAME (4)	FIXED;

	REPLACE.SEQ: PROC(TREENAME, LEN, LEVEL, TERM);
		DCL TREENAME	ARRAY;
		DCL LEN			FIXED;
		DCL LEVEL		FIXED;
		DCL TERM			FIXED;

		IF (REPLACE(TREENAME, T#SYNC, 0, LEN, SHL(LEN,8), LEVEL))
		THEN DO;
			dcl Cat.Cache.File.Type				fixed external;
			dcl Protocol.Cat.Cache.File.Type	fixed external;

			CALL WRITE.SEQUENCE(F#MS_SECTOR,F#LS_SECTOR);
			PUBLISH.SEQ.FILE.NAME(TREENAME, LEVEL);

			Cat.Cache.File.Type			  = 0;
			Protocol.Cat.Cache.File.Type = 0;
		END;
		ELSE DO;
			CALL HANDLE.CAT.ERROR(TERM);
			RETURN (0);						/*	SOME FILE ERROR HAPPENED, BOMB OUT	*/
		END;
		RETURN (1);
	END REPLACE.SEQ;

	COMPUTE.SEQ.LENGTH: PROC;
		DCL LENGTH FIXED;

		CALL ERASE.TRACK(UNDO.TRK);			/*	WANT TO MAKE SURE THESE TRACKS	*/
		CALL ERASE.TRACK(UNDO.TMP.TRK);		/*	ARE NOT SAVED WITH THE SEQUENCE	*/

		CALL NAH.COLLECT;										/*	CLEAN UP NOTE AREA	*/

		LENGTH=FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS);	/*	GET POINTER TO AFTER KEYBOARD TIMBRES	*/
		LENGTH=SHR(PAR.TOP-LENGTH+255,8);				/*	LENGTH OF SEQ TIMBRES IN SECTORS	*/
		LENGTH=LENGTH+BAS.LEN;								/*	ADD BASE LENGTH	*/
		IF LENGTH ILT BAS.LEN
		THEN RETURN 0;											/*	OVERFLOW, BOMB OUT	*/
		ELSE DO;
			LENGTH=LENGTH+NAH.LEN;
			IF LENGTH ILT NAH.LEN
			THEN RETURN 0;										/*	OVERFLOW	*/
			ELSE DO;
				LENGTH=LENGTH+INF.LEN;
				IF LENGTH ILT INF.LEN
				THEN RETURN 0;									/*	OVERFLOW	*/
				ELSE DO;
					RETURN LENGTH;								/*	OK - RETURN COMPUTED LENGTH	*/
				END;
			END;
		END;
	END COMPUTE.SEQ.LENGTH;

	IF LOCATE(TREENAME, LEVEL) THEN DO;					/*	FILE EXISTS	*/
		IF (F#TYPE<>T#SYNC)\(F#LS_LENGTH=0) THEN DO;
			call Set.Error(err.tme, treename);
			RETURN (0);						/*	SOME FILE ERROR HAPPENED, BOMB OUT	*/
		END;
		ELSE DO;
			call READDATA(F#MS_Sector, F#LS_Sector, Misc.Buf, 256);
			if  (((Misc.Buf(MAGIC.NUMBER) = MAGIC#5)
			||    (MIsc.Buf(MAGIC.NUMBER) = MAGIC#6)
			||    (MIsc.Buf(MAGIC.NUMBER) = MAGIC#7))
			&&   ((Misc.Buf(SEQ.PROT)&1) <> 0))
			then do;
				call DISPLAY.ERR(58);	/*	sequence file is protected	*/
			end;
			else do;
				LEN = COMPUTE.SEQ.LENGTH;
				IF (LEN<>0) THEN DO;
               // For sync3 saves to W0, always just write to the file; it's a mac file.
               if (interp_w0_write_protected(0) != 0 && LEVEL == 0) {
                  CALL WRITE.SEQUENCE(F#MS_SECTOR,F#LS_SECTOR);
                  PUBLISH.SEQ.FILE.NAME(TREENAME, LEVEL);
               }

               /*	WANT TO CHECK TO SEE IF THIS IS A .SQnDATA FILE			*/
					/*	IF IT IS, WE DON'T WANT TO MAKE IT SHORTER, BECAUSE	*/
					/*	THIS WILL CAUSE PROBLEMS WHEN THE USER WANTS TO SAVE	*/
					/*	A SEQUENCE FROM THE BUTTON PANEL.							*/

					ELSE IF  (BYTE(TREENAME, 0) = A.PERIOD)
					AND      ((BYTE(TREENAME, 1) = A.S) OR (BYTE(TREENAME, 1) = L.S))
					AND      ((BYTE(TREENAME, 2) = A.Q) OR (BYTE(TREENAME, 2) = L.Q))
					AND      ((BYTE(TREENAME, 4) = A.D) OR (BYTE(TREENAME, 4) = L.D))
					AND      ((BYTE(TREENAME, 5) = A.A) OR (BYTE(TREENAME, 5) = L.A))
					AND      ((BYTE(TREENAME, 6) = A.T) OR (BYTE(TREENAME, 6) = L.T))
					AND      ((BYTE(TREENAME, 7) = A.A) OR (BYTE(TREENAME, 7) = L.A))
					THEN DO;
						IF F#LS_LENGTH ILT LEN
						THEN RETURN REPLACE.SEQ(TREENAME, LEN, LEVEL, TERM);
						ELSE DO;
							CALL WRITE.SEQUENCE(F#MS_SECTOR,F#LS_SECTOR);
							PUBLISH.SEQ.FILE.NAME(TREENAME, LEVEL);
						END;
					END;

					ELSE RETURN REPLACE.SEQ(TREENAME, LEN, LEVEL, TERM);	/*	ELSE MAKE SAVED FILE THE SAME LENGTH AS THE SEQUENCE	*/
				END;
				ELSE DO;
					CALL HANDLE.CAT.ERROR(TERM);
					RETURN (0);						/*	SOME FILE ERROR HAPPENED, BOMB OUT	*/
				END;
			END;
		END;
	END;
	ELSE DO;
		IF (C#STATUS = E#NO_FILE) THEN DO;	/*	FILE DOESN'T EXIST, OK, MAKE A NEW ONE	*/
			LEN = COMPUTE.SEQ.LENGTH;
			IF (LEN<>0)
			THEN RETURN REPLACE.SEQ(TREENAME, LEN, LEVEL, TERM);	/*	WRITE OUT NEW SEQUENCE FILE	*/
			ELSE DO;
				CALL HANDLE.CAT.ERROR(TERM);
				RETURN (0);							/*	SOME FILE ERROR HAPPENED, BOMB OUT	*/
			END;
		END;
		ELSE DO;
			CALL HANDLE.CAT.ERROR(TERM);
			RETURN (0);								/*	SOME FILE ERROR HAPPENED, BOMB OUT	*/
		END;
	END;

	RETURN 1;
END SAVE.SEQUENCE;

BEGIN;

	DCL (DEV,SEC)					FIXED;	/*	LOCAL GLOBAL FOR DEV & SEC ADDR OF SEQUENCE	*/
	DCL (MSB,LSB)					FIXED;
	DCL (KWRD,KLEN)				FIXED;
	DCL (PWRD,PLEN)				FIXED;
	DCL (NWRD,NLEN)				FIXED;
	DCL (NAHSEC,THDSEC)			FIXED;
	DCL (NEW.LEN,NEW.PAR.LEN)	FIXED;
	DCL (OLD.LEN,OLD.PAR.LEN)	FIXED;
	DCL (NEXT.DISK.NLS)			FIXED;
	DCL (PRIOR.NLS,NEXT.NLS)	FIXED;
	DCL (I,J,K,L,M,N)				FIXED;

	DCL (SPOS,WPOS,WLEN,PARLEN)	FIXED;
	DCL (S.BF.DEV,S.BF.SEC)		FIXED;
	DCL (S.BF.PTR)					FIXED;

	DCL NUM.OSEQ.MISC LIT '256';	/*	LENGTH OF ORIGINAL MISC AREA		*/
	DCL	  OSEQ.SLEN LIT ' 80';	/*	LOCATION OF SEQ.TOP - *** MUST BE SEQ.POINTERS+NUM.TRACKS ***	*/
	DCL	  OSEQ.PLEN LIT ' 82';	/*	LENGTH OF PARAMETER AREA IN NEW FORMAT SEQUENCES	*/



ADD.TO:PROC(X) SWAPABLE;					/*	32-BIT ADD	*/
	DCL X FIXED;

	LSB=LSB+X;
	IF LSB ILT X THEN MSB=MSB+1;
END;

CLEAN.UP.AFTER.RECALL:  PROC SWAPABLE;

	/*	Create a system event when sequence is called up:	*/

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 1;

	IF NUM.OF.HELD.TRACK.BUTTONS=0	/*	ONLY RESET IF DOING FULL SEQ RECALL	*/
	THEN DO;									/*	MARK BUTTON INFO IS RECALLED WITH SEQUENCE	*/
		IGNORE.LOOPS = FALSE;			/*	DON'T WANT TO IGNORE UNLESS SET BY USER	*/
	END;

	CALL COMPUTE.TRK.HEADS;
	CALL CLEAN.TRACK.HEADS(NUM.KBD.TRACKS);
	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP TIMBRE POINTERS, PAR.NUMT	*/
	CALL COMPUTE.ACTIVE.TRKS;
	CALL SETUP.SQ;										/*	SET UP GLOBAL INFO					*/
	CALL CHECK.MEMORY.FOR.RECORD;

	NPTR=NOTELIST;					/*	GO THROUGH NOTELIST AND		*/
	DO WHILE NPTR<>0;				/*	SET NACT/NDEC SO NOT			*/
		IF TRACK>=NUM.KBD.TRACKS THEN DO;
			STEALOK=(-2);
		END;
		RECS=0; RECW=0;
		NPTR=NFPTR;
	END;

	CALL DISPLAY.PARAMETER.BUTTONS;
	CALL DISPLAY.SEQUENCER.STATUS;
	CALL DISPLAY.TRACK.BUTTONS;

	/*	ERASE POSSIBLE CUE AUDITION TRACK	*/
	/*	MAY HAVE BEEN WRITTEN OUT				*/
	/*	WITH SEQUENCE								*/

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=CUE.AUDITION.TRACK;
	IF READ(MD)<>0
	THEN CALL ERASE.TRACK(CUE.AUDITION.TRACK);

END CLEAN.UP.AFTER.RECALL;

READ.ENTIRE.SEQUENCE: PROC SWAPABLE;

	KWRD = FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS);	/*	GET LENGTH OF KBD TIMBRE(S)	*/
	KLEN = SHR(KWRD+255,8);

	IF (MISC.BUF(MAGIC.NUMBER)=MAGIC#5)		/*	256-TRACK MODEL			*/
	OR (MISC.BUF(MAGIC.NUMBER)=MAGIC#6)		/*	256-TRACK MODEL			*/
	OR (MISC.BUF(MAGIC.NUMBER)=MAGIC#7)		/*	256-TRACK MODEL			*/
	THEN DO;

		MSB=0; LSB=0;								/*	INITIALIZE SUM				*/
		CALL ADD.TO(BAS.PTR);					/*	KEEP BAS.PTR IN SAME		*/
		CALL ADD.TO(MISC.BUF(SEQ.BAS+1));	/*	COMPUTE BAS.LEN			*/
		CALL ADD.TO(KLEN);						/*	KEYB TIMBRES				*/
		CALL ADD.TO(MISC.BUF(SEQ.PAR+1));	/*	SEQ  PAR.LEN				*/
		CALL ADD.TO(MISC.BUF(SEQ.NAH+1));	/*	SEQ  NAH.LEN				*/
		CALL ADD.TO(MISC.BUF(SEQ.INF+1));	/*	SEQ  INF.LEN				*/

		IF (MSB<>0)									/*	OVERFLOW						*/
		OR (LSB IGE TRD.PTR)						/*	OR NO WAY JOSE				*/
		THEN DO;
			CALL DISPLAY.ERR(14);				/*	'NOT ENOUGH ROOM IN MEMORY'	*/
			CALL DISPLAY.SEQUENCER.STATUS;
			RETURN FALSE;
		END;

		/*	CLEAN UP MEMORY	*/

		CALL DEALLOC.ALL;							/*	FREE UP ANY MEMORIES, SOUND FILES, ETC.	*/

		INF.LEN=0;									/*	CLEAN OUT SPACE	*/
		TIM.LEN=0; TIM.FREE=0; TIM.#FREE=0;

		WRITE(MAM)=TIM.HEAD;						/*	KEYBOARD TIM.HEAD IS ABSOLUTE	*/
		WRITE(MAL)=1;								/*	SO START WITH 1	*/
		DO I=1 TO MAX.TIMBRES-1;
			WRITE(MDI)=0;
		END;

		CALL SHUFFLE.BNK.UP;						/*	TRY TO PRESERVE BANK	*/

		PAR.NUMT	= NUM.KBD.TRACKS;				/*	KEEP INFO CONSISTENT FOR NOW	*/
		PAR.TOP	= KWRD;
		PAR.LEN	= KLEN;


		/*	$PAGE	*/


		/*	READ IN BAS.PTR	*/

		BAS.PTR = BAS.PTR;						/*	LEAVE BAS.PTR WHERE IS	*/
		BAS.LEN = MISC.BUF(SEQ.BAS+1);		/*	GET NEW BAS.LEN			*/

		/*	MOVE KBD PARAMETERS IN		*/
		/*	CASE NEW BAS.LEN IS LONGER	*/

		CALL COPY.EXT.MEM.SEC(PAR.PTR,BAS.PTR+BAS.LEN,PAR.LEN);	/*	IN CASE NEW BAS.LEN IS DIFFERENT	*/
		PAR.PTR=BAS.PTR+BAS.LEN;

		MSB=DEV; LSB=SEC;							/*	READ IN BAS.PTR	*/
		CALL ADD.TO(MISC.BUF(SEQ.BAS));
		CALL EXT.READDATA(MSB,LSB,BAS.PTR,0,BAS.LEN,0);


		/*	READ IN PAR.PTR	*/

		PAR.PTR = PAR.PTR;							/*	PAR.PTR WAS COMPUTED ABOVE	*/
		PAR.LEN = PAR.LEN+MISC.BUF(SEQ.PAR+1);	/*	CONSERVATIVELY ESTIMATE PARAMETER LENGTH	*/

		MSB=DEV; LSB=SEC;
		CALL ADD.TO(MISC.BUF(SEQ.PAR));
		CALL EXT.READDATA(MSB,LSB,PAR.PTR,KWRD,MISC.BUF(SEQ.PAR+1),0);

		PAR.NUMT=PAR.NUMT+MISC.BUF(SEQ.NUMTIMBS);


		/*	READ IN NAH.PTR	*/

		NAH.PTR = PAR.PTR+PAR.LEN;
		NAH.LEN = MISC.BUF(SEQ.NAH+1);

		MSB=DEV; LSB=SEC;
		CALL ADD.TO(MISC.BUF(SEQ.NAH));
		CALL EXT.READDATA(MSB,LSB,NAH.PTR,0,NAH.LEN,0);

		IF (NAH.PTR+NAH.LEN) IGT BNK.PTR		/*	CRASHED INTO BANK	*/
		THEN DO;
			BNK.PTR=INF.PTR; BNK.LEN=0;
		END;

		NAH.FREE=0; NAH.#FREE=0;
		CPLIST0=0;
		ARLIST0=0;
		UPLIST0=0;


		/*	READ IN INF.PTR	*/

		IF MISC.BUF(SEQ.INF+1)<>0 THEN DO;	/*	INF AREA EXISTS	*/
			INF.LEN=MISC.BUF(SEQ.INF+1);		/*	GET NEW LENGTH		*/
			IF BNK.LEN<>0 THEN DO;				/*	IF BANK EXISTS		*/
				IF ((BNK.PTR ILT INF.LEN))		/*	GROSS OVERFLOW		*/
				OR ((BNK.PTR-INF.LEN) ILE (NAH.PTR+NAH.LEN))
				THEN DO;
					BNK.PTR=INF.PTR;
					BNK.LEN=0;
				END;
				ELSE CALL COPY.EXT.MEM.SEC(BNK.PTR,BNK.PTR-INF.LEN,BNK.LEN);
			END;
			BNK.PTR=BNK.PTR-INF.LEN;
			INF.PTR=INF.PTR-INF.LEN;
			MSB=DEV; LSB=SEC;
			CALL ADD.TO(MISC.BUF(SEQ.INF));
			CALL EXT.READDATA(MSB,LSB,INF.PTR,0,INF.LEN,0);
		END;

	END;


	/*	$PAGE	*/


	ELSE DO;

		/*	CONVERT FROM OLD FORMAT	*/
		/*	TO NEW FORMAT				*/

		/*	READ IN SEQUENCE - CONVERT TO NEW FORMAT IF REQUIRED	*/

		IF MISC.BUF(MAGIC.NUMBER)<>MAGIC#4
		THEN PWRD=LEN.SEQ.TIMBS;			/*	RECALLING OLD FORMAT, OR SFM SEQUENCE - TIMBRE LENGTH IS FIXED	*/
		ELSE PWRD=MISC.BUF(OSEQ.PLEN);	/*	ELSE GET PARAMETER LENGTH DATA FROM SEQUENCE	*/
		NWRD		=MISC.BUF(OSEQ.SLEN);	/*	GET LENGTH OF NOTES + MISC	*/

		PLEN=SHR(PWRD+255,8);				/*	LENGTH OF TIMBRE PARAMS IN SECTORS	*/
		NLEN=SHR(NWRD-1  ,8);				/*	GET SECTOR LENGTH OF NOTES ONLY		*/

		I=1+16+NLEN+SHR(NLEN+15,4);		/*	ESTIMATE FOR NAH, TRK HEADERS, NOTES	*/

		IF ((KLEN+PLEN				) IGE 254	 )	/*	TIMBRE AREA IS TOO LONG	*/
		OR ((BAS.PTR+KLEN+PLEN+I) IGT TRD.PTR)	/*	OR NO GO IN MEMORY		*/
		THEN DO;
			CALL DISPLAY.ERR(14);			/*	'NOT ENOUGH ROOM IN MEMORY'	*/
			CALL DISPLAY.SEQUENCER.STATUS;
			RETURN FALSE;
		END;

		/*	CLEAN UP MEMORY	*/

		CALL DEALLOC.ALL;							/*	FREE UP ANY MEMORIES, SOUND FILES, ETC.	*/

		INF.LEN=0;									/*	CLEAN OUT SPACE	*/
		TIM.LEN=0; TIM.FREE=0; TIM.#FREE=0;

		WRITE(MAM)=TIM.HEAD;						/*	KEYBOARD TIM.HEAD IS ABSOLUTE	*/
		WRITE(MAL)=1;								/*	SO START WITH 1	*/
		DO I=1 TO MAX.TIMBRES-1;
			WRITE(MDI)=0;
		END;

		CALL SHUFFLE.BNK.UP;						/*	TRY TO PRESERVE BANK	*/

		PAR.NUMT	= NUM.KBD.TRACKS;				/*	KEEP INFO CONSISTENT FOR NOW	*/
		PAR.TOP	= KWRD;
		PAR.LEN	= KLEN;


		/*	SET UP BAS.PTR	*/

		BAS.PTR	= BAS.PTR;						/*	LEAVE BAS.PTR WHERE IS	*/
		BAS.LEN	= 2;								/*	GET NEW BAS.LEN			*/

		/*	MOVE KBD PARAMETERS IN		*/
		/*	NEW CASE BAS.LEN IS LONGER	*/

		CALL COPY.EXT.MEM.SEC(PAR.PTR,BAS.PTR+BAS.LEN,PAR.LEN);	/*	IN CASE NEW BAS.LEN IS DIFFERENT	*/
		PAR.PTR=BAS.PTR+BAS.LEN;

		IF (PAR.PTR+PAR.LEN+PLEN+NLEN+10) IGT BNK.PTR
		THEN DO;										/*	MUST TOSS BANK IMMEDIATELY	*/
			BNK.PTR=BNK.PTR+BNK.LEN;
			BNK.LEN=0;
		END;


		/*	$PAGE	*/


		I=BNK.PTR-NLEN-PLEN-1;					/*	PARAMS WILL GO HERE			*/
		J=BNK.PTR-NLEN-1;							/*	NOTES WILL GO HERE			*/

		IF MISC.BUF(MAGIC.NUMBER)<>MAGIC#4 THEN DO;		/*	#1, #2, #3			*/
			MSB=DEV; LSB=SEC;										/*	POINTER TO PARAMS	*/
			CALL ADD.TO(1);										/*	SKIP OVER MISC		*/
			CALL EXT.READDATA(MSB,LSB,I,0,0,PWRD+NWRD-256);
			CALL COPY.EXT.MEM(I,PWRD,J,0,NWRD-256);		/*	COPY NOTES UP TO SECTOR BOUNDARY	*/
		END;
		ELSE DO;				/*	READ IN PARAMS & SEQUENCE TOGETHER	*/
			MSB=0; LSB=PWRD;
			CALL ADD.TO(NWRD);									/*	WATCH FOR 32-BIT SUM	*/
			K=SHL(MSB,8); L=LSB;									/*	CONVERT TO SECTORS & WORDS (STILL UNNORMALIZED, THOUGH)	*/
			MSB=DEV; LSB=SEC;										/*	POINTER TO PARAMS	*/
			CALL ADD.TO(1);										/*	SKIP OVER MISC		*/
			CALL EXT.READDATA(MSB,LSB,I,0,K,L);
			CALL COPY.EXT.MEM(I+1,PWRD,J,0,NWRD-256);		/*	TRASH SECOND MISC AREA.  MOVE NOTES TO SECTOR BOUNDARY	*/
		END;

		IF CONVERT.OLD.SEQUENCE(I,PLEN,J,NLEN)=0			/*	CONVERT TO NEW FORMAT	*/
		THEN DO;

			WRITE(MAM)=BAS.PTR;									/*	SERIOUS ERROR IF BOMB OUT	*/
			DO I=0 TO 511; WRITE(MDI)=0; END;

			WRITE(MAM)=BAS.PTR;
			DO I=0 TO 11;							/*	SEQ.SCALE				*/
				WRITE(MDI)=WESTERN.SCALE(I);
			END;
			WRITE(MDI)=1000;						/*	SEQ.SPEED TO 1.000	*/
			WRITE(MDI)=500;						/*	SEQ.CLICK TO	500	*/
			WRITE(MDI)=4;							/*	SEQ.CRM	 TO	  4	*/

			WRITE(MAL)=MAGIC.NUMBER; WRITE(MD )=MAGIC#5;	/*	would be no groups or maps at this point	*/
			WRITE(MAL)=SEQ.OCTRATIO; WRITE(MD )=1000;

			PAR.LEN=SHR(FIND.TIMBRE(PAR.PTR,NUM.KBD.TRACKS)+255,8);
			PAR.NUMT=NUM.KBD.TRACKS;

			NAH.PTR=PAR.PTR+PAR.LEN;
			NAH.LEN=1;

			WRITE(MAM)=NAH.PTR;
			DO I=0 TO 255; WRITE(MDI)=0; END;

		END;

	END;

	IF KEYBOARD.TIMBRE.CONTROL<>0 THEN DO;		/*	KEYBOARD IS SHARING TIMBRE	*/
		KEYBOARD.TIMBRE.CONTROL=0;					/*	RECLAIM TIMBRE - DO NOT COPY TO TRACK!	*/
		CALL DISPLAY.SMT.SKT.BUTTONS;				/*	TURN OFF SKT BUTTON	*/
	END;

	CALL CLEAN.UP.AFTER.RECALL;	/*	DO A BUNCH OF SEQ SETUP STUFF	*/

	//	Correct mapped sequences saved prior to Release 4.20
	dcl Rebuild.Record.Numbers proc (fixed,boolean) external;
	if (Tempo.Map.Ptr != 0) Rebuild.Record.Numbers(Tempo.Map#,true);
	if (Meter.Map.Ptr != 0) Rebuild.Record.Numbers(Meter.Map#,true);

	CALL INIT.LIVE.RTES;			/*	RESET THD.LIVE.RTES VALUES		*/

	interp_seq_dirtyness(0);   /* seq no longer dirty */

	RETURN TRUE;					/*	ALL DONE	*/

END READ.ENTIRE.SEQUENCE;


/*	$SUBTITLE  SELECTIVE TRACK RECALL	*/


READ.SEQUENCE.TRACKS: PROC SWAPABLE;
	DCL TRACKS_HELD	FIXED;	/*	NO. TRACKS TO LOAD	*/
	DCL CHECK.ILS.SEC	FIXED;
	DCL CHECK.ILE.SEC	FIXED;
	DCL TEMP.BUF(7)	FIXED;
	DCL TEMP.ACTIVE	FIXED;
	DCL DISK.GRPLIST	FIXED;

	SEQUENCE.TRACKS.CLEANUP:PROC;
		DCL I FIXED;

		CALL DEALLOC.ALL;							/*	FREE UP ANY MEMORIES, SOUND FILES, ETC.	*/

		TIM.LEN=0; TIM.FREE=0; TIM.#FREE=0;

		WRITE(MAM)=TIM.HEAD;						/*	KEYBOARD TIM.HEAD IS ABSOLUTE	*/
		WRITE(MAL)=1;								/*	SO START WITH 1	*/
		DO I=1 TO MAX.TIMBRES-1;
			WRITE(MDI)=0;
		END;

		CALL CLEAN.UP.AFTER.RECALL;
	END;

	IF  (MISC.BUF(MAGIC.NUMBER)<>MAGIC#5)	/*	NOT A 256-TRACK MODEL SEQ	*/
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#6)	/*	NOT A 256-TRACK MODEL SEQ	*/
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#7)	/*	NOT A 256-TRACK MODEL SEQ	*/
	THEN DO;											/*	SELECTIVE TRACK RECALL NOT ALLOWED	*/
		CALL DISPLAY.ERR(51);					/*	DISPLAY 'CANNOT RECALL TRK FROM OLD SEQ'	*/
		CALL DISPLAY.SEQUENCER.STATUS;		/*	UPDATE LIGHT DISPLAY	*/
		RETURN FALSE;
	END;


	/*	BACK OUT THE SOLOING THAT WAS JUST DONE WHEN THE TRACK BUTTONS WERE PRESSED	*/

	DO I=0 TO (NUM.TRACK.BUTTONS-1);	/*	LOOP OVER TRACK BUTTONS	*/

		WRITE(MAM)=TBUT.PTR;				/*	SEE IF TRK BUTTON HELD	*/
		WRITE(MAL)=I;

		IF (READ(MD)&B.HELD.TRK)<>0 THEN DO;
			TOGGLE.TRACK.SOLO.STATE(READ(MD)&255);
		END;
	END;

	CALL STORE.SEQUENCE.INFO;			/*	STORE OCTRATIO, SOLOS, ETC. (IN CASE CALL TO SETUP.SEQ BELOW)	*/


	/*	FOR SELECTIVE TRACK RECALL:

			MISC.BUF - HOLDS THE BASE SECTOR (SEQ.BAS)
			NAHSEC   - PTR TO XMEM SECTOR - HOLDS 1ST SECTOR OF NAH AREA
			THDSEC   - PTR TO XMEM SECTOR - HOLDS TRK HEAD FOR TRK BEING RECALLED
	*/

	NAHSEC=ALLOCATE.NAH.BLOCK;				/*	GET A WORK SECTOR			*/

	IF NAHSEC=0 THEN DO;						/*	RAN OUT OF MEMORY			*/
			CALL COMPUTE.ACTIVE.TRKS;		/*	RESTORE THD.ACTIVE		*/
		CALL DISPLAY.ERR(14);				/*	'NOT ENOUGH ROOM IN MEMORY'	*/
		CALL DISPLAY.SEQUENCER.STATUS;	/*	UPDATE LIGHT DISPLAY		*/
		RETURN FALSE;							/*	BOMB OUT						*/
	END;

	LSB=NUM.OF.HELD.TRACK.BUTTONS;		/*	INIT CTR TO # OF TRKS TO LOAD	*/
	MSB=DEV; LSB=SEC;
	CALL ADD.TO(MISC.BUF(SEQ.NAH));
	CALL EXT.READDATA(MSB,LSB,NAH.PTR+NAHSEC,0,1,0);	/*	READ IN ARRAY OF TRK HEAD PTRS	*/

	TRACKS_HELD=NUM.OF.HELD.TRACK.BUTTONS;		/*	INIT CTR TO # OF TRKS TO LOAD	*/

	DO I=0 TO (NUM.TRACK.BUTTONS-1);		/*	LOOP OVER TRACK BUTTONS	*/

		WRITE(MAM)=TBUT.PTR;					/*	SEE IF TRK BUTTON HELD	*/
		WRITE(MAL)=I;

		IF (READ(MD)&B.HELD.TRK)<>0 THEN DO;	/*	BUTTON HELD - RECALL CORRESPONDING TRK	*/

			CHECK.ILS.SEC = 0;
			CHECK.ILE.SEC = 0;

			#TRK=READ(MD)&255;				/*	SAVE CORRESPONDING TRK #	*/

			TRACKS_HELD=TRACKS_HELD-1;		/*	ONE LESS TRK TO LOAD		*/

			IF  (#TRK >= FIRST.LOD.TRACK)	/*	IF TRK IS A LOD TRACK	*/
			AND (#TRK <  LAST.LOD.TRACK)
			THEN DO;								/*	SELECTIVE TRK RECALL NOT AVAILABLE		*/
				CALL DISPLAY.ERR(49);		/*	DISPLAY 'NOT AVAILABLE FOR LIVE TRACK'	*/
				CALL DEALLOCATE.NAH.BLOCK(NAHSEC);	/*	GET RID OF TEMP SEC		*/
				CALL SEQUENCE.TRACKS.CLEANUP;
				RETURN FALSE;					/*	BOMB OUT						*/
			END;

			WRITE(MAM)=NAH.PTR+NAHSEC;
			WRITE(MAL)=#TRK;
			J=READ(MD);

			IF J=0 THEN DO;					/*	TRACK IS EMPTY	*/
				CALL ERASE.TRACK(#TRK);		/*	JUST ERASE EXISTING TRK	*/
			END;

			ELSE DO;

				/*	WE HAVE A TRACK TO RECALL.  COMPUTE THE NUMBER	*/
				/*	OF SECTORS OF NAH MEMORY REQUIRED FOR THE TRK	*/
				/*	AND COMPUTE HOW MUCH STORAGE IN THE PAR AREA		*/
				/*	WILL BE NEEDED AND HOW MANY NEW TIMBRES WE WILL	*/
				/*	NEED TO READ FROM THE DISK FOR THE NEW TRACK.	*/

				THDSEC=ALLOCATE.NAH.BLOCK;		/*	TEMP BUF WHICH HOLDS FINAL TRK HEAD IF WE SUCCEED	*/

				IF THDSEC=0 THEN DO;				/*	RAN OUT OF MEMORY			*/
					CALL DISPLAY.ERR(14);		/*	'NOT ENOUGH ROOM IN MEMORY'	*/
					CALL DEALLOCATE.NAH.BLOCK(NAHSEC);	/*	GET RID OF TEMP SEC		*/
					CALL SEQUENCE.TRACKS.CLEANUP;
					RETURN FALSE;					/*	BOMB OUT						*/
				END;

				J=MISC.BUF(SEQ.NAH)+J;			/*	RELATIVE PTR TO OUR NEW TRK HEAD	*/
				MSB=DEV; LSB=SEC;
				CALL ADD.TO(J);
				CALL EXT.READDATA(MSB,LSB,NAH.PTR+THDSEC,0,1,0);	/*	READ IN TRK HEAD FOR NEW TRK	*/

				/*	$PAGE	*/


				/*	1. NUMBER OF SECTORS IN NAH AREA NEEDED	*/

				WRITE(MAM)=NAH.PTR+THDSEC;		/*	LOOK UP HOW MANY NOTE SEGMENTS	*/
				WRITE(MAL)=THD.NUM.NLS;			/*	USED BY THE TRACK						*/
				NEW.LEN=READ(MD);					/*	DON'T INCLUDE TRK HEAD				*/

				WRITE(MAL)=THD.GROUPLIST;		/*	PLUS 1  MORE IF GROUP TRACK		*/
				DISK.GRPLIST = READ(MD);		/*	GET NAH RELATIVE GRP LIST			*/
				WRITE(MD)	 = 0;					/*	IN CASE READ IN FAILS BELOW		*/

				IF (DISK.GRPLIST != 0)
					NEW.LEN = NEW.LEN + 1;

				/*	2. NUMBER OF WORDS IN PAR AREA NEEDED	*/
				/*		NOTE: CURRENT VERSION OF CODE DOES	*/
				/*		NOT TRY TO DEAL WITH MORE THAN ONE	*/
				/*		TIMBRE ON A SINGLE TRACK.  TO BE		*/
				/*		DONE AT A LATER DATE.					*/

				WRITE(MAL)=THD.USAGE;
				J=READ(MD);						/*	SAVE TIMBRE # FOR TRK IN TEMP	*/

				IF J<>0 THEN DO;				/*	TRK HAS A REAL TIMBRE ON IT	*/

					J=J-NUM.KBD.TRACKS;		/*	CORRECT FOR KBD TIMBRE OFFSET	*/

					MSB = DEV;
					LSB = SEC;
					CALL ADD.TO(MISC.BUF(SEQ.PAR));	/*	PTR TO PAR AREA	*/

					CALL PRIME.IO.BUFFER(MSB,LSB,0,
												0,MISC.BUF(SEQ.PAR+1),
												EXTBUF.PTR,EXTBUF.LEN,0);

					CALL FIND.DISK.TIM(J);
					S.BF.DEV=DISK.DEV; S.BF.SEC=DISK.SEC; S.BF.PTR=BUF.R.PTR;	/*	SAVE POINTERS	*/
					CALL FIND.DISK.TIM(1);	/*	STEP OVER DISK TIMBRE	*/

					NEW.PAR.LEN=SHL(DISK.SEC-S.BF.SEC,8)+BUF.R.PTR-S.BF.PTR;	/*	GET LENGTH OF NEW TIMBRE IN WORDS - NO OVERFLOW PROBLEM HERE	*/

				END;
				ELSE NEW.PAR.LEN=0;

				/*	3. NUMBER OF NEW TIMBRES									*/
				/*		NOTE: ASSUME THERE IS ONLY 1 NEW TIMBRE FOR NOW	*/


				/*	TOTAL NUMBER OF SECTORS NEEDED FOR NEW TRK	*/
				/*	IS NUMBER OF SECTORS NEEDED FOR NOTES AND		*/
				/*	TRK HEAD PLUS NUMBER OF SECTORS NEEDED FOR	*/
				/*	TIMBRE PLUS 1 SECTOR FOR THE TIMBRE HEAD		*/
				/*	AREA.														*/

				NEW.LEN=NEW.LEN+SHR(NEW.PAR.LEN+255,8)+1;	/*	TOTAL SECTORS NEEDED FOR NEW TRK	*/

				/*	NOW COMPUTE AMOUNT OF MEMORY USED	*/
				/*	BY THE CURRENT IN-MEMORY TRACK	*/

				WRITE(MAM)=TRK.HEAD;
				WRITE(MAL)=#TRK;

				IF READ(MD)<>0 THEN DO;		/*	CURRENT IN-MEMORY TRK HAS A HEADER	*/

					WRITE(MAM)=READ(MD);									/*	POINT TO THE TRK HEAD	*/
					WRITE(MAL)=THD.LIVE.RTES;							/*	GET THESE VALUES AND PUT THEM ON NEW TRK HEAD BELOW	*/
					DO M=0 TO 7;TEMP.BUF(M)=READ(MDI);END;			/*	IN CASE MIDI IS MAPPED TO RECORDER	*/

					WRITE(MAL)=THD.ACTIVE;								/*	SAVE SOLOED STATE FOR THIS TRACK (STORED BY STORE.SEQUENCE.INFO)	*/
					TEMP.ACTIVE = READ(MD);

					OLD.LEN=TRK.HEAD.LOOKUP(#TRK,THD.NUM.NLS)+1;	/*	LENGTH OF CURRENT IN-MEMORY TRK (INCLUDING TRK HEAD)	*/

					IF (TRK.HEAD.LOOKUP(#TRK, THD.GROUPLIST) != 0)
						OLD.LEN = OLD.LEN + 1;

					J=TRK.HEAD.LOOKUP(#TRK,THD.USAGE);				/*	GET TIMBRE # FOR THIS TRK	*/

					IF J<>0 THEN DO;										/*	TRACK USES A TIMBRE	*/

						WRITE(MAM)=USE.PTR;
						WRITE(MAL)=J;

						IF READ(MD)=1 THEN DO;							/*	THIS IS ONLY TRK USING THE TIMBRE	*/
							OLD.PAR.LEN=FIND.TIMBRE(PAR.PTR,J  );	/*	GET LENGTH OF TIMBRE	*/
							OLD.PAR.LEN=FIND.TIMBRE(PAR.PTR,J+1)-OLD.PAR.LEN;	/*	ON ORIGINAL TRACK		*/
						END;
						ELSE OLD.PAR.LEN=0;								/*	OTHERWISE, ERASING TRK WILL NOT FREE UP ANY MEMORY IN PAR AREA	*/

					END;
					ELSE OLD.PAR.LEN=0;

					OLD.LEN=OLD.LEN+SHR(OLD.PAR.LEN+255,8)+1;	/*	TOTAL MEMORY USED FOR THIS TRK	*/

				END;
				ELSE DO;									/*	NO TRACK				*/
					OLD.LEN=0;							/*	NO NOTE SEGMENTS	*/
					OLD.PAR.LEN=0;						/*	AND NO TIMBRE		*/

					/*	INIT THD.LIVE.RTES VALUES - TO BE COPIED IN TO NEW TRK HEAD BELOW	*/
					TEMP.BUF(0)=RTE.MAX;				/*	PEDAL 1				*/
					TEMP.BUF(1)=SHL(RTE.MAX,8);	/*	PEDAL 2				*/
					TEMP.BUF(2)=SHL(RTE.MAX,8);	/*	MOD WHEEL			*/
					TEMP.BUF(3)=SHL(RTE.MAX,8);	/*	BREATH CONTROLLER	*/
					TEMP.BUF(4)=0;						/*	PITCH WHEEL			*/
					TEMP.BUF(5)=0;						/*	RAW RIBBON			*/
					TEMP.BUF(6)=0;						/*	+FRIBBON				*/
					TEMP.BUF(7)=0;						/*	-FRIBBON				*/

					IF (NUM.OF.SOLOED.TRACKS != 0)		/*	IF SOME TRACKS ARE SOLOED, THEN SOLO THIS TRACK BEING RECALLED	*/
						TEMP.ACTIVE = B.SOLOED.TRK;		/*	AFTER WE BRING IT INTO MEMORY...											*/
					ELSE
						TEMP.ACTIVE = 0;
				END;


				/*	$PAGE	*/


				/*	NOW GIVEN MEMORY REQUIRED FOR NEW TRACK AND	*/
				/*	MEMORY USED BY OLD TRACK AND OTHER AVAILABLE	*/
				/*	MEMORY, WE CAN MAKE A REASONABLE GUESS AS TO	*/
				/*	WHETHER OR NOT WE WILL BE ABLE TO RECALL THE	*/
				/*	NEW TRACK												*/

				J=NAH.#FREE+((BNK.PTR+BNK.LEN)-(NAH.PTR+NAH.LEN))+OLD.LEN;	/*	NUMBER OF EASILY OBTAINED SECTORS LEFT	*/

				IF NEW.LEN IGT J						/*	NOT ENOUGH MEMORY RIGHT NOW	*/
				THEN DO;									/*	DO SHUFFLE TO COLLECT MEMORY	*/

					CALL MAXIMIZE.MEMORY.FOR.RECORD;	/*	HEAVY DUTY GARBAGE COLLECT	*/

					J=NAH.#FREE+((BNK.PTR+BNK.LEN)-(NAH.PTR+NAH.LEN))+OLD.LEN;	/*	TOTAL SECTORS AVAILABLE	*/

					IF NEW.LEN IGT J THEN DO;		/*	STILL WON'T FIT AFTER SHUFFLE	*/
						CALL DISPLAY.ERR(14);		/*	'NOT ENOUGH ROOM IN MEMORY'	*/
						CALL DEALLOCATE.NAH.BLOCK(NAHSEC);		/*	GET RID OF TEMP SEC	*/
						CALL SEQUENCE.TRACKS.CLEANUP;
						RETURN FALSE;					/*	BOMB OUT						*/
					END;
				END;


				/*	DO AN OVERFLOW CHECK HERE TO MAKE SURE	*/
				/*	THAT WE CAN FIT THE NEW TIMBRE INTO		*/
				/*	OUR PARAMETER AREA (NOT > 64K WORDS)	*/
				/*	EVENTUALLY, MAKE A CHECK TO BE SURE WE	*/
				/*	WILL NOT END UP WITH MORE THAN 256		*/
				/*	TIMBRES IN THE PARAMETER AREA.			*/

				K=NEW.PAR.LEN-OLD.PAR.LEN;			/*	DIFFERENCE IN LENGTHS OF PARMS ON TRK	*/
				J=PAR.TOP+K;							/*	NEW TIMBRE AREA LENGTH	*/

				IF NEW.PAR.LEN IGT OLD.PAR.LEN THEN DO;		/*	NEW TIMBRE IS LONGER - MUST DO OVERFLOW CHECK	*/
					IF J ILT K THEN  J=(-1);		/*	OVERFLOW OCCURRED	*/
					ELSE DO;
						J=J+255;							/*	ROUND	*/
						IF J ILT 255 THEN J=(-1);	/*	OVERFLOW DURING ROUNDING	*/
						ELSE J=SHR(J,8);				/*	WILL BE NEW LENGTH OF TIMBRES	*/
					END;
				END;
				ELSE J=SHR(J+255,8);					/*	NO WORRY ABOUT OVERFLOW	*/

				IF (J IGE 255)							/*	255 OR MORE PARAMETER SECTORS	*/
				THEN DO;									/*	CAN NOT DO IT	*/
					CALL DISPLAY.ERR(14);			/*	'NOT ENOUGH ROOM IN MEMORY'	*/
					CALL DEALLOCATE.NAH.BLOCK(NAHSEC);			/*	GET RID OF TEMP SEC	*/
					CALL SEQUENCE.TRACKS.CLEANUP;
					RETURN FALSE;
				END;


				/*	$PAGE	*/


				/*	FROM HERE ON, WE ASSUME THAT EVERYTHING	*/
				/*	IS GOING TO FIT INTO MEMORY.					*/

				CALL ERASE.TRACK(#TRK);				/*	ZAP ORIGINAL TRACK (NOTES AND TIMBRE)	*/
				CALL SETUP.FLOPPY.CACHE;			/*	SET UP CACHE IF NEEDED (FOR FOLLOWING CALL TO MOVE.TIMBRE.TO)	*/
				CALL MOUNT.OPTICAL.VOLUME;			/*	ALSO CACHE OPT DISK IF NEEDED	*/


				/*	NOW READ IN THE NOTELIST ONE SECTOR AT A TIME	*/

				CALL READDATA(DEV,SEC,MISC.BUF,256);	/*	RE-READ MISC INFO FOR FURTHER PROCESSING (PRIME DESTROYS MISC.BUF, AS DOES ERASE.TRACK)	*/

				WRITE(MAM)=NAH.PTR;					/*	SET UP PTR IN NAH AREA TO	*/
				WRITE(MAL)=#TRK;						/*	TRK HEAD FOR NEW TRK			*/
				WRITE(MD )=THDSEC;

				WRITE(MAM)=TRK.HEAD;					/*	SET UP ABS TRK PTR INFO	*/
				WRITE(MAL)=#TRK;
				WRITE(MD )=NAH.PTR+THDSEC;

				WRITE(MAM)=NAH.PTR+THDSEC;
				NEXT.DISK.NLS=READ(MDI);			/*	SAVE PTR TO NEXT NLS ON DISK	*/
				WRITE(MD)=0;							/*	RESET THD.REV POINTER TO ZERO	*/
				NEXT.NLS=THDSEC;						/*	INIT CUR PTR TO TRK HEAD		*/

				WRITE(MAL)=THD.ILP;
				IF READ(MD)<>0 THEN DO;
					CHECK.ILS.SEC = 1;
					CHECK.ILE.SEC = 1;
				END;

				DO WHILE NEXT.DISK.NLS<>0;			/*	LOOP WHILE MORE NLS TO READ IN	*/

					PRIOR.NLS=NEXT.NLS;				/*	SAVE CURRENT PTR	*/
					NEXT.NLS=ALLOCATE.NAH.BLOCK;	/*	GET ANOTHER SECTOR	*/

					IF NEXT.NLS=0 THEN DO;			/*	SYSTEM ERROR!!!!	*/
						IF DEBUG THEN DO; END;
					END;

					WRITE(MAM)=NAH.PTR+PRIOR.NLS;	/*	FIX FORWARD PTR	*/
					WRITE(MD )=NEXT.NLS;				/*	IN OUR PRIOR NLS	*/

					J=MISC.BUF(SEQ.NAH)+NEXT.DISK.NLS;	/*	REL DISK PTR TO NEXT NLS	*/
					MSB=DEV; LSB=SEC;
					CALL ADD.TO(J);
					CALL EXT.READDATA(MSB,LSB,NAH.PTR+NEXT.NLS,0,1,0);	/*	READ NLS DATA	*/

					IF CHECK.ILS.SEC <>0 THEN DO;
						WRITE(MAM)=NAH.PTR+THDSEC;
						WRITE(MAL)=THD.ILS.SEC;
						IF READ(MD)=NEXT.DISK.NLS THEN DO;
							WRITE(MD)=NEXT.NLS;
							CHECK.ILS.SEC=0;
						END;
					END;

					IF CHECK.ILE.SEC <>0 THEN DO;
						WRITE(MAM)=NAH.PTR+THDSEC;
						WRITE(MAL)=THD.ILE.SEC;
						IF READ(MD)=NEXT.DISK.NLS THEN DO;
							WRITE(MD)=NEXT.NLS;
							CHECK.ILE.SEC=0;
						END;
					END;

					WRITE(MAM)=NAH.PTR+NEXT.NLS;	/*	POINT TO NEWLY READ NLS			*/
					NEXT.DISK.NLS=READ(MD);			/*	SAVE ITS ORIGINAL FOR PTR		*/
					WRITE(MDI)=0;						/*	SET FOR PTR TO NULL FOR NOW	*/
					WRITE(MD )=PRIOR.NLS;			/*	FIX BACK PTR TO PRIOR NLS		*/

				END;


				/*	READ IN GROUP LIST AS WELL	*/

				IF (DISK.GRPLIST != 0)
				{
					NEXT.NLS = ALLOCATE.NAH.BLOCK;			/*	GET ANOTHER SECTOR	*/

					IF (NEXT.NLS != 0)
					{
						J=MISC.BUF(SEQ.NAH)+DISK.GRPLIST;	/*	REL DISK PTR TO NEXT NLS	*/
						MSB=DEV; LSB=SEC;
						CALL ADD.TO(J);
						CALL EXT.READDATA(MSB,LSB,NAH.PTR+NEXT.NLS,0,1,0);	/*	READ GROUP LIST DATA	*/

						WRITE(MAM) = NAH.PTR+THDSEC;
						WRITE(MAL) = THD.GROUPLIST;
						WRITE(MD ) = NEXT.NLS;
					}
				}

				/*	$PAGE	*/


				/*	BEFORE WE READ THE TIMBRE INTO MEMORY FROM	*/
				/*	THE DISK, IT IS NECESSARY TO SAVE SOME OF		*/
				/*	THE TRK INFO AND CLEAR OUT SOME OF IT.			*/

				WRITE(MAM)=NAH.PTR+THDSEC;					/*	POINT AT TRK HEAD	*/
				WRITE(MAL)=THD.STIMB;	  WRITE(MD)=0;	/*	CLEAR OUT EXISTING TRK INFO	*/
				WRITE(MAL)=THD.CTIMB;	  WRITE(MD)=0;
				WRITE(MAL)=THD.LP.CTIMB;  WRITE(MD)=0;
				WRITE(MAL)=THD.ILS.CTIMB; WRITE(MD)=0;
				WRITE(MAL)=THD.ILE.CTIMB; WRITE(MD)=0;

				WRITE(MAL)=THD.USAGE;
				DO J=0 TO THD.USAGE.LEN-1; WRITE(MDI)=0; END;	/*	CLEAR OUT USAGE TABLE TOO	*/

				WRITE(MAL)=THD.TVOL; J=READ(MD);			/*	SAVE THESE 4 VALUES SINCE	*/
				WRITE(MAL)=THD.MIDI; K=READ(MD);			/*	COPY.TIMBRE WILL TRASH THEM	*/
				WRITE(MAL)=THD.ACTIVE.MIDI.RTES; L=READ(MD);
				WRITE(MAL)=THD.MIDI.PATH; M=READ(MD);
				WRITE(MAL)=THD.MIDX; N=READ(MD);

				/*	READ IN TIMBRE FROM DISK	*/

				S.BF.SEC=S.BF.SEC+SHR(S.BF.PTR,8);		/*	NORMALIZE DISK ADDR OF	*/
				IF S.BF.SEC ILT SHR(S.BF.PTR,8) THEN S.BF.DEV = S.BF.DEV + 1;
				S.BF.PTR=S.BF.PTR&255;						/*	START OF NEW TIMBRE FOR TRK	*/

				CALL PRIME.IO.BUFFER(S.BF.DEV,S.BF.SEC,S.BF.PTR,
											0,SHR(S.BF.PTR+NEW.PAR.LEN+255,8),
											EXTBUF.PTR,EXTBUF.LEN,0);	/*	RESET DISK TO START OF TIMBRE	*/

				DISPLAY.EBL=0;									/*	SUPPRESS DISPLAYS DURING THIS COPY	*/
				CALL COPY.TIMBRE(-2,#TRK);					/*	READ TIMBRE FROM DISK AND SET UP TRK INFO	*/
				DISPLAY.EBL=1;									/*	ALLOW DISPLAYS NOW	*/

				CALL TRK.HEAD.STORE(#TRK,THD.TVOL,J);	/*	RESTORE TO THEIR	*/
				CALL TRK.HEAD.STORE(#TRK,THD.MIDI,K);	/*	ORIGINAL VALUES	*/
				CALL TRK.HEAD.STORE(#TRK,THD.ACTIVE.MIDI.RTES,L);
				CALL TRK.HEAD.STORE(#TRK,THD.MIDI.PATH,M);
				CALL TRK.HEAD.STORE(#TRK,THD.MIDX,N);
				DO M=0 TO 7;
					CALL TRK.HEAD.STORE(#TRK,THD.LIVE.RTES+M,TEMP.BUF(M));
				END;
				CALL TRK.HEAD.STORE(#TRK,THD.ACTIVE,TEMP.ACTIVE);

				CALL COMPUTE.NUMB.LEFT;						/*	INDICATE ANOTHER TRK	*/
				CALL DISPLAY.NUMB.LEFT;						/*	HAS BEEN RECALLED		*/

				IF TRACKS_HELD<>0 THEN CALL READDATA(DEV,SEC,MISC.BUF,256);	/*	RE-READ MISC INFO FOR NEXT TRACK	*/

				FLOPPY.CACHE.VALID=0;						/*	DONE WITH FLOPPY CACHE	*/
				CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
				OPTICAL.DISK.READY=0;
			END;	/*	OF TRK TO RECALL HAS A TRK HEAD	*/

		END;		/*	OF RECALL THIS TRACK FROM DISK	*/

	END;			/*	OF LOOP OVER TRACKS	*/


	/*	NOW WE ARE FINISHED WITH THE NAHSEC	*/
	/*	TEMP BUFFER. SO FREE IT UP				*/

	CALL DEALLOCATE.NAH.BLOCK(NAHSEC);
	CALL SEQUENCE.TRACKS.CLEANUP;

	RETURN TRUE;
END READ.SEQUENCE.TRACKS;

/*	$SUBTITLE  ROUTINE TO TRY TO READ IN A SEQUENCE FROM THE DISK	*/

TRY.TO.READ.SEQ: PROC (OUR.DEV,OUR.SEC) PUBLIC SWAPABLE;	/*	READ SEQUENCE, GIVEN DEVICE AND SECTOR	*/
	DCL (OUR.DEV,OUR.SEC)	FIXED;	/*	DEV & SEC ADDR OF SEQUENCE	*/

	DEV=OUR.DEV;							/*	MOVE TO LOCAL GLOBALS		*/
	SEC=OUR.SEC;

	IF INC.MONO<>0 THEN CALL STOP.DISK;		/*	STOP OUTPUT SO WE CAN READ DISK	*/

   interp_seq_dirtyness(2);               /* Remove current sequence path; new one will be assigned if this is a read is from a Mac file */

	CALL READDATA(DEV,SEC,MISC.BUF,256);	/*	READ IN HEADER SECTOR	*/

	IF ((MISC.BUF(MAGIC.NUMBER)<>MAGIC#1)	/*	CHECK MAGIC NUMBER	*/
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#2)
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#3)
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#4)
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#5)
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#6)
	AND (MISC.BUF(MAGIC.NUMBER)<>MAGIC#7))
	THEN DO;				/*	ERROR - NOT A SEQUENCE, OR TOO BIG	*/
		IF NEW.PAN THEN CALL DISPLAY.ERR(18);	/*	NO SEQUENCE STORED HERE	*/
		ELSE				 CALL DISPLAY.ERR( 5);	/*	FOR OLD PANEL - USE DOCUMENTED ERROR MESSAGE	*/
		CALL DISPLAY.SEQUENCER.STATUS;			/*	UPDATE LIGHT DISPLAY		*/
		RETURN FALSE;
	END;

	CALL CLEAR.DISPLAY;
	CALL CLEAR.PARAMETERS;

	IF NUM.OF.HELD.TRACK.BUTTONS=0
	THEN RETURN READ.ENTIRE.SEQUENCE;			/*	READ IN ENTIRE SEQUENCE	*/
   ELSE {
      RETURN READ.SEQUENCE.TRACKS;
      interp_seq_dirtyness(2);               /* Disable Save after merging tracks since sequence is now a hybrid */
   }

END TRY.TO.READ.SEQ;

/*	$page - routines for sequence "undo" feature	*/

dcl undotree		data public ('W0:USER:.UNDOSEQ');
dcl undofile		data public ('.UNDOSEQ');
dcl tmp.undofile	data public ('W0:USER:.TMPUNDO');

SAVE.UNDOSEQ: proc public swapable;
	dcl tmp fixed;

	write(mam) = bas.ptr;
	write(mal) = seq.prot;
	tmp = read(md);							/*	save the protection state	*/
	write(md ) = (read(md)&"177776");	/*	make sure there's no protection	*/

	call Save.Sequence(UndoTree, 1, 1);	/*	save sequence for undo	*/

	write(mam) = bas.ptr;
	write(mal) = seq.prot;
	write(md ) = (read(md)&"177776") \ tmp;	/*	restore the protection state	*/

end SAVE.UNDOSEQ;

UNDO.SEQUENCE.CHANGES: proc public swapable;
	dcl protection fixed;

	/*	save current version into a temp file	*/
	write(mam) = bas.ptr;
	write(mal) = seq.prot;
	protection = read(md);					/*	save the protection state	*/
	write(md ) = (read(md)&"177776");	/*	make sure there's no protection	*/

	call Save.Sequence(tmp.undofile, 1, 1);

	/*	look for previous undo file	*/
	if (locate(undotree, 1))
	then do;
		/*	read it in	*/
		call try.to.read.seq(F#MS_SECTOR,F#LS_SECTOR);

		/*	delete previous undo file	*/
		call Delete(undotree, 1);

		/*	rename current file to be undo file	*/
		if  (locate(tmp.undofile, 1))
		then call rename(tmp.undofile, undofile, 1);
	end;
	else call display.err(4);

	write(mam) = bas.ptr;
	write(mal) = seq.prot;
	write(md ) = (read(md)&"177776") \ protection;	/*	restore the protection state	*/

end UNDO.SEQUENCE.CHANGES;

END;
