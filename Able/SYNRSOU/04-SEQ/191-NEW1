/* 191-NEW1  $TITLE  MISC ROUTINES TO HANDLE SMPTE, PLAY NOTES   Modified:   08/24/91 - PF  - Added TIMED.INFO.NOTES   01/30/91 - MWH - Report which tracks have had new notes   04/26/89 - cj - perform info note trigger of events   09/18/88 - cj - set bit in store.e.time to cause seq panel scroll   08/16/88 - Modify Store.E.Time to handle still-frame recording   07/08/88 - TS,PF - FIXED BUG IN SUPER-SHORT NOTE DURATION COMPUTATIONS   03/14/88 - cj - sent syncl track # over during cue trigger   10/06/87 - cj - change stop info trigger to stop cue trig notes    10/22/86 - CJ,TS - IMPROVED INFO NOTE TRIGGER FOR RELEASE TIMES   08/13/86 - TS,EG - FIXED INFO.NOTE.TRIGGER BUG   07/13/86 - CJ,TS - MOVED TRACK.CLICK.CHECK.  ADDED NORIG   06/23/86 - TSS - FIXED BUG IN STORE.E.TIME & PLAY.SEQ.NOTE   06/20/86 - CJ - MOVED SMPTE.SUB OUT OF HERE INTO ORBIT   06/12/86 - TSS - Put in code for STORE.E.TIME   05/15/86 - "official" creation of release-M modules*//* $SUBTITLE  PLAY A SEQUENCER NOTE UNDER MANUAL CONTROL *//* THIS ROUTINE IS INTENDED TO BE USED DURING FAST FORWARD *//* AND REWIND TO MAKE SOUND.  PASS IT A PTR TO THE TRACK   *//* HEADER FROM WHICH THE NOTE INFO CAME AND FOUR WORDS OF  *//* NOTE INFO.  IF ORIGINAL NOTE WAS A 2-WORD RECORD, THEN  *//* PASS W3=0 AND W4=VEL.NOTE.  NOTE:  DON'T TRY TO PASS    *//* REST RECORDS, UPDATE RECORDS, OR ALTERNATE FORMAT NOTES *//* TO THIS ROUTINE.  IT WILL CHOKE ON THEM AND GIVE YOU    *//* HEARTBURN.....                                          */PLAY.SEQ.NOTE:  PROC (PTR,W1,W2,W3,W4) PUBLIC SWAPABLE; /* QUEUES UP A NOTE ONTO SEQLIST */   DCL PTR           FIXED; /* ABS PTR TO TRK HEAD */   DCL (W1,W2,W3,W4) FIXED; /* THE FOUR WORDS OF NOTE RECORD */   DCL (MSB,LSB)     FIXED;   DCL (I,J)         FIXED;   DCL (TRACK#)      FIXED;   DCL KEY#          FIXED;   DCL CUEID         FIXED;   DCL CUETIME(1)    FIXED;   DCL PTLPTR        FIXED;   DCL EVPTR         FIXED;   WRITE(MAM) = PTR;            /* POINT TO TRACK HEAD        */   WRITE(MAL) = THD.TRK;        /* GET TRACK # FOR THIS TRACK */   TRACK#     = READ(MD);       /* SAVE FOR CUE TRIGGER       */   KEY# = (W2&"77") \ SHR(W1&"074000",6); /* GET "KEY" NO.    */   WRITE(MAL) = THD.CUE.TRACK;   /* SEE IF THIS IS A CUE TRACK    */   IF READ(MD)<>0 THEN DO;       /* CUE TRACK - SEND IT           */      WRITE(MAL)  = THD.CTIMB;   /* LOOK UP CURRENT TIMBRE NUMBER */      WRITE("313")= READ(MD);    /* GET CUR TIMBRE                */      WRITE(MAM)  = TIM.HEAD;      WRITE(MAL)  = READ("313");      WRITE(MAM)  = READ(MD);    /* PT TO TIMBRE HEAD   */      WRITE(MAL)  = TIM.PARTIAL.POINTERS + SHR(KEY#, 8);      PTLPTR      = READ(MD);      WRITE(MAL)  = TIM.KBDTAB.PTR       + SHR(KEY#, 8);      IF READ(MD)<>0 THEN DO;   /* MAKE SURE 1 IS THERE */         WRITE(MAM) = TIM.PTR + READ(MD) - 1;         WRITE(MAL) = KEY#;         CUEID      = READ(MD); /* GET CUE ID # FOR KEY */         /* look up event info if this is event:        */         if Cueid < 0 then do;  /* means this is event       */            call p.lookup(ptlptr-Cueid+ev.in.msb);            write("300") = addr(copy.buf(0));            rpc (ev.name - ev.in.msb);            write("360") = read(mdi);            call p.lookup(ptlptr-Cueid+ev.cue.id);            Cueid = read(md);            Evptr = addr(copy.buf(0));         end;         else Evptr = 0;    /* no event info for cue trigs */         /* compute time to trigger event at:              */         call COPY32(loc(addr(SAMPLED.ACTUAL.PLAY.TIME.MSB)),                     cuetime);         /* ie: add 250 milliseconds to current play time! */         call ADD16 (shr(samp.speed,2), cuetime);         if Cueid <> 0         /* if id exists, then send it  */         then do;            call Store.Real.Time.Event.Info             (Cueid, cuetime,              /* cue id,  time    */             4096 \ 1, loc(addr(W1)),     /* bits, w1-w4      */             32768 \ track#, loc(Evptr)); /* trk, event info  */            lod.update.time = lod.update.time - lod.update.rate; /* send info over right now */         end;      END;      RETURN 0;      /* NO BLOCK ON QUE, THOUGH     */   END;         IF (NFREEP=0)     /* NO NOTE BLOCKS AVAILABLE    */   THEN RETURN 0;    /* CAN'T PLAY NOTE -- BOMB OUT */   NPTR=NFREEP;    NFREEP=CORE(NFREEP);   WRITE("313")=NPTR;              /* USE R13 FOR SPEED */   WRITE("373")=0;                 /* NFPTR - ALWAYS 0  */      IF SEQLIST=0 THEN SEQLIST=NPTR;       /* IF QUE IS EMPTY, STORE ON FRONT */   ELSE              CORE(SEQLAST)=NPTR; /* ELSE STORE ON END OF QUE        */   SEQLAST=NPTR;                         /* NOW WE ARE ON END OF QUE        */   WRITE(MAM)=PTR;              /* POINT TO TRK HEAD    */   WRITE(MAL)=THD.CTIMB;        /* GET CURRENT TIMBRE # */   WRITE("373")=READ(MD);       /* TIMBRE =             */   WRITE(MAL)=THD.TRK;   WRITE("373")=READ(MD);       /* TRACK  =             */   WRITE("373")=1;              /* NORIG  =             */   WRITE("373")=(W2&"77")+12;   /* KEYN   =             */   WRITE("373")=SHR(W3,8);      /* SBITS  =             */   WRITE("373")=W3&255;         /* VELD   =             */   /* COMPUTE DURATION */   MSB=0;   LSB=SHR(W2,6);               /* GET BASIC DURATION   */   IF (W1&"074000")<>0 THEN DO; /* INFO IN UPPER BITS   */      LSB=LSB\SHR(W1&"014000",1);      IF (W1&"060000")<>0 THEN DO;    /* LONG SHIFT     */         LOAD LSB;         MUL DUR.MUL.DATA(ROT(W1,3)&3);         MSB=URES; LSB=RES;      END;   END;   /* $PAGE */   disable;   OTIMM=PLAY.TIME.MSB;       /* START NOTE ASAP, ASSUME           */   OTIML=PLAY.TIME.LSB;       /* PLAY.TIME IS MORE OR LESS CORRECT */   enable;   /* compute duration of note as if it was played now using the   */   /* musical length of the note - may or may not be what you      */   /* want to do.                                                  */   call Map.Real.Time.To.Sequence.Time(loc(addr(OTIMM)),                                        loc(addr(FENDM)));   /* if playing or forwarding, compute positive end time:         */   IF (MOVE=0) OR (MOVE.SPEED>0)   THEN CALL ADD32(LOC(ADDR(FENDM)), LOC(ADDR(MSB)), LOC(ADDR(FENDM)));   /* else if rewinding and we hwave a long way to go, use         */   /* correct duration:                                            */   ELSE IF COM32(LOC(ADDR(FENDM)), LOC(ADDR(MSB))) >= LW#IEQ   THEN CALL SUB32(LOC(ADDR(FENDM)), LOC(ADDR(MSB)), LOC(ADDR(FENDM)));   /* else limit end time to 0,0 to avoid overflow:                */   ELSE CALL STR32(0, 0, LOC(ADDR(FENDM)));   call Map.Sequence.Time.To.Real.Time(loc(addr(FENDM)),                                        loc(addr(FENDM)));   IF INC.AXE<>0 THEN GDATA=0;     /* NOT A GUITAR NOTE */   IF W4<>VEL.NOTE THEN DO;        /* PROCESS INFO      */      SBITS=SBITS\(W4&"177400");      IF (W4&(LOWER.KEY\RAISE.KEY))<>0      THEN DO;         IF (W4&LOWER.KEY)<>0 THEN KEYN=KEYN-12;         IF (W4&RAISE.KEY)<>0 THEN KEYN=KEYN+12;      END;   END;   IF INC.MONO<>0 THEN DO;      WRITE(MAL)=THD.WRD;          /* SAVE POINTER TO */      TFLAG     =READ(MDI);        /* NOTE RECORD IN  */      REMAIN    =READ(MD );        /* CASE OVERLAY    */   END;                            /* MODE            */   QME=0;                          /* NON-MIDI        */   RETURN 1;                       /* MEANS WE WERE SUCCESSFUL */END PLAY.SEQ.NOTE;/* $SUBTITLE  ROUTINE TO STORE ENDING TIME OF NOTE WHILE RECORDING */DCL NEW.SEQ.MATCH.W1 FIXED PUBLIC;DCL NEW.SEQ.MATCH.W2 FIXED PUBLIC;DCL NEW.SEQ.MATCH.W3 FIXED PUBLIC;DCL NEW.SEQ.MATCH.W4 FIXED PUBLIC;STORE.E.TIME: PROC PUBLIC; /* STORE ENDING TIME FOR RECORDED NOTE */	DCL (M,L)  FIXED;	DCL (VITC) FIXED;	DCL (TRK)  FIXED EXTERNAL;	dcl stamp  fixed;	// Grab possible time stamp	if ((recw & 0xFF00) != 0)	{		stamp = shr(recw, 8);		recw  = recw & 0xFF;				stamp = interp_compute_time_stamp(stamp);		// Compute # of milliseconds we are late at this point	}		/* ROUTINE ASSUMES THAT NPTR IS POINTING AT */	/* THE NOTEBLOCK FOR THE NOTE WE ARE TRYING */	/* TO SAVE A DURATION IN                    */	WRITE(MAM)=NAH.PTR+RECS;              /* POINT AT THE NOTE */	WRITE(MAL)=RECW;	IF  ((READ(MDI)&"074000")=0)          /* BOTH PARTS OF DURATION FIELD */	AND ((READ(MD )&"177700")=0)          /* ARE SET AT ZERO SO SAFE TO STORE DURATION */	THEN DO;                              /* CHECK HERE IN CASE OF SEQ RECALL WHILE RECORDING */		IF ABRT.RECORDING<>0 THEN DO;      /* USE PREVIOUS TIME AFTER LOOP OR ABORT */			/* use prior.actua.play.time.msb if abrt.recording to get */			/* actual precise durations:                              */			if (tempo.map.ptr == 0)			{				sub32(loc(addr(prior.actual.play.time.msb)), loc(addr(fendm)), loc(addr(m)));			}			else			{				//	if using tempo map, get corresponding sequence time				Map.Real.Time.To.Sequence.Time(loc(addr(prior.actual.play.time.msb)), loc(addr(m)));				sub32(loc(addr(m)), loc(addr(fendm)), loc(addr(m)));			}		END;      /* else if VITC still-framing, do a thorough job:              */      ELSE IF (SMPTE.ONOFF<>0)           /* SMPTE IS BEING USED      */      AND     (SLOCKED     =0)           /* BUT NOT LOCKED           */      THEN DO;                           /* THEN USE ACTAUL REAL     */        /* get real time of note start:                             */        call Map.Sequence.Time.To.Real.Time(loc(addr(fendm)), loc(addr(m)));        /* add in actual real time duration of note:                */        LOAD (KBD.MILLISECONDS - OTIML);/* TIME THAT NOTE WAS HELD. */        MUL  SAMP.SPEED;                /* BUT APPLY CORRECTION     */        MWAIT; DIV 1000;                /* FOR STRANGE SPEEDS       */        call ADD16(res, loc(addr(m)));  /* add in actual duration   */        call Map.Real.Time.To.Sequence.Time(loc(addr(m)), loc(addr(m)));        call SUB32(loc(addr(m)), loc(addr(fendm)), loc(addr(m)));        VITC = 1;                       /* SET FLAG FOR PROCESSING BELOW */     END;     ELSE DO;                           /* END OF KEYBOARD NOTE */			/* use sampled.actual.play.time.msb for normal recording */			if (tempo.map.ptr == 0)			{				sub32(loc(addr(sampled.actual.play.time.msb)), loc(addr(fendm)), loc(addr(m)));								// Reduce note duration by number of milliseconds we are late (approximately, since time stamp should have been sampled when we sampled actual play time)				if (stamp != 0)				{					load stamp; uload 500; mul samp.speed; mwait; div 1000;		// lateness * speed / 1000, rounded										if ((m != 0) || (l IGE stamp))						sub16(stamp, loc(addr(m)));				}			}						else			{				//	if using tempo map, get corresponding sequence time				Map.Real.Time.To.Sequence.Time(loc(addr(sampled.actual.play.time.msb)), loc(addr(m)));				sub32(loc(addr(m)), loc(addr(fendm)), loc(addr(m)));			}     END;     /* Convert the duration to a sequence time with regard to */     /* tempo map:                                             */     IF (M<0) THEN DO;                  /* some of the above computations */        M = 0; L = 0;                   /* might yield negative numbers.  */     END;                               /* handle correctly here.         */     IF (M\L)=0 THEN L=1;               /* SHORTEST NOTE IS 1 MSEC! */     IF ((M IGT 3))                     /* NOTE DURATION IS TOO */     OR ((M  =  3)                      /* LONG TO RECORD       */     AND (L IGT 65472))     THEN DO;                           /* LIMIT DURATION     */        M=3; L=65472;                   /* TO 262.080 SECONDS */     END;     IF M=0 THEN DO;                        /* MAP DURATION TO MANTISSA & EXPONENT */        IF L IGT 16380 THEN DO;           LOAD L; DIV 16; L=RES;           /* MAKE NUMBER FIT IN 12-BITS */           IF REM IGE SHR(16,1) THEN L=L+1; /* ROUND UP */           M=2;                             /* THIS IS THE EXPONENT */        END;        ELSE IF L IGT 4095 THEN DO;           LOAD L; DIV 4; L=RES;            /* MAKE NUMBER FIT IN 12-BITS */           IF REM IGE SHR(4,1) THEN L=L+1;  /* ROUND UP */           M=1;                             /* THIS IS THE EXPONENT */        END;        ELSE M=0;                           /* SMALL DURATIONS FIT WITH NO MULTIPLIER */     END;     ELSE DO;                               /* REAL LONG NOTES */        LOAD L; ULOAD M; DIV 64; L=RES;     /* MAKE NUMBER FIT IN 12-BITS */        IF REM IGE SHR(64,1) THEN L=L+1;    /* ROUND UP */        M=3;                                /* THIS IS THE EXPONENT */     END;     LOAD M; MUL 8192;                      /* SHIFT BITS INTO CORRECT POS */     M=RES\SHL(L&"006000",1);     WRITE(MAM)=NAH.PTR+RECS;               /* POINT AT THE NOTE */     WRITE(MAL)=RECW;                       /* RESTORE PTR TO START OF RECORD */     WRITE(MDI)=READ(MD)\M;                 /* STORE HIGH 4-BITS OF DURATION */     WRITE(MD )=READ(MD)\SHL(L,6);          /* STORE LOW 10-BITS OF DURATION MANTISSA */     /* Create a system event when a note is added or removed */     /* from the sequencer:                                   */     NEW.SEQ.INFO = NEW.SEQ.INFO \ 4;     WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;     WRITE(MAL) = TRK;                      /* REMEMBER TRACK # ON NEW.SEQ.INFO */     WRITE(MD) = "177777";                  /*   "NEW NOTES" OR "NEW TIMBRE"    */     IF VITC <> 0 THEN DO;                  /* SET BITS AFTER VITC PLACE   */        /* Create a special system event when a note is placed in the      */        /* sequencer using VITC placing.   This tells the screen software  */        /* to scroll to that note and highlight it so that changes         */        /* can then be made:                                               */        new.seq.info = new.seq.info \ 8192;        WRITE(MAL)=RECW;                              NEW.SEQ.MATCH.W1 = READ(MDI);        NEW.SEQ.MATCH.W2 = READ(MDI);        IF NEW.SEQ.MATCH.W1 THEN DO;           NEW.SEQ.MATCH.W3 = READ(MDI);           NEW.SEQ.MATCH.W4 = READ(MD );        END;        ELSE DO;           NEW.SEQ.MATCH.W3 = RTE.MAX;           NEW.SEQ.MATCH.W4 = VEL.NOTE;        END;        VITC = 0;     END;  END;                                      /* OF RECALL CROSSCHECK */  RECW=0; RECS=0;                           /* ZERO BACK PTR TO INDICATE RECORDING DONE */END STORE.E.TIME;/* $SUBTITLE  INFO NOTE TRIGGER ROUTINE */DCL TRIGGER.INFO.NOTES    FIXED PUBLIC;DCL TIMED.INFO.NOTES      FIXED PUBLIC;DCL INFO.NOTE.TIMER(1)    FIXED PUBLIC;DCL INFO.NOTE.DURATION(1) FIXED PUBLIC;DCL INFO.TIMER.LAST       FIXED PUBLIC;INFO.NOTE.TRIGGER:PROC(TRK) PUBLIC SWAPABLE; /* TRIGGERS SEQUENCER NOTE DURING INFO MODE */   DCL (TRK,PTR,I,J,K,L) FIXED;   I=FIND.FIRST.NOTE(TRK);            /* GET PTRS TO 1ST SOUNDING NOTE ON TRK */   IF I=0 THEN RETURN;                /* NO NOTE TO SOUND         */   WRITE(MAM)=TRK.HEAD;               /* NEED TO LOOK UP ABS PTR  */   WRITE(MAL)=TRK;                    /* TO TRK HEAD FOR THIS TRK */   PTR=READ(MD);   WRITE(MAM)=NAH.PTR+TRACK.FIRST.SEC;/* POINT TO THE NOTE RECORD */   WRITE(MAL)=TRACK.FIRST.WRD;        /* FOUND ABOVE              */   I=READ(MDI); J=READ(MDI);   IF I THEN DO; K=READ(MDI); L=READ(MD); END;   ELSE      DO; K=RTE.MAX;   L=VEL.NOTE; END;   I=PLAY.SEQ.NOTE(PTR,I,J,K,L);      /* SET UP NOTE BLOCK FOR NOTE */   IF TRK.HEAD.LOOKUP(TRK, THD.CUE.TRACK) <> 0          /* MAKE INFO KEY NONZERO */   THEN CALL TRK.HEAD.STORE(TRK,THD.INFO.TRIGGER.KEY,1);/* SO WE TURN OFF THE NOTE */   ELSE IF  (I      <>0)              /* WE WERE ABLE TO START NOTE     */   AND      (SEQLAST<>0)              /* PLAY.SEQ.NOTE PUTS NOTE ON END */   THEN DO;                           /* OF SEQLIST - LOOK THERE        */      NPTR=SEQLAST;      IF (SBITS&B.VOL)<>0 THEN DO;    /* MAKE SURE HEARABLE VOLUME */         IF SHR(SBITS,8) ILT 25       /* TRY 10% OF FULL SCALE */         THEN SBITS=(SBITS&255)\SHL(25,8);      END;      WRITE(MAM)=PTR;                 /* RESTORE PTR TO TRK HEADER       */      WRITE(MAL)=THD.INFO.TRIGGER.KEY;      WRITE(MD )=KEYN\256;            /* SAVE KEYN FOR START/STOP. SET NONZERO */      IF (MOVE=0) OR (MOVE.SPEED>0)   /* NOT REWINDING                   */      THEN DO;         FENDM=(-1);                  /* info note - MARK FOR BUTTON RELEASE         */         FENDL=( 0);      END;      ELSE DO;         FENDM=0;         FENDL=0;      END;      IF PLAY=0 THEN TRIGGER.INFO.NOTES=1; /* WILL FORCE INFO NOTE TO START */   END;END INFO.NOTE.TRIGGER;// Note: This is called from the low level real time loopSTOP.INFO.NOTE:PROC (ABS.TRK#) PUBLIC SWAPABLE;  /* STOP INFO NOTE TRIGGER NOTE */   DCL (ABS.TRK#) FIXED;   CALL TRK.HEAD.STORE(ABS.TRK#,THD.INFO.TRIGGER.KEY,0);   IF TRK.HEAD.LOOKUP(ABS.TRK#, THD.CUE.TRACK) <> 0   THEN STOP.INFO.CUES = 1;   TRIGGER.INFO.NOTES=0;          /* ALWAYS RESET FLAG */   NPTR=NOTELIST;   DO WHILE NPTR<>0;      IF  (TRACK = ABS.TRK#)      /* START FINAL DECAY NOW  */      AND (((FENDM=( 0))          /* FOR INFO NOTE TRIGGERS */      AND   (FENDL=( 0)))      OR   ((FENDM=(-1))))      AND (NSTAT  =( 0))          /* IN CASE TRIGGER OVERLAPS WITH OTHER TRIGGER DURING FDECAY */      THEN DO;         NSTAT=3;         DISABLE;                 /* TERMINATE HELD INFO NOTES */         FENDM=PLAY.TIME.MSB;     /* RIGHT NOW                 */         FENDL=PLAY.TIME.LSB;         ENABLE;      END;      NPTR=NFPTR;   END;END STOP.INFO.NOTE;