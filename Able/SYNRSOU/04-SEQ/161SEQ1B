/*	:SYNRSOU:04-SEQ:161SEQ1B  $SUBTITLE  ROUTINE TO BACK UP SEQUENCER IN NON-REAL TIME	*//*Modified:1998/07/12 - TY  - Fixed bugs in BACKUP.SEQUENCER and ADVANCE.SEQUENCER that left the 32-bit						 click variables with incorrect values when the target time was on an even						 click.  This caused missing clicks when play was subsequently initiated.					  - Fixed bug in REWIND.TRACK.CLICK.CHECK.  (See comments there.)					  - Nuked unused variable "PRIOR.CLICK" from REWIND.TRACK.CLICK.CHECK.1998/07/11 - TY  - Added code to ADVANCE.SEQUENCER and BACKUP.SEQUENCER to properly						 maintain the variables needed when a click track is being referenced.1998/07/09 - TY  - Commented out Pseudo-log function used for RTE inversion, and						 replaced it with a linear inversion.1998/06/24 - TY  - Updated expressions containing (CLICK.TRACK.MODE & 511) to account for						 the independence of CLICK.TRACK.MODE from CLICKON.1990/11/06 - PF  - Support for new sustain update records1990/08/27 - PF  - Support all MIDI controllers1990/07/10 - PF  - Modified ADVANCE.SEQUENCER and BACKUP.SEQUENCER.SUBROUTINE						 to cope with Meter Map1989/09/23 - CJ  - Mapped times when reading through sequencer forward and backwards1989/09/22 - cj  - Added code in "start.up.notes.in.middle" to prevent						 starting up sound file twice (caused SMPTE "phasing" bug)1988/06/23 - cj  - changed parameters in start up notes in middle						 to avoid crunching on huge pressure record sequences.						 SEE LITERALS RIGHT AT START OF 'START.UP.NOTES.IN.MIDDLE'1989/04/26 - cj  - code to start up events in middle1988/12/10 - cj  - fixed bug with starting up first cue in sequence						 when start button pressed twice by adding send.all.cue.info.1988/10/23 - CJ  - SPEEDED UP ADVANCE.SEQUENCER TO AVOID VITC RECORDING BUGS1988/10/14 - cj  - modified start.up.notes.in.middle to start						 poly notes up in middle1988/09/30 - CJ  - CHANGED LAST.CLICK USAGE TO GET BEAT NUMBERS						 TO ADVANCE USING LIVE CLICK TRACKS WHEN						 DOING FAST FORWARD.  FIXED BUG IN REWIND TRACK						 CLICK CHECK WITH CHORDS ON CLICK TRACK.1988/09/11 - cj  - improved start.up.notes.in.middle to do its best						 to get all cues from all cue tracks!1988/08/30 - PF  - REMOVED THD.SEQ.RTES1988/08/22 - cj  - broke backup.sequencer into backup.sequencer						 and backup.sequencer.subroutine1988/04/13 - PF  - ADDED THD.SEQ.RTES1988/03/14 - cj  - send track # to dtd for cue trigger1987/08/20 - CJ  - ADDED START.UP.NOTES.IN.MIDDLE ROUTINE1986/11/25 - TS  - ATTEMPTED TO FIX BUGS IN ADVANCE/BACKUP WITH LIVE CLICK TRACKS1986/09/30 -CJ,TS- TRIED TO IMPROVE FF/REW LIMIT CHECKING1986/09/08 - TS  - PUT NON-SWAPPING COPY OF REVERSE.MERGE.INTO.EVENT.QUEUE INTO BACKUP.SEQUENCER1986/07/21 - TS  - FIXED BUG IN MIDI PROGRAM CHANGE CODE IN BACKUP.SEQUENCER1986/07/17 - CJ  - MOVED ADVANCE.SEQUENCER TO HERE1986/07/11 -CJ,TS- REWIND.TRACK.CLICK.CHECK1986/07/10 - CJ  - FIXED MARK BUTTON BUG IN ADVANCE.SEQUENCER1986/06/28 - CJ  - SPLIT OFF THIS FILE*//* Routine called by ADVANCE.SEQUENCER and BACKUP.SEQUENCER */SET.CLICK.TRACK.VARIABLES: proc;	dcl remainder fixed;		/*	Compute current sequence time	*/	call map.real.time.to.sequence.time(loc(addr(PLAY.TIME.MSB)),BitMsbArray);	/*	Convert sequence time to CT millibeats	*/	call remap.with.live.click(BitMsb,BitLsb,0,0,1);	call sub16(zero.time, loc(addr(remapped.time.msb)));	/* ----- Compute BEAT.NUMBER ----- */	load remapped.time.lsb; uload remapped.time.msb; div 1000;	BEAT.NUMBER = res+(rem<>0);	/* ----- Compute LAST.CLICK  ----- */	if (BEAT.NUMBER = 0)	then LAST.CLICK = 0;	else do;		load BEAT.NUMBER-1; uload zero.time; mul 1000;	/* ((BEAT.NUMBER-1)*1000)+ZERO.TIME */		call remap.with.live.click(ures,res,0,0,0);		/*	Convert CT millibeats back to seq time	*/		call map.sequence.time.to.real.time(loc(addr(remapped.time.msb)),BitMsbArray);		LAST.CLICK = BitLsb;	end;		/* ----- Compute NEXT.CLICK  ----- */	load BEAT.NUMBER; uload zero.time; mul 1000;			/* ((BEAT.NUMBER-0)*1000)+ZERO.TIME */	call remap.with.live.click(ures,res,0,0,0);			/*	Convert CT millibeats back to seq time	*/	call map.sequence.time.to.real.time(loc(addr(remapped.time.msb)),BitMsbArray);	NEXT.CLICK = BitLsb;	/* -----  Compute EST.RATE   ----- */	EST.RATE = NEXT.CLICK - LAST.CLICK;END;/*	$SUBTITLE  ROUTINE TO ADVANCE SEQUENCER IN NON-REAL TIME	*//*	'ADVANCE.SEQUENCER' BASICALLY HAS THE EFFECT OF PLAYING THROUGH	A NOTE LIST WITHOUT ACTUALLY MAKING ANY SOUND.  IT UPDATES ALL	THE RELEVANT GLOBAL VARIABLES, PROCESSES UPDATE RECORDS, HANDLES	LOOPS, KEEPS TRACK HEADER INFORMATION CORRECT, ETC.  THIS ROUTINE	CAN ONLY BE CALLED IF ALL THE GLOBAL VARS RELATING TO THE CURRENT	SEQUENCER STATE ARE ALREADY SET UP (I.E., NEXT EVENT QUEUE, TRK	HEADER PLAY PTRS). THIS IS ACCOMPLISHED BY CALLING THE ROUTINE,	'INIT.TRACK.HEAD.FOR.PLAY' FOR EACH TRACK IN THE SEQUENCE.	*/ADVANCE.SEQUENCER: PROC (TIME.MSB,TIME.LSB) PUBLIC SWAPABLE;	/*	STEP SEQUENCE FORWARD TO DESIRED TIME	*/	DCL (TIME.MSB,TIME.LSB) FIXED;	/*	ABS TIME TO ADVANCE SEQUENCER UP TO	*/	DCL (     MSB,     LSB) FIXED;	DCL (TEMP)          (1) FIXED;	DCL (MOVED,I          ) FIXED;	DCL MIN.ADV LIT '10';			/*	FASTEST SPEED IS 10.000	*/	/*	COMPUTE A MINIMUM AMOUNT TO ADVANCE.  THIS IS BASED UPON SPEED	*/	DO FOREVER;							/*	WE WILL LOOP HERE UNTIL WE HIT TARGET TIME	*/		/*	ADVANCE PLAY.TIME.LSB BY 15 SECONDS AT A CRACK:		*/		CALL COPY32(LOC(ADDR(PLAY.TIME.MSB)), LOC(ADDR(MSB)));		CALL ADD16 (15000, LOC(ADDR(MSB)));		/*	BUT LIMIT TO TIME OF NEXT NOTE TO AVOID PROBLEMS	*/		/*	WITH LIVE CLICK TRACK, ETC:								*/		IF  (PTRS.LOOPED=LOOP.RESTART)	/*	PLAY TIME AND PTRS ARE CONSISTENT	*/		AND (NEXT.EVENT.QUEUE<>0)			/*	AND NOTES TO PLAY							*/		AND (CLICK.TRACK.MODE igt 3)		/*	AND USING LIVE CLICK TRACK				*/		THEN DO;			call Map.Sequence.Time.To.Real.Time(loc(addr(next.event.msb)), temp);			IF ((temp(0) ILT MSB))				/*	SEE IF NEXT NOTE OCCURS	*/			OR ((temp(0)  =  MSB)				/*	BEFORE THE NEXT CLICK	*/			AND (temp(1) ILT LSB))				/*	IF IT DOES THEN NEXT		*/			THEN DO;									/*	EVENT TIME IS THE TIME	*/														/*	OF THE NOTE					*/				MSB=TEMP(0);				LSB=TEMP(1);				/*	BUT MAKE SURE WE GET SOME MOVEMENT:	*/				IF LSB<PLAY.TIME.LSB+MIN.ADV	/*	SEE IF THAT ADVANCES		*/				THEN DO;								/*	BY MINIMUM AMOUNT			*/					LSB=PLAY.TIME.LSB+MIN.ADV;					MSB=PLAY.TIME.MSB;					IF LSB ILT MIN.ADV					THEN MSB=MSB+1;				END;			END;		END;		/*	LIMIT THE MOVEMENT BY OUR SPECIFIED DESITINATION:				*/		IF ((TIME.MSB ILT MSB))					/*	FINALLY LIMIT ADVANCE	*/		OR ((TIME.MSB  =  MSB)					/*	AMOUNT TO THE TARGET		*/		AND (TIME.LSB ILT LSB))					/*	TIME WE WERE PASSED		*/		THEN DO;										/*	ABOVE							*/			MSB=TIME.MSB;			LSB=TIME.LSB;		END;		/*	COMPUTE DISTANCE TO ADVANCE (MODULO SAMP.SPEED)	*/		MOVED = 0;									/*	ASSUME NO MOVEMENT		*/														/*	NO MOVEMENT					*/		IF SAMP.SPEED<2 THEN DO;				/*	.000, .001 - SPECIAL		*/			IF (PLAY.TIME.MSB <> MSB)			OR (PLAY.TIME.LSB <> LSB)			OR (PLAY.TIME.ACU <>   0)			THEN MOVED=1;			PLAY.TIME.MSB=MSB;					/*	GO THERE IMMEDIATELY			*/			PLAY.TIME.LSB=LSB;					/*	MATH BELOW WOULD BLOW UP	*/			PLAY.TIME.ACU=0;						/*	ACCUM WOULD HIT ZERO			*/		END;		ELSE DO;										/*	CAN USE DIVIDE				*/			IF LSB<>PLAY.TIME.LSB THEN DO;	/*	IF 0 - LEAVE ACU AS IS	*/				LOAD  LSB-PLAY.TIME.LSB-1;		/*	- 1 HERE						*/				ULOAD 1000-PLAY.TIME.ACU;		/*	+ 1 HERE						*/			END;			ELSE LOAD 0;			MUL 1000;								/*	= Y MICROSECONDS TO ADV		*/			DO WHILE URES IGE SAMP.SPEED;		/*	WATCH FOR OVERFLOW ON DIV	*/				MOVED = 1;							/*	SOME MOVEMENT					*/				LOAD 0;								/*	MOVE AS FAR AS WE CAN		*/				ULOAD SAMP.SPEED-1;				/*	WITHOUT OVERFLOW HERE		*/				DIV SAMP.SPEED;					/*	CAN MOVE THAT MANY			*/				LOAD RES; MUL SAMP.SPEED;		/*	INTEGER # OF SAMP.SPEEDS	*/				MWAIT; DIV 1000;				PLAY.TIME.ACU=PLAY.TIME.ACU+REM;				IF PLAY.TIME.ACU>=1000 THEN DO;					PLAY.TIME.LSB=PLAY.TIME.LSB+1;					IF PLAY.TIME.LSB=0 THEN PLAY.TIME.MSB=PLAY.TIME.MSB+1;					PLAY.TIME.ACU=PLAY.TIME.ACU-1000;				END;				PLAY.TIME.LSB=PLAY.TIME.LSB+RES;				IF PLAY.TIME.LSB ILT RES				THEN PLAY.TIME.MSB=PLAY.TIME.MSB+1;				IF LSB<>PLAY.TIME.LSB THEN DO;	/*	IF 0 - LEAVE ACU AS IS	*/					LOAD  LSB-PLAY.TIME.LSB-1;		/*	- 1 HERE						*/					ULOAD 1000-PLAY.TIME.ACU;		/*	+ 1 HERE						*/				END;				ELSE LOAD 0;				MUL 1000;								/*	= Y MICROSECONDS TO ADV	*/			END;			DIV SAMP.SPEED;			IF RES<>0 THEN MOVED = 1;				/*	SOME MOVEMENT				*/			LOAD RES; MUL SAMP.SPEED;			MWAIT; DIV 1000;			PLAY.TIME.ACU=PLAY.TIME.ACU+REM;			IF PLAY.TIME.ACU>=1000 THEN DO;				PLAY.TIME.LSB=PLAY.TIME.LSB+1;				IF PLAY.TIME.LSB=0 THEN PLAY.TIME.MSB=PLAY.TIME.MSB+1;				PLAY.TIME.ACU=PLAY.TIME.ACU-1000;			END;			PLAY.TIME.LSB=PLAY.TIME.LSB+RES;			IF PLAY.TIME.LSB ILT RES			THEN PLAY.TIME.MSB=PLAY.TIME.MSB+1;		END;		NEW.MOTION =1;								/*	TELL LOD ABOUT IT			*/		/*	BRING SEQUENCER POSITION UP TO JUST BEFORE THIS TIME:			*/		IF  (PTRS.LOOPED=LOOP.RESTART)		/*	PLAY TIME AND PTRS ARE CONSISTENT	*/		THEN DO;			/*	Get corresponding Sequence time from this real time:	*/			call Map.Real.Time.To.Sequence.Time(loc(addr(play.time.msb)), TEMP);			if com16(0, temp) <> lw#ieq	/*	scan up to 1 sequencer unit		*/			then call sub16(1, temp);		/*	before this matching real time.	*/			CALL SCAN.SEQUENCER.NOTES(TEMP(0), TEMP(1));		END;		/* update the click and beat variables until we're ready to return to the point of call */		IF (PLAY.TIME.LSB > REAL.TIME.OF.NEXT.CLICK.LSB)		THEN DO;			CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),															LOC(ADDR(MSB)));			/*	Do this so that if we're on an even click, NEXT.CLICK.MSB,LSB will be	*/			/*	the one we're on, and PRIOR.CLICK.MSB,LSB will be the one before.			*/			call sub16(1,loc(addr(MSB)));			CALL MAP.SEQUENCE.TIME.TO.NEAREST.CLICKS(LOC(ADDR(MSB)),																  LOC(ADDR(PRIOR.CLICK.MSB)),																  LOC(ADDR(NEXT.CLICK.MSB)));			/*	MAP NEXT CLICK TO REAL TIME	*/			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(NEXT.CLICK.MSB)),															LOC(ADDR(REAL.TIME.OF.NEXT.CLICK.MSB)));		END;		if click.track.mode igt 3		then do;		/* LIVE CLICK */			/*	Note: The previous call to SCAN.SEQUENCER.NOTES calls TRACK.CLICK.CHECK which keeps	*/			/*	LAST.CLICK, NEXT.CLICK, EST.RATE and BEAT.NUMBER up to date - BUT ONLY until the		*/			/*	last note on the click track is scanned.  During normal play, beyond the last note	*/			/*	on the click track, the interrupt code keeps these up to date.  But because this		*/			/*	procedure moves the sequencer by as much as 15 seconds at a crack, the interrupt		*/			/*	routine cannot keep these variables correctly up to date.  Consequently, we'll		*/			/* begrudgingly use the non-real-time live click mapping procedure to properly set		*/			/*	these variables.																							*/				IF (PLAY.TIME.LSB > NEXT.CLICK)			THEN DO;				if TRIGGER.CLICK<>3				then do;	/*	(TRIGGER.CLICK<>3) means we're not past the last note on the click track.		*/					/*	Since we're not past the last note on the click track, we can do it the fast way.	*/					NEXT.CLICK = NEXT.CLICK + EST.RATE;					/*	Note: Because this procedure adds MIN.ADV to PLAY.TIME.MSB,LSB, the call to TRACK.CLICK.CHECK	*/					/*	typically sets NEXT.CLICK late by MIN.ADV, and subtracts this time from EST.RATE to compensate.	*/					/*	Hence the following:																										*/					EST.RATE = NEXT.CLICK - LAST.CLICK;					/*	(TRIGGER.CLICK = 2) means the last note on the click track was just scanned.	*/					if (TRIGGER.CLICK = 2) then TRIGGER.CLICK = 3;				end;				else do;	/*	(TRIGGER.CLICK = 3) means we're past the last note on the click track.	*/					/* We have to determine all the variables from scratch - the slow way. */					call SET.CLICK.TRACK.VARIABLES;				end;								NEW.BEAT.NUMBER = True;		/* Tell :06-MAIN:325-NEW to update the VK window.	*/			END;		end;		else do;		/* INT OR EXT CLICK */			IF (PLAY.TIME.LSB > REAL.TIME.OF.NEXT.BEAT.LSB) THEN NEW.BEAT.NUMBER = True;		end;		/*	ARE WE THERE YET?  ARE WE THERE YET?  ARE WE THERE YET?  ARE WE THERE YET?	*/		IF  ((MOVED = 0))						/*	NO MOVEMENT							*/		OR  ((PLAY.TIME.LSB=TIME.LSB)		/*	HAVE ADVANCED TO TARGET TIME	*/		AND  (PLAY.TIME.MSB=TIME.MSB))	/*	SO WE ARE ALL DONE				*/		THEN RETURN;							/*	GO FAR FAR AWAY	*/	END;											/*	OF LOOP UNTIL WE GET TO TARGET TIME	*/END ADVANCE.SEQUENCER;/*	$PAGE - BACK UP SEQUENCER	*//*	'BACKUP.SEQUENCER' OPERATES JUST LIKE 'ADVANCE.SEQUENCER'	*//*	ONLY IT GOES IN THE OPPOSITE DIRECTION.							*//*	PASS CODE = 1 TO PERFORM NORMAL SEQUENCER BACKUP.				*//*	PASS CODE = 0 TO JUST BACK UP PLAY TIME							*/BACKUP.SEQUENCER.SUBROUTINE: PROC (TIME.MSB,TIME.LSB,CODE) PUBLIC SWAPABLE;	/*	REWINDS SEQUENCER IN NON-REAL TIME */	DCL (TIME.MSB,TIME.LSB) FIXED;	DCL (CODE             ) FIXED;	DCL (     MSB,     LSB) FIXED;	DCL (MOVED            ) FIXED;	DCL MIN.ADV LIT '10';		/*	FASTEST SPEED	*/	REVERSE.MERGE.INTO.EVENT.QUEUE: PROC (PTR);	/*	SORTS TRK INTO EVENT QUEUE IF MOVING BACKWARDS	*/		DCL PTR			 FIXED;	/*	ABS POINTER TO TRACK HEAD	*/		DCL (MSB,LSB)	 FIXED;	/*	HOLDS NEXT EVENT TIMES		*/		DCL (FPTR,RPTR) FIXED;	/*	HOLDS FORWARD AND REVERSE LINK PTRS	*/		/*	NOTE: THIS ROUTINE SORTS IN DESCENDING ORDER USING		*/		/*			THE TRACK HEAD VARIABLES, THD.LMSB AND THD.LLSB	*/		WRITE(MAM)=PTR;						/*	LOOK AT TRACK HEAD			*/		WRITE(MAL)=THD.LMSB;					/*	LOOK AT LAST EVENT TIME		*/		MSB=READ(MDI);							/*	THD.LMSB							*/		LSB=READ(MD );							/*	THD.LLSB							*/		WRITE(MAL)=THD.NEV.MSB;				/*	SAVE QUE TIME FOR				*/		WRITE(MDI)=MSB;						/*	THIS TRACK						*/		WRITE(MD )=LSB;		/*	PUT EVENT INTO PROPER POSITION IN QUEUE	*/		IF NEXT.EVENT.QUEUE=0 THEN DO;	/*	BLOCK GOES ON FRONT			*/			NEXT.EVENT.QUEUE=PTR-NAH.PTR;	/*	SAVE AS RELATIVE PTR			*/			WRITE(MAL)=THD.NEVF;				/*	ZERO OUT QUE POINTERS		*/			WRITE(MDI)=0;						/*	THD.NEVF							*/			WRITE(MD )=0;						/*	THD.NEVR							*/			NEXT.EVENT.MSB=MSB;				/*	SAVE TIME IN MEMORY			*/			NEXT.EVENT.LSB=LSB;			RETURN;		END;		WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	START AT FRONT OF QUEUE	*/		NEXT.TRACK:		WRITE(MAL)=THD.NEVF;					/*	LOOK UP FOR & REV PTRS FOR TRK	*/		FPTR=READ(MDI);						/*	THD.NEVF							*/		RPTR=READ(MD );						/*	THD.NEVR							*/		WRITE(MAL)=THD.NEV.MSB;				/*	COMPARE MSB,LSB WITH THIS TRK	*/		IF  ((MSB ILT READ(MD )))			/*	OUR NEXT EVENT IS EARLIER	*/		OR  ((MSB  =  READ(MDI))			/*	THAN THE NEXT EVENT FOR		*/		AND  (LSB ILE READ(MD )))			/*	THIS TRACK						*/		THEN DO;									/*	STEP TO NEXT TRK IN QUEUE	*/			IF FPTR<>0							/*	HAVE NOT HIT END OF QUEUE	*/			THEN DO;								/*	APPEND OUR TRACK HERE		*/				WRITE(MAM)=NAH.PTR+FPTR;	/*	CONVERT TO ABS. PTR			*/				GOTO NEXT.TRACK;				/*	COMPARE OUR NEXT TIME WITH NEXT TRK	*/			END;			ELSE DO;								/*	PUT BLOCK ON END OF LIST		*/				RPTR=READ(MAM)-NAH.PTR;		/*	COMPUTE OUR REVERSE POINTER	*/				WRITE(MAL)=THD.NEVF;			/*	STORE NEW FORWARD PTR			*/				WRITE(MD )=PTR-NAH.PTR;		/*	THD.NEVF NOW POINTS TO US		*/				WRITE(MAM)=PTR;				/*	NOW SET LINK VARS ON OUR TRK	*/				WRITE(MAL)=THD.NEVF;				WRITE(MDI)=0;					/*	NO FORWARD PTR -- WE ARE LAST	*/				WRITE(MD )=RPTR;				/*	THD.NEVR POINTS TO PREV TRK	*/				RETURN;			END;		END;		/*	INSERT BLOCK INTO QUE	*/		/*	AT THIS POINT			*/		WRITE(MAL)=THD.NEVR;				/*	THD.NEVR FOR TRK NOW		*/		WRITE(MD)=PTR-NAH.PTR;			/*	POINTS BACK TO US			*/		IF RPTR<>0							/*	WE ARE NOT FIRST IN LIST	*/		THEN DO;								/*	DO NORMAL INSERT				*/			FPTR=READ(MAM)-NAH.PTR;		/*	GET REL PTR TO NEXT TRK		*/			WRITE(MAM)=PTR;				/*	SET LINK VARS ON OUR TRK	*/			WRITE(MAL)=THD.NEVF;			WRITE(MDI)=FPTR;				/*	THD.NEVF PTS TO NEXT		*/			WRITE(MD )=RPTR;				/*	THD.NEVR PTS TO PREV		*/			WRITE(MAM)=NAH.PTR+RPTR;	/*	POINT TO PREV TRK			*/			WRITE(MAL)=THD.NEVF;			WRITE(MD )=PTR-NAH.PTR;		/*	THD.NEVF PTS TO US		*/		END;		ELSE DO;									/*	INSERT AT HEAD OF LIST		*/			WRITE(MAM)=PTR;					/*	SET LINK VARS ON OUR TRK	*/			WRITE(MAL)=THD.NEVF;			WRITE(MDI)=NEXT.EVENT.QUEUE;	/*	NEW THD.NEVF				*/			WRITE(MD )=0;						/*	THD.NEVR IS NULL			*/			NEXT.EVENT.QUEUE=PTR-NAH.PTR;	/*	AND LAST OF ALL FIX LIST HEAD PTR	*/			NEXT.EVENT.MSB=MSB;				/*	SAVE TIME IN MEMORY		*/			NEXT.EVENT.LSB=LSB;		END;	END REVERSE.MERGE.INTO.EVENT.QUEUE;	REWIND.TRACK.CLICK.CHECK:PROC;		DCL (LOOP.SCANNED) FIXED;		DCL (I,J         ) FIXED;		WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;	/*	POINT TO TRACK HEAD		*/		#PTR = READ(MAM);		WRITE(MAL)=THD.TRK;		#TRK = READ(MD);		CALL LOAD.#.INFO(THD.NMSB);			/*	GET TIME OF NOTE IN QUESTION, BUT #ANYR, #LMSB, #LLSB IS QUESTIONABLE */		CALL ADVANCE.TO.NEXT.REAL.NOTE;		/*	ADVANCE AND THEN BACKUP	*/		call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), loc(addr(#RMSB)));		I = #ANYF; J = #RLSB;					/*	SAVE INFO					*/		CALL BACKUP.TO.PRIOR.REAL.NOTE;		/*	TO GET #ANYR, #LMSB OK	*/		call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), loc(addr(#RMSB)));		IF (I =  0    )							/*	IF THIS IS LAST NOTE		*/		OR (J <> #RLSB)							/*	ON TRACK,  OR IF NOT		*/		THEN DO;										/*	A CHORD ...					*/			BEAT.NUMBER=BEAT.NUMBER-1;			IF BEAT.NUMBER<0 THEN BEAT.NUMBER=0;			NEW.BEAT.NUMBER=1;					/*	NEW BEAT #					*/		END;		NEXT.CLICK=#RLSB;							/*	SAVE TIME OF CLICK		*/		TRIGGER.CLICK=0;							/*	DISABLE CLICK.  WILL BE SET WHEN WE SCAN THE NOTE FORWARD	*/		LOOP.SCANNED = 0;							/*	DETECT EMPTY INDEP LOOP	*/		MORE:;		IF #ANYR=0 THEN DO;						/*	BEGINNING OF SEQUENCE	*/			LAST.CLICK =0;			EST.RATE   =NEXT.CLICK;			RETURN;		END;		CALL BACKUP.TO.PRIOR.REAL.NOTE;		#W1=#W1 & "174001";						/*	EXTRACT NOTE TYPE			*/		IF #W1 = "110001" THEN GOTO MORE;	/*	SKIP OVER EXTRANEOUS ILE RECORD?	*/		IF #W1 = "104001" THEN DO;				/*	ILS RECORD					*/			IF LOOP.SCANNED<>0 THEN DO;		/*	EMPTY INDEP LOOP			*/				LAST.CLICK =0;				EST.RATE   =NEXT.CLICK;				RETURN;			END;			LOOP.SCANNED = 1;			WRITE(MAM)=#PTR;			WRITE(MAL)=THD.ILPCTR;			IF READ(MD)=0 THEN GOTO MORE;		/*	KEEP GOING OVER FIRST ILS	*/			WRITE(MAL)=THD.ILE.WRD;			#WRD = READ(MDI);			#SEC = READ(MD );			IF #SEC=0 THEN DO;					/*	ILE RECORD WITH NO ILS?		*/				LAST.CLICK =0;				EST.RATE   =NEXT.CLICK;				RETURN;			END;			GOTO MORE;		END;		/*	BUG FIX: The following line of code was missing.  This caused LAST.CLICK to be assigned	*/		/*	the same value as NEXT.CLICK which caused EST.RATE to be evaluated as 0.						*/		call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), loc(addr(#RMSB)));		LAST.CLICK  = #RLSB;		EST.RATE    = NEXT.CLICK-LAST.CLICK;	/*	ACTUALLY A PRETTY GOOD ESTIMATE	*/	END REWIND.TRACK.CLICK.CHECK;	/*	FOR TRANPOSE TRACKS: RESET TRANSPOSE UPON REWIND	*/	REWIND.TRANSPOSE.CHECK:PROC;		DCL (LOOP.SCANNED) FIXED;		DCL (I,J         ) FIXED;		/*	WE ARE CALLED WHEN SCANNING BACKWARDS AND WE COME ACROSS A REAL NOTE.	*/		/*	FIND THE YET NEXT EARLIER REAL NOTE AND FIX UP TRANSPOSING.					*/		WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;	/*	POINT TO TRACK HEAD		*/		#PTR = READ(MAM);		WRITE(MAL)=THD.TRK;		#TRK = READ(MD);		CALL LOAD.#.INFO(THD.NMSB);			/*	GET TIME OF NOTE IN QUESTION, BUT #ANYR, #LMSB, #LLSB IS QUESTIONABLE */		CALL ADVANCE.TO.NEXT.REAL.NOTE;		/*	ADVANCE AND THEN BACKUP	*/		CALL BACKUP.TO.PRIOR.REAL.NOTE;		/*	TO GET #ANYR, #LMSB OK	*/		LOOP.SCANNED = 0;							/*	DETECT EMPTY INDEP LOOP	*/		MORE:;		IF #ANYR=0 THEN DO;						/*	BEGINNING OF SEQUENCE	*/			TRANSPOSE.SEQUENCER.TRACKS(#TRK, TRK.HEAD.LOOKUP(#TRK, THD.XPOSBASE), 0, 0);			RETURN;		END;		CALL BACKUP.TO.PRIOR.REAL.NOTE;		#W1=#W1 & "174001";						/*	EXTRACT NOTE TYPE			*/		IF #W1 = "110001" THEN GOTO MORE;	/*	SKIP OVER EXTRANEOUS ILE RECORD?	*/		IF #W1 = "104001" THEN DO;				/*	ILS RECORD					*/			IF LOOP.SCANNED<>0 THEN RETURN;	/*	EMPTY INDEP LOOP ?		*/			LOOP.SCANNED = 1;			WRITE(MAM)=#PTR;			WRITE(MAL)=THD.ILPCTR;			IF READ(MD)=0 THEN GOTO MORE;		/*	KEEP GOING OVER FIRST ILS	*/			WRITE(MAL)=THD.ILE.WRD;			#WRD = READ(MDI);			#SEC = READ(MD );			IF #SEC=0 THEN RETURN;				/*	ILE RECORD WITH NO ILS?		*/			GOTO MORE;		END;		I = (#W2 & "77") + 12;						/*	KEYN =					*/		IF ((#W1 & 1) != 0)							/*	IF 4 WORD RECORD		*/		{			IF ((#W4&(LOWER.KEY\RAISE.KEY)) != 0)			{				IF (#W4&LOWER.KEY)<>0 THEN I=I-12;				IF (#W4&RAISE.KEY)<>0 THEN I=I+12;			}		}		TRANSPOSE.SEQUENCER.TRACKS	(#TRK, I, NEXT.EVENT.MSB, NEXT.EVENT.LSB);	END REWIND.TRANSPOSE.CHECK;	SCAN.SEQUENCER.BACKWARDS: PROC (TIME.MSB,TIME.LSB);		DCL (TIME.MSB, TIME.LSB) FIXED;		DCL (MSB     , LSB)		 FIXED;		DCL (W1,W2,W3,W4,I,J,K)	 FIXED;		DCL UPDATES					 FIXED;		call Map.Real.Time.To.Sequence.Time(loc(addr(time.msb)),														loc(addr(time.msb)));		DO WHILE (NEXT.EVENT.QUEUE<>0)			/*	LOOP WHILE NOTES IN QUEUE	*/			AND   (((TIME.MSB ILT NEXT.EVENT.MSB))			OR     ((TIME.MSB  =  NEXT.EVENT.MSB)			AND     (TIME.LSB ILE NEXT.EVENT.LSB)));			/*	1. COPY LAST EVENT TIME OVER NEXT EVENT TIME	*/			WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;	/*	POINT TO TRK HEAD	*/			WRITE(MAL)=THD.LMSB;			/*	COPY LAST EVENT TIME OVER NEXT TIME	*/			WRITE("300")=READ(MDI);		/*	PUT THD.LMSB IN TEMP		*/			WRITE("301")=READ(MDI);		/*	PUT THD.LLSB IN TEMP		*/			WRITE(MAL)=THD.NMSB;			WRITE(MDI)=READ("300");		/*	STORE INTO THD.NMSB		*/			WRITE(MDI)=READ("301");		/*	STORE INTO THD.NLSB		*/			/*	2. READ CURRENT PLAY PTRS AND SEE IF WE	*/			/*		NEED TO BACK UP TO THE PRIOR NLS			*/			WRITE(MAL)=THD.WRD;			/*	GET AT PLAY PTRS				*/			LSB=READ(MDI);					/*	SAVE THD.WRD AND THD.SEC	*/			MSB=READ(MD);					/*	FOR THIS TRK					*/			WRITE(MAM)=MSB+NAH.PTR;		/*	POINT TO NLS					*/			WRITE(MAL)=NLS.FP;			/*	LOOK UP PTR TO FIRST NOTE	*/			K=READ(MD);			DO WHILE LSB=K;				/*	AT START OF NLS, GO BACK	*/				WRITE(MAL)=NLS.REV;		/*	AND SEE IF PRIOR NLS EXISTS	*/				MSB=READ(MD);				/*	GET PTR TO PRIOR NLS	*/				WRITE(MAM)=NAH.PTR+MSB;	/*	LOOK UP PTR TO FIRST NOTE	*/				WRITE(MAL)=NLS.FP;		/*	LOOK UP NEW PTR TO FIRST NOTE	*/				K  =READ(MDI);				/*	READ IT THEN STEP TO NLS.LP VAR	*/				LSB=READ(MD );				/*	LSB=NLS.LP (PTR TO LAST NOTE IN NLS)	*/			END;			/*	3. NOW BACK UP THE PTRS TO THE PRIOR NOTE	*/			WRITE(MAL)=LSB-1;				/*	POINT AT LAST WD OF PRIOR RECORD	*/			IF (READ(MD)&"77")=VEL.NOTE	/*	PRIOR NOTE IS A 4-WD RECORD	*/			THEN LSB=LSB-4;					/*	JUMP TO START OF PRIOR			*/			ELSE LSB=LSB-2;					/*	RECORD								*/			/*	4. AT THIS POINT, (MSB,LSB) CONTAIN PTRS	*/			/*		TO THE NOTE RECORD WE WANT TO PROCESS	*/			/*		READ THE NOTE RECORD INTO TEMPS			*/			WRITE(MAL)=LSB;				/*	POINT TO THE PRIOR NOTE	*/			W1=READ(MDI);					/*	READ THE NOTE RECORD		*/			W2=READ(MDI);					/*	INTO TEMPORARY VARS		*/			IF W1 THEN DO;					/*	THIS IS A 4-WRD RECORD	*/				W3=READ(MDI);				W4=READ(MDI);			END;			ELSE DO;				W3=RTE.MAX;					/*	SET TO VALUES WHICH		*/				W4=VEL.NOTE;				/*	DON'T BLOW UP BELOW		*/			END;			/*	5. SET THE MORE FORWARD NOTES FLAG AND STORE	*/			/*		THE NEW PLAY PTRS BACK IN TRACK HEADER		*/			WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;	/*	RESTORE PTR TO TRK HEAD	*/			WRITE(MAL)=THD.ANY.FOR;		/*	NEED TO SET THE FORWARD FLAG	*/			WRITE(MD )=1;					/*	SINCE AT LEAST ONE MORE NOTE	*/			WRITE(MAL)=THD.WRD;			/*	STORE NEW PTRS BACK IN HEADER	*/			WRITE(MDI)=LSB;				/*	REWRITE THD.WRD					*/			WRITE(MD )=MSB;				/*	REWRITE THD.SEC					*/			/*	6.  NOW PROCESS THE NOTE	*/			IF W1<0 THEN DO;			/*	PROCESS ALTERNATE FORMAT RECORD	*/				I=ROT(W1,5)&"17";		/*	EXTRACT ALT FORMAT TYPE CODE		*/				IF I=0 THEN DO;		/*	SPECIAL EXTENDED REST NOTE RECORD	*/					/*	DO NOTHING WITH SPECIAL REST RECORDS	*/					/*	DURING REWIND.  THE EXTRA DELTA FIELD	*/					/*	HAS ALREADY BEEN SUBTRACTED FROM THE	*/					/*	LAST EVENT TIME FOR THIS TRACK			*/				END;						/*	OF SPECIAL EXTENDED REST RECORD	*/				ELSE IF I=1 THEN DO;	/*	INDEPENDENT LOOP START RECORD		*/					/*	PERFORM JUMP TO ILP END POINT		*/					/*	IF WE ARE NOT ALL DONE UNWINDING	*/					/*	THE INDEPENDENT LOOP.				*/					CALL HANDLE.LOOP.JUMP(READ(MAM),THD.ILE.WRD);					/*	READ IN THE ILP END RECORD FOR PROCESSING BELOW	*/					WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	RESTORE PTR TO TRK HEAD	*/					WRITE(MAL)=THD.WRD;			/*	AND READ THE NEW PLAY PTRS	*/					LSB=READ(MDI);					/*	GET NEW THD.WRD				*/					MSB=READ(MD );					/*	AND NEW THD.SEC				*/					WRITE(MAM)=NAH.PTR+MSB;		/*	POINT TO WORD AT NEW PTRS	*/					WRITE(MAL)=LSB;					W1=READ(MD);					/*	READ 1ST WD OF NOTE RECORD	*/				END;						/*	OF ILP START RECORD				*/				ELSE IF I=2 THEN DO;	/*	INDEPENDENT LOOP END RECORD	*/					/*	DURING REWIND WE SHOULD NEVER ACTUALLY		*/					/*	ENCOUNTER THE ILP END RECORD.  IF WE DO	*/					/*	THEN WE HAD BETTER JUST IGNORE IT			*/				END;						/*	OF ILP END RECORD					*/			END;							/*	OF ALTERNATE FORMAT RECORD		*/			ELSE DO;						/*	PROCESS NORMAL FORMAT RECORD	*/				IF (W3&SHL(B.UPD,8))<>0	/*	UPDATE RECORD	*/				THEN DO;						/*	PROCESS TO KEEP RTE INFO CORRECT	*/					IF (W3&SHL(B.GUI,8))<>0	/*	GUITAR UPDATE RECORD	*/					THEN DO;						/*	PROCESS IT	*/					END;					ELSE DO;							/*	KEYBOARD UPDATE RECORD	*/						DO CASE (SHR(W2,6)&3);	/*	BRANCH ON UPDATE TYPE	*/							DO;								/*	NORMAL UPDATE RECORD	*/								IF (W2&"100000")<>0		/*	TRUE MIDI FORMAT UPDATE	*/								THEN DO;									I=SHR(W2,8)&"177";	/*	EXTRACT MIDI CONTROLLER NUMBER (0-127)	*/									K=SHR(W4,8);			/*	GET MIDI VALUE	*/									WRITE(MAL)=THD.TRK;	/*	LOOKUP TRACK NUMBER	*/									J=READ(MD);									WRITE(MAM)=MIDI.TRACK.RTES+J;									WRITE(MAL)=I;			/*	INDEX INTO MIDI DATA ARRAY	*/									WRITE(MD )=K\(READ(MD)&"177400");	/*	STORE CORRECT MIDI VALUE	*/									WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	RESTORE PTR TO TRK HEAD	*/								END;								ELSE DO;						/*	SYNCLAV FORMAT	*/									I=SHR(W2,8)&"17";		/*	EXTRACT RTE DATA CODE (0-5)	*/									K=SHR(W4,8);			/*	GET RTE VALUE	*/									IF I<R.PWHEEL THEN DO;			/*	INVERT USING LOG FUNCTION	*/										/* INVERT LINEARLY */										K=K\SHL(RTE.MAX-K,8);										/*	************************ B E G I N   D E L E T I O N ************************	*\										\* INVERT USING PSEUDO-LOG FUNCTION *\										LOAD (RTE.MAX*20+400); DIV (K+20);										K=K\SHL(RES-20,8);			\* USE LOG-LIKE FUNCTION FOR BEST INVERSION *\										\*	************************** E N D   D E L E T I O N **************************	*/									END;									ELSE IF I=R.PWHEEL THEN DO;	/*	NEGATE FOR PWHEEL.  LEAVE RIBBON ALONE FOR NOW	*/										K=(K&255)\SHL((-K)&255,8);	/*	STORE - TWO 8-BIT TWOS COMPLEMENT NUMBERS	*/									END;									WRITE(MAL)=THD.RTES+I;			/*	INDEX INTO RTE DATA ARRAY	*/									WRITE(MD )=K;						/*	STORE RTE AND INVERTED RTE	*/									WRITE(MAL)  =THD.CTIMB;			/*	LOOK UP CURRENT TIMBRE NUMBER	*/									WRITE("300")=READ(MD);			/*	SAVE IN R0 SPEED					*/									WRITE(MAM)  =TIM.HEAD;			/*	POINT TO TIMBRE HEADER FOR		*/									WRITE(MAL)  =READ("300");		/*	THIS TRACK'S CURRENT TIMBRE	*/									WRITE(MAM)  =READ(MD);			/*	THEN POINT TO THE TIMBRE INFO	*/									WRITE(MAL)  =TIM.ACT.PARS+I;	/*	AND LOOK UP ITS ACTIVE RTE PARMS	*/									UPDATES=UPDATES\READ(MD);		/*	SAVE IN TEMP FOR ONE UPDATE BELOW	*/									WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	RESTORE PTR TO TRK HEAD	*/								END;					/*	OF SYNCLAVIER UPDATE FORMAT	*/							END;						/*	OF NORMAL UPDATE RECORD			*/							DO;						/*	TOGGLE BITS UPDATE RECORD		*/								WRITE(MAL)=THD.CTBITS;		/*	SAVE NEW TOGGLE BITS	*/								WRITE(MD )=ROT(W2,4)&"17";	/*	IN TRACK HEADER		*/								UPDATES=UPDATES\N.REPRATE;	/*	UPDATE REPEAT/ARPEGGIATE	*/							END;						/*	OF TOGGLE BITS UPDATE RECORD	*/							DO;						/*	PRESSURE UPDATE RECORD	*/								/*	DO NOTHING WITH PRESSURE UPDATE	*/								/*	RECORDS FOR NOW						*/							END;							DO;	/*	MIDI UPDATE RECORD INFO	*/								IF SHR(W2,8)=0		/*	MIDI UPDATE RECORD TYPE		*/								THEN DO;				/*	IS A PROGRAM CHANGE RECORD	*/									WRITE(MAL)=THD.CPROGRAM;	/*	SAVE NEW VALUE	*/									WRITE(MD )=SHR(W4,8)\128;	/*	IN PLAY INFO	*/								END;								ELSE IF (SHR(W2,8)=2)		/*	SUSTAIN SWITCH UPDATE RECORD	*/								THEN DO;									WRITE(MAL)=THD.SUSTAIN;	/*	POINT TO SUSTAIN STATUS	*/									IF (SHR(W4,8)=0)			/*	SUSTAIN OFF	*/									THEN WRITE(MD)=(READ(MD)&(NOT B.CURRENT.SUSTAIN));									ELSE WRITE(MD)=(READ(MD)\B.CURRENT.SUSTAIN);								END;							END;						END;					/*	OF BRANCH ON UPDATE TYPE		*/						IF UPDATES<>0		/*	HAVE SOME RTE UPDATES TO DO	*/						THEN DO;				/*	LINK TRK ONTO UPDATE QUEUE		*/							WRITE(MAL)=THD.UPD.PARS;		/*	POINT AT UPD.PARS WORD			*/							WRITE(MDI)=READ(MD)\UPDATES;	/*	OR IN BITS FOR RTES AFFECTED	*/							IF  (READ(MD)=0)					/*	CHECK THD.UPD.QUED				*/							THEN DO;								/*	NOT IN LIST SO PUT IT THERE	*/								WRITE(MDI)=1;					/*	THD.UPD.QUED TO NONZERO			*/								WRITE(MD)=UPLIST0;			/*	STORE REL. FORWARD PTR			*/								UPLIST0=NEXT.EVENT.QUEUE;	/*	IN THD.UPD.LINK					*/							END;							UPDATES=0;							/*	THEN RESET LOCAL FLAG			*/							NEW.INFO=1;							/*	SET FLAG TO DO UPDATES ASAP	*/						END;					END;						/*	OF KEYBOARD UPDATE RECORD (NOT GUITAR)	*/				END;							/*	OF CASE FOR UPDATE RECORD	*/				ELSE DO;						/*	NORMAL "REAL" NOTE	*/					IF (W2&"77")<>REST.NOTE						/*	NOT A REST NOTE	*/					THEN DO;						IF CLICK.TRACK.MODE ige 4 THEN DO;	/*	CHECK QUICKLY	*/							WRITE(MAL)=THD.TRK;					/*	LOOK UP OUR TRK #	*/							IF CLICK.TRACK.MODE = (4-NUM.KBD.TRACKS+READ(MD))	/*	USING LIVE CLICK TRACK	*/							THEN DO;									/*	RETARD CLICK/BEAT NUMBER HERE	*/								CALL REWIND.TRACK.CLICK.CHECK;							END;						END;						/*	DO NOTHING WITH THE NOTE	*/						/*	ITSELF DURING REWIND			*/						WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;						WRITE(MAL)=THD.IGNORE;						IF ((READ(MD) & THD.IGNORE.XPOS) != 0)							REWIND.TRANSPOSE.CHECK();					END;						/*	OF NOT A REST NOTE				*/				END;							/*	OF PROCESS NORMAL "REAL" NOTE	*/			END;								/*	OF NORMAL FORMAT NOTE RECORD PROCESSING	*/			/*	7. SUBTRACT OUR DELTA FROM THE CURRENT LAST EVENT TIME	*/			I=SHR(W1,1)&1023;				/*	START TIME DELTA FROM CURRENT NOTE	*/			WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	POINT TO TRK HEAD		*/			WRITE(MAL)=THD.LLSB;			/*	COMPUTE NEW NEXT EVENT TIME		*/			IF READ(MD) ILT I				/*	WILL NEED TO BORROW FOR SUBTRACT	*/			THEN DO;							/*	FULL 32-BIT SUBTRACT W/BORROW		*/				WRITE(MAL)=THD.LMSB;				WRITE(MDI)=READ(MD)-1;	/*	DECREMENT THD.LMSB					*/			END;			WRITE(MD)=READ(MD)-I;		/*	NORMAL SUBTRACT FROM LSB			*/			/*	8. AT THIS POINT WE NEED TO REMOVE	*/			/*		THIS TRACK FROM THE EVENT QUEUE	*/			/*		SINCE WE HAVE PROCESSED THE NOTE	*/			/*		RECORD IT REFERRED TO				*/			I=READ(MAM);					/*	SAVE ABS PTR TO OUR TRK		*/			WRITE(MAL)=THD.NEVF;			/*	LOOK UP FORWARD PTR			*/			NEXT.EVENT.QUEUE=READ(MD);	/*	IT BECOMES HEAD OF LIST		*/			IF READ(MD)<>0 THEN DO;		/*	ADJUST NEW HEAD				*/				WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;	/*	NOW LOOK AT NEXT TRK IN LIST	*/				WRITE(MAL)=THD.NEVR;		/*	NEED TO ZERO ITS BACK PTR	*/				WRITE(MD )=0;				/*	SINCE NOW AT FRONT OF LIST	*/				WRITE(MAL)=THD.NEV.MSB;	/*	RESET NEXT EVENT TIME		*/				NEXT.EVENT.MSB=READ(MDI);	/*	TO TIME OF FIRST TRK		*/				NEXT.EVENT.LSB=READ(MD );	/*	IN EVENT QUEUE				*/			END;			/*	AT THIS POINT THE FOLLOWING VARS ARE MEANINGFUL:	*/			/*			I      CONTAINS ABS PTR TO TRK HEAD				*/			/*		(MSB,LSB) CONTAIN THE CURRENT PLAY PTR				*/			/*	9. SEE IF THERE IS ANOTHER NOTE			*/			/*		BEFORE OUR CURRENT NOTE. IF NOT		*/			/*		THEN SET THD.ANY.REV BACK TO ZERO	*/			WRITE(MAM)=MSB+NAH.PTR;		/*	POINT TO NLS					*/			WRITE(MAL)=NLS.FP;			/*	LOOK UP PTR TO FIRST NOTE	*/			K=READ(MD);			DO WHILE LSB=K;				/*	AT START OF NLS, GO BACK	*/				WRITE(MAL)=NLS.REV;		/*	AND SEE IF PRIOR NLS EXISTS	*/				IF (READ(MD)=0)				/*	NO MORE NLS BEHIND US	*/				OR (READ(MD)=(I-NAH.PTR))	/*	OR THIS IS THE TRK HEAD	*/				THEN DO;							/*	HAVE TO QUIT				*/					WRITE(MAM)=I;				/*	RESTORE PTR TO TRK HEAD	*/					WRITE(MAL)=THD.ANY.REV;	/*	RESET FLAG TO ZERO		*/					WRITE(MD )=0;				/*	NO MORE NOTES BEHIND US	*/					GOTO DONE.WITH.NOTE;	/*	DON'T MERGE TRK BACK ONTO EVENT LIST	*/				END;				MSB=READ(MD);				/*	GET PTR TO PRIOR NLS	*/				WRITE(MAM)=NAH.PTR+MSB;	/*	LOOK UP PTR TO FIRST NOTE	*/				WRITE(MAL)=NLS.FP;		/*	LOOK UP NEW PTR TO FIRST NOTE	*/				K  =READ(MDI);				/*	READ IT THEN STEP TO NLS.LP VAR	*/				LSB=READ(MD );				/*	LSB=NLS.LP (PTR TO LAST NOTE IN NLS)	*/			END;			/*	10. THERE IS ANOTHER PRIOR NOTE.		*/			/*		 IF NOTE IS AN ALTERNATE FORMAT	*/			/*		 REST RECORD THEN SUBTRACT THE	*/			/*		 EXTRA REST FROM OUR CURRENT		*/			/*		 LAST EVENT TIME AND STORE			*/			/*		 BACK IN THE TRK HEADER				*/			WRITE(MAL)=LSB-1;					/*	POINT AT LAST WD OF PRIOR RECORD	*/			IF (READ(MD)&"77")=VEL.NOTE	/*	PRIOR NOTE IS A 4-WD RECORD	*/			THEN DO;								/*	MIGHT BE ALT. FORMAT REST	*/				/*	11A. LOOK AT PRIOR NOTE AND SEE IF	*/				/*	IT IS AN ALTERNATE FORMAT REST NOTE	*/				WRITE(MAL)=LSB-4;				/*	POINT TO START OF PRIOR NOTE	*/				IF (READ(MDI)&"174001")="100001"	/*	AN ALT FORMAT REST NOTE	*/				THEN DO;							/*	SUBTRACT EXTRA DELTA FROM LAST EVENT TIME	*/					W2=READ(MDI);				/*	READ EXTRA DELTA INTO TEMPS	*/					W3=READ(MDI);				/*	W2 HOLDS MSB, W3 HOLDS LSB		*/					WRITE(MAM)=I;				/*	RESTORE PTR TO TRK HEADER		*/					WRITE(MAL)=THD.LMSB;		/*	COMPUTE NEW LAST EVENT TIME	*/					WRITE(MDI)=READ(MD)-W2;	/*	SUBTRACT MSB FROM THD.LMSB			*/					IF READ(MD) ILT W3		/*	WILL NEED TO BORROW FOR SUBTRACT	*/					THEN DO;						/*	FULL 32-BIT SUBTRACT W/BORROW		*/						WRITE(MAL)=THD.LMSB;						WRITE(MDI)=READ(MD)-1;	/*	DECREMENT THD.LMSB		*/					END;					WRITE(MD)=READ(MD)-W3;	/*	NORMAL SUBTRACT FROM THD.LLSB	*/				END;								/*	OF HANDLE ALT FORMAT REST NOTE	*/			END;									/*	OF SEE IF PRIOR REC IS ALT FORMAT REST	*/			ELSE DO;				/*	11B. IF NOT A 4-WORD RECORD THEN	*/				/*		  DON'T BOTHER LOOKING AT IT	*/				/*		  SINCE IT COULD NOT BE AN		*/				/*		  ALTERNAT FORMAT REST NOTE	*/			END;			/*	12. MERGE TRK BACK INTO THE EVENT QUEUE	*/			CALL REVERSE.MERGE.INTO.EVENT.QUEUE(I);	/*	PUT TRK BACK INTO LIST	*/			DONE.WITH.NOTE:		END;									/*	OF LOOP WHILE NOTES TO PROCESS NOW	*/	END SCAN.SEQUENCER.BACKWARDS;	/*	MAKE SURE PRIOR CLICK IS COMPUTED CORRECTLY	*/	/*	COMPUTE CURRENT SEQUENCER TIME	*/	CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),													LOC(ADDR(MSB)));	//	Do the following so that if we're on an even click, NEXT.CLICK.MSB,LSB	//	will be the one we're on, and PRIOR.CLICK.MSB,LSB will be the one before.	if (MSB\LSB) ine 0 then call sub16(1,loc(addr(MSB)));		/*	AND COMPUTE PRIOR CLICK	*/	CALL MAP.SEQUENCE.TIME.TO.NEAREST.CLICKS(LOC(ADDR(MSB)),														  LOC(ADDR(PRIOR.CLICK.MSB)),														  LOC(ADDR(NEXT.CLICK.MSB)));	CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(PRIOR.CLICK.MSB)),													LOC(ADDR(REAL.TIME.OF.PRIOR.CLICK.MSB)));	DO FOREVER;	/*	WE WILL LOOP HERE UNTIL WE HIT TARGET TIME	*/		/*	THE FIRST THING TO DO IS TO FIGURE OUT HOW	*/		/*	FAR WE CAN BACK UP THE SEQUENCER PLAY TIME	*/		/*	IN THIS ITERATION OF THE LOOP.  THE TIME		*/		/*	WE BACK UP TO CAN BE LIMITED BY EITHER THE	*/		/*	NEXT CLICK TIME, THE NEXT NOTE TIME, OR		*/		/*	THE TARGET TIME WE ARE BACKING UP TO.			*/		/*	COMPUTE THE 32-BIT TIME AT WHICH		*/		/*	THE NEXT CLICK WILL OCCUR				*/		/*	INITIALLY ASSUME THIS IS THE TIME	*/		/*	OF THE NEXT EVENT TO BE PROCESSED	*/		MSB = REAL.TIME.OF.PRIOR.CLICK.MSB;		LSB = REAL.TIME.OF.PRIOR.CLICK.LSB;		/*	BACK UP BY MIN.ADV TO ASSURE MOVEMENT	*/		IF LSB>PLAY.TIME.LSB-MIN.ADV		THEN DO;			LSB=PLAY.TIME.LSB-MIN.ADV;			MSB=PLAY.TIME.MSB;			IF PLAY.TIME.LSB ILT MIN.ADV THEN DO;				IF MSB=0 THEN LSB=0;				/*	LIMIT TO 0.000			*/				ELSE MSB=MSB-1;					/*	ELSE WRAP				*/			END;		END;		IF ((TIME.MSB IGT MSB))					/*	FINALLY LIMIT BACK UP	*/		OR ((TIME.MSB  =  MSB)					/*	AMOUNT TO THE TARGET		*/		AND (TIME.LSB IGT LSB))					/*	TIME WE WERE PASSED		*/		THEN DO;										/*	ABOVE							*/			MSB=TIME.MSB;			LSB=TIME.LSB;		END;		MOVED = 0;									/*	ASSUME NO MOVEMENT		*/		IF SAMP.SPEED<2 THEN DO;				/*	.000, .001 - SPECIAL		*/			IF (PLAY.TIME.MSB <> MSB)			OR (PLAY.TIME.LSB <> LSB)			OR (PLAY.TIME.ACU <>   0)			THEN MOVED =1 ;			PLAY.TIME.MSB=MSB;					/*	GO THERE IMMEDIATELY			*/			PLAY.TIME.LSB=LSB;					/*	MATH BELOW WOULD BLOW UP	*/			PLAY.TIME.ACU=0;						/*	ACCUM WOULD HIT ZERO			*/			NEW.MOTION   =1;						/*	TELL LOD ABOUT IT				*/		END;		ELSE DO;										/*	CAN USE DIVIDE					*/			LOAD  PLAY.TIME.LSB-LSB;			/*	GET X MSEC TO BACK UP		*/			ULOAD PLAY.TIME.ACU;					/*	LSB'S								*/			MUL   1000;								/*	= Y MICROSECONDS TO ADV		*/			DO WHILE URES IGE SAMP.SPEED;		/*	WATCH FOR OVERFLOW ON DIV	*/				MOVED = 1;							/*	SOME MOVEMENT HERE			*/				LOAD 0;								/*	MOVE AS FAR AS WE CAN		*/				ULOAD SAMP.SPEED-1;				/*	WITHOUT OVERFLOW HERE		*/				DIV SAMP.SPEED;					/*	CAN MOVE THAT MANY			*/				LOAD RES; MUL SAMP.SPEED;		/*	INTEGER # OF SAMP.SPEEDS	*/				MWAIT; DIV 1000;				PLAY.TIME.ACU=PLAY.TIME.ACU-REM;				IF PLAY.TIME.ACU<0 THEN DO;					PLAY.TIME.LSB=PLAY.TIME.LSB-1;					IF PLAY.TIME.LSB=(-1) THEN PLAY.TIME.MSB=PLAY.TIME.MSB-1;					PLAY.TIME.ACU=PLAY.TIME.ACU+1000;				END;				IF PLAY.TIME.LSB ILT RES				THEN PLAY.TIME.MSB=PLAY.TIME.MSB-1;				PLAY.TIME.LSB=PLAY.TIME.LSB-RES;				LOAD  PLAY.TIME.LSB-LSB;		/*	GET X MSEC TO ADVANCE	*/				ULOAD PLAY.TIME.ACU;				/*	LSB'S							*/				MUL   1000;							/*	= Y MICROSECONDS TO ADV	*/			END;			DIV SAMP.SPEED;			IF RES<>0 THEN MOVED = 1;			/*	SOME MOVEMENT				*/			LOAD RES; MUL SAMP.SPEED;			MWAIT; DIV 1000;			PLAY.TIME.ACU=PLAY.TIME.ACU-REM;			IF PLAY.TIME.ACU<0 THEN DO;				PLAY.TIME.LSB=PLAY.TIME.LSB-1;				IF PLAY.TIME.LSB=(-1) THEN PLAY.TIME.MSB=PLAY.TIME.MSB-1;				PLAY.TIME.ACU=PLAY.TIME.ACU+1000;			END;			IF PLAY.TIME.LSB ILT RES			THEN PLAY.TIME.MSB=PLAY.TIME.MSB-1;			PLAY.TIME.LSB=PLAY.TIME.LSB-RES;			NEW.MOTION   =1;						/*	TELL LOD ABOUT IT			*/		END;		IF CODE = 1		THEN CALL SCAN.SEQUENCER.BACKWARDS(PLAY.TIME.MSB,PLAY.TIME.LSB);		IF  (PLAY.TIME.LSB<=REAL.TIME.OF.PRIOR.CLICK.LSB)	/*	TIME TO GENERATE NEXT	*/		THEN DO;															/*	CLICK							*/			CALL COPY32(LOC(ADDR(REAL.TIME.OF.PRIOR.CLICK.MSB)),	/*	BACK UP ONE CLICK	*/							LOC(ADDR(REAL.TIME.OF.NEXT.CLICK.MSB)));			IF  (REAL.TIME.OF.NEXT.CLICK.MSB = 0)						/*	NEVER LET TIME OF NEXT CLICK	*/			AND (REAL.TIME.OF.NEXT.CLICK.LSB ILT ZERO.TIME)			/*	BACKUP UP TO BEFORE ZERO.TIME	*/			THEN REAL.TIME.OF.NEXT.CLICK.LSB = ZERO.TIME;			/*	COMPUTE CURRENT SEQUENCER TIME	*/			CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),															LOC(ADDR(MSB)));			/*	Do this so that if we're on an even click, NEXT.CLICK.MSB,LSB will be	*/			/*	the one we're on, and PRIOR.CLICK.MSB,LSB will be the one before.			*/			if com16(0,loc(addr(MSB))) <> lw#ieq		/*	Prevent rewind into oblivion	*/			then call sub16(1,loc(addr(MSB)));			/*	COMPUTE PRIOR CLICK FOR NEXT TIME THRU	*/			CALL MAP.SEQUENCE.TIME.TO.NEAREST.CLICKS(LOC(ADDR(MSB)),																  LOC(ADDR(PRIOR.CLICK.MSB)),																  LOC(ADDR(NEXT.CLICK.MSB)));			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(PRIOR.CLICK.MSB)),															LOC(ADDR(REAL.TIME.OF.PRIOR.CLICK.MSB)));		END;		if click.track.mode igt 3		then do;		/* LIVE CLICK */			/*	Note: The previous call to SCAN.SEQUENCER.BACKWARDS calls REWIND.TRACK.CLICK.CHECK	*/			/*	which keeps LAST.CLICK, NEXT.CLICK, EST.RATE and BEAT.NUMBER up to date - BUT ONLY	*/			/*	while there are notes to scan on the click track.  Consequently, if we are backing	*/			/*	up from sufficiently beyond the last note on the click track, we'll have to use the */			/*	non-real-time live click mapping procedure to properly set these variables.			*/				IF (PLAY.TIME.LSB <= LAST.CLICK)			THEN DO;				if TRIGGER.CLICK<>0				then do;	/*	(TRIGGER.CLICK<>0) means we haven't yet scanned a note off the click track.	*/					/* We have to determine all the variables from scratch - the slow way. */					call SET.CLICK.TRACK.VARIABLES;					NEW.BEAT.NUMBER = True;		/* Tell :06-MAIN:325-NEW to update the VK window.	*/				end;				else do;	/*	(TRIGGER.CLICK = 0) means we can rely on REWIND.TRACK.CLICK.CHECK from here on.	*/				end;			END;		end;		else do;		/* INT OR EXT CLICK */			IF (PLAY.TIME.LSB <= REAL.TIME.OF.PRIOR.BEAT.LSB) THEN NEW.BEAT.NUMBER = True;		end;		/*	ARE WE THERE YET?  ARE WE THERE YET?  ARE WE THERE YET?  ARE WE THERE YET?	*/		IF MOVED = 0 THEN RETURN;		/*	REACHED LIMIT	*/	END;										/*	OF LOOP UNTIL WE GET TO TARGET TIME	*/END BACKUP.SEQUENCER.SUBROUTINE;/*	DRIVER ROUTINE GERNERALLY USED:	*/BACKUP.SEQUENCER: PROC (TIME.MSB,TIME.LSB) PUBLIC SWAPABLE;	/*	REWINDS SEQUENCER IN NON-REAL TIME	*/	DCL (TIME.MSB, TIME.LSB) FIXED;	CALL BACKUP.SEQUENCER.SUBROUTINE(TIME.MSB, TIME.LSB, 1);END BACKUP.SEQUENCER;