/*	:SYNRSOU:04-SEQ:160SEQ0A  $TITLE  MORE SEQUENCER ROUTINES	*//*Modified:1990/08/28 - PF  - Split this file off from 160-seq0*//*	$PAGE - NOTE PROCESSING/EDITING SUBROUTINES					*//*	GLOBALS USED BY SEVERAL MAJOR SEQUENCER ROUTINES:			*//*		MAKE USE OF THESE TO AVOID EXTRA VARS, AND TO			*//*		REDUCE PROCEDURE CALL OVERHEAD.  PUT DCLS INTO			*//*		ROUTINES WHICH WANT TO USE THEM AS "FIXED EXTERNAL"	*//*		THESE VARS SHOULD GENERALLY NOT BE USED AS TEMPS IN	*//*		ROUTINES, UNLESS YOU PLAN TO PASS THE INFO TO OTHER	*//*		PROCEDURES.  BE ESPECIALLY CAREFUL THAT THE VARS		*//*		HOLD THE CORRECT VALUES WHEN RETURNING FROM PROCS.		*//*		BEWARE OF ROUTINES WHICH ASSUME THE VARS WILL NOT		*//*		ALTERED BY OTHER PROCEDURE CALLS.							*//*	NOTE: KEEP #TRK - #LSB IN ORDER!!  DON'T MESS WITH THEM	*//*	SERIOUSLY! - DON'T EVEN LOOK AT THEM!!!						*/DCL (#TRK)					FIXED PUBLIC;	/*	ABS TRK NUMBER ACTION IS TO TAKE PLACE ON	*/DCL (#PTR)					FIXED PUBLIC;	/*	ABS PTR TO TRACK HEAD	*//*	NOTE: ORDER OF #NMSB - #ANYR MUST MATCH TRACK HEAD	*/DCL (#NMSB,#NLSB)			FIXED PUBLIC;	/*	NEXT TIME CORRESPONDING TO PTR	*/DCL (#LMSB,#LLSB)			FIXED PUBLIC;	/*	LAST TIME CORRESPONDING TO PTR	*/DCL (#WRD,#SEC)			FIXED PUBLIC;	/*	RELATIVE PTR INTO NAH AREA AT WHICH ACTION OCCURS	*/DCL (#ANYF,#ANYR)			FIXED PUBLIC;	/*	ANY REV & FOR FOR THIS POINT		*/DCL (#W1,#W2,#W3,#W4)	FIXED PUBLIC;	/*	4 WORDS TO HOLD A NOTE RECORD		*/DCL (#MSB,#LSB)			FIXED PUBLIC;	/*	GENERAL 32-BIT VALUE TO PASS OR RETURN	*/DCL (#RMSB)					FIXED PUBLIC;	/*	HANDY TEMP TO HOLD REAL TIME OF	*/DCL (#RLSB)					FIXED PUBLIC;	/*	NOTE (CORRESPONDS TO #NMSB,LSB)	*//*	LOOK UP #W1,#W2,#W3,#W4 FROM CURRENT NOTE RECORD	*//*	ONLY CALL WHEN #ANYF<>0  (I.E. POINTING TO			*//*	A REAL NOTE, AS OPPOSED TO END OF TRACK)				*/STORE.NOTE.INFO: PROC PUBLIC;	write(mam)=nah.ptr+#sec;	/*	look at note record		*/	write(mal)=#wrd;	write("313")=addr(#w1);		/*	save addr of #w1		 in reg for speed	*/	write("300")=read("353");	write(mdi)=read("373");	write(mdi)=read("373");	if read("300") then do;		/*	this is a 4-word record	*/		write(mdi)=read("373");		write(mdi)=read("353");	end;END STORE.NOTE.INFO;LOOK.UP.NOTE.INFO:  PROC PUBLIC;	/*	loads note at (#sec,#wrd) into #w1-#w4	*/	write(mam)=nah.ptr+#sec;	/*	look at note record		*/	write(mal)=#wrd;	write("313")=addr(#w1);		/*	save addr of #w1		 in reg for speed	*/	write("300")=read(md);		/*	save 1st word of note in reg for speed	*/	write("373")=read(mdi);		/*	1st word into #w1			*/	write("373")=read(mdi);		/*	2nd word into #w2			*/	if read("300") then do;		/*	this is a 4-word record	*/		write("373")=read(mdi);	/*	3rd word into #w3			*/		write("353")=read(mdi);	/*	4th word into #w4			*/	end;	else do;		write("373")=rte.max;	/*	rte.max  into #w3			*/		write("353")=vel.note;	/*	vel.note into #w4			*/	end;END LOOK.UP.NOTE.INFO;/*	this routine returns true if the note in #w1, #w2, #w3, #w4 is a	2 or 4 word  rest note record. It assumes #w1-#w4 are set up already	*/ISA.REST.NOTE: proc public;	if ((#w1 & "174001") = "100001")						/*	extended rest note	*/	or ((#w1 >= 0) and ((#w2 & "77") = rest.note))	/*	regular rest note		*/	then return(true);	else return(false);end ISA.REST.NOTE;/*	this routine returns true if the note in #w1, #w2, #w3, #w4 is a	rte update note record. It assumes #w1-#w4 are set up already	*/ISA.RTE.NOTE: proc public;	if ((#w1) & ((#w3 & shl(b.upd,8)) <> 0))	then return(true);	else return(false);end ISA.RTE.NOTE;/*	this routine returns true if the note in #w1, #w2, #w3, #w4 is a	 ilp.start or ilp.end note record.  It assumes #w1-#w4 are set up already	*/ISA.ILP.NOTE: proc public;	if (((#w1 & "174001") = "104001")	or  ((#w1 & "174001") = "110001"))	then return(true);	else return(false);end ISA.ILP.NOTE;/*	this routine returns true if the note in #w1, #w2, #w3, #w4 is a	"normal" note or an ilp start or end. It assumes #w1 - #w4 have been	set up already.	*/ISA.NORMAL.OR.ILP.NOTE: proc fixed public;	if (isa.rest.note\isa.rte.note) then return false;	else											 return true;end ISA.NORMAL.OR.ILP.NOTE;/*	$PAGE	*//*	BACKUP.TO.PRIOR.NOTE RETURNS 0 IF YOU BACK UP TO THE		*//*	START OF THE GIVEN TRACK.  OTHERWISE IT RETURNS A 1.		*//*	ROUTINE ASSUMES (#SEC,#WRD) POINT TO A NOTE OR NLS.EOS.	*//*	PASSED AN ABSOLUTE PTR TO THE TRK HEAD. SET UP				*//*	(#SEC,#WRD) BEFORE CALLING ROUTINE. IF ABLE TO BACK UP,	*//*	(#SEC,#WRD) POINT TO PRIOR NOTE. OTHERWISE (#SEC,#WRD)	*//*	WILL POINT AT THE FIRST NOTE ON THE TRACK.					*/BACKUP.TO.PRIOR.NOTE: PROC	FIXED PUBLIC;	DCL K				FIXED;	DCL (SEC,WRD)	FIXED;	LOOK.AT.PRIOR.NOTE:PROC;		WRITE(MAM)=NAH.PTR+SEC;		/*	POINT TO CURRENT NLS					*/		WRITE(MAL)=NLS.FP;			/*	LOOK UP PTR TO 1ST WORD IN NLS	*/		K=READ(MD);						/*	SAVE IN TEMP							*/		DO WHILE WRD=K;				/*	AT START OF NLS, GO BACK			*/			WRITE(MAL)=NLS.REV;		/*	AND SEE IF PRIOR NLS EXISTS		*/			IF READ(MD)=(#PTR-NAH.PTR)	/*	BACKING UP TO THE TRK HEAD		*/			THEN DO;							/*	HAVE TO QUIT						*/				WRITE(MAM)=NAH.PTR+SEC;	/*	POINT AT FIRST NOTE IN TRACK	*/				WRITE(MAL)=WRD;				RETURN 0;					/*	HIT START OF TRACK - BOMB OUT	*/			END;			SEC=READ(MD);				/*	SAVE PTR TO PRIOR NLS IN GLOBAL	*/			WRITE(MAM)=NAH.PTR+SEC;	/*	POINT TO PRIOR NLS					*/			WRITE(MAL)=NLS.FP;		/*	GET PTR TO FIRST WORD IN NLS		*/			K	=READ(MDI);				/*	READ IT THEN STEP TO NLS.LP VAR	*/			WRD=READ(MD );				/*	PTR TO LAST WORD IN NLS IN GLOBAL	*/		END;		WRITE(MAL)=WRD-1;				/*	BACK UP TO LAST WORD OF NOTE	*/		IF (READ(MD)&"77")=VEL.NOTE	/*	HAVE A 4-WORD RECORD			*/		THEN WRD=WRD-4;		ELSE WRD=WRD-2;		WRITE(MAL)=WRD;				/*	AND POINT TO IT					*/		RETURN 1;	END LOOK.AT.PRIOR.NOTE;	/*	$PAGE	*/	WRD=#WRD; SEC=#SEC;			/*	START HERE	*/	IF LOOK.AT.PRIOR.NOTE=0		/*	NO NOTE		*/	THEN RETURN 0;	/*	AT THIS POINT, (#SEC,#WRD) ARE POINTING AT THE PRIOR	*/	/*	NOTE ON THE TRACK. AND THE MAM AND MAL PTRS ARE ALL	*/	/*	SET UP TO BEGIN READING.										*/	#WRD=WRD; #SEC=SEC;			/*	GO THERE						*/	#ANYF=1;							/*	NOTE IN FRONT OF US		*/	#NMSB=#LMSB;					/*	NEXT TIME IS LAST TIME	*/	#NLSB=#LLSB;	K=SHR(READ(MD),1)&1023;		/*	GET DELTA					*/	IF #LLSB ILT K					/*	COMPUTE NEW LAST TIME	*/	THEN #LMSB=#LMSB-1;	#LLSB=#LLSB-K;	IF LOOK.AT.PRIOR.NOTE<>0	/*	SEE IF LONG REST RECORD	*/	THEN DO;							/*	ONE BEHIND US	*/		#ANYR=1;		IF (READ(MDI)&"174001")="100001"		THEN DO;						/*	LONG REST		*/			#LMSB=#LMSB-READ(MDI);			IF #LLSB ILT READ(MD)			THEN #LMSB=#LMSB-1;			#LLSB=#LLSB-READ(MD);		END;	END;	ELSE DO;		#ANYR=0;						/*	NO NOTE			*/	END;	WRITE(MAM)=NAH.PTR+#SEC;	/*	RESET POINTERS TO NOTE	*/	WRITE(MAL)=#WRD;	RETURN 1;						/*	WAS ABLE TO BACK UP		*/END BACKUP.TO.PRIOR.NOTE;/*	BACK UP TO A REAL NOTE (OR ILS/ILE)	*//*	USED MOSTLY FROM RECORDER DISPLAY	*/BACKUP.TO.PRIOR.REAL.NOTE: PROC FIXED PUBLIC;	do while (1);		if #anyr = 0 then return;					/*	first note		*/		call backup.to.prior.note;					/*	move back one note record	*/		/*	no need to check #anyf here since	*/		/*	we just backed up a note				*/		call look.up.note.info;						/*	load #w1 - #w4	*/		if isa.normal.or.ilp.note then return;	/*	check which type of record we have & return if a real or ilp note	*/	end;end BACKUP.TO.PRIOR.REAL.NOTE;/*	$PAGE	*//*	ADVANCE.TO.NEXT.NOTE RETURNS 0 IF YOU ADVANCE TO THE		*//*	END OF THE GIVEN TRACK.  OTHERWISE IT RETURNS A 1.			*//*	ROUTINE ASSUMES (#SEC,#WRD) POINT TO A NOTE OR NLS.EOS	*//*	SET UP (#SEC,#WRD) BEFORE CALLING ROUTINE.					*//*	IF ROUTINE ADVANCES, (#SEC,#WRD) POINT TO NEXT NOTE.		*//*	OTHERWISE (#SEC,#WRD) WILL POINT AT THE NLS.EOS AT THE	*//*	END OF THE TRACK.														*/ADVANCE.TO.NEXT.NOTE: PROC FIXED PUBLIC;	DCL (K) FIXED;	WRITE(MAM)=NAH.PTR+#SEC;		/*	POINT TO NOTE AT CURRENT POS	*/	WRITE(MAL)=#WRD;	IF READ(MD)<>NLS.EOS THEN DO;	/*	POINTING AT A REAL NOTE	*/		#ANYR=1;							/*	ONE BEHIND US FOR SURE	*/		#LMSB=#NMSB;					/*	LAST TIME IS NEXT TIME	*/		#LLSB=#NLSB;		IF (READ(MDI)&"174001")="100001"		THEN DO;							/*	LONG REST	*/			#NMSB=#NMSB+READ(MDI);			#NLSB=#NLSB+READ(MD);			IF #NLSB ILT READ(MD)			THEN #NMSB=#NMSB+1;			WRITE(MAL)=READ(MAL)-2;		END;		ELSE WRITE(MAL)=READ(MAL)-1;		IF READ(MD)						/*	ADVANCE OVER CURRENT NOTE	*/		THEN #WRD=#WRD+4;				/*	4-WORD RECORD				*/		ELSE #WRD=#WRD+2;				/*	2-WORD RECORD				*/		WRITE(MAL)=#WRD;				/*	POINT AT THE NOTE			*/	END;	DO WHILE READ(MD)=NLS.EOS;		/*	AT END OF THIS NLS		*/		WRITE(MAL)=NLS.FOR;			/*	GET THE FORWARD PTR		*/		IF READ(MD)=0					/*	NO MORE NOTE SEGS ON TRACK	*/		THEN DO;							/*	HIT END OF TRACK - BOMB OUT	*/			WRITE(MAM)=NAH.PTR+#SEC;	/*	POINT AT NLS.EOS AT END OF TRACK	*/			WRITE(MAL)=#WRD;			#ANYF=0;						/*	NOT POINTING TO NOTE		*/			RETURN 0;		END;		#SEC=READ(MD);					/*	UPDATE INTO GLOBAL		*/		WRITE(MAM)=NAH.PTR+#SEC;	/*	SET PTR TO NEXT NLS		*/		WRITE(MAL)=NLS.FP;			/*	GET PTR TO FIRST WORD IN NLS	*/		#WRD=READ(MD);					/*	UPDATE INTO GLOBAL		*/		WRITE(MAL)=#WRD;				/*	AND POINT TO IT			*/	END;	/*	AT THIS POINT, (#SEC,#WRD) ARE POINTING AT THE NEXT	*/	/*	NOTE ON THE TRACK. AND THE MAM AND MAL PTRS ARE ALL	*/	/*	SET UP TO BEGIN READING.										*/	K=SHR(READ(MD),1)&1023;			/*	GET DELTA					*/	#NLSB=#NLSB+K;						/*	ADD TO NEXT TIME			*/	IF #NLSB ILT K						/*	CARRY							*/	THEN #NMSB=#NMSB+1;	RETURN 1;							/*	WAS ABLE TO ADVANCE	*/END ADVANCE.TO.NEXT.NOTE;ADVANCE.TO.NEXT.REAL.NOTE: PROC	FIXED PUBLIC;	if #anyf = 0 then return;						/*	end of track has been reached already	*/	do while (1);		call advance.to.next.note;					/*	advance one note record	*/		if #anyf = 0 then return;					/*	end of track reached		*/		call look.up.note.info;						/*	load #w1 - #w4				*/		if isa.normal.or.ilp.note then return;	/*	check which type of record we have & return if a real or ilp note	*/	end;end ADVANCE.TO.NEXT.REAL.NOTE;/*	$SUBROUTINES - LOAD AND STORE PLAY INFO	*//*	loads up the above globals with the CURRENT PLAY INFO given a particular	track number...doesn't affect #w1 - #w4 or #msb, #lsb	*/LOAD.SEQ.GLOBALS: proc(trk) public swapable;	dcl trk	fixed;	#trk=trk;	if #trk<>0 then do;			/*	track is selected				*/		write(mam) = trk.head;	/*	track header area				*/		write(mal) = #trk;		/*	load absolute track#			*/		#ptr = read(md);			/*	point to track header for this track	*/		if #ptr<>0 then do;		/*	if track exists...			*/			/*	sample current play info into variables			*/			write(mam) = #ptr;			WRITE(MAL)=THD.NMSB;			/*	READ IN SOME CURRENT PLAY INFO	*/			#NMSB=READ(MDI);				/*	SAVE THD.NMSB	  IN GLOBAL	*/			#NLSB=READ(MDI);				/*	SAVE THD.NLSB	  IN GLOBAL	*/			#LMSB=READ(MDI);				/*	SAVE THD.LMSB	  IN GLOBAL	*/			#LLSB=READ(MDI);				/*	SAVE THD.LLSB	  IN GLOBAL	*/			#WRD =READ(MDI);				/*	SAVE THD.WRD	  IN GLOBAL	*/			#SEC =READ(MD );				/*	SAVE THD.SEC	  IN GLOBAL	*/			WRITE(MAL)=THD.ANY.FOR;			#ANYF=READ(MDI);				/*	SAVE THD.ANY.FOR IN GLOBAL	*/			#ANYR=READ(MDI);				/*	SAVE THD.ANY.REV IN GLOBAL	*/		end;		else return 0;	end;	else return 0;	return 1;end LOAD.SEQ.GLOBALS;/*	STORE THE # VARIABLES BACK IN THE TRACK HEAD:	*/STORE.#.INFO:PROC(PTR) PUBLIC;	DCL (PTR) FIXED;	WRITE(MAM)=#PTR;	WRITE(MAL)=PTR;	WRITE("313")=ADDR(#NMSB);	/*	SET UP REG FOR SPEED	*/	IF INC.POLY THEN DO;		RPC 6;		WRITE(MDI)=READ("373");	/*	COPY EDIT INFO INTO TRK HEAD PLAY INFO	*/		/*	COPY EDIT #NMSB OVER THD.NMSB OR THD.NMSB	*/		/*	COPY EDIT #NLSB OVER THD.NLSB OR THD.NLSB	*/		/*	COPY EDIT #LMSB OVER THD.LMSB OR THD.LMSB	*/		/*	COPY EDIT #LLSB OVER THD.LLSB OR THD.LLSB	*/		/*	COPY EDIT #WRD  OVER THD.WRD  OR THD.WRD	*/		/*	COPY EDIT #SEC  OVER THD.SEC  OR THD.SEC	*/	END;	ELSE DO;		WRITE(MDI)=READ("373"); WRITE(MDI)=READ("373");		WRITE(MDI)=READ("373"); WRITE(MDI)=READ("373");		WRITE(MDI)=READ("373"); WRITE(MDI)=READ("373");	END;	IF PTR=THD.NMSB THEN WRITE(MAL)=THD.ANY.FOR;	ELSE				 WRITE(MAL)=THD.LP.ANY.FOR;	WRITE("313")=ADDR(#ANYF);	/*	SET UP REGISTER FOR SPEED	*/	WRITE(MDI)=READ("373");		/*	COPY EDIT #ANYF OVER THD.ANY.FOR OR THD.LP.ANY.FOR	*/	WRITE(MD )=READ("353");		/*	COPY EDIT #ANYR OVER THD.ANY.REV OR THD.LP.ANY.REV	*/END STORE.#.INFO;LOAD.#.INFO:PROC(PTR) PUBLIC;	/*	COPIES FROM TRK HEAD INTO # VARS - MAKE SURE #PTR IS SET BEFORE CALLING	*/	DCL (PTR) FIXED;	WRITE(MAM)=#PTR;	WRITE(MAL)=PTR;	WRITE("313")=ADDR(#NMSB);	/*	SET UP REG FOR SPEED	*/	IF INC.POLY THEN DO;		RPC 6;		WRITE("373")=READ(MDI);	/*	COPY TRK INFO INTO # VARS	*/		/*	STORE THD.NMSB OR THD.LP.NMSB INTO #NMSB	*/		/*	STORE THD.NLSB OR THD.LP.NLSB INTO #NLSB	*/		/*	STORE THD.LMSB OR THD.LP.LMSB INTO #LMSB	*/		/*	STORE THD.LLSB OR THD.LP.LLSB INTO #LLSB	*/		/*	STORE THD.WRD  OR THD.LP.WRD  INTO #WRD	*/		/*	STORE THD.SEC  OR THD.LP.SEC  INTO #SEC	*/	END;	ELSE DO;		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	END;	IF PTR=THD.NMSB THEN WRITE(MAL)=THD.ANY.FOR;	ELSE                 WRITE(MAL)=THD.LP.ANY.FOR;	WRITE("313")=ADDR(#ANYF);	/*	SET UP REGISTER FOR SPEED	*/	WRITE("373")=READ(MDI);		/*	STORE THD.ANY.FOR OR THE.LP.ANY.FOR INTO #ANYF	*/	WRITE("353")=READ(MD );		/*	STORE THD.ANY.REV OR THD.LP.ANY.REV INTO #ANYR	*/END LOAD.#.INFO;/*	$SUBTITLE  ROUTINES TO INCREMENT AND DECREMENT # OF NOTES ON TRK	*/INCREMENT.NUM.NOTES: PROC PUBLIC;	/*	ASSUMES #PTR IS VALID	*/		WRITE(MAM)=#PTR;					/*	UPDATE TRACK HEAD			*/		WRITE(MAL)=THD.NN.LSB;			/*	ONE MORE NOTE				*/		WRITE(MD )=READ(MD)+1;		IF READ(MD)=0 THEN DO;			WRITE(MAL)=THD.NN.MSB;			WRITE(MD )=READ(MD)+1;		END;END INCREMENT.NUM.NOTES;DECREMENT.NUM.NOTES: PROC PUBLIC;	/*	USE TO DEC NUMBER OF NOTES ON A TRACK	*/	WRITE(MAM)=#PTR;						/*	ASSUMES #PTR IS VALID	*/	WRITE(MAL)=THD.NN.LSB;				/*	ONE LESS NOTE				*/	IF READ(MD)=0 THEN DO;				/*	NEED TO BORROW				*/		WRITE(MAL)=THD.NN.MSB;		WRITE(MD)=READ(MD)-1;		IF READ(MD)<0						/*	WE PROBABLY HAVE A SERIOUS BUG HERE	*/		THEN WRITE(MD)=0;					/*	AT LEAST LIMIT NUM NOTES TO ZERO		*/		ELSE DO;			WRITE("324")=READ(MDI);			WRITE(MD )=(-1);				/*	AFTER BORROW, NORMAL DECREMENT	*/		END;	END;	ELSE WRITE(MD)=READ(MD)-1;			/*	DID NOT BORROW, NORMAL DECREMENT	*/END DECREMENT.NUM.NOTES;/*	$SUBTITLE - TRACK.CLICK.CHECK IS CALLED WHEN 3 CONDITIONS ARE MET:	1. A RECORDED TRACK IS BEING USED AS A CLICK TRACK	2. WE ARE JUST SCANNING A NOTE FROM THAT TRACK	3. AND WE ARE MOVING FORWARD.	THIS ROUTINE WILL SET UP A CORRECT BEAT NUMBER FOR THE CLICK AND MAKE IT HAPPEN.*/TRACK.CLICK.CHECK:PROC SWAPABLE;	DCL (NEW.EST.RATE) FIXED;	FIND.NEXT.CLICK.NOTE:PROC;		DCL (LOOP.SCANNED ) FIXED;		LOOP.SCANNED = 0;								/*	DETECT EMPTY INDEP LOOP	*/		MORE:;		CALL ADVANCE.TO.NEXT.REAL.NOTE;		IF #ANYF=0 THEN RETURN;						/*	END OF CLICK TRACK		*/		#W1=#W1 & "174001";							/*	EXTRACT NOTE TYPE			*/		IF #W1 = "104001" THEN GOTO MORE;		/*	SKIP OVER ILS (FIRST TIME THROUGH)	*/		IF #W1 = "110001" THEN DO;					/*	ILE RECORD					*/			IF LOOP.SCANNED<>0 THEN RETURN;		/*	EMPTY INDEP LOOP			*/			LOOP.SCANNED = 1;			WRITE(MAM)=#PTR;			WRITE(MAL)=THD.ILS.WRD;			#WRD = READ(MDI);			#SEC = READ(MD );			IF #SEC=0 THEN RETURN;					/*	ILE RECORD WITH NO ILS?	*/			GOTO MORE;		END;		call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), loc(addr(#RMSB)));		IF #RLSB=LAST.CLICK THEN GOTO MORE;		/*	TREAT JUSTIFIED CHORDS AS ONE NOTE	*/	END FIND.NEXT.CLICK.NOTE;	/*	BEGIN BY LOOKING UP NOTE INFO	*/	/*	FROM TRACK HEAD:					*/	WRITE(MAM)=NEXT.EVENT.QUEUE+NAH.PTR;		/*	POINT TO TRACK HEAD	*/	#PTR = READ(MAM);	WRITE(MAL)=THD.TRK;	#TRK = READ(MD);	CALL LOAD.#.INFO(THD.NMSB);			/*	NOTE: #LMSB,#LLSB ARE WRONG HERE SINCE WE HAVE STARTED TO SKIP OVER THE NOTE	*/	call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), loc(addr(#RMSB)));	IF #RLSB<>LAST.CLICK						/*	ADVANCE BEAT NUMBER IF NOT A CHORD	*/	THEN BEAT.NUMBER=BEAT.NUMBER+1;		/*	INCREMENT BEAT # WHEN NOTE IS SCANNED WHEN USING LIVE TRACK	*/	LAST.CLICK = #RLSB;						/*	SAVE TIME OF YET TO OCCUR "NEXT" AND "LAST" CLICK	*/	CALL FIND.NEXT.CLICK.NOTE;				/*	GET NEXT ONE TO COMPUTE EST.RATE	*/	IF #ANYF <> 0								/*	IF NEXT NOTE EXISTS, GET TIME	*/	THEN NEW.EST.RATE=#RLSB-LAST.CLICK;	/*	TO IT, ELSE LEAVE AT PRIOR		*/	ELSE NEW.EST.RATE=EST.RATE;			/*	RATE.									*/	DISABLE;	IF PTRS.LOOPED=LOOP.RESTART			/*	NORMAL TIME BASE			*/	THEN DO;		NEXT.CLICK=LAST.CLICK;				/*	SET NEXT.CLICK TIME		*/		EST.RATE  =NEW.EST.RATE;			/*	AND EST.RATE				*/		TRIGGER.CLICK = 1 + (#ANYF=0);	/*	TELL INTERRUPT ROUTINE WE ACTUALLY SCANNED A NOTE, AND WHETHER WE ARE AT THE END OF TRACK OR NOT	*/		IF NEXT.CLICK<PLAY.TIME.LSB		/*	BUT WE MIGHT BE LATE HERE USING BEAT SYNC IN OR MIDI SYNC IN AND SOME ONE IS PUSHING THE TEMPO	*/		THEN DO;			EST.RATE=(EST.RATE					 )		/*	MAKE EST.RATE SMALLER IF WE ARE LATE	*/					  -(PLAY.TIME.LSB-NEXT.CLICK);	/*	SO THAT NEXT.CLICK + EST.RATE WILL		*/			IF EST.RATE<0 THEN EST.RATE=0;			/*	EQUAL THE NEXT NEXT CLICK TIME			*/			NEXT.CLICK=PLAY.TIME.LSB;					/*	SET NEXT.CLICK TO BE NORMALIZED			*/		END;	END;	ELSE IF LOOP.RESTART=0 THEN DO;		/*	MEANS PTRS.LOOPED<>0			*/		LOOP.NEXT.CLICK=LAST.CLICK;		/*	SET LOOP.NEXT.CLICK TIME	*/		EST.RATE			=NEW.EST.RATE;		/*	AND EST.RATE					*/		LOOP.TRIG.CLICK=1 + (#ANYF=0);	/*	TELL INTERRUPT ROUTINE WE SCANNED A NOTE	*/		IF LOOP.NEXT.CLICK<LOOP.PLAY.TIME.LSB	/*	BUT WE MIGHT BE LATE HERE USING BEAT SYNC IN OR MIDI SYNC IN AND SOME ONE IS PUSHING THE TEMPO	*/		THEN DO;			EST.RATE=(EST.RATE								  )	/*	MAKE EST.RATE SMALLER IF WE ARE LATE	*/					  -(LOOP.PLAY.TIME.LSB-LOOP.NEXT.CLICK);	/*	SO THAT NEXT.CLICK + EST.RATE WILL		*/			IF EST.RATE<0 THEN EST.RATE=0;		/*	EQUAL THE NEXT NEXT CLICK TIME	*/			LOOP.NEXT.CLICK=LOOP.PLAY.TIME.LSB;	/*	SET NEXT.CLICK TO BE NORMALIZED	*/		END;	END;	ELSE DO;										/*	MEANS LATE - TIME BASE HAS LOOPED BUT POINTERS HAVE NOT - SYNCHRONIZATION IS NOW LOST AFTER OVERALL LOOP	*/		NEXT.CLICK=PLAY.TIME.LSB;			/*	EMIT CLICK HERE	*/		TRIGGER.CLICK = 1 + (#ANYF=0);	/*	TELL INTERRUPT ROUTINE WE ACTUALLY SCANNED A NOTE, AND WHETHER WE ARE AT THE END OF TRACK OR NOT	*/	END;	ENABLE;END TRACK.CLICK.CHECK;