Check.event.queue:proc (code) public;   dcl code fixed;           /* pass diagnostics code               */   DCL (FPTR,RPTR) FIXED;    /* HOLDS FORWARD AND REVERSE LINK PTRS */   dcl prior       fixed;    /* for prior measurement               */   IF NEXT.EVENT.QUEUE = 0 THEN return;  /* que is ok (empty)         */         if (Next.Event.Queue IGE NAH.LEN)     /* oops - cue points outside */   then stop(code);                      /* NAH active area           */   WRITE(MAM)=NAH.PTR+NEXT.EVENT.QUEUE;  /* START AT FRONT OF QUEUE   */   WRITE(MAL)=THD.NEVF;              /* LOOK UP FOR & REV PTRS FOR TRK */   FPTR=READ(MDI);                   /* THD.NEVF                       */   RPTR=READ(MD );                   /* THD.NEVR                       */   if RPTR<>0                        /* if first block has reverse     */   then stop(256+code);              /* pointer, then serious trouble! */   if FPTR IGE NAH.LEN               /* see if first FPTR is bad.      */   then stop(512+code);   if FPTR=0 then return;            /* no fptr - que is good.         */   prior = Next.Event.Queue;         /* save what reverse ptr should B */   WRITE(MAM)=NAH.PTR+FPTR;          /* point to next block            */   NEXT.TRACK:   WRITE(MAL)=THD.NEVF;              /* LOOK UP FOR & REV PTRS FOR TRK */   FPTR=READ(MDI);                   /* THD.NEVF                   */   RPTR=READ(MD );                   /* THD.NEVR                   */   if RPTR <> prior                  /* make sure RPTR points back */   then stop(768+code);              /* to prior block             */   if FPTR IGE NAH.LEN               /* see if FPTR is bad.            */   then stop(1024+code);   if FPTR=0 then return;            /* no fptr - que is good.         */   prior = read(mam) - NAH.PTR;   WRITE(MAM)=NAH.PTR+FPTR;          /* point to next block            */   GOTO NEXT.TRACK;            /* COMPARE OUR NEXT TIME WITH NEXT TRK */end Check.event.queue;