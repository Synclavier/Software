/*	:SYNRSOU:05-BUTT:171-PRF1  $TITLE  Routines for Handling Buttons	*/

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
2000/04/25 - TY  - Replaced floating point math in DISPLAY.CLICK.RATE with equivalent multiple-precision math
						 which runs five times faster
2000/04/16 - TY  - Overhauled frames per beat stuff in DISPLAY.CLICK.RATE
1999/04/22 - TY  - Simplified rounding in non-meter mapped beats/min part of DISPLAY.CLICK.RATE
1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE
1998/06/24 - TY  - Added the variable CLICK.TRACK.FUNCTION to allow the user to select between
						 using a track to generate a tempo map, or using the track as a click track.
					  - Added the variable TOGGLE.CLICKON to facilitate the ergonomic separation
						 of CLICKON and CLICK.TRACK.MODE into independednt parameters.
					  - Added code to PARAMETER.BUTTON to toggle CLICKON if appropriate or to
						 execute selected click track option when the click button is released.
					  - Updated expressions containing (CLICK.TRACK.MODE & 511) to account for
						 the independence of CLICK.TRACK.MODE from CLICKON.
					  - Replaced the math in the frames/beat part of DISPLAY.CLICK.RATE with
						 a simpler and faster implementation.
					  - Corrected rounding in non-meter mapped beats/min part of DISPLAY.CLICK.RATE
						 to work properly with odd values as well as even.
1998/05/18 - TY  - Modified RESET.KEYBOARD.TIMBRE.CONTROL to create a "new timbre on track"
						 system event also when restoring the original timbre to the track.
1991/04/26 - cj  - got rid of sampled.time.of.prior.tempo...
1991/03/15 - CJ  - REALLY !! fixed time signature cursor bug
1991/02/14 - CJ  - Reactivated old click rate display if no tempo map
1991/02/08 - PF  - made DISPLAY.CLICK.RATE public
1991/01/19 - PF  - Increased Tempo resolution to microseconds per beat
1991/01/14 - PF  - Make sure cursor is left in non blink state after editing meter
1991/01/09 - PF  - added routines DISPLAY.CLICK.VALUE, DISPLAY.METER
1990/10/20 - PF  - Add HELD.SPEED.BUTTON in support of Meter Map VK interface
1990/10/10 - PF  - Moved DISPLAY.CLICK.RATE here and modified it to always
						 display current tempo
1990/10/10 - PF  - Expand TRACK.FORMAT to allow for beats only display mode
1990/03/21 - PF  - Compressed CLAV.PTR to 43 sectors
1990/03/09 - PF  - Increase MAX.INPUTS to 128
1989/11/14 - MWH - Enable selection of MIDInet sync from button panel (for PAUL)
1989/11/14 - MWH - Disable MIDI + Polyphony when MIDInet present (for PAUL)
1989/01/13 - PF  - Monster MIDI code
1988/12/02 - CJ  - ADDED HELD.POLY.BUTTON
1988/11/10 - PF  - bug fix for SPLIT function and STOP button
1988/10/17 - TSS - HAD TO MOVE SMPTE.GEN ROUTINE TO 172-PRF2
1988/10/17 - TSS - MOVED CODE TO SILENCE 4X VOICES TO TBASE.L BUTTON CODE
1988/09/22 - TSS - Changed references to INC.XXXX to DIAGNOSTICS.ENABLED
1988/06/15 - CJ  - modified Smpte Generator to show code on terminal
1988/04/12 - PF  - ADDED CALL TO DISPLAY.ENABLED.TRACKS FOR MULTI TRACK RECORDING
1988/04/12 - PF  - ADDED CALLS TO CLEAR.ALL.NOTES AND CLEAR.POLY.TIMBRE.NOTES WHEN MAPPING CHANGES
1988/01/25 - MWH - Allow track's prefered poly bin to be changed from VK
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/07/02 - MWH - kbd lookup table literals; restructured for 32 bit poly
1987/04/14 - TS  - MADE REPLICATE.BOUNCE A LOCAL STATIC VAR
1986/05/15 - "official" creation of release-M modules
*/

/*	GENERAL DESCRIPTION:

.	THE BUTTONS ON THE SYNCLAVIER FRONT PANEL ARE EASILY CATEGORIZED
.	INTO 9 BASIC TYPES OF BUTTONS.  THESE TYPES ARE:
.
.		1 - PARTIAL SELECT BUTTONS (PARTIAL SELECT, PARTIAL SOLOING)
.		2 - PARAMETER BUTTONS (BUTTONS THAT CONTROL A KNOB PARAMETER)
.		3 - SEQUENCER CONTROL BUTTONS	(START, STOP, ETC.)
.		4 - TRACK SELECT BUTTONS		(16-32 TRACKS)
.		5 - REAL TIME EFFECTS BUTTONS
.		6 - BANK SELECT BUTTONS
.		7 - TIMBRE RECALL BUTTONS
.		8 - SEQUENCER RECALL BUTTONS
.		9 - MISCELLANEOUS BUTTONS (UNUSUAL OR UNIQUE FUNCTIONS)
.
.	THE ROUTINE 'PERFORM' EXAMINES BUTTON PRESSES/RELEASES STORED ON
.	A PUSH DOWN STACK CREATED BY THE DRIVER ROUTINE.  THE BUTTON
.	IS CATEGORIZED INTO ONE OF THE 9 GROUPS, AND THE CORRESPONDING
.	PROCEDURE IS CALLED.  THE PROCEDURE IS PASSED A *** RELATIVE ***
.	BUTTON NUMBER (I.E 0-7 FOR THE 8 TIMBRE RECALL BUTTONS) AND
.	A VALUE WORD THAT INDICATES WHETHER THE BUTTON HAS JUST BEEN
.	PRESSED OR RELEASED.
.
.	THE FOLLOWING 9 ROUTINES PROCESS THE DIFFERENT TYPES OF
.	SYNCLAVIER II BUTTONS:	*/

/*	FIRST, SOME GLOBAL VARIABLES:	*/

DCL RESET.INFO			FIXED PUBLIC;	/*	HOLDS BUTTON # OF BUTTON PRESSED TWICE (FOR RESETTING VARIABLES)	*/

DCL REPLICATE.BOUNCE	FIXED;			/*	TRUE IF SHOULD COPY SOURCE FOR BOUNCE	*/
DCL SPLIT.KEYBOARD	FIXED PUBLIC;	/*	TRUE IF SPLIT ACTIVE	*/
DCL SPLIT.KBD.LOC		FIXED PUBLIC;	/*	DEFINES LOCATION OF KEYBOARD SPLIT	*/
DCL TRACK.ONE			FIXED PUBLIC;	/*	INDICATES SOURCE TRACK FOR BOUNCE	*/
DCL PARTIAL.STATE		FIXED PUBLIC;	/*	USED FOR BOUNCING PARTIALS	*/
DCL PARTIAL.ONE		FIXED PUBLIC;	/*	INDICATES FIRST PARTIAL	*/

DCL (TB.POS,VB.POS)	FIXED PUBLIC;	/*	TONE BEND/VIBRATO DEPTH FROM MASTER KNOB	*/

/*	THE PTR "CLAV.PTR" POINTS TO 43 SECTORS OF EXTERNAL MEMORY WHICH	*/
/*	STATE INFORMATION ABOUT ALL OF THE KEYS ON THE KEYBOARD AND THE	*/
/*	126 'MIDI KEYBOARDS'.  THIS INFO IS REPRESENTED BY THE BITS			*/
/*	DEFINED IN THE FOLLOWING LITERAL DECLARATIONS.  ACCESS THE INFO	*/
/*	WITH CODE LIKE THAT SHOWN BELOW:												*/

/*	WRITE(MAM)=CLAV.PTR+SHR((CHANNEL*NUM.KEYS)+KEY#,8);				*/
/*										CHANNEL=0	  SYNCLAVIER KEYBOARD	*/
/*										CHANNEL=1	  UNDEFINED					*/
/*										CHANNEL=2-127 INPUT CHANNELS 2-127	*/
/*										CHANNEL=2-202 INPUT CHANNELS 2-202	*/	// Changed to allow midi access to all sequencer tracks 2007-02-11 CJ
/*	WRITE(MAL)=(CHANNEL*NUM.KEYS)+KEY#;										*/
/*	INFO CAN BE READ OR WRITTEN WITH READ(MD) OR WRITE(MD)			*/


/*	TOGGLE.CLICKON is set to TRUE when the click button is pressed.  If any other buttons				*/
/*	are pressed (or the knob turned) while click is held, then TOGGLE.CLICKON is set to false.		*/
/*	When the click button is released, CLICKON is toggled depending on the value of TOGGLE.CLICKON.	*/
/*	This is done to enable the on/off status of the click to be quickly toggled without having		*/
/*	to step through modes, while also allowing modes to be stepped through (and rate to be changed)	*/
/*	without having to toggle the on/off status.																		*/

DCL TOGGLE.CLICKON BOOLEAN;


/*	CLICK.TRACK.FUNCTION is stepped by track button presses while the click button is held.  This	*/
/*	is needed because the resulting functions are not executed until the click button is released.	*/

DCL CLICK.TRACK.FUNCTION	FIXED;	/*	CLICK.TRACK.FUNCTION:						*/
												/*	---LOWER BYTE---								*/
												/*		0:	NO-OP (ABORT)							*/
												/*		1:	SELECT/DESELECT AS CLICK TRACK	*/
												/*		2:	GENERATE MAP, PRESERVE TIMES		*/
												/*		3:	GENERATE MAP, PRESERVE BEATS		*/
												/*	---UPPER BYTE---								*/
												/*		Asolute Track Number (0-255)			*/

//	32-bit constant 60,000,000 used repeatedly in conversions between sec/beat and beat/min
dcl sixty_million	data (915,34560);

/*	$PAGE - ROUTINES TO ASSIST WITH BUTTON COMMANDS	*/

/*	THEN SOME SHORT ROUTINES CALLED BY SEVERAL OF THE BUTTON
.	PROCESSING ROUTINES	*/

/*	ROUTINE TO CLEAN UP FROM BOUNCE, SMT, SKT, & CHAIN:	*/
/*	ALSO CLEANS UP FROM TRACK PAN									*/


ABORT.BOUNCE.SMT.SKT:PROC PUBLIC SWAPABLE;	/*	STOP THESE FUNCTIONS MIDSTREAM IF REQUIRED	*/
	IF (UPPER.DISP == TPANRESET.DISP)
		CLEAR.DISPLAY();

	IF (UPPER.DISP == TPAN.DISP)
		CLEAR.DISPLAY();

	IF (UPPER.DISP == TGROUP.DISP)
		CLEAR.DISPLAY();

	IF (UPPER.DISP == START.DISP)
		REMOVE.TRACK.START.DISPLAY();

	IF (BOUNCE\SMT\SKT\CHAIN\TPAN\TGRP)=0 THEN RETURN;		/*	NOT IN PROGRESS, JUST RETURN	*/

	CHAIN=0; BOUNCE=0; SMT=0; SKT=0; TPAN=0; TGRP=0; SPLT=0;

	BOUNCE.PTR		= 0;
	SPECIAL.BOUNCE	= 0;
	TRACK.STATE		= TRACK.STATE.NORMAL;
	RECALL.STATE	= 0;
	PARTIAL.STATE	= 0;
	TIMB.DEST		= 0;
	REPLICATE.BOUNCE = 0;								/*	INITIALIZE BOUNCE DEFAULT OF NOT REPLICATING	*/

	ALLOW.TRACK.GROUP.DEFINE = 0;

	CALL DISPLAY.BOUNCE.AND.RECD.JUST.BUTTONS;	/*	CLEAR BOUNCE BUTTON (UNLESS JUSTIFIED RECORDING WITH OLD PANEL)	*/
	CALL DISPLAY.SMT.SKT.BUTTONS;						/*	DISPLAY SMT & SKT	*/
	CALL DISPLAY.TIMBRE.RECALL.BUTTONS;				/*	SET CORRECT TIMBRE RECALL BUTTONS	*/
	CALL DISPLAY.TRACK.BUTTONS;						/*	SET SOLOED TRACK BUTTONS	*/

END ABORT.BOUNCE.SMT.SKT;

CLEAR.ERAS.BUTTON:PROC PUBLIC SWAPABLE;			/*	CLEAN UP OR ABORT AN ERASE ATTEMPT	*/
	IF (UPPER.DISP == ERAS.DISP)
		CLEAR.DISPLAY();

	ERAS			= 0;
	ERASE.STYLE	= ERASE.NO.STYLE;
END CLEAR.ERAS.BUTTON;

RESET.KEYBOARD.TIMBRE.CONTROL:PROC(CODE) PUBLIC SWAPABLE;
	DCL CODE	FIXED;	/*	0=RESTORE OLD TIMBRE, 1=ZAP OLD ONE WITH NEW ONE	*/
	DCL TB	FIXED;

	DO CASE CODE;

		DO;						/*	CASE 0: RESTORE ORIGINAL TIMBRE TO TRACK	*/
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=KEYBOARD.TIMBRE.CONTROL;
			WRITE(MAM)=READ(MD);
			WRITE(MAL)=THD.USAGE;
			TB			 =READ(MD);

			WRITE(MAL)=THD.STIMB;
			WRITE(MD )=TB;
			WRITE(MAL)=THD.CTIMB;
			WRITE(MD )=TB;
			WRITE(MAL)=THD.LP.CTIMB;
			WRITE(MD )=TB;
			WRITE(MAL)=THD.ILS.CTIMB;
			WRITE(MD )=TB;
			WRITE(MAL)=THD.ILE.CTIMB;
			WRITE(MD )=TB;
			/*	NOTIFY SCREENS OF "NEW" TIMBRE ON TRACK EVEN WHEN RESTORING ORIGINAL	*/
			new.seq.info=new.seq.info\2;
		END;

		DO;						/*	CASE 1: PLACE KEYBOARD TIMBRE ON TRACK	*/
			/*	THE UPCOMING CALL TO COPY.TIMBRE TAKES CARE OF "new.seq.info=new.seq.info\2"	*/
			CALL DEALLOC.TIMBRE.USES(KEYBOARD.TIMBRE.CONTROL);	/*	FREE UP OLD TIMBRE BEFORE COPYING NEW ONE	*/
			CALL COPY.TIMBRE(0,KEYBOARD.TIMBRE.CONTROL);			/*	COPY KBD TIMBRE TO TRACK	*/
		END;

	END;

	KEYBOARD.TIMBRE.CONTROL=0;		/*	RELEASE CONTROL	*/

END RESET.KEYBOARD.TIMBRE.CONTROL;

SKT.SPLT.SUB:PROC(T#) PUBLIC SWAPABLE;	/*	PROCESS SKT/SPLT	*/
	DCL (T#)	FIXED;	/*	PASS 0 OR -1	*/

	IF (SKT<>0)&(TIMB.DEST=1)
	THEN CALL ABORT.BOUNCE.SMT.SKT;	/*	STOP OPERATION ON THIRD SKT PRESS	*/
	ELSE DO;									/*	PRESSING FIRST OR SECOND TIME	*/
		IF (SKT<>0) THEN DO;				/*	PRESSING TWICE	*/
			TIMB.DEST=1;					/*	INDICATE LOWER HALF OF KEYBOARD ONLY	*/
			RECALL.STATE=2;
		END;
		ELSE DO;								/*	PRESSING FIRST TIME - RECALL TO ALL, OR UPPER ONLY	*/
			TIMB.DEST=T#;					/*	ELSE RECALL TO ALL OF KEYBOARD, OR JUST UPPER	*/
			RECALL.STATE=1;
		END;

		SKT=1;												/*	LIGHT SKT LIGHT	*/

		TRACK.STATE = TRACK.STATE.TIMBRE.RECALL;	/*	SET STATE TO CAUSE TIMBRE MOVEMENT IF TRACK BUTTON PRESS	*/

		CALL DISPLAY.TIMBRE.RECALL.BUTTONS;			/*	THESE WILL BLINK	*/
		CALL DISPLAY.TRACK.BUTTONS;					/*	THESE WILL BLINK	*/
		CALL DISPLAY.SMT.SKT.BUTTONS;					/*	SET UP THESE		*/
	END;
END SKT.SPLT.SUB;

/*	$SUBTITLE  CHANGE RTE PATCHING	*/


/*	STEPS TO THE NEXT RTE MODE FOR THE SPECIFIED EFFECT	*/
/*	ON THE KEYBOARD TIMBRE										*/


STEP.RTE.PATCHING:  PROC (EXP.INPUT,PRM) PUBLIC SWAPABLE;	/*	CHANGES RTE PATCHING ON KBD TIMBRE	*/
	DCL EXP.INPUT	FIXED;	/*	EXPRESSION TO PATCH (VEL,PRS,MOD,PED1,ETC)	*/
	DCL PRM			FIXED;	/*	PARAMETER TO PATCH TO (VOL,VIB,ETC)	*/
	DCL TINFO.BASE	FIXED;
	DCL (I,J,K,L,M)	FIXED;


	IF RECD<>0 THEN RETURN;	/*	CANNOT BE RECORDING FOR NOW	*/


	/*	FIRST MAKE SURE WE HAVE A TINFO.BLOCK	*/

	TINFO.BASE=TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);	/*	READ TINFO.POINTER FOR KBD TIMBRE	*/

	IF TINFO.BASE=0 THEN DO;							/*	CREATE TINFO BLOCK ON BUTTON PRESS	*/
		IF CREATE.TINFO.FRAME=0							/*	TRY TO CREATE IT - CHECK FOR ERROR	*/
		THEN RETURN;										/*	NOT ENOUGH MEMORY - BOMB OUT	*/
		ELSE TINFO.BASE=TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);	/*	READ TINFO.POINTER FOR KBD TIMBRE	*/
	END;


	/*	HANDLE CLEARING OF ALL PARMS PATCHED TO AN EXPRESSION	*/

	IF (EXP.INPUT&256)<>0 THEN DO;			/*	PRESSING CLEAR, OR PRESSING OTHER BUTTON WITH CLEAR HELD	*/
		IF EXP.INPUT IGT 256 THEN DO;			/*	CLEAR ALL PARMS PATCHED TO THIS EXPRESSION	*/
			DO I=0 TO 7;							/*	LOOP OVER EXPRESSION INPUTS	*/
				IF (EXP.INPUT&BITS(I))<>0 THEN DO;	/*	CLEAR THIS EXPRESSION	*/
					J=TINFO.BASE+TI.RTE+I*5;			/*	COMPUTE POINTER TO WORD PAIR	*/
					CALL P.STORE(J,"17");				/*	INITIALIZE TO ALL PARTIALS	*/
					WRITE(MDI)=0; WRITE(MDI)=0;		/*	CLEAR RTE WORDS FOR	*/
					WRITE(MDI)=0; WRITE(MDI)=0;		/*	THAT EXPRESSION	*/
				END;
			END;
			CALL COMPUTE.RBITS(0);				/*	MUST RECOMPUTE LOOKUP TABLE	*/
			NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	SET BIT TO INDICATE OVERALL CHANGE	*/
		END;
	END;

	IF PRM=(-1) THEN DO;							/*	DON'T MESS WITH PARMS	*/
		CALL COMPUTE.RTE.BUTTONS;				/*	COMPUTE NEW RTE BUTTON DISPLAY	*/
		RETURN;										/*	AND ALL DONE NOW	*/
	END;


	/*	REMAP SEVERAL PARAMETERS	*/

	IF PRM=VE.SUST.L THEN PRM=VE.PEAK.L;	/*	MAP THESE BUTTONS TOGETHER	*/
	IF PRM=PVOL.L	  THEN PRM=VE.PEAK.L;
	IF PRM=DYNENVH.L THEN PRM=DYNENVL.L;
	IF PRM=PCHORUS.L THEN PRM=CHORUS.L ;	/*	PARTIAL CHORUS/CHORUS	*/


	/*	SEE IF DESIRED PARAMETER IS AVAILABLE FOR RTE PATCHING	*/

	K=0;L=0;													/*	INITIALIZE TO NOT FOUND	*/
	DO I=0 TO 15;											/*	SEE IF LEGIT PARAMETER	*/
		IF (SAMPLED.LOOKUP(I)&255)=PRM THEN DO;	/*	LEGIT SAMPLED PARAM	*/
			K=0; L=BITS(I);								/*	GET BIT	*/
		END;
		IF (CONTINUOUS.LOOKUP(I)&255)=PRM THEN DO;	/*	CONTINUOUS PARAMETER	*/
			K=1; L=BITS(I);
		END;
	END;
	IF (K\L)=0 THEN DO;
		CALL COMPUTE.RTE.BUTTONS;						/*	COMPUTE NEW RTE BUTTON DISPLAY	*/
		RETURN;												/*	PARAMETER NOT AVAILABLE FOR PATCHING	*/
	END;


	DO I=0 TO 7;											/*	CHECK EACH SOURCE - ELSE LEAVE OFF WITH ERR11 DISPLAY	*/
		IF (EXP.INPUT&(BITS(I)\256))<>0 THEN DO;	/*	CHANGE PARAMETERS FOR THESE SOURCES	*/
			J=TINFO.BASE+TI.RTE+I*5;					/*	COMPUTE POINTER	*/
			IF (EXP.INPUT&256)<>0 THEN DO;			/*	CLEAR PATCHING	*/
				M=P.LOOKUP(J+1+K);
				WRITE(MD)=M&(NOT(L));
				M=P.LOOKUP(J+3+K);
				WRITE(MD)=M&(NOT(L));
			END;
			ELSE DO;											/*	PERFORM INVERT/TOGGLE	*/
				M=P.LOOKUP(J+3+K);
				IF (M&L)<>0 THEN WRITE(MD)=M XOR L;	/*	INVERTED TO OFF	*/
				ELSE DO;										/*	CHECK FOR ON TO INVERTED	*/
					M=P.LOOKUP(J+1+K);
					IF (M&L)<>0 THEN DO;					/*	ON TO INVERTED	*/
						WRITE(MD)=M XOR L;				/*	TURN OFF INVERTED BIT	*/
						M=P.LOOKUP(J+3+K);
						WRITE(MD)=M XOR L;				/*	TURN ON INVERT BIT	*/
					END;
					ELSE DO;									/*	OF TO ON	*/
						WRITE(MD)=M XOR L;				/*	TURN ON NORMAL PATCH	*/
					END;
				END;
			END;
			NEW.PRM.INFO=NEW.PRM.INFO\16;				/*	SET BIT TO INDICATE OVERALL CHANGE	*/
		END;
	END;

	CALL COMPUTE.RTE.BUTTONS;					/*	COMPUTE NEW RTE BUTTON DISPLAY	*/
	CALL COMPUTE.RBITS(0);						/*	RE-COMPUTE REAL TIME EFFECTS BITS	*/

END STEP.RTE.PATCHING;


/*	$SUBTITLE  ROUTINES TO CLEAR OUT PARAMETER STACK AND TO PUSH NEW PARM ONTO STACK	*/

DCL (NUM.HELD.BUTTONS)	FIXED PUBLIC;		/*	COUNTS HELD BUTTON FOR ALGORITHM	*/

CLEAR.PARAMETERS:PROC PUBLIC;					/*	PROCEDURE TO ERASE PARAMETERS - DO NOT SWAP SO TRACK BUTTONS ARE FAST	*/

	IF (LOWER.DISP=LOOPL.DISP)					/*	CLEAR 'TOTAL LENGTH' OR		*/
	OR (LOWER.DISP=TIME.DISP)					/*	OR 'MARK POINT' OR			*/
	OR (LOWER.DISP=POLYPHONY.DISP)
	THEN CALL CLEAR.LOWER;						/*	'LOOP LENGTH' FROM DISPLAY	*/

	IF CHAIN<>0 THEN CALL ABORT.BOUNCE.SMT.SKT;	/*	GET OUT OF CHAIN IF NECESSARY	*/

	ACTIVE.PARMS(0)=0;							/*	EMPTY OUT PARAMETER LIST	*/

	TB.ENABLED=0; TB.POS=0; VB.POS=1000;	/*	CLEAR OUT TONE BEND INFO	*/
	IF SOLOED.PARTIALS=15 THEN DO;			/*	INDICATES ACCESS OF POLYPHONY CONTROL - CLEAR IT	*/
		SOLOED.PARTIALS=0;						/*	REMOVE KEYBOARD POLYPHONY	*/
		CALL DISPLAY.PARTIAL.BUTTONS;
		CALL COMPUTE.VOLUME.LEVELS;			/*	COMPUTE NEW VOLUME LEVELS AFTER SOLOING CHANGE	*/
	END;

	CALL DISPLAY.PARAMETER.BUTTONS;			/*	DISPLAY BUTTONS (I.E. CLEAR THEM)	*/
	CALL CLEAR.UPPER;                      /*	ERASE POSSIBLE PARAMETER NUMBER IN WINDOW	*/
	CALL DISPLAY.TONE.BEND.BUTTON;			/*	DISPLAY TONE BEND INFO		*/

END CLEAR.PARAMETERS;

ADD.PARM.TO.ACTIVE.LIST:  PROC (PRM,PRM#) PUBLIC SWAPABLE;	/*	PUSHES NEW PARM ONTO ACTIVE.PARM LIST	*/
	DCL (PRM,PRM#)	FIXED;
	DCL (I,J)		FIXED;

	DO I=1 TO ACTIVE.PARMS(0);						/*	SEE IF ALREADY ACTIVE (BEING PRESSED TWICE)	*/
		IF (ACTIVE.PARMS(I)&255)=PRM THEN DO;	/*	PRESS TWICE - SET FLAG FOR PROCESSING IN 'UPDATE'	*/
			IF  (UPPER.DISP<>0)						/*	IF VALID PARAMETER BEING DISPLAYED	*/
			AND (UPPER.DISP=PRM)						/*	AND THIS ONE IS BEING DISPLAYED	*/
			AND (PRM <> (SMPTE.L-PAR.L))			/*	BUT DISALLOW FOR SMPTE TO AVOID UNNECESSARY DROPOUTS	*/
			THEN RESET.INFO=PRM;						/*	PERFORM RESET IF PARAMETER IS BEING DISPLAYED	*/
		END;
	END;

	IF (NUM.HELD.BUTTONS=1)
	THEN CALL CLEAR.PARAMETERS;				/*	CLEAR OUT ACTIVE LIST	*/

	IF DIAGNOSTICS.ENABLED THEN DO;			/*	STOP ALL NOTES ON PARTIAL PRESS IF XXXX PROGRAM	*/
		IF PRM=(TBASE.L-PAR.L) THEN DO;		/*	TUNING BASE BUTTON	*/
			WRITE(MAM)=CLAV.PTR;					/*	SET UP PTR TO KEY STATE XMEM ARRAY	*/
			DO I=0 TO NUM.KEYS-1;				/*	LOOP OVER ALL THE KEYS	*/
				WRITE(MDI)=READ(MD) AND (NOT ACTIVE);	/*	AND TURN OFF THE ACTIVE BIT	*/
			END;
		END;
	END;

	J=0;	/*	ASSUME NOT HELD	*/
	DO I=1 TO ACTIVE.PARMS(0);								/*	SEE IF ALREADY ON LIST	*/
		IF (ACTIVE.PARMS(I)&255)=PRM THEN J=1;			/*	ALREADY ON LIST	*/
	END;

	IF (J=0)&(ACTIVE.PARMS(0) ilt 20) THEN DO;		/*	PUT ON LIST (IF ROOM)	*/
		ACTIVE.PARMS(0)=ACTIVE.PARMS(0)+1;
		ACTIVE.PARMS(ACTIVE.PARMS(0))=PRM\SHL(PRM#,8);
	END;

END ADD.PARM.TO.ACTIVE.LIST;

/*	$PAGE - ADDITIONAL SUBROUTINES - TOGGLE.BLINK/LOOP LENGTH DISPLAY	*/

TOGGLE.BLINK:PROC PUBLIC SWAPABLE;				/*	PROCEDURE TO TOGGLE BLINKING MODE	*/
	IN.BLINK.MODE=IN.BLINK.MODE XOR 1;			/*	SWITCH STATE	*/
	IF NEW.PAN=0 THEN CALL CLEAR.PARAMETERS;	/*	CLEAR OTHER PARAMETERS ON OLD KEYBOARD	*/
	CALL DISPLAY.HGS;									/*	SET HGS BUTTONS TO BLINK OR NOT	*/
END TOGGLE.BLINK;

DISPLAY.LENGTH.LOOP:PROC PUBLIC SWAPABLE;		/*	CALL IF POLY PATCH LIST PARTIAL IS SELECTED	*/
	DCL PRM	FIXED;

	IF (INC.POLY=0)
	OR (SCALE.ADJUST.IS.ACTIVE<>0)
	OR (TIM.HEAD.LOOKUP(0,TIM.SYNTH.TYP+FIND.PARTIAL)<>2)	/*	NOT A POLY PATCH LIST PARTIAL	*/
	THEN DO;												/*	KEEP LOWER DISPLAY CORRECT	*/
		IF (LOWER.DISP=LOOPL.DISP)					/*	LOOP DISPLAY IN LOWER	*/
		THEN CALL CLEAR.LOWER;
		RETURN;
	END;

	PRM=ACTIVE.PARMS(ACTIVE.PARMS(0))&255;	/*	GET LAST ENTRY ON STACK (HOPEFULLY ONLY ONE). YIELDS 0 IF STACK IS EMPTY	*/
	IF NEW.PAN=0 THEN RETURN;					/*	OLD PANEL?	*/
	IF (PRM=12)\(PRM=24) THEN DO;
		CALL CLEAR.LOWER;
		CALL EMIT.STRING(16,'TOTAL  LENGTH');
		LOWER.DISP=LOOPL.DISP;
	END;
	ELSE IF (PRM=13)\(PRM=25) THEN DO;
		CALL CLEAR.LOWER;
		CALL EMIT.STRING(16,'LOOP   LENGTH');
		LOWER.DISP=LOOPL.DISP;
	END;
	ELSE IF (PRM=14)\(PRM=26) THEN DO;
		CALL CLEAR.LOWER;
		CALL EMIT.STRING(16,'WINDOW LENGTH');
		LOWER.DISP=LOOPL.DISP;
	END;
	ELSE IF (LOWER.DISP=LOOPL.DISP)	/*	SELECTED, BUT NOT LAST	*/
	THEN	  CALL CLEAR.LOWER;
END DISPLAY.LENGTH.LOOP;

/*	Handy routine to update VK display limit breakpoints:	 huh?	*/

DISPLAY.CLICK.RATE:PROC(VALUE) PUBLIC SWAPABLE;
	DCL VALUE		FIXED;		/*	PASS DISPLAY VALUE	*/
	DCL PT			FIXED;		/*	DECIMAL POINT TO POS	*/
	DCL (I, J)		FIXED;
	DCL scale32(1)	FIXED;

	//	from :SYNSOU:LINKMOD:LINKSOU
	dcl convert_msec_to_frames proc (fixed,fixed,fixed array) external;	//	pass (millisecond_click_rate, frame_type, output_array)
	dcl convert_usec_to_frames proc (fixed,fixed array)		 external;	//	pass (frame_type, output_array)

	IF (CLICK.TRACK.MODE == 0) THEN DO;						/*	INTERNAL CLICK	*/
		if (TEMPO.MAP.PTR/*|METER.MAP.PTR*/) == 0
		then do case CLICK.DISP.MODE;							//	HANDLE UNMAPPED SEQUENCES
			//	CASE 0: BEATS PER MINUTE
			{	IF VALUE ilt 184									//	Prevent quotient below from being interpreted as a negative number
				THEN {PT = 1; LOAD  120;}						/*	600,000/MSEC = BPM*10	*/
				ELSE {PT = 2; LOAD 1200;}						/*	GIVES AN EXTRA DECIMAL PLACE - 6,000,000/MSEC = BPM*100	*/
				MUL 5000; MWAIT; DIV VALUE;
				if (shl(REM,1) ige VALUE) load RES+1;		//	ROUND
				DISPLAY.PAR.NUM(RES,PT,256*24);				/*	BEATS/MIN	*/
			}

			//	CASE 1: MILLISECONDS PER BEAT
			DISPLAY.PAR.NUM(VALUE,0,1);

			//	CASE 2: FILM FRAMES PER BEAT
			{	convert_msec_to_frames(samp.click.rate,0,loc(addr(i)));
				clear.upper();				//	clear the top line
				emit_int.fract(i,j);
				display.units(256*19);	//	emit 'FILM FR/B'
			}

			//	CASE 3: SMPTE FRAMES PER BEAT
			{	convert_msec_to_frames(samp.click.rate,1,loc(addr(i)));
				clear.upper();				//	clear the top line
				emit_int.fract(i,j);
				display.units(256*40);	//	emit 'SMPTE F/B'
			}
		end;	//	of do case

		else do case CLICK.DISP.MODE;							//	HANDLE MAPPED SEQUENCES
			//	CASE 0: BEATS PER MINUTE
			{	CALL LOOKUP.TEMPO(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)),LOC(ADDR(I)));	/*	GET CURRENT MICROSECONDS/BEAT	*/
				//	if microseconds per beat is less than 183109 then shift decimal to avoid result greater than (2^15)-1
				if ((i ilt 2) || ((i == 2) && (j ilt 52037))) {pt = 1; scale32(1) =	10;}
				else														 {pt = 2; scale32(1) = 100;}
				disable;
				mul_32by32(sixty_million,scale32);
				div_64by32(loc(addr(i)),loc(addr(i)));
				enable;
				DISPLAY.PAR.NUM(J,PT,256*24);					/*	BEATS/MIN	*/
			}

			//	CASE 1: MICROSECONDS PER BEAT
			{	CALL LOOKUP.TEMPO(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)),LOC(ADDR(I)));	/*	GET CURRENT MICROSECONDS/BEAT	*/
				CALL CLEAR.UPPER;									/*	CLEAR TOP LINE	*/
				CALL EMIT.LARGE.NUMBER(0,I,J);				/*	MICROSECONDS PER BEAT	*/
				CALL EMIT.STRING(10,'USEC');					/*	ABBREVIATE MICROSECONDS	*/
			}

			//	CASE 2: FILM FRAMES PER BEAT
			{	convert_usec_to_frames(0,loc(addr(i)));
				clear.upper();				//	clear the top line
				emit_int.fract(i,j);
				display.units(256*19);	//	emit 'FILM FR/B'
			}

			//	CASE 3: SMPTE FRAMES PER BEAT
			{	convert_usec_to_frames(1,loc(addr(i)));
				clear.upper();				//	clear the top line
				emit_int.fract(i,j);
				display.units(256*40);	//	emit 'SMPTE F/B'
			}
		end;	//	of do case
	END;		//	of if INTERNAL CLICK

	ELSE IF CLICK.TRACK.MODE=3 THEN DO;						/*	EXTERNAL CLICK	*/
      CALL CLEAR.UPPER;
      CALL EMIT.STRING(0,'EXTERNAL CLICK');

      IF (NEW.ORK == 1) THEN BEGIN;
			DCL MSG.E DATA ("100"+SHL("100",8),"100"+SHL("171",8),0);
			CALL CLEAR.DISPLAY;
			CALL DISPLAY.ORK.WINDOW.MESSAGE(MSG.E);
		END;
	END;

	ELSE DO;															/*	USING TRACK FOR CLICK	*/
		IF NEW.PAN=0 THEN DISPLAY.PAR.NUM(CLICK.TRACK.MODE-3,0,0);
		ELSE DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0 ,'CLICK: TRACK');
			CALL EMIT.NUMBER(13,CLICK.TRACK.MODE-3,0,LEFT.JUST);
		END;
	END;

	UPPER.DISP=(CLICK.L-PAR.L);

END DISPLAY.CLICK.RATE;

DISPLAY.METER:PROC PUBLIC SWAPABLE;
	DCL BPM		FIXED;
	DCL DENOM	FIXED;
	DCL POS		FIXED;

	IF ((/*TEMPO.MAP.PTR|*/METER.MAP.PTR) == 0)	/*	ONLY BPM CAN CHANGE	*/
	THEN BPM.CURSOR = 0;									/*	IF NO TEMPO/METER	*/

	IF UPPER.DISP<>(BPM.L-PAR.L) THEN DO;	/*	INITIALZE FOR BLINKING OF CURSOR ON FIRST PRESS	*/
		BLINK.MS=REAL.MILLISECONDS-300;		/*	INITIALIZE ON FIRST DISPLAY	*/
		CURSOR.BLINK=1;
	END;

	CALL CLEAR.UPPER;

	BPM=LOOKUP.BEATS.PER.MEASURE(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
	DENOM=LOOKUP.DENOM(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
	DENOM=SHL(2,DENOM-1);			/*	DENOM STORED AS NEG POWER OF TWO	*/

	CALL EMIT.NUMBER(5, BPM,  0,RIGHT.JUST);
	CALL EMIT.NUMBER(12,DENOM,0,LEFT.JUST );

	IF  (CURSOR.BLINK<>0)
	AND (HELD.CLIK.BUTTON<>0)
	AND (HELD.SPEED.BUTTON<>0)
	THEN DO;
		IF (BPM.CURSOR=0)
		THEN CALL EMIT.STRING(8 ,'___');
		ELSE CALL EMIT.STRING(12,'__' );
	END;

	CALL EMIT.STRING(0 ,'Meter =');
	CALL EMIT.STRING(11,'/');

	UPPER.DISP			 = (BPM.L-PAR.L);
	ANY.MISC.FUNCTIONS = TRUE;

END DISPLAY.METER;

DISPLAY.CLICK.VALUE:PROC(VALUE) SWAPABLE;
	DCL VALUE	FIXED;

	CALL CLEAR.UPPER;

	CALL EMIT.STRING(0,'CLICK = ');
	DO CASE VALUE;
		CALL EMIT.STRING(8,'1/16 ');
		CALL EMIT.STRING(8,'1/16.');
		CALL EMIT.STRING(8,'1/8  ');
		CALL EMIT.STRING(8,'1/8. ');
		CALL EMIT.STRING(8,'1/4  ');
		CALL EMIT.STRING(8,'1/4. ');
		CALL EMIT.STRING(8,'1/2  ');
		CALL EMIT.STRING(8,'1/2. ');
		CALL EMIT.STRING(8,'1/1  ');
		CALL EMIT.STRING(8,'1/1. ');
	END;

	UPPER.DISP=CLICKVAL.L-PAR.L;

END DISPLAY.CLICK.VALUE;

DCL INFO.MODE.UPDATE.TIME	FIXED PUBLIC;	/*	USED TO TIME TRACK BUTTON INFO MODE DISPLAY REFRESHES	*/

INFO.BUTTON.PRESS:PROC PUBLIC SWAPABLE;	/*	PROCESS INFO BUTTON PRESS	*/
	INFO.MODE			 = INFO.MODE XOR 1;
	ANY.MISC.FUNCTIONS = TRUE;
	CALL ASSIGN(INFO.L,INFO.MODE);
	CALL CLEAR.DISPLAY;
	IF (INFO.MODE<>0) THEN DO;					/*	PROMPT DISPLAY	*/
		CALL EMIT.STRING(0,'PRESS BUTTON FORINFORMATION');
		BOTH.DISPLAY=1;
		CALL DISPLAY.ACTIVE.TRACKS;			/*	SHOW WHICH TRKS ARE PLAYING	*/
		INFO.MODE.UPDATE.TIME=REAL.MILLISECONDS;		/*	WAIT 100 MSEC	*/
	END;
	ELSE CALL DISPLAY.TRACK.BUTTONS;			/*	REDISPLAY TRACK BUTTONS	*/

	/*	Create a system event when info mode is turned on or off:	*/

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 256;

END INFO.BUTTON.PRESS;

/*	$SUBTITLE  Routines to perform button directed actions	*/

PARTIAL.BUTTON:PROC(PAR,VALUE) PUBLIC SWAPABLE;	/*	PROCESS PARTIAL SELECT BUTTON	*/
   DCL (PAR,VALUE)         FIXED;
   DCL (I,J,K)             FIXED;
	DCL MISC.BASE				FIXED;
	DCL TINFO.BASE				FIXED;
	DCL (NUM.PARS,NUM.FRAMES)	FIXED;
	DCL (FNAME)  (4)			FIXED;

	HELD.PSEL.BUTTONS=HELD.PSEL.BUTTONS XOR BITS(PAR);	/*	KEEP TRACK OF HELD ONES FOR TIMBRE FRAME SELECT UPDATING	*/
	NUM.HELD.BUTTONS =NUM.HELD.BUTTONS -1 + VALUE + VALUE;

	IF (NEW.PAN<>0)&(INFO.MODE<>0) THEN DO;	/*	GIVE INFO ON PARTIAL USAGE	*/

		IF VALUE=0 THEN RETURN;						/*	RETURN ON RELEASE	*/

		/*	COMPUTE NUMBER OF VOICES AND FRAMES FOR THIS PARTIAL TIMBRE	*/

		NUM.PARS=0; NUM.FRAMES=0;	/*	NO PARTIALS OR FRAMES YET	*/
		FNAME(0)=0; FNAME(1)=0;		/*	INITIALIZE NAME			*/

		PTPTR=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+PAR);	/*	LOOK UP POINTER HERE FOR NEW FORMAT	*/

		IF (P.LOOKUP(PTPTR)<>SUP) THEN DO;	/*	ACTIVE PARTIAL - LOOK FURTHER	*/
			I=0;
			IF ((P.LOOKUP(PTPTR+P.EPEAKL)\P.LOOKUP(PTPTR+P.ESUSTL))&1023)<>0 THEN DO;
				I=1;	/*	COUNT PARTIALS	*/
				IF P.LOOKUP(PTPTR+P.NEW.CHORUS)<>1000 THEN I=2;	/*	INCLUDE NEW CHORUS FUNCTION	*/
			END;
			PTPTR=PTPTR+NUM.PARAMS;						/*	GET TO FIRST ONE	*/
			IF  (P.LOOKUP(PTPTR)=MOR) THEN DO;		/*	TIMBRE FRAME EXISTS	*/
				IF (P.LOOKUP(PTPTR+TYPE)=TF.TYPE)
				THEN DO;										/*	USES TIMBRE FRAMES	*/
					I=I+I;
					DO WHILE (P.LOOKUP(PTPTR)=MOR);
						NUM.FRAMES=NUM.FRAMES+1;
						PTPTR=PTPTR+P.LOOKUP(PTPTR+CLEN);
					END;
				END;
				ELSE IF (P.LOOKUP(PTPTR+TYPE)=PT.TYPE)
				THEN DO;								/*	PATCH FRAME - GET FILE NAME	*/
					DO K=0 TO 3;
						FNAME(K+1)=P.LOOKUP(PTPTR+PT.NAME+K);
					END;
					FNAME(0)=8;
					DO K=0 TO 7;					/*	ZEROES TO SPACES	*/
						IF BYTE(FNAME,K)=0 THEN CALL PBYTE(FNAME,K,SP);
					END;
					K=TIM.HEAD.LOOKUP(0,TIM.KBDTAB.PTR+PAR);	/*	CHECK FOR LOOKUP TABLE	*/
					IF K<>0							/*	TABLE EXISTS						*/
					THEN DO;
						WRITE(MAM)=TIM.PTR+K-1;	/*	RESTORE MEMORY POINTERS AGAIN	*/
						J=0;
						DO K=0 TO (NUM.KEYS*KLT.SIZE-1) BY KLT.SIZE;
							WRITE(MAL)=K+KLT.BASE.MSB;		/*	CHECK STEREO ENTRY BIT IN BASE.MSB	*/
							IF (READ(MD)&BASE#STEREO_B)<>0 THEN J=1;
						END;
						IF J<>0 THEN I=SHL(I,1);
					END;
				END;
			END;

			NUM.PARS=NUM.PARS+I;
		END;

		MISC.BASE=TIM.HEAD.LOOKUP(0,TIM.MISC.POINTER);	/*	LOOKUP MISC DATA FOR KEYBOARD TIMBRE	*/

		IF P.LOOKUP(MISC.BASE+CHORUS.LOC)<>1000
		THEN NUM.PARS=SHL(NUM.PARS,1);	/*	2X REQUIRED	*/

		CALL CLEAR.DISPLAY;

		IF FNAME(0)=0 THEN DO;						/*	NOT A PATCH LIST	*/
			CALL EMIT.STRING(0,'PARTIAL');
			CALL EMIT.NUMBER(8,PAR+1,0,LEFT.JUST);
			CALL EMIT.STRING(16,'   V          F');
			CALL EMIT.NUMBER(16,NUM.PARS,  0,LEFT.JUST);
			CALL EMIT.NUMBER(27,NUM.FRAMES,0,LEFT.JUST);
		END;
		ELSE DO;											/*	PATCH LIST - SHOW NAME	*/
			CALL EMIT.STRING(0,'PARTIAL       V');
			CALL EMIT.NUMBER(8,PAR+1,0,LEFT.JUST);
			CALL EMIT.NUMBER(12,NUM.PARS, 0,LEFT.JUST);
			CALL EMIT.STRING(16,FNAME);
		END;
		BOTH.DISPLAY=1;
		RETURN;
	END;	/*	OF DISPLAY PARTIAL INFO	*/

	/*	$PAGE - CHANGE RTE PATCHING OR PARTIAL SELECTION ON PARTIAL BUTTON PRESS	*/

	IF (HELD.RTE.BUTTONS<>0) THEN DO;			/*	CHANGE RTE PATCHING	*/
		IF VALUE=0 THEN RETURN;						/*	RETURN ON RELEASE - NOTHING REQUIRED	*/
		TINFO.BASE=TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);	/*	GET PTR TO TINFO AREA	*/
		IF  (TINFO.BASE<>0)							/*	IF TINFO BLOCK WAS SUCCESSFULLY ALLOCATED	*/
		AND ((RECD=0)\(RECD.TRK=0))				/*	AND NOT RECORDING	*/
		THEN DO I=0 TO 7;								/*	CHECK EACH SOURCE - ELSE LEAVE OFF WITH ERR11 DISPLAY	*/
			IF (HELD.RTE.BUTTONS&(BITS(I)\256))<>0 THEN DO;	/*	CHANGE PARTIALS FOR THESE SOURCES	*/
				J=TINFO.BASE+TI.RTE+I*5;			/*	COMPUTE POINTER	*/
				K=P.LOOKUP(J);							/*	GET CURRENT BITS	*/

				IF (HELD.RTE.BUTTONS&256)<>0		/*	CLEAR BUTTON HELD	*/
				THEN WRITE(MD)=K AND (NOT(BITS(PAR)\BITS(PAR+NUM.PARTIALS)));	/*	TURN OFF BITS FOR THIS PARTIAL	*/
				ELSE DO;
					IF (K & BITS(PAR+NUM.PARTIALS)) <> 0	/*	INVERTED BIT SET	*/
					THEN K = K XOR BITS(PAR+NUM.PARTIALS);	/*	THEN BACK TO OFF	*/
					ELSE IF (K & BITS(PAR)) <> 0				/*	NORMAL SENSING SET	*/
					THEN K = K XOR BITS(PAR) XOR BITS(PAR+NUM.PARTIALS);	/*	THEN OFF WITH NORMAL SESNING, ON TO INVERTED SENSING	*/
					ELSE K = K XOR BITS(PAR);					/*	OFF GOES TO ON	*/
					WRITE(MD)=K;									/*	RESTORE	*/
				END;
				NEW.PRM.INFO=NEW.PRM.INFO\BITS(PAR)\16;	/*	SET BIT TO INDICATE OVERALL CHANGE	*/
			END;
		END;
		CALL COMPUTE.RTE.BUTTONS;	/*	COMPUTE NEW RTE BUTTON DISPLAY	*/
		CALL COMPUTE.RBITS(0);		/*	RE-COMPUTE REAL TIME EFFECTS BITS	*/
		RETURN;							/*	DONE WITH BUTTON PRESS	*/
	END;

	IF HELD.MIDI.BUTTON<>0 THEN RETURN;

	IF VALUE<>0 THEN DO;				/*	PARTIAL SELECT BUTTON BEING PRESSED	*/

		/*	Create an event when the user selectes a new partial:	*/

		NEW.TIMBRE.INFO=NEW.TIMBRE.INFO \ 2;

		IF (SELECTED.PARTIALS&BITS(PAR))<>0 THEN DO;		/*	PRESSING TWICE - TOGGLE SOLO STATE	*/
			IF SOLOED.PARTIALS=0 THEN SOLOED.PARTIALS=1;	/*	CHANGE STATE BETWEEN ZERO AND NON-ZERO FOR NOW	*/
			ELSE                      SOLOED.PARTIALS=0;	/*	REVERT TO NO SOLOING	*/
		END;
		IF NUM.HELD.BUTTONS=1 THEN SELECTED.PARTIALS=0;	/*	ONLY THIS BUTTON IS BEING HELD - CLEAR PARTIAL SELECT FIELD	*/
		SELECTED.PARTIALS=SELECTED.PARTIALS\BITS(PAR);	/*	NOW THIS PARTIAL IS SELECTED	*/
		IF SOLOED.PARTIALS<>0 THEN SOLOED.PARTIALS=SELECTED.PARTIALS;	/*	SOLOED - SOLO THE SELECTED PARTIALS	*/
		IF (NEW.PAN=0)&(SOLOED.PARTIALS=15) THEN DO;		/*	ALL PARTIALS SOLOED - SET UP KEYBOARD POLYPHONY LPN	*/
			CALL CLEAR.PARAMETERS;					/*	REMOVE EARLIER DISPLAYS	*/
			ACTIVE.PARMS(0)=1;
			ACTIVE.PARMS(1)=(POLY.L-PAR.L)\SHL(POLY.L-PAR.L,8);	/*	SET UP POLYPHONY AS THE PARAMETER	*/
			CALL DISPLAY.PARAMETER.BUTTONS;		/*	DISPLAY BUTTONS (I.E. CLEAR THEM)	*/
			IF NEW.PAN=0 THEN DO;					/*	DO POLYPHONY MODE BUTTON DISPLAY BETTER	*/
				SOLOED.PARTIALS=15;					/*	WAS RESET BY CLEAR.PARAMETERS	*/
				CALL DISPLAY.PARTIAL.BUTTONS;		/*	MAKE PARTIAL BUTTONS BLINK	*/
				CALL COMPUTE.VOLUME.LEVELS;
			END;
		END;
		IF (BOUNCE<>0)&(BOUNCE.PTR=0) THEN DO;	/*	BOUNCE IN PROCESS	*/
			IF PARTIAL.STATE=0 THEN DO;
				PARTIAL.STATE=1; PARTIAL.ONE=PAR;
			END;
			ELSE DO;	/*	BOUNCE PARTIAL A TO PARTIAL B	*/
				CALL BOUNCE.PARTIAL(PARTIAL.ONE,PAR);	/*	COPY IT	*/
				CALL ABORT.BOUNCE.SMT.SKT;			/*	STOP THE OPERATION	*/
			END;
		END;
		ELSE DO;
			CALL DISPLAY.PAR;									/*	DISPLAY FRAME #			*/

			#if (inc.voice.output)
				IF D42.OUTPUT.HAPPENING=0 THEN DO;		/*	MARK BUSY FOR A MOMENT	*/
					D42.OUTPUT.HAPPENING=1;					/*	MUST HOLD PARTIAL FOR	*/
					SPEAK.TIME=REAL.MILLISECONDS-1700;	/*	300 MS TO GET FRAME #	*/
				END;
			#endif
		END;
		CALL COMPUTE.TOGGLE.DISPLAY;				/*	PRESENT TOGGLE STUFF FOR NEWLY SELECTED PARTIAL	*/
		CALL COMPUTE.VOLUME.LEVELS;				/*	COMPUTE NEW VOLUME LEVELS AFTER SOLOING CHANGE	*/
	END;	/*	OF PRESSED	*/
	ELSE DO;												/*	PARTIAL BUTTON RELEASED	*/
		CALL REMOVE.FRAME.NUMBER;					/*	REMOVE FRAME NUMBER FROM DISPLAY (UPON PARTIAL BUTTON RELEASE)	*/
		CALL DISPLAY.PAR;								/*	REDISPLAY CURRENT PARAMETER (IF ONE)	*/
		CALL DISPLAY.LENGTH.LOOP;
	END;
	CALL DISPLAY.PARTIAL.BUTTONS;				/*	PRESENT DISPLAY TO USER	*/
END PARTIAL.BUTTON;

/*	$PAGE - SELECT PARTIAL FROM TDS, TOGGLE SMPTE MODE	*/

SELECT.PARTIAL:PROC(I) PUBLIC SWAPABLE;	/*	ACTIVE A SELECTED PARTIAL ONLY - CALLED FROM TDS	*/
	DCL (I)	FIXED;								/*	PASS PARTIAL 0-3	*/

	/*	Create an event when the user selectes a new partial:	*/

	IF SELECTED.PARTIALS <> BITS(I)
	THEN NEW.TIMBRE.INFO = NEW.TIMBRE.INFO \ 2;

	SELECTED.PARTIALS=BITS(I);			/*	SELECT DESIRED PARTIAL	*/
	IF SOLOED.PARTIALS<>0				/*	IF SOLOING	*/
	THEN SOLOED.PARTIALS=SELECTED.PARTIALS;
	CALL COMPUTE.TOGGLE.DISPLAY;		/*	PRESENT TOGGLE STUFF FOR NEWLY SELECTED PARTIAL	*/
	CALL COMPUTE.VOLUME.LEVELS;		/*	COMPUTE NEW VOLUME LEVELS AFTER SOLOING CHANGE	*/
	CALL DISPLAY.PAR;						/*	REDISPLAY CURRENT PARAMETER (IF ONE)	*/
	CALL DISPLAY.PARTIAL.BUTTONS;		/*	PRESENT DISPLAY TO USER	*/
	CALL DISPLAY.LENGTH.LOOP;
END SELECT.PARTIAL;

DCL SMPTE.ID	LIT '256';				/*	D51 BIT FOR SMPTE BOARD						*/

TOGGLE.SMPTE.STATE:PROC SWAPABLE;	/*	INTERNAL ROUTINE TO TOGGLE SMPTE MODE	*/
	CALL STOP.RECD.MOVE.PLAY;			/*	HAVE TO STOP MOVEMENT FIRST				*/
	EXT.CLOCK.MODE		  = 0;			/*	DISABLE MIDI AND EXT SYNC IN ALL CASES	*/
	TIMING.CLOCK.ENABLE = 0;			/*	DISABLE TIMING CLOCK ACCUMULATION TOO	*/
	NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	HAVE A CHANGE IN SYNC STATE	*/
	NEW.SEQ.INFO=NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
	CALL RESYNC.TIME.BASE;				/*	CLEAN UP EXT SYNC INFO	*/
	IF SMPTE.ONOFF=0 THEN DO;			/*	SMPTE IS OFF - TRY TO TURN ON	*/
		IF (READ("51")&SMPTE.ID)=0
		THEN DO;								/*	SMPTE NOT IN SYSTEM	*/
			CALL DISPLAY.ERR(29);		/*	SMPTE IS NOT AVAIL	*/
			RETURN;
		END;
		DISABLE;								/*	PROTECT FROM INTERRUPTS	*/
		WRITE(D70)=SMPTE.SUBSYS;		/*	SELECT SMPTE BOARD	*/
		IF (READ(D70)&255)<>8
		THEN DO;								/*	MAKE SURE OK		*/
			ENABLE;
			CALL DISPLAY.ERR(29);		/*	SMPTE IS NOT AVAIL	*/
			RETURN;
		END;
		ENABLE;
		CALL INIT.SMPTE;					/*	INIT SMPTE BOARD, SET SMPTE.ONOFF=1	*/
		CALL PLAY.INITIALIZE;			/*	TO ASSURE THAT PLAY TIME VARIABLES ARE AS ACCURATE AS POSSIBLE	*/
	END;
	ELSE DO;
		SMPTE.ONOFF=0;						/*	TURN OFF SMPTE			*/
		SMPTE.RATE =0;
		SMPTE.STATE=0;
	END;
	ABORT.SEQ.NOTES=1;					/*	STOP SEQUENCER NOTES ON MODE CHANGE	*/
END TOGGLE.SMPTE.STATE;

TOGGLE.SMPTE:PROC PUBLIC SWAPABLE;	/*	TOGGLE SMPTE MODE		*/
	CALL CLEAR.PARAMETERS;				/*	CLEAR OTHER PARAMETER BUTTONS FOR SETTING UP SMPTE	*/

	TOGGLE.SMPTE.STATE();				/*	PERFROM THE DETAILED WORK	*/

	CALL DISPLAY.SEQUENCER.STATUS;	/*	BLINK EXT SYNC IF SMPTE IS ON	*/
	ACTIVE.PARMS(0)=1;					/*	SET UP FOR SMPTE DISPLAY		*/
	ACTIVE.PARMS(1)=(SMPTE.L-PAR.L)+SHL(SMPTE.L-PAR.L,8);	/*	STORE ON STACK	*/
	CALL DISPLAY.PARAMETER.BUTTONS;	/*	LIGHT/BLINK SMPTE BUTTON		*/
	CALL DISPLAY.SEQUENCER.STATUS;	/*	BLINK EXT SYNC IF SMPTE IS ON	*/
	IF NEW.PAN<>0 THEN CALL DISPLAY.PAR;	/*	DISPLAY PARAMETER IN UPPER ONLY IF NEW KEYBOARD	*/
	CALL DISPLAY.SMODE(SM.MODE);		/*	DISPLAY SM.MODE IN LOWER HALF	*/
END TOGGLE.SMPTE;

SELECT.PARAMETER:PROC(PRM#) PUBLIC SWAPABLE;	/*	ACTIVATE A PARAMETER SELECTION FROM TDS	*/
	DCL (PRM#,I,PRM)	FIXED;

	IF (PRM#>=12)&(PRM#<=35)
	THEN DO;
		SCALE.ADJUST.IS.ACTIVE=0;			/*	BACK TO COEF MODE IF THAT IS WHAT IS DESIRED	*/
		IF PRM#<24 THEN HGS=0;				/*	SELECT CORRECT HGS	*/
		ELSE DO; HGS=1; PRM#=PRM#-12; END;
	END;

	PRM=PRM#;									/*	ASSUME BLINKING MODE NOT REQUIRED	*/
	I=0;
	DO WHILE BLINKTABLE(I)<>0;				/*	GET PAR BUTTON TO LIGHT AND CHECK FOR BLINKING MODE PARAMETER ON OLD KEYBOARD	*/
		IF BLINKTABLE(I+1)=PRM# THEN PRM=BLINKTABLE(I);
		I=I+2;
	END;

	IF ((PRM =PRM#)&(IN.BLINK.MODE<>0))
	OR ((PRM<>PRM#)&(IN.BLINK.MODE =0))
	THEN CALL TOGGLE.BLINK;					/*	ENTER/EXIT BLINK MODE IF REQUIRED	*/

	IF (PRM == (MIDI.L - PAR.L))
		MIDI.PARAM.ID = 0;

	IF (ACTIVE.PARMS(0)<>1)					/*	MORE THAN ONE DISPLAYED	*/
	OR (ACTIVE.PARMS(1)<>(PRM\SHL(PRM#,8)))
	THEN DO;
		CALL CLEAR.PARAMETERS;				/*	CLEAR OUT ACTIVE LIST, TONE BEND INFO	*/
		ACTIVE.PARMS(0)=1;
		ACTIVE.PARMS(1)=PRM\SHL(PRM#,8);
	END;

	CALL DISPLAY.PAR;							/*	DISPLAY PARAMETER	*/
	CALL DISPLAY.PARAMETER.BUTTONS;		/*	PRESENT DISPLAY TO USER	*/
	CALL DISPLAY.HGS;							/*	IN CASE IT CHANGED	*/
	CALL DISPLAY.LENGTH.LOOP;

END SELECT.PARAMETER;

/*	$SUBTITLE  PROCESS PARAMETER BUTTONS (ATTACK, DECAY, MANY OTHERS)	*/

DCL FLICKER.PARAMS	FIXED PUBLIC;	/*	SET TRUE TO START FLICKER - MOSTLY USED IN 173-PRF3 & 400-MISC	*/
DCL PERFORM.FLICKER	FIXED PUBLIC;	/*	SET TRUE BELOW TO PERFORM PARAMETER FLICKERING	*/

DCL (PRESET.KBD.ENVELOPE)			FIXED PUBLIC;
DCL (NEW.FRAME.COEFF)				FIXED PUBLIC;
DCL (KBD.VAL)							FIXED PUBLIC;
DCL (NEW.KBD.ENV)						FIXED PUBLIC;

DCL (HELD.KBD.ENV.BUTTONS)			FIXED PUBLIC;
DCL (HELD.SCALE.ADJUST.BUTTONS)	FIXED PUBLIC;
DCL (HELD.TNAME.BUTTON)				FIXED PUBLIC;
DCL (HELD.VIBR.BUTTON)				FIXED PUBLIC;
DCL (HELD.SMPTE.BUTTON)				FIXED PUBLIC;
DCL (HELD.EXT.BUTTON)				FIXED PUBLIC;
DCL (HELD.PVOL.BUTTON)				FIXED PUBLIC;
DCL (HELD.PTUN.BUTTON)				FIXED PUBLIC;
DCL (HELD.RATE.BUTTON)				FIXED PUBLIC;
DCL (HELD.MARK.BUTTON)				FIXED PUBLIC;
DCL (HELD.XPOS.BUTTON)				FIXED PUBLIC;
DCL (HELD.SKT.BUTTON)				FIXED PUBLIC;
DCL (HELD.POLY.BUTTON)				FIXED;

DCL (HELD.TPAN.BUTTON)				FIXED;
DCL (TIME.OF.TPAN.PRESS)			FIXED;

//	Display.Track.Format.Change() consists of code that was extracted from PARAMETER.BUTTON()
//	and made public so that the G-page can call it after updating TRACK.FORMAT
Display.Track.Format.Change: proc public swapable;
	dcl trk_index			fixed;
	dcl first_held_trk	fixed;

	if (num.of.held.track.buttons == 0)
	{	//	redisplay current parameter in new format
		call clear.upper;
		call display.par;					
	}
	else
	{
		write(mam)		= tbut.ptr;
		trk_index		= 0;
		first_held_trk	= 0;

		while (trk_index ilt num.track.buttons)
		{
			first_held_trk	= read(mdi);						//	read the track mapping value
			if ((first_held_trk & b.held.trk) != 0)	trk_index	= num.track.buttons;	//	if this track button is held then exit loop
			else													trk_index	= trk_index + 1;		//	else step to next button
		}

		first_held_trk	= first_held_trk & 255;				//	extract absolute track number

		if
		(	(new.pan != 0)											//	new panel
		&& (	(	(first_held_trk ige first.lod.track)	//	track is a lod track
				&&	(first_held_trk ilt last.lod.track)
				)
			||	(find.first.note(first_held_trk) == 0)		//	or track is empty
			)
		)
		{
			emit.string(16,'Format: ');
			do case TRACK.FORMAT;
				emit.string(24,'BEATS   ');
				emit.string(24,'MEASURES');
				emit.string(24,'SECONDS ');
				emit.string(24,'SMPTE   ');
			end;
			both.display			= true;
			upper.disp				= start.disp;			//	indicate track start displayed in upper half
			supress.beat.display	= true;					//	stop beat displays momentarily
			beat.display.time		= real.milliseconds;	//	hold display for 5 seconds
		}
		else
		{	compute.start.time.display(first_held_trk);	//	redisplay trk start in new format
		}
	}
end Display.Track.Format.Change;

PARAMETER.BUTTON: PROC (PRM, VALUE) PUBLIC SWAPABLE;	/*	PROCESS PARAMETER BUTTON	*/
	DCL (PRM, VALUE)				FIXED;
	DCL (I, J, K, L, M, PRM#)	FIXED;
	DCL LAST							FIXED STATIC;
	DCL TINFO.BASE					FIXED;
	DCL (KBD.LOOKUP) DATA	/*	MAP BUTTONS TO HELD.KBD.ENV.BUTTONS	*/
		(1,2,0,0,0,0,4,8);	/*	MAP 4,5, 10,11 TO 1,2,4,8				*/

	NUM.HELD.BUTTONS = NUM.HELD.BUTTONS - 1 + VALUE + VALUE;

	IF (PRM>=12)&(PRM<=23)	/*	KEEP TRACK OF HELD SCALE ADJUST BUTTONS	*/
	THEN DO;						/*	COEF BUTTON PRESSED	*/
		HELD.SCALE.ADJUST.BUTTONS=HELD.SCALE.ADJUST.BUTTONS XOR BITS(PRM-12);
	END;

	IF NEW.PAN=0 THEN DO;	/*	MAP KBD ENV BUTTONS TO HELD.KBD.ENV FOR OLD PANEL	*/
		IF (PRM=4)\(PRM=5)\(PRM=10)\(PRM=11)	/*	KEEP TRACK OF HELD KBD ENVELOPE BUTTONS FOR PRESET OF THEM	*/
		THEN HELD.KBD.ENV.BUTTONS=HELD.KBD.ENV.BUTTONS XOR KBD.LOOKUP(PRM-4);
	END;
	ELSE DO;						/*	MAP BUTTONS TO HELD.KBD.ENV FOR NEW PANEL	*/
		IF (PRM=51)\(PRM=52) THEN DO;	/*	A KBD ENVELOPE BUTTON	*/
			HELD.KBD.ENV.BUTTONS=HELD.KBD.ENV.BUTTONS XOR BITS(PRM-51);
			NEW.KBD.ENV=0;
		END;
	END;

	#if (true)
	//	OUCH, OUCH, OUCH.  Although the following block looks ridiculous, and will require extra
	//	effort and care when being modified, it makes for substantially faster processing.

	/*	TOGGLE HELD BUTTON STATUS	*/
	if (PRM ige (PTUN.L-PAR.L)) and (PRM ile (MIDI.L-PAR.L))
	then do case PRM-(PTUN.L-PAR.L);
		//	Case  0: PRM = (PTUN.L	  - PAR.L)					/*	PARTIAL TUNE	*/
		HELD.PTUN.BUTTON		= HELD.PTUN.BUTTON		XOR 1;
		//	Case  1: PRM = (VWAVE.L	  - PAR.L)					/*	VIBRATO WAVE	*/
		HELD.VIBR.BUTTON		= HELD.VIBR.BUTTON		XOR 1;
		;;;;;;;;;;;;;;;;;
		//	Case 19: PRM = (PVOL.L	  - PAR.L)					/*	PARTIAL VOL		*/
		HELD.PVOL.BUTTON		= HELD.PVOL.BUTTON		XOR 1;
		;;;;;;;;
		//	Case 28: PRM = (POLY.L	  - PAR.L)					/*	HELD POLY BUTTON	*/
		HELD.POLY.BUTTON		= HELD.POLY.BUTTON		XOR 1;
		;;;;
		//	Case 33: PRM = (RRATE.L	  - PAR.L)					/*	HOLDING REPEAT RATE BUTTON	*/
		HELD.RATE.BUTTON		= HELD.RATE.BUTTON		XOR 1;
		;
		//	Case 35: PRM = (TNAME.L	  - PAR.L)					/*	HOLDING TIMBRE NAME BUTTON - TWO SPECIAL HOUSE CHECKS	*/
		HELD.TNAME.BUTTON		= HELD.TNAME.BUTTON		XOR 1;
		;;;;;;;;;;;;;;;;;;;;
		//	Case 56: PRM = (SPEED.L	  - PAR.L)					/*	HOLDING SPEED BUTTON			*/
		HELD.SPEED.BUTTON		= HELD.SPEED.BUTTON		XOR 1;
		//	Case 57: PRM = (CLICK.L	  - PAR.L)					/*	HOLDING CLICK RATE BUTTON	*/
		HELD.CLIK.BUTTON		= HELD.CLIK.BUTTON		XOR 1;
		;
		//	Case 59: PRM = (SMPTE.L	  - PAR.L)					/*	HOLDING SMPTE BUTTON	*/
		HELD.SMPTE.BUTTON		= HELD.SMPTE.BUTTON		XOR 1;
		;
		//	Case 61: PRM = (MARK.L	  - PAR.L)					/*	HOLDING MARK BUTTON	*/
		HELD.MARK.BUTTON		= HELD.MARK.BUTTON		XOR 1;
		;;;;;;;
		//	Case 69: PRM = (STARTUP.L - PAR.L)					/*	HELD SEQ NAME BUTTON	*/
		HELD.SEQNAME.BUTTON	= HELD.SEQNAME.BUTTON	XOR 1;
		;;;
		//	Case 73: PRM = (TRROUT.L  - PAR.L)					/*	HELD TRACK ROUTE	*/
		HELD.TRINF.BUTTON		= HELD.TRINF.BUTTON		XOR 1;		/*	SET BIT 0	*/
		//	Case 74: PRM = (TRVOL.L	  - PAR.L)					/*	HELD TRACK VOL		*/
		HELD.TRINF.BUTTON		= HELD.TRINF.BUTTON		XOR 2;		/*	SET BIT 1	*/
		;;
		//	Case 77: PRM = (MIDI.L	  - PAR.L)					/*	HELD MIDI BUTTON	*/
		HELD.MIDI.BUTTON		= HELD.MIDI.BUTTON		XOR 1;
	end;

	#else
	/*	TOGGLE HELD BUTTON STATUS	*/
	IF (PRM=(VWAVE.L-PAR.L))										/*	VIBRATO WAVE	*/
	THEN HELD.VIBR.BUTTON	 = HELD.VIBR.BUTTON	  XOR 1;
	ELSE IF (PRM=(PVOL.L-PAR.L))									/*	PARTIAL VOL	*/
	THEN HELD.PVOL.BUTTON	 = HELD.PVOL.BUTTON	  XOR 1;
	ELSE IF (PRM=(PTUN.L-PAR.L))									/*	PARTIAL TUNE	*/
	THEN HELD.PTUN.BUTTON	 = HELD.PTUN.BUTTON	  XOR 1;
	ELSE IF (PRM=(TNAME.L-PAR.L))									/*	HOLDING TIMBRE NAME BUTTON - TWO SPECIAL HOUSE CHECKS	*/
	THEN HELD.TNAME.BUTTON	 = HELD.TNAME.BUTTON	  XOR 1;
	ELSE IF (PRM=(SMPTE.L-PAR.L))									/*	HOLDING SMPTE BUTTON	*/
	THEN HELD.SMPTE.BUTTON	 = HELD.SMPTE.BUTTON	  XOR 1;
	ELSE IF (PRM=(CLICK.L-PAR.L))									/*	HOLDING CLICK RATE BUTTON	*/
	THEN HELD.CLIK.BUTTON	 = HELD.CLIK.BUTTON	  XOR 1;
	ELSE IF (PRM=(SPEED.L-PAR.L))									/*	HOLDING SPEED BUTTON	*/
	THEN HELD.SPEED.BUTTON	 = HELD.SPEED.BUTTON	  XOR 1;
	ELSE IF (PRM=(RRATE.L-PAR.L))									/*	HOLDING REPEAT RATE BUTTON	*/
	THEN HELD.RATE.BUTTON	 = HELD.RATE.BUTTON	  XOR 1;
	ELSE IF (PRM=(MARK.L-PAR.L))									/*	HOLDING MARK BUTTON	*/
	THEN HELD.MARK.BUTTON	 = HELD.MARK.BUTTON	  XOR 1;
	ELSE IF (PRM=(TRROUT.L-PAR.L))								/*	HELD TRACK ROUTE	*/
	THEN HELD.TRINF.BUTTON	 = HELD.TRINF.BUTTON	  XOR 1;	/*	SET BIT 0		*/
	ELSE IF (PRM=(TRVOL.L-PAR.L))									/*	HELD TRACK VOL	*/
	THEN HELD.TRINF.BUTTON	 = HELD.TRINF.BUTTON	  XOR 2;	/*	SET BIT 1		*/
	ELSE IF (PRM=(MIDI.L-PAR.L))									/*	HELD MIDI BUTTON	*/
	THEN HELD.MIDI.BUTTON	 = HELD.MIDI.BUTTON	  XOR 1;
	ELSE IF (PRM=(POLY.L-PAR.L))									/*	HELD POLY BUTTON	*/
	THEN HELD.POLY.BUTTON	 = HELD.POLY.BUTTON	  XOR 1;
	ELSE IF (PRM=(STARTUP.L-PAR.L))								/*	HELD SEQ NAME BUTTON	*/
	THEN HELD.SEQNAME.BUTTON = HELD.SEQNAME.BUTTON XOR 1;

	#endif

	/*	$PAGE - HANDLE MORE SPECIAL CASES (CAN RETURN FROM HERE ON)	*/

	IF (HELD.MIDI.BUTTON<>0) THEN DO;			/*	HOLDING MIDI BUTTON	*/
		IF (PRM=(PTUN.L-PAR.L))						/*	AND PRESSED PTUNING BUTTON	*/
		THEN DO;
			IF VALUE=0 THEN RETURN;					/*	DO NOTHING ON RELEASE	*/
			WRITE(MD)=TRK.HEAD.LOOKUP(0,THD.ACTIVE.MIDI.RTES) XOR B.PWHEEL;	/*	TOGGLE BIT IN TRK HEAD	*/
			NEW.PRM.INFO=NEW.PRM.INFO\16;			/*	SET BIT TO INDICATE OVERALL CHANGE	*/
			CALL COMPUTE.RTE.BUTTONS;
			RETURN;
		END;
		ELSE IF (PRM=(POLY.L-PAR.L))				/*	MIDI + POLYPHONY	*/
		THEN DO;
			IF VALUE=0									/*	DO NOTHING ON RELEASE	*/
			OR (MAX.MIDINET.CHAN<>0)				/*	DISSALLOW IF MIDINET IS PRESENT	*/
			THEN RETURN;
			IF UPPER.DISP=MIDIPOLY.DISP			/*	TOGGLE IF DISPLAYED	*/
			THEN DO;

			/*	Create a system event if the MIDI routing for a	*/
			/*	sequencer track (in or out) changes.				*/

				NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;

				POLY.TIMBRE.MIDI.CONTROL=POLY.TIMBRE.MIDI.CONTROL XOR 1;
				
				if ((POLY.TIMBRE.MIDI.CONTROL | OMS.MIDI.ENABLED | MAX.MIDINET.CHAN) != 0)
					MIDI.INPUT.ENABLED = true;
				else
					MIDI.INPUT.ENABLED = false;
				
				IF POLY.TIMBRE.MIDI.CONTROL=0					/*	CHANGED MAPPING FROM RECORDER KBD	*/
				THEN DO I=NUM.KBD.TRACKS TO MAX.INPUTS-1;	/*	LOOP THRU ALL INPUT CHANNELS	*/
					IF I>1											/*	DIRECTED AT NON KBD TRACKS	*/	// was midi  mapped
					THEN CALL CLEAR.POLY.TIMBRE.NOTES(I);	/*	KILL THOSE NOTES TO AVOID STUCK ONES	*/
				END;
				ELSE CALL CLEAR.ALL.NOTES;						/*	KILL ALL KEYBOARD NOTES	*/
			END;
			IF NEW.PAN THEN DO;									/*	MAKES SENSE HERE ONLY	*/
				CALL CLEAR.DISPLAY;
				IF POLY.TIMBRE.MIDI.CONTROL=0 THEN DO;
					CALL EMIT.STRING(0,'MIDI Chan MappedTo: Keyboard');
				END;
				ELSE DO;
					CALL EMIT.STRING(0,'MIDI Chan MappedTo: Recorder');
				END;
				BOTH.DISPLAY = 1;
				UPPER.DISP=MIDIPOLY.DISP;
				SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
				BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
			END;
			RETURN;
		END;

		ELSE IF (PRM == (SMPTE.L - PAR.L))		/*	HOLDING MIDI; PRESSING SMPTE	*/
		{
			IF VALUE=0 THEN RETURN;					/*	DO NOTHING ON RELEASE	*/

			if (MIDI.PARAM.ID == 0)					/*	IF JUST PRESSED MIDI BUTTON, NOW SHOW SYNC OUTPUT	*/
				MIDI.PARAM.ID = 1;

			ELSE IF (UPPER.DISP == (MIDI.L - PAR.L))	/*	ELSE IF SHOWING MIDI SYNC STYLE, TOGGLE IT	*/
			{
				call stop.recd.move.play;
				MIDI.SYNC.IS.TC = MIDI.SYNC.IS.TC XOR 1;

				if (midi.sync.is.tc == 0)			/*	clear mtc display when disabling mtc	*/
					DISPLAY.MTC = 0;

				else if (midi.sync.out != 0)		/*	send out full frame when changing	*/
				{											/*	sync to midi tc							*/
					MIDI.FULL.FRAME(play.time.msb, play.time.lsb);
					NEW.MTC.VAL = 0;
				}

				/*	Create a system event when changing the	*/
				/*	output sync:									*/

				new.seq.info = new.seq.info \ 512;
				call display.sequencer.status;
			}

			DISPLAY.PAR();								/*	DISPLAY 'MIDI TC  OUT:' OR 'MIDI CLK OUT:'	*/

			IF (MIDI.SYNC.IS.TC != 0)				/*	IF SYNC MODE IS TIME CODE							*/
				DISPLAY.SMODE(SM.MODE);				/*	DISPLAY MIDI TIME CODE IN LOWER HALF			*/
			ELSE											/*	ELSE REMOVE MODE DISPLAY							*/
				CLEAR.LOWER();

			RETURN;
		}

		ELSE IF PRM<>(MIDI.L-PAR.L) THEN RETURN;	/*	ONLY PTUN & MIDI BUTTONS ALLOWED	*/
	END;

	IF (PRM=(TRROUT.L-PAR.L)) THEN DO;		/*	TRACK ROUTING BUTTON		*/
		IF POLYNUMS > 1 THEN DO;				/*	IF MULTIPLE BINS			*/
			IF VALUE=1 THEN DO;					/*	BUTTON PRESS				*/
				DO J=0 TO POLYNUMS - 1;
					CALL BLINK(TIMB.L+J);		/*	BLINK BIN BUTTONS			*/
				END;
			END;
			ELSE DO;									/*	BUTTON RELEASE				*/
				DO CASE BUTMODE;					/*	FIX UP TIM/SEQ BUTTONS	*/
					CALL DISPLAY.TIMBRE.RECALL.BUTTONS;		/*	0	*/
					CALL DISPLAY.BANK.BUTTONS;					/*	1	*/
					CALL DISPLAY.SEQUENCER.RECALL.BUTTONS;	/*	2	*/
				END;
			END;
		END;
		CALL DISPLAY.TRACK.BUTTONS;			/*	CLEAR/SET TRACK BUTTONS	*/
	END;

	IF (PRM=(TRVOL.L-PAR.L))					/*	IN CASE HELD TRACK VOL	*/
	OR (PRM=(CLICK.L-PAR.L))					/*	IN CASE HELD CLICK WITH CLICK TRACK	*/
	THEN DO;
		CALL DISPLAY.TRACK.BUTTONS;			/*	SET/CLEAR TRACK BUTTONS	*/
	END;

	IF (PRM=(MIDI.L-PAR.L)) THEN DO;			/*	SPECIAL CASE FOR MIDI BUTTON	*/

		/*	HANDLE PRESS OF MIDI BUTTON:	*/

		IF VALUE<>0 THEN DO;
			IF NEW.PAN THEN DO;
				CALL CLEAR.LOWER;
				CALL EMIT.STRING(16,'SELECT PATCHING');
				LOWER.DISP = MIDISEL.DISP;
			END;
			FLICKER.PARAMS=1;						/*	PRESSING FIRST BUTTON - SET UP FOR FLICKER DISPLAY	*/
			CALL COMPUTE.RTE.BUTTONS;			/*	COMPUTE NEW RTE BUTTON DISPLAY ON PRESS	*/
			CALL DISPLAY.TRACK.BUTTONS;		/*	SHOW MIDI TRACKS ENABLED	*/
			MIDI.PARAM.ID = 0;					/*	PARAM IS KBD MIDI ROUTING	*/
			/*	and fall through to normal parameter button press	*/
		END;
		ELSE DO;										/*	RELEASE OF MIDI BUTTON	*/
			CALL DISPLAY.PAR;						/*	IN CASE MIDI NOTE# IS IN UPPER	*/

			IF ((NEW.PAN) && (LOWER.DISP == MIDISEL.DISP))
			THEN CALL CLEAR.LOWER;				/*	REMOVE PROMPT FROM DISPLAY	*/

			IF PLAY<>0 THEN NEW.BEAT.NUMBER=1;	/*	CAUSE BEAT DISPLAY TO REFRESH ASAP	*/
			PERFORM.FLICKER=0;						/*	RESET FLAG ON RELEASE OF MIDI BUTTON	*/
			FLICKER.PARAMS =0;
			CALL COMPUTE.RTE.BUTTONS;				/*	COMPUTE NEW RTE BUTTON DISPLAY ON RELEASE	*/
			RETURN;
		END;
	END;

	IF (PRM=(SMPTE.L-PAR.L)) THEN DO;			/*	SPECIAL CASE FOR PRESS OR RELEASE OF SMPTE BUTTON	*/
		IF VALUE=0 THEN DO;
			IF NEW.PAN=0								/*	ORIG PANEL	*/
			AND (LOWER.DISP<>SMODE.DISP)			/*	NOT DISPLAYING SMODE	*/
			THEN CALL DISPLAY.PAR;					/*	THEN DISPLAY MINUTES/SECONDS	*/
			RETURN;
		END;
		IF HELD.EXT.BUTTON<>0 THEN DO;			/*	EXT BUTTON HELD	*/
			CALL TOGGLE.SMPTE;						/*	TOGGLE SMPTE MODE	*/
			RETURN;
		END;												/*	OTHERWISE TREAT AS BUTTON PRESS	*/
		IF (0)											/*	COULD DELETE EXTERNAL SYNC MODE ON SIMPLE	*/
		{													/*	PRESS OF SMPTE BUTTON????	*/
			IF EXT.CLOCK.MODE<>0 THEN DO;
				CALL STOP.RECD.MOVE.PLAY;			/*	STOP SEQUENCER		*/
				EXT.CLOCK.MODE=0;						/*	DELETE EXT CLOCK	*/
				NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	HAVE A CHANGE IN SYNC STATE	*/
				NEW.SEQ.INFO=NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
				CALL RESYNC.TIME.BASE;				/*	CLEAN UP EXT SYNC INFO	*/
				CALL DISPLAY.SEQUENCER.STATUS;	/*	LIGHT BUTTONS			*/
			END;
		}
		IF NEW.PAN=0 THEN DO;						/*	OLD PANEL	*/
			IF (LOWER.DISP<>SMODE.DISP)			/*	IF SMPTE MODE IS NOT DISPLAED	*/
			THEN DO;
				CALL CLEAR.PARAMETERS;				/*	ZIPPO	*/
				CALL DISPLAY.SMODE(SM.MODE);		/*	NEW PANEL - SMODE IN LOWER HALF THOUGH	*/
				RETURN;									/*	THAT IS ALL FOR NOW	*/
			END;											/*	ELSE NORMAL BUTTON PRESS (PARAMETER)	*/
		END;

		ELSE IF (( SMPTE.ONOFF				  == 0)	/*	IF NOT DOING SMPTE SYNCING	*/
		&&			((MIDI.SYNC.OUT & 0x80FF) != 0)	/*	AND ARE DOING MIDI SYNC OUT	*/
		&&			( MIDI.SYNC.IS.TC			  != 0))	/*	DOING MIDI TC OUT				*/
		{
			DISPLAY.MTC = DISPLAY.MTC XOR 1;			/*	TOGGLE MTC DISPLAY			*/

			IF (DISPLAY.MTC != 0)						/*	IF NOW DISPLAYING MTC,		*/
				NEW.MTC.VAL = 1;							/*	PRESENT MOST RECENT VALUE	*/
			ELSE												/*	TO USER							*/
			{
				CLEAR.LOWER();
				NEW.BEAT.NUMBER		= 1;
				SUPRESS.BEAT.DISPLAY	= 0;
			}
		}

		ELSE
		CALL DISPLAY.SMODE(SM.MODE);		/*	NEW PANEL - SMODE IN LOWER HALF THOUGH	*/
	END;


	IF  (NEW.PAN<>0)
	AND ((NUM.OF.HELD.TRACK.BUTTONS<>0)			/*	CLICK RATE WITH TRACK BUTTON HELD	*/
	OR   (HELD.MARK.BUTTON			 <>0)			/*	OR MARK BUTTON OR STARTLOOP			*/
	OR   (HELD.STARTLOOP.BUTTON	 <>0)			/*	BUTTON -- TOGGLE DISPLAY MODE			*/
	OR   (HELD.INSERT.BUTTON		 <>0)
	OR   (HELD.DELETE.BUTTON		 <>0))
	AND (PRM=(CLICK.L-PAR.L))
	THEN DO;

		ALLOW.TRACK.GROUP.DEFINE = FALSE;		/*	DISALLOW GROUP DEFINE WHILE CHANGING	*/

		IF VALUE=0 THEN RETURN;						/*	BUTTON RELEASE	*/

		TRACK.FORMAT=TRACK.FORMAT+1;				/*	TOGGLE TRACK FORMAT DISPLAY	*/
		IF TRACK.FORMAT=4 THEN TRACK.FORMAT=0;

		Display.Track.Format.Change();
		RETURN;
	END;

	IF (NEW.PAN<>0)&(INFO.MODE<>0) THEN DO;				/*	INFO MODE	*/
		IF (PRM=(POLY.L-PAR.L)) THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.NUMBER(0 , NUM.PBLKS  , 0, LEFT.JUST);
			CALL EMIT.NUMBER(16, MEASURE.PDL, 0, LEFT.JUST);
			CALL EMIT.NUMBER(10, PAR.LEN    , 0, RIGHT.JUST);
			CALL EMIT.NUMBER(26, NAH.LEN    , 0, RIGHT.JUST);
			RETURN;													/*	DO NOTHING FOR NOW (INFO BUTTON)	*/
		END;
		ELSE CALL INFO.BUTTON.PRESS;			/*	GET OUT OF INFO MODE IF OTHER BUTTON PRESSED	*/
	END;

	/*	$PAGE - CHANGE RTE PATCHING	*/

	IF (HELD.RTE.BUTTONS<>0) THEN DO;					/*	CHANGE RTE PATCHING	*/
		IF VALUE=0 THEN RETURN;								/*	RETURN ON RELEASE - NOTHING REQUIRED	*/
		IF IN.BLINK.MODE<>0 THEN DO;						/*	BLINKING MODE - CHECK FOR MAPPING	*/
			I=0;
			DO WHILE BLINKTABLE(I)<>0;						/*	REMAP PRMS TO BLINKING ONES IF NECESSARY	*/
				IF BLINKTABLE(I)=PRM THEN PRM=BLINKTABLE(I+1);	/*	REMAP	*/
				I=I+2;
			END;
		END;

		PRM=PRM+PAR.L;											/*	COMPUTE LPN FOR THIS BUTTON	*/
		IF PRM=VE.SUST.L THEN PRM=VE.PEAK.L;			/*	MAP THESE BUTTONS TOGETHER	*/
		IF PRM=PVOL.L    THEN PRM=VE.PEAK.L;
		IF PRM=DYNENVH.L THEN PRM=DYNENVL.L;
		IF PRM=PCHORUS.L THEN PRM=CHORUS.L ;			/*	PARTIAL CHORUS/CHORUS	*/

		IF  ((HELD.RTE.BUTTONS&512)<>0)					/*	HOLDING OVERWRITE BUTTON	*/
		AND (PRM=PTUN.L)										/*	AND PRESSED PTUNING BUTTON	*/
		THEN DO;
			RTE.OVERWRITE.BITS=RTE.OVERWRITE.BITS XOR B.PWHEEL;	/*	TOGGLE PITCH WHEEL OVERDUB ENABLE	*/
			NEW.PRM.INFO=NEW.PRM.INFO\16;					/*	SET BIT TO INDICATE OVERALL CHANGE	*/
		END;

		K=0;L=0;													/*	INITIALIZE TO NOT FOUND	*/
		DO I=0 TO 15;											/*	SEE IF LEGIT PARAMETER	*/
			IF (SAMPLED.LOOKUP(I)&255)=PRM THEN DO;	/*	LEGIT SAMPLED PARAM	*/
				K=0; L=BITS(I);								/*	GET BIT	*/
			END;
			IF (CONTINUOUS.LOOKUP(I)&255)=PRM THEN DO;	/*	CONTINUOUS PARAMETER	*/
				K=1; L=BITS(I);
			END;
		END;
		IF (K\L)=0 THEN RETURN;						/*	PARAMETER NOT AVAILABLE	*/

		TINFO.BASE=TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);	/*	GET PTR TO TINFO BLOCK	*/

		IF (TINFO.BASE<>0)							/*	IF BLOCK WAS SUCCESSFULLY ALLOCATED	*/
		AND ((RECD=0)\(RECD.TRK=0))				/*	AND NOT RECORDING	*/
		THEN DO I=0 TO 7;								/*	CHECK EACH SOURCE - ELSE LEAVE OFF WITH ERR11 DISPLAY	*/
			IF (HELD.RTE.BUTTONS&(BITS(I)\256))<>0 THEN DO;	/*	CHANGE PARAMETERS FOR THESE SOURCES	*/
				J=TINFO.BASE+TI.RTE+I*5;			/*	COMPUTE POINTER	*/
				IF (HELD.RTE.BUTTONS&256)<>0 THEN DO;	/*	CLEAR	*/
					M=P.LOOKUP(J+1+K);
					WRITE(MD)=M&(NOT(L));
					M=P.LOOKUP(J+3+K);
					WRITE(MD)=M&(NOT(L));
				END;
				ELSE DO;											/*	PERFORM INVERT/TOGGLE	*/
					M=P.LOOKUP(J+3+K);
					IF (M&L)<>0 THEN WRITE(MD)=M XOR L;	/*	INVERTED TO OFF	*/
					ELSE DO;										/*	CHECK FOR ON TO INVERTED	*/
						M=P.LOOKUP(J+1+K);
						IF (M&L)<>0 THEN DO;					/*	ON TO INVERTED	*/
							WRITE(MD)=M XOR L;				/*	TURN OFF INVERTED BIT	*/
							M=P.LOOKUP(J+3+K);
							WRITE(MD)=M XOR L;				/*	TURN ON INVERT BIT	*/
						END;
						ELSE DO;									/*	OF TO ON	*/
							WRITE(MD)=M XOR L;				/*	TURN ON NORMAL PATCH	*/
						END;
					END;
				END;
				NEW.PRM.INFO=NEW.PRM.INFO\16;	/*	SET BIT TO INDICATE OVERALL CHANGE	*/
			END;
		END;
		CALL COMPUTE.RTE.BUTTONS;	/*	COMPUTE NEW RTE BUTTON DISPLAY	*/
		CALL COMPUTE.RBITS(0);		/*	RE-COMPUTE REAL TIME EFFECTS BITS	*/
		RETURN;							/*	DONE WITH IT	*/
	END;

	/*	$PAGE - HANDLE PRESS OF PARAMETER BUTTON	*/

	IF VALUE<>0 THEN DO;				/*	PARAMETER SELECT BUTTON BEING PRESSED	*/
		IF NEW.PAN=0 THEN DO;									/*	CHECK FOR BLINK MODE TOGGLE ON OLD PANEL	*/
			IF ((LAST=PTUN.L-PAR.L)&(PRM=VWAVE.L-PAR.L))	/*	SEE IF TOGGLE OF BLINK MODE DESIRED	*/
			OR ((LAST=VWAVE.L-PAR.L)&(PRM=PTUN.L-PAR.L))
			THEN CALL TOGGLE.BLINK;								/*	SWITCH MODES	*/
		END;
		LAST=PRM;													/*	SAVE MOST RECENTLY PRESSED BUTTON	*/
		PRM#=0;														/*	INITALIZE	*/
		IF IN.BLINK.MODE<>0 THEN DO;							/*	BLINKING MODE - CHECK FOR MAPPING	*/
			I=0;
			IF (PRM>=12)&(PRM<=23) THEN PRM#=PRM;			/*	ALLOW 12 COEEF BUTTONS IN BLINK MODE	*/
			ELSE DO WHILE BLINKTABLE(I)<>0;					/*	SEE IF A LEGIT BLINKING PARAMETER	*/
				IF BLINKTABLE(I)=PRM THEN PRM#=BLINKTABLE(I+1);
				I=I+2;
			END;
			IF PRM#=0 THEN DO;			/*	NOT A BLINKING PARAMETER	*/
				IF NEW.PAN=0 THEN CALL TOGGLE.BLINK;	/*	EXIT BLINK MODE ON OLD PANEL OF NON-BLINK PARAM SELECTED	*/
				PRM#=PRM;					/*	JUST USE NORMAL PARAMETER	*/
			END;								/*	EXIT BLINK MODE IF OTHER BUTTON PRESSED	*/
		END;
		ELSE PRM#=PRM;	/*	NOT BLINKING MODE - PARAMETER INDEX NUMBER IS EASILY COMPUTED!!	*/

		/*	$PAGE - PERFORM BUTTON ALGORITHM, STORE ON STACK:	*/

		IF  (NEW.PAN			 =0)			/*	IF  THIS COMPILATION IS FOR OLD PANEL	*/
		AND (IN.BLINK.MODE	 =0)			/*	AND NOT IN BLINK MODE	*/
		AND (HELD.VIBR.BUTTON<>0)			/*	AND VIBRATO WAVE IS HELD	*/
		AND (PRM#>=(VRATE.L-PAR.L))		/*	AND THIS IS THE VRATE,VDEPTH,VATK BUTTONS	*/
		AND (PRM#<=( VATK.L-PAR.L))
		THEN DO;									/*	SPECIAL LOGIC FOR VIBRATO MODIFIER BUTTONS	*/
			CALL STACK.ON.PANEL("100000"+INVERT.L+(PRM#-(VRATE.L-PAR.L)));	/*	MAP TO PRESS OF INVERT/RAISE/QUANTIZE	*/
		END;
		ELSE IF (NEW.PAN			 <>0)		/*	NEW KEYBOARD				*/
		AND     (HELD.CLIK.BUTTON<>0)		/*	HOLDING CLICK RATE BUTTON	*/
		AND     (PRM#=(SPEED.L-PAR.L))	/*	PRESSING SPEED BUTTON	*/
		THEN DO;									/*	SELECT BEATS PER MEASURE PARM	*/
			IF (UPPER.DISP=(BPM.L-PAR.L))
			THEN DO;
				BPM.CURSOR = BPM.CURSOR XOR 1;
				CALL DISPLAY.METER;
			END;
			ELSE DO;
				CALL CLEAR.PARAMETERS;
				CALL ADD.PARM.TO.ACTIVE.LIST(BPM.L-PAR.L,BPM.L-PAR.L);
			END;
			TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
			CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
		END;
		ELSE DO;	/*	ACTIVATE NORMAL PARAMETER BUTTON ALGORITHM	*/
			CALL ADD.PARM.TO.ACTIVE.LIST(PRM,PRM#);
			CALL DISPLAY.LENGTH.LOOP;
		END;
		CALL DISPLAY.PAR;	/*	DISPLAY PARAMETER	*/
		IF  (PRM#=(SPEED.L-PAR.L))
		OR  (PRM#=(CLICK.L-PAR.L))
		THEN DO;
			NEW.BEAT.NUMBER		= true;
			SUPRESS.BEAT.DISPLAY	= false;
			IF PRM#=(CLICK.L-PAR.L)
			THEN DO;
				TOGGLE.CLICKON=TRUE;
				CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
			END;
		END;
	END;	/*	OF PRESSED	*/
	ELSE DO;	/*	PARAMETER BUTTON RELEASED	*/
		LAST=0;													/*	MOST RECENTLY PRESSED BUTTON IS NOW RELEASED	*/
		IF PRM=(TBDEPTH.L-PAR.L) THEN TB.ENABLED=1;	/*	RELEASING SCALE RESET BUTTON - SET FLAG - BUTTON SET BLINKING BY CALL TO DISPLAY.PARAMETERS	*/
		IF PRM=(TTBEN.L  -PAR.L) THEN TB.ENABLED=1;	/*	ALSO INDIVIDUAL TONE BEND DEPTH	*/
		IF (PRM>=12)&(PRM<=23) THEN DO;					/*	COEF RELEASED	*/
			IF ((RESET.BITS&R.COEFS)<>0)
			OR (NEW.FRAME.COEFF<>0)
			THEN CALL DISPLAY.PAR;			/*	ENTER UPDATE ON COEFF BUTTON RELEASE TO CHECK FOR RE-COMPUTING WAVE MEMORY	*/
		END;
		IF ((PRM=(SPEED.L-PAR.L))\(PRM=(CLICK.L-PAR.L)))
		THEN DO;									/*	RELEASE SPEED OR CLICK	*/
			IF (UPPER.DISP=(BPM.L-PAR.L))	/*	WE ARE DISPLAYING METER	*/
			THEN DO;
				CALL DISPLAY.METER;			/*	MAKE SURE CURSOR IS LEFT IN NON BLINK STATE	*/
				CURSOR.BLINK = 0;
			END;
			ELSE IF (UPPER.DISP=ET.DISP)	/*	HAD THOUGHT ABOUT ERASING METER INFO	*/
			THEN DO;
				CLEAR.DISPLAY();
				CLEAR.ERAS.BUTTON();
				DISPLAY.SEQUENCER.STATUS();
			END;
			/*	Process everything specific to click button release here.	*/
			ELSE IF PRM=(CLICK.L-PAR.L)
			THEN DO;
				/*	Toggle the click's on/off status here.	*/
				IF TOGGLE.CLICKON <> false
				THEN DO;
					CLICKON = CLICKON XOR 1;
					CALL CLEAR.LOWER;
					IF CLICKON <> false
					THEN CALL EMIT.STRING(16,'Click: ON');
					ELSE CALL EMIT.STRING(16,'Click: OFF');
					CALL SET.CLOCK.CASE;							/*	SET UP EXT.CLOCK.CASE	*/
					NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;			/*	NEW CONSTANTS ON CLICK TRACK MODE CHANGE	*/
					CALL DISPLAY.PAR;
				END;
				/*	Execute desired click track option.	*/
				ELSE IF CLICK.TRACK.FUNCTION <> 0 THEN DO;
					J = shr(CLICK.TRACK.FUNCTION,8);	/*	Get Track Number	*/
					CALL CLEAR.DISPLAY;
					DO CASE (CLICK.TRACK.FUNCTION & 255);

						;	/*	CASE 0: No-op (Abort).	*/

						{	/*	CASE 1: Select/Deselect as click track.	*/
							/*	If the selected track is already the current click track,	*/
							/*	then revert to internal click,										*/
							/*	else go for it.															*/
							if	(CLICK.TRACK.MODE igt 3) AND (J = CLICK.TRACK.MODE+NUM.KBD.TRACKS-4)
							then CLICK.TRACK.MODE = 0;
							else CLICK.TRACK.MODE = (J + 4 - NUM.KBD.TRACKS);
							call PLAY.INITIALIZE;	/*	init to top of sequence	*/
						}

						{	/*	CASE 2: Use track to generate tempo map.	*/
							CALL EMIT.STRING(0,'Creating Tempo  Map from Trk');
							CALL EMIT.NUMBER(29,J-NUM.KBD.TRACKS+1,0,LEFT.JUST );
							BOTH.DISPLAY=1; CALL PANEL.RESCAN;
							IF (CREATE.TEMPO.MAP.FROM.TRACK(J,0) <> 0)
							THEN DO;
								CALL CLEAR.DISPLAY;
								CALL EMIT.STRING(16,'Tempo: Track');
								CALL EMIT.NUMBER(29,J-NUM.KBD.TRACKS+1,0,LEFT.JUST);
							END;
							ELSE CALL BAD.TEMPO.TRK.ERR;			/*	INVALID TRACK FOR TEMPO CONVERSION	*/
						}

						{	/*	CASE 3: Generate tempo map and conform all tracks.	*/
							CALL EMIT.STRING(0,'Conforming all  Trks to Trk:');
							CALL EMIT.NUMBER(29,J-NUM.KBD.TRACKS+1,0,LEFT.JUST );
							BOTH.DISPLAY=1; CALL PANEL.RESCAN;
							IF (CREATE.TEMPO.MAP.FROM.TRACK(J,1) <> 0)
							THEN DO;
								CALL CLEAR.DISPLAY;
								CALL EMIT.STRING(16,'Conform: Trk');
								CALL EMIT.NUMBER(29,J-NUM.KBD.TRACKS+1,0,LEFT.JUST);
							END;
							ELSE CALL BAD.TEMPO.TRK.ERR;			/*	INVALID TRACK FOR TEMPO CONVERSION	*/
						}

					END;	/*	of DO CASE	*/
					CALL SELECT.PARAMETER(CLICK.L-PAR.L);	/*	update display	*/
					IF (CLICK.TRACK.FUNCTION & 255) <> 0	/*	If something was changed...	*/
					THEN DO;
						/*	Create a system event when changing anything about the click track:	*/
						NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;		/*	NEW CONSTANTS ON CLICK TRACK MODE CHANGE	*/
					CALL DISPLAY.SEQUENCER.STATUS;		/*	generates NEW.SEQ.INFO motion change (128)	*/
					END;
				END;
			END;
		END;
	END;
	CALL DISPLAY.PARAMETER.BUTTONS;		/*	PRESENT DISPLAY TO USER	*/
END PARAMETER.BUTTON;

/*	$PAGE - ROUTINES TO SELECT TIMBRE FRAMES AND PARAMETERS (FROM TDS)	*/

SELECT.TIMBRE.FRAME: proc(tds.pt#,frame) PUBLIC SWAPABLE;	/*	activates an active timbre frame	*/
	dcl tds.pt#	fixed;	/*	selected partial	*/
	dcl frame	fixed;	/*	selected frame	*/
	dcl i			fixed;

	if TIM.HEAD.LOOKUP(0,TIM.SYNTH.TYP+tds.pt#)<2
	then do;										/*	if synthesized timbre	*/
		i=C.FRAME(tds.pt#);					/*	get current frame	*/
		if frame<>i then do;					/*	if selected timbre frame different than current	*/
			i=FIND.FRAME(tds.pt#,frame);	/*	find pointer to selected frame	*/
			if (frame=0) or (p.lookup(i)=MOR) then do;	/*	if timbre frame exists	*/
				C.FRAME(tds.pt#)=frame;		/*	set current timbre frame	*/
				FR.PTRS(tds.pt#)=i;			/*	store pointer to selected frame	*/
			end;
		end;										/*	of if selected timbre frame is different	*/
	end;											/*	of if synthesized timbre	*/
end SELECT.TIMBRE.FRAME;
