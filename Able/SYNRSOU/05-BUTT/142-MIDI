/* 142-MIDI  $TITLE  MIDI DEFINITIONS AND SCAN ROUTINES

   Modified:
	2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
   05/21/91 - PF/MWH - Fix MIDInet output in ALL.MIDI.NOTES.OFF
   05/17/91 - PF  - Record controller 65 as controller not as portamento per Eric Richardson
   08/27/90 - PF  - Support all MIDI controllers
   03/09/90 - PF  - Increase MAX.INPUTS to 128
   01/10/90 - MWH - Change MIDI mapping switch when MIDInet goes ON or OFF
   11/14/89 - MWH - Force original MIDI input to keyboard when MIDInet is present (for Paul)
   09/22/89 - TSS - Made small mod to V.S.MUL/V.S.MIN mapping in SCAN.MIDI code
   09/20/89 - PF  - Changed some bits for MIDInet
   07/07/89 - TSS - Added code to COMPUTE.MIDI.VELMAPS for Kbd Mapping
   07/27/89 - PF  - Set NEW.SEQ.INFO|1 in INIT.MIDI.SUBSYSTEMS to force MIDInet update
   07/27/89 - PF  - MIDInet bit in MIDI.THERE only set if MAC there too (INIT.MIDI.SUBSYSTEMS)
   07/17/89 - PF  - Defined bit 15 of THD.MIDI to represent "MIDInet routing is valid"
   07/17/89 - PF  - Send T#All_Notes_Off to MIDInet from ALL.MIDI.NOTES.OFF
   07/17/89 - PF  - Modified MIDI.THERE to accommodate MIDInet bit
   06/15/89 - PF  - Removed references to inc.new.midi
   06/15/89 - PF  - Added SYSEX.PACKET dcl
   05/08/89 - PF  - Added MIDI.BUF dcl
   01/13/89 - PF  - Monster MIDI code
   12/06/88 - tss - fixed bug in Scan.Midi where swap routine was being called
   04/12/88 - PF - MODIFIED CODE FOR POLY.TIMBRE.MIDI.CONTROL
   04/12/88 - PF - ADDED SYSTEM EXCLUSIVE ROUTINES FOR REAL TIME SYSEX RECORDING
   04/12/88 - PF - CLEANED UP CHECK.MIDI.EFFECTS AND CHECK.ALL.MIDI.TRACKS TO FIX RTE BUGS
   03/15/88 - PF - ADDED CHANNEL TO POLY PRESSURE CONVERSION
   02/01/88 - PF - MIPGM ON SKT FEATURE
   12/31/86 - TS - MODIFIED SCAN.MIDI TO ONLY LOOK AT INPUT BIT (TO DEAL WITH HDWARE PROBLEM)
   12/19/86 - CJ - FIXED MIDI INPUT SCAN INTERRUPT BUG
   8/22/86 - TS - PUT IN CODE TO PROCESS THD.ACTIVE.MIDI.RTES ON INPUT
   7/15/86 - CJ - CHANGED MIDI PROGRAM NUMBER USAGE
   7/10/86 - CJ,TS - REVISED SCAN.MIDI
   7/09/86 - CJ - STARTED MIDI EXTERNAL SYNC
   6/18/86 - CJ - REMOVED TIME.ACCUM REFERENCE
   5/15/86 - "official" creation of release-M modules
*/

#if (0)
   DCL MIDI_NOTE_ONS  FIXED PUBLIC;
   DCL MIDI_NOTE_OFFS FIXED PUBLIC;
#endif

/* THE MIDI SYSTEM WILL SUPPORT UP TO 8 MIDI I/O SUBSYSTEM CARDS.
   EACH MIDI SUBSYSTEM CONTAINS 4 OUTPUT CHANNELS AND 1 INPUT CHANNEL. */

DCL RUNNING.STATUS LIT '00'; /* SET TO 1 TO OPTIMIZE ON TRANSMIT, ELSE 0 */

DCL MIDI.ECHO.DISABLED  FIXED PUBLIC;    /* 0=ALLOW ECHO OF MIDI INPUT, 1=DISABLE MIDI ECHO */
DCL MIDI.OVERRUN        FIXED PUBLIC;    /* 1 IF DETECT AN OVERRUN ON INPUT, ELSE 0 */

/* THE ROUTING VARIABLE, STORED IN THD.MIDI (DECLARED IN 130-SDEF) CONTAINS
   SEVERAL PIECES OF INFORMATION:

		see literals in synclits...  equivalent to thd.midi.oms etc...
		
		if (THD.MIDI.OMS) (bit 14) is set
			if (THD.MIDI.OMS.VPORT) (11) is set ==> MIDI virtual port routing
				Bits 0 - 3  == MIDI channel number (0-15; present to user as 1-16)
				Bits 4 - 10 == MIDI virtual port number (0-63; present to user as 1-64 - room for 127 virtual ports in this field)
			if (THD.MIDI.OMS.VPORT) (11) is not set ==> OMS MIDI hardwired routing
				Bits 0 - 10 will be 0 in this case
				
		if (THD.MIDI.OMS) (bit 14) is not set
      	BITS   0 - 4   MIDI SUBSYSTEM with 16 set # (16-23)
    		BITS   5 - 6   MIDI OUTPUT # ON GIVEN SUBSYSTEM (0-3)
      	BIT    7       ** UNUSED **
      	BITS   8 - 11  MIDI CHANNEL # (0-15)
      	
      In all cases:
      	BITS  12 - 13  PRESSURE MODE (0=NONE, 1=INDIVIDUAL, 2=CHANNEL)
      	BIT   14       ROUTED TO OMS MIDI
      	BIT   15       MIDINET (PATH TO SEND ON IS STORED IN THD.MIDI.PATH)

      IF THE VALUE IN THE ROUTING WORD IS ZERO, THAT IMPLIES THAT THE
      SYNCLAVIER TIMBRE IS NOT ROUTED TO ANY MIDI OUTPUT.  IF MIDI.THERE
      IS ZERO, THD.MIDI IS GUARANTEED TO EQUAL ZERO.
		
		Note the MIDIRT word in the partial block has a similar, but quite different format.
		
		If THD.MIDI.OMS and THD.MIDI.OMS.VPORT are set, lower 11 bits are virtual port and channel.
		If just THD.MIDI.OMS is set, lower 8 bits are track number.
		If THD.MIDI.OMS is not set, lower half contains midi subsystem & output as described above
		Individual presure bit becomes a repeating/arpeggiating flag in MIDIRT.
*/

DCL MIDI.SYNC.OUT   		FIXED PUBLIC; /* MODE OF OPERATION FOR MIDI SYNC OUTPUT (0->DON'T SEND BYTES, 1-32 SEND TO OUTPUT #1-32) */
DCL MIDI.SYNC.IS.TC 		FIXED PUBLIC; /* TRUE IF MIDI SYNC OUTPUT FORMAT IS MIDI TC */
DCL MIDI.TC.VAL(5)  		FIXED PUBLIC; /* HRS, MIN, SEC, FRA, BIT TIME CODE VALUE */
DCL MIDI.TC.NUM			FIXED PUBLIC; /* HOLDS RATIO OF MILLISECONDS PER QUARTER-FRAME Ö 1000 */
DCL MIDI.TC.DEN			FIXED PUBLIC;
DCL MIDI.TC.NEXT.CODE 	FIXED PUBLIC;

DCL DISPLAY.MTC			FIXED PUBLIC; /* TRUE TO DISPLAY MIDI TIME CODE INSTEAD OF MEASURES */
DCL NEW.MTC.VAL       	FIXED PUBLIC; /* SET WHEN A NEW MTC VALUE IS AVAILABLE					*/

DCL MIDI.INPUT.CHAN FIXED PUBLIC; /* INPUT CHAN TO LISTEN TO.  */
                           /* (-2) --> IGNORE MIDI INPUT */
                           /* (-1) --> OMNI ON (LISTEN TO ALL INPUT) */
                           /* 0-15 --> OMNI OFF (LISTEN TO SPECIFIED CHAN ONLY) */

/* THE FOLLOWING BUFFER IS USED TO PACK MIDI EVENTS DESTINED FOR THE NETWORK.
   THE BUFFER IS BROADCAST EVERY MILLISECOND OR WHEN IT IS ABOUT TO OVERFLOW,
   WHICHEVER COMES FIRST. */

DCL MIDI.BUF((MAX_PACKET_LENGTH / 2) - 1) FIXED PUBLIC;    /* HOLDS NETWORK EVENTS WHICH HAVE ACCUMULATED DURING THE LAST MILLISECOND */

/* THE FOLLOWING ARRAY IS USED TO KEEP TRACK OF THE MOST RECENTLY
   TRANSMITTED STATUS (COMMAND) BYTE SENT OUT EACH OF THE POSSIBLE 33
   MIDI OUTPUTS.  THIS INFORMATION ALLOWS THE SYNCLAVIER TO TAKE
   ADVANTAGE OF THE RUNNING STATUS FEATURE OF MIDI TO REDUCE THE NUMBER
   OF BYTES WHICH NEED TO BE SENT. */

DCL LAST.MIDI.STATUS (32*RUNNING.STATUS) FIXED PUBLIC; 	/* VALUE OF LAST MIDI STATUS SENT ON EACH OUTPUT AND OMS MIDI PORT */
																			/* guaranteed to not work correctly for OMS midi output... */

/* $SUBTITLE  DECLARATIONS RELATED TO MIDI CONTROLLER ROUTINGS */

/* THE FOLLOWING VARS CONTAIN THE SYNCLAVIER EQUIVALENT INDEX NUMBER FOR EACH
MIDI CONTROLLER WHICH IS ROUTED TO A SYNCLAVIER CONTROLLER/SWITCH. IF NO
ROUTING EXISTS, OR IF MIDI.THERE=0, THIS VALUE IS GUARANTEED TO BE (-1). */

DCL MIDI.CROUT (63) FIXED PUBLIC; /* MIDI TO SYNCLAVIER ROUTING ARRAY FOR CONTINUOUS CONTROLLERS */
DCL MIDI.SROUT (31) FIXED PUBLIC; /* MIDI TO SYNCLAVIER ROUTING ARRAY FOR SWITCHES */

/* DECLARATIONS FOR MIDI CONTINUOUS CONTROLLERS AND SWITCHES */
DCL MIDI.PRESSURE(MAX.INPUTS-1)       						FIXED PUBLIC; /* MIDI CHANNEL PRESSURE */
DCL MIDI.KEY.PRESS                    						FIXED PUBLIC; /* POINTER TO INDIV PRESSURE TABLE */
DCL MIDI.ANALOG.IN                    						FIXED PUBLIC; /* MIDI CONTINUOUS CONTROLLER VALUES */
DCL MIDI.SWITCHDATA                   						FIXED PUBLIC; /* MIDI SWITCH VALUES */

DCL MIDI.ANALOG.CHANGEBITS				  						FIXED PUBLIC; /* BITS SET FOR ENTRIES OF MIDI.ANALOG.CHANGETABLE */
DCL MIDI.ANALOG.CHANGETABLE((MAX.INPUTS+15)/16 - 1)  	FIXED PUBLIC; /* BITS FOR INPUT CHANNELS WHICH HAVE CHANGING CONTINUOUS CONTORLLERS */
DCL MIDI.ANALOG.CHANGES    (MAX.INPUTS-1) 				FIXED PUBLIC; /* BITS FOR CONTINUOUS CONTROLLERS WHICH HAVE CHANGED */

DCL MIDI.SWITCH.CHANGEBITS				  						FIXED PUBLIC; /* BITS SET FOR ENTRIES OF MIDI.SWITCH.CHANGETABLE */
DCL MIDI.SWITCH.CHANGETABLE((MAX.INPUTS+15)/16 - 1) 	FIXED PUBLIC; /* BITS FOR INPUT CHANNELS WHICH HAVE CHANGING SWITCHES */
DCL MIDI.SWITCH.CHANGES    (MAX.INPUTS-1) 				FIXED PUBLIC; /* BITS FOR SWITCHES WHICH HAVE CHANGED */

DCL MISSED.MIDI.CLOCKS                FIXED PUBLIC; /* COUNTS UNPROCESSED MIDI TIMING CLOCKS */
DCL TIMING.CLOCK.ENABLE               FIXED PUBLIC; /* 1 ENABLES ACCUMULATION OF TIMING CLOCKS RECEIVED */
DCL MIDI.INPUT.ENABLED          		  FIXED PUBLIC; /* IF POLY.TIMBRE.MIDI.CONTROL or MAX.MIDINET.CHAN or OMS.MIDI.ENABLED */
DCL POLY.TIMBRE.MIDI.CONTROL          FIXED PUBLIC; /* MIDI MAPPED TO RECORDER FLAG */
DCL OMS.MIDI.ENABLED						  FIXED PUBLIC; /* TRUE OF OMS MIDI INPUT IS ENABLED */
DCL NEW.PROGRAM.STAK(PGM.CHG.LIST.SIZE)  FIXED PUBLIC; /* LIST FOR PROGRAM CHANGES */

DCL SYSEX.BUF                 FIXED PUBLIC; /* POINTER TO 16 SECTOR CIRCULAR BUFFER IN XMEM */
DCL SYSEX.WRITE.PTR           FIXED PUBLIC; /* NEXT LOCATION TO WRITE TO */
DCL SYSEX.READ.PTR            FIXED PUBLIC; /* NEXT LOCATION TO READ FROM */
DCL SYSEX.PACKET              FIXED PUBLIC; /* POINTER TO PACKET RESERVED FOR SYSEX OUTPUT */
DCL MIDI.MAPPING(MAX.INPUTS-1)  FIXED PUBLIC; /* INPUT CHANNEL TO TRACK ROUTING FOR ORIG MIDI AND MIDINET ONLY */
DCL CURRENT.KEY(15)           FIXED PUBLIC; /* FOR PRESSURE CONVERSION - HOLDS LAST PITCH PER MIDI CHANNEL */
DCL MONO.TO.POLY.PRESSURE     FIXED PUBLIC; /* PRESSURE CONVERSION SWITCH */
DCL MIDI.TRACK.RTES           FIXED PUBLIC; /* POINTER TO XMEM STORAGE FOR 128 MIDI CONTROLLERS FOR ALL TRACKS */

/* $SUBTITLE  ROUTINES TO SET UP AND CLEAR CONTROLLER ROUTING INFO */

CLEAR.MIDI.OUT.CONTROLLERS: PROC(TRK) PUBLIC SWAPABLE; /* REMOVES MIDI CONTROLLER ROUTINGS */
   DCL (TRK,I)  FIXED;

   WRITE(MAM)=TRK.HEAD;             /* POINT TO TRK.HEAD SECTOR */
   WRITE(MAL)=TRK;                  /* TRACK #                  */

   IF READ(MD)=0 THEN RETURN;

   WRITE(MAM)=READ(MD);             /* POINT TO TRACK HEAD      */
   WRITE(MAL)=THD.SYN.CROUT;

   DO I=THD.SYN.CROUT TO THD.SYN.SROUT+(8-1);
      WRITE(MDI)=0;
   END;
END CLEAR.MIDI.OUT.CONTROLLERS;

SET.MIDI.OUT.CONTROLLERS: PROC(TRK) PUBLIC SWAPABLE; /* SETS UP ROUTINGS FOR DX7 */
   DCL TRK FIXED; /* TRACK NUMBER */

   WRITE(MAM)=TRK.HEAD;             /* POINT TO TRK.HEAD SECTOR */
   WRITE(MAL)=TRK;                  /* FOR PASSED TRACK         */

   IF READ(MD)=0 THEN RETURN;       /* TRACK DOES NOT HAPPEN    */

   WRITE(MAM)=READ(MD);             /* POINT TO TRACK HEAD      */

   WRITE(MAL)=THD.SYN.CROUT+R.MWHEEL;
   WRITE(MD )=01;

   WRITE(MAL)=THD.SYN.CROUT+R.BREATH;
   WRITE(MD )=02;

   WRITE(MAL)=THD.SYN.CROUT+R.PEDAL1;
   WRITE(MD )=07;

   WRITE(MAL)=THD.SYN.CROUT+R.PEDAL2;
   WRITE(MD )=04;

   WRITE(MAL)=THD.SYN.CROUT+R.PWHEEL;
   WRITE(MD )=1;                      /* NONZERO */

   WRITE(MAL)=THD.SYN.SROUT+R.SUST.SW;
   WRITE(MD )=64;

   WRITE(MAL)=THD.SYN.SROUT+R.GLIDE.SW;
   WRITE(MD )=65;

END SET.MIDI.OUT.CONTROLLERS;

INIT.MIDI.ROUTINGS: PROC PUBLIC SWAPABLE;
   DCL I FIXED;

   /* FIRST CLEAR ALL INPUT MAPPINGS */

   DO I=0 TO 63;MIDI.CROUT(I)=(-1);END;
   DO I=0 TO 31;MIDI.SROUT(I)=(-1);END;

   /* SET UP DEFAULT INPUT MAPPINGS */

   MIDI.CROUT(01)=R.MWHEEL;     /* 01 = MODULATION WHEEL  */
   MIDI.CROUT(02)=R.BREATH;     /* 02 = BREATH CONTROLLER */
   MIDI.CROUT(04)=R.PEDAL2;     /* 04 = MODULATION PEDAL  */
   MIDI.CROUT(07)=R.PEDAL1;     /* 07 = VOLUME PEDAL      */

   MIDI.SROUT(00)=R.SUST.SW;    /* 00 = SUSTAIN SWITCH    */
/*   MIDI.SROUT(01)=R.GLIDE.SW; */  /* 01 = PORTAMENTO SWITCH */

END INIT.MIDI.ROUTINGS;

INIT.MIDI.RTE.AREA: PROC PUBLIC SWAPABLE;
   DCL I  FIXED;
   
   DO I=0 TO 255;
      WRITE(MAM)=MIDI.TRACK.RTES + I;
      RPC 256;
      WRITE(MDI)=(-1);
   END;

END INIT.MIDI.RTE.AREA;

/* SUBTITLE  ROUTINE TO SET UP VELOCITY->VOLUME AND VOLUME->VELOCITY LOOKUP TABLES */

COMPUTE.MIDI.VELMAPS: PROC PUBLIC SWAPABLE; /* COMPUTES NEW VELOCITY TO VOLUME TABLE */
   DCL (VOL,I,J) FIXED;

   IF (INC.KBD.MAPS<>0)              /* TRY TO USE MAPS ON DISK */
   AND (MAP.THERE <> 0)
   THEN DO;                          /* READ MAPS FROM DATA FILE */
      CALL LOAD.DATA(MAPDEV,MAPSEC,MIDI.MAPS,VMAP.PTR,128); /* LOAD MIDI VELOCITY TO VOLUME MAP */

      WRITE(MAM)=VMAP.PTR;
      DO I = 0 TO 127; MISC.BUF(I)=READ(MDI); END;

      J = 0;                      /* ASSUME MAP IS VALID */
      DO I = 0 TO 127;
         IF MISC.BUF(I) IGT RTE.MAX THEN J = 1; /* MAP IS INVALID */
      END;
      IF J = 0 THEN DO;           /* MAP IS OK SO FAR */
         J = 1;                   /* ASSUME MAP IS ALL ZERO & INVALID */
         DO I = 0 TO 127;
            IF MISC.BUF(I) <> 0 THEN J = 0; /* AT LEAST ITS NON ZERO */
         END;
      END;
   END;
   ELSE J = 1;

   IF J = 1 THEN DO;
   #if (0) // Original exponential algoritme
         DCL MIDI.VEL.MIN LIT '1';     /* SMALLEST VELOCITY TO MAP */
         DCL MIDI.VEL.MAX LIT '127';   /* LARGEST  VELOCITY TO MAP */
         DCL MIDI.MAGIC#  LIT '63338'; /* MAGIC NUMBER USED TO ACHIEVE GREATEST DYNAMIC RANGE */

         DO I=0 TO MIDI.VEL.MIN-2; MISC.BUF(I)=1; END;

         VOL=SHL(RTE.MAX,8);            /* STARTING AT THE MAX VOLUME */
         I=MIDI.VEL.MAX-MIDI.VEL.MIN+1;
         DO WHILE I>0;                 /* LOOP OVER VALUES IN TABLE */
            MISC.BUF(I)=SHR(VOL,8)+((VOL&128)<>0);  /* STORE NEXT VALUE */
            LOAD VOL; MUL MIDI.MAGIC#;  /* FRACTIONAL MULTIPLY */
            VOL=READ(4);
            I=I-1;
         END;

         WRITE(MAM)=VMAP.PTR; /* NOW PUT TABLE INTO EXTERNAL MEMORY */
         DO I=0 TO 127; WRITE(MDI)=MISC.BUF(I); END;
   #endif
   #if (0) // Yielded these values
      // Original exponential mapping analyzed 2017-02-08 C. Jones
      // Software started with 127; multipled by 63338/65536 going down the table
      // Original exponential mapping analyzed 2017-02-08 C. Jones
      // Software started with 127; multipled by 63338/65536 going down the table
      // 00000 00003 00003 00003 00003 00003 00004 00004
      // 00004 00004 00004 00004 00004 00005 00005 00005
      // 00005 00005 00005 00006 00006 00006 00006 00006
      // 00007 00007 00007 00007 00008 00008 00008 00008
      // 00009 00009 00009 00010 00010 00010 00011 00011
      // 00012 00012 00012 00013 00013 00014 00014 00015
      // 00015 00016 00016 00017 00017 00018 00019 00019
      // 00020 00021 00021 00022 00023 00024 00024 00025
      // 00026 00027 00028 00029 00030 00031 00032 00033
      // 00034 00036 00037 00038 00039 00041 00042 00044
      // 00045 00047 00048 00050 00052 00054 00056 00057
      // 00059 00062 00064 00066 00068 00071 00073 00075
      // 00078 00081 00084 00087 00090 00093 00096 00099
      // 00103 00106 00110 00114 00118 00122 00126 00130
      // 00135 00140 00144 00149 00155 00160 00166 00171
      // 00177 00183 00190 00196 00203 00210 00217 00225
   #endif
   #if (1) // Hand-tweaked table to preserve more midi resoluion at small values
      WRITE(MAM)=VMAP.PTR; /* NOW PUT TABLE INTO EXTERNAL MEMORY */
      WRITE(MDI) = 00000;
      WRITE(MDI) = 00001;
      WRITE(MDI) = 00001;
      WRITE(MDI) = 00002;
      WRITE(MDI) = 00002;
      WRITE(MDI) = 00003;
      WRITE(MDI) = 00003;
      WRITE(MDI) = 00004;
      WRITE(MDI) = 00004;
      WRITE(MDI) = 00005;
      WRITE(MDI) = 00005;
      WRITE(MDI) = 00006;
      WRITE(MDI) = 00006;
      WRITE(MDI) = 00007;
      WRITE(MDI) = 00007;
      WRITE(MDI) = 00008;
      WRITE(MDI) = 00008;
      WRITE(MDI) = 00009;
      WRITE(MDI) = 00009;
      WRITE(MDI) = 00010;
      WRITE(MDI) = 00010;
      WRITE(MDI) = 00011;
      WRITE(MDI) = 00011;
      WRITE(MDI) = 00012;
      WRITE(MDI) = 00012;
      WRITE(MDI) = 00013;
      WRITE(MDI) = 00013;
      WRITE(MDI) = 00014;
      WRITE(MDI) = 00014;
      WRITE(MDI) = 00015;
      WRITE(MDI) = 00015;
      WRITE(MDI) = 00016;
      WRITE(MDI) = 00016;
      WRITE(MDI) = 00017;
      WRITE(MDI) = 00017;
      WRITE(MDI) = 00018;
      WRITE(MDI) = 00018;
      WRITE(MDI) = 00019;
      WRITE(MDI) = 00019;
      WRITE(MDI) = 00020;
      WRITE(MDI) = 00020;
      WRITE(MDI) = 00021;
      WRITE(MDI) = 00021;
      WRITE(MDI) = 00022;
      WRITE(MDI) = 00022;
      WRITE(MDI) = 00023;
      WRITE(MDI) = 00023;
      WRITE(MDI) = 00024;
      WRITE(MDI) = 00024;
      WRITE(MDI) = 00025;
      WRITE(MDI) = 00025;
      WRITE(MDI) = 00026;
      WRITE(MDI) = 00026;
      WRITE(MDI) = 00027;
      WRITE(MDI) = 00027;
      WRITE(MDI) = 00028;
      WRITE(MDI) = 00028;
      WRITE(MDI) = 00029;
      WRITE(MDI) = 00029;
      WRITE(MDI) = 00030;
      WRITE(MDI) = 00030;
      WRITE(MDI) = 00031;
      WRITE(MDI) = 00031;
      WRITE(MDI) = 00032;
      WRITE(MDI) = 00032;
      WRITE(MDI) = 00033;
      WRITE(MDI) = 00033;
      WRITE(MDI) = 00034;
      WRITE(MDI) = 00034;
      WRITE(MDI) = 00035;
      WRITE(MDI) = 00035;
      WRITE(MDI) = 00036;
      WRITE(MDI) = 00036;
      WRITE(MDI) = 00037;
      WRITE(MDI) = 00037;
      WRITE(MDI) = 00038;
      WRITE(MDI) = 00039;
      WRITE(MDI) = 00041;
      WRITE(MDI) = 00042;
      WRITE(MDI) = 00044;
      WRITE(MDI) = 00045;
      WRITE(MDI) = 00047;
      WRITE(MDI) = 00048;
      WRITE(MDI) = 00050;
      WRITE(MDI) = 00052;
      WRITE(MDI) = 00054;
      WRITE(MDI) = 00056;
      WRITE(MDI) = 00057;
      WRITE(MDI) = 00059;
      WRITE(MDI) = 00062;
      WRITE(MDI) = 00064;
      WRITE(MDI) = 00066;
      WRITE(MDI) = 00068;
      WRITE(MDI) = 00071;
      WRITE(MDI) = 00073;
      WRITE(MDI) = 00075;
      WRITE(MDI) = 00078;
      WRITE(MDI) = 00081;
      WRITE(MDI) = 00084;
      WRITE(MDI) = 00087;
      WRITE(MDI) = 00090;
      WRITE(MDI) = 00093;
      WRITE(MDI) = 00096;
      WRITE(MDI) = 00099;
      WRITE(MDI) = 00103;
      WRITE(MDI) = 00106;
      WRITE(MDI) = 00110;
      WRITE(MDI) = 00114;
      WRITE(MDI) = 00118;
      WRITE(MDI) = 00122;
      WRITE(MDI) = 00126;
      WRITE(MDI) = 00130;
      WRITE(MDI) = 00135;
      WRITE(MDI) = 00140;
      WRITE(MDI) = 00144;
      WRITE(MDI) = 00149;
      WRITE(MDI) = 00155;
      WRITE(MDI) = 00160;
      WRITE(MDI) = 00166;
      WRITE(MDI) = 00171;
      WRITE(MDI) = 00177;
      WRITE(MDI) = 00183;
      WRITE(MDI) = 00190;
      WRITE(MDI) = 00196;
      WRITE(MDI) = 00203;
      WRITE(MDI) = 00210;
      WRITE(MDI) = 00217;
      WRITE(MDI) = 00225;

      WRITE(MAM)=VMAP.PTR; /* NOW PUT TABLE INTO EXTERNAL MEMORY */
      DO I=0 TO 127; MISC.BUF(I) = READ(MDI); END;

   #endif
   END;

   /* NOW COMPUTE THE INVERSE TABLE:  VOLUME TO MIDI VELOCITY */
   WRITE(MAM)=VMAP.PTR+1; /* FIRST ZERO OUT THE TABLE */
   DO I=0 TO RTE.MAX; WRITE(MDI)=0; END;

   VOL=0;
   DO I=1 TO 127;
      IF VOL<>MISC.BUF(I) THEN DO;
         VOL=MISC.BUF(I); /* LOOK UP MAP FROM MID VEL TO VOL */
         WRITE(MAM)=VMAP.PTR+1+SHR(VOL,8);
         WRITE(MAL)=VOL;
         WRITE(MD )=I;
      END;
   END;

   WRITE(MAM)=VMAP.PTR+1;
   DO I=0 TO RTE.MAX; MISC.BUF(I)=READ(MDI); END;
   MISC.BUF(0)=0;

   I=RTE.MAX;
   DO VOL=0 TO RTE.MAX-1;
      IF   MISC.BUF(RTE.MAX-VOL)=0
      THEN MISC.BUF(RTE.MAX-VOL)=I;
      ELSE I=MISC.BUF(RTE.MAX-VOL);
   END;

   WRITE(MAM)=VMAP.PTR+1;
   DO I=0 TO RTE.MAX; WRITE(MDI)=MISC.BUF(I); END;

END COMPUTE.MIDI.VELMAPS;

/* $SUBTITLE  MIDI HARDWARE INITIALIZATION ROUTINES */

INIT.MIDI.FIFO:  PROC (BOARD,CHAN) PUBLIC SWAPABLE; /* INIT THE DESIRED FIFO */
   DCL BOARD FIXED; /* THE SUBSYSTEM (0-7) */
   DCL CHAN  FIXED; /* AND CHANNEL   (0-4) */

   IF (MIDI.THERE & MIDI.THERE.ORIG)=0 THEN RETURN;   /* NO OLD MIDI HW TO POLL */
   
   IF (BOARD < MIDI.SUBSYS)                  /* WACKO VALUES PASSED */
   OR (BOARD > MIDI.SUBSYS + 7) THEN RETURN;

   DISABLE;
   WRITE(SYSSEL)  =BOARD; /* SELECT SUBSYSTEM */
   IF READ(SYSSEL)=BOARD THEN DO;   /* THIS SUBSYSTEM EXISTS */
      WRITE(MCHA)="10"\CHAN;        /* SELECT UART AND ASSERT RESET LINE */
      WRITE(MDAT)=READ(MDAT);       /* INIT ROTARY PTRS */
      WRITE(MCHA)=0;                /* DEASSERT RESET LINE */
   END;
   ENABLE;
END INIT.MIDI.FIFO;

INIT.MIDI.SUBSYSTEMS:  PROC PUBLIC SWAPABLE; /* INIT ROUTINE FOR MIDI SUBSYSTEMS */
   DCL (I,J) FIXED;
   DCL DISABLE.INTERRUPTS LIT 'WRITE("313")=READ("314"); DISABLE';
   DCL RESTORE.INTERRUPTS LIT 'WRITE("314")=READ("313"); WRITE(1)=READ("313")';

	// Set bit if OMS output available
	if (interp_is_running != 0)
		MIDI.THERE = MIDI.THERE | MIDI.THERE.OMS;
	else
		MIDI.THERE = MIDI.THERE & (not(MIDI.THERE.OMS));
		
	// Set bit(s) if orig hardware avilable
   DISABLE.INTERRUPTS;
   MIDI.THERE=MIDI.THERE & (not(MIDI.THERE.ORIG));  /* ASSUME NO ORIGINAL MIDI SUBSYSTEMS FOUND */
   MAX.MIDI.CHAN=0;
   IF (((READ("51")&256)<>0)
   &&  ((interp_real_time_prefs(SYNCLAVIER_PREF_POLL_DD70MIDI) & SYNCLAVIER_PREF_POLL_DD70MIDI) != 0))
   THEN DO;     /* HAVE SOME D70 TYPE DEVICE */
      I=MIDI.SUBSYS; J=I;
      DO WHILE (J=I) AND (I<(MIDI.SUBSYS+8)); /* LOOP OVER THE 8 MIDI SUBSYSTEMS */
         WRITE(SYSSEL)=I;              /* SELECT SUBSYSTEM */
         IF  (READ(SYSSEL)=I)          /* THIS SUBSYSTEM EXISTS */
         AND ((READ(MSTA)&2)=0)        /* AND THE CABLES ARE OK */
         THEN DO;                      /* WE HAVE 4 MORE GOOD OUTPUTS AND 1 MORE GOOD INPUT */

            MIDI.THERE=MIDI.THERE\BITS(I-MIDI.SUBSYS); /* TURN ON CORRESPONDING BIT */
            MAX.MIDI.CHAN=MAX.MIDI.CHAN+4;    /* ANOTHER 4 OUTPUTS AVAILABLE */

            DO J="10" TO "14";         /* INIT FIFO ROTARY PTRS */
               WRITE(MCHA)=J;          /* SELECT UART AND ASSERT RESET LINE */
               WRITE(MDAT)=READ(MDAT); /* INIT ROTARY PTRS */
            END; 
            WRITE(MCHA)=0;             /* DEASSERT RESET LINE */

            J=I;                       /* INIDICATE THAT ADJACENT OUTPUTS FOUND */
         END;
         ELSE J=0;                     /* INDICATE END OF ADJACENT OUTPUTS */
         I=I+1; J=J+1;                 /* STEP TO NEXT POSSIBLE SUBSYTEM */
      END;
   END;

	// Set bit if MIDINet is there
   IF  (MAP.D115.NODE.ID(NN#MIDI)<>(-1))  /* FOUND THE D115D MIDI CHANNEL */
   AND (MAX.MIDINET.CHAN=0)               /* MIDINET JUST CAME UP */
   THEN DO;
      MIDI.THERE=MIDI.THERE|MIDI.THERE.MIDINET;    /* SET BIT 15 IN MIDI.THERE */
      MAX.MIDINET.CHAN=8;                 			/* FOR NOW 8 IS ALWAYS THE MAX MIDINET NUMBER */
		MIDI.INPUT.ENABLED = true;
      NEW.SEQ.INFO=NEW.SEQ.INFO|8;        /* NEW CONSTANTS */
   END;
   ELSE IF (MAP.D115.NODE.ID(NN#MIDI)=(-1))
   AND (MAX.MIDINET.CHAN<>0)              /* MIDINET WAS THERE BUT NOW IS GONE */
   THEN DO;
      MIDI.THERE=MIDI.THERE&(not(MIDI.THERE.MIDINET));     	/* CLEAR BIT 15 IN MIDI.THERE */
      MAX.MIDINET.CHAN=0;                 						/* CLEAR MIDINET CHANS FROM CONFIGURATION */
		if ((POLY.TIMBRE.MIDI.CONTROL | OMS.MIDI.ENABLED) != 0)
			MIDI.INPUT.ENABLED = true;
		else
			MIDI.INPUT.ENABLED = false;
      NEW.SEQ.INFO=NEW.SEQ.INFO|8;        /* NEW CONSTANTS */
   END;

   WRITE(MAM)=MIDI.ANALOG.IN;

   // For keyboard, init PED2 to max (optionally)
   // Tracks init ped2 to 0 in all cases since that how the track would have been recorded
   WRITE(MDI) = RTE.MAX;					// INIT PED1 TO RTE.MAX
   if ((interp_real_time_prefs(0) & SYNCLAVIER_PREF_PEDAL2_MAX) != 0)
      write(mdi) = RTE.MAX;            // INIT PED2 TO RTE.MAX...
   else
      write(mdi) = 0;                  // ... OR TO 0
   RPC 6;
   WRITE(MDI) = 0;							// INIT OTHER EFFECTS TO 0

   DO I=1 TO MAX.INPUTS-1;
		WRITE(MDI) = RTE.MAX;					// INIT PED1 TO RTE.MAX
		RPC 7;
		WRITE(MDI) = 0;							// INIT OTHER EFFECTS TO 0
	END;

   WRITE(MAM)=MIDI.SWITCHDATA;
   DO I=0 TO (MAX.INPUTS*8)-1; WRITE(MDI)=0; END;   /* INITIALIZE SWITCH VALUES     */

   IF RUNNING.STATUS<>0                /* USING RUNNING STATUS OPTIMIZATION */
   THEN DO I=0 TO 31; LAST.MIDI.STATUS(I)=0; END; /* CLEAR PREV INFO */
   RESTORE.INTERRUPTS;
END INIT.MIDI.SUBSYSTEMS;

/* $SUBTITLE  ROUTINES TO CLEANUP AND INITIALIZE MIDI DEVICES */

DCL MIDI.CHANNEL.PRESSURE    FORWARD (FIXED);
DCL MIDI.INDIVIDUAL.PRESSURE FORWARD (FIXED,FIXED);

CLEANUP.MIDI.PRESSURE:  PROC (T#) PUBLIC SWAPABLE; /* TURNS OFF PRESSURE IN CURRENT MODE */
   DCL T#         FIXED;    /* TRACK NUMBER TO CLEAN UP PRESSURE ON (0 TO NUM.TIMBRES-1) */
   DCL I          FIXED;
   DCL MIDI.ROUTE FIXED;

   WRITE(MAM)=TRK.HEAD;             /* POINT TO TRK.HEAD SECTOR */
   WRITE(MAL)=T#;                   /* TRACK #                  */
   WRITE(MAM)=READ(MD);             /* EVEN IF 0                */

   WRITE(MAL)=THD.MIDI;
   MIDI.ROUTE=READ(MD);

   /* NOTE:  THIS ROUTINE IS USED TO SEND OUT A ZERO PRESSURE VALUE
      TO MIDI WHEN THE PRESSURE ROUTING INFO IS ABOUT TO CHANGE.
      THIS IS DONE TO PREVENT A MIDI DEVICE FROM GETTING STUCK WITH
      A NON-ZERO PRESSURE VALUE. */

   IF (MIDI.ROUTE&THD.MIDI.PRESURE)=0 THEN RETURN; /* NO PRESSURE ACTIVE NOW */

   WRITE(MAL)=THD.CPPSUM;     							/* INIT CPPSUM IF ANY ROUTING */
   WRITE(MD )=0;              							/* PRESUMABLY MEANS EXISTING TRACK HEAD IF MIDI ROUTING NONZERO */

   IF (MIDI.ROUTE&THD.MIDI.INDIVP)<>0             	/* SENDING INDIVIDUAL PRESSURE */
   THEN DO;
      DO I=0 to 127;                               /* LOOP OVER ALL POSSIBLE MIDI KEYS */
         CALL MIDI.INDIVIDUAL.PRESSURE(I,0); 		/* REZERO PRESSURE INFO */
      END;
   END;
   ELSE IF (MIDI.ROUTE&THD.MIDI.CHANP)<>0        	/* SENDING CHANNEL PRESSURE */
   THEN DO;
      CALL MIDI.CHANNEL.PRESSURE(0);    /* REZERO PRESSURE INFO */
   END;
END CLEANUP.MIDI.PRESSURE;

ALL.MIDI.NOTES.OFF:  PROC PUBLIC SWAPABLE;        /* TURNS OFF ALL NOTES ON ALL SUBSYSTEMS AND MIDI CHANNELS */
   DCL (I,J,K) FIXED;
   DCL DISABLE.INTERRUPTS LIT 'WRITE("313")=READ("314"); DISABLE';
   DCL RESTORE.INTERRUPTS LIT 'WRITE("314")=READ("313"); WRITE(1)=READ("313")';

   IF (MIDI.THERE & MIDI.THERE.MIDINET)<>0        /* MIDINET IS OUT THERE */
   THEN DO;
      DO I=0 TO 7;
         WRITE(MAM)=MISC.PTR;
         WRITE(MDI)=L#ALL_NOTES_OFF;
         WRITE(MDI)=NN#MIDI;
         WRITE(MDI)=T#ALL_NOTES_OFF;
         WRITE(MDI)=SHL(16,8) | I;                /* SEND TO ALL CHANNELS ON EACH PORT */
         CALL SEND.PROTOCOL.PACKET(MISC.PTR,1);
      END;
   END;

   IF (MIDI.THERE & MIDI.THERE.ORIG)<>0           /* OLD MIDI HARDWARE THERE */
   THEN DO; /* TURN OFF ALL NOTES ON ALL SUBSYSTEMS FOR ALL MIDI CHANNELS */
      DO J=0 TO 7; /* LOOP OVER THE 8 POSSIBLE MIDI SUBSYSTEMS */
         IF (MIDI.THERE&BITS(J))<>0 THEN DO; /* THIS SUBSYSTEM EXISTS */
            DO I=0 TO 3;
               DO K=0 TO 15;               /* LOOP OVER THE 16 MIDI CHANNELS */
                  DISABLE.INTERRUPTS;         /* NEED TO PROTECT FROM INTERRUPTS */

                  IF RUNNING.STATUS<>0
                  THEN LAST.MIDI.STATUS(J*4+I)=0; /* REZERO */

                  WRITE(SYSSEL)=MIDI.SUBSYS+J;/* SELECT MIDI SUBSYSTEM */
                  WRITE(MCHA  )=I;            /* AND SELECT OUTPUT ON THAT SUBSYSTEM */

                  WRITE(MDAT)="HB0"\K;     /* SEND STATUS BYTE AND MIDI CHAN */
                  WRITE(MDAT)=123;         /* POLY MODE - ALL NOTES OFF */
                  WRITE(MDAT)=0;           /* MUST SEND ZERO */
                  RESTORE.INTERRUPTS;
               END;
            END;
         END;
      END;
   END;
	
	IF (MIDI.THERE & MIDI.THERE.OMS) <> 0	/* OMS IS THERE */
		interp_send_all_notes_off();
		
END ALL.MIDI.NOTES.OFF;

/* $SUBTITLE  MAIN MIDI INPUT SCANNING ROUTINE */

DCL MIDI.SONG.PTR.INFO FIXED PUBLIC;

/* LITERAL DEFINITIONS OF SELECTED MIDI STATUS/COMMAND BYTES */

DCL SYSTEM.EXCLUSIVE LIT '240';
DCL SONG.POSITION    LIT '242';
DCL END.OF.BLOCK     LIT '247';
DCL TIMING.CLOCK     LIT '248';
DCL START.CLOCK      LIT '250';
DCL CONTINUE.CLOCK   LIT '251';
DCL STOP.CLOCK       LIT '252';
DCL ACTIVE.SENSING   LIT '254';
DCL SYSTEM.RESET     LIT '255';

// Routine to do much of the grunt work associated with
// syncing to an external midi clock.  Forwards information for
// starting and stopping the sequence and so forth.

SYNC.TO.MIDI:  PROC(MIDI);                /* PROCESSES MIDI REAL-TIME BYTES */
	DCL MIDI FIXED;
	
	DO CASE (MIDI-TIMING.CLOCK);
		IF TIMING.CLOCK.ENABLE<>0
		THEN DO;                      /* TIMING CLOCK            */
			IF  (TIME.BASE.MODE=6)     /* WAITING FOR MIDI PULSES */
			THEN DO;
				CLOCK.RECEIVED=1;       /* CLOCK PULSE RECEIVED    */
				CLOCK.DELAY.TIME=KBD.MILLISECONDS;  /* NO DELAY    */
			END;
			ELSE MISSED.MIDI.CLOCKS=MISSED.MIDI.CLOCKS+1; /* COUNT THESE */
		END;

		;   /* UNDEFINED */

		DO; /* START */
			IF PLAY=0 THEN DO;
				SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4)\1; /* SET FLAG TO START SEQUENCER ASAP */
				MISSED.MIDI.CLOCKS=0;   /* REZERO */
			END;
			TIMING.CLOCK.ENABLE=1;     /* ENABLE ACCUMULATION OF MIDI CLOCKS */
		END;

		DO; /* CONTINUE */
			IF PLAY=0 THEN DO;
				SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4)\2; /* SET FLAG TO CONTINUE ASAP */
				MISSED.MIDI.CLOCKS=0;   /* REZERO */
			END;
			TIMING.CLOCK.ENABLE=1;     /* ENABLE ACCUMULATION OF MIDI CLOCKS */
		END;

		DO; /* STOP */
			IF PLAY<>0
			THEN SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4)\3; /* SET FLAG TO STOP SEQUENCER ASAP */
			TIMING.CLOCK.ENABLE=0;     /* DISABLE ACCUMULATION OF MIDI CLOCKS */
		END;

		/* 252 - 255 : IGNORE FOR NOW */

	END;
END SYNC.TO.MIDI;


// Routine to process incoming midi bytes from the aux midi
// port or from the OMS midi clock port.

DCL SCANNING.SONGPTR  FIXED;
DCL AUX.SYS.COMMON    FIXED;

PROCESS.MIDI.AUX.BYTE:PROC(MIDI) PUBLIC;
	DCL MIDI FIXED;

	IF  (MIDI<128)            /* DATA BYTE          */
	THEN DO;
		IF SCANNING.SONGPTR=1 THEN DO;
			AUX.SYS.COMMON=MIDI;
			SCANNING.SONGPTR=2;
		END;
		ELSE IF SCANNING.SONGPTR=2 THEN DO;
			AUX.SYS.COMMON=AUX.SYS.COMMON\SHL(MIDI,7);
			MIDI.SONG.PTR.INFO=AUX.SYS.COMMON;
			SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4)\5;
			SCANNING.SONGPTR=0;
		END;
	END;
	ELSE IF MIDI=SONG.POSITION THEN DO;
		SCANNING.SONGPTR=1;
	END;
	ELSE DO;
		SCANNING.SONGPTR=0;
		IF  (MIDI>=TIMING.CLOCK)
		THEN DO;                     /* PROCESS SYSTEM REAL-TIME INFORMATION */
			CALL SYNC.TO.MIDI(MIDI);  /* SUBROUTINE TO DO THE SYNCHRONIZING */
		END;                         /* OF HAVE A REAL-TIME BYTE TO PROCESS */
	END;
END PROCESS.MIDI.AUX.BYTE;

SCAN.MIDI:  PROC PUBLIC;  /* PROCESSES MIDI BYTES */
   DCL (SAVE.MAM,SAVE.MAL) FIXED STATIC;
   DCL MIDI                FIXED; /* BYTE OF MIDI INFO */


   /* MAIN ROUTINE TO SYNCHRONIZE TO MIDI REAL-TIME INFORMATION */

   /* $PAGE MAIN BODY OF INPUT SCANNING CODE */

   DCL MIDI.STATE      FIXED; /* STATE VAR TO KEEP TRACK OF WHERE WE ARE */
   DCL PREV.STATE      FIXED; /* HOLDS LAST STATE IF WE GET THE SYSTEM EXCLUSIVE COMMAND BYTE */
   DCL SUBSTATE        FIXED; /* SECONDARY STATE VAR USED IN MANY STATES */
   DCL MIDI.BYTES.READ FIXED; /* COUNT OF BYTES READ IN THIS SCAN */

   DCL CHANNEL         FIXED; /* MIDI CHANNEL NUMBER      */
   DCL KEY             FIXED; /* KEY NUMBER               */
   DCL CONTROLLER      FIXED; /* CONTROLLER NUMBER        */
   DCL VALUE           FIXED; /* GENERAL PARAMETER VALUE  */
   DCL SYS.COMMON      FIXED; /* SOME SYSTEM COMMON INFO  */

   DCL ORIGIN          FIXED; /* SET TO 0 IF MIDI MAPPED TO KBD, CHANNEL+NUM.KBD.TRACKS IF MIDI MAPPED TO RECORDER */
   DCL (I,J)           FIXED;
   DCL PTMC            FIXED; /* LOCAL COPY OF POLY.TIMBRE.MIDI.CONTROL */

   /* MIDI STATE VALUES */

   DCL NULL.STATE     LIT '00'; /* NULL -- IGNORE DATA BYTES */
   DCL NOTE.OFF       LIT '01'; /* PROCESSING A NOTE OFF COMMAND */
   DCL NOTE.ON        LIT '02'; /* PROCESSING A NOTE ON  COMMAND */
   DCL POLY.PRESSURE  LIT '03'; /* PROCESSING AN INDIVIDUAL KEY PRESSURE UPDATE (ON GIVEN CHANNEL) */
   DCL CONTROL.CHANGE LIT '04'; /* PROCESSING A CONTROLLER SETTING UPDATE */
   DCL PROGRAM.CHANGE LIT '05'; /* PROCESSING A PROGRAM (TIMBRE) CHANGE COMMAND */
   DCL CHAN.PRESSURE  LIT '06'; /* PROCESSING AN OVERALL PRESSURE UPDATE (ON GIVEN CHANNEL) */
   DCL PITCH.WHEEL    LIT '07'; /* PROCESSING A 2 BYTE PITCH WHEEL UPDATE */
   DCL SYSTEM.COMMON  LIT '08'; /* PROCESSING A SYSTEM COMMON COMMAND */
   DCL EXCLUSIVE      LIT '09'; /* PROCESSING SYSTEM EXCLUSIVE INFO */

   SAVE.SYSEX.BYTE: PROC (VAL);

      DCL VAL FIXED;

      IF  (((RECD<>0)                             /* WE ARE RECORDING */
      AND (RECD.TRK<>0))                          /* SYNCLAVIER RECORDING */
      OR  (MIDI.ECHO.DISABLED=0))                 /* WE ARE ECHOING MIDI */
      THEN DO;                                    /* PROCESS BYTE */
         IF (SYSEX.WRITE.PTR<>(SYSEX.READ.PTR-1))   /* ROOM IN SYSEX BUFFER */
         THEN DO;
            WRITE(MAM)=SYSEX.BUF+(SHR(SYSEX.WRITE.PTR&"7777",8));
            WRITE(MAL)=SYSEX.WRITE.PTR;           /* SET UP POINTERS INTO BUFFER ARRAY */
            WRITE(MD) =VAL;                       /* STORE BYTE */
            SYSEX.WRITE.PTR=SYSEX.WRITE.PTR+1;    /* INCREMENT POINTER */
         END;
         ELSE DO;                                 /* BUFFER IS FULL */
            MIDI.OVERRUN=1;                       /* MIGHT HAVE MISSED SOMETHING */ 
            SYSEX.READ.PTR=SYSEX.WRITE.PTR;       /* EMPTY BUFFER */
         END;
      END;
   END SAVE.SYSEX.BYTE;

   TERMINATE.SYSEX:PROC;
      IF MIDI=END.OF.BLOCK                      /* TERMINATED BY EOX */
      THEN MIDI.STATE=PREV.STATE;               /* (ELSE TERMINATED BY ANOTHER STATUS BYTE) */

      CALL SAVE.SYSEX.BYTE(END.OF.BLOCK);
   END;


   /* SAVE EXT MEM REGS SO WE DON'T MESS UP INTERRUPTS */
   WRITE("300")=ADDR(SAVE.MAM);
   WRITE("360")=READ(MAM);
   WRITE("360")=READ(MAL);

   MIDI.BYTES.READ=0;                     /* KEEP TRACK OF NUMBER OF BYTES READ */
   ORIGIN=0;                              /* INITIALIZE MAPPING ORIGIN */

   PTMC = POLY.TIMBRE.MIDI.CONTROL;       /* LATCH CURRENT MODE */
   IF (MAX.MIDINET.CHAN<>0)               /* IF MIDINET IS PRESENT */
   THEN PTMC = 0;                         /* then FORCE original MIDI INPUT TO BE MAPPED TO KBD */

   DISABLE;
   WRITE(SYSSEL)=MIDI.SUBSYS;             /* SELECT MIDI SUBSYSTEM 0 */

   DO WHILE READ(MSTA);                   /* LOOP WHILE BYTES TO PROCESS */

      WRITE(MCHA)=4;                      /* SELECT INPUT CHANNEL    */
      MIDI=READ(MDAT);                    /* GET NEXT MIDI BYTE */

      ENABLE;
      MIDI.BYTES.READ=MIDI.BYTES.READ+1;

      IF (MIDI&128)=0 THEN DO;            /* MOST COMMON CASE - DATA BYTES */

         IF  (MIDI.STATE>PITCH.WHEEL)       /* NOT INTERESTED IN CHANNEL NUMBERS */
         OR  (((MIDI.INPUT.CHAN=(-1))       /* OR LISTENING IN OMNI MODE */
         OR   (MIDI.INPUT.CHAN=CHANNEL))    /* OR LISTENING TO THIS CHANNEL */
         AND  (PTMC=0))                     /* MIDI MAPPED TO KEYBOARD */
         OR  ((PTMC=1)                      /* MIDI MAPPED TO RECORDER */
         AND  (MIDI.MAPPING(CHANNEL+2)<>1)) /* THIS CHANNEL IS ROUTED TO A TRACK */
         THEN DO;                           /* PROCESS THE MIDI DATA BYTE */

            IF (PTMC<>0) THEN DO;                     /* IF MIDI MAPPED TO RECORDER */
					// was midi  mapped
					// ORIGIN was CHANNEL+NUM.KBD.TRACKS; changed to MIDI.MAPPING(CHANNEL+NUM.KBD.TRACKS)
               ORIGIN=MIDI.MAPPING(CHANNEL+NUM.KBD.TRACKS);
            END;

            DO CASE MIDI.STATE;           /* BRANCH ACCORDING TO CURRENT STATE */
               ;                             /* STATE 00 -- NULL STATE */

               DO;                           /* STATE 01 -- NOTE.OFF STATE */
                  IF SUBSTATE=0 THEN DO;     /* FIRST GET PITCH OF NOTE TO TURN OFF */
                     SUBSTATE=1;             /* NOW WAITING FOR VELOCITY BYTE */
                     KEY = MIDI + (SYNC.MIDDLE.C-MIDI.MIDDLE.C) + KBD_TRANSPOSE; /* CORRECT FOR OFFSET BETWEEN SYNC KEY#S AND MIDI KEY#S */
                  END;
                  ELSE DO;                   /* THEN PROCESS VELOCITY OF RELEASE */
                     #if (0)
                        MIDI_NOTE_OFFS = MIDI_NOTE_OFFS + 1;
                     #endif
                     SUBSTATE=0;             /* RESET */
                     DISABLE;                /* SO EXT CLOCK CODE WON'T INTERRUPT US */
                     IF NEW.NOTE.STAK(0)<NEW.NOTE.LIST.SIZE
                     THEN DO;                /* ADD TO LIST IF ROOM IN LIST */
                        NEW.NOTE.STAK(0)=NEW.NOTE.STAK(0)+1;
                        NEW.NOTE.STAK(NEW.NOTE.STAK(0))=(2\"10")\(SHL(ORIGIN,8)); /* CODE FOR RELEASED NOTE. SAVE POSSIBLE ORIGIN CODE */
                        NEW.NOTE.KEY#(NEW.NOTE.STAK(0))=KEY;   // ok if out of range here; range is checked later
                        NEW.NOTE.TIME(NEW.NOTE.STAK(0))=0;		// no time stamp for release by original MIDI hardware
                                                               // lower bits of new.note.time must be zero for releases
                                                               // upper half would be time stamp
                        /* IGNORE RELEASE VELOCITY */
                        // send 'Off:', KEY, ORIGIN, NEW.NOTE.STAK(0);
                     END;
                     ELSE MIDI.OVERRUN=1;    /* MIGHT HAVE MISSED SOMETHING */ 
                     ENABLE;
                  END;
               END;

               /* $PAGE */

               DO;                           /* STATE 02 -- NOTE.ON STATE */
                  IF SUBSTATE=0 THEN DO;     /* FIRST GET PITCH OF NOTE TO TURN ON */
                     SUBSTATE=1;
                     KEY = MIDI + (SYNC.MIDDLE.C-MIDI.MIDDLE.C) + KBD_TRANSPOSE; /* CORRECT FOR OFFSET BETWEEN SYNC KEY#S AND MIDI KEY#S */
                     if (key >= 0 && key < NUM.KEYS) {
                        LOAD ORIGIN; ULOAD KEY; MUL NUM.KEYS;
                        WRITE(MAM)=MIDI.KEY.PRESS+SHR(RES,8);
                        WRITE(MAL)=RES;   			  /* POINT TO PRESSURE TABLE */
                        WRITE(MD) =0;                /* INIT TO 0 TO PREVENT STUCK PRESSURES */
                        CURRENT.KEY(CHANNEL)=KEY;    /* SAVE FOR POLY TO MONO PRESSURE CONVERSION */
                     }
                  END;
                  ELSE DO;                   /* NOW PROCESS VELOCITY OF NEW NOTE */
                     SUBSTATE=0;             /* RESET */
                     DISABLE;                /* SO EXT CLOCK CODE WON'T INTERRUPT US */
                     IF NEW.NOTE.STAK(0)<NEW.NOTE.LIST.SIZE
                     THEN DO;                /* ADD TO LIST IF ROOM IN LIST */
                        NEW.NOTE.STAK(0)=NEW.NOTE.STAK(0)+1;
                        NEW.NOTE.KEY#(NEW.NOTE.STAK(0))=KEY;   // OK if out of range here

                        IF MIDI<>0           /* VELOCITY=0 IMPLIES RELEASED NOTE */
                        THEN DO;
                           NEW.NOTE.STAK(NEW.NOTE.STAK(0))=(1\"10")\(SHL(ORIGIN,8)); /* CODE FOR NEW NOTE. SAVE POSSIBLE ORIGIN CODE */
                           NEW.NOTE.TIME(NEW.NOTE.STAK(0))=KBD.MILLISECONDS;  /* USE NO SYNC DELAY FOR MIDI INPUT */

                           // Apply velocity sensitivity and mapping to velocity.
                           IF V.S.MIN<>100 THEN DO;      /*	ONLY IF OTHER THAN FULL SENSITIVITY	*/
                              LOAD V.S.MUL; MUL 127-MIDI; MIDI=URES;
                              IF RES<0 THEN MIDI=MIDI+1;
                           
                              WRITE(MAM)=VMAP.PTR;       /* LOOK UP VOLUME FROM TABLE */
                              WRITE(MAL)=127-MIDI;
                              MIDI      =READ(MD);       /* SAVE REMAPPED VALUE */
                           END;
                           ELSE DO;
                              WRITE(MAM)=VMAP.PTR;       /* LOOK UP VOLUME FROM TABLE */
                              WRITE(MAL)=MIDI;
                              MIDI      =READ(MD);       /* SAVE REMAPPED VALUE */
                           END;

                           //WRITE(MAM)=TRK.HEAD;              /* NOW SEE IF VELOCITY IS */
                           //WRITE(MAL)=ORIGIN;  					 /* SET POINTER TO PROPER TRACK */ // was midi  mapped
                           //WRITE(MAM)=READ(MD);              /* ACTIVE ON KBD TIMBRE */
                           //WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
                           //IF (READ(MD)&B.VELOCITY)=0        /* VELOCITY DISABLED */
                           //THEN MIDI=DEFAULT.MIDI.VELOCITY;  /* USE DEFAULT VALUE */

                           NEW.NOTE.VEL(NEW.NOTE.STAK(0))=MIDI; /* STORE NEW NOTE VOLUME */

                           // Inform interpreter we have a new key to process
								   if (newkey == 0) interp_newkey_pending(true);

                           NEWKEY=1;         /* ONLY SET FLAG FOR NEW NOTES - NOT FOR RELEASES */
                        END;
                        ELSE DO;
                           NEW.NOTE.STAK(NEW.NOTE.STAK(0))=(2\"10")\(SHL(ORIGIN,8)); /* CODE FOR RELEASED NOTE. SAVE POSSIBLE ORIGIN CODE */
                           NEW.NOTE.TIME(NEW.NOTE.STAK(0))=0;		// no time stamp for release by original MIDI hardware
                                                                  // lower bits of new.note.time must be zero for releases
                                                                  // upper half would be time stamp
                                                                  // this was Mike Thorne's bug
                           // send 'Off:', KEY, ORIGIN, NEW.NOTE.STAK(0);
                       END;
                     END;
                     ELSE MIDI.OVERRUN=1;    /* MIGHT HAVE MISSED SOMETHING */ 
                     ENABLE;
                  END;
               END;

               DO;                           /* STATE 03 -- POLY.PRESSURE STATE */
                  IF SUBSTATE=0 THEN DO;     /* FIRST GET PITCH OF NOTE TO UPDATE */
                     SUBSTATE=1;
                     KEY = MIDI + (SYNC.MIDDLE.C-MIDI.MIDDLE.C) + KBD_TRANSPOSE; /* CORRECT FOR OFFSET BETWEEN SYNC KEY#S AND MIDI KEY#S */
                  END;
                  ELSE DO;                   /* NOW GET INDIVIDUAL PRESSURE VALUE */
                     SUBSTATE=0;             /* RESET */
							WRITE(MAM)=TRK.HEAD;    /* LOOK UP PTR TO TRK HEAD     */
							WRITE(MAL)=ORIGIN;      /* FOR THIS CHANNELS TRACK */
							WRITE(MAM)=READ(MD);                /* POINT TO IT AND SET UP TO   */
							WRITE(MAL)=THD.ACTIVE.MIDI.RTES;    /* READ ACTIVE MIDI RTE BITS   */
                     IF (READ(MD)&B.PRESSURE)<>0 
                     THEN DO;                  		/* WE ARE LISTENING TO PRESSURE */
                        LOAD 18496; ULOAD MIDI; 	/* FRACTIONAL DIVIDE */
                        DIV 36992;             		/* EQUIVALENT TO MIDI*RTE.MAX/127 (64K*127/225 ROUNDED UP) */
                        MIDI=RES;
                        if (key >= 0 && key < NUM.KEYS) {
                           LOAD ORIGIN; ULOAD KEY; MUL NUM.KEYS;
                           WRITE(MAM)=MIDI.KEY.PRESS+SHR(RES,8);
                           WRITE(MAL)=RES;       /* POINT TO PRESSURE TABLE */
                           WRITE(MD) =MIDI;      /* STORE NEW INDIV PRESSURE VALUE */
                        }
                     END;
                  END;
               END;

               /* $PAGE */

               // Handle incoming MIDI control change messages
               DO;                                /* STATE 04 -- CONTROL.CHANGE STATE */
                  IF SUBSTATE=0 THEN DO;          /* FIRST GET CONTROLLER NUMBER */
                     SUBSTATE=1;
                     CONTROLLER=MIDI;
                  END;
                  ELSE DO;                        /* NOW GET UPDATE VALUE FOR CONTROLLER */
                     SUBSTATE=0;
                     I=(-1);
                     IF CONTROLLER<64
                     THEN DO;                     /* THIS IS A CONTINUOUS CONTROLLER NUMBER */
                        I=MIDI.CROUT(CONTROLLER); /* LOOK UP ROUTING */
                        IF I>=0 THEN DO;          /* CONTROLLER IS ROUTED SOMEWHERE */
                           IF CONTROLLER<32       /* CONTROLLER IS A 14-BIT VALUE */
                           THEN DO;               /* BUT WE ARE ONLY USING THE HIGH 7 BITS FOR NOW */

										WRITE(MAM)=TRK.HEAD;    		  /* LOOK UP PTR TO TRK HEAD     */
										WRITE(MAL)=ORIGIN;      		  /* FOR THIS CHANNELS TRACK */
										WRITE(MAM)=READ(MD);            /* POINT TO IT AND SET UP TO   */
										WRITE(MAL)=THD.ACTIVE.MIDI.RTES;    /* READ ACTIVE MIDI RTE BITS   */

                              IF (READ(MD)&BITS(I))<>0        /* THIS RTE CONTROLLER IS ENABLED */
                              THEN DO;                        /* MAP VALUE AND SET CHANGED BITS */
                                 IF I<>R.PWHEEL THEN DO;      /* NOT MAPPED TO PITCH WHEEL:  MAP 0-127 TO 0-RTE.MAX */
												LOAD 18496; ULOAD MIDI;   /* FRACTIONAL DIVIDE */
												DIV 36992;             	  /* EQUIVALENT TO MIDI*RTE.MAX/127 (64K*127/225 ROUNDED UP) */
												MIDI=RES;
                                 END;
                                 ELSE DO;                     /* PITCH WHEEL: MAP 0-127 TO -100 TO +100 */
                                    LOAD 0; WRITE(4)=MIDI;    /* FRACTIONAL DIVIDE */
                                    DIV 41582;                /* EQUIVALENT TO (MIDI*200/127)-100 (64K*126.9/200 ROUNDED) */
                                    MIDI=RES-100;
                                 END;

                                 WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+I,8);
                                 WRITE(MAL)=SHL(ORIGIN,3)+I;
                                 WRITE(MD) =MIDI;     /* UPDATE MIDI VALUE */
											J = SHR(ORIGIN, 4);
											MIDI.ANALOG.CHANGES    (ORIGIN) = MIDI.ANALOG.CHANGES    (ORIGIN) \ BITS(I); 					/* SET BIT TO DENOTE CHANGE HERE */
											MIDI.ANALOG.CHANGETABLE(J     ) = MIDI.ANALOG.CHANGETABLE(J     ) \ BITS(ORIGIN & "17"); 	/* SET BIT TO DENOTE ACTIVE CHANNEL */
											MIDI.ANALOG.CHANGEBITS          = MIDI.ANALOG.CHANGEBITS          \ BITS(J);
                              END;

                           END;
                           /* IGNORE THE LSB OF CONTROLLERS FOR NOW */
                        END;
                     END;
                     ELSE IF CONTROLLER<96
                     THEN DO;                        /* THIS IS A SWITCH */
                        I=MIDI.SROUT(CONTROLLER-64); /* LOOK UP ROUTING */
                        IF I>=0 THEN DO;             /* SWITCH IS ROUTED SOMEWHERE */
                           WRITE(MAM)=MIDI.SWITCHDATA+SHR(SHL(ORIGIN,3)+I,8);
                           WRITE(MAL)=SHL(ORIGIN,3)+I;
                           IF MIDI IGT 63
                           THEN WRITE(MD)=RTE.MAX; /* SWITCH IS ON */
                           ELSE WRITE(MD)=0;       /* SWITCH IS OFF */
									J = SHR(ORIGIN, 4);
                           MIDI.SWITCH.CHANGES    (ORIGIN) = MIDI.SWITCH.CHANGES    (ORIGIN) \ BITS(I); 					/* SET BIT TO DENOTE CHANGE HERE */
                           MIDI.SWITCH.CHANGETABLE(J     ) = MIDI.SWITCH.CHANGETABLE(J     ) \ BITS(ORIGIN & "17"); 	/* SET BIT TO DENOTE ACTIVE CHANNEL */
									MIDI.SWITCH.CHANGEBITS          = MIDI.SWITCH.CHANGEBITS          \ BITS(J);
								END;
                     END;
                     IF I=(-1) THEN DO;            /* THIS MIDI CONTROLLER NOT MAPPED TO A SYNLAV CONTROLLER */
                        DISABLE;                   
                        IF MIDI.RTE.STAK(0)<RTE.LIST.SIZE
                        THEN DO;                   /* ADD TO LIST IF ROOM IN LIST */
                           MIDI.RTE.STAK(0)=MIDI.RTE.STAK(0)+1;
                           MIDI.RTE.STAK(MIDI.RTE.STAK(0))=CONTROLLER\(SHL(ORIGIN,8)); /* SAVE CONTROLLER NUMBER AND POSSIBLE ORIGIN CODE */
                           MIDI.RTE.VALUE(MIDI.RTE.STAK(0))=MIDI;  /* SAVE CONTROLLER VALUE IN SEPARATE STACK */
                           MIDI.RTE.MSB(MIDI.RTE.STAK(0))=PLAY.TIME.MSB;
                           MIDI.RTE.LSB(MIDI.RTE.STAK(0))=PLAY.TIME.LSB;
                        END;
                        ELSE MIDI.OVERRUN=1;       /* MIGHT HAVE MISSED SOMETHING */ 
                        ENABLE;
                     END;
                  END;
               END;

               DO;                              /* STATE 05 -- PROGRAM.CHANGE STATE */

                  DISABLE;                /* SO EXT CLOCK CODE WON'T INTERRUPT US */

                  IF NEW.PROGRAM.STAK(0)<PGM.CHG.LIST.SIZE
                  THEN DO;                /* ADD TO LIST IF ROOM IN LIST */
                     NEW.PROGRAM.STAK(0)=NEW.PROGRAM.STAK(0)+1;
                     NEW.PROGRAM.STAK(NEW.PROGRAM.STAK(0))=128\MIDI\(SHL(ORIGIN,8)); /* SAVE TIMBRE NUMBER WITH VALID BIT AND POSSIBLE ORIGIN CODE */
                  END;

                  ENABLE;

               END;

               DO;                              	/* STATE 06 -- CHANNEL.PRESSURE STATE */
						WRITE(MAM)=TRK.HEAD;    		  	/* LOOK UP PTR TO TRK HEAD     */
						WRITE(MAL)=ORIGIN;      		  	/* FOR THIS CHANNELS TRACK */
						WRITE(MAM)=READ(MD);            	/* POINT TO IT AND SET UP TO   */
						WRITE(MAL)=THD.ACTIVE.MIDI.RTES; /* READ ACTIVE MIDI RTE BITS   */
                  IF (READ(MD)&B.PRESSURE)<>0   	/* PRESSURE INPUT ENABLED */
                  THEN DO;
							LOAD 18496; ULOAD MIDI;   		/* FRACTIONAL DIVIDE */
							DIV 36992;             	  		/* EQUIVALENT TO MIDI*RTE.MAX/127 (64K*127/225 ROUNDED UP) */
							MIDI=RES;
                     IF (MONO.TO.POLY.PRESSURE<>0) THEN DO;     /* SIMULATE MIDI MODE 4 FOR PRESSURE ONLY */
								LOAD ORIGIN; ULOAD CURRENT.KEY(CHANNEL); MUL NUM.KEYS;
                        WRITE(MAM)=MIDI.KEY.PRESS+SHR(RES,8);
                        WRITE(MAL)=RES;
                        WRITE(MD) =MIDI;                        /* STORE AS INDIVIDUAL PRESSURE VALUE */
                     END;
                     ELSE MIDI.PRESSURE(ORIGIN)=MIDI;           /* STORE AS OVERALL PRESSURE (STANDARD MODE) */
                  END;
               END;

               DO;                             /* STATE 07 -- PITCH WHEEL UPDATE */
                  IF SUBSTATE=0 THEN DO;		  /* IGNORE LSB OF PITCH WHEEL      */
                     SUBSTATE=1;
                  END;
                  ELSE DO;                     /* GET HIGH 7 BITS OF PITCH WHEEL POS */
                     SUBSTATE=0;               /* RESET */
							WRITE(MAM)=TRK.HEAD;      /* LOOK UP PTR TO TRK HEAD     */
							WRITE(MAL)=ORIGIN;        /* FOR THIS CHANNELS TRACK */
							WRITE(MAM)=READ(MD);      /* POINT TO IT AND SET UP TO   */
							WRITE(MAL)=THD.ACTIVE.MIDI.RTES;    /* READ ACTIVE MIDI RTE BITS   */
                     IF (READ(MD)&B.PWHEEL)<>0 /* PITCH WHEEL INPUT ENABLED */
                     THEN DO;
                        LOAD 0; WRITE(4)=MIDI;    /* FRACTIONAL DIVIDE */
                        DIV 41582;                /* EQUIVALENT TO (MIDI*200/127)-100 (64K*126.9/200 ROUNDED DOWN) */
                        MIDI=RES-100;

                        WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+R.PWHEEL,8);
                        WRITE(MAL)=SHL(ORIGIN,3)+R.PWHEEL;
                        WRITE(MD) =MIDI;     /* UPDATE MIDI VALUE */
								
								J = SHR(ORIGIN, 4);
								MIDI.ANALOG.CHANGES    (ORIGIN) = MIDI.ANALOG.CHANGES    (ORIGIN) \ BITS(R.PWHEEL); 		/* SET BIT TO DENOTE CHANGE HERE */
								MIDI.ANALOG.CHANGETABLE(J     ) = MIDI.ANALOG.CHANGETABLE(J     ) \ BITS(ORIGIN & "17"); 	/* SET BIT TO DENOTE ACTIVE CHANNEL */
								MIDI.ANALOG.CHANGEBITS          = MIDI.ANALOG.CHANGEBITS          \ BITS(J);
                      END;
                  END;
               END;

               /* $PAGE */

               DO;                           /* STATE 08  -- SYSTEM COMMON INFORMATION */
                  /* LOW 3 BITS OF CHANNEL CONTAINS THE TYPE OF SYSTEM
                     COMMON INFO BEING TRANSMITTED HERE */

                  CHANNEL=CHANNEL&7;           /* ONLY KEEP LOW 3 BITS OF THIS */
                  IF CHANNEL=2 THEN DO;        /* SONG POSITION POINTER */
                     IF SUBSTATE=0 THEN DO;    /* GET HIGH BITS OF MEASURE NUMBER */
                        SUBSTATE=1;
                        SYS.COMMON=MIDI;
                     END;
                     ELSE DO;                  /* GET REST OF MEASURE NUMBER OR SONG NUMBER */
                        SUBSTATE=0;
                        SYS.COMMON=SYS.COMMON\SHL(MIDI,7);
                        IF EXT.CLOCK.MODE=3 THEN DO;
                           MIDI.SONG.PTR.INFO=SYS.COMMON;
                           SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4)\5;
                        END;
                        MIDI.STATE=NULL.STATE; /* REZERO RUNNING STATUS */
                     END;
                  END;
                  ELSE IF CHANNEL=3 THEN DO;   /* SONG SELECT COMMAND */
                     SYS.COMMON=MIDI;          /* SAVE SONG NUMBER */
                     MIDI.STATE=NULL.STATE;    /* REZERO RUNNING STATUS */
                  END;
                  ELSE DO;                     /* EITHER TUNE REQUEST OR UNDEFINED */
                     /* IGNORE TUNE REQUEST */
                     MIDI.STATE=NULL.STATE;    /* REZERO RUNNING STATUS */
                  END;
               END;

               DO;                             /* STATE 09 -- SYSTEM EXCLUSIVE STATE */
                  CALL SAVE.SYSEX.BYTE(MIDI);  /* STORE DATA BYTE IN SYSEX BUFFER */
               END;

            END; /* OF BRANCH ACCORDING TO CURRENT MIDI SCANNING STATE */

         END; /* OF PROCESS MIDI DATA BYTE */

      END;    /* OF HANDLING NON-STATUS BYTE */

      ELSE IF MIDI<SYSTEM.EXCLUSIVE       /* NOTE ON/OFF, PRESSURE, ETC. */
      THEN DO;
         IF MIDI.STATE=EXCLUSIVE          /* WE HAVE BEEN IN SYSEX STATE */
         THEN CALL TERMINATE.SYSEX;       /* ANY STATUS BYTE MUST TERMINATE A SYSEX MESSAGE */
         SUBSTATE=0;                      /* RESET SECONDARY STATE VAR */
         CHANNEL=MIDI&15;                 /* EXTRACT POSSIBLE CHAN # */
         MIDI.STATE=(SHR(MIDI,4)&7)+1;    /* COMPUTE COMMAND TYPE */
      END;

      ELSE IF MIDI>=TIMING.CLOCK          /* TIMING CLOCK / SYSTEM RESET */
      THEN DO;
         IF (EXT.CLOCK.MODE=3)            /* SYNCHING TO MIDI FROM MAIN INPUT JACK */
         THEN CALL SYNC.TO.MIDI(MIDI);    /* SUBROUTINE TO DO THE SYNCHRONIZING */
      END;

      ELSE IF MIDI=SYSTEM.EXCLUSIVE
      THEN DO;                            /* ENTER SYSTEM EXCLUSIVE STATE */
         IF MIDI.INPUT.CHAN>(-2)  
         THEN DO;                         /* MIDI INPUT IS ENABLED */
            IF MIDI.STATE=EXCLUSIVE       /* WE HAVE BEEN IN SYSEX STATE */
            THEN CALL TERMINATE.SYSEX;    /* ANY STATUS BYTE MUST TERMINATE A SYSEX MESSAGE */

            PREV.STATE=MIDI.STATE;        /* SAVE THE CURRENT STATE FOR LATER */
            MIDI.STATE=EXCLUSIVE;         /* GO TO THE NEW STATE */

            CALL SAVE.SYSEX.BYTE(SYSTEM.EXCLUSIVE);
         END;
      END;

      ELSE DO;                            /* SYSTEM COMMON             */
         IF MIDI.STATE=EXCLUSIVE          /* WE HAVE BEEN IN SYSEX STATE */
         THEN CALL TERMINATE.SYSEX;       /* ANY STATUS BYTE MUST TERMINATE A SYSEX MESSAGE */
         SUBSTATE=0;                      /* RESET SECONDARY STATE VAR */
         CHANNEL=MIDI&15;                 /* EXTRACT POSSIBLE CHAN # */
         MIDI.STATE=(SHR(MIDI,4)&7)+1;    /* COMPUTE COMMAND TYPE */
      END;

      IF  (MIDI.STATE<=PITCH.WHEEL)       /* THIS STATE HAS A CHANNEL */
      AND (PTMC=1)                        /* MIDI MAPPED TO RECORDER  */
      THEN DO;
         WRITE(MAM)=TRK.HEAD;             /* POINT TO TRK HEAD */
         WRITE(MAL)=MIDI.MAPPING(CHANNEL+NUM.KBD.TRACKS);
         IF READ(MD)=0                    /* NO TRACK HEAD */
         THEN MIDI.STATE=NULL.STATE;      /* DISALLOW MIDI */
      END;

      /* $SUBTITLE  MIDI INPUT SCAN CODE -- HANDLE ALL DATA BYTES (I.E. NOT A COMMAND BYTE) */

      DISABLE;
      WRITE(SYSSEL)=MIDI.SUBSYS; /* RESELECT MIDI SUBSYSTEM 0 */
   END;    /* OF LOOP WHILE MIDI BYTES TO PROCESS */

   ENABLE;

   IF MIDI.BYTES.READ>63  /* I.E., INPUT BUFFER WAS FULL */
   THEN DO;               /* THIS PROBABLY INDICATES A BUFFER OVERRUN */
      MIDI.OVERRUN=1;     /* SO SET FLAG ACCORDINGLY */
      MIDI.STATE  =0;
      SUBSTATE    =0;
   END;

   /* $PAGE  NOW CHECK THE AUX INPUT FOR SYNCHRONIZING INFORMATION.
             IGNORE ALL OTHER INPUT ON THIS JACK FOR NOW */

   IF EXT.CLOCK.MODE=4             /* READ SYNC INFO FROM AUX INPUT JACK */
   THEN BEGIN;                     /* ASSUMES MODE<>4 IF < 8 OUTPUTS IN SYSTEM */

      MIDI.BYTES.READ=0;           /* REZERO TO CHECK FOR OVERRUNS HERE TOO */
      DISABLE;
      WRITE(SYSSEL)=MIDI.SUBSYS+1; /* SELECT MIDI SUBSYSTEM 1 */

      DO WHILE READ(MSTA);         /* LOOP WHILE BYTES TO PROCESS */

         WRITE(MCHA)=4;            /* SELECT INPUT CHANNEL    */
         MIDI=READ(MDAT);          /* GET NEXT MIDI BYTE */
         ENABLE;
         MIDI.BYTES.READ=MIDI.BYTES.READ+1;

			PROCESS.MIDI.AUX.BYTE(MIDI);

         DISABLE;
         WRITE(SYSSEL)=MIDI.SUBSYS+1; /* RESELECT MIDI SUBSYSTEM 1 */
      END;                            /* OF LOOP WHILE MIDI BYTES TO PROCESS */

      ENABLE;

      IF MIDI.BYTES.READ>63  /* I.E., AUX INPUT BUFFER WAS FULL */
      THEN DO;               /* THIS PROBABLY INDICATES A BUFFER OVERRUN */
         MIDI.OVERRUN=1;     /* SO SET FLAG ACCORDINGLY */
         SCANNING.SONGPTR=0;
      END;

   END;                               /* OF READING SYNC INFO FROM AUX INPUT JACK */

   WRITE("300")=ADDR(SAVE.MAM); /* RESTORE EXT MEM REGS */
   WRITE(MAM)  =READ("360");
   WRITE(MAL)  =READ("360");

END SCAN.MIDI;
