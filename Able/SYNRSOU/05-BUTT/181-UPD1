/*	:SYNRSOU:05-BUTT:181-UPD1  $TITLE  Process Value Changes Using Knob - subroutines	*/

/*
Modified:
2000/11/17 - TY  - Modified DISPLAY.TRACK.ROUTING.AND.VOLUME.DISPLAY() to handle muted outputs
2000/10/07 - TY  - Added call to DISPLAY.MWHEEL_PROXY() in DISPLAY.UPDATED.PARAMETER()
2000/04/17 - TY  - Removed obsolete variables
1994/01/06 - PF  - Added DISP.MULTI.ERRS
1991/01/09 - PF  - various bug fixes for sequencer and MIDInet
1990/10/09 - PF  - Moved DISPLAY.CLICK.RATE to 171-prf1
1988/12/02 - CJ  - ADDED VOICES USED DISPLAY TO POLYPHONY BUTTON
1988/08/19 - TSS - Changed references to INC.XXXX to DIAGNOSTICS.ENABLED
1988/05/31 - TSS - BROKE UP DISPLAY.UPDATED.PARAMETER TO MAKE SWAP AREA SMALLER
1988/01/27 - MWH - Allow track's prefered poly bin to be changed from VK
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/01/20 - TS  - ENHANCED POLYPHONY CONTROL DISPLAY
1987/01/20 - TS  - TRACK SLIDE PRESERVES FRACTIONS OF BEATS IN TRK STARTS IF IN JUSTIFIED MODE
1986/12/18 - CJ  - SHOW SOUNDFILE NAME WHEN PRESSING PARTIAL
1986/12/10 - CJ,TS,EG - FIXED TRACK SLIDE MEM/#PTR BUG
1986/12/03 - CJ  - CHANGED PROCEDURE NAME 'SUB' TO 'SUBIT' TO GET TO COMPILE WITH NEW ASCII LITS
1986/11/25 - TS  - ENHANCED INSERT/DELETE DISPLAY
1986/11/21 - ts  - added enhancements to mark button & click rate displays
1986/11/13 - TS  - CHAIN REPETITIONS DISPLAY
1986/11/05 - TS  - ENHANCED MARK BUTTON & INSERT/DELETE PARM DISPLAYS
1986/10/30 - TS  - ADDED CODE TO HANDLE INSERT/DELETE BUTTONS
1986/10/16 - TS  - RESET MARK.BUTTON.VALM/L AFTER SLIDE TRACKS
1986/10/08 - TS  - MOVED LOOP BUTTON DISPLAY CODE INTO LOOP.PARAMETER.DISPLAY PROC
1986/09/23 - TS  - ADDED MORE CODE TO ADD.TO.TIME; NEW DISPLAY TYPES FOR SLOOP,ELOOP
1986/09/17 - TS  - ENHANCED MARK BUTTON DISPLAY
1986/08/19 - TS  - SLIDE.TRACKS NOW TRIES TO KEEP PLAY/LOOP PTRS CORRECT
1986/08/12 - TS  - DISABLE TRACK START TIME DISPLAY DURING TRK SLIDE IF SLIDE DIST=0
1986/08/06 - TS  - PUT IN ERROR MESSAGE FOR TRYING TO SLIDE LIVE TRACK
1986/08/05 - TS  - MORE WORK ON SLIDE.TRACKS
1986/08/04 - CJ  - FIXED TRACK ROUTING/VOLUME DISPLAY FOR LOD TRACKS
1986/08/01 -CJ,EG- COMMENTED IN 'CAN NOT SLIDE LIVE TRACK' ERROR MSG
1986/07/31 - TS  - DID WORK ON SLIDE.TRACKS ROUTINE
1986/05/15 - "official" creation of release-M modules
*/

LOOP.PARAMETER.DISPLAY: PROC SWAPABLE;
	DCL STARTTIME(1)	FIXED;
	DCL DURATION (1)	FIXED;

	DCL DTYPE			FIXED;

	BOTH.DISPLAY=0;
	CALL CLEAR.UPPER;	/*	CLEAR WHOLE DISPLAY	*/

	IF LAST.LOOP.PARM=0 THEN DO;		/*	SHOW LOOP START TIME	*/
		CALL COPY32(LOC(ADDR(LOOP.START.MSB)), STARTTIME);
		DTYPE=#TIME;
	END;
	ELSE IF LAST.LOOP.PARM=1 THEN DO;	/*	SHOW LOOP END TIME	*/
		CALL COPY32(LOC(ADDR(LOOP.END.MSB)), STARTTIME);
		DTYPE=#TIME;
	END;
	ELSE DO;	/*	SHOW LOOP LENGTH	*/
		CALL COPY32(LOC(ADDR(LOOP.START.MSB)), STARTTIME);
		CALL SUB32(LOC(ADDR(LOOP.END.MSB)), STARTTIME, DURATION);
		IF DURATION(0) < 0 THEN CALL STR32(0, 0, DURATION);
		DTYPE=#DUR;
	END;

	CALL DISPLAY.TIME(0,STARTTIME,DURATION,DTYPE);	/*	DISPLAY THE PARAMETER	*/
	CALL CLEAR.LOWER;

	IF TROUT.TRK#=(-1)			/*	OVERALL LOOP DISPLAY	*/
	THEN CALL EMIT.STRING(16,'OVERALL');
	ELSE DO;
		CALL EMIT.STRING(16,'TRK');
		CALL EMIT.NUMBER(20,TBUT.MAPPING(TROUT.TRK#)-1,0,LEFT.JUST);
	END;

	DO CASE LAST.LOOP.PARM;
		CALL EMIT.STRING(24,'LP START');
		CALL EMIT.STRING(24,'LOOP END');
		CALL EMIT.STRING(24,'LOOP LEN');
	END;

	BOTH.DISPLAY=1;
	SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
END LOOP.PARAMETER.DISPLAY;

/*	$SUBTITLE	NUMERIC PARAMETER DISPLAY SUBROUTINES	*/

/*	$SUBTITLE	ROUTINE FOR SCALE ADJUST FREQUENCY DISPLAY	*/

DISPLAY.SCALE.ADJUST.FREQUENCY: PROC (KEY#,VALUE,PT,UN) SWAPABLE;
	DCL (KEY#,VALUE,PT,UN)	FIXED;
	DCL (TDATA,INCR,DIVI)	FIXED;

	DCL (PITCH.WINDOW) DATA
		 (ASC.C,ASC.C+SHL(asc.sharp,8),ASC.D,ASC.D+SHL(asc.sharp,8),ASC.E,
		  ASC.F,ASC.F+SHL(asc.sharp,8),ASC.G,ASC.G+SHL(asc.sharp,8),
		  ASC.A,ASC.A+SHL(asc.sharp,8),ASC.B);

	WRITE(MAM)=FRE.PTR+SHR(VALUE,8); WRITE(MAL)=VALUE;
	TDATA=READ(MD);									/*		GET INCREMENT, DIVISOR	*/
	INCR=SHR(TDATA,8); DIVI=TDATA&255;			/*		EXTRACT	*/
	IF INCR=0 THEN INCR=256; IF DIVI=0 THEN DIVI=256;
	TDATA=(16276*INCR/DIVI+3)/5;					/*		FOR NEW SYNTH	*/

	CALL DISPLAY.PAR.NUM(TDATA,PT,UN);

	IF NEW.PAN<>0 THEN DO;							/*	ADD LETTER INDICATOR	*/
		MISC.BUF(0)=1;
		MISC.BUF(1)=PITCH.WINDOW(KEY#-(SCALE.L-PAR.L));
		IF (MISC.BUF(1)&"177400")<>0
		THEN MISC.BUF(0)=2;
		CALL EMIT.STRING(14,MISC.BUF);
	END;
END DISPLAY.SCALE.ADJUST.FREQUENCY;

DISPLAY.HARMONIC.COEFFICIENT: PROC (PAR,VALUE,PT,UN) SWAPABLE;	/*	DISPLAY PHASE OR COEFFICIENT AS REQUIRED	*/
	DCL (PAR,VALUE,PT,UN)	FIXED;
	DCL (I,J)					FIXED;

	IF IN.BLINK.MODE=0
	THEN CALL DISPLAY.PAR.NUM(VALUE,PT,		UN);	/*	DISPLAY COEFFICIENT	*/
	ELSE CALL DISPLAY.PAR.NUM(VALUE, 0,256*25);	/*	DISPLAY PHASE 0-63	*/
	IF NEW.PAN<>0 THEN DO;		/*	DISPLAY ADDITIONAL INFO	*/
		I=12; J=PAR-11;			/*	COMPUTE BASIC POSITION, COEF # 1-X	*/
		IF HGS=1 THEN J=J+12;
		IF HGS=2 THEN J=J+24;	/*	13-24, 25-36	*/
		IF J<100 THEN I=13;
		CALL EMIT.STRING(I,'#');
		CALL EMIT.NUMBER(I+1,J,0,LEFT.JUST);
	END;
END DISPLAY.HARMONIC.COEFFICIENT;

DISPLAY.SMPTE.TIME: PROC SWAPABLE;	/*	12 - SMPTE DISPLAY	*/
   CALL CLEAR.UPPER;					/*	CLEAR UPPER DISPLAY	*/
   CALL EMIT.STRING(0,'  :  :  :');
   CALL EMIT.NUMBER(0,SM.HRS,2,LEFT.JUST);
   CALL CLEAR.DECIMAL.POINT(0);	/*	REMOVE FAULTY DP'S	*/
   CALL EMIT.NUMBER(3,SM.MIN,2,LEFT.JUST);
   CALL CLEAR.DECIMAL.POINT(3);	/*	REMOVE FAULTY DP'S	*/
   CALL EMIT.NUMBER(6,SM.SEC,2,LEFT.JUST);
   CALL CLEAR.DECIMAL.POINT(6);	/*	REMOVE FAULTY DP'S	*/
   CALL EMIT.NUMBER(9,SM.FRA,2,LEFT.JUST);
   CALL CLEAR.DECIMAL.POINT(9);	/*	REMOVE FAULTY DP'S	*/
   CALL EMIT.NUMBER(11,SM.BIT,2,LEFT.JUST);
	IF (NEW.ORK == 1) THEN DO;
		IF HELD.SMPTE.BUTTON=0			/*	NOT HELD				*/
		THEN CALL DISPLAY.ORK.WINDOW.TIMES(SM.FRA,SM.BIT);
		ELSE CALL DISPLAY.ORK.WINDOW.TIMES(SM.MIN,SM.SEC);
	END;
END DISPLAY.SMPTE.TIME;

/*	$SUBTITLE	*/

DISPLAY.TRACK.ROUTING.AND.VOLUME.DISPLAY: PROC (PAR#,VALUE,PT,UN) SWAPABLE;	/*	13: TRACK ROUTING/VOLUME DISPLAY	*/
	DCL (PAR#,VALUE,PT,UN)	FIXED;
	DCL (I,J)					FIXED;

	IF NEW.PAN=0
	THEN CALL DISPLAY.PAR.NUM(VALUE,PT,UN);	/*	ORIG PANEL?	*/
	ELSE DO;										/*	VK PANEL					*/
		CALL CLEAR.UPPER;						/*	CLEAR UPPER DISPLAY	*/

		IF TROUT.TRK#=(-1) THEN DO;		/*	KEYBOARD ROUTING	*/
			I=0;									/*	KEYBOARD TRK NUMBER	*/
			CALL EMIT.STRING(0,'KEYBRD');
		END;
		ELSE DO;
			I=TBUT.MAPPING(TROUT.TRK#);	/*	SAVE TRK NUMBER IN I	*/
			IF  (I>=FIRST.LOD.TRACK)
			AND (I< LAST.LOD.TRACK )
			THEN DO;
				CALL DISPLAY.ERR(49);		/*	"NOT AVAILABLE FOR LIVE TRACK"	*/
				I=(-1);
			END;
			ELSE DO;
				IF (TRK.HEAD.LOOKUP(I, THD.GROUPLIST) == 0)
					CALL EMIT.STRING(0,'TRK');
				ELSE
					CALL EMIT.STRING(0,'GRP');

				CALL EMIT.NUMBER(4,I+(1-NUM.KBD.TRACKS),0,LEFT.JUST);
			END;
		END;

		IF I>=0 THEN DO;
			IF (PAR#=(TRROUT.L-PAR.L)) THEN DO;				/*	ROUTING		*/
				IF TRK.HEAD.LOOKUP(I, THD.CUE.TRACK) <> 0	/*	CUE TRACK	*/
				THEN DO;
					J=TRK.HEAD.LOOKUP(I,THD.CUE.OUT);		/*	LOOK UP CUE ROUTING	*/
					CALL EMIT.STRING(7,'D-T-D:');
					IF J <> 0 THEN J = (J&31)+1;
					CALL EMIT.NUMBER(14, J, 0, LEFT.JUST);
					J=0;		/*	NO ERROR DISPLAYED IN LOWER	*/
					IF LOD.RUNNING = 0 THEN DO;
						CALL CLEAR.LOWER;
						CALL EMIT.STRING(16,'D-T-D Not Avail');
						J=1;
					END;
				END;
				ELSE DO;
					J=TRK.HEAD.LOOKUP(I,THD.TROU);		/*	LOOK UP MULTI ROUTING	*/
					CALL EMIT.STRING(7,'L:   R:');
					//	left
					write("313") = SHR(J,8);
					if (read("313") != 0) write("313") = (read("313")&63)+1;	//	check for muted output
					EMIT.NUMBER( 9,read("313"),0,LEFT.JUST);
					// right
					write("313") = J&255;
					if (read("313") != 0) write("313") = (read("313")&63)+1;	//	check for muted output
					EMIT.NUMBER(14,read("313"),0,LEFT.JUST);
					J=0;											/*	NO ERROR PRINTED YET	*/
					IF AMOUNT<>"100000" THEN DO;			/*	IF KNOB ACTUALLY CHANGED	*/
						IF MULTI.THERE=0 THEN DO;
							CALL CLEAR.LOWER;
							CALL EMIT.STRING(16,'MC NOT IN SYSTEM');
							J=1;
						END;
						ELSE IF ((MULTI.ERRS<>0)
						AND		(DISP.MULTI.ERRS<>0))
						THEN DO;
							CALL CLEAR.LOWER;
							CALL EMIT.NUMBER(16,MULTI.ERRS,0,LEFT.JUST);
							CALL EMIT.STRING(20,'VOICE ERRORS');
							J=1;
						END;
					END;
				END;
				IF POLYNUMS > 1 THEN DO;					/*	A MULTIPLE POLY BIN SYSTEM	*/
					IF J=0 THEN DO;							/*	NO ERROR DISPLAYED, SHOW BIN	*/
						CALL CLEAR.LOWER;
						J=TRK.HEAD.LOOKUP(I,THD.POLY);	/*	LOOK UP POLY BIN	*/
						CALL EMIT.STRING(21,'POLY BIN:');
						CALL EMIT.NUMBER(30,J+1,0,LEFT.JUST);
					END;
				END;
			END;
			ELSE DO;												/*	VOLUME	*/
				CALL TRK.HEAD.LOOKUP(I,THD.TVOL);		/*	LOOKUP TRACK VOLUME	*/
				CALL EMIT.NUMBER(10,READ(MD),1,RIGHT.JUST);
				CALL EMIT.STRING(7,'VOL:');
			END;
		END;
	END;
END DISPLAY.TRACK.ROUTING.AND.VOLUME.DISPLAY;

/*	$SUBTITLE	ROUTINE TO DISPLAY A PARAMETER VALUE	*/

/*	DISPLAY.UPDATED.PARAMETER:

.	THIS ROUTINE IS CALLED TO DISPLAY A PARAMETER IN THE DIGITAL WINDOW.
.	IT IS CALLED FROM WITHIN THE 'UPDATE' PROCEDURE.	*/

DISPLAY.UPDATED.PARAMETER:PROC(PAR, VALUE, TF.CODE) PUBLIC SWAPABLE;	/*	UPDATE THE DISPLAY - PASS PARAMETER INDEX NUMBER, THE NEW VALUE	*/
	DCL (PAR,VALUE,TF.CODE)	FIXED;
	DCL (I,J)					FIXED;
	DCL (DTYPE,PT,UN)			FIXED;
	DCL (PAR#)					FIXED;
	DCL (STARTTIME)	(1)	FIXED;
	DCL (DURATION )	(1)	FIXED;

	PAR#=SHR(PAR,8); PAR=PAR&255;					/*	EXTRACT BUTTON & PARAMETER CODE	*/

	IF (TF.CODE=0)\(PAR#>=12) THEN DO;			/*	LOOK UP INFO FOR MOST PARAMETERS FROM PAR. ARRAYS	*/
		IF PAR#<(START.L-PAR.L) THEN DO;
			DTYPE=PAR.TYPE	 (PAR#);					/*	GET DISPLAY FORMAT FOR PARAMETER	*/
			PT   =PAR.POINTS(PAR#);					/*	GET DECIMAL PT POSITION	*/
			UN   =PAR.UNS	 (PAR#);					/*	GET UNITS FOR PARAMETER	*/

			IF  (DIAGNOSTICS.ENABLED<>0)			/*	XXXX PROGRAM	*/
			AND (PAR#=(TBASE.L-PAR.L))				/*	OVERALL TUNING	*/
			THEN DO;										/*	DISPLAY VOICE CHANGE	*/
				DTYPE=0; PT=0; UN=(256*38);		/*	SPECIAL UNITS 'TEST CHAN'	*/
			END;
		END;
		ELSE DO;											/*	SPECIAL CASES FOR	*/
			IF (PAR#=(INSERT.L-PAR.L))				/*	PSEUDO PARAMS		*/
			OR (PAR#=(DELETE.L-PAR.L))
			THEN DTYPE=18;
			ELSE IF PAR#=CHAIN.L-PAR.L
			THEN DO;										/*	KLUDGE TO GET CORRECT DISPLAY	*/
				DTYPE=0;
				PT   =0;
				UN   =256*37;							/*	SHOWS 'REPEAT COUNT' LABEL	*/
			END;
		END;
	END;
	ELSE DO;												/*	SPECIAL INFO FOR TIMBRE FRAME PARAMETERS	*/
		DTYPE=0;											/*	DISPLAY TYPE FOR TIMBRE FRAME PARMS	*/
		PT   =E.SEG.POINTS(PAR#);					/*	GET DECIMAL PT POSITION	*/
		UN   =E.SEG.UNS	(PAR#);					/*	AND UNITS FOR TIMBRE FRAME PARM	*/
	END;

	/*	BRANCH ON DISPLAY TYPE	*/

	DO CASE (DTYPE);	/*	BRANCH ON TYPE OF DISPLAY REQUIRED FOR THIS PARAMETER	*/

		CALL DISPLAY.PAR.NUM(VALUE,PT,UN);				/*	0: REGULAR	*/

		CALL DISPLAY.VIBRATO(VALUE);						/*	1: SHOW VIBRATO CODE	*/

		CALL DISPLAY.SCALE.ADJUST.FREQUENCY(PAR#,VALUE,PT,UN);	/*	2: FREQUENCY DISPLAY (SCALE ADJUST)	*/

		CALL DISPLAY.CLICK.RATE(VALUE);

		{	DISPLAY.SIGNED.PAR.NUM(VALUE,UN);			/*	4: SMALL +/- NUMBERS: HADJ, STCEN	*/
			if (PAR# == vkxpos.l-PAR.L)
			{	//	this is needed because otherwise the user may not know what this parameter is (since the button panel is labeled "CUT/BOOST")
				IF (PLAY == false)
				{	CALL CLEAR.LOWER;
					EMIT.STRING(16,'KEYBRD TRANSPOSE');
					LOWER.DISP	= TIME.DISP;
				}
				SUPRESS.BEAT.DISPLAY	= false;
			}
			if (PAR# == midixpos.l-PAR.L)
			{	//	this is needed because otherwise the user may not know what this parameter is (since the button panel is labeled "CUT/BOOST")
				IF (PLAY == false)
				{	CALL CLEAR.LOWER;
					EMIT.STRING(16,'MIDI OUT TRANSP ');
					LOWER.DISP	= TIME.DISP;
				}
				SUPRESS.BEAT.DISPLAY	= false;
			}
		}

		CALL DISPLAY.PAR.NUM(VALUE*10,2,UN);			/*	5: STEREO RATE	*/

		DO;														/*	6: DISPLAY CORRECT ATTACK TIME	*/
			LOAD VALUE; MUL 36864;
			CALL DISPLAY.PAR.NUM(READ(4),0,1);
		END;

		CALL DISPLAY.HARMONIC.COEFFICIENT(PAR,VALUE,PT,UN);	/*	7: DISPLAY PHASE OR COEFFICIENT AS REQUIRED	*/

		DO;														/*	8: TONE BEND DISPLAY - EITHER NEW OR OLD	*/
			IF VALUE>=0
			THEN CALL DISPLAY.PAR.NUM(VALUE,2,256*04);	/*	SEMITONES	*/
			ELSE CALL DISPLAY.PAR.NUM(VALUE,1,256*26);	/*	% OF VIBRATO DEPTH	*/
		END;

		/*	$PAGE	*/

		DO;														/*	9: STEREO MODE DISPLAY	*/
			IF NEW.PAN<>0
			THEN CALL DISPLAY.STEREO(VALUE);
			ELSE CALL DISPLAY.PAR.NUM(VALUE,PT,UN);	/*	OLD PANEL DISPLAY MODE NUMBER	*/
		END;

		IF (NEW.PAN<>0) THEN DO;							/*	10: TIMBRE NAME DISPLAY ON NEW KBD ONLY	*/
			CALL TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);
			CALL DISPLAY.TIMBRE.NAME(READ(MD),0);
		END;

		DO;														/*	11 - USE SINGLE DP IF MINUS (RATIO)	*/
			IF VALUE>=0
			THEN CALL DISPLAY.PAR.NUM(VALUE,PT,UN);
			ELSE CALL DISPLAY.PAR.NUM(VALUE,1,2);		/*	MINUS DISPLAY - USE HERTZ	*/
		END;

		CALL DISPLAY.SMPTE.TIME;							/*	12 - SMPTE DISPLAY	*/

		CALL DISPLAY.TRACK.ROUTING.AND.VOLUME.DISPLAY(PAR#,VALUE,PT,UN);	/*	13: TRACK ROUTING/VOLUME DISPLAY	*/

		DO;														/*	14: MIDI ROUTING	*/
			IF (midi.there & (MIDI.THERE.OMS | MIDI.THERE.ORIG)) == 0 THEN DO;
				CALL DISPLAY.ERR(40);				/*	MIDI IS NOT AVAILABLE	*/
			END;
			ELSE DO;						/*	VK PANEL					*/
				CALL CLEAR.UPPER;		/*	CLEAR UPPER DISPLAY	*/

				IF (MIDI.PARAM.ID == 0)		/*	display midi output and channel for keyboard	*/
				{
					// Note that 'value' is not the value from the track head (thd.midi). It has been modified to be mono-tonic.
					
					// if ((val & THD.MIDI.OMS) != 0)				// Routed to OMS
					// {
					// 	if ((val & THD.MIDI.OMS.VPORT) != 0)	// Routed to Virtual Port
					// 		val = (val & (THD.MIDI.OMS | THC.MIDI.OMS.VPNUM | THC.MIDI.OMS.VPMC)) + 1;
					// 	else
					// 		val = THD.MIDI.OMS;
					// }
					// 
					// else if ((val & THD.MIDI.ORIG) != 0)	// Routed to original hardware output
					// {
					// 	val = val & THD.MIDI.ORIG;    		// Extract output specifier
					// 	val = (shl(val & 7, 6) 					// Get midi substem * 64
					// 	    \ (shr(val, 1) & 0x30) 			// Get 2 bits of which output from bit position 5
					// 	    \ (shr(val, 8) & 15)) 				// Get 4 bits of MIDI output
					// 	    + 1;										// Present to user as 1-x
					// }
					// 
					// else
					// 	val = 0;
					
					IF VALUE=0 THEN DO;
						CALL EMIT.STRING(0,'MIDI: OUTPUT OFF');
					END;
					ELSE IF (VALUE & THD.MIDI.OMS) != 0 THEN DO;
						if (VALUE == THD.MIDI.OMS)
							CALL EMIT.STRING(0,'MIDI: TO OMS');
						else
						{
							CALL EMIT.STRING(0,'MIDI:V[  ] C[  ]');
							CALL EMIT.NUMBER( 7,SHR((VALUE-1)&THC.MIDI.OMS.VPNUM,4)+1,0,LEFT.JUST);
							CALL EMIT.NUMBER(13,   ((VALUE-1)&THC.MIDI.OMS.VPMC   )+1,0,LEFT.JUST);
						}
					END;
					ELSE DO;
						CALL EMIT.STRING(0,'MIDI:O[  ] C[  ]');
						CALL EMIT.NUMBER( 7,SHR((VALUE-1),   4)+1,0,LEFT.JUST);
						CALL EMIT.NUMBER(13,   ((VALUE-1) & 15)+1,0,LEFT.JUST);
					END;
				}

				else								/*	display midi sync output	*/
				{
					if (midi.sync.is.tc != 0)
						call emit.string(0,'MIDI TC  OUT:   ');
					else
						call emit.string(0,'MIDI CLK OUT:   ');

					if (value = 0)
						call emit.string(13, 'OFF');

					else if (value == max.midi.chan+1)
						call emit.string(13, 'OMS');

					else
						call emit.number(13, value, 0, left.just);
				}
			END;

		END;

		DO;														/*	15: REPEAT RATE	*/
			IF EXT.REP.ARP=0
			THEN CALL DISPLAY.PAR.NUM(VALUE,PT,UN);
			ELSE DO;
            CALL CLEAR.UPPER;			/*	CLEAR UPPER DISPLAY	*/
            CALL EMIT.STRING(0,'EXTERNAL REPEAT');

            IF (NEW.ORK == 1) THEN BEGIN;
               DCL MSG.E DATA ("100"+SHL("100",8),"100"+SHL("171",8),0);
               DISPLAY.ORK.WINDOW.MESSAGE(MSG.E);
            END;
			END;
		END;

		DO;	/*	16: MARK BUTTON	*/
			IF NEW.PAN<>0 THEN DO;
				CALL CLEAR.UPPER;	/*	GET RID OF OTHER STUFF	*/
				CALL DISPLAY.TIME(0,LOC(ADDR(MARK.BUTTON.MSB)),DURATION,#TIME);	/*	DISPLAY EXACT MARK START TIME	*/
				IF PLAY=0 THEN DO;
					CALL CLEAR.LOWER;
					CALL EMIT.STRING(16,'MARK POINT:');
					IF MARK.BUTTON.DISABLED=0
					THEN CALL EMIT.STRING(28,'ON' );
					ELSE CALL EMIT.STRING(28,'OFF');
					LOWER.DISP=TIME.DISP;
				END;
				SUPRESS.BEAT.DISPLAY=0;		/*	NO LONGER SUPPRESSED	*/
			END;
			ELSE CALL DISPLAY.PAR.NUM(VALUE,PT,UN);	/*	DISPLAY VALUE	*/
		END;

		IF NEW.PAN<>0 THEN DO;								/*	17: LOOP START, END, AND LEN PARAMETER DISPLAYS	*/
			CALL LOOP.PARAMETER.DISPLAY;	/*	DO WORK IN PROC	*/
		END;

		IF NEW.PAN THEN DO;									/*	18: EDIT LENGTH DISPLAY (FOR INSERT.L & DELETE.L)	*/

			CALL CLEAR.UPPER;			/*	GET RID OF OTHER STUFF	*/

			I=MARK.BUTTON.MSB;		/*	GET MARK TIME HANDY	*/
			J=MARK.BUTTON.LSB;
			IF (I=0)&(J ILT ZERO.TIME)
			THEN J=ZERO.TIME;

			IF (PLAY<>0)				/*	IF PLAYING, MUST PRESERVE BEAT COUNT	*/
			OR (EDIT.DISP.MODE=0)	/*	OR SHOWING LENGTH								*/
			THEN DO;
				CALL DISPLAY.TIME(0,LOC(ADDR(I)),LOC(ADDR(EDIT.LEN.MSB)),#DUR);	/*	SHOW LEN IN CORRECT FORMAT	*/
			END;
			IF PLAY=0 THEN DO;						/*	NOT PLAYING 0: SHOW COMPLETE INFO	*/
				IF EDIT.DISP.MODE<>0 THEN DO;		/*	SHOW END TIME								*/
					CALL ADD32(LOC(ADDR(I)), LOC(ADDR(EDIT.LEN.MSB)), LOC(ADDR(I)));
					CALL DISPLAY.TIME(0,LOC(ADDR(I)),DURATION,#TIME);	/*	SHOW END TIME OF EDIT	*/
				END;
				CALL CLEAR.LOWER;
				IF PAR=(INSERT.L-PAR.L)
				THEN CALL EMIT.STRING(16,'INSERT');
				ELSE CALL EMIT.STRING(16,'DELETE');
				IF EDIT.DISP.MODE=0
				THEN CALL EMIT.STRING(23,'LENGTH');
				ELSE CALL EMIT.STRING(23,'END TIME');
				LOWER.DISP=TIME.DISP;
			END;
			SUPRESS.BEAT.DISPLAY=0;	/*	NO LONGER SUPPRESSED	*/
		END;

		DO;														/*	19: POLYPHONY CONTROL	*/
			CALL DISPLAY.PAR.NUM(VALUE,PT,UN);	/*	SHOW CURRENT POLYPHONY VALUE	*/
			IF NEW.PAN THEN DO;
				IF (VALUE=1) THEN DO;				/*	FOR MONO VOICE TIMBRES, DISPLAY AUTOPHRASING MODE	*/
					CALL CLEAR.LOWER;
					LOWER.DISP=POLYPHONY.DISP;
					CALL EMIT.STRING(16,'AUTOPHRASE:');
					IF (P.LOOKUP(TIM.HEAD.LOOKUP(0,TIM.MISC.POINTER))&BIT.APHRASE)<>0
					THEN CALL EMIT.STRING(28,'ON ');
					ELSE CALL EMIT.STRING(28,'OFF');
					SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
					BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
					BOTH.DISPLAY=1;
				END;
				ELSE DO;
					IF LOWER.DISP=POLYPHONY.DISP THEN CALL CLEAR.LOWER;

					IF POLYNUMS <> 0 THEN DO;
						/*	DISPLAY VOICE USAGE IN LOWER LINE	*/

						CALL CLEAR.LOWER;
						LOWER.DISP = USED.DISP;
						CALL EMIT.STRING(16,'USED:');

						DO I = 0 TO POLYNUMS-1;						/*	SHOW MAX USED FOR EACH BIN	*/
							IF I < 3 THEN DO;							/*	ONLY ROOM FOR 3 BINS	*/
								CALL EMIT.NUMBER(22+I*3,POLYUSED(I),0,LEFT.JUST);
							END;
						END;

						SUPRESS.BEAT.DISPLAY=1;						/*	STOP BEAT DISPLAYS MOMENTARILY	*/
						BEAT.DISPLAY.TIME=REAL.MILLISECONDS;	/*	HOLD DISPLAY FOR 5 SECONDS	*/
						BOTH.DISPLAY=1;
					END;
				END;
			END;
		END;

		DO;														/*	20: CLICK VALUE	*/
			CALL DISPLAY.CLICK.VALUE(LOOKUP.CLICK.VALUE(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB))));	//	this calls CLEAR.UPPER()
		END;

		DO;														/*	21: METER DISPLAY	*/
			CALL CLEAR.UPPER;
			CALL DISPLAY.METER;
		END;

		DISPLAY.MWHEEL_PROXY(VALUE);						/*	22: MOD WHEEL PROXY DISPLAY	*/

	END;	/*	OF DO CASE	*/

	UPPER.DISP=PAR;	/*	INDICATE WHICH NORMAL PARAMETER DISPLAY IS IN WINDOW	*/

	IF ((UPPER.DISP == (TNAME.L - PAR.L))
	||  (UPPER.DISP == (BPM.L	 - PAR.L)))
	ANY.MISC.FUNCTIONS = TRUE;

END DISPLAY.UPDATED.PARAMETER;

