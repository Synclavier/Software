/*	072-NEWI  $TITLE  Drivers for New Button Panel Functions

Modified:
2002/09/24 - TY  - Keyboard octave shift feature
2002/08/24 - TY  - Modified emit_int.fract() to work around the fact that set.wimage() wipes out the decimal point
2000/06/28 - TY  - Added the procedure emit_int.fract()
1991/02/07 - MWH - Combine 3200, 6400 and 9600 RTP's
1990/08/27 - PF  - Support all MIDI controllers
1989/11/15 - TSS - FIX BUG IN TERMULATOR MEASURES:BEATS DISPLAY
1989/07/12 -	  - ADDED SOME CODE TO SET TTIME.MIN AND TO DO VELOCITY SENSITIVITY BETTER
1989/06/05 - TSS - ADDED CODE TO SUPPORT KEYBOARD MAP FILES
1988/09/24 - TSS - ADDED CODE TO SET NEW.CLAVIER.INFO FOR WINDOW DISPLAY CHANGES
1987/09/03 - MWH - FIX MIDI BUG: NOTES NOW SOUND EVEN IF KEYBOARD UNPLUGGED
1986/10/09 -CJ,TS- ADDED KBD.SYNC.DELAY TO NEW.NOTE.TIME
1996/09/16 - TS  - ADDED EMIT.CHAR ROUTINE
1986/05/15 - "official" creation of release-M modules
*/

/*	THIS FILE CONTAINS I/O DRIVERS THAT USE THE VELOCITY/PRESSURE KEYBOARD	*/

DCL MIDI.RTE.STAK	 (RTE.LIST.SIZE)			FIXED PUBLIC;
DCL MIDI.RTE.VALUE (RTE.LIST.SIZE)			FIXED PUBLIC;
DCL MIDI.RTE.MSB	 (RTE.LIST.SIZE)			FIXED PUBLIC;
DCL MIDI.RTE.LSB	 (RTE.LIST.SIZE)			FIXED PUBLIC;

DCL DP.DATAS	(3)		FIXED PUBLIC;		/*	CURRENT DECIMAL POINT BITS	*/
DCL DP.TABLE	DATA PUBLIC (32,48,36,52);	/*	DECIMAL POINT ADDRESSES		*/

/*	FOR BLINKING	*/

DCL TTIME.MIN	FIXED PUBLIC;	/*	TRANSIT TIME REQUIRED TO ACHIEVE MAX VOLUME	*/

LOAD.DATA: PROC (BASE.M,BASE.L,OFFSET,DEST.PTR,LEN) SWAPABLE;
	DCL (BASE.M,BASE.L)	FIXED;	/*	DEVICE AND SECTOR DISK ADDR TO READ FROM	*/
	DCL OFFSET				FIXED;	/*	OFFSET FROM BASE	*/
	DCL DEST.PTR			FIXED;	/*	XMEM PTR TO DEST	*/
	DCL LEN					FIXED;

	BASE.L = BASE.L + OFFSET;
	IF BASE.L ILT OFFSET THEN BASE.M = BASE.M + 1;

	CALL EXT.READDATA(BASE.M,BASE.L,DEST.PTR,0,0,LEN);	/*	READ DATA INTO BUFFER	*/

END LOAD.DATA;

DCL COMPUTE.MIDI.VELMAPS PROC RECURSIVE;	/*	COMPUTES NEW VELOCITY TO VOLUME TABLE	*/

COMPUTE.SYNC.TTIME.MAP: PROC (VEL.MODE) PUBLIC SWAPABLE;	/*	COMPUTES A LOOKUP TABLE FOR TRANSIT TIME TO VOLUME	*/
	DCL VEL.MODE	FIXED;
	DCL (I,J)		FIXED;

	/*	NOTE: THIS ROUTINE MAKES TWO ASSUMPTIONS.  FIRST VEL.MODE MUST BE IN
		THE RANGE 0 TO 9 OR THE ROUTINE WILL BLOW UP.  SECOND, TTMAP.PTR MUST
		BE DEFINED PRIOR TO CALLING THIS PROCEDURE.	*/

	IF INC.KBD.MAPS THEN DO;			/*	TRY TO USE MAPS ON DISK		*/
		IF MAP.THERE<>0 THEN DO;		/*	READ MAPS FROM DATA FILE	*/
			CALL LOAD.DATA(MAPDEV,MAPSEC,TTIME.MAPS+VEL.MODE,TTMAP.PTR,256);

			J = 0;							/*	ASSUME MAP IS VALID	*/
			WRITE(MAM)=TTMAP.PTR;
			DO I = 0 TO 255;
				IF READ(MDI) IGT RTE.MAX THEN J = 1;	/*	MAP IS INVALID	*/
			END;
			IF J = 0 THEN DO;				/*	MAP IS OK SO FAR	*/
				J = 1;						/*	ASSUME MAP IS ALL ZERO & INVALID	*/
				WRITE(MAM)=TTMAP.PTR;
				DO I = 0 TO 255;
					IF READ(MDI) <> 0 THEN J = 0;	/*	AT LEAST ITS NON ZERO	*/
				END;
			END;
			IF J = 0 THEN DO;
				/*	LOOK AT MAP DATA AND SET UP TTIME.MIN SO VELOCITY	*/
				/*	SENSITIVITY STUFF WORKS PROPERLY							*/
				TTIME.MIN = (-1);
				WRITE(MAM)=TTMAP.PTR;
				WRITE(MAL)=1;
				I=1;
				DO WHILE (I ILT 256) & (TTIME.MIN<0);
					IF READ(MDI) ILT RTE.MAX THEN TTIME.MIN=I-1;
					I=I+1;
				END;
				IF TTIME.MIN<0 THEN TTIME.MIN=0;	/*	WIERD CASE	*/
				RETURN;		/*	MAP SEEMS TO BE VALID	*/
			END;
		END;
	END;

	DCL MAGIC#		LIT '61770';	/*	FRACTION USED TO GENERATE VOL TABLE (GIVES RANGE OF 110)	*/
	DCL ABS.MIN.TT	LIT '5';			/*	SMALLEST MINIMUM TRANSIT TIME	*/
	DCL TT.STEP		LIT '5';			/*	INCREMENT BETWEEN ADJACENT MIN TTIMES	*/
	DCL MIN.VOL		LIT '3';			/*	SMALLEST VOLUME GENERATED	*/

	TTIME.MIN=ABS.MIN.TT+VEL.MODE*TT.STEP;

	WRITE(MAM)=TTMAP.PTR;	/*	LOAD PTR TO SYNCLAVIER VELOCITY MAP TABLE	*/

	/*	FIRST START ARRAY WITH VOL.MAX	*/
	/*	CODE BELOW LOADS ONE EXTRA RTE.MAX VALUE INTO TABLE.  THIS
		IS BECAUSE WE NEED TO SKIP OVER ELEMENT ZERO.	*/
	WRITE("313")=RTE.MAX;		/*	PUT IN R13 FOR SPEED	*/
	IF INC.POLY OR (MODC<>0) THEN DO;	/*	OKAY TO USE REPEAT COUNTER	*/
		RPC TTIME.MIN; WRITE(MDI)=READ("313");
	END;
	ELSE DO I=1 TO TTIME.MIN;
		WRITE(MDI)=READ("313");
	END;

	/*	NOW COMPUTE VOLUME CURVE FOR DECAYING REGION		*/
	J=MAGIC#;							/*	START WITH MAGIC #	*/
	WRITE("313")=SHL(RTE.MAX,8);	/*	INIT R13 TO MAX VOLUME SHIFTED LEFT FOR ACCURACY	*/
	I=TTIME.MIN;
	DO WHILE (READ("313")IGT (SHL(MIN.VOL,8)-1)) AND (I<256);
		WRITE(MDI)=SHR(READ("313"),8)+((READ("313")&128)<>0);
		LOAD READ("313"); MUL J; WRITE("313")=READ(4);
		I=I+1;
		LOAD -J; MUL -512; J=-READ(4);
	END;

	/*	AT THIS POINT I EQUALS THE NUMBER OF VALUES WHICH HAVE BEEN
		STORED IN THE TABLE	*/

	/*	NOW FILL REST OF ARRAY WITH VOL.MIN	*/
	I=256-I;				/*	NUMBER OF PTS LEFT TO FILL IN MAP	*/
	IF I>0 THEN DO;
		IF INC.POLY OR (MODC<>0) THEN DO;	/*	OKAY TO USE REPEAT COUNTER	*/
			RPC I; WRITE(MDI)=MIN.VOL;
		END;
		ELSE DO I=1 TO I; WRITE(MDI)=MIN.VOL; END;
	END;
END COMPUTE.SYNC.TTIME.MAP;

/*	$SUBTITLE  VELOCITY KEYBOARD DEVICE SCANNING ROUTINES	*/

/*	SCAN.FOR.NOTES IS CALLED EVERY 5 MS. FROM THE REAL TIME CLOCK	*/
/*	INTERRUPT ROUTINE																*/

/*	A SOFTWARE FLAG KEEPS US FROM BEING RE-ENTERED						*/

/*	INTERRUPTS ARE ON DURING THE SCAN (FOR DISK INTERRUPS, ETC)		*/

DCL LAST.NOTE.TYPE	FIXED PUBLIC;
DCL LAST.NOTE.KEY#	FIXED PUBLIC;
DCL LAST.NOTE.VEL    FIXED PUBLIC;
DCL OLDKCR           FIXED PUBLIC;

DCL NEW.VEL.SENSITIVITY	LIT '0';	/*	0=>Matches Rev 2.0 RTP, 1=>New Dyn Range Limiter Algorithm	*/

SCAN.VKP.FOR.NOTES: PROC PUBLIC; /*	CREATE LIST OF NEW NOTES ON KEYBOARD	*/
	DCL (MASK1,MASK2,KCR)				FIXED;
	DCL (KEYS.NEW,KEYS.REL)				FIXED;
	DCL CLAVIER		(NUM.OCTAVES-1)	FIXED;	/*	CURRENT KEY BITS	*/
	DCL OLD.CLAVIER(NUM.OCTAVES-1)	FIXED;
	DCL (I,J,K,L)							FIXED;

	IF INC.CREG=0 THEN RETURN;

	IF READ(DREG)=0 THEN DO;					/*	DETECT POWER TURNED OFF	*/
		IF POWER.OFF=0 THEN DO;					/*	POWER JUST FAILED			*/
			DO I=0 TO (NUM.OCTAVES-1);				/*	CHECK FOR CHANGE IN EACH SUPEROCTAVE	*/
				CLAVIER(I)=0; OLD.CLAVIER(I)=0;	/*	PROVIDE ZERO FOR WHEN POWER RETURNS	*/
			END;
			POWER.OFF=1;							/*	1 MEANS POWER JUST NOW FAILED	*/
		END;
		WRITE(CREG)=0;								/*	REMOVE READ	*/
		RETURN;
	END;

	KCR=(NOT(READ(DREG))&"017437")\OLDKCR;	/*	GET KEYBOARD CHANGE REG - IGNORE OTHER BITS FOR NOW. - NOTE UNDISCOVERED USE OF NEGATIVE LOGIC	*/

	WRITE(CREG)=0;									/*	REMOVE READ	*/

	OLDKCR=0;										/*	CLEAR HERE - SET IF OUT OF STACK BELOW	*/

	/*	$PAGE - SCAN FOR NEW OR RELEASED KEYS (NEW KEYBOARD)	*/

	KCR=KCR\SHR(KCR,8);							/*	OR UP AND DOWN BYTES TOGETHER	*/
	WRITE(CREG)=1;									/*	SET DREG ADDRESSS TO INDICATE EXPANDED OPCODES	*/
	MASK1=1;											/*	INIT BIT MASK FOR KCR	*/
/*
	File "PB_G3_400_ATA2:Programming:Able:SYNLITS:SYNCLITS"; Line 77 	# DCL NUM.OCTAVES	LIT ' 5';	//	# SUPEROCTAVES (16 KEY)
	I		K = shl(I,4)	K|J (J = 0 to 15)		+9
	0		 0					 0 to 15					 9 to 24		a0  to c2
	1		16					16 to 31					25 to 40		c#2 to e3
	2		32					32 to 47					41 to 56		f3  to g#4
	3		48					48 to 63					57 to 72		a4  to c6
	4		64					64 to 79					73 to 88		c#6 to e7
			80
set keynum 72; evaluate {keynum} mod 12; evaluate {keynum} Ö 12
*/
	DO I=0 TO (NUM.OCTAVES-1);					/*	CHECK FOR CHANGE IN EACH SUPEROCTAVE	*/
		IF (MASK1&KCR)<>0 THEN DO;				/*	CHECK FOR CHANGE IN OCTAVE	*/
			WRITE(DREG)="417"\SHL(I,4);		/*	REQUEST ACTIVITY WORD	*/
			PULSE_EXWR;
			CLAVIER(I)=READ(DREG);				/*	GET ACTIVITY WORD	*/
			KEYS.NEW	= CLAVIER(I) AND (NOT OLD.CLAVIER(I));	/*	NEW KEYS DOWN	*/
			KEYS.REL	= OLD.CLAVIER(I) AND (NOT CLAVIER(I));	/*	RELEASED KEYS	*/

			K=SHL(I,4);								/*	PRECOMPUTE SUPEROCTAVE NUMBER	*/
			MASK2=1;									/*	INIT BIT MASK FOR KEYS	*/
			IF KEYS.NEW<>0 THEN DO J=0 TO 15;	/*	LOOP OVER KEYS IN OCTAVE	*/
				IF (MASK2&KEYS.NEW)<>0 THEN DO;	/*	NEW KEY DOWN - NOTE - WE MIGHT LOOSE KEYS HERE	*/
					DISABLE;								/*	FOR NEW.NOTE.STAK CHECK SINCE WE COULD GET INTERRUPTED FOR EXT CLOCK INPUT NOTE TRIGGER	*/
					IF NEW.NOTE.STAK (0) < NEW.NOTE.LIST.SIZE THEN DO;		/*	ADD TO LIST	*/

						NEW.NOTE.STAK(0) = NEW.NOTE.STAK(0)+1;
						NEW.NOTE.STAK(NEW.NOTE.STAK(0)) =1;	/*	CODE FOR NEW NOTE	*/

						IF INC.KBD.MAPS THEN DO;
							write("313")	= (K|J) + 9 + KBD_TRANSPOSE;							//	KEY #
							NEW.NOTE.KEY#(NEW.NOTE.STAK(0))	= read("313");
							LAST.NOTE.TYPE = 1;
							LAST.NOTE.KEY# = read("313");

							WRITE(DREG)="000"|K|J;	/*	REQUEST KEY VEL/TIME DATA	*/
							PULSE_EXWR;
							L=(READ(DREG)&"1777");	/*	READ VELOCITY DATA	*/

							LAST.NOTE.VEL = L;

							IF L>255 THEN L=255;		/*	LIMIT TO MAX TTIME OF 255	*/
						END;
						ELSE DO;							/*	ORIGINAL ALGORITHM	*/
							NEW.NOTE.KEY#(NEW.NOTE.STAK(0))	= (K|J) + 9 + KBD_TRANSPOSE;	//	KEY #
							WRITE(DREG)="000"|K|J;	/*	REQUEST KEY VEL/TIME DATA	*/
							PULSE_EXWR;
							L=(READ(DREG)&"1777");	/*	READ VELOCITY DATA	*/
							IF L>200 THEN L=200;		/*	LIMIT TO MAX TTIME OF 200	*/
						END;

						IF NEW.VEL.SENSITIVITY=0 THEN DO;
							IF V.S.MIN<>100 THEN DO;	/*	ONLY IF OTHER THAN FULL SENSITIVITY	*/
								L=L-TTIME.MIN;				/*	COMPUTE DISPLACEMENT FROM MIN	*/
								IF L<1 THEN L=1;			/*	LIMIT TO POSITIVE NON-ZERO TIMES	*/
								LOAD L; MUL V.S.MUL; L=URES+TTIME.MIN;
							END;
						END;

						WRITE(MAM)=TTMAP.PTR;			/*	LOOK UP VOLUME FROM TABLE	*/
						WRITE(MAL)=L;
						L=READ(MD);

						IF NEW.VEL.SENSITIVITY<>0 THEN DO;
							IF V.S.MIN<>100 THEN DO;
								LOAD RTE.MAX-L; MUL V.S.MUL;
								L=RTE.MAX-URES;
							END;
						END;

						NEW.NOTE.VEL(NEW.NOTE.STAK(0))=L;	/*	STORE VOLUME DATA	*/
						NEW.NOTE.TIME(NEW.NOTE.STAK(0))=KBD.MILLISECONDS+KBD.SYNC.DELAY;

						OLD.CLAVIER(I)=OLD.CLAVIER(I) XOR MASK2;

                  // Inform interpreter we have a new key to process
						if (newkey == 0) interp_newkey_pending(true);

						NEWKEY=1;
					END;
					ELSE OLDKCR=OLDKCR\MASK1;
					ENABLE;
				END;	/*	NEW KEY DOWN	*/
				MASK2=SHL(MASK2,1);
			END;	/*	LOOP FOR NEW KEYS	*/

			MASK2=1;	/*	INIT BIT MASK FOR KEYS	*/
			IF KEYS.REL<>0 THEN DO J=0 TO 15;	/*	LOOP OVER RELEASED KEYS	*/
				IF (MASK2&KEYS.REL)<>0 THEN DO;	/*	NEW KEY UP	*/
					DISABLE;								/*	BECAUSE EXT CLOCK SYNC CODE COULD INTERRUPT US FOR NOTE TRIGGER	*/
					IF NEW.NOTE.STAK(0)<NEW.NOTE.LIST.SIZE THEN DO;	/*	ADD TO LIST	*/
						NEW.NOTE.STAK(0)=NEW.NOTE.STAK(0)+1;
						NEW.NOTE.STAK(NEW.NOTE.STAK(0))	= 2;		/*	CODE FOR NOTE RELEASE	*/
						NEW.NOTE.KEY#(NEW.NOTE.STAK(0))	= (K|J) + 9 + KBD_TRANSPOSE;		//	KEY #
						NEW.NOTE.TIME(NEW.NOTE.STAK(0))  = 0;		// no time stamp for keyboard notes
						OLD.CLAVIER(I)=OLD.CLAVIER(I) XOR MASK2;	/*	CLEAR BIT IN OLD.CLAVIER WORD IF NOTE ACTUALLY STACKED	*/
					END;
					ELSE OLDKCR=OLDKCR\MASK1;
					ENABLE;
				END;		/*	NEW KEY UP	*/
				MASK2=SHL(MASK2,1);
			END;			/*	OF LOOP FOR RELEASED KEYS	*/
		END;				/*	OF CHANGE IN OCTAVE	*/
		MASK1=SHL(MASK1,1);
	END;					/*	OF LOOP OVER OCTAVES	*/
	WRITE(CREG)=1;		/*	REMOVE READ	*/
END SCAN.VKP.FOR.NOTES;

/*	$SUBTITLE  ROUTINE TO SCAN NEW BUTTON PRESSES	*/

/*	SEE SCAN.PRESSURE ROUTINE IN 370-REAL	*/
/*	PUT THERE TO AVOID PROC CALL				*/

DCL (OLD.SAR)	FIXED PUBLIC;

SERIOUSLY.SCAN.NEW.VKP.BUTTONS: PROC (INFO) SWAPABLE;	/*	PROCESS ACTUAL BUTTON PRESSES AND RELEASES FROM SWAP PROCEDURE	*/
	DCL INFO						FIXED;								/*	PASS BIT WORD	*/
	DCL (MASK1,MASK2)			FIXED;
	DCL (I,J,K,N)				FIXED;
	DCL PANSW(NUM.SW.PANS)	FIXED static;

	IF INC.CREG=0 THEN RETURN;

	MASK1=1;							/*	INIT BIT MASK	*/
	DO I=1 TO NUM.SW.PANS;		/*	LOOP OVER PANELS	*/
		IF (MASK1&INFO)<>0 THEN DO;	/*	SWITCH WAS HELD THIS TIME OR LAST TIME	*/

			DISABLE;					/*	AVOID KEYBOARD SCAN FOR A MOMENT	*/
			WRITE(CREG)=1;			/*	TURN OFF READ	*/
			WRITE(DREG)="600"\I;	/*	REQUEST DATA FOR BANK	*/
			PULSE_EXWR;
			J=READ(DREG);			/*	READ NEW DATA	*/
			WRITE(CREG)=1;			/*	REMOVE READ	*/
			ENABLE;					/*	THROUGH WITH READING	*/

			MASK2=1;					/*	INIT THE BIT MASK	*/
			IF J<>PANSW(I) THEN DO K=0 TO 15;                  /*	LOOP OVER BITS	*/
				IF ((J XOR PANSW(I))&MASK2)<>0 THEN DO;         /*	BIT HAS CHANGED	*/
					N=SHL(NUM.SW.PANS-I,4)+K;                    /*	COMPUTE BUTTON NUMBER - CONVERT FOR NEW MAPPING HERE	*/
					IF (J&MASK2)<>0 THEN N=N\BUTTON.LIST.HELD;   /*	MARK NEW OR REL	*/
					IF NEW.BUTTON.LIST(0)<2 THEN DO;             /*	CAN ADD ONTO LIST - LIMIT HERE TO AVOID POWER ON/OFF PROBLEMS	*/
						NEW.BUTTON.LIST(0)=NEW.BUTTON.LIST(0)+1;
						NEW.BUTTON.LIST(NEW.BUTTON.LIST(0))=N;
					   ANY.MISC.FUNCTIONS = TRUE;
						PANSW(I)=PANSW(I) XOR MASK2;              /*	TOGGLE BIT IN OLD REGISTER	*/
					END;
					ELSE OLD.SAR=OLD.SAR\MASK1;                  /*	CHECK NEXT TIME	*/
				END;
				MASK2=SHL(MASK2,1);	/*	MOVE TO NEXT BIT	*/
			END;	/*	OF LOOP OVER BITS	*/
		END;	/*	OF ACTIVITY OCCURRED	*/
		MASK1=SHL(MASK1,1);
	END;	/*	OF LOOP OVER PANELS	*/
END SERIOUSLY.SCAN.NEW.VKP.BUTTONS;

SCAN.NEW.VKP.BUTTONS: PROC PUBLIC;	/*	CREATE LIST OF BUTTONS CHANGING STATE	*/
	DCL (I,SAR)		FIXED;

	IF INC.CREG=0 THEN RETURN;

	DISABLE;					/*	AVOID KEYBOARD SCANS FOR A MINUTE	*/
	WRITE(CREG)=1;			/*	SET DREG ADDRESS TO INDICATE EXTENDED OPCODES	*/
	WRITE(DREG)="600";	/*	REQUEST SWITCH ACTIVITY REGISTER	*/
	PULSE_EXWR;
	SAR=READ(DREG);		/*	GET SWITCH ACTIVITY REGISTER - BITS FOR ANY SECTION WITH A HELD BUTTON	*/
	WRITE(CREG)=1;			/*	TURN OFF READ	*/
	ENABLE;					/*	ALLOW KEYBOARD SCANS NOW	*/

	I=SAR\OLD.SAR;			/*	OR IN OLD SAR - MEANS BUTTON WAS HELD THIS TIME OR LAST TIME	*/
	IF I=0 THEN DO;
		RETURN;				/*	NO BUTTONS PRESSED THIS TIME OR LAST TIME - NOTHING TO DO	*/
	END;

	OLD.SAR=SAR;			/*	STORE SAR	*/

	CALL SERIOUSLY.SCAN.NEW.VKP.BUTTONS(I);
END SCAN.NEW.VKP.BUTTONS;

/*	$SUBTITLE  ROUTINE TO SCAN ANALOG INPUTS	*/

SCAN.VKP.ANALOG.INPUTS: PROC PUBLIC;	/*	READ ANALOG INPUTS AND DIGITAL SWITCHES	*/
	DCL (I,MASK)	FIXED;
	DCL (PSW,NSW)	FIXED;

	IF INC.CREG=0 THEN RETURN;

	WRITE("313")=ADDR(ANALOG.IN(0));	/*	USE R13 FOR SPEED	*/
	DO I=88 TO 95;							/*	LOOP OVER ADDRESSES OF ANALOG CONTROLLERS	*/
		DISABLE;
		WRITE(CREG)=1;						/*	INDICATE INPUTS	*/
		WRITE(DREG)="200"\I;				/*	REQUEST VEL/TIME DATA	*/
		PULSE_EXWR;
		WRITE("373")=READ(DREG)&255;	/*	STORE DATA - IGNORE UPPER HALF THIS TIME - AVOID COMPUTER TIME NECESSARY TO MAKE CHECK	*/
		WRITE(CREG)=1;						/*	REMOVE READ	*/
		ENABLE;
	END;

	DISABLE;
	WRITE(CREG)=1;							/*	SELECT INPUTS	*/
	WRITE(DREG)="200"\89;				/*	GET SWITCH BITS	*/
	PULSE_EXWR;								/*	READ	*/
	NSW=READ(DREG)&"177400";			/*	GET NEW SWITCHES	*/
	WRITE(CREG)=1;							/*	REMOVE READ	*/
	ENABLE;									/*	ALLOW KEYBOARD SCAN NOW	*/

	MASK="400";
	WRITE("313")=ADDR(SWITCHDATA(0));	/*	USE R13 AGAIN	*/
	IF NSW<>PSW THEN DO;					/*	CHECK FOR DIFFERENT TO AVOID LOOP TIMES	*/
		SW1.CHANGES=1; SW2.CHANGES=1;	/*	HAVE SOME DIFFERENCES FROM LAST CHECK	*/
		DO I=0 TO 7;	/*	LOOP OVER BITS	*/
			IF (NSW&MASK)<>0 THEN WRITE("373")=1;
			ELSE						 WRITE("373")=0;
			MASK=SHL(MASK,1);
		END;					/*	OF LOOP OVER ANALOG ADDRS	*/
		PSW=NSW;				/*	SAVE FOR NEXT COMPARISON	*/
	END;
END SCAN.VKP.ANALOG.INPUTS;

/*	$SUBTITLE  DISPLAY DRIVER ROUTINES	*/

/*	NOTE: ALSO SEE DRIVERS IN SILENCE.SYNTHS	*/

CLEAR.VKP.LIGHT: PROC(LIGHT.NUM);
	DCL LIGHT.NUM	FIXED;

	IF (INC.CREG == 0) THEN RETURN;

	LIGHT.NUM=(LIGHT.NUM&15)+(144-(LIGHT.NUM&"177760"));
	DISABLE;
	WRITE(CREG)=3;	/*	SET UP DREG TO INDICATE LIGHTS	*/
	WRITE(DREG)=SHL(LIGHT.NUM,8)\0;
	WRITE(CREG)=3\"40"; WRITE(CREG)=3;	/*	PULSE EXW	*/
	ENABLE;
END CLEAR.VKP.LIGHT;

SET.VKP.LIGHT: PROC(LIGHT.NUM);
	DCL LIGHT.NUM	FIXED;

	IF (INC.CREG == 0) THEN RETURN;

	LIGHT.NUM=(LIGHT.NUM&15)+(144-(LIGHT.NUM&"177760"));
	DISABLE;
	WRITE(CREG)=3;	/*	SET UP DREG TO INDICATE LIGHTS	*/
	WRITE(DREG)=SHL(LIGHT.NUM,8)\1;
	WRITE(CREG)=3\"40"; WRITE(CREG)=3;	/*	PULSE EXW	*/
	ENABLE;
END SET.VKP.LIGHT;

BLINK.VKP.LIGHT: PROC(LIGHT.NUM);
	DCL LIGHT.NUM	FIXED;

	IF (INC.CREG == 0) THEN RETURN;

	LIGHT.NUM=(LIGHT.NUM&15)+(144-(LIGHT.NUM&"177760"));
	DISABLE;
	WRITE(CREG)=3;	/*	SET UP DREG TO INDICATE LIGHTS	*/
	WRITE(DREG)=SHL(LIGHT.NUM,8)\2;
	WRITE(CREG)=3\"40"; WRITE(CREG)=3;	/*	PULSE EXW	*/
	ENABLE;
END BLINK.VKP.LIGHT;

KBD.INIT:PROC PUBLIC SWAPABLE;	/*	TURN OFF ALL BUTTON PANEL LIGHTS	*/
	DCL I	FIXED;

	IF (INC.CREG == 0) OR (NEW.ORK == 1) THEN RETURN;

   DO I=0 TO 159;
		CALL CLEAR.VKP.LIGHT(I);
	END;

END KBD.INIT;

SET.WIMAGE: PROC (POS,CH);	/*	SET WINDOW IMAGE ARRAY AND UPDATE BITS	*/
	DCL (POS,CH)	FIXED;

	IF CH<>WIMAGE(POS)		/*	CHANGING VALUE - SET BIT FOR UPDATE	*/
	THEN NEW.CLAVIER.INFO = NEW.CLAVIER.INFO | BITS(10+SHR(POS,3));

	WIMAGE(POS)=CH;			/*	SET TO NEW VALUE	*/

END SET.WIMAGE;

SET.DECIMAL.POINT: PROC(POS) PUBLIC SWAPABLE;	/*	UPDATED FOR NEW DISPLAY BOARD - DO NOT SWAP SO TRACK BUTTONS ARE FAST	*/
	DCL (POS,I,J)	FIXED;

	I=(POS&3);	/*	WORD NUMBER	*/
	IF POS<16 THEN	J=	 SHL(SHR(POS,	 2),1);			/*	BIT NUMBER	*/
	ELSE				J=1+SHL(SHR(POS-16,2),1);
	DP.DATAS(I)=DP.DATAS(I)\BITS(J);						/*	OR IN BIT	*/
	IF INC.CREG AND (NEW.ORK == 0) THEN DO;
		DISABLE;
		WRITE(CREG)=2;	/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
		WRITE(DREG)=SHL(DP.TABLE(I),8)\DP.DATAS(I);	/*	EMIT WORD	*/
		WRITE(CREG)=2\"40"; WRITE(CREG)=2;				/*	PULSE EXW	*/
		ENABLE;
	END;

	CALL SET.WIMAGE(POS,WIMAGE(POS)|"100000");		/*	SET DP BIT	*/

END SET.DECIMAL.POINT;

CLEAR.DECIMAL.POINT: PROC(POS) PUBLIC;	/*	DO NOT SWAP - CALLED OFTEN FROM EMIT.NUMBER	*/
	DCL (POS,I,J)	FIXED;

	I=(POS&3);													/*	WORD NUMBER	*/
	IF POS<16 THEN	J=  SHL(SHR(POS,	 2),1);			/*	BIT NUMBER	*/
	ELSE				J=1+SHL(SHR(POS-16,2),1);
	DP.DATAS(I)=DP.DATAS(I)&(NOT BITS(J));				/*	MASK OUT BIT	*/
	IF INC.CREG AND (NEW.ORK == 0) THEN DO;
		DISABLE;
		WRITE(CREG)=2;											/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
		WRITE(DREG)=SHL(DP.TABLE(I),8)\DP.DATAS(I);	/*	EMIT WORD	*/
		WRITE(CREG)=2\"40"; WRITE(CREG)=2;				/*	PULSE EXW	*/
		ENABLE;
	END;

	CALL SET.WIMAGE(POS,WIMAGE(POS)&"077777");		/*	CLEAR DP BIT	*/

END CLEAR.DECIMAL.POINT;

/*	$SUBTITLE  ROUTINE TO EMIT NUMBER TO DISPLAY WINDOW	*/

EMIT.NUMBER: PROC(POS,VALUE,DP,MODE) PUBLIC SWAPABLE;	/*	WRITE VALUE TO ALPHA, STARTING AT POS	*/
	DCL (POS,VALUE,DP)	FIXED;
	DCL (I,R,GO,MODE)		FIXED;	/*	MODE 0=LEFT JUST, 1=RIGHT JUST		*/
	DCL (NEG,CH)			FIXED;

	IF POS<16 THEN	NEW.UPPER=1;	/*	KEEP TRACK OF CHANGES FOR PRINTOUT	*/
	ELSE				NEW.LOWER=1;	/*	(DO NOT USE ACROSS BOUNDARIES)		*/

	NEG=0;
	IF VALUE<0 THEN DO; NEG=1; VALUE=-VALUE; END;	/*	SET SIGN FLAG	*/

	IF (MODE=RIGHT.JUST) AND (NOT NEG) THEN DO;		/*	PUT OUT EXTRA SPACE FOR RIGHT JUST POS NUMBERS	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;										/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(POS,8)\("40");				/*	WRITE OUT BLANK	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;			/*	PULSE EXW	*/
			ENABLE;
		END;
		CALL CLEAR.DECIMAL.POINT(POS);
		CALL SET.WIMAGE(POS,"40");							/*	SET ARRAY AND UPDATE BITS	*/
		POS=POS+1;
	END;

	GO=0;				/*	SUPPRESS LEADING ZEROS	*/
	DO I=0 TO 4;	/*	LOOP OVER CHARS OF NUMBER	*/
		R=0;			/*	ASSUME ZERO DIGIT	*/
		IF VALUE>=POWERS(I) THEN DO;	/*	NON-ZERO DIGIT	*/
			R=VALUE/POWERS(I);			/*	GET DIGIT	*/
			GO=1;
			VALUE=VALUE-R*POWERS(I);	/*	REDUCE VALUE	*/
		END;
		IF (MODE=RIGHT.JUST)&(I=4-DP) THEN GO=1;	/*	TURN ON LEADING ZEROES BEFORE DEC PT FOR RIGHT JUST	*/
		IF (MODE= LEFT.JUST)&((I=5-DP)\(I=4)) THEN GO=1;	/*	TURN ON ZEROES AFTER DP FOR LEFT JUST - BUT ALWAYS PUT OUT A SINGLE ZERO EVEN IF NO DECIMAL POINTS	*/
		IF (GO) AND (NEG) THEN DO;	/*	PUT OUT NEGATIVE SIGN	*/
			NEG=0;

         IF INC.CREG AND (NEW.ORK == 0) THEN DO;
				DISABLE;
				WRITE(CREG)=2;								/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
				WRITE(DREG)=SHL(POS,8)\("55");		/*	WRITE OUT SIGN	*/
				WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
				ENABLE;
			END;

			CALL CLEAR.DECIMAL.POINT(POS);
			CALL SET.WIMAGE(POS,"55");				/*	CHANGE WINDOW IMAGE ARRAY	*/
			POS=POS+1;
		END;

		IF GO												/*	DIGIT TO PRINT	*/
		THEN CH = "60"+R;
		ELSE CH = "40";								/*	JUST PRINT A SPACE	*/

      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;								/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(POS,8)\CH;				/*	WRITE OUT CHAR	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;

		CALL SET.WIMAGE(POS,CH);					/*	CHANGE WINDOW IMAGE ARRAY	*/

		IF I=(5-DP) THEN CALL SET.DECIMAL.POINT  (POS);
		ELSE				  CALL CLEAR.DECIMAL.POINT(POS);

		IF (MODE=RIGHT.JUST) OR (GO)	/*	IF PRINTING CHARS OR SPACES	*/
		THEN POS=POS+1;					/*	STEP _UTPUT POSITION	*/
	END;										/*	OF LOOP OVER CHARS	*/
END EMIT.NUMBER;

//	emit_int.fract() interprets the two fixed variables passed to it as an unsigned integer followed by and unsigned fraction.
//	For now it emits the result (000.000 to 999.999) in the upper part of the VK display starting at position 0.  This procedure
//	assumes that the caller has already normalized the variables passed to it (i.e., it doesn't carry fractional values exceeding
//	999 into the integer part.)  It will print *** in place of the integer or fractional part if the respective input variable
//	is out of range.
//	Also we assume CLEAR.UPPER was called before calling this procedure so there's no need to call clear.decimal.point(pos);
emit_int.fract: proc(int, fract) swapable;
	dcl (int, fract)	fixed;
	dcl i					fixed;	//	general purpose iterator
	dcl (pos,char)		fixed;	//	position and ascii character to emit
	dcl leading_space	boolean;

	new.upper		= true;		//	KEEP TRACK OF CHANGES FOR PRINTOUT
	pos				= 0;			//	for now always start at the first character
	leading_space	= true;		//	assume we will have leading spaces

	//	print integer part
	if (int igt 999)
	{	//	don't deceive the user.  print '***' if out of bounds
		do i = 2 to 4;
         if (NEW.ORK == 0) {
				disable;
				write(CREG) = 2;								//	SET UP DREG TO INDICATE ALPHA DISPLAY
				write(DREG) = shl(pos,8)|a.star;			//	WRITE OUT '*'
				write(CREG) = 2|"40"; write(CREG)=2;	//	PULSE EXW
				enable;
         }
			set.wimage(pos,a.star);							//	CHANGE WINDOW IMAGE ARRAY
			pos = pos+1;
		end;
		leading_space = false;
	}
	else
	{
		do i = 2 to 4;
			load int; div powers[i];
			if ((res != 0) || (i == 4)) leading_space = false;
			if (leading_space == true)	char = a.space;
			else {char = res + a.0; int = rem;}
			//	go for it
         if (NEW.ORK == 0) {
				disable;
				write(CREG) = 2;								//	SET UP DREG TO INDICATE ALPHA DISPLAY
				write(DREG) = shl(pos,8)|char;			//	WRITE OUT CHAR
				write(CREG) = 2|"40"; write(CREG)=2;	//	PULSE EXW
				enable;
         }
			set.wimage(pos,char);							//	CHANGE WINDOW IMAGE ARRAY
			pos = pos+1;
		end;
	}

	set.decimal.point(pos);	//	<<<<<<<<	this should be replaced when the termulator bug is fixed

	//	print fractional part
	if (fract igt 999)
	{	//	don't deceive the user.  print '***' if out of bounds
		do i = 2 to 4;
			if (NEW.ORK == 0) {
				disable;
				write(CREG)	= 2;								//	SET UP DREG TO INDICATE ALPHA DISPLAY
				write(DREG)	= shl(pos,8)|a.star;			//	WRITE OUT '*'
				write(CREG)	= 2|"40"; write(CREG)=2;	//	PULSE EXW
				enable;
         }
			set.wimage(pos, (wimage(pos)&"100000")|a.star);	//	CHANGE WINDOW IMAGE ARRAY retaining the previously set decimal
			pos	= pos+1;
		end;
	}
	else
	{
		do i = 2 to 4;
			load fract; div powers[i];
			char = res + a.0; fract = rem;
			//	go for it
			if (NEW.ORK == 0) {
				disable;
				write(CREG)	= 2;								//	SET UP DREG TO INDICATE ALPHA DISPLAY
				write(DREG)	= shl(pos,8)|char;			//	WRITE OUT CHAR
				write(CREG)	= 2|"40"; write(CREG)=2;	//	PULSE EXW
				enable;
         }
			set.wimage(pos, (wimage(pos)&"100000")|char);	//	CHANGE WINDOW IMAGE ARRAY retaining the previously set decimal
			pos	= pos+1;
		end;
	}
end emit_int.fract;

/*	$PAGE - EMIT.LARGE NUMBER	*/

/*	NOTE:	1.	EMIT.LARGE.NUMBER ONLY PRINTS POSITIVE NUMBERS	*/
/*			2.	RIGHT JUSTIFICATION IS PERFORMED						*/
/*			3.	CLEAR THE DISPLAY BEFORE CALLING AS NO				*/
/*				DECIMAL POINTS ARE SET OR CLEARED					*/

EMIT.LARGE.NUMBER:PROC (POS,MSB,LSB) PUBLIC SWAPABLE;	/*	EMIT NUMBER UP TO 9,999,999	*/
	DCL (POS,MSB,LSB)	FIXED;
	DCL (I,J,K)			FIXED;

	I=0;
	DO J=0 TO 6;						/*	PRINT DIGITS	*/
		K=0;
		DO WHILE	((MSB IGT POWERS.MSB(J)))
		OR			((MSB  =  POWERS.MSB(J))
		AND		 (LSB IGE POWERS.LSB(J)));
			IF LSB ILT POWERS.LSB(J) THEN MSB=MSB-1;
			LSB=LSB-POWERS.LSB(J);
			MSB=MSB-POWERS.MSB(J);
			K=K+1;
		END;
		IF K<>0 THEN I=1;				/*	SUPPRESS LEADING ZEROS	*/
		IF J=6  THEN I=1;				/*	ALWAYS DISPLAY 1 ZERO	*/
		IF I<>0 THEN DO;
         IF INC.CREG AND (NEW.ORK == 0) THEN DO;
				DISABLE;
				WRITE(CREG)=2;								/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
				WRITE(DREG)=SHL(POS,8)\("60"+K);		/*	WRITE OUT DIGIT	*/
				CALL SET.WIMAGE(POS,"60"+K);			/*	CHANGE WINDOW IMAGE ARRAY	*/
				WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
				ENABLE;
			END;
			ELSE CALL SET.WIMAGE(POS,"60"+K);		/*	CHANGE WINDOW IMAGE ARRAY	*/
			IF (J=0)\(J=3) THEN DO;						/*	USE COMMAS	*/
            IF INC.CREG AND (NEW.ORK == 0) THEN DO;
					DISABLE;
					WRITE(CREG)=2;							/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
					WRITE(DREG)=SHL(POS+1,8)\"54";	/*	COMMA	*/
					CALL SET.WIMAGE(POS+1,"54");		/*	CHANGE WINDOW IMAGE ARRAY	*/
					WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
					ENABLE;
				END;
				ELSE CALL SET.WIMAGE(POS+1,"54");	/*	CHANGE WINDOW IMAGE ARRAY	*/
			END;
		END;
		IF (J=0)\(J=3) THEN POS=POS+2;
		ELSE					  POS=POS+1;
	END;

END EMIT.LARGE.NUMBER;

/*	$SUBTITLE  ROUTINE TO EMIT STRING TO WINDOW, CLEAR WINDOW	*/

EMIT.CHAR: PROC (POS,CH) PUBLIC;
	DCL (POS,CH)	FIXED;

	IF INC.CREG AND (NEW.ORK == 0) THEN DO;
		DISABLE;
		WRITE(CREG)=2;								/*	SET UP DREG TO INDICATE ALPHA DISPLAY	*/
		WRITE(DREG)=SHL(POS,8)\(CH);			/*	WRITE OUT CHAR	*/
		WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW		*/
		ENABLE;
	END;

	CALL SET.WIMAGE(POS,(WIMAGE(POS)&"100000")|CH);	/*	CHANGE WINDOW IMAGE ARRAY (BUT PRESERVE DECIMAL POINT)	*/

END EMIT.CHAR;

EMIT.STRING: PROC(POS,STR) PUBLIC	/*	NON-SWAP!!	*/ ;	/*	WRITE STRING TO ALPHA, STARTING AT POS - NOTE - DOES NOT CLEAR DECIMAL POINT	*/
	DCL (POS,I)	FIXED;	/*	NOTE: DO NOT SWAP SO STRING CONSTANTS WILL BE STORED IN EXT MEMORY	*/
	DCL CH		FIXED;
	DCL STR		ARRAY;
	DCL CHANGE	FIXED;

	IF (POS		  )<16 THEN NEW.UPPER=1;	/*	KEEP TRACK OF CHANGES FOR PRINTOUT	*/
	IF (POS+STR(0))>16 THEN NEW.LOWER=1;

	DO I=0 TO STR(0)-1;			/*	LOOP OVER CHARS	*/
		CH=STR(SHR(I,1)+1);		/*	GET CORRECT WORD	*/
		IF I THEN CH=SHR(CH,8);	/*	GET UPPER BYTE		*/
		ELSE		 CH=CH&"377";	/*	LOWER BYTE	*/

      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;			/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(POS+I,8)\CH;			/*	WRITE OUT DIGIT	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;

		CALL SET.WIMAGE(POS+I,CH);	/*	CHANGE WINDOW IMAGE ARRAY	*/

	END;
END EMIT.STRING;

DCL BOTH.DISPLAY	FIXED PUBLIC;	/*	TRUE IF BOTH UPPER & LOWER USED FOR SAME MESSAGE	*/

CLEAR.DISPLAY: PROC PUBLIC SWAPABLE;
	DCL (I,CHANGE)	FIXED;

   IF (INC.CREG AND (NEW.ORK == 1))
      CLEAR.ORK.DISPLAY();

   NEW.UPPER=0;
	NEW.LOWER=0;

	DO I=0 TO 31;				/*	CLEAR CHARS	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;		/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(I,8)\"40";				/*	WRITE OUT A SPACE	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;

		IF WIMAGE(I)<>"40"	/*	CHANGING DISPLAY VALUE	*/
		THEN CHANGE = 1;		/*	SET FLAG					*/

		WIMAGE(I)="40";		/*	CLEAR OUT DISPLAY	*/
	END;

	IF CHANGE<>0				/*	MADE SOME CHANGES - SET BITS FOR UDPATE	*/
	THEN NEW.CLAVIER.INFO = NEW.CLAVIER.INFO | "036000";

	DO I=0 TO 3;				/*	CLEAR DECIMAL POINTS	*/
		DP.DATAS(I)=0;			/*	MARK OFF	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;		/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(DP.TABLE(I),8)\"0";	/*	WRITE ZERO	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;
	END;
	BOTH.DISPLAY=0;			/*	CLEAR FLAG	*/
	UPPER.DISP	=0;			/*	NO PARAMETER BEING DISPLAYED	*/
	LOWER.DISP	=0;			/*	NO DISPLAY IN LOWER WINDOW EITHER	*/
END CLEAR.DISPLAY;

/*	$SUBTITLE  ROUTINES TO CLEAR WINDOW HALVES	*/

CLEAR.UPPER: PROC PUBLIC SWAPABLE;	/*	CLEAR THE UPPER LINE OF DISPLAY	*/
	DCL (I,CHANGE)	FIXED;

   IF BOTH.DISPLAY<>0 THEN DO;		/*	CURRENT DISPLAY USES BOTH LOWER & UPPER - CLEAR ALL	*/
		CALL CLEAR.DISPLAY;
		RETURN;
	END;

   IF (INC.CREG AND (NEW.ORK == 1))
      CLEAR.ORK.DISPLAY();

	NEW.UPPER=0;

	DO I=0 TO 15;							/*	CLEAR UPPER CHARS	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;					/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(I,8)\"40";	/*	WRITE OUT A SPACE	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;

		IF WIMAGE(I)<>"40"	/*	CHANGING DISPLAY VALUE	*/
		THEN CHANGE = 1;		/*	SET FLAG					*/

		WIMAGE(I)="40";		/*	CLEAR OUT DISPLAY	*/
	END;

	IF CHANGE<>0				/*	MADE SOME CHANGES - SET BITS FOR UDPATE	*/
	THEN NEW.CLAVIER.INFO = NEW.CLAVIER.INFO | "006000";

	DO I=0 TO 3;	/*	CLEAR DP'S	*/
		DP.DATAS(I)=DP.DATAS(I)&("177652");		/*	CLEAR BITS 0,2,4,6	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;								/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(DP.TABLE(I),8)\DP.DATAS(I);	/*	EMIT DP WORD	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;
	END;

	UPPER.DISP=0;							/*	NO PARAMETER BEING DISPLAYED	*/

END CLEAR.UPPER;

CLEAR.LOWER: PROC PUBLIC SWAPABLE;	/*	CLEAR THE LOWER LINE OF DISPLAY	*/
	DCL (I,CHANGE)	FIXED;

	IF BOTH.DISPLAY<>0 THEN DO;		/*	CURRENT DISPLAY USES BOTH LOWER & UPPER - CLEAR ALL	*/
		CALL CLEAR.DISPLAY;
		RETURN;
	END;

   IF (INC.CREG AND (NEW.ORK == 1))
      CLEAR.ORK.DISPLAY();

	NEW.LOWER=0;

	DO I=16 TO 31;					/*	CLEAR LOWER CHARS	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;			/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(I,8)\"40";				/*	WRITE OUT A SPACE	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;	/*	PULSE EXW	*/
			ENABLE;
		END;

		IF WIMAGE(I)<>"40"		/*	CHANGING DISPLAY VALUE	*/
		THEN CHANGE = 1;			/*	SET FLAG					*/

		WIMAGE(I)="40";			/*	CLEAR OUT DISPLAY	*/
	END;

	IF CHANGE<>0					/*	MADE SOME CHANGES - SET BITS FOR UDPATE	*/
	THEN NEW.CLAVIER.INFO = NEW.CLAVIER.INFO | "030000";

	DO I=0 TO 3;	/*	EMIT DP WORDS	*/
		DP.DATAS(I)=DP.DATAS(I)&"177525";	/*	CLEAR BITS 1,3,5,7	*/
      IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;
			WRITE(CREG)=2;			/*	INDICATE ALPHA DISPLAY	*/
			WRITE(DREG)=SHL(DP.TABLE(I),8)\DP.DATAS(I);	/*	EMIT DP WORD	*/
			WRITE(CREG)=2\"40"; WRITE(CREG)=2;				/*	PULSE EXW		*/
			ENABLE;
		END;
	END;

	LOWER.DISP=0;					/*	NO DISPLAY IN LOWER WINDOW EITHER	*/

END CLEAR.LOWER;

/*	$SUBTITLE  ROUTINE TO CHECK FOR STOP BUTTON HELD (POLY ABORT)	*/


