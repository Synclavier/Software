/* :SYNRSOU:05-BUTT:073-NEWW - NUMERIC WINDOW DISPLAY ROUTINE FOR NEW PANEL */

/*
Modified:
2000/10/07 - TY  - Added DISPLAY.MWHEEL_PROXY()
2000/04/17 - TY  - Removed obsolete variables
2000/04/15 - TY  - Modified strings in DISPLAY.UNITS to distinguish SMPTE frames per beat from Film frames per beat
1998/07/06 - TY  - Modified DISPLAY.BEAT.NUMBER to work when using a click track.
1998/05/22 - TY  - Fixed a bug in DISPLAY.TIME that prevented it from properly displaying
						 times when a click track was in use.  Also removed some old code that
						 converted sequence time to beats and stored the results in an array.
						 The array was then immediately overwritten by a call to
						 MAP.SEQUENCE.TIME.TO.BEATS.
1991/10/19 - PF  - Fixed total memory display to show correct "byte" count
1991/03/14 - CJ  - Removed uneeded public's to reduce symbol table size
1991/02/07 - MWH - Combine 3200, 6400 and 9600 RTP's
1991/01/09 - PF  - added dcl for BPM.CURSOR
1990/10/09 - PF  - Expanded TRACK.FORMAT to include both measures/beats
						 and beats format
1990/10/09 - PF  - Removed references to BPM=1 for beats display
1990/09/27 - cj  - added label for STARTUP
1990/09/06 - TSS - ENHANCED PRESSURE CALIBRATION FOR REV 2 TRIPP KBD
1990/07/20 - PF  - Modified DISPLAY.TIME and DISPLAY.MEASURE.NUMBER
						 to work with Meter Mapping
1990/07/10 - PF  - Modified DISPLAY.BEAT.NUMBER to handle Meter Map
1990/06/14 - LSS - changed pull-down display to NTSC 30
1990/05/02 - cj  - added "pull-down" smpte code
1989/10/11 - CJ  - fixed bug with Mark Start time display in meas:beats format
1989/10/04 - cj  - fixed some VK time displays for Tempo Map
1989/08/24 - PF  - Added "MIDInet Sync" in DISPLAY.EXT.SYNC.MODE
1989/06/14 - TSS - Added PRESSURE.CALIBRATION.DISPLAY routine
1989/05/02 - TSS - Fixed bugs in display of System RAM amount for >>32MB
1988/12/02 - CJ  - CHANGES TO IMPROVE VOICES USED DISPLAY
1988/10/17 - TSS - ADDED UNITS DISPLAY FOR VOICE DIAGNOSTICS CODE
1988/04/11 - PF  - CHANGED MESSAGE IN DISPLAY.TRACK.START IF TIMBRE BUT NO NOTES
1987/11/15 - cj  - linked all vk error displays to terminal
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/09/01 - eg  - added some more messages to display.err
1987/07/21 - MWH - DISPLAY.SIGNON CORRECTLY EVEN IF 1000'S OF MEG OF POLY
1987/07/18 - cj  - split up display.err to save swap size
1987/04/01 - TS  - ADDED 'CANNOT EDIT PAST INDEP LOOP END' MESSAGE
1986/12/01 -CJ,EG- DISK IS WRITE PROTECTED MESSAGE
1986/11/13 - TS  - ADDED UNITS DISPLAY FOR CHAIN REPETITIONS & AND ERROR MSG
1986/11/03 - TS  - IMPROVED ERROR 10 MESSAGE IN DISPLAY.ERR
1986/10/06 - KJO - Updated for -7 catalog structure
1986/09/23 - TS  - ADDED FORMAT ARGUMENT TO COMPUTE.SMPTE.DISPLAY CALL
1986/09/12 - TS  - ADDED BEATS PER MEASURE TO DISPLAY UNITS PROC & TO DISPLAY.BEAT.NUMBER
1986/08/25 - TS  - MADE CHANGE FOR THD.ACTIVE.MIDI.RTES
1986/08/14 - TS  - ADDED ERROR #51
1986/08/06 - MPB - Added error #50
1986/07/31 - EEG - Added errors #43 and #44,45
1986/06/17 - MPB - Added error #41
1986/05/15 - "official" creation of release-M modules
*/

/* THIS FILE CONTAINS SUBROUTINES THAT CREATE THE DIFFERENT DISPLAYS */
/* FOR THE 32 CHARACTER WINDOW DISPLAY ON THE VELOCITY/PRESSURE      */
/* KEYBOARD.                                                         */

DCL (DISPLAY.EBL)					FIXED PUBLIC; /* SET TO NONZERO AFTER SIGN ON TO ALLOW ALL DISPLAYS */
DCL (NEW.BEAT.NUMBER)			FIXED PUBLIC; /* SET TRUE WHEN CHANGED */
DCL (SUPRESS.BEAT.DISPLAY)		FIXED PUBLIC; /* SET TO TRUE IF SHOULD SUSPEND BEAT DISPLAY */
DCL (BEAT.DISPLAY.TIME)			FIXED PUBLIC; /* WILL RESUME 5 SEC FROM THIS TIME SNAPSHOT */

/* LITERALS FOR TRACK.STATE ENCODING */

DCL TRACK.STATE					FIXED PUBLIC;	/* INDICATES WHAT TO DO IF TRACK BUTTON PRESSED */

DCL TRACK.STATE.NORMAL						LIT '0';		/* STATE 0: NORMAL TOGGLE OF TRACK BUTTON					*/
DCL TRACK.STATE.TIMBRE.RECALL				LIT '1';		/* STATE 1: RECALL TIMBRE TO KEYBOARD OR OTHER TRACK	*/
DCL TRACK.STATE.SELECT.SMT.DEST			LIT '2';		/* STATE 2: SELECT DEST FOR SMT								*/
DCL TRACK.STATE.SELECT.BOUNCE.SOURCE	LIT '3';		/* STATE 3: SELECT SOURCE TRACK FOR BOUNCE				*/
DCL TRACK.STATE.BOUNCE.CHAIN				LIT '4';		/* STATE 4: PERFORM BOUNCE OR CHAIN							*/
DCL TRACK.STATE.SELECT.TPAN.ROW			LIT '5';		/* STATE 5: SELECT ROW FOR FOLLOWING TRACK PAN			*/
DCL TRACK.STATE.PERFORM.TPAN.ASSIGN		LIT '6';		/* STATE 6: ASSIGN BUTTONS TO TRACK PAN					*/
DCL TRACK.STATE.DEFINE.GROUP				LIT '7';		/* STATE 7: DEFINE CONTENTS OF MASTER TRACK				*/
DCL TRACK.STATE.RECALL.GROUP.TRACKS		LIT '8';		/* STATE 8: RECALL TRACK BUTTONS FOR GROUP				*/

DCL TPAN.ROW.SELECT				FIXED;			/* SPECIFIES ROW DESTINATION FOR TRACK PAN FUNCTION			*/
DCL TGRP.TRACK.SELECT			FIXED;			/* SPECIFIES GROUP BEING DEFINED...									*/
DCL TRACK.BUTTON.PRESS.TIME	FIXED;			/* TIME OF BUTTON PRESS...												*/
DCL ALLOW.TRACK.GROUP.DEFINE	FIXED;			/* ALLOWS TRACK GROUP TO OCCUR										*/

DISPLAY.SIGNON:PROC(NUMV) PUBLIC SWAPABLE; /* DISPLAY SIGN-ON MESSAGE */
	DCL (NUMV,I,J) FIXED;
	DCL (LW,TMP) (1) FIXED;
	
	insert ':-xpl:reldat';

	DISPLAY.EBL=1;         /* ALLOW DISPLAYS FROM NOW ON */
	CALL CLEAR.DISPLAY;    /* CLEAR WINDOW FIRST */
	CALL EMIT.STRING(1,'SYNCLAVIER' );
	CALL EMIT.STRING(12,rel.shortver);
	CALL EMIT.NUMBER(16,NUMV,0,LEFT.JUST);
	CALL EMIT.STRING(19,'VOICES');

   IF (NEW.ORK == 1)
      DISPLAY.ORK.SIGNON(NUMV);

	/* FIRST, TRY TO TOTAL UP MEMORY IN 'K' WORDS */

	CALL STR32(0,SHR(MEM.SIZ,9),LW);                        /* INTERNAL MEMORY    */
	CALL ADD16(SHR((CORE(LOC.EMSIZE)+256)&"177400",1),LW);  /* EXTERNAL MEMORY    */
	DO I=0 TO POLYNUMS-1;                                   /* POLY     MEMORY    */
		CALL SET.CUR.BIN(I);        /* POINT AT THIS BIN  */
		CALL STR32(POLYAMOUNT.MSB,POLYAMOUNT.LSB,TMP);       /* SECTORS IN THIS BIN */
		CALL SHR32(TMP,1);          /* CONVERT TO K "BYTES" (ROUND DOWN) */
		CALL ADD32(TMP,LW,LW);      /* ADD TO TOTAL       */
	END;

	IF COM16(1024,LW) = LW#IGT THEN DO;    /* POSITIVE 16-BIT NUMBER OF K? */
		I=LW(LW#LSB);                       /* GET 16 BITS WORTH   */
		CALL EMIT.NUMBER(26,I,0,LEFT.JUST); /* WRITE IT OUT        */
		J=31;
		IF I<10000 THEN J=30;               /* K IN CORRECT COLUMN */
		IF I< 1000 THEN J=29;
		IF I<  100 THEN J=28;
		CALL EMIT.STRING(J,'K');            /* WRITE 'K'           */
	END;
	ELSE DO;                               /* TOO BIG FOR 'K'     */
		CALL SHR32(LW,10);                  /* CONVERT TO MEGABYTES (ROUND DOWN) */
		I=LW(LW#LSB);                       /* NOW IN 16 BIT RANGE */
		CALL EMIT.NUMBER(26,I,0,LEFT.JUST);
		J=31;
		IF I<10000 THEN J=30;               /* M IN CORRECT COLUMN */
		IF I< 1000 THEN J=29;
		IF I<  100 THEN J=28;
		CALL EMIT.STRING(J,'M');            /* WRITE 'M'           */
	END;
	SUPRESS.BEAT.DISPLAY=1;                   /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS+5000; /* HOLD DISPLAY FOR 5 SECONDS */
END DISPLAY.SIGNON;

DCL LAST.ERR FIXED PUBLIC;

DISPLAY.ERR#1:PROC(NUM) SWAPABLE;
	DCL NUM FIXED;

	DO CASE(NUM);
		/* RULER FOR ERRORS:         1         2         3  */
		/*                  12345678901234567890123456789012*/
		CALL EMIT.STRING(0,'NOT ENOUGH ROOM FOR OPERATION');    /*  0: RECORDER OUT OF NOTES */
		CALL EMIT.STRING(0,'OUT OF WAVE     TABLES [1]');       /*  1: TOO MANY WAVEFORMS, CHANGING PARAMETER */
		CALL EMIT.STRING(0,'OUT OF WAVE     TABLES [2]');       /*  2: TOO MANY WAVEFORMS, RECALLING TIMBRE */
		CALL EMIT.STRING(0,'OUT OF WAVE     TABLES [3]');       /*  3: TOO MANY */
		CALL EMIT.STRING(0,'DATA/SOUND FILE IS MISSING');       /*  4: NON-EXISTENT FILE */
		CALL EMIT.STRING(0,'SEQUENCE IS TOO LONG FOR MEMORY');  /*  5: SEQUENCE TOO LONG FOR MEMORY */
		CALL EMIT.STRING(0,'SEQUENCE IS TOO LONG TO STORE');    /*  6: SEQUENCE TOO LONG FOR DISK */
		CALL EMIT.STRING(0,'TIMBRES MUST    MATCH FOR RECORD'); /*  7: NON-EMPTY TRACK */
		CALL EMIT.STRING(0,'NO FREE TRACKS  FOR RECORD');       /*  8: NO FREE TRACKS */
		CALL EMIT.STRING(0,'TIMBRES MUST    MATCH FOR BOUNCE'); /*  9: TIMBRES DO NOT MATCH */
		CALL EMIT.STRING(0,'NOT ENOUGH MEMORY TO OVRLAY');      /* 10: REVCOM,SFM,OR MP TOO BIG TO OVERLAY TO */
		CALL EMIT.STRING(0,'NOT ENOUGH ROOM FOR NEW TIMBRE');   /* 11: OUT OF MEMORY-11 */
		CALL EMIT.STRING(0,'NOT ENOUGH ROOM TO COPY BANK');     /* 12: OUT OF MEMORY-12 */
		CALL EMIT.STRING(0,'TIMBRE BANK DOESNOT EXIST');        /* 13: TIMBRE BANK DOES NOT EXIST */
		CALL EMIT.STRING(0,'NOT ENOUGH ROOM IN MEMORY');        /* 14: NOT ENOUGH MEMORY FOR TIMBRE WRITE */
		CALL EMIT.STRING(0,'BANK IS TOO     LONG TO STORE');    /* 15: TIMBRE BANK WON'T FIT IN .NEWDATA */
		CALL EMIT.STRING(0,'SOFTWARE FEATUREIS NOT AVAILABLE'); /* 16: SOFTWARE FEATURE NOT AVAILABLE */
		CALL EMIT.STRING(0,'NO MEMORY LEFT  TO RECORD');        /* 17: NO NOTES */
		CALL EMIT.STRING(0,'SEQUENCE FILE   IS EMPTY');         /* 18: UNINITIALZED SEQUENCE */
		CALL EMIT.STRING(0,'NOT AVAILABLE   WITH THIS TIMBRE'); /* 19: OPERATION NOT ALLOWED WITH 'PATCH' TIMBRE */
		CALL EMIT.STRING(0,'MOVING  SOUND   FILE "');           /* 20: SMARTS */
		CALL EMIT.STRING(0,'LOADING SOUND   FILE "');           /* 21: SMARTS */
		CALL EMIT.STRING(0,'MUST PRESS ENTRYBANK OR SEQUENCE'); /* 22: BUTTON ERROR */
		CALL EMIT.STRING(0,'PRESS ENTRY,    BANK OR SEQUENCE'); /* 23: WRITE BUTTON DISPLAY */
		CALL EMIT.STRING(0,'"1-8" WILL STORETIMBRE IN BANK'  ); /* 24 */
		/* RULER FOR ERRORS:         1         2         3  */
		/*                  12345678901234567890123456789012*/
	END;

END DISPLAY.ERR#1;

DISPLAY.ERR#2:PROC(NUM) SWAPABLE;
	DCL NUM FIXED;

	DO CASE(NUM);
		/* RULER FOR ERRORS:         1         2         3  */
		/*                  12345678901234567890123456789012*/
		CALL EMIT.STRING(0,'PRESS "1-8" TO  WRITE WHOLE BANK'); /* 25 */
		CALL EMIT.STRING(0,'PRESS "1-8" TO  STORE SEQUENCE'  ); /* 26 */
		CALL EMIT.STRING(0,'ERROR - NOTHING WRITTEN TO DISK' ); /* 27 */
		CALL EMIT.STRING(0,'CAN NOT PLAY    PAST END OF LOOP'); /* 28 */
		CALL EMIT.STRING(0,'SMPTE OPTION IS NOT IN SYSTEM'   ); /* 29 */
		CALL EMIT.STRING(0,'LOADING HALTED!'                 ); /* 30 */
		CALL EMIT.STRING(0,'MULTI CHANNEL   OPTION NOT AVAIL'); /* 31 */
		
		{
			if (interp_is_running == 0)
				CALL EMIT.STRING(0,'D16 TIMER IS NOTIN SYSTEM'       ); /* 32 */
			else
				CALL EMIT.STRING(0,'SMPTE GENERATOR IS NOT AVAILABLE'); /* 32 */
		}
		
		CALL EMIT.STRING(0,'D16 TIMER IS SETAT WRONG RATE'   ); /* 33 */
		CALL EMIT.STRING(0,'ERROR DETECTED  IN SMPTE SIGNAL' ); /* 34 */
		CALL EMIT.STRING(0,'SIGNAL DOES NOT MATCH SMPTE MODE'); /* 35 */
		CALL EMIT.STRING(0,'WAITING FOR     SMPTE SIGNAL'    ); /* 36 */
		CALL EMIT.STRING(0,'MUST HAVE MODEL C PROCESSOR'     ); /* 37 */
		CALL EMIT.STRING(0,'MUST SET LENGTHSBEFORE SEARCH'   ); /* 38 */
		CALL EMIT.STRING(0,'HELLO'                           ); /* 39 */
		CALL EMIT.STRING(0,'MIDI OPTION IS  NOT IN SYSTEM'   ); /* 40 */
		CALL EMIT.STRING(0,'MUST RECORD STM ON EMPTY TRACK'  ); /* 41 */
		CALL EMIT.STRING(0,'POLY MEMORY FULL'                ); /* 42 */
		CALL EMIT.STRING(0,'CAN NOT LOOP    LIVE TRACKS'     ); /* 43 */
		CALL EMIT.STRING(0,'USE TERMINAL TO ERASE LIVE TRACK'); /* 44 */
		CALL EMIT.STRING(0,'CAN NOT BOUNCE  LIVE TRACK'      ); /* 45 */
		CALL EMIT.STRING(0,'CAN NOT SLIDE   LIVE TRACK'      ); /* 46 */
		CALL EMIT.STRING(0,'ALL TRACKS SAFE:CAN NOT RECORD'  ); /* 47 */
		CALL EMIT.STRING(0,'CAN NOT SMT TO  LIVE TRACK'      ); /* 48 */
		CALL EMIT.STRING(0,'NOT AVAILABLE   FOR LIVE TRACK'  ); /* 49 */
		CALL EMIT.STRING(0,'LOOP END MUST BEAFTER LOOP START'); /* 50 */
		CALL EMIT.STRING(0,'CANNOT RECALL   TRK FROM OLD SEQ'); /* 51 */
		CALL EMIT.STRING(0,'CAN NOT CHAIN   LIVE TRACK'      ); /* 52 */
		CALL EMIT.STRING(0,'TIMBRES MUST    MATCH FOR CHAIN' ); /* 53 */
		CALL EMIT.STRING(0,'ERROR - DISK IS WRITE PROTECTED' ); /* 54 */
		CALL EMIT.STRING(0,'CANNOT EDIT PASTINDEP LOOP END'  ); /* 55 */
		CALL EMIT.STRING(0,'NO FLOPPY DISK  IN DRIVE'        ); /* 56 */
		CALL EMIT.STRING(0,'NOT ENOUGH      CONTIGUOUS SPACE'); /* 57 */
		CALL EMIT.STRING(0,'ERROR - SEQUENCEIS PROTECTED'    ); /* 58 */
		CALL EMIT.STRING(0,'CANNOT CHAIN    WITH LIVE CLICK' ); /* 59 */
		CALL EMIT.STRING(0,'CANNOT READ SND FILE FROM DISK'  ); /* 60 */
		CALL EMIT.STRING(0,'CANNOT READ SEQ FILE FROM DISK'  ); /* 61 */
		CALL EMIT.STRING(0,'MOUNT W1        BEFORE USE'      ); /* 62 */
		/* RULER FOR ERRORS:         1         2         3  */
		/*                  12345678901234567890123456789012*/
		/* NOTE: add suitable message to display.vk.error in errsou */
		/* as well                                                  */
	END;

END DISPLAY.ERR#2;

DISPLAY.ERR:PROC(NUM) PUBLIC SWAPABLE; /* DISPLAY ERR0 - ERR9, ER10 - ER19 */
	DCL NUM FIXED;

	LAST.ERR=NUM;

	IF DISPLAY.EBL=0 THEN RETURN; /* SUPPRESS PRINTOUT DURING INITIALIZATION */
	CALL CLEAR.DISPLAY;

   IF (NEW.ORK == 1)
      DISPLAY.ORK.ERR(NUM);

	IF NUM<25 THEN CALL DISPLAY.ERR#1(NUM);
	ELSE           CALL DISPLAY.ERR#2(NUM-25);

	SUPRESS.BEAT.DISPLAY=1;                   /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      /* HOLD DISPLAY FOR 5 SECONDS */
	BOTH.DISPLAY=1;
	UPPER.DISP=ERR.DISP;                      /* ERROR DISPLAY TYPE */

	IF  ((NUM<20) OR (NUM>27))                /* 'MOVING' AND 'LOADING' SOUND FILE DO NOT BELONG ON TERMINAL */
	THEN DO;
		IF  (ERTYP = 0      )                  /* IF NO ERROR PENDING */
		OR  (ERTYP = ERR.VKE)                  /* OR IF WAS VK ERROR  */
		THEN DO;
			ERTYP = ERR.VKE;                    /* SHO VK ERRORS ON    */
			VK.ERROR.CODE = NUM;                /* TERMINAL SOME TIME  */
		END;
	END;

END DISPLAY.ERR;

/* $PAGE - DISPLAY INFO PROMPT, FRANE NUMBER */

INFO.PROMPT:PROC PUBLIC SWAPABLE;   /* RE-DISPLAY INFO PROMPT */
	CALL CLEAR.DISPLAY;
	CALL EMIT.STRING(0,'PRESS ANOTHER   BUTTON FOR INFO');
	BOTH.DISPLAY=1;
END INFO.PROMPT;

DISPLAY.FRAME.NUMBER:PROC(NUM) PUBLIC SWAPABLE;        /* DISPLAY A FRAME NUMBER IN WINDOW */
	DCL NUM FIXED;

	CALL CLEAR.UPPER;                    /* CLEAR UPPER LINE, INCLUDING DP */

   IF (NEW.ORK == 1)
      DISPLAY.ORK.FRAME.NUMBER(NUM);

	CALL EMIT.STRING(0,'FRAME ');
	CALL EMIT.NUMBER(6,NUM,0,LEFT.JUST);
	UPPER.DISP=FRAME.DISP;               /* INDICATE FRAME # DISPLAYED (FOR REMOVAL) */
END DISPLAY.FRAME.NUMBER;

REMOVE.FRAME.NUMBER:PROC PUBLIC SWAPABLE; /* REMOVE FRAME NUMBER FROM DISPLAY (UPON PARTIAL BUTTON RELEASE) */
	IF (UPPER.DISP=FRAME.DISP)          /* IF FRAME # IS DISPLAYED */
	THEN CALL CLEAR.UPPER; 
END REMOVE.FRAME.NUMBER;

DISPLAY.OUR.DEV:  PROC PUBLIC SWAPABLE;     /* PUT NAME OF DEVICE TO ACCESS IN WINDOW */
	DCL I FIXED;
	CALL CLEAR.DISPLAY;
	CALL EMIT.STRING(0,'WILL READ/WRITE TO ');

	I=CORE(FIND_DEVICE(ACTIVE.LEVEL))&255; /* GET LOW BYTE OF CONFIG INFO */
	DO CASE I&"17";                   /* LOOK AT LOWER NIBBLE */
		CALL EMIT.STRING(19,'F');      /* DRIVE TYPE */
		CALL EMIT.STRING(19,'W');
		CALL EMIT.STRING(19,'R');
	END;
	DO CASE SHR(I,4);                 /* LOOK AT UPPER NIBBLE */
		CALL EMIT.STRING(20,'0');      /* DRIVE NUMBER */
		CALL EMIT.STRING(20,'1');
	END;
	CALL EMIT.STRING(21,':');
	IF ACTIVE.LEVEL=1
	THEN CALL EMIT.STRING(22,LOCATION(LOC.CCNM)); /* CURRENT CAT NAME */

	UPPER.DISP=DSEL.DISP;    /* INDICATE DRIVE SELECT INFO DISPLAYED */
	LOWER.DISP=DSEL.DISP;
END DISPLAY.OUR.DEV;

REMOVE.OUR.DEV:  PROC PUBLIC SWAPABLE;
	IF  (UPPER.DISP=DSEL.DISP)
	AND (LOWER.DISP=DSEL.DISP)
	THEN CALL CLEAR.DISPLAY;
END REMOVE.OUR.DEV;

/* $SUBTITLE  - DISPLAY.MEASURE.NUMBER ROUTINE */

DCL #TIME LIT '0'; /* DISPLAY VALUE AS A TIME     */
DCL #DUR  LIT '1'; /* DISPLAY VALUE AS A DURATION */

DISPLAY.MEASURE.NUMBER:  PROC (POS,STARTTIME,DURATION,HI.RES,FORMAT) PUBLIC SWAPABLE;
	DCL POS       FIXED; /* POSITION TO BEGIN DISPLAY AT   */
	DCL STARTTIME ARRAY; /* TIME TO DISPLAY OR STARTTIME OF DURATION */
	DCL DURATION  ARRAY; /* DURATION TO BE DISPLAYED       */
	DCL HI.RES    FIXED; /* 1 TO PRINT FRACTIONS OF BEATS  */
	DCL FORMAT    FIXED; /* 0=TIME, 1=DURATION             */
	DCL INFO(2)   FIXED; /* HOLDS MEASURE/BEAT/FRACTION    */
	DCL BPM       FIXED; /* BEATS PER MEASURE AT STARTTIME */
	DCL (I,J,K,M) FIXED;

	IF POS<16 THEN NEW.UPPER=1;    /* KEEP TRACK OF CHANGES FOR PRINTOUT	*/
	ELSE           NEW.LOWER=1;    /* (DO NOT USE ACROSS BOUNDARIES)		*/

	CALL EMIT.CHAR(POS  ,"115");
	POS=POS+1;

	/* COMPUTE MEASURES,BEATS AND FRACTIONS */

	IF FORMAT=#TIME
	THEN CALL MAP.SEQUENCE.TIME.TO.MEASURES.BEATS(STARTTIME,INFO);
	ELSE CALL MAP.SEQUENCE.DURATION.TO.MEASURES.BEATS(STARTTIME,DURATION,INFO);

	BPM = LOOKUP.BEATS.PER.MEASURE(STARTTIME);    /* LOOKUP BEATS PER MEASURE AT STARTTIME */

	IF      BPM< 10 THEN K=0;
	ELSE IF BPM<100 THEN K=1;
	ELSE                 K=2;

	I=INFO(0);                     /* GET MEASURE NUMBER HANDY */
	J=0;                           /* INIT FLAG */
	DO K=K TO 4;
		LOAD I; DIV POWERS(K); M=RES; I=REM;
		IF (K=4) OR (M<>0) THEN J=1;
		IF J<>0
		THEN CALL EMIT.CHAR(POS,"60"+M);
		ELSE CALL EMIT.CHAR(POS,"40");
		POS=POS+1;
	END;

	CALL EMIT.CHAR(POS,"072");     /* DISPLAY ':'  */
	POS=POS+1;                     /* AND INCR POS */

	IF      BPM>99 THEN J=3;       /* WILL NEED 3 CHARS */
	ELSE IF BPM> 9 THEN J=2;       /* WILL NEED 2 CHARS */
	ELSE                J=1;       /* WILL NEED 1 CHAR  */
	
	I=INFO(1);                     /* GET BEAT NUMBER HANDY */
	DO K=0 TO J-1;
		LOAD I; DIV POWERS(5-J+K); I=REM;
		CALL EMIT.CHAR(POS,"60"+RES);
		POS=POS+1;
	END;

	IF HI.RES<>0 THEN DO;           /* DISPLAY FRACTIONS OF A BEAT */

		CALL SET.DECIMAL.POINT(POS); /* SET UP THE DECIMAL POINT */

		I=INFO(2);                   /* GET FRACTION HANDY */
		DO K=0 TO 2;
			LOAD I; DIV POWERS(2+K); I=REM;
			CALL EMIT.CHAR(POS,"60"+RES);
			POS=POS+1;
		END;
	END;

END DISPLAY.MEASURE.NUMBER;

/* $PAGE - DISPLAY BEAT NUMBER - SPECIAL FAST ROUTINE FOR NEW PANEL */

DCL HELD.RTE.BUTTONS   FIXED PUBLIC;
DCL HELD.MIDI.BUTTON   FIXED PUBLIC;
DCL MIDI.PARAM.ID		  FIXED PUBLIC;

DISPLAY.BEAT.NUMBER:PROC (SEQ.TIME) PUBLIC SWAPABLE; /* SPECIAL PROCEDURE FOR BEAT NUMBER */
	DCL SEQ.TIME          ARRAY;
	DCL BDIG(4)           FIXED STATIC; /* HOLDS IMAGE OF CURRENT BEAT DISPLAY FOR FASTER UPDATES */
	DCL MDIG(8)           FIXED STATIC; /* HOLDS IMAGE OF CURRENT MEAS DISPLAY FOR FASTER UPDATES */
	DCL MDISP.ACTIVE      FIXED STATIC;
	DCL (I,J,K,M,N)       FIXED STATIC;
	DCL POS               FIXED STATIC;
	DCL BPM               FIXED STATIC;
	DCL MEASURES.BEATS(2) FIXED STATIC;
	DCL DISPLAY.MTC       FIXED EXTERNAL;

	INIT.MEASURE.DISP: PROC(MDIG);
		DCL MDIG FIXED ARRAY;

		MDISP.ACTIVE=1;                          /* MEASURE DISPLAY IS ACTIVE */
		DO I=0 TO 8; MDIG(I)=(-1); END;          /* INDICATE NO DIGITS DISPLAYED YET */
	END INIT.MEASURE.DISP;

	MAYBE.EMIT.CHAR: PROC(POS,CH,ARR);
		DCL (POS,CH) FIXED;
		DCL ARR      ARRAY;

		IF ARR(POS)<>CH THEN DO;                 /* CHAR IS NOT IN DISPLAY */
			ARR(POS)=CH;
			CALL EMIT.CHAR(POS+16,CH);            /* WRITE CHAR TO DISPLAY */
		END;
	END MAYBE.EMIT.CHAR;

	BPM = LOOKUP.BEATS.PER.MEASURE(SEQ.TIME);

	DO WHILE 1;                                 /* RE-ENTER FROM BELOW TO REDRAW */
		IF (LOWER.DISP=BEATS.DISP)               /* SEE IF BEAT # ALREADY DISPLAYED */
		OR (LOWER.DISP=SMPTE.DISP)               /* ALSO WITH SMPTE DISPLAY          */
		THEN DO;                                 /* PERFORM QUICK UPDATE OF BEAT DISPLAY */

			IF  ((SMPTE.ONOFF == 0)               /* SMPTE IS NOT RUNNING */
			&&   (DISPLAY.MTC == 0))				  /* AND NOT SHOWING MTC  */
			THEN DO;                              /* COMPUTE MEASURE DISPLAY */

				IF MDISP.ACTIVE=0
				THEN CALL INIT.MEASURE.DISP(MDIG); /* GET DISPLAY RESTARTED */

				CALL MAYBE.EMIT.CHAR(0,"115",MDIG); /* PUT UP THE 'M' */
				POS=1;

				/* CALL ROUTINE TO GET MEASURE NUMBER */
				IF CLICK.TRACK.MODE igt 3
				then do;
					if BEAT.NUMBER = 0
				/*	********* B E G I N   D E L E T I O N *********	*\
					// This method shows beat 1 before the first click
					then load 0;
					else load BEAT.NUMBER-1;
					div SAMP.BPM;
					MEASURES.BEATS(0)=res; MEASURES.BEATS(1)=rem+1;
				\*	*********** E N D   D E L E T I O N ***********	*/
					// This method shows beat 0 before the first click
					then {MEASURES.BEATS(0)=0; MEASURES.BEATS(1)=0;}
					else do;
						load BEAT.NUMBER-1;
						div SAMP.BPM;
						MEASURES.BEATS(0)=res; MEASURES.BEATS(1)=rem+1;
					end;
				end;
				else CALL MAP.SEQUENCE.TIME.TO.MEASURES.BEATS(SEQ.TIME,MEASURES.BEATS);

				IF      BPM< 10 THEN K=0;
				ELSE IF BPM<100 THEN K=1;
				ELSE                 K=2;

				I=MEASURES.BEATS(0);           /* GET MEASURE NUMBER */
				J=0;                           /* INIT FLAG */
				DO K=K TO 4;
					LOAD I; DIV POWERS(K); M=RES; I=REM;
					IF (K=4) OR (M<>0) THEN J=1;
					IF J<>0
					THEN CALL MAYBE.EMIT.CHAR(POS,"60"+M,MDIG);
					ELSE CALL MAYBE.EMIT.CHAR(POS,"40",MDIG);
					POS=POS+1;
				END;

				CALL MAYBE.EMIT.CHAR(POS,"072",MDIG); /* DISPLAY ':'  */
				POS=POS+1;                     /* AND INCR POS */

				IF      BPM< 10 THEN J=1;      /* WILL NEED 1 CHAR  */
				ELSE IF BPM<100 THEN J=2;      /* WILL NEED 2 CHARS */
				ELSE                 J=3;      /* WILL NEED 3 CHARS */

				I=MEASURES.BEATS(1);           /* GET BEAT NUMBER */
				DO K=0 TO J-1;
					LOAD I; DIV POWERS(5-J+K); I=REM;
					CALL MAYBE.EMIT.CHAR(POS,"60"+RES,MDIG);
					POS=POS+1;
				END;

				DO I=POS TO 8;                    /* MAKE SURE REST IS BLANK */
					CALL MAYBE.EMIT.CHAR(I,"40",MDIG);
				END;

			END;
			
			/* IF SMPTE IS ACTIVE, OR IF SHOWING MIDI TIME CODE, REMOVE THE MEASURE DISPLAY */
			
			ELSE IF MDISP.ACTIVE<>0 THEN DO;      /* MEASURE DISPLAY IS HERE  */
				MDISP.ACTIVE=0;                    /* TURN DISPLAY OFF         */
				DO I=0 TO 8;                       /* LOOP OVER MEASURE DIGITS */
					IF MDIG(I)<>(-1) THEN DO;
						MDIG(I)=(-1);
						IF (LOWER.DISP == BEATS.DISP)
							CALL EMIT.CHAR(16+I,"40");
					END;
				END;
			END;

			/* CALL ROUTINE TO GET BEAT NUMBER */
			IF CLICK.TRACK.MODE igt 3
			then do;		/* CLICK TRACK */
				/*	********* B E G I N   D E L E T I O N *********	*\
				// This method shows beat 1 before the first click
				if BEAT.NUMBER = 0
				then N = 1;
				else N = BEAT.NUMBER;
				\*	*********** E N D   D E L E T I O N ***********	*/
				// This method shows beat 0 before the first click
				N = BEAT.NUMBER;
			end;
			else do;		/* INT OR EXT CLICK */
			  CALL MAP.SEQUENCE.TIME.TO.BEATS(SEQ.TIME,MEASURES.BEATS);
			  N = MEASURES.BEATS(0);
			end;

         IF (NEW.ORK == 1)
            DISPLAY.ORK.BEAT.NUMBER(N);

			I=0;
			DO WHILE (I<4)&(N ILT POWERS(I));     /* PERFORM RIGHT JUSTIFICATION HERE */
				IF BDIG(I)<>(-1) THEN DO;          /* REMOVE NON-SPACE CHARACTERS */
					BDIG(I)=(-1);                   /* INDICATE NOW CLEARED */
					CALL EMIT.CHAR(27+I,"40");      /* WRITE OUT A SPACE */
				END;
				I=I+1;
			END;
			DO WHILE I<5;                         /* AND COMPUTE EACH DIGIT (AT LEAST ONE) */
				LOAD N; DIV POWERS(I);             /* COMPUTE FIRST DIGIT AND REMAINDER */
				N=REM;                             /* GET REMAINDER */
				IF (RES<>BDIG(I)) THEN DO;         /* MUST WRITE NEW DIGIT TO POSITION I */
					BDIG(I)=RES;                    /* SAVE FOR NEXT TIME */
					CALL EMIT.CHAR(27+I,"60"+RES);  /* WRITE OUT DIGIT */
				END;
				I=I+1;                             /* INCREMENT DIGIT, SPACE COUNTER */
			END;
			NEW.LOWER=0;                          /* DO NOT ANOUNCE BEATS */
			RETURN;                               /* DONE WITH QUICK DISPLAY OF BEAT NUMBER */
		END;

		IF (SUPRESS.BEAT.DISPLAY<>0)             /* SEE IF BEAT DISPLAY SHOULD BE SUSPENDED */
		THEN DO;
			IF (REAL.MILLISECONDS-BEAT.DISPLAY.TIME) ILT 5000   /* END OF 5 SEC SUSPENSION OF BEAT DISPLAY */
			THEN RETURN;
			SUPRESS.BEAT.DISPLAY=0;               /* ALLOW DISPLAYS NOW */
		END;

		IF ((INFO.MODE\HELD.RTE.BUTTONS\HELD.MIDI.BUTTON)<>0)
		THEN RETURN;                             /* ALSO NOT DONE IF INFO MODE, RTE BUTTONS */

		IF LOWER.DISP=LINES.DISP THEN RETURN;    /* NO BEAT NUMBERS IF LINES DISPLAY */

		IF (LOWER.DISP = (USED.DISP   ))
		OR (UPPER.DISP = (POLY.L-PAR.L))    /* LEAVE POLYPHONY DISPLAY IN UPPER HALF SO THAT WE */
		THEN BOTH.DISPLAY = 0;              /* WILL DISPLAY VOICES USED IN REAL TIME            */

		CALL CLEAR.LOWER;                   /* CLEAR WHOLE ROW AND DECIMAL POINTS HERE */
		LOWER.DISP=BEATS.DISP;              /* INDICATE BEAT # DISPLAYED */
		DO I=0 TO 4; BDIG(I)=(-1); END;     /* INDICATE NO DIGITS DISPLAYED YET */

		IF  ((SMPTE.ONOFF == 0)             /* SMPTE IS NOT RUNNING	*/
		&&   (DISPLAY.MTC == 0))				/* AND NOT SHOWING MTC	*/
		THEN CALL INIT.MEASURE.DISP(MDIG);  /* GET DISPLAY GOING		*/

	END;                                   /* RE-ENTER ABOVE CODE TO DISPLAY NUMBER */
END DISPLAY.BEAT.NUMBER;

/* $PAGE - MORE WINDOW DISPLAY ROUTINES FOR NEW PANEL - TIMBRE NAME, RECALL INFO, NUMB.LEFT */

DCL TNAME.CURSOR FIXED;
DCL CURSOR.BLINK FIXED;
DCL BLINK.MS     FIXED;
DCL BPM.CURSOR   FIXED;


DISPLAY.TIMBRE.NAME:PROC(I,POS) PUBLIC SWAPABLE; /* PUT TIMBRE NAME ON UPPER OR LOWER DISPLAY - PASS TINFO POINTER, POSITION */
	DCL (I,POS) FIXED;
	DCL ARR(8) FIXED;

	IF I=0 THEN RETURN;                    /* NO NAME TO DISPLAY IF NO TINFO AREA */
	I=I+8;                                 /* GET POINTER TO NAME AREA AT TI.NAME */

	CALL P.LOOKUP(I);                      /* SET UP XMEM POINTERS     */
	DO I=0 TO 7; 
		ARR(I+1)=READ(MDI); 
	END;
	ARR(0)=16;

	IF (POS=0) THEN DO;              /* DISPLAYING IN UPPER WINDOW - MEANS PARAMETER DISPLAY (NAME CHANGE) - BLINK CURSOR */
		IF UPPER.DISP<>(TNAME.L-PAR.L) THEN DO;  /* INITIALZE FOR BLINKING OF CURSOR ON FIRST PRESS */
			BLINK.MS=REAL.MILLISECONDS-300;       /* INITIALIZE ON FIRST DISPLAY */
			CURSOR.BLINK=1;
		END;
		CALL CLEAR.UPPER;             /* DISPLAY OF NAME DURING PARAMETER CHANGE - CLEAR UPPER */
		UPPER.DISP=(TNAME.L-PAR.L);   /* INDICATE NAME DISPLAY IF IN UPPER HALF */
		ANY.MISC.FUNCTIONS = TRUE;
		IF CURSOR.BLINK<>0 THEN DO;   /* SUPPRESS CHARACTER DURING BLINK */
			I=ARR(SHR(TNAME.CURSOR,1)+1);
			IF TNAME.CURSOR THEN I=(I&"000377")\SHL(95,8); /* UPPER HALF */
			ELSE                 I=(I&"177400")\    95   ; /* LOWER HALF */
			ARR(SHR(TNAME.CURSOR,1)+1)=I;
		END;
	END;
	
	CALL EMIT.STRING(POS,ARR);        /* ASSUME DISPLAY HAS BEEN CLEARED!! */
END DISPLAY.TIMBRE.NAME;

DISPLAY.TIMBRE.RECALL.INFO:PROC(TINFP,NUM.PARS,NUM.FRAMES) PUBLIC SWAPABLE; /* PASS TINFO PTR, NUMBER OF PARTIALS, NUMBER OF FRAMES */
	DCL (I,TINFP,NUM.PARS,NUM.FRAMES) FIXED;
	DCL (NAMEARRAY)   (8)             FIXED;

	IF DISPLAY.EBL=0 THEN RETURN; /* SUPPRESS PRINTOUT DURING INITIALIZATION */
	CALL CLEAR.DISPLAY;

   IF (NEW.ORK == 1)
      DISPLAY.ORK.TIMBRE.RECALL.INFO(NUM.PARS, NUM.FRAMES);

	CALL EMIT.STRING(0,'1- -'); /* FAKE THE LIBRARY NUMBER */
	CALL EMIT.NUMBER(2,OUR.BANK  +1,0,LEFT.JUST); /* DISPLAY BANK  NUMBER FOR TIMBRE */
	CALL EMIT.NUMBER(4,OUR.TIMBRE+1,0,LEFT.JUST); /* DISPLAY ENTRY NUMBER FOR TIMBRE */
	
	CALL EMIT.STRING(15,'F'); /* PRINT NUMBER OF FRAMES IN TIMBRE */
	CALL EMIT.NUMBER(9,NUM.FRAMES,0,RIGHT.JUST);
	CALL EMIT.STRING(11,'V'); /* PRINT NUMBER OF VOICES FOR TIMBRE */
	CALL EMIT.NUMBER(5,NUM.PARS,0,RIGHT.JUST);
	
	CALL LOOKUP.TIMBRE.NAME(0,NAMEARRAY);     /* GET TIMBRE NAME, OR FILE NAME */
	CALL EMIT.STRING(16,NAMEARRAY);           /* ASSUME DISPLAY HAS BEEN CLEARED!! */
	SUPRESS.BEAT.DISPLAY=1;                   /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      /* HOLD DISPLAY FOR 5 SECONDS */
END DISPLAY.TIMBRE.RECALL.INFO;

DISPLAY.NUMB.LEFT:PROC PUBLIC SWAPABLE; /* DISPLAY # OF NOTES LEFT IN SEQUENCER */

	IF DISPLAY.EBL=0 THEN RETURN;        /* SUPPRESS PRINTOUT DURING INITIALIZATIN */

	IF UPPER.DISP=KBDTRACK.DISP THEN
	CALL CLEAR.UPPER;

	CALL CLEAR.LOWER;

   IF (NEW.ORK == 1)
      DISPLAY.ORK.NUMB.LEFT();

	CALL EMIT.LARGE.NUMBER(16,NOTES.LEFT.MSB,NOTES.LEFT.LSB);
	CALL EMIT.STRING(26,'LEFT');

END DISPLAY.NUMB.LEFT;
	
/* $SUBTITLE  ROUTINE TO DISPLAY TIME & DURATION VALUES IN SEVERAL FORMATS */

/* NOTE:  IF FORMAT = #TIME  (START TIME FORMAT) THEN THE MSB,LSB PASSED
			 ARE ABSOLUTE SYNCL TIMES.

			 IF FORMAT = #DUR AND BEATS ARE BEING DISPLAYED THEN THE MSB,LSB PASSED
			 ARE IN BEATS (I.E. RATE=1000) FOR LIVE CLICK TRACKS */

/* DISPLAY.TIME IS PASSED :                                   */
/*        A VK DISPLAY CHARACTER POSITION                     */
/*        A SEQUENCE START TIME                               */
/*        A SEQUENCE DURATION                                 */
/*        A TIME FORMAT WORD                                  */


DISPLAY.TIME:  PROC(POS,STARTTIME,DURATION,FORMAT) SWAPABLE;
	DCL POS         FIXED; /* WHERE TO PUT DISPLAY */
	DCL STARTTIME   ARRAY; /* SEQUENCE START TIME  */
	DCL DURATION    ARRAY; /* SEQUENCE DURATION    */
	DCL FORMAT      FIXED; /* EITHER #TIME OR #DUR */

	DCL INFO   (1)  FIXED;
	DCL ENDTIME(1)  FIXED;
	DCL I           FIXED;
	DCL XBUF(5)     FIXED;

	IF POS<16 THEN NEW.UPPER=1;    /* KEEP TRACK OF CHANGES FOR PRINTOUT	*/
	ELSE           NEW.LOWER=1;    /* (DO NOT USE ACROSS BOUNDARIES)		*/

	/* CREATE A SECONDS FORMAT DISPLAY:                                  */

	IF  ((TRACK.FORMAT=2))         /* EXPLICITLY IN SECONDS DISPLAY MODE */
	OR  ((TRACK.FORMAT<2)          /* OR BEATS (OR MEASURES/BEATS) MODE  */
	AND  (CLICK.TRACK.MODE=3))     /* BUT USING EXTERNAL CLICK TRACK     */
	THEN DO;                       /* SECONDS FORMAT                     */

		/* BEGIN BY MAPPING TO REAL TIMES:                                */
		
		call Map.Sequence.Time.To.Real.Time(STARTTIME, INFO);
		IF FORMAT=#TIME THEN DO;        /* SUBTRACT OFF ZERO.TIME ONLY FOR START TIMES */
			IF COM16(ZERO.TIME, INFO) = LW#IGT
			THEN CALL STR32(0, 0, INFO);
			ELSE CALL SUB16(ZERO.TIME, INFO);
		END;
		ELSE DO;                             /* GET CORRECT DURATION  */
			CALL ADD32(STARTTIME, DURATION, ENDTIME);
			call Map.Sequence.Time.To.Real.Time(ENDTIME, ENDTIME);
			CALL SUB32(ENDTIME, INFO, INFO);  /* GET REAL TIME DURATION */
		END;

		LOAD INFO(1); ULOAD INFO(0); DIV 1000;
		INFO(0) = RES; INFO(1) = REM;                      /* GET SECONDS & MILLISECONDS */

		CALL EMIT.NUMBER(POS   ,INFO(0),0,RIGHT.JUST); /* DISPLAY SECONDS  */
		CALL EMIT.NUMBER(POS+ 6,INFO(1),3,LEFT.JUST ); /* DISPLAY MILLISEC */
		CALL EMIT.STRING(POS+10,'SECND');

	END;

	ELSE IF (TRACK.FORMAT=0)    /* BEATS */
	OR      (TRACK.FORMAT=1)    /* MEASURES/BEATS */
	THEN DO;                    /* BEATS OR MEASURE FORMAT */

		IF FORMAT=#TIME THEN DO;
			IF (CLICK.TRACK.MODE igt 3)	/* IF USING TRACK FOR CLICK */
			THEN DO;
				CALL REMAP.WITH.LIVE.CLICK(STARTTIME(0),STARTTIME(1),0,0,1);
				call MSEC.TO.BEATS(loc(addr(REMAPPED.TIME.MSB)),format,1000,info);
			END;
			ELSE CALL MAP.SEQUENCE.TIME.TO.BEATS(STARTTIME,INFO);
		END;

		ELSE DO;									/* FORMAT=#DUR */
			IF (CLICK.TRACK.MODE igt 3)	/* IF USING TRACK FOR CLICK */
			THEN DO;
				CALL REMAP.WITH.LIVE.CLICK(STARTTIME(0),STARTTIME(1),DURATION(0),DURATION(1),1);
				call MSEC.TO.BEATS(loc(addr(REMAPPED.DUR.MSB)),format,1000,info);
			END;
			ELSE CALL MAP.SEQUENCE.DURATION.TO.BEATS(STARTTIME,DURATION,INFO);
		END;

		IF (TRACK.FORMAT=1)					/* MEASURES:BEATS FORMAT */
		THEN CALL DISPLAY.MEASURE.NUMBER(POS,STARTTIME,DURATION,1,FORMAT); /* DISPLAY MEASURE:BEATS.FRACTIONS */
		ELSE DO;									/* NORMAL BEATS DISPLAY */
			CALL EMIT.NUMBER(POS   ,INFO(0),0,RIGHT.JUST); /* DISPLAY BEATS     */
			CALL EMIT.NUMBER(POS+ 6,INFO(1),3,LEFT.JUST ); /* DISPLAY FRACTIONS */
			CALL EMIT.STRING(POS+10,'BEATS');
		END;
	END;

	ELSE DO; /* SMPTE TIME FORMAT */

		/* GET CORRESPONDING REAL TIME FOR START TIME OR DURATION: */

		call Map.Sequence.Time.To.Real.Time(STARTTIME, INFO);
		IF FORMAT=#DUR THEN DO;
			CALL ADD32(STARTTIME, DURATION, ENDTIME);
			call Map.Sequence.Time.To.Real.Time(ENDTIME, ENDTIME);
			CALL SUB32(ENDTIME, INFO, INFO);  /* GET REAL TIME DURATION */
		END;

		CALL MSEC.TO.SMPTE(INFO,FORMAT,SAMP.SPEED,SM.MODE,
								 LOC(ADDR(SM.HRS)),XBUF);

		CALL EMIT.STRING(POS   ,'  :  :  :');

		WRITE("313")=ADDR(XBUF(0)); 

		DO I=0 TO 9 BY 3;
			CALL EMIT.NUMBER        (POS+I,READ("373"),2,LEFT.JUST);
			CALL CLEAR.DECIMAL.POINT(POS+I);
		END;
		CALL EMIT.NUMBER(POS+11,READ("373"),2,LEFT.JUST);

	END;

END DISPLAY.TIME;

/* $SUBTITLE  A COUPLE OF ROUTINES WHICH MIGHT BE USEFUL FOR 32BIT TIME DISPLAYS */

SIGNIFY.TIME.PARAMETER:  PROC SWAPABLE;      /* SETS UP GLOBAL INFO TO DENOTE TIME PARAMETER IN WINDOW */

	BOTH.DISPLAY=1;
	UPPER.DISP=TIME.DISP;                     /* INDICATE TIME PARAMETER DISPLAY */
	SUPRESS.BEAT.DISPLAY=1;                   /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      /* HOLD DISPLAY FOR 5 SECONDS */

END SIGNIFY.TIME.PARAMETER;

REMOVE.TIME.PARAMETER:PROC SWAPABLE; /* CLEAR TIME PARAMETER DISPLAY */
	IF UPPER.DISP=TIME.DISP         /* IF TIME PARAMETER IS DISPLAYED */
	THEN DO;                        /* REMOVE TIME DISPLAY            */
		CALL CLEAR.DISPLAY;          /* ERASE TIME DISPLAY FROM WINDOW */
		IF PLAY<>0 THEN DO;          /* SEQUENCER IS RUNNING           */
		  SUPRESS.BEAT.DISPLAY=0;    /* FORCE BEAT DISPLAY BACK ON     */
		  NEW.BEAT.NUMBER=1;
		END;
	END;
END REMOVE.TIME.PARAMETER;

/* $PAGE - DISPLAY TRACK START TO 8 DIGIT ACCURACY (NEW PANEL ONLY) */

DISPLAY.TRACK.START:PROC(TRK,FORMAT,MSB,LSB) PUBLIC SWAPABLE; /* DISPLAY BEAT # OF FIRST NOTE ON TRACK - PASS FORMAT, PLAY TIME, PLAY TIME CARRIES, CLICK RATE */
	DCL (TRK,FORMAT,MSB,LSB) FIXED; /* FORMAT: 0 = EMPTY TRACK, 1 = TIME */
	DCL DURATION(1)          FIXED;

	/* FORMAT = 0 MEANS TRACK IS EMPTY     */
	/* FORMAT = 1 MEANS TRACK IS NOT EMPTY */

	IF (SMPTE.RATE=0)             /* SMPTE IS NOT COMING INTO MACHINE  */
	THEN DO;
		CALL CLEAR.DISPLAY;
		
		IF (TRK.HEAD.LOOKUP(TRK, THD.GROUPLIST) == 0)
		{
			CALL EMIT.STRING(0,'TRACK');
			CALL EMIT.NUMBER(6,TRK-1,0,LEFT.JUST);
		}
		ELSE
		{
			CALL EMIT.STRING(0,'TRACK GROUP');
			CALL EMIT.NUMBER(12,TRK-1,0,LEFT.JUST);
		}

		IF FORMAT=0 THEN DO;       	/* IF TRACK IS EMPTY - SAY SO        */
			
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=TRK;
			
			IF READ(MD)<>0 THEN DO;		/* TRACK HEAD EXISTS						*/
				IF (TRK.HEAD.LOOKUP(TRK, THD.GROUPLIST) == 0)
					CALL EMIT.STRING(16,'0 NOTES');
				ELSE
				{
					DCL GRP_LIST FIXED;
					DCL NUM_ENTS FIXED;
					
					GRP_LIST = NAH.PTR + TRK.HEAD.LOOKUP(TRK, THD.GROUPLIST);
					
					WRITE(MAM) = GRP_LIST;
					WRITE(MAL) = GRPAUX.NUM;
					NUM_ENTS   = READ(MD);
					
					IF (NUM_ENTS == 1)
						CALL EMIT.STRING(16,'1 TRACK IN GROUP');
						
					ELSE
					{
	  					CALL EMIT.NUMBER(16, NUM_ENTS, 0, LEFT.JUST);
						
						IF (NUM_ENTS < 10)
							CALL EMIT.STRING(18,'TRKS IN GROUP');
						ELSE IF (NUM_ENTS < 100)
							CALL EMIT.STRING(19,'TRKS IN GROUP');
						ELSE
							CALL EMIT.STRING(20,'TRKS IN GRP');
					}
				}
			END;
			ELSE CALL EMIT.STRING (16,'TRACK IS EMPTY');
		END;
		ELSE CALL DISPLAY.TIME(16,LOC(ADDR(MSB)),DURATION,#TIME); /* DISPLAY TIME IN DESIRED FORMAT */
	
		SUPRESS.BEAT.DISPLAY=1;                       /* STOP BEAT DISPLAYS MOMENTARILY */
		BEAT.DISPLAY.TIME=REAL.MILLISECONDS;          /* HOLD DISPLAY FOR 5 SECONDS */

		BOTH.DISPLAY=1;
	END;

	/* IF SMPTE IS COMING INTO THE MACHINE, USE UPPER DISPLAY FOR */
	/* TRACK START TIME                                           */

	ELSE DO;
		CALL CLEAR.UPPER;

		IF FORMAT=0
		THEN CALL EMIT.STRING (0,'TRACK IS EMPTY');
		ELSE CALL DISPLAY.TIME(0,LOC(ADDR(MSB)),DURATION,#TIME); /* DISPLAY TIME IN DESIRED FORMAT */
		BOTH.DISPLAY=0;
	END;

   IF (NEW.ORK == 1)
      DISPLAY.ORK.TRACK.START(TRK,FORMAT,MSB,LSB);

   UPPER.DISP=START.DISP;                        /* INDICATE TRACK START DISPLAYED IN UPPER HALF */
END DISPLAY.TRACK.START;

REMOVE.TRACK.START.DISPLAY:PROC PUBLIC SWAPABLE; /* CLEAR TRACK START DISPLAY */
	IF UPPER.DISP=START.DISP        /* IF START TIME IS DISPLAYED */
	THEN DO;                        /* REMOVE TRACK START, RESTORE BEAT COUNTER IF PLAYING */
		CALL CLEAR.DISPLAY;          /* FOR US */
		IF PLAY<>0 THEN DO;
		  SUPRESS.BEAT.DISPLAY=0;    /* FORCE BEAT DISPLAY BACK ON */
		  NEW.BEAT.NUMBER=1;
		END;
	END;
END REMOVE.TRACK.START.DISPLAY;

/* $PAGE - WINDOW DISPLAY ROUTINE TO DISPLAY TIMBRE PARAMETERS */

DISPLAY.UNITS:PROC(UN) PUBLIC SWAPABLE;         /* DISPLAY UNITS WORD */
	DCL (UN) FIXED;
	IF UN ILT 256 THEN DO CASE (UN);             /* DISPLAY SIMPLE UNITS WORD */
		;
		CALL EMIT.STRING(7,'MILLISEC');
		CALL EMIT.STRING(7,'HERTZ'   );
		CALL EMIT.STRING(7,'MICROSEC');
		; /* SKIP 'ARBITRARY' DISPLAY FOR NOW */
		;;;
		CALL EMIT.STRING(7,'VOLUME');
	END;
	ELSE DO CASE (SHR(UN,8)-1);                  /* ELSE BRANCH FOR SPECIFIC UNIT */
		CALL EMIT.STRING(7,'FM PEAK');            /* 1                 */
		CALL EMIT.STRING(7,'FM SUSTN');           /* 2                 */
		CALL EMIT.STRING(7,'COEF');               /* 3                 */
		CALL EMIT.STRING(7,'SEMITONES');          /* 4                 */
		CALL EMIT.STRING(7,'GLIDE');              /* 5                 */
		CALL EMIT.STRING(7,'FM RATIO');           /* 6                 */
		CALL EMIT.STRING(7,'DECAY ADJ');          /* 7                 */
		CALL EMIT.STRING(7,'PAR CHOR');           /* 8                 */
		CALL EMIT.STRING(7,'HARM ADJ');           /* 9                 */
		CALL EMIT.STRING(7,'ST PAN');             /* 10                */
		CALL EMIT.STRING(7,'ST DEPTH');           /* 11                */
		CALL EMIT.STRING(7,'LEFT KEY');           /* 12                */
		CALL EMIT.STRING(7,'RIGHT KEY');          /* 13                */
		CALL EMIT.STRING(7,'LEFT FADE');          /* 14                */
		CALL EMIT.STRING(7,'RGHT FADE');          /* 15                */
		CALL EMIT.STRING(7,'POLYPHONY');          /* 16                */
		CALL EMIT.STRING(7,'CHORUS');             /* 17                */
		CALL EMIT.STRING(7,'SPEED');              /* 18                */
		CALL EMIT.STRING(7,'FILM FR/B');          /* 19 (see 40 below)	*/
		CALL EMIT.STRING(7,'CLICK MUL');          /* 20                */
		CALL EMIT.STRING(7,'OCT RATIO');          /* 21                */
		CALL EMIT.STRING(7,'VEL SENS');           /* 22                */
		CALL EMIT.STRING(7,'VEL RESP');           /* 23                */
		CALL EMIT.STRING(7,'BEATS/MIN');          /* 24                */
		CALL EMIT.STRING(7,'PHASE');              /* 25                */
		CALL EMIT.STRING(7,'PERCENT');            /* 26                */
		CALL EMIT.STRING(7,'SHAPE');              /* 27                */
		CALL EMIT.STRING(7,'PEAK VOL');           /* 28                */
		CALL EMIT.STRING(7,'SUSTN VOL');          /* 29                */
		CALL EMIT.STRING(7,'PARTIAL V');          /* 30                */
		CALL EMIT.STRING(7,'FRAME NUM');          /* 31                */
		CALL EMIT.STRING(7,'DYN LEVEL');          /* 32                */
		CALL EMIT.STRING(7,'RESPONSE');           /* 33                */
		CALL EMIT.STRING(7,'SAMPLES');            /* 34                */
		CALL EMIT.STRING(7,'STRT BT #');          /* 35                */
		CALL EMIT.STRING(7,'BTS/MEASR');          /* 36                */
		CALL EMIT.STRING(7,'REPT CNT');           /* 37                */
		CALL EMIT.STRING(7,'TEST CHAN');          /* 38                */
		CALL EMIT.STRING(7,'START UP');           /* 39                */
		CALL EMIT.STRING(7,'SMPTE F/B');          /* 40 (see 19 above)	*/
	END;
END DISPLAY.UNITS;

DISPLAY.PAR.NUM:PROC(VAL,DP,UN) PUBLIC SWAPABLE; /* DISPLAY PARAMETER NUMBER */
	DCL (VAL,DP,UN) FIXED;

	CALL CLEAR.UPPER;                            /* REMOVE EARLIER DISPLAY */

   IF (NEW.ORK == 1)
      DISPLAY.ORK.PAR.NUM(VAL,DP,UN);

	CALL EMIT.NUMBER(0,VAL,DP,RIGHT.JUST);       /* NUMBER & DP */
	CALL DISPLAY.UNITS(UN);                      /* ADD UNIT CODE WORD */
END DISPLAY.PAR.NUM;

DISPLAY.LARGE.PAR.NUM:PROC(MSB,LSB,UN) PUBLIC SWAPABLE; /* DISPLAY (LARGE) PARAMETER NUMBER */
	DCL (MSB,LSB,UN) FIXED;

	CALL CLEAR.UPPER;                            /* REMOVE EARLIER DISPLAY */
	CALL EMIT.LARGE.NUMBER(0,MSB,LSB);           /* NUMBER */
	CALL DISPLAY.UNITS(UN);                      /* ADD UNIT CODE WORD */
END DISPLAY.LARGE.PAR.NUM;

DISPLAY.SIGNED.PAR.NUM:PROC(VAL,UN) PUBLIC SWAPABLE;    /* DISPLAY A SIGNED SHORT BYTE (STEREO CENTER, HARMONIC ADJUST, KBD TRANSPOSE) */
	DCL (VAL,UN)  FIXED;

	CALL CLEAR.UPPER; 

   IF (NEW.ORK == 1)
      DISPLAY.SIGNED.ORK.PAR.NUM(VAL,UN);

	CALL EMIT.NUMBER(0,VAL,0,RIGHT.JUST);
	CALL DISPLAY.UNITS(UN);                      /* ADD UNIT CODE WORD */
END DISPLAY.SIGNED.PAR.NUM;

/* $PAGE - DISPLAY VIBRATO, STEREO CODES */

DISPLAY.VIBRATO:PROC(CODE) PUBLIC SWAPABLE; /* DISPLAY A VIBRATO WAVE TYPE */
	DCL (CODE,I) FIXED;                      

	CALL CLEAR.UPPER;

   IF (NEW.ORK == 1)
      DISPLAY.ORK.VIBRATO(CODE);

	CALL EMIT.NUMBER(0,(CODE&"17")+1,0,LEFT.JUST); /* DISPLAY WAVE # FOR CLARITY */
	I=1; IF ((CODE&"17")+1)>9 THEN I=2;
	CALL EMIT.STRING(I,'-'); 
	I=I+1;
	DO CASE (CODE&"17")+1; /* BRANCH ON VIBRATO WAVE TYPE */
		;                                     /*  0: NULL */
		CALL EMIT.STRING(I,'SINE');           /*  1: SINE WAVE */
		CALL EMIT.STRING(I,'TRIANGLE');       /*  2: TRIANGLE WAVE */
		CALL EMIT.STRING(I,'RAMP');           /*  3: RAMP WAVE */
		CALL EMIT.STRING(I,'INV RAMP');       /*  4: INVERTED RAMP WAVE */
		CALL EMIT.STRING(I,'SQUARE');         /*  5: SQUARE WAVE */
		CALL EMIT.STRING(I,'SINE2');          /*  6: SINE WAVE */
		CALL EMIT.STRING(I,'TRIANGLE2');      /*  7: TRIANGLE WAVE */
		CALL EMIT.STRING(I,'RAMP2');          /*  8: RAMP WAVE */
		CALL EMIT.STRING(I,'INV RAMP2');      /*  9: INVERTED RAMP WAVE */
		CALL EMIT.STRING(I,'SQUARE2');        /* 10: SQUARE WAVE */
		CALL EMIT.STRING(I,'RANDOM');         /* 11: RANDOM WAVE */
		CALL EMIT.STRING(I,'RANDOM2');        /* 12: RANDOM WAVE */
	END;
END DISPLAY.VIBRATO;

DISPLAY.STEREO:PROC(MODE) PUBLIC SWAPABLE; /* DISPLAY A STEREO MODE */
	DCL (MODE,I) FIXED;

	CALL CLEAR.UPPER;
	CALL EMIT.NUMBER(0,MODE,0,LEFT.JUST); /* DISPLAY MODE # FOR CLARITY */
	I=1; IF MODE>9 THEN I=2;
	CALL EMIT.STRING(I,'-'); 
	I=I+1;
	IF MONO_VOICES_PRESENT THEN DO;    /* MONO VOICE CARDS - NO STEREO PANNING AVAIL */
		CALL EMIT.STRING(I,'NOT AVAIL');
	END;
	ELSE IF MODE=0 THEN CALL EMIT.STRING(I,'STATIONARY'); /*  0: STATIC (SPECIAL CASE) */
	ELSE IF MODE>20 THEN DO;                         /* A.M. MODES */
		DO CASE(MODE-21);
			CALL EMIT.STRING(I,'SYNC AM ATTAK');
			CALL EMIT.STRING(I,'IND AM ATTACK');
			CALL EMIT.STRING(I,'SYNC AM DECAY');
			CALL EMIT.STRING(I,'IND AM DECAY');
		END;
	END;
	ELSE DO; /* ALL OTHER STEREO MODES */
		DO CASE (SHR(MODE-1,1)); /* BRANCH ON STEREO MODE */
			CALL EMIT.STRING(I,'UNUSED');        /*  1 &  2:           */
			CALL EMIT.STRING(I,'KEYBOARD');      /*  3 &  4: KEY # POS */
			CALL EMIT.STRING(I,'ALTERNATE');     /*  5 &  6: PING PONG */
			CALL EMIT.STRING(I,'UNUSED');        /*  7 &  8:           */
			CALL EMIT.STRING(I,'SYNC SINE');     /*  9 & 10: SYNCHRONOUS SINE WAVE PAN */
			CALL EMIT.STRING(I,'SYNC SQR');      /* 11 & 12: SYNCHRONOUS SQUARE WAVE PAN */
			CALL EMIT.STRING(I,'UNUSED');        /* 13 & 14:           */
			CALL EMIT.STRING(I,'IND SINE');      /* 15 & 16: INDEPENDENT SINE WAVE PAN */
			CALL EMIT.STRING(I,'IND SQR');       /* 17 & 18: INDEPENDENT SQUARE WAVE PAN */
			CALL EMIT.STRING(I,'RANDOM');        /* 19 & 20: RANDOM PAN */
		END;
		IF NOT MODE THEN CALL EMIT.STRING(I+10,'INV'); /* DISPLAY INVERTED VALUE */
	END;
END DISPLAY.STEREO;

DISPLAY.MWHEEL_PROXY: proc (value) public swapable; /* display the mod wheel proxy */
dcl (value) fixed;                      
	clear.upper();
	emit.string(0,'ModWheel -> ');
	do case value;
		emit.string(12,'Ped1');
		emit.string(12,'Ped2');
		emit.string(12,'ModW');
		emit.string(12,'Brth');
	end;
end;

/* $PAGE - SPECIAL WINDOW ROUTINES FOR 'LINES' DISPLAY ("----"), DISK WRITE MESSAGE */

DCL REMOVE.KBD.ERROR FIXED PUBLIC;

KBD.ERROR:PROC(TYP) PUBLIC SWAPABLE;                  /* PRESENT ERROR ON KEYBOARD NOTE */
  DCL (TYP) FIXED;

  REMOVE.KBD.ERROR=0;                          /* DO NOT REMOVE IT THIS TIME */
  IF LOWER.DISP=LINES.DISP THEN RETURN;        /* ALREADY DISPLAYING LINES - JUST EXIT */
  IF TYP<>0 THEN CALL DISPLAY.ERR(TYP);        /* GENERAL MSG */
  ELSE DO;
	  CALL CLEAR.LOWER;
     IF (NEW.ORK == 1)
         ORK.KBD.ERROR();
	  CALL EMIT.STRING(16,'----------------');
  END;
  LOWER.DISP         = LINES.DISP;             /* INDICATE LINES DISPLAYED */
  ANY.MISC.FUNCTIONS = TRUE;
END KBD.ERROR;

DISPLAY.MORE.NOTES:PROC(M) PUBLIC SWAPABLE;
	DCL M FIXED;
	CALL CLEAR.UPPER;
   IF (NEW.ORK == 1)
      DISPLAY.ORK.MORE.NOTES(M);
	CALL EMIT.NUMBER(0,M,0,LEFT.JUST);
	CALL EMIT.STRING(6,'MORE NOTES');
END DISPLAY.MORE.NOTES;

DISK.MESSAGE:PROC(NUMSEC) PUBLIC SWAPABLE; /* FOR NEW PANEL - DISPLAY # OF DISK SECTORS WRITTEN */
	DCL (NUMSEC,I) FIXED;

	CALL CLEAR.DISPLAY;

   IF (NEW.ORK == 1)
      ORK.DISK.MESSAGE();

   CALL EMIT.NUMBER(0,NUMSEC,0,LEFT.JUST);
	I=3;
	IF NUMSEC>=1000 THEN I=5;
	ELSE IF NUMSEC>=100  THEN I=4;
	CALL EMIT.STRING(I ,'SECTORS');
	CALL EMIT.STRING(16,'WRITTEN TO DISK');
	SUPRESS.BEAT.DISPLAY=1;                      /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;         /* HOLD DISPLAY FOR 5 SECONDS */
	BOTH.DISPLAY=1;
	LAST.ERR=0;
END DISK.MESSAGE;


DISPLAY.SMODE:PROC(MODE) PUBLIC SWAPABLE;           /* DISPLAY SMPTE MODE IN LOWER */
	DCL (MODE) FIXED;
	
	CALL CLEAR.LOWER;  										 /* CLEAR LOWER DISPLAY */

   IF (NEW.ORK == 1)
      DISPLAY.ORK.SMODE(MODE);

   IF ((HELD.MIDI.BUTTON != 0)							 /* IF HOLDINNG MIDI */
	||  ((UPPER.DISP == (MIDI.L - PAR.L))				 /* OR STILL SHOWING MIDI CLOCK STYLE IN UPPER */
	&&   (MIDI.PARAM.ID == 1)))
	{
		DO CASE (MODE);                      			/* PRESENT MTC MODE */
			CALL EMIT.STRING(16,'Drop Frame MTC');
			CALL EMIT.STRING(16,'Non Drop   MTC');
			CALL EMIT.STRING(16,'25 Frame   MTC');
			CALL EMIT.STRING(16,'24 Frame   MTC');
			CALL EMIT.STRING(16,'NTSC 30 Fr MTC');
		END;
	}
	
	ELSE IF (SMPTE.ONOFF == 0)
		CALL EMIT.STRING(16,'SMPTE is OFF');
		
	ELSE DO CASE (MODE);                      		/* PRESENT SMPTE MODE */
		CALL EMIT.STRING(16,'Drop Frame SMPTE');
		CALL EMIT.STRING(16,'Non Drop   SMPTE');
		CALL EMIT.STRING(16,'25 Frame   SMPTE');
		CALL EMIT.STRING(16,'24 Frame   SMPTE');
		CALL EMIT.STRING(16,'NTSC 30 Fr SMPTE');
	END;

	SUPRESS.BEAT.DISPLAY=1;                   /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      /* HOLD DISPLAY FOR 5 SECONDS */
	LOWER.DISP=SMODE.DISP;                    /* INDICATE SMODE DISPLAYED   */
END DISPLAY.SMODE;

DISPLAY.EXT.SYNC.MODE:  PROC (MODE) PUBLIC SWAPABLE; /* DISPLAYS EXT SYNC MODE */
	DCL MODE FIXED;
	CALL CLEAR.LOWER;
	DO CASE (MODE);     /* DISPLAY TYPE */
		CALL EMIT.STRING(16,'Internal Sync');
		CALL EMIT.STRING(16,'50 Hertz Sync');
		CALL EMIT.STRING(16,'Ext Beat Sync');
		CALL EMIT.STRING(16,'MIDI IN Sync ');
		CALL EMIT.STRING(16,'MIDI AUX Sync');
		CALL EMIT.STRING(16,'MIDInet Sync ');
		CALL EMIT.STRING(16,'OMS MIDI Sync');
	END;
	LOWER.DISP=EXT.DISP;                         /* IN CASE STOP BUTTON PRESSED */
	SUPRESS.BEAT.DISPLAY=1;                      /* STOP BEAT DISPLAYS MOMENTARILY */
	BEAT.DISPLAY.TIME=REAL.MILLISECONDS;         /* HOLD DISPLAY FOR 5 SECONDS */
END DISPLAY.EXT.SYNC.MODE;

DCL PRESSURE.CALIBRATION.MODE  FIXED PUBLIC;
DCL PRESSURE.CALIBRATION.KEY   FIXED PUBLIC;
DCL PRESSURE.CALIBRATION.VALUE FIXED PUBLIC;

PRESSURE.CALIBRATION.DISPLAY: PROC (KEY#,PRS) PUBLIC SWAPABLE;
	DCL KEY#  FIXED; /* THE KEY # TO DISPLAY            */
	DCL PRS   FIXED; /* AND ITS CURRENT PRESSURE        */
	DCL LEFT  FIXED; /* KEYS LEFT TO CALIBRATE          */
	DCL CAL   FIXED; /* CURRENT SAVED CALIBRATION VALUE */
	DCL (I,J) FIXED;
	DCL (PITCH.WINDOW)  DATA
       (ASC.C,ASC.C+SHL(asc.sharp,8),ASC.D,ASC.D+SHL(asc.sharp,8),ASC.E,
        ASC.F,ASC.F+SHL(asc.sharp,8),ASC.G,ASC.G+SHL(asc.sharp,8),
        ASC.A,ASC.A+SHL(asc.sharp,8),ASC.B);

	CALL CLEAR.DISPLAY;

	IF KEY#>0 THEN DO;             /* CREATE DISPLAY FOR KEY PRESSURES */
		WRITE(MAM)=PMAP.PTR;
		WRITE(MAL)=KEY#;
		CAL=READ(MD);                  /* LOOKUP CURRENT CALIBRATION VALUE FOR THIS KEY */

		/* SEE HOW MANY KEYS NEED TO BE CALIBRATED YET */
		WRITE(MAL)=(128+9);            /* START WITH FIRST 'REAL' KEY */
		LEFT=0;                      
		DO I = 1 TO (NUM.KEYS-9);      /* LOOP OVER KEYS AND COUNT KEYS LEFT TO CALIBRATE */
			IF READ(MDI)=0 THEN LEFT=LEFT+1;
		END;

		WRITE(MAL)=128+PRESSURE.CALIBRATION.KEY;
		/*                       01234567890123456789012345678901 */
		IF READ(MD)<>0                       /* KEY HAS ALREADY BEEN CALIBRATED */
		THEN CALL EMIT.STRING(0,'Key:    DONE:   More:    Cur:   ');
		ELSE CALL EMIT.STRING(0,'Key:     Cal:   More:    Cur:   ');

		LOAD KEY#; DIV 12;
		MISC.BUF(0)=1;
		MISC.BUF(1)=PITCH.WINDOW(REM);
		IF (MISC.BUF(1)&"177400")<>0 THEN MISC.BUF(0)=2;

		CALL PBYTE(MISC.BUF,MISC.BUF(0),RES+"60");
		MISC.BUF(0)=MISC.BUF(0)+1;

		CALL EMIT.STRING(4,MISC.BUF);   /* DISPLAY THE KEY NAME */
		CALL EMIT.NUMBER(13,CAL ,0,0);
		CALL EMIT.NUMBER(21,LEFT,0,0);
		CALL EMIT.NUMBER(29,PRS ,0,0);
	END;
	ELSE IF KEY# = (-1) THEN DO;        /* CREATE SATURATION VALUE DISPLAY */
	  WRITE(MAM)=PMAP.PTR;
	  WRITE(MAL)=LOC.PRESSURE.SATURATION;
	  I=READ(MD);                      /* LOOK UP CURRENT SATURATION VALUE */

		WRITE(MAL)=128+NUM.KEYS;        /* SEE IF SATURATION HAS BEEN RESET */
		/*                       01234567890123456789012345678901 */
		IF READ(MD)<>0                       /* SATURATION VALUE HAS BEEN CHANGED */
		THEN CALL EMIT.STRING(0,'Saturation: DONECur:     New:   ');
		ELSE CALL EMIT.STRING(0,'Saturation:     Cur:     New:   ');

		CALL EMIT.NUMBER(20,I  ,0,0);
		CALL EMIT.NUMBER(29,PRS,0,0);
	END;

END PRESSURE.CALIBRATION.DISPLAY;


/* PRESENT.TPAN.DISPLAY PRESENTS THE 4 TRACK NUMBERS IN THE VK WINDOW		*/
/* THAT CORRESPOND TO THE TRACK NUMBERS AT THE START OF EACH ROW OF			*/
/* TRACK BUTTONS																				*/

DCL COUNT.GROUPS.ON.PANEL PROC RECURSIVE;

PRESENT.TPAN.DISPLAY:PROC PUBLIC SWAPABLE; 
	DCL (NUMSEC,I) FIXED;
	DCL BUTTON.1   FIXED;
	DCL BUTTON.9   FIXED;
	DCL BUTTON.17  FIXED;
	DCL BUTTON.25  FIXED;
	
	EMIT.IT:PROC(WHICH, WHERE);
		DCL (WHICH, WHERE) FIXED;
		
		IF (WHICH < FIRST.LOD.TRACK)
			CALL EMIT.NUMBER(WHERE,  WHICH - 1,  0, LEFT.JUST);
			
		ELSE
		{
			CALL EMIT.STRING(WHERE, 'L');
			CALL EMIT.NUMBER(WHERE + 2,  WHICH - FIRST.LOD.TRACK + 1,  0, LEFT.JUST);
		}
		
	END EMIT.IT;

	CALL CLEAR.DISPLAY;
	
	IF ((TRACK.STATE == TRACK.STATE.RECALL.GROUP.TRACKS)		/* IF RECALL OF TRACK GROUPS WITH NO GROUPS	*/
	&&  (COUNT.GROUPS.ON.PANEL() == 0))								/* AVAILABLE, PRESENT MESSAGE						*/
		EMIT.STRING(0,'No Track Groups available...');
	
	/* LOOK UP CURRENT  BUTTON ASSIGNMENT. */
	
	ELSE
	{
		WRITE(MAM) = TBUT.PTR;
		WRITE(MAL) = 0;
		BUTTON.1   = (READ(MD) & 0xFF);
	
		WRITE(MAL) = 8;
		BUTTON.9   = (READ(MD) & 0xFF);
	
		WRITE(MAL) = 16;
		BUTTON.17  = (READ(MD) & 0xFF);
	
		WRITE(MAL) = 24;
		BUTTON.25  = (READ(MD) & 0xFF);
	
		EMIT.IT(BUTTON.1,   0);
		EMIT.IT(BUTTON.9,  16);
		EMIT.IT(BUTTON.17,  8);
		EMIT.IT(BUTTON.25, 24);
	}
	
	SUPRESS.BEAT.DISPLAY = 1;
	BEAT.DISPLAY.TIME    = REAL.MILLISECONDS;
	BOTH.DISPLAY         = 1;
	
	UPPER.DISP = TPAN.DISP;

END PRESENT.TPAN.DISPLAY;
