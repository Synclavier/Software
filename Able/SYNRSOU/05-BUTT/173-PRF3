/*	:SYNRSOU:05-BUTT:173-PRF3  $TITLE  ROUTINES TO PROCESS MOTION CONTROL AND SEQUENCER BUTTONS	*/

/*
Modified:
2000/06/15 - TY  - STOP button now stops any playing DtoD cues
2000/04/15 - TY  - Added additional click display mode to distinguish SMPTE frames per beat from Film frames per beat
1999/04/20 - TY  - Disabled displays associated with the ClickVal parameter and the Erase Tempo/Meter Map functions
						 when no maps are present.
1999/04/18 - TY  - Made it possible to switch from clickval or meter displays to click rate display without
						 having to release and re-press the click button (press continue as usual.)
1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE.
1999/04/11 - TY  - Added ERASE with HELD.CLIK.BUTTON to invoke "Convert.Mapped.To.Unmapped".
1999/04/04 - TY  - When first activating a tempo or meter map, don't also insert an event.
1999/03/22 - TY  - Mark is automatically set to ON when the user sets it's value by holding
						 mark while pressing the continue button.
1998/06/30 - TY  - Restructured COMPUTE.NEAREST.BEAT.TIME (nested in PROCESS.CONTINUE.BUTTON)
						 to avoid unnecessary computation if CLICK.TRACK.MODE ilt 3.
1998/06/26 - TY  - Added "IF NUM.HELD.BUTTONS igt 0 then RETURN" to PROCESS.RECORD.BUTTON and
						 PROCESS.PUNCH.BUTTON to help avoid accidental erasure.
1998/06/24 - TY  - Changed PROCESS.CONTINUE.BUTTON to separate CLICKON and CLICK.TRACK.MODE
						 into independent parameters.
					  - Set TOGGLE.CLICKON to false and CLICK.TRACK.FUNCTION to 0 if any of the
						 following buttons are pressed while the click button is held:
						 External Sync, Speed, Transpose, Fast Forward, Rewind, Start and Stop.
1998/06/22 - TY  - Modified the Transpose case of SEQUENCER.BUTTON to accommodate the new
						 Transpose Lock (blinking) feature.
1991/03/15 - cj  - Showed Click: ON and Click: OFF as needed
1991/03/14 - cj  - Inserted two tempo/meter events when first one
						 is created.  Changed messages suggested by Eric Richardson.
1991/02/14 - CJ  - Create default tempo and meter if needed.  Also
						 erase tempo meter by using erase
1991/01/09 - PF  - various bug fixes for sequencer and MIDInet
1990/10/16 - PF  - Add support for Tempo/Meter Map VK interface
1990/07/10 - PF  - Modified PROCESS.CONTINUE.BUTTON to work with Meter Map
1990/05/02 - cj  - added "pull-down" smpte code
1989/09/23 - CJ  - Mapped to sequence time when 'taking' mark start point
1989/03/30 - TSS - Fixed SMPTE infinite loop bug when PUNCHING IN during lockup
1989/03/14 - PF  - Added logic to support HELD.STOP.BUTTON
1989/01/11 - MWH - Add Auto Punch feature, move procs from 172-PRF2
1988/11/10 - PF  - bug fix for SPLIT function and STOP button
1988/04/12 - PF  - MODIFIED CODE TO ALLOW RECORD WHILE MIDI IS HELD(MULTI RECORD MODE)
1988/04/12 - PF  - MODIFIED CODE TO ALLOW START/STOP WHILE PRESSURE IS HELD(CONVERT CHANNEL TO POLY PRESSURE)
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/01/24 - CJ  - SPLIT UP THIS FILE
*/

DCL CREATE.DEFAULT.TEMPO.MAP		PROC EXTERNAL;
DCL CREATE.DEFAULT.METER.MAP		PROC EXTERNAL;
DCL ERASE.TEMPO.MAP.INFO			PROC EXTERNAL;
DCL ERASE.METER.MAP.INFO			PROC EXTERNAL;
DCL CONVERT.MAPPED.TO.UNMAPPED	PROC EXTERNAL;
DCL Stop.DTD.Playback				PROC EXTERNAL;

PROCESS.START.BUTTON:PROC SWAPABLE;

	/*	IF RS-232 PROTOCOL RUNNING, DON'T DO VOICE OUTPUT SINCE	*/
	/*	IT WILL JUST CONFUSE PEOPLE WHO ACCIDENTALLY TURN IT ON	*/

	#if (inc.voice.output)
		IF ((HELD.PTUN.BUTTON&HELD.PVOL.BUTTON)<>0)
		AND (USE.D50.PROTOCOL = 0)					/*	ONLY DO IT IF RS232 PROTOCOL NOT THERE	*/
		THEN DO;
			SPEAK.IT=1;									/*	TURN ON VOICE	*/
			ANY.MISC.FUNCTIONS	= TRUE;
			D42.OUTPUT.HAPPENING	=0;				/*	CLEAR BUSY FLAG	*/
			CALL DISPLAY.ERR(39);					/*	HELLO				*/
			RETURN;
		END;
	#endif

	IF  (INC.POLY<>0)									/*	POLY COMPILATION	*/
	AND ((HELD.SCALE.ADJUST.BUTTONS&7)<>0)		/*	COEF BUTTON HELD	*/
	THEN DO;
		CALL LOOP.SEARCH(0);							/*	LOOPING SEARCH	*/
	END;

	ELSE IF (HELD.SMPTE.BUTTON<>0)			/*	SMPTE GENERATOR			*/
	THEN CALL SMPTE.GENERATOR(0);

	ELSE IF (HELD.PSEL.BUTTONS<>0)			/*	PSEL - CREATE FRAME		*/
	THEN DO;
		CALL CREATE.TIMBRE.FRAME;
	END;

	ELSE IF (HELD.EXT.BUTTON<>0)				/*	EXT SYNC - ENABLE KEYBOARD TRIGGER	*/
	THEN DO;
		ENABLE.KEY.TRIG=1;
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'Ext Trigger: ON');
		END;
		IF EXT.CLOCK.MODE<3 THEN DO;
			IF EXT.CLOCK.MODE<>0
			THEN DO;
				CALL STOP.RECD.MOVE.PLAY;		/*	HAVE TO STOP MOVEMENT FIRST	*/
				EXT.CLOCK.MODE=0;
			END;
			CALL RESYNC.TIME.BASE;
			NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	HAVE A CHANGE IN SYNC STATE	*/
			NEW.SEQ.INFO=NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
			IF LOWER.DISP=EXT.DISP THEN CALL CLEAR.LOWER;
		END;
	END;

	/*	$PAGE - MARK + START BUTTONS PRESSED	*/

	/*	HANDLE HOLDING MARK BUTTON, PRESSING START:	*/
	/*		ENABLE MARK START									*/
	/*		SEND SONG POS POINTER OUT MIDI				*/

	ELSE IF (HELD.MARK.BUTTON<>0)				/*	MARK + START - ENABLE MARK POINT; ALSO SEND MIDI SONG PTR	*/
	THEN DO;
		CALL MARK.START.POINT.SUBROUTINE(1);
	END;

	ELSE IF (HELD.STARTLOOP.BUTTON<>0)		/*	START LOOP + START = ENABLE LOOPS (I.E. DISABLE IGNORE.LOOPS)	*/
	THEN DO;
		IGNORE.LOOPS = FALSE;
		IF NEW.PAN THEN DO;						/*	NEW PANEL	*/
			CALL CLEAR.LOWER;
			CALL EMIT.STRING(16,'LOOPS: ON');
		END;
	END;

	ELSE IF (HELD.MIDI.BUTTON<>0)				/*	MIDI BUTTON - ENABLE MIDI ECHO	*/
	THEN DO;
		MIDI.ECHO.DISABLED=0;
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'MIDI Echo: ON');
		END;
		NEW.PRM.INFO=NEW.PRM.INFO\16;			/*	HAVE A CHANGE IN MIDI ECHO MODE	*/
	END;

	ELSE IF (HELD.SCALE.ADJUST.BUTTON<>0)	/*	SCALE ADJUST & START - USE NEW FREQUENCY LOOKUP TABLE	*/
	THEN DO;
		CALL CLEAR.PARAMETERS;

		IF POLY.FRE.PTR<>FRE.PTR THEN DO;		/*	THE NEW POLY FREQ TABLE IS LOADED	*/
			WRITE(MAM)=BAS.PTR;
			WRITE(MAL)=SEQ.POLY.FREQ.TABLE;		/*	TELL SEQUENCE TO USE NEW TABLE	*/
			WRITE(MD )=1;
			POLY.FREQ.TABLE.PTR=POLY.FRE.PTR;	/*	AND SET PTR TO THE POLY LOOKUP TABLE	*/
			RESET.BITS=RESET.BITS\R.FREQS;		/*	UPDATE ACTIVE NOTES	*/
			NEW.KBD.PRE=1;								/*	AND RECOMPUTE KBD LOOKUP TABLES	*/

			IF NEW.PAN THEN DO;
				CALL CLEAR.UPPER;
				CALL EMIT.STRING(0,'New Freq Table');
			END;
		END;
		ELSE IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'Not Available');
		END;
	END;

	ELSE IF ((HELD.RTE.BUTTONS&2)<>0) THEN DO;	/*	PRESSURE BEING HELD	*/
		MONO.TO.POLY.PRESSURE=1;						/*	TURN ON PRESSURE CONVERSION ALGORITHM	*/
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'Convert Channel To Poly:  ON');
		END;
		BOTH.DISPLAY = 1;
		SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
		BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
	END;

	ELSE IF (HELD.INSERT.BUTTON\HELD.DELETE.BUTTON)<>0	/*	IF EITHER IS HELD	*/
	THEN DO;
		CALL PERFORM.INSERT.DELETE;		/*	DO THE INSERT/DELETE FUNCTION	*/
	END;

	/*	Handle press of start button while xpos button is held	*/

	ELSE IF (HELD.XPOS.BUTTON<>0)			/*	XPOS BUTTON - ENABLE TRIGGERING	*/
	THEN DO;
		XPOS.TRIGGER.DISABLED=0;
		IF NEW.PAN THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'Transpose       Trigger:  ON');
			BOTH.DISPLAY = 1;
		END;
	END;

	ELSE IF (HELD.CLIK.BUTTON <> 0)				/*	HOLDING CLICK AND PRESSING START	*/
	THEN DO;
		IF (HELD.SPEED.BUTTON <> 0)				/*	ALSO HOLDING SPEED BUTTON	*/
		THEN DO;											/*	BPM MODE - INSERT METER RECORD	*/
			IF METER.MAP.PTR = 0						/*	CREATE DEFAULT MAPS	*/
			THEN DO;										/*	IF NEEDED				*/
				CALL CREATE.DEFAULT.TEMPO.MAP;
				CALL CREATE.DEFAULT.METER.MAP;
				IF METER.MAP.PTR <> 0 THEN DO;
					CALL SCROLL.SEQ(SAMPLED.ACTUAL.PLAY.TIME.MSB,
										 SAMPLED.ACTUAL.PLAY.TIME.LSB, 0);
					CALL CLEAR.PARAMETERS;
					IF NEW.PAN THEN DO;
						CALL CLEAR.DISPLAY;
						CALL EMIT.STRING(0,'Activating MeterMap');
						UPPER.DISP	 = METER.DISP;
						BOTH.DISPLAY = 1;
						NEW.BEAT.NUMBER = 0;
					END;
				END;
			END;
			ELSE DO;
				CALL INSERT.METER.RECORD(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
				CALL CLEAR.PARAMETERS;
				IF NEW.PAN THEN DO;
					CALL CLEAR.UPPER;
					UPPER.DISP=METER.DISP;
					CALL EMIT.STRING(0,'Insert Meter Evt');
				END;
			END;
		END;

		ELSE DO;											/*	TEMPO MODE - INSERT TEMPO RECORD	*/
			IF TEMPO.MAP.PTR = 0						/*	CREATE DEFAULT MAPS	*/
			THEN DO;										/*	IF NEEDED				*/
				CALL CREATE.DEFAULT.TEMPO.MAP;
				CALL CREATE.DEFAULT.METER.MAP;
				IF TEMPO.MAP.PTR <> 0 THEN DO;
					CALL SCROLL.SEQ(SAMPLED.ACTUAL.PLAY.TIME.MSB,
										 SAMPLED.ACTUAL.PLAY.TIME.LSB, 0);
					CALL CLEAR.PARAMETERS;
					IF NEW.PAN THEN DO;
						CALL CLEAR.DISPLAY;
						CALL EMIT.STRING(0,'Activating TempoMap');
						UPPER.DISP	 = TEMPO.DISP;
						BOTH.DISPLAY = 1;
						NEW.BEAT.NUMBER = 0;
					END;
				END;
			END;
			ELSE DO;
				CALL INSERT.TEMPO.RECORD(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
				CALL CLEAR.PARAMETERS;
				IF NEW.PAN THEN DO;
					CALL CLEAR.UPPER;
					UPPER.DISP=TEMPO.DISP;
					CALL EMIT.STRING(0,'Insert Tempo Evt');
				END;
			END;
		END;

		TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
		CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
	END;	/*	OF IF (HELD.CLIK.BUTTON <> 0)	*/

	ELSE DO;											/*	NORMAL START	*/
		CALL START.SEQUENCER;
		RETURN;
	END;

END PROCESS.START.BUTTON;


/*	$PAGE - PROCESS STOP BUTTON	*/

PROCESS.STOP.BUTTON:PROC SWAPABLE;
	DCL I	FIXED;

	DCL MSG.OFF DATA ("000"+SHL("161",8),"161"+SHL("077",8),0);

	#if (inc.voice.output)
		IF ((HELD.PTUN.BUTTON&HELD.PVOL.BUTTON)<>0)
		{
			SPEAK.IT=0;								/*	TURN OFF VOICE		*/
			RETURN;
		}
	#endif

	ALLOW.TRACK.GROUP.DEFINE = FALSE;		/*	TRACK, THEN STOP: PROBABLY ABOUT TO ERASE NOTES	*/

	IF (HELD.PSEL.BUTTONS<>0) THEN DO;		/*	STOP WHILE PARTIAL BUTTON PRESSED - CREATE TIMBRE SEGMENT	*/
		CALL DELETE.TIMBRE.FRAME;
	END;

	ELSE IF (HELD.EXT.BUTTON<>0)				/*	EXT SYNC - DISABLE KEYBOARD TRIGGER	*/
	THEN DO;
		ENABLE.KEY.TRIG=0;
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'Ext Trigger: OFF');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
		IF EXT.CLOCK.MODE<3 THEN DO;
			IF EXT.CLOCK.MODE<>0
			THEN DO;
				CALL STOP.RECD.MOVE.PLAY;		/*	HAVE TO STOP MOVEMENT FIRST	*/
				EXT.CLOCK.MODE=0;
			END;
			CALL RESYNC.TIME.BASE;
			NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	CHANGE IN SYNC MODE	*/
			NEW.SEQ.INFO=NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
			IF LOWER.DISP=EXT.DISP THEN CALL CLEAR.LOWER;
		END;
	END;

	ELSE IF (HELD.MARK.BUTTON<>0)
	THEN DO;
		MARK.BUTTON.DISABLED=1;					/*	DISABLE MARK FUNCTION	*/
		NEW.MOTION			  =1;					/*	TELL LOD ABOUT IT		*/
		CALL DISPLAY.PARAMETER.BUTTONS;
		IF NEW.PAN THEN DO;						/*	NEW PANEL	*/
			CALL CLEAR.LOWER;
			CALL EMIT.STRING(16,'MARK POINT: OFF');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
	END;

	ELSE IF (HELD.STARTLOOP.BUTTON<>0)		/*	START LOOP + STOP = IGNORE LOOPS	*/
	THEN DO;
		IGNORE.LOOPS = TRUE;
		IF NEW.PAN THEN DO;						/*	NEW PANEL	*/
			CALL CLEAR.LOWER;
			CALL EMIT.STRING(16,'LOOPS: OFF');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
	END;

	ELSE IF (HELD.MIDI.BUTTON<>0)					/*	MIDI BUTTON - ENABLE MIDI ECHO	*/
	THEN DO;
		MIDI.ECHO.DISABLED=1;
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'MIDI Echo: OFF');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
		NEW.PRM.INFO=NEW.PRM.INFO\16;		/*	HAVE A CHANGE IN MIDI ECHO MODE	*/
	END;

	ELSE IF (HELD.SCALE.ADJUST.BUTTON<>0)	/*	SCALE ADJUST & START - USE NEW FREQUENCY LOOKUP TABLE	*/
	THEN DO;
		WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.POLY.FREQ.TABLE;	/*	TELL SEQUENCE TO USE ORIGINAL TABLE	*/
		WRITE(MD )=0;
		POLY.FREQ.TABLE.PTR=FRE.PTR;		/*	AND SET PTR TO THE FM LOOKUP TABLE	*/
		RESET.BITS=RESET.BITS\R.FREQS;	/*	UPDATE ACTIVE NOTES	*/
		NEW.KBD.PRE=1;							/*	AND RECOMPUTE KBD LOOKUP TABLES		*/

		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'Orig Freq Table');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
	END;

	ELSE IF ((HELD.RTE.BUTTONS&2)<>0) THEN DO;	/*	PRESSURE BEING HELD	*/
		MONO.TO.POLY.PRESSURE=0;						/*	TURN OFF PRESSURE CONVERSION	*/
		CALL CLEAR.PARAMETERS;
		IF NEW.PAN THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'Convert Channel To Poly: OFF');
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
		BOTH.DISPLAY = 1;
		SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
		BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
	END;

	/*	Handle press of stop button while the XPOS button is held	*/

	ELSE IF (HELD.XPOS.BUTTON<>0)			/*	XPOS BUTTON - DISABE TRIGGERING	*/
	THEN DO;
		XPOS.TRIGGER.DISABLED=1;
		IF NEW.PAN THEN DO;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'Transpose       Trigger:  OFF');
			BOTH.DISPLAY = 1;
         IF (NEW.ORK == 1)
            DISPLAY.ORK.WINDOW.MESSAGE(MSG.OFF);
		END;
	END;

	ELSE IF (HELD.SKT.BUTTON<>0) THEN DO;
		CALL RESET.KEYBOARD.TIMBRE.CONTROL(0);		/*	ABORT KEYBOARD.TIMBRE.CONTROL	*/
		CALL ABORT.BOUNCE.SMT.SKT;
	END;

	ELSE IF (HELD.POLY.BUTTON<>0) THEN DO;	/*	POLY BUTTON + STOP = RESET VOICES USED	*/
		DO I = 0 TO PSMAXBINS-1;				/*	RESET POLY USED	*/
			POLYUSED(I) = 0;
		END;
		CALL DISPLAY.PAR;							/*	PRESET 0 0 0	*/
	END;

	ELSE IF (HELD.CLIK.BUTTON <> 0) THEN DO;				/*	HOLDING CLICK AND PRESSING STOP	*/
		IF (HELD.SPEED.BUTTON <> 0)							/*	HOLDING SPEED BUTTON ALSO	*/
		THEN DO;														/*	BPM MODE - DELETE METER RECORD	*/
			CALL DELETE.METER.RECORD(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
			CALL CLEAR.PARAMETERS;
			IF NEW.PAN THEN DO;
				CALL CLEAR.UPPER;
				UPPER.DISP=METER.DISP;
				CALL EMIT.STRING(0,'Delete Meter Evt');
			END;
		END;

		ELSE DO;														/*	TEMPO MODE - DELETE TEMPO RECORD	*/
			CALL DELETE.TEMPO.RECORD(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));
			CALL CLEAR.PARAMETERS;
			IF NEW.PAN THEN DO;
				CALL CLEAR.UPPER;
				UPPER.DISP=TEMPO.DISP;
				CALL EMIT.STRING(0,'Delete Tempo Evt');
			END;
		END;

		TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
		CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
	END;

	ELSE DO;											/*	NORMAL 'STOP'	*/
		IF SKT=1 THEN DO;
			CALL RESET.KEYBOARD.TIMBRE.CONTROL(1);	/*	RELEASE KEYBOARD.TIMBRE.CONTROL	*/
		END;

		ABORT.BOUNCE.SMT.SKT();
		CLEAR.ERAS.BUTTON   ();

		IF PLAY<>0 THEN DO;						/*	STOP SEQUENCER IF PLAYING	*/
			IF SLOCKED<>0							/*	STOP WHILE SMPTE LOCKED	*/
			THEN DISABLE.SMPTE.START=1;		/*	KEEP FROM STARTING		*/
			CALL STOP.SEQUENCER;
		END;
		ELSE DO;										/*	STOP PRESSED TWICE	*/
			CALL STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS;	/*	STOP SEQUENCER & TURN OFF ALL LIGHTS	*/
			WRITE(MAM)=CLAV.PTR;
			DO I=0 TO (NUM.KEYS-1);				/*	CLEAR CLAV.STAT	*/
				WRITE(MDI)=0;						/*	TO TURN OFF			*/
			END;										/*	STUCK MIDI NOTES	*/
			NUM.HELD.KEYS=0;						/*	NONE HELD			*/
			CALL ALL.MIDI.NOTES.OFF;			/*	EXTRA INSURANCE	*/
			Stop.DTD.Playback();
		END;
	END;

END PROCESS.STOP.BUTTON;

/*	$PAGE - PROCESS RECORD BUTTON	*/

dcl SAFE.READY.TOGGLES	fixed public;	/*	nonzero - contains bits for d-t-d tracks to record on	*/

PROCESS.RECORD.BUTTON:PROC PUBLIC SWAPABLE;

	DCL MSG.OFF DATA ("000"+SHL("161",8),"161"+SHL("077",8),0);

	DCL (I,J)	FIXED;
	DCL TEMP(1)	FIXED;

	/*	NOTE: ONLY ARM A SINGLE TRACK HERE.  DO NOT ARM ALL MEMBERS OF A GROUP	*/

	IF NUM.OF.HELD.TRACK.BUTTONS<>0 THEN DO;	/*	TRACK BUTTON HELD : TOGGLE SAFE/READY	*/
		ALLOW.TRACK.GROUP.DEFINE = FALSE;		/*	DISALLOW GROUP DEFINE WHILE CHANGING	*/
		DO I=0 TO NUM.TRACK.BUTTONS-1;
			WRITE(MAM)=TBUT.PTR;
			WRITE(MAL)=I;
			J=READ(MD)&255;							/*	GET ABS TRACK #	*/
			IF  ((READ(MD)&B.HELD.TRK)<>0)		/*	BUTTON HELD		*/
			AND (J ige FIRST.LOD.TRACK   )		/*	LOD TRACKS		*/
			AND (J ilt LAST.LOD.TRACK    )		/*	THAT IS			*/
			THEN DO;
				WRITE(MAL)=J;							/*	INDEX TO TRK	*/
				IF (READ(MD)&B.SOLOED.TRK)<>0		/*	UNSOLO TRACK THAT WAS SOLOED WHEN BUTTON WAS PRESSED	*/
				THEN DO;
					WRITE(MD)=READ(MD)&(NOT B.SOLOED.TRK);	/*	CLEAR SOLOED BIT	*/
					NUM.OF.SOLOED.TRACKS=NUM.OF.SOLOED.TRACKS-1;
					CALL COMPUTE.ACTIVE.TRKS;		/*	RECOMPUTE ACTIVE.TRACKS	*/
					CALL DISPLAY.TRACK.BUTTONS;
				END;
				SAFE.READY.TOGGLES = SAFE.READY.TOGGLES XOR BITS(J-FIRST.LOD.TRACK);
				NEW.DTD.INFO = NEW.DTD.INFO \ 4;	/*	TELL SCREEN CODE	*/
			END;
		END;
	END;

	ELSE IF (HELD.MIDI.BUTTON<>0) THEN DO;
		IF NEW.PAN THEN DO;							/*	MAKES SENSE HERE ONLY	*/
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'MIDI Recording      Trks Ready');
			CALL EMIT.NUMBER(16,NUM.ENABLED.TRKS,0,LEFT.JUST);	/*	SHOW NUMBER OF ARMED TRACKS	*/
			BOTH.DISPLAY = 1;
			SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
			BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
		END;
	END;

	ELSE IF PNCH<>0 THEN DO;
		PNCH=0;							/*	IF PUNCHING & PRESS RECORD - JUST RECORD	*/
		NEW.MOTION=1;					/*	TELL LIVE OVERDUB ABOUT IT		*/
	END;

	ELSE IF RECD<>0 THEN CALL STOP.RECORD;			/*	STOP RECORDING BUT CONTINUE ELSE IF PRESSED TWICE	*/

	ELSE DO;													/*	START RECORDING	*/

		IF NUM.HELD.BUTTONS igt 0 then RETURN;		/*	TO AVOID ACCIDENTAL ERASURE OR POLLUTION OF TRACKS,	*/
																/*	DON'T RECORD IF OTHER BUTTONS ARE HELD.					*/

		IF MOVE<>0 THEN CALL STOP.MOVE;				/*	ABORT FF/REWIND	*/

		IF  (PLAY			  <> 0)						/*	IF PLAYING			*/
		AND (SMPTE.ONOFF	  <> 0)						/*	USING SMPTE			*/
		AND (TIME.BASE.MODE <> 4)						/*	BUT NOT LOCKED		*/
		THEN CALL STOP.PLAY;								/*	THEN STOP PLAY		*/
																/*	SO WE CAN SCROLL	*/
		IF PLAY = 0 THEN DO;								/*	IF NOT PLAYING		*/
			IF (SMPTE.ONOFF <> 0)						/*	IF USING SMPTE		*/
			THEN DO;											/*	THEN SCROLL			*/
				CALL PLAY.INITIALIZE;					/*	SET UP FOR PLAY FROM THE TOP	*/
				CALL TAKE.SYSTEM.REAL.TIME(TEMP);
				IF TEMP(0) >= 0							/*	only scroll if it is in front of us	*/
				THEN CALL SCROLL.SEQ(TEMP(0), TEMP(1),0);
				CALL CONTINUE.SEQUENCER;				/*	GET SEQUENCER MOVING	*/
				CONT = 0;									/*	BUT NO CONTINUE LITE	*/
			END;
			ELSE CALL START.SEQUENCER;					/*	NON-SMPTE - EASY		*/
		END;

		IF PLAY<>0 THEN DO;								/*	AM NOW PLAYING	*/
			IF START.RECORD=0 THEN CALL STOP.PLAY;	/*	STOP IF ERROR ENCOUNTERED	*/
		END;
	END;

END PROCESS.RECORD.BUTTON;


/*	$PAGE - PROCESS PUNCH BUTTON	*/

PROCESS.PUNCH.BUTTON:PROC PUBLIC SWAPABLE;
	DCL TEMP(1)	FIXED;

	IF NUM.HELD.BUTTONS igt 0 then RETURN;	/*	TO AVOID ACCIDENTAL ERASURE, DON'T PUNCH IF OTHER BUTTONS ARE HELD	*/

	IF PNCH<>0 THEN CALL STOP.RECORD;	/*	IF PUNCH IN PRESSED AGAIN - FLIP OUT OF PUNCH IN MODE	*/

	ELSE DO;										/*	ELSE START PUNCHING IN	*/
		IF MOVE<>0 THEN CALL STOP.MOVE;	/*	ABORT FF/REWIND	*/

		IF  (PLAY           <> 0)					/*	IF PLAYING		*/
		AND (SMPTE.ONOFF    <> 0)					/*	USING SMPTE		*/
		AND (TIME.BASE.MODE <> 4)					/*	BUT NOT LOCKED	*/
		THEN CALL STOP.PLAY;							/*	THEN STOP PLAY	*/
															/*	SO WE CAN SCROLL	*/
		IF PLAY = 0 THEN DO;							/*	IF NOT PLAYING	*/
			IF (SMPTE.ONOFF <> 0)					/*	IF USING SMPTE	*/
			THEN DO;										/*	THEN SCROLL		*/
				CALL PLAY.INITIALIZE;				/*	SET UP FOR PLAY FROM THE TOP	*/
				CALL TAKE.SYSTEM.REAL.TIME(TEMP);
				IF TEMP(0) >= 0						/*	only scroll if it is in front of us	*/
				THEN CALL SCROLL.SEQ(TEMP(0), TEMP(1),0);
				CALL CONTINUE.SEQUENCER;			/*	GET SEQUENCER MOVING	*/
				CONT = 0;								/*	BUT NO CONTINUE LITE	*/
			END;
			ELSE CALL START.SEQUENCER;				/*	NON-SMPTE - EASY		*/
		END;

		IF PLAY<>0 THEN DO;				/*	AM NOW PLAYING	*/
			IF RECD=0 THEN DO;			/*	START RECORDING	*/
				IF START.RECORD=0 THEN CALL STOP.PLAY;	/*	START RECORDING, BUT STOP IF ERROR (NO TRACK, TIMBRE MISMACTH, ETC)	*/
			END;
			IF RECD<>0 THEN DO;
				TIME.DELTA=0;
				PNCH=1;					/*	IF START.RECORD WAS SUCCESSFUL, THEN BEGIN PUNCHING	*/
				NEW.MOTION=1;			/*	TELL LIVE OVERDUB ABOUT IT		*/
			END;
		END;
	END;

END PROCESS.PUNCH.BUTTON;

/*	$PAGE - PROCESS CONTINUE BUTTON	*/

DCL EDIT.DISP.MODE	FIXED;

PROCESS.CONTINUE.BUTTON:PROC SWAPABLE;

	DCL (I,J,K,L,M)	FIXED;	/*	KEEP IN ORDER	*/
	DCL (MSB,LSB  )	FIXED;

	/*	COMPUTE NEAREST BEAT TIME RETURNS AN ABSOLUTE SYNCL TIME OF	*/
	/*	THE NEAREST CLICK															*/

	COMPUTE.NEAREST.BEAT.TIME:  PROC	FIXED;	/*	MUST BE CALLED WITH INTERRUPTS OFF	*/

		/*	NOTE: ONLY CALL WITH INTERRUPTS OFF!!	*/

		/*	FOR EXTERNAL CLICK - USE LAST CLICK	*/

		IF CLICK.TRACK.MODE=3 THEN DO;	/*	EXTERNAL CLICK	*/
			#MSB=PLAY.TIME.MSB;				/*	BEGIN BY GETTING	*/
			#LSB=LAST.CLICK;					/*	ABSOLUTE TIME	*/

			IF PLAY.TIME.LSB ILT LAST.CLICK
			THEN #MSB=#MSB-1;

			IF (PLAY.TIME.LSB-LAST.CLICK) IGE SHR(EST.RATE,1)
			THEN DO;
				#LSB=#LSB+EST.RATE;
				IF #LSB ILT EST.RATE
				THEN #MSB=#MSB+1;
			END;
			RETURN;
		END;

		IF (CLICK.TRACK.MODE == 0) THEN DO;	/*	INTERNAL CLICK	*/
			/*	BEGIN BY GETTING CURRENT SEQUENCE TIME	*/
			CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),
															LOC(ADDR(#MSB)));

			CALL MAP.SEQUENCE.TIME.TO.NEAREST.BEATS(LOC(ADDR(#MSB)),
																 LOC(ADDR(PRIOR.BEAT.MSB)),
																 LOC(ADDR(NEXT.BEAT.MSB)));

			/*	FIND WHICH BEAT WE ARE CLOSER TO	*/
			IF (NEXT.BEAT.LSB-#LSB) IGT SHR(NEXT.BEAT.LSB-PRIOR.BEAT.LSB,1)
			THEN DO;								/*	USE PRIOR BEAT	*/
				#MSB=PRIOR.BEAT.MSB;
				#LSB=PRIOR.BEAT.LSB;
			END;
			ELSE DO;								/*	CLOSER TO NEXT BEAT	*/
				#MSB=NEXT.BEAT.MSB;
				#LSB=NEXT.BEAT.LSB;
			END;
			/*	AND FINALLY MAP THE NEAREST BEAT TIME BACK TO REAL TIME	*/
			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(#MSB)),LOC(ADDR(#MSB)));
			RETURN;
		END;

		/*	LIVE CLICK TRACK ONLY:	*/

		#MSB=PLAY.TIME.MSB;					/*	BEGIN BY GETTING	*/
		#LSB=NEXT.CLICK;						/*	ABSOLUTE TIME	*/
		IF NEXT.CLICK ILT PLAY.TIME.LSB	/*	OF NEXT CLICK	*/
		THEN #MSB=#MSB+1;

		/*	WATCH OUT HERE - LAST CLICK MAY ACTUALLY BE IN FRONT OF US	*/
		/*	IF WE ARE SCANNING NOTES OFF OF A LIVE CLICK TRACK				*/

		IF (NEXT.CLICK-PLAY.TIME.LSB) IGT SHR(EST.RATE,1)
		THEN DO;								/*	BACK UP TO PRIOR CLICK	*/
			IF #LSB ILT EST.RATE
			THEN #MSB=#MSB-1;
			#LSB=#LSB-EST.RATE;
		END;

		RETURN;

	END COMPUTE.NEAREST.BEAT.TIME;

	IF  (INC.POLY<>0)								/*	POLY COMPILATION	*/
	AND ((HELD.SCALE.ADJUST.BUTTONS&7)<>0)	/*	COEF BUTTON HELD	*/
	THEN DO;
		CALL LOOP.SEARCH(1);						/*	LOOPING SEARCH	*/
	END;

	ELSE IF (HELD.MARK.BUTTON<>0)				/*	MARK + CONTINUE - SET MARK POINT	*/
	THEN DO;
		DISABLE;
		CALL COMPUTE.NEAREST.BEAT.TIME;		/*	ROUNDS TIME TO NEAREST BEAT	*/
		ENABLE;

		call Map.Real.Time.To.Sequence.Time(loc(addr(#msb				)),
														loc(addr(mark.button.msb)));

		WRITE(MAM) = BAS.PTR; WRITE(MAL) = SEQ.MARK.MSB;	/*	AND RE-WRITE TO SEQUENCE AREA	*/
		WRITE(MDI) = MARK.BUTTON.MSB;
		WRITE(MD ) = MARK.BUTTON.LSB;

		//	The following three lines are unnecessary because the subsequent call to "DISPLAY.PAR"
		//	will indirectly cause the same thing to be executed.
		//
		//	NEW.MOTION = True;	/*	TELL LOD ABOUT IT	*/
		//	/*	Create a system event when the mark start time changes:	*/
		//	NEW.SEQ.INFO = (NEW.SEQ.INFO|128);

		/*	Turn Mark on for ergonomics (user probably wouldn't change mark unless intending to use it)	*/
		MARK.BUTTON.DISABLED = False; DISPLAY.PAR(); DISPLAY.PARAMETER.BUTTONS();
	END;

	ELSE IF (HELD.INSERT.BUTTON<>0)
	OR		  (HELD.DELETE.BUTTON<>0)
	THEN DO;

		DISABLE;

		IF CLICK.TRACK.MODE=3				/*	EXTERNAL CLICK		*/
		THEN DO;									/*	MUST ROUND END TIME	*/
			I=PLAY.TIME.MSB;					/*	GET TIME OF LAST	*/
			J=LAST.CLICK;						/*	CLICK					*/
			IF PLAY.TIME.LSB ILT LAST.CLICK
			THEN I=I-1;
			IF (PLAY.TIME.LSB-LAST.CLICK) IGE SHR(EST.RATE,1)
			THEN DO;
				J=J+EST.RATE;
				IF J ILT EST.RATE
				THEN I=I+1;
			END;
		END;
		ELSE DO;
			I=PLAY.TIME.MSB; J=PLAY.TIME.LSB;	/*	SAMPLE CURRENT TIME	*/
		END;

		ENABLE;

		/*	map to sequence time for edit information:	*/

		call Map.Real.Time.To.Sequence.Time(loc(addr(i)),
														loc(addr(i)));

		K=MARK.BUTTON.MSB;					/*	GET MARK TIME		*/
		L=MARK.BUTTON.LSB;

		IF (K=0)&(L ILT ZERO.TIME)			/*	BUT LIMIT TO >=	*/
		THEN L=ZERO.TIME;						/*	ZERO.TIME			*/

		IF ((I ILT K))							/*	CURRENT PLAY TIME	*/
		OR ((I  =  K)							/*	IS BEFORE MARK		*/
		AND (J ILE L)) THEN DO;				/*	TIME					*/
			EDIT.LEN.MSB=0; EDIT.LEN.LSB=0;
		END;

		ELSE IF CLICK.TRACK.MODE=3			/*	EXTERNAL CLICK			*/
		THEN DO;
			EDIT.LEN.MSB=I-K;					/*	RESULTS IN JUSTIFIED	*/
			EDIT.LEN.LSB=J-L;					/*	END TIME					*/
			IF J ILT L THEN EDIT.LEN.MSB=EDIT.LEN.MSB-1;
		END;

		ELSE DO;	/*	PLAY TIME > MARK TIME; LIVE OR INTERNAL CLICK: JUSTIFY LENGTH (EDIT.LEN)	*/

			EDIT.LEN.MSB=I-K;					/*	GET EDIT LEN (UNJUSTIFIED)	*/
			EDIT.LEN.LSB=J-L;					/*	END TIME							*/
			IF J ILT L THEN EDIT.LEN.MSB=EDIT.LEN.MSB-1;

			IF CLICK.TRACK.MODE igt 3 THEN DO;		/*	LIVE CLICK TRACK	*/
				CALL REMAP.WITH.LIVE.CLICK(K,L,EDIT.LEN.MSB,EDIT.LEN.LSB,1);	/*	GET BEAT TIME OF MARK POINT	*/
				EDIT.LEN.MSB=REMAPPED.DUR.MSB;		/*	GET DUR IN BEATS	*/
				EDIT.LEN.LSB=REMAPPED.DUR.LSB;
			END;

			/*	JUSTIFY EDIT LENGTH TO BE EVEN NUMBER OF BEATS	*/

			CALL MAP.SEQUENCE.TIME.TO.NEAREST.BEATS(LOC(ADDR(I)),
																 LOC(ADDR(PRIOR.BEAT.MSB)),
																 LOC(ADDR(NEXT.BEAT.MSB)));

			/*	FIND WHICH BEAT WE ARE CLOSER TO	*/
			IF (NEXT.BEAT.LSB-J) IGT SHR(NEXT.BEAT.LSB-PRIOR.BEAT.LSB,1)
			THEN DO;										/*	USE PRIOR BEAT	*/
				EDIT.LEN.MSB=PRIOR.BEAT.MSB-K;
				EDIT.LEN.LSB=PRIOR.BEAT.LSB-L;
				IF PRIOR.BEAT.LSB ILT L THEN EDIT.LEN.MSB=EDIT.LEN.MSB-1;
			END;
			ELSE DO;										/*	USE NEXT BEAT	*/
				EDIT.LEN.MSB=NEXT.BEAT.MSB-K;
				EDIT.LEN.LSB=NEXT.BEAT.LSB-L;
				IF NEXT.BEAT.LSB ILT L THEN EDIT.LEN.MSB=EDIT.LEN.MSB-1;
			END;

			IF CLICK.TRACK.MODE igt 3 THEN DO;		/*	LIVE CLICK TRACK	*/
				CALL REMAP.WITH.LIVE.CLICK(REMAPPED.TIME.MSB,REMAPPED.TIME.LSB,EDIT.LEN.MSB,EDIT.LEN.LSB,0);	/*	REMAP EDIT LEN TO ACTUAL TIME	*/
				EDIT.LEN.MSB=REMAPPED.DUR.MSB;		/*	GET DUR IN SYNC TIME	*/
				EDIT.LEN.LSB=REMAPPED.DUR.LSB;
			END;

		END;

		CALL DISPLAY.PAR;

	END;

	ELSE IF (HELD.CLIK.BUTTON<>0)						/*	HOLDING CLICK AND PRESSING CONTINUE	*/
	THEN DO;
		IF (CLICK.TRACK.MODE == 0) {					/*	INTERNAL CLICK - TOGGLE CLICK DISPLAY MODE	*/
			//	If other parameters involving HELD.CLIK.BUTTON are currently displayed (i.e., meter or clickval display),
			//	then just show the current CLICK DISPLAY MODE without toggling it.
			if (UPPER.DISP != (CLICK.L-PAR.L)) {
				CLEAR.PARAMETERS();
				ADD.PARM.TO.ACTIVE.LIST(CLICK.L-PAR.L,CLICK.L-PAR.L);
			}
			else {
				CLICK.DISP.MODE = CLICK.DISP.MODE+1;				/*	STEP THROUGH MODES						*/
				IF (CLICK.DISP.MODE == 4) CLICK.DISP.MODE = 0;	/*	WRAP TO 0 IF PAST THE LAST OPTION	*/
				CALL SET.CLOCK.CASE;						/*	SET UP EXT.CLOCK.CASE	*/
				NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;		/*	NEW CONSTANTS ON CLICK TRACK MODE CHANGE	*/
			}
			CALL DISPLAY.PAR;
			CALL DISPLAY.PARAMETER.BUTTONS;
		}
		TOGGLE.CLICKON = false;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
		CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
	END;

	ELSE DO;
		CONT.HELD=1;						/*	INDICATE HELD	*/

		IF CONT<>0
		THEN CONTINUE.BUTTON.ACTIVE=1;	/*	SET FLAG; IF NOTE PLAYED, SET START TIMER HERE	*/
		ELSE CONTINUE.BUTTON.ACTIVE=0;	/*	CONTINUE BUTTON NO LONGER ACTIVE	*/

		CALL CONTINUE.SEQUENCER;		/*	DO REST OF FUNCTIONS IN PROC	*/
		RETURN;								/*	DID DISPLAY.SEQUENCER.STATUS IN PROC	*/

	END;

END PROCESS.CONTINUE.BUTTON;

/*	$PAGE	*/

PROCESS.ERASE.BUTTON:PROC PUBLIC SWAPABLE;			/*	ERASE BUTTON PRESS									*/
	DCL (THE_BUTTON  )		FIXED;
	DCL (THE_TRACK   )		FIXED;
	DCL (DISP_NUMLEFT)		FIXED;
	DCL (THIS.STYLE  )		FIXED;


	/*	BEGIN BY DETERMINING WHAT KIND OF ERASE IS BEING ASKED FOR.  CHECK	*/
	/*	FOR ALL POSSIBLE CASES.																*/

	CALL ABORT.BOUNCE.SMT.SKT;								/*	MAKE SURE BOUNCE STOPS AFTER CRM					*/

	ALLOW.TRACK.GROUP.DEFINE = FALSE;					/*	DISABLE GROUP DEFINE WHEN PRESSING ERASE		*/

	THIS.STYLE = ERASE.NO.STYLE;							/*	ASSUME NO STYLE SELECTED							*/

	IF (HELD.CLIK.BUTTON != false) {
		TOGGLE.CLICKON=FALSE;		//	Don't toggle the click's on/off status on release of click button if we've been here.
		if ((Tempo.Map.Ptr/*|Meter.Map.Ptr*/) == null) return;				//	Ignore these button presses if no maps
		IF (HELD.SPEED.BUTTON != false)	THIS.STYLE = ERASE.TEMPO.MAP;		//	if holding click and speed
		ELSE										THIS.STYLE = CONV.TO.UNMAPPED;	//	if holding just click
		CLICK.TRACK.FUNCTION = 0;	//	Clear track number and selection
	}

	ELSE IF	(((RECD<>0)
	AND		  (RECD.TRK=0))								/*	IF RECORDING LOD TRACK								*/
	OR			 (LOD.RECD.TRACKS<>0))
	{
		CALL CLEAR.ERAS.BUTTON;								/*	CLEAN UP POSSIBLE ERAS								*/
		CALL DISPLAY.ERR(44);								/*	CAN'T ERASE LOD TRACKS FROM BUTTON PANEL		*/
		CALL SET.ERROR(ERR.DTDERAS,'');
		THIS.STYLE = ERASE.NO.STYLE;
	}

	ELSE IF (RECD != 0)										/*	ERASE OF RECORD TRACK								*/
		THIS.STYLE = ERASE.RECD.TRACK;

	ELSE IF (NUM.OF.HELD.TRACK.BUTTONS != 0)
		THIS.STYLE = ERASE.HELD.TRACKS;

	ELSE IF (NUM.OF.SOLOED.TRACKS != 0)
		THIS.STYLE = ERASE.SOLOED.TRACKS;

	ELSE
		THIS.STYLE = ERASE.ALL.TRACKS;


	/*	NOW HANDLE FIRST PRESS OF ERASE BUTTON.  THAT IS, PRESENT A MESSAGE	*/
	/*	IN THE WINDOW DISPLAY AND SAVE AWAY WHAT STATE WE ARE PREPARING FOR	*/

	IF (ERAS == 0)										/*	FIRST PRESS - ARM THINGS				*/
	{
		IF (THIS.STYLE != ERASE.NO.STYLE)		/*	IF NO ERROR ENCOUNTERED					*/
		{
			CALL CLEAR.DISPLAY;						/*	CLEAR PRIOR DISPLAY						*/

			ERAS			= 1;							/*	INDICATE PRESSING IT ONCE				*/
			ERASE.STYLE	= THIS.STYLE;

			DO CASE (ERASE.STYLE - 1);				/*	PRESENT APPROPRIATE MESSAGE			*/

				DO;										//	ERASE.TEMPO.MAP	(Erase Maps: preserve beats)
					CALL EMIT.STRING(0,'Erase Tempo Map Preserve Beats?');
				UPPER.DISP = ET.DISP;
				END;

				DO;										//	CONV.TO.UNMAPPED	(Erase Maps: preserve times)
					CALL EMIT.STRING(0,'Erase Tempo Map Preserve Times?');
				UPPER.DISP = ET.DISP;
				END;

				DO;										/*	ERASE.RECD.TRACK							*/
					CALL EMIT.STRING(0,'Erase RECORDING Track?');
				UPPER.DISP = ERAS.DISP;
				END;

				DO;										/*	ERASE.HELD.TRACKS							*/
					CALL EMIT.STRING(0,'Erase HELD      Track(s)?');
				UPPER.DISP = ERAS.DISP;
				END;

				DO;										/*	ERASE.SOLOED.TRACKS						*/
					CALL EMIT.STRING(0,'Erase SOLOED    Track(s)?');
				UPPER.DISP = ERAS.DISP;
				END;

				DO;										/*	ERASE.ALL.TRACKS							*/
					CALL EMIT.STRING(0,'Erase ALL       Tracks?');
				UPPER.DISP = ERAS.DISP;
				END;

			END;

			BOTH.DISPLAY			= 1;
			SUPRESS.BEAT.DISPLAY	= 1;
			BEAT.DISPLAY.TIME		= REAL.MILLISECONDS;
		}
	}

	/*	ELSE ACTUALLY ERASE ON SECOND PRESS	*/

	ELSE														/*	SECOND PRESS OF ERASE BUTTON							*/
	{
		IF (ERASE.STYLE != THIS.STYLE)				/*	SEE IF USER HAS CHANGED HIS STYLE OF ERASE...	*/
		{
			CLEAR.ERAS.BUTTON();							/*	BIG ERROR													*/

			CALL CLEAR.DISPLAY;

			CALL EMIT.STRING(0,'Error with eraseselection');

			BOTH.DISPLAY			= 1;
			SUPRESS.BEAT.DISPLAY	= 1;
			BEAT.DISPLAY.TIME		= REAL.MILLISECONDS;
		}

		ELSE IF (ERASE.STYLE == ERASE.NO.STYLE)	/*	OR DETECT UNKNOWN ERROR							*/
		{
			CLEAR.ERAS.BUTTON();							/*	BIG ERROR											*/

			CALL CLEAR.DISPLAY;

			CALL EMIT.STRING(0,'Canot erase at  this time');
			BOTH.DISPLAY			= 1;
			SUPRESS.BEAT.DISPLAY	= 1;
			BEAT.DISPLAY.TIME		= REAL.MILLISECONDS;
		}

		ELSE													/*	ELSE PERFORM THE SELECTED ERASE FUNCTION	*/
		{
			DO CASE (ERASE.STYLE - 1);

				DO;											//	ERASE.TEMPO.MAP	(Erase Maps: preserve beats)
					call Erase.Meter.Map.Info;			/*	erase first!!								*/
					call Erase.Tempo.Map.Info;

					write(mam) = bas.ptr;				/*	RESTORE MAGIC # TO USE					*/
					write(mal) = magic.number;			/*	SEQUENCE WITH EARLY						*/

					if (read(md) == magic#6)			/*	if seq is a tempo map sequence (eg	*/
						write(md) = magic#5;				/*	no groups) then restore magic#		*/

					call clear.display;

					CALL EMIT.STRING(0,'Tempo map erased');
					CALL DISPLAY.NUMB.LEFT;
				END;

				DO;											//	CONV.TO.UNMAPPED	(Erase Maps: preserve times)
					Convert.Mapped.To.Unmapped();
					clear.display();
					EMIT.STRING(0,'Tempo map erased');
					DISPLAY.NUMB.LEFT();
				END;

				DO;											/*	ERASE.RECD.TRACK							*/
					THE_TRACK = RECD.TRK;				/*	SAVE RECORD TRK # IN TEMP				*/

					IF (RECD != 0) STOP.RECORD();		/*	STOP RECORDING								*/

					CLEAR.PARAMETERS();					/*	CLEAR POSSIBLE PARM BUTTONS			*/

					IF (MOVE != 0) STOP.MOVE();		/*	STOP ANY  MOVEMENT						*/
					IF (PLAY != 0) STOP.PLAY();		/*	STOP PLAYING TOO							*/

					IF (HELD.STOP.BUTTON<>0)			/*	HOLDING STOP BUTTON						*/
					THEN CALL DELETE.NOTELIST.FROM.TRK		 (THE_TRACK);	/*	ERASE ONLY THE NOTES					*/
					ELSE CALL ERASE.TRACK.BUT.PRESERVE.GROUP(THE_TRACK);	/*	ELSE ERASE TRACK BUT NOT GROUP	*/

					DISPLAY.NUMB.LEFT();					/*	SHOW NUMBER OF NOTES LEFT				*/
				END;

				DO;											/*	ERASE.HELD.TRACKS							*/
					DISP_NUMLEFT = TRUE;					/*	ALLOW NUMB.LEFT DISPLAY	*/

					IF (RECD != 0) STOP.RECORD();		/*	STOP RECORDING								*/

					CLEAR.PARAMETERS();					/*	CLEAR POSSIBLE PARM BUTTONS			*/

					IF (MOVE != 0) STOP.MOVE();		/*	STOP ANY  MOVEMENT						*/
					IF (PLAY != 0) STOP.PLAY();		/*	STOP PLAYING TOO							*/

					DO THE_BUTTON = 0 TO (NUM.TRACK.BUTTONS - 1);

						WRITE(MAM)=TBUT.PTR;				/*	EXAMINE HELD BIT							*/
						WRITE(MAL)=THE_BUTTON;

						IF (READ(MD)&B.HELD.TRK)<>0	/*	THIS TRK IS HELD							*/
						THEN DO;

							THE_TRACK = READ(MD) & 0xFF;	/*	LOOK UP TRACK							*/

							IF  (THE_TRACK >= FIRST.LOD.TRACK)
							AND (THE_TRACK <  LAST.LOD.TRACK)
							THEN DO;
								CALL DISPLAY.ERR(44);		/*	GIVE ERROR MESSAGE					*/
								CALL SET.ERROR(ERR.DTDERAS,'');
								DISP_NUMLEFT = 0;
							END;
							ELSE DO;
								IF (HELD.STOP.BUTTON<>0)	/*	HOLDING STOP BUTTON					*/
								THEN CALL DELETE.NOTELIST.FROM.TRK(THE_TRACK);	/*	ERASE ONLY THE NOTES					*/
								ELSE CALL ERASE.TRACK				 (THE_TRACK);	/*	ERASE TRACK INCLUDING GRP INFO	*/
							END;
						END;
					END;

					NAH.COLLECT();								/*	CLEAN UP NOTE AREA					*/

					IF (DISP_NUMLEFT != 0)
						DISPLAY.NUMB.LEFT();					/*	SHOW NUMBER OF NOTES LEFT			*/
				END;

				DO;												/*	ERASE.SOLOED.TRACKS					*/
					DISP_NUMLEFT = 1;							/*	ALLOW NUMB.LEFT DISPLAY				*/

					IF (RECD != 0) STOP.RECORD();			/*	STOP RECORDING							*/

					CLEAR.PARAMETERS();						/*	CLEAR POSSIBLE PARM BUTTONS		*/

					IF (MOVE != 0) STOP.MOVE();			/*	STOP ANY  MOVEMENT					*/
					IF (PLAY != 0) STOP.PLAY();			/*	STOP PLAYING TOO						*/

					DO THE_TRACK = NUM.KBD.TRACKS TO (MAX.TRACKS-1);	/*	LOOP OVER TRKS		*/

						WRITE(MAM)=TBUT.PTR;					/*	EXAMINE HELD BIT						*/
						WRITE(MAL)=THE_TRACK;

						IF (READ(MD)&B.SOLOED.TRK)<>0		/*	THIS TRK IS SOLOED					*/
						THEN DO;
							IF  (THE_TRACK >= FIRST.LOD.TRACK)
							AND (THE_TRACK <  LAST.LOD.TRACK)
							THEN DO;
								CALL DISPLAY.ERR(44);		/*	GIVE ERROR MESSAGE					*/
								CALL SET.ERROR(ERR.DTDERAS,'');
								DISP_NUMLEFT = 0;
							END;
							ELSE DO;
								IF (HELD.STOP.BUTTON<>0)	/*	HOLDING STOP BUTTON					*/
								THEN CALL DELETE.NOTELIST.FROM.TRK(THE_TRACK);			/*	ERASE ONLY THE NOTES					*/
								ELSE CALL ERASE.TRACK.BUT.PRESERVE.GROUP(THE_TRACK);	/*	ELSE ERASE TRACK SAVING GRP INFO	*/
							END;
						END;
					END;

					NAH.COLLECT      ();						/*	CLEAN UP NOTE AREA					*/

					IF (DISP_NUMLEFT != 0)
						DISPLAY.NUMB.LEFT();					/*	SHOW NUMBER OF NOTES LEFT			*/
				END;

				DO;												/*	ERASE.ALL.TRACKS						*/
					IF (RECD != 0) STOP.RECORD();			/*	STOP RECORDING							*/

					CLEAR.PARAMETERS();						/*	CLEAR POSSIBLE PARM BUTTONS		*/

					IF (MOVE != 0) STOP.MOVE();			/*	STOP ANY  MOVEMENT					*/
					IF (PLAY != 0) STOP.PLAY();			/*	STOP PLAYING TOO						*/

					IF (HELD.STOP.BUTTON <> 0)				/*	HOLDING STOP BUTTON					*/
					THEN DO;
						DO THE_TRACK=NUM.KBD.TRACKS TO (MAX.TRACKS-1);	/*	LOOP OVER TRKS					*/
							IF (THE_TRACK <  FIRST.LOD.TRACK)		/*	IF THE_TRACK IS NOT AN LOD TRACK	*/
							OR (THE_TRACK >=  LAST.LOD.TRACK)
							THEN CALL DELETE.NOTELIST.FROM.TRK(THE_TRACK);	/*	ERASE ONLY THE NOTES		*/
						END;
						CALL NAH.COLLECT;
					END;
					ELSE CALL SEQ.INIT;						/*	ERASE EVERYTHING	*/

					DISPLAY.NUMB.LEFT();						/*	SHOW NUMBER OF NOTES LEFT			*/
				END;

			END;

			CLEAR.ERAS.BUTTON();
		}
	}

END PROCESS.ERASE.BUTTON;


/*	$SUBTITLE - ROUTINE TO PROCESS SEQUENCER BUTTON PRESSES AND RELEASES	*/

DCL MIPGM.ON.SKT.CONTROL	FIXED PUBLIC;

SEQUENCER.BUTTON:PROC(CODE,VALUE) PUBLIC SWAPABLE;			/*	ROUTINE TO PROCESS SEQUENCER BUTTONS	*/
	DCL (CODE,VALUE)	FIXED;
	DCL (I,J,K,L)		FIXED;

	#if (true)
	if CODE ile (TRACKPAN.L-SEQ.L) then do case CODE;
		;
		//	Case  1: CODE = (STOP.L		 - SEQ.L)
		HELD.STOP.BUTTON			= HELD.STOP.BUTTON		XOR 1;
		;;;
		//	Case  5: CODE = (REW.L		 - SEQ.L)
		HELD.REWIND.BUTTON		= HELD.REWIND.BUTTON		XOR 1;
		//	Case  6: CODE = (FF.L		 - SEQ.L)
		HELD.FF.BUTTON				= HELD.FF.BUTTON			XOR 1;
		;
		//	Case  8: CODE = (ELOOP.L	 - SEQ.L)
		HELD.ENDLOOP.BUTTON		= HELD.ENDLOOP.BUTTON	XOR 1;
		//	Case  9: CODE = (TRANSP.L	 - SEQ.L)
		HELD.XPOS.BUTTON			= HELD.XPOS.BUTTON		XOR 1;
		;;
		//	Case 12: CODE = (SKT.L		 - SEQ.L)
		HELD.SKT.BUTTON			= HELD.SKT.BUTTON			XOR 1;
		//	Case 13: CODE = (EXT.L		 - SEQ.L)
		HELD.EXT.BUTTON			= HELD.EXT.BUTTON			XOR 1;
		;
		//	Case 15: CODE = (SLOOP.L	 - SEQ.L)
		HELD.STARTLOOP.BUTTON	= HELD.STARTLOOP.BUTTON	XOR 1;
		;
		//	Case 17: CODE = (INSERT.L	 - SEQ.L)
		HELD.INSERT.BUTTON		= HELD.INSERT.BUTTON		XOR 1;
		//	Case 18: CODE = (DELETE.L	 - SEQ.L)
		HELD.DELETE.BUTTON		= HELD.DELETE.BUTTON		XOR 1;
		//	Case 19: CODE = (TRACKPAN.L - SEQ.L)
		HELD.TPAN.BUTTON			= HELD.TPAN.BUTTON		XOR 1;
	end;

	#else
		  IF (CODE=(EXT.L		  - SEQ.L)) THEN HELD.EXT.BUTTON			= HELD.EXT.BUTTON			XOR 1;	/*	KEEP TRACK OF EXT BUTTON HELD	*/
	else IF (CODE=(SLOOP.L	  - SEQ.L)) THEN HELD.STARTLOOP.BUTTON	= HELD.STARTLOOP.BUTTON	XOR 1;
	else IF (CODE=(ELOOP.L	  - SEQ.L)) THEN HELD.ENDLOOP.BUTTON	= HELD.ENDLOOP.BUTTON	XOR 1;
	else IF (CODE=(STOP.L	  - SEQ.L)) THEN HELD.STOP.BUTTON		= HELD.STOP.BUTTON		XOR 1;
	else IF (CODE=(REW.L		  - SEQ.L)) THEN HELD.REWIND.BUTTON		= HELD.REWIND.BUTTON		XOR 1;
	else IF (CODE=(FF.L		  - SEQ.L)) THEN HELD.FF.BUTTON			= HELD.FF.BUTTON			XOR 1;
	else IF (CODE=(INSERT.L	  - SEQ.L)) THEN HELD.INSERT.BUTTON		= HELD.INSERT.BUTTON		XOR 1;
	else IF (CODE=(DELETE.L	  - SEQ.L)) THEN HELD.DELETE.BUTTON		= HELD.DELETE.BUTTON		XOR 1;
	else IF (CODE=(TRANSP.L	  - SEQ.L)) THEN HELD.XPOS.BUTTON		= HELD.XPOS.BUTTON		XOR 1;
	else IF (CODE=(SKT.L		  - SEQ.L)) THEN HELD.SKT.BUTTON			= HELD.SKT.BUTTON			XOR 1;
	else IF (CODE=(TRACKPAN.L - SEQ.L)) THEN HELD.TPAN.BUTTON		= HELD.TPAN.BUTTON		XOR 1;

	#endif

	IF (NEW.PAN)&(INFO.MODE<>0)  THEN DO;			/*	DISPLAY NOTES LEFT IN RECORDER	*/
		IF (CODE=(START.L-SEQ.L)) THEN DO;			/*	START BUTTON	*/
			IF VALUE=0 THEN RETURN;
			CALL CLEAR.UPPER;
			CALL EMIT.STRING(0,'RECORDER STATUS');
			CALL DISPLAY.NUMB.LEFT;
			BOTH.DISPLAY=1;
			RETURN;
		END;
		ELSE IF (CODE=(SKT.L-SEQ.L)) THEN DO;		/*	SKT BUTTON	*/
			IF VALUE=0 THEN RETURN;
			CALL CLEAR.DISPLAY;
			CALL EMIT.STRING(0,'KEYBOARD CONTROL');
			IF (KEYBOARD.TIMBRE.CONTROL<>0) THEN DO;
				CALL EMIT.STRING(16,'TRACK');
				CALL EMIT.NUMBER(22,KEYBOARD.TIMBRE.CONTROL-1,0,LEFT.JUST);
			END;
			ELSE CALL EMIT.STRING(16,'IS NORMAL');
			BOTH.DISPLAY=1;
			RETURN;
		END;
		CALL INFO.BUTTON.PRESS;				/*	GET OUT OF INFO MODE IF OTHER BUTTON PRESSED	*/
	END;

	IF  ((HELD.RTE.BUTTONS & "177775")<>0) THEN RETURN;	/*	DO NOTHING IF IN RTE MODE EXCEPT IF PRESSURE ONLY IS BEING HELD	*/

	IF  ((HELD.RTE.BUTTONS & 2)<>0) THEN DO;	/*	USED TO ENABLE/DISABLE PRESSURE CONVERSION	*/
		IF  (CODE<>(STOP.L -SEQ.L))				/*	ONLY THE START AND STOP BUTTONS	*/
		AND (CODE<>(START.L-SEQ.L))				/*	ARE USED FOR THIS FEATURE			*/
		THEN RETURN;									/*	IGNORE ALL OTHERS						*/
	END;

	IF HELD.MIDI.BUTTON<>0 THEN DO;	/*	USED TO ENABLE/DISABLE MIDI FEATURES	*/
		IF  (CODE<>(STOP.L  -SEQ.L))	/*	ONLY THE START, STOP							*/
		AND (CODE<>(START.L -SEQ.L))	/*	RECORD AND SKT BUTTONS AND EXT SYNC		*/
		AND (CODE<>(RECORD.L-SEQ.L))	/*	ARE USED											*/
		AND (CODE<>(SKT.L   -SEQ.L))
		AND (CODE<>(EXT.L   -SEQ.L))
		THEN RETURN;						/*	IGNORE ALL OTHERS								*/
	END;

	IF (CODE=(REW.L-SEQ.L)) THEN DO;
		IF (HELD.CLIK.BUTTON<>0)		/*	HOLDING CLICK AND PRESSING RW	*/
		THEN DO;
			IF (HELD.SPEED.BUTTON<>0)	/*	HOLDING SPEED TOO	*/
			THEN {IF (VALUE<>0) THEN CALL BACKUP.TO.PRIOR.METER.RECORD;}	/*	BPM MODE	*/
			ELSE {IF (VALUE<>0) THEN CALL BACKUP.TO.PRIOR.TEMPO.RECORD;}	/*	TEMPO.MODE	*/
			TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
			CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
			RETURN;
		END;

		IF ((HELD.REWIND.BUTTON=1)		/*	JUST PRESSED REWIND BUTTON	*/
		AND (MOVE.SPEED	  =2000))	/*	WANT SEQUENCER TO STOP		*/
		OR ((HELD.REWIND.BUTTON=0)		/*	JUST RELEASED BUTTON			*/
		AND (MOVE.SPEED		  =0))	/*	AND WE ARE NOT MOVING		*/
		THEN DO;
			CALL STOP.RECD.MOVE.PLAY;			/*	ABORT FF/REWIND OPERATION NICELY	*/
			CALL DISPLAY.SEQUENCER.STATUS;	/*	SET UP SEQUENCER DISPLAY	*/
			RETURN;
		END;
	END;
	IF (CODE=(FF.L-SEQ.L)) THEN DO;
		IF (HELD.CLIK.BUTTON<>0)			/*	HOLDING CLICK AND PRESSING FF	*/
		THEN DO;
			IF (HELD.SPEED.BUTTON<>0)		/*	HOLDING SPEED TOO	*/
			THEN {IF (VALUE<>0) THEN CALL ADVANCE.TO.NEXT.METER.RECORD;}	/*	BPM MODE	*/
			ELSE {IF (VALUE<>0) THEN CALL ADVANCE.TO.NEXT.TEMPO.RECORD;}	/*	TEMPO MODE	*/
			TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
			CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
			RETURN;
		END;

		IF ((HELD.FF.BUTTON= 1)				/*	JUST PRESSED FF BUTTON	*/
		AND (MOVE.SPEED =-2000))			/*	WANT TO STOP SEQUENCER	*/
		OR ((HELD.FF.BUTTON=0)				/*	JUST RELEASED BUTTON		*/
		AND (MOVE.SPEED	 =0))				/*	AND WE ARE NOT MOVING	*/
		THEN DO;
			CALL STOP.RECD.MOVE.PLAY;			/*	ABORT FF/REWIND OPERATION NICELY	*/
			CALL DISPLAY.SEQUENCER.STATUS;	/*	SET UP SEQUENCER DISPLAY	*/
			RETURN;
		END;
	END;

	/*	HANDLE BUTTON RELEASES HERE	*/

	IF VALUE=0 THEN DO;	/*	BUTTON RELEASE	*/
		IF (CODE=(START.L-SEQ.L))
		OR (CODE=(STOP.L -SEQ.L)) THEN DO;
			IF UPPER.DISP=TEMPO.DISP THEN DO;
				CALL CLEAR.PARAMETERS;	/*	GET RID OF CURRENTLY ACTIVE PARS	*/
				CALL ADD.PARM.TO.ACTIVE.LIST(CLICK.L-PAR.L,CLICK.L-PAR.L);
				CALL DISPLAY.PAR;
				CALL DISPLAY.PARAMETER.BUTTONS;
				NEW.BEAT.NUMBER = 1;
			END;
			ELSE IF UPPER.DISP=METER.DISP THEN DO;
				CALL CLEAR.PARAMETERS;	/*	GET RID OF CURRENTLY ACTIVE PARS	*/
				CALL ADD.PARM.TO.ACTIVE.LIST(BPM.L-PAR.L,BPM.L-PAR.L);
				CALL DISPLAY.PAR;
				CALL DISPLAY.PARAMETER.BUTTONS;
				NEW.BEAT.NUMBER = 1;
			END;
		END;
		IF CODE=(CONT.L -SEQ.L) THEN CONT.HELD=0;	/*	RELEASE OF CONTINUE BUTTON	*/
		IF CODE=(SLOOP.L-SEQ.L) THEN CALL DISPLAY.TRACK.BUTTONS;
		RETURN;											/*	NOTHING ELSE TO DO ON SEQUENCER BUTTON RELEASE	*/
	END;

	/*	HANDLE BUTTON PRESSES	*/

	IF  (CODE<>(CONT.L -SEQ.L))	/*	NOT PRESSING CONTINUE BUTTON	*/
	AND (CODE<>(ELOOP.L-SEQ.L))	/*	OR				 LOOP		 BUTTON	*/
	THEN CONT=0;						/*	CLEAR CONTINUE SWITCH			*/

	SUPRESS.BEAT.DISPLAY=0;		/*	ALLOW BEAT DISPLAY WHEN PRESSING ANY SEQUENCER BUTTON	*/

	/*	$PAGE - PROCESS SEQUENCER BUTTON	*/


	DO CASE (CODE);	/*	BRANCH ON CODE	*/

		CALL PROCESS.START.BUTTON;		/*	START.L		*/

		CALL PROCESS.STOP.BUTTON;		/*	STOP.L		*/

		CALL PROCESS.RECORD.BUTTON;	/*	RECORD.L		*/

		CALL PROCESS.PUNCH.BUTTON;		/*	PUNCH.L		*/

		CALL PROCESS.CONTINUE.BUTTON;	/*	CONT.L		*/

		DO;	/*	5: REWIND	*/			/*	REW.L			*/
			CALL REWIND.SEQUENCER;		/*	DO IT IN A PROCEDURE	*/
			RETURN;							/*	DID DISPLAY.SEQUENCER.STATUS IN PROC	*/
		END;

		DO;	/*	6: FAST FORWARD	*/	/*	FF.L			*/
			CALL FAST.FORWARD.SEQUENCER;	/*	DO IT IN A PROCEDURE	*/
			RETURN;							/*	DID DISPLAY.SEQUENCER.STATUS IN PROC	*/
		END;

		CALL PROCESS.ERASE.BUTTON;		/*	7: ERAS.L	*/

		DO;	/*	8: END LOOP FUNCTION	*/

			IF NEW.PAN&(HELD.STARTLOOP.BUTTON<>0)
			THEN DO;
				TROUT.TRK#=(-1);						/*	RESET FOR OVERALL LOOP DISPLAY	*/
				CALL SET.LOOP.PARMS.TO.OVERALL;	/*	LOAD OVERALL LOOP PARMS INTO GLOBALS	*/
				CALL DISPLAY.TRACK.BUTTONS;		/*	TURN OFF TRACK LIGHTS	*/
				CALL DISPLAY.PAR;						/*	FORCE REDISPLAY OF PARMS	*/
			END;

			ELSE DO;										/*	TOGGLE STATE OF LOOPS	*/
				IF NUM.OF.HELD.TRACK.BUTTONS<>0	/*	HOLDING A TRK BUTTON	*/
				THEN CALL TOGGLE.ILP;				/*	TOGGLE STATE OF ILPS	*/
				ELSE CALL TOGGLE.OVERALL.LOOP;	/*	TOGGLE STATE OF OVERALL LOOPS	*/
			END;

		END;

		DO;					/*	9: TRANSPOSE	*/
			/*	HOLD CLICK; PRESS TRANSPOSE: SET UP FOR CLICK VALUE CHANGE	*/

			IF (HELD.CLIK.BUTTON != false) {
				TOGGLE.CLICKON=FALSE;	/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
				if ((/*Tempo.Map.Ptr|*/Meter.Map.Ptr) != null)
				THEN DO;									/*	SELECT CLICK VALUE PARM	*/
					CALL CLEAR.PARAMETERS;			/*	GET RID OF CLICK RATE PARM	*/
					CALL ADD.PARM.TO.ACTIVE.LIST(CLICKVAL.L-PAR.L,CLICKVAL.L-PAR.L);
					CALL DISPLAY.PAR;
					CALL DISPLAY.PARAMETER.BUTTONS;
					CLICK.TRACK.FUNCTION = 0;		/*	Clear track number and selection	*/
				END;
				//	ELSE DO NOTHING
			}

			/*	HOLD TRACK BUTTON; PRESS TRANSPOSE: TOGGLE TRACK XPOS STATE	*/

			ELSE IF NUM.OF.HELD.TRACK.BUTTONS<>0 THEN DO;

				ALLOW.TRACK.GROUP.DEFINE = FALSE;		/*	DISALLOW GROUP DEFINE WHILE CHANGING	*/
				CLEAR.DISPLAY();								/*	REMOVE CREATING...							*/

				DO I=0 TO NUM.TRACK.BUTTONS - 1;
					WRITE(MAM)=TBUT.PTR;
					WRITE(MAL)=I;
					J=READ(MD)&255;							/*	GET ABS TRACK #	*/

					IF ((READ(MD)&B.HELD.TRK)<>0)			/*	BUTTON HELD		*/
					{
						WRITE(MAM) = TRK.HEAD;
						WRITE(MAL) = J;

						IF (READ(MD) == 0)					/*	IF TRACK HEAD DOES EXIST, CREATE ONE	*/
						{
							IF (ALLOCATE.TRK.HEADER(J) == 0)
							{
								CALL DISPLAY.ERR(14);		/*	NOT ENOUGH ROOM IN EXT MEMORY				*/
								CALL NOMEM.ERROR;				/*	NOT ENOUGH EXTERNAL MEMORY					*/
							}
						}

						WRITE(MAM) = TRK.HEAD;
						WRITE(MAL) = J;

						IF (READ(MD) != 0)					/*	SHOULD HAVE TRK HEAD BY  NOW				*/
						{
							TRK.HEAD.LOOKUP(J, THD.IGNORE);
							WRITE(MD) = READ(MD) XOR THD.IGNORE.XPOS;
							COMPUTE.ACTIVE.TRKS();
						}

						NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;	/*	NEW CONSTANTS AFTER CHANGING XPOS	*/
					}
				END;
			END;

			/*	ELSE JUST STEP XPOS STATE	*/

			ELSE DO;
				XPOS=XPOS+1;
				IF XPOS=3 THEN XPOS=0;
			END;
		END;

		/*	$PAGE	*/

		DO;	/*	10: BOUNCE TRACKS (BOUNCE.L)	*/
			IF (TGRP != 0) ABORT.BOUNCE.SMT.SKT();			/*	FINISH OUT TRACK GROUP MODE ON BOUNCE BUTTON PRESS	*/
			IF (SMT\SKT\CHAIN\TPAN\TGRP)=0 THEN DO;		/*	ONLY RECOGNIZE WHILE OTHERS IDLE	*/
				IF BOUNCE<>0 THEN DO;							/*	SECOND HIT	*/
					CALL ABORT.BOUNCE.SMT.SKT;					/*	RESET VARIABLES IN CASE BOUNCE IN PROGRESS	*/
					RECD.JUST=RECD.JUST XOR 1;					/*	TOGGLE JUSTIFIED RECORD	*/
				END;
				ELSE DO;												/*	FIRST HIT - COULD BE REAL BOUNCE	*/
					CALL ABORT.BOUNCE.SMT.SKT;					/*	RESET VARIABLES	*/
					BOUNCE=1;										/*	THEN SET TO ONE	*/
					TRACK.STATE = TRACK.STATE.SELECT.BOUNCE.SOURCE;	/*	NEXT TRACK LIGHT STORE FIRST TRACK	*/
					IF (HELD.PSEL.BUTTONS<>0)
					THEN DO;											/*	PARTIAL BUTTON HELD - PREPARE FOR FRAME BOUNCE	*/
						K=0; L=0;
						DO WHILE (K<NUM.PARTIALS);				/*	CHECK EACH ONE	*/
							IF (HELD.PSEL.BUTTONS&BITS(L))<>0
							THEN DO;									/*	THIS ONE	*/
								BOUNCE.PTR=FR.PTRS(K);			/*	LOOK UP POINTER TO FRAME	*/
								SPECIAL.BOUNCE=0;					/*	ASSUME NORMAL BOUNCE	*/
								IF C.FRAME(K)=0 THEN DO;		/*	MEANS BOUNCE FROM FRAME 0	*/
									SPECIAL.BOUNCE=1;
								END;
							END;
							K=K+1; L=L+1;
						END;
					END;
				END;

				IF NEW.PAN=0 THEN DO;		/*	USE BOUNCE BUTTON TO CONTROL CRM ON OLD KBD	*/
					CALL CLEAR.PARAMETERS;	/*	CLEAR OTHER PARAMETER BUTTONS FOR CHANGING CRM	*/
					ACTIVE.PARMS(0)=1;		/*	SET UP FOR CHANGE OF CLICK RATE MULTIPLIER	*/
					ACTIVE.PARMS(1)=(CRM.L-PAR.L)+SHL(CRM.L-PAR.L,8);	/*	STORE ON STACK	*/
					CALL DISPLAY.PAR;			/*	DISPLAY IT?	*/
				END;

				CALL DISPLAY.BOUNCE.AND.RECD.JUST.BUTTONS;
				CALL DISPLAY.TRACK.BUTTONS;	/*	THESE WILL BLINK NOW SINCE BOUNCE<>0	*/

				#if (inc.voice.output)
					IF (NEW.PAN=0) & (D42.OUTPUT.HAPPENING=0) THEN DO;		/*	MARK BUSY FOR A MOMENT	*/
						D42.OUTPUT.HAPPENING=1;										/*	MUST HOLD BOUNCE FOR		*/
						SPEAK.TIME=REAL.MILLISECONDS-1700;						/*	300 MS TO GET CLICK M	*/
					END;
				#endif
			END;
		END;

		DO;	/*	11: SMT.L: SELECT MEMORY TIMBRE	*/
			IF (TGRP != 0) ABORT.BOUNCE.SMT.SKT();			/*	FINISH OUT TRACK GROUP MODE ON CHAIN BUTTON PRESS	*/
			IF (CHAIN\BOUNCE\SKT\TPAN\TGRP)=0 THEN DO;	/*	ONLY RECOGNIZE WHILE OTHERS IDLE			*/
				CALL ABORT.BOUNCE.SMT.SKT;						/*	KILL LIGHTS IF SMT ALREADY IN PROGRESS	*/
				SMT=1;												/*	INDICATE SMT IN PROCESS						*/
				TRACK.STATE=TRACK.STATE.SELECT.SMT.DEST;	/*	SELECT MEMORY TIMBRE STATE					*/
				CALL DISPLAY.SMT.SKT.BUTTONS;					/*	DISPLAY SMT BUTTON							*/
				CALL DISPLAY.TRACK.BUTTONS;					/*	THESE WILL BLINK								*/
			END;

		END;

		DO;	/*	12: SELECT KEYBOARD TIMBRE	*/

			IF (SMT<>0) AND (RECALL.STATE=3)
			THEN DO;								/*	MOVE FROM CLAVIER TO TRACK	*/
				CALL COPY.TIMBRE(0,TIMB.DEST);
				CALL ABORT.BOUNCE.SMT.SKT;	/*	INDICATE END OF THIS OPERATION	*/
			END;
			ELSE IF ((CHAIN\SPLT\SMT\BOUNCE\TPAN)=0)
			THEN DO;								/*	DO SKT IF SMT, BOUNCE ARE IDLE, AS WELL AS SPLIT	*/
				IF (TGRP != 0) ABORT.BOUNCE.SMT.SKT();		/*	FINISH OUT TRACK GROUP MODE ON BUTTON PRESS	*/
				IF HELD.MIDI.BUTTON<>0 THEN DO;
					IF UPPER.DISP=MIDISKT.DISP					/*	TOGGLE IF DISPLAYED	*/
					THEN MIPGM.ON.SKT.CONTROL=MIPGM.ON.SKT.CONTROL XOR 1;
					IF NEW.PAN THEN DO;							/*	MAKES SENSE HERE ONLY	*/
						CALL CLEAR.DISPLAY;
						IF MIPGM.ON.SKT.CONTROL=0 THEN DO;
							CALL EMIT.STRING(0,'Program Change  On SKT: Off');
						END;
						ELSE DO;
							CALL EMIT.STRING(0,'Program Change  On SKT: On');
						END;
						BOTH.DISPLAY = 1;
						UPPER.DISP=MIDISKT.DISP;
						SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/
						BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/
					END;
				END;
				ELSE CALL SKT.SPLT.SUB(0);				/*	USE SUBROUTINE TO SAVE CODE	*/
			END;

		END;	/*	OF SKT	*/


		/*	$PAGE	*/


		DO;	/*	13: EXT SYNC BUTTON	*/				/*	EXT.L													*/
			IF (((HELD.MIDI.BUTTON <> 0)				/*	HOLD MIDI, PRESS SMPTE, THEN EXT SYNC		*/
			&&   (MIDI.PARAM.ID == 1))
			||  ((UPPER.DISP == (MIDI.L - PAR.L))	/*	OR STILL SHOWING MIDI CLOCK STYLE IN UPPER	*/
			&&   (MIDI.SYNC.IS.TC  != 0)				/*	MIDI TC ENABLE	*/
			&&   (MIDI.PARAM.ID == 1)))				/*	AFTER PRESSING SMPTE, OF COURSE!				*/
			{
				IF (LOWER.DISP== SMODE.DISP)			/*	IF SMPTE MODE IS DISPLAED	*/
				{												/*	TOGGLE MODE						*/
					SM.MODE=SM.MODE+1;
					IF SM.MODE=5 THEN SM.MODE=0;
					CALL STOP.SEQUENCER;
					IF (SMPTE.ONOFF != 0)
						INIT.SMPTE();						/*	RE-INITIALIZE ON MODE CHANGE	*/
					WRITE(MAM)=BAS.PTR;
					WRITE(MAL)=SEQ.SMODE;
					WRITE(MD )=SM.MODE;
					NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;	/*	NEW CONSTANTS AFTER CHANGING SMPTE MODE	*/
					NEW.SEQ.INFO = NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
					DISPLAY.SMODE(SM.MODE);				/*	DISPLAY MIDI TIME CODE IN LOWER HALF			*/
				}
				ELSE IF (MIDI.SYNC.IS.TC != 0)		/*	IF SYNC MODE IS TIME CODE						*/
					DISPLAY.SMODE(SM.MODE);				/*	DISPLAY MIDI TIME CODE IN LOWER HALF			*/
				ELSE											/*	ELSE REMOVE MODE DISPLAY							*/
					CLEAR.LOWER();
			}

			ELSE IF (HELD.SMPTE.BUTTON<>0)			/*	SMPTE & EXT SYNC TOGETHER	*/
			THEN CALL TOGGLE.SMPTE;						/*	TOGGLE SMPTE MODE	*/

			ELSE IF (HELD.MIDI.BUTTON<>0)				/*	MIDI & EXT SYNC: TURN		*/
			THEN DO;											/*	MIDI SYNC ON/OFF				*/
				IF  (MAX.MIDI.CHAN     == 0)						/*	NO ORIGINAL MIDI HARDWARE	*/
				AND (MAX.MIDINET.CHAN  == 0)						/*	NO MIDINET SYSTEM PRESENT	*/
				AND (interp_is_running == 0)						/* NO OMS MIDI */
				THEN CALL DISPLAY.ERR(40);							/*	MIDI IS NOT AVAILABLE	*/

				ELSE IF ((LOWER.DISP != EXT.DISP  )				/*	IF SYNC MODE NOT DISPLAYED	*/
				&&			(LOWER.DISP != SMODE.DISP))			/*	THEN BEGIN BY DISPLAYING IT	*/
				{
					IF (SMPTE.ONOFF<>0)
						THEN CALL DISPLAY.SMODE(SM.MODE);
					ELSE
						CALL DISPLAY.EXT.SYNC.MODE(EXT.CLOCK.MODE);
				}

				ELSE DO;													/*	ELSE CHANGE MODE	*/
					CALL STOP.RECD.MOVE.PLAY;						/*	HAVE TO STOP MOVEMENT FIRST	*/
					TIMING.CLOCK.ENABLE=0;							/*	DISABLE MIDI CLOCKS	*/

					interp_init_oms_midi_sync(0);					/* Trash any OMS MIDI Sync Info */

					IF (SMPTE.ONOFF <> 0)							/*	IF SYNCED TO SMPTE, BEGIN BY	*/
						TOGGLE.SMPTE.STATE();						/*	TURNING SMPTE SYNC OFF			*/

					IF EXT.CLOCK.MODE<3 THEN DO;					/*	FROM INTERNAL (OR WAS SMPTE) TO MIDI IN	*/
						IF (MAX.MIDI.CHAN<>0)						/*	OK TO USE MIDI INPUT	*/
						THEN EXT.CLOCK.MODE=3;						/*	GO TO MIDI INPUT SYNC	*/
						ELSE IF (MAX.MIDINET.CHAN<>0)
						THEN EXT.CLOCK.MODE=5;						/*	GO TO MIDINET SYNC	*/
						ELSE IF (interp_is_running<>0)
						THEN EXT.CLOCK.MODE=6;						/*	GO TO OMS MIDI SYNC	*/
						ELSE EXT.CLOCK.MODE=0;						/* FAILED */
					END;
					ELSE IF (EXT.CLOCK.MODE=3) THEN DO;			/*	CURRENTLY SYNCED TO INPUT JACK	*/
						IF (MAX.MIDI.CHAN>4)							/*	AND OK TO USE AUX JACK	*/
						THEN EXT.CLOCK.MODE=4;						/*	GO TO MIDI AUX SYNC	*/
						ELSE IF (MAX.MIDINET.CHAN<>0)
						THEN EXT.CLOCK.MODE=5;						/*	GO TO MIDINET SYNC	*/
						ELSE IF (interp_is_running<>0)
						THEN EXT.CLOCK.MODE=6;						/*	GO TO OMS MIDI SYNC	*/
						ELSE EXT.CLOCK.MODE=0;						/* FAILED */
					END;
					ELSE IF (EXT.CLOCK.MODE=4)	THEN DO;			/*	CURRENTLY SYNCED TO AUX	*/
						IF (MAX.MIDINET.CHAN<>0)
						THEN EXT.CLOCK.MODE=5;						/*	GO TO MIDINET SYNC	*/
						ELSE IF (interp_is_running<>0)
						THEN EXT.CLOCK.MODE=6;						/*	GO TO OMS MIDI SYNC	*/
						ELSE EXT.CLOCK.MODE=0;						/* FAILED */
					END;
					ELSE IF (EXT.CLOCK.MODE=5) THEN DO;			/* CURRENTLY SYNCED TO MIDINET */
						IF (interp_is_running<>0)
						THEN EXT.CLOCK.MODE=6;						/*	GO TO OMS MIDI SYNC	*/
						ELSE EXT.CLOCK.MODE=0;						/* FAILED */
					END;
					ELSE EXT.CLOCK.MODE=0;							/* ELSE RETURN FROM OMS MIDI SYNC TO INTERNAL */

					IF EXT.CLOCK.MODE=4								/*	NOW LISTENING TO THE AUX INPUT	*/
					THEN CALL INIT.MIDI.FIFO(MIDI.SUBSYS+1,4);	/*	REZERO THE INPUT PORT SINCE IT MAY CONTAIN GARBAGE	*/

					IF EXT.CLOCK.MODE=6								// if activating OMS midi sync, inform interp of our byte-pending flag
					THEN CALL interp_init_oms_midi_sync(addr(ANY.OMS.MIDI.SYNC.BYTES));

					CALL RESYNC.TIME.BASE;

					NEW.PRM.INFO=NEW.PRM.INFO\16;					/*	HAVE A CHANGE IN SYNC STATE	*/
					NEW.SEQ.INFO=NEW.SEQ.INFO\512;				/*	CHANGE IN EXT SYNC MODE		*/

					IF NEW.PAN<>0										/*	ONLY FOR NEW KBD	*/
					THEN CALL DISPLAY.EXT.SYNC.MODE(EXT.CLOCK.MODE);	/*	GIVE WINDOW DISPLAY	*/
				END;
			END;

			ELSE IF (HELD.RATE.BUTTON<>0)		/*	TOGGLE REPEAT/ARPEG MODE	*/
			THEN DO;
				EXT.REP.ARP=EXT.REP.ARP XOR 1;
				CALL DISPLAY.PAR;
			END;

			ELSE IF (HELD.CLIK.BUTTON<>0)		/*	CLICK HELD - TOGGLE EXT CLICK	*/
			THEN DO;
				IF CLICK.TRACK.MODE=3			/*	IF USING EXT CLICK	*/
				THEN CLICK.TRACK.MODE=0;		/*	THEN GO BACK TO INTERNAL CLICK	*/
				ELSE CLICK.TRACK.MODE=3;		/*	ELSE USE EXT CLICK NOW	*/
				CALL SELECT.PARAMETER(CLICK.L-PAR.L);	/*	SHOW USER DESIRED RESULT	*/
				NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;			/*	NEW SEQUENCER CONSTANTS ON CLICK TRACK MODE CHANGE	*/
				CALL STOP.RECD.MOVE.PLAY;					/*	STOP SEQUENCER			*/
				CALL DISPLAY.SEQUENCER.STATUS;			/*	TO GET CLICK CORRECT	*/
				CALL PLAY.INITIALIZE;						/*	SET UP CORRECT CLICKS	*/
				TOGGLE.CLICKON=FALSE;		/*	Don't toggle the click's on/off status on release of click button if we've been here.	*/
				CLICK.TRACK.FUNCTION = 0;	/*	Clear track number and selection	*/
			END;

			ELSE IF SMPTE.ONOFF<>0 THEN DO;	/*	SMPTE ACTIVE - TOGGLE SMPTE STATE	*/
				IF (LOWER.DISP=SMODE.DISP)		/*	IF SMPTE MODE IS DISPLAED	*/
				OR ((SMPTE.RATE<>0)&(UPPER.DISP=SMPTE.E.DISP))	/*	OR MISMATCH ERROR WHILE PLAYING	*/
				THEN DO;								/*	TOGGLE MODE	*/
					SM.MODE=SM.MODE+1;
					IF SM.MODE=5 THEN SM.MODE=0;
					CALL STOP.SEQUENCER;
					CALL INIT.SMPTE;				/*	RE-INITIALIZE ON MODE CHANGE	*/
					WRITE(MAM)=BAS.PTR;
					WRITE(MAL)=SEQ.SMODE;
					WRITE(MD )=SM.MODE;
					NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;	/*	NEW CONSTANTS AFTER CHANGING SMPTE MODE	*/
					NEW.SEQ.INFO = NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
				END;
				CALL CLEAR.PARAMETERS;			/*	CLEAR OTHER PARAMETER BUTTONS FOR CHANGING SYNC DELAY	*/
				ACTIVE.PARMS(0)=1;				/*	SET UP FOR SMPTE DISPLAY	*/
				ACTIVE.PARMS(1)=(SMPTE.L-PAR.L)+SHL(SMPTE.L-PAR.L,8);	/*	STORE ON STACK	*/
				CALL DISPLAY.PARAMETER.BUTTONS;		/*	LIGHT/BLINK SMPTE BUTTON	*/
				IF NEW.PAN THEN CALL DISPLAY.PAR;	/*	DISPLAY PARAMETER IN UPPER ONLY IF NEW KEYBOARD	*/
				CALL DISPLAY.SMODE(SM.MODE);			/*	DISPLAY NEW MODE	*/
			END;

			ELSE DO;											/*	NORMAL EXT SYNC (NON-SMPTE)	*/
				IF EXT.CLOCK.MODE<3 THEN DO;			/*	NOT SYNCHED TO MIDI	*/
					IF (EXT.CLOCK.MODE<>2)				/*	IF NOT CURRENTLY MODE 2	*/
					OR (UPPER.DISP=SDELAY.L-PAR.L)	/*	OR SYNC DELAY IS DISPLAYED	*/
					THEN DO;									/*	TOGGLE STATE	*/
						CALL STOP.RECD.MOVE.PLAY;		/*	HAVE TO STOP MOVEMENT FIRST	*/
						EXT.CLOCK.MODE=EXT.CLOCK.MODE+1;	/*	BUMP AND WRAP	*/
						IF EXT.CLOCK.MODE=3 THEN EXT.CLOCK.MODE=0;
						NEW.SEQ.INFO=NEW.SEQ.INFO\512;	/*	CHANGE IN EXT SYNC MODE		*/
						CALL RESYNC.TIME.BASE;			/*	SET UP CORRECT SYNC PULSE TIMING WHEN CHANGING STATES	*/
					END;
					CALL CLEAR.PARAMETERS;				/*	CLEAR OTHER PARAMETER BUTTONS FOR CHANGING SYNC DELAY	*/
					IF EXT.CLOCK.MODE=2 THEN DO;		/*	DISPLAY DELAY	*/
						ACTIVE.PARMS(0)=1;				/*	SET UP FOR CHANGE OF SYNC DELAY	*/
						ACTIVE.PARMS(1)=(SDELAY.L-PAR.L)+SHL(SDELAY.L-PAR.L,8);	/*	STORE ON STACK	*/
						CALL DISPLAY.PAR;					/*	CAUSES DISPLAY OF SDELAY ON EXT.CLK BUTTON PRESS	*/
					END;
				END;

				IF NEW.PAN														/*	ONLY FOR NEW KBD	*/
				THEN CALL DISPLAY.EXT.SYNC.MODE(EXT.CLOCK.MODE);	/*	GIVE WINDOW DISPLAY	*/
			END;

		END;


		IF NEW.PAN THEN DO;		/*	14: JUSTIFY BUTTON	*/
			RECD.JUST=RECD.JUST XOR 1;	/*	TOGGLE JUSTIFIED RECORDING MODE	*/
			CALL CLEAR.PARAMETERS;
			IF RECD.JUST<>0 THEN DO;
				CALL ADD.PARM.TO.ACTIVE.LIST(CRM.L-PAR.L,CRM.L-PAR.L);
				CALL DISPLAY.PAR;			/*	DISPLAY NEW PARAMETER	*/
			END;
			ELSE CALL EMIT.STRING(0,'JUSTIFY DISABLED');
			CALL DISPLAY.BOUNCE.AND.RECD.JUST.BUTTONS;
		END;


		IF NEW.PAN THEN DO;		/*	15: START LOOP BUTTON (NEW KBD ONLY)	*/

			IF NUM.OF.HELD.TRACK.BUTTONS<>0
			THEN DO;
				CALL SET.TROUT.TRK#;				/*	GET TROUT.TRK# SET CORRECTLY	*/
				CALL SET.LOOP.PARMS.TO.ILP;	/*	COPY ILP TIMES INTO LOOP PARMS	*/
			END;

			/*	SEARCH THROUGH ACTIVE PARM LIST. IF LOOP START OR	*/
			/*	LOOP END SELECTED THEN STEP TO NEXT PARM, ELSE		*/
			/*	RESELECT THE LAST SELECTED PARM							*/

			J=0;
			DO I=1 TO ACTIVE.PARMS(0);	/*	SEE IF ALREADY ON LIST	*/
				IF (ACTIVE.PARMS(I)&255)=(LOOP.L-PAR.L) THEN J=1;
			END;

			IF UPPER.DISP=(LOOP.L-PAR.L)
			THEN DO;	/*	ALREADY BEING DISPLAYED, STEP TO NEXT LOOP PARM	*/
				LAST.LOOP.PARM=LAST.LOOP.PARM+1;
				IF LAST.LOOP.PARM=3 THEN LAST.LOOP.PARM=0;
			END;

			IF J=0 THEN DO;
				CALL CLEAR.PARAMETERS;	/*	GET RID OF CURRENTLY ACTIVE PARS	*/
				CALL ADD.PARM.TO.ACTIVE.LIST(LOOP.L-PAR.L,LOOP.L-PAR.L);
			END;

			CALL DISPLAY.PAR;
			CALL DISPLAY.TRACK.BUTTONS;
			CALL DISPLAY.PARAMETER.BUTTONS;
		END;


		DO;	/*	16: CHAIN BUTTON	*/
			IF (TGRP != 0) ABORT.BOUNCE.SMT.SKT();						/*	FINISH OUT TRACK GROUP MODE ON CHAIN BUTTON PRESS	*/
			IF (SMT\SKT\BOUNCE\TPAN\TGRP)=0 THEN DO;
				IF CHAIN=0 THEN DO;
					CALL ABORT.BOUNCE.SMT.SKT;								/*	RESET VARIABLES	*/
					CALL CLEAR.PARAMETERS;									/*	GET RID OF CURRENTLY ACTIVE PARS	*/

					CHAIN=1;														/*	THEN SET TO ONE	*/
					TRACK.STATE=TRACK.STATE.SELECT.BOUNCE.SOURCE;	/*	NEXT TRACK LIGHT STORE FIRST TRACK	*/
				END;

				CALL ADD.PARM.TO.ACTIVE.LIST(CHAIN.L-PAR.L,CHAIN.L-PAR.L);
				CALL DISPLAY.BOUNCE.AND.RECD.JUST.BUTTONS;	/*	ALSO LIGHTS CHAIN BUTTON	*/
				CALL DISPLAY.TRACK.BUTTONS;	/*	FLASH TRK BUTTONS	*/
				CALL DISPLAY.PAR;
			END;
		END;

		DO;	/*	17: INSERT BUTTON	*/
			IF UPPER.DISP=(INSERT.L-PAR.L)
			THEN EDIT.DISP.MODE=EDIT.DISP.MODE XOR 1;	/*	TOGGLE BETWEEN END TIME & LENGTH	*/

			CALL CLEAR.PARAMETERS;	/*	GET RID OF CURRENTLY ACTIVE PARS	*/
			CALL ADD.PARM.TO.ACTIVE.LIST(INSERT.L-PAR.L,INSERT.L-PAR.L);
			CALL DISPLAY.PAR;
			CALL DISPLAY.PARAMETER.BUTTONS;
		END;


		DO;	/*	18: DELETE BUTTON	*/
			IF UPPER.DISP=(DELETE.L-PAR.L)
			THEN EDIT.DISP.MODE=EDIT.DISP.MODE XOR 1;	/*	TOGGLE BETWEEN END TIME & LENGTH	*/

			CALL CLEAR.PARAMETERS;	/*	GET RID OF CURRENTLY ACTIVE PARS	*/
			CALL ADD.PARM.TO.ACTIVE.LIST(DELETE.L-PAR.L,DELETE.L-PAR.L);
			CALL DISPLAY.PAR;
			CALL DISPLAY.PARAMETER.BUTTONS;
		END;

		DO;	/*	19: TRACKPAN.L	*/
			IF (TGRP != 0) ABORT.BOUNCE.SMT.SKT();				/*	FINISH OUT TRACK GROUP MODE ON TRACK PAN BUTTON PRESS	*/

			TIME.OF.TPAN.PRESS = REAL.MILLISECONDS;			/*	PUBLISH TIME OF PRESS IN ALL CASES						*/
			ANY.MISC.FUNCTIONS = TRUE;								/*	AND START TIMER FOR HOLD FOR 2 SECONDS					*/
							
			IF ((CHAIN\SMT\SKT\BOUNCE\TGRP)=0)					/*	DO TPAN IF SMT, BOUNCE ARE IDLE, AS WELL AS GROUPS	*/
			{
				IF (TPAN == 3)											/*	IF ALREADY IN GROUP RECALL MODE, EXIT					*/
				{
					ABORT.BOUNCE.SMT.SKT();							/*	STOP ON SECOND PRESS...										*/
				}

				ELSE IF (TPAN == 1)									/*	IF ALREADY SHOWING BASIC TPAN, SHOW GROUPS			*/
				{
					TPAN			= 3;									/*	BLINK IT & PREP FOR RECALL OF GROUP						*/
					TRACK.STATE	= TRACK.STATE.RECALL.GROUP.TRACKS;

					CLEAR.PARAMETERS    ();							/*	GET RID OF CURRENTLY ACTIVE PARS	*/
					PRESENT.TPAN.DISPLAY();							/*	PRESENT TRACK PAN DISPLALY			*/

					DISPLAY.SMT.SKT.BUTTONS();						/*	DISPLAY TPAN BUTTON			*/
					DISPLAY.TRACK.BUTTONS  ();						/*	THESE WILL BLINK				*/
				}

				ELSE
				{
					CALL ABORT.BOUNCE.SMT.SKT;						/*	KILL LIGHTS IF TPAN ALREADY IN PROGRESS	*/

					TPAN			= 1;										/*	INDICATE SMT IN PROCESS		*/
					TRACK.STATE	= TRACK.STATE.SELECT.TPAN.ROW;	/*	SELECT ROW FOR TRACK PAN	*/

					DISPLAY.SMT.SKT.BUTTONS();						/*	DISPLAY SMT BUTTON		*/
					DISPLAY.TRACK.BUTTONS  ();						/*	THESE WILL BLINK			*/

					CLEAR.PARAMETERS    ();							/*	GET RID OF CURRENTLY ACTIVE PARS	*/
					PRESENT.TPAN.DISPLAY();							/*	PRESENT TRACK PAN DISPLALY			*/
				}
			}
		END;

	END;	/*	OF DO CASE	*/

	CALL DISPLAY.SEQUENCER.STATUS;	/*	SET UP SEQUENCER DISPLAY	*/

END SEQUENCER.BUTTON;
