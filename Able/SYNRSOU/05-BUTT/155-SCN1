/* :SYNRSOU:05-BUTT:155-SCN1  $TITLE  ROUTINES TO SCAN ANALOG INPUT DATA AND BUTTON PANEL */

/*
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
2000/10/06 - TY  - Added support for mod wheel proxy function
1998/07/09 - TY  - Commented out Pseudo-log function used for RTE inversion,
						 and replaced it with linear inversion.
1991/08/09 - PF  - Fix VK portamento foot switch
1991/05/17 - PF  - record MIDI controllers at correct sequence time
1991/01/09 - PF  - various bug fixes for sequencer and MIDInet
1990/11/06 - PF  - FIX MIDI RTES RECORD BUG
1990/10/15 - CJ  - IMPROVED MOD WHEEL HYSTERESIS TO FIX RTE BUGS
1990/09/06 - TSS - ADDED CODE TO USE PRESSURE VERSION INFORMATION
1990/08/27 - PF  - Support all MIDI controllers
1990/05/16-TSS,DGM-FIXED KEYBOARD UNPLUGGED SCANNING BUG
1990/03/14 - TSS - COMMENT OUT GLIDESWITCH CODE FOR NOW
1989/03/09 - PF  - Increase MAX.INPUTS to 128
1989/06/05 - TSS - ADDED CODE TO READ PRESSURE MAPS FROM DISK IN RESTORE.POWER
1989/03/16 - TSS - Changed USE.PROTOCOL to INC.PRO
1989/03/14 - PF  - Changed use of NEW.RTES.BIT to R.LOOK
1988/10/19 - TSS - changed inc.protocol to use.protocol
1988/10/13 - TSS - MINOR CLEANUP OF POWER.OFF LOGIC IN SCANDATA
1988/09/30 - TSS - ADDED CODE TO PICK UP CLAVIER KNOB EMULATION INFO
1988/04/12 - PF  - MODIFIED CODE TO HANDLE MULTI TRACK RTES
1988/04/12 - PF  - ADDED THD.LIVE.RTES TO TRK HEADER
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1987/10/13 - LPG - ALTERED POWER ON/OFF CODES -- ADDED TRANSITION STATE
1987/09/03 - MWH - FIX MIDI BUG: NOTES NOW SOUND EVEN IF KEYBOARD UNPLUGGED
1986/10/30 - TS  - EXPERIMENTED WITH MIDI ECHO FEATURE
1986/08/25 - TS  - PUT IN THD.ACTIVE.MIDI.RTES I/O FILTERING CODE
1986/07/15 -CJ,TS- CHANGES TO MIDI OPERATION
1986/05/15 - "official" creation of release-M modules
*/

/* THE SYNCLAVIER PROGRAM SCANS DATA FROM SEVERAL INPUT DEVICES.  THESE
	INCLUDE THE CONTROL PANEL, CLAVIER, KNOB, PEDALS, SWITCHES, ETC.
	THE FOLLOWING ROUTINE SCANS ALL OF THE INPUT DATA AND STORES THEM
	IN GLOBAL VARIABLES FOR LATER PROCESSING.  ADDITIONALLY, MIDI CONTROL
	CHANGES ARE PROCESSED HERE AND SYNCLAVIER INPUTS WHICH CHANGE WILL
	CAUSE UPDATES TO THE MIDI OUTPUT PORT TO BE GENERATED. */

/* THE SCAN ROUTINE CALLS IO PRIMITIVES TO READ INPUT SIGNALS FROM THE
	BUTTONS AND KNOBS.  (ANALOG INFO RETURNED FROM PRIMITIVES IN RAW.XXX.POS).
	RAW INPUT DATA IS MASSAGED BY SCAN INTO XXX.DELTA. */

DCL TOGGLE FIXED PUBLIC;    /* FLAG TO SCAN BUTTONS EVERY OTHER TIME TO REDUCE BOUNCING & COMPUTE LOAD */

/* BASES FOR CENTERRED INPUTS: */

DCL RAW.KNOB.BASE   FIXED PUBLIC;  /* NEUTRAL POSITION OF KNOB               */
DCL RAW.RIBBON.BASE FIXED;         /* NEUTRAL POSITION OF RIBBON - ONLY VALID IF ACTIVE */
DCL RAW.PWHEEL.BASE FIXED;         /* NEUTRAL POSITION OF PITCH WHEEL/(PBI ON ORIGINAL KEYBOARD) */

/* VARIABLES USED FOR NEW KEYBOARD ONLY: */

DCL PREV.PEDAL1.POS FIXED;
DCL PREV.PEDAL2.POS FIXED;
DCL PREV.PWHEEL.POS FIXED;
DCL FILT.PWHEEL.POS FIXED;
DCL PREV.MWHEEL.POS FIXED;
DCL FILT.MWHEEL.POS FIXED;
DCL PREV.BREATH.POS FIXED;
DCL PREV.RIBBON.POS FIXED;
DCL PREV.REP        FIXED;
DCL PREV.ARP        FIXED;
DCL PREV.GLIDE      FIXED;

/* VARIABLES USED FOR BOTH KEYBOARDS:    */

DCL KNOB.DELTA												FIXED PUBLIC; /* CURRENT POSITION OF KNOB FROM BASE */
DCL CLAVIER.EMULATION.KNOB.DELTA						FIXED PUBLIC; /* PICK UP POTENTIAL SETTING */
DCL RIBBON.RELEASE										FIXED PUBLIC; /* SET TRUE FOR RIBBON RELEASE         */
DCL RIBBON.AMOUNT											FIXED PUBLIC; /* AMOUNT OF DEFLECTION BEFORE RELEASE */

DCL (NEW.GVOL,NEW.GRTE)									FIXED PUBLIC; /* SET TRUE IF CHANGE IN GUITAR INPUT KNOB */

DCL RTE.CHANGEBITS				  						FIXED PUBLIC; /* BITS SET FOR ENTRIES OF RTE.CHANGETABLE */
DCL RTE.CHANGETABLE(((MAX.INPUTS+15)/16)-1)		FIXED PUBLIC; /* BITS ARE SET FOR CHANNELS WITH CHANGING RTE'S FOR RECORD */
DCL RTE.CHANGES    (MAX.INPUTS-1)	   			FIXED PUBLIC; /* BITS ARE SET FOR CHANGING RTE'S WHICH NEED TO BE RECORDED */

DCL (NEW.INFO)												FIXED PUBLIC; /* SET TRUE ON CHANGE OF ANY RTE DATA */
DCL (NEW.TOGGLES)											FIXED PUBLIC; /* ON CHANGE OF FOOT SWITCH/TOGGLES */
DCL SWITCHBITS(MAX.INPUTS-1)							FIXED PUBLIC; /* PACKED BITS OF FOOT SWITCH BITS */

DCL AMOUNT													FIXED PUBLIC; /* AMOUNT TO CHANGE KNOB PARAMETER (SEE 'UPDATE') */

/* $SUBTITLE  DESCRIPTION OF FIFO SCHEME USED TO UPDATE RTE INPUTS */

/* IN ORDER TO MINIMIZE CODE DUPLICATION AND TO REDUCE THE OVERALL COMPUTER
	LOAD WHILE PROCESSING REAL-TIME CONTROLLER INPUTS, THE FOLLOWING FIFO
	BUFFER SCHEME HAS BEEN IMPLEMENTED:

	1.	EACH TIME THE PROGRAM SCANS THROUGH THE REAL-TIME INPUTS TO LOOK
		FOR CHANGES THE FOLLOWING THINGS TAKE PLACE FOR EACH INPUT:

		A.	A DEAD-BAND OR HYSTERESIS FILTER IS APPLIED TO ALL
			SYNCLAVIER RAW INPUTS.
		B.	IF THE CURRENT SYNCLAVIER INPUT VALUE DIFFERS FROM THE PREVIOUS
			VALUE, THE CANONICAL INPUT NUMBER (0-5) IS STORED IN A FIFO.
		C.	ANY CHANGE IN A SYNCLAVIER INPUT CAUSES A NEW MIDI CONTROL CHANGE
			TO OCCUR IF ANY MIDI SUBSYSTEMS ARE PRESENT AND THE INPUT IS
			CURRENTLY ROUTED TO SOME MIDI CONTROL NUMBER.
		D.	IF THE CORRESPONDING MIDI ANALOG INPUT HAS CHANGED (AS DETERMINED
			BY EXAMINING THE PROPER BIT OF MIDI.ANALOG.CHANGES(n)), THEN
			ITS CANONICAL INPUT NUMBER IS STORED IN THE FIFO.

	2.	AFTER THIS PROCESS IS FINISHED FOR ALL INPUTS, THE CONTENTS OF THE
		FIFO BUFFER ARE PROCESSED AS FOLLOWS:

		A.	THE NEXT INPUT NUMBER IS SCANNED FROM THE FIFO.
		B.	THE CURRENT SCALED SYNCLAVIER VALUE FOR THE INPUT IS ADDED
			TO THE CURRENT MIDI VALUE ON THE SAME INPUT.  THIS SUM IS
			THEN RESCALED.  IF THE NEW VALUE DIFFERS FROM THE VALUE STORED
			IN RTE.DATA() THEN A FLAG IS SET WHICH WILL EVENTUALLY CAUSE
			A BUNCH OF GLOBAL VARIABLES TO BE UPDATED.

	3.	LAST OF ALL, IF THE UPDATE SYSTEM RTE VARIABLES FLAG IS SET THEN
		UPDATE THE SYSTEM RTE VARIABLES, SO THAT RECORDING OF REAL-TIME
		EFFECTS OCCURS AND SO THAT THE SYNTHESIZERS WILL BE UPDATED TO
		REFLECT THE CHANGE IN THE REAL TIME CONTROLLER.
*/

/* $SUBTITLE  ROUTINE TO RESET VARS UPON POWER UP/RESET */

DCL NEW.PM           FIXED PUBLIC;     /* SET TRUE IF NEW PITCH/MOD WHEEL */
DCL MODHYST          FIXED;            /* HYSTERESIS VALUE TO USE         */
DCL ORK.KNOB.MISSING FIXED;

RESTORE.POWER:PROC PUBLIC SWAPABLE;    /* RE-MEASURE INPUT ITEMS ON POWER RESTORE */
	POWER.OFF=0;                        /* ALLOW SCANNING NEXT TIME */

   IF (NEW.ORK == 0)
      CALL SCAN.VKP.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS FOR INITIAL READINGS */
   ELSE
      CALL SCAN.ORK.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS FOR INITIAL READINGS */
      
   interp_delay_on_d3_write(true );
   disable;write(3)=0;write(3)=0;write(3)=0;enable;
   interp_delay_on_d3_write(false);
   
   IF (NEW.ORK == 0)
      CALL SCAN.VKP.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS FOR INITIAL READINGS */
   ELSE
      CALL SCAN.ORK.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS FOR INITIAL READINGS */
      
   // Get 0 if Sync3 and D160 is unplugged; get 255 if D160 disconnected from ORK
   if ((RAW.KNOB.POS == 0) || (RAW.KNOB.POS == 255)) {
      //RAW.KNOB.POS     = 128;
      //ORK.KNOB.MISSING = true;
   }

	RAW.KNOB.BASE   =RAW.KNOB.POS;      /* LOOK UP INITIAL ANALOG INPUTS */
	RAW.PWHEEL.BASE =RAW.PWHEEL.POS;    /* READ INITIAL PITCH BEND INPUT POSITION */
	PREV.PWHEEL.POS =RAW.PWHEEL.POS;    /* INITIALIZE PWHEEL HYSTERESIS FILTER */
	FILT.PWHEEL.POS =RAW.PWHEEL.POS;
	PREV.PEDAL1.POS=1000;               /* SO NEXT CALL TO SCAN SETS UP INVERTED INPUTS CORRECTLY */
	PREV.PEDAL2.POS=1000;
	PREV.MWHEEL.POS=1000;
	FILT.MWHEEL.POS=2000;
	PREV.BREATH.POS=1000;
	PREV.RIBBON.POS=1000;
	IF INC.CREG AND NEW.PAN AND (NEW.ORK == 0) THEN DO;
		DISABLE;                      /* FOR CHECK OF NEW PITCH/MOD WHEEL */
		WRITE(CREG)=1;                /* SELECT INPUTS         */
		WRITE(DREG)="200"\95;         /* REQUEST DATA FROM CH7 */
		WRITE(CREG)="40"\1;           /* WRITE BIT     */
		WRITE(CREG)=1;                /* END OF WRITE  */
		WRITE(CREG)="100"\1;          /* READ ANSWER   */
		IF (READ(DREG)&255)>=128      /* READ UNUSED ANALOG INPUT */
		THEN NEW.PM=1;                /* 255 = NEW MOD WHEEL      */
		ELSE NEW.PM=0;                /*   0 = OLD MOD WHEEL      */
		WRITE(CREG)=1;                /* REMOVE READ              */
		ENABLE;
	END;
	ELSE NEW.PM=0;                   /* NO HIGH RES PWHEEL ON OLD KBD */

	IF MIDI.THERE<>0 THEN CALL INIT.MIDI.SUBSYSTEMS; /* RESET MIDI SYSTEMS */

	IF NEW.PM THEN MODHYST = 3;      /* SET HYSTERESIS VALUE TO USE FOR    */
	ELSE           MODHYST = 1;      /* MOD WHEEL                          */

	IF (INC.KBD.MAPS) AND (PMAP.PTR<>0)
	THEN BEGIN;                       /* READ IN PRESSURE MAP & DO SOME MEASUREMENTS */
		DCL (I,J)    FIXED;
		DCL DEADBAND LIT '5';

		IF MAP.THERE <> 0 THEN DO;     /* WE HAVE OUR MAPS FILE */
			CALL LOAD.DATA (MAPDEV,MAPSEC,PRESSURE.CAL.DATA,PMAP.PTR,256); /* LOAD KBD SPECIFIC CALIBRATION INFO */

			J = 0;                      /* ASSUME MAP IS VALID */
			WRITE(MAM)=PMAP.PTR;
			DO I = 0 TO (NUM.KEYS-1);
				IF READ(MDI) IGT 255 THEN J = 1; /* MAP IS INVALID - SET TO TRIPP DEFAULT */
			END;
			IF J = 0 THEN DO;           /* MAP IS OK SO FAR */
				J = 1;                   /* ASSUME MAP IS ALL ZERO & INVALID */
				WRITE(MAM)=PMAP.PTR;
				DO I = 0 TO (NUM.KEYS-1);
					IF READ(MDI) <> 0 THEN J = 0; /* AT LEAST ITS NON ZERO */
				END;
				DO I=NUM.KEYS TO LOC.PRESSURE.SATURATION-1;
					IF READ(MDI) IGT 1 THEN J=1;  /* MAP IS INVALID - SET TO TRIPP DEFAULT */
				END;

				WRITE(MAM)=PMAP.PTR;
				WRITE(MAL)=LOC.PRESSURE.VERSION; /* CHECK PRESSURE VERSION OF MAP FILE */
				IF READ(MD)>DEFAULT.PRESSURE.VERSION /* RTP SOFTWARE IS OLDER THAN MAP - USER MIXING SW VERSIONS! */
				THEN J=1;                /* RESET MAP TO TRIPP KBD DEFAULT */
			END;
		END;
		ELSE J=2;                      /* NO MAP FILE AT ALL - ASSUME ORIGINAL KBD */

		IF J<>0 THEN DO;               /* SET UP DEFAULT CALIBRATION TABLE */
			IF J=1 THEN DO;
				LOAD 255-DEADBAND;       /* COMPUTE DEFAULT PRESSURE CALIBRATION VALUE */
				MUL DEFAULT.PRESSURE.SATURATION; MWAIT;
				DIV 100;
				I=RES+(REM IGE 50);
			END;
			ELSE I=225;                 /* ORIGINAL KBD SETTING: 225 = 90% OF 250 */

			WRITE(MAM) = PMAP.PTR;
			DO J = 0 TO (NUM.KEYS-1); WRITE(MDI)=I; END; /* SET MAP TO DEFAULTS */
			DO J = NUM.KEYS TO 255;   WRITE(MDI)=0; END; /* CLEAR REST OF SECTOR */

			WRITE(MAM) = PMAP.PTR;      /* SET PRESSURE CALIBRATION TABLE TO DEFAULT VALUES */
			WRITE(MAL)=LOC.PRESSURE.VERSION;
			WRITE(MD)=DEFAULT.PRESSURE.VERSION;    /* INIT TO CURRENT VERSION OF PRESSURE CALIBRATION SW */
			WRITE(MAL)=LOC.PRESSURE.SATURATION;
			WRITE(MD)=DEFAULT.PRESSURE.SATURATION; /* INIT TO DEFAULT SATURATION */
		END;

		WRITE(MAM)=PMAP.PTR;       /* READ IN CURRENT VERSION NUMBER */
		WRITE(MAL)=LOC.PRESSURE.VERSION;

		IF READ(MD)=0 THEN DO;     /* THIS IS ORIGINAL MAP VERSION, SO UPGRADE IT */
			WRITE(MAM)=PMAP.PTR;
			WRITE(MAL)=LOC.PRESSURE.VERSION;
			WRITE(MD)=1;            /* UPGRADE VERSION 0 MAP TO VERSION 1     */
			WRITE(MAL)=LOC.PRESSURE.SATURATION;
			WRITE(MD)=90;           /* VERSION 0 MAPPED 1LB TO 90% SATURATION */
		END;

		IF MAP.THERE <> 0 THEN DO;     /* WE HAVE OUR MAPS FILE */
			CALL LOAD.DATA (MAPDEV,MAPSEC,PRESSURE.MAP,PMAP.PTR+2,256); /* LOAD PRESSURE TO VOLUME MAP */

			J = 0;                      /* ASSUME MAP IS VALID */
			WRITE(MAM)=PMAP.PTR+2;
			DO I = 0 TO 255;
				IF READ(MDI) IGT RTE.MAX THEN J = 1; /* MAP IS INVALID */
			END;
			IF J = 0 THEN DO;           /* MAP IS OK SO FAR */
				J = 1;                   /* ASSUME MAP IS ALL ZERO & INVALID */
				WRITE(MAM)=PMAP.PTR+2;
				DO I = 0 TO 255;
					IF READ(MDI) <> 0 THEN J = 0; /* AT LEAST ITS NON ZERO */
				END;
			END;
		END;
		ELSE J=1;

		IF J<>0 THEN DO;                         /* SET UP DEFAULT MAPPING */
			WRITE(MAM) = PMAP.PTR + 2;            /* POINT TO PRESSURE TO VOL MAP */
			DO J = 0 TO 255;
				I = J;
				IF I>RTE.MAX THEN I=RTE.MAX;       /* LIMIT TO RTE.MAX */
				LOAD I; MUL I; MWAIT; DIV RTE.MAX; /* USE SQUARE FUNCTION ON PRESSURE */
				WRITE(MDI)=RES;                    /* GET SQUARE FUNCTION, CURRENT VALUE */
			END;
		END;

		WRITE(MAM) = PMAP.PTR + 1;     /* SET UP TO BUILD PRESSURE BASELINE MAP */

		DO I = 0 TO NUM.KEYS-1;        /* CHECK THE BASELINE PRESSURE OVER ENTIRE KBD */
			IF  INC.CREG AND NEW.PAN    /* VK KEYBOARD BUILD      */
         AND (NEW.ORK == 0)          /* NO ORK ATTACHED        */
			AND (I > 8)                 /* KEY ACTUALLY EXISTS ON VK */
			THEN DO;                    /* SCAN PRESSURE     */
				DISABLE;                 /* AVOID KEYBOARD SCAN RIGHT HERE */
				WRITE(CREG)=1;           /* INDICATE KEYBOARD OPCODES */
				WRITE(DREG)="200"\(I-9); /* REQUEST DATA FOR THIS KEY */
				WRITE(CREG)="40"\1;
				WRITE(CREG)=1;
				WRITE(CREG)="100"\1;     /* PULSE_EXWR */
				J=READ(DREG)&"377";      /* EXTRACT PRESSURE */
				J = J + DEADBAND;        /* ADD A LITTLE FOR A DEADBAND */
				WRITE(CREG)=1;           /* REMOVE READ */
				ENABLE;                  /* ALLOW KEYBOARD SCAN NOW */
			END;
			ELSE J=0;                   /* ZERO PRESSURE FOR OLD KEYBOARD OR AFTER RELEASE */

			WRITE(MDI) = J;             /* SAVE IN TABLE */
		END;
	END;

END RESTORE.POWER;

/* $SUBTITLE  ROUTINE TO SCAN ALL INPUT DEVICES */

DCL LAST.SCAN.TIME		 FIXED;
DCL LAST.RTE.TIME			 FIXED;

SCANDATA:  PROC PUBLIC;          /* SCANS ALL INPUT DEVICES */
	DCL (H,I,J,K,L,PMODE) FIXED;
	DCL PREV.RIB.VAL		 FIXED;    /* PREVIOUS RIBBON VALUE       */
	DCL RIB.ACTIVE			 FIXED;    /* TRUE IF RIBBON ACTIVE       */
	DCL RIBBON.DELTA		 FIXED;    /* INTERNAL RIBBON POSITION    */
	DCL ACTIVE.MIDI.RTES	 FIXED;    /* LOCAL COPY OF THD.ACTIVE.MIDI.RTES FOR KBD TRK */
	DCL DO.ANALOG.SCAN	 BOOLEAN;  /* OK TO DO ANALOG SCAN        */
	DCL ORIGIN				 FIXED;    /* HOLDS INPUT CHANNEL NUMBER */
   DCL CHANGEBITS        FIXED;
	DCL CHANGETABLE		 FIXED;
	DCL CHAN.BIT			 FIXED;
	DCL (MSB,LSB)			 FIXED;
	DCL THP					 FIXED EXTERNAL;
	DCL TRK					 FIXED EXTERNAL;

	/* VARIABLES USED FOR MIDI/RTE FIFO BUFFER -- SEE COMMENTS ABOVE */
	DCL RTE.FIFO.LEN LIT '(6*17)';     /* 6 INPUTS * 17 SOURCES (SYNCLAVIER KBD & 16 MIDI CHANNELS) */
	DCL RTE.FIFO (RTE.FIFO.LEN) FIXED; /* THE FIFO BUFFER */
	DCL RTE.UPD						 FIXED; /* SET IF RTES TO UPDATE */

	/* THE FOLLOWING VARIABLE SHOULD BE DECLARED TO BE A FIXED-POINT ARRAY
	IF SUMMING OF SYNCLAVIER AND MIDI RTES IS DESIRED. OTHERWISE DECLARE
	IT LITERALLY TO BE MIDI.ANALOG.IN. THIS WILL GIVE YOU A MOST-RECENT
	CHANGE TYPE OF ALGORITHM. ALSO SET THE FOLLOWING COMPILATION FLAG.
	IF SYN.PLUS.MIDI=1 THEN SYNCLAVIER WILL BE SUMMED TO MIDI; IF ZERO,
	USES THE MOST RECENT CHANGE ALGORITHM. */

	/***** CAUTION!! CODE ADDED ON 04/12/88 WILL CERTAINLY CAUSE *****/
	/* PROBLEMS IF SYN.PLUS.MIDI IS EVER DEFINED TO BE 1.            */
	/* ie MIDI.ANALOG.IN IS NOW AN ARRAY IN EXTERNAL MEMORY          */

	/*DCL SYN.RTE.VALUE (R.RIBBON) FIXED;*/ /* HOLDS MOST RECENT DEAD-BAND FILTERED RTE VALUE FOR EACH INPUT */
	DCL SYN.RTE.VALUE LIT 'MIDI.ANALOG.IN';
	DCL SYN.PLUS.MIDI LIT '0';


	/* LITERAL WHICH SETS UP EXTERNAL MEMORY PTRS TO TRACK(n) HEADER     */
	/* WERE n=MIDI.MAPPING(ORIGIN) WHICH WILL POINT TO THE APPROPRIATE   */
	/* TRACK (KEYBOARD OR 1-200) DEPENDING ON THE CURRENT VALUE OF       */
	/* MIDI.MAPPING(ORIGIN).                                             */
	/* USED BY WRITING LOOKUP.TRK.THD.PARM (THD.???) INTO YOUR CODE      */
	/* WHERE THD.??? IS REPLACED WITH THE DESIRED PARAMETER LITERAL FOR  */
	/* THE TRACK HEADER AREA.  DATA IS THEN ACCESSED WITH READ(MD).      */
	/* SIMILARLY, USE LOOKUP.SPLT.KBD.THD.PARM TO ACCESS SPLIT KEYBOARD  */
	/* DATA.                                                             */

	DCL LOOKUP.TRK.THD.PARM  LIT 'WRITE(MAM)=TRK.HEAD; WRITE(MAL)=ORIGIN; WRITE(MAM)=READ(MD); WRITE(MAL)='; // was midi  mapped

	DO.ANALOG.SCAN = (TOGGLE=1) & ((REAL.MILLISECONDS-LAST.RTE.TIME) IGT 10);

	/***  LPG "Mark" bug fix of 10/13/87.  Begin inclusion here ***/
	/*
	CHECK THE KEYBOARD POWER STATE.  IF THE POWER IS SUDDENLY LOST, THE
	SCANNING ROUTINE IN 190-NEW0 WILL SET POWER.OFF TO 1.  WE NEED TO
	CONFIRM THAT THE POWER IS STEADILY OFF BY STEPPING THROUGH A THOUSAND
	TRANSITION STATES.  IF WE SUCCESSFULLY REACH 1000, THE POWER IS DEFINITELY
	OFF.  IF WE SEE THE KB REATTACHED IN THAT TRANSITION TIME, WE ABORT THE
	POWER OFF TRANSITION AND ASSUME THAT THE POWER IS ON.

	LIKEWISE, IF WE'RE STEADILY POWERED OFF AND SEE THE KEYBOARD REATTACHED,
	WE BEGIN THE TRANSITION TO A POWER-ON STATE, ABORTING IF WE LOSE THE
	KEYBOARD SOMEWHERE IN TRANSITION.
	*/

	IF  (NEW.PAN)                             /* IF NEW PANEL  */
	AND (POWER.OFF <> 0)                      /* ... AND POWER NOT STEADY ON */
	THEN DO;
		DO I=0 TO 7;
			SWITCHDATA(I)=0;                    /* CLEAR OUT POSSIBLY RANDOM SWITCHES */
		END;
		IF INC.CREG AND (NEW.ORK == 0) THEN DO;
			DISABLE;                               /* AVOID KEYBOARD INTERRUPT HERE */
			WRITE(DREG)=0;
			WRITE(CREG)=0; WRITE(CREG)="40"\0;     /* EX WRITE IN MODE 0 */
			WRITE(CREG)=0; WRITE(CREG)="100"\0;    /* EX READ  IN MODE 0 */
			I=READ(DREG);                          /* GET KCR            */
			ENABLE;
		END;
		ELSE I = "000000";
		IF (POWER.OFF > 0) AND (POWER.OFF < 1000)  /* (1 TO 999) => POWER GOING OFF? */
		THEN DO;
			IF I = "000000"                  /* KB UNPLUGGED IMPLIES POWER GOING OFF */
			THEN DO;
				POWER.OFF = POWER.OFF + 1;    /* INCREMENT STATE VALUE (AUTOMATICALLY CYCLES TO 1000) */
				LOAD POWER.OFF; DIV 5;        /* DO FAST MODULO 5 COMPUTATION */
				IF REM = 0                    /* CLEAR NOTES EVERY 5 ITERATIONS */
				THEN CALL CLEAR.ALL.NOTES;    /* STOP RANDOM NOISE AS POWER COMES ON */
				if ((interp_is_running != 0) && (POWER.OFF == 100)) POWER.OFF = 1000;
			END;
			ELSE IF I = "077777"             /* KB PLUGGED IN INDICATES NOT A REAL POWER-OFF */
			THEN POWER.OFF = 1001;           /* IF SO, START THE POWER ON TRANSITION */
		END;              /* IF POWER GOING OFF */
		ELSE IF (POWER.OFF = 1000)          /* POWER STAYING OFF? */
		THEN DO;
			IF I = "077777"                  /* LOOKS LIKE KEYBOARDS PLUGGED IN */
			THEN POWER.OFF = 1001;           /* ... SO START THE POWER ON TRANSITION */
		END;                                /* IF POWER STEADY OFF */
		ELSE IF (POWER.OFF > 1000) AND (POWER.OFF < 2000) /* POWER GOING ON? */
		THEN DO;
			IF I = "077777"                     /* KB PLUGGED IN IMPLIES POWER COMING ON */
			THEN DO;
				POWER.OFF = POWER.OFF + 1;       /* INCREMENT STATE VALUE */
				LOAD POWER.OFF; DIV 5;           /* DO FAST MODULO 5 COMPUTATION */
				IF REM = 0                       /* CLEAR NOTES EVERY 5 ITERATIONS */
				THEN CALL CLEAR.ALL.NOTES;       /* STOP RANDOM NOISE AS POWER COMES ON */
				if ((interp_is_running != 0) && (POWER.OFF == 1100)) POWER.OFF = 2000;
				IF POWER.OFF = 2000              /* POWER IS DEFINITELY BACK! */
				THEN DO;
					CALL CLEAR.DISPLAY;           /* REMOVE POSSIBLE TRASH FROM WINDOW */
					AMOUNT = "100000";            /* FORCE A REDISPLAY OF PARAMETER */
					CALL RESTORE.POWER;           /* MEASURE INPUT SIGNALS & RESETS POWER.OFF = 0 */
					PRESENT.RTE.DISPLAY = 1;      /* SET FLAG - CAUSES EVERYTHING TO BE REDISPLAYED WHEN POWER IS RESTORED */
					RTE.DISPLAY.STATE   = 0;      /* INITIALIZE TO STATE 0 */
				ANY.MISC.FUNCTIONS  = TRUE;
				END;                             /* IF POWER IS DEFINITELY BACK */
			END;                                /* IF KB IS PLUGGED IN */
			ELSE IF I = "000000"                /* KB UNPLUGGED INDICATES NOT A REAL POWER-ON */
			THEN POWER.OFF = 1;                 /* IF SO, START THE POWER OFF TRANSITION */
		END;  /* IF POWER GOING ON */
	END;     /* OF POWER OFF ON NEW KEYBOARD */

	/***  LPG "Mark" bug fix of 10/13/87.  End inclusion here ***/

	/* $SUBTITLE  HANDLE ORIGINAL KEYBOARD INPUTS */

	ELSE DO;                                  /* POWER ON - READ INFO */
		IF TOGGLE=0 THEN DO;
			IF (REAL.MILLISECONDS-LAST.SCAN.TIME) IGT 20
			THEN DO;
				CALL PANEL.SCAN;                 /* READ SWITCHES EVERY OTHER TIME */
				LAST.SCAN.TIME=REAL.MILLISECONDS-10;
			END;
		END;

      ELSE IF DO.ANALOG.SCAN THEN DO;
         IF (NEW.ORK == 0)
            CALL SCAN.VKP.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS EVERY 15 MSEC */
         ELSE IF (ORK.KNOB.MISSING == false)
            CALL SCAN.ORK.ANALOG.INPUTS;     /* SCAN ANALOG INPUTS EVERY 15 MSEC */
       END;
	END;        /* OF POWER IS ON TO KEYBOARD */

	IF DO.ANALOG.SCAN THEN DO;

		ORIGIN=0;                                  /* INITIALIZE TO PROCESS KEYBOARD */

		LAST.RTE.TIME = REAL.MILLISECONDS;
		KNOB.DELTA=RAW.KNOB.POS-RAW.KNOB.BASE;     /* COMPUTE KNOB DELTA */

		IF INC.PRO THEN DO;        /* IF PROTOCOL SUPPORTED IN THIS CODE */
			KNOB.DELTA = KNOB.DELTA + CLAVIER.EMULATION.KNOB.DELTA; /* PICK UP POTENTIAL SETTING */

			/* MAKE SURE KNOB DOESN'T GET STUCK IN AN OFF-CENTER POSITION */
			IF CLAVIER.EMULATION.KNOB.DELTA < 0
			THEN CLAVIER.EMULATION.KNOB.DELTA=CLAVIER.EMULATION.KNOB.DELTA + 1;
			ELSE IF CLAVIER.EMULATION.KNOB.DELTA > 0
			THEN CLAVIER.EMULATION.KNOB.DELTA=CLAVIER.EMULATION.KNOB.DELTA - 1;
		END;

		SWITCHBITS(0)=GLIDESWITCH;             /* LATCH GLIDESWITCH STATUS */

		IF SW1.CHANGES<>0 THEN DO;             /* HAVE SOME CHANGES TO PROCESS */
			SW1.CHANGES=0;                      /* RESET */

			IF GLIDESWITCH<>PREV.GLIDE THEN DO; /* CHANGE IN GLIDE SWITCH */
				PREV.GLIDE=GLIDESWITCH;          /* UPDATE PREV VALUE */
				/* DON'T PUT THIS CHANGE IN RTE.FIFO SINCE ALL DONE HERE */

				LOOKUP.TRK.THD.PARM (THD.SYN.SROUT+R.GLIDE.SW); /* SET PTR TO MIDI SWITCH ROUTING */

				IF READ(MD)<>0 THEN DO; /* SWITCH IS ROUTED TO MIDI CONTROL # */
					IF GLIDESWITCH<>0 THEN CALL MIDI.CONTROL.CHANGE(0,RTE.MAX);
					ELSE                   CALL MIDI.CONTROL.CHANGE(0,0);
				END;
			END;

			IF REPSWITCH<>PREV.REP THEN DO;      /* CHANGE IN REPEAT SWITCH */
				PREV.REP=REPSWITCH;               /* UPDATE PREV VALUE */
				RTE.UPD=RTE.UPD\B.REP.SW;         /* CHANGE IN REPEAT SWITCH */

				LOOKUP.TRK.THD.PARM (THD.SYN.SROUT+R.REP.SW); /* SET PTR TO MIDI SWITCH ROUTING */

				IF READ(MD)<>0 THEN DO; /* SWITCH IS ROUTED TO MIDI CONTROL # */
					IF REPSWITCH<>0 THEN CALL MIDI.CONTROL.CHANGE(0,RTE.MAX);
					ELSE                 CALL MIDI.CONTROL.CHANGE(0,0);
				END;
			END;

			IF ARPSWITCH<>PREV.ARP THEN DO;      /* CHANGE IN ARPEG SWITCH */
				PREV.ARP=ARPSWITCH;               /* UPDATE PREV VALUE */
				RTE.UPD=RTE.UPD\B.ARP.SW;         /* CHANGE IN ARPEGGIATE SWITCH */

				LOOKUP.TRK.THD.PARM (THD.SYN.SROUT+R.ARP.SW); /* SET PTR TO MIDI SWITCH ROUTING */

				IF READ(MD)<>0 THEN DO; /* SWITCH IS ROUTED TO MIDI CONTROL # */
					IF ARPSWITCH<>0 THEN CALL MIDI.CONTROL.CHANGE(0,RTE.MAX);
					ELSE                 CALL MIDI.CONTROL.CHANGE(0,0);
				END;
			END;
		END; /* OF LOOKING AT SWITCH CHANGES */

		IF (MIDI.SWITCH.CHANGES(0)&(B.REP.SW\B.ARP.SW))<>0
		THEN DO;                          /* HAVE SOME CHANGES IN THE MIDI SWITCH STATES */
			DISABLE;
				I=MIDI.SWITCH.CHANGES(0);
				MIDI.SWITCH.CHANGES(0)=MIDI.SWITCH.CHANGES(0)&(NOT(B.REP.SW\B.ARP.SW)); /* TURN OFF BITS PROCESSED */
			ENABLE;

			IF (I&B.REP.SW)<>0
			THEN RTE.UPD=RTE.UPD\B.REP.SW; /* CHANGE IN REPEAT SWITCH */

			IF (I&B.ARP.SW)<>0
			THEN RTE.UPD=RTE.UPD\B.ARP.SW; /* CHANGE IN ARPEGGIATE SWITCH */
		END;                              /* OF MIDI SWITCH CHANGES */

		/* $PAGE */

		IF RTE.UPD<>0 THEN DO; /* HAVE SOME UPDATES TO DO */
			IF (RTE.UPD&B.REP.SW)<>0 THEN DO;

				LOOKUP.TRK.THD.PARM (THD.CTBITS);  /* SET PTR TO TOGGLE BITS */

				IF (REPSWITCH  /* \MIDI.SWITCHDATA(R.REP.SW) */ ) <>0
				THEN WRITE(MD)=READ(MD)\BIT.REPEAT;       /* SET REPEAT BIT   */
				ELSE WRITE(MD)=READ(MD)&(NOT BIT.REPEAT); /* CLEAR REPEAT BIT */
			END;

			IF (RTE.UPD&B.ARP.SW)<>0 THEN DO;

				LOOKUP.TRK.THD.PARM (THD.CTBITS);   /* SET PTR TO TOGGLE BITS */

				IF (ARPSWITCH /* \MIDI.SWITCHDATA(R.ARP.SW) */ )<>0
				THEN WRITE(MD)=READ(MD)\BIT.ARPEG;       /* SET ARPEG BIT   */
				ELSE WRITE(MD)=READ(MD)&(NOT BIT.ARPEG); /* CLEAR ARPEG BIT */
			END;

			NEW.TOGGLES=1; NEW.INFO=1;

			LOOKUP.TRK.THD.PARM (THD.UPD.PARS); /* SET PTR TO RTE UPDATE BITS */

			WRITE(MD)=READ(MD)\N.REPRATE;       /* SET REPEAT UPDATE BIT */
			RTE.UPD=0; /* RESET */
		END;

		/* $SUBTITLE  PROCESS SYNCLAVIER AND MIDI ANALOG INPUT CHANGES */

		LOOKUP.TRK.THD.PARM (THD.ACTIVE.MIDI.RTES); /* GET ACTIVE BITS FOR ENABLED RTES */
		ACTIVE.MIDI.RTES=READ(MD);                  /* AND SAVE IN LOCAL */

		IF RAW.PEDAL1.POS<>PREV.PEDAL1.POS
		THEN DO;                                 /* CHANGE IN PEDAL 1 */

			IF RAW.PEDAL1.POS<PREV.PEDAL1.POS
			THEN RAW.PEDAL1.POS=RAW.PEDAL1.POS+1; /* PROVIDE DEAD BAND */
			ELSE RAW.PEDAL1.POS=RAW.PEDAL1.POS-1;

			IF RAW.PEDAL1.POS<>PREV.PEDAL1.POS
			THEN DO;                                 /* CHANGE IN PEDAL 1 */

				IF RAW.PEDAL1.POS<PREV.PEDAL1.POS
				THEN RAW.PEDAL1.POS=RAW.PEDAL1.POS+1; /* PROVIDE DEAD BAND */
				ELSE RAW.PEDAL1.POS=RAW.PEDAL1.POS-1;

				IF RAW.PEDAL1.POS<>PREV.PEDAL1.POS
				THEN DO;                              /* SIGNIFICANT CHANGE IN PEDAL 1 */
					PREV.PEDAL1.POS=RAW.PEDAL1.POS;    /* UPDATE PREV VAL */

					if (MWHEEL_PROXY != R.PEDAL1) {	//	disregard the physical pedal if the mod wheel is proxying for it
						RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
						RTE.FIFO(RTE.FIFO(0))=R.PEDAL1;    /* STORE INPUT # */
						I=235-RAW.PEDAL1.POS;
						IF I<0       THEN I=0;             /* LIMIT TO ZERO */
						IF I>RTE.MAX THEN I=RTE.MAX;       /* LIMIT TO MAX */
						WRITE(MAM)=SYN.RTE.VALUE;
						WRITE(MAL)=R.PEDAL1;
						WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */
	
						IF (ACTIVE.MIDI.RTES&B.PEDAL1)<>0  /* THIS MIDI RTE IS ENABLED */
						THEN DO;
	
							LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.PEDAL1); /* SET PTR TO MIDI CTRLR ROUTING */
	
							IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
								CALL MIDI.CONTROL.CHANGE(0,I&255);
								/* NOT NECESSARY TO UPDATE MIDI.RTES FOR TRACK 0 */
							END;
						END;
					}
				END;
			END;
		END;

		IF RAW.PEDAL2.POS<>PREV.PEDAL2.POS       /* CHANGE IN PEDAL 2 */
		THEN DO;

			IF RAW.PEDAL2.POS<PREV.PEDAL2.POS
			THEN RAW.PEDAL2.POS=RAW.PEDAL2.POS+1; /* PROVIDE DEAD BAND */
			ELSE RAW.PEDAL2.POS=RAW.PEDAL2.POS-1;

			IF RAW.PEDAL2.POS<>PREV.PEDAL2.POS
			THEN DO;                              /* SIGNIFICANT CHANGE IN PEDAL 2 */

				IF RAW.PEDAL2.POS<PREV.PEDAL2.POS
				THEN RAW.PEDAL2.POS=RAW.PEDAL2.POS+1; /* PROVIDE DEAD BAND */
				ELSE RAW.PEDAL2.POS=RAW.PEDAL2.POS-1;

				IF RAW.PEDAL2.POS<>PREV.PEDAL2.POS
				THEN DO;                              /* SIGNIFICANT CHANGE IN PEDAL 2 */
					PREV.PEDAL2.POS=RAW.PEDAL2.POS;    /* UPDATE PREV VAL */

					if (MWHEEL_PROXY != R.PEDAL2) {       //	disregard the physical pedal if the mod wheel is proxying for it
						RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
						RTE.FIFO(RTE.FIFO(0))=R.PEDAL2;    /* STORE INPUT # */
						I=235-RAW.PEDAL2.POS;
						IF I<0       THEN I=0;             /* LIMIT TO ZERO */
						IF I>RTE.MAX THEN I=RTE.MAX;       /* LIMIT TO MAX */
						WRITE(MAM)=SYN.RTE.VALUE;
						WRITE(MAL)=R.PEDAL2;
						WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */
	
						IF (ACTIVE.MIDI.RTES&B.PEDAL2)<>0  /* THIS MIDI RTE IS ENABLED */
						THEN DO;
	
							LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.PEDAL2); /* SET PTR TO MIDI CTRLR ROUTING */
	
							IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
								CALL MIDI.CONTROL.CHANGE(0,I&255);
							END;
						END;
					}
				END;
			END;
		END;

		/* $PAGE - MWHEEL, BREATH */

		IF RAW.MWHEEL.POS<>PREV.MWHEEL.POS       /* CHANGE IN MWHEEL */
		THEN DO;

			PREV.MWHEEL.POS = RAW.MWHEEL.POS;     /* SAVE FOR NEXT TIME */

			IF RAW.MWHEEL.POS < FILT.MWHEEL.POS   /* KNOB IS BELOW HYSTERESIS VALUE */
			THEN DO;
				RAW.MWHEEL.POS = RAW.MWHEEL.POS + MODHYST;
				IF RAW.MWHEEL.POS > FILT.MWHEEL.POS
				THEN RAW.MWHEEL.POS = FILT.MWHEEL.POS;
			END;
			ELSE IF RAW.MWHEEL.POS > FILT.MWHEEL.POS
			THEN DO;
				RAW.MWHEEL.POS = RAW.MWHEEL.POS - MODHYST;
				IF RAW.MWHEEL.POS < FILT.MWHEEL.POS
				THEN RAW.MWHEEL.POS = FILT.MWHEEL.POS;
			END;

			IF RAW.MWHEEL.POS<>FILT.MWHEEL.POS
			THEN DO;                              /* SIGNIFICANT CHANGE IN MWHEEL */
				RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
				RTE.FIFO(RTE.FIFO(0)) = MWHEEL_PROXY;	/* STORE INPUT # */
				FILT.MWHEEL.POS=RAW.MWHEEL.POS;    /* SAVE FOR NEXT COMPARISON */

				IF NEW.PM=0 THEN DO;               /* ORIGINAL PITCH/MOD WHEEL */
					I=FILT.MWHEEL.POS-5;            /* USE POSITION FOR MOD WHEEL */
					IF I<0 THEN I=0;                /* LIMIT TO ZERO */
					I=SHL(I,2)+I;                   /* SCALE BY FACTOR OF 5 */
				END;
				ELSE DO;                           /* NEW PITCH/MOD WHEELS */
					I=FILT.MWHEEL.POS-13;           /* USE POSITION FOR MOD WHEEL */
					IF I<0 THEN I=0;                /* LIMIT TO ZERO */
					I=I+SHR(I,2);                   /* SCALE UPWARDS */
				END;
				IF I>RTE.MAX THEN I=RTE.MAX;       /* LIMIT TO MAX  */
				WRITE(MAM)=SYN.RTE.VALUE;
				WRITE(MAL)=MWHEEL_PROXY;
				WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */

				//	SHL(1,MWHEEL_PROXY) yields the bit corresponding to the controller being proxied for
				IF (ACTIVE.MIDI.RTES & SHL(1,MWHEEL_PROXY))<>0  /* THIS MIDI RTE IS ENABLED */
				THEN DO;

					LOOKUP.TRK.THD.PARM (THD.SYN.CROUT + MWHEEL_PROXY); /* SET PTR TO MIDI CTRLR ROUTING */

					IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
						CALL MIDI.CONTROL.CHANGE(0,I&255);
					END;
				END;
			END;
		END;

		/* $PAGE - BREATH CONTROLLER */

		IF RAW.BREATH.POS<>PREV.BREATH.POS       /* CHANGE IN BREATH */
		THEN DO;

			IF RAW.BREATH.POS<PREV.BREATH.POS
			THEN RAW.BREATH.POS=RAW.BREATH.POS+1; /* PROVIDE DEAD BAND */
			ELSE RAW.BREATH.POS=RAW.BREATH.POS-1;

			IF RAW.BREATH.POS<>PREV.BREATH.POS
			THEN DO;                              /* SIGNIFICANT CHANGE IN BREATH CONT. */
				PREV.BREATH.POS=RAW.BREATH.POS;    /* SAVE FOR NEXT TIME */

				if (MWHEEL_PROXY != R.BREATH) {	//	disregard the physical breath controller if the mod wheel is proxying for it
					RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
					RTE.FIFO(RTE.FIFO(0))=R.BREATH;    /* STORE INPUT # */
					I=RAW.BREATH.POS-20;               /* AND LIMIT RAW VALUE */
					IF I<0 THEN I=0;
					IF I>RTE.MAX THEN I=RTE.MAX;
					WRITE(MAM)=SYN.RTE.VALUE;
					WRITE(MAL)=R.BREATH;
					WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */
	
					IF (ACTIVE.MIDI.RTES&B.BREATH)<>0  /* THIS MIDI RTE IS ENABLED */
					THEN DO;
	
						LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.BREATH); /* SET PTR TO MIDI CTRLR ROUTING */
	
						IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
							CALL MIDI.CONTROL.CHANGE(0,I&255);
						END;
					END;
				}
			END;
		END;

		/* $PAGE -- PITCH WHEEL */

		IF  (TB.ENABLED<>0)                      /* IF TONE BEND IS SELECTED */
		AND (HELD.PSEL.BUTTONS=0)                /* AND PARTIAL BUTTON NOT HELD */
		AND (NUM.OF.HELD.TRACK.BUTTONS=0)        /* AND TRACK BUTTON NOT HELD */
		THEN DO;                                 /* PERFORM PITCH BEND */
			RAW.PWHEEL.POS=RAW.PWHEEL.POS+KNOB.DELTA; /* JUST ADD KNOB IN */
			KNOB.DELTA=0;                         /* OTHER ITEMS DO NOT CHANGE */
		END;                                     /* OF TONE BEND ENABLED */

		IF RAW.PWHEEL.POS<>PREV.PWHEEL.POS       /* CHANGE IN PWHEEL */
		THEN DO;

			PREV.PWHEEL.POS=RAW.PWHEEL.POS;       /* SAVE FOR NEXT TIME */

			IF RAW.PWHEEL.POS<FILT.PWHEEL.POS     /* KNOB IS BELOW HYSTERESIS VALUE */
			THEN RAW.PWHEEL.POS=RAW.PWHEEL.POS+1; /* PROVIDE ONE UNIT HYSTERESIS */
			ELSE IF RAW.PWHEEL.POS>FILT.PWHEEL.POS
			THEN RAW.PWHEEL.POS=RAW.PWHEEL.POS-1;

			IF RAW.PWHEEL.POS<>FILT.PWHEEL.POS
			THEN DO;                              /* SIGNIFICANT CHANGE IN PWHEEL */
				RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
				RTE.FIFO(RTE.FIFO(0))=R.PWHEEL;    /* STORE INPUT # */
				FILT.PWHEEL.POS=RAW.PWHEEL.POS;    /* SAVE FOR NEXT COMPARISON */

				I=ABS(FILT.PWHEEL.POS-RAW.PWHEEL.BASE); /* GET DELTA FROM BASE */
				IF NEW.PM=0 THEN DO;               /* ORIGINAL PITCH/MOD WHEEL */
					IF I>4 THEN DO;                 /* PROVIDE DEAD BAND */
						LOAD I-4; MUL 100; I=RES; DIV 24; /* MAX OF 24 */
						I=RES;
						IF I>100 THEN I=100;         /* LIMIT TO +- 100 */
						IF FILT.PWHEEL.POS<RAW.PWHEEL.BASE
						THEN I=-I;                   /* NEGATE */
					END;
					ELSE I=0;                       /* IN DEAD BAND */
				END;
				ELSE DO;                           /* NEW PITCH WHEEL */
					IF I>12 THEN DO;                /* PROVIDE DEAD BAND */
						LOAD I-12; MUL 100; I=RES; DIV 84;
						I=RES;
						IF I>100 THEN I=100;         /* LIMIT TO +- 100 */
						IF FILT.PWHEEL.POS<RAW.PWHEEL.BASE
						THEN I=-I;                   /* NEGATE */
					END;
					ELSE I=0;                       /* IN DEAD BAND */
				END;
				WRITE(MAM)=SYN.RTE.VALUE;
				WRITE(MAL)=R.PWHEEL;
				WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */

				IF (ACTIVE.MIDI.RTES&B.PWHEEL)<>0  /* THIS MIDI RTE IS ENABLED */
				THEN DO;

					LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.PWHEEL); /* SET PTR TO MIDI CTRLR ROUTING */

					IF READ(MD)<>0                  /* MIDI IS ENABLED         */
					THEN CALL MIDI.PITCH.WHEEL(I&255);
				END;
			END;
		END;

		/* $PAGE - RIBBON CONTROLLER AND MIDI CONTROLLER CHANGES */

		IF RAW.RIBBON.POS<>PREV.RIBBON.POS       /* CHANGE IN RIBBON */
		THEN DO;

			IF RAW.RIBBON.POS<PREV.RIBBON.POS
			THEN RAW.RIBBON.POS=RAW.RIBBON.POS+1; /* PROVIDE DEAD BAND */
			ELSE RAW.RIBBON.POS=RAW.RIBBON.POS-1;

			IF RAW.RIBBON.POS<>PREV.RIBBON.POS    /* SIGNIFICANT CHANGE IN RIBBON */
			THEN DO;
				IF RIB.ACTIVE=0 THEN DO;              /* CHECK FOR START OF RIBBON CONTROLLER */
					IF  (PREV.RIB.VAL  >10)            /* LOOK FOR TWO READINGS IN A ROW */
					AND (RAW.RIBBON.POS>10) THEN DO;   /* START RIBBON IF TWO GOOD READINGS */
						RIB.ACTIVE=1;                   /* START RIBBON CONTROLLER */
						RAW.RIBBON.BASE=RAW.RIBBON.POS; /* SAVE RIBBON CONTROLLER BASE */
						PREV.RIBBON.POS=RAW.RIBBON.POS; /* ACTIVATE HYSTERESIS NOW */
					END;
				END;
				ELSE DO;                              /* RIBBON CONTROLLER IS ACTIVE */
					RTE.FIFO(0)=RTE.FIFO(0)+1;         /* ADVANCE COUNT */
					RTE.FIFO(RTE.FIFO(0))=R.RIBBON;    /* STORE INPUT # */

					IF RAW.RIBBON.POS>10 THEN DO;      /* MAKE SURE STILL ACTIVE      */
						I=PREV.RIB.VAL-RAW.RIBBON.BASE; /* COMPUTE FROM BASE - USE OLD DATA TO AVOID GLITCH AT END */
						IF I> 100 THEN I= 100;          /* LIMIT TO +- 100 */
						IF I<-100 THEN I=-100;
						PREV.RIBBON.POS=PREV.RIB.VAL;   /* ACTIVATE HYSTERESIS NOW */
					END;
					ELSE DO;                           /* END OF RIBBON CONTROLLER   */
						RIB.ACTIVE=0;                   /* RIBBON NO LONGER ACTIVE    */
						I=0;                            /* VALUE IS ZERO */
						PREV.RIBBON.POS=RAW.RIBBON.POS; /* ACTIVATE HYSTERESIS NOW */
					END;
					WRITE(MAM)=SYN.RTE.VALUE;
					WRITE(MAL)=R.RIBBON;
					WRITE(MD) =I;                      /* AND SAVE A COPY FOR USE BELOW */

					IF (ACTIVE.MIDI.RTES&B.RIBBON)<>0  /* THIS MIDI RTE IS ENABLED */
					THEN DO;

						LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.RIBBON); /* SET PTR TO MIDI CTRLR ROUTING */

						IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
							CALL MIDI.CONTROL.CHANGE(1,I);
						END;
					END;
				END;                           /* OF CASE FOR RIBBON CONTROLLER IS ACTIVE */
				PREV.RIB.VAL=RAW.RIBBON.POS;   /* SAVE FOR NEXT RIBBON READING */
			END;
		END;

		// Process incoming MIDI rte changes
		
		DISABLE;
		CHANGEBITS = MIDI.ANALOG.CHANGEBITS;
		MIDI.ANALOG.CHANGEBITS = 0;
		ENABLE;
  
		WHILE (CHANGEBITS != 0)
		{
			DISABLE;
			WRITE("2")  = CHANGEBITS;
			H           = SHR(READ("2"), 1);
			CHANGETABLE = MIDI.ANALOG.CHANGETABLE(H);  /* COPY INTO LOCAL VAR */
			MIDI.ANALOG.CHANGETABLE(H)=0;              /* ZERO GLOBAL */
			ENABLE;
		
			CHANGEBITS=CHANGEBITS & (NOT BITS(H));     /* ZERO THIS BIT IN CHANGES WORD */
			
			DO WHILE CHANGETABLE<>0;                   /* PROCESS ALL CHANNELS IN THIS GROUP */
				DISABLE;
					WRITE("2")=CHANGETABLE;
					CHAN.BIT=SHR(READ("2"),1);           /* RETURNS POSITION (TIMES 2) OF HIGHEST SET BIT */
				ENABLE;

				ORIGIN=SHL(H,4)+CHAN.BIT;               /* COMPUTE INPUT CHANNEL ORIGIN */
				CHANGETABLE=CHANGETABLE & (NOT BITS(CHAN.BIT)); /* CLEAR THIS CHANNEL'S BIT FROM CHANGES WORD */

				IF MIDI.ANALOG.CHANGES(ORIGIN)<>0 THEN DO;    /* HAVE SOME CHANGES IN MIDI CONTROLLERS */
					DISABLE;
						K=MIDI.ANALOG.CHANGES(ORIGIN);    /* GET COPY OF VAR */
						MIDI.ANALOG.CHANGES(ORIGIN)=0;    /* RESET */
					ENABLE;

					IF ORIGIN<>1 THEN DO;                /* ORIGIN OF 1=NOT LISTENING TO THIS CHANNEL */
						J=1;                              /* INTIALIZE MASK */

						DO I=R.PEDAL1 TO R.RIBBON;        /* LOOP THROUGH INPUTS */
							IF (K&J)<>0 THEN DO;           /* CONTROLLER HAS CHANGED */
								RTE.FIFO(0)=RTE.FIFO(0)+1;  /* ADVANCE COUNT */
								RTE.FIFO(RTE.FIFO(0))=I\(SHL(ORIGIN,8)); /* STORE INPUT # AND ORIGIN FOR BELOW */

								IF MIDI.ECHO.DISABLED=0 THEN DO;
									/* ASSUMES RTE VALUE ONLY CHANGES IF */
									/* MIDI.ACTIVE.RTES WAS SET FOR THIS */
									/* CONTROLLER.                       */

									LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+I); /* SET PTR TO MIDI CTRLR ROUTING */

									IF READ(MD)<>0 THEN DO; /* CTRLR IS ROUTED TO MIDI */
										IF I<R.PWHEEL
										THEN DO;
											WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+I,8); /* XMEM DATA ARRAY */
											WRITE(MAL)=SHL(ORIGIN,3)+I;      /* OFFSET INTO ARRAY */
											L         =READ(MD);             /* GET DATA */
											LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+I); /* SET PTR TO MIDI CTRLR ROUTING */
											CALL MIDI.CONTROL.CHANGE(0,L&255);
										END;
										ELSE DO;
											IF I=R.PWHEEL
											THEN DO;
												WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+R.PWHEEL,8);
												WRITE(MAL)=SHL(ORIGIN,3)+R.PWHEEL;
												L         =READ(MD);
												LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.PWHEEL); /* SET PTR TO MIDI CTRLR ROUTING */
												CALL MIDI.PITCH.WHEEL(L&255);
											END;
											ELSE DO;
												WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+R.RIBBON,8);
												WRITE(MAL)=SHL(ORIGIN,3)+R.RIBBON;
												L         =READ(MD);
												LOOKUP.TRK.THD.PARM (THD.SYN.CROUT+R.RIBBON); /* SET PTR TO MIDI CTRLR ROUTING */
												CALL MIDI.CONTROL.CHANGE(1,L);
											END;
										END;
									END;      /* OF CONTROLLER IS ROUTED   */
								END;         /* OF MIDI ECHO              */
							END;            /* OF CONTROLLER HAS CHANGED */
							J=SHL(J,1);     /* SHIFT MASK FOR NEXT INPUT */
						END;               /* OF LOOP THRU RTE INPUTS   */
					END;                  /* ORIGIN <> 1               */
				END;                     /* OF ANY CHANGES IN MIDI    */
			END;                        /* OF ANY CHANGES IN THIS GROUP OF CHANNELS */
		END;                           /* OF LOOP THRU ALL CHANNELS */

		/* $SUBTITLE  NOW PROCESS ALL THE INPUT CHANGES IN THE FIFO BUFFER */

		IF RTE.FIFO(0)<>0 THEN DO; /* HAVE SOME RTE UPDATES TO PROCESS */

			DO K=1 TO RTE.FIFO(0);  /* LOOP OVER INPUTS WHICH HAVE CHANGED */
				ORIGIN=SHR(RTE.FIFO(K),8);     /* EXTRACT ORIGIN      */
				J=(RTE.FIFO(K)&255);           /* PUT VAR IN SCALAR   */

				WRITE(MAM)=MIDI.ANALOG.IN+SHR(SHL(ORIGIN,3)+J,8); /* XMEM DATA ARRAY     */
				WRITE(MAL)=SHL(ORIGIN,3)+J;    /* OFFSET INTO ARRAY   */
				L         =READ(MD);           /* GET MIDI ONLY VALUE */
				WRITE(MAL)=J;                  /* POINT TO KBD VALUE  */

				IF SYN.PLUS.MIDI<>0  /* COMPILATION FLAG TO SELECT ALGORITHM TYPE */
				THEN I=READ(MD)+L;   /* ADD IN MIDI VALUE */
				ELSE I=L;            /* USE MOST RECENT CHANGE */

				IF J ilt R.PWHEEL
				THEN DO; /* SCALE FOR PEDAL1, PEDAL2, MOD WHEEL, BREATH CONT */
					IF I igt RTE.MAX THEN I=RTE.MAX;       /* LIMIT TO MAX */

					/* INVERT LINEARLY */
					I=I\SHL(RTE.MAX-I,8);
					/*	************************ B E G I N   D E L E T I O N ************************	*\
					\* INVERT USING PSEUDO-LOG FUNCTION *\
					LOAD (RTE.MAX*20+400); DIV (I+20);
					I=I\SHL(RES-20,8);			\* USE LOG-LIKE FUNCTION FOR BEST INVERSION *\
					\*	************************** E N D   D E L E T I O N **************************	*/

					LOOKUP.TRK.THD.PARM (THD.LIVE.RTES+J);  /* SET PTR TO RTE DATA FOR THIS KBD EXPRESSION INPUT */

					IF I<>READ(MD) THEN RTE.UPD=1;     /* UPDATE THE RTE GLOBAL INFO */
				END;
				ELSE DO; /* SCALE PITCH WHEEL AND RIBBON CONTROLLER */
					IF I>(+100) THEN I=+100;           /* LIMIT RANGE AGAIN */
					IF I<(-100) THEN I=-100;

					IF J=R.PWHEEL THEN DO; /* ONLY FOR PITCH WHEEL */
						IF I<>0 THEN I=(I&255)\SHL((-I)&255,8); /* STORE - TWO 8-BIT TWOS COMPLEMENT NUMBERS */

						LOOKUP.TRK.THD.PARM (THD.LIVE.RTES+R.PWHEEL); /* SET PTR TO RTE DATA FOR THIS KBD EXPRESSION INPUT */

						IF I<>READ(MD) THEN RTE.UPD=1; /* UPDATE THE RTE INFO */
					END;
					ELSE DO;               /* ONLY FOR RIBBON */

						LOOKUP.TRK.THD.PARM (THD.LIVE.RTES+R.RIBBON); /* SET PTR TO RTE DATA FOR THIS KBD EXPRESSION INPUT */

						IF I<>READ(MD) THEN DO;             /* CHANGE IN RAW RIBBON */
							WRITE(MD)=I;                     /* STORE + AND - DATA IN RTE ARRAY */

							L = SHR(ORIGIN, 4);
							RTE.CHANGES    (ORIGIN) = RTE.CHANGES    (ORIGIN) \ R.LOOK(R.RIBBON); 	 /* INDICATE NEW RTE FOR RECORDING */
							RTE.CHANGETABLE(L     ) = RTE.CHANGETABLE(L     ) \ BITS(ORIGIN & "17"); /* INDICATE ACTIVE RTE CHANNEL FOR RECORD */
							RTE.CHANGEBITS          = RTE.CHANGEBITS          \ BITS(L);				 /* AND THE CORRESPONDING CJAMGEBOTS BIT */

							/*** NOTE: THE CODE TO SET THD.UPD.PARS AND NEW.INFO
							IS TO BE FOUND IN 320-RIBF.  THAT FILE CONTAINS CODE
							FOR A SPECIAL SOFTWARE FILTER USED BY ALL TIMBRES
							PATCHED TO THE RIBBON CONTROLLER. *****/
						END;
					END;
				END;

				IF RTE.UPD<>0 THEN DO;                /* UPDATE SOME GLOBAL VARS */
					RTE.UPD=0;                         /* RESET */
					LOOKUP.TRK.THD.PARM (THD.LIVE.RTES+J);  /* SET PTR TO KBD RTE DATA FOR EXPRESSION INPUT */

					WRITE(MD)=I;                       /* STORE NEW VALUE */

					IF ORIGIN<>0 THEN DO;              /* IF FROM MIDI */

						IF (MIDI.ECHO.DISABLED=0)
						AND (ORIGIN>1) THEN DO; 		  /* NOT NECESSARY TO UPDATE THIS FOR KBD */ // was midi  mapped
							WRITE(MAL)=THD.MIDI.RTES+J;
							WRITE(MD )=I;
						END;
					END;
					
					L = SHR(ORIGIN, 4);
					RTE.CHANGES    (ORIGIN) = RTE.CHANGES    (ORIGIN) \ R.LOOK(J); 			 /* INDICATE NEW RTE FOR RECORDING */
					RTE.CHANGETABLE(L     ) = RTE.CHANGETABLE(L     ) \ BITS(ORIGIN & "17"); /* INDICATE ACTIVE RTE CHANNEL FOR RECORD */
					RTE.CHANGEBITS          = RTE.CHANGEBITS          \ BITS(L);				 /* AND THE CORRESPONDING CJAMGEBOTS BIT */
					
					/* FOLLOWING LINES EQUIVALENT TO: */
					/* UPD.PARS(0)=UPD.PARS(0)\ACT.PARS(0)\ACT.PARS(1) */

					WRITE(MAL)=THD.CTIMB;
					L         =READ(MD);               /* GET CURRENT TIMBRE FOR THIS KEYBOARD */
					WRITE(MAM)=TIM.HEAD;               /* GET PTR TO KBD/TRK TIMBRE INFO */
					WRITE(MAL)=L;
					WRITE(MAM)=READ(MD);               /* POINT TO TIMBRE    */
					WRITE(MAL)=TIM.ACT.PARS+J;         /* ACCESS ACT.PARS(J) */
					L         =READ(MD);               /* STORE IN TEMP VAR  */

					IF ORIGIN = 0 THEN DO;             /* ALSO GET SPLIT KBD ACTIVE PARS */
						WRITE(MAM)=TIM.HEAD;            /* GET PTR TO SPLIT KBD TIMBRE INFO */
						WRITE(MAL)=1;
						WRITE(MAM)=READ(MD);
						WRITE(MAL)=TIM.ACT.PARS+J;       /* ACCESS ACT.PARS(J) */
						L=L\READ(MD);
					END;

					LOOKUP.TRK.THD.PARM (THD.UPD.PARS); /* SET PTR TO UPDATE WORD */
					WRITE(MD)=READ(MD)\L;               /* MUST UPDATE PARMS FOR KEYBOARD/TRACK TIMBRE */

					NEW.INFO=1;                         /* FORCE IMMEDIATE ENTRY INTO UPDATING CODE */
				END;        /* DO AN RTE UPDATE */
			END;           /* OF LOOP OVER RTE BYTES IN FIFO */
			RTE.FIFO(0)=0; /* RESET */
		END;              /* OF HAVE SOME RTE UPDATES TO DO */

		/* $SUBTITLE  PROCESS NEW MIDI CONTROLLERS FROM STACK */

		I=1;

		DISABLE;                                  /* FOR STACK CHECK */
		DO WHILE I<=MIDI.RTE.STAK(0);

			ENABLE;                                /* ALLOW FOR MORE RTES NOW */

			ORIGIN=SHR(MIDI.RTE.STAK(I),8);        /* GET MIDI CHANNEL ORIGIN */
			J=ORIGIN;                					/* AND TRACK NUMBER WE ARE ROUTED TO */ // was midi  mapped
			K=MIDI.RTE.STAK(I) & 255;              /* EXTRACT CONTROLLER NUMBER */
			L=MIDI.RTE.VALUE(I);                   /* GET CONTROLLER VALUE */

			WRITE(MAM)=MIDI.TRACK.RTES+J;          /* POINT TO TABLE IN XMEM */
			WRITE(MAL)=128+K;                      /* OFFSET INTO TABLE FOR LAST RECEIVED VALUE FOR THIS CONTROLLER */
			WRITE(MD )=L;                          /* WRITE VALUE INTO TABLE */

			IF MIDI.ECHO.DISABLED=0 THEN DO;       /* DO MIDI ECHO HERE */
				WRITE(MAM)=TRK.HEAD;                /* MUST SET UP MAM/MAL FOR CALL BELOW */
				WRITE(MAL)=J;
				WRITE(MAM)=READ(MD);
				CALL REAL.MIDI.CONTROL.CHANGE(K,L); /* OUTPUT MIDI CONTROL CHANGE */
			END;

			IF J=0 THEN J=RECD.TRK;                /* IN CASE WE ARE RECORDING GET ACTUAL RECORD TRACK */

			WRITE(MAM)=TBUT.PTR;
			WRITE(MAL)=J;

			IF  (RECD<>0)                          /* RECORDING */
			AND (RECD.TRK<>0)                      /* SYNCLAVIER RECORDING */
			AND ((READ(MD)&B.READY.TRK)<>0)        /* THIS TRACK IS ENABLED FOR RECORD */
			THEN DO;

				MSB=MIDI.RTE.MSB(I);                /* GET TIME OF THIS RTE */
				LSB=MIDI.RTE.LSB(I) + PRESCAN;
				IF LSB ILT PRESCAN
				THEN MSB=MSB+1;

				WRITE(MAM)=MIDI.TRACK.RTES+J;       /* POINT TO TABLE IN XMEM */
				WRITE(MAL)=K;                       /* OFFSET INTO TABLE FOR LAST RECORDED VALUE FOR THIS CONTROLLER */
				H=READ(MD)&"377";                   /* GET CURRENT VALUE */
				L=L\(READ(MD)&"177400");            /* OR IN UPPER BYTE OF STORED WORD TO RETAIN INIT VALUE */
				WRITE(MD )=L;                       /* WRITE NEW VALUE BACK INTO TABLE */

				WRITE(MAM)=TRK.HEAD;
				WRITE(MAL)=J;
				THP=READ(MD);
				TRK=J;

				CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(MSB)), LOC(ADDR(MSB)));

				IF STORE.DATA.RECORD (MSB,LSB,                  /* TIME */
											 24,    SHL(K\"200",2),    /* KEY, MIDI CONTROLLER NUMBER*/
											 L&255, B.UPD,             /* NEW, B.UPD */
											 H&255         )=0         /* OLD        */
				THEN CALL KBD.ERROR(17);

			END;

			I=I+1;                                 /* ADVANCE TO NEXT RTE IF ONE */

			DISABLE;                               /* FOR NEXT STACK CHECK */
		END;                                      /* OF STACK LOOP */

		MIDI.RTE.STAK(0)=0;                       /* STACK IS NOW EMPTY */
		ENABLE;                                   /* AFTER STACK CHECK */

	END;                 /* OF DO.ANALOG.SCAN */

	/* GUITAR SCAN CODE MAY BE INSERTED HERE.  END OF SCANDATA IS NEXT */
