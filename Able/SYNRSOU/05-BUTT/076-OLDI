/* 076-OLDI  $TITLE  LOW LEVEL SCANNING ROUTINES FOR ORIGINAL SYNCLAVIER II PANEL */

/*
   5/15/86 - "official" creation of release-M modules
*/

/* This file contains the i/o drivers that are used with the original
   button panel/clavier */

/* FIRST, THE KEYBOARD: */

/* A new scanning routine has been implemented for the scanning
.of the clavier.   The routine 'scan.for.notes' is called every loop time.
.It detects changes in the keyboard and records entries on a push
.down stack when a key is pressed or released.   See stack definitions
.below. */

/* Use of key numbers:
.
.  The higher level software can accept key numbers that span the
.range from C0 (use 0) to C7 (use 84).   Keyboards must be mapped
.to produce a key number form 0 to 84.   Middle C is C3 (key number
.of 36.
.
.  The original synclavier II keyboard spans C1 to C6 */

DCL BUTTON.LIST.SIZE	   LIT '10';         // 10 fingers in one millisecond
DCL BUTTON.LIST.HELD    LIT '"100000"';   // Button held
DCL BUTTON.LIST.ORK     LIT '"040000"';   // Button press was from ORK
DCL BUTTON.LIST.MASK    LIT '"037777"';   // Data field with PBN or LPN

DCL NEW.NOTE.STAK	 (NEW.NOTE.LIST.SIZE)	FIXED PUBLIC;
DCL NEW.NOTE.KEY#	 (NEW.NOTE.LIST.SIZE)	FIXED PUBLIC;
DCL NEW.NOTE.VEL	 (NEW.NOTE.LIST.SIZE)	FIXED PUBLIC;
DCL NEW.NOTE.TIME	 (NEW.NOTE.LIST.SIZE)	FIXED PUBLIC;

DCL NEW.BUTTON.LIST(BUTTON.LIST.SIZE)		FIXED PUBLIC;
DCL EXT.TRIG.STAK	 (EXT.TRIG.LIST.SIZE)	FIXED PUBLIC;

DCL NUM.HELD.KEYS FIXED PUBLIC;

DCL SW1.CHANGES	FIXED PUBLIC;	/*	SET TO 1 WHEN SWITCHDATA STATES HAVE CHANGED       */
DCL SW2.CHANGES	FIXED PUBLIC;	/*	SET TO 1 WHEN SWITCHDATA STATES HAVE CHANGED       */
DCL SWITCHDATA(7)	FIXED PUBLIC;	/*	INDIVIDUAL SWITCH STATE BITS                       */
DCL ANALOG.IN (7)	FIXED PUBLIC;	/*	ANALOG CONTROLLER VALUES FOR SYNCLAVIER            */

DCL NEWKEY        FIXED PUBLIC;  /*	SET WHEN NEW KEY PRESS DETECTED DURING INTERRUPT	*/
DCL ANY.MISC.FUNCTIONS	FIXED;				/*	TRUE IF ANY MISC FUNCTIONS ACTIVE - FOR CPU OPTIMIZING	*/

/* $PAGE - ROUTINE TO READ ORIGINAL KEYBOARD */

/* SCAN.FOR.NOTES IS CALLED EVERY 5 MILLISECONDS FROM THE REAL
   TIME CLOCK INTERRUPT ROUTINE */

/* INTERRUPTS ARE ENABLED WHEN IT IS CALLED,  BUT A SOFTWARE FLAG IN
   THE INTERRUPT ROUTINE KEEPS US FROM BEING RE-ENTERED. */

DCL CLAV.BITS(5)  FIXED PUBLIC;    /* holds keyboard key state bits on old keyboard */

BEGIN;                      /* INITIALIZATION - MUST DO BEFORE FIRST 'ENABLE' */
   DCL I FIXED;
   DO I=0 TO 4; CLAV.BITS(I)="7777"; END;
   CLAV.BITS(5)=1;
   OUR.SEQ=-1;                /* since it is not read into memory during boot, leave seq 1 light off */
END;

SCAN.ORK.FOR.NOTES:     PROC PUBLIC;       /* CREATE LIST OF NEW NOTES ON KEYBOARD */
  DCL MAX.KEY     DATA (11,11,11,11,11,1); /* NUMBER OF KEYS IN EACH OCTAVE */
  DCL (I,J,K,L,M,N) FIXED;

  WRITE(CREG)="20";               /* FIRST STOP THE WRITE IN PROGRESS */
  DO I=0 TO 5;                    /* SCAN THE KEYBOARD - 5 OCTAVES + 1 NOTE */
    WRITE(CREG)=I\"100";          /* SET UP ADDRESS WITH READ BIT*/
    J=READ(DREG);                 /* GET NEW BITS */
    IF CLAV.BITS(I)<>J THEN DO;   /* QUICKLY DETECT CHANGE IN REGISTER DATA */
       M=J XOR CLAV.BITS(I);      /* COMPUTE BITS THAT ARE DIFFERENT */
       DO K=0 TO MAX.KEY(I);      /* MUST TEST EACH BIT TO SEE WHICH BITS DIFFER */
          IF (M&BITS(K)) <> 0 THEN DO;    /* THIS BIT IS DIFFERENT    */
             L=I*12+K+12+KBD_TRANSPOSE;   /* COMPUTE KEY NUMBER 12-72 */
             DISABLE;             /* SO EXT CLOCK CODE WON'T INTERRUPT US AND CHANGE NEW.NOTE.STAK(0) */
             IF NEW.NOTE.STAK(0)<NEW.NOTE.LIST.SIZE THEN DO;    /* ADD TO LIST */
                NEW.NOTE.STAK(0)=NEW.NOTE.STAK(0)+1;
                NEW.NOTE.KEY#(NEW.NOTE.STAK(0))=L;     /* STORE KEY NUMBER */
                IF (J&BITS(K))=0 THEN DO;              /* NEW KEY - SET TO MAX VELOCITY FOR OLD KEYBOARD - NOTE NEGATIVE LOGIC OF OLD HARDWARE */
                   NEW.NOTE.STAK(NEW.NOTE.STAK(0))=1;  /* CODE FOR NEW NOTE */
                   NEW.NOTE.VEL (NEW.NOTE.STAK(0))=RTE.MAX;   /* SET MAX VELOCITY */
                   NEW.NOTE.TIME(NEW.NOTE.STAK(0))=KBD.MILLISECONDS+KBD.SYNC.DELAY;
                   // Inform interpreter we have a new key to process
                   if (NEWKEY == 0) interp_newkey_pending(true);
                   NEWKEY=1;
                END;
                ELSE DO;                               /* HANDLE KEY RELEASE */
                   NEW.NOTE.STAK(NEW.NOTE.STAK(0))=2;  /* CODE FOR NOTE RELEASE */
					    NEW.NOTE.TIME(NEW.NOTE.STAK(0))=0;  // no time stamp for keyboard notes
                END;
                CLAV.BITS(I)=CLAV.BITS(I) XOR BITS(K); /* TOGGLE BIT IN OLD REGISTER - DO IT THIS WAY TO SAVE BUTTON FOR NEXT TIME IN CASE OF STACK OVERFLOW */
             END;
             ENABLE;
          END;
       END;
    END;
  END;
  WRITE(CREG)=I;      /* AND OFF WITH READ */
  WRITE(CREG)="20";   /* SELECT EXTERNAL I/O ADDRESS COUNTER */
  WRITE(CREG)="260";  /* SET UP EXTERNAL WRITE, START COUNTING */
END SCAN.ORK.FOR.NOTES;

/* $PAGE - BUTTON HARDWARE DRIVERS: (ORIGINAL PANEL) */

/* THE FOLLOWING ROUTINES ARE THE HARDWARE DRIVERS FOR THE BUTTONS ON
.THE SYNCLAVIER II PANEL:

.   SCAN.NEW.BUTTONS    -  STACKS BUTTON CHANGES ON NEW.BUTTON.LIST
.                         (STORES PHYSICAL BUTTON NUMBER ON STACK.  MAPPED
.                          TO LOGICAL BUTTON NUMBER LATER).
.
.   CLEAR.LIGHT         -  TURNS OFF A LIGHTED BUTTON (PASS PBN).
.
.   SET.LIGHT           -  TURNS ON  A         BUTTON (PASS PBN).
.
.   BLINK.LIGHT         -  SETS A BUTTON TO BLINK (PASS PBN).
*/

/* DRIVERS FOR THE OLD (ORIGINAL) HARDWARE: */

DCL DISPLAYBITS(7) FIXED;   /* HOLDS DISPLAY INFO ON OLD KEYBOARD */
dcl PRIORBITS  (7) FIXED;
DCL BLINKBITS  (7) FIXED;   /* USED FOR BLINKING  ON OLD KEYBOARD */

dcl synth.ork.lites lit 'false';
dcl debug.ork.lites lit 'false';

#if (synth.ork.lites)
   dcl ork.test fixed;
#endif

SCAN.NEW.ORK.BUTTONS:  PROC PUBLIC;    /* CREATE LIST OF NEW BUTTONS DOWN - STACKS PHYSICAL BUTTON NUMBERS ON STACK */
  DCL (I,J,K,L)  FIXED;
  DCL (PBN)      FIXED;
  DCL (PPAN) (7) FIXED STATIC;         /* PREVIOUS PANEL SETTINGS - NEEDED TO DETECT CHANGES */

  DO I=0 TO 7;              /* LOOP OVER EACH PANEL             */
    DISABLE;                /* AVOID CLOCK INTERRUPTS FOR THE MOMENT */
    WRITE(CREG)=  "020";    /* FIRST STOP THE WRITE IN PROGRESS */
    WRITE(CREG)=I\"010";    /* SET UP ADDRESS */
    WRITE(CREG)=I\"110";    /* NOW READ THEM FIRST */
    J=READ(DREG);           /* AND READ NEW SETTING */
    WRITE(CREG)=I\"010";    /* AND OFF WITH READ */
    ENABLE;                 /* CAN SCAN THE KEYBOARD NOW */
    IF J<>PPAN(I) THEN DO;  /* DIFFERENCE FOUND - PUT ON CHANGE STACK */
       L=J XOR PPAN(I);     /* GET DIFFERENCES */
       DO K=0 TO 15;        /* MUST TEST EACH BIT TO SEE WHICH BITS DIFFER */
          IF (L&BITS(K)) <> 0 THEN DO; /* THIS BIT IS DIFFERENT */
             PBN=(I*16+K) | BUTTON.LIST.ORK;                   /* COMPUTE PHYSICAL BUTTON NUMBER 0-127; indicate from ORK */
             IF (J&BITS(K))<>0 THEN PBN=PBN\BUTTON.LIST.HELD;  /* SET "100000" BIT ON IF PRESS - LEAVE OFF IF BUTTON RELEASE */
             IF NEW.BUTTON.LIST(0)<BUTTON.LIST.SIZE            /* SEE IF ROOM ON STACK */
             THEN DO;       /* ADD TO LIST */
                NEW.BUTTON.LIST(0)=NEW.BUTTON.LIST(0)+1;
                NEW.BUTTON.LIST(NEW.BUTTON.LIST(0))=PBN; /* STORE PBN, WITH OR WITHOUT "100000" BIT SET */
                ANY.MISC.FUNCTIONS = TRUE;
                PPAN(I)=PPAN(I) XOR BITS(K);             /* TOGGLE BIT IN OLD REGISTER - DO IT THIS WAY TO SAVE BUTTON FOR NEXT TIME IN CASE OF STACK OVERFLOW */
             END;
          END;
       END;
    END;

    /* MUST DISPLAY INFO HERE FOR OLD PANEL: */
    #if (synth.ork.lites)
       if (shr(ork.test, 4) == I)
          k = bits(ork.test & 0xF);
       else
          k = 0;
      
       if (k != PRIORBITS(i)) {
          PRIORBITS(i) = k;
          DISABLE;             /* RESTORE INTERRUPTS TO OFF CONDITION */
          WRITE(CREG)=  "020"; /* FIRST STOP THE WRITE IN PROGRESS    */
          WRITE(CREG)=I\"010"; /* RESTORE ADDRESS,  WITH NO READ      */
          WRITE(DREG)=k;
          ENABLE;
       }

    #else
       IF (REAL.MILLISECONDS&"300")<>0                   /* BLINK FIRST */
       THEN K=DISPLAYBITS(I)\J;                          /* LIGHT THOSE PRESSED IN CASE BUSTED */
       ELSE K=(DISPLAYBITS(I)&(NOT(BLINKBITS(I))))\J;
       
       if (k != PRIORBITS(i)) {
          #if (debug.ork.lites)
             send 'ORK ',CHR(asc.0+I),':',octal(k);
          #endif
          PRIORBITS(I) = k;
          DISABLE;             /* RESTORE INTERRUPTS TO OFF CONDITION */
          WRITE(CREG)=  "020"; /* FIRST STOP THE WRITE IN PROGRESS    */
          WRITE(CREG)=I\"010"; /* RESTORE ADDRESS,  WITH NO READ      */
          WRITE(DREG)=k;
          ENABLE;
       }
    #endif

  END;

  DISABLE;
  WRITE(CREG)="20";   /* SET UP EXTERNAL WRITE AGAIN */
  WRITE(CREG)="260";  /* START CONVERSION, SET UP EXTERNAL WRITE */
  ENABLE;

   #if (synth.ork.lites)
      ork.test = (ork.test + 1) & 0x7F;
   #endif

END SCAN.NEW.ORK.BUTTONS;

/* $PAGE - LOW LEVEL DRIVERS FOR CLEARING/BLINKING/SETTING BUTTONS (ORIGINAL PANEL) */

CLEAR.ORK.LIGHT:  PROC(LIGHT.NUM);      /* CLEARS A BUTTON - PASS PHYSICAL BUTTON NUMBER */
   DCL LIGHT.NUM FIXED;

   WRITE(5)=LIGHT.NUM; WRITE(7)=16; /* DIVIDE BY 16 TO GET PANEL, BIT */
   DISPLAYBITS(READ(5))=DISPLAYBITS(READ(5)) & (NOT(BITS(READ(4)))); /* CLEAR DISPLAY BIT */
   BLINKBITS  (READ(5))=BLINKBITS  (READ(5)) & (NOT(BITS(READ(4)))); /* CLEAR BLINK BIT AS WELL */
END CLEAR.ORK.LIGHT;

SET.ORK.LIGHT:  PROC(LIGHT.NUM);        /* SETS A LIGHT TO ON - PASS A PHYSICAL BUTTON NUMBER */
   DCL LIGHT.NUM FIXED;

   CALL CLEAR.ORK.LIGHT(LIGHT.NUM);     /* CALL OFF - COMPUTES INFO, CLEARS BLINKBITS - RETURN INFO IN D4 & D5 */
   DISPLAYBITS(READ(5))=DISPLAYBITS(READ(5)) \ BITS(READ(4)); /* SET DISPLAY BIT - BLINK BIT HAS BEEN CLEARED */
END SET.ORK.LIGHT;

BLINK.ORK.LIGHT:  PROC(LIGHT.NUM);      /* SETS A LIGHT TO BLINK - PASS A PHYSICAL BUTTON NUMBER */
   DCL LIGHT.NUM FIXED;

   CALL SET.ORK.LIGHT(LIGHT.NUM);       /* SET TO ON - RETURN INFO IN D4 & D5 */
   BLINKBITS  (READ(5))=BLINKBITS  (READ(5)) \ BITS(READ(4)); /* SET BLINK BIT AS WELL */
END BLINK.ORK.LIGHT;

ASSIGN.ORK.MULTIPLE:PROC(STARTING.LPN,ENDING.LPN,STATE) PUBLIC;	/* ASSIGN SAME STATE TO MANY BUTTONS */
	DCL (I,STARTING.LPN,ENDING.LPN,STATE,ORK.BUT) FIXED;

	DO I=STARTING.LPN TO ENDING.LPN-1;	/* ASSIGN EACH ONE */
      WRITE(MAM)=ORK.PTR+SHR(I,8);		/* SET UP XMEM ADDR INTO PBN TABLE */
      WRITE(MAL)=I;
      ORK.BUT=READ(MD);                   /* FIND PHYSICAL BUTTON FOR THIS LPN */
      
      IF ((ORK.BUT&"020000") != 0) DO CASE (STATE);	/* BRANCH */
			CALL CLEAR.ORK.LIGHT(ORK.BUT&"017777");
			CALL SET.ORK.LIGHT  (ORK.BUT&"017777");
			CALL BLINK.ORK.LIGHT(ORK.BUT&"017777");
		END;
	END;
END ASSIGN.ORK.MULTIPLE;

/* $PAGE - HARDWARE DRIVERS FOR ANALOG/SWITCH INPUTS (ORIGINAL PANEL) */

SCAN.ORK.ANALOG.INPUTS:  PROC PUBLIC; /* READ ANALOG INPUTS AND DIGITAL SWITCHES */
   DCL (I,J) FIXED;
   DCL AD    LIT '"163"';    /* AD CONVERTER    - OLD PANEL */
   DCL SW    LIT '"160"';    /* SWITCH REGISTER - OLD PANEL */ // same as CHAN
   DCL PSW   FIXED;

   IF (READ(SW)&"374")<>PSW THEN DO; /* CHANGE IN SWITCHES */
      SW1.CHANGES=1; SW2.CHANGES=1;  /* HAVE SOME DIFFERENCES FROM LAST CHECK */
      PSW=READ(SW)&"374";            /* GET NEW ONES */
      I=4;                           /* SCAN INPUT SWITCHES */
      DO J=0 TO 5;                   /* ALL SIX OF THEM */
        SWITCHDATA(J)=((PSW&I)<>0);  /* TRUE IF NONZERO */
        I=SHL(I,1);
      END;
   END;

   /* IN-LINE CODE TO MAP ANALOG DATA INTO SAME VALUES AS FOR NEW KBD */

   WRITE("313")=ADDR(ANALOG.IN(0)); /* SET UP PTR TO ANALOG INPUT ARRAY */
   WRITE(AD)=2+SHL(0,2);
   WRITE("373")=READ(AD);        /* READ KNOB POS      */
   WRITE(AD)=2+SHL(1,2);
   WRITE("373")=READ(AD);        /* READ RIBBON POS    */
   WRITE(AD)=2+SHL(4,2);
   WRITE("373")=READ(AD);        /* READ PEDAL 2 POS   */
   WRITE(AD)=2+SHL(3,2);
   WRITE("373")=READ(AD);        /* READ PEDAL 1 POS   */
   WRITE(AD)=2+SHL(2,2);
   WRITE("373")=READ(AD);        /* READ PWHEEL POS    */
   /* THE OTHER 3 INPUTS (MWHEEL,BREATH,UNUSED) ARE NOT AVAILABLE ON THE OLD KBD */

   WRITE(AD)=3; /* INITIATE NEXT ADC CONVERSION CYCLE */

END SCAN.ORK.ANALOG.INPUTS;

/* $PAGE - HARDWARE DRIVERS FOR DIGITAL WINDOW (ORIGINAL PANEL) */

/* FIRST INTERNAL DRIVER ROUTINES - NOT CALLED FROM MAIN PROGRAM         */

DCL WINDOW.BITS(2) FIXED; /* HOLDS BITS FOR DISPLAY                      */

LOAD.ORK.DISPLAY:PROC;    /* ROUTINE TO LOAD INFO INTO 4 DIGIT DISPLAY IF ORIGINAL SYNCLAVIER II */
  DCL (I) FIXED;

  DISABLE;            /* AVOID KEYBOARD SCAN RIGHT HERE */
  WRITE(CREG)="20";   /* FIRST STOP THE WRITE IN PROGRESS */
  DO I=0 TO 2; /* WRITE OUT 3 WORDS */
    WRITE(CREG)=I;    /* SET UP ADDRESS */
    WRITE(DREG)=WINDOW.BITS(I); /* AND NUMBER TO DISPAY IN LEDS */
    WRITE(CREG)=I\"40"; WRITE(CREG)=I; /* PULSE EXW FOR LATCH STROBE */
  END;
  WRITE(CREG)="20";   /* SET UP EXTERNAL WRITE AGAIN */
  WRITE(CREG)="260";  /* START CONVERSION, SET UP EXTERNAL WRITE */
  ENABLE;
END LOAD.ORK.DISPLAY;

CLEAR.ORK.DISPLAY:PROC;    /* CALL TO CLEAR DISPLAY WINDOW */
   WINDOW.BITS(0)=0; WINDOW.BITS(1)=0; WINDOW.BITS(2)=0;
   CALL LOAD.ORK.DISPLAY;  /* ZAP THE DISPLAY */
END CLEAR.ORK.DISPLAY;
