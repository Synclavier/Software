/*	:SYNRSOU:05-BUTT:172-PRF2  $TITLE  ROUTINES TO PROCESS SEQUENCER BUTTON PRESSES - START, STOP, RECORD, PUNCH IN	*//*Modified:1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE.1998/07/09 - TY  - Fixed bug in COMPUTE.LOOP.END.TIME that caused justified endloops						 to be 1 millisecond early when using a click track.1998/06/30 - TY  - Restructured COMPUTE.NEAREST.BEAT.TIME to avoid unnecessary						 computation if CLICK.TRACK.MODE ilt 3.1998/06/25 - TY  - Moved SELECT.PARAMETER to 171-PRF1 since it is now called from						 PARAMETER.BUTTON which is defined there.1991/08/23 - PF  - Fix to COMPUTE.LOOP.END.TIME in justify mode1991/02/14 - CJ  - Moved some routines here from 171-prf11991/01/09 - PF  - various bug fixes for sequencer and MIDInet1990/11/06 - PF  - Add call to START.MIDI.SUSTAIN in CONTINUE.SEQUENCER1990/07/16 - PF  - Made CLEAR.LOOP.PARMS work with Meter Map1990/07/10 - PF  - Modified COMPUTE.LOOP.END.TIME to work with Meter Map1990/07/10 - PF  - Modified COMPUTE.NEAREST.BEAT.TIME to work with Meter Map1990/07/10 - PF  - Replace calls to DISPLAY.BEAT.NUMBER with NEW.BEAT.NUMBER flag1990/06/15 - CJ  - USE FORCE.TIME.MESSAGE INSTEAD OF LAST TIME MESSAGE						 TO FORCE A CURRENT TIME MESSAGE1990/01/25 - MWH - Fix "300 msec delay starting cues" bug (from EditView)1989/08/24 - PF  - Add check for ext.clock.mode=5 (MIDInet Sync) in CONTROL.SEQUENCER1989/06/20 - MWH - Add "play to" time for the sequencer1989/06/08 - MWH - Process start/stop record protocol packets faster1989/03/14 - PF  - Added HELD.STOP.BUTTON1989/01/19 - MWH - Add Auto Punch feature, move procs to 173-PRF31988/12/09 - CJ  - bug fix for Rev. 4 SMPTE recording with an offset1988/12/02 - CJ  - HANDLED POLYPHONY + STOP1988/11/10 - PF  - bug fix for SPLIT function and STOP button1988/10/23 - CJ  - CHANGES TO CONTINUE.SEQUENCER AND PROCESS.RECORD.BUTTON						 TO FIX PROBLEMS WITH VITC RECORDING1988/10/21 - TSS - DISABLE VOICE OUTPUT IF RS22 PROTOCOL THERE1988/04/12 - PF  - ADDED CODE FOR ENABLE/DISABLE MULTI RECORD MODE1988/04/12 - PF  - ADDED CODE FOR ENABLE/DISABLE CHANNEL PRESSURE CONVERSION1988/03/30 - EG  - ADDED CODE TO ENABLE/DISABLE ILP PROCESSING1987/11/14 - CJ  - ADDED MARK.START.POINT.SUBROUTINE, SET.SEQUENCER.MARK.START.POINT;1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"1986/12/19 - TS  - FIXED BUG IN INSERT/DELETE END TIME COMPUTATION DURING MARK&CONTINUE1986/12/15 - CJ  - DISPLAY CRM ON ORK.  ALSO END LOOP BUTTON DISPLAY ON ORK1986/12/05 - CJ  - MODIFIED CONTROL.SEQUENCER SO MIDI START ALWAYS GOES FROM TOP1986/12/04 -CJ,TS- ADDED MIDI SONG PTR SYNC UP1986/11/25 - TS  - ENHANCED INSERT/DELETE LEN DISPLAY1986/11/21 - ts  - added enhancements to mark button code1986/11/18 - TS  - ADDED CODE TO DEBOUNCE INSERT/DELETE OPERATIONS1986/11/14 - TS  - MADE SOME CHANGES TO CHAIN BUTTON CODE1986/11/13 - TS  - CHAIN!!!1986/11/11 - TS  - MADE SOME CHANGES TO FF/REWIND LOGIC & MORE INSERT/DELETE CODE*/DCL (LAST.FF.REWIND.PRESS)	FIXED PUBLIC;	/*	ABS TIME WHEN FF/REWIND BUTTON WAS LAST PRESSED	*/DCL (HELD.STOP.BUTTON)		FIXED PUBLIC;	/*	SET TO 1 IF STOP			 BUTTON PRESSED	*/DCL (HELD.REWIND.BUTTON)	FIXED PUBLIC;	/*	SET TO 1 IF REWIND		 BUTTON PRESSED	*/DCL (HELD.FF.BUTTON)			FIXED PUBLIC;	/*	SET TO 1 IF FAST FORWARD BUTTON PRESSED	*/DCL (NUM.ENABLED.TRKS)		FIXED PUBLIC;DCL HELD.SCALE.ADJUST.BUTTON	FIXED PUBLIC;	/*	SET TO 1 IF SCALE ADJUST BUTTON HELD, ELSE 0	*/TAKE.PRE.ROLL.TIME:  PROC PUBLIC SWAPABLE;	/*	SNAPSHOT THE CURRENT SEQUENCER TIME	*/	DCL SEQ.TIME (1)	FIXED;						/*	GET CURRENT SEQUENCE TIME INTO HERE	*/	IF AUTO.PUNCH.ON = 0 THEN DO;					/*	WHEN NOT IN AUTO PUNCH, REMEMBER WHERE WE WANT THE MARK	*/		CALL TAKE.SYSTEM.REAL.TIME(SEQ.TIME);	/*	GET THE CURRENT SEQUENCER REAL TIME	*/		IF SEQ.TIME(LW#MSB) < 0		OR COM16(ZERO.TIME,SEQ.TIME) = LW#IGT		THEN CALL STR32(0,ZERO.TIME,SEQ.TIME);		PRE.ROLL.MSB = SEQ.TIME(LW#MSB);		PRE.ROLL.LSB = SEQ.TIME(LW#LSB);	END;END TAKE.PRE.ROLL.TIME;TAKE.RECORD.TIME:  PROC (OUT) PUBLIC SWAPABLE;	/*	SNAPSHOT THE CURRENT SEQUENCER TIME	*/	DCL OUT				FIXED;		/*	0=REC IN TIME; 1=REC OUT TIME	*/	DCL SEQ.TIME (1)	FIXED;		/*	GET CURRENT SEQUENCE TIME INTO HERE	*/	CALL TAKE.SYSTEM.REAL.TIME(SEQ.TIME);		/*	GET THE CURRENT SEQUENCE TIME IN REAL TIME UNITS	*/	IF SEQ.TIME(LW#MSB) < 0	OR COM16(ZERO.TIME,SEQ.TIME) = LW#IGT	THEN CALL STR32(0,ZERO.TIME,SEQ.TIME);	IF OUT = 0 THEN DO;								/*	WHEN NOT IN AUTO PUNCH, REMEMBER WHERE WE WANT THE MARK	*/		AUTO.PUNCH.IN.MSB = SEQ.TIME(LW#MSB);		AUTO.PUNCH.IN.LSB = SEQ.TIME(LW#LSB);	END;	ELSE DO;		AUTO.PUNCH.OUT.MSB = SEQ.TIME(LW#MSB);		AUTO.PUNCH.OUT.LSB = SEQ.TIME(LW#LSB);	END;END TAKE.RECORD.TIME;START.SEQUENCER:  PROC PUBLIC SWAPABLE;	/*	START SEQUENCER PLAYING	*/	CALL ABORT.BOUNCE.SMT.SKT;		/*	STOP BOUNCING UNLESS TIMBRE FRAME BUSINESS	*/	IF PLAY OR (((MARK.BUTTON.MSB<>0)\(MARK.BUTTON.LSB IGE ZERO.TIME)) & MARK.BUTTON.DISABLED=0)	THEN DO;								/*	PRESSING START WHILE PLAYING OR MARK START ACTIVE	*/		CALL STOP.RECD.MOVE.PLAY;	/*	HAVE TO STOP MOVEMENT FIRST	*/		CALL PRESET.PLAY.TIME(1);	/*	JUMP TO HYPER-SPACE	*/	END;	ELSE CALL START.PLAY;			/*	ELSE START FROM TOP	*/	CALL TAKE.PRE.ROLL.TIME;	CALL DISPLAY.SEQUENCER.STATUS;	/*	LIGHT THE CORRECT BUTTONS	*/END START.SEQUENCER;STOP.SEQUENCER:  PROC PUBLIC SWAPABLE;	IF (PLAY<>0)		CALL STOP.RECD.MOVE.PLAY();	/*	STOP SEQUENCER IF PLAYING	*/	CONT=0;	CLEAR.ERAS.BUTTON();	DISPLAY.SEQUENCER.STATUS();		/*	LIGHT THE CORRECT BUTTONS	*/END STOP.SEQUENCER;DCL SET.LOOP.START.TIME PROC (FIXED,FIXED) RECURSIVE;CONTINUE.SEQUENCER:  PROC PUBLIC SWAPABLE;	DCL (MSB,LSB)	FIXED;	IF CONT THEN DO;						/*	CONTINUE BUTTON PRESSED TWICE	*/		IF (MARK.BUTTON.DISABLED<>0)	/*	DISABLED	*/		OR ((MARK.BUTTON.MSB=0)&(MARK.BUTTON.LSB ILT ZERO.TIME))	/*	OR NOT SET AT ALL	*/		THEN DO;								/*	ONLY DO THIS IF MARK BUTTON NOT ACTIVE	*/			CALL LOOP.SAMPLE; CONT=0;	/*	PRESSING CONT TWICE	*/			IF RECD.JUST<>0 THEN CALL LOOP.JUSTIFY;	/*	JUSTIFY LOOP STARTING POINT IF IN JUSTIFIED RECORDING MODE	*/			CALL SET.LOOP.START.TIME(LOOP.SEQ.TIME.MSB,LOOP.SEQ.TIME.LSB);		END;	END;	ELSE DO;		IF ((RECD\MOVE)=0)&(PLAY<>0) THEN CONT=1;	/*	PRESSING CONT FIRST TIME	*/		IF MOVE<>0 THEN CALL STOP.MOVE;		/*	STOP MOVING	*/		IF RECD<>0 THEN CALL STOP.RECORD;	/*	STOP RECORDING HERE	*/		IF PLAY =0 THEN DO;						/*	NOT PLAYING - SET UP THINGS	*/			IF  (OVERALL.LOOP<>0)				/*	IF OVERALL LOOP ACTIVE			*/			AND (SMPTE.ONOFF = 0)				/*	AND NOT USING SMPTE				*/			THEN DO;	/*	MAKE SURE NOT PLAYING PAST END OF LOOP	*/				IF  ( LOOP.PLAY.TIME.MSB IGT GOBACK.PLAY.TIME.MSB)				OR  ((LOOP.PLAY.TIME.MSB  =  GOBACK.PLAY.TIME.MSB)				AND  (LOOP.PLAY.TIME.LSB IGE GOBACK.PLAY.TIME.LSB    ))				THEN DO;					CALL DISPLAY.ERR(28);		/*	CANNOT PLAY PAST END OF LOOP	*/					CALL DISPLAY.SEQUENCER.STATUS;	/*	LIGHT THE CORRECT BUTTONS	*/					RETURN;				END;			END;			CALL ABORT.BOUNCE.SMT.SKT;		/*	MAKE SURE BOUNCE STOPS AFTER CRM	*/			NEW.BEAT.NUMBER = 1;				/*	CAUSE BEAT# IN WINDOW TO REFRESH	*/			IF (EXT.CLOCK.MODE < 3)			/*	RESYNC CLOCK VARIABLES UNLESS		*/				RESYNC.TIME.BASE();			/*	DOING MIDI SYNC IN					*/			CALL CHECK.ALL.MIDI.TRACKS;			CALL CHECK.ALL.MIDI.RTES;			CALL START.MIDI.SUSTAIN;		/*	GET SUSTAIN STATES RIGHT		*/			CALL TAKE.PRE.ROLL.TIME;		/*	THEN CONTINUE TAKES PRE-ROLL	*/			IF (EXT.CLOCK.MODE == 0)		/*	BACK UP PLAY.TIME FOR PRECISE NOTE START	*/				BACK.UP.100.MSEC();			/*	IF NOT DOING BEAT/MIDI SYNC IN				*/			IF  (MIDI.SYNC.OUT<>0)			/*	WE ARE SENDING MIDI REAL-TIME BYTES	*/			AND (SMPTE.ONOFF=0)				/*	BUT NOT SMPTE	*/			THEN DO;				IF (MIDI.SYNC.IS.TC)				THEN DO;					PREP.FOR.MTC.OUTPUT(PLAY.TIME.MSB, PLAY.TIME.LSB, FALSE);					CALL START.TIME.BASE;		/*	ENABLE SEQUENCER TO RUN		*/				END;				ELSE IF (MIDI.LIMIT.MSB=0)&(MIDI.LIMIT.LSB ILE ZERO.TIME)				THEN DO;					DISABLE;							/*	NEED TO HAVE MIDI-CONTINUE AND START.TIME.BASE OCCUR TOGETHER	*/					CALL START.TIME.BASE;		/*	START SEQ TIMEBASE ROLLING	*/					CALL SEND.MIDI.START;		/*	CONTINUE FROM TOP: START	*/					/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/				END;				ELSE DO;					CALL MIDI.SONG.POS.PTR(MIDI.LIMIT.MSB, MIDI.LIMIT.LSB);	/*	LOCATE TO CURRENT POINT IN CASE CONTINUE	*/					DISABLE;							/*	NEED TO HAVE MIDI-CONTINUE AND START.TIME.BASE OCCUR TOGETHER	*/					CALL START.TIME.BASE;		/*	START SEQ TIMEBASE ROLLING		*/					CALL SEND.MIDI.CONTINUE;	/*	TELL MIDI DEVICES TO CONTINUE	*/					/*** NOTE: ABOVE CALL RE-ENABLES INTERRUPTS ***/				END;			END;			ELSE CALL START.TIME.BASE;		/*	START SEQUENCER TIMEBASE ROLLING	*/		END;	END;	CALL DISPLAY.SEQUENCER.STATUS;		/*	LIGHT THE CORRECT BUTTONS	*/END CONTINUE.SEQUENCER;/*	CONTINUE SEQUENCER WITH A PRE-ROLL TIME DURING WHICH NO AUDIO SOUNDS	*//*	TO GET THE SEQUENCER (AND ESPECIALLY THE DTD) UP TO SPEED PROPERLY	*/CONTINUE.SEQ.WITH.PRE.ROLL: PROC (BACKUP) PUBLIC SWAPABLE;	DCL BACKUP	FIXED;			/*	NUMBER OF 100 MSEC'S TO PRE-ROLL	*/	DCL I		FIXED;	/*	REMEMBER CURRENT LOCATION WHICH IS WHERE AUDIO STARTS AGAIN	*/	DISABLE;	DELAY.NOTE.AND.CUE.TIME(LW#MSB) = PLAY.TIME.MSB;	DELAY.NOTE.AND.CUE.TIME(LW#LSB) = PLAY.TIME.LSB;	ENABLE;	/*	REGULAR CONTINUE DOES 100 MSEC ALREADY, SO ONLY ADD MORE IF NEEDED	*/	IF BACKUP >= 2 THEN DO I=2 TO BACKUP;		CALL BACK.UP.100.MSEC;	END;	CALL CONTINUE.SEQUENCER;				/*	CLEARS DELAY.NOTE.AND.CUE.STARTS	*/	DELAY.NOTE.AND.CUE.STARTS = 1;		/*	ENABLE PRE-ROLL WITHOUT AUDIO		*/	CHECK.SEQUENCER.TIMES = 1;				/*	ENABLE CHECKING OF SPECIAL VARS	*/END CONTINUE.SEQ.WITH.PRE.ROLL;/*	$SUBTITLE  SWAPPING PROCEDURES TO FAST FORWARD AND REWIND SEQUENCER	*/FAST.FORWARD.SEQUENCER:  PROC PUBLIC SWAPABLE;	LAST.FF.REWIND.PRESS=KBD.MILLISECONDS&(NOT 1);	/*	SAVE TIME BUTTON WAS PRESSED - LOW BIT NOT SET=>FF PRESSED (KLUDGE!!)	*/	IF RECD THEN CALL STOP.RECORD;		/*	STOP RECORDING IF WE ARE	*/	IF SMPTE.ONOFF=0 THEN DO;				/*	IGNORE FF/REW IF SMPTE ON	*/		IF MOVE<>0 THEN DO;					/*	ALREADY FF OR REWIND		*/			IF MOVE.SPEED<0 THEN DO;		/*	MOVING BACKWARDS			*/				IF		  MOVE.SPEED=-32000 THEN MOVE.SPEED=-8000;				ELSE IF MOVE.SPEED=-08000 THEN MOVE.SPEED=-2000;				ELSE IF MOVE.SPEED=-02000 THEN MOVE.SPEED=	 0;			END;			ELSE IF MOVE.SPEED=0			THEN CALL START.MOVING.FORWARD;			ELSE IF MOVE.SPEED<=(+8000)	/*	NOT GOING FULL SPEED FORWARD	*/			THEN DO;				IF		  MOVE.SPEED=+8000 THEN MOVE.SPEED=+32000;				ELSE IF MOVE.SPEED=+2000 THEN MOVE.SPEED=+08000;			END;		END;		ELSE DO;									/*	START OF REWIND			*/			CALL SEND.MIDI.STOP;				/*	STOP MIDI SEQUENCERS		*/			IF PLAY=0			THEN CALL ABORT.BOUNCE.SMT.SKT;	/*	MAKE SURE BOUNCE STOPS AFTER CRM	*/			CALL START.MOVING.FORWARD;		/*	START FORWARD SLOWLY		*/			NEW.BEAT.NUMBER = 1;		END;		CALL COMPUTE.VOLUME.LEVELS;	/*	KEEP MUTE EFFECT PLEASANT	*/	END;	CALL DISPLAY.SEQUENCER.STATUS;	/*	LIGHT THE CORRECT BUTTONS	*/END FAST.FORWARD.SEQUENCER;REWIND.SEQUENCER:  PROC PUBLIC SWAPABLE;	LAST.FF.REWIND.PRESS=KBD.MILLISECONDS\1;	/*	SAVE TIME BUTTON WAS PRESSED - LOW BIT SET=>REW PRESSED (KLUDGE!!)	*/	IF RECD THEN CALL STOP.RECORD;		/*	STOP RECORDING ON FF/REW	*/	IF SMPTE.ONOFF=0 THEN DO;				/*	IGNORE FF/REW IF SMPTE ON	*/		IF MOVE<>0 THEN DO;					/*	ALREADY FF OR REWIND			*/			IF MOVE.SPEED>0 THEN DO;		/*	MOVING FORWARD					*/				IF		  MOVE.SPEED=+32000 THEN MOVE.SPEED=+8000;				ELSE IF MOVE.SPEED=+08000 THEN MOVE.SPEED=+2000;				ELSE IF MOVE.SPEED=+02000 THEN MOVE.SPEED=    0;			END;			ELSE IF MOVE.SPEED=0			THEN CALL START.MOVING.BACKWARDS;	/*	START REWINDING SLOWLY	*/			ELSE IF MOVE.SPEED>=(-8000)	/*	NOT GOING FULL SPEED BACKWARDS	*/			THEN DO;				IF		  MOVE.SPEED=-8000 THEN MOVE.SPEED=-32000;				ELSE IF MOVE.SPEED=-2000 THEN MOVE.SPEED=-08000;			END;		END;		ELSE DO;									/*	START OF REWIND			*/			CALL SEND.MIDI.STOP;				/*	STOP MIDI SEQUENCERS		*/			IF PLAY=0			THEN CALL ABORT.BOUNCE.SMT.SKT;	/*	MAKE SURE BOUNCE STOPS AFTER CRM	*/			CALL START.MOVING.BACKWARDS;	/*	START REWINDING SLOWLY	*/			NEW.BEAT.NUMBER = 1;		END;		CALL COMPUTE.VOLUME.LEVELS;		/*	KEEP MUTE EFFECT PLEASANT	*/	END;	CALL DISPLAY.SEQUENCER.STATUS;		/*	LIGHT THE CORRECT BUTTONS	*/END REWIND.SEQUENCER;/*	$SUBTITLE - ROUTINES TO SET/UNSET MARK START POINTS	*//*	MARK START POINT SUBROUTINE IS CALLED TO DO ALL THE WORK OF	*//*	ENABLING A MARK START POINT.  IT ENABLES FOR MARK START		*//*	USAGE AND DISPLAYS (ON/OFF) IN THE LOWER WINDOW (THIS 		*//*	ASSUMES THE UPPER WINDOW CONTAINS THE MARK START TIME).		*//*	A LOCATE CODE IS PASSED - IF THE CODE = 1 AND THE SEQUENCER	*//*	IS NOT PLAYING, WE WILL PRESET TO THE MARK START POINT		*//*	THIS ROUTINE WILL SEND OUT AN APPROPRIATE MIDI SONG POINTER	*//*	IF MIDI SYNC OUT IS SELECTED											*/MARK.START.POINT.SUBROUTINE: PROC (CODE) SWAPABLE;	DCL CODE		FIXED;	DCL (M,L)	FIXED;	MARK.BUTTON.DISABLED=0;					/*	ENABLE MARK FUNCTION	*/	NEW.MOTION			  =1;					/*	TELL LOD ABOUT IT		*/	CALL DISPLAY.PARAMETER.BUTTONS;		/*	LIGHT/BLINK MARK BUT	*/	IF NEW.PAN THEN DO;						/*	NEW PANEL	*/		CALL CLEAR.LOWER;		CALL EMIT.STRING(16,'MARK POINT: ON');	END;	IF  (TIME.BASE.MODE	== 0)		/*	SEND OUT SONG POS POINTER	*/	AND (MIDI.SYNC.OUT	<> 0)		/*	IF DESIRED						*/	AND (MIDI.SYNC.IS.TC	== 0)	THEN DO;		M=MARK.BUTTON.MSB; L=MARK.BUTTON.LSB;		IF (M=0) & (L ILT ZERO.TIME)		THEN L=ZERO.TIME;		IF CLICK.TRACK.MODE igt 3	/*	LIVE CLICK TRACK			*/		THEN DO;							/*	MAP TO BEATS HERE			*/			CALL REMAP.WITH.LIVE.CLICK(M,L,0,0,1);			M=REMAPPED.TIME.MSB;		/*	GET BEAT TIME				*/			L=REMAPPED.TIME.LSB;		END;		CALL MIDI.SONG.POS.PTR(M,L);	END;	IF (PLAY = 0) & (CODE <> 0) THEN DO;		IF  (MARK.BUTTON.MSB=0)		AND (MARK.BUTTON.LSB ILT ZERO.TIME)		THEN CALL PLAY.INITIALIZE;		ELSE CALL PRESET.PLAY.TIME(0);	END;END MARK.START.POINT.SUBROUTINE;/*	SET.SEQUENCER.MARK.START.POINT IS CALLED TO SET MARK START POINT	*//*	IT IS PASSED A VALUE, AND A BIT THAT TELLS WHETHER TO LOCATE		*//*	THE SEQUENCER TO THAT POINT OR NOT											*/SET.SEQUENCER.MARK.START.POINT: PROC(msw, lsw, locate.code) PUBLIC swapable;	dcl msw			fixed;		/*	msw of mark start time	*/	dcl lsw			fixed;		/*	lsw of mark start time	*/	dcl locate.code	fixed;	/*	0 = no locate.  1 = locate if not playing.  2 = stop playing then locate	*/	mark.button.msb = msw;	mark.button.lsb = lsw;	call select.parameter(mark.l-par.l);	if locate.code = 2 then do;		call STOP.SEQUENCER;		locate.code = 1;	end;	call mark.start.point.subroutine(locate.code);end SET.SEQUENCER.MARK.START.POINT;/*	$SUBTITLE  ROUTINES TO PERFORM THE LOOP BUTTON PROCEDURE	*/SET.TROUT.TRK#:  PROC SWAPABLE;					/*	USED FOR SELECTING TRK FOR LOOP DISPLAYS	*/	IF NUM.OF.HELD.TRACK.BUTTONS<>0				/*	HOLDING A TRK BUTTON	*/	THEN DO;												/*	GET # OF 1ST HELD TRK BUTTON	*/		ALLOW.TRACK.GROUP.DEFINE = FALSE;		/*	DISALLOW GROUP DEFINE WHILE CHANGING	*/		WRITE(MAM)=TBUT.PTR;							/*	INIT MAM PTR TO BUTTON STATE ARRAY	*/		TROUT.TRK#=0;									/*	START WITH FIRST TRK BUTTON	*/		DO WHILE TROUT.TRK#<NUM.TRACK.BUTTONS;	/*	CHECK EACH TRACK BUTTON	*/			IF (READ(MDI)&B.HELD.TRK)<>0			/*	TRACK BUTTON IS HELD			*/			THEN RETURN;								/*	QUIT WHEN WE FIND FIRST HELD BUTTON	*/			TROUT.TRK#=TROUT.TRK#+1;				/*	OTHERWISE STEP TO NEXT BUTTON	*/		END;	END;	ELSE TROUT.TRK#=(-1);							/*	RESET TO KBD/OVERALL	*/END SET.TROUT.TRK#;CLEAR.LOOP.PARMS:  PROC PUBLIC SWAPABLE;		/*	LOADS DEFAULT LOOP LENGTHS INTO GLOBAL LOOP PARMS	*/	DCL MEASURES(2)	FIXED;	/*	COMPUTE TIME OF 1 MEASURE COUNTIN	*/	MEASURES(0)=2;				/*	MEAUSRE #2 STARTING WITH 1	*/	MEASURES(1)=1;				/*	BEAT 1 OF MEASURE 2			*/	MEASURES(2)=0;				/*	NO FRACTIONS					*/	CALL Map.Measures.Beats.To.Sequence.Time(MEASURES,loc(addr(LOOP.START.MSB)));	/*	COMPUTE TIME OF 2 MEASURE LOOP LENGTH	*/	MEASURES(0)=4;				/*	LOOP END WILL BE AT MEASURE 4	*/	CALL Map.Measures.Beats.To.Sequence.Time(MEASURES,loc(addr(LOOP.END.MSB)));	IF CLICK.TRACK.MODE igt 3 THEN DO;	/*	LIVE CLICK TRACK - MAP TO ABS TIMES	*/		CALL REMAP.WITH.LIVE.CLICK(LOOP.START.MSB,LOOP.START.LSB,0,0,0);		LOOP.START.MSB=REMAPPED.TIME.MSB;		LOOP.START.LSB=REMAPPED.TIME.LSB;		CALL REMAP.WITH.LIVE.CLICK(LOOP.END.MSB,LOOP.END.LSB,0,0,0);		LOOP.END.MSB=REMAPPED.TIME.MSB;		LOOP.END.LSB=REMAPPED.TIME.LSB;	END;END CLEAR.LOOP.PARMS;SET.LOOP.PARMS.TO.OVERALL: PROC SWAPABLE;	/*	COPY OVERALL LOOP INFO INTO LOOP PARMS	*/	IF OVERALL.LOOP<>0					/*	WE HAVE AN OVERALL LOOP	*/	THEN DO;									/*	PICK UP VALUES FROM THERE	*/		WRITE(MAM)=BAS.PTR;		WRITE(MAL)=SEQ.S.P.T;		LOOP.START.LSB=READ(MDI);		/*	SEQ.S.P.T	*/		LOOP.START.MSB=READ(MD );		/*	SEQ.S.P.T.C	*/		IF (LOOP.START.MSB=0)&(LOOP.START.LSB ILT ZERO.TIME)		THEN LOOP.START.LSB=ZERO.TIME;	END;	ELSE DO;		LOOP.START.MSB=LOOP.SEQ.TIME.MSB;		LOOP.START.LSB=LOOP.SEQ.TIME.LSB;	END;	LOOP.END.MSB	=GOBACK.SEQ.TIME.MSB;	LOOP.END.LSB	=GOBACK.SEQ.TIME.LSB;END SET.LOOP.PARMS.TO.OVERALL;SET.LOOP.PARMS.TO.ILP: PROC SWAPABLE;	/*	COPY ILP INFO INTO LOOP PARMS	*/	DCL I	FIXED;	I=TBUT.MAPPING(TROUT.TRK#);	WRITE(MAM)=TRK.HEAD;	WRITE(MAL)=I;	IF READ(MD)<>0 THEN DO;				/*	WE HAVE A TRK HEADER	*/		WRITE(MAM)=READ(MD);		WRITE(MAL)=THD.COUNTIN.MSB;		LOOP.START.MSB=READ(MDI);		/*	READ THD.COUNTIN.MSB	*/		LOOP.START.LSB=READ(MDI);		/*	READ THD.COUNTIN.LSB	*/		LOOP.END.MSB  =READ(MDI);		/*	READ THD.LOOPLEN.MSB	*/		LOOP.END.LSB  =READ(MD );		/*	READ THD.LOOPLEN.LSB	*/		IF  (LOOP.START.MSB	=  0)		AND (LOOP.START.LSB ILT ZERO.TIME)		THEN LOOP.START.LSB=ZERO.TIME;		/*	ADD COUNTIN TO LOOPLEN TO GET TRUE LOOP.END	*/		LOOP.END.MSB=LOOP.END.MSB+LOOP.START.MSB;		LOOP.END.LSB=LOOP.END.LSB+LOOP.START.LSB;		IF LOOP.END.LSB ILT LOOP.START.LSB		THEN LOOP.END.MSB=LOOP.END.MSB+1;	END;END SET.LOOP.PARMS.TO.ILP;/*	Set Loop Start Time is passed a starting time in SEQUENCE time units.	*//*	It sets up the global variabls LOOP.START.MSB & LSB, and also stores		*//*	this information in the external memory sequence.								*/SET.LOOP.START.TIME: PROC (MSB,LSB) PUBLIC SWAPABLE;	/*	SET LOOP.START TO PASSED TIME & SELECT OVERALL LOOP START PARM	*/	DCL (MSB,LSB)	FIXED;	WRITE(MAM)=BAS.PTR;	WRITE(MAL)=SEQ.S.P.T;	WRITE(MDI)=LSB;							/*	COPY INTO SEQ.S.P.T		*/	WRITE(MD )=MSB;							/*	COPY INTO SEQ.S.P.T.C	*/	TROUT.TRK#=(-1);							/*	SHOW OVERALL LOOP PARMS	*/	LOOP.START.MSB=MSB;						/*	SET UP TO NEW INFO		*/	LOOP.START.LSB=LSB;	LAST.LOOP.PARM=0;							/*	DISPLAY LOOP START TIME	*/	CALL DISPLAY.PAR;							/*	CAUSE REDISPLAY	*/END SET.LOOP.START.TIME;/*	$PAGE	*/COMPUTE.LOOP.END.TIME: PROC	FIXED SWAPABLE;	/*	CALCULATE TIME TO END REAL-TIME LOOPS AT	*/	DCL I		FIXED;	DCL X		FIXED;	DCL Y		FIXED;	DCL MSB	FIXED;	DCL LSB	FIXED;	/*	COMPUTES TIME AT WHICH A REAL-TIME	*/	/*	LOOP SHOULD END.  IF SUCCESSFUL,		*/	/*	PUTS LOOP END TIME INTO #MSB,#LSB	*/	/*	AND RETURNS 1, OTHERWISE RETURNS 0	*/	DISABLE;								/*	NO INTERRUPTS IN FOLLOWING CODE	*/	/*	JUSTIFY THE LOOP END TIME TO THE NEAREST CLICK:						*/	IF  ( ADVANCED.PLAY.TIME.MSB IGT LOOP.PLAY.TIME.MSB )	/*	MAKE SURE WE	*/	OR  ((ADVANCED.PLAY.TIME.MSB	=  LOOP.PLAY.TIME.MSB)	/*	WILL LOOP BACK	*/	AND  (ADVANCED.PLAY.TIME.LSB IGT LOOP.PLAY.TIME.LSB))	/*	PROTECT AGAINST	*/	THEN DO;									/*	WIERD TRK SOLO SITUATIONS (OR MARK BUTTON AFTER REWIND)	*/		IF (CONT\RECD.JUST)<>0			/*	USER WANTS JUSTIFIED LOOP	*/		&& CLICK.TRACK.MODE<>3			/*	CAN'T JUSTIFY WITH EXTERNAL CLICK	*/		THEN DO;								/*	MAKE LOOP AN EVEN NUMBER OF CLICKS LONG	*/			IF (CLICK.TRACK.MODE == 0)	/*	INTERNAL CLICK	*/			THEN DO;				/*	first compute sequence time of loop.next.click	*/				call Map.Sequence.Time.To.Nearest.Clicks(loc(addr(Loop.Seq.Time.Msb)),																	  loc(addr(x)),																	  loc(addr(msb)));				I=lsb-Loop.Seq.Time.Lsb;					/*	sequence delta amount to adjust loop end by	*/				/*	get sequence time of advanced.next.click	*/				call Map.Sequence.Time.To.Nearest.Clicks(loc(addr(Advanced.Seq.Time.Msb)),																	  loc(addr(x)),																	  loc(addr(msb)));				IF I IGT lsb THEN #MSB=msb-1;				/*	JUSTIFY LOOP END	*/				else #MSB=msb;				#LSB=lsb-I;				DO WHILE ((#MSB ILT ADVANCED.SEQ.TIME.MSB))	/*	JUSTIFIED TIME		*/				OR  ((#MSB	=  ADVANCED.SEQ.TIME.MSB)			/*	COMES BEFORE OUR	*/				AND  (#LSB ILE ADVANCED.SEQ.TIME.LSB));		/*	ADVANCED TIME		*/																			/*	SO BUMP LOOP END AHEAD ONE FULL BEAT	*/					/*	get sequence time of next click	*/					call Map.Sequence.Time.To.Nearest.Clicks(loc(addr(msb)),																		  loc(addr(x)),																		  loc(addr(msb)));					IF I IGT lsb THEN #MSB=msb-1;			/*	JUSTIFY LOOP END	*/					else #MSB=msb;					#LSB=lsb-I;				END;				/*	now map the justified loop end time back to real time	*/				call Map.Sequence.Time.To.Real.Time(loc(addr(#MSB)),loc(addr(#MSB)));			END;			ELSE DO;							/*	CLICK TRACK	*/																	/*	ESTIMATE GOBACK TIME	*/				#MSB=ADVANCED.PLAY.TIME.MSB;				/*	COMPUTE ABS TIME OF NEXT CLICK	*/				#LSB=LAST.CLICK+EST.RATE;					/*	LSB OF ESTIMATED NEXT CLICK		*/				IF  (#LSB  >  ADVANCED.PLAY.TIME.LSB)				AND (#LSB ILT ADVANCED.PLAY.TIME.LSB)				THEN #MSB=#MSB+1;				ELSE IF  (#LSB  <  ADVANCED.PLAY.TIME.LSB)				AND      (#LSB IGT ADVANCED.PLAY.TIME.LSB)				THEN #MSB=#MSB-1;				/*	Map LOOP.SEQ.TIME.MSB,LSB to real time	*/				/*	This time should be used in lieu of LOOP.PLAY.TIME.MSB,LSB because LOOP.PLAY.TIME.MSB,LSB was set to	*/				/*	1 sequencer delta before FIRST.PLAY.TIME.MSB,LSB in the call to ADVANCE.SEQUENCER in PLAY.INITIALIZE.	*/				call Map.Sequence.Time.To.Real.Time(loc(addr(Loop.Seq.Time.Msb)),loc(addr(MSB)));				I=LOOP.NEXT.CLICK-LSB;	/*	AMOUNT TO ADJUST LOOP LEN BY	*/				IF I IGT #LSB THEN #MSB=#MSB-1;			/*	SUBTRACT TIME FROM LOOP END TO CORRECT FOR UPBEAT (IF ONE)	*/				#LSB=#LSB-I;				IF ((#MSB ILT ADVANCED.PLAY.TIME.MSB))	/*	JUSTIFIED TIME		*/				OR ((#MSB  =  ADVANCED.PLAY.TIME.MSB)	/*	COMES BEFORE OUR	*/				AND (#LSB ILE ADVANCED.PLAY.TIME.LSB))	/*	ADVANCED TIME		*/				THEN DO;				/*	SO BUMP LOOP END AHEAD ONE FULL BEAT.	*/					/*	UNFORTUNATELY, EST.RATE DOESN'T NECESSARILY REPRESENT THE DISTANCE BETWEEN NEXT.CLICK AND THE ONE AFTER,	*/					/*	SO OUR ENDLOOP PROBABLY WON'T ANTICIPATE THE BEAT BY THE SAME AMOUNT THAT THE STARTLOOP DOES.				*/					#LSB=#LSB+EST.RATE;					IF #LSB ILT EST.RATE THEN #MSB=#MSB+1;				END;				/*	TO DO THIS BETTER WE REALLY SHOULD HAVE	*/				/*	A LOOP.EST.RATE VARIABLE.     (????)		*/			END;		END;								/*	OF MAKE A JUSTIFIED LOOP	*/		ELSE DO;							/*	LOOP ON NEXT INTERRUPT IF NOT JUSTIFIED	*/			#MSB=ADVANCED.PLAY.TIME.MSB;			#LSB=ADVANCED.PLAY.TIME.LSB+1;			IF #LSB=0 THEN #MSB=#MSB+1;		END;		I=1;								/*	COMPUTED TIME WAS A-OK	*/		call Map.Real.Time.To.Sequence.Time(loc(addr(#msb)), loc(addr(#msb)));	END;	ELSE I=0;							/*	INVERTED LOOP TIMES	*/	ENABLE;								/*	OK TO RE-ENABLE NOW	*/	RETURN I;							/*	RETURN STATUS INFO	*/END COMPUTE.LOOP.END.TIME;/*	$PAGE	*/TOGGLE.ILP: PROC SWAPABLE;	DCL (I,J,K)	FIXED;	K=0;										/*	ASSUME NO TRKS WANT NEW ILP	*/	DO I=0 TO NUM.TRACK.BUTTONS-1;	/*	CHECK EACH TRACK BUTTON		*/		WRITE(MAM)=TBUT.PTR;				/*	POINT TO BUTTON STATE ARRAY	*/		WRITE(MAL)=I;						/*	SELECT THIS BUTTON			*/		IF (READ(MD)&B.HELD.TRK)<>0	/*	TRACK BUTTON IS HELD			*/		THEN DO;								/*	TOGGLE STATE OF ILP ON TRK	*/			J=READ(MD)&255;				/*	GET LOGICAL TRK FOR BUTTON	*/			IF  (J >= FIRST.LOD.TRACK)	/*	IF TRK IS A LOD TRACK		*/			AND (J <  LAST.LOD.TRACK)			THEN DO;				CALL DISPLAY.ERR(43);	/*	CANNOT PUT ILP ON LOD TRK	*/				CONT=0;				RETURN;			END;			IF TRK.HEAD.LOOKUP(J,THD.ILP)=0 THEN K=1;	/*	WE WANT TO PUT AN ILP ON TRK	*/		END;	END;	IF  (PLAY<>0) AND (K<>0)		/*	REAL-TIME ILP AND HAVE SOME TO DO	*/	THEN DO;								/*	CREATE INDEPENDENT LOOP IN REAL TIME	*/		IF COMPUTE.LOOP.END.TIME=0	/*	INVERTED LOOP TIMES		*/		THEN DO;			CALL DISPLAY.ERR(50);	/*	DISPLAY ERROR MESSAGE	*/			CONT=0;			RETURN;						/*	AND BOMB OUT				*/		END;		/*	OTHERWISE LOOP END TIME SITS IN #MSB,#LSB	*/	END;	ELSE IF K<>0 THEN DO;			/*	CREATE ILP IN NON-REAL TIME	*/		IF ((LOOP.START.MSB IGT LOOP.END.MSB))		OR ((LOOP.START.MSB	=  LOOP.END.MSB)		AND (LOOP.START.LSB IGT LOOP.END.LSB))		THEN DO;			CALL DISPLAY.ERR(50);	/*	DISPLAY INVERTED LOOP MESSAGE	*/			CONT=0;			RETURN;						/*	BOMB OUT								*/		END;	END;	CONT=0;	DO I=0 TO NUM.TRACK.BUTTONS-1;	/*	CHECK EACH TRACK BUTTON		*/		WRITE(MAM)=TBUT.PTR;			/*	POINT TO BUTTON STATE ARRAY	*/		WRITE(MAL)=I;					/*	SELECT THIS BUTTON				*/		IF (READ(MD)&B.HELD.TRK)<>0	/*	TRACK BUTTON IS HELD			*/		THEN DO;								/*	TOGGLE STATE OF ILP ON TRK	*/			J=READ(MD)&255;			/*	GET LOGICAL TRK FOR BUTTON	*/			WRITE(MAM)=TRK.HEAD;		/*	POINT TO TRK HEAD PTR ARRAY	*/			WRITE(MAL)=J;			IF READ(MD)=0 THEN DO;	/*	NO TRACK HEAD - ALLOCATE ONE	*/				CALL ALLOCATE.TRK.HEADER(J);	/*	TRY TO ALLOCATE TRK HEAD	*/				WRITE(MAM)=TRK.HEAD;	/*	LOOK UP TRK HEAD PTR			*/				WRITE(MAL)=J;			END;			IF READ(MD)<>0 THEN DO;	/*	TRACK HEAD EXISTS				*/				WRITE(MAM)=READ(MD);	/*	POINT TO TRK HEAD				*/				WRITE(MAL)=THD.ILP;	/*	SEE IF TRK ALREADY HAS ILP	*/				IF READ(MD)=0			/*	NO ILP ON THIS TRK			*/				THEN DO;					/*	TRY TO CREATE ONE				*/					IF PLAY<>0 THEN DO;	/*	APPLY ILP IN REAL-TIME	*/						LOOP.START.MSB=LOOP.SEQ.TIME.MSB;						LOOP.START.LSB=LOOP.SEQ.TIME.LSB;						LOOP.END.MSB  =#MSB;						LOOP.END.LSB  =#LSB;						IF LAST.LOOP.PARM=0 THEN LAST.LOOP.PARM=1;	/*	CAUSE DISPLAY  OF END TIME	*/						CALL CREATE.ILP.ON.TRACK(J,LOOP.SEQ.TIME.MSB,LOOP.SEQ.TIME.LSB,#MSB,#LSB);	/*	PASS TRK # AND LOOP END TIME	*/					END;					ELSE DO;				/*	APPLY ILP IN NON-REAL TIME	*/						CALL PLAY.INITIALIZE;						CALL CREATE.ILP.ON.TRACK(J,LOOP.START.MSB,LOOP.START.LSB,LOOP.END.MSB,LOOP.END.LSB);						MARK.BUTTON.VALM=0; MARK.BUTTON.VALL=0;						CALL PLAY.INITIALIZE;					END;					TROUT.TRK#=I;					IF (UPPER.DISP<>ERR.DISP)					AND (NEW.PAN<>0)					THEN CALL DISPLAY.PAR;				END;				ELSE DO;					/*	REMOVE THE LOOP				*/					CALL REMOVE.ILP.FROM.TRACK(J);	/*	PASS TRACK #	*/					IF PLAY=0 THEN CALL PLAY.INITIALIZE;				END;			END;							/*	OF TRK HEAD EXISTS			*/			ELSE DO;						/*	WE JUST RAN OUT OF MEMORY	*/				CALL DISPLAY.ERR(14);	/*	OUT OF MEMORY	*/				RETURN;			END;		END;								/*	OF TRACK BUTTON IS HELD		*/	END;									/*	OF LOOP OVER TRK BUTTONS	*/END TOGGLE.ILP;/*	$PAGE	*/TOGGLE.OVERALL.LOOP: PROC SWAPABLE;	IF OVERALL.LOOP<>0		/*	THIS IS DONE BY REMOVING AN OVERALL LOOP	*/	THEN DO;						/*	IF WE HAVE ONE										*/		OVERALL.LOOP=0;		/*	DISABLE THE LOOP									*/		WRITE(MAM)=BAS.PTR;	/*	DISABLE IN SEQ HEADER TOO						*/		WRITE(MAL)=SEQ.LOOP;		WRITE(MD )=0;	END;	ELSE DO;						/*	SET A NEW OVERALL LOOP	*/		IF PLAY<>0 THEN DO;	/*	APPLY OVERALL LOOP IN REAL TIME	*/			IF COMPUTE.LOOP.END.TIME<>0	/*	NO INVERTED LOOP TIMES		*/			THEN DO;								/*	GO AHEAD AND SET UP LOOP	*/				/*	#MSB,#LSB WILL CONTAIN DESIRED LOOP END TIME	*/				/*	OKAY TO DO THIS WITH INTERRUPTS ON SINCE		*/				/*	WE ARE SURE THAT OVERALL.LOOP=0 RIGHT NOW		*/				WRITE(MAM)=BAS.PTR;			/*	SAVE INFO IN SEQ HEADER TOO	*/				WRITE(MAL)=SEQ.LOOP;				WRITE(MDI)=1;				WRITE(MDI)=#LSB;				WRITE(MDI)=#MSB;				WRITE(MDI)=LOOP.SEQ.TIME.LSB;				WRITE(MD )=LOOP.SEQ.TIME.MSB;				GOBACK.SEQ.TIME.MSB=#MSB;	/*	SET UP GLOBALS TO CORRECT	*/				GOBACK.SEQ.TIME.LSB=#LSB;	/*	TIME COMPUTED ABOVE		*/				call Map.Sequence.Time.To.Real.Time(loc(addr(GOBACK.SEQ.TIME.MSB)),																loc(addr(GOBACK.PLAY.TIME.MSB)));				OVERALL.LOOP=1;				/*	OVERALL LOOP NOW ENABLED	*/				LOOP.START.MSB=LOOP.SEQ.TIME.MSB;				LOOP.START.LSB=LOOP.SEQ.TIME.LSB;				LOOP.END.MSB  =GOBACK.SEQ.TIME.MSB;				LOOP.END.LSB  =GOBACK.SEQ.TIME.LSB;				IF LAST.LOOP.PARM=0 THEN LAST.LOOP.PARM=1;	/*	CAUSE DISPLAY OF END TIME	*/			END;			ELSE CALL DISPLAY.ERR(50);		/*	INVERTED OVERALL LOOP MESSAGE	*/		END;		ELSE DO;	/*	APPLY OVERALL LOOP IN NON-REAL TIME	*/			/*	OKAY TO DO THIS WITH INTERRUPTS ON SINCE		*/			/*	WE ARE SURE THAT OVERALL.LOOP=0 RIGHT NOW		*/			IF ((LOOP.START.MSB ILT LOOP.END.MSB))	/*	INVERTED LOOP TIMES	*/			OR ((LOOP.START.MSB	=  LOOP.END.MSB)			AND (LOOP.START.LSB ILE LOOP.END.LSB))			THEN DO;				MARK.BUTTON.VALM=0;	/*	RESET THESE VALUES TO FORCE	*/				MARK.BUTTON.VALL=0;	/*	FULL PLAY.INIT ON NEXT START	*/				LOOP.SEQ.TIME.MSB  =LOOP.START.MSB;				LOOP.SEQ.TIME.LSB  =LOOP.START.LSB;				GOBACK.SEQ.TIME.MSB=LOOP.END.MSB;				GOBACK.SEQ.TIME.LSB=LOOP.END.LSB;				call Map.Sequence.Time.To.Real.Time(loc(addr(GOBACK.SEQ.TIME.MSB)),																loc(addr(GOBACK.PLAY.TIME.MSB)));				WRITE(MAM)=BAS.PTR;			/*	SAVE INFO IN SEQ HEADER TOO	*/				WRITE(MAL)=SEQ.LOOP;				WRITE(MDI)=1;				WRITE(MDI)=#LSB;				WRITE(MDI)=#MSB;				WRITE(MDI)=LOOP.SEQ.TIME.LSB;				WRITE(MD )=LOOP.SEQ.TIME.MSB;				OVERALL.LOOP=1;				/*	NOW ENABLE OVERALL LOOP	*/				CALL PLAY.INITIALIZE;			END;			ELSE CALL DISPLAY.ERR(50);		/*	INVERTED LOOP TIMES MESSAGE	*/		END;		TROUT.TRK#=(-1);		IF (UPPER.DISP<>ERR.DISP)		AND (NEW.PAN<>0)		THEN CALL DISPLAY.PAR;	END;	CONT=0;						/*	BAG THE CONTINUE LIGHT	*/END TOGGLE.OVERALL.LOOP;/*	$SUBTITLE  ROUTINE TO PERFORM THE INSERT/DELETE FEATURE	*/DCL INSERT.DELETE.LOCKED		FIXED PUBLIC;	/*	SET TO 1 TO LOCK OUT SUBSEQUENT INSERT/DELETES	*/DCL INSERT.DELETE.UNLOCK.TIME	FIXED PUBLIC;	/*	TIME AT WHICH TO TURN OFF LOCKOUT	*/PERFORM.INSERT.DELETE: PROC SWAPABLE;	/*	DOES THE BUTTON PANEL INSERT/DELETE FUNCTION	*/	DCL (TRK,M,L,NOERR)	FIXED;	IF (HELD.INSERT.BUTTON\HELD.DELETE.BUTTON)=0 THEN RETURN;	/*	DO NOTHING	*/	IF INSERT.DELETE.LOCKED<>0                   THEN RETURN;	/*	STILL DEBOUNCING	*/	CALL CLEAR.PARAMETERS;			/*	BEST TO CLEAR PARAMS		*/	CALL STOP.RECD.MOVE.PLAY;		/*	HALT THE SEQUENCER		*/	IF HELD.INSERT.BUTTON<>0	THEN CALL EMIT.STRING(0,'Inserting...');	ELSE CALL EMIT.STRING(0,'Deleting...');	CALL PLAY.INITIALIZE;	TRK=NUM.KBD.TRACKS;	DO WHILE TRK ILT MAX.TRACKS;	/*	LOOP OVER TRKS	*/		WRITE(MAM)=TBUT.PTR;			/*	EXAMINE SOLOED BIT	*/		WRITE(MAL)=TRK;		IF ((READ(MD)&B.SOLOED.TRK)<>0)	/*	THIS TRK IS SOLOED		*/		OR (NUM.OF.SOLOED.TRACKS	 =0)	/*	OR NO TRKS ARE SOLOED	*/		THEN DO;			IF  (TRK >= FIRST.LOD.TRACK)	/*	IF THIS IS A LOD TRACK	*/			AND (TRK <  LAST.LOD.TRACK)			THEN DO;				IF (READ(MD)&B.SOLOED.TRK)<>0	/*	IF LOD TRK IS SOLOED	*/				THEN DO;					CALL DISPLAY.ERR(49);	/*	THEN GIVE ERROR MESSAGE	*/					TRK=MAX.TRACKS;			/*	BOMB OUT OF LOOP			*/				END;			END;			ELSE DO;				WRITE(MAM)=TRK.HEAD;				WRITE(MAL)=TRK;				IF READ(MD)<>0 THEN DO;		/*	WE HAVE A TRK HEAD ALREADY	*/					WRITE(MAM)=READ(MD);		/*	POINT TO TRK HEAD	*/					IF READ(MD)<>0 THEN DO;	/*	AND WE HAVE AT LEAST ONE NLS (LOOK AT THD.FOR)	*/						M=MARK.BUTTON.MSB; L=MARK.BUTTON.LSB;						IF (M=0) AND (L ILT ZERO.TIME) THEN L=ZERO.TIME;						IF HELD.INSERT.BUTTON<>0						THEN NOERR=INSERT.TIME.ON.TRK  (TRK,M,L,EDIT.LEN.MSB,EDIT.LEN.LSB);						ELSE NOERR=DELETE.TIME.FROM.TRK(TRK,M,L,EDIT.LEN.MSB,EDIT.LEN.LSB);						CALL GARBAGE.COLLECT.TRK(TRK);	/*	CLEAN UP THE TRACK AFTER DELETE	*/						IF (NOERR=0) AND (UPPER.DISP<>ERR.DISP)						THEN DO;	/*	HAD AN ERROR WITHOUT ANY MESSAGE	*/							CALL DISPLAY.ERR(0);				/*	PRESUMABLY NOT ENOUGH MEMORY	*/							TRK=MAX.TRACKS;						END;					END;				END;			END;		END;			/*	OF WANT TO INSERT/DELETE ON THIS TRK	*/		TRK=TRK+1;	/*	STEP TO NEXT TRK	*/	END;				/*	OF LOOP OVER TRACKS							*/	MARK.BUTTON.VALM=0; MARK.BUTTON.VALL=0;	/*	FORCE FULL PLAY.INITIALIZE	*/	CALL PLAY.INITIALIZE;	INSERT.DELETE.LOCKED		  = 1;						/*	LOCK OUT FOR A WHILE	*/	INSERT.DELETE.UNLOCK.TIME = REAL.MILLISECONDS;	/*	WAIT 250 MSEC TO UNLUOCK	*/	ANY.MISC.FUNCTIONS		  = TRUE;END PERFORM.INSERT.DELETE;/*	$SUBTITLE  ROUTINE TO ROUND CURRENT PLAY TIME TO NEAREST BEAT TIME	*//*	COMPUTE.NEAREST.BEAT.TIME RETURNS AN ABSOLUTE SYNCL TIME OF	*//*	THE NEAREST CLICK															*/COMPUTE.NEAREST.BEAT.TIME:  PROC (TIME) PUBLIC SWAPABLE;	/*	ROUNDS PLAY.TIME.MSB & PLAY.TIME.LSB TO NEAREST BEAT TIME	*/	DCL TIME	ARRAY;	/*	32-BIT MSEC RESULT STUFFED INTO TIME(0) & TIME(1)	*/	DISABLE;	IF CLICK.TRACK.MODE=3 THEN DO;	/*	EXTERNAL CLICK - USE LAST.CLICK	*/		TIME(0)=PLAY.TIME.MSB;			/*	BEGIN BY GETTING	*/		TIME(1)=LAST.CLICK;				/*	ABSOLUTE TIME		*/		IF PLAY.TIME.LSB ILT LAST.CLICK		THEN TIME(0)=TIME(0)-1;		IF (PLAY.TIME.LSB-LAST.CLICK) IGE SHR(EST.RATE,1)		THEN DO;			TIME(1)=TIME(1)+EST.RATE;			IF #LSB ILT EST.RATE			THEN TIME(0)=TIME(0)+1;		END;		ENABLE;		RETURN;	END;	IF (CLICK.TRACK.MODE == 0) THEN DO;	/*	INTERNAL CLICK	*/		/*	BEGIN BY GETTING CURRENT SEQUENCE TIME	*/		CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(PLAY.TIME.MSB)),TIME);		CALL MAP.SEQUENCE.TIME.TO.NEAREST.BEATS(TIME,															 LOC(ADDR(PRIOR.BEAT.MSB)),															 LOC(ADDR(NEXT.BEAT.MSB)));		/*	FIND WHICH BEAT WE ARE CLOSER TO	*/		IF (NEXT.BEAT.LSB-TIME(1)) IGT SHR(NEXT.BEAT.LSB-PRIOR.BEAT.LSB,1)		THEN DO;								/*	USE PRIOR BEAT	*/			TIME(0)=PRIOR.BEAT.MSB;			TIME(1)=PRIOR.BEAT.LSB;		END;		ELSE DO;								/*	CLOSER TO NEXT BEAT	*/			TIME(0)=NEXT.BEAT.MSB;			TIME(1)=NEXT.BEAT.LSB;		END;		/*	AND FINALLY MAP THE NEAREST BEAT TIME BACK TO REAL TIME	*/		CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(TIME,TIME);		ENABLE;		RETURN;	END;	/*	LIVE CLICK TRACK ONLY:	*/	TIME(0)=PLAY.TIME.MSB;				/*	BEGIN BY GETTING	*/	TIME(1)=NEXT.CLICK;					/*	ABSOLUTE TIME	*/	IF NEXT.CLICK ILT PLAY.TIME.LSB	/*	OF NEXT CLICK	*/	THEN TIME(0)=TIME(0)+1;	/*	WATCH OUT HERE - LAST CLICK MAY ACTUALLY BE IN FRONT OF US	*/	/*	IF WE ARE SCANNING NOTES OFF OF A LIVE CLICK TRACK			*/	IF (NEXT.CLICK-PLAY.TIME.LSB) IGT SHR(EST.RATE,1)	THEN DO;								/*	BACK UP TO PRIOR CLICK	*/		IF TIME(1) ILT EST.RATE		THEN TIME(0)=TIME(0)-1;		TIME(1)=TIME(1)-EST.RATE;	END;	ENABLE;END COMPUTE.NEAREST.BEAT.TIME;/*	$SUBTITLE  ROUTINE TO CONTROL SEQUENCER VIA GLOBAL FLAG VARIABLES	*/CONTROL.SEQUENCER:  PROC PUBLIC SWAPABLE;	/*	PROCESSES SEQUENCER.CONTROL.REG	*/	DCL I	FIXED;	/*	SEQUENCER.CONTROL.REG IS A FIFO CONTAINING UP TO 4 SEQUENCER	COMMANDS.  NEW COMMANDS ARE SHIFTED IN FROM THE RIGHT.  COMMANDS	ARE TAKEN OUT FROM THE LEFT.	*/	DO WHILE SEQUENCER.CONTROL.REG<>0;	/*	PROCESS ALL SEQUENCER CONTROL COMMANDS	*/		DISABLE;		I=ROT(SEQUENCER.CONTROL.REG,4)&"17";	/*	READ BITS FROM FIFO	*/		SEQUENCER.CONTROL.REG=SHL(SEQUENCER.CONTROL.REG,4);	/*	SHIFT BITS OUT OF FIFO	*/		ENABLE;		DO CASE I;			;									/*	0: NO BITS SET - DO NOTHING	*/			DO;								/*	START: START FROM TOP			*/				CALL ABORT.BOUNCE.SMT.SKT;	/*	STOP BOUNCING						*/				CALL STOP.RECD.MOVE.PLAY;	/*	HAVE TO STOP MOVEMENT FIRST	*/				MARK.BUTTON.DISABLED=1;		/*	DISABLE MARK BUTTON				*/				CALL START.PLAY;				/*	START FROM TOP						*/				CALL DISPLAY.SEQUENCER.STATUS;	/*	LIGHT THE CORRECT BUTTONS	*/			END;			CALL CONTINUE.SEQUENCER;	/*	2: SIMULATE CONT  BUTTON PRESS	*/			CALL STOP.SEQUENCER;			/*	3: SIMULATE STOP  BUTTON PRESS	*/			IF PLAY=0 THEN DO;				CALL STOP.RECD.MOVE.PLAY;	/*	MUST STOP MOTION BEFORE INIT	*/				CALL PLAY.INITIALIZE;	/*	4: REPOSITION TO START OF SEQUENCE	*/			END;			/*	HANDLE MIDI SONG POSITION POINTER	*/			/*	INPUT.  PRESET DATA FOR MARK		*/			/*	START:									*/			DO;									/*	SET MARK START (SONG PTR)	*/				LOAD MIDI.SONG.PTR.INFO;	/*	GET SONG PTR (I/E BEATS * 4)	*/				IF CLICK.TRACK.MODE igt 3				THEN MUL 1000;				ELSE MUL DIVISIONS;			/*	TIMES DELTA DIVISIONS PER MIDI QUARTER NOTE	*/				MARK.BUTTON.MSB=URES; MARK.BUTTON.LSB=RES;				MARK.BUTTON.LSB = MARK.BUTTON.LSB + 2;	/*	ROUND BY 2	*/				IF MARK.BUTTON.LSB ILT 2				THEN MARK.BUTTON.MSB = MARK.BUTTON.MSB + 1;				MARK.BUTTON.LSB = SHR(MARK.BUTTON.LSB,2)\SHL(MARK.BUTTON.MSB,14);				MARK.BUTTON.MSB = SHR(MARK.BUTTON.MSB,2);				MARK.BUTTON.LSB = MARK.BUTTON.LSB + ZERO.TIME;				IF MARK.BUTTON.LSB ILT ZERO.TIME				THEN MARK.BUTTON.MSB = MARK.BUTTON.MSB + 1;				IF CLICK.TRACK.MODE igt 3 THEN DO;	/*	LIVE CLICK TRACK - MAP TO ABS TIME	*/					CALL REMAP.WITH.LIVE.CLICK(MARK.BUTTON.MSB,MARK.BUTTON.LSB,0,0,0);					MARK.BUTTON.MSB=REMAPPED.TIME.MSB;					MARK.BUTTON.LSB=REMAPPED.TIME.LSB;				END;				MARK.BUTTON.DISABLED=0;		/*	MAKE MARK BUTTON ACTIVE			*/				WRITE(MAM)=BAS.PTR;				WRITE(MAL)=SEQ.MARK.MSB;	/*	AND RE-WRITE TO SEQUENCE AREA	*/				WRITE(MDI)=MARK.BUTTON.MSB;				WRITE(MD )=MARK.BUTTON.LSB;				CALL SELECT.PARAMETER(MARK.L-PAR.L);				CALL DISPLAY.PAR;				CALL STOP.RECD.MOVE.PLAY;	/*	ABORT FF/REWIND OPERATION NICELY	*/				IF (MARK.BUTTON.MSB\MARK.BUTTON.LSB)<>0				THEN CALL PRESET.PLAY.TIME(0);	/*	SET UP FOR JUMP TO HYPER-SPACE	*/				ELSE CALL PLAY.INITIALIZE;				CALL DISPLAY.SEQUENCER.STATUS;	/*	SET UP SEQUENCER DISPLAY	*/			END;		END;		IF (I=1) OR (I=2)					/*	START OR CONTINUE	*/		THEN DO;								/*	PROCESS PREVIOUSLY MISSED MIDI TIMING CLOCKS	*/			IF  ((EXT.CLOCK.MODE=3)		/*	SYNCHED TO MIDI	*/			OR   (EXT.CLOCK.MODE=4)			OR   (EXT.CLOCK.MODE=5)			OR   (EXT.CLOCK.MODE=6))			AND (MISSED.MIDI.CLOCKS<>0)	/*	BUT WE ARE BEHIND	*/			THEN CALL RESYNC.TO.MIDI;		/*	GET CAUGHT UP	*/		END;	END;END CONTROL.SEQUENCER;