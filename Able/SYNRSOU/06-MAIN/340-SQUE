  /* 340-SQUE - QUE UP NOTES FOR ATTACK *//*   1/08/87 - CJ - NO LONGER USE EATQ FOR LATE LOOP START NOTES   12/30/86 - CJ - ADDED MONO SAMPLING ITEMS   10/9/86 - CJ,TS - FIXED KBD.SPL BUG   7/13/86 - CJ - ADDED NORIG   7/11/86 - CJ - USE SEQ.SPL.TIM FOR SEQUENCER NOTE DELAY   7/08/86 - CJ - FIXED TRK/TB BUG (CHANGED TO TRACK/TIMBRE)   5/15/86 - "official" creation of release-M modules*/  /* LINK PARTIAL BLOCKS TO APPROPRIATE QUE */  /* SO THAT NOTES GETS STARTED ACCURATELY  */  /* NOTE: DUPLICATE CODE APPEARS BELOW */  /*       FOR SPEED REASONS            */  /* QUEING FOR START OF NOTE:          */  DISABLE;  PPTR=PTLST;                      /* SET POINTER TO FIRST PARTIAL BLOCK */  IF NORIG=0 THEN BEGIN;             /* KEYBOARD/GUITAR NOTE    */     IF INC.MONO=0 THEN DO;        IF KBD.MILLISECONDS>=(OTIML-KBD.SPL.TIM)     /* SEE IF WE ARE STARTING NOTE LATE */        THEN OTIML=KBD.MILLISECONDS+(KBD.SPL.TIM+1); /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */     END;     ELSE DO;        WRITE(MAM)=TIM.HEAD;        WRITE(MAL)=TIMBRE;        WRITE(MAM)=READ(MD);        WRITE(MAL)=TIM.TOPTIONS;        IF (READ(MD)&ANY.SAMPLED)<>0 THEN DO;           /* LEAVE TIME FOR MONO SAMPLING SPLICE */           IF KBD.MILLISECONDS>=(OTIML-KBD.MONO3)       /* SEE IF WE ARE STARTING NOTE LATE */           THEN OTIML=KBD.MILLISECONDS+(KBD.MONO3+1);   /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */        END;        ELSE DO;                                        /* NO SAMPLING */           IF KBD.MILLISECONDS>=(OTIML-KBD.SPL.TIM)     /* SEE IF WE ARE STARTING NOTE LATE */           THEN OTIML=KBD.MILLISECONDS+(KBD.SPL.TIM+1); /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */        END;     END;     DO WHILE PPTR<>0;             /* CYCLE THROUGH EACH PARTIAL BLOCK   */        I=PFPTR;                   /* GET FOWARD POINTER - SAVE TEMPORARILY */        NEXT:                      /* RE-ENTER FROM BELOW TO QUE UP GHOST BLOCK - COULD HAPPEN WHILE RECORDING FROM KEYBOARD IF KEYBOARD STOLE A PRE-RECORDED NOTE */        ETIMER=OTIML+ETIMER;       /* GET ABSOLUTE TIME TO TRIGGER       */        ITIMER=OTIML+ITIMER;        J=ETIMER;                  /* SORT INTO QUE                      */        K=EKBQB;                   /* SEARCHING BACKWARDS FOR BEST SPEED */        DO WHILE (K<>ADDR(EKBQF))              AND      (J<CORE(K+(ETLOC-EQFLOC)));           K=CORE(K+1);            /* BACKWARDS                          */        END;        EQB        =K;             /* LINK US AFTER THE BLOCK ON QUE     */        EQF        =CORE(K);               CORE(EQF+1)=ADDR(EQF);                   CORE(K)    =ADDR(EQF);                   IF  (DO.FM<>0)             /* IF FM IS USED ON THIS PARTIAL */        AND (ITIMER<>ETIMER)       /* BUT DIFFERENT DELAY */        THEN DO;                   /* MUST LINK TO INDEX QUE AS WELL */           J=ITIMER;               /* SORT INTO QUE                      */           K=IKBQB;                /* SEARCHING BACKWARDS FOR BEST SPEED */           DO WHILE (K<>ADDR(IKBQF))                 AND      (J<CORE(K+(ITLOC-IQFLOC)));              K=CORE(K+1);         /* BACKWARDS                          */           END;           IQB        =K;          /* LINK US AFTER THE BLOCK ON QUE     */           IQF        =CORE(K);                  CORE(IQF+1)=ADDR(IQF);                      CORE(K)    =ADDR(IQF);                      ANY.INDEX.QUES=1;        END;        IF  (GFPTR<>0)             /* IF THERE IS A GHOST BLOCK ATTACHED TO THIS */        AND (CORE(GFPTR)<0)        /* WHICH STILL MUST BE QUED */        THEN DO;                   /* USE ABOVE CODE TO ALSO QUE UP GHOST BLOCK */           PPTR=GFPTR;             /* GET PPTR POINTING TO GHOST BLOCK */           PFPTR=0;                /* SET TO ZERO IN GHOST BLOCK WHEN QUED */           GOTO NEXT;              /* QUE UP IT IS WELL */        END;        PPTR=I;                    /* MOVE ON TO NEXT PARTIAL */     END;                          /* OF LOOP OVER PARTIALS */  END;/* $PAGE - QUE UP SEQUENCER NOTES *//*   SEQ      NOTE - PTRS.LOOP=0  LOOP.RESTART=0 - USE EDLQ (DELAY NOTE WITH NO LOOPING CONSIDERATION)                     PTRS.LOOP=0  LOOP.RESTART=1 - USE EDLQ BUT SET STIMER TO PLAY.TIME.LSB (MEANS WE MISSED THE BOAT COMPLETELY)                     PTRS.LOOP=1  LOOP.RESTART=0 - USE ELPQ (WAIT FOR LOOP POINT,  THEN DELAY NOTE)                     PTRS.LOOP=1  LOOP.RESTART=1 - USE EDLQ (DELAY NOTE WITHOUT LOOPING CONSIDERATIONS) - BOTH TIME BASES HAVE LOOPED */  ELSE DO;                         /* QUE UP SEQUENCER NOTES */     IF (PTRS.LOOPED=LOOP.RESTART) /* IF NO LOOPING AT ALL */     THEN BEGIN;                   /* OR BOTH POINTERS AND TIME BASE HAVE LOOPED */        IF INC.MONO=0 THEN DO;     /* FM ONLY/POLY */           IF PLAY.TIME.LSB>=(OTIML-SEQ.SPL.TIM)      /* SEE IF WE ARE STARTING NOTE LATE */           THEN OTIML=PLAY.TIME.LSB+SEQ.SPL.TIM+1;    /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */        END;        ELSE DO;           IF PLAY.TIME.LSB>=(OTIML-SEQ.MONO3)         /* SEE IF WE ARE STARTING NOTE LATE */           THEN OTIML=PLAY.TIME.LSB+SEQ.MONO3+1;       /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */        END;        DO WHILE PPTR<>0;          /* CYCLE THROUGH EACH PARTIAL BLOCK   */           I=PFPTR;                /* GET FOWARD POINTER - SAVE TEMPORARILY */           J=QME;                  /* AND QUE STATUS */           NEXT:                   /* RE-ENTER FROM BELOW TO QUE UP GHOST BLOCK - COULD HAPPEN WHILE RECORDING FROM KEYBOARD IF KEYBOARD STOLE A PRE-RECORDED NOTE */           STIMER=OTIML+STIMER;           K=STIMER;               /* SORT INTO QUE                      */           L=EDLQB;                /* SEARCHING BACKWARDS FOR BEST SPEED */           DO WHILE (L<>ADDR(EDLQF))                 AND      (K<CORE(L+(STLOC-EQFLOC)));              L=CORE(L+1);         /* BACKWARDS                          */           END;           EQB        =L;          /* LINK US AFTER THE BLOCK ON QUE     */           EQF        =CORE(L);                  CORE(EQF+1)=ADDR(EQF);                      CORE(L)    =ADDR(EQF);                                 IF ((J=(-3))         )     /* IF SHORT SEQ NOTE WITH F DECAY IMMINENT */           OR ((J=(-2))&(MCHN=0))     /* MIDI BLOCK FOR SHORT SEQ NOTE WITH FD SPLICING */           THEN DO;                   /* QUE UP FINAL DECAY RIGHT NOW */              K=FTIMER;               /* SORT INTO QUE                      */              L=FDLQB;                /* SEARCHING BACKWARDS FOR BEST SPEED */              DO WHILE (L<>ADDR(FDLQF))                    AND      (K<CORE(L+(FTLOC-FQFLOC)));                 L=CORE(L+1);         /* BACKWARDS                          */              END;              FQB        =L;          /* LINK US AFTER THE BLOCK ON QUE     */              FQF        =CORE(L);                     CORE(FQF+1)=ADDR(FQF);                         CORE(L)    =ADDR(FQF);                      END;           IF  (GFPTR<>0)          /* IF THERE IS A GHOST BLOCK ATTACHED TO THIS */           AND (CORE(GFPTR)<0)     /* WHICH STILL MUST BE QUED */           THEN DO;                /* USE ABOVE CODE TO ALSO QUE UP GHOST BLOCK */              PPTR=GFPTR;              J=PFPTR;             /* GET QME STATE FOR THIS GHOST BLOCK */              PFPTR=0;             /* SET TO ZERO IN GHOST BLOCK WHEN QUED */              GOTO NEXT;           END;           PPTR=I;                 /* MOVE ON TO NEXT PARTIAL */        END;                       /* OF LOOP OVER PARTIALS */     END;     /* $PAGE - QUE UP SEQUENCER NOTE (SPECIAL CASES - LOOP OR LATE) */     ELSE IF PTRS.LOOPED=0         /* PTRS.LOOPED=0, LOOP.RESTART=1 - MEANS WE MISSED THE BOAT */     THEN BEGIN;                   /* WE ARE LATE - JUST PERFORM ATTACK AS SOON AS POSSIBLE - NOTE WILL BE SHORT LIVED ANYWAYS */        DO WHILE PPTR<>0;          /* CYCLE THROUGH EACH PARTIAL BLOCK   */           I=PFPTR;                /* GET FOWARD POINTER - SAVE TEMPORARILY */           J=QME;                  /* AND QUE STATUS */           NEXT:                   /* RE-ENTER FROM BELOW TO QUE UP GHOST BLOCK - COULD HAPPEN WHILE RECORDING FROM KEYBOARD IF KEYBOARD STOLE A PRE-RECORDED NOTE */           EQF=EDLQF;              /* SET UP OUR FORWARD PTR TO WHAT IS ON EDLQ */           EQB=ADDR(EDLQF);        /* SET UP OUR BACK    PTR TO QUE START */           EDLQF=ADDR(EQF);        /* SET UP QUE POINTING TO US */           CORE(EQF+1)=ADDR(EQF);  /* SET UP BACK POINTER BACK TO US */           STIMER=PLAY.TIME.LSB;   /* SET UP A USEFUL PLAY TIME IN CASE SPLICE DELAY REQUIRED */           IF ((J=(-3))         )     /* IF SHORT SEQ NOTE WITH F DECAY IMMINENT */           OR ((J=(-2))&(MCHN=0))     /* MIDI BLOCK FOR SHORT SEQ NOTE WITH FD SPLICING */           THEN DO;                   /* QUE UP FINAL DECAY RIGHT NOW */              FQF=FINQF;              /* SET UP OUR FORWARD PTR TO WHAT IS ON FINQ */              FQB=ADDR(FINQF);        /* SET UP OUR BACK    PTR TO QUE START */              FINQF=ADDR(FQF);        /* SET UP QUE POINTING TO US */              CORE(FQF+1)=ADDR(FQF);  /* SET UP BACK POINTER BACK TO US */           END;           IF  (GFPTR<>0)          /* IF THERE IS A GHOST BLOCK ATTACHED TO THIS */           AND (CORE(GFPTR)<0)     /* WHICH STILL MUST BE QUED */           THEN DO;                /* USE ABOVE CODE TO ALSO QUE UP GHOST BLOCK */              PPTR=GFPTR;              J=PFPTR;             /* GET QME STATE FOR THIS GHOST BLOCK */              PFPTR=0;             /* SET TO ZERO IN GHOST BLOCK WHEN QUED */              GOTO NEXT;           END;           PPTR=I;                 /* MOVE ON TO NEXT PARTIAL */        END;                       /* OF LOOP OVER PARTIALS */     END;     ELSE BEGIN;                        /* PTRS.LOOPED=1, LOOP.RESTART=0 - QUE ON TO LOOP QUE */        DO WHILE PPTR<>0;               /* CYCLE THROUGH EACH PARTIAL BLOCK   */           I=PFPTR;                     /* GET FOWARD POINTER - SAVE TEMPORARILY */           J=QME;                       /* AND QUE STATUS */           NEXT:                        /* RE-ENTER FROM BELOW TO QUE UP GHOST BLOCK - COULD HAPPEN WHILE RECORDING FROM KEYBOARD IF KEYBOARD STOLE A PRE-RECORDED NOTE */           STIMER=OTIML+STIMER;           IF  (STIMER<LOOP.PLAY.TIME.LSB)    /* MAKE SPECIAL CHECK FOR BACKED UP PLAY TIMES FOR SPLICE OR FM SYNTH VOLUME WRITES */           THEN DO;                           /* USE EDL QUE TO GET GOOD SPLICE. NO NEED TO CHECK FOR FINAL DECAY */              K =(LOOP.PLAY.TIME.LSB - STIMER);   /* GET DISTANCE TO BACK UP */              STIMER=(GOBACK.PLAY.TIME.LSB - K);  /* BACK UP TO THIS TIME */              K=STIMER;               /* SORT INTO QUE                      */              L=EDLQB;                /* SEARCHING BACKWARDS FOR BEST SPEED */              DO WHILE (L<>ADDR(EDLQF))                    AND      (K<CORE(L+(STLOC-EQFLOC)));                 L=CORE(L+1);         /* BACKWARDS                          */              END;              EQB        =L;          /* LINK US AFTER THE BLOCK ON QUE     */              EQF        =CORE(L);                     CORE(EQF+1)=ADDR(EQF);                         CORE(L)    =ADDR(EQF);                      END;           ELSE DO;                     /* USE ELP QUE SO NOTE WAITS UNTIL LOOP POINT */              K=STIMER;                 /* SORT INTO QUE                      */              L=ELPQB;                  /* SEARCHING BACKWARDS FOR BEST SPEED */              DO WHILE (L<>ADDR(ELPQF))                    AND      (K<CORE(L+(STLOC-EQFLOC)));                 L=CORE(L+1);         /* BACKWARDS                          */              END;              EQB        =L;          /* LINK US AFTER THE BLOCK ON QUE     */              EQF        =CORE(L);                     CORE(EQF+1)=ADDR(EQF);                         CORE(L)    =ADDR(EQF);                      END;           IF J=(-3) THEN DO;                /* QUE UP FINAL DECAY IF REQUIRED */              K=FTIMER;               /* SORT INTO QUE                      */              L=FLPQB;                /* SEARCHING BACKWARDS FOR BEST SPEED */              DO WHILE (L<>ADDR(FLPQF))                    AND      (K<CORE(L+(FTLOC-FQFLOC)));                 L=CORE(L+1);         /* BACKWARDS                          */              END;              FQB        =L;          /* LINK US AFTER THE BLOCK ON QUE     */              FQF        =CORE(L);                     CORE(FQF+1)=ADDR(FQF);                         CORE(L)    =ADDR(FQF);                      END;           IF  (GFPTR<>0)          /* IF THERE IS A GHOST BLOCK ATTACHED TO THIS */           AND (CORE(GFPTR)<0)     /* WHICH STILL MUST BE QUED */           THEN DO;                /* USE ABOVE CODE TO ALSO QUE UP GHOST BLOCK */              PPTR=GFPTR;              J=PFPTR;             /* GET QME STATE FOR THIS GHOST BLOCK */              PFPTR=0;             /* SET TO ZERO IN GHOST BLOCK WHEN QUED */              GOTO NEXT;           END;           PPTR=I;                 /* MOVE ON TO NEXT PARTIAL */        END;                       /* OF LOOP OVER PARTIALS */     END;  END;                             /* FOR SEQUENCER NOTES     */  IF   QME=(-2)                    /* SET UP FOR FD SPLICING IF DESIRED */  THEN QME=( 1);  ELSE QME=( 0);                   /* NOTE IS NOW QUED        */  ENABLE;