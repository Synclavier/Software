/* :SYNRSOU:06-MAIN:300-MAIN  -  MAIN LOOP FOR NOTE PROCESSING, LOD SCAN */

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
1998/06/14 - TY  - Deleted duplicated code at the end of step 12.
1991/08/24 - PF  - Added TIMED.INFO.NOTES
1991/08/23 - PF  - Reversed order of PRIOR.ACTUAL.PLAY.TIME.LSB/MSB dcl to fix STORE.E.TIME when ABRT.RECORDING
1991/05/31 - CJ  - Added control of POLY scrubbing
1990/03/21 - PF  - Compressed CLAV.PTR to 43 sectors
1990/03/09 - PF  - Increase MAX.INPUTS to 128
1989/06/15 - PF  - Added check to send system exclusive packets to MIDInet
1989/06/08 - MWH - Process start/stop record protocol packets faster
1988/10/14 - TSS - Moved code relating to button panel out of 06-MAIN
1988/04/13 - PF  - ADDED TO MIDI OVERRUN TO KILL MIDI NOTES MAPPED TO RECORDER
1988/01/12 - TS  - SPLIT UP 06-MAIN MODULE INTO TWO PIECES
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1986/12/10 - CJ,TS,EG - INIT MIDI FIFO ON MIDI OVERRUN
1986/12/01 - cj,mb,eg (mo,curley,larry) - fixed d66 sampling bug
1986/11/19 - TS  - ADDED CODE TO DEBOUNCE INSERT/DELETE OPERATIONS
1986/11/01 - ts  - added info button track display refresh
1996/09/25 - KJO - updated for -7 catalog structure
1986/09/18 - ts  - changed mark button stuff
1986/08/14 - cj  - improved lod track button logic
1986/08/11 - cj  - set tds.update after track button assignment
1986/08/04 - cj  - changed load.load for workload
1986/07/31 - cj  - changed send.to.lod
1986/07/24 - cj  - scanned dtd.max.inputs,  etc.
1986/07/21 - cj  - scanned of lod messages for song & track directory
1986/07/15 -cj,ts- re-inserted 313-ghld
1986/06/28 -     - FINISHED LIVE OVERDUB SMPTE ITEMS
1986/06/26 -     - sent smpte info to Live Overdub
1986/06/20 -     - NOT USED
1986/06/17 - cj  - added live overdub loop scan
1986/06/12 - TSS - Added dcls for PRIOR.ACTUAL.PLAY.TIME.LSB/MSB
1986/05/15 - "official" creation of release-M modules
*/

/* 'MAIN.LOOP' IS CALLED EVERY SAMPLING INTERVAL TO PROCESS ALL ACTIVE NOTES */
/* INSERT STATEMENTS (RATHER THAN PROCEDURE CALLS) ARE USED TO PERFORM */
/* THE DIFFERENT NOTE FUNCTIONS.  A SIGNIFICANT SAVINGS IN SPEED		  */
/* IS THEREBY ACHIEVED																  */

/* THE VARIABLE TB, TBP, AND PTL ARE USED BY THE 'MAIN' PROCEDURE.	  */
/* THEY ARE DECLARED AS PUBLIC VARIABLES SO COMPUTE.KBD.PRE CAN SWAP	  */

BEGIN;
	DCL (TB,TBP,PTL,TRK,THP)  FIXED PUBLIC;
	DCL (I,J,K,L,M,N,P,Q,R,S) FIXED PUBLIC;
END;

DCL (PRIOR.REAL.MILLISECONDS    ) FIXED PUBLIC;
DCL (PRIOR.KBD.MILLISECONDS     ) FIXED PUBLIC;
DCL (PRIOR.ACTUAL.PLAY.TIME.MSB ) FIXED PUBLIC;
DCL (PRIOR.ACTUAL.PLAY.TIME.LSB ) FIXED PUBLIC;

DCL (SAMPLED.REAL.MILLISECONDS  ) FIXED PUBLIC;
DCL (SAMPLED.KBD.MILLISECONDS   ) FIXED PUBLIC;

DCL SXMSB								 FIXED PUBLIC;
DCL SXLSB								 FIXED PUBLIC;

DCL FM.VOL.SHADOW                 FIXED PUBLIC;
DCL POLY.PSRDVOL.SHADOW           FIXED PUBLIC;

ENTER ':SYNRSOU:06-MAIN';	/* GET IN RIGHT DIRECTORY */
INSERT '301-SUB1';
INSERT '302-SUB2';
INSERT '303-SUB3';
INSERT '304-SUB4';
INSERT '305-SUB5';

REAL.TIME.LOOP:PROC public;	/* MAIN REAL TIME LOOP */
	DCL (TB,TBP,PTL,TRK,THP)	FIXED EXTERNAL;
	DCL (I,J,K,L,M,N,P)			FIXED EXTERNAL;
	DCL (Q,R,S)						FIXED;
	DCL (X,Y,Z)						FIXED;
	DCL (BACK.PTR)					FIXED;
	DCL (NEW.HZ)					FIXED;
	DCL (TIME.TO.REPEAT)			FIXED;
	DCL (PRIOR.TIME)				FIXED;	/* TIME OF LAST RTE/GLIDE CHECK */
	DCL (PREV.TB)					FIXED;	/* PREVIOUS TONE BEND INFO */
	DCL (NEW.TB,NEW.BEND)		FIXED;	/* TRUE IF NEW TONE BEND INFO */
	DCL (NEW.GPITCH)				FIXED;	/* USED TO DETECT GUITAR PITCH BEND */
	DCL (SORT.TOGGLE)				FIXED;	/* FREE CHANNEL SORT TOGGLE */
	DCL (OUR.BITS)					FIXED;	/* USED IN RTE.UPDATE */
	DCL (MY.VOL)					FIXED;
	DCL (PRIOR.NPTR)				FIXED;
	DCL (EXT.REP.TRIGGER)		FIXED;
	DCL (OLD.PUNCH)				FIXED;

	DCL CURVE DATA (	/* 64-WORD DESCRIPTION OF S/CURVE SPLICE FOR DECAY COMPUTATION */
							/* ACTUALLY, THERE ARE 65 WORDS HERE - TY 1998/06/14 */
							/* BECAUSE WE INCLUDE THE END POINT - CJ 1998/06/26 */
		0,  3,   7, 10, 14, 16, 19, 21, 24, 25, 27, 28, 30, 30, 31, 31,
		32, 31, 31, 30, 30, 28, 27, 25, 24, 21, 19, 16, 14, 10,  7,  3,
		0,  3,   7, 10, 14, 16, 19, 21, 24, 25, 27, 28, 30, 30, 31, 31,
		32, 31, 31, 30, 30, 28, 27, 25, 24, 21, 19, 16, 14, 10,  7,  3,  0);

	/* $SUBTITLE - MAIN.LOOP OPERATION */

	/* OPERATION OF MAIN.LOOP:

	.	 0. SORT CHANNEL LIST PERIODICALLY TO IMPROVE RESYNTHESIZED TIMBRES
	.	 1. SAMPLE INTERRUPT DRIVEN CLOCK (PLAY.TIME)
	.	 2. 
	.	 3. CHECK GUITAR HOLD SWITCH,  MIDI TIMBRE CHANGE
	.	 4. ADVANCE PRESSURE/RIBBON FILTERS FOR NEW KEYBOARD
	.	 5. SCAN SEQUENCER & KBD FOR NEW NOTES (JUST INTO NBLKS FOR NOW)
	.	 6. START FINAL DECAYS AS REQUIRED
	.	 7. START ANY NEW NOTES FROM (5)
	.	 8. QUE UP NOTES TO START TOGETHER
	.	 9. PROCESS SYNTH CHANGES FOR KNOB UPDATES
	.	10. PROCESS ALL ACTIVE NOTES (FOR REPEATS, DYN PANNING, END.OF.NOTE, SPLICING)
	.	11. RECORD CHANGING REAL TIME EFFECTS IF RECORDING
	.	12. PROCESS GLIDE, VIBRATO, EXPONENTIAL DECAYS
	.	13. EMIT GATE AND TRIGGER SIGNALS IF REQUIRED
	.	14. CHECK FOR KEYBOARD PRECOMPUTE
	.	15. CHECK FOR MIDI BUFFER OVERRUN AND HANDLE IF NECESSARY
	.	16. CHECK FOR POSSIBLE SEQUENCER PSEUDO BUTTON COMMANDS
	.	17. CHECK FOR POSSIBLE SYSTEM EXCLUSIVE PACKET TO SEND OUT
	.	18. CHECK FOR PROTOCOL POLY SCRUBBING NEEDS
	.	19. CHECK FOR TIMED.INFO.NOTES IN PROGRESS */


	IF (0)									// ANALYZE RESPONSE
	{
		DCL (A,B) FIXED STATIC;
		A = A+1;
		IF (A == 1000)
		{
			SEND 'REAL.TIME.LOOP ', PLAY.TIME.LSB - B;
			A = 0;
			B = PLAY.TIME.LSB;
		}
	}

	CALL SCANDATA;		/* SCAN ALL INPUT DATA INTO GLOBAL VARIABLES */

	/*     */ INSERT '306-STR6';	/* SUBROUTINE TO START A NOTE */
	/*     */ INSERT '307-STR7';	/* MORE START NOTE CODE       */
	/*     */ INSERT '308-STR8';	/* START.NEW.NOTES ROUTINE    */
	/*  0. */ INSERT '310-SORT';	/* SORT CHANNEL LISTS FOR BETTER USAGE */
	/*  1. */ INSERT '311-SAMP';	/* SAMPLE CURRENT TIME BASE   */
	/*  3. */ INSERT '313-GHLD';	/* HOLD SWITCH, MIDI PGM CHG  */
	/*  4. */ INSERT '320-RIBF';	/* CHECK RIBBON FILTERS       */
	/*  5. */ INSERT '325-NEW' ;	/* SCAN KEYBOARD, SEQ, SMPT   */
	/*  6. */ INSERT '330-FINL';	/* START FINAL DECAYS IN ENDING NOTES */

	/*  7. */							/* START ANY NEW NOTES FROM (5) */

	IF TIELIST<>0 THEN DO;									/* CHECK TIMING OF TIED NOTES      */
		NPTR=TIELIST;											/* CHECK TIME OF BLOCKS            */
		TIELIST=0; TIELAST=0;								/* CLEAN OUT TIED QUE              */
		DO WHILE NPTR<>0;										/* CHECK TIME FOR EACH ONE         */
			I=NFPTR; NFPTR=0;									/* GET NEXT PTR; INITIALIZE        */
			IF (SAMPLED.ACTUAL.PLAY.TIME.LSB>=OTIML)	/* IF TIME FOR TIE THEN            */
			THEN DO;												/* PERFORM TIE NOW                 */
				IF SEQLIST=0 THEN SEQLIST=NPTR;			/* IF QUE IS EMPTY, STORE ON FRONT */
				ELSE              CORE(SEQLAST)=NPTR;	/* ELSE STORE ON END OF QUE        */
				SEQLAST=NPTR;									/* NOW WE ARE ON END OF QUE        */
			END;
			ELSE DO;												/* LINK BACK ON TIELIST            */
				IF TIELIST=0 THEN TIELIST=NPTR;			/* IF QUE IS EMPTY, STORE ON FRONT */
				ELSE              CORE(TIELAST)=NPTR;	/* ELSE STORE ON END OF QUE        */
				TIELAST=NPTR;									/* NOW WE ARE ON END OF QUE        */
			END;
			NPTR=I;												/* CONTINUE TIED NOTE SRCH         */
		END;
	END;

	IF (KBDLIST\SEQLIST)<>0					/* NEW SEQ OR KBD NOTES */
	THEN CALL START.NEW.NOTES;

	/*  9. */							/* PROCESS KNOB CHANGES FOR SYNTHS */

	IF (RESET.BITS<>0)						/* SEE IF SYNTH UPDATES REQUIRED */
	{
		IF ((RESET.BITS & R.XPOS) != 0)	/* IF RECORDED TRANSPOSITION UPDATE PENDING, CHECK... */
		{
			IF (SAMPLED.ACTUAL.SEQUENCE.TIME.LSB >= RESET.XPOS.TIME)
			{
				RESET.BITS = RESET.BITS XOR R.XPOS;
				RESET.BITS = RESET.BITS |   R.FREQS;
			}
		}

		IF ((RESET.BITS & (NOT(R.XPOS))) != 0)
			CALL KNOB.CHANGES;				/* UPDATE SYNTH AS REQUIRED FROM KNOB CHANGES */
	}

	/* 10. */							/* PROCESS ALL ACTIVE NOTES */

	BACK.PTR=ADDR(NOTELIST);				/* SET UP BACK POINTER      */
	NPTR=NOTELIST;								/* TO FIRST BLOCK ON LIST   */

	DO WHILE NPTR<>0;							/* CYCLE THROUGH EACH BLOCK */
		IF NSTAT<>2 THEN DO;					/* PROCESS ACTIVE NOTE */
			TB=TIMBRE;							/* SET UP PTRS FOR FOLLOWING ROUTINES */
			WRITE(MAM)=TIM.HEAD;
			WRITE(MAL)=TB;
			TBP       =READ(MD);
			TRK=TRACK;
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=TRK;
			THP       =READ(MD);
			INSERT '350-REPT';				/* CHECK FOR REPEAT/ARPEGGIATE */
			INSERT '351-DPAN';				/* PERFORM DYNAMIC PANNING FOR THIS NOTE */
			INSERT '352-SPLC';				/* CHECK FOR ENVELOPE SEGMENT SPLICING */ // Also your basic volume control
		END;
		IF NSTAT=2 THEN DO;					/* TERMINATE NOTE */
			CORE(BACK.PTR)=NFPTR;			/* UPDATE BACK POINTER */
			CORE(NPTR)=NFREEP;				/* LINK US ON TO FRONT OF FREE QUE */
			NFREEP    =NPTR  ;
			NPTR=CORE(BACK.PTR);				/* GET NEW NPTR */
		END;
		ELSE DO;									/* MOVE AHEAD */
			BACK.PTR=NPTR;						/* THIS IS NEW BACK POINTER */
			NPTR=NFPTR;							/* MOVE ON */
			IF NEWKEY<>0 THEN DO;			/* CHECK FOR NEW KEYBOARD NOTES HERE */
				PRIOR.NPTR=NPTR;				/* SAVE    */
				CALL SCANKBD;					/* GET NEW KEYBOARD NOTE (S) */
				CALL START.NEW.NOTES;		/* START THEM - NOTE THEY GO ON FRONT (!!) OF QUE */
				NPTR=PRIOR.NPTR;
			END;
		END;
	END;											/* OF NPTR LOOP */

	/* $PAGE - MAIN LOOP, CONTINUED */

	/* 11. */ INSERT '360-RREC';	/* CHECK FOR REAL TIME EFFECTS TO BE RECORDED */

	/* 12. */							/* NOW THE BIG 3 - PORTAMENTO, VIBRATO, EXPONENTIAL DECAYS */

	IF (SAMPLED.REAL.MILLISECONDS-PRIOR.TIME) IGT 500	/* AVOID OVERFLOW */
	THEN PRIOR.TIME=SAMPLED.REAL.MILLISECONDS-500;		/* ON LONG SEQUENCE RECALL */

	IF (SAMPLED.REAL.MILLISECONDS>=PRIOR.TIME+10)\(NEW.INFO<>0) THEN DO;	/* SCAN THROUGH NOTELIST QUE IF ANY CHANGE */
      DCL TEST_PRESSURE LIT '0';

		NEW.INFO=0;								/* PROCESS TIED NOTES AND RTE CHANGES QUICKLY */

      #if (TEST_PRESSURE)
         DCL TEST_PRESSURE_VALUE FIXED STATIC;

         IF (NOTELIST == 0)
            TEST_PRESSURE_VALUE = 0;
         ELSE
            TEST_PRESSURE_VALUE = TEST_PRESSURE_VALUE + 1;
      #endif

		NPTR=NOTELIST;							/* PICK UP FIRST NOTE BLOCK */
		DO WHILE NPTR<>0;						/* PROCESS EACH ONE         */

			TB=TIMBRE;							/* SET UP PTRS FOR FOLLOWING ROUTINES */
			WRITE(MAM)=TIM.HEAD;
			WRITE(MAL)=TB;
			TBP       =READ(MD);
			TRK=TRACK;
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=TRK;
			THP       =READ(MD);

			INSERT '370-REAL';				/* CHECK FOR REAL TIME CHANGES TO BE PERFORMED */

			PPTR=PTLST;							/* GET POINTER TO PARTIAL LIST */
			DO WHILE PPTR<>0;					/* PROCESS EACH PARTIAL        */
				IF MCHN<>0 THEN DO;			/* SKIP  OVER MIDI-ONLY BLOCKS */
					NEW.HZ=NEW.BEND;			/* REWRITE HZ ALWAYS IF NEW TONE BEND INFO */
					PTL   =PARTL;
					WRITE(MAM)=TBP;
					WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
					PTPTR=READ(MD);			/* GET PTR TO PARTIAL INFO */

					IF PSTAT THEN DO;			/* IF ACTIVE, REPEATING, OR DECAYING ONLY */
						INSERT '380-GLID';	/* PERFORM PORTAMENTO AS NEEDED, OR GUITAR PITCH CHANGES */
						INSERT '381-VIB' ;
						INSERT '382-EXP' ;	/* PERFORM EXPONENTIAL DECAYS AS NEEDED */
					END;
					IF (NEW.HZ<>0)				/* NEW TONE BEND INFO      */
					THEN DO;						/* AS OPPOSED TO MIDI-ONLY */
						CALL SETUP.FRQS;		/* SET UP NEW HZ - STORE INFO IN PARTIAL BLOCK IF INACTIVE NOTE */
					END;
				END;
				PPTR=PFPTR;						/* GET NEXT PARTIAL */
			END;									/* OF PARTIAL LOOP  */
			NPTR=NFPTR;							/* PICK UP POINTER TO NEXT NOTE */
			IF NEWKEY<>0 THEN DO;			/* CHECK FOR NEW KEYBOARD NOTES HERE */
				PRIOR.NPTR=NPTR;				/* SAVE */
				CALL SCANKBD;					/* GET NEW KEYBOARD NOTE (S) */
				CALL START.NEW.NOTES;		/* START THEM - NOTE THEY GO ON FRONT (!!) OF QUE */
				NPTR=PRIOR.NPTR;
			END;
		END;	/* OF NOTE LOOP */


		/* IF NEED TO SEND MIDI CHANNEL PRESSURE THEN DO IT HERE */

		IF CPLIST0<>0 THEN DO;				/* SEND OUT MIDI CHANNEL PRESSURE */
			I=CPLIST0;
			DO WHILE I<>0;						/* PROCESS EACH ONE          */
				WRITE(MAM)=NAH.PTR+I;
				WRITE(MAL)=THD.TRK;
				TRK=READ(MD);					/* GET TRACK #               */
				WRITE(MAL)=THD.CPLIST;
				I=READ(MD);						/* ADVANCE TO NEXT LINK      */
				WRITE(MAL)=THD.CPSUM;		/* GET CURRENT SUM           */
				J=READ(MD);						/* READ IT                   */
				WRITE(MDI)=0;					/* CLEAR IT FOR NEXT LOOP    */
				IF J<>READ(MD)					/* CURRENT VALUE DIFFERENT FROM PREVIOUS */
				THEN DO;							/* DO UPDATE */
					WRITE(MD)=J;				/* STORE CURRENT VALUE INTO PREVIOUS VALUE */
					WRITE(MAL)=THD.ACTIVE;	/* ONLY SEND PRESSURE UPDATE */
					IF READ(MD)<>0 THEN DO;	/* IF TRK IS ACTIVE          */
						CALL MIDI.CHANNEL.PRESSURE(J);
					END;
				END;
			END;
		END;

		/* CLEAN UP UPD.PARS NOW THAT */
		/* ALL RTE UPDATES HAVE       */
		/* BEEN DONE                  */

		WRITE(MAM)=TRK.HEAD;					/* LOOK UP TABLE    */
		WRITE(MAM)=READ(MD);					/* TRACK HEAD FOR 0 */
		WRITE(MAL)=THD.UPD.PARS;
		WRITE(MD )=0;

		DO WHILE UPLIST0<>0;					/* PROCESS EACH ONE         */
			WRITE(MAM)=NAH.PTR+UPLIST0;
			WRITE(MAL)=THD.UPD.PARS;
			WRITE(MDI)=0;						/* THD.UPD.PARS - DONE      */
			WRITE(MDI)=0;						/* THD.UPD.QUED - NO LONGER */
			UPLIST0   =READ(MD);				/* ADVANCE POINTER          */
			WRITE(MD )=0;						/* ZERO LINKE WORD          */
		END;

		IF INC.AXE THEN DO;					/* ZERO FLAGS */
			NEW.GVOL=0; NEW.GRTE=0;
		END;

		INSERT '395-UPDT';					/* CHECK FOR KNOB UPDATES */

		DO WHILE PRIOR.TIME<=(SAMPLED.REAL.MILLISECONDS-10);	/* ADVANCE PRIOR TIME FILTER TO KEEP SOUNDS ACCURATE */
			PRIOR.TIME=PRIOR.TIME+10;
		END;

	END;	/* OF VIBRATO, PORTAMENTO, EXP DECAY PROCESSING */

	/* 13. */ INSERT '390-VOLT';	/* EMIT GATE AND TRIGGER SIGNALS IF REQUIRED */

	/* 14. */							/* CHECK FOR KEYBOARD PRECOMPUTE */

	IF (NEW.KBD.PRE<>0)			/* HOUSE WORK TO DO */
	THEN CALL COMPUTE.KBD.PRE;	/* CALL SWAP PROCEDURE TO PRECOMPUTE STUFF */

	/* 15. */							/* CHECK FOR MIDI INPUT BUFFER OVERRUN AND HANDLE */

	IF MIDI.OVERRUN<>0 THEN DO;/* TURN OFF ALL SYNCLAVIER NOTES IN CASE WE MISSED A MIDI NOTE OFF */
		MIDI.OVERRUN=0;			/* RESET */

		/* DOES ACTUALLY PRINT THE ERROR MESSAGE FOR NOW   */
		/* BUT IT CAN BE ANNOYING TO THE USER.             */
		CALL MIDI.OVERRUN.ERROR;

		WRITE(MAM)=CLAV.PTR;
		DO I=0 TO MAX.KEY#;		/* LOOP OVER ALL KEYS */
			WRITE(MDI)=0;			/* RESET BITS SO NOTES GET TURNED OFF */
		END;							/* AVOIDS STUCK MIDI NOTES */

		IF (MIDI.INPUT.ENABLED<>0)						/* MIDI MAPPED TO RECORDER   */
		THEN DO J=NUM.KBD.TRACKS TO MAX.INPUTS-1;	/* LOOP THRU ALL MIDI INPUT CHANNELS */
			IF J>1 THEN DO;				/* THIS CHANNEL IS ROUTED TO A TRACK*/	// was midi  mapped
			   LOAD J; MUL NUM.KEYS;
				WRITE(MAM)=CLAV.PTR+SHR(RES,8);
				WRITE(MAL)=RES;
				DO I=0 TO MAX.KEY#;		/* LOOP OVER ALL KEYS */
					WRITE(MDI)=0;			/* RESET BITS SO NOTES GET TURNED OFF */
				END;							/* AVOIDS STUCK MIDI NOTES */
			END;
		END;
		NUM.HELD.KEYS=0;			/* NONE HELD */

		CALL INIT.MIDI.FIFO(MIDI.SUBSYS,4);				/* INIT INPUT ALWAYS */

		IF EXT.CLOCK.MODE=4									/* NOW LISTENING TO THE AUX INPUT */
		THEN CALL INIT.MIDI.FIFO(MIDI.SUBSYS+1,4);	/* REZERO THE INPUT PORT SINCE IT MAY CONTAIN GARBAGE */
		
		IF EXT.CLOCK.MODE=6									/* Trash any OMS MIDI Sync saved-up bytes */
		THEN CALL interp_init_oms_midi_sync(addr(ANY.OMS.MIDI.SYNC.BYTES));
		
		IF OMS.MIDI.ENABLED != 0							/* Trash any saved up OMS Midi bytes */
		THEN CALL interp_init_oms_midi_bulk(addr(ANY.OMS.MIDI.BULK.BYTES), OMSMIDI.PTR);
	END;

	X=PUNCHSWITCH	/* \(MIDI.SWITCHDATA(R.PUNCH.SW)<>0) -- HAS TO UPDATED FOR MOVE TO XMEM -- */ ;
						/* OR MIDI AND SYNC TOGETHER */
	IF (X<>OLD.PUNCH) THEN DO;	/* CHANGE IN PUNCH IN FOOTSWITCH */
		IF X<>0 THEN CALL STACK.ON.PANEL(PUNCH.L+"100000");	/* PRESSING FOOT SWITCH - MAP TO BUTTON PRESS */
		OLD.PUNCH=X;
	END;

	/* 16. */							/* CHECK FOR POSSIBLE SEQUENCER PSEUDO BUTTON COMMANDS */

	IF SEQUENCER.CONTROL.REG<>0	/* SEQUENCER COMMANDS TO DO        */
	THEN CALL CONTROL.SEQUENCER;	/* PROCESSES SEQUENCER.CONTROL.REG */

	/* 17. */							/* CHECK FOR POSSIBLE SYSTEM EXCLUSIVE PACKET TO SEND OUT */

	WRITE(MAM) = SYSEX.PACKET;		/* POINT TO PACKET RESERVED FOR SYSEX */
	IF READ(MD) <> 8					/* IF LENGTH IS NOT 8 THEN WE HAVE SOME BYTES TO SEND */
	THEN CALL SEND.SYSEX.PACKET;	/* SEND THE PACKET */

	/* 18. */							/* CHECK FOR PROTOCOL POLY SCRUBBING NEEDS */

	BEGIN;
		DCL MOUSE.PLAYING				FIXED			EXTERNAL;
		DCL MPB$SCRBPOS				ARRAY			EXTERNAL;
		DCL Update.POLY.Scrubbing	PROC(ARRAY)	EXTERNAL;

		IF MOUSE.PLAYING = 3
		THEN CALL Update.POLY.Scrubbing(MPB$SCRBPOS);
	END;

	/* 19. */	/* CHECK FOR TIMED INFO NOTES: */

	BEGIN;
		DCL TIME FIXED;
		DCL Stop.Event.Auditions PROC EXTERNAL;

		IF (TIMED.INFO.NOTES<>0) THEN DO;		/* TIMED INFO NOTE IN PROGRESS */

			DISABLE;															/* GET ELAPSED TIME SINCE LAST CHECK */
				TIME = REAL.MILLISECONDS - INFO.TIMER.LAST;
				INFO.TIMER.LAST = REAL.MILLISECONDS;
			ENABLE;

			INFO.NOTE.TIMER(1) = INFO.NOTE.TIMER(1) + TIME;		/* KEEP INFO TIMER GOING */
			IF INFO.NOTE.TIMER(1) ILT TIME
			THEN INFO.NOTE.TIMER(0) = INFO.NOTE.TIMER(0) + 1;

			/* NOW CHECK TO SEE IF TIME HAS EXPIRED */
			IF (COM32(INFO.NOTE.TIMER,INFO.NOTE.DURATION) <> LW#ILT)
			THEN CALL Stop.Event.Auditions;

		END;
	END;

END REAL.TIME.LOOP;
