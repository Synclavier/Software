/* 305-SUB5   $TITLE  SUBROUTINES FOR START.NOTE/CHANNEL STEALING   Modified:   09/05/90 - cj  - fixed bug with start.up.music.note.in.middle to handle                    looping poly sound files correctly.   03/14/90 - TSS - DON'T SEND NOTE OFFS UNLESS NOTE HAS ACTUALLY BEEN STARTED   01/25/90 - MWH - Fix "300 msec delay starting cues" bug (from EditView)   08/24/89 - PF  - Added PATH argument to MIDI.NOTE.OFF   09/06/89 - MWH - Unsplit 06-MAIN now that the compiler can cope   04/20/89 - TSS - sign extend into page bits when starting notes up in middle   12/02/88 - CJ  - do not show ---- display if showing voices used                    via polyphony button   10/18/88 - cj  - fixed bug with partial chorus   10/14/88 - cj  - added start.up.music.note.in.middle   06/29/88 - MWH - DISPLAY BARS, TRACK, BEAT WHEN OUT OF VOICES DURING SEQ   01/12/88 - TS - SPLIT UP 06-MAIN MODULE INTO TWO PIECES   07/13/87 - MWH - MERGE IN CWJ FIX   06/26/87 - MWH - Split FRP.PTR into FP0-FP3.PTR for expanded poly   08/15/86 - CJ - FIXED STEALOK BUG   07/28/86 - CJ,KC - CHANGES TO ABORT.NOTE FOR STEREO   07/24/86 - CJ,KJC - cleanup.synth call   07/15/86 - CJ - CLEANED UP ABORT.NOTE   07/13/86 - CJ - ADDED NORIG.  MOVED CANCEL.NOTE   07/08/86 - CJ  - EXPANDED TEMP.LIST,  FIXED BACK.ARP BUG   06/12/86 - TSS - Changes related to RECP   05/15/86 - "official" creation of release-M modules*//* STEAL CHANNELS - STEAL CHANNELS FROM EARLIER NOTE *//* USED FOR TIED NOTES, PHRASING, MONOPHONIC VOICES  *//* ALSO USED TO SIMPLIFY USE OF LONG DECAYS          *//* SETS UP GHOST BLOCKS AS SUITABLE                  */DCL (TEMP.LIST)    (67) FIXED; /* MUST BE TWICE MAX # OF CHANNELS IN CASE OF ABORT.NOTE. ALSO EXTRA IN CASE MIDI GHOST BLOCK */DCL (TEMP.PTR)          FIXED;DCL (GHOST.LIST)   (67) FIXED; /* POINTS TO GHOST PARTIAL BLOCKS FOR SAME */DCL (NEWFP)             FIXED; /* STOLEN FILTERED PRESSURE, IF APPLIC */DCL (SAVED.NPTR)        FIXED;DCL (NEW.NUPDT)         FIXED;DCL (NEW.NPTR)          FIXED;DCL (NOTETIME.MSB)      FIXED;  /* FOR STEAL.CHANS - TIME OF NEW NOTE */DCL (NOTETIME.LSB)      FIXED;DCL (MIDIGHOST)         FIXED;NEW.DECAYER: PROC;  /* MARK A NEW DECAYER */  DCL (THP) FIXED  EXTERNAL;   WRITE(MAM)=THP;  WRITE(MAL)=THD.NACT;  WRITE(MDI)=READ(MD)-1;    /* ONE LESS ACTIVE NOTE */  WRITE(MD )=READ(MD)+1;    /* ONE MORE DECAYING    */END NEW.DECAYER;STEAL.CHANS: PROC;  /* PROCEDURE TO TERMINATE AN EARLIER NOTE SO WE CAN RE-USE IT'S CHANNELS. */   DCL (TB,TBP,PTL,TRK,THP) FIXED   EXTERNAL;    DCL (I,J,Y) FIXED;                 I=QME;                       /* SAVE FOR QUICK REFERENCE IF NOTE IS STILL TO BE QUED */   DO WHILE PTLST<>0;           /* FREE UP ALL ON LIST EARLIER NOTE BLOCK */     PPTR=PTLST; PTLST=PFPTR;   /* UNLINK AND FREE UP PARTIAL BLOCK       */     J=TEMP.LIST(0)+1;                       /* GET NEXT POINTER TO TEMP.LIST/GHOST.LIST */     TEMP.LIST(0)=J;                         /* INCREMENT POINTER FOR AT LEAST ONE CHANNEL + POSSIBLE GHOST QUE */     TEMP.LIST(J)=MCHN;                      /* STORE MCHN ON TEMP FREE LIST */                                             /* NOTE: MCHN COULD BE ZERO HERE IF MIDI ONLY BLOCK */     IF (SMCHN<>0) THEN DO;                  /* FREE UP SPLICE CHANNEL AS WELL */        IF (FMPTR<>0)                        /* CHECK FOR SPLICING HAD BEGUN */        THEN DO;                             /* IF SPLICING HAD BEGUN - SEE IF THERE IS PREFERRED CHANNEL FOR NEW ATTACK */           IF (UCHN<0)&(SUCHN>=0) THEN DO;   /* SWAP CHANNELS IF UCHN IS SOUNDING BUT SUCHN IS NOT - CREATES BETTER ATTACK */              Y=UCHN; UCHN=SUCHN; SUCHN=Y;   /* SWAP CHANNELS FOR NEW ATTACK */              Y=MCHN; MCHN=SMCHN; SMCHN=Y;              TEMP.LIST(J)=MCHN;             /* RESTORE NEW MCHN */           END;        END;        TEMP.LIST(0)=TEMP.LIST(0)+1;            /* COUNT ONE MORE FREE CHANNEL ON TEMP LIST */        TEMP.LIST(TEMP.LIST(0))=SMCHN\B.SPLICE; /* STORE SMCHN ON TEMP FREE LIST - INDICATE WAS IN PHASE WITH PREVIOUS CHANNEL */     END;     /* $PAGE - CREATE 'GHOST' BLOCK IF CHANNELS STOLEN */     /* START POLY SPLICE IF KEYBOARD NOTE      */     /* SEE IF NOTE IS QUED UP FOR ATTACK/DECAY */     /* CREATE GHOST BLOCK TO KEEP THESE THINGS */     /* HAPPENING EVEN IF CHANNELS STOLEN       */     DISABLE;                           /* FOR QUE CHECK AND POSSIBLE UNLINKING */     WRITE("300")=ADDR(EQF);            /* MAKE QUICK CHECK FOR ANY QUES - NORMALLY ARE NONE */     WRITE("301")=READ("360");          /* MR0I  TO  R1 */     WRITE("210")=1;                    /* IM(1) TO  ADD0 - SKIP OVER BACK POINTER */     WRITE("231")=READ("360");          /* MR0I  TO  OR1 */     WRITE("210")=1;                    /* IM(1) TO  ADD0 - SKIP OVER BACK POINTER */     WRITE("231")=READ("360");          /* MR0I  TO  OR1 */     IF (READ("301")   <>0)             /* IF NOTE IS QUED */     OR (I             < 0)             /* OR IF IS IN NEED OF QUEING *//**/ OR (((SBITS&B.GUI)<>0)             /* AND THIS IS GUITAR NOTE    *//**/ AND (NORIG        <>0))            /* FROM SEQUENCER             */     THEN DO;                           /* MUST CHECK FURTHER         */        IF   (  NORIG<>0                    )  /* IF STEALING CHANNELS FROM SEQUENCER NOTE */        AND  (( OTIML<NOTETIME.LSB         )   /* WHICH STARTED BEFORE OURS (AS OPPOSED TO EQUAL.  > IF LOOP OCCURRED) */        OR    ((PTRS.LOOPED<>0            )    /* OF OTIM>=NOTE TIME,  ALLOW GHOST BLOCK IF POINTERS HAVE LOOPED */        AND    (FENDL<GOBACK.PLAY.TIME.LSB)    /* AND NOTE ENDS ACTUALLY BEFORE THE LOOP (AS OPPOSED TO AT THE LOOP OR AFTER) */        AND    (I>=0                      )))  /* UNLESS ALSO SCANNED THIS TIME (MEANS AT BEGINNING OF LOOP) */        THEN DO;                               /* CREATE GHOST BLOCK     */           ENABLE;                             /* ENABLE INTERRUPTS HERE */           GHOST.LIST(J)=PPTR;                 /* WE BECOME A GHOST INSTEAD OF BEING RELEASED */           PFPTR=I;                            /* SET PFPTR IN GHOST BLOCK : MINUS IF STILL MUST BE QUED,  0 IF ALREADY QUED.  LOOKED AT IN 340-SQUE CODE */        END;        ELSE DO;                        /* JUST FREE UP BLOCKS - DO NOT CREATE GHOST BLOCKS SINCE THEY WOULD START AT THE SAME TIME */                      IF EQF<>0 THEN DO;           /* BLOCK IS LINKED ON TO A TIMER QUE */              CORE(EQB  )=EQF;          /* OUR FP GOES TO FP BEHIND   US */              CORE(EQF+1)=EQB;          /* OUR BP GOES TO BP AHEAD OF US */              EQF=0;           END;           IF IQF<>0 THEN DO;           /* BLOCK IS LINKED ON TO A TIMER QUE */              CORE(IQB  )=IQF;          /* OUR FP GOES TO FP BEHIND   US */              CORE(IQF+1)=IQB;          /* OUR BP GOES TO BP AHEAD OF US */              IQF=0;           END;           IF FQF<>0 THEN DO;           /* BLOCK IS LINKED ON TO A TIMER QUE */              CORE(FQB  )=FQF;          /* OUR FP GOES TO FP BEHIND   US */              CORE(FQF+1)=FQB;          /* OUR BP GOES TO BP AHEAD OF US */              FQF=0;           END;           IF MIDIRT<>0 THEN DO;        /* THIS IS A MIDI PARTIAL */              IF PSTAT<>DELAY.STATE     /* NOTE HAS BEEN STARTED  */              THEN CALL MIDI.NOTE.OFF(MIDIRT, MIDIPATH, MIDIINFO); /* TURN NOTE OFF */              MIDIRT=0;                 /* REZERO INFO AFTER DOING NOTE OFF */              /******/;                 /* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */           END;           ENABLE;           IF GFPTR<>0 THEN DO;               /* SPECIAL TESTS REQUIRED IF THIS PARTIAL ALSO HAD A GHOST BLOCK */              GHOST.LIST(J)=GFPTR;            /* BUT IF THERE WERE GHOSTS ON THIS NOTE, SAVE THIS AS THE GHOST BLOCK */              GFPTR=0;                        /* ZERO OUT GHOST POINTER.  PFPTR IN GHOST BLOCK IS ALL SET UP 0 OR 1 */           END;           CALL RELP;                         /* DONE WITH PARTIAL BLOCK */        END;                                                                                   END;     ELSE DO;          /* BLOCK NOT ON ANY ENV QUES - ALSO MEANS WE DO NOT HAVE ANY GHOSTS - JUST RELEASE BLOCK */        IF MIDIRT<>0 THEN DO;                  /* THIS IS A MIDI PARTIAL */           IF PSTAT<>DELAY.STATE               /* NOTE HAS BEEN STARTED */           THEN CALL MIDI.NOTE.OFF(MIDIRT, MIDIPATH, MIDIINFO); /* TURN NOTE OFF */           MIDIRT=0;                           /* REZERO INFO AFTER DOING NOTE OFF */           /******/;                           /* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */        END;        ENABLE;        CALL RELP;     END;   END;                                   /* OF PARTIAL LOOP */   IF RECS<>0 THEN DO;                    /* STORE ENDING TIME IF STEALING CHANNELS */      CALL STORE.E.TIME;                  /* STORE ENDING TIME IF RECORDING - COULD HAPPEN IF NSTAT=0 */   END;   NSTAT=2;    WRITE(MAM)=THP;   WRITE(MAL)=THD.ARP;   IF NPTR=READ(MD) THEN DO;              /* REMOVE THIS ARPEGGIATE NOTE */     CALL BACK.ARP.PTR(TRK);              /* GET NEXT FORWARD BLOCK ON QUE - SO NEXT NEW NOTE TRIGGERS */     WRITE(MAM)=THP;   END;   NEWFP=FPRED;                           /* SAVE FILTERED PRESSURE FOR START OF NEW NOTE */   IF STEALOK<>(-2) THEN DO;              /* IF ACCOUNTING STILL TO DO */      IF (STEALOK&256)=0 THEN CALL NEW.DECAYER; /* REDUCE ACTIVE, INCREMENT DECAYER IF TRASHING ACTIVE NOTE */      WRITE(MAL)=THD.NDEC;      WRITE(MD)=READ(MD)-1;               /* ONE LESS DECAYING NOTE */      STEALOK=(-1);                       /* INDICATE NO CHANNELS LEFT, NO USE STEALING. IF ACTIVE NOTE, LEAVE ON NOTE BLOCK QUE FOR LATER DEALLOCATION */   END;END STEAL.CHANS;/* $PAGE - OTHER INTERNAL SUBROUTINES - RELEASE.TEMP.CHANS, ABORT.NOTE, CHECKQUE *//* RELEASE.TEMP.CHANS:  CLEAN UP STOLEN CHANNELS IF NEW NOTE LATER       *//*                      BOMBS OUT (THIS WAS THE ORIGINAL STUCK-NOTE BUG) */RELEASE.TEMP.CHANS: PROC SWAPABLE;          /* FREE UP TEMPORARY STOLEN CHANNELS (IF ANY) */   DCL (I,J) FIXED;   IF MIDIGHOST<>0 THEN DO;                 /* FREE UP STOLEN MIDI PARTIAL BLOCK THAT FOR SOME REASON WAS NOT REUSED */     I=TEMP.LIST(0)+1;                      /* GET NEXT POINTER TO NEXT TEMP.LIST/GHOST.LIST ENTRY */     TEMP.LIST  (0)=I;                      /* INCREMENT POINTER FOR AT LEAST ONE CHANNEL + POSSIBLE GHOST QUE */     TEMP.LIST  (I)=0;                      /* MCHN IS ZERO FOR MIDI-ONLY BLOCKS */     GHOST.LIST (I)=MIDIGHOST;              /* PRETEND THIS IS A GHOST BLOCK.  RELEASE TEMP CHANNELS WILL CLEAN IT UP. PFPTR NEED NOT BE SET */     MIDIGHOST     =0;   END;      DO WHILE TEMP.PTR<>TEMP.LIST(0);         /* CLEAN UP STOLEN BUT NOT REUSED CHANNELS */      TEMP.PTR=TEMP.PTR+1;                  /* GET POINTER TO CHANNEL */      IF GHOST.LIST(TEMP.PTR)<>0 THEN DO;   /* SEE IF GHOST BLOCK WAS ATTACHED */         PPTR=GHOST.LIST(TEMP.PTR);         /* GET PPTR TO IT     */         GHOST.LIST(TEMP.PTR)=0;            /* AND CLEAN OUT LIST */         DO WHILE PPTR<>0;                  /* PROCESS EACH GHOST BLOCK, STARTING WITH FIRST ONE */            DISABLE;                        /* FOR QUEING */            IF EQF<>0 THEN DO;              /* BLOCK IS LINKED ON TO A TIMER QUE */               CORE(EQB  )=EQF;             /* OUR FP GOES TO FP BEHIND   US */               CORE(EQF+1)=EQB;             /* OUR BP GOES TO BP AHEAD OF US */               EQF=0;            END;            IF IQF<>0 THEN DO;              /* BLOCK IS LINKED ON TO A TIMER QUE */               CORE(IQB  )=IQF;             /* OUR FP GOES TO FP BEHIND   US */               CORE(IQF+1)=IQB;             /* OUR BP GOES TO BP AHEAD OF US */               IQF=0;            END;            IF FQF<>0 THEN DO;              /* BLOCK IS LINKED ON TO A TIMER QUE */               CORE(FQB  )=FQF;             /* OUR FP GOES TO FP BEHIND   US */               CORE(FQF+1)=FQB;             /* OUR BP GOES TO BP AHEAD OF US */               FQF=0;            END;            I=GFPTR;                        /* MUST GET TEMP COPY OF GFPTR */            GFPTR=0;                        /* ZERO OUT GFPTR HERE         */            PFPTR=GFREE; GFREE=PPTR;        /* LINK THIS GHOST BLOCK ON TO GFREE QUE */            IF MIDIRT<>0 THEN DO;           /* THIS IS A MIDI PARTIAL */               IF (PSTAT<>DELAY.STATE)      /* NOTE HAS BEEN STARTED */               THEN CALL MIDI.NOTE.OFF(MIDIRT, MIDIPATH, MIDIINFO); /* TURN NOTE OFF */               MIDIRT=0;                    /* REZERO INFO AFTER DOING NOTE OFF */               /******/;                    /* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */            END;            ENABLE;                         /* FOR LATER CALL TO PREL */            PPTR=I;                         /* SWITCH OVER TO GHOST BLOCK */         END;      END;      I=TEMP.LIST(TEMP.PTR)&(NOT(B.SOUNDING\B.SPLICE)); /* GET FREE CHANNEL - CLEAR SOUNDING AND SPLICE BITS */      IF (I<>0) THEN DO;                    /* NOTE ENTRY FROM ABORT.NOTE ABOVE - ZERO MEANS NO CHANNEL WAS EVER ALLOCATED (OR MIDI-ONLY BLOCK) */         IF  ((INC.MONO=0)                  /* IF NO SAMPLING AT ALL */         AND  (INC.POLY=0))         OR (I&(B.MONO\B.POLY))=0 THEN DO;  /* OR ORIGINAL SYNTHESIZER - COMPUTE ITEMS */            IF (I&255)<LSYN1.END THEN J=FR1.PTR; ELSE J=FR2.PTR; /* GET LOG SYN PTR */            CALL CLEANUP.SYNTH(I,I+1);         END;       /* OF BEGIN FOR ORIGINAL SYNTHESIZER */         ELSE IF (INC.MONO<>0)&((I&B.MONO)<>0) THEN DO;  /* MONO SAMPLING (W. DISK) */            J=FRM.PTR;            CALL CLEANUP.SYNTH(I,0);         END;         ELSE IF (INC.POLY<>0) THEN DO;                  /* MEANS POLY SYNTH */            J=CORE(ADDR(FP0.PTR) + (SHR(I,6)&"3"));      /* POINT AT CHANNEL LIST FOR THIS BIN (UP 1 BIN EVERY 64) */            IF (I&B.STEREO)<>0 THEN DO;                  /* STEREO PAIR */               CALL CLEANUP.SYNTH(I,I+1);               I=I&(NOT B.STEREO);                       /* TURN OFF STEREO BIT */               CORE(J)=CORE(J)+1; CORE(J+CORE(J))=I;     /* STORE MASTER CHANNEL BACK ON LIST */               I=I+1;            END;            ELSE CALL CLEANUP.SYNTH(I,0);         END;         CORE(J)=CORE(J)+1; CORE(J+CORE(J))=I; /* STORE FREE CHANNEL BACK ON LIST */      END;   END;   TEMP.LIST(0)=0; TEMP.PTR=0;END RELEASE.TEMP.CHANS;DCL DO.VOICE.CHECK FIXED PUBLIC;    /* SET WHEN WE'RE ALLOWED TO DISPLAY BARS DURING SEQUENCE *//* ABORT.NOTE - CLEAN UP LOOSE ENDS ON NOTE BOMB       *//*              HAPPENS IF NOT ENOUGH CHANNELS         *//*              ALSO HAPPENS IF NOT ENOUGH NOTE BLOCKS */ABORT.NOTE: PROC SWAPABLE;  /* INTERNAL PROC TO CLEAN UP IF BOMB OUT - CLEANS UP CURRENT UNQUEUED NOTE BLOCK */   DCL (TB,TBP,PTL,TRK,THP)   FIXED   EXTERNAL;    DCL (DISP.TRK.BARS)        FIXED   STATIC;    /* BARS DISPLAYED: OUT OF VOICES ON TRACK IF <> 0 */   DCL (DISP.TRK.TIME)        FIXED   STATIC;    /* MILLISECOND TIME WHEN DISP.TRK.BARS SET */   DCL (I)                    FIXED;   DO WHILE PTLST<>0;           /* FREE UP ALL ON LIST EARLIER NOTE BLOCK */     PPTR=PTLST; PTLST=PFPTR;   /* UNLINK AND FREE UP PARTIAL BLOCK       */     I=TEMP.LIST(0)+1;                       /* GET NEXT POINTER TO TEMP.LIST/GHOST.LIST ENTRY */     TEMP.LIST(0)=I;                         /* INCREMENT POINTER FOR AT LEAST ONE CHANNEL + POSSIBLE GHOST QUE */     TEMP.LIST(I)=MCHN;                      /* STORE MCHN ON TEMP FREE LIST */                                             /* NOTE MCHN MIGHT BE ZERO HERE */     IF (SMCHN<>0) THEN DO;                  /* FREE UP SPLICE CHANNEL AS WELL */        TEMP.LIST(0)=TEMP.LIST(0)+1;            /* COUNT ONE MORE FREE CHANNEL ON TEMP LIST */        TEMP.LIST(TEMP.LIST(0))=SMCHN\B.SPLICE; /* STORE SMCHN ON TEMP FREE LIST - INDICATE WAS IN PHASE WITH PREVIOUS CHANNEL */     END;     GHOST.LIST(I)=PPTR;                     /* PRETEND THIS IS A GHOST BLOCK.  RELEASE TEMP CHANNELS WILL CLEAN IT UP. PFPTR NEED NOT BE SET */   END;   IF (STEALOK&256)=0 THEN CALL NEW.DECAYER; /* REDUCE ACTIVE, INCREMENT DECAYER IF TRASHING ACTIVE NOTE */   WRITE(MAM)=THP;   WRITE(MAL)=THD.NDEC;   WRITE(MD )=READ(MD )-1;   IF NORIG=0 THEN DO;                       /* FROM KBD OR AXE - MUST HOUSECLEAN */     IF (INC.AXE=0)\(GDATA=0) THEN DO;       /* REQUE KEYBOARD NOTES FOR NEXT TIME */        NFPTR=RETRY.QUE; RETRY.QUE=NPTR;     /* STORE NOTE BLOCK ON QUE FOR RETRY NEXT TIME */        IF LOWER.DISP <> USED.DISP THEN DO;           IF ((NEW.PAN=1)&(LOWER.DISP<>LINES.DISP))           OR ((NEW.PAN=0)&(UPPER.DISP<>LINES.DISP))           THEN CALL KBD.ERROR(0);                    /* PRESENT ---- TO USER UNLESS OTHERE ERROR THERE */           ELSE REMOVE.KBD.ERROR=0;                   /* ELSE JUST KEEP ERROR THAT IS THERE */        END;     END;     ELSE DO;                                         /* JUST RELEASE GUITAR BLOCKS */        CORE(NPTR)=NFREEP;                            /* LINK US ON TO FRONT OF FREE QUE */        NFREEP    =NPTR  ;     END;   END;   ELSE DO;                           /* ELSE JUST RELEASE NOTE BLOCK FOR SEQUENCER NOTES */      CORE(NPTR)=NFREEP;              /* LINK US ON TO FRONT OF FREE QUE */      NFREEP    =NPTR  ;      IF NEW.PAN = 1                  /* PUT UP BARS, TRK# & BEAT# WHEN OUT OF VOICES */      AND DO.VOICE.CHECK <> 0      THEN DO;         IF DISP.TRK.BARS <> 0        /* IF BARS ALREADY UP */         THEN DO;                     /* SEE IF THEY CAN BE OVERWRITTEN YET */            IF (REAL.MILLISECONDS - DISP.TRK.TIME) IGT 1000  /* 1 SEC GONE BY YET? */            THEN DISP.TRK.BARS = 0;   /* OK TO PUT UP NEW BARS */         END;         IF DISP.TRK.BARS = 0 THEN DO;            CALL EMIT.STRING(16,'OV TRK-   ');  /* (WELL, NOT REALLY BARS ANY MORE) */            WRITE(MAM) = THP;            WRITE(MAL) = THD.TRK;     /* TRACK # WHERE VOICE IS LOST */            CALL EMIT.NUMBER(23,READ(MD)-1,0,LEFT.JUST);            CALL EMIT.NUMBER(26,BEAT.NUMBER,0,RIGHT.JUST);            SUPRESS.BEAT.DISPLAY = 1; /* HOLD BEAT DISPLAY FOR 5 SECONDS */            BEAT.DISPLAY.TIME = REAL.MILLISECONDS;            DISP.TRK.BARS = 1;        /* HOLD BARS FOR 1 SECOND */            DISP.TRK.TIME = REAL.MILLISECONDS;            LOWER.DISP = ERR.DISP;    /* SO BEAT DISPLAY CODE WILL CLEAR LINE */         END;      END;   END;   IF (TEMP.PTR <>TEMP.LIST(0))       /* STOLEN CHANELS NOT REUSED */   OR (MIDIGHOST<>0           )       /* STOLEN BUT UNUSED MIDI-ONLY PARTIAL BLOCK */   THEN CALL RELEASE.TEMP.CHANS;      /* USE SWAP PROC IF ACTUAL CHANNELS HERE */   ELSE DO;                           /* ELSE TRY TO EXIT 'ABORT.NOTE' FASTER */      TEMP.PTR=0;      TEMP.LIST(0)=0;   END;END ABORT.NOTE;/* $PAGE  -  CHECKQUE - CHECK FOR DECAYING CHANNEL AVAILABILITY *//* CHECKQUE - CHECK EXISTING NOTE LIST FOR DECAYING CHANNELS *//*            USED TO SEARCH FOR MORE CHANNELS (LONG FINAL   *//*            DECAYS) IF OUT OF CHANNELS                     */CHECKQUE: PROC;                          /* PROCEDURE TO CHECK NOTELIST FOR DECAYING CHANNELS */  DCL (TB,TBP,PTL,TRK,THP)    FIXED   EXTERNAL;   DCL NEW.TRK FIXED;  NEW.NPTR=0; SAVED.NPTR=NPTR;  NEW.TRK =256+TRK;                      /* SET UP FOR SCAN OF NOTE LIST */  NPTR=NOTELIST;                         /* START SCAN OF NOTE LIST */  DO WHILE NPTR<>0;                      /* SCAN LIST */    IF (STEALOK=NEW.TRK) THEN DO;        /* FOUND ONE SUITABLE FOR STEALING */       NEW.NPTR=NPTR;                    /* SAVE POINTER TO NOTE - WILL STEAL OLDEST (FIRST STRUCK) AVAILABLE NOTE DUE TO ORDER OF QUE */    END;    NPTR=NFPTR;                 /* MOVE AHEAD */  END;  IF NEW.NPTR<>0 THEN DO;       /* ONE FOUND - USE ITS CHANNELS */    NPTR=NEW.NPTR;              /* GET POINTER TO BLOCK */    CALL STEAL.CHANS;           /* STEAL CHANNELS, SET UP GHOST BLOCKS */  END;  NPTR=SAVED.NPTR; /* RESTORE NPTR TO NEW BLOCK */END CHECKQUE;/* $PAGE - ROUTINE TO START UP MUSIC NOTES IN MIDDLE */START.UP.MUSIC.NOTE.IN.MIDDLE: PROC SWAPABLE;   dcl (time) (1) fixed;   dcl (temp) (1) fixed;   dcl (delt) (1) fixed;   dcl (wave) (1) fixed;   dcl (base) (1) fixed;   dcl (loop) (1) fixed;   dcl (i,j,k)    fixed;   conv1:proc (a);      				/* convert from poly synth 16/8 format, to */      dcl a  array;     				/* 24 bit sample #                         */      a(1) = a(1) & 255;           	/* make sure upper half of word */                                   	/* field is 0.                  */      if a(1) = 0                  	/* if 8 lsb's are 0, then       */      then a(0) = (-a(0));         	/* negate 16 msb's              */      else do;                     	/* else use not function        */         a(0) = not(a(0));         	/* for msbs, negate for lsb     */         a(1) = (-(a(1))) & 255;      end;      a(1) = a(1) \ shl(a(0),8);   	/* now get 24-bit sample #      */      a(0) = shr(a(0),8);   end conv1;   conv2:proc (a);      				/* convert from 24 - bit sample # to       */      dcl a  array;     				/* negative 16/8 hardware format           */      a(0) = shl(a(0),8) \ shr(a(1),8);      a(1) = a(1) & 255;      if a(1) = 0                  	/* if 8 lsb's are 0, then       */      then a(0) = (-a(0));         	/* negate 16 msb's              */      else do;                     	/* else use not function        */         a(0) = not(a(0));         	/* for msbs, negate for lsb     */         a(1) = (-(a(1))) & 255;      end;      a(1) = a(1) | "177400";      	/* sign extend into page bits   */   end conv2;   /* Begin by computing when we would like to start this note.  */   /* pick a time that is about 80 msecs in front of us.         */   /* But make sure it is not after the end of the note!         */   disable;                    /* look at current play time      */   time(0) = play.time.msb;   time(1) = play.time.lsb;   enable;   call add16(prescan, time);  /* advance to future              */   if (Delay.Note.And.Cue.Starts <> 0) then do;  /* Pre-roll without audio */      /* Delay to the later of after the pre-roll or the normal start time */      if com32 (Delay.Note.And.Cue.Time,time) = lw#igt then do;         call copy32(Delay.Note.And.Cue.Time,time);      end;   end;   if COM32(time, loc(addr(FENDM))) = lw#igt   /* limit time to  */   then do;                                    /* the end of the */      call COPY32(loc(addr(FENDM)),time);      /* note, however  */      call SUB16 (1 ,time);   end;   /* Compute how late we will be starting the note: */   call SUB32(time, loc(addr(OTIMM)), delt);   /* If doing repeat or repeat/arpeggiate,  then delay the start */   /* of the note further so that it will start on an integer     */   /* multiple of the repeating interval:                         */   if (rrate <> 0) then do;                  /* if any repeat/arpeg         */      if (rrate & "040000") <> 0 then do;    /* repeat or repeat/arpeggiate */         I = RRATE & "017777";               /* GET REPEAT RATE, HZ * 100   */         call COPY32(Delt, BitMsbArray);     /* get # of msecs to delay     */         call ratio_multiply(i, 50000);      /* compute msecs*rrate/50,000  */                                             /* (yields 2 * # of repeat     */                                             /*  cycles)                    */         bitlsb = (bitlsb&"177776") + 2;     /* round up to next cycle      */         call ratio_multiply(50000, i);      /* get # of msecs to delay     */                                             /* (is now an integer multiple */         call COPY32(BitMsbArray, Delt);     /* and then delay note this    */                                             /* much now.                   */      end;      call ADD32(loc(addr(OTIMM)), delt, loc(addr(OTIMM)));  /* now note starts here */      RTIM = RTIM + delt(1);                 /* adjust single precision rtim as well */   end;   else call COPY32(time, loc(addr(OTIMM)));  /* now note starts here */   /* now loop over partial blocks.   If fm note, just start the */   /* note late (no sync to picture).  For poly notes,  start    */   /* up the note in the middle,  but watch out for loop         */   /* points, etc.                                               */   pptr = ptlst;   do while pptr <> 0;      if (mchn & b.poly) <> 0     /* for poly notes, do wave table */      then do;                    /* adjusting                     */         /* get the wave table information for this note: */         call COPY32(loc(addr(MONU)),   wave); /* get - wtable len */         call COPY32(loc(addr(MINC)),   base); /* base address     */         call COPY32(loc(addr(IATINT)), loop); /* loop length      */         /* convert to signed 32-bit sample #'s: */         call conv1(wave);    /* get pos wave table len  */         i = shr(base(1),8);  /* get base address page # */         base(1) = (base(1)&255) \ shl(base(0),8);         base(0) = (shr(base(0),8)) \ shl(i,8);         call conv1(loop);    /* get pos loop len (may be 0) */         /* look up actual poly synth frequency from partial block: */         noteadd = uonu&255;         notenum = unnm&255;         noteinc = uinc&255;         noteinc = noteinc + 1;    /* compute logical inc/num from */         notenum = 256 - notenum;  /* hardware units               */         /* now compute how many samples we must delay the start of */         /* the SF for.                                             */         call COPY32(Delt, BitMsbArray);			/* get time delay, msecs */         call ratio_multiply(1000,samp.speed);	/* un-correct for speed control */         call ratio_multiply(10000,99);			/* # of samples at 101.01010101 khz */         call ratio_multiply(noteinc*noteadd,notenum);	/* # of samples at actual rate */         if UCHN <> 0 then bitlsb = bitlsb & "177776";	/* make even for stereo sound files */         /* If we are looping,  limit the delay to the start of the   */         /* looping section.                                          */         if COM16(0, loop) <> lw#ieq then do;    /* if any looping, then    */            call SUB32(Wave, Loop, Temp);        /* limit amount to delay   */            if COM32(BitMsbArray, temp) >= lw#ieq   /* to the time up to    */            then call COPY32(Temp, BitMsbArray);    /* the loop start       */         end;                                       /* point                */         /* Else just limit the delay to the total length of the file       */         else if COM32(BitMsbArray, Wave) >= lw#ieq   /* if amount to delay is > */         then do;                                /* wave table length, then */            call COPY32(Wave, BitMsbArray);      /* must limit to play      */            call SUB16 (1,    BitMsbArray);      /* at least one sample     */         end;         call SUB32(Wave, BitMsbArray, Wave);    /* shorten total length    */         call ADD32(Base, BitMsbArray, Base);    /* and add to base addr    */         /* reconvert info back to synth format */         call conv2(wave);    /* get neg wave table len  */         i = shr(base(0),8);  /* get base address page # */         base(0) = (shl(base(0),8)) \ shr(base(1),8);         base(1) = (base(1)&255) \ shl(i,8);         /* and store back in partial block */         call COPY32(wave, loc(addr(MONU)));  /* note: loop length is */         call COPY32(base, loc(addr(MINC)));  /* unchanged            */         /* set up attack/decay times to avoid click */         if EATINT = (-1)             /* if 0 millisecond attack */         then EATINT=SHL(200,8)\200;  /* then use slow fade-in   */                                      /* since we are mid-audio  */      end;      pptr = pfptr;   end;END START.UP.MUSIC.NOTE.IN.MIDDLE;