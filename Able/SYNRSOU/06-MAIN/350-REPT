/* 350-REPT - CHECK EACH NOTE FOR REPEAT/ARPEGGIATE *//*   03/22/91 - cj -  Changed kbd.spl.time to fix Lee Kopp FM retrigger clicks   04/05/90 - TSS - FIX STUCK MIDI NOTE/EXTRA NOTE OFF BUGS   08/24/89 - PF  - Added PATH argument to MIDI.NOTE.OFF   10/3/88 - sgs - Fixed bugs in MONO VOICE card code   06/22/87 - MWH - Move multi.syn2 to external memory at MFM.PTR   01/06/87 - CJ - FIXED OTIM/+- BUGS IN REQUE OF REPEATED NOTES   12/30/86 - CJ - MONO SAMPLING ITEMS   7/28/86 - CJ,KC - CHANGED NACT COUNTING   7/13/86 - CJ - ADDED NORIG   7/11/86 - CJ - CHANGED QSTAT/SEQ.SPL.TIM OPERATION   5/15/86 - "official" creation of release-M modules*//* CHECK FOR REPEAT/ARPEGGIATE */BEGIN;  DCL (OPT) FIXED;                 /* HOLDS OPTION BITS IF NOTE RESTART, KBD TIME */  IF  (RRATE<>0)                   /* IF REPEAT/ARPEG IS ACTIVE       */  AND (PTRS.LOOPED=LOOP.RESTART)   /* AND PLAY.TIME MATCHES TIME BASE */  THEN DO;                         /* PERFORM REPEAT/ARPEG */    I=RRATE;                       /* GET INFO IN HANDY LOCAL VARIABLE      */    TIME.TO.REPEAT=0;              /* INITIALIZE TO NO REPEAT */    IF (I&"100000")<>0 THEN DO;             /* PERFORM ARPEGGIATE      */      WRITE(MAM)=THP;      WRITE(MAL)=THD.ARP;      IF READ(MD)=NPTR THEN DO;             /* THIS NOTE ONLY PROCESS IF THIS NOTE IS ON TOP OF QUE */        IF (I&"020000")<>0 THEN DO;         /* NOTE HAS ALREADY PLAYED - CHECK FOR TIME TO FIND NEXT ARPEGGIATE NOTE */          IF EXT.REP.ARP<>0 THEN DO;        /* EXTERNAL TRIGGERING */            CALL STEP.ARP.PTR(TRK);         /* MOVE TO NEXT ONE IMMEDIATELY    */          END;          ELSE DO;            IF NORIG=0                                    /* KEYBOARD NOTE */            THEN J=SAMPLED.KBD.MILLISECONDS+REPSCAN2;     /* KEYBOARD  NOTE - CHECK MILLISECONDS */            ELSE J=SAMPLED.ACTUAL.PLAY.TIME.LSB+REPSCAN1; /* SEQUENCER NOTE - CHECK PLAY.TIME */            IF (J>=RTIM)                      /* TIME TO ADVANCE PTR TO NEXT NOTE.  CHECK ACTUAL PLAY.TIME ON NEXT LOOP */            THEN DO;              CALL STEP.ARP.PTR(TRK);         /* SET UP TO TRIGGER NEXT NOTE AT PROPER TIME */            END;          END;        END;        ELSE DO;                            /* NOTE HAS NOT SOUNDED - CHECK FOR INSTANT TIME */          IF EXT.REP.ARP<>0 THEN DO;        /* EXTERNAL TRIGGERING */            IF EXT.REP.TRIGGER<>0 THEN DO;              TIME.TO.REPEAT=1;              RRATE=RRATE\"020000";         /* INDICATE NOTE HAS TRIGGERED */            END;          END;          ELSE DO;            IF NORIG=0                      /* KEYBOARD NOTE */            THEN J=SAMPLED.KBD.MILLISECONDS;                ELSE J=SAMPLED.ACTUAL.PLAY.TIME.LSB;            IF (J>=RTIM)                    /* TIME TO ADVANCE NOTE TO NEXT SOUND */            THEN DO;              TIME.TO.REPEAT=1;             /* SET FLAG TO REQUE ATTACK  */              RRATE=RRATE\"020000";         /* INDICATE NOTE HAS TRIGGERED */            END;          END;        END;           /* OF CASE FOR NOTE HAS NOT SOUNDED */      END;             /* OF CASE FOR THIS NOTE            */    END;               /* OF CASE FOR ARPEGGIATE           */    ELSE IF (I&"040000")<>0 THEN DO;         /* PERFORM REPEAT WITHOUT ARPEGGIATE */      IF EXT.REP.ARP<>0 THEN DO;             /* EXTERNAL TRIGGER */        TIME.TO.REPEAT=EXT.REP.TRIGGER;      END;      ELSE IF NORIG=0 THEN DO;               /* KEYBOARD NOTE */        IF SAMPLED.KBD.MILLISECONDS>=RTIM THEN DO; /* TIME TO REPEAT KEYBOARD NOTE */          TIME.TO.REPEAT=1;                        /* SET FLAG TO REQUE ATTACK */        END;      END;      ELSE DO;                                     /* SEQUENCER NOTE - CHECK PLAY TIME */        IF  (SAMPLED.ACTUAL.PLAY.TIME.LSB>=RTIM)   /* APPROACHING TIME TO REPEAT NOTE */        AND (LOOP.RESTART=PTRS.LOOPED)             /* PLAY.TIME MATCHES RTIM    */        THEN TIME.TO.REPEAT=1;                     /* SET FLAG TO REQUE ATTACK  */      END;    END;                   /* OF CASE FOR REPEAT */    /* $PAGE - RETRIGGER ATTACKS IF REQUIRED FOR REPEAT, ARPEGGIATE FEATURE */    IF TIME.TO.REPEAT THEN DO;               /* MUST TRIGGER ATTACKS AGAIN             */      IF EXT.REP.ARP<>0 THEN DO;             /* USE EXTERNAL TIME                      */        OTIML=EXT.PULSE.TIME+SYNC.DELAY;        RTIM =OTIML+REPSCAN2;                /* SOMETHING CONSISTENT IN RTIM */      END;      ELSE DO;                               /* COMPUTE NEW RTIM         */         IF NORIG=0 THEN DO;                 /* KEYBOARD NOTE            */           OTIML=RTIM+REPSCAN2;              /* CORRECT FOR REPEAT PRESCAN  */         END;         ELSE DO;                            /* COMPUTE NEW TIME FOR KEYBOARD NOTES */           OTIML=RTIM+REPSCAN1;              /* COMPUTE NEW TIME FOR NOTE */         END;         J=I&"017777";                       /* GET REPEAT RATE, HZ       */         IF J<4 THEN RTIM=RTIM+25000;        /* LIMIT TO 25 SECOND INTERV */         ELSE DO;           LOAD 34464+REMAIN;                /* LOAD 100,000+REMIANDER    */           ULOAD 1;                          /* (WILL NOT OVERFLOW SINCE  */           DIV J;                            /* REMAINDER < 8192)         */           REMAIN=READ(4);                   /* SAVE REMAINDER FOR BETTER ROUND OFF COMPUTATION */           IF RES<20 THEN LOAD RTIM=RTIM+20; /* LIMIT MAX REPEAT RATE TO 50.00 HZ */           ELSE RTIM=RTIM+RES;               /* COMPUTE TIME OF NEXT REPEAT FOR SEQ NOTES */         END;      END;      PPTR=PTLST;              /* PICK UP POINTER TO PARTIAL TIMBRE LIST */      DO WHILE PPTR<>0;        /* CYCLE THROUGH EACH ONE TO RESTART      */        DISABLE;               /* REMOVE FROM EQF IF TRIGGERING TO FAST  */        IF EQF<>0 THEN DO;     /* BLOCK IS LINKED ON TO A TIMER QUE      */           CORE(EQB  )=EQF;    /* OUR FP GOES TO FP BEHIND   US */           CORE(EQF+1)=EQB;    /* OUR BP GOES TO BP AHEAD OF US */           EQF=0;        END;        IF IQF<>0 THEN DO;     /* BLOCK IS LINKED ON TO A TIMER QUE */           CORE(IQB  )=IQF;    /* OUR FP GOES TO FP BEHIND   US */           CORE(IQF+1)=IQB;    /* OUR BP GOES TO BP AHEAD OF US */           IQF=0;        END;        ENABLE;        IF MIDIRT<>0 THEN MIDIRT=MIDIRT \ THD.MIDI.CHANP;    /* SPECIAL BIT TO DENOTE REPEATING/ARPEGGIATING NOTE */        IF MCHN<>0 THEN DO;                     /* COMPUTE INFO IF NOT MIDI-ONLY BLOCK */           PTL=PARTL;                           /* LOOK UP PARTIAL # FOR SPEED            */           WRITE(MAM)=TBP;           WRITE(MAL)=TIM.OPTIONS+PTL;           OPT=READ(MD);                        /* LOOK UP PARTIAL OPTIONS FOR SPEED  */           WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;           PTPTR=READ(MD);                      /* GET PTR TO PARTIAL INFO */           IF (SMCHN<>0)&(FMPTR<>0) THEN DO;    /* IF SPLICING HAD BEGUN - MUST RESET FRAME POINTER */              IF (UCHN<0)&(SUCHN>=0) THEN DO;   /* SWAP CHANNELS IF SUCHN IS QUIET BUT UCHN IS NOT */                 I=UCHN;UCHN=SUCHN;SUCHN=I;     /* SWAP CHANNELS FOR RETRIGGER */                 I=MCHN;MCHN=SMCHN;SMCHN=I;              END;              FMPTR=0;                          /* RESET FRAME POINTER */           END;           IF PSTAT=DONE.STATE THEN DO;         /* SET BACK TO ACTIVE STATE FOR REPEAT */              NACT=NACT+1;                      /* RESTORE TO ACTIVE PARTIAL TIMBRES IF INITIAL DECAY HAD REACHED 0 */              PSTAT=DELAY.STATE;                /* RETURN TO DELAY STATE IF HAD BEEN DONE */           END;           ELSE DO;                             /* CURRENTLY ACTIVE - CHECK FOR POLY SYNTH SPLICE */              IF PSTAT<>DELAY.STATE             /* IF IN OTHER THAN DELAY STATE */              THEN PSTAT=REPT.STATE;            /* INDICATE REPEAT DELAY STATE IF HAD BEEN IN SOME OTHER STATE */           END;           WRITE("300")=ADDR(C.E.L);            /* ZERO OUT C.E.L, P.E.E, P.I.E */           WRITE("360")=0; WRITE("360")=0;           WRITE("360")=0;            SUPR = SUPR & "137400";              /* CLEAR POSSIBLE SUPPR BIT FROM INITIAL DECAY TO ZERO */           IF (OPT&ANY.DELAY)<>0                /* IF EITHER ENV OR INDEX IS DELAYED */           THEN CALL COMPUTE.DELAY;             /* THEN WE MUST COMPUTE INFO FOR SPECIAL QUES - ALSO HANDLE RTE PATCHES TO DELAYS */           ELSE DO;                             /* INITIALIZE DELAYS QUICKLY */              ETIMER=0;              ITIMER=0;           END;           IF (OPT&ENV.RTES)<>0                 /* ENV RTE'S - RECOMPUTE ON REPEAT */           THEN CALL COMPUTE.ENV;           IF (EIDLIM=0)&(MIDIRT<>0) THEN DO;   /* CHANGING KNOB HERE - MAKE SURE NOTE OFF GOES OUT */              CALL MIDI.NOTE.OFF(MIDIRT, MIDIPATH, MIDIINFO); /* TURN NOTE OFF */              MIDIRT=0;              /******/;                         /* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */           END;                      IF DO.FM<>0 THEN DO;              IF (OPT&INX.RTES)=0               /* IF INX RTES USED, RECOMPUTE ATTACK/DECAY INFO FOR NEW RTES */              THEN CALL COMPUTE.INX;            /* ELSE USE PROCEDURE CALL */           END;           ELSE ITIMER=ETIMER-1;                /* NO FM - MAKE SURE DIFFERENT FROM ETIMER - SIMPLIFIES QUEING & INTERRUPT CODE */           STIMER=0;           IF  ((INC.MONO=0)                    /* IF NO SAMPLING AT ALL */           AND  (INC.POLY=0))           OR (MCHN&(B.MONO\B.POLY))=0 THEN DO; /* OR ORIGINAL SYNTHESIZER - COMPUTE ITEMS */              ISTAT=0; SSTAT=0;                 /* ZERO OUT ENV STATES FOR RETRIGGER */              IF MULTI.THERE<>0 THEN DO;             /* INITIALIZE MULTI STUFF IN CASE CHANNEL TURNED OFF */                 WRITE(MAM)=THP;                 WRITE(MAL)=THD.TROU;                 I=READ(MD);                         /* GET L & R ROUTING (WITH ON BIT SET) */                 J=SHL(I,8);                         /* GET RIGHT ROUTING (IN LOWER HALF) */                 I=I&"177400";                       /* GET LEFT  ROUTING (IN UPPER HALF) */                 K=SHR(MCHN&255,1);                  /* GET CHAN ID       */                 DISABLE;                 WRITE(D32)="21";                    /* SELECT MULTI I/O  */                 WRITE(MAM) = MFM.PTR;               /* POINT AT MULTI->FM MAP */                 WRITE(MAL) = K;                     /* WORD OFFSET */                 WRITE(D33)=I\(SHR(READ(MD),8));     /* ROUTE LEFT INPUT TO LEFT OUTPUT */                 WRITE(D33)=J\(READ(MD)&255);        /* ROUTE RITE INPUT TO RITE OUTPUT */                 IF (SMCHN<>0) THEN DO;              /* IN CASE IT IS  */                    WRITE(MAL)=SHR(SMCHN&255,1);     /* SPLICE CHANNEL */                    WRITE(D33)=I\(SHR(READ(MD),8));  /* ROUTE LEFT INPUT TO LEFT OUTPUT */                    WRITE(D33)=J\(READ(MD)&255);     /* ROUTE RITE INPUT TO RITE OUTPUT */                 END;                 ENABLE;              END;              IF  (NORIG<>0)                    /* SEQUENCER NOTE      */              AND (EXT.REP.ARP=0)               /* INTERNAL REP/ARP    */              THEN DO;                          /* THEN DO IT          */                 STIMER=STIMER-SEQ.SPL.TIM;     /* BACK UP SPLICE TIME */                 QSTAT=SHL(SEQ.FM1,8)+SEQ.FM2;  /* SAVE TIME; SET <> 0 */              END;              ELSE DO;                          /* KEYBOARD            */                 ETIMER=ETIMER-KBD.SPL.TIM;                 ITIMER=ITIMER-KBD.SPL.TIM;                 QSTAT=SHL(KBD.FM1,8)+KBD.FM2;  /* CONSTRUCT SPLICE    */              END;           END;                                 /* OF ORIGINAL SYNCLAV CASE */           ELSE BEGIN;                          /* FOR MONO OR POLY - GET INFO */              IF (INC.MONO<>0)&((MCHN&B.MONO)<>0) THEN DO;  /* MONO SAMPLING (W. DISK) */                 IF (UNNM=MIN.SAMP)             /* CHECK FOR OUT OF RANGE AT NOTE START ONLY */                 OR (UNNM=MAX.SAMP)                 THEN DO;                       /* SAMPLING RATE OUT OF RANGE */                    CALL RANGE.ERROR;           /* DISPLAY ERROR MESSAGE */                    ISTAT=2;                    /* FOR NOW, KEEP NOTE FROM HAPPENING */                 END;                 ELSE IF (NORIG<>0)             /* SEQUENCER NOTE - REDUCE DELAY SO WE CUT OFF NOTES EARLY TO MAKE SPLICE */                 AND     (EXT.REP.ARP=0)        /* INTERNAL REP/ARP    */                 THEN DO;                    ISTAT=1;                    /* SEQUENCER NOTE - DELAY 15 MSEC TICKS FOR SPLICE */                    STIMER=STIMER-SEQ.MONO3;    /* BACK UP STIMER FOR SPLICE & LOAD */                    QSTAT=SEQ.MONO3;            /* SET QSTAT; SAVE ORIGINAL VALUE IN CASE SPEED SETTING CHANGES */                 END;                 ELSE DO;                    ISTAT=0;                    /* KEYBOARD NOTE - NO DELAY CORRECTION REQUIRED */                    ETIMER=ETIMER-KBD.MONO3;                    ITIMER=ITIMER-KBD.MONO3;                    QSTAT=KBD.MONO3;                 END;              END;              ELSE IF (INC.POLY<>0) THEN DO;       /* MEANS POLY SYNTH */                 WRITE(MAM)=TBP;                 WRITE(MAL)=TIM.SYNTH.TYP+PTL;                 IF (READ(MD)=2)                   /* PATCH LIST POLY SAMP NOTE */                 THEN DO;                          /* CONSTRUCT SPLICE    */                    IF  (NORIG<>0)                 /* SEQUENCER NOTE      */                    AND (EXT.REP.ARP=0)            /* INTERNAL REP/ARP    */                    THEN DO;                       /* THEN DO IT          */                       STIMER=STIMER-SEQ.SPL.TIM;  /* BACK UP SPLICE TIME */                       QSTAT=SEQ.SPL.TIM;          /* SAVE TIME; SET <> 0 */                    END;                    ELSE DO;                       /* KEYBOARD            */                       ETIMER=ETIMER-KBD.SPL.TIM;                       ITIMER=ITIMER-KBD.SPL.TIM;                       QSTAT =KBD.SPL.TIM;          /* CONSTRUCT SPLICE    */                    END;                 END;              END;                        /* OF POLY                  */           END;                           /* OF MONO OR POLY SAMPLING */        END;                              /* IF MCHN<>0 CASE          */        ELSE DO;                          /* MAKE SURE ETIMER SET     */           ETIMER=0;           ITIMER=(-1);                   /* SET ITIMER FOR CONSISTENCY */           STIMER=0;        END;        PPTR=PFPTR;                       /* MOVE ON TO NEXT ONE */      END;      PPTR=PTLST;                         /* SET POINTER TO FIRST PARTIAL BLOCK */      DISABLE;                            /* FOR QUEING */      IF (EXT.REP.ARP<>0)                 /* EXTERNAL REPEAT/ARPEG */      OR (NORIG=0)                        /* OR KEYBOARD           */      THEN DO;                            /* KEYBOARD/GUITAR NOTE  */         IF INC.MONO=0 THEN DO;            IF KBD.MILLISECONDS>=(OTIML-KBD.SPL.TIM)     /* SEE IF WE ARE STARTING NOTE LATE */            THEN OTIML=KBD.MILLISECONDS+(KBD.SPL.TIM+1); /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */         END;         ELSE DO;            WRITE(MAM)=TBP;            WRITE(MAL)=TIM.TOPTIONS;            IF (READ(MD)&ANY.SAMPLED)<>0 THEN DO;           /* LEAVE TIME FOR MONO SAMPLING SPLICE */               IF KBD.MILLISECONDS>=(OTIML-KBD.MONO3)       /* SEE IF WE ARE STARTING NOTE LATE */               THEN OTIML=KBD.MILLISECONDS+(KBD.MONO3+1);   /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */            END;            ELSE DO;                                        /* NO SAMPLING */               IF KBD.MILLISECONDS>=(OTIML-KBD.SPL.TIM)     /* SEE IF WE ARE STARTING NOTE LATE */               THEN OTIML=KBD.MILLISECONDS+(KBD.SPL.TIM+1); /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */            END;         END;         DO WHILE PPTR<>0;                /* CYCLE THROUGH EACH PARTIAL BLOCK   */            ETIMER=OTIML+ETIMER;          /* GET ABSOLUTE TIME TO TRIGGER       */            ITIMER=OTIML+ITIMER;            J=ETIMER;                     /* SORT INTO QUE                      */            K=EKBQB;                      /* SEARCHING BACKWARDS FOR BEST SPEED */            DO WHILE (K<>ADDR(EKBQF))                     AND      (J<CORE(K+(ETLOC-EQFLOC)));               K=CORE(K+1);               /* BACKWARDS                          */            END;            EQB        =K;                /* LINK US AFTER THE BLOCK ON QUE     */            EQF        =CORE(K);                   CORE(EQF+1)=ADDR(EQF);                          CORE(K)    =ADDR(EQF);                          IF  (DO.FM<>0)                /* IF FM IS USED ON THIS PARTIAL */            AND (ITIMER<>ETIMER)          /* BUT DIFFERENT DELAY */            THEN DO;                      /* MUST LINK TO INDEX QUE AS WELL */               J=ITIMER;                  /* SORT INTO QUE                      */               K=IKBQB;                   /* SEARCHING BACKWARDS FOR BEST SPEED */               DO WHILE (K<>ADDR(IKBQF))                     AND      (J<CORE(K+(ITLOC-IQFLOC)));                  K=CORE(K+1);            /* BACKWARDS                          */               END;               IQB        =K;             /* LINK US AFTER THE BLOCK ON QUE     */               IQF        =CORE(K);                         CORE(IQF+1)=ADDR(IQF);                          CORE(K)    =ADDR(IQF);                          ANY.INDEX.QUES=1;            END;            PPTR=PFPTR;                   /* GET FOWARD POINTER */         END;      END;      ELSE DO;                         /* QUE UP SEQUENCER NOTES */         IF INC.MONO=0 THEN DO;     /* FM ONLY/POLY */            IF PLAY.TIME.LSB>=(OTIML-SEQ.SPL.TIM)      /* SEE IF WE ARE STARTING NOTE LATE */            THEN OTIML=PLAY.TIME.LSB+SEQ.SPL.TIM+1;    /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */         END;         ELSE DO;            IF PLAY.TIME.LSB>=(OTIML-SEQ.MONO3)         /* SEE IF WE ARE STARTING NOTE LATE */            THEN OTIML=PLAY.TIME.LSB+SEQ.MONO3+1;       /* MUST DELAY DELAYED PARTIALS TO GET CORRECT SOUND */         END;         DO WHILE PPTR<>0;             /* CYCLE THROUGH EACH PARTIAL BLOCK   */            STIMER=OTIML+STIMER;            K=STIMER;                  /* SORT INTO QUE                      */            L=EDLQB;                   /* SEARCHING BACKWARDS FOR BEST SPEED */            DO WHILE (L<>ADDR(EDLQF))                  AND      (K<CORE(L+(STLOC-EQFLOC)));               L=CORE(L+1);            /* BACKWARDS                          */            END;            EQB        =L;             /* LINK US AFTER THE BLOCK ON QUE     */            EQF        =CORE(L);                      CORE(EQF+1)=ADDR(EQF);                          CORE(L)    =ADDR(EQF);                                     PPTR=PFPTR;                /* MOVE ON TO NEXT PARTIAL */         END;                          /* OF LOOP OVER PARTIALS */      END;                             /* OF SEQ NOTE */      ENABLE;    END;            /* OF TRIGGER ATTACKS AGAIN */  END;              /* IF CASE FOR RRATE<>0 */END;                /* OF BEGIN */