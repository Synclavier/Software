/* 313-GHLD  -  MIDI PROGRAM CHANGE RECORDING,  SYSTEM EXCLUSIVE RECORDING,                GUITAR HOLD SWITCH RECORDING *//*   09/23/89 - CJ  - FIXED BUG WITH ENABLE/DISABLE   06/15/89 - PF  - Updated sysex logic to allow direct to track recording   11/22/88 - TSS - Fixed some bugs in MIDI program change code   04/13/88 - PF - ADDED SYSTEM EXCLUSIVE RECORDING AND ECHOING   04/13/88 - PF - ADDED CODE FOR MEMORY MAPS TO RESPOND TO PROGRAM CHANGES   04/13/88 - PF - ADDED CODE FOR MULTI RECORDING OF PROGRAM CHANGES   10/30/86 - TS - ADDED SOME CODE TO ALLOW ECHO OF MIDI PROGRAM CHANGES   8/25/86 - eg - got guitar code going   7/31/86 - CJ - LOD RECORDING CHECKS*//* PROCESS MIDI PROGRAM CHANGES THAT HAVE COME IN */BEGIN;   DCL OUR.PTR FIXED;   OUR.PTR=1;   DISABLE;      DO WHILE OUR.PTR <= NEW.PROGRAM.STAK(0);     /* PROGRAM CHANGE TO PROCESS */      ENABLE;      DCL CH  FIXED;                            /* TEMP VAR FOR CHANNEL ORIGIN */      DCL NUM FIXED;                            /* TEMP VAR FOR PROGRAM NUMBER */      CH =SHR(NEW.PROGRAM.STAK(OUR.PTR),8);     /* GET POLY.TIMBRE INFO */      NUM=NEW.PROGRAM.STAK(OUR.PTR)&127;        /* GET PROGRAM NUMBER   */      IF MIDI.ECHO.DISABLED=0 THEN DO;         IF TRK.HEAD.LOOKUP(CH,THD.MIDI)<>0      /* MIDI OUTPUT ENABLED ON THIS KBD/TRK */ // was midi  mapped         THEN CALL MIDI.PROGRAM.CHANGE(NUM&127); /* SEND OUT MIDI PORT */      END;      WRITE(MAM)=TBUT.PTR;      WRITE(MAL)=CH;						  // was midi  mapped      IF  ((RECD<>0)                          /* RECORDING                    */      AND (RECD.TRK<>0)                       /* SYNCLAVIER RECORDING         */      AND (CH=0))                             /* MIDI IS DIRECTED AT KEYBOARD */      OR  ((RECD.TRK<>0)                      /* SYNCLAVIER RECORDING           */      AND ((READ(MD)&B.READY.TRK)<>0)) THEN DO; /* THIS TRACK IS ARMED FOR RECD */                IF CH=0 THEN TRK=RECD.TRK;           /* MIDI ROUTED TO OUR KEYBOARD */         ELSE TRK=CH;           			  /* MIDI ROUTED TO TRACK        */ // was midi  mapped         WRITE(MAM)=TRK.HEAD;         WRITE(MAL)=TRK;         THP=READ(MD);         CALL COMPUTE.RTE.TIME;               /* CORRECT FOR EARLY/LATE */         WRITE(MAM)=THP;         WRITE(MAL)=THD.CPROGRAM;         I=READ(MD);                          /* GET CURRENT PROGRAM NUMBER FOR BELOW */         WRITE(MD)=NUM;                       /* STORE NEW NUMBER */         WRITE(MAL)=THD.MIDI;         IF READ(MD)<>0 THEN DO;              /* MIDI SENT NOW OR LATER */            WRITE(MAL)=THD.MIDI.CPROGRAM;            WRITE(MD )=NUM;                   /* UPDATE LAST NUMBER SENT */         END;         IF STORE.DATA.RECORD(RTEMSB,RTELSB,24,3,NUM,B.UPD,I)=0         THEN CALL DISPLAY.ERR(17);         /* OUT OF NOTES */      END;      OUR.PTR=OUR.PTR+1;                    /* POINT TO NEXT CHANGE (IF ONE) */      DISABLE;   END;                                     /* OF PROGRAMS TO PROCESS */   NEW.PROGRAM.STAK(0)=0;                   /* CLEAR OUT LIST         */   ENABLE;END;/*   IF ANY SYSTEM EXCLUSIVE BYTES IN BUFFER THEN PROCESS UP TO THREE   BYTES EACH TIME THROUGH LOOP.*/DISABLE;IF SYSEX.READ.PTR<>SYSEX.WRITE.PTR THEN BEGIN;    /* SYSTEM EXCLUSIVE DATA TO PROCESS */   ENABLE;   DCL I          FIXED;   DCL SYSEX.BYTE FIXED;   DCL TRK        FIXED;   DO I=0 TO 2;                                   /* PROCESS THREE BYTES EACH TIME THRU LOOP */      DISABLE;      IF SYSEX.READ.PTR<>SYSEX.WRITE.PTR THEN DO; /* HAVE A BYTE TO PROCESS */         ENABLE;         WRITE(MAM)=SYSEX.BUF+(SHR(SYSEX.READ.PTR&"7777",8));   /* POINT TO SYSEX BUFFER */         WRITE(MAL)=SYSEX.READ.PTR;         SYSEX.BYTE=READ(MD)&"377";             /* GET NEXT BYTE */         TRK = SHR(READ(MD),8);                 /* GET DEST TRACK */         SYSEX.READ.PTR=SYSEX.READ.PTR+1;       /* INCREMENT POINTER */         IF SYSEX.BYTE=240 THEN DO;             /* THIS IS THE FIRST BYTE OF A NEW MESSAGE */            DISABLE;               SXMSB=PLAY.TIME.MSB;             /* GET PLAY TIME FOR THIS MESSAGE */               SXLSB=PLAY.TIME.LSB;                          ENABLE;            if tempo.map.ptr <> 0            then call Map.Real.Time.To.Sequence.Time(loc(addr(SXMSB)), loc(addr(SXMSB)));         END;         IF MIDI.ECHO.DISABLED=0 THEN DO;       /* WE ARE ECHOING MIDI */            IF TRK.HEAD.LOOKUP(TRK,THD.MIDI)<>0 /* KEYBOARD MIDI OUTPUT ENABLED */            THEN DO;               CALL SEND.SYSEX(SYSEX.BYTE);     /* SEND OUT SYSTEM EXCLUSIVE */            END;         END;         IF TRK=0 THEN TRK=RECD.TRK;            /* THIS DATA ROUTED TO KBD - DIRECT IT TO CURRENT RECORD TRACK */         WRITE(MAM) = TBUT.PTR;                 /* TRACK LOOKUP TABLE */         WRITE(MAL) = TRK;                      /* FOR THIS TRACK */         if  (recd<>0)                          /* recording                */         and ((trk=recd.trk)                    /* on this synclavier track */         or  ((recd.trk<>0)                     /* synclavier recording     */         and ((read(md)&b.ready.trk)<>0)))      /* this track is armed   */         then do;                               /* recording on this track  */            WRITE(MAM)=TRK.HEAD;                /* POINT TO TRACK HEAD */            WRITE(MAL)=TRK;                     /* FOR THIS TRACK */            THP=READ(MD);                       /* SETUP THP */            IF STORE.DATA.RECORD(SXMSB,SXLSB,24,7,SYSEX.BYTE,B.UPD,0)=0            THEN CALL DISPLAY.ERR(17);          /* OUT OF NOTES */         END;      END;                          /* OF INDIVIDUAL BYTE PROCESSING */      ELSE ENABLE;   END;                             /* OF 3 ITERATION LOOP */   SXLSB=SXLSB+1;                   /* INCREMENT TIME TO RECORD BY */   IF SXLSB=0 THEN SXMSB=SXMSB+1;   /* ONE MILLISECOND EVERY THIRD BYTE */END;                                /* OF SYSEX PROCESSING */ELSE ENABLE;DCL PGHOLDSW      FIXED EXTERNAL;DCL GHOLDSW       FIXED EXTERNAL;IF (INC.AXE<>0) THEN BEGIN;              /* ONLY INCLUDE CODE FOR GUITAR COMPILATIONS */   IF (PGHOLDSW=0)&(GHOLDSW<>0) THEN DO; /* PRESSING HOLD SWITCH */      IF (RECD<>0) & (RECD.TRK<>0) THEN DO; /* RECORD GUITAR HOLD SWITCH */         CALL COMPUTE.RTE.TIME;         IF STORE.DATA.RECORD(RTEMSB,RTELSB,24,0,0,B.UPD+B.GUI+6,0)=0  /* STORE AN UPDATE RECORD REFERENCING STRING 6, WITH FIELDS AS SPECIFIED - USED DURING PLAYBACK */         THEN CALL DISPLAY.ERR(17);      /* OUT OF NOTES */      END;      NPTR=NOTELIST;                     /* LOOK AT ALL ACTIVE NOTES */      DO WHILE (NPTR<>0);                /* PROCESS EACH ONE */         IF GDATA<>0 THEN DO;            /* GUITAR NOTE - CHANGE TO STRING 6 (0-5 BEING REAL) TO STOP UPDATES & DECAYS */            GDATA=SHL(GVOL,8)\6;         /* SAVE CURRENT VOLUME, SET STRING TYPE TO 6 */            SBITS=(SBITS&"177770")\6;    /* ALSO IN NOTE BLOCK SO NO TIED STRINGS OCCUR */         END;         NPTR=NFPTR;                     /* GET NEXT BLOCK */      END;      PGHOLDSW=GHOLDSW;   END;   ELSE IF (PGHOLDSW<>0)&(GHOLDSW=0) THEN DO; /* SWITCH RELEASED - CLEAN UP */      STRING.DONE=STRING.DONE\"100";          /* SET THIS BIT IN STRING.DONE TO STOP THE HELD NOTES */      PGHOLDSW=GHOLDSW;   END;END;