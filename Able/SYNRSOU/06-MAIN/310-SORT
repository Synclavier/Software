/* :SYNRSOU:06-MAIN:310-SORT  -  CODE TO SORT CHANNEL LISTS *//*   12/2/88 - cj  - updated polyused on the fly   6/25/87 - MWH - Split FRP.PTR into FP0-FP3.PTR for expanded poly   7/09/86 - KJC - fixed poly channel sort bug   6/23/86 - KJC - added poly channel sort   5/15/86 - "official" creation of release-M modules*//* THE SYNCLAVIER SYNTHESIZER REQUIRES CHANNELS IN THE SAME   PHYSICAL SYNTHESIZER TO CREATE RESYNTHESIZED SOUNDS.   THIS IS FACILITED BY SORTING THE FREE CHANNEL LIST IN OUR FREE TIME */BEGIN;   DCL (L1PTR,L2PTR) FIXED;             /* CHANNEL SORT POINTERS */   IF SORT.TOGGLE=0 THEN DO;            /* BUBBLE SORT FR1 */      IF L1PTR<CORE(FR1.PTR)-1 THEN DO; /* BUBBLE SORT FREE CHANNEL LIST */         L1PTR=L1PTR+1;                 /* POINT TO CHANNEL PAIR         */         IF (CORE(FR1.PTR+L1PTR)&255)<(CORE(FR1.PTR+L1PTR+1)&255)         THEN DO;                       /* SWAP CHANNELS */            I=CORE(FR1.PTR+L1PTR); CORE(FR1.PTR+L1PTR)=CORE(FR1.PTR+L1PTR+1);            CORE(FR1.PTR+L1PTR+1)=I;         END;      END;      ELSE L1PTR=0;                     /* RESET POINTER */   END;   ELSE DO;      IF L2PTR<CORE(FR2.PTR)-1 THEN DO; /* BUBBLE SORT FREE CHANNEL LIST */         L2PTR=L2PTR+1;                 /* POINT TO CHANNEL PAIR         */         IF (CORE(FR2.PTR+L2PTR)&255)<(CORE(FR2.PTR+L2PTR+1)&255)         THEN DO;                       /* SWAP CHANNELS */            I=CORE(FR2.PTR+L2PTR); CORE(FR2.PTR+L2PTR)=CORE(FR2.PTR+L2PTR+1);            CORE(FR2.PTR+L2PTR+1)=I;         END;      END;      ELSE L2PTR=0;                     /* RESET POINTER */   END;   SORT.TOGGLE=SORT.TOGGLE XOR 1;       /* SWAP */END;/* $page *//* Channels used for stereo playback on the poly synthesizer must   be adjacent, with the master channel being even.  It is therefore   desirable to maintain the free channel list for the poly synthesizer   by stereo pairs, where a stereo pair is comprised of two adjacent   channels, the even channel being smaller than the odd channel (e.g.,   2,3 and 20,21).   This routine sorts the free channel list into stereo pairs in our   spare time.  One pass through one poly list each time around. */begin;                                         /* bubble sort the poly free list */   dcl bin                  fixed;             /* which poly bin */   dcl lpsave (PSMAXBINS-1) fixed;             /* save current lpptr here for each bin */   dcl ptr                  pointer;           /* channel list pointer */   dcl lpptr                fixed;             /* poly channel pointer */   bin = bin + 1;                              /* look at next bin's list */   if bin >= polynums then bin = 0;            /* wrap around at end */   ptr = core(addr(fp0.ptr) + bin);            /* point at list for this bin */   lpptr = lpsave(bin);                        /* retrieve saved pointer into this bin's list */   if lpptr < core(ptr) - 1 then do;           /* if in range */      lpptr = lpptr + 1;                       /* point to next channel */      x = (core(ptr + lpptr) and "377");       /* pick up current channel */      y = (core(ptr + lpptr + 1) and "377");   /* and next */      if x > y then do;                        /* if not in order, perform swap */         if ((not x) or (lpptr <= 1)           /* check for stereo pair below */         or (x - 1 <> (core(ptr + lpptr - 1) and "377")))         then m = 1;                           /* no stereo pair */         else m = 2;                           /* found a stereo pair below */         if (y or (lpptr >= core(ptr) - 1)     /* check for stereo pair above */         or (y + 1 <> (core(ptr + lpptr + 2) and "377")))         then n = 1;                           /* no stereo pair */         else n = 2;                           /* found a stereo pair above */         p = m - 1;                            /* determine offset from LPPTR to start of possible pair below */         q = n - 1;                            /* determine LPPTR advance after swap */         if m > n then i = m; else i = n;      /* i = max(m, n); */         do i = 1 to i;                        /* swap the channels (and possible stereo pairs) */            if m > 0 then m = m - 1; n = n - 1;            j = core(ptr + lpptr + 1 + n);            core(ptr + lpptr + 1 + n) = core(ptr + lpptr + m - p);            core(ptr + lpptr + m - p) = j;         end;                                  /* of swapping channels */         lpptr = lpptr + q;                    /* point to next channel */      end;                                     /* of perform swap */   end;   else lpptr = 0;                             /* reset sort pointer for next pass */   lpsave(bin) = lpptr;                        /* save pointer into this bin's list */   /* Keep track of max channel usage for poly */   i = polynumvs(bin) - core(ptr);             /* get # of used voices */   if i > polyused(bin) then do;               /* if new max used ...  */      polyused(bin) = i;                       /* save away            */      if (upper.disp = (poly.l-par.l))         /* show to user in real */      or (lower.disp = (used.disp   ))         /* time if anxious      */      then call display.par;   end;end;                                           /* of sorting poly list */