/*	:SYNRSOU:06-MAIN:201#SUB1  $TITLE  SUBROUTINES FOR NOTE STARTING/PROCESSING	*/

/*
Modified:
1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE.
1998/06/24 - TY  - Updated expression containing (CLICK.TRACK.MODE & 511) to account for
						 the independence of CLICK.TRACK.MODE from CLICKON.
1998/06/18 - TY  - Modified JUSTIFY.TIME.AND.CHECK.EFFECTS so that only RTEs used by
						 TIM.USED.RTES or by THD.ACTIVE.MIDI.RTES will be recorded.
1998/06/12 - TY  - Minor changes to CHECK.EFFECTS.
1991/01/09 - PF  - Synclavier controllers recorded at all times
1990/08/27 - PF  - Support all MIDI controllers
1990/07/10 - PF  - Modified JUSTIFY.TIME.AND.CHECK.EFFECTS to work with Meter Map
1989/09/06 - MWH - Unsplit 06-MAIN now that the compiler can cope
1989/01/13 - PF  - Monster MIDI code
1988/10/12 - CJ  - CODE FOR JUSTIFY WITH LIVE CLICK TRACK
1988/09/18 - cj  - moved vitc scroll to store.e.time
1988/04/13 - PF  - MODIFIED CHECK.EFFECTS TO HANDLE MULTI RECORDING(IT NOW RECEIVES 5 ARGUMENTS)
1988/01/12 - TS  - SPLIT UP 06-MAIN MODULE INTO TWO PIECES
1986/08/24 - TS  - ADDED CODE IN CHECK.EFFECTS FOR THD.ACTIVE.MIDI.RTES
1986/08/18 - TS  - ADDED CODE TO HANDLE TIME.DELTA A LITTLE BETTER
1986/07/15 -CJ,TS- ADDED STORE DATA RECORD, GUITAR UPDATE RECORD, CHECK EFFECTS
1986/07/13 - CJ  - DIVIDED RECORD.NOTE UP INTO JUSTIFY.TIME.AND.CHECK.EFFECTS AND RECORD.ACTUAL.NOTE
1986/07/11 - CJ  - CHECKED OUT LIVE CLICK TRACK RECORDING
1986/07/11 -CJ,TS- LIMITED RECORDING TO AT OR AFTER ZERO.TIME
1986/07/02 - TSS - CLEANED UP RECORD.NOTE A LITTLE
1986/06/28 - CJ  - NEXT.CLICK, TRIGGER.CLICK FOR RECORDING ON CLICK TRACK
1986/06/12 - TSS - Lots of changes, to start to make these routines work
1986/06/11 - TSS - Modified RECORD.NOTE so it won't cause record to blow up
*/


/*	THIS FILE CONTAINS SUBROUTINES THAT ARE USED FOR	*/
/*	STARTING AND PLAYING NOTES :								*/
/*
	1.  STORE.DATA.RECORD					-- STORE MULTI-PURPOSE DATA RECORD
	1.5 PLACE.CUE								-- PLACE CUE TRIGGER NOTE RECORD ON CUE TRACK
	2.  COMPUTE.RTE.TIME						-- ???
	3.  STORE.GUITAR.UPDATE.RECORD		-- STORE REAL TIME GUITAR INFO
	4.  CHECK.EFFECTS							-- CHECK FOR REAL TIME EFFECTS UPDATE
	5.  JUSTIFY.TIME.AND.CHECK.EFFECTS	-- COMPUTES JUSTIFIED START TIME AND STORES UPDATED REAL TIME EFFECTS
	6.  RECORD.ACTUAL.NOTE					-- STORE BASIC NEW NOTE RECORD
*/


/*	$PAGE - STORE MULTI-PURPOSE DATA RECORDS IN SEQUENCER	*/

/*	STORE DATA RECORD STORES A 4-WORD UPDATE RECORD IN THE NOTELIST.	*/

/*	PROCEDURE TO STORE DATA RECORD IN SEQUENCER - USED FOR GUITAR FOOT PEDAL, ETC.	*/
STORE.DATA.RECORD:PROC(TIME.MSB,TIME.LSB,KINFO,DINFO,RINFO,BITS,VINFO) PUBLIC;
	DCL (TIME.MSB,TIME.LSB,KINFO,DINFO,RINFO,BITS,VINFO)	FIXED;
	DCL (TRK,THP)	FIXED EXTERNAL;

	#TRK=TRK;							/*	GET TRACK #	*/
	#PTR=THP;							/*	AND THD PTR	*/

	#W1=1;								/*	CREATE 4 WORD RECORD.  DELTA COMPUTED LATER	*/
	#W2=SHL(DINFO,6);
	#W3=RINFO\SHL(BITS,8);
	#W4=VEL.NOTE\SHL(VINFO,8);

	IF KINFO<12 THEN DO;
		#W2=#W2\KINFO;					/*	C0 - B0 - ( 0 - 11) STORE KEY #  0-11, SET LOWER BIT BELOW	*/
		#W4=#W4\LOWER.KEY;
	END;
	ELSE IF KINFO>72 THEN DO;
		#W2=#W2\(KINFO-24);			/*	C#6 - C7	*/
		#W4=#W4\RAISE.KEY;
	END;
	ELSE  #W2=#W2\(KINFO-12);		/*	C1 - C6 - (12 - 72) STORE KEY # 0-60, AS BEFORE	*/

	/*	NOW SET UP A BUNCH OF GLOBAL VARS		*/
	/*	WHICH ARE NEEDED BY INSERT.NOTE.RECORD	*/
	/*	TO CORRECTLY PUT A NEW NOTE INTO THE	*/
	/*	SEQUENCE.										*/

	WRITE(MAM)=#PTR;					/*	RESTORE PTR TO TRK HEAD	*/

	WRITE("313")=ADDR(#NMSB);
	WRITE(MAL)=THD.NMSB;

	IF INC.POLY<>0 THEN DO;
		RPC 6;
		WRITE("373")=READ(MDI);
	END;
	ELSE DO;
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.NMSB,THD.NLSB INTO #NMSB,#NLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.LMSB,THD.LLSB INTO #LMSB,#LLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MD );	/*	COPY THD.WRD ,THD.SEC  INTO #WRD,#SEC	*/
	END;

	WRITE(MAL)=THD.ANY.FOR;
	WRITE("373")=READ(MDI); WRITE("373")=READ(MD);	/*	COPY THD.ANY.FOR,THD.ANY.REV INTO #ANYF,#ANYR	*/

	IF #ANYF=0													/*	RECORDING AT END OF TRACK	*/
	THEN RETURN APPEND.NOTE.DURING.PLAY(TIME.MSB,TIME.LSB);	/*	SPEEDY ROUTINE FOR RECD AT END OF TRK	*/
	ELSE RETURN INSERT.NOTE.RECORD	  (TIME.MSB,TIME.LSB);	/*	SLOWER METHOD DURING OVERDUB	*/

END STORE.DATA.RECORD;


/*	$PAGE - PLACE CUE TRIGGER NOTE IN SEQUENCER	*/


PLACE.CUE:PROC(TRACK#,					/*	PASS TRACK # (ABS, 2-201)	*/
					TIME.MSB,TIME.LSB,	/*	TIME TO TRIGGER				*/
					KEYINFO,					/*	PASS "KEY" #					*/
					VOLINFO,PANINFO,		/*	PASS VOL (0-RTE.MAX) + PAN	*/
					OUTINFO,PRIINFO)		/*	OUTPUT,  PRIORITY				*/
					PUBLIC SWAPABLE;
	DCL (TRACK#)				FIXED;
	DCL (TIME.MSB,TIME.LSB)	FIXED;
	DCL (KEYINFO)				FIXED;
	DCL (VOLINFO,PANINFO)	FIXED;
	DCL (OUTINFO,PRIINFO)	FIXED;

	#TRK=TRACK#;						/*	GET TRACK #	*/

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=TRACK#;
	#PTR=READ(MD);						/*	AND THD PTR	*/

	#W1=1\SHL(KEYINFO&"740",6);	/*	CREATE 4 WORD RECORD.  DELTA COMPUTED LATER	*/
	#W2=(KEYINFO&"37")\SHL(PRIINFO&"37",6)\SHL(OUTINFO&"37",11);
	#W3=VOLINFO;
	#W4=VEL.NOTE\SHL(PANINFO,8);

	/*	NOW SET UP A BUNCH OF GLOBAL VARS		*/
	/*	WHICH ARE NEEDED BY INSERT.NOTE.RECORD	*/
	/*	TO CORRECTLY PUT A NEW NOTE INTO THE	*/
	/*	SEQUENCE.										*/

	WRITE(MAM)=#PTR;					/*	RESTORE PTR TO TRK HEAD	*/

	WRITE("313")=ADDR(#NMSB);
	WRITE(MAL)=THD.NMSB;

	IF INC.POLY<>0 THEN DO;
		RPC 6;
		WRITE("373")=READ(MDI);
	END;
	ELSE DO;
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.NMSB,THD.NLSB INTO #NMSB,#NLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.LMSB,THD.LLSB INTO #LMSB,#LLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MD );	/*	COPY THD.WRD ,THD.SEC  INTO #WRD,#SEC	*/
	END;

	WRITE(MAL)=THD.ANY.FOR;
	WRITE("373")=READ(MDI); WRITE("373")=READ(MD);	/*	COPY THD.ANY.FOR,THD.ANY.REV INTO #ANYF,#ANYR	*/

	RETURN INSERT.NOTE.RECORD (TIME.MSB,TIME.LSB);

END PLACE.CUE;


DCL (RTMSB, RTLSB	)	FIXED PUBLIC;	/*	TIME OF NOTE RECORD				*/
DCL (RTEMSB,RTELSB)	FIXED;			/*	RETURNED BY COMPUTE.RTE.TIME	*/
DCL (STILL.TIME	)	FIXED;

COMPUTE.RTE.TIME.FOR.STILL.FRAME: PROC SWAPABLE;
	DCL (THP)	FIXED EXTERNAL;

	WRITE(MAM)=THP;				/*	IF ANY NOTES STILL ACTIVE,		*/
	WRITE(MAL)=THD.NACT;			/*	THEN COMPUTE REAL TIME			*/
										/*	SINCE LAST NOTE WAS PLAYED.	*/
	IF ((READ(MDI))<>0)			/*	THD.NACT								*/
	OR ((READ(MDI))<>0)			/*	THD.NDEC								*/
	THEN DO;
		RTEMSB = RTMSB;			/*	GET TIME OF NOTE START			*/
		RTELSB = RTLSB;			/*	IN SEQUENCER TIME UNITS			*/

		if tempo.map.ptr <> 0	/*	get as real time if mapping	*/
		then call Map.Sequence.Time.To.Real.Time(loc(addr(rtemsb)), loc(addr(rtemsb)));

		LOAD KBD.MILLISECONDS - STILL.TIME;	/*	GET # OF MSECS SINCE THEN	*/
		MUL SAMP.SPEED; MWAIT; DIV 1000;		/*	CORRECT FOR SPEED SETTING	*/
		call ADD16(RES + PRESCAN, loc(addr(RTEMSB)));

		if tempo.map.ptr <> 0	/*	get corresponding sequence time	*/
		then call Map.Real.Time.To.Sequence.Time(loc(addr(rtemsb)), loc(addr(rtemsb)));

	END;

	/*	ELSE IF NO NOTE STILL PLAYING, THEN JUST RECORD THIS	*/
	/*	EFFECT AT THE CURRENT STILL FRAME:							*/

	ELSE DO;
		call TAKE.SYSTEM.SEQUENCE.TIME (loc(addr(RTEMSB)));
		if RTEMSB < 0
		then call STR32(0, zero.time, loc(addr(RTEMSB)));
	END;
END COMPUTE.RTE.TIME.FOR.STILL.FRAME;


COMPUTE.RTE.TIME: PROC;			/*	COMPUTE TIME FOR RTE RECORDING	*/

	/*	IF SMPTE STILL FRAMING, GET TIME SINCE KEY WAS PRESSED	*/
	/*	AND ADD TO TIME WHEN NOTE WAS RECORDED.						*/

	IF  (SMPTE.ONOFF<>0)			/*	SMPTE IS BEING USED			*/
	AND (SLOCKED	  =0)			/*	BUT NOT LOCKED					*/
	THEN DO;							/*	PLACE NOTE AT SMPTE TIME	*/

		/*	USE SWAP PROCEDURE SINCE REAL-TIME CONSTRAINTS DO	*/
		/*	NOT APPLY:														*/

		CALL COMPUTE.RTE.TIME.FOR.STILL.FRAME;
	END;

	/*	ELSE GET CURRENT SEQUENCER TIME, BUT CORRECT FOR EARLY	*/
	/*	OR LATE NOTES IF DOING JUSTIFIED RECORDING					*/

	ELSE DO;
		RTELSB=ADVANCED.SEQ.TIME.LSB+TIME.DELTA;
		RTEMSB=ADVANCED.SEQ.TIME.MSB;
		IF TIME.DELTA>=0 THEN DO;	/*	JUSTIFY HOLD SWITCH TO MOST RECENT NOTE	*/
			IF RTELSB ILT TIME.DELTA THEN RTEMSB=RTEMSB+1;
		END;
		ELSE DO;
			IF RTELSB IGT ADVANCED.SEQ.TIME.LSB THEN RTEMSB=RTEMSB-1;
		END;
	END;
END COMPUTE.RTE.TIME;

/*	$PAGE - STORE GUITAR UPDATE RECORDS	*/

STORE.GUITAR.UPDATE.RECORD:PROC(PDELT);	/*	PROCEDURE TO STORE AN UPDATE RECORD IN TRACK (FOR PITCH BEND) - PASS PITCH DELTA	*/
	DCL (I,J,PDELT)	FIXED;

	CALL COMPUTE.RTE.TIME;

	MORE.TO.RECORD:;		/*	RETURN HERE IF FOR SOME REASON PITCH DELTA WON'T FIT INTO ONE WORD	*/

	IF		  PDELT<-512 THEN I=-512;	/*	MAXIMUM PITCH SHIFT OF 1/2 OCTAVE	*/
	ELSE IF PDELT> 511 THEN I= 511;
	ELSE I=PDELT;			/*	CAN USE MAX AMOUNT OF PDELT		*/
	PDELT=PDELT-I;			/*	ACCOUNT FOR AMOUNT WE RECORDED	*/

	J=SHR(SBITS,8);		/*	VOLUME DATA FOR GUITAR			*/
	LOAD J; MUL GVOL;		/*	SCALE BY VOLUME KNOB				*/
	MWAIT; DIV 255;
	J=RES;

	IF STORE.DATA.RECORD(RTEMSB,RTELSB,KEYN,I,VELD&255,B.UPD\(SBITS&(B.GUI+7)),J)=0
	THEN DO;
		CALL KBD.ERROR(17);
		RETURN;
	END;

	IF PDELT<>0 THEN GOTO MORE.TO.RECORD;	/*	RECORD ANOTHER RECORD IF UNUSUAL PITCH DELTA	*/

END STORE.GUITAR.UPDATE.RECORD;

/*	$PAGE - CHECK FOR REAL TIME EFFECTS RECORDING	*/

CHECK.EFFECTS:PROC(MSB,LSB,CHANGES,UPD, RPTR) PUBLIC;	/*	RECORD CHANGING RTE'S IN NOTELIST - NOTE RTE.CHANGES(RPTR) IS CHANGED BY THIS ROUTINE	*/
	DCL (MSB,LSB)	FIXED;	/*	TIME AT WHICH RTES SHOULD BE RECORDED	*/
	DCL CHANGES		FIXED;	/*	BITS INDICATING WHICH RTES NEED TO BE CHECKED	*/
	DCL UPD			FIXED;	/*	PASSING A 1 HERE WILL CAUSE THE UPDATE BITS TO BE SET FOR THIS TRACK.  THIS WILL CAUSE OTHER NOTES PLAYING TO BE UPDATED	*/
	DCL RPTR			FIXED;	/*	SUBSCRIPT FOR CORRECT RTE.CHANGES WORD		*/
	DCL UPDATES		FIXED;
	DCL (I,J,K)		FIXED;
	DCL (TB,TBP,TRK,THP)	FIXED EXTERNAL;

	DO I=0 TO 5;								/*	TEST RTES FOR BEING UP TO DATE	*/

		IF ((CHANGES&R.LOOK(I))<>0) THEN DO;	/*	IF THIS RTE IS ACTIVE AND HAS POSSIBLY CHANGED - CHECK	*/

			IF RPTR=0								// was midi  mapped
			THEN DO;									/*	PROCESSING OUR KEYBOARD	*/
				WRITE(MAM)=TRK.HEAD;				/*	TRACK HEAD FOR KEYBOARD	*/
				WRITE(MAM)=READ(MD);
			END;
			ELSE WRITE(MAM)=THP;					/*	TRACK HEAD FOR MULTI.RECD TRK	*/

			WRITE(MAL)=THD.LIVE.RTES+I;		/*	POINT TO CURRENT VALUE	*/
			J=READ(MD);								/*	GET NEW VALUE TO BE RECORDED	*/

			WRITE(MAM)=THP;						/*	POINT TO TRK HEAD			*/
			WRITE(MAL)=THD.RTES+I;				/*	GET LAST RECORDED VALUE	*/

			IF READ(MD)<>J THEN DO;				/*	CHANGED						*/
				K=READ(MD);							/*	SAVE OLD VALUE				*/
				WRITE(MD)=J;						/*	STORE NEW VALUE			*/

				WRITE(MAL)=THD.MIDI;				/*	MIDI BEING SENT NOW OR LATER	*/
				IF READ(MD)<>0 THEN DO;
					WRITE(MAL)=THD.ACTIVE.MIDI.RTES;		/*	THIS RTE IS ENABLED	*/
					IF (READ(MD)&BITS(I))<>0 THEN DO;	/*	FOR MIDI OUTPUT		*/
						WRITE(MAL)=THD.MIDI.RTES+I;
						WRITE(MD )=K;
					END;
				END;

				IF STORE.DATA.RECORD (MSB,		LSB,			/*	TIME			*/
											 24,		SHL(I,2),	/*	KEY, DUR		*/
											 J&255,	B.UPD,		/*	NEW, B.UPD	*/
											 K			)=0			/*	OLD			*/
				THEN DO;
					CALL KBD.ERROR(17);
					RTE.CHANGES(RPTR)=0;
					RETURN;	/*	NO MEMORY FOR RECORDING	*/
				END;

				IF (UPD<>0) THEN DO;		/*	UPDATE ACTIVE NOTES IF WE SHOULD	*/

					WRITE(MAM)=TBP;		/*	GET ACTIVE PARMS FOR THIS EXPR	*/
					WRITE(MAL)=TIM.ACT.PARS+I;
					UPDATES=UPDATES\READ(MD);

				END;

			END;	/*	OF RECORDING RTE'S	*/
		END;	/*	OF THIS RTE IS ACTIVE	*/
	END;	/*	OF RTE LOOP	*/

	RTE.CHANGES(RPTR)=RTE.CHANGES(RPTR) AND (NOT(CHANGES));

	IF  (RPTR=0)							/*	PROCESSING KEYBOARD		*/
	AND (NEW.TOGGLES<>0) THEN DO;
		WRITE(MAM)=TRK.HEAD;				/*	TRACK HEAD FOR KEYBOARD	*/
		WRITE(MAM)=READ(MD);
		WRITE(MAL)=THD.CTBITS;
		J=READ(MD);							/*	GET KEYBOARD VALUE		*/

		WRITE(MAM)=THP;
		WRITE(MAL)=THD.CTBITS;

		IF READ(MD)<>J THEN DO;			/*	REPEAT/ARPEG FOOT SWITCH OR TOGGLE	*/
			K=READ(MD);						/*	SAVE CURRENT VALUE		*/
			WRITE(MD)=J;					/*	STORE NEW VALUE			*/

			IF STORE.DATA.RECORD (MSB,	LSB,						/*	TIME	*/
										 24,	SHL(SHL(K,4)\J,2)\1,
										 0,	B.UPD,
										 0		)=0
			THEN DO;
				CALL KBD.ERROR(17);
				NEW.TOGGLES=0;
				RETURN;	/*	NO MEMORY FOR RECORDING	*/
			END;

			IF (UPD<>0) THEN DO;			/*	UPDATE ACTIVE NOTES IF WE SHOULD	*/
				UPDATES=UPDATES\N.REPRATE;
			END;
		END;

		NEW.TOGGLES=0;						/*	TOGGLES ARE UP TO DATE	*/
	END;

	IF UPDATES<>0 THEN DO;
		WRITE(MAM)=THP;
		WRITE(MAL)=THD.UPD.PARS;		/*	POINT AT UPD.PARS WORD			*/
		WRITE(MDI)=READ(MD)\UPDATES;	/*	OR IN BITS FOR RTES AFFECTED	*/
		UPDATES=0;

		IF  (READ(MD)=0)					/*	CHECK THD.UPD.QUED				*/
		THEN DO;								/*	NOT IN LIST SO PUT IT THERE	*/
			WRITE(MDI)=1;					/*	THD.UPD.QUED TO NONZERO			*/
			WRITE(MD) =UPLIST0;			/*	STORE REL. FORWARD PTR			*/
			UPLIST0=THP-NAH.PTR;			/*	IN THD.UPD.LINK					*/
		END;

		NEW.INFO=1;							/*	SET FLAG TO DO UPDATES ASAP	*/
	END;
END CHECK.EFFECTS;						/*	OF MUST CHECK RTE'S	*/


/*	$SUBTITLE  Routine to Store Basic Note Record in Sequencer List	*/


/*		1. CHECK FOR NUMEROUS RECORDING ERRORS
		2. COMPUTE POSSIBLY JUSTIFIED STARTING TIME
		3. STORE UPDATED REAL TIME EFFECTS IN SEQUENCER	*/

/*	NOTE: upon entry, FENDM/FENDL is the REAL TIME where the note	*/
/*	is to be recorded in the sequencer.  This routine must			*/
/*	possibly JUSTIFY that time, store any RTE update records			*/
/*	in the sequence if needed, then convert FENDM to the				*/
/*	actual SEQUENCE TIME that the note is stored at.					*/

JUSTIFY.TIME.AND.CHECK.EFFECTS: PROC (CHK.RTES)	FIXED;
	DCL CHK.RTES	FIXED;	/*	1 TO PROCESS RTE CHANGES	*/
	DCL (I,J)		FIXED;
	DCL CLICK.RATE	FIXED;
	DCL (MSB,LSB)	FIXED;

	/*	The following global variables are set by SETUP.NOTE before this procedure is called.	*/
	DCL (TB,TBP,TRK,THP)	FIXED EXTERNAL;

	/*	CHECK FOR COMMON ERRORS:	*/

	IF (LOOP.RESTART	<>0)			/*	IF PLAY TIME HAS LOOPED AND POINTERS HAVE NOT	*/
	OR (PTRS.LOOPED	<>0)			/*	OR POINTERS HAVE LOOPED AND PLAY TIME HAS NOT	*/
	THEN DO;								/*	DO NOT RECORD NOTE IF PLAY.TIME MAY BE INVALID (RETURN WITH NO ERROR MESSAGE)	*/
		RETURN 1;
	END;

	IF  (SMPTE.ONOFF<>0)				/*	SMPTE IS BEING USED			*/
	AND (SLOCKED	  =0)				/*	BUT NOT LOCKED					*/
	THEN DO;								/*	PLACE NOTE AT SMPTE TIME	*/

		/*	Store the sequence time at which this note is triggered	*/
		/*	so that the end time can be computed when the key is		*/
		/*	released:																*/

		/*	Take current in-coming smpte time as the time to			*/
		/*	record the note at:													*/

		call TAKE.SYSTEM.REAL.TIME (loc(addr(FENDM)));
		if FENDM < 0
		then call STR32(0, zero.time, loc(addr(FENDM)));

		still.time = OTIML;			/*	save note start time for real time effects time computation	*/

	END;

	IF  (NAH.FREE<>0)							/*	IF NO FREE BLOCKS	*/
	AND ((NAH.PTR+NAH.LEN) IGE BNK.PTR)	/*	NAH HAS HIT BANK	*/
	AND (BNK.LEN=0)							/*	AND BANK IS EMPTY	*/
	THEN DO;
		CALL KBD.ERROR(17);					/*	PRESENT ERROR MESSAGE	*/
		RETURN 1;
	END;

	/*	$PAGE - COMPUTE JUSTIFIED NOTE STARTING TIME IF NECESSARY	*/


	/*	IF NOT DOING JUSTIFIED RECORDING, SET TIME.DELTA TO 0	*/
	/*	AND COMPUTE SEQUENCE TIME FOR THE NOTE:					*/

	IF RECD.JUST = 0 THEN DO;
		TIME.DELTA = 0;

		if tempo.map.ptr <> 0
		then call Map.Real.Time.To.Sequence.Time(loc(addr(fendm)),
															  loc(addr(fendm)));
		RTMSB=FENDM;
		RTLSB=FENDL;
	END;

	/*	ELSE FOR JUSTIFIED RECORDING, JUSTIFY THE REAL TIME, THEN	*/
	/*	MAP TO A SEQUENCE TIME.  BUT SAVE ACTUAL SEQUENCE TIME		*/
	/*	FOR DURATION COMPUTATION:												*/

	ELSE DO;									/*	JUSTIFY THE START TIME		*/
		RTMSB=FENDM;						/*	GET WORKING COPY OF NOTE	*/
		RTLSB=FENDL;						/*	START TIME						*/

		IF (CLICK.TRACK.MODE == 0) THEN DO;	/*	INTERNAL CLICK	*/

			/*	COMPUTE CURRENT CLICK RATE	*/
			CLICK.RATE = SAMPLED.REAL.TIME.OF.NEXT.CLICK.LSB-SAMPLED.REAL.TIME.OF.PRIOR.CLICK.LSB;

			LOAD RTLSB-SAMPLED.REAL.TIME.OF.PRIOR.CLICK.LSB;	/*	MSEC INTO CURRENT CLICK	*/
			MUL  SAMP.CRM;
			MWAIT;
			DIV  CLICK.RATE;							/*	ACCUM*CRM MODULO CLICK PERIOD	*/

			IF REM ILE SHR(CLICK.RATE,1)			/*	NOTE PLAYED LATE	*/
			THEN DO;										/*	BACK UP START TIME	*/
				LOAD REM; DIV SAMP.CRM;				/*	NUMBER OF UNITS TO BACK UP	*/
				TIME.DELTA=RES;						/*	SAVE ABS(TIME DELTA) TO USE FOR REAL TIME EFFECTS	*/
				IF RTLSB ILT TIME.DELTA THEN RTMSB=RTMSB-1;	/*	WILL WRAP ON BACK UP	*/
				RTLSB=RTLSB-TIME.DELTA;				/*	BACK UP THIS MANY TICKS	*/

				/*	MUST NOW MAP TIME.DELTA TO SEQUENCER DELTAS	*/
				MSB=0;									/*	COPY INTO 32 BIT VARS	*/
				LSB=TIME.DELTA;
				CALL MAP.REAL.DURATION.TO.SEQUENCE.DURATION(LOC(ADDR(RTMSB)),LOC(ADDR(MSB)),LOC(ADDR(MSB)));
				TIME.DELTA=LSB;						/*	EXTRACT NEW DELTA FROM LSB	*/
				TIME.DELTA=-TIME.DELTA;				/*	PUT SIGN ON TIME DELTA	*/
			END;
			ELSE DO;										/*	NOTE WAS PLAYED EARLY - ADVANCE TIME (GIVES CONVERSION PROGRAM BUG)	*/
				LOAD CLICK.RATE-REM; DIV SAMP.CRM;	/*	ADVANCE BY THIS MUCH WITH ROUND UP	*/
				TIME.DELTA=RES;						/*	ADVANCE TIME BY THIS MUCH	*/
				IF REM<>0								/*	IF REMAINDER - ADVANCE FURTHER TO MATCH EXT SYNC/CRM CODE	*/
				THEN TIME.DELTA=TIME.DELTA+1;		/*	ADVANCE ONE TICK FURTHER TO MATCH EXT CLOCK INPUT CODE	*/

				/*	MAP TIME.DELTA TO SEQUENCER DELTAS	*/
				MSB=0;
				LSB=TIME.DELTA;
				CALL MAP.REAL.DURATION.TO.SEQUENCE.DURATION(LOC(ADDR(RTMSB)),LOC(ADDR(MSB)),LOC(ADDR(MSB)));

				RTLSB=RTLSB+TIME.DELTA;				/*	MAKE STARTING TIME WAIT TILL BEAT FRACTION	*/
				IF RTLSB ILT TIME.DELTA THEN RTMSB=RTMSB+1;	/*	CARRY INTO TIME MSB	*/

				TIME.DELTA=LSB;						/*	NOW ASSIGN NEW SEQUENCER DELTA	*/
			END;
		END;												/*	OF JUSTIFY TO INTERNAL CLICK TRACK	*/

		ELSE DO;											/*	JUSTIFY TO EXTERNAL/LIVE CLICK TRACK	*/
			DISABLE;										/*	IN CASE EXT CLICK	*/
			I=RTLSB-LAST.CLICK;						/*	JUSTIFY TO CLICK	*/

			IF I<0 THEN DO;							/*	LAST CLICK ACTUALLY IN FUTURE (HAPPENS WHEN SCANNING LIVE TRACKS)	*/
				I=I+EST.RATE;							/*	ADVANCE ONE CLICK	*/
				IF I<0 THEN I=0;						/*	CAN NOT JUSTIFY IF MORE THAN 1 BEAT IN FUTURE	*/
			END;
			ELSE IF I>=EST.RATE THEN DO;			/*	LAST CLICK WAS MORE THAN 1 BEAT BACK	*/
				I=I-EST.RATE;							/*	BACKUP  ONE CLICK	*/
				IF I>=EST.RATE THEN I=0;			/*	CAN NOT JUSTIFY IF MORE THAN 1 BEAT IN FUTURE	*/
			END;

			LOAD I; MUL SAMP.CRM; MWAIT; DIV EST.RATE;	/*	ACCUM*CRM MODULO CLICK PERIOD	*/

			IF REM ILE SHR(EST.RATE,1)				/*	NOTE PLAYED LATE	*/
			THEN DO;										/*	BACK UP START TIME	*/
				LOAD REM; DIV SAMP.CRM;				/*	COMPUTE NUMBER OF UNITS TO BACK UP	*/
				TIME.DELTA=RES;						/*	SAVE ABS(TIME DELTA) TO USE FOR REAL TIME EFFECTS	*/
				IF RTLSB ILT TIME.DELTA THEN RTMSB=RTMSB-1;	/*	WILL WRAP ON BACK UP		*/
				RTLSB=RTLSB-TIME.DELTA;				/*	BACK UP THIS MANY TICKS	*/
				TIME.DELTA=-TIME.DELTA;				/*	PUT SIGN ON TIME DELTA	*/
			END;
			ELSE DO;										/*	NOTE WAS PLAYED EARLY - ADVANCE TIME (GIVES CONVERSION PROGRAM BUG)	*/

				LOAD EST.RATE-REM; DIV SAMP.CRM;	/*	ADVANCE BY THIS MUCH WITH ROUND UP	*/

				TIME.DELTA=RES;						/*	ADVANCE TIME BY THIS MUCH	*/
				IF REM<>0								/*	IF REMAINDER - ADVANCE FURTHER TO MATCH EXT SYNC/CRM CODE	*/
				THEN TIME.DELTA=TIME.DELTA+1;		/*	ADVANCE ONE TICK FURTHER TO MATCH EXT CLOCK INPUT CODE	*/
				RTLSB=RTLSB+TIME.DELTA;				/*	MAKE STARTING TIME WAIT TILL BEAT FRACTION	*/
				IF RTLSB ILT TIME.DELTA THEN RTMSB=RTMSB+1;	/*	CARRY INTO TIME MSB	*/
			END;
			ENABLE;
		END;												/*	OF JUSTIFY TO EXTERNAL/LIVE CLICK TRACK	*/

		/*	Map both times to sequence times now:	*/

		if tempo.map.ptr <> 0
		then do;
			call Map.Real.Time.To.Sequence.Time(loc(addr(fendm)),
															loc(addr(fendm)));
			call Map.Real.Time.To.Sequence.Time(loc(addr(RTMSB)),
															loc(addr(RTMSB)));
		end;

	END;													/*	OF COMPUTE JUSTIFIED NOTE TIME	*/

	IF  ((PNCH					<>0)			/*	WE ARE PUNCHING OUT EVERYTHING	*/
	OR   (RTE.OVERWRITE.BITS<>0))			/*	OR POSSIBLY OVERWRITING SOME RTES	*/
	AND ((TIME.DELTA>0))						/*	WE ARE TRYING TO DELAY RTES THAT GO WITH THIS NOTE	*/
	THEN DO;										/*	MIGHT NEED TO RESET TIME DELTA TO ZERO	*/

		WRITE(MAM)=THP;
		WRITE(MAL)=THD.ANY.FOR;

		IF (READ(MD)<>0)						/*	PUNCHING INTO MIDDLE OF TRK	*/
		THEN TIME.DELTA=0;					/*	CANNOT JUSTIFY RTES CORRECTLY	*/

	END;

	/*	$PAGE - CHECK OTHER ERRORS, AND RECORD REAL TIME EFFECTS	*/

	IF (RTMSB=0)&(RTLSB ILT ZERO.TIME)		/*	LIMIT TO RECORD AT ZERO.TIME	*/
	THEN RTLSB=ZERO.TIME;

	IF  (LOOP.TIME.IS.AT.0<>0)					/*	IF NO OTHER NOTES IN SEQUENCE	*/
	OR  ((RTMSB ILT LOOP.SEQ.TIME.MSB))		/*	OR NOTE IS BEFORE LOOP POINT	*/
	OR  ((RTMSB  =  LOOP.SEQ.TIME.MSB)
	AND  (RTLSB ILT LOOP.SEQ.TIME.LSB))
	THEN DO;
		CALL KBD.PHOTO(RTMSB,RTLSB);			/*	SET LOOP TIME TO THIS NOTE		*/
	END;


	/*	CHECK FOR REAL TIME EFFECTS TO BE RECORDED:	*/

	IF (RTE.CHANGES(CHORIG)<>0)
	OR ((TRACK=RECD.TRK) AND (NEW.TOGGLES<>0))
	THEN DO;

		/*	Step 1: Set bits for all RTEs that are used by the Timbre.	*/
		WRITE(MAM)=TBP; WRITE(MAL)=TIM.USED.RTES;
		J = READ(MD);		/*	RTES USED BY THIS TIMBRE - SAMPLED IN LOWER HALF, CONT IN UPPER HALF	*/
		J = (J\ROT(J,8));	/*	(SAMPLED OR CONTINUOUS) IN BOTH HALVES	*/

		/*	Step 2: Also set bits for all RTEs that are used for MIDI.	*/
		WRITE(MAM)=THP; WRITE(MAL)=THD.MIDI;
		IF READ(MD)<>0 THEN DO;	/*	TRACK IS ROUTED TO MIDI OUTPUT	*/
			WRITE(MAL) = THD.ACTIVE.MIDI.RTES;
			DO i = 0 TO 5;
				IF (READ(MD) & BITS(i))<>0 THEN J = J\R.LOOK(i);
			END;
		END;

		/*	Step 3: Now disable bits for all RTEs which haven't changed.	*/
		J = J & RTE.CHANGES(CHORIG);

		IF (J<>0) OR ((CHORIG=0) AND (NEW.TOGGLES<>0))
		THEN CALL CHECK.EFFECTS(RTMSB,RTLSB,J,CHK.RTES,CHORIG);	/*	RECORD THOSE RTE'S IN NOTELIST USING JUSTIFIED STARTING TIME	*/

		RTE.CHANGES(CHORIG)=0;	/*	ANY CHANGED BUT NOT RECORDED HERE ARE NOT NEEDED	*/

	END;	/*	OF RECORD RELEVANT REAL TIME EFFECTS CHANGES	*/

	RETURN 0;

END JUSTIFY.TIME.AND.CHECK.EFFECTS;


/*	$SUBTITLE - RECORD ACTUAL NOTE IN SEQUENCER	*/

/*	SET UP WORDS OF NOTE RECORD	*/
/*	AND TRY TO SAVE IT ON THE		*/
/*	TRACK.								*/

RECORD.ACTUAL.NOTE: PROC;
	DCL STORED.BITS		FIXED;	/*	WORKING COPY OF SBITS FIELD FROM NOTE BLOCK	*/
	DCL (I)					FIXED;
	DCL (TB,TBP,TRK,THP)	FIXED EXTERNAL;
	DCL TRANSPOSE.SEQUENCER.TRACKS PROC(FIXED,	FIXED,	FIXED,	FIXED) EXTERNAL;


	#TRK=TRK;							/*	GET TRACK #	*/
	#PTR=THP;							/*	AND THD PTR	*/

	I			  =KEYN;					/*	LOOK UP KEY NUMBER	FOR SPEED	*/
	STORED.BITS=SBITS;				/*	LOOK UP SPECIAL BITS FOR SPEED	*/

	#W1=MEMORIZE.RTE;					/*	#W1=0 MEANS 2-WORD RECORD, #W1=1 MEANS 4-WORD RECORD	*/

	IF ((VELD&255)<>RTE.MAX)		/*	VELOCITY DIFFERS FROM MAX	*/
	OR (I<12) OR (I>72)				/*	OR NEW KEY OUT OF RANGE		*/
	OR (STORED.BITS<>0)				/*	OR SWITCH BITS DIFFER OR VOL DATA PRESENT	*/
	THEN #W1=1;							/*	SET BIT FOR 4-WORD RECORD	*/

	IF		  I<12 THEN #W2=I;		/*	C0 - B0 - ( 0 - 11) STORE KEY #  0-11, SET LOWER BIT BELOW	*/
	ELSE IF I>72 THEN #W2=I-24;	/*	C#6- C7 - (73 - 84) STORE KEY # 49-60, SET RAISE BIT BELOW	*/
	ELSE					#W2=I-12;	/*	C1 - C6 - (12 - 72) STORE KEY # 0-60, AS BEFORE	*/

	IF #W1<>0 THEN DO;				/*	SEE IF VELOCITY/SWITCH STORE	*/
		#W3=(VELD&255)\SHL(STORED.BITS,8);	/*	SAVE RTE & BITS		*/
		#W4=STORED.BITS&"177400";	/*	EXTRACT VOLUME DATA (IF ANY)	*/
		IF INC.AXE AND (GDATA<>0)	/*	GUITAR NOTE: STORE PRODUCT OF	*/
		THEN DO;							/*	ENVELOPE & VOL KNOB IN SEQUENCER!	*/
			LOAD #W4; MUL GVOL; MWAIT; DIV 255; #W4=RES&"177400";
		END;
		IF		  I<12 THEN #W4=#W4\(LOWER.KEY\VEL.NOTE);	/*	SET BIT TO LOWER KEY ON PLAYBACK	*/
		ELSE IF I>72 THEN #W4=#W4\(RAISE.KEY\VEL.NOTE);	/*	SET BIT TO RAISE RECORDED KEY# BACK UP ON PLAYBACK	*/
		ELSE #W4=#W4\VEL.NOTE;		/*	SAVE VEL.NOTE HERE FOR REWIND	*/
	END;


	/*	$PAGE - INSERT THE NOTE ON THE TRACK AND SAVE PTR TO IT IN NOTE BLOCK	*/


	/*	NOW SET UP A BUNCH OF GLOBAL VARS		*/
	/*	WHICH ARE NEEDED BY INSERT.NOTE.RECORD	*/
	/*	TO CORRECTLY PUT A NEW NOTE INTO THE	*/
	/*	SEQUENCE.										*/

	WRITE(MAM)=#PTR;					/*	RESTORE PTR TO TRK HEAD	*/

	WRITE(MAL)=THD.SLPITCH;

	IF READ(MD)=0 THEN DO;			/*	WE HAVE NOT SET UP A FIRST PITCH YET (I.E THIS IS THE FIRST NOTE)	*/

		WRITE(MAM)=#PTR;				/*	STORE THIS KEY NUMBER AS TRANSPOSE BASE									*/
		WRITE(MAL)=THD.XPOSBASE;

		IF (READ(MD) == 0)			/*	MAKE SURE KEYBOARD BASE IS DEFINED	*/
			WRITE(MD )=I;

		WRITE(MAM)=TRK.HEAD;			/*	GET CURRENT LAST PITCH FROM KEYBOARD	*/
		WRITE(MAM)=READ(MD);
		WRITE(MAL)=THD.CLPITCH;
		I=READ(MD);

		WRITE(MAM)=#PTR;				/*	RESTORE PTR TO TRK HEAD	*/
		WRITE(MAL)=THD.SLPITCH;		WRITE(MD)=I;	/*	AND SET ITS STARTING PITCH	*/
		WRITE(MAL)=THD.CLPITCH;		WRITE(MD)=I;	/*	AND ITS CURRENT LAST PITCH	*/
		WRITE(MAL)=THD.LP.CLPITCH;	WRITE(MD)=I;	/*	AND ITS LOOP LAST PITCH		*/
	END;


	WRITE("313")=ADDR(#NMSB);
	WRITE(MAL)=THD.NMSB;

	IF INC.POLY<>0 THEN DO;
		RPC 6;
		WRITE("373")=READ(MDI);
	END;
	ELSE DO;
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.NMSB,THD.NLSB INTO #NMSB,#NLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MDI);	/*	COPY THD.LMSB,THD.LLSB INTO #LMSB,#LLSB	*/
		WRITE("373")=READ(MDI); WRITE("373")=READ(MD );	/*	COPY THD.WRD ,THD.SEC  INTO #WRD,#SEC		*/
	END;

	WRITE(MAL)=THD.ANY.FOR;
	WRITE("373")=READ(MDI); WRITE("373")=READ(MD);	/*	COPY THD.ANY.FOR,THD.ANY.REV INTO #ANYF,#ANYR	*/


	IF #ANYF=0									/*	RECORDING AT END OF TRACK	*/
	THEN I=APPEND.NOTE.DURING.PLAY(RTMSB,RTLSB);	/*	SPEEDY ROUTINE FOR RECD AT END OF TRK	*/
	ELSE I=INSERT.NOTE.RECORD		(RTMSB,RTLSB);	/*	SLOWER METHOD DURING OVERDUB	*/


	IF I<>0 THEN DO;				/*	PUT PTR TO NEW NOTE INTO NOTE BLOCK FOR STORE.E.TIME	*/
		WRITE(MAM)=THP;
		WRITE(MAL)=THD.CUE.TRACK;
		IF READ(MD)=0 THEN DO;		/*	IF NOT CUE TRACK, WILL NEED END TIME	*/
			RECW=#WRD; RECS=#SEC;	/*	STORE BACK PTR TO NOTE IN NOTE BLOCK	*/
		END;
	END;								/*	OF SUCCESSFULLY RECORDED NOTE	*/
	ELSE DO;
		CALL KBD.ERROR(17);		/*	PRESENT ERROR MESSAGE	*/
		RETURN 1;					/*	CANNOT RECORD NOTE	*/
	END;

	IF (CLICK.TRACK.MODE+NUM.KBD.TRACKS-4)=RECD.TRK	/*	THIS IS CLICK TRACK	*/
	THEN DO;							/*	CHECK FOR CORRECT LOOP BEAT NUMBER	*/
		DISABLE;
		NEXT.CLICK=FENDL;						/*	DO CLICK WHEN NOTE STARTS	*/
		IF NEXT.CLICK<PLAY.TIME.LSB		/*	BUT IF ALREADY LATE			*/
		THEN NEXT.CLICK=PLAY.TIME.LSB;	/*	THEN DO ASAP					*/
		TRIGGER.CLICK=1;						/*	NOTE SCANNED					*/
		LAST.CLICK=NEXT.CLICK;				/*	BUT LEAVE EST.RATE			*/
		EST.RATE=100;							/*	PLAY COMPLETE BEAT NOW		*/
		ENABLE;									/*	(MAY BE USEFUL ESTIMATE)	*/
		BEAT.NUMBER=BEAT.NUMBER+1;			/*	INCREMENT BEAT COUNTER		*/
	END;

	/*	TRANSPOSE OTHER TRACKS IF RECORDING A TRANSPOSE TRACK	*/

	WRITE(MAM)=#PTR;					/*	RESTORE PTR TO TRK HEAD	*/
	WRITE(MAL)=THD.IGNORE;

	IF ((READ(MD) & THD.IGNORE.XPOS) != 0)
		TRANSPOSE.SEQUENCER.TRACKS(#TRK, KEYN, SAMPLED.ACTUAL.SEQUENCE.TIME.MSB, SAMPLED.ACTUAL.SEQUENCE.TIME.LSB);

	RETURN 0;							/*	SUCCESSFUL RECORDING	*/

END RECORD.ACTUAL.NOTE;
