/* :SYNRSOU:06-MAIN:306-STR6  $TITLE  CODE FOR NOTE STARTING, SECTION 1 */

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
1998/06/14 - TY  - Minor streamlining at "CLEAR OUT NUM1-2, NUME, NUMM, NUMP0-3".
1991/09/05 - cj  - Fixed polyphony=1 resynth bug for Lee Kopp
1991/04/04 - cj  - Improved monophonic Slap Bass timbres for Lee Kopp
1990/11/05 - CJ  - Improved accuracy of "play to"
1990/04/05 - TSS - FIX STUCK MIDI NOTE/EXTRA NOTE OFF BUGS
1990/03/21 - PF  - Compressed CLAV.PTR to 43 sectors
1990/03/09 - PF  - Increase MAX.INPUTS to 128
1990/01/25 - MWH - Fix "300 msec delay starting cues" bug (from EditView)
1989/08/24 - PF  - Added PATH argument to MIDI.NOTE.OFF and MIDI.NOTE.ON
1989/04/27 - cj  - allow trigger of events from keyboard
1988/11/04 - TS  - DON'T STEAL HELD GUITAR NOTES IF SAME PITCH RETRIGGERED
1988/11/03 - TS  - ADDED AXE.HOLD.MODE DCL
1988/04/13 - PF  - ADDED CODE FOR MULTI TRACK SEQUENCING
1988/04/13 - PF  - ADDED CODE FOR MULTI CHANNEL SUSTAIN PEDAL
1988/03/14 - CJ  - PASSED TRACK # TO DTD DURING KEYBOARD CUE TRIGGER
1987/07/13 - MWH - USE RPC TO SPEED INITIALIZATION; GET BIN WITH ROT 2 & "3", NOT SHR 14
1987/07/10 - MWH - EXPAND NUMP FOR 4 BINS OF POLY
1987/07/02 - MWH - KBD LOOKUP TABLE LITERALS; RESTRUCTURED FOR 32 BIT POLY
1986/11/18 - CJ  - ADDED TIM.TVOL.LOOK
1986/07/31 - CJ  - DISABLED KEYBOARD RECORDING WHILE LOD RECORDING
1986/07/28 - CJ  - CHANGES TO ALLOCATE STEREO CHANNELS
1986/07/24-KJC,CJ- KBDTAB CHANGES
1986/07/15 - CJ  - MODS TO CANCEL.NOTE/MONO POLYPHONY
1986/07/13 - CJ  - ADDED NORIG. FIXED RECORD OF ABORTED NOTES BUG
1986/06/18 - CJ  - USE OF SAMPLED.PLAY.TIME.ACU
1986/06/12 - CJ  - changed tied note for larger note blocks
1986/05/15 - "official" creation of release-M modules
*/

/* SETUP.NOTE IS CALLED TO COMPUTE A VARIETY OF ITEMS FOR STARTING
	A NOTE.  PARTIAL BLOCKS ARE ALLOCATED AND SET UP SO THAT THE NOTE
	CAN START ON TIME.

	TIED NOTES ARE ALSO HANDLED BY SETUP.NOTE.
	UPDATE RECORDS MUST BE HANDLED ELSEWHERE, THOUGH. */

/* CODE IN THIS FILE:

		1. PROCESS TIED NOTES
		2. CHECK FOR POLYPHONY, STOLEN CHANNELS
		3. ALLOCATE PARTIAL BLOCKS AND COUNT CHANNELS REQUIRED
*/

DCL (TRACK.DATA)  FIXED;	/* USED FOR TRACKING FILTERS */
DCL AXE.HOLD.MODE FIXED EXTERNAL;

SETUP.NOTE:PROC;	/* MAIN PROCEDURE TO SET UP NOTE */
	DCL (ARPEG.VAL,G.VAL)	FIXED;
	DCL (CHORUS.ON)			FIXED;
	DCL (OUR.BITS)				FIXED;
	DCL (PITCH)					FIXED;
	DCL (OUR.VOL)				FIXED;
	DCL (PWP)					FIXED;
	DCL (ST.INFO)				FIXED;
	DCL (MY.AXE)				FIXED;
	DCL (RAN.PTR)				FIXED;
	DCL (RANDOM.LIST)			DATA (32,-64,-32,64,16,-16,48,-48,-8,24,-40,56,8,-24,40,-56);
	DCL (NUM1,NUM2,
		  NUME,NUMM,NUMP0,
		  NUMP1,NUMP2,NUMP3)	FIXED;	/* MUST BE IN ORDER - SPEEDILY CHECKED SEVERAL PLACES */
	DCL (NEWCH,SPLICER)		FIXED;
	DCL (SYNTYP,OPT,TOPT)	FIXED;
	DCL (OUR.LAST.PITCH)		FIXED;
	DCL (SET.HZ)				FIXED;
	DCL (TIED.NPTR)			FIXED;
	DCL (MAXNUM)				FIXED;
   DCL (XPOSDIST)				FIXED;
   DCL (MIDIDIST)				FIXED;
	DCL (TRACKVOL)				FIXED;
	DCL (BIN)					FIXED;	/* WHICH POLY BIN WE'RE TALKING TO */
	DCL (PTR)					POINTER;	/* POINTER TO NUMBER OF POLY VOICES FOR THE BIN */
	DCL (CUETIME) (1)			FIXED;
	DCL (ANY.HZ.SET)			FIXED;

	/* TODD: THE FREE.R0 MACRO IS TRICKY TO UNDERSTAND; CALL ME AND I'LL EXPLAIN IT (CJ) */
	DCL (FREE.R0)				LIT 'IF 0 THEN WRITE("300")=READ("300")';

	BREL:PROC;								/* PROCEDURE TO FREE NOTE BLOCK - ONLY USED IF BOMB OUT (FOR SPEED) */
		CORE(NPTR)=NFREEP;				/* LINK US ON TO FRONT OF FREE QUE */
		NFREEP    =NPTR  ;
	END BREL;

	GETPBLK:PROC;							/* SUB TO CALL IF NO PARTIAL BLOCKS */
		DCL SPP FIXED;						/* SAVE PPTR - CLOBBERED BY STEAL.CHANS. */
		SPP=PPTR;
		WRITE(MAM)=THP;
		WRITE(MAL)=THD.NDEC;
		IF READ(MD)<>0 THEN DO;			/* SEARCH NOTE LIST FOR SAME KEY IF SOME DECAYERS */
			CALL CHECKQUE;					/* KILL EARLIER NOTE.   HOPEFULLY WILL YIELD PARTIAL BLOCKS...	*/
		END;									/* ...BUT MAY NOT IF MANY GHOSTS											*/
		IF PFREE=0 THEN DO;				/* OUT OF PARTIAL BLOCKS FOR GOOD */
			CALL ABORT.NOTE;				/* JUST QUIT */
			PPTR=SPP;
			RETURN 0;						/* ERROR RECOVERY IS DIFFICULT BECAUSE OF GHOST BLOCKS */
		END;
		PPTR=SPP;
		RETURN 1;
	END GETPBLK;

	CANCEL.NOTE:PROC;						/* FORCE FINAL DECAY ON TIED/RETIGGERED NOTE */
		DCL I FIXED;

		IF NORIG<>0 THEN DO;				/* SEQUENCE NOTE */

			NORIG = NORIG \ 4;			/* SET BIT TO INDICATE NOTE HAS BEEN */
												/* CANCELLED SO WE DON'T FIND IT     */
												/* AGAIN (FIXES RESYNTH BUG)         */
			IF NSTAT=0 THEN DO;			/* STILL ACTIVE - MARK CHANNELS AS STELABLE */
				IF STEALOK<>(-2) THEN DO;
					IF (STEALOK&256)=0 THEN CALL NEW.DECAYER;	/* INDICATE A NEW DECAYING NOTE UNLESS WE HAVE ALREADY DONE SO */
					STEALOK=256+TRK;									/* ALLOW CHANNELS TO BE STOLEN IF NEEDED */
				END;
			END;

			IF (NOTETIME.LSB<FENDL)		/* CUT OFF TIED NOTE WHEN NEW NOTE STARTS */
			THEN DO;

				FENDM=NOTETIME.MSB;		/* END THIS PRIOR SEQUENCER NOTE WHEN */
				FENDL=NOTETIME.LSB;		/* THE NEW NOTE BEGINS                */

				IF NSTAT=0 THEN DO;		/* NOTE IS STILL ACTIVE - MUST MAKE SURE MIDI NOTE OFF GOES OUT */

					IF (TOPT&(SLAP.BASS\BIT.REPEAT\BIT.ARPEG))<>0
					THEN DO;							/* IF SLAP BASS TIMBRE, THEN  */
						FENDL=FENDL+PRESCAN;		/* POSTPONE FINAL DECAY SINCE */
						IF FENDL ILT PRESCAN		/* IT IS STARTED RIGHT AWAY   */
						THEN FENDM=FENDM+1;

						WRITE(MAM)=THP;			/* BEFORE MIDI NOTE ON */
						WRITE(MAL)=THD.MIDI;
						IF READ(MD)<>0 THEN DO;
							PPTR=PTLST;
							DISABLE;
							DO WHILE PPTR<>0;
								I=MIDIRT;						/* SAMPLE THE ROUTING */
								MIDIRT=0;						/* AND CLEAR IT */
								IF (I<>0) AND (PSTAT<>DELAY.STATE)
								THEN DO;							/* THIS IS A MIDI PARTIAL */
									CALL MIDI.NOTE.OFF(I, MIDIPATH, MIDIINFO);	/* TURN NOTE OFF */
									/******/;					/* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */
									DISABLE;
								END;
								PPTR=PFPTR;
							END;
							ENABLE;
						END;
					END;
					/* ELSE NON-SLAP BASS:  TRUST THE FINAL DECAY TO BE QUED BEFORE THE NOTE ON HAPPENS. */
					/* PROVIDES BETTER MIDI ARTICULATION THIS WAY */
				END;

				ELSE IF NSTAT=1 THEN DO;	/* NOTE IS ALREADY QUED FOR FINAL DECAY */
					PPTR=PTLST;
					DISABLE;
					DO WHILE PPTR<>0;
						FTIMER=FENDL;
						PPTR=PFPTR;
					END;
					ENABLE;
				END;

			END;
		END;
		ELSE DO;								/* KEYBOARD NOTE */
			IF NSTAT=0 THEN DO;
				IF RECS<>0 THEN DO;		/* IF RECORDING, SAVE LENGTH OF OLD NOTE - HAPPENS WHEN RECORDING NOTES WITH PHRASE PEDAL FROM CLAVIER */
					CALL STORE.E.TIME;	/* NOTE */
				END;
				IF STEALOK<>(-2) THEN DO;
					IF (STEALOK&256)=0 THEN CALL NEW.DECAYER;	/* INDICATE A NEW DECAYING NOTE UNLESS WE HAVE ALREADY DONE SO */
					STEALOK=256+TRK;									/* ALLOW CHANNELS TO BE STOLEN IF NEEDED */
				END;
				WRITE(MAM)=THP;		/* BEFORE MIDI NOTE ON */
				WRITE(MAL)=THD.MIDI;
				IF READ(MD)<>0 THEN DO;
					PPTR=PTLST;
					DISABLE;
					DO WHILE PPTR<>0;
						I=MIDIRT;						/* SAMPLE THE ROUTING */
						MIDIRT=0;						/* AND CLEAR IT */
						IF (I<>0) & (PSTAT<>DELAY.STATE)
						THEN DO;							/* THIS IS A MIDI PARTIAL */
							CALL MIDI.NOTE.OFF(I, MIDIPATH, MIDIINFO);	/* TURN NOTE OFF */
							/******/;					/* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */
							DISABLE;
						END;
						PPTR=PFPTR;
					END;
					ENABLE;
				END;
				NSTAT=3;		/* GENERATE IMMEDIATE FINAL DECAY FOR KEYBOARD, GUITAR NOTES */
			END;
		END;

	END CANCEL.NOTE;

	/* $SUBTITLE  PROCESS NEW NOTE BOCK - LOOK UP GLOBAL VARIABLES */


	/* SET UP GLOBAL VARIABLES FOR SPEEDY ACCESS */

	TB  = TIMBRE;
	TRK = TRACK;

	WRITE(MAM)=TIM.HEAD;
	WRITE(MAL)=TB;
	TBP=READ(MD);

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=TRK;
	THP=READ(MD);

	WRITE(MAM)=TBP;
	WRITE(MAL)=TIM.TOPTIONS;
	TOPT=READ(MD);					/* LOOK UP TIMBRE FOR NEW NOTE */

	OUR.BITS=SBITS;				/* LOOK UP BITS WORD FOR SPEED */

	/* NOTE: KEEP MAM POINTING TO TBP UNLESS INDICATED */

	/* 1. INITIALIZE NOTE BLOCK INITIALIZE HERE ONLY FOR ITEMS USED FOR TIED NOTES.
		2. CHECK FOR TIED NOTE.
	*/

	RECW=0; RECS=0;				/* INITIALIZE BLOCK TO NOT RECORDED */
	NOTETIME.LSB=OTIML;			/* SAVE POSSIBLE TIME OF NEW SEQUENCER NOTE FOR CHANNEL STEALING PREFERENCE */
	NOTETIME.MSB=OTIMM;

	/* COMPUTE INVERTED VELOCITY */
	/* IN CASE USED FOR RTES     */

	I=VELD;							/* LOOK UP VELOCITY, 0-RTE.MAX */
	IF I<32 THEN I=32;			/* COMPUTE INVERTED VELOCITY   */
	LOAD (RTE.MAX*32);			/* RTE.MAX*16   */
	DIV I;							/* RTE.MAX*32/I */
	VELD=VELD\SHL(RES,8);		/* STORE IN UPPER HALF */

	RPRED=0;							/* INITIALIZE PRESSURE TO 0 */
	NEWFP=SHL(RTE.MAX,8);		/* AND FILTERED VERSION - INIT TO 0 PRESSURE, BUT STORE IN VARIABLE IN CASE OF TIED NOTE OR MONO VOICE STEALING */

	/* COMPUTE KCV ONLY IF USED */
	/* (MAM CLOBBERED HERE)     */

	WRITE(MAL)=TIM.USED.RTES;	/* SEE WHAT RTES USED (FOR SPEED) */

	IF (READ(MD)&(32\SHL(32,8)))<>0 THEN DO;		/* Note: I think this is computing the keyboard envelope	*/
		WRITE(MAL)=TIM.TINFO.POINTER;					/* RTE stuff; I'll have to check; CJ 12/12/96				*/
		J=READ(MD);					/* GET TINFO BLOCK POINTER       */
		IF J=0 THEN DO;			/* NO TINFO - USE DEFAULT LIMITS */
			I=24; J=48+24;			/* DEFAULT                       */
		END;
		ELSE DO;
			I=J+TI.KCVL;
			WRITE(MAM)=PAR.PTR+SHR(I,8); WRITE(MAL)=I;
			I=READ(MDI);
			J=READ(MD );
		END;
		J=J-I;						/* GET NUMBER OF KEYS */
		IF J=0 THEN J=1;			/* AT LEAST ONE       */
		I=KEYN-I;					/* GET DISTANCE FROM KEYN TO LEFT */
		IF I< 0 THEN I=0;			/* CHECK BOUNDS */
		IF I> J THEN I=J;
		LOAD RTE.MAX; MUL I; K=RES; DIV J;	/* COMPUTE RTE.MAX*KEYN/(NUM.KEYS-1) */
		KCVD=SHL(RTE.MAX-RES,8)\RES;			/* STORE INVERTED & NORMAL KCV */
	END;

	/* $PAGE - HANDLE TIED NOTES */


	/* (MAM IS UNDEFINED HERE) */

	IF (OUR.BITS&B.TIE)<>0 THEN DO;		/* CHECK FOR TIED NOTE */

		TIED.NOTE:;

		SAVED.NPTR=NPTR;						/* SAVE FOR LATER REFERENCE. ENTER FROM ABOVE OF POLYPHONE EXCEEDED */
		NPTR=NOTELIST;							/* SEARCH THRU LIST FOR NOTE TO TIE TO */
		IF (OUR.BITS&B.GUI)=0 THEN DO;	/* NOT ORIGINALLY FROM GUITAR - ANY ACTIVE OR DECAYING NOTE WILL DO */
			TIED.NPTR=0;
			DO WHILE NPTR<>0;					/* LOOK THROUGH NOTE LIST FOR OLDEST MATCHING NOTE ON OUR TRK */
				IF  (TRACK=TRK)				/* LOOK FOR NOTE ON SAME TRACK */
				AND (NSTAT<>2)					/* WITH CHANNELS               */
				AND ((NORIG & 4) = 0)		/* THAT HAS NOT BEEN CANCELED  */
				THEN TIED.NPTR=NPTR;			/* SAVE PTR TO THIS NOTE */
				NPTR=NFPTR;						/* STEP TO NEXT NOTE     */
			END;
			NPTR=TIED.NPTR;					/* TIE TO THIS NOTE */
		END;
		ELSE DO;									/* MEANS TIED NOTE FROM GUITAR (SET WHEN DCONT=1) - LOOK FOR STRING MATCH */
			PITCH=OUR.BITS&(B.GUI+7);		/* EXTRACT B.GUI & STRING NUMBER FOR MATCH */
			DO WHILE (NPTR<>0)&((TRACK<>TRK)\(NSTAT>1)\((SBITS&(B.GUI+7))<>PITCH));	/* FIND NOTE FROM SAME STRING */
				NPTR=NFPTR;
			END;
		END;

		IF NPTR<>0 THEN DO;						/* NOTE TO TIE TO WAS FOUND - CHECK FOR ARTICULATION OR NOT */
			IF ((OUR.BITS&B.ART)<>0)			/* IF ARTICULATION DESIRED */
			OR (NSTAT<>0)							/* OR FDECAY HAD BEGIN     */
			THEN DO;									/* RE ARTICULATE IF DECAY HAD BEGUN, OR IF REARTICULATION DESIRED */
				IF (INC.AXE=0)
				OR (GDATA  =0)
				THEN DO;
					IF (TOPT&SLAP.BASS)<>0		/* FOR SLAP BASS, USE CANCEL.NOTE */
					THEN CALL CANCEL.NOTE;		/* ELSE CAN STEAL CHANS DIRECTLY  */
					ELSE CALL STEAL.CHANS;
				END;
				ELSE DO;								/* GUITAR NOTES */
					IF (TOPT&(SLAP.BASS\BIT.REPEAT\BIT.ARPEG))<>0
					THEN DO;							/* SLAP BASS OR REP/ARP - CHECK FURTHER */
						CALL CANCEL.NOTE;
					END;
					ELSE CALL STEAL.CHANS;		/* DECREMENT DECAYERS (IF REQD), FREE UP CHANNELS, BLOCKS, STORE TIME, TERMINATE NOTE.
															LEAVE BLOCK ON NOTELIST QUE WITH NSTAT=2 FOR LATER RELEASE */
				END;
				NPTR=SAVED.NPTR;					/* GET POINTER TO THE NEW NOTE BLOCK */
				GOTO ALWAYS.START.NEW.NOTE;	/* START THE NEW NOTE WITH THE OLD CHANNELS. RECORD NOTE WILL BE CALLED LATER */
			END;										/* NOTE - ALL GUITAR TIED NOTES ARE ALWAYS RE-ARTICULATED */

			/* $PAGE */


			// Tied Note Processing
			IF NORIG=0 THEN DO;						/* KEYBOARD/GUITAR - SPECIAL CHECKS */
				TIED.NPTR=NPTR; NPTR=SAVED.NPTR;	/* GET NOTE BLOCK FRESH FROM SEQUENCER - NOW PROCESS TIED BUT NOT ARTICULATED NOTES */

				WRITE(MAM)=TBUT.PTR;
				WRITE(MAL)=TRACK;						/* FOR THIS TRACK */

				IF  (RECD<>0)										/* IF RECORDING */
				AND (RECD.TRK<>0)									/* SYNCLAVIER RECORDING */
				AND ((TRACK=RECD.TRK)							/* THIS IS RECORD TRACK */
				OR  ((READ(MD)&B.READY.TRK)<>0))				/* THIS TRACK IS ARMED FOR REC */
				THEN DO;												/* RECORD NOTE  - NOTE: THESE ARE KEYBOARD NOTES ONLY */

					/* Note set FENDM to real time here.  Justify.Time	*/
					/* performs justification and converts fendm			*/
					/* to a sequencer time.										*/

					FENDM=SAMPLED.ACTUAL.PLAY.TIME.MSB;		/* USE IMMEDIATE TIME */
					FENDL=SAMPLED.ACTUAL.PLAY.TIME.LSB;		/* FOR TIED NOTES     */

					IF JUSTIFY.TIME.AND.CHECK.EFFECTS(1)<>0	/* JUSTIFY START TIME */
					THEN DO;												/* AND STORE EFFECTS  */
						CALL BREL; RETURN;							/* TOSS NOTE IF BOMB  */
					END;
					IF RECORD.ACTUAL.NOTE<>0 THEN DO;			/* NOW RECORD NOTE    */	// Record a tied not start event in the sequencer
						CALL BREL; RETURN;							/* TOSS IF BOMBOUT    */
					END;
				END;
				IF ((INC.AXE=0)\(GDATA=0))			/* IF NON GUITAR, SET CLAV.STATE HERE */
				THEN DO;									/* SUCCESSFUL START OF KEYBOARD NOTE - SET ACTIVE BIT IN CLAV.STAT FOR END OF NOTE CHECK */
					WRITE(MAM)=MIDI.SWITCHDATA+SHR(SHL(CHORIG,3)+R.SUST.SW,8);
					WRITE(MAL)=SHL(CHORIG,3)+R.SUST.SW;
					L         =READ(MD);
					LOAD CHORIG; ULOAD KEYN; MUL NUM.KEYS;
					WRITE(MAM)=CLAV.PTR+SHR(RES,8);
					WRITE(MAL)=RES;
					IF (READ(MD)&DOWN)<>0
					THEN DO;								/* CHECK FOR KEY ALREADY BEING RELEASED */
						IF  ((CHORIG=0)
						AND (SUSTSWITCH<>0))
						OR  (L<>0)
						THEN WRITE(MD)=READ(MD)\(SUSTD\ACTIVE);
						ELSE WRITE(MD)=READ(MD)\(ACTIVE);		/* INDICATE ACTIVE IF SUCCESSFUL NOTE START */
					END;
				END;
				NPTR=TIED.NPTR;						/* GET POINTER TO NOTE BLOCK OF NOTE WE TIED TO */
			END;

			IF RECS<>0 THEN DO;		/* IF RECORDING, SAVE LENGTH OF OLD NOTE - HAPPENS WHEN RECORDING NOTES WITH PHRASE PEDAL FROM CLAVIER */
				IF FENDL ILT 1000 THEN FENDM=FENDM-1;	/* BACK UP FEND SO NOTE */
				FENDL=FENDL-1000;								/* WILL OVERLAP NEW     */
				CALL STORE.E.TIME;							/* NOTE                 */
			END;

			FREE.R0;
			WRITE("302")=NPTR+KEYPT;			/* POINTER TO NOTE WE TIED TO */
			FREE.R0;
			WRITE("303")=SAVED.NPTR+KEYPT;	/* POINTER TO NEW NOTE        */

			WRITE("362")=READ("363"); WRITE("362")=READ("363");	/* KEYN,  SBITS */
			WRITE("362")=READ("363");										/* VELD         */
			WRITE("212")=1; WRITE("213")=1;								/* SKIP FPRED   */
			WRITE("362")=READ("363");										/* KCVD         */
			WRITE("362")=READ("363"); WRITE("362")=READ("363");	/* RECW,  RECS  */
			WRITE("362")=READ("363"); WRITE("362")=READ("363");	/* FENDM, FENDL */
			WRITE("362")=READ("363"); WRITE("362")=READ("363");	/* OTIMM, OTIML */
			WRITE("362")=READ("363");										/* RPRED        */

			CORE(SAVED.NPTR)=NFREEP;			/* FREE UP BLOCK SINCE WE */
			NFREEP=SAVED.NPTR;					/* HAVE ALL THE INFO      */

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.VP;					/* LOOK UP UPDATED PARAMS */
			NUPDT=NUPDT\(READ(MD)&(NOT(N.VE.PKSUS\N.TVOL)));	/* SET BITS TO UPDATE FUNCTIONS FOR NEW PRESSURE, VELOCITY, KCV -
																					BUT VEPKSUS NOT NEEDED DUE TO IMMINENT CALL TO COMPUTE.VOL */
			WRITE(MAL)=TIM.KP;
			NUPDT=NUPDT\(READ(MD)&(NOT(N.VE.PKSUS\N.TVOL)));

			WRITE(MAM)=THP;
			WRITE(MAL)=THD.CXPOS;
			XPOSDIST=READ(MD);

         WRITE(MAL)=THD.MIDX;
         MIDIDIST=XPOSDIST+READ(MD);

			PITCH=COMPUTE.KBD.PITCH(KEYN+XPOSDIST);	/* COMPUTE PITCH FOR THIS KEY - WE KNOW IT IS NOT A LIVE GUITAR NOTE */

			IF (OUR.BITS&(B.GUI\B.GLI))=B.GLI
			THEN G.VAL=1;
			ELSE G.VAL=0;

			PPTR=PTLST;									/* GET POINTER TO PARTIAL LIST */

			DO WHILE PPTR<>0;							/* PROCESS EACH PARTIAL FOR NEW PITCH - EITHER TIED NOTE, OR PITCH UPDATE */

				IF MCHN<>0 THEN DO;					/* SKIP OVER MIDI-ONLY BLOCKS */
					PTL=PARTL;							/* LOOK UP PARTIAL NUMBER FOR SPEEDY REFERENCE */
					WRITE(MAM)=TBP;
					WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
					PTPTR=READ(MD);
					WRITE(MAL)=TIM.OPTIONS+PTL;
					IF (READ(MD)&MIN.PTUNE)=0			/* IF NOT AN A-440 NOTE */
					THEN DO;									/* THEN UPDATE HZ       */
						DESTF=PITCH;						/* SAVE DESIRED PITCH DIRECTLY FOR TIED NOTES */
						IF ((READ(MD)&ANY.GLIDE)<>0)	/* IF ANY GLIDE         */
						OR ((G.VAL)             <>0)
						THEN CALL COMPUTE.GLIDE;		/* GLIDE ACTIVATED - PERFORM IT */
						ELSE CURRF=DESTF;					/* GO IMMED TO NEW PITCH */
					END;
					CALL COMPUTE.VOL;			/* COMPUTE NEW VOLUME BASED ON SBITS, RTE */
				END;

				DISABLE;
				IF MIDIRT<>0 THEN DO;		/* DO A SLURRED NOTE FOR MIDI TOO */
					I=MIDIINFO;
					MIDIINFO=MIDI.MAP.KEY(KEYN+MIDIDIST)\SHL(VELD,8);	/* SAVE INFO FOR NEW SLURRED NOTE */

					IF (PSTAT<>DELAY.STATE)	/* IF NOTE HAS STARTED               */
					THEN DO;						/* THEN NOTE ON WENT OUT - RETRIGGER */
						CALL MIDI.NOTE.ON(MIDIRT,MIDIPATH,MIDIINFO,VELD&255);	/* TURN NEW NOTE ON  */
						/******/;				/* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.ON */
						DISABLE;
						CALL MIDI.NOTE.OFF(MIDIRT, MIDIPATH, I);							/* TURN OLD NOTE OFF */
						/******/;				/* NOTE - INTERRUPTS ARE TURNED ON BY MIDI.NOTE.OFF */
					END;							/* ELSE MEANS WE TIED TO NEW PITCH BEFORE OLD PITCH WENT OUT */
				END;
				ENABLE;

				PPTR=PFPTR;	/* GET NEXT FORWARD PARTIAL */
			END;
			NUPDT=NUPDT\N.NFREQ;
			NEW.INFO=1;				/* SET FLAG TO UPDATE FREQUENCIES ON TIED NOTE */
			RETURN;					/* DONE WITH NEW TIED NOTE PROCESSING */
		END;	/* OF CASE FOR TIED NOTE FOUND */

		NPTR=SAVED.NPTR;			/* IF NO OLD NOTE FOUND - JUST START AS IF NEW NOTE */
		SBITS=SBITS\B.ART;		/* RECORD WITH ARTICULATE BIT IF THAT IS WHAT HAPPENED (OTHER NOTE NOT FOUND) */

	END;	/* OF CHECK FOR TIED NOTE */

	/* $SUBTITLE  CHECK CHANNEL ASSIGNMENTS FOR NEW NOTE */

	/*	0. CHECK FOR DOUBLE NOTE TRIGGER - SKIP NOTE IF SO.
		1. LOOK UP MAX NUM OF NOTES ALLOWED (MONOPHONIC RECORDING)
		2. CHECK FOR SAME TIMBRE & KEY - CANCEL NOTE OR STEAL CHANNELS IF SO
		3. CHECK FOR POLYPHONY EXCEEDED
		4. CHECK FOR OVERLAY PERFORMANCE
	*/

	IF (NORIG=0)&((INC.AXE=0)\(GDATA=0))	/* LIVE NOTE - NOT GUITAR */
	THEN DO;
		LOAD CHORIG; ULOAD KEYN; MUL NUM.KEYS;
		WRITE(MAM)=CLAV.PTR+SHR(RES,8);	/* POINT TO NOTE STATUS ARRAY IN EXT MEM */
		WRITE(MAL)=RES;
		IF (READ(MD)&ACTIVE)<>0 THEN DO;		/* CHECK FOR KEY ALREADY BEING PLAYED (TWO NOTE STARTS IN SAME LOOP) */
			CALL BREL;
			RETURN;
		END;
	END;

	WRITE(MAM)=TBP;
	WRITE(MAL)=TIM.MAX.NUM.NOTES;
	MAXNUM    =READ(MD);

	WRITE(MAM)=THP;
	WRITE(MAL)=THD.NACT;

	/* Check for for same note being played again.  E.G. steal channels from prior */
	/* occurrence of the note.  Also at this time check for polyphony exceeded.	 */

	IF  ((READ(MDI))<>0)			/* THD.NACT - IF THERE ARE DECAYING NOTES */
	OR  ((READ(MDI))<>0)			/* THD.NDEC - OR ANY ACTIVE NOTES         */
	THEN DO;							/* LOOK FOR TIMBRE/KEY MATCH              */

		SAVED.NPTR=NPTR;
		I=KEYN;									/* SET UP FOR SEARCH           */
		J=NORIG & "1";							/* SAVE ORIGIN OF NEW NOTE     */
		K=CHORIG;								/* SAVE CHANNEL ORIGIN OF NEW NOTE */
		NPTR=NOTELIST;							/* LOOK DOWN NOTE LIST         */

		DO WHILE (NPTR<>0)					/* SCAN LIST OF ACTIVE NOTES   */
		AND ((KEYN <>I      )				/* UNTIL SAME KEY, SAME TRACK  */
		OR   (TRACK<>TRK    )				/* IS FOUND                    */
		OR   ((NORIG & "1") <> J)			/* ALSO SAME ORIGIN            */
		OR   (CHORIG<>K     )				/* AND SAME CHANNEL ORIGN      */
		OR   (NSTAT=2       )				/* OR CHANNELS GONZO           */
/**/OR   ((INC.AXE<>0)					/* OR GUITAR COMPILATION       */
/**/AND   (AXE.HOLD.MODE=0)			/* AND HOLD SWITCH NOT IN SUSTAIN MODE */
/**/AND   ((GDATA & 255)=6)));		/* AND THIS NOTE IS HELD       */
			NPTR=NFPTR;
		END;

		IF NPTR<>0 THEN DO;					/* SAME PITCH FOUND            */
			WRITE(MAL)=THD.NACT;				/* CHECK POLYPHONY HERE ALSO   */
			IF ((READ(MDI)+READ(MDI))>=MAXNUM)
			THEN DO;								/* POLYPHONY EXCEEDED          */
				IF (TOPT&SLAP.BASS)<>0		/* FOR SLAP BASS, USE CANCEL.NOTE */
				THEN CALL CANCEL.NOTE;		/* ELSE CAN STEAL CHANS DIRECTLY  */
				ELSE CALL STEAL.CHANS;
				NPTR=SAVED.NPTR;				/* RESTORE NPTR TO NEW BLOCK   */
				GOTO CONTINUE.WITH.NEW.NOTE;
			END;
			CALL CANCEL.NOTE;					/* START FINAL DECAY           */
			NPTR=SAVED.NPTR;					/* RESTORE NPTR TO NEW BLOCK   */
			WRITE(MAM)=THP;					/* RESTORE THP POINTER         */
		END;
		ELSE DO;									/* NO SIMILAR PITCH FOUND      */
			NPTR=SAVED.NPTR;					/* RESTORE NPTR TO NEW BLOCK   */
			WRITE(MAL)=THD.NACT;
			IF ((READ(MDI)+READ(MDI))>=MAXNUM)
			THEN DO;												/* POLYPHONY EXCEEDED WITH AT LEAST ONE DECAYING NOTE */
				IF (OUR.BITS&B.TIE)=0 THEN DO;			/* HANDLE AS TIED NOTE IF TOO MANY HELD               */
					IF NORIG<>0 THEN DO;						/* SEQUENCER NOTE - TIE WITH ARTICULARION ALWAYS      */
						OUR.BITS=OUR.BITS\(B.TIE\B.ART);	/* MUST ARTICULATE OTHERWISE TIMING GETS OFF (TIED NOTES ARE PROCESSED AS UPDATE RECORDS) */
						GOTO TIED.NOTE;
					END;
					OUR.BITS=OUR.BITS\B.TIE;
					IF (MAXNUM<>1)							/* IF NOT MONOPHONIC */
					OR ((TOPT&BIT.APHRASE)=0)			/* OR NO AUTOPHRASE  */
					THEN OUR.BITS=OUR.BITS\B.ART;
					SBITS=SBITS\OUR.BITS;				/* IN CASE RECORDING */
					GOTO TIED.NOTE;
				END;
				CALL BREL;						/* POLYPHONY EXCEEDED BUT NO NOTE TO TIE TO? */
				RETURN;
			END;
		END;

	END;

	IF  (INC.MONO<>0)								/* CHECK OVERLAY MODE FOR MONO ONLY (FOR NOW) */
	AND (OVERLAY.STATUS<>0)						/* OVERLAY MODE */
	AND (NORIG<>0)									/* AND IS A SEQUENCER NOTE */
	AND (PLAY <>0)									/* PLAYING (VS. INFO NOTE) */
	AND (MOVE  =0)									/* NOT FF/REW              */
	THEN DO;											/* CHECK FOR OVERLAY MODE  */
		IF (NOTELIST<>0) THEN DO;				/* SOME OTHER NOTE PLAYING */
			NOTES.SKIPPED=NOTES.SKIPPED+1;	/* COUNT SKIPPED NOTES */
			CALL BREL;								/* SIMPLY RELEASE NOTE BLOCK */
			RETURN;									/* SKIP NOTE */
		END;
		WRITE(MAM)=NAH.PTR+REMAIN;
		WRITE(MAL)=TFLAG+1;
		WRITE(MD)=REST.NOTE;						/* CONVERT TO REST NOTE */
	END;												/* AND HOPE THE NOTE DOES NOT BOMB OUT BELOW!! */

	GOTO CONTINUE.WITH.NEW.NOTE;				/* SKIP SECOND OVERLAY MODE CHECK FOR SPEED */

	/* $SUBTITLE  SET UP PARTIAL BLOCKS FOR NEW NOTE */

	/* 1. ACCOUNT FOR ONE MORE ACTIVE NOTE       */
	/* 2. INITIALIZE NOTE BLOCK FOR PLAYING      */
	/* 3. CHECK FOR CHORUS                       */
	/* 4. COMPUTE INITIAL VOLUME INFO FOR TIMBRE */
	/* 5. SET UP FOR PARTIAL BLOCK ALLOCATION    */
	/* 6. ALLOCATE PARTIAL BLOCKS                */

	ALWAYS.START.NEW.NOTE:

	IF  (INC.MONO<>0)									/* CHECK OVERLAY MODE FOR MONO ONLY (FOR NOW) */
	AND (OVERLAY.STATUS<>0)							/* OVERLAY MODE */
	AND (NORIG<>0)										/* AND IS A SEQUENCER NOTE */
	AND (PLAY <>0)										/* PLAYING (VS. INFO NOTE) */
	AND (MOVE  =0)										/* NOT FF/REW              */
	THEN DO;												/* CHECK FOR OVERLAY MODE  */
		IF (NOTELIST<>0) THEN DO;					/* SOME OTHER NOTE PLAYING */
			NOTES.SKIPPED=NOTES.SKIPPED+1;		/* COUNT SKIPPED NOTES */
			CALL BREL;									/* SIMPLY RELEASE NOTE BLOCK */
			RETURN;										/* SKIP NOTE */
		END;
		WRITE(MAM)=NAH.PTR+REMAIN;
		WRITE(MAL)=TFLAG+1;
		WRITE(MD)=REST.NOTE;							/* CONVERT TO REST NOTE */
	END;													/* AND HOPE THE NOTE DOES NOT BOMB OUT BELOW!! */

	CONTINUE.WITH.NEW.NOTE:							/* SKIP SECOND OVERLAY MODE CHECK FOR SPEED */

	WRITE(MAM)=THP;
	WRITE(MAL)=THD.NACT;
	WRITE(MD )=READ(MD)+1;				/* ACCOUNT FOR POSSIBLY A NEW ACTIVE NOTE.  FROM NOW ON USE 'ABORT.NOTE' TO EXIT */

	WRITE(MAL)=THD.TVOL;					/* LOOK UP TRACK VOLUME   */
	TRACKVOL  =READ(MD);

	WRITE(MAL)=THD.CXPOS;				/* ALSO CURRENT XPOSITION */
	XPOSDIST  =READ(MD);

   WRITE(MAL)=THD.MIDX;
   MIDIDIST  =XPOSDIST+READ(MD);

	WRITE("300")=ADDR(NSTAT);				/* ZERO OUT NSTAT, STEALOK, NACT, PTLST, RRATE QUICKLY */

	WRITE("360")=0; WRITE("360")=TRK;	/* NSTAT, STEALME - INITIALIZE NOTE STATE, INDICATE ACTIVE (VS. DECAYING) NOTE (STEALME&256)=0
														(SEE ABORT.NOTE) */
	WRITE("360")=0;			/* NACT  - INITIALIZE # OF ACTIVE PARTIALS */
	WRITE("360")=0;			/* PTLST - INITIALIZE POINTER TO PARTIAL LIST */
	WRITE("360")=0;			/* RRATE - INITIALIZE REPEAT TIME. */
	FPRED=NEWFP;				/* STORE INITIAL PRESSURE, EITHER 0 OR THAT STOLEN FROM TIED NOTE (WORKS ESP WELL WITH MONO VOICES) */

	WRITE(MAM)=TBP;
	WRITE(MAL)=TIM.LOG.CH;
	CHORUS.ON=READ(MD);		/* SEE IF ANY CHORUS */

	PTL=0;						/* INITIALIZE PARTIAL # FOR LOOP */

   // See if track volume passed from Script; or perhaps a guitar volume or a live volume pedal
   IF ((OUR.BITS&B.VOL)<>0)
      OUR.VOL=(OUR.BITS&"177400")|(SHR(OUR.BITS,8));
   ELSE
      OUR.VOL=(SHL(255,8)|255);

	MY.AXE=0;					/* ASSUME NOT A GUITAR NOTE (LIVE OR FROM SEQUENCER) */
	IF (OUR.BITS&B.GUI)<>0 THEN MY.AXE=(OUR.BITS&7)+1;			/* EXTRACT RECORDED STRING NUMBER, IN CASE SEQUENCER NOTE, MAKE NONZERO */

	IF INC.POLY OR (MODC<>0) THEN DO;
		WRITE("300")=ADDR(NUM1); /* ZERO OUT NUMBER OF VOICE VARIABLES QUICKLY */
		RPC 8;                   /* CLEAR OUT NUM1-2, NUME, NUMM, NUMP0-3 */
		WRITE("360")=0;
	END;
	ELSE DO;
		WRITE("300")=ADDR(NUM1); /* AS QUICKLY AS POSSIBLE IF NO RPC INSTRUCTION */
		WRITE("360")=0; WRITE("360")=0;	/* NUM1,  NUM2  */
		WRITE("360")=0; WRITE("360")=0;	/* NUME,  NUMM  */
		WRITE("360")=0; WRITE("360")=0;	/* NUMP0, NUMP1 */
		WRITE("360")=0; WRITE("360")=0;	/* NUMP2, NUMP3 */
	END;

	IF NORIG=0 THEN DO;					/* KEYBOARD/GUITAR NOTE - CHECK FOR RECORDING */
		dcl recent.keyboard.key fixed external;

		recent.keyboard.key = KEYN;	/* publish recent key # for XX function */

		WRITE(MAM)=THP;

		IF ((RECD<>0) & (RECD.TRK<>0))
		THEN DO;

			I=1;								/* ASSUME ACTIVE NOTES SHOULD BE UPDATED FOR RTE'S */

			WRITE(MAL)=THD.NACT;
			IF ((READ(MDI)+READ(MDI))=1)
			AND (CHORIG=0) THEN I=0;	/* NO NEED TO UPDATE ACTIVE NOTES IF THE ONE STARTING IS THE ONLY NOTE PLAYING
													(UNLESS MIDI MAPPED TO RECORDER) */

			// Compute the time the note was detected and record that time into the sequencer
			J=OTIML-SAMPLED.KBD.MILLISECONDS;	/* GET # OF MSEC UNTIL KBD NOTE START   */
			
			// If a cue track - record start time some random interval in the future
			WRITE(MAL)=THD.CUE.TRACK;
			
			if (READ(MD)<>0)
			{
				LOAD SHR(SAMP.SPEED,2);
				FENDM=SAMPLED.ACTUAL.PLAY.TIME.MSB;
				FENDL=SAMPLED.ACTUAL.PLAY.TIME.LSB+RES;
				IF FENDL ILT RES THEN FENDM=FENDM+1;
			}

			// Else if starting late (generally the case) compute sequencer time when the key press was detected
			else if (j<0)
			{
				LOAD -J-1; ULOAD 1000-SAMPLED.ACTUAL.PLAY.TIME.ACU;		/* (J*SPEED+TIM.ACCUM)/1000 */
				MUL SAMP.SPEED;														/* CORRECT FOR SPEED        */
				MWAIT ; DIV 1000;

				/* Note set FENDM to real time here.  Justify.Time */
				/* performs justification and converts fendm       */
				/* to a sequencer time.                            */

				FENDM=SAMPLED.ACTUAL.PLAY.TIME.MSB;
				FENDL=SAMPLED.ACTUAL.PLAY.TIME.LSB-RES;
				IF FENDL IGT SAMPLED.ACTUAL.PLAY.TIME.LSB THEN FENDM=FENDM-1;
			}
			
			// Else we are still ahead of the pack
			else
			{
				LOAD J; ULOAD SAMPLED.ACTUAL.PLAY.TIME.ACU;	/* (J*SPEED+TIM.ACCUM)/1000 */
				MUL SAMP.SPEED;										/* CORRECT FOR SPEED        */
				MWAIT ; DIV 1000;

				/* Note set FENDM to real time here.  Justify.Time */
				/* performs justification and converts fendm       */
				/* to a sequencer time.                            */

				FENDM=SAMPLED.ACTUAL.PLAY.TIME.MSB;
				FENDL=SAMPLED.ACTUAL.PLAY.TIME.LSB+RES;
				IF FENDL ILT RES THEN FENDM=FENDM+1;
			}
			
			IF JUSTIFY.TIME.AND.CHECK.EFFECTS(I)<>0	/* JUSTIFY START TIME */
			THEN DO;												/* AND STORE EFFECTS  */
				CALL ABORT.NOTE; RETURN;					/* TOSS NOTE IF BOMB  */
			END;

			WRITE(MAM)=THP;
		END;

		/* Trigger the cue manually here if recording cue triggers */
		/* using the VK:                                           */

		WRITE(MAL)=THD.CUE.TRACK;
		IF READ(MD)<>0 THEN DO;

			IF TIME.BASE.MODE<>0
			THEN CALL COPY32(LOC(ADDR(SAMPLED.ACTUAL.PLAY.TIME.MSB)), CUETIME);
			ELSE CALL STR32 (0, 0, CUETIME);

			write(mam)=tbp;					/* point to timbre head        */
			write(mal)=tim.partial.pointers + 0;
			i         =read(md);				/* get partial pointer handy   */
			write(mal)=tim.kbdtab.ptr       + 0;

			if  (read(md) <> 0 )				/* make sure kbd table exists  */
			and (keyn     >= 12)				/* make sure key in range      */
			then do;

				write(mam)=tim.ptr + read(md) - 1;
				write(mal)=keyn-12;
				j         =read(md);			/* get cue id or event ptr     */

				if j < 0 then do;				/* means this is event         */
					call p.lookup(i-j+ev.in.msb);
					write("300") = addr(copy.buf(0));
					rpc (ev.name - ev.in.msb);
					write("360") = read(mdi);
					call p.lookup(i-j+ev.cue.id);
					j = read(md);				/* get actual cue id           */
					k = addr(copy.buf(0));
				end;
				else k = 0;						/* no event info for cue trigs */

				if j <> 0						/* if id actually exists       */
				then call Manually.Trigger.Event.Or.Cue
					  (j, cuetime, 4096\1,
						rte.max, 0, 0, 0,
						32768 + trk, loc(k));

			end;

		END;
	END;

	ELSE DO;									/* SEQUENCER NOTE - CHECK FOR SLAP BASS TIMBRE AND "PLAY TO" */

		IF (PLAY.SEQ.TO.A.TIME <> 0)			/* IF NOTE LASTS BEYOND THE */
		&  ((FENDM IGT SEQ.PLAY.TO.MSB)		/* PLAY TO POINT, THEN      */
		\   ((FENDM  =  SEQ.PLAY.TO.MSB)		/* SHORTEN NOTE TO END AT   */
		&    (FENDL IGT SEQ.PLAY.TO.LSB)))	/* THE PLAY TO POINT        */
		THEN DO;
			FENDM = SEQ.PLAY.TO.MSB;			/* END THE NOTE AT THE      */
			FENDL = SEQ.PLAY.TO.LSB;			/* PLAY TO POINT            */
		END;

		IF (TOPT&(SLAP.BASS\BIT.REPEAT\BIT.ARPEG))<>0
		THEN DO;								/* ADVANCE ENDING TIME FOR CORRECTNESS */
			FENDL=FENDL+PRESCAN;			/* DELAY NOTE ENDING TIME */
			IF FENDL ILT PRESCAN
			THEN FENDM=FENDM+1;			/* DETECT WRAP */
		END;

	END;


	/* $SUBTITLE  ALLOCATE PARTIAL BLOCKS FOR NEW NOTE */

	/* THE FOLLOWING CODE CYCLES THROUGH EACH OF THE PARTIAL TIMBRES IN THE
		SPECIFIED TIMBRE DEFINITION.  FOR EVERY ACTIVE PARTIAL, 1 TO 4 PARTIAL
		BLOCKS ARE ALLOCATED, DEPENDING ON THE OVERALL CHORUS FUNCTION AND
		THE NEW INDIVIDUAL CHORUS FUNCTION.
	*/

	DO WHILE GFREE<>0;				/* FREE UP FINISHED GHOST PARTIAL BLOCKS */
		DISABLE;							/* (IF ANY) */
		PPTR=GFREE; GFREE=PFPTR;
		ENABLE;
		CALL RELP;						/* USE SPEEDY ZERO ROUTINE TO SET UP NOTE BLOCK */
	END;

	WRITE(MAM)=TBP;					/* KEEP TBP LOADED NOW & AT END OF LOOP */

	DO PTL=0 TO (NUM.PARTIALS-1);			/* LOOP OVER PARTIALS */

		WRITE(MAL)=PTL;						/* TIM.VOLUME.LEV */
		IF (READ(MD)<>0) THEN DO;			/* QUICK CHECK FOR INACTIVE PARTIALS */

			/* CHECK FOR PARTIAL VOLUME */
			/* CHECK KBD & DYN ENVELOPE */
			/* CHECK STRING SOLO        */
         LOAD     TRACKVOL;				/* TRACK VOLUME * PARTIAL VOLUME = 0-255 */
			MUL      READ(MD);				/* MUL BY VOLUME.LEV (16714)             */
			LOAD     URES;						/* GET FRACTIONAL RESULT, 0-255          */
         ULOAD    32768;               /* ROUND BY 1/2                          */
			MUL      OUR.VOL;
			MY.VOL = URES;						/* FRACTIONAL MULTIPLY RESULT */

			WRITE(MAL)=TIM.OPTIONS+PTL;
			OPT=READ(MD);						/* LOOK UP OPTIONS WORD FOR SPEED */

         IF (OPT&(KBD.ENV\DYN.ENV))<>0	/* CHECK FOR KEYBOARD OR DYNAMIC ENVELOPE */
			THEN DO;								/* MUST CHECK FURTHER */

				WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
				PTPTR=READ(MD);				/* SET UP PARTIAL PTR FOR SUB CALLS HERE */

				IF ((OPT&KBD.ENV)<>0)							/* COMPUTE KBD ENVELOPE IF REQUIRED */
				THEN MY.VOL=COMPUTE.KBD.ENV(MY.VOL);		/* MUST COMPUTE VOLUME */

				IF ((OPT&DYN.ENV)<>0)							/* DYN ENV USED */
				THEN DO;												/* SCALE FOR DYNAMIC ENVELOPE IF ANY THERE */

					WRITE(MAM)=TBP;
					WRITE(MAL)=TIM.DYN.ENV.LOOK;
					IF READ(MD)<>0 THEN DO;						/* SHOUD BE ROUTED */
						L=SCALE(255);								/* GET SCALED NUMBER FOR DYNAMIC ENVELOPE */
						IF L>255 THEN L=255;						/* LIMIT TO MAX */
						WRITE(MAL)=TIM.PINFO.POINTERS+PTL;
						K=READ(MD)+PI.DENVL;						/* LOOK UP POINTER - IT MUST BE THERE OR DYN.ENV WOULD = 0 */
						WRITE(MAM)=PAR.PTR+SHR(K,8); WRITE(MAL)=K;
						J=READ(MDI); K=READ(MDI);				/* GET DYN ENV LIMITS */
						IF J=0 THEN J=1; IF K=0 THEN K=1;	/* MAKE SURE IN RANGE 1-8 */
						IF (L<DENVLIM(J-1))						/* SEE IF IN DESIRED RANGE */
						OR (L>=DENVLIM(K))
						THEN MY.VOL=0;
					END;
				END;
			END;

         IF MY.AXE<>0 THEN DO;				/* IF GUITAR NOTE (LIVE OR FROM SEQUENCER), CHECK ACTIVE STRINGS */
				WRITE(MAM)=TBP;
				WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
				PTPTR=READ(MD);					/* SET UP PARTIAL PTR FOR SUB CALLS HERE */
				J=PTPTR+P.ACT.STRGS;				/* LOOK UP ACTIVE STRINGS WORD */
				WRITE(MAM)=PAR.PTR+SHR(J,8); WRITE(MAL)=J;
				IF (READ(MD)&BITS(MY.AXE+9))<>0 THEN MY.VOL=0;	/* STRING NOT SELECTED (NOTE NEGATIVE LOGIC HERE) */
			END;

			/* $PAGE - CHECK FOR PATCH LIST TIMBRE */

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.SYNTH.TYP+PTL;
			SYNTYP=READ(MD);							/* GET SYNTH TYPE TO USE */

         IF SYNTYP>=TIM#POLY THEN DO;			/* CHECK FURTHER FOR PATCH TIMBRE */

				IF  (INC.MONO=0)						/* NO MONO */
				AND (INC.POLY=0)						/* NO POLY */
				THEN MY.VOL=0;							/* STOP NOTE */

				ELSE DO;

					WRITE(MAL)=TIM.KBDTAB.PTR+PTL;
					J=READ(MD);							/* GET POINTER TO LOOKUP TABLE */

					IF J=0 THEN MY.VOL=0;			/* CAN NOT PLAY PARTIAL IF NO LOOKUP TABLE */
					ELSE DO;								/* SEE IF KEY IS PLAYABLE */
						WRITE(MAM)=TIM.PTR+J-1;		/* POINT TO BASE */
						J=KEYN+XPOSDIST;				/* ADD IN XPOS TO LOOKUP PTR */
						IF (J<0) OR (J>=NUM.KEYS)
						THEN MY.VOL=0;					/* TRANSPOSED OFF END OF KBD */
						ELSE DO;
							WRITE(MAL)=J*KLT.SIZE + KLT.PATCH.TIM.PTR;	/* CHECK TABLE */
							IF READ(MDI)=0 THEN MY.VOL=0;	/* THIS KEY NOT PATCHED IN */
							ELSE DO;
								IF (READ(MD)&BASE#STEREO_B)<>0 THEN SYNTYP=SYNTYP\TIM#STEREO;	/* SET BIT IF STEREO */
								/* NEXT LINE IS A QUICKER "BIN = SHR(READ(MD),BASE#BIN_P);" */
								BIN = ROT(READ(MD),2) & "3";	/* SAVE BIN FOR LATER USE IN LOOP OVER PARTIALS */
							END;
						END;
						WRITE(MAM)=TBP;
					END;
				END;
			END;

			IF MY.VOL<>0 THEN DO;					/* ALLOCATE PARTIAL BLOCKS IF PARTIAL HAS SOME VOLUME */

				IF PFREE=0 THEN DO;
					IF GETPBLK=0 THEN RETURN;		/* TRY TO GET ONE */
					WRITE(MAM)=TBP;
				END;

				PPTR =PFREE; PFREE=CORE(PFREE);	/* GET PARTIAL BLOCK */

				PFPTR=PTLST; PTLST=PPTR;			/* PUT US ON FRONT OF PTLST  */
				PLOG =    0;							/* INDICATE BASIC BLOCK      */
				PARTL=  PTL; BVOL =MY.VOL;			/* SAVE PTL #, BASIC VOL     */

				WRITE(MAL)=TIM.VE.PKSUS.LOOK;		/* TEST VOLUME RTES          */
				IF READ(MD)<>0 THEN DO;				/* SCALING VOLUME WITH RTE'S */
					IF (READ(MD)=(1+16+256+4096))	/* VELOCITY TO ALL 4 PARTIAL */
					THEN DO;								/* COMPUTE THIS COMMON PATCH QUICKLY */
						LOAD MY.VOL; MUL VELD&255;
						MWAIT;       DIV RTE.MAX;
						MY.VOL=RES;
					END;
					ELSE DO;								/* PERFORM NORMAL SCALING */
						MY.VOL=SCALE(MY.VOL);
						IF MY.VOL>255 THEN MY.VOL=255;	/* LIMIT TO 255 */
					END;
				END;

				WRITE(MAL)=TIM.TVOL.LOOK;			/* CHECK FOR TRACK VOLUME    */
				IF READ(MD)<>0 THEN DO;				/* SCALING VOLUME WITH RTE'S */
					MY.VOL=SCALE(MY.VOL);
					IF MY.VOL>255 THEN MY.VOL=255;		/* LIMIT TO 255 */
				END;

				RVOL=MY.VOL;							/* STORE IN PARTIAL BLOCK */

				J=1;										/* COUNT 1 BLOCK SO FAR */

				/* $PAGE - ALLOCATE CHORUS BLOCKS IF USED */

				WRITE(MAL)=TIM.LOG.NCH+PTL;

				IF READ(MD)<>0 THEN DO;	/* PARTIAL CHORUS IS ON */

					IF PFREE=0 THEN DO;
						IF GETPBLK=0 THEN RETURN;
						WRITE(MAM)=TBP;
					END;

					K=PFREE;  PFREE=CORE(PFREE);		/* GET PARTIAL BLOCK  */

					CORE(K)=PFPTR; PFPTR=K;				/* LINK ON AFTER US   */
					CORE(K+PLOGLOC)=1;					/* INDICATE PCH BLOCK */

					J=2;										/* TWO BLOCKS NOW     */

					IF (CHORUS.ON<>0) THEN DO;			/* MUST GET TWO MORE  */

						IF PFREE=0 THEN DO;
							IF GETPBLK=0 THEN RETURN;
							WRITE(MAM)=TBP;
						END;

						PPTR=PFREE;  PFREE=CORE(PFREE);	/* GET PARTIAL BLOCK   */

						PFPTR=CORE(K); CORE(K)=PPTR;		/* LINK ON AFTER PCHOR */
						PLOG=2;									/* INDICATE CHOR BLOCK */

						IF PFREE=0 THEN DO;					/* NOW GET PCHCH BLOCK */
							IF GETPBLK=0 THEN RETURN;
							WRITE(MAM)=TBP;
						END;

						K=PFREE;  PFREE=CORE(PFREE);		/* GET PARTIAL BLOCK    */

						CORE(K)=PFPTR; PFPTR=K;				/* LINK ON AFTER CHOR   */
						CORE(K+PLOGLOC)=3;					/* INDICATE PCHCH BLOCK */

						J=4;										/* 4 BLOCKS */

					END;	/* OF CHORUS.ON */

				END;	/* OF PARTIAL CHORUS IS ON */

				ELSE IF (CHORUS.ON<>0)						/* ALLOCATE CHORUS BLOCK */
				AND ((INC.MONO=0)\(SYNTYP<>TIM#MONO))	/* DISALLOW MONO CHORUS  */
				THEN DO;											/* IF NOT MONO           */

					IF PFREE=0 THEN DO;
						IF GETPBLK=0 THEN RETURN;
						WRITE(MAM)=TBP;
					END;

					K=PFREE;  PFREE=CORE(PFREE);		/* GET PARTIAL BLOCK   */

					CORE(K)=PFPTR; PFPTR=K;				/* LINK ON AFTER US    */
					CORE(K+PLOGLOC)=2;					/* INDICATE CHOR BLOCK */

					J=2;										/* TWO BLOCKS TOTAL    */

				END;

				/* $PAGE - COUNT CHANNELS REQUIRED FOR NOTE */

				NACT=NACT+J;								/* COUNT # OF PARTIAL BLOCKS USED */

				IF SYNTYP=TIM#FM THEN DO;				/* ORIGINAL SYNTHESIZER */

					IF ((OPT&SPLICE.INFO)<>0)			/* IF SPLICING USED */
					THEN J=J+J;								/* WILL NEED SPLICE CHANNELS AS WELL */

					WRITE(MAL)=TIM.WMEM#+PTL;
					IF READ(MD)=0 THEN DO;				/* OUT OF WAVE MEM */
						IF (LSYN1.START != LSYN2.END)
							CALL KBD.ERROR(1);			/* TELL USER       */
						WRITE(MAM)=TBP;
					END;

					WRITE(MAL)=TIM.CAN.USE.BOTH+PTL;
					IF (READ(MD)<>0)  THEN NUME=NUME+J;	/* EITHER ONE */
					ELSE DO;
						WRITE(MAL)=TIM.WMEM#+PTL;
						IF (READ(MD)&255) <>0
						THEN NUM1=NUM1+J;	/* SYNTH ONE ONLY */
						ELSE NUM2=NUM2+J;	/* LSYNTH 2 ONLY  */
					END;
				END;	/* OF BEGIN FOR ORIGINAL SYNTHESIZER */

				ELSE IF SYNTYP=TIM#MONO THEN DO;		/* MONO SAMPLING (W. DISK) */
					NUMM=NUMM+J;
				END;

				ELSE DO;										/* MEANS POLY SYNTH IS NEEDED         */
					IF ((SYNTYP&TIM#STEREO)<>0)		/* IF STEREO USED                     */
					THEN J=J+J;								/* WILL NEED SPLICE CHANNELS AS WELL  */
					PTR = ADDR(NUMP0) + BIN;			/* POINT AT COUNT FOR THIS NOTE'S BIN */
					CORE(PTR) = CORE(PTR) + J;			/* ADD VOICES NEEDED                  */
				END;

			END;	/* OF VOLUME IS NON-ZERO */

		END;	/* OF PARTIAL IS ACTIVE */

	END;	/* OF LOOP OVER PARTIALS */
