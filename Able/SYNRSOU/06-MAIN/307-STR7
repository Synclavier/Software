/* :SYNRSOU:06-MAIN:307-STR7 - CODE FOR STARTING A NOTE, SECTION 2 *//*Modified:1998/06/14 - TY  - Minor streamlining.1996/12/12 - CJ  - Recorded thd.clpitch in track head correctly for pre-computed notes1991/03/22 - cj  - Changed kbd.spl.time to fix Lee Kopp FM retrigger clicks.1991/02/07 - MWH - Combine 3200, 6400 and 9600 RTP's1989/11/14 - TSS - Fixed MIDI pitch bend bug for live notes during record1988/12/02 - SGS - Fixed bugs in Diagnostic Channel assignment1988/10/18 - cj  - fixed bug with partial chorus1988/10/14 - CJ  - DIFFERENT USE OF PARTIAL BLOCK ENTRIES TO ACCOMPLISH						 STARTUP OF POLY NOTES IN MIDDLE1988/09/22 - TSS - MODIFIED CHANNEL ALLOCATION CODE TO ALLOW FOR RUN-TIME DIAGNOSTICS ENABLE1988/09/21 - TSS - MOVED CODE FROM HERE INTO 308-STR81988/04/13 - PF  - ADDED CODE FOR MULTI TRACK SEQUENCING1988/04/13 - PF  - ADDED CODE FOR MULTI CHANNEL SUSTAIN PEDAL1987/07/13 - MWH - GET BIN WITH ROT 2 & "3", NOT SHR 14 (FOR SPEED)1987/07/10 - MWH - EXPAND NUMP FOR 4 BINS OF POLY1987/06/26 - MWH - Split FRP.PTR into FP0-FP3.PTR for expanded poly1987/06/22 - MWH - Move multi.syn2 to external memory at MFM.PTR1986/12/30 - CJ  - MONO SAMPLING ITEMS1986/12/16 -     - MASKED OFF BITS FOR REPEAT RATE1986/09/30 -CJ,TS- FIXED NO MULTI/SPLICING BUG1986/08/25 - TS  - ADDED THD.ACTIVE.MIDI.RTES CODE1986/07/28 - CJ  - CHANNEL ALLOCATION FOR STEREO1986/07/24-KJC,CJ- KBDTAB CHANGES1986/07/23 -CJ,KC- CHANGED UCHN USAGE1986/07/15 -cj,ts- changed midi.control.change call1986/07/11 - CJ  - CHANGED QSTAT/SEQ.SPL.TIM OPERATION.  MOVED RECORD.ACTUAL.NOTE CALL TO HERE1986/05/15 - "official" creation of release-M modules*//* CONTINUE WITH SETUP.NOTE:	1. SEE IF ENOUGH CHANNELS ARE AVAILABLE TO PLAY THE NOTE	2. COMPUTE BASIC NOTE INFO - PITCH, ARPEGGIATE	3. FILL IN THE ALLOCATED PARTIAL BLOCKS :		ENVELOPE INFO, TUNING, GLIDE, CHANNEL ASSIGNMENTS	4. CLEAN UP *//* CHECK CHANNELS: */	WRITE("313")=ADDR(NUM1);					/* SET UP FOR FAST COMPARE OF NUM1, NUM2, NUM3, NUMM, */														/* NUMP0, NUMP1, NUMP2, NUMP3 */	IF TEMP.LIST(0)=0 THEN DO;					/* IF NO STOLEN CHANNELS,  SEE IF ENOUGH NEW CHANNELS. IF STOLEN CHANNELS, ASSUME THERE ARE PROBABLY ENOUGH */		IF  (CORE(FR1.PTR)<READ("373"))		/* NUM1  - NOT ENOUGH CHANS IN LSYNTH1 */		OR  (CORE(FR2.PTR)<READ("373"))		/* NUM2  - NOT ENOUGH CHANS IN LSYNTH2 */		OR ((CORE(FR1.PTR)-NUM1+CORE(FR2.PTR)-NUM2)<READ("373"))	/* NUME - NOT ENOUGH */		OR  (CORE(FRM.PTR)<READ("373"))		/* NUMM  - NOT ENOUGH MONO VOICES */		OR  (CORE(FP0.PTR)<READ("373"))		/* NUMP0 - NOT ENOUGH POLY VOICES IN BIN-0 */		OR  (CORE(FP1.PTR)<READ("373"))		/* NUMP1 - NOT ENOUGH POLY VOICES IN BIN-1 */		OR  (CORE(FP2.PTR)<READ("373"))		/* NUMP2 - NOT ENOUGH POLY VOICES IN BIN-2 */		OR  (CORE(FP3.PTR)<READ("373"))		/* NUMP3 - NOT ENOUGH POLY VOICES IN BIN-3 */		THEN DO;									/* MUST TRY TO GET MORE CHANNELS */			WRITE(MAM)=THP;			WRITE(MAL)=THD.NDEC;			IF (READ(MD)=0)					/* IF NO DECAYERS                */			THEN DO;								/* THEN CAN NOT STEAL ANY        */				CALL ABORT.NOTE;				/* FREE UP ALL BLOCKS            */				RETURN;			END;			CALL CHECKQUE;						/* CHECK QUEUE FOR DECAYING NOTES WE CAN STOP */			IF TEMP.LIST(0)=0 THEN  DO;	/* CAN NOT PLAY NOTE IF NO STOLEN CHANNELS */				CALL ABORT.NOTE;				/* FREE UP ALL BLOCKS */				RETURN;			END;		END;	END;	/* $PAGE - CHECK FOR TOTAL NOTE ITEMS */	/* EUREKA - THERE ARE PROBABLY ENOUGH CHANNELS AVAILABLE TO PLAY THE NOTE.		CYCLE THROUGH EACH PARTIAL BLOCK, AND SET IT UP TO PERFORM THE SOUND.		THIS INCLUDES ACTUALLY ALLOCATING THE CHANNELS, INITIALIZING THE		PORTAMENTO, INITIALIZING THE VIBRATO ACCUMULATORS, AND SO FORTH. */	/* FIRST - COMPUTE INFO FOR TOTAL NOTE (PITCH, REPEAT/ARPEG).		THEN COMPUTE INFO FOR EACH PARTIAL */	IF (INC.AXE=0)\(GDATA=0) THEN DO;				/* KEYBOARD NOTE */		PITCH=COMPUTE.KBD.PITCH(KEYN+XPOSDIST);		OUR.VOL=255;										/* USE MAX */	END;	ELSE DO;			/* LIVE GUITAR NOTE */	  PITCH=GPITCH;	/* ELSE USE ACTUAL PITCH FROM GUITAR */	  IF OCTRATIO<>1000 THEN PITCH=COMPUTE.GUITAR.OCTAVE.RATIO(PITCH);	/* CORRECT FOR OCTAVE RATIO.  AVOID PROCEDURE CALL MOST OF THE IME */	  OUR.VOL=GVOL;	/* USE GUITAR INFO FOR VOLUME */	END;	WRITE(MAM)=THP;	WRITE(MAL)=THD.CTBITS;	G.VAL=0;													/* ASSUME NO FORCED GLIDE FROM FOOT SW */	ARPEG.VAL=(TOPT XOR READ(MD))&(BIT.ARPEG\BIT.REPEAT);	/* LOOK UP REPEAT/ARPEGGIATE BIT FROM TIMBRE DEFINITION */	IF NORIG<>0 THEN WRITE(MAL)=THD.RTES+4;		/* SEQUENCER NOTE - LOOK UP INFO FROM TRK HEADER */	ELSE DO;		IF  (RECD<>0)										/* RECORDING */		AND (RECD.TRK<>0)									/* INTO SEQUENCER */		AND (CHORIG=0)										/* NOTE IS MAPPED TO KEYBOARD */ // was midi  mapped		THEN DO;			WRITE(MAM)=TRK.HEAD;			WRITE(MAM)=READ(MD);		 END;		 WRITE(MAL)=THD.LIVE.RTES+4;	END;	PWP=READ(MD)&255;	/* LOOK UP PITCH WHEEL POSITION FOR THIS TRACI (FASTER THIS WAY) */	WRITE(MAM)=THP;										/* RESTORE PTR TO TRK HEAD */	WRITE(MAL)=THD.CLPITCH;	OUR.LAST.PITCH=READ(MD);							/* IN CASE OF GLIDE */	ANY.HZ.SET = 0;										/* ASSUME NO HZ'S WILL BE SET */	WRITE(MAL)=THD.MRNPTR;	WRITE(MD)=NPTR;										/* SAVE POINTER TO MOST RECENT NOTE FOR PORTAMENTO CHECK - MUST DO SO BEFORE CALL TO SETUP.FRQS */	IF ((OUR.BITS&B.GUI)=0) THEN DO;					/* KEYBOARD NOTE - CHECK FOOT SWITCHES */		IF ((OUR.BITS&(B.ARP\B.GLI\B.REP))<>0)		/* CHECK FOR ANY BITS QUICKLY */		THEN DO;			IF ((OUR.BITS&B.GLI)<>0)					/* GLIDE FOOT SW */			THEN G.VAL=1;			IF ((OUR.BITS&B.ARP)<>0)					/* ARPEG FOOT SW */			THEN ARPEG.VAL=ARPEG.VAL\BIT.ARPEG;			IF ((OUR.BITS&B.REP)<>0)					/* REPEAT FOOT SW */			THEN ARPEG.VAL=ARPEG.VAL\BIT.REPEAT;		END;	END;	/* $PAGE - FILL IN PARTIAL BLOCKS FOR NEW NOTE */	PPTR=PTLST;									/* SET POINTER TO FIRST PARTIAL BLOCK */	IF PPTR<>0 THEN DO;						/* MIGHT BE ZERO IF NACT=0 */		NEXT.BLOCK:;							/* RE-ENTER FROM BELOW FOR NEXT BLOCK */		WRITE(MAM)=TBP;		PTL    =PARTL;							/* LOOK UP PARTIAL NUMBER             */		WRITE(MAL)=TIM.OPTIONS+PTL;		OPT       =READ(MD);					/* LOOK UP PARTIAL OPTIONS FOR SPEED  */		WRITE(MAL)=TIM.SYNTH.TYP+PTL;		SYNTYP    =READ(MD);					/* AND REQUIRED SYNTHESIZER TYPE FOR THIS PARTIAL */		WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;		PTPTR     =READ(MD);					/* LOOK UP POINTER.  TRUST PSTAT TO BE ZERO */		/* HANDLE KEYBOARD NOTES */		/* QUICKLY TO REDUCE     */		/* KEYBOARD DELAYS       */		IF  (TB=0)								/* THIS PARTIAL IS PRE-COMPUTED */		AND (NEW.KBD.PRE=0)					/* AND WE ARE ALL CAUGHT UP WITH KNOB CHANGES */		THEN DO;									/* THEN USE TABLE LOOKUP */		  LOAD PTL;								/* D5 = PARTIAL # (0- 7) */			ULOAD KEYN;							/* D4 = KEY     # (0-84) */			MUL NUM.KEYS;						/* PARTIAL*NUM.KEYS+KEYN */			MWAIT;			MUL KBD.PRE.STR;					/* MULT BY TABLE STRIDE  */			WRITE(MAM)=KBD.PRE+SHR(RES,8);			WRITE(MAL)=RES;			IF INC.POLY OR (MODC<>0) THEN DO;	/* COPY INFO IN */				WRITE("300")=ADDR(SSTAT);			/* SET UP PTR   */				RPC KBD.PRE.STR1;						/* COPY IN INFO */				WRITE("360")=READ(MDI);			END;			ELSE DO;										/* MOD B        */				WRITE("300")=ADDR(SSTAT);			/* SET UP PTR   */				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);				WRITE("360")=READ(MDI);			END;			WRITE(MAM)=TBP;								/* RESTORE MAM PTR     */			IF (OPT&(ANY.DELAY\ENV.RTES\INX.RTES))<>0	/* MAKE QUICK CHECK FOR */			THEN DO;												/* ANY RTE'S */				IF (OPT&ANY.DELAY)<>0		/* DELAY USED         */				THEN DO;							/* COMPUTE DELAY INFO */					CALL COMPUTE.DELAY;					IF DO.FM=0					/* BUT IF FM NOT USED */					THEN ITIMER=ETIMER-1;	/* THEN SET NOT EQUEL */				END;				IF (OPT&ENV.RTES)<>0			/* ENV RTE'S USED */				THEN CALL COMPUTE.ENV;				IF  (OPT&INX.RTES)<>0		/* INX RTE'S USED */				AND (OPT&ANY.FM  )<>0		/* (WITH FM)      */				THEN CALL COMPUTE.INX;			END;			IF ((INC.AXE<>0)&(GDATA<>0))				/* IF GUITAR NOTE      */			THEN SET.HZ=1;									/* MUST SET HZ BELOW   */			ELSE SET.HZ=0;									/* HZ'S ALL SET        */		END;		/* $PAGE - FILL PARTIAL BLOCKS THAT HAVE NOT BEEN PRE-COMPUTED */		ELSE DO;			IF SYNTYP>=TIM#POLY THEN DO;				/* PATCH TIMBRE - LOOK UP INFO     */				/* READ PATCH FRAME POINTER */				/* READ SOUND F SECTOR #    */				WRITE(MAL)=TIM.KBDTAB.PTR+PTL;				WRITE(MAM)=TIM.PTR+READ(MD)-1;				WRITE(MAL)=(KEYN+XPOSDIST)*KLT.SIZE+KLT.PATCH.TIM.PTR;	/* GET LOCATION WITHIN THE SECTOR */				IF  (INC.MONO  <>  0)										// FOR MONO SAMPLING, SET UP				AND (SYNTYP=TIM#MONO)										// INFO				THEN DO;					K=PTPTR+READ(MDI)+PT.SRATE;							// POINT TO FRAME IN QUESTION, SRATE ENTRY-ADVANCE TO MEMORY SECTOR #					WRITE("324")=READ(MDI);									// SKIP BASE MSB INFO					SSTAT=READ(MD);											// SAVE EXTERNAL MEMORY SECTOR				END;								ELSE DO;															// ELSE MUST BE POLY					K=PTPTR+READ(MDI)+PT.WTABL;							// POINT TO PT.WTABL ENTRY IN PATCH FRAME					M=READ(MDI);												// GET STEREO, BIN, PAGE  KLT.BASE.MSB					L=READ(MD );												// GET BASE SECTOR        KLT.BASE.LSB					ITMC = M;													// SAVE BIN & STEREO FOR CHANNEL ALLOCATION BELOW					WRITE(MAM)=PAR.PTR+SHR(K,8);							// POINT TO PT.WTABL INFO					WRITE(MAL)=K;												// COMPUTE IN PARTIAL AREA					WRITE("300")=ADDR(MONU);								// COPY TO PARTIAL BLOCK					RPC 7;														// PT.WTABL (2), PT.SOFS, PT.WOFS,					WRITE("360")=READ(MDI);									// PT.LOOPL (2), PT.ONLOOP																					// MONU, MNNM     = PT.WTABL																					// MINC           = PT.SOFS																					// IATLIM         = PT.WOFS																					// IATINT, IIDLIM = PT.LOOPL																					// IIDINT         = PT.ONLOOP										// add sound file base in memory to the mark start position.  This is					// where we compute the absolute memory pointer to where the sound is					// in poly ram.					MINC = MINC + L;											// ADD BASE TO SECTOR OFFSET					IF MINC ILT L												// IF CARRY ...					THEN M=(M&BASE#PAGE_B)+1;								// THEN INCREMENT PAGE					ELSE M=(M&BASE#PAGE_B)  ;								// ELSE EXTRACT   PAGE					IATLIM = IATLIM \ SHL(M,8);							// STORE PAGE BITS IN UPPER					K=K+(PT.SRATE-PT.WTABL);								// MOVE POINTER TO PT.SRATE FIELD NOW				END;				/* READ SAMPLE RATE FOR SF  */				/* READ SET OCT     FOR SF  */				/* READ FRACTIONAL SET OCT  */				/* READ SEMITONE CORRECTION */				WRITE(MAM)=PAR.PTR+SHR(K,8);	/* GET INFO FROM PATCH LIST FRAME */				WRITE(MAL)=K;						/* READ INFO TO COMPUTE PITCH CORRECTLY */				L =READ(MDI);						/* READ SAMPLING RATE FACTOR FOR FILE */				M =READ(MDI);						/* READ SET OCTAVE FACTOR FOR FILE */				N =READ(MDI);						/* READ FRACTIONAL PITCH OFFSET FOR TRANSPOSITION */				/* READ FILE VOLUME   */				/* READ TRANSPOSITION */				K=(K+PT.VOL-PT.SRATE);			/* MOVE POINTER TO FILE VOL FIELD */				WRITE(MAM)=PAR.PTR+SHR(K,8);				WRITE(MAL)=K;						/* READ INFO TO COMPUTE PITCH */				LOAD 0; WRITE(4)=READ(MDI);	/* COMPUTE FMPTR FOR FRACTIONAL MULTIPLY */				DIV 1001;				FMPTR=RES;							/* READ AND STORE FILE VOLUME IN TEMP, ADVANCE TO TRANSPOSITION FIELD */				IF (READ(MD)=0)					/* NO TRANSPOSITION - CORRECT TO SETOCTAVE VALUE */				THEN DO;					MRLCH=1024-M-L;				/* NO TRANSPOSITION - CORRECT TO SETOCTAVE VALUE */					WRITE("300")=READ(MDI);		/* POINT PAST TRANSPOSITION */				END;				ELSE DO;								/* USER SPECIFIED TRANSPOSITION */					MRLCH=(2816+1024)-COMPUTE.PATCH.XPOS(READ(MDI)&255)+N-L;				END;				IF READ(MD)<>0 THEN DO;			/* ADD IN SEMITONE CORRECTION */					IF READ(MD)<0 THEN DO;		/* PERFORM FAST SIGNED 32 BIT MATH HERE */						LOAD -READ(MD);			/* CONVERT TO FREQ INFO FROM SEMITONES * 100 */						MUL  1024;						WRITE("300")=RES;						DIV  1200;						MRLCH=MRLCH-RES;					END;					ELSE DO;						LOAD  READ(MD);						MUL  1024;						WRITE("300")=RES;						DIV  1200;						MRLCH=MRLCH+RES;					END;				END;				WRITE(MAM)=TBP;	/* *** RESTORE TIMBRE POINTER */			END;			ELSE DO;			/* NON-PATCH LIST TIMBRES */				WRITE("300")=ADDR(SSTAT);		/* ZERO OUT */				IF INC.POLY THEN DO;					RPC 4;					WRITE("360")=0;				/* SSTAT ISTAT FMPTR MRLCH */				END;				ELSE DO;					WRITE("360")=0; WRITE("360")=0;	/* SSTAT ISTAT */					WRITE("360")=0; WRITE("360")=0;	/* FMPTR MRLCH */				END;			END;			/* $PAGE - CHECK FOR DECAY, HARMONIC ADJUST */			IF (OPT&(ENV.DADJ\INX.HADJ))<>0	/* FIRST DO DECAY OR HARMONIC ADJUST */			THEN DO;									/* SO THAT ENVELOPE INFO IS COMPUTED CORRECTLY */				IF (OPT&ENV.DADJ)<>0 THEN DO;	/* COMPUTE DECAY ADJUST */					WRITE(MAL)=(TIM.DEC.ADJ+4)+(PTL*TIM.DEC.ADJ.STR);					I=READ(MD)-1000;				/* GET DIALED IN AMOUNT */					J=1000;										/* ASSUME NORMAL DECAY USED */					IF KEYN<72 THEN DO;						/* COMPUTE DECAY ADJUST FACTOR FOR C0-B5 ONLY */						LOAD KEYN; DIV 12; K=READ(5); L=READ(4);	/* GET OCTAVE & NOTE INFO */						IF K<5 THEN DO;						/* LOOK UP STARTING DECAY ADJUST FACTOR */							WRITE(MAL)=TIM.DEC.ADJ+K+(PTL*TIM.DEC.ADJ.STR);							J=READ(MD);						END;						ELSE J=1000;							/* START AT 1000 FOR UPPER OCTAVES */						LOAD 16000+I*DEC.ADJ.TAB(L);						MUL J; MWAIT; DIV 16000; J=RES;	/* SCALE RESULT */						IF J IGT 30000 THEN J=30000;		/* LIMIT DECAYS TO 30X DIALED IN  NUMBER */					END;					DADJ=J;										/* SAVE DECAY ADJUST PARAMETER */				END;				ELSE DADJ=0;									/* NO DECAY ADJUST */				IF (OPT&INX.HADJ)<>0							/* COMPUTE HARM ADJUST */				THEN CALL COMPUTE.HADJ;						/* COMPUTE HARMONIC ADJUST */				ELSE HADJ=0;									/* NO HARM ADJUST */			END;			ELSE DO;				DADJ=0;											/* NO DECAY ADJUST */				HADJ=0;											/* NO HARM  ADJUST */			END;			CURRF=PITCH;										/* ASSUME NO GLIDE */			DESTF=PITCH;										/* SET UP PITCH INFO */			IF (OPT&MIN.PTUNE)<>0 THEN DO;				/* USE CONSTANT PITCH IF DESIRED */				CURRF=2816;				DESTF=2816;			END;			PVIB=PTL&3;								/* SPACE OUT VIBRATO PROCESSING - VARIABLES ARE INITIALIZED LATER */			VIBWD=(-1);								/* QUICKLY INITIALIZE VIBRATO STUFF */			/* $PAGE - CHECK FOR DELAY FIELD */			/* NOTE: PRESERVE MAM POINTER TO TBP */			IF (OPT&ANY.DELAY)<>0				/* IF EITHER ENV OR INDEX IS DELAYED */			THEN CALL COMPUTE.DELAY;			/* THEN WE MUST COMPUTE INFO FOR SPECIAL QUES */			ELSE DO;									/* INITIALIZE DELAYS QUICKLY */				ETIMER=0;				ITIMER=0;			END;			IF (OPT&(ENV.DADJ\ENV.RTES))=0	/* IF NO DEC ADJ OR RTES */			THEN DO;									/* LOOK UP ATTACK INFO QUICKLY */				WRITE(MAL)=(TIM.EATLIM+EATLIM.LOC)+(PTL*TIM.EATLIM.STR);				WRITE("300")=ADDR(EATLIM);				WRITE("360")=READ(MDI);					/* EATLIM */				WRITE("360")=READ(MDI);					/* EATINT */				WRITE("360")=READ(MDI);					/* EIDLIM */				WRITE("360")=READ(MDI);					/* EIDINT */				WRITE("360")=READ(MDI);					/* ETMC   */			END;			ELSE CALL COMPUTE.ENV;						/* ELSE USE PROCEDURE CALL */			/* $PAGE - CHECK FOR FM */			IF (OPT&ANY.FM)<>0							/* IF ANY FM IN SOUND - COMPUTE STUFF */			THEN DO;											/* SET UP FOR FM COMPUTATIONS */				DO.FM=1;				IF (OPT&(ENV.DADJ\INX.HADJ\INX.RTES))=0	/* IF NO HARM ADJ OR INDEX RTE'S */				THEN DO;												/* COPY INDEX INFO QUICKLY */					WRITE(MAL)=(TIM.IATLIM+IATLIM.LOC)+(PTL*TIM.IATLIM.STR);					WRITE("300")=ADDR(IATLIM);					WRITE("360")=READ(MDI);					/* IATLIM */					WRITE("360")=READ(MDI);					/* IATINT */					WRITE("360")=READ(MDI);					/* IIDLIM */					WRITE("360")=READ(MDI);					/* IIDINT */					WRITE("360")=READ(MDI);					/* ITMC   */				END;				ELSE CALL COMPUTE.INX;			/* ELSE USE PROCEDURE CALL */			END;			ELSE DO;									/* NO FM IN SOUND */				ITIMER=ETIMER-1;					/* MAKE SURE DIFFERENT FROM ETIMER - SIMPLIFIES QUEING & INTERRUPT CODE */				DO.FM=0;								/* NO FM NEEDED */			END;			SET.HZ=1;								/* MUST SET HZ'S IF NOT PRE-COMPUTED */		END;		/* $PAGE - CHECK FOR GLIDE & REAL TIME EFFECTS. COMPUTE INITIAL STEREO POSITON. */		/* NOTE: MAM POINTER IS LOADED */		IF ((OPT&ANY.GLIDE)<>0)						/* PORTAMENTO CALLED FOR IN PARTIAL */		OR ((G.VAL        )<>0)						/* OR FOOT SWITCH ACTIVATED */		THEN DO;											/* GLIDE REQUIRED */		  CURRF=OUR.LAST.PITCH;						/* GET LAST PITCH FOR THIS TIMBRE */		  CALL COMPUTE.GLIDE;						/* SET UP GLIDE INFORMATION  */		  SET.HZ=1;										/* MUST RECOMPUTE HZ'S BELOW */		END;		IF  ( ((OPT&TUN.RTES)<>0)					/* AND RTES PATCHED TO TUNINGS */		OR    ((PWP         )<>0) )				/* OR PITCH WHEEL IS HELD */		THEN DO;											/* MUST LOOK FURTHER */			WRITE(MAL)=TIM.FMRATIO.LOOK;			IF READ(MD)<>0 THEN DO;				RRATO=SCALE(10000);					/* CHECK FOR RTE'S TO FM RATIO */				IF RRATO<>10000 THEN SET.HZ=1;			END;			WRITE(MAL)=TIM.CHORUS.LOOK;			IF READ(MD)<>0 THEN DO;				RCHOR=SCALE(10000);					/* CHECK FOR CHORUS ADJUST */				IF RCHOR<>10000 THEN SET.HZ=1;			END;			WRITE(MAL)=TIM.TUNING.LOOK;			IF  (READ(MD)<>(2+32+512+8192))				/* IF SOMETHING ELSE BESIDES PITCH WHEEL PATCHED IN */			OR  (PWP<>0)										/* OR IF PITCH WHEEL HELD */			THEN DO;												/* COMPUTE PITCH BEND OF PITCH WHEEL IS HELD */				WRITE(MAL)=TIM.TINFO.POINTER;				IF READ(MD)=0 THEN I=200;					/* USE 2.000 SEMITONES IF NO TINFO AREA */				ELSE DO;											/* LOOK UP TONE BEND DEPTH FOR TIMBRE */					I=READ(MD)+TI.TBD;					WRITE(MAM)=PAR.PTR+SHR(I,8); WRITE(MAL)=I;					I=READ(MD);					WRITE(MAM)=TBP;				END;				LOAD I; MUL 1024; I=RES; DIV 1200;		/* SCALE FOR 12.00 SEMITONES PER OCTAVE */				I=RES;				WRITE(MAL)=TIM.TUNING.LOOK;				CALL SCALE(I);									/* SCALE FOR TONE BEND SENS */				RTUNG=SIGNED.SCALE;							/* LOOK UP SIGNED RESULT HERE */				IF RTUNG<>0 THEN SET.HZ=1;					/* MUST SET HZ BELOW */			END;													/* ELSE LEAVE RTUNG AT ZERO */		END;		/* NOTE: MAM POINTER LOST BY COMPUTE.STEREO CALL  */		IF (OPT&ANY.STAM)<>0									/* QUICKLY SEE IF ANY STEREO/AM */		THEN DO;			ST.INFO=COMPUTE.STEREO;							/* CALL PROCEDURE IF COMPLICATED */		END;		ELSE DO;													/* QUICKLY SET TO MIDDLE IF NO STEREO/AM */			IF MONO_VOICES_PRESENT THEN ST.INFO=256;	/* SET TO RIGHT IF MONO VOICES */			ELSE DO;				WRITE(MAL)=TIM.INIT.STPOS+PTL;				ST.INFO=READ(MD);			END;			AVOL=SHL(RVOL,8);		END;		SPLICER=0;												/* ASSUME NO SPLICING */		IF (OPT&SPLICE.INFO)<>0		THEN SPLICER=1;										/* FRAME SPLICING IS ACTIVE */		/* $PAGE - COMPUTE SYNTHESIZER-SPECIFIC INFORMATION */		IF  ((INC.MONO=0)										/* IF NO SAMPLING AT ALL */		AND  (INC.POLY=0))		OR (SYNTYP  =  TIM#FM ) THEN DO;					/* OR ORIGINAL SYNTHESIZER - COMPUTE ITEMS */			IF ST.INFO=256 THEN ST.INFO=255;				/* LIMIT TO HARDWARE MAX */			WRITE(MAM)=TBP;			WRITE(MAL)=TIM.I.ISHC+PTL;			ST.INFO=(ST.INFO&"374")\READ(MD);			/* OR IN INDEX SHC       */			IF NORIG<>0 THEN DO;								/* SEQUENCER NOTE - LOAD VOLUME REGISTER 2 MSEC EARLY FOR BEST RESULTS */				STIMER=STIMER-SEQ.SPL.TIM;					/* BUT LEAVE ETIMER & ITIMER FOR LATER DELAY */				QSTAT=SHL(SEQ.FM1,8) + SEQ.FM2;			/* SET QSTAT; SAVE ORIGINAL VALUE IN CASE SPEED SETTING CHANGES */			END;													/* INTERRUPT CODE TO SET */			ELSE DO;												/* BACK UP ETIMER        */				ETIMER=ETIMER-KBD.SPL.TIM;					/* TO CONSTRUCT SPLICE   */				ITIMER=ITIMER-KBD.SPL.TIM;				QSTAT=SHL(KBD.FM1,8) + KBD.FM2;			/* SET QUE STATE TO TELL */			END;		END;										/* OF ORIGINAL SYNCLAV CASE */		ELSE IF (INC.MONO  <>  0)		AND     (SYNTYP=TIM#MONO)		THEN DO;									/* MONO SAMPLING (W. DISK) */			IF NORIG<>0 THEN DO;				/* SEQUENCER NOTE - REDUCE DELAY SO WE CUT OFF NOTES EARLY TO MAKE SPLICE */				ISTAT=1;							/* SEQUENCER NOTE - DELAY 15 MSEC FOR SPLICE */				STIMER=STIMER-SEQ.MONO3;	/* BACK UP STIMER FOR SPLICE & LOAD */				QSTAT=SEQ.MONO3;				/* SET QSTAT; SAVE ORIGINAL VALUE IN CASE SPEED SETTING CHANGES */			END;			ELSE DO;								/* KEYBOARD NOTE */				ISTAT=0;				ETIMER=ETIMER-KBD.MONO3;				ITIMER=ITIMER-KBD.MONO3;				QSTAT=KBD.MONO3;			END;			STOP.MONO.IO=0;					/* ALLOW NEW NOTES AFTER CALL TO STOP.DISK */			PPTMB=KEYN+XPOSDIST;				/* SAVE TRANSPOSED KEY# TO GET CORRECT SND FILE */		END;		ELSE IF (INC.POLY<>0) THEN DO;	/* MEANS POLY SYNTH    */			SSTAT = OUR.VOL;					/* SAVE VOL INFO       */			WRITE(MAM)=THP;					/* PASS MULTI ROUTING  */			WRITE(MAL)=THD.TROU;				/* TO INTERRUPT RTN    */			ISTAT = READ(MD);					/* IN ISTAT            */			IF (ITMC&BASE#STEREO_B)<>0 THEN DO;	/* STEREO SOUND FILE - CHECK DEFAULT SETTING OF PAN */				IF ((OPT&ANY.STAM)=0)		/* IF NO STEREO/AM     */				AND (ST.INFO=128)				/* AND CENTERED        */				THEN ST.INFO=0;				/* THEN APPLY FULL PAN */			END;			IF SYNTYP=TIM#POLY THEN DO;	/* PATCH LIST PARTIAL */				PPTMB=KEYN+XPOSDIST;			/* SAVE TRANSPOSED KEY# TO GET CORRECT SND FILE */				IF NORIG<>0 THEN DO;			/* SEQUENCER NOTE - START 5 MS EARLY FOR CORRECT SPLICE */					STIMER=STIMER-SEQ.SPL.TIM;					QSTAT=SEQ.SPL.TIM;		/* SET QSTAT; SAVE ORIGINAL VALUE IN CASE SPEED SETTING CHANGES */				END;				ELSE DO;					ETIMER=ETIMER-KBD.SPL.TIM;					ITIMER=ITIMER-KBD.SPL.TIM;					QSTAT=KBD.SPL.TIM;				END;			END;			ELSE DO;				IF POLY.SPLICE THEN DO; END;			END;		END;		/* $PAGE - ALLOCATE CHANNEL FOR NEW NOTE */		/* BEGIN BY SEEING IF STOLEN CHANNELS WILL DO THE JOB */		/* NOTE: MAM POINTER IS UNDEFINED HERE */		GET.NEXT.CHAN:;								/* RE-ENTER FROM BELOW TO GET CHORUS CHANNELS */		IF TEMP.LIST(0) > (TEMP.PTR+SPLICER)	/* IF ENOUGH STOLEN CHANNELS FOR THE JOB */		THEN DO;											/* THEN LOOK FURTHER */			NEWCH=TEMP.LIST(TEMP.PTR+1);			/* GET NEXT FREE CHANNEL ON TEMP LIST */			IF  ((NEWCH&B.SPLICE)=0)				/* IF WAS NOT A SPLICE CHANNEL (INDICATES GROSS ERROR WITH KBD ENVELOPE) */			THEN DO;										/* LOOK FURTHER IF FIRST ONE WAS NOT A SPLICER */				IF (NEWCH=0) THEN DO;				/* OOPS - ZERO - MEANS STOLEN MIDI PARTIAL BLOCK - IGNORE CHANNEL */					TEMP.PTR=TEMP.PTR+1;				/* INCREMENT TO WHERE MCHN ENTRY WAS - MATCHES GHOST.LIST NOW */					IF GHOST.LIST(TEMP.PTR)<>0		/* SEE IF GHOST BLOCK ATTACHED */					THEN DO;										/* GHOST BLOCK ON MIDI-ONLY PARTIAL BLOCK */						MIDIGHOST=GHOST.LIST(TEMP.PTR);	/* SAVE FOR LATER ALLOCATION */						GHOST.LIST(TEMP.PTR)=0;				/* OF MIDI-ONLY BLOCK */					END;											/* NOTE: ONLY ONE ALLOWED */					GOTO GET.NEXT.CHAN;				END;				IF (SPLICER=0)							/* IF NO SPLICING NEEDED */				OR ((TEMP.LIST(TEMP.PTR+2)&B.SPLICE)<>0)	/* OR SECOND ONE IS INDEED A SPLICING CHANNEL */				THEN DO;										/* THEN CONTINUE FURTHER */					IF SYNTYP=TIM#FM THEN DO;			/* ORIGINAL SYNTHESIZER NEEDED */						IF (NEWCH&(B.MONO\B.POLY))=0	/* IF STOLEN CHANNEL ALSO FROM ORIGINAL SYNTH */						THEN DO;								/* THEN CHANNEL MATCHES */							WRITE(MAM)=TBP;							WRITE(MAL)=TIM.CAN.USE.BOTH+PTL;							IF READ(MD)<>0 THEN I=ADDR(NUME);	/* ONE FROM EITHER */							ELSE DO;							/* MAKE SURE THIS LSYN CAN MAKE SOUND */								IF (NEWCH&255)<LSYN1.END THEN DO;									I=ADDR(NUM1);			/* CHANNEL FROM LSYN1 */									WRITE(MAL)=TIM.WMEM#+PTL;									IF (READ(MD)&255)=0	/* IF NO WAVE MEMORY */									THEN DO;					/* (HAPPENS DURING OVERLOAD) WITH ABSURD KEYBOARD ENVELOPE */										NEWCH=NEWCH\B.SOUNDING;	/* USE EXISTING, HOPEFULLY USEFUL WAVE MEMORY IF NOT AVAIL */										IF SPLICER<>0 THEN TEMP.LIST(TEMP.PTR+2)=TEMP.LIST(TEMP.PTR+2)\B.SOUNDING;									END;								END;								ELSE DO;									I=ADDR(NUM2);			/* FROM LSYN2 */									WRITE(MAL)=TIM.WMEM#+PTL;									IF (READ(MD)&"177400")=0									THEN DO;					/* (HAPPENS DURING OVERLOAD) */										NEWCH=NEWCH\B.SOUNDING;	/* USE EXISTING, HOPEFULLY USEFUL WAVE MEMORY IF NOT AVAIL */										IF SPLICER<>0 THEN TEMP.LIST(TEMP.PTR+2)=TEMP.LIST(TEMP.PTR+2)\B.SOUNDING;									END;								END;							END;							MCHN=NEWCH;		/* STORE IN MCHN, MAKE MCHN NONZERO */						END;					/* CHANNEL MATCHES */					END;						/* ORIGINAL SYNTHESIZER CALLED FOR */					ELSE IF SYNTYP=TIM#MONO THEN DO;	/* MONO SAMPLING NEEDED */						IF (NEWCH&B.MONO)<>0				/* IF STOLEN CHANNEL ALSO FROM MONO SYNTH */						THEN DO;							I=ADDR(NUMM);					/* ACCOUNT FOR A MONO CHANNEL */							MCHN=NEWCH;						END;		/* CHANNELS MATCH */					END;			/* MONO SAMPLING  */					ELSE DO;									/* POLY SAMPLING */						IF  ((NEWCH&B.POLY)<>0)			/* POLY */						AND (((SHL(NEWCH,8) XOR ITMC) AND BASE#BIN_B) = 0)						THEN DO;							/* NEXT LINE IS A QUICKER: "I=ADDR(NUMP0)+SHR(ITMC,BASE#BIN_P);" */							I=ADDR(NUMP0)+(ROT(ITMC,2)&"3");		/* ACCOUNT FOR A POLY CHANNEL */							IF (ITMC&BASE#STEREO_B)<>0 THEN DO;	/* SEE IF WE NEED A STEREO SOUND FILE */								IF (NEWCH&B.STEREO)<>0				/* STOLEN ONE IS ALSO STEREO - OK TO USE IT */								THEN DO;									MCHN=NEWCH;									CORE(I) =CORE(I)-1;	/* ACCOUNT FOR ONE CHANNEL HERE */									UCHN=MCHN+1;			/* SET UCHN                     */								END;							END;							ELSE DO;								IF (NEWCH&B.STEREO)=0	/* USE NON-STEREO CHANNEL IF NON-STEREO NEEDED */								THEN MCHN=NEWCH;							END;						END;	/* CHANNELS MATCH */					END;	/* POLY SAMPLING */				END;	/* SPLICING CHANNEL IS VALID */			END;	/* VALID FIRST CHANNEL */		END;	/* ENOUGH STOLEN CHANNELS */		/* $PAGE - ALLOCATE SPLICE CHANNEL */		IF MCHN<>0 THEN DO;			/* STOLEN CHANNELS WERE USABLE */			TEMP.PTR=TEMP.PTR+1;		/* INCREMENT TO WHERE MCHN ENTRY WAS - MATCHES GHOST.LIST NOW */			IF GHOST.LIST(TEMP.PTR)<>0			/* SEE IF GHOST BLOCK ATTACHED */			THEN DO;				GFPTR=GHOST.LIST(TEMP.PTR);	/* LINK PRIOR PARTIAL BLOCK AS GHOST POINTER TO US */				GHOST.LIST(TEMP.PTR)=0;			END;			IF SPLICER=0 THEN DO;	/* NO SPLICING - JUST ACCOUNT */				CORE(I) =CORE(I)-1;	/* ACCOUNT FOR ONE CHANNEL ALLOCATED */			END;			ELSE DO;						/* SPLICE CHANNEL NEEDED AS WELL */				TEMP.PTR=TEMP.PTR+1;	/* ADVANCE TEMP POINTER A SECOND TIME */				CORE(I) =CORE(I)-2;	/* ACCOUNT FOR TWO CHANNELS ALLOCATED */				SMCHN=TEMP.LIST(TEMP.PTR)&(NOT(B.SPLICE));	/* USE STOLEN SPLICE CHANEL, BUT CLEAR SPLICE BIT */			END;		END;		ELSE DO;								/* NO STOLEN CHANNELS WOULD DO IT - GET NEW CHANNELS */			IF SYNTYP=TIM#FM THEN DO;	/* ORIGINAL SYNTHESIZER */				WRITE(MAM)=TBP;				WRITE(MAL)=TIM.CAN.USE.BOTH+PTL;				IF READ(MD)<>0 THEN DO;	/* IF PARTIAL CAN BE CREATED IN EITHER LOGICAL SYNTHESIZER - SEE WHICH AS MORE FREE CHANNELS */					IF (CORE(FR1.PTR)-NUM1)<(CORE(FR2.PTR)-NUM2) THEN DO;	/* TRY TO USE FR2 IF MORE AVAILABLE THERE */						I=FR2.PTR; IF CORE(I)=0 THEN I=FR1.PTR;					END;					ELSE DO;	/* PREFERRED WOULD BE FR1 */						I=FR1.PTR; IF CORE(I)=0 THEN I=FR2.PTR;	/* BUT TRY FR2 AS LAST DITCH */					END;					J=ADDR(NUME);	/* SAVE POINTER TO WORD TO DECREMENT */				END;				ELSE DO;					WRITE(MAL)=TIM.WMEM#+PTL;					IF (READ(MD)&255)<>0					THEN DO; I=FR1.PTR; J=ADDR(NUM1); END;					ELSE DO; I=FR2.PTR; J=ADDR(NUM2); END;				END;				MCHN=CORE(I+CORE(I));		/* GET CHANNEL TO USE FROM FREE LIST */			END;			ELSE IF SYNTYP=TIM#MONO THEN DO;	/* MONO SAMPLING */				I=FRM.PTR; J=ADDR(NUMM);				MCHN=CORE(I+CORE(I));		/* GET CHANNEL TO USE FROM FREE LIST */			END;			ELSE DO;								/* POLY SAMPLING */				BIN=ROT(ITMC,2)&"3";			/* GET WHICH POLY BIN - FAST "BIN=SHR(ITMC,BASE#BIN_P)" */				I=CORE(ADDR(FP0.PTR)+BIN);	/* POINT AT CORRECT FREE CHANNEL LIST */				J=ADDR(NUMP0)+BIN;			/* POINT AT NUM VOICES REQUIRED IN THIS BIN */				IF (ITMC&BASE#STEREO_B)<>0 THEN DO;	/* STEREO SOUND FILE - LOOK FOR 2 CHANNELS */					K=CORE(I);					/* NUMBER OF FREE POLY CHANS     */					IF K>=2 THEN DO;			/* LOOK AT LIST IF TWO AVAILABLE */						L=CORE(I+K-1);			/* SECOND TO THE TOP             */						M=CORE(I+K  );			/* TOP MOST FREE CHANNEL         */						IF (M<>(L+1))			/* IF CHANNELS ARE OUT OF ORDER  */						OR ((L&1)<>0)			/* OR MASTER IS NOT EVEN         */						THEN DO;					/* THEN LOOK FOR MATCHED PAIR    */							N=K;					/* SAVE ORIGINAL # OF FREE CHANS */							DO WHILE (M<>(L+1))							OR       ((L&1)<>0);								K=K-1;			/* BACK UP ONE                   */								IF K=1 THEN DO;/* NONE FOUND THIS TIME          */									CALL ABORT.NOTE; RETURN;								END;								M=L;				/* BACK DOWN ONE ON LIST         */								L=CORE(I+K-1);	/* LOOK UP THIRD (ETC) FREE CHAN */							END;							CORE(I+K-1)=CORE(I+N);	/* SWAP TOP WITH K-1       */							CORE(I+K  )=CORE(I+N-1);	/* SWAP HERE ALWAYS, BUT IS A NULL OPERATION IF ONLY ONE ABOVE US */						END;						MCHN=L\B.STEREO;						UCHN=M\B.STEREO;						CORE(J)=CORE(J)-1;			/* DECREMENT NUMPn; n=0 to 3 */						CORE(I)=CORE(I)-1;			/* ACCOUNT FOR 1 HERE        */					END;					ELSE DO;								/* STEREO IS NEEDED, BUT ONLY ONE CHAN AVAILABLE */						CALL ABORT.NOTE; RETURN;	/* SOLLY, CHOLLY (CHAN) */					END;				END;				ELSE DO;					MCHN=CORE(I+CORE(I));			/* GET CHANNEL TO USE FROM FREE LIST */				END;			END;			CORE(J)=CORE(J)-1;			/* DECREMENT NUME, NUM1, NUM2, NUMP0-3, NUMM AS APPROPRIATE */			IF CORE(I)=0 THEN DO;				CALL ABORT.NOTE; RETURN;			END;								/* FINALLY RAN OUT OF CHANNELS */			CORE(I)=CORE(I)-1;			/* INDICATE ONE LESS FREE CHANNEL FROM THIS LOGICAL SYNTHESIZER */			/* $PAGE - GET SPLICE CHANNEL HERE */			IF SPLICER<>0 THEN DO;		/* SPLICE CHANNEL NEEDED - GET IT */				IF CORE(I)=0 THEN DO;	/* NO CHANNELS LEFT FOR SPLICING */					IF      I=FR1.PTR THEN I=FR2.PTR;	/* TRY OTHER LSYN SO NOTE WILL SOUND */					ELSE IF I=FR2.PTR THEN I=FR1.PTR;	/* EVEN IF FROM OTHER PSYNTH */					IF CORE(I)=0 THEN DO;					/* NO CHANNELS LEFT ON EITHER SYNTH */						CALL ABORT.NOTE;						RETURN;					END;						/* FINALLY OUT OF CHANNELS */				END;				ELSE IF SYNTYP=TIM#FM THEN DO;	/* SORT CHANNELS INTO SAME PHYS SYNTH IF ORIGINAL SYNTH - UNLESS STEALING FROM OTHER SYNTH */					IF (CORE(I+CORE(I))&"360")<>(MCHN&"360") THEN DO;	/* OOPS - WOULD BE DIFFERENT SYNTH */						K=CORE(I)-1;			/* LOOK FOR FREE CHANNEL IN SAME SYNTHESIZER - GET # OF FREE CHANNELS -1 */						L=MCHN&"360";			/* GET PHYSICAL SYNTH INTO CONVENIENT VARIABLE FOR COMPARE */						DO WHILE K<>0;			/* NOTE QUICK INTERNAL EXIT FROM LOOP */							IF (CORE(I+K)&"360")=L THEN DO;	/* SEE IF NEXT FREE CHANNEL ON STACK SAME PSYN AS MCHN */								L=CORE(I+K); CORE(I+K)=CORE(I+CORE(I));								CORE(I+CORE(I))=L;	/* SWAP CHANNELS ON STACK */								K=0;						/* EXIT LOOP */							END;							ELSE IF (CORE(I+K)&"360")=(CORE(I+CORE(I))&"360") THEN DO;	/* ALSO CHECK FOR TWO FREE CHANNELS IN SAME SYNTH ON FREE STACK */								L=CORE(I+K); CORE(I+K)=MCHN;	/* PUT MCHN BACK ON STACK */								MCHN=L;					/* SWAP WITH CHANNEL GOTTEN ABOVE */								K=0;						/* EXIT LOOP */							END;							ELSE K=K-1;					/* TRY NEXT CHANNEL ON STACK */						END;	/* OF SORT LOOP */					END;		/* OF BEGIN IF PSYNS DON'T MATCH  */				END;			/* OF SORT CHECK IF SYNTYP=TIM#FM */				CORE(J)=CORE(J)-1;		/* DECREMENT NUME,NUM1,NUM2 AS APPROPRIATE */				SMCHN=CORE(I+CORE(I));	/* GET CHANNEL TO USE */				CORE(I)=CORE(I)-1;		/* REMOVE CHANNEL FROM LIST */			END;	/* OF SPLICE CHANNEL NEEDED */		END;		/* OF MUST GET NEW CHANNELS (NO OR NOT ENOUGH STOLEN ONES) */		IF DIAGNOSTICS.ENABLED<>0 THEN DO;			/* XXXX PROGRAM - CREATE CHANNEL NUMBER */			IF  ((INC.MONO=0)								/* IF NO SAMPLING AT ALL */			AND  (INC.POLY=0))			OR (MCHN&(B.MONO\B.POLY))=0 THEN DO;	/* OR ORIGINAL SYNTHESIZER */				MCHN=(MCHN&"177400")+SHL(XXXXCH,1);			END;			ELSE IF (INC.POLY<>0)	/* CHECK FOR POLY */			AND ((MCHN&B.POLY)<>0)			THEN DO;				I=SHR(XXXXCH,5)&"3";	/* GET BIN # */				MCHN=(MCHN&"177400")+(I*64)+(XXXXCH&"37");	/* VOICE = (BIN# * 64) + (VOICE# MOD 32) */			END;		END;		IF SPLICER<>0 THEN DO;			I=PTPTR+(NUM.PARAMS+P.E.SEG.RND);			WRITE(MAM)=PAR.PTR+SHR(I,8); WRITE(MAL)=I;			IF READ(MD)<>0 THEN DO;	/* PITCH RANDOMNESS SPECIFIED */				DESTF=DESTF+READ(MD)*RANDOM.LIST(RAN.PTR)/75;	/* COMPUTE RANDOM DISTANCE */				CURRF=DESTF;				RAN.PTR=(RAN.PTR+1)&15;				SET.HZ=1;				/* MUST DO HZ'S BELOW */			END;		END;		/* $PAGE - LOAD INITIAL INFO (VOLUME, STEREO) INTO SYNTH */		IF SET.HZ<>0 THEN DO;			 CALL SETUP.FRQS;								/* COMPUTE HZ INFO IF REQUIRED (AFTER!! CHANNEL ALLOCATION) */			  ANY.HZ.SET = TRUE;		 END;		IF  ((INC.MONO=0)									/* IF NO SAMPLING AT ALL */		AND  (INC.POLY=0))		OR  (MCHN&(B.MONO\B.POLY))=0 THEN DO;		/* OR ORIGINAL SYNTHESIZER - COMPUTE ITEMS */			UCHN=MCHN+1;									/* USER CHANNEL IS MCHN+1 */			IF MULTI.THERE<>0 THEN DO;					/* INITIALIZE MULTI STUFF */				WRITE(MAM)=THP;				WRITE(MAL)=THD.TROU;				I=READ(MD);									/* GET L & R ROUTING (WITH ON BIT SET) */				J=SHL(I,8);									/* GET RIGHT ROUTING (IN LOWER HALF) */				I=I&"177400";								/* GET LEFT  ROUTING (IN UPPER HALF) */				K=SHR(MCHN&255,1);						/* GET CHAN ID       */				DISABLE;				WRITE(D32)="21";							/* SELECT MULTI I/O  */				WRITE(MAM) = MFM.PTR;					/* POINT AT MULTI->FM MAP */				WRITE(MAL) = K;							/* WORD OFFSET */				WRITE(D33)=I\(SHR(READ(MD),8));		/* ROUTE LEFT INPUT TO LEFT OUTPUT */				WRITE(D33)=J\(READ(MD)&255);			/* ROUTE RITE INPUT TO RITE OUTPUT */				IF (SMCHN<>0) THEN DO;					/* SET UP INITIAL VOLUME & STEREO POSITION INFO, PLUS INITIAL WAVESHAPE */					SUCHN=SMCHN+1;							/* COMPUTE SPLICING USER CHANEL */					WRITE(MAL)=SHR(SMCHN&255,1);		/* SPLICE CHANNEL */					WRITE(D33)=I\(SHR(READ(MD),8));	/* ROUTE LEFT INPUT TO LEFT OUTPUT */					WRITE(D33)=J\(READ(MD)&255);		/* ROUTE RITE INPUT TO RITE OUTPUT */				END;				ENABLE;			END;			ELSE IF (SMCHN<>0) THEN DO;				SUCHN=SMCHN+1;								/* COMPUTE SPLICING USER CHANEL */			END;			WRITE(MAM)=TBP;			WRITE(MAL)=TIM.WMEM#+PTL;			IF (MCHN&255)<LSYN1.END			THEN FMINFO=SHL(READ(MD),8)\ST.INFO;	/* SELECT MEMORY */			ELSE FMINFO=(READ(MD)&"177400")\ST.INFO;			LOAD OUR.VOL; MUL AVOL; SUPR=READ(4);	/* COMPUTE INITIAL VOLUME - STORE IN SUPR FOR INTERRRUPT ROUTINE */			IF (OUR.VOL=0)\(RVOL=0)			THEN CALL SUPPRESS;		/* STOP OUTPUT - MUST SILENCE POSSIBLY STOLEN CHANNEL */		END;								/* OF ORIGINAL SYNCLAV CASE */		/* $PAGE - INITIALIZE FOR MONO OR POLY SYNTH */		ELSE BEGIN;						/* FOR MONO OR POLY - GET INFO */			IF (INC.MONO<>0)&((MCHN&B.MONO)<>0) THEN DO;	/* MONO SAMPLING (W. DISK) */				IF (UNNM=MIN.SAMP)			/* CHECK FOR OUT OF RANGE AT NOTE START ONLY */				OR (UNNM=MAX.SAMP)				THEN DO;							/* SAMPLING RATE OUT OF RANGE */					CALL RANGE.ERROR;			/* DISPLAY ERROR MESSAGE */					ISTAT=2;						/* FOR NOW, KEEP NOTE FROM HAPPENING */				END;				LOAD OUR.VOL; MUL AVOL;		/* COMPUTE AM AND OVERALL VOLUME */				LOAD READ(4); MUL FMPTR;	/* SCALE BY FILE VOLUME          */				IDAT=READ(4);					/* SAVE FOR INTERRUPT ROUTINE    */			END;			ELSE IF (INC.POLY<>0) THEN DO;			/* MEANS POLY SYNTH   */				IDAT=ST.INFO;								/* SAVE STEREO INFO FOR VOLUME WRITES */			END;		END;					/* OF MONO OR POLY SAMPLING */		/* PAGE - CHECK FOR CHORUS BLOCKS THAT FOLLOW */		IF PFPTR<>0 THEN DO;							/* ANOTHER BLOCK ON QUE? */			I=PPTR;										/* SAVE LAST POINTER     */			PPTR=PFPTR;									/* GET NEXT BLOCK        */			IF PLOG<>0 THEN DO;						/* MEANS THIS IS CHORUS BLOCK */				IF INC.POLY OR (MODC<>0) THEN DO;	/* COPY INFO IN   */	/* COPY OVER   */					WRITE("313")=I+PANRLOC;				/* SOURCE POINTER */	/* PANR - ETMC */					WRITE("300")=PPTR+PANRLOC;			/* DEST   POINTER */	/* FOR SPEEDY  */					RPC 46;									/* COPY OVER INFO */	/* NOTE STARTS */					WRITE("360")=READ("373");				END;				ELSE DO;										/* MOD B        */					WRITE("313")=I+PANRLOC;				/* SOURCE POINTER */	/* PANR - ETMC */					WRITE("300")=PPTR+PANRLOC;			/* DEST   POINTER */	/* FOR SPEEDY  */					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373"); WRITE("360")=READ("373");					WRITE("360")=READ("373"); WRITE("360")=READ("373");				END;				IF PLOG=2 THEN DO;		/* READ IN CHORUS HZ FROM EX MEM */					IF SET.HZ=0 THEN DO;	/* ONLY IF NOT SET ABOVE, THO!   */						LOAD PTL;								/* D5 = PARTIAL # (0- 7) */						WRITE(4)=KEYN;							/* D4 = KEY     # (0-84) */						MUL NUM.KEYS;							/* PARTIAL*NUM.KEYS+KEYN */						WRITE(4)=KBD.PRE.STR1;				/* ADD IN KBD.PRE.STR1   */						MUL KBD.PRE.STR;						/* MULT BY TABLE STRIDE  */						WRITE(MAM)=KBD.PRE+SHR(RES,8);						WRITE(MAL)=RES;						WRITE("300")=ADDR(UONU);						WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);						WRITE("210")=1;			/* IM(1) TO ADD0 - SKIP DO.FM */						WRITE("360")=READ(MDI); WRITE("360")=READ(MDI); WRITE("360")=READ(MDI);					END;					PLOG=TIM.LOG.CH;	/* SET PLOG POINTER */				END;				/* $PAGE - EXTRACT PARTIAL CHORUS FREQUENCY INFO QUICKLY */				ELSE DO;						/* MUST SHIFT OVER PCHORUS HZ */					IF SET.HZ=0 THEN DO;	/* ONLY IF NOT COMPUTED THO   */						/* PERFORM FAST SHIFT RIGHT OF UONU, UNNM, UINC   */						WRITE("313")=ADDR(UONU);	/* PERFORM FAST BYTE SWAP ON 6 WORDS */						WRITE("301")=READ("353");	/* MR13 TO R1      */						WRITE("261")=0;				/* IM(0) TO BSOR 1 */						WRITE("373")=READ("301");	/* R1 TO MR13I     */						WRITE("301")=READ("353");	/* MR13 TO R1      */						WRITE("261")=0;				/* IM(0) TO BSOR 1 */						WRITE("373")=READ("301");	/* R1 TO MR13I     */						WRITE("301")=READ("353");	/* MR13 TO R1      */						WRITE("261")=0;				/* IM(0) TO BSOR 1 */						WRITE("373")=READ("301");	/* R1 TO MR13I     */						/* PERFORM FAST SHIFT RIGHT OF MONU, MNNM, MINC */						/* FOR FM VOICES:                               */						IF SYNTYP=TIM#FM THEN DO;		/* FM ONLY       */							WRITE("324")=READ("333");	/* R13I TO ATNV - SKIP DO.FM */							WRITE("301")=READ("353");	/* MR13 TO R1      */							WRITE("261")=0;				/* IM(0) TO BSOR 1 */							WRITE("373")=READ("301");	/* R1 TO MR13I     */							WRITE("301")=READ("353");	/* MR13 TO R1      */							WRITE("261")=0;				/* IM(0) TO BSOR 1 */							WRITE("373")=READ("301");	/* R1 TO MR13I     */							WRITE("301")=READ("353");	/* MR13 TO R1      */							WRITE("261")=0;				/* IM(0) TO BSOR 1 */							WRITE("373")=READ("301");	/* R1 TO MR13I     */						END;					END;					IF PLOG=1					THEN PLOG=TIM.LOG.NCH  +PTL;					ELSE PLOG=TIM.LOG.NCHCH+PTL;				END;				GOTO GET.NEXT.CHAN;		/* GET CHANNEL, WRITE INFO */			END;			GOTO NEXT.BLOCK;				/* NOT A CHORUS BLOCK - SET IT UP */		END;									/* OF PFPTR<>0 BEGIN */	END;										/* OF PPTR<>0 BEGIN */