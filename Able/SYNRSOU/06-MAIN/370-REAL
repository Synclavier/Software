/*	:SYNRSOU:06-MAIN:370-REAL - APPLY REAL TIME CHANGES TO SOUND	*/

/*
Modified:
1998/07/09 - TY  - Commented out Pseudo-log function used for RTE inversion,
						 and replaced it with linear inversion.
1990/09/07 - TSS - ENHANCED PRESSURE CODE TO SUPPORT REV 2 TRIPP KBD
1990/05/04 - PF  - ALLOW ECHO OF MIDI PRESSURE
1989/06/14 - TSS - ADDED CODE TO RUN PRESSURE CALIBRATION STUFF
1989/06/05 - TSS - ADDED CODE TO MAP PRESSURE TO VOLUME THRU LOOKUP TABLES
1989/03/19 - TS  - MADE CHECK FOR POWER.OFF IN PRESSURE SCAN
1988/04/13 - PF  - MODIFIED PRESSURE ROUTINES TO ALLOW FOR MULTI RECORDING
1986/12/15 -CJ,EG- FIXED FMIMFO BUG
1986/11/17 - CJ  - ADDED CHANGES FOR TIM.TVOL.LOOK
1986/07/15 - CJ  - CHECKED RECORDING OF PRESSURE
1986/07/13 - CJ  - ADDED NORIG
1986/06/12 - TSS - Changes related to RECP
1986/05/15 - "official" creation of release-M modules
*/

/*	NOW PROCESS NOTES:

	1.	CHECK FOR CHANGING GUITAR PITCH
	2.	CHECK FOR PRESSURE CHANGE (VK)
	3.	UPDATE ACTIVE NOTES FOR REAL TIME EFFECTS CHANGES (EITHER
		LIVE OR RECORDED)	*/

BEGIN;

	/*	CHECK FOR GUITAR				*/
	/*	PITCH, VOLUME, RTE CHANGES	*/

	IF (INC.AXE=0)\(GDATA=0) THEN DO;	/*	KEYBOARD NOTE OR SEQUENCER NOTE	*/
		IF INC.AXE<>0 THEN NEW.GPITCH=0;	/*	INITIALIZE FOR NO NEW GUITAR PITCH	*/
		NEW.BEND=0;								/*	INITIALIZE FOR NO NEW PITCH INFO	*/
	END;

	ELSE DO;											/*	LIVE GUITAR NOTE - CHECK FOR NEW PITCH, VOLUME, RTE KNOB	*/
		NEW.GPITCH=0; NEW.BEND=0;				/*	ASSUME NO NEW PITCH .  OBVIOUSLY NO KEYBOARD TONE BEND	*/
		J=GDATA&255;								/*	EXTRACT STRING NUMBER	*/
		K=C.PER(J);L=C.VOL(J);					/*	GET CURRENT PERIOD & VOLUME FOR THIS STRING	*/
		IF (NSTAT=0)&(((NEW.STRING.DECAYS\NEXT.STRING.DONE)&BITS(J))=0)
		THEN DO;	/*	ACTIVE NOTE - CHECK FOR PITCH CHANGING. MUST CHECK STRING.DONE IN CASE COMPUTER IS LATE	*/
			I=NEW.GVOL;								/*	EMIT UPDATE RECORD IF VOLUME CHANGE (ALWAYS, FOR NOW (UGH!!!)	*/

			K=COMPUTE.GTPITCH(J,K);				/*	COMPUTE NEW GUITAR PITCH	*/
			IF (K<>GPITCH) THEN DO;				/*	NEW GUITAR PITCH DETECTED - SAVE INFO FOR LATER UPDATE RECORD NEEDED	*/
				I=1;          N=K-GPITCH;
				NEW.GPITCH=1; GPITCH=K;
				KEYN=EQUIV.KBD.KEY;
			END;
			ELSE N=0;	/*	NO PITCH CHANGE - MUST ZERO N IN CASE UPDATE RECORD NEEDED FOR OTHER REASONS	*/

			M=SHR(GDATA,8);						/*	CHECK FOR LARGER PEAK VOLUME - GET CURRENTLY ACTIVE PEAK	*/
			WRITE(5)=M; WRITE(6)="020000"; M=M+READ(4);	/*	COMPUTE 12% LARGER CHANGE	*/
			IF ((L>M) AND (VTRACK<>0))			/*	IF NEW PEAK VOLUME AND IN VOLUME TRACK MODE	*/
			OR ((FOLLOW.GUITAR)					/*	OR IF IN FOLLOW MODE ON LIVE TRACK	*/
			AND ((SHR(L,1)<>SHR(GDATA,9)) OR ((L<64) AND (L<>SHR(GDATA,8)))))	/*	AND VOL CHANGE	*/
			THEN DO;		/*	PROCESS NEW VOLUME	*/
				I=1;		/*	SET FLAG TO EMIT UPDATE RECORD	*/
				SBITS=(SBITS&255)\SHL(L,8);	/*	STORE NEW VOLUME IN NOTE BLOCK	*/
				GDATA=SHL(L,8)\J;					/*	SAVE NEW PEAK VOLUME & STRING #	*/
				PPTR=PTLST;							/*	SET UP POINTER TO PARTIAL LIST	*/
				DO WHILE (INC.AXE)&(PPTR<>0);	/*	PROCESS EACH PARTIAL	*/
					IF MCHN<>0 THEN DO;			/*	COMPUTE NEW VOL IF NON-MIDI	*/
						PTL=PARTL;
						WRITE(MAM)=TBP;
						WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
						PTPTR=READ(MD);			/*	GET PTR TO PARTIAL INFO	*/
						CALL COMPUTE.VOL;			/*	COMPUTE NEW VOLUME INFO	*/
					END;
					PPTR=PFPTR;	/*	GO ON TO NEXT PARTIAL BLOCK	*/
				END;				/*	OF LOOP OVER PARTIALS	*/
			END;
			IF (I<>0) THEN DO;	/*	STORE UPDATE RECORD	*/
				IF (RECD)&(RECS<>0) THEN CALL STORE.GUITAR.UPDATE.RECORD(N);	/*	STORE RECORD OF CHANGING PITCH - ONLY WHILE STILL RECORDING AND NOTE IS STILL ACTIVE	*/
			END;	/*	STORE & SET FLAG IF DIFFERENT FROM CURRENT READING	*/
		END;
	END;

	/*	$PAGE - NEW PANEL - CHECK FOR PRESSURE CHANGE, PROCESS REAL TIME EFFECTS UPDATES	*/

   // SCAN.PRESSURE

	WRITE(MAM)=THP;
	WRITE(MAL)=THD.UPD.PARS;
	OUR.BITS=READ(MD)\NUPDT;					/*	GET BITS FOR PARAMETERS REQUIRING UPDATES FOR THIS TIMBRE, OR THIS NOTE IN THE CASE OF PRESSURE	*/

	NUPDT=NUPDT&N.NFREQ;							/*	CLEAN OUT NUPDT, AS WE WILL GET EVERYTHING HERE (EXCEPT FOR FREQUENCY CHANGES)	*/

	WRITE(MAL)=THD.MIDI;
	P=(READ(MD) & THD.MIDI.PRESURE);			/*	SEE IF SENDING MIDI PRESSURE	*/
	IF (P<>0) THEN DO;
		WRITE(MAL)=THD.ACTIVE.MIDI.RTES;
		P=(READ(MD) & B.PRESSURE);
	END;

	WRITE(MAM)=TBP;								/*	TIMBRE HEAD	*/
	WRITE(MAL)=TIM.USED.RTES;

	IF  ((READ(MD) & 256)<>0)					/*	IF PRESSURE IS ACTIVE ON A CONTINUOUS PARAMETER	*/
	OR  ((P)             <>0)					/*	OR SENDING ANY MIDI PRESSURE	*/
	THEN DO;											/*	PRESSURE IS ACTIVE - CHECK FOR CHANGE IF KEYBOARD NOTE; ADVANCE PRESSURE FILTER	*/
		I=RPRED&255;								/*	INIT TO CURRENT RAW PRESSURE IN CASE THIS IS A SEQUENCER NOTE	*/

		IF (NORIG=0) THEN DO;					/*	LIVE NOTE	*/

			IF FROMMIDI=0 THEN DO;				/*	NON-MIDI: SCAN PRESSURE FROM CLAVIER	*/

				IF ((INC.AXE=0)\(GDATA=0))			/*	KEYBOARD NOTE (VS. GUITAR)	*/
				THEN DO;									/*	SCAN PRESSURE FROM KEY	*/

					IF  (NEW.PAN<>0)					/*	VK KEYBOARD			*/
					AND (POWER.OFF=0)					/*	AND IT'S RUNNING	*/
					AND (NSTAT=0)						/*	STILL ACTIVE NOTE	*/
					THEN DO;								/*	SCAN PRESSURE		*/

                  IF (NEW.ORK == 0) THEN DO;
                     DISABLE;								/*	AVOID KEYBOARD SCAN RIGHT HERE	*/
                     WRITE(CREG)=1;						/*	INDICATE KEYBOARD OPCODES	*/
                     WRITE(DREG)="200"\(KEYN-9-KBD_TRANSPOSE);	/*	REQUEST DATA FOR THIS KEY	*/ // KBD_TRANSPOSE Out of range notes were discarded in 190-new.
                     WRITE(CREG)="40"\1;
                     WRITE(CREG)=1;
                     WRITE(CREG)="100"\1;			/*	PULSE_EXWR	*/
                     I=READ(DREG)&"377";			/*	EXTRACT PRESSURE	*/
                     WRITE(CREG)=1;					/*	REMOVE READ	*/
                     ENABLE;							/*	ALLOW KEYBOARD SCAN NOW	*/
                  END;
                  ELSE I = 0;

						IF INC.KBD.MAPS THEN DO;		/*	USE KBD MAPPING LOGIC	*/
							WRITE(MAM) = PMAP.PTR + 1;	/*	POINT AT BASELINE PRESSURE TABLE	*/
							WRITE(MAL) = KEYN-KBD_TRANSPOSE;
							I = I - READ(MD);				/*	SUBTRACT OFF BASE LINE PRESSURE VALUE	*/
							IF I < 0 THEN I = 0;			/*	LIMIT TO ZERO	*/

							/*	LOOK UP CALIBRATION INFO AND USE IT TO MAP	*/
							/*	PRESSURE INFO TO AN INDEX INTO AN RTE			*/
							/*	LOOKUP TABLE.											*/

							/*	FORMULA FOR GETTING SCALED PRESSURE:			*/
							/*	(RAW * SATURATION % * 250)/CALIBRATION VALUE	*/

							WRITE(MAM) = PMAP.PTR;		/*	LOOKUP SATURATION CONSTANT	*/
							WRITE(MAL) = LOC.PRESSURE.SATURATION;

							LOAD (READ(MD)*250/100);
							MUL I;							/*	RAW PRESSURE VALUE	*/
							MWAIT;
							WRITE(MAM) = PMAP.PTR;		/*	SET PTR TO PRESSURE CALIBRATION TABLE	*/
							WRITE(MAL) = KEYN-KBD_TRANSPOSE;
							DIV READ(MD);					/*	CALIBRATION VALUE FOR THIS KEY	*/

							I=RES+(REM IGE READ(MD));	/*	INDEX INTO MAP SCALED BY CALIBRATION DATA FOR THIS KEY	*/
							IF I IGT 255 THEN I=255;	/*	LIMIT TO MAX VALUE IN MAP	*/

							WRITE(MAM)= PMAP.PTR + 2;	/*	POINT AT PRESSURE TO RTE MAP	*/
							WRITE(MAL)=I;
							I = READ(MD);					/*	MAP PRESSURE TO VOLUME	*/
						END;
						ELSE DO;								/*	ORIGINAL LOGIC	*/
							IF I>RTE.MAX THEN I=RTE.MAX;	/*	LIMIT TO RTE.MAX	*/
							LOAD I; MUL I; I=RES; DIV RTE.MAX;	/*	USE SQUARE FUNCTION ON PRESSURE	*/
							I=RES;							/*	GET SQUARE FUNCTION, CURRENT VALUE	*/
						END;

					END;

					ELSE I=0;						/*	ZERO PRESSURE FOR OLD KEYBOARD OR AFTER RELEASE OR POWER OFF TO NEW VK	*/
            END;

				ELSE I=GRTE;						/*	USE GUITAR RTE KNOB AS PRESSURE VALUE, EVEN DURING FINAL DECAY	*/

				IF  (I>(RPRED&255)) THEN I=I-1;	/*	APPLY HYSTERESIS	*/

			END;										/*	OF SYNCLAVIER LIVE NOTE	*/

			ELSE DO;									/*	THIS NOTE CAME FROM MIDI	*/
				I=MIDI.PRESSURE(CHORIG);		/*	LOOKUP ANY MIDI CHANNEL PRESSURE	*/
				LOAD CHORIG; ULOAD KEYN; MUL NUM.KEYS;
				WRITE(MAM)=MIDI.KEY.PRESS+SHR(RES,8);
				WRITE(MAL)=RES;
				I=I+READ(MD);						/*	AND ANY MIDI INDIVIDUAL PRESSURE	*/
				IF I>RTE.MAX THEN I=RTE.MAX;	/*	LIMIT TO RTE.MAX	*/
			END;

         #if (TEST_PRESSURE)
            LOAD RTE.MAX; MUL (TEST_PRESSURE_VALUE&255); MWAIT; DIV 256; I=RES;
         #endif

         /*	$PAGE	*/

			/*	STORE NEW PRESSURE IN SEQUENCER	*/
			/*	CHECK FOR INDIV PRESS SEND			*/

			IF (I<>(RPRED&255)) THEN DO;		/*	NEW VALUE - RECORD IT	*/
				IF (RECD<>0)&(RECS<>0)
				THEN DO;								/*	RECORDING - BUT SKIP HELD NOTES THAT WERE PRESSED BEFORE 'RECORD'	*/
					CALL COMPUTE.RTE.TIME;		/*	GET TIME CORRECTED FOR TIME.DELTA	*/
					IF STORE.DATA.RECORD(RTEMSB,RTELSB,KEYN,2,I,B.UPD,0)=0
					THEN DO;							/*	NO ROOM	*/
						CALL DISPLAY.ERR(17);
						I=RPRED&255;				/*	KEEP USING OLD DATA IF OUT OF ROOM	*/
					END;
				END;
				RPRED=(RPRED&"177400")\I;		/*	STORE NEW RAW PRESSURE.  SAVE FILTERED PRESSURE LSB'S	*/

				IF (FROMMIDI=0)					/*	SYNCLAVIER LIVE NOTE	*/
				OR (MIDI.ECHO.DISABLED=0)		/*	MIDI ECHO ENABLED	*/
				THEN DO;
					WRITE(MAM)=THP;
					WRITE(MAL)=THD.MIDI;

					IF ((READ(MD) & THD.MIDI.INDIVP)<>0)	/*	INDIV PRESSURE	*/
					THEN DO;
                  WRITE(MAL)=THD.CXPOS;			/* ADD IN TRANSPOSITION  */
                  J = KEYN + READ(MD);
                  WRITE(MAL)=THD.MIDX;			   /* ADD IN TRANSPOSITION  */
                  J = J + READ(MD);
						CALL MIDI.INDIVIDUAL.PRESSURE(MIDI.MAP.KEY(J),I);	/*	SEND NEW VALUE	*/
					END;
				END;
			END;									/*	OF CHANGE IN PRESSURE FOR ACTIVE LIVE NOTE	*/

		END;										/*	OF PROCESSING LIVE NOTE (SYNCLAVIER OR MIDI)	*/

		IF (FROMMIDI=0)						/*	NON-MIDI NOTE	*/
		OR (MIDI.ECHO.DISABLED=0)			/*	MIDI ECHO ENABLED	*/
		THEN DO;
			WRITE(MAM)=THP;
			WRITE(MAL)=THD.MIDI;

			IF ((READ(MD) & THD.MIDI.CHANP)<>0)	/*	SENDING CHANNEL PRESSURE	*/
			THEN DO;
				WRITE(MAL)=THD.CPSUM;
				IF ((INC.AXE=0)\(GDATA=0)\(FROMMIDI=1))	/*	KEYBOARD OR MIDI NOTE (VS. GUITAR)	*/
				THEN DO;							/*	SCAN PRESSURE FROM KEY	*/
					WRITE(MD)=READ(MD)+I;
					IF READ(MD) IGT RTE.MAX
					THEN WRITE(MD)=RTE.MAX;
				END;
				ELSE WRITE(MD)=I;				/*	FOR GUITAR - DO NOT TOTAL - JUST USER GRTE	*/
			END;
		END;

		I=SHL(I,8);								/*	GET DEST PRESSURE IN UPPER HALF - ZEROES FOR LSB'S - MUST UPDATE PRESSURE FILTER EVEN IF NO LONGER ACTIVE	*/
		J=SHL(FPRED,8)\SHR(RPRED,8);		/*	GET MSB & LSB OF CURRENT PRESSURE	*/

		IF I<>J THEN DO;						/*	FILTERED PRESSURE NEEDS UPDATING	*/

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.PF.TC;
			K=READ(MD);							/*	LOOK UP PRECOMPUTED PRESSURE FILTER TIME CONSTANT	*/

			WRITE(MAL)=TIM.PP;
			OUR.BITS=OUR.BITS\READ(MD);	/*	INDICATE WHICH CONTINUOUS PARAMETERS MUST BE UPDATED BELOW	*/

			IF J ILT I THEN DO;				/*	HEADED UP	*/
				DO L=PRIOR.TIME TO SAMPLED.REAL.MILLISECONDS-10 BY 10;	/*	CORRECT FOR LOST TIME	*/
					LOAD (I-J); MUL K;
					J=J+READ(4);				/*	FREACTIONAL MULTIPLY	*/
					IF READ(4)=0 THEN DO;	/*	SPECIAL CHECKS REQUIRED	*/
						IF J<>I THEN J=J+1;
					END;
				END;
			END;

			ELSE DO;								/*	HEADED DOWN	*/
				DO L=PRIOR.TIME TO SAMPLED.REAL.MILLISECONDS-10 BY 10;	/*	CORRECT FOR LOST TIME	*/
					LOAD (J-I); MUL K;
					J=J-READ(4);				/*	FREACTIONAL MULTIPLY, HEAD DOWN (ALL UNSIGNED FOR SPEED)	*/
					IF READ(4)=0 THEN DO;	/*	SPECIAL CHECKS REQUIRED	*/
						IF J<>I THEN J=J-1;
					END;
				END;
			END;

			RPRED=(RPRED&255)\SHL(J,8);	/*	RESTORE RAW PRESSURE, STORE LSB'S IN UPPER HALF OF WORD	*/
			J=SHR(J,8);							/*	ISOLATE UPPPER 8 BITS OF 16-BIT PRESSURE VALUE	*/

			/*	INVERT LINEARLY	*/
			FPRED=J\SHL(RTE.MAX-J,8);
			/*	************************ B E G I N   D E L E T I O N ************************	*\
			\* INVERT USING PSEUDO-LOG FUNCTION *\
			LOAD (RTE.MAX*20+400); DIV (J+20);
			FPRED=J\SHL(RES-20,8);	\* USE LOG-LIKE FUNCTION FOR BEST INVERSION - STORE AS NEW FILTERED PRESSURE *\
			\*	************************** E N D   D E L E T I O N **************************	*/
		END;
	END;											/*	OF PRESSURE BEING USED	*/

/*	$PAGE - APPLY REAL TIME EFFECTS TO ACTIVE NOTES	*/

/*	HANDLE VOLUME CHANGE, TUNING, VIBRATO	*/

	IF (OUR.BITS<>0) THEN DO;				/*	AT LAST - UPDATE CONTINUOUS PARAMETERS	*/

		WRITE(MAM)=TBP;

		IF (OUR.BITS&(N.VE.PKSUS\N.TVOL))<>0		/*	COMPUTE NEW VOLUMES	*/
		THEN DO;

			WRITE(MAL)=TIM.VE.PKSUS.LOOK;		/*	QUICKLY CHECK TO SEE	*/
			I=READ(MD);								/*	IF ANY PKSUS CHANGE	*/
			WRITE(MAL)=TIM.TVOL.LOOK;			/*	OR TRACK VOL CHANGE	*/

			IF (I\READ(MD))<>0 THEN DO;
				PPTR=PTLST;								/*	GET POINTER TO PARTIAL LIST	*/
				DO WHILE PPTR<>0;						/*	PROCESS EACH PARTIAL		*/
					IF MCHN<>0 THEN DO;				/*	UPDATE IF NOT MIDI-ONLY	*/
						PTL=PARTL;						/*	LOOK UP PARTIAL NUMBER	*/
						I=BVOL;							/*	GET BASIC VOLUME		*/
						WRITE(MAL)=TIM.VE.PKSUS.LOOK;
						IF READ(MD)<>0 THEN DO;
							I=SCALE(I);							/*	COMPUTE NEW VALUE	*/
							IF I>255 THEN I=255;				/*	LIMIT TO MAX		*/
						END;
						WRITE(MAL)=TIM.TVOL.LOOK;			/*	CHECK TRK VOL		*/
						IF READ(MD)<>0 THEN DO;
							I=SCALE(I);							/*	COMPUTE NEW VALUE	*/
							IF I>255 THEN I=255;				/*	LIMIT TO MAX		*/
						END;
						RVOL=I; I=SHL(I,8);					/*	STORE RTE VOLUME FOR LATER A.M.	*/
						WRITE(MAL)=TIM.ANY.DPAN;
						IF (READ(MD)=0)						/*	NO STEREO OR A.M. (MOST COMMON CASE) - AVOL IS EASY TO COMPUTE	*/
						OR (PANR        =0)					/*	OR NO DYNAMIC PANNING/AM	*/
						OR (PANF ILT SHL(21,9))				/*	IF NO A.M. IS IN SOUND	*/
						THEN AVOL=I;							/*	STORE IMMED IN AVOL IF NO DYNAMIC PANNING/A.M.	*/
						IF (I=0)&(SUPR>=0) THEN CALL SUPPRESS;	/*	SUPPRESS IT	*/
					END;
					PPTR=PFPTR;	/*	GET NEXT PARTIAL	*/
				END;
			END;
		END;

		IF (OUR.BITS&N.TUNING)<>0					/*	UPDATE TUNING	*/
		THEN DO;

			WRITE(MAL)=TIM.TUNING.LOOK;

			IF READ(MD)<>0 THEN DO;					/*	SOME RTES	*/

				WRITE(MAL)=TIM.TINFO.POINTER;
				IF READ(MD)<>0 THEN DO;				/*	LOOK UP DEPTH IF DIALED IN	*/
					I=READ(MD)+TI.TBD;
					WRITE(MAM)=PAR.PTR+SHR(I,8); WRITE(MAL)=I;
					I=READ(MD);
					WRITE(MAM)=TBP;
				END;
				ELSE I=200;

				PPTR=PTLST;								/*	GET POINTER TO PARTIAL LIST	*/
				DO WHILE PPTR<>0;						/*	PROCESS EACH PARTIAL		*/
					IF MCHN<>0 THEN DO;				/*	UPDATE IF NOT MIDI-ONLY	*/
						PTL=PARTL;						/*	LOOK UP PARTIAL NUMBER	*/
						LOAD I; MUL 1024; J=RES; DIV 1200;		/*	SCALE FOR 12.00 SEMITONES PER OCTAVE	*/
						J=RES;
						WRITE(MAL)=TIM.TUNING.LOOK;
						CALL SCALE(J);					/*	SCALE FOR TONE BEND SENS		*/
						IF SIGNED.SCALE<>RTUNG THEN DO;	/*	DETECT CHANGE				*/
							NUPDT=NUPDT\N.NFREQ;		/*	SET BIT TO RESET FREQUENCIES	*/
							RTUNG=SIGNED.SCALE;		/*	AND SAVE INFO	*/
						END;
					END;									/*	ELSE LEAVE RTUNG AT ZERO	*/
					PPTR=PFPTR;							/*	GET NEXT PARTIAL	*/
				END;
			END;											/*	OF PARTIAL LOOP	*/
		END;

/*	$PAGE	*/

/*	HANDLE VIBRATO, STEREO CHANGES	*/

		IF (OUR.BITS&(N.V.RATE\N.V.DEPTH\N.V.MDEPTH))<>0 THEN DO;

			PPTR=PTLST;									/*	GET POINTER TO PARTIAL LIST	*/
			DO WHILE PPTR<>0;							/*	PROCESS EACH PARTIAL	*/
				IF MCHN<>0 THEN DO;					/*	UPDATE IF NOT MIDI-ONLY	*/
					PTL=PARTL;							/*	LOOK UP PARTIAL NUMBER	*/
					IF VIBWD>0 THEN DO;				/*	IF VIBRATO IS UP AND RUNNING	*/
						WRITE(MAL)=TIM.V.RATE.LOOK;
						IF READ(MD)<>0 THEN DO;		/*	NEW VIBRATO RATE	*/
							WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
							I=READ(MD)+P.VIBRATE;	/*	GET PTR TO PARTIAL INFO	*/
							WRITE(MAM)=PAR.PTR+SHR(I,8); WRITE(MAL)=I;
							I=READ(MD);					/*	GET MAX RATE				*/
							WRITE(MAM)=TBP;			/*	POINTERS FOR SCALE		*/
							WRITE(MAL)=TIM.V.RATE.LOOK;
							VRAT=SCALE(I);
						END;
						WRITE(MAL)=TIM.V.DEPTH.LOOK;
						IF READ(MD)<>0 THEN DO;		/*	NEW VIB DEP	*/
							VIBWD=1+SCALE(1000);		/*	SCALE FOR VIB DEPTH	*/
						END;
						WRITE(MAL)=TIM.V.MDEPTH.LOOK;
						IF READ(MD)<>0 THEN DO;		/*	NEW MOD VIB DEP	*/
							VMDE=SCALE(1000);
						END;
					END;
				END;
				PPTR=PFPTR;			/*	GET NEXT PARTIAL	*/
			END;						/*	OF PARTIAL LOOP	*/
		END;

		IF (OUR.BITS&(N.S.RATE\N.S.DEP\N.S.PAN))<>0 THEN DO;
			PPTR=PTLST;									/*	GET POINTER TO PARTIAL LIST	*/
			DO WHILE PPTR<>0;							/*	PROCESS EACH PARTIAL	*/
				IF MCHN<>0 THEN DO;					/*	UPDATE IF NOT MIDI-ONLY	*/
					PTL=PARTL;							/*	LOOK UP PARTIAL NUMBER	*/
					WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
					PTPTR=READ(MD);					/*	GET PTR TO PARTIAL INFO	*/
					I=COMPUTE.STEREO;					/*	GET BASIC STEREO INFO	*/
					WRITE(MAM)=TBP;
					IF  ((INC.MONO=0)					/*	IF NO SAMPLING AT ALL	*/
					AND  (INC.POLY=0))
					OR (MCHN&(B.MONO\B.POLY))=0 THEN DO;	/*	OR ORIGINAL SYNTHESIZER - COMPUTE ITEMS	*/
						IF I=256 THEN I=255;						/*	LIMIT TO FM SYNTH MAX	*/
						WRITE(MAL)=TIM.I.ISHC+PTL;
						I=(I&"374")+READ(MD);					/*	GET ISHC, OR INTO WORD	*/
						FMINFO=(FMINFO&"177400")\I;			/*	MOSTLY IN CASE OF REPEAT OR ARPEGGIATE (OR IN CASE NOT HAS NOT STARTED YET)	*/
						DISABLE;
						WRITE(CHA)=MCHN; WRITE(FUN)=ISHC; WRITE(DAT)=I;	/*	WRITE OUT STEREO INFO	*/
						IF (SMCHN<>0) THEN DO;					/*	UPDATE SPLICE CHANNEL TOO	*/
							WRITE(CHA)=SMCHN; WRITE(DAT)=I;	/*	WRITE OUT STEREO INFO	*/
						END;
						ENABLE;
					END;		/*	OF BEGIN FOR ORIGINAL SYNTHESIZER	*/
					ELSE IF (INC.MONO<>0)&((MCHN&B.MONO)<>0) THEN DO;	/*	MONO SAMPLING (W. DISK)	*/
						/*	NO STEREO CONTROL AVAILABLE	*/
					END;
					ELSE IF (INC.POLY<>0) THEN DO;	/*	MEANS POLY SYNTH	*/
						IDAT=I;								/*	SAVE FOR LATER WRITES	*/
					END;
				END;
				PPTR=PFPTR;	/*	GET NEXT PARTIAL	*/
			END;				/*	OF PARTIAL LOOP	*/
		END;

		/*	$PAGE - HANDLE FM REAL TIME EFFECTS	*/

		IF (OUR.BITS&N.HE.PK)<>0 THEN DO;			/*	NEW HARM ENV PK REQUIRED	*/
			IF NSTAT=0 THEN DO;							/*	ADJUST ONLY IF ACTIVE (VS. DECAYING) NOTE	*/
				PPTR=PTLST;									/*	GET POINTER TO PARTIAL LIST	*/
				DO WHILE PPTR<>0;							/*	PROCESS EACH PARTIAL		*/
					IF  (MCHN<>0)							/*	UPDATE IF NOT MIDI-ONLY	*/
					AND (DO.FM<>0)							/*	AND FM INCLUDED HERE		*/
					THEN DO;
						PTL=PARTL;							/*	LOOK UP PARTIAL NUMBER	*/
						WRITE(MAL)=TIM.HE.PK.LOOK;
						IF READ(MD)<>0 THEN DO;			/*	NEW HARMONIC ENVELOPE PEAK MIGHT BE REQUIRED	*/
							CALL COMPUTE.INX;				/*	COMPUTE NEW INDEX VALUES FOR ATTACK AND INITIAL DECAY	*/
							DISABLE;							/*	FOR ISTAT CHECK AND WRITE	*/
							IF ISTAT=1 THEN DO;			/*	ATTACK HAS STARTED BUT NOT FINISHED - WRITE OUT NEW INFO	*/
								WRITE(CHA)=MCHN;
								WRITE(FUN)=IDIV; WRITE(DAT)=IATINT;
								WRITE(FUN)=IADD; WRITE(DAT)=SHR(IATINT,8);
								WRITE(FUN)=ILIM; WRITE(DAT)=IATLIM;
								IF (SMCHN<>0) THEN DO;
									WRITE(CHA)=SMCHN;
									WRITE(FUN)=IDIV; WRITE(DAT)=IATINT;
									WRITE(FUN)=IADD; WRITE(DAT)=SHR(IATINT,8);
									WRITE(FUN)=ILIM; WRITE(DAT)=IATLIM;
								END;
							END;
							ENABLE;
						END;
					END;
					PPTR=PFPTR;								/*	GET NEXT PARTIAL		*/
				END;											/*	OF PARTIAL LOOP		*/
			END;												/*	OF BEGIN FOR NSTAT=0	*/
		END;

		IF (OUR.BITS&N.HE.SUS)<>0 THEN DO;			/*	NEW HARM ENV SUST LEV	*/
			IF NSTAT=0 THEN DO;							/*	ADJUST ONLY IF ACTIVE (VS. DECAYING) NOTE	*/
				PPTR=PTLST;									/*	GET POINTER TO PARTIAL LIST	*/
				DO WHILE PPTR<>0;							/*	PROCESS EACH PARTIAL		*/
					IF  (MCHN<>0)							/*	UPDATE IF NOT MIDI-ONLY	*/
					AND (DO.FM<>0)							/*	AND FM INCLUDED HERE		*/
					THEN DO;
						PTL=PARTL;							/*	LOOK UP PARTIAL NUMBER	*/
						WRITE(MAL)=TIM.HE.SUS.LOOK;
						IF READ(MD)<>0 THEN DO;			/*	RETRIGGER INITIAL DECAY IF SUSTAIN LEVEL CHANGED	*/
							CALL COMPUTE.INX;				/*	COMPUTE NEW INDEX VALUES FOR ATTACK AND INITIAL DECAY	*/
							DISABLE;							/*	FOR ISTAT CHECK AND WRITE	*/
							IF ISTAT=2 THEN DO;			/*	IF INITIAL DECAY HAS STARTED, THEN RE-WRITE INFO	*/
								WRITE(CHA)=MCHN;			/*	SELECT MODULATOR CHANNEL	*/
								WRITE(FUN)=ILIM;
								WRITE(DAT)=IIDLIM;		/*	WRITE OUT NEW LIMIT	*/
								WRITE(FUN)=IDIV; WRITE(DAT)=IIDINT;
								WRITE(FUN)=IADD; WRITE(DAT)=SHR(IIDINT,8);
								IF (SMCHN<>0) THEN DO;	/*	SPLICE CHANNEL	*/
									WRITE(CHA)=SMCHN; WRITE(FUN)=ILIM;
									WRITE(DAT)=IIDLIM;	/*	WRITE OUT NEW LIMIT	*/
									WRITE(FUN)=IDIV; WRITE(DAT)=IIDINT;
									WRITE(FUN)=IADD; WRITE(DAT)=SHR(IIDINT,8);
								END;
								IDAT=IIDINT&"177400";	/*	SAVE ADDER FOR EXPONENTIATION	*/
							END;
							ENABLE;
						END;
					END;
					PPTR=PFPTR;								/*	GET NEXT PARTIAL	*/
				END;											/*	OF PARTIAL LOOP	*/
			END;
		END;

		/*	$PAGE - HANDLE FM RATIO, REPEAT RATE, CHORUS CHANGES	*/

		IF (OUR.BITS&(N.FMRATIO\N.REPRATE\N.CHORUS))<>0 THEN DO;

			IF (OUR.BITS&N.REPRATE)<>0 THEN DO;	/*	NEW REPEAT RATE REQUIRED	*/
				CALL COMPUTE.RRATE;					/*	RECOMPUTE RRATE IF NEEDED	*/
				WRITE(MAM)=TBP;
			END;

			IF (OUR.BITS&(N.FMRATIO\N.CHORUS))<>0
			THEN DO;										/*	MUST LOOK THROUGH PARTIALS	*/

				PPTR=PTLST;								/*	GET POINTER TO PARTIAL LIST	*/

				DO WHILE PPTR<>0;						/*	PROCESS EACH PARTIAL		*/
					IF MCHN<>0 THEN DO;				/*	UPDATE IF NOT MIDI-ONLY	*/
						PTL=PARTL;						/*	LOOK UP PARTIAL NUMBER	*/
						IF  ((OUR.BITS&N.FMRATIO)<>0)	/*	NEW FM RATIO			*/
						AND (DO.FM<>0) THEN DO;
							WRITE(MAL)=TIM.FMRATIO.LOOK;
							IF READ(MD)<>0
							THEN DO;						/*	CHECK FOR CHANGE	*/
								I=SCALE(10000);		/*	CHECK FOR RTE'S TO FM RATIO	*/
								IF I<>RRATO THEN DO;	/*	CHANGE				*/
									RRATO=I; NUPDT=NUPDT\N.NFREQ;
								END;
							END;
						END;
						IF (OUR.BITS&N.CHORUS)<>0 THEN DO;	/*	NEW CHORUS	*/
							WRITE(MAL)=TIM.CHORUS.LOOK;
							IF READ(MD)<>0
							THEN DO;						/*	CHECK FOR CHANGE	*/
								I=SCALE(10000);		/*	CHECK FOR CHORUS ADJUST	*/
								IF I<>RCHOR THEN DO;	/*	CHANGE				*/
									RCHOR=I; NUPDT=NUPDT\N.NFREQ;
								END;
							END;
						END;
					END;
					PPTR=PFPTR;							/*	GET NEXT PARTIAL	*/
				END;										/*	OF PARTIAL LOOP	*/
			END;											/*	OF RATIO OR CHORUS CHANGE	*/
		END;												/*	RATIO, REP RATE, CHORUS CHANGE	*/

	END;													/*	OF SOME UPDATE REQUIRED	*/

	IF ((NUPDT&N.NFREQ)<>0) THEN DO;
		NEW.BEND=1;
		NUPDT=NUPDT XOR N.NFREQ;
	END;

END;														/*	OF BEGIN FOR THIS FILE	*/
