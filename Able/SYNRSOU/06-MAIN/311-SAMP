/*	:SYNRSOU:06-MAIN:311-SAMP  $TITLE  SAMPLED & ADVANCED SEQUENCER TIME BASE	*//*1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE.1998/07/06 - TY  - Modified the "IF (SAMPLED.ACTUALLY.EMIT.CLICK=0)" block to allow the						 click track feature to work in conjuction with tempo maps.1991/05/23 - CJ  - moved tempo/meter event processing to 325-new1991/04/26 - cj  - Created new tempo and new meter events as needed1991/01/09 - PF  - bug fix for click track "flange"1990/07/10 - pf  - Use LOOP.REAL.TIME.OF.NEXT.CLICK in place of LOOP.NEXT.CLICK1990/07/10 - pf  - Added Meter Map Globals: SAMPLED.ACTUAL.SEQUENCE.TIME,						 REAL.TIME.OF.NEXT.CLICK and SAMPLED.REAL.TIME.OF.NEXT.CLICK1990/06/15 - cj  - used force.time.message to send out current time						 message correctly.1990/05/31 - cj  - sampled MOVE and MOVE.SPEED in main loop1989/09/26 - CJ  - NUMEROUS CHANGES FOR TEMPO MAPPING1988/10/14 - CJ  - CLEARED NEW.SEQUENCER.FORWARD.MOTION ON OVERALL LOOP						 SO WE DON'T BOTHER TO START UP NOTES IN MIDDLE THAT						 WERE BEFORE THE LOOP END POINT1988/10/03 - CJ  - SET LOOP.TRIG.CORRECTLY TO GET MORE ACCURATE OVERALL LOOPS1986/07/15 -CJ,TS- FIXED ABRT.RECORDING BUG1986/07/09 - CJ  - MOVED SAMPLING OF NEW.EXT.PULSE FOR BUG REPAIR1986/06/19 - CJ  - SAMPLED PLAY.TIME.ACU1986/06/12 - TSS - Added code for PRIOR.ACTUAL.PLAY.TIME.LSB/MSB1986/05/15 - "official" creation of release-M modules*/BEGIN;	DCL LAST.TIME.MESSAGE	FIXED EXTERNAL;	DCL FORCE.TIME.MESSAGE	FIXED EXTERNAL;	DCL MSB						FIXED;	DCL LSB						FIXED;	PRIOR.REAL.MILLISECONDS		= SAMPLED.REAL.MILLISECONDS;	PRIOR.KBD.MILLISECONDS		= SAMPLED.KBD.MILLISECONDS;	PRIOR.ACTUAL.PLAY.TIME.LSB	= SAMPLED.ACTUAL.PLAY.TIME.LSB;	/*	SAVE FOR ABRT.RECORDING	*/	PRIOR.ACTUAL.PLAY.TIME.MSB	= SAMPLED.ACTUAL.PLAY.TIME.MSB;	interp_check_interrupts();		/*	if running in simulator, latch d3 interrupt at this time	*/	DISABLE;	SAMPLED.REAL.MILLISECONDS	= REAL.MILLISECONDS;	SAMPLED.KBD.MILLISECONDS	= KBD.MILLISECONDS;	SAMPLED.ACTUAL.PLAY.TIME.LSB = PLAY.TIME.LSB;	SAMPLED.ACTUAL.PLAY.TIME.MSB = PLAY.TIME.MSB;	SAMPLED.ACTUAL.PLAY.TIME.ACU = PLAY.TIME.ACU;	SAMPLED.ACTUAL.NEXT.CLICK	  = NEXT.CLICK;	SAMPLED.ACTUAL.BEAT.NUMBER	  = BEAT.NUMBER;	SAMPLED.MOVE					  = MOVE;	SAMPLED.MOVE.SPEED			  = MOVE.SPEED;	SAMPLED.ACTUALLY.EMIT.CLICK  = ACTUALLY.EMIT.CLICK;	EXT.REP.TRIGGER				= NEW.EXT.PULSE;	NEW.EXT.PULSE					= 0;	IF (LOOP.RESTART<>0) THEN DO;			/*	RESTART LOOP - HOUSE CLEAN	*/		LOOP.RESTART=0;						/*	CLEAR FLAG	*/		ENABLE;		IF PTRS.LOOPED=0 THEN DO;			/*	MUST MOVE LOOP POINTERS HERE IF WE DID NOT BELOW	*/			CALL MOVE.LOOP.PTRS;				/*	PRESET FOR SCAN OF SEQUENCER AT LOOP START POINT	*/			IF NEW.SEQUENCER.FORWARD.MOTION <> 1	/*	STOP ANY START UP IN MIDDLE ACTIVITY GOING ON, BUT	*/			THEN NEW.SEQUENCER.FORWARD.MOTION = 0;	/*	IF PRESET PLAY TIME, LET IT START	*/		END;										/*	HAPPENS FREQUENTLY ON PRESS OF UNJUSTIFIED LOOP BUTTON	*/		PTRS.LOOPED=0;							/*	RESET POINTERS LOOPED FLAG FOR NEXT LOOP	*/		ABRT.RECORDING=1;						/*	WAIT ONE MORE LOOP IN CASE BAD PLAY.TIMES ARE STACKED	*/		IF LOOP.REAL.TIME.OF.NEXT.CLICK.LSB<>LOOP.PLAY.TIME.LSB		THEN CALL RESYNC.TIME.BASE;		/*	GET SEQUENCER INFO CORRECT FOR SYNC PURPOSES	*/		IF ((MIDI.SYNC.OUT	!= 0)			/*	if doing midi sync output	*/		&&  (MIDI.SYNC.IS.TC != 0))		/*	and is time code				*/			PREP.FOR.MTC.OUTPUT(SAMPLED.ACTUAL.PLAY.TIME.MSB, SAMPLED.ACTUAL.PLAY.TIME.LSB, FALSE);	END;	ELSE DO;										/*	RESET ABRT FLAG	*/		ENABLE;									/*	INTERRUPTS AFTER SAMPLING LOOP.RESTART & PLAY.TIME	*/	END;	/*	FORCE OUT A CURRENT TIME MESSAGE IF NEEDED.  THIS MUST BE DONE	*/	/*	AFTER WE SAMPLED THE TIME BASE ABOVE TO MAKE SURE THE INFO		*/	/*	IS CORRECT.																		*/	IF FORCE.TIME.MESSAGE <> 0 THEN DO;		LAST.TIME.MESSAGE  = REAL.MILLISECONDS-1000;		FORCE.TIME.MESSAGE = 0;	END;	/*	MAP SAMPLED PLAY TIME TO SEQUENCE TIME	*/	CALL MAP.REAL.TIME.TO.SEQUENCE.TIME(LOC(ADDR(SAMPLED.ACTUAL.PLAY.TIME.MSB)),													LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)));	IF (SAMPLED.ACTUALLY.EMIT.CLICK=0)	/*	NEED TO COMPUTE REAL.TIME.OF.NEXT.CLICK	*/	THEN DO;		/*	COMPUTE NEXT/PRIOR CLICK SEQUENCE TIME	*/		CALL MAP.SEQUENCE.TIME.TO.NEAREST.CLICKS(LOC(ADDR(SAMPLED.ACTUAL.SEQUENCE.TIME.MSB)),															  LOC(ADDR(PRIOR.CLICK.MSB)),															  LOC(ADDR(MSB)));		IF (MSB <> NEXT.CLICK.MSB)			/*	MAKE REAL SURE THAT WE HAVE			*/		OR (LSB <> NEXT.CLICK.LSB)			/*	ACTUALLY ENTERED A NEW CLICK PERIOD	*/		THEN DO;			NEXT.CLICK.MSB = MSB;			/*	SAVE NEW SEQUENCE TIME OF NEXT CLICK	*/			NEXT.CLICK.LSB = LSB;			/*	MAP NEXT CLICK TO REAL TIME	*/			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(NEXT.CLICK.MSB)),															LOC(ADDR(REAL.TIME.OF.NEXT.CLICK.MSB)));			IF CLICK.TRACK.MODE ILT 4 THEN ACTUALLY.EMIT.CLICK = TRUE;	/*	TELL INTERRUPT CODE OK TO EMIT NEXT CLICK	*/			/*	COMPUTE PRIOR CLICK ALSO FOR JUSTIFY CODE	*/			CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(PRIOR.CLICK.MSB)),															LOC(ADDR(REAL.TIME.OF.PRIOR.CLICK.MSB)));		END;		IF (CLICK.TRACK.MODE IGT 3)							/*	MAKE REAL SURE THAT WE HAVE			*/		&& (SAMPLED.ACTUAL.PLAY.TIME.LSB >= NEXT.CLICK)	/*	ACTUALLY ENTERED A NEW CLICK PERIOD	*/		THEN ACTUALLY.EMIT.CLICK = TRUE;	/*	TELL INTERRUPT CODE OK TO EMIT NEXT CLICK	*/	END;	SAMPLED.REAL.TIME.OF.NEXT.CLICK.LSB  = REAL.TIME.OF.NEXT.CLICK.LSB;	SAMPLED.REAL.TIME.OF.PRIOR.CLICK.LSB = REAL.TIME.OF.PRIOR.CLICK.LSB;	/*	ADVANCE SEQUENCER TIME BASE BY PRESCAN AMOUNT	*/	ADVANCED.PLAY.TIME.MSB	= SAMPLED.ACTUAL.PLAY.TIME.MSB;	ADVANCED.PLAY.TIME.LSB	= SAMPLED.ACTUAL.PLAY.TIME.LSB+PRESCAN;	IF ADVANCED.PLAY.TIME.LSB ILT PRESCAN	THEN ADVANCED.PLAY.TIME.MSB=ADVANCED.PLAY.TIME.MSB+1;	ADVANCED.NEXT.CLICK		=SAMPLED.ACTUAL.NEXT.CLICK;	ADVANCED.BEAT.NUMBER		=SAMPLED.ACTUAL.BEAT.NUMBER;	DO WHILE (ADVANCED.PLAY.TIME.LSB>=ADVANCED.NEXT.CLICK);	/*	PRESCAN CROSSED OVER CLICK BOUNDARY	*/		ADVANCED.NEXT.CLICK=ADVANCED.NEXT.CLICK+SAMP.CLICK.RATE;	/*	TIME OF NEXT CLICK	*/		IF (CLICK.TRACK.MODE == 0)	/*	NOT USING EXT CLICK OR LIVE CLICK TRACK	*/		ADVANCED.BEAT.NUMBER = ADVANCED.BEAT.NUMBER+1;			/*	ADVANCE BEAT #	*/	END;	/*	COMPUTE THE SEQUENCE TIME THAT CORRESPONDS TO THE ADVANCED	*/	/*	REAL PLAY TIME:															*/	call Map.Real.Time.To.Sequence.Time(loc(addr(ADVANCED.PLAY.TIME.MSB)),													loc(addr(ADVANCED.SEQ.TIME.MSB )));	IF NUM.MIDI.CLOCKS<>0 THEN DO;					/*	RECALIBRATE MIDI CLOCK LIMIT	*/		DISABLE.MIDI.CLOCKS=1;							/*	DON'T LET INTERRUPT CODE MUCK WITH US	*/		LOAD NUM.MIDI.CLOCKS;							/*	COMPUTE SEQ TIME OF NEXT MIDI LIMIT	*/		MUL  DIVISIONS;		LOAD MIDI.LIMIT.REM+RES;		DIV 24;		MIDI.LIMIT.LSB=MIDI.LIMIT.LSB+RES;		IF MIDI.LIMIT.LSB ILT RES		THEN MIDI.LIMIT.MSB=MIDI.LIMIT.MSB+1;		MIDI.LIMIT.REM=REM;								/*	SAVE REMAINDER TO ACCUMULATE CORRECT TOTAL TIME	*/		IF MIDI.LIMIT.REM<>0 THEN DO;					/*	ROUND LIMIT UP IF REMAINDER	*/			MIDI.LIMIT.LSB=MIDI.LIMIT.LSB+1;			IF MIDI.LIMIT.LSB=0			THEN MIDI.LIMIT.MSB=MIDI.LIMIT.MSB+1;			MIDI.LIMIT.REM=MIDI.LIMIT.REM-24;		END;		/*	NOW MAP THE MIDI LIMIT TO REAL TIME	*/		CALL Map.Sequence.Time.To.Real.Time(loc(addr(MIDI.LIMIT.MSB)),LOC(ADDR(REAL.TIME.OF.MIDI.LIMIT.MSB)));		/*	SEE IF WE NEED TO COMPUTE NEW REAL TIME MIDI CLOCK RATES	*/		IF COM32(LOC(ADDR(REAL.TIME.OF.MIDI.LIMIT.MSB)),LOC(ADDR(REAL.TIME.OF.NEXT.TEMPO.MSB)))<>LW#ILT		THEN CALL COMPUTE.REAL.MIDI.CLOCK.RATES(LOC(ADDR(MIDI.LIMIT.MSB)));		NUM.MIDI.CLOCKS=0;								/*	RESET INTERRUPT CLOCK COUNTER	*/		DISABLE.MIDI.CLOCKS=0;							/*	ALLOW INTERRUPT CODE TO DO ITS THING	*/	END;	IF NUM.RECEIVED.CLOCKS<>0 THEN DO;				/*	RECALIBRATE RECEVIED CLOCK LIMIT	*/		DISABLE.RECEIVED.CLOCKS=1;						/*	DON'T LET INTERRUPT CODE MUCK WITH US	*/		LOAD NUM.RECEIVED.CLOCKS;						/*	COMPUTE SEQ TIME OF NEXT CLOCK LIMIT	*/		MUL  DIVISIONS;		LOAD CLOCK.LIMIT.REM+RES;		DIV  SAMP.EXT.DIV;								/*	EXTERNAL CLICK RATE MULTIPLIER	*/		CLOCK.LIMIT.LSB=CLOCK.LIMIT.LSB+RES;		IF CLOCK.LIMIT.LSB ILT RES		THEN CLOCK.LIMIT.MSB=CLOCK.LIMIT.MSB+1;		CLOCK.LIMIT.REM=REM;								/*	SAVE REMAINDER TO ACCUMULATE CORRECT TOTAL TIME	*/		IF CLOCK.LIMIT.REM<>0 THEN DO;				/*	ROUND LIMIT UP IF REMAINDER	*/			CLOCK.LIMIT.LSB=CLOCK.LIMIT.LSB+1;			IF CLOCK.LIMIT.LSB=0			THEN CLOCK.LIMIT.MSB=CLOCK.LIMIT.MSB+1;			CLOCK.LIMIT.REM=CLOCK.LIMIT.REM-SAMP.EXT.DIV;		END;		/*	NOW MAP THE CLOCK LIMIT TO REAL TIME	*/		CALL Map.Sequence.Time.To.Real.Time(loc(addr(CLOCK.LIMIT.MSB)),LOC(ADDR(REAL.TIME.OF.CLOCK.LIMIT.MSB)));		/*	SEE IF WE NEED TO COMPUTE NEW REAL TIME MIDI CLOCK RATES	*/		IF COM32(LOC(ADDR(REAL.TIME.OF.CLOCK.LIMIT.MSB)),LOC(ADDR(REAL.TIME.OF.NEXT.TEMPO.MSB)))<>LW#ILT		THEN CALL COMPUTE.REAL.CLOCK.RATES(LOC(ADDR(CLOCK.LIMIT.MSB)));		NUM.RECEIVED.CLOCKS=0;							/*	RESET INTERRUPT CLOCK COUNTER	*/		DISABLE.RECEIVED.CLOCKS=0;						/*	ALLOW INTERRUPT CODE TO DO ITS THING	*/	END;	IF OVERALL.LOOP<>0 THEN DO;			/*	CHECK FOR TIME PAST LOOP	*/		IF  (( ADVANCED.PLAY.TIME.MSB IGT GOBACK.PLAY.TIME.MSB)		/*	IF PAST	*/		OR   ((ADVANCED.PLAY.TIME.MSB  =  GOBACK.PLAY.TIME.MSB)		/*	END OF	*/		AND   (ADVANCED.PLAY.TIME.LSB IGE GOBACK.PLAY.TIME.LSB)))	/*	LOOP ..	*/		AND (((SMPTE.ONOFF=0												)))		THEN DO;			IF  (PTRS.LOOPED=0)				/*	IF HAVE NOT LOOPED POINTERS YET	*/			AND (NEXT.EVENT.QUEUE<>0)		/*	AND THERE IS A NOTE ON THE QUE	*/			AND (MOVE=0)						/*	BUT SKIP IF MOVING					*/			AND (((NEXT.EVENT.MSB ILT GOBACK.SEQ.TIME.MSB))			OR   ((NEXT.EVENT.MSB  =  GOBACK.SEQ.TIME.MSB)			AND   (NEXT.EVENT.LSB ILT GOBACK.SEQ.TIME.LSB)))			THEN DO;								/*	SCAN FOR NOTE BETWEEN US AND LOOP END - GET IT IF SO	*/				/*	SET ADVANCED.PLAY.TIME AND ADVANCED.SEQ.TIME TO 1 UNIT	*/				/*	BEFORE THE END OF THE LOOP SO WE SCAN ANY NOTES				*/				/*	SITTING BETWEEN US AND THE END OF THE LOOP.					*/				CALL COPY32 (LOC(ADDR(GOBACK.PLAY.TIME.MSB  )),								 LOC(ADDR(ADVANCED.PLAY.TIME.MSB)));				IF COM16(0, LOC(ADDR(ADVANCED.PLAY.TIME.MSB))) <> LW#IEQ				THEN CALL SUB16(1, LOC(ADDR(ADVANCED.PLAY.TIME.MSB)));				CALL COPY32 (LOC(ADDR(GOBACK.SEQ.TIME.MSB  )),								 LOC(ADDR(ADVANCED.SEQ.TIME.MSB)));				IF COM16(0, LOC(ADDR(ADVANCED.SEQ.TIME.MSB))) <> LW#IEQ				THEN CALL SUB16(1, LOC(ADDR(ADVANCED.SEQ.TIME.MSB)));			END;			/*	ELSE IF THERE ARE NO NOTES BETWEEN US AND THE END OF THE	*/			/*	LOOP, THEN RESET THE LOOP POINTERS HERE:						*/			ELSE DO;				/*	COMPUTE TIME INTO LOOP START WE SHOULD BE AT	*/				I = ADVANCED.PLAY.TIME.LSB - GOBACK.PLAY.TIME.LSB;	/*	GET REAL TIME INTO LOOP	*/				ADVANCED.PLAY.TIME.LSB		=LOOP.PLAY.TIME.LSB+I;				ADVANCED.PLAY.TIME.MSB		=LOOP.PLAY.TIME.MSB;				IF (ADVANCED.PLAY.TIME.LSB ILT I) THEN DO;	/*	WRAPPED	*/					ADVANCED.PLAY.TIME.MSB	=ADVANCED.PLAY.TIME.MSB+1;				END;				ADVANCED.NEXT.CLICK			=LOOP.NEXT.CLICK;				ADVANCED.BEAT.NUMBER			=LOOP.BEAT.NUMBER;				DO WHILE (ADVANCED.PLAY.TIME.LSB>=ADVANCED.NEXT.CLICK);	/*	PRESCAN CROSSED OVER CLICK BOUNDARY	*/					ADVANCED.NEXT.CLICK=ADVANCED.NEXT.CLICK+SAMP.CLICK.RATE;	/*	TIME OF NEXT CLICK	*/					IF (CLICK.TRACK.MODE == 0)		/*	NOT USING EXT SYNC OR LIVE TRACK	*/					ADVANCED.BEAT.NUMBER = ADVANCED.BEAT.NUMBER+1;	/*	ADVANCE BEAT #	*/				END;				call Map.Real.Time.To.Sequence.Time(loc(addr(ADVANCED.PLAY.TIME.MSB)),																loc(addr(ADVANCED.SEQ.TIME.MSB )));				IF  (PTRS.LOOPED=0)			/*	LOOP POINTERS FIRST TIME THROUGH	*/				AND (MOVE.SPEED>=0)			/*	IF PLAY OR FF							*/				THEN DO;					PTRS.LOOPED=1;					CALL MOVE.LOOP.PTRS;		/*	AND PRESET FOR SCAN OF SEQUENCER AT LOOP START POINT	*/					LOOP.TRIG.CLICK = LOOP.TRIGGER.CLICK;					IF NEW.SEQUENCER.FORWARD.MOTION <> 1	/*	STOP ANY START UP IN MIDDLE ACTIVITY GOING ON, BUT	*/					THEN NEW.SEQUENCER.FORWARD.MOTION = 0;	/*	IF PRESET PLAY TIME, LET IT START	*/				END;			END;	/*	OF OK TO RESET PLAY INFO NOW	*/		END;		/*	OF HAVE GONE BEYOND OVERALL LOOP END POINT	*/	END;			/*	OF CASE FOR PLAYING AND LOOPING	*/END;