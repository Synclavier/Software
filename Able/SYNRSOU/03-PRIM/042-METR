/*	:SYNRSOU:03-PRIM:042-METR  -  Routines to manage Sequencer Meter Map	*//*Modified:1999/04/11 - TY  - Fixed two whopping bugs in "Normalize.Meter.Map.All".  When updating the first record in a subsequent						 sector, it failed to write the time and beat number at the end of the previous sector as well.						 Also when backing up to the beginning of the map, it failed to update "Meter.Map.Len".					  - Streamlined the Meter map renormalization process by replacing "Normalize.Meter.Map.All" with						 "Update.Meter.Map.Ratios" and "Normalize.Meter.Map.TimesBeats".  The ratios only need to be recomputed						 in the record who's meter was changed, and the times and beat numbers only need to be rebuilt in the						 records subsequent to the one updated or deleted.						 "Normalize.Meter.Map.All" was needlessly performing both of these tasks on the entire list.1999/03/31 - TY  - Moved variable and literal declarations from here to ":SYNRSOU:03-PRIM:041-MAPS".						 Too much hassle with forward declarations otherwise.1998/05/22 - TY  - Modified LOOKUP.BEATS.PER.MEASURE to return SAMP.BPM if a click track is in use.1998/01/13 - cj  - allowed for (limited) minus times1991/03/14 - cj  - fixed other display bugs; allowed for 32-bit beat numbers1991/03/12 - cj  - fixed several tempo map display bugs1991/02/13 - cj  - Checked for null meter maps in places					  - Used more thorough ratio computation to handle non-integer ratios better.1991/02/06 - PF  - Begin counting measures at zero1991/02/05 - PF  - Add compute click rate to Normalize.Meter.Map.All1991/02/01 - PF  - Fix bug in Create.Default.Meter.Map1991/01/09 - PF  - bug fixes for click rate, allow editing of beats per measure1990/10/14 - PF  - Add routine Normalize.Meter.Map.All to be called after any meter changes1990/07/10 - PF  - Begin Meter Map implementation*//*	$page Routine to normalize current pointer to segment map	*//*	This routine is called whenever the contents of the	*//*	map has changed.  It sets up some global				*//*	variables that identify the current segment so		*//*	the search for the correct segment is sped up.		*/Normalize.Meter.Map.Cur: proc;	/*	procedure to provide infinite limits:	*/	Zap.Meter.Limits: proc;		Meter.Map.This.Seq.Msb		= 0;		Meter.Map.This.Seq.Lsb		= 0;		Meter.Map.This.Measure.Msb	= 0;		Meter.Map.This.Measure.Lsb	= 0;		Meter.Map.This.Beat.Msb		= 0;		Meter.Map.This.Beat.Lsb		= 0;		Meter.Map.Next.Seq.Msb		= -1;		Meter.Map.Next.Seq.Lsb		= -1;		Meter.Map.Next.Measure.Msb	= -1;		Meter.Map.Next.Measure.Lsb	= -1;		Meter.Map.Next.Beat.Msb		= -1;		Meter.Map.Next.Beat.Lsb		= -1;		Meter.Map.Cur = 0;		/*	no current pointer	*/		Meter.Map.Len = 0;		/*	no meter map length	*/	end Zap.Meter.Limits;	/*	If the meter map is empty, set current pointer to zero and mark	*/	/*	limits as from 0 to infinity:													*/	if (Meter.Map.Ptr = 0)		/*	if no sector allocated						*/	then do;							/*	then no meter map is present				*/		call Zap.Meter.Limits;	/*	set up infinite limits, clear out		*/		return;						/*	cur & len info.								*/	end;	/*	back meter map pointer up to prior block if we need to:				*/	do while Meter.Map.Cur < Meter.Map.First;		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.REV;		/*	if no prior block, indicates a serious error of some sort:		*/		if read(md) = 0		then do;			call Zap.Meter.Limits;	/*	set up infinite limits, clear out	*/			return;						/*	cur & len info.							*/		end;		Meter.Map.Ptr = NAH.PTR + read(md);	/*	compute absolute pointer	*/		write(mam) = Meter.Map.Ptr;			/*	access prior block			*/		write(mal) = Meter.Map.LP;				/*	get ending pointer			*/		Meter.Map.Len = read(md);				/*	save in global					*/		Meter.Map.Cur = Meter.Map.Len - Meter.Map.Rec.Len;	end;	/*	Now skip to next meter map block if we are at the end of this		*/	/*	block:																				*/	do while Meter.Map.Cur >= Meter.Map.Len;		write(mam) = Meter.Map.Ptr;	/*	point ahead to next linked block	*/		write(mal) = Meter.Map.FOR;		/*	if no next block, indicates a serious error of some sort:		*/		if read(md) = 0		then do;			call Zap.Meter.Limits;	/*	set up infinite limits, clear out	*/			return;						/*	cur & len info.							*/		end;		Meter.Map.Ptr = NAH.PTR + read(md);	/*	compute absolute pointer	*/		write(mam) = Meter.Map.Ptr;			/*	access next block				*/		write(mal) = Meter.Map.FP;				/*	get pointer to start			*/		Meter.Map.Cur = read(mdi);				/*	should be Meter.Map.First	*/		Meter.Map.Len = read(md);				/*	get ending pointer too.		*/	end;	/*	Now look up starting and ending values to have handy:	*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur;	Meter.Map.This.Seq.Msb		= read(mdi);	Meter.Map.This.Seq.Lsb		= read(mdi);	Meter.Map.This.Measure.Msb	= read(mdi);	Meter.Map.This.Measure.Lsb	= read(mdi);	Meter.Map.This.Beat.Msb		= read(mdi);	Meter.Map.This.Beat.Lsb		= read(mdi);	write(mal) = Meter.Map.Cur + Meter.Map.Rec.Len;	Meter.Map.Next.Seq.Msb		= read(mdi);	Meter.Map.Next.Seq.Lsb		= read(mdi);	Meter.Map.Next.Measure.Msb	= read(mdi);	Meter.Map.Next.Measure.Lsb	= read(mdi);	Meter.Map.Next.Beat.Msb		= read(mdi);	Meter.Map.Next.Beat.Lsb		= read(mdi);end Normalize.Meter.Map.Cur;/*	The following routine goes through the entire meter map and computes all	*//*	the ratios, the sequence time, and the accumulated beat # from the			*//*	measure # field and the 4 nn-dd-cc-bb fields.										*//*	It is called (for example) whenever the measure length of a meter			*//*	segment changes.  It recomputes the accumulated beat #'s and				*//*	sequencer times of all the following meter segments.							*//*	Note:  The measure length of each segment is determined by subtracting	*//*			 the measure # of the start of this segment from the measure #		*//*			 of the start of the next segment.  Thus, every meter change		*//*			 occurs on a measure boundary by definition.  The starting			*//*			 beat number, and all the ratios, are computing from the				*//*			 measure length, and the 4 constants nn, dd, cc, and bb.				*//*			 The length of the segment in sequencer divisions is then			*//*			 also computed from the measure length of the segment.				*/#if (false)Normalize.Meter.Map.All: proc public swapable;	//	THIS PROCEDURE IS FLAWED... FATAL RESULTS -TY 1999/04/11	dcl t.msb			fixed;	dcl t.lsb			fixed;	dcl measures.msb	fixed;	dcl measures.lsb	fixed;	dcl beat.msb		fixed;	dcl beat.lsb		fixed;	dcl nn				fixed;	dcl dd				fixed;	dcl cc				fixed;	dcl bb				fixed;	dcl (r1,r2,r3)		fixed static;	dcl i					fixed;	/*	handy routine to compute rounded 48 bit ratio of (a*b)/(c*d)	*/	compute.local.ratio:proc(a,b,c,d);		dcl (a,b,c,d)	fixed;      dcl (x)       fixed;		/*	Remove powers of 2 from numerator and denominator to handle	*/		/*	cases of unusually large Divisions (etc.).						*/		//	do while	((((a&1) = 0) \ ((b&1)=0))		//		and	 (((c&1) = 0) \ ((d&1)=0)));		while	((((a&b)|(c&d))&1) == 0) {	//	Faster conditional			if ((a&1)=0) then	a = shr(a,1);			else					b = shr(b,1);			if ((c&1)=0) then	c = shr(c,1);			else					d = shr(d,1);		}		c = c*d;             /* compute denominator; won't overflow in realistic cases */		load a; mul b; mwait; div c;		r1 = res;		x=rem; load 0; uload x; div c; r2=res;		x=rem; load 0; uload x; div c; r3=res;		if (shl(rem,1) IGE c)       /* round up ratio if needed */		then do;			r3 = r3 + 1;			if r3 = 0 then do;				r2 = r2 + 1;				if r2 = 0 then r1 = r1 + 1;			end;		end;	end compute.local.ratio;	if Meter.Map.Ptr = 0			/*	if no meter map	*/	then return;					/*	nothing to do		*/	/*	Back up to Record 0 of Meter Map	*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.REV;	do while read(md)<>0;		Meter.Map.Ptr = NAH.PTR + read(md);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.REV;	end;	write(mal) = Meter.Map.FP;	Meter.Map.Cur = read(mdi);	/*	get pointer to start				*/	Meter.Map.Len = read(md );	/*	must get ending pointer too	*/	call Normalize.Meter.Map.Cur;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur;	t.msb = read(mdi);			/*	get sequencer time of first	*/	t.lsb = read(md );			/*	meter record (0, zero.time)	*/	write(mal) = Meter.Map.Cur + Meter.Map.Beat#.Msb;	beat.msb = read(mdi);		/*	get starting beat number		*/	beat.lsb = read(md );		/*	of first record (0,0)			*/	/*	now step thru each record and compute seq times etc...	*/	i = 1;	do while i;		/*	lookup meter record basics	*/		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.nn;		nn = read(mdi);		/*	get numerator									*/		dd = read(mdi);		/*	get denominator								*/		cc = read(mdi);		/*	get midi clocks per click					*/		bb = read(md );		/*	get 32nd notes per beat displayed		*/		/*	Compute click ratios for this meter segment						*/		/*	Rc.d = 24 / divisions / cc												*/		call compute.local.ratio(1,24,Divisions,cc);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rc.d;		write(mdi) = r1;		write(mdi) = r2;		write(md ) = r3;		/*	Rd.c = divisions * cc / 24												*/		call compute.local.ratio(Divisions,cc,24,1);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rd.c;		write(mdi) = r1;		write(mdi) = r2;		write(mdi) = r3;		/*	Compute beat ratios for this meter segment						*/		/*	Rb.d = bb / shl(1,5-dd) / divisions									*/		call compute.local.ratio(1,bb,shl(1,5-dd),Divisions);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rb.d;		write(mdi) = r1;		write(mdi) = r2;		write(md ) = r3;		/*	Rd.b = shl(1,5-dd) * divisions / bb									*/		call compute.local.ratio(shl(1,5-dd),Divisions,bb,1);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rd.b;		write(mdi) = r1;		write(mdi) = r2;		write(md ) = r3;		/*	Compute measure ratios for this meter segment					*/		/*	Rm.d = bb / shl(1,5-dd) / nn / divisions							*/		call compute.local.ratio(1,bb,shl(1,5-dd)*nn,Divisions);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rm.d;		write(mdi) = r1;		write(mdi) = r2;		write(md ) = r3;		/*	Rd.m = shl(1,5-dd) * nn * divisions / bb							*/		call compute.local.ratio(shl(1,5-dd)*nn,Divisions,bb,1);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.Rd.m;		write(mdi) = r1;		/*	note: save r1, r2, r3 for segment		*/		write(mdi) = r2;		/*	length computation below					*/		write(mdi) = r3;		/*	if this is not the last meter segment, advance to next one	*/		if (Meter.Map.Next.Seq.Msb <> (-1))		or (Meter.Map.Next.Seq.Lsb <> (-1))		then do;			/*	Compute length of this meter segment in measures			*/			call sub32(loc(addr(Meter.Map.Next.Measure.Msb)),						  loc(addr(Meter.Map.This.Measure.Msb)),						  loc(addr(measures.msb)));			/*	compute start of next segment in sequencer time while we	*/			/*	have Rd.m conveniently sitting in r1, r2, r3					*/			BITMSB = measures.msb;			/*	get # of measures in this meter	*/			BITLSB = measures.lsb;			/*	segment									*/			call MULTIPLY(r1,r2,r3,0);		/*	compute deltadivisions length		*/			call add32(loc(addr(t.msb)),loc(addr(BITMSB)),loc(addr(t.msb)));			BITMSB = measures.msb;			/*	get # of measures in this meter	*/			BITLSB = measures.lsb;			/*	segment									*/			call MULTIPLY(nn,0,0,0);		/*	compute beat length					*/			call add32(loc(addr(beat.msb)),loc(addr(BITMSB)),loc(addr(beat.msb)));			Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;			write(mam) = Meter.Map.Ptr;			write(mal) = Meter.Map.Cur;			write(mdi) = t.msb;			write(mdi) = t.lsb;			write(mal) = Meter.Map.Cur + Meter.Map.Beat#.Msb;			write(mdi) = beat.msb;			write(mdi) = beat.lsb;		end;		else i = 0;							/*	force break from loop	*/	end;end Normalize.Meter.Map.All;#endifNormalize.Meter.Map.TimesBeats: proc public swapable;	dcl t.msb			fixed;	dcl t.lsb			fixed;	dcl measures.msb	fixed;	dcl measures.lsb	fixed;	dcl beat.msb		fixed;	dcl beat.lsb		fixed;	if Meter.Map.Ptr = 0			/*	if no meter map	*/	then return;					/*	nothing to do		*/	/*	now step thru each record and compute seq times etc...	*/	while ((Meter.Map.Next.Seq.Msb != -1) || (Meter.Map.Next.Seq.Lsb != -1)) {		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur;		t.msb = read(mdi);			/*	get sequencer time of current	*/		t.lsb = read(md );			/*	meter record						*/		write(mal) = Meter.Map.Cur + Meter.Map.Beat#.Msb;		beat.msb = read(mdi);		/*	get starting beat number		*/		beat.lsb = read(md );		/*	of this record						*/		/*	Compute length of this meter segment in measures			*/		call sub32(loc(addr(Meter.Map.Next.Measure.Msb)),					  loc(addr(Meter.Map.This.Measure.Msb)),					  loc(addr(measures.msb)));		//	Compute the new length in delta divisions of this meter segment		//	Measure Length * Delta Divisions/Measure		BITMSB = measures.msb;		BITLSB = measures.lsb;		write(mal) = Meter.Map.Cur + Meter.Map.Rd.m;		MULTIPLY(read(mdi),read(mdi),read(md),0);			//	Compute start time of next record		call add32(loc(addr(t.msb)),loc(addr(BITMSB)),loc(addr(t.msb)));		//	Compute the new length in beats of this meter segment		//	Measure Length * Beats/Measure		BITMSB = measures.msb;		BITLSB = measures.lsb;		write(mal) = Meter.Map.Cur + Meter.Map.nn;		call MULTIPLY(read(md),0,0,0);		//	Compute beat number of next record		call add32(loc(addr(beat.msb)),loc(addr(BITMSB)),loc(addr(beat.msb)));		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		//	If there are no furthur records in this sector, write out the new info at the end before linking to the next sector		if (Meter.Map.Cur == Meter.Map.Len) {			write(mal) = Meter.Map.Cur;			write(mdi) = t.msb;			write(md ) = t.lsb;			write(mal) = Meter.Map.Cur + Meter.Map.Beat#.Msb;			write(mdi) = beat.msb;			write(md ) = beat.lsb;		}		// Jump to the next record		Normalize.Meter.Map.Cur();		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur;		write(mdi) = t.msb;		write(mdi) = t.lsb;		write(mal) = Meter.Map.Cur + Meter.Map.Beat#.Msb;		write(mdi) = beat.msb;		write(mdi) = beat.lsb;	}end Normalize.Meter.Map.TimesBeats;Update.Meter.Map.Ratios: proc public swapable;	dcl (nn,dd,cc,bb)	fixed;	dcl (r1,r2,r3)		fixed static;	/*	handy routine to compute rounded 48 bit ratio of a*b/c/d	*/	compute.local.ratio:proc(a,b,c,d);		dcl (a,b,c,d)	fixed;		/*	Remove powers of 2 from numerator and denominator to handle	*/		/*	cases of unusually large Divisions (etc.).						*/		while	((((a&b)|(c&d))&1) == 0) {			if ((a&1) == 0) a = shr(a,1);			else				 b = shr(b,1);			if ((c&1) == 0) c = shr(c,1);			else				 d = shr(d,1);		}		load c; mul d; c = res;		//	compute denominator; won't overflow in realistic cases		load a; mul b; mwait; div c;									r1 = res;		write("313") = rem; load 0; uload read("313"); div c;	r2 = res;		write("313") = rem; load 0; uload read("313"); div c;	r3 = res;		if (shl(rem,1) IGE c) {		//	round up ratio if needed			r3 = r3 + 1;			if (r3 == 0) {				r2 = r2 + 1;				if (r2 == 0) r1 = r1 + 1;			}		}	end compute.local.ratio;	if Meter.Map.Ptr = 0				/*	if no meter map	*/	then return;						/*	nothing to do		*/	/*	lookup meter record basics	*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	nn = read(mdi);	/*	get numerator								*/	dd = read(mdi);	/*	get denominator							*/	cc = read(mdi);	/*	get midi clocks per click				*/	bb = read(md );	/*	get 32nd notes per beat displayed	*/	/*	Compute click ratios for this meter segment				*/	write(mal) = Meter.Map.Cur + Meter.Map.Rc.d;	/*	Rc.d = 24 / (divisions * cc)									*/	call compute.local.ratio(1,24,Divisions,cc);	write(mdi) = r1;	write(mdi) = r2;	write(mdi) = r3;	/*	Rd.c = (divisions * cc) / 24									*/	call compute.local.ratio(Divisions,cc,24,1);	write(mdi) = r1;	write(mdi) = r2;	write(mdi) = r3;	/*	Compute measure ratios for this meter segment			*/	/*	Rm.d = bb / (shl(1,5-dd) * nn * divisions)				*/	call compute.local.ratio(1,bb,shl(1,5-dd)*nn,Divisions);	write(mdi) = r1;	write(mdi) = r2;	write(mdi) = r3;	/*	Rd.m = (shl(1,5-dd) * nn * divisions) / bb				*/	call compute.local.ratio(shl(1,5-dd)*nn,Divisions,bb,1);	write(mdi) = r1;	write(mdi) = r2;	write(mdi) = r3;	/*	Compute beat ratios for this meter segment				*/	/*	Rb.d = bb / (shl(1,5-dd) * divisions)						*/	call compute.local.ratio(1,bb,shl(1,5-dd),Divisions);	write(mdi) = r1;	write(mdi) = r2;	write(mdi) = r3;	/*	Rd.b = (shl(1,5-dd) * divisions) / bb						*/	call compute.local.ratio(shl(1,5-dd),Divisions,bb,1);	write(mdi) = r1;	write(mdi) = r2;	write(md ) = r3;end Update.Meter.Map.Ratios;/*	Handy routine to look up the BPM setting for a particular	*//*	sequence time:																*/Lookup.Beats.Per.Measure: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl (x,y)	fixed;	/*	if using click track or not using meter map, then use system beats per measure	*/	if (click.track.mode igt 3) or (Meter.Map.Ptr ieq 0) then return SAMP.BPM;	x = Seq.Time(0);	y = Seq.Time(1);	if ((x < 0)	||  ((x == 0) & (y ILT zero.time)))		/*	check for time less than	*/		{x=0; y = zero.time;}					/*	start of first segment		*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while ((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	return read(md);end Lookup.Beats.Per.Measure;/*	Handy routine to look up the denominator for a particular	*//*	sequence time:																*/Lookup.Denom: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl (x,y)	fixed;	if Meter.Map.Ptr = 0			/*	no meter map	*/	then do;		return 2;					/*	SAMP.BPM/4 time is the default		*/	end;	x = Seq.Time(0);	y = Seq.Time(1);	if ((x < 0)	||  ((x == 0) & (y ILT zero.time)))		/*	check for time less than	*/		{x=0; y = zero.time;}					/*	start of first segment		*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x = 	 Meter.Map.This.Seq.Msb)	/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.dd;	return read(md);end Lookup.Denom;/*	Routine to convert a long measures:beats.fraction to a long				*//*	beats.fraction.  Simplifies other routines									*//*	Note on the following routines:  The real routines handle 32-bit		*//*	measure numbers or 32-bit beat numbers.  "glue" routines are			*//*	provided to handle calls from earlier single precision external		*//*	software.  The plan is to eventually change over to the long			*//*	routines everywhere																	*/Convert.Long.Measures.Beats.To.Long.Beats: proc (Measures, Beats) public swapable;	dcl Measures	array;	dcl Beats		array;	dcl meas(3)		fixed;	dcl temp(1)		fixed;	dcl bpm			fixed;	dcl sign			fixed;	/*	Note:  Measures(0) = msb # of measures								*/	/*			 Measures(1) = lsb # of measures								*/	/*			 Measures(2) = integer # of beats into next measure	*/	/*			 Measures(3) = thousandths of a beat						*/	/*	Note:  Beats   (0) = msb # of beats									*/	/*			 Beats   (1) = lsb # of beats									*/	/*			 Beats   (2) = thousandths of a beat						*/	/*	Note: minus input  values indicated by measures(2) and measures(3) being negated	*/	/*			minus output values indicated by negated beats0:1 and beats2					*/	meas(0) = Measures(0);	/*	copy callers data into temp	*/	meas(1) = Measures(1);	/*	buffer in case the output		*/	meas(2) = Measures(2);	/*	array is the same as the		*/	meas(3) = Measures(3);	/*	input array							*/	if (meas(2) < 0 || meas(3) < 0)	{		meas(2) = -meas(2);		meas(3) = -meas(3);		sign = -1;	}	else		sign = +1;	if Meter.Map.Ptr = 0					/*	if no meter map, then compute	*/	then do;		load meas(0); mul SAMP.BPM;	/*	compute msb # of beats			*/		Beats(0) = res;		load meas(1); mul SAMP.BPM;	/*	compute lsb # of beats			*/		Beats(0) = Beats(0) + ures;		Beats(1) = res;		call ADD16(meas(2), Beats);	/*	add in beats into measure		*/		Beats(2) = meas(3);				/*	copy beat fraction				*/		if (sign < 0)		{			if (beats(1) == 0) beats(0) = -beats(0);			else {beats(1) = -beats(1); beats(0) = ~beats(0);}			beats(2) = -beats(2);		}		return;	end;	/*	Find the meter segment that contains this measure number.	*/	if (sign < 0)	{		do while	((0 ILT Meter.Map.This.Measure.Msb))			/*	back up if we are		*/		or			((0 =   Meter.Map.This.Measure.Msb)				/*	before start of		*/		and		 (0 ILT Meter.Map.This.Measure.Lsb));			/*	this segment.			*/			Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;	}	else	{		do while	((meas(0) ILT Meter.Map.This.Measure.Msb))	/*	back up if we are		*/		or			((meas(0) =   Meter.Map.This.Measure.Msb)		/*	before start of		*/		and		 (meas(1) ILT Meter.Map.This.Measure.Lsb));	/*	this segment.			*/			Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;		do while	((meas(0) IGT Meter.Map.Next.Measure.Msb))	/*	skip ahead if we are	*/		or			((meas(0) =   Meter.Map.Next.Measure.Msb)		/*	after end of this		*/		and		 (meas(1) IGE Meter.Map.Next.Measure.Lsb)		/*	segment (check for	*/		and		 (meas(0) <>  (-1)							 ));	/*	infinite loop).		*/			Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;	}	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	bpm = read(md);	/*	compute how many full measures into this segment we are:				*/	call SUB32(meas, loc(addr(Meter.Map.This.Measure.Msb)), temp);	load temp(0); mul bpm;				/*	now multiply that many measures	*/	Beats(0) = res;						/*	by the bpm for this segment		*/	load temp(1); mul bpm;				/*	do both msb & lsb						*/	Beats(0) = Beats(0) + ures;	Beats(1) = res;						/*	full 32 bit beat #					*/	/*	Add in the beat # for the start of this segment:						*/	call ADD32(Beats, loc(addr(Meter.Map.This.Beat.Msb)), Beats);	call ADD16(meas(2), Beats);		/*	add in beats into measure			*/	Beats(2) = meas(3);					/*	copy fractional part of a beat	*/	if (sign < 0)	{		if (beats(1) == 0) beats(0) = -beats(0);		else {beats(1) = -beats(1); beats(0) = ~beats(0);}		beats(2) = -beats(2);	}end Convert.Long.Measures.Beats.To.Long.Beats;/*	$page - Map Sequence Time to Nearest Range								*//*	The following routine is used to find the times of the prior		*//*	and next click, prior and next beat, or prior and next measure.	*//*	It is passed a sequence time and a ratio code, and returns			*//*	a prior time, a next time, and a 32-bit integer Range.Count.		*//*	Range.Count is the number of clicks, beats or measures from the	*//*	start of the sequence up to the identified range of times.			*//*	Range.Count is not necessarily valid for click ranges because we	*//*	don't store the accumulated # of clicks at the start of every		*//*	segment.																				*/dcl Range.Count.Msb	fixed;	/*	Also sometimes needed by calling		*/dcl Range.Count.Lsb	fixed;	/*	procedure									*/Map.Sequence.Time.To.Nearest.Range: proc(Seq.Time, Prior.Time, Next.Time, Ratio) public swapable;	dcl Seq.Time	array;	/*	32-bit millisecond sequence time			*/	dcl Prior.Time	array;	/*	returns 32-bit millisecond prior click	*/	dcl Next.Time	array;	/*	returns 32-bit millisecond next click	*/	dcl Ratio		fixed;	/*	pointer to which ratio to use				*/									/*		Rc.d for prior & next click			*/									/*		Rb.d for prior & next beat				*/									/*		Rm.d for prior & next measure			*/	dcl rate			fixed;	dcl (i,j)		fixed static;	dcl (x,y)		fixed static;	dcl loc.Rc.d	fixed static;	dcl loc.Rd.c	fixed static;	dcl loc.base	fixed static;	/*	Carefully written and called subroutine that preserves registers	*/	/*	over procedure call:																*/	multiply.sub:proc;		load read(a2); mul read(md );	/*	compute msb*r1							*/			write(add0 ) = res;			/*	add to msb								*/		load read(a3); mul read(mdi);	/*	compute lsb*r1							*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a2); mul read(md );	/*	compute msb*r2							*/			x				 = read(mdi);	/*	stash r2 while mul/div is busy	*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a3); mul read(md );	/*	compute lsb*r3 for rounding		*/			y = ures;						/*	save upper only (as new llsb)		*/		load read(a3); uload y;			/*	get lsb & rounding amount			*/			mul x;							/*	compute lsb*r2 + 1/2					*/			write(add1)	 = ures;			/*	add to lsb								*/			y				 = res;			/*	save llsb								*/		load read(a2); uload y;			/*	load msb, preserve prior llsb		*/			mul read(md);					/*	compute msb*r3 + prior llsb		*/			write(addc0) = 0;				/*	add PREVIOUS carry only to msb	*/												/*	while multiply is going on !!		*/			write(add1)	 = ures;			/*	add to lsb								*/			write(addc0) = 0;				/*	add carry only to msb				*/	end multiply.sub;	x = Seq.Time(0);						/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)	/*	check for time less than		*/	then do;									/*	start of first segment			*/		call STR32(0, 0, Prior.Time);				/*	prior						*/		call STR32(0, zero.time, Next.Time);	/*	next						*/		Range.Count.Msb = 0;							/*	range count really	*/		Range.Count.Lsb = 0;							/*	should be minus one	*/		return;											/*	or something here		*/	end;	if Meter.Map.Ptr = 0								/*	if no meter map, then	*/	then do;												/*	compute using modulo		*/		if Ratio = Meter.Map.Rm.d					/*	if using measures		*/		then rate = SAMP.CLICK.RATE*SAMP.BPM;	/*	ticks per meas			*/		else rate = SAMP.CLICK.RATE;				/*	ticks per click/beat	*/		call COPY32(loc(addr(x)),Prior.Time);	/*	init prior time		*/		call SUB16(zero.time,loc(addr(x)));		/*	remove zero.time		*/		load x; div rate;								/*	compute msb				*/		Range.Count.Msb = res; i = rem;			/*	get msb, remainder	*/		load y; uload i; div rate;					/*	compute lsb, mod		*/		Range.Count.Lsb = res;		call SUB16(rem,Prior.Time);				/*	back to boundary		*/		call COPY32(Prior.Time,Next.Time);		/*	good for all			*/		call ADD16(rate,Next.Time);				/*	times						*/		return;	end;	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	Compute pointers and store them in static variables so we can		*/	/*	access the ratios during assembly language segments:					*/	loc.Rc.d = Meter.Map.Cur + Ratio;	loc.Rd.c = Meter.Map.Cur + Ratio + (Meter.Map.Rd.c - Meter.Map.Rc.d);	if Ratio = Meter.Map.Rm.d	then loc.base = Meter.Map.Cur + Meter.Map.Measure#.Msb;	/*	meas				*/	else loc.base = Meter.Map.Cur + Meter.Map.Beat#.Msb;		/*	beats/clicks	*/	write(mam) = Meter.Map.Ptr;			/*	set up ptrs to begin		*/	write(mal) = Meter.Map.Cur;			/*	of this record				*/	/*	Compute delta time from start of this meter segment to the	*/	/*	passed sequencer time.  Store in ac2-ac3:							*/	write(a2) = x;		/*	get passed sequence time in ac2-ac3			*/	write(a3) = y;		/*	as a 32-bit number								*/	write(sub2) = read(mdi);	/*	subtract start of this meter		*/	write(sub3) = read(mdi);	/*	segment from passed time			*/	write(subb2) = 0;				/*	propagate borrow						*/	write(a0) = 0;					/*	initialize number of ranges		*/	write(a1) = 0;					/*	into segment							*/	write(mal) = loc.Rc.d;		/*	point at Rc.d, Rb.d, Rm.d			*/	/*	now multiply delta (ac2-ac3) by clicks/delta ratio for num.clicks	*/	call multiply.sub;	/*	multiply ac2/ac3 by ratio and add to ac0/ac1	*/								/*	(truncate here instead of round)					*/	write(a2) = read(a0);				/*	move full 32-bit click count	*/	write(a3) = read(a1);				/*	to a2/a3								*/	Range.Count.Msb = read(a2);		/*	save count of ranges into		*/	Range.Count.Lsb = read(a3);		/*	this segment for later use		*/	/*	now compute start and end time for this range, and then check	*/	/*	for unusual round-off conditions that might mean the passed		*/	/*	sequence time is actually in the next range:							*/	write(mal) = Meter.Map.Cur;	write(a0) = read(mdi);				/*	copy seg start time into a0-a1	*/	write(a1) = read(md );				/*	as a 32-bit number					*/	write(mal) = loc.Rd.c;				/*	point at Rd.c, Rd.b, Rd.m			*/	/*	now multiply by full clicks (ac2-ac3) by delta/click ratio			*/	call multiply.sub;	/*	multiply ac2/ac3 by ratio and add to ac0/ac1	*/	/*	round up to next delta division boundary:									*/	write(tloa2) = res;					/*	test result in a2; check sign		*/	write(rtpl ) = 2;						/*	if >=0, no rounding needed			*/	write(add1 ) = 1;						/*	round by 1 msec						*/	write(addc0) = 0;						/*	propagate carry						*/	i = read(a0);		/*	move to static variables to avoid glomming		*/	j = read(a1);		/*	registers with subscript computations				*/	/*	increment to next click boundary and check again to get 100%		*/	/*	accurate results with all rounding cases									*/	write(add3 ) = 1;						/*	increment to next click				*/	write(addc2) = 0;						/*	add carry to msb						*/	write(mal) = Meter.Map.Cur;	write(a0) = read(mdi);				/*	copy seg start time into a0-a1	*/	write(a1) = read(md );				/*	as a 32-bit number					*/	write(mal) = loc.Rd.c;				/*	point at Rd.c, Rd.b, Rd.m			*/	/*	now multiply by full clicks (ac2-ac3) by delta/click ratio			*/	call multiply.sub;	/*	multiply ac2/ac3 by ratio and add to ac0/ac1	*/	/*	round up to next delta division boundary:									*/	write(tloa2) = res;					/*	test result in a2; check sign		*/	write(rtpl ) = 2;						/*	if >=0, no rounding needed			*/	write(add1 ) = 1;						/*	round by 1 msec						*/	write(addc0) = 0;						/*	propagate carry						*/	x = read(a0);		/*	move to static variables to avoid glomming		*/	y = read(a1);		/*	registers with subscript computations				*/	/*	Check for round off here.  Might happen that next.click is			*/	/*	actually <= passed sequencer time.  Advance again if so.				*/	if COM32(loc(addr(x)), Seq.Time) <= LW#IEQ	then do;		i = x;									/*	copy computed next time			*/		j = y;									/*	back to prior time				*/		write(a2) = Range.Count.Msb;		/*	get last range count we use	*/		write(a3) = Range.Count.Lsb;		write(add3 ) = 1;						/*	increment to next range			*/		write(addc2) = 0;						/*	add carry to msb					*/		Range.Count.Msb = read(a2);		/*	this is our new range count	*/		Range.Count.Lsb = read(a3);		write(add3 ) = 1;						/*	increment to next range			*/		write(addc2) = 0;						/*	add carry to msb					*/		write(mal) = Meter.Map.Cur;		write(a0) = read(mdi);				/*	copy seg start time into a0-a1	*/		write(a1) = read(md );				/*	as a 32-bit number					*/		write(mal) = loc.Rd.c;				/*	point at Rd.c, Rd.b, Rd.m			*/		/*	now multiply by full clicks (ac2-ac3) by delta/click ratio			*/		call multiply.sub;	/*	multiply ac2/ac3 by ratio and add to ac0/ac1	*/		/*	round up to next delta division boundary:								*/		write(tloa2) = res;					/*	test result in a2; check sign	*/		write(rtpl ) = 2;						/*	if >=0, no rounding needed		*/		write(add1 ) = 1;						/*	round by 1 msec					*/		write(addc0) = 0;						/*	propagate carry					*/		x = read(a0);		/*	move to static variables to avoid glomming	*/		y = read(a1);		/*	registers with subscript computations			*/	end;	Prior.Time(0) = i;	/*	return sequence times of start of range		*/	Prior.Time(1) = j;	/*	and end of range.  Will be fully accurate		*/	Next.Time(0)  = x;	/*	for all rounding conditions						*/	Next.Time(1)  = y;	write(mal)		 = loc.base;			/*	get starting beat/msr #			*/	write(a0)		 = read(mdi);	write(a1)		 = read(mdi);	write(add1)		 = Range.Count.Lsb;	/*	compute absolute range count	*/	write(addc0)	 = Range.Count.Msb;	Range.Count.Msb = read(a0);	Range.Count.Lsb = read(a1);end Map.Sequence.Time.To.Nearest.Range;/*	$page Routine to find prior and next click of passed sequence time	*/Map.Sequence.Time.To.Nearest.Clicks: proc(Seq.Time, Prior.Click, Next.Click) public swapable;	dcl Seq.Time	 array;		/*	32-bit millisecond sequence time			*/	dcl Prior.Click array;		/*	returns 32-bit millisecond prior click	*/	dcl Next.Click  array;		/*	returns 32-bit millisecond next click	*/	call Map.Sequence.Time.To.Nearest.Range(Seq.Time, Prior.Click, Next.Click, Meter.Map.Rc.d);end Map.Sequence.Time.To.Nearest.Clicks;/*	$page Routine to find prior and next beat of passed sequence time		*/Map.Sequence.Time.To.Nearest.Beats: proc(Seq.Time, Prior.Beat, Next.Beat) public swapable;	dcl Seq.Time	array;		/*	32-bit millisecond sequence time			*/	dcl Prior.Beat	array;		/*	returns 32-bit millisecond prior beat	*/	dcl Next.Beat	array;		/*	returns 32-bit millisecond next beat	*/	call Map.Sequence.Time.To.Nearest.Range(Seq.Time, Prior.Beat, Next.Beat, Meter.Map.Rb.d);end Map.Sequence.Time.To.Nearest.Beats;/*	$page Routine to find prior and next measure of passed sequence time	*/Map.Sequence.Time.To.Nearest.Measures: proc(Seq.Time, Prior.Measure, Next.Measure) public swapable;	dcl Seq.Time		array;	/*	32-bit millisecond sequence time			*/	dcl Prior.Measure	array;	/*	returns 32-bit millisecond prior meas	*/	dcl Next.Measure	array;	/*	returns 32-bit millisecond next meas	*/	call Map.Sequence.Time.To.Nearest.Range(Seq.Time, Prior.Measure, Next.Measure, Meter.Map.Rm.d);end Map.Sequence.Time.To.Nearest.Measures;/*	$page Routine to map sequence time to beat number & fraction	*//*	Routine to map sequence time to beats:fractions using a long	*//*	(i.e. 32-bit) variable for beats:										*/Map.Sequence.Time.To.Long.Beats: proc (Seq.Time, Beats) public swapable;	dcl Seq.Time	array;	dcl Beats		array;	dcl prior(1)	fixed;	dcl next (1)	fixed;	dcl delta		fixed;	dcl offset		fixed;	dcl sign			fixed;	/*	Note:  Beats (0) = msb # of beats			*/	/*			 Beats (1) = lsb # of beats			*/	/*			 Beats (2) = thousandths of a beat	*/	if (Seq.Time(0) < 0)	{		if (Seq.Time(1) == 0) Seq.Time(0) = -Seq.Time(0);		else {Seq.Time(1) = -Seq.Time(1); Seq.Time(0) = ~Seq.Time(0);}		sign = -1;	}	else		sign = +1;	if (Seq.Time(0) = 0) & (Seq.Time(1) ILT zero.time)	/*	check for	*/	then do;									/*	before start of first segment	*/		Beats(0) = 0;						/*	beat number							*/		Beats(1) = 1;						/*	beat number							*/		Beats(2) = 0;						/*	beat fractions						*/		if (sign < 0)		{			if (Beats(1) == 0) Beats(0) = -Beats(0);			else {Beats(1) = -Beats(1); Beats(0) = ~Beats(0);}			Beats(2) = -Beats(2);		}		return;	end;	/*	Begin by computing beat boundaries of before and after this beat:	*/	call Map.Sequence.Time.To.Nearest.Beats(Seq.Time, prior, next);	delta  = next(1)     - prior(1);	/*	get current beat delta		*/	offset = Seq.Time(1) - prior(1);	/*	get how far into beat		*/	Beats(0) = Range.Count.Msb;		/*	get 32 bit # of beats		*/	Beats(1) = Range.Count.Lsb;		/*	plus add one to start		*/	call ADD16(1, Beats);				/*	counting at beat 1			*/	load offset; mul 1000; mwait; div delta;	Beats(2) = res;	if shl(rem,1) ige delta then Beats(2)=Beats(2)+1;		/*	round	*/	if Beats(2) = 1000 then do;	/*	if rounded up to a whole		*/		Beats(2) = 0;					/*	zero fraction						*/		call ADD16(1, Beats);		/*	round up to next beat			*/	end;	if (sign < 0)	{		if (Beats(1) == 0) Beats(0) = -Beats(0);		else {Beats(1) = -Beats(1); Beats(0) = ~Beats(0);}		Beats(2) = -Beats(2);	}end Map.Sequence.Time.To.Long.Beats;/*	A temporary version that returns only 16-bits of beat number:	*/Map.Sequence.Time.To.Beats: proc (Seq.Time, Beats) public swapable;	dcl Seq.Time	array;	dcl Beats		array;	dcl Temp (2)	fixed;	/*	Note:  Beats(0) = integer # of beats		*/	/*			 Beats(1) = thousandths of a beat	*/	call Map.Sequence.Time.To.Long.Beats (Seq.Time, Temp);	Beats(0) = Temp(1);		/*	return only 16-bits of beat number	*/	Beats(1) = Temp(2);		/*	for external old routines				*/end Map.Sequence.Time.To.Beats;/*	Here is the inverse routine that maps a full resolution beat #	*//*	to a sequence time:															*/Map.Long.Beats.To.Sequence.Time: proc (Beats, Seq.Time) public swapable;	dcl Beats		array;	dcl Seq.Time	array;	dcl beat(2)		fixed;	dcl delta		fixed;	dcl sign			fixed;	dcl x				fixed static;	dcl y				fixed static;	dcl b				fixed static;	dcl b1			fixed static;	dcl p				fixed static;	dcl prior.msb	fixed static;	dcl prior.lsb	fixed static;	dcl next.lsb	fixed static;	/*	Carefully written and called subroutine that preserves registers	*/	/*	over procedure call:																*/	multiply.sub:proc;		load read(a2); mul read(md );	/*	compute msb*r1							*/			write(add0 ) = res;			/*	add to msb								*/		load read(a3); mul read(mdi);	/*	compute lsb*r1							*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a2); mul read(md );	/*	compute msb*r2							*/			x				 = read(mdi);	/*	stash r2 while mul/div is busy	*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a3); mul read(md );	/*	compute lsb*r3 for rounding		*/			y = ures;						/*	save upper only (as new llsb)		*/		load read(a3); uload y;			/*	get lsb & rounding amount			*/			mul x;							/*	compute lsb*r2 + 1/2					*/			write(add1)	 = ures;			/*	add to lsb								*/			y				 = res;			/*	save llsb								*/		load read(a2); uload y;			/*	load msb, preserve prior llsb		*/			mul read(md);					/*	compute msb*r3 + prior llsb		*/			write(addc0) = 0;				/*	add PREVIOUS carry only to msb	*/												/*	while multiply is going on !!		*/			write(add1)	 = ures;			/*	add to lsb								*/			write(addc0) = 0;				/*	add carry only to msb				*/	end multiply.sub;	/*	Note:  Beats (0) = msb # of beats			*/	/*			 Beats (1) = lsb # of beats			*/	/*			 Beats (2) = thousandths of a beat	*/	beat(0) = Beats(0);	/*	full beat # msb		*/	beat(1) = Beats(1);	/*	beat # lsb				*/	beat(2) = Beats(2);	/*	beat fraction			*/	if (beat(0) < 0 || beat(2) < 0)	{		if (beat(1) == 0) beat(0) = -beat(0);		else {beat(1) = -beat(1); beat(0) = ~beat(0);}		beat(2) = -beat(2);		sign = -1;	}	else		sign = +1;	if COM16(0, beat) = LW#IEQ			/*	check for beat 0					*/	then do;		Seq.Time(0) = 0;					/*	set up zero time					*/		Seq.Time(1) = zero.time;		if (sign < 0)		{			if (Seq.Time(1) == 0) Seq.Time(0) = -Seq.Time(0);			else {Seq.Time(1) = -Seq.Time(1); Seq.Time(0) = ~Seq.Time(0);}		}		return;								/*	and return							*/	end;	call SUB16(1, beat);					/*	now count from beat 0			*/	if Meter.Map.Ptr = 0					/*	if no meter map, then compute	*/	then do;		load beat(0); mul SAMP.CLICK.RATE;				/*	msb beats		*/		Seq.Time(0) = res;		load beat(1); mul SAMP.CLICK.RATE;				/*	lsb beats		*/		Seq.Time(0) = Seq.Time(0) + ures;		Seq.Time(1) = res;		call ADD16(zero.time, Seq.Time);					/*	add zero.time	*/		load beat(2); mul SAMP.CLICK.RATE;				/*	beat fractions	*/		mwait; div 1000;		if rem ige (shr(1000,1)) then load res+1;		call ADD16(res, Seq.Time);		if (sign < 0)		{			if (Seq.Time(1) == 0) Seq.Time(0) = -Seq.Time(0);			else {Seq.Time(1) = -Seq.Time(1); Seq.Time(0) = ~Seq.Time(0);}		}		return;	end;	/*	Find the meter segment that contains this beat number.	*/	if (sign < 0)	{		do while	((0 ILT Meter.Map.This.Beat.Msb))		or			((0 =   Meter.Map.This.Beat.Msb)		and		 (0 ILT Meter.Map.This.Beat.Lsb));			Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;	}	else	{		do while	((beat(0) ILT Meter.Map.This.Beat.Msb))		or			((beat(0) =   Meter.Map.This.Beat.Msb)		and		 (beat(1) ILT Meter.Map.This.Beat.Lsb));			Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;		do while	((beat(0) IGT Meter.Map.Next.Beat.Msb))		or			((beat(0) =   Meter.Map.Next.Beat.Msb)		and		 (beat(0) INE (-1)						 )		and		 (beat(1) IGE Meter.Map.Next.Beat.Lsb));			Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;		end;	}	/*	Compute number of beats into this meter segment:	*/	call SUB32(beat, loc(addr(Meter.Map.This.Beat.Msb)), beat);	b	= beat(0);								/*	get whole beats in static		*/	b1	= beat(1);	p	= Meter.Map.Cur+Meter.Map.Rd.b;	/*	and pointer to ratio				*/	write(mam) = Meter.Map.Ptr;			/*	point at ratio of sequencer	*/	write(mal) = p;							/*	divisions per beat				*/	write(a0 ) = Meter.Map.This.Seq.Msb;	/*	get seq time of start of	*/	write(a1 ) = Meter.Map.This.Seq.Lsb;	/*	meter segment					*/	write(a2 ) = b;							/*	get whole # of beats				*/	write(a3 ) = b1;							/*	into segment						*/	call multiply.sub;	/*	compute a2-a3 * ratio and add to a0-a1			*/	write(tloa2) = res;						/*	test result in a2; check sign	*/	write(rtpl ) = 2;							/*	if >=0, no rounding needed		*/	write(add1 ) = 1;							/*	round by 1 msec					*/	write(addc0) = 0;							/*	propagate carry					*/	prior.msb = read(a0);					/*	save away sequencer time		*/	prior.lsb = read(a1);					/*	of start of this whole beat	*/	/*	Now compute the sequencer time of the next whole beat.  Subtracting	*/	/*	the two will give the precise number of sequencer division in this	*/	/*	beat for all round off cases.  Will match exactly map.sequence.		*/	/*	time.to.nearest.range.																*/	write(mal) = p;							/*	restore pointer to ratio		*/	write(a0 ) = Meter.Map.This.Seq.Msb;	/*	get seq time of start of	*/	write(a1 ) = Meter.Map.This.Seq.Lsb;	/*	meter segment					*/	write(add3 ) = 1;							/*	increment beat # to next		*/	write(addc2) = 0;							/*	beat									*/	call multiply.sub;	/*	compute a2-a3 * ratio and add to a0-a1			*/	write(tloa2) = res;						/*	test result in a2; check sign	*/	write(rtpl ) = 2;							/*	if >=0, no rounding needed		*/	write(add1 ) = 1;							/*	round by 1 msec					*/	write(addc0) = 0;							/*	propagate carry					*/	next.lsb = read(a1);						/*	get next; need lsb only			*/	Seq.Time(0) = prior.msb;				/*	start at time of prior beat	*/	Seq.Time(1) = prior.lsb;	delta = next.lsb - prior.lsb;			/*	get duration of this beat		*/	load beat(2);			/*	convert fractional beats 0-999 to sequencer deltas	*/	mul  delta;	mwait;	div 1000;	if rem ige (shr(1000,1)) then load res+1;	call ADD16(res, Seq.Time);				/*	now compute sequence time		*/	if (sign < 0)	{		if (Seq.Time(1) == 0) Seq.Time(0) = -Seq.Time(0);		else {Seq.Time(1) = -Seq.Time(1); Seq.Time(0) = ~Seq.Time(0);}	}end Map.Long.Beats.To.Sequence.Time;/*	Similar routine for 16-bit bit numbers used externally until	*//*	not needed any more:															*/Map.Beats.To.Sequence.Time: proc (Beats, Seq.Time) public swapable;	dcl Beats		array;	dcl Seq.Time	array;	dcl temp(2)		fixed;	/*	Note:  Beats(0) = integer # of beats		*/	/*			 Beats(1) = thousandths of a beat	*/	if ((Beats(0) < 0) || (Beats(1) < 0))		temp(0) = -1;	else		temp(0) = 0;	temp(1) = Beats(0);	temp(2) = Beats(1);	call Map.Long.Beats.To.Sequence.Time(temp, Seq.Time);end Map.Beats.To.Sequence.Time;/*	$page Routine to map sequence time to measures and beats	*//*	Routine to map a sequence time to measures:beats.fraction.  Returns	*//*	full 32 bit measure #																*/Map.Sequence.Time.To.Long.Measures.Beats: proc (Seq.Time, Measures) public swapable;	dcl Seq.Time	array;	dcl Measures	array;	dcl prior(1)	fixed;	dcl next (1)	fixed;	dcl delta		fixed;	dcl offset		fixed;	dcl rate			fixed;	dcl sign			fixed;	/*	Note:  Measures(0) = msb # of measures								*/	/*			 Measures(1) = lsb # of measures								*/	/*			 Measures(2) = integer # of beats into next measure	*/	/*			 Measures(3) = thousandths of a beat						*/	if (Seq.Time(0) < 0)	{		if (Seq.Time(1) == 0) Seq.Time(0) = -Seq.Time(0);		else {Seq.Time(1) = -Seq.Time(1); Seq.Time(0) = ~Seq.Time(0);}		sign = -1;	}	else		sign = +1;	if (Seq.Time(0) = 0) & (Seq.Time(1) ILT zero.time)	/*	check for	*/	then do;									/*	before start of first segment	*/		Measures(0) = 0;					/*	measure number						*/		Measures(1) = 0;		Measures(2) = 1;					/*	beat number							*/		Measures(3) = 0;					/*	beat fractions						*/		if (sign < 0)		{			Measures(2) = -Measures(2);			Measures(3) = -Measures(3);		}		return;	end;	/*	Begin by computing meas boundaries of before and after this meas:	*/	call Map.Sequence.Time.To.Nearest.Measures(Seq.Time, prior, next);	delta	 = next(1)     - prior(1);	/*	get divisions in this meas		*/	offset = Seq.Time(1) - prior(1);	/*	get how far into measure		*/	rate	 = Lookup.Beats.Per.Measure(Seq.Time);	Measures(0) = Range.Count.Msb;	/*	msb # of measures					*/	Measures(1) = Range.Count.Lsb;	/*	lsb # of measures					*/	load offset; mul rate;				/*	compute how many beats and		*/	mwait; div delta;						/*	fractions of beat we are into	*/	Measures(2) = res;					/*	measure								*/	load rem; mul 1000;					/*	compute fraction in				*/	mwait; div delta;						/*	thousandths of a beat			*/	if shl(rem,1) IGE delta	then load res+1;	Measures(3) = res;					/*	get thousandths of a beat		*/	if Measures(3) = 1000 then do;	/*	might have rounded to next		*/		Measures(3) = 0;					/*	beat.  If so, do so.				*/		Measures(2) = Measures(2) + 1;		if Measures(2) = rate then do;	/*	Might also have rounded to	*/			Measures(2) = 0;				/*	next measure						*/			call ADD16(1, Measures);		end;	end;	Measures(2) = Measures(2) + 1;	/*	now count with beat 1			*/	if (sign < 0)	{		Measures(2) = -Measures(2);		Measures(3) = -Measures(3);	}end Map.Sequence.Time.To.Long.Measures.Beats;/*	Glue routine to handle calls from routines with 16-bit measure #'s	*/Map.Sequence.Time.To.Measures.Beats: proc (Seq.Time, Measures) public swapable;	dcl Seq.Time array;	dcl Measures array;	dcl temp(3)	fixed;	/*	Note:  Measures(0) = integer # of measures						*/	/*			 Measures(1) = integer # of beats into next measure	*/	/*			 Measures(2) = thousandths of a beat						*/	call Map.Sequence.Time.To.Long.Measures.Beats(Seq.Time, temp);	Measures(0) = temp(1);				/*	return 16 bit measure # to	*/	Measures(1) = temp(2);				/*	old external routines		*/	Measures(2) = temp(3);end Map.Sequence.Time.To.Measures.Beats;/*	Contrary routines to map a measure time to a sequence time:		*/Map.Long.Measures.Beats.To.Sequence.Time: proc (Measures, Seq.Time) public swapable;	dcl Measures array;	dcl Seq.Time array;	dcl beats(2)	fixed;	/*	Note:  Measures(0) = msb # of measures								*/	/*			 Measures(1) = lsb # of measures								*/	/*			 Measures(2) = integer # of beats into next measure	*/	/*			 Measures(3) = thousandths of a beat						*/	call Convert.Long.Measures.Beats.To.Long.Beats(Measures, beats);	call Map.Long.Beats.To.Sequence.Time(beats, Seq.Time);end Map.Long.Measures.Beats.To.Sequence.Time;/*	Glue routine to handle calls from routines with 16-bit measure #'s	*/Map.Measures.Beats.To.Sequence.Time: proc (Measures, Seq.Time) public swapable;	dcl Measures array;	dcl Seq.Time array;	dcl meas (3)	fixed;	/*	Note:  Measures(0) = integer # of measures						*/	/*			 Measures(1) = integer # of beats into next measure	*/	/*			 Measures(2) = thousandths of a beat						*/	meas(0) = 0;	meas(1) = Measures(0);	meas(2) = Measures(1);	meas(3) = Measures(2);	call Map.Long.Measures.Beats.To.Sequence.Time (meas, Seq.Time);end Map.Measures.Beats.To.Sequence.Time;/*	Here are routines to map between sequence times and durations.		*//*	These all work on 16-bit measure #s and 16-bit beat numbers (for	*//*	now) because that should be adequate for note durations				*/Map.Sequence.Duration.To.Beats: proc (Seq.Time, Seq.Dur, Beats) public swapable;	dcl Seq.Time	array;	dcl Seq.Dur		array;	dcl Beats		array;	dcl begin.time(2)	fixed;	dcl end.time  (2)	fixed;	/*	Note:  Beats(0) = integer # of beats		*/	/*			 Beats(1) = thousandths of a beat	*/	call ADD32(Seq.Time,Seq.Dur,end.time);		/*	compute sequence end time	*/	call Map.Sequence.Time.To.Long.Beats(Seq.Time,begin.time);	/*	get beat # at start time	*/	call Map.Sequence.Time.To.Long.Beats(end.time,end.time  );	/*	get beat # at end time		*/	/*	compute duration to 16-bit accuracy for now	*/	Beats(0) = end.time(1) - begin.time(1);	/*	compute beat duration	*/	Beats(1) = end.time(2) - begin.time(2);	/*	and fraction				*/	if (Beats(1) < 0) then do;						/*	check for borrow			*/		Beats(0) = Beats(0) - 1;		Beats(1) = Beats(1) + 1000;	end;end Map.Sequence.Duration.To.Beats;Map.Beats.To.Sequence.Duration: proc (Seq.Time, Beats, Seq.Dur) public swapable;	dcl Seq.Time	array;	dcl Beats		array;	dcl Seq.Dur		array;	dcl begin.time(2)	fixed;	dcl end.time  (2)	fixed;	/*	Note:  Beats(0) = integer # of beats		*/	/*			 Beats(1) = thousandths of a beat	*/	call Map.Sequence.Time.To.Long.Beats(Seq.Time,begin.time);	/*	get beat # at start time	*/	call COPY32(begin.time, end.time);	call ADD16 (Beats(0), end.time);	end.time(2) = begin.time(2) + Beats(1);	/*	add fraction		*/	if end.time(2) >= 1000 then do;				/*	check for carry	*/		end.time(2) = end.time(2) - 1000;		call ADD16(1, end.time);					/*	add 1 whole beat	*/	end;	call Map.Long.Beats.To.Sequence.Time(end.time,end.time);		/*	compute seq time of end		*/	call SUB32(end.time,Seq.Time,Seq.Dur);		/*	calc duration in sequencer deltas	*/end Map.Beats.To.Sequence.Duration;Map.Sequence.Duration.To.Measures.Beats: proc (Seq.Time, Seq.Dur, Measures) public swapable;	dcl Seq.Time array;	dcl Seq.Dur  array;	dcl Measures array;	dcl bpm				fixed;	dcl beats(1)		fixed;	/*	Note:  Measures(0) = integer # of measures						*/	/*			 Measures(1) = integer # of beats into next measure	*/	/*			 Measures(2) = thousandths of a beat						*/	bpm = Lookup.Beats.Per.Measure(Seq.Time);	/*	get current bpm handy	*/	call Map.Sequence.Duration.To.Beats(Seq.Time, Seq.Dur, beats);	load beats(0); div bpm;		/*	only makes sense to return ms:beats		*/	Measures(0) = res;			/*	at current bpm.  Numbers will not make	*/	Measures(1) = rem;			/*	sense in all cases anyways					*/	Measures(2) = beats(1);end Map.Sequence.Duration.To.Measures.Beats;Map.Measures.Beats.To.Sequence.Duration: proc (Seq.Time, Measures, Seq.Dur) public swapable;	dcl Seq.Time	array;	dcl Measures	array;	/*	0 = measures, 1 = beats, 2 = fractions	*/	dcl Seq.Dur		array;	dcl bpm			fixed;	dcl beats(1)	fixed;	/*	Note:  Measures(0) = integer # of measures						*/	/*			 Measures(1) = integer # of beats into next measure	*/	/*			 Measures(2) = thousandths of a beat						*/	bpm = Lookup.Beats.Per.Measure(Seq.Time);	/*	get current bpm handy	*/	load	Measures(0);	mul	bpm;	beats(0) = res + Measures(1);	beats(1) = Measures(2);	call Map.Beats.To.Sequence.Duration(Seq.Time, beats, Seq.Dur);end Map.Measures.Beats.To.Sequence.Duration;Compute.Real.Time.Of.Next.Click: proc (Real.Time) public swapable;	dcl Real.Time array;	dcl Seq.Time(1)	fixed;	call Map.Real.Time.To.Sequence.Time(Real.Time,Seq.Time);	call Map.Sequence.Time.To.Nearest.Clicks(Seq.Time,														  loc(addr(Prior.Click.Msb)),														  loc(addr(Next.Click.Msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(Next.Click.Msb)),													loc(addr(Real.Time.Of.Next.Click.Msb)));end Compute.Real.Time.Of.Next.Click;Compute.Real.Time.Of.Next.Beat: proc (Real.Time) public swapable;	dcl Real.Time array;	dcl Seq.Time(1)	fixed;	call Map.Real.Time.To.Sequence.Time(Real.Time,Seq.Time);	call Map.Sequence.Time.To.Nearest.Beats(Seq.Time,														 loc(addr(Prior.Beat.Msb)),														 loc(addr(Next.Beat.Msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(Next.Beat.Msb)),													loc(addr(Real.Time.Of.Next.Beat.Msb)));end Compute.Real.Time.Of.Next.Beat;INSERT ':SYNRSOU:03-PRIM:042METRA';