/*	:SYNRSOU:03-PRIM:042METRB  -  More routines to manage Sequencer Meter Map	*//*Modified:1999/11/05 - TY  - Fixed a bug in "Create.Tempo.Map.From.Track" which allow unexpected results if						 the previously existing tempo map had any events between beats.1999/04/16 - TY  - Fixed bugs in "Advance.To.Next.Meter.Record" and "Backup.To.Prior.Meter.Record".1999/04/11 - TY  - Added "Convert.Mapped.To.Unmapped".1992/02/26 - PF  - Added support for block transfer of tempo/meter maps1991/06/19 - PF  - Added check for any notes on track during Check.Track.For.Tempo.Map1991/03/20 - PF  - Added routines for Create.Tempo.Map.From.Track1991/03/19 - cj  - moved more routines here1991/03/14 - cj  - moved some routines here1991/01/09 - PF  - added routines SET.CLICK.VALUE, LOOKUP.CLICK.VALUE, COMPUTE.LOOP.NEXT.CLICK1990/10/16 - PF  - Added Advance.To.Next.Meter.Record and Backup.To.Prior.Meter.Record1990/10/16 - PF  - Started this file*//*	this routine fetches the NTH record of a sequencer meter map:	*//*	returns 1 if that record was found.										*//*	returns 0 if that record is past the end of the list.  The		*//*	last record in the list is returned in this case, except			*//*	that A RECORD OF ALL ZEROES is returned if the list itself		*//*	is empty.																		*/Fetch.Sequencer.Meter.Map.Record: proc(record#, record) PUBLIC swapable;	dcl record#		array;	/*	pass record#		*/	dcl record		array;	/*	pass the record	*/	dcl temp (1)	fixed;	dcl comp (1)	fixed;	dcl last (1)	fixed;	dcl i				fixed;	dcl status		fixed;	status = 1;							/*	assume record will be found		*/	do i = 0 to Meter.Map.Rec.Len-1;		/*	initialize answer to			*/		record(i) = 0;							/*	all zeroes in case there	*/	end;											/*	are no records					*/	if Meter.Map.Ptr = 0						/*	if no meter map, then return	*/	then do;										/*	all zeroes with a record	*/		call STR32(0, 0, record#);			/*	# of all zeroes.				*/		return 0;								/*	past end of list				*/	end;	call COPY32(record#, temp);			/*	get record#						*/	write(mam) = Meter.Map.Ptr;			/*	get info handy for the		*/	write(mal) = Meter.Map.FP;				/*	record we are pointing		*/	Meter.Map.Cur = read(mdi);				/*	to.  Get Meter.Map.FP,		*/	Meter.Map.Len = read(mdi);				/*	Meter.Map.LP,					*/	comp(0) = read(mdi);						/*	Meter.Map.Rec#.Msb			*/	comp(1) = read(mdi);						/*	Meter.Map.Rec#.Lsb			*/	/*	back up to prior block if the record we want is before where	*/	/*	we are now:																		*/	do while COM32(temp, comp) = lw#ilt;	/*	back up in list to			*/		write(mam) = Meter.Map.Ptr;			/*	find the desired record.	*/		write(mal) = Meter.Map.REV;			/*	Indicates serious system	*/		if read(md) = 0							/*	error if we cannot			*/		then do;										/*	find it.							*/			call STR32(0, 0, record#);			call Normalize.Meter.Map.Cur;			return 0;								/*	strange error.					*/		end;		Meter.Map.Ptr = NAH.PTR + read(md);	/*	advance to next block		*/		write(mam) = Meter.Map.Ptr;			/*	get info handy for the		*/		write(mal) = Meter.Map.FP;				/*	record we are pointing		*/		Meter.Map.Cur = read(mdi);				/*	to.  Get Meter.Map.FP,		*/		Meter.Map.Len = read(mdi);				/*	Meter.Map.LP,					*/		comp(0) = read(mdi);						/*	Meter.Map.Rec#.Msb			*/		comp(1) = read(mdi);						/*	Meter.Map.Rec#.Lsb			*/	end;	/*	Now see if we want a record that is in the	*/	/*	next meter map sector:								*/	call COPY32(comp, last);	call ADD16 ((Meter.Map.Len - Meter.Map.Cur) / Meter.Map.Rec.Len, last);	do while COM32(temp, last) >= lw#ieq;	/*	go forward in list to		*/		write(mam) = Meter.Map.Ptr;			/*	find the desired record.	*/		write(mal) = Meter.Map.FOR;		if read(md) = 0							/*	if we reach end of list,	*/		then do;										/*	then return end one.			*/			call COPY32(last, temp);			call SUB16 (   1, temp);			status = 0;								/*	return last one				*/		end;		else do;			Meter.Map.Ptr = NAH.PTR + read(md);			write(mam) = Meter.Map.Ptr;		/*	get info handy for the		*/			write(mal) = Meter.Map.FP;			/*	record we are pointing		*/			Meter.Map.Cur = read(mdi);			/*	to.  Get Meter.Map.FP,		*/			Meter.Map.Len = read(mdi);			/*	Meter.Map.LP,					*/			comp(0) = read(mdi);					/*	Meter.Map.Rec#.Msb			*/			comp(1) = read(mdi);					/*	Meter.Map.Rec#.Lsb			*/			call COPY32(comp, last);			call ADD16 ((Meter.Map.Len - Meter.Map.Cur) / Meter.Map.Rec.Len, last);		end;	end;	/*	Compute pointer to desired record:	*/	Meter.Map.Cur = Meter.Map.Cur + ((temp(1) - comp(1))*Meter.Map.Rec.Len);	write(mam) = Meter.Map.Ptr;				/*	and now read it in.			*/	write(mal) = Meter.Map.Cur;	do i = 0 to Meter.Map.Rec.Len-1;		record(i) = read(mdi);	end;	/*	Remove the zero.time offset:			*/	if        COM16(zero.time, loc(addr(record(Meter.Map.Seq.Msb )))) = lw#igt	then call STR32(0, 0,      loc(addr(record(Meter.Map.Seq.Msb ))));	else call SUB16(zero.time, loc(addr(record(Meter.Map.Seq.Msb ))));	/*	Set up info for current pointer:	*/	call Normalize.Meter.Map.Cur;	return status;		/*	return record & tell user if it was the	*/							/*	last one in the list instead of the one	*/							/*	he asked for.										*/end Fetch.Sequencer.Meter.Map.Record;Fetch.Sequencer.Meter.Range: proc (tstart,tend,range) PUBLIC swapable;	dcl tstart	array;	dcl tend		array;	dcl range	array;	dcl (x,y)	fixed;	dcl offset	fixed;	if  (Meter.Map.Ptr = 0)							/*	if no meter map, then return		*/	or  ((tstart(0) = tend(0))						/*	also check for zero length range	*/	and (tstart(1) = tend(1)))						/*	- not allowed	*/	then do;		call STR32(0, 0, loc(addr(range(0))));	/*	return zeros	*/		call STR32(0, 0, loc(addr(range(2))));		return;	end;	x = tstart(0);										/*	copy start time into locals	*/	y = tstart(1);	/*	Find the meter segment that contains this delta time.		*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Rec#.Msb;					/*	point to record # at begin of sector	*/	range(0) = read(mdi);								/*	copy into our start range arg				*/	range(1) = read(md );	write(mal) = Meter.Map.FP;							/*	look up loc of first record within sector	*/	offset = (Meter.Map.Cur - read(md)) / Meter.Map.Rec.Len;		/*	compute how many records we are into sector	*/	call ADD16(offset,loc(addr(range(0))));		/*	compute absolute rec# of first record in range	*/	call COPY32(loc(addr(range(0))),loc(addr(range(2))));	/*	init ending range	*/	if  (x = Meter.Map.This.Seq.Msb)					/*	we are sitting at the exact start of this meter segment	*/	and (y = Meter.Map.This.Seq.Lsb)	then do;													/*	include this record in return range	*/		call ADD16(1,loc(addr(range(2))));	end;	x = tend(0);											/*	copy end time of range into handy locals	*/	y = tend(1);	/*	keep counting until we hit a start time beyond our range	*/	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;		call ADD16(1,loc(addr(range(2))));			/*	increment ending record#	*/	end;end Fetch.Sequencer.Meter.Range;/*	Routine to create a default meter map for debugging	*/Create.Experimental.Meter.Map: proc public swapable;	dcl i	fixed;	/*	Set up default meter map:	*/	/*		 0 -  4000 at 500  yields 1 click/beat		*/	/*	 4000 -  8000 at 1000 yields 1 click/2 beats	*/	/*	 8000 - 12000 at 250  yields 2 clicks/beat	*/	/*	12000 - 16000 at 500  yields 1 click/beat		*/	if PLAY <> 0							/*	cannot do so while playing	*/	then return;	if Meter.Map.Ptr <> 0				/*	if one is there already		*/	then call Erase.Meter.Map.Info;	/*	blow it away					*/	i = Allocate.Map.Block(0, 0, Meter.Map#);	if i = 0									/*	out of room for meter map.	*/	then return;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.FP;	write(mdi) = Meter.Map.First;	write(mdi) = Meter.Map.First + 4*Meter.Map.Rec.Len;	write(mdi) = 0;						/*	initialize record # to 0	*/	write(mdi) = 0;	write(mal) = Meter.Map.First;	write(mdi) = 0;		/*	delta-time of record 0			*/	write(mdi) = 50;	write(mdi) = 0;		/*	measure#								*/	write(mdi) = 0;	write(mdi) = 0;		/*	beat#									*/	write(mdi) = 0;	write(mdi) = 0;		/*	clicks/division					*/	write(mdi) = 131;	write(mdi) = 4719;	write(mdi) = 500;		/*	divisions/click					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	measures/division					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 2000;	/*	divisions/measure					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	beats/division						*/	write(mdi) = 131;	write(mdi) = 4719;	write(mdi) = 500;		/*	divisions/beat						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 4;		/*	nn										*/	write(mdi) = 0;		/*	dd										*/	write(mdi) = 0;		/*	cc										*/	write(mdi) = 0;		/*	bb										*/	write(mdi) = 0;		/*	delta-time of record 2			*/	write(mdi) = 4050;	write(mdi) = 0;		/*	measure#								*/	write(mdi) = 2;	write(mdi) = 0;		/*	beat#									*/	write(mdi) = 8;	write(mdi) = 0;		/*	clicks/division					*/	write(mdi) = 65;	write(mdi) = 35128;	write(mdi) = 1000;	/*	divisions/click					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	measures/division					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1000;	/*	divisions/measure					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	beats/division						*/	write(mdi) = 131;	write(mdi) = 4719;	write(mdi) = 500;		/*	divisions/beat						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 2;		/*	nn										*/	write(mdi) = 0;		/*	dd										*/	write(mdi) = 0;		/*	cc										*/	write(mdi) = 0;		/*	bb										*/	write(mdi) = 0;		/*	delta-time of record 3			*/	write(mdi) = 8050;	write(mdi) = 0;		/*	measure#								*/	write(mdi) = 6;	write(mdi) = 0;		/*	beat#									*/	write(mdi) = 16;	write(mdi) = 0;		/*	clicks/division					*/	write(mdi) = 262;	write(mdi) = 9438;	write(mdi) = 250;		/*	divisions/click					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	measures/division					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 4000;	/*	divisions/measure					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	beats/division						*/	write(mdi) = 65;	write(mdi) = 35128;	write(mdi) = 1000;	/*	divisions/beat						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 4;		/*	nn										*/	write(mdi) = 0;		/*	dd										*/	write(mdi) = 0;		/*	cc										*/	write(mdi) = 0;		/*	bb										*/	write(mdi) = 0;		/*	delta-time of record 4			*/	write(mdi) = 12050;	write(mdi) = 0;		/*	measure#								*/	write(mdi) = 7;	write(mdi) = 0;		/*	beat#									*/	write(mdi) = 20;	write(mdi) = 0;		/*	clicks/division					*/	write(mdi) = 131;	write(mdi) = 4719;	write(mdi) = 500;		/*	divisions/click					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	measures/division					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 2000;	/*	divisions/measure					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	beats/division						*/	write(mdi) = 131;	write(mdi) = 4719;	write(mdi) = 500;		/*	divisions/beat						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 4;		/*	nn										*/	write(mdi) = 0;		/*	dd										*/	write(mdi) = 0;		/*	cc										*/	write(mdi) = 0;		/*	bb										*/	write(mdi) = -1;		/*	set up + infinity for start times	*/	write(mdi) = -1;		/*	of non-existent next segment.			*/	write(mdi) = -1;	write(mdi) = -1;	write(mdi) = -1;	write(mdi) = -1;	Meter.Map.Len = Meter.Map.First + 4*Meter.Map.Rec.Len;	/*	word end of map in this sector	*/	Meter.Map.Cur = Meter.Map.First;	/*	Set up info for current pointer:	*/	call Normalize.Meter.Map.Cur;	call PLAY.INITIALIZE;	/*	recompute all sequencer variables	*/	/*	Create a system event since some constants have likely changed:	*/	New.Seq.Info = New.Seq.Info \ 8;end Create.Experimental.Meter.Map;/*	Routine to advance sequencer to start time of next meter segment	*/Advance.To.Next.Meter.Record: proc public swapable;	dcl (x,y)	fixed;	if (Meter.Map.Ptr == 0) return;	call stop.recd.move.play;	disable;		x = play.time.msb;		y = play.time.lsb;	enable;	if (x = 0) & (y ILT zero.time)	/*	check for time less than	*/	then y = zero.time;					/*	start of first segment		*/	/*	compute sequence time in order to search for segment	*/	call Map.Real.Time.To.Sequence.Time(loc(addr(x)),loc(addr(x)));	//	Bug Fix: If you had two adjacent records with the same meter, and you changed the tempo of	//	the first, then advanced to the second, the upper display would not update.  This happened	//	because the checksum in "Check.For.Tempo.Meter.Events" was not updated since the meter was changed.	//	Hence, we will first call "Check.For.Tempo.Meter.Events" to update the checksum for proper comparison	//	with the record we are about to advance to.	Check.For.Tempo.Meter.Events(loc(addr(x)));	/*	Find the meter segment that contains this real time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	now get start time of next meter seqment	*/	x = Meter.Map.Next.Seq.Msb;	y = Meter.Map.Next.Seq.Lsb;	if  (x = (-1))							/*	check for no next segment	*/	and (y = (-1))	then do;											/*	do nothing	*/		call display.sequencer.status;		//	show that we stopped		broadcast.mtc();		return;	end;	/*	must pass real time to advance.sequencer		*/	call Map.Sequence.Time.To.Real.Time(loc(addr(x)),loc(addr(x)));	move = 1; move.speed = 1;	call display.sequencer.status;	call advance.sequencer(x,y);	move = 0; move.speed = 0;	call display.sequencer.status;	//	Without the following line, the lower display will not be updated when advancing to	//	an event at the next beat.	new.beat.number = true;	broadcast.mtc();end Advance.To.Next.Meter.Record;/*	Routine to backup sequencer to prior meter segment	*/Backup.To.Prior.Meter.Record: proc public swapable;	dcl (x,y)	fixed;	if (Meter.Map.Ptr == 0) return;	call stop.recd.move.play;	disable;		x = play.time.msb;		y = play.time.lsb;	enable;	if (x = 0) and (y ile zero.time)			/*	sequencer is already at zero	*/	then do;											/*	do nothing	*/		call display.sequencer.status;		//	show that we stopped		broadcast.mtc();		return;	end;	/*	compute sequence time in order to search for segment	*/	call Map.Real.Time.To.Sequence.Time(loc(addr(x)),loc(addr(x)));	//	Bug Fix: If you had two adjacent records with the same meter, and you changed the meter of	//	the second, then backed up to the first, the upper display would not update.  This happened	//	because the checksum in "Check.For.Tempo.Meter.Events" was not updated since the meter was changed.	//	Hence, we will first call "Check.For.Tempo.Meter.Events" to update the checksum for proper comparison	//	with the record we are about to back up to.	Check.For.Tempo.Meter.Events(loc(addr(x)));	/*	Find the meter segment that contains this real time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	if  (x = Meter.Map.This.Seq.Msb)					/*	we are sitting at		*/	and (y = Meter.Map.This.Seq.Lsb)					/*	start of segment		*/	then do;													/*	backup one more segment	*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	now get start time of prior meter seqment	*/	x = Meter.Map.This.Seq.Msb;	y = Meter.Map.This.Seq.Lsb;	if  (x = 0)									/*	check for backup to zero	*/	and (y ile zero.time)	then do;		call play.initialize;				/*	just do a play init	*/		new.beat.number = 1;					/*	update beat display	*/		call display.sequencer.status;	/*	and buttons				*/		broadcast.mtc();		return;									/*	bail out	*/	end;	/*	must pass real time to advance.sequencer	*/	call Map.Sequence.Time.To.Real.Time(loc(addr(x)),loc(addr(x)));	move = 1; move.speed = (-1);	call display.sequencer.status;	call rebuild.event.queue;	call backup.sequencer(x,y);	move = 0; move.speed = 0;	call rebuild.event.queue;	call display.sequencer.status;	broadcast.mtc();end Backup.To.Prior.Meter.Record;dcl click.val.data data (2,3,4,6,8,12,16,24,32,48);Set.Click.Value: proc (Seq.Time, value) public swapable;	dcl Seq.Time	array;	dcl value		fixed;	dcl (x,y)		fixed static;	dcl cc			fixed;	dcl bb			fixed;	if Meter.Map.Ptr = 0			/*	no meter map		*/	then do;		return;						/*	use default value	*/	end;	x = Seq.Time(0);				/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)	/*	check for time less than		*/	then y = zero.time;					/*	start of first segment			*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.bb;	bb = read(md);							/*	lookup # displayed 32nd notes in MIDI quarter note		*/	cc = 24/bb * (click.val.data(value));			/*	compute new cc based on passed index		*/	write(mal) = Meter.Map.Cur + Meter.Map.cc;	write(md ) = cc;										/*	write new value		*/	actually.emit.click = 0;							/*	force immediate recompute of next click	*/	Update.Meter.Map.Ratios();				//	recompute all ratios in this record	Normalize.Meter.Map.TimesBeats();	//	recompute start times and beat numbers for all subsequent recordsend Set.Click.Value;Lookup.Click.Value: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl (x,y)	fixed static;	dcl cc		fixed;	dcl bb		fixed;	dcl val		fixed;	dcl i			fixed;	if Meter.Map.Ptr = 0			/*	no meter map		*/	then do;		return 24;					/*	use default value	*/	end;	x = Seq.Time(0);				/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)	/*	check for time less than		*/	then y = zero.time;					/*	start of first segment			*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.cc;	cc = read(md);								/*	lookup current cc value	*/	write(mal) = Meter.Map.Cur + Meter.Map.bb;	bb = read(md);								/*	lookup current bb val	*/	val = cc/(24/bb);	do i = 0 to 9;		if val = click.val.data(i)			/*	search data array for current value	*/		then return i;							/*	return index into array	*/	end;	return 4;									/*	use default value			*/end Lookup.Click.Value;Compute.Loop.Next.Click: proc public swapable;	dcl prior.msb	fixed;	dcl prior.lsb	fixed;	call Map.Sequence.Time.To.Nearest.Clicks(loc(addr(loop.seq.time.msb)),														  loc(addr(prior.msb)),														  loc(addr(Loop.Seq.Time.Of.Next.Click.Msb)));	if  (prior.msb = loop.seq.time.msb)		/*	if loop.point is on click boundary	*/	and (prior.lsb = loop.seq.time.lsb)		/*	use that click for next loop click	*/	then do;		Loop.Seq.Time.Of.Next.Click.Msb = prior.msb;		Loop.Seq.Time.Of.Next.Click.Lsb = prior.lsb;	end;	call Map.Sequence.Time.To.Real.Time(loc(addr(Loop.Seq.Time.Of.Next.Click.Msb)),													loc(addr(Loop.Real.Time.Of.Next.Click.Msb)));end Compute.Loop.Next.Click;dcl modify.bounce proc (fixed, fixed, array) returns (fixed) external;Map.All.Tracks.To.Real.Time: proc swapable;	dcl i			fixed;	dcl info(1)	fixed;	do i=num.kbd.tracks to first.lod.track-1;		write(mam)=trk.head;		write(mal)=i;		if read(md)<>0 then do;			call modify.bounce (i,op#seq.to.real,info);		end;	end;end Map.All.Tracks.To.Real.Time;Map.All.Tracks.To.Sequence.Time: proc swapable;	dcl i			fixed;	dcl info(1)	fixed;	do i=num.kbd.tracks to first.lod.track-1;		write(mam)=trk.head;		write(mal)=i;		if read(md)<>0 then do;			call modify.bounce (i,op#real.to.seq,info);		end;	end;end Map.All.Tracks.To.Sequence.Time;dcl undo.enabled boolean external;//	Convert.Mapped.To.Unmapped effectively does the opposite of "Create.Tempo.Map.From.Track".//	The tempo and meter maps are erased but the real times and durations of all events in//	the sequence are preserved (i.e., the unmapped sequence sounds indentical.)//Convert.Mapped.To.Unmapped: proc public swapable;	if ((Tempo.Map.Ptr|Meter.Map.Ptr) == null) return;	//	No maps - nothing to do - boring...	STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS();			//	stop any performance	PLAY.INITIALIZE();									//	init to top of sequence	if (undo.enabled != false) save.undoseq();	//	set up for possible undo	Map.All.Tracks.To.Real.Time();	Erase.Meter.Map.Info();	Erase.Tempo.Map.Info();	//	If the sequence has no groups then restore to magic#5 (else leave at magic#7)	write(mam) = bas.ptr;	write(mal) = magic.number;	if (read(md) == magic#6) write(md) = magic#5;	Map.All.Tracks.To.Sequence.Time();	PLAY.INITIALIZE();	//	Yet to be done: Also preserve real times for goback, start mark,	//	S-page and Q-page locate points, etc.end Convert.Mapped.To.Unmapped;//	Look into also converting goback, start mark, S-page and Q-page locate points, etc.//Create.Tempo.Map.From.Track: proc (trk,op) public swapable;	dcl trk		fixed;	/*	abs trk# to work on	*/	dcl op		fixed;	/*	operation: 0 = maintain real times on all other tracks	*/								/*				  1 = maintain beat times on all other tracks	*/	dcl time(1)	fixed;	dcl tempo	fixed;	dcl (x,y)	fixed;	dcl i			fixed;	dcl info(1)	fixed;	Check.Track.For.Tempo.Map: proc (t)	fixed;		dcl t			fixed;	/*	abs track number to check	*/		dcl time(1)	fixed;		dcl real.time.of.note(1)	fixed;		dcl i			fixed;		dcl (x,y)	fixed;		time(0) = 0;						/*	init to time of first click	*/		time(1) = zero.time;		i = 1;								/*	prime loop var			*/		do while (i <> 0);				/*	until end of track	*/			/*	get start time of note and make sure it is in real time format	*/			call Map.Sequence.Time.To.Real.Time (loc(addr(#NMSB)),real.time.of.note);			call look.up.note.info;		/*	get #W1 - #w4						*/			if (isa.rest.note)			/*	skip over rest notes,			*/			or (isa.rte.note )			/*	rtes									*/			or (isa.ilp.note )			/*	and ilps								*/			then do; end;			/*	compare time of last note with new note	*/			else if	((time(0) <> real.time.of.note(0))			or			(time(1) <> real.time.of.note(1)))			then do;							/*	new note starts at new time	*/				/*	load possible new tempo into x,y	*/				call SUB32(real.time.of.note, time, loc(addr(x)));				if ((x != 0)				//	Protect against misinterpretation when notes are approx. 65 seconds apart				|| (y ilt 25)				/*	resulting tempo > 2400 bpm		*/				|| (y igt 2000))			/*	resulting tempo < 30   bpm		*/				return 0;					/*	return error						*/				time(0) = real.time.of.note(0);	/*	copy note start time for next check	*/				time(1) = real.time.of.note(1);			end;			i = ADVANCE.TO.NEXT.NOTE;	/*	goto next note on track			*/		end;		call PLAY.INITIALIZE;			/*	must leave globals set up on return no error	*/		call LOAD.SEQ.GLOBALS(t);		return 1;							/*	valid track for tempo conversion	*/	end Check.Track.For.Tempo.Map;	/*	code begins here	*/	call STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS;	/*	stop any performance		*/	call PLAY.INITIALIZE;							/*	init to top of sequence	*/	if LOAD.SEQ.GLOBALS(trk) = 0					/*	no track						*/	or (#wrd=0)											/*	or no notes					*/	then return 0;										/*	invalid track for tempo	*/	if Check.Track.For.Tempo.Map (trk) = 0		/*	call routine for further validity check	*/	then return 0;	if undo.enabled then call save.undoseq;	/*	setup for possible undo	*/	if (op=0) then do;								/*	keep real times constant for all tracks	*/		call Map.All.Tracks.To.Real.Time;		/*	make sure all tracks are temporarily stored in real time format	*/	end;	/*	use orig seq times for all other tracks		*/	/*	result: beat times instead of real times are	*/	/*	maintained for new tempo map.						*/	else call modify.bounce (trk, op#seq.to.real, info);	//	If no maps are in use yet, start by creating defaults.  However,	//	if a tempo map already exists, it must first be nuked first.	if (Meter.Map.Ptr == null)	Create.Default.Meter.Map();	if (Tempo.Map.Ptr != null)	Erase.Tempo.Map.Info();	Create.Default.Tempo.Map();	call PLAY.INITIALIZE;				/*	make sure seq globals are ready	*/	call LOAD.SEQ.GLOBALS(trk);	time(0) = 0;							/*	init to time of first click	*/	time(1) = zero.time;	tempo = 0;								/*	init to impossible value		*/	i = 1;									/*	prime loop var						*/	do while (i <> 0);					/*	until end of track				*/		call look.up.note.info;			/*	get #W1 - #w4						*/		if (isa.rest.note)				/*	skip over rest notes,			*/		or (isa.rte.note )				/*	rtes									*/		or (isa.ilp.note )				/*	and ilps								*/		then do; end;		/*	compare time of last note and this note	*/		else if ((time(0) <> #NMSB)		or       (time(1) <> #NLSB))		then do;								/*	new note starts at new time	*/			/*	load possible new tempo into x,y	*/			call SUB32(loc(addr(#NMSB)),time,loc(addr(x)));			if tempo <> y then do;		/*	new tempo	*/				tempo = y;					/*	latch new tempo in milliseconds per beat	*/				load tempo;					/*	convert to microseconds per beat				*/				mul 1000;				x = ures;				y = res;				/*	must use sequence times for calls to tempo routines	*/				call Map.Real.Time.To.Sequence.Time (time,time);				call Insert.Tempo.Record (time);		/*	create a new tempo record	*/				call Set.Tempo (time,loc(addr(x)));	/*	set it to new tempo			*/			end;			time(0) = #NMSB;				/*	copy real time of note start	*/			time(1) = #NLSB;				/*	for next check						*/		end;		i = ADVANCE.TO.NEXT.NOTE;		/*	goto next note on track			*/	end;	if (op=0) then do;		/*	after new tempo map is created...						*/		/*	we must now map all tracks back to sequence time.	*/		call Map.All.Tracks.To.Sequence.Time;	end;	/*	conform sequence to new tempo map by leaving	*/	/*	all other tracks at orig seqtime.				*/	else call modify.bounce (trk,op#real.to.seq,info);	call PLAY.INITIALIZE;	return 1;								/*	return no err	*/end Create.Tempo.Map.From.Track;//	………………B…E…G…I…N………B…U…N…G…L…O…A…D………O…'………D…E…B…U…G………S…C…H…P…U…T…Z………………/*Debug.Schputz: proc public;	dcl block#	fixed;	dcl (Map.Ptr, Map.Cur, Map.Len)	fixed;	//	THIS IS NOT EFFICIENT, BUT WHO CARES?	Report.Tempo: proc;		write(mal) = Tempo.Map.FP;		Map.Cur = read(mdi);		Map.Len = read(md );		write(5) = (Map.Len-Map.Cur);		write(7) = Tempo.Map.Rec.Len;//		send 'block',block#,' at sector',Map.Ptr,' contains',read(5),' records';		send 'block',block#,' contains',read(5),' records.  first =',;		write(mal) = Tempo.Map.Rec#.lsb;		send read(md);	end;	Report.Meter: proc;		write(mal) = Meter.Map.FP;		Map.Cur = read(mdi);		Map.Len = read(md );		write(5) = (Map.Len-Map.Cur);		write(7) = Meter.Map.Rec.Len;//		send 'block',block#,' at sector',Map.Ptr,' contains',read(5),' records';		send 'block',block#,' contains',read(5),' records.  first =',;		write(mal) = Meter.Map.Rec#.lsb;		send read(md);	end;	//	MAKE LOCAL COPIES OF THE TEMPO MAP VARIABLES	Map.Ptr = Tempo.Map.Ptr; Map.Cur = Tempo.Map.Cur; Map.Len = Tempo.Map.Len;	//	BACK UP TO FIRST NLS OF TEMPO MAP	write(mam) = Map.Ptr; write(mal) = Tempo.Map.REV;		//	POINT TO THE CURRENT NLS'S REVERSE POINTER FOR THE LOOP CONDITION.	while (read(md) != null) {										//	WHILE IT'S NOT NULL,		Map.Ptr = NAH.PTR + read(md);								//	MAKE "Map.Ptr" POINT TO THE PREVIOUS NLS.		write(mam) = Map.Ptr; write(mal) = Tempo.Map.REV;	//	THEN POINT TO IT'S REVERSE POINTER FOR THE LOOP CONDITION.	}	send 'Tempo:'; Report.Tempo();								//	GENERATE OUTPUT.	//	LINK THROUGH ANY SUBSEQUENT NLS BLOCKS	write(mal) = Tempo.Map.FOR;									//	POINT TO THE CURRENT NLS'S FORWARD POINTER FOR THE LOOP CONDITION.	while (read(md) != null) {										//	WHILE IT'S NOT NULL,		Map.Ptr = NAH.PTR + read(md);								//	MAKE "Map.Ptr" POINT TO THE NEXT NLS.		write(mam) = Map.Ptr;										//	POINT TO IT IN PREPARATION FOR THE CALL TO "report()".		block# = block#+1;		Report.Tempo();												//	GENERATE OUTPUT.		write(mal) = Tempo.Map.FOR;								//	POINT TO THE FORWARD POINTER FOR THE LOOP CONDITION.	}	block# = null;														//	RESET FOR METER	//	MAKE LOCAL COPIES OF THE METER MAP VARIABLES	Map.Ptr = Meter.Map.Ptr; Map.Cur = Meter.Map.Cur; Map.Len = Meter.Map.Len;	//	BACK UP TO FIRST NLS OF METER MAP	write(mam) = Map.Ptr; write(mal) = Meter.Map.REV;		//	POINT TO THE CURRENT NLS'S REVERSE POINTER FOR THE LOOP CONDITION.	while (read(md) != null) {										//	WHILE IT'S NOT NULL,		Map.Ptr = NAH.PTR + read(md);								//	MAKE "Map.Ptr" POINT TO THE PREVIOUS NLS.		write(mam) = Map.Ptr; write(mal) = Meter.Map.REV;	//	THEN POINT TO IT'S REVERSE POINTER FOR THE LOOP CONDITION.	}	send 'Meter:'; Report.Meter();								//	GENERATE OUTPUT.	//	LINK THROUGH ANY SUBSEQUENT NLS BLOCKS	write(mal) = Meter.Map.FOR;									//	POINT TO THE CURRENT NLS'S FORWARD POINTER FOR THE LOOP CONDITION.	while (read(md) != null) {										//	WHILE IT'S NOT NULL,		Map.Ptr = NAH.PTR + read(md);								//	MAKE "Map.Ptr" POINT TO THE NEXT NLS.		write(mam) = Map.Ptr;										//	POINT TO IT IN PREPARATION FOR THE CALL TO "report()".		block# = block#+1;		Report.Meter();												//	GENERATE OUTPUT.		write(mal) = Meter.Map.FOR;								//	POINT TO THE FORWARD POINTER FOR THE LOOP CONDITION.	}	block# = null;														//	RESET FOR NEXT TIME THIS PROCEDURE IS CALLED	send;																	//	CR TO INDICATE THAT WE'RE LEAVING THIS PROCEDURE	write(mam) = Tempo.Map.Ptr;									//	LEAVE POINTING TO THE SAME NLS AS WHEN WE ENTERED THIS PROCEDUREend Debug.Schputz;*///	……………………E…N…D………B…U…N…G…L…O…A…D………O…'………D…E…B…U…G………S…C…H…P…U…T…Z……………………