/*	:SYNRSOU:03-PRIM:131-SDF2  -  VARIABLES FOR SEQUENCER SCANNING	*/

/*
Modified:
1999/04/12 - TY  - Made modifications to account for the independence of CLICK.DISP.MODE from CLICK.TRACK.MODE.
1998/07/06 - TY  - Modified SPEED.COMP not to set SAMP.CLICK.RATE to 500 ms when a click track is in use.
1991/03/22 - cj  - Changed seq.spl.time to fix Lee Kopp FM retrigger clicks
1991/03/15 - cj  - Better fetching of track timbre names
1989/10/06 - MWH - Fix comment
1989/09/23 - CJ  - Broke this code off from 131-sdf1
*/

/*	FAST FORWARD/REWIND CONSTANTS:	*/

DCL MIN.SPEED	LIT '1500';	/*	MINIMUM SPEED	*/
DCL TIM.CONST	LIT '9800';	/*	TIM.CONST*SPEED/10000 EVERY CS.	*/


/*	$PAGE - PROCEDURE FOR SPEED ADJUSTMENT, COMPUTE # OF NOTES LEFT	*/

/*	LOOK UP SPEED INFO FROM SEQUENCER BASE SECTOR	*/

COMPUTE.CLICK.RATE: proc fixed public;
	if (click.track.mode == 0) return samp.click.rate;
	else								return 1000;
end COMPUTE.CLICK.RATE;

/*	SPEED.COMP looks up some important sequencer variables from	*/
/*	external memory and stores them in some handy global			*/
/*	variables.  It also creates a system event if any of			*/
/*	these constants change:													*/

SPEED.COMP:PROC PUBLIC SWAPABLE;			/*	COMPUTE PRESCAN AMOUNTS & SAMPLE SEQUENCER INFO	*/
	DCL NEW FIXED;

	DISABLE;										/*	TO KEEP INTERRUPT STUFF CONSISTENT	*/

	NEW = 0;

	WRITE(MAM)=BAS.PTR;						/*	LOOK UP INFO		*/
	WRITE(MAL)=SEQ.SPEED;

	IF SAMP.SPEED <> READ(MD)				/*	CHECK FOR CHANGE	*/
	THEN NEW   = 1;							/*	NEW VALUE			*/
	SAMP.SPEED = READ(MDI);					/*	GET SAMP SPEED		*/

	IF (CLICK.TRACK.MODE ine 3)			/*	IF NOT EXT CLICK	*/
	THEN DO;										/*	THEN GET VALUE		*/
		IF  (SAMP.CLICK.RATE <> READ(MD))
		THEN NEW			 = 1;
		SAMP.CLICK.RATE = READ(MDI);
	END;
	ELSE DO;										/*	ELSE SET VALUE		*/
		WRITE("324") = READ(MDI);			/*	SKIP OVER EXT MEM	*/
		IF  (SAMP.CLICK.RATE <> 500)		/*	SET SAMP CLICK RATE TO 500	*/
		THEN NEW			 = 1;
		SAMP.CLICK.RATE = 500;				/*	TO PREVENT EXTRA CLICKS		*/
	END;

	IF (SAMP.CRM <> READ(MD))				/*	CHECK CRM			*/
	THEN NEW = 1;
	SAMP.CRM = READ(MDI);

	IF EXT.CLOCK.MODE<3
	THEN SAMP.EXT.DIV=SAMP.CRM;		/*	GET DIVISIONS PER BEAT FROM CRM		*/
	ELSE SAMP.EXT.DIV=24;				/*	24 DIVISIONS PER BEAT FOR MIDI SYNC	*/

	IF SM.MODE <> READ(MD)				/*	LOOK UP CURRENT SMPTE MODE	*/
	THEN NEW	= 1;
	SM.MODE	= READ(MDI);

	IF SM.BIT <> READ(MD)
	THEN NEW	= 1;
	SM.BIT	= READ(MDI) ;				/*	FOR USE BY INTERRUPT ROUTINE	*/

	IF (SM.FRA\SHL(SM.SEC,8)) <> READ(MD)
	THEN NEW	= 1;
	SM.FRA	= READ(MD)&255;
	SM.SEC	= SHR(READ(MDI),8);

	IF (SM.MIN\SHL(SM.HRS,8)) <> READ(MD)
	THEN NEW	= 1;
	SM.MIN	= READ(MD)&255;
	SM.HRS	= SHR(READ(MDI),8);

	IF SAMP.BPM <> READ(MD)
	THEN NEW = 1;
	SAMP.BPM = READ(MDI);					/*	GET BEATS PER MEASURE		*/

	MARK.BUTTON.MSB=READ(MDI);				/*	READ MARK BUTTON TIME		*/
	MARK.BUTTON.LSB=READ(MDI);				/*	IN SEQUENCER UNITS			*/

	LOAD 5; MUL SAMP.SPEED;					/*	COMPUTE MONO SAMPLING SPLICE	*/
	MWAIT;  DIV 1000;							/*	TIME FOR SEQUENCER NOTES	*/
	IF REM<>0 THEN LOAD RES+1;				/*	START WITH 5 MSECS.  SCALE	*/
	IF RES =0 THEN LOAD 1;					/*	BY SPEED.  MULTIPLY BY 3	*/
	SEQ.MONO3=RES*3;							/*	TO GET 15 MSEC					*/

	LOAD	 KBD.FM1; MUL SAMP.SPEED;		/*	COMPUTE TIME FOR FIRST FM	*/
	MWAIT; DIV 1000;							/*	SPLICE							*/
	IF REM<>0 THEN LOAD RES+1;				/*	ROUNDED UP						*/
	IF RES =0 THEN LOAD 1;					/*	MIN OF 1							*/
	SEQ.FM1 = RES;

	LOAD	 KBD.FM2; MUL SAMP.SPEED;		/*	COMPUTE TIME FOR SECOND FM	*/
	MWAIT; DIV 1000;							/*	SPLICE							*/
	IF REM<>0 THEN LOAD RES+1;				/*	ROUNDED UP						*/
	IF RES =0 THEN LOAD 1;					/*	MIN OF 1							*/
	SEQ.FM2 = RES;

	SEQ.SPL.TIM = SEQ.FM1 + SEQ.FM2;		/*	USE FM1 + FM2 FOR POLY		*/

	LOAD	 20; MUL SAMP.SPEED;				/*	20 MSEC FOR REPEAT			*/
	MWAIT; DIV 1000;
	IF REM<>0 THEN LOAD RES+1;				/*	ROUNDED UP						*/
	IF RES =0 THEN LOAD 1;					/*	MIN OF 1							*/
	REPSCAN1 = RES;

	IF INC.MONO THEN REPSCAN1=REPSCAN1+SEQ.MONO3;
	ELSE				  REPSCAN1=REPSCAN1+SEQ.SPL.TIM;

	LOAD  SAMP.SPEED; MUL	80;			/*	USE 80 MS PRESCAN				*/
	MWAIT; DIV 1000;
	IF REM<>0 THEN LOAD RES+1;				/*	ROUNDED UP						*/
	IF RES =0 THEN LOAD 1;					/*	MIN OF 1							*/
	PRESCAN = RES;

	IF INC.MONO THEN DO;
		IF PRESCAN ILT SHL(SEQ.MONO3,1)
		THEN PRESCAN=SHL(SEQ.MONO3,1);
	END;
	ELSE DO;
		IF PRESCAN ILT SHL(SEQ.SPL.TIM,1)
		THEN PRESCAN=SHL(SEQ.SPL.TIM,1);
	END;

	NEW.MOTION = 1;						/*	TELL LIVE OVERDUB NEW SPEED	*/

	ENABLE;

	/*	create a system event if any of the sequencer constants	*/
	/*	change:																	*/

	IF NEW THEN DO;
		NEW.SEQ.INFO = NEW.SEQ.INFO \ 8;
	END;

END SPEED.COMP;


COMPUTE.NUMB.LEFT:PROC PUBLIC SWAPABLE;	/*	HANDY PROCEDURE TO COMPUTE # OF NOTES REMAINING IN SEQUENCER	*/

	/*	ADD UP # OF FREE SECTORS OF EXT MEMORY	*/

	LOAD (BAS.PTR - 1)
	+	  (PAR.PTR - (BAS.PTR+BAS.LEN))
	+	  (NAH.PTR - (PAR.PTR+PAR.LEN))
	+	  (BNK.PTR - (NAH.PTR+NAH.LEN))
	+	  (INF.PTR - (BNK.PTR		  ))
	+	  (TIM.PTR - (INF.PTR+INF.LEN))
	+	  (TRD.PTR - (TIM.PTR+TIM.LEN))
	+	  (NAH.#FREE);

	MUL (SHR(NLS.LAST+4-NLS.FIRSTL,1));

	NOTES.LEFT.MSB=READ(4);
	NOTES.LEFT.LSB=READ(5);

END COMPUTE.NUMB.LEFT;

/*	$SUBTITLE  Routines to Process Variable Length Timbres	*/


P.LOOKUP:PROC(PTR) PUBLIC;			/*	LOOK UP SINGLE WORD FROM TIMBRE AREA		*/
	DCL PTR	FIXED;					/*	MUST USE ** NO INCREMENT ** THEN RETURN	*/
	WRITE(MAM)=PAR.PTR+SHR(PTR,8); WRITE(MAL)=PTR;
	RETURN READ(MD);
END P.LOOKUP;


P.STORE:PROC(PTR,VAL) PUBLIC;		/*	STORE WORD IN PARTIAL AREA					*/
	DCL (PTR,VAL)	FIXED;			/*	MUST USE ** INCREMENT ** THEN RETURN	*/
	WRITE(MAM)=PAR.PTR+SHR(PTR,8); WRITE(MAL)=PTR;
	WRITE(MDI)=VAL;
END P.STORE;

TRK.HEAD.LOOKUP:  PROC (TRACK#,VAR.PTR) FIXED PUBLIC;	/*	LOOK UP SINGLE WORD FROM SPECIFIED TRACK HEADER AREA	*/
	DCL TRACK#	FIXED;	/*	DESIRED TRACK: 0-1 => KBD TRACKS, 2-255 => SEQUENCER TRACKS	*/
	DCL VAR.PTR	FIXED;	/*	OFFSET PTR INTO TRACK HEADER; USE THD.??? DEFS	*/

	WRITE(MAM)=TRK.HEAD;	/*	GET ABS PTR TO DESIRED TRACK HEADER	*/
	WRITE(MAL)=TRACK#;
	WRITE(MAM)=READ(MD);	/*	NOW POINT INTO TRACK HEADER			*/
	WRITE(MAL)=VAR.PTR;	/*	AT DESIRED WORD							*/
	RETURN READ(MD);		/*	READ WORD AND RETURN IT - NO INCR.	*/
END TRK.HEAD.LOOKUP;


TRK.HEAD.STORE:  PROC (TRACK#,VAR.PTR,VAL) PUBLIC;	/*	STORE SINGLE WORD INTO SPECIFIED TRACK HEADER AREA	*/
	DCL TRACK#	FIXED;	/*	DESIRED TRACK: 0-1 => KBD TRACKS, 2-255 => SEQUENCER TRACKS	*/
	DCL VAR.PTR	FIXED;	/*	OFFSET PTR INTO TRACK HEADER; USE THD.??? DEFS	*/
	DCL VAL		FIXED;	/*	WORD TO STORE	*/

	WRITE(MAM)=TRK.HEAD;	/*	GET ABS PTR TO DESIRED TRACK HEADER	*/
	WRITE(MAL)=TRACK#;
	IF READ(MD)=0 THEN RETURN;	/*	NO TRACK HEADER DEFINED -- DON'T DO WRITE	*/
	WRITE(MAM)=READ(MD);	/*	NOW POINT INTO TRACK HEADER			*/
	WRITE(MAL)=VAR.PTR;	/*	AT DESIRED WORD							*/
	WRITE(MDI)=VAL;		/*	STORE WORD, INCREMENT FOR SUBSEQUENT WRITES	*/
END TRK.HEAD.STORE;


TIM.HEAD.LOOKUP:  PROC (TIMBRE#,VAR.PTR) FIXED PUBLIC;	/*	LOOK UP SINGLE WORD FROM SPECIFIED TIMBRE INFO AREA	*/
	DCL TIMBRE#	FIXED;	/*	DESIRED TIMBRE: 0-1 => KBD TIMBRES, 2-255 => OTHER TIMBRES	*/
	DCL VAR.PTR	FIXED;	/*	OFFSET PTR INTO TIMBRE INFO AREA; USE TIM.??? DEFS	*/

	WRITE(MAM)=TIM.HEAD;	/*	GET ABS PTR TO DESIRED TIMBRE INFO AREA	*/
	WRITE(MAL)=TIMBRE#;
	WRITE(MAM)=READ(MD);	/*	NOW POINT INTO TIMBRE INFO AREA		*/
	WRITE(MAL)=VAR.PTR;	/*	AT DESIRED WORD							*/
	RETURN READ(MD);		/*	READ WORD AND RETURN IT - NO INCR.	*/
END TIM.HEAD.LOOKUP;


TIM.HEAD.STORE:  PROC (TIMBRE#,VAR.PTR,VAL) PUBLIC;	/*	STORE SINGLE WORD INTO SPECIFIED TIMBRE INFO AREA	*/
	DCL TIMBRE#	FIXED;	/*	DESIRED TIMBRE: 0-1 => KBD TIMBRES, 2-255 => OTHER TIMBRES	*/
	DCL VAR.PTR	FIXED;	/*	OFFSET PTR INTO TIMBRE INFO AREA; USE TIM.??? DEFS	*/
	DCL VAL		FIXED;	/*	WORD TO STORE	*/

	WRITE(MAM)=TIM.HEAD;	/*	GET ABS PTR TO DESIRED TIMBRE INFO AREA	*/
	WRITE(MAL)=TIMBRE#;
	IF READ(MD)=0 THEN RETURN;	/*	NO TIMBRE INFO AREA -- DON'T DO WRITE	*/
	WRITE(MAM)=READ(MD);	/*	NOW POINT INTO TIMBRE INFO AREA		*/
	WRITE(MAL)=VAR.PTR;	/*	AT DESIRED WORD							*/
	WRITE(MDI)=VAL;		/*	STORE WORD, INCREMENT FOR SUBSEQUENT WRITES	*/
END TIM.HEAD.STORE;


/*	$PAGE - FRAME POINTER ROUTINES	*/

/*		1. ZERO.FRAME.PTRS		- INITIALIZE FRAME POINTERS (FOR EXAMPLE, AFTER TIMBRE RECALL)	*/
/*		2. FIND.FRAME				- STEPS TO A PARTICULAR FRAME OF KEYBOARD TIMBRE					*/
/*		3. FIND.PARTIAL			- FINDS FIRST SELECTED PARTIAL											*/
/*		4. COUNT.TIMBRE.FRAMES	- FINDS LARGEST FRAME #														*/


ZERO.FRAME.PTRS:PROC PUBLIC SWAPABLE;	/*	INITIALIZE FRAME POINTERS - USED SEVERAL PLACES	*/
	DCL (I)	FIXED;

	DO I=0 TO NUM.PARTIALS-1;
		C.FRAME(I)=0;
		WRITE(MAM)=TIM.HEAD;
		IF READ(MD)<>0 THEN DO;		/*	MAKE SURE TIMBRE HEAD PTR FOR KEYBOARD	*/
			WRITE(MAM)=READ(MD);
			WRITE(MAL)=TIM.PARTIAL.POINTERS+I;
			FR.PTRS(I)=READ(MD);
		END;
		ELSE FR.PTRS(I)=0;
	END;
END ZERO.FRAME.PTRS;


FIND.FRAME:PROC(PAR#,FRA#) PUBLIC SWAPABLE;	/*	FIND FRAME FOR KEYBOARD TIMBRE - PASS PARTIAL #, FRAME #	*/
	DCL (I,J,PAR#,FRA#)	FIXED;

	WRITE(MAM)=TIM.HEAD;

	IF READ(MD)=0 THEN RETURN;	/*	NO BLOCK FOR TIMRE 0?					*/

	WRITE(MAM)=READ(MD);			/*	POINT TO TIMBRE HEAD FOR KEYBOARD	*/
	WRITE(MAL)=TIM.PARTIAL.POINTERS+PAR#;
	I=READ(MD);						/*	GET POINTER TO PARTIAL					*/

	IF FRA#=0 THEN RETURN I;	/*	FRAME 0 IS MAIN TIMBRE BLOCK			*/

	I=I+NUM.PARAMS;				/*	GET FIRST CONTINUATION FRAM			*/

	DO J=1 TO FRA#-1;				/*	SKIP UP TO DESIRED FRAME				*/
		IF P.LOOKUP(I)<>MOR THEN RETURN I;	/*	OOPS - END OF LIST REACHED - STOP HERE	*/
		I=I+P.LOOKUP(I+CLEN);					/*	SKIP OVER FRAME - IT HAD BETTER EXIST	*/
	END;

	RETURN I;

END FIND.FRAME;

FIND.PARTIAL:  PROC PUBLIC;	/*	FIND FIRST SELECTED PARTIAL	*/
	DCL I	FIXED;

	I=0;
	DO WHILE (SELECTED.PARTIALS&BITS(I))=0;
		I=I+1;
	END;								/*	GET FIRST SELECTED PARTIAL		*/

	RETURN I;

END FIND.PARTIAL;

/*	find max frame - convenient routine to find	*/
/*	the # of frames on a partial						*/

COUNT.TIMBRE.FRAMES:  PROC(PAR) public swapable;	/*	FIND LAST FRAME	*/
	dcl (par,j)			fixed;				/*	pass partial #	*/
	dcl (num.frames)	fixed;

	j=TIM.HEAD.LOOKUP(0,tim.partial.pointers+par)+num.params;	/*	find last patch list for cursor movement	*/
	num.frames=0;
	do while p.lookup(j)=mor;				/*	find end of list	*/
		num.frames=num.frames+1;
		j=j+p.lookup(j+clen);				/*	skip to next frame	*/
	end;
	return num.frames;
END COUNT.TIMBRE.FRAMES;


/*	#PAGE - FIND.TIMBRE, COMPUTE. TIMBRE FRAME	*/

/*	ROUTINES DEFINED HERE:

	1. FIND.TIMBRE						- STEPS THROUGH BANK OR SEQUENCER TIMBRES TO FIND DESIRED TIMBRE
	2. LOOKUP.TIMBRE.NAME			- LOOKS UP NAME OF PASSED TIMBRE #
	3. LOOKUP.TRACK.TIMBRE.NAME	- LOOKS UP NAME OF CURRENT TIMBRE ON TRACK
	4. COMPUTE.TIMBRE.FRAME			- RECOMPUTE T. FRAME WAVESHAPE

	SO:	*/

FIND.TIMBRE:PROC(BASE,NUMBER) PUBLIC SWAPABLE;	/*	PASS BASE, TIMBRE # - RETURN CORE POINTER TO TIMBRE, OR WORD OFFSET	*/
	DCL (I,J,K,BASE,PTR,NUMBER)	FIXED;			/*	FOR PTR=SECTOR BOUNDARY.  RETURNS WORD OFFSET FROM THAT	*/

	W.LOOKUP:PROC(BASE,PTR);						/*	LOOK UP WORD OFF OF BASE	*/
		DCL BASE	FIXED;
		DCL PTR	FIXED;
		WRITE(MAM)=BASE+SHR(PTR,8); WRITE(MAL)=PTR;
		RETURN READ(MD);
	END W.LOOKUP;

	PTR=0;												/*	INITIALIZE	*/
	DO I=0 TO (NUMBER-1);							/*	ADVANCE POINTER OVER TIMBRES	*/
		DO J=0 TO (NUM.PARTIALS-1);				/*	SKIP OVER PARTIALS	*/
			IF W.LOOKUP(BASE,PTR)=SUP THEN PTR=PTR+1;	/*	INDICATES SUPPRESSED PARTIAL	*/
			ELSE PTR=PTR+NUM.PARAMS;
			DO WHILE W.LOOKUP(BASE,PTR)=MOR; PTR=PTR+W.LOOKUP(BASE,PTR+CLEN); END;	/*	SKIP OVER NEW WAVES	*/
			IF W.LOOKUP(BASE,PTR)=PINFO THEN PTR=PTR+PINFO.LEN;	/*	PARTIAL INFO	*/
		END;
		IF W.LOOKUP(BASE,PTR)=TINFO THEN PTR=PTR+TINFO.LEN;		/*	TIMBRE INFO		*/
		PTR=PTR+NUM.MISC.PARAMS;					/*	SKIP OVER 8 EXTRA WORDS	*/
	END;
	RETURN PTR;											/*	RETURN WORD OFFSET FROM BASE FOR EXT MEM	*/
END FIND.TIMBRE;

COMPUTE.TIMBRE.FRAME:PROC(I) PUBLIC SWAPABLE;	/*	COMPUTE WAVESHAPE FOR CURRENTLY SELECTED TIMBRE FRAME	*/
	DCL (I,J)	FIXED;
	PTPTR=FR.PTRS(I)+S.ENV.P;	/*	SET UP PTPTR FOR PASSING TO COMPUTE.WAVE	*/
	PHASE.INFO=1;					/*	SET TRUE TO INDICATE VALID PHASE INFO STORED IN COEF 0	*/
	CALL COMPUTE.WAVE;			/*	COMPUTE WAVE FORM IN MISC.BUFF	*/
	PHASE.INFO=0;					/*	NORMALLY SET TO ZERO	*/
	J=0;								/*	INITIALIZE LOOP		*/
	PTPTR=PTPTR+(S.ENV.T-S.ENV.P);	/*	POINT TO WAVE TABLE ITSELF IN FRAME	*/
	DO WHILE (J<256);														/*	STORE EACH IN TABLE	*/
		CALL P.STORE(PTPTR,MISC.BUF(J)+SHL(MISC.BUF(J+1),8));	/*	GET WORD FROM COMPUTED WAVE TABLE	*/
		J=J+2; PTPTR=PTPTR+1;
	END;
END COMPUTE.TIMBRE.FRAME;

LOOKUP.TIMBRE.NAME: proc (t#,arr) public swapable;	/*	LOOKS UP NAME FOR A TIMBRE #	*/
	DCL T#		FIXED;	/*	TIMBRE #	*/
	DCL ARR		ARRAY;	/*	STRING	*/
	DCL (I,J,K)	fixed;
	DCL PTL#		FIXED;

	ARR(0) = 0;											/*	INIT TO NO NAME		*/
	PTL#	 = 0;											/*	INIT PTL COUNTER		*/

	I=TIM.HEAD.LOOKUP(T#, TIM.TINFO.POINTER);	/*	LOOK UP TINFO POINTER	*/

	IF I<>0 THEN DO;									/*	CHECK TIMBRE NAME		*/
		K=0;												/*	IF TINFO AREA EXISTS	*/
		DO J=1 TO 8;									/*	GET TIMBRE TITLE		*/
			ARR(J)=P.LOOKUP(I+J+(TI.NAME-1));	/*	NOT SPACES				*/
			IF  (ARR(J)<>(SP\SHL(SP,8)))			/*	AND NOT ALL ZEROES	*/
			AND (ARR(J)<>(0))
			THEN K=1;
		END;
		IF K<>0 THEN ARR(0)=16;
	END;

	/*	Else look for cues/events/patch list file names if no assigned	*/
	/*	timbre name exists:															*/

	DO WHILE	(ARR(0) = 0				 )				/*	LOOK THROUGH FRAMES	*/
	AND		(PTL#   < NUM.PARTIALS);			/*	FOR ALL PARTIALS		*/

		J=TIM.HEAD.LOOKUP(T#,TIM.PARTIAL.POINTERS+PTL#);

		IF P.LOOKUP(J)<>SUP							/*	EXAMINE PARTIAL		*/
		THEN DO;											/*	IF NOT SUPPRESSED		*/

			J=J+NUM.PARAMS;							/*	POINT TO FIRST FRAME	*/

			DO WHILE	(ARR(0)		 = 0	)			/*	UNTIL NAME FOUND		*/
			AND		(P.LOOKUP(J) = MOR);			/*	SEARCH					*/

				IF (P.LOOKUP(J+TYPE) = PT.TYPE)           /*	PATCH LIST        */
				THEN DO;
               // Check for long file name
               if ((p.lookup(j+clen  ) > pt.len)
               &&  (p.lookup(j+pt.len) > 8     )) {
                  dcl l fixed;
                  l = shr(p.lookup(j+pt.len)+3,1);    // get word length of name
                  
                  if (l>9)
                     l = 9;
                  
                  DO K = 0 to l-1;
                     arr(k) = p.lookup(j+pt.len+k);
                  end;
                  
                  if (arr(0)>16)
                     arr(0) = 16;
               }

               else {
                  DO K = 1 TO 4;									/*	USE FILE NAME		*/
                     ARR(K)=P.LOOKUP(J+K+(PT.NAME-1));	/*	FOR TIMBRE NAME	*/
                  END;
                  ARR(0)=8;
               }
				END;

				ELSE IF (P.LOOKUP(J+TYPE) = CU.TYPE)	/*	CUE LIST				*/
				THEN DO;
					DO K=0 TO 8;								/*	USE FIRST CUE NAME	*/
						ARR(K)=P.LOOKUP(J+CU.NAME+K);		/*	FOR TIMBRE NAME	*/
					END;
					IF ARR(0) IGT 16 THEN ARR(0)=16;		/*	LIMIT NAME LENGTH	*/
				END;

				ELSE IF (P.LOOKUP(J+TYPE) = EV.TYPE)	/*	EVENT LIST			*/
				THEN DO;
					DO K=0 TO 8;								/*	USE FIRST CUE NAME	*/
						ARR(K)=P.LOOKUP(J+EV.NAME+K);		/*	FOR TIMBRE NAME	*/
					END;
					IF ARR(0) IGT 16 THEN ARR(0)=16;		/*	LIMIT NAME LENGTH	*/
				END;

				/*	SKIP OVER THIS FILE/CUE/EVENT NAME IF							*/
				/*	NULLS OR SPACES														*/

				IF ARR(0) <> 0 THEN DO;				/*	CHECK FOR SPACES/ZEROES	*/
					K = 0;
					DO WHILE (K < ARR(0))
					AND		(BYTE(ARR,K) <= SP);
						K = K + 1;
					END;
					IF K = ARR(0) THEN ARR(0) = 0;
				END;

				J=J+P.LOOKUP(J+CLEN);

			END;
		END;

		PTL# = PTL# + 1;

	END;

	/*	REMOVE ANY TRAILING NULLS/SPACES FROM FILE/EVENT/CUE NAME:			*/

	DO WHILE (ARR(0)<>0) AND (BYTE(ARR,ARR(0)-1)<=SP);
		ARR(0)=ARR(0)-1;
	END;

END LOOKUP.TIMBRE.NAME;

LOOKUP.TRACK.TIMBRE.NAME: PROC(T#,ARR) PUBLIC SWAPABLE;	/*	LOOKS UP CURRENT TIMBRE NAME FOR A TRACK	*/
	DCL T#	FIXED;	/*	TRACK #	*/
	DCL ARR	ARRAY;	/*	STRING	*/
	DCL I		FIXED;

	I=TRK.HEAD.LOOKUP(T#,THD.CTIMB);	/*	GET CURRENT TIMBRE # FOR TRACK	*/
	IF I=0 THEN DO;
		ARR(0)=0;							/*	NO TIMBRE = NO TITLE			*/
		RETURN;
	END;

	CALL LOOKUP.TIMBRE.NAME(I,ARR);	/*	GET NAME FOR THIS TIMBRE	*/
END LOOKUP.TRACK.TIMBRE.NAME;


/*	$SUBTITLE  TIMBRE USAGE COUNTER ROUTINES	*/


ADJUST.USAGE.COUNTERS: PROC (TB,AMT) PUBLIC SWAPABLE;
	DCL TB	FIXED;	/*	TIMBRE NUMBER	*/
	DCL AMT	FIXED;	/*	AMOUNT TO ADJUST TIMBRE USES BY	*/

	WRITE(MAM)=USE.PTR;				/*	ACCESS DESIRED USE COUNTER	*/
	WRITE(MAL)=TB;

	WRITE(MD)=READ(MD)+AMT;			/*	ADJUST USE COUNTER	*/

	IF READ(MD)<=0 THEN DO;			/*	ERASE THE TIMBRE		*/
		WRITE(MD)=0;
		CALL ERASE.TIMBRE(TB);
	END;

END ADJUST.USAGE.COUNTERS;


ALLOC.TIMBRE.USES: PROC (TRK) PUBLIC SWAPABLE;
	DCL (TRK,I,J,K)	FIXED;	/*	TRACK TO ACCOUNT FOR TIMBRE USES ON	*/

	WRITE(MAM)=TRK.HEAD;			/*	GET PTR TO TRK HEAD	*/
	WRITE(MAL)=TRK;

	IF READ(MD)=0 THEN RETURN;	/*	NO TRK HEAD, NO USES	*/

	WRITE(MAM)=READ(MD);			/*	POINT TO TRK HEAD		*/

	DO I=0 TO (THD.USAGE.LEN-1) BY 2;
		WRITE(MAL)=THD.USAGE+I;

		IF READ(MD)<>0 THEN DO;	/*	HAVE A TIMBRE WITH SOME USES	*/
			J=READ(MDI); K=READ(MD);
			CALL ADJUST.USAGE.COUNTERS(J,K);	/*	ACCOUNT FOR USES IN USAGE TABLE	*/
			WRITE(MAM)=TRK.HEAD;	/*	RESTORE PTR TO TRK HEAD	*/
			WRITE(MAL)=TRK;
			WRITE(MAM)=READ(MD);
		END;
	END;

END ALLOC.TIMBRE.USES;


DEALLOC.TIMBRE.USES:  PROC (TRK) PUBLIC SWAPABLE;
	DCL (TRK,I,J,K)	FIXED;	/*	TRACK TO ACCOUNT FOR TIMBRE USES ON	*/

	WRITE(MAM)=TRK.HEAD;			/*	GET PTR TO TRK HEAD	*/
	WRITE(MAL)=TRK;

	IF READ(MD)=0 THEN RETURN;	/*	NO TRK HEAD, NO USES	*/

	WRITE(MAM)=READ(MD);			/*	POINT TO TRK HEAD		*/

	DO I=0 TO (THD.USAGE.LEN-1) BY 2;
		WRITE(MAL)=THD.USAGE+I;

		IF READ(MD)<>0 THEN DO;	/*	HAVE A TIMBRE WITH SOME USES	*/
			J=READ(MDI); K=-READ(MD);
			CALL ADJUST.USAGE.COUNTERS(J,K);	/*	ACCOUNT FOR USES IN USAGE TABLE	*/
			WRITE(MAM)=TRK.HEAD;	/*	RESTORE PTR TO TRK HEAD	*/
			WRITE(MAL)=TRK;
			WRITE(MAM)=READ(MD);
		END;
	END;

	WRITE(MAL)=THD.USAGE;		/*	RESTORE PTR TO START OF USAGE TABLE	*/

	DO I=0 TO (THD.USAGE.LEN-1);	/*	ZERO OUT TRK USAGE TABLE	*/
		WRITE(MDI)=0;
	END;

END DEALLOC.TIMBRE.USES;


/*	$PAGE	*/


ALLOC.ALL.TIMBRE.USES:  PROC PUBLIC SWAPABLE;
	DCL I	FIXED;

	WRITE(MAM)=USE.PTR;			/*	FIRST ZERO OUT THE USAGE COUNTER TABLE	*/
	DO I=NUM.KBD.TRACKS TO MAX.TIMBRES-1;
		WRITE(MDI)=0;
	END;

	DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1;	/*	LOOP OVER TRACKS		*/
		WRITE(MAM)=TRK.HEAD;						/*	GET PTR TO TRK HEAD	*/
		WRITE(MAL)=I;
		IF READ(MD)<>0								/*	TRK HEAD EXISTS		*/
		THEN CALL ALLOC.TIMBRE.USES(I);		/*	ACCOUNT FOR TIMBRE USES	*/
	END;

END ALLOC.ALL.TIMBRE.USES;


DEALLOC.ALL.TIMBRE.USES: PROC PUBLIC SWAPABLE;
	DCL I	FIXED;

	DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1;	/*	LOOP OVER TRACKS		*/
		WRITE(MAM)=TRK.HEAD;						/*	GET PTR TO TRK HEAD	*/
		WRITE(MAL)=I;
		IF READ(MD)<>0								/*	TRK HEAD EXISTS		*/
		THEN CALL DEALLOC.TIMBRE.USES(I);	/*	ACCOUNT FOR TIMBRE USES	*/
	END;

END DEALLOC.ALL.TIMBRE.USES;


/*	$PAGE - GARBAGE COLLECTION ROUTINE - COMPACT PARTIAL TIMBRES	*/


/*	THIS ROUTINE IS CALLED TO COMPACT A LIST OF TIMBRE DEFINITIONS
	STORED IN EXTERNAL MEMORY.  IT IS CALLED BOTH TO COMPACT
	THE TIMBRES IN THE (PAR.PTR,PAR.LEN) BLOCK, AS WELL AS
	THE (BNK.PTR,BNK.LEN) BLOCK.  IT SETS UP SOME SPECIAL
	POINTERS (TIM.PARTIAL.POINTERS, TIM.PINFO.POINTERS, ETC)
	IF IT IS THE PAR.PTR BLOCK THAT IS BEING COMPACTED	*/


/*	COMPACT.TIMBRES SETS UP THE FOLLOWING INFORMATION IN
	EACH TIMBRE HEADER BLOCK FOR PAR.PTR IS BEING COMPACTED:

.		1.	TIM.PARTIAL.POINTERS	- STORES A POINTER TO THE START OF EACH PARTIAL
.		2.	TIM.MISC.POINTER		- STORES A POINTER TO THE START OF THE
.										  8-WORD MISC AREA FOR EACH TIMBRE
.		3.	TIM.PINFO.POINTERS	- POINTER TO NEW MISC PARTIAL INFO AREA.
.		4.	TIM.TINFO.POINTER		- POINTER TO NEW INFO (NAME) FOR TIMBRE	*/



/*	RETURNS 1 IF OUT OF MEMORY DURING TIMBRE HEAD	*/
/*	BLOCK ALLOCATION											*/


COMPACT.TIMBRES:PROC(XBASE,MAX#) PUBLIC SWAPABLE;	/*	PROCEDURE TO COMPACT IN-CORE TIMBRES AS REQUIRED IN SEQUENCER, OR BANK	*/
	DCL (XBASE,MAX#)	FIXED;				/*	HOLDS XMEM BASE, # OF TIMBRES	*/
	DCL (TB,PTL)		FIXED;				/*	COUNTERS								*/
	DCL (SOUP,DESP)	FIXED;				/*	SOURCE # DEST POINTERS			*/
	DCL (L,M,N,P)		FIXED;
	DCL (TIM.HEADP)	FIXED;
	DCL (BASE )			FIXED STATIC;

	DCL (PARTIAL.POINTERS) (NUM.PARTIALS-1)	FIXED;
	DCL (PINFO.POINTERS	) (NUM.PARTIALS-1)	FIXED;
	DCL (TINFO.POINTER	)							FIXED;

	W.LOOKUP:PROC(PTR);						/*	LOOK UP WORD OFF OF BASE	*/
		DCL PTR	FIXED;
		WRITE(MAM)=BASE+SHR(PTR,8); WRITE(MAL)=PTR;
		RETURN READ(MD);
	END W.LOOKUP;

	W.STORE:PROC(PTR,VAL);
		DCL (PTR,VAL)	FIXED;
		WRITE(MAM)=BASE+SHR(PTR,8); WRITE(MAL)=PTR;
		WRITE(MDI)=VAL;
	END W.STORE;

	/*	$PAGE - PERFORM GARBAGE COLLECTION ON TIMBRE STORAGE	*/

	BASE = XBASE;

	SOUP=0; DESP=0;							/*	EVERYTHING IS BASED ON PASSED BASE	*/

	DO TB=0 TO MAX#-1;						/*	COLLECT ALL TIMBRES		*/

		TIM.HEADP=0;							/*	ASSUME NO TIMBRE HEAD	*/

		IF BASE=PAR.PTR THEN DO;			/*	ALLOCATE BLOCKS & SET POINTERS IF PAR.PTR AREA	*/

			WRITE(MAM)=TIM.HEAD;				/*	LOOK UP TIMBRE HEAD SECTOR #	*/
			WRITE(MAL)=TB;
			TIM.HEADP=READ(MD);				/*	SEE IF TIMBRE HEAD ALLOCATED	*/

			IF TIM.HEADP=0 THEN DO;			/*	NOT ALLOCATED - TRY FOR ONE	*/

				IF TIM.FREE=0 THEN DO;		/*	NO BLOCK - ALLOCATE ONE	*/
					L=TIM.LEN;					/*	SAVE CURRENT LENGTH		*/
					IF GET.TIM.STORAGE(TIM.LEN+1) <> 0 THEN DO;
						TIM.FREE=L+1;
						TIM.#FREE=TIM.#FREE+1;
						WRITE(MAM)=TIM.PTR+TIM.FREE-1;
						WRITE(MD )=0;			/*	END OF LINKED LIST		*/
					END;
					BASE=PAR.PTR;				/*	RESET BASE IN CASE MOVED	*/
				END;

				IF TIM.FREE<>0 THEN DO;		/*	ASSIGN TIMBRE HEAD IF BLOCK AVAILABLE	*/

					TIM.HEADP=TIM.PTR+TIM.FREE-1;	/*	GET ABSOLUTE PTR	*/

					WRITE(MAM)=TIM.HEAD;		/*	STORE IN LOOK UP TABLE	*/
					WRITE(MAL)=TB;
					WRITE(MD )=TIM.HEADP;

					WRITE(MAM)=TIM.HEADP;	/*	POINT TO BLOCK					*/
					TIM.FREE=READ(MD);		/*	ADVANCE TO NEXT FREE BLK	*/
					TIM.#FREE=TIM.#FREE-1;

					DO L=0 TO 255;				/*	INITIALIZE THD BLK TO 0	*/
						WRITE(MDI)=0;
					END;

				END;
			END;

		END;


		DO PTL=0 TO NUM.PARTIALS-1;				/*	PROCESS EACH PARTIAL	*/

			PARTIAL.POINTERS(PTL)=DESP;			/*	PARTIAL WILL GO HERE	*/
			PINFO.POINTERS  (PTL)=0;				/*	NO  PINFO YET			*/

			IF W.LOOKUP(SOUP)=SUP THEN DO;		/*	SUPPRESSED PARTIAL	*/
				CALL W.STORE(DESP,SUP);
				SOUP=SOUP+1;
				DESP=DESP+1;
			END;

			ELSE IF ((BASE<>PAR.PTR)\(TB<>0))	/*	IF COMPACTING BANK, OR IF NON KEYBOARD TIMBRE	*/
			AND	  (((W.LOOKUP(SOUP+P.EPEAKL)\W.LOOKUP(SOUP+P.ESUSTL))&"1777")=0)	/*	AND NO PEAK/SUST LEVEL	*/
			THEN DO;										/*	NO PEAK/SUSTAIN LIMIT - TOSS IT IF NON-KEYBOARD TIMBRE, OR IF COMPACTING BANK	*/
				SOUP=SOUP+NUM.PARAMS;				/*	GET POINTER TO AFTER THIS PARTIAL	*/
				DO WHILE W.LOOKUP(SOUP)=MOR;		/*	TOSS FRAME	*/
					SOUP=SOUP+W.LOOKUP(SOUP+CLEN);
				END;
				IF W.LOOKUP(SOUP)=PINFO THEN SOUP=SOUP+PINFO.LEN;	/*	SKIP OVER EXTRA PARTIAL INFO	*/
				CALL W.STORE(DESP,SUP);
				DESP=DESP+1;							/*	COMPRESS THIS PARTIAL TO ZIPPO	*/
			END;

			ELSE DO;										/*	COPY OVER ACTIVE PARTIALS	*/

				CALL COPY.EXT.MEM(BASE,SOUP,BASE,DESP,NUM.PARAMS);

				SOUP=SOUP+NUM.PARAMS;
				DESP=DESP+NUM.PARAMS;
				DO WHILE W.LOOKUP(SOUP)=MOR;
					M=W.LOOKUP(SOUP+CLEN);
					CALL COPY.EXT.MEM(BASE,SOUP,BASE,DESP,M);
					SOUP=SOUP+M;

               // Prune patch timbres that have space for a long file name but the long file name is not there any more
               if  ((w.lookup(desp+type  ) == pt.type)
               &&   (w.lookup(desp+clen  ) >  pt.len )
               &&   (w.lookup(desp+pt.len) == 0      )) {
                  W.STORE(desp+clen, pt.len);
                  desp = desp + pt.len;
               }

               // Else keep the whole frame, whether it is longer or not
               else
                  DESP=DESP+M;

				END;
				IF W.LOOKUP(SOUP)=PINFO THEN DO;	/*	COPY NEW PARTIAL INFO	*/
					PINFO.POINTERS(PTL)=DESP;		/*	PINFO IS HERE				*/
					CALL COPY.EXT.MEM(BASE,SOUP,BASE,DESP,PINFO.LEN);
					SOUP=SOUP+PINFO.LEN;
					DESP=DESP+PINFO.LEN;
				END;

			END;
		END;

		/*	$PAGE - CHECK FOR OPTIONAL TINFO BLOCK	*/

		IF W.LOOKUP(SOUP)=TINFO THEN DO;	/*	TIMBRE INFO FOUND	*/
			TINFO.POINTER=DESP;				/*	TINFO IS HERE		*/
			CALL COPY.EXT.MEM(BASE,SOUP,BASE,DESP,TINFO.LEN);
			DESP=DESP+TINFO.LEN;
			SOUP=SOUP+TINFO.LEN;
		END;
		ELSE TINFO.POINTER=0;				/*	NO TINFO AREA		*/

		IF TIM.HEADP<>0 THEN DO;			/*	STORE POINTERS		*/
			WRITE(MAM)=TIM.HEADP;
			WRITE(MAL)=TIM.MISC.POINTER;
			WRITE(MD )=DESP;
			WRITE(MAL)=TIM.TINFO.POINTER;
			WRITE(MD )=TINFO.POINTER;
			DO PTL=0 TO NUM.PARTIALS-1;
				WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
				WRITE(MD )=PARTIAL.POINTERS(PTL);
				WRITE(MAL)=TIM.PINFO.POINTERS+PTL;
				WRITE(MD )=PINFO.POINTERS(PTL);
			END;
		END;

		CALL COPY.EXT.MEM(BASE,SOUP,BASE,DESP,NUM.MISC.PARAMS);
		SOUP=SOUP+NUM.MISC.PARAMS;
		DESP=DESP+NUM.MISC.PARAMS;

	END;	/*	OF LOOP OVER TIMBRES TO COMPACT	*/

	IF BASE=PAR.PTR THEN DO;				/*	COMPACTING PARAMETERS			*/
		PAR.TOP =DESP;							/*	SAVE TOTAL LENGTH (WORDS)		*/
		PAR.NUMT=MAX#;							/*	SAVE NUMBER OF TIMBRES			*/
		PAR.LEN =SHR(PAR.TOP+255,8);		/*	FREE UP UNUSED PAR.LEN			*/
		IF MAX#=0 THEN MAX#=1;				/*	SERIOUS ERROR HERE				*/
		DO L=MAX# TO MAX.TIMBRES-1;		/*	FREE UP UNUSED TIM HEADS		*/
			WRITE(MAM)=TIM.HEAD;				/*	LOOK UP TIMBRE HEAD SECTOR #	*/
			WRITE(MAL)=L;
			IF READ(MD)<>0 THEN DO;			/*	FREE UP BLOCK						*/
				M=READ(MD);						/*	SAVE POINTER						*/
				WRITE(MD )=0;					/*	CLEAR IT								*/
				DO N=0 TO NUM.PARTIALS-1;	/*	ALSO FREE UP KEYBOARD BLOCKS	*/
					WRITE(MAM)=M;				/*	POINT TO TIMBRE HEAD				*/
					WRITE(MAL)=TIM.KBDTAB.PTR+N;
					IF READ(MD)<>0 THEN DO;	/*	FREE UP KBD BLOCK IF THERE		*/
						P=READ(MD);				/*	GET POINTER							*/
						WRITE(MD)=0;			/*	ZERO BLOCK FOR CONSISTENCY		*/
						WRITE(MAM)=TIM.PTR+P-1;
						WRITE(MD )=TIM.FREE;	/*	CONSTRUCT LINKED LIST	*/
						TIM.FREE=P;
						TIM.#FREE=TIM.#FREE+1;
					END;
				END;
				WRITE(MAM)=M;
				WRITE(MD )=TIM.FREE;			/*	CONSTRUCT LINKED LIST	*/
				TIM.FREE=M-TIM.PTR+1;		/*	RELATIVE POINTER +1		*/
				TIM.#FREE=TIM.#FREE+1;
			END;
		END;
		WRITE(MAM)=USE.PTR;					/*	CLEAN UP THE USAGE COUNTER TABLE	*/
		WRITE(MAL)=MAX#;						/*	NOW THAT WE HAVE ERASED ALL THESE TIMBRES	*/
		DO L=MAX# TO MAX.TIMBRES-1;
			WRITE(MDI)=0;
		END;

      // Compute new current frame pointers
      do l=0 to num.partials-1;
         FR.PTRS(l) = FIND.FRAME(l,C.FRAME(l));
      end;
	END;

	ELSE IF BASE=BNK.PTR THEN DO;
		ACTIVE.BANK.LEN = DESP;					/*	SAVE TOTAL LENGTH (WORDS)	*/
		BNK.LEN=SHR(ACTIVE.BANK.LEN+255,8);	/*	FREE UP UNUSED BANK LENGTH	*/
	END;

END COMPACT.TIMBRES;
