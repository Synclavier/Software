/*	:SYNRSOU:03-PRIM:041MAPSA - More routines to manage Sequencer Tempo Map	*//*Modified:1999/04/16 - TY  - Fixed bugs in "Advance.To.Next.Tempo.Record" and "Backup.To.Prior.Tempo.Record".1999/03/30 - TY  - Rewrote "Delete.Tempo.Record" to maintain record numbers.					  - Fixed bugs in "Delete.Tempo.Record".  It failed to call "Normalize.Tempo.Map.Times"						 whenever the deleted record was the only one in the block, even though there may						 be subsequent blocks.  Also it passed (NAH.PTR-Tempo.Map.Ptr) to "Deallocate.NAH.Block"						 when it should have passed (Tempo.Map.Ptr-NAH.PTR).1999/03/22 - TY  - Added procedure "Rebuild.Record.Numbers"1991/02/14 - cj  - Checked for null tempo map1990/10/15 - PF  - Created this file*///	"Rebuild.Record.Numbers" goes through the tempo or meter map and, for each NLS in the linked list,//	it recalculates the record number of the first record and writes that information into words 5 and 6.//	This should be called whenever a record is inserted or deleted in order to maintain the correct information//	in words 5 and 6 of each NLS.  Also since sequences have been saved in the past with this information not//	correctly maintained, it will be necessary to call this procedure (with "all" set to true) when loading a//	sequence from disk.//Rebuild.Record.Numbers: proc (map#,all) public swapable;	dcl map#	fixed;	//	Pass Tempo.Map# or Meter.Map#	dcl all	boolean;	//	Pass true to start from the beginning							//	Pass false to start from the current NLS	dcl (Map.Ptr, Map.Cur, Map.Len)	fixed;	//	Make local copies of the current map variables	if (map# == Tempo.Map#) {		Map.Ptr = Tempo.Map.Ptr;		Map.Cur = Tempo.Map.Cur;		Map.Len = Tempo.Map.Len;		//	To avoid having to repeatedly branch later...		write("313") = Tempo.Map.Rec.Len;	}	else {				//	Assume only Tempo.Map# or Meter.Map# are passed		Map.Ptr = Meter.Map.Ptr;		Map.Cur = Meter.Map.Cur;		Map.Len = Meter.Map.Len;		//	To avoid having to repeatedly branch later...		write("313") = Meter.Map.Rec.Len;	}	//	Make sure we're pointing to the current NLS	write(mam) = Map.Ptr;	if (all != false) {		//	We must first back up to the first NLS		write(mal) = Tempo.Map.REV;		//	Point to the current NLS's reverse pointer for the loop condition.		while (read(md) != null) {			//	While it's not null,			Map.Ptr = NAH.PTR + read(md);	//	make "Map.Ptr" point to the previous nls.			write(mam) = Map.Ptr;			write(mal) = Tempo.Map.REV;	//	Then point to it's reverse pointer for the loop condition.		}		//	Count from 0		Bitmsb = 0;		Bitlsb = 0;	}	else {		//	Count from the record number of the first record in the current sector		write(mal) = Tempo.Map.Rec#.Msb;		Bitmsb = read(mdi);		Bitlsb = read(md );	}	//	Link through any subsequent NLS blocks	write(mal) = Tempo.Map.FOR;			//	Point to the current NLS's forward pointer for the loop condition.	while (read(md) != null) {				//	While it's not null...		//	Calculate the record number of the first record in the next block		write(mal) = Tempo.Map.FP;		Map.Cur = read(mdi);		Map.Len = read(md );		write(5) = (Map.Len-Map.Cur);		//	Load total length of records in this NLS.		write(7) = read("313");				//	Divide by the appropriate record length to get the number of records in this NLS.		Add16(read(5),BitMsbArray);		//	Add the result to our running total.		write(mal) = Tempo.Map.FOR;		//	Point to the current NLS's forward pointer again.		Map.Ptr = NAH.PTR + read(md);		//	Make "Map.Ptr" point to the next NLS.		write(mam) = Map.Ptr;				//	Point to it.		write(mal) = Tempo.Map.Rec#.Msb;	//	Point to where the record numbers belong.		write(mdi) = Bitmsb;					//	Stash 'em.		write(md ) = Bitlsb;		write(mal) = Tempo.Map.FOR;		//	Point to the forward pointer for the loop condition.	}end Rebuild.Record.Numbers;//	"Garbage.Collect.Map" goes through the entire tempo or meter map and compacts the records.//	This should be called when saving a sequence to disk since the insert and delete routines can leave//	a rather sparse and fragmented map.  Since sequences have been saved in the past with sparse and//	fragmented maps, it may be worthwhile to call this when loading a sequence from disk as well.///*Garbage.Collect.Map: proc (map#);	dcl map#	fixed;	//	Pass Tempo.Map# or Meter.Map#	//	OUT TO LUNCHend Garbage.Collect.Map;*//*	Routine to delete tempo segment at Seq.Time	*/Delete.Tempo.Record: proc (Seq.Time) public swapable;	dcl Seq.Time	array;	dcl len			fixed;	dcl (x,y)		fixed;	dcl fp	lit 'x';	dcl rp	lit 'y';	if Tempo.Map.Ptr = 0						/*	should always be one		*/	then return;								/*	but just in case			*/	x = Seq.Time(0);							/*	get sequence time handy	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for zero time		*/	then y = zero.time;						/*	can't insert records before zero time	*/	/*	Find the tempo segment that contains this delta time.			*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	The tempo pointers are now pointing at the tempo record to delete.	*/	/*	First check to see if this is the first tempo segment.					*/	if  (Tempo.Map.This.Seq.Msb = 0)	and (Tempo.Map.This.Seq.Lsb ile zero.time)	then return;											/*	can't delete	*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;	if (Tempo.Map.Cur = read(md))						/*	if this record is the	*/	then do;													/*	first in this sector		*/		//	NOTE: If we're here, then the value at Tempo.Map.Rev cannot be null		write(mal) = Tempo.Map.REV;					/*	get reverse ptr			*/		write(mam) = NAH.PTR + read(md);				/*	point to prior sector	*/		write(mal) = Tempo.Map.LP;		write(mal) = read(md);		write(mdi) = Tempo.Map.Next.Seq.Msb;		/*	update times of next segment	*/		write(mdi) = Tempo.Map.Next.Seq.Lsb;		//	The following information will likely be incorrect after the deletion anyway		//	and will need to be rebuilt with Normalize.Tempo.Map.Times		write(mdi) = Tempo.Map.Next.Real.Msb;		write(md ) = Tempo.Map.Next.Real.Lsb;		write(mam) = Tempo.Map.Ptr;					/*	restore mam and mal	*/		write(mal) = Tempo.Map.LP;		/*	now check to see if this is the only tempo record in this sector	*/		if ((Tempo.Map.Cur + Tempo.Map.Rec.Len) == read(md)) {			write(mal) = Tempo.Map.FOR;			fp = read(mdi);			rp = read(md );			Deallocate.NAH.Block(Tempo.Map.Ptr-NAH.PTR);			//	Update the previous NLS's forward pointer			//	NOTE: (rp != 0) will always be true if we're here			Tempo.Map.Ptr = NAH.PTR + rp;			write(mam) = Tempo.Map.Ptr;			//	write(mal) = Tempo.Map.FOR;	//	This is automatically accomplished by the prior statement			write(md)  = fp;			// Make current the record prior to the one we deleted			write(mal) = Tempo.Map.LP;			Tempo.Map.Len = read(md);			Tempo.Map.Cur = read(md)-Tempo.Map.Rec.Len;			Normalize.Tempo.Map.Cur();			//	See if we have a subsequent NLS			if (fp != null) {				//	Update the subsequent NLS's reverse pointer				write(mam) = NAH.PTR + fp;				write(mal) = Tempo.Map.REV;				write(md ) = rp;				//	If we're here, then we have subsequent Tempo records who's real times will				//	have to be recalculated by Normalize.Tempo.Map.Times due to our deletion.				Rebuild.Record.Numbers(Tempo.Map#, false);				Normalize.Tempo.Map.Times();			}			// Else no need to call "Rebuild.Record.Numbers" or "Normalize.Tempo.Map.Times"			//	because we deleted the last record in the map			return;	//	We are done		}	end;	//	of "this record is the first in this sector"	/*	We are now pointing at the tempo record to be deleted so all	*/	/*	we have to do is copy the rest of this sector down.				*/	/*	First compute len of data to be copied including 4 words of		*/	/*	"next segment times" which must be maintained.						*/	len = Tempo.Map.Len - Tempo.Map.Cur - Tempo.Map.Rec.Len + 4;	write(mam) = Tempo.Map.Ptr;				/*	point to start of date to be copied	*/	write(mal) = Tempo.Map.Cur + Tempo.Map.Rec.Len;	write("300")=addr(misc.buf(0));			/*	copy data to misc.buf		*/	rpc len;	write("360")=read(mdi);	write(mal) = Tempo.Map.Cur;				/*	point back to destination	*/	write("300") = addr(misc.buf(0));		/*	write the data back in		*/	rpc len;	write(mdi) = read("360");	write(mal) = Tempo.Map.LP;					/*	update LP Tempo Map info	*/	Tempo.Map.Len = read(md) - Tempo.Map.Rec.Len;	/*	just lost one record from this block	*/	write(md ) = Tempo.Map.Len;	// Make current the record prior to the one we deleted	Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;	Normalize.Tempo.Map.Cur();	//	Make everything groovy	//	If there are records subsequent to our new current record, then their real times	//	will have to be recalculated by Normalize.Tempo.Map.Times due to our deletion.	write(mal) = Tempo.Map.For;	if ((Tempo.Map.Cur != (Tempo.Map.Len - Tempo.Map.Rec.Len)) || (read(md) != null)) {		If (read(md) != null) Rebuild.Record.Numbers(Tempo.Map#, false);		Normalize.Tempo.Map.Times();	}end Delete.Tempo.Record;dcl Check.For.Tempo.Meter.Events proc (fixed array) recursive;/*	Routine to advance sequencer to start time of next tempo segment	*/Advance.To.Next.Tempo.Record: proc public swapable;	dcl (x,y)	fixed;	dcl seq.time(1)	fixed;	if (Tempo.Map.Ptr == 0) return;	//	Don't even acknowledge a non-function	call stop.recd.move.play;	disable;		x = play.time.msb;		y = play.time.lsb;	enable;	//	In case sequencer has been play.initialized, allow us to advance to the second event on the first press	if ((x == 0) && (y ilt zero.time)) y = zero.time;	//	Bug Fix: If you had two adjacent records with the same tempo, and you changed the tempo of	//	the first, then advanced to the second, the upper display would not update.  This happened	//	because the checksum in "Check.For.Tempo.Meter.Events" was not updated since the tempo was changed.	//	Hence, we will first call "Check.For.Tempo.Meter.Events" to update the checksum for proper comparison	//	with the record we are about to advance to.	Map.Real.Time.To.Sequence.Time(loc(addr(x)),seq.time);	Check.For.Tempo.Meter.Events(seq.time);		/*	Find the tempo segment that contains this real time.	*/	do while	((x ILT Tempo.Map.This.Real.Msb))	/*	back up if we are		*/	or			((x =   Tempo.Map.This.Real.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Real.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Real.Msb))	/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Real.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Real.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						 ));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	now get start time of next tempo seqment	*/	x = Tempo.Map.Next.Real.Msb;	y = Tempo.Map.Next.Real.Lsb;	if  (x = (-1))							/*	check for no next segment	*/	and (y = (-1))	then do;											/*	do nothing	*/		call display.sequencer.status;		//	show that we stopped		broadcast.mtc();		return;	end;	move = 1; move.speed = 1;	call display.sequencer.status;	call advance.sequencer(x,y);	move = 0; move.speed = 0;	call display.sequencer.status;	//	Bug Fix: Without the following line, the lower display will not be updated when	//	advancing to an event at the next beat or sooner.	//	Note: This lower display doesn't show the actual time of the event (unless it's exactly on a beat).	//	Hence, it should eventually be replaced by an accurate display.	new.beat.number = true;	broadcast.mtc();end Advance.To.Next.Tempo.Record;/*	Routine to backup sequencer to prior tempo segment	*/Backup.To.Prior.Tempo.Record: proc public swapable;	dcl (x,y)			fixed;	dcl seq.time(1)	fixed;	if (Tempo.Map.Ptr == 0) return;	//	Don't even acknowledge a non-function	call stop.recd.move.play;	disable;		x = play.time.msb;		y = play.time.lsb;	enable;	if (x = 0) and (y ile zero.time)			/*	sequencer is already at zero	*/	then do;											/*	do nothing	*/		call display.sequencer.status;		//	show that we stopped		broadcast.mtc();		return;	end;	//	Bug Fix: If you had two adjacent records with the same tempo, and you changed the tempo of	//	the second, then backed up to the first, the upper display would not update.  This happened	//	because the checksum in "Check.For.Tempo.Meter.Events" was not updated since the tempo was changed.	//	Hence, we will first call "Check.For.Tempo.Meter.Events" to update the checksum for proper comparison	//	with the record we are about to back up to.	Map.Real.Time.To.Sequence.Time(loc(addr(x)),seq.time);	Check.For.Tempo.Meter.Events(seq.time);	/*	Find the tempo segment that contains this real time.	*/	do while	((x ILT Tempo.Map.This.Real.Msb))	/*	back up if we are		*/	or			((x =   Tempo.Map.This.Real.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Real.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Real.Msb))	/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Real.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Real.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						 ));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	if  (play.time.msb = Tempo.Map.This.Real.Msb)	/*	we are sitting at	*/	and (play.time.lsb = Tempo.Map.This.Real.Lsb)	/*	start of segment	*/	then do;														/*	backup one more segment	*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	now get start time of prior tempo seqment	*/	x = Tempo.Map.This.Real.Msb;	y = Tempo.Map.This.Real.Lsb;	if  (x = 0)									/*	check for backup to zero	*/	and (y ile zero.time)	then do;		call play.initialize;				/*	just do a play init	*/		new.beat.number = 1;					/*	update beat display	*/		call display.sequencer.status;	/*	and buttons	*/		broadcast.mtc();		return;									/*	bail out	*/	end;	move = 1; move.speed = (-1);	call display.sequencer.status;	call rebuild.event.queue;	call backup.sequencer(x,y);	move = 0; move.speed = 0;	call rebuild.event.queue;	call display.sequencer.status;	//	Bug Fix: Without the following line, the lower display would not be updated when	//	backing up to an earlier event within the same beat.	//	Note: This lower display doesn't show the actual time of the event (unless it's exactly on a beat).	//	Hence, it should eventually be replaced by an accurate display.	new.beat.number = true;	broadcast.mtc();end Backup.To.Prior.Tempo.Record;