/*	:SYNRSOU:03-PRIM:042METRA  -  More routines to manage Sequencer Meter Map	*//*Modified:1999/04/17 - TY  - Made "Insert.Tempo.Record" and "Insert.Meter.Record" move the sequencer to the						 inserted event.  This assures that subsequently setting a parameter will affect						 the inserted event instead of the prior event.  It also facilitates moving to the						 next or prior event with one button press.					  - Also modified "Insert.Meter.Record" to justify to the nearest measure boundary rather						 than to the prior measure boundary.1999/04/11 - TY  - Modified "Erase.Meter.Map.Info" to retain the meaningful value of Samp.Click.Rate1999/04/04 - TY  - Added code to Create.Default.Meter.Map to preserve the sequencer start mark.						 Also Sampled.Actual.Sequence.Time wasn't correctly preserved.1999/03/30 - TY  - Rewrote "Insert.Tempo.Record", "Insert.Meter.Record" and "Delete.Meter.Record"						 To maintain record numbers and to prevent wasted sectors.					  - Fixed bugs in "Delete.Meter.Record".  It failed to call "Normalize.Meter.Map.All"						 whenever the deleted record was the only one in the block, even though there may						 be subsequent blocks.  Also it passed (NAH.PTR-Meter.Map.Ptr) to "Deallocate.NAH.Block"						 when it should have passed (Meter.Map.Ptr-NAH.PTR).1999/03/29 - TY  - Removed unused parameter "record#" from "Append.Sequencer.Meter.Map.Record"1991/04/26 - cj -  Added routine to check for tempo/meter events1991/03/18 - cj -  Corrected play time when creating default map1991/03/14 - cj -  moved some routines here. Simplified lookup.beat.rate.						 made lookup.tempo handle unusual ratios1991/02/14 - cj  - bug fix in Lookup.Tempo1991/02/08 - PF  - Check limits in Set.Tempo and Set.Beats.Per.Measure1991/02/06 - PF  - Begin counting measures at zero1991/02/01 - PF  - Fixed minor bug in Compute.Time.Of.Nearest.Meters1991/01/19 - PF  - Increased Tempo resolution to microseconds per beat1991/01/17 - PF  - Fixed bug: Changing Tempo when denominator not equal to MIDI quarter note.1991/01/09 - PF  - allow editing of beats per measure display1990/07/16 - PF  - Broke this file off from 042-METR*/dcl Lookup.Tempo	proc (array,array) recursive;dcl Scroll.Seq		proc (fixed,fixed,boolean) external;/*	Routine to erase meter map from the sequencer	*/Erase.Meter.Map.Info: proc PUBLIC swapable;	dcl i				fixed;	dcl j				fixed;	dcl tempo(1)	fixed;	dcl zerot(1)	fixed;	dcl bpm			fixed;	if PLAY <> 0					/*	stop playing when changing sequencer	*/	then call STOP.SEQUENCER;	/*	map (mostly for PLAY.INITIALIZE)			*/	call STR32(0, zero.time, zerot);			/*	get current tempo at 0.000	*/	call Lookup.Tempo (zerot,tempo);			/*	to restore click rate to	*/	bpm = Lookup.Beats.Per.Measure(zerot);	/*	and bpm as well				*/	/*	See if meter map exists in the sequence:	*/	write(mam) = BAS.PTR;	write(mal) = Seq.Map.Ptrs + Meter.Map#;	i = read(md);						/*	get pointer to first block (if any)	*/	if i = 0								/*	if not, then we are done				*/	then return;	write(md) = 0;						/*	no map now									*/	Meter.Map.Ptr = 0;				/*	zero out absolute pointer				*/	/*	Now free up all data storage blocks:	*/	do while i <> 0;								/*	free up all the blocks		*/		write(mam) = NAH.PTR + i;				/*	that had been allocated.	*/		j = read(md);								/*	get forward pointer.			*/		call Deallocate.NAH.Block(i);			/*	free up first block			*/		i = j;										/*	move on to next.				*/	end;	call Normalize.Meter.Map.Cur;				/*	set up globals					*/	SAMP.BPM   = bpm;	write(mam) = BAS.PTR;	//	write(mal) = SEQ.CLICK;				//	restore new click rate to base sector	//	write(md ) = SAMP.CLICK.RATE;	write(mal) = SEQ.BPM;					//	restore new bpm to base sector	write(md ) = SAMP.BPM;	call PLAY.INITIALIZE;					/*	recompute all sequencer variables	*/	/*	Create a system event since some constants have likely changed:	*/	New.Seq.Info = New.Seq.Info \ 8;end Erase.Meter.Map.Info;/*	Routine to create a default meter map	*/dcl Set.Tempo proc (array, array) recursive;Create.Default.Meter.Map: proc public swapable;	dcl i				fixed;	dcl tempo(1)	fixed;	dcl zerot(1)	fixed;	if Meter.Map.Ptr <> 0		/*	if one is there already, do not	*/	then return;					/*	touch it!!								*/	if PLAY <> 0					/*	stop playing when changing sequencer	*/	then call STOP.SEQUENCER;	/*	map (mostly for PLAY.INITIALIZE)			*/	call PLAY.INITIALIZE;		/*	initialize here to find out if empty	*/	/*	If the sequence is empty, set up for divisions = 480, but keep		*/	/*	the tempo the same																*/	if NEXT.EVENT.QUEUE = 0		/*	if had been empty sequence, then			*/	then do;							/*	set to divisions = 480						*/		load SAMP.CLICK.RATE;	/*	get current beat/click rate				*/		mul  1000;					/*	get in microseconds							*/		tempo(0) = ures;			/*	save for setting the tempo below			*/		tempo(1) = res;		/*	scale the sampled actual sequence time for our change in			*/		/*	divisions so the first actual tempo/meter record gets				*/		/*	inserted at the right sequence time:									*/		if (com16(zero.time,loc(addr(sampled.actual.sequence.time.msb))) == lw#ilt) {			BITMSB = sampled.actual.sequence.time.msb;			BITLSB = sampled.actual.sequence.time.lsb;			Sub16(zero.time, BitMsbArray);			ratio_multiply(480, SAMP.CLICK.RATE);			Add16(zero.time, BitMsbArray);			sampled.actual.sequence.time.msb = BITMSB;			sampled.actual.sequence.time.lsb = BITLSB;		}	//	Else is already correct		//	Also maintain real time of sequencer start mark		if (com16(zero.time,loc(addr(MARK.BUTTON.MSB))) == lw#ilt) {			BITMSB = MARK.BUTTON.MSB;			BITLSB = MARK.BUTTON.LSB;			Sub16(zero.time, BitMsbArray);			ratio_multiply(480, SAMP.CLICK.RATE);			Add16(zero.time, BitMsbArray);			MARK.BUTTON.MSB = BITMSB;			MARK.BUTTON.LSB = BITLSB;			WRITE(MAM) = BAS.PTR;	//	store in base sector			WRITE(MAL) = SEQ.MARK.MSB;			WRITE(MDI) = MARK.BUTTON.MSB;			WRITE(MD ) = MARK.BUTTON.LSB;		}	//	Else is already correct		SAMP.CLICK.RATE = 480;		write(mam) = BAS.PTR;	/*	store in base sector	*/		write(mal) = SEQ.CLICK;		write(md ) = SAMP.CLICK.RATE;	end;	i = Allocate.Map.Block(0, 0, Meter.Map#);	if i = 0					/*	out of room for meter map.	*/	then return;	Meter.Map.Len = Meter.Map.First + Meter.Map.Rec.Len;	/*	word end of map in this sector	*/	Meter.Map.Cur = Meter.Map.First;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.FP;	write(mdi) = Meter.Map.First;	write(mdi) = Meter.Map.Len;	write(mdi) = 0;			/*	initialize record # to 0		*/	write(md ) = 0;	write(mal) = Meter.Map.First;	write(mdi) = 0;			/*	delta-time of record 1			*/	write(mdi) = zero.time;	write(mdi) = 0;			/*	measure#								*/	write(mdi) = 0;	write(mdi) = 0;			/*	beat#									*/	write(md ) = 0;//	write(mdi) = 0;			/*	clicks/division					*///	write(mdi) = 131;			/*	note: these ratios are			*///	write(mdi) = 4719;		/*	recomputed below:					*///	write(mdi) = 500;			/*	divisions/click					*///	write(mdi) = 0;//	write(mdi) = 0;//	write(mdi) = 0;			/*	measures/division					*///	write(mdi) = 32;//	write(mdi) = 50332;//	write(mdi) = 2000;		/*	divisions/measure					*///	write(mdi) = 0;//	write(mdi) = 0;//	write(mdi) = 0;			/*	beats/division						*///	write(mdi) = 131;//	write(mdi) = 4719;//	write(mdi) = 500;			/*	divisions/beat						*///	write(mdi) = 0;//	write(mdi) = 0;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	write(mdi) = SAMP.BPM;	/*	nn										*/	write(mdi) = 2;			/*	dd	(quarter note)					*/	write(mdi) = 24;			/*	cc										*/	write(mdi) = 8;			/*	bb										*/	write(mdi) = -1;	/*	set up + infinity for start times	*/	write(mdi) = -1;	/*	of non-existent next segment.			*/	write(mdi) = -1;	write(mdi) = -1;	write(mdi) = -1;	write(md ) = -1;	/*	Compute the correct ratios for this default entry:	*/	Update.Meter.Map.Ratios();	Normalize.Meter.Map.Cur();	//	Set global variables		/*	And set the tempo to provide the original tempo		*/	/*	in case we changed our divisions to 1.0000			*/	if NEXT.EVENT.QUEUE = 0	then do;		call STR32(0, zero.time, zerot);		call Set.Tempo(zerot, tempo);	end;	call PLAY.INITIALIZE;	/*	recompute all sequencer variables	*/	/*	Create a system event since some constants have likely changed:	*/	New.Seq.Info = New.Seq.Info \ 8;end Create.Default.Meter.Map;/*	find beat rate at passed sequence time	*/Lookup.Beat.Rate: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl prior(1)	fixed;	dcl next (1)	fixed;	call Map.Sequence.Time.To.Nearest.Beats(Seq.Time, prior, next);	return (next(1) - prior(1));end Lookup.Beat.Rate;/*	Routine to adjust beats per measure at passed seq time	*/Set.Beats.Per.Measure: proc (Seq.Time,Bpm) public swapable;	dcl Seq.Time	array;	dcl Bpm		fixed;	dcl (x,y)	fixed static;	if Meter.Map.Ptr = 0				/*	no meter map	*/	then do;		return;	end;	x = Seq.Time(0);					/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for time less than		*/	then y = zero.time;						/*	start of first segment			*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	check limits of passed beats per measure	*/	if		  Bpm igt 128 then Bpm = 128;	else if Bpm ilt 1   then Bpm = 1;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	/*	numerator		*/	write(md ) = Bpm;	Update.Meter.Map.Ratios();				//	recompute all ratios in this record	Normalize.Meter.Map.TimesBeats();	//	recompute start times and beat numbers for all subsequent records	new.seq.info = new.seq.info \ 8;					/*	new constants	*/end Set.Beats.Per.Measure;Set.Denom: proc (Seq.Time,Denom) public swapable;	dcl Seq.Time	array;	dcl Denom	fixed;	dcl (x,y)	fixed static;	if Meter.Map.Ptr = 0				/*	no meter map	*/	then do;		return;	end;	x = Seq.Time(0);					/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for time less than		*/	then y = zero.time;						/*	start of first segment			*/	/*	Find the meter segment that contains this delta time.	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.dd;	/*	denominator		*/	write(md ) = Denom;	Update.Meter.Map.Ratios();				//	recompute all ratios in this record	Normalize.Meter.Map.TimesBeats();	//	recompute start times and beat numbers for all subsequent records	new.seq.info = new.seq.info \ 8;					/*	new constants	*/end Set.Denom;/*	Routine to lookup current tempo in microseconds per beat	*/Lookup.Tempo: proc (Seq.Time,Tempo) public swapable;	dcl Seq.Time		array;	dcl Tempo			array;	dcl (x,y)			fixed;	dcl (r1, r2, r3)	fixed;	dcl (x1, x2, x3)	fixed;	dcl (temp)			fixed;	if (Tempo.Map.Ptr = 0)					/*	if no tempo & meter map, then	*/	or (Meter.Map.Ptr = 0)					/*	compute from SAMP.CLICK.RATE	*/	then do;		load SAMP.CLICK.RATE;				/*	return in microseconds			*/		mul  1000;								/*	per									*/		Tempo(0) = ures;						/*	beat									*/		Tempo(1) = res;		return;	end;	x = Seq.Time(0);					/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for time less than		*/	then y = zero.time;						/*	start of first segment			*/	/*	Find the tempo segment that contains this delta time. Then look	*/	/*	up the ratio of milliseconds per delta division:						*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur + Tempo.Map.Rms.d;	r1 = read(mdi);						/*	get ratio of real milliseconds	*/	r2 = read(mdi);						/*	per sequencer division				*/	r3 = read(mdi);	/*	find the meter segment for this time as well.  Look up the number	*/	/*	of divisions per beat															*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.Rd.b;	x1 = read(mdi);	x2 = read(mdi);	x3 = read(md );	/*	basically, we want to compute 1000 * divisions/beat * msec/division	*/	/*	which yields 1000 * msec/beat, or microseconds per beat.				*/	/*	We will do this by starting with 65,536 * divisions/beat,			*/	/*	multiplying by msec/division, then multiplying by 1000/65536.		*/	/*	This computation will be fully accurate for all allowed cases.		*/	/*	Begin by multiplying lowest cross product:								*/	BITMSB = 0;			/*	start with divisions/beat shifted 32 bits			*/	BITLSB = x3;	call MULTIPLY(r1,r2,r3,0);	if BITLSB < 0 then BITMSB = BITMSB + 1;	/*	round							*/	temp = BITMSB;		/*	save for later addition									*/	BITMSB = x1;		/*	compute 65536 * divisions/beat by shifting left	*/	BITLSB = x2;		/*	16 bits.														*/	call MULTIPLY(r1,r2,r3,0);	/*	add in prior cross product:													*/	call ADD16(temp, loc(addr(BITMSB)));	/*	now multiply by 1000/65536 to get microseconds/beat					*/	call ratio_multiply(125,8192);	Tempo(0) = BITMSB;						/*	return 32 bit result				*/	Tempo(1) = BITLSB;						/*	will be rounded to nearest		*/													/*	microsecond							*/end Lookup.Tempo;/*	Routine to set tempo at passed sequencer time	*/Set.Tempo: proc (Seq.Time, Tempo) public swapable;	dcl Seq.Time	array;	dcl Tempo		array;	/*	new tempo			*/	dcl dd			fixed;	/*	holds denominator	*/	dcl bb			fixed;	/*	holds 32nd notes per midi quarter note		*/	dcl cur.seq.time(1)	fixed;	dcl loop			fixed;	dcl click		fixed;	dcl Rb.d			(4)	fixed;	/*	will hold beats per division ratio	*/	dcl onethou		(4)	fixed;	/*	holds 1/1000 (rounded)					*/	dcl micsec.div	(5)	fixed;	/*	holds xx.xxxz micsec/division			*/	dcl msec.div	(8)	fixed;	/*	holds xx.xxxzzzz msec/division		*/	dcl temp			(8)	fixed;	dcl i				fixed;	dcl j				fixed;	dcl x				fixed;	dcl y				fixed;	/*	Routine to compute ratios to 80 bit precision.  For our purposes,	*/	/*	the upper 16 most bits will always be zero.								*/	compute.local.long.ratio:proc(a,b,c,d,r);		dcl (a,b,c,d)	fixed;		dcl r			array;		dcl (x)		fixed;		dcl rnd(4)	fixed;		/*	Remove powers of 2 from numerator and denominator to handle	*/		/*	cases of unusually large Divisions (etc.).						*/		do while	((((a&1) = 0) \ ((b&1)=0))			and	 (((c&1) = 0) \ ((d&1)=0)));			if ((a&1)=0) then	a = shr(a,1);			else					b = shr(b,1);			if ((c&1)=0) then	c = shr(c,1);			else					d = shr(d,1);		end;		c = c*d;	/*	compute denominator; won't overflow in realistic cases	*/		load a; mul b; mwait; div c;		r(0) = res;		x=rem; load 0; uload x; div c; r(1)=res;		x=rem; load 0; uload x; div c; r(2)=res;		x=rem; load 0; uload x; div c; r(3)=res;		x=rem; load 0; uload x; div c; r(4)=res;		if (rem         <  0)		or (shl(rem,1) IGE c)		/*	round up ratio if needed	*/		then do;			rnd(4) = 1;			call multiple.precision.add(r, rnd, r, 5);		end;	end compute.local.long.ratio;	if (Tempo.Map.Ptr = 0)		/*	if no tempo map, then ???	*/	or (Meter.Map.Ptr = 0)	then do;		return;	end;	/*	latch the current sequence time for below	*/	disable;		x = play.time.msb;		y = play.time.lsb;	enable;	call Map.Real.Time.To.Sequence.Time(loc(addr(x)),cur.seq.time);	x = Seq.Time(0);					/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for time less than		*/	then y = zero.time;						/*	start of first segment			*/	/*	Find the tempo segment that contains this delta time.	*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	find the meter segment for this time as well	*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.dd;	dd = read(md);	write(mal) = Meter.Map.Cur + Meter.Map.bb;	bb = read(md);	/*	check limits of passed Tempo	*/	if  (Tempo(0) igt 30)	or  ((Tempo(0) = 30)	and (Tempo(1) igt 33920))				/*	max is 2,000,000	*/	then do;		Tempo(0) = 30;		Tempo(1) = 33920;	end;	else if  (Tempo(0) = 0)					/*	min is 25,000		*/	and (Tempo(1) ilt 25000)	then Tempo(1) = 25000;	/*	Now compute the ratios msec/div and div/msec:						*/	/*	We are passed in the desired # of microseconds per beat.			*/	/*	We want to compute micsec/beat * beats/division * 1/1000 which	*/	/*	yields micsec/division * 1/1000, or milliseconds per division.	*/	/*	We also need to compute 1 over this ratio, all to 48-bit			*/	/*	precision.  Hmm....															*/	/*	Begin by computing some ratios to 80 bit accuracy:					*/	/*	Rb.d = bb / shl(1,5-dd) / divisions										*/	/*	note: assume beats/division will always be less than 1			*/	call compute.local.long.ratio(1,bb,shl(1,5-dd),Divisions,Rb.d);	/*	1/1000																			*/	/*	note: can we assume 1/1000 is less than 1?							*/	call compute.local.long.ratio(1,1,1,1000,onethou);	/*	now compute micsec/beat * rb.d to yield micsec/division			*/	call blockset (micsec.div, 6, 0);					/*	init to 0		*/	do i = 0 to 1;		BITMSB = 0;		BITLSB = Tempo(i);		call MULTIPLY(Rb.d(1), Rb.d(2), Rb.d(3), Rb.d(4));		call blockset (temp, 6, 0);						/*	init to 0		*/		call blockmove(multiply.result, loc(addr(temp(i))), 5);		call multiple.precision.add(micsec.div, temp, micsec.div, 6);	end;	/*	now multiply micsec.div by 1/1000 in pieces							*/	call blockset (msec.div, 9, 0);						/*	init to 0		*/	do i = 0 to 4;		BITMSB = 0;		BITLSB = micsec.div(i);		call MULTIPLY(onethou(1), onethou(2), onethou(3), onethou(4));		call blockset (temp, 9, 0);						/*	init to 0		*/		call blockmove(multiply.result, loc(addr(temp(i))), 5);		call multiple.precision.add(msec.div, temp, msec.div, 9);	end;	/*	round to 64 bits to compute inverse:									*/	call blockset (temp, 9, 0);							/*	init to 0		*/	temp(4) = 1;	if msec.div(5)<0	then call multiple.precision.add(msec.div, temp, msec.div, 9);	/*	now compute inverse ratio:													*/	call LONGINVERT(msec.div(1),msec.div(2),msec.div(3),msec.div(4));	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur + Tempo.Map.Rd.ms;	write(mdi) = BITMSB;			/*	store inverted ratio computed			*/	write(mdi) = BITLSB;			/*	by longinvert								*/	write(mdi) = MUL.LLSB;	/*	now round the msec/div ratio to 48 bits before storing:			*/	call blockset (temp, 9, 0);							/*	init to 0		*/	temp(3) = 1;	if msec.div(4)<0	then call multiple.precision.add(msec.div, temp, msec.div, 9);	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur + Tempo.Map.Rms.d;	write(mdi) = msec.div(1);	write(mdi) = msec.div(2);	write(mdi) = msec.div(3);	call Normalize.Tempo.Map.Times();	//	from this record to the end	/*	new tempo in effect	*/	/*	first set/clear some flags	*/	abort.seq.notes = 1;						/*	abort all sequencer notes since end times are already stored in real times	*/	stop.info.cues	 = 1;						/*	lod notes too			*/	lod.cue.len		 = 0;	auto.punch.in.armed = 0;				/*	disable auto punch since times will now be corrupt	*/	play.seq.to.a.time  = 0;				/*	same for "play to"	*/	delay.note.and.cue.starts = 0;		/*	and "play from"		*/	disable;	/*	temporarily disable overall loop so the	*/	/*	interrupt code doesn't loop us here.		*/	loop = overall.loop;	overall.loop = 0;	/*	disable click output until we have all	*/	/*	of our ducks back in a row.				*/	click = actually.emit.click;	actually.emit.click = 0;	enable;	/*	recalc all important real time variables after tempo change	*/	call Map.Sequence.Time.To.Real.Time(loc(addr(sampled.actual.sequence.time.msb)),													loc(addr(sampled.actual.play.time.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(advanced.seq.time.msb)),													loc(addr(advanced.play.time.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(prior.beat.msb)),													loc(addr(real.time.of.prior.beat.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(next.beat.msb)),													loc(addr(real.time.of.next.beat.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(prior.click.msb)),													loc(addr(real.time.of.prior.click.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(next.click.msb)),													loc(addr(real.time.of.next.click.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(loop.seq.time.msb)),													loc(addr(loop.play.time.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(loop.seq.time.of.next.click.msb)),													loc(addr(loop.real.time.of.next.click.msb)));	call Map.Sequence.Time.To.Real.Time(loc(addr(goback.seq.time.msb)),													loc(addr(goback.play.time.msb)));	if (midi.sync.out <> 0)					/*	if using midi sync out, recompute real time of midi limit	*/	{												/*	unless generating MTC													*/		if (midi.sync.is.tc == 0)			Map.Sequence.Time.To.Real.Time(loc(addr(midi.limit.msb)),loc(addr(real.time.of.midi.limit.msb)));		Compute.Real.Midi.Clock.Rates(loc(addr(midi.limit.msb)));	}	if (ext.clock.mode >= 2) then do;	/*	in ext beat/midi sync	*/		call Map.Sequence.Time.To.Real.Time(loc(addr(clock.limit.msb)),loc(addr(real.time.of.clock.limit.msb)));		call Compute.Real.Clock.Rates(loc(addr(clock.limit.msb)));	end;	/*	current play time takes a quantum leap - seq time remains constant	*/	call Map.Sequence.Time.To.Real.Time(cur.seq.time,loc(addr(x)));	disable;		play.time.msb = x;		play.time.lsb = y;	enable;	overall.loop = loop;						/*	restore loop and click states	*/	actually.emit.click = click;	new.seq.info = new.seq.info \ 8;		/*	new constants	*/end Set.Tempo;/*	Routine to insert a new tempo record at Seq.Time	*/Insert.Tempo.Record: proc (Seq.Time) public swapable;	dcl Seq.Time	array;	dcl (x,y)		fixed;	//	Delta	dcl record(Tempo.Map.Rec.Len - 1)	fixed;	dcl prior(1)	fixed;	dcl next(1)		fixed;	dcl Dest.Len	fixed;	dcl Dest.Sec	fixed;	dcl Dest.Wrd	fixed;	dcl i				fixed;	dcl real			lit 'prior';	dcl cc			lit 'Dest.Len';	dcl diff			lit 'Dest.Sec';	dcl dist			lit 'Dest.Wrd';	if Tempo.Map.Ptr = 0						/*	should always be one		*/	then call Create.Default.Tempo.Map;	/*	but just in case			*/	if Tempo.Map.Ptr = 0						/*	still no map				*/	then return;								/*	error							*/	x = Seq.Time(0);							/*	get sequence time handy	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for zero time		*/	then y = zero.time;						/*	can't insert records before zero time	*/	/*	check for justify mode	*/	if (recd.just <> 0)						/*	get nearest prior beat into x,y	*/	then do;										/*	provide rounding here				*/		call Map.Sequence.Time.To.Nearest.Beats(loc(addr(x)),prior,next);		if (y - prior(1)) < (next(1) - y)			/*	if passed time was		*/		then call COPY32(prior, loc(addr(x)));		/*	closer to prior, use		*/		else call COPY32(next,  loc(addr(x)));		/*	it; else use next			*/	end;	/*	if not in justify mode!!!	*/	/*	map this time to the nearest midi clock boundary (prior)	*/	else do;		call Map.Sequence.Time.To.Nearest.Clicks(loc(addr(x)),prior,next);		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Cur + Meter.Map.cc;		cc = read(md);		diff = next(1) - prior(1);				/*	get division in this click	*/		dist = y - prior(1);						/*	how far into it x,y is		*/		load cc; mul dist;						/*	get how many clocks into	*/		mwait; div diff;							/*	this click we are				*/														/*	i.e. yields 0 - (cc-1)		*/		load res; mul diff;						/*	truncate down to prior		*/		mwait; div cc;								/*	midi clock time				*/		call add16(res, prior);		call copy32(prior, loc(addr(x)));	end;	/*	Find the tempo segment that contains this delta time.		*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	check to see if a tempo record already exists at this time	*/	if  (x = Tempo.Map.This.Seq.Msb)	and (y = Tempo.Map.This.Seq.Lsb)	then return;				/*	can't insert a new tempo record on top of an existing one	*/		call Map.Sequence.Time.To.Real.Time(loc(addr(x)),real);	/*	get real time of new record to be inserted	*/	/*	The tempo pointers are now pointing at the tempo record just prior	*/	/*	to our new tempo.  Make a copy of this record so that we may use		*/	/*	its data to construct the new record below.									*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur + 4;	/*	skip over these time fields,					*/												/*	but pick up time fields from next record	*/	write("300")=addr(record(0));	rpc Tempo.Map.Rec.Len;	write("360")=read(mdi);	Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;	/*	advance pointer to next record	*/	//	………………S…T…A…R…T………O…F………N…E…W………A…L…G…O…R…I…T…H…M………………	//	Two improvevments have been made:	//	//	1)	--- appending versus inserting ---	//	Since appending a record to the very end of the tempo map is much simpler than inserting	//	in the middle, and since this procedure is often called repeatedly for that purpose (as from	//	Create.Tempo.Map.From.Track), this algorithm has separate preprocessing based on this condition.	//	//	2)	--- better utilization of available space ---	//	The previous algorithm always inserted a new NLS when inserting at the end of a NLS, even	//	when space was already available in the sebsequent NLS.  Consequently, repeatedly inserting	//	at the end of a NLS caused a chain of new NLSs each containing only one record in it.	//	This algorithm only inserts a new NLS if the target NLS is full.	//	//	Following is an overview of the new algorithm:	/*	//	--- Step 1: Acquire our actual insertion point ---	if (we are at the end of the NLS) {		write the time of the new rcord at the end of the NLS		if (there is no subsequent NLS) {			//	We'll be appending			Allocate a new NLS			Calculate what the record number will be (from the current NLS)			Point to the new NLS and initialize it			Write the record number			Tempo.Map.Len = Tempo.Map.First	//	Indicate no record stored yet		}		else {			//	We'll be inserting			Skip forward to the next NLS			if (it is full) {				Get the record number from this NLS				Insert a new NLS before this one				Point to the new NLS and initialize it				Write the record number				Tempo.Map.Len = Tempo.Map.First	//	Indicate no record stored yet			}			else set Tempo.Map.Len to represent the NLS we'll be inserting into		}		Tempo.Map.Cur = Tempo.Map.First	// Indicate where to write the new record	}	//	--- Step 2: Move records if necessary ---	if (we must move records for insertion) {		Dest.Len = length of words to copy		if (NLS is full) {			//	FULL: We must move records to another NLS			Allocate another NLS			Initialize the new NLS			Set Dest.Sec and Dest.Wrd to point to the destination in the newly allocated NLS		}		else {			//	NOT FULL: We can shuffle records in this NLS			Set Dest.Sec and Dest.Wrd to point to the destination in this NLS		}		Copy from source		Update source LP		Copy to destination		Update destination LP	}	//	--- Step 3: Write the record, update variables ---	Write the new record at Tempo.Map.Cur	//	Update variables	Tempo.Map.Len = Tempo.Map.Len+Tempo.Map.Rec.Len;	if (we appended to this NLS) {		Tempo.Map.Len = Tempo.Map.Len+Tempo.Map.Rec.Len		write Tempo.Map.Len out to LP in NLS	}	else LP is already correct - update Tempo.Map.Len to match	Normalize.Tempo.Map.Cur();	//	Update variables	If (we are not in the last NLS) Rebuild.Record.Numbers(Tempo.Map#, false);	*/	//	First, we must acquire our actual insertion point, making sure	//	that the NLS containing it has the proper record number.	//	See if we are at the end of the current NLS	If (Tempo.Map.Cur == Tempo.Map.Last) {		/*	Write the starting time of the new record out at the	*/		/*	end of the last sector so the real time software will	*/		/*	know when to switch to the next segment:					*/		write(mal) = Tempo.Map.Last;		write(mdi) = x;		write(mdi) = y;		write(mdi) = real(0);		write(md ) = real(1);		//	See if there is a subsequent NLS		write(mal) = Tempo.Map.For;		If (read(md) == null) {			//	We'll be appending			//	Try to allocate another NLS			i = Allocate.Map.Block(null,Tempo.Map.Ptr-NAH.PTR,Tempo.Map#);			//	If out of room, quit - but first clean up a little.			if (i == null) {				Tempo.Map.Cur = Tempo.Map.Last-Tempo.Map.Rec.Len;				Normalize.Tempo.Map.Cur();	//	Reset variables and return				return;			}			//	Calculate the record number of the first record in the next block			write(mal) = Tempo.Map.Rec#.Msb;		//	Get the first record number from the current NLS			BitMsb = read(mdi);			BitLsb = read(md );			write(mal) = Tempo.Map.FP;				//	Just in case previous software ever allowed (Tempo.Map.FP != Tempo.Map.First)			write(5) = Tempo.Map.Last-read(md);	//	Load total length of records in this NLS			write(7) = Tempo.Map.Rec.Len;			//	Divide by the record length to get the number of records in this NLS			Add16(read(5),BitMsbArray);			//	Add in the result			// Initialize the new NLS			Tempo.Map.Ptr = NAH.PTR+i;				//	Compute new pointer			write(mam) = Tempo.Map.Ptr;			//	Point to the new block now			write(mal) = Tempo.Map.FP;			write(mdi) = Tempo.Map.First;			//	Tempo.Map.FP			write(mdi) = Tempo.Map.First;			//	Tempo.Map.LP			write(mdi) = BitMsb;						//	Tempo.Map.Rec#.Msb			write(md ) = BitLsb;						//	Tempo.Map.Rec#.Lsb			Tempo.Map.Len = Tempo.Map.First;		//	Indicate no record stored yet in this NLS		}		else {			//	We'll be inserting			//	Skip forward to the next NLS			Tempo.Map.Ptr = NAH.PTR + read(md);	//	Compute new pointer			write(mam) = Tempo.Map.Ptr;			//	Point to the next block			write(mal) = Tempo.Map.LP;			//	If it is full, insert a new NLS before this one			if (read(md) == Tempo.Map.Last) {				write(mal) = Tempo.Map.Rec#.Msb;	//	Get the first record number from the current NLS				BitMsb = read(mdi);				BitLsb = read(md );				//	Try to allocate another NLS				write(mal) = Tempo.Map.Rev;				i = Allocate.Map.Block(Tempo.Map.Ptr-NAH.PTR,read(md),Tempo.Map#);				write(mam) = Tempo.Map.Ptr;				write(mal) = Tempo.Map.Rev;				Tempo.Map.Ptr = NAH.PTR+read(md);	//	Compute pointer to new NLS (or back to original if allocation failed)				write(mam) = Tempo.Map.Ptr;			//	Point to this NLS				//	If out of room, quit - but first clean up a little.				if (i == null) {					Tempo.Map.Cur = Tempo.Map.Last-Tempo.Map.Rec.Len;					Normalize.Tempo.Map.Cur();			//	Reset variables & return					return;				}				// Initialize the new NLS				write(mal) = Tempo.Map.FP;				write(mdi) = Tempo.Map.First;		//	Tempo.Map.FP				write(mdi) = Tempo.Map.First;		//	Tempo.Map.LP				write(mdi) = BitMsb;					//	Tempo.Map.Rec#.Msb				write(md ) = BitLsb;					//	Tempo.Map.Rec#.Lsb				Tempo.Map.Len = Tempo.Map.First;	//	Indicate no record stored yet in this NLS			}			else Tempo.Map.Len = read(md);	//	Make this refer to the length of the NLS we'll be inserting into		}		Tempo.Map.Cur = Tempo.Map.First;		// Indicate where to write the new record	}	//	See if we must move records for insertion	if (Tempo.Map.Cur != Tempo.Map.Len) {		Dest.Len = Tempo.Map.Len-Tempo.Map.Cur;	//	length of words to copy		if (Tempo.Map.Len == Tempo.Map.Last) {			//	FULL: We must move records to another NLS			//	Try to allocate another NLS			write(mal) = Tempo.Map.FOR;			i = Allocate.Map.Block(read(md),Tempo.Map.Ptr-NAH.PTR,Tempo.Map#);			//	If out of room, quit - but first clean up a little.			if (i == null) {				Tempo.Map.Cur = Tempo.Map.Cur-Tempo.Map.Rec.Len;				Normalize.Tempo.Map.Cur();				return;			}			// Initialize the new NLS			Dest.Sec = NAH.PTR + i;				//	Compute pointer to new NLS			write(mam) = Dest.Sec;				//	Point there now			write(mal) = Tempo.Map.FP;			write(mdi) = Tempo.Map.First;		//	Tempo.Map.FP			write(mdi) = Tempo.Map.First;		//	Tempo.Map.LP			Dest.Wrd = Tempo.Map.First;			write(mam) = Tempo.Map.Ptr;		//	Point back to the source NLS		}		else {			//	NOT FULL: We can shuffle records in this NLS			Dest.Sec = Tempo.Map.Ptr;			Dest.Wrd = Tempo.Map.Cur+Tempo.Map.Rec.Len;		}		write(mal) = Tempo.Map.Cur;			//	Point to where we will copy the records from		write("300") = addr(misc.buf(0));	//	Copy the records to be moved		rpc Dest.Len + 4;							//	plus the four words of "next segment start time"		write("360") = read(mdi);		write(mal) = Tempo.Map.LP;				//	Update Source LP to indicate new end of records		write(md ) = Tempo.Map.Cur;		write(mam) = Dest.Sec;					//	Point to where we will put the records		write(mal) = Dest.Wrd;		write("300") = addr(misc.buf(0));		rpc Dest.Len + 4;		write(mdi) = read("360");		write(mal) = Tempo.Map.LP;				//	Update Destination LP to indicate new end of records		write(md ) = Dest.Wrd + Dest.Len;		write(mam) = Tempo.Map.Ptr;			//	Make sure we're pointing to the right NLS	}	//	Write the new record at Tempo.Map.Cur	write(mal) = Tempo.Map.Cur;				//	point to where we will insert the new record	write(mdi) = x;								/*	write in start times of this segment	*/	write(mdi) = y;	write(mdi) = real(0);	write(mdi) = real(1);	write("300") = addr(record(0));			/*	fill in data with copy of previous record	*/	rpc Tempo.Map.Rec.Len;						/*	including start times of next segment		*/	write(mdi) = read("360");	//	Update variables	write(mal) = Tempo.Map.LP;	if (read(md) == Tempo.Map.Cur) {						//	if we appended to this NLS		Tempo.Map.Len = read(md)+Tempo.Map.Rec.Len;	//	Increment Tempo.Map.Len		write(md) = Tempo.Map.Len;							//	write out new LP	}	else Tempo.Map.Len = read(md);			//	Otherwise LP is already correct - update Tempo.Map.Len to match	Normalize.Tempo.Map.Cur();					// This leaves mam pointed to Tempo.Map.Ptr	write(mal) = Tempo.Map.For;	if (read(md) != null) Rebuild.Record.Numbers(Tempo.Map#, false);	//	This will be skipped for all appendages		//	Finally, move sequencer to match the time of the record that was inserted	Scroll.Seq(real(0),real(1),0);	//	pass 0 if real time, 1 if sequence timeend Insert.Tempo.Record;/*	Routine to insert a new meter record at Seq.Time	*/Insert.Meter.Record: proc (Seq.Time) public swapable;	dcl Seq.Time	array;	dcl (x,y)		fixed;	//	Delta	dcl record(Meter.Map.Rec.Len - 1)	fixed;	dcl prior(1)	fixed;	//	Important:  Keep "prior", "next" and "Dest.Len" declared in order!	dcl next(1)		fixed;	dcl Dest.Len	fixed;	dcl Dest.Sec	fixed;	dcl Dest.Wrd	fixed;	dcl i				fixed;		dcl measure	lit 'prior';	dcl beat		lit 'next';	if Meter.Map.Ptr = 0						/*	should always be one	*/	then call Create.Default.Meter.Map;	/*	but just in case		*/	if Meter.Map.Ptr = 0						/*	still no map			*/	then return;								/*	error						*/	x = Seq.Time(0);							/*	get sequence time handy	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for zero time	*/	then y = zero.time;						/*	can't insert records before zero time	*/	/*	meter records must fall on a measure boundary				*/	/*	so map this time to the nearest measure time					*/	Map.Sequence.Time.To.Nearest.Measures(loc(addr(x)), Prior, Next);	if (y - prior(1)) < (next(1) - y)			/*	if passed time was		*/	then call COPY32(prior, loc(addr(x)));		/*	closer to prior, use		*/	else call COPY32(next,  loc(addr(x)));		/*	it; else use next			*/	/*	Find the meter segment that contains this delta time.		*/	do while ((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	check to see if a meter record already exists at this time	*/	if  (x = Meter.Map.This.Seq.Msb)	and (y = Meter.Map.This.Seq.Lsb)	then return;						/*	can't insert a new meter record on top of an existing one	*/	/*	get the measure and beat numbers for the new meter record	*/	//	Note: the following call will return data into "Beat" as well.  No harm is done.	Map.Sequence.Time.To.Long.Measures.Beats(loc(addr(x)), Measure);	//	Note: the following call will return data into "Dest.Len" as well.  No harm is done.	Map.Sequence.Time.To.Long.Beats(loc(addr(x)), Beat);	call SUB16(1, beat);				/*	start beat # at 0 for our purposes here	*/	/*	The meter pointers are now pointing at the meter record just prior	*/	/*	to our new meter.  Make a copy of this record so that we may use		*/	/*	its data to construct the new record below.									*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.Rc.d;	write("300")=addr(record(0));	/*	copy ratios and constants for	*/	rpc Meter.Map.Rec.Len;			/*	this segment to copy into our	*/	write("360")=read(mdi);			/*	new tempo segment.				*/											/*	Also copy time of possible		*/											/*	following segment.				*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;	/*	advance pointer to next record	*/	//	………………S…T…A…R…T………O…F………N…E…W………A…L…G…O…R…I…T…H…M………………	//	First, we must acquire our actual insertion point, making sure	//	that the NLS containing it has the proper record number.	//	See if we are at the end of the current NLS	If (Meter.Map.Cur == Meter.Map.Last) {		/*	Write the starting time of the new record out at the	*/		/*	end of the last sector so the real time software will	*/		/*	know when to switch to the next segment:					*/		write(mal) = Meter.Map.Last;		write(mdi) = x;		write(mdi) = y;		write(mdi) = measure(0);		write(mdi) = measure(1);		write(mdi) = beat(0);		write(md ) = beat(1);		//	See if there is a subsequent NLS		write(mal) = Meter.Map.For;		If (read(md) == null) {			//	We'll be appending			//	Try to allocate another NLS			i = Allocate.Map.Block(null,Meter.Map.Ptr-NAH.PTR,Meter.Map#);			//	If out of room, quit - but first clean up a little.			if (i == null) {				Meter.Map.Cur = Meter.Map.Last-Meter.Map.Rec.Len;				Normalize.Meter.Map.Cur();	//	Reset variables and return				return;			}			//	Calculate the record number of the first record in the next block			write(mal) = Meter.Map.Rec#.Msb;		//	Get the first record number from the current NLS			BitMsb = read(mdi);			BitLsb = read(md );			write(mal) = Meter.Map.FP;				//	Just in case previous software ever allowed (Meter.Map.FP != Meter.Map.First)			write(5) = Meter.Map.Last-read(md);	//	Load total length of records in this NLS			write(7) = Meter.Map.Rec.Len;			//	Divide by the record length to get the number of records in this NLS			Add16(read(5),BitMsbArray);			//	Add in the result			// Initialize the new NLS			Meter.Map.Ptr = NAH.PTR+i;				//	Compute new pointer			write(mam) = Meter.Map.Ptr;			//	Point to the new block now			write(mal) = Meter.Map.FP;			write(mdi) = Meter.Map.First;			//	Meter.Map.FP			write(mdi) = Meter.Map.First;			//	Meter.Map.LP			write(mdi) = BitMsb;						//	Meter.Map.Rec#.Msb			write(md ) = BitLsb;						//	Meter.Map.Rec#.Lsb			Meter.Map.Len = Meter.Map.First;		//	Indicate no record stored yet in this NLS		}		else {			//	We'll be inserting			//	Skip forward to the next NLS			Meter.Map.Ptr = NAH.PTR + read(md);	//	Compute new pointer			write(mam) = Meter.Map.Ptr;			//	Point to the next block			write(mal) = Meter.Map.LP;			//	If it is full, insert a new NLS before this one			if (read(md) == Meter.Map.Last) {				write(mal) = Meter.Map.Rec#.Msb;	//	Get the first record number from the current NLS				BitMsb = read(mdi);				BitLsb = read(md );				//	Try to allocate another NLS				write(mal) = Meter.Map.Rev;				i = Allocate.Map.Block(Meter.Map.Ptr-NAH.PTR,read(md),Meter.Map#);				write(mam) = Meter.Map.Ptr;				write(mal) = Meter.Map.Rev;				Meter.Map.Ptr = NAH.PTR+read(md);	//	Compute pointer to new NLS (or back to original if allocation failed)				write(mam) = Meter.Map.Ptr;			//	Point to this NLS				//	If out of room, quit - but first clean up a little.				if (i == null) {					Meter.Map.Cur = Meter.Map.Last-Meter.Map.Rec.Len;					Normalize.Meter.Map.Cur();			//	Reset variables & return					return;				}				// Initialize the new NLS				write(mal) = Meter.Map.FP;				write(mdi) = Meter.Map.First;		//	Meter.Map.FP				write(mdi) = Meter.Map.First;		//	Meter.Map.LP				write(mdi) = BitMsb;					//	Meter.Map.Rec#.Msb				write(md ) = BitLsb;					//	Meter.Map.Rec#.Lsb				Meter.Map.Len = Meter.Map.First;	//	Indicate no record stored yet in this NLS			}			else Meter.Map.Len = read(md);	//	Make this refer to the length of the NLS we'll be inserting into		}		Meter.Map.Cur = Meter.Map.First;		// Indicate where to write the new record	}	//	See if we must move records for insertion	if (Meter.Map.Cur != Meter.Map.Len) {		Dest.Len = Meter.Map.Len-Meter.Map.Cur;	//	length of words to copy		if (Meter.Map.Len == Meter.Map.Last) {			//	FULL: We must move records to another NLS			//	Try to allocate another NLS			write(mal) = Meter.Map.FOR;			i = Allocate.Map.Block(read(md),Meter.Map.Ptr-NAH.PTR,Meter.Map#);			//	If out of room, quit - but first clean up a little.			if (i == null) {				Meter.Map.Cur = Meter.Map.Cur-Meter.Map.Rec.Len;				Normalize.Meter.Map.Cur();				return;			}			// Initialize the new NLS			Dest.Sec = NAH.PTR + i;				//	Compute pointer to new NLS			write(mam) = Dest.Sec;				//	Point there now			write(mal) = Meter.Map.FP;			write(mdi) = Meter.Map.First;		//	Meter.Map.FP			write(mdi) = Meter.Map.First;		//	Meter.Map.LP			Dest.Wrd = Meter.Map.First;			write(mam) = Meter.Map.Ptr;		//	Point back to the source NLS		}		else {			//	NOT FULL: We can shuffle records in this NLS			Dest.Sec = Meter.Map.Ptr;			Dest.Wrd = Meter.Map.Cur+Meter.Map.Rec.Len;		}		write(mal) = Meter.Map.Cur;			//	Point to where we will copy the records from		write("300") = addr(misc.buf(0));	//	Copy the records to be moved		rpc Dest.Len + 6;							//	plus the six words of "next segment start time"		write("360") = read(mdi);		write(mal) = Meter.Map.LP;				//	Update Source LP to indicate new end of records		write(md ) = Meter.Map.Cur;		write(mam) = Dest.Sec;					//	Point to where we will put the records		write(mal) = Dest.Wrd;		write("300") = addr(misc.buf(0));		rpc Dest.Len + 6;		write(mdi) = read("360");		write(mal) = Meter.Map.LP;				//	Update Destination LP to indicate new end of records		write(md ) = Dest.Wrd + Dest.Len;		write(mam) = Meter.Map.Ptr;			//	Make sure we're pointing to the right NLS	}	//	Write the new record at Meter.Map.Cur	write(mal) = Meter.Map.Cur;				//	point to where we will insert the new record	write(mdi) = x;								/*	write in start times of this segment	*/	write(mdi) = y;	write(mdi) = measure(0);	write(mdi) = measure(1);	write(mdi) = beat(0);	write(mdi) = beat(1);	write("300") = addr(record(0));			/*	fill in data with copy of previous record	*/	rpc Meter.Map.Rec.Len;						/*	including start times of next segment		*/	write(mdi) = read("360");	//	Update variables	write(mal) = Meter.Map.LP;	if (read(md) == Meter.Map.Cur) {						//	if we appended to this NLS		Meter.Map.Len = read(md)+Meter.Map.Rec.Len;	//	Increment Meter.Map.Len		write(md) = Meter.Map.Len;							//	write out new LP	}	else Meter.Map.Len = read(md);			//	Otherwise LP is already correct - update Meter.Map.Len to match	Normalize.Meter.Map.Cur();					// This leaves mam pointed to Meter.Map.Ptr	write(mal) = Meter.Map.For;	If (read(md) != null) Rebuild.Record.Numbers(Meter.Map#, false);	//	This will be skipped for all appendages		//	Finally, move sequencer to match the time of the record that was inserted	Scroll.Seq(x,y,1);	//	pass 0 if real time, 1 if sequence timeend Insert.Meter.Record;/*	Routine to delete meter segment at Seq.Time	*/Delete.Meter.Record: proc (Seq.Time) public swapable;	dcl Seq.Time	array;	dcl len			fixed;	dcl (x,y)		fixed;	dcl fp		lit 'x';	dcl rp		lit 'y';	if Meter.Map.Ptr = 0						/*	should always be one	*/	then return;								/*	but just in case		*/	x = Seq.Time(0);							/*	get sequence time handy	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)		/*	check for zero time	*/	then y = zero.time;						/*	can't delete records before zero time	*/	/*	Find the meter segment that contains this delta time.		*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	/*	The meter pointers are now pointing at the meter record to delete.	*/	/*	First check to see if this is the first meter segment.					*/	if  (Meter.Map.This.Seq.Msb = 0)	and (Meter.Map.This.Seq.Lsb ile zero.time)	then return;											/*	can't delete				*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.FP;	if (Meter.Map.Cur = read(md))						/*	if this record is the	*/	then do;													/*	first in this sector		*/		//	NOTE: If we're here, then the value at Meter.Map.Rev cannot be null		write(mal) = Meter.Map.REV;					/*	get reverse ptr			*/		write(mam) = NAH.PTR + read(md);				/*	point to prior sector	*/		write(mal) = Meter.Map.LP;		write(mal) = read(md);		//	The following information will likely be incorrect after the deletion anyway		//	and will need to be rebuilt with Normalize.Meter.Map.TimesBeats		write(mdi) = Meter.Map.Next.Seq.Msb;		/*	update times of next segment	*/		write(mdi) = Meter.Map.Next.Seq.Lsb;		write(mdi) = Meter.Map.Next.Measure.Msb;		write(mdi) = Meter.Map.Next.Measure.Lsb;		write(mdi) = Meter.Map.Next.Beat.Msb;		write(md ) = Meter.Map.Next.Beat.Lsb;		write(mam) = Meter.Map.Ptr;					/*	restore mam and mal		*/		write(mal) = Meter.Map.LP;		/*	now check to see if this is the only meter record in this sector	*/		if ((Meter.Map.Cur + Meter.Map.Rec.Len) == read(md)) {			write(mal) = Meter.Map.FOR;			fp = read(mdi);			rp = read(md );			Deallocate.NAH.Block(Meter.Map.Ptr-NAH.PTR);			//	Update the previous NLS's forward pointer			//	NOTE: (rp != 0) will always be true if we're here			Meter.Map.Ptr = NAH.PTR + rp;			write(mam) = Meter.Map.Ptr;			//	write(mal) = Meter.Map.FOR;	//	This is automatically accomplished by the prior statement			write(md ) = fp;			// Make current the record prior to the one we deleted			write(mal) = Meter.Map.LP;			Meter.Map.Len = read(md);			Meter.Map.Cur = read(md)-Meter.Map.Rec.Len;			Normalize.Meter.Map.Cur();			//	See if we have a subsequent NLS			if (fp != null) {				//	Update the subsequent NLS's reverse pointer				write(mam) = NAH.PTR + fp;				write(mal) = Meter.Map.REV;				write(md ) = rp;				//	If we're here, then we have subsequent meter records who's start times and beat numbers				//	will have to be rebuilt by "Normalize.Meter.Map.TimesBeats" due to our deletion.				Rebuild.Record.Numbers(Meter.Map#, false);				Normalize.Meter.Map.TimesBeats();			}			// Else no need to call "Rebuild.Record.Numbers" or "Normalize.Meter.Map.TimesBeats"			//	because we deleted the last record in the map			return;	//	We are done		}	end;	//	of "this record is the first in this sector"	/*	We are now pointing at the meter record to be deleted so all	*/	/*	we have to do is copy the rest of this sector down.				*/	/*	First compute len of data to be copied including 6 words of		*/	/*	"next segment times" which must be maintained.						*/	len = Meter.Map.Len - Meter.Map.Cur - Meter.Map.Rec.Len + 6;	write(mam) = Meter.Map.Ptr;			/*	point to start of data to be copied	*/	write(mal) = Meter.Map.Cur + Meter.Map.Rec.Len;	write("300")=addr(misc.buf(0));		/*	copy data to misc.buf		*/	rpc len;	write("360")=read(mdi);	write(mal) = Meter.Map.Cur;			/*	point back to destination	*/	write("300") = addr(misc.buf(0));	/*	write the data back in		*/	rpc len;	write(mdi) = read("360");	write(mal) = Meter.Map.LP;				/*	update LP Meter Map info	*/	Meter.Map.Len = read(md) - Meter.Map.Rec.Len;	/*	just lost one record from this block	*/	write(md ) = Meter.Map.Len;	// Make current the record prior to the one we deleted	Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;	Normalize.Meter.Map.Cur();	//	If there are records subsequent to our new current record, then their start times and	//	beat numbers will have to be rebuilt by "Normalize.Meter.Map.TimesBeats" due to our deletion.	write(mal) = Meter.Map.For;	if ((Meter.Map.Cur != (Meter.Map.Len - Meter.Map.Rec.Len)) || (read(md) != null)) {		If (read(md) != null) Rebuild.Record.Numbers(Meter.Map#, false);		Normalize.Meter.Map.TimesBeats();	}end Delete.Meter.Record;/*	Routine to compute sequence time of next meter change	*/Compute.Time.Of.Nearest.Meters: proc (Seq.Time,Prior.Meter,Next.Meter) public swapable;	dcl Seq.Time		array;	dcl Prior.Meter	array;	dcl Next.Meter		array;	dcl (x,y)			fixed;	x = Seq.Time(0);						/*	get sequence time handy		*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)	/*	check for time less than	*/	then y = zero.time;					/*	start of first segment		*/	/*	Find the meter segment that contains this delta time.			*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	Prior.Meter(0) = Meter.Map.This.Seq.Msb;	Prior.Meter(1) = Meter.Map.This.Seq.Lsb;	if  (Prior.Meter(0) = 0)							/*	if we are in the first	*/	and (Prior.Meter(1) ile zero.time)				/*	meter segment, remove	*/	then Prior.Meter(1) = 0;							/*	zero.time from prior		*/	Next.Meter(0) = Meter.Map.Next.Seq.Msb;	Next.Meter(1) = Meter.Map.Next.Seq.Lsb;end Compute.Time.Of.Nearest.Meters;/*	create the first sector block of a meter map with no records in it	*/Initialize.Empty.Meter.Map: proc swapable;	dcl i		fixed;	/*	Get the first block:	*/	i = Allocate.Map.Block(0, 0, Meter.Map#);	if i = 0								/*	out of room for meter map		*/	then return;	Meter.Map.Len = Meter.Map.First;	/*	special case - sector allocated but no records yet	*/	Meter.Map.Cur = Meter.Map.First;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.FP;	write(mdi) = Meter.Map.First;	/*	pointer to first record			*/	write(mdi) = Meter.Map.First;	/*	and last record					*/	write(mdi) = 0;					/*	initialize first record id#	*/	write(md ) = 0;					/*	to 0.									*/end Initialize.Empty.Meter.Map;/*	Returns -1 if out of memory	*//*	Returns +1 if operation OK		*/Append.Sequencer.Meter.Map.Record: proc(record) returns (fixed) PUBLIC swapable;	dcl record		array;	/*	pass the record	*/	dcl temp (1)	fixed;	dcl delta(1)	fixed;	dcl i				fixed;	if PLAY <> 0						/*	stop playing when changing meter	*/	then call STOP.SEQUENCER;		/*	map (mostly for PLAY.INITIALIZE)	*/	/*	Add Zero.Time offset into the passed times:	*/	call COPY32(record, delta);	/*	get delta time					*/	call ADD16(zero.time, delta);	/*	add zero.time					*/	if Meter.Map.Ptr = 0				/*	get first block				*/	then call Initialize.Empty.Meter.Map;	if Meter.Map.Ptr = 0				/*	make sure we got a block	*/	then return (-1);	/*	Find the end of the meter map	*/	write(mam) = Meter.Map.Ptr;	do while read(md) <> 0;		Meter.Map.Ptr = NAH.PTR + read(md);		write(mam) = Meter.Map.Ptr;	end;	/*	See if there is room for this new segment in the last			*/	/*	sector:																		*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.FP;				/*	get pointer to first		*/	Meter.Map.Cur = read(mdi);				/*	get in handy temp			*/	Meter.Map.Len = read(mdi);				/*	pointer to end of list	*/	temp(0) = read(mdi);						/*	get Meter.Map.Rec#.Msb	*/	temp(1) = read(mdi);						/*	and Lsb handy as well	*/	if Meter.Map.Len >= Meter.Map.Last	/*	if no more room, then	*/	then do;										/*	get another block			*/		/*	Try to allocate another NLS block to hold more meter		*/		/*	map data:																*/		i = Allocate.Map.Block(0, Meter.Map.Ptr - NAH.PTR, Meter.Map#);		/*	If out of room, quit - but first clean up a little.		*/		if i = 0 then do;						/*	out of room					*/			Meter.Map.Cur = Meter.Map.Len - Meter.Map.Rec.Len;			call Normalize.Meter.Map.Cur;	/*	reset variables & return	*/			return (-1);		end;		/*	Write the starting time of the new record out at the		*/		/*	end of the last sector so the real time software will		*/		/*	know when to switch to the next segment:						*/		write(mam) = Meter.Map.Ptr;		write(mal) = Meter.Map.Len;		write(mdi) = delta(0);									/*	store delta time		*/		write(mdi) = delta(1);		write(mdi) = record(Meter.Map.Measure#.Msb+0);	/*	store measure number	*/		write(mdi) = record(Meter.Map.Measure#.Msb+1);		write(mdi) = record(Meter.Map.Beat#.Msb   +0);	/*	and beat number		*/		write(mdi) = record(Meter.Map.Beat#.Msb   +1);		/*	compute record # of the first meter map record that		*/		/*	will be stored in the new block:									*/		call ADD16((Meter.Map.Len - Meter.Map.Cur) / Meter.Map.Rec.Len, temp);		Meter.Map.Ptr = NAH.PTR + i;		/*	compute pointer to new block	*/		write(mam) = Meter.Map.Ptr;		/*	point to the new block now		*/		write(mal) = Meter.Map.FP;			/*	initialize the newly		*/		write(mdi) = Meter.Map.First;		/*	allocated block.			*/		write(mdi) = Meter.Map.First;		write(mdi) = temp(0);		write(mdi) = temp(1);		Meter.Map.Len = Meter.Map.First;	end;	/*	Store the data record in external memory	*/	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Len;	write(mdi) = delta(0);			/*	store delta time				*/	write(mdi) = delta(1);	do i = 2 to Meter.Map.Rec.Len - 1;	/*	store rest of record	*/		write(mdi) = record(i);	end;	write(mdi) = (-1);				/*	terminate map with			*/	write(mdi) = (-1);				/*	infinity							*/	write(mdi) = (-1);	write(mdi) = (-1);	write(mdi) = (-1);	write(mdi) = (-1);	Meter.Map.Len = Meter.Map.Len + Meter.Map.Rec.Len;	write(mam) = Meter.Map.Ptr;	/*	store new length of			*/	write(mal) = Meter.Map.LP;		/*	sector out in ext memory.	*/	write(md ) = Meter.Map.Len;	Meter.Map.Cur = Meter.Map.Len - Meter.Map.Rec.Len;	/*	Set up info for current pointer:	*/	call Normalize.Meter.Map.Cur;	return 1;end Append.Sequencer.Meter.Map.Record;/*	handy routine to create tempo/meter change events	*//*	pass in current sequencer time							*/Check.For.Tempo.Meter.Events: proc (Seq.Time) public swapable;	dcl Seq.Time	array;	dcl tempinfo	fixed static;	dcl metrinfo	fixed static;	dcl x				fixed static;	dcl y				fixed static;	dcl i				fixed static;	dcl a0	lit '"300"';	dcl add0	lit '"210"';	if (Tempo.Map.Ptr = 0)		/*	if no tempo & meter map, then			*/	or (Meter.Map.Ptr = 0)		/*	no events to create						*/	then return;	x = Seq.Time(0);				/*	get sequence time handy in statics	*/	y = Seq.Time(1);	if (x = 0) & (y ILT zero.time)	/*	check for time less than		*/	then y = zero.time;					/*	start of first segment			*/	/*	Find the tempo segment that contains this delta time. Then		*/	/*	compute a checksum for fast compare:									*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	/*	perform checksum on tempo info to check for change						*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur + Tempo.Map.Rms.d;	write( a0) = 0;	rpc (Tempo.Map.Rd.ms - Tempo.Map.Rms.d);	write(add0) = read(mdi);	i = read(a0);	if i <> tempinfo then do;		tempinfo = i;		new.seq.info = new.seq.info \ 16;	end;	/*	find the meter segment for this time as well.  Then compute a		*/	/*	fast checksum for compare:														*/	do while	((x ILT Meter.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Meter.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Meter.Map.This.Seq.Lsb));	/*	this segment.			*/		Meter.Map.Cur = Meter.Map.Cur - Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	do while	((x IGT Meter.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Meter.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Meter.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Meter.Map.Cur = Meter.Map.Cur + Meter.Map.Rec.Len;		call Normalize.Meter.Map.Cur;	end;	write(mam) = Meter.Map.Ptr;	write(mal) = Meter.Map.Cur + Meter.Map.nn;	write( a0) = 0;	rpc (Meter.Map.Rec.Len - Meter.Map.nn);	write(add0) = read(mdi);	i = read(a0);	if i <> metrinfo then do;		metrinfo = i;		new.seq.info = new.seq.info \ 16;	end;end Check.For.Tempo.Meter.Events;INSERT ':SYNRSOU:03-PRIM:042METRB';