/* :SYNRSOU:03-PRIM:194-SAMP - SUBROUTINES USED BY MONO & POLY SAMPLING *//*   6/02/86 - CJ - changed to pass periods in khz*10   5/15/86 - "official" creation of release-M modules*//* 32-bit Time Calculation *//* SOUND FILES REQUIRE THE FOLLOWING COMPUTATION TO COMPUTE A STARTING    AND ENDING FILE POSITION FROM A STARTING AND ENDING TIME */dcl (sector.msb,sector.numb,sector.offset) fixed public; /* returned by the following routine */TIME_TO_INDEX:  proc(seconds,milliseconds,microseconds,khz,stereo) public swapable;   dcl seconds      fixed;   dcl milliseconds fixed;   dcl microseconds fixed;   dcl khz          fixed;    /* khz * 10                        */   dcl stereo       fixed;    /* if sound file is stereo or mono */   dcl (x,y)        fixed;   load seconds; uload milliseconds; mul 1000;  /* compute 32 bit # of milliseconds */   bitmsb=ures; bitlsb=res;   call ratio_multiply(khz,10);		/* compute sample # */   x=bitmsb; y=bitlsb;					/* save             */     bitmsb=0; bitlsb=microseconds;   call ratio_multiply(khz,10000);	/* compute sample # */   x=x+bitmsb;   y=y+bitlsb;   if y ilt bitlsb then x=x+1;   if stereo<>0 then do;      x=shl(x,1)\shr(y,15);      y=shl(y,1);   end;   sector.msb   =shr(x,8);   sector.numb  =shl(x,8)\shr(y,8);   sector.offset=y&255;end TIME_TO_INDEX;/* original version - based on d66 sample periods */PERIOD_TIME_TO_INDEX:  proc(seconds,milliseconds,microseconds,periods) PUBLIC SWAPABLE;   dcl periods      fixed;    dcl seconds      fixed;   dcl milliseconds fixed;   dcl microseconds fixed;   dcl (a,b,c,d,e,f,i,x,y,z) fixed;   /* compute de.f milliseconds */   write(5)=seconds; write(6)=1000;   d=read(4);   e=read(5);   e=e+milliseconds;   if e ILT milliseconds then d=d+1;   write(5)=0; write(4)=microseconds; write(7)=1000; /* fractional divide */   f=read(5);   /* compute a.bc samples/millisecond */   write(5)=30000; write(7)=periods; /* compute microseconds/sample */   a=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=periods;   b=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=periods; /* to 48 bit accuracy */   c=read(5);   /* multiply de.f milliseconds times a.bc (samples/ms) to get xy.z sample # */   x=0; y=0; z=0;   write(5)=c; write(6)=e;   z=read(4);   write(5)=c; write(6)=d;   z=z+read(5); if z ILT read(5) then y=y+1;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=b; write(6)=f;   z=z+read(4); if z ILT read(4) then do; y=y+1; if y=0 then x=x+1; end;   write(5)=b; write(6)=e;   z=z+read(5); if z ILT read(5) then do; y=y+1; if y=0 then x=x+1; end;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=b; write(6)=d;   y=y+read(5); if y ILT read(5) then x=x+1;   x=x+read(4);   write(5)=a; write(6)=f;   z=z+read(5); if z ILT read(5) then do; y=y+1; if y=0 then x=x+1; end;   y=y+read(4); if y ILT read(4) then x=x+1;   write(5)=a; write(6)=e;   y=y+read(5); if y ILT read(5) then x=x+1;   x=x+read(4);   write(5)=a; write(6)=d;   x=x+read(5);   /* round up to nearest sample number */   if z<0 then do;     y=y+1; if y=0 then x=x+1;   end;   /* compute answer: */   sector.msb   =shr(x,8);   sector.numb  =shl(x,8)\shr(y,8);   sector.offset=y&255;end PERIOD_TIME_TO_INDEX;/* $PAGE - INDEX TO TIME *//* The following procedure computes a sample time from a sound file position */ dcl (time.seconds, time.milliseconds, time.microseconds)  fixed public;  /* returned by the following routine */INDEX_TO_TIME: proc(sector.msb,sector.number,sector.offset,khz,stereo) public swapable;  /* convert address to time */   /* convert sectors to time:  works for sector numbers up to 24 bits,      and times up to 32 bits of milliseconds. */   dcl sector.msb      fixed;   dcl sector.number   fixed;   /* sector number */   dcl sector.offset   fixed;   /* word offset */   dcl khz             fixed;   /* khz * 10    */   dcl stereo          fixed;   /* if sound file in stereo or mono */   dcl (x,y) fixed;   /* compute xy. sample # */   x=shl(sector.msb,8)\shr(sector.number,8); /* upper 16 bits of sample # */   y=shl(sector.number,8)\sector.offset;     /* lower 32 bits of sample # */   if stereo<>0 then do;                     /* if stereo sound file */      y=shr(y,1)\shl(x,15);                  /* sector number is half # of samples */      x=shr(x,1);   end;   bitmsb=x; bitlsb=y;   call ratio_multiply(10,khz);		/* compute milliseconds */   call unround;   load bitlsb; uload bitmsb; div 1000;   time.seconds=res; time.milliseconds=rem;   load 1000; mul mul.llsb; time.microseconds=ures;   if res<0 then time.microseconds=time.microseconds+1;      /* round */   if time.microseconds=1000 then do;      time.microseconds=time.microseconds-1000;      time.milliseconds=time.milliseconds+1;      if time.milliseconds=1000 then do;         time.milliseconds=time.milliseconds-1000;         time.seconds     =time.seconds+1;      end;   end;end INDEX_TO_TIME;INDEX_TO_PERIOD_TIME: proc(sector.msb,sector.number,sector.offset,periods) PUBLIC SWAPABLE;  /* convert address to time */   /* convert sectors to time:  works for sector numbers up to 24 bits,      sampling periods up to 29,999, and times up to 32 bits of milliseconds. */   dcl sector.msb      fixed;   dcl sector.number   fixed;   /* sector number */   dcl sector.offset   fixed;   /* word offset */   dcl periods         fixed;    dcl (a,b,c,d,e,f,i,x,y) fixed;   /* compute xy. sample # */   x=shl(sector.msb,8)\shr(sector.number,8); /* upper 16 bits of sample # */   y=shl(sector.number,8)\sector.offset;     /* lower 32 bits of sample # */   /* compute .abc milliseconds/sample */   write(5)=0; write(4)=periods; write(7)=30000; /* compute microseconds/sample */   a=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=30000;   b=read(5);   i=read(4); write(5)=0; write(4)=i; write(7)=30000; /* to 48 bit accuracy */   c=read(5);   /* multiply xy. (sample #) times .abc (ms./sample) to get de.f milliseconds */   d=0;e=0;f=0;   write(5)=c; write(6)=x;   f=read(4);   write(5)=b; write(6)=y;   f=f+read(4); if f ILT read(4) then e=e+1;   write(5)=b; write(6)=x;   f=f+read(5); if f ILT read(5) then e=e+1;   e=e+read(4); if e ILT read(4) then d=d+1;   write(5)=a; write(6)=y;   f=f+read(5); if f ILT read(5) then do; e=e+1; if e=0 then d=d+1; end;   e=e+read(4); if e ILT read(4) then d=d+1;   write(5)=a; write(6)=x;   e=e+read(5); if e ILT read(5) then d=d+1;   d=d+read(4);   /* round up to nearest microsecond */   f=f+32; /* add 1/2000 of a millisecond */   if f ILT 32 then do; e=e+1; if e=0 then d=d+1; end;   /* compute answer: */   write(5)=e; write(4)=d;       /* milliseconds */   write(7)=1000;                /* to get seconds */   time.seconds=read(5); time.milliseconds=read(4);   write(5)=f; write(6)=1000;    /* and microseconds */   time.microseconds=read(4);    /* fractional multiply result */end INDEX_TO_PERIOD_TIME;