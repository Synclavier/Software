/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: 043-MAPSPATH:		 :SYNRSOU:03-PRIM:043-MAPSCONTAINS: SOURCE CODE FOR TEMPO/METER MAP ROUTINES USED BY THE CONDUCTOR TOOLS SCREENREVISION HISTORY:00	1999/10/28	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*This file contains some non-real time tempo map routines used by the Conductor Tools screen.They need to be here rather than in the CONDMOD module in order to have access to the manytempo/meter map related literals, variables and procedures which are private to this module.This file also contains all routines pertaining to the curve fit map data structureused by the Conductor Tools screen.Note:	Unlike with tempo maps, a running sequence has no effect on the curve fit map variables.		The tempo map routines here do not guard against the interrupt code changing the variables.		They are intended to be called from procedures which have disabled interrupts and/or		stopped the sequence.To do:	Once sequences containing CFit maps are being saved, refer to CFit.Map.FP rather than 	CFit.Map.First in most cases, so that if CFit.Map.First changes, old CFit maps can	still be operated on.*//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*///	Storage of curve fit data structure in the NED sequence://	Literals for sector of curve fit map information:dcl CFit.Map.For			lit 'NLS.FOR';	//	0: forward pointer to next blkdcl CFit.Map.Rev			lit 'NLS.REV';	//	1: reverse pointer to past blkdcl CFit.Map.Trk			lit 'NLS.TRK';	//	2: trk# (for garbage collect routines)dcl CFit.Map.FP			lit 'NLS.FP ';	//	3: pointer to first recorddcl CFit.Map.LP			lit 'NLS.LP ';	//	4: pointer to end of recordsdcl CFit.Map.Record#		lit '      5';	//	5: holds record number (limited to 64K)dcl CFit.Map.First		lit '		  6';	//	start of first segment in NLS blockdcl CFit.Map.Last			lit '		249';	//	up through word 248//	NOTE: the four words starting at Tempo.Map.Len MUST contain the values of//	CFit.Map.Cue.Msb through CFit.Map.Target.Lsb for the next segment.//	These words must contain -1,-1,-1,-1 if there is no further segment.//	The curve fit map itself consists of up to 27 9-word records per NLS.dcl CFit.Map.Cue.Msb				lit '0';	//	Real time of cue in whole video fields relative to 00:00:00:00.00dcl CFit.Map.Target.Msb			lit '2';	//	Sequence time of target beatdcl CFit.Map.Start.Tempo.Msb	lit '4';	//	Instantaneous tempo in microseconds at the beginning of this segmentdcl CFit.Map.End.Tempo.Msb		lit '6';	//	Instantaneous tempo in microseconds at the end of this segmentdcl CFit.Map.Weight				lit '8';	//	Used for assigning a weight to each cue (for least squares linear fit) dcl CFit.Map.Rec.Len			lit	' 9';dcl CFit.Map.#Records		lit	'27';/*ииииииииииииииии  E X T E R N A L   R E F E R E N C E S  ииииииииииииииии*//*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*/dcl CFit.Map.Len	fixed;	//	pointer to end of records in current sector (not really a length at all)dcl CFit.Map.Cur	fixed;	//	pointer to current worddcl CFit.Map.This.Cue.Msb		fixed;	//	holds convenient copy of the real time of THIS cue to speed up map searchdcl CFit.Map.This.Cue.Lsb		fixed;dcl CFit.Map.This.Target.Msb	fixed;	//	holds convenient copy of the sequence time of THIS target to speed up map searchdcl CFit.Map.This.Target.Lsb	fixed;dcl CFit.Map.Next.Cue.Msb		fixed;	//	holds convenient copy of the real time of the NEXT cue to speed up map searchdcl CFit.Map.Next.Cue.Lsb		fixed;dcl CFit.Map.Next.Target.Msb	fixed;	//	holds convenient copy of the sequence time of the NEXT target to speed up map searchdcl CFit.Map.Next.Target.Lsb	fixed;/*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE Normalize.CFit.Map.Cur											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/Normalize.CFit.Map.Cur: proc;	//	back up to prior blocks if necessary	while (CFit.Map.Cur < CFit.Map.First) {		write(mam) = CFit.Map.Ptr;		write(mal) = CFit.Map.Rev;		CFit.Map.Ptr = nah.ptr+read(md);		write(mam) = CFit.Map.Ptr;		write(mal) = CFit.Map.LP;		CFit.Map.Len = read(md);		CFit.Map.Cur = read(md)-CFit.Map.Rec.Len;	}	//	Now skip to the next block if we are at the end of this one	while (CFit.Map.Cur >= CFit.Map.Len) {		write(mam) = CFit.Map.Ptr;		write(mal) = CFit.Map.For;		CFit.Map.Ptr = nah.ptr+read(md);		write(mam) = CFit.Map.Ptr;		write(mal) = CFit.Map.FP;		CFit.Map.Cur = read(mdi);		CFit.Map.Len = read(md );	}	//	Now look up starting and ending values to have handy	write(mam) = CFit.Map.Ptr;	write(mal) = CFit.Map.Cur;	CFit.Map.This.Cue.Msb	 = read(mdi);	CFit.Map.This.Cue.Lsb	 = read(mdi);	CFit.Map.This.Target.Msb = read(mdi);	CFit.Map.This.Target.Lsb = read(md );	write(mal) = CFit.Map.Cur+CFit.Map.Rec.Len;	CFit.Map.Next.Cue.Msb	 = read(mdi);	CFit.Map.Next.Cue.Lsb	 = read(mdi);	CFit.Map.Next.Target.Msb = read(mdi);	CFit.Map.Next.Target.Lsb = read(md );end Normalize.CFit.Map.Cur;/*иииииииииииииииииии  P U B L I C   V A R I A B L E S  иииииииииииииииииии*//*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE locate_tempo_map													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/locate_tempo_map: proc (time32) public swapable;	dcl time32 fixed array;	// pass real time//	stop.recd.move.play();	//	don't let a playing sequence screw with the tempo map variables	//	Make current the tempo segment that contains time32	while	//	back up to the previous record if time32 is before the start of the current one	( (time32(0) ilt Tempo.Map.This.Real.Msb) ||	 ((time32(0) ==  Tempo.Map.This.Real.Msb) &&	  (time32(1) ilt Tempo.Map.This.Real.Lsb)) )	{		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		Normalize.Tempo.Map.Cur();	}	while	//	advance to the next record if time32 is after the end of the current one	( (time32(0) igt Tempo.Map.Next.Real.Msb) ||	 ((time32(0) ==  Tempo.Map.Next.Real.Msb) &&	  (time32(1) ige Tempo.Map.Next.Real.Lsb) &&	  ((Tempo.Map.Next.Real.Msb & Tempo.Map.Next.Real.Lsb) != -1)) )	//	guard against infinite loop	{		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		Normalize.Tempo.Map.Cur();	}end locate_tempo_map;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE locate_cfit_map													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/locate_cfit_map: proc (time32) public swapable;	dcl time32 fixed array;	// pass real time	//	Make current the segment that contains input_time	while	//	back up to the previous record if time32 is before the start of the current one	( (time32(0) ilt CFit.Map.This.Cue.Msb) ||	 ((time32(0) ==  CFit.Map.This.Cue.Msb) &&	  (time32(1) ilt CFit.Map.This.Cue.Lsb)) )	{		CFit.Map.Cur = CFit.Map.Cur - CFit.Map.Rec.Len;		Normalize.CFit.Map.Cur();	}	while	//	advance to the next record if time32 is after the end of the current one	( (time32(0) igt CFit.Map.Next.Cue.Msb) ||	 ((time32(0) ==  CFit.Map.Next.Cue.Msb) &&	  (time32(1) ige CFit.Map.Next.Cue.Lsb) &&	  ((CFit.Map.Next.Cue.Msb & CFit.Map.Next.Cue.Lsb) != -1)) )	//	guard against infinite loop	{		CFit.Map.Cur = CFit.Map.Cur + CFit.Map.Rec.Len;		Normalize.CFit.Map.Cur();	}end locate_cfit_map;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE get_next_tempo_pair												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/get_next_tempo_pair: proc (real32,seq32) public swapable;	dcl (real32,seq32) fixed array;	real32(0)	= Tempo.Map.Next.Real.Msb;	real32(1)	= Tempo.Map.Next.Real.Lsb;	seq32(0)		= Tempo.Map.Next.Seq.Msb;	seq32(1)		= Tempo.Map.Next.Seq.Lsb;	//	advance to the next record unless we're already at the final one	if ((Tempo.Map.Next.Real.Msb & Tempo.Map.Next.Real.Lsb) != -1)	{		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		Normalize.Tempo.Map.Cur();	}end get_next_tempo_pair;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE get_next_cfit_pair												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Note: if the same array is passed for "cue32" and "target32", the latter will be returned.//	This is not a trivial point, but is utilized.get_next_cfit_pair: proc (cue32,target32) public swapable;	dcl (cue32,target32) fixed array;	cue32(0)		= CFit.Map.Next.Cue.Msb;	cue32(1)		= CFit.Map.Next.Cue.Lsb;	target32(0)	= CFit.Map.Next.Target.Msb;	target32(1)	= CFit.Map.Next.Target.Lsb;	//	advance to the next record unless we're already at the final one	if ((CFit.Map.Next.Cue.Msb & CFit.Map.Next.Cue.Lsb) != -1)	{		CFit.Map.Cur = CFit.Map.Cur+CFit.Map.Rec.Len;		Normalize.CFit.Map.Cur();	}end get_next_cfit_pair;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE get_final_tempo_event_info									*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Note: if the same array is passed for "time" and "num_records", the latter will be returned.//	This is not a trivial point, but is utilized.get_final_tempo_event_info: proc (time,num_records) public swapable;	dcl time				fixed array;	//	return the real time of the final event here	dcl num_records	fixed array;	//	return the 32-bit number of records here	dcl final_record	fixed;	//	Make sure we're pointing to the current tempo map NLS block	write(mam) = Tempo.Map.Ptr;	//	Link through any subsequent NLS blocks	write(mal) = Tempo.Map.For;			//	Point to the current NLS's forward pointer for the loop condition.	while (read(md) != null) {				//	While it's not null...		write(mam) = NAH.PTR + read(md);	//	Point to the next NLS		write(mal) = Tempo.Map.For;		//	Point to it's forward pointer for the loop condition.	}	write(mal) = Tempo.Map.FP;	write("313")	= read(mdi);							//	Tempo.Map.FP (first record)	final_record	= read(mdi) - Tempo.Map.Rec.Len;	//	Tempo.Map.LP (end of data)	num_records(0)	= read(mdi);							//	Tempo.Map.Rec#.Msb (record number of the first record in this block)	num_records(1)	= read(md );							//	Tempo.Map.Rec#.Lsb	//	Output the real time of the final record	write(mal) = final_record + Tempo.Map.Real.Msb;	time(0) = read(mdi);	time(1) = read(md );		//	Calculate and output the number of records in this final block	load final_record - read("313");	//	Load total length of records in this NLS	div Tempo.Map.Rec.Len;				//	Divide by the record length to get the number of records in this NLS	add16(res,num_records);				//	Add the result to the record number of the first record in this final blockend get_final_tempo_event_info;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE get_final_cfit_cue_info										*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/get_final_cfit_cue_info: proc (time) returns (fixed) public swapable;	dcl time				fixed array;	//	return the real time of the final cue here	dcl final_record	fixed;	//	Make sure we're pointing to the current curve fit map NLS block	write(mam) = CFit.Map.Ptr;	//	Link through any subsequent NLS blocks	write(mal) = CFit.Map.For;		//	Point to the current NLS's forward pointer for the loop condition.	while (read(md) != null) {				//	While it's not null...		write(mam) = NAH.PTR + read(md);	//	Point to the next NLS		write(mal) = CFit.Map.For;	//	Point to it's forward pointer for the loop condition.	}	write(mal)	 = CFit.Map.LP;	final_record = read(mdi) - CFit.Map.Rec.Len;	//	CFit.Map.LP (end of data)	write("313") = read(md );							//	CFit.Map.Record# (record number of the first record in this block)	//	Output the real time of the final record	write(mal) = final_record + CFit.Map.Cue.Msb;	time(0) = read(mdi);	time(1) = read(md );	//	Calculate and return the number of records in this final block	load final_record - CFit.Map.First;	//	Load total length of records in this NLS	div CFit.Map.Rec.Len;					//	Divide by the record length to get the number of records in this NLS	return read("313") + res;				//	Add the result to the record number of the first record in this final blockend get_final_cfit_cue_info;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfit_target_to_record#											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Returns the record number of the segment containing this target beat (i.e., 32-bit millisecond sequence time)cfit_target_to_record#: proc (beat32) returns (fixed) public swapable;	dcl beat32	fixed array;	//	Make current the segment that contains beat32	while	//	back up to the previous record if input_time is before the start of the current one	( (beat32(0) ilt CFit.Map.This.Target.Msb) ||	 ((beat32(0) ==  CFit.Map.This.Target.Msb) &&	  (beat32(1) ilt CFit.Map.This.Target.Lsb)) )	{		CFit.Map.Cur = CFit.Map.Cur-CFit.Map.Rec.Len;		Normalize.CFit.Map.Cur();	}	while	//	advance to the next record if input_time is after the end of the current one	( (beat32(0) igt CFit.Map.Next.Target.Msb) ||	 ((beat32(0) ==  CFit.Map.Next.Target.Msb) &&	  (beat32(1) ige CFit.Map.Next.Target.Lsb) &&	  ((CFit.Map.Next.Target.Msb & CFit.Map.Next.Target.Lsb) != -1)) )	//	guard against infinite loop	{		CFit.Map.Cur = CFit.Map.Cur+CFit.Map.Rec.Len;		Normalize.CFit.Map.Cur();	}	//	Calculate and return the record number of this segment	write(mam) = CFit.Map.Ptr;	write(mal) = CFit.Map.Record#;	load CFit.Map.Cur - CFit.Map.First;	//	Load total length of records prior to the current one in this NLS	div CFit.Map.Rec.Len;					//	Divide by the record length to get the number of records prior to the current one	return read(md) + res;					//	Add the result to the record number of the first record in this blockend cfit_target_to_record#;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE reset_cfit_map													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/reset_cfit_map: proc public swapable;	//	point all cfit variables to the first record (which is null)	//	We have two methods for pointing CFit.Map.Ptr to the head node: We can step backwards through the nodes	//	until the reverse pointer is null, or we can look up the head node from the sequence BASE sector.	#if (false)		//	Make sure we're pointing to the current NLS		write(mam) = CFit.Map.Ptr;			//	We must first back up to the first NLS		write(mal) = CFit.Map.Rev;				//	Point to the current NLS's reverse pointer for the loop condition.			while (read(md) != null) {				//	While it's not null,			CFit.Map.Ptr = nah.ptr+read(md);	//	make "CFit.Map.Ptr" point to the previous NLS.			write(mam) = CFit.Map.Ptr;			write(mal) = Tempo.Map.REV;		//	Then point to it's reverse pointer for the loop condition.		}	#else		write(mam)	 = BAS.PTR;	//	look up the pointer to the curve fit map in the sequence base area		write(mal)	 = Seq.Map.Ptrs + CFit.Map#;		CFit.Map.Ptr = nah.ptr + read(md);		write(mam)	 = CFit.Map.Ptr;	#endif	write(mal)	 = CFit.Map.FP;	CFit.Map.Cur = read(mdi);	//	should be CFit.Map.First	CFit.Map.Len = read(md );	//	Now look up starting and ending values to have handy	write(mal) = CFit.Map.First;	CFit.Map.This.Cue.Msb	 = read(mdi);	CFit.Map.This.Cue.Lsb	 = read(mdi);	CFit.Map.This.Target.Msb = read(mdi);	CFit.Map.This.Target.Lsb = read(md );	write(mal) = CFit.Map.First+CFit.Map.Rec.Len;	CFit.Map.Next.Cue.Msb	 = read(mdi);	CFit.Map.Next.Cue.Lsb	 = read(mdi);	CFit.Map.Next.Target.Msb = read(mdi);	CFit.Map.Next.Target.Lsb = read(md );end reset_cfit_map;	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE erase_cfit_map													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/erase_cfit_map: proc public swapable;	dcl temp_ptr fixed;	//	write(mam) = BAS.PTR;	//	look up the pointer to the map in the sequence base area	write(mal) = Seq.Map.Ptrs + CFit.Map#;	temp_ptr   = read(md);	//	remember it for below	write(md)  = null;		//	nuke it from the sequence base area	CFit.Map.Ptr = null;		//	null the absolute pointer	//	Now recycle all the NLS blocks	while (temp_ptr != null) {		write(mam) = NAH.PTR + temp_ptr;	// point to the block to be recycled		write("313") = read(md);			//	remember its forward pointer for the next iteration		call Deallocate.NAH.Block(temp_ptr);			temp_ptr = read("313");	}end erase_cfit_map;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE Create.CFit.Map.From.Track									*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/Create.CFit.Map.From.Track: proc (track) public swapable;	dcl track fixed;	dcl (prior32,next32)				(1)	fixed;	//	possible targets: subdivisions of a beat bookending the cue	dcl (prior_dur32,next_dur32)	(1)	fixed;	//	used only to determine which target to choose	dcl prior_note32					(1)	fixed;	//	sequence time of cue note (used only to prevent writing multiple cues when chords are encountered)	dcl smpte32							(1)	fixed;	dcl cue_time32						(1)	fixed;	//	real time of cue note	dcl target_time32					(1)	fixed;	//	sequence time of chosen target//	dcl starting_tempo				(1)	fixed;	//	*** UNIMPLEMENTED FOR NOW ***//	dcl ending_tempo					(1)	fixed;	//	*** UNIMPLEMENTED FOR NOW ***	dcl (note_exists,real_note_found)	boolean;	//	From :SYNMODS:SMGRDCL	dcl S$Speed			fixed			external;	dcl S$SMode			fixed			external;	dcl S$SOffset		fixed array	external;	dcl zero.zerotime	data			external;	stop.recd.move.play.xpos.cont.eras();	//	stop any performance	play.initialize();							//	init to the top of the sequence	//	if we have a valid cue track and it contains a note	if ((load.seq.globals(track) != false) && (#wrd != 0)) {		// First make sure we have actual notes after zero.time to create a map from		note_exists = true;		//	ignore any notes at or before zero time		while ((note_exists != false) && (com32(loc(addr(#NMSB)),zero.zerotime) != lw#igt)) note_exists = advance.to.next.note;		//	now skip ahead to the first real note		real_note_found = false;		while ((note_exists != false) && (real_note_found == false)) {			look.up.note.info();				//	get #w1 - #w4 current for the following line			if (((isa.rest.note)|(isa.rte.note)|(isa.ilp.note)) == false) real_note_found = true;			else note_exists = advance.to.next.note;		}		if (note_exists == false) return;	//	no notes to generate a map from		else {			//	we're now certain we have notes to create a map from			if (Allocate.Map.Block(0,0,cfit.map#) == null) {				ertyp = err.oom;	//	report no memory for map				return;			}			//	initialize the word pointers to the second record, since the first record will serve as a lower boundary			CFit.Map.Cur = CFit.Map.First+CFit.Map.Rec.Len;			CFit.Map.Len = CFit.Map.Cur;			//	initialize the info at the head of the NLS			write(mam) = CFit.Map.Ptr;			write(mal) = CFit.Map.FP;			write(mdi) = CFit.Map.First;	//	CFit.Map.FP			write(mdi) = CFit.Map.Len;		//	CFit.Map.LP			write(mdi) = 0;					//	CFit.Map.Record#			//	Initialize the first record to zero to provide a lower boundary for segment searches			write(mal) = CFit.Map.First;			write(mdi) = 0;					//	CFit.Map.Cue.Msb			write(mdi) = 0;					//	CFit.Map.Cue.Lsb			write(mdi) = 0;					//	CFit.Map.Target.Msb			write(md ) = 0;					//	CFit.Map.Target.Lsb		}		smpte.to.sbits(S$SOffset,S$Smode,smpte32);		copy32(zero.zerotime,prior_note32);	//	initialize for first comparison		while (note_exists != false) {			look.up.note.info();					//	get #w1 - #w4 current for the following line			if (((isa.rest.note)|(isa.rte.note)|(isa.ilp.note)) == false) {				//	if this note isn't at the same time as the previous note, go for it				if (com32(loc(addr(#NMSB)),prior_note32) != lw#ieq) {					copy32(loc(addr(#NMSB)),prior_note32);	//	save for next comparison					//	determine the cue (real time in whole video fields relative to 00:00:00:00.00)					Map.Sequence.Time.To.Real.Time(prior_note32,cue_time32);			//	need real time					msec.to.sbits(cue_time32,cf#time,S$Speed,S$Smode,cue_time32);	//	convert to SMPTE bits					// add in smpte offset					add32(cue_time32,smpte32,cue_time32);					//	convert to whole fields					//	divide upper word					load cue_time32(0); div 40;					cue_time32(0) = res;					write("313") = rem;				//	save remainder to use as upper word in division of lower word					//	divide lower word					load cue_time32(1); uload read("313"); div 40;					cue_time32(1) = res + (rem ige 20);	//	rounded result					//	Determine the target.  We'll target the nearest subdivision of a beat based on the click rate multiplier.					//	Note that since tempo events can occur anywhere, we'll have to convert the two subdivisions bookending the					// cue back to real time in order to really know which is closest.					//	Perhaps this can easily be modified to utilize the live click track feature.					//	convert from whole fields to SMPTE bits					//	multiply lower word					load cue_time32(1); mul 40;					target_time32(1) = res;					write("313") = ures;				//	save overflow to use as addend in multiplication of upper word					//	multiply upper word					load cue_time32(0); uload read("313"); mul 40;					target_time32(0) = res;					//	subtract out SMPTE offset					sub32(target_time32,smpte32,target_time32);					// convert to real milliseconds					sbits.to.msec(target_time32,cf#time,S$Speed,S$Smode,target_time32);					//	At this point the real milliseconds corresponding to cue_time32 is in target_time32.  Now we can bookend this time.					// convert to sequence milliseconds					Map.Real.Time.To.Sequence.Time(target_time32,BitMsbArray);					sub16(zero.time,BitMsbArray);					ratio_multiply(samp.crm,samp.click.rate);					copy32(BitMsbArray,next32);					//	if ratio_multiply just rounded up, decrement prior, else increment next					if (mul.llsb < 0)	sub16(1,BitMsbArray);					else					add16(1,next32);					//	convert these quanta back to sequence time					ratio_multiply(samp.click.rate,samp.crm); copy32(BitMsbArray,prior32); add16(zero.time,prior32);					copy32(next32 ,BitMsbArray);					ratio_multiply(samp.click.rate,samp.crm); copy32(BitMsbArray,next32 ); add16(zero.time,next32 );					//	Map prior beat and next beat back to real time					Map.Sequence.Time.To.Real.Time(prior32,prior32);					Map.Sequence.Time.To.Real.Time(next32, next32 );					//	get the real distances between the cue time and the surrounding subdivisions of beats					sub32(target_time32,prior32,prior_dur32);					sub32(next32,target_time32 ,next_dur32 );					//	choose the nearest sub-beat (choose the later sub-beat if equidistant)					if (com32(prior_dur32,next_dur32) == lw#ilt)	copy32(prior32,target_time32);					else														copy32(next32 ,target_time32);					Map.Real.Time.To.Sequence.Time(target_time32,target_time32);					//	point to the appropriate NLS					write(mam) = CFit.Map.Ptr;					if (CFit.Map.Cur == CFit.Map.Last) {						//	must link on a new NLS						if (Allocate.Map.Block(0,read(md),cfit.map#) == null) {							erase_cfit_map();	//	recycle what we've built thus far							ertyp = err.oom;	// report no memory for map							return;						}						//	Note: the above call to Allocate.Map.Block has left us pointing to the previous NLS						write(mal) = CFit.Map.Last;		//	write the cue and target times at the end of the previous NLS						write(mdi) = cue_time32(0);						write(mdi) = cue_time32(1);						write(mdi) = target_time32(0);						write(md ) = target_time32(1);						write(mal) = CFit.Map.Record#;					//	Get the record number of the first record in the previous NLS						write("313") = read(md)+CFit.Map.#Records;	//	Add the 27 records in the previous NLS to this running total						if (read("313") ilt CFit.Map.#Records) {		//	check for overflow							erase_cfit_map();			//	recycle what we've built thus far							ertyp = err.overflow;	// report too many events							return;						}						//	Now point to the new NLS						write(mam) = CFit.Map.Ptr;						write(mal) = CFit.Map.FP;						write(mdi) = CFit.Map.First;		//	CFit.Map.FP						write(mdi) = CFit.Map.First;		//	CFit.Map.LP						//	Poke the new total into this new NLS						write(md ) = read("313");			//	CFit.Map.Record#						CFit.Map.Cur = CFit.Map.First;						CFit.Map.Len = CFit.Map.First;					}					//	point to the appropriate record and stash all our values					write(mal) = CFit.Map.Cur;					write(mdi) = cue_time32(0);					write(mdi) = cue_time32(1);					write(mdi) = target_time32(0);					write(mdi) = target_time32(1);					write(mdi) = 0;	//	starting_tempo(0);	*** UNIMPLEMENTED FOR NOW ***					write(mdi) = 0;	//	starting_tempo(1);	*** UNIMPLEMENTED FOR NOW ***					write(mdi) = 0;	//	ending_tempo(0);		*** UNIMPLEMENTED FOR NOW ***					write(mdi) = 0;	//	ending_tempo(1);		*** UNIMPLEMENTED FOR NOW ***					write(md ) = 1;	//	default to a weight of 1					//	increment the word pointers to the next possible record					CFit.Map.Cur = CFit.Map.Cur+CFit.Map.Rec.Len;					CFit.Map.Len = CFit.Map.Cur;					write(mal) = CFit.Map.LP;					write(md ) = CFit.Map.Len;				}			}			note_exists = advance.to.next.note;		}		//	Terminate the list		write(mam) = CFit.Map.Ptr;	//	because the final call to advance.to.next.note changed our current sector		write(mal) = CFit.Map.Cur;		write(mdi) = -1;		write(mdi) = -1;		write(mdi) = -1;		write(md ) = -1;		CFit.Map.Cur = CFit.Map.Cur-CFit.Map.Rec.Len;	//	illegal to leave CFit.Map.Cur pointing at termination (I think)		Normalize.CFit.Map.Cur();								//	set up the handy and convenient copies	}end Create.CFit.Map.From.Track;