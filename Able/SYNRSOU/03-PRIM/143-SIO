/* :SYNRSOU:03-PRIM:143-SIO  $TITLE  IO DEVICE DEFINITIONS FOR SYNCL II, POLY SYNTH, =SMPTE */

/*
Modified:
1998/06/24 - TY  - Updated expressions containing (CLICK.TRACK.MODE & 511) to account
						 for the independence of CLICK.TRACK.MODE from CLICKON.
1991/10/16 - CJ  - Set flag on smpte auto-start to allow correct shutdown
1990/05/02 - cj  - added "pull-down" smpte code
1990/01/25 - MWH - Fix "300 msec delay starting cues" bug (from EditView)
1989/09/26 - CJ  - created system event when smpte lock changes (for cmx)
1989/09/23 - CJ  - Mapped tempos during smpte lockup
1988/07/18 - CJ  - skip sync check if we are coasting (check.smpte.synchronization)
					  - Many different constants in SMPTE algorithm to handle
						 repeating frames
1988/05/24 - MWH - Limit negative SMPTE times to 15 minutes, not 12 hours
1988/05/19 - MWH - Remove unused procedures
1988/02/24 -CJ,TSS-Merged a bunch of changes to SMPTE code
1987/11/12 - MWH - Make timer comparisons unsigned to fix "30 sec hang"
1986/11/12 -     - debugged copy.poly.mem
1986/05/15 - "official" creation of release-M modules
*/

DCL STOP.DATA DATA PUBLIC(255,255,0,0,0,0,0,0,255,255,0,0);

DCL SMPTE.ONOFF      FIXED PUBLIC; /* 1: SMPTE ON.  0: SMPTE OFF */
DCL SMPTE.STATE      FIXED PUBLIC; /* INTERNAL STATE             */
DCL SMPTE.RECD       FIXED PUBLIC; /* STORED PUNCH & RECORD BITS */
DCL SMPTE.AUTO.START FIXED PUBLIC;

/* DECLARE RATE-INFO3 IN ORDER: */
DCL SMPTE.RATE       FIXED PUBLIC; /* SMPTE BITS PER 10 SECONDS  */
DCL SMPTE.TIME       FIXED PUBLIC; /* TIME OF SMPTE READING      */
DCL SMPTE.ACCUM      FIXED PUBLIC; /* BIT ACCUMULATOR            */
DCL SMPTE.ADVANCES   FIXED PUBLIC; /* ADVANCE ACCUMULATOR        */
DCL SMPTE.BRATE      FIXED PUBLIC; /* BIT RATE (BITS IN 20 MSEC) */
DCL SMPTE.RATE.ACCUM FIXED PUBLIC; /* RATE ACCUMULATOR           */
DCL SM.INFO1         FIXED PUBLIC; /* SMPTE INFO STORED HERE     */
DCL SM.INFO2         FIXED PUBLIC; /* BY D03 INTERRUPT ROUTINE   */
DCL SM.INFO3         FIXED PUBLIC;

/* DECLARE RATE-INFO3 IN ORDER: */
DCL (SAMPLED.RATE )      FIXED PUBLIC; /* SAMPLED BY MAIN LOOP       */
DCL (SAMPLED.TIME )      FIXED PUBLIC; /* FOR USE DURING LOCK-UP     */
DCL (SAMPLED.ACCUM)      FIXED PUBLIC;
DCL (SAMPLED.ADVANCES)   FIXED PUBLIC;
DCL (SAMPLED.BRATE)      FIXED PUBLIC;
DCL (SAMPLED.RATE.ACCUM) FIXED PUBLIC; /* RATE ACCUMULATOR          */
DCL (SAMPLED.INFO1)      FIXED PUBLIC;
DCL (SAMPLED.INFO2)      FIXED PUBLIC;
DCL (SAMPLED.INFO3)      FIXED PUBLIC;
                           

DCL SMPTE.BIT.TARG   FIXED PUBLIC; /* TARGET BIT.ACCUM FOR LOCK UP    */
DCL SMPTE.TIME.TARG  FIXED PUBLIC; /* TARGET KBD.MILLS FOR LOCK UP    */
DCL SMPTE.TRACK.RATE FIXED PUBLIC; /* RATE TO USE FOR TRACKING        */
DCL SMPTE.LAST.ADV   FIXED PUBLIC; /* PREVIOUS LAST.ADV READING       */
DCL SMPTE.LAST.RACC  FIXED PUBLIC; /* PREVIOUS RATE ACCUMULATOR       */
DCL SMPTE.MODE.RATE  FIXED PUBLIC; /* DESIRED RATE FOR MODE     */
DCL SMPTE.SYNC.MSB   FIXED PUBLIC; /* ERROR ACCUMULATOR         */
DCL SMPTE.SYNC.LSB   FIXED PUBLIC;

DCL (SLOCKED)             FIXED PUBLIC;  /* TRUE IF LOCKED TO SMPTE        */
DCL (DISABLE.SMPTE.START) FIXED PUBLIC;  /* SET TRUE TO DISABLE AUTO-START */
DCL (CHECK.SMPTE.ERROR)   FIXED PUBLIC;  /* SET TO CHECK SYNC              */

/* THESE VARIABLES MUST BE IN ORDER:  (ACCESSED WITH "CORE") */

DCL CUR.HRS          FIXED PUBLIC; /* LAST READ SMPTE TIME        */
DCL CUR.MIN          FIXED PUBLIC; /* STORED AS GLOBAL VARIABLES  */
DCL CUR.SEC          FIXED PUBLIC; /* FOR DISPLAY                 */
DCL CUR.FRA          FIXED PUBLIC;
DCL CUR.BIT          FIXED PUBLIC;
                           
DCL DIS.HRS          FIXED PUBLIC; /* LAST DISPLAYED SMPTE TIME   */
DCL DIS.MIN          FIXED PUBLIC;
DCL DIS.SEC          FIXED PUBLIC;
DCL DIS.FRA          FIXED PUBLIC;
DCL DIS.BIT          FIXED PUBLIC;

DCL BITS.PER.MSEC.NUM DATA PUBLIC  /* SMPTE BITS PER MSEC NUMERATOR */
(2997, 3000, 2500, 2400, 2997);

DCL BITS.PER.MSEC.DEN DATA PUBLIC  /* SMPTE BITS PER MSEC DENOM     */
(1250, 1250, 1250, 1250, 1250);	  /* MUST BE DIVISIBLE BY 50		  */

DCL BIT.RATE.FACTOR   DATA PUBLIC  /* FACTOR FOR RATE CORRECTION    */
( 104,  104,  104,  104,  104);    /* 1/12 OF BITS.PER.MSEC.DEN     */

DCL BITS.PER.10.SEC  DATA          /* SMPTE BITS IN 10 REAL SECONDS */
(23976,24000,20000,19200,23976);

DCL SMPTE.FRAME.CODES DATA         /* 30 30 25 24 FRAME             */
("220","220","221","222","220");

/* $PAGE - ROUTINE TO INITIALIZE SMPTE BOARD */


DCL SMPTE.LAST.INFO2  FIXED PUBLIC; /* SAVE LAST READING DISPLAYED ON    */
DCL SMPTE.LAST.INFO3  FIXED PUBLIC; /* VK FOR BETTER DISPLAYING          */

INIT.SMPTE:PROC PUBLIC SWAPABLE;    /* PROCEDURE TO INITIALIZE FOR SMPTE */
   DCL (I) FIXED;                   /* CALL ON SMPTE MODE CHANGE         */


   SMPTE.ONOFF=0;                   /* SUPPRESS USE OF SMPTE FOR NOW     */
   SMPTE.RATE =0;                   /* RATE IS GONZO                     */
   SMPTE.STATE=0;                   /* INITIALIZE STATE                  */

   DISABLE;                         /* PROTECT FROM INTERRUPTS */
   WRITE(D70)=SMPTE.SUBSYS;
   WRITE(D71)=SMPTE.FRAME.CODES(SM.MODE);  /* SELECT FRAME MODE       */
   I=REAL.MILLISECONDS;
   ENABLE;
   DO WHILE (REAL.MILLISECONDS-I) ILT 10;
		interp_run_host_non_timer();
   END;

   DISABLE;                         /* PROTECT FROM INTERRUPTS */
   WRITE(D70)=SMPTE.SUBSYS;
   WRITE(D71)="200";                /* SELECT ERROR CORRECTION MODE */
   I=REAL.MILLISECONDS;
   ENABLE;
   DO WHILE (REAL.MILLISECONDS-I) ILT 10;
		interp_run_host_non_timer();
   END;

   SMPTE.ONOFF=1;                   /* SET SMPTE RUNNING NOW        */

   I=REAL.MILLISECONDS;
   DO WHILE (REAL.MILLISECONDS-I) ILT 50;
		interp_run_host_non_timer();
   END;

   SMPTE.LAST.INFO2  = SM.INFO2;
   SMPTE.LAST.INFO3  = SM.INFO3;

END INIT.SMPTE;

/* $PAGE - subroutine to compute smpte bit position */

/* this routine is used to accurately compute the smpte bit position */
/* of a sequencer time.   It is passed a play time msb, lsb, and     */
/* acu.   It computes and returns the # of smpte bits from           */
/* sequencer time 0,0,0 to the passed sequencer time                 */

/* The smpte.rate.accumulator can also be set by this routine        */

COMPUTE.SEQUENCER.SMPTE.BIT:PROC (PLAY.MSB, PLAY.LSB, PLAY.ACU, BIT#, SETRATE) SWAPABLE;
   DCL PLAY.MSB FIXED;       /* PASS CURRENT SEQUENCER TIME  */
   DCL PLAY.LSB FIXED;       /* MSB, LSB, ACU                */
   DCL PLAY.ACU FIXED;
   DCL BIT#     ARRAY;       /* OUTPUT BIT # GOES HERE       */
   DCL SETRATE  FIXED;       /* TRUE TO SET SMPTE.RATE.ACCUM */

   DCL MSB      FIXED;
   DCL LSB      FIXED;
   DCL LLSB     FIXED;
   DCL M        FIXED;

   /* LET'S DO SOME 48-BIT MATH TO ACCURATELY COMPUTE   */
   /* WHAT SMPTE BIT TIME THIS CORRESPONDS TO:          */

   /* FORMULA IS:  (PLAY.TIME * BITS.PER.MSEC * 1000 / SAMP.SPEED) */

   /* PLAY.ACU * BITS PER MSEC: */

   BITMSB=0; BITLSB=PLAY.ACU;  
   CALL MULTIPLY(BITS.PER.MSEC.A(SM.MODE),BITS.PER.MSEC.B(SM.MODE),    
                 BITS.PER.MSEC.C(SM.MODE),BITS.PER.MSEC.D(SM.MODE));   
   CALL ratio_multiply(1,1000);
   CALL UNROUND;
   MSB=BITMSB; LSB=BITLSB; LLSB=MUL.LLSB;


   /* + (PLAY.MSB,PLAY.LSB) * BITS PER MSEC: */

   BITMSB=PLAY.MSB; BITLSB=PLAY.LSB;
   CALL MULTIPLY(BITS.PER.MSEC.A(SM.MODE),BITS.PER.MSEC.B(SM.MODE),    /* GET SMPTE */
                 BITS.PER.MSEC.C(SM.MODE),BITS.PER.MSEC.D(SM.MODE));   /* SINCE START */
   CALL UNROUND;
   LLSB=LLSB+MUL.LLSB;
   IF LLSB ILT MUL.LLSB THEN DO;
      LSB=LSB+1;
      IF LSB=0 THEN MSB=MSB+1;
   END;
   LSB=LSB+BITLSB;
   IF LSB ILT BITLSB THEN MSB=MSB+1;
   MSB=MSB+BITMSB;

   /* MSB,LSB * 1000/SPEED: */

   BITMSB=MSB; BITLSB=LSB;
   CALL ratio_multiply(1000,SAMP.SPEED);
   CALL UNROUND;
   MSB=BITMSB; LSB=BITLSB; M=MUL.LLSB;

   /* + LLSB * 1000/SPPED:  */

   BITMSB=0; BITLSB=LLSB;
   CALL ratio_multiply(1000,SAMP.SPEED);
   LLSB=M+BITLSB;
   IF LLSB ILT BITLSB THEN DO;
      LSB=LSB+1;
      IF LSB=0 THEN MSB=MSB+1;
   END;
   LSB=LSB+BITMSB;
   IF LSB ILT BITMSB THEN MSB=MSB+1;


   /* ROUND CURRENT SEQUENCER TIME TO   */
   /* NEAREST SMPTE BIT.   SAVE LSB'S   */
   /* IN RATE ACCUMULATOR FOR EXTRA     */
   /* PRECISION                         */

   IF SETRATE THEN DO;
      SMPTE.MODE.RATE=BITS.PER.10.SEC(SM.MODE);   /* LOOK UP RATE FOR MODE */
      LOAD LLSB; MUL SMPTE.MODE.RATE;             /* INITIALIZE SMPTE      */
      SMPTE.RATE.ACCUM=URES;                      /* RATE ACCUMULATOR      */
   END;

   BIT#(0) = MSB;
   BIT#(1) = LSB;

END COMPUTE.SEQUENCER.SMPTE.BIT;

/* $PAGE - LOCK UP TO SMPTE SYNC */

LOCK.TO.SMPTE:PROC PUBLIC SWAPABLE;
   DCL SEQ.START.SMPTE.BIT  (1)  FIXED;
   DCL CUR.SMPTE.BIT        (1)  FIXED;
   DCL SMPTE.WINDOW.BITS    (1)  FIXED;
   DCL I                         FIXED;
   DCL LOW                  (1)  FIXED;
   DCL HIGH                 (1)  FIXED;
   DCL TEMP                 (1)  FIXED;
   DCL (LOLIM,HILIM)             FIXED;


   /* COMPUTE ABS PLAY TIME:   ROUTINE IS USED TO COMPUTE A PLAY.TIME.MSB,
      PLAY.TIME.LSB FOR A FAST FORWARD/REWIND DESTINATION ONLY.

      ROUTINE IS PASSED:

          SMPTE STARTING TIME,  ENCODED IN SMPTE BITS
          ABS SMPTE TIME WE WANT THE SEQUENCER TO BE AT
          SEQUENCER SPEED CONTROL

      RETURNS:

          BITMSB,BITLSB  = PLAY.TIME.MSB, PLAY.TIME.LSB FOR FF/REW DESTINATION */


   COMPUTE.ABS.PLAY.TIME:PROC(SEQ.START.SMPTE.BIT, HIGH);  /* GET DEST PLAY.TIME FOR FF, REW */
      DCL SEQ.START.SMPTE.BIT  ARRAY;
      DCL HIGH                 ARRAY;

      CALL SUB32(HIGH, SEQ.START.SMPTE.BIT, BitMsbArray);
      CALL MULTIPLY(0,MSECS.PER.BIT.B(SM.MODE),MSECS.PER.BIT.C(SM.MODE),MSECS.PER.BIT.D(SM.MODE));
      CALL ratio_multiply(SAMP.SPEED,1000);
   END COMPUTE.ABS.PLAY.TIME;


   /* BEGINNING OF CODE FOR LOCK.TO.SMPTE: */

   /* FIRST,  MAKE SURE SEQUENCER IS IN    */
   /* CORRECT STATE (I.E. PLAYING,  NOT    */
   /* FF/REW:                              */

   IF MOVE<>0 THEN DO;              /* STOP ANY USER FF/REW     */
      CALL STOP.MOVE;
      CALL DISPLAY.SEQUENCER.STATUS;
      RETURN;
   END;

   /* NOW CHECK FOR MATCHING DROP FRAME    */
   /* SELECTION AND MODE BIT:              */

   I = SAMPLED.INFO1&SHL(4,8);      /* ISOLATE DROP FRAME BIT     */
   IF  (((I<>0)&(SM.MODE<>0))       /* IF NOT LOCKED FOR SPEED    */
   OR   ((I= 0)&(SM.MODE =0)))      /* MATCHES SELECTED MODE      */
   THEN DO;
      CALL DISPLAY.ERR(35);
      UPPER.DISP=SMPTE.E.DISP;
      RETURN;
   END;


   /* NOW CHECK FOR BIT=0,  BIT=79          */
   /* FIRMWARE BUG CAUSES SYNC ERROR HERE:  */

   IF (CUR.BIT=0)                   /* AVOID BIT=0  FIRMWARE BUG  */
   OR (CUR.BIT=79)                  /* AVOID BIT=79 FIRMWARE BUG  */
   THEN RETURN;                     /* WAIT                       */


   /* COMPUTE SMPTE BIT TIME FOR OUR         */
   /* STARTING TIME,  AND CURRENT TIME:      */

   CALL SMPTE.TO.SBITS(LOC(ADDR(SM.HRS)),  SM.MODE, SEQ.START.SMPTE.BIT);

   CALL SMPTE.TO.SBITS(LOC(ADDR(CUR.HRS)), SM.MODE, CUR.SMPTE.BIT);

   /* HANDLE INCOMING SMPTE WITHIN "NEGATIVE SMPTE WINDOW" IMMEDIATELY  */
   /* PRECEEDING THE SMPTE OFFSET TIME.  IF INCOMING SMPTE IS BELOW THE */
   /* WINDOW, REMAP IT TO BE ABOVE 24 HOURS.                            */

   MISC.BUF(0) = 0;   /* HR, MIN, SEC, FRAME, BIT: IN SMPTE WINDOW */
   MISC.BUF(1) = 15;  MISC.BUF(2) = 0;  MISC.BUF(3) = 0; MISC.BUF(4) = 0;
   CALL SMPTE.TO.SBITS(MISC.BUF,SM.MODE,SMPTE.WINDOW.BITS);  /* GET BITS IN NEGATIVE WINDOW */
   CALL COPY32(SEQ.START.SMPTE.BIT,TEMP);   /* GET BITS IN SMPTE OFFSET  */
   IF COM32(TEMP,SMPTE.WINDOW.BITS)<>LW#ILT /* CAN WE UNSIGNED SUBTRACT? */
   THEN CALL SUB32(TEMP,SMPTE.WINDOW.BITS,TEMP);/* SUBTRACT SMPTE WINDOW */
   ELSE CALL STR32(0,0,TEMP);               /* ELSE, NEVER ADD 24 HOURS  */
   IF COM32(CUR.SMPTE.BIT,TEMP) = LW#ILT    /* ARE WE BEFORE THE WINDOW? */
   THEN DO;
      CUR.HRS = CUR.HRS + 24;               /* BUMP INCOMING SMPTE AHEAD */
      CALL SMPTE.TO.SBITS(LOC(ADDR(CUR.HRS)), SM.MODE, CUR.SMPTE.BIT);
      CUR.HRS = CUR.HRS - 24;               /* RESTORE CUR.HRS           */
   END;

   /* When syncing up, sync to next smpte frame, since we don't  */
   /* normally see the smpte frame until the END of the frame    */
   /* in question                                                */

   CALL ADD16(80, CUR.SMPTE.BIT);   
   

   /* THE D70 BOARD PROVIDES SMPTE READINGS  */
   /* THAT ARE 1 BEHIND.   ADVANCE OUR       */
   /* CURRENT SMPTE TIME BY THE NUMBER OF    */
   /* BITS THAT GO BY BETWEEN READINGS SO    */
   /* WE KNOW EXACTLY WHERE WE ARE:          */
   
   CALL ADD16(SAMPLED.BRATE, CUR.SMPTE.BIT);

   
   /* COMPUTE HOW MANY BITS ARE IN ZERO.TIME. */
   /* ADD TO CURRENT READING TO LINE UP       */
   /* SMPTE START TIME WITH FIRST CLICK:      */

   CALL STR32(0, ZERO.TIME, BitMsbArray);

   CALL MULTIPLY(BITS.PER.MSEC.A(SM.MODE),BITS.PER.MSEC.B(SM.MODE),    /* GET SMPTE */
                 BITS.PER.MSEC.C(SM.MODE),BITS.PER.MSEC.D(SM.MODE));   /* SINCE START */

   CALL ratio_multiply(1000,SAMP.SPEED);

   CALL ADD32(CUR.SMPTE.BIT, BitMsbArray, CUR.SMPTE.BIT);


   /* NOW COMPUTE OUR HIGH AND LOW LIMITS.    */
   /* THESE WILL BE THE ABSOLUTE SMPTE TIMES  */
   /* CORRESPONDING TO +200 AND +400 MSECS    */
   /* FROM NOW.   WE WILL FF/REW THE          */
   /* SEQUENCER TO BE WITHING THIS RANGE      */
   /* BEFORE ATTEMPTING TO LOCK UP:           */

   /* SAMPLED.RATE = SMPTE BITS GOING BY IN 10 SECONDS */

   /* PROVIDE A LONGER LOCK UP WINDOW IF USING LIVE CLICK TRACK  */
   /* AND SENDING MIDI SYNC OUT,  TO PROVIDE ENOUGH TIME TO CALL */
   /* THE REMAP TIME BASE ROUTINE                                */

   LOLIM=200;         /* NORMALL SEQUENCER MUST BE POSITIONED BETWEEN 200 */
   HILIM=400;         /* AND 400 MSEC IN FRONT OF US                      */

   IF  (MIDI.SYNC.OUT<>0)			/* BUT IF SENDING MIDI SYNC OR MTC		  */
   AND (CLICK.TRACK.MODE igt 3)	/* WITH LIVE CLICK							  */
   THEN DO;
      LOLIM=1200;    /* NORMAL SEQUENCER MUST BE POSITIONED BETWEEN 1200  */
      HILIM=2400;    /* AND 2400 MSEC IN FRONT OF US                      */
   END;

   CALL COPY32(CUR.SMPTE.BIT, LOW);
   CALL COPY32(CUR.SMPTE.BIT, HIGH);

   LOAD SAMPLED.RATE; MUL LOLIM; MWAIT; DIV 10000;  /* BITS IN 200 MSEC */
   CALL ADD16(RES, LOW);

   LOAD SAMPLED.RATE; MUL HILIM; MWAIT; DIV 10000;  /* BITS IN 400 MSEC */
   CALL ADD16(RES, HIGH);


   /* NOW SEE IF OUR CURRENT SMPTE TIME       */
   /* IS BEFORE THE SMPTE STARTING TIME FOR   */
   /* THE SEQUENCE.  IF SO, THEN JUST       */
   /* INITIALIZE THE SEQUENCE SO IT WILL      */
   /* BE SITTING AT ABSOLUTE 0.000 (BEFORE    */
   /* ZERO.TIME) AND WAIT FOR INCOMING SMPTE  */
   /* TO CATCH UP.                            */

   /* HANDLE INCOMING SMPTE WITHIN "NEGATIVE SMPTE WINDOW" IMMEDIATELY  */
   /* PRECEEDING THE SMPTE OFFSET TIME.  IF INCOMING SMPTE IS BELOW THE */
   /* WINDOW, REMAP IT TO BE ABOVE 24 HOURS.                            */

   MISC.BUF(0) = 24;   /* HR, MIN, SEC, FRAME, BIT: 24 HOURS EXACTLY */
   MISC.BUF(1) = 0;  MISC.BUF(2) = 0;  MISC.BUF(3) = 0; MISC.BUF(4) = 0;
   CALL SMPTE.TO.SBITS(MISC.BUF,SM.MODE,TEMP); /* GET BITS IN 24 HOURS  */
   CALL SUB32(TEMP,SMPTE.WINDOW.BITS,TEMP);    /* SUBTRACT SMPTE WINDOW */
   CALL ADD32(TEMP,SEQ.START.SMPTE.BIT,TEMP);  /* ADD SMPTE OFFSET      */

   /* SEE IF SMPTE OFFSET IS LARGE AND INCOMING TIME HAS WRAPPED AROUND */
   IF COM32(CUR.SMPTE.BIT,TEMP) = LW#IGT           /* IF SO, WE'RE IN NEGATIVE TIME WINDOW */
   OR (COM32(HIGH, SEQ.START.SMPTE.BIT) = LW#ILT)  /* OR WE'RE ELSEWHERE IN NEGATIVE TIME WINDOW */
   THEN DO;                         /* WAIT FOR SMPTE TO CATCH UP */
      IF (PLAY.TIME.MSB<>0)         /* INITIALIZE FOR FAST REWIND */
      OR (PLAY.TIME.LSB<>0)         /* SEQUENCER IS NOT AT 0,0,0  */
      OR (PLAY.TIME.ACU<>0)
      OR (PLAY         <>0)         /* OR NOTE SCANNED & LOST     */
      THEN DO;                      /* INITIALIZE FOR FAST REWIND */
		   DCL LOCATE.MIDI.SLAVES PROC EXTERNAL;
			
         I=0;                       /* ASSUME NO SMPTE.RECD       */
         IF RECD<>0 THEN DO;        /* SET SMPTE.RECD IF DESIRED  */
            I=RECD\SHL(PNCH,1);
         END;
         CALL STOP.RECD.MOVE.PLAY;  /* STOP SEQUENCER IF PLAYING  */
         CALL PLAY.INITIALIZE;      /* SET UP FOR PLAY FROM TOP   */
         NEW.BEAT.NUMBER = 1;       /* PUT 0 IN DISPLAY           */
			CALL LOCATE.MIDI.SLAVES;   /* LOCATE MIDI SLAVE DEVICES  */
         CALL CHECK.ALL.MIDI.TRACKS;/* SAVE TIME LATER            */
         CALL CHECK.ALL.MIDI.RTES;
         CALL DISPLAY.SEQUENCER.STATUS;
         SMPTE.RECD=I;
      END;
      RETURN;                       /* WILL START PLAYING NEXT TIME TRHOUGH */
   END;

   /* NOW MAKE SURE WE ARE READY TO PLAY */

   IF PLAY=0 THEN DO;               /* MAKE SURE PLAYING          */
      CALL CHECK.ALL.MIDI.TRACKS;
      CALL START.TIME.BASE;
      CALL DISPLAY.SEQUENCER.STATUS;
      SMPTE.AUTO.START = 1;
   END;
   DELAY.NOTE.AND.CUE.STARTS = 0;   /* NO PRE-ROLL WITHOUT AUDIO  */


   /* COMPUTE SMPTE BIT (ACCURATELY) FOR WHERE THE */
   /* SEQUENCER IS SITTING NOW                     */

   CALL COMPUTE.SEQUENCER.SMPTE.BIT (PLAY.TIME.MSB, PLAY.TIME.LSB, 
                                     PLAY.TIME.ACU, TEMP, 1);


   /* ADD IN SMPTE START TIME TO SEQUENCER POSITION */
   /* TO GET ABSOLUTE SMPTE TIME WHERE SEQUENCER    */
   /* IS NOW SITTING:                               */

   CALL ADD32(SEQ.START.SMPTE.BIT, TEMP, TEMP);


   /* NOW COMPARE THE CURRENT SEQUENCER POSITION (MSB,LSB) */
   /* WITH OUR CURRENT SMPTE POSITION (K,L).  SEE IF       */
   /* WE MUST FAST FORWARD,  REWIND,  OR IF WE ARE CLOSE   */
   /* ENOUGH TO LOCK UP:                                   */

   /* CHECK FOR FAST FOWARD REQUIRED:                      */

   IF COM32(TEMP, LOW) = LW#ILT    /* FF IF NEEDED IF SO               */
   THEN DO;
      IF RECD<>0 THEN DO;          /* FLOP OUT OF RECORD FOR FF        */
         I=RECD\SHL(PNCH,1);
         CALL STOP.RECORD;
         CALL DISPLAY.SEQUENCER.STATUS;    
         SMPTE.RECD=I;
      END;
      MOVE=1; MOVE.SPEED=1;        /* SET FF LIGHT                     */
      CALL DISPLAY.SEQUENCER.STATUS;
      CALL COMPUTE.ABS.PLAY.TIME(SEQ.START.SMPTE.BIT, HIGH);  /* GET DEST PLAY.TIME FOR FF, REW */

      /* Fastforward quickly to first note of sequence.  Once we get */
      /* in the middle of notes,  advance in small chunks so the     */
      /* system does not get bogged down:                            */

      IF  (PTRS.LOOPED=LOOP.RESTART) /* PLAY TIME AND PTRS ARE CONSISTENT */
      AND (NEXT.EVENT.QUEUE<>0)      /* AND NOTES TO PLAY                 */
      THEN DO;
         CALL COPY32(LOC(ADDR(NEXT.EVENT.MSB)), TEMP);  /* GET TIME OF NEXT NOTE */
         IF TEMPO.MAP.PTR <> 0
         THEN CALL Map.Sequence.Time.To.Real.Time(TEMP, TEMP);
         CALL ADD16 (30000,TEMP);                       /* THAT TIME + 30 SECODNS   */
         IF COM32(TEMP,BitMsbArray) = LW#ILT            /* LIMIT HOW FAR WE ADVANCE       */
         THEN CALL COPY32(TEMP,BitMsbArray);            /* IN ONE TIME SO MACHINE DOES    */
      END;

      CALL ADVANCE.SEQUENCER(BITMSB,BITLSB);
      MOVE=0; MOVE.SPEED=0;
      CALL DISPLAY.SEQUENCER.STATUS;
      CALL CHECK.ALL.MIDI.TRACKS;
      RETURN;
   END;


   /* CHECK FOR REWIND REQUIRED:                      */

   IF COM32(TEMP, HIGH) = LW#IGT       /* REW IF NEEDED IF SO         */
   THEN DO;
      IF RECD<>0 THEN DO;
         I=RECD\SHL(PNCH,1);
         CALL STOP.RECORD;
         CALL DISPLAY.SEQUENCER.STATUS;    
         SMPTE.RECD=I;
      END;
      MOVE=1;                 
      MOVE.SPEED=(-1);
      CALL DISPLAY.SEQUENCER.STATUS;   /* LIGTH REWIND LIGHT          */
      CALL REBUILD.EVENT.QUEUE;        /* SET UP EVENT QUE IN REVERSE */
      CALL COMPUTE.ABS.PLAY.TIME(SEQ.START.SMPTE.BIT, HIGH);  /* GET DEST PLAY.TIME FOR FF, REW */
      IF PLAY.TIME.MSB <> 0 THEN DO;
         CALL COPY32(LOC(ADDR(PLAY.TIME.MSB)), TEMP);   /* GET CURRENT PLAY TIME (MSECS) */
         CALL SUB16 (30000,TEMP);                       /* COMPUTE CURRENT - 30 SECONDS */
         IF COM32(TEMP,BitMsbArray) = LW#IGT
         THEN CALL COPY32(TEMP,BitMsbArray);
      END;
      CALL BACKUP.SEQUENCER(BITMSB,BITLSB);
      MOVE=0;
      MOVE.SPEED=(0);
      CALL REBUILD.EVENT.QUEUE;   
      CALL DISPLAY.SEQUENCER.STATUS;    
      CALL CHECK.ALL.MIDI.TRACKS;
      RETURN;
   END;


   /*  LOCK UP TO SMPTE: */

   /* THE SEQUENCER IS CURRENTLY SITTING JUST IN FRONT OF OUR   */
   /* CURRENT SMPTE TIME (SPECIFICALLY:  200 TO 400 MSECS FROM  */
   /* RIGHT NOW).   SET UP A PROCESS TO START THE SEQUENCER     */
   /* PLAYING AT THE CORRECT SMPTE TIME.                        */

   /* THIS IS DONE BY FIRST COMPUTING HOW MANY SMPTE BITS       */
   /* WE MUST WAIT BEFORE STARTING:                             */

   /* BUT FIRST,  GET INTO RECORD MODE IF USER SO REQUESTED:    */

   IF  (RECD=0)
   AND (SMPTE.RECD<>0)
   THEN DO;
      CALL START.RECORD;
      IF RECD=0 THEN DO;             /* ERROR CONDITION WAS */
         SMPTE.RECD=0;               /* ENCOUNTERED         */
         CALL DISPLAY.SEQUENCER.STATUS;     
         RETURN;
      END;
      IF ((SMPTE.RECD&2)<>0) THEN DO;
         /* DON'T NEED TO RESET TIME.DELTA SINCE IT SHOULD STILL BE OK */
         PNCH=1;
      END;
   END;
   SMPTE.RECD=0;
   CALL DISPLAY.SEQUENCER.STATUS;     

   /* COMPUTE SMPTE BIT TARG - THIS IS A TARGET VALUE FOR SMPTE.ACCUM.  IT */
   /* BASICALLY REPRESENTS WHAT THE SMPTE ACCUM VALUE WILL BE WHEN THE     */
   /* IN-COMING SMPTE TIME MATCHES WHERE THE SEQUENCER IS SITTING          */

   /* WHEN THE SMPTE BIT ACCUMULATOR (SMPTE.ACCUM) REACHES THE TARGET      */
   /* VALUE (SMPTE.BIT.TARG),  THE SEQUENCER WILL START ADVANCING          */

   SMPTE.BIT.TARG   = SAMPLED.ACCUM        /* START WITH SMPTE ACCUMULATOR WHEN MEASUREMENT WAS TAKEN */
                      + TEMP(1)            /* ADD IN DIFFERENCE BETWEEN WHERE SEQUENCER SITS AND WHERE SMPTE IS */
                      - CUR.SMPTE.BIT(1)   /* TARGET SMPTE BIT WHICH MATCHES CURRENT SEQUENCER POSITION */
                      + SAMPLED.BRATE;     /* ADD IN SAMPLED BRATE TO PROVIDE FOR ACCURATE VARISPEED COMPUTATIONS */

   SMPTE.LAST.ADV   = SAMPLED.ADVANCES;    /* ACCUMULATE PLAY TIME ADVANCES HERE    */
   SMPTE.TRACK.RATE = SAMPLED.RATE;        /* USE THIS RATE AT FIRST                */
   SMPTE.SYNC.MSB   = 0;                   /* INITIALIZE ERROR ACCUMULATOR          */
   SMPTE.SYNC.LSB   = 0;
   SMPTE.LAST.RACC  = 0;                   /* MOVE INITIAL ERROR TO SYNC.LSB ON FIRST CHECK */

   NEW.MOTION       = 1;                   /* TELL LOD ABOUT IT                     */

   SLOCKED=1;                              /* WE ARE NOW LOCKED */

   /* Create a system event whenever smpte locks or unlocks     */

   NEW.SEQ.INFO = NEW.SEQ.INFO \ 128;

   IF MIDI.SYNC.OUT<>0 THEN BEGIN;
      DCL (MSB,LSB) FIXED;
      DCL TEMP(1)   FIXED;
		
		IF (MIDI.SYNC.IS.TC != 0)				/* IF MIDI SYNC OUT IS MIDI TIME CODE, PREP FOR	*/
		{												/* EMITTING QUARTER FRAME MESSAGES					*/
			PREP.FOR.MTC.OUTPUT(PLAY.TIME.MSB, PLAY.TIME.LSB, FALSE);
			NUM.MIDI.CLOCKS = 0;
			TIME.BASE.MODE=2;           		/* NOW WAITING FOR SMPTE BITS TO REACH TARGET */
		}
		
		ELSE
		{
			MSB = SAMPLED.ACTUAL.SEQUENCE.TIME.MSB;
			LSB = SAMPLED.ACTUAL.SEQUENCE.TIME.LSB;
		
			IF  (MSB=0)                       /* TAKING IT FROM THE TOP */
			AND (LSB ILE ZERO.TIME)
			THEN DO;
				DISABLE;
				TIME.BASE.MODE=2;              /* NOW WAITING FOR SMPTE BITS TO REACH TARGET */
				CALL SEND.MIDI.START;          /* ****** ENABLES INTERRUPTS.  SEND START */
			END;
			
			ELSE DO;
				IF CLICK.TRACK.MODE ile 3      /* INTERNAL OR EXTERNAL CLICK */
				THEN DO;
					TEMP(0)=0;                  /* LOAD 1 SEC INTO TEMP VAR   */
					TEMP(1)=1000;                  
					
					/* COMPUTE SEQUENCER DURATION OF 1 SECOND */
					CALL MAP.REAL.DURATION.TO.SEQUENCE.DURATION(LOC(ADDR(MSB)),TEMP,TEMP);
	
					CALL ADD32(LOC(ADDR(MSB)),TEMP,LOC(ADDR(MSB)));  /* ADD 1 SECOND OF SEQUENCE TIME */
	
					/* COMPUTE MIDI CLOCK >= 1 SECOND IN FRONT OF US */
					CALL COMPUTE.NEXT.MIDI.LIMIT(LOC(ADDR(MSB)),LOC(ADDR(MIDI.LIMIT.MSB)));
	
					CALL MAP.SEQUENCE.TIME.TO.REAL.TIME(LOC(ADDR(MIDI.LIMIT.MSB)),
																	LOC(ADDR(REAL.TIME.OF.MIDI.LIMIT.MSB)));
	
					MIDI.LIMIT.REM    =0;             /* RESET MIDI REMAINDER */
					NUM.MIDI.CLOCKS   =0;             /* RESET MIDI CLOCK COUNTER */
	
					CALL COMPUTE.REAL.MIDI.CLOCK.RATES(LOC(ADDR(MIDI.LIMIT.MSB)));
	
					CALL MIDI.SONG.POS.PTR(MIDI.LIMIT.MSB,MIDI.LIMIT.LSB);
					DISABLE;
					TIME.BASE.MODE=2;           /* NOW WAITING FOR SMPTE BITS TO REACH TARGET */
					CALL SEND.MIDI.CONTINUE;    /* ****** ENABLES INTERRUPTS.  SEND CONTINUE */
				END;
				ELSE DO;                       /* LIVE CLICK TRACK       */
					MSB = PLAY.TIME.MSB;        /* GET SEQUENCER POSITION */
					LSB = PLAY.TIME.LSB;
					LSB = LSB + 1000;           /* ADD 1 SECOND TO ALLOW TIME FOR OTHER UNIT TO RESPOND TO SONG POSITION POINTER */
					IF LSB ILT 1000 THEN MSB=MSB+1;
	
					/* COMPUTE REMAPPED TIME OF THIS SYNCLAVIER POSITION */
					/* SO WE CAN MEASURE NEAREST BEAT                    */
	
					CALL REMAP.WITH.LIVE.CLICK(MSB,LSB,0,0,1);
	
					LOAD  REMAPPED.TIME.LSB;    /* GET REMAPPED TIME.  DIVIDE BY */
					ULOAD REMAPPED.TIME.MSB;    /* 1000 TO GET A BEAT NUMBER     */
					DIV   1000;                 
					LOAD (RES+(REM<>0));        /* ROUND UP                  */
					MUL   1000;                 /* COMPUTE TIME OF NEXT BEAT */
					MSB = URES; LSB = RES;
					LSB=LSB+ZERO.TIME;          /* MUST ADD ZERO.TIME        */
					IF LSB ILT ZERO.TIME        /* NOW MSB AND LSB ARE ON    */
					THEN MSB=MSB+1;             /* A BEAT BOUNDARY           */
	
					/* NOW GET THE SYNCLAVIER TIME THAT EXACTLY CORRESPONDS */
					/* TO THIS BEAT:                                        */
	
					CALL REMAP.WITH.LIVE.CLICK(MSB,LSB,0,0,0);
	
					MIDI.LIMIT.LSB  =REMAPPED.TIME.LSB; /* MIDI CLOCK PULSES WILL GO OUT HERE */
					MIDI.LIMIT.REM  =0;
	
					CALL MIDI.SONG.POS.PTR(MSB,LSB);
					DISABLE;
					TIME.BASE.MODE=2;           /* NOW WAITING FOR SMPTE BITS TO REACH TARGET */
					CALL SEND.MIDI.CONTINUE;    /* ****** ENABLES INTERRUPTS.  SEND CONTINUE */
				END;
			END;
		}
   END;
   ELSE TIME.BASE.MODE=2;               /* NOW WAITING FOR SMPTE BITS TO REACH TARGET */

   CHECK.SMPTE.ERROR = 0;               /* RESET ERROR CHECK FLAG IF IN SYNC */

   NEW.SEQUENCER.FORWARD.MOTION = 1;    /* NEW FORWARD MOTION NOW */

	interpret_set_timebase_mode(TIME.BASE.MODE);			// Inform interpreter that timebase is moving
END LOCK.TO.SMPTE;

/* $PAGE - ROUTINE TO CHECK SMPTE SYNCHRONIZATION AFTER DROP OUT */

/* THIS ROUTINE IS CALLED WHEN WE ARE LOCKED TO SMPTE (SLOCKED <> 0) */

/* IT IS CALLED AFTER A DROP OUT HAS OCCURRED IN THE SMPTE SIGNAL (ALSO  */
/* WOULD HAPPEN IF A BREAK OCCURRED IN THE SMPTE SIGNAL                  */

/* THIS ROUTINE  MAKES SURE WE ARE STILL AT THE RIGHT PLACE IN           */
/* THE SEQUENCE                                                          */

CHECK.SMPTE.SYNCHRONIZATION:PROC PUBLIC SWAPABLE;
   DCL SEQ.START.SMPTE.BIT  (1)  FIXED;
   DCL CUR.SMPTE.BIT        (1)  FIXED;
   DCL TEMP                 (1)  FIXED;
   DCL N                         FIXED;
   DCL LOCAL.TIME                FIXED;


   /* CHECK FOR BIT=0,  BIT=79              */
   /* FIRMWARE BUG CAUSES SYNC ERROR HERE:  */

   IF (CUR.BIT=0)                   /* AVOID BIT=0  FIRMWARE BUG  */
   OR (CUR.BIT=79)                  /* AVOID BIT=79 FIRMWARE BUG  */
   THEN RETURN;                     /* WAIT                       */


   /* ALSO SKIP SYNC CHECK IF WE ARE COASTING: */

   IF (SAMPLED.INFO1 & SHL("200",8)) <> 0
   THEN RETURN;


   /* COMPUTE SMPTE BIT TIME FOR OUR         */
   /* STARTING TIME,  AND CURRENT TIME:      */

   CALL SMPTE.TO.SBITS(LOC(ADDR(SM.HRS)),  SM.MODE, SEQ.START.SMPTE.BIT);

   /* NOW CHECK FOR OPERATION NEAR MIDNIGHT */
   /* MAP CURRENT TIME TO > 24:00:00:00.00  */
   /* IF SO:                                */

   IF CUR.HRS < SM.HRS              /* IF INCOMING SMPTE IS LESS THAN THE STARTING OFFSET */
   THEN DO;
      CUR.HRS=CUR.HRS + 24;         /* WE'VE WRAPPED AROUND, SO MAP HOURS UP BY 24 */
      CALL SMPTE.TO.SBITS(LOC(ADDR(CUR.HRS)), SM.MODE, CUR.SMPTE.BIT);
      CUR.HRS=CUR.HRS - 24;         /* LEAVE CUR.HRS CORRECT */
   END;
   ELSE CALL SMPTE.TO.SBITS(LOC(ADDR(CUR.HRS)), SM.MODE, CUR.SMPTE.BIT);

   /* When syncing up, sync to next smpte frame, since we don't  */
   /* normally see the smpte frame until the END of the frame    */
   /* in question                                                */

   CALL ADD16(80, CUR.SMPTE.BIT);
   

   /* THE D70 BOARD PROVIDES SMPTE READINGS  */
   /* THAT ARE 1 BEHIND.   ADVANCE OUR       */
   /* CURRENT SMPTE TIME BY THE NUMBER OF    */
   /* BITS THAT GO BY BETWEEN READINGS SO    */
   /* WE KNOW EXACTLY WHERE WE ARE:          */
   
   CALL ADD16(SAMPLED.BRATE, CUR.SMPTE.BIT);

   
   /* COMPUTE HOW MANY BITS ARE IN ZERO.TIME. */
   /* ADD TO CURRENT READING TO LINE UP       */
   /* SMPTE START TIME WITH FIRST CLICK:      */

   CALL STR32(0, ZERO.TIME, BitMsbArray);

   CALL MULTIPLY(BITS.PER.MSEC.A(SM.MODE),BITS.PER.MSEC.B(SM.MODE),    /* GET SMPTE		*/
                 BITS.PER.MSEC.C(SM.MODE),BITS.PER.MSEC.D(SM.MODE));   /* SINCE START	*/

   CALL ratio_multiply(1000,SAMP.SPEED);

   CALL ADD32(CUR.SMPTE.BIT, BitMsbArray, CUR.SMPTE.BIT);


   /* SAMPLE CURRENT SEQUENCER TIME.  REMEMBER: SEQUENCER IS MOVING HERE,	*/
   /* WHEREAS IN LOCK.TO.SMPTE IT WAS NOT.  FIND OUT WHERE THINGS ARE		*/

   DISABLE;
   BITMSB     = PLAY.TIME.MSB; 
   BITLSB     = PLAY.TIME.LSB; 
   N          = PLAY.TIME.ACU;
   LOCAL.TIME = KBD.MILLISECONDS;
   ENABLE;

   /* ACCURATELY COMPUTE SMPTE BIT POSITION OF SEQUENCER: */

   CALL COMPUTE.SEQUENCER.SMPTE.BIT (BITMSB, BITLSB, N, TEMP, 0);


   /* ADD IN SMPTE START TIME TO SEQUENCER POSITION */
   /* TO GET ABSOLUTE SMPTE TIME WHERE SEQUENCER    */
   /* IS NOW SITTING:                               */

   CALL ADD32(SEQ.START.SMPTE.BIT, TEMP, TEMP);


   /* ADD TO CURRENT SMPTE BIT TIME THE # OF SMPTE BITS THAT HAVE */
   /* GONE BY SINCE WE SAMPLED SMPTE (DURING THIS TIME THE        */
   /* SEQUENCER HAS BEEN RUNNING)                                 */

   LOAD LOCAL.TIME - SAMPLED.TIME;      /* GET MSECS THAT HAVE PASSED SINCE LAST SAMPLING OF SMPTE  */
   MUL SAMPLED.BRATE; MWAIT; DIV 20;    /* PROJECT HOW MANY BITS HAVE GONE BY SINCE THEN            */
   N=RES;                               /* THIS MANY BITS HAVE GONE BY SINCE WE SAMPLED SMPTE       */
   IF REM>=10 THEN N=N+1;               /* ROUND                                                    */

   CALL ADD16(N, CUR.SMPTE.BIT);


   /* NOW COMPARE THE CURRENT SEQUENCER POSITION (TEMP)    */
   /* WITH OUR CURRENT SMPTE POSITION.        SEE IF       */
   /* WE ARE WITHIN SYNC                                   */

   IF COM32(TEMP, CUR.SMPTE.BIT) = LW#ILT
   THEN CALL SUB32(CUR.SMPTE.BIT, TEMP, TEMP);
   ELSE CALL SUB32(TEMP, CUR.SMPTE.BIT, TEMP);


   /* FLAG OUT OF SYNC IF WE ARE MORE THAN 30 BITS OFF     */

   IF COM16(30, TEMP) = LW#ILT
   THEN DO;
      CALL STOP.SEQUENCER;            /* (SMPTE MUST HAVE JUMPED BEHIND)   */
      RETURN;                       
   END;


   /* ELSE SMPTE SYNC IS OK: */

   CHECK.SMPTE.ERROR = 0;             /* RESET ERROR CHECK FLAG IF IN SYNC */


END CHECK.SMPTE.SYNCHRONIZATION;
