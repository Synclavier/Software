/*	:SYNRSOU:03-PRIM:041-MAPS  -  Routines to manage Sequencer Tempo Map	*//*Modified:1999/04/11 - TY  - None of the calls to "Normalize.Tempo.Map.Times" passed "true" as a parameter so						 I commented out the associated code for now.1999/03/31 - TY  - Moved variable and literal declarations from ":SYNRSOU:03-PRIM:042-METR" here						 to avoid hassles with forward declarations.1999/03/29 - TY  - Removed unused parameter "record#" from "Append.Sequencer.Tempo.Map.Record"1998/01/13 - CJ  - Provided support (limited) of minus time values1992/02/26 - PF  - Added support for block xfr of tempo/meter maps1991/04/01 - PF  - Added "all" argument to Normalize.Tempo.Map.Times to avoid unnecessary computations in some cases1991/03/14 - cj  - Kept click rate on tempo map creation1991/02/13 - CJ  - Added comments.  Checked for null tempo map everywhere.1991/02/01 - PF  - Save "Divisions" with sequence1990/11/06 - PF  - Fix first click bug (multiple clicks on beat 1)1990/11/06 - PF  - Add "Divisions" argument to Activate.Sequence.For.New.Map1990/10/14 - PF  - Add routine Normalize.Tempo.Map.Times to be called after any tempo changes1990/10/10 - PF  - Add Compute.Time.Of.Nearest.Tempos to define boundaries for VK panel display updates1990/10/10 - PF  - Add Create.Default.Tempo.Map1990/07/10 - PF  - Begin Meter Map implementation1989/10/09 - CJ  - Added Map.Real.Duration.To.Sequence.Duration and Map.Sequence.Duration.To.Real.Duration*//*	Description of NED Tempo Map:The tempo map is a data structure within the ABLE computer that isused to quickly map between delta-times and real times (in both directions).The data structure consists of 10-word records.  The data structure iscomputed in the MAC from information stored in the MIDI-file,and then loaded into the ABLE over the protocol.The conductor track in the MIDI-file contains N Set Tempo events (Nmay be zero!).  Each Set Tempo event defines the start of a temposegment.  There are N+1 tempo segments in a conductor track sincethere is a defined initial tempo segment starting at delta-time 0 andlasting until the first Set Tempo event.  The tempo during thisfirst segment is defined to be 500,000 microseconds per MIDIQuarter-note (the default MIDI tempo).  The last tempo segment startsat the last Set Tempo event and has no upper bound.Tempo segments have (by definition) three important features:	1) The tempo is constant over the length of the tempo segment,	2) The logical length of the tempo segment is an integer number		of delta-devisions,	3) The real time length of the tempo segment is an integer number		of real time units of 1/D microseconds, where D is the number		of delta-divisions in a MIDI Quarter-note.Tempo Map TerminologyEach tempo segment starts at a certain delta-time Td.  Td is computedby adding up (or accumulating) all the time deltas from the beginningof the sequence up to the corresponding Set Tempo event:					Td = SUM of all prior time deltasEach tempo segment starts at a certain real time Tr.  Tr is computedby adding up (or accumulating) the real time lengths of all priortempo segments in the conductor track:							x = Td					Tr = integral  T(x)							x = 0If T(x) is the tempo in microseconds/MIDI Quarter-note at delta-time x,then the units of this integration are in units of 1/D microseconds.A 64-bit variable will likely be required to accumulate the totallength of the sequence in this format.  This must be done to preserveabsolute long term accuracy of the sequence.The tempo map will require the starting real time of each temposegment expressed in milliseconds rounded to the nearest millisecond:					Trmsec = Tr/(D*1000)Two ratios must be computed and stored in the tempo map datastructure.  These ratios are expressed to 48-bit accuracy, with16-bits to the left of the decimal point and 32-bits to the rightof the decimal point.  The two ratios are as follows:					Rm/d = T/(1000*D) = milliseconds per delta-divisionAnd				Rd/m = (1000*D)/T = delta-divisions per millisecondwhere T is the tempo (in microseconds per MIDI Quarter-note) for thissegment, and D is the number of delta-divisions per MIDI Quarter-notedefined in the header chunk.Tempo Map FormatThere is one 10-word record in the tempo map for every tempo segment.The format of each record is as follows:				( Td		msb	16-bits)				( Td		lsb	16-bits)				( Trmsec	msb	16-bits)				( Trmsec	lsb	16-bits)				( Rm/d	msb	16-bits)				( Rm/d	lsb	16-bits)				( Rm/d	llsb	16-bits)				( Rd/m	msb	16-bits)				( Rd/m	lsb	16-bits)				( Rd/m	llsb	16-bits)	*//*	$page - storage of tempo map data structure in the NED sequence.			*//*	Tempo.Map.Ptr points to an absolute sector of external memory.  This		*//*	sector is one of the blocks that is linked on to the first Seq.Map.Ptrs	*//*	list of blocks.																			*//*	Note that Tempo.Map.Ptr is not necessarily the first block of the tempo	*//*	map.  It is merely the current working area of the tempo map that is		*//*	of interest to us now.																	*//*	Literals for sector of tempo map information:									*/dcl Tempo.Map.For			lit 'NLS.FOR';	/*	0: forward pointer to next blk	*/dcl Tempo.Map.Rev			lit 'NLS.REV';	/*	1: reverse pointer to past blk	*/dcl Tempo.Map.Trk			lit 'NLS.TRK';	/*	2: trk# (for garbage collect routines)	*/dcl Tempo.Map.FP			lit 'NLS.FP ';	/*	3: pointer to first record			*/dcl Tempo.Map.LP			lit 'NLS.LP ';	/*	4: pointer to end of records		*/dcl Tempo.Map.Rec#.Msb	lit '      5';	/*	5: holds msb & lsb of record#		*/dcl Tempo.Map.Rec#.Lsb	lit '      6';	/*	6: of first record in this nls	*/dcl Tempo.Map.First		lit ' 10';	/*	start first segment in NLS block		*/dcl Tempo.Map.Last		lit '250';	/*	up through word 249						*//*	NOTE: words 250,251,252,253 of a Tempo Map block MUST contain the			*//*	tempo.map.seq.msb - tempo.map.real.lsb of the next segment.  These		*//*	words must contain -1,-1,-1,-1 if there is no further segment.				*/////	The previous statement is misleading.  It is actually the four words// starting at Tempo.Map.Len which contain this information./*	The tempo map itself consists of 10 word records.								*/dcl Tempo.Map.Seq.Msb	lit ' 0';	/*	Sequence time (delta-time)				*/dcl Tempo.Map.Real.Msb	lit ' 2';	/*	Corresponding real time					*/dcl Tempo.Map.Rms.d		lit ' 4';	/*	milliseconds per delta time			*/dcl Tempo.Map.Rd.ms		lit ' 7';	/*	delta time per millisecond				*/dcl Tempo.Map.Rec.len	lit '10';/*	NOTE: Tempo.Map.Cur points to the current entry of the current block		*//*	of the tempo map.  If Tempo.Map.Cur = 0, it actually means it should		*//*	be pointing to the last entry in the prior block (so set up pointers		*//*	to it.)																						*//*	IE the normal range for Tempo.Map.Cur is from Tempo.Map.First to			*//*	Tempo.Map.Len - Tempo.Map.Rec.Len.													*//*	Tempo.Map.Cur is the word offset (in the current block) of the block		*//*	that is in use at the current time.													*/dcl Tempo.Map.Len	fixed;	/*	end of tempo map info in current sector		*/dcl Tempo.Map.Cur	fixed;	/*	word pointer to current word						*//*	The following variables hold working copies of the Sequence and Real		*//*	times of the current (and following) record of the Tempo Map.  This is	*//*	done to speed up the tempo segment searching.									*/dcl Tempo.Map.This.Seq.Msb		fixed;	/*	holds convenient copy of real		*/dcl Tempo.Map.This.Seq.Lsb		fixed;	/*	and sequence time of this			*/dcl Tempo.Map.This.Real.Msb	fixed;	/*	tempo segment to speed up			*/dcl Tempo.Map.This.Real.Lsb	fixed;	/*	map search								*/dcl Tempo.Map.Next.Seq.Msb		fixed;	/*	holds convenient copy of real		*/dcl Tempo.Map.Next.Seq.Lsb		fixed;	/*	and sequence time of NEXT			*/dcl Tempo.Map.Next.Real.Msb	fixed;	/*	tempo segment to speed up			*/dcl Tempo.Map.Next.Real.Lsb	fixed;	/*	map search								*//*	Assembly language literals for Tempo Map routine	*/dcl a0		lit '"300"';dcl a1		lit '"301"';dcl a2		lit '"302"';dcl a3		lit '"303"';dcl add0		lit '"210"';	/*	add 0					*/dcl add1		lit '"211"';	/*	add 1					*/dcl add2		lit '"212"';	/*	add 2					*/dcl add3		lit '"213"';	/*	add 3					*/dcl addc0	lit '"270"';	/*	add with carry 0	*/dcl addc2	lit '"272"';	/*	add with carry 2	*/dcl sub2		lit '"216"';	/*	sub 2					*/dcl sub3		lit '"217"';	/*	sub 3					*/dcl subb2	lit '"276"';	/*	subb 2				*/dcl tloa2	lit '"242"';	/*	test load 2			*/dcl rtpl		lit '"337"';	/*	tra if >= 0			*//*	storage of meter map data structure in the NED sequence.						*//*	Meter.Map.Ptr points to an absolute sector of external memory.  This		*//*	sector is one of the blocks that is linked on to the Seq.Map.Ptrs			*//*	list of blocks.																			*//*	Note that Meter.Map.Ptr is not necessarily the first block of the meter	*//*	map.  It is merely the current working area of the meter map that is		*//*	of interest to us now.																	*//*	Literals for sector of meter map information:									*/dcl Meter.Map.For			lit 'NLS.FOR';	/*	0: forward pointer to next blk	*/dcl Meter.Map.Rev			lit 'NLS.REV';	/*	1: reverse pointer to past blk	*/dcl Meter.Map.Trk			lit 'NLS.TRK';	/*	2: trk# (for garbage collect routines)	*/dcl Meter.Map.FP			lit 'NLS.FP ';	/*	3: pointer to first record			*/dcl Meter.Map.LP			lit 'NLS.LP ';	/*	4: pointer to end of records		*/dcl Meter.Map.Rec#.Msb	lit '      5';	/*	5: holds record # of first			*/dcl Meter.Map.Rec#.Lsb	lit '      6';	/*	6: record in this nls				*/dcl Meter.Map.First		lit ' 10';	/*	start first segment in NLS block		*/dcl Meter.Map.Last		lit '234';	/*	up through word 233						*//*	NOTE: words 234 thru 239 of a Meter Map block MUST contain the				*//*	seq time, measure #, and beat # of the next segment.  These					*//*	words must contain -1 if there is no further segment.							*/////	The previous statement is misleading.  It is actually the six words//	starting at Meter.Map.Len which contain this information./*	The meter map itself consists of 28 word records.								*/dcl Meter.Map.Seq.Msb		lit ' 0';	/*	Sequence time (delta-time)			*/dcl Meter.Map.Measure#.Msb	lit ' 2';	/*	32 bit measure number				*/dcl Meter.Map.Beat#.Msb		lit ' 4';	/*	32 bit beat number					*/dcl Meter.Map.Rc.d			lit ' 6';	/*	clicks per delta-division			*/dcl Meter.Map.Rd.c			lit ' 9';	/*	delta-divisions per click			*/dcl Meter.Map.Rm.d			lit '12';	/*	measures per delta-division		*/dcl Meter.Map.Rd.m			lit '15';	/*	delta-divisions per measure		*/dcl Meter.Map.Rb.d			lit '18';	/*	beats per delta-division			*/dcl Meter.Map.Rd.b			lit '21';	/*	delta-divisions per beat			*/dcl Meter.Map.nn				lit '24';	/*	numerator								*/dcl Meter.Map.dd				lit '25';	/*	denominator (negative power of 2)	*/dcl Meter.Map.cc				lit '26';	/*	midi clocks per click				*/dcl Meter.Map.bb				lit '27';	/*	32nd notes per displayed beat		*/dcl Meter.Map.Rec.len		lit '28';/*	NOTE: Meter.Map.Cur points to the current entry of the current block		*//*	of the meter map.  If Meter.Map.Cur = 0, it actually means it should		*//*	be pointing to the last entry in the prior block (so set up pointers		*//*	to it.)																						*//*	IE the normal range for Meter.Map.Cur is from Meter.Map.First to			*//*	Meter.Map.Len - Meter.Map.Rec.Len.													*//*	Meter.Map.Cur is the word offset (in the current block) of the block		*//*	that is in use at the current time.													*/dcl Meter.Map.Len	fixed;	/*	end of meter map info in current sector		*/dcl Meter.Map.Cur	fixed;	/*	word pointer to current word						*//*	The following variables hold working copies of the Sequence time,			*//*	Measure #, and Beat #  of the current (and following) record of the		*//*	Meter Map.  This is done to speed up the meter segment search.				*/dcl Meter.Map.This.Seq.Msb			fixed;	/*	holds convenient copies of start	*/dcl Meter.Map.This.Seq.Lsb			fixed;	/*	times of this meter segment		*/dcl Meter.Map.This.Measure.Msb	fixed;dcl Meter.Map.This.Measure.Lsb	fixed;dcl Meter.Map.This.Beat.Msb		fixed;dcl Meter.Map.This.Beat.Lsb		fixed;dcl Meter.Map.Next.Seq.Msb			fixed;	/*	holds convenient copies of start	*/dcl Meter.Map.Next.Seq.Lsb			fixed;	/*	times of NEXT meter semgment		*/dcl Meter.Map.Next.Measure.Msb	fixed;dcl Meter.Map.Next.Measure.Lsb	fixed;dcl Meter.Map.Next.Beat.Msb		fixed;dcl Meter.Map.Next.Beat.Lsb		fixed;/*	$page Routine to normalize current pointer to segment map	*//*	This routine is called whenever the contents of the	*//*	map has changed.  It sets up some global					*//*	variables that identify the current segment so			*//*	the search for the correct segment is sped up.			*/Normalize.Tempo.Map.Cur: proc;	/*	procedure to provide infinite limits:	*/	Zap.Tempo.Limits: proc;		Tempo.Map.This.Seq.Msb	= 0;		Tempo.Map.This.Seq.Lsb	= 0;		Tempo.Map.This.Real.Msb	= 0;		Tempo.Map.This.Real.Lsb	= 0;		Tempo.Map.Next.Seq.Msb	= -1;		Tempo.Map.Next.Seq.Lsb	= -1;		Tempo.Map.Next.Real.Msb	= -1;		Tempo.Map.Next.Real.Lsb	= -1;		Tempo.Map.Cur = 0;	/*	no current pointer	*/		Tempo.Map.Len = 0;	/*	no tempo map length	*/	end Zap.Tempo.Limits;	/*	If the tempo map is empty, set current pointer to zero and mark	*/	/*	limits as from 0 to infinity:													*/	if (Tempo.Map.Ptr = 0)		/*	if no sector allocated						*/	then do;							/*	then no tempo map is present				*/		call Zap.Tempo.Limits;	/*	set up infinite limits, clear out		*/		return;						/*	cur & len info.								*/	end;	/*	back tempo map pointer up to prior block if we need to:				*/	do while Tempo.Map.Cur < Tempo.Map.First;		write(mam) = Tempo.Map.Ptr;		write(mal) = Tempo.Map.REV;		/*	if no prior block, indicates a serious error of some sort:		*/		if read(md) = 0		then do;			call Zap.Tempo.Limits;	/*	set up infinite limits, clear out	*/			return;						/*	cur & len info.							*/		end;		Tempo.Map.Ptr = NAH.PTR + read(md);	/*	compute absolute pointer	*/		write(mam) = Tempo.Map.Ptr;			/*	access prior block			*/		write(mal) = Tempo.Map.LP;				/*	get ending pointer			*/		Tempo.Map.Len = read(md);				/*	save in global					*/		Tempo.Map.Cur = Tempo.Map.Len - Tempo.Map.Rec.Len;	end;	/*	Now skip to next tempo map block if we are at the end of this		*/	/*	block:																				*/	do while Tempo.Map.Cur >= Tempo.Map.Len;		write(mam) = Tempo.Map.Ptr;	/*	point ahead to next linked block	*/		write(mal) = Tempo.Map.FOR;		/*	if no next block, indicates a serious error of some sort:		*/		if read(md) = 0		then do;			call Zap.Tempo.Limits;	/*	set up infinite limits, clear out	*/			return;						/*	cur & len info.							*/		end;		Tempo.Map.Ptr = NAH.PTR + read(md);	/*	compute absolute pointer	*/		write(mam) = Tempo.Map.Ptr;			/*	access next block				*/		write(mal) = Tempo.Map.FP;				/*	get pointer to start			*/		Tempo.Map.Cur = read(mdi);				/*	should be Tempo.Map.First	*/		Tempo.Map.Len = read(md);				/*	get ending pointer too.		*/	end;	/*	Now look up starting and ending values to have handy:	*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur;	Tempo.Map.This.Seq.Msb	= read(mdi);	Tempo.Map.This.Seq.Lsb	= read(mdi);	Tempo.Map.This.Real.Msb	= read(mdi);	Tempo.Map.This.Real.Lsb	= read(mdi);	write(mal) = Tempo.Map.Cur + Tempo.Map.Rec.Len;	Tempo.Map.Next.Seq.Msb	= read(mdi);	Tempo.Map.Next.Seq.Lsb	= read(mdi);	Tempo.Map.Next.Real.Msb	= read(mdi);	Tempo.Map.Next.Real.Lsb	= read(mdi);end Normalize.Tempo.Map.Cur;/*	Routine to recompute all segment start real times.	*//*	The following routine goes through the entire tempo map and		*//*	recomputes the real time of the start of each tempo segment.	*//*	This routine is called whenever the tempo of a segment is		*//*	changed from within the RTP.  It is basically a version of		*//*	map sequence time to real time.											*/Normalize.Tempo.Map.Times: proc public swapable;	dcl (x,y) fixed static;	if Tempo.Map.Ptr = 0		/*	if no tempo map	*/	then return;				/*	nothing to do	*/	#if (false)	// No-one uses this so remove from compilation for now. -TY 1999/04/11		if all					/*	if caller wants all times recalculated	*/		then do;					/*	then back up to Record 0 of Tempo Map	*/			write(mam) = Tempo.Map.Ptr;			write(mal) = Tempo.Map.REV;			do while read(md)<>0;				Tempo.Map.Ptr = NAH.PTR + read(md);				write(mam) = Tempo.Map.Ptr;				write(mal) = Tempo.Map.REV;			end;			write(mal) = Tempo.Map.FP;			Tempo.Map.Cur = read(mdi);	/*	get pointer to start				*/			Tempo.Map.Len = read(md );	/*	must get ending pointer too	*/		end;	#endif	call Normalize.Tempo.Map.Cur;		/*	now step thru each record from here to the end and compute real times	*/	do while	(Tempo.Map.Next.Seq.Msb <> (-1))	or			(Tempo.Map.Next.Seq.Lsb <> (-1));		write(mam) = Tempo.Map.Ptr;		write(mal) = Tempo.Map.Cur;		/*	Compute length of this tempo segment in sequencer deltas	*/		write(a2) = Tempo.Map.Next.Seq.Msb;	/*	get sequencer time of next segment	*/		write(a3) = Tempo.Map.Next.Seq.Lsb;		write(sub2) = read(mdi);		/*	subtract sequencer time of this segment	*/		write(sub3) = read(mdi);		write(subb2) = 0;					/*	propagate borrow						*/		write(a0) = read(mdi);			/*	initialize real time accumulator	*/		write(a1) = read(mdi);		load read(a2); mul read(md );	/*	compute msb*r1							*/			write(add0 ) = res;			/*	add to msb								*/		load read(a3); mul read(mdi);	/*	compute lsb*r1							*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a2); mul read(md );	/*	compute msb*r2							*/			x				 = read(mdi);	/*	stash r2 while mul/div is busy	*/			write(add1 ) = res;			/*	add to lsb								*/			write(addc0) = ures;			/*	add to msb								*/		load read(a3); mul read(md );	/*	compute lsb*r3 for rounding		*/			y = ures;						/*	save upper only (as new llsb)		*/		load read(a3); uload y;			/*	get lsb & rounding amount			*/			mul x;							/*	compute lsb*r2 + 1/2					*/			write(add1)	 = ures;			/*	add to lsb								*/			y				 = res;			/*	save llsb								*/		load read(a2); uload y;			/*	load msb, preserve prior llsb		*/			mul read(md);					/*	compute msb*r3 + prior llsb		*/			write(addc0) = 0;				/*	add PREVIOUS carry only to msb	*/												/*	while multiply is going on !!		*/			write(add1)	 = ures;			/*	add to lsb								*/			write(addc0) = 0;				/*	add carry only to msb				*/		/*	through with r2 - check for rounding									*/		write(tloa2) = res;				/*	test result in a2; check sign		*/		write(rtpl ) = 2;					/*	if >=0, no rounding needed			*/		write(add1 ) = 1;					/*	round by 1 msec						*/		write(addc0) = 0;					/*	propagate carry						*/		x = read(a0);		/*	move to static variables to avoid glomming	*/		y = read(a1);		/*	first write new value over Tempo.Map.Next.Real.Msb/Lsb	*/		/*	in case we are about to jump sectors							*/		write(mal) = Tempo.Map.Cur + Tempo.Map.Rec.Len + Tempo.Map.Real.Msb;		write(mdi) = x;		write(md ) = y;		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;		write(mam) = Tempo.Map.Ptr;		write(mal) = Tempo.Map.Cur + Tempo.Map.Real.Msb;		write(mdi) = x;		write(md ) = y;	end;end Normalize.Tempo.Map.Times;/*	$page Routine to map Sequence Time to Real Time	*/Map.Sequence.Time.To.Real.Time: proc(Seq.Time, Real.Time) public;	dcl Seq.Time  array;		/*	32-bit millisecond sequence time			*/	dcl Real.Time array;		/*	returns 32-bit millisecond real time	*/	dcl sign		fixed;	dcl (x,y) fixed static;	x = Seq.Time(0);			/*	get sequence time handy in statics		*/	y = Seq.Time(1);	if Tempo.Map.Ptr = 0		/*	if no tempo map, then seq time			*/	then do;						/*	and real time are the same.				*/		Real.Time(0) = x;		Real.Time(1) = y;		return;	end;	/*	Handle minus sequence times	*/	if (x < 0)					/*	minus - use tempo from first segment	*/	{		do while	((0			ILT Tempo.Map.This.Seq.Msb))	/*	back up if we are	*/		or			((0			=	 Tempo.Map.This.Seq.Msb)	/*	before start of	*/		and		 (zero.time ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.		*/			Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;		sign = (-1);			/*	indicate minus value	*/		if (y == 0)				/*	negate sequence time	*/			x = -x;		else			{x = ~x; y = -y;}	}	/*	Find the tempo segment that contains this delta time.			*/	else	{		do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/		or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/		and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/			Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;		do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/		or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/		and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/		and		 (x <>  (-1)						));	/*	infinite loop).		*/			Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;		sign = (+1);	}	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur;	/*	Compute delta time from start of this tempo segment to the		*/	/*	passed sequencer time.  Store in ac2-ac3:								*/	write(a2) = x;		/*	get passed sequence time in ac2-ac3				*/	write(a3) = y;		/*	as a 32-bit number									*/	write(sub2) = read(mdi);	/*	subtract msb from passed seq time	*/	write(sub3) = read(mdi);	write(subb2) = 0;				/*	propagate borrow							*/	write(a0) = read(mdi);		/*	initialize real time accumulator		*/	write(a1) = read(mdi);	load read(a2); mul read(md );	/*	compute msb*r1							*/		write(add0 ) = res;			/*	add to msb								*/	load read(a3); mul read(mdi);	/*	compute lsb*r1							*/		write(add1 ) = res;			/*	add to lsb								*/		write(addc0) = ures;			/*	add to msb								*/	load read(a2); mul read(md );	/*	compute msb*r2							*/		x				 = read(mdi);	/*	stash r2 while mul/div is busy	*/		write(add1 ) = res;			/*	add to lsb								*/		write(addc0) = ures;			/*	add to msb								*/	load read(a3); mul read(md );	/*	compute lsb*r3 for rounding		*/		y = ures;						/*	save upper only (as new llsb)		*/	load read(a3); uload y;			/*	get lsb & rounding amount			*/		mul x;							/*	compute lsb*r2 + 1/2					*/		write(add1)	 = ures;			/*	add to lsb								*/		y				 = res;			/*	save llsb								*/	load read(a2); uload y;			/*	load msb, preserve prior llsb		*/		mul read(md);					/*	compute msb*r3 + prior llsb		*/		write(addc0) = 0;				/*	add PREVIOUS carry only to msb	*/											/*	while multiply is going on !!		*/		write(add1)	 = ures;			/*	add to lsb								*/		write(addc0) = 0;				/*	add carry only to msb				*/	/*	through with r2 - check for rounding									*/	write(tloa2) = res;				/*	test result in a2; check sign		*/	write(rtpl ) = 2;					/*	if >=0, no rounding needed			*/	write(add1 ) = 1;					/*	round by 1 msec						*/	write(addc0) = 0;					/*	propagate carry						*/	x = read(a0);		/*	move to static variables to avoid glomming	*/	y = read(a1);		/*	registers with subscript computations			*/	if (sign < 0)	{		if (y == 0)		/*	negate real time										*/			x = -x;		else			{x = ~x; y = -y;}	}	Real.Time(0) = x;	Real.Time(1) = y;end Map.Sequence.Time.To.Real.Time;/*	Similar routine for durations:												*/Map.Sequence.Duration.To.Real.Duration: proc(Seq.Time, Seq.Dur, Real.Dur) public swapable;	dcl Seq.Time	array;	/*	sequencer time of event in question		*/	dcl Seq.Dur		array;	/*	sequencer duration of event				*/	dcl Real.Dur	array;	/*	returns real duration in msec				*/	dcl starttime(1)	fixed;	dcl endtime  (1)	fixed;	call Map.Sequence.Time.To.Real.Time(Seq.Time, starttime);	/*	get real start	time	*/	call ADD32(Seq.Time, Seq.Dur, endtime);							/*	get seq  end	time	*/	call Map.Sequence.Time.To.Real.Time(endtime, endtime);		/*	get real end	time	*/	call SUB32(endtime, starttime, Real.Dur);							/*	get real duration		*/end Map.Sequence.Duration.To.Real.Duration;/*	Routine to map Real Time to Sequence Time	*/Map.Real.Time.To.Sequence.Time: proc(Real.Time, Seq.Time) public;	dcl Real.Time array;		/*	32-bit millisecond real time					*/	dcl Seq.Time  array;		/*	returns 32-bit millisecond sequence time	*/	dcl sign	fixed;	dcl (x,y) fixed static;	x = Real.Time(0);			/*	get real time handy in statics	*/	y = Real.Time(1);	if Tempo.Map.Ptr = 0		/*	if no tempo map, then real time	*/	then do;						/*	and seq time are the same.			*/		Seq.Time(0) = x;		Seq.Time(1) = y;		return;	end;	/*	Find the tempo segment that contains this delta time.		*/	/*	Handle minus real times	*/	if (x < 0)					/*	minus - use tempo from first segment	*/	{		do while	((0			ILT Tempo.Map.This.Real.Msb))		/*	back up if we are	*/		or			((0			=	 Tempo.Map.This.Real.Msb)		/*	before start of	*/		and		 (zero.time	ILT Tempo.Map.This.Real.Lsb));	/*	this segment.		*/			Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;		sign = (-1);			/*	indicate minus value	*/		if (y == 0)				/*	negate sequence time	*/			x = -x;		else			{x = ~x; y = -y;}	}	else	{		do while	((x ILT Tempo.Map.This.Real.Msb))	/*	back up if we are		*/		or			((x =   Tempo.Map.This.Real.Msb)		/*	before start of		*/		and		 (y ILT Tempo.Map.This.Real.Lsb));	/*	this segment.			*/			Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;		do while	((x IGT Tempo.Map.Next.Real.Msb))	/*	skip ahead if we are	*/		or			((x =   Tempo.Map.Next.Real.Msb)		/*	after end of this		*/		and		 (y IGE Tempo.Map.Next.Real.Lsb)		/*	segment (check for	*/		and		 (x <>  (-1)						 ));	/*	infinite loop).		*/			Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;		end;	}	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Cur;	/*	Compute delta time from start of this tempo segment to the		*/	/*	passed sequencer time.  Store in ac2-ac3:								*/	write(a2) = x;					/*	get passed sequence time in ac2-ac3	*/	write(a3) = y;					/*	as a 32-bit number						*/	write(a0) = read(mdi);		/*	initialize seq time accumulator		*/	write(a1) = read(mdi);	write(sub2) = read(mdi);	/*	subtract msb from passed real time	*/	write(sub3) = read(mdi);	write(subb2) = 0;				/*	propagate borrow							*/	rpc (Tempo.Map.Rd.ms - Tempo.Map.Rms.d);	/*	skip to delta/msec	*/	write(atnv) = read(mdi);						/*	ratio						*/	load read(a2); mul read(md );	/*	compute msb*r1							*/		write(add0 ) = res;			/*	add to msb								*/	load read(a3); mul read(mdi);	/*	compute lsb*r1							*/		write(add1 ) = res;			/*	add to lsb								*/		write(addc0) = ures;			/*	add to msb								*/	load read(a2); mul read(md );	/*	compute msb*r2							*/		x				 = read(mdi);	/*	stash r2 while mul/div is busy	*/		write(add1 ) = res;			/*	add to lsb								*/		write(addc0) = ures;			/*	add to msb								*/	load read(a3); mul read(md );	/*	compute lsb*r3 for rounding		*/		y = ures;						/*	save upper only (as new llsb)		*/	load read(a3); uload y;			/*	get lsb & rounding amount			*/		mul x;							/*	compute lsb*r2 + 1/2					*/		write(add1)	 = ures;			/*	add to lsb								*/		y				 = res;			/*	save llsb								*/	load read(a2); uload y;			/*	load msb, preserve prior llsb		*/		mul read(md);					/*	compute msb*r3 + prior llsb		*/		write(addc0) = 0;				/*	add PREVIOUS carry only to msb	*/											/*	while multiply is going on !!		*/		write(add1)	 = ures;			/*	add to lsb								*/		write(addc0) = 0;				/*	add carry only to msb				*/	/*	through with r2 - check for rounding									*/	write(tloa2) = res;				/*	test result in a2; check sign		*/	write(rtpl ) = 2;					/*	if >=0, no rounding needed			*/	write(add1 ) = 1;					/*	round by 1 msec						*/	write(addc0) = 0;					/*	propagate carry						*/	x = read(a0);		/*	move to static variables to avoid glomming	*/	y = read(a1);		/*	registers with subscript computations			*/	if (sign < 0)	{		if (y == 0)						/*	negate sequnce time					*/			x = -x;		else			{x = ~x; y = -y;}	}	Seq.Time(0) = x;	Seq.Time(1) = y;end Map.Real.Time.To.Sequence.Time;/*	Similar routine for durations:												*/Map.Real.Duration.To.Sequence.Duration: proc(Seq.Time, Real.Dur, Seq.Dur) public swapable;	dcl Seq.Time	array;	/*	sequencer time of event in question		*/	dcl Real.Dur	array;	/*	real duration in msec						*/	dcl Seq.Dur		array;	/*	returns sequencer duration of event		*/	dcl starttime(1)	fixed;	dcl endtime  (1)	fixed;	call Map.Sequence.Time.To.Real.Time(Seq.Time, starttime);	/*	get real start	time	*/	call ADD32(starttime, Real.Dur, endtime);							/*	get real end	time	*/	call Map.Real.Time.To.Sequence.Time(endtime, endtime);		/*	get seq  end	time	*/	call SUB32(endtime, Seq.Time, Seq.Dur);							/*	get seq  duration		*/end Map.Real.Duration.To.Sequence.Duration;Compute.Real.Midi.Clock.Rates: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl (x,y)	fixed;	dcl temp(1)	fixed;	dcl real(1)	fixed;	temp(0)=0;												/*	compute midi clock rate in sequencer deltas	*/																/*	and store in "temp"	*/	load Divisions;	div  24;	temp(1)=res;	if Tempo.Map.Ptr=0									/*	if no tempo map, set up defaults			*/	then do;		Real.Midi.Clock.Rate=temp(1);					/*	real midi clock rate = seq clock rate	*/		Real.Time.Of.Next.Tempo.Msb=(-1);			/*	zap time of next change	*/		Real.Time.Of.Next.Tempo.Lsb=(-1);		Next.Midi.Clock.Rate=Real.Midi.Clock.Rate;	/*	next rate same as the first	*/		return;	end;	call Map.Sequence.Duration.To.Real.Duration(Seq.Time,temp,real);	Real.Midi.Clock.Rate=real(1);						/*	get real rate from lsb of duration	*/	/*	now normalize the tempo map for the passed sequence time	*/	x = Seq.Time(0);										/*	get sequence time handy	*/	y = Seq.Time(1);	/*	Find the tempo segment that contains this delta time.			*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	Real.Time.Of.Next.Tempo.Msb = Tempo.Map.Next.Real.Msb;	/*	get the real time of next tempo record	*/	Real.Time.Of.Next.Tempo.Lsb = Tempo.Map.Next.Real.Lsb;	if  (Real.Time.Of.Next.Tempo.Msb = (-1))	and (Real.Time.Of.Next.Tempo.Lsb = (-1))	then Next.Midi.Clock.Rate = Real.Midi.Clock.Rate;	else do;		x = Tempo.Map.Next.Seq.Msb;		y = Tempo.Map.Next.Seq.Lsb;		call Map.Sequence.Duration.To.Real.Duration(loc(addr(x)),temp,real);		Next.Midi.Clock.Rate=real(1);	/*	get next clock rate from lsb of duration	*/	end;end Compute.Real.Midi.Clock.Rates;Compute.Real.Clock.Rates: proc (Seq.Time) public swapable;	dcl Seq.Time array;	dcl (x,y)	fixed;	dcl temp(1)	fixed;	dcl real(1)	fixed;	temp(0)=0;												/*	compute external clock rate in sequencer deltas	*/																/*	and store in "temp"	*/	load Divisions;	div  samp.ext.div;	temp(1)=res;	if Tempo.Map.Ptr=0									/*	if no tempo map, set up defaults		*/	then do;		Real.Clock.Rate=temp(1);						/*	real clock rate = seq clock rate		*/		Real.Time.Of.Next.Tempo.Msb=(-1);			/*	zap time of next change	*/		Real.Time.Of.Next.Tempo.Lsb=(-1);		Next.Clock.Rate=Real.Clock.Rate;				/*	next rate same as the first	*/		return;	end;	call Map.Sequence.Duration.To.Real.Duration(Seq.Time,temp,real);	Real.Clock.Rate=real(1);							/*	get real rate from lsb of duration	*/	/*	now normalize the tempo map for the passed sequence time	*/	x = Seq.Time(0);										/*	get sequence time handy	*/	y = Seq.Time(1);	/*	Find the tempo segment that contains this delta time.			*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	Real.Time.Of.Next.Tempo.Msb = Tempo.Map.Next.Real.Msb;	/*	get the real time of next tempo record	*/	Real.Time.Of.Next.Tempo.Lsb = Tempo.Map.Next.Real.Lsb;	if  (Real.Time.Of.Next.Tempo.Msb = (-1))	and (Real.Time.Of.Next.Tempo.Lsb = (-1))	then Next.Clock.Rate = Real.Clock.Rate;	else do;		x = Tempo.Map.Next.Seq.Msb;		y = Tempo.Map.Next.Seq.Lsb;		call Map.Sequence.Duration.To.Real.Duration(loc(addr(x)),temp,real);		Next.Clock.Rate=real(1);	/*	get next clock rate from lsb of duration	*/	end;end Compute.Real.Clock.Rates;/*	Routine to compute sequence time of next tempo change	*/Compute.Time.Of.Nearest.Tempos: proc (Seq.Time,Prior.Tempo,Next.Tempo) public swapable;	dcl Seq.Time	 array;	dcl Prior.Tempo array;	dcl Next.Tempo  array;	dcl (x,y)	fixed;	if Tempo.Map.Ptr = 0	then do;		Prior.Tempo(0) = Tempo.Map.This.Seq.Msb;		Prior.Tempo(1) = Tempo.Map.This.Seq.Lsb;		Next.Tempo (0) = Tempo.Map.Next.Seq.Msb;		Next.Tempo (1) = Tempo.Map.Next.Seq.Lsb;		return;	end;	x = Seq.Time(0);										/*	get sequence time handy	*/	y = Seq.Time(1);	/*	Find the tempo segment that contains this delta time.			*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	Prior.Tempo(0) = Tempo.Map.This.Seq.Msb;	Prior.Tempo(1) = Tempo.Map.This.Seq.Lsb;	Next.Tempo(0) = Tempo.Map.Next.Seq.Msb;	Next.Tempo(1) = Tempo.Map.Next.Seq.Lsb;end Compute.Time.Of.Nearest.Tempos;/*	Routine to allocate an NLS block for map data storage:					*//*	Note: this routine is used to both allocate storage for the				*//*	tempo/meter map, and to allocate storage blocks for the group list	*//*	and auxinfo areas of a track head.												*//*	The tempo map & meter map are a list of blocks that start at the		*//*	base sector and can be any length.  The grouplists and auxinfo list	*//*	start at a track head and are (typically?) only one block long.		*//*	Encoding: if map# == 0 or 1, we are allocating a tempo or meter		*//*	map block which may be the first one (e.g. reverse == 0) or a			*//*	continuation (reverse != 0).  If we are allocating a group list		*//*	or aux info block, the map# will be the actual pointer to the track	*//*	head where the pointer is stored (e.g. THD.GROUPLIST, THD.AUXINFO,	*//*	etc.																						*//*	NOTE: when allocating storage for the THD.GROUPLIST or aux info		*//*	areas, the caller must set up the pointer in the appropriate track	*//*	head to point to the allocated block.  Also, the track# itself			*//*	must still be stored in the lower of THD.TRK									*/Allocate.Map.Block: proc(forward, reverse, map#) PUBLIC;	dcl forward	fixed;	/*	pass forward pointer to set up	*/	dcl reverse	fixed;	/*	pass reverse poitner to set up	*/	dcl map#		fixed;	/*	pass map # code for bas.ptr area	*/	dcl i			fixed;	i = ALLOCATE.NAH.BLOCK;		/*	get block from nah area.			*/	if i = 0							/*	out of room for tempo map.			*/	then return 0;	write(mam) = NAH.PTR + i;	/*	initialize block to all zeroes	*/	rpc 256;							/*	for consistency.						*/	write(mdi) = 0;	write(mam) = NAH.PTR + i;	/*	access block.  set up basic		*/	write(mdi) = forward;		/*	NLS.FOR, NLS.REV, NLS.TRK			*/	write(mdi) = reverse;		/*	for garbage collect routines.		*/	if (map# ilt #.OF.MAP.PTRS)		write(mdi) = SEQ.MAP.CODE + map#;	else		write(mdi) = SEQ.GRPAUX.CODE + shl(map# - THD.GROUPLIST, 14);	/*	note: caller must store track # in lower...	*/	/*	If we are allocating the first block, set up the pointer		*/	/*	in the bas.ptr area and also the internal memory copy.		*/	if (reverse == 0)	{		if (map# ILT #.OF.MAP.PTRS)	/*	if temp/meter map...			*/		{			write(mam) = BAS.PTR;		/*	store in base sector.		*/			write(mal) = Seq.Map.Ptrs + map#;			write(md ) = i;			write(mal) = MAGIC.NUMBER;			if (read(md) == MAGIC#5)	/*	if has no groups, then mark	*/				write(md) = MAGIC#6;		/*	as tempo map sequence			*/												/*	else leave as magic#7...		*/			core(addr(Tempo.Map.Ptr) + map#) = NAH.PTR + i;		}		else									/*	else is group/aux info			*/		{			/*	set up magic number here.  caller must set up				*/			/*	pointer in track head...											*/			write(mam) = BAS.PTR;		/*	store in base sector.			*/			write(mal) = MAGIC.NUMBER;			write(md) = MAGIC#7;			/*	indicate group info present	*/			/*	NOTE: caller must store pointer to this block in appropriate track head...	*/		}	}	else do;									/*	set up prior forward ptr		*/		write(mam) = NAH.PTR + reverse;		write(mal) = NLS.FOR;		write(md ) = i;	end;	if forward <> 0 then do;			/*	also set up rev ptr in next	*/		write(mam) = NAH.PTR + forward;		write(mal) = NLS.REV;		write(md ) = i;	end;	return i;end Allocate.Map.Block;Activate.Sequence.For.New.Map: proc(map#,data) PUBLIC swapable;	dcl map#			fixed;	dcl data			fixed;	if (map# = Tempo.Map#)			/*	if we are activating the tempo map	*/	then Divisions = data;			/*	data is the new divisions value		*/	write(mam) = BAS.PTR;			/*	store new divisions to base sector	*/	write(mal) = SEQ.CLICK;	write(md ) = Divisions;	if PLAY <> 0						/*	stop playing when changing tempo		*/	then call STOP.SEQUENCER;		/*	map (mostly for PLAY.INITIALIZE)		*/	call Map.Sequence.Time.To.Real.Time(loc(addr(GOBACK.SEQ.TIME.MSB)),													loc(addr(GOBACK.PLAY.TIME.MSB)));	call PLAY.INITIALIZE;			/*	recompute all sequencer variables	*/	/*	Create a system event since some constants have likely changed:	*/	New.Seq.Info = New.Seq.Info \ 8;end Activate.Sequence.For.New.Map;/*	Routine to create a default tempo map	*/Create.Default.Tempo.Map: proc public swapable;	dcl i	fixed;	if Tempo.Map.Ptr <> 0		/*	if one is there already, do not			*/	then return;					/*	touch it!!										*/	if PLAY <> 0					/*	stop playing when changing sequencer	*/	then call STOP.SEQUENCER;	/*	map (mostly for PLAY.INITIALIZE)			*/	i = Allocate.Map.Block(0, 0, Tempo.Map#);	if i = 0							/*	out of room for tempo map.					*/	then return;	Tempo.Map.Len = Tempo.Map.First + 2*Tempo.Map.Rec.Len;	/*	word end of map in this sector	*/	Tempo.Map.Cur = Tempo.Map.First;	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;	write(mdi) = Tempo.Map.First;	write(mdi) = Tempo.Map.Len;	write(mdi) = 0;		/*	initialize record # to 0	*/	write(md ) = 0;	write(mal) = Tempo.Map.First;	write(mdi) = 0;		/*	delta-time						*/	write(mdi) = 0;	write(mdi) = 0;		/*	matching real time			*/	write(mdi) = 0;	write(mdi) = 1;		/*	define ratio = 1				*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1;		/*	define inverse ratio			*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;		/*	delta-time						*/	write(mdi) = zero.time;	write(mdi) = 0;		/*	matching real time			*/	write(mdi) = zero.time;	write(mdi) = 1;		/*	define ratio = 1				*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1;		/*	define inverse ratio			*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = -1;		/*	set up + infinity for start times	*/	write(mdi) = -1;		/*	of non-existent next segment.			*/	write(mdi) = -1;	write(md ) = -1;	/*	Set up info for current pointer:	*/	call Normalize.Tempo.Map.Cur;	call Activate.Sequence.For.New.Map(Tempo.Map#,SAMP.CLICK.RATE);end Create.Default.Tempo.Map;/*	Routine to erase tempo map from the sequencer	*/Erase.Tempo.Map.Info: proc PUBLIC swapable;	dcl i		fixed;	dcl j		fixed;	if PLAY <> 0						/*	stop playing when changing sequencer	*/	then call STOP.SEQUENCER;		/*	map (mostly for PLAY.INITIALIZE)			*/	/*	See if tempo map exists in the sequence:	*/	write(mam) = BAS.PTR;	write(mal) = Seq.Map.Ptrs + Tempo.Map#;	i = read(md);						/*	get pointer to first block (if any)	*/	if i = 0								/*	if not, then we are done				*/	then return;	write(md) = 0;						/*	no map now									*/	Tempo.Map.Ptr = 0;				/*	zero out absolute pointer				*/	/*	Now free up all data storage blocks:	*/	do while i <> 0;								/*	free up all the blocks		*/		write(mam) = NAH.PTR + i;				/*	that had been allocated.	*/		j = read(md);								/*	get forward pointer.			*/		call Deallocate.NAH.Block(i);			/*	free up first block			*/		i = j;										/*	move on to next.				*/	end;	call Normalize.Tempo.Map.Cur;				/*	set up globals					*/	call Map.Sequence.Time.To.Real.Time(loc(addr(GOBACK.SEQ.TIME.MSB)),													loc(addr(GOBACK.PLAY.TIME.MSB)));	call PLAY.INITIALIZE;			/*	recompute all sequencer variables	*/	/*	Create a system event since some constants have likely changed:	*/	New.Seq.Info = New.Seq.Info \ 8;end Erase.Tempo.Map.Info;Initialize.Empty.Tempo.Map: proc swapable;	dcl i		fixed;	/*	Get the first block:												*/	i = Allocate.Map.Block(0, 0, Tempo.Map#);	if i = 0					/*	out of room for tempo map.			*/	then return;	Tempo.Map.Len = Tempo.Map.First + Tempo.Map.Rec.Len;	/*	word end of map in this sector	*/	Tempo.Map.Cur = Tempo.Map.First;	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;	write(mdi) = Tempo.Map.First;	write(mdi) = Tempo.Map.Len;	write(mdi) = 0;		/*	initialize first record id#		*/	write(md ) = 0;		/*	to 0.										*/	write(mal) = Tempo.Map.First;	write(mdi) = 0;		/*	delta-time								*/	write(mdi) = 0;	write(mdi) = 0;		/*	matching real time					*/	write(mdi) = 0;	write(mdi) = 1;		/*	define ratio = 1						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1;		/*	define inverse ratio					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = -1;		/*	set up + infinity for delta and	*/	write(mdi) = -1;		/*	real times of non-existent			*/	write(mdi) = -1;		/*	next segment.							*/	write(md ) = -1;	/*	Set up info for current pointer:	*/	call Normalize.Tempo.Map.Cur;end Initialize.Empty.Tempo.Map;/*	Returns -1 if out of memory	*//*	Returns +1 if operation OK		*/Append.Sequencer.Tempo.Map.Record: proc(record) returns (fixed) PUBLIC swapable;	dcl record		array;	/*	pass the record	*/	dcl temp (1)	fixed;	dcl delta(1)	fixed;	dcl real (1)	fixed;	dcl i				fixed;	if PLAY <> 0						/*	stop playing when changing tempo	*/	then call STOP.SEQUENCER;		/*	map (mostly for PLAY.INITIALIZE)	*/	/*	Add Zero.Time offset into the passed times:	*/	call COPY32(record, delta);	/*	get delta time					*/	call ADD16(zero.time, delta);	/*	add zero.time					*/	call COPY32(loc(addr(record(Tempo.Map.Real.Msb))), real);	call ADD16(zero.time, real);	/*	add zero.time					*/	if Tempo.Map.Ptr = 0				/*	get first block				*/	then call Initialize.Empty.Tempo.Map;	if Tempo.Map.Ptr = 0				/*	make sure we got a block	*/	then return (-1);	/*	Find the end of the tempo map	*/	write(mam) = Tempo.Map.Ptr;	do while read(md) <> 0;		Tempo.Map.Ptr = NAH.PTR + read(md);		write(mam) = Tempo.Map.Ptr;	end;	/*	See if there is room for this new segment in the last		*/	/*	sector:																	*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;			/*	get pointer to first		*/	Tempo.Map.Cur = read(mdi);			/*	get in handy temp			*/	Tempo.Map.Len = read(mdi);			/*	pointer to end of list	*/	temp(0) = read(mdi);					/*	get Tempo.Map.Rec#.Msb	*/	temp(1) = read(mdi);					/*	and Lsb handy as well	*/	if Tempo.Map.Len >= Tempo.Map.Last	/*	if no more room, then	*/	then do;										/*	get another block			*/		/*	Try to allocate another NLS block to hold more tempo		*/		/*	map data:																*/		i = Allocate.Map.Block(0, Tempo.Map.Ptr - NAH.PTR, Tempo.Map#);		/*	If out of room, quit - but first clean up a little.		*/		if i = 0 then do;						/*	out of room					*/			Tempo.Map.Cur = Tempo.Map.Len - Tempo.Map.Rec.Len;			call Normalize.Tempo.Map.Cur;	/*	reset variables & return	*/			return (-1);		end;		/*	Write the starting time of the new record out at the		*/		/*	end of the last sector so the real time software will		*/		/*	know when to switch to the next segment:						*/		write(mam) = Tempo.Map.Ptr;		write(mal) = Tempo.Map.Len;		write(mdi) = delta(0);			/*	store delta time				*/		write(mdi) = delta(1);		write(mdi) = real(0);			/*	store real time				*/		write(mdi) = real(1);		/*	compute record # of the first tempo map record that		*/		/*	will be stored in the new sector:								*/		call ADD16((Tempo.Map.Len - Tempo.Map.Cur) / Tempo.Map.Rec.Len, temp);		Tempo.Map.Ptr = NAH.PTR + i;	/*	compute new pointer			*/		write(mam) = Tempo.Map.Ptr;	/*	point to the new block now	*/		write(mal) = Tempo.Map.FP;		/*	initialize the newly			*/		write(mdi) = Tempo.Map.First;	/*	allocated block.				*/		write(mdi) = Tempo.Map.First;		write(mdi) = temp(0);		write(mdi) = temp(1);		Tempo.Map.Len = Tempo.Map.First;	end;	/*	Store the data record in external memory	*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Len;	write(mdi) = delta(0);			/*	store delta time				*/	write(mdi) = delta(1);	write(mdi) = real(0);			/*	store real time				*/	write(mdi) = real(1);	write(mdi) = record(Tempo.Map.Rms.d+0);	/*	store ratio				*/	write(mdi) = record(Tempo.Map.Rms.d+1);	write(mdi) = record(Tempo.Map.Rms.d+2);	write(mdi) = record(Tempo.Map.Rd.ms+0);	/*	store inverse ratio	*/	write(mdi) = record(Tempo.Map.Rd.ms+1);	write(mdi) = record(Tempo.Map.Rd.ms+2);	write(mdi) = (-1);				/*	terminate map with			*/	write(mdi) = (-1);				/*	infinity							*/	write(mdi) = (-1);	write(mdi) = (-1);	Tempo.Map.Len = Tempo.Map.Len + Tempo.Map.Rec.Len;	write(mam) = Tempo.Map.Ptr;	/*	store new length of			*/	write(mal) = Tempo.Map.LP;		/*	sector out in ext memory.	*/	write(md ) = Tempo.Map.Len;	Tempo.Map.Cur = Tempo.Map.Len - Tempo.Map.Rec.Len;	/*	Set up info for current pointer:	*/	call Normalize.Tempo.Map.Cur;	return 1;end Append.Sequencer.Tempo.Map.Record;/*	this routine fetches the NTH record of a sequencer tempo map:	*//*	returns 1 if that record was found.										*//*	returns 0 if that record is past the end of the list.  The		*//*	last record in the list is returned in this case, except			*//*	that A RECORD OF ALL ZEROES is returned if the list itself		*//*	is empty.																		*/Fetch.Sequencer.Tempo.Map.Record: proc(record#, record) PUBLIC swapable;	dcl record#	array;	/*	pass record#		*/	dcl record	array;	/*	pass the record	*/	dcl temp (1)	fixed;	dcl comp (1)	fixed;	dcl last (1)	fixed;	dcl i				fixed;	dcl status		fixed;	status = 1;									/*	assume record will be found	*/	do i = 0 to Tempo.Map.Rec.Len-1;		/*	initialize answer to				*/		record(i) = 0;							/*	all zeroes in case there		*/	end;											/*	are no records						*/	if Tempo.Map.Ptr = 0						/*	if no tempo map, then return	*/	then do;										/*	all zeroes with a record		*/		call STR32(0, 0, record#);			/*	# of all zeroes.					*/		return 0;								/*	past end of list					*/	end;	/*	Add one to the desired record # for the search, since a				*/	/*	default record (for 0 == zero.time) was automatcally added			*/	/*	by the operating system:														*/	call COPY32(record#, temp);			/*	get record#							*/	if (temp(0) <> (-1))						/*	increment unless user is		*/	or (temp(1) <> (-1))						/*	trying to get last one!			*/	then call ADD16 (1, temp);				/*	+1 for our default one			*/	write(mam) = Tempo.Map.Ptr;			/*	get info handy for the			*/	write(mal) = Tempo.Map.FP;				/*	record we are pointing			*/	Tempo.Map.Cur = read(mdi);				/*	to.  Get Tempo.Map.FP,			*/	Tempo.Map.Len = read(mdi);				/*	Tempo.Map.LP,						*/	comp(0) = read(mdi);						/*	Tempo.Map.Rec#.Msb				*/	comp(1) = read(mdi);						/*	Tempo.Map.Rec#.Lsb				*/	/*	back up to prior block if the record we want is before where		*/	/*	we are now:																			*/	do while COM32(temp, comp) = lw#ilt;	/*	back up in list to			*/		write(mam) = Tempo.Map.Ptr;			/*	find the desired record.	*/		write(mal) = Tempo.Map.REV;			/*	Indicates serious system	*/		if read(md) = 0							/*	error if we cannot			*/		then do;										/*	find it.							*/			call STR32(0, 0, record#);			call Normalize.Tempo.Map.Cur;			return 0;								/*	strange error.					*/		end;		Tempo.Map.Ptr = NAH.PTR + read(md);	/*	advance to next block		*/		write(mam) = Tempo.Map.Ptr;			/*	get info handy for the		*/		write(mal) = Tempo.Map.FP;				/*	record we are pointing		*/		Tempo.Map.Cur = read(mdi);				/*	to.  Get Tempo.Map.FP,		*/		Tempo.Map.Len = read(mdi);				/*	Tempo.Map.LP,					*/		comp(0) = read(mdi);						/*	Tempo.Map.Rec#.Msb			*/		comp(1) = read(mdi);						/*	Tempo.Map.Rec#.Lsb			*/	end;	/*	Now see if we want a record that is in the	*/	/*	next tempo map sector:								*/	call COPY32(comp, last);	call ADD16 ((Tempo.Map.Len - Tempo.Map.Cur) / Tempo.Map.Rec.Len, last);	do while COM32(temp, last) >= lw#ieq;	/*	go forward in list to		*/		write(mam) = Tempo.Map.Ptr;			/*	find the desired record.	*/		write(mal) = Tempo.Map.FOR;		if read(md) = 0							/*	if we reach end of list,	*/		then do;										/*	then return end one.			*/			call COPY32(last, temp);			call SUB16 (   1, temp);			status = 0;								/*	return last one				*/		end;		else do;			Tempo.Map.Ptr = NAH.PTR + read(md);	/*	advance to next block	*/			write(mam) = Tempo.Map.Ptr;		/*	get info handy for the		*/			write(mal) = Tempo.Map.FP;			/*	record we are pointing		*/			Tempo.Map.Cur = read(mdi);			/*	to.  Get Tempo.Map.FP,		*/			Tempo.Map.Len = read(mdi);			/*	Tempo.Map.LP,					*/			comp(0) = read(mdi);					/*	Tempo.Map.Rec#.Msb			*/			comp(1) = read(mdi);					/*	Tempo.Map.Rec#.Lsb			*/			call COPY32(comp, last);			call ADD16 ((Tempo.Map.Len - Tempo.Map.Cur) / Tempo.Map.Rec.Len, last);		end;	end;	/*	Double check for empty tempo map:	*/	if COM16(0, temp) = lw#ieq			/*	oops - trying to access physical	*/	then do;									/*	record 0.  Means an empty			*/		call STR32(0, 0, record#);		/*	map that never received any		*/		return 0;							/*	data.										*/	end;	/*	Compute pointer to desired record:	*/	Tempo.Map.Cur = Tempo.Map.Cur + ((temp(1) - comp(1))*Tempo.Map.Rec.Len);	call SUB16(1, temp);					/*	compute record # we are actualy	*/	call COPY32(temp, record#);		/*	fetching.								*/	write(mam) = Tempo.Map.Ptr;		/*	and now read it in.					*/	write(mal) = Tempo.Map.Cur;	do i = 0 to Tempo.Map.Rec.Len-1;		record(i) = read(mdi);	end;	/*	Remove the zero.time offset:		*/	if			 COM16(zero.time,	loc(addr(record(Tempo.Map.Seq.Msb )))) = lw#igt	then call STR32(0, 0,		loc(addr(record(Tempo.Map.Seq.Msb ))));	else call SUB16(zero.time,	loc(addr(record(Tempo.Map.Seq.Msb ))));	if			 COM16(zero.time,	loc(addr(record(Tempo.Map.Real.Msb )))) = lw#igt	then call STR32(0, 0,		loc(addr(record(Tempo.Map.Real.Msb ))));	else call SUB16(zero.time,	loc(addr(record(Tempo.Map.Real.Msb ))));	/*	Set up info for current pointer:	*/	call Normalize.Tempo.Map.Cur;	return status;		/*	return record & tell user if it was the	*/							/*	last one in the list instead of the one	*/							/*	he asked for.										*/end Fetch.Sequencer.Tempo.Map.Record;Fetch.Sequencer.Tempo.Range: proc (tstart,tend,range) PUBLIC swapable;	dcl tstart	array;	dcl tend		array;	dcl range	array;	dcl (x,y)	fixed;	dcl offset	fixed;	if  (Tempo.Map.Ptr = 0)								/*	if no tempo map, then return		*/	or  ((tstart(0) = tend(0))							/*	also check for zero length range	*/	and  (tstart(1) = tend(1)))						/*	- not allowed	*/	then do;		call STR32(0, 0, loc(addr(range(0))));		/*	return zeros	*/		call STR32(0, 0, loc(addr(range(2))));		return;	end;	x = tstart(0);											/*	copy start time into locals		*/	y = tstart(1);	/*	Find the tempo segment that contains this delta time.			*/	do while	((x ILT Tempo.Map.This.Seq.Msb))		/*	back up if we are		*/	or			((x =   Tempo.Map.This.Seq.Msb)		/*	before start of		*/	and		 (y ILT Tempo.Map.This.Seq.Lsb));	/*	this segment.			*/		Tempo.Map.Cur = Tempo.Map.Cur - Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;	end;	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.Rec#.Msb;					/*	point to record # at begin of sector	*/	range(0) = read(mdi);								/*	copy into our start range arg				*/	range(1) = read(md );	write(mal) = Tempo.Map.FP;							/*	look up loc of first record within sector	*/	offset = (Tempo.Map.Cur - read(md)) / Tempo.Map.Rec.Len;		/*	compute how many records we are into sector	*/	call ADD16(offset,loc(addr(range(0))));		/*	compute absolute rec# of first record in range	*/	call SUB16(1,loc(addr(range(0))));				/*	remove 1 record for our zero.time offset	*/	call COPY32(loc(addr(range(0))),loc(addr(range(2))));	/*	init ending range	*/	if  (x = Tempo.Map.This.Seq.Msb)					/*	we are sitting at the exact start of this tempo segment	*/	and (y = Tempo.Map.This.Seq.Lsb)	then do;													/*	include this record in return range	*/		call ADD16(1,loc(addr(range(2))));	end;	x = tend(0);											/*	copy end time of range into handy locals	*/	y = tend(1);	/*	keep counting until we hit a start time beyond our range	*/	do while	((x IGT Tempo.Map.Next.Seq.Msb))		/*	skip ahead if we are	*/	or			((x =   Tempo.Map.Next.Seq.Msb)		/*	after end of this		*/	and		 (y IGE Tempo.Map.Next.Seq.Lsb)		/*	segment (check for	*/	and		 (x <>  (-1)						));	/*	infinite loop).		*/		Tempo.Map.Cur = Tempo.Map.Cur + Tempo.Map.Rec.Len;		call Normalize.Tempo.Map.Cur;		call ADD16(1,loc(addr(range(2))));			/*	increment ending record#	*/	end;end Fetch.Sequencer.Tempo.Range;/*	Routine to create a default tempo map for debugging	*/#if (false)//	I just need to make specific experimental tempo maps to suit my needs,//	but I didn't want to undo what someone else did here.  -TY 1999/11/05Create.Experimental.Tempo.Map: proc public swapable;	dcl i	fixed;	/*	Set up default tempo map:	*/	/*		 0 -  4000 at 1:1    yields	  0 -  4000	*/	/*	 4000 -  8000 at 1:1.5+ yields  4000 - 10000	*/	/*	 8000 - 12000 at 1:2    yields 10000 - 18000	*/	/*	12000 - 16000 at 1:.5   yields 18000 - 20000	*/	if PLAY <> 0				/*	cannot do so while playing			*/	then return;	if Tempo.Map.Ptr <> 0	/*	if one is there already, do not	*/	then return;				/*	touch it!!								*/	i = Allocate.Map.Block(0, 0, Tempo.Map#);	if i = 0						/*	out of room for tempo map.			*/	then return;	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;	write(mdi) = Tempo.Map.First;	write(mdi) = Tempo.Map.First + 4*Tempo.Map.Rec.Len;	write(mdi) = 0;			/*	initialize record # to 0			*/	write(mdi) = 0;	write(mal) = Tempo.Map.First;	write(mdi) = 0;			/*	delta-time								*/	write(mdi) = 0;	write(mdi) = 0;			/*	matching real time					*/	write(mdi) = 0;	write(mdi) = 1;			/*	define ratio = 1						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1;			/*	define inverse ratio					*/	write(mdi) = 0;	write(mdi) = 0;	//	Note error here: There must always be a record at zero.time	write(mdi) = 0;			/*	delta-time								*/	write(mdi) = 4050;	write(mdi) = 0;			/*	matching real time					*/	write(mdi) = 4050;	write(mdi) = 1;			/*	define ratio = 1 + 1/2				*/	write(mdi) = 32768;	write(mdi) = 0;	write(mdi) = 0;			/*	define inverse ratio					*/	write(mdi) = "HAAAA";	write(mdi) = "HAAAA";	/*	what's so funny?						*/	write(mdi) = 0;			/*	delta-time								*/	write(mdi) = 8050;	write(mdi) = 0;			/*	matching real time					*/	write(mdi) = 10050;	write(mdi) = 2;			/*	define ratio = 2						*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;			/*	define inverse ratio					*/	write(mdi) = "100000";	write(mdi) = 0;	write(mdi) = 0;			/*	delta-time								*/	write(mdi) = 12050;	write(mdi) = 0;			/*	matching real time					*/	write(mdi) = 18050;	write(mdi) = 0;			/*	define ratio = 1/2					*/	write(mdi) = "100000";	write(mdi) = 0;	write(mdi) = 2;			/*	define inverse ratio					*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = -1;			/*	set up + infinity for delta and	*/	write(mdi) = -1;			/*	real times of non-existent			*/	write(mdi) = -1;			/*	next segment.							*/	write(mdi) = -1;	Tempo.Map.Len = Tempo.Map.First + 4*Tempo.Map.Rec.Len;	/*	word end of map in this sector	*/	Tempo.Map.Cur = Tempo.Map.First;	/*	Set up info for current pointer:	*/	call Normalize.Tempo.Map.Cur;	call Activate.Sequence.For.New.Map(Tempo.Map#,SAMP.CLICK.RATE);end Create.Experimental.Tempo.Map;#elseCreate.Experimental.Tempo.Map: proc public swapable;	/*	I need to create:	at beat 1.000 tempo =  240 ms/beat	at beat 2.500 tempo = 1920 ms/beat	Assuming samp.click.rate = 480	 seq_time  *  ratio  =  real_time 	----------    -----     ----------	  0 -  720		1/2		  0 -  360	720 - 1920		4/1		360 - 5160	*/	dcl num_records lit '3';	//	<== DON'T OVERLOOK THIS!	if PLAY <> 0				/*	cannot do so while playing			*/	then return;	if Tempo.Map.Ptr <> 0	/*	if one is there already, do not	*/	then return;				/*	touch it!!								*/	if (Allocate.Map.Block(0,0,Tempo.Map#) == null) return;	//	out of room for tempo map	Tempo.Map.Cur = Tempo.Map.First;	Tempo.Map.Len = Tempo.Map.First + num_records*Tempo.Map.Rec.Len;;	/*	word end of map in this sector	*/	/*	Set up info for current pointer:	*/	write(mam) = Tempo.Map.Ptr;	write(mal) = Tempo.Map.FP;	write(mdi) = Tempo.Map.First;	write(mdi) = Tempo.Map.Len;	write(mdi) = 0;			/*	initialize record # to 0			*/	write(mdi) = 0;	write(mal) = Tempo.Map.First;	//	record#0	write(mdi) = 0;				/*	delta-time							*/	write(mdi) = 0;	write(mdi) = 0;				/*	matching real time				*/	write(mdi) = 0;	write(mdi) = 1;				/*	define ratio = 1/1				*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 1;				/*	define inverse ratio = 1/1		*/	write(mdi) = 0;	write(mdi) = 0;	//	record#1	write(mdi) = 0;				/*	delta-time							*/	write(mdi) = 0+zero.time;	write(mdi) = 0;				/*	matching real time				*/	write(mdi) = 0+zero.time;	write(mdi) = 0;				/*	define ratio = 1/2				*/	write(mdi) = "100000";	write(mdi) = 0;	write(mdi) = 2;				/*	define inverse ratio = 2/1		*/	write(mdi) = 0;	write(mdi) = 0;	//	record#2	write(mdi) = 0;				/*	delta-time							*/	write(mdi) = 720+zero.time;	write(mdi) = 0;				/*	matching real time				*/	write(mdi) = 360+zero.time;	write(mdi) = 4;				/*	define ratio = 4/1				*/	write(mdi) = 0;	write(mdi) = 0;	write(mdi) = 0;				/*	define inverse ratio = 1/4		*/	write(mdi) = "040000";	write(mdi) = 0;	write(mdi) = -1;			/*	set up + infinity for delta and	*/	write(mdi) = -1;			/*	real times of non-existent			*/	write(mdi) = -1;			/*	next segment.							*/	write(mdi) = -1;	call Normalize.Tempo.Map.Cur;	call Activate.Sequence.For.New.Map(Tempo.Map#,SAMP.CLICK.RATE);end Create.Experimental.Tempo.Map;#endifINSERT ':SYNRSOU:03-PRIM:041MAPSA';