/* 147-GSCN  $TITLE  REAL TIME SCAN OF GUITAR - examine each string for note *//* Timing information:   Guitar scan routine was timed 7/18/83 using d16 timer with model B   timer, with 2 32k memory boards in system.   With the guitar silent and the recorder off, the interrupt routine   takes a maximum of 373 microseconds.   With the guitar silent but the recorder running at a speed of 1.000,   the interrupt routine takes a maximum of 517 microseconds.   With the guitar silent but the recorder running at a speed of 10.000,   the interrupt routine takes a maximum of 1027 microseconds.   With the recorder running at a speed of 1.000, it takes a maximum   of 1,800 microseconds to start all 6 guitar strings in one cycle.   At a speed of 10.000, this time increases to 2,200 microseconds.   Once the 6 strings had become active, it takes a maximum of 1,800 microseconds   to process all 6 strings with different values being read from   all strings. (Speed of 10.000).  Time is only 1,400 to process all   6 strings with a speed of 1.000.   When only one string is being played, the interrupt loop averages    approx 570 microseconds per interrupt *//* $PAGE - Scan input data from guitar strings - Look for start of new note */dcl string.active array external;dcl on.limit      array external;dcl max.per       data  external;dcl onthr         fixed external;dcl offthr        fixed external; /* off threshold */dcl (p.per,pp.per,ppp.per)    array external;dcl (pppp.per,ppppp.per)      array external;dcl (m.range,w.range)         array external;dcl (cycle.counter)           array external;dcl (c.per)                   array external;dcl (pk.vol,c.vol,p.vol)      array external;dcl (vn.range)                array external;dcl (n.above,n.below)         array external;dcl (num.over)                array external;dcl (new.string.list)         array external;dcl (string.time)             array external;dcl (new.in,new.out,s.new.in) fixed external;  /* pointers into this list */dcl (new.string.decays)       fixed external;real.time.guitar.scan:proc public;dcl (i,j,k,m,n)    fixed;do i = 0 to 5; /* loop over strings */   if fake.it=0 then do; /* read guitar */      write(D134)=i;    j=read(D135); /* get current period */      write(D134)=16+i; k=read(D135); /* get volume */   end;   else do; /* simulate guitar with data from terminal (for debugging) */      j=fake.freq(i) + shl(real.milliseconds&1,1) + shr(real.milliseconds&2,1) - 2; /* provide jitter to fake out smoothing algorithm */      k=fake.vol(i);   end; /* code disappears if fake.it=0 */   if string.active(i)=0 then do; /* inactive note - check for possible new note */      if j IGE max.per(i) then do; /* current period out of range - means no peaks being detected */         p.per(i)=0; /* clear flag */         write(5)=k; write(6)="160000";         on.limit(i)=read(4); /* set on limit at .875 final amplitude */      end;      else if (k<onthr) or (k<on.limit(i)) then do; /* volume below desired threshold */         write(5)=k; write(7)=10; on.limit(i)=k+read(5); /* set limit to k*1.10 - slowly attacking harmonics will not trigger notes */         p.per(i)=0; /* set to zero */      end;      else do; /* oops - valid pitch & volume data on inactive string */         if (tfilten=0) /* if no tfilt at all (user wants any data immediately) */         or ((p.per(i)<>0) and (abs(j-p.per(i))<=w.range(i)))         then do; /* start note immed if no tfilt at all.  else wait for two similar readings */            string.active(i)=1; /* set to active */            cycle.counter(i)=0; /* initialize cycle counter */            if tfilten=1 then j=shr(j+p.per(i),1); /* average the two similar readings if transient filter was active */            p.per(i)=j; /* save for trend comparison */            c.per(i)=j; /* store current period */            pk.vol(i)=k; c.vol(i)=k; p.vol(i)=k; /* store peak volume always here */            w.range(i)=shr(j,2);      /* 1/4   for wide   range */            write(5)=j; write(7)= 18; /* 1/18  for medium range */            m.range(i)=read(5);            write(5)=j; write(7)=100; /* 1/100 for narrow range */            vn.range(i)=read(5);            n.above(i)=0; n.below(i)=0;            num.over(i)=0; /* used to detect end of note */            string.time(i)=kbd.milliseconds;            new.string.list(new.in)=i;            new.in=new.in+1; if new.in=new.max then new.in=0;         end;         else do; /* first nonzero sample, or samples differ - wait for more */            p.per(i)=j; /* save previous reading */            write(5)=j; /* compute range according to tfilter mode (range ignored if tfilten=0) */            if tfilt then write(7)=50; /* trans filter on       - wait for two readings within 2%  */            else          write(7)=8;  /* trans filter blinking - wait for two readings within 12% */            w.range(i)=read(5); /* store the computed range */         end;      end; /* of do for valid pitch and volume data from string */   end; /* of do for inactive string */   /* $PAGE  process active string - check pitch change, or end of note */   else do; /* active string - check for new pitch or end of note */      if j IGE max.per(i) then do; /* over maximum - check for end of vibrations */         num.over(i)=num.over(i)+1; /* count lost cycles */         if num.over(i)>1 then do; /* no more peaks - means end of note */            write(5)=k; write(6)="160000";            on.limit(i)=read(4); /* set on limit at .875 final amplitude */            goto guitar.decay; /* use goto - provides for fastest loop times */         end;         n.above(i)=0; n.below(i)=0; /* zap trends in case we recover */      end;      else if k<=offthr then do; /* oops - volume level has fallen below off threshold or no more periods - start final decay */         write(5)=k; write(7)=10; on.limit(i)=k+read(5); /* set limit to k*1.10 */         GUITAR.DECAY:; /* jump here to terminate note */         c.per(i)=shr(pppp.per(i)+ppppp.per(i),1); /* compute final pitch estimate from prior data */         string.active(i)=0; p.per(i)=0;     /* clear string status */         new.string.list(new.in)=256+i;      /* store with bit set to mean start decay */         new.in=new.in+1; if new.in=new.max then new.in=0;         new.string.decays=new.string.decays\bits(i); /* set bit so routines can check */      end;      /* $PAGE  Process Pitch Update */      else do; /* volume still above off threshold - check pitch update */         num.over(i)=0;         if (k>(c.vol(i)+15)) and (k>(p.vol(i)+15)) /* sudden rise in volume */         and (k>onthr) and (cycle.counter(i)>1) /* above threshold and past 2 cycles */         then do; /* may be new pluck */            on.limit(i)=0; /* no need of an on.limit here */            goto guitar.decay; /* begin decay first, then trigger attack */         end;         if (tfilten=0) and (cycle.counter(i)<3) then goto hammer; /* track first 3 cycles of unfiltered sounds exactly */         if j=p.per(i) then goto ignore; /* do not process identical samples */         m=c.per(i); /* look up current period - store in convenient variable for high speed access */         if j<m then do; /* period is below current value - means spurious data, bend up, glide up, hammer up, or just warbles */            n.above(i)=0; /* cancel upwards trend */            if j<(m-w.range(i)) then do; /* spurious reading - outside allowable range */               n.below(i)=0; /* no useful data */               goto ignore; /* ignore this sample */            end;            n.below(i)=n.below(i)+1; /* count one sample in this direction */            if n.below(i)>=4 then do; /* 4 lower readings - must be bend or glide upwards */               n.below(i)=0;                m=shr(j+p.per(i)+pp.per(i)+ppp.per(i),2); /* average 4 */               goto update.new; /* update new ranges */            end;            if  (j<(m-m.range(i))) /* if pitch is hammering up at least a semitone */            and (abs(j-p.per(i))<vn.range(i)) /* and it is very similar to last reading */            then goto hammer; /* must be accurate hammer up - two consecutive similar readings */         end; /* of period below current value */         else do; /* period above current value - must be spurious reading, glide down, bend down, hammer down, or obnoxious warbles */            n.below(i)=0; /* cancel downwards trend */            if j>(m+w.range(i)) then do; /* spurious reading - outside allowable range */               n.above(i)=0; /* no useful data */               goto ignore; /* ignore this sample */            end;            n=vn.range(i); if n>80 then n=80; /* limit to 80 */            write(5)=p.vol(i); write(7)=shr(n,2); /* initiate divide */            if (k>=(p.vol(i)-read(5))) /* if volume is not dropping precipitously (bend down) */            or (j>(m+m.range(i))) /* or pitch is dropping more than one semitone (glide down) */            then do; /* check for possible glide down or pitch bend release */               n.above(i)=n.above(i)+1; /* count one more sample in this direction */               if n.above(i)>=6 then do; /* means glide down or pitch bend release */                  n.above(i)=0;                   m=shr(j+p.per(i)+pp.per(i)+ppp.per(i),2); /* average 4 */                  goto update.new; /* update new ranges */               end;            end;            else n.above(i)=0; /* small pitch change & decaying volume - means drooping pitch */            if  (j>(m+shl(m.range(i),1))) /* if pitch is hammering down at least two semitones */            and (abs(j-p.per(i))<vn.range(i)) /* and it is very similar to last reading */            then do; /* must be accurate hammer down - two consecutive similar readings */               HAMMER:;               m=shr(j+p.per(i),1); /* average two similar readings */               p.per(i)=m;               n.above(i)=0; n.below(i)=0; /* clear trend */               UPDATE.NEW:; /* process pitch update and adjust ranges */               c.per(i)=m; /* store new pitch estimate in array */               w.range(i)=shr(m,2);      /* 1/4   for wide   range */               write(5)=m; write(7)= 18; /* 1/18  for medium range */               m.range(i)=read(5);               write(5)=m; write(7)=100; /* 1/100 for narrow range */               vn.range(i)=read(5);               cycle.counter(i)=cycle.counter(i)+1; /* count number of pitch updates made */            end;         end; /* of period above current value */         ppppp.per(i)=pppp.per(i); /* push measurement samples */         pppp.per (i)=ppp.per (i);   ppp.per(i)=pp.per(i);         pp.per   (i)=p.per   (i);   p.per  (i)=j;      end; /* of volume still above off threshold */      IGNORE:; /* fall out if spurious data or same data read twice */   end; /* of begin for active strings */   p.vol(i)=c.vol(i); /* keep one previous volume reading */   c.vol(i)=k;        /* store current volume */end;                  /* of loop over strings */end real.time.guitar.scan;