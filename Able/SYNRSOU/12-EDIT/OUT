insert ':synlits:comlits';insert ':synlits:globlits';insert ':synmods:globdcl';insert ':synmods:xmemdcl';insert ':synmods:syndummy';dcl (DiskDev,DiskSec) fixed; /* 32-bit device & sector address on disk */dcl (MaxSecs)         fixed; /* # of Sectors you can write to disk     */dcl (BufStart,BufLen) fixed; /* Exmem ptr to buffer and word length    */dcl (BufPtr)          fixed; /* Ptr to next free word in buffer        */dcl (TotalSecs)       fixed; /* sectors written to disk so far         */PRIME.OUTPUT:  proc (Dev,Sec,Max,Start,SecLen) swapable;   dcl (Dev,Sec)      fixed; /* 32-bit device & sector address on disk */   dcl (Max)          fixed; /* # of Sectors you can write to disk     */   dcl (Start,SecLen) fixed; /* Exmem ptr to buffer and length in sectors */   /* Set up Global Data */   DiskDev=Dev; DiskSec=Sec;   MaxSecs=Max;   BufStart=Start; BufLen=shl(SecLen,8);   /* Init Buffered Output Vars */   BufPtr   =0;   TotalSecs=0;end PRIME.OUTPUT;FLUSH.OUTPUT: proc fixed swapable;   dcl (Dev,Sec) fixed;   dcl (Len)     fixed;   if BufPtr<>0 then do;                /* have some data to write out */      Dev=DiskDev;      Sec=DiskSec+TotalSecs;      if Sec ILT TotalSecs then Dev=Dev+1;      Len=shr(BufPtr,8);      if (BufPtr&255)<>0 then Len=Len+1;      if (TotalSecs+Len) IGT MaxSecs then Len=MaxSecs-TotalSecs;      Len=shl(Len,8);      /* convert back to words */      if BufPtr ILT Len then Len=BufPtr;      /* call Ext.WriteData(Dev,Sec,BufStart,0,0,Len); */      print 'EXT.WRITEDATA(Dev,Sec,XmemSec,XmemWd,Len): ';      print '            ',dev,sec,bufstart,0,len;      BufPtr=0;      TotalSecs=TotalSecs+shr(Len+255,8);   end;   return MaxSecs-TotalSecs; /* sectors still available */end FLUSH.OUTPUT;OUTPUT.CHUNK: proc (Sec,Wrd,Len) fixed swapable;   dcl (Sec,Wrd) fixed; /* Exmem ptr to data to write out */   dcl Len       fixed; /* words to write out */   dcl Chunk     fixed;   dcl Left      fixed;   Sec=Sec+shr(Wrd,8); Wrd=Wrd&255; /* normalize */   Left=MaxSecs-TotalSecs;          /* Sectors available */   do while (Len<>0) & (Left<>0);      Chunk=BufLen-BufPtr;      if Chunk IGT Len then Chunk=Len;      /* call Copy.Ext.Mem(Sec,Wrd,BufStart,BufPtr,Chunk); */      print 'COPY.EXT.MEM (Sec,Wrd,BufStart,BufPtr,Chunk): ';      print '            ',sec,wrd,bufstart,bufptr,chunk;      BufPtr=BufPtr+Chunk;                /* advance buffer ptr */      if BufPtr=BufLen                    /* buffer is now full */      then Left=Flush.Output;             /* write data to disk */      Len=Len-Chunk;                      /* words left to write out */      Sec=Sec+shr(Wrd+Chunk,8);           /* keep source ptr normalized */      Wrd=(Wrd+Chunk)&255;   end;   return Left;end OUTPUT.CHUNK;Show.Globals: proc;   print;   print 'DiskDev,DiskSec: ',;   print DiskDev,DiskSec;   print 'MaxSecs: ',;   print  MaxSecs;   print 'BufStart,BufLen,BufPtr: ',;   print  BufStart,BufLen,BufPtr;   print 'TotalSecs: ',;   print  TotalSecs;   print;end Show.Globals;dcl cmnd fixed; cmnd=1;do while cmnd<>0;   print;   print '0 - Quit';   print '1 - Prime Output Buffer';   print '2 - Flush Output Buffer';   print '3 - Write Out Chunk';   print;   print 'Command',; input cmnd;   if cmnd<>0 then do;      do case cmnd-1;         begin; /* prime buffer */            dcl (dev,sec,max,start,len) fixed;            print 'PRIME.OUTPUT (Dev,Sec,Max,Start,Len)';            print 'Args',; input dev,sec,max,start,len;            call Prime.Output(dev,sec,max,start,len);            call Show.Globals;         end;         begin; /* flush output buffer */            dcl secsleft fixed;            print 'FLUSH.OUTPUT';            secsleft=Flush.Output;            print 'Sectors Left: ',secsleft;            call Show.Globals;         end;         begin; /* write out chunk */            dcl (sec,wrd,len,left) fixed;            print 'OUTPUT.CHUNK (Sec,Wrd,Len)';            print 'Args',; input sec,wrd,len;            left=output.chunk(sec,wrd,len);            print 'Sectors Left: ',left;            call Show.Globals;         end;      end;   end;end;