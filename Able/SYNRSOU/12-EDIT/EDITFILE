/* EDITFILE  $TITLE  Routines to Open and Manage Temporary ClipBoard File */dcl ClipBoard.is.WorkFile boolean; /* true if current clipboard file is the .WORK file */SET.CLIPBOARD.TREENAME: proc (treename) swapable;   dcl treename array; /* pass name of CLIPBOARD file or pass null-string to have routine get one */   BUILD.TREENAME: proc (filename,treename);      dcl filename array;      dcl treename array;      dcl i        fixed;      do case systyp;         treename(1)=a.f\shl(asc.0,8); /* "F0" */         treename(1)=a.w\shl(asc.0,8); /* "W0" */         treename(1)=a.r\shl(asc.0,8); /* "R0" */      end;      call pbyte(treename,2,a.colon); /* ":"  */      treename(0)=3;                    /* 3 char device */      do i=0 to filename(0)-1;         call pbyte(treename,treename(0),byte(filename,i));         treename(0)=treename(0)+1;      end;   end BUILD.TREENAME;   if treename(0)=0 then do;      call Build.Treename('.WORK',treename);      if Locate(treename,1) then do;         ClipBoard.is.WorkFile=true;      end;      else do;         call Build.Treename('.SCLIP-7',treename);         ClipBoard.is.WorkFile=false;      end;   end;   else ClipBoard.is.WorkFile=false;end SET.CLIPBOARD.TREENAME;SHORTEN.DISK.FILE: proc (treename,length) swapable; /* trims temp file to specified length */   dcl treename       array;   /* treename of file to shorten */   dcl length         fixed;   /* sector length of data actually written to temp file */   dcl found          boolean; /* TRUE if free block found */   dcl fcb1 (F#Len-1) fixed;   dcl fcb2 (F#Len-1) fixed;   dcl (MS_NewSize,LS_NewSize) fixed;   dcl (MS_NewSecs,LS_NewSecs) fixed;   dcl orig.len       fixed;   /* holds original length of treename string */   dcl filename   (4) fixed;   dcl (f,p)          fixed;   if ClipBoard.is.WorkFile then return; /* don't shorten work file */   orig.len=treename(0);       /* save in temp, so we can change below */   f=treename(0)-1;            /* get byte ptr of last char in treename */   do while (byte(treename,f)<>a.colon) and (f>=0);      f=f-1;   end;   filename(0)=0;              /* now extract filename */   do p=f+1 to treename(0)-1;      call pbyte(filename,filename(0),byte(treename,p)); /* extract filename from treename */      filename(0)=filename(0)+1;   end;   treename(0)=f+1;            /* and temporarily drop filename from treename */   if read_catalog(treename,1) then do; /* read system level catalog */      call findmax;                  /* consolidate the catalog */      f = 0; found = false; /* entry not found yet */      do while (f < C#Dir_Size / C#Len) and (not found); /* search for a free catalog entry */         call get_fcb(f,fcb2); /* get fcb */         if (fcb2(f#nm) = 0) and (fcb2(f#ml) = 0) and (fcb2(f#ll) = 0) /* found a free catalog entry */         then found = true; /* found it */         else f = f + 1; /* look at next entry */       end;      if found then do; /* free block found -- it better find one!! */         p = findfile(filename);          /* look for ClipBoard file */         if p<>(-1) then do;              /* ClipBoard file better be there at this stage */            call get_fcb(p,fcb1); /* get fcb */                           MS_NewSize=0; LS_NewSize=Length;            MS_NewSecs=fcb1(F#ml) - MS_NewSize;            LS_NewSecs=fcb1(F#ll) - LS_NewSize;            if LS_NewSecs igt fcb1(f#ll) then MS_NewSecs=MS_NewSecs-1;            /* Set up FCB2 to mark space to be freed up */            fcb2(f#ms) = fcb1(f#ms) + MS_NewSize; /* set sector start of free block */            fcb2(f#ls) = fcb1(f#ls) + LS_NewSize; /* start = start of subcat + new length of subcat */            if fcb2(f#ls) ILT LS_NewSize then fcb2(f#ms) = fcb2(f#ms) + 1;            fcb2(f#ml) = MS_NewSecs; /* set sector length of free block */            fcb2(f#ll) = LS_NewSecs; /* length = no. sectors subtracted above */            fcb2(f#wd) = shl(fcb2(f#ll),8); /* set word length of free block */            /* Set up FCB1 to reflect new length of subcat */            fcb1(f#ml) = MS_NewSize; /* set sector length of subcat */            fcb1(f#ll) = LS_NewSize;            fcb1(f#wd) = shl(fcb1(f#ll),8); /* set word length of subcat */            /* Store these fcbs back where they came from */            call put_fcb(p,fcb1);            call put_fcb(f,fcb2);            call Write_Catalog;         end;      end;   end;   treename(0)=orig.len;   /* restore treename to original length */end SHORTEN.DISK.FILE;FIND.CLIPBOARD: proc (treename) boolean swapable;   dcl treename fixed array;   call Set.ClipBoard.Treename(treename); /* set up clipboard filename */   return Locate(treename,1);end FIND.CLIPBOARD;OPEN.CLIPBOARD:  proc (treename) boolean swapable; /* opens a temporary edit buffer file */   dcl treename      array;   /* treename of edit temp file */   dcl found         boolean;   dcl fcb (F#Len-1) fixed;   dcl maxlen        fixed;   dcl orig.len      fixed;   /* holds original length of treename string */   dcl filename  (4) fixed;   dcl (f,p)         fixed;   /* Routine returns with Catalog vars all set up */   call Set.ClipBoard.Treename(treename); /* set up clipboard filename */   if ClipBoard.is.WorkFile then do;      /* we returned from SET.CLIPBOARD.TREENAME with */      /* catalog variables all set up in this case    */      if F#MS_Length=0            /* limit length to 32 MBytes */      then maxlen=F#LS_Length;      else maxlen=65535;      if maxlen=0 then return false; /* just to be safe */      call Prime.Output(F#MS_Sector,F#LS_Sector,MaxLen,ExtBuf.Ptr,ExtBuf.Len);      return true;                /* found the work file */   end;   orig.len=treename(0);       /* save in temp, so we can change below */   f=treename(0)-1;            /* get byte ptr of last char in treename */   do while (byte(treename,f)<>a.colon) and (f>=0);      f=f-1;   end;   filename(0)=0;              /* now extract filename */   do p=f+1 to treename(0)-1;      call pbyte(filename,filename(0),byte(treename,p)); /* extract filename from treename */      filename(0)=filename(0)+1;   end;   treename(0)=f+1;            /* and temporarily drop filename from treename */   if Read_Catalog(treename,1) then do;  /* try to read in catalog */      if FindMax then do;                /* look for largest free block   */         if F#MS_Length=0                /* limit length to 32 MBytes */         then maxlen=F#LS_Length;         else maxlen=65535;         if maxlen=0 then do;            /* no room on disk */            treename(0)=orig.len;        /* restore treename to original length */            return false;                /* just to be safe */         end;         if AddFile(filename,T#Sync,0,MaxLen,F#Words) then do;            /* make sure we still have another free block    */            /* so we will be able to trim the edit file      */            /* after we finish with CUT/COPY/PASTE operation */            f = 0; found = false; /* entry not found yet */            do while (f < (C#Dir_Size / C#Len)) and (not found); /* search for a free catalog entry */               call get_fcb(f,fcb); /* get fcb */               if (fcb(f#nm) = 0) and (fcb(f#ml) = 0) and (fcb(f#ll) = 0) /* found a free catalog entry */               then found = true; /* found it */               else f = f + 1; /* look at next entry */            end;            /* if we were able to open our edit file */            /* then prime the disk output buffer     */            if found then do;               call Write_Catalog;          /* write out our modified catalog */               call Prime.Output(F#MS_Sector,F#LS_Sector,MaxLen,ExtBuf.Ptr,ExtBuf.Len);            end;         end;         else found=false;      end;      else found=false;   end;   else found=false;       /* problem opening disk file */   treename(0)=orig.len;   /* restore treename to original length */   return found;end OPEN.CLIPBOARD;ABORT.EDIT: proc (treename) swapable;   dcl treename array; /* treename of edit file */   if not ClipBoard.is.WorkFile   then call Delete(treename,1);   /* display an appropriate error message */end ABORT.EDIT;