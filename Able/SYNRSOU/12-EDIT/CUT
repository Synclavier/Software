/*	:SYNRSOU:12-EDIT:CUT  $TITLE  ROUTINES TO PERFORM CUT & PASTE EDIT OPERATIONS	*//*Modified:2002/08/18 - TY  - CHECK.NOTE.FILTER() now handles pressure as well as separate ranges for monopolar vs. bipolar RTEs2002/08/04 - TY  - Bug fix: CHECK.NOTE.FILTER() did not distinguish between Synclavier RTEs and MIDI RTEs when checking ranges1990/08/27 - PF  - Support all MIDI controllers1988/07/26 - eeg - bug fix - seq.cbits were not being saved with the cut file1988/04/05 - eeg - made filter.cut.region delete notes instead of converting them to rests1988/03/02 - eeg - added filter.cut.region1988/02/25 - eeg - changed bounce.down call in partial.track.copy to FAST.COPY1987/10/30-TSS,EEG-FIXED NASTY WINCHESTER TRASHING BUG1987/09/04 - EEG - MADE PUNCH.REGION PUBLIC1987/04/16 - TSS - FILE CREATED FOR RELEASE N*/dcl t#indx		fixed;	/*	globals used by Set.Start.Bit & Get.Next.Bit	*/dcl t#bit		fixed;dcl cut.indx	fixed;	/*	DEBUG: globals used for paste, index into cut.trks	*/dcl cut.bit		fixed;SET.START.BIT: proc (index) swapable;	/*	inits vars for subsequent Get.Next.Bit calls	*/	dcl index	fixed;	/*	bit to start at on next call to Get.Next.Bit	*/	t#indx=shr(index,4); t#bit=index&15;end SET.START.BIT;GET.NEXT.BIT: proc(bit.array) fixed swapable;	dcl bit.array	array;	/*	array of bits (16 words long)	*/	dcl next.bit	fixed;	/*	bit position	*/	next.bit=(-1);	do while next.bit=(-1);		if (t#indx ILT 16) then do;			if (bit.array(t#indx)&bits(t#bit))<>0	/*	bit is set	*/			then next.bit=shl(t#indx,4)+t#bit;		/*	return this bit	*/			t#bit=t#bit+1;									/*	advance vars to next bit pos	*/			if t#bit=16 then do;				t#bit=0;				t#indx=t#indx+1;			end;		end;		else return (-1);									/*	have hit end of bit array	*/	end;	return next.bit;										/*	this is index of next bit set	*/end GET.NEXT.BIT;OPTIMIZE.TRACKS.TO.EDIT: proc (trks) swapable;	/*	masks off trk bits for trks which are null	*/	dcl trks			array;	dcl trk			fixed;	dcl (mask,len)	fixed;	dcl i				fixed;	trk=0; mask=1;	do i=0 to 15;									/*	loop over 16 groups of 16 tracks	*/		do while mask<>0;			if (trks(i)&mask)<>0 then do;		/*	this bit is set	*/				write(mam)=Trk.Head;				/*	look up trk head for this trk	*/				write(mal)=trk;				if (read(md)=0)							/*	no trk head	*/				or (trk<num.kbd.tracks)					/*	keyboard track	*/				or (trk>(num.kbd.tracks+200))			/*	track too high	*/				then trks(i)=trks(i) & (not mask);	/*	don't bother processing track	*/			end;			trk=trk+1;			mask=shl(mask,1);						/*	advance bit mask	*/		end;		mask=1;	end;end OPTIMIZE.TRACKS.TO.EDIT;/*	$SUBTITLE	*/COMPUTE.AFFECTED.TIMBRES: proc (trks,timbres) fixed swapable;	dcl trks				array;	/*	16 words of bits representing which trks to edit	*/	dcl timbres			array;	/*	output: bit set if timbre should be used	*/	dcl (trk, timbre)	fixed;	dcl count			fixed;	dcl (sindx, sbit)	fixed;	/*	loop over tracks and figure out which			*/	/*	timbres need to be written out to the disk	*/	sindx=t#indx; sbit=t#bit;					/*	save current values since we trash them below	*/	call Set.Start.Bit(Num.Kbd.Tracks);		/*	start with first non-kbd track	*/	trk=Get.Next.Bit(trks);						/*	get first used track	*/	do while trk<>(-1);							/*	loop over all tracks	*/		timbre=Trk.Head.Lookup(trk,thd.ctimb);	/*	timbre used by this trk	*/		timbres(shr(timbre,4))=timbres(shr(timbre,4))\bits(timbre&15);	/*	set bit in array	*/		trk=Get.Next.Bit(trks);					/*	get next used track	*/	end;	call Set.Start.Bit(Num.Kbd.Tracks);		/*	start with first non-kbd track	*/	timbre=Get.Next.Bit(timbres);				/*	get first used timbre	*/	count=0;											/*	init count of timbres used	*/	do while timbre<>(-1);						/*	loop over all tracks	*/		count=count+1;								/*	one more timbre used	*/		timbre=Get.Next.Bit(timbres);			/*	get next used timbre	*/	end;	t#indx=sindx; t#bit=sbit;					/*	restore to original values	*/	return count;									/*	return total # of timbres used	*/end COMPUTE.AFFECTED.TIMBRES;REMAP.TRACK.TIMBRE: proc (timbres,timbre) fixed swapable;	dcl timbres			array;	dcl timbre			fixed;	dcl disktimbre		fixed;	dcl cur				fixed;	dcl (sindx, sbit)	fixed;	/*	routine remaps timbre numbers in original sequences to	*/	/*	the timbre numbers once they get written to disk for		*/	/*	the CUT/COPY/PASTE operation.										*/	sindx=t#indx; sbit=t#bit;						/*	save current values since we trash them below	*/	call Set.Start.Bit(0);							/*	start with first timbre	*/	cur=Get.Next.Bit(timbres);						/*	get first timbre relevant timbre	*/	disktimbre=num.kbd.tracks;						/*	first timbre # is 2	*/	do while cur<>(-1);								/*	loop through timbres	*/		if cur=timbre then do;			t#indx=sindx; t#bit=sbit;				/*	restore to original values	*/			return disktimbre;		end;		disktimbre=disktimbre+1;		cur=Get.Next.Bit(timbres);					/*	get next timbre to process	*/	end;	t#indx=sindx; t#bit=sbit;						/*	restore to original values	*/	return (-1);										/*	error!!!	*/end REMAP.TRACK.TIMBRE;/*	$SUBTITLE	*/WRITE.TIMBRES: proc (Timbres) fixed swapable;	/*	writes timbres to disk	*/	dcl timbres				array;	/*	16 words of bits timbres to write to disk	*/	dcl timbre				fixed;	dcl (mask, len, ptr)	fixed;	dcl startlen			fixed;	dcl i						fixed;	dcl (sindx, sbit)		fixed;	if Edit.Error=0 then do;		/*	flush output buffer just to be safe to	*/		/*	make sure we are aligned on a sector	*/		/*	boundary for writing out timbre area	*/		if Flush.Output=0 then Edit.Error=E#NoRoom;	end;	startlen=TotalSecs;									/*	save len of temp disk file so far	*/	sindx=t#indx; sbit=t#bit;							/*	save current values since we trash them below	*/	call Set.Start.Bit(Num.Kbd.Tracks);				/*	start with first track after keyboard trks	*/	timbre=Get.Next.Bit(timbres);						/*	get first timbre to write out	*/	do while (timbre<>(-1)) and (Edit.Error=0);	/*	loop through trks to edit	*/		ptr=Find.Timbre(Par.Ptr,timbre);				/*	get ptr to timbre	*/		len=Find.Timbre(Par.Ptr,timbre+1)-ptr;		/*	this is timbre len in words	*/		/*	write out timbre data	*/		if Output.Chunk(Par.Ptr,ptr,len)=0			/*	hit end of disk buffer	*/		then Edit.Error=E#NoRoom;						/*	have to abort edit	*/		timbre=Get.Next.Bit(timbres);					/*	get next timbre to process	*/	end;	/*	flush any remaining words in disk output buffer	*/	/*	to realign disk pointer to sector boundary		*/	if Edit.Error=0 then do;		if Flush.Output=0 then Edit.Error=E#NoRoom;	/*	out of disk space	*/	end;	t#indx=sindx; t#bit=sbit;		/*	restore to original values	*/	return TotalSecs-StartLen;		/*	sectors of timbres written out	*/end WRITE.TIMBRES;/*	$SUBTITLE  Routine to Extract a Section of a Track and Copy to a New Track	*/PARTIAL.TRACK.COPY: proc(sou.trk,des.trk,start,finish) boolean swapable;	dcl sou.trk		fixed;	/*	trk to copy from	*/	dcl des.trk		fixed;	/*	where to copy trk to	*/	dcl start		array;	/*	start time of region to keep	*/	dcl finish		array;	/*	end time of region to keep	*/	dcl (msb, lsb)	fixed;	msb=start(0); lsb=start(1);	if (msb=0) and (lsb ilt zero.time) then lsb=zero.time;	if lsb ilt zero.time then msb=msb-1;	lsb=lsb-zero.time;	/**** if Bounce.Down(sou.trk,des.trk,1,1)=0 ***	*/	/*	quick replicate bounce	*/	if Fast.Copy(sou.trk,des.trk)=0		/*	quick replicate bounce	*/	then return false;						/*	ran out of memory		*/	if Unwrap.Track(des.trk,finish(0),finish(1))=0	then return false;						/*	ran out of memory	*/	if Delete.Time.From.Trk(des.trk,0,zero.time,msb,lsb)=0	/*	delete from zero.time to start of edit region	*/	then return false;						/*	ran out of memory	*/	return true;								/*	operation successful	*/end PARTIAL.TRACK.COPY;/*	$SUBTITLE	*//*	items used by edit filter	*/dcl apply.filter			boolean public;	/*	true if filter should be applied to region and cut/paste functions	*/dcl check.pitches			fixed public;dcl check.vel				fixed public;dcl check.dur				fixed public;dcl check.ctrl				fixed public;dcl check.monopolar.val	fixed public;dcl check.bipolar.val	fixed public;dcl check.midi.val		fixed public;dcl (ctrl1,			ctrl2,		ctrl3)		fixed public;	/*	3 rte controllers to filter		*/dcl (midi.ctrl1,	midi.ctrl2,	midi.ctrl3)	fixed public;	/*	3 midi controllers to filter		*/dcl (pitch.lo,			pitch.hi)				fixed public;	/*	pitch boundaries						*/dcl (vel.lo,			vel.hi)					fixed public;	/*	velocity boundaries					*/dcl (monopolar.lo,	monopolar.hi)			fixed public;	/*	controller value boundaries		*/dcl (bipolar.lo,		bipolar.hi)				fixed public;	/*	controller value boundaries		*/dcl (midi.lo,			midi.hi)					fixed public;	/*	midi controller value boundaries	*/dcl (dur.lo,			dur.hi)(1)				fixed public;	/*	hi duration boundary (32bit)		*//*	check to see if note falls inside or outside edit filter region	*/CHECK.NOTE.FILTER: proc returns (boolean) public swapable;	dcl value			fixed;	dcl out_of_range	boolean;	dcl inside			lit 'true';									/*	for easier readability		*/	dcl outside			lit 'false';	if (isa.rest.note)	or (isa.ilp.note)	then return inside;	if (isa.rte.note == false)	{																		/*	this is a normal note		*/		if (check.pitches != 0)		{			if (check.pitches == 3)	return outside;			//	no pitches			value = extract.key(loc(addr(#w1)));			out_of_range	= (value ilt pitch.lo) || (value igt pitch.hi);			if	(check.pitches == 1)									//	pitches from pitch.lo to pitch.hi			{	if	(out_of_range != false)	return outside;			}			else	//	(check.pitches == 2)							//	pitches except pitch.lo to pitch.hi			{	if (out_of_range == false)	return outside;			}		}		if (check.vel != 0)		{			if (#w1)			then value = (#w3 & 255);			else value = rte.max;			out_of_range	= (value ilt vel.lo) || (value igt vel.hi);			if	(check.vel == 1)										//	velocities from vel.lo to vel.hi			{	if	(out_of_range != false)	return outside;			}			else	//	(check.vel == 2)								//	velocities except vel.lo to vel.hi			{	if (out_of_range == false)	return outside;			}		}		if (check.dur != 0)		{			dcl time(1)	fixed;			extract.dur(loc(addr(#w1)), time);			out_of_range	= (com32(time, dur.lo) == lw#ilt) || (com32(time, dur.hi) == lw#igt);			if	(check.dur == 1)										//	durations from dur.lo to dur.hi			{	if	(out_of_range != false)	return outside;			}			else	//	(check.dur == 2)								//	durations except dur.lo to dur.hi			{	if (out_of_range == false)	return outside;			}		}	}	//	end of this is a normal note	else	{																		/*	this note is an update record		*/		dcl rte.val	lit 'value';		do case (shr(#w2,8-2)&3);			{	//	CASE 0:	this is an RTE update record				dcl rte.code	fixed;				rte.code	= shr(#w2,8);								/*	find out what type of controller is being changed	*/				rte.val	= #w3 & 255;								/*	get current rte value			*/				if ((rte.code & "200") == 0)						//	this is a Synclavier RTE				{															//	rte.code should be in the range 0 through 5					do case check.ctrl;						;													/*	all controllers					*/						do;												/*	only...								*/							if	(rte.code != ctrl1)							&&	(rte.code != ctrl2)							&&	(rte.code != ctrl3)							then return outside;						end;						do;												/*	all controllers except...		*/							if	(rte.code == ctrl1)							||	(rte.code == ctrl2)							||	(rte.code == ctrl3)							then return outside;						end;						return outside;								/*	no controllers						*/					end;					//	NOTE: The bipolar RTEs have a different range of possible values than the monopolar RTEs.					//	Consequently we need separate lo/hi boundaries for the two types.					if (rte.code ilt 4)								//	this is a monopolar RTE					{						if (check.monopolar.val != 0)						{							out_of_range	= (rte.val ilt monopolar.lo) || (rte.val igt monopolar.hi);							if	(check.monopolar.val == 1)			//	monopolar RTE values from monopolar.lo to monopolar.hi							{	if	(out_of_range != false)	return outside;							}							else	//	(check.monopolar.val == 2)	//	monopolar RTE values except monopolar.lo to monopolar.hi							{	if (out_of_range == false)	return outside;							}						}					}					else													//	this is a bipolar RTE					{						if (check.bipolar.val != 0)						{							if ((rte.val & 0x80) != 0)	rte.val	= rte.val | 0xFF00;	//	will need sign extension for bipolar RTEs							out_of_range	= (rte.val < bipolar.lo) || (rte.val > bipolar.hi);							if	(check.bipolar.val == 1)			//	bipolar RTE values from bipolar.lo to bipolar.hi							{	if	(out_of_range != false)	return outside;							}							else	//	(check.bipolar.val == 2)	//	bipolar RTE values except bipolar.lo to bipolar.hi							{	if (out_of_range == false)	return outside;							}						}					}				}	//	end of note is a Synclavier RTE				else														//	this is a MIDI Controller RTE				{															//	rte.code should be in the range 128+0 through 128+127					rte.code = rte.code & 0x7F;					//	transpose to MIDI controller number 0 through 127					do case check.ctrl;						;													/*	all controllers				*/						do;												/*	only...							*/							if							(	((ctrl1 != 7) || (rte.code != midi.ctrl1))							&&	((ctrl2 != 7) || (rte.code != midi.ctrl2))							&&	((ctrl3 != 7) || (rte.code != midi.ctrl3))							)							then return outside;						end;						do;												/*	all controllers except...		*/							if							(	((ctrl1 == 7) && (rte.code == midi.ctrl1))							||	((ctrl2 == 7) && (rte.code == midi.ctrl2))							||	((ctrl3 == 7) && (rte.code == midi.ctrl3))							)							then return outside;						end;						return outside;								/*	no controllers					*/					end;					if (check.midi.val != 0)					{						out_of_range	= (rte.val ilt midi.lo) || (rte.val igt midi.hi);						if	(check.midi.val == 1)					//	midi controller values from midi.lo to midi.hi						{	if	(out_of_range != false)	return outside;						}						else	//	(check.midi.val == 2)			//	midi controller values except midi.lo to midi.hi						{	if (out_of_range == false)	return outside;						}					}				}	//	end of note is a MIDI RTE			}			{	//	CASE 1:	this is a toggle update record				do case check.ctrl;					;														/*	all controllers					*/					return outside;									/*	only...								*/					;														/*	all controllers except...		*/					return outside;									/*	no controllers						*/				end;			}			{	//	CASE 2:	this is a pressure update record				//	pressure is treated just like monopolar RTEs except that it is pitch-specific				do case check.ctrl;					;														/*	all controllers					*/					do;													/*	only...								*/						if	(ctrl1 != 6)						&&	(ctrl2 != 6)						&&	(ctrl3 != 6)						then return outside;					end;					do;													/*	all controllers except...		*/						if	(ctrl1 == 6)						||	(ctrl2 == 6)						||	(ctrl3 == 6)						then return outside;					end;					return outside;									/*	no controllers						*/				end;				//	option 3 (No Pitches) doesn't apply to pressure - treat it as option 0 (All Pitches)				if ((check.pitches == 1) || (check.pitches == 2))				{					dcl pitch_number	fixed;					pitch_number	= extract.key(loc(addr(#w1)));					out_of_range	= (pitch_number ilt pitch.lo) || (pitch_number igt pitch.hi);					if	(check.pitches == 1)							//	pitches from pitch.lo to pitch.hi					{	if	(out_of_range != false)	return outside;					}					else	//	(check.pitches == 2)					//	pitches except pitch.lo to pitch.hi					{	if (out_of_range == false)	return outside;					}				}				if (check.monopolar.val != 0)				{					rte.val			= #w3 & 255;					/*	get current rte value			*/					out_of_range	= (rte.val ilt monopolar.lo) || (rte.val igt monopolar.hi);					if	(check.monopolar.val == 1)					//	pressure values from monopolar.lo to monopolar.hi					{	if	(out_of_range != false)	return outside;					}					else	//	(check.monopolar.val == 2)			//	pressure values except monopolar.lo to monopolar.hi					{	if (out_of_range == false)	return outside;					}				}			}			{	//	CASE 3:	this is a MIDI Program Change, Sustain or SysEx update record				do case check.ctrl;					;														/*	all controllers					*/					return outside;									/*	only...								*/					;														/*	all controllers except...		*/					return outside;									/*	no controllers						*/				end;			}		end;	//	end of do case update record type	}	//	end of note is an RTE	return inside;end CHECK.NOTE.FILTER;FILTER.CUT.REGION: proc (trk, start, finish, keep.inside) swapable;	dcl trk						fixed;	/*	abs. track to filter						*/	dcl (start, finish)		array;	/*	start and end time of edit				*/	dcl keep.inside			boolean;	/*	if true, keep notes which are			*/												/*	inside the edit filter and turn		*/												/*	notes outside the filter to rests.	*/												/*	if false, keep notes outside the		*/												/*	edit filter and turn notes inside	*/												/*	the filter to rests.						*/	dcl ptr						fixed;	dcl inside.edit.filter	boolean;	/*	true if note passes filter test		*/	dcl more.notes				boolean;	/*	true while more notes left on track	*/	write(mam)=Nah.Ptr;	write(mal)=trk;	ptr=read(md);	if (ptr <> 0) then do;		write(mam) = nah.ptr + ptr;	/*	point to data track head	*/		write(mal) = thd.for;			/*	get pointer to first nls	*/		#sec = read(md);					/*	#sec is a relative ptr to 1st nls	*/		if (#sec <> 0) then do;			/*	nls is there	*/			write(mam) = nah.ptr + #sec;			write(mal) = nls.fp;			/*	get pointer to first note in this nls	*/			#wrd = read(md);		end;		else return 0;	end;	else return 0;	call load.seq.globals(trk);	call look.up.note.info;				/*	load #w1 - #w4	*/	/*	move back to before edit start	*/	do while (#anyr <> 0)	and (((#nmsb igt start(0)))	or   ((#nmsb ==  start(0))	and   (#nlsb ige start(1))));		call backup.to.prior.note;	end;	/*	now move forward to first note in edit region	*/	do while (#anyf <> 0)	and (((#nmsb ilt start(0)))	or   ((#nmsb ==  start(0))	and   (#nlsb ilt start(1))));		call advance.to.next.note;	end;	if (#anyf <> 0)	then more.notes = true;	else more.notes = false;	do while (more.notes);					/*	loop over track	*/		call look.up.note.info;				/*	load #w1 - #w4		*/		/*** DEBUG **	*/		/** CALL CLEAR.TERM;	*/		/** CALL PS('DATA TRACK = ');CALL PNUM(trk, 0);	*/		/** CALL POLL.FOR.DEBUG.COMMANDS('JUST LOOKED UP NOTE INFO');	*/		if (isa.rest.note)		then inside.edit.filter = true;					/*	skip over rest notes	*/		else inside.edit.filter = check.note.filter;	/*	see if we want to keep this note or not	*/		/** CALL PS('inside.edit.filter = ');	*/		/** IF inside.edit.filter		*/		/** THEN CALL PSR('TRUE');		*/		/** ELSE CALL PSR('FALSE');	*/		if  (isa.rest.note = false)		and (((keep.inside) & not(inside.edit.filter))		or   (not(keep.inside) & (inside.edit.filter)))		THEN CALL REMOVE.NOTE.RECORD;		ELSE CALL ADVANCE.TO.NEXT.NOTE;		if (#anyf = 0)		or  (((#nmsb igt finish(0)))		or   ((#nmsb ==  finish(0))		and   (#nlsb ige finish(1))))		then more.notes = false;		else more.notes = true;	end;	call quick.play.init(get.thd.ptr(trk));	/*	keep things safe	*/	return 1;end FILTER.CUT.REGION;WRITEOUT.TRACK: proc (data.trk,logical.trk,timbres,start,finish,Nls.Ptr) swapable;	/*	writes NLS for track to disk	*/	dcl data.trk			fixed;	/*	temp track from which data should actually be written	*/	dcl logical.trk		fixed;	/*	original seq trk being written	*/	dcl timbres				array;	/*	array of timbres used in edit	*/	dcl (start, finish)	array;	/*	start and end time of edit	*/	dcl length		(1)	fixed;	dcl clip.start	(1)	fixed;	/*	will hold start time of clipboard	*/	dcl Nls.Ptr				fixed;	/*	rel ptr to start of track on disk	*/	dcl ptr					fixed;	dcl (maxnum,num)		fixed;	dcl (sfor,srev,strk)	fixed;	dcl stimb				fixed;	dcl grouplist			fixed;	write(mam)=Nah.Ptr;	write(mal)=data.trk;	ptr=read(md);	if ptr<>0 then do;				/*	we appear to have a track	*/		if (apply.filter) then do;			clip.start(0) = 0; clip.start(1) = zero.time;			call sub32(finish, start, length);			call Filter.Cut.Region(data.trk, clip.start, length, true);			write(mam)=Nah.Ptr;					/*	make sure ptr is right	*/			write(mal)=data.trk;			ptr=read(md);		end;		/*	remap timbre number on track to new location on disk	*/		stimb=Trk.Head.Lookup(data.trk,THD.STIMB);	/*	save original timbre number	*/		num=Remap.Track.Timbre(timbres,stimb);			/*	remap to position in disk file	*/		call Trk.Head.Store(data.trk,THD.STIMB,num);	/*	temporarily store remapped timbre number in trk head	*/		call Trk.Head.Store(data.trk,THD.USAGE,num);	/*	store in usage table too	*/		grouplist = Trk.Head.Lookup(data.trk,THD.GROUPLIST);	/*	stash away group setting	*/		call Trk.Head.Store(data.trk,THD.GROUPLIST,0);			/*	and set to 0 for writeout	*/		/*	for right now we assume usage table only contains 1 timbre	*/		write(mam)=Nah.Ptr+Ptr;		/*	look at track head	*/		write(mal)=THD.NUM.NLS;		/*	see how many NLS's we are supposed to have	*/		maxnum=read(md)+1;			/*	use for consistency check below	*/		/*	add one since trk head sector not counted in THD.NUM.NLS	*/		num=0;							/*	init NLS count	*/	end;	/*	$PAGE	*/	do while (Edit.Error=0) & (ptr<>0) & (num ILT maxnum);	/*	loop through NLS's	*/		/*	recompute new NLS.FOR and NLS.REV ptrs for each	*/		/*	note segment since writing to disk will change	*/		/*	their order. Also temporarily change trk number	*/		/*	to the logical position trk will occupy on disk	*/		write(mam)=Nah.Ptr+Ptr;			/*	point at NLS	*/		write(mal)=NLS.FOR;				/*	access ptr to next NLS	*/		sfor=read(md);						/*	save original forward ptr	*/		if read(md)<>0						/*	remap the forward ptr	*/		then write(md)=Nls.Ptr+Num+1;	/*	temporarily store remapped forward ptr	*/		write(mal)=NLS.REV;				/*	access ptr to prior NLS	*/		srev=read(md);						/*	save original reverse ptr	*/		if read(md)<>0						/*	remap the reverse ptr	*/		then write(md)=Nls.Ptr+Num-1;	/*	temporarily store remapped reverse ptr	*/		write(mal)=NLS.TRK;				/*	access trk number of NLS	*/		strk=read(md);						/*	save original trk number	*/		if read(md)>num.kbd.tracks		then write(md)=logical.trk;	/*	temporarily set to logical val	*/		if Output.Chunk(Nah.Ptr+Ptr,0,256)=0		then Edit.Error=E#NoRoom;		/*	after writing out NLS, we need to restore the NLS.FOR	*/		/*	and NLS.REV ptrs back to their original values so our	*/		/*	in memory copy of the sequence is still correct			*/		write(mam)=Nah.Ptr+Ptr;		write(mal)=NLS.FOR;		if sfor<>0 then write(md)=sfor;		/*	restore forward ptr to original value	*/		write(mal)=NLS.REV;		if srev<>0 then write(md)=srev;		/*	restore reverse ptr to original value	*/		write(mal)=NLS.TRK;						/*	access trk number of NLS	*/		if strk>num.kbd.tracks then write(md)=strk;	/*	restore trk to original value	*/		num=num+1;									/*	increment count of sectors used by track	*/		ptr=sfor;									/*	ptr to next nls for loop	*/	end;	call Trk.Head.Store(data.trk, THD.STIMB,     stimb);	/*	restore original timbre number to trk head	*/	call Trk.Head.Store(data.trk, THD.USAGE,     stimb);	/*	restore usage table too	*/	call Trk.Head.Store(data.trk, THD.GROUPLIST, grouplist);	/*	restore group list	*/	return num;						/*	return sector len written to disk	*/end WRITEOUT.TRACK;/*	$SUBTITLE	*/WRITE.NOTES: proc (trks,timbres,start,finish,nah.head) fixed swapable;	dcl trks						array;	/*	16 words of bits representing which trks to edit	*/	dcl timbres					array;	/*	bits corresponding to timbres used by edit	*/	dcl (start, finish)		array;	/*	start and end time of edit	*/	dcl nah.head				fixed;	/*	ptr (relative to NAH.PTR) to temp NAH header sector	*/	dcl (status, trk)			fixed;	dcl (startlen, nls.ptr)	fixed;	dcl (msb, lsb)				fixed;	dcl trk.len					fixed;	dcl (sindx, sbit)			fixed;	call Erase.Track(Sou.Copy);		/*	make sure track is erased to start	*/	if Edit.Error=0 then do;		/*	flush output buffer just to be safe to	*/		/*	make sure we are aligned on a sector	*/		/*	boundary for writing out note area		*/		if Flush.Output=0 then Edit.Error=E#NoRoom;	end;	/*	save ptr to current disk position	*/	/*	so we can write out the NAH Header	*/	/*	after we finish writing out all		*/	/*	the individual tracks					*/	msb=DiskDev; lsb=DiskSec;						/*	compute ptr to next sector in	*/	lsb=lsb+TotalSecs;								/*	temp disk file						*/	if lsb ilt TotalSecs then msb=msb+1;	startlen=TotalSecs;								/*	used to calculate total length of note area	*/	if Edit.Error=0 then do;						/*	write out sector of zeroes		*/		if Output.Chunk(0,0,256)=0					/*	to NAH header so we advance	*/		then Edit.Error=E#NoRoom;					/*	disk ptrs beyond header sec	*/		Nls.Ptr=1;										/*	init nah ptr to first trk to be written	*/	end;	/*	$PAGE	*/	sindx=t#indx; sbit=t#bit;						/*	save current values since we trash them below	*/	call Set.Start.Bit(Num.Kbd.Tracks);			/*	start with first track after keyboard trks	*/	trk=Get.Next.Bit(trks);							/*	get first track to edit	*/	do while (trk<>(-1)) and (Edit.Error=0);	/*	loop through trks to edit	*/		write(mam)=Trk.Head;							/*	look up ptr to our track	*/		write(mal)=trk;		if read(md)<>0 then do;						/*	trk has a header	*/			if not Partial.Track.Copy(trk,sou.copy,start,finish)			then Edit.Error=E#NoRoom;				/*	just ran out of memory	*/			if Edit.Error=0 then do;				write(mam)=Trk.Head;					/*	look up ptr to the temp trk	*/				write(mal)=sou.copy;				if read(md)<>0 then do;				/*	temp trk has a header	*/					write(mam)=Nah.Ptr+Nah.Head;	/*	set up ptr to our NAH head sector	*/					write(mal)=trk;					/*	save relative ptr to	*/					write(md )=Nls.Ptr;				/*	start of our trk		*/					trk.len=WriteOut.Track(Sou.Copy,trk,Timbres,Start,Finish,Nls.Ptr);	/*	loop over sectors and write to disk	*/					Nls.Ptr=Nls.Ptr+trk.len;		/*	next trk will be written here	*/				end;			end;			call Erase.Track(Sou.Copy);			/*	erase track after each write	*/		end;		trk=Get.Next.Bit(trks);						/*	get next trk to process	*/	end;	if Edit.Error=0 then do;		if Flush.Output=0								/*	Finish up with last diskwrite	*/		then Edit.Error=E#NoRoom;					/*	file got too long	*/		else DO;			call Ext.WriteData(Msb,Lsb,Nah.Ptr+Nah.Head,0,1,0);	/*	write out NAH header sector	*/			/*	PRINT 'EXT.WRITEDATA(MSB,LSB,NAH.PTR+NAH.HEAD,0,1,0)';	*/			/*	print '            ',MSB,LSB,NAH.PTR+NAH.HEAD;				*/		END;	end;	t#indx=sindx; t#bit=sbit;						/*	restore to original values	*/	return TotalSecs-StartLen;						/*	sectors written out in NAH area	*/end WRITE.NOTES;/*	$SUBTITLE Routines to Delete/Erase Time/Notes in a Region of a Sequence	*/PUNCH.REGION: proc (trks,start,len,delete.time) public swapable;	/*	removes time & notes from START to FINISH on specified tracks	*/	dcl trks				array;	/*	16 words of bits representing which trks to edit	*/	dcl start			array;	/*	32-bit millisecond region start time	*/	dcl len				array;	/*	32-bit millisecond region length	*/	dcl delete.time	boolean;	/*	true to erase time, else just erase notes	*/	dcl trk				fixed;	dcl (sindx, sbit)	fixed;	dcl finish	(1)	fixed;	sindx=t#indx; sbit=t#bit;					/*	save current values since we trash them below	*/	call Set.Start.Bit(Num.Kbd.Tracks);		/*	start with first non-kbd track	*/	trk=Get.Next.Bit(trks);						/*	get first used track	*/	do while (trk<>(-1)) and (Edit.Error=0);	/*	loop over all tracks	*/		if (apply.filter) then do;			call add32(start, len, finish);			call Filter.Cut.Region(trk, start, finish, false);		end;		if (delete.time) or (not apply.filter)	/*	CUTTING or MOVING w/o filtering	*/		then if Punch.Notes.From.Trk(trk,start(0),start(1),len(0),len(1),delete.time,true)=0		then Edit.Error=E#NoRoom;		trk=Get.Next.Bit(trks);					/*	get next used track	*/	end;	t#indx=sindx; t#bit=sbit;					/*	restore to original values	*/end PUNCH.REGION;/*	$SUBTITLE  Routine to Perform CUT, COPY, and MOVE	*//*	CUT, COPY, MOVE operation literals	dcl EDIT#Cut	lit '0'; dcl EDIT#Copy	lit '1'; dcl EDIT#Move	lit '2';	*/CUT.COPY.MOVE: proc (operation,trks,start,finish,dest) public swapable;	dcl operation		fixed;	/*	0=cut, 1=copy, 2=move	*/	dcl trks				array;	/*	16 words of bits representing which trks to edit	*/	dcl start			array;	/*	32-bit millisecond IN  time	*/	dcl finish			array;	/*	32-bit millisecond OUT time	*/	dcl dest				array;	/*	treename for where to put extracted notes (null string to use default)	*/	dcl ClipBoard.Name(32)	fixed;	/*	set aside a large array to hold a treename	*/	dcl (msb, lsb)				fixed;	dcl timbres			(15)	fixed;	dcl numtimbs				fixed;	dcl Temp.Seq.Header		fixed;	dcl Temp.Nah.Header		fixed;	dcl Disk.Par.Len			fixed;	dcl Disk.Nah.Len			fixed;	dcl region.len		(1)	fixed;	dcl (m, l)					fixed;	dcl i							fixed;	/*	CUT.COPY.MOVE creates a new sequence in the file specified	*/	/*	by DEST which is extracted from the sequence in memory.		*/	/*	The various CUT, COPY, and MOVE operations affect the			*/	/*	in different ways:														*/	/*		CUT:  Removes the time and the notes from the source		*/	/*		COPY: Takes a copy of the time and notes from source		*/	/*		MOVE: Removes just the notes from the source					*/	if  (start(0) IGT finish(0))							/*	times are swapped	*/	or ((start(0) ==  finish(0))	and (start(1) IGT finish(1)))	then do;														/*	so reverse start and finish	*/		region.len(0)=start     (0); region.len(1)=start     (1);		start     (0)=finish    (0); start     (1)=finish    (1);		finish    (0)=region.len(0); finish    (1)=region.len(1);	end;	if start(0)=0 and start(1) ilt zero.time			/*	make sure time is ok	*/	then start(1)=zero.time;	if finish(0)=0 and finish(1) ilt zero.time		/*	make sure time is ok	*/	then finish(1)=zero.time;	region.len(0)=finish(0)-start(0);	region.len(1)=finish(1)-start(1);	if start(1) igt finish(1) then region.len(0)=region.len(0)-1;	if (region.len(0)\region.len(1))=0 then return false;	/*	nothing selected	*/	Edit.Error=0;													/*	reset flag	*/	call Optimize.Tracks.To.Edit(trks);						/*	only process tracks that aren't empty	*/	NumTimbs=Compute.Affected.Timbres(trks,timbres);	/*	figure out which timbres are needed		*/	Temp.Seq.Header=Allocate.Nah.Block;						/*	get a sector to hold new seq base info	*/	Temp.Nah.Header=Allocate.Nah.Block;						/*	and one to hold nah ptrs	*/	if (Temp.Seq.Header=0) or (Temp.Nah.Header=0)		/*	could not allocate temp sectors	*/	then do;															/*	not enough memory to do edit	*/		if Temp.Seq.Header<>0 then call Deallocate.Nah.Block(Temp.Seq.Header);	/*	free up allocated sectors	*/		if Temp.Nah.Header<>0 then call Deallocate.Nah.Block(Temp.Nah.Header);		/*	generate some reasonable error message	*/		return E#NoRoom;	end;	/*	$PAGE	*/	do lsb=0 to shr(dest(0)+1,1); ClipBoard.Name(lsb)=dest(lsb); end;	/*	copy dest file name into temp	*/	if Open.ClipBoard(ClipBoard.Name) then do;	/*	was able to get an edit buffer	*/		call Copy.Ext.Mem(Bas.Ptr,0,Nah.Ptr+Temp.Seq.Header,0,256);	/*	load copy of seq header into temp buffer	*/		/*	Open.ClipBoard sets up catalog global vars	*/		/*	and primes the disk output buffer				*/		msb=F#MS_Sector; lsb=F#LS_Sector;				/*	save file ptr in temps	*/		if (Output.Chunk(0,0,256)	== 0)					/*	write out 2 sectors of zeroes into	*/		or (Output.Chunk(0,0,256)	== 0)					/*	Seq Header just for safety's sake	*/		or (Flush.Output				== 0)					/*	get aligned on sector boundary & update TOTALSECS var	*/		then Edit.Error=E#NoRoom;							/*	ran out of disk file space	*/		if Edit.Error=0 then do;			Disk.Par.Len=Write.Timbres(Timbres);		/*	write timbres to disk	*/			write(mam)=Nah.Ptr+Temp.Seq.Header;			/*	set up ptr & len		*/			write(mal)=Seq.Bas;								/*	info for seq header	*/			write(mdi)=0;			write(md )=2;			write(mam)=Nah.Ptr+Temp.Seq.Header;			/*	write out parameter	*/			write(mal)=Seq.Par;								/*	ptr and len info		*/			write(mdi)=2;										/*	to sequence header	*/			write(md )=Disk.Par.Len;		end;		if Edit.Error=0 then do;							/*	write out note area	*/			call Copy.Ext.Mem(0,0,Nah.Ptr+Temp.Nah.Header,0,256);	/*	zero out temp Nah Sector	*/			Disk.Nah.Len=Write.Notes(trks,timbres,start,finish,Temp.Nah.Header);	/*	write notes to disk	*/			write(mam)=Nah.Ptr+Temp.Seq.Header;			/*	write out note			*/			write(mal)=Seq.Nah;								/*	ptr and len info		*/			write(mdi)=2+Disk.Par.Len;						/*	to sequence header	*/			write(md )=Disk.Nah.Len;		end;		if Edit.Error=0 then do;	/*	Write out Seq Header Stuff for new sequence	*/			write(mam)=Nah.Ptr+Temp.Seq.Header;	/*	finish writing out seq info	*/			write(mal)=Seq.SMBits;			write(mdi)=0; write(mdi)=0; write(md)=0;	/*	rezero SMPTE offset time	*/			write(mal)=Seq.Mark.Msb;				/*	and turn off any MARK setting	*/			write(mdi)=0; write(md)=0;			m=Region.Len(0);							/*	compute end time of region	*/			l=Region.Len(1)+zero.time;			if l ilt zero.time then m=m+1;			write(mal)=Seq.Loop;						/*	set up Overall Loop		*/			write(mdi)=1;								/*	to match region edited	*/			write(mal)=Seq.S.P.T;			write(mdi)=zero.time; write(md)=0;			write(mal)=Seq.G.P.T;			write(mdi)=l;         write(md )=m;			write(mal)=Seq.NumSec;					/*	total seq len	*/			write(md )=Disk.Par.Len+Disk.Nah.Len+2;			write(mal)=Seq.Inf;								/*	info area ptr	*/			write(mdi)=Disk.Par.Len+Disk.Nah.Len+2;	/*	would start here	*/			write(md )=0;										/*	but no info data	*/			write(mal)=Seq.NumTimbs;				/*	and write out number of timbres in seq	*/			write(md )=NumTimbs;			write(mal) = Seq.Cbits.Valid;			/*	save which tracks have been cut		*/			write(mdi) = 1;							/*	indicate that bits have been saved	*/			do i = 0 to 15;							/*	write out bit words						*/				write(mdi) = trks(i);			end;			call Ext.WriteData(msb,lsb,Nah.Ptr+Temp.Seq.Header,0,1,0);	/*	write out 1st sector of seq header	*/			/*	PRINT 'EXT.WRITEDATA(MSB,LSB,NAH.PTR+TEMP.SEQ.HEADER,0,1,0)';	*/			/*	print '            ',MSB,LSB,NAH.PTR+TEMP.SEQ.HEADER;				*/		end;	end;	else Edit.Error=E#NoOpenClip;	/*	problem opening clipboard	*/	/*	$PAGE	*/	/*	last of all free up the TEMP.NAH.HEADER & TEMP.SEQ.HEADER memory	*/	if Temp.Seq.Header<>0 then call Deallocate.Nah.Block(Temp.Seq.Header);	/*	free up allocated sectors	*/	if Temp.Nah.Header<>0 then call Deallocate.Nah.Block(Temp.Nah.Header);	if Edit.Error=0 then do;	/*	edit was successful	*/		if not ClipBoard.is.WorkFile	/*	don't shorten work file	*/		then call Shorten.Disk.File(ClipBoard.Name,Disk.Par.Len+Disk.Nah.Len+2);	/*	shorten ClipBoard file to optimal size	*/		/*	At this point, we need to delete info from source trks	*/		/*	if operation was a CUT or a MOVE									*/		if (Operation=EDIT#Cut)  then call Punch.Region(trks,start,region.len,true);		if (Operation=EDIT#Move) then call Punch.Region (trks,start,region.len,false);	end;	call Compute.Active.Trks;			/*	recompute all THD.ACTIVE bits	*/	call Check.Memory.For.Record;		/*	put memory into optimal state	*/	call Play.Initialize;				/*	reset sequencer		*/	if Edit.Error=0 then do;			/*	edit was successful	*/		call Compute.Numb.Left;			/*	show notes left		*/		call Display.Numb.Left;			/*	ditto						*/	end;	else call Abort.Edit(ClipBoard.Name);	/*	delete temp edit file	*/	return (Edit.Error);		/*	return error status	*/end CUT.COPY.MOVE;