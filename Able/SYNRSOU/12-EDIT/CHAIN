/* $TITLE :SYNRSOU:12-EDIT:CHAIN - ROUTINES TO CHAIN TRACKS TOGETHER *//*Modified:1998/04/29 - TY  - Fixed the following three bugs in CHAIN.TRACKS:						 1) The chained notes were rippled 50 ms late when the source track started in measure 0 and							 the destination track was not empty.						 2) The chained notes were rippled 50 ms early when the source track started in any measure							 other than 0 and the destination track was empty.						 3) If the source track started in measure 0, had a loop length shorter than the measure length,							 and was chained onto itself, the chained notes started at one measure after the loop start							 rather than at one loop length after the loop start.						 Since these bugs were artifacts of the way CHAIN.TRACKS worked, it was necessary to redesign						 it and it's nested procedures almost from the ground up.  In the process, the following						 variables and arrays were removed (along with a good deal of redundant code):						 ILP.ON.SOU, ILP.ON.DES, MSB, LSB, MEASURE.MSB, MEASURE.LSB, COUNTIN.MSB, COUNTIN.LSB,						 DES.COUNTIN.MSB, DES.COUNTIN.LSB, DES.FIRSTNOTE.MSB, DES.FIRSTNOTE.LSB,						 DES.LOOPLEN.MSB, DES.LOOPLEN.LSB, TEMP(1), BEATS(1).						 The remaining variables were renamed to make the code a bit more comprehensible.					  - Removed the following unnecessary variables and more redundant code from ROUND.MEASURE.INFO:						 FIRST.NOTE, I, J.					  - Combined COMPUTE.TRK.MEASURE.LEN and ROUND.MEASURE.INFO into one procedure because they are						 always called together in immediate succession.					  - Moved the declaration of MEASURE(2) from COMPUTE.TRK.MEASURE.LEN to CHAIN.TRACKS and declared						 as STATIC so that it could be accessed from both procedures.1990/07/16 - PF  - Made CHAIN work with Meter Map1988/10/15 - TSS - Keep protocol output running during CHAIN.TRACKS1988/02/25 - eg  - changed some bounce.down calls in chain to FAST.COPY1987/11/05 - EG  - ADDED TRKS ARGUMENT TO UNWRAP.SEQUENCE1987/10/27 - eg  - made chaining live tracks an error (for now, anyway)1987/07/30 - EG  - ADDED CALL TO QUICK.PLAY.INIT AFTER REMOVE.ILP1986/12/04 -TS,CJ- FIXED BUG IN GET.THD.PTR1986/12/01 - TS  - CREATED THIS FILE FROM 'EDITPRIM'*//* WHEN CHAIN.TRACKS IS DONE, YOU MUST BE SURE TO CALL *//* PLAY.INITIALIZE BEFORE LETTING THE USER GET AT THE  *//* SEQUENCE AGAIN                                      */DCL SET.START.BIT proc (fixed) recursive;DCL GET.NEXT.BIT  proc (array) recursive;CHAIN.TRACKS: PROC (SOU.TRK,DES.TRK) PUBLIC SWAPABLE;	DCL (SOU.TRK,DES.TRK)	FIXED;	/* SOURCE AND DEST TRKS FOR CHAIN */	DCL (STATUS,CHAIN#)		FIXED;	DCL (SOU.MeasureBoundary.MSB,	SOU.MeasureBoundary.LSB)	FIXED;	DCL (SOU.StartTime.MSB,			SOU.StartTime.LSB)			FIXED;	DCL (SOU.ChainLength.MSB,		SOU.ChainLength.LSB)			FIXED;	DCL (SOU.EndTime.MSB,			SOU.EndTime.LSB)				FIXED;	DCL (DES.EndTime.MSB,			DES.EndTime.LSB)				FIXED;	DCL (DES.MeasureBoundary.MSB,	DES.MeasureBoundary.LSB)	FIXED;	/* GLOBALS SET BY COMPUTE.TRK.MEASURE.LEN */	DCL (StartTime.MSB,   StartTime.LSB)	FIXED STATIC;	DCL (EndTime.MSB,     EndTime.LSB)		FIXED STATIC;	DCL (ChainLength.MSB, ChainLength.LSB)	FIXED STATIC;		DCL MEASURE(2)									FIXED STATIC;	DCL QUICK.BOUNCE LIT '1';	/* SET TO 0 FOR SLOW, FULL BOUNCE, 1 FOR QUICK VERSION */	/* COMPUTE.TRK.MEASURE.LEN FINDS THE FIRST AND LAST REAL NOTE ON A TRACK.		THE ABSOLUTE TIME OF THE FIRST NOTE IS PLACED IN (StartTime.MSB,StartTime.LSB).		THE ABSOLUTE TIME OF THE LAST NOTE IS PLACED IN (EndTime.MSB,EndTime.LSB).		(StartTime.MSB,StartTime.LSB) ARE ROUNDED DOWN TO THE PREVIOUS MEASURE BOUNDARY.		(EndTime.MSB,EndTime.LSB) ARE ROUNDED UP TO THE NEXT MEASURE BOUNDARY.		(ChainLength.MSB,ChainLength.LSB) ARE THEN COMPUTED */	COMPUTE.TRK.MEASURE.LEN: PROC (TRK);	/* COMPUTES TRK LEN IN MSEC ROUNDED UP TO NEXT MEASURE */		DCL (TRK,FIRST.NOTE)				FIXED;		StartTime.MSB = 0; StartTime.LSB = ZERO.TIME;		EndTime.MSB   = 0; EndTime.LSB   = ZERO.TIME;		FIRST.NOTE = true;		WRITE(MAM)=TRK.HEAD; WRITE(MAL)=TRK;		#PTR=READ(MD); #TRK=TRK;		if #PTR<>0 then do;							/* IF TRK HEAD EXISTS */			CALL QUICK.PLAY.INIT(#PTR);			/* GET PTRS BACK TO START OF TRK */			CALL LOAD.#.INFO(THD.NMSB);			/* INIT # VARS */			if #SEC<>0 then do;						/* IF THERE IS A NLS */				if #ANYF<>0 then do;					/* HAVE SOME NOTES ON THE TRK */					WRITE(MAM)=NAH.PTR+#SEC;					WRITE(MAL)=#WRD;							DO WHILE #ANYF<>0;						/* ZIP OUT TO END OF TRK */						#W1=READ(MDI); #W2=READ(MDI); #W3=READ(MD);	/* PUT FIRST 3 WORDS IN TEMPS */								IF  ((#W1&"100000")=0)				/* NOT AN ALTERNATE FORMAT NOTE */						AND (((#W1)      & ((#W3&SHL(B.UPD,8))=0))	/* 4-WORD NON-UPDATE RECORD */						OR  (((#W1&1)=0) & ((#W2&"77")<>REST.NOTE)))	/* 2-WORD NON-REST NOTE */						THEN DO;									/* SAVE TIME OF THIS REAL NOTE */							EndTime.MSB=#NMSB; EndTime.LSB=#NLSB;							IF FIRST.NOTE<>false THEN DO;	/* THIS IS FIRST REAL NOTE */								StartTime.MSB=#NMSB; StartTime.LSB=#NLSB;								FIRST.NOTE=false;							END;						END;						CALL ADVANCE.TO.NEXT.NOTE;			/* STEP TO NEXT NOTE OUT */					END;				end;			end;		end;		IF (EndTime.MSB=0) AND (EndTime.LSB ILT ZERO.TIME)		THEN EndTime.LSB = ZERO.TIME;				/* WIERD CASE */		ELSE DO;			/* ROUND EndTime UP TO NEXT MEASURE BOUNDARY */			Call Map.Sequence.Time.To.Measures.Beats(loc(addr(EndTime.MSB)),Measure);			Measure(0)=Measure(0)+1;				/* round measure# up */			Measure(1)=1;								/* zero beat number  */			Measure(2)=0;								/* and fractions     */			Call Map.Measures.Beats.To.Sequence.Time(Measure,loc(addr(EndTime.MSB)));			/* ROUND StartTime DOWN TO PREVIOUS MEASURE BOUNDARY */			Call Map.Sequence.Time.To.Measures.Beats(loc(addr(StartTime.MSB)),Measure);			Measure(1)=1;								/* remove any beats */			Measure(2)=0;								/* or fractions     */			Call Map.Measures.Beats.To.Sequence.Time(Measure,loc(addr(StartTime.MSB)));			ChainLength.MSB = EndTime.MSB - StartTime.MSB;	/* ChainLength = TOTAL LEN - COUNTIN */			ChainLength.LSB = EndTime.LSB - StartTime.LSB;			IF EndTime.LSB ILT StartTime.LSB THEN ChainLength.MSB = ChainLength.MSB-1;	/* carry */		END;	END COMPUTE.TRK.MEASURE.LEN;	/* $SUBTITLE  MAIN BODY OF CHAIN TRACKS CODE */	/*IF DEBUG THEN DO;*/		/* SOMEWHERE IN HERE YOU NEED TO DO LOTS OF CHECKING  */		/* TO TRY TO GUESS WHETHER OR NOT THE CHAIN OPERATION */		/* IS GOING TO HAVE ENOUGH MEMORY TO COMPLETE         */	/*END;*/	IF CLICK.TRACK.MODE igt 3	THEN DO;						/* ILLEGAL (I.E. SOFTWARE NOT THERE) TO CHAIN LIVE CLICK TRACKS */		CALL DISPLAY.ERR(59);		CALL CHAIN.LIVE.CLICK.ERROR;		RETURN 0;	END;	WRITE(MAM)=TRK.HEAD; WRITE(MAL)=SOU.TRK;	IF READ(MD)=0 THEN RETURN 1;	/* NOTHING TO CHAIN - ALL DONE */	WRITE(MAM)=TRK.HEAD; WRITE(MAL)=DES.TRK;	IF READ(MD)=0 THEN DO;			/* DES TRK HAS NO TRK HEAD - CREATE ONE */		/* WHAT TO DO HERE? */	END;	ELSE DO;								/* NEED TO MAKE SURE TIMBRES ON SOURCE & DEST MATCH */		IF  ((TRK.HEAD.LOOKUP(DES.TRK,THD.CTIMB )<>0))	/* HAVE A TIMBRE ON DES TRK  */		AND ((TRK.HEAD.LOOKUP(SOU.TRK,THD.CTIMB )<>0))	/* AND A TIMBRE ON SOU TRK   */		AND ((TRK.HEAD.LOOKUP(DES.TRK,THD.NN.MSB)<>0)	/* AND DES TRK HAS SOME      */		OR   (TRK.HEAD.LOOKUP(DES.TRK,THD.NN.LSB)<>0))	/* NOTES ON IT               */		AND (OK.TO.COPY.TIMBRE(SOU.TRK,DES.TRK)=0)		/* BUT TIMBRE DOES NOT MATCH */		THEN DO;			CALL DISPLAY.ERR(53);	/* 'TIMBRES MUST MATCH FOR CHAIN' */			RETURN 0;					/* BOMB OUT */		END;	END;	/* COMPUTE LENGTH VARIABLES FOR BOTH SOURCE AND DESTINATION TRACKS */	IF TRK.HEAD.LOOKUP(SOU.TRK,THD.ILP)<>0 THEN DO;	/* SOURCE TRK HAS ILP - USE LOOP INFO */		CALL TRK.HEAD.LOOKUP(SOU.TRK,THD.COUNTIN.MSB);		SOU.StartTime.MSB   = READ(MDI); SOU.StartTime.LSB   = READ(MDI);	/* GET LOOP START TIME */		SOU.ChainLength.MSB = READ(MDI); SOU.ChainLength.LSB = READ(MD );	/* GET LOOP LENGTH     */		SOU.EndTime.MSB = SOU.StartTime.MSB + SOU.ChainLength.MSB;		SOU.EndTime.LSB = SOU.StartTime.LSB + SOU.ChainLength.LSB;		IF SOU.EndTime.LSB ILT SOU.StartTime.LSB THEN SOU.EndTime.MSB = SOU.EndTime.MSB+1;	/* CARRY */		/* ROUND SOU.StartTime DOWN TO PREVIOUS MEASURE BOUNDARY AND PLACE IN SOU.MeasureBoundary */		Call Map.Sequence.Time.To.Measures.Beats(loc(addr(SOU.StartTime.MSB)),Measure);		Measure(1)=1;					/* remove any beats */		Measure(2)=0;					/* or fractions     */		Call Map.Measures.Beats.To.Sequence.Time(Measure,loc(addr(SOU.MeasureBoundary.MSB)));			END;	ELSE DO;														/* ACTUALLY LOOK AT TRK AND COMPUTE CHAIN LENGTHS */		CALL COMPUTE.TRK.MEASURE.LEN(SOU.TRK);		SOU.MeasureBoundary.MSB	= StartTime.MSB  ;SOU.MeasureBoundary.LSB	= StartTime.LSB;		SOU.StartTime.MSB			= StartTime.MSB  ;SOU.StartTime.LSB			= StartTime.LSB;		SOU.ChainLength.MSB		= ChainLength.MSB;SOU.ChainLength.LSB		= ChainLength.LSB;		SOU.EndTime.MSB			= EndTime.MSB	  ;SOU.EndTime.LSB			= EndTime.LSB;	END;	IF TRK.HEAD.LOOKUP(DES.TRK,THD.ILP)<>0 THEN DO;	/* DEST TRK HAS ILP - USE LOOP INFO */		CALL TRK.HEAD.LOOKUP(DES.TRK,THD.COUNTIN.MSB);		StartTime.MSB = READ(MDI); StartTime.LSB = READ(MDI);	/* GET LOOP START TIME */		DES.EndTime.MSB = StartTime.MSB + READ(MDI);				/* LOOP START TIME + LOOP LENGTH */		DES.EndTime.LSB = StartTime.LSB + READ(MD );				/* LOOP START TIME + LOOP LENGTH */		IF DES.EndTime.LSB ILT StartTime.LSB THEN DES.EndTime.MSB = DES.EndTime.MSB+1;	/* CARRY */		/* ROUND DES.EndTime UP TO NEXT MEASURE BOUNDARY AND PLACE IN DES.MeasureBoundary */		Call Map.Sequence.Time.To.Measures.Beats(loc(addr(DES.EndTime.MSB)),Measure);		if (Measure(1) ine 1 or Measure(2) ine 0) then do;			Measure(0)=Measure(0)+1;	/* round measure# up */			Measure(1)=1;					/* zero beat number  */			Measure(2)=0;					/* and fractions     */		end;		Call Map.Measures.Beats.To.Sequence.Time(Measure,loc(addr(DES.MeasureBoundary.MSB)));	END;	ELSE DO;														/* ACTUALLY LOOK AT TRK AND COMPUTE DEST TRK LENGTH */		CALL COMPUTE.TRK.MEASURE.LEN(DES.TRK);		DES.EndTime.MSB			= EndTime.MSB;	DES.EndTime.LSB			= EndTime.LSB;		DES.MeasureBoundary.MSB	= EndTime.MSB;	DES.MeasureBoundary.LSB	= EndTime.LSB;	END;	/* MAKE COPY OF ORIGINAL SOURCE TRK.  BUT ONLY KEEP NOTES ON THE        */	/* SOURCE TRK WHICH ARE BEFORE THE ILP END IF THE TRK HAS AN ILP ON IT. */	/* STATUS=BOUNCE.DOWN(SOU.TRK,SOU.COPY,QUICK.BOUNCE,TRUE); */	/* COPY SOURCE TO TEMP TRK */	STATUS=FAST.COPY(SOU.TRK,SOU.COPY);										/* COPY SOURCE TO TEMP TRK */	IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */	IF TRK.HEAD.LOOKUP(SOU.COPY,THD.ILP) <> 0	THEN CALL REMOVE.ILP.FROM.TRACK(SOU.COPY);				/* GET RID OF ILP ON SOURCE COPY TRK */		STATUS=DELETE.TIME.FROM.TRK(SOU.COPY,SOU.EndTime.MSB,SOU.EndTime.LSB,-1,-1);		/* DELETE ANY STUFF AFTER EndTime */	IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */	STATUS=DELETE.TIME.FROM.TRK(SOU.COPY,0,0,SOU.StartTime.MSB,SOU.StartTime.LSB);	/* DELETE ANY STUFF PRIOR TO StartTime */	IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */	STATUS=INSERT.TIME.ON.TRK(SOU.COPY,0,0,SOU.StartTime.MSB,SOU.StartTime.LSB);		/* REINSERT DELETED TIME */	IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */		/* First we need to slide SOU.COPY to start at the time at which it will be appended to the destination track */	if SOU.TRK ieq DES.TRK	/* If we're unwrapping loops then simply insert SOU.ChainLength */	then do;		STATUS=INSERT.TIME.ON.TRK(SOU.COPY,0,0,SOU.ChainLength.MSB,SOU.ChainLength.LSB);		IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;					/* TIME TO BOMB OUT */	end;	else do;		if (SOU.MeasureBoundary.MSB ine DES.MeasureBoundary.MSB) or (SOU.MeasureBoundary.LSB ine DES.MeasureBoundary.LSB)		then do;			/* We need to slide SOU.COPY such that SOU.MeasureBoundary aligns with DES.MeasureBoundary.				Since (ChainLength.MSB,ChainLength.LSB) are not used beyond this point in the procedure,				we can use them here to hold the insert or delete times. */			/* if SOU.MeasureBoundary < DES.MeasureBoundary then insert difference */			if (SOU.MeasureBoundary.MSB ilt DES.MeasureBoundary.MSB)			or ((SOU.MeasureBoundary.MSB ieq DES.MeasureBoundary.MSB)			and (SOU.MeasureBoundary.LSB ilt DES.MeasureBoundary.LSB))			then do;				ChainLength.MSB = DES.MeasureBoundary.MSB - SOU.MeasureBoundary.MSB;				ChainLength.LSB = DES.MeasureBoundary.LSB - SOU.MeasureBoundary.LSB;				if DES.MeasureBoundary.LSB ilt SOU.MeasureBoundary.LSB				then ChainLength.MSB = ChainLength.MSB - 1;	/* Carry */				STATUS=INSERT.TIME.ON.TRK(SOU.COPY,0,0,ChainLength.MSB,ChainLength.LSB);				IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;			/* TIME TO BOMB OUT */			end;			/* else if SOU.MeasureBoundary > DES.MeasureBoundary then delete difference */			else do;				ChainLength.MSB = SOU.MeasureBoundary.MSB - DES.MeasureBoundary.MSB;				ChainLength.LSB = SOU.MeasureBoundary.LSB - DES.MeasureBoundary.LSB;				if SOU.MeasureBoundary.LSB ilt DES.MeasureBoundary.LSB				then ChainLength.MSB = ChainLength.MSB - 1;	/* Carry */				STATUS=DELETE.TIME.FROM.TRK(SOU.COPY,0,0,ChainLength.MSB,ChainLength.LSB);				IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;			/* TIME TO BOMB OUT */			end;		end;	end;	/* NOW BEGIN TO CHAIN THE SOURCE COPY TRK ONTO THE TEMP CHAIN TRK */	CALL CLEAR.UPPER;							/* SHOW WHAT IS HAPPENING IN WINDOW */	CALL EMIT.STRING(0,'CHAIN # 1');	/* Force an immediate update to the VK display on remote devices */	/* to provide an immediate update of the VK window display while */	/* we are chaining sequencer tracks:                             */	call Flush.VK.Display.To.Termulators;	/* CHAIN FIRST COPY OF SOURCE */	/* STATUS=BOUNCE.DOWN(SOU.COPY,CHAIN.TRK,QUICK.BOUNCE,TRUE);*/	STATUS=FAST.COPY(SOU.COPY,CHAIN.TRK);	IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;							/* TIME TO BOMB OUT */	DO CHAIN#=2 TO CHAIN.REPETITIONS;			/* LOOP OVER REMAINING REPETITIONS */		CALL CLEAR.UPPER;								/* SHOW WHAT IS HAPPENING IN WINDOW */		CALL EMIT.STRING(0,'CHAIN #');		CALL EMIT.NUMBER(8,CHAIN#,0,LEFT.JUST);		/* Force an immediate update to the VK display on remote devices */		/* to provide an immediate update of the VK window display while */		/* we are chaining:                                              */		call Flush.VK.Display.To.Termulators;		/* CHAIN NEXT COPY OF SOURCE */		STATUS=INSERT.TIME.ON.TRK(SOU.COPY,0,0,SOU.ChainLength.MSB,SOU.ChainLength.LSB);		IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */		STATUS=BOUNCE.DOWN(SOU.COPY,CHAIN.TRK,QUICK.BOUNCE,TRUE);		IF STATUS=0 THEN GOTO DONE.WITH.CHAIN;						/* TIME TO BOMB OUT */	END;	DONE.WITH.CHAIN:	IF STATUS<>0 THEN DO;							/* CHAIN WAS SUCCESSFUL */		/* GET RID OF OUR TEMP COPY OF THE SOURCE TRK  */		/* AND THEN BOUNCE OUR TEMP CHAIN TRK ONTO THE */		/* ACTUAL DESTINATION TRK                      */		CALL ERASE.TRACK(SOU.COPY);				/* DONE WITH THIS TRK */		IF TRK.HEAD.LOOKUP(DES.TRK,THD.ILP) <> 0		THEN DO;			CALL REMOVE.ILP.FROM.TRACK(DES.TRK);			WRITE(MAM)=TRK.HEAD;			WRITE(MAL)=DES.TRK;			CALL QUICK.PLAY.INIT(READ(MD));		/* GET PTRS BACK TO START OF TRK */		end;		CALL DELETE.TIME.FROM.TRK(DES.TRK,DES.EndTime.MSB,DES.EndTime.LSB,-1,-1);	/* DELETE ANY STUFF AFTER EndTime */		IF BOUNCE.DOWN(CHAIN.TRK,DES.TRK,QUICK.BOUNCE,0) = 0		THEN CALL ERASE.TRACK(CHAIN.TRK);	END;	ELSE DO;		CALL ERASE.TRACK(SOU.COPY );				/* ERASE BOTH TEMP TRKS */		CALL ERASE.TRACK(CHAIN.TRK);	END;	CALL GARBAGE.COLLECT.TRK(DES.TRK);			/* MAKE SURE TRK IS COMPRESSED */	CALL CHECK.MEMORY.FOR.RECORD;					/* MAXIMIZE MEMORY FOR RECORDING */	CALL COMPUTE.ACTIVE.TRKS;						/* MAKE SURE THD.ACTIVE SET CORRECTLY */	IF QUICK.EDITS=0 THEN DO;		CALL PLAY.INITIALIZE;						/* RESET TRK INFO                */	END;	IF STATUS<>0 THEN DO;							/* CHAIN WAS SUCCESSFUL */		CALL COMPUTE.NUMB.LEFT;						/* SHOW HOW MANY NOTES ARE LEFT  */		CALL DISPLAY.NUMB.LEFT;	END;	RETURN STATUS;										/* RETURN FINAL STATE OF CHAIN */END CHAIN.TRACKS;/* $SUBTITLE */UNWRAP.TRACK: PROC (TRK,LEN.MSB,LEN.LSB) FIXED SWAPABLE;	/* UNWRAPS A TRACK WITH AN ILP TO BE SPECIFIED LENGTH */	DCL TRK               FIXED;	/* ABS TRK NUMBER TO UNWRAP */	DCL (LEN.MSB,LEN.LSB) FIXED;	/* DESIRED TRK LENGTH */	DCL (MSB,LSB)         FIXED;	DCL (LLM,LLL)         FIXED;	DCL STATUS            FIXED;	DCL SAVE.REPS         FIXED;	/* SAVES CURRENT VALUE OF CHAIN.REPETITIONS */	WRITE(MAM)=TRK.HEAD;					/* SEE IF TRK HAS A HEADER */	WRITE(MAL)=TRK;	IF READ(MD)=0 THEN RETURN 1;		/* NO HEADER, ALL DONE     */	SAVE.REPS=CHAIN.REPETITIONS;		/* SAVE SO USERS VALUE IS STILL THERE */	QUICK.EDITS=QUICK.EDITS+1;			/* SET FLAG FOR SPEEDIER EDITS */	WRITE(MAM)=READ(MD);					/* POINT AT TRK HEAD       */	WRITE(MAL)=THD.ILP;					/* DO WE HAVE AN ILP?      */	IF READ(MD)<>0 THEN DO;				/* MIGHT NEED TO CHAIN ILP */		/* NOW LOOK AT THD.COUNTIN.MSB/LSB & THD.ChainLength.MSB/LSB */		WRITE(MAL)=THD.COUNTIN.MSB;		MSB=READ(MDI); LSB=READ(MDI);	/* SAVE ILP COUNTIN IN TEMP VARS */		LLM=READ(MDI); LLL=READ(MD );	/* SAVE ILP ChainLength IN TEMP VARS */		MSB=MSB+LLM;		LSB=LSB+LLL;						/* ADD THD.ChainLength.MSB/LSB TO COUNTIN */		IF LSB ILT LLL THEN MSB=MSB+1;		/* (MSB,LSB) NOW HOLD CURRENT LENGTH OF LOOPING TRK */		/* (LLM,LLL) HOLD LENGTH OF THE LOOPING MATERIAL    */		CHAIN.REPETITIONS=0;		DO WHILE ((MSB ILT LEN.MSB))	/* FIGURE OUT HOW MANY CHAINS  */			OR    ((MSB  =  LEN.MSB)	/* OF ILP ARE NEEDED TO UNWRAP */			AND    (LSB ILT LEN.LSB));	/* TRACK TO DESIRED LENGTH     */			CHAIN.REPETITIONS=CHAIN.REPETITIONS+1;			MSB=MSB+LLM;					/* ADD ONE MORE LOOP LENGTH TO TOTAL */			LSB=LSB+LLL;			IF LSB ILT LLL THEN MSB=MSB+1;		END;		IF CHAIN.REPETITIONS<>0					/* NEED TO CHAIN TRK */		THEN STATUS=CHAIN.TRACKS(TRK,TRK);	/* UNWRAP TRK WITH ILP */		ELSE DO;										/* NO CHAINING TO DO - SUCCESSFUL */			CALL REMOVE.ILP.FROM.TRACK(TRK);	/* GET RID OF ILP ON OUR TRK */			STATUS=1;		END;	END;	ELSE STATUS=1;									/* NO ILP - NO ERRORS YET */	IF STATUS<>0 THEN DO;		STATUS=DELETE.TIME.FROM.TRK(TRK,LEN.MSB,LEN.LSB,-1,-1);	/* TRIM TRK LENGTH */	END;	QUICK.EDITS=QUICK.EDITS-1;					/* DECREMENT SPECIAL QUICK EDIT FLAG */	CHAIN.REPETITIONS=SAVE.REPS;				/* RESTORE USERS VALUE */	RETURN STATUS;END UNWRAP.TRACK;/* $PAGE */UNWRAP.SEQUENCE: PROC (TRKS,LEN.MSB,LEN.LSB) FIXED PUBLIC SWAPABLE;	DCL TRKS              ARRAY;	/* 16 words of bits representing which trks to edit */	DCL (LEN.MSB,LEN.LSB) FIXED;	/* LENGTH TO UNWRAP SEQUENCE TO */	DCL (TRK,STATUS)      FIXED;	/* NOTE: ROUTINE DOES NOT TRIM LENGTH OF TRKS WITHOUT ILPS */	CALL SET.START.BIT(num.kbd.tracks);	TRK = GET.NEXT.BIT(trks);	STATUS = 1;	DO WHILE (TRK <> (-1))			/* loop through tracks to paste */	AND      (STATUS <> 0);		IF TRK.HEAD.LOOKUP(TRK,THD.ILP)<>0		THEN STATUS=UNWRAP.TRACK(TRK,LEN.MSB,LEN.LSB);		TRK=TRK+1;		TRK = GET.NEXT.BIT(TRKS);	/* step to next track */	end;	RETURN STATUS;END UNWRAP.SEQUENCE;