/*	:SYNRSOU:11-TIMB:139-PRE2  Routines and Storage for Pre-computing Logarithms	*//*Modified:2002/07/31 - TY  - Further increased the accuracy of Log1000 for values > 1999.						 (The results now match the equivalent rounded algebraic solution.)1998/07/13 - TY  - Increased the accuracy of LOG1000 for values > 1999.1998/05/03 - TY  - Added rounding to LOG4400 to improve accuracy of precomputed partial tunings1988/08/16 -CJ,EG- FIXED COMPUTE.ACTIVE.TRKS BUG1988/06/20 - eg  - added check for thd.ignore to compute.active.trks1988/06/13 - CJ  - fixed (again) audtion track solo bug1986/11/21 - CJ  - ADDED INVERTED PARTIAL PATCHING CODE1986/11/18 - CJ  - ADDED RTE PATCHING TO TRACK VOLUME1986/09/05 -CJ,TS- FIXED PMASK BUG1986/07/31 - CJ  - CHANGED ACTIVE TRACKS FOR LIVE OVERDUB1986/06/20 - CJ  - DELETED SMPTE.MOVE REFERENCE IN COMPUTE.ACTIVE.TRACKS1986/05/15 - "official" creation of release-M modules*//*	TO SPEED UP OPERATION, THE LOGARITHMS OF CERTAIN TIMBRE PARAMETERS	ARE COMPUTED IN ADVANCE.  THEY ARE STORED IN THE TIMBRE HEADER	FOR EACH TIMBRE AND ARE ACCESSED WITH THE FOLLOWING DECLARATIONS:		TIM.LOG.RA		LOG OF RATIO		TIM.LOG.PT		LOG OF PARTIAL TUNING		TIM.LOG.NCH		HOLDS LOG OF PAR CHORUS		TIM.LOG.NCHCH	HOLDS LOG OF CHORUS/PAR CHORUS		TIM.LOG.CH		LOG OF CHORUS	*//*	LOG1000-		COMPUTE THE LOG OF A NUMBER, WHERE 1000=1.000.  IT RETURNS		THE LOG OF THE NUMBER (USING A LOG BASE OF 2) TIMES 1024.	*/#if (false)	LOG1000:PROC(VAL) PUBLIC;			/*	VAL IS 1000 = 1.000	*** NOTE: NOT CALLED FROM REAL-TIME CODE	*/		DCL (VAL,I)	FIXED;		IF VAL=0 THEN VAL=1;				/*	RATIO OF ZERO - TREAT AS .001	*/		I=0;									/*	ASSUME LOG OF ZERO	*/		DO WHILE VAL<1000; I=I-1024; VAL=SHL(VAL,1); END;		DO WHILE VAL>1999;			I=I+1024;			/*	This algorithm rounds the quotient of odd values toward an even result,	*/			/*	thereby maintaining maximum accuracy over multiple iterations.				*/			WRITE("313")=SHR(VAL,1);			VAL=READ("313")+((VAL&1)&READ("313"));		END;		VAL=VAL-1000;						/*	GET 0-999	*/		WRITE(MAM)=LTB.PTR+SHR(VAL,8);		WRITE(MAL)=VAL;		RETURN I+READ(MD);				/*	LOOK UP LOG, ADD IN, RETURN	*/	END LOG1000;#else	LOG1000: proc(value) returns (fixed) public;	//	value is 1000 = 1.000	*** NOTE: NOT CALLED FROM REAL-TIME CODE		dcl value	fixed;		dcl offset	fixed;		if (value igt 1999)		{			dcl shift_amount	fixed;			shift_amount	= 1;			while (value ige shl(2000, shift_amount))			{				shift_amount	= shift_amount + 1;			}			value = shr(value, shift_amount) + (shr(value, shift_amount-1) & 1);	//	round			if (value == 2000)			{				value				= 1000;				shift_amount	= shift_amount + 1;			}			load 1024; mul shift_amount; offset = res;	//	offset = 1024 * shift_amount;		}		else		{			offset	= 0;			if (value == 0) value = 1;				//	RATIO OF ZERO - TREAT AS .001			while	(value ilt 1000)			{				value		= shl(value, 1);				offset	= offset - 1024;			}		}		value			= value - 1000;				//	transpose into range 0 through 999		write(mam)	= LTB.PTR + shr(value, 8);	//	point to entry in log table		write(mal)	= value;		return offset + read(md);					//	return offset plus log	end LOG1000;#endifLOG4400:PROC(VAL) PUBLIC;			/*	SAME AS LOG1000 ONLY 4400=1.000	*/	DCL VAL	FIXED;	IF VAL<0 THEN VAL=-VAL;	/*	ABSOLUTE VALUE - FOR MINUS RATIOS, PARTIAL TUNINGS	*/	LOAD VAL; MUL 5; MWAIT;	/*	MULTIPLY BY THE RATIO 1000/4400	*/	DIV 22;	if (REM ige 11) load RES+1;	/*	ROUND	*/	RETURN LOG1000(RES);END LOG4400;/*	$PAGE - PRECOMPUTE LOG FUNCTIONS (RATIO, TUNING, CHORUS)	*/COMPUTE.LOGS:PROC(TB) PUBLIC SWAPABLE;		/*	PROCEDURE TO COMPUTE LOG DATA FOR SPECIFIED TIMBRE	*/	DCL (K,L,TB,PTL)	FIXED;	DCL (TIM.HEADP)	FIXED;	WRITE(MAM)=TIM.HEAD;							/*	POINT TO LOOK UP TABLE	*/	WRITE(MAL)=TB;									/*	SEE IF ENTRY THERE		*/	IF READ(MD)=0 THEN RETURN;					/*	NO INFO TO PRECOMPUTE	*/	TIM.HEADP=READ(MD);							/*	POINTER TO TIM HEAD		*/	WRITE(MAM)=TIM.HEADP;						/*	POINT TO TIMBRE HEAD		*/	WRITE(MAL)=TIM.MISC.POINTER;				/*	INDEX TO MISC POINTER	*/	K=LOG1000(P.LOOKUP(READ(MD)+CHORUS.LOC) & 16383);	/*	COMPUTE LOG OF CHORUS FUNCTION	*/	WRITE(MAM)=TIM.HEADP;						/*	POINT TO TIMBRE HEAD		*/	WRITE(MAL)=TIM.LOG.CH;						/*	LOG OF CHORUS				*/	WRITE(MD )=K;	DO PTL=0 TO (NUM.PARTIALS-1);				/*	COMPUTE PARTIAL CHORUS, PARTIAL TUING, ETC	*/		WRITE(MAM)=TIM.HEADP;					/*	POINT TO TIMBRE HEAD	*/		WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;		PTPTR=READ(MD);		WRITE(MAL)=TIM.OPTIONS+PTL;			/*	CLEAR OUR OPTIONS BITS	*/		WRITE(MD )=READ(MD) & (NOT(MIN.PTUNE \ ANY.GLIDE));		IF (P.LOOKUP(PTPTR)<>(SUP)) THEN DO;	/*	EXAMINE FURTHER IF NOT SUPPRESSED	*/			K=P.LOOKUP(PTPTR+P.RATIO);			/*	GET RATIO				*/			IF K<0 THEN	K=LOG4400(K)-10000;	/*	NEGATIVE RATIO - CONSTANT PITCH	*/			ELSE			K=LOG1000(K)+15000;	/*	NORMAL RATIO LOG		*/			WRITE(MAM)=TIM.HEADP;				/*	POINT TO TIMBRE HEAD	*/			WRITE(MAL)=TIM.LOG.RA+PTL;			/*	LOG OF RATIO ENTRY	*/			WRITE(MD )=K;			K=P.LOOKUP(PTPTR+P.PTUNING);		/*	GET PTUNING				*/			IF (K<0) THEN DO;						/*	SET MIN PTUN BIT		*/				WRITE(MAM)=TIM.HEADP;			/*	POINT TO TIMBRE HEAD	*/				WRITE(MAL)=TIM.OPTIONS+PTL;	/*	PARTIAL OPTIONS		*/				WRITE(MD )=READ(MD) \ MIN.PTUNE;			END;			K=LOG4400(K);							/*	LOG OF PARTIAL TUNING	*/			WRITE(MAM)=TIM.HEADP;				/*	POINT TO TIMBRE HEAD	*/			WRITE(MAL)=TIM.LOG.PT+PTL;			/*	LOG OF PTUNING ENTRY	*/			WRITE(MD )=K;			K=P.LOOKUP(PTPTR+P.NEW.CHORUS) & 16383;	/*	GET NEW CHORUS VALUE	*/			K=LOG1000(K);							/*	LOG OF PAR CHORUS		*/			WRITE(MAM)=TIM.HEADP;				/*	POINT TO TIMBRE HEAD	*/			WRITE(MAL)=TIM.LOG.NCH+PTL;		/*	LOG OF PAR CHORUS		*/			WRITE(MD )=K;			WRITE(MAL)=TIM.LOG.CH;				/*	LOOK UP LOG OF CHOR	*/			K=K+READ(MD);			WRITE(MAL)=TIM.LOG.NCHCH+PTL;		/*	CHORUS*PARTIAL CHOR	*/			WRITE(MD )=K;			IF P.LOOKUP(PTPTR+P.GLIDEBITS)	/*	GLIDE IS ACTIVE IF TRUE	*/			THEN DO;				WRITE(MAM)=TIM.HEADP;			/*	POINT TO TIMBRE HEAD	*/				WRITE(MAL)=TIM.OPTIONS+PTL;	/*	PARTIAL OPTIONS		*/				WRITE(MD )=READ(MD) \ ANY.GLIDE;			END;		END;		WRITE(MAM)=TIM.HEADP;					/*	POINT TO TIMBRE HEAD	*/		WRITE(MAL)=TIM.SYNTH.TYP+PTL;		IF READ(MD)=3 THEN DO;					/*	DISALLOW CHORUS FOR MONO SAMP	*/			WRITE(MAL)=TIM.LOG.NCH+PTL;			WRITE(MD )=0;			WRITE(MAL)=TIM.LOG.NCHCH+PTL;			WRITE(MD )=0;		END;	END;												/*	OF LOOP OVER PARTIALS	*/	IF TB=0 THEN NEW.KBD.PRE=1;				/*	IF THIS IS A PRE-COMPUTED PARTIAL	*/END COMPUTE.LOGS;/*	LOOK UP TABLE TO MAP BUTTONS TO ABOVE BITS:	*/DCL SAMPLED.LOOKUP DATA PUBLIC (VE.ATK.L,	VE.IDEC.L,	VE.DEL.L,		 HE.ATK.L,HE.IDEC.L,	VE.FDEC.L,	HE.DEL.L,		 PRATE.L,HE.FDEC.L,	VATK.L,		DYNENVL.L+1024, 0,0,				0,				0,					 0);/*	LOOK UP TABLE TO MAP BUTTONS TO CONTINUOUS BITS:	*/DCL CONTINUOUS.LOOKUP DATA PUBLIC (VRATE.L,			VDEPTH.L,	VE.PEAK.L+256+512, MODDEP.L,STRATE.L,		HE.PEAK.L,	HE.SUST.L,			 STDEPTH.L,STCEN.L,			PTUN.L,		RATIO.L,				 RRATE.L,CHORUS.L+2048,	TRVOL.L,		0,						 0);DCL SPECIAL.LOOKUP	DATA PUBLIC (	/*	SPECIAL LPNS FOR MULTIPLY-LIT BUTTONS	*/VE.SUST.L,PVOL.L,DYNENVH.L,PCHORUS.L);/*	BIT ENCODING FOR TIM.USED.RTES	*//*	LOWER HALF - BITS FOR EXPRESSION INPUTS THAT CONTROL SAMPLED PARAMETERS	*//*	UPPER HALF - BITS FOR EXPRESSION INPUTS THAT CONTROL CONTIN. PARAMETERS	*//*	THEY MATCH THE FRONT PANEL, EXCEPT VELOCITY IS LEFT OUT (SINCE IT CAN	*//*	NOT CHANGE ONCE A KEY IS PRESSED).													*//*							SAMPLED	CONTINUOUS	*//*		PRESSURE		-	BIT  0,	BIT  8		*//*		PEDAL1		-	BIT  1,	BIT  9		*//*		PEDAL2		-	BIT  2,	BIT 10		*//*		MODWHEEL		-	BIT  3,	BIT 11		*//*		RIBBON		-	BIT  4,	BIT 12		*//*		KEYB CV		-	BIT  5,	BIT 13		*//*		BREATH		-	BIT  6,	BIT 14		*//*		PITCH WHEEL	-	BIT  7,	BIT 15		*/DCL MEMORIZE.RTE	FIXED PUBLIC;			/*	SET TO RECORD VELOCITY	*//*	$PAGE - EXPAND OLD REAL TIME EFFECTS TO NEW VK FORMAT	*//*	THIS ROUTINE EXPANDS AN ORIGINAL KEYBOARD RTE ROUTING WORD	*//*	INTO A 40-WORD ARRAY THAT REPRESENTS ITS NEAREST EQUIVALENT	*//*	ON THE V/P KEYBOARD														*/EXPAND.OLD.RTE:PROC(L,ARR) PUBLIC SWAPABLE;	/*	EXPAND OLD FORMAT RTE'S FOR PROCESSING BY NEW CODE	*/	DCL (J,K,L,M,N,P)	FIXED;						/*	PROVIDES MOST USEFUL FEATURES OF OLD TIMBRES	*/	DCL (ARR)			ARRAY;	IF L=0 THEN L="172";								/*	INITIALZE PEDAL TO VIBRATO DEPTH IF OLD OLD OLD TIMBRE	*/	M=SHR(L,8)&(N.VE.ATK\N.VE.IDEC\N.HE.ATK\N.HE.IDEC\N.P.RATE);	/*	EXTRACT SAMPLED PARAMETERS - THIS IS WHY WE USED SUCH A SCREWY BIT PATTERN ABOVE !!	*/	N=SHR(L,8)&(N.VE.PKSUS\N.HE.PK\N.HE.SUS);								/*	EXTRACT CONTIUNOUS ONES	*/	IF (M&N.VE.IDEC)<>0 THEN M=M\N.VE.FDEC;	/*	BIT MEANT BOTH INITIAL & FINAL DECAYS	*/	IF (M&N.HE.IDEC)<>0 THEN M=M\N.HE.FDEC;	/*	DITTO	*/	DO K=0 TO 7;										/*	SET UP INFO FOR 8 EXPRESSION INPUTS	*/		P=K*5;											/*	COMPUTE POINTER WITH STRIDE OF 5 WORDS	*/		DO J=0 TO 4; ARR(P+J)=0; END;				/*	INITIALIZE TO ZEROES	*/		IF K=0 THEN DO;								/*	VELOCITY - MAP TO VELOCITY/PEDAL ROUTING	*/			IF (L&6)=0 THEN ARR(P)="17";			/*	INITIALIZE TO ALL PARTIALS, NO PARAMETERS IF NEITHER PEDAL NOR VELOCITY WAS SELECTED	*/			ELSE DO;										/*	VELOCITY WAS IN	*/				ARR(P)=SHR(L,3)&"17";				/*	PICK UP PARTIALS FROM EARLIER ROUTING	*/				ARR(P+1)=M;								/*	SAMPLED BITS	*/				ARR(P+2)=N;								/*	CONTINUOUS BITS	*/			END;		END;		ELSE DO;											/*	PRESSURE/PEDAL1/PEDAL2/MOD WH/RIBBON/KBD CV/BREATH - INITIALIZE	*/			ARR(P)="17";								/*	INITIALIZE TO ALL PARTIALS, NO PARAMETERS	*/		END;	END;						/*	OF LOOP OVER INPUTS	*/END EXPAND.OLD.RTE;/*	$PAGE - PRECOMPUTE REAL TIME EFFECTS ROUTING	*/DCL T.AR (39)			FIXED PUBLIC;			/*	HOLDS BITS FOR EXPANDED RTE'S	*/DCL PMASK DATA PUBLIC ("000017", "000360", "007400", "170000");COMPUTE.RBITS:PROC(XTB) PUBLIC SWAPABLE;	/*	COMPUTES REAL TIME EFFECTS FOR SPECIFIED TIMBRE	*/	DCL (XTB)				FIXED;	DCL (TB,PTL,I,J,K)	FIXED STATIC;	DCL (TIM.HEADP)		FIXED STATIC;	DCL (NUM.OF.PATCHES)	FIXED STATIC;	/*	MAP 0-8 EXPRESSION INPUT # TO 5-BIT FILED STORED IN .LOOK:		*/	/*	MAPPED THIS WAY TO SPEED UP REAL TIME COMPUTATION IN 'SCALE'	*/	/*	TABLE STARTS WITH 2 TO MAKE NONZERO.  LSB MEANS NORMAL OR		*/	/*	INVERTED SENSING																*/	/*						VEL   PRE  PED1  PED2  MODW  RIBB KBDCV  BRTH PWHEEL	*/	DCL RB.LOOK	DATA (  2,    4,    8,   10,   12,   18,    6,   14,   16);	/*	PATCHING ORDER - NO LONGER USED		*/	//	DCL ORDER	DATA ( 0,1,2,3,4,5,6,7);	PARSUB:PROC(TIM.LOC,XPBIT,XOFFS);	/*	SUBROUTINE TO CONSTRUCT & STORE PATCHES FOR EACH PARTIAL	*/		DCL (XPBIT,XOFFS)	FIXED;		DCL (TIM.LOC)		FIXED;			/*	TIM.VE.ATK.LOOK, ETC	*/		DCL (PBIT	)		FIXED STATIC;		DCL (OFFS	)		FIXED STATIC;		DCL (I,K,L)			FIXED;		DCL (PLIST	)		FIXED;			/*	OUTPUT PARTIAL LIST		*/		DCL (PARS	)		FIXED;			/*	PARTIAL BITS				*/		DCL (PATCHING)		FIXED STATIC;		PATCH:PROC(EXPR,SENS);				/*	ACTUALLY CONSTRUCT PATCH	*/			DCL (EXPR,SENS,CODE#)	FIXED;			/*	LOOK UP 5-BIT CODE #	*/			CODE#=RB.LOOK(EXPR);				/*	LOOK UP 5-BIT CODE # FOR THIS EXPRESSION	*/			/*	CONSTRUCT PATCHING	*/			PATCHING=SHL(PATCHING&"1777",5)\CODE#\SENS;	/*	CONSTRUCT PATCHING WORD	*/			/*	SET BITS IN TIM.ACT.PARS, TIM.VP, TIM.PP, TIM.KP AS APPROPRIATE	*/			IF OFFS=1 THEN DO;				/*	ONLY SET BITS IN ACT.PARS FOR CONTINUOUS	*/				WRITE(MAM)=TIM.HEADP;		/*	ACCESS TIMBRE HEAD	*/				IF CODE#>=8 THEN DO;			/*	THIS EXPRESSION IS STORED IN RTE.DATA - SO SET BIT IN TIM.ACT.PARS	*/					WRITE(MAL)=TIM.ACT.PARS+SHR(CODE#-8,1);				END;				ELSE DO;							/*	INDEX TO TIM.VP, TIM.PP, TIM,KP	*/					WRITE(MAL)=TIM.VP+SHR(CODE#-2,1);				END;				WRITE(MD )=READ(MD) \ PBIT;	/*	SET BIT FOR THIS PARAMETER	*/			END;			/*	NOW SET TIM.USED.RTES OR MEMORIZE.VELOCITY	*/			/*	SO THAT EXPRESSION GETS RECORDED				*/			IF EXPR<>0 THEN DO;							/*	NOT VELOCITY - SET USED.RTE BITS	*/				WRITE(MAM)=TIM.HEADP;					/*	ACCESS TIMBRE HEAD					*/				WRITE(MAL)=TIM.USED.RTES;				IF OFFS=0 THEN DO;						/*	SAMPLED PARAMTER						*/					WRITE(MD)=READ(MD)\BITS(EXPR-1);	/*	SET BIT IN LOWER HALF IF USED FOR SAMPLED FUNCTION	*/					IF (PBIT&(N.VE.DEL\N.VE.ATK\N.VE.IDEC\N.VE.FDEC\N.HE.DEL\N.HE.ATK\N.HE.IDEC\N.HE.FDEC))<>0					THEN DO;									/*	RTES PATCHED TO SAMPLED ENVELOPE FUNCTION	*/						WRITE(MAL)=TIM.TOPTIONS;						IF (READ(MD)&BIT.REPEAT)<>0	/*	REPEAT ACTIVE	*/						THEN DO;								/*	TREAT AS CONTINUOUS PARAMETER FOR RECORDING PURPOSES	*/							WRITE(MAL)=TIM.USED.RTES;							WRITE(MD)=READ(MD)\BITS(EXPR+7);	/*	SET BIT IN UPPER HALF TO CONTINUOUSLY RECORD	*/						END;					END;				END;				ELSE DO;										/*	CONTINUOUS PARAMETER	*/					WRITE(MD)=READ(MD)\BITS(EXPR+7);	/*	SET BIT IN UPPER HALF TO CONTINUOUSLY RECORD EXPRESSION INPUT	*/				END;			END;			ELSE IF TB=0 THEN MEMORIZE.RTE=1;		/*	SET MEMORIZE.VELOCITY IF COMPUTING KEYBOARD RTES & VELOCITY IS USED	*/		END PATCH;		PBIT = XPBIT; OFFS = XOFFS;		PLIST=0;											/*	ASSUME NO PARTIALS AFFECTED	*/		DO I=0 TO NUM.PARTIALS-1;					/*	CHECK EACH PARTIAL			*/			IF TIM.LOC<>TIM.REPRATE.LOOK			/*	NOT REPEAT ARPEG - JUST 1	*/			THEN DO;				PARS=BITS(I);			END;											/*	LUMP ALL PARTIALS TOGETHER	*/			ELSE PARS="17";							/*	FOR REPEAT RATE PATCHING	*/			PATCHING=0;									/*	INITIALIZE PATCH TO 0		*/			DO K=0 TO 7;								/*	CHECK EACH OF 8 EXPRESSIONS	*/				L = K*5;									/*	POINTER WITH STRIDE OF 5		*/				IF (T.AR(L)&PARS)<>0					/*	IF THIS PARTIAL IS AFFECTED	*/				THEN DO;					IF (T.AR(L+1+OFFS)&PBIT)<>0	/*	BIT SET FOR NORMAL SENSING	*/					THEN DO;								/*	EXPRESSION IS USED			*/						CALL PATCH(K,0);				/*	POSITIVE							*/					END;					ELSE IF (T.AR(L+3+OFFS)&PBIT)<>0	/*	INVERTED SENSING			*/					THEN DO;						CALL PATCH(K,1);				/*	INVERTED							*/					END;				END;				ELSE IF (SHR(T.AR(L),NUM.PARTIALS)&PARS)<>0	/*	CHECK FOR INVERTED PARTIAL PATCHING	*/				THEN DO;					IF (T.AR(L+1+OFFS)&PBIT)<>0	/*	BIT SET FOR NORMAL SENSING	*/					THEN DO;								/*	EXPRESSION IS USED			*/						CALL PATCH(K,1);				/*	INVERT SENSING					*/					END;					ELSE IF (T.AR(L+3+OFFS)&PBIT)<>0	/*	INVERTED SENSING			*/					THEN DO;						CALL PATCH(K,0);				/*	DOUBLY INVERTED - POS		*/					END;				END;			END;			IF TIM.LOC=TIM.TUNING.LOOK				/*	SETTING UP TUNING PATCH		*/			THEN DO;										/*	ALSO INCLUDE PITCH WHEEL	*/				CALL PATCH(8,0);			END;			K=0;											/*	ASSUME NOT PATCHED		*/			IF PATCHING<>0 THEN DO;					/*	PARAMETER IS AFFECTED	*/				WRITE(MAM)=TIM.HEADP;				/*	ACCESS TIMBRE HEAD		*/				DO L=0 TO NUM.OF.PATCHES-1;		/*	SEE IF PATCH ALREADY USED	*/					WRITE(MAL)=TIM.RTE.PATCHES+L;					IF READ(MD)=PATCHING THEN K=L+1;	/*	ADD 1 TO MAKE NONZERO	*/				END;				IF  (K=0)									/*	NOT IN LIST - PUT IT THERE	*/				AND (NUM.OF.PATCHES<TIM.RTE.LENGTH)	/*	IF IT FITS!!					*/				THEN DO;					WRITE(MAL)=TIM.RTE.PATCHES+NUM.OF.PATCHES;					WRITE(MD )=PATCHING;					K=NUM.OF.PATCHES+1;					NUM.OF.PATCHES=NUM.OF.PATCHES+1;				END;			END;			PLIST=SHR(PLIST,4)\SHL(K,12);		END;		WRITE(MAM)=TIM.HEADP;					/*	ACCESS TIMBRE HEAD			*/		WRITE(MAL)=TIM.LOC;						/*	PASSED LOCATION				*/		WRITE(MD )=PLIST;							/*	STORE PARTIAL PATCH LIST	*/	END PARSUB;	/*	CHECK FOR TIMBRE HEAD BLOCK	*/	TB = XTB;											/*	SET UP PASSED VARIABLE	*/	WRITE(MAM)=TIM.HEAD;								/*	POINT TO LOOK UP TABLE	*/	WRITE(MAL)=TB;										/*	SEE IF ENTRY THERE	*/	IF READ(MD)<>0 THEN DO;;						/*	IF THERE, COMPUTE IT	*/		TIM.HEADP=READ(MD);							/*	POINTER TO TIM HEAD	*/		/*	EXCTRACT RTE PATCH LIST	*/		WRITE(MAM)=TIM.HEADP;						/*	POINT TO TIMBRE HEAD	*/		WRITE(MAL)=TIM.TINFO.POINTER;		IF READ(MD)<>0 THEN DO;						/*	TINFO AREA - GET RETS	*/			I=READ(MD)+TI.RTE;						/*	POINT TO RTE INFO		*/			CALL P.LOOKUP(I);							/*	LOAD POINTERS			*/			CALL COPY.IN(ADDR(T.AR(0)),40);		/*	READ IN FROM EXT MEMORY	*/		END;		ELSE DO;											/*	NO TINFO - EXPAND OLD	*/			WRITE(MAL)=TIM.MISC.POINTER;			/*	GET POINTER TO MISC	*/			I=READ(MD)+RTE.LOC;						/*	GET POINTER TO ORIGINAL RTE WORD FOR NEW MAPPING	*/			CALL EXPAND.OLD.RTE(P.LOOKUP(I),T.AR);	/*	EXPAND OLD FORMAT RTE'S FOR PROCESSING	*/		END;		/*	CONSTRUCT ROUTING FOR USE	*/		/*	BY REAL TIME CODE			*/		WRITE(MAM)=TIM.HEADP;						/*	POINT TO TIMBRE HEAD	*/		WRITE(MAL)=TIM.ACT.PARS;					/*	ZERO TIM.ACT.PARS, TIM.VP,	*/		DO I=TIM.ACT.PARS TO TIM.KP;				/*	TIM.PP, TIM.KP					*/			WRITE(MDI)=0;		END;		WRITE(MAL)=TIM.USED.RTES;		WRITE(MD )=0;		IF (TB=0) THEN DO;							/*	KEYBOARD - SET MEMORIZE.RTE AS REQUIRED	*/			MEMORIZE.RTE=0;		END;		NUM.OF.PATCHES=2;								/*	INDLUDE 2 DEFAULT PATCHES ALWAYS (SEE OPTIMIZING IN NOTE START CODE)	*/		WRITE(MAL)=TIM.RTE.PATCHES;		WRITE(MDI)=2;									/*	JUST VELOCITY = CODE 2	*/		WRITE(MD )=16;									/*	JUST PITCH WHEEL			*/		DO I=0 TO 11-1;								/*	CONSTRUCT PATCH FOR EVERY SAMPLED PARAMETER	*/			CALL PARSUB(TIM.VE.ATK.LOOK+I,BITS(I),0);		END;		DO I=0 TO 14-1;								/*	CONSTRUCT PATCH FOR EVERY CONTINUOUS PARAMETER	*/			CALL PARSUB(TIM.V.RATE.LOOK+I,BITS(I),1);		END;		WRITE(MAM)=TIM.HEADP;							/*	ZERO OUT UNUSED AREA	*/		WRITE(MAL)=TIM.RTE.PATCHES+NUM.OF.PATCHES;		DO WHILE NUM.OF.PATCHES<TIM.RTE.LENGTH;	/*	ZERO OUT UNUSED AREA	*/			WRITE(MDI)=0;			NUM.OF.PATCHES=NUM.OF.PATCHES+1;		END;		/*	$PAGE - SET PARTIAL OPTIONS BITS FOR REAL TIME EFFECTS	*/		DO PTL=0 TO (NUM.PARTIALS-1);				/*	CHECK EACH ONE FOR RTE'S	*/			WRITE(MAM)=TIM.HEADP;					/*	POINT TO TIMBRE HEAD			*/			WRITE(MAL)=TIM.OPTIONS+PTL;			/*	GET CURRENT OPTIONS WORD	*/			J = READ(MD) & (NOT(ENV.RTES	OR INX.RTES	OR TUN.RTES													OR FD.RTES	OR ANY.STAM ));			WRITE(MAL)=TIM.VE.ATK.LOOK;			I=READ(MD);			WRITE(MAL)=TIM.VE.IDEC.LOOK;			I=I\READ(MD);			IF ((I&PMASK(PTL))<>0)			THEN J=J\ENV.RTES;			WRITE(MAL)=TIM.HE.ATK.LOOK;			I=READ(MD);			WRITE(MAL)=TIM.HE.PK.LOOK;			I=I\READ(MD);			WRITE(MAL)=TIM.HE.IDEC.LOOK;			I=I\READ(MD);			WRITE(MAL)=TIM.HE.SUS.LOOK;			I=I\READ(MD);			IF (I&PMASK(PTL))<>0			THEN J=J\INX.RTES;			WRITE(MAL)=TIM.FMRATIO.LOOK;			I=READ(MD);			WRITE(MAL)=TIM.CHORUS.LOOK;			I=I\READ(MD);			WRITE(MAL)=TIM.TUNING.LOOK;			IF READ(MD)<>(2+32+512+8192)	/*	DO NOT SET TUN.RTES	*/			THEN I=I\READ(MD);				/*	IF ONLY PITCH WHL		*/			IF (I&PMASK(PTL))<>0			THEN J=J\TUN.RTES;			WRITE(MAL)=TIM.VE.FDEC.LOOK;			I=READ(MD);			WRITE(MAL)=TIM.HE.FDEC.LOOK;			I=I\READ(MD);			IF (I&PMASK(PTL))<>0			THEN J=J\FD.RTES ;			WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;			PTPTR=READ(MD);			WRITE(MAL)=TIM.INIT.STPOS+PTL;	/*	INITIALIZE STEREO POSITION TO 128	*/			WRITE(MD )=128;			WRITE(MAL)=TIM.S.PAN.LOOK;			I=READ(MD);			IF  ((P.LOOKUP(PTPTR+P.VIBWAVE  )&"177600")<>0)	/*	MODE IS NONZERO	*/			OR  ((I&PMASK(PTL))<>0)									/*	OR STEREO RTES		*/			THEN DO;														/*	MUST COMPUTE INITIAL POSITION	*/				J=J\ANY.STAM;		/*	SET OPTIONS BIT	*/			END;			ELSE DO;														/*	INITIAL POSITION IS KNOWN - PRECOMPUTE IT	*/				IF ((P.LOOKUP(PTPTR+P.GLIDEBITS)&"000774")<>0)				THEN DO;										/*	NON-CENTERED	*/					K=(SHR(P.LOOKUP(PTPTR+P.GLIDEBITS),2)+50)&"177";	/*	GET CENTER - MAP TO 0 TO 100, 50 IS CENTER	*/					WRITE(5)=K*256; WRITE(7)=100; K=READ(5);				/*	MAP CENTER TO 0-256	*/					WRITE(MAM)=TIM.HEADP;				/*	POINT TO TIMBRE HEAD		*/					WRITE(MAL)=TIM.INIT.STPOS+PTL;					WRITE(MD )=K;							/*	SAVE FOR FASTER NOTE STARTS	*/				END;			END;			WRITE(MAM)=TIM.HEADP;					/*	POINT TO TIMBRE HEAD		*/			WRITE(MAL)=TIM.OPTIONS+PTL;			/*	STORE NEW OPTIONS WORD	*/			WRITE(MD )=J;		END;	END;	CALL COMPUTE.ARLIST;								/*	SET UP ACTIVE RIBBON LINKED LIST	*/END COMPUTE.RBITS;/*	$PAGE - PRECOMPUTE ROUTINE FOR TRACK SOLOING	*/COMPUTE.ACTIVE.TRKS:PROC PUBLIC SWAPABLE;	/*	CALL THIS PROCEDURE TO SET UP WORDS	*/	DCL (I,J,K)	FIXED;	LOD.PLAY.TRACKS=0;							/*	INITIALIZE ALL TO OFF			*/	NEW.MOTION		=1;	DO I=NUM.KBD.TRACKS TO (MAX.TRACKS-1);	/*	CHECK CONDITION OF EACH TRACK	*/		WRITE(MAM)=TRK.HEAD;			/*	POINT TO TRK.HEAD SECTOR		*/		WRITE(MAL)=I;					/*	INDEX TO TRACK HEAD				*/		J=READ(MD);						/*	SAVE PTR TO TRACK HEAD			*/		IF J<>0 THEN DO;				/*	CHECK BLOCK IF THERE				*/			WRITE(MAM)=J;				/*	POINT TO TRACK HEAD				*/			WRITE(MAL)=THD.ACTIVE;			WRITE(MD )=0;				/*	ASSUME TRACK IS NOT ACTIVE		*/			WRITE(MAL)=THD.IGNORE;	/*	LOOK UP THD.IGNORE BIT			*/			K			 =READ(MD);		/*	FOR FOLLOWING CHECK				*/		END;		ELSE K = 0;						/*	CANNOT IGNORE A TRACK THAT DOES	*/											/*	NOT HAVE A TRACK HEAD!!				*/		IF (K = 0) THEN DO;			/*	IF NOT IGNORING THIS TRACK			*/			WRITE(MAM)=TBUT.PTR;		/*	POINT TO TRACK SOLO STATE ARRAY	*/			WRITE(MAL)=I;				/*	FOR THIS TRACK							*/			IF   ((NUM.OF.SOLOED.TRACKS=0)		/*	NO TRACKS ARE SOLOED		*/			AND	((READ(MD)&B.MUTED.TRK)=0))	/*	THIS ONE IS NOT MUTED	*/			OR   (I = CUE.AUDITION.TRACK)			/*	OR THIS IS CUE AUDIT		*/			OR   ((READ(MD)&B.SOLOED.TRK)<>0)	/*	OR THIS ONE SOLOED		*/			OR   ((RECD<>0)							/*	OR RECORDING				*/			AND	(RECD.TRK<>0)						/*	SYNCLAVIER RECORDING		*/			AND	(NUM.OF.SOLOED.TRACKS=1)		/*	WITH ONE SOLOED			*/			AND  ((READ(MD)&B.MUTED.TRK)=0))		/*	THIS ONE IS NOT MUTED	*/			THEN DO;										/*	THIS TRACK IS ACTIVE		*/				IF J<>0 THEN DO;						/*	TRACK HEAD EXISTS			*/					WRITE(MAM)=J;						/*	POINT TO TRACK HEAD		*/					WRITE(MAL)=THD.ACTIVE;					WRITE(MD )=1;						/*	TRACK IS ACTIVE			*/				END;				IF  (I ige FIRST.LOD.TRACK)				AND (I ilt LAST.LOD.TRACK )				THEN DO;					LOD.PLAY.TRACKS=LOD.PLAY.TRACKS \ BITS(I-FIRST.LOD.TRACK);				END;			END;		END;	END;END COMPUTE.ACTIVE.TRKS;