/*	:SYNRSOU:11-TIMB:137-COMP  $TITLE  Routines to Compute Frequency & Envelope Information	*/

/*
Modified:
1999/04/22 - TY  - Corrected rounding in COMPUTE.MSYN.FREQ to work with odd values of NOTEINC
1998/05/03 - TY  - Modified COMPUTE.POLY.HZ.INFO to take negative partial tunings into account.
1991/06/06 - cj  - Added sample rate correction to compute.poly.hz.info
1988/02/04 - TSS - NEW CODE FOR COMPUTE.PSYN.FREQ ROUTINE FOR NEW FREQ TABLE
1986/05/15 - "official" creation of release-M modules
*/

/*	INTERNAL TO THE PROGRAM, ALL FREQUENCIES ARE REPRESENTED BY A
	LOGARITHMIC NOTATION.  IN A SIXTEEN BIT NUMBER, THE LOWER 10 BITS
	INDICATE STEPS OF 1024/OCTAVE.  THE UPPER 6 BITS THEN INDICATE
	WHICH OCTAVE IS INVOLVED.  MULTIPLICATION (SUCH AS FOR THE RATIO
	CONTROL AND THE FREQUENCY BASE ADJUSTMENT) IS DONE BY ADDING LOGS.	*/

/*	COMPUTE.OSYN.FREQ-
		PASSED A KEY NUMBER IN THE INTERNAL NOTATION (0-87), AND
		RETURNS DATA THAT CAN BE WRITTEN TO THE ORIGINAL SYNTHESIZER	*/

DCL NOTEADD	FIXED PUBLIC;					/*	MUST DECLARE THIS IN ORDER	*/
DCL NOTENUM	FIXED PUBLIC;					/*	TO MATCH PARTIAL BLOCK		*/
DCL NOTEINC	FIXED PUBLIC;					/*	ORDER FOR FASTER WRITES		*/

DCL POLY.FREQ.TABLE.PTR	FIXED PUBLIC;	/*	XMEM PTR TO FREQ LOOKUP TABLE FOR POLY NOTES	*/

COMPUTE.OSYN.FREQ:PROC(KEY#,FREQ.NUM) PUBLIC;	/*	PASS INTERNAL KEY # FOR TABLE SELECTION	*/
	DCL (KEY#,FREQ.NUM,I,J)	FIXED;

	IF FREQ.NUM<=-4096 THEN DO;	/*	SIMPLY USE LOWEST FREQUENCY	*/
		NOTEINC=5; NOTENUM=199; NOTEADD=0;
	END;
	ELSE DO;	/*	MUST COMPUTE	*/
		I=FREQ.NUM&1023;	/*	EXTRACT FRACTIONAL OCTAVE PART	*/
		IF KEY#<(SYNC.MIDDLE.C+12) THEN DO;		/*	NO CORRECTION REQUIRED	*/
			WRITE(MAM)=FRE.PTR+SHR(I,8); WRITE(MAL)=I;
			NOTENUM=READ(MD);							/*	NO CORRECTION REQUIRED THROUGH B3	*/
		END;
		ELSE DO;											/*	USE DIFFERENT TABLE FOR UPPER OCTAVES	*/
			I=SHR(I,1);									/*	USE SHORTER TABLE FOR UPPER 2 OCTAVES	*/
			IF KEY#<(SYNC.MIDDLE.C+24) THEN DO;	/*	C4-B4  - USE UPPER MIDDLE	*/
				WRITE(MAM)=FRE.PTR+SHR(I,8)+4; WRITE(MAL)=I;
				NOTENUM=READ(MD);
				FREQ.NUM=FREQ.NUM-1024;				/*	BRING DOWN AN EXTRA OCTAVE	*/
			END;
			ELSE DO;										/*	UPPER OCTAVE + 1 NOTE		*/
				WRITE(MAM)=FRE.PTR+SHR(I,8)+6; WRITE(MAL)=I;
				NOTENUM=READ(MD);
				FREQ.NUM=FREQ.NUM-2048;				/*	SAMPLING RATE IS TWO OCTAVES UP	*/
			END;
		END;	/*	OF CASE FOR DIFFERENT TABLE	*/
		NOTEINC=SHR(NOTENUM,8);	/*	EXTRACT INCREMENT	*/
		NOTENUM=NOTENUM&255;		/*	EXTRACT DIVISOR	*/

		/*	$PAGE - CHECK FOR OCTAVE BOUNDARY	*/

		IF FREQ.NUM>=1024 THEN DO;	/*	WE CAN COMPUTE NOTEADDER	*/
			NOTEADD=SHR(FREQ.NUM,10)-1;
			IF NOTEADD>7 THEN NOTEADD=7;
		END;
		ELSE DO;	/*	MUST CORRECT INC/DIVISOR PAIRS FOR SUPER LOW FREQUENCIES	*/
			NOTEADD=0;	/*	USE LOWEST VALUE	*/
			I=SHR((1024+1023)-FREQ.NUM,10);	/*	COMPUTE # OF OCTAVES TO BRING DOWN	*/
			DO WHILE (I<>0) AND ((NOTEINC&1)=0);	/*	EVEN INCREMENTS	*/
				I=I-1; NOTEINC=SHR(NOTEINC,1);
			END;
			DO WHILE (I<>0) AND (NOTENUM<128);
				I=I-1; NOTENUM=SHL(NOTENUM,1);
			END;
			IF I<>0 THEN DO;	/*	MORE TO DO	*/
				J=NOT(BITS(I)-1);	/*	COMPUTE MASK FOR BITS TO SAVE	*/
				WRITE(5)=NOTENUM;WRITE(6)=NOTEINC&J;J=READ(5);WRITE(7)=NOTEINC;	/*	CORRECT FOR BITS BEING LOST DURING FOLLOWING SHR	*/
				NOTENUM=READ(5);	/*	READ SCALED RESULT	*/
				WRITE(5)=NOTEINC;WRITE(7)=BITS(I);NOTEINC=READ(5);	/*	USE D4567 FOR FAST SHIFT RIGHT	*/
			END;
		END;	/*	OF CASE FOR SUPER LOW FREQS	*/
	END;	/*	OF CASE FOR COMPUTING FREQUENCY DATA	*/

	NOTEINC=NOTEINC-1;	/*	ADJUST TO MATCH SYNTHESIZER ALGORITHM	*/
	NOTENUM=256-NOTENUM+SHR(NOTEINC,3);
END COMPUTE.OSYN.FREQ;

/*	$PAGE - FREQUENCY COMPUTATION FOR SAMPLING (MONO SYNTH)	*/

/*	USE SYNCL II LOOKUP TABLE TO GET INCREMENT/DIVISOR	*/
/*	COMPUTE PERIOD FROM THAT INFORMATION					*/

COMPUTE.MSYN.FREQ:PROC(FREQ.NUM) PUBLIC;		/*	COMPUTE INFO FOR SAMPLING SYSTEM	*/
	DCL (FREQ.NUM)	FIXED;							/*	2816 = 50 KHZ	*/
	CALL COMPUTE.OSYN.FREQ(0,FREQ.NUM+(2048-2816));	/*	COMPUTE NOTEINC, NOTENUM, NOTEADD	*/
	NOTENUM=256-NOTENUM+SHR(NOTEINC,3);			/*	RECOMPUTE ACTUAL DIVISOR	*/
	NOTEINC=(NOTEINC+1)*BITS(NOTEADD);			/*	RECOMPUTE ACTUAL INCREMENT - SCALE UP FOR OCTAVE CONTENTS	*/
	LOAD 1929; MUL NOTENUM;							/*	COMPUTE 1200*DIV/INC = DESIRED PERIOD	*/
	IF READ(4) IGE NOTEINC THEN NOTENUM=MAX.SAMP;	/*	OVERFLOW - USE LOWEST PITCH	*/
	ELSE DO;
		DIV NOTEINC;									/*	1200*DIVISOR/INCREMENT	*/
		NOTENUM=RES;									/*	GET PERIOD	*/
		IF (shl(READ(4),1) ige NOTEINC) NOTENUM = NOTENUM+1;	/*	ROUND UP	*/
		IF NOTENUM ILT MIN.SAMP THEN NOTENUM=MIN.SAMP;			/*	LIMIT TO JUST ABOVE 50 KHZ	*/
		IF NOTENUM IGT MAX.SAMP THEN NOTENUM=MAX.SAMP;
	END;
END COMPUTE.MSYN.FREQ;

/*	$PAGE - FREQUENCY COMPUTATION FOR POLY SAMPLING	*/

COMPUTE.PSYN.FREQ:PROC(FREQ.NUM) PUBLIC;	/*	PASS FREQ NUMBER - USES ORIGINAL FREQ TABLE	*/
	DCL (FREQ.NUM,I,J)	FIXED;			   /*	FOR NOW, 3840 = 50 KHZ	*/

	IF   FREQ.NUM<(-2048)						/*	LIMIT FOR CONSISTENT RESULTS	*/
	THEN FREQ.NUM=(-2048);						/*	WITH CRAZY RATIOS & TUNINGS	*/

	IF POLY.FREQ.TABLE.PTR=FRE.PTR			/*	USING ORIGINAL FREQ LOOKUP TABLE	*/
	THEN DO;
		FREQ.NUM=FREQ.NUM+(308-2816-1024);	/*	COMPUTE DIST FROM 2816; OFFSET TO 308 (CORRECTED RATIO=.495000)	*/

		I=FREQ.NUM&1023;							/*	EXTRACT FRACTIONAL OCTAVE PART	*/
		WRITE(MAM)=POLY.FREQ.TABLE.PTR+SHR(I,8); WRITE(MAL)=I;

		NOTEINC=SHR(READ(MD),8);				/*	EXTRACT INCREMENT	*/
		NOTENUM=READ(MD)&255;					/*	EXTRACT DIVISOR	*/
		IF NOTEINC>NOTENUM THEN DO;			/*	LIMIT RATIO TO 1.000 FOR NEW SYNTH	*/
			FREQ.NUM=FREQ.NUM+1024;				/*	BRING PHASE INC UP AN OCTAVE BELOW	*/
			NOTENUM=SHL(NOTENUM,1);				/*	GET LARGER MODULUS - WE KNOW IT WAS < 128	*/
		END;

		IF FREQ.NUM>=1024 THEN DO;					/*	WE CAN COMPUTE PHASE INCREMENT	*/
			NOTEADD=BITS(SHR(FREQ.NUM,10)-1);	/*	LET'S NOT MAKE AN OVERFLOW CHECK AND SEE WHAT HAPPENS	*/
			I = 0;										/*	NO FURTHER CORRECTION BELOW		*/
		END;
		ELSE DO;										/*	MUST CORRECT INC/DIVISOR PAIRS FOR LOWER FREQUENCIES	*/
			NOTEADD=1;								/*	USE A PHASE INCR OF 1	*/
			I=SHR((1024+1023)-FREQ.NUM,10);	/*	COMPUTE # OF OCTAVES TO BRING DOWN	*/
		END;
	END;

	ELSE DO;											/*	USING NEW POLY FREQ LOOKUP TABLE	*/
		FREQ.NUM=FREQ.NUM-(3840-3057);		/*	MAP TO 3057 = 50.000 KHZ			*/

		IF FREQ.NUM < 0 THEN I = (FREQ.NUM & 1023);
		ELSE IF FREQ.NUM > 4095 THEN I = 3072 + (FREQ.NUM & 1023);
		ELSE I = FREQ.NUM;

		WRITE(MAM)=POLY.FREQ.TABLE.PTR+SHR(I,8); WRITE(MAL)=I;

		NOTEINC=SHR(READ(MD),8);				/*	EXTRACT INCREMENT	*/
		NOTENUM=READ(MD)&255;					/*	EXTRACT DIVISOR	*/
		NOTEADD=1;									/*	ASSUME A PHASE INCR OF 1	*/

		IF NOTENUM = 0 THEN NOTENUM = 256;
		IF NOTEINC = 0 THEN NOTEINC = 256;

		IF FREQ.NUM>=4096 THEN DO;					/*	WE CAN COMPUTE PHASE INCREMENT	*/
			NOTEADD=BITS(SHR(FREQ.NUM,10)-3);	/*	LET'S NOT MAKE AN OVERFLOW CHECK AND SEE WHAT HAPPENS	*/
			I = 0;										/*	NO OCTAVE CORRECTION	*/
		END;
		ELSE IF FREQ.NUM < 0 THEN DO;
			I=SHR(1023-FREQ.NUM,10);				/*	COMPUTE # OF OCTAVES TO BRING DOWN	*/
		END;
		ELSE I = 0;										/*	ELSE NO OCTAVE CORRECTION NEEDED		*/
	END;

	/*	BRING DOWN OCTAVES AS REQUIRED (FOR SUPER LOW FREQUENCIES)	*/

	IF I <> 0 THEN DO;
		DO WHILE (I<>0) AND (NOTENUM<128);		/*	USE LARGER MODULUSES IF POSSIBLE	*/
			I=I-1; NOTENUM=SHL(NOTENUM,1);
		END;
		DO WHILE (I<>0) AND ((NOTEINC&1)=0);	/*	EVEN INCREMENT - USE SMALLER ONE IF NO CHANGE IN RATIO	*/
			I=I-1; NOTEINC=SHR(NOTEINC,1);
		END;

		IF I<>0 THEN DO;								/*	STILL LOWER - COMPUTE NEW INC/MODULUS	*/
			J=NOT(BITS(I)-1);							/*	COMPUTE MASK FOR BITS TO SAVE	*/
			WRITE(5)=NOTENUM;	WRITE(6)=NOTEINC&J;
			J=READ(5);			WRITE(7)=NOTEINC;	/*	CORRECT FOR BITS BEING LOST DURING FOLLOWING SHR	*/
			NOTENUM=READ(5);							/*	READ SCALED RESULT	*/
			WRITE(5)=NOTEINC; WRITE(7)=BITS(I);
			NOTEINC=READ(5);							/*	USE D4567 FOR FAST SHIFT RIGHT	*/
		END;
	END;

	/*	CORRECT TO MEET HARDWARE REQUIREMENTS:	*/

	NOTEINC=NOTEINC-1;								/*	ADJUST TO MATCH SYNTHESIZER ALGORITHM	*/
	NOTENUM=256-NOTENUM;

END COMPUTE.PSYN.FREQ;

/*	$PAGE - COMPUTE POLY HZ INFO	*/

/*	COMPUTE POLY HZ INFO IS USED TO COMPUTE THE BASIC SAMPLING RATE FOR
	A POLY NOTE TRIGGER.  THIS IS A NON-REAL TIME ROUTINE AND IS USED
	TO COMPUTE WHAT THAT SAMPLING RATE FOR A NOTE IS LIKELY TO BE WHEN
	THE NOTE IS TRIGGERED.  IT DOES NOT TRY TO CORRECT FOR POSSIBLE
	PITCH BENDING EFFECTS SUCH AS PORTAMENTO, VIBRATO, OR PITCH BEND	*/

/*	THE INFORMATION IS RETURNED IN THE GLOBAL VARIABLES NOTEINC, NOTEADD, NOTENUM	*/

/*	INFORMATION THAT IS TAKEN INTO ACCOUNT IS:	*/

/*	track transposition							*/
/*	patch transposition field					*/
/*	sound file set octave setting				*/
/*	patch list semitone correction field	*/
/*	overall tuning incl octave ratio			*/
/*	partial tuning for this partial			*/
/*	which key #										*/

/*	if bitmsb,bitlsb = milliseconds into note

	call ratio_multiply(1000,samp.speed);	un-correct for speed to get actual msecs into note
	call ratio_multiply(200*noteadd,99);	compute sample # based on 101.0101 khz and which octave note is in
	call ratio_multiply(noteinc,notenum);	correct for actual sample rate to get sample # past mark start to play at

	bitmsb,bitlsb = sample #
*/

/*	if bitmsb,bitlsb = sample # beyond mark start point

	call ratio_multiply(notenum,noteinc);	correct for sample rate
	call ratio_multiply(99,200*NOTEADD);	get sample # based on 50 khz
	call ratio_multiply(samp.speed,1000);	correct for speed control

	bitmsb,lsb = milliseconds into note
*/

COMPUTE.POLY.HZ.INFO: PROC (TRK#,KEY#,PAR#) PUBLIC SWAPABLE;
	DCL TRK#				FIXED;	/*	PASS TRACK	 #	*/
	DCL KEY#				FIXED;	/*	PASS KEY		 #	*/
	DCL PAR#				FIXED;	/*	PASS PARTIAL #	*/

	DCL POLYHZ			FIXED;
	DCL FRAMEBASE		FIXED;
	DCL (I,J,K)			FIXED;
	dcl (l,m,n,p)		fixed;
	dcl sfile.base(1)	fixed;

	NOTEINC = 1;	/*	initialize in case error	*/
	NOTENUM = 1;	/*	encountered					*/
	NOTEADD = 1;

	/*	KEY=(BUF(6)&63)+12;								*/	/*	GET BASIC KEY # - ADD 1 OCTAVE	*/
	/*	IF (BUF(8)&LOWER.KEY)<>0 THEN KEY=KEY-12;	*/	/*	C0 - B0	*/	/*	MAY BE RANDOM # IN CASE OF 4 WORD REST RECORD	*/
	/*	IF (BUF(8)&RAISE.KEY)<>0 THEN KEY=KEY+12;	*/	/*	C#6- C7	*/

	KEY# = KEY# + TRK.HEAD.LOOKUP(TRK#,thd.cxpos);	/*	correct key # for current transposition	*/

	if  (KEY# <0)												/*	look up offset only	*/
	OR  (KEY# >=num.keys)									/*	if key is in range	*/
	then RETURN 0;

	i = TRK.HEAD.LOOKUP(TRK#,thd.ctimb);				/*	get timbre # for this track	*/

	IF TIM.HEAD.LOOKUP(i,tim.synth.typ+PAR#) <> TIM#POLY
	THEN RETURN 0;												/*	not a poly partial	*/

	j=TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+PAR#);			/*	look up pointer		*/

	if j=0 then return 0;									/*	no look up table available	*/

	write(mam)=tim.ptr+j-1;
	write(mal)=KEY# * klt.size + klt.patch.tim.ptr;	/*	index by key#	*/

	if read(md)=0 then return 0;							/*	if no entry, then no sound file	*/

	framebase			 = read(mdi);						/*	save & skip over frame pointer	*/
	sfile.base(lw#msb) = read(mdi) & base#only;		/*	poly bin/page# w/o stereo flag	*/
	sfile.base(lw#lsb) = read(md);						/*	get sector of poly memory	*/

	/*	if negative partial tuning is being used then pretend a3 is being played	*/
	if (TIM.HEAD.LOOKUP(i,tim.options+PAR#) & MIN.PTUNE) <> 0 then KEY# = Sync.Middle.C + 9;

	k=TIM.HEAD.LOOKUP(i,tim.partial.pointers+PAR#);	/*	look up pointer to partial info	*/
	call p.lookup(k+framebase+pt.srate);				/*	look up pt.srate entry	*/

	/*	READ SAMPLE RATE FOR SF		*/
	/*	READ SET OCT	  FOR SF		*/
	/*	READ FRACTIONAL SET OCT		*/
	/*	READ SEMITONE CORRECTION	*/

	L =READ(MDI);			/*	READ SAMPLING RATE FACTOR FOR FILE	*/
	M =READ(MDI);			/*	READ SET OCTAVE FACTOR FOR FILE		*/
	N =READ(MD );			/*	READ FRACTIONAL PITCH OFFSET FOR TRANSPOSITION	*/

	/*	READ TRANSPOSITION	*/

	call p.lookup(k+framebase+pt.tra);

	IF (READ(MD)=0)						/*	NO TRANSPOSITION - CORRECT TO SETOCTAVE VALUE	*/
	THEN DO;
		polyhz=1024-M-L;					/*	NO TRANSPOSITION - CORRECT TO SETOCTAVE VALUE	*/
		WRITE("300")=READ(MDI);			/*	POINT PAST TRANSPOSITION		*/
	END;
	ELSE DO;									/*	USER SPECIFIED TRANSPOSITION	*/
		polyhz=(2816+1024)-COMPUTE.PATCH.XPOS(READ(MDI)&255)+N-L;
	END;

	IF READ(MD)<>0 THEN DO;				/*	ADD IN SEMITONE CORRECTION		*/
		IF READ(MD)<0 THEN DO;			/*	PERFORM FAST SIGNED 32 BIT MATH HERE		*/
			LOAD -READ(MD);				/*	CONVERT TO FREQ INFO FROM SEMITONES * 100	*/
			MUL 1024;
			WRITE("300")=RES;
			DIV 1200;
			polyhz=polyhz-RES;
		END;
		ELSE DO;
			LOAD  READ(MD);
			MUL 1024;
			WRITE("300")=RES;
			DIV 1200;
			polyhz=polyhz+RES;
		END;
	END;

	polyhz=polyhz+logtbase				/*	add in overall tuning		*/
			+compute.kbd.pitch(KEY#)	/*	get starting synclav pitch #	*/
			+TIM.HEAD.LOOKUP(i,tim.log.pt+PAR#);	/*	also p tuning	*/

	CALL COMPUTE.PSYN.FREQ(polyhz);	/*	COMPUTE INFO FOR POLY SYNTH	*/

	NOTEINC = NOTEINC + 1;				/*	COMPUTE LOGICAL INCREMENT	*/
	NOTENUM = 256-NOTENUM;				/*	AND LOGICAL DIVISOR	*/

	return 1;

end COMPUTE.POLY.HZ.INFO;
