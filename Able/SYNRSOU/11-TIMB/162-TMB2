/*	:SYNRSOU:11-TIMB:162-TMB2  $TITLE  MORE TIMBRE MANIPULATION ROUTINES	*/

/*
Modified:
2002/09/02 - TY  - Bug fix: COPY.TIMBRE() did the wrong thing when (FROM.TRK == -3) and (TO.TRK == 0)
1999/04/11 - TY  - Modified "COPY.TIMBRE" to utilize 4.20 user defaults
1992/02/15 - pf  - Speed up block sequence downloading over protocol
1992/01/12 - PF  - Made FIND.USABLE.DEST and CHECK.FOR.REDUNDANT.TIMBRE public for protocol timbre code
1991/07/23 - PF  - Support looping RAM Events
1991/06/19 - PF  - Modified SETUP.POLY.INFO to support RAM Events
1991/01/30 - MWH - Report which tracks have had new notes
1990/05/09 - PF  - adjusted COPY.TIMBRE so new null timbres have default.active.midi.rtes
1989/08/24 - PF  - Added copy of THD.MIDI.PATH in COPY.TIMBRE
1989/05/03 - cj  - optimize memory usage on cue placing
1989/04/21 - CJ  - ADDED STORAGE OF EVENT INFORMATION
1989/02/11 - CJ  - MODIFIED SETUP.POLY.INFO TO EXTEND SIGN BITS OF LOOP LENGTH, TOTAL LENGTH
1988/10/19 - TSS - Keep protocol output going during LOOP.SEARCH
1988/10/14 - CJ  - SET NEW KBD PRE AFTER COMPUTING NEW LOOP INFO FOR POLY SYNTH
1988/03/15 - cj  - Send over info to dtd after changing track volume
1987/12/17 - MWH - Merge poly updates with N-Final plus AEE sources
1987/10/09 - EEG - added RECALL.TIMBRE.TO.TRACK
1987/09/09 - MWH - ADDED PREFERED POLY BIN TO TRACK HEADER
1987/08/24 - MWH - Merge with other release-N edits
1987/07/21 - MWH - Update all to support max 4 poly bins, 512mb/bin
1986/12/10 -cj,ts- fixed copy.timbre bug
1986/10/14 - CJ  - CHECK BEFORE CALL TO G.PRIME
1986/09/25 - KJO - UPDATED FOR -7 CATALOG STRUCTURE
1986/09/08 - TS  - PUT CONVERT.SFM.TIMBRES BACK INTO CODE
1986/08/24 - TS  - PUT IN THD.ACTIVE.MIDI.RTES CODE
1986/08/14 - TS  - MADE FURTHER CHANGES SINCE I BLEW IT ON THE 1ST TRY
1986/08/14 - TS  - FIXED BIG BUG IN COPY.TIMBRE (CHECK.FOR.REDUNDANT.TIMBRE)
1986/08/12 - TS  - MODIFIED COPY.TIMBRE TO READ FROM DISK BUT NOT NECESSARILY A .NEWDATA
1986/08/04 - CJ  - SET NEW.SEQ IN COPY.TIMBRE
1986/07/29 -EG,CJ- changes to setup.poly.info and loop.search for stereo sound files
1986/07/24 - tss - removed references to SEQDBUG3
1986/06/17 - TSS - Disabled debug prints in COPY.TIMBRE
1986/06/10 - TSS - Fixed bug in COPY.TIMBRE (Call to COMPACT.TIMBRES was wrong)
1986/05/15 - "official" creation of release-M modules
*/

// Converts old style patchdata timbre banks or old style sequence timbre areas to the current format. Maybe.

CONVERT.SFM.TIMBRES:  PROC(SEC,WD,MAX)	FIXED PUBLIC SWAPABLE;	/*	CONVERTS OLD SFM TIMBRE FORMAT TO NEW FORMAT	*/
	DCL (SEC,WD,MAX,I,J,K,L)	FIXED;

	/*	NOTE: IF THIS ROUTINE RESULTS IN TIMBRE INFO WHICH WOULD BECOME
		LONGER THAN THE 3072 WORDS ALLOCATED FOR IT ORIGINALLY A ZERO IS
		RETURNED FOR THE NEW LENGTH.  IN THIS EVENT, YOU SHOULD ZERO OUT
		ALL 3072 WORDS.	*/

	/*	FIRST COMPUTE LENGTH OF OLD TIMBRE	*/

	WRITE(MAM)=SEC+SHR(WD,8); WRITE(MAL)=WD;

	K=0;											/*	FIND LENGTH				*/
	DO I=0 TO MAX-1;							/*	LOOP OVER TIMBRES		*/
		DO J=0 TO 9;							/*	SKIP OVER 10 WORDS	*/
			L=READ(MDI);
		END;
		K=K+10;
		DO WHILE READ(MDI)<>0;
			DO J=1 TO 11;
				L=READ(MDI);
			END;
			K=K+12;
		END;
		K=K+1;									/*	ACCOUNT FOR TRAILING ZERO	*/
	END;

	CALL COPY.EXT.MEM(SEC,WD,SEC,WD+3072-K,K);	/*	MOVE INFO UP	*/

	I=3072-K;									/*	SOURCE POINTER	*/
	J=0;											/*	DEST	 POINTER	*/

	DO K=0 TO MAX-1;							/*	LOOP OVER 16 TRACKS	*/

		I=I+10;									/*	SKIP 10 WORDS			*/
		WRITE(MAM)=SEC+SHR(WD+I,8);
		WRITE(MAL)=WD+I;

		IF READ(MD)=0 THEN DO;					/*	NO FILES - CREATE NULL TIMBRE	*/
			I=I+1;									/*	ACCOUNT FOR THE 0					*/
			IF (J+12) IGT I THEN RETURN 0;	/*	BOMB OUT -- TIMBRE TOO BIG		*/
			WRITE(MAM)=SEC+SHR(WD+J,8);
			WRITE(MAL)=WD+J;
			DO L=0 TO 11;							/*	CREATE NULL TIMBRE				*/
				WRITE(MDI)=NULL.TIMBRE (L);
			END;
			J=J+12;
		END;
		ELSE DO;										/*	CREATE PATCH LIST TIMBRE		*/
			WRITE(MAM)=SEC+SHR(WD+J,8);
			WRITE(MAL)=WD+J;
			IF (J+46) IGT I THEN RETURN 0;	/*	BOMB OUT -- TIMBRE TOO BIG	*/
			DO L=0 TO 3; WRITE(MDI)=0; END;		/*	DEL ATK IDEC FDEC	*/
			WRITE(MDI)=1000; WRITE(MDI)=1000;	/*	PK SUST				*/
			DO L=6 TO 35;								/*	INDEX, COEFFS		*/
				WRITE(MDI)=0;
			END;
			WRITE(MDI)=4400;					/*	PARTIAL TUNING		*/
			DO L=37 TO 44;
				WRITE(MDI)=0;
			END;
			WRITE(MDI)=1000;					/*	CHORUS				*/
			J=J+46;								/*	ACCOUNT FOR CREATED PARTIAL	*/

			/*	$PAGE	*/

			WRITE(MAM)=SEC+SHR(WD+I,8);	/*	LOOP OVER FILES	*/
			WRITE(MAL)=WD+I;

			DO WHILE READ(MD)<>0;			/*	CREATE PATCH LIST FOR EACH FILE	*/

				IF (J+PT.LEN) IGT I THEN RETURN 0;	/*	BOMB OUT -- TIMBRE TOO BIG	*/
				WRITE(MAM)=SEC+SHR(WD+J,8);
				WRITE(MAL)=WD+J;
				WRITE(MDI)=MOR; WRITE(MDI)=PT.TYPE; WRITE(MDI)=PT.LEN;
				DO L=3 TO PT.LEN-1; WRITE(MDI)=0; END;		/*	ZERO OUT	*/
				CALL COPY.EXT.MEM(SEC,WD+I,SEC,WD+J+3,8);	/*	GRAB THE STUFF	*/

				/*	REPAIR KEY# INFO BY ADDING ONE OCTAVE TO KEY#S	*/
				WRITE(MAM)=SEC+SHR(WD+J+7,8);		/*	FIRST FIX START KEY #	*/
				WRITE(MAL)=WD+J+7;  WRITE(MD)=READ(MD)+12;
				WRITE(MAM)=SEC+SHR(WD+J+8,8);		/*	NEXT FIX END KEY #		*/
				WRITE(MAL)=WD+J+8;  WRITE(MD)=READ(MD)+12;
				WRITE(MAM)=SEC+SHR(WD+J+10,8);	/*	LAST FIX TRANSPOSE KEY #	*/
				WRITE(MAL)=WD+J+10; IF READ(MD)<>0 THEN WRITE(MD)=READ(MD)+12;

				I=I+12;							/*	SKIP OVER SOURCE NAME		*/
				J=J+PT.LEN;						/*	SKIP OVER CREATED PARTIAL	*/

				WRITE(MAM)=SEC+SHR(WD+I,8);	/*	SET UP POINTERS FOR ABOVE CHECK	*/
				WRITE(MAL)=WD+I;
			END;
			I=I+1;									/*	ACCOUNT FOR TRAILING 0	*/

			IF (J+12) IGT I THEN RETURN 0;	/*	BOMB OUT -- TIMBRE TOO BIG	*/
			WRITE(MAM)=SEC+SHR(WD+J,8);		/*	WRITE OUT 3 PARTIALS, MISC	*/
			WRITE(MAL)=WD+J;

			DO L=1 TO 11;						/*	3 SUPPRESSED PARTIALS	*/
				WRITE(MDI)=NULL.TIMBRE(L);	/*	8 MISC WORDS			*/
			END;

			J=J+11;								/*	ACCOUNT FOR THEM	*/
		END;
	END;

	RETURN J+1;									/*	RETURN LENGTH OF NEW TIMBRE	*/
END CONVERT.SFM.TIMBRES;


/*	$SUBTITLE  ROUTINE TO FIND A TIMBRE FILE ON THE DISK	*/

DCL BANK.DEV		FIXED PUBLIC;	/*	GLOBAL VAR FOR DEVICE OF CURRENT BANK	*/
DCL BANK.SEC		FIXED PUBLIC;	/*	GLOBAL VAR FOR BANK SECTOR	*/
DCL OUR.BANK.STR	FIXED PUBLIC;	/*	GLOBAL VAR FOR BANK STRIDE	*/
DCL BANK.MAX		FIXED PUBLIC;	/*	NUMBER OF BANKS AVAILABLE	*/
DCL PAT.FORMAT		FIXED PUBLIC;	/*	TRUE IF .PATDATA  FILE		*/


FIND.NEW.BANK:PROC (BANK)	FIXED PUBLIC SWAPABLE;	/*	PROCEDURE TO TRY TO FIND A NEW TIMBRE BANK ON THE DISK	*/
	DCL BANK			FIXED;				/*	DESIRED BANK -- RETURNS 1 IF FOUND, ELSE 0	*/
	DCL BANK.FOUND BOOLEAN;

   SEARCH: PROC(NAME, FURTHER, LEVEL);       /* SEARCH FOR .NEWDATA AND .BNKDATA ON GIVEN CAT */
		DCL NAME			ARRAY;
		DCL FURTHER		BOOLEAN;
		DCL LEVEL		FIXED;			/*	LEVEL TO SEARCH	*/
		DCL FOUND		BOOLEAN;
		DCL I				FIXED;
		DCL OLD.PREFIX	LIT '"040502"';	/*	BA	*/

		PAT.FORMAT=0;									/*	ASSUME NOT .PATDATA	*/

		IF INC.MONO<>0 THEN CALL STOP.DISK;

      FOUND = LOCATE(NAME, LEVEL);           /* SEARCH FOR .NEWDATA FILE ON GIVEN LEVEL */

		IF FOUND THEN DO;								/*	FOUND IT - COMPUTE THE STRIDE	*/
			IF F#LS_LENGTH IGE 24*8					/*	BIGGER THAN 24 SECTORS/BANK	*/
			THEN DO;
				OUR.BANK.STR=SHR(F#LS_LENGTH,3);	/*	DIVIDE FILE INTO 1/8 THS	*/
				BANK.MAX=8;								/*	ALL 8 BANKS EXIST	*/
			END;
			ELSE DO;										/*	FEWER BANKS	*/
				OUR.BANK.STR=24;	/*	SHORTHER THAN 24*8 SECTORS - USE FEWER BANKS	*/
				LOAD F#LS_LENGTH; DIV 24;
				BANK.MAX=RES;
			END;
		END;												/*	OF FOUND .NEWDATA	*/
      ELSE IF FURTHER THEN DO;               /* .NEWDATA NOT FOUND - SEE IF .BNKDATA THERE */
			DO I = 0 TO SHR(BNKDATA(0) + 1,1);	/*	COPY NAME INTO MISC.BUF	*/
				MISC.BUF(I) = BNKDATA(I);
			END;

			FOUND = LOCATE(MISC.BUF,LEVEL);		/*	SEARCH FOR .BANKDATA	*/
			IF (NOT FOUND) THEN DO;					/*	.BANKDATA NOT FOUND	*/
				MISC.BUF(1) = OLD.PREFIX;			/*	START FILE WITH 'BA' INSTEAD OF '.B'	*/
				FOUND = LOCATE(MISC.BUF,LEVEL);	/*	SEARCH FOR BANKDATA	*/
				IF (NOT FOUND) THEN DO;				/*	NOT FOUND	*/
					FOUND = LOCATE(PATDATA,LEVEL);	/*	SEARCH FOR .PATDATA	*/
					PAT.FORMAT=1;
				END;
			END;
			OUR.BANK.STR=BANK.STRIDE;	/*	IF THERE, IS OLD BANK FORMAT (BNKDATA OR PATDATA)	*/
			BANK.MAX=8;						/*	IF THERE, 8 BANKS EXISTS		*/
		END;

		RETURN (FOUND);				/*	RETURN TRUE IF FILE WAS FOUND	*/
	END SEARCH;

	BANK.DEV = (-1);  BANK.SEC = (-1);	/*	CLEAR OUR PREVIOUS BANK LOCATION	*/

   BANK.FOUND = SEARCH(NEWDATA, TRUE, ACTIVE.LEVEL);  /* TRY ON CURRENT CATALOG */
   IF (NOT BANK.FOUND) AND (DRIVE.SELECT.ACTIVE=0)
   THEN BANK.FOUND=SEARCH(NEWDATA, TRUE, 0); /* TRY ON SYSTEM CATALOG */

	IF BANK.FOUND THEN DO;					/*	FOUND A TIMBRE BANK	*/
		IF BANK IGE BANK.MAX THEN DO;		/*	DESIRED BANK IS NOT IN FILE	*/
			CALL DISPLAY.ERR(13);			/*	DISPLAY ERROR	*/
			BANK.FOUND=FALSE;					/*	FATAL ERROR		*/
		END;
		ELSE DO;									/*	STORE LOCATION OF BANK	*/
			BANK.DEV = F#MS_SECTOR;
			BANK.SEC = F#LS_SECTOR+BANK*OUR.BANK.STR;	/*	COMPUTE DISK POINTER TO START OF BANK	*/
			IF BANK.SEC ILT F#LS_SECTOR THEN BANK.DEV = BANK.DEV + 1;
		END;
	END;
	ELSE CALL DISPLAY.ERR(4);				/*	NEVER FOUND A TIMBRE BANK	*/

	RETURN (BANK.FOUND);						/*	RETURN STATUS - 1 IF FOUND, ELSE 0	*/
END FIND.NEW.BANK;


/*	$SUBTITLE  ROUTINE TO READ A TIMBRE BANK FROM THE DISK	*/

READ.IN.BANK:PROC PUBLIC SWAPABLE;			/*	CALL THIS PROCEDURE TO ATTEMPT TO READ IN NEW TIMBRE BANK FROM DISK	*/
	DCL (I)				FIXED;

	BNK.LEN=0; ACTIVE.BANK.LEN=0;		/*	INDICATE BANK NOT IN MEMORY	*/
	BNK.PTR=INF.PTR;						/*	ZERO LENGTH, BELOW INF.PTR	*/

	IF (NOT FIND.NEW.BANK(OUR.BANK)) THEN RETURN 0;	/*	CANNOT FIND APPROPRIATE NEW BANK	*/

	IF PAT.FORMAT=0 THEN DO;						/*	BANKDATA OR NEWDATA	*/
		BNK.PTR=NAH.PTR+NAH.LEN;					/*	READ IN BANK RIGHT ABOVE SEQ FOR NOW	*/
		CALL GET.BNK.STORAGE(OUR.BANK.STR);		/*	TRY TO GET ROOM	*/
		COPY.BANK=BNK.PTR;							/*	STORE STUFF HERE IN EXT MEMORY	*/
		IF (INF.PTR-BNK.PTR)=0		/*	NOT FOUND IF NO ROOM TO READ IN	*/
		THEN RETURN 0;
		CALL PRIME.IO.BUFFER(BANK.DEV,BANK.SEC,0,
									0,OUR.BANK.STR,
									BNK.PTR,INF.PTR-BNK.PTR,0);	/*	SET UP FOR READ OF DISK	*/
		CALL FIND.DISK.TIM(8);						/*	STEP OVER 8 DISK TIMBRES - LOCATE THEM FOR OPTIMIZATION	*/

		IF COPY.BANK<>0 THEN DO;					/*	IF MEMORY NOT EXCEEDED	*/
			IF OUR.BANK.STR<>BANK.STRIDE
			THEN CALL COMPACT.TIMBRES(BNK.PTR,8);	/*	COMPACT, UNLESS FROM .BNKDATA	*/
			ELSE ACTIVE.BANK.LEN=FIND.TIMBRE(BNK.PTR,8);
			CALL SHUFFLE.BNK.UP;						/*	PUT IN UPPER MEMORY	*/
			COPY.BANK=0;								/*	CLEAR FLAG			*/
		END;
		ELSE DO;											/*	BANK DID NOT FIT	*/
			BNK.LEN=0;
			BNK.PTR=INF.PTR;							/*	LEAVE UP HIGH		*/
		END;
	END;

	ELSE DO;												/*	PAT DATA			*/
		BNK.PTR=NAH.PTR+NAH.LEN;					/*	READ IN BANK RIGHT ABOVE SEQ FOR NOW	*/
		IF GET.BNK.STORAGE(12)<>0 THEN DO;		/*	GET ROOM FOR CONVERT.SFM.TIMBRES	*/
			CALL EXT.READDATA(BANK.DEV,BANK.SEC,BNK.PTR,0,6,0);	/*	READ IN 8 TIMBRES	*/
			ACTIVE.BANK.LEN=CONVERT.SFM.TIMBRES(I,0,8);			/*	TRY TO CONVERT	*/
		END;
		IF ACTIVE.BANK.LEN<>0 THEN DO;			/*	SUCCESSFUL ALLOCATION & CONVERSION	*/
			BNK.LEN=SHR(ACTIVE.BANK.LEN+255,8);	/*	SEE HOW MANY COMPLETE SECTORS IN EXTERNAL MEMORY ARE NOT REALLY PART OF THE BANK	*/
			CALL SHUFFLE.BNK.UP;						/*	PUT IN UPPER MEMORY	*/
		END;
		ELSE DO;											/*	BANK DID NOT FIT	*/
			BNK.LEN=0;
			BNK.PTR=INF.PTR;							/*	LEAVE UP HIGH	*/
		END;
	END;

	RETURN 1;											/*	BANK WAS FOUND	*/

END READ.IN.BANK;


/*	$SUBTITLE  SUPPORT ROUTINES FOR COPY.TIMBRE ROUTINE	*/

FIND.USABLE.DEST:  PROC	FIXED PUBLIC SWAPABLE;	/*	FINDS AN UNUSED TIMBRE SLOT	*/
	DCL I	FIXED;

	WRITE(MAM)=USE.PTR; WRITE(MAL)=NUM.KBD.TRACKS;

	DO I=NUM.KBD.TRACKS TO PAR.NUMT-1;	/*	LOOP OVER DEFINED TIMBRES	*/
		IF READ(MDI)=0 THEN RETURN I;
	END;

	RETURN PAR.NUMT;
END FIND.USABLE.DEST;


CHECK.FOR.REDUNDANT.TIMBRE:  PROC (TRK,TB)	FIXED PUBLIC SWAPABLE;	/*	ELIMINATES DUPLICATE COPIES OF A TIMBRE	*/
	DCL (TRK)	FIXED;	/*	TRK # OF TRK WE ARE DOING COPY.TIMBRE TO	*/
	DCL (TB,I,J)	FIXED;

	ADJUST.TRK.TIMBRE.#:  PROC (OLD#,NEW#,TRK);
		DCL (OLD#,NEW#,TRK)	FIXED;
		DCL (I,J,K)			FIXED;

		DO J=NUM.KBD.TRACKS TO MAX.TRACKS-1;	/*	LOOP THROUGH ALL SEQUENCER TRKS	*/

			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=J;
			I=READ(MD);

			IF  (I<>0)						/*	TRK HAS A TRK HEAD	*/
			AND (J<>TRK)					/*	WE ARE NOT DOING COPY.TIMBRE ON THIS TRK	*/
			THEN DO;							/*	CHECK ITS TIMBRE USES	*/
				WRITE(MAM)=I;				/*	POINT TO IT		*/

				/*	LOOK AT EACH TRACK.  IF TRK USES			*/
				/*	THE TIMBRE WE ARE ABOUT TO GET RID OF,	*/
				/*	OLD#, THEN MAKE IT USE THE EQUIVALENT	*/
				/*	TIMBRE, NEW#.									*/

				WRITE(MAL)=THD.STIMB;				/*	CHECK STARTING TIMBRE	*/
				IF READ(MD)=OLD# THEN WRITE(MD)=NEW#;
				WRITE(MAL)=THD.CTIMB;				/*	CHECK CURRENT TIMBRE	*/
				IF READ(MD)=OLD# THEN WRITE(MD)=NEW#;
				WRITE(MAL)=THD.ILS.CTIMB;			/*	CHECK ILP START TIMBRE	*/
				IF READ(MD)=OLD# THEN WRITE(MD)=NEW#;
				WRITE(MAL)=THD.ILE.CTIMB;			/*	CHECK ILP END TIMBRE	*/
				IF READ(MD)=OLD# THEN WRITE(MD)=NEW#;
				WRITE(MAL)=THD.LP.CTIMB;			/*	CHECK OVERALL LOOP START TIMBRE	*/
				IF READ(MD)=OLD# THEN WRITE(MD)=NEW#;

				DO K=0 TO THD.USAGE.LEN-1 BY 2;	/*	CHECK TIMBRE USAGE TABLE	*/
					WRITE(MAL)=THD.USAGE+K;
					IF READ(MD)=OLD# THEN DO;
						WRITE(MD)=NEW#;				/*	CHANGE TO NEW TIMBRE #	*/

						WRITE(MAM)=USE.PTR;			/*	AND FIX UP THE USE TABLE	*/
						WRITE(MAL)=OLD#;
						WRITE("300")=READ(MD);		/*	THIS MANY USES WILL BE TRANSFERRED TO THE NEW#	*/
						WRITE(MD)=0;
						WRITE(MAL)=NEW#;
						WRITE(MD)=READ(MD)+READ("300");	/*	ADD TO NEW# USES	*/

						WRITE(MAM)=I;					/*	RESTORE PTR TO TRK HEAD	*/
					END;
				END;

			END;								/*	OF TRK HAS A TRK HEAD	*/
		END;									/*	OF LOOP OVER SEQUENCER TRKS	*/

	END ADJUST.TRK.TIMBRE.#;


	I=MATCHING.TIMBRE(TB);				/*	SEE IF TIMBRE ALREADY EXISTS	*/

	IF I<PAR.NUMT THEN DO;				/*	NEW TIMBRE IS REDUNDANT	*/
		IF I<TB THEN DO;					/*	SWAP THE TWO TIMBRE NUMBERS	*/
			J=TB; TB=I; I=J;				/*	SO WE COMPRESS OUT THE HIGHER ONE	*/
		END;

		CALL ADJUST.TRK.TIMBRE.#(I,TB,TRK);	/*	KEEP USAGE TABLE AND TRK HEADS FOR OTHER TRKS CORRECT	*/

		CALL ERASE.TIMBRE(I);			/*	GET RID OF TIMBRE TO DEALLOCATE ITEMS	*/
		IF I=(PAR.NUMT-1)					/*	DUPLICATE TIMBRE IS LAST IN PAR AREA	*/
		THEN DO;								/*	SHORTEN THE PAR AREA	*/
			CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT-1);	/*	GET RID OF THE TIMBRE	*/
		END;
	END;

	RETURN TB;								/*	RETURN THE REMAPPED TIMBRE NUMBER		*/

END CHECK.FOR.REDUNDANT.TIMBRE;


/*	$PAGE	*/


/*	MOVE.FROM.BANK - THIS PROCEDURE MOVES A TIMBRE FROM A TIMBRE BANK
.	(HOPEFULLY IN MEMORY) TO THE KEYBOARD, OR A TRACK (SMT).  THE ROUTINE
.	CHECKS TO SEE IF THE CURRENT BANK IS IN MEMORY, AND LOADS IT IF NOT.
.	IT READS THE TIMBRE DIRECTLY FROM THE DISK IF THE BANK AND TIMBRE
.	WILL NOT FIT IN MEMORY TOGETHER.
.
.	A VALUE OF ** ONE  ** IS RETURNED IF THE MOVE WAS SUCCESSFUL.
.	A VALUE OF ** ZERO ** INDICATES AN ERROR (NO BANK ON DISK, NOT ENOUGH MEMORY, ETC.)	*/

MOVE.FROM.BANK: PROC(DES)	FIXED SWAPABLE;	/*	PROCEDURE TO PERFORM TIMBRE MOVE FROM BANK	*/
	DCL (DES,MUST.READ,K)	FIXED;

	CALL SETUP.FLOPPY.CACHE;			/*	SET UP FLOPPY CACHE				*/
	CALL MOUNT.OPTICAL.VOLUME;			/*	ALSO CACHE OPT DISK IF NEEDED	*/

	MUST.READ=(BNK.LEN<>0);				/*	IF BANK IS IN MEMORY, WE MUST RE-READ POSSIBLY NEW DISK TO CONSTRUCT INDEX	*/

	IF (BNK.LEN=0) THEN DO;				/*	TRY TO READ IN BANK	*/
		K=READ.IN.BANK;					/*	TRY TO PUT BANK IN MEMORY - CONSTRUCT INDEX IN ANY CASE. DISPLAY ERROR IF NO FILE.	*/
		ABRT.LIMIT=0;						/*	RESET ABRT.LIMIT FOR OTHER CALLS	*/
		IF K=0 THEN DO;
			FLOPPY.CACHE.VALID=0;
			CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
			OPTICAL.DISK.READY=0;
			RETURN 0;						/*	NO BANK IN MEMORY, CAN NOT FIND ONE ON DISK - RETURN - CAN NOT READ TIMBRE!!	*/
		END;
	END;

	IF (RECD)&(RECD.TRK<>0) THEN DO;
		CALL STOP.RECORD;	/*	STOP RECORDING ON TIMBRE RECALL	*/
		CALL DISPLAY.SEQUENCER.STATUS;
	END;

	IF (BNK.LEN<>0) THEN DO;		/*	BANK IN MEMORY (EITHER FROM BEFORE, OR JUST READ IN) - TRY TO MOVE TIMBRE FROM IN-CORE BANK	*/
		SUPPRESS.ERR=1;				/*	SUPPRESS ERR11 PRINTOUT	*/
		CALL MOVE.TIMBRE.TO(BNK.PTR,FIND.TIMBRE(BNK.PTR,OUR.TIMBRE),DES);
		SUPPRESS.ERR=0;				/*	ALLOW THEM NOW	*/
		IF LENGTH.OVERFLOW=0 THEN DO;
			FLOPPY.CACHE.VALID=0;
			CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
			OPTICAL.DISK.READY=0;
			RETURN 1;	/*	OK MOVE IF NO ERROR	*/
		END;
	END;

	IF (PAT.FORMAT<>0) THEN DO;	/*	PAT FORMAT - CAN NOT USE MOVE.TIMBRE.TO FROM DISK	*/
		CALL DISPLAY.ERR(14);		/*	NOT ENOUGH MEMORY	*/
		FLOPPY.CACHE.VALID=0;
		CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
		OPTICAL.DISK.READY=0;
		RETURN 0;						/*	NOT THERE	*/
	END;

	IF MUST.READ=0						/*	PRIME BUFFER AT START OF TIMBRE	*/
	THEN CALL PRIME.IO.BUFFER(INDEX.DEV(OUR.TIMBRE),INDEX.SEC(OUR.TIMBRE),INDEX.PTR(OUR.TIMBRE),
									  0,BANK.SEC+OUR.BANK.STR-INDEX.SEC(OUR.TIMBRE),
									  EXTBUF.PTR,EXTBUF.LEN,0);

	/*	POINTERS WERE COMPUTED IN ABOVE CALL TO READ.IN.BANK	*/

	ELSE DO;	/*	OOPS - MUST CHECK FOR NEW DISK	*/
		IF FIND.NEW.BANK(OUR.BANK)=0 THEN DO;
			FLOPPY.CACHE.VALID=0;
			CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
			OPTICAL.DISK.READY=0;
			RETURN 0;	/*	MAKE SURE BANK STILL AVAILABLE ON THIS DISKETTE	*/
		END;
		IF (PAT.FORMAT<>0) THEN DO;	/*	PAT FORMAT - CAN NOT USE MOVE.TIMBRE.TO FROM DISK	*/
			CALL DISPLAY.ERR(14);		/*	NOT ENOUGH MEMORY	*/
			FLOPPY.CACHE.VALID=0;
			CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
			OPTICAL.DISK.READY=0;
			RETURN 0;						/*	NOT THERE	*/
		END;
		CALL PRIME.IO.BUFFER(BANK.DEV,BANK.SEC,0,
									0,OUR.BANK.STR,
									EXTBUF.PTR,EXTBUF.LEN,0);	/*	OOPS - MUST RE-READ DISK- CAN NOT USE INDEX IN CASE DIFFERET DISK	*/
		CALL FIND.DISK.TIM(OUR.TIMBRE);	/*	SKIP TO DESIRED TIMBRE	*/
	END;

	CALL MOVE.TIMBRE.TO(-1,0,DES);	/*	MOVE FROM DISK TO DESTINATION	*/

	FLOPPY.CACHE.VALID=0;
	CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);	/*	DISABLE CACHE	*/
	OPTICAL.DISK.READY=0;

	IF LENGTH.OVERFLOW=0 THEN RETURN 1;	/*	OK MOVE IF NO ERROR	*/
	RETURN 0;	/*	LENGTH ERROR	*/

END MOVE.FROM.BANK;


/*	$SUBTITLE  ROUTINE TO COPY TIMBRES BETWEEN TRACKS	*/


/*	SPECIAL CASES:
		FROM.TRK >= 2		SOURCE IS ANOTHER TRACK
		FROM.TRK  = 1		UNDEFINED
		FROM.TRK  = 0		SOURCE IS KEYBOARD
		FROM.TRK  = -1		SOURCE IS A TIMBRE ON DISK STORED IN .NEWDATA
		FROM.TRK  = -2		SOURCE IS A TIMBRE ON DISK (BUT NOT .NEWDATA)
		FROM.TRK  = -3		A NEW NULL TIMBRE IS CREATED FOR THIS TRACK.
*/

COPY.TIMBRE:  PROC (FROM.TRK,TO.TRK)	FIXED PUBLIC SWAPABLE;	/*	COPIES A TIMBRE FROM ONE TRK TO ANOTHER	*/
	DCL FROM.TRK			FIXED;	/*	SOURCE INFO		*/
	DCL TO.TRK				FIXED;	/*	DESTINATION TRK	*/
	DCL (NEW.T#,OLD.T#)	FIXED;
	DCL I						FIXED;

	IF FROM.TRK=TO.TRK  THEN RETURN 1;	/*	NOTHING TO DO	*/

	LENGTH.OVERFLOW	= 0;					/*	ALWAYS CLEAR	*/
	EDIT.ERROR			= 0;					/*	CLEAR ERROR FLAG	*/

	/*	Create a New Seq Info event when copying timbres around in memory	*/
	/*	since the timbre assigned to a certain track may change:				*/
	if (TO.TRK > 2)	interp_seq_dirtyness(true);

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 2;		/*	REDRAW INSTRUMENT NAMES ON ANY COPYTIMBRE ACTIVITY	*/
	WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
	WRITE(MAL) = TO.TRK;						/*	REMEMBER TRACK # ON NEW.SEQ.INFO	*/
	WRITE(MD) = "177777";					/*	"NEW NOTES" OR "NEW TIMBRE"		*/

	IF (RECD)&(RECD.TRK<>0) THEN DO;
		CALL STOP.RECORD;						/*	STOP RECORDING ON TIMBRE RECALL	*/
		CALL DISPLAY.SEQUENCER.STATUS;
	END;

	IF TO.TRK<NUM.KBD.TRACKS THEN DO;	/*	COPYING TIMBRE TO A KEYBOARD TIMBRE	*/
		IF FROM.TRK=(-1) THEN DO;			/*	COPY TIMBRE DIRECTLY FROM DISK	*/
			IF MOVE.FROM.BANK(TO.TRK)=0	/*	PUT CURRENT ENTRY ONTO KBD	*/
			THEN RETURN 0;						/*	HAD AN ERROR - BOMB OUT	*/
		END;
		ELSE IF FROM.TRK=(-2) THEN DO;	/*	FROM DISK BUT NOT A .NEWDATA	*/
			CALL MOVE.TIMBRE.TO(-1,0,TO.TRK);	/*	MOVE FROM DISK TO DESTINATION	*/
		END;
		ELSE IF FROM.TRK=(-3) THEN DO;	/*	NEW NULL TIMBRE DESIRED	*/
			CALL MOVE.TIMBRE.TO(NUL.PTR,0,TO.TRK);
		END;
		ELSE IF FROM.TRK<NUM.KBD.TRACKS	/*	COPYING THE UPPER KBD TIMBRE TO THE	*/
		THEN DO;									/*	LOWER KBD TIMBRE, OR VICE VERSA	*/
			CALL MOVE.TIMBRE.TO(PAR.PTR,FIND.TIMBRE(PAR.PTR,FROM.TRK),TO.TRK);
			IF LENGTH.OVERFLOW=0
			THEN RETURN 1;						/*	ALL DONE	*/
			ELSE RETURN 0;
		END;
		ELSE DO;									/*	SOURCE TIMBRE COMES FROM SEQUENCER TRACK	*/
			WRITE(MAM)=TRK.HEAD;
			WRITE(MAL)=FROM.TRK;

			IF READ(MD)<>0 THEN DO;			/*	WE HAVE A TRACK HEAD	*/
				WRITE(MAM)=READ(MD);
				WRITE(MAL)=THD.STIMB;

				IF READ(MD)>=NUM.KBD.TRACKS	/*	SOURCE TRACK HAS A TIMBRE	*/
				THEN CALL MOVE.TIMBRE.TO(PAR.PTR,FIND.TIMBRE(PAR.PTR,READ(MD)),TO.TRK);
				ELSE CALL MOVE.TIMBRE.TO(NUL.PTR,0,TO.TRK);	/*	MAKE COPY OF NULL TIMBRE	*/
			END;
			ELSE CALL MOVE.TIMBRE.TO(NUL.PTR,0,TO.TRK);	/*	MAKE COPY OF NULL TIMBRE	*/

		END;

		IF LENGTH.OVERFLOW<>0 THEN DO;	/*	CANNOT CONTINUE - OUT OF MEMORY	*/
			EDIT.ERROR = E#NOROOM;
			RETURN 0;
		END;

		/*	FIX UP TRACK HEAD INFO:						*/
		/*	MOVE.TIMBRE.TO RESETS TRK VOL=100.0,	*/
		/*	MIDI ROUTING=0 FOR MAIN KBD TIMBRE		*/

		IF  (FROM.TRK>=NUM.KBD.TRACKS)	/*	COPYING FROM TRACK		*/
		AND (TO.TRK   =0)						/*	TO THE MAIN KBD TIMBRE	*/
		THEN DO;
			CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.TROU);		/*	LOOK UP SOURCE TROUT	*/
			CALL TRK.HEAD.STORE(0,THD.TROU,READ(MD));		/*	COPY TO MAIN KBD TRK	*/
			CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.TVOL);		/*	LOOK UP SOURCE TVOL	*/
			CALL TRK.HEAD.STORE(0,THD.TVOL,READ(MD));		/*	COPY TO MAIN KBD TRK	*/
			CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDX);		/*	LOOK UP SOURCE MIDX	*/
			CALL TRK.HEAD.STORE(0,THD.MIDX,READ(MD));		/*	COPY TO MAIN KBD TRK	*/
			CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.CUE.OUT);	/*	LOOK UP SOURCE TVOL	*/
			CALL TRK.HEAD.STORE(0,THD.CUE.OUT,READ(MD));	/*	COPY TO MAIN KBD TRK	*/
			I=TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDI);			/*	LOOK UP SOURCE MIDI ROUTING	*/
			CALL TRK.HEAD.STORE(0,THD.MIDI,I);				/*	COPY TO MAIN KBD TRK	*/
			IF I<>0
			THEN CALL SET.MIDI.OUT.CONTROLLERS  (0);
			ELSE CALL CLEAR.MIDI.OUT.CONTROLLERS(0);
			I=TRK.HEAD.LOOKUP(FROM.TRK,THD.ACTIVE.MIDI.RTES);	/*	LOOK UP SOURCE MIDI RTE BITS	*/
			CALL TRK.HEAD.STORE(0,THD.ACTIVE.MIDI.RTES,I);		/*	COPY TO MAIN KBD TRK	*/
			CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDI.PATH);		/*	LOOKUP SOURCE MIDINET ROUTING	*/
			CALL TRK.HEAD.STORE(0,THD.MIDI.PATH,READ(MD));		/*	COPY TO MAIN KBD TIMBRE	*/
			NEW.MOTION				  = 1;	/*	SEND NEW CUE TRACK CONSTANTS			*/
			NEW.CUE.TRACK.SETTINGS = 1;	/*	OVER AFTER CHANGING VOLUME/ROUTING	*/
		END;

		RETURN 1;								/*	ALL DONE	*/
	END;	//	end of if (TO.TRK < NUM.KBD.TRACKS)

	/*	$PAGE - COPYING TIMBRE TO A SEQUENCER TRACK DESTINATION	*/

	IF FROM.TRK=(-1) THEN DO;				/*	SOURCE IS THE DISK - I.E. A .NEWDATA FILE	*/
		NEW.T#=FIND.USABLE.DEST;			/*	FIGURE OUT POSITION FOR NEW TIMBRE	*/

		IF MOVE.FROM.BANK(NEW.T#)=0		/*	HAD AN ERROR READING TIMBRE	*/
		THEN RETURN 0;							/*	HAVE TO BOMB OUT	*/

		NEW.T#=CHECK.FOR.REDUNDANT.TIMBRE(TO.TRK,NEW.T#);	/*	MAKE SURE WE ONLY HAVE 1 COPY OF THE TIMBRE	*/
	END;
	ELSE IF FROM.TRK=(-2) THEN DO;		/*	SOURCE IS DISK - BUT NOT A NEWDATA	*/
		NEW.T#=FIND.USABLE.DEST;			/*	FIGURE OUT POSITION FOR NEW TIMBRE	*/

		CALL MOVE.TIMBRE.TO(-1,0,NEW.T#);	/*	MOVE FROM DISK TO DESTINATION	*/

		IF LENGTH.OVERFLOW<>0 THEN DO;	/*	RAN OUT OF MEMORY	*/
			EDIT.ERROR = E#NOROOM;
			RETURN 0;							/*	LENGTH ERROR		*/
		END;

		NEW.T#=CHECK.FOR.REDUNDANT.TIMBRE(TO.TRK,NEW.T#);	/*	MAKE SURE WE ONLY HAVE 1 COPY OF THE TIMBRE	*/
	END;
	ELSE IF FROM.TRK=(-3) THEN DO;		/*	NEW NULL TIMBRE DESIRED	*/
		NEW.T#=FIND.USABLE.DEST;			/*	FIGURE OUT POSITION FOR NEW TIMBRE	*/

		DISPLAY.EBL=0;							/*	SUPPRESS DISPLAYS DURING THIS COPY	*/
		CALL MOVE.TIMBRE.TO(NUL.PTR,0,NEW.T#);
		DISPLAY.EBL=1;							/*	ALLOW DISPLAYS NOW		*/

		IF LENGTH.OVERFLOW<>0 THEN DO;	/*	RAN OUT OF MEMORY	*/
			EDIT.ERROR = E#NOROOM;
			RETURN 0;					/*	LENGTH ERROR		*/
		END;
											/*	DO NOT CHECK FOR REDUNDANT TIMBRE	*/
	END;									/*	SINCE WE WANT OUR OWN				*/

	WRITE(MAM)=TRK.HEAD;
	WRITE(MAL)=TO.TRK;

	IF READ(MD)=0 THEN DO;			/*	DEST TRACK HEAD DOESN'T EXIST - CREATE IT	*/
		IF ALLOCATE.TRK.HEADER(TO.TRK)=0
		THEN DO;
			EDIT.ERROR = E#NOROOM;
			RETURN 0;					/*	IF WE BOMB OUT	*/
		END;

		OLD.T#=(-1);					/*	DENOTES NO ORIGINAL TIMBRE	*/
	END;
	ELSE DO;								/*	SEE WHICH TIMBRE IS ON THIS TRACK	*/
		OLD.T#=TRK.HEAD.LOOKUP(TO.TRK,THD.STIMB);	/*	GET ORIGINAL TIMBRE #	*/
	END;

	IF FROM.TRK>=0 THEN DO;					/*	SOURCE TRK IS NOT FROM THE DISK	*/
		WRITE(MAM)=TRK.HEAD;
		WRITE(MAL)=FROM.TRK;

		IF  (READ(MD)<>0)						/*	SOURCE TRK HAS A TRACK HEAD	*/
		AND (FROM.TRK >=NUM.KBD.TRACKS)	/*	COPYING TRACK TIMBRE TO NEW TRACK	*/
		THEN DO;									/*	DO SIMPLE FORM OF TIMBRE COPY		*/

			WRITE(MAM)=READ(MD);				/*	SEE WHICH TIMBRE IS USED	*/
			WRITE(MAL)=THD.STIMB;			/*	ON THE SOURCE TRACK	*/

			IF READ(MD)>=NUM.KBD.TRACKS	/*	TRACK SEEMS TO USE A REAL TIMBRE	*/
			THEN DO;
				NEW.T#=READ(MD);				/*	SAVE SOURCE TIMBRE #	*/

				WRITE(MAM)=TIM.HEAD;
				WRITE(MAL)=NEW.T#;
				IF READ(MD)=0 THEN DO;		/*	NO TIMBRE HEAD - BIG PROBLEM!!!	*/
					RETURN 0;					/*	SYSTEM ERROR	*/
				END;
			END;
			ELSE GOTO COPY.NULL.TIMBRE;	/*	NO TIMBRE ON TRACK	*/
		END;
		ELSE DO;									/*	NEED TO DO A MOVE.TIMBRE.TO	*/
			IF READ(MD)=0						/*	SOURCE TRACK HAS NO TRK HEAD	*/
			THEN DO;

				COPY.NULL.TIMBRE:

				NEW.T#=FIND.USABLE.DEST;	/*	FIGURE OUT POSITION FOR NEW TIMBRE	*/
				CALL MOVE.TIMBRE.TO(NUL.PTR,0,NEW.T#);	/*	MAKE COPY OF NULL TIMBRE	*/
			END;
			ELSE DO;								/*	COPY KBD TIMBRE	*/
				NEW.T#=FIND.USABLE.DEST;	/*	FIGURE OUT POSITION FOR NEW TIMBRE	*/
				CALL MOVE.TIMBRE.TO(PAR.PTR,0,NEW.T#);	/*	MAKE COPY OF KBD TIMBRE	*/
			END;

			IF LENGTH.OVERFLOW<>0 THEN DO;	/*	CANNOT CONTINUE - OUT OF MEMORY	*/
				EDIT.ERROR = E#NOROOM;
				RETURN 0;
			END;

			NEW.T#=CHECK.FOR.REDUNDANT.TIMBRE(TO.TRK,NEW.T#);	/*	MAKE SURE WE ONLY HAVE 1 COPY OF THE TIMBRE	*/
		END;
	END;	/*	OF SOURCE TRK IS NOT THE TIMBRE BANK	*/

	/*	AT THIS POINT, OLD.T# CONTAINS THE TIMBRE NUMBER OF THE ORIGINAL	*/
	/*	TIMBRE ON THE TO.TRK, AND NEW.T# CONTAINS THE NUMBER OF THE			*/
	/*	TIMBRE WHICH SHOULD BE PUT ONTO THE TO.TRK.								*/

	IF NEW.T#<>OLD.T# THEN DO;			/*	TIMBRE NUMBERS ARE DIFFERENT	*/

		CALL TRK.HEAD.STORE(TO.TRK,THD.STIMB,NEW.T#);	/*	SAVE NEW STARTING TIMBRE #	*/
		WRITE(MAL)=THD.CTIMB;	 WRITE(MD)=NEW.T#;
		WRITE(MAL)=THD.LP.CTIMB; WRITE(MD)=NEW.T#;
		WRITE(MAL)=THD.ILP;
		IF READ(MD)<>0 THEN DO;	/*	SET VARS IF ILP ON OUR TRACK	*/
			WRITE(MAL)=THD.ILS.CTIMB; WRITE(MD)=NEW.T#;
			WRITE(MAL)=THD.ILE.CTIMB; WRITE(MD)=NEW.T#;
		END;

		/*	KEEP THE USAGE COUNTER INFO CORRECT	*/

		IF  (OLD.T#>=NUM.KBD.TRACKS)						/*	TRACK ACTUALLY HAD A TIMBRE	*/
		THEN CALL DEALLOC.TIMBRE.USES(TO.TRK);			/*	ACCOUNT FOR TIMBRES NO LONGER USED BY THIS TRK	*/

		CALL TRK.HEAD.STORE(TO.TRK,THD.USAGE,NEW.T#);	/*	NEW TIMBRE USE	*/
		WRITE(MD)=1;												/*	JUST ONE USE	*/

		CALL ALLOC.TIMBRE.USES(TO.TRK);	/*	ACCOUNT FOR NEW TIMBRE ON TRK	*/

		CALL COMPUTE.ARLIST;					/*	SET UP THD.CUE.TRACK, RIBBON LISTS	*/
	END;

	IF FROM.TRK<0 THEN DO;	/*	TIMBRE ENTRY TO TRACK	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.TVOL,1000);		/*	TRACK VOL = 100.0	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.MIDI,0);			/*	MIDI ROUTING OFF	*/
		CALL CLEAR.MIDI.OUT.CONTROLLERS(TO.TRK);
		CALL TRK.HEAD.STORE(TO.TRK,THD.ACTIVE.MIDI.RTES,GID(Default.MIDI.RTEs));
		CALL TRK.HEAD.STORE(TO.TRK,THD.MIDI.PATH,0);		/*	MIDINET ROUTING OFF ALSO	*/
      CALL TRK.HEAD.STORE(TO.TRK,THD.MIDX,0);		   /*	MIDI OUTPUT XPOS OFF ALSO	*/
	END;
	ELSE DO;	/*	KBD OR OTHER TRACK TO OUR TRACK	*/
		CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.TVOL);			/*	LOOK UP SOURCE TVOL	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.TVOL,READ(MD));	/*	COPY TO DEST TRK		*/
	   CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDX);		   /*	LOOK UP SOURCE MIDX	*/
	   CALL TRK.HEAD.STORE(TO.TRK,THD.MIDX,READ(MD)); /*	COPY TO DEST TRK     */
		CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.POLY);			/*	LOOK UP SOURCE POLY	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.POLY,READ(MD));	/*	COPY TO DEST TRK		*/
		I=TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDI);				/*	LOOK UP SOURCE MIDI ROUTING	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.MIDI,I);			/*	COPY TO DEST TRK		*/
		IF I<>0
		THEN CALL SET.MIDI.OUT.CONTROLLERS  (TO.TRK);
		ELSE CALL CLEAR.MIDI.OUT.CONTROLLERS(TO.TRK);
		CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.ACTIVE.MIDI.RTES);	/*	LOOK UP SOURCE MIDI RTE BITS	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.ACTIVE.MIDI.RTES,READ(MD));	/*	COPY TO MAIN KBD TRK	*/
		CALL TRK.HEAD.LOOKUP(FROM.TRK,THD.MIDI.PATH);			/*	LOOKUP SOURCE MIDINET ROUTING	*/
		CALL TRK.HEAD.STORE(TO.TRK,THD.MIDI.PATH,READ(MD));	/*	COPY TO DEST TRK	*/

		WRITE(MAM)=TRK.HEAD;									/*	NOW CHECK TO SEE IF SOURCE TRACK HAD A HEADER	*/
		WRITE(MAL)=FROM.TRK;
		IF READ(MD)=0 THEN DO;								/*	SOURCE TRACK HAS NO HEADER	*/
			CALL TRK.HEAD.STORE(TO.TRK,THD.ACTIVE.MIDI.RTES,GID(Default.MIDI.RTEs));	/*	SET DEFAULTS SO THIS TRACK CAN ECHO THESE CONTROLLERS	*/
		END;

	END;

	NEW.MOTION				  = 1;	/*	SEND NEW CUE TRACK CONSTANTS		*/
	NEW.CUE.TRACK.SETTINGS = 1;	/*	OVER AFTER TRACK HEAD ALLOCATE	*/

	RETURN 1;	/*	EVERYTHING IS A-OK!!	*/

END COPY.TIMBRE;

/*	$PAGE - CREATE CUE OR EVENT LIST	*/

/*	ADD.EVENT.TO.LIST IS PASSED AN ABSOLUTE TRACK #, A CUE NAME (IN STRING
	FORMAT), AND A CUE ID# (SINCE IT IS USUALLY AVAILABLE), SOME EVENT INFO,
	AND A CAPTION.

	IT ADDS THE INFO TO THE CUE LIST FOR THAT TRACK, AND RETURNS THE 'KEY'
	NUMBER TO USE IN THE NOTE LIST.  IF A NONZERO KEY# IS PASSED,
	THEN IT IS USED IF IT IS FREE.

	IF THE CUE IS ALREADY IN THE CUE LIST FOR THIS TRACK, IT'S KEY
	NUMBER IS RETURNED.

	ERROR CONDITIONS ARE RETURNED AS FOLLOWS:
		-1 : OUT OF ROOM IN MEMORY FOR CUE LIST, TRACK HEADER, ETC.
		-2 : TRACK IS A NON-EMPTY FM OR POLY SYNTH TRACK
		-3 : CUE LIST IS FULL (250 CUES MAX PER TRACK)
*/

DCL LAST.EVENT	FIXED PUBLIC;		/*	FLAG TO ACTIVATE CLEAN UP ROUTINES AFTER PLACE OF LAST EVENT IN BLOCK	*/

ADD.EVENT.TO.LIST:PROC(TRACK#, CUENAME, CUEID# ,KEY#,
							  EVENTINFO, CAPTION, CODE) PUBLIC SWAPABLE;
	DCL TRACK#				FIXED;	/*	PASS ABSOLUTE TRACK #	*/
	DCL CUENAME				ARRAY;	/*	CUE NAME, IN ARRAY		*/
	DCL CUEID#				FIXED;	/*	PASS CUE ID#				*/
	DCL KEY#					FIXED;	/*	KEY# TO USE OR 0			*/
	DCL EVENTINFO			ARRAY;	/*	EVENT SPECIFIC INFO		*/
	DCL CAPTION				ARRAY;	/*	CAPTION FOR EVENT			*/
	DCL CODE					FIXED;	/*	PASS CU.TYPE OR EV.TYPE	*/

	DCL (I,J,K,L,M,N,P,Q)	FIXED;
	DCL (MAXKEY#)			FIXED;
	DCL (PTL)				FIXED;
	DCL (FOUND)				FIXED;
	DCL (EMPTYONE)			FIXED;
	DCL (EMPTYKEY)			FIXED;

	DCL INSERT.PTL			FIXED;	/*	SET UP THIS INFORMATION TO TELL	*/
	DCL INSERT.PTR			FIXED;	/*	LATER CODE WHERE TO STORE THE		*/
	DCL INSERT.LENGTH		FIXED;	/*	EVENT INFORMATION.					*/
	DCL FILL.IN.PARTIAL	FIXED;
	DCL START.FRAME.HERE	FIXED;
	DCL NEW.FRAME.SIZE	FIXED;

	DCL FLENS(NUM.PARTIALS-1)	FIXED;

	clean.string:proc(name);
		dcl (name)	array;
		if name(0) then call pbyte(name,name(0),0);	/*	zero fill upper byte for compare	*/
	end clean.string;

	/*	Create a system event when adding an event to a timbre since	*/
	/*	the timbre name of a track may change.  This occurs				*/
	/*	because the timbre name of a track defaults to the name			*/
	/*	of the first cue on that track if there is no other name			*/
	/*	explicitly assigned.															*/

	interp_seq_dirtyness(1);

	NEW.SEQ.INFO = NEW.SEQ.INFO \ 2;	/*	REDRAW INSTRUMENT NAMES ANY TIME	*/
												/*	EVENT IS ADDED TO LIST.				*/
	WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
	WRITE(MAL) = TRACK#;					/*	REMEMBER TRACK # ON NEW.SEQ.INFO	*/
	WRITE(MD) = "177777";				/*	"NEW NOTES" OR "NEW TIMBRE"		*/

	CALL CLEAN.STRING(CUENAME);
	CALL CLEAN.STRING(CAPTION);

	IF CODE = CU.TYPE
	THEN NEW.FRAME.SIZE = CU.NAME + SHR(CUENAME(0)+3,1);

	ELSE IF CODE = EV.TYPE
	THEN NEW.FRAME.SIZE = EV.NAME + SHR(CUENAME(0)+3,1) + SHR(CAPTION(0)+3,1);

	ELSE STOP;	/*	THAT WILL CATCH ANY SLOPPY SYSTEM PROGRAMMERS QUICKLY	*/

	IF CUENAME(0)=0 THEN RETURN -1;			/*	USER ERROR				*/

	WRITE(MAM)=TRK.HEAD;							/*	SEE IF TRACK HEAD		*/
	WRITE(MAL)=TRACK#;							/*	EXISTS					*/

	IF READ(MD)=0 THEN DO;						/*	IF NO TRACK HEADER	*/
		IF ALLOCATE.TRK.HEADER(TRACK#)=0		/*	THEN GET ONE			*/
		THEN DO;
			CALL MAXIMIZE.MEMORY.FOR.RECORD;	/*	DO A GOOD JOB IN THE	*/
			IF ALLOCATE.TRK.HEADER(TRACK#)=0	/*	EFFORT DEPT ANYWAY	*/
			THEN RETURN (-1);
		END;
	END;

	I = TRK.HEAD.LOOKUP(TRACK#,THD.CTIMB);	/*	GET CUR TIMB #			*/

	IF I<>0 THEN DO;								/*	IF ONE, CHECK IT		*/
		IF (TIM.HEAD.LOOKUP(I,TIM.SYNTH.TYP+0)<>TIM#CUE)
		THEN DO;										/*	IF NOT A CUE LIST		*/
			CALL TRK.HEAD.LOOKUP(TRACK#,THD.NN.MSB);
			IF  (READ(MDI)\READ(MDI))<>0		/*	ANY NOTES ON TRK?		*/
			THEN RETURN (-2);						/*	NOT A CUE TRACK		*/
			I=0;										/*	FORCE THE CREATION	*/
		END;											/*	OF A CUE LIST TIMBRE	*/
	END;												/*	COULD LEAVE 1 NULL T	*/

	IF I=0 THEN DO;								/*	CREATE A NEW NULL		*/
		IF COPY.TIMBRE(-3,TRACK#)=0			/*	TIMBRE WITH ONLY US	*/
		THEN RETURN (-1);							/*	USING IT.				*/
		I=TRK.HEAD.LOOKUP(TRACK#,THD.CTIMB);	/*	LOOK UP NEW TIMBRE #	*/
	END;

	/*	LOOK THROUGH EXISTING PARTIALS TO FIND MATCH OF CUE NAME (IF	*/
	/*	THIS IS A CUE TRIGGER) OR TO FIND AN EMPTY CUE FRAME (IF			*/
	/*	THIS IS AN EVENT TRIGGER).													*/

	FOUND	  = 0;		/*	INITIALIZE TO PLACE NOT FOUND YET			*/
	PTL	  = 0;		/*	START WITH PARTIAL #0							*/
	MAXKEY# = KEY#;	/*	SAVE MIN KEY# TO USE.							*/
	EMPTYONE= 0;		/*	NO EMPTY SLOT FOUND YET							*/

	DO WHILE	(FOUND = 0				)	/*	DO WHILE NOT FOUND			*/
		AND	(PTL	 < NUM.PARTIALS);	/*	AND MORE PARTIALS TO GO		*/

		J=TIM.HEAD.LOOKUP(I,TIM.PARTIAL.POINTERS+PTL);	/*	GET POINTER TO PARTIAL	*/

		IF P.LOOKUP(J)<>SUP THEN DO;		/*	IF NON EMPTY, SEE IF CUE IS ALREADY IN LIST	*/
			J=J+NUM.PARAMS;					/*	GET POINTER TO POSSIBLE FRAME 1	*/

			DO WHILE (FOUND		 = 0	)	/*	WHILE NOT FOUND				*/
			AND		(P.LOOKUP(J) = MOR);	/*	SEARCH MORE FRAMES			*/

				WRITE("313")=READ(MDI);		/*	SKIP MOR							*/
				Q=READ(MDI);					/*	GET RECORD TYPE				*/
				L=READ(MDI);					/*	GET AND SAVE CLEN				*/
				M=READ(MDI) + SHL(PTL,8);	/*	GET AND SAVE CU.KEY			*/
													/*			  OR	 EV.KEY			*/
													/*	PLUS PARTIAL# * 256			*/
													/*	POINT TO CU.NAME HERE		*/

				/*	SAVE POINTER TO POSSIBLE EMPTY FRAME SO WE CAN			*/
				/*	RE-USE THIS STORAGE ON AN INSERT								*/

				IF  (Q		  = CU.TYPE)	/*	IF THIS IS A CUE NAME		*/
				AND (READ(MD) = 0		)		/*	WITH A NULL STRING NAME		*/
				AND (EMPTYONE = 0		)		/*	AND FIRST SUCH BEAST ...	*/
				THEN DO;
					EMPTYONE   = 1;			/*	INDICATE EMPTY FOUND			*/
					EMPTYKEY   = M;			/*	SAVE PARTIAL, KEY#			*/
					INSERT.PTL = PTL;			/*	WHERE TO INSERT DATA			*/
					INSERT.PTR = J + L;		/*	INSERT WORDS HERE				*/
					IF NEW.FRAME.SIZE > L
					THEN INSERT.LENGTH = NEW.FRAME.SIZE - L;
					ELSE DO;
						INSERT.LENGTH	= 0;	/*	NO WORDS TO INSERT			*/
						NEW.FRAME.SIZE	= L;	/*	MAKE NEW FRAME THIS			*/
					END;							/*	SIZE.								*/
					FILL.IN.PARTIAL	= 0;	/*	NO BASIC PARTIAL TO FILL	*/
					START.FRAME.HERE	= J;	/*	START FRAME HERE				*/
				END;

				/*	IF WE ARE LOOKING TO PLACE A CUE TRIGGER, THEN			*/
				/*	SEE IF CUE NAME MATCHES											*/

				IF  (CODE = CU.TYPE)			/*	IF WE ARE LOOKING FOR A		*/
				AND (Q	 = CU.TYPE)			/*	CUE NAME & THIS IS ONE		*/
				THEN DO;							/*	THEN SEE IF NAME MATCHES	*/
					P=0;							/*	INITIALIZE FOR SCAN			*/
					WRITE("313")=ADDR(CUENAME(0));
					N=SHR(CUENAME(0)+3,1);	/*	LENGTH OF CUE NAME			*/
					DO WHILE	(P<N)				/*	COMPARE NAME (IGNORE CASE)	*/
					AND		((READ("373")\(sp\shl(sp,8)))=(READ(MDI)\(sp\shl(sp,8))));
						P=P+1;
					END;
					IF P=N THEN DO;			/*	IF NAME MATCHES, USE SAME	*/
						FOUND   = 1;			/*	KEY.  SET FOUND = 1, SAVE	*/
						MAXKEY# = M;			/*	KEY # TO USE.					*/
					END;
				END;

				/*	ELSE IF WE ARE LOOKING TO STORE SOME EVENT INFO,		*/
				/*	THEN SEE IF THIS IS A BLANK CUE RECORD THAT WE CAN		*/
				/*	RE-USE.																*/

				ELSE IF (CODE		= EV.TYPE)	/*	IF WE ARE PLACING EVENT	*/
				AND	  (EMPTYONE <> 0		)	/*	AND WE FOUND AN EMPTY	*/
				THEN DO;								/*	SLOT:  USE IT!				*/
					FOUND   = 1;
					MAXKEY# = EMPTYKEY;
				END;

				/*	MOVE ON TO NEXT FRAME IF NOT FOUND YET	*/

				IF FOUND = 0 THEN DO;
					J=J+L;
					IF M IGE MAXKEY# THEN
					MAXKEY# = M+1;
				END;
			END;

			FLENS(PTL) = J;	/*	SAVE TOTAL FRAME LENGTHS FOR INSERT	*/

		END;

		/*	MOVE ON TO NEXT PARTIAL IF NOT FOUND YET	*/

		IF FOUND = 0 THEN DO;
			PTL = PTL + 1;
		END;
	END;

	IF FOUND <> 0 THEN DO;			/*	IF WE FOUND WHAT WE WERE LOOKING FOR.	*/
		IF CODE = CU.TYPE				/*	IF LOOKING FOR CUE NAME						*/
		THEN RETURN MAXKEY#;			/*	THEN USE THIS KEY.							*/

		/*	ELSE REUSE THIS EMPTY CUE NAME TIMBRE FRAME FOR EVENT INFO			*/
		/*	INSERT INFO WAS SET UP ABOVE.													*/
	END;

	ELSE IF EMPTYONE <> 0 THEN DO;	/*	ELSE IF EMPTY BLOCK FOUND THEN			*/
		MAXKEY# = EMPTYKEY;				/*	POINTERS ARE SET UP ABOVE.  SET WHICH	*/
	END;										/*	KEY TO USE.										*/

	ELSE DO;									/*	SET UP PTRS TO END OF LIST				*/

		/*	STORE NEW EVENT INFO OR CUE NAME IN FRAME	*/

		INSERT.PTL = SHR(MAXKEY#,8);		/*	PARTIAL # TO INSERT DATA ON		*/

		J=TIM.HEAD.LOOKUP(I,TIM.PARTIAL.POINTERS+INSERT.PTL);

		IF P.LOOKUP(J) = SUP THEN DO;		/*	EXPAND SUPPRESSED PARTIAL	*/
			INSERT.PTR = J + 1;				/*	INSERT AFTER SUP			*/
			INSERT.LENGTH = NUM.PARAMS - 1 + NEW.FRAME.SIZE;
			FILL.IN.PARTIAL = 1;				/*	DO FILL IN BASIC INFO	*/
			START.FRAME.HERE = J + NUM.PARAMS;	/*	PUT FRAME HERE		*/
		END;

		ELSE DO;
			INSERT.PTR = FLENS(INSERT.PTL);	/*	ADD TO END OF FRAME LIST	*/
			INSERT.LENGTH = NEW.FRAME.SIZE;	/*	ENOUGH FOR WHOLE FRAME	*/
			FILL.IN.PARTIAL = 0;					/*	NO BASIC PARAMS TO FILL	*/
			START.FRAME.HERE = INSERT.PTR;	/*	START FRAME HERE			*/
		END;
	END;

	IF MAXKEY# >= 512								/*	LIMIT TO 512 FOR NOW BECAUSE	*/
	THEN RETURN (-3);								/*	OF 9-BIT FIELD IN NOTE RECRD	*/

	IF EX.ROOMFOR(INSERT.LENGTH) = 0			/*	MAKE SURE ROOM IN MEMORY FOR FRAME	*/
	THEN RETURN (-1);

	CALL COPY.EXT.MEM(PAR.PTR, INSERT.PTR,	/*	COPY EXISTING PARAMS UP	*/
							PAR.PTR, INSERT.PTR+INSERT.LENGTH,
							PAR.TOP - INSERT.PTR);

	/*	FILL IN BASIC PARTIAL IF NEEDED	*/

	IF FILL.IN.PARTIAL THEN DO;			/*	EXPANDING A SUPPRESSED PARTIAL	*/
		CALL P.LOOKUP(INSERT.PTR - 1);	/*	SET UP MAM AND MAL					*/
		DO P=0 TO NUM.PARAMS-1;				/*	ZERO OUT FRAME							*/
			WRITE(MDI)=0;
		END;
		CALL P.STORE(INSERT.PTR+(P.EPEAKL	 -1),1000);
		CALL P.STORE(INSERT.PTR+(P.ESUSTL	 -1),1000);
		CALL P.STORE(INSERT.PTR+(P.NEW.CHORUS-1),1000);
		CALL P.STORE(INSERT.PTR+(P.PTUNING	 -1),4400);
		CALL P.STORE(INSERT.PTR+(P.COEF.LOC	 -1),1000);
		CALL P.STORE(INSERT.PTR+(P.RATIO		 -1),1000);
	END;

	/*	FILL UP FRAME IN QUESTION	*/

	CALL P.STORE(START.FRAME.HERE, MOR);	/*	SET UP POINTERS & STORE FIRST WORD	*/
	WRITE(MDI) = CODE;							/*	CU.TYPE OR EV.TYPE	*/
	WRITE(MDI) = NEW.FRAME.SIZE;				/*	CUE FRAME LENGTH	*/
	WRITE(MDI) = MAXKEY# & 255;				/*	EV.KEY OR CU.KEY	*/

	IF CODE = CU.TYPE THEN DO;					/*	FILL IN CUE NAME ONLY	*/
		CALL COPY.OUT(ADDR(CUENAME(0)), SHR(CUENAME(0)+3,1));
	END;
	ELSE DO;											/*	WRITE OUT EVENT INFO	*/
		WRITE(MDI) = CUEID#;						/*	EV.CUE.ID				*/
		CALL COPY.OUT(ADDR(EVENTINFO(0)), EV.NAME - EV.IN.MSB);
		CALL COPY.OUT(ADDR(CUENAME  (0)), SHR(CUENAME(0)+3,1));
		CALL COPY.OUT(ADDR(CAPTION  (0)), SHR(CAPTION(0)+3,1));
	END;

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS	*/

	NEW.PRM.INFO=NEW.PRM.INFO\1;

	CALL TIM.HEAD.LOOKUP(I,TIM.CSEM);
	INITIALCSEM=INITIALCSEM+1;
	WRITE(MD)=INITIALCSEM;

	/*	WE COULD CALL ALLOCATE.TIMBRE HERE, BUT INSTEAD WE WILL	*/
	/*	DO THE ITEMS OURSELVES TO SAVE TIME								*/

	CALL TIM.HEAD.STORE(I,TIM.SYNTH.TYP+INSERT.PTL,TIM#CUE);	/*	MAKE THIS GUY A CUE PARTIAL	*/
	CALL TRK.HEAD.STORE(TRACK#,THD.CUE.TRACK,1);			/*	INDICATE THIS TRACK IS A CUE TRACK	*/

	IF TIM.HEAD.LOOKUP(I,TIM.KBDTAB.PTR+INSERT.PTL)=0	/*	SEE IF WE HAVE A LOOK UP TABLE	*/
	THEN DO;												/*	IF NOT, THEN GET ONE				*/
		IF TIM.FREE=0 THEN DO;						/*	NO FREE BLOCK - ALLOCATE ONE	*/
			IF GET.TIM.STORAGE(TIM.LEN+1) <> 0 THEN DO;
				CALL TIM.HEAD.STORE(I,TIM.KBDTAB.PTR+INSERT.PTL,TIM.LEN);
				WRITE(MAM)=TIM.PTR+TIM.LEN-1;
				DO P=0 TO 255;					/*	FIRST, ZERO OUT THE KEYBOARD PATCH LIST	*/
					WRITE(MDI)=0;
				END;
			END;
		END;
		ELSE DO;
			CALL TIM.HEAD.STORE(I,TIM.KBDTAB.PTR+INSERT.PTL,TIM.FREE);

			WRITE(MAM)=TIM.PTR+TIM.FREE-1;
			TIM.FREE=READ(MD);				/*	ADVANCE TO NEXT FREE BLK	*/
			TIM.#FREE=TIM.#FREE-1;

			DO P=0 TO 255;
				WRITE(MDI)=0;
			END;
		END;
	END;

	/*	SET UP KBD LOOKUP TABLE TO EITHER HOLD CUE NUMBER (IN CASE OF A	*/
	/*	CUE TRIGGER) OR TO HOLD A POINTER BACK TO THE EVENT FRAME (IN		*/
	/*	THE CASE OF AN EVENT).  ALSO UPDATE ALL EVENT FRAME POINTERS		*/
	/*	FOR THIS PARTIAL SINCE SOME OF THEM MAY HAVE MOVED.					*/

	P = TIM.HEAD.LOOKUP(I, TIM.KBDTAB.PTR + INSERT.PTL);
	IF P<>0 THEN DO;							/*	IF KBDTAB EXISTS, FILL IT			*/

		IF CODE = CU.TYPE						/*	STORE CUE ID IN KBDTAB FOR			*/
		THEN DO;									/*	SIMPLE CUE TRIGGERS					*/
			WRITE(MAM) = TIM.PTR + P - 1;	/*	OR STORE NEGATIVE POINTER TO		*/
			WRITE(MAL) = MAXKEY# & 255;	/*	TIMBRE FRAME FOR EVENT FRAMES		*/
			WRITE(MD ) = CUEID#;
		END;

		/*	NOW LOOP OVER THIS PARTIAL AND MAKE SURE ALL EVENT FRAME				*/
		/*	POINTERS ARE UP TO DATE.														*/

		J = TIM.HEAD.LOOKUP(I, TIM.PARTIAL.POINTERS + INSERT.PTL);
		IF P.LOOKUP(J) <> SUP THEN DO;	/*	HAD BETTER NOT BE SUPPRESSED!		*/
			Q = J;
			J = J + NUM.PARAMS;				/*	SAVE BASE OF PARTIAL					*/
			DO WHILE P.LOOKUP(J) = MOR;
				WRITE("313")=READ(MDI);		/*	SKIP MOR							*/
				K=READ(MDI);					/*	GET RECORD TYPE				*/
				L=READ(MDI);					/*	GET AND SAVE CLEN				*/
				M=READ(MDI);					/*	GET AND SAVE CU.KEY			*/

				IF K = EV.TYPE THEN DO;		/*	IF THIS IS EVENT FRAME		*/
					WRITE(MAM) = TIM.PTR + P - 1;	/*	THEN STORE BACK PTR	*/
					WRITE(MAL) = M;			/*	TO EVENT FRAME					*/
					WRITE(MD ) = -(J - Q);	/*	NEGATIVE RELATIVE POINTER	*/
				END;
				J = J + L;
			END;
		END;
	END;

	IF (LAST.EVENT) THEN DO;
		CALL COMPUTE.USAGE.KEY#(I);	/*	GET NEW USAGE KEY #						*/
		CALL COMPUTE.ENV.PARAMS(I);	/*	COMPUTE ENVELOPE PARAMETERS			*/
		CALL COMPUTE.LOGS		  (I);	/*	COMPUTE LOGS OF RATIO, CHORUS, ETC.	*/
		CALL COMPUTE.RBITS	  (I);	/*	RECOMPUTE REAL TIME EFFECTS BITS - ALWAYS CALL AFTER COMPUTE.ENV.PARAMS SO TOPTIONS IS SET UP	*/
		CALL COMPUTE.MISC.INFO;			/*	COMPUTE RIBBON & PRESSURE FILTERS	*/
		CALL CHECK.MEMORY.FOR.RECORD;	/*	MAKE SURE WE STILL HAVE ENOUGH ROOM	*/
	END;

	LAST.EVENT = TRUE;					/*	CLEAR THIS SO UNKNOWING CALLERS DON'T HAVE TO WORRY	*/

	RETURN MAXKEY#;

END ADD.EVENT.TO.LIST;

/*	ROUTINE TO STORE JUST CUE TRIGGER (FOR COMPATIBILITY WITH	*/
/*	EARLIER SOFTWARE:														*/

ADD.CUE.TO.LIST:PROC(TRACK#,CUENAME,CUEID#,KEY#) PUBLIC SWAPABLE;
	DCL TRACK#	FIXED;
	DCL CUENAME	ARRAY;
	DCL CUEID#	FIXED;
	DCL KEY#		FIXED;
	DCL INFO(1)	FIXED;

	RETURN ADD.EVENT.TO.LIST (TRACK#, CUENAME, CUEID# ,KEY#,
									  INFO, INFO, CU.TYPE);
END ADD.CUE.TO.LIST;

//	SETUP.POLY.INFO

//	SETUP.POLY.INFO is passed in the MISC.BUF array
//	that has been set up with information that has been read in
//	from the sound file header.  Some of that information was
//	stored when the sound file was created (either by SFM
//	or STM), and some of it was pre-computed in PS.SETUP().

//	PS.SETUP computes information that is inherent in the sound file
//	itself:  that is, the basic perceptual pitch of the sound file,
//	any precise looping information in the sound file (total length,
//	loop length), and information about the file-resident mark start/
//	mark end.

//	Additional information has been copied into MISC.BUF from
//	that patch list frame of the partial timbre that uses
//	this sound file.  A partial-specific total length/loop
//	length may be applied, or ram-event in & out times to over-ride
//	the mark start/mark end points.

//	SETUP.POLY.INFO computes some additional information and
//	stores that in MISC.BUF.  It is copied from there back out
//	to the partial timbre area where it is stored until it is needed
//	to actually start a note.

//	NOTE: Most information required to start the note is stored
//	in the patch frame.  Some additional information (like the
//	page and word offset bits) are stored in the keyboard lookup
//	table

SETUP.POLY.INFO:PROC PUBLIC SWAPABLE;						//	SET UP POLY LOOP INFO
	DCL (K,L,M,N,P,Q)	FIXED;									//	PASS INFO IN MISC.BUF
	DCL (SF.INFO)		FIXED;
	DCL (SOFS,WOFS)	FIXED;

	IF (MISC.BUF(PT.EVENT)<>0)									//	DO SOME SPECIAL HANDLING
	{																	//	IF THIS IS A RAM EVENT FRAME
		K=MISC.BUF(PT.INSOFS);									//	LOOKUP NEW EVENT IN TIME
		L=MISC.BUF(PT.INWOFS);
		M=MISC.BUF(PT.SOFS);										//	GET FORMER MARK START
		N=MISC.BUF(PT.WOFS);

		IF (K<>M)\(L<>N)											//	NEW IN TIME OFFSET BEING SET
		{
			IF  (K ILT M)											//	NEW IN TIME BEFORE OLD IN TIME
			OR ((K  =  M)
			AND (L ILT N))
			{
				SOFS=M-K;											//	COMPUTE OFFSET BETWEEN OLD AND NEW
				WOFS=N-L;
				IF WOFS<0											//	CHECK FOR BORROW
				THEN DO;
					SOFS=SOFS-1;
					WOFS=WOFS+256;
				END;
				P=MISC.BUF(PT.MAX  )+SOFS;						//	COMPUTE NEW MAX
				Q=MISC.BUF(PT.MAX+1)+WOFS;
				IF Q>255												//	CHECK FOR CARRY
				THEN DO;
					P=P+1;
					Q=Q&255;
				END;
			}
			ELSE IF (K IGT M)										//	NEW IN TIME IS LATER THAN OLD IN TIME
			OR		 ((K  =  M)
			AND	  (L IGT N))
			{
				SOFS=K-M;											//	COMPUTE OFFSET BETWEEN OLD AND NEW
				WOFS=L-N;
				IF WOFS<0
				THEN DO;
					SOFS=SOFS-1;
					WOFS=WOFS+256;
				END;
				IF  (SOFS IGT MISC.BUF(PT.MAX  ))			//	DO SOME LIMIT CHECKING HERE
				OR ((SOFS  =  MISC.BUF(PT.MAX  ))
				AND (WOFS IGT MISC.BUF(PT.MAX+1)))
				THEN DO;
					SOFS=MISC.BUF(PT.MAX  );					//	LIMIT NEW IN TIME TO MAX
					WOFS=MISC.BUF(PT.MAX+1);
					MISC.BUF(PT.INSOFS)=MISC.BUF(PT.MAX  );
					MISC.BUF(PT.INWOFS)=MISC.BUF(PT.MAX+1);
				END;
				P=MISC.BUF(PT.MAX  )-SOFS;						//	SET NEW MAX
				Q=MISC.BUF(PT.MAX+1)-WOFS;
				IF Q<0
				THEN DO;
					P=P-1;
					Q=Q+256;
				END;
			}

			MISC.BUF(PT.MAX  )=P;								//	NOW ASSIGN NEW MAX BACK INTO MISC BUF
			MISC.BUF(PT.MAX+1)=Q;
			MISC.BUF(PT.SOFS )=MISC.BUF(PT.INSOFS);		//	AND NOW WE'RE FREE TO WRITE
			MISC.BUF(PT.WOFS )=MISC.BUF(PT.INWOFS);		//	THE NEW IN TIME INTO THE MARK START FIELDS
		}
	}

	SF.INFO=0;														//	ASSUME NOT FR SF
	K=MISC.BUF(PT.MAX);											//	16 MSB OF MAX LEN
	L=MISC.BUF(PT.MAX+1);										//	 8 LSB OF MAX LEN
	M=MISC.BUF(PT.TLEN);											//	TOTAL LENGTH 8
	N=MISC.BUF(PT.TLEN+1);										//	16 LSB
	P=MISC.BUF(PT.LLEN);											//	LOOP LENGTH
	Q=MISC.BUF(PT.LLEN+1);

	IF (M\N)=0 THEN DO;											//	IF NO USER LOOP INFO
		M=MISC.BUF(PT.SFTL);										//	THEN LOOK UP LOOP
		N=MISC.BUF(PT.SFTL+1);									//	FROM SOUND FILE
		P=MISC.BUF(PT.SFLL);										//	ITSELF (SFM LOOP)
		Q=MISC.BUF(PT.SFLL+1);
		MISC.BUF(PT.LLEN)=0;										//	CLEAN OUT POSSIBLE
		MISC.BUF(PT.LLEN+1)=0;									//	BAD LOOP LEN INFO	;e.g. enforce user LL == 0 if user TL == 0
		SF.INFO=1;													//	INDICATE INFO IS FR SF
	END;

	IF (M\N)=0 THEN DO;											//	ZERO LENGTH - NO LOOP
		MISC.BUF(PT.ONLOOP)=1;									//	ON, NO LOOP
		IF L=0 THEN K=-K;											//	NEGATE K IF LSB ARE 0
		ELSE DO;
			K=NOT(K);
			L=(-L)&255;
		END;
		IF (K\L) <> 0												//	IF TOTAL LENGTH IS <> 0
		THEN L = L \ "177400";									//	THEN EXTEND SIGN
		MISC.BUF(PT.WTABL)  =K;									//	STORE MINUS WTAB LEN
		MISC.BUF(PT.WTABL+1)=L;
		MISC.BUF(PT.LOOPL)  =0;									//	USE 0 AS LOOP LEN FOR NO CLICKS
		MISC.BUF(PT.LOOPL+1)=0;
	END;
	ELSE DO;															//	LOOP SPECIFIED - EITHER IN PARTIAL OR IN SOUND FILE

		IF (P\Q)=0 THEN MISC.BUF(PT.ONLOOP)=1;				//	TOT LENGTH SPECIFIED BUT NO LOOP - JUST PLAY THAT LENGTH
		ELSE				 MISC.BUF(PT.ONLOOP)=3;				//	TOT LENGTH SPECIFIED WITH  LOOP - PERFORM IT

		//	GET MAX IN 32 BIT FORMAT

		L=L\SHL(K,8);
		K=SHR(K,8);

		//	SEE IF TOTAL LENGTH
		//	GRTR THAN SOUND FIL

		IF ((M IGT K))												//	LIMIT LENGTH
		OR ((M  =  K)												//	TO THAT AVAIL
		AND (N IGT L))
		THEN DO;
			M=K; N=L;
		END;

		//	SEE IF LOOP  LENGTH
		//	GRTR THAN TOTAL LEN

		IF ((P IGT M))												//	LIMIT LOOP
		OR ((P  =  M)												//	TO TOT LEN
		AND (Q IGT N))
		THEN DO;
			P=M; Q=N;
		END;

		//	STORE INFO BACK IN MISC.BUF
		//	IN CASE KNOB UPDATE HERE

		IF SF.INFO=0 THEN DO;									//	IF NOT FROM S.F
			MISC.BUF(PT.TLEN)  =M;								//	RE-STORE TOTAL LEN, LOOP LEN
			MISC.BUF(PT.TLEN+1)=N;								//	AFTER LIMITING SAME TO FILE
			MISC.BUF(PT.LLEN)  =P;								//	LENGTH.  ALSO LOOP LEN IS
			MISC.BUF(PT.LLEN+1)=Q;								//	<=TOTAL LENGTH
		END;

		//	COMPUTE 24 BIT FORMAT

		IF MISC.BUF(PT.STEREO)<>0 THEN DO;
			N = N & "177776";										//	MAKE EVEN FOR STEREOS
			Q = Q & "177776";										//	MAKE EVEN FOR STEREOS
		END;

		M=SHL(M,8)\SHR(N,8);
		N=N&255;														//	GET 16-8 FORMAT
		P=SHL(P,8)\SHR(Q,8);
		Q=Q&255;

		//	NEGATE INFO FOR SYNTH HARDWARE

		IF N=0 THEN M=-M;											//	NEGATE M IF LSB ARE 0
		ELSE DO;
			M=NOT(M);
			N=(-N)&255;
		END;
		IF Q=0 THEN P=-P;											//	NEGATE P IF LSB ARE 0
		ELSE DO;
			P=NOT(P);
			Q=(-Q)&255;
		END;

		IF (M\N) <> 0												//	IF TOTAL LENGTH IS <>
		THEN N = N \ "177400";									//	0 THEN EXTEND SIGN

		IF (P\Q) <> 0												//	IF LOOP LENGTH IS <>
		THEN Q = Q \ "177400";									//	0 THEN EXTEND SIGN

		MISC.BUF(PT.WTABL)  =M;									//	STORE INFO FOR SYNTH DATA WRITES
		MISC.BUF(PT.WTABL+1)=N;
		MISC.BUF(PT.LOOPL)  =P;
		MISC.BUF(PT.LOOPL+1)=Q;

	END;

	NEW.KBD.PRE = 1;												//	RECOMPUTE KEYBOARD LOOK UP TABLES SINCE THIS
																		//	IS POSSIBLY A KEYBOARD NOTE
END SETUP.POLY.INFO;
