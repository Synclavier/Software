/*	:SYNRSOU:11-TIMB:160-TMB0  $TITLE  ROUTINES FOR MANIPULATING TIMBRES	*/

/*
1999/01/20 - TY  - CREATE.PATCH.PARTIAL now sets final decay to user default
1998/06/27 - TY  - CREATE.PATCH.PARTIAL now sets final decay to 100 msec!
1986/08/24 - TS  - INIT THD.ACTIVE.MIDI.RTES IN MOVE.TIMBRE.TO
1986/08/15 - CJ  - FIXED CSEM/FDECAY BUF
1986/08/05 - TS  - GOT BOUNCE.PARTIAL UP AND RUNNING
1986/07/31 - CJ  - CHECK FOR LOD RECORDING
1986/07/13 - CJ  - USED NEW.SEQ=2 FOR NEW TIMBRE NAMES
1986/06/10 - TSS - Rewrote COMPUTE.USAGE.KEY# to fix bug
1986/06/09 - TSS - Moved CHECK.TIMBRE routine inside START.RECORD (162-SEQ2)
1986/05/15 - "official" creation of release-M modules
*/

insert ':synmods:giddcl';

COMPUTE.USAGE.KEY#: PROC (T#) PUBLIC SWAPABLE;	/*	COMPUTES USAGE KEY # FOR TIMBRE	*/
	DCL T#							FIXED;	/*	TIMBRE NUMBER	*/
	DCL (PTR)						FIXED;
	DCL (BASE)						FIXED STATIC;
	DCL (STATE,PAR#)				FIXED;
	DCL (CNT,LIM,WORD)			FIXED;
	DCL (K1,K2,K3,K4)				FIXED;	/*	WILL HOLD 64-BIT USAGE KEY			*/
	DCL (RANDOMLSB,RANDOMMSB)	FIXED;	/*	SEED FOR RANDOM NUMBER GENERATOR	*/

	W.LOOKUP:  PROC (PTR)	FIXED;
		DCL PTR	FIXED;
		WRITE(MAM)=PAR.PTR+SHR(BASE+PTR,8);
		WRITE(MAL)=BASE+PTR;
		RETURN READ(MD);
	END W.LOOKUP;

	DCL S.PARTIAL	LIT '0';	DCL S.FRAME	LIT '1';	/*	LITERALS FOR THE DIFFERENT STATES	*/
	DCL S.PINFO		LIT '2';	DCL S.TINFO	LIT '3';
	DCL S.MISC		LIT '4';


	WRITE(MAM)=TIM.HEAD;				/*	LOOK UP PTR TO THIS TIMBRE	*/
	WRITE(MAL)=T#;
	IF READ(MD)=0 THEN RETURN;		/*	NO TIMBRE HEAD - BOMB OUT	*/

	RANDOMMSB=1; RANDOMLSB=57921;	/*	INIT SEED TO 1234567		*/
	K1=0; K2=0; K3=0; K4=0;			/*	INIT KEY TO ZERO			*/

	BASE=FIND.TIMBRE(PAR.PTR,T#);	/*	GET REL PTR TO OUR TIMBRE			*/
	PTR=0;								/*	INIT OUR PTR							*/
	STATE=S.PARTIAL;					/*	START OUT IN THE PARTIAL STATE	*/
	PAR#=0;								/*	START WITH FIRST PARTIAL			*/


	/*	$PAGE	*/


	TOP.OF.LOOP:

		CNT=0;										/*	RESET COUNT	*/

		DO CASE STATE;
			DO;										/*	PARTIAL		*/
				IF W.LOOKUP(PTR)=SUP THEN DO;	/*	THIS IS A SUPPRESSED PARTIAL	*/
					WORD=SUP;
					LIM=1;
					PTR=PTR+LIM;
				END;
				ELSE IF ((W.LOOKUP(PTR+P.EPEAKL)\W.LOOKUP(PTR+P.ESUSTL))&"1777")=0
				THEN DO;								/*	ZERO VOLUME ON THIS PARTIAL	*/
					WORD=SUP;
					LIM=1;
					PTR=PTR+NUM.PARAMS;
				END;
				ELSE DO;								/*	NORMAL PARTIAL	*/
					CALL W.LOOKUP(PTR);			/*	RESTORE PTR		*/
					WORD=READ(MDI);
					LIM=NUM.PARAMS;
					PTR=PTR+LIM;
				END;
			END;

			DO;										/*	FRAME	*/
				LIM=W.LOOKUP(PTR+CLEN);
				CALL W.LOOKUP(PTR);				/*	RESTORE PTR	*/
				WORD=READ(MDI);
				PTR=PTR+LIM;
			END;

			DO;										/*	PINFO	*/
				WORD=READ(MDI);
				LIM=PINFO.LEN;
				PTR=PTR+LIM;
			END;

			DO;										/*	TINFO	*/
				WORD=READ(MDI);
				LIM=TINFO.LEN;
				PTR=PTR+LIM;
			END;

			DO;										/*	MISC	*/
				WORD=READ(MDI);
				LIM=NUM.MISC.PARAMS;
				PTR=PTR+LIM;
			END;
		END;											/*	OF DO CASE		*/


		/*	$PAGE	*/


	LOOP:

		/*	THIS LOOP DOES THREE THINGS:					*/
		/*		1. GENERATE A RANDOM NUMBER				*/
		/*		2. MULTIPLY RND # BY TIBMRE WORD			*/
		/*		3. ACCUMULATE PRODUCT INTO 64-BIT SUM	*/


		/*	1. A linear congruential generator with multiplier			*/
		/*		16807 and modulus 2**31-1.  These are the same values	*/
		/*		as the IMSL routine GGUBS, and the same logic is		*/
		/*		used, but this routine is implemented in fixed point.	*/
		/*		RANDOMMSB and RANDOMLSB are the most and least			*/
		/*		significant bits of the seed.									*/

		DCL ROOT	LIT '16807';

		WRITE("300")=RANDOMMSB;	/*	RANDOMMSB --> R0	*/
		WRITE("301")=RANDOMLSB;	/*	RANDOMLSB --> R1	*/
		WRITE("302")=ROOT;		/*	LONG IMMED (ROOT) TO R2	*/

		WRITE(5)=READ("302");		/*		 R2 --> DEV(5)	*/
		WRITE(6)=READ("301");		/*		 R1 --> DEV(6)	*/
		WRITE("303")=READ(4);		/*	DEV(4) --> R3		*/
		WRITE("301")=READ(5);		/*	DEV(5) --> R1		*/

		WRITE(5)=READ("302");		/*		 R2 --> DEV(5)	*/
		WRITE(6)=READ("300");		/*		 R0 --> DEV(6)	*/
		WRITE("213")=READ(5);		/*	DEV(5) --> ADD3	*/

		WRITE("300")=READ(4);		/*	DEV(4) --> R0		*/
		WRITE("210")=READ("300");	/*		 R0 --> ADD0	*/
		WRITE("257")=READ(5);		/*	DEV(5) --> TSUB3	*/
		WRITE("332")=1;				/*	 IM(1) --> RTRC	*/
		WRITE("210")=2;				/*	 IM(2) --> ADD0	*/

		WRITE("243")=READ("303");	/*		 R3 --> TLOA3	*/
		WRITE("337")=1;				/*	 IM(1) --> RTPL	*/
		WRITE("210")=1;				/*	 IM(1) --> ADD0	*/

		WRITE("211")=READ("300");	/*		 R0 --> ADD1	*/
		WRITE("336")=1;				/*	 IM(1) --> RTNC	*/
		WRITE("213")=1;				/*	 IM(1) --> ADD3	*/

		WRITE("207")="077777";		/*	LONG IMMED("077777") --> AND3	*/

		RANDOMLSB=READ("301");		/*		 R1 --> RANDOMLSB (RESTORE TO MEMORY)	*/
		RANDOMMSB=READ("303");		/*		 R3 --> RANDOMMSB (RESTORE TO MEMORY)	*/

		WRITE("213")=READ("303");	/*		 R3 --> ADD3	*/
		WRITE("241")=READ("301");	/*		 R1 --> TLOA1	*/
		WRITE("337")=1;				/*	 IM(1) --> RTPL	*/
		WRITE("213")=1;				/*	 IM(1) --> ADD3	*/


		/*	2. MULTIPLY RANDOM NUMBER BY NEXT WORD FROM TIMBRE	*/

		LOAD READ("303");			/*	PUT INTO D4567 FOR MULTIPLY		*/
		MUL  WORD;					/*	MULTIPLY BY NEXT WORD OF TIMBRE	*/


		/*	$PAGE	*/


		/*	3. ACCUMULATE PRODUCT INTO OUR 64-BIT KEY NUMBER	*/

		K1=K1+RES;						/*	ACCUMULATE LSB OF PRODUCT	*/
		IF K1 ILT RES THEN DO;		/*	HAD A CARRY						*/
			K2=K2+1;
			IF K2=0 THEN DO;			/*	ANOTHER CARRY					*/
				K3=K3+1;
				IF K3=0 THEN K4=K4+1;
			END;
		END;

		K2=K2+URES;						/*	ACCUMULATE MSB OF PRODUCT	*/
		IF K2 ILT URES THEN DO;		/*	HAD A CARRY						*/
			K3=K3+1;
			IF K3=0 THEN K4=K4+1;
		END;

		CNT=CNT+1;
		IF CNT<LIM THEN DO;			/*	MORE WORDS TO ENCODE			*/
			WORD=READ(MDI);			/*	GET NEXT WORD					*/
			GOTO LOOP;					/*	JUMP BACK TO TOP OF LOOP	*/
		END;


	END.OF.LOOP:

		DO CASE STATE;
			DO;										/*	PARTIAL	*/
				CALL W.LOOKUP(PTR);				/*	RESTORE MAM & MAL PTRS	*/
				STATE=S.FRAME;
				GOTO END.OF.LOOP;
			END;

			DO;										/*	FRAME	*/
				IF READ(MD)=MOR THEN DO;		/*	HAVE A FRAME OF SOME SORT	*/
					GOTO TOP.OF.LOOP;				/*	ENCODE THE FRAME	*/
				END;
				ELSE DO;
					STATE=S.PINFO;
					GOTO END.OF.LOOP;
				END;
			END;

			DO;										/*	PINFO	*/
				IF READ(MD)=PINFO THEN DO;		/*	HAVE A PINFO BLOCK	*/
					GOTO TOP.OF.LOOP;
				END;
				ELSE DO;
					PAR#=PAR#+1;
					IF PAR#=NUM.PARTIALS THEN DO;	/*	ALL DONE WITH PARTIALS	*/
						STATE=S.TINFO;
						GOTO END.OF.LOOP;
					END;
					ELSE DO;
						STATE=S.PARTIAL;
						GOTO TOP.OF.LOOP;
					END;
				END;
			END;

			DO;										/*	TINFO	*/
				IF READ(MD)=TINFO THEN DO;		/*	HAVE A TINFO BLOCK	*/
					GOTO TOP.OF.LOOP;
				END;
				ELSE DO;
					STATE=S.MISC;
					GOTO TOP.OF.LOOP;
				END;
			END;

			;	/*	MISC:  ALL DONE -- DO NOTHING	*/
		END;											/*	OF DO CASE			*/


	/*	$PAGE	*/


	/*	NOW WRITE OUT THE KEY NUMBER TO THE TIMBRE HEAD	*/

	WRITE(MAM)=TIM.HEAD;				/*	LOOK UP PTR TO THIS TIMBRE	*/
	WRITE(MAL)=T#;
	WRITE(MAM)=READ(MD);				/*	POINT TO TIMBRE HEAD			*/
	WRITE(MAL)=TIM.RANDOM.KEY#;
	WRITE(MDI)=K4;
	WRITE(MDI)=K3;
	WRITE(MDI)=K2;
	WRITE(MD )=K1;

END COMPUTE.USAGE.KEY#;


MATCHING.TIMBRE:  PROC (TB)	FIXED PUBLIC SWAPABLE;	/*	RETURNS TIMBRE # OF DUPLICATE TIMBRE OR PAR.NUMT IF NO DUPLICATE EXISTS IN PAR.AREA	*/
	DCL (TB,I)			FIXED;
	DCL (W1,W2,W3,W4)	FIXED;

	IF TB<NUM.KBD.TRACKS					/*	KEYBOARD TIMBRE USAGE KEY # NOT KEPT UP TO DATE	*/
	THEN CALL COMPUTE.USAGE.KEY#(TB);	/*	SO RECOMPUTE IT	*/

	CALL TIM.HEAD.LOOKUP(TB,TIM.RANDOM.KEY#);	/*	GET USAGE RANDOM KEY # FROM NEW TIMBRE	*/
	W1=READ(MDI); W2=READ(MDI);	/*	SAVE OUR KEY# IN TEMPS	*/
	W3=READ(MDI); W4=READ(MD );

	DO I=NUM.KBD.TRACKS TO (PAR.NUMT-1);	/*	LOOP THROUGH NON-KBD TIMBRES	*/

		IF I<>TB THEN DO;			/*	DON'T COMPARE TIMBRE TO ITSELF	*/
			CALL TIM.HEAD.LOOKUP(I,TIM.RANDOM.KEY#);	/*	GET USAGE RANDOM KEY #	*/

			IF  (READ(MDI)=W1)	/*	COMPARE USAGE KEY # FROM THIS TIMBRE	*/
			AND (READ(MDI)=W2)	/*	TO THE KEY FROM OUR TEST TIMBRE		*/
			AND (READ(MDI)=W3)
			AND (READ(MD )=W4)
			THEN RETURN I;			/*	USAGE KEYS ARE THE SAME	*/
		END;

	END;

	RETURN PAR.NUMT;				/*	PRESUMABLY MEANS NO MATCH???	*/
	/*	SUBSEQUENT CALL TO MOVE.TIMBRE.TO WILL APPEND TIMBRE TO	*/
	/*	PARAMETER AREA															*/
END MATCHING.TIMBRE;


/*	$SUBTITLE	*/


DCL (BOUNCE.PTR)		FIXED PUBLIC;	/*	IN CASE BOUNCING FRAMES	*/
DCL (SPECIAL.BOUNCE)	FIXED PUBLIC;

EX.ROOMFOR:PROC(WORDS) PUBLIC SWAPABLE;	/*	EXTERNAL MEMORY - CHECK FOR SPACE IN TIMBRE AREA	*/
	DCL (WORDS)	FIXED;							/*	BANK & SEQUENCE MOVED IF NEEDED	*/

	WORDS=PAR.TOP+WORDS;
	IF WORDS ILT PAR.TOP THEN RETURN 0;	/*	OVERFLOW	*/
	WORDS=WORDS+255;							/*	ROUND		*/
	IF WORDS ILT ( 255) THEN RETURN 0;	/*	OVERFLOW	*/
	IF WORDS IGE (-512) THEN RETURN 0;	/*	TOO BIG	*/

	IF GET.PAR.STORAGE(SHR(WORDS,8))=0
	THEN RETURN 0;								/*	NO ROOM	*/

	ELSE RETURN 1;

END EX.ROOMFOR;


CREATE.TIMBRE.FRAME:PROC PUBLIC SWAPABLE;	/*	PROCEDURE TO CREATE TIMBRE FRAME	*/
	DCL (I,K,L,M,N)	FIXED;

	I=0;

	DO WHILE I<NUM.PARTIALS;			/*	PROCESS EACH PARTIAL BUTTON	*/

		IF (HELD.PSEL.BUTTONS&BITS(I))<>0 THEN DO;	/*	CREATE RECORD FOR THIS PARTIAL	*/

			IF TIM.HEAD.LOOKUP(0,TIM.SYNTH.TYP+I)<>0 THEN DO;		/*	TRYING TO CREATE TIMBRE FRAME ON TOP OF PATCH PARTAL ?	*/
				CALL DISPLAY.ERR(19);
				RETURN;
			END;

			K=0;		/*	ASSUME OK	*/

			IF EX.ROOMFOR(LEN.TIMB.FRAME)=0
			THEN CALL DISPLAY.ERR(11);				/*	DISPLAY ERROR IF NO ROOM	*/

			ELSE DO;	/*	CREATE TIMBRE FRAME	*/

				K=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+I)+NUM.PARAMS;	/*	GET POINTER TO POSSIBLE FRAME 1	*/

				IF P.LOOKUP(K)=MOR THEN DO;		/*	EXTRACT PITCH RANDOMNESS & VOLUME	*/
					M=P.LOOKUP(K+P.E.SEG.RND);		/*	FROM FRAME 1					*/
					N=P.LOOKUP(K+P.E.SEG.VOL);
				END;
				ELSE DO; M=0; N=1000; END;			/*	ELSE USE NEW VALUES	*/

				C.FRAME(I)=C.FRAME(I)+1;			/*	COMPUTE NEXT FRAME # FOR THIS PARTIAL	*/
				K=FIND.FRAME(I,C.FRAME(I));		/*	GET POINTER TO WHERE NEXT FRAME WILL GO	*/
				FR.PTRS(I)=K;							/*	STORE THE POINTER	*/

				CALL COPY.EXT.MEM(PAR.PTR,K,PAR.PTR,K+LEN.TIMB.FRAME,PAR.TOP-K);	/*	COPY OTHER PARAMETERS UP	*/

				IF  (BOUNCE.PTR<>0)					/*	IF BOUNCE OF TIMBRE FRAME	*/
				AND (BOUNCE.PTR IGE K)				/*	CHECK FOR SOURCE MOVEMENT	*/
				THEN BOUNCE.PTR=BOUNCE.PTR+LEN.TIMB.FRAME;	/*	SOURCE OF INFO IS BEING MOVED	*/

				/*	FILL IN TIMBRE FRAME	*/

				CALL P.STORE(K,MOR);								/*	SET UP POINTERS & STORE FIRST WORD	*/
				WRITE(MDI)=0; WRITE(MDI)=LEN.TIMB.FRAME;	/*	STORE TYPE,LEN	*/
				IF SPECIAL.BOUNCE<>0								/*	BOUNCE FROM FRAME 0	*/
				THEN BOUNCE.PTR=BOUNCE.PTR-S.ENV.P;			/*	FUDGE POINTER FOR 24 COEFFS BELOW	*/

				/*	$PAGE - COPY INFO IF BOUNCE IF TIMBRE FRAME	*/

				DO L=CLEN+1 TO LEN.TIMB.FRAME-1;
					IF (BOUNCE.PTR=0)					/*	IF NEW T.F	*/
					OR ((SPECIAL.BOUNCE<>0)&((L<S.ENV.H)\(L>=S.ENV.T)))
					THEN CALL P.STORE(K+L,0);		/*	INITIALIZE TO ZEROES IF NON-BOUNCE, OR SPECIAL FRAME 0 BOUNCE	*/
					ELSE CALL P.STORE(K+L,P.LOOKUP(BOUNCE.PTR+L));	/*	COPY DATA (OR JUST COEFFS IF FROM FRAME 0) FROM SOURCE FRAME	*/
				END;										/*	INITALIZE TO ZEROES	*/

				IF (BOUNCE.PTR=0)\(SPECIAL.BOUNCE<>0) THEN DO;	/*	INITIALIZE NEW PARAMETERS	*/
					IF SPECIAL.BOUNCE<>0 THEN DO;	/*	TAKE DELAY, ATTACK, PEAK FROM FRAME 0	*/
						CALL P.STORE(K+P.E.SEG.DEL,P.LOOKUP(BOUNCE.PTR+P.E.SEG.DEL));	/*	DELAY	*/
						LOAD P.LOOKUP(BOUNCE.PTR+P.E.SEG.ATK); MUL 36864;	/*	CONVERT ATTACK TIME TO ACTUAL MILLISECONDS	*/
						CALL P.STORE(K+P.E.SEG.ATK,READ(4));	/*	GET ATTACK TIME IN MS.	*/
						CALL P.STORE(K+P.E.SEG.PK ,P.LOOKUP(BOUNCE.PTR+P.E.SEG.PK));	/*	PEAK	*/
					END;
					ELSE DO;								/*	INITIALIZE SPLICE TIME & PEAK	*/
						CALL P.STORE(K+P.E.SEG.ATK,1000);	/*	INITIALIZE SPLICE TIME TO ONE SECOND	*/
						CALL P.STORE(K+P.E.SEG.PK ,1000);	/*	PEAK LEVEL OF 100.0	*/
						CALL P.STORE(K+S.ENV.H	  ,1000);	/*	SET FIRST HARMONIC TO 100.0	*/
					END;
					CALL P.STORE(K+P.E.SEG.EXP,500);	/*	EXPONENTIAL SHAPE TO .500 IN ANY CASE	*/
					CALL COMPUTE.TIMBRE.FRAME(I);		/*	COMPUTE WAVE TABLE ACCORDING TO PARAMETERS	*/
				END;

				CALL P.STORE(K+P.E.SEG.RND,M);
				CALL P.STORE(K+P.E.SEG.VOL,N);	/*	SAVE INFO IN T.F.	*/
				CALL P.STORE(K+P.E.SEG.LOOP,0);	/*	DISALLOW ANY LOOP INFO ON BOUNCE OF TIMBRE FRAME	*/

				K=K+P.LOOKUP(K+CLEN);				/*	SKIP TO NEXT FRAME	*/
				DO WHILE P.LOOKUP(K)=MOR;			/*	UPDATE LOOP POINTERS	*/
					L=P.LOOKUP(K+P.E.SEG.LOOP);	/*	LOOK UP LOOP VALUE	*/
					IF (L>=C.FRAME(I))				/*	IF LOOP IS TO POINT AFTER CURRENT FRAME	*/
					THEN WRITE(MD)=L+1;
					K=K+P.LOOKUP(K+CLEN);
				END;

				IF C.FRAME(I)=1 THEN CALL CLEAR.PARAMETERS;	/*	CLEAR PARAMETER BUTTONS WHEN CHANGING STATES IF SWITCHING TO FRAME 1 FROM FRAME 0	*/

				CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS	*/
				CALL DISPLAY.FRAME.NUMBER(C.FRAME(I));	/*	PRESENT THAT NUMBER IN DISPLAY	*/

				CALL ABORT.BOUNCE.SMT.SKT;	/*	IN CASE BOUNCING	*/


				NEW.PRM.INFO=NEW.PRM.INFO\BITS(I);

				CALL TIM.HEAD.LOOKUP(0,TIM.CSEM);
				INITIALCSEM=INITIALCSEM+1;
				WRITE(MD)=INITIALCSEM;

			END;
		END;

		I=I+1;

	END;

	CALL COMPUTE.ENV.PARAMS(0);	/*	PRECOMPUTE ENVELOPE PARAMETERS	*/

END CREATE.TIMBRE.FRAME;


DELETE.TIMBRE.FRAME:PROC PUBLIC SWAPABLE;	/*	PROCEDURE TO DELETE TIMBRE FRAME	*/
	DCL (I,K,L,M,N)	FIXED;

	I=0;
	DO WHILE I<NUM.PARTIALS;	/*	PROCESS EACH PARTIAL BUTTON	*/

		IF (HELD.PSEL.BUTTONS&BITS(I))<>0 THEN DO;	/*	DELETE RECORD FOR THIS PARTIAL	*/

			IF TIM.HEAD.LOOKUP(0,TIM.SYNTH.TYP+I)<>0 THEN DO;		/*	TRYING TO DELETE TIMBRE FRAME ON TOP OF PATCH PARTAL	*/
				CALL DISPLAY.ERR(19);
				RETURN;
			END;

			IF C.FRAME(I)<>0 THEN DO;	/*	DELETE THIS FRAME IF NOT ZERO	*/
				K=FR.PTRS(I);				/*	GET POINTER TO THIS FRAME		*/
				L=P.LOOKUP(K+CLEN);		/*	GET LENGTH OF THIS FRAME		*/
				M=P.LOOKUP(K+P.E.SEG.VOL); N=P.LOOKUP(K+P.E.SEG.RND);	/*	SAVE VOLUME FROM DELETED FRAME	*/

				CALL COPY.EXT.MEM(PAR.PTR,K+L,PAR.PTR,K,PAR.TOP-(K+L));	/*	COPY DOWN REST OF PARAMETERS	*/

				IF P.LOOKUP(K)<>MOR THEN DO;	/*	MUST BACK UP ONE FRAME IF DELETING LAST FRAME	*/
					C.FRAME(I)=C.FRAME(I)-1;
					FR.PTRS(I)=FIND.FRAME(I,C.FRAME(I));	/*	GET POINTER TO IT	*/
					IF C.FRAME(I)=0 THEN CALL CLEAR.PARAMETERS;	/*	CLEAR PARAMETER BUTTONS WHEN CHANGING STATES IF SWITCHING TO FRAME 1 FROM FRAME 0	*/
				END;

				ELSE DO;
					CALL P.STORE(K+P.E.SEG.VOL,M);
					CALL P.STORE(K+P.E.SEG.RND,N);
				END;	/*	STORE VOLUME IN LATER FRAME TO SAVE IT	*/

				DO WHILE P.LOOKUP(K)=MOR;			/*	CHECK FOR LOOP IN FOLLOWING FRAME	*/
					L=P.LOOKUP(K+P.E.SEG.LOOP);	/*	LOOK UP LOOP VALUE	*/
					IF (L>C.FRAME(I))					/*	IF LOOP IS TO POINT AFTER CURRENT FRAME	*/
					THEN WRITE(MD)=L-1;
					K=K+P.LOOKUP(K+CLEN);
				END;

				CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS	*/

				NEW.PRM.INFO=NEW.PRM.INFO\BITS(I);

				CALL TIM.HEAD.LOOKUP(0,TIM.CSEM);
				WRITE(MD)=READ(MD)+1;

			END;

			CALL DISPLAY.FRAME.NUMBER(C.FRAME(I));	/*	PRESENT THAT NUMBER IN DISPLAY	*/

		END;

		I=I+1;

	END;

	CALL COMPUTE.ENV.PARAMS(0);	/*	PRECOMPUTE ENVELOPE PARAMETERS	*/

END DELETE.TIMBRE.FRAME;

// CREATE.PATCH.FRAME is used to add a patch frame to the current keyboard timbre.
// Pass in - partial #, 0 - 3
//           frame #, 1 -, which frame we are creating (0 WOULD REFER TO THE BASE PARTIAL AREA; 1 WOULD REFER TO THE FIRST PATCH FRAME)
//           extra - number of extra words to reserve for a long file name
CREATE.PATCH.FRAME:PROC(WHICH.PAR,WHICH.FRAME,EXTRA) PUBLIC SWAPABLE;      /*	PROCEDURE TO CREATE PATCH LIST FRAME	*/
	DCL (WHICH.PAR,WHICH.FRAME,EXTRA,J,K,L,M)	FIXED;                        /*	PASS PARTIAL #, PARTIAL AREA POINTER, extra words for long file name	*/
   DCL FRAME.LENGTH                          FIXED;

   FRAME.LENGTH = PT.LEN + EXTRA;

	IF EX.ROOMFOR(FRAME.LENGTH)=0 THEN DO;
		CALL DISPLAY.ERR(11);							/*	DISPLAY ERROR IF NO ROOM	*/
		RETURN 0;											/*	NONE ALLOCATED	*/
	END;

   J=find.frame(WHICH.PAR,WHICH.FRAME);         /*	get pointer to where to create	*/

	CALL COPY.EXT.MEM(PAR.PTR,J,PAR.PTR,J+FRAME.LENGTH,PAR.TOP-J);	/*	COPY OTHER PARAMETERS UP	*/

	CALL P.STORE(J,MOR);                         /*	STORE FIRST WORD, TYPE, LENGTH	*/

	WRITE(MDI)=PT.TYPE; WRITE(MDI)=FRAME.LENGTH; /*	STORE TYPE,LEN	*/
	DO K=CLEN+1 TO FRAME.LENGTH-1;
		WRITE(MDI)=0;									/*	ZERO OUT BLOCK	*/
	END;													/*	INITALIZE TO ZEROES	*/
	CALL P.STORE(J+PT.VOL,1000);					/*	INIT VOL TO 1000	*/

	L=0; M=NUM.KEYS-1;								/*	ASSUME MIN AND MAX START AND END KEYS	*/

   // If their is a patch frame before this new one, start the key assignment
   // for this new frame at 1 after the key of the prior frame
   if (which.frame > 1) {
      k = find.frame(WHICH.PAR,WHICH.FRAME-1);
      
      IF  (P.LOOKUP(k  )=MOR)                /*	AND A FRAME IS THERE	*/
      AND (P.LOOKUP(k+1)=PT.TYPE)            /*	OF THIS TYPE	*/
      THEN L=P.LOOKUP(k+PT.EKEY)+1;          /*	GET ENDING KEY OF PRIOR FRAME	*/
   }

	IF  (P.LOOKUP(J+FRAME.LENGTH)=MOR)        /*	IF FRAME IS AFTER US	*/
	AND (P.LOOKUP(J+FRAME.LENGTH+1)=PT.TYPE)  /*	OF THIS TYPE	*/
	THEN M=P.LOOKUP(J+FRAME.LENGTH+PT.SKEY)-1;/*	GET STARTING KEY OF NEXT FRAME	*/

	IF L<0 THEN L=0;									/*	MAKE SURE START KEY IS IN LEGIT RANGE	*/
	IF L>NUM.KEYS-1 THEN L=NUM.KEYS-1;

	IF M<L THEN M=L;									/*	MAKE SURE END	 KEY IS IN LEGIT RANGE	*/
	IF M>NUM.KEYS-1 THEN M=NUM.KEYS-1;

	CALL P.STORE(J+PT.SKEY,L);						/*	STARTING KEY	*/
	CALL P.STORE(J+PT.EKEY,M);						/*	ENDING KEY	*/

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS FOR ALL TIMBRES	*/

	RETURN 1;											/*	OK ALLOCATE	*/
END CREATE.PATCH.FRAME;

create.patch.partial:proc(par#,fname) public swapable;	/*	create a new patch list partial on keyboard timbre	*/
	dcl (par#)			fixed;
	dcl (fname)			array;
	dcl (j,k,l,m)		fixed;
	dcl (tname) (4)	fixed;

	call dealloc(0);				/*	free up wave memories, buffers, etc. for keyboard timbre	*/
	call TIM.HEAD.LOOKUP(0,tim.csem);	/*	treat as timbre recall if notes are now playing	*/
	initialcsem=initialcsem+1;
	write(md)=initialcsem;

	j=TIM.HEAD.LOOKUP(0,tim.partial.pointers+par#);				/*	get pointer to partial info		*/
	k=j+num.params;														/*	pointer to where frame will go	*/

	if p.lookup(k)=mor then do;										/*	first, erase earlier frames		*/
		l=k;
		do while p.lookup(l)=mor; l=l+p.lookup(l+clen); end;	/*	find end of frames	*/
		if p.lookup(l)=pinfo then l=l+pinfo.len;					/*	trash pinfo block as well	*/
		CALL COPY.EXT.MEM(PAR.PTR,L,PAR.PTR,K,PAR.TOP-L);		/*	COPY DOWN REST OF PARAMETERS	*/
		CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);					/*	SET UP NEW POINTERS FOR NUMBER OF TIMBRES IN PAR.PTR. MOVE DOWN NOTES & BANK IF EXT MEM	*/
	end;

	IF CREATE.PATCH.FRAME(par#,1,0)=0   /*	NOT ENOUGH MEMORY	*/
	then call nomem.error;              /*	WOULD NOT HAPPEN IF WE HAD DELETED A FRAME ABOVE	*/
	ELSE DO;                            /*	SUCCESSFUL	*/
		j=TIM.HEAD.LOOKUP(0,tim.partial.pointers+par#);	/*	get pointer to partial info	*/
		k=j+num.params;                  /*	pointer to where frame is	*/
		DO L=0 TO NUM.PARAMS-1;          /*	INITIALIZE TO STANDARD PARTIAL	*/
			CALL P.STORE(J+L,0);
		END;
		CALL P.STORE(J+3 ,GID(Default.FDecay));
		CALL P.STORE(J+4 ,1000);		/*	PK, SUSTAIN VOL ENV	*/
		CALL P.STORE(J+5 ,1000);
		CALL P.STORE(J+36,4400);		/*	P TUNING	*/
		CALL P.STORE(J+45,1000);		/*	NEW CHORUS FUNCTION	*/
		CALL TIM.HEAD.STORE(0,TIM.ANY.DPAN+J,0);	/*	ASSUME NO DYNAMIC PANNING USED - SET WHEN NOTE IS STARTED IF ANY PARTIAL REQUIRES SERVICE.  FASTER THIS WAY.	*/
		tname(0)=fname(0);				/*	get temp copy of string	*/
		do l=0 to 7;
			if l<tname(0) then call pbyte(tname,l,byte(fname,l));
			else					 call pbyte(tname,l,0				);
		end;
		do l=0 to 3; call p.store(k+pt.name+l,tname(l+1)); end;		/*	copy name	*/
	END;
	IF (ALLOC.TIMBRE(0)=0)&(ERTYP=0)	/*	CHECK FOR MESSAGE	*/
	THEN CALL DISPLAY.PAR;
	CALL COMPUTE.ENV.PARAMS(0);		/*	COMPUTE ENVELOPE PARAMETERS	*/
	CALL COMPUTE.LOGS(0);				/*	COMPUTE LOGS OF RATIO, CHORUS, ETC.	*/
	CALL COMPUTE.RBITS(0);				/*	RECOMPUTE REAL TIME EFFECTS BITS - AFTER CALL TO COMPUTE.ENV.PARAMS	*/
	CALL COMPUTE.MISC.INFO;				/*	COMPUTE RIBBON & PRESSURE FILTERS	*/
	CALL COMPUTE.TOGGLE.DISPLAY;		/*	ERASE POSSIBLE EARLIER PORTAMENTO BITS	*/

	return (ertyp=0);						/*	good status if no error	*/

end create.patch.partial;

// Expands the size of a patch frame to store a longer name.
// The current name is zapped, but only if the frame needs expanding
expand.patch.partial:proc(par#,fra#,extra) public swapable;	/*	expand a patch list partial	*/
   dcl (par# )			fixed;
   dcl (fra# )			fixed;
   dcl (extra)			fixed;
   dcl (k,m)         fixed;
   dcl (curlen )     fixed;

   k=find.frame(par#,fra#);

   if  ((p.lookup(k     ) != mor         )         // Bail if not a frame
   ||   (p.lookup(k+type) != pt.type     ))        // Specifically, a patch frame
      return;

   curlen = p.lookup(k+clen);                      // get current length of this frame

   if (curlen >= PT.LEN+extra)                     // if it is already big enough
      return;

   IF EX.ROOMFOR(PT.LEN+extra-curlen)=0 THEN DO;
      CALL DISPLAY.ERR(11);                        /*	DISPLAY ERROR IF NO ROOM	*/
      RETURN;
   END;

   call dealloc(0);                                /*	free up wave memories, buffers, etc. for keyboard timbre	*/

   call TIM.HEAD.LOOKUP(0,tim.csem);               /*	treat as timbre recall if notes are now playing          */
   initialcsem=initialcsem+1;
   write(md)=initialcsem;

   CALL COPY.EXT.MEM(PAR.PTR,k+curlen,PAR.PTR,k+PT.LEN+extra,PAR.TOP-k-curlen);      /*	COPY OTHER PARAMETERS UP	*/

   curlen = pt.len+extra;                          // compute new frame length
   p.store(k+clen,   curlen       );
   p.store(k+pt.len, shl(curlen,1));               // store name of that length to keep compact.timbres from tossing it

   do m=pt.len+1 to pt.len+extra-1;
      p.store(k+m, 0);
   end;

   do m=0 to 3;
      p.store(k+pt.name+m, 0);
   end;

   CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);         /*	SET UP NEW POINTERS FOR NUMBER OF TIMBRES IN PAR.PTR. MOVE DOWN NOTES & BANK IF EXT MEM	*/

   // Set the expanded file name area length back to 0 in case it is never used
   k=find.frame(par#,fra#);

   if  ((p.lookup(k     ) == mor    )
   &&   (p.lookup(k+type) == pt.type)
   &&   (p.lookup(k+clen) >  pt.len ))
      p.store(k+pt.len, 0);

   IF (ALLOC.TIMBRE(0)=0)&(ERTYP=0)	/*	CHECK FOR MESSAGE	*/
   THEN CALL DISPLAY.PAR;
   CALL COMPUTE.ENV.PARAMS(0);		/*	COMPUTE ENVELOPE PARAMETERS	*/
   CALL COMPUTE.LOGS(0);				/*	COMPUTE LOGS OF RATIO, CHORUS, ETC.	*/
   CALL COMPUTE.RBITS(0);				/*	RECOMPUTE REAL TIME EFFECTS BITS - AFTER CALL TO COMPUTE.ENV.PARAMS	*/
   CALL COMPUTE.MISC.INFO;				/*	COMPUTE RIBBON & PRESSURE FILTERS	*/
   CALL COMPUTE.TOGGLE.DISPLAY;		/*	ERASE POSSIBLE EARLIER PORTAMENTO BITS	*/

   return (ertyp=0);						/*	good status if no error	*/

end expand.patch.partial;

DELETE.PATCH.FRAME:PROC(I,J) PUBLIC SWAPABLE;	/*	PROCEDURE TO DELETE A PATCH FRAME	*/
	DCL (I,J,K,L)	FIXED;	/*	PASS PARTIAL #, POINTER	*/

	K=P.LOOKUP(J+CLEN);		/*	GET LENGTH OF THIS FRAME	*/
	CALL COPY.EXT.MEM(PAR.PTR,J+K,PAR.PTR,J,PAR.TOP-(J+K));	/*	COPY DOWN REST OF PARAMETERS	*/

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS FOR ALL TIMBRES	*/

END DELETE.PATCH.FRAME;


CREATE.PINFO.FRAME:PROC(I) PUBLIC SWAPABLE;		/*	PROCEDURE TO CREATE OPTIONAL PINFO BLOCK	*/
	DCL (I,J,K)	FIXED;									/*	PASS KEYBOARD PARTIAL #	*/

	IF EX.ROOMFOR(PINFO.LEN)=0 THEN RETURN 0;		/*	NO ROOM	*/

	J=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+I)+NUM.PARAMS;	/*	GET POINTER TO POSSIBLE FRAME 1	*/

	IF  (P.LOOKUP(J)=MOR)								/*	TIMBRE FRAME EXISTS	*/
	AND (P.LOOKUP(J+TYPE)=TF.TYPE)					/*	AND IS A TIMBRE FRAME TYPE	*/
	THEN K=P.LOOKUP(J+P.E.SEG.VOL);					/*	LOOK UP POSSIBLE OLD P.VOL	*/
	ELSE K=1000;											/*	NO PARTIAL VOLUME		*/

	DO WHILE P.LOOKUP(J)=MOR;
		J=J+P.LOOKUP(J+CLEN);
	END;														/*	FIND END OF FRAME LIST	*/

	CALL TIM.HEAD.STORE(0,TIM.PINFO.POINTERS+I,J);

	CALL COPY.EXT.MEM(PAR.PTR,J,PAR.PTR,J+PINFO.LEN,PAR.TOP-J);	/*	COPY OTHER PARAMETERS UP	*/

	CALL P.STORE(J,PINFO);								/*	SET UP PINFO BLOCK	*/
	CALL P.STORE(J+PI.PVOL,K);							/*	STORE PARTIAL VOLUME	*/
	DO K=PI.MDEP TO PINFO.LEN-1;
		WRITE(MDI)=0;
	END;														/*	PROVIDE ZEROES TO OTHER PARAMS	*/

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);		/*	SET UP NEW POINTERS	*/

	CALL COMPUTE.ENV.PARAMS(0);						/*	CLEAN UP KBD ENVELOPE	*/

	RETURN TIM.HEAD.LOOKUP(0,TIM.PINFO.POINTERS+I);

END CREATE.PINFO.FRAME;


CREATE.TINFO.FRAME:PROC PUBLIC SWAPABLE;			/*	PROCEDURE TO CREATE OPTIONAL TINFO BLOCK	*/
	DCL (J,K)	FIXED;

	IF EX.ROOMFOR(TINFO.LEN)=0 THEN RETURN 0;		/*	NO ROOM	*/

	/*	EXPAND OLD RTES NOW	*/
	/*	FOR LATER STORAGE	*/

	K=P.LOOKUP(TIM.HEAD.LOOKUP(0,TIM.MISC.POINTER)+RTE.LOC);	/*	LOOK UP ORIGINAL RTE WORD FOR NEW MAPPING	*/
	CALL EXPAND.OLD.RTE(K,T.AR);						/*	EXPAND OLD FORMAT RTE'S FOR PROCESSING BY NEW CODE	*/

	J=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+(NUM.PARTIALS-1))+NUM.PARAMS;	/*	GET POINTER TO END OF LAST PARTIAL FOR KEYBOARD TIMBRE	*/

	DO WHILE P.LOOKUP(J)=MOR;
		J=J+P.LOOKUP(J+CLEN);
	END;														/*	FIND END OF FRAME LIST	*/

	IF P.LOOKUP(J)=PINFO THEN J=J+PINFO.LEN;		/*	SKIP OVER POSSIBLE PINFO BLOCK	*/

	CALL TIM.HEAD.STORE(0,TIM.TINFO.POINTER,J);

	CALL COPY.EXT.MEM(PAR.PTR,J,PAR.PTR,J+TINFO.LEN,PAR.TOP-J);	/*	COPY OTHER PARAMETERS UP	*/

	CALL P.STORE(J,TINFO);							/*	SET UP TINFO BLOCK	*/
	DO K=1 TO TINFO.LEN-1;
		WRITE(MDI)=0;
	END;													/*	PROVIDE ZEROES TO ALL PARAMETERS	*/
	CALL P.STORE(J+TI.TBD,	 200);				/*	DEFAULT TONE BEND DEPTH OF 2.00 SEMITONES	*/
	CALL P.STORE(J+TI.KCVL,   24);				/*	LEFT KEY	*/
	CALL P.STORE(J+TI.KCVR,48+24);				/*	RIGHT KEY	*/
	CALL P.STORE(J+TI.PREF,  200);
	CALL P.STORE(J+TI.RIBF,  400);
	DO K=TI.NAME TO TI.NAME+7;						/*	INITIALIZE TIMBRE NAME	*/
		CALL P.STORE(J+K,32+SHL(32,8));
	END;	/*	AND SPACES IN NAME FIELD	*/

	K=P.LOOKUP(J+TI.RTE);							/*	SET UP POINTER TO RTE AREA	*/
	CALL COPY.OUT(ADDR(T.AR(0)),40);				/*	STORE RTE BITS THERE	*/
	CALL P.STORE(J+TI.VSENS, V.S.MIN\256);
	CALL P.STORE(J+TI.VCON , V.S.CON		);

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW POINTERS	*/
	CALL COMPUTE.MISC.INFO;							/*	COMPUTE TIME CONSTANTS	*/

	RETURN J;
END CREATE.TINFO.FRAME;


STORE.NEW.TIMBRE.NAME:PROC(NAMEARR) PUBLIC SWAPABLE;	/*	STORE NEW NAME OF KEYBOARD TIMBRE	*/
	DCL NAMEARR		ARRAY;							/*	HOLDS NAME	*/
	DCL I				FIXED;
	DCL J				FIXED;
	DCL NEWNAME(8)	FIXED;

	newname(0)=namearr(0);
	if newname(0) igt 16 then newname(0)=16;

	do i=0 to newname(0)-1;
		j=byte(namearr,i);
		if j<sp then j=sp;
		call pbyte(newname,i,j);
	end;
	do i=newname(0) to 15;							/*	space fill timbre names	*/
		call pbyte(newname,i,sp);
	end;

	CALL TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);
	IF (READ(MD)=0) THEN DO;						/*	CREATE T.FRAME IF ONE NOT THERE	*/
		CALL CREATE.TINFO.FRAME;					/*	MAKE ONE SO CURSOR BLINKS	*/
	END;

	I = TIM.HEAD.LOOKUP(0,TIM.TINFO.POINTER);	/*	TRY AGAIN			*/
	IF (I=0) THEN DO;									/*	OUT OF MEMORY		*/
		CALL NOMEM.ERROR;								/*	TERMINAL ERROR MES	*/
		CALL DISPLAY.ERR(11);						/*	DISPLAY 'OUT OF MEMORY'	*/
		RETURN 0;
	END;

	DO J=0 TO 7;						/*	STORE NAME	*/
		CALL P.STORE(I+TI.NAME+J,NEWNAME(J+1));
	END;

	CALL SELECT.PARAMETER(TNAME.L-PAR.L);		/*	SHO NAME IN WINDOW TOO	*/

	/*	Create a system event when someone enters a new name	*/
	/*	for the current keyboard timbre:								*/

	NEW.TIMBRE.INFO = NEW.TIMBRE.INFO \ 4;

	RETURN 1;

END STORE.NEW.TIMBRE.NAME;

/*	$SUBTITLE  ROUTINE TO BOUNCE PARTIALS ON KEYBOARD TIMBRE	*/


DCL (ALLOC.ALL.TIMBRES)	FORWARD RECURSIVE;
DCL (DEALLOC.ALL)			FORWARD RECURSIVE;
DCL (ALLOC.AND.COMPUTE)	FORWARD RECURSIVE;


BOUNCE.PARTIAL:  PROC (SOU,DES) PUBLIC SWAPABLE;	/*	PASS PARTIAL NUMBERS - BOUNCES PARTIALS OF KBD TIMBRE	*/
	DCL (SOU,DES)				FIXED;	/*	SOURCE AND DEST PARTIAL #'S FOR BOUNCE	*/
	DCL (SOU.PTR,DES.PTR)	FIXED;	/*	EXMEM PTRS TO THE PARTIALS		*/
	DCL (SOU.LEN,DES.LEN)	FIXED;	/*	WORD LENGTHS OF THE PARTIALS	*/

	CALL DEALLOC(0);			/*	FREE UP MEMORIES/BLOCKS FOR KBD TIMBRE	*/

	SOU.PTR=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+SOU);	/*	GET PTR TO SOURCE PARTIAL	*/
	DES.PTR=TIM.HEAD.LOOKUP(0,TIM.PARTIAL.POINTERS+DES);	/*	GET PTR TO DEST	PARTIAL	*/

	/*	COMPUTE LENGTH OF THE SOURCE AND DEST	*/
	/*	PARTIAL TIMBRES BEFORE THE BOUNCE	*/

	SOU.LEN=NUM.PARAMS;								/*	LENGTH OF BASIC PARTIAL TIMBRE	*/
	DO WHILE (P.LOOKUP(SOU.PTR+SOU.LEN)=MOR);	/*	HAVE A FRAME OF SOME SORT			*/
		SOU.LEN=SOU.LEN+P.LOOKUP(SOU.PTR+SOU.LEN+CLEN);	/*	ADD IN ITS LENGTH			*/
	END;
	IF (P.LOOKUP(SOU.PTR+SOU.LEN)=PINFO)		/*	PARTIAL HAS A 'PINFO' BLOCK		*/
	THEN SOU.LEN=SOU.LEN+PINFO.LEN;				/*	ADD IN ITS LENGTH						*/

	DES.LEN=NUM.PARAMS;								/*	LENGTH OF BASIC PARTIAL TIMBRE	*/
	DO WHILE (P.LOOKUP(DES.PTR+DES.LEN)=MOR);	/*	HAVE A FRAME OF SOME SORT			*/
		DES.LEN=DES.LEN+P.LOOKUP(DES.PTR+DES.LEN+CLEN);	/*	ADD IN ITS LENGTH			*/
	END;
	IF (P.LOOKUP(DES.PTR+DES.LEN)=PINFO)		/*	PARTIAL HAS A 'PINFO' BLOCK		*/
	THEN DES.LEN=DES.LEN+PINFO.LEN;				/*	ADD IN ITS LENGTH						*/


	IF SOU.LEN<>DES.LEN THEN DO;		/*	PARTIALS ARE DIFFERENT LENGTHS - MOVE STUFF AROUND	*/

		IF SOU.LEN IGT DES.LEN THEN DO;	/*	GETTING LONGER - CHECK FOR MAX, MOVE BANK & NOTES UP	*/
			IF EX.ROOMFOR(SOU.LEN-DES.LEN)=0
			THEN DO;							/*	WILL NOT FIT				*/
				CALL DISPLAY.ERR(11);	/*	DISPLAY 'OUT OF MEMORY'	*/
				RETURN;						/*	BOMB OUT						*/
			END;
		END;

		IF SOU.PTR IGE (DES.PTR+DES.LEN)			/*	CORRECT SOURCE PTR IF		*/
		THEN SOU.PTR=SOU.PTR+SOU.LEN-DES.LEN;	/*	SOURCE MOVES DURING COPY	*/

		CALL COPY.EXT.MEM(PAR.PTR,(DES.PTR+DES.LEN),		/*	SOURCE FOR COPY		*/
								PAR.PTR,(DES.PTR+SOU.LEN),		/*	DEST	 FOR COPY		*/
								PAR.TOP-(DES.PTR+DES.LEN));	/*	COPY LENGTH IN WDS	*/

	END;

	CALL COPY.EXT.MEM(PAR.PTR,SOU.PTR,PAR.PTR,DES.PTR,SOU.LEN);	/*	MOVE THE PARTIAL INTO PLACE	*/
	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	SET UP NEW MEMORY POINTERS IN CASE THINGS MOVED	*/
	CALL ZERO.FRAME.PTRS;			/*	INITIALIZE FRAME POINTERS ON PARTIAL BOUNCE	*/

	CALL ALLOC.TIMBRE		  (0);	/*	ALLOCATE WAVE MEMORIES, ETC		*/
	CALL COMPUTE.ENV.PARAMS(0);	/*	PRECOMPUTE ENVELOPE PARAMETERS	*/
	CALL COMPUTE.LOGS		  (0);	/*	PRECOMPUTE LOGS	*/
	CALL COMPUTE.RBITS	  (0);	/*	RECOMPUTE REAL TIME EFFECTS BITS - ALWAYS CALL AFTER COMPUTE.ENV.PARAMS SO TOPTIONS IS SET UP	*/
	CALL COMPUTE.MISC.INFO;			/*	COMPUTE RIBBON & PRESSURE FILTERS	*/
	CALL CHECK.MEMORY.FOR.RECORD;	/*	MAKE SURE WE STILL HAVE ENOUGH ROOM	*/

	CALL TIM.HEAD.STORE(0,TIM.CSEM,TIM.HEAD.LOOKUP(0,TIM.CSEM)+1);	/*	INC MAGIC# TO AVOID FDECAY/SPLICING BUGS	*/

	NEW.PRM.INFO=NEW.PRM.INFO\BITS(DES);

END BOUNCE.PARTIAL;
