/*	:SYNRSOU:11-TIMB:161-TMB1  $TITLE  PROC TO SET UP NEW TIMBRE (FROM MOVE.TIMBRE.TO)	*/

/*
Modified:
1999/04/11 - TY  - Modified "SETUP.NEW.TIMBRE" to utilize 4.20 user defaults.
1991/03/15 -     - Removed reference to tname cursor
1991/01/30 - MWH - Report which tracks have had new notes
1989/08/24 - PF  - Zero THD.MIDI.PATH in SETUP.NEW.TIMBRE
1988/03/15 - cj  - Send over info to dtd after changing track volume
1987/07/02 - MWH - kbd lookup table literals; restructured for 32 bit poly
*/

DCL (RESET.FILTERS)		FIXED PUBLIC;	/*	SET TRUE IF SHOULD RESET FILTERS	*/
DCL (LENGTH.OVERFLOW)	FIXED PUBLIC;	/*	SET TRUE IF OUT OF MEMORY IN MOVE.TIMBRE.TO	*/
DCL (SUPPRESS.ERR)		FIXED PUBLIC;	/*	SUPPRESS ERR11 SOMETIMES	*/

SETUP.NEW.TIMBRE:PROC(TIMBRE#) SWAPABLE;
	DCL (TIMBRE#)				FIXED;
	DCL (STATUS,NUM.PARS)	FIXED;
	DCL (MISC.BASE)			FIXED;
	DCL (NUM.FRAMES)			FIXED;
	DCL (PTL,TBP)				FIXED;
	DCL (I,J,K)					FIXED;

	IF TIMBRE#=PAR.NUMT					/*	IF ADDING BEYOND END	*/
	THEN PAR.NUMT=PAR.NUMT+1;			/*	THEN ADD TO PAR.NUMT	*/

	CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);		/*	COMPACT THE TIMBRE IF POSSIBLE, PLUS SET UP NEW POINTERS	*/

	/*	$PAGE - END OF MOVE.TIMBRE.TO	*/

	/*	COMPUTE NUMBER OF PARTIAL TIMBRES REQUIRED	*/
	/*	ALLOCATE WAVE MEMORIES, PATCH BLOCKS	*/
	/*	FIX UN-INITIALIZED PARAMETER VALUES		*/

	NUM.PARS=0; NUM.FRAMES=0;			/*	NO ERRORS, PARTIALS OR FRAMES YET	*/

	WRITE(MAM)=TIM.HEAD;					/*	LOOK UP TABLE	*/
	WRITE(MAL)=TIMBRE#;					/*	INDEX				*/

	TBP=READ(MD);							/*	TIMBRE HEAD		*/

	IF TBP=0 THEN DO;						/*	NOT AVAIL		*/
		CALL DISPLAY.ERR(14);			/*	NOT ENOUGH ROOM IN EXT MEMORY	*/
		CALL NOMEM.ERROR;					/*	NOT ENOUGH EXTERNAL MEMORY		*/
		STATUS=1;
	END;

	ELSE DO;									/*	SET UP TIMBRE HEAD				*/

		WRITE(MAM)=TBP;
		WRITE(MAL)=TIM.CSEM;
		WRITE(MD )=READ(MD)+1;

		STATUS=ALLOC.TIMBRE(TIMBRE#);			/*	REALLOCATE WAVE MEMORIES, ETC FOR NEW INFO	*/

		WRITE(MAM)=TIM.HEAD;						/*	LOOK UP TABLE	*/	/*	IN CASE	*/
		WRITE(MAL)=TIMBRE#;						/*	INDEX				*/	/*	IT MOVED	*/
		TBP=READ(MD);								/*	TIMBRE HEAD		*/

		DO PTL=0 TO NUM.PARTIALS-1;			/*	LOOP OVER PARTIALS	*/

			J=0;										/*	COUNT # OF VOICES FOR THIS PARTIAL	*/

			WRITE(MAM)=TBP;
			WRITE(MAL)=TIM.PARTIAL.POINTERS+PTL;
			PTPTR=READ(MD);						/*	LOOK UP POINTER HERE FOR NEW FORMAT	*/

			WRITE(MAL)=TIM.PAN.PHASE+PTL;
			WRITE(MD )=0;							/*	RESYNC PARTIAL PHASES DURING RECALL	*/

			IF (P.LOOKUP(PTPTR)<>SUP) THEN DO;	/*	ACTIVE PARTIAL - LOOK FURTHER	*/
				IF P.LOOKUP(PTPTR+P.NEW.CHORUS)<32 THEN WRITE(MD)=1000;	/*	PARTIAL CHORUS - SET TO 1.000 IF UNINITIALIZED	*/
				IF ((P.LOOKUP(PTPTR+P.EPEAKL)\P.LOOKUP(PTPTR+P.ESUSTL))&1023)<>0 THEN DO;	/*	LOOK FOR NONZERO PEAK/SUST LEVEL	*/
					J=1;															/*	USES ONE VOICE	*/
					IF P.LOOKUP(PTPTR+P.NEW.CHORUS)<>1000 THEN J=2;	/*	USES TWO VOICES IF NEW CHORUS FUNCTION	*/
				END;
				PTPTR=PTPTR+NUM.PARAMS;			/*	GET TO FIRST ONE		*/
				IF  (P.LOOKUP(PTPTR)=MOR)		/*	IF THERE ARE FRAMES	*/
				AND (P.LOOKUP(PTPTR+TYPE)=TF.TYPE)	/*	OF THE CORRECT VARIETY	*/
				THEN DO;								/*	MARK TIMBRE FRAMES	*/
					J=J+J;							/*	DOUBLE VOICES IF ANY FRAMES	*/
					IF P.LOOKUP(PTPTR+P.E.SEG.VOL)=0 THEN WRITE(MD)=1000;	/*	INITIALIZE PARTIAL VOLUME IF NOT THERE	*/
					DO WHILE P.LOOKUP(PTPTR)=MOR;
						NUM.FRAMES=NUM.FRAMES+1;
						PTPTR=PTPTR+P.LOOKUP(PTPTR+CLEN);
					END;
				END;
				ELSE DO;							/*	CHECK FOR STEREO SOUND FILES	*/
					WRITE(MAM)=TBP;									/*	TIMBRE HEAD	*/
					WRITE(MAL)=TIM.KBDTAB.PTR+PTL;
					IF READ(MD)<>0				/*	TABLE EXISTS						*/
					THEN DO;
						WRITE(MAM)=TIM.PTR+READ(MD)-1;	/*	RESTORE MEMORY POINTERS AGAIN	*/
						I=0;
						DO K=0 TO (NUM.KEYS*KLT.SIZE-1) BY KLT.SIZE;
							WRITE(MAL)=K+KLT.BASE.MSB;		/*	CHECK STEREO ENTRY	*/
							IF (READ(MD)&BASE#STEREO_B)<>0 THEN I=1;
						END;
						IF I<>0 THEN J=SHL(J,1);
					END;
				END;
				NUM.PARS=NUM.PARS+J;
			END;

		END;	/*	OF PARTIALS LOOP	*/


		/*	$PAGE - FIX OLD CHORUS VALUES, & REDISPLAY PARAMETERS FOR KEYBOARD	*/

		WRITE(MAM)=TBP;
		WRITE(MAL)=TIM.MISC.POINTER;
		MISC.BASE=READ(MD);			/*	LOOK UP POINTER	*/

		IF P.LOOKUP(MISC.BASE+CHORUS.LOC)= 0000
		THEN WRITE(MD)=1000;					/*	DETECT VERY OLD TIMBRES WITH NO CHORUS VALUE	*/
		IF READ(MD)<>1000 THEN NUM.PARS=NUM.PARS+NUM.PARS;	/*	2X REQUIRED IF CHORUS	*/
		IF P.LOOKUP(MISC.BASE+RTE.LOC   )= 0000
		THEN WRITE(MD)="172";				/*	INITIALIZE OLD RTE'S	*/

		K=SHR(P.LOOKUP(MISC.BASE),8);		/*	GET MAX # OF NOTES	*/
		IF K=0 THEN K=128;
		WRITE(MD)=(READ(MD)&255)\SHL(K,8);	/*	STORE MAX OF 128 IN TIMBRE IF WE GET A ZERO	*/

		WRITE(MAM)=TBP;
		WRITE(MAL)=TIM.MAX.NUM.NOTES;
		WRITE(MD )=K;

		WRITE(MAL)=TIM.ANY.DPAN;
		WRITE(MD )=0;

	END;

	IF TIMBRE#=0 THEN DO;			/*	MOVING TO KEYBOARD TIMBRE - MUST LOOK UP PERFORMANCE INFO	*/

		K=P.LOOKUP(MISC.BASE+GTINFO.LOC) XOR (-1);	/*	GET GUITAR INFO, INVERT LOGIC AS REQUIRED	*/

		TFILT=0;  QUANT=0; PFILT=0;
		VTRACK=0; DCONT=0; TFILTEN=0;
		FOLLOW.GUITAR=0;				/*	MOVE TO INDIVIDUAL VARIABLES FOR GUITAR SCAN SPEED	*/

		IF (K&"100000")<>0 THEN   TFILT=1;
		IF (K&"040000")<>0 THEN   QUANT=1;
		IF (K&"020000")<>0 THEN   PFILT=1;
		IF (K&"010000")<>0 THEN  VTRACK=1;
		IF (K&"004000")<>0 THEN   DCONT=1;
		IF (K&"002000")<>0 THEN TFILTEN=1;
		IF (K&"001000")<>0 THEN FOLLOW.GUITAR=1;

		IF (QUANT<>0)		  THEN PFILT=0;	/*	BUT NEVER DO BOTH. QUANT HAS PRIORITY	*/
		IF (TFILTEN=0)		  THEN TFILT=0;	/*	DISABLE TFILTER IF NONE DESIRED	*/
		IF FOLLOW.GUITAR<>0 THEN DCONT=0;	/*	MAKE SURE FOLLOW AND DCONT ARE MUTUALLY EXCLUSIVE	*/

		CALL ZERO.FRAME.PTRS;				/*	INITIALIZE FRAME POINTERS WHEN RECALLING TO KEYBOARD	*/

		IF BOUNCE.PTR<>0 THEN CALL ABORT.BOUNCE.SMT.SKT;	/*	TRASH BOUNCING ON TIMBRE RECALL	*/

		CALL COMPUTE.RTE.BUTTONS;	/*	SET UP RTE BUTTONS AS REQUIRED	*/
		CALL COMPUTE.TOGGLE.DISPLAY;	/*	SET UP LIGHTS FOR TOGGLE FUNCTIONS (PORT, REPEAT, ARPEG, FILTERS, VIBRATO)	*/

		WRITE(MAM)=TBP;
		WRITE(MAL)=TIM.TINFO.POINTER;
		K=READ(MD);

		IF K<>0 THEN DO;						/*	CHECK FOR VEL SENS INFO IN TIMBRE	*/
			V.S.MIN=P.LOOKUP(K+TI.VSENS);
			V.S.CON=P.LOOKUP(K+TI.VCON );
			IF V.S.MIN=0 THEN DO;			/*	ZERO MEANS OLD TINFO BLOCK	*/
				write("313") = GID(Default.VelocitySens);
				V.S.MIN = shr(read("313"),4);
				V.S.CON = read("313") & 0xF;
			END;
			ELSE V.S.MIN=V.S.MIN&255;
		END;
		ELSE DO;
			write("313") = GID(Default.VelocitySens);
			V.S.MIN = shr(read("313"),4);
			V.S.CON = read("313") & 0xF;
		END;

		IF NEW.PAN<>0											/*	COMPUTE TTIME TO VEL MAPPING	*/
		THEN CALL COMPUTE.SYNC.TTIME.MAP(V.S.CON);	/*	IF ON VEL KBD ONLY	*/
		LOAD 0; WRITE(4)=V.S.MIN; DIV 100;				/*	COMPUTE HERE FOR FASTER VEL KBD SCAN	*/
		V.S.MUL=RES;											/*	COMPUTE FRACT MUL CONSTANT	*/

		//	Get this user default handy now so we won't have to re-point MAM to the keyboard track head later
		write("313") = GID(Default.MIDI.RTEs);

		WRITE(MAM)=TRK.HEAD;								/*	SET KEYBOARD INFO ON TIMBRE RECALL	*/
		WRITE(MAM)=READ(MD);								/*	KEYBOARD TRACK HEAD	*/

		WRITE(MAL)=THD.TVOL;
		WRITE(MD )=1000;

		WRITE(MAL)=THD.MIDX;
		WRITE(MD )=0;

		WRITE(MAL)=THD.MIDI;
		WRITE(MD )=0;

		WRITE(MAL) = THD.ACTIVE.MIDI.RTES;			/*	SET TO USER DEFAULT VALUES	*/
		WRITE(MD ) = read("313");

		WRITE(MAL)=THD.MIDI.PATH;
		WRITE(MD )=0;										/*	RESET MIDINET ROUTING ALSO	*/

		CALL CLEAR.MIDI.OUT.CONTROLLERS(0);

		NEW.MOTION				  = 1;	/*	SEND NEW CUE TRACK CONSTANTS		*/
		NEW.CUE.TRACK.SETTINGS = 1;	/*	OVER AFTER TIMBRE RECALL			*/

	END;

	WRITE(MAM)=TIM.HEAD;						/*	LOOK UP TABLE	*/	/*	IN CASE	*/
	WRITE(MAL)=TIMBRE#;						/*	INDEX				*/	/*	IT MOVED	*/
	TBP=READ(MD);								/*	TIMBRE HEAD		*/

	WRITE(MAM)=TBP;
	WRITE(MAL)=TIM.TINFO.POINTER;
	K=READ(MD);

	IF (LENGTH.OVERFLOW<>0) THEN DO;
		IF SUPPRESS.ERR=0 THEN CALL DISPLAY.ERR(11);	/*	11 - OUT OF RROM	*/
	END;
	ELSE DO;	/*	DISPLAY # OF PARTIALS	*/
		IF STATUS=0
		THEN CALL DISPLAY.TIMBRE.RECALL.INFO(K,NUM.PARS,NUM.FRAMES);	/*	DISPLAY INFO IN TIMBRE RECALL	*/
	END;

	CALL COMPUTE.ENV.PARAMS(TIMBRE#);	/*	COMPUTE ENVELOPE PARAMETERS	*/
	CALL COMPUTE.LOGS		  (TIMBRE#);	/*	COMPUTE LOGS OF RATIO, CHORUS, ETC.	*/
	CALL COMPUTE.RBITS	  (TIMBRE#);	/*	RECOMPUTE REAL TIME EFFECTS BITS - ALWAYS CALL AFTER COMPUTE.ENV.PARAMS SO TOPTIONS IS SET UP	*/
	CALL COMPUTE.MISC.INFO;					/*	COMPUTE RIBBON & PRESSURE FILTERS	*/
	CALL CHECK.MEMORY.FOR.RECORD;			/*	MAKE SURE WE STILL HAVE ENOUGH ROOM	*/

	IF TIMBRE#>=NUM.KBD.TRACKS					/*	IF NOT A KEYBOARD TIMBRE	*/
	THEN CALL COMPUTE.USAGE.KEY#(TIMBRE#);	/*	RECOMPUTE USAGE KEY # (MUST BE DONE AFTER COMPUTE.ENV.PARAMS)	*/

END SETUP.NEW.TIMBRE;

/*	$SUBTITLE  MOVE.TIMBRE.TO ROUTINE	*/


/*	MOVE.TIMBRE.TO MOVES TIMBRES BETWEEN THE KEYBOARD, SEQUENCER TRACKS,
AND TIMBRE BANKS.  BY SPECIFYING A BASE OF -1, THE ROUTINE CAN BE
USED TO MOVE A TIMBRE DIRECTLY FROM DISK INTO MEMORY.	*/


MOVE.TIMBRE.TO:PROC(XBASE,PTR,TIMBRE#) PUBLIC SWAPABLE;	/*	SPECIFY MEMORY POINTER (UPPER, LOWER), TIMBRE #	*/
	DCL (XBASE,PTR,TIMBRE#)				FIXED;
	DCL (BASE)								FIXED STATIC;
	DCL (PTL)								FIXED;
	DCL (I,J,K,L,N,Q,R,S,T)				FIXED;
	DCL (NEW.LENGTH,OLD.LENGTH)		FIXED;
	DCL (S.BF.DEV,S.BF.SEC,S.BF.PTR)	FIXED;
	DCL (S.MS.LEN,S.LS.LEN)				FIXED;
	DCL (S.I,S.J)							FIXED;
	DCL (X.BF.DEV,X.BF.SEC,X.BF.PTR)	FIXED;
	DCL (NUM.TO.DO)						FIXED;
	DCL (PLENS)  (NUM.PARTIALS-1)		FIXED;
	DCL (PBNK,PPAR)						FIXED;

	W.LOOKUP:PROC(PTR);					/*	LOOK UP WORD FROM INTERNAL OR EXTERNAL MEMORY	*/
		DCL (PTR)	FIXED;				/*	USES PASSED 'BASE' AS EXTERNAL MEMORY BASE	*/
		WRITE(MAM)=BASE+SHR(PTR,8); WRITE(MAL)=PTR;
		RETURN READ(MD);
	END;

	BASE = XBASE;							/*	SAVE IN LOCAL STATIC VARIABLE	*/

	IF TIMBRE#=0 THEN DO;				/*	IF ASSIGNING TO KEYBOARD, CLEAN UP SEVERAL THINGS	*/
		XPOS=0;								/*	REMOVE TRANSPOSE	*/
		CALL DISPLAY.SEQUENCER.STATUS;	/*	DELETE TRANSPOSE LIGHT	*/
		RESET.FILTERS=1;					/*	SIGNAL TO RESET FILTER DACS	*/
		IF  (DIAGNOSTICS.ENABLED=0)	/*	IF NOT THE DIAGNOSTIC PROGRAM	*/
		AND (SOLOED.PARTIALS<>15) THEN DO; SOLOED.PARTIALS=0; CALL DISPLAY.PARTIAL.BUTTONS; END;	/*	MUST CLEAR SOLOING TO HEAR NEW TIMBRE	*/

		/*	Create a system event when calling up a new timbre to the	*/
		/*	keyboard.  Set both the bits for a new keyboard timbre		*/
		/*	and a new name for the keyboard timbre:							*/

		NEW.TIMBRE.INFO = NEW.TIMBRE.INFO \ (1 \ 4);

		IF IN.BLINK.MODE THEN CALL TOGGLE.BLINK;	/*	GET OUT OF BLINK MODE ON TIMBRE RECALL	*/
	END;
	ELSE DO;

		/*	Create a New Seq Info system event when changing the timbre	*/
		/*	on a track:																	*/

		interp_seq_dirtyness(1);

		NEW.SEQ.INFO = NEW.SEQ.INFO \ 2;	/*	REDRAW TRACK NAMES ON SMT	*/
		WRITE(MAM) = D115D.NOTE.CHANGE.TRACKS;
		WRITE(MAL) = TIMBRE#;				/*	REMEMBER TRACK # ON NEW.SEQ.INFO	*/
		WRITE(MD) = "177777";				/*	"NEW NOTES" OR "NEW TIMBRE"		*/
	END;

	IF TIMBRE#<PAR.NUMT					/*	IF TIMBRE EXISTS NOW	*/
	THEN CALL DEALLOC(TIMBRE#);		/*	THEN FREE UP WAVE MEMORIES, PATCH BLOCKS, ETC FOR NOW	*/

	/*	$PAGE - COPY USING VARIABLE LENGTH ALGORITHM	*/

	LENGTH.OVERFLOW=0;		/*	CLEAR FLAG FROM POSSIBLE EARLIER LENGTH ERROR		*/
	I=PTR;						/*	GET POINTER TO START OF NEW TIMBRE (OFF OF BASE)	*/
	J=FIND.TIMBRE(PAR.PTR,TIMBRE#);	/*	COMPUTE POINTER TO DEST IN OUR TIMBRE AREA - REL TO PAR.PTR	*/
	K=0;							/*	INITIALIZE PARTIAL COUNTER	*/

	DO WHILE (K<NUM.PARTIALS);	/*	PROCESS EACH PARTIAL - BEGIN BY FINDING LENGTH OF NEW PARTIAL	*/

		S.BF.DEV=DISK.DEV;	/*	SAVE INITIAL POINTERS	*/
		S.BF.SEC=DISK.SEC;	/*	FOR BOTH DISK AND			*/
		S.BF.PTR=BUF.R.PTR;	/*	MEMORY						*/
		S.MS.LEN=MAX.LEN.MSB;
		S.LS.LEN=MAX.LEN.LSB;

		S.I=I; S.J=J;

		IF HELD.PSEL.BUTTONS=0
		THEN NUM.TO.DO=4;		/*	MOVE ALL 4 PARTIALS AT ONCE IF POSSIBLE	*/
		ELSE NUM.TO.DO=1;		/*	SELECTIVE RECALL - MOVE 1 AT A TIME			*/

		/*	FIRST MEASURE LENGTHS	*/
		/*	OF OLD AND NEW TIMBRE	*/

		NEW.LENGTH=0;
		OLD.LENGTH=0;

		Q=0;
		DO WHILE (Q<NUM.TO.DO);	/*	COMPUTE LENGTH OF EACH PARTAL TO MOVE	*/

			IF BASE=(-1) THEN DO;	/*	MUST SEARCH DISK FOR TIMBRE LENGTH	*/
				X.BF.DEV=DISK.DEV; X.BF.SEC=DISK.SEC; X.BF.PTR=BUF.R.PTR;	/*	SAVE POINTERS TO START OF PARTIAL - ON DISK OR IN MEMORY	*/
				IF G.NEXT=SUP THEN DO;	/*	MOVING SUPPRESSED TIMBRE - CHECK KBD	*/
					IF (TIMBRE#=0) THEN NEW.LENGTH=NEW.LENGTH+NUM.PARAMS-1;	/*	MOVING SUPPRESSED PARTIAL TO KEYBOARD - EXPAND SO KNOB WORKS OK	*/
				END;
				ELSE DO;							/*	MUST SKIP OVER PARTIAL				*/
					BUF.R.PTR=BUF.R.PTR-1;	/*	RESTORE WORD FOR NEXT GET.NEXT	*/
					CALL SKIP.DISK.PAR;		/*	SKIP OVER THE PARTIAL ON DISK		*/
				END;
				IF (HELD.PSEL.BUTTONS=0)&((K+Q)=NUM.PARTIALS-1) THEN DO;	/*	CHECK FOR INCLUSION OF MISC AREA	*/
					IF G.NEXT=TINFO THEN CALL SKIP.WRDS(TINFO.LEN-1);		/*	SKIP TIMBRE INFO	*/
					ELSE BUF.R.PTR=BUF.R.PTR-1;		/*	RESTORE WORD FOR NEXT GET.NEXT	*/
					CALL SKIP.WRDS(NUM.MISC.PARAMS);	/*	SKIP OVER MISC INFO	*/
				END;
				R=SHL(DISK.SEC-X.BF.SEC,8)+BUF.R.PTR-X.BF.PTR;	/*	LENGTH IS EQUAL TO NUMBER OF WORDS SKIPPED	*/
			END;

			ELSE DO;	/*	COMPUTE LENGTH OF NEW TIMBRE IN MEMORY	*/
				L=I;									/*	SAVE START POINTER FOR LENGTH COMPUTATION	*/
				IF W.LOOKUP(I)=SUP THEN DO;	/*	SUPPRESSED - COUNT 1 WORD, CHECK FOR EXPANSION IF MOVING TO KBD	*/
					I=I+1;							/*	SUPRRESSED TIMBRE - SKIP OVER 1 WORD		*/
					IF (TIMBRE#=0) THEN NEW.LENGTH=NEW.LENGTH+NUM.PARAMS-1;	/*	MOVING SUPPRESSED PARTIAL TO KEYBOARD - EXPAND SO KNOB WORKS OK	*/
				END;
				ELSE DO;
					I=I+NUM.PARAMS;	/*	SKIP OVER STUFF PARAMS, GET TO VARIABLE LENGTH STUFF	*/
					DO WHILE (W.LOOKUP(I)=MOR); I=I+W.LOOKUP(I+CLEN); END;	/*	LOOP OVER SUCCESSIVE PARTIALS	*/
					IF W.LOOKUP(I)=PINFO THEN  I=I+PINFO.LEN;				/*	PARTIAL INFO	*/
				END;
				IF (HELD.PSEL.BUTTONS=0)&((K+Q)=NUM.PARTIALS-1) THEN DO;	/*	CHECK FOR INCLUSION OF MISC AREA (PARTIAL # 4, COMPLETE PARTIAL COPY)	*/
					IF W.LOOKUP(I)=TINFO THEN I=I+TINFO.LEN;	/*	SKIP TIMBRE INFO		*/
					I=I+NUM.MISC.PARAMS;								/*	INCLUDE MISC STUFF	*/
				END;
				R=I-L;	/*	COMPUTE NUMBER OF WORDS TO COPY	*/
			END;

			NEW.LENGTH=NEW.LENGTH+R;	/*	COUNT UP ACTUAL LENGTH	*/
			PLENS(Q)=R;						/*	SAVE FOR LATER USE		*/

			/*	COMPUTE LENGTH OF IN-CORE TIMBRE	*/

			IF TIMBRE#<PAR.NUMT THEN DO;
				L=J;										/*	SAVE STARTING POINTER				*/
				IF P.LOOKUP(J)=SUP THEN J=J+1;	/*	SKIP OVER SUPPRESSED PARTIAL		*/
				ELSE DO;
					J=J+NUM.PARAMS;	/*	SKIP OVER STUFF	*/
					DO WHILE (P.LOOKUP(J)=MOR); J=J+P.LOOKUP(J+CLEN); END;	/*	LOOP OVER SUCCESSIVE WAVE FORMS	*/
					IF P.LOOKUP(J)=PINFO THEN J=J+PINFO.LEN;
				END;
				IF (HELD.PSEL.BUTTONS=0)&((K+Q)=NUM.PARTIALS-1) THEN DO;	/*	CHECK FOR INCLUSION OF MISC AREA (PARTIAL # 4, COMPLETE PARTIAL COPY)	*/
					IF P.LOOKUP(J)=TINFO THEN J=J+TINFO.LEN;	/*	SKIP TIMBRE INFO	*/
					J=J+NUM.MISC.PARAMS;					/*	INCLUDE MISC STUFF	*/
				END;
				OLD.LENGTH=OLD.LENGTH+J-L;				/*	LENGTH OF IN-CORE AREA	*/
			END;

			Q=Q+1;

		END;												/*	OF LOOP TO COMPUTE NEW&OLD LENGTHS	*/

		/*	$PAGE - MAKE ROOM FOR NEW TIMBRE IF IT IS LONGER (OR SHORTER) THAN OLD ONE	*/

		IF (HELD.PSEL.BUTTONS=0) OR ((HELD.PSEL.BUTTONS&BITS(K))<>0) THEN DO;	/*	COPY THIS PARTIAL	*/

			IF NEW.LENGTH<>OLD.LENGTH THEN DO;	/*	MUST COPY MEMORY UP OR DOWN TO MAKE ROOM IF LENGTHS DIFFER	*/

				S=NEW.LENGTH-OLD.LENGTH;		/*	GET DIFFERENCE IN LENGTH	*/

				PBNK=BNK.PTR;						/*	SAVE ORIGINAL POINTERS	*/
				PPAR=PAR.PTR;						/*	TO DETECT SOURCE MOVING	*/

				IF (NEW.LENGTH ILT OLD.LENGTH)
				THEN DO;								/*	NEW LENGTH IS SHORTER	*/
					CALL COPY.EXT.MEM(PAR.PTR,S.J+OLD.LENGTH,
											PAR.PTR,S.J+NEW.LENGTH,
											PAR.TOP-(S.J+OLD.LENGTH));
					PAR.TOP=PAR.TOP+S;			/*	NEW PAR.TOP					*/
					IF  (BASE =   PAR.PTR		  )	/*	SEE IF SOURCE MOVED	*/
					AND (S.I IGE (S.J+OLD.LENGTH))
					THEN S.I=S.I+S;				/*	UPDATE SOURCE POINTER	*/
					OLD.LENGTH=NEW.LENGTH;		/*	NOW THEY ARE THE SAME	*/
					CALL GET.PAR.STORAGE(SHR(PAR.TOP+255,8));	/*	SET NEW PAR.LEN	*/
				END;

				ELSE DO;								/*	NEW LENGTH IS LONGER		*/

					IF ((PAR.TOP+S) ILT PAR.TOP)		/*	OVERFLOW				*/
					OR ((PAR.TOP+S) IGE (-512) )		/*	OR TOO BIG			*/
					THEN DO;							/*	RESULTS >= 254 SECTORS	*/
						/*	ERROR HANDLED BELOW WITH LENGTH.OVERFLOW VARIABLE	*/
					END;								/*	NO GO							*/

					ELSE DO;							/*	SEE IF ROOM AVAIL			*/
						IF GET.PAR.STORAGE(SHR(PAR.TOP+S+255,8))<>0
						THEN DO;
							CALL COPY.EXT.MEM(PAR.PTR,S.J,PAR.PTR,S.J+S,PAR.TOP-S.J);	/*	COPY PARAMETER STUFF UP OR DOWN	*/
							PAR.TOP=PAR.TOP+S;
							IF  (BASE  =  PPAR)		/*	SEE IF SOURCE MOVED	*/
							AND (S.I  IGE S.J )
							THEN S.I=S.I+S;			/*	UPDATE SOURCE POINTER	*/
							OLD.LENGTH=NEW.LENGTH;	/*	NOW THEY ARE THE SAME	*/
						END;
						ELSE IF (BASE<>PBNK)			/*	NOT FROM BANK			*/
						THEN DO;							/*	CAN TOSS BANK			*/
							BNK.LEN=0;					/*	TOSS BANK				*/
							ACTIVE.BANK.LEN=0;
							IF GET.PAR.STORAGE(SHR(PAR.TOP+S+255,8))<>0
							THEN DO;
								CALL COPY.EXT.MEM(PAR.PTR,S.J,PAR.PTR,S.J+S,PAR.TOP-S.J);	/*	COPY PARAMETER STUFF UP OR DOWN	*/
								PAR.TOP=PAR.TOP+S;
								IF  (BASE  =  PPAR)		/*	SEE IF SOURCE MOVED		*/
								AND (S.I  IGE S.J )
								THEN S.I=S.I+S;			/*	UPDATE SOURCE POINTER	*/
								OLD.LENGTH=NEW.LENGTH;	/*	NOW THEY ARE THE SAME	*/
							END;
							ELSE;	/*	ERROR HANDLED BELOW WITH LENGTH.OVERFLOW VARIABLE	*/
						END;
					END;
				END;

				IF BASE=PBNK							/*	RESET BASE IN CASE	*/
				THEN BASE=BNK.PTR;					/*	SOURCE BLOCK MOVED	*/

				ELSE IF BASE=PPAR						/*	DURING MEMORY			*/
				THEN BASE=PAR.PTR;					/*	SHUFFLE					*/

			END;

			/*	$PAGE - COPY INFO INTO PLACE (IF ROOM)	*/

			IF NEW.LENGTH=OLD.LENGTH THEN DO;	/*	COPY INTO PLACE IF ROOM	*/

				IF BASE=(-1) THEN DO;				/*	READING FROM DISK - REPRIME BUFFER IF REQUIRED	*/
					CALL PRIME.IO.BUFFER(S.BF.DEV,S.BF.SEC,S.BF.PTR,
												S.MS.LEN,S.LS.LEN,
												BUFR.START,MAX.BUF.LEN,CHUNK.SIZE);
				END;			/*	RESTORE DISK POINTERS FOR LATER DISK TIMBRE READ	*/
				I=S.I;		/*	RESET MEMORY POINTERS	*/
				J=S.J;

				Q=0;			/*	COUNT # OF PARTIALS	*/
				DO WHILE (Q<NUM.TO.DO);	/*	MOVE EACH PARTIAL	*/
					IF BASE<>(-1) THEN DO; T=W.LOOKUP(I); END;
					ELSE					 DO; T=G.NEXT;		  END;
					IF (T=SUP)&(TIMBRE#=0) THEN DO;	/*	EXPAND TO FILL KEYBOARD	*/
						CALL P.STORE(J,0);			/*	SET UP POINTER, STORE FIRST 0	*/
						DO L=1 TO NUM.PARAMS-1; WRITE(MDI)=0; END;	/*	PROVIDE NULL TIMBRE	*/
						CALL P.STORE(J+36,4400); CALL P.STORE(J+43,1000);
						CALL P.STORE(J+12,1000);	/*	PROVIDE 440.0 & 1.000 TO SPEED UP FREQUENCY ROUTINE IF POSSIBLE, ALSO COEFF 0	*/
						J=J+NUM.PARAMS;
						I=I+1;							/*	ACCOUNT FOR 1 WORD READ	*/
					END;
					ELSE DO;		/*	COPY INFO	*/
						CALL P.STORE(J,T);			/*	STORE WORD IN MEMORY	*/
						J=J+1; I=I+1;					/*	ACCOUNT FOR IT	*/
					END;
					IF PLENS(Q)<>1 THEN DO;			/*	COPY REST OF SECTION IF MORE THAN 1 WORD TO COPY (THIS IS HOW MISC AREA GETS IN)	*/
						IF BASE=(-1) THEN DO;		/*	COPY FROM DISK	*/
							N=0;
							DO WHILE N<>(PLENS(Q)-1);	/*	COPY ON A WORD BY WORD BASIS	*/
								CALL P.STORE(J+N,G.NEXT);	/*	COPY OVER WORDS	*/
								N=N+1;
							END;
						END;
						ELSE DO;						/*	MEMORY TO MEMORY	*/
							CALL COPY.EXT.MEM(BASE,I,PAR.PTR,J,PLENS(Q)-1);
						END;							/*	MEMORY TO MEMORY	*/
						J=J+PLENS(Q)-1; I=I+PLENS(Q)-1;
					END;			/*	COPY INFO	*/
					Q=Q+1;
				END;				/*	OF LOOP OVER PARTIALS	*/
			END;					/*	OF NEW.LENGTH=OLD.LENGTH (OK TO COPY)	*/

			ELSE LENGTH.OVERFLOW=1;		/*	SET LENGTH OVERFLOW IF DID NOT COPY IN	*/

		END;	/*	OF BEGIN TO COPY THIS GROUP	*/

		K=K+NUM.TO.DO;	/*	MOVE ON TO NEXT PARTIAL	*/

	END;	/*	OF PARTIAL LOOP	*/

	CALL SETUP.NEW.TIMBRE(TIMBRE#);

END MOVE.TIMBRE.TO;


/*	COPY.KBD.TIMBRES - FOR COPYING TO KEYBOARD TIMBRES ONLY	*/

/*	I.E. - COPY.KBD.TIMBRES(X,0)
	OR		 COPY.KBD.TIMBRES(X,1)	*/

COPY.KBD.TIMBRES:PROC(SOU,DES) PUBLIC SWAPABLE;
	DCL (SOU,DES)	FIXED;

	IF (RECD)&(RECD.TRK<>0) THEN DO;
		CALL STOP.RECORD;	/*	STOP RECORDING ON TIMBRE RECALL	*/
		CALL DISPLAY.SEQUENCER.STATUS;
	END;

	CALL MOVE.TIMBRE.TO(PAR.PTR,FIND.TIMBRE(PAR.PTR,SOU),DES);	/*	LOOK UP POINTER, THEN PASS IT	*/

	/*	NEED TO COPY TRACK VOL, MIDI ROUTING, AND TRACK ROUTING TO KBD TRK HEAD	*/

END COPY.KBD.TIMBRES;

ERASE.TIMBRE:PROC(TIM.NUM) PUBLIC SWAPABLE;	/*	ERASE TIMBRE FROM TIMBRE LIST	*/
	DCL (TIM.NUM)	FIXED;		/*	ABS TIM NUMBER, 0 - (PAR.NUMT-1)	*/

	DISPLAY.EBL=0;					/*	SUPPRESS DISPLAYS DURING THIS COPY	*/
	CALL MOVE.TIMBRE.TO(NUL.PTR,0,TIM.NUM);
	DISPLAY.EBL=1;					/*	ALLOW DISPLAYS NOW		*/

END ERASE.TIMBRE;

ERASE.KEYBOARD.TIMBRE: proc public swapable;	/*	puts null timbre in TIMBRE #0	*/
	display.ebl=0;				/*	supress window displays duing this copy	*/
	IF (RECD)&(RECD.TRK<>0) THEN DO;
		CALL STOP.RECORD;		/*	STOP RECORDING ON TIMBRE RECALL	*/
		CALL DISPLAY.SEQUENCER.STATUS;
	END;
	call ERASE.TIMBRE(0);
end ERASE.KEYBOARD.TIMBRE;
