/*	:SYNRSOU:08-INIT:600-INIT  $SUBTITLE  INITIALIZATION CODE	*/

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
1999/04/11 - TY  - Added new defaults to "INIT.DEFAULTS".
1999/01/11 - TY  - Added diagnostic output which won't be compiled unless the literal "diagnostic" is set to 'true'.
1999/01/07 - TY  - Modified "INIT.EXPAND.SYSTEM" so that if all tries result in errors, we assume that the voices are
						 not connected and write the nulled array to .SINF-7 accordingly.  Previously the "errors" prevented
						 ANY information from being written to .SINF-7 so the hardware was interrogated with every run.
					  - Commented out a dormant block of code in "INIT.INFOFILE".
1991/11/15 - PF  - Added XFER.PTR
1991/11/04 - PF  - Added 'Quick Update' feature
1991/04/23 - PF  - Made MIDI.TRACK.RTES size of MAX.TRACKS
						 some routines were writing beyond range allocated
1991/02/28 - MWH - Add AEE's 20 saved mark points to the protocol
1991/02/07 - MWH - Combine 3200, 6400 and 9600 RTP's
1990/10/11 - PF  - Modify MAP.KYBD.DISP to handle new TRACK.FORMAT beats mode
1990/08/27 - PF  - Support all MIDI controllers
1990/07/16 - cj  - cj fixed bug in 5/06/90 multi-channel "fix"
1990/05/06 - cj  - inserted delays to fix "new" multi-channel problem
1990/05/02 - cj  - added "pull-down" smpte code (init empty sequence)
1990/03/21 - PF  - Compressed CLAV.PTR to 43 sectors
1990/03/09 - PF  - Increase MAX.INPUTS to 128
1989/09/01 - MWH - Count the number of FM voices
1989/07/07 - TSS - Allocate PMAP.PTR area, Changed TTMAP.PTR length
1989/07/07 - TSS - ALLOCATE TTMAP.PTR & VMAP.PTR IN KEYBOARD.CHECK ROUTINE,
						 and added defs for .SMAP-7 file, ETC.
1989/06/26 - PF  - Allocate space for SYSEX.PACKET
1989/06/20 - MWH - Add sector to save sequence scrubbing packet
1989/03/20 - TSS - added MIDI defaults
1989/03/14 - PF  - Allocate Xmem for PACKET.BAS.PTR
1989/01/27 - MWH - Add SECT.PTR
1989/01/05 - SGS - Added SMPTE Display Offset default
1989/01/05 - MWH - Merge in updates to Karim's downloading code
1989/01/05 - MWH - Allocate space for Packet.Ptr
1988/12/12 - TSS - Fixed startup bug in defaults initialization
1988/12/02 - SGS - Fixed bug in Init.Synths
1988/11/16 - TSS - MOVE DEFAULTS INFO INTO SEPARATE FILE .SDEF-7
1988/10/17 - MWH - Add RS422 driver, some code taken from:
						 "PROGRAM TO DOWNLOAD BINARIES TO D115D 68K BOARD
						 BY:  KARIM J. CHICHAKLY ON 30 SEPTEMBER 1988"
1988/10/04 -cj,sgs-changed multi channel boot up code to try complement wave forms
1988/10/03 - TSS - FIXED BUG IN MULTI-CHANNEL BOOT COMPUTING MULTI.MAX & WRITING OUT DATA TO .SINF-7
1988/09/30 - SGS - FIXED BUG IN INIT.SYNTHS
1988/09/22 - TSS - MODIFIED CODE TO SUPPORT RUN-TIME VOICE DIAGNOSTICS ENABLING
1988/09/21 - TSS - Allocated external mem for BSTAT.PTR
1988/09/20 - PF  - CREATED MISC.PTR MAINLY FOR SENDING PROTOCOL PACKETS
1988/08/30 - MWH - Undo temp changes below (leave in but commented)
1988/07/29 - SGS - Created INIT.INFOFILE and INIT.DEFAULTS. Added defaults.
1988/07/22 - MWH - TEMP CODE TO BLOCK ANYONE FROM STEALING THE RTP
1988/05/17 - EEG - INIT SEQ.SMODE TO 1 (NON-DROP)
1988/04/13 - PF  - CREATED SYSEX.PTR
1988/04/13 - PF  - MOVED MIDI.ANALOG.IN, MIDI.SWITCHDATA, MIDI.KEY.PRESS TO HERE
1988/04/13 - PF  - EXTENDED CLAV.PTR TO INCLUDE KEYBOARD ARRAY PLUS 16 MIDI ARRAYS
1987/06/26 - MWH - Split FRP.PTR into FP0-FP3.PTR for expanded poly
1987/06/22 - MWH - Move multi.syn2 to external memory at MFM.PTR
1987/06/19 - MWH - Support multiple poly bins
1986/12/29 - cj  - mono sampling items
1986/12/15 -     - FIXED STOP.DATA/STEREO POSITION BUG
1986/10/07 - TS  - INIT SEQ.MARK.MSB, SEQ.MARK.LSB, SEQ.CRM=4
1986/09/25 - KJO - UPDATED FOR -7 CATALOG STRUCTURE
1986/09/15 -CJ,MB- USED FIRST.BASE FOR PSFIRST
1986/08/27 - KJC - fixed new D/A controller initialization bug
1986/08/26 -TS,AT- MODIFIED NEW.FORMAT.OVERLAY FOR MUSIC PRINTING
1986/08/20 - EEG - PUT INITMODS IN A BEGIN/END BLOCK
1986/08/11 - EEG - INSERTED SUBROUTINES EXTRACTED FROM THE INITALIZATION PROCEDURE TO SAVE SWAP SPACE
1986/05/15 -     - "official" creation of release-M modules
*/

BEGIN;		/*	PUT ALL OF INITMODS INSIDE A BEGIN/END BLOCK	*/
	DCL WHERE.FROM				FIXED;
	DCL INFOTHERE				FIXED PUBLIC;	/*	TRUE IF .SINF-7 FILE FOUND	*/
	DCL (INFODEV,INFOSEC)	FIXED PUBLIC;	/*	DISK PTRS TO THE FILE		*/

	DCL DEFS.THERE				FIXED PUBLIC;	/*	TRUE IF .SDEF-7 FILE FOUND	*/
	DCL (DEFDEV,DEFSEC)		FIXED PUBLIC;	/*	DISK PTRS TO THE FILE		*/
	DCL MAP.THERE				FIXED PUBLIC;	/*	TRUE IF .SMAP-7 FILE FOUND	*/
	DCL (MAPDEV,MAPSEC)		FIXED PUBLIC;	/*	DISK PTRS TO THE FILE		*/

	DCL RESET.POLY.HIST.FILE FIXED EXTERNAL;	/*	TRUE IF ON BOOTUP POLY IS EMPTY	*/
	DCL COPY.STRING PROC (ARRAY, ARRAY) EXTERNAL;

	//	DIAGNOSTIC LITERALS
	dcl diagnostic	lit 'false';
	dcl d_print		lit 'send';

/*	PROCEDURES USED BY INITIALIZATION - NO.MEMORY, OPENFILE, ALLOC.EXT	*/

NO.MEMORY:  PROC SWAPABLE;	/*	CALL THIS PROCEDURE IF BOMB-OUT FROM NOT ENOUGH MEMORY DURING INITIALIZATION	*/
	DCL I	FIXED;

	CALL CLEAR.TERM;

	CALL PS('Not enough external memory for this software');
	CALL TTY_WAIT;

	CORE(LOC.SYNSTAT)="400";	/*	SET STATUS OF 256 SO MUSIC PLOTTING OR CONVERSION PROGRAM WILL WAIT FOR USER TO HIT RETURN	*/
	I=CORE(LOC.SYNRET);			/*	LOOK UP RETURN POINTER - (MPLT OR CONV PGM)	*/
	CORE(LOC.SYNRET)=LOC.P2;	/*	TELL HIM WE CAME FROM RTP (VS PLT)	*/
	CALL OVERLAY(CORE(I+1),CORE(I),CORE(I-1));	/*	RETURN TO EARLIER MODULE (CONV PGM, MUSIC PRTNG)	*/
END NO.MEMORY;

OPENFILE: PROC(NAME,LOC) SWAPABLE;	/*	OPEN A SYSTEM FILE	*/
	DCL NAME		FIXED ARRAY;
	DCL (LOC,I)	FIXED;

	I = FILE.SEARCH(NAME,3,-2,0,1);	/*	SEARCH PATH, SYSTEM AND CURRENT CATALOG FOR FILE	*/

	IF I=0 THEN DO;
		CALL DISPLAY.ERR(4);	/*	NOT FOUND	*/
		CORE(LOC+1) = 0;
		CORE(LOC  ) = 0;
		CORE(LOC-1) = 0;
	END;
	ELSE DO;	/*	FOUND	*/
		CORE(LOC+1) = F#MS_SECTOR;	/*	SET FILE PARAMETERS ASIDE	*/
		CORE(LOC  ) = F#LS_SECTOR;
		CORE(LOC-1) = F#WORDS;
	END;
END OPENFILE;

ALLOC.EXT:PROC(NUM) SWAPABLE;		/*	ALLOCATE & ZERO OUT EXTERNAL MEMORY	*/
	DCL (NUM,I)	FIXED;

	I=ALLOC.EXAMOUNT(NUM);			/*	ALLOCATE MEMORY OFF OF EXAMOUNT		*/

	IF I=0 THEN CALL NO.MEMORY;

	RETURN I;

END ALLOC.EXT;

/*	ALLOCATE AND ZERO OUT INTERNAL MEMORY STARTING	*/
/*	AT MEM.BOTTOM.  ABORT IF REACHES MEM.TOP		*/

DCL (MEM.TOP)		FIXED;
DCL (MEM.BOTTOM)	FIXED;

ALLOC.INT:PROC(NUM) SWAPABLE;		/*	ALLOCATE & ZERO OUT INTERNAL MEMORY	*/
	DCL (I,NUM)	FIXED;

	IF (MEM.BOTTOM IGT MEM.TOP)     THEN DO;	/*	OUT OF ROOM	*/
		CALL NO.MEMORY;
	END;

	IF (MEM.TOP-MEM.BOTTOM) ILT NUM THEN DO;	/*	OUT OF ROOM	*/
		CALL NO.MEMORY;
	END;

	I=0;
	DO WHILE I <> NUM;								/*	ZERO OUT		*/
		CORE(MEM.BOTTOM+I)=0;
		I=I+1;
	END;

	MEM.BOTTOM = MEM.BOTTOM+NUM;
	RETURN		 MEM.BOTTOM-NUM;

END ALLOC.INT;

/*	$PAGE - OTHER SUBROUTINES FOR INITIALIZATION	*/


ZERO.SECTOR.ZERO:PROC SWAPABLE;		/*	INITIALIZE SECTOR 0 OF XMEM	*/
	DCL (I)	FIXED;

	WRITE(MAM)=0;							/*	TO ALL ZEROES	*/
	DO I=0 TO 255;
		WRITE(MDI)=0;
	END;

END ZERO.SECTOR.ZERO;


INIT.BAS.PTR:PROC SWAPABLE;			/*	CREATE & INITIALIZE BASE SECTORS	*/
	DCL (I)	FIXED;

	BAS.PTR=1; BAS.LEN=2;
	WRITE(MAM)=BAS.PTR;
	DO I=0 TO 511;
		WRITE(MDI)=0;
	END;

	WRITE(MAM)=BAS.PTR;
	DO I=0 TO 11;							/*	SEQ.SCALE			*/
		WRITE(MDI)=WESTERN.SCALE(I);
	END;
	//	Next two are set by INIT.DEFAULTS now.
	//	WRITE(MDI)=1000;					/*	SEQ.SPEED TO 1.000	*/
	//	WRITE(MDI)=500;					/*	SEQ.CLICK TO   500	*/
	WRITE(MAL)=SEQ.CRM;
	WRITE(MDI)=4;							/*	SEQ.CRM   TO     4	*/

	WRITE(MAL)=MAGIC.NUMBER;
	WRITE(MD )=MAGIC#5;

	WRITE(MAL)=SEQ.OCTRATIO;
	WRITE(MD )=1000;

END INIT.BAS.PTR;


INIT.PAR.PTR:PROC SWAPABLE;
	DCL (I)	FIXED;

	PAR.PTR=BAS.PTR+BAS.LEN;
	PAR.LEN=1;

	WRITE(MAM)=PAR.PTR;
	DO I=0 TO LEN.ENTRY-1;				/*	PROVIDE KBD & SPLIT TIMBRES	*/
		WRITE(MDI)=0;
	END;
	DO I=0 TO NUM.PARTIALS+NUM.MISC.PARAMS-1;
		WRITE(MDI)=NULL.TIMBRE(I);
	END;
	PAR.NUMT=2;

END INIT.PAR.PTR;


INIT.NAH.PTR:PROC SWAPABLE;			/*	PROVIDE EMPTY NAH.PTR	*/
	DCL (I)	FIXED;

	NAH.PTR=PAR.PTR+PAR.LEN;
	NAH.LEN=1;

	WRITE(MAM)=NAH.PTR;
	DO I=0 TO 255;
		WRITE(MDI)=0;
	END;

END INIT.NAH.PTR;


INIT.OTHER.PTRS:PROC(PLACE) SWAPABLE;
	DCL PLACE	FIXED;

	BNK.PTR=PLACE; BNK.LEN=0;
	INF.PTR=PLACE; INF.LEN=0;
	TIM.PTR=PLACE; TIM.LEN=0;
	TRD.PTR=PLACE; TRD.LEN=0;
END INIT.OTHER.PTRS;

DCL (I,J,K,L)	FIXED;
DCL (MEDIA)		FIXED;

/*	THESE ARE SUBROUTINES CALLED FROM THE INITIALIZATION PROCEDURE	*/

OLD.FORMAT.OVERLAY: PROC SWAPABLE;

	/*	DEFINITIONS FOR ORIGINAL MISC AREA:	*/

	DCL NUM.OSEQ.MISC	LIT '256';	/*	LENGTH OF ORIGINAL MISC AREA		*/
	DCL     OSEQ.SLEN	LIT ' 80';	/*	LOCATION OF SEQ.TOP - *** MUST BE SEQ.POINTERS+NUM.TRACKS ***	*/
	DCL     OSEQ.PLEN	LIT ' 82';	/*	LENGTH OF PARAMETER AREA IN NEW FORMAT SEQUENCES	*/

	/*	GET OLD MISC AREA	*/
	/*	INTO MISC.BUF		*/

	DO I=0 TO NUM.OSEQ.MISC-1;			/*	COPY OLD MISC AREA INTO MISC.BUF FOR NOW	*/
		MISC.BUF(I)=CORE(BAS.PTR+I);
	END;

	IF WHERE.FROM=0 THEN DO;			/*	SEQUENCE EXISTS - SCRIPT, MP, CONV	*/

		/*	SEQUENCE EXISTS (SCRIPT, MP, CONV)	*/
		/*	COMPUTE SECTOR LENGTHS					*/

		IF   MISC.BUF(MAGIC.NUMBER) ILT MAGIC#4	/*	SET UP TIMBRE LENGTH IF EARLY SEQUENCE	*/
		THEN MISC.BUF(OSEQ.PLEN) = LEN.SEQ.TIMBS;	/*	SAVE LENGTH OF TIMBRES	*/

		PAR.LEN=SHR(MISC.BUF(OSEQ.PLEN)+255,8);	/*	LENGTH IN SECTORS	*/
		NAH.LEN=SHR(MISC.BUF(OSEQ.SLEN)-  1,8);	/*	LENGTH IN SECTORS	*/

		/*	STORE SEQUENCE IN EXT MEMORY	*/
		/*	AS HIGH AS POSSIBLE FOR			*/
		/*	CONVERSION							*/

		IF MEDIA=0 THEN DO;					/*	SEQUENCE SITS IN INTERNAL MEMORY NOW	*/
			IF EXAMOUNT ILT (PAR.LEN+NAH.LEN+10)
			THEN CALL NO.MEMORY;				/*	BASIC CHECK FOR ENOUGH EXT MEM			*/
			WRITE(MAM)=EXAMOUNT-NAH.LEN;
			CALL COPY.OUT(NAH.PTR,SHL(NAH.LEN,8));
			NAH.PTR	=EXAMOUNT-NAH.LEN;
			WRITE(MAM)=NAH.PTR-PAR.LEN;
			CALL COPY.OUT(PAR.PTR,SHL(PAR.LEN,8));	/*	COPY NOTES ONLY (NO MISC)		*/
			PAR.PTR	=NAH.PTR-PAR.LEN;
			MEDIA		=1;									/*	NOW IN EXT MEM		*/
			CORE(LOC.SYNTIMB)=PAR.PTR;					/*	RESTORE MEM PTRS	*/
			CORE(LOC.SYNSEQ )=NAH.PTR;
			CORE(LOC.SYNMED )=MEDIA;
		END;
		ELSE DO;									/*	IN XMEM - MOVE UP FOR CONVERSION			*/
			IF EXAMOUNT ILT (PAR.LEN+NAH.LEN+10)
			THEN CALL NO.MEMORY;				/*	BASIC CHECK FOR ENOUGH EXT MEM			*/
			CALL COPY.EXT.MEM.SEC(NAH.PTR,EXAMOUNT-NAH.LEN,NAH.LEN);
			NAH.PTR=EXAMOUNT-NAH.LEN;
			CALL COPY.EXT.MEM.SEC(PAR.PTR,NAH.PTR-PAR.LEN,PAR.LEN);
			PAR.PTR=NAH.PTR-PAR.LEN;
			CORE(LOC.SYNTIMB)=PAR.PTR;					/*	RESTORE MEM PTRS	*/
			CORE(LOC.SYNSEQ )=NAH.PTR;
		END;

		/*	PROVIDE EMPTY KEYBOARD TIMBRE	*/
		/*	AND INITIALIZE OTHER MEMORY	*/
		/*	SECTIONS								*/

		I=PAR.PTR;       J=PAR.LEN;		/*	SAVE THESE FOR NOW	*/

		CALL ZERO.SECTOR.ZERO;				/*	FILL SECTOR 0		*/
		CALL INIT.BAS.PTR;					/*	BASE PTR				*/
		CALL INIT.PAR.PTR;					/*	NULL KBD TIMBRES	*/
		CALL INIT.OTHER.PTRS(EXAMOUNT);	/*	OTHERS ARE HIGH	*/

		IF CONVERT.OLD.SEQUENCE(I,J,NAH.PTR,NAH.LEN)=0	/*	CONVERT TO NEW FORMAT	*/
		THEN CALL NO.MEMORY;

		/*	NOW MOVE BNK.PTR, INF.PTR, TIM.PTR	*/
		/*	AND TRD.PTR DOWN IN MEMORY FOR		*/
		/*	FOLLOWING CALLS TO ALLOC.EXT			*/

		BNK.PTR=NAH.PTR+NAH.LEN; BNK.LEN=0;
		CALL COPY.EXT.MEM.SEC(INF.PTR,BNK.PTR+BNK.LEN,INF.LEN);
		INF.PTR=BNK.PTR+BNK.LEN;
		TIM.PTR=INF.PTR+INF.LEN; TIM.LEN=0;
		TRD.PTR=TIM.PTR+TIM.LEN; TRD.LEN=0;

		IF NAH.LEN<>1							/*	IF ANY REAL NOTES		*/
		THEN SEQUENCER.CONTROL.REG=1;		/*	PRETEND MIDI START	*/

	END;

	/*	HANDLE OVERLAY FROM	*/
	/*	RESYNTH OR SFM		*/

	ELSE DO;								/*	NO SEQUENCE - SFM, RESYN	*/

		IF WHERE.FROM=2 THEN DO;		/*	CAME FROM SFM			*/
			CALL ZERO.SECTOR.ZERO;		/*	FILL SECTOR 0			*/
			CALL INIT.BAS.PTR;			/*	BASE PTR					*/
			CALL INIT.PAR.PTR;			/*	NULL KBD TIMBRES		*/
			CALL INIT.NAH.PTR;			/*	EMPTY NAH FOR NOW		*/
			CALL INIT.OTHER.PTRS(NAH.PTR+NAH.LEN);				/*	ALLOW ROOM FOR FOLLOWING CALLS TO ALLOC.EXT	*/
		END;

		ELSE DO;									/*	ANALYSIS PROGRAM			*/
			IF MEDIA=0 THEN DO;				/*	COPY RESYN TIMBRE OUT TO EXTERNAL MEMORY	*/
				CALL ZERO.SECTOR.ZERO;		/*	FILL SECTOR 0				*/
				CALL INIT.BAS.PTR;			/*	BASE PTR						*/
				WRITE(MAM)=BAS.PTR+BAS.LEN;
				CALL COPY.OUT(PAR.PTR,MEM.SIZ-PAR.PTR-512);	/*	COPY OUT ALL OF UPPER MEMORY HERE - TO COMPUTE TIMBRE LENGTH WOULD BE A PAIN	*/
				PAR.PTR=BAS.PTR+BAS.LEN;	/*	NOW TIMBRE					*/
				I=FIND.TIMBRE(PAR.PTR,1);	/*	GET LENGTH IN WRDS		*/
			END;
			ELSE DO;								/*	ALLREAY IN XMEM			*/
				I=FIND.TIMBRE(PAR.PTR,1);	/*	GET LENGTH IN WRDS		*/
				CALL COPY.EXT.MEM.SEC(PAR.PTR,3,SHR(I+255,8));	/*	MOVE RESYNTH TIMBRE TO SECTOR 3 OF EXTERNAL MEMORY	*/
				CALL ZERO.SECTOR.ZERO;		/*	FILL SECTOR 0				*/
				CALL INIT.BAS.PTR;			/*	BASE PTR						*/
				PAR.PTR=3;
			END;
			WRITE(MAM)=PAR.PTR+SHR(I,8);	/*	NOW STORE NULL SPLIT TIMB	*/
			WRITE(MAL)=I;
			DO J=0 TO NUM.PARTIALS+NUM.MISC.PARAMS-1;
				WRITE(MDI)=NULL.TIMBRE(J);
				I=I+1;
			END;
			PAR.LEN=SHR(I+255,8);
			PAR.NUMT=2;
			CALL INIT.NAH.PTR;							/*	EMPTY NAH FOR NOW	*/
			CALL INIT.OTHER.PTRS(NAH.PTR+NAH.LEN);	/*	ALLOW ROOM FOR FOLLOWING CALLS TO ALLOC.EXT	*/
		END;							/*	ELSE TIMBRE IN EXT MEMORY - CAN NOT BE SFM	*/
	END;

	IF NAH.LEN=1 THEN DO;		/*	HAVE AN EMPTY SEQUENCE		*/
		WRITE(MAM)=BAS.PTR;		/*	SET BEATS PER MEASURE TO 4	*/
		WRITE(MAL)=SEQ.SMODE;
		WRITE(MD )=4;				/*	SEQ.SMODE TO 4 (PULL DOWN)	*/
		WRITE(MAL)=SEQ.BPM;
		WRITE(MD )=4;
		WRITE(MAL)=SEQ.MARK.MSB;
		WRITE(MDI)=0;
		WRITE(MD )=0;
	END;
END OLD.FORMAT.OVERLAY;

NEW.FORMAT.OVERLAY: PROC SWAPABLE;

	BAS.PTR		=  PAR.PTR;		/*	THIS IS ACTUALLY BASE POINTER	*/


	WRITE(MAM)	=  BAS.PTR;		/*	INFO STORED HERE					*/
	WRITE(MAL)	=  SEQ.BAS+1;	/*	LOOK UP POINTER PAIRS			*/

	BAS.LEN		=  READ(MDI);

	PAR.PTR		=  BAS.PTR+READ(MDI);
	PAR.LEN		=  READ(MDI);

	NAH.PTR		=  BAS.PTR+READ(MDI);
	NAH.LEN		=  READ(MDI);

	INF.PTR		=  BAS.PTR+READ(MDI);
	INF.LEN		=  READ(MDI);

	IF BAS.PTR=0 THEN DO;		/*	BASE OF SEQ IS SITTING IN SECTOR 0	*/

		IF (EXAMOUNT ILT (INF.PTR+INF.LEN+1))
		THEN CALL NO.MEMORY;		/*	BASIC CHECK FOR ENOUGH EXT MEM		*/

		CALL COPY.EXT.MEM.SEC(0,1,INF.PTR+INF.LEN);	/*	MOVE IT UP TO SECTOR 1	*/

		BAS.PTR=        1;		/*	EVERYTHING HAS MOVED UP BY 1 SECTOR	*/
		PAR.PTR=PAR.PTR+1;
		NAH.PTR=NAH.PTR+1;
		INF.PTR=INF.PTR+1;
	END;


	/*	CHECK FOR ENOUGH MEMORY	*/

	IF (EXAMOUNT ILT (INF.PTR+INF.LEN+1))
	OR (BAS.LEN<>2)				/*	ONLY HANDLE THIS FORMAT	*/
	THEN CALL NO.MEMORY;			/*	BASIC CHECK FOR ENOUGH EXT MEM		*/

	CALL ZERO.SECTOR.ZERO;		/*	FILL SECTOR 0		*/
	CALL SHUFFLE.BAS.DOWN;		/*	MOVE BAS PTR TO 1	*/

	/*	PROVIDE EMPTY KEYBOARD TIMBRE	*/
	/*	AND INITIALIZE OTHER MEMORY	*/
	/*	SECTIONS								*/

	IF PAR.PTR=BAS.PTR+BAS.LEN			/*	IF SEQUENCE TIMBRES SITTING ABOVE BASE	*/
	THEN DO;									/*	THEN MUST PROVIDE ROOM FOR KEYBOARD TIMBRES	*/
		CALL COPY.EXT.MEM.SEC(PAR.PTR,PAR.PTR+1,INF.PTR+INF.LEN-PAR.PTR);
		PAR.PTR=PAR.PTR+1;
		NAH.PTR=NAH.PTR+1;
		INF.PTR=INF.PTR+1;
	END;

	WRITE(MAM)=BAS.PTR+BAS.LEN;		/*	PUT TIMBRE HERE					*/
	DO I=0 TO LEN.ENTRY-1;				/*	PROVIDE KBD & SPLIT TIMBRES	*/
		WRITE(MDI)=0;
	END;
	DO I=0 TO NUM.PARTIALS+NUM.MISC.PARAMS-1;
		WRITE(MDI)=NULL.TIMBRE(I);
	END;

	CALL COPY.EXT.MEM(PAR.PTR,0,			/*	COPY SEQUENCE TIMBRES	*/
							BAS.PTR+BAS.LEN,LEN.ENTRY+NUM.PARTIALS+NUM.MISC.PARAMS,
							SHL(PAR.LEN,8));	/*	ABOVE KEYBOARD TIMBRES	*/

	WRITE(MAM)	=  BAS.PTR;
	WRITE(MAL)	=  SEQ.NUMTIMBS;
	PAR.NUMT		=  READ(MD)+NUM.KBD.TRACKS;

	PAR.PTR=BAS.PTR+BAS.LEN;			/*	PARAMS NOW HERE	*/

	BNK.PTR=NAH.PTR+NAH.LEN; BNK.LEN=0;

	CALL COPY.EXT.MEM.SEC(INF.PTR,BNK.PTR+BNK.LEN,INF.LEN);
	INF.PTR=BNK.PTR+BNK.LEN;
	TIM.PTR=INF.PTR+INF.LEN; TIM.LEN=0;
	TRD.PTR=TIM.PTR+TIM.LEN; TRD.LEN=0;

	IF NAH.LEN<>1							/*	IF ANY REAL NOTES				*/
	THEN SEQUENCER.CONTROL.REG=1;		/*	PRETEND MIDI START			*/
	ELSE DO;									/*	OVERLAYING WITH EMPTY SEQ	*/
		WRITE(MAM)=BAS.PTR;				/*	SET BEATS PER MEASURE TO 4	*/
		WRITE(MAL)=SEQ.SMODE;
		WRITE(MD )=4;						/*	SEQ.SMODE TO 4 (PULL DOWN)	*/
		WRITE(MAL)=SEQ.BPM;
		WRITE(MD )=4;
	END;

END NEW.FORMAT.OVERLAY;

SETUP.EXTERNAL.ALLOCATIONS: PROC SWAPABLE;
	DCL REC(POLY.HIST.REC.LEN-1)	FIXED;

	/*	CERTAIN EXTERNAL MEMORY SECTIONS MUST EXIST FOR THE	*/
	/*	PROGRAM EVEN TO RUN.  THESE ARE ALLOCATED HERE.			*/

	/*	PROGRAM RETURNS IF THEY WOULD END UP ON TOP OF			*/
	/*	THE SEQUENCE SITTING IN EXTERNAL MEMORY					*/

	/*	FIRST WE ALLOCATE AND ZERO OUT THE STORAGE AREAS.		*/
	/*	THEN WE FILL THE TABLES, VELOCITY MAP, ETC.				*/

   if ((interp_real_time_prefs(0) & SYNCLAVIER_PREF_RECORD_SUSTAIN) != 0)
      MIDISUST.MODE = 1;

	TRK.HEAD	=ALLOC.EXT(1);				/*	ONE SECTOR FOR TRACK HEADS LOOK UP TABLE	*/

	I			=ALLOC.EXT(1);				/*	TRACK HEADER SECTOR FOR KEYBOARD		*/
	WRITE(MAM)=TRK.HEAD;					/*	IS ABSOLUTE POINTER ALREADY			*/
	WRITE(MD )=I;

	WRITE(MAM)=I;							/* Init keyboard rtes to default values.  Provides correct */
	WRITE(MAL)=THD.LIVE.RTES;			/* operation if keyboard is powered off or not connected	  */
	WRITE(MDI)=RTE.MAX;					/* or if running under PowerPC									  */

   if ((interp_real_time_prefs(0) & SYNCLAVIER_PREF_PEDAL2_MAX) != 0)
      write(mdi) = RTE.MAX;         // INIT PED2 TO RTE.MAX...
   else
      write(mdi) = SHL(RTE.MAX,8);  // ... OR TO 0

   WRITE(MDI)=SHL(RTE.MAX,8);
	WRITE(MDI)=SHL(RTE.MAX,8);

	TIM.HEAD	=ALLOC.EXT(1);				/*	ONE SECTOR FOR TIMBRE LOOK UP TABLE	*/

	I			=ALLOC.EXT(1);				/*	TIMBRE HEADER SECTOR FOR KEYBOARD	*/
	WRITE(MAM)=TIM.HEAD;
	WRITE(MD )=I;

	LTB.PTR		=ALLOC.EXT(4);				/*	LOG  TABLE	*/
	STB.PTR		=ALLOC.EXT(1);				/*	SINE TABLE	*/
	FRE.PTR		=ALLOC.EXT(8);				/*	FREQ TABLE	*/
	IF CORE(LOC.P3-1) IGT (13*256)		/*	WE HAVE THE NEW .STAB-7 FILE	*/
	THEN POLY.FRE.PTR=ALLOC.EXT(16);		/*	ALLOCATE SPACE FOR NEW POLY FREQ TABLE	*/
	ELSE POLY.FRE.PTR=FRE.PTR;				/*	ONLY HAVE OLD .STAB-7 -- MAKE SYSTEM USE OLD FREQ TABLE	*/

	/*	THESE 3 NEED TO BE SET UP BEFORE CALLING RESTORE.POWER,	*/
	/*	COMPUTE.SYNC.TTIME.MAP OR COMPUTE.MIDI.VELMAPS				*/

	TTMAP.PTR=ALLOC.EXT(1);					/*	TRANSIT TIME MAP		*/
	VMAP.PTR =ALLOC.EXT(2);					/*	MIDI VELOCITY MAPS	*/
	PMAP.PTR =ALLOC.EXT(3);					/*	PRESSURE CALIBRATION/MAP DATA	*/

	NUL.PTR	=ALLOC.EXT(1);					/*	NULL TIMBRE				*/

	KBD.PRE	=ALLOC.EXT(SHR(KBD.PRE.LEN+255,8));

	LOAD.PTR	=ALLOC.EXT(4);					/*	WILL HOLD LOADER		*/
   PBN.PTR	=ALLOC.EXT(2);					/*	BUTTON LOOK-UP			*/
   ORK.PTR	=ALLOC.EXT(2);					/*	BUTTON LOOK-UP			*/

	PACKET.BAS.PTR =ALLOC.EXT(SIZEOF.PACKET.BUF);	/*	ROTARY BUFFER FOR PROTOCOL PACKETS	*/
	PACKET.PTR		=PACKET.BAS.PTR;		/*	ROTARY BUFFER TAIL PTR	*/
	PACKET.FREE.PTR=PACKET.BAS.PTR;		/*	ROTARY BUFFER HEAD PTR	*/
	MISC.PTR	=ALLOC.EXT(1);					/*	FOR MISC USE (PROTOCOL PACKET OUTPUT?)	*/
	SECT.PTR	=ALLOC.EXT(1);					/*	BUFFER FOR SETBUF DURING D115 DOWNLOAD	*/
	LOCATE.STACK.PTR	=ALLOC.EXT(2);		/*	BUFFER FOR SAVED MARK POINTS	*/
	SCRUB.PTR =ALLOC.EXT(1);				/*	BUFFER TO SAVE START SCRUB PACKET IF DTD NOT READY	*/

	TBUT.PTR	 = ALLOC.EXT(1);				/*	TRACK BUTTON TABLE		*/
	BSTAT.PTR = ALLOC.EXT(1);				/*	TRACK BUTTON TABLE		*/

	CLAV.PTR	 = ALLOC.EXT(((MAX.INPUTS*NUM.KEYS)+255)/256);			/*	KEYBOARD BITS				*/

	MIDI.ANALOG.IN  = ALLOC.EXT (((MAX.INPUTS*8)+255)/256);			/*	MIDI CONTROLLER VALUES	*/

	MIDI.SWITCHDATA = ALLOC.EXT(((MAX.INPUTS*8)+255)/256);			/*	MIDI SWITCH VALUES		*/

	MIDI.KEY.PRESS  = ALLOC.EXT(((MAX.INPUTS*NUM.KEYS)+255)/256);	/*	INDIVIDUAL PRESSURE TABLE FOR 128 POSSIBLE INPUTS	*/

	SYSEX.BUF=ALLOC.EXT(16);				/*	SYSTEM EXCLUSIVE BUFFER - FOR INPUT		*/

	SYSEX.PACKET=ALLOC.EXT(1);				/*	SYSTEM EXCLUSIVE PACKET - FOR OUTPUT	*/

	MIDI.TRACK.RTES=ALLOC.EXT(MAX.TRACKS);	/*	A SECTOR FOR EACH POTENTIAL MIDI TRACK	*/

	USE.PTR	=ALLOC.EXT(1);					/*	USAGE COUNTERS			*/

	MPOLY.PTR =ALLOC.EXT(1);				/*	MULTICHAN-POLY MAP	*/

	MFM.PTR =ALLOC.EXT(1);					/*	MULTICHAN-FM MAP		*/

	IF INC.MONO<>0 THEN DO;			/*	SET UP FOR MONO BLOCK ALLOCATION				*/
      IF (EXAMOUNT IGT 12000) {  // SYNC3 - RESERVE 100 FIXED LENGTH 100-SECTOR ATTACK BUFFERS
			MSFREE=10000;					         /*	USE 10000 SECTORS	*/
			MSFIRST=EXAMOUNT-MSFREE;				/*	START LIST HERE		*/
			MSLAST=MSFIRST;							/*	ENDING BLOCK IS HERE	*/
			MSMAX=EXAMOUNT;							/*	MAX IS HERE				*/
			IF (MSFIRST ILT TRD.PTR) THEN DO;	/*	OUT OF ROOM				*/
				CALL NO.MEMORY;
			END;
			EXAMOUNT=MSFIRST;							/*	AND ONLY THIS MUCH IS NOW AVAIL FOR SYN2	*/
      }

		ELSE IF (NOT     MONO.LB)	/*	NOT COMPILING LARGE BUFFER MODEL				*/
		OR (EXAMOUNT ILT 316)		/*	OR LESS THAN 15,000 NOTES IN ANY EVENT!	*/
		THEN DO;							/*	USE NORMAL ALGORITHM								*/
			MSFREE=SHR(EXAMOUNT,1);					/*	USE HALF OF STORAGE FOR ATTACK BUFFERS	*/
			MSFIRST=EXAMOUNT-MSFREE;				/*	START LIST HERE		*/
			MSLAST=MSFIRST;							/*	ENDING BLOCK IS HERE	*/
			MSMAX=EXAMOUNT;							/*	MAX IS HERE				*/
			IF (MSFIRST ILT TRD.PTR) THEN DO;	/*	OUT OF ROOM				*/
				CALL NO.MEMORY;
			END;
			EXAMOUNT=MSFIRST;							/*	AND ONLY THIS MUCH IS NOW AVAIL FOR SYN2	*/
		END;
		ELSE DO;							/*	RESERVE MORE MEMORY FOR ATTACK BUFFERS	*/
			MSFREE=EXAMOUNT-158;						/*	RESERVE 158 FOR TRD + SEQUENCE	*/
			MSFIRST=EXAMOUNT-MSFREE;				/*	START LIST HERE		*/
			MSLAST=MSFIRST;							/*	ENDING BLOCK IS HERE	*/
			MSMAX=EXAMOUNT;							/*	MAX IS HERE				*/
			IF (MSFIRST ILT TRD.PTR) THEN DO;	/*	OUT OF ROOM				*/
				CALL NO.MEMORY;
			END;
			EXAMOUNT=MSFIRST;							/*	AND ONLY THIS MUCH IS NOW AVAIL FOR SYN2	*/
		END;
	END;

	IF (CUE.HIST.THERE) THEN DO;	/*	ALLOCATE BUFFERS FOR CUE AND POLY HISTORY FILES	*/
		CUE.HIST.BUF=ALLOC.EXT(CUE.HIST.SIZE);
	END;

	IF (POLY.HIST.THERE) THEN DO;
		POLY.HIST.BUF=ALLOC.EXT(POLY.HIST.SIZE);
		IF (RESET.POLY.HIST.FILE = 1)
		THEN DO;
			CALL BUILD.POLY.HIST.RESET.REC(REC);
			CALL ADD.POLY.TO.HIST(REC);
		END;
	END;

   // Allocate blocks for poly & FM shadow registers
   FM.VOL.SHADOW        = ALLOC.EXT(1);
   POLY.PSRDVOL.SHADOW  = ALLOC.EXT(1);

	XFER.PTR	     = ALLOC.EXT(20);
	LCAP.PTR	     = ALLOC.EXT( 1);
	PCACHE.PTR    = ALLOC.EXT( 4);
   TBANKNAME.PTR = ALLOC.EXT( 1);
   SPACENAME.PTR = ALLOC.EXT( 1);

	// Allocate area for OMS MIDI Buffer
	OMSMIDI.PTR   = ALLOC.EXT( 2);

	/*	AFTER ALLOCATING FIXED AREAS,	*/
	/*	MOVE TRD.PTR UP TO ALLOW THE	*/
	/*	SEQUENCE TO GROW					*/

	TRD.PTR = EXAMOUNT;						/*	NOW MOVE UP IN MEMORY	*/

	/*	ALLOCATE INITIAL TRD AREA		*/

	IF GET.TRD.STORAGE(34)=0
	THEN CALL NO.MEMORY;						/*	UNTIL CODE GETS SMARTER	*/

	CALL SHUFFLE.BNK.UP;						/*	NOW BANK & INFO GO UP	*/
END SETUP.EXTERNAL.ALLOCATIONS;

INIT.INFOFILE: PROC SWAPABLE;
	DCL (I,ZERO,DEV,SEC)	FIXED;
	DCL THE_NAME (4)		FIXED;

	INSERT ':SYNAUXS:AUDAUXS:ADEFLITS';		/*	FOR AEE# LITERALS	*/

	COPY.STRING(InfoFileName, THE_NAME);	/*	TO ALLOW INFOFILE TO STAY IN EXT MEMORY	*/

	I = FILE.SEARCH(THE_NAME,2,-2,0,0);		/*	SEARCH PATH AND SYSTEM CATALOGS FOR FILE	*/

	IF  (I<>0)										/*	FOUND						*/
	AND (F#LS_LENGTH IGE 4)
	AND (F#MS_LENGTH =	0)
	THEN DO;											/*	INFO FILE IS THERE	*/
		INFOTHERE = 1;
		INFODEV = F#MS_SECTOR;					/*	SET FILE PARAMETERS ASIDE	*/
		INFOSEC = F#LS_SECTOR;
	END;

	I = FILE.SEARCH(DEFSFILE,3,-2,0,1);		/*	SEARCH PATH, SYSTEM, & USER CATALOGS FOR FILE	*/

	IF  (I<>0)										/*	FOUND	*/
	AND (F#LS_LENGTH IGE 32)
	AND (F#MS_LENGTH =	 0)
	THEN DO;											/*	DEFAULTS FILE IS THERE	*/

		DEFS.THERE = 1;
		DEFDEV = F#MS_SECTOR;					/*	SET FILE PARAMETERS ASIDE	*/
		DEFSEC = F#LS_SECTOR;

		//	The following block is redundant since we won't get here if (F#MS_LENGTH != 0) -TY 1999/01/02
		/*
		IF F#MS_LENGTH <> 0 THEN DO;
			F#MS_LENGTH = 0; F#LS_LENGTH = 32;
		END;
		*/

		F#LS_SECTOR = F#LS_SECTOR + 1;
		IF F#LS_SECTOR = 0
		THEN F#MS_SECTOR = F#MS_SECTOR + 1;

		CALL READDATA(F#MS_SECTOR,F#LS_SECTOR,MISC.BUF,256);

		IF MISC.BUF(AEE#DEFSINIT) IGT 1 THEN ZERO = 1;	/*	ILLEGAL VALUE	*/

		I = INFO#SECTORS.USED;	/*	START WITH FIRST UNUSED SECTOR	*/

		DO WHILE (I ILT F#LS_LENGTH)	/*	CHECK SUPPOSEDLY UNUSED SECTORS	*/
		AND      (ZERO = 0);
			DEV = DEFDEV; SEC = DEFSEC;
			SEC = SEC + I;
			IF SEC ILT I THEN DEV = DEV + 1;

			CALL READDATA(DEV,SEC,MISC.BUF,256);

			DO SEC = 0 TO 255;
				IF MISC.BUF(SEC)<>0	/*	UNUSED WORDS SHOULD BE ALL ZEROES	*/
				THEN ZERO = TRUE;		/*	IF NOT ASSUME FILE IS TRASH			*/
			END;
			I = I + 1;
		END;

		IF ZERO <> 0 THEN DO;				/*	ZERO OUT THE FILE			*/
			DO I = 0 TO 255; MISC.BUF(I) = 0; END;

			I = 0;
			DO WHILE I ILT F#LS_LENGTH;	/*	WRITE SECTORS OF ZEROS	*/
				DEV = DEFDEV; SEC = DEFSEC;
				SEC = SEC + I;
				IF SEC ILT I THEN DEV = DEV + 1;

				CALL WRITEDATA(DEV,SEC,MISC.BUF,256);

				I = I + 1;
			END;
		END;
	END;

END INIT.INFOFILE;

/*	INITIALIZE CERTAIN VARIABLES TO VALUES SAVED IN DEFAULTS FILE	*/

INIT.DEFAULTS: PROC SWAPABLE;
	DCL DEF.BUF(255)	FIXED;
	DCL (DEV, SEC)		FIXED;

	DCL MAP.KYBD.DISP	DATA (2,0,1,3,3,2);	//	MAPS AEE.TIME.FORMAT TO VK TRACK.FORMAT
		//	0: Seconds			->	2: SECONDS
		//	1: Beats				->	0: BEATS
		//	2: Meas:Beats		->	1: MEASURES/BEATS
		//	3: SMPTE				->	3: SMPTE
		//	4: Feet:Frames		->	3: SMPTE
		//	5: Mins:Seconds	->	2: SECONDS
	DCL MAP.SEQ.EDIT	DATA (0,2,3,4,5,1);	//	MAPS AEE.TIME.FORMAT TO S-PAGE/G-PAGE SAV.TIME.FORMAT
		//	0: Seconds			->	0: seconds
		//	1: Beats				->	2: beats
		//	2: Meas:Beats		->	3: measures/beats
		//	3: SMPTE				->	4: smpte
		//	4: Feet:Frames		->	5: feet:frames
		//	5: Mins:Seconds	->	1: min:sec

	DCL tmp				lit	'DEV';

	DCL S$FMODE			FIXED EXTERNAL;
	DCL S$FOFFSET		ARRAY EXTERNAL;
	DCL PID				PROC (FIXED, FIXED) EXTERNAL;

	INSERT ':SYNAUXS:AUDAUXS:ADEFLITS';	/*	FOR AEE# LITERALS	*/
	INSERT ':SYNAUXS:GIDLITS';				/*	FOR STATIC GID/PID VARIABLES	*/

	DEV = DEFDEV; SEC = DEFSEC;
	SEC = SEC + INFO#AEEDEFAULTS;
	IF SEC ILT INFO#AEEDEFAULTS THEN DEV = DEV + 1;

	IF DEFS.THERE<>0							/*	DEFAULTS FILE THERE	*/
	THEN CALL READDATA(DEV,SEC,DEF.BUF,256);
	/*	ELSE DEF.BUF WILL BE ALL ZEROES	*/

	IF DEF.BUF(AEE#DEFSINIT)=0 THEN DO;	/*	INITIALIZE DEFAULTS	*/
		DEF.BUF(AEE#SMPTEIN)			= 0;	/*	DROP FRAME				*/
		DEF.BUF(AEE#SMPTEDISP)		= 0;	/*	DROP FRAME				*/
		DEF.BUF(AEE#SMPTEOFFS)		= 0;	/*	00:00:00:00.00			*/
		DEF.BUF(AEE#SMPTEOFFS+1)	= 0;
		DEF.BUF(AEE#SMPTEOFFS+2)	= 0;
		DEF.BUF(AEE#SMPTEOFFS+3)	= 0;
		DEF.BUF(AEE#SMPTEOFFS+4)	= 0;
		DEF.BUF(AEE#SMPTEDSPOFFS)	= 0;	/*	00:00:00:00.00			*/
		DEF.BUF(AEE#SMPTEDSPOFFS+1)= 0;
		DEF.BUF(AEE#FOOTDISP)		= 2;	/*	35MM, 24 FPS			*/
		DEF.BUF(AEE#FOOTOFFS)		= 0;	/*	00:00.00					*/
		DEF.BUF(AEE#FOOTOFFS+1)		= 0;
		DEF.BUF(AEE#FOOTOFFS+2)		= 0;
		DEF.BUF(AEE#DISPFORMAT)		= -1;	//	Indicate not explicitly set
		DEF.BUF(AEE#RECORDMODE)		= 0;	/*	MODE: ALLOCATE			*/
		DEF.BUF(AEE#RECORDMODE+1)	= 0;	/*	TRIG: MANUAL			*/
		DEF.BUF(AEE#RECORDMODE+2)	= 0;	/*	REC:  SINGLE			*/
		DEF.BUF(MIDI#InputChan)		= -1;	/*	MIDI Input OMNI On	*/
		DEF.BUF(MIDI#EchoDisable)	= 1;	/*	MIDI Echo Enabled		*/ // CHanged to default to echo disable CJ 2007-08-08
	END;

	if (Def.Buf(Misc#DefsInit) == 0)
	{	//	.SDEF-7 files from before release 4.20 won't contain these defaults
		Def.Buf(Misc#KbdRouting)		= shl(64|(1-1),8)|(64|(2-1));	//	Use L=1, R=2 for default Keyboard Multichannel Routing
		Def.Buf(Misc#ClickOn)			= true;				//	Use On for default On/Off status of the click
		Def.Buf(Misc#ClickDispMode)	= 0;					//	Use BPM for default Click Display Mode
		Def.Buf(Misc#ClickRate)			= 500;				//	Use 500 ms/beat (120 BPM) for default Click Rate
		Def.Buf(Misc#Speed)				= 1000;				//	Use 1.000 for default Sequence Speed
		Def.Buf(Misc#ActiveMIDIRTEs)	= "100000"|B.MWHEEL|B.PWHEEL|B.VELOCITY;	//	Default MIDI RTEs used for null timbre
		Def.Buf(Misc#VelocitySens)		= shl(100,4)|3;	//	Use Sensitivity=100, Response=3
		Def.Buf(Misc#FinalDecay)		= 100;				//	Use 100 milliseconds for default Final Decay for loading sound files
	}

	/*	IF NO SEQUENCE, SET SMPTE IN MODE, OFFSET, DISPLAY OFFSET,	*/
	/*	AND FOOTAGE MODE AND OFFSET											*/
	IF NAH.LEN=1 THEN DO;
		WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.SMODE;
		WRITE(MD) =DEF.BUF(AEE#SMPTEIN);

		//	WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.SMBITS;
		WRITE(MDI)=DEF.BUF(AEE#SMPTEOFFS+4);
		WRITE(MDI)=DEF.BUF(AEE#SMPTEOFFS+3)\SHL(DEF.BUF(AEE#SMPTEOFFS+2), 8);
		WRITE(MD )=DEF.BUF(AEE#SMPTEOFFS+1)\SHL(DEF.BUF(AEE#SMPTEOFFS  ), 8);

		//	WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.DOFFSET;
		WRITE(MDI)=DEF.BUF(AEE#SMPTEDSPOFFS);
		WRITE(MDI)=DEF.BUF(AEE#SMPTEDSPOFFS+1);

		/*	THIS VAR IS CURRENTLY NOT ACTIVE (AND THEREFORE NOT PUBLIC)	*/
		/*	SYNC.SMPTE.DISP.MODE = DEF.BUF(AEE#SMPTEDISP);					*/

		/*	SET FOOTAGE DISPLAY MODE AND FOOTAGE OFFSET						*/
		//	WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.FMODE;
		WRITE(MD )=DEF.BUF(AEE#FOOTDISP);

		//	WRITE(MAM)=BAS.PTR;
		WRITE(MAL)=SEQ.FOFFSET;
		WRITE(MDI)=DEF.BUF(AEE#FOOTOFFS);
		WRITE(MDI)=DEF.BUF(AEE#FOOTOFFS+1);
		WRITE(MD )=DEF.BUF(AEE#FOOTOFFS+2);

		write(mal) = SEQ.SPEED;
		write(mdi) = Def.Buf(Misc#Speed);		//	Set default Sequence Speed
		write(md ) = Def.Buf(Misc#ClickRate);	//	Set default Click Rate
	END;

	/*	SET TIME DISPLAY FORMATS (AEE, SEQUENCE EDITOR/G-PAGE, AND KEYBOARD)	*/
	tmp = DEF.BUF(AEE#DISPFORMAT);
	PID(SAVED.AEE.TIME.FORMAT, tmp);				//	set default Q-page time display format (or indicate not explicitly set)

	if (tmp < 0)
	{
		PID(SAV.TIME.MODE, -1);						//	indicate S-page/G-page time display format not explicitly set
		TRACK.FORMAT	= 0;							//	default VK time display format to BEATS
	}
	else
	{
		PID(SAV.TIME.MODE, MAP.SEQ.EDIT(tmp));	//	set default S-page/G-page time display format
		TRACK.FORMAT	= MAP.KYBD.DISP(tmp);	//	set default VK time display format
	}

	/*	SET RECORD MODES IN AUDIO EVENT EDITOR SCREEN	*/
	CALL PID(RECORD.MODE.SWITCH.SETTING,	DEF.BUF(AEE#RECORDMODE));
	CALL PID(RECORD.TRIGGER.SWITCH.SETTING,DEF.BUF(AEE#RECORDMODE+1));
	CALL PID(RECORD.REC.SWITCH.SETTING,		DEF.BUF(AEE#RECORDMODE+2));

	MIDI.Input.Chan	 = DEF.BUF(MIDI#InputChan);
	MIDI.Echo.Disabled = DEF.BUF(MIDI#EchoDisable);

	//	Set default Keyboard Multichannel Routing
	IF (INC.MULT != false) {
		IF ((MULTI.THERE != false) && (MULTI.MAX != 0)) {
			WRITE(MAM) = TRK.HEAD;	//	Point to keyboard's multichannel routing
			WRITE(MAM) = READ(MD);
			WRITE(MAL) = THD.TROU;
			WRITE(MD ) = DEF.BUF(Misc#KbdRouting);
		}
	}
	//	Set global variables
	ClickOn						 = Def.Buf(Misc#ClickOn);				//	Set default On/Off status of the click
	Click.Disp.Mode			 = Def.Buf(Misc#ClickDispMode);		//	Set default Click Display Mode

	//	Set static defaults in the PID/GID area
	PID(Default.Click.Rate,		Def.Buf(Misc#ClickRate));			//	Default Click Rate				(for null sequence)
	PID(Default.Speed,			Def.Buf(Misc#Speed));				//	Default Speed						(for null sequence)

	PID(Default.MIDI.RTEs,		Def.Buf(Misc#ActiveMIDIRTEs));	//	Default MIDI RTEs					(for null timbre)

	write("313")				 = Def.Buf(Misc#VelocitySens);
	PID(Default.VelocitySens,	read("313"));							//	Default Velocity Sensitivity	(for null timbre)
	V.S.MIN = shr(read("313"),4);
	V.S.CON = read("313") & 0xF;

	PID(Default.FDecay,			Def.Buf(Misc#FinalDecay));			//	Default Final Decay				(for loading sound files)

END INIT.DEFAULTS;

/*	SET UP CUE AND POLY HISTORY FILES	*/

INIT.CUE.HIST.FILE: PROC SWAPABLE;
	DCL I	FIXED;
	DCL THE_NAME(5)	FIXED;

	COPY.STRING(CueFileName, THE_NAME);		/*	TO ALLOW INFOFILE TO STAY IN EXT MEMORY			*/

	I = FILE.SEARCH(THE_NAME,3,-2,0,1);		/*	SEARCH PATH, SYSTEM, & USER CATALOGS FOR FILE	*/

	IF  (I<>0) THEN DO;							/*	FOUND	*/
		CUE.HIST.SIZE = SHR(((CUE.HIST.REC.LEN * CUE.HIST.NUM.RECS) + CUE.HIST.HDR.LEN + 255),8);

		IF  (F#LS_LENGTH IGE CUE.HIST.SIZE)
		AND (F#MS_LENGTH =   0)
		THEN DO;
			CUE.HIST.THERE=1;
			CUEDEV=F#MS_SECTOR;					/*	SET FILE PARAMETERS ASIDE	*/
			CUESEC=F#LS_SECTOR;
		END;
	END;

END INIT.CUE.HIST.FILE;

INIT.POLY.HIST.FILE: PROC SWAPABLE;
	DCL I	FIXED;
	DCL THE_NAME(5)	FIXED;

	COPY.STRING(PolyFileName, THE_NAME);	/*	TO ALLOW INFOFILE TO STAY IN EXT MEMORY			*/

	I = FILE.SEARCH(THE_NAME,3,-2,0,1);		/*	SEARCH PATH, SYSTEM, & USER CATALOGS FOR FILE	*/

	IF  (I<>0) THEN DO;							/*	FOUND	*/
		POLY.HIST.SIZE = SHR(((POLY.HIST.REC.LEN * POLY.HIST.NUM.RECS) + POLY.HIST.HDR.LEN + 255),8);

		IF  (F#LS_LENGTH IGE POLY.HIST.SIZE)
		AND (F#MS_LENGTH =   0)
		THEN DO;
			POLY.HIST.THERE=1;
			POLYDEV=F#MS_SECTOR;
			POLYSEC=F#LS_SECTOR;
		END;
	END;

END INIT.POLY.HIST.FILE;

INIT.EXPAND.SYSTEM: PROC SWAPABLE;
	DCL (I,J,K,L,M,N)					FIXED;
	DCL (IVOICE,BIN,CHAN)			FIXED;
	DCL BASE (1)						FIXED;
	DCL RETRY							FIXED;
	DCL (THIS.TRY,THIS.ERROR)		FIXED;
	DCL (FM.TRIES,FM.ERRORS)		FIXED;
	DCL (POLY.TRIES,POLY.ERRORS)	FIXED;
	DCL WAVE.DIRECTION				FIXED;

	read_d33: proc returns (boolean);
		dcl xyz fixed;

		do xyz = 0 to 1;	//	read twice for better noise immunity
			if ((read(d33)&1) != 0)	return true;
		end;

		return false;
	end read_d33;

	interp_delay_on_d3_write(true);

	/*	INFOTHERE, INFODEV, AND INFOSEC SET IN INIT.INFOFILE	*/

	IF (READ("51")&2048)<>0 THEN DO;					/*	XPAND SYSTEM INCLUDED	*/
		WRITE(D32)="20";									/*	SELECT MULTI SUBSYS		*/
		DO J=0 TO 30; interp_usleep(1); END;
		IF (read_d33() != false) THEN BEGIN;		/*	MULTI SYSTEM INCLUDED	*/

			MULTI.THERE=1;									/*	INDICATE MULTI THERE		*/

			IF INFOTHERE THEN DO;						/*	FOUND	*/
				I = 1;										/*	ASSUME INFO WILL BE VALID	*/

				CALL READDATA(INFODEV,INFOSEC,MISC.BUF,256);

				IF  (MISC.BUF( 0)=POLY.MAGIC)			/*	CHECK MAGIC #	*/
				AND (MISC.BUF( 1)=POLY.REV)			/*	MAKE SURE		*/
				AND (MISC.BUF( 2)=LSYN1.START)		/*	HARDWARE INFO	*/
				AND (MISC.BUF( 3)=LSYN1.END)			/*	MATCHES			*/
				AND (MISC.BUF( 4)=LSYN2.START)
				AND (MISC.BUF( 5)=LSYN2.END)
				AND (MISC.BUF( 7)=(POLYNUMVS(0)\SHL(NOT(MONO_VOICES_PRESENT),8)))
				AND (MISC.BUF( 8)=POLYNUMVS(1))
				AND (MISC.BUF( 9)=POLYNUMVS(2))
				AND (MISC.BUF(10)=POLYNUMVS(3))
				THEN DO;
					DO J=11 TO 11+PSMAXBINS*2-1;			/*	CHECK FOR SAME AMOUNT OF POLY MEM IN EACH BIN	*/
						IF MISC.BUF(J) <> POLYAMOUNTS(J-11) THEN I=0;				/*	NOT THE SAME IN ONE BIN	*/
					END;
					IF I <> 0 THEN DO;						/*	SAVED DATA IS OK	*/
						MULTI.MAX=MISC.BUF(6);				/*	LOOK UP MAX	*/
						IF INFOSEC+1=0 THEN J=1; ELSE J=0;
						CALL EXT.READDATA(INFODEV+J,INFOSEC+1,MPOLY.PTR,0,1,0);	/*	READ MULTI->POLY MAP	*/
						IF INFOSEC+2 ILT INFOSEC THEN J=1; ELSE J=0;
						CALL EXT.READDATA(INFODEV+J,INFOSEC+2,MFM.PTR,0,1,0);		/*	READ MULTI->FM MAP	*/
					END;
				END;
				ELSE I=0;										/*	MUST RECHECK	*/
			END;

			/*	$PAGE - INTERROGATE MULTI HARDWARE	*/

			IF I=0 THEN DO;									/*	INTERROGATE HARDWARE	*/

				/*	Begin by initializing multi-channel hardware and waiting	*/
				/*	for all DC offsets to decay away.								*/

				/*	First turn on each input to output #7 and wait for DC		*/
				/*	offset to decay away.												*/

				/*	Note: turn only 1 voice on every 5 milliseconds to			*/
				/*	avoid a gigantic click by turning on all voices at			*/
				/*	machine speed.															*/

   			psr('Analyzing Multi-Channel Connections...');
				tty_wait();

				DISABLE;

				write(d32) = "21";				/*	select actual port			*/
				write(3) = 0; write(3) = 0;	/*	sync to d3 clock				*/
				do ivoice = 0 to 255;			/*	for every input voice		*/
					write(d33) = "040000" \ shl(7,8) \ ivoice;	/*	turn on	*/
					write(3) = 0;
					enable; interp_run_host_250(); disable;
				end;

				/*	Wait 500 milliseconds for DC offset to decay away.			*/
				do ivoice = 0 to 100;
					write(3) = 0;
					enable; interp_run_host_250(); disable;
				end;


				/*	Now turn off all the multi-channel assignments				*/
				do ivoice = 0 to 255;		/*	for every input voice			*/
					write(d33) = shl(7,8) \ ivoice;
					write(3) = 0;
					enable; interp_run_host_250(); disable;
				end;

				MULTI.MAX=100;									/*	FIND MIN # OF TRACKS	*/

				DO IVOICE=0 TO 127;							/*	SET UP VOICE # FOR SYN2 VOICES	*/
					enable; interp_run_host_250(); disable;

					WRITE(MAM) = MFM.PTR;					/*	INITIALIZE DATA	*/
					WRITE(MAL) = IVOICE;						/*	ARRAY TO NO			*/
					WRITE(MD)	= 0;							/*	ROUTING				*/

					IF INC.FM THEN DO;

						WRITE(CHA)=SHL(IVOICE,1);			/*	SELECT MOD  CHAN	*/
						IF READ(CHA) THEN DO;				/*	CHANNEL EXISTS		*/

							RETRY		= 0;						/*	CLEAR FLAG FOR POSSIBLE RETRY	*/

				RETRY.FM.ROUTING:

							THIS.TRY = 1; THIS.ERROR = 0;		/*	RESET COUNTERS			*/

							WRITE(FUN)=ISHC; WRITE(DAT)=0;	/*	FIRST - ALL LEFT		*/
							WRITE(CHA)=SHL(IVOICE,1)+1;		/*	SELECT USER CHAN		*/
							WRITE(FUN)=ELIM; WRITE(DAT)=255;	/*	SELECT MAX ENV LIM	*/
							WRITE(FUN)=ZMA;  WRITE(DAT)=0;	/*	ZERO MEM ADDR REG		*/
							WRITE(FUN)=TIM;  WRITE(DAT)=32;	/*	SELECT WAVE MEM # 0	*/
							WRITE(FUN)=MEM;						/*	GET READY TO LOAD WAVE DATA	*/
							IF WAVE.DIRECTION = 0
							THEN WRITE(DAT)=255;					/*	USE 255 FOR DATA		*/
							ELSE WRITE(DAT)=  1;					/*	USE 1   FOR DATA		*/

							/*	CREATE COMPLEMENTARY OUTPUT TO CANCEL SIGNAL	*/
							/*	FROM COMPOSITE OUTPUT								*/

							L=IVOICE XOR 1;						/*	COMPUTE ANOTHER CHAN	*/
							WRITE(CHA)=SHL(L,1);					/*	SELECT MOD  CHAN		*/
							WRITE(FUN)=ISHC; WRITE(DAT)=0;	/*	LIKEWISE - ALL LEFT	*/
							WRITE(CHA)=SHL(L,1)+1;				/*	SELECT USER CHAN		*/
							WRITE(FUN)=ELIM; WRITE(DAT)=255;	/*	SELECT MAX ENV LIM	*/
							WRITE(FUN)=ZMA;  WRITE(DAT)=0;	/*	ZERO MEM ADDR REG		*/
							WRITE(FUN)=TIM;  WRITE(DAT)=33;	/*	SELECT WAVE MEM # 1	*/
							WRITE(FUN)=MEM;						/*	GET READY TO LOAD WAVE DATA	*/
							IF WAVE.DIRECTION = 0
							THEN WRITE(DAT)=  1;					/*	USE 1   FOR DATA		*/
							ELSE WRITE(DAT)=255;					/*	USE 255 FOR DATA		*/

							/*	NOW TURN CHANNELS ON SMOOTHLY	*/

							WRITE(CHA)=SHL(IVOICE,1)+1;		/*	SELECT USER CHAN		*/
							WRITE(FUN)=VOL;  WRITE(DAT)=255;	/*	SELECT MAX VOL			*/
							WRITE(CHA)=SHL(L,1)+1;				/*	SELECT USER CHAN		*/
							WRITE(FUN)=VOL;  WRITE(DAT)=255;	/*	SELECT MAX VOL			*/

							WRITE(3)=0; WRITE(3)=0;				/*	WAIT FOR VOL TO REACH	*/

							WRITE(D32)="21";						/*	SELECT MULTI PORT			*/
							DO I=0 TO 63;							/*	TRY 64 POSSIBLE INPUTS	*/
								M = (SHL(I,2)\((IVOICE+1)&3));               /*	COMPUTE POSSIBLE INPUT #	*/
								WRITE(D33)="040000"\SHL(7,8)\M;              /*	MAP INPUT TO OT7		*/
								DO J=0 TO 30; interp_usleep(1); END;         /*	DELAY FOR SWITCH		*/
								IF (read_d33() != false) THEN DO;            /*	INPUT FOUND FOR THIS	*/
									WRITE(MAM) = MFM.PTR;                     /*	STORE IN EXT MEMORY	*/
									WRITE(MAL) = IVOICE;
									WRITE(MD) = (READ(MD)&255) \ SHL(M,8);    /*	LEFT VOICE IN UPPER	*/
									IF MULTI.MAX=100 THEN DO;                 /*	MEASURE FIRST TIME	*/
										K=8;                                   /*	AT LEAST 8 OUTPUTS	*/
										MORE.SYN2.TRACKS:
										WRITE(D33)="040000"\SHL(K+7,8)\M;      /*	MAP INPUT TO TR7		*/
										DO J=0 TO 30; interp_usleep(1); END;	/*	DELAY FOR SWITCH		*/
										IF (read_d33() != false) THEN DO;      /*	MORE TRACKS				*/
											K=K+8;
											IF K<64 THEN
											GOTO MORE.SYN2.TRACKS;	/*	COUNT UP TO REASON	*/
										END;
										MULTI.MAX=K;
									END;
										WRITE(D33)=M;					/*	DISCONNECT INPUT V	*/
									GOTO TRY.FM.RIGHT;
								END;
									WRITE(D33)=M;						/*	DISCONNECT INPUT V	*/
							END;

							THIS.ERROR = 1;

							/*	$PAGE - CHECK RIGHT CHANNEL MAPPING	*/

				TRY.FM.RIGHT:
							THIS.TRY = THIS.TRY + 1;
							WRITE(CHA)=SHL(IVOICE,1);				/*	SELECT MOD  CHAN			*/
							WRITE(FUN)=ISHC; WRITE(DAT)=252;		/*	NOW = ALL RIGHT			*/
							WRITE(CHA)=SHL(L,1);						/*	SELECT COMPL MOD CHAN	*/
							WRITE(FUN)=ISHC; WRITE(DAT)=252;		/*	ALSO ALL RIGHT				*/

							WRITE(3)=0; WRITE(3)=0; WRITE(3)=0;	/*	WAIT FOR VOL TO REACH	*/

							DO I=0 TO 63;								/*	TRY UP TO 64 POSSIBLE INPUT CHANNELS	*/
								M = (SHL(I,2)\((IVOICE+1)&3));				/*	COMPUTE POSSIBLE INPUT #		*/
								WRITE(D33)="040000"\SHL(7,8)\M;				/*	MAP INPUT TO TR7		*/
								DO J=0 TO 30; interp_usleep(1); END;      /*	DELAY FOR SWITCH		*/
								IF (read_d33() != false) THEN DO;			/*	INPUT FOUND FOR THIS	*/
									WRITE(MAM) = MFM.PTR;						/*	STORE IN EXT MEMORY	*/
									WRITE(MAL) = IVOICE;
									WRITE(MD) = (READ(MD)&"177400") \ M;	/*	RIGHT VOICE IN LOWER	*/
										WRITE(D33)=M;					/*	DISCONNECT INPUT V	*/
									GOTO CLEAN.SYN2;
								END;
									WRITE(D33)=M;						/*	DISCONNECT INPUT V	*/
							END;

							THIS.ERROR = THIS.ERROR + 1;

				CLEAN.SYN2:
							WRITE(CHA)=SHL(IVOICE,1)+1;		/*	SELECT USER CHAN			*/
							WRITE(FUN)=VOL;  WRITE(DAT)=0;	/*	SELECT 0 VOL				*/
							WRITE(CHA)=SHL(L,1)+1;				/*	SELECT USER CHAN			*/
							WRITE(FUN)=VOL;  WRITE(DAT)=0;	/*	SELECT 0 VOL				*/

							WRITE(3)=0; WRITE(3)=0; WRITE(3)=0;	/*	WAIT FOR VOL TO REACH	*/

							WRITE(CHA)=SHL(IVOICE,1);			/*	SELECT MOD  CHAN			*/
							WRITE(FUN)=ISHC; WRITE(DAT)=0;	/*	ZERO STEREO POS			*/
							WRITE(CHA)=SHL(IVOICE,1)+1;		/*	SELECT USER CHAN			*/
							WRITE(FUN)=ELIM; WRITE(DAT)=0;
							WRITE(FUN)=TIM;  WRITE(DAT)=0;

							WRITE(CHA)=SHL(L,1);					/*	SELECT COMPL MOD CHAN	*/
							WRITE(FUN)=ISHC; WRITE(DAT)=0;	/*	ZERO STEREO POS			*/
							WRITE(CHA)=SHL(L,1)+1;				/*	SELECT USER CHAN			*/
							WRITE(FUN)=ELIM; WRITE(DAT)=0;
							WRITE(FUN)=TIM;  WRITE(DAT)=0;

							WRITE(3)=0;								/*	WAIT FOR ENV LIM			*/

							/*	SEE IF NO INPUT FOR THIS VOICE COULD BE FOUND	*/

							IF THIS.ERROR <> 0 THEN DO;		/*	IF ERROR WITH THIS VOICE	*/
								IF RETRY = 0 THEN DO;			/*	THEN RETRY JUST ONCE			*/
									RETRY = 1;
									WAVE.DIRECTION = WAVE.DIRECTION XOR 1;
									GOTO RETRY.FM.ROUTING;
								END;
								FM.ERRORS = FM.ERRORS+THIS.ERROR;	/*	COUNT ERROR - NO INPUT VOICE FOR THIS CHANNEL	*/

                        CALL PS('FM error detected: Mod channel = ');
                        CALL PNUM(SHL(IVOICE,1), 0);
                        CALL PS(', User channel = ');
                        CALL PNUM(SHL(IVOICE,1)+1, 0);
                        call PCR;
                        do m = 0 to 100;
                           write(3) = 0;
                           enable; interp_run_host_250(); disable;
                        end;

								#if (diagnostic)
									d_print
									'FM error detected: Mod channel =',SHL(IVOICE,1),', User channel =',SHL(IVOICE,1)+1,
									', Compl mod channel =',SHL(L,1),', Compl user channel =',SHL(L,1)+1;
								#endif
							END;
							FM.TRIES = FM.TRIES+THIS.TRY;				/*	COUNT TRIES	*/
						END;			/*	OF CHAN EXISTS	*/
					END;				/*	IF INC.FM		*/
				END;					/*	OF CHAN LOOP	*/

				/*	$PAGE - CREATE POLY SYNTH MULTI OUT MAP	*/

				IF (INC.POLY) THEN DO;								/*	SEE IF ANY POLY BINS HAVE MEMORY	*/
					I=FALSE;
					DO BIN=0 TO PSMAXBINS-1;
						CALL SET.CUR.BIN(BIN);
						IF COM16(0,POLYAMOUNT) = LW#ILT			/*	ANY IN THIS BIN?			*/
						THEN I = TRUE;									/*	WE HAVE POLY MEMORY		*/
					END;

					IF (I<>FALSE)										/*	CONSTRUCT POLY MAP		*/
					THEN DO;												/*	ONLY IF MEMORY EXISTS	*/
						DO BIN=0 TO POLYNUMS-1;

							DO IVOICE=0 TO POLYNUMVS(BIN)-1;		/*	LOOP OVER POLY CHANS		*/

								CHAN = IVOICE + 64 * BIN;			/*	64 CHANNELS PER BIN		*/
								L	= CHAN XOR 1;						/*	COMPUTE ANOTHER CHAN		*/

								WRITE(MAM)	= MPOLY.PTR;			/*	STORE IN EXT MEMORY		*/
								WRITE(MAL)	= CHAN;					/*	IVOICE + 64 * BIN			*/
								WRITE(MD)	= 0;						/*	INITIALIZE TO 0			*/

								RETRY			= 0;						/*	CLEAR FLAG FOR POSSIBLE RETRY	*/

				RETRY.POLY.ROUTING:

								THIS.TRY = 1; THIS.ERROR = 0;		/*	RESET COUNTERS				*/

								BASE(LW#MSB) = SHL(BIN,14);		/*	BIN IN UPPER 2 MS BITS	*/
								CALL PSMWRITE(BASE,0,254);			/*	SET UP 1 WORD COMPL		*/
								IF WAVE.DIRECTION = 0 THEN DO;
										WRITE(PSD)=-32767;
										WRITE(PSD)=+32767;
								END;
								ELSE DO;
										WRITE(PSD)=+32767;
										WRITE(PSD)=-32767;
								END;

								DISABLE;	/*	AFTER PSMWRITE CALL!!	*/

								WRITE(PSC)= CHAN;						/*	SELECT CHANNEL			*/
								WRITE(PSF)= PSBA;						/*	SET UP BASE ADDRESS	*/
								WRITE(PSD)= 0; WRITE(PSD)=255;	/*	BASE ADDRESS OF 255	*/
								WRITE(PSF)= PSON;						/*	TURN CHANNEL ON		*/
								WRITE(PSD)= 3;							/*	TURN ON WITH LOOP		*/

								WRITE(PSC)= L;							/*	SELECT COMPL CHAN		*/
								WRITE(PSF)= PSBA;						/*	SET UP BASE ADDRESS	*/
								WRITE(PSD)= 0; WRITE(PSD)=254;	/*	BASE ADDRESS OF 254	*/
								WRITE(PSF)= PSON;						/*	TURN CHANNEL ON		*/
								WRITE(PSD)= 3;							/*	TURN ON WITH LOOP		*/

								/*	ONLY INTERROGATE LEFT CHANS IF USING POLY VOICES		*/
								/*	(LEFT CHANS DON'T EXIST IN MONO VOICES)					*/

								IF (NOT MONO_VOICES_PRESENT) THEN DO;
										WRITE(PSC)= CHAN;                      /*	SELECT CHANNEL			*/
										WRITE(PSF)= PSRCVOL;
										WRITE(PSD)= 0; WRITE(PSD)=4095;        /*	R,L CVOL					*/
										WRITE(PSD)= 0; WRITE(PSD)=4095;        /*	R,L DVOL					*/
										WRITE(PSF)= PSELIM;                    /*	SET UP FOR LIMIT, CVAL	*/
										WRITE(PSD)=4095;                       /*	LIMIT,			TO MAX	*/

										WRITE(PSC)= L;                         /*	SELECT COMPL CHAN		*/
										WRITE(PSF)= PSRCVOL;
										WRITE(PSD)= 0; WRITE(PSD)=4095;        /*	R,L CVOL					*/
										WRITE(PSD)= 0; WRITE(PSD)=4095;        /*	R,L DVOL					*/
										WRITE(PSF)= PSELIM;                    /*	SET UP FOR LIMIT, CVAL	*/
										WRITE(PSD)=4095;                       /*	LIMIT,			TO MAX	*/

										WRITE(3)=0;                            /*	WAIT FOR RAMP UP			*/

									WRITE(D32)="21";                         /*	SELECT MULTI PORT			*/

										// Optimized:
										DO I=0 TO 63;						/*	TRY 64 POSSIBLE INPUT CHANNELS	*/
											M = (SHL(I,2) \ (IVOICE&3));
											WRITE(D33)="040000"\SHL(7,8)\M;				/*	MAP INPUT TO TR7		*/
											DO J=0 TO 30; interp_usleep(1); END;      /*	DELAY FOR SWITCH		*/
											IF (read_d33() != false) THEN DO;			/*	INPUT FOUND FOR THIS	*/
												WRITE(MAM) = MPOLY.PTR;						/*	STORE IN EXT MEMORY	*/
												WRITE(MAL) = CHAN;							/*	IVOICE + 64 * BIN		*/
												WRITE(MD) = (READ(MD)&255) \ SHL(M,8);	/*	LEFT VOICE IN UPPER	*/

                                 #if (diagnostic)
                                    d_print 'Poly ',CHAN,' L Connected: ',I;
                                 #endif

												IF MULTI.MAX=100 THEN DO;					/*	MEASURE FIRST TIME	*/
													K=8;											/*	AT LEAST 8 OUTPUTS	*/
													MORE.POLY.TRACKS:
													WRITE(D33)="040000"\SHL(K+7,8)\M;	/*	MAP INPUT TO TR7	*/
													DO J=0 TO 30; interp_usleep(1); END;
													IF (read_d33() != false) THEN DO;	/*	MORE TRACKS			*/
														K=K+8;
														IF K<64 THEN
														GOTO MORE.POLY.TRACKS;	/*	COUNT UP TO REASON	*/
													END;
													MULTI.MAX=K;
												END;
												WRITE(D33)=M;						/*	DISCONNECT INPUT V	*/
												GOTO CLEAN.POLY.LEFT;
											END;
											WRITE(D33)=M;							/*	DISCONNECT INPUT V	*/
										END;

									THIS.ERROR = 1;

				CLEAN.POLY.LEFT:										/*	CLEAN UP FROM LEFT CHAN INTERROGATION	*/

										WRITE(PSC)= CHAN;					/*	SELECT CHANNEL				*/
										WRITE(PSF)= PSELIM;				/*	SET UP FOR LIMIT, CVAL	*/
										WRITE(PSD)=0;						/*	LIMIT,			TO 0		*/

										WRITE(PSC)= L;						/*	SELECT COMPL CHAN			*/
										WRITE(PSF)= PSELIM;				/*	SET UP FOR LIMIT, CVAL	*/
										WRITE(PSD)=0;						/*	LIMIT,			TO 0		*/

										WRITE(3)=0; WRITE(3)=0;			/*	WAIT FOR RAMP DOWN		*/

								END;	/*	OF NOT MONO (IE: STEREO) VOICES	*/

								/*	$PAGE - TRY POLY SYNTH RIGHT CHAN		*/

				TRY.POLY.RIGHT:	//	Nothing points here anymore.
								THIS.TRY = THIS.TRY + 1;

									WRITE(PSC)=CHAN;                       /*	SELECT CHANNEL				*/
									WRITE(PSF)= PSRCVOL;
									WRITE(PSD)= 4095; WRITE(PSD)=0;        /*	R,L CVOL						*/
									WRITE(PSD)= 4095; WRITE(PSD)=0;        /*	R,L DVOL						*/
									WRITE(PSF)= PSELIM;                    /*	SET UP FOR LIMIT, CVAL	*/
									WRITE(PSD)=4095;                       /*	LIMIT,			TO MAX	*/

									WRITE(PSC)=L;                          /*	SELECT COMPL CHAN			*/
									WRITE(PSF)= PSRCVOL;
									WRITE(PSD)= 4095; WRITE(PSD)=0;        /*	R,L CVOL						*/
									WRITE(PSD)= 4095; WRITE(PSD)=0;        /*	R,L DVOL						*/
									WRITE(PSF)= PSELIM;                    /*	SET UP FOR LIMIT, CVAL	*/
									WRITE(PSD)=4095;                       /*	LIMIT,			TO MAX	*/

									WRITE(3)=0;                            /*	WAIT FOR RAMP UP			*/

								WRITE(D32)="21";                       /*	SELECT MULTI PORT			*/

									// Optimized:
									DO I=0 TO 63;						/*	TRY 64 POSSIBLE INPUT CHANNELS	*/
										M = (SHL(I,2) \ (IVOICE&3));
										WRITE(D33)="040000"\SHL(7,8)\M;              /*	MAP INPUT TO TR7		*/
										DO J=0 TO 30; interp_usleep(1); END;			/*	DELAY FOR SWITCH		*/
										IF (read_d33() != false) THEN DO;            /*	INPUT FOUND FOR THIS	*/
											WRITE(MAM) = MPOLY.PTR;                   /*	STORE IN EXT MEMORY	*/
											WRITE(MAL) = CHAN;                        /*	IVOICE + 64 * BIN		*/
											WRITE(MD) = (READ(MD)&"177400") \ M;      /*	RIGHT VOICE IN LOWER	*/

                              #if (diagnostic)
                                 d_print 'Poly ',CHAN,' R Connected: ',I;
                              #endif

											IF MULTI.MAX=100 THEN DO;                 /*	MEASURE FIRST TIME	*/
												K=8;                                   /*	AT LEAST 8 OUTPUTS	*/
												MORE.POLY.TRACKS1:
												WRITE(D33)="040000"\SHL(K+7,8)\M;      /*	MAP INPUT TO TR7		*/
												DO J=0 TO 30; interp_usleep(1); END;	/*	DELAY FOR SWITCH		*/
												IF (read_d33() != false) THEN DO;      /*	MORE TRACKS				*/
													K=K+8;
													IF K<64 THEN
													GOTO MORE.POLY.TRACKS1;	/*	COUNT UP TO REASON		*/
												END;
												MULTI.MAX=K;
											END;
											WRITE(D33)=M;						/*	DISCONNECT INPUT V		*/
											GOTO CLEAN.POLY;
										END;
										WRITE(D33)=M;							/*	DISCONNECT INPUT V		*/
									END;

								THIS.ERROR = THIS.ERROR + 1;

								/*	$PAGE - CLEAN UP FROM POLY INTERROGATION	*/

				CLEAN.POLY:
									WRITE(PSC)= CHAN;						/*	SELECT CHANNEL				*/
									WRITE(PSF)= PSELIM;					/*	SET UP FOR LIMIT, CVAL	*/
									WRITE(PSD)=0;							/*	LIMIT,			TO 0		*/

									WRITE(PSC)= L;							/*	SELECT COMPL CHAN			*/
									WRITE(PSF)= PSELIM;					/*	SET UP FOR LIMIT, CVAL	*/
									WRITE(PSD)=0;							/*	LIMIT,			TO 0		*/

									WRITE(3)=0; WRITE(3)=0;				/*	WAIT FOR RAMP DOWN		*/

									WRITE(PSC)=CHAN;
									WRITE(PSF)= PSRCVOL;
									WRITE(PSD)= 0; WRITE(PSD)=0;		/*	R,L CVOL						*/
									WRITE(PSD)= 0; WRITE(PSD)=0;		/*	R,L DVOL						*/

									WRITE(PSC)=L;
									WRITE(PSF)= PSRCVOL;
									WRITE(PSD)= 0; WRITE(PSD)=0;		/*	R,L CVOL						*/
									WRITE(PSD)= 0; WRITE(PSD)=0;		/*	R,L DVOL						*/

									WRITE(PSC)=CHAN;
									WRITE(PSF)= PSON;
									WRITE(PSD)= 0;							/*	TURN OFF						*/

									WRITE(PSC)=L;
									WRITE(PSF)= PSON;
									WRITE(PSD)= 0;							/*	TURN OFF						*/

									WRITE(3)=0;								/*	WAIT FOR CHAN OFF			*/

								/*	SEE IF NO INPUT FOR THIS VOICE COULD BE FOUND	*/

								IF THIS.ERROR <> 0 THEN DO;	/*	IF ERROR WITH THIS VOICE	*/
									IF RETRY = 0 THEN DO;		/*	THEN RETRY JUST ONCE			*/
										RETRY = 1;
										WAVE.DIRECTION = WAVE.DIRECTION XOR 1;
										GOTO RETRY.POLY.ROUTING;
									END;

									POLY.ERRORS = POLY.ERRORS+THIS.ERROR;	/*	COUNT ERROR - NO INPUT VOICE FOR THIS CHANNEL	*/

                           CALL PS('Poly error detected: Channel = ');
                           CALL PNUM(CHAN, 0);
                           CALL PS(', Compl channel = ');
                           CALL PNUM(L, 0);
                           call PCR;
                           do m = 0 to 100;
                              write(3) = 0;
                              enable; interp_run_host_250(); disable;
                           end;

									#if (diagnostic)
										d_print 'Poly error detected: Channel =',CHAN,', Compl channel =',L;
									#endif
								END;
								POLY.TRIES = POLY.TRIES+THIS.TRY;			/*	COUNT TRIES		*/
							END;	/*	OF CHANNEL LOOP			*/
						END;		/*	OF LOOP OVER BINS			*/
					END;			/*	OF CONSTRUCT POLY MAP	*/
				END;				/*	OF INC.POLY					*/

				//	If each try resulted in error, then assume hardware is disconnected and disregard errors.
				#if (diagnostic)
					d_print 'FM.TRIES    =',FM.TRIES;
					d_print 'FM.ERRORS   =',FM.ERRORS;
					d_print 'POLY.TRIES  =',POLY.TRIES;
					d_print 'POLY.ERRORS =',POLY.ERRORS;
				#endif

				if FM.ERRORS	ieq FM.TRIES	then FM.ERRORS	= 0;
				if POLY.ERRORS	ieq POLY.TRIES	then POLY.ERRORS = 0;
				MULTI.ERRS = FM.ERRORS + POLY.ERRORS;

				/*	$PAGE - STORE MULTI INFO IN .SINF-7	*/

				IF MULTI.MAX=100 THEN DO;					/*	NO OUTPUTS FOUND	*/
					MULTI.THERE=0; MULTI.MAX=0;			/*	TREAT AS IF NOT	*/
				END;												/*	THERE					*/

				IF  (INFOTHERE<>0)							/*	INFO FILE FOUND	*/
				AND (MULTI.THERE<>0)							/*	OUTPUTS FOUND		*/
				AND (MULTI.ERRS=0)							/*	NO ERRORS			*/
				THEN DO;											/*	WRITE OUT INFO		*/
					MISC.BUF( 0)=POLY.MAGIC;
					MISC.BUF( 1)=POLY.REV;
					MISC.BUF( 2)=LSYN1.START;
					MISC.BUF( 3)=LSYN1.END;
					MISC.BUF( 4)=LSYN2.START;
					MISC.BUF( 5)=LSYN2.END;
					MISC.BUF( 6)=MULTI.MAX;
					MISC.BUF( 7)=(POLYNUMVS(0)\SHL(NOT(MONO_VOICES_PRESENT),8));
					MISC.BUF( 8)=POLYNUMVS(1);
					MISC.BUF( 9)=POLYNUMVS(2);
					MISC.BUF(10)=POLYNUMVS(3);
					DO I=11 TO 127;
						IF I-11 < PSMAXBINS*2-1
						THEN MISC.BUF(I) = POLYAMOUNTS(I-11);
						ELSE MISC.BUF(I) = 0;
					END;
					CALL WRITEDATA(INFODEV,INFOSEC,MISC.BUF,256);

					/*	STORE MULTI-CHANNEL POLY MAP IN SECOND SECTOR OF INFO FILE AND FM MAP IN THE THIRD	*/
					IF INFOSEC+1=0 THEN J=1; ELSE J=0;
					CALL EXT.WRITEDATA(INFODEV+J,INFOSEC+1,MPOLY.PTR,0,1,0);	/*	WRITE 1 SECTOR FROM EXT MEM TO DISK	*/
					IF INFOSEC+2 ILT INFOSEC THEN J=1; ELSE J=0;
					CALL EXT.WRITEDATA(INFODEV+J,INFOSEC+2,MFM.PTR,0,1,0);
				END;
			END;				/*	OF INTERROGATE HARDWARE	*/
		END;					/*	OF MULTI SYSTEM INCL		*/
	END;						/*	OF EXPAND SYSTEM INCL	*/

	ENABLE;					// in all cases just in case

	interp_delay_on_d3_write(false);

END INIT.EXPAND.SYSTEM;

INIT.SYNTHS: PROC PUBLIC SWAPABLE;
	DCL (I,J,BIN)	FIXED;
	DCL PTR        POINTER;

	COMPUTE.MAX.DIAG.VOICES: proc;	/*	compute the magic "wrap" number for diagnostics testing	*/
		dcl (sum1,sum2,sum3)	fixed;
		dcl (i,ptr)				fixed;

		sum1 = core(fr1.ptr)+core(fr2.ptr);				/*	FM voices	*/

		ptr = addr(fp0.ptr);
		do i=0 to polynums-1;
			if core(core(ptr))<>0 then sum2=sum2+32;	/*	Poly voices	*/
			ptr=ptr+1;
		end;

		sum3 = (inc.mono<>0)&1;								/*	Mono voice	*/

		/*	choose whichever is largest	*/
		if		  (sum1 ige sum2) and (sum1 ige sum3) then MAX.DIAGNOSE.VOICES = sum1;
		else if (sum2 ige sum1) and (sum2 ige sum3) then MAX.DIAGNOSE.VOICES = sum2;
		else if (sum3 ige sum2) and (sum3 ige sum1) then MAX.DIAGNOSE.VOICES = sum3;
		else															 MAX.DIAGNOSE.VOICES = sum1;

	end COMPUTE.MAX.DIAG.VOICES;

	DISABLE;

	CORE(FR1.PTR) = 0;	/*	MAKE SURE THESE ARE ZERO SINCE	*/
	CORE(FR2.PTR) = 0;	/*	ROUTINE MAY GET CALLED MORE		*/
	CORE(FRM.PTR) = 0;	/*	THAN ONCE								*/
	CORE(FP0.PTR) = 0;
	CORE(FP1.PTR) = 0;
	CORE(FP2.PTR) = 0;
	CORE(FP3.PTR) = 0;

	IF INC.FM & (DIAGNOSTICS.ENABLED=0)		/*	COMPUTE NORMAL FREE CHANNEL LISTS	*/
	THEN DO;
		DO I=0 TO LSYN2.END-1;					/*	ZERO OUT ACTUAL CHANNELS THAT EXIST	*/
			IF (I&1)=0 THEN DO;					/*	EVEN CHANNEL - STORE ON FREE LIST	*/
				DO J=0 TO 11;
					WRITE(CHA)=I; WRITE(FUN)=J;
					WRITE(DAT)=STOP.DATA(J);
				END;
				WRITE(FUN)=ISHC; WRITE(DAT)=128;	/*	CENTER STEREO POSITION	*/

				IF      (I<LSYN1.END) THEN J=FR1.PTR;
				ELSE IF (I<LSYN2.END) THEN J=FR2.PTR;
				ELSE J=0;								/*	HARDWARE RANDOMNESS					*/
				IF J<>0 THEN DO;						/*	STORE ON FREE LIST					*/
					CORE(J)=CORE(J)+1;
					CORE(J+CORE(J))=I\SHL(8+(SHR(I,1)&7),8);	/*	STORE MEMORY # IN UPPER HALF	*/
				END;
			END;
		END;

		IF INC.MONO<>0 THEN DO;		/*	SET UP MONO LIST	*/
			DO I=1 TO 16;				/*	SIMULATE MULTIPLE CHANNELS - ALLOW NEW NOTES TO OVERRIDE OLD ONES	*/
				CORE(FRM.PTR+I)=B.MONO+SHL(I-1,1);
			END;
			CORE(FRM.PTR)=16;
		END;

		IF INC.POLY<>0 THEN DO;							/*	SET UP POLY LIST			*/
			PTR = ADDR(FP0.PTR);							/*	POINT AT FIRST LIST		*/
			DO BIN=0 TO PSMAXBINS-1;					/*	FOR ALL BINS AND			*/
				DO I=0 TO POLYNUMVS(BIN)-1;			/*	ALL VOICES IN EACH BIN	*/
					CORE(CORE(PTR)+1+I) = B.POLY \ (I + 64 * BIN);
				END;
				CORE(CORE(PTR)) = POLYNUMVS(BIN);	/*	COUNT IN 1ST WORD			*/
				PTR = PTR + 1;								/*	POINT AT NEXT LIST		*/
			END;												/*	OF LOOP OVER BINS			*/
		END;

		CALL COMPUTE.MAX.DIAG.VOICES;

	END;
	
	ELSE IF INC.FM THEN DO;								/*	SET UP CHANNELS FOR 4X PROGRAM	*/
		IF LSYN2.END<>0									/*	IF ANY FM CHANNELS AT ALL	*/
		THEN CORE(FR2.PTR)=1;							/*	USE ONLY ONE OF THEM			*/
		PTR=ADDR(FP0.PTR);								/*	POINT AT 1ST POINTER			*/
		DO BIN=0 TO PSMAXBINS-1;
			IF POLYNUMVS(BIN) > XXXXCH				   /*	if xxxxch available in bin	*/
			THEN CORE(CORE(PTR))=1;						/*	USE ONLY ONE					*/
			PTR=PTR+1;
		END;
	END;

	FM.VOICES	= core(fr1.ptr)+core(fr2.ptr);
	SYSTEM.VOICES = core(fr1.ptr)+core(fr2.ptr)+core(fp0.ptr)+core(fp1.ptr)+core(fp2.ptr)+core(fp3.ptr)+inc.mono;

	ENABLE;

END INIT.SYNTHS;
