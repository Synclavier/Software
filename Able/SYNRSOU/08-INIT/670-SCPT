/*	:SYNRSOU:08-INIT:670-SCPT  $TITLE  Main program initialization	*/

/*
Modified:
2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202
2000/10/06 - TY  - Added initialization of new MWHEEL_PROXY variable
1999/04/12 - TY  - Removed some default-related code which is now handled by "INIT.DEFAULTS".
						 Moved the call to "INIT.DEFAULTS" to a point after extmem areas have been
						 allocated and track heads and timbre heads have been set up
1999/01/20 - TY  - Keyboard's Output Routing now initializes to user default
1998/06/27 - TY  - Added code to make Keyboard's Output Routing default to Left=1, Right=2.
1998/06/22 - TY  - Added code to make initial sequence default to New Freq Table.
1991/11/04 - PF  - Added 'Quick Update' feature
1991/04/26 - PF  - removed debug line hardcoding divisions word
1990/09/27 - CJ  - Initialized start up value
1990/08/27 - PF  - Support all MIDI controllers
1990/07/27 - LSS - added call to INIT_OPTICAL_CONTROLLER for 5-inch M/O
1989/03/09 - PF  - Increase MAX.INPUTS to 128
1990/01/10 - MWH - Clean up initialization of POLY.TIMBRE.MIDI.CONTROL
1989/12/11 - MWH - Initialize POLY.TIMBRE.MIDI.CONTROL to 0 (MIDI mapped to keyboard)
1989/08/24 - PF  - Initialize POLY.TIMBRE.MIDI.CONTROL to 1 (MIDI mapped to recorder)
1989/07/07 - TSS - Call KEYBOARD.CHECK if INC.KBD.MAPS = 1
1989/05/08 - PF  - Changed MIDI.MAPPING initializations to all channels off
1989/05/08 - PF  - ADDED MIDI.BUF AND SYSEX.PACKET INITIALIZATIONS
1989/03/21 - TSS - Fix bug where files were not loading from Optical
1989/03/19 - TSS - Don't initialize MIDI.INPUT.CHAN in this file anymore
1988/10/11 - MWH - Add RS422 driver
1988/07/29 - SGS - Added default settings to INFOFILE
1988/07/22 - MWH - Initialize SMPTE coast time
1988/04/13 - PF  - ADDED MIDI MAPPING INITIALIZATIONS
1988/01/12 - MWH - Start Synclavier via SET RTP...PLAY; no running directly
1987/06/26 - MWH - Split FRP.PTR into FP0-FP3.PTR for expanded poly
1987/06/18 - MWH - Add code for expanded poly
1986/10/28 - KJO - -7 CHANGES
1986/10/22 - TS  - FIXED OVERLAY/1ST TIMBRE PROBLEMS FOR THE LAST TIME
1986/10/17 - TS  - ADDED CALL TO CLEAR.LOOP.PARMS
1986/10/10 - TS  - FIXED BUG: FAILING TO CALL UP TIMBRE WHEN OVERLAYING WITH M SEQ
1986/08/20 - TS  - FINISHED CODE TO GET STARTING TIMBRE (RESYNTH,SFM, OR READ FROM BANK)
1986/08/19 - TS  - FIXED BUG IN SFM OVERLAY TO CALL UP LAST CURRENT FILE
1986/08/11 - EG  - moved some initialization code into procedures to save swap space,
						 moved procedures into 600-init
1986/08/01 - cj  - changed look for lod setting
1986/07/25 - BSW - deleted allocations for  mrec.ptr and msum.ptr
1986/07/16 -CJ,TS- CALLED PANEL.RESCAN AND CLEARED RTE.CHANGES
1986/06/15 - CJ  - ADDED SCSI BUFFER ALLOCATION, set look.for.lod=1
1986/05/29 - CJ  - added inbound overlay with 32 track sequence
1986/05/22 - eg  - added allocations for mrec.ptr and msum.ptr
1986/05/15 - "official" creation of release-M modules
*/

/*	START OF INITIALIZATION	*/

/*	WE MUST FIRST SET UP EXTERNAL MEMORY TO ACCOUNT FOR THE	*/
/*	FACT THAT THERE MAY BE A SEQUENCE OUT THERE (FROM			*/
/*	SCRIPT).																	*/

/*	THIS WILL KEEP OTHER ALLOCATION ROUTINES FROM				*/
/*	OVERWRITING AND TRASHING THE SEQUENCE							*/

DCL (SFM.NAME) (4)	fixed;

BAS.PTR=CORE(LOC.SYNMISC);			/*	BASE/MISC POINTER								*/
PAR.PTR=CORE(LOC.SYNTIMB);			/*	PARAM POINTER - IN CORE OR EX MEMORY	*/
NAH.PTR=CORE(LOC.SYNSEQ );			/*	NOTE POINTER  - IN CORE OR EX MEMORY	*/
MEDIA	=CORE(LOC.SYNMED );			/*	MEDIA - 0 = INTERNAL MEM, 1 = EXT MEM, 2 = REL M FORMAT	*/

/*	FOLLOWING CODE IS A KLUDGE TO FIGURE OUT WHERE WE OVERLAYED	*/
/*	FROM IN ORDER TO KNOW IF WHAT TIMBRE WE SHOULD SET UP ON		*/
/*	THE KEYBOARD. SCRIPT, MUSIC PRINTING, AND THE REVERSE			*/
/*	COMPILER SET UP HIGH CORE IN ONE WAY, SFM SETS IT UP IN		*/
/*	ANOTHER, AND THE RESYNTHESIS ANALYSIS PROGRAM SETS UP HIGH	*/
/*	CORE IN YET A THIRD WAY. BASICALLY ANY CHECK OF THE HIGH		*/
/*	VARIABLES WHICH CAN DISTINGUISH BETWEEN THE THREE CASES IS	*/
/*	SUFFICIENT. THE KLUDGE BELOW WAS BASED UPON THE FOLLOWING	*/
/*	WAYS OF SETTING HIGH CORE BY EACH PROGRAM:						*/

/*		SCRIPT/MP/REVCOM (RELEASE L):										*/
/*			-RELEASE L FORMAT-         -RELEASE M FORMAT-			*/
/*			 CORE(LOC.SYNMED) =1        CORE(LOC.SYNMED) =2			*/
/*			 CORE(LOC.SYNLEN) =LEN      CORE(LOC.SYNLEN) =0			*/
/*			 CORE(LOC.SYNMISC)=PTR      CORE(LOC.SYNMISC)=0			*/
/*			 CORE(LOC.SYNTIMB)=PTR      CORE(LOC.SYNTIMB)=BAS.PTR	*/
/*			 CORE(LOC.SYNSEQ) =PTR      CORE(LOC.SYNSEQ) =0			*/
/*			 CORE(LOC.SYNSTAT)=0        CORE(LOC.SYNSTAT)=0			*/
/*			 CORE(LOC.SYNRET) =LOC.MON  CORE(LOC.SYNRET) =LOC.MON	*/
/*			 CORE(LOC.RST)		=2        CORE(LOC.RST)		=2			*/

/*		SIGNAL FILE MANAGER (SFM):											*/
/*			 CORE(LOC.SYNMED) =0												*/
/*			 CORE(LOC.SYNLEN) =0												*/
/*			 CORE(LOC.SYNMISC)=0												*/
/*			 CORE(LOC.SYNTIMB)=0												*/
/*			 CORE(LOC.SYNSEQ) =0												*/
/*			 CORE(LOC.SYNSTAT)=0												*/
/*			 CORE(LOC.SYNRET) =LOC.MON										*/
/*			 CORE(LOC.RST)		=3												*/

/*		RESYNTHESIS/ANALYSIS PROGRAM:										*/
/*			 CORE(LOC.SYNMED) =1												*/
/*			 CORE(LOC.SYNLEN) =0												*/
/*			 CORE(LOC.SYNMISC)=0												*/
/*			 CORE(LOC.SYNTIMB)=0												*/
/*			 CORE(LOC.SYNSEQ) =0												*/
/*			 CORE(LOC.SYNSTAT)=0												*/
/*			 CORE(LOC.SYNRET) =LOC.MON										*/
/*			 CORE(LOC.RST)		=3												*/


/*	ASSUMES WE HAVE COME FROM SCRIPT/MP/REVCOM (I.E., WHERE.FROM=0)	*/

IF CORE(LOC.RST)=3 THEN DO;	/*	EITHER FROM SFM OR RESYNTH PGM	*/
	IF MEDIA=0
	THEN WHERE.FROM=2;			/*	CAME HERE FROM THE SFM	*/
	ELSE IF MEDIA=1
	THEN WHERE.FROM=1;			/*	CAME FROM RESYNTH PGM	*/
END;

/*	ELSE, IF NOT FROM SCRIPT/MP/REVCOM ("PLAY" IS FROM SCRIPT), DON'T START	*/

ELSE IF CORE(LOC.RST)<>2 THEN DO;
	CALL PS('The real-time program must be run via the SET RTP and PLAY commands');
	CALL TTY_WAIT;
	CALL EXIT(-1);
END;


/*	CHECK FOR SFM OVERLAY & SAVE NAME FIRST	*/

IF WHERE.FROM=2 THEN DO;		/*	CAME FROM SFM	*/
	FROM.SFM=1;						/*	DETECT CONDITION OF COMING FROM SFM	*/
	I=CORE(MEM.SIZ-1119);		/*	GET PTR TO SFM FCB AREA	*/
	IF (CORE(I)<>0)				/*	LAST CURRENT FILE HAS NON-NULL NAME	*/
	THEN DO;							/*	DO HAVE A CURRENT SOUND FILE	*/
		DO J=0 TO CORE(I)-1;
			CALL PBYTE(SFM.NAME,J,BYTE(LOCATION(I),J));
		END;
		SFM.NAME(0)=CORE(I);
	END;
END;

IF MEDIA<>2			/*	OVERLAY WITH OLD FORMAT SEQUENCE		*/
THEN CALL OLD.FORMAT.OVERLAY;
ELSE CALL NEW.FORMAT.OVERLAY;	/*	MEDIA = 2: OVERLAY WITH NEW FORMAT SEQUENCE IN MEMORY	*/

/*	$PAGE - OPEN GENERAL INFOFILE	*/

CALL INIT.INFOFILE;

/*	OPEN CUE HISTORY FILE	*/

CALL INIT.CUE.HIST.FILE;
CALL INIT.POLY.HIST.FILE;

/*	OPEN UP FILES IF FROM SFM:	*/

IF (INC.MONO<>0)\(INC.POLY<>0)				/*	IF SAMPLING INCLUDED, CHECK FOR SFM OVERLAY	*/
THEN DO;
	IF FROM.SFM<>0 THEN DO;						/*	MUST OPEN UP SCRIPT FILES IF FROM SFM	*/
		CALL OPENFILE('.STAB-7',LOC.P3);		/*	LOOK UP DATA FILE	*/
		CALL OPENFILE('.SCON-7',LOC.RT);		/*	LOOK UP CONVERSION PROGRAM	*/
		CALL OPENFILE('.SPLT-7',LOC.MPLT);	/*	AND PLOTTING PROGRAM	*/
	END;
	CALL OPENFILE('.SFM-7',LOC.P1);			/*	OPEN UP SFM FOR SFM OVERLAY	*/
END;

/*	NOW ALLOCATE BASIC EXTERNAL MEMORY AREAS	*/

CALL SETUP.EXTERNAL.ALLOCATIONS;

IF INC.KBD.MAPS <> 0				/*	DO CHECK HERE SINCE XMEM ALLOCS MUST	*/
THEN CALL KEYBOARD.CHECK;		/*	FINISH BEFORE CHECKING FOR CORRECT KEYBOARD	*/

/*	$PAGE - MORE INITIALIZATION - CHECK HARDWARE, ALLOCATE INTERNAL MEMORY	*/

/*	COMPUTE INTERNAL MEMORY SIZES	*/

MEM.BOTTOM=CORE(CORE(1))+CORE(CORE(1)+1)+PDL.SIZE;	/*	COMPUTE FREE MEM PTR = VSTRT+VLNGTH+PDLL	*/
MEM.TOP	=LOC.LOAD-256;										/*	PRESERVE 256 FOR SFM FOR NOW	*/


/*	SEE HOW MANY FM CHANNELS	*/

IF INC.FM THEN DO I=0 TO 254 BY 16;	/*	SEE HOW MANY SYNTHESIZERS AVAIL	*/
	WRITE(CHA)=I;							/*	SELECT CHANNEL - THIS SELECTS SYNTHESIZER BANK	*/
	IF READ(CHA) THEN DO;				/*	CHANNEL EXISTS	*/
		LSYN2.END=I+16;					/*	RECORD END	*/
	END;
END;

LSYN1.START=0;
LSYN1.END=SHR(LSYN2.END,1)&"177760";	/*	ALLOCATE HALF TO LSYN1 - MAY BE 0 FOR 8 VOICE	*/
LSYN2.START=LSYN1.END;						/*	LSYN1 STARTS HERE	*/


/*	ALLOCATE INTERNAL MEMORY	*/

FR1.PTR=ALLOC.INT(SHR(LSYN1.END,1)+1);					/*	FREE CHAN LIST FOR LSYN1	*/
FR2.PTR=ALLOC.INT(SHR(LSYN2.END-LSYN1.END,1)+1);	/*	FREE CHAN LIST FOR LSYN2	*/

IF INC.MONO THEN FRM.PTR=ALLOC.INT(17);				/*	FREE CHAN LIST FOR MONO		*/
ELSE             FRM.PTR=ALLOC.INT( 1);

BEGIN;
	DCL PTR POINTER;											/*	POINTER TO POINTER TO POLY CHANNEL LISTS	*/
	PTR = ADDR(FP0.PTR);										/*	POINT AT FIRST CHANNEL LIST	*/
	DO I=0 TO PSMAXBINS-1;									/*	OVER ALL POSSIBLE POLY BINS	*/
		IF INC.POLY & I < POLYNUMS							/*	IF POLY AT ALL AND THIS BIN EXISTS	*/
		THEN CORE(PTR) = ALLOC.INT(POLYNUMVS(I)+1);	/*	RESERVE SPACE FOR INITIAL COUNT AND ALL VOICES		*/
		ELSE CORE(PTR) = ALLOC.INT(1);					/*	ELSE ONLY ONE WORD NEEDED FOR VOICE COUNT OF ZERO	*/
		PTR = PTR + 1;											/*	POINT AT NEXT POINTER	*/
	END;
END;

/*	NOTE: WE WILL ALLOCATE NOTE BLOCKS AND	*/
/*			PARTIAL BLOCKS LATER, ONCE THE	*/
/*			LOADER HAS BEEN TRANSFERRED		*/
/*			TO EXTERNAL MEMORY					*/


/*	$PAGE - FILL EXTERNAL MEMORY AS REQUIRED	*/

/*	SET UP TRACK HEADS:	*/

CALL COMPUTE.TRK.HEADS;

/*	READ IN DATA TABLES:	*/

IF (MS.TABLE.SECTOR != 0)						/*	IF FILE EXISTS, READ IT IN...		*/
{
	I = MS.TABLE.SECTOR;
	J = LS.TABLE.SECTOR + FRQTABLE.OFFSET;
	IF J ILT LS.TABLE.SECTOR THEN I = I + 1;
	CALL EXT.READDATA(I,J,FRE.PTR,0,0,2048);

	I = MS.TABLE.SECTOR;
	J = LS.TABLE.SECTOR + SINTABLE.OFFSET;
	IF J ILT LS.TABLE.SECTOR THEN I = I + 1;
	CALL EXT.READDATA(I,J,STB.PTR,0,0,0256);

	I = MS.TABLE.SECTOR;
	J = LS.TABLE.SECTOR + LOGTABLE.OFFSET;
	IF J ILT LS.TABLE.SECTOR THEN I = I + 1;
	CALL EXT.READDATA(I,J,LTB.PTR,0,0,1000);

	IF FRE.PTR<>POLY.FRE.PTR THEN DO;	/*	NEED TO LOAD NEW POLY FREQ LOOKUP TABLE	*/
		I = MS.TABLE.SECTOR;
		J = LS.TABLE.SECTOR + POLY.FRQTABLE.OFFSET;
		IF J ILT LS.TABLE.SECTOR THEN I = I + 1;
		CALL EXT.READDATA(I,J,POLY.FRE.PTR,0,0,4096);
	END;
}

ELSE													/*	ELSE AT LEAST BOOT IF NO TABLE	*/
{
	CALL PSR('.STAB-7 is missing; creating substitute data...');

	WRITE(MAM) = FRE.PTR;
	DO I = 0 TO 2047;
		WRITE(MDI) = 0x566B;
	END;

	WRITE(MAM) = STB.PTR;
	DO I = 0 TO 63;
		WRITE(MDI) = 0x400 + SHL(I,4);
	END;
	DO I = 0 TO 63;
		WRITE(MDI) = 0x7F0 - SHL(I,4);
	END;
	DO I = 0 TO 63;
		WRITE(MDI) = 0x400 - SHL(I,4);
	END;
	DO I = 0 TO 63;
		WRITE(MDI) = 0x010 + SHL(I,4);
	END;

	WRITE(MAM) = LTB.PTR;
	DO I = 0 TO 999;
		WRITE(MDI) = 1024*i/1000;
	END;

	IF FRE.PTR<>POLY.FRE.PTR THEN DO;
		WRITE(MAM) = POLY.FRE.PTR;
		DO I = 0 TO 4095;
			WRITE(MDI) = 0x1000;
		END;
	END;
}

/*	SET UP SEQUENCE TO DEFAULT TO NEW FREQ TABLE	*/

IF POLY.FRE.PTR<>FRE.PTR THEN DO;		/*	THE NEW POLY FREQ TABLE IS LOADED		*/
	WRITE(MAM)=BAS.PTR;
	WRITE(MAL)=SEQ.POLY.FREQ.TABLE;		/*	TELL SEQUENCE TO USE NEW TABLE			*/
	WRITE(MD )=1;
	POLY.FREQ.TABLE.PTR=POLY.FRE.PTR;	/*	AND SET PTR TO THE POLY LOOKUP TABLE	*/
END;

/*	COMPUTE MIDI & VEL MAPS:	*/

CALL COMPUTE.SYNC.TTIME.MAP(3);
CALL COMPUTE.MIDI.VELMAPS;

/*	LOAD NULL TIMBRE:				*/

WRITE(MAM)=NUL.PTR;
CALL COPY.OUT(ADDR(NULL.TIMBRE(0)),NUM.PARTIALS+NUM.MISC.PARAMS);

NEW.KBD.PRE=1;									/*	FIRLL PRECOMPUTE AREA LATER	*/


/*	MOVE LOADER TO XMEM:		*/

WRITE(MAM)=LOAD.PTR;
CALL COPY.OUT(LOC.LOAD-256,LOC.SYNRET-LOC.LOAD+256);	/*	LOADER + INFO, 256 WORDS FOR SFM	*/
LOADER.MOVED=1;						/*	LOADER HAS BEEN MOVED	*/
ORIG.PSYS=CORE(LOC.PSYS);			/*	SAVE ORIGINAL PSYS #		*/
CORE(LOC.PSYS) = -1;					/*	FORCE COLD BOOT			*/


/*	SET UP INITIAL TRACK BUTTONS:	*/

WRITE(MAM)=TBUT.PTR;
DO I=0 TO MAX.TRACKS-NUM.KBD.TRACKS-1;
	WRITE(MDI)=NUM.KBD.TRACKS+I;
END;


/*	$PAGE - ALLOCATE AND INITIALIZE NOTE & PARTIAL BLOCKS	*/

/*	ALLOCATE BLOCKS NOW THAT LOADER IS IN EXTERNAL MEMORY	*/

MEM.TOP	=LOC.SYNRET;				/*	MOVE MEM.TOP UP TO LOC.SYNRET NOW THAT LOADER IS GONE	*/

LOAD (MEM.TOP-MEM.BOTTOM);
DIV  (PBLK.SIZE+NBLK.SIZE);
NUM.PBLKS=RES;							/*	DIVIDE EQUALLY FOR NOW	*/
NUM.NBLKS=RES;

NPTR = ALLOC.INT(NUM.NBLKS*NBLK.SIZE);

DO I=1 TO NUM.NBLKS;					/*	MAKE BLOCKS, LINK ON TO FREE LIST	*/
	CORE(NPTR)=NFREEP;				/*	LINK US ON TO FRONT OF FREE QUE		*/
	NFREEP	=NPTR  ;					/*	NOTE BLOCK IS ALL ZEROES NOW			*/
	NPTR=NPTR+NBLK.SIZE;
END;

PPTR = ALLOC.INT(NUM.PBLKS*PBLK.SIZE);

DO I=1 TO NUM.PBLKS;					/*	CREATE PARTIAL BLOCK LIST	*/
	CALL RELP;							/*	USE RELP SO THAT WORDS GET INITIALIZED	*/
	PPTR=PPTR+PBLK.SIZE;
END;

// Now allow switch to deferred task in case things take a while

interp_activate_real_time(true); // Inform interpreter that real time loop is now running.
interp_set_rtp_is_running(true); // Can load sound files

/*	INITIALIZE SYNTHESIZERS	*/
CALL INIT.SYNTHS;

/*	INITIALIZE & SET UP MULTI OUTPUT	*/
CALL INIT.EXPAND.SYSTEM;

/*	$PAGE - INITIALIZE OTHER HARDWARE VARIABLES	*/

MIDI.SYNC.IS.TC = true;       // Default to MTC
CALL INIT.MIDI.SUBSYSTEMS;		/*	SEE IF MIDI IN SYSTEM AND CLEAR OUT I/O FIFOS	*/

CALL CLEAN.TRACK.HEADS(0);		/*	INITIALIZE ALL TRACK HEADS (AFTER MIDI & MULTI ROUTE INFO DETERMINED)	*/

CALL COMPACT.TIMBRES(PAR.PTR,PAR.NUMT);	/*	ALLOCATE TIMBRE HEADS		*/

/*	SET SOME PARAMS ACCORDING TO DEFAULTS STORED IN INFOFILE	*/
//	This must not be called until after extmem areas have been allocated
//	and track heads and timbre heads have been set up
CALL INIT.DEFAULTS;

CALL KBD.INIT;							/*	CLEAR KEYBOARD HARDWARE	*/
CALL PANEL.INIT;						/*	SET UP KEYBOARD PRESETS	*/
CALL DISPLAY.HGS;						/*	DISPLAY HARMONIC GROUP	*/

MIDI.BUF(0) = 3;						/*	INIT MIDI.BUF NEXT DATA WORD TO 3 (PAST HEADER STUFF)	*/
MIDI.BUF(2) = T#MIDI_BULK;			/*	INIT THE MIDI NETWORK BUFFER TYPE WORD TO T#MIDI_BULK TYPE	*/

WRITE(MAM) = SYSEX.PACKET;			/*	POINT TO SECTOR RESERVED FOR SYSTEM EXCLUSIVE PACKETS OUTGOING	*/
WRITE(MDI) = 8;						/*	INIT LENGTH TO 8 BYTES - LENGTH OF HEADER STUFF	*/
WRITE(MDI) = NN#MIDI;				/*	DESTINATION IS MIDI	*/
WRITE(MDI) = T#SYSTEM_EXCLUSIVE;	/*	SUPER/SUB TYPE LITERAL FOR SYSTEM EXCLUSIVE PACKETS	*/

CALL INIT.MIDI.ROUTINGS;			/*	INITIALIZE CONTROLLER ROUTING INFO	*/
CALL INIT.MIDI.RTE.AREA;			/*	INITAILIZE XMEM TABLE FOR ALL MIDI CONTROLLERS	*/

DO I=NUM.KBD.TRACKS TO MAX.INPUTS-1;		/*	INITIALIZE MIDI TO RECORDER ROUTING	*/
	MIDI.MAPPING(I)=1;							/*	INIT INPUT CHANNELS 2-127 TO OFF POSITION	*/
END;

POLY.TIMBRE.MIDI.CONTROL = 0;					/*	INIT TO MIDI MAPPED TO KEYBOARD	*/
MIDI.INPUT.ENABLED       = false;

IF INC.POLY THEN CALL SETUP.CACHE(true);	/*	CREATE CACHE OF ALL SOUND FILES ON WINCHESTER DISKS	*/

CALL COMPUTE.DSEL.BUTTON;						/*	SET DSEL BUTTON AS APPROPRIATE	*/

CALL COMPUTE.ACTIVE.TRKS;						/*	SET UP ACTIVE.TRACKS ARRAY TO ALL ON	*/

CALL SETUP.SQ;										/*	SET UP SEQUENCE INFO	*/

CALL INIT.D115;									/*	INITIALIZE RS422 COMMUNICATIONS PROCESSOR	*/

CALL INIT_OPTICAL_CONTROLLER;					/*	SET UP OPTICAL DISK CONTROLLER TYPE (LMS WORM OR 5-INCH M/O)	*/

TBASE						= 4400;		/*	SET UP INITIAL TUNING BASE		*/
TB.DMAX					= 200;		/*	INITIALIZE TB SENS TO 2 SEMITONES (OLD PANEL ONLY)	*/
STARTUP.VALUE			= 100;		/*	INITIALIZE START UP CONTROL	*/
NUMPOINTS				= 5;			/*	DEFAULT FOR LOOP SEARCH			*/
TROUT.TRK#				= -1;			/*	INIT TO ACCESS KBD				*/
SMPTE.COAST.MSEC		= 100;		/*	DEFAULT COAST TIME ON ERRORS	*/ // was 300 in the analog days; changed to 100 for MTC CJ 2017
MWHEEL_PROXY			= R.MWHEEL;	//	default to "physical mod wheel generates ModW RTEs"
MARK.BUTTON.DISABLED	= true;		//	Since this is no longer done automatically when sequences are recalled,
											//	we should initialize with "MARK POINT: OFF".

/*	READ IN BANK - SET UP INITIAL TIMBRE	*/

I=READ.IN.BANK;			/*	LOOK FOR BANK & TRY TO READ IT IN	*/

IF WHERE.FROM<>1			/*	DID NOT COME FROM RESYNTH PGM	*/
THEN DO;						/*	PROVIDE A PLAYABLE BUT NULL KEYBOARD TIMBRE	*/
								/*	THIS WILL ONLY BE USED IF A BANK CAN'T BE FOUND BELOW	*/
	WRITE(MAM)=PAR.PTR; WRITE(MAL)=3;
	WRITE(MDI)=100;							/*	FINAL DECAY = 100 MILLISECONDS	*/
	WRITE(MDI)=1000; WRITE(MDI)=1000;	/*	SET UP PK & SUS LEV OF 1000		*/
	WRITE(MAL)=12;
	WRITE(MD)=1000;						/*	COEF OF 1000	*/
	WRITE(MAL)=36;
	WRITE(MD)=4400;						/*	TUNING	*/
	WRITE(MAL)=45;
	WRITE(MD)=1000;						/*	NEW CHORUS FUNCTION	*/
	WRITE(MAL)=NUM.PARTIALS*NUM.PARAMS+CHORUS.LOC;
	WRITE(MD)=1000;						/*	OVERALL CHORUS FUNCTION	*/
END;

IF ((INC.POLY\INC.MONO)<>0)		/*	THIS IS A SAMPLING COMPILATION	*/
AND (FROM.SFM   <>0)					/*	TRY TO SET UP LAST CURRENT FILE AS TIMBRE	*/
AND (SFM.NAME(0)<>0)					/*	LAST CURRENT FILE HAS NON-NULL NAME	*/
THEN BEGIN;								/*	DO HAVE A CURRENT SOUND FILE	*/
	DCL (I)	fixed;
	CALL ERASE.KEYBOARD.TIMBRE;	/*	get rid of timbre #0			*/
	CALL SELECT.PARTIAL(0);			/*	select the first partial	*/
	CALL CREATE.PATCH.PARTIAL(0,SFM.NAME);
	NEW.TIMBRE.INFO = 0;				/*	but no event needed			*/
END;
ELSE ERTYP=1;							/*	FORCE READ OF BANK			*/

IF ERTYP<>0 THEN DO;					/*	NEED TO PUT SOME TIMBRE ON KBD	*/

	CALL SETUP.FLOPPY.CACHE;	/*	SET UP TO USE FLOPPY IN CASE WE NEED TO	*/
	CALL MOUNT.OPTICAL.VOLUME;	/*	ALSO CACHE OPT DISK IF NEEDED	*/

	IF  (BNK.LEN    <> 0)		/*	IF THERE IS A TIMBRE BANK		*/
	AND (WHERE.FROM <> 1)		/*	DID NOT COME FROM RESYNTH PGM	*/
	THEN DO;
		CALL MOVE.TIMBRE.TO(BNK.PTR,0,0);	/*	THEN MOVE FROM TIMBRE BANK BANK	*/
	END;

	IF (BNK.LEN=0)									/*	IF THERE IS NO BANK IN MEMORY	*/
	OR (LENGTH.OVERFLOW<>0)						/*	OR WE HAD A LENGTH ERROR ABOVE	*/
	OR (WHERE.FROM		=1)						/*	OR CAME FROM RESYNTH PGM	*/
	THEN DO;											/*	CHECK FURTHER	*/
		IF (I				=0)						/*	IF THERE IS NO BANK FILE AT ALL (SET WHEN WE SEARCHED FOR .BNKDATA)	*/
		OR (WHERE.FROM =1)						/*	OR WE ARE FROM ANALYSIS PROGRAM	*/
		OR (PAT.FORMAT<>0)						/*	FILE IS A .PATDATA	*/
		THEN CALL MOVE.TIMBRE.TO(PAR.PTR,0,0);	/*	PICK UP DEFAULT TIMBRE STORED ABOVE IF NO TIMBRE FILE, OR PICK UP TIMBRE FROM ANALYSIS PROGRAM	*/
		ELSE DO;										/*	READ TIMBRE DIRECTLY FROM DISK TO KEYBOARD FOR SFM, SYNCL II	*/
			BNK.PTR=INF.PTR; BNK.LEN=0;
			CALL PRIME.IO.BUFFER(BANK.DEV,BANK.SEC,0,
										0,OUR.BANK.STR,
										EXTBUF.PTR,EXTBUF.LEN,0);	/*	SET UP FOR READ OF DISK	*/
			CALL MOVE.TIMBRE.TO(-1,0,0);		/*	STORE INTO PLACE DIRECTLY FROM DISK	*/
		END;
	END;

	FLOPPY.CACHE.VALID=0;						/*	DONE WITH CACHES NOW	*/
	CALL DISABLE_CACHE(FLOPPY.CACHE.NUM);
	OPTICAL.DISK.READY=0;

	ERTYP=0;											/*	RESET SINCE DONE WITH FLAG	*/
END;


RESET.FILTERS=1;		/*	SET FLAG TO WRITE OUT CORRECT FILTER DATA	*/

/*	TOGGLE EXTERNAL CLOCK OUTPUT TO LOW STATE SO IT GOES TO	*/
/*	A HIGH STATE WHEN THE SEQUENCER STARTS:					*/

IF INC.FM THEN DO;
	DCL ADC	lit '"163"';						/*	AD CONVERTER - OLD PANEL	*/

	WRITE(ADC)=3;									/*	INITIATE CONVERSION FOR EXT CLOCK USING OLD HARDWARE	*/
	WRITE(ADC)=2+20;								/*	SELECT AV5	*/
	IF READ(ADC)>50 THEN WRITE("163")=1;	/*	SWITCH EXT CLOCK TO LOW STATE	*/
END;

CALL CLEAR.LOOP.PARMS;					/*	INIT LOOP PARMS TO DEFAULT	*/

/*	SET INITIAL KEYBOARD SPLIT	*/

IF NEW.PAN=0 THEN SPLIT.KBD.LOC=24;	/*	ALLOW LOWER TWO OCTAVES FOR OLD PANEL	*/
ELSE SPLIT.KBD.LOC=36;					/*	THREE OCTAVES FOR NEW KEYBARD				*/

SOUND.FILE.MISSING=0;					/*	SUPRESS ANY ERRORS FROM ABOVE	*/

CALL PANEL.RESCAN;						/*	SCAN INPUTS ONCE	*/

DO I=0 TO MAX.INPUTS-1;					/*	LOOP THRU ALL INPUT CHANNELS	*/
	RTE.CHANGES(I)=0;						/*	BUT ONLY RECORD CHANGES FROM HERE ON	*/
END;

WRITE(MAM)=TBUT.PTR;
DO I=NUM.KBD.TRACKS TO MAX.TRACKS-1;		/*	INIT ALL SEQUENCER TRACKS TO AUTO MODE	*/
	IF (I <  FIRST.LOD.TRACK)					/*	DON'T TOUCH DTD TRACKS	*/
	OR (I >= LAST.LOD.TRACK )
	THEN WRITE(MDI)=READ(MD)\B.AUTO.CUE.TRK;
	ELSE WRITE("300")=READ(MDI);				/*	SIMPLY INCREMENT MD	*/
END;

do i = 0 to 15;							/*	init track index for seq & recorder screens	*/
	trkindex(i) = NUM.KBD.TRACKS + i;
end;

// Default to OMS MIDI on
if (interp_is_running != 0)
{
	OMS.MIDI.ENABLED = true;
	interp_init_oms_midi_bulk(addr(ANY.OMS.MIDI.BULK.BYTES), OMSMIDI.PTR);
	MIDI.INPUT.ENABLED = true;
}

INITIALIZE.COMPLETED = 1;				/*	ALLOW INTERRUPT SCAN NOW					*/
ENABLE;										/*	ENABLE INTS IF SOMEONE TURNED THEM OFF	*/
