/* ASM-3  $title  N.E.D. Able Series Assembler, Part 3 *//* Scan expression:  if prior = 0,  then scan complete expression.                     if prior = 1,  then stop after first terminal. */dcl exprc (40) fixed; /* expression string */dcl prior      fixed; /* initially zero */expc:  proc; /* call to set up next expression char */   call pbyte(exprc, exprc (0), nchr); exprc (0) = exprc (0) + 1; /* put in and bump length */   nchr = gc; /* next char */end expc;gexp:  proc; /* scan expression (recursive) */  dcl (val, expt) fixed;  glo.flag = 0; /* no flags yet */  if prior = 1 then do; /* scan terminal only */    if nchr = a.period then do; /* . or ... */      call expc;      if nchr <> a.period then return curloc; /* current location */      do while nchr = a.period; call expc; end; /* read dots */      return srch ('...'); /* set GLO.FLAG and return it's value */    end;    if nchr = a.lparen then do; /* left paren */      call expc; prior = 0; /* set up for recursive call */      val = gexp; /* scan parenthetical expression */      glo.flag = 0; /* clear flags */      if nchr <> a.rparen then call erm ('Missing parenthesis in expression');      else call expc; /* skip over right paren */      prior = 1; /* reset to correct priority */      return val;    end;    if (nchr >= a.0) and (nchr <= a.7) then do; /* numeric - octal expr */      val = 0; /* initialize val */      do while (nchr >= a.0) and (nchr <= a.7);        val = shl(val, 3) + (nchr and 7); /* add in value */        if nchr > a.7 then call erm ('Incorrect format in octal constant');        call expc;      end;      return val;    end; /* of numeric */    call gsymb (lab); /* none of the above - scan symbol */    call concat (exprc, exprc, lab);    val = srch (lab); /* look up in table */    if (glo.flag = immedsymb) or (glo.flag = relimsymb) then do; /* detect 'IM' or 'RE' */      call push (glo.flag); prior = 0; val = gexp; prior = 1; /* scan immediate expression */      if pop = relimsymb then val = val - curloc - 1; /* compute relative offset */      if (((val > 31) or (val < -32) or (glo.flag <> 0)) and (if_level = skip_level)) then do;        call erm ('Immediate field too large or undefined');        val = 0; glo.flag = 0; /* use zero */      end;      val = ("200") or (val and "77"); /* form immediate field */    end; /* of case for immediate or relative immediate */  end; /* of priority one */  else do; /* priority zero - scan complete expression */    if (nchr = a.minus) or (nchr = a.plus) then val = 0; /* clear for leading monadic */    else do; /* must get first terminal */      call push (nchr); if nchr = a.cflex then call expc; /* skip over monadic NOT */      prior = 1; val = gexp; prior = 0; /* scan first term */      if pop = a.cflex then val = not val; /* interpret monadic NOT */    end;    do while (nchr = a.minus) or (nchr = a.plus) or (nchr = a.star) or (nchr = a.slash) or (nchr = a.and) or (nchr = a.backslash); /* scan of operators */      call push (val); /* save first half */      call push (nchr); call expc; /* save operator, skip over it */      prior = 1; val = gexp; prior = 0; /* and scan second - terminal only */      glo.flag = 0; expt = pop; /* restore operator */      if      expt = a.plus then val = pop + val; /* add */      else if expt = a.minus then val = pop - val; /* sub */      else if expt = a.star then val = pop*val; /* mul */      else if expt = a.slash then do; if val = 0 then val = 1; val = pop/val; end;      else if expt = a.and then val = pop and val; /* and */      else if expt = a.backslash  then val = pop or val; /* or */    end; /* of do while */  end; /* of priority zero */  return val; /* return computed value */end gexp;/* $subtitle  Utility Routines and Initialization */dcl (plab, popc1, pto, popc2) (40) fixed; /* strings for print-out fields */expr:  proc fixed; /* routine to set up and call expr */  exprc (0) = 0; /* set to null */  return gexp; /* return expression result */end expr; comb:  proc(sou, des); /* combine the source and destination */   dcl (sou, des) fixed;   if (sou > 255) or (sou < 0) then call erm ('Source field too large');   if (des > 255) or (des < 0) then call erm ('Destination field too large');   return (shl(des and 255, 8) or (sou and 255));end comb;assign.title:  proc(buf); /* scan off title into buffer */   dcl buf array;   call skips; /* skip over spaces */   buf (0) = 0; /* clear out present title */   do while nchr <> 0; /* loop until end of line */      if buf (0) < 80 then do; call pbyte(buf, buf (0), nchr); buf (0) = buf (0) + 1; end; /* drop in and count */      nchr = gc; /* get next char */   end; /* of do while */   call strassign (pto, buf); /* save for printing */end assign.title;/* start of main code */dcl scan.flag  fixed; /* TRUE if rest of line to be scanned */dcl (i, j)     fixed;if (core(loc.cmed) or core(loc.wmed)) <> 0 then do;   print 'System error with disk configuration (.WORK missing).',; /* crashola (EXIT has a PRINT) */   call exit(-1);end;out.dev = "50"; /* default output to SIOUX */if ((directed_output = 1) and d40_present) then out.dev = "40"; /* printer output */redirection_word = 0; /* turn off all redirection */print string(rel.date); call set_catbuf (addr(catbuf (0)), 0); /* set the catalog buffer */disabled = TRUE; /* cache is currently disabled */print 'Initial output status:  L(ist) or N(olist) ->',;listf = (-1); /* unselected */do while listf = (-1); /* loop until selected */   i = rchar;   if (i = a.L) or (i = l.l) then do; listf = 1; print 'List';   end;   if (i = a.N) or (i = l.n) then do; listf = 0; print 'Nolist'; end;end;print;stkptr = 0; /* set up stack */call init; /* set up the symbol table with built-ins */nerrors = 0; /* no errors *//* $subtitle  Pass One Code *//* Scan the source, build symbol table, and assign locations. */call prime; /* start up the source file (get first NCHR) */pagenum = 0; call header; /* print header */print '*** Begin pass 1';pass = 1;if_level = 0; skip_level = 0; /* start at outermost level; don't skip any code */do while nchr <> (-1); /* main loop for pass 1 */  if curtyp = 0 then write("104") = 1; /* if floppy, kick the disk drive */  if curtyp = 2 then write("114") = 1; /* ditto for remote */  lnum = nchr + shl(gb, 8); /* get the line number */  nchr = gc; /* get first char of line */  scan.flag = 1; /* assume scan end of line */  plab (0) = 0; /* assume no label */  call skips; /* skip any leading spaces */  if nchr <> a.star then do; /* not a comment line - must be data producing line or '...' */    if nchr = 0 then call strassign (lab, '...');    else             call gsymb (lab); /* get potential label, or data statement */    if nchr = a.colon then do; /* statement label */      if if_level = skip_level then do; /* only proceed if we aren't skipping code */        i = srch (lab); /* look up */        call strassign (plab, lab); /* save name of symbol */      end; /* of not skipping code */      nchr = gc; call skips; /* skip colon and spaces */      if nchr = 0 then call strassign (lab, '...');      else             call gsymb (lab);      if ((not equal (lab, 'SET')) or (glo.flag = undefsymb)) and (if_level = skip_level) then do; /* allow SET labels to be redefined when not skipping code */        if glo.flag <> undefsymb then do; /* multiple definition */          call concat (errormes, 'Duplicate definition of symbol "', plab);          call concat (errormes, errormes, '"');          call erm (errormes);        end;        else call sym.ins (plab, curloc, usersymb); /* put into symbol table as user symbol */      end; /* of all SET to be redefined */    end; /* of statement label */    i = srch (lab); /* look up in table */    if glo.flag = specsymb then do; /* special symbol? */      if (if_level = skip_level) or (i = 11) or (i = 12) /* if we're not skipping or this is an IF or ENDIF */      then do case (i); /* branch on type of special psuedo-op */        ;;;; /* null, ..., list, eject */        curloc = curloc + 1; /* data generates one word */        do; /* text */          call skips;          do while nchr <> 0; /* until end of it all */            curloc = curloc + 1; nchr = gc; /* one byte means at least one word */            if nchr <> 0 then nchr = gc; /* but if two bytes then only one word */          end;        end; /* text */        do; /* insert */          call skips; call gsymb (lab); /* get filename */          call scan.rest; /* scan remainder of line */          scan.flag = 0; /* have already scanned rest */          call pushfile (lab); /* push this file and start inserted file */        end; /* insert */        do; /* equ */          call skips; j = expr; /* get the value */          i = sym.search (plab); /* find out its location */          sval (i) = j; sflag (i) = usersymb; /* assign value and type */        end; /* equ */        ; /* ttl */        ; /* sttl */        ; /* listoff */        do; /* if */          if if_level = skip_level then do; /* only evaluate if we aren't skipping */            call skips; /* skip spaces */            if expr <> 0 then skip_level = skip_level + 1; /* if the expression is TRUE, don't skip */          end; /* of evaluating only if we aren't skipping */          if_level = if_level + 1; /* we've moved in a level */        end; /* if */        do; /* endif */          if if_level = skip_level then skip_level = skip_level - 1; /* keep in synch if we aren't skipping */          if_level = if_level - 1; /* we've moved out a level */        end; /* endif */      end; /* of do case */    end; /* of special symbol */    else if if_level = skip_level then curloc = curloc + 1; /* an instruction - increment location */  end; /* of case for not comment */  if scan.flag then call scan.rest; /* scan rest of line */  nchr = gb; /* get first byte of next line number */end; /* of main loop for pass 1 *//* $subtitle  Pass Two Code *//* Rescan the source and output the object and listing..  By now, all symbols should be defined. */dcl (sou, des, objword) fixed; /* source, dest, and object output word */dcl (pri.loc, pri.obj)  fixed; /* print flags for object loc and val */dcl (anylistf, textf)   fixed; /* list flag, text flag */dcl ncurloc             fixed; /* next location counter value *//* tab positions for output format */dcl locpos            lit '2';dcl objpos            lit '10';dcl lnpos             lit '20';dcl labpos            lit '26';dcl compos            lit '26';dcl opcpos            lit '35';dcl topos             lit '45';dcl op2pos            lit '50';dcl cm2pos            lit '60';call prime; /* reset source file */curloc = 0; ncurloc = 0; /* reset location counter */if nerrors <> 0 then call header; /* start new page if error msgs have been printed */print '*** Begin pass 2';pass = 2;if_level  = 0; skip_level = 0; /* start at outermost level; don't skip any code */do while nchr <> (-1); /* main loop for pass two */  if (not listf) and (curtyp = 0) then write("104") = 1; /* bump disk if floppy and no list */  if (not listf) and (curtyp = 2) then write("114") = 1; /* bump disk if remote and no list */  textf     = 0; /* assume no text */  scan.flag = 1; /* assume rest of line must be scanned */  pri.obj   = 0; /* assume object code word is not to be printed */  pri.loc   = 1; /* assume location is to be printed */  plab (0) = 0; popc1 (0) = 0; pto (0) = 0; popc2 (0) = 0; exprc (0) = 0; /* clear strings */  lnum = nchr + shl(gb, 8); /* get the line number */  nchr = gc; /* get first char of line */  call skips; /* skip spaces */  if nchr = a.star then do; /* comment line */    call tab (lnpos);  call pnum (lnum);    call tab (compos); call pc (a.star);    nchr = gc;    call tab (opcpos); /* space out for comment */    call scan.rest; /* scan and print it */  end; /* of comment line */  else do; /* label or data line */    if nchr = 0 then do; i = 0; glo.flag = specsymb; end;    else                 i = expr; /* scan expression */    if nchr = a.colon then do; /* label */      call strassign (plab, exprc); /* save expression string which is really a label */      nchr = gc; call skips;      if nchr = 0 then do; i = 0; glo.flag = specsymb; end;      else                 i = expr; /* scan expression */    end; /* label */    call strassign (popc1, exprc); /* save scanned expression */    if glo.flag = specsymb then do; /* special assembler pseudo-op */      pri.loc = 0; /* don't print location for most of specials */      do case (i); /* branch on type */        ; /* null */        pri.loc = 1; /* ... */        if not listf then do; /* list */          listf = 1;          call header; /* start new page */        end;        do; /* eject */          if linc <> top.linc then call header; /* if not at top, start new page */        end;        do; /* data */          call skips; /* skip spaces */          objword = expr; /* scan expression for data word */          call strassign (pto, exprc); /* and print expression field */          pri.loc = 1; /* print it */          if if_level = skip_level then ncurloc = curloc + 1; /* next one */        end;        do; /* text */          call skips; /* skip spaces */          if nchr <> 0 then do; /* if not at end, then at least one data word */            textf = 1; /* indicate text mode */            call ungc; /* put NCHR back in the input buffer (as it was before GC) */            objword = gb; /* store first char */            nchr = gb; /* get next char */            if nchr <> 0 then do; /* pack */              objword = objword or shl(nchr, 8);              nchr = gb;            end;            pri.loc = 1; /* print it */            if if_level = skip_level then ncurloc = curloc + 1; /* next one */          end;        end; /* text */        do; /* insert */          call skips; /* skip spaces */          call gsymb (pto); /* get name of insert file */          if if_level = skip_level then do; /* only do insert if currently active */            call tab (lnpos);  call pnum (lnum);            call tab (opcpos); call ps (popc1);            call tab (topos);  call ps (pto);            call tab (cm2pos); call scan.rest; /* scan and print rest of line */            scan.flag = 0; /* rest of line already scanned */            call nl;            call pushfile (pto); /* push this file and start inserted file */          end;        end; /* insert */        do; /* equ (defined on pass 2) */          call skips;          objword = expr; /* scan off value */          call strassign (pto, exprc); /* keep the value chars */          if if_level = skip_level then do; /* only define if active code */            i = sym.search (plab); /* find it */            sval (i)  = objword; /* update value */            sflag (i) = usersymb;            pri.obj = 1; /* print the object value */          end;        end; /* equ */        do; /* ttl (title) */          call assign.title (title);          if linc <> top.linc then call header; /* if not at top, start new page */        end; /* ttl */        do; /* sttl (subtitle) */          call assign.title (stitle);          if linc <> top.linc then call header; /* if not at top, start new page */        end; /* sttl */        listf = 0; /* listoff */        do; /* if */          if if_level = skip_level then do; /* if we aren't skipping */            call skips; /* skip spaces */            if expr <> 0 then skip_level = skip_level + 1; /* if the expression is TRUE, don't skip code */            call strassign (pto, exprc); /* copy the scanned expression */          end; /* of if we aren't skipping */          if_level = if_level + 1; /* just went in a level */        end; /* if */        do; /* endif */          if if_level = skip_level then skip_level = skip_level - 1; /* keep in synch if we're not skipping */          if_level = if_level - 1; /* just went out a level */        end; /* endif */      end; /* of do case */    end; /* of stuff for special pseudo-ops */       else do; /* must be instruction (i.e., x to x) */      sou = i; /* save first result as source */      des = 0; /* assume no dest */      call skips;      call gsymb (lab); /* get what should be 'TO' */      if equal (lab, 'TO') then do; /* found 'TO' */        call strassign (pto, lab);        call skips;        des = expr; /* scan expression for dest */        call strassign (popc2, exprc); /* save it for print */      end;      else do; /* missing 'TO' */        call erm ('Expected ''TO'' after symbol');        call strassign (pto, lab);      end;      if if_level = skip_level then do; /* only do instructions if we aren't skipping code */        objword = comb (sou, des); /* create instruction from source and dest */        ncurloc = curloc + 1; /* advance */      end; /* of not skipping code */    end; /* of case for instruction */    if scan.flag then do; /* rest of line to be scanned, and code emitted */      call skips;      if (pri.loc and (if_level = skip_level)) then do; /* print the location number */        call tab (locpos); call poct (curloc);      end;      call tab (objpos);      if (curloc <> ncurloc) or (pri.obj) then call poct (objword);      call tab (lnpos); call pnum (lnum);      if plab (0) <> 0 then do; /* print label */        call tab (labpos); call ps (plab); call pc (a.colon);      end;      if popc1 (0) <> 0 then do; call tab (opcpos); call ps (popc1); end;      if textf then do; /* text line */        call tab (topos); call pc (objword); /* print this one */        if shr(objword, 8) <> 0 then call pc (shr(objword, 8)); /* and second byte if one */        if if_level = skip_level then call writeobj (objword); /* write first word */        do while nchr <> 0; /* loop until eol */          objword = nchr; nchr = gb; /* output this one, get next */          if nchr <> 0 then do; objword = objword or shl(nchr, 8); nchr = gb; end; /* and second */          if if_level = skip_level then do; /* only write out if active */            call writeobj (objword);            call nl; call tab (locpos);            call poct (ncurloc); ncurloc = ncurloc + 1;            call tab (objpos); call poct (objword);            call tab (topos);          end;          call pc (objword);          if shr(objword, 8) <> 0 then call pc (shr(objword, 8)); /* print it */        end; /* of do while */      end; /* of case for text */      else do; /* not text */        if pto (0) <> 0   then do; call tab (topos);  call ps (pto);   end;        if popc2 (0) <> 0 then do; call tab (op2pos); call ps (popc2); end;        if nchr <> 0 then call tab (cm2pos); /* space out for comment */        if curloc <> ncurloc then call writeobj (objword); /* emit it */      end; /* of not text */      call scan.rest; /* scan and print rest of line */    end; /* of case to emit code */  end; /* of label or data line */  curloc = ncurloc; /* set location counter to next loc */  anylistf = (anylistf or listf); /* set if list flag ever on */  nchr = gb; /* get first byte of next line number */end; /* of pass 2 loop */if ((if_level <> 0) or (skip_level <> 0)) /* make sure we found our share of ENDIFs */then call erm ('Missing ENDIF');/* $subtitle  Print Out Stats and Symbols, and Clean Up */dcl count    fixed; /* count of symbols printed */dcl cnam (f#name_len) fixed; /* holds name for change */call strassign (title, ''); call strassign (stitle, ''); /* clear titles */call flushobj; /* force out last buffer load */if anylistf then do; /* print stats if any pages listed */   listf = 1; /* turn list on */   call header; /* go to new page */   call nl;   call ps ('Assembly statistics'); call nl;   call nl; call nl;   call ps ('Length of object code : '); call poct (objlngth); call ps (' octal');   call nl;   call ps ('Number of errors      : '); call pnum (nerrors);   call nl;   call ps ('Total symbols defined : '); call pnum (stab (0) - sys.symb);   call nl; call nl; call nl;   call ps ('Symbol table');   call nl; call nl;   count = 0; /* init symbol counter */   do i = 0 to stab (0) - 1; /* loop over all entries in table */      if sflag (i) = usersymb then do; /* print if its a user symbol */         j = 20* (count mod 6); /* starting column for this entry */         call tab (j); /* tab to start */         call extsym (lab, i); /* get a symbol */         call ps (lab); call tab (j + 10); /* print name */         call poct (sval (i)); /* print value */         if (count mod 6) = 5 then call nl; /* print in six columns */         count = count + 1; /* add to count */      end;   end; /* of symbol loop */   call nl; call top; /* go to top of page */end; /* stats printing */if nerrors > 0 then call exit(-1); /* skip if errors *//* successful assembly - save as current file */  do i = 0 to f#name_len; /* get current file name */   cnam (i) = core(loc.cfn + i);end;i = cnam (0); /* get number of chars */if i > 7 then i = 7; /* take only first seven chars */call pbyte(cnam, i, a.period); /* add dot at end to mean compiled */cnam (0) = i + 1; /* and add to length */do i = 0 to f#name_len; /* restore file name */  core(loc.cfn + i) = cnam (i);end;core(loc.cmed) = 0; /* indicate disk file */core(loc.csec + 1) = objdev; /* indicate device */core(loc.csec) = objstart; /* indicate starting sector */core(loc.csln) = shr(objlngth + 255, 8); /* length in sectors */core(loc.clen) = objlngth; /* and number of words in it */core(loc.ftyp) = 1; /* indicates executable file */core(loc.strd) = 1; /* indicate stored (in .WORK) */core(loc.svd) = 0; /* but the user hasn't saved it! */core(loc.rst)  = 2; /* return code to monitor */print 'Object file length : ', octal(objlngth), ' octal';print 'Assembly successful - current file is now called "', string(cnam), '"';call overlay (core(loc.mon + 1), core(loc.mon), core(loc.mon - 1));print 'System error in overlay to MONITOR.';call exit(-1);