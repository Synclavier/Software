/* ASM-2  $title  N.E.D. Able Series Assembler, Part 2 *//* character and byte read and scan routines */gb:  proc fixed; /* procedure to get next byte */   dcl (msw,lsw) fixed;   if bc = 0 then do; /* must get next word */      if sfflp ige sflngth then do; /* end of current file - check for pop */         if cfname (0) = 0 then return (-1); /* final eof */         call popfile; /* pop up a file */         return gb; /* call ourselves at new level */      end;      if sfpos = sfbufl then do; /* end of this buffer load - get next one */         sfsec = sfsec + shr(sfbufl,8); /* incr length */         readl = sflngth - sfflp;         if readl igt sfbufl then readl = sfbufl; /* only read a buffer load */         msw = sfdev;         lsw = sfstart + sfsec;         if lsw ilt sfstart then msw = msw + 1;         call readdata (msw,lsw, sfbuf, readl); /* get it all */         sfpos = 0; /* start at beginning of buffer */      end;      word = sfbuf (sfpos); /* get word */      sfpos = sfpos + 1; sfflp = sfflp + 1; /* increment buffer and file position */      bc = 1; /* set byte toggle */      return (word and "377");   end; /* of case for next word */   else do;      bc = 0; /* clear byte toggle */      return shr(word, 8);   end;end gb;ungc: proc; /* return last character read to input buffer */   if bc = 0 then bc = 1; /* just re-read upper byte of WORD */   else do; /* if we just read the lower byte, we need to be smarter */      bc = 0; /* force ourselves to re-read the lower byte */      sfpos = sfpos - 1;  sfflp = sfflp - 1; /* back up pointers */   end;end ungc;gc:  proc; /* procedure to get next uppercase char (calls gb) */   dcl ch fixed;   ch = gb; /* get byte */   if (ch >= l.a) and (ch <= l.z) then return ch - "40"; /* return upcased char */   return ch; /* return byte (or EOF) as char */end gc;prime:  proc; /* prime the input buffer and initialize state variables */   sfdev   = core(loc.csec + 1); /* source file device */   sfstart = core(loc.csec); /* source file start and length */   sflngth = core(loc.clen);   cfname (0) = 0; /* mark name as current file */   sfsec = 0; sfflp = 0; sfpos = 0; /* init file pointers */   stkptr = 0; /* init the stack */   readl = sflngth; /* read the first buffer */   if readl igt sfbufl then readl = sfbufl;   call readdata (sfdev, sfstart, sfbuf, readl);   bc = 0; nchr = gb; /* clear byte toggle and get first byte */end prime;skips:  proc; /* skip spaces in source */   do while (nchr == a.SP) or (nchr == a.ht); nchr = gc; end;end skips;scan.rest:  proc; /* scan rest of line and print if on pass 2 */   do while nchr <> 0; /* loop until end of line */      if pass = 2 then call pc (nchr); /* print if pass 2 */      nchr = gc; /* advance */   end;   if pass = 2 then call nl; /* new line if pass 2 */   if bc then nchr = gc; /* skip extra null at line end if odd */end scan.rest; erm:  proc(msg); /* print an error message */   dcl msg char;   call push (listf); listf = 1; /* save listing status and turn on */   call tab (17); call ps (msg);   call ps (' at line '); call pnum (lnum);   if cfname (0) <> 0 then do; /* add filename to error msg */      call ps (' in file '); call ps (cfname);   end;   call nl;   listf = pop; /* restore status */   nerrors = nerrors + 1; /* count errors */end erm;/* $subtitle  String Handling Routines, Object File Output */ strassign:  proc(a, b); /* string assign a < -b */   dcl (a, b) char;   dcl i      fixed;   do i = 0 to b (0) - 1;     call pbyte(a, i, byte(b, i));   end;   a (0) = b (0);end strassign; equal:  proc(a, b) fixed; /* return true if two strings equal */   dcl (a, b) char;   dcl i      fixed;   if a (0) <> b (0) then return 0;   do i = 0 to a (0) - 1;      if byte(a, i) <> byte(b, i) then return 0;   end;   return 1;end equal; concat:  proc(a, b, c); /* concat b and c to give a */   dcl (a, b, c)       char; /* a and c must not be the same */   dcl (lenb, lenc, i) fixed;   lenb = b (0); lenc = c (0); /* get lengths handy */   if addr(a (0)) <> addr(b (0)) then do; /* have to move b to a */      do i = 0 to lenb - 1; call pbyte(a, i, byte(b, i)); end;   end;       do i = lenb to lenb + lenc - 1; /* move to result */      call pbyte(a, i, byte(c, i - lenb));   end;   a (0) = lenb + lenc; /* store length of result */end concat; dcl objstart          fixed; /* starting sector of object code */dcl objdev            fixed; /* device to write to */dcl objsec            fixed; /* current sector to write to */dcl objbpos           fixed; /* position in buffer */dcl objlngth          fixed; /* length in words */dcl objbufln          lit  '512'; /* length of object buffer */dcl objbuf (objbufln) fixed; /* object buffer */ flushobj:  proc; /* flush out the object buffer */   dcl (msw,lsw) fixed;   msw = objdev;   lsw = objstart + objsec;   if lsw ilt objstart then msw = msw + 1;   call writedata (msw, lsw, objbuf, objbpos);   objsec = objsec + shr(objbpos, 8); /* point to next sector */   objbpos = 0; /* and reset word pointer */end flushobj; writeobj:  proc(word); /* write a word of object file */   dcl word fixed;   objlngth = objlngth + 1; /* keep track of length */   if objbpos = objbufln then call flushobj;   objbpos = objbpos + 1; /* point to next word in buffer */   objbuf (objbpos - 1) = word; /* save object code */end writeobj;/* $subtitle  Symbol Table Definitions and Routines *//* flag values */dcl usersymb      lit '1'; /* symbol defined by user (print out at end) */dcl builtinsymb   lit '2'; /* built - in symbol, such as D104, MR12I */dcl specsymb      lit '3'; /* special psuedo-op symbol, such as EJECT */dcl immedsymb     lit '4'; /* immediate symbol, 'IM' */dcl relimsymb     lit '5'; /* relative immediate, 'RE' */dcl undefsymb     lit '6'; /* undefined symbol */dcl glo.flag      fixed; /* flag value for current symbol */dcl sys.symb      fixed; /* number of predefined symbols */dcl stabl          lit '1250'; /* maximum number of symbols (about 1000 for user) */dcl stab (stabl*4) fixed; /* 8 char symbols */dcl sval (stabl)   fixed; /* values */dcl sflag (stabl)  fixed; /* flags *//* The symbol table is kept in a sorted order   so that binary search algorithm may be used. */ extsym:  proc(sym, num); /* extract symbol from symbol table entry 'NUM' */   dcl sym char;   dcl num fixed; /* index into table */   dcl i   fixed;   num = shl(num, 2); /* 4 words per symbol */   do i = 1 to symwl;      sym (i) = stab (num + i);   end;   sym (0) = 8;end extsym; putsym:  proc(sym, num); /* put symbol into symbol table at entry 'NUM' */   dcl sym char;   dcl num fixed;   dcl i   fixed;   num = shl(num, 2); /* 4 words per symbol */   do i = 1 to symwl;      stab (num + i) = sym (i);   end;end putsym; comp.sym:  proc(str1, str2) fixed; /* compare two symbols, return -NUM if str1 < str2 */   dcl (str1, str2) char;   dcl (a, b, i)     fixed;   do i = 1 to symwl; /* compare words */      a = str1 (i); b = str2 (i);      if a <> b then return (rot(a, 8) - rot(b, 8));   end;   return 0; /* equal */end comp.sym; sym.search:  proc(key); /* search for symbol, return location in symbol table */   dcl key char;   dcl i   fixed;   dcl (base, len, toplen, topbase) fixed;   base = 0; /* start at zero */   len = stab (0); /* length of table */   if len = 0 then return (-1); /* no symbols in table */   do i = key (0) to (symwl + symwl) - 1; call pbyte(key, i, 0); end; /* fill with nulls */       do while len > 1; /* perform binary search */      toplen = len - shr(len, 1);      len = len - toplen;      topbase = base + len;      if comp.sym (location(addr(stab (shl(topbase, 2)))), key) <= 0 then do;         base = topbase;         len = toplen;      end;   end; /* of do while */   /* check for correct symbol when finished */   if comp.sym (location(addr(stab (shl(base, 2)))), key) = 0 then return base;   return (-1); /* not found */end sym.search; /* $subtitle  Routine to Insert a Symbol, Search For Symbol, Get Symbol */ sym.ins:  proc(symb, val, flag); /* insert SYMB, with VAL and FLAGS */   dcl symb        char; /* symbol name */   dcl (val, flag) fixed; /* value and flag attributes of symbol */   dcl (tsym, sym) symbol; /* internal symbol spaces */   dcl copyit      lit 'write("362") = read("363")';   dcl (i, j, k)   fixed;       /* copy over symbol in case the string is packed against another */   do i = 0 to symwl; sym (i) = 0; end; /* null out */   do i = 0 to symb (0) - 1; /* copy symbol name */      call pbyte(sym, i, byte(symb, i) and "177");   end;   sym (0) = symb (0); /* copy length */       i = stab (0) - 1; /* index of largest symbol */   if i >= stabl then do; /* overflow */      call erm ('Symbol table overflow');      call fatal;   end;       stab (0) = stab (0) + 1; /* increment number of symbols */   do while i >= 0; /* loop backwards over locations */      if comp.sym (location(addr(stab (shl(i, 2)))), sym) < 0 then do; /* found place */         call putsym (sym, i + 1); /* store name */         sval (i + 1) = val; sflag (i + 1) = flag; /* store attributes */         return;      end;      else do; /* move up this symbol */         j = addr(stab (0)) + shl(i, 2) + 1;         k = j + 4;         write("303") = j; /* from */         write("302") = k; /* to */         copyit; copyit; copyit; copyit; /* move name */         sval (i + 1)  = sval (i); sflag (i + 1) = sflag (i); /* move attributes */      end; /* move up this symbol */      i = i - 1; /* move to next symbol */   end; /* of do while */   call putsym (sym, 0); /* store the symbol at entry 0 */   sval (0)  = val; sflag (0) = flag; /* store attributes */end sym.ins; srch:  proc(sym) fixed; /* search for symbol and return value and flags */   dcl sym char;   dcl p   fixed;   p = sym.search (sym); /* search for key */   if p >= 0 then do; /* found */      glo.flag = sflag (p); /* return flags in global var */      return sval (p); /* return value of symbol */   end;   if if_level <> skip_level /* if we're skipping this code */   then glo.flag = 0; /* then there's no error if the symbol isn't defined */   else do; /* we're not skipping this code */      glo.flag = undefsymb; /* undefined symbol */      if pass = 2 then do; /* error if undefined on second pass */         call concat (errormes, 'Undefined symbol "', sym); /* form error message */         call concat (errormes, errormes, '"');         call erm (errormes); /* print error message */      end;   end; /* of not skipping code */   return 0;end srch; gsymb:  proc(sym); /* read the next symbol from source */   dcl sym char;   dcl i   fixed;   do i = 0 to symwl; sym (i) = 0; end; /* set to null */   do while ((nchr >= a.A) and (nchr <= a.Z)) /* loop over chars of symbol */   or ((nchr >= a.0) and (nchr <= a.9)) /* symbol is a..z, 0..9, or dot */   or (nchr = a.period);      if sym (0) < symcl then do; /* take up to length of symbol */         call pbyte(sym, sym (0), nchr); sym (0) = sym (0) + 1; /* drop it in and count it */      end;      nchr = gc; /* get next char */   end; /* of do while */end gsymb; /* $subtitle  Initialize the Assembler */init:  proc; /* load the built-in symbols into the symbol table */   dcl (sym, res1, res2, res3, res4) symbol;   dcl i fixed;       print '*** Setting up built-in symbols';   do i = 0 to 127; /* devices */      call goct (res1, i); /* get octal */      call concat (sym, 'D', res1); /* make 'Dddd' */      call sym.ins (sym, i, builtinsymb); /* add to table as built-in */   end;       do i = 0 to 15; /* memory and register sources */      call goct (res1, i); /* get octal */      call concat (res2, 'R', res1); /* Rddd */      call sym.ins (res2, "300" + i, builtinsymb);      call concat (res3, res2, 'I'); /* RdddI */      call sym.ins (res3, "320" + i, builtinsymb);      call concat (res4, 'M', res2); /* MRddd */      call sym.ins (res4, "340" + i, builtinsymb);      call concat (res4, 'M', res3); /* MRdddI */      call sym.ins (res4, "360" + i, builtinsymb);   end;   call sym.ins ('MR12D', "360" + "12", builtinsymb); /* same as MR12I */       des:  proc(name, val, del); /* pack a destination symbol */      dcl name       char;      dcl (val, del) fixed;      call goct (res1, del); /* get octal */      call concat (res2, name, res1); /* get 'NAMEddd' */      call sym.ins (res2, val + del, builtinsymb); /* pack */   end des;       do i = 0 to 3; /* accumulator operations */      call des ('LOA', "200", i);      call des ('AND', "204", i);      call des ('ADD', "210", i);      call des ('SUB', "214", i);      call des ('XOR', "220", i);      call des ('RTL', "224", i);      call des ('OR' , "230", i);      call des ('LCM', "234", i);             call des ('TLOA', "240", i);      call des ('TAND', "244", i);      call des ('TADD', "250", i);      call des ('TSUB', "254", i);      call des ('BSOR', "260", i);      call des ('SHRA', "264", i);      call des ('ADC' , "270", i);      call des ('SBB' , "274", i);   end;       call sym.ins ('ATRA', "320", builtinsymb);  call sym.ins ('RTRA', "330", builtinsymb);   call sym.ins ('ATZE', "321", builtinsymb);  call sym.ins ('RTZE', "331", builtinsymb);   call sym.ins ('ATRC', "322", builtinsymb);  call sym.ins ('RTRC', "332", builtinsymb);   call sym.ins ('ATMI', "323", builtinsymb);  call sym.ins ('RTMI', "333", builtinsymb);   call sym.ins ('ATNV', "324", builtinsymb);  call sym.ins ('RTNV', "334", builtinsymb);   call sym.ins ('ATNZ', "325", builtinsymb);  call sym.ins ('RTNZ', "335", builtinsymb);   call sym.ins ('ATNC', "326", builtinsymb);  call sym.ins ('RTNC', "336", builtinsymb);   call sym.ins ('ATPL', "327", builtinsymb);  call sym.ins ('RTPL', "337", builtinsymb);   call sym.ins ('PCI', "377", builtinsymb);   call sym.ins ('...',   1, specsymb);  call sym.ins ('LIST',     2, specsymb);   call sym.ins ('EJECT', 3, specsymb);  call sym.ins ('DATA',     4, specsymb);   call sym.ins ('TEXT',  5, specsymb);  call sym.ins ('INSERT',   6, specsymb);   call sym.ins ('EQU',   7, specsymb);  call sym.ins ('SET',      7, specsymb);   call sym.ins ('TTL',   8, specsymb);  call sym.ins ('TTLS',     9, specsymb);   call sym.ins ('STTL',  9, specsymb);  call sym.ins ('LISTOFF', 10, specsymb);   call sym.ins ('IF',   11, specsymb);  call sym.ins ('ENDIF',   12, specsymb);   call sym.ins ('IM',   0, immedsymb);  call sym.ins ('RE',     0, relimsymb);       sys.symb = stab (0); /* count up predefined symbols */   objstart = core(loc.wsec); /* set object output to working file */   objlngth = 0; /* zero length for now */end init;