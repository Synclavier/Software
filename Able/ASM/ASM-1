/* ASM-1  $title  N.E.D. Able Series Assembler, Part 1 *//* This is a standard two pass assembler...  Before starting, the symbol table is filled with basic symbols.  like 'TRA' and 'LOA0'.  After that, the two passes go to work...  Pass1 will process the source file and produce a symbol table..  During this pass, everything is located and a value computed...  Pass2 will process the source again and produce an object file.  and a listing file.  During this pass, the symbols used must be.  defined.  This pass should also make sure that only two passes.  are needed:  various methods of changing the location counter.  between pass1 and pass2 are known and must be guarded against...    Input:    line numbered source file.    Output:   on termination,  current file is the object file.    Listing:  if selected,  sent to line printer during assembly*/pdl 256; /* define large pushdown stack */insert ':-xpl:literals'; /* general literals */insert ':-xpl:asciilit'; /* ASCII literals */insert ':-xpl:catrtns';  /* catalog routines *//* $subtitle  Definitions, Special Overlay and Exit Routines */dcl symwl   lit '4'; /* symbol length in words */dcl symcl   lit '8'; /* symbol length in chars */ dcl forward lit 'procedure';dcl char    lit 'array';dcl symbol  lit '(symwl) fixed';dcl lpp     lit '88'; /* lines per page */ overlay:  proc(device, start, len); /* used to overlay an object file */   dcl (device, start, len, i) fixed;   i = loc.load + 1; /* enter word 1 of loader routine */   write("300") = device; /* device/MS start */   write("301") = start; /* start */   write("302") = 0; /* dest */   write("303") = len; /* and len number to copy over */   write("320") = i; /* and enter highcore copy routine */end overlay;  exit:  proc(sts); /* special exit procedure */   dcl sts fixed;   core(loc.rst) = sts; /* store status for sed */   print;   call overlay (core(loc.mon + 1), core(loc.mon), core(loc.mon - 1));end exit;/* $subtitle  Output Primitives */dcl header        forward; /* routine to print page header */dcl out.dev       fixed; /* output dev:  "40" = printer, "50" = terminal */dcl listf         fixed; /* list flag:  1 = on, 0 = off */dcl lnum          fixed; /* line number */dcl pass          fixed; /* pass number */dcl errormes (40) fixed; /* to hold error message */dcl cfname (f#name_len) fixed; /* current file name */dcl title (40)    fixed; /* holds title */dcl stitle (40)   fixed; /* holds subtitle */dcl pagenum       fixed; /* page number */dcl curloc        fixed; /* assembly location counter */dcl lab           symbol; /* current symbol */dcl nerrors       fixed; /* number of errors encountered */dcl if_level      fixed; /* level of IF-nesting */dcl skip_level    fixed; /* skip source when this is less than IF_LEVEL */dcl lpos          fixed; /* horizontal position on line */dcl linc          fixed; /* line count */dcl top.linc      fixed; /* linc value for first text line */ when break then call exit(-1); /* return to monitor */pc:  proc(ch); /* print ch to printer */   dcl ch fixed;   ch = (ch and "177"); /* mask out */   if (ch = 0) or (not listf) then return; /* do nothing */   if out.dev = "50" then print character(ch),;   else                   send  character(ch),;   lpos = lpos + 1; /* increment line position */end pc;ps:  proc(str); /* print a string to tty using pc */   dcl str char;   dcl i   fixed;   do i = 0 to str (0) - 1; call pc (byte(str, i)); end;end ps;nl:  proc; /* print a newline */   if not listf then return; /* do nothing */   if out.dev = "50" then print;   else                   send;   lpos = 0; linc = linc + 1; /* update position pointers */   if linc = (lpp - 5) then call header; /* if start of new page */end nl; tab:  proc(pos); /* tab to position */   dcl pos fixed;   if not listf then return; /* skip if list not active */   if lpos >= pos then do; call pc (a.SP); return; end; /* past it already */   do while lpos < pos; call pc (a.SP); end; /* space out to position */end tab;pnum:  proc(val); /* print a decimal number */   dcl val        fixed;   dcl (go, i, r) fixed;   dcl powers     data (10000, 1000, 100, 10, 1);       go = 0; /* turn of leading zeroes */   do i = 0 to 4; /* loop over digits */      r = 0; /* assume zero */      if val >= powers (i) then do; /* got a non-zero */         r = val/powers (i); /* get digit */         go = 1; /* turn on */         val = val - (r*powers (i)); /* reduce number */      end;      if (go) or (i = 4) then call pc (a.0 + r);   end; /* of digits loop */end pnum;/* $page */top:  proc; /* advance to top of page */   linc = linc + 100;   if out.dev = "40" then do while linc <> (100 + lpp); call nl; end;   else                   do; call nl; call nl; end; /* two skips for terminal */   linc = 0; /* zero out count */end top;header:  proc; /* print out a header */   dcl (i, j) fixed;   if not listf then return; /* no header if not listing */   if linc <> 0 then call top; /* must move to top of page */   pagenum = pagenum + 1; /* inc page number */   call ps (cfname); call tab (12);    call ps ('New England Digital ABLE Series Assembler                 page ');   call pnum (pagenum); call nl;   call nl;   call tab (5); call ps (title); call nl;   if stitle (0) > 0 then do; /* print subtitle */      call tab (5); call ps (stitle);   end;   call nl;   call nl; /* blank line */   top.linc = linc; /* indicate this as first program text line on page */end header;poct:  proc(val); /* print octal value */   dcl val fixed;   dcl i   fixed;   // Octal output:   // do i = 0 to 15 by 3;   //    call pc (a.0 + (shr(val, 15 - i) and 7));   // end;      // Hexadeximal output   call pc (a.0);   call pc (l.x);      do i = 0 to 15 by 4;      dcl j fixed;      j = shr(val, 12 - i) and 15;            if (j < 10)         pc (a.0 + j);      else         pc (a.a + j - 10);   end;end poct; goct:  proc(res, val); /* get octal string for forming symbols */   dcl res        char; /* result */   dcl val        fixed; /* value */   dcl (i, j, go) fixed;       res (0) = 0; /* start length at zero */   go = 0; /* turn off zeros */   do i = 0 to 15 by 3; /* loop over digits */      j = shr(val, 15 - i) and 7;      if j > 0 then go = 1; /* non zero digit - turn on */      if (go) or (i = 15) then do;         call pbyte(res, res (0), a.0 + j);         res (0) = res (0) + 1;      end;   end; /* of digits loop */end goct; fatal:  proc; /* this error was fatal */   listf = 1; /* turn on print */   call nl;   call ps ('Fatal error'); call nl;   call exit(-1);end fatal;/* $subtitle  Source File Handling Routines */dcl sfbufl         lit '512'; /* length of source buffer */dcl sfbuf (sfbufl) fixed; /* buffer */dcl sfpos          fixed; /* source file buffer position */dcl sfsec          fixed; /* source file current sector (next one to read) */dcl sfflp          fixed; /* word equivalent of fsec */dcl sfdev          fixed; /* source file device */dcl sfstart        fixed; /* starting sector number */dcl sflngth        fixed; /* length in words */dcl newdisk        fixed; /* new diskette inserted flag */dcl bc             fixed; /* byte toggle  */dcl word           fixed; /* current word */dcl readl          fixed; /* read length */dcl nchr           fixed; /* current char */dcl catbuf (c#dir_max - 1) fixed; /* catalog buffer */dcl cache.num      fixed; /* no. of cached buffer */dcl disabled       boolean; /* true if caching is disabled *//* stacking routines */dcl stklen         lit '400'; /* stack definition */dcl stk (stklen)   fixed; /* the stack area */dcl stkptr         fixed; /* pointer to stack */push:  proc(word); /* push a word into the stack */   dcl word fixed;   if stkptr = stklen then do; /* stack overflow */      listf = 1; /* turn on print */      call nl; call ps ('Expression or insert level too complex at line ');      call pnum (lnum);      call fatal;   end;   stk (stkptr) = word;   stkptr = stkptr + 1;end push;pop:  proc fixed; /* recover word from stack */   if stkptr = 0 then do;      listf = 1; /* turn on print */      call nl; call ps ('Stack underflow (unmatched parentheses) at line ');      call pnum (lnum);      call fatal;   end;   stkptr = stkptr - 1;   return stk (stkptr);end pop;rchar:  proc; /* get char from terminal */   dcl ch fixed;   ch = read("50") and "177"; /* read char */   if ch = c.S then do while ch <> c.Q; ch = read("50") and "177"; end; /* handle not s, not q */   return ch;end rchar;get.response:  procedure; /* prompt and wait for new disk */   dcl i fixed;   print ' into the lower or rightmost';   print 'drive, and press <return> when ready ->',; /* prompt */   i = 0;   do while i <> a.CR; /* wait for carriage return */      i = rchar; /* get character */      if i = 0 then call exit(-1); /* stop if break */   end; /* of do while */   print;   call disable_cache(cache.num); /* disable caching */   disabled = true; /* cache has been disabled */end get.response;/* $subtitle  File Search and Open Routine */openfile:  proc(nam); /* open a file */   dcl nam   fixed array; /* name of file to open */   dcl found boolean; /* true if a file is found */   dcl i     fixed;   newdisk = 0; /* assume no new disk used */   found = false; /* file not found yet */   do while not found; /* repeat until file is found or a fatal error occurs */      i = 1; /* start search on current catalog */      do while (i >= 0) and (not found); /* search catalogs until file is found */         found = locate(nam,i); /* search catalog */         i = i - 1;         if disabled then do; /* cache is currently disabled */            cache.num = cache(c#bufptr,c#bufmed); /* cache this catalog */            disabled = false; /* cache is now enabled */         end;      end;      if not found then do; /* file not found */         print;         if (curtyp=0) or (curtyp = 2) then do; /* floppy - ask for next disk */            print 'Insert diskette containing file "',string(nam),'"',;            call get.response; /* prompt and wait for reply */            newdisk=1; /* new disk is being used */         end; /* FLOPPY */         else do; /* fatal error on winchester */            print 'Could not find file "', string(nam), '" at line ', lnum,;            if cfname (0) > 0 then print ' in file ', string(cfname);            else print;            call exit(-1);         end; /* winchester */      end;   end; /* of while file not found */   if f#type <> t#text then do; /* not a text file */      print;      print 'File "',string(nam),'" is not a text file',;      call exit(-1);   end;   end openfile;/* $subtitle  Push and Pop of Insert File *//* Push state variables of current file into stack   open up the file and initialize the file buffer. */pushfile:  proc(name); /* push current file and use insert file given by 'NAME' */   dcl name array;   dcl i    fixed;   do i = 0 to f#name_len; /* push name of current file */      call push (cfname (i));   end;   call openfile (name); /* open the file to get 'NEWDISK' variable */   call push (sfdev);   call push (sfstart);   call push (sflngth);   call push (sfflp);   call push (sfsec);   call push (sfpos);   call push (bc);   call push (word);   call push (lnum);   call push (nchr);   call push (newdisk);   call push (skip_level);   call push (if_level);   print '*** Inserting file ', string(name); /* tell user */   sfdev = f#ms_sector; /* set up for new file */   sfstart = f#ls_sector;   sflngth = f#words;   do i = 0 to f#name_len; /* set up name */      cfname (i) = name (i);   end;   readl = sflngth;   if readl igt sfbufl then readl = sfbufl;   call readdata (sfdev, sfstart, sfbuf, readl);   bc      = 0;   sfflp   = 0;   sfpos   = 0;   sfsec   = 0;   nchr    = 0;end pushfile;dcl erm proc(fixed array); /* procedure to print an error message */popfile:  proc; /* pop back to file prior to insert */   dcl i fixed;   dcl (msw,lsw) fixed;   if ((((if_level <> pop)) or (skip_level <> pop)) and (pass = 2)) /* make sure we end up where we started from */   then call erm ('Missing ENDIF');   newdisk = pop;   nchr    = pop;   lnum    = pop;   word    = pop;   bc      = pop;   sfpos   = pop;   sfsec   = pop;   sfflp   = pop;   sflngth = pop;   sfstart = pop;   sfdev   = pop;   do i = f#name_len to 0 by -1; /* recover name */      cfname (i) = pop;   end;   if newdisk then do; /* must refetch old disk */      if cfname (0) = 0 then print 'Reinsert original user diskette',;      else print 'Reinsert the diskette containing "', string(cfname), '"',;      call get.response;   end;   readl = sflngth - shr(sfsec, 8); /* read in the last buffer load */   if readl igt sfbufl then readl = sfbufl;   msw = sfdev;   lsw = sfstart + sfsec;   if lsw ilt sfstart then msw = msw + 1;   call readdata(msw,lsw,sfbuf,readl);end popfile;