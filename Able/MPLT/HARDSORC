module HARDRTNS;/* Insert all necessary Operating System literals explicitly */insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:plotlib';insert ':-xpl:catswap';insert ':-xpl:strings';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';insert ':mplt:harddcls';dcl d40pc lit '#ps_wchar';/* Module global declarations */dcl SYSTEM_FILE_LOOKUP procedure (fixed array) returns (boolean) external,    MAIN_MODE          fixed external;when d03int then begin;  insert ':mplt:io_timer';end;begin;/* D40 driver primitives */#HPNUM:procedure (X) public;  dcl (X,M,N) fixed,      SDIG    boolean;  call d40pc (32);  if X < 0 then do;    call d40pc (45);    X = -X;  end;  M = 10000; SDIG = false;  do while M > 0;    N = X / M;    X = X - N*M;    M = M / 10;    if N ~= 0 \ SDIG \ M = 0 then do;      SDIG = true;      call d40pc (48+N);    end;  end;end #HPNUM;#HONUM:procedure (X) public;  dcl (X,I) fixed;  X = rot(X,10);  do I = 1 to 3;    call d40pc (48+(X & 7));    X = rot(X,3);  end;end #HONUM;#HHNUM:procedure (X) public;  dcl (X,B,I) fixed;  X = rot(X,4);  do I = 1 to 4;    B = X & MASK4;    if B < 10 then call d40pc (asc.0 + B);              else call d40pc (asc.a + B - 10);    X = rot(X,4);  end;end #HHNUM;#HSTRING:procedure (STR) public;  dcl STR fixed array,      I   fixed;  do I = 0 to STR(0)-1;    call d40pc (byte(STR,I));  end;end #HSTRING;#HSTRINGR:procedure (STR) public;  dcl STR fixed array,      I   fixed;  do I = 0 to STR(0)-1;    call d40pc (byte(STR,I));  end;  hcr;end #HSTRINGR;#HSTRCHAR:procedure (C) public;  dcl C fixed;  if C < sp \ C > del then do;    call d40pc (bsl); honum(C);  end;  else do;    if C = lparen \ C = rparen \ C = bsl then call d40pc (bsl);    call d40pc (C);  end;end #HSTRCHAR;#HSTROBJ:procedure (STR) public;  dcl STR   fixed array,      (C,I) fixed;  call d40pc (sp);  call d40pc (lparen);  do I = 0 to STR(0)-1;    hstrchar(byte(STR,I));  end;  call d40pc (rparen);end #HSTROBJ;/* %subtitle PostScript driver routines */READ_PS_MESSAGE:procedure (MSG,MAX);  dcl MSG     fixed array,      (MAX,C) fixed;  if MAIN_MODE = TEST# then return (true);  call ps_flush; /* Wait for any chars to be sent */  MSG(0) = 0;  do forever;    C = ps_rmchar;    if C = -1 then return; /* Time out *//*    if C = ctrl.d then return; * Got an eot */    call pbyte(MSG,MSG(0),C);    MSG(0) = MSG(0) + 1;    if MSG(0) = MAX then return;  end;end READ_PS_MESSAGE;AQUIRE_PRINTER:procedure public swap;  dcl (F,G) boolean;  dcl C     fixed;  if ~d40_present then call ERROR (ERR_NOD40);  call PS_ENABLE ("40"); /* Enable D40 interrupts */  if MAIN_MODE ~= TEST# then F = true; /* Wait until printer responds */  G = false;	if (PS_PRINTER_WRITE_ONLY <> 0)	// skip waiting for printer if running on Mac		F = false;		  do while F;    hchar(ctrl.t);    call READ_PS_MESSAGE (BUFF,128);    if COMPARE(BUFF,'%%[ status: waiting; source: serial 25 ]%%')    then call CLOSE_PS_JOB;/*  if COMPARE(BUFF,'%%[ status: busy; source: serial 25 ]%%')    then call ps_rchar; */    if COMPARE(BUFF,'%%[ status: idle ]%%')    then F = false;    if F & ~G then do;      pos(13,23); reverse(1);      pstring(' Waiting for printer to respond ');      reverse(0); pos(16,0); flush_term; G = true;    end;    do while ~term_idle;      C = rchar;      if C = sp then do;        call PS_DISABLE;        call RE_START;      end;      else if C = asc.refresh then do;        clear_all;        G = false;      end;    end;  end;  if G then do;    pos(13,0); erase_line; pos(16,0);  end;  do while ~ps_idle;    call ps_rchar;  end;end AQUIRE_PRINTER;START_JOB:procedure public swap;  dcl (F,S) fixed; /* Fast and slow scan direction page sizes */  dcl (W,H) fixed; /* Temporaries */  /* Set the trim area to page area + margins */  W = DEC_ADD(PAGE_WIDTH,DEC_ADD(LEFT_MARGIN,LEFT_MARGIN));  H = DEC_ADD(PAGE_LENGTH,DEC_ADD(BOT_MARGIN,BOT_MARGIN));  hstring('/trim_w '); hpnum(shr(W,8)); hpnum(W & LBYTE); hstringr(' # def');  hstring('/trim_h '); hpnum(shr(H,8)); hpnum(H & LBYTE); hstringr(' # def');  /* Set imag_w to lessor of (mediawidth | default) and (trim_w | trim_h) */  /* Do the same thing for imag_h */  hstringr('/imag_w /imag_h');  do case PRINTER_TYPE;    ;    ;    hstringr('10.92 in def 8.0 in def');    hstringr('13.5 in def 8.0 in def');    hstringr('792 pt def 926 pt def');    hstringr('842 pt def 1853 pt def');    do;      hstringr('statusdict begin mediawidth end 72 div 300 mul def');      hstringr('statusdict begin medialength end 72 div 300 mul def');    end;  end;  /* Set the clip area to the trim area */  hstringr('/clip_w trim_w def /clip_h trim_h def');  /* Set overlap value from menu */  if OVERLAP ~= 0 then do;    hstring('/overlap ');    hpnum(shr(OVERLAP,8)); hpnum(OVERLAP & LBYTE); hstringr(' # def');  end;  /* Reload all these values we just set from the overlay file if there is one */  call SCAN_OVERLAY_FILE (0); /* Scan 'setup' page description */  /* If we're in landscape mode, swap trim dimentions */  if (FORMAT & F_LAND) ~= 0 then hstringr('/trim_w trim_h /trim_h trim_w def def');  /* Set various statusdict values for this job */  hstringr('statusdict begin');  if PRINTER_TYPE > 3 then do; /* This printer supports setpageparams */    hstringr('trim_w .75 in add trim_dx add');    hstringr('dup imag_w lt {/imag_w exch def} {pop} ifelse');    hstring('imag_h 300 div 72 mul ');    hstring('imag_w 300 div 72 mul ');    hstringr('0 0 setpageparams');  end;  hstringr('/waittimeout 300 def'); /* Long enough wait for any page! */  if (FORMAT & F_MANFD) ~= 0 /* Manual feed */  then hstringr('/manualfeed true def');  hstringr('end'); /* Finished with statusdict */  /* Set working unit size to 1/300 to match laser printer output */  hstringr('72 300 div dup scale');end START_JOB;SETUP_PAGE:procedure (HORIZONTAL_PAGE,VERTICAL_PAGE) returns (fixed) public swap;  dcl HORIZONTAL_PAGE fixed;  dcl VERTICAL_PAGE   fixed;  dcl TILE_STATE      fixed;  /* Translate to current tile position */  if OVERLAP ~= 0 then do;    hpnum(HORIZONTAL_PAGE);    hpnum(VERTICAL_PAGE);    hstringr(' tile');    TILE_STATE = ps_rchar - asc.0;  end;  else TILE_STATE = 3;  /* Establish trim rect and print crop marks */  hstringr('trim');  /* Setup mirror image if reverse reading */  if (FORMAT & F_FWDR) = 0 then hstringr('trim_w 0 T -1 1 SC');  /* Setup sideways image if landscape orientation */  if (FORMAT & F_LAND) ~= 0 then hstringr('trim_w 0 T 90 R');  /* Establish image (clip) rect */  hstringr('clip');  return TILE_STATE;end SETUP_PAGE;PAGE_FRAME:procedure swap;  dcl INSNAME    boolean,      (TI,ST)    boolean,      (P,I,C)    fixed,      STR1(6)    fixed;  P = NAME_BASE + DISPLAY(0) * 18; INSNAME = false;  if STAVES = 0 & core(P) ~= 0 then do;    INSNAME = true; /* I = core(P) * 10; */  end;  else if STAVES = 1 & core(P) = 0 then do;    P = P + 18;    if core(P) ~= 0 then do;      INSNAME = true; /* I = core(P) * 10; */    end;  end;  if INSNAME then do;    /*hstringr(' exch sub -45 M'); */    call blockmove (loc(P),BUFF,9);    if ~PAGE_CNT then I = PIXEL_WIDTH - STRING_LEN (BUFF,F_STANDARD#); /* Even numbered page */                 else I = 0; /* Odd numbered page */    call INSNAME_STR (BUFF);    UPPER_FONT = F_MUSIC#;    LOWER_FONT = F_STANDARD#;    call PLOT_STRING (BUFF,I+3,-11,BUFF(0),1);  end;  call SET_FONT (F_SUBTITLE#);  if INIT_PAGE > 0 then do;    if ~PAGE_CNT then do; /* Even numbered page */      call NUM_TO_STR (STR1,PAGE_CNT);      hstring('0 -45 M'); hstrobj(STR1); hstringr(' H');    end;    else do; /* Odd numbered page */      call NUM_TO_STR (STR1,PAGE_CNT);      hstrobj(STR1);      hstring(' dup stringwidth pop'); hpnum(PIXEL_WIDTH*4);      hstringr(' exch sub -45 M H');    end;  end;  TI = false;  ST = false;  if PAGE_CNT = INIT_PAGE \ (INIT_PAGE = 0 & PAGE_CNT = 1) then do; /* This is the title page */    /* Left subtitle */    P = TEXT_BASE + 41;    if core(P) ~= 0 then do;      hstring('0 -225 M'); hstrobj(location(P)); hstringr(' H');      ST = true;    end;    /* Right subtitle */    P = P + 41;    if core(P) ~= 0 then do;      hstrobj(location(P));      hstring(' dup stringwidth pop'); hpnum(PIXEL_WIDTH*4);      hstringr(' exch sub -225 M H');      ST = true;    end;    /* Title */    P = TEXT_BASE;    if core(P) ~= 0 then do;      call SET_FONT (F_TITLE#);      hstrobj(location(P));      hstring(' dup stringwidth pop'); hpnum(PIXEL_WIDTH*4);      hstringr(' exch sub 2 div -150 M H');      TI = true;    end;    /* Copyright line */    P = TEXT_BASE + 3*41;    if core(P) ~= 0 then do;      call SET_FONT (F_SUBTITLE#);      /* Translate down to bottom of page */      hstringr('GS');      hstring('0 '); hpnum(shr(PAGE_LENGTH,8)); hpnum(PAGE_LENGTH & LBYTE);      hstring(' #');      hpnum(SCALE_FACTOR & LBYTE); hpnum(shr(SCALE_FACTOR,8));       hstringr(' div mul - T');      /* Find centered position for text */      hstrobj(location(P));      hstring(' stringwidth pop'); hpnum(PIXEL_WIDTH*4);      hstringr(' exch sub 2 div 100 T'); /* Set height above bottom here */                  /* WAS        10  */      do I = 0 to core(P) - 1;        if byte(location(P),I) = asc.at        then call pbyte(location(P),I,"323");      end;      UPPER_FONT = F_SYMBOL#;      LOWER_FONT = F_SUBTITLE#;      call PLOT_STRING (location(P),3,0,core(P),1);      hstringr('GR');    end;  end;  /* A spacing of -60 will place the bottom of the page number line (or     subtitle line for title page) on the middle line of an imaginary staff     above the top staff of music. */  hstringr('0 -60 T'); /* Room for Page Number line - Adjust here for title-to-music spacing *//*  if TI then */ hstringr('0 -120 T'); /* Room for Title line *//*  if ST then */ hstringr('0 -60  T'); /* Room for Subtitle line */  hpnum(0); hpnum(STAFF_SPACE(DISPLAY(0))*4/4);  hstringr(' T');                  /* Center staves between title & copy lines */  end PAGE_FRAME;MUSIC_PAGE:procedure public swap;  hstringr('2 setlinewidth 0 setlinecap .5 .5 translate');  /* Establish music page area */  hpnum(shr(LEFT_MARGIN,8)); hpnum(LEFT_MARGIN & LBYTE); hstring(' #');  if OVLY_BASE = null & (FORMAT & F_LAND) ~= 0 then do;    hstring(' clip_h');    hpnum(shr(PAGE_LENGTH,8)); hpnum(PAGE_LENGTH & LBYTE);    hstring(' # sub');  end;  else do;    hpnum(shr(BOT_MARGIN,8)); hpnum(BOT_MARGIN & LBYTE); hstring(' #');  end;  hstringr(' T');  /* Translate to music origin */  hstring('0'); hpnum(shr(PAGE_LENGTH,8)); hpnum(PAGE_LENGTH & LBYTE);  hstringr(' # page_top_mrgn sub T');  /* Scale to correct scale factor */  hpnum(shr(SCALE_FACTOR,8)); hpnum(SCALE_FACTOR & LBYTE);  hstringr(' div dup SC');  /* Print old style titles, etc. */  if OVLY_BASE = null then call PAGE_FRAME;  hstringr('0 -360 T'); /* Offset down to staff origin (-90) */end MUSIC_PAGE;CLOSE_PS_JOB:procedure public swap;  dcl C fixed;  hchar(ctrl.d);        /* Send EOF */  call ps_flush; /* Wait until last char is sent out to printer */  CATCH_PS_ERRORS = false;end CLOSE_PS_JOB;FINISH_ENGRAVING:procedure public swap;  if MAIN_MODE = TEST# then hchar(ff); /* Eject page if not talking to PostScript */  call CLOSE_PS_JOB;  call PS_DISABLE;  if PS_ERROR_PRESENT then do;    crlf;    pstring('Press <RETURN> to continue: ');    call rchar;  end;end FINISH_ENGRAVING;CLEAR_LASER_PRINTER:procedure public swap;  call CLOSE_PS_JOB;  call ps_disable; /* Turn off D40 interrupts */end CLEAR_LASER_PRINTER;encrypt: proc(buf,len) swap; /* encrypts an array with the given key (from DISKLOCK) */   dcl buf      fixed array;     /* array to encrypt */   dcl len      fixed;           /* length of array in words */   dcl password data ('Dont change this pass word. EVER!'); /* password */   dcl (i,j,k)  fixed;		// For now, process un-encrypted prolog files.	return;	   i=0; j=password(0);   do while i ILT len;           /* encrypt array */      k=byte(password,j-1);      buf(i)=buf(i) xor ((k\shl(not k,8)) xor (i+j)); /* !!!! */      i=i+1; j=j-1;      if j=0 then j=password(0);   end;end encrypt;DUMP_PROLOGUE:procedure public swap;  dcl (C,I,J) fixed,      S(1)    fixed,      CB      fixed,      LN      boolean;  dcl BUFSIZ lit '4096'; /* This must be 2^N */  if MAIN_MODE = TEST# then return; /* ***** */  /* Examen printer to see if we need to send the prologue */	if (!PS_EMIT_FONTS)		return;		  /* Examen printer to see if we need to send the prologue */  if (PS_PRINTER_WRITE_ONLY == 0) {	  hstringr('FontDirectory /NEDMusicFont known {(Y)} {(N)} ifelse print flush');	  C = ps_rchar;	  if C = asc.y then do;		return;	  end;	  else if C ~= asc.n then do;		call SYSERROR ('Bad printer response to prologue presence query');		call PS_ENABLE ("40");		return;	  end;		  if ~SYSTEM_FILE_LOOKUP ('.SPRO-7') then call ERROR (ERR_NOSPRO);		  hstringr('serverdict begin 0 exitserver'); /* Cause printer to save this job permanently */	  call READ_PS_MESSAGE (BUFF,128);	  if ~COMPARE(BUFF,'%%[ exitserver: permanent state may be changed ]%%	')	  then call SYSERROR ('Bad printer response to download sequence');		  flush_term;	  CATCH_PS_ERRORS = true;	}	else if ~SYSTEM_FILE_LOOKUP ('.SPRO-7') then call ERROR (ERR_NOSPRO);  I    = F#WORDS;  LN   = true;  S(1) = F#MS_SECTOR;  S(0) = F#LS_SECTOR;  CB   = CORE_BASE + C#DIR_MAX;  do while I igt 0;    if I ile BUFSIZ then do; J = I;      I = 0;          end;                    else do; J = BUFSIZ; I = I - BUFSIZ; end;    call readdata (S(1),S(0),location(CB),J);    call ENCRYPT (location(CB),J);    write(R13) = CB; /* Set R13 to base of buffer */    do J = 1 to J; /* Loop over buffer or portion thereof */      C = read(MR13I); /* Read a word from buffer */      if LN then LN = false; /* Skip over line number */      else if (C & UBYTE) = 0 then do; /* Last word in line */        if (C & LBYTE) ~= 0 then hchar(C);        hchar(cr); /* Send newline */        LN = true; /* Next word will be a line number */      end;      else do;        hchar(C & LBYTE); /* Send lower char */        hchar(shr(C,8));  /* Send upper char */      end;    end;    call ADD32 (S,shr(BUFSIZ,8));  end;  call CLOSE_PS_JOB;end DUMP_PROLOGUE;dcl OVLY_FPOS fixed;dcl OVLY_PAGE fixed;dcl OVLY_PS   boolean;dcl SCAN      boolean;dcl CONTINUE  boolean;dcl CARRY     boolean;dcl MOVE_DOWN boolean;dcl X_ALIGN   fixed;dcl Y_ALIGN   fixed;dcl SYSTEMS   fixed;dcl LEFT#     lit '0',    CENTER#   lit '1',    RIGHT#    lit '2',    TOP#      lit '0',    BOTTOM#   lit '2';dcl COMMENT_CHAR# lit 'asc.gt',    COMMAND_CHAR# lit 'hash';dcl FINISH_LINE lit 'if CARRY then call SHOW_LINE('''')';PS_OCT_CHAR:procedure (BUFF,X) public swap7; /* Converts a number to a string */  dcl BUFF fixed array,  /* String array */      X    fixed,        /* Number */      I    fixed;  BUFF(0) = 1;  call pbyte(BUFF,0,bsl);  X = rot(X,10);  do I = 1 to 3;    call pbyte(BUFF,BUFF(0),48+(X & 7));    X = rot(X,3);    BUFF(0) = BUFF(0) + 1;  end;end PS_OCT_CHAR;GET_LINE:procedure (LINE) returns (boolean) swap7;  dcl LINE fixed array;  dcl L    fixed;  write(SECT$) = OVLY_BASE + shr(OVLY_FPOS,8);  write(WORD$) = OVLY_FPOS;  L = read(DATA$);  if L = 0 then return FALSE;  L = (L+1)/2+1;  call import (OVLY_BASE,OVLY_FPOS,LINE,L);  OVLY_FPOS = OVLY_FPOS + L;  /* Clean line */  do while LINE(0) > 0 & byte(LINE,LINE(0)-1) = 0;    LINE(0) = LINE(0) - 1;  end;  return TRUE;end GET_LINE;REST_OF_LINE:procedure (TOKEN);  dcl TOKEN fixed array;  dcl I     fixed;  call strtok(TOKEN,'');  I = index(TOKEN,'>',0);  if I > -1 then TOKEN(0) = I;end REST_OF_LINE;SHOW_LINE:procedure (LINE) swap7;  dcl LINE       fixed array;  dcl CARRIED_TO boolean;  if OVLY_PS then do;    if LINE(0) > 0 then hstringr(LINE);  end;  else do;    if ~CARRY then hstringr('mark');    if LINE(0) > 0 then do;      CARRIED_TO = CARRY;      if byte(LINE,LINE(0)-1) = bsl then do;        CARRY = true;        LINE(0) = LINE(0) - 1;      end;      else CARRY = false;      if ~CARRIED_TO then hstringr('cur_x cur_y moveto');      if CARRY | CARRIED_TO then hstring('currentfont ');      hchar(lparen); hstring(LINE); hchar(rparen);      do case X_ALIGN;        ;        hstring(' center');        hstring(' right');      end;    end;    else CARRY = false;    if ~CARRY then do case Y_ALIGN;      hstring(' top');      ;      ;    end;    hcr;    if ~CARRY then hstringr('showline /cur_y cur_y fontsize leading add sub def');    if Y_ALIGN ~= TOP# then MOVE_DOWN = TRUE;  end;end SHOW_LINE;COMMAND_LINE:procedure (LINE) returns (boolean) swap7;  dcl LINE      fixed array;  dcl TOKEN(32) fixed;  dcl I         fixed;  dcl X_FLAG    boolean;  dcl RETURN_ON_COMMENT lit 'if byte(TOKEN,0) = COMMENT_CHAR# then return TRUE';  OVLY_PS = FALSE;  call STRNTIN(LINE, 1, LINE(0));  do while core(STRTOK(TOKEN,' ')) ~= 0; /* This may not need to loop */    RETURN_ON_COMMENT;    if COMPARE(TOKEN,'page') then do;      FINISH_LINE;      if SCAN & ~CONTINUE then return FALSE;      call STRTOK(TOKEN,' ');           if COMPARE(TOKEN,'even')  then SCAN = ((OVLY_PAGE & MASK1) = 0);      else if COMPARE(TOKEN,'odd')   then SCAN = ((OVLY_PAGE & MASK1) = 1);      else if COMPARE(TOKEN,'setup') then SCAN = (OVLY_PAGE = 0);      else if COMPARE(TOKEN,'all')   then SCAN = (OVLY_PAGE > 0);      else SCAN = (OVLY_PAGE = STR_TO_NUM(TOKEN));      call STRTOK(TOKEN,' ');      if COMPARE(TOKEN,'continue') then CONTINUE = TRUE;                                   else CONTINUE = FALSE;    end;    if ~SCAN then return TRUE;    if COMPARE(TOKEN,'postscript') then do;      FINISH_LINE;      OVLY_PS = TRUE;    end;    else if COMPARE(TOKEN,'font') then do;      call STRTOK(TOKEN,' ');      if COMPARE(TOKEN,'music') then hstring('OMF ');      else if COMPARE(TOKEN,'ext') then do;        call STRTOK(TOKEN,' ');        hchar(slash); hstring(TOKEN);        hstring(' findNEDfont ');      end;      else do;        hchar(slash); hstring(TOKEN);        hstring(' findfont ');      end;      call REST_OF_LINE(TOKEN); hstring(TOKEN);      if MOVE_DOWN then hstring(' 1'); else hstring(' 0');      hstringr(' setfontsize setfont');     end;    else if COMPARE(TOKEN,'leading') then do;      FINISH_LINE;      hstring('/leading ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' def');    end;    else if COMPARE(TOKEN,'move') then do;      FINISH_LINE;      X_FLAG = TRUE;      do while core(STRTOK(TOKEN,' ')) ~= 0;        RETURN_ON_COMMENT;        if compare(TOKEN,'auto') then do;          if X_FLAG then do case X_ALIGN;            hstring('0 ');            /* Left */            hstring('clip_w 2 div '); /* Center */            hstring('clip_w ');       /* Right */          end;          else do case Y_ALIGN;            hstring('clip_h '); /* Top */            hstring('clip_h 2 div '); /* Center */            hstring('0 '); /* Bottom */          end;        end;        else do;          hstring(TOKEN); hchar(sp);        end;        X_FLAG = FALSE; /* First token is x-auto or there is no x-auto */      end;      hstringr('/cur_y exch def /cur_x exch def');      MOVE_DOWN = false;    end;    else if COMPARE(TOKEN,'align') then do;      call STRTOK(TOKEN,' ');      if      COMPARE(TOKEN,'right')  then X_ALIGN = RIGHT#;      else if COMPARE(TOKEN,'center') then X_ALIGN = CENTER#;      else if COMPARE(TOKEN,'left')   then X_ALIGN = LEFT#;      call STRTOK(TOKEN,' ');      if      COMPARE(TOKEN,'top')    then Y_ALIGN = TOP#;      else if COMPARE(TOKEN,'center') then Y_ALIGN = CENTER#;      else if COMPARE(TOKEN,'bottom') then Y_ALIGN = BOTTOM#;    end;    else if COMPARE(TOKEN,'trim') then do;      hstring('/trim_w ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /trim_h exch def def');    end;    else if COMPARE(TOKEN,'trimoff') then do;      hstring('/trim_dx ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /trim_dy exch def def');    end;    else if COMPARE(TOKEN,'image') then do;      hstring('/clip_w ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /clip_h exch def def');    end;    else if COMPARE(TOKEN,'imageoff') then do;      hstring('/clip_dx ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /clip_dy exch def def');    end;    else if COMPARE(TOKEN,'printer') then do;      hstring('/imag_w ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /imag_h exch def def');    end;    else if COMPARE(TOKEN,'pageno') then do;      call NUM_TO_STR (TOKEN,OVLY_PAGE);      call pbyte (TOKEN,TOKEN(0),bsl); TOKEN(0) = TOKEN(0) + 1;      call SHOW_LINE (TOKEN);    end;    else if COMPARE(TOKEN,'symbol') then do;      call STRTOK(TOKEN,' ');      I = STR_TO_NUM(TOKEN) + "177";      call STRTOK(TOKEN,' ');      if COMPARE(TOKEN,'e') then I = I - "177";      call PS_OCT_CHAR (TOKEN,I);      call pbyte (TOKEN,TOKEN(0),bsl); TOKEN(0) = TOKEN(0) + 1;      call SHOW_LINE (TOKEN);    end;    else if COMPARE(TOKEN,'shift') then do;      FINISH_LINE;      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' translate');    end;    else if COMPARE(TOKEN,'music') then do;      FINISH_LINE;      call STRTOK(TOKEN,' ');      SYSTEMS = STR_TO_NUM(TOKEN);      hstring('/page_top_mrgn ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' def');    end;  end;    return TRUE;end COMMAND_LINE;SCAN_OVERLAY_FILE:procedure (PAGE) returns (fixed) public;  dcl PAGE      fixed;  dcl LINE(128) fixed;  dcl MORE      boolean;  if OVLY_BASE = null then return -1;  OVLY_PAGE = PAGE;  SCAN      = FALSE;  CONTINUE  = FALSE;  CARRY     = FALSE;  MOVE_DOWN = FALSE;  OVLY_FPOS = 0;  X_ALIGN   = LEFT#;  Y_ALIGN   = TOP#;  SYSTEMS   = 0;  MORE = TRUE;  do while MORE;    MORE = GET_LINE(LINE);    if MORE then do;      if byte(LINE,0) = COMMAND_CHAR#      then MORE = COMMAND_LINE(LINE);      else if SCAN then call SHOW_LINE(LINE);    end;  end;  FINISH_LINE;  return SYSTEMS;end SCAN_OVERLAY_FILE;end;end HARDRTNS;