FIND_CONTROL_POINTS:procedure (MAT,DIR) public swap2;  dcl MAT     fixed array,      DIR     fixed,      (DX,DY) floating,      (A,D,E) floating,      (R,S)   floating,      SMALL   boolean;  DX = MAT(6) - MAT(0);  DY = MAT(7) - MAT(1);  if DY = 0 then D = DX;            else D = sqr(DX*DX+DY*DY);  if      DY > 0 & abs(DX)*10000 < abs(DY) then R =  1.570796; /*  90 deg */  else if DY < 0 & abs(DX)*10000 < abs(DY) then R = -1.570796; /* -90 deg */                                           else R = atn(DY/DX);  if D = 0 then do;    MAT(2) = MAT(0);    MAT(3) = MAT(1);    MAT(4) = MAT(6);    MAT(5) = MAT(7);    return;  end;  if D < 100 then do;    SMALL = true;    E = D / 4.5;    E = E + E * (100-D)/200;/*  E = E + E * (100-D)/100; *//*  A = atn(100/D);  */    if D < 70 then D = 70;    A = atn(70/D);  end;  else if D < 200 then do;    SMALL = false;    E = D / 4.5;/*  if E > 100 then E = 100; *//*  A = .785398;  * 45 deg */    A = atn(70/100);  end;  else do;    SMALL = false;    E = (200 / 4.5) * 200 / D;/*  if E > 100 then E = 100; *//*  A = .785398;  * 45 deg */    A = atn(70/100);  end;  S = R + A*DIR;  DX = E * cos(S);  DY = E * sin(S);  if SMALL then do;    MAT(2) = MAT(0) + int(DX);    MAT(3) = MAT(1) + int(DY);  end;  else do;    MAT(2) = MAT(0) + int(DX/4) * 4;    MAT(3) = MAT(1) + int(DY/3) * 3;  end;  S = R + 3.141592 - A*DIR;  DX = E * cos(S);  DY = E * sin(S);  if SMALL then do;    MAT(4) = MAT(6) + int(DX);    MAT(5) = MAT(7) + int(DY);  end;  else do;    MAT(4) = MAT(6) + int(DX/4) * 4;    MAT(5) = MAT(7) + int(DY/3) * 3;  end;  return (SMALL);end FIND_CONTROL_POINTS;POSITION_NSLUR:procedure (BUFF,PP,SX) swap2;  /* This routine preserves xmem registers */  dcl SEARCH_X procedure (fixed,fixed,fixed) external;  dcl BUFF    fixed array, /* Holds the edit record */      PP      pointer,     /* Position pointer */      (SX,EX) fixed,       /* X position */      DIR     boolean,     /* Symbol direction */      TYPE    boolean,      DRAW    boolean,      (S,W)   fixed,      MAT(7)  fixed,       /* Slur point matrix */      (XA,YA) fixed,      (XADV,YADV) fixed,      MULT    fixed,      MODE    fixed,      (C,I)   fixed;  vector_mode; data_level (2);  S = read(SECT$);   /* Save xmem registers */  W = read(WORD$);  DIR = (BUFF(1) & R_DIR) ~= 0; /* Symbol direction */  DIR = CONV(DIR);  EX = SEARCH_X(PP,BUFF(2),SX);  MAT(0) = SX + EXPAND(shr(BUFF(1),6),6) * 4;  MAT(1) = (BUFF(1) & MASK6) * 3;  MAT(6) = EX + EXPAND(shr(BUFF(3),6),6) * 4;  MAT(7) = (BUFF(3) & MASK6) * 3;  BUFF(1) = BUFF(2);  XADV = 4; YADV = 3; DRAW = false; TYPE = 0;  C = ht; MODE = 0; SLUR_GRAIN = .05;  do while C ~= cr & C ~= kp.enter;    XA = 0; YA = 0;    if C = ht then do;      if FIND_CONTROL_POINTS (MAT,DIR) then BUFF(1) = BUFF(1) |  R_SMSLR;                                       else BUFF(1) = BUFF(1) & ~R_SMSLR;    end;    else if C = cur.left  then XA = -XADV;    else if C = cur.right then XA =  XADV;    else if C = cur.down  then YA = -YADV;    else if C = cur.up    then YA =  YADV;    else if C = asc.5     then MODE = 0;    else if asc.1 <= C & C <= asc.4 then MODE = C - asc.1 + 1;    else if C = asc.c then do; XADV = 16; YADV = 12; SLUR_GRAIN = .100; end;    else if C = asc.f then do; XADV =  4; YADV =  3; SLUR_GRAIN = .050; end;    else if C = asc.v then do; XADV =  1; YADV =  1; SLUR_GRAIN = .050; end;    else if C = asc.t then do; data_level (2); DRAW = false; end;    else if C = asc.s then do; data_level (0); DRAW = true;  end;    else if C = asc.d then TYPE = 1;    else if C = asc.r then TYPE = 0;    if (BUFF(1) & R_SMSLR) ~= 0 then SLUR_GRAIN = .1;    if MODE = 0 then do;      MAT(2) = MAT(2) + XA;      MAT(3) = MAT(3) + YA;      MAT(4) = MAT(4) - XA;      MAT(5) = MAT(5) + YA;    end;    else do;      I = (MODE - 1) * 2;      MAT(I)   = MAT(I)   + XA;      MAT(I+1) = MAT(I+1) + YA;    end;    call NSLUR (MAT,TYPE);    C = rchar; if lower.a <= C & C <= lower.z then C = C - 32;    if DRAW then data_level (1);    call NSLUR (MAT,TYPE);    if DRAW then data_level (0);  end;  SLUR_GRAIN = .1;  if TYPE then BUFF(1) = BUFF(1) | R_DOTTED;  BUFF(2) = shl((MAT(0)-SX),8) \ (MAT(1) & LBYTE);  BUFF(5) = shl((MAT(6)-EX),8) \ (MAT(7) & LBYTE);  if (BUFF(1) & R_SMSLR) ~= 0 then do; /* Small slur */    BUFF(3) = shl((MAT(2)-MAT(0)),8) \ ((MAT(3)-MAT(1)) & LBYTE);    BUFF(4) = shl((MAT(4)-MAT(6)),8) \ ((MAT(5)-MAT(7)) & LBYTE);  end;  else do; /* Normal slur */    BUFF(3) = shl((MAT(2)-MAT(0))/4,8) \ ((MAT(3)-MAT(1))/3 & LBYTE);    BUFF(4) = shl((MAT(4)-MAT(6))/4,8) \ ((MAT(5)-MAT(7))/3 & LBYTE);  end;  if ~DRAW then data_level (0); transparent_mode;  write(SECT$) = S;  /* Restore xmem registers */  write(WORD$) = W;  end POSITION_NSLUR;