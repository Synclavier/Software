/* $title Debugging Routines */module TESTRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';begin;BIT_OUT:procedure (D,LEN);  dcl (D,LEN,I) fixed;  do I = 1 to LEN;    D = rot(D,1);    if D then wchar(35); else wchar(45);    if I mod 4 = 0 then wchar(sp);  end;end BIT_OUT;TUP_OUT:procedure (P,CNT);  dcl P   pointer,      CNT fixed;    pos(5,10); pstring(' Fwd: '); onum(core(P),     0);    pos(6,10); pstring(' Grp: '); onum(core(P+1),   0);    pos(7,10); pstring('LTup: '); onum(core(P+2),   0);    pos(8,10); pstring('UTup: '); onum(core(P+3),   0);    pos(5,55); pstring('Loc: '); onum(P,           0);    pos(6,55); pstring('Cnt: '); pnum(CNT,         0);    pos(10,10); pstring('LRTL: '); pnum(shr(core(P+D3),8),0);    pos(10,40); pstring('LFTL: '); pnum(core(P+D3)&LBYTE,0);    pos(11,10); pstring('URTL: '); pnum(shr(core(P+D4),8),0);    pos(11,40); pstring('UFTL: '); pnum(core(P+D4)&LBYTE,0);    pos(12,10); pstring('LOld: '); pnum(shr(core(P+D5),8),0);    pos(12,40); pstring('PAdv: '); pnum(core(P+D5)&LBYTE,0);    pos(13,10); pstring('UOld: '); pnum(shr(core(P+D6),8),0);    pos(13,40); pstring('Bits: '); call BIT_OUT (shl(core(P+D6),8),8);end TUP_OUT;HEAP_OUT:procedure (P,CNT);  dcl P   pointer,      CNT fixed;    pos(5,10); pstring('Fwd: '); onum(core(P),     0);    pos(5,55); pstring('Loc: '); onum(P,           0);    pos(6,55); pstring('Cnt: '); pnum(CNT,         0);    pos( 8,10); pstring('SeqP: '); pnum(core(P+D0),0);pnum(core(P+D1),10);    pos( 9,10); pstring(' Dur: '); unum(core(P+D3),0);    pos(10,10); pstring('StTm: '); unum(core(P+D2X),0);unum(core(P+D2),1);    pos(11,10); pstring('Part: '); pnum(shr(core(P+D6),8),0);    pos(12,10); pstring('Str#: '); pnum(shr(core(P+D4),12),0);    pos(12,25); pstring('Accd: '); pnum(shr(core(P+D4),8)&MASK4,0);    pos(12,40); pstring('Note: '); pnum(core(P+D4)&LBYTE,0);    pos(13,10); pstring('NotO: '); pnum(shr(core(P+D5),12),0);    pos(13,25); pstring('TieC: '); pnum(shr(core(P+D5),8)&MASK4,0);    pos(13,40); pstring(' Key: '); pnum(core(P+D5)&LBYTE,0);    pos(14,10); pstring('Bits: '); call BIT_OUT (core(P+D6),16);end HEAP_OUT;POSN_OUT:procedure (P,CNT);  dcl P   pointer,      CNT fixed;    pos(5,10); pstring('Fwd: '); onum(core(P),    0);    pos(6,10); pstring('Grp: '); onum(core(P+GRP),0);    pos(7,10); pstring('Rev: '); onum(core(P+REV),0);    pos(5,55); pstring('Loc: '); onum(P,          0);    pos(6,55); pstring('Cnt: '); pnum(CNT,        0);    pos(9 ,10); pstring('Strt: '); unum(core(P+D2X),0); unum(core(P+D2),10);    pos(10,10); pstring('ACnt: '); pnum(shr(core(P+D3),12),0);    pos(10,25); pstring('Xtra: '); pnum(shr(core(P+D3),8)&MASK4,0);    pos(10,40); pstring('Hbts: '); call BIT_OUT (shl(core(P+D3),8),4);    pos(11,10); pstring(' Pre: '); pnum(shr(core(P+D4),8),0);    pos(11,40); pstring('Post: '); pnum(core(P+D4)&LBYTE,0);    pos(12,10); pstring(' New: '); pnum(shr(core(P+D5),8),0);    pos(12,40); pstring(' Old: '); pnum(core(P+D5)&LBYTE,0);    pos(13,10); pstring('Bits: '); call BIT_OUT (core(P+D6),16);end POSN_OUT;NOTE_OUT:procedure (P,CNT);  dcl P   pointer,      CNT fixed;    pos(5,10); pstring('Fwd: '); onum(core(P),    0);    pos(6,10); pstring('Grp: '); onum(core(P+GRP),0);    pos(5,55); pstring('Loc: '); onum(P,          0);    pos(6,55); pstring('Cnt: '); pnum(CNT,        0);    pos(8,10);  pstring('SeqP: '); pnum(core(P+D1X),0);pnum(core(P+D1),10);    pos(9,10);  pstring('NotO: '); pnum(shr(core(P+D2),12),0);    pos(9,25);  pstring('Note: '); pnum(shr(core(P+D2),8)&MASK4,0);    pos(9,40);  pstring('YPos: '); pnum(core(P+D2)&LBYTE,  0);    pos(10,10); pstring('OBms: '); pnum(shr(core(P+D3),12),0);    pos(10,25); pstring('CBms: '); pnum(shr(core(P+D3),8)&MASK4,0);    pos(10,40); pstring('SLen: '); pnum(core(P+D3)&LBYTE,  0);    pos(11,10); pstring('AOff: '); pnum(shr(core(P+D4),13),0);    pos(11,25); pstring('Accd: '); pnum(shr(core(P+D4),8)&MASK4,0);    pos(11,40); pstring('Trak: '); pnum(core(P+D4)&LBYTE,  0);    pos(12,10); pstring('TieC: '); pnum(shr(core(P+D5),12),0);    pos(12,25); pstring('XBts: '); call BIT_OUT (shl(core(P+D5),4),4);    pos(12,40); pstring('PAdv: '); pnum(core(P+D5)&LBYTE,  0);    pos(13,10); pstring('Bits: '); call BIT_OUT (core(P+D6),16);    return (CNT + (core(P+D5)&LBYTE) - 1);end NOTE_OUT;#examen:procedure (HEAD,TYPE,STR) public;  dcl HEAD pointer,      TYPE fixed,      STR  fixed array,      (P,GH,TH,CNT,C,T) fixed;  transparent_mode; clear_screen;  pos(0,0); reverse(1); pstring(STR); reverse(0); pos(0,65);  do case TYPE;    ;    pstring('Heap/Chord');    pstring('Position');    pstring('Note/Rest');  end;  pos(2,0);  pstring('Meas:  '); pnum(MEASURE_NUMBER,0);  pos(3,0);  pstring('Staff: '); pnum(STAFF,0);  pos(2,30); pstring('Part:  '); pnum(PART,0);  pos(3,30); pstring('Voice: '); pnum(VOICE,0);  pos(3,60); pstring('Posn:  '); pnum(EDIT_POSITION,0);  CNT = 0; P = HEAD; GH = P; T = TYPE; TH = null;  if P = null then do;    pos(10,10); pstring('*** POINTER WAS NULL *** '); C = rchar;    clear_screen; return;  end;  else do forever;    if (core(P+D6) & B_TUP) ~= null & TYPE = NOTE# then T = 0; else T = TYPE;    pos(5,0); pstring(CLEAR_CUR);    do case T;      call TUP_OUT  (P,CNT);      call HEAP_OUT (P,CNT);      call POSN_OUT (P,CNT);      CNT = NOTE_OUT (P,CNT);    end;    POLL: C = rchar;    if C = cur.left & TYPE = POSN# & core(P+REV) ~= null then do;      P = core(P+REV);    end;    else if C = cur.left & P = GH & P ~= HEAD then do;      P = HEAD; GH = P; CNT = 0;    end;    else if C = cur.right & TYPE = POSN# & core(P) ~= null then do;      P = core(P);    end;    else if C = cur.right & P = GH & core(P) ~= null then do;      P = core(P); GH = P; CNT = CNT + 1;    end;    else if C = cur.up & TYPE = POSN# then do; P = TH; TH = null; end;    else if C = cur.up & P ~= GH then P = core(P);    else if C = cur.down & TYPE = POSN# & core(P+GRP) ~= null then do;      TH = P; P = core(P+GRP);    end;    else if C = cur.down & core(P+GRP) ~= null then P = core(P+GRP);    else if C = pf.1 & T = 0 then do; TH = P; P = core(P+D2); GH = P; end;    else if C = pf.2 & T = 0 then do; TH = P; P = core(P+D1); GH = P; end;    else if C = pf.3 & TH ~= null then do; P = TH; GH = P; TH = null; end;    else if C = cr then do; clear_screen; return; end;    else if C = 0  then do; clear_screen; return; end;    else goto POLL;  end;end #examen;#printout:procedure (HEAD,TYPE,STR) public;  dcl HEAD pointer,      TYPE fixed,      STR  fixed array,      P    pointer;  transparent_mode; pos(23,0);  reverse(1); pstring(STR); reverse(0); pstring('    ');  do case TYPE;    pstring('Template');    pstring('Heap/Chord');    pstring('Position');    pstring('Note/Rest');  end;  if HEAD = null then pstring('  NULL'); crlf; P = HEAD;  do while P ~= null;    onum(P,0); wchar(colon); onum(core(P),1); onum(core(P+1),1);    pnum(core(P+D1),1);    pnum(shr(core(P+D2),8),1); wchar(sp); pnum(core(P+D2)&LBYTE,0);    pnum(shr(core(P+D3),8),1); wchar(sp); pnum(core(P+D3)&LBYTE,0);    pnum(shr(core(P+D4),8),1); wchar(sp); pnum(core(P+D4)&LBYTE,0);    wchar(sp); onum(core(P+D5),1); crlf;    P = core(P);  end;end #printout;/*dcl #EB fixed data (2,"H5B1B");dcl EB  lit 'string(#EB)';#stat_init:procedure;  send EB,'2J',;  send EB,'3;1HMeas:  ',;  send EB,'4;1HStaff: ',;  send EB,'3;35HPart:  ',;  send EB,'4;35HVoice: ',;  send EB,'3;65HMode:  ',;  send  EB,'6;1H Free_Head: ',;  send  EB,'6;60H Free_Tail: ',;  send  EB,'7;1H Temp_Head: ',;  send  EB,'7;60H Temp_Tail: ',;  send  EB,'8;1HChord_Head: ',;  send  EB,'8;60HChord_Tail: ',;  send  EB,'9;1H  Pos_Head: ',;  send  EB,'9;27H  Pos_Point: ',;  send  EB,'9;60H  Pos_Tail: ',;  send EB,'10;1H Note_Head: ',;  send EB,'10;27H Note_Point: ',;  send EB,'10;60H Note_Tail: ',;end #stat_init;dcl stat_init lit 'call #stat_init';#status:procedure (STR);  dcl STR fixed array;  dcl C   fixed;  send EB,'1;1H',EB,'2K',EB,'7m',string(STR),EB,'0m',;  send EB,'3;8H',MEASCNT,;  send EB,'4;8H',STAFF,;  send EB,'3;42H',PART,;  send EB,'4;42H',VOICE,;  send EB,'3;72H',MODE,;  send  EB,'6;13H', octal(FREE_HEAD),;  send  EB,'6;73H', octal(FREE_TAIL),;  send  EB,'7;13H', octal(TEMP_HEAD),;  send  EB,'7;73H', octal(TEMP_TAIL),;  send  EB,'8;13H', octal(CHORD_HEAD),;  send  EB,'9;13H', octal(POS_HEAD),;  send  EB,'9;40H', octal(POS_POINT),;  send  EB,'9;73H', octal(POS_TAIL),;  send EB,'10;13H', octal(HEAD(VOICE)),;  send EB,'10;40H', octal(POINT(VOICE)),;  send EB,'10;73H', octal(TAIL(VOICE)),;  if ERROR_CHECK then C = rchar;end #status;dcl status lit 'call #status';printmsc:proc;  dcl (P,I,J) fixed;  P = msc.ptr;  do I = 1 to 32;    do J = 1 to 8;      print octal(core(P)),'   ',;      P = P + 1;    end;    print;  end;end printmsc;*/#print_presets:procedure(STR) public;  dcl STR   fixed array,      (I,J) fixed,      P     pointer;  transparent_mode; pos(23,0); reverse(1); pstringr(STR); reverse(0);  do I = 0 to shr(core(P+6),8)+1;    do J = 0 to core(P)-1;      if J mod 8 = 0 then crlf;      onum(core(P+J),1);    end;    P = P + core(P); crlf; crlf;  end;end #print_presets;/* WORK WORK WORK */print_edit_list:procedure (X) recursive;  dcl (X,I,J,LL,L,S,P) fixed;  do I = 1 to X; wchar(sp); end;  LL = read(DATI$); pstring('Length: '); unum(LL,0); crlf;  S = read(SECT$);  J = 1;  do while J ilt LL;    unum(read(SECT$),4); unum(read(WORD$),4); wchar(58);    do I = 0 to X; wchar(sp); end;    L = GET_EDIT_RECORD (BUFF,true);    if shr(BUFF(0),8) = "177" then do;      onum(BUFF(0),0);      pnum(shr(BUFF(1),8),10); pnum(BUFF(1) & LBYTE,10);      pnum(BUFF(2),10); pstring(' TUP'); crlf;/*      P = read(WORD$);      write(SECT$) = S + shr(J+2,8);      write(WORD$) = J + 2;      call print_edit_list (X+9);      write(SECT$) = S + shr(P,8);      write(WORD$) = P;*/    end;    else do I = 0 to L-1;      onum(BUFF(I),8);    end;    J = J + L;    crlf;  end;end print_edit_list;#print_edit:procedure public;  dcl (P,Q) pointer,      (I,J) fixed;  clear; pos(0,0);  pstring('LISTS,PARTS: ');pnum(LISTS,0);pnum(PARTS,8); crlf;  pstring('INF.PTR:   ');unum(INF.PTR,0); crlf;  write(SECT$) = INF.PTR;  pstring('     sect:   ');unum(read(DATI$),0); crlf;  pstring('      len:   ');unum(read(DATI$),0); crlf;  write(WORD$) = 1;  J            = read(DATI$);  do I = 1 to J-1;    onum(read(DATI$),8);    if I mod 8 = 0 \ I = J then crlf;  end;  crlf;  pstring('EDIT_BASE:   ');unum(EDIT_BASE,0); crlf;  do I = 1 to LISTS;    write(SECT$) = FIND_LIST_SECT (EDIT_BASE,I);    pstring('LIST_BASE:   ');unum(read(SECT$),0); crlf;    pstring('    sects:   ');unum(read(DATI$),0); crlf;    pstring('    words:   ');unum(read(DATI$),0); crlf;    write(WORD$) = 1;    call print_edit_list (0); crlf;  end;  I = rchar; clear;end #print_edit;#print_notelist:procedure (TRK) public;  dcl TRK fixed;  dcl B pointer,      (I,J) fixed;/*  B = FIND_LIST_SECT (NOTE_BASE,TRK);  write(SECT$) = B;  pstring('Sect:  ');unum(B,0); crlf;  pstring('Sects: ');unum(read(DATI$),0); crlf;  pstring('Words: ');unum(read(DATI$),0); crlf;  write(WORD$) = 1;  J            = read(DATI$);  do I = 1 to J-1;    onum(read(DATI$),8);    if I mod 8 = 0 \ I = J then crlf;  end;  crlf;*/end #print_notelist;#print_list:procedure (HEAD,TYPE,TITLE) public;  dcl HEAD pointer,      (P,Q,LQ) pointer,      TITLE fixed array,      TYPE  fixed,      (X,Y) fixed,      XADV  fixed;  BOX:procedure;    imove_to (X,Y+15); iplot (X+30,Y+15);    iplot (X+30,Y-15); iplot (X,Y-15);    iplot (X,Y+15);  end BOX;  ARROW_UP:procedure;    imove_to (X+10,Y+15); iplot (X+10,Y+35);    imove_to (X+10-3,Y+35-3); iplot (X+10,Y+35); iplot (X+10+3,Y+35-3);  end ARROW_UP;  ARROW_DOWN:procedure;    imove_to (X+20,Y-15); iplot (X+20,Y-35);    imove_to (X+20-3,Y-35+3); iplot (X+20,Y-35); iplot (X+20+3,Y-35+3);  end ARROW_DOWN;  ARROW_RIGHT:procedure;    imove_to (X+30,Y+5); iplot (X+50,Y+5);    imove_to (X+50-3,Y+5-3); iplot (X+50,Y+5); iplot (X+50-3,Y+5+3);  end ARROW_RIGHT;  ARROW_LEFT:procedure;    imove_to (X,Y-5); iplot (X-20,Y-5);    imove_to (X-20+3,Y-5-3); iplot (X-20,Y-5); iplot (X-20+3,Y-5+3);  end ARROW_LEFT;  clear;  viewport (0,639,0,479);  iwindow  (0,639,-290,189);  pos(0,0); reverse(1); pstring(TITLE); reverse(0);  X = 0; XADV = 50;  P = HEAD;  do while P ~= null;    Q = P; LQ = P; Y = 0;    if core(P) ~= null then call ARROW_RIGHT;    do while Q ~= null;      call BOX;      imove_to (X+4,Y+2);  alpha_mode; pnum(core(Q+D2)&LBYTE,0);      imove_to (X+4,Y-12); alpha_mode; call BIT_OUT (shl(core(Q+D6),13),3);      if core(Q)      = LQ   then call ARROW_UP;      if core(Q+GRP) ~= null then call ARROW_DOWN;      Y = Y - 50; LQ = Q; Q = core(Q+GRP);    end;    X = X + XADV; P = core(P);    if X > 600 then P = null;  end;  transparent_mode; X = rchar; clear;end #print_list;#print_edit_stack:procedure (LEVEL) public;  dcl (LEVEL,P) fixed;  P = EDIT_STAK_BASE + 6*LEVEL;  pstring('------------Level: '); pnum(LEVEL,0);         crlf;  pstring('Master Edit Point: '); onum(core(P+MEDP#),0); crlf;  pstring('Master Edit Index: '); pnum(core(P+MEDI#),0); crlf;  pstring('Master Edit End:   '); onum(core(P+MEDE#),0); crlf;  pstring('       Edit Point: '); onum(core(P+EDP# ),0); crlf;  pstring('       Edit Index: '); pnum(core(P+EDI# ),0); crlf;  pstring('       Edit End:   '); onum(core(P+EDE# ),0); crlf;end #print_edit_stack;#set_screen:procedure public;  dcl (X,Y) fixed;  send character(26),;  do Y = 1 to 16;    send character(27),'=',character(31+Y),' ',;    do X = 1 to 80;      send '.',;    end;  end;  send character(27),'=3 ',;end #set_screen;#set_location:procedure (LOC,STATE) public; /* WORK */  dcl LOC     fixed,      STATE   fixed,      (C,X,Y) fixed;  C = (LOC - CORE_BASE) / 8;  X = C / 16 + 1;  Y = C mod 16 + 1;  send character(27),'=',character(31+Y),character(31+X),;  do case STATE;    send 'O'; /* 0 - Free */    send '#'; /* 1 - Used */    send '@'; /* 2 - Guarenteed free */  end;  send character(27),'=3 ',;end #set_location;#set_free_update:procedure public;  dcl P pointer;  dcl (FREE_HEAD,FREE_TAIL) pointer external;  P = FREE_HEAD;  do while P ~= null;    set_location (P,2);    if P = FREE_TAIL then P = null;    else P = core(P);  end;  P = rchar;end #set_free_update;#part_display:procedure (MESS) public;  dcl MESS fixed array,      (I,J,N,P) fixed;  clear; pstringr(MESS); crlf;  P = PART_BASE; N = NAME_BASE;  do I = 0 to PARTS;    do J = 0 to 15;      if J = 8 then crlf;      onum(core(P),7); P = P + 1;    end;    crlf;    do J = 0 to 17;      if J = 9 then crlf;      onum(core(N),7); N = N + 1;    end;    crlf; crlf;  end;  I = rchar;end #part_display;#print_list_indices:proc public;  dcl I fixed;  pos(12,0);  erase_line;pstring('PARTS: ');pnum(PARTS,0);crlf;  erase_line;pstring('LISTS: ');pnum(LISTS,0);crlf;  erase_line;pstring('BufIn: ');pnum(BUFF_LIST,0);crlf;  erase_line;pstring('LiInM: ');pnum(LIST_INDEX(MASTER_PART),0);crlf;  do I = 0 to PARTS;    erase_line; pstring('Part,Index: ');    pnum(I,0); pnum(LIST_INDEX(I),10); crlf;  end;end #print_list_indices;#print#s:procedure public;  pstring('#TRK ,#PTR ');pnum(#TRK ,10);pnum(#PTR ,10);crlf;  pstring('#NMSB,#NLSB');pnum(#NMSB,10);pnum(#NLSB,10);crlf;  pstring('#LMSB,#LLSB');pnum(#LMSB,10);pnum(#LLSB,10);crlf;  pstring('#SEC ,#WRD ');pnum(#SEC ,10);pnum(#WRD ,10);crlf;  pstring('#ANYR,#ANYF');pnum(#ANYR,10);pnum(#ANYF,10);crlf;  pstring('#MSB ,#LSB ');pnum(#MSB ,10);pnum(#LSB ,10);crlf;  crlf;end #print#s;print_inf_area:proc public;  dcl (I,J) fixed;  crlf;  pstring('INF.PTR = ');pnum(INF.PTR,0);  pstring('  INF.LEN = ');pnum(INF.LEN,0);crlf;  write(SECT$) = INF.PTR;  do I = 1 to INF.LEN;    do J = 0 to 255;      if (J&7) = 0 then crlf;      hnum(read(DATI$),8);    end;  end;  crlf;crlf;end print_inf_area;print_nah_area:proc public;  dcl (I,J) fixed;  clear_all;  pstring('NAH.PTR = ');pnum(NAH.PTR,0);  pstring('  NAH.LEN = ');pnum(NAH.LEN,0);crlf;  write(SECT$) = NAH.PTR;  do I = 1 to NAH.LEN;    pstring('Sector ');pnum(I-1,0);crlf;    do J = 0 to 255;      if (J&7) = 0 then crlf;      onum(read(DATI$),8);    end;    if ~term_idle then I = NAH.LEN;    crlf;  end;  do I = 1 to 10; crlf; end;end print_nah_area;print_time:proc (T) public;  dcl T fixed array;  write(5) = T(0);  write(4) = T(1);  write(7) = 200;  unum(read(5),0); wchar(sp); unum(read(4),0);end print_time;end;end TESTRTNS;