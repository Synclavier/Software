/* $title Editing Routines */module EDITRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';/* Module globals */dcl PLAY_SEQUENCE   procedure (boolean) external;dcl LOOKUP_SYMBOL   procedure (fixed) returns (boolean) external;dcl (CX,CY)         fixed;  /* Cursor postion */dcl EDIT_POS(3)     fixed,  /* Edit postion */    EDIT_OLD(3)     fixed,  /* Old edit position */    LEN_PTR(3)      fixed,    BLOCK(3)        fixed;  /* Edit block */dcl BASE_EDIT_POS       fixed,  /* Base editing position */    BASE_MEASURE_NUMBER fixed,  /* Base measure position */    XBASE               fixed,    XOFF                fixed,  /* X offset */    LEVEL               fixed,  /* Tuplet level */    MAX_LEVEL           fixed,  /* Maximum tuplet level */    STAFF_POS           fixed,  /* Staff position */    CUR_LIST_IND        fixed,    VOX                 fixed,   /* Voice switch */    PP                  pointer, /* Position pointer */    CHARACTERS_ONLY     boolean, /* Set if string is limited to characters */    SYMBOLS_ONLY        boolean, /* Set if string is limited to symbols */    MASTER_VOICE        boolean, /* Set for master voice editing */    ALL_PARTS           boolean, /* Set for all-part editing */    LAST_EDIT           boolean; /* If the last edit block */dcl LONG_SYM(15)        fixed,  /* Long symbol */    LONG_POSITION       fixed,    LONG_X              fixed,  /* Long symbol X positon */    LONG_PP             pointer,/* Long symbol position pointer */    LONG_FLAG           boolean;/* If a long symbol */dcl CHORD_POS           fixed,  /* Chord postion */    CHORD_MASK          fixed,    RECORDS             fixed,    SCAN_IND            fixed,    SCAN_TUP            boolean,    SCAN_PTR            pointer,    SCAN_END            pointer;dcl PITCH               fixed,    OCTAVE              fixed,    RANGE_PITCH         fixed,  /* Pitch range */    RANGE_OCTAVE        fixed,  /* Octave range */    (DN,DD)             fixed;dcl KEY_TAB fixed data (kp.7,kp.8,kp.9,kp.minus,kp.4,kp.5,kp.6,kp.comma);dcl STATUS#       lit '0', /* Editor display modes */    LIST_DISPLAY# lit '1',    SEQ_ALTER#    lit '2';dcl STANDARD#     lit '0', /* Fonts */    ITALIC#       lit '1',    BOLD#         lit '2',    BOLDITAL#     lit '3',    SYMBOL#       lit '4';  dcl DUR#  lit '0',   /* Change duration */      PTCH# lit '1',   /* Change pitch */      MOVE# lit '2',   /* Move note in time */      TRIM# lit '3',   /* Justify note to correct time */      ADD#  lit '4',   /* Add new note */      DEL#  lit '5',   /* Delete existing note */      INSR# lit '6',   /* Insert time into seq */      REMV# lit '7',   /* Remove time from seq */      STRN# lit '8';   /* Set guitar string number */insert ':mplt:editfncs';insert ':mplt:efns';SYMBOL_PROCESS:procedure swap2; /* Processes the designated keystroke and returns a symbol or a command */  dcl (C,I)  fixed,      COM(2) fixed,      LFOFF  fixed,   /* Library font offset */      SHIFT  boolean;  SHIFT = false;     /* Initialize shifted key */  LOOP:do forever;    vector_mode; data_level (2); call CURSOR (CX,CY);    if MG600 then transparent_mode;/*  if GO250 then do;      flush_term;       disable;      wait(5);      enable;      clear_typeahead;    end; */    C = rchar;/*  if GO250 & ~term_idle & C < sp then C = 0; */    call CURSOR (CX,CY); data_level (0);                 LFOFF = LIBRARY; if EXTENDED & LIBRARY then LFOFF = 2;    if C = kp.dot & ~SHIFT then SHIFT = true; /* keypad . sets shift */    else if C = lf & EXTENDED then do;      LIBRARY = ~LIBRARY & MASK1;      if EDIT_MODE = STATUS# then do;        call EDIT_TEXT (2,false);       /* Update the X offset, Y position, and bank settings*/        call KEYPAD_REF;                /* Draw the keypad bank setting */      end;    end;    else if C = ht then do; /* TAB - Get a symbol name and look up the symbol code in the symbol table */      if ~CHARACTERS_ONLY then do;      transparent_mode; /* pos(cmdline,0); */ erase_command;      call GET_STR ('Symbol/Command Name: ',true,COM,4); erase_command;      if COM(0) > 0 then do;        C = LOOKUP_NUMBER (COM,LFOFF);        if C = nullint then pcmd('Symbol not found');        else do;          if C < 128 & ~(EXTENDED & LIBRARY) then C = C | COM_BIT;          return (C);        end;      end;      end;    end;    else if kp.1 <= C & C <= kp.3 then do;      BANK = C - kp.1;      if SHIFT then do; BANK = BANK + 3; SHIFT = false; end;      if EDIT_MODE = STATUS# then do;        call EDIT_TEXT (2,false);       /* Update the X offset, Y position, and bank settings*/        call KEYPAD_REF;                /* Draw the keypad bank setting */      end;    end;    else if SHIFT & (C = kp.0 \ C = kp.dot \ C = kp.enter \ C = 0) then do;      if C = kp.enter then do;        EDIT_MODE = STATUS#;        call GRID;                /* Draw the keypad dividers */        call EDIT_TEXT (0,false); /* Update the current part prompts and some settings */        call KEYPAD_REF;          /* Draw the keypad bank settings */      end;      else if C = kp.0   then do;        EDIT_MODE = LIST_DISPLAY#;        vector_mode; data_level (1); call GRID; data_level (0); /* Erase the keypad dividers and reset the pixels to on */      end;      call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,EDIT_BOT#);      return (0);    end;    else do;      do I = 0 to 7;        if C = KEY_TAB(I) then do;          C = byte(location(BANK_BASE+LFOFF*24-1),BANK*8 + I);          if C < 128 & ~(EXTENDED & LIBRARY) then return (C | COM_BIT);          if ~CHARACTERS_ONLY then return (C); else goto LOOP;        end;      end;      if C >= 128 then return (C | COM_BIT); /* If a non-ascii char, drop through */      if EXTENDED & LIBRARY & sp <= C & C < del then C = C | "200";      if ~SYMBOLS_ONLY | C < sp | C = del then return (C);    end;  end;end SYMBOL_PROCESS;STRING_PROCESS:procedure swap2; /* Processes the character string and returns the character representing a symbol or command code*/  dcl (C,LEN,A) fixed,   /* Character, length */      (SX,CA)   fixed,      BOFF      fixed,      COFF      fixed,      HOFF      fixed,      HY        fixed,      DIR       boolean; /* Symbol direction */  BOX_TEXT:procedure;    imove_to (SX-7,HY- 4*TSIZE); iplot (CX+1,HY- 4*TSIZE);    iplot    (CX+1,HY+13*TSIZE); iplot (SX-7,HY+13*TSIZE);    iplot    (SX-7,HY- 4*TSIZE);  end BOX_TEXT;  DRAW_STRING:procedure (C,DELETE);    dcl C       fixed;    dcl DELETE  boolean;    dcl I       fixed;    vector_mode;    if BOXTX then do; /* XXX Remove end of present box */      data_level (1);      call BOX_TEXT;    end;    if AUTO_CENTER & C ~= 0 then do;      I    = (A * TSIZE) / (CSC# * 2);      I    = (I/4)*4;      if BOFF - I >= -120 then COFF = BOFF - I;    end;    if COFF ~= HOFF | CY ~= HY then do;      data_level (1);      if BUFF(1) = 1      then call PLOT_CHARACTER (byte(loc(addr(BUFF(1))),0),SX,HY,DIR);      else call PLOT_STRING (loc(addr(BUFF(1))),SX,HY,BUFF(1),TSIZE);    end;    else if DELETE then do;      data_level (1);      CX = XBASE + COFF + A*TSIZE / CSC#;      call PLOT_CHARACTER (C,CX,CY,DIR);    end;    else do;      data_level (0);      call PLOT_CHARACTER (C,CX,CY,DIR);      CX = XBASE + COFF + A*TSIZE / CSC#;    end;    if C ~= 0 then do;      if DELETE then BUFF(1) = BUFF(1) - 1;                else BUFF(1) = BUFF(1) + 1;    end;    if COFF ~= HOFF | CY ~= HY then do;      HOFF = COFF;      HY   = CY;      SX   = XBASE + COFF;      data_level (0);      if BUFF(1) = 1      then call PLOT_CHARACTER (byte(loc(addr(BUFF(1))),0),SX,CY,DIR);      else call PLOT_STRING (loc(addr(BUFF(1))),SX,CY,BUFF(1),TSIZE);      CX = XBASE + COFF + A*TSIZE / CSC#;    end;    if BOXTX & BUFF(1) > 0 then do;      data_level (0);      call BOX_TEXT;    end;  end DRAW_STRING;  CREATE_RECORD:procedure;    dcl IS_SYM boolean; /* Set if symbol record */    LEN = BUFF(1);    if LEN > 1 \ TSIZE = 2 \ BOXTX then do; /* Create a multi-word record */      if LEN then call pbyte(location(addr(BUFF(1))),LEN,0); /* 0 fill last byte of odd length string */      LEN = WORD_LEN(LEN)+1;      BUFF(0) = shl("140",8) \ LEN;      if TSIZE = 2 & EDIT_FONT ~= F_USER# then BUFF(0) = BUFF(0) \ R_DTX; /* Double size chars */      if BOXTX                            then BUFF(0) = BUFF(0) \ R_BTX; /* Boxed chars */    end;    else do;                /* Create a two-word record */      LEN = 2; BUFF(0) = shl("100",8) \ (BUFF(2) & LBYTE);    end;    BUFF(1) = shl(COFF/4 & MASK6,6) \ CY/3;    if EXTENDED then do;      BUFF(1) = BUFF(1) \ R_EXT;      IS_SYM  = SYMBOLS_ONLY;      if LEN = 2 then if LIBRARY then BUFF(1) = BUFF(1) \ R_LIB; else;      else            if IS_SYM  then BUFF(1) = BUFF(1) \ R_LIB; else;    end;    else do;      IS_SYM = IS_A_SYMBOL(BUFF(2) & LBYTE);      if LIBRARY then BUFF(1) = BUFF(1) \ R_LIB;    end;    if EDIT_FONT = F_ALPHA# | ((LEN = 2 | EXTENDED) & IS_SYM) then do;      BUFF(0) = BUFF(0) \ R_ALF; /* Make this an alpha record */      if DIR then BUFF(1) = BUFF(1) \ R_DIR; /* Set direction bit */    end;    else BUFF(1) = shl(EDIT_FONT,12) \ BUFF(1);    call INSERT_RECORD (MASTER_VOICE,LEN,BUFF); /* Insert a record into an edit list */    call EDIT_MARK (XBASE);                     /* Draw an edit mark */  end CREATE_RECORD;  COFF = XOFF; HOFF = XOFF; BOFF = XOFF; HY = CY;  BUFF(1) = 0; CX = XBASE + XOFF; SX = CX; A = 0; CA = 0; DIR = 0;  SYMBOLS_ONLY    = false;  CHARACTERS_ONLY = false;  do forever;/*transparent_mode;pos(23,0);pstring('Upper = ');pnum(UPPER_FONT,0);pstring('     Lower = ');pnum(LOWER_FONT,0);crlf;vector_mode;*/    C = SYMBOL_PROCESS;           /* Process the input character */    if C = del & BUFF(1) > 0 then do;      C   = byte(location(addr(BUFF(1))),BUFF(1)-1);      call LOOKUP_SYMBOL (C);      if SYM_ADFT < F_MUSIC# then A = A - SYM_XADV*10;                             else A = A - SYM_XADV*CSC#;      call DRAW_STRING (C,true);    end;    else if sp <= C & C ~= del & (C & COM_BIT) = 0 then do;      if BUFF(1) < 128 then do;      if BUFF(1) = 0 then call SETUP_FONTS (EDIT_FONT,EXTENDED,LIBRARY,CHOOSE#);      /* PLOT_CHARACTER may trash SYM_XXXX so do it as late as possible - in DRAW_STRING */      call pbyte (location(addr(BUFF(1))),BUFF(1),C);      call LOOKUP_SYMBOL (C);      if SYM_FLIP & BUFF(1) = 0 then DIR = GET_DIRECTION; else DIR = UP#;      if TSIZE = 2 & EDIT_FONT ~= F_USER# then DIR = DIR \ SIGN_BIT; /* Tells PlotCharacter to use large chars */      if SYM_ADFT < F_MUSIC# then A = A + SYM_XADV*10;                             else A = A + SYM_XADV*CSC#;      call DRAW_STRING (C,false);      if EXTENDED then do;        if IS_A_SYMBOL(C) then do;          SYMBOLS_ONLY = true;          call SETUP_FONTS (F_ALPHA#,true,true,STRING#);        end;        else do;          CHARACTERS_ONLY = true;          call SETUP_FONTS (EDIT_FONT,true,false,STRING#);        end;      end;      end; /* End of BUFF-not-full block */    end;    else if AUTO_CENTER & BUFF(1) > 0 & (C&LBYTE) = pf.3 & ~LAST_EDIT then do;       if COFF > -120 then COFF = COFF - 4; /* Move left one half note head */      if BOFF > -120 then BOFF = BOFF - 4; /* Move left one half note head */      call DRAW_STRING (0,true);    end;    else if AUTO_CENTER & BUFF(1) > 0 & (C&LBYTE) = pf.4 & ~LAST_EDIT then do;      if COFF < 120  then COFF = COFF + 4; /* Move right one half note head */      if BOFF < 120  then BOFF = BOFF + 4; /* Move right one half note head */      call DRAW_STRING (0,true);    end;    else if AUTO_CENTER & BUFF(1) > 0 & (C&LBYTE) = pf.2 & ~LAST_EDIT then do;       if CY > 0 then CY = CY - 3; /* move down one unit */      call DRAW_STRING (0,true);    end;    else if AUTO_CENTER & BUFF(1) > 0 & (C&LBYTE) = pf.1 & ~LAST_EDIT then do;      if CY < 180 then CY = CY + 3; /* move up one unit */      call DRAW_STRING (0,true);    end;    else do;      if BUFF(1) > 0 then call CREATE_RECORD;      return (C);    end;  end;end STRING_PROCESS;COMMAND_PROCESS:procedure swap2; /* Processes edit commands and inserts an edit record in the edit list */  dcl (C,I,J,K) fixed,      VBIT     fixed,      DATA8    fixed,      DATA16   fixed,      P        pointer,      CLR      boolean,      MVOX     boolean,   /* If master voice */      CREATE_1 boolean,   /* If creating a one word record */      CREATE_2 boolean,   /* If creating a two word record */      CREATE_M boolean,   /* If creating a multi word record */      CREATE_S boolean,   /* If creating a sublist */      PLOTREC  boolean;   /* If plotting a record */  dcl AUTO_MASTERS     data ("12","40","41","42","120","121","122","123"),      AUTO_MASTERS_LEN lit '8';  dcl HD_LABS data  ('Standard Cue Percussion 7-Shape 4-Shape None DiamPerc . Do Re Mi Fa Sol La Ti . Left Right Bass . . . . . AltHarmonic Harmonic ');  GET_TIME_SIGNATURE:procedure;    dcl FLAG boolean;    pstring('Time Signature: ');    DATA8 = 0;    FLAG  = true;    do while FLAG;      if      DATA8 = R_COMT then pstring ('Common ');      else if DATA8 = R_CUTT then pstring ('Cut ');      do while term_idle_wait; end; K = peek;      pos(cmdline,16); erase_line;      if K = ht then do;        DATA8 = R_COMT; DATA16 = "H0404";      end;      else if K = asc.q \ K = lower.q then do;        DATA8 = R_CUTT; DATA16 = "H0202";      end;      else if K = cr then do;        if DATA8 = 0 then CLR = true;        else CREATE_2 = true;        FLAG = false;      end;      else if asc.0 <= K & K <= asc.9 then do;        DATA8  = 0;        DATA16 = GET_FRACTION (true);        if DATA16 = 0 then pcmd('Illegal time signature');        else if DATA16 = nullint then CLR = true;        else CREATE_2 = true;        FLAG = false;      end;      else if K = del then do;        CLR = true;        FLAG = false;      end;      if FLAG then call rchar; /* Eat a character */    end;    if ~CLR then do;      pcmd('Show time signature (Y or N)? '); I = rchar;      if I = asc.n | I = lower.n then DATA8 = DATA8 | INVISIBLE#;      if I = del then do; CLR = true; CREATE_2 = false; end;    end;  end GET_TIME_SIGNATURE;  GET_ACCD_CHANGE:procedure;    P = GET_NOTE (false,false,false,'Select note');    I = 3; J = 0;    if P ~= null then do;         /* If a note exists */      do while J ~= cr & J ~= del;        do case I;          ;          pcmd('Double Sharp');          pcmd('Sharp');          pcmd('Natural');          pcmd('Flat');          pcmd('Double Flat');        end;        wchar(sp); J = rchar;        if      J = cur.up   & I > 1 then I = I - 1;        else if J = cur.down & I < 5 then I = I + 1;        else if J = cr then do;          DATA8    = DATA8 \ shl(I,4) \ CHORD_POS;          CREATE_1 = true;        end;        else if J = del then CLR = true;      end;    end;  end GET_ACCD_CHANGE;  LOOP: do forever;    C = STRING_PROCESS;    if (C & COM_BIT) = 0 then return (C); C = C & LBYTE;  /* If not a command then return the character */    transparent_mode; erase_command;    VBIT = shl(VOICE,7);    if MASTER_VOICE then DATA8 = 0; else DATA8 = VBIT;    DATA16   = shl(XOFF/4 & MASK6,6) \ CY/3;    CLR      = false;    CREATE_1 = false;    CREATE_2 = false;    CREATE_M = false;    CREATE_S = false;    PLOTREC  = false;    MVOX = MASTER_VOICE;    do I = 0 to AUTO_MASTERS_LEN-1;      if C = AUTO_MASTERS(I) then do;        if LEVEL ~= 0 then do;          pcmd('Can''t edit master list from tup level');          goto LOOP; /* oop */        end;        MVOX = true;      end;    end;    if      C < "30"  then do case C;     /* 24 one word data records */      ;                                   /* 000 reserved */      do;                                 /* 001 Clef change */        call GET_STR ('Clef: ',true,BUFF,1);        if BUFF(0) > 0 then do;          DATA8 = 0;          pcmd('Show clef (Yes,No,Invisible)? '); I = rchar;          if I = asc.n | I = lower.n then DATA8 = INVISIBLE#;          else if I = asc.i | I = lower.i then DATA8 = INVISIBLE# | RESTORE#;          else if I = del then CLR = true;          do I = 0 to 5;            if (BUFF(1) & LBYTE) = CLEF_NAMES(I) & ~CLR then do;              DATA8 = DATA8 | I; CREATE_1 = true;            end;          end;          if ~CREATE_1 then pcmd('Illegal clef name');        end; else CLR = true;      end;      do;                                 /* 002 Key change */        call GET_STR ('Key: ',false,BUFF,2);        if BUFF(0) > 0 then do;          DATA8 = 0;          pcmd('Cancel previous (Y or N)? '); I = rchar;          if I = asc.n | I = lower.n then DATA8 = NO_CANCEL#;          if I = del then CLR = true;          if BUFF(0) = 1 then call pbyte(BUFF,1,sp); /* Add a space to a 1 char key */          else if byte(BUFF,1) = asc.f then call pbyte(BUFF,1,lower.f);          do I = 1 to 42;            if BUFF(1) = KEY_NAMES(I) & ~CLR then do;              DATA8 = DATA8 | I; CREATE_1 = true;            end;          end;          if ~CREATE_1 then pcmd('Illegal key name');        end; else CLR = true;      end;      do;                               /* 003 Split point change */        call GET_STR ('Split note (concert pitch): ',true,BUFF,3);        if BUFF(0) > 0 then do;          I = KEY_NUMBER (BUFF,true);          if -12 <= I & I <= 72 then do;            DATA8    = I & LBYTE;            CREATE_1 = true;          end;          else pcmd('Illegal note');        end; else CLR = true;      end;      do;                              /* 004 Transpose change */        pstring('Transpose: '); I = GET_NUM;        if -64 < I & I < 64 then do; CREATE_1 = true; DATA8 = DATA8 \ (I&MASK7); end;        else if I ~= nullint then pcmd('Illegal transpose');        else CLR = true;      end;      do;                             /* 005 Resolution change */        pstring('Resolution: '); I = GET_NUM;        if POWER(I) then do; CREATE_1 = true; DATA8 = DATA8 \ I; end;        else if I ~= nullint then pcmd('Illegal resolution');        else CLR = true;      end;      do;                             /* 006 Format Bits change */        pstring ('Format:'); I = 0; J = 0; DATA8 = 0;        do while J ~= cr & J ~= del;          pos(cmdline,8);               if (DATA8 & P_UPER) ~= 0 then wchar(asc.U);  /* Upper voice */          else if (DATA8 & P_LOER) ~= 0 then wchar(asc.L);  /* Lower voice */          else                               wchar(asc.min);               if (DATA8 & P_BEND) ~= 0 then wchar(asc.b);   else wchar(asc.min); /* Pitch bend */               if (DATA8 & P_NATR) ~= 0 then wchar(lower.n); else wchar(asc.min);  /* Naturals */               if (DATA8 & P_FLAT) ~= 0 then wchar(lower.f); else wchar(hash); /* Sharps or flats */               if (DATA8 & P_JAZZ) ~= 0 then wchar(asc.J);  /* Jazz */          else if (DATA8 & P_CLAS) ~= 0 then wchar(asc.C);  /* Classical */          else                               wchar(asc.M);  /* Modern */          pos(cmdline,8+I); J = rchar;          do case I; /* This code is redundant with get_entry and should be procedurized */            do; /* COL 1 Get U bit (Voice)*/              if      J = ht    then DATA8 = DATA8 & ~(P_UPER \ P_LOER);              else if J = asc.1 then DATA8 = (DATA8 & ~P_LOER) \ P_UPER;              else if J = asc.2 then DATA8 = (DATA8 & ~P_UPER) \ P_LOER;            end;            do; /* COL 2 Get B bit (Pitch Bend) */              if      J = ht    then DATA8 = DATA8 & ~P_BEND;              else if J = asc.1 then DATA8 = DATA8 \  P_BEND;            end;            do; /* COL 3 Get N bit (Natural Signs)*/              if      J = ht    then DATA8 = DATA8 & ~P_NATR;              else if J = asc.1 then DATA8 = DATA8 \  P_NATR;            end;            do; /* COL 4 Get F bit (Accidental) */              if      J = ht    then DATA8 = DATA8 & ~P_FLAT;              else if J = asc.1 then DATA8 = DATA8 \  P_FLAT;            end;            do; /* COL 5 Get S bits (Syncopation)*/              if      J = ht    then DATA8 = (DATA8 & ~P_JAZZ) \ P_CLAS;              else if J = asc.1 then DATA8 = DATA8 & ~(P_JAZZ \ P_CLAS);              else if J = asc.2 then DATA8 = (DATA8 & ~P_CLAS) \ P_JAZZ;            end;          end;               if J = cur.left  & I > 0 then I = I - 1; /* Move left to previous edit position */          else if J = cur.right & I < 4 then I = I + 1; /* Move right to next edit position */          else if J = cr  then CREATE_1 = true;          else if J = del then CLR = true;        end;      end;      call GET_ACCD_CHANGE;           /* 007 Accidental change */      do;                             /* 010 Set stem direction */        DATA8 = DATA8 \ GET_DIRECTION; CREATE_1 = true;      end;      do;                             /* 011 Track change */        pstring('Track: '); I = GET_NUM;        if (0 <= I & I <= MAX_LEGAL_TRACKS#) then do;          CREATE_1 = true; DATA8 = DATA8 \ I;        end;        else if I ~= nullint then pcmd('Illegal track');        else CLR = true;      end;      NSPC:do;                        /* 012 Note spacing change */        pstring('Note Spacing: '); I = GET_NUM;        if 0 < I & I < 256 then do;          CREATE_1 = true; DATA8 = I;        end;        else if I ~= nullint then pcmd('Illegal note spacing');        else CLR = true;      end;      do;                             /* 013 Stem length */        pstring('Stem Length: '); I = GET_NUM;        if 0 <= I & I < 128 then do;          CREATE_1 = true; DATA8 = DATA8 \ I;        end;        else if I ~= nullint then pcmd('Illegal stem length');        else CLR = true;      end;      do;                             /* 014 Rest positioning */        pstring('Rest Offset: '); I = GET_NUM;        if -64 < I & I < 64 then do;          CREATE_1 = true; DATA8 = DATA8 \ (I & MASK7);        end;        else if I ~= nullint then pcmd('Illegal entry');        else CLR = true;      end;      call GET_ACCD_CHANGE; /* 015 Enharmonic change */      do;                             /* 016 Head change */        pstring('Note head type: '); J = 0; DATA8 = 0;        do while J ~= cr & J ~= del;          pos(cmdline,16); K = 0;          do I = 0 to DATA8;            do while byte(HD_LABS,K) ~= sp;              if I = DATA8 then wchar(byte(HD_LABS,K));              K = K + 1;            end;            K = K + 1;          end;          erase_line; wchar(sp); J = rchar;          if lower.a <= J & J <= lower.z then J = J - 32;          if      J = ht    then DATA8 = HD_STANDARD#;          else if J = asc.1 then DATA8 = HD_GRACE#;          else if J = asc.2 then DATA8 = HD_XNOTE#;          else if J = asc.3 then DATA8 = HD_SHAPE#;          else if J = asc.4 then DATA8 = HD_4SHAPE#;          else if J = asc.5 then DATA8 = HD_NONE#;          else if J = asc.6 then DATA8 = HD_PERC#;          else if J = asc.d then DATA8 = "10";          else if J = asc.r then DATA8 = "11";          else if J = asc.m then DATA8 = "12";          else if J = asc.f then DATA8 = "13";          else if J = asc.s then DATA8 = "14";          else if J = asc.l then DATA8 = "15";          else if J = asc.t then DATA8 = "16";/*          else if J = comma then DATA8 = HD_LHD#;          else if J = dot   then DATA8 = HD_RHD#;          else if J = slash then DATA8 = HD_BHD#;*/          else if J = asc.a then DATA8 = HD_HARM#;          else if J = asc.h then DATA8 = HD_DIAM#;          else if J = cr  then CREATE_1 = true;          else if J = del then CLR = true;        end;        DATA8 = DATA8 \ VBIT;      end;      do;                               /* 017 Transposed split point change */        call GET_STR ('Split note: ',true,BUFF,3);        if BUFF(0) > 0 then do;          I = KEY_NUMBER (BUFF,true);          if -12 <= I & I <= 72 then do;            DATA8    = I & LBYTE;            CREATE_1 = true;          end;          else pcmd('Illegal note');        end; else CLR = true;      end;      do;                        /* 020 Staff spacing change */        pstring('Staff Space: '); I = GET_NUM;        if 0 <= I & I < 256 then do;          CREATE_1 = true; DATA8 = I;        end;        else if I ~= nullint then pcmd('Illegal entry');        else CLR = true;      end;      do;                        /* 021 Part note spacing change */        C = "12"; goto NSPC;      end;      do;                        /* 022 Measures/Line change */        pstring('Measures/Line: '); I = GET_NUM;        if 0 <= I & I < 256 then do;          CREATE_1 = true; DATA8 = I;        end;        else if I ~= nullint then pcmd('Illegal entry');        else CLR = true;      end;    end;    else if C < "70" then CREATE_1 = true; /* 40 one word flag records */    else if C < "76" then do;      if EDIT_NOTE (PP,C & MASK3) then erase_command; /* Clear non-error message */      if EDIT_MODE = 0 then do;        call UPDATE_VOICE; /* Update "voice" display item */        pos(cmdline,0);      end;    end;    else if "130" <= C & C <= "137" then do;      if EDIT_NOTE (PP,8 + (C & MASK3)) then erase_command; /* Clear non-error message */      if EDIT_MODE = 0 then do;        call UPDATE_VOICE; /* Update "voice" display item */        pos(cmdline,0);      end;    end;    else if C < "100" then do;      if EDIT_SEQUENCE (PP,C & MASK3) then do;        erase_command; /* Clear non-error message */        return (ctrl.r);      end;    end;    else if C = "102" \ C = "104" then do; /* 102 Note, 104 Grace Note */      pstring('Note value: '); DATA8 = GET_NUM;      if POWER(DATA8) then do;        if DATA8 > 1 & GET_DIRECTION then DATA16 = DATA16 \ R_DIR;        CREATE_2 = true; PLOTREC = true;      end;      else if DATA8 ~= nullint then pcmd('Illegal value');      else CLR = true;    end;    else if C = "103" \ C = "105" then do; /* 103 Rest, 105 Grace Rest */      pstring('Rest value: '); DATA8 = GET_NUM;      if POWER(DATA8) then do;        CREATE_2 = true; PLOTREC = true;      end;      else if DATA8 ~= nullint then pcmd('Illegal value');      else CLR = true;    end;    else if C = "106" then do; /* 106 Chord name */      call GET_STR ('Chord name (concert pitch): ',true,BUFF,2);      if BUFF(0) > 0 then do;        I = KEY_NUMBER (BUFF,true);        if I ~= nullint then do;          DATA8        = I mod 12;          CREATE_2     = true;          PLOTREC      = true;          TRANSPOSE(0) = 0;          PBITS        = 0;        end;        else pcmd('Illegal chord');      end;      else CLR = true;    end;    else if C = "107" then do; /* 107 Bar line */      DATA8    = 0;    /* For future use */      CREATE_2 = true;      PLOTREC  = true;    end;    else if "110" <= C & C < "140" then do case (C - "110"); /* 32 two word records */      do;                                                    /* 110 Voice a chord */        P = GET_NOTE (true,false,false,'Mark lower voice');        if P ~= null then do;          DATA16 = CHORD_MASK; CREATE_2 = true;        end;      end;      do;                             /* 111 Set ties of a chord */        P = GET_NOTE (true,true,false,'Mark down ties');        if P ~= null then do;          DATA16 = CHORD_MASK; CREATE_2 = true;        end;      end;      ;;;;;;      call GET_TIME_SIGNATURE;        /* 120 - Time signature change */      do;                             /* 121 - Click note change */        pstring('Click Note: '); DATA16 = GET_FRACTION (false);        if DATA16 = 0 then pcmd('Illegal click note');        else if DATA16 = nullint then CLR = true;        else do;          CREATE_2 = true; DATA8 = 0;        end;      end;      do;                             /* 122 - Measure multiplier change */        pstring('Time value of measure: '); DATA16 = GET_FRACTION (true);        if DATA16 = 0 then pcmd('Illegal measure fraction');        else if DATA16 = nullint then CLR = true;        else do;          DATA8 = 0;          pcmd('Pickup or Cadenza (P or C): '); I = rchar;          if I = asc.c \ I = lower.c then DATA8 = 1;          if I = del then CLR      = true;                     else CREATE_2 = true;        end;      end;      goto BSPC;      BSPC:do;                        /* 123,124 - Block spacing change (MASTER,PART) */        pstring('Spacing (Left/Right): '); I = GET_NUM;        if I ~= nullint then do;          wchar(slash); DATA16 = GET_NUM;          if 0 <= I & I < 64 & 0 <= DATA16 & DATA16 < 64 then do;            CREATE_2 = true;            DATA8 = 0; DATA16 = shl(I*4,8) \ DATA16*4;          end;          else pcmd('Illegal spacing');        end;        else CLR = true;      end;      do;                             /* 125 - Measure number positioning */        pcmd('Big measure numbers (Y or N)? '); I = rchar;        if I = asc.y | I = lower.y then DATA8 = 1; else DATA8 = 0;        if I = del then CLR = true;        else do;          pcmd('Boxed measure numbers (Y or N)? '); I = rchar;          if I = asc.y | I = lower.y then DATA8 = DATA8 | 2;          if I = del then CLR = true;        end;        if ~CLR then CREATE_2 = true;      end;    end;    else if C = "146" & EDIT_POS(LEVEL) ige LONG_POSITION & /* If midpoint of a long symbol */            shr(LONG_SYM(0),8) = "150"                      /* and a slur */    then do; /* Set Midpoint */      LONG_SYM(0) = LONG_SYM(0) + 2;      LONG_SYM(1) = LONG_SYM(1) \ R_MID;      LONG_SYM(4) = EDIT_POS(LEVEL) - LONG_POSITION;      LONG_SYM(5) = DATA16;    end;    else if C = "147" & LONG_FLAG & EDIT_POS(LEVEL) ige LONG_POSITION then do; /* If Endpoint of a long symbol */      LONG_SYM(2) = EDIT_POS(LEVEL) - LONG_POSITION;      LONG_SYM(3) = DATA16;      LONG_FLAG   = false;      CREATE_M    = true;      if shr(LONG_SYM(0),8) = "160"      then call POSITION_NSLUR (LONG_SYM,LONG_PP,LONG_X); /* New cubic slur */    end;    else if "150" <= C & C < "170" then do;         if C = "150" | C = "151" | C = "157" | C = "160" /* If a slur, hairpin, brace, newslur */      then if GET_DIRECTION then DATA16 = DATA16 \ R_DIR;   /* If direction designated */      LONG_SYM(0)   = shl(C,8) \ 4;      LONG_SYM(1)   = DATA16;      LONG_POSITION = EDIT_POS(LEVEL);      /* Long symbol edit position */      LONG_X        = XBASE;                /* Long symbol X position */      LONG_PP       = PP;                   /* Long symbol position pointer */      LONG_FLAG     = true;      if C = "152" then do; /* If a tuplet bar */        pstring('Bar type: '); J = GET_NUM; erase_command;        if J < 0 \ J > 3 then J = 0;        if J = 0 \ J = 3 then if GET_DIRECTION then LONG_SYM(1) = LONG_SYM(1) \ R_DIR;        pstring('Tuplet type: '); I = GET_NUM; erase_command;        if I = nullint     then I = 3;        if I < 0 \ I > 255 then I = 0;        LONG_SYM(0) = LONG_SYM(0) + 1;        LONG_SYM(4) = shl(J,8) \ I;      end;      else if C = "153" then        LONG_SYM(1) = shl(EDIT_FONT,12) | DATA16;      else if C = "156" then do; /* Line */        pstring('Line type: '); J = GET_NUM; erase_command;        if J < 0 \ J > 4 then J = 0;        pstring('Line width: '); I = GET_NUM; erase_command;        if I < 1 \ I = nullint then I = 1;        if I > 255             then I = 255;        LONG_SYM(0) = LONG_SYM(0) + 1;        LONG_SYM(4) = shl(J,8) \ I;      end;      else if C = "160" then LONG_SYM(0) = LONG_SYM(0) + 2; /* New cubic slur */    end;    else if C = "170" | C = "171" then do; /* 170 Guitar chord frame */      call GET_STR ('Chord name (concert pitch): ',false,BUFF,12);      if BUFF(0) > 0 then do;        LONG_SYM(0)   = shl(C,8) \ 8;        LONG_SYM(1)   = DATA16;        do K = 0 to 11;          if K < BUFF(0)           then call pbyte (loc(addr(LONG_SYM(1))),K,byte(BUFF,K));          else call pbyte (loc(addr(LONG_SYM(1))),K,0);        end;        LONG_POSITION = EDIT_POS(LEVEL);      /* Long symbol edit position */        LONG_X        = XBASE;                /* Long symbol X position */        LONG_PP       = PP;                   /* Long symbol position pointer */        CREATE_M     = true;        PLOTREC      = true;        TRANSPOSE(0) = 0;        PBITS        = 0;      end;      else CLR = true;    end;    else if C = "177" & ~MASTER_VOICE then do; /* 1 sublist (tuplet) record */      pstring('Tuplet Type: '); K = GET_NUM;      if K ~= nullint then do;        pcmd ('Time Value: '); I = GET_NUM;        if I ~= nullint then do;          wchar(slash); J = GET_NUM;        end;      end;      if K = nullint \ J = nullint \ I = nullint then CLR = true;      else if 0 < K & K < 128 & 0 < I & I < 256 & POWER(J) & J <= EDIT_RESOLUTION then do;        I = (I * EDIT_RESOLUTION) / J; /* Old blocks */        do while K < I; K = K * 2; end; /* New blocks */        DATA16   = shl(K,8) \ I;        CREATE_S = true;      end;      else pcmd('Illegal tuplet');    end;    else return (C); /* A keypad character */    if CLR \ CREATE_1 \ CREATE_2 \ CREATE_S \ CREATE_M then erase_command;    if MVOX & LEVEL ~= 0 then call SYSERROR ('Level ~= 0 for Master Edit');    /* Create a record and insert it into the file */    if CREATE_1 then do;         /* Creating and save a one word record */      BUFF(0) = shl(C,8) \ (DATA8 & LBYTE);      call INSERT_RECORD (MVOX,1,BUFF);    end;    else if CREATE_2 then do;    /* Creating and save a two word record */      BUFF(0) = shl(C,8) \ (DATA8 & LBYTE);      BUFF(1) = DATA16;      if PLOTREC then call PLOT_RECORD (BUFF,null,XBASE);      call INSERT_RECORD (MVOX,2,BUFF);    end;    else if CREATE_S then do;   /* If creating a sublist */      BUFF(0) = shl(C,8) \ (DATA8 & LBYTE);      BUFF(1) = DATA16;      BUFF(2) = 1;      call INSERT_RECORD (MVOX,3,BUFF);    end;    else if CREATE_M then do;    /* If creating a multi word record */      I = EDIT_POS(LEVEL); EDIT_POS(LEVEL) = LONG_POSITION;      call EDIT_MARK (LONG_X); /* Draw an edit mark (this must happen before PLOT_RECORD) */      call PLOT_RECORD (LONG_SYM,LONG_PP,LONG_X);    /* Plot the record */      call INSERT_RECORD (MASTER_VOICE,LONG_SYM(0) & LBYTE,LONG_SYM);  /* Insert a record into an edit list */      EDIT_POS(LEVEL) = I;         /* Set the edit position */    end;    if (CREATE_1 \ CREATE_2 \ CREATE_S) & ~LAST_EDIT then call EDIT_MARK (XBASE); /* Draw an edit mark */  end;end COMMAND_PROCESS;BLOCK_PROCESS:procedure swap2; /* Processes cursor movements within an edit block */  dcl C fixed; /* Character */  do forever;    if term_idle & EDIT_MODE = STATUS# then call EDIT_TEXT (2,false);/*    call CLEAN_SEQUENCE (true); */    C = COMMAND_PROCESS;   /* process the command and return a character from lower lvel processing*/    if      C = cur.up   then do;      if CY < 180 then CY = CY + 3;    /* move up one unit */    end;    else if C = cur.down then do;      if CY >   0 then CY = CY - 3;    /* move down one unit */    end;    else if C = pf.3 & ~LAST_EDIT then do;       if XOFF > -120 then XOFF = XOFF - 4; /* Move left one half note head */    end;    else if C = pf.4 & ~LAST_EDIT then do;      if XOFF < 120  then XOFF = XOFF + 4; /* Move right one half note head */    end;    else if C = ctrl.e then do;      if      EDIT_FONT = F_BOLDITALIC# then EDIT_FONT = F_ALPHA#;      else if EDIT_FONT = F_ALPHA#      then EDIT_FONT = F_STANDARD#;      else                                   EDIT_FONT = EDIT_FONT + 1;    end;    else if C = ctrl.b then do;      if TSIZE = 2 then TSIZE = 1; else TSIZE = 2;      if TSIZE = 1 then BOXTX = ~BOXTX;    end;    else if C = ctrl.n then do;      AUTO_CENTER = ~AUTO_CENTER;    end;    else if C = ctrl.f then if CY < 90 then CY = 132; else CY = 48; /* Flip the cursor above or below the staff */    else if C = lf then do;      LIBRARY = ~LIBRARY & MASK1;      if EDIT_MODE = STATUS# then do;        call EDIT_TEXT (2,false);       /* Update the X offset, Y position, and bank settings */        call KEYPAD_REF;                /* Draw the keypad bank setting */      end;    end;    else if C = ctrl.u then do;      EXTENDED = ~EXTENDED & MASK1;      if EDIT_MODE = STATUS# then do;        call EDIT_TEXT (2,false); /* Update the X offset, Y position, and bank settings */        call KEYPAD_REF;          /* Draw the keypad bank setting */      end;    end;    else return (C);  end;end BLOCK_PROCESS;EDITOR:procedure (TOP_POS) public swap2;  /* Editor driver routine */  dcl TOP_POS   fixed,                    BEAT      fixed,      (C,F,I,J) fixed;  cmdline        = 20;  STAFF          = 0;  PART           = DISPLAY(0);  VOX            = 0;               /* Voice (0 -> Lower, 1 -> Upper, 2 -> Master)*/  VOICE          = 0;               /* Voice ( 0 -> Lower, 1 -> Upper) */  MAX_LEVEL      = 3;               /* Maximum tuplet level */  REPLOT_MEASURE = 0;  BEAT           = (EDIT_RESOLUTION * shr(CLICK_NOTE,8)) / (CLICK_NOTE & LBYTE);  MASTER_VOICE   = false;   ALL_PARTS      = false;   LAST_EDIT      = false;  LONG_FLAG      = false;  if EDIT_POSITION = 0 then call SYSERROR ('Editpos 0 in editor startup');  BASE_MEASURE_NUMBER = MEASURE_NUMBER;  BASE_EDIT_POS       = EDIT_POSITION;  EDIT_POS(0)         = EDIT_POSITION;  call FIND_NEAREST (1);   if RESET_EDITOR then do;    if STAVES = 0 then CY = 48;  /* If only one staff, then set cursor at predetermined location */    else do;                     /* If cursor is between staves */      CY = 90 - STAFF_SPACE(DISPLAY(1)) / 2;  /* Determine the vertical cursor position */      if CY < 0 then CY = 0;                else CY = CY - CY mod 3;    end;    RESET_EDITOR = false;  end;  viewport (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#); /* Set the plotting display area */  iwindow  (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#);  imove_to (0,EDIT_BOT#); iplot (SCREEN_WIDTH#,EDIT_BOT#);  if EDIT_MODE = STATUS# then do;         call GRID;                       /* Draw bank dividers */    call EDIT_TEXT (0,false);        /* Print the prompt settings for part */    call KEYPAD_REF;                 /* Print and refresh bank settings */  end;  XOFF      = 0;  STAFF_POS = TOP_POS - STAFF_SPACE(PART);   /* Set window for display screen */  call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,EDIT_BOT#);  do forever;    I = ((core(PP+D6) & B_BAR) ~= 0 & LEVEL = 0) \ LAST_EDIT;    if term_idle then do case EDIT_MODE;      call EDIT_TEXT (1,I);    /* Print the edit settings */      call LIST_DISPLAY;    end;    C = BLOCK_PROCESS;    if C = kp.0 then return; /* Move to next page */    else if C = ctrl.a & MEASURE_NUMBER > 0 then do; /* Replot from current measure */      REPLOT_MEASURE = MEASURE_NUMBER;      call RE_START; /* Exit */    end;    else if C = kp.enter \ C = ctrl.r \ C = asc.refresh then do; /* Return to main menu or replot */      if C = ctrl.r \ C = asc.refresh then REPLOT_MEASURE = BASE_MEASURE_NUMBER; /* Replot from same measure */      call RE_START; /* Exit */    end;    else if C = ctrl.w then do;      transparent_mode; pcmd('Jump to Measure: '); I = GET_NUM;      if I ~= nullint then do;        if INIT_MEAS <= I & (LAST_MEAS = 0 \ I <= LAST_MEAS) then do;          REPLOT_MEASURE = I;          call RE_START;        end;        else pcmd('Illegal measure number');      end;    end;    else if C = pf.1 & STAFF > 0 then do; /* Up a staff */      STAFF_POS = STAFF_POS + STAFF_SPACE(PART);      call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,EDIT_BOT#);      STAFF = STAFF - 1; PART = DISPLAY(STAFF);      call FIND_NEAREST (XBASE);    /* Find the nearest base X position to the notehead */    end;    else if C = pf.2 & STAFF < STAVES then do; /* Down a staff */      STAFF = STAFF + 1; PART = DISPLAY(STAFF);      STAFF_POS = STAFF_POS - STAFF_SPACE(PART);      call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,EDIT_BOT#);      call FIND_NEAREST (XBASE);   /* Find the nearest base X position to the notehead */    end;    else if C = cur.right then call FIND_NEXT;  /* Find next edit position */    else if C = cur.left  then call FIND_LAST;  /* Find previous edit position */    else if C = ctrl.l    then call FIND_NEXT_NOTE;  /* Find next edit position with a note */    else if C = ctrl.k    then call FIND_LAST_NOTE;  /* Find previous edit position with a note */    else if C = ctrl.z then do; /* Left to last block */      MAX_LEVEL = 0;      call FIND_LAST;      do while (core(PP+D6) & B_BAR) = 0 & ~LAST_EDIT;        call FIND_LAST;      end;      MAX_LEVEL = 3;    end;    else if C = ctrl.x then do; /* Right to last block */      MAX_LEVEL = 0;      if LEVEL > 0 then call FIND_NEAREST (XBASE);      call FIND_NEXT;      do while (core(PP+D6) & B_BAR) = 0;        call FIND_NEXT;      end;      MAX_LEVEL = 3;    end;    else if C = ctrl.t then do; /* Left to beat */      F = false; I = 1;      do while ~F & I ~= 0;        F = FIND_LAST;        J = EDIT_POS(LEVEL);        if LEVEL = 0 then J = J - 1;        write(5)   = J;        write(7)   = BEAT;        I          = read(4);      end;    end;    else if C = ctrl.y then do; /* Right to beat */      F = false; I = 1;      do while ~F & I ~= 0;        F = FIND_NEXT;        J = EDIT_POS(LEVEL);        if LEVEL = 0 then J = J - 1;        write(5)   = J;        write(7)   = BEAT;        I          = read(4);      end;    end;    else if C = bs then do;      VOX          = (VOX + 1) mod 4;      VOICE        = 0;      MASTER_VOICE = false;      ALL_PARTS    = false;      do case VOX;        ;                    /* Lower voice */        VOICE        = 1;    /* Upper voice */        MASTER_VOICE = true; /* Master voice */        ALL_PARTS    = true; /* All parts */      end;      call FIND_NEAREST (XBASE); /* Find the nearest base X position to the notehead */    end;    else if C = ctrl.c & EDIT_MODE = LIST_DISPLAY# then call DELETE_RECORD (false); /* CTRL-D - delete the edit record */    else if C = ctrl.d then call DELETE_RECORD (true);  /* CTRL-D - delete the edit record */    else if C = ctrl.v & LEVEL > 0 then do;      /* CTRL-V - move down a tuplet level */      MAX_LEVEL = LEVEL - 1;     /* Decrease the number of possible tuplet levels */      call FIND_NEAREST (XBASE);      MAX_LEVEL = 3;    end;/*    else if DEBUG & C = ctrl.n then call print_nah_area;    else if DEBUG & C = ctrl.l then print_edit;    else if DEBUG & C = ctrl.p then examen (POS_HEAD,POSN#,'From Editor');    else if DEBUG & C = 28 then examen (HEAD(PART),NOTE#,'From Editor');*/    else if C = ctrl.p then do; /* Play */      transparent_mode;      pos(20,0); erase_line;      pos(20,64); reverse(1); pstring('     Play     '); reverse(0);      call PLAY_SEQUENCE (true); /* Overlay to runtime - keep screen */    end;  end; /* End of forever loop */end EDITOR;end EDITRTNS;