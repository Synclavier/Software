/* $title List Building Routines */module LISTRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';/* Module globals */dcl    CLEAR_LASER_PRINTER procedure external,       MAIN_MODE           fixed external;/* Storage for notelist scanning */dcl    TIME(1)                  fixed public,       MEAS_START(1)            fixed public,       LAST_START(1)            fixed,       LO_THRESH(1)             fixed,       SEQ_WRAPS(MAX_PARTS*2-1) fixed, /* This could allow a more sophisticated way of handling track change */       MODE            fixed,       BEAM_DIV        fixed public,       RES_MULT        fixed public,       STEM_LENGTH     fixed,       WHOLE_SIZE      fixed,       NOTE_BLOCKS     fixed,       POS_BLOCKS      fixed,       TICS_MEASURE    fixed,       MEAS_DIV        fixed,       MEAS_ON_LINE    fixed,       RACK            fixed,       NEW_TRACK(1)    fixed,       END_RACK(3)     fixed public,       REST_OFFSET(1)  fixed,       VOX_MASK        fixed,       VALID_VOX_MASK  fixed,       SET_ACC         boolean,       HOLD_DBAR       boolean public,       HOLD_OREP       boolean public,       HOLD_TIME       boolean public,       CADENZA         boolean,       PARTL_MEAS      boolean,       STEM_DIR        boolean,       BEAM_FLAGS      boolean public,       BREAK_NOTE      boolean,       FORCE_ACCD      boolean,       SET_LO          boolean,       DONE            boolean public,       NOTES           boolean,       END_OF_LINE     boolean,       END_BLOCK       boolean;dcl    ED_NEW          fixed public,       ED_OLD          fixed public,       NEW_CLEF        fixed public,       NEW_KEY         fixed public;/* Tables and buffers *//*dcl PRIME_COUNT lit '28';dcl PRIME_TABLE fixed data (2, 3, 5, 7, 11,13,17,19,23,29,31,37,41,43,47,                            53,59,61,67,71,73,79,83,89,97,101,103,107,109);*/dcl ACC_LIST(32)         fixed, /* If this size is changed, change SCAN_CHORD */    ACC_CHANGE_LIST(8)   fixed;insert ':mplt:beamfncs';insert ':mplt:listfncs';/* List building routines */NOTE_INSERT:procedure (LP,REC_P); /* Insert a heap record into a chord list by Key No. */ dcl  REC_P  pointer,      (LP,P) pointer;  P = core(LP);  do while (core(REC_P+D5) & LBYTE) <= (core(P+D5) & LBYTE) & P ~= null;    LP = core(LP); P = core(P);  end;  core(LP) = REC_P; core(REC_P) = P;end NOTE_INSERT;POSITION_CHORD:procedure (CHRD_PTRS,PPSN,ADV);  dcl CHRD_PTRS pointer array,      PPSN      fixed,      ADV       fixed,      (CI,NI)   fixed;  CHRD_PTRS(TAIL#) = core(CHRD_PTRS(CURC#));  CI               = 0;  NI               = core(CHRD_PTRS(CURC#)+D5) & LBYTE;  do while NI <= PPSN & CHRD_PTRS(CURC#) ~= null;    CHRD_PTRS(HEAD#) = CHRD_PTRS(CURC#);    CHRD_PTRS(CURC#) = CHRD_PTRS(TAIL#);    CHRD_PTRS(TAIL#) = core(CHRD_PTRS(TAIL#));    CI               = NI;    NI               = NI + (core(CHRD_PTRS(CURC#)+D5) & LBYTE);  end;  if CI < PPSN then do;    core(CHRD_PTRS(CURC#)+D5) = (core(CHRD_PTRS(CURC#)+D5) & UBYTE) \ (PPSN - CI);    CHRD_PTRS(HEAD#)          = CHRD_PTRS(CURC#);    CHRD_PTRS(CURC#)          = null;    ADV                       = NI - PPSN;  end;  else if CI = PPSN then ADV = core(CHRD_PTRS(CURC#)+D5) & LBYTE;  return (ADV);end POSITION_CHORD;INSERT_CHORD:procedure (NOTE_PTRS,CHRD_PTRS) returns (pointer);  dcl NOTE_PTRS pointer array,      CHRD_PTRS pointer array,      (P,NP,Q)  pointer;  Q = ALLOCATE;  if CHRD_PTRS(CURC#) = null \ (core(Q+D6) & B_TUP) ~= 0 \     (       (core(CHRD_PTRS(CURC#)+D6) & B_TUP) = 0 &       (core(Q+D2) & LBYTE) > (core(CHRD_PTRS(CURC#)+D2) & LBYTE)     )  then do;    core(Q)     = CHRD_PTRS(TAIL#);    core(Q+GRP) = CHRD_PTRS(CURC#);    if CHRD_PTRS(HEAD#) ~= null then core(CHRD_PTRS(HEAD#)) = Q;    if CHRD_PTRS(CURC#) ~= null then core(CHRD_PTRS(CURC#)) = Q;    CHRD_PTRS(CURC#) = Q;  end;  else do;    P = CHRD_PTRS(CURC#); NP = core(P+GRP);    do while NP ~= null & (core(Q+D2) & LBYTE) <= (core(NP+D2) & LBYTE);      P = NP; NP = core(P+GRP);    end;    core(P+GRP) = Q;    core(Q+GRP) = NP;    core(Q)     = P;    if NP ~= null then core(NP) = Q;  end;  if CHRD_PTRS(HEAD#) = null then NOTE_PTRS(HEAD#) = CHRD_PTRS(CURC#);  if CHRD_PTRS(TAIL#) = null then NOTE_PTRS(TAIL#) = CHRD_PTRS(CURC#);  return (Q);end INSERT_CHORD;SEARCH:procedure (P,STRING_NO,GUITAR) returns(pointer); /* Search a heap for string no. */  dcl P         pointer,      STRING_NO fixed,      GUITAR    boolean;  do while P ~= null;    if (shr(core(P+D4),12) & MASK4)   = STRING_NO &       ((core(P+D6) & H_GUITAR) ~= 0) = GUITAR    then return (P);    P = core(P);  end;  return (null);end SEARCH;VOICE_LOAD:procedure (T1,T2);  dcl T1       fixed array,      T2       fixed array,      TIE_CODE fixed,      (P,LP)   pointer;  LP = addr(VOX_HEAD); P = VOX_HEAD;  do while P ~= null;    if (T1(1) ilt core(P+D2X) \ (T1(1) = core(P+D2X) & T1(0) ile core(P+D2)))     & (T2(1) igt core(P+D2X) \ (T2(1) = core(P+D2X) & T2(0) ige core(P+D2)))    then do;      core(LP) = core(P);      TIE_CODE = GET_TIE_CODE;      if TIE_CODE < 0 then call FREE (P); /* Out of tie codes: ding note */      else do;        core(P+D5) = (core(P+D5) & ~THRD4) \ shl(TIE_CODE,8);        core(P+D6) = (core(P+D6) & ~H_DIR) \ H_SET \ VOICE;        call NOTE_INSERT (addr(NEW_HEAD),P);      end;      P = core(LP);    end;    else do;      P = core(P); LP = core(LP);    end;  end;end VOICE_LOAD;HEAP_LOAD:procedure (PURGE);  dcl PURGE    boolean,      (P,LP,V) pointer;  RACK = 0;  LP   = addr(HEAP_HEAD);  P    = HEAP_HEAD;  do while P ~= null;    if shr(core(P+D6),8) = PART & (core(P+D6) & MASK1) = VOICE then do;      core(LP) = core(P);      if PURGE then do;        if core(P+D0) ~= null then core(core(P+D0)+D6) = core(core(P+D0)+D6) & ~B_OTIE;        call FREE (P);      end;      else do;        call NOTE_INSERT (addr(OLD_HEAD),P);        RACK = RACK \ shl(1,shr(core(P+D5),8) & MASK4);      end;      P = core(LP);    end;    else do;      LP = P; P = core(P);    end;  end;end HEAP_LOAD;SEQ_LOAD:procedure (T1,T2);  dcl T1          fixed array,      T2          fixed array,      START(1)    fixed,      VOX         fixed,      KEY_NO      fixed,      DURATION    fixed,      TIE_CODE    fixed,      STRING_NO   fixed,      UPDATE      boolean,      GUITAR      boolean,      VALID       boolean,      P           pointer;/*error_case do;  transparent_mode;  pstring('SeqLoad here: MEASURE# = ');pnum(MEASURE_NUMBER,0);crlf;  pstring('    T1: ');unum(T1(1),0);unum(T1(0),8);crlf;  pstring('    T2: ');unum(T2(1),0);unum(T2(0),8);crlf;  pstring(' Track: ');unum(TRACK(VOICE),0);crlf;end;*/  if #STATUS = OUT#    then return; /* This track is finished or not there */  if #STATUS = UNINIT# then do; /* Init #'s to 1st note on track */    if ~INIT_SEQ_GLOBALS(TRACK(VOICE)) then do;      #STATUS = OUT#;      return;    end;    else #STATUS = VALID#;  end;  if #STATUS = VALID# then do; /* Position #'s to just inside window */    call POSITION_SEQ_GLOBALS (T1);    #STATUS = ACTIVE#;  end;/*error_case do;  pstring('After track time locate NLSB,WRD,ANYF ');  pnum(#NLSB,0);pnum(#WRD,10);pnum(#ANYF,10);crlf;end;*/  do forever; /* Loop through notes in window */    if ~#ANYF then do;      #STATUS = OUT#;      return;    end;    if #NMSB igt T2(1) \ (#NMSB = T2(1) & #NLSB igt T2(0)) then return;    if #NMSB igt T1(1) \ (#NMSB = T1(1) & #NLSB ige T1(0)) then do;      call LOOK.UP.NOTE.INFO;      VALID     = true;      VOX       = VOICE;      START(1)  = #NMSB;      START(0)  = #NLSB;      KEY_NO    = #W2 & MASK6;      if KEY_NO = REST_KEY# then VALID = false;      if rot(#W1,1) then VALID = false;      KEY_NO    = KEY_NO + 12;      UPDATE    = (#W3 & S_UPDATE) ~= 0;      GUITAR    = (#W3 & S_GUITAR) ~= 0;      STRING_NO = shr(#W3,8) & MASK3;      if (#W4 & S_OCTDN) ~= 0 then KEY_NO = KEY_NO - 12;      if (#W4 & S_OCTUP) ~= 0 then KEY_NO = KEY_NO + 12;      if UPDATE & (PBITS & P_BEND) ~= 0 then do;        P = SEARCH (NEW_HEAD,STRING_NO,GUITAR);        if P ~= null then do; /* Should we really point to the lattest update record? */          core(P+D0) = #SEC;          core(P+D1) = #WRD & LBYTE;          core(P+D5) = (core(P+D5) & UBYTE) \ KEY_NO;          VALID      = false;        end;        else do;          P = SEARCH (OLD_HEAD,STRING_NO,GUITAR);          if P = null & ONE_TRACK then do;            P = SEARCH (VOX_HEAD,STRING_NO,GUITAR);            if P = null then VALID = false;                        else VOX   = 1;          end;          else if P = null \ (core(P+D5) & LBYTE) = KEY_NO then VALID = false;          else do;            START(1)   = core(P+D2X); /* Get start time and duration */            START(0)   = core(P+D2);  /* of initiating note so we know when to ding this one */            DURATION   = core(P+D3);            TIE_CODE   = shr(core(P+D5),8) & MASK4;            core(P+D6) = core(P+D6) \ H_UPDATE;          end;        end;      end;      else if UPDATE then VALID = false;      else if ((PBITS & P_UPER) ~= 0 & KEY_NO <  SPLIT+12) \              ((PBITS & P_LOER) ~= 0 & KEY_NO >= SPLIT+12)      then VALID = false;      else if VALID then do;        DURATION = GET_DURATION;        TIE_CODE = GET_TIE_CODE;        if TIE_CODE < 0 then VALID = false;      end;      if VALID then do;        call CLEAR_REC;        REC(D0)  = #SEC;        REC(D1)  = #WRD & LBYTE;        REC(D2X) = START(1);        REC(D2)  = START(0);        REC(D3)  = DURATION;        REC(D4)  = shl(STRING_NO,12);        REC(D5)  = shl(TIE_CODE,8) \ KEY_NO;        REC(D6)  = shl(PART,8) \ VOX;        if TWO_VOICE then do;          REC(D6) = REC(D6) \ H_SET;          if VOICE = 0 then REC(D6) = REC(D6) \ H_DIR;        end;        if UPDATE then REC(D6) = REC(D6) \ H_SLUR;        if GUITAR then REC(D6) = REC(D6) \ H_GUITAR;        call NOTE_INSERT (addr(NEW_HEAD),ALLOCATE);      end;    end;    call ADVANCE.TO.NEXT.NOTE;  end; /* End of forever loop *//*error_case do;  pstring('Leaving SeqLoad'); D = rchar;end;*/end SEQ_LOAD;VOICE_CHORD:procedure; /* Assign key no. ordering and chuck voice1 notes */  dcl (Q,LQ) pointer,      MAXGAP   fixed,      GAP      fixed,      (I,CNT)  fixed;  /* If there was no voice record, voice by finding the biggest interval (use key no.) */  if VALID_VOX_MASK = NOMASK# & ONE_TRACK then do;    MAXGAP = -1; CNT = 1; I = 1; LQ = NEW_HEAD; Q = core(LQ);    do while Q ~= null;      GAP = (core(LQ+D5) & LBYTE) - (core(Q+D5) & LBYTE);      if GAP > MAXGAP then do;        MAXGAP = GAP; CNT = I;      end;      LQ = core(LQ); Q = core(Q); I = I + 1;    end;    VOX_MASK = shl("177777",CNT);  end;  if VALID_VOX_MASK = B_MASK# then do;    I = 0; Q = NEW_HEAD;    do while (Q ~= null);      I = I + 1;      Q = core(Q);    end;    VOX_MASK = CONVERT_MASK (VOX_MASK,I);  end;  /* Set voicing by VOX_MASK and set note position and count */  LQ  = addr(NEW_HEAD);  Q   = NEW_HEAD;  CNT = 0;  do while Q ~= null;    I = (core(Q+D5) & LBYTE) + TRANSPOSE(VOICE);    core(Q+D1) = shl(TRANSPOSE(VOICE),8) | core(Q+D1);    if TABLATURE then core(Q+D4) = (core(Q+D4) & FRTH4) \                    TAB_NOTE(I,(core(Q+D6)&H_GUITAR)~=0,shr(core(Q+D4),12));                 else core(Q+D4) = (core(Q+D4) & FRTH4) \                    KEY_NOTE(I,byte(ACC_CHANGE_LIST,CNT));    core(Q+D5) = shl(CNT,12) \ core(Q+D5);    if ONE_TRACK & (~VOX_MASK \ (core(Q+D6) & B_VOICE) = 1) then do;      core(LQ)       = core(Q);      core(Q)        = null;      core(VOX_TAIL) = Q;      VOX_TAIL       = Q;      RACK           = RACK & ~shl(1,shr(core(Q+D5),8)&MASK4); /* Clear this tie code from rack */    end;    else LQ = core(LQ);    CNT        = CNT + 1;    VOX_MASK   = shr(VOX_MASK,1);    Q          = core(LQ);  end;end VOICE_CHORD;SCAN_CHORD:procedure (THRESH) returns (boolean); /* Most of the work is done here! */  dcl THRESH    fixed array,      FINISH(1) fixed,      P         pointer,      DONE      boolean;/* SET_ACC is set the first time in a measure this is called.  The first time   this is called it will scan off only HEAP originated notes, and these must   be accounted for in the ACC_LIST.  Why this is done here and not in   HEAP_LOAD is one of life's great mysteries.  */  P = OLD_HEAD; DONE = false;  do while P ~= null;    FINISH(1) = core(P+D2X); /* Get start time */    FINISH(0) = core(P+D2);    call ADD32 (FINISH,core(P+D3)); /* Add duration to get finish time */    if FINISH(1) ilt THRESH(1) \      (FINISH(1) = THRESH(1) & FINISH(0) ile THRESH(0)) then do;      core(P+D6) = core(P+D6) \ H_DONE;      RACK       = RACK & ~shl(1,shr(core(P+D5),8)&MASK4);      DONE       = true;    end;    else if SET_ACC & (core(P+D4) & THRD4) ~= 0 & (PBITS & P_NATR) = 0                    & ACC_LIST(0) < 32 then do;      ACC_LIST(0)           = ACC_LIST(0) + 1;      ACC_LIST(ACC_LIST(0)) = core(P+D4) & MASK12;    end;    P = core(P);  end;  SET_ACC = false;  return (DONE);end SCAN_CHORD;PURGE:procedure (CLEAN);  dcl CLEAN  boolean,      (LP,P) pointer;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 then do;  examen (HEAP_HEAD,HEAP#,'HeapHead at top of Purge');  examen (OLD_HEAD,HEAP#,'OldHead at top of Purge');end;*/  LP = addr(OLD_HEAD); P = OLD_HEAD;  do while P ~= null;    if (core(P+D6) & (H_DONE \ H_UPDATE)) ~= 0 then do;      if (core(P+D6) & H_DONE) ~= 0 & CLEAN      then do;/*        if core(P+D0) ilt CORE_ORIGIN \ core(P+D0) igt msc.ptr then        call SYSERROR ('Heap Back Pointer invalid');*/        if core(P+D0) ~= null then core(core(P+D0)+D6) = core(core(P+D0)+D6) & ~B_OTIE;      end;      core(LP) = core(P);      call FREE (P);      P = core(LP);    end;    else do;      LP = P; P = core(P);    end;  end;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 then do;  examen (HEAP_HEAD,HEAP#,'HeapHead at bottom of Purge');  examen (OLD_HEAD,HEAP#,'OldHead at bottom of Purge');end;*/end PURGE;MERGE:procedure;  dcl (P,Q) pointer;  P = NEW_HEAD;  do while P ~= null;    Q = core(P);    call NOTE_INSERT (addr(OLD_HEAD),P);    P = Q;  end;end MERGE;STACK_CHORD:procedure (NOTE_PTRS,PPSN,COUNT,REST,WHOLE,LEVEL) returns (fixed);  dcl NOTE_PTRS    pointer array,      PPSN         fixed,      COUNT        fixed,      REST         boolean,      WHOLE        boolean,      LEVEL        fixed,      (C,I)        fixed,      (BLKS,TYPE)  fixed,      DUR_ADV      fixed,      ACT_ADV      fixed,      CHRD_PTRS(2) pointer,      P            pointer,      DOTTED       boolean;/*error_case do;  pstring('      STACK_CHORD here PPSN,COUNT,REST,LEVEL ');  pnum(PPSN,10);pnum(COUNT,10);pnum(REST,10);pnum(LEVEL,10);crlf;end;*/    TYPE   = WHOLE#;    DOTTED = false;    if WHOLE then BLKS = COUNT;    else do;      C = COUNT;      if C > MEAS_DIV & MEAS_DIV mod 3 = 0 then C = C - C mod MEAS_DIV;      BLKS = WHOLE_SIZE;      do while (BLKS > C);        BLKS = BLKS / 2; TYPE = TYPE + 1;      end;      I = BLKS + BLKS / 2;      if BLKS > 1 & C = I then do; /* Allow for a dotted note ???? */        BLKS = I; DOTTED = true;      end;    end;    if TYPE = WHOLE# then STEM_LENGTH = 0;    if BLKS = 0 then BLKS = 1; /* TimeSig/Reso incompatable */    DUR_ADV = BLKS * RES_MULT;    if VOICE = 0 \ LEVEL > 0 then do;      CHRD_PTRS(HEAD#) = NOTE_PTRS(TAIL#);      CHRD_PTRS(CURC#) = null;      CHRD_PTRS(TAIL#) = null;      ACT_ADV = DUR_ADV;    end;    else do;      CHRD_PTRS(HEAD#) = null;      CHRD_PTRS(CURC#) = NOTE_PTRS(HEAD#);      ACT_ADV = POSITION_CHORD (CHRD_PTRS,PPSN,DUR_ADV);    end;    if (VOICE = 1 & (PLOTBITS & P_BMOFF1) ~= 0) \       (VOICE = 0 & (PLOTBITS & P_BMOFF0) ~= 0)    then BEAM_FLAGS = BEAM_FLAGS \ B_BREAK;    P = OLD_HEAD;    if REST > 0 then do;      call CLEAR_REC;      REC(D1)  = shl(TRANSPOSE(VOICE),8); /* TRANSPOSE value (ubyte) */      REC(D2) = shl(TYPE,8);      REC(D4) = TRACK(VOICE);      REC(D5) = ACT_ADV;      REC(D6) = B_REST \ VOICE;      if DOTTED then REC(D6) = REC(D6) \ B_DOT;      if WHOLE  then REC(D6) = REC(D6) \ B_CREST;      if REST_OFFSET(VOICE) ~= nullint then do;        REC(D2) = REC(D2) \ (REST_OFFSET(VOICE) & LBYTE);        if REST_OFFSET(VOICE) = 0 then REC(D6) = REC(D6) \ B_SUPREST;      end;      if (VOICE = 1 & (PLOTBITS & P_ROFF1) ~= 0) \         (VOICE = 0 & (PLOTBITS & P_ROFF0) ~= 0)      then REC(D6) = REC(D6) \ B_SUPREST;      call INSERT_CHORD (NOTE_PTRS,CHRD_PTRS);    end;    else do while P ~= null;      call CLEAR_REC;      NOTES = true;      if (core(P+D6) & H_TIED) = 0 then do;        REC(D1X) = core(P+D0); /* Seq pointer SECT */        REC(D1)  = core(P+D1); /* TRANSPOSE value & Seq pointer WORD */        REC(D4)  = core(P+D4) & THRD4; /* Add accidental if not tied-to */      end;      if FORCE_ACCD      then REC(D4)  = core(P+D4) & THRD4; /* Add redundant accidental */      if TABLATURE then        REC(D2) = (core(P+D5) & FRTH4) | (core(P+D4) & MASK12);      else do;        REC(D2) = (core(P+D5) & FRTH4) \ shl(TYPE,8) \ (core(P+D4) & LBYTE);        if      STEM_LENGTH     ~= nullint   then REC(D3) = STEM_LENGTH;        else if HEAD_TYPE(VOICE) = HD_GRACE# then REC(D3) = STANDARD_STEM - 6; /* WAS 3 */        else                                      REC(D3) = STANDARD_STEM;      end;      REC(D4)  = REC(D4) \ TRACK(VOICE);      REC(D5)  = shl(core(P+D5)&THRD4,4) \ ACT_ADV;      REC(D6)  = BEAM_FLAGS \ VOICE;      if DOTTED                         then REC(D6) = REC(D6) \ B_DOT;      if (core(P+D6) & H_TIED)   ~= 0 \         (core(P+D6) & H_SLUR)   ~= 0   then REC(D6) = REC(D6) \ B_CTIE;      if (core(P+D6) & H_SET)    ~= 0   then REC(D6) = REC(D6) \ B_SET;      if (core(P+D6) & H_DIR)    ~= 0   then REC(D6) = REC(D6) \ B_DIR;      if (core(P+D6) & H_DONE)    = 0 \         (core(P+D6) & H_UPDATE) ~= 0 \         BLKS < COUNT                   then REC(D6) = REC(D6) \ B_OTIE;      if STEM_DIR ~= 0 then REC(D6) = (REC(D6) & ~(B_SET\B_DIR)) \ STEM_DIR;      core(P+D0) = INSERT_CHORD (NOTE_PTRS,CHRD_PTRS);      core(P+D6) = core(P+D6) \ H_TIED; /* Heap note is now tied to */      P = core(P);    end; /* End of chord loop */  return (BLKS);end STACK_CHORD;EDIT_SCAN_1:procedure (PP,LEVEL);  dcl PP        pointer,      LEVEL     fixed,      DATA8     fixed,      DATA16    fixed,      (J,K,T)   fixed,      VOX       fixed,      TSPLIT    fixed,      VOX_MATCH boolean;/*error_case do;  pstring('EditScan 1: LEVEL ');pnum(LEVEL,0);crlf;end;*/  TSPLIT = nullint;  do while GET_NEXT_RECORD (LEVEL,BUFF,false);    T         = shr(BUFF(0),8);    DATA8     = BUFF(0) & LBYTE;    DATA16    = BUFF(1);    VOX       = shr(DATA8,7);    VOX_MATCH = (VOX = VOICE);    if MASTER_RECORD then VOX_MATCH = true;    if T < "30" then do case T; /* 24 one word data records */      ;   /* 000 reserved */      do; /* 001 Clef change */        if (DATA8 & INVISIBLE#) = 0 then core(PP+D6) = core(PP+D6) \ B_CLEF;        NEW_CLEF = DATA8;        if (NEW_CLEF & RESTORE#) ~= 0 then NEW_CLEF = NEW_CLEF & MASK6;      end;      do; /* 002 Key change */        J = SET_KEY(DATA8,true);        if (DATA8 & NO_CANCEL#) ~= 0  then K = abs(J);        else if J * KEY < 0           then K = abs(J) + abs(KEY);        else if (KEY > 0 & KEY > J) |                (KEY < 0 & KEY < J)   then K = abs(KEY);                                      else K = abs(J);        if K ~= 0 then K = shl(K+1,12);        if (core(PP+D3) & FRTH4) ilt K        then core(PP+D3) = (core(PP+D3) & ~FRTH4) \ K;        NEW_KEY   = J;        END_BLOCK = true;      end;      SPLIT = EXPAND(DATA8,8); /* 003 Split note change (range -12 to 72) */      do; /* 004 Transpose change */        TRANSPOSE(VOX) = TRANSPOSE(VOX) + EXPAND(DATA8,7);        if MASTER_RECORD then TRANSPOSE(1) = TRANSPOSE(0);      end;      ; /* 005 Resolution change */      PBITS = (PBITS & UBYTE) \ DATA8; /* 006 Format change */      if VOX_MATCH then call pbyte(ACC_CHANGE_LIST,DATA8 & MASK4,shr(DATA8,4) & MASK3); /* 007 Accidental change */      ;;;;;      if VOX_MATCH then call pbyte(ACC_CHANGE_LIST,DATA8 & MASK4,ENHARMONIC#\(shr(DATA8,4) & MASK3)); /* 015 Enharmonic change */      ;      TSPLIT = EXPAND(DATA8,8); /* 017 Transposed split note change (range -12 to 72) */    end;    else if T < "70" then do case (T - "30");      ;;      if VOX_MATCH then BREAK_NOTE = true;      if VOX_MATCH then BREAK_NOTE = false;    end;    else if T = "110" then do; /* 110 Set voicing mask */      if DATA8 then VALID_VOX_MASK = B_MASK#;               else VALID_VOX_MASK = C_MASK#;      VOX_MASK = DATA16;    end;/*    else if T < "140" then do case (T & MASK5); * 32 two word records *    end;    else if T < 127 then do case (T & MASK5); * 31 multi word records *    end;*/    else if T = 127 & VOX_MATCH then do; /* 1 sublist record */      ED_NEW = shr(DATA16,8);      ED_OLD = DATA16 & LBYTE;    end;  end;  if TSPLIT ~= nullint then SPLIT = TSPLIT - TRANSPOSE(0);end EDIT_SCAN_1;EDIT_SCAN_2:procedure (PP,LEVEL) public;  dcl PP        pointer,      LEVEL     fixed,      DATA8     fixed,      DATA16    fixed,      (J,K,T)   fixed,      VOX       fixed,      VOX_MATCH boolean;  STEM_DIR           = 0; /* This isn't really in the right place */  STEM_LENGTH        = nullint;  REST_OFFSET(VOICE) = nullint;  FORCE_ACCD         = false;/*error_case do;  pstring('EditScan 2: LEVEL ');pnum(LEVEL,0);crlf;end;*/  do while GET_NEXT_RECORD (LEVEL,BUFF,false);    T         = shr(BUFF(0),8);    DATA8     = BUFF(0) & LBYTE;    DATA16    = BUFF(1);    VOX       = shr(DATA8,7);    VOX_MATCH = (VOX = VOICE);    if MASTER_RECORD then VOX_MATCH = true;    if T < "30" then do case T; /* 24 one word data records */      ;;;;;      do; /* 005 Resolution change */        RESOLUTION(VOX) = DATA8 & MASK7;        if RESOLUTION(VOX) > EDIT_RESOLUTION then RESOLUTION(VOX) = EDIT_RESOLUTION;        if MASTER_RECORD then RESOLUTION(1) = RESOLUTION(0);      end;      ;;      if VOX_MATCH then do; /* 010 Set stem direction */        if DATA8 then STEM_DIR = B_SET \ B_DIR;                 else STEM_DIR = B_SET;      end;      do; /* 011 Track change */        NEW_TRACK(VOX) = DATA8 & MASK7;        if MASTER_RECORD then NEW_TRACK(1) = 0;      end;      NOTE_SPACE = DATA8 * 4; /* 012 Note Spacing change */      if VOX_MATCH then STEM_LENGTH = (DATA8 & MASK7) * 3; /* 013 Set stem length */      REST_OFFSET(VOX) = EXPAND(DATA8,7) * 3; /* 014 Rest positioning */      ;      HEAD_TYPE(VOX) = (DATA8 & MASK7); /* 016 Head type change */      ;;;      MEAS_LINE = DATA8;                /* 022 Measures/line change */    end;    else if T < "70" then do case (T - "30");      if VOX_MATCH then BEAM_FLAGS = B_BREAK;      if VOX_MATCH then BEAM_FLAGS = BEAM_FLAGS \ B_MEND;      ;;      do; PLOTBITS = PLOTBITS \  P_POFF; BEAM_FLAGS = B_BREAK; end; /* Plot off */      do; PLOTBITS = PLOTBITS & ~P_POFF; BEAM_FLAGS = B_BREAK; end; /* Plot on */      PLOTBITS = PLOTBITS \  P_BOFF; /* Bar off */      PLOTBITS = PLOTBITS & ~P_BOFF; /* Bar on */      do; core(PP+D6) = core(PP+D6) \ B_OREP; END_BLOCK = true; HOLD_OREP = true; end;      do; core(PP+D6) = core(PP+D6) \ B_CREP; END_BLOCK = true; end;      do; core(PP+D6) = core(PP+D6) \ B_DBAR; END_BLOCK = true; HOLD_DBAR = true; end;      END_BLOCK = true;      if VOX_MATCH then BEAM_FLAGS = BEAM_FLAGS \ B_PBRK;      if POS_HEAD ~= null then core(POS_TAIL+D6) = core(POS_TAIL+D6) \ B_EOL; /* 045 End of line */      END_OF_PAGE = true;    /* 046 End of page */      if VOX = 1 then PLOTBITS = PLOTBITS \ P_BMOFF1;  /* 047 Beams off */                 else PLOTBITS = PLOTBITS \ P_BMOFF0;      if VOX = 1 then PLOTBITS = PLOTBITS & ~P_BMOFF1; /* 050 Beams on  */                 else PLOTBITS = PLOTBITS & ~P_BMOFF0;      if VOX = 1 then PLOTBITS = PLOTBITS \ P_ROFF1;   /* 051 Rests off */                 else PLOTBITS = PLOTBITS \ P_ROFF0;      if VOX = 1 then PLOTBITS = PLOTBITS & ~P_ROFF1;  /* 052 Rests on  */                 else PLOTBITS = PLOTBITS & ~P_ROFF0;      PLOTBITS = PLOTBITS \  P_MNOFF;                  /* 053 Meas # off */      PLOTBITS = PLOTBITS & ~P_MNOFF;                  /* 054 Meas # on */      ;;;;      FORCE_ACCD = true;                               /* 061 Force redundant accidental */      do; core(PP+D6) = core(PP+D6) \ B_EBAR; END_BLOCK = true; end; /* 062 End of piece bar */    end;    else if T < "140" then do case (T & MASK5); /* 32 two word records */      ;;;;;;;;      ;;;;;;;;      do; /* 120 Time signature change */        BEAT_MEAS   = shr(DATA16,8);        BEAT_NOTE   = DATA16 & LBYTE;        FORMAT      = (FORMAT & ~(F_COMT \ F_CUTT)) \ shl(DATA8&MASK6,8);        END_BLOCK   = true;        if (DATA8 & INVISIBLE#) = 0 then do;          HOLD_TIME   = true;          core(PP+D6) = core(PP+D6) \ B_TIME;        end;      end;      CLICK_NOTE = DATA16; /* 121 Click note change */      do; MEASURE_VALUE = DATA16; CADENZA = DATA8 & MASK1; END_BLOCK = true; end; /* 122 Measure multiplier change */      if core(PP+D4) = 0 then core(PP+D4) = DATA16; /* 123 Block Spacing */      if core(PP+D4) = 0 then core(PP+D4) = DATA16; /* 124 Part specific Block Spacing */      call PLOT_RECORD (BUFF,NULL,0); /* 125 Measure number format (use PlotRecord cause it does what we need) */    end;/*    else if T < 127 then do case (T & MASK5); * 31 multi word records *    end;    else if T = 127 then do; * 1 sublist record *    end;*/  end;end EDIT_SCAN_2;BUILD_POS_SEG:procedure (POSN_PTRS,BLKS,BASE,TICS);  dcl POSN_PTRS pointer array,      BLKS      fixed,      BASE      fixed array,      TICS      fixed,      T(1)      fixed,      I         fixed,      P         pointer;  call CLEAR_REC;  do I = 0 to BLKS-1;    P           = ALLOCATE;    T(1)        = BASE(1);    T(0)        = BASE(0);    call ADD32 (T,SIEVE(TICS,BLKS,I));    core(P+D2X) = T(1);    core(P+D2)  = T(0);    if I = 0 then POSN_PTRS(HEAD#) = P;    else do;      core(P+REV)            = POSN_PTRS(TAIL#);      core(POSN_PTRS(TAIL#)) = P;    end;    POSN_PTRS(TAIL#) = P;  end;end BUILD_POS_SEG;SCAN_SEQ:procedure (SCAN_PTRS,END_TIME,NPSN,LEVEL) returns (fixed);  dcl SCAN_PTRS    pointer array,      END_TIME     fixed array,      NPSN         fixed,      LEVEL        fixed,      START(1)     fixed,      HI_THRESH(1) fixed,      TH(1)        fixed,      DIV_CNT      fixed,      MAX_CNT      fixed,      COUNT        fixed,      (DT,I)       fixed;/*error_case do;  pstring('    ScanSeq here: SCAN_PTRS, NPSN,LEVEL,RACK ');  onum(SCAN_PTRS(HEAD#),10);onum(SCAN_PTRS(TAIL#),10);  pnum(NPSN,6);pnum(LEVEL,4);onum(RACK,10);crlf;end;*/  COUNT      = 1;  BREAK_NOTE = false;  MAX_CNT    = WHOLE_SIZE;  if LEVEL = 0 then do;    DIV_CNT = NPSN mod MEAS_DIV;    if DIV_CNT = 0 \ (PBITS & P_JAZZ) ~= 0 then MAX_CNT = NOTE_BLOCKS;    else if (PBITS & P_CLAS) ~= 0 then do while DIV_CNT mod MAX_CNT ~= 0;      MAX_CNT = MAX_CNT / 2;    end;    else MAX_CNT = MEAS_DIV - DIV_CNT;  end;/*  if NPSN = 0 & OLD_HEAD = null then MAX_CNT = NOTE_BLOCKS; ***** */  do forever; /* Loop over position list by resolution *//*error_case do;  pstring('      In ScanSeq loop: COUNT,MAX_CNT ');  pnum(COUNT,6);pnum(MAX_CNT,6);crlf;end;*/    do I = 1 to 8; ACC_CHANGE_LIST(I) = 0; end; /* Clear accidental change list so it can be set each pos by EDIT_SCAN */    VALID_VOX_MASK = NOMASK#;    ED_NEW         = 0;    ED_OLD         = 0;    if COUNT = MAX_CNT then BREAK_NOTE = true;    if SCAN_PTRS(HEAD#) = null then return (COUNT);    call EDIT_SCAN_1 (SCAN_PTRS(HEAD#),LEVEL+3);    if ED_OLD > 0 then return (COUNT);    START(1) = core(SCAN_PTRS(HEAD#)+D2X);    START(0) = core(SCAN_PTRS(HEAD#)+D2);/*error_case do;  pstring('      After EditScan: START ');  pnum(START(1),0);pnum(START(0),6);crlf;end;*/    do I = 1 to RES_MULT;      if SCAN_PTRS(HEAD#) = SCAN_PTRS(TAIL#) then do;        SCAN_PTRS(HEAD#) = null;        I = RES_MULT; /* This takes care of uneven note res blocks / meas or tup */      end;      else do;        SCAN_PTRS(HEAD#) = core(SCAN_PTRS(HEAD#));        if I < RES_MULT then call EDIT_SCAN_1 (SCAN_PTRS(HEAD#),LEVEL+3);      end;    end;    if SCAN_PTRS(HEAD#) ~= null then do;      TH(1) = core(SCAN_PTRS(HEAD#)+D2X);      TH(0) = core(SCAN_PTRS(HEAD#)+D2);    end;    else do;      TH(1) = END_TIME(1);      TH(0) = END_TIME(0);    end;/* WAS:    if TH(1) > START(1) then TH(0) = TH(0) + MAX_INT#;*/    DT = TH(0) - START(0);    HI_THRESH(1) = START(1); /* Set HiThresh and LoThresh */    HI_THRESH(0) = START(0);    call ADD32 (HI_THRESH,DT/2);    if SET_LO then do;      LO_THRESH(1) = START(1);      LO_THRESH(0) = START(0);      call SUB32 (LO_THRESH,DT/2);      SET_LO = false;    end;/*error_case do;  pstring('      After Time set: DT,LoTh,HiTh ');  pnum(DT,8);pnum(LO_THRESH(0),6);pnum(HI_THRESH(0),8);crlf;end;*/    if VOICE = 1 & ONE_TRACK then call VOICE_LOAD (LO_THRESH,HI_THRESH);    else do;      call SEQ_LOAD (LO_THRESH,HI_THRESH);/*error_case do;  pstring('      After SeqLoad: NewHead,RACK ');  onum(NEW_HEAD,10);onum(RACK,10); crlf; I = rchar;  examen (NEW_HEAD,HEAP#,'NewList Just loaded');end;*/      if NEW_HEAD ~= null then call VOICE_CHORD;/*error_case do;  pstring('      After VoiceChord: NewHead,RACK ');  onum(NEW_HEAD,10);onum(RACK,10); crlf; I = rchar;  examen (NEW_HEAD,HEAP#,'NewList Just voiced');end;*/    end;    CLEF = NEW_CLEF; /* This may not be in the right place - there are two of these */    TABLATURE = false; if (CLEF & MASK6) = TABLATURE# then TABLATURE = true;    if KEY ~= NEW_KEY then do;      KEY = NEW_KEY;      if KEY < 0 then PBITS = (PBITS \  P_FLAT);                 else PBITS = (PBITS & ~P_FLAT);    end;    if NEW_HEAD ~= null then do;      TH(1) = HI_THRESH(1);      TH(0) = HI_THRESH(0);    end;    else do;      TH(1) = START(1);      TH(0) = START(0);    end;    LO_THRESH(1) = HI_THRESH(1);    LO_THRESH(0) = HI_THRESH(0);    if SCAN_CHORD (TH) \ BREAK_NOTE \ NEW_HEAD ~= null then return (COUNT);    COUNT = COUNT + 1;  end;end SCAN_SEQ;BUILD_LIST:procedure (POSN_PTRS,NOTE_PTRS,END_TIME,LEVEL) recursive;  dcl POSN_PTRS    pointer array,      NOTE_PTRS    pointer array,      END_TIME     fixed array,      LEVEL        fixed,      SCAN_PTRS(1) pointer,      PPT(1)       pointer,      NPT(1)       pointer,      CPT(2)       pointer,      ST(1)        fixed,      FN(1)        fixed,      COUNT        fixed,      BLKS         fixed,      PPSN         fixed,      NEW          fixed,      OLD          fixed,      ADV          fixed,      NCLEF        fixed,      NKEY         fixed,      FWD_TUP_LEV  fixed,      REV_TUP_LEV  fixed,      H_PPSN       fixed,      (I,J)        fixed,      (H_PP,L_PP)  pointer,      (PP,P,Q)     pointer,      FROND_FOUND  boolean,      CLEAN_TIES   boolean,      WHOLE        boolean,      FIRST        boolean,      FLAG         boolean,      ED_NEW       fixed external,      ED_OLD       fixed external,      NEW_CLEF     fixed external,      NEW_KEY      fixed external,      RES_MULT     fixed external,      BEAM_DIV     fixed external,      BEAM_FLAGS   fixed external,      NEW_HEAD     pointer external,      OLD_HEAD     pointer external;  /* This should be in a separate procedure */  P = EDIT_STAK_BASE+(LEVEL+3)*6; Q = EDIT_STAK_BASE+LEVEL*6;  do I = 0 to 5; /* Push a level of edit pointers */    core(P) = core(Q); P = P + 1; Q = Q + 1;  end;/*error_case do;  pstring('*************************** LEVEL = '); pnum(LEVEL,0); crlf;  do I = 0 to 5;    print_edit_stack (I);  end;  crlf;end;*/  PP               = POSN_PTRS(HEAD#);  SCAN_PTRS(HEAD#) = POSN_PTRS(HEAD#);  SCAN_PTRS(TAIL#) = POSN_PTRS(TAIL#);  if LEVEL < 2 then BEAM_FLAGS = B_BREAK;  CLEAN_TIES       = true;  FIRST            = true;  FLAG             = true;  PPSN             = 0;  COUNT            = 0;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead at top of BuildList');*/  do while FLAG;/*error_case do;  pstring('  In loop COUNT,PPSN ');  pnum(COUNT,10);pnum(PPSN,10);crlf;  i = rchar;  examen (OLD_HEAD,HEAP#,'OldList before SeqScan');end;*/    NEW_CLEF = CLEF;    NEW_KEY  = KEY;    NEW_HEAD = null;    COUNT    = COUNT + SCAN_SEQ (SCAN_PTRS,END_TIME,PPSN/RES_MULT,LEVEL);    NEW      = ED_NEW;    OLD      = ED_OLD;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in BuildList after ScanSeq');*//*error_case do;  pstring('  After ScanSeq COUNT,FIRST ');  pnum(COUNT,10);pnum(FIRST,10);crlf;  I = rchar;  examen (OLD_HEAD,HEAP#,'OldList after SeqScan');end;*/    WHOLE = false;    if PPSN = 0 & SCAN_PTRS(HEAD#) = null & NEW_HEAD = null & LEVEL = 0 &       (core(SCAN_PTRS(TAIL#)+D6) & B_SOT) = 0 /* No whole rest if partial measure */    then WHOLE = true;    if FIRST & (SCAN_PTRS(HEAD#) ~= null \ NEW_HEAD ~= null) then COUNT = COUNT - 1;    FIRST = false;/*error_case do;  pstring('  After Set COUNT,FIRST,WHOLE ');  pnum(COUNT,8);pnum(FIRST,8);pnum(WHOLE,8);crlf;end;*/    do while COUNT > 0;      call EDIT_SCAN_2 (PP,LEVEL);/*error_case do;  pstring('    In COUNT loop COUNT,PPSN,FLAG,LEVEL,OldHead ');  pnum(COUNT,6);pnum(PPSN,6);pnum(FLAG,4);pnum(LEVEL,4);onum(OLD_HEAD,10);crlf;end;*/      if OLD_HEAD ~= null then do;        BLKS       = STACK_CHORD (NOTE_PTRS,PPSN,COUNT,false,false,LEVEL);        BEAM_FLAGS = 0; /* This should be in StackChord */      end;      else BLKS = STACK_CHORD (NOTE_PTRS,PPSN,COUNT,true,WHOLE,LEVEL);/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in BuildList after StackChord');*/      do I = 1 to RES_MULT*BLKS;        PPSN = PPSN + 1;        if LEVEL = 0 & PPSN mod BEAM_DIV = 0 then BEAM_FLAGS = B_BREAK;        if PP = POSN_PTRS(TAIL#) then do;          FLAG = false;          PP   = null;          I    = RES_MULT*BLKS; /* This takes care of uneven note res blocks / meas or tup */        end;        else do;          PP = core(PP);          if I < RES_MULT*BLKS then call EDIT_SCAN_2 (PP,LEVEL);        end;      end;/*error_case do;  pstring('    End of COUNT loop COUNT,BLKS,PPSN,FLAG ');  pnum(COUNT,6);pnum(BLKS,6);pnum(PPSN,6);pnum(FLAG,4);crlf;end;*/      COUNT = COUNT - BLKS;    end;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in BuildList before Purge');*/    call PURGE (CLEAN_TIES);    CLEAN_TIES = false;/*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in BuildList before Merge');*/    call MERGE;    if OLD > 0 then do; /* This is not too optimized yet (but real readable) *//*error_case do;  pstring('    Tup found: OLD,NEW,PPSN,FLAG ');  pnum(OLD,6);pnum(NEW,6);pnum(PPSN,6);pnum(FLAG,4);crlf;end;*/      ST(1) = core(PP+D2X);; /* Get start time of tuplet */      ST(0) = core(PP+D2);      H_PPSN = PPSN;      H_PP   = PP;      I      = 1;      do while I <= OLD; /* Advance over OLD */        PPSN = PPSN + 1;        L_PP = PP;        /* Who knows what will happen to editing in here? */        SCAN_PTRS(HEAD#) = core(SCAN_PTRS(HEAD#));        if PP = POSN_PTRS(TAIL#) then do;          FLAG = false; OLD = I; /* Tup over bar fixed here */        end;        call EDIT_SCAN_2 (PP,LEVEL);        if FLAG then PP = core(PP);                else PP = null;        if I < OLD then call EDIT_SCAN_1 (SCAN_PTRS(HEAD#),LEVEL+3);        I = I + 1;      end;      COUNT      = -1;      CLEAN_TIES = true;      NCLEF      = NEW_CLEF;      NKEY       = NEW_KEY;/*error_case do;  pstringr('  After looping over OLD');  do I = 0 to 5;    print_edit_stack (I);  end;  crlf;end;*/      if PP = null then do;        FN(1) = END_TIME(1);        FN(0) = END_TIME(0);      end;      else do;        FN(1) = core(PP+D2X);        FN(0) = core(PP+D2);      end;      FWD_TUP_LEV = 1;      REV_TUP_LEV = 1;      I           = shl(NEW,8) \ OLD;      Q           = core(H_PP+GRP);      FROND_FOUND = false;      do while Q ~= null;        H_PP = Q;        if core(Q+D5) = I & (shr(core(Q+D6),4) & MASK4) = LEVEL then do;          Q = null; FROND_FOUND = true;        end;        else do;          Q           = core(Q+GRP);          FWD_TUP_LEV = FWD_TUP_LEV + 1;        end;      end;      if ~FROND_FOUND then do;/* WAS:        if FN(1) > ST(1) then J = FN(0) + MAX_INT# - ST(0);                         else J = FN(0) - ST(0);        call BUILD_POS_SEG (PPT,NEW,ST,J);*/        call BUILD_POS_SEG (PPT,NEW,ST,FN(0)-ST(0));        core(PPT(HEAD#)+D5) = I;        core(PPT(TAIL#)+D5) = I;        core(PPT(HEAD#)+D6) = core(PPT(HEAD#)+D6) \ shl(LEVEL,4);        core(PPT(HEAD#)+D6) = core(PPT(HEAD#)+D6) \ B_SOT; /* Mark start of frond */        core(PPT(TAIL#)+D6) = (core(L_PP+D6) & MASK13) \ B_EOL; /* Mark end of frond *//*error_case do;  I = rchar; examen (PPT(HEAD#),POSN#,'Tup Pos Seg just built');end;*/        core(H_PP+GRP) = PPT(HEAD#);        do while core(L_PP+GRP) ~= null;          L_PP = core(L_PP+GRP); REV_TUP_LEV = REV_TUP_LEV + 1;        end;        core(L_PP+GRP) = PPT(TAIL#);      end;      else do;        PPT(HEAD#)  = H_PP;        L_PP        = core(L_PP+GRP);        do while (core(H_PP+D6) & B_EOL) = 0; H_PP = core(H_PP); end;        do while L_PP ~= H_PP;          L_PP = core(L_PP+GRP); REV_TUP_LEV = REV_TUP_LEV + 1;        end;        PPT(TAIL#) = L_PP;      end;      NPT(HEAD#) = null; /* Necessary? */      NPT(TAIL#) = null;      call BUILD_LIST (PPT,NPT,FN,LEVEL+1);      core(NPT(TAIL#)+D6) = core(NPT(TAIL#)+D6) \ B_EOT; /* Mark end of sublist *//*error_case do;  I = rchar; examen (NPT(HEAD#),NOTE#,'Tup note list just built');end;*/      Q = null;      if VOICE = 0 \ LEVEL > 0 then do;        CPT(HEAD#) = NOTE_PTRS(TAIL#);        CPT(CURC#) = null;        CPT(TAIL#) = null;        ADV        = OLD;      end;      else do;        CPT(HEAD#) = null;        CPT(CURC#) = NOTE_PTRS(HEAD#);        ADV = POSITION_CHORD (CPT,H_PPSN,OLD);        if (core(CPT(CURC#)+D6) & B_TUP) ~= 0 then Q = CPT(CURC#);      end;      if Q = null then do;        call CLEAR_REC;        REC(D6) = B_TUP;        Q       = INSERT_CHORD (NOTE_PTRS,CPT);      end;            core(Q+D1+VOICE) = NPT(HEAD#);      core(Q+D3+VOICE) = shl(REV_TUP_LEV,8) \ FWD_TUP_LEV;      core(Q+D5+VOICE) = shl(OLD,8);      core(Q+D5)       = (core(Q+D5) & UBYTE) \ ADV;      core(Q+D6)       = core(Q+D6) \ B_TUP;      if LEVEL = 0 then BEAM_FLAGS = B_BREAK;      CLEF = NCLEF; /* This may not be in the right place - there are two of these */      TABLATURE = false; if (CLEF & MASK6) = TABLATURE# then TABLATURE = true;      if KEY ~= NKEY then do;        KEY = NKEY;        if KEY < 0 then PBITS = (PBITS \  P_FLAT);                   else PBITS = (PBITS & ~P_FLAT);      end;    end;/*estringr('-------------------');*//*error_case do;  pstring('    After Tup block: COUNT,PPSN,FLAG ');  pnum(COUNT,6);pnum(PPSN,6);pnum(FLAG,4);crlf;end;error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in BuildList at bottom of loop');*/  end; /* End of note resolution loop *//*error_case if MEASURE_NUMBER = 31 & STAFF = 4 thenexamen (HEAP_HEAD,HEAP#,'HeapHead at bottom of BuildList');error_case do;  pstring('*************************** LEVEL = ');pnum(LEVEL,0);crlf;  I = rchar;end;*/end BUILD_LIST;STACK_MEASURE:procedure (POSN_PTRS,NOTE_PTRS);  dcl POSN_PTRS pointer array,      NOTE_PTRS pointer array,      P         pointer,      I         fixed;  do while ~term_idle & peek ~= asc.refresh; /* Handle user break (space) */    I = rchar; /* Get rid of random typed ahead chars */    if I = sp then do;      if RUNNING & MAIN_MODE >= PRINT# then call CLEAR_LASER_PRINTER;      REPLOT_MEASURE = 0;      call RE_START; /* Break if space is pressed */    end;  end;  if #STATUS = UNINIT# then SET_LO = true;  else do;    SET_LO = false;    LO_THRESH(1) = LAST_START(1);    LO_THRESH(0) = LAST_START(0);  end;  ACC_LIST(0) = 0; /* Clear accidental list each measure */  SET_ACC     = true;  OLD_HEAD    = null;/*error_case if MEASURE_NUMBER > 30 thenexamen (HEAP_HEAD,HEAP#,'Heap in StackMeas before HeapLoad');*//*estringr('    In StackMeasure - Before HeapLoad');*/  call HEAP_LOAD (false);  ACC_LIST(0) = 0; /* Clear accidental list each measure HERE SO TIED DON't CARRY *//*error_case if MEASURE_NUMBER > 30 thenexamen (HEAP_HEAD,HEAP#,'Heap in StackMeas after HeapLoad');*/  RES_MULT    = EDIT_RESOLUTION / RESOLUTION(VOICE);  NOTE_BLOCKS = POS_BLOCKS / RES_MULT;  WHOLE_SIZE  = RESOLUTION(VOICE);  if (PBITS & (P_JAZZ \ P_CLAS)) ~= 0  then MEAS_DIV = NOTE_BLOCKS;  else MEAS_DIV = WHOLE_SIZE / BEAT_NOTE;  if (PBITS & P_JAZZ) = 0 & BEAT_MEAS mod 3 = 0 & BEAT_NOTE > 4  then MEAS_DIV = (WHOLE_SIZE * 3) / BEAT_NOTE;  if BEAT_MEAS mod 3 = 0 & BEAT_NOTE > 4  then BEAM_DIV = (WHOLE_SIZE * 3 * RES_MULT) / 8;  else BEAM_DIV = (WHOLE_SIZE     * RES_MULT) / 4;/*estringr('    In StackMeasure - Before LoadEditStack');*/  call LOAD_EDIT_STACK;  call BUILD_LIST (POSN_PTRS,NOTE_PTRS,TIME,0);  call DUMP_EDIT_STACK;/*error_case if MEASURE_NUMBER > 30 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in StackMeas after BuildList');*/  if OLD_HEAD ~= null then do; /* Stick remains of OldChord on heap */    P = OLD_HEAD;    do while core(P) ~= null; P = core(P); end;    core(P) = HEAP_HEAD; HEAP_HEAD = OLD_HEAD;  end;/*error_case if MEASURE_NUMBER > 30 thenexamen (HEAP_HEAD,HEAP#,'HeapHead in StackMeas after Old append');*/end STACK_MEASURE;BUILD_POS_LIST:procedure (POSN_PTRS);  dcl POSN_PTRS pointer array,      (H,T)     pointer,      TICS      fixed,      ST(1)     fixed,      (RA,CA)   fixed,      (B,I,L)   fixed;  /* TIME gets advanced here */  LAST_START(1) = MEAS_START(1);  LAST_START(0) = MEAS_START(0);  MEAS_START(1) = TIME(1);  MEAS_START(0) = TIME(0);  B = 0; CA = 1;  RA = (EDIT_RESOLUTION * shr(CLICK_NOTE,8)) / (CLICK_NOTE & LBYTE);  if RA = 0 then do;    CA = ((CLICK_NOTE & LBYTE) / EDIT_RESOLUTION) / shr(CLICK_NOTE,8);    if CA = 0 then CA = 1; /* Click/Reso incompatable */    RA = 1;   end;  call CLEAR_REC;  do while B < POS_BLOCKS;    /* This bit is confusingly clever in the way TEMPO works */    TICS = 0;    I    = CA;    if CLICK_TRACK ~= 0 then do;      call LOAD_SEQ_RECORD (CLICK_REC_POS#,0);      do while #STATUS ~= OUT# & I > 0;        ST(1) = #NMSB;        ST(0) = #NLSB;        do while ST(1) = #NMSB & ST(0) = #NLSB & #ANYF;          call ADVANCE.TO.NEXT.EVENT;        end;        if #ANYF then do;          TEMPO = #NLSB - #LLSB;          TICS  = TICS + TEMPO;          I     = I - 1;        end;        else #STATUS = OUT#;      end;      call DUMP_SEQ_RECORD (CLICK_REC_POS#,0);    end;    TICS = TICS + I * TEMPO;    call BUILD_POS_SEG (POSN_PTRS,RA,TIME,TICS);    if B = 0 then H = POSN_PTRS(HEAD#);    else do;      core(T)                    = POSN_PTRS(HEAD#);      core(POSN_PTRS(HEAD#)+REV) = T;    end;    T = POSN_PTRS(TAIL#);    B = B + RA;    call ADD32 (TIME,TICS);  end;  core(T+D6) = core(T+D6) \ B_BAR;  if PARTL_MEAS then core(T+D6) = core(T+D6) \ B_SOT;/*  if HOLD_DBAR  then core(H+D3) = core(H+D3) \ B_HDBR; REMOVED BY POPULAR DEMAND */  if HOLD_OREP  then core(H+D3) = core(H+D3) \ B_HREP;  if HOLD_TIME  then core(H+D3) = core(H+D3) \ B_HTIM;  HOLD_DBAR        = false;  HOLD_OREP        = false;  HOLD_TIME        = false;  POSN_PTRS(HEAD#) = H;  POSN_PTRS(TAIL#) = T;end BUILD_POS_LIST;/* Driving routines */GET_SYSTEM:procedure (LINE_LEN) public swap1; /* This drives pass 1 (the list builder) */  dcl LINE_LEN       fixed,      LEN            fixed,      BLOCK_REST_CNT fixed,      EDIT_ADVANCE   fixed,      MEAS_THIS_LINE fixed,      (I,J,K,MK)     fixed,      P              pointer,      POSN_PTRS(1)   pointer,      NOTE_PTRS(1)   pointer,      SKIP           boolean;  call LOAD_MAIN_VECTOR (MAIN_BASE);/*error_case do;  transparent_mode;  pstring('GetLine here: LineLen,MeasLine,PosHead,PosLast,PosTail ');  pnum(LINE_LEN,0);pnum(MEAS_LINE,7);onum(POS_HEAD,7);onum(POS_LAST,7);onum(POS_TAIL,7);crlf;end;*/  END_OF_LINE    = false;  MEAS_THIS_LINE = MEAS_LINE;  if POS_HEAD ~= null then LEN = GET_LIST_LEN (POS_HEAD,POS_TAIL);  else do; /* This will mostly happen first time through */    MEAS_ON_LINE = 0;    SKIP       = false;    LEN        = 0;  end;/*error_case do;  pstring('After PosHead handle: Len,MonL,Skip ');  pnum(LEN,0);pnum(MEAS_ONLINE,5);pnum(SKIP,5);crlf;end;*/  do while LEN <= LINE_LEN & ~DONE & ~END_OF_LINE;/*error_case do;  pstring('---------------------------------');  pstring('  Top of loop: Len,M/L,Skip ');  pnum(LEN,0);pnum(MEAS_LINE,5);pnum(SKIP,5);crlf;  call rchar;end;*/    /* Build position list */    PARTL_MEAS = false;    NOTES      = false;    END_BLOCK  = false;    if MEASURE_VALUE ~= 0 then do;      POS_BLOCKS    = (EDIT_RESOLUTION * shr(MEASURE_VALUE,8)) / (MEASURE_VALUE & LBYTE);      NOTES         = true;      MEASURE_VALUE = 0;      if ~CADENZA then PARTL_MEAS = true;    end;    else POS_BLOCKS = (EDIT_RESOLUTION * BEAT_MEAS) / BEAT_NOTE;    call BUILD_POS_LIST (POSN_PTRS);    /* Build a measure of note list for each staff */    MK = 0; /* Keeps maximum of abs(key) */    do STAFF = 0 to STAVES;      /* Build a measure of voice 0 */      VOICE = 0;      PART  = DISPLAY(STAFF);      call LOAD_MAIN_VECTOR (MAIN_BASE);      call LOAD_PART_VECTOR (PART_BASE,PART);      call LOAD_SEQ_RECORD (PART,VOICE);      if MK < abs(KEY) then MK = abs(KEY);      NEW_TRACK(1) = TRACK(1);      NEW_TRACK(0) = TRACK(0); /* GET RID OF THIS MESS SOON *//*error_case do;  pstring('  Before Build: M/L ');  pnum(MEAS_LINE,5);crlf;  call rchar;end;*/      VOX_HEAD         = null;      VOX_TAIL         = addr(VOX_HEAD);      NOTE_PTRS(HEAD#) = null; /* Necessary? */      NOTE_PTRS(TAIL#) = null;      call STACK_MEASURE (POSN_PTRS,NOTE_PTRS);      call DUMP_SEQ_RECORD (PART,VOICE);/*error_case do;  pstring('  After Build: M/L ');  pnum(MEAS_LINE,5);crlf;  call rchar;end;error_case do;  examen     (NOTE_PTRS(HEAD#),NOTE#,'Voice0 list just built');  examen     (POSN_PTRS(HEAD#),POSN#,'Voice0 list just built');  examen     (HEAP_HEAD,HEAP#,'Heap after Voice0 list just built');  examen     (VOX_HEAD, HEAP#,'Vox after Voice0 list just built');end;*/      /* Add a measure of voice 1 */      if TWO_VOICE then do;        VOICE = 1;        I = TRANSPOSE(0);        J = HEAD_TYPE(0);        K = PLOTBITS & P_BMOFF0;        call LOAD_MAIN_VECTOR (MAIN_BASE);        call LOAD_PART_VECTOR (PART_BASE,PART);        call LOAD_SEQ_RECORD (PART,VOICE);        call STACK_MEASURE (POSN_PTRS,NOTE_PTRS);        call DUMP_SEQ_RECORD (PART,VOICE);        TRANSPOSE(0) = I;        HEAD_TYPE(0) = J;        PLOTBITS     = PLOTBITS \ K;/*error_case do;  examen     (NOTE_PTRS(HEAD#),NOTE#,'Voice1 just added');  examen     (HEAP_HEAD,HEAP#,'Heap after Voice1 list just built');  examen     (VOX_HEAD, HEAP#,'Vox after Voice1 list just built');end;*/      end;/*error_case examen (NOTE_PTRS(HEAD#),NOTE#,'NoteList before TieDown');*/      call NOTE_TIE_DOWN (NOTE_PTRS(HEAD#),null);/*error_case examen (NOTE_PTRS(HEAD#),NOTE#,'NoteList after TieDown');*/      if ~TABLATURE then do;      VOICE = 0;      call BEAMER (NOTE_PTRS(HEAD#));      call SET_SPACING (POSN_PTRS(HEAD#),NOTE_PTRS(HEAD#),true); /* Set the spacing of the pos list to fit new measure *//*error_case examen (NOTE_PTRS(HEAD#),NOTE#,'NoteList after set_spacing');*/      if TWO_VOICE then do;        VOICE = 1;        call SET_SPACING (POSN_PTRS(HEAD#),NOTE_PTRS(HEAD#),true); /* Set the spacing of the pos list to fit new measure */        call BEAMER (NOTE_PTRS(HEAD#));      end;      end;      LAST(PART)       = TAIL(PART);      core(TAIL(PART)) = NOTE_PTRS(HEAD#);      TAIL(PART)       = NOTE_PTRS(TAIL#);      if TRACK(1) ~= NEW_TRACK(1) then do;        VOICE = 1;        call LOAD_SEQ_RECORD (PART,VOICE);        if NEW_TRACK(1) = 0 \ NEW_TRACK(1) = NEW_TRACK(0)        then #STATUS = OUT#;        else #STATUS = UNINIT#;        call DUMP_SEQ_RECORD (PART,VOICE);        call HEAP_LOAD (true); /* Purge Heap */        TRACK(1) = NEW_TRACK(1);      end;      if TRACK(0) ~= NEW_TRACK(0) then do;        VOICE = 0;        call LOAD_SEQ_RECORD (PART,VOICE);        #STATUS = UNINIT#;        call DUMP_SEQ_RECORD (PART,VOICE);        call HEAP_LOAD (true); /* Purge Heap */        TRACK(0) = NEW_TRACK(0);      end;      /* If both tracks out for this part then mark part done */      call LOAD_SEQ_RECORD (PART,0);      if #STATUS = OUT# then do;        call LOAD_SEQ_RECORD (PART,1);        if #STATUS = OUT# then do;          I           = STAFF / 16;          END_RACK(I) = END_RACK(I) & rot("177776",STAFF & MASK4);        end;      end;      call DUMP_PART_VECTOR (PART_BASE,PART);    end; /* End of staff loop */    call ALIGN_AXIS (POSN_PTRS(HEAD#),0,SKIP & ~NOTES); /* ***** *//*error_case examen (POSN_PTRS(HEAD#),POSN#,'After align axis');*/    if MEASURE_NUMBER = LAST_MEAS \       (LAST_MEAS = 0 &        (END_RACK(0) \ END_RACK(1) \ END_RACK(2) \ END_RACK(3)) = 0 &        HEAP_HEAD = null)    then do;      if MEASURE_NUMBER < START_MEAS     then START_MEAS     = MEASURE_NUMBER;      if MEASURE_NUMBER < REPLOT_MEASURE then REPLOT_MEASURE = MEASURE_NUMBER;      DONE = true;    end;    core(POSN_PTRS(HEAD#)+D6)  = core(POSN_PTRS(HEAD#)+D6) \ shl(MK,5);    if POS_TAIL ~= addr(POS_HEAD) then    core(POSN_PTRS(HEAD#)+REV) = POS_TAIL;    core(POS_TAIL)             = POSN_PTRS(HEAD#);    POS_TAIL                   = POSN_PTRS(TAIL#);    if POS_LAST = null then POS_LAST = POSN_PTRS(HEAD#);    LEN = LEN + GET_LIST_LEN (POSN_PTRS(HEAD#),POSN_PTRS(TAIL#));/*error_case do;  pstring('  New meas added: Len,PosHead,PosLast,PosTail ');  pnum(LEN,0);onum(POS_HEAD,7);onum(POS_LAST,7);onum(POS_TAIL,7);crlf;  pstring('                  PosnHead,PosnTail ');            onum(POSN_PTRS(HEAD#),7);onum(POSN_PTRS(TAIL#),7);crlf;end;*/    if NOTES then SKIP = false;    else do;/*estringr('    No notes'); */      if SKIP \ (DONE & MEASURE_NUMBER > START_MEAS & LAST_MEAS = 0) then do;/*estringr('    About to skip');*/        MEAS_ON_LINE   = MEAS_ON_LINE   - 1;        BLOCK_REST_CNT = BLOCK_REST_CNT + 1;        EDIT_ADVANCE   = EDIT_ADVANCE   + POS_BLOCKS;        do STAFF = 0 to STAVES;          PART = DISPLAY(STAFF);          call FREE_NOTE (core(LAST(PART)),TAIL(PART));          TAIL(PART)          = LAST(PART);          core(TAIL(PART))    = null;          if ~DONE then core(TAIL(PART)+D3) = EDIT_ADVANCE;        end;        if ~SKIP then do; /* i.e. if DONE *//*estringr('      Done');*/          POS_TAIL       = core(POSN_PTRS(HEAD#) + REV);          core(POS_TAIL) = null;          call FREE_POSN (POSN_PTRS(HEAD#),POSN_PTRS(TAIL#));        end;        else do;/*estringr('      Block rest');*/          /* This kludge keeps initial timesig & openrep & dbar from             disappearing when the first measures are a block rest (ick) */          if (core(POS_LAST+D3) & B_HDBR) ~= 0 then          core(POSN_PTRS(HEAD#)+D3) = core(POSN_PTRS(HEAD#)+D3) \ B_HDBR;          if (core(POS_LAST+D3) & B_HREP) ~= 0 then          core(POSN_PTRS(HEAD#)+D3) = core(POSN_PTRS(HEAD#)+D3) \ B_HREP;          if (core(POS_LAST+D3) & B_HTIM) ~= 0 then          core(POSN_PTRS(HEAD#)+D3) = core(POSN_PTRS(HEAD#)+D3) \ B_HTIM;          I = core(POSN_PTRS(HEAD#)+REV); /* Get last block in last meas */          if POS_HEAD = POS_LAST then POS_HEAD = POSN_PTRS(HEAD#);          core(POSN_PTRS(HEAD#)+REV) = core(POS_LAST+REV);          if core(POS_LAST+REV) ~= null          then core(core(POS_LAST+REV)) = POSN_PTRS(HEAD#);          LEN = LEN - GET_LIST_LEN(POS_LAST,I);          call FREE_POSN (POS_LAST,I);          core(POS_TAIL+D2) = EDIT_ADVANCE;          core(POS_TAIL+D5) = BLOCK_REST_CNT;          core(POS_TAIL+D6) = core(POS_TAIL+D6) \ B_REST;        end;      end;      else do;        if (FORMAT & F_BRST) ~= 0 then SKIP = true;        BLOCK_REST_CNT = 1;        EDIT_ADVANCE   = 0;      end;    end;    if END_BLOCK & SKIP then SKIP = false;    POS_LAST = POSN_PTRS(HEAD#);    if ~PARTL_MEAS then do;      MEASURE_NUMBER = MEASURE_NUMBER + 1;      MEAS_ON_LINE   = MEAS_ON_LINE   + 1;/*error_case do;  pstring('  In full measure block: M/L,MEAS_ON_LINE ');  pnum(MEAS_LINE,5);pnum(MEAS_ON_LINE,5);crlf;  call rchar;end;*/      if (MEASURE_NUMBER <= START_MEAS & REPLOT_MEASURE = 0) \          MEASURE_NUMBER <= REPLOT_MEASURE then do;        do STAFF = 0 to STAVES;          PART = DISPLAY(STAFF);          call FREE_NOTE (HEAD(PART),TAIL(PART));          HEAD(PART) = null;          TAIL(PART) = addr(HEAD(PART));          LAST(PART) = TAIL(PART);        end;        call FREE_POSN (POS_HEAD,POS_TAIL);        POS_HEAD = null;        POS_LAST = null;        POS_TAIL = addr(POS_HEAD);        call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);        call COPY_PART_VECTOR (PART_BASE,PLOT_PART_BASE);        LEN          = 0;        MEAS_ON_LINE = 0;        SKIP         = false;        END_OF_LINE  = false;        END_OF_PAGE  = false;      end;      else if MEAS_THIS_LINE > 0 & MEAS_ON_LINE > MEAS_THIS_LINE           then END_OF_LINE = true;    end;    call DUMP_MAIN_VECTOR (MAIN_BASE);/*error_case do;  pstring('  Bottom of loop: Len,M/L,Skip ');  pnum(LEN,0);pnum(MEAS_LINE,5);pnum(SKIP,5);crlf;  call rchar;end;*/  end;  if DONE then do;    core(POS_TAIL+D6) = core(POS_TAIL+D6) \ B_EOP;    core(POS_TAIL+D6) = core(POS_TAIL+D6) \ B_EOL;    if (FORMAT & F_END) ~= 0 then core(POS_TAIL+D4) = core(POS_TAIL+D4) + 5;    P = HEAP_HEAD;    do while P ~= null; /* Clean up trailing ties */      if core(P+D0) ~= null then core(core(P+D0)+D6) = core(core(P+D0)+D6) & ~B_OTIE;      P = core(P);    end;  end;/*error_case examen (POS_HEAD,POSN#,'Pos list before justify');*/  call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);  MEAS_ON_LINE = MEAS_ON_LINE - JUSTIFY_LINE (LINE_LEN);/*error_case examen (POS_HEAD,POSN#,'Pos list after justify');*/  do STAFF = 0 to STAVES;    PART = DISPLAY(STAFF);/*error_case examen (HEAD(PART),NOTE#,'Before beaming');*/    do VOICE = 0 to 1;      call SET_BEAMS;    end;/*error_case examen (HEAD(PART),NOTE#,'After beaming');*/  end;/*error_case do;  pstring('Leaving GetSystem'); call rchar;end;*/end GET_SYSTEM;end LISTRTNS;