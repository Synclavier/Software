/* $title Menu Routines */module MENURTNS;insert ':-xpl:strings';insert 'oslits';insert 'lits';insert 'globdcls';insert 'picsdcls';/* Declare globals for this module */dcl INITIALIZE_TERMINAL procedure external,    MAIN_MODE           fixed external; /* Display, Edit, Hardcopy */dcl NUM_VAL       fixed, /* Holds returned value from GET_NUM */    COMMAND       fixed,    MENU_MODE     fixed; /* static init (MAIN#) */dcl ITEM_LENGTHS  fixed data (16, 1,1,1,1,1, 3,1,2, 6,1,1,1,1, 3,3,2,3, 16),    SCORE_TABLE   fixed data (8, 25,26,27,28,29, 33),    STAFF_TABLE   fixed data (55,65,72, 34, 44,45,46,47),    VOICE_TABLE   fixed data (6,18,31,49,69),    SCORE_TEXT    fixed data ('Part  Instrument      Format Spacing'),    SEQ_FILE_NAME fixed data ('.SQ0DATA');dcl MAIN#         lit '0', /* Main menu */    SCORE#        lit '1', /* Score menu */    PART#         lit '2', /* Part menu */    PAGE#         lit '3', /* Page menu */    KEYPAD#       lit '4', /* Keypad menu */    EXIT#         lit '5'; /* Exit menu system (usually to plot music) */insert 'menufncs';     /* Menu functions */KEYPAD_MENU:procedure swap;  dcl (ROW,COL) fixed,  /* Row, column */      (BLK,PSN) fixed,  /* Block, position */      LFOFF     fixed,  /* static init (0); Library Font Offset (F_MUSIC#,F_USER#,F_AUXIL#) */      COM(2)    fixed,  /* Symbol name array */      MID_TEXT  fixed data ('tqqqqnqqqqnqqqqnqqqqu');  DISPLAY_LIBRARY:procedure;    do case LFOFF;      pstring(' System ');      pstring('  User  ');      pstring('Extended');    end;  end DISPLAY_LIBRARY;  MIDLINE:procedure (PSN);    dcl (PSN,I) fixed; /* Block, position */    do I = PSN to PSN + 3;      wchar(lower.x); /* Draw vertical bar */      call LOOKUP_NAME (byte(location(BANK_BASE+LFOFF*24-1),BLK*8+I),LFOFF,COM); /* Look up the symbol name given the code */      pstring(COM); /* Print the symbol name */    end;    wchar(lower.x);     /* Draw a vertical bar */  end MIDLINE;  REFRESH_KEYPAD:procedure;    dcl (ROW,COL) fixed,        (BLK,I)   fixed;    BLK = 0;    do COL = 15 to 37 by 22;      do ROW = 6 to 16 by 5;        do I = 0 to 7;          pos(ROW+(I/4)*2,COL+(I mod 4)*5);          call LOOKUP_NAME (byte(location(BANK_BASE+LFOFF*24-1),BLK*8+I),LFOFF,COM); /* Look up the symbol name given the code */          pstring(COM);        end;        BLK = BLK + 1;      end;    end;  end REFRESH_KEYPAD;  GET_COM:procedure;   /* Gets a symbol name and always returns a character */    dcl (C,I,J) fixed;    COM(0) = 0; /* Initialize the number of characters */    do forever;      C = rchar; /* Get a character */      if lower.a <= C & C <= lower.z then C = C - lower.a + asc.a; /* If lowercase, capitalize it */      if sp <= C & C < del & COM(0) < 4 then do; /* If an ascii character */        call pbyte (COM,COM(0),C);        COM(0) = COM(0) + 1; wchar(C);  /* Increase the # of characters */      end;      else if C = del & COM(0) > 0 then do;  /* If deleting a character */        COM(0) = COM(0) - 1; wchar(bs); wchar(sp); wchar(bs); /* Decrease the number of characters and delete it */      end;      else if C < sp \ del < C then do; /* If not an ascii character */        if COM(0) > 0 then do;  /* If there are name characters */          do I = COM(0) to 3; call pbyte(COM,I,sp); wchar(sp); end; /* Fill in the rest of the name with spaces */          I = LOOKUP_NUMBER (COM,LFOFF); J = BLK*8 + PSN; /* Look up the symbol code given the name */          if I = nullint then do; /* If the symbol code is not there */            pcmd('Symbol "'); pstring(COM); pstring('" does not exist.');            pos (ROW+1+2*(PSN/4),COL+1+5*(PSN mod 4));            call LOOKUP_NAME (byte(location(BANK_BASE+LFOFF*24-1),J),LFOFF,COM);            pstring(COM);            C = 0;          end;          else call pbyte(location(BANK_BASE+LFOFF*24-1),J,I);  /* Put the symbol code in the symbol bank */        end;        return (C);  /* Return the character */      end;    end;  end GET_COM;  /* $PAGE */  dcl C fixed;  cmdline = 23;  clear_all;  pos( 3,12); pstring(DOUBLE_WIDE); pstring('Keypad Menu');  /* Print the Keypad menu title in double sized characters */  pos(21,14); pstring(DOUBLE_WIDE); call DISPLAY_LIBRARY;  pstring(ALTERNATE_CHARS); BLK = 0;  /* Invoke the special graphics character set */  do COL = 14 to 36 by 22;      /* Draw the keypad menu box */    do ROW = 5 to 15 by 5;      if COL = 14 then pos(ROW+2,COL-2); else pos(ROW+2,COL+22);      pnum(BLK+1,0);            /* Print the block number */      pos(ROW+0,COL); pstring('lqqqqwqqqqwqqqqwqqqqk'); /* Draw the upper half of a block */      pos(ROW+1,COL); call MIDLINE (0);      pos(ROW+2,COL); pstring(MID_TEXT);            /* Draw a horizontal division */      pos(ROW+3,COL); call MIDLINE (4);      pos(ROW+4,COL); pstring('mqqqqvqqqqvqqqqvqqqqj'); /* Draw the lower half of the block */      BLK = BLK + 1;    end;  end;  pstring(NORMAL_CHARS);  /* Restore the standard ascii character set */  if ERR_PTR ~= null then call DISPLAY_ERROR;  ROW = 5; COL = 14; BLK = 0; PSN = 0; C = 0;  do forever;    if C ~= 0 then erase_command; /* If there is a character, erase the command line */    pos (ROW+1+2*(PSN/4),COL+1+5*(PSN mod 4));/*    call CLEAN_SEQUENCE (true); */    C = GET_COM; /* Get the symbol name */    if      C = kp.enter then return (MAIN#); /* Activate the main menu */    else if C = kp.1     then return (SCORE#);/* Activate the score menu */    else if C = kp.2     then return (PAGE#); /* Activate the page menu */    else if C = kp.dot   then return (PART#); /* Activate the part number */    else if C = asc.refresh then return (KEYPAD#); /* Refresh keypad menu */    else if C = lf       then return (EXIT#); /* Go to music */    else if C = cur.up    then do;        if PSN > 3 then PSN = PSN - 4;      else if BLK mod 3 > 0 then do;        PSN = PSN + 4; BLK = BLK - 1; ROW = ROW - 5;   /* Move cursor up */      end;    end;    else if C = cur.down  then do;      if PSN < 4 then PSN = PSN + 4;      else if BLK mod 3 < 2 then do;        PSN = PSN - 4; BLK = BLK + 1; ROW = ROW + 5;  /* Move cursor down */      end;    end;    else if C = cur.left  then do;      if PSN mod 4 > 0 then PSN = PSN - 1;      else if BLK > 2 then do;        PSN = PSN + 3; BLK = BLK - 3; COL = 14;      /* Move cursor left */      end;    end;    else if C = cur.right then do;                   /* Move cursor right */      if PSN mod 4 < 3 then PSN = PSN + 1;      else if BLK < 3 then do;        PSN = PSN - 3; BLK = BLK + 3; COL = 36;      end;    end;    else if C = kp.0 then do;      LFOFF = LFOFF + 1;      if LFOFF = 3 then LFOFF = 0;      pos(21,14);      call DISPLAY_LIBRARY;      call REFRESH_KEYPAD;    end;  end;end KEYPAD_MENU;/* $SUBTITLE     Display a Part Item */DISPLAY_ITEM:procedure (ROW,COL,ITEM,ERASE) swap; /* Displays a part parameter on the Score or Part Menu */  dcl (ROW,COL) fixed,   /* Row, Column */      (ITEM,I)  fixed,   /* Part item */      P         pointer,      ERASE     boolean; /* If erasing */  BUFF(0) = 2; pos(ROW,COL);  if ERASE then do;                      /* If erasing an item  */    do I = 1 to ITEM_LENGTHS(ITEM); wchar(sp); end; /* Erase it */    pos(ROW,COL);  end;  do case ITEM;    /* Display the specified part parameter on the Score Menu *//*  0 */ pstring(location(NAME_BASE + 18*PART));        /* Print the instrument name *//*  1 */ if (PBITS & P_PLOT) ~= 0 then wchar(star);     /* Plotting -> * *//*  2 */ if (PBITS & P_OBRC) ~= 0 &            (PBITS & P_CBRC) ~= 0 then wchar(lbrack); /* 1 staff brkt -> [ */    else if (PBITS & P_OBRC) ~= 0 then UPPERL;        /* Top brace    -> { */    else if (PBITS & P_CBRC) ~= 0 then LOWERL;        /* Bot brace    -> } *//*  3 */ if (PBITS & P_OBAR) ~= 0 &                                (PBITS & P_CBAR) ~= 0 then VBAR;   /* Continue bar */    else if (PBITS & P_OBAR) ~= 0 then UPPERL; /* Open bar */    else if (PBITS & P_CBAR) ~= 0 then LOWERL; /* Closed bar *//*  4 */ if (PBITS & P_BBRK) ~= 0 then TOPT;    else if (PBITS & P_CBRK) ~= 0 then wchar(sp);    else                               VBAR;/*  5 */ if (PBITS & P_BLKR) ~= 0 then wchar(sp); else wchar(asc.#); /* Bend *//*  6 */ pnum(STAFF_SPACE(PART)/3,0);                        /* Staff space *//*  7 */ do; BUFF(1) = CLEF_NAMES(CLEF); pstring(BUFF); end; /* Clef *//*  8 */ do; BUFF(1) = KEY_NAMES(KEY);   pstring(BUFF); end; /* Key *//*  9 */ if (PBITS & P_UPER) ~= 0 then pstring('Upper');     /* Grand staff mode */    else if (PBITS & P_LOER) ~= 0 then pstring('Lower');    else                               pstring('Single');/* 10 */ if (PBITS & P_BEND) ~= 0 then wchar(asc.b);         /* Guitar bend mode *//* 11 */ if (PBITS & P_NATR) ~= 0 then wchar(lower.n);       /* Naturals *//* 12 */ if (PBITS & P_FLAT) ~= 0 then wchar(lower.f); else wchar(hash);   /* Sharps or flats *//* 13 */ if (PBITS & P_JAZZ) ~= 0 then wchar(asc.J);         /* Jazz syncopation */    else if (PBITS & P_CLAS) ~= 0 then wchar(asc.C);         /* Classical syncopation */    else                               wchar(asc.M);         /* Modern syncopation *//* 14 */ /*if TRACK(VOICE) ~= 0 then*/ pnum(TRACK(VOICE),0);     /* Track *//* 15 */ pnum(TRANSPOSE(VOICE),0);                           /* Transposition # in semitones *//* 16 */ do; BUFF(1) = KEY_NAMES(KEYIN_TABLE(TRANSPOSE(VOICE) mod 12)); pstring(BUFF); end;  /* Instrument Key *//* 17 */ pnum(RESOLUTION(VOICE),0);                          /* Note resolution *//* 18 */ pstring(location(NAME_BASE + 18*PART + 9));         /* Instrument abbreviation */  end;end DISPLAY_ITEM;/* $SubTitle      Get a Specified Part Item */GET_ITEM:procedure (ROW,COL,ITEM) swap; /* Gets the specified item on the Score or Part Menu part line */  dcl (ROW,COL) fixed, /* Row, Column */      ITEM      fixed, /* Part item */      STR(1)    fixed, /* String buffer */      (C,I,J,P) fixed;/* pos(0,0); erase_line; pstring(' R '); pnum(ROW,0); pstring(' C '); pnum(COL,0); pstring(' I '); pnum(ITEM,0);*/  pos(ROW,COL);  STR(0) = 0; C = 0;  if (1 <= ITEM & ITEM <= 5) \ (9 <= ITEM & ITEM <= 13) then C = rchar;  do case ITEM;    do; /* 0 - Name of Instrument */      C = GET_STR (false,location(NAME_BASE + 18*PART),16);      if C = ht then call GET_TIMBRE_NAME (TRACK(0),location(NAME_BASE + 18*PART));    end;    do; /* 1 - * bit */      if      C = ht    then PBITS = PBITS & ~P_PLOT;      else if C = asc.1 then PBITS = PBITS \  P_PLOT;    end;    do; /* 2 - { bits */      if      C = ht    then PBITS = PBITS & ~(P_OBRC \ P_CBRC);      else if C = asc.1 then PBITS = (PBITS & ~P_CBRC) \ P_OBRC;      else if C = asc.2 then PBITS = PBITS \ (P_OBRC \ P_CBRC);      else if C = asc.3 then PBITS = (PBITS & ~P_OBRC) \ P_CBRC;    end;    do; /* 3 - [ bits */      if      C = ht    then PBITS = PBITS & ~(P_OBAR \ P_CBAR);      else if C = asc.1 then PBITS = (PBITS & ~P_CBAR) \ P_OBAR;      else if C = asc.2 then PBITS = PBITS \ (P_OBAR \ P_CBAR);      else if C = asc.3 then PBITS = (PBITS & ~P_OBAR) \ P_CBAR;    end;    do; /* 4 - | bit */      if      C = ht    then PBITS = PBITS & ~(P_BBRK \ P_CBRK);      else if C = asc.1 then PBITS = (PBITS & ~P_CBRK) \ P_BBRK;      else if C = asc.2 then PBITS = (PBITS & ~P_BBRK) \ P_CBRK;    end;    do; /* 5 - # bit */      if      C = ht    then PBITS = PBITS & ~P_BLKR;      else if C = asc.1 then PBITS = PBITS \  P_BLKR;    end;    do; /* 6 - Staff Increment */      C = GET_NUM;      if C = ht then do;        PIXEL_LENGTH      = shr(PAGE_LENGTH,8) * 75 + ((PAGE_LENGTH & LBYTE) * 75) / 200;        PIXEL_LENGTH      = PIXEL_LENGTH * (SCALE_FACTOR & LBYTE) / shr(SCALE_FACTOR,8);        STAFF_SPACE(PART) = (PIXEL_LENGTH - 15) / (STVS_PP*2+1);        STAFF_SPACE(PART) = (STAFF_SPACE(PART)/3)*6;        if STAFF_SPACE(PART) > 255 then STAFF_SPACE(PART) = 255;      end;      else if 0 <= NUM_VAL & NUM_VAL ~= nullint then STAFF_SPACE(PART) = NUM_VAL*3;      if STAFF_SPACE(PART) > 255 then STAFF_SPACE(PART) = 255;    end;    do; /* 7 - Clef */      C = GET_STR (false,STR,1);      if STR(0) > 0 then do;        J = STR(1) & LBYTE; if J > 96 then J = J - 32;        do I = 0 to 6;          if J = CLEF_NAMES(I) then CLEF = I;        end;      end;    end;    /* $PAGE */    do; /* 8 - Key */      C = GET_STR (false,STR,2);      if STR(0) > 0 then do;        if STR(0) = 1 then call pbyte(STR,1,32); /* Add a space to a 1 char key */        if byte(STR,1) = asc.f then call pbyte (STR,1,lower.f); /* Allow EF or Ef */        do I = 1 to 42;          if STR(1) = KEY_NAMES(I) then do;            KEY = I;            if SET_KEY(KEY,false) >= 0            then PBITS = PBITS & ~P_FLAT;            else PBITS = PBITS \  P_FLAT;          end;        end;      end;    end;    do; /* 9  - G bit */      if      C = ht    then PBITS = PBITS & ~(P_UPER \ P_LOER);      else if C = asc.1 then PBITS = (PBITS & ~P_LOER) \ P_UPER;      else if C = asc.2 then PBITS = (PBITS & ~P_UPER) \ P_LOER;    end;    do; /* 10 - B bit */      if      C = ht    then PBITS = PBITS & ~P_BEND;      else if C = asc.1 then PBITS = PBITS \  P_BEND;    end;    do; /* 11 - N bit */      if      C = ht    then PBITS = PBITS & ~P_NATR;      else if C = asc.1 then PBITS = PBITS \  P_NATR;    end;    do; /* 12 - F bit */      if      C = ht    then PBITS = PBITS & ~P_FLAT;      else if C = asc.1 then PBITS = PBITS \  P_FLAT;    end;    do; /* 13 - S bits */      if      C = ht    then PBITS = (PBITS & ~P_JAZZ) \ P_CLAS;      else if C = asc.1 then PBITS = PBITS & ~(P_JAZZ \ P_CLAS);      else if C = asc.2 then PBITS = (PBITS & ~P_CLAS) \ P_JAZZ;    end;    do; /* 14 - Track */      C = GET_NUM;      if C = ht \ C = del then TRACK(VOICE) = 0; /* WHAT IS THIS ALL ABOUT? */      else if 0 <= NUM_VAL & NUM_VAL <= MAX_LEGAL_TRACKS#           then TRACK(VOICE) = NUM_VAL;    end;    do; /* 15 - Transpose */      C = GET_NUM;      if -128 < NUM_VAL & NUM_VAL < 128 then TRANSPOSE(VOICE) = NUM_VAL;    end;    do; /* 16 - Key of Instrument */      C = GET_STR (false,STR,2);      if STR(0) > 0 then do;        if STR(0) = 1 then call pbyte(STR,1,32); /* Add a space to a 1 char key */        J = byte(STR,0); if J > 96 then call pbyte(STR,0,J - 32); /* Map 1st char to upper case */        do I = 1 to 42;          if STR(1) = KEY_NAMES(I) then TRANSPOSE(VOICE) = TRANS_TABLE(KEY_CODES(I)+7);        end;      end;    end;    do; /* 17 - Resolution */      C = GET_NUM;      if POWER(NUM_VAL) then RESOLUTION(VOICE) = NUM_VAL;    end;    C = GET_STR (false,location(NAME_BASE + 18*PART + 9),16); /* 18 - Abbreviation of name of Instrument */  end; /* End of case */  return (C);end GET_ITEM;/* $Subtitle Display Part Settings */DISPLAY_VOICE_LINE:procedure (ERASE) swap; /* Displays or erases the voice setting */  dcl ERASE     boolean, /* If erasing */      (ROW,COL) fixed,   /* Row, Column */      ITEM      fixed;   /* Item in part line */  if TWO_VOICE then ROW = 13 - VOICE;               else ROW = 12;  pos(ROW,VOICE_TABLE(0));  if TWO_VOICE then do;               /* If two voices */    if VOICE then pstring('Upper ');  /* If upper voice */             else pstring('Lower ');  end;  else pstring('Single');             /* Single voice */  do ITEM = 14 to 17;    call DISPLAY_ITEM (ROW,VOICE_TABLE(ITEM-13),ITEM,ERASE); /* Display or erase the voice setting */  end;  if ERASE & ~TWO_VOICE then do; /* Clear second voice line if not in use */    pos(13,2);    do ITEM = 2 to 77; wchar(sp); end;  end;end DISPLAY_VOICE_LINE;PART_MENU_TEXT:procedure swap;  /* Prints the Part Menu title and text in the header boxes */  clear_all; pos(2,14); pstring(DOUBLE_WIDE); pstring('Part Menu'); /* Clear the screen and print the title in double width characters */  call BOX (3,1,8,30);  pos(4,3); pstring('Part:   ');  pos(5,3); pstring('Name:');  pos(6,3); pstring('Abbrev:');  pos(7,3); pstring('Format:');  call HEADER_BOX (3,31,8,78);  pos(4,33); pstring(' Staff    Format    Spacing    Clef    Key');  call HEADER_BOX (9,1,14,78);  pos(10,3); pstring('   Voice      Track      Transpose      Key of Instrument      Resolution');end PART_MENU_TEXT;PART_MENU_FILL:procedure (ERASE) swap; /* Fills in or erases the part menu */  dcl ERASE boolean,  /* If erasing */      ITEM  fixed;    /* Item in part line */  pos(4,11); pnum(PART+1,0); wchar(sp);  call DISPLAY_ITEM (5,11, 0,ERASE); /* Instrument name */  call DISPLAY_ITEM (6,11,18,ERASE); /* Instrument abbreviation */  do ITEM = 1 to 5;                  /* Fixed format bits */    call DISPLAY_ITEM (7,10+ITEM,ITEM,ERASE);  end;  do ITEM = 6 to 13;    call DISPLAY_ITEM (6,STAFF_TABLE(ITEM-6),ITEM,ERASE); /* Staff specific items */  end;  do VOICE = 0 to TWO_VOICE; /* Voice specific items */    call DISPLAY_VOICE_LINE (ERASE);  end;  VOICE = 0;  if TWO_VOICE then VOICE = 1;end PART_MENU_FILL;/* $SubTitle     Part Menu */PART_MENU:procedure swap; /* Prints the Part Menu, current settings, and handles the menu */  dcl (ROW,COL) fixed, /* Row, Column */      ITEM      fixed, /* Item in part line */      MODE      fixed, /* Region in part menu */      C         fixed;  cmdline = 17;  call LOAD_PART_VECTOR (PART_BASE,PART);  /* Load a part in */  call PART_MENU_TEXT;                     /* Print the part menu title and text */  call PART_MENU_FILL (false);             /* Fill in the menu items */  if ERR_PTR ~= null then call DISPLAY_ERROR;  ITEM  = 0;  do forever;    MODE = 0;                              /* Determine which region in the part menu */         if 6  <= ITEM & ITEM <= 13 then MODE = 1;    else if 14 <= ITEM & ITEM <= 17 then MODE = 2;    do case MODE;     /* Position cursor depending upon the menu region */      do;        COL = 11;        if      ITEM = 0  then ROW = 5;        else if ITEM = 18 then ROW = 6;        else do;          ROW = 7; COL = ITEM + 10;        end;      end;      do;        ROW = 6;        COL = STAFF_TABLE(ITEM-6);      end;      do;                                     /* Position cursor on number of voices */        if TWO_VOICE then ROW = 13 - VOICE;                     else ROW = 12;        COL = VOICE_TABLE(ITEM-13);      end;    end;/*    call CLEAN_SEQUENCE (true); */    C = GET_ITEM (ROW,COL,ITEM); /* Get the part line item */    if C = pf.1 & 0 < PART then do;             /* If Moving up a part */       call DUMP_PART_VECTOR (PART_BASE,PART);  /* Dump the part line into main memory */       PART = PART - 1;                         /* Move up a part */       call LOAD_PART_VECTOR (PART_BASE,PART);  /* Load a part into the variables */       call PART_MENU_FILL (true);              /* Erase the current settings */    end;    else if C = pf.2 & PART < PARTS then do;    /* If moving down a part */       call DUMP_PART_VECTOR (PART_BASE,PART);  /* Dump the part line into main memory */       PART = PART + 1;                         /* Move down a part */       call LOAD_PART_VECTOR (PART_BASE,PART);  /* Load a part into the part variables */       call PART_MENU_FILL (true);              /* Erase the current settings */    end;    else do;       /* $PAGE */      call DISPLAY_ITEM (ROW,COL,ITEM,true);      /* These items effect other part items */       if      ITEM = 15 then call DISPLAY_ITEM (ROW,VOICE_TABLE(3),16,true); /* Transposition */      else if ITEM = 16 then call DISPLAY_ITEM (ROW,VOICE_TABLE(2),15,true); /* Instrument key */      else if ITEM = 8  then call DISPLAY_ITEM (ROW,STAFF_TABLE(6),12,true); /* Sharp/flat -> Key signature */      if C = kp.enter \ C = lf \ (kp.1 <= C & C <= kp.3) then call DUMP_PART_VECTOR (PART_BASE,PART); /* Dump the part vector */           if C = kp.enter  then return (MAIN#);  /* Activate the main menu */      else if C = kp.1      then return (SCORE#); /* Activate the score menu */      else if C = kp.2      then return (PAGE#);  /* Activate the page menu */      else if C = kp.3      then return (KEYPAD#);/* Activate the keypad menu */      else if C = asc.refresh then return (PART#); /* Refresh part menu */      else if C = lf        then return (EXIT#); /* Go to music */      else if C = cur.up then do case MODE;        if 1 <= ITEM & ITEM <= 5 then ITEM = 18; else if ITEM = 18 then ITEM = 0;        ;        if TWO_VOICE & VOICE = 0 then VOICE = 1; else ITEM = 1;      end;      else if C = cur.down then do case MODE;        if ITEM = 0 then ITEM = 18; else if ITEM = 18 then ITEM = 1; else ITEM = 14;        ITEM = 14;        if VOICE = 1 then VOICE = 0;      end;      else if C = cur.right then do case MODE;        if 1 <= ITEM & ITEM < 5 then ITEM = ITEM + 1; else ITEM = 9;        if ITEM ~= 8 then do;          if ITEM = 13 then ITEM = 6;          else ITEM = ITEM + 1;        end;        if ITEM < 17 then ITEM = ITEM + 1;      end;      else if C = cur.left  then do case MODE;        if 1 < ITEM & ITEM <= 5 then ITEM = ITEM - 1;        if ITEM = 9 then ITEM = 0; else if ITEM = 6 then ITEM = 13; else ITEM = ITEM - 1;        if 14 < ITEM then ITEM = ITEM - 1;      end;      else if C = pf.3 & ~TWO_VOICE then do;   /* Go to one voice */        TRACK(1)  = TRACK(0);        TWO_VOICE = true;        VOICE     = 0;        call DISPLAY_VOICE_LINE (false);        VOICE     = 1;        call DISPLAY_VOICE_LINE (true); /* Erase the previous voice line */      end;      else if C = pf.4 & TWO_VOICE then do;  /* Go to two voice */        TRACK(1)  = 0;        VOICE     = 0;        TWO_VOICE = false;        call DISPLAY_VOICE_LINE (true); /* Erase the previous voice line */      end;    end;  end;end PART_MENU;/* $PAGE */DISPLAY_LINES:procedure (P1,P2,PBASE,ERASE) swap; /* Displays part lines given the start and ending part */  dcl (P1,P2)    fixed,   /* Display from part P1 to part P2 */      PBASE      fixed,   /* Part in upper lefthand corner */      (ROW,COL)  fixed,      (ITEM,I,J) fixed,      ERASE      boolean; /* Set to clear previous values */  I = PART; /* Save the current part */  if P1 < PBASE      then P1 = PBASE;  if P2 > PBASE + 31 then P2 = PBASE + 31;  do PART = P1 to P2;   /* Do for all parts designated */    ROW = (PART mod 16) + 4;    COL = 0; if PART >= PBASE+16 then COL = 39;    if PART <= PARTS then do;      call LOAD_PART_VECTOR (PART_BASE,PART); /* Load a part */      pos(ROW,COL+2); pstring('    ');      pos(ROW,COL+2); pnum(PART+1,0);         /* Print the part number */      if LIST_INDEX(PART) ~= 0 then do;        pos(ROW,COL+5); wchar(asc.e);      end;      do ITEM = 0 to 6; /* Display the score menu part line */        call DISPLAY_ITEM (ROW,COL+SCORE_TABLE(ITEM),ITEM,ERASE);      end;    end;    else do; /* Clear the line */      pos(ROW,COL+2);      do J = 1 to 37; wchar(sp); end;    end;  end;  PART = I;             /* Restore the part number */end DISPLAY_LINES;/* SubTitle Score Menu */SCORE_MENU:procedure swap;  dcl (ROW,COL)     fixed,      ITEM          fixed,      PBASE         fixed,      (C,I,J)       fixed,      (P,Q)         pointer;  cmdline = 23;  clear_all; pos(0,14);                             /* Clear the screen */  pstring(DOUBLE_WIDE); pstring('Score Menu');  /* Print the score menu title in double wide characters */  call HEADER_BOX (1,0,20,78);          /* Draw the header box */  call BOX (20,0,22,78);  pstring(ALTERNATE_CHARS); pos(1,39);  /* Invoke special graphics character set */  wchar(lower.w);                       /* Draw a top "T" */  do I = 4 to 21;    wchar(bs); wchar(lf);    if I = 5 then wchar(lower.n); else wchar(lower.x);  /* Draw a horizontal line */  end;  wchar(bs); wchar(lf); wchar(lower.v);                 /* Draw a bottom "T" */  pos(20,0);  wchar(lower.t);  pos(20,78); wchar(lower.u);  pstring(NORMAL_CHARS);  pos(2,2);  pstring(SCORE_TEXT);  pos(2,41); pstring(SCORE_TEXT);  if LIST_INDEX(MASTER_PART) ~= 0 then do;    pos(21,48); pstring('Master Edit List');  end;  if ERR_PTR ~= null then call DISPLAY_ERROR;  ITEM  = 1;  PBASE = 0;  do while PBASE + 31 < PART;    PBASE = PBASE + 16;  end;  call DISPLAY_LINES (0,PARTS,PBASE,false); /* Fill screen initially */  do forever;    ROW = (PART mod 16) + 4;    COL = SCORE_TABLE(ITEM) + ((PART-PBASE)/16) * 39;    call LOAD_PART_VECTOR (PART_BASE,PART);    /* Load a part *//*    call CLEAN_SEQUENCE (true); */    C = GET_ITEM (ROW,COL,ITEM);    call DISPLAY_ITEM (ROW,COL,ITEM,true);     /* Display the part line */    call DUMP_PART_VECTOR (PART_BASE,PART);    /* Dump the part into main memory */         if C = kp.enter  then return (MAIN#);   /* Activate the main menu */    else if C = kp.2      then return (PAGE#);   /* Activate the page menu */    else if C = kp.3      then return (KEYPAD#); /* Activate the keypad menu */    else if C = kp.dot    then return (PART#);   /* Activate the part menu */    else if C = asc.refresh then return (SCORE#); /* Refresh score menu */    else if C = lf        then return (EXIT#);   /* Go to music *//*    else if C = ctrl.d then print_edit;    else if C = ctrl.l then print_list_indices;*/    else if C = cur.down  & PART < PARTS then PART = PART + 1; /* Down a part */    else if C = cur.up    & PART > 0     then PART = PART - 1; /* Up a part */    else if C = cur.right then do; /* Right one item */      if ITEM < 6 then ITEM = ITEM + 1;      else if PART/16 < PARTS/16 then do;        ITEM = 0;        PART = PART + 16;        if PART > PARTS then PART = PARTS;      end;    end;    else if C = cur.left  then do; /* Left one item */      if ITEM > 0 then ITEM = ITEM - 1;      else if PART/16 > 0 then do;        ITEM = 6;        PART = PART - 16;      end;    end;    else if C = pf.1     & PARTS < MAX_PARTS - 1 then do; /* Insert a part above from buffer or defaults */      call INSERT_BUFF;      call DISPLAY_LINES (PART,PARTS,PBASE,true);      if PART = PARTS - 1 then PART = PARTS;    end;    else if C = kp.comma & PARTS < MAX_PARTS - 1 then do; /* Insert a part below from buffer or defaults */      PART = PART + 1;      call INSERT_BUFF;      call DISPLAY_LINES (PART,PARTS,PBASE,true);      if PART = PARTS - 1 then PART = PARTS;    end;    else if C = pf.2 & PARTS > 0 then do; /* Delete a part */      call DELETE_PART;      call DISPLAY_LINES (PART,PARTS+1,PBASE,true);      if PART > PARTS then PART = PARTS;    end;    else if C = kp.minus then call PART_TO_BUFF; /* Store a part in buffer */    else if C = pf.3 & LIST_INDEX(PART) ~= 0 then do;      /* Delete the edit list if it exists */      call DELETE_EDIT (PART);      pos(ROW,5 + 39*((PART-PBASE)/16)); wchar(sp);    end;    else if C = pf.4 & LIST_INDEX(MASTER_PART) ~= 0 then do; /* Delete the master edit list if it exists */      call DELETE_EDIT (MASTER_PART);      pos(21,48); do I = 1 to 16; wchar(sp); end;    end;    else if C = kp.0 then do; /* Set vertical spacing from staves/page */      pos(21,2); pstring('Staves per page: '); C = GET_NUM;      if 0 < NUM_VAL & NUM_VAL < 1000 then do;        STVS_PP      = NUM_VAL;        PIXEL_LENGTH = shr(PAGE_LENGTH,8) * 75 + ((PAGE_LENGTH & LBYTE) * 75) / 200;        PIXEL_LENGTH = PIXEL_LENGTH * (SCALE_FACTOR & LBYTE) / shr(SCALE_FACTOR,8);        Q            = (PIXEL_LENGTH - 15) / (STVS_PP*2+1);        Q            = (Q/3)*6; /* Justify to 3 */        if Q > 255 then Q = 255;        STAFF_SPACE(PART) = Q;        do P = 0 to PARTS;          call LOAD_PART_VECTOR (PART_BASE,P); /* Hmmm... */          STAFF_SPACE(P) = Q;          if PBASE <= P & P <= PBASE + 31 then do;            I = (P mod 16) + 4; J = SCORE_TABLE(6) + ((P-PBASE)/16) * 39;            call DISPLAY_ITEM (I,J,6,true);          end;          call DUMP_PART_VECTOR (PART_BASE,P); /* Hmmmmmmm... */        end;      end;      pos(21,2); do I = 1 to 21; wchar(sp); end;    end;    else if C = kp.7 \ C = kp.8 then do P = 0 to PARTS;      call LOAD_PART_VECTOR (PART_BASE,P); /* Hmmm... */      if C = kp.7 then PBITS = PBITS \ P_PLOT;                  else PBITS = PBITS & ~P_PLOT;      if PBASE <= P & P <= PBASE + 31 then do;        I = (P mod 16) + 4; J = SCORE_TABLE(1) + ((P-PBASE)/16) * 39;        call DISPLAY_ITEM (I,J,1,true);      end;      call DUMP_PART_VECTOR (PART_BASE,P); /* Hmmmmmmm... */    end;    else if C = ff then do; /* Display total vertical spacing */      pos(21,2); pstring('System Size: ');      I = 0;      do P = 0 to PARTS;        call LOAD_PART_VECTOR (PART_BASE,P); /* Hmmm... */        if (PBITS & P_PLOT) ~= 0        then I = I + STAFF_SPACE(P)/3;      end;      pnum(I,0); pstring('  ');    end;    if PART < PBASE then do;      PBASE = PBASE - 16;      call DISPLAY_LINES (PBASE,PBASE + 31,PBASE,true);    end;    else if PART > PBASE + 31 then do;      PBASE = PBASE + 16;      call DISPLAY_LINES (PBASE,PBASE + 31,PBASE,true);    end;  end;end SCORE_MENU;/* $Subtitle Page Menu */DISPLAY_PAGE_ENTRY:procedure (ROW,COL) swap;  dcl (ROW,COL) fixed;  pos(ROW,COL);  if COL < 45 then do case ROW - 13; /* Left hand side of menu */    call PRINT_DECIMAL(LEFT_MARGIN);    call PRINT_DECIMAL(PAGE_WIDTH);     call PRINT_DECIMAL(BOT_MARGIN);     call PRINT_DECIMAL(PAGE_LENGTH);    call PRINT_DECIMAL(OVERLAP);        do;      pnum(shr(SCALE_FACTOR,8),0); wchar(slash);      pnum(SCALE_FACTOR & LBYTE,0); pstring('  ');    end;    pnum(NOTE_SPACE/4,0);    pnum(SPACING_PERCENT,0);    pnum(FIRST_INDENT,0);    pstring(OVERLAY_FILE);  end;  else do case ROW - 11; /* Right hand side of menu */    if INIT_PAGE = 0 then pstring('Off'); else pnum(INIT_PAGE,0);    if INIT_MEAS = 0 then pstring('Off'); else pnum(INIT_MEAS,0);    if LAST_MEAS = 0 then pstring('Off'); else pnum(LAST_MEAS,0);    if MEAS_FREQ = 0 then pstring('Off  ');    else do;      pnum(MEAS_FREQ,0); wchar(slash);      pnum(MEAS_SYNC,0); pstring('  ');    end;    if MEAS_LINE = 0 then pstring('Off'); else pnum(MEAS_LINE,0);    if (FORMAT & F_END) ~= 0 then pstring('On'); /* If end of piece is on */                             else pstring('Off');    if   (FORMAT & F_BRST) ~= 0 then do;      if (FORMAT & F_1RST) ~= 0 then pstring('On 1''s');                                else pstring('On  ');    end;                                else pstring('Off ');    do case PRINTER_TYPE;      ;      ;      pstring('8x11 laser');      pstring('8x14 laser');      pstring('Typeset Hi');      pstring('Typeset Lo');    end;    if (FORMAT & F_FWDR) ~= 0 then do;      if (FORMAT & F_LAND) ~= 0 then pstring('Landscape');                                else pstring('Portrait');    end;    else do;      if (FORMAT & F_LAND) ~= 0 then pstring('Land Rev');                                else pstring('Port Rev');    end;    if (FORMAT & F_MANFD) ~= 0 then pstring('Manual');                               else pstring('Tray  ');    if (FORMAT & F_LVDOT) ~= 0 then pstring('Up  ');                               else pstring('Down');  end;  if COL = 67 & ROW >= 13 & ROW <= 15 then pstring('  ');  pstring('  ');end DISPLAY_PAGE_ENTRY;PAGE_MENU:procedure swap;  dcl (ROW,COL,C,P,I) fixed;  cmdline = 23;  clear_all; pos(0,15); pstring(DOUBLE_WIDE); pstring('Page Menu'); /* Print the page menu title in double wide characters */  call HORIZONTAL_LINE (2);  call HORIZONTAL_LINE (4);  call HORIZONTAL_LINE (6);  call HORIZONTAL_LINE (8);  pos(2,74);          pstring(' Title');  pos(4,66);  pstring(' Left Subtitle');  pos(6,65); pstring(' Right Subtitle');  pos(8,70);      pstring(' Copyright');  P = TEXT_BASE; pos(3,0); pstring(location(P)); /* Title */  P = P + 41;    pos(5,0); pstring(location(P)); /* Left Subtitle */  P = P + 41;    pos(7,0); pstring(location(P)); /* Right subtitle */  P = P + 41;    pos(9,0); pstring(location(P)); /* Copyright */  call BOX (10,0,23,79);  pos(11, 2); reverse(1); pstring('Page Format Specifications:'); reverse(0);  pos(13, 2); pstring('Left Margin       (inches):');  pos(14, 2); pstring('Page Width        (inches):');  pos(15, 2); pstring('Top/Bottom Margin (inches):');  pos(16, 2); pstring('Page Length       (inches):');  pos(17, 2); pstring('Tile Overlap      (inches):');  pos(18, 2); pstring('Music Size Factor (N/D):');  pos(19, 2); pstring('Note Spacing (1/2 note wth):');  pos(20, 2); pstring('Spacing Percentage:');  pos(21, 2); pstring('First System Indent:');  pos(22, 2); pstring('Overlay file:');  pos(11,42); pstring('Starting Page Number:');  pos(12,42); pstring('Starting Measure Number:');  pos(13,42); pstring('Final Measure Number:');  pos(14,42); pstring('Numbering Frequency:');  pos(15,42); pstring('Measures per Line:');  pos(16,42); pstring('End of Piece:');  pos(17,42); pstring('Block Rests:');  pos(18,42); pstring('Printer Type:');  pos(19,42); pstring('Orientation:');  pos(20,42); pstring('Paper Feed:');  pos(21,42); pstring('Lower voice dots:');  if ERR_PTR ~= null then call DISPLAY_ERROR;  do COL = 31 to 67 by 67-31;    do ROW = 11 to 22;      call DISPLAY_PAGE_ENTRY (ROW,COL);    end;  end;  ROW = 13; COL = 31;  do forever;    pos(ROW,COL);/*    call CLEAN_SEQUENCE (true); */    if 3 <= ROW & ROW <= 9 then do; /* Load a title directly into the text area */      C = GET_STR (false,location(TEXT_BASE + (shr(ROW,1)-1)*41),80);      if C = del then erase_line;    end;    else if ROW = 22 then do;      C = GET_STR (true,OVERLAY_FILE,32);      if C = del then do I = 1 to 32; wchar(sp); end;    end;    else if COL = 67 & ROW >= 16               then C = rchar;    else if COL = 31 & (ROW >= 13 & ROW <= 17) then C = GET_DECIMAL;    else                                            C = GET_NUM;    if COL = 31 then do case ROW - 13;      if NUM_VAL ~= nullint then LEFT_MARGIN = NUM_VAL;      if NUM_VAL ~= nullint then PAGE_WIDTH  = NUM_VAL;      else if C = ht           then if (FORMAT & F_LAND) ~= 0                then PAGE_WIDTH = IMAGE_LENGTH;                else PAGE_WIDTH = IMAGE_WIDTH;      if NUM_VAL ~= nullint then BOT_MARGIN  = NUM_VAL;      if NUM_VAL ~= nullint then PAGE_LENGTH = NUM_VAL;      else if C = ht           then if (FORMAT & F_LAND) ~= 0                then PAGE_LENGTH = IMAGE_WIDTH;                else PAGE_LENGTH = IMAGE_LENGTH;      if NUM_VAL ~= nullint then OVERLAP     = NUM_VAL;      if NUM_VAL ~= nullint then do; /* Get scale factor */        if 0 < NUM_VAL & NUM_VAL < 256        then SCALE_FACTOR = shl(NUM_VAL,8) \ (SCALE_FACTOR & LBYTE);        if C = slash then do;          wchar(slash); C = GET_NUM;          if 0 < NUM_VAL & NUM_VAL < 256          then SCALE_FACTOR = (SCALE_FACTOR & UBYTE) \ NUM_VAL;        end;      end;      if 0 <  NUM_VAL & NUM_VAL <  256 then NOTE_SPACE      = NUM_VAL*4;      if 0 <= NUM_VAL & NUM_VAL <= 100 then SPACING_PERCENT = NUM_VAL;      if 0 <= NUM_VAL & NUM_VAL <  256 then FIRST_INDENT    = NUM_VAL;    end;    else if COL = 67 then do case ROW - 11;      if (0 <= NUM_VAL & NUM_VAL ~= nullint) \ C = ht then do; /* Set initial page number */        if C = ht then INIT_PAGE = 0;                  else INIT_PAGE = NUM_VAL;      end;      if (0 <= NUM_VAL & NUM_VAL ~= nullint) \ C = ht then do; /* Set initial measure number */        if C = ht then do;          INIT_MEAS = 0; START_MEAS = 1;        end;        else do;          INIT_MEAS = NUM_VAL; START_MEAS = INIT_MEAS;        end;      end;      if (0 <= NUM_VAL & NUM_VAL ~= nullint) \ C = ht then do; /* Set last measure number */        if C = ht then LAST_MEAS = 0;                  else LAST_MEAS = NUM_VAL;      end;      if NUM_VAL ~= nullint \ C = ht then do; /* Get measure number frequency */        if C = ht then MEAS_FREQ = 0;        else if 0 < NUM_VAL & NUM_VAL < 256 then MEAS_FREQ = NUM_VAL;        if C = slash then do;          wchar(slash); C = GET_NUM;          if 0 < NUM_VAL & NUM_VAL < 256          then MEAS_SYNC = NUM_VAL;        end;      end;      if (0 < NUM_VAL & NUM_VAL < 256) \ C = ht then do;        if C = ht then MEAS_LINE = 0;                  else MEAS_LINE = NUM_VAL;      end;      if      C = asc.1 then FORMAT = FORMAT \  F_END; /* Set if end of piece is on */      else if C = ht    then FORMAT = FORMAT & ~F_END;      if      C = asc.2 then FORMAT = FORMAT \ F_BRST \ F_1RST; /* Set if block rests from 1 */      else if C = asc.1 then FORMAT = (FORMAT \ F_BRST) & ~F_1RST; /* Set if block rests from 2 */      else if C = ht    then FORMAT = FORMAT & ~(F_BRST \ F_1RST);      if      C = ht    then PRINTER_TYPE = 2;      else if C = asc.1 then PRINTER_TYPE = 2;      else if C = asc.2 then PRINTER_TYPE = 2;      else if C = asc.3 then PRINTER_TYPE = 3;      else if C = asc.4 then PRINTER_TYPE = 4;      else if C = asc.5 then PRINTER_TYPE = 5;      if      C = ht    then FORMAT = (FORMAT \ F_FWDR) & ~F_LAND;      else if C = asc.1 then FORMAT = (FORMAT \ F_FWDR) \  F_LAND;      else if C = asc.2 then FORMAT = (FORMAT & ~F_FWDR) & ~F_LAND;      else if C = asc.3 then FORMAT = (FORMAT & ~F_FWDR) \  F_LAND;      if      C = ht    then FORMAT = FORMAT & ~F_MANFD;      else if C = asc.1 then FORMAT = FORMAT |  F_MANFD;      if      C = ht    then FORMAT = FORMAT & ~F_LVDOT;      else if C = asc.1 then FORMAT = FORMAT |  F_LVDOT;    end;    if LAST_MEAS > 0 & LAST_MEAS < INIT_MEAS then LAST_MEAS = INIT_MEAS; /* Final measure (if on) cannot be > First measure */    call SET_IMAGE_AREA;    if ROW >= 11 then call DISPLAY_PAGE_ENTRY (ROW,COL);    if      C = kp.enter then return (MAIN#);   /* Activate main menu */    else if C = kp.1     then return (SCORE#);  /* Activate score menu */    else if C = kp.3     then return (KEYPAD#); /* Activate keypad menu */    else if C = kp.dot   then return (PART#);   /* Activate part menu */    else if C = asc.refresh then return (PAGE#); /* Refresh main menu */    else if C = lf       then return (EXIT#);   /* Go to music */    else if C = cur.up & ROW > 4 then do;      /* Move up */      if      ROW <= 9 then ROW = ROW - 2;      else if (COL = 31 & ROW = 13) \ ROW = 11 then do;        ROW = 9; COL = 0;      end;      else ROW = ROW - 1;    end;    else if C = cur.down & ROW < 22 then do;   /* Move down */      if      ROW < 9 then ROW = ROW + 2;      else if ROW = 9 then do; ROW = 13; COL = 31; end;      else if COL = 31 | ROW < 21 then ROW = ROW + 1;    end;    else if C = cur.right & ROW >= 13 & ROW < 22 then COL = 67; /* Move to right column */    else if C = cur.left  then do;      if ROW >= 11 then do;        COL = 31;        if ROW < 13 then ROW = 13;      end;    end;  end;end PAGE_MENU;/* $SubTitle Main Menu */MAIN_MENU:procedure swap;  dcl REVISION       fixed data external,      SCRIPT_RELEASE fixed data external,      RELEASE_DATE   fixed data external;  dcl ROW   fixed,      COL   fixed,      (C,I) fixed,      VALID boolean;  dcl COPY_NOTICE1 fixed data      ('Copyright   New England Digital Corporation 1989, [1981-1988]');  dcl COPY_NOTICE2 fixed data      ('All rights reserved.');/*  dcl SLUR_WIDTH  fixed external;  dcl SLUR_BORDER fixed external;*/  cmdline = 23;  clear_all;  pos(1,3); pstring(DOUBLE_WIDE);   /* Print the title in double wide characters */  pstring('Synclavier Music Engraving System');  call BOX (2,1,22,78);  pstring(ALTERNATE_CHARS);  pos(9,1);  wchar(lower.t);  do I = 2 to 77;    wchar(lower.q);  end;  wchar(lower.u);  pos(9,40);  wchar(lower.w);  do I = 9 to 20;    wchar(bs); wchar(lf);    wchar(lower.x);  end;  wchar(bs); wchar(lf);  wchar(lower.v);  pstring(NORMAL_CHARS);  pos(3,3); pstring('Program Version: '); pstring(REVISION); if interp_is_running pstring(' Synclavier³'); else pstring(' Model D');  pos(4,3); pstring('Free memory:     '); pnum(SECTS_LEFT,0);  pos(5,3); pstring('Sequence name:   ');  if NUMBERED_SEQUENCE then wchar(shr(SEQUENCE_NAME(2),8)+1);                       else pstring(SEQUENCE_NAME);  pos(3,42); pstring('Supports Release: '); pstring(SCRIPT_RELEASE);  pos(4,42); pstring('Release Date:     '); pstring(RELEASE_DATE);  viewport (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#);  iwindow  (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#);  if MACII | MG600 then do;    PLOT_SYMBOL ("311",339,721,UP#); /* Registered Trade Mark */    PLOT_SYMBOL ("332",333,530,UP#); /* Copyright */    imove_to (250,530);    CURRENT_FONT = F_RESET#;    call SET_FONT (F_ALPHA#); alpha_mode;    pstring(COPY_NOTICE1);    imove_to (420,510); alpha_mode;    pstring(COPY_NOTICE2);  end;  else do;    PLOT_SYMBOL ("311",207,449,UP#); /* Registered Trade Mark */    PLOT_SYMBOL ("332",143,330,UP#); /* Copyright */    imove_to (060,330);    CURRENT_FONT = F_RESET#;    call SET_FONT (F_ALPHA#); alpha_mode;    pstring(COPY_NOTICE1);    imove_to (210,310); alpha_mode;    pstring(COPY_NOTICE2);  end;  transparent_mode;  /*  if DEBUG then do;    dcl S(1) fixed;    dcl T(1) fixed;    disable;    S(0) = CLOCK(0); S(1) = CLOCK(1);    T(0) = TIME_XOFFED(0); T(1) = TIME_XOFFED(1);    enable;    pos(8,19); pstring('Time XOFFed: '); call print_time (T);               pstring('   Total time: '); call print_time (S);  end;  *//*call BOX (9,1,22,39);*/  pos(10,3); reverse(1); pstring('System Commands:'); reverse(0);  pos(12,3); pstring('BREAK      Return to the Monitor');  pos(13,3); pstring('PF1        Reverse compile');  pos(14,3); pstring('PF2        Activate RealTime System');  pos(15,3); pstring('keypad ,   Store a sequence');  pos(16,3); pstring('keypad 0   Recall a sequence');  pos(17,3); pstring('keypad 1   Activate Score menu');  pos(18,3); pstring('keypad 2   Activate Page menu');  pos(19,3); pstring('keypad 3   Activate Keypad menu');  pos(20,3); pstring('keypad .   Activate Part menu');  pos(21,3); pstring('RETURN     Activate notation system');/*call BOX (9,40,22,78);*/  pos(10,42); reverse(1); pstring('Overall Parameters:'); reverse(0);  pos(12,42); pstring('Operation Mode:');  pos(13,42); pstring('Jump to Measure:');  pos(15,42); pstring('Start at Click:');  pos(16,42); pstring('Click Track:');  pos(17,42); pstring('Click Note:');  pos(18,42); pstring('Time Signature:');  pos(19,42); pstring('Edit Resolution:');  pos(21,42); pstring('Storage Device:');  if ERR_PTR ~= null then call DISPLAY_ERROR;  /* WHY IS THIS HERE? */  if START_MEAS < INIT_MEAS then START_MEAS = INIT_MEAS; /* Contain jump to measure within the initial and last measure number */  if START_MEAS > LAST_MEAS & LAST_MEAS > 0 then START_MEAS = LAST_MEAS;  ROW = 12; COL = 64;  /* $PAGE */  do forever;/*  pos(10,64); pnum(SLUR_WIDTH,0);  wchar(sp);    pos(10,70); pnum(SLUR_BORDER,0); wchar(sp); */    pos(12,66); do case MAIN_MODE; /* Operation Mode */                  pstring('Display');                  pstring('Edit   ');                  pstring('Print  ');                  pstring('Extract');                  pstring('Test   ');                end;    pos(13,66); pnum(START_MEAS,0);   pstring(SPACE_5); /* Jump to Measure */    pos(15,66); pnum(START_CLICK,0);  pstring(SPACE_5);                             /* Starting click setting */    pos(16,66); if CLICK_TRACK = 0 then pstring('Click');               /* Click track setting */                else do; pnum(CLICK_TRACK,0); pstring(SPACE_5); end;                       pos(17,66); pnum(shr(CLICK_NOTE,8),0);  wchar(slash);               /* Click note setting */                pnum(CLICK_NOTE & LBYTE,0); pstring(SPACE_5);    pos(18,66); if      (FORMAT & F_COMT) ~= 0 then pstring('Common');                else if (FORMAT & F_CUTT) ~= 0 then pstring('Cut');                else do; pnum(BEAT_MEAS,0); wchar(slash); pnum(BEAT_NOTE,0); end;                pstring('      ');    pos(19,66); pnum(EDIT_RESOLUTION,0);  pstring(SPACE_5);             /* Edit resolution */    pos(21,66); call PRINT_DEVICE (STORAGE_DEVICE);    if DEBUG then do;      if ERROR_CHECK then do;        pos(10,67); reverse(1); pstring('Error Check'); reverse(0);      end;      else do; pos(10,67); pstring('           '); end;    end;    if ROW = 10 then pos (ROW,COL); else /* ***** */    pos(ROW,66);/*    call CLEAN_SEQUENCE (true); */    if ROW = 12 \ ROW = 21 then C = rchar;  /* If main mode or device setting */                           else C = GET_NUM;    if lower.a <= C & C <= lower.z then C = C - 32; /* If lower case, capitalize it */    if ROW = 15 \ ROW = 19 then do; /* StartClick and EditResolution can't change if seq has been edited */      VALID = true;      do I = 0 to PARTS;        if LIST_INDEX(I) ~= 0 then VALID = false; /* Check edit list to see if editing occurred */      end;      if LIST_INDEX(MASTER_PART) ~= 0 then VALID = false;    end;/*  if ROW = 10 & 0 <= NUM_VAL & NUM_VAL < 32000 then do;      if COL = 64 then SLUR_WIDTH  = NUM_VAL;                  else SLUR_BORDER = NUM_VAL;    end; else */    do case ROW - 12;      if      C = ht    then MAIN_MODE = DISPLAY#; /* Set main mode */      else if C = asc.1 then MAIN_MODE = SYSEDIT#;      else if C = asc.2 then MAIN_MODE = PRINT#;      else if C = asc.3 then MAIN_MODE = EXTRACT#;      else if C = asc.4 & DEBUG then MAIN_MODE = TEST#;      if      C = ht    then START_MEAS = INIT_MEAS; /* TAB sets jump to 1st measure */      else if NUM_VAL ~= nullint & INIT_MEAS <= NUM_VAL &  /* Set jump to measure value */              (LAST_MEAS = 0 \ NUM_VAL <= LAST_MEAS)           then START_MEAS = NUM_VAL;      ;      if 0 < NUM_VAL & NUM_VAL < 256 & VALID then START_CLICK = NUM_VAL;  /* Set starting click */      do;        if 0 < NUM_VAL & NUM_VAL < MAX_SYSTEM_TRACKS# then CLICK_TRACK = NUM_VAL;   /* Set click track */        else if C = ht then CLICK_TRACK = 0;      end;      do;       /* Set the click note */        if 0 < NUM_VAL & NUM_VAL < 256 then CLICK_NOTE = shl(NUM_VAL,8) \ (CLICK_NOTE & LBYTE);        if C = slash then do;          wchar(C); C = GET_NUM;          if 0 < NUM_VAL & NUM_VAL < 256 then CLICK_NOTE = (CLICK_NOTE & UBYTE) \ NUM_VAL;        end;      end;      do;        if      C = ht    then do;          BEAT_MEAS = 4;          BEAT_NOTE = 4;          FORMAT    = (FORMAT & ~F_CUTT) \ F_COMT;        end;        else if C = asc.q then do;          BEAT_MEAS = 2;          BEAT_NOTE = 2;          FORMAT    = (FORMAT & ~F_COMT) \ F_CUTT;        end;        else if NUM_VAL ~= nullint then do;          if 0 < NUM_VAL & NUM_VAL < 256 then BEAT_MEAS = NUM_VAL; /* Set the time signature */          if C = slash then do;            wchar(C); C = GET_NUM;            if POWER(NUM_VAL) then BEAT_NOTE = NUM_VAL;          end;          FORMAT = FORMAT & ~(F_COMT \ F_CUTT);        end;      end;      if POWER(NUM_VAL) & VALID then EDIT_RESOLUTION = NUM_VAL; /* Set the edit resolution */      ;      do; /* Set storage device */        I = C - asc.1;        if C = ht then STORAGE_DEVICE = 1;        else if find_device(I) ~= 0 then STORAGE_DEVICE = I;      end;    end;    /* $PAGE */    if C = cr \ C = lf then return (EXIT#); /* RETURN for notation */    else if C = kp.0 | C = kp.comma then do; /* 0 / , = recall/store a sequence */      pcmd(' Name/number of sequence to ');      if C = kp.comma then pstring('store: '); else pstring('recall: ');      BUFF(0) = 0;      I = GET_STR (true,BUFF,127);      if I = cr & BUFF(0) = 0 then do;        call strcpy (BUFF,SEQUENCE_NAME);        pstring(BUFF);        I = GET_STR ("100001",BUFF,127);      end;      if I = del then erase_command;      else do;        BUFF(NUMBERED#) = false; /* Reset numbered sequence flag */        if kp.0 < I & I <= kp.9 then do;          if BUFF(0) = 0 then do;            call strcpy (BUFF,SEQ_FILE_NAME);            call pbyte (BUFF,3,I - kp.1 + asc.0);            BUFF(NUMBERED#) = true; /* Mark numbered sequence */          end;          else BUFF(0) = 0;        end;        if BUFF(0) ~= 0 then do;          if C = kp.comma then COMMAND = STORE#;                          else COMMAND = RECALL#;          return (EXIT#);        end;        else pcmd(' Illegal sequence');      end;    end;    else if C = pf.1 then do; /* PF1 = reverse compiler */      COMMAND = CONVERT#;      return (EXIT#);    end;    else if C = pf.2 then do; /* PF2 for RTP */      COMMAND = PLAY#;      return (EXIT#);    end;    else if C = asc.null then do; /* BREAK for monitor */      COMMAND = MONITOR#;      return (EXIT#);    end;/*    else if DEBUG & C = ctrl.e then ERROR_CHECK = ~ERROR_CHECK;    else if DEBUG & C = ctrl.n then call print_nah_area;    else if DEBUG & C = ctrl.d then print_edit;    else if DEBUG & C = ctrl.l then print_list_indices;*/    else if C = kp.1   then return (SCORE#);   /* Activate score menu */    else if C = kp.2   then return (PAGE#);    /* Activate page menu */    else if C = kp.3   then return (KEYPAD#);  /* Activate keypad menu */    else if C = kp.dot then return (PART#);    /* Activate part menu */    else if C = asc.refresh then return (MAIN#); /* Refresh main menu *//*  else if C = cur.up   & ROW = 12 then ROW = 10;   */    else if C = cur.up   & ROW > 12 then do;   /* Move up */      ROW = ROW - 1; if ROW = 14 \ ROW = 20 then ROW = ROW - 1;    end;/*  else if C = cur.down & ROW = 10 then ROW = 12; */    else if C = cur.down & ROW < 21 then do;   /* Move down */      ROW = ROW + 1; if ROW = 14 \ ROW = 20 then ROW = ROW + 1;    end;/*    else if C = cur.right then COL = 70;    else if C = cur.left  then COL = 64;*/  end;end MAIN_MENU;/* $SubTitle Menu System */MENU_SYSTEM:procedure returns (fixed) public swap; /* Handles the menu routines */  dcl MODE fixed;  BUFF_BASE = CORE_ORIGIN;          /* Allocate a buffer to hold a part and instrument abbreviation */  CORE_BASE = BUFF_BASE + 16 + 18;  /* Must change if Part def changed - this is dangerous */  call LOAD_PRESETS (false); /* Load presets into core from sequence in xmem */  call LOAD_MAIN_VECTOR (MAIN_BASE); /* Load main named variables */  PART = LOAD_LIST_INDICES; /* Load list indices from sequence directly (return 1st selected part) */  if NEW_SEQUENCE then do;    /* Any settings that are not stored with the sequence but need an initial       value for every new sequence should be set here.       This is here because it requires a LOAD and MENU always gets       called once at least. */    START_MEAS   = 1;    MAIN_MODE    = DISPLAY#;    RESET_EDITOR = true;    EDIT_FONT    = F_STANDARD#;    EXTENDED     = false;    LIBRARY      = false;    NEW_SEQUENCE = false;  end;  if STARTUP_ARG ~= 0 then do;    COMMAND = START#;    call INITIALIZE_TERMINAL; /* In case we're printing to a Dot Matrix */    if      STARTUP_ARG = asc.p then MAIN_MODE = PRINT#;    else if STARTUP_ARG = asc.e then MAIN_MODE = EXTRACT#;    else if STARTUP_ARG = -1    then COMMAND = MONITOR#;    else do;       STARTUP_ARG = 0;       call ERROR (ERR_BADARG);    end;    STARTUP_ARG = -1;    MODE = EXIT#;  end;  else do;    COMMAND = START#;    MODE    = MENU_MODE;  end;  do while MODE ~= EXIT#;    MENU_MODE = MODE;    call INITIALIZE_TERMINAL;    do case MODE;      MODE = MAIN_MENU;      do;        call DEFAULTS_TO_BUFF; /* Load holding buffer with defaults */        MODE = SCORE_MENU;        call CLEAR_BUFF; /* Delete unused edit list left in holding buffer */      end;      MODE = PART_MENU;      MODE = PAGE_MENU;      MODE = KEYPAD_MENU;    end;  end;  call DUMP_MAIN_VECTOR (MAIN_BASE);  /* Dumps named variables into the main memory */  call DUMP_PRESETS;                  /* Dumps presets */  call DUMP_LIST_INDICES;             /* Dumps edit record list indices */  clear_all;                          /* Clear the screen */  CLOCK(0) = 0;  CLOCK(1) = 0;  TIME_XOFFED(0) = 0;  TIME_XOFFED(1) = 0;  return (COMMAND);                   /* Return to main driver */end MENU_SYSTEM;end MENURTNS;