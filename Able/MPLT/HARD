module HARD;/* Insert all necessary Operating System literals explicitly */insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:plotlib';insert ':-xpl:catswap';insert ':-xpl:strings';insert 'lits';insert 'hdcl';dcl CATCH_PS_ERRORS  boolean external;dcl PS_ERROR_PRESENT boolean external;dcl ERROR procedure (fixed array) external;dcl d40pc lit '#ps_wchar';/* Module global declarations */dcl MAIN_MODE          fixed external;dcl OVLY_BASE fixed external;  OVLY_BASE = 10;dcl OVLY_FPOS fixed;dcl OVLY_PAGE fixed;dcl OVLY_PS   boolean;dcl SCAN      boolean;dcl CARRY     boolean;dcl MOVE_DOWN boolean;dcl X_ALIGN   fixed;dcl Y_ALIGN   fixed;dcl SYSTEMS   fixed;dcl LEFT#     lit '0',    CENTER#   lit '1',    RIGHT#    lit '2',    TOP#      lit '0',    BOTTOM#   lit '2';dcl FINISH_LINE lit 'if CARRY then call SHOW_LINE('''')';dcl CORE_ORIGIN fixed;  CORE_ORIGIN = core(C#CONTAB + C#VSTART) +                core(C#CONTAB + C#VLNGTH) +                core(C#CONTAB + C#STKLEN);dcl CORE_BASE fixed;  CORE_BASE   = CORE_ORIGIN;when d03int then begin;  insert 'io_timer';end;begin;NUM_TO_STR:procedure (BUFF,X) public swap9; /* Converts a number to a string */  dcl BUFF  fixed array,  /* String array */      X     fixed,        /* Number */      (D,I) fixed;  D = 10000; do while D > X; D = D/10; end; BUFF(0) = 0;  if X = 0 then do; BUFF(0) = 1; BUFF(1) = 48; end;  else do while D > 0;    I = X / D;    call pbyte(BUFF,BUFF(0),I+48);    X = X mod D; D = D/10; BUFF(0) = BUFF(0) + 1;  end;end NUM_TO_STR;STR_TO_NUM:procedure (BUFF) returns (fixed) public;  dcl BUFF  fixed array,  /* String array */      (C,X) fixed;        /* Char, Number */  X = 0;  do C = 0 to BUFF(0)-1;    X = X * 10;    X = X + (byte(BUFF,C) - asc.0);  end;  return X;end STR_TO_NUM;/* D40 driver primitives */#HPNUM:procedure (X) public;  dcl (X,M,N) fixed,      SDIG    boolean;  call d40pc (32);  if X < 0 then do;    call d40pc (45);    X = -X;  end;  M = 10000; SDIG = false;  do while M > 0;    N = X / M;    X = X - N*M;    M = M / 10;    if N ~= 0 \ SDIG \ M = 0 then do;      SDIG = true;      call d40pc (48+N);    end;  end;end #HPNUM;#HONUM:procedure (X) public;  dcl (X,I) fixed;  X = rot(X,10);  do I = 1 to 3;    call d40pc (48+(X & 7));    X = rot(X,3);  end;end #HONUM;#HHNUM:procedure (X) public;  dcl (X,B,I) fixed;  X = rot(X,4);  do I = 1 to 4;    B = X & MASK4;    if B < 10 then call d40pc (asc.0 + B);              else call d40pc (asc.a + B - 10);    X = rot(X,4);  end;end #HHNUM;#HSTRING:procedure (STR) public;  dcl STR fixed array,      I   fixed;  do I = 0 to STR(0)-1;    call d40pc (byte(STR,I));  end;end #HSTRING;#HSTRINGR:procedure (STR) public;  dcl STR fixed array,      I   fixed;  do I = 0 to STR(0)-1;    call d40pc (byte(STR,I));  end;  hcr;end #HSTRINGR;#HSTRCHAR:procedure (C) public;  dcl C fixed;  if C < sp \ C > del then do;    call d40pc (bsl); honum(C);  end;  else do;    if C = lparen \ C = rparen \ C = bsl then call d40pc (bsl);    call d40pc (C);  end;end #HSTRCHAR;#HSTROBJ:procedure (STR) public;  dcl STR   fixed array,      (C,I) fixed;  call d40pc (sp);  call d40pc (lparen);  do I = 0 to STR(0)-1;    hstrchar(byte(STR,I));  end;  call d40pc (rparen);end #HSTROBJ;USER_FILE_LOOKUP:procedure (FILE_NAME) returns (boolean);  dcl FILE_NAME fixed array;  call set_catbuf (CORE_BASE,0);  if locate (FILE_NAME,1) then return (true);  return locate (FILE_NAME,0);end USER_FILE_LOOKUP;CLOSE_PS_JOB:procedure public swap;  dcl C fixed;/*  if MAIN_MODE ~= TEST# then  */hchar(ctrl.d);        /* Send EOF */  call ps_flush; /* Wait until last char is sent out to printer *//*  if MAIN_MODE = TEST# then return;*/ /* ***** */  C = ps_rchar;  do while C ~= ctrl.d; /* This is probably unecessary */    C = ps_rchar;  end;  CATCH_PS_ERRORS = false;end CLOSE_PS_JOB;CLEAR_LASER_PRINTER:procedure public swap;  call CLOSE_PS_JOB;  call ps_disable; /* Turn off D40 interrupts */end CLEAR_LASER_PRINTER;READ_PS_MESSAGE:procedure (PATTERN) returns (boolean) public;  dcl PATTERN fixed array,      (C,I)   fixed;  if MAIN_MODE = TEST# then return (true);  call ps_flush; /* Wait for any chars to be sent */  I = 0;  do forever;    C = ps_rmchar;    if C = -1 then return (false); /* Time out */    if C = byte(PATTERN,I) then I = I + 1;                           else I = 0;    if I = PATTERN(0) then return (true);  end;end READ_PS_MESSAGE;CHECK_PS_ERRORS:procedure public;  dcl C fixed;  if ps_midle | ~CATCH_PS_ERRORS then return;  C = ps_rmchar;  do while C ~= -1;    wchar(C);    C = ps_rmchar;  end;  flush_term;  PS_ERROR_PRESENT = true;end CHECK_PS_ERRORS;LOAD_OVERLAY_FILE:procedure public swap;  dcl (I,W)   fixed,      SECT    fixed,      WORD    fixed,      (LS,LW) fixed,      L       fixed,      REC(3)  fixed;pstringr('  In load'); flush_term;  if ~USER_FILE_LOOKUP ('PAGE') then call ERROR ('No overlay file');pstringr('  After lookup'); flush_term;  REC(0) = OVLY_BASE; /* Sector */  REC(1) = 0;       /* Word */  REC(2) = 0;       /* Length in sectors */  REC(3) = F#WORDS; /* Length mod 256 (or length in words if above is 0) */  call extread (F#MS_SECTOR,F#LS_SECTOR,REC);pstringr('  After extread'); flush_term;  SECT = OVLY_BASE;  WORD = 0;  I    = F#WORDS;  do while I igt 0;    LS = SECT; LW = WORD;    write(SECT$) = SECT;    write(WORD$) = WORD;    write(NOP) = read(DATI$);    I = I - 1;    L = 0; W = 256;    do while (W & UBYTE) ~= 0;      W = read(DATI$);      I = I - 1;      L = L + 2;    end;    SECT = read(SECT$);    WORD = read(WORD$);    write(SECT$) = LS;    write(WORD$) = LW;    write(DATA$) = L;  end;pstringr('  After convert'); flush_term;  write(SECT$) = SECT;  write(WORD$) = WORD;  write(DATA$) = 0;end LOAD_OVERLAY_FILE;/* Some string processing routines (modeled after C):..       TOUPPER (WORD):  Converts WORD to uppercase..              Returns:  The uppercased word..       TOLOWER (WORD):  Converts WORD to lowercase..              Returns:  The lowercased word..       UPPER (S)     :  Converts string S to uppercase..              Returns:  Pointer to S..       LOWER (S)     :  Converts string S to lowercase..              Returns:  Pointer to S..       STRLEN (S)    :  Determine length of string S..              Returns:  Character length of string S..       STRCMP (S, T) :  Compares strings S with string T..              Returns:  0 if S = T, <0 if S < T, >0 if S > T. STRNCMP (S, T, I, J):  Compares N chars of string T (from I to J) with string S..              Returns:  0 if S = T, <0 if S < T, >0 if S > T.       STRCPY (S, T) :  Copy string T to string S..              Returns:  Pointer to S.. STRNCPY (S, T, I, J):  Copy N chars from string T (from I to J) to string S..              Returns:  Pointer to S..       STRCAT (S, T) :  Concatenate string T to the end of string S..              Returns:  Pointer to S..    STRNCAT (S, T, P):  Insert string T at position P of string S..              Returns:  Pointer to S..      INDEX (S, T, P):  Find position of string T in string S; start at position P..              Returns:  Position of string T in string S or -1 if not found..     STRSPN (S, T, P):  Find first occurrence of any char of string T in string S; start at pos P..              Returns:  Position of char from string T in string S or -1 if none found..    STRCSPN (S, T, P):  Find first occurrence of any char not of string T in string S; start at pos P..              Returns:  Position of char not from string T in string S or -1 if none found..    STRNTIN (S, P, Q):  Initializes token scanner w/string S.  Start at position P, stop at position Q..       STRTIN (S)    :  Initializes token scanner w/string S..       STRTOK (S, T) :  Extract next token S (delimited by chars in T) from STRTOKIN string..              Returns:  Pointer to S..       COMPARE (S, T):  Compares strings S with string T ignoring case..              Returns:  TRUE if S = T, FALSE otherwise*/GET_LINE:procedure (LINE) returns (boolean);  dcl LINE fixed array;  dcl L    fixed;  write(SECT$) = OVLY_BASE + shr(OVLY_FPOS,8);  write(WORD$) = OVLY_FPOS;  L = read(DATA$);  if L = 0 then return FALSE;  L = (L+1)/2+1;  call import (OVLY_BASE,OVLY_FPOS,LINE,L);  OVLY_FPOS = OVLY_FPOS + L;  /* Clean line */  do while LINE(0) > 0 & byte(LINE,LINE(0)-1) = 0;    LINE(0) = LINE(0) - 1;  end;  return TRUE;end GET_LINE;REST_OF_LINE:procedure (TOKEN);  dcl TOKEN fixed array;  dcl I     fixed;  call strtok(TOKEN,'');  I = index(TOKEN,'>',0);  if I > -1 then TOKEN(0) = I;end REST_OF_LINE;SHOW_LINE:procedure (LINE);  dcl LINE fixed array;pstring('     in show line <');pstring(LINE);pstring('> len = ');pnum(LINE(0),0);crlf;  if OVLY_PS then do;    if LINE(0) > 0 then hstringr(LINE);  end;  else do;    if ~CARRY then hstringr('mark');    if LINE(0) > 0 then do;      if ~CARRY then hstringr('cur_x cur_y moveto');      if byte(LINE,LINE(0)-1) = bsl then do;        CARRY = true;        LINE(0) = LINE(0) - 1;      end;      else CARRY = false;      hchar(lparen); hstring(LINE); hchar(rparen);      do case X_ALIGN;        ;        hstring(' center');        hstring(' right');      end;      if ~CARRY then do case Y_ALIGN;        hstring(' top');        ;        ;      end;      hcr;    end;    else CARRY = false;    if ~CARRY then hstringr('showline /cur_y cur_y fontsize sub def');    if Y_ALIGN ~= TOP# then MOVE_DOWN = TRUE;  end;end SHOW_LINE;COMMAND_LINE:procedure (LINE);  dcl LINE      fixed array;  dcl TOKEN(32) fixed;  dcl X_FLAG    boolean;  dcl RETURN_ON_COMMENT lit 'if byte(TOKEN,0) = asc.gt then return';  OVLY_PS = FALSE;  call STRNTIN(LINE, 1, LINE(0));  do while core(STRTOK(TOKEN,' ')) ~= 0; /* This may not need to loop */    RETURN_ON_COMMENT;    if COMPARE(TOKEN,'page') then do;      FINISH_LINE;      call STRTOK(TOKEN,' ');      if      COMPARE(TOKEN,'setup') then SCAN = (OVLY_PAGE = 0);      else if COMPARE(TOKEN,'1')     then SCAN = (OVLY_PAGE = 1);      else if COMPARE(TOKEN,'even')  then SCAN = ((OVLY_PAGE & MASK1) = 0);      else if COMPARE(TOKEN,'odd')   then SCAN = ((OVLY_PAGE & MASK1) = 1);      else if COMPARE(TOKEN,'all')   then SCAN = (OVLY_PAGE > 0);    end;    if ~SCAN then return;    if COMPARE(TOKEN,'postscript') then do;      FINISH_LINE;      OVLY_PS = TRUE;    end;    else if COMPARE(TOKEN,'font') then do;      hchar(slash);      hstring(loc(STRTOK(TOKEN,' ')));      hstring(' findfont ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      if MOVE_DOWN then hstring(' 1'); else hstring(' 0');      hstring(' setfontsize');       if CARRY then hstring(' dup');      hstringr(' setfont');    end;    else if COMPARE(TOKEN,'move') then do;      FINISH_LINE;      X_FLAG = TRUE;      do while core(STRTOK(TOKEN,' ')) ~= 0;        RETURN_ON_COMMENT;        if compare(TOKEN,'auto') then do;          if X_FLAG then do case X_ALIGN;            hstring('0 ');            /* Left */            hstring('clip_w 2 div '); /* Center */            hstring('clip_w ');       /* Right */          end;          else do case Y_ALIGN;            hstring('clip_h '); /* Top */            hstring('clip_h 2 div '); /* Center */            hstring('0 '); /* Bottom */          end;        end;        else do;          hstring(TOKEN); hchar(sp);        end;        X_FLAG = FALSE; /* First token is x-auto or there is no x-auto */      end;      hstringr('/cur_y exch def /cur_x exch def');      MOVE_DOWN = false;    end;    else if COMPARE(TOKEN,'align') then do;      call STRTOK(TOKEN,' ');      if      COMPARE(TOKEN,'right')  then X_ALIGN = RIGHT#;      else if COMPARE(TOKEN,'center') then X_ALIGN = CENTER#;      else if COMPARE(TOKEN,'left')   then X_ALIGN = LEFT#;      call STRTOK(TOKEN,' ');      if      COMPARE(TOKEN,'top')    then Y_ALIGN = TOP#;      else if COMPARE(TOKEN,'center') then Y_ALIGN = CENTER#;      else if COMPARE(TOKEN,'bottom') then Y_ALIGN = BOTTOM#;    end;    else if COMPARE(TOKEN,'trim') then do;      hstring('/trim_w ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /trim_h exch def def');    end;    else if COMPARE(TOKEN,'trimoff') then do;      hstring('/trim_dx ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /trim_dy exch def def');    end;    else if COMPARE(TOKEN,'image') then do;      hstring('/clip_w ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /clip_h exch def def');    end;    else if COMPARE(TOKEN,'imageoff') then do;      hstring('/clip_dx ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' /clip_dy exch def def');    end;    else if COMPARE(TOKEN,'pageno') then do;      call NUM_TO_STR (TOKEN,OVLY_PAGE);      call pbyte (TOKEN,TOKEN(0),bsl); TOKEN(0) = TOKEN(0) + 1;      call SHOW_LINE (TOKEN);    end;    else if COMPARE(TOKEN,'shift') then do;      FINISH_LINE;      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' translate');    end;    else if COMPARE(TOKEN,'music') then do;      FINISH_LINE;      call STRTOK(TOKEN,' ');      SYSTEMS = STR_TO_NUM(TOKEN);pstring('Systems = ');pnum(SYSTEMS,0); crlf;      hstring('/page_top_mrgn ');      call REST_OF_LINE(TOKEN); hstring(TOKEN);      hstringr(' def');    end;  end;end COMMAND_LINE;SCAN_OVERLAY_FILE:procedure (PAGE) public swap;  dcl PAGE      fixed;  dcl LINE(128) fixed;  dcl SCANNING  boolean;  dcl MORE      boolean;  OVLY_PAGE = PAGE;  SCAN      = TRUE;  SCANNING  = FALSE;  CARRY     = FALSE;  MOVE_DOWN = FALSE;  OVLY_FPOS = 0;  X_ALIGN   = LEFT#;  Y_ALIGN   = TOP#;  MORE = TRUE;  do while MORE;    MORE = GET_LINE(LINE);    if MORE then do;      if byte(LINE,0) = bsl      then call COMMAND_LINE(LINE);      else if SCAN then call SHOW_LINE(LINE);    end;    if ~SCANNING & SCAN then SCANNING = TRUE;    if SCANNING & ~SCAN then MORE = FALSE;  end;pstringr('     Before final finish_line');  FINISH_LINE;end SCAN_OVERLAY_FILE;end;end HARD;