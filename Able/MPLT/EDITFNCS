/* $title Editing Routines *//* Additional Editing Routines */IS_A_SYMBOL:procedure (C) returns (boolean);  dcl C fixed;  if EXTENDED & LIBRARY then if C < "200" then return (true);                                          else;                        else if C >= "200" then return (true);  return (false);end IS_A_SYMBOL;GET_DIRECTION:procedure returns (boolean) swap2;  /* Gets user designated symbol direction and returns a value. (Up = 0, Down = 1) */  dcl C fixed;  transparent_mode; pcmd('Enter Direction ');   /* Prompt the user */  do forever;    C = rchar;                                  /* Get the user designated direction */	if C = 0 then c = cur.up;					// handle break    if C = cur.up   \ C = cur.right then do; erase_command; return (false); end; /* If up or right */    if C = cur.down \ C = cur.left  then do; erase_command; return (true);  end;     /* If down or left */  end;end GET_DIRECTION;GET_STR:procedure (PROMPT,MODE,BUFF,LEN) swap2; /* Get a character string (This could be combined with the one in menu) */  dcl PROMPT  fixed array,      MODE    boolean,     /* Set for all caps */      NOMOD   boolean,     /* No modifications */      BUFF    fixed array, /* Buffer to return string*/      (C,LEN) fixed;       /* Character and maximum length of string */  pstring(PROMPT); BUFF(0) = 0;  do forever;    C = rchar;    if del < C \ C = cr \ c = 0 then return;    else if C = del then do; /* If the character is a delete keystroke */      if BUFF(0) > 0 then do;        if BUFF(0) = 80 then wchar(sp);        else do;          wchar(bs); wchar(sp); wchar(bs); /* Delete the character on the terminal */        end;        BUFF(0) = BUFF(0) - 1;          /* Decrease the number of characters in the string */      end;      else return;    end;    else if sp <= C & BUFF(0) < LEN then do;      if MODE & lower.a <= C & C <= lower.z then C = C - 32; /* If character is lower case, capitalize it */      wchar(C); call pbyte (BUFF,BUFF(0),C);    /* Write it out to the terminal */      BUFF(0) = BUFF(0) + 1;  /* Increase the number of characters in the string */    end;  end;end GET_STR;KEYPAD_REF:procedure swap2; /* Prints the bank settings */  dcl (R,C)  fixed,      LFOFF  fixed,      COM(2) fixed;   /* Symbol or command setting */  LFOFF = LIBRARY; if EXTENDED & LIBRARY then LFOFF = 2;  do R = 0 to 1;    do C = 0 to 3;      pos(22+R,60+C*5);      call LOOKUP_NAME (byte(location(BANK_BASE+LFOFF*24-1),BANK*8+R*4+C),LFOFF,COM);      pstring(COM); /* Print the keypad bank setting */    end;  end;  pos(cmdline,0); /* Position the cursor on the command line */end KEYPAD_REF;GRID:procedure swap2; /* Draw the dividing lines for the keypad bank settings */  dcl I fixed;  viewport (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#);  iwindow  (0,SCREEN_WIDTH#,0,SCREEN_LENGTH#);  if MG600 | MACII then do;    do I = 0 to 2;      imove_to (737,30*I+46); iplot (737+60*4,30*I+46);    end;    do I = 0 to 4;      imove_to (737+60*I,46); iplot (737+60*I,106);    end;  end;  else do; /* vt640 case */    do I = 0 to 2;      imove_to (453,20*I); iplot (605,20*I);    end;    do I = 0 to 4;      imove_to (453+38*I,0); iplot (453+38*I,40);    end;  end;end GRID;UPDATE_VOICE:procedure swap2;  pos(23,7);  do case VOX;    pstring('Lower ');    pstring('Upper ');    pstring('Master');    pstring('Parts ');  end;end UPDATE_VOICE;EDIT_TEXT:procedure (LEV,LAST) swap2;  dcl (LEV,I) fixed, /* Amount of text that needs refreshing (3 levels) */      SFONT   fixed, /* Sample of EDIT_FONT */      LAST    boolean; /* Set if last edit block in measure */  transparent_mode;  if LEV = 0 then do;  /* If LEV = 0, print prompt settings in lower section of display screen */    pos(20,0);  pstring(CLEAR_CUR);    pos(21,0);  pstring('Name:');    pos(22,0);  pstring('Part:');    pos(23,0);  pstring('Voice:');    pos(22,15); pstring('X-Off:');    pos(23,15); pstring('Y-Pos:');    pos(21,28); pstring('Measure:');    pos(22,28); pstring('Block:');    pos(23,28); pstring('Level:');    pos(21,44); pstring('Bank:');    pos(22,44); pstring('Libr:');    pos(23,44); pstring('Font:');    SFONT = -1; /* Force font to print first time */  end;  else if LEV = 1 then do; /* If LEV=1, print some of the status values in the lower section of the screen */    I = NAME_BASE + PART * 18;    pos(21,7); pstring(location(I)); /* Print the instrument name */               do I = core(I) + 1 to 16; wchar(sp); end;    if LAST then do; /* If last edit block, print message */      pos(21,68); pstring('Last Block');    end;    else do;      pos(21,68); pstring('          ');    end;    pos(22,7); pnum(PART+1,0); wchar(sp);   /* Print the part number */    call UPDATE_VOICE;    pos(21,37); pnum(MEASURE_NUMBER,0); wchar(sp); /* Print the measure number */    pos(22,37);    if BLOCK(LEVEL) = 0 then wchar(sp); else pnum(BLOCK(LEVEL),0); wchar(sp); wchar(sp); /* Print the edit block number */    pos(23,37);    if LEVEL = 0 then     pstring('Base ');   /* If not a tuplet level, indicate that it's base level */                 else do; pstring('Tup '); pnum(LEVEL,0); end; /* Print the tuplet level */  end;  else do;                                              /* If any other level (i.e., if movement key ) */    pos(22,22); pnum(XOFF/4,0); wchar(sp); wchar(sp);   /* Print the X offset */    pos(23,22); pnum(CY/3,0);   wchar(sp); wchar(sp);   /* Print the Y position */    pos(21,50); pnum(BANK+1,0);                         /* Print the bank number */    pos(22,50);    do case (shl(EXTENDED,1) \ LIBRARY);      pstring('System');      pstring('User  ');      pstring('EF Sys');      pstring('EF Ext');    end;    pos(23,50);    if EDIT_FONT ~= SFONT then do case EDIT_FONT;      pstring('Standard');      pstring('Italic  ');      pstring('Bold    ');      pstring('Bold Itl');      ;;;      pstring('Typewrit');    end;           SFONT = EDIT_FONT;    pos(21,55);    if TSIZE = 2   then pstring('Big ');                   else pstring('    ');    if BOXTX       then pstring('Box ');                   else pstring('    ');    if AUTO_CENTER then pstring('Ctr');                   else pstring('   ');  end;  erase_command;end EDIT_TEXT;/* $SubTitle Scan_Edit_List */SCAN_EDIT_LIST:procedure (SECT,EDPOS,LEVEL,FINDTUP) swap2; /* Scans edit list for entries at a given edit position */  /*     This procedure searches an edit list for the location of the first entry     at a given complex-edit-position (also known as 'index').     It is passed:          SECT    - the base sector of the edit list          EDPOS   - the target complex-edit-position aggregate (see 'complex-edit-positions')          LEVEL   - the highest level of the search (the editor's current level)          FINDTUP - a flag which causes a search for a tuplet record on the highest level     It returns:          LEN_PTR  - a stack of pointers to the start of the lists at each level                     (this is useful for updating the length field of each list)          SCAN_END - points to the end of the edit list (defined to mean the next available word)          SCAN_PTR - points to the first edit entry at the target edit position                     or, if the target position is not populated, points to the                     first edit entry of the next populated position beyond the                     target position or the end of the list          SCAN_IND - holds the index of the entry to which SCAN_PTR points          SCAN_TUP - Set if a tuplet is found on the highest level of the search,                     (Note: a tuplet is only looked for on highest level if                     FINDTUP is set)  */  dcl      SECT    fixed,      EDPOS   fixed array,      LEVEL   fixed,      FINDTUP boolean,      TEMP(2) fixed, /* Holds returned edit records (1st 3 words) */      LEN     fixed,      (I,L)   fixed,      P       pointer;  /* $page */  LEN_PTR(LEVEL) = null;  /* Top level list origin will remain null if complex_edit_pos not found */  LEN_PTR(0)     = 1;     /* Level 0 list origin is always 1 (see edit-list definition) */  SCAN_TUP       = false; /* Scan tup will be false until we find a tuplet on the highest level */  do L = 0 to LEVEL; /* Scan levels from base to highest */    write(SECT$) = SECT + shr(LEN_PTR(L),8); /* Set xmem to start of current level's list */    write(WORD$) = LEN_PTR(L);    P            = LEN_PTR(L) + 1;           /* P starts at first entry in current list */    SCAN_END     = LEN_PTR(L) + read(DATA$); /* Find end of current list */    I            = 0;                        /* I keeps track of edit index (starts at 0) */    /* Scan edit list until the index we want at this level is found or       exceeded, or we reach the end of the edit list */    do while I ilt EDPOS(L) & P ilt SCAN_END;      write(SECT$) = SECT + shr(P,8); /* Set xmem to current position in list */      write(WORD$) = P;      LEN = GET_EDIT_RECORD (TEMP,false); /* Get the next edit record (return length) */      P   = P + LEN; /* Advance pointer to next edit record */      if rot(TEMP(0),1) then I = I + (TEMP(0) & MASK15); /* If an index spacer, advance index */      /* If we have arrived at the target index for this level and we have         another level to go or we are looking for a tuplet record, then         search the enties at this index for a tuplet */      if I = EDPOS(L) & (L < LEVEL \ FINDTUP) then do;        if P = SCAN_END then return;        /* If we hit the end of the list, we're done */        LEN = GET_EDIT_RECORD (TEMP,false); /* Get the next edit record *//* WAS  do while shr(TEMP(0),8) ~= "177";    * Do while it's not a tuplet */        do while (TEMP(0) & ~MASK7) ~= ("077400" \ shl(VOICE,7)); /* Loop to find tuplet in this voice */          if rot(TEMP(0),1) \ P = SCAN_END then return;  /* If it's an index spacer or we hit the end, return */          P   = P + LEN;                    /* Advance pointer to next edit record */          LEN = GET_EDIT_RECORD (TEMP,false); /* Get the next edit record */        end;        if L = LEVEL then SCAN_TUP = true;  /* Tell the calling proc we found a tuplet */        LEN_PTR(L+1) = P + 2; /* Set the next level's pointer in list pointer stack */      end;    end;  end;  SCAN_PTR = P;  SCAN_IND = I;end SCAN_EDIT_LIST;/* $SubTitle  Display the Edit List */LIST_DISPLAY:procedure swap2;/* Displays a list of all the edit items in a given edit block */ /* Optimize!!!!!!!!!!! */  dcl P            pointer,/* Points to edit list */      LIST_END     boolean,/* If at end of list */      COM(2)       fixed,  /* Symbol name or command */      (ROW,COL)    fixed,      (C,I,J,VP,S) fixed;  transparent_mode; pos(20,0); pstring(CLEAR_CUR); /* Clear lower four lines */  VP = PART; if MASTER_VOICE then VP = MASTER_PART; /* If master voice, then point to master edit list */  if LIST_INDEX(VP) = 0 then return;                /* If there is nothing in the list, return */  S = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(VP)); /* Find the starting sector for the edit list */  call SCAN_EDIT_LIST (S,EDIT_POS,LEVEL,false); /* Scan the edit list to find the edit position entry */  if SCAN_IND > EDIT_POS(LEVEL) \ SCAN_PTR = SCAN_END then return; /* If no entry exists, then return*/  ROW          = 21;  COL          = 0;  RECORDS      = 0;            /* Initialize number of records */  LIST_END     = false;  P            = SCAN_PTR;  write(SECT$) = S + shr(P,8); /* Set external memory to sector base and set the word pointer */  write(WORD$) = P;              /* $PAGE */  do forever;                             /* Do for all entries at this position */    if P = SCAN_END then LIST_END = true; /* If at the end of the edit list, set the end of list flag */    else do;      write(SECT$) = S + shr(P,8);        /* Set the external memory to the sector base and the word pointer*/      write(WORD$) = P;                         P = P + GET_EDIT_RECORD (BUFF,true); /* Get the next edit record and put it into buffer*/    end;    if rot(BUFF(0),1) \ LIST_END \ RECORDS = 9 then do; /* If an index spacer or at the end of the edit list, then leave */      pos(20,0);      return;    end;    RECORDS = RECORDS + 1;                /* Increase the number of records accounted for*/    C       = shr(BUFF(0),8);             /* Get the record type */    pos(ROW,COL);    if C = "101" then pstring('CHAR ');    else if (C & "371") = "141" then pstring('TEXT ');    else if C = "100" \ (C & "371") = "140" then do case shr(BUFF(1),12) & MASK2;      pstring('STDR ');      pstring('ITAL ');      pstring('BOLD ');      pstring('BDIT ');    end;    else do;      call LOOKUP_NAME (C,0,COM);             /* Look up the symbol name given the code */      pstring(COM); pos(ROW,COL+6);    end;/* WORK here for Auxilliary fonts !!! */    if C = "100" \ C = "101" then do;         /* If a character or symbol record*/      J = BUFF(0) & LBYTE;                    /* Get the character */      if sp < J & J < del then wchar(J);      /* If an ascii character, print it */      else if J > del then do;                /* If a symbol */        call LOOKUP_NAME (J,shr(BUFF(1),14),COM); pstring(COM); /* Lookup the symbol name or command given the code */      end;    end;    else if (C & "370") = "140" then do;      /* If a character or a symbol string */      J = ((BUFF(0) & LBYTE) - 2) * 2 - 1;    /* Calculate the number of characters in string */      if J > 7 then J = 7;                    /* We only have room for 8 characters on the screen */      do I = 0 to J;        J = byte(location(addr(BUFF(1))),I);  /* Get the character */        if sp <= J & J < del then wchar(J);        else if J > 0 then wchar(star);       /* Non-printing chars (expt NULL) get $ */      end;    end;    else if C < "140" \ C = "177" then do;    /* If a command or a tuplet sublist */      if ~MASTER_VOICE then do;                /* If not in master */        if shr(BUFF(0),7) then wchar(asc.u); else wchar(asc.l); /* Follow commands by a U or L for upper or lower voice */      end;      pos(ROW,COL+9); pnum(BUFF(0) & MASK7,0); /* Print the DATA8 and DATA16 words */      if C >= "100" then do;               /* If a two or more word record */        pos(ROW,COL+15); pnum(shr(BUFF(1),8),0);  /* Print the DATA8 and DATA16 data */        pos(ROW,COL+21); pnum(BUFF(1) & LBYTE,0);      end;    end;    else if C = "170" then do;    /* If a command or a tuplet sublist */      pos(ROW,COL+9); BUFF(1) = 12;      pstring(loc(addr(BUFF(1))));    end;    ROW = ROW + 1;    if ROW = 24 then do;      ROW = 21; COL = COL + 30;    end;  end;end LIST_DISPLAY;/* $Subtitle Update Vectors */UPDATE_VECTORS:procedure (PART,LEN) swap2; /* Advance edit pointers of main and plot state vectors by length */ /* This is a little kludgy */ /* Note: These edit pointers are always pointing beyond the current update position */  dcl PART fixed,    /* Current part */      LEN  fixed,    /* Length of edit item */      P    pointer;  if PART = MASTER_PART then do;      /* If master part */    P = MAIN_BASE;    if core(P+11) ~= null then do;          core(P+11) = core(P+11) + LEN;  /* Update the master edit pointer */      core(P+12) = core(P+12) + LEN;  /* Update the master edit end */    end;    P = PLOT_MAIN_BASE;    if core(P+11) ~= null then do;      core(P+11) = core(P+11) + LEN;  /* Update the master edit pointer */      core(P+12) = core(P+12) + LEN;  /* Update the master edit end */    end;  end;  else do;    P = PART_BASE + PART * 16;    if core(P+9) ~= null then do;           core(P+9)  = core(P+9)  + LEN;  /* Update edit pointer */      core(P+10) = core(P+10) + LEN;  /* Update edit end */    end;    P = PLOT_PART_BASE + PART * 16;    if core(P+9) ~= null then do;      core(P+9)  = core(P+9)  + LEN;  /* Update edit pointer */      core(P+10) = core(P+10) + LEN;  /* Update edit end */    end;  end;end UPDATE_VECTORS;/* $Subtitle Insert Record */INS_RECORD:procedure (PRT,LEN,BUFF) swap2; /* Inserts an edit record into external memory */ /* This is still kind of a mess */  dcl PRT        boolean,     /* If a master voice */      LEN        fixed,       /* Length of an edit item */      BUFF       fixed array, /* Record data */      SPACER(0)  fixed,      (P,SPTR)   pointer,    /* Pointers to edit list */      SLEN       fixed,      /* Length of an edit item*/      PRE_IND    fixed,      /* Pre-edit list index */      PST_IND    fixed,      /* Post-edit list index */      (I,IND,L,S) fixed;  if LIST_INDEX(PRT) = 0 then do; /* If list does not exist yet, create one */    if LEVEL > 0 then return;    /* Don't create a list since complex pos won't be there */    LISTS = LISTS + 1;           /* Increase the number of lists */    S     = FIND_LIST_SECT (EDIT_BASE,LISTS); /* Find the starting sector of this edit list */    call XMEM_SECT_SLIDE (S+1,1); /* Create a 1 sec empty edit list (actual copy does nothing) */    LIST_INDEX(PRT) = LISTS;    write(SECT$)    = S;    write(DATI$)    = 1;    write(DATI$)    = 1;    call DUMP_LIST_INDICES;  end;  else S = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(PRT)); /* Find the staring sector of the edit list */  call SCAN_EDIT_LIST (S,EDIT_POS,LEVEL,false);  if LEN_PTR(LEVEL) = null then return; /* This means that the complex_edit_pos was not there */  P       = SCAN_PTR; /* These are passed back from Scan_Edit_List */  I       = SCAN_IND; /* LenPtr is also set */  PRE_IND = 0;  PST_IND = 0;  SPTR    = P;    /* Pointer to edit position in the edit list */  SLEN    = LEN;  /* Set the edit position entry length */  if I igt EDIT_POS(LEVEL) then do;  /* If scanning index is greater than the edit postion in the edit list*/    P            = P - 1;    write(SECT$) = S + shr(P,8);     /* Determine the starting sector */    write(WORD$) = P;                /* Determine the word offset */    PRE_IND      = (read(DATA$) & MASK15) - (I - EDIT_POS(LEVEL));  /* Find the pre-edit list index */    PST_IND      = I - EDIT_POS(LEVEL); /* Find the post-edit list index */    SLEN         = LEN + 1;  end;  else if I ilt EDIT_POS(LEVEL) then do; /* If the scanning index is less than the edit position */    PRE_IND = EDIT_POS(LEVEL) - I;       /* Find the pre-edit list index */    SLEN    = LEN + 1;  end;  call XMEM_WORD_SLIDE (S,SPTR,SLEN);    /* Slide the contents of external memory up to make room for insertion */  write(SECT$) = S + shr(P,8);           /* Find starting sector */  write(WORD$) = P;                      /* Find word offset */  if PRE_IND ~= 0 then write(DATI$) = COM_BIT \ PRE_IND; /* If a pre-edit list index exists then write it out as an index spacer */  do I = 0 to LEN-1;       /* Do for the length of the edit item */    write(DATI$) = BUFF(I); /* Write out the data */  end;  if PST_IND ~= 0 then write(DATI$) = COM_BIT \ PST_IND;   /* If a post-edit list index, write it out as an index spacer */  do I = 1 to LEVEL;                       /* Do for all levels */    write(SECT$) = S + shr(LEN_PTR(I),8);  /* Set the starting sector */    write(WORD$) = LEN_PTR(I);             /* Set the word offset within the sector */    write(DATA$) = read(DATA$) + SLEN;     /* Write out the data */  end;  call UPDATE_VECTORS (PRT,SLEN);           /* Update the edit list pointers and indices in memory */end INS_RECORD;INSERT_RECORD:procedure (MVOX,LEN,BUFF) swap2; /* Inserts an edit record into external memory */  dcl MVOX boolean,      LEN  fixed,      BUFF fixed array,      I    fixed;  if MVOX then call INS_RECORD (MASTER_PART,LEN,BUFF);  else if ALL_PARTS then do I = 0 to STAVES;    call INS_RECORD (DISPLAY(I),LEN,BUFF);  end;  else call INS_RECORD (PART,LEN,BUFF);end INSERT_RECORD;/* $Subtitle  Select a Record */SELECT_RECORD:procedure returns (fixed) swap2; /* Returns a number pointing to the selected edit record */  dcl (ROW,COL) fixed,      (C,R)     fixed;  transparent_mode;  ROW = 21;  COL = 0;  R   = 1;  do forever;    pos(ROW,COL);    /* Position the cursor at the specified location */    C = rchar;       /* Get the cursor keystroke */    if      C = del then return (R);    /* If delete, return the number pointing to the selected edit record */    else if C = cr  then return (0);    /* If carriage return, return a null number meaning nothing was selected */    else if C = 0   then return (0);    // break    else if C = cur.up    & ROW > 21 then do;      ROW = ROW - 1;                    /* Move up a row to the previous row */      R   = R   - 1;    end;    else if C = cur.down  & ROW < 23 & R < RECORDS then do;      ROW = ROW + 1;                    /* Move down a row to the next record */      R   = R   + 1;    end;    else if C = cur.right & COL < 60 & R + 3 <= RECORDS then do;      COL = COL + 30;                   /* Move right to the next record */      R   = R   + 3;    end;    else if C = cur.left  & COL > 0 then do;      COL = COL - 30;      R   = R   - 3;                    /* Move left to the previous record */    end;  end;end SELECT_RECORD;/* $SubTitle Delete a Record */DELETE_RECORD:procedure (DELETE_ALL) swap2;  /* Deletes an edit record from external memory */  dcl (P,Q)      pointer,      (I,R,S)    fixed,      VP         fixed,      LEN        fixed,  /* Length of edit item */      ADV        fixed,  /* Edit position advance */      DELETE_ALL boolean; /* Set if all entries at this position are to go */  VP = PART; if MASTER_VOICE then VP = MASTER_PART;  /* If master voice then point to master edit list */  if LIST_INDEX(VP) = 0 then return;                 /* If nothing in the edit list, return */  S = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(VP));     /* Find the starting sector of the edit list */  call SCAN_EDIT_LIST (S,EDIT_POS,LEVEL,false);         /* Scan the edit list to find the location of the entries in the edit list */  if SCAN_IND > EDIT_POS(LEVEL) \ SCAN_PTR = SCAN_END then return; /* If edit position not found or at end of edit list, return */  P = SCAN_PTR;                                      /* Set the edit list pointer */  if ~DELETE_ALL & EDIT_MODE = LIST_DISPLAY# & RECORDS > 1 then do; /* If list display and more than one record in the list */    R = SELECT_RECORD;                               /* Ask the user which record to delete */    if R = 0 then return;                            /* If the user aborts, return */  end;  else DELETE_ALL = true;                            /* Otherwise, delete all entries */  vector_mode; data_level(1);                        /* Set data level to erase pixels */  if DELETE_ALL then do;                             /* If deleting all edit entries in the edit list */    ADV = 0;                                         /* Initialize the edit position advance */    if P - 1 igt LEN_PTR(LEVEL) then P = P - 1;      /* If the edit list pointer is greater than length of the edit list */    write(SECT$) = S + shr(P,8);                     /* Then point to the beginning of the edit item */    write(WORD$) = P;                                /* and set external memory to sector base and set word pointer */    Q = P + GET_EDIT_RECORD (BUFF,true);             /* Get the end of the edit record */    if rot(BUFF(0),1) then do;                      /* If an index spacer */      ADV = BUFF(0) & MASK15;                       /* Set the edit position advance */      Q = Q + GET_EDIT_RECORD (BUFF,true);          /* Get the next edit record */    end;    call PLOT_RECORD (BUFF,PP,XBASE);               /* Erase the edit record from the screen */    do while ~rot(BUFF(0),1) & Q ~= SCAN_END;       /* If not an index spacer and not at the end of the edit list */      Q = Q + GET_EDIT_RECORD (BUFF,true);          /* Get next record */      if rot(BUFF(0),1) then ADV = ADV + (BUFF(0) & MASK15); /* If an edit list index spacer, sum total of edit position advances */      else call PLOT_RECORD (BUFF,PP,XBASE);        /* Otherwise, erase it from the screen */    end;                                   /* If we are deleting the entire list */    if Q = SCAN_END then do;       /* If at the end of the edit list */      if P = 2 then do;            /* If pointing to the beginning of the list */        call DELETE_EDIT (VP);     /* Delete edit list of this part */        call DUMP_LIST_INDICES;    /* Update the edit list indices  */      end;      else do;                     /* otherwise, delete the edit list records */        LEN = Q - P;               /* Determine how long the chunk is we are deleting */        call XMEM_WORD_SLIDE (S,P,-LEN); /* Slide the external memory down in order to delete the record(s)*/      end;    end;    else do;      LEN = (Q - P) - 1;                /* Determine the total length of edit items we are deleting */      call XMEM_WORD_SLIDE (S,P,-LEN);  /* Slide the external memory down in order to delete */      write(SECT$) = S + shr(P,8);      /* Update the starting sector base*/      write(WORD$) = P;                 /* Update the word offset */      write(DATA$) = SIGN_BIT \ ADV;    /* Replace new index spacer value */    end;  end;  /* $PAGE */  else do;                              /* Delete only one edit record from several */    write(SECT$) = S + shr(P,8);        /* Find the starting sector */    write(WORD$) = P;                   /* Find the word offset */    do while R > 1;                     /* Locate record to delete */      P = P + GET_EDIT_RECORD (BUFF,false);  /* Get the next edit record in the edit list */      R = R - 1;    end;    Q = P + GET_EDIT_RECORD (BUFF,true);/* Get the next edit record */    call PLOT_RECORD (BUFF,PP,XBASE);   /* Erase the edit record from the screen */    LEN = Q - P;                        /* Determine the length of the edit item */    call XMEM_WORD_SLIDE (S,P,-LEN);    /* Slide the contents of external memory down for deletion */  end;  call EDIT_MARK (XBASE);               /* Erase the edit mark */  data_level(0);  if LIST_INDEX(VP) ~= 0 then do;       /* If there is something left in the list */    do I = 1 to LEVEL;                  /* Do for all levels beyond the base*/      write(SECT$) = S + shr(LEN_PTR(I),8);   /* Update the length fields */      write(WORD$) = LEN_PTR(I);               /* Find the word offset */      write(DATA$) = read(DATA$) - LEN;        /* Update the length of the sublists */    end;    call UPDATE_VECTORS (VP,-LEN);             /* Update state vectors */  end;end DELETE_RECORD;/* $subtitle SLIDE_EDIT_LIST */SLIDE_EDIT_LIST:procedure (VP,SP,FP,INSR) swap2;  /* Part to edit is VP (could be MASTER), and must exist.     SP must be > 0     If  INSR then insert space FP - SP edit blocks at SP.     If ~INSR then remove edit blocks from SP to FP. */  dcl VP   fixed,      SP   fixed,      FP   fixed,      INSR boolean;  dcl (P,Q)      pointer,      PS(3)      fixed,      S          fixed,      LEN        fixed,      ADV        fixed;  S = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(VP));     /* Find the starting sector of the edit list */  PS(0) = SP;  call SCAN_EDIT_LIST (S,PS,0,false);  if SCAN_PTR = SCAN_END then return;  P = SCAN_PTR - 1;  if P = LEN_PTR(0) then call SYSERROR('Slide from pos 0');  ADV = 0;  write(SECT$) = S + shr(P,8);  write(WORD$) = P;  ADV = read(DATA$) & MASK15;  if INSR then do;    ADV = ADV + (FP - SP);    write(DATA$) = SIGN_BIT | ADV;    return;  end;  /* All else is for the remove case */  ADV   = ADV - (SCAN_IND - SP);  PS(0) = FP;  call SCAN_EDIT_LIST (S,PS,0,false);  Q = SCAN_PTR; /* Q now points to 1st word to save */  ADV = ADV + (SCAN_IND - FP);  if Q = SCAN_END then do;       /* If at the end of the edit list */    if P = LEN_PTR(0) + 1 then do;            /* If pointing to the beginning of the list */      call DELETE_EDIT (VP);     /* Delete edit list of this part */      call DUMP_LIST_INDICES;    /* Update the edit list indices  */    end;    else do;                     /* otherwise, delete the edit list records */      LEN = Q - P;               /* Determine how long the chunk is we are deleting */      call XMEM_WORD_SLIDE (S,P,-LEN); /* Slide the external memory down in order to delete the record(s)*/    end;  end;  else do;    LEN = (Q - P) - 1;    call XMEM_WORD_SLIDE (S,P+1,-LEN);    write(SECT$) = S + shr(P,8);    write(WORD$) = P;    write(DATA$) = SIGN_BIT \ ADV;    /* Replace new index spacer value */  end;end SLIDE_EDIT_LIST;/* $Subtitle Get a Numerical Value */GET_NUM:procedure swap2; /* Get a Number */  dcl (C,CNT,NUM,MINUS) fixed;  NUM = 0; CNT = 0; MINUS = false;  do forever;    C = rchar;                /* Get a character from the terminal */    if C = asc.min & ~MINUS & CNT = 0 then do;  /* If a leading minus sign */      wchar(asc.min); MINUS = true;             /* Output it to the terminal */    end;    else if asc.0 <= C & C <= asc.9 then do;    /* If a valid digit */      wchar(C); NUM = NUM * 10 + (C - asc.0); CNT = CNT + 1; /* Print it and update the numerical value */    end;    else if C = del & (CNT > 0 \ MINUS) then do; /* If delete or a minus sign */      wchar(bs); wchar(sp); wchar(bs);           /* Delete it */      if CNT = 0 then MINUS = false;      else do;        NUM = NUM/10; CNT = CNT - 1;             /* Update the numerical value */      end;    end;    else if C = cr \ C = slash \ C >= del \ C = 0 then do; /* Exit on slash or any cursor move */      if MINUS then NUM = -NUM;                 /* If a minus sign, negate the numerical value */      if CNT > 0 then return (NUM);             /* Return the number */                 else return (nullint);         /* else if nothing was entered, return a null vale */    end;  end;end GET_NUM;GET_FRACTION:procedure (POWER_DENOM) swap2; /* Gets the fraction value and returns either a legitimate value or 0 */  dcl (N,D)       fixed,   /* Numerator, Denominator */      POWER_DENOM boolean; /* Set to check for power denominator */  N = GET_NUM; if N = nullint then return (nullint); /* Get the numerator */  wchar(slash);  D = GET_NUM; if D = nullint then return (nullint); /* Get the denominator */  if 0 < N & N < 256 & (~POWER_DENOM \ POWER(D)) then return (shl(N,8) \ D); /* If the fraction is a legitimate value, return it */  return (0);end GET_FRACTION;GET_NOTE:procedure (MASK,ORDER,LAST,MESS) returns (pointer) swap2;  dcl MASK      boolean, /* Use a chord mask */      ORDER     boolean, /* Use physical note order and stop on tied-to notes */      LAST      boolean, /* Return nearest note (for track number) */      FLAG      boolean,      (P,Q,R)   pointer,      MESS      fixed array, /* Message, if null then simply test for note */      CHORD_BIT fixed,   /* Chord indicator */      PSN       fixed,   /* Note postion in chord */      (EX,EY)   fixed,      (I,T,C,L) fixed;  /* Pass (false,false,false,loc(null)) to test for presence of note. Return value     will be null if no note and non-null if a note is there. */  P = HEAD(PART); PSN = BASE_EDIT_POS; L = 0; Q = P; FLAG = true; /* Set pointer to head of part, set note position to edit list base */  do while FLAG;    if LAST & PSN <= EDIT_POS(L) then do; /* Search down chord for right voice */      R = P;    /* THIS GETS CALLED FOR EVERY NOTE UP TO POS!!! */      do while R ~= null;        if (core(R+D6) & MASK1) = VOICE then do;          Q = R; R = null;        end;        else R = core(R+GRP);      end;    end;    if P = null then call SYSERROR ('EdPos too big in GetNote'); /* ***** */    if PSN = EDIT_POS(L) then do;     /* If note position is equal to the edit position */      if L = LEVEL then FLAG = false;      else if (core(P+D6) & B_TUP) ~= 0 & core(P+D1+VOICE) ~= null then do;  /* If a tuplet in that voice */        P = core(P+D1+VOICE); PSN = 0; L = L + 1;      end;    end;    else do;      PSN = PSN + (core(P+D5) & LBYTE); /* Advc note pos by note advance */      if (core(P+D6) & B_REST) ~= 0 then PSN = PSN + core(P+D3); /* If a block rest, change the note position by the block rest edit advance */      P = core(P);      if PSN > EDIT_POS(L) then do;     /* If pos > edit position */        if L < LEVEL then call SYSERROR ('No tup in GetNote'); /* ***** */        FLAG = false;      end;    end;  end;  CHORD_MASK = 0;  if ORDER then CHORD_POS = 0;           else CHORD_POS = shr(core(P+D2),12);  if LAST then return (Q);  /* If LAST, return the nearest (previous) note */  if PSN ~= EDIT_POS(LEVEL) then return (null);  BUFF(0) = 0;  do while P ~= null;    if (core(P+D6) & B_REST)  = 0 &       (core(P+D6) & B_TUP)   = 0 &       (ORDER \ core(P+D1X) ~= null)    then do;      BUFF(0) = BUFF(0) + 1;      BUFF(BUFF(0)) = P;    end;    P = core(P+GRP);               /* Point to the next note in the chord */  end;  if BUFF(0) = 0 then return (null);  if BUFF(0) = 1 & ~MASK then return (BUFF(1));  /* This is kind of a kludge that allows this routine to be used     to simply test for the presence of a note. (return null = no note) */  if addr(MESS(0)) = null then return (BUFF(1));  if MESS(0) > 0 then do; /* Print the prompt if there is one */    pstring(MESS); wchar(sp);  end;  /* $PAGE */  vector_mode; L = 1;  do forever;    EX = XBASE; Q = BUFF(L);    if (core(Q+D2) & THRD4) = 0 then I = 12; else I = 8;  /* If the first note in a chord */    if ORDER then CHORD_POS = L - 1;                      /* Determine the new note position within the chord */             else CHORD_POS = shr(core(Q+D2),12);    CHORD_BIT = shl(1,CHORD_POS);                         /* Set the chord bit */    T = shr(core(Q+D5),8) & MASK2;                        /* Find the position bits7 */    if T = 3 then EX = EX - 8;             else EX = EX + T*4;    if      (core(Q+D5) & B_NOFF) ~= 0 then EX = EX + I*CONV((core(Q+D6) & B_DIR)~=0); /* If note offset is not zero, change the X position of the note, including th stem */    EY = core(Q+D2) & LBYTE;                             /* Determine vertical note position */    data_level (2); call CURSOR (EX,EY);  /* Draw the cursor in complement mode */    transparent_mode; C = rchar; /* Set t-mode for GO250 (change later?) */    call CURSOR (EX,EY); data_level (0);    if C = cr \ C = del then do; /* Be nice to ding note marks at this point */      transparent_mode;    end;    if      C = cr  then return (Q);   /* If cr return the note we're on */    else if C = 0   then return (Q);   /* If break return the note we're on */    else if C = del then do; erase_command; return (null); end; /* If delete, do nothing and return */    else if C = cur.up   & L > 1       then L = L - 1;    /* Move down a level */    else if C = cur.down & L < BUFF(0) then L = L + 1;    /* Move up a level */    else if MASK & C = sp & (CHORD_MASK & CHORD_BIT) ~= 0 then do;      data_level (2); call NOTE_MARK (EX,EY); data_level (0); /* Draw a note mark in complement mode */      CHORD_MASK = CHORD_MASK & ~shl(1,CHORD_POS);    end;    else if MASK & sp < C & C < del & (CHORD_MASK & CHORD_BIT) = 0 then do; /* If an ascii character */      data_level (2); call NOTE_MARK (EX,EY); data_level (0);   /* Draw the note mark in complement mode */      CHORD_MASK = CHORD_MASK \ shl(1,CHORD_POS);    end;  end;end GET_NOTE;FIND_TUP:procedure (REVRS,FIND_NOTE) returns (pointer) swap2; /* GetNote has one of these? - redundant! */  dcl REVRS    boolean, /* If searching backwards */      FIND_NOTE boolean, /* If searching for a note */      (P,Q)    pointer,      EDPOS(3) fixed,   /* Edit position pointers */      (I,L,S)  fixed;  L        = 0;  P        = HEAD(PART);  EDPOS(0) = BASE_EDIT_POS;   /* Set edit position to base level */  do forever;    if P = null then call SYSERROR ('EdPos too big in FindTup'); /* ***** */    I = EDPOS(L);    if REVRS & L = LEVEL then I = I + shr(core(P+D5+VOICE),8) - 1;    if FIND_NOTE & I = EDIT_POS(L) & (core(P+D6) & B_REST) = 0 then return P;    if (core(P+D6) & B_TUP) ~= 0 & core(P+D1+VOICE) ~= null & I = EDIT_POS(L) /* If a tuplet and something in the sequence  */    then do;      /* If the edit record for this tup has been deleted, we don't ascend */      if LIST_INDEX(PART) = 0 then return (null);       /* If there is nothing in the list, return */      S = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(PART));  /* Find the starting sector */      call SCAN_EDIT_LIST (S,EDPOS,L,true);        /* Scan the edit list to find the edit position */      if ~SCAN_TUP then return (null);      if L = LEVEL then return (P);      else do;        P = core(P+D1+VOICE); L = L + 1; EDPOS(L) = 0;      end;    end;    else do;      EDPOS(L) = EDPOS(L) + (core(P+D5) & LBYTE);     /* Increase edit position by position record advance */      if (core(P+D6) & B_REST) ~= 0 then EDPOS(L) = EDPOS(L) + core(P+D3);/* If block rest, increase edit position by block rest edit advance */      P = core(P);      if EDPOS(L) > EDIT_POS(L) then return (null);    end;  end;end FIND_TUP;/* $SubTitle  Find the Next Edit Position */FIND_NEXT:procedure returns (boolean) swap2; /* Find the next edit position from the note head */  dcl FLAG  boolean, /* If the next edit position found */      P     pointer,      (I,L) fixed;  XOFF = 0;  if LAST_EDIT then do;    BLOCK(0)       = 1;    LAST_EDIT      = false;    EDIT_POS(0)    = EDIT_POS(0) + 1;    MEASURE_NUMBER = MEASURE_NUMBER + 1;  end;  else do;    if (core(PP+D6) & B_EOL) ~= 0 then do; /* Drop a tup level */      if core(PP) = null \ LEVEL = 0 then return (true); /* If end of list or end of line */      LEVEL = LEVEL - ((shr(core(PP+D6),8) & MASK2) - (shr(core(core(PP)+D6),8) & MASK2));      EDIT_POS(LEVEL) = EDIT_POS(LEVEL) + EDIT_OLD(LEVEL);      BLOCK(LEVEL)    = BLOCK(LEVEL)    + EDIT_OLD(LEVEL);    end;    else do;                           /* Go up a tuplet level */      EDIT_POS(LEVEL) = EDIT_POS(LEVEL) + 1;      BLOCK(LEVEL)    = BLOCK(LEVEL)    + 1;    end;    XBASE = XBASE + (core(PP+D4) & LBYTE); /* Get the Post X Shift */    if LEVEL = 0 & (core(PP+D6) & B_BAR) ~= 0 then do;   /* If not a tuplet and if bar line */      if (core(PP+D6) & B_SOT) = 0 then MEASURE_NUMBER = MEASURE_NUMBER + 1; /* If not a start of a tuplet, increase measure number */      BLOCK(LEVEL) = 1;    end;    if (core(PP+D6) & B_REST) ~= 0 then do; /* If not a block rest */      EDIT_POS(LEVEL) = EDIT_POS(LEVEL) + core(PP+D2); /* Get next edit position by adding the edit advance to the edit position*/      MEASURE_NUMBER  = MEASURE_NUMBER  + (core(PP+D5) - 1); /* Increase the measure number */    end;    PP = core(PP);  end;  XBASE = XBASE + shr(core(PP+D4),8); /* Get the Pre X shift */  FLAG = true;  do while FLAG & core(PP+GRP) ~= null & ~MASTER_VOICE & LEVEL < MAX_LEVEL;    P = FIND_TUP (false,false);    if P ~= null then do;      L = core(P+D3+VOICE) & LBYTE;      do I = 1 to L; PP = core(PP+GRP); end;      EDIT_OLD(LEVEL) = core(PP+D5) & LBYTE;      LEVEL           = LEVEL + 1;      EDIT_POS(LEVEL) = 0;      BLOCK(LEVEL)    = 1;    end;    else FLAG = false;  end;  return (false);end FIND_NEXT;FIND_NEXT_NOTE:procedure;  do forever;    if FIND_NEXT then return;    if GET_NOTE(false,false,false,loc(null)) ~= null then return;  end;end FIND_NEXT_NOTE;/* $SubTitle Find Nearest and Find Last */FIND_NEAREST:procedure (X) swap2; /* Find the nearest edit position */  dcl X fixed;      /* X position */  LAST_EDIT      = true;  LEVEL          = 0;                       /* Tuplet level */  PP             = POS_HEAD;                /* Position pointer */  EDIT_POS(0)    = BASE_EDIT_POS - 1;       /* Edit position vector*/      BLOCK(0)       = 0;                       /* Block number */  MEASURE_NUMBER = BASE_MEASURE_NUMBER - 1; /* Meaure number */  XBASE          = 0;  do while XBASE < X;    if FIND_NEXT then X = 0;  end;end FIND_NEAREST;FIND_LAST:procedure returns (boolean) swap2; /* Find the last edit position */  dcl P     pointer,      (I,L) fixed,      FLAG  boolean;  XOFF = 0;  if LAST_EDIT then return (true);  if core(PP+REV) = null then do; /* If at the beginning of the position edit list */    call FIND_NEAREST (0);        /* Get the nearest X position to the beginning */    return (true);  end;  if (core(PP+D6) & B_SOT) ~= 0 & LEVEL > 0   /* If start of tuplet and more than one tuplet level */  then LEVEL = LEVEL - ((shr(core(PP+D6),8) & MASK2) - (shr(core(core(PP+REV)+D6),8) & MASK2));   /* Go down a tuplet */  XBASE           = XBASE - shr(core(PP+D4),8);     /* Get previous X shift */  PP              = core(PP+REV);                 /* Get previous position record */  EDIT_POS(LEVEL) = EDIT_POS(LEVEL) - 1;          /* Point to previous edit position */  BLOCK(LEVEL)    = BLOCK(LEVEL)    - 1;          /* Decrease the block level */  if LEVEL = 0 & (core(PP+D6) & B_BAR) ~= 0 then do;    /* If not a tuplet and a bar line */    if (core(PP+D6) & B_SOT) = 0 then MEASURE_NUMBER = MEASURE_NUMBER - 1;  /* Decrease the measure number */    P = core(PP+REV); BLOCK(LEVEL) = 1;   /* Point to previous position record and set block level number*/    do while (core(P+D6) & B_BAR) = 0 & P ~= null;    /* Do while there is not a bar line and there are position records */      P = core(P+REV); BLOCK(LEVEL) = BLOCK(LEVEL) + 1;  /* Point to previous position record and set the block number */    end;  end;  if (core(PP+D6) & B_REST) ~= 0 then do;            /* If a block rest */    EDIT_POS(LEVEL) = EDIT_POS(LEVEL) - core(PP+D2); /* Determine the edit position (last block in block rest measure only) */    MEASURE_NUMBER  = MEASURE_NUMBER  - (core(PP+D5) - 1); /* Determine the measure number */  end;  FLAG = true;  do while FLAG & core(PP+GRP) ~= null & ~MASTER_VOICE & LEVEL < MAX_LEVEL; /* Do while there are records, not a master voice, and level does not exceed maximum */    P = FIND_TUP (true,false); /* Find tuplet level */    if P ~= null then do;      L = shr(core(P+D3+VOICE),8);      do I = 1 to L; PP = core(PP+GRP); end;/* Get position records for all levels */      EDIT_OLD(LEVEL) = core(PP+D5) & LBYTE;    /* Find the old edit position */      EDIT_POS(LEVEL) = EDIT_POS(LEVEL) - (EDIT_OLD(LEVEL) - 1);  /* Detrmine the difference in positions */      BLOCK(LEVEL)    = BLOCK(LEVEL)    - (EDIT_OLD(LEVEL) - 1);  /* Find the tuplet level */      LEVEL           = LEVEL + 1;      EDIT_POS(LEVEL) = shr(core(PP+D5),8) - 1;  /* Find the new edit position */      BLOCK(LEVEL)    = shr(core(PP+D5),8);    end;    else FLAG = false;  end;  XBASE = XBASE - (core(PP+D4) & LBYTE);  return (false);end FIND_LAST;FIND_LAST_NOTE:procedure;  do forever;    if FIND_LAST then return;    if GET_NOTE(false,false,false,loc(null)) ~= null then return;  end;end FIND_LAST_NOTE;/* $SubTitle Key_Number */KEY_NUMBER:procedure (BUFF,SCRIPT) returns (fixed) public swap2;  /* Determines the key given the pitch letter and octave number     and returns the key number */  dcl BUFF    fixed array,                 /* Pitch [accidental] [octave] */      SCRIPT  boolean,                     /* Set if script representation */      (KEY,C) fixed,                       /* Key number */      KEYTAB  fixed data (9,11,0,2,4,5,7); /* KeyTable */  C = byte(BUFF,0);  if lower.a <= C then C = C - 32;  C = C - asc.a;                           /* Change the character into a number */  if C < 0 \ 6 < C then return (nullint);  /* Make sure the number is within bounds */  KEY = KEYTAB(C) + 24;  if BUFF(0) = 1 then return (KEY);  C = byte(BUFF,1);    /* Determine if the key is a sharp or a flat */  if (SCRIPT & C = asc.f) | C = asc.dollr then do; /* If a flat */    KEY = KEY - 1;      /* Reduce key by a semitone */    if BUFF(0) = 2 then return (KEY); /* If no octave, return the keycode */    C = byte(BUFF,2);   /* Get the specified octave number */  end;  else if C = hash then do;   /* If a sharp */    KEY = KEY + 1;            /* Increase key by a semitone */    if BUFF(0) = 2 then return (KEY); /* If no octave number is specified, return the key code */    C = byte(BUFF,2);         /* Get the specified octave number */  end;  if SCRIPT & (asc.0 <= C & C <= asc.7)  then return (KEY + 12 * (C - asc.1 - 2)); /* Return the key number offset by the octave */  return (KEY);end KEY_NUMBER;/* $subtitle ADD_BLOCK_TIME */ADD_BLOCK_TIME:procedure (T,B) swap2;  dcl T       fixed array,      B       fixed,      (CA,RA) fixed,      DIF     fixed,      REM     fixed,      TICS    fixed;  if B <= 0 then return;  CA = 1;  RA = (EDIT_RESOLUTION * shr(CLICK_NOTE,8)) / (CLICK_NOTE & LBYTE);  if RA = 0 then do;    CA = ((CLICK_NOTE & LBYTE) / EDIT_RESOLUTION) / shr(CLICK_NOTE,8);    if CA = 0 then CA = 1; /* Click/Reso incompatable */    RA = 1;   end;  write(5) = B;  write(7) = RA;  DIF      = read(5);  REM      = read(4);  TICS = DIF * (CA * TEMPO);  TICS = TICS + SIEVE(TEMPO,RA,REM);  call ADD32 (T,TICS);end ADD_BLOCK_TIME;/* $SubTitle  Sequence Editing routine */EDIT_NOTE:procedure (PP,COM) returns (boolean) swap2;  dcl (PP,P,Q)  pointer,      CT(1)     fixed, /* Current starting time */      NT(1)     fixed, /* New starting time */      LT(1)     fixed, /* Previous starting time */      DT(1)     fixed, /* Temp */      AT(1)     fixed, /* Temp */      COM       fixed,      TRK       fixed, /* Track */      TRN       fixed, /* Transpose */      (I,D,N,V) fixed;  transparent_mode;/*error_case do;  pstring('SeqChange here COM = ');pnum(COM,0);crlf;  flush_term;end;*/  if SECTS_LEFT < 4 then do;    pcmd('Not enough room to edit sequence');    return (false);  end;  if COM = ADD# then do; /* Look up nearest note for track # (DOES THIS ALWAYS WORK?) */    P   = GET_NOTE(false,false,true,'');    TRK = core(P+D4) & LBYTE;    TRN = EXPAND(shr(core(P+D1),8),8); /* Get transpose value */    P   = null;  end;  else do; /* Look up an existing note to change */    P = GET_NOTE (false,false,false,'Select note');    if P = null \ core(P+D1X) = null then do;      pcmd('No note to edit');      return (false);    end;    TRK   = core(P+D4) & LBYTE; /* Set track to edit from note record */    TRN   = EXPAND(shr(core(P+D1),8),8); /* Get transpose value */    VOICE = core(P+D6) & MASK1; /* Set VOICE from note record */    VOX   = VOICE; /* Note editing can only be in UPPER or LOWER voice modes */  end;/*error_case do;  pstring('TRK,P ');pnum(TRK,0);pnum(P,10);crlf;  flush_term;end;*/  if ONE_TRACK then call LOAD_SEQ_RECORD (PART,0);               else call LOAD_SEQ_RECORD (PART,VOICE);  if #TRK ~= TRK \ #STATUS = UNINIT# then call INIT_SEQ_GLOBALS (TRK);/*error_case do;  pstringr('#s after loadup:'); print#s;  flush_term;end;*/  CT(1) = core(PP+D2X); /* Get time of current position */  CT(0) = core(PP+D2);  if P ~= null then do; /* If we are not ADDing a note */    /* Set #'s to note to edit */    if ~LOCATE_NOTE (core(P+D1X),core(P+D1)&LBYTE) then do;      pcmd('Note not found in sequence');      return (false);    end;/*error_case do;  pstringr('#s after locate:'); print#s;  flush_term;end;*/    call LOOK.UP.NOTE.INFO; /* Get #W's */  end;  else do; /* set #W's to null */    #W1 = 0;    #W2 = 0;    #W3 = RTE.MAX;    #W4 = VEL.NOTE;  end;/*call rchar;*/  if COM = PTCH# \ COM = ADD# then do; /* Get pitch */    erase_command;    call GET_STR ('Note: ',true,BUFF,3);    if BUFF(0) > 0 then do;      N = KEY_NUMBER(BUFF,true) - TRN; /* Translate script pitch into key number */      if N < -12 \ N > 72 then do;        pcmd('Illegal note or note out of range');        return (false);      end;      if N < 0 then do;      /* Out of range pitch requires 4 word rec */        N   = N + 12;        #W1 = #W1 \ 1;        #W4 = (#W4 & ~S_OCTUP) \ S_OCTDN;      end;      else if N > 60 then do;     /* Out of range pitch requires 4 word rec */        N   = N - 12;        #W1 = #W1 \ 1;        #W4 = (#W4 & ~S_OCTDN) \ S_OCTUP;      end;      else #W4 = #W4 & ~(S_OCTDN \ S_OCTUP);      #W2 = (#W2 & ~MASK6) \ N;    end;    else return (true);  end;/* $page */  if COM = STRN# then do; /* Get string number */    erase_command; pcmd('String: ');    N = GET_NUM;    if 1 <= N & N <= 6 then do;      #W1 = #W1 \ 1;      #W3 = (#W3 & ~THRD4) | S_GUITAR | shl(N-1,8);    end;    else do;      pcmd('Illegal string number');      return (false);    end;  end;/* $page */  if COM = DUR# \ COM = ADD# then do; /* Get duration */    pcmd('Duration: ');    N = GET_NUM; if N = nullint then return (true); /* Get the numerator */    wchar(slash);    D = GET_NUM; if D = nullint then return (true); /* Get the denominator */    if N <= 0 \ N >= 256 \ ~POWER(D) then do; /* Make sure its a legitimate value */      pcmd('Illegal note duration');      return (false);    end;    /* Find the pos rec that corresponds to the End Time of the new note */    D = (EDIT_RESOLUTION * N) / D;    Q = PP;    do while D > 0 & core(Q) ~= null;      Q = core(Q); D = D - 1;    end;    NT(1) = core(Q+D2X);    NT(0) = core(Q+D2);    call ADD_BLOCK_TIME (NT,D);    call DIF32 (NT,CT,DT);    if D > 0 then do;      LT(1) = core(core(Q+REV)+D2X);      LT(0) = core(core(Q+REV)+D2);      call DIF32 (NT,LT,AT);      do N = 1 to D;        call SUM32 (DT,AT,DT);      end;    end;    /* Encode duration */    N = 0; /* Exponent */    do while DT(1) igt 0 \ DT(0) ige 4096;      D     = DT(1) & MASK2;      DT(1) = shr(DT(1),2);      DT(0) = shl(D,14) \ shr(DT(0),2);      N     = N + 1;    end;    if N > 3 then do;      DT(0) = 4095;      N     = 3;    end;    #W1 = (#W1 & "103777") \ shl(N,13) \ shl(DT(0),1);    #W2 = shl(DT(0),6) \ (#W2 & MASK6);  end;  if COM = MOVE# then do; /* Get a delta time value */    pcmd('Value to move: ');    N = GET_NUM; if N = nullint then return (true); /* Get the numerator */    wchar(slash);    D = GET_NUM; if D = nullint then return (true); /* Get the denominator */    if N < -255 \ N > 255 \ ~POWER(D) \ D > EDIT_RESOLUTION then do;      pcmd('Illegal value');      return (false);    end;    N = (EDIT_RESOLUTION * N) / D;    do while N < 0 & core(PP+REV) ~= null;  /* Move backward in time */      PP = core(PP+REV); N = N + 1;    end;    do while N > 0 & core(PP) ~= null;      PP = core(PP);     N = N - 1;    end;    CT(1) = core(PP+D2X);    CT(0) = core(PP+D2);    call ADD_BLOCK_TIME (CT,N);  end;/*error_case do;  pstringr('#s before edit:'); print#s;  flush_term;end;*/  if P ~= null then core(P+D1X) = null; /* Clear NoteRec sec ptr so we don't try to edit this one again */  #MSB = CT(1);  #LSB = CT(0);  call EDIT_TRACK (COM ~= DEL#,COM ~= ADD#);/*pstringr('#s after edit:'); print#s;call rchar;*/  /* Any pointers and times to this track may be invalid */  do I = 0 to STAVES;    P = DISPLAY(I);    do V = 0 to 1;      call LOAD_SEQ_RECORD (P,V);      if #TRK = TRK then do;        #STATUS = UNINIT#;        call DUMP_SEQ_RECORD (P,V);      end;    end;  end;  return (true);end EDIT_NOTE;EDIT_SEQUENCE:procedure (PP,COM) returns (boolean) swap2;  dcl PP    pointer,      COM   fixed,      ST(1) fixed, /* Start time of area */      FT(1) fixed, /* Finish time of area */      BLKS  fixed,      TRK   fixed, /* User selected track */      PRT   fixed, /* User selected part (edit list) */      (D,N) fixed;  transparent_mode;  if SECTS_LEFT < 4 then do;    pcmd('Not enough room to edit sequence');    return (false);  end;  if LEVEL > 0 then do;    pcmd('Must be in Base Level');    return (false);  end;  if EDIT_POS(0) = 0 then do;    pcmd('Command not allowed from this position');    return (false);  end;  if COM = INSR# then pcmd ('Time to insert: ');                 else pcmd ('Time to remove: ');  N = GET_NUM; if N = nullint then return (true); /* Get the numerator */  wchar(slash);  D = GET_NUM; if D = nullint then return (true); /* Get the denominator */  if N < 1 \ N > 255 \ ~POWER(D) \ D > EDIT_RESOLUTION then do;    pcmd('Illegal value');    return (false);  end;  pcmd ('Track: '); TRK = GET_NUM;  if TRK = nullint then TRK = 0;  if TRK < 0 | MAX_LEGAL_TRACKS# < TRK then do;    pcmd('Illegal track');    return (false);  end;  pcmd ('Part: ');  PRT = GET_NUM;  if PRT = nullint then PRT = 0;  if PRT < 0 | PRT > PARTS + 1 then do;    pcmd('Illegal part');    return (false);  end;  BLKS  = (EDIT_RESOLUTION * N) / D; /* Calc no. of edit blocks */  ST(1) = core(PP+D2X);  ST(0) = core(PP+D2);  N     = BLKS;  do while N > 0 & core(PP) ~= null; /* Move forward MUST GO BEYOND END OF LINE!!! */    PP = core(PP); N = N - 1;  end;  FT(1) = core(PP+D2X);  FT(0) = core(PP+D2);  call ADD_BLOCK_TIME (FT,N);  if TRK = 0 & PRT = 0 then do;    do D = 1 to MAX_LEGAL_TRACKS#;      if INIT_SEQ_GLOBALS (D)       then call SLIDE_TRACK (ST,FT,COM=INSR#);    end;    do D = 0 to PARTS;      if LIST_INDEX(D) ~= 0      then call SLIDE_EDIT_LIST (D,EDIT_POS(0),EDIT_POS(0)+BLKS,COM=INSR#);    end;    if LIST_INDEX(MASTER_PART) ~= 0    then call SLIDE_EDIT_LIST (MASTER_PART,EDIT_POS(0),EDIT_POS(0)+BLKS,COM=INSR#);  end;  else do;    if TRK ~= 0 & INIT_SEQ_GLOBALS (TRK)     then call SLIDE_TRACK (ST,FT,COM=INSR#);    if PRT ~= 0 & LIST_INDEX(PRT-1) ~= 0    then call SLIDE_EDIT_LIST (PRT-1,EDIT_POS(0),EDIT_POS(0)+BLKS,COM=INSR#);  end;  return (true);end EDIT_SEQUENCE;