/* $title Global Routines */module GLOBRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';insert ':mplt:ps_lits';begin;dcl MEP(0) fixed, /* For edit stack snapshot */    MEI(0) fixed,    MEE(0) fixed,    EDP(0) fixed,    EDI(0) fixed,    EDE(0) fixed;ERROR:procedure (STRING) public; /* Set the error message pointer and return to main menu */  dcl STRING              fixed array,                  /* Error message  */      CLEAR_LASER_PRINTER procedure external,      MAIN_MODE           fixed external;  if ENGRAVING then call CLEAR_LASER_PRINTER;  REPLOT_MEASURE = 0;  ERR_PTR        = addr(STRING(0));           /* Set the error pointer to print the error message*/  call RE_START;end ERROR;SYSERROR:procedure (STRING) public; /* Handle system errors - choice of abort or continue */  /* THIS MUST NOT SWAP OR IT WON'T GET THE STRING */  dcl STRING              fixed array,                  /* Error message  */      CLEAR_LASER_PRINTER procedure external,      MAIN_MODE           fixed external,      C                   fixed;  clear_all;  pos(7, 5); pstring('SYSTEM ERROR: '); pstring(STRING);  pos(9, 5); pstring('Press <ENTER> to return to main menu.');  pos(10,5); pstring('Press <RETURN> to continue (at your own risk).');  pos(12,5);  do forever;    C = rchar;	if C = kp.enter then do;      if ENGRAVING then call CLEAR_LASER_PRINTER;      REPLOT_MEASURE = 0;      call RE_START;    end;    else if C = cr then do;      clear_all;      return;    end;    else if C = 0 then do;      clear_all;      return;    end;  end;end SYSERROR;CHECK_PS_ERRORS:procedure public;  dcl C fixed;  if ps_midle | ~CATCH_PS_ERRORS then return;  C = ps_rmchar;  do while C ~= -1;    wchar(C);    C = ps_rmchar;  end;  flush_term;  PS_ERROR_PRESENT = true;end CHECK_PS_ERRORS;WORD_LEN:procedure (LEN) public; /* Given the length char string, returns length in words */  dcl LEN fixed;  return (shr(LEN + 3,1));end WORD_LEN;STRING_LEN:procedure (STR,FONT) returns (fixed) public;  dcl STR     fixed array,      FONT    fixed,      (LEN,I) fixed;  if FONT = F_ALPHA# then return (STR(0) * 8);  LEN = 0;  do I = 0 to STR(0) - 1;    LEN = LEN + byte(loc(addr(WIDTH_TABLE(0))-1),256*FONT+byte(STR,I));  end;  return (LEN*10/CSC#);end STRING_LEN;INSNAME_STR:procedure (S) public;  dcl S fixed array,      I fixed;  dcl tilde lit '126';  do I = 0 to S(0)-1;    if      byte(S,I) = asc.sharp   then call pbyte(S,I,"207"); /* Sharp */    else if byte(S,I) = asc.dollr   then call pbyte(S,I,"215"); /* Flat */    else if byte(S,I) = uarrow  	then call pbyte(S,I,"276"); /* Diminished */    else if byte(S,I) = percent 	then call pbyte(S,I,"277"); /* Half diminished */    else if byte(S,I) = tilde   	then call pbyte(S,I,"216"); /* Natural */    else if byte(S,I) = asc.at  	then call pbyte(S,I,"217"); /* Major */  end;end INSNAME_STR;EXPAND:procedure (N,BITS) public;  /* Expand right justified 2's comp # of BITS width to 16 bits */  dcl (N,BITS) fixed; /* Number, Number of Bits */  if shr(N,BITS-1)  then N = N \ shl(-1,BITS);  else N = N & shr(-1,16-BITS);  return (N); /* Return the number */end EXPAND;POWER:procedure (X) public; /* Return TRUE iff 0 < X <= 128 and X = 2^K */  dcl (X,I,B) fixed;  B = 1;  do I = 0 to 7;    if X = B then return (true);    B = shl(B,1);  end;  return (false);end POWER;CONV:procedure (D) public; /* Converts a boolean value to a signed direction (false = 1, true = -1) */ dcl D fixed; if D = 0 then return ( 1);          else return (-1);end CONV;ADD32:procedure (A,N) public; /* A = A + N (Won't wrap) */  dcl A fixed array,      N fixed;  A(0) = A(0) + N;  if A(0) ilt N then do;    if A(1) = -1 then A(0) = -1;                 else A(1) = A(1) + 1;  end;end ADD32;SUB32:procedure (A,N) public; /* A = A - N (Won't wrap) */  dcl A fixed array,      N fixed;  N = A(0) - N;  if N igt A(0) then do;    if A(1) = 0 then N    = 0;                else A(1) = A(1) - 1;  end;  A(0) = N;end SUB32;SUM32:procedure (A,B,C) public; /* C = A + B */  dcl (A,B,C) fixed array,       ALSB   fixed;  ALSB = A(0);  C(1) = A(1) + B(1);  C(0) = A(0) + B(0);  if C(0) ilt ALSB then C(1) = C(1) + 1;end SUM32;DIF32:procedure (A,B,C) public; /* C = A - B */  dcl (A,B,C) fixed array,      ALSB    fixed;  ALSB = A(0);  C(1) = A(1) - B(1);  C(0) = A(0) - B(0);  if C(0) igt ALSB then C(1) = C(1) - 1;end DIF32;SIEVE:procedure (BASE,GRID,POSN) returns (fixed) public;  dcl BASE  fixed,      GRID  fixed,      POSN  fixed;  if GRID then do; /* If GRID is odd, multiply by 2 */    GRID = shl(GRID,1);    POSN = shl(POSN,1);  end;  write(5)   = BASE;  write(6)   = POSN;  write(NOP) = read(5);  write(7)   = GRID;  if read(4) >= shr(GRID,1) then return (read(5) + 1);                            else return (read(5));end SIEVE;NUM_TO_STR:procedure (BUFF,X) public swap9; /* Converts a number to a string */  dcl BUFF  fixed array,  /* String array */      X     fixed,        /* Number */      (D,I) fixed;  D = 10000; do while D > X; D = D/10; end; BUFF(0) = 0;  if X = 0 then do; BUFF(0) = 1; BUFF(1) = 48; end;  else do while D > 0;    I = X / D;    call pbyte(BUFF,BUFF(0),I+48);    X = X mod D; D = D/10; BUFF(0) = BUFF(0) + 1;  end;end NUM_TO_STR;STR_TO_NUM:procedure (BUFF) returns (fixed) public;  dcl BUFF  fixed array,  /* String array */      (C,X) fixed;        /* Char, Number */  X = 0;  do C = 0 to BUFF(0)-1;    X = X * 10;    X = X + (byte(BUFF,C) - asc.0);  end;  return X;end STR_TO_NUM;SET_KEY:procedure (KEY,FORM) returns (fixed) public swap9;  dcl KEY  fixed,   /* KEY comes in as a keytable index */      FORM boolean; /* Use the accidental format */  KEY = KEY_CODES(KEY&MASK6) - KEY_CODES(KEYIN_TABLE(TRANSPOSE(0) mod 12)); /* Transpose according to key of instrument *//*  if      KEY < -7 \ (KEY < -4 & (PBITS & P_FLAT)  = 0 & FORM) then KEY = KEY + 12;  else if KEY >  7 \ (KEY >  4 & (PBITS & P_FLAT) ~= 0 & FORM) then KEY = KEY - 12;*/  if      KEY < -7 then KEY = KEY + 12; /* Keep key reasonable */  else if KEY >  7 then KEY = KEY - 12; /* Keep key reasonable */  return (KEY); /* KEY goes out as a key code (no. of sharps) */end SET_KEY;DEC_ADD:procedure (A,B) returns (fixed) public; /* A + B */  dcl (A,B,M,D) fixed;  M = (A & UBYTE) + (B & UBYTE);  D = (A & LBYTE) + (B & LBYTE);  if D >= 200 then do;    M = M + shl(1,8);    D = D - 200;  end;  return (M \ D);end DEC_ADD;DEC_SUB:procedure (A,B) returns (fixed) public; /* A - B (positive only) */  dcl (A,B,M,D) fixed;  if B ige A then return (0);  M = (A & UBYTE) - (B & UBYTE);  D = (A & LBYTE) - (B & LBYTE);  if D < 0 then do;    M = M - shl(1,8);    D = D + 200;  end;  return (M \ D);end DEC_SUB;LOG10:procedure (N) returns (fixed) public;  /* Determines the integer log base 10 of a number */  dcl (N,I) fixed;  I = 0; N = N / 10;  do while N ~= 0;    I = I + 1;    N = N / 10;  end;  return (I);end LOG10;CONVERT_MASK:procedure (MASK,LEN) returns (fixed) public swap9;  dcl MASK  fixed,      LEN   fixed,      (I,T) fixed;    T = MASK; MASK = 0;    do I = 1 to LEN;      MASK = shl(MASK,1);      MASK = MASK \ (T & MASK1);      T    = shr(T,1);    end;    return (MASK);end CONVERT_MASK;CLEAR_REC:procedure public; /* Clears the contents of "REC" which typically holds the current record */  write("300") = addr(REC(D0));  write("360") = 0;  write("360") = 0;  write("360") = 0;  write("360") = 0;  write("360") = 0;  write("360") = 0;  write("360") = 0;  write("360") = 0;end CLEAR_REC;LOAD_RECORD:procedure (P) public;  /* Loads a record into "REC" given the current pointer */  dcl P pointer; /* Record pointer */  write("300") = P+D1;  write("301") = addr(REC(D1));  write("361") = read("360"); /*  REC(D1)  = core(P+D1);  */  write("361") = read("360"); /*  REC(D2X) = core(P+D2X); */  write("361") = read("360"); /*  REC(D2)  = core(P+D2);  */  write("361") = read("360"); /*  REC(D3)  = core(P+D3);  */  write("361") = read("360"); /*  REC(D4)  = core(P+D4);  */  write("361") = read("360"); /*  REC(D5)  = core(P+D5);  */  write("361") = read("360"); /*  REC(D6)  = core(P+D6);  */end LOAD_RECORD;LOOKUP_NUMBER:procedure (NAME,LIBRARY) returns (fixed) public swap9; /* Looks for the symbol code given the symbol name and returns it. */  dcl NAME     fixed array, /* Symbol name */      LIBRARY  fixed,      (N1,N2)  fixed,       /* First and second words of the symbol name */      (S,W,D)  fixed;  do D = NAME(0) to 3; /* Fill out symbol name with spaces */    call pbyte(NAME,D,sp);  end;  S = 0; W = 0;  do case LIBRARY;    S = SLIB_BASE;    S = ULIB_BASE;    S = ALIB_BASE;  end;  if S = 0 then return (nullint);  do forever;    write(SECT$) = S + shr(W,8);    write(WORD$) = W;    D            = read(DATI$);    if D = 0 then return (nullint);    N1           = read(DATI$);    N2           = read(DATI$);    if N1 = NAME(1) & N2 = NAME(2) then return (shr(D,8));    W = W + (D & LBYTE);  end;end LOOKUP_NUMBER;LOOKUP_NAME:procedure (CODE,LIBRARY,NAME) returns (boolean) public swap9; /* Look up the symbol name given the symbol code. Returns the name in COM. */  dcl CODE    fixed,      LIBRARY fixed,      NAME    fixed array,      (S,W,D) fixed;  NAME(0) = 4;       /* Null name is 4 spaces */  NAME(1) = "H2020";  NAME(2) = "H2020";  S = 0; W = 0;  do case LIBRARY;    S = SLIB_BASE;    S = ULIB_BASE;    S = ALIB_BASE;  end;  if S = 0 \ CODE = 0 then return (false);  do forever;    write(SECT$) = S + shr(W,8);    write(WORD$) = W;    D            = read(DATI$);    if D = 0 then return (false);    if shr(D,8) = CODE then do;      NAME(1) = read(DATI$);      NAME(2) = read(DATI$);      return (true);    end;    W = W + (D & LBYTE);  end;end LOOKUP_NAME;LOOKUP_FRAME:procedure (NAME,FRAME) returns (boolean) public swap9;  dcl NAME  fixed array;  dcl FRAME fixed array;  COMPARE:procedure returns (boolean);    dcl (A,B,I) fixed;    do I = 0 to 11;      A = byte(NAME,I);      B = byte(loc(addr(FRAME(0))-1),I);      if A<B then return (2); /* Less */      if A>B then return (1); /* Greater */    end;    return (0); /* Found */  end COMPARE;  dcl (L,I,R) fixed;  L = 0;  R = shr(FLIB_LEN,4) - 1;  do while L <= R;    I = (L+R)/2;    call import (FLIB_BASE,shl(I,4),FRAME,16);    do case COMPARE;      return (true);      L = I + 1;      R = I - 1;    end;  end;  return (false);end LOOKUP_FRAME;FIND_LIST_SECT:procedure (BASE,INDEX) returns (fixed) public;    dcl BASE  fixed, /* Base of edit list */      INDEX fixed, /* Index to edit list */      (I,S) fixed;  S = BASE;  do I = 2 to INDEX;    write(SECT$) = S;    S            = S + read(DATA$);  end;  return (S);end FIND_LIST_SECT;DELETE_EDIT_LIST:procedure (LIST) public swap; /* Deletes an edit list from the sequence */  dcl LIST fixed,      S    fixed;  S            = FIND_LIST_SECT (EDIT_BASE,LIST);  write(SECT$) = S;  call XMEM_SECT_SLIDE (S,-read(DATA$)); /* Slide rest of xmem down */  /* All list references to beyond deleted list get decremented 1 */  do S = 0 to PARTS;    if LIST_INDEX(S) > LIST then LIST_INDEX(S) = LIST_INDEX(S) - 1;  end;  if LIST_INDEX(MASTER_PART) > LIST then LIST_INDEX(MASTER_PART) = LIST_INDEX(MASTER_PART) - 1;  if BUFF_LIST > LIST then BUFF_LIST = BUFF_LIST - 1;  LISTS = LISTS - 1;end DELETE_EDIT_LIST;DELETE_EDIT:procedure (PART) public swap; /* Deletes a part's edit list */  dcl PART fixed;  if LIST_INDEX(PART) = 0 \        /* If there is no edit list          */     BUFF_LIST = LIST_INDEX(PART)  /* or list is held in buffer, return */  then return;  call DELETE_EDIT_LIST (LIST_INDEX(PART));  LIST_INDEX(PART) = 0; /* Clear current part index */end DELETE_EDIT;LOAD_EDIT_STACK:procedure public;  core(EDIT_STAK_BASE+MEDP#) = MEDIT_POINT;  core(EDIT_STAK_BASE+MEDI#) = MEDIT_INDEX;  core(EDIT_STAK_BASE+MEDE#) = MEDIT_END;  core(EDIT_STAK_BASE+EDP#)  = EDIT_POINT;  core(EDIT_STAK_BASE+EDI#)  = EDIT_INDEX;  core(EDIT_STAK_BASE+EDE#)  = EDIT_END;end LOAD_EDIT_STACK;DUMP_EDIT_STACK:procedure public;  MEDIT_POINT = core(EDIT_STAK_BASE+MEDP#);  MEDIT_INDEX = core(EDIT_STAK_BASE+MEDI#);  MEDIT_END   = core(EDIT_STAK_BASE+MEDE#);  EDIT_POINT  = core(EDIT_STAK_BASE+ EDP#);  EDIT_INDEX  = core(EDIT_STAK_BASE+ EDI#);  EDIT_END    = core(EDIT_STAK_BASE+ EDE#);end DUMP_EDIT_STACK;UNSNAP_EDIT_STACK:procedure (I) public;  dcl I fixed;  core(EDIT_STAK_BASE+MEDP#) = MEP(I);  core(EDIT_STAK_BASE+MEDI#) = MEI(I);  core(EDIT_STAK_BASE+MEDE#) = MEE(I);  core(EDIT_STAK_BASE+EDP#)  = EDP(I);  core(EDIT_STAK_BASE+EDI#)  = EDI(I);  core(EDIT_STAK_BASE+EDE#)  = EDE(I);end UNSNAP_EDIT_STACK;SNAP_EDIT_STACK:procedure (I) public;  dcl I fixed;  MEP(I) = core(EDIT_STAK_BASE+MEDP#);  MEI(I) = core(EDIT_STAK_BASE+MEDI#);  MEE(I) = core(EDIT_STAK_BASE+MEDE#);  EDP(I) = core(EDIT_STAK_BASE+ EDP#);  EDI(I) = core(EDIT_STAK_BASE+ EDI#);  EDE(I) = core(EDIT_STAK_BASE+ EDE#);end SNAP_EDIT_STACK;GET_EDIT_RECORD:procedure (BUFF,FILL) returns (fixed) public;  /* Enter with xmem set to first word of record     Exit with record in BUFF (if FILL) and return record length     Xmem will now be set to next record */  dcl BUFF  fixed array,      FILL  boolean,      TUP   boolean,      LEN   fixed,      (D,S) fixed;  TUP     = false;  LEN     = 1;  BUFF(0) = read(DATI$);  D       = rot(BUFF(0),1);  if ~D then do;    D = rot(D,1);    if D then do;      D = rot(D,1);      if D then do;        if (D & ~MASK11) = ~MASK11 then do;          LEN = 3;          TUP = true;        end;        else LEN = BUFF(0) & LBYTE;      end;      else LEN = 2;    end;    else LEN = 1;  end;  if LEN igt 1 then BUFF(1) = read(DATI$);  if LEN igt 2 then BUFF(2) = read(DATI$);  if TUP then LEN = 2 + BUFF(2);  if FILL & ~TUP then do D = 4 to LEN; /* Load remaining words */    BUFF(D-1) = read(DATI$);  end;  else if LEN igt 3 then do;    S = read(SECT$);    D = read(WORD$);    D = D + LEN - 3;    write(SECT$) = S + shr(D,8);    write(WORD$) = D;  end;  return (LEN);end GET_EDIT_RECORD;GET_NEXT_RECORD:procedure (LEVEL,BUFF,FILL) returns (boolean) public;  dcl LEVEL fixed, /* High bit set to stop EDIT_POSITION from advancing */      BUFF  fixed array,      FILL  boolean,      (B,P) pointer,      LEN   fixed;  B = EDIT_STAK_BASE + (LEVEL&LBYTE)*6;  if core(B+MEDP#) ~= null & core(B+MEDI#) = 0 then do;    write(SECT$) = FIND_LIST_SECT(EDIT_BASE,LIST_INDEX(MASTER_PART)) + shr(core(B+MEDP#),8);    write(WORD$) = core(B+MEDP#);    LEN          = GET_EDIT_RECORD (BUFF,FILL);    if rot(BUFF(0),1) then do;      core(B+MEDI#) = BUFF(0) & MASK15;      core(B+MEDP#) = core(B+MEDP#) + 1;    end;    else do;      MASTER_RECORD = true;      core(B+MEDP#) = core(B+MEDP#) + LEN;      if core(B+MEDP#) igt core(B+MEDE#) then call SYSERROR ('MEdPtr > MEdEnd in GNR');      if core(B+MEDP#) = core(B+MEDE#) then core(B+MEDP#) = null;      return (true);    end;  end;  if core(B+EDP#) ~= null & core(B+EDI#) = 0 then do;    write(SECT$) = FIND_LIST_SECT(EDIT_BASE,LIST_INDEX(PART)) + shr(core(B+EDP#),8);    write(WORD$) = core(B+EDP#);    LEN          = GET_EDIT_RECORD (BUFF,FILL);    if rot(BUFF(0),1) then do;      core(B+EDI#) = BUFF(0) & MASK15;      core(B+EDP#) = core(B+EDP#) + 1;    end;    else do;      MASTER_RECORD = false;      P             = core(B+EDP#);      core(B+EDP#)  = P + LEN;      if core(B+EDP#) igt core(B+EDE#) then call SYSERROR ('EdPtr > EdEnd in GNR');      if core(B+EDP#) = core(B+EDE#) then core(B+EDP#) = null;/* WAS if shr(BUFF(0),8) = "177" then do; * A sublist */      if (BUFF(0) & ~MASK7) = ("077400" \ shl(VOICE,7)) then do; /* A sublist */        B             = EDIT_STAK_BASE + ((LEVEL&LBYTE) + 1) * 6;        core(B+MEDP#) = null;        if BUFF(2) = 1 then core(B+EDP#) = null;        else do;          core(B+EDP#) = P + 3;          core(B+EDI#) = 0;          core(B+EDE#) = P + 2 + BUFF(2);        end;      end;      return (true);    end;  end;  core(B+MEDI#) = core(B+MEDI#) - 1;  core(B+ EDI#) = core(B+ EDI#) - 1;  if LEVEL = 0 then EDIT_POSITION = EDIT_POSITION + 1;  return (false);end GET_NEXT_RECORD;LOAD_MAIN_VECTOR:procedure (LOC) public;  dcl LOC fixed,      I   fixed;  I = LOC - 1;  START_CLICK             = shr(core(I+1),8);  CLICK_TRACK     = core(I+1) & LBYTE;  CLICK_NOTE              = core(I+2);  BEAT_MEAS               = shr(core(I+3),8);  BEAT_NOTE       = core(I+3) & LBYTE;  OVERLAP                 = core(I+4);  FORMAT                  = core(I+5) & UBYTE; NOTE_SPACE      = (core(I+5) & LBYTE)*4;  PARTS                   = shr(core(I+6),8);  /* LISTS */  /* LIST_INDEX */                             EDIT_RESOLUTION = core(I+7) & LBYTE;  INIT_PAGE               = core(I+8);  INIT_MEAS               = core(I+9);  LAST_MEAS               = core(I+10);  PRINTER_TYPE            = shr(core(I+11),8); MEAS_LINE       = core(I+11) & LBYTE;  LEFT_MARGIN             = core(I+12);  PAGE_WIDTH              = core(I+13);  BOT_MARGIN              = core(I+14);  PAGE_LENGTH             = core(I+15);  SCALE_FACTOR            = core(I+16);  SPACING_PERCENT         = shr(core(I+17),8); MEAS_FREQ       = core(I+17) & LBYTE;  MEAS_SYNC           = shr(core(I+18),8) + 1; FIRST_INDENT    = core(I+18) & LBYTE;  BAR_SPACE               = shr(core(I+19),8); FORMAT = FORMAT | (core(I+19) & LBYTE);  /* These are not saved in sequence */  MEDIT_INDEX             = core(I+25);  MEDIT_POINT             = core(I+26);  MEDIT_END               = core(I+27);  EDIT_POSITION           = core(I+28);  MEASURE_NUMBER          = core(I+29);  if PRINTER_TYPE < 2 then PRINTER_TYPE = 2;  if BAR_SPACE = 0 then BAR_SPACE = 4;end LOAD_MAIN_VECTOR;DUMP_MAIN_VECTOR:procedure (LOC) public;  dcl (LOC,P) fixed;  P = LOC - 1;  core(P+1)  = shl(START_CLICK,            8) \ CLICK_TRACK;  core(P+2)  = CLICK_NOTE;  core(P+3)  = shl(BEAT_MEAS,              8) \ BEAT_NOTE;  core(P+4)  = OVERLAP;  core(P+5)  = (FORMAT & UBYTE)               \ NOTE_SPACE/4;  core(P+6)  = shl(PARTS,                  8) \ LISTS;  core(P+7)  = shl(LIST_INDEX(MASTER_PART),8) \ EDIT_RESOLUTION;  core(P+8)  = INIT_PAGE;  core(P+9)  = INIT_MEAS;  core(P+10) = LAST_MEAS;  core(P+11) = shl(PRINTER_TYPE,8)            \ MEAS_LINE;  core(P+12) = LEFT_MARGIN;  core(P+13) = PAGE_WIDTH;  core(P+14) = BOT_MARGIN;  core(P+15) = PAGE_LENGTH;  core(P+16) = SCALE_FACTOR;  core(P+17) = shl(SPACING_PERCENT,8)         \ MEAS_FREQ;  core(P+18) = shl(MEAS_SYNC-1,8)             \ FIRST_INDENT;  core(P+19) = shl(BAR_SPACE,8)               \ (FORMAT & LBYTE);  core(P+25) = MEDIT_INDEX;  core(P+26) = MEDIT_POINT;    core(P+27) = MEDIT_END;  core(P+28) = EDIT_POSITION;  core(P+29) = MEASURE_NUMBER;end DUMP_MAIN_VECTOR;LOAD_PART_VECTOR:procedure (LOC,PART) public;  dcl (LOC,PART,P) fixed;  P = LOC + PART * 16;  TRACK(1)         = shr(core(P)  ,8); TRACK(0)          =  core(P)   & LBYTE;  RESOLUTION(1)    = shr(core(P+1),8); RESOLUTION(0)     =  core(P+1) & LBYTE;  TRANSPOSE(1)     = shr(core(P+2),8); TRANSPOSE(0)      =  core(P+2) & LBYTE;  HEAD_TYPE(1)     = shr(core(P+3),8); HEAD_TYPE(0)      =  core(P+3) & LBYTE;  /* LIST_INDEX(PART) */               STAFF_SPACE(PART) = (core(P+4) & LBYTE) * 3;  CLEF             = shr(core(P+5),8); KEY               =  core(P+5) & LBYTE;  /* Not used but ~0 before F.4     */ SPLIT             =  core(P+6) & LBYTE;  PBITS            = core(P+7);  EDIT_INDEX       = core(P+8);  EDIT_POINT       = core(P+9);  EDIT_END         = core(P+10);  POSN_PTR         = core(P+11);  NOTE_PTR         = core(P+12);  MEASNO_POS       = core(P+13);                                       MEASNO_FORMAT     = core(P+14) & LBYTE;  PLOTBITS         = core(P+15);  KEY          = EXPAND(KEY         ,8);  SPLIT        = EXPAND(SPLIT       ,8);  TRANSPOSE(1) = EXPAND(TRANSPOSE(1),8);  TRANSPOSE(0) = EXPAND(TRANSPOSE(0),8);  TWO_VOICE = false;  ONE_TRACK = false;  if TRACK(0) ~= 0 & TRACK(1) ~= 0 then do;    TWO_VOICE = true;    if TRACK(1) = TRACK(0) then ONE_TRACK = true;  end;  if (CLEF & MASK6) = TABLATURE# then TABLATURE = true;                                 else TABLATURE = false;end LOAD_PART_VECTOR;DUMP_PART_VECTOR:procedure (LOC,PART) public;  dcl (LOC,PART,P) fixed;  P = LOC + PART * 16;  core(P)   = shl(TRACK(1),        8) \ TRACK(0);  core(P+1) = shl(RESOLUTION(1),   8) \ RESOLUTION(0);  core(P+2) = shl(TRANSPOSE(1),    8) \ (TRANSPOSE(0) & LBYTE);  core(P+3) = shl(HEAD_TYPE(1),    8) \ (HEAD_TYPE(0) & LBYTE);  core(P+4) = shl(LIST_INDEX(PART),8) \ ((STAFF_SPACE(PART)/3) & LBYTE);  core(P+5) = shl(CLEF,            8) \ (KEY   & LBYTE);  core(P+6) =                           (SPLIT & LBYTE);  core(P+7) = PBITS;  core(P+8)  = EDIT_INDEX;  core(P+9)  = EDIT_POINT;  core(P+10) = EDIT_END;  core(P+11) = POSN_PTR;  core(P+12) = NOTE_PTR;  core(P+13) = MEASNO_POS;  core(P+14) =                        (MEASNO_FORMAT & LBYTE);  core(P+15) = PLOTBITS;end DUMP_PART_VECTOR;COPY_PART_VECTOR:procedure (SORC_LOC,DEST_LOC) public;  dcl SORC_LOC pointer,      DEST_LOC pointer,      I        fixed;  do I = 1 to (PARTS+1)*16;    core(DEST_LOC) = core(SORC_LOC);    DEST_LOC       = DEST_LOC + 1;    SORC_LOC       = SORC_LOC + 1;  end;end COPY_PART_VECTOR;LOAD_SEQ_RECORD:procedure (P,V) public;  dcl (P,V) fixed;  P            = P * 16 + V * 8;  write(SECT$) = PFIL_BASE + shr(P,8);  write(WORD$) = P;  #NMSB = read(DATI$); #NLSB = read(DATI$);  #LMSB = read(DATI$); #LLSB = read(DATI$);  #WRD  = read(DATI$); #SEC  = read(DATI$);  #ANYF = read(DATI$); #ANYR = read(DATA$) & LBYTE;  #STATUS = shr(read(DATA$),8);end LOAD_SEQ_RECORD;DUMP_SEQ_RECORD:procedure (P,V) public;  dcl (P,V) fixed;  P            = P * 16 + V * 8;  write(SECT$) = PFIL_BASE + shr(P,8);  write(WORD$) = P;  write(DATI$) = #NMSB; write(DATI$) = #NLSB;  write(DATI$) = #LMSB; write(DATI$) = #LLSB;  write(DATI$) = #WRD;  write(DATI$) = #SEC;  write(DATI$) = #ANYF; write(DATI$) = shl(#STATUS,8) \ #ANYR;end DUMP_SEQ_RECORD;LOAD_PRESETS:procedure (LIMIT) public swap;  dcl LIMIT   boolean, /* Limit memory usage (set except from MENU) */      (I,J,K,L) fixed,      COPY    lit 'write("373") = read(DATI$)',      ZERO    lit 'write("373") = 0';  MAIN_BASE = CORE_BASE;  BANK_BASE = MAIN_BASE + 32; /* Leave room for 24 + 8 not-saved words */  TEXT_BASE = BANK_BASE + 72; /* WAS 48 for <= F.1 */  PART_BASE = TEXT_BASE + 4  * 41;  if LIMIT then I = PARTS + 1;           else I = MAX_PARTS;  NAME_BASE = PART_BASE + 16 * I;  CORE_BASE = NAME_BASE + 18 * I;  write(SECT$) = INF.PTR;  write(WORD$) = 3; /* Skip Sectors,Block Length,Field Length */  write("313") = MAIN_BASE;  COPY; COPY; COPY; COPY; COPY;  COPY; COPY; COPY; COPY; COPY;  if MUS_MAG ige REV_D.2# then do; /* 6 more spare words for D.2 and up */    COPY; COPY; COPY; COPY; COPY; COPY;  end;  else do;    ZERO; ZERO; ZERO; ZERO; ZERO; ZERO;  end;  if MUS_MAG ige REV_F.1# then do; /* 8 more spare words for F.1 and up */    COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;  end;  else do;    ZERO; ZERO; ZERO; ZERO; ZERO; ZERO; ZERO; ZERO;  end;  write("313") = BANK_BASE;  do I = 1 to 9;    if (I <= 3) \       (I <= 6 & MUS_MAG ige REV_D.2#) \ /* 6 more banks (user) for D.2 and up */       (MUS_MAG ige REV_F.2#)            /* 6 more banks (aux) for F.2 and up */    then do;      COPY; COPY; COPY; COPY;      COPY; COPY; COPY; COPY;    end;    else do;      ZERO; ZERO; ZERO; ZERO;      ZERO; ZERO; ZERO; ZERO;    end;  end;  if MUS_MAG ilt REV_G.0# then do;    OVERLAY_FILE(0) = 0; K = 3;  end;  else K = 4;  do I = 0 to K;    if I = 4    then write("313") = addr(OVERLAY_FILE(0));    else write("313") = TEXT_BASE + 41 * I;    L = read(DATA$);    do J = 1 to WORD_LEN(L);      COPY;    end;  end;  call LOAD_MAIN_VECTOR (MAIN_BASE);  do PART = 0 to PARTS;    write("313") = PART_BASE + 16 * PART;    write(NOP)   = read(DATI$);    COPY; COPY; COPY; COPY;    COPY; COPY; COPY; COPY;    do I = 0 to 1;      write("313") = NAME_BASE + 18 * PART + 9 * I;      L = read(DATA$);      do J = 1 to WORD_LEN(L);        COPY;      end;      if MUS_MAG = REV_C.1# then do;        core(NAME_BASE + 18 * PART + 9) = 0;        I = 1;      end;    end;  end;  if MUS_MAG ilt REV_E.1# then do;    PAGE_WIDTH   = (OVERLAP & LBYTE);    PAGE_WIDTH   = (shl(PAGE_WIDTH,6) & UBYTE) \ ((PAGE_WIDTH & MASK2) * 50);    PAGE_LENGTH  = shr(OVERLAP,8);    PAGE_LENGTH  = (shl(PAGE_LENGTH,6) & UBYTE) \ ((PAGE_LENGTH & MASK2) * 50);    OVERLAP      = 0;    SCALE_FACTOR = "H0101";  end;  if MUS_MAG ilt REV_F.1# then do;    FORMAT          = FORMAT \ F_FWDR;    SPACING_PERCENT = 20;  end;  call DUMP_MAIN_VECTOR (MAIN_BASE);  MUS_MAG = VERSION_NUMBER;end LOAD_PRESETS;DUMP_PRESETS:procedure public swap;  dcl (I,J,K)  fixed,      LEN      fixed,      MAIN_LEN fixed,      OLD_LEN  fixed,      COPY     lit 'write(DATI$) = read(MR13I)';  write(SECT$) = INF.PTR;  write(WORD$) = 1;  OLD_LEN      = read(DATA$);  LEN          = 1 + 24 + 72; /* Change this whenever preset area changes (this is a little dangerous) */  do I = 0 to 3;    LEN = LEN + WORD_LEN(core(TEXT_BASE + 41 * I));  end;  LEN = LEN + WORD_LEN(OVERLAY_FILE(0));  MAIN_LEN = LEN;  do I = 0 to PARTS;    K = 1 + 8;    do J = 0 to 1;      K = K + WORD_LEN(core(NAME_BASE + 18 * I + 9 * J));    end;    LEN        = LEN + K;    DISPLAY(I) = K; /* DISPLAY is used here as a temp */  end;  I = shr(LEN+2,8) - shr(OLD_LEN,8); /* Signed difference in length (in sects) */  J = EDIT_BASE; if I < 0 then J = J + I;  call XMEM_SECT_SLIDE (J,I);  write(SECT$) = INF.PTR;  write(DATI$) = shr(LEN + 2 + 255,8);  write(DATI$) = LEN + 1;  write(DATI$) = MAIN_LEN;  write(R13) = MAIN_BASE;  COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;  COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;  COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;  write(R13) = BANK_BASE;  do I = 1 to 9;    COPY; COPY; COPY; COPY;    COPY; COPY; COPY; COPY;  end;  do I = 0 to 4;    if I = 4    then write(R13) = addr(OVERLAY_FILE(0));    else write(R13) = TEXT_BASE + 41 * I;    K          = read(MR13);    do J = 1 to WORD_LEN(K);      COPY;    end;  end;  do I = 0 to PARTS;    write(DATI$) = DISPLAY(I);    write(R13) = PART_BASE + 16 * I;    COPY; COPY; COPY; COPY;    COPY; COPY; COPY; COPY; /* 7th word is used & really shouldn't be                               saved in seq */    do J = 0 to 1;      write(R13) = NAME_BASE + 18 * I + 9 * J;      K          = read(MR13);      do K = 1 to WORD_LEN(K);        COPY;      end;    end;  end;end DUMP_PRESETS;LOAD_LIST_INDICES:procedure public swap;  dcl (I,J,L,PRT) fixed;  write(SECT$) = INF.PTR;  write(WORD$) = 2;  L            = 2 + read(DATA$);  write(WORD$) = 2 + 6;  LISTS        = read(DATI$) & LBYTE;  LIST_INDEX(MASTER_PART) = shr(read(DATA$),8);  PRT = MASTER_PART;  do I = 0 to PARTS;    write(SECT$) = INF.PTR + shr(L,8);    write(WORD$) = L;    J            = L + 5;    L            = L + read(DATA$);    write(SECT$) = INF.PTR + shr(J,8);    write(WORD$) = J;    LIST_INDEX(I) = shr(read(DATI$),8);    write(NOP)    = read(DATI$);    write(NOP)    = read(DATI$);    if (read(DATA$) & P_PLOT) ~= 0 & I < PRT then PRT = I;  end;  if PRT = MASTER_PART then PRT = 0;  return (PRT);end LOAD_LIST_INDICES;DUMP_LIST_INDICES:procedure public swap;  dcl (I,J,L) fixed;  write(SECT$) = INF.PTR;  write(WORD$) = 2;  L            = 2 + read(DATA$);  write(WORD$) = 2 + 6;  write(DATI$) = (read(DATA$) & UBYTE) \ LISTS;  write(DATA$) = shl(LIST_INDEX(MASTER_PART),8) \ (read(DATA$) & LBYTE);  do I = 0 to PARTS;    write(SECT$) = INF.PTR + shr(L,8);    write(WORD$) = L;    J            = L + 5;    L            = L + read(DATA$);    write(SECT$) = INF.PTR + shr(J,8);    write(WORD$) = J;    write(DATA$) = shl(LIST_INDEX(I),8) \ (read(DATA$) & LBYTE);  end;end DUMP_LIST_INDICES;COPY_IN:procedure (LOC,LEN) public;           /* COPY BLOCK INTO MAIN MEMORY - SET UP MAM & MAL BEFORE CALLING */   dcl (LOC,LEN) fixed,       COPY      lit 'write(MR13I) = read(DATI$)';   write(R13) = LOC;                     /* SET UP CORE POINTER */   do while LEN ige 16;                    /* COPY 16 WORD CHUNKS */      COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;      COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;      LEN = LEN - 16;   end;   do while LEN > 0; /* FINISH OUT PARTIAL SECTOR */     COPY; LEN = LEN - 1;   end;end COPY_IN;COPY_OUT:procedure (LOC,LEN) public;              /* COPY BLOCK TO EX MEM - SET UP MAM & MAL BEFORE CALLING */   dcl (LOC,LEN) fixed,       COPY      lit 'write(DATI$) = read(MR13I)';   write(R13) = LOC;                     /* SET UP CORE POINTER */   do while LEN ige 16;                    /* COPY 16 WORD CHUNKS */      COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;      COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY;      LEN = LEN - 16;   end;   do while LEN > 0; /* FINISH OUT PARTIAL SECTOR */     COPY; LEN = LEN - 1;   end;end COPY_OUT;COPY_EXT:procedure (SOUM,SOUL,DESM,DESL,LEN) public;  /* HIGH SPEED COPIES - COPIES UP OR DOWN, ANY LENGTH, IN EXTERNAL MEMORY */  dcl (SOUM,SOUL) fixed,      (DESM,DESL) fixed,      (LEN,I)     fixed;   SOUM = SOUM + shr(SOUL,8); SOUL = SOUL & LBYTE;     /* CONVERT FROM BASE + OFFSET TO SECTOR + WORD */   DESM = DESM + shr(DESL,8); DESL = DESL & LBYTE;     /* CONVERT FROM BASE + OFFSET TO SECTOR + WORD */   if SOUM = DESM & SOUL = DESL then return;   /* CHECK HERE FOR EQUAL - NO NEED TO MOVE */   if (SOUM igt DESM) \ (SOUM = DESM & SOUL igt DESL) then do; /* COPY DOWN */      do while LEN ~= 0;                      /* PROCESS DESIRED WORDS */         I = 1024;                            /* GET DISK BUFFER LENGTH IN WORDS */         if I igt LEN then I = LEN;         write(SECT$) = SOUM;         write(WORD$) = SOUL;         call COPY_IN (CORE_BASE,I);          /* GET DATA FROM EX MEM */         SOUM         = read(SECT$);          /* GET CONTINUATION ADDRESS */         SOUL         = read(WORD$);         write(SECT$) = DESM;                 /* SET UP DESTINATION */         write(WORD$) = DESL;         call COPY_OUT (CORE_BASE,I);         /* WRITE DATA OUT */         DESM         = read(SECT$);          /* GET CONTINUATION ADDRESS */         DESL         = read(WORD$);         LEN          = LEN - I;              /* ACCOUNT FOR WORDS COPIED */      end;   end;   ELSE DO; /* COPY UP - MUST START AT TOP AND WORK DOWN */      SOUL=SOUL+LEN; DESL=DESL+LEN; /* COMPUTE TOP POINTERS */      SOUM=SOUM+SHR(SOUL,8); SOUL=SOUL&255;      DESM=DESM+SHR(DESL,8); DESL=DESL&255;      DO WHILE LEN<>0;                          /* PROCESS DESIRED WORDS */         I=1024;                             /* GET DISK BUFFER LENGTH IN WORDS */         IF I IGT LEN THEN I=LEN;         SOUL=SOUL-I;                           /* BACK UP POINTER BY LENGTH TO COPY */         IF SOUL<0 THEN DO;                     /* BACK UP MSB AS WELL */            SOUM=SOUM+("177400"\SHR(SOUL,8));   /* CONSTRUCT - NUMBER, ADD IN */            SOUL=SOUL&255;                      /* GET POSITIVE MSB */         END;         WRITE(SECT$)=SOUM; WRITE(WORD$)=SOUL;         CALL COPY_IN(CORE_BASE,I);               /* GET DATA FROM EX MEM */         DESL=DESL-I;                           /* BACK UP POINTER BY LENGTH TO COPY */         IF DESL<0 THEN DO;                     /* BACK UP MSB AS WELL */            DESM=DESM+("177400"\SHR(DESL,8));   /* CONSTRUCT - NUMBER, ADD IN */            DESL=DESL&255;                      /* GET POSITIVE MSB */         END;         WRITE(SECT$)=DESM; WRITE(WORD$)=DESL; /* SET UP DESTINATION */         CALL COPY_OUT(CORE_BASE,I);         /* WRITE DATA OUT */         LEN=LEN-I;                        /* ACCOUNT FOR WORDS COPIED */      end;   end;end COPY_EXT;COPY_EXT_SECT:procedure (S,D,LEN) public;  dcl (S,D) fixed,      LEN   fixed,      I     fixed;  if S ilt D then do;    S = S + LEN - 1;    D = D + LEN - 1;    do I = 1 to LEN;      call import (S,0,loc(CORE_BASE),256);      call export (D,0,loc(CORE_BASE),256);      S = S - 1;      D = D - 1;    end;  end;  else if S igt D then do I = 1 to LEN;    call import (S,0,loc(CORE_BASE),256);    call export (D,0,loc(CORE_BASE),256);    S = S + 1;    D = D + 1;  end;end COPY_EXT_SECT;XMEM_SECT_SLIDE:procedure (BASE,SECTS) public recursive; /* This could be optimized */  dcl BASE  fixed,      SECTS fixed,      SORC  fixed,      DEST  fixed,      LOCK  boolean static; /* init(0) */  /* Within 32 sects of the top, start cleaning the seq every time */  if ~LOCK & SECTS > 0 & LAST_SECT - (XMEM_BASE + SECTS) < 32 then do;    LOCK = true; /* CleanSeq will (indirectly) call us again */    call CLEAN_SEQUENCE (false);    LOCK = false;  end;  if SECTS < 0 then do;    SECTS = -SECTS;    DEST  = BASE;    SORC  = DEST + SECTS;    do while SORC < XMEM_BASE;      call COPY_EXT (SORC,0,DEST,0,256);      SORC = SORC + 1;      DEST = DEST + 1;    end;    if NAH.PTR igt BASE then do;      /* This would mean editing below the NAH area and should never happen */      NAH.PTR = NAH.PTR - SECTS;      INF.PTR = INF.PTR - SECTS;    end;    else if INF.PTR igt BASE then do; /* Editing in the NAH area */      NAH.LEN = NAH.LEN - SECTS;      INF.PTR = INF.PTR - SECTS;    end;    else INF.LEN = INF.LEN - SECTS; /* Editing in the INF area */    SEQ.LENGTH = SEQ.LENGTH - SECTS;    if EDIT_BASE igt BASE then EDIT_BASE = EDIT_BASE - SECTS;    XMEM_BASE = XMEM_BASE - SECTS;  end;  else if SECTS > 0 then do;    SORC = XMEM_BASE - 1;    DEST = SORC + SECTS;    if DEST = LAST_SECT then call ERROR (ERR_BIGSEQ);    do while SORC >= BASE;      call COPY_EXT (SORC,0,DEST,0,256);      SORC = SORC - 1;      DEST = DEST - 1;    end;    if NAH.PTR ige BASE then do;      /* This would mean editing below the NAH area and should never happen */      NAH.PTR   = NAH.PTR + SECTS;      INF.PTR   = INF.PTR + SECTS;    end;    else if INF.PTR ige BASE then do; /* Editing in the NAH area */      NAH.LEN   = NAH.LEN + SECTS;      INF.PTR   = INF.PTR + SECTS;    end;    else INF.LEN = INF.LEN + SECTS; /* Editing in the INF area */    SEQ.LENGTH = SEQ.LENGTH + SECTS;    if EDIT_BASE ige BASE then EDIT_BASE = EDIT_BASE + SECTS;    XMEM_BASE = XMEM_BASE + SECTS;  end;end XMEM_SECT_SLIDE;XMEM_WORD_SLIDE:procedure (BASE,WORD,LEN) public; /* This could be optimized */  dcl BASE  fixed,      WORD  fixed,      LEN   fixed,      SECTS fixed,      SDIF  fixed,      L     fixed;  if LEN = 0 then return;  write(SECT$) = BASE;  SECTS        = read(DATI$);  L            = read(DATA$);  write(DATA$) = L + LEN;  SDIF         = shr(L + LEN,8) - shr(L,8);  L            = L + 1;  write(WORD$) = 0;  write(DATA$) = SECTS + SDIF;  if LEN < 0 then do;    call COPY_EXT (BASE,WORD-LEN,BASE,WORD,L - (WORD - LEN));    call XMEM_SECT_SLIDE (BASE+SECTS+SDIF,SDIF);  end;  else do;    call XMEM_SECT_SLIDE (BASE+SECTS,SDIF);    call COPY_EXT (BASE,WORD,BASE,WORD+LEN,L - WORD);  end;end XMEM_WORD_SLIDE;end;end GLOBRTNS;