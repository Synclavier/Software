/* Additional Menu Routines */DISPLAY_ERROR:procedure swap;  reverse(1); pos(cmdline,1);  pstring('Error: '); pstring(location(ERR_PTR));  erase_line; reverse(0);  ERR_PTR = null;end DISPLAY_ERROR;BOX:procedure (C1,R1,C2,R2) swap; /* Draw a box on the VT100 given the top left and lower right corners */  dcl (C1,R1,C2,R2,I) fixed; /* Column 1, Row 1, Column 2, Row 2 */  pstring(ALTERNATE_CHARS);                 /* Invoke special graphics character set */  pos(C1,R1); wchar("154");                 /* Draw upper-left corner */  do I = R1+1 to R2-1; wchar("161"); end;   /* Draw horizontal line */  wchar("153");                             /* Draw upper-right corner */  do I = C1+1 to C2-1;                      /* Draw right vertical bar */    if R2 < 79 then wchar(bs);    wchar(lf);    wchar("170");  end;  pos(C1+1,R1);  do I = C1+1 to C2-1; wchar("170"); wchar(bs); wchar(lf); end; /* Draw left vertical bar */  wchar("155");                             /* Draw lower left corner */  do I = R1+1 to R2-1; wchar("161"); end;   /* Draw a horizontal line */  wchar("152"); wchar(cr);                  /* Draw lower left corner */  pstring(NORMAL_CHARS);                    /* Invoke standard ascii set */end BOX;HEADER_BOX:procedure (R1,C1,R2,C2) swap; /* Plot a header box given the top left and lower right corners */ /* A header box is a rectangle with room for headings.   Note: This procedure will not work if column 79 is passed as an argument.*/  dcl (C1,R1,C2,R2,I) fixed; /* Column 1, Row 1, Column 2, Row 2 */  call BOX (R1,C1,R2,C2);    /* Draw a box */  pstring(ALTERNATE_CHARS);  /* Invoke special graphics character set */  pos(R1+2,C1); wchar(lower.t);  /* Draw a left "T" */  do I = C1+1 to C2-1; wchar(lower.q); end;  /* Draw a horizontal line */  wchar(lower.u);            /* Draw a right "T" */  pstring(NORMAL_CHARS);     /* Invoke standard ascii character set */end HEADER_BOX;HORIZONTAL_LINE:procedure (COL) swap;  /* Draws a horizontal line on the VT100 */  dcl (COL,I) fixed;  pstring(ALTERNATE_CHARS); pos(COL,0); /* Invoke special graphics character set and set starting position */  do I = 0 to 79; wchar("161"); end; /* Draw a horizontal line */  pstring(NORMAL_CHARS);      /* Return to standard ascii character set */end HORIZONTAL_LINE;PRINT_DEVICE:procedure (DEV) swap;  dcl DEV     fixed,      NAME(1) fixed,      DNAMES  fixed data ('SCCCF0F1R0R1W0W1');  NAME(0) = 2;  NAME(1) = DNAMES(DEV+1);  pstring(NAME);end PRINT_DEVICE;PRINT_DECIMAL:procedure (D) public swap;  dcl D fixed;  pnum(shr(D,8),0);  wchar(DOT);  D = (D & LBYTE) * 5;  if D < 100 then wchar(asc.0);  if D < 10  then wchar(asc.0);  pnum(D,0);end PRINT_DECIMAL;GET_STR:procedure (MODE,BUFF,LEN) swap; /* Get a character string */   /* This procedure always returns a character; so, it will remember cursor keystrokes */  dcl MODE    boolean,     /* Set for all caps, high bit for no auto-clear */      NOMOD   boolean,     /* No modifications */      BUFF    fixed array, /* Buffer to return string*/      (C,LEN) fixed;       /* Character and maximum length of string */  if rot(MODE,1) then NOMOD = false;          /* So far, no modifications */                 else NOMOD = true;           /* So far, no modifications */  do forever;    C = rchar;            /* Get a character */    if C < sp \ del < C then return (C);  /* If the character is not an ascii  character or it's a carriage return */    else if C = del then do; /* If the character is a delete keystroke */      if NOMOD then BUFF(0) = 0; /* Clear the buffer and initialize the number of characters in the string */      if BUFF(0) > 0 then do;        if BUFF(0) = 80 then wchar(sp);        else do;          wchar(bs); wchar(sp); wchar(bs); /* Delete the character on the terminal */        end;        BUFF(0) = BUFF(0) - 1;          /* Decrease the number of characters in the string */      end;      else return (C);      /* Return the character */    end;    else do;  /* If an ascii character */      if NOMOD then do; BUFF(0) = 0; NOMOD = false; end;   /* Initialize the number of characters in the buffer*/      if BUFF(0) < LEN then do;        if MODE & lower.a <= C & C <= lower.z then C = C - 32; /* If character is lower case, capitalize it */        wchar(C); call pbyte (BUFF,BUFF(0),C);    /* Write it out to the terminal */        BUFF(0) = BUFF(0) + 1;  /* Increase the number of characters in the string */      end;    end;  end;end GET_STR;GET_NUM:procedure swap;  dcl (C,CNT,NUM,MINUS) fixed; /* Character, digit count, number, sign */  NUM = 0; CNT = 0; NUM_VAL = nullint; MINUS = false;  do forever;    C = rchar;    /* Get the character typed in */    if C = asc.min & ~MINUS & CNT = 0 then do; /* If leading minus sign, write it out to the terminal */      wchar(asc.min); MINUS = true;    end;    else if asc.0 <= C & C <= asc.9 then do;       /* If a valid digit */      if CNT < 4 then do; /* Numbers are limited to 4 digits */        wchar(C); NUM = NUM * 10 + (C - asc.0); CNT = CNT + 1; /* Then write it out and determine the numerical value */      end;    end;    else if C = del & (CNT > 0 \ MINUS) then do;  /* If a delete character or a leading minus sign */      wchar(bs); wchar(sp); wchar(bs);            /* Delete the number or minus sign from the terminal*/      if CNT = 0 then MINUS = false;      else do;        NUM = NUM/10; CNT = CNT - 1;         /* Determine the new numerical value */      end;    end;    else do;      if MINUS then NUM = -NUM;      /* If a leading minus sign, negate the numerical value */      if CNT > 0 then NUM_VAL = NUM; /* Update the global variable */      return (C);                    /* Return the character */    end;  end;end GET_NUM;GET_DECIMAL:procedure returns (fixed) swap;  /* Decimals are of the form: shl(Units,8) \ 200ths */  dcl (C,I)  fixed,      CNT(1) fixed,      NUM(1) fixed;  NUM(0) = 0; NUM(1) = 0;  CNT(0) = 0; CNT(1) = 0;  NUM_VAL = nullint; I = 0;  do forever;    C = rchar;    /* Get the character typed in */    if C = dot then do;      if I = 0 then do;        wchar(dot); I = 1;      end;    end;    else if asc.0 <= C & C <= asc.9 then do; /* If a valid digit */      if CNT(I) < 2 \ (I = 1 & CNT(I) < 3 & (C = asc.5 \ C = asc.0)) then do;        wchar(C);        NUM(I) = NUM(I) * 10 + (C - asc.0);        CNT(I) = CNT(I) + 1;      end;    end;    else if C = del & (I = 1 \ CNT(I) > 0) then do;      wchar(bs); wchar(sp); wchar(bs);      if CNT(I) = 0 then I = 0;      else do;        NUM(I) = NUM(I) / 10;        CNT(I) = CNT(I) - 1;      end;    end;    else do;      if CNT(0) > 0 \ CNT(1) > 0 then do;        if CNT(1) > 0 then do I = CNT(1) to 2;          NUM(1) = NUM(1) * 10;        end;        NUM_VAL = shl(NUM(0),8) \ (NUM(1) / 5);      end;      return (C);    end;  end;end GET_DECIMAL;COPY_PART:procedure (SORC,DEST) swap; /* Duplicates a part entry from an indicated source to destination */  dcl (SORC,DEST) pointer,    /* Source, Destination */      COPY        lit 'write(MR13I) = read(MR0I)';    /* Copy from sorce to destination and auto increment both registers */  write(R0)  = SORC;   /* Load source into register R0 */  write(R13) = DEST;   /* Load destination into register R13 */  COPY; COPY; COPY; COPY; /* Copy the entire part entry */  COPY; COPY; COPY; COPY;end COPY_PART;COPY_NAME:procedure (SORC,DEST) swap;  /* Duplicates an instrument name and abbreviation for a part given the source and destination */  dcl (SORC,DEST) pointer,      COPY        lit 'write(MR13I) = read(MR0I)';  /* Copy from source to destination and auto increment both registers */  write(R0)  = SORC;  write(R13) = DEST;  COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY; /* Copy the instrument name */  COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY; COPY; /* Copy the instrument abbrev */end COPY_NAME;DEFAULTS_TO_BUFF:procedure swap; /* Copy default part settings into the holding buffer */  call COPY_PART (addr(PART_DEFAULTS(1)),BUFF_BASE); /* Copy default part settings into holding buffer */  core(BUFF_BASE+16)   = 0; /* Clear the instrument name */  core(BUFF_BASE+16+9) = 0; /* and abbreviation          */  BUFF_LIST = 0;end DEFAULTS_TO_BUFF;PART_TO_BUFF:procedure swap;  /* Copy the current part and name setting to the holding buffer */  call COPY_PART (PART_BASE + PART * 16,BUFF_BASE);  call COPY_NAME (NAME_BASE + PART * 18,BUFF_BASE + 16);  BUFF_LIST = LIST_INDEX(PART);end PART_TO_BUFF;INSERT_BUFF:procedure swap; /* Insert a part into the preset area in memory */  dcl (I,J) fixed;  dcl (S,D) fixed;  I = PARTS; /* Ah, the curse of not having negative increment loops */  do while I >= PART;    J = PART_BASE + I * 16;    call COPY_PART (J,J + 16);    J = NAME_BASE + I * 18;    call COPY_NAME (J,J + 18);    LIST_INDEX(I+1) = LIST_INDEX(I);    I = I - 1;  end;  call COPY_PART (BUFF_BASE,     PART_BASE + PART * 16);  /* Get part from holding buffer */  call COPY_NAME (BUFF_BASE + 16,NAME_BASE + PART * 18);  /* Get name from holding buffer */  PARTS = PARTS + 1; /* Increment the number of parts */  if BUFF_LIST ~= 0 then do;    LISTS            = LISTS + 1;    LIST_INDEX(PART) = LISTS;    S                = FIND_LIST_SECT (EDIT_BASE,BUFF_LIST);  /* Determine the source */    D                = FIND_LIST_SECT (EDIT_BASE,LISTS);      /* Determine the destination *//* OLD WAY -- WRONG?!?    write(SECT$)     = I;    XMEM_BASE        = J + read(DATI$);    if XMEM_BASE = LAST_SECT then call ERROR (ERR_BIGSEQ);    call COPY_EXT (I,0,J,0,read(DATA$)+1);*/    write(SECT$) = S;    I            = read(DATI$); /* Get sector length */    J            = read(DATA$); /* Get word length */    call XMEM_SECT_SLIDE (D,I);    call COPY_EXT (S,0,D,0,J+1);  end;  else LIST_INDEX(PART) = 0;end INSERT_BUFF;CLEAR_BUFF:procedure swap;  dcl I fixed;  if BUFF_LIST = 0 then return;  do I = 0 to PARTS;    if LIST_INDEX(I) = BUFF_LIST then return;  end;  if LIST_INDEX(MASTER_PART) = BUFF_LIST then return;  call DELETE_EDIT_LIST (BUFF_LIST);  BUFF_LIST = 0;end CLEAR_BUFF;DELETE_PART:procedure swap; /* Delete a part from the preset area */  dcl (I,J) fixed;  call DELETE_EDIT (PART);  /* Delete an edit list from the sequence */   PARTS = PARTS - 1;  do I = PART to PARTS;    J = PART_BASE + I * 16;    call COPY_PART (J + 16,J);       /* Copy the part */    J = NAME_BASE + I * 18;    call COPY_NAME (J + 18,J);       /* Copy the name */    LIST_INDEX(I) = LIST_INDEX(I+1); /* Copy the list index */  end;end DELETE_PART;