/* $title List Building Routines *//* Additional list building routines */FREE:procedure (P); /* Free a record */  dcl P pointer;  core(FREE_TAIL) = P;  core(P)         = null;  FREE_TAIL       = P;end FREE;FREE_POSN:procedure (P,T) public recursive;  dcl (P,Q,T) pointer,      FLAG       boolean;  if P = null then return;  FLAG = true;  do while FLAG;    Q = core(P+GRP);    do while Q ~= null & (core(Q+D6) & B_SOT) = 0;      Q = core(Q+GRP);    end;    if Q ~= null then call FREE_POSN (Q,null);    Q = P;    if P = T \ (core(P+D6) & B_EOL) ~= 0    then FLAG = false;    else P    = core(P);    call FREE (Q);  end;end FREE_POSN;FREE_NOTE:procedure (P,T) public recursive;  dcl (P,T,Q,LQ,H) pointer,      V          fixed,      FLAG       boolean;  if P = null then return;  FLAG = true;  do while FLAG;    if (core(P+D6) & B_TUP) ~= 0 then do V = 0 to 1;      Q = core(P+D1+V);      if Q ~= null then call FREE_NOTE (Q,null);    end;    Q = P;    if P = T \ (core(P+D6) & B_EOT) ~= 0    then FLAG = false;    else P    = core(P);    do while Q ~= null;      LQ = Q;      Q  = core(Q+GRP);      /* Invalidate Heap record back pointer if it points to this note */      H = HEAP_HEAD;      do while H ~= null;        if core(H+D0) = LQ then core(H+D0) = null;        H = core(H);      end;      call FREE (LQ);    end;  end;end FREE_NOTE;ALLOCATE:procedure;  dcl P pointer;  if FREE_HEAD = null then do; /* Allocate a new record */    if CORE_BASE + 9 igt loc.load then call ERROR (ERR_NOROOM);    P         = CORE_BASE;    CORE_BASE = CORE_BASE + 9;  end;  else do;    P         = FREE_HEAD;    FREE_HEAD = core(FREE_HEAD);    if FREE_HEAD = null then FREE_TAIL = addr(FREE_HEAD);  end;  write(R0)   = P;             /* Destination = P        */  write(R13)  = addr(REC(D0)); /* Source      = REC(D0)  */  write(MR0I) = null;          /* core(P+0)   = null     */  write(MR0I) = read(MR13I);   /* core(P+1)   = REC(D0)  */  write(MR0I) = read(MR13I);   /* core(P+2)   = REC(D1)  */  write(MR0I) = read(MR13I);   /* core(P+3)   = REC(D2X) */  write(MR0I) = read(MR13I);   /* core(P+4)   = REC(D2)  */  write(MR0I) = read(MR13I);   /* core(P+5)   = REC(D3)  */  write(MR0I) = read(MR13I);   /* core(P+6)   = REC(D4)  */  write(MR0I) = read(MR13I);   /* core(P+7)   = REC(D5)  */  write(MR0I) = read(MR13I);   /* core(P+8)   = REC(D6)  */  return (P);end ALLOCATE;GET_DURATION:procedure returns (fixed);  dcl (DURATION,I) fixed;  DURATION = (shr(#W1,1) & "006000") \ shr(#W2,6);  do I = 1 to (rot(#W1,3) & MASK2);    write(5) = DURATION;    write(6) = 4;    if read(4) ~= 0 then do;      DURATION = -1; I = 3;    end;    else DURATION = read(5);  end;  return (DURATION);end GET_DURATION;GET_TIE_CODE:procedure;  dcl (TIE_CODE,R) fixed;  TIE_CODE = 0; R = RACK;  do while R;    if TIE_CODE = 15 then return (-1);    R = shr(R,1); TIE_CODE = TIE_CODE + 1;  end;  RACK = RACK \ shl(1,TIE_CODE);  return (TIE_CODE);end GET_TIE_CODE;GET_LIST_LEN:procedure (H,T) returns (fixed);  dcl (H,T)     pointer,      LEN       fixed,      FLAG      boolean;  LEN  = 0;  FLAG = true;  do while FLAG;    LEN = LEN + shr(core(H+D4),8) + (core(H+D4) & LBYTE);    if H = T then FLAG = false;    H = core(H);  end;  return (LEN);end GET_LIST_LEN;GET_SEG_LEN:procedure (P,BLKS,LIMIT); /* This is redundant as all hell ^^^ */  dcl P         pointer,      BLKS      fixed,      LIMIT     fixed, /* Same as in JSTIFY */      LEN       fixed,      I         fixed,      USE_BUFF  boolean;  /* LIMIT = 0 -->  #|# #|# ... #|# #|#     LIMIT = 1 -->   |# #|# ... #|# #|#     LIMIT = 2 -->  #|# #|# ... #|# #|     LIMIT = 3 -->   |# #|# ... #|# #|         */  if P = null then do;    USE_BUFF = true;    P        = BUFF(0);  end;  else USE_BUFF = false;  if BLKS = 1 & LIMIT = 3 then LIMIT = 2; /* BLKS = 1 & LIMIT = 3 wouldn't do anything */  LEN = 0;  do I = 1 to BLKS;    if LIMIT = 0 \ LIMIT = 2 \ I > 1    then LEN = LEN + shr(core(P+D4),8);    if LIMIT = 0 \ LIMIT = 1 \ I < BLKS then LEN = LEN + (core(P+D4) & LBYTE);    if USE_BUFF then P = BUFF(I);                else P = core(P);    if P = null then I = BLKS; /* Safety measure */  end;  return (LEN);end GET_SEG_LEN;NOTE_TIE_DOWN:procedure (P,LAST_P) returns (pointer) recursive;  dcl (P,Q,R,L) pointer,      LAST_P    pointer,      OLD       fixed;  do while P ~= null;    if (core(P+D6) & B_TUP) ~= 0 then do VOICE = 0 to 1;      Q = core(P+D1+VOICE);      if Q ~= null then do;        OLD = shr(core(P+D5+VOICE),8);        R   = P;        do while OLD > 0;          OLD = OLD - (core(R+D5) & LBYTE);          R = core(R);        end;        if R = null then core(NOTE_TIE_DOWN(Q,LAST_P)) = LAST_P;                    else core(NOTE_TIE_DOWN(Q,R))      = R;      end;    end;    L = P;    P = core(P);  end;  return (L);end NOTE_TIE_DOWN;POSN_TIE_DOWN:procedure (P,LEAD_P,TAIL_P,LEVEL) recursive;  dcl P      pointer,      LEAD_P pointer,      TAIL_P pointer,      (Q,R)  pointer,      LEVEL  fixed,      (I,J)  fixed,      FLAG   boolean;  core(P+REV) = LEAD_P; FLAG = true;  do while FLAG;    Q = core(P+GRP);    do while Q ~= null;      if (shr(core(Q+D6),4) & MASK4) = LEVEL & (core(Q+D6) & B_SOT) ~= 0 then do;        /* This may be redundant, since EOL should be set if FWD = null */        /* Don't forget that EOL = EOT! */        R = P; J = core(Q+D5) & LBYTE; /* Old */        do I = 1 to J; /* Loop over Old */          if (core(R+D6) & B_EOL) ~= 0 then do;            I = J; R = null;          end;          else R = core(R);        end;        if R = null then call POSN_TIE_DOWN (Q,LEAD_P,TAIL_P,LEVEL+1);                    else call POSN_TIE_DOWN (Q,LEAD_P,R     ,LEVEL+1);      end;      Q = core(Q+GRP);    end;    LEAD_P = P;    core(P+D6) = (core(P+D6) & "176377") \ shl(LEVEL,8); /* VoiceOffset field becomes Level field */    if (core(P+D6) & B_EOL) ~= 0 then FLAG = false;                                 else P    = core(P);  end;  if LEVEL > 0 then core(P) = TAIL_P;end POSN_TIE_DOWN;JUSTIFY:procedure (P,BLKS,ADD,LIMIT);  dcl P        pointer, /* Points to first record to include */      BLKS     fixed,   /* Number of blocks to include */      ADD      fixed,   /* Number of units (pixels) to distribute */      LIMIT    fixed,   /* Switch to exclude first or last half record */      SBLKS    fixed,      LAST     fixed,      NEXT     fixed,      (A,I,J)  fixed,      PRE      boolean, /* Set to add to PRE field, reset to add to POST field */      USE_BUFF boolean; /* Set to read pointer list from BUFF */  /* LIMIT = 0 -->  #|# #|# ... #|# #|#     LIMIT = 1 -->   |# #|# ... #|# #|#     LIMIT = 2 -->  #|# #|# ... #|# #|     LIMIT = 3 -->   |# #|# ... #|# #|         */  if ADD <= 0 then return;  if BLKS = 1 & LIMIT = 3 then LIMIT = 2; /* BLKS = 1 & LIMIT = 3 wouldn't do anything */  SBLKS = BLKS * 2;  if LIMIT = 3 then SBLKS = SBLKS - 1;  if LIMIT > 0 then SBLKS = SBLKS - 1;  if LIMIT = 1 or LIMIT = 3 then PRE = false;                            else PRE = true;  if P = null then do;    USE_BUFF = true;    P        = BUFF(0);  end;  else USE_BUFF = false;  LAST = 0; J = 1;  do I = 1 to SBLKS;    NEXT = SIEVE(ADD,SBLKS,I);    if PRE then A = shl(NEXT - LAST,8);           else A = NEXT - LAST;    core(P+D4) = core(P+D4) + A;    LAST       = NEXT;    if PRE then PRE = false;    else do;      if USE_BUFF then P = BUFF(J);                  else P = core(P);      if P = null then I = SBLKS; /* Safety measure */      PRE = true;      J   = J + 1;    end;  end;end JUSTIFY;SPACE:procedure (PP,NP,FIRST_BLOCK,SPACING); /* This could REALLY use cleaning up (no fooling) */  dcl (PP,NP)     pointer,      (EP,P)      pointer,      SPACING     fixed array,      (Y,LY,I)    fixed,      SLEW        fixed,      PRE         fixed, /* Remove these */      POST        fixed, /*     ""       */      TOP         fixed,      BOT         fixed,      TOP_V       fixed,      BOT_V       fixed,      ACC         fixed,      REST(1)     fixed,      MAX_ACC_OFF fixed,      ACC_OFF     fixed,      VOX_OFF     fixed,      REV_OFF     fixed,      FWD_OFF     fixed,      FIRST_BLOCK boolean,      ACC_FLAG    boolean,      DOT_FLAG    boolean;  if (core(NP+D6) & B_SPACED) ~= 0 then do;    SPACING(1) = 0;    SPACING(0) = 0;    return;  end;  core(NP+D6) = core(NP+D6) \ B_SPACED;/*PRE     = shr(NOTE_SPACE,1); POST    = PRE + (NOTE_SPACE & MASK1);*/  PRE     = 0;                 POST    = 0;  REV_OFF = 0;                 FWD_OFF = 0;  REST(0) = null;              REST(1) = null;  /* Space stem down chord (Voice 0) */  P = NP; LY = -1; TOP = -1;  do while P ~= null;    if (core(P+D6) & B_REST) ~= 0 then REST(core(P+D6) & MASK1) = P;    else if (core(P+D6) & B_DIR) ~= 0 & (core(P+D6) & B_TUP) = 0    then do;      Y = core(P+D2) & LBYTE;      if TOP = -1 then do;        TOP   = Y;        TOP_V = shr(core(P+D2),8) & MASK4;      end;      if LY = -1 \ LY - Y >= 6 then LY = Y;      else do;        core(P+D5) = core(P+D5) \ B_NOFF;        if (core(P+D2) & THRD4) = 0 then REV_OFF = 24; /* was 26 */                                    else REV_OFF = 16; /* was 22 */      end;    end;    EP = P; P = core(P+GRP);  end;  /* Space stem up chord (Voice 1), setting voice1 offset */  P = EP; LY = -1; BOT = -1;  do while P ~= null;    if (core(P+D6) & B_DIR) = 0 & (core(P+D6) & (B_REST \ B_TUP)) = 0    then do;      Y = core(P+D2) & LBYTE;      if BOT = -1 then do;        BOT   = Y;        BOT_V = shr(core(P+D2),8) & MASK4;      end;      if LY = -1 \ Y - LY >= 6 then LY = Y;      else do;        core(P+D5) = core(P+D5) \ B_NOFF;        if (core(P+D2) & THRD4) = 0 then FWD_OFF = 24; /* was 26 */                                    else FWD_OFF = 16; /* was 22 */      end;    end;    if P = NP then P = null; else P = core(P);  end;  if REST(0) ~= null & REST(1) ~= null then do;    if (core(REST(0)+D2) & THRD4) = (core(REST(1)+D2) & THRD4) then do;      REST(0) = S3; REST(1) = S3;    end;    else do;      REST(0) = S1; REST(1) = S4;    end;  end;  else if REST(0) ~= null then do;    if BOT = -1 then REST(0) = S3;    else do;      REST(0) = BOT - 18;      REST(0) = REST(0) - (REST(0) mod 6) + 3;      if REST(0) > S1 then REST(0) = S1;    end;  end;  else if REST(1) ~= null then do;    if TOP = -1 then REST(1) = S3;    else do;      REST(1) = TOP + 24; /* WAS 18 */      REST(1) = REST(1) - (REST(1) mod 6) - 3;      if REST(1) < S4 then REST(1) = S4;    end;  end;  /* This thing just gets worse and worse.  This next bit keeps suppressed     rests from pushing the unsuppressed rests around */  if NP ~= EP & ((core(NP+D6) & B_CREST) ~= 0 \ (core(EP+D6) & B_CREST) ~= 0)  then do; REST(0) = S3; REST(1) = S3; end;  /* Add offset to voice1 notes and find dots */  if TOP_V = WHOLE# then TOP_V = -1;  if TOP_V >= QUARTER# & BOT_V >= QUARTER# then TOP_V = BOT_V;  DOT_FLAG = false; VOX_OFF = 0;  if TOP > -1 & BOT > -1 then do;    if      BOT - TOP = 3 then VOX_OFF = 3;    else if TOP > BOT \ (TOP = BOT & TOP_V ~= BOT_V) then VOX_OFF = 2; /* Don't superimpose dissimilar notes */  end;  /* Set accidental spacing */  P           = NP;  LY          = -1;  MAX_ACC_OFF = 0;  ACC_OFF     = 0;  ACC_FLAG    = false;  if (core(P+D6) & B_TUP) ~= 0 then P = core(P+GRP); /* Tup rec will always be at top of chord */  do while P ~= null;    Y = core(P+D2) & LBYTE;    ACC = shr(core(P+D4),8) & MASK4;    if ACC ~= 0 then do;      ACC_FLAG = true;      if LY = -1 \ LY - Y > 15 then do;        LY = Y; ACC_OFF = 0;      end;      I = ACC_OFF; if REV_OFF ~= 0 \ VOX_OFF = 3 then I = I + 1;      core(P+D4) = core(P+D4) \ shl(I,12);      if ACC = DOUB_FLAT#      then do; ACC_OFF = ACC_OFF + 2; LY = LY + 6; end;      else ACC_OFF = ACC_OFF + 1;      if MAX_ACC_OFF < ACC_OFF then MAX_ACC_OFF = ACC_OFF;    end;    if (core(P+D6) & B_DOT) ~= 0 then DOT_FLAG = true;    if core(P+D6) then core(P+D5) = core(P+D5) \ shl(VOX_OFF,8); /* If voice 1 */    if (core(P+D6) & B_CREST) ~= 0 then do;      if NP = EP \ (core(NP+D6) & B_CREST) = (core(EP+D6) & B_CREST)      then do; PRE = 0; POST = 0; end;      else core(P+D6) = core(P+D6) \ B_ROFF;    end;    else if (core(P+D6) & B_REST) ~= 0    then core(P+D2) = (core(P+D2) & UBYTE) \ (REST(core(P+D6) & MASK1) + EXPAND (Y,8));    P = core(P+GRP);  end;/* This is the way it used to work */  if ACC_FLAG then PRE  = PRE  + 12 + MAX_ACC_OFF*8;  if DOT_FLAG then POST = POST + 10;/* This changed because accds & dots shouldn't take up room if they can help it *//*  I = 12 + MAX_ACC_OFF*8;  if FIRST_BLOCK then I = I + 6; * *** WAS 4 *** This keeps accs from hitting bars to left *  I = I - NOTE_SPACE;  if ACC_FLAG & I > 0 then PRE  = PRE  + I;  I = 12 - NOTE_SPACE;  if DOT_FLAG & I > 0 then POST = POST + I;*/  if REV_OFF ~= 0 \ VOX_OFF = 3 then do;     core(PP+D6) = core(PP+D6) \ B_RNOT;    if REV_OFF ~= 0 then PRE = PRE + REV_OFF;                    else PRE = PRE + 8;  end;  if FWD_OFF ~= 0 then do;     core(PP+D6) = core(PP+D6) \ B_FNOT;    POST = POST + FWD_OFF;  end;  Y = shr(core(PP+D6),8) & MASK2;  if Y < VOX_OFF & VOX_OFF < 3  then core(PP+D6) = (core(PP+D6) & "176377") \ shl(VOX_OFF,8);/*  Y = shr(core(PP+D4),8);  I = PRE - (Y + SLEW); if I < 0 then I = 0;  PRE = Y + I;*//*  Y = shr(core(PP+D4),8);  if Y > PRE  then PRE  = Y;  Y = core(PP+D4) & LBYTE; if Y > POST then POST = Y;  core(PP+D4) = shl(PRE,8) \ POST;*/  SPACING(1) = PRE;  SPACING(0) = POST;end SPACE;SET_SPACING:procedure (P,Q,FIRST_BLOCK) recursive;  dcl (P,TP)      pointer, /* Position list */      (Q,TQ)      pointer, /* Note list */      RP(2)       pointer,      SPACING(1)  fixed,      LEVEL       fixed,      BLKS        fixed,      ADD         fixed,      MIN         fixed,      (I,J)       fixed,      FIRST_BLOCK boolean, /* Set for first block in measure */      (FLAG,F)    boolean;  BLKS    = 0;  ADD     = 0;  MIN     = 0;  FLAG    = true;  BUFF(0) = P;  do while FLAG;    F = true;    do while F & (core(Q+D6) & B_TUP) ~= 0;      TQ = core(Q+D1+VOICE); /* Get NoteSublist pointer */      if TQ ~= null then do;        TP = P; /* Get PosFrond pointer */        do I = 1 to (core(Q+D3+VOICE) & LBYTE);          TP = core(TP+GRP);        end;        do I = 1 to shr(core(Q+D5+VOICE),8); /* Get return pos pointer */          P = core(P);        end;        RP(LEVEL) = P;        LEVEL     = LEVEL + 1;        Q = TQ; P = TP;      end;      else F = false;    end;    call SPACE (P,Q,FIRST_BLOCK,SPACING);    FIRST_BLOCK   = false;    ADD = ADD + SPACING(1);    MIN = MIN + shr(NOTE_SPACE,1);    if BLKS > 1    then MIN = MIN + (NOTE_SPACE * (BLKS-1) * SPACING_PERCENT *                     RESOLUTION(VOICE)) / (EDIT_RESOLUTION * 100);    if MIN > ADD then ADD = MIN;    I   = GET_SEG_LEN (null,BLKS+1,3);    call JUSTIFY (null,BLKS+1,ADD-I,3);    ADD = SPACING(0);    MIN = shr(NOTE_SPACE,1) + (NOTE_SPACE & MASK1);        BLKS    = core(Q+D5) & LBYTE;    BUFF(0) = P;    do I = 1 to BLKS;      if LEVEL = 0 & (core(P+D6) & B_BAR) ~= 0 then FLAG = false;      else if LEVEL > 0 & (core(P+D6) & B_EOL) ~= 0 then do; /* Decend a tup level */        P = core(P);        do while P = null & LEVEL > 0;          LEVEL = LEVEL - 1;          P     = RP(LEVEL);        end;        I = BLKS; /* Safety measure */      end;      else P = core(P);      BUFF(I) = P;      if P = null then do;        I = BLKS; /* Safety measure */        FLAG = false;      end;    end;    Q = core(Q);  end;  if BLKS > 1  then MIN = MIN + (NOTE_SPACE * (BLKS-1) * SPACING_PERCENT *                   RESOLUTION(VOICE)) / (EDIT_RESOLUTION * 100);  if MIN > ADD then ADD = MIN;  I = GET_SEG_LEN (null,BLKS,1);  call JUSTIFY (null,BLKS,ADD-I,1);end SET_SPACING;ALIGN_AXIS:procedure (PP,LEVEL,ENLARGE) recursive;  dcl (PP,P)    pointer,      LEVEL     fixed,      PRE       fixed,      POST      fixed,      XTRA      fixed,      BITS      fixed,      NEW       fixed,      OLD       fixed,      (OL,NL,I) fixed,      ENLARGE   boolean,      FLAG      boolean;  FLAG = true; P = PP;  do while FLAG;    PRE  = shr(core(P+D4),8);    POST = core(P+D4) & LBYTE;    if ENLARGE then do; /* This should be optimized */      I = NOTE_SPACE / 4; /* Change here to adjust block rest size? */      if PRE  < I then PRE  = I;      if POST < I then POST = I;    end;    XTRA = 0;    BITS = core(P+D6);    if (BITS & B_BAR) ~= 0 then do;      POST = POST + 2*BAR_SPACE; XTRA = BAR_SPACE;/* Do we want to do these in a frond since these bits are use for LEVEL? *//*    if LEVEL = 0 then do; */        if (BITS & B_DBAR) ~= 0 then     POST = POST + 3;        if (BITS & B_OREP) ~= 0 then do; POST = POST + 10; XTRA = XTRA + 10; end;        if (BITS & B_CREP) ~= 0 then     POST = POST + 10;        if (BITS & B_TIME) ~= 0 then     POST = POST + TIMESIG_GAP + 4;        if (BITS & B_EBAR) ~= 0 then     POST = POST + 7;/*    end; */    end;    I = shr(BITS,8) & MASK2;    if I < 3 then POST = POST + I * 4;/*  if (BITS & B_RNOT) ~= 0 then PRE  = PRE  + 8; *//*  if (BITS & B_FNOT) ~= 0 then POST = POST + 8; */    if (BITS & B_CLEF) ~= 0 then      if PRINTER_TYPE > 1 then POST = POST + 18; /* Small clefs */                          else POST = POST + 24; /* Large clefs */    if (core(P+D3) & FRTH4) ~= 0    then POST = POST + shr(core(P+D3) & FRTH4,9); /* FRTH4 field * 8 *//*  then POST = POST + (shr(core(P+D3),12) & MASK4) * 8; * Could use a shift */    core(P+D4) = shl(PRE,8) \ POST;    core(P+D3) = (core(P+D3) & ~THRD4) \ shl(XTRA/2,8);    if (core(P+D6) & (B_EOL\B_BAR)) ~= 0 then FLAG = false;/*    LEN = LEN + PRE + POST; */    P   = core(P);  end;  FLAG = true;  do while FLAG;    PRE = shr(core(PP+D4),8);    P   = core(PP+GRP);    do while P ~= null & (core(P+D6) & B_SOT) ~= 0 &             (shr(core(P+D6),4) & MASK4) = LEVEL;      call ALIGN_AXIS (P,LEVEL+1,false);      I = shr(core(P+D4),8);      if I < PRE then core(P +D4) = shl(PRE,8) \ (core(P +D4) & LBYTE);      if PRE < I then core(PP+D4) = shl(I,8)   \ (core(PP+D4) & LBYTE);      NEW = shr(core(P+D5),8);      OLD = core(P+D5) & LBYTE;      NL  = GET_SEG_LEN ( P,NEW,0);      OL  = GET_SEG_LEN (PP,OLD,0);/*      if NL > OL then do; */          call JUSTIFY (PP,OLD,NL-OL,1);/*        LEN = LEN + (NL-OL); *//*      end; */      P = core(P+GRP);    end;    if (core(PP+D6) & (B_EOL\B_BAR)) ~= 0 then FLAG = false;    PP = core(PP);  end;end ALIGN_AXIS;ALIGN_FRONDS:procedure (PP,LEVEL) recursive;  dcl (PP,P) pointer,      LEVEL  fixed,      NL     fixed,      OL     fixed,      NEW    fixed,      OLD    fixed,      PRE    fixed,      I      fixed,      FLAG   boolean;  FLAG = true;  do while FLAG;    PRE = shr(core(PP+D4),8);    P   = core(PP+GRP);    do while P ~= null & (core(P+D6) & B_SOT) ~= 0 &             (shr(core(P+D6),4) & MASK4) = LEVEL;      I = shr(core(P+D4),8);      if I < PRE then core(P +D4) = shl(PRE,8) \ (core(P +D4) & LBYTE); /* Are both of these necessary? */      if PRE < I then core(PP+D4) = shl(I,8)   \ (core(PP+D4) & LBYTE);      NEW = shr(core(P+D5),8);      OLD = core(P+D5) & LBYTE;      NL  = GET_SEG_LEN ( P,NEW,0);      OL  = GET_SEG_LEN (PP,OLD,0);      call JUSTIFY (P,NEW,OL-NL,1);      call ALIGN_FRONDS (P,LEVEL+1);      P = core(P+GRP);    end;    if (core(PP+D6) & B_EOL) ~= 0 then FLAG = false;    PP = core(PP);  end;end ALIGN_FRONDS;JUSTIFY_LINE:procedure (MAX_LEN) returns (fixed);  dcl MAX_LEN    fixed,      LINE_LEN   fixed,      TL         fixed,      NAME_WIDTH fixed,      CLEF_WIDTH fixed,      (BL,SL)    fixed,      (P,Q)      fixed,      (X,I,J)    fixed,      RECS       fixed,      MEAS       fixed,      FLAG       boolean;  /* Set first position record to reflect clef, keysig etc. */  TL = 0;  BL = 0; SL = 0;  NAME_WIDTH = 0;  CLEF_WIDTH = 0;  do STAFF = 0 to STAVES;    PART = DISPLAY(STAFF);    call LOAD_PART_VECTOR (PLOT_PART_BASE,PART);    I = NAME_BASE + PART * 18;    if MEASURE_NUMBER > 1 then I = I + 9;    if PRINTER_TYPE > 1 then J = F_STANDARD#; else J = F_ALPHA#;    J = STRING_LEN (location(I),J);    if NAME_WIDTH < J then NAME_WIDTH = J;    if (CLEF & INVISIBLE#) = 0 then CLEF_WIDTH = 24; /* Same for all clefs */    if (PBITS & (P_OBRC \ P_CBRC)) = (P_OBRC \ P_CBRC) then J = true;    if (PBITS & (P_OBRC \ P_CBRC)) ~= 0 & ~J then BL = 9; /* Room for brace */    if (PBITS & (P_OBAR \ P_CBAR)) ~= 0 | J then SL = 5; /* Room for bracket */  end;  if STAVES > 0 then do; /* If a real system (2 or more staves) */    TL = BL + SL;    if NAME_WIDTH > 0 then TL = TL + NAME_WIDTH + 4;  end;  if MEASURE_NUMBER = 1 & TL < FIRST_INDENT*4 then TL = FIRST_INDENT*4;  START_STAFF(SYSTEM) = TL;  TL = TL + CLEF_WIDTH;  if      (core(POS_HEAD+D3) & B_HTIM) ~= 0 then TL = TL + TIMESIG_GAP;  if      (core(POS_HEAD+D3) & B_HREP) ~= 0 then TL = TL + 14;  else if (core(POS_HEAD+D3) & B_HDBR) ~= 0 then TL = TL + 10;  J = shr(core(POS_HEAD+D4),8); /* Basic pre offset of 1st note */  I = shr(core(POS_HEAD+D6),5) & MASK3; /* Keysig width in accd's */  if I > 0 then TL = TL + I*8 + 4; /* WAS 8 */  if J < 16 then J = 12;  TL = TL + J;  if TL > 255 then do;    START_STAFF(SYSTEM) = START_STAFF(SYSTEM) - (TL - 255); TL = 255;  end;  core(POS_HEAD+D4) = shl(TL,8) \ (core(POS_HEAD+D4) & LBYTE);  /* Find out how many measures will fit on a line */  P        = POS_HEAD; Q    = null;  LINE_LEN = 0;        X    = 0;  MEAS     = 0;        I    = 0;  FLAG     = true;  do while FLAG;    I = I + 1;    X = X + shr(core(P+D4),8) + (core(P+D4) & LBYTE);    if (core(P+D6) & B_BAR) ~= 0 then do;      if Q ~= null &         (X - (shr(core(P+D3),8) & MASK4)*2 > MAX_LEN)      then FLAG = false;      else do;        LINE_LEN = X; RECS = I; Q = P;        if (core(P+D6) & B_SOT) = 0 then MEAS = MEAS + 1;        if MEAS_LINE > 0 & MEAS >= MEAS_LINE then FLAG = false;      end;      if (core(P+D6) & B_EOL) ~= 0 then FLAG = false;    end;    if P = POS_TAIL then FLAG = false;                    else P    = core(P);  end;  X = (shr(core(Q+D3),8) & MASK4) * 2;  LINE_LEN   = LINE_LEN   - X;  core(Q+D3) = core(Q+D3) & ~THRD4;  core(Q+D4) = core(Q+D4) - X;  core(Q+D6) = core(Q+D6) \ B_EOL;  POS_LINE   = Q;  STOP_STAFF(SYSTEM) = LINE_LEN;  if core(Q) ~= null \ LINE_LEN*2 > MAX_LEN \ (FORMAT & F_END) = 0  then do; /* Justify unless a short last line */    STOP_STAFF(SYSTEM) = MAX_LEN;    call JUSTIFY (POS_HEAD,RECS,MAX_LEN-LINE_LEN,0);  end;  call ALIGN_FRONDS (POS_HEAD,0);/*  OLD WAY:    call POSN_TIE_DOWN (POS_HEAD,null,core(POS_LAST),0); */  call POSN_TIE_DOWN (POS_HEAD,null,null,0);  return (MEAS);end JUSTIFY_LINE;KEY_NOTE:procedure (KEY_NO,ACC_MOD) returns (fixed);  dcl KEY_NO       fixed,      ACC_MOD      fixed,      ACC          fixed,      (Y,I,J)      fixed,      YPOS(5)      fixed,      SUP          boolean,      ENHARM       boolean,      ACC_LIST_SET boolean;  dcl NOTE_POS    fixed data (0,L0-3,L0,0,S0,0,L1,S1,0,L2,0,S2,0,L3,S3,0),      SHARP_NOTES fixed data (0,S1,L0,L2,S0,S2,L1,L3),      FLAT_NOTES  fixed data (0,L3,L1,S2,S0,L2,L0,S1);  if ACC_MOD > ENHARMONIC# then do;    ENHARM  = true;    ACC_MOD = ACC_MOD & MASK3;  end;  else ENHARM = false;  J = KEY_NO mod 12;  do I = 1 to 5;    YPOS(I) = NOTE_POS(J);    J       = J + 1;  end;  Y   = 0;  ACC = 0;  SUP = false;  if KEY < 0 then do I = 1 to -KEY;    if (YPOS(FLAT#) = FLAT_NOTES(I) - OCTAVE#  \        YPOS(FLAT#) = FLAT_NOTES(I)            \        YPOS(FLAT#) = FLAT_NOTES(I) + OCTAVE#) &       ((ENHARM & ACC_MOD = FLAT#) \ (PBITS & P_FLAT) ~= 0)    then do;      Y   = YPOS(FLAT#);      ACC = FLAT#;      SUP = true;    end;    if YPOS(NATURAL#) = FLAT_NOTES(I) then ACC = NATURAL#;  end;  else if KEY > 0 then do I = 1 to KEY;    if (YPOS(SHARP#) = SHARP_NOTES(I) - OCTAVE#  \        YPOS(SHARP#) = SHARP_NOTES(I)            \        YPOS(SHARP#) = SHARP_NOTES(I) + OCTAVE#) &       ((ENHARM & ACC_MOD = SHARP#) \ (PBITS & P_FLAT) = 0)    then do;      Y   = YPOS(SHARP#);      ACC = SHARP#;      SUP = true;    end;    if YPOS(NATURAL#) = SHARP_NOTES(I) then ACC = NATURAL#;  end;  if Y = 0 then Y = YPOS(NATURAL#);  if Y = 0 then do;    if (PBITS & P_FLAT) ~= 0 then do;      Y   = YPOS(FLAT#);      ACC = FLAT#;    end;    else do;      Y   = YPOS(SHARP#);      ACC = SHARP#;    end;  end;  if ACC = 0 & (PBITS & P_NATR) ~= 0 then ACC = NATURAL#;  if ACC_MOD ~= 0 & YPOS(ACC_MOD) ~= 0 then do;    if ~(ENHARM & ACC = ACC_MOD) then SUP = false;    Y   = YPOS(ACC_MOD);    ACC = ACC_MOD;/*  SUP = false; */  end;  Y = Y + (21 * (KEY_NO / 12 - 3)); /* Adjust note to octave */  ACC_LIST_SET = false;  do I = 1 to ACC_LIST(0);    if Y = (ACC_LIST(I) & LBYTE) then do;      J = shr(ACC_LIST(I),8);      if ACC = J & (ACC_MOD = 0 \ ENHARM) then ACC = 0;      else do;        if J ~= NATURAL# then do;          if ACC = 0 then ACC = NATURAL#;        end;          ACC_LIST(I) = shl(ACC,8) \ Y; /* WAS IN J=NAT# CASE */        ACC_LIST_SET = true;        SUP          = false;      end;    end;  end;  if SUP then ACC = 0;  if ACC ~= 0 & ~ACC_LIST_SET & (PBITS & P_NATR) = 0 then do;    ACC_LIST(0) = ACC_LIST(0) + 1;    ACC_LIST(ACC_LIST(0)) = shl(ACC,8) \ Y;  end;  Y = Y + CLEF_TABLE(CLEF&MASK6); /* Adjust note to clef */  return (shl(ACC,8) \ Y);end KEY_NOTE;TAB_NOTE:procedure (KEY_NO,GUITAR,STRING);  /* Return fret number of note on given string.     If string is invalid (keyboard performance) then     use first position. */  dcl KEY_NO fixed,   /* Key number of note */      GUITAR boolean, /* Set if this note was recorded by guitar */      STRING fixed,   /* String note was played on (invalid if GUITAR false) */      FRET   fixed;  dcl OPEN_NOTE data (28,33,38,43,47,52,85); /* Last key no. is C7+1 */  if GUITAR then STRING = 5 - STRING;  else do;    STRING = 0;    do while OPEN_NOTE(STRING+1) <= KEY_NO;      STRING = STRING + 1;    end;  end;  if KEY_NO < OPEN_NOTE(STRING)  then FRET = 255;  else FRET = KEY_NO - OPEN_NOTE(STRING);  return (shl(STRING,8) | FRET);end TAB_NOTE;