OVERLAY:procedure (PTR,STAT) public;  dcl (PTR,STAT,DEVICE,START,LEN,I) fixed;  /* Restore the environment */  if MACII | MG600 then do;    /* Set alpha char state back to normal */    vector_mode; alpha_mode;    wchar(esc); wchar(asc.7);    wchar(esc); wchar(asc.8);    if MACII then do; wchar(esc); wchar(asc.gt); end;    transparent_mode;  end;  pstring(KEYPAD_OFF);  core(LOC.SYNSTAT) = STAT;  core(LOC.SYNRET)  = LOC.MPLT;  flush_term; disable;  /* Perform the overlay */  I            = loc.load + 1; /* loader entry point */  DEVICE       = core(PTR + 1);  START        = core(PTR);  LEN          = core(PTR - 1);  write("300") = DEVICE;  write("301") = START;  write("302") = 0;  write("303") = LEN;  write("320") = I; /* Wheeeeeoooooooo ===============> */end OVERLAY;CAN_OVERLAY:procedure (dev,sec,int.reserved,ext.reserved,secbuf) fixed swap;   dcl (dev,sec)    fixed; /* DEVICE and starting SECTOR of program to overlay */   dcl int.reserved fixed; /* WORDS of internal memory to reserve */   dcl ext.reserved fixed; /* SECTORS of external memory to reserve */   dcl secbuf       fixed array; /* a 1 SECTOR work buffer */   dcl (i,j)        fixed;   /* NOTE:  this routine computes whether or not the program pointed to      by SEC can be overlayed to give certain memory constraints.  If      okay to overlay, routine returns 0; otherwise it returns a negative      value as follows:            0:  okay to overlay           -1:  desired pgm is an XPL-5 or earlier compilation           -2:  not enough int. memory to hold core procedures,vars, etc.           -3:  not enough int. memory for reserved words           -4:  not enough ext. memory to hold swap procedures           -5:  not enough ext. memory for reserved sectors           -6:  zero sector (means an empty file)           -7:  not an XPL program at all */    if ((dev=0) and (sec=0)) then return (-6); /* file not found (should return -8) */    if (((dev and "377")=0) and (sec=0)) then return (-6); /* empty file */    call readdata(dev,sec,secbuf,256); /* read first sector of target pgm */    j=secbuf(1);    i=secbuf(j+c#vstart)+secbuf(j+c#vlngth)+secbuf(j+c#stklen); /* words need for core procs, vars, pdl */    j=secbuf(j+c#swplen); /* sectors needed for swap procedures */    if (secbuf(0) <> "100377") \       (secbuf(1) IGT 256-c#conlen)          then return (-7); /* file not an XPL program */    if secbuf(secbuf(1)+c#version) <> c#current_version then return (-1); /* program compiled before XPL-6 */    if                i IGT LOC.LOAD         then return (-2); /* not enough int mem for core procs */    if (int.reserved+i) IGT LOC.LOAD         then return (-3); /* not enough int mem for resrvd words */    if                j IGT core(LOC.EMSIZE) then return (-4); /* not enough ext mem for swap procs */    if (j+ext.reserved) IGT core(LOC.EMSIZE) then return (-5); /* not enough ext mem for resrvd secs */    return (0); /* okay to overlay */end CAN_OVERLAY;ABORT:procedure (MESS) swap;  dcl MESS fixed array;  clear_all;  pos(5,0); pstring (MESS); pos(7,0);  call OVERLAY (core(LOC.SYNRET),C_NOCLEAR); /* Return to whence we came */end ABORT;EXPAND_EDIT_AREA:procedure swap; /* Expand edit area to sector format */  /* If seq can't fit expanded into xmem then this blows up ??? */  dcl (DP,SP,WP) fixed,      (I,L,S)    fixed;  if INF.LEN = 0 \ MUS_MAG = 0 then do; /* Create a default edit area ("inf" area) */    L            = MAIN_DEFAULTS(0) + PART_DEFAULTS(0) + 2;    INF.LEN      = shr(L + 255,8);    write(SECT$) = INF.PTR;    write(DATI$) = INF.LEN; /* Word 0 holds sector length of area */    write(DATI$) = L - 1;   /* Word 1 holds word   length of area - 1 */    call COPY_OUT (addr(MAIN_DEFAULTS(0)),MAIN_DEFAULTS(0));    call COPY_OUT (addr(PART_DEFAULTS(0)),PART_DEFAULTS(0));    MUS_MAG = VERSION_NUMBER;  end;  else do; /* Expand an old style edit area */    write(SECT$) = INF.PTR;    write(WORD$) = 6;    PARTS        = shr(read(DATA$),8);    LISTS        = read(DATA$) & LBYTE;    SP = LAST_SECT - INF.LEN; /* Source of feed at top of xmem */    DP = INF.PTR;             /* Destinaton of feed in original position */    call COPY_EXT (DP,0,SP,0,INF.LEN*256); /* Copy area up to source position */    /* Feed preset area back down */    WP = 0;    L  = 0;    do I = 0 to PARTS + 1;      write(SECT$) = SP + shr(WP,8);      write(WORD$) = WP;      WP           = WP + read(DATA$);      L            = L  + read(DATA$);    end;    call COPY_EXT (SP,0,DP,2,L);    S            = shr(L+2+255,8);    write(SECT$) = DP;    write(DATI$) = S;   /* Word 0 gets sector length */    write(DATI$) = L+1; /* Word 1 gets word length (inc. length word) */    DP           = DP + S;    do I = 1 to LISTS; /* Feed each edit area back down */      write(SECT$) = SP + shr(WP,8);      write(WORD$) = WP;      L            = read(DATA$);      call COPY_EXT (SP,WP,DP,1,L);      S            = shr(L+1+255,8);      write(SECT$) = DP;      write(DATA$) = S;      DP           = DP + S;      WP           = WP + L;    end;    INF.LEN = DP - INF.PTR;  end;end EXPAND_EDIT_AREA;SYSTEM_FILE_LOOKUP:procedure (FILE_NAME) returns (boolean) public swap;  dcl FILE_NAME fixed array;  call set_catbuf (CORE_BASE,0);  if locate (FILE_NAME,-2) then return (true);  if locate (FILE_NAME, 0) then return (true);  if SYSTYP ~= CURTYP \     (core(find_device(shr(core(LOC.UCAT+1),8))) & "1400") ~=     (core(find_device(0)) & "1400")  then return (false);  return locate (FILE_NAME,1);end SYSTEM_FILE_LOOKUP;USER_FILE_LOOKUP:procedure (FILE_NAME) returns (boolean) swap;  dcl FILE_NAME fixed array;  call set_catbuf (CORE_BASE,0);  if locate (FILE_NAME,1) then return (true);  return locate (FILE_NAME,0);end USER_FILE_LOOKUP;GET_LIBRARY:procedure (NAME,USER) returns (fixed) swap;  dcl NAME fixed array, /* Name of library (file) */      USER boolean,     /* Set to look in current cat first */      BASE fixed;       /* Xmem pointer to start of library - returned */  if USER then if   ~USER_FILE_LOOKUP(NAME) then return (0); else;          else if ~SYSTEM_FILE_LOOKUP(NAME) then return (0);  LAST_SECT = LAST_SECT - shr(F#WORDS + 1 + 255,8);  BASE      = LAST_SECT;  REC(0)    = BASE;    /* Sector */  REC(1)    = 0;       /* Word */  REC(2)    = 0;       /* Length in sectors */  REC(3)    = F#WORDS; /* Length mod 256 (or length in words if above is 0) */  call extread (F#MS_SECTOR,F#LS_SECTOR,REC);  /* Write a 0 just after end of file to ensure that scans will stop */  write(SECT$) = BASE + shr(F#WORDS,8);  write(WORD$) = F#WORDS;  write(DATA$) = 0;  return (BASE);end GET_LIBRARY;LOAD_OVERLAY_FILE:procedure swap;  dcl (I,W)   fixed,      SECT    fixed,      WORD    fixed,      (LS,LW) fixed,      L       fixed,      REC(3)  fixed;  if OVERLAY_FILE(0) = 0 then do;    OVLY_BASE = null;    return;  end;  call set_catbuf (CORE_BASE,0);  if ~locate(OVERLAY_FILE,STORAGE_DEVICE)  then call ERROR ('Overlay file does not exist');  OVLY_BASE = LAST_SECT - F#LS_LENGTH;  if OVLY_BASE ilt XMEM_BASE then call ERROR ('Overlay file is too big');  REC(0) = OVLY_BASE; /* Sector */  REC(1) = 0;       /* Word */  REC(2) = 0;       /* Length in sectors */  REC(3) = F#WORDS; /* Length mod 256 (or length in words if above is 0) */  call extread (F#MS_SECTOR,F#LS_SECTOR,REC);  SECT = OVLY_BASE;  WORD = 0;  I    = F#WORDS;  do while I igt 0;    LS = SECT; LW = WORD;    write(SECT$) = SECT;    write(WORD$) = WORD;    write(NOP) = read(DATI$);    I = I - 1;    L = 0; W = 256;    do while (W & UBYTE) ~= 0;      W = read(DATI$);      I = I - 1;      L = L + 2;    end;    SECT = read(SECT$);    WORD = read(WORD$);    write(SECT$) = LS;    write(WORD$) = LW;    write(DATA$) = L;  end;  write(SECT$) = SECT;  write(WORD$) = WORD;  write(DATA$) = 0;end LOAD_OVERLAY_FILE;DOWNLOAD:procedure (BASE) swap;  dcl BASE     fixed,      SYM_CODE fixed,      SYM_FONT fixed,      SYM_ILEN fixed,      SYM_XZER fixed,      SYM_YZER fixed,      SYM_XADV fixed,      SYM_WDTH fixed,      SYM_FLIP fixed,      (W0,W3,W4) fixed,      (I,J,K)    fixed;/*pstringr('About to download');*/  control.seq = true;  /* Download raster control tables */  wchar(esc); pstring('P3;32;95;0;0;0;0;0;0;0;0;0;0#RM');  wchar(esc); wchar(bsl);  wchar(esc); pstring('P3;32;95;0;0;0;0;0;0;0;0;0;0#RN');  wchar(esc); wchar(bsl);  /* Download data and alter table for each symbol */  write(SECT$) = BASE;/*pstring('About to scan library, BASE = ');pnum(BASE,0);crlf;*/  do while read(DATA$) ~= 0;    W0           = read(DATI$);    write(NOP)   = read(DATI$);    write(NOP)   = read(DATI$);    if (W0 & LBYTE) > 3 then W3 = read(DATI$);    if (W0 & LBYTE) > 4 then W4 = read(DATI$);    SYM_CODE = shr(W0,8);    SYM_ILEN = (W0 & LBYTE) - 5;    SYM_XZER = shr(W4,12);    SYM_YZER = shr(W4,6) & MASK6;    SYM_XADV = W4 & MASK6;    SYM_WDTH = 1; /* Word width assumed 1 (16 bits) */    if (W3 & S_DOUB) ~= 0 then do; /* If the double width bit is set, word width is 2 (32 bits) */      SYM_WDTH = 2;      if (W3 & S_MSBX) ~= 0 then SYM_XZER = SYM_XZER + 16; /* Get msb of X center */    end;    if (W3 & S_INVERT) ~= 0 then SYM_FLIP = true; /* Symbol is invertable */    do I = 0 to SYM_ILEN - 1;      BUFF(I) = read(DATI$);    end;/*pstring('  Entry, CODE = ');pnum(SYM_CODE,0);crlf;pstring('         ILEN = ');pnum(SYM_ILEN,0);crlf;pstring('         xmem = ');pnum(read(WORD$),0);crlf;*/    if SYM_ILEN > 0 & SYM_CODE > "200" then do; /* Symbol (as opposed to command) */      /* Download Raster Data */      wchar(esc); wchar(asc.p);      pnum(SYM_WDTH*16,0); /* P1 */      pstring(';0;0;0;');      pnum(SYM_CODE,0);    /* P5 */      pstring(';0;0%R');      pnum(SYM_ILEN*2,0); wchar(slash);      J = SYM_ILEN;      do I = 1 to SYM_ILEN/SYM_WDTH;        J = J - SYM_WDTH;        do K = 0 to SYM_WDTH-1;          wchar(shr(BUFF(J+K),8));          wchar(BUFF(J+K));        end;      end;      wchar(esc); wchar(bsl);      /* Alter raster control table */      wchar(esc); wchar(asc.p);      pnum(32+(SYM_CODE&"77"),0); wchar(scolon);      unum(-SYM_XZER,0); wchar(scolon);      unum(-SYM_YZER,0); wchar(scolon);      pnum( SYM_XADV,0); pstring(';0;');      pnum(SYM_WDTH*16,0); wchar(scolon);      pnum(SYM_ILEN/SYM_WDTH,0); wchar(scolon);      pnum(SYM_CODE,0); wchar(asc.r);      if (SYM_CODE & "100") ~= 0 then pstring('N');                                 else pstring('M');      wchar(esc); wchar(bsl);    end;  end;  control.seq = false;end DOWNLOAD;GET_STARTUP_ARG:procedure swap;  dcl arg(15) fixed;  call setup_args (arg);  call next_arg (arg);  if arg(0) = 2 & (arg(1) & LBYTE) = asc.min  then STARTUP_ARG = shr(arg(1),8);  else STARTUP_ARG = 0;  STARTUP_ARG = toupper(STARTUP_ARG);end GET_STARTUP_ARG;INITIALIZE_GRAPHICS:procedure swap;  dcl LOAD_RASTERS boolean,      (C,D,I)      fixed;  if terminal.model = t#macintosh then do;    MACII                  = true;    SCREEN_WIDTH#          = 2047;    SCREEN_LENGTH#         = 2047;    DISPLAY_SCREEN_LENGTH# = 780;    SCREEN_TOP#            = 2047;    SCREEN_BOT#            = 0;    WIN_TOP#               = 770;    WIN_BOT#               = 670;    LOWER_TOP#             = 470;    EDIT_TOP#              = 747;    EDIT_BOT#              = 165;    EDIT_SCREEN_LENGTH#    = EDIT_TOP# - EDIT_BOT#;    SCAN_SIZE#             = 4;    punits (1023,779);  end;  else if terminal.model = t#mg600 then do;    MG600                  = true;    SCREEN_WIDTH#          = 1023;    SCREEN_LENGTH#         =  779;    DISPLAY_SCREEN_LENGTH# =  780;    SCREEN_TOP#            =  779;    SCREEN_BOT#            =    0;    WIN_TOP#               =  770;    WIN_BOT#               =  670;    LOWER_TOP#             =  470;    EDIT_TOP#              =  779;    EDIT_BOT#              =  165;    EDIT_SCREEN_LENGTH#    =  696;    SCAN_SIZE#             =    4;/*  GO250 = true;  */    punits (SCREEN_WIDTH#,SCREEN_LENGTH#);  end;  else if terminal.model = t#vt640 then do;    SCREEN_WIDTH#          = 639;    SCREEN_LENGTH#         = 479;    EDIT_SCREEN_LENGTH#    = 396;    DISPLAY_SCREEN_LENGTH# = 480;    SCREEN_TOP#            = 479;    SCREEN_BOT#            =   0;    WIN_TOP#               = 460;    WIN_BOT#               = 260;    LOWER_TOP#             = 230;    EDIT_BOT#              =  84;    SCAN_SIZE#             =   5;    punits (SCREEN_WIDTH#,SCREEN_LENGTH#);  end;  else call ABORT ('Music Printing cannot run on this terminal');  screen_size (-1,-1);  /* Initialize GraphOn terminal */  if GO250 then do;    /* Test presence of raster sets */    LOAD_RASTERS = true; C = 0;    flush_term; disable;    print chr(esc),'[5;0#|',;    do while ~(C = esc & D = bsl);      do I = 1 to 5; C = read("50"); end; /* Eat header */      C = read("50");      do while C ~= esc;        if C = asc.M then LOAD_RASTERS = false;        if C = asc.N then LOAD_RASTERS = false;        C = read("50"); /* Eat CR */        C = read("50"); /* Eat LF */        C = read("50"); /* Get next char */      end;      D = read("50");    end;    enable;    /* If raster sets not there, load them */    if LOAD_RASTERS then call DOWNLOAD (SLIB_BASE);    vector_mode;    wchar(esc); wchar(lower.r);    wchar(esc); pstring('(M');    wchar(esc); pstring(')N');    wchar(esc); wchar(lower.t);    transparent_mode;  end;end INITIALIZE_GRAPHICS;INITIALIZE_ENVIRONMENT:procedure swap;  dcl C fixed;  /* Set internal memory pointers (this must be done first as everybody uses CORE_BASE) */  CORE_ORIGIN = core(C#CONTAB + C#VSTART) +                core(C#CONTAB + C#VLNGTH) +                core(C#CONTAB + C#STKLEN);  CORE_BASE   = CORE_ORIGIN;  LAST_SECT   = core(LOC.EMSIZE) - core(c#contab + c#swplen);  if (core(LOC.SYNSTAT) & C_NOCLEAR) ~= 0 then do;    pstring('Press <RETURN> to continue. ');    do while rchar ~= cr; end;  end;  if core(LOC.SYNMED) ~= 2 then call ABORT ('Sequence not in correct format');  /* Load data files into external memory */  FLIB_BASE = GET_LIBRARY ('.SFRM-7',false); FLIB_LEN = F#WORDS;  SLIB_BASE = GET_LIBRARY ('.SLIB-7',false);  ALIB_BASE = GET_LIBRARY ('.SAUX-7',false);  ULIB_BASE = GET_LIBRARY ('SYMLIB',true);  LAST_SECT = LAST_SECT - 5; /* Leave room for 64 16 word part records + 1 */  PFIL_BASE = LAST_SECT;     /* Point PFIL_BASE to base of part record file */  call INITIALIZE_GRAPHICS;  if SYSTEM_FILE_LOOKUP ('.SCWT-7') /* Get char width table */  then call readdata (F#MS_SECTOR,F#LS_SECTOR,WIDTH_TABLE,WIDTH_TABLE_LENGTH);  BAS.PTR = core(LOC.SYNTIMB);end INITIALIZE_ENVIRONMENT;INITIALIZE_TERMINAL:procedure public;  vector_mode; alpha_mode;  if MACII then do;      /* Set Times font */    wchar(esc); wchar(asc.lt);  end;  else if MG600 then do; /* Set alpha char size to small (to match VT640) */    wchar(esc); wchar(colon);  end;  transparent_mode;  pstring(KEYPAD_ON);end INITIALIZE_TERMINAL;LOOKUP_SEQUENCE_DATA:procedure;  /* Lookup external memory pointers */  write(SECT$) = BAS.PTR;  write(WORD$) = SEQ.NUMSEC;  SEQ.LENGTH   = read(DATI$);  write(NOP)   = read(DATI$); BAS.LEN = read(DATI$);  PAR.PTR      = read(DATI$); PAR.LEN = read(DATI$);  NAH.PTR      = read(DATI$); NAH.LEN = read(DATI$);  INF.PTR      = read(DATI$); INF.LEN = read(DATI$);  XMEM_BASE    = BAS.PTR + SEQ.LENGTH; /* REMOVE */  /* Lookup various sequence values */  write(WORD$) = SEQ.CLICK;  CLICK_RATE   = read(DATA$);  write(WORD$) = SEQ.MPREV;  MUS_MAG      = read(DATA$);/*clear_all;pstring('BAS.PTR         ');pnum(BAS.PTR,0);crlf;pstring('PAR.PTR,PAR.LEN ');pnum(PAR.PTR,0);pnum(PAR.LEN,10);crlf;pstring('NAH.PTR,NAH.LEN ');pnum(NAH.PTR,0);pnum(NAH.LEN,10);crlf;pstring('INF.PTR,INF.LEN ');pnum(INF.PTR,0);pnum(INF.LEN,10);crlf;pstring('SEQ.LENGTH      ');pnum(SEQ.LENGTH,0);crlf;pstring('EDIT_BASE       ');pnum(EDIT_BASE,0);crlf;pstring('XMEM_BASE       ');pnum(XMEM_BASE,0);crlf;pstring('LAST_SECT       ');pnum(LAST_SECT,0);crlf;pstring('CLICK_RATE      ');pnum(CLICK_RATE,0);crlf;pstring('MUS_MAG         ');hnum(MUS_MAG,0);crlf;flush_term;*/  /* Make all pointers absolute */  PAR.PTR = PAR.PTR + BAS.PTR;  NAH.PTR = NAH.PTR + BAS.PTR;  INF.PTR = INF.PTR + BAS.PTR;  /* Move seq down to sec 0 & remove space between PAR area and NAH area */  call COPY_EXT_SECT (BAS.PTR,              0,BAS.LEN);  BAS.PTR           = 0;  core(LOC.SYNTIMB) = 0;  call COPY_EXT_SECT (PAR.PTR,BAS.PTR+BAS.LEN,PAR.LEN);  PAR.PTR = BAS.PTR + BAS.LEN;  call COPY_EXT_SECT (NAH.PTR,PAR.PTR+PAR.LEN,NAH.LEN);  NAH.PTR = PAR.PTR + PAR.LEN;  call COPY_EXT_SECT (INF.PTR,NAH.PTR+NAH.LEN,INF.LEN);  INF.PTR = NAH.PTR + NAH.LEN;/*crlf;pstring('BAS.PTR         ');pnum(BAS.PTR,0);crlf;pstring('PAR.PTR,PAR.LEN ');pnum(PAR.PTR,0);pnum(PAR.LEN,10);crlf;pstring('NAH.PTR,NAH.LEN ');pnum(NAH.PTR,0);pnum(NAH.LEN,10);crlf;pstring('INF.PTR,INF.LEN ');pnum(INF.PTR,0);pnum(INF.LEN,10);crlf;*//* call rchar; *//* pstringr('Before expand'); call print_inf_area; flush_term; */  /* Expand old style edit area or create a default "inf" area */  if INF.LEN = 0 \ MUS_MAG ilt REV_F.1# then call EXPAND_EDIT_AREA;/* pstringr('After expand'); call print_inf_area; flush_term; */  SEQ.LENGTH   = INF.PTR + INF.LEN;  XMEM_BASE    = SEQ.LENGTH;  write(SECT$) = INF.PTR;  EDIT_BASE    = INF.PTR + read(DATA$);/*crlf;pstring('BAS.PTR         ');pnum(BAS.PTR,0);crlf;pstring('PAR.PTR,PAR.LEN ');pnum(PAR.PTR,0);pnum(PAR.LEN,10);crlf;pstring('NAH.PTR,NAH.LEN ');pnum(NAH.PTR,0);pnum(NAH.LEN,10);crlf;pstring('INF.PTR,INF.LEN ');pnum(INF.PTR,0);pnum(INF.LEN,10);crlf;pstring('SEQ.LENGTH      ');pnum(SEQ.LENGTH,0);crlf;pstring('EDIT_BASE       ');pnum(EDIT_BASE,0);crlf;pstring('XMEM_BASE       ');pnum(XMEM_BASE,0);crlf;*/  NEW_SEQUENCE = true;  FREESEG_HEAD = null;/*pstringr('About to not clean sequence'); flush_term; *//*  call CLEAN_SEQUENCE (false); * Why do this here? *//*pstringr('About to leave'); call rchar; */end LOOKUP_SEQUENCE_DATA;UPDATE_SEQUENCE_DATA:procedure;  call CLEAN_SEQUENCE (false);  call COMPRESS_NAH_AREA;  write(SECT$) = BAS.PTR;  write(WORD$) = SEQ.MPREV;  write(DATA$) = VERSION_NUMBER; /* Set MP magic number */  write(WORD$) = SEQ.NUMSEC;  write(DATI$) = SEQ.LENGTH;     /* Set NUMSEC and pointers and lengths */  write(DATI$) = BAS.PTR; write(DATI$) = BAS.LEN;  write(DATI$) = PAR.PTR; write(DATI$) = PAR.LEN;  write(DATI$) = NAH.PTR; write(DATI$) = NAH.LEN;  write(DATI$) = INF.PTR; write(DATI$) = INF.LEN;end UPDATE_SEQUENCE_DATA;INITIALIZE_GLOBALS:procedure swap;  STORAGE_DEVICE = 1;  REPLOT_MEASURE = 0;  START_MEAS     = 1;  STVS_PP        = 8;  EDIT_MODE      = 0;  BANK           = 0;  TSIZE          = 1;  BUFF_LIST      = 0;  SLUR_GRAIN     = .1;  ERR_PTR        = null;  BOXTX          = false;  RUNNING        = false;  call strcpy (SEQUENCE_NAME,loc(loc.cfn));end INITIALIZE_GLOBALS;RECALL_SEQUENCE:procedure;  dcl SLEN  fixed,      MAGIC fixed;  CORE_BASE = CORE_ORIGIN;  call set_catbuf (CORE_BASE,0);  CORE_BASE = CORE_BASE + C#DIR_MAX;  if ~locate (BUFF,STORAGE_DEVICE) then call ERROR (ERR_SEQNA);  call readdata (F#MS_SECTOR,F#LS_SECTOR,location(CORE_BASE),256); /* Get 1st sector of bas area */  MAGIC = core(CORE_BASE+MAGIC.NUMBER); /* Sequence magic number */  if MAGIC ~= MAGIC#5 then call ERROR (ERR_INC);  MAGIC = core(CORE_BASE+SEQ.MPREV); /* Music Printing rev number */  if MAGIC ~= 0 & (MAGIC ilt REV_C.1# \ MAGIC igt VERSION_NUMBER)  then call ERROR (ERR_IMP);  /* Guess how big seqence will end up and give up if too big */  SLEN = core(CORE_BASE+SEQ.NUMSEC);  if BAS.PTR + SLEN + 16 igt LAST_SECT then call ERROR (ERR_PRINT);  call strcpy (SEQUENCE_NAME,BUFF); NUMBERED_SEQUENCE = BUFF(NUMBERED#);  REC(0) = BAS.PTR; /* Sector */  REC(1) = 0;       /* Word */  REC(2) = SLEN;    /* Length in sectors */  REC(3) = 0;       /* Length mod 256 (or length in words if above is 0) */  call extread (F#MS_SECTOR,F#LS_SECTOR,REC);  call LOOKUP_SEQUENCE_DATA;end RECALL_SEQUENCE;STORE_SEQUENCE:procedure;  dcl C fixed;  CORE_BASE = CORE_ORIGIN;  call set_catbuf (CORE_BASE,0);  NUMBERED_SEQUENCE = BUFF(NUMBERED#);  if NUMBERED_SEQUENCE then do;    if ~locate (BUFF,STORAGE_DEVICE) then call ERROR (ERR_SEQNA);    if F#LS_LENGTH ilt SEQ.LENGTH then NUMBERED_SEQUENCE = false;  end;  if ~NUMBERED_SEQUENCE then do;    if locate (BUFF,STORAGE_DEVICE) then do;      erase_command;      pcmd('Press <RETURN> to replace this sequence');      C = rchar;      if C ~= cr then call ERROR ('Replace aborted');    end;    if ~replace (BUFF,t#sync,0,SEQ.LENGTH,shl(SEQ.LENGTH,8),STORAGE_DEVICE) then do;      call ERROR ('Sequence cannot be stored');    end;  end;  call strcpy (SEQUENCE_NAME,BUFF);  call UPDATE_SEQUENCE_DATA;  REC(0) = BAS.PTR;    /* Sector */  REC(1) = 0;          /* Word */  REC(2) = SEQ.LENGTH; /* Length in sectors */  REC(3) = 0;          /* Length mod 256 */  call extwrite (F#MS_SECTOR,F#LS_SECTOR,REC);end STORE_SEQUENCE;REVERSE_SEQUENCE:procedure (CONV_STATUS) swap;  dcl CONV_STATUS fixed;  CORE_BASE = CORE_ORIGIN;  if core(LOC.RT) = 0 then call ERROR (ERR_CNVNA);  if CAN_OVERLAY (core(LOC.RT+1),core(LOC.RT),                  0,                  SEQ.LENGTH,                  location(CORE_BASE)) ~= 0  then call ERROR (ERR_REVERSE);  call UPDATE_SEQUENCE_DATA;  call OVERLAY (LOC.RT,CONV_STATUS); /* Overlay to reverse compiler */end REVERSE_SEQUENCE;PLAY_SEQUENCE:procedure (KEEP_SCREEN) public swap;  dcl KEEP_SCREEN boolean;  CORE_BASE = CORE_ORIGIN;  if CAN_OVERLAY (core(LOC.P2+1),core(LOC.P2),                  0,                  SEQ.LENGTH,                  location(CORE_BASE))  then call ERROR (ERR_PLAY);  call UPDATE_SEQUENCE_DATA;  if KEEP_SCREEN then call OVERLAY (LOC.P2,C_NOCLEAR);  else do;    pstringr('Starting the Synclavier (r).  Please wait...');    call OVERLAY (LOC.P2,0);  end;end PLAY_SEQUENCE;EXIT_TO_MONITOR:procedure swap;  call OVERLAY (loc.mon,0); /* Overlay to monitor */end EXIT_TO_MONITOR;CLEAN_LISTS:procedure (SET,FREE_RECS) swap;  dcl I         fixed,      SET       boolean,      FREE_RECS boolean;  do STAFF = 0 to STAVES; /* Clean up the lists */    PART = DISPLAY(STAFF);    if SET then if FREE_RECS then HEAD(PART) = HOLD_HEAD(PART);                             else HOLD_HEAD(PART) = HEAD(PART);    I          = HEAD(PART);    HEAD(PART) = core(LAST(PART));    if FREE_RECS then do;      if HEAD(PART) = null then TAIL(PART) = addr(HEAD(PART));      call FREE_NOTE (I,LAST(PART));    end;  end;  if SET then if FREE_RECS then POS_HEAD = HOLD_POS_HEAD;                           else HOLD_POS_HEAD = POS_HEAD;  I        = POS_HEAD;  POS_HEAD = core(POS_LINE);  if FREE_RECS then do;    if POS_HEAD = null then POS_TAIL = addr(POS_HEAD);    else core(POS_HEAD+REV) = null;    call FREE_POSN (I,POS_LINE);  end;end CLEAN_LISTS;