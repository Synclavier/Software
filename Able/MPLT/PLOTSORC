/* $title List Plotting Routines */module PLOTRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';/* Module Globals *//* Procedures */dcl CLEAR_LASER_PRINTER procedure external,    MAIN_MODE           fixed external, /* Display, Edit, Hardcopy */    FIND_CONTROL_POINTS procedure (fixed array,fixed) external;/* Variables */dcl EDIT_SKIP      fixed, /* # of edit blocks to skip over */    REST_CNT       fixed, /* # of measures for block rests */    POST           fixed, /* Post edit postition */    WHOLE_REST_LEFT fixed,    BLOCK_REST_LEFT fixed,    CRS_X          fixed, /* Centered rest position */    BAR_X          fixed, /* Bar position */    KEY_X          fixed, /* Key position */    TIM_X          fixed, /* Time signature position */    CLF_X          fixed, /* Clef position */    TIE_1ST_X      fixed, /* 1st X of 1st note ties */    BAR_LEN        fixed; /* Bar length */dcl BEAM_DEG(1)    fixed, /* Number of beams in progress (up to 5 for each voice)  */    SM_BEAM_DEG(1) fixed, /* Number of small beams in progress */    SM_BEAMST(3)   fixed, /* Small beam stack */    BEAMSTACK(25)  fixed, /* Once upon a time, there was a young lad named Jack */    OBEAM(1)       fixed, /* Open beam */    CBEAM(1)       fixed, /* Closed beam */    REVBEAM        fixed, /* Reversed beam (right-most to left) */    CRIMP(1)       boolean; /* Set to crimp end of beam */dcl TIE_X(31)      fixed, /* Tie X position */    TIE_Y(31)      fixed, /* Tie Y Position */    TIE_MASK       fixed, /* Tie mask for the editing function */    TIE_MASK_VALID fixed; /* No mask, RevB mask, Normal mask */dcl MAT(7)         fixed;/* $subtitle Miscellaneous Picture Drives */CHORD_LEN:procedure (P) returns (fixed) public swap3;  dcl P pointer,      L fixed;  L = 0;  do while (P ~= null);    if (core(P+D6) & B_REST) = 0 &       (core(P+D6) & B_TUP)  = 0    then L = L + 1;    P = core(P+GRP);  end;  return (L);end CHORD_LEN;KEY_ACC:procedure (ACC,IND,X,NAT) swap3; /* Plot an accidental in the key signature given the index */  dcl (ACC,IND,X,Y) fixed,   /* accidental, index, X-Y position */      NAT           boolean, /* If there are naturals */      C             fixed;  C = CLEF & MASK6;  if C = 2 & ACC = SHARP# then Y = TENOR_SHARP_TABLE(IND); /* Sharps in tenor clef */  else do;    if ACC = FLAT#    then Y = FLAT_TABLE(IND)  + CLEF_MODS(C);    else Y = SHARP_TABLE(IND) + CLEF_MODS(C);    if C = 3 & IND = 7 & ACC = FLAT# then Y = Y + 21; /* Cf in bass clef */  end;  if      NAT         then PLOT_SYMBOL ("212",X,Y,UP#);   /* plot a natural */  else if ACC = FLAT# then PLOT_SYMBOL ("213",X,Y,UP#);   /* plot a flat */  else                     PLOT_SYMBOL ("211",X,Y,UP#);   /* plot a sharp */end KEY_ACC;PLOTKEY:procedure (OLD,NEW,X) swap3; /* Plots the key signature given the old and new key and X postion */  dcl (OLD,NEW,X,ACC,I) fixed; /* Old and New key signature, X postion, accidental */  if OLD > 0 then ACC = SHARP#; else ACC = FLAT#;  if OLD * NEW <= 0 then do I = 1 to abs(OLD); /* If sharps to flats or flats to sharps */    call KEY_ACC (ACC,I,X,true);  X = X + 8;  /* Plot the naturals */  end;  if NEW > 0 then ACC = SHARP#; else ACC = FLAT#;  do I = 1 to abs(NEW);    call KEY_ACC (ACC,I,X,false); X = X + 8;  /* Plot the new key signature */  end;  if OLD * NEW > 0 & abs(OLD) > abs(NEW)  then do I = abs(NEW) + 1 to abs(OLD);    call KEY_ACC (ACC,I,X,true);  X = X + 8;  /* Natural out the extraneous ones */  end;end PLOTKEY;PLOT_MEAS_NO:procedure (X);  dcl X fixed;  dcl E fixed;  X = X + 3 + EXPAND(shr(MEASNO_POS,8),8);  E = NUMBER (X,              MEASNO_POS & LBYTE,              MEASURE_NUMBER,              (MEASNO_FORMAT & "1") + 1,              F_STANDARD#);  if (MEASNO_FORMAT & "2") ~= 0  then call TEXT_BOX (X,MEASNO_POS & LBYTE,E,(MEASNO_FORMAT & "1")+1);end PLOT_MEAS_NO;/* $subtitle Position Record Plotting Routines */PLOT_POSITION_RECORD:procedure (PP,XX,LEVEL,POS_CNT) swap3; /* Plots all the stuff that is related to an edit position*/  dcl PP      pointer,      /* Postion pointer */      XX      fixed array,  /* Contains X position values to be used by PLOT LIST */      LEVEL   fixed,        /* Edit block (tuplet) level */      POS_CNT fixed,        /* Count down to next note (0 if note at this pos) */      PRE     fixed,        /* Pre edit position */      POST    fixed,        /* Post edit position */      KEY_SIZE fixed,      REST_LEFT fixed,      (I,J)   fixed;  call LOAD_RECORD (PP);    /* Load a postition record */  PRE   = shr(REC(D4),8);   /* Get the Pre X position */  POST  = REC(D4) & LBYTE;  /* Get the Post X position */  XX(0) = XX(0) + PRE;  XX(1) = XX(0) + POST;  BAR_X = XX(1) - shr(REC(D3) & THRD4,7); /* Bar position = End - Xtra (* 2) */  TIM_X = BAR_X - TIMESIG_GAP/2; /* Time signature position */  KEY_SIZE = shr(REC(D3) & FRTH4,9);  BAR_X = BAR_X - KEY_SIZE; /* Bar moves back to make room for key sig */  KEY_X = BAR_X;                          /* Key sig position */  CRS_X = BAR_X;  if (REC(D6) & (B_OREP \ B_EOL \ B_BAR)) = (B_OREP \ B_BAR) then do;    TIM_X = TIM_X + 10;    KEY_X = KEY_X + 10;  end;  if (REC(D6) & B_BAR) ~= 0 then do;    CLF_X = BAR_X - 4;    if (REC(D6) & B_CREP) ~= 0 then CLF_X = CLF_X - 10; /* Clef moves back to make room for a close rep */    if (REC(D6) & B_EBAR) ~= 0 then CLF_X = CLF_X - 7; /* Clef moves back to make room for an ebar */    if (REC(D6) & B_DBAR) ~= 0 then CLF_X = CLF_X - 3; /* Clef moves back to make room for a dbar */  end;  else if POS_CNT = 0 then CLF_X = XX(1); /* + shr(core(core(PP)+D4),8); */                      else CLF_X = XX(1) - 8;  if (REC(D6) & B_CLEF) ~= 0 then CLF_X = CLF_X - 24;  CRS_X = CLF_X;  if (REC(D6) & B_REST) ~= 0 then do; /* If a block rest */    EDIT_SKIP = EDIT_SKIP + REC(D2);  /* skip over editing for a block rest */    REST_CNT  = REC(D5);              /* Set block rest count */  end;  if BLOCK_REST_LEFT = 0 then BLOCK_REST_LEFT = XX(0);  if LEVEL = 0 & (REC(D6) & B_BAR) ~= 0 & (PLOTBITS & P_BOFF) = 0 then do;  /* If no tuplets and the last block in measure */    if (REC(D6) & B_TIME) ~= 0 then do; /* If there is a time change */      BAR_X = BAR_X - TIMESIG_GAP;      KEY_X = KEY_X - TIMESIG_GAP;      CLF_X = CLF_X - TIMESIG_GAP;      CRS_X = CRS_X - TIMESIG_GAP;    end;    if REST_CNT > 1 then REST_LEFT = BLOCK_REST_LEFT;                    else REST_LEFT = WHOLE_REST_LEFT;    WHOLE_REST_LEFT = BAR_X + KEY_SIZE;    BLOCK_REST_LEFT = XX(1);    /* EOP check may be redundant here */    if ((REC(D6) & B_EOP) ~= 0 & (FORMAT & F_END) ~= 0 & core(PP) = null) |       ((REC(D6) & B_EBAR) ~= 0) then do; /* If at the end of the piece and end_of_piece is on */      call BAR (BAR_X-5,BAR_LEN); call HEAVY_BAR (BAR_X-1,BAR_LEN); /* Draw an end of piece mark */    end;    else do;      call BAR (BAR_X,BAR_LEN); /* Plot a bar */      if (REC(D6) & B_OREP) ~= 0 &  /* If an open repeat and not end of line */         (REC(D6) & B_EOL)   = 0 then call REPEAT (BAR_X,BAR_LEN,false);   /* Plot an open repeat */    end;    if (REC(D6) & B_CREP) ~= 0 then call REPEAT (BAR_X,BAR_LEN,true); /* If closed repeat, draw it */    if (REC(D6) & B_DBAR) ~= 0 then call BAR (BAR_X-3,BAR_LEN);       /* If double bar, draw a double bar */    if ~TABLATURE then do;      I = 1;      J = S3; if (CLEF&MASK6) = SINGLE_CLEF# then J = S2;      if REST_CNT > 1 then do;                /* If a block rest */        call REST (WHOLE#,REST_CNT,REST_LEFT,CRS_X-8);         I = REST_CNT;      end;                                          /* was CRS_X */      else if REST_CNT = 1 then call REST (WHOLE#,1,(REST_LEFT+BAR_X)/2,J);  /* If a whole rest centered between bars */    end;    if (REC(D6) & B_SOT) = 0 then MEASURE_NUMBER = MEASURE_NUMBER + I; /* If not a partial measure, advance measure number by block rest count */    if STAFF = 0 & INIT_MEAS ~= 0 & MEAS_FREQ ~= 0 &       (REC(D6) & B_EOL) = 0 & (PLOTBITS & P_MNOFF) = 0    then if MEASURE_NUMBER >= MEAS_SYNC then do;      write(5) = MEASURE_NUMBER - MEAS_SYNC;      write(7) = MEAS_FREQ;      if read(4) = 0 then call PLOT_MEAS_NO (BAR_X);    end;    REST_CNT = 0;  end;end PLOT_POSITION_RECORD;/* $Subtitle Edit Record Plotting Routines */PLOT_EDIT_RECORDS:procedure (PP,X,LEVEL) swap3; /* Plots edit records given the current position pointer, X position, and edit block (tuplet) level */  dcl PP             pointer, /* Postion record pointer */      X              fixed,   /* X positon */      LEVEL          fixed,   /* Edit block (tuplet) level */      DATA8          fixed,   /* First 8 bits of edit record data*/      DATA16         fixed,   /* second word of data */      (VOX,I,T)      fixed,   /* Voice */      RECORD_PRESENT boolean; /* If an edit record is present */    do I = 1 to EDIT_SKIP;    /* Skip over unused edit records */      do while GET_NEXT_RECORD (LEVEL,BUFF,false); end;    end;    EDIT_SKIP      = 0;    TIE_MASK_VALID = NOMASK#;    RECORD_PRESENT = false;    CRIMP(1)       = false;    CRIMP(0)       = false;    do while GET_NEXT_RECORD (LEVEL,BUFF,true);  /* Get the next edit record */      T      = shr(BUFF(0),8);    /* Get type code */      DATA8  = BUFF(0) & LBYTE;   /* Get the data */      DATA16 = BUFF(1);       VOX    = shr(DATA8,7);      /* Determine the voice */      if T < "30" then do case T; /* If one word records */        ;   /* 000 reserved */        do; /* 001 Clef change */          CLEF = DATA8;          call PLOTCLEF (CLEF,CLF_X,true);            if (CLEF & RESTORE#) ~= 0 then CLEF = CLEF & MASK6;        end;        do; /* 002 Key change */          I = SET_KEY (DATA8,true);          if (DATA8 & NO_CANCEL#) ~= 0 then KEY = 0;          call PLOTKEY (KEY,I,KEY_X + 8);           KEY = I;        end;        ;        do; /* 004 Transpose change */          TRANSPOSE(VOX) = TRANSPOSE(VOX) + EXPAND(DATA8,7);          if MASTER_RECORD then TRANSPOSE(1) = TRANSPOSE(0);        end;        ;        PBITS = (PBITS & UBYTE) \ DATA8; /* 006 Format change */        ;;        TRACK(VOX) = DATA8 & MASK7;      /* 011 Track change */        ;;;;        HEAD_TYPE(VOX) = DATA8 & MASK7;  /* 016 Head change */        ;        STAFF_SPACE(PART) = DATA8 * 3;   /* 020 Staff Spacing change */        ;        MEAS_LINE = DATA8;               /* 022 Measures/line change */      end;      else if T < "70" then do case (T - "30");        ;;;;        do; /* 34 - Plot off */          PLOTBITS = PLOTBITS \  P_POFF;          do I = 0 to 31; TIE_X(I) = 0; end; /* Clear tie arrays */        end;        PLOTBITS = PLOTBITS & ~P_POFF; /* 35 - Plot on */        PLOTBITS = PLOTBITS \  P_BOFF; /* 36 - Bar off */        PLOTBITS = PLOTBITS & ~P_BOFF; /* 37 - Bar on */        ;;;; ;;;; ;;;        /*        if VOX = 1 then PLOTBITS = PLOTBITS \ P_ROFF1;    * 051 Rests off *                    else PLOTBITS = PLOTBITS \ P_ROFF0;        if VOX = 1 then PLOTBITS = PLOTBITS & ~P_ROFF1;   * 052 Rests on  *                    else PLOTBITS = PLOTBITS & ~P_ROFF0;        */        PLOTBITS = PLOTBITS \  P_MNOFF;                  /* 053 Meas # off */        PLOTBITS = PLOTBITS & ~P_MNOFF;                  /* 054 Meas # on */        if VOX = 1 then PLOTBITS = PLOTBITS \  P_FOFF1;  /* 055 Flags off */                   else PLOTBITS = PLOTBITS \  P_FOFF0;        if VOX = 1 then PLOTBITS = PLOTBITS & ~P_FOFF1;  /* 056 Flags on  */                   else PLOTBITS = PLOTBITS & ~P_FOFF0;        if VOX = 1 then PLOTBITS = PLOTBITS \  P_SOFF1;  /* 057 Stems off */                   else PLOTBITS = PLOTBITS \  P_SOFF0;        if VOX = 1 then PLOTBITS = PLOTBITS & ~P_SOFF1;  /* 060 Stems on  */                   else PLOTBITS = PLOTBITS & ~P_SOFF0;        ;;        CRIMP(VOX) = true;   /* 063 Crimp beam at this edit pos */      end;      else if T < "140" then do case (T & MASK5); /* 32 two word records */        ;;;;;;;;        ;        do; /* 111 Set tie direction */          if DATA8 then TIE_MASK_VALID = B_MASK#;                   else TIE_MASK_VALID = C_MASK#;          TIE_MASK = DATA16;        end;        ;;;;;;        do; /* 120 Time signature change */          BEAT_MEAS   = shr(DATA16,8); /* Get the numerator of the time signature (i.e. beats per measure) */          BEAT_NOTE   = DATA16 & LBYTE; /* Get the denominator of time signature (i.e. beat note) */          FORMAT      = (FORMAT & ~(F_COMT \ F_CUTT));          if (DATA8 & R_COMT) ~= 0 then FORMAT = FORMAT | F_COMT;          if (DATA8 & R_CUTT) ~= 0 then FORMAT = FORMAT | F_CUTT;          if ~TABLATURE & (DATA8 & INVISIBLE#) = 0 then          call TIME_SIGN (TIM_X,BEAT_MEAS,BEAT_NOTE,FORMAT); /* Plot the time signature */        end;      end;      call PLOT_RECORD (BUFF,PP,X);   /* Plot the edit record */      RECORD_PRESENT = true;    end;    if RECORD_PRESENT & MAIN_MODE = SYSEDIT# then call EDIT_MARK (X); /* If editing and there is an edit record then draw an edit mark */end PLOT_EDIT_RECORDS;PLOT_NOTE_RECORD:procedure (NP,X) swap3; /* Plots a chord given a pointer to the first note record in chord */  dcl (NP,HNP)    pointer, /* Note record pointer */      (X,DOTX)    fixed,   /* X position */      WIDTH       fixed,   /* Note width */      STEM_OFF    fixed,   /* Stem origin offset */      (VAL,LEN)   fixed,   /* Note value, stem length */      (NX,SX,BX)  fixed,   /* Note X position, Stem X position, Voice X position */      (Y,DIR,VOX) fixed,   /* Y position, Stem direction, Voice of note */      (X1,X2,XM)  fixed,   /* X slur positions */      (Y1,Y2,YM)  fixed,   /* Y slur positions */      (I,J,T,LY)  fixed,      TNY(1)      fixed,      F(1)        fixed,      TOP_NOTE(1) pointer, /* Holds a pointer to highest note in each chord */      GBEAM(1)    boolean;  if TIE_MASK_VALID = B_MASK# then TIE_MASK = CONVERT_MASK (TIE_MASK,CHORD_LEN(NP));        if (core(NP+D6) & B_TUP) ~= 0 then NP = core(NP+GRP); /* There can be only one tup record per chord, and it will be at top of chord */  /* Scan chord to find top note in each voice, set TOP_NOTE(VOICE) to point     if it isn't the only note in the voice. This is only used if HEAD_TYPE     is HD_HARM# for alternate harmonic string notation. */  if HEAD_TYPE(VOX) = HD_HARM# then do; /* Alternate harmonics */    TOP_NOTE(1) = null; F(1) = 0; TNY(1) = 0;    TOP_NOTE(0) = null; F(0) = 0; TNY(0) = 0;    I = NP;    do while I ~= null;      if (core(I+D6) & B_REST) = 0 then do;        VOX = core(I+D6) & MASK1;        Y   = core(I+D2) & LBYTE;                    F(VOX) = F(VOX) + 1;        if TNY(VOX) <= Y then do;          TOP_NOTE(VOX) = I;          TNY(VOX)      = Y;        end;      end;      I = core(I+GRP);    end;    do I = 0 to 1;      if F(I) = 1 then TOP_NOTE(I) = null;    end;  end;  HNP = NP; DOTX = X + 8 - 1; LY = -1;  do while NP ~= null;       /* Do while there are records in the list */    call LOAD_RECORD (NP);   /* Load a note record */    VAL   = shr(REC(D2),8) & MASK4;             /* Find the note value */    Y     = REC(D2) & LBYTE;                VOX   = REC(D6) & MASK1;                WIDTH = 8; if VAL = WHOLE# then WIDTH = 12;/*    if (REC(D6) & B_REST) ~= 0 then if       (VOX = 1 & (PLOTBITS & P_ROFF1) = 0) \       (VOX = 0 & (PLOTBITS & P_ROFF0) = 0)*/    if (REC(D6) & B_REST) ~= 0 then do; /* This is a rest */      if ~TABLATURE then do;      if (CLEF&MASK6) = SINGLE_CLEF# & VAL = WHOLE# & Y = S3 then Y = S2;/*    T = core(NP+GRP);                 * Find the group pointer to next note/rest in chord        if T ~= null then do;             * If there is another note/rest        J = shr(core(T+D2),8) & MASK4;        I = B_CREST \ B_REST \ B_DOT;   * Make sure they are exactly the same        if (REC(D6) & I) = (core(T+D6) & I) & VAL = J then do; * Average the two y positions to get the real y position          I = core(T+D2) & LBYTE;          if (CLEF&MASK6) = SINGLE_CLEF# & VAL = WHOLE# & I = S3 then I = S2;          Y  = (Y + I) / 2;          core(NP+D2) = (core(NP+D2) & UBYTE) \ Y;          core(T +D2) = (core(T +D2) & UBYTE) \ Y;          NP = T;        end;      end;*/      if (REC(D6) & B_CREST) ~= 0 then do;        /* If a centered whole rest */        if (REC(D6) & (B_ROFF | B_SUPREST)) = 0 then REST_CNT = 1;  /* Then indicate to plot a whole rest at the end of the bar */      end;      else if (REC(D6) & B_SUPREST) = 0 then do;        if HEAD_TYPE(VOX) = HD_GRACE#        then call GREST (VAL,0,X,Y);        else call REST (VAL,0,X,Y);        NX = X;      end;      end;    end;    else do; /* This is a note */      DIR = CONV(REC(D6) & B_DIR);           /* Determine the stem direction */      J   = 6; if VAL = WHOLE# then J = 8;   /* Get ledger line width */      T = shr(REC(D5),8) & MASK2;      /* Set voice offset (3 = -2) */      if T = 3 then T = -2;      BX = X + T*(WIDTH/2);      if (REC(D5) & B_NOFF) ~= 0 then NX = BX + WIDTH*DIR;   /* If note offset is set, then the note is on other side of stem */                                 else NX = BX;      I = NX + WIDTH - 1;        /* Dot position for this note */      if I > DOTX then DOTX = I; /* Keep rightmost dot position */      STEM_OFF = 0;      if TABLATURE then do;        I  = Y;        Y  = L1 - 4 + VAL*9;        NX = X;        J  = X; if I >= 10 then J = X - 4;        LOWER_FONT = F_TABLATURE#;        if I = 255 then call PLOT_CHARACTER (asc.x,J,Y,UP#);                   else call NUMBER (J,Y,I,1,F_TABLATURE#);      end;      else if HEAD_TYPE(VOX) < "10" then do case HEAD_TYPE(VOX);        do;          call NOTE (VAL,NX,Y); /* Standard notes */          STEM_OFF = DIR;        end;        do; /* Cue notes */          call GNOTE (VAL,NX,Y);          J = J - 2; /* Ledger lines shrink to match notes */        end;        do; /* Percussion (X) notes */          if VAL <= 1 then PLOT_SYMBOL ("357",NX,Y,UP#);          else do;            PLOT_SYMBOL ("347",NX,Y,UP#);            STEM_OFF = 3 * DIR;          end;        end;        STEM_OFF = SNOTE (VAL,NX,Y,LY=Y|DIR=-1,false); /* Shape notes - 7 shape */        STEM_OFF = SNOTE (VAL,NX,Y,LY=Y|DIR=-1,true ); /* Shape notes - 4 shape */        ; /* No note head */        do; /* Diamond percussion notes */          if VAL <= 1 then PLOT_SYMBOL ("307",NX,Y,UP#);          else do;            PLOT_SYMBOL ("347",NX,Y,UP#);            STEM_OFF = 3 * DIR;          end;        end;      end;      else if HEAD_TYPE(VOX) < "30" /* Single shape notes */      then STEM_OFF = RNOTE (VAL,NX,Y,DIR=-1,HEAD_TYPE(VOX));      else if HEAD_TYPE(VOX) = HD_HARM# then do; /* Alternate harmonics */        if NP = TOP_NOTE(VOX) then do;          PLOT_SYMBOL ("235",NX,Y,UP#);/*        STEM_OFF = SIGN_BIT; */          STEM_OFF = 0;        end;        else call NOTE (VAL,NX,Y); /* Standard notes */      end;      else if HEAD_TYPE(VOX) = HD_DIAM# then do;        PLOT_SYMBOL ("235",NX,Y,UP#);/*      STEM_OFF = SIGN_BIT; */        STEM_OFF = 0;      end;      if (CLEF&MASK6) < SINGLE_CLEF#      then call LEDGER (NX,Y,J); /* Draw ledger lines (LEDGER called redundantly) */      if (REC(D6) & B_STEM) ~= 0 then do;      /* If this is a stem note */        LEN          = REC(D3) & LBYTE;        /* Find the stem length */        OBEAM(VOX)   = shr(REC(D3),12);        /* Determine open beam degree (how many to open) */        CBEAM(VOX)   = shr(REC(D3),8) & MASK4; /* Determine closed beam degree (how many to close) */        if HEAD_TYPE(VOX) = HD_GRACE#        then SX = BX + 3*DIR; /* Calculate stem position = voice position + half note*direction */        else SX = BX + 4*DIR; /* Calculate stem position = voice position + half note*direction */        if (REC(D6) & B_FLAG) ~= 0 &           ((VOX = 1 & (PLOTBITS & P_FOFF1) = 0) \            (VOX = 0 & (PLOTBITS & P_FOFF0) = 0))        then I = VAL - QUARTER#;        else I = 0;        J = LEN;        if BEAM_DEG(VOX) > 0 then J = J - 1; /* This keeps stems under the beam from sticking out */                             else GBEAM(VOX) = false; /* Reset GBEAM if no beam in progress */        if (VOX = 1 & (PLOTBITS & P_SOFF1) = 0) \           (VOX = 0 & (PLOTBITS & P_SOFF0) = 0) then do;        if HEAD_TYPE(VOX) = HD_NONE# then call STEM (SX,Y,J*DIR,I); /* NONE */        if HEAD_TYPE(VOX) = HD_STANDARD#        then call STEM (SX,Y+STEM_OFF,J*DIR-STEM_OFF,I);        if HEAD_TYPE(VOX) = HD_GRACE# then do;       /* GRACE    */            call GSTEM (SX,Y,J*DIR,I,true);            if BEAM_DEG(VOX) = 0 then GBEAM(VOX) = true;        end;        if HEAD_TYPE(VOX) = HD_XNOTE# | HEAD_TYPE(VOX) = HD_PERC#        then call STEM (SX,Y+STEM_OFF,J*DIR-STEM_OFF,I);  /* XNOTE    */        else if HEAD_TYPE(VOX) = HD_SHAPE# | HEAD_TYPE(VOX) = HD_4SHAPE# |                "10" <= HEAD_TYPE(VOX)        then do;          T = STEM_OFF; /*EXPAND(STEM_OFF,8);*/          call STEM (SX,Y+T,J*DIR-T,I/*,rot(STEM_OFF,1)*/);   /* SNOTE    */        end;        end; /* End of stemming block */        if OBEAM(VOX) > CBEAM(VOX) then do; /* Open beams - all this could be better */          SM_BEAM_DEG(VOX) = CBEAM(VOX); /* Forward small beam degree */          OBEAM(VOX)       = OBEAM(VOX) - CBEAM(VOX);          do I = BEAM_DEG(VOX) to BEAM_DEG(VOX) + OBEAM(VOX) - 1; /* Open beams by degree */            BEAMSTACK(I*4+0+VOX) = SX; /* X position is the stem position */            if CRIMP(VOX) then J = LEN * DIR;                          else J = (LEN - BEAM_SPACING*I) * DIR;            BEAMSTACK(I*4+2+VOX) = Y + J; /* Y is the end of the stem - vertical offset of the beams */          end;          BEAM_DEG(VOX) = BEAM_DEG(VOX) + OBEAM(VOX); /* Increase # of beams in progress by # of open beams */        end;        else do; /* Close beams - all this could be better */          if OBEAM(VOX) > 0 then do;            SM_BEAM_DEG(VOX) = OBEAM(VOX); /* Reverse small beam degree */            CBEAM(VOX)       = CBEAM(VOX) - OBEAM(VOX);            REVBEAM            = true;          end;          else REVBEAM = false;          do I = BEAM_DEG(VOX) - CBEAM(VOX) to BEAM_DEG(VOX) - 1; /* Close main beams by degree*/            if CRIMP(VOX) then J = LEN * DIR;                          else J = (LEN - BEAM_SPACING*I) * DIR;            call BEAM                (BEAMSTACK(I*4+0+VOX),   /* Start of beam in beamstack */                 BEAMSTACK(I*4+2+VOX),                    SX,                       /* Ending point is stem position */                 Y + J, DIR, GBEAM(VOX));          end;          if SM_BEAM_DEG(VOX) > 0 then do;            X1 = SM_BEAMST(0+VOX);       /* Get start of beam */            Y1 = SM_BEAMST(2+VOX);            X2 = SX;                       /* Get end of beam based on stem position */            Y2 = Y + LEN*DIR;              /* Determine Y offset by length and direction of stem */            if REVBEAM                     /* If a reverse beam (right-most to left) */            then XM = X2 - 7;            else XM = X1 + 7;              /* (right) */            J  = (Y2 - Y1) * (XM - X1);    /* Assume Y1 is the origin */            T  = X2 - X1;                  /* Find the midpoint */            YM = J / T;                    /* Round vertical y offset midpoint to nearest pixel */            if J mod T >= T / 2 then YM = YM + 1; /* So that it's not crooked */            YM = YM + Y1;            if REVBEAM then do;              X1 = XM; Y1 = YM;            end;            else do;              X2 = XM; Y2 = YM;            end;            do I = 0 to SM_BEAM_DEG(VOX)-1; /* Close small beams (This is in fact pretty aweful) */              J = BEAM_SPACING*(I+BEAM_DEG(VOX))*DIR; /* Draw each beam down the stem */              call BEAM (X1,Y1-J,X2,Y2-J,DIR,GBEAM(VOX)); /* Otherwise, plot a beam */            end;            SM_BEAM_DEG(VOX) = 0;          end;          BEAM_DEG(VOX) = BEAM_DEG(VOX) - CBEAM(VOX);        end; /* End of close beams */        SM_BEAMST(0+VOX) = SX;           /* Set small beam opening position */        SM_BEAMST(2+VOX) = Y + LEN*DIR;  /* Set y offset by length of stem */      end; /* End of stemming block */      if ~TABLATURE then do;      I = 10; if VAL = WHOLE# then I = 12;      I = X - I - shr(REC(D4),12) * 8;     /* Calculate accidental offset */      if HEAD_TYPE(VOX) = HD_GRACE#      then do case (shr(REC(D4),8) & MASK4);    /* Plot grace accidental */        ;        PLOT_SYMBOL ("210",I,Y,UP#); /* Double sharp */        PLOT_SYMBOL ("373",I,Y,UP#); /* Grace Sharp */        PLOT_SYMBOL ("374",I,Y,UP#); /* Grace Natural */        PLOT_SYMBOL ("375",I,Y,UP#); /* Grace Flat */        PLOT_SYMBOL ("214",I,Y,UP#); /* Double flat */      end;      else do case (shr(REC(D4),8) & MASK4);    /* Plot accidental */        ;        PLOT_SYMBOL ("210",I,Y,UP#); /* Double sharp */        PLOT_SYMBOL ("211",I,Y,UP#); /* Sharp */        PLOT_SYMBOL ("212",I,Y,UP#); /* Natural */        PLOT_SYMBOL ("213",I,Y,UP#); /* Flat */        PLOT_SYMBOL ("214",I,Y,UP#); /* Double flat */      end;      end; /* End accidental block */      J = shl(shr(REC(D5),12),1) \ VOX; /* Tie Code */      if (REC(D6) & B_CTIE) ~= 0 then do; /* Close a tie */        if TIE_X(J) = 0 then do;/* This means that the tie opened last line */          I = -DIR; if TRACK(1) ~= 0 then I = DIR;/* First, assume tie is opposite direction of stem. Then, if two voices, then direction is same as stem */          if TIE_MASK_VALID ~= NOMASK# then I = CONV(TIE_MASK&MASK1); /* However, if tie editing command, direction is user designated */          MAT(0) = TIE_1ST_X; /* WAS NX-NOTE_SPACE */          MAT(1) = Y+TIE_Y_POS#*I;          MAT(6) = NX - TIE_X_POS#; /* WAS NX-4+2*I; */          MAT(7) = Y+TIE_Y_POS#*I;          call FIND_CONTROL_POINTS (MAT,I); call NSLUR (MAT,0);          TIE_Y(J) = I & SIGN_BIT;  /* Store the direction value */        end;        else do;          I = CONV (TIE_Y(J) & SIGN_BIT);          MAT(0) = TIE_X(J) + TIE_X_POS#; /* WAS TIE_X(J)+4+2*I; */          MAT(1) = (TIE_Y(J)&LBYTE)+TIE_Y_POS#*I;          MAT(6) = NX - TIE_X_POS#; /* WAS NX-4+2*I; */          MAT(7) = Y+TIE_Y_POS#*I;          call FIND_CONTROL_POINTS (MAT,I); call NSLUR (MAT,0);          TIE_X(J) = 0; /* Store the direction value */        end;      end;      if (REC(D6) & B_OTIE) ~= 0 then do;    /* Open a tie */        I = -DIR; if TRACK(1) ~= 0 then I = DIR;  /* First, tie direction is opposite of stem direction. Then, if two voices direction is same as stem. */        if TIE_MASK_VALID ~= NOMASK# then I = CONV(TIE_MASK&MASK1);/* Otherwise, direction is user designated */        else if (REC(D6) & B_CTIE) ~= 0 then I = TIE_Y(J) & SIGN_BIT;        TIE_X(J) = NX;                      /* Determine the X and Y tie coordinates */        TIE_Y(J) = (I & SIGN_BIT) \ Y;      end;      TIE_MASK = shr(TIE_MASK,1);  /* Get the appropriate tie mask for the next note in chord */    end; /* End of note record case */    NP = core(NP+GRP);   /* Get the next note record in the chord */    LY = Y;  end; /* End of group (chord) loop */  NP = HNP; J = 0;  if NP = null | TABLATURE then T = 0; /* Stop */  else if core(NP+GRP) = null      then T = 1; /* Up   */  else                                  T = 2; /* Down */  do while T > 0; /* Re-scan chord down and up for dots */    if  (core(NP+D6) & B_DOT)    ~= 0 &         /* Plot a dot for a dotted note/rest */       ((core(NP+D6) & B_REST)    = 0 \        (core(NP+D6) & B_SUPREST) = 0) then do;      I   = 0;      Y   = core(NP+D2) & LBYTE;                  VOX = core(NP+D6) & MASK1;                  if Y mod 6 = 0 & ((core(NP+D6) & B_REST) = 0 \ (L1 <= Y & Y <= L5))      then do;        if (core(NP+D6) & B_REST) ~= 0 then I = -3;        else do;          if TWO_VOICE & VOX = 0 & (FORMAT & F_LVDOT) = 0          then I = -3;          else I =  3;          if Y + I = J then I = -I;        end;      end;      J = Y + I;      PLOT_SYMBOL ("241",DOTX,J,UP#);    end;    if T = 2 then do;      if core(NP+GRP) ~= null then NP = core(NP+GRP);   /* Get the next note record in the chord */      else do;        T = 1; J = 0;      end;    end;    else do;      if NP = HNP then T = 0;      else NP = core(NP);    end;  end;end PLOT_NOTE_RECORD;PLOT_LIST:procedure (PP,NP,X,LEVEL) recursive swap3; /* Prints the music. The recursion handles tuplets */  dcl PP      pointer, /* position record pointer */      NP      pointer, /* Note pointer */      X       fixed,   /* X position */      LEVEL   fixed,   /* Edit block level */      XX(1)   fixed,   /* Next X position */      POS_CNT fixed,   /* Position record count */      HV      fixed,      I       fixed,      (P,Q)   pointer,      FLAG    boolean;/*error_case do;  transparent_mode;  pstringr('-----------------------------------------');  pstring('PlotList here, LEVEL,VOICE: ');  pnum(LEVEL,0); pnum(VOICE,5); crlf;  print_edit_stack (LEVEL); crlf; call rchar;end;*/  POS_CNT = 0; FLAG = true;  do while FLAG; /* Position record loop */    do while ~term_idle & peek ~= asc.refresh; /* Handle user break (space) */      I = rchar;         /* Get rid of random typed ahead chars */      if I = sp then do;        if RUNNING & MAIN_MODE >= PRINT# then call CLEAR_LASER_PRINTER;        REPLOT_MEASURE = 0;   /* Initialize in order to exit from Replotting a measure */        call RE_START; /* Break if space is pressed and return to main menu*/      end;    end;    XX(0) = X;    /* Determine the current X position */    call PLOT_POSITION_RECORD (PP,XX,LEVEL,POS_CNT);  /* Plot the position information */    if LEVEL = 0 then call SNAP_EDIT_STACK (0);    call PLOT_EDIT_RECORDS (PP,XX(0),LEVEL);  /* Plot the edit records *//*  call SNAP_EDIT_STACK (1); */    if POS_CNT = 0 then do;           /* If there is a note */      POS_CNT = core(NP+D5) & LBYTE;  /* Find the position advance */      if (PLOTBITS & P_POFF) = 0 then do; /* If plotting is on */        HV = VOICE;        if (core(NP+D6) & B_TUP) ~= 0 then do VOICE = 0 to 1;  /* If there is a tuplet record */          Q = core(NP+D1+VOICE); /* Get NoteSublist pointer */          if Q ~= null then do;            P = PP; /* Get PosFrond pointer */            do I = 1 to (core(NP+D3+VOICE) & LBYTE);              P = core(P+GRP);            end;/*error_case do;  transparent_mode;  pstring('Tuplet found LEVEL,VOICE: ');  pnum(LEVEL,0); pnum(VOICE,5); crlf;end;*/            if LEVEL = 0 then do;/*error_case do;  transparent_mode;  pstring('Before unsnap'); crlf;  print_edit_stack(LEVEL); crlf;end;*/              call UNSNAP_EDIT_STACK (0); /* Locate tup list of correct voice *//*error_case do;  pstring('After Unsnap'); crlf;  print_edit_stack(LEVEL); crlf;end;*/              do while GET_NEXT_RECORD ("100000"\LEVEL,BUFF,false); end;/*error_case do;  transparent_mode;  pstring('After Advance'); crlf;  print_edit_stack(LEVEL); crlf;end;*/            end;            call PLOT_LIST (P,Q,X,LEVEL+1);    /* Plot the frond *//*error_case do;  transparent_mode;  pstring('After PlotList'); crlf;  print_edit_stack(LEVEL); crlf;end;*/          end;        end;        VOICE = HV;        call PLOT_NOTE_RECORD (NP,XX(0));      /* Plot the chord given the first note */      end;      NP = core(NP);    end;/*  call UNSNAP_EDIT_STACK (1); */    /* Keep TWO_VOICE up to date since it is used for dot Y positioning */    if TRACK(0) ~= 0 & TRACK(1) ~= 0 then TWO_VOICE = true;                                     else TWO_VOICE = false;    if (core(PP+D6) & B_EOL) ~= 0 then FLAG = false; /* If at the end of the line - stop */    POS_CNT = POS_CNT - 1;   /* Decrement position count */    X       = XX(1);         /* Set X postion to the next note */    PP      = core(PP);      /* Advance the postion record pointer */  end;  if LEVEL = 0 then do; /* If on axis, update pointers for next pass */    POSN_PTR = PP;    NOTE_PTR = NP;  end;end PLOT_LIST;PLOTTER:procedure public swap3; /* Plots the initial clef, staff and bars, etc. */  dcl P            pointer,      BRACE_LEN    fixed, /* static */      BRACKET_LEN  fixed, /* static */      STAFF_HEIGHT fixed,      (I,J,K,X,X0) fixed;  /* Plot staff and all non edit-flow staff related items (clef, time sig, etc.) */  STAFF_HEIGHT = L5 - L1;  if TABLATURE then do;    call TAB_LINES (START_STAFF(SYSTEM),STOP_STAFF(SYSTEM),6);    STAFF_HEIGHT = 5*9;  end;  else call STAFF_LINES (START_STAFF(SYSTEM),STOP_STAFF(SYSTEM),(CLEF&MASK6) = SINGLE_CLEF#);   /* Draw the staff lines */  BAR_LEN = STAFF_HEIGHT;  if (PBITS & P_CBRK) = 0 & STAFF > 0 then BAR_LEN = STAFF_SPACE(PART);  X = START_STAFF(SYSTEM);  if STAVES > 0 then do;      /* If plotting more than one staff */    X0 = X;    J = false;    if (PBITS & (P_OBRC \ P_CBRC)) = (P_OBRC \ P_CBRC) then J = true;    if (PBITS & (P_OBAR \ P_CBAR)) ~= 0 then X0 = X0 - 5;    if (PBITS & (P_OBRC \ P_CBRC)) ~= 0 & ~J then X0 = X0 - 3;    BRACE_LEN   = BRACE_LEN   + STAFF_SPACE(PART);    BRACKET_LEN = BRACKET_LEN + STAFF_SPACE(PART);    P = NAME_BASE + PART * 18; /* Get pointer to instrument name */    if MEASURE_NUMBER > 1 then P = P + 9; /* If not 1st meas, use inst abbrev */    if core(P) ~= 0 & ((PBITS & P_OBRC) = 0 \ J) &       STAFF_SPACE(PART) > 0    then do; /* Plot inst name */      if PRINTER_TYPE > 1 then K = F_STANDARD#; else K = F_ALPHA#;      call blockmove (loc(P),BUFF,9);      if FIRST_INDENT = 0 then X0 = 3;      else do;        X0 = X0 - STRING_LEN (BUFF,K) - 3;        if X0 < 3 then X0 = 3;      end;      call INSNAME_STR (BUFF);      I = L1 - 3 + STAFF_HEIGHT/2;      if (PBITS & P_CBRC) ~= 0 & ~J  /* Center the instrument name between current and previous staff */      then I = L1 - 3 + BRACE_LEN/2;      UPPER_FONT = F_MUSIC#;      LOWER_FONT = K;      call PLOT_STRING (BUFF,X0,I,BUFF(0),1);    end;    I = X - 3; /* Brace X center offset from left edge */    if (PBITS & (P_OBAR \ P_CBAR)) ~= 0 then I = I - 5; /* Offset to clear bracket */    if      ((PBITS & P_OBRC) ~= 0 & ~J) | STAFF = 0 then BRACE_LEN = STAFF_HEIGHT;    else if  (PBITS & P_CBRC) ~= 0 & ~J then call BRACE (I,L1,BRACE_LEN);    I = X - 4;    if (PBITS & (P_OBAR \ P_CBAR)) = P_OBAR | STAFF = 0 then BRACKET_LEN = STAFF_HEIGHT;    if (PBITS & (P_OBAR \ P_CBAR)) = P_CBAR then call BRACKET (I,BRACKET_LEN);    else if J                               then call BRACKET (I,STAFF_HEIGHT);    call BAR (X,BAR_LEN);  /* Plot a barline */  end;  if (PBITS & P_BBRK) ~= 0 then BAR_LEN = STAFF_HEIGHT;     /* If a bar break, only plot from top to bottom of staff */  I = false;  if MEAS_FREQ ~= 0 & MEASURE_NUMBER >= MEAS_SYNC then do;    write(5) = MEASURE_NUMBER - MEAS_SYNC;    write(7) = MEAS_FREQ;    if read(4) = 0 then I = true;  end;  else if MEASURE_NUMBER > 1 then I = true;  if STAFF = 0 & INIT_MEAS ~= 0 & I & (PLOTBITS & P_MNOFF) = 0  then call PLOT_MEAS_NO (X);  if (CLEF & INVISIBLE#) = 0 then do;    call PLOTCLEF (CLEF,X,false);    X = X + 24;    end;  WHOLE_REST_LEFT = X;  if ~TABLATURE then do;  call PLOTKEY  (KEY,KEY,X+6); /* WAS +8 */          I = shr(core(POSN_PTR+D6),5) & MASK3; /* Make room for max key sig */  if I > 0 then X = X + I*8 + 4; /* WAS 8 */  WHOLE_REST_LEFT = X;  if (core(POSN_PTR+D3) & B_HTIM) ~= 0 then do;  /* If the time signature (held time) should be plotted */    call TIME_SIGN (X+(TIMESIG_GAP/2),BEAT_MEAS,BEAT_NOTE,FORMAT);    X = X + TIMESIG_GAP;  end;  if (core(POSN_PTR+D3) & B_HREP) ~= 0 then do;   /* If held open repeat */    call REPEAT (X,BAR_LEN,false);  end;  if (core(POSN_PTR+D3) & B_HDBR) ~= 0 then do;   /* If held dbar repeat */    call BAR (X,  BAR_LEN);    call BAR (X+3,BAR_LEN);  end;  end;  EDIT_SKIP   = 0;   BEAM_DEG(0) = 0; SM_BEAM_DEG(0) = 0;  BEAM_DEG(1) = 0; SM_BEAM_DEG(1) = 0;  REST_CNT    = 0;  POST        = 0;  VOICE       = 0;  BLOCK_REST_LEFT = 0;  TIE_1ST_X   = X - 2;  if TIE_1ST_X < START_STAFF(SYSTEM) then TIE_1ST_X = START_STAFF(SYSTEM);  do I = 0 to 31; TIE_X(I) = 0; end; /* Clear tie arrays *//*error_case examen (POSN_PTR,POSN#,'POSN in Plotter');error_case examen (NOTE_PTR,NOTE#,'NOTE in Plotter');*/  call LOAD_EDIT_STACK;  call PLOT_LIST (POSN_PTR,NOTE_PTR,0,0); /* Plot the list */  call DUMP_EDIT_STACK;  do J = 0 to 31; /* Close any ties left open */    if TIE_X(J) ~= 0 then do;      I = CONV (TIE_Y(J) & SIGN_BIT);/* Determine direction by direction bit */      TIE_Y(J) = TIE_Y(J) & LBYTE;   /* Remove direction bit */      MAT(0) = TIE_X(J) + TIE_X_POS#; /* TIE_X(J)+4+2*I; */      MAT(1) = TIE_Y(J)+TIE_Y_POS#*I;      MAT(6) = BAR_X;      MAT(7) = TIE_Y(J)+TIE_Y_POS#*I;      call FIND_CONTROL_POINTS (MAT,I); call NSLUR (MAT,0);    end;  end;end PLOTTER;end PLOTRTNS;