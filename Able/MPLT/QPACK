/*TITLE:   Q-PACK -- Cicular queue libraryAUTHOR:  Larry Gallagher, New England Digitial Co.DESCRIPTION:This package implements a circular queue data structure.It will build and maintain circular queues of CHARACTERS (bytes), usingan internal fixed array.PROCEDURE DESCRIPTION:   Init_QPACK           -- Intializes the queue package.  Must be called first.   Init_Queue (queue)   -- initializes a specific queue to empty queue.   Scratch_Queue (queue)-- erases specified queue.   Enqueue(queue,item)  -- adds item to specified queue.  Item is type char.   Dequeue(queue)       -- returns a character from the tail and dequeues.   Peek_Queue(queue)    -- returns character at tail of queue, but does not dequeue.   Queue_Empty(queue)   -- returns Boolean TRUE if no data in queue.   Queue_Error          -- returns result code of head operation.   Queue_Free(queue)    -- returns the number of free bytes in the queue.   Queue_Size(queue)    -- returns total capacity of queue.DATA DESCRIPTION:      The queues are declared as static fixed arrays, with two fixed indeces   used as pointers to either end.  The queues are circular; upon reaching   the high end of the array, the pointers wrap around to byte 0.     All routines set an error code which can be read with Queue_Error.   If the routine executed successfully, TRUE is returned, otherwise   FALSE is returned.  Examples of unsuccessful completion might include   Enqueuing into a full queue, Dequeueing from an empty queue, etc.USAGE:   A programmer using this package must have the following statement   in the program declarations:      insert 'QPACK';MODIFICATION HISTORY:                                               Date      Who         What   ----      ---         ----   6/24/87   LPG         Began Initial Development   6/26/87   LPG         Added Queue_Free, Queue_Size   7/2/87    LPG         Fixed qsize errors, cleaned up code.   7/6/87    LPG         Added Peek_Queue.   7/10/87   LPG         Increased qsize to 1K.*//* $subtitle 'Global Declarations, Procedures INIT_QPACK, QUEUE_EMPTY' */       /* for now, put all declarations here for easy viewing */DCL qbegin LIT '4';           /* first avail byte of queue */dcl size lit '0';dcl tail lit '1';dcl head lit '2';dcl rot_buf_size lit '256';dcl rot_buf lit '(shr(rot_buf_size,1) + 3)  fixed';dcl big_rot_buf_size  lit '1024';        /* we'll allow 1K bytes in our queues */dcl big_rot_buf  lit '(shr(big_rot_buf_size,1) + 3) fixed';dcl qdcl  lit 'fixed array';            /* for internal declarations *//* QUEUE_EMPTY -- return boolean TRUE if queue is empty, FALSE if not QUEUE_EMPTY simply compares the tail and head pointer of the queue,and returns the logical result of that comparison (TRUE if equal,FALSE if not.)*/QUEUE_EMPTY: procedure(my_queue) returns (Boolean)  ;      dcl my_queue qdcl;   return (my_queue(tail) = my_queue(head));end QUEUE_EMPTY;/* $subtitle 'Procedures SCRATCH_QUEUE, INIT_QUEUE' *//*SCRATCH_QUEUE -- procedure to erase a given queue This procedure first zeroes all the bytes in the queue, and resetsthe tail and head pointers to point to element 0 in the queue.*/SCRATCH_QUEUE: procedure (my_queue)  ;   /* erase the particular queue */   dcl my_queue       qdcl,       i              fixed;   /* zero all the items */   do i = qbegin to my_queue(size);     call pbyte(my_queue,i,0);   end;   /* reset the pointers to item 0 */   my_queue(tail) = qbegin;   my_queue(head) = qbegin;end SCRATCH_QUEUE;/*INIT_QUEUE -- initialize a particular queue.This procedure is passed a queue declared in the the programmer'sspace, and initializes it to an empty queue.  Currently, all itdoes is call Scratch_Queue to erase it.*/INIT_QUEUE: procedure (my_queue, my_size)  ;   /* initialize the particular queue */ dcl my_queue qdcl; dcl my_size fixed;              /* number of bytes available */   my_queue(size) = my_size + qbegin;   call SCRATCH_QUEUE(my_queue);end INIT_QUEUE;/* $subtitle 'Procedure ENQUEUE' *//*ENQUEUE -- add a byte to the end of the circular queue.ENQUEUE takes a queue and a byte of data (the lower byte in afixed data type ) and adds the byte to the queue if possible.Addition is to the tail end of the FIFO queue.  If there is noroom left in the queue, the procedure does nothing and returnsFALSE.  Upon successful addition, it updates the 'head' pointerand returns TRUE.*/ENQUEUE:  procedure(my_queue, item)  ;      dcl my_queue  qdcl,       item      fixed;       /* assuming char in lower byte */   dcl next      fixed;       /* location we're adding item to */   /* compute next location and wraparound to qbegin if we hit the end */   next = my_queue(head) + 1;   if next > my_queue(size) then next = qbegin;   /* if no room in queue (pointers collide), return FALSE */   if next = my_queue(tail)   then return(false);   else do;                     /* otherwise, add it and update the 'head' pointer */      call pbyte (my_queue, my_queue(head), item);      my_queue(head) = next;      return(true);   end;end ENQUEUE;/* $subtitle 'Procedure DEQUEUE' *//*DEQUEUE -- return a byte from the front of the circular queue.DEQUEUE returns the item from the front of the circular queue, andupdates the 'tail' pointer to remove that item from the queue.If the queue is empty (ie, 'tail' and 'head' pointers are identical),a FALSE is returned.  Otherwise, the byte is returned in 'item' anda TRUE is returned as the function result.*/DEQUEUE: procedure(my_queue) returns (fixed)  ;   dcl my_queue   qdcl,                    /* the queue to look at */       item       fixed;                   /* return the item through this */   dcl next       fixed;                   /* points to item following tail */      /* return error on empty queue */   if my_queue(head) = my_queue(tail)   then return(-1);   else do;      /* compute the new update for the 'tail' pointer, and wraparound if      necessary */      next = my_queue(tail) + 1;      if next > my_queue(size)       then next = qbegin;      /* read the value and update the 'tail' pointer */      item = byte(my_queue, my_queue(tail));      my_queue(tail) = next;      return(item);   end;end DEQUEUE;PEEK_QUEUE: procedure (my_queue) returns(fixed)  ;   dcl my_queue qdcl;   dcl item fixed;   if Queue_Empty(my_queue)   then item = -1;   else item = byte(my_queue, my_queue(tail));      return(item);end PEEK_QUEUE;/* $subtitle 'Procedure QUEUE_FREE, QUEUE_SIZE' *//*QUEUE_FREE -- returns number of free bytes in bufferThis procedure looks at the head and tail pointers, and performsthe necessary arithmetic to computer the number of free bytes.NB:  This will work on any size buffer; it is not limited tosizes of a power of two.*/QUEUE_FREE: procedure (my_queue) returns (fixed);   dcl my_queue qdcl;   if my_queue(tail) <= my_queue(head)   then return( (my_queue(size) - my_queue(head))       + ( my_queue(tail) - qbegin));   else return(my_queue(tail) - my_queue(head) - 1);end QUEUE_FREE;xQUEUE_FREE: procedure (my_queue) returns (fixed);   dcl my_queue qdcl;   if my_queue(tail) <= my_queue(head)   then return( (my_queue(size) - my_queue(head))       + ( my_queue(tail) - qbegin));   else return(my_queue(tail) - my_queue(head) - 1);end xQUEUE_FREE;yQUEUE_FREE: procedure (my_queue) returns (fixed);   dcl my_queue qdcl;   if my_queue(tail) <= my_queue(head)   then return( (my_queue(size) - my_queue(head))       + ( my_queue(tail) - qbegin));   else return(my_queue(tail) - my_queue(head) - 1);end yQUEUE_FREE;/*QUEUE_SIZE -- procedure returns capacity of the queue in bytes */QUEUE_SIZE: procedure (my_queue) returns (fixed)  ;   dcl my_queue qdcl;   return (my_queue(size) - qbegin);               /* for now...  this is a stub */end QUEUE_SIZE;