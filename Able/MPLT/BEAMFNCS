/* $title List Building Routines *//* Beaming Routines */AVERAGE:procedure (P) returns (fixed);  dcl P pointer;  dcl (SUM,COUNT) fixed;  SUM = 0; COUNT = 0;  do while P ~= null;    if /* (core(P+D2) & THRD4)  ~= 0 & */       (core(P+D6) & B_TUP)   = 0 &       (core(P+D6) & B_VOICE) = VOICE    then do;      SUM   = SUM   + (core(P+D2) & LBYTE);      COUNT = COUNT + 1;    end;    P = core(P+GRP);  end;  return (SUM / COUNT);end AVERAGE;FIND_EXT:procedure (P,DIR); /* 0 = Highest  1 = Lowest */  dcl (P,U,L) pointer,      DIR     boolean;  U = null; L = null;  do while P ~= null;    if (core(P+D2) & THRD4)  ~= 0 &       (core(P+D6) & B_TUP)   = 0 &       (core(P+D6) & B_VOICE) = VOICE    then do;      if U = null then U = P; L = P;    end;    P = core(P+GRP);  end;  if DIR then return (L);         else return (U);end FIND_EXT;FIND_BASE:procedure (P,WHOLE);  dcl (P,Q) pointer,      WHOLE boolean;  Q = null;  do while (P ~= null);    if Q = null &      (WHOLE \ (core(P+D2) & THRD4) ~= 0) &      (core(P+D6) & B_REST)  = 0 &      (core(P+D6) & B_TUP)   = 0 &      (core(P+D6) & B_VOICE) = VOICE    then Q = P;    P = core(P+GRP);  end;  return (Q);end FIND_BASE;SET_DIRECTION:procedure (P,DIR);  dcl (P,DIR) pointer;  do while P ~= null;    if /* (core(P+D2) & THRD4)  ~= 0 & */       (core(P+D6) & B_REST)  = 0 &       (core(P+D6) & B_TUP)   = 0 &       (core(P+D6) & B_VOICE) = VOICE    then do;      if DIR then core(P+D6) = core(P+D6) \  B_DIR;             else core(P+D6) = core(P+D6) & ~B_DIR;    end;    P = core(P+GRP);  end;end SET_DIRECTION;GET_MAX_NOTE_VALUE:procedure (P,CP) returns (fixed);  dcl (P,CP,Q)       pointer,      FLAG           boolean,      MAX_NOTE_VALUE fixed,      V              fixed;  MAX_NOTE_VALUE = WHOLE#;  FLAG = true;  do while FLAG;    do while (core(P+D6) & B_TUP) ~= 0 & core(P+D1+VOICE) ~= null;      P = core(P+D1+VOICE);    end;    Q = FIND_BASE(P,false); /* Stem chord */    if Q ~= null then do;      V = shr(core(Q+D2),8) & MASK4;      if MAX_NOTE_VALUE < V then MAX_NOTE_VALUE = V;    end;    if P = CP then FLAG = false; else P = core(P);  end;  return MAX_NOTE_VALUE;end GET_MAX_NOTE_VALUE;STEM_NOTES:procedure (P,CP,DIR,FLAGS); /* This whole system is kind of God-Awful */  dcl (P,CP,Q)     pointer,      (TP,BP)      pointer,      (DIR,FLAG)   boolean,      FLAGS        boolean,      MAX_NOTE_VALUE fixed,      (LEN,CG,F,Y) fixed;  MAX_NOTE_VALUE = GET_MAX_NOTE_VALUE (P,CP);  FLAG = true;  do while FLAG;    do while (core(P+D6) & B_TUP) ~= 0 & core(P+D1+VOICE) ~= null;      P = core(P+D1+VOICE);    end;    call SET_DIRECTION (P,DIR); /* Set direction of stem */    Q = FIND_BASE(P,false); /* Stem chord */    if Q ~= null then do;      if core(P+GRP) ~= null then do;        TP = FIND_EXT (P, DIR); /* Find nearest note to beam */        BP = FIND_EXT (P,~DIR); /* Find farthest note from beam */        CG = abs((core(TP+D2) & LBYTE) - (core(BP+D2) & LBYTE)); /* Chord gap - from bottom to top of chord */      end;      else do; BP = P; TP = P; CG = 0; end;      F = MAX_NOTE_VALUE - EIGHTH#;/*    F = (shr(core(BP+D2),8) & MASK4) - EIGHTH#; */      if ~FLAGS then F = F - 1; /* A standard stem can support 1 flag or 2 beams */      if F < 0 then F = 0;      LEN = (core(BP+D3) & LBYTE) + F * BEAM_SPACING; /* Space beams/flags 6 pix appart */      Y   = (core(TP+D2) & LBYTE); /* Get top note Y */      if (L3 - Y) * CONV(DIR) > LEN      then LEN = abs(L3-Y); /* All stems must reach L3 */      LEN = LEN + CG;      if LEN > 255 then LEN = 255;      if FLAGS then do;        core(BP+D3) = LEN; core(BP+D6) = core(BP+D6) \ B_STEM \ B_FLAG;      end;      else core(BP+D3) = (core(Q+D3) & UBYTE) \ LEN;    end;    if P = CP then FLAG = false; else P = core(P);  end;end STEM_NOTES;BEAMER:procedure (HEAD);  dcl HEAD      pointer,      LASTP     pointer,      (P,Q,OQ)  pointer,      DIRFLAG   boolean,      DIR       boolean,      BREAK     boolean,      FLAG      boolean,      PPSN      fixed,      DEGREE    fixed,      LASTDEG   fixed,      (Y,CNT)   fixed;  LASTDEG = 0;  PPSN    = 0;  BREAK   = false;  Q       = HEAD;  do while Q ~= null;    P = FIND_BASE(Q,false);    if P ~= null then do; /* A note */      if (core(P+D6) & B_BREAK) ~= 0 then BREAK = true;      if (core(P+D6) & B_MEND)  ~= 0 then BREAK = false;      if BREAK & LASTDEG > 0 then do; /* Close if this is a break point */        core(LASTP+D3) = core(LASTP+D3) \ shl(LASTDEG,8); LASTDEG = 0;      end;      else if (core(P+D6) & B_PBRK) ~= 0 then do;        if 1 < LASTDEG /* Close beams > 1 (partial beam break) */        then core(LASTP+D3) = core(LASTP+D3) \ shl(LASTDEG - 1,8);        LASTDEG = 1;      end;      DEGREE = (shr(core(P+D2),8) & MASK4) - QUARTER#;      if DEGREE < 0 then DEGREE = 0;      if DEGREE > LASTDEG /* Open beams */      then core(P+D3)     = core(P+D3)     \ shl(DEGREE-LASTDEG,12);      if DEGREE < LASTDEG /* Close beams */      then core(LASTP+D3) = core(LASTP+D3) \ shl(LASTDEG-DEGREE,8);      LASTP = P; LASTDEG = DEGREE; BREAK = false;    end;    if (core(Q+D6) & B_TUP) ~= 0 & core(Q+D1+VOICE) ~= null    then Q = core(Q+D1+VOICE);    else Q = core(Q);  end;  if LASTDEG > 0 then core(LASTP+D3) = core(LASTP+D3) \ shl(LASTDEG,8); /* Close last beam */  Y       = 0;  CNT     = 0;  DEGREE  = 0;  DIRFLAG = false;  Q       = HEAD;  OQ      = Q;  do while Q ~= null;    P = FIND_BASE(Q,true);    if P ~= null then do; /* A whole note or greater */      DEGREE = DEGREE + (shr(core(P+D3),12) & MASK4) - (shr(core(P+D3),8) & MASK4);      if (core(P+D6) & B_SET) ~= 0 then do; /* Direction has been preset */        DIR     = ((core(P+D6) & B_DIR) ~= 0);        DIRFLAG = true;      end;      Y   = Y   + AVERAGE(Q); /* OK here */      CNT = CNT + 1;      if DEGREE = 0 then do;        if ~DIRFLAG then DIR = (Y/CNT >= L3); /* Set default direction */        call STEM_NOTES (OQ,Q,DIR,CNT=1);        CNT = 0; Y = 0; OQ = core(Q); DIRFLAG = false;      end;    end; /* End of process note block */    if (core(Q+D6) & B_TUP) ~= 0 & core(Q+D1+VOICE) ~= null    then Q = core(Q+D1+VOICE);    else Q = core(Q);  end;end BEAMER;SET_BEAMS:procedure;  dcl (PP,NP)     pointer,      (XBAR,YBAR) fixed,      (FLAGS,I)   fixed,      AVG_CNT      fixed,      STACK_CNT   fixed;SET_BEAM:procedure;  dcl (P,Q,R) pointer,      (A,B,D) fixed,      (L,X,Y) fixed,      (B1,Y1) fixed,      (NM,DM) fixed,      (SC,CY) fixed,      CNT     fixed,      DIR     fixed,      DIRFLAG boolean;  /* Calculate slope [ E(X-XBAR)(Y-YBAR) / E(X-XBAR)^2 ] */  SC = (AVG_CNT*XBAR*XBAR)/32760; if SC = 0 then SC = 1;  DIR = 0; NM = 0; DM = 0;  do CNT = 0 to STACK_CNT-1 by 2;    P = BUFF(CNT);    X = BUFF(CNT+1);    R = FIND_BASE(P,false);    if R ~= null then do;      if DIR = 0 then do;        DIRFLAG = (core(R+D6) & B_DIR) ~= 0;        DIR     = CONV(DIRFLAG);      end;      A  = X - XBAR;      Q  = FIND_EXT(P,DIRFLAG);      Y  = (core(Q+D2) & LBYTE) + (core(Q+D3) & LBYTE)*DIR;      NM = NM + (A*(Y - YBAR))/SC;/*    NM = NM + (A*( (core(FIND_EXT(P,DIRFLAG)+D2) & LBYTE) - YBAR))/SC; */      DM = DM + (A*A)/SC;    end;  end;  if PRINTER_TYPE > 3 then do;    if (NM*100) / DM <  2  & (NM*100) / DM > -2 then NM = 0; /* Eliminate very small angles */  end;  else if PRINTER_TYPE > 1 then do;    if (NM*100) / DM <  5  & (NM*100) / DM > -5 then NM = 0; /* Eliminate very small angles */  end;  else do;    if (NM*100) / DM <  25  & (NM*100) / DM > -25 then NM = 0; /* Eliminate small angles */  end;  if      (NM*400) / DM >  100 then NM =  DM/4; /* Eliminate large angles */  else if (NM*400) / DM < -100 then NM = -DM/4; /* WAS 1/2 -> F.3 */  /* Set B1,Y1 according to slope */  do CNT = 0 to STACK_CNT-1 by 2;    P = BUFF(CNT);    X = BUFF(CNT+1);    if FIND_BASE(P,false) ~= null then do;      R = FIND_EXT(P,~DIRFLAG); /* Find farthest note from beam */      L = (core(R+D3) & LBYTE);      Y = (core(R+D2) & LBYTE) + L*DIR;      B = Y - (NM*X)/DM;      if CNT = 0 \ B*DIR > B1*DIR then do; B1 = B; Y1 = Y; end;    end;  end;  /* We are going to keep track of the beam degree for this beam     (not counting stub beams) so that we can move any rests the     correct distance away */  /* Set beam lengths and rest positions */  D = 0;  if NM = 0 & B1 mod 6 = 3 then B1 = B1 - DIR; /* Prevents beam swelling */  do CNT = 0 to STACK_CNT-2 by 2;    P  = BUFF(CNT); /* P = core(P+GRP) if TUPLET ???? */    X  = BUFF(CNT+1);    CY = (NM*X)/DM + B1;    if FIND_BASE(P,false) ~= null then do;      R = FIND_EXT(P,~DIRFLAG); /* Find farthest note from beam */      Y = (core(R+D2) & LBYTE) + (core(R+D3) & LBYTE)*DIR;      D = D + shr(core(P+D3),12) - (shr(core(P+D3),8) & MASK4); /* Maintain current degree */      core(R+D3) = core(R+D3) + (CY - Y)*DIR;      core(R+D6) = core(R+D6) \ B_STEM; /* This is for stem length feature */    end;    else if (core(P+D6) & B_REST) ~= 0 then do; /* Move rests away from beam */      Y = (core(P+D2) & LBYTE); A = -3;      if D > 1 then A = 3;/* OLD WAY -- WOULD PLACE RESTS IN WRONG RELATIONSHIP TO STAFF LINES      if DIR > 0 & CY - (12+A) < Y      then core(P+D2) = (core(P+D2) & UBYTE) \ (CY/3)*3 - (12+A);      if DIR < 0 & CY + (24+A) > Y      then core(P+D2) = (core(P+D2) & UBYTE) \ (CY/3)*3 + (24+A);*/      if DIR > 0 & CY - (12+A) < Y      then core(P+D2) = (core(P+D2) & UBYTE) \ (CY/6)*6 - (12+A);      if DIR < 0 & CY + (24+A) > Y      then core(P+D2) = (core(P+D2) & UBYTE) \ (CY/6)*6 + (24+A);    end;  end;end SET_BEAM;BEAM_MEASURE:procedure (PHEAD,NHEAD);  dcl PHEAD     pointer,      NHEAD     pointer,      (X,Y)     fixed,      (AX,I)    fixed,      DEGREE    fixed,      (P,Q)     pointer,      F         boolean,      OPEN_FLAG boolean,      FLAG      boolean;  PP = PHEAD; NP = NHEAD; DEGREE = 0;  FLAG = true; OPEN_FLAG = false;  do while (FLAG);    F = true;    do while F & (core(NP+D6) & B_TUP) ~= 0;      P = core(NP+D1+VOICE);      if P ~= null then do;        do I = 1 to (core(NP+D3+VOICE) & LBYTE);          PP = core(PP+GRP);        end;        NP = P;      end;      else F = false;    end;    P = FIND_BASE(NP,false);    if P ~= null then do; /* A half note or greater */      I = (core(P+D6) & B_DIR) ~= 0; /* Stem Direction */      Q = FIND_EXT(NP,I); /* Find nearest note to beam */      Y = (core(Q+D2) & LBYTE) + (core(Q+D3) & LBYTE) * CONV(I); /* Find nearest note to beam *//*    Y = core(FIND_EXT(NP,(core(P+D6) & B_DIR) ~= 0) + D2) & LBYTE; * Find nearest note to beam */      DEGREE = DEGREE + shr(core(P+D3),12) - (shr(core(P+D3),8) & MASK4);      if ~OPEN_FLAG & DEGREE > 0 then do; /* Open a beam */        X         = shr(core(PP+D4),8);        YBAR      = 0;        XBAR      = 0;        AVG_CNT   = 0;        STACK_CNT = 0;        OPEN_FLAG = true;      end;      if OPEN_FLAG then do; /* Keep sums while beam is open */        I = shr(core(P+D5),8) & MASK2; /* I wonder if this really works. */        if I = 3 then AX = X - 4;                 else AX = X + I * 4;        XBAR              = XBAR + AX;        YBAR              = YBAR + Y;        AVG_CNT           = AVG_CNT + 1;        BUFF(STACK_CNT)   = NP;        BUFF(STACK_CNT+1) = AX;        STACK_CNT         = STACK_CNT + 2;      end;      if OPEN_FLAG & DEGREE = 0 then do; /* Close a beam */        XBAR = XBAR / AVG_CNT;        YBAR = YBAR / AVG_CNT;        call SET_BEAM;        OPEN_FLAG = false;      end;    end; /* End of process note block */    else if OPEN_FLAG then do;      P = NP;      do while P ~= null;        if (core(P+D6) & B_VOICE) = VOICE & (core(P+D6) & B_REST) ~= 0        then do;          BUFF(STACK_CNT)   = P;          BUFF(STACK_CNT+1) = X;          STACK_CNT         = STACK_CNT + 2;          P = null;        end;        else P = core(P+GRP);      end;    end;    do I = 1 to (core(NP+D5) & LBYTE);      X = X + (core(PP+D4) & LBYTE);      if (core(PP+D6) & B_BAR) ~= 0 then FLAG = false;      else do;        PP = core(PP);        if PP = null then FLAG = false;                     else X = X + shr(core(PP+D4),8);      end;    end;    NP = core(NP);  end;end BEAM_MEASURE;  dcl (P,Q)         pointer,      MORE_MEASURES boolean,      FLAG          boolean;  MORE_MEASURES = true;  P             = POS_HEAD;  Q             = HEAD(PART);  if Q = null then return;  do while MORE_MEASURES;    call BEAM_MEASURE (P,Q);    FLAG = true;    do while FLAG;      do I = 1 to (core(Q+D5) & LBYTE);        if (core(P+D6) & B_BAR) ~= 0 then FLAG          = false;        if (core(P+D6) & B_EOL) ~= 0 then MORE_MEASURES = false;        P = core(P);      end;      LAST(PART) = Q;      Q          = core(Q);    end;  end;end SET_BEAMS;