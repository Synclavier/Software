/* $title Main Driving Routines */module MAINRTNS;/* Insert all necessary Operating System literals explicitly */insert ':-xpl:asciidef';insert ':-xpl:termutil';insert ':-xpl:plotlib';insert ':-xpl:catswap';insert ':-xpl:scanargs'; /* command line argument scanner */insert ':-xpl:strings';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:picsdcls';insert ':mplt:harddcls';begin;/* Module globals */dcl FREE_NOTE     procedure (fixed,fixed) external,    FREE_POSN     procedure (fixed,fixed) external;dcl MENU_SYSTEM   procedure returns (fixed) external,    GET_SYSTEM    procedure (fixed) external,    EDIT_SCAN_2   procedure (pointer,fixed) external,    PLOTTER       procedure external,    EDITOR        procedure (fixed) external;dcl DONE          boolean external;dcl MAIN_MODE         fixed public,    SYSTEM_LENGTH     fixed;insert ':mplt:mainfncs';/* $subtitle Main List Building Loops */BUILD_INITIALIZE:procedure (EX_PART) returns (boolean) swap;  dcl EX_PART   fixed,      LAST_PART fixed,      (I,L,T)   fixed,      ST(1)     fixed;  dcl TIME          fixed array external,      MEAS_START    fixed array external,      END_RACK      fixed array external,      MEASURE_VALUE fixed external,      HOLD_DBAR     boolean external,      HOLD_OREP     boolean external,      HOLD_TIME     boolean external;  CORE_BASE = CORE_ORIGIN;  call LOAD_PRESETS (true);  call LOAD_LIST_INDICES;  PIXEL_WIDTH  = shr(PAGE_WIDTH, 8) * 75 + ((PAGE_WIDTH  & LBYTE) * 75) / 200;  PIXEL_LENGTH = shr(PAGE_LENGTH,8) * 75 + ((PAGE_LENGTH & LBYTE) * 75) / 200;  PIXEL_WIDTH  = PIXEL_WIDTH  * (SCALE_FACTOR & LBYTE) / shr(SCALE_FACTOR,8);  PIXEL_LENGTH = PIXEL_LENGTH * (SCALE_FACTOR & LBYTE) / shr(SCALE_FACTOR,8);  if MAIN_MODE = SYSEDIT# then do; /* Edit mode */    EDIT_MAIN_BASE = CORE_BASE;    CORE_BASE      = EDIT_MAIN_BASE + 32;  end;  else if MAIN_MODE >= PRINT# then do; /* A print mode */    HOLD_MAIN_BASE = CORE_BASE;    HOLD_PART_BASE = HOLD_MAIN_BASE + 32;    CORE_BASE      = HOLD_PART_BASE + 16 * (PARTS+1);  end;  PLOT_MAIN_BASE = CORE_BASE;  PLOT_PART_BASE = PLOT_MAIN_BASE + 32;  EDIT_STAK_BASE = PLOT_PART_BASE + 16 * (PARTS+1); /* Used to be MAX_PARTS */  CORE_BASE      = EDIT_STAK_BASE + 8 * 6; /* 8 levels of edit stack gives 3 levels of tuplet nesting */  FREE_HEAD = null; FREE_TAIL = addr(FREE_HEAD);  POS_HEAD  = null; POS_TAIL  = addr(POS_HEAD);  POS_LINE  = null; POS_LAST  = null;  HEAP_HEAD = null;  /* Set up overall items */  PAGE_CNT       = INIT_PAGE; if PAGE_CNT       = 0 then PAGE_CNT       = 1;  MEASURE_NUMBER = INIT_MEAS; if MEASURE_NUMBER = 0 then MEASURE_NUMBER = 1;  HOLD_TIME      = false;     if MEASURE_NUMBER = 1 then HOLD_TIME      = true;  HOLD_DBAR      = false;  HOLD_OREP      = false;  MEDIT_POINT    = null;  MEASURE_VALUE  = 0;  SYSTEM_LENGTH  = 0;  if EX_PART = -1 then do;    PART = 0; LAST_PART = PARTS;  end;  else do;    PART = EX_PART; LAST_PART = EX_PART;  end;  STAVES = -1;  do while PART <= LAST_PART; /* Set up part specific items */    call LOAD_PART_VECTOR (PART_BASE,PART);    if PART = EX_PART then do; /* When extracting print grand staves together */      if (PBITS & (P_OBRC \ P_CBRC)) = P_OBRC then LAST_PART = LAST_PART + 1;      if (PBITS & (P_OBRC \ P_CBRC)) = P_CBRC then return (false);    end;    HEAD(PART)  = null;    TAIL(PART)  = addr(HEAD(PART));    if (PBITS & P_PLOT) ~= 0 then do;      STAVES          = STAVES + 1;      DISPLAY(STAVES) = PART;      SYSTEM_LENGTH   = SYSTEM_LENGTH + STAFF_SPACE(PART);      #TRK    = 0;      #STATUS = UNINIT#;      call DUMP_SEQ_RECORD (PART,0);      if ~TWO_VOICE \ ONE_TRACK then #STATUS = OUT#;      call DUMP_SEQ_RECORD (PART,1);      if RESOLUTION(0) > EDIT_RESOLUTION then RESOLUTION(0) = EDIT_RESOLUTION;      if RESOLUTION(1) > EDIT_RESOLUTION then RESOLUTION(1) = EDIT_RESOLUTION;      HEAD_TYPE(0) = HD_STANDARD#;      HEAD_TYPE(1) = HD_STANDARD#;      KEY          = SET_KEY(KEY,false); /* Convert keytable index into usable key */      SPLIT        = MIDDLE_C;      PLOTBITS     = 0;      if CLEF = TABLATURE# then MEASNO_POS = L1 + 5*9 + 18;                           else MEASNO_POS = L6+12;      MEASNO_FORMAT = 0;      EDIT_INDEX   = 0;      EDIT_POINT   = null;      EDIT_END     = null;      if LIST_INDEX(PART) > 0 then do;        write(SECT$) = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(PART));        write(WORD$) = 1;        EDIT_END     = 1 + read(DATA$);        EDIT_POINT   = 2;      end;      call LOAD_EDIT_STACK;      call EDIT_SCAN_2 (addr(REC(0)),0);      call DUMP_EDIT_STACK;      call DUMP_PART_VECTOR (PART_BASE,PART);      call DUMP_PART_VECTOR (PLOT_PART_BASE,PART);    end;    PART = PART + 1;  end;  if STAVES = -1 then     if EX_PART = -1 then call ERROR (ERR_NOPARTS);                    else return (false);  I = (STAVES+1) / 16;  do L = 0 to I-1;    END_RACK(L) = -1;  end;  END_RACK(I) = shr(-1,((I+1)*16)-(STAVES+1));  do L = I+1 to 3;    END_RACK(L) = 0;  end;  MEDIT_INDEX = 0;  if LIST_INDEX(MASTER_PART) > 0 then do;    write(SECT$) = FIND_LIST_SECT (EDIT_BASE,LIST_INDEX(MASTER_PART));    write(WORD$) = 1;    MEDIT_END    = 1 + read(DATA$);    MEDIT_POINT  = 2;  end;  EDIT_POSITION = 0;  EDIT_POINT    = null;  call LOAD_EDIT_STACK;  call EDIT_SCAN_2 (addr(REC(0)),0);  call DUMP_EDIT_STACK;  call DUMP_MAIN_VECTOR (MAIN_BASE);  call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);  /* Set timing values */  TEMPO = CLICK_RATE;  /* Set lefthand edge of time window */  if CLICK_TRACK ~= 0 then do; /* We are using a surrogate click track */    call INIT_SEQ_GLOBALS (CLICK_TRACK);    if #ANYF then #STATUS = ACTIVE#;             else #STATUS = OUT#;    I = START_CLICK;    do while #STATUS ~= OUT# & I > 0;      TIME(1) = #NMSB;      TIME(0) = #NLSB;      do while TIME(1) = #NMSB & TIME(0) = #NLSB & #ANYF;        call ADVANCE.TO.NEXT.EVENT;      end;      if #ANYF then TEMPO   = #NLSB - #LLSB;               else #STATUS = OUT#;      I = I - 1;    end;    call BACKUP.TO.PRIOR.EVENT;    call DUMP_SEQ_RECORD (CLICK_REC_POS#,0);/*  TIME(1) = #NMSB;    TIME(0) = #NLSB; */    call ADD32 (TIME,TEMPO*I);  end;  else do;    write(5) = START_CLICK - 1;    write(4) = ZERO.TIME;    write(6) = TEMPO;    TIME(1)  = read(4);    TIME(0)  = read(5);  end;  MEAS_START(1) = TIME(1);  MEAS_START(0) = TIME(0);  return (true);end BUILD_INITIALIZE;DISPLAY_MUSIC:procedure swap;  dcl SYSTEMS       fixed,      SYSTEMS_PAGE  fixed,      TOP_POS       fixed,      STAFF_POS     fixed,      BASE_MEAS     fixed,      I             fixed;  DISPLAYER:procedure;    dcl C fixed;    transparent_mode; pos(23,0);    do forever;      C = rchar;      if      C = kp.0 then return;		else if C = 0    then return;      else if C = kp.enter \ C = asc.refresh then do; /* Return to main menu or replot */        if C = asc.refresh then REPLOT_MEASURE = BASE_MEAS; /* Replot from same measure */                           else REPLOT_MEASURE = 0;        call RE_START; /* Exit */      end;      else if C = ctrl.p then do;        reverse(1); pstring('     Play     '); reverse(0); pstring('  ');        call PLAY_SEQUENCE (true); /* Overlay to runtime - keep screen */      end;    end;  end DISPLAYER;  call BUILD_INITIALIZE (-1);  if MACII then do;    if PIXEL_LENGTH > DISPLAY_SCREEN_LENGTH#    then TOP_POS = SCREEN_BOT# + PIXEL_LENGTH;    else TOP_POS = SCREEN_BOT# + DISPLAY_SCREEN_LENGTH#;    if TOP_POS > SCREEN_TOP# then TOP_POS = SCREEN_TOP#;    I = PIXEL_LENGTH - 15; /* Room for page number line */    if PAGE_CNT = INIT_PAGE \ (INIT_PAGE = 0 & PAGE_CNT = 1) then do; /* This is the title page */      if core(TEXT_BASE)      ~= 0 then I = I - 30; /* Room for title line */      if core(TEXT_BASE+  41) ~= 0 \         core(TEXT_BASE+2*41) ~= 0 then I = I - 15; /* Room for subtitle line */      if core(TEXT_BASE+3*41) ~= 0 then I = I - 15; /* Room for copyright line */    end;    I            = I - shr(STAFF_SPACE(DISPLAY(0)),1); /* Leave xtra room (inter-system space / 2) */    SYSTEMS_PAGE = I / SYSTEM_LENGTH; /* Systems/page = floor (remaining page length / system length) */  end;  else do;    SYSTEMS_PAGE = (DISPLAY_SCREEN_LENGTH# - STAFF_SPACE(DISPLAY(0))) / SYSTEM_LENGTH;    TOP_POS      = SCREEN_TOP#;  end;  if SYSTEMS_PAGE <= 0 \ SYSTEMS_PAGE > 64 then call ERROR (ERR_STAVES);  DONE = false;  do while ~DONE \ POS_HEAD ~= null;    clear_all;    call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);    BASE_MEAS   = MEASURE_NUMBER;    SYSTEMS     = 0;    END_OF_PAGE = false;    STAFF_POS   = TOP_POS;    do while SYSTEMS < SYSTEMS_PAGE & (~DONE \ POS_HEAD ~= null);      if PIXEL_WIDTH <= SCREEN_WIDTH#      then call GET_SYSTEM (PIXEL_WIDTH - 1);      else call GET_SYSTEM (SCREEN_WIDTH#);      do STAFF = 0 to STAVES; /* Plot one system */        PART      = DISPLAY(STAFF);        STAFF_POS = STAFF_POS - STAFF_SPACE(PART);        call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,SCREEN_BOT#);        call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);        call LOAD_PART_VECTOR (PLOT_PART_BASE,PART);        POSN_PTR = POS_HEAD;        NOTE_PTR = HEAD(PART);        call PLOTTER;        call DUMP_PART_VECTOR (PLOT_PART_BASE,PART);      end;      call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);      call CLEAN_LISTS (false,true);      SYSTEMS = SYSTEMS + 1;      if (DONE & POS_HEAD = null) \ END_OF_PAGE then SYSTEMS = SYSTEMS_PAGE;    end;    call DISPLAYER;    PAGE_CNT = PAGE_CNT + 1;  end;end DISPLAY_MUSIC;EDIT_MUSIC:procedure swap;  dcl STAFF_POS     fixed,      SYS_LEN       fixed,      TOP_POS       fixed;  call BUILD_INITIALIZE (-1);  SYS_LEN = STAFF_SPACE(DISPLAY(0)) + SYSTEM_LENGTH;  if SYS_LEN > EDIT_SCREEN_LENGTH#  then TOP_POS = EDIT_BOT# + SYS_LEN;  else TOP_POS = EDIT_BOT# + EDIT_SCREEN_LENGTH#/2 + SYS_LEN/2;  if TOP_POS > SCREEN_TOP# then call ERROR (ERR_STAVES);  DONE = false;  do while ~DONE \ POS_HEAD ~= null;    clear_all;    STAFF_POS = TOP_POS;    if PIXEL_WIDTH <= SCREEN_WIDTH#    then call GET_SYSTEM (PIXEL_WIDTH - 1);    else call GET_SYSTEM (SCREEN_WIDTH#);    call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);    call DUMP_MAIN_VECTOR (EDIT_MAIN_BASE);    do STAFF = 0 to STAVES; /* Plot one system */      PART      = DISPLAY(STAFF);      STAFF_POS = STAFF_POS - STAFF_SPACE(PART);      call OPEN_WINDOW (SCREEN_TOP#,STAFF_POS,EDIT_BOT#);      call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);      call LOAD_PART_VECTOR (PLOT_PART_BASE,PART);      POSN_PTR = POS_HEAD;      NOTE_PTR = HEAD(PART);      call PLOTTER;      call DUMP_PART_VECTOR (PLOT_PART_BASE,PART);    end;    call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);    call LOAD_MAIN_VECTOR (EDIT_MAIN_BASE);    call EDITOR (TOP_POS);    call CLEAN_LISTS (false,true);  end;end EDIT_MUSIC;/* $subtitle Engraving Driver */DISPLAY_BANNER:procedure;  dcl STR1 data ('lqqqqqqqqqqqk'),      STR2 data ('x ENGRAVING x'),      STR3 data ('x           x'),      STR4 data ('mqqqqqqqqqqqj');    pstring(ALTERNATE_CHARS);    pos(5, 13); pstring(DOUBLE_HEIGHT_T); pstring(STR1);    pos(6, 13); pstring(DOUBLE_HEIGHT_B); pstring(STR1);    pos(7, 13); pstring(DOUBLE_HEIGHT_T); pstring(STR2);    pos(8, 13); pstring(DOUBLE_HEIGHT_B); pstring(STR2);    pos(9, 13); pstring(DOUBLE_HEIGHT_T); pstring(STR3);    pos(10,13); pstring(DOUBLE_HEIGHT_B); pstring(STR3);    pos(11,13); pstring(DOUBLE_HEIGHT_T); pstring(STR4);    pos(12,13); pstring(DOUBLE_HEIGHT_B); pstring(STR4);    pstring(NORMAL_CHARS); pos(16,0);end DISPLAY_BANNER;DISPLAY_PRINT_PAGE:procedure;    pos(9, 15); pstring(DOUBLE_HEIGHT_T); pstring('Page: '); pnum(PAGE_CNT,0);    pos(10,15); pstring(DOUBLE_HEIGHT_B); pstring('Page: '); pnum(PAGE_CNT,0);    pos(16,0);end DISPLAY_PRINT_PAGE;CALCULATE_SYSTEMS_PAGE:procedure returns (fixed) swap;  dcl (I,S) fixed;  I = PIXEL_LENGTH - 15; /* Room for page number line */  if PAGE_CNT = INIT_PAGE \ (INIT_PAGE = 0 & PAGE_CNT = 1) then do; /* This is the title page */    if core(TEXT_BASE)      ~= 0 then I = I - 30; /* Room for title line */    if core(TEXT_BASE+  41) ~= 0 \       core(TEXT_BASE+2*41) ~= 0 then I = I - 15; /* Room for subtitle line */    if core(TEXT_BASE+3*41) ~= 0 then I = I - 15; /* Room for copyright line */  end;  I = I - shr(STAFF_SPACE(DISPLAY(0)),1); /* Leave xtra room (inter-system space / 2) */  S = I / SYSTEM_LENGTH; /* Systems/page = floor (remaining page length / system length) */  if S <= 0 \ S > 64 then call ERROR (ERR_STAVES);  return S;end CALCULATE_SYSTEMS_PAGE;PREBUILD_SYSTEMS:procedure (SYSTEMS) returns (fixed) swap;  dcl SYSTEMS fixed;  SYSTEM = 0;  do while SYSTEM < SYSTEMS & (~DONE \ POS_HEAD ~= null) & ~END_OF_PAGE;    call GET_SYSTEM (PIXEL_WIDTH - 1);    call CLEAN_LISTS (SYSTEM = 0,false);    if SYSTEM = 0 then do; /* Store snapshot for start of page */      call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);      call DUMP_MAIN_VECTOR (HOLD_MAIN_BASE);      call COPY_PART_VECTOR (PLOT_PART_BASE,HOLD_PART_BASE);    end;    /* Advance snapshot for continued scanning ("PLOT" vector is used by JUSTIFY_LINE) */    call LOAD_MAIN_VECTOR (MAIN_BASE);    call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);    call COPY_PART_VECTOR (PART_BASE,PLOT_PART_BASE);    SYSTEM = SYSTEM + 1;  end;  return SYSTEM;end PREBUILD_SYSTEMS;PLOT_SYSTEMS:procedure (SYSTEMS) swap;  dcl SYSTEMS fixed;  dcl C       fixed;  do SYSTEM = 0 to SYSTEMS - 1;    if OVERLAP = 0 then call GET_SYSTEM (PIXEL_WIDTH - 1);    do STAFF = 0 to STAVES; /* Plot one system */      PART = DISPLAY(STAFF);      hpnum(0); hpnum(-STAFF_SPACE(PART)*4); hstringr(' T');      call LOAD_MAIN_VECTOR (PLOT_MAIN_BASE);      call LOAD_PART_VECTOR (PLOT_PART_BASE,PART);      if OVERLAP = 0 then do;        POSN_PTR = POS_HEAD;        NOTE_PTR = HEAD(PART);      end;      else if SYSTEM = 0 then do;        POSN_PTR = HOLD_POS_HEAD;        NOTE_PTR = HOLD_HEAD(PART);      end;      call PLOTTER;      call DUMP_PART_VECTOR (PLOT_PART_BASE,PART);      do while ~term_idle;        C = rchar;        if C = sp then do;          call PS_DISABLE;          call RE_START;        end;        else if C = asc.refresh then do;          clear_all;          call DISPLAY_BANNER;        end;      end;    end;    call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);    if OVERLAP = 0 then do;      call CLEAN_LISTS (false,true);      if (DONE & POS_HEAD = null) \ END_OF_PAGE then SYSTEM = SYSTEMS;    end;  end;end PLOT_SYSTEMS;ENGRAVE_MUSIC:procedure swap;  dcl SYSTEMS_PAGE    fixed,      H_SHIFT         fixed,      V_SHIFT         fixed,      S               fixed,      HORIZONTAL_PAGE fixed,      VERTICAL_PAGE   fixed,      HORIZONTAL      boolean,      VERTICAL        boolean,      NEW_PAGE        boolean,      IN_RANGE        boolean;  call LOAD_OVERLAY_FILE;  ENGRAVING        = true;  PS_ERROR_PRESENT = false;  CATCH_PS_ERRORS  = false;  call AQUIRE_PRINTER;  call DISPLAY_BANNER;  call DUMP_PROLOGUE;  flush_term;  CATCH_PS_ERRORS = true;  call START_JOB;  DONE = false;  do while (~DONE | POS_HEAD ~= null) &           (TO_PAGE = 0 | PAGE_CNT <= TO_PAGE);    call DISPLAY_PRINT_PAGE;    SYSTEMS_PAGE = CALCULATE_SYSTEMS_PAGE; /* This supports pre-G seqs */    NEW_PAGE     = true;         /* TRUE for first sheet of tiled page */    END_OF_PAGE  = false;    IN_RANGE     = (FROM_PAGE <= PAGE_CNT);    VERTICAL_PAGE = 0;    VERTICAL      = true;    do while VERTICAL;      HORIZONTAL_PAGE = 0;      HORIZONTAL      = true;      do while HORIZONTAL;        CURRENT_FONT = F_RESET#;        START_PAGE;        do case SETUP_PAGE(HORIZONTAL_PAGE,VERTICAL_PAGE);          ;                   /* Continue tile scan */          HORIZONTAL = false; /* End of horizontal tile scan */          VERTICAL = false;   /* End of vertical tile scan */          do; HORIZONTAL = false; VERTICAL = false; end; /* End of page */        end;        S = SCAN_OVERLAY_FILE (PAGE_CNT);        if NEW_PAGE then do;          if S = 0 then SYSTEMS_PAGE = PIXEL_LENGTH / SYSTEM_LENGTH; /* Systems/page = floor (page length / system length) */          else if S > 0 then SYSTEMS_PAGE = S;          if OVERLAP ~= 0 then SYSTEMS_PAGE = PREBUILD_SYSTEMS(SYSTEMS_PAGE);        end;        /* Recall snapshot */        if OVERLAP ~= 0 then do;          call LOAD_MAIN_VECTOR (HOLD_MAIN_BASE);          call DUMP_MAIN_VECTOR (PLOT_MAIN_BASE);          call COPY_PART_VECTOR (HOLD_PART_BASE,PLOT_PART_BASE);        end;        call MUSIC_PAGE;        call PLOT_SYSTEMS (SYSTEMS_PAGE);        if IN_RANGE then FINISH_PAGE;        else do;          CLEAR_PAGE;          HORIZONTAL = false;          VERTICAL   = false;        end;        NEW_PAGE = false;        HORIZONTAL_PAGE = HORIZONTAL_PAGE + 1;      end; /* HORIZONTAL */      VERTICAL_PAGE = VERTICAL_PAGE + 1;    end; /* VERTICAL */    if OVERLAP ~= 0 then call CLEAN_LISTS (true,true);    PAGE_CNT = PAGE_CNT + 1;  end;  call FINISH_ENGRAVING;  ENGRAVING = false;end ENGRAVE_MUSIC;/* $subtitle Main Control Routine */MAIN_DRIVER:procedure (RESTART) public;  dcl RESTART boolean,      COMMAND fixed static,      I       fixed static;  if ~RESTART then do;    call GET_STARTUP_ARG;    call INITIALIZE_ENVIRONMENT; /* This order of calls is ESSENTIAL! */    call INITIALIZE_GLOBALS;    call LOOKUP_SEQUENCE_DATA;    ERROR_CHECK = false;  /* DEBUG */    /* This has to change for other processors and any compiler changes */    if      MODEL_B then PDS_BASE = read("315"); /* (B) Get stack pointer at this point so stack can be reset */    else if MODEL_C then PDS_BASE = read("312"); /* (C) Get stack pointer at this point so stack can be reset */  end;  do forever;    /* This has to change for other processors and any compiler changes */    if      MODEL_B then write("315") = PDS_BASE; /* (B) Reinit stack */    else if MODEL_C then write("312") = PDS_BASE; /* (C) Reinit stack */    call swapinit (swapinit(0)); /* Reinitialize swapping mechanism */    /* Reset these here because they may be left on if we abort */    RUNNING   = false;    ENGRAVING = false;    if REPLOT_MEASURE = 0 then COMMAND = MENU_SYSTEM;    else call INITIALIZE_TERMINAL;    do case COMMAND;      do;        RUNNING = true;        do case MAIN_MODE;          call DISPLAY_MUSIC;          call EDIT_MUSIC;          do; /* PRINT */            call BUILD_INITIALIZE (-1);            call ENGRAVE_MUSIC;          end;          do I = 0 to PARTS; /* EXTRACT */            if BUILD_INITIALIZE (I) then            call ENGRAVE_MUSIC;          end;          do; /* TEST (prints PostScript without printer response) */            call BUILD_INITIALIZE (-1);            call ENGRAVE_MUSIC;          end;        end;      end;      call RECALL_SEQUENCE;      call STORE_SEQUENCE;      call REVERSE_SEQUENCE (1);      call PLAY_SEQUENCE (false);      call EXIT_TO_MONITOR;    end;  end;end MAIN_DRIVER;end;end MAINRTNS;