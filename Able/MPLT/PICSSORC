/* $title Picture Routines */module PICSRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';insert ':mplt:harddcls';insert ':mplt:picsdcls';begin;/* Externals */dcl KEY_NUMBER  procedure (fixed array,boolean) external;dcl MAIN_MODE   fixed external;dcl GET_PITCH procedure (fixed,fixed array);/* Variables */dcl SYM_CODE fixed public,    SYM_INTC fixed public,    SYM_FONT fixed public,    SYM_ADFT fixed public,    SYM_ILEN fixed public,    SYM_XZER fixed public,    SYM_YZER fixed public,    SYM_XADV fixed public,    SYM_WDTH fixed public,    SYM_FLIP fixed public;dcl INT_SYM_LOCK boolean; /* Prevents unchecked recursion in INTERNAL_SYMBOL *//* Internal Symbol tables */dcl ISYMBOL_CNT lit '14'; /* Count of internal symbols *//* Internal Symbol library symbol codes */dcl ISYMBOL_LIB fixed data ("202","206","211","212","213","214","333","376",                            "377","353","354","355","356","367");/* Internal symbol cursor advances */dcl ISYMBOL_ADV fixed data (    0,    0,    0,    0,    0,    0,    1,   2,                               -8,    0,    0,    0,    0,    0);insert ':mplt:picsfncs'; /* Picture functions */SCAN_SYMBOL:procedure (X0,Y0,WIDTH,LEN,DIR,TSIZE) swap5; /* Scans and plots the bit map of a symbol. It checks if symbol is invertable. */  dcl (X0,Y0) fixed, /* Symbol location */      WIDTH   fixed, /* Symbol width */      LEN     fixed, /* Symbol length */      TSIZE   fixed, /* Symbol magnification (1x or 2x) */      (X1,X,Y,D) fixed,      (I,J,K) fixed,      DIR     boolean, /* Direction */      FLAG    boolean;  Y = Y0;  do I = 1 to LEN / WIDTH;  /* Do for all rows of bits representing the symbol*/    FLAG = false;    X    = X0;    do J = 1 to WIDTH;      D = read(DATI$);      do K = 1 to 16;        D = rot(D,1);        if ~FLAG & D then do;          X1 = X;          FLAG = true;        end;        else if FLAG & ~D then do;          call LINE (X1,Y,X-1,Y,0,TSIZE);          FLAG = false;        end;        X = X + TSIZE;      end;    end;    if FLAG then call LINE (X1,Y,X-1,Y,0,TSIZE);    Y = Y + DIR*TSIZE;                   /* Advance the Y position */  end;end SCAN_SYMBOL;PS_SCAN_SYMBOL:procedure (X0,Y0,WIDTH,LEN,DIR,TSIZE) swap5; /* Plots a bit map symbol in postscript */  dcl (X0,Y0) fixed, /* Symbol lower left corner location */      WIDTH   fixed, /* Symbol width in words */      LEN     fixed, /* Bit map length in words */      HEIGHT  fixed, /* Symbol height in bits */      DIR     boolean, /* Direction 0 = UP, 1 = DOWN */      TSIZE   fixed,   /* Enlargement factor (1 or 2) */      (I,J)   fixed;  HEIGHT = LEN / WIDTH;  hstringr('GS');/*hstringr('/str 256 string def');*/                 /* OPTIMIZE? */  hpnum(X0*4); hpnum(Y0*4); hstringr(' T');  if TSIZE > 1 then hstringr('2 2 SC'); /* This is not general, but so what? */  hpnum(WIDTH*16); hpnum(HEIGHT);  if DIR then hstringr(' true [.25 0 0 -.25 0 0]');         else hstringr(' true [.25 0 0  .25 0 0]');  hstring('{<');  do I = 1 to LEN;    hhnum(read(DATI$));  end;  hstringr('>} imagemask');/*hstringr('{currentfile str readhexstring pop} imagemask');*/  hstringr('GR');end PS_SCAN_SYMBOL;GO_SYMBOL:procedure (X,Y) swap5;  dcl (X,Y) fixed;  imove_to (X,Y);  wchar(esc); wchar(lower.r); wchar(us);  if (SYM_CODE & "100") ~= 0 then wchar("200"+32+(SYM_CODE&"77"));                             else wchar(      32+(SYM_CODE&"77"));  wchar(esc); wchar(lower.t);end GO_SYMBOL;MAC_SYMBOL:procedure (X,Y) swap5;  dcl (X,Y) fixed;  imove_to (X,Y);  if SYM_CODE < "200" then wchar("200");  wchar(SYM_CODE);end MAC_SYMBOL;LOOKUP_SYMBOL:procedure (CODE) returns (boolean) public swap5;  dcl CODE       fixed,      (I,W0)     fixed,      (S,W)      fixed,      (W3,W4)    fixed,      SNAP(4)    fixed; /* static init (0) - Holds snapshot of last symbol looked up */  if CODE < 0 \ CODE > 255 then return (false);  if SNAP(0) = UPPER_FONT &  /* Return if symbol already looked up */     SNAP(1) = LOWER_FONT &     SNAP(2) = CODE & ~INT_SYM_LOCK /* Ensure we look again when called recursively */  then do; /* Ensure xmem is in position */    write(SECT$) = SNAP(3);    write(WORD$) = SNAP(4);    return (true);  end;  SNAP(0) = UPPER_FONT; /* Take snapshot */  SNAP(1) = LOWER_FONT;  SNAP(2) = CODE;  if INT_SYM_LOCK then SNAP(2) = 0; /* Ensure we look again after being called recursively */  SYM_CODE = CODE;  SYM_INTC = -1;  SYM_FLIP = false;  if CODE >= "200" then do;    if ~ENGRAVING & ((~MACII & UPPER_FONT < F_MUSIC#) \ UPPER_FONT = F_ALPHA#)    then SYM_FONT = F_EXTENDED#;    else SYM_FONT = UPPER_FONT;    SYM_ADFT = UPPER_FONT;  end;  else do;    SYM_FONT = LOWER_FONT;    SYM_ADFT = LOWER_FONT;  end;  if SYM_ADFT < F_MUSIC# /* A proportionaly spaced font */  then SYM_XADV = byte(loc(addr(WIDTH_TABLE(0))-1),256*SYM_ADFT+CODE);  else if SYM_ADFT = F_ALPHA# then SYM_XADV = 8; /* The VT640 alpha font */  if F_MUSIC# <= SYM_FONT & SYM_FONT < F_ALPHA# then do; /* A symbol font */    if SYM_FONT = F_MUSIC# & ~ENGRAVING & ~INT_SYM_LOCK then do; /* Check for possible internal symbol */      do I = 0 to ISYMBOL_CNT - 1;        if CODE = ISYMBOL_LIB(I) then do;          SYM_INTC = I;          SYM_XADV = ISYMBOL_ADV(I);          return (true);        end;      end;    end;    /* Look up symbol in library (done in-line for speed) */    S = 0;    do case (SYM_FONT & MASK2);      S = SLIB_BASE;      S = ULIB_BASE;      S = ALIB_BASE;    end;    if S = 0 then W0 = 0; /* No library, so plot nothing */    else do;      I            = shl(CODE,8);      W            = 0;      write(SECT$) = S;      W0           = read(DATI$);      do while W0 ~= 0 & (W0 & UBYTE) ~= I;        W            = W + (W0 & LBYTE);        write(SECT$) = S + shr(W,8);        write(WORD$) = W;        W0           = read(DATI$);      end;    end;    if W0 = 0 then do; /* Symbol not found */      SNAP(2) = 0; /* Prevent returning true if called again */      return (false);    end;    write(NOP) = read(DATI$); /* Skip the symbol name */    write(NOP) = read(DATI$);    W3         = read(DATI$);    W4         = read(DATI$);    SYM_ILEN = (W0 & LBYTE) - 5;    SYM_XZER = shr(W4,12);    SYM_YZER = shr(W4,6) & MASK6;    if SYM_ADFT = SYM_FONT \ SYM_ADFT = F_ALPHA#    then SYM_XADV = W4 & MASK6;    SYM_WDTH = 1; /* Word width assumed 1 (16 bits) */    if (W3 & S_DOUB) ~= 0 then do; /* If the double width bit is set, word width is 2 (32 bits) */      SYM_WDTH = 2;      if (W3 & S_MSBX) ~= 0 then SYM_XZER = SYM_XZER + 16; /* Get msb of X center */    end;    if (W3 & S_INVERT) ~= 0 then SYM_FLIP = true; /* Symbol is invertable */  end;  /* The Mac font combines the extended and music fonts */  if ~ENGRAVING & MACII & SYM_FONT = F_EXTENDED# & CODE < "200"  then SYM_FONT = F_MUSIC#;  SNAP(3) = read(SECT$);  SNAP(4) = read(WORD$);  return (true);end LOOKUP_SYMBOL;INTERNAL_SYMBOL:procedure (X,Y,DIR) swap5; /* Plot internal procedure symbol */  dcl (X,Y,DIR) fixed;  INT_SYM_LOCK = true;  do case SYM_INTC;    call C_CLEF      (X,Y); /* 202 -> C Clef */    call P_CLEF      (X,Y); /* 206 -> Percussion Clef */    call SHARP       (X,Y); /* 211 -> Sharp */    call NATURAL     (X,Y); /* 212 -> Natural */    call FLAT        (X,Y); /* 213 -> Flat */    call DOUBLE_FLAT (X,Y); /* 214 -> Double flat */    ;;;    call STEM_FLAG   (X,Y,true, UP#); /* 353 -> 1st flag up */    call STEM_FLAG   (X,Y,false,UP#); /* 354 -> 2nd flag up */    call STEM_FLAG   (X,Y,true, DN#); /* 355 -> 1st flag down */    call STEM_FLAG   (X,Y,false,DN#); /* 356 -> 2nd flag down */    call GRACE_FLAG  (X,Y,DIR);       /* 367 -> grace flag */  end;  INT_SYM_LOCK = false;end INTERNAL_SYMBOL;PLOT_CHARACTER:procedure (C,X,Y,DIR) public swap5;  dcl C          fixed,      (X,Y)      fixed,      DIR        boolean,      TSIZE      fixed;  if LOOKUP_SYMBOL(C) then do;  /* This is a kludge so this will plot large chars for the editor */  TSIZE = 1; if rot(DIR,1) then TSIZE = 2;  DIR = DIR & MASK1;  if ENGRAVING then do;    if SYM_ADFT ~= F_USER# then do;      call SET_FONT (SYM_ADFT);      if SYM_ADFT < F_MUSIC# \ SYM_ADFT = F_ALPHA# then X = X - 3; /* Center letters on cursor */      if DIR then do;        hstringr('GS');        hpnum(X*4); hpnum(Y*4); hstring(' T 180 R 0 0 M');      end;      else do;        hpnum(X*4); hpnum(Y*4); hstring(' M');      end;      hstring(' ('); hstrchar(C); hstringr(') H');      if DIR then hstringr('GR');    end;    else call PS_SCAN_SYMBOL (X-SYM_XZER*TSIZE,Y-SYM_YZER*TSIZE*CONV(DIR),                              SYM_WDTH,SYM_ILEN,DIR,TSIZE);  end;  else do; /* Not generating PostScript */    call SET_FONT (SYM_ADFT);    if SYM_ADFT < F_MUSIC# | SYM_ADFT = F_ALPHA# | SYM_ADFT = F_LITTLE#    then X = X - 3;    if (~MACII | DIR) & SYM_INTC >= 0  /* An internal procedure symbol */    then call INTERNAL_SYMBOL (X,Y,DIR);    else if SYM_FONT < F_MUSIC# | SYM_FONT = F_ALPHA# | SYM_FONT = F_LITTLE#    then call CHAR (X,Y,C,TSIZE); /* Print an alpha character */    else if MACII & SYM_FONT = F_MUSIC# & DIR = UP# & TSIZE = 1    then call MAC_SYMBOL (X,Y);    else if GO250 & SYM_FONT = F_MUSIC# & DIR = UP# & TSIZE = 1    then call GO_SYMBOL (X,Y);    else call SCAN_SYMBOL (X-SYM_XZER*TSIZE,Y-SYM_YZER*TSIZE*CONV(DIR),                           SYM_WDTH,SYM_ILEN,CONV(DIR),TSIZE);  end;  end;end PLOT_CHARACTER;FAST_PLOT_SYMBOL:procedure (C,X,Y,DIR) public swap5;  dcl C          fixed,      (X,Y)      fixed,      DIR        boolean;  UPPER_FONT = F_MUSIC#;  LOWER_FONT = F_EXTENDED#;  if LOOKUP_SYMBOL(C) then do;  if ENGRAVING then do;      call SET_FONT (SYM_ADFT);      if DIR then do;        hstringr('GS');        hpnum(X*4); hpnum(Y*4); hstring(' T 180 R 0 0 M');      end;      else do;        hpnum(X*4); hpnum(Y*4); hstring(' M');      end;      hstring(' ('); hstrchar(C); hstringr(') H');      if DIR then hstringr('GR');  end;  else do; /* Not generating PostScript */    if (~MACII | DIR) & SYM_INTC >= 0  /* An internal procedure symbol */    then call INTERNAL_SYMBOL (X,Y,DIR);    else if MACII & DIR = UP#    then call MAC_SYMBOL (X,Y);    else if GO250 & SYM_FONT = F_MUSIC# & DIR = UP#    then call GO_SYMBOL (X,Y);    else call SCAN_SYMBOL (X-SYM_XZER,Y-SYM_YZER*CONV(DIR),                           SYM_WDTH,SYM_ILEN,CONV(DIR),1);  end;  end;end FAST_PLOT_SYMBOL;PLOT_STRING:procedure (STR,X,Y,LEN,TSIZE) returns (fixed) public swap5;  dcl STR        fixed array,      (X,Y)      fixed,      NX         fixed, /* Position of next char after string */      LEN        fixed, /* String length in characters */      TSIZE      fixed, /* Text size (1 or 2) */      FONT       fixed,      IND        fixed,      (A,AX,C)   fixed,      REPO       boolean;  TOKEN:procedure returns (fixed);    dcl C fixed;    if IND = LEN then return (-1);    C   = byte(STR,IND);    IND = IND + 1;    return (C);  end TOKEN;  A = 0;  if ENGRAVING then do;    IND  = 0;    C    = TOKEN;    REPO = true;    do while C ~= -1;      if LOOKUP_SYMBOL(C) then do;      if SYM_FONT ~= F_USER# then do;        FONT = SYM_FONT;        call SET_FONT (SYM_FONT);        A = 0;        if REPO \ FONT = F_MUSIC# \                  FONT = F_EXTENDED# \                  FONT = F_SMALL# then do; /* Position string */          if (FONT = F_MUSIC# \              FONT = F_EXTENDED# \              FONT = F_SMALL# ) then do;            hpnum(X*4);            REPO = true;          end;          else do;            hpnum((X-3)*4); /* Center chars on cursor */            REPO = false;          end;          hpnum(Y*4); hstringr(' M');        end;        if TSIZE = 2 then hstringr('GS 2 2 SC');        hchar(lparen);        do while C ~= -1 & SYM_FONT = FONT;          hstrchar(C);          A = A + SYM_XADV;          C = TOKEN;          call LOOKUP_SYMBOL (C);        end;        hstringr(') H');        if TSIZE = 2 then hstringr('GR');        if FONT < F_MUSIC# then X = X + A*TSIZE*10/CSC#; /* A proportionally spaced font */                           else X = X + A*TSIZE;      end;      else do;        call PS_SCAN_SYMBOL (X-SYM_XZER*TSIZE,Y-SYM_YZER*TSIZE,SYM_WDTH,SYM_ILEN,UP#,TSIZE);        X    = X + SYM_XADV; /* WAS * TSIZE */        C    = TOKEN;        REPO = true;      end;      end;    end;    NX = X;  end;  else do IND = 0 to LEN - 1; /* Not generating PostScript */    if LOOKUP_SYMBOL(byte(STR,IND)) then do;      if SYM_ADFT >= F_MUSIC# then do;        X  = X + A*10/CSC#;        AX = X;         A  = 0;       end;      else AX = X + A * 10 / CSC#;      if SYM_ADFT < F_MUSIC# | SYM_ADFT = F_ALPHA# | SYM_ADFT = F_LITTLE#      then AX = AX - 3;      call SET_FONT (SYM_ADFT);      if ~MACII & SYM_INTC >= 0    /* An internal procedure symbol */      then call INTERNAL_SYMBOL (X,Y,0);      else if SYM_FONT < F_MUSIC# | SYM_FONT = F_LITTLE# /* A proportionally spaced font */      then call CHAR (AX,Y,SYM_CODE,TSIZE); /* Print an alpha character */      else if SYM_FONT < F_ALPHA# then do; /* A symbol font symbol */        if MACII & SYM_FONT = F_MUSIC# & TSIZE = 1        then call MAC_SYMBOL (AX,Y);        else if GO250 & SYM_FONT = F_MUSIC# & TSIZE = 1        then call GO_SYMBOL (AX,Y);        else call SCAN_SYMBOL (AX-SYM_XZER*TSIZE,Y-SYM_YZER*TSIZE,SYM_WDTH,SYM_ILEN,1,TSIZE);      end;      else if SYM_FONT = F_ALPHA# /* The VT640 alpha font */      then call CHAR (AX,Y,SYM_CODE,TSIZE); /* Print an alpha character */      if SYM_ADFT < F_MUSIC# then A = A + SYM_XADV*TSIZE;                             else X = X + SYM_XADV*TSIZE;      NX = X + A * 10 / CSC#;    end;  end;  return (NX);end PLOT_STRING;/*PLOT_SYMBOL:procedure (C,X,Y,DIR) public;  dcl (C,X,Y,DIR) fixed;  UPPER_FONT = F_MUSIC#;  LOWER_FONT = F_EXTENDED#;  call PLOT_CHARACTER (C,X,Y,DIR);end PLOT_SYMBOL;*/SEARCH_X:procedure (P,OFF,X) returns (fixed) public swap4; /* Searches for the end of a long symbol and returns X2 */  dcl P     pointer, /* memory pointer*/      OFF   fixed,   /* # of edit points between start and end */      (X,I) fixed;   /* X coordinate */  do I = 1 to OFF;    X = X + (core(P+D4) & LBYTE);    P = core(P);    if P = null then I = OFF;    else X = X + shr(core(P+D4),8);  end;  return (X);end SEARCH_X;GET_PITCH:procedure (KEY,NAME) swap4;  dcl KEY  fixed,      NAME fixed array,      SHRP_TAB fixed data ('C C#D D#E F F#G G#A A#B '),      FLAT_TAB fixed data ('C D$D E$E F G$G A$A B$B ');  KEY = KEY mod 12;  if (PBITS & P_FLAT) ~= 0 then NAME(1) = FLAT_TAB(KEY+1);                           else NAME(1) = SHRP_TAB(KEY+1);  if byte(NAME,1) = sp then NAME(0) = 1;                       else NAME(0) = 2; /* Remove trailing space */end GET_PITCH;PLOT_RECORD:procedure (BUFF,PP,X) public swap4; /* Plots the record given the current position pointer and X position */  /* This routine preserves xmem registers */  dcl BUFF    fixed array, /* Holds the edit record */      PP      pointer,     /* Position pointer */      X       fixed,       /* X position */      TSZ     fixed,       /* Text size 1 or 2 */      BTX     boolean,     /* Boxed text   */      ALF     boolean,     /* Alpha record */      EXT     boolean,     /* Auxilliary font */      LIB     boolean,     /* Library */      DIR     boolean,     /* Symbol direction */      MID     boolean,     /* If slur midpoint is designated */      FNT     fixed,       /* Lower font */      NAME(6) fixed,       /* Holds chord name */      TYP     fixed,       /* Type of edit record */      VAL     fixed,       /* length of edit record */      (I,J)   fixed,      (S,W)   fixed,      (SX,SY) fixed,       /* Starting point */      (MX,MY) fixed,       /* Mid point */      (EX,EY) fixed,       /* End point */      MAT(7)  fixed;       /* New slur point matrix */  if rot(BUFF(0),1) then return; /* Do nothing if this is a spacing record */  S = read(SECT$);   /* Save xmem registers */  W = read(WORD$);  TYP = shr(BUFF(0),8);               /* Type of edit record */  VAL = BUFF(0) & LBYTE;              /* Length of edit record or DATA8 */  BTX = (BUFF(0) & R_BTX) ~= 0;       /* Boxed text */  ALF = (BUFF(0) & R_ALF) ~= 0;       /* Alpha record */  TSZ = 1;  if (BUFF(0) & R_DTX) ~= 0 then TSZ = 2; /* Double size text */  EXT = (BUFF(1) & R_EXT) ~= 0;       /* Extended mode */  LIB = (BUFF(1) & R_LIB) ~= 0;       /* Library */  DIR = (BUFF(1) & R_DIR) ~= 0;       /* Symbol direction */  MID = (BUFF(1) & R_MID) ~= 0;       /* Set if slur record with midpoint */  if ALF then FNT = F_ALPHA#;         else FNT = (rot(BUFF(1),4) & MASK2);     /* Font */  SX  = X + EXPAND(shr(BUFF(1),6),6) * 4; /* Symbol X,Y location */  SY  = (BUFF(1) & MASK6) * 3;  if (TYP & "176") = "100" then do; /* Single character record */    call SETUP_FONTS (FNT,EXT,LIB,CHAR#);    if ~ALF then DIR = UP#;    call PLOT_CHARACTER (VAL,SX,SY,DIR);  end;  else if TYP = "102" \ TYP = "104" then do; /* Note */    DIR = CONV(DIR); I = 0;                  /* Determine the symbol direction */    do while ~VAL; I = I + 1; VAL = shr(VAL,1); end;  /* Find the note value */    if TYP = "104" then call GNOTE (I,SX,SY);                   else call NOTE  (I,SX,SY);      /* Plot the note */    if I > 0 then do;      J = I - EIGHTH#; if J < 0 then J = 0;  /* Determine stem length */      if TYP = "104"      then call GSTEM (SX+3*DIR,SY,(15+J*6)*DIR,I-QUARTER#,false);      else call STEM  (SX+4*DIR,SY+DIR,(STANDARD_STEM+J*6-1)*DIR,I-QUARTER#); /* Draw the stem */    end;  end;  else if TYP = "103" \ TYP = "105" then do; /* Rest */    I = 0; do while ~VAL; I = I + 1; VAL = shr(VAL,1); end;  /* Determine the rest value */    if TYP = "105" then call GREST (I,0,SX,SY);                   else call REST  (I,0,SX,SY);  end;  else if TYP = "106" then do; /* Chord name */    call GET_PITCH (VAL+TRANSPOSE(0),NAME);    call INSNAME_STR (NAME);    if NAME(0) = 2 then SX = SX - 8;    UPPER_FONT = F_MUSIC#;    LOWER_FONT = F_STANDARD#;    call PLOT_STRING (NAME,SX,SY,NAME(0),1);  end;  else if TYP = "107" then /* Bar line */    call BAR (SX,SY-L1);  else if TYP = "125" then do; /* Measure number positioning */    /* This is a weird place for this since it's a command, not a       symbol. It is here because the x,y decoding is all done for       us here, and these variables are, after all, global. */    MEASNO_POS    = shl(SX - X,8) | SY;    MEASNO_FORMAT = VAL;  end;  else if (TYP & "170") = "140" then do;    call SETUP_FONTS (FNT,EXT,LIB,STRING#);    EX = PLOT_STRING (location(addr(BUFF(1))),SX,SY,(VAL-2)*2,TSZ);    if BTX then call TEXT_BOX (SX,SY,EX,TSZ);  end;  else if "150" <= TYP & TYP <= "157" then do; /* If a long symbol */    EX = SEARCH_X(PP,BUFF(2),X) + EXPAND(shr(BUFF(3),6),6) * 4; /* Find the closing X position */    EY = (BUFF(3) & MASK6) * 3;                                 /* Find the closing Y position */    if MID & TYP = "150" then do; /* If slur with midpoint */      MX = SEARCH_X(PP,BUFF(4),X) + EXPAND(shr(BUFF(5),6),6) * 4; /* Find the X midpoint */      MY = (BUFF(5) & MASK6) * 3;                                 /* Find the Y midpoint of the slur */    end;    else do; MX = 0; MY = DIR; end; /* Otherwise, let the slur routine determine the best one */    if MAIN_MODE = SYSEDIT# then do; /* If editing then plot edit marks for slur *//*    call LSYM_EDIT_MARK (SX,SY); *//*    call LSYM_EDIT_MARK (EX,EY); */      if MX > 0 then call LSYM_EDIT_MARK (MX,MY);    end;    do case TYP - "150";      call SLUR     (SX,SY,MX,MY,EX,EY);      call HAIR_PIN (SX,SY,EX,EY,DIR);      call TUPLET   (SX,SY,EX,EY,BUFF(4),DIR);      do; /* Lyric hyphen */        call SETUP_FONTS (rot(BUFF(1),4) & MASK2,false,false,CHAR#);        call PLOT_CHARACTER (asc.min,SX+(EX-SX)/2,SY+(EY-SY)/2,UP#);      end;      call WAVE     (SX,SY,EX,EY);      ;      if VAL = 5 /* Only lines made as of 7/18/85 version have type & width word */      then call LINE (SX,SY,EX,EY,shr(BUFF(4),8),BUFF(4) & LBYTE);      else call LINE (SX,SY,EX,EY,0,1);      do; /* Brace */        I = SY; J = EY;        if (DIR & SY < EY) | (~DIR & SY > EY)        then do; I = EY; J = SY; end;        call BRACE (SX,J,I-J);      end;    end;  end;  else if TYP = "160" then do; /* Cubic slur */    MAT(0) = EXPAND(shr(BUFF(2),8),8) + X;    MAT(1) = (BUFF(2) & LBYTE);    MAT(6) = EXPAND(shr(BUFF(5),8),8) + SEARCH_X(PP,BUFF(1)&MASK14,X);    MAT(7) = (BUFF(5) & LBYTE);    MAT(2) = EXPAND(shr(BUFF(3),8),8);    MAT(3) = EXPAND(BUFF(3),8);    MAT(4) = EXPAND(shr(BUFF(4),8),8);    MAT(5) = EXPAND(BUFF(4),8);    if (BUFF(1) & R_SMSLR) = 0 then do;      MAT(2) = MAT(2) * 4;      MAT(3) = MAT(3) * 3;      MAT(4) = MAT(4) * 4;      MAT(5) = MAT(5) * 3;    end;    MAT(2) = MAT(0) + MAT(2);    MAT(3) = MAT(1) + MAT(3);    MAT(4) = MAT(6) + MAT(4);    MAT(5) = MAT(7) + MAT(5);    call NSLUR (MAT,(BUFF(1) & R_DOTTED) ~= 0);  end;  else if TYP = "170" | TYP = "171" then do; /* Guitar chord frame or chord name */    NAME(0) = 12;    do I = 1 to 6;      NAME(I) = BUFF(I+1);    end;    call GUITAR_FRAME (NAME,SX,SY,TYP="170");  end;  write(SECT$) = S;  /* Restore xmem registers */  write(WORD$) = W;  end PLOT_RECORD;end;end PICSRTNS;