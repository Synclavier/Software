module SYNCRTNS;insert ':mplt:oslits';insert ':mplt:lits';insert ':mplt:globdcls';/* Module globals */dcl P_SSEC  fixed,    P_DSEC  fixed,    P_SEC   fixed,    P_WRD   fixed,    P_W1    fixed,    P_W2    fixed,    P_W3    fixed,    P_W4    fixed,    (PSC,PWD) fixed,    (NSC,NWD) fixed,    CT(1)   fixed,    DT(1)   fixed,    PT(1)   fixed,    NT(1)   fixed;begin;/* MULTIPLY DIVIDE LITERALS: */DCL LOAD  LIT 'WRITE(5)=';             /* LOAD         */DCL ULOAD LIT 'WRITE(4)=';             /* LOAD UPPER   */DCL REM   LIT 'READ(4)'  ;             /* QUOTIENT REMAINDER               */DCL MUL   LIT 'WRITE(6)=';DCL DIV   LIT 'WRITE(7)=';  DCL RES   LIT 'READ(5)'  ;             /* RESULT       */DCL URES  LIT 'READ(4)'  ;             /* UPPER RESULT */DCL MWAIT LIT 'WRITE("324")=RES';      /* D5 TO ATNV TO WAIT FOR MUL/DIV *//* REPEAT COUNTER: */  DCL RPC   LIT 'WRITE("010")=(-1)+';/* EXTERNAL MEMORY DEFINITIONS */dcl mam    lit '"60"';     /* memory address msb */dcl mal    lit '"61"';     /* memory address lsb */dcl md     lit '"62"';     /* memory data */dcl mdi    lit '"63"';     /* memory data with increment *//* Timbre definitions */DCL NUM.PARTIALS     LIT   '04'; /* NUMBER OF PARTIAL TIMBRES PER TIMBRE */DCL NUM.PARAMS       LIT   '46'; /* NUMBER OF PARAMETERS IN PARTIAL TIMBRE */DCL NUM.MISC.PARAMS  LIT   '08'; /* NUMBER OF MISC PARAMETERS AT END OF TIMBRE */DCL PINFO.LEN        LIT '(32)';DCL TINFO.LEN        LIT '(96)';DCL TI.NAME          LIT ' 8';   /* TIMBRE NAME */DCL MOR              LIT '(-1)'; /* -1: INDICATES A TIMBRE FRAME */DCL SUP              LIT '(-2)'; /* -2: INDICATES A SUPPRESSED PARTIAL - NO OTHER WORDS */DCL PINFO            LIT '(-3)'; /* -3: INDICATES OPTIONAL PARTIAL INFO BLOCK */DCL TINFO            LIT '(-4)'; /* -4: INDICATES OPTIONAL TIMBRE  INFO BLOCK *//* $subtitle ALLOCATE_SEG and FREE_SEG */ALLOCATE_SEG:procedure returns (fixed) swap6;  dcl SEC fixed;  if FREESEG_HEAD ~= null then do;    SEC          = FREESEG_HEAD;    write(SECT$) = NAH.PTR + SEC;    FREESEG_HEAD = read(DATA$);    if FREESEG_HEAD ~= null then do;      write(SECT$) = NAH.PTR + FREESEG_HEAD;      write(WORD$) = NLS.REV;      write(DATA$) = null;    end;  end;  else do;    SEC = NAH.LEN;    call XMEM_SECT_SLIDE (NAH.PTR + SEC,1);  end;  return (SEC);end ALLOCATE_SEG;FREE_SEG:procedure (SEC) swap6;  dcl SEC     fixed,      (FL,RL) fixed;  if SEC = null then return;  if FREESEG_HEAD ~= null then do;    write(SECT$) = NAH.PTR + FREESEG_HEAD;    write(WORD$) = NLS.REV;    write(DATA$) = SEC;  end;  write(SECT$) = NAH.PTR + SEC; /* Point to freed sec */  FL           = read(DATI$);   /* Get forward link */  RL           = read(DATI$);   /* Get reverse link */  write(WORD$) = NLS.FOR;  write(DATI$) = FREESEG_HEAD;  /* New forward link */  write(DATI$) = null;          /* Null reverse link */  write(DATI$) = -1;            /* Null track */  FREESEG_HEAD = SEC;  if FL ~= null then do; /* Link next to previous */    write(SECT$) = NAH.PTR + FL;    write(WORD$) = NLS.REV;    write(DATA$) = RL;  end;  if RL ~= null then do; /* Link previous to next */    write(SECT$) = NAH.PTR + RL;    write(DATA$) = FL;  end;end FREE_SEG;/* $subtitle INIT_SEQ_GLOBALS */INIT_SEQ_GLOBALS:procedure(trk) returns (boolean) public swap0;   dcl trk fixed;   if 0 < TRK & TRK < 254 then do; /* track is selected */      #trk       = trk;      write(mam) = NAH.PTR;   /* track header area */      write(mal) = #trk - 1 + num.kbd.tracks; /* load absolute track# */      #ptr       = read(md);  /* point to track header for this track */      if #PTR<>0 then do;     /* if track exists, set #'s to first note */        write(SECT$) = NAH.PTR + #PTR;      /* Point to track header */        #SEC         = read(DATA$);         /* Get 1st NLS pointer */        #ANYR        = false;        #ANYF        = false;        if #SEC = null then return (false); /* Quit if no 1st NLS */        write(SECT$) = NAH.PTR + #SEC;      /* Point to 1st NLS   */        write(WORD$) = NLS.FP;              /* and 1st note       */        #WRD         = read(DATI$);         /* Our pointer should be FP */        #LMSB        = 0;        #LLSB        = 0;        #NMSB        = 0;        if #WRD = read(DATA$) then do;      /* If FP = LP then no notes */          #NLSB = 0;          return (false);        end;        else do;          #ANYF = true;          call LOOK.UP.NOTE.INFO;          #NLSB = shr(#W1,1) & MASK10;          if ~ISA.EVENT then call ADVANCE.TO.NEXT.EVENT;        end;      end;      else return false;   end;   else return false;   return true;end INIT_SEQ_GLOBALS;/* $subtitle POSITION_SEQ_GLOBALS and LOOK.UP.NOTE.INFO */POSITION_SEQ_GLOBALS:procedure (T) public;  dcl T fixed array;  /* Scan backward until before time T */  do while #ANYR & (#NMSB igt T(1) \ (#NMSB = T(1) & #NLSB ige T(0)));    call BACKUP.TO.PRIOR.NOTE;  end;  /* Scan forward until at or beyond time T */  do while #ANYF & (#NMSB ilt T(1) \ (#NMSB = T(1) & #NLSB ilt T(0)));    call ADVANCE.TO.NEXT.REAL.NOTE;  end;end POSITION_SEQ_GLOBALS;LOCATE_NOTE:procedure (S,W) returns (boolean) public swap6;  /* Locate a specific note in a note list, preferably starting     from beyond the note in time */  dcl (S,W) fixed;  /* Scan forward until just after time T *//* OLD WAY  do while #ANYF & (#NMSB ilt T(1) \ (#NMSB = T(1) & #NLSB ilt T(0)));    call ADVANCE.TO.NEXT.NOTE;  end;  do while #ANYR & (#SEC ~= S \ #WRD ~= W);    call BACKUP.TO.PRIOR.NOTE;  end;  return (#SEC = S & #WRD = W);*/  /* This seems very inefficient since it backs up all the way,     then if no note it goes forward all the way from the     beginning. In practice, we will always be beyond the note     or at the beginning of the seq, and the note will always be     there */  do while #ANYR & (#SEC ~= S | #WRD ~= W);    call BACKUP.TO.PRIOR.NOTE;  end;  if (#SEC ~= S | #WRD ~= W)  then do while #ANYF & (#SEC ~= S | #WRD ~= W);    call ADVANCE.TO.NEXT.NOTE;  end;  return (#SEC = S & #WRD = W);end LOCATE_NOTE;/* LOOK UP #W1,#W2,#W3,#W4 FROM CURRENT NOTE RECORD *//* ONLY CALL WHEN #ANYF<>0  (I.E. POINTING TO       *//* A REAL NOTE,  AS OPPOSED TO END OF TRACK)        */LOOK.UP.NOTE.INFO:PROC PUBLIC;   write(mam) = nah.ptr + #sec;   /* look at note record         */   write(mal) = #wrd;   #w1=read(mdi);   #w2=read(mdi);   if #w1 then do;      #w3=read(mdi);      #w4=read(mdi);   end;   else do;      #w3=rte.max;      #w4=vel.note;   end;END LOOK.UP.NOTE.INFO;/* $subtitle ADVANCE.TO.NEXT.NOTE *//* ADVANCE.TO.NEXT.NOTE RETURNS 0 IF YOU ADVANCE TO THE   *//* END OF THE GIVEN TRACK.  OTHERWISE IT RETURNS A 1.     *//* ROUTINE ASSUMES (#SEC,#WRD) POINT TO A NOTE OR NLS.EOS *//* SET UP (#SEC,#WRD) BEFORE CALLING ROUTINE.             *//* IF ROUTINE ADVANCES, (#SEC,#WRD) POINT TO NEXT NOTE.   *//* OTHERWISE (#SEC,#WRD) WILL POINT AT THE NLS.EOS AT THE *//* END OF THE TRACK.                                      */ADVANCE.TO.NEXT.NOTE:  PROC FIXED PUBLIC;   DCL (K)           FIXED;   WRITE(MAM)=NAH.PTR + #SEC; /* POINT TO NOTE AT CURRENT POS */   WRITE(MAL)=#WRD;   IF READ(MD)<>NLS.EOS THEN DO;   /* POINTING AT A REAL NOTE   */      #ANYR=1;                     /* ONE BEHIND US FOR SURE    */      #LMSB=#NMSB;                 /* LAST TIME IS NEXT TIME    */      #LLSB=#NLSB;      IF (READ(MDI)&"174001")="100001"      THEN DO;                     /* LONG REST     */         #NMSB=#NMSB+READ(MDI);         #NLSB=#NLSB+READ(MD);         IF #NLSB ILT READ(MD)         THEN #NMSB=#NMSB+1;         WRITE(MAL)=READ(MAL)-2;      END;      ELSE WRITE(MAL)=READ(MAL)-1;      IF READ(MD)                  /* ADVANCE OVER CURRENT NOTE */      THEN #WRD=#WRD+4;            /* 4-WORD RECORD             */      ELSE #WRD=#WRD+2;            /* 2-WORD RECORD             */      WRITE(MAL)=#WRD;             /* POINT AT THE NOTE         */   END;   DO WHILE READ(MD)=NLS.EOS;      /* AT END OF THIS NLS        */      WRITE(MAL)=NLS.FOR;          /* GET THE FORWARD PTR       */      IF READ(MD)=0                /* NO MORE NOTE SEGS ON TRACK  */      THEN DO;                     /* HIT END OF TRACK - BOMB OUT */         WRITE(MAM)=NAH.PTR+#SEC;  /* POINT AT NLS.EOS AT END OF TRACK */         WRITE(MAL)=#WRD;         #ANYF=0;                  /* NOT POINTING TO NOTE        */         RETURN 0;      END;      #SEC=READ(MD);               /* UPDATE INTO GLOBAL        */      WRITE(MAM)=NAH.PTR+#SEC;     /* SET PTR TO NEXT NLS       */      WRITE(MAL)=NLS.FP;           /* GET PTR TO FIRST WORD IN NLS */      #WRD=READ(MD);               /* UPDATE INTO GLOBAL        */      WRITE(MAL)=#WRD;             /* AND POINT TO IT           */   END;   /* AT THIS POINT, (#SEC,#WRD) ARE POINTING AT THE NEXT */   /* NOTE ON THE TRACK. AND THE MAM AND MAL PTRS ARE ALL */   /* SET UP TO BEGIN READING.                            */   K=SHR(READ(MD),1)&1023;      /* GET DELTA               */   #NLSB=#NLSB+K;               /* ADD TO NEXT TIME        */   IF #NLSB ILT K               /* CARRY                   */   THEN #NMSB=#NMSB+1;      RETURN 1;                       /* WAS ABLE TO ADVANCE */END ADVANCE.TO.NEXT.NOTE;/* $subtitle BACKUP.TO.PRIOR.NOTE *//* BACKUP.TO.PRIOR.NOTE RETURNS 0 IF YOU BACK UP TO THE     *//* START OF THE GIVEN TRACK.  OTHERWISE IT RETURNS A 1.     *//* ROUTINE ASSUMES (#SEC,#WRD) POINT TO A NOTE OR NLS.EOS.  *//* PASSED AN ABSOLUTE PTR TO THE TRK HEAD. SET UP           *//* (#SEC,#WRD) BEFORE CALLING ROUTINE. IF ABLE TO BACK UP,  *//* (#SEC,#WRD) POINT TO PRIOR NOTE. OTHERWISE (#SEC,#WRD)   *//* WILL POINT AT THE FIRST NOTE ON THE TRACK.               */BACKUP.TO.PRIOR.NOTE: PROC FIXED PUBLIC;   DCL K             FIXED;   DCL (SEC,WRD)     FIXED;   LOOK.AT.PRIOR.NOTE:PROC;      WRITE(MAM)=NAH.PTR+SEC; /* POINT TO CURRENT NLS              */      WRITE(MAL)=NLS.FP;           /* LOOK UP PTR TO 1ST WORD IN NLS    */      K=READ(MD);                  /* SAVE IN TEMP                      */      DO WHILE WRD=K;              /* AT START OF NLS, GO BACK          */         WRITE(MAL)=NLS.REV;       /* AND SEE IF PRIOR NLS EXISTS       */         IF READ(MD)=#PTR           /* BACKING UP TO THE TRK HEAD      */         THEN DO;                   /* HAVE TO QUIT                    */            WRITE(MAM)=NAH.PTR+SEC; /* POINT AT FIRST NOTE IN TRACK    */            WRITE(MAL)=WRD;            RETURN 0;               /* HIT START OF TRACK - BOMB OUT   */         END;         SEC=READ(MD);             /* SAVE PTR TO PRIOR NLS IN GLOBAL   */         WRITE(MAM)=NAH.PTR+SEC;   /* POINT TO PRIOR NLS                */         WRITE(MAL)=NLS.FP;        /* GET PTR TO FIRST WORD IN NLS      */         K   =READ(MDI);           /* READ IT THEN STEP TO NLS.LP VAR   */         WRD=READ(MD );            /* PTR TO LAST WORD IN NLS IN GLOBAL */      END;      WRITE(MAL)=WRD-1;           /* BACK UP TO LAST WORD OF NOTE */      IF (READ(MD)&"77")=VEL.NOTE  /* HAVE A 4-WORD RECORD         */      THEN WRD=WRD-4;      ELSE WRD=WRD-2;      WRITE(MAL)=WRD;             /* AND POINT TO IT             */      RETURN 1;   END LOOK.AT.PRIOR.NOTE;   /* $PAGE */   WRD=#WRD; SEC=#SEC;          /* START HERE */   IF LOOK.AT.PRIOR.NOTE=0      /* NO NOTE    */   THEN RETURN 0;   /* AT THIS POINT, (#SEC,#WRD) ARE POINTING AT THE PRIOR */   /* NOTE ON THE TRACK. AND THE MAM AND MAL PTRS ARE ALL  */   /* SET UP TO BEGIN READING.                             */   #WRD=WRD; #SEC=SEC;          /* GO THERE                */   #ANYF=1;                     /* NOTE IN FRONT OF US     */   #NMSB=#LMSB;                 /* NEXT TIME IS LAST TIME  */   #NLSB=#LLSB;   K=SHR(READ(MD),1)&1023;      /* GET DELTA               */   IF #LLSB ILT K               /* COMPUTE NEW LAST TIME   */   THEN #LMSB=#LMSB-1;   #LLSB=#LLSB-K;      IF LOOK.AT.PRIOR.NOTE<>0     /* SEE IF LONG REST RECORD */   THEN DO;                     /* ONE BEHIND US */      #ANYR=1;      IF (READ(MDI)&"174001")="100001"      THEN DO;                  /* LONG REST     */         #LMSB=#LMSB-READ(MDI);         IF #LLSB ILT READ(MD)         THEN #LMSB=#LMSB-1;         #LLSB=#LLSB-READ(MD);      END;   END;   ELSE DO;      #ANYR=0;                  /* NO NOTE          */   END;   WRITE(MAM)=NAH.PTR+#SEC;     /* RESET POINTERS TO NOTE  */   WRITE(MAL)=#WRD;   RETURN 1;                    /* WAS ABLE TO BACK UP     */END BACKUP.TO.PRIOR.NOTE;/* $subtitle Backup and Advance to Real Note */ISA.EVENT:procedure returns(boolean) public;   if rot(#w1,1)                 /* Alternate note */   or (#w3 & shl(b.upd,8)) <> 0  /* update         */   or (#w2 & "77") = rest.note   /* 2 word rest    */   then return(false);   else return(true);end ISA.EVENT;ISA.REAL.NOTE: proc returns(boolean) public;  write(SECT$) = nah.ptr + #sec;    /* look at note record         */  write(WORD$) = #wrd;  if (read(DATI$) & "174001") = "100001"  /* 4 word rest note */  or (read(DATI$) & "77")     = rest.note /* 2 word rest note */  then return (false);  else return (true);end ISA.REAL.NOTE;ADVANCE.TO.NEXT.REAL.NOTE: PROC PUBLIC;  if #anyf = 0 then return (false); /* end of track has been reached already */  do forever;     call advance.to.next.note;           /* advance one note record   */     if #anyf = 0 then return (false);    /* end of track reached      */     if isa.real.note then return (true); /* return if a non-rest note */  end;end ADVANCE.TO.NEXT.REAL.NOTE;   BACKUP.TO.PRIOR.REAL.NOTE: PROC public;  do forever;    if #anyr = 0 then return (false);    /* first note */    call backup.to.prior.note;           /* move back one note record */    if isa.real.note then return (true); /* return if a non-rest note */  end;end BACKUP.TO.PRIOR.REAL.NOTE;   ADVANCE.TO.NEXT.EVENT: PROC FIXED PUBLIC;  if #anyf = 0 then return;      /* end of track has been reached already */  do forever;    if ~advance.to.next.note then return; /* advance one note record   */    call look.up.note.info;    if isa.event then return; /* check which type of record we have & return if a real or ilp note */  end;end ADVANCE.TO.NEXT.EVENT;BACKUP.TO.PRIOR.EVENT: PROC public;  do forever;    if #anyr = 0 then return;     /* first note     */    call backup.to.prior.note;    /* move back one note record */    call look.up.note.info;    if isa.event then return; /* check which type of record we have & return if a real or ilp note */  end;end BACKUP.TO.PRIOR.EVENT;/* $SUBTITLE  ROUTINE TO ALLOCATE AND INIT A TRACK HEADER *//* ALLOCATE.TRK.HEADER RETURNS 0 IF IT FAILS *//* ELSE RETURNS AN ABS PTR TO TRK HEAD       */ALLOCATE.TRK.HEADER:PROC(TRK) FIXED swap6; /* ALLOCATES AND INITS NAH BLOCK FOR TRK HEAD */   DCL (TRK,THP,I) FIXED;   TRK = TRK - 1 + num.kbd.tracks;   THP = ALLOCATE_SEG;                    /* GET TRACK HEADER         */   IF THP = null THEN RETURN null;        /* NONE AVAILABLE           */   WRITE(MAM)=NAH.PTR+THP;   DO I=0 TO 63;                   /* ZERO OUT THE SECTOR      */      WRITE(MDI)=0; WRITE(MDI)=0;      WRITE(MDI)=0; WRITE(MDI)=0;   END;   WRITE(MAM)=NAH.PTR;                  /* STORE REL PTR IN NAH TABLE */   WRITE(MAL)=TRK;   WRITE(MD )=THP;   WRITE(MAM)=NAH.PTR+THP;              /* INITIALIZE TRACK HEADER */   WRITE(MAL)=THD.TRK;   WRITE(MD )=TRK;   WRITE(MAL)=THD.TVOL;                 /* TRACK VOLUME */   WRITE(MD )=1000;   WRITE(MAL)=THD.ORATIO;               /* INDIVIDUAL OCTAVE RATIO */   WRITE(MD )=1000;   WRITE(MAL)=THD.STIMB;                /* STARTING TIMBRE */   WRITE(MD )=0;   call COPY_EXT (BAS.PTR,0,NAH.PTR+THP,THD.SCALE,12); /* INDIVIDUAL SCALE FROM SEQ.SCALE */   RETURN THP;END ALLOCATE.TRK.HEADER;/* $subtitle UPDATE_SEQ_POINTERS */UPDATE_SEQ_POINTERS:procedure (TH,OS,OP,NS,NP) swap6;  /* This updates the sequences pointers in the current note lists,     the pointers in the Seq Record area, and the #'s */  dcl TH      fixed, /* Track header pointer */      (OS,OP) fixed,      (NS,NP) fixed,      (I,PT,P,V) fixed;  SCAN:procedure (P,OS,OP,NS,NP) recursive;    dcl (P,Q)   pointer,        (OS,OP) fixed,        (NS,NP) fixed,        V       fixed;    do while P ~= null;      if (core(P+D6) & B_TUP) ~= 0 then do V = 0 to 1;  /* If a tuplet */        Q = core(P+D1+V);                               /* Get NoteSublist pointer */        if Q ~= null then call SCAN (Q,OS,OP,NS,NP);        Q = core(P+GRP);                                /* Get next record */      end;      else Q = P;      do while Q ~= null;        if core(Q+D1X) = OS & core(Q+D1) = OP then do;          core(Q+D1X) = NS;          core(Q+D1)  = NP;        end;        Q = core(Q+GRP);      end;      if (core(P+D6) & B_EOT) ~= 0      then P = null;      else P = core(P);    end;  end SCAN;  do I = 0 to STAVES;    PT = DISPLAY(I);    if RUNNING then call SCAN (HEAD(PT),OS,OP,NS,NP);    do V = 0 to 1;      P            = PT * 16 + V * 8;      write(SECT$) = PFIL_BASE + shr(P,8);      write(WORD$) = P+4;      if read(DATI$) = OP & read(DATA$) = OS then do;        write(WORD$) = P+4;        write(DATI$) = NP;        write(DATA$) = NS;      end;    end;    if #SEC = OS & #WRD = OP then do;      #SEC = NS;      #WRD = NP;    end;  end;  write(SECT$) = NAH.PTR + TH;  write(WORD$) = THD.ILS.WRD;  if OP = read(DATI$) & OS = read(DATA$) then do;    write(WORD$) = THD.ILS.WRD;    write(DATI$) = NP;    write(DATA$) = NS;  end;  write(WORD$) = THD.ILE.WRD;  if OP = read(DATI$) & OS = read(DATA$) then do;    write(WORD$) = THD.ILE.WRD;    write(DATI$) = NP;    write(DATA$) = NS;  end;  /* Interesting point: we don't have to update HEAP recs because     their seq pointers have all been converted to back pointers */end UPDATE_SEQ_POINTERS;/* $subtitle PACK_NOTE */PACK_NOTE:procedure swap6;  dcl (P,T) fixed;  if P_DSEC = null then do; /* Allocate a new destination sector to pack */    P_DSEC = ALLOCATE_SEG;    write(SECT$) = NAH.PTR + P_SSEC;    write(WORD$) = NLS.REV;    P            = read(DATA$); /* NLS.REV */    write(DATI$) = P_DSEC;      /* NLS.REV */    T            = read(DATA$); /* NLS.TRK */    write(SECT$) = NAH.PTR + P;    write(DATA$) = P_DSEC;      /* NLS.FOR */    write(SECT$) = NAH.PTR + P_DSEC;    write(DATI$) = P_SSEC;     /* NLS.FOR (0) */    write(DATI$) = P;          /* NLS.REV (1) */    write(DATI$) = T;          /* NLS.TRK (2) */    write(DATI$) = NLS.FIRSTL; /* NLS.FP  (3) */    write(DATI$) = NLS.FIRSTL; /* NLS.LP  (4) */    write(DATI$) = 0;          /* unused  (5) */    write(DATI$) = 0;          /* unused  (6) */    write(DATI$) = 0;          /* unused  (7) */    write(WORD$) = NLS.FIRSTL; /* This is redundant, but safe */  end;  else do;    write(SECT$) = NAH.PTR + P_DSEC;    write(WORD$) = NLS.LP;    write(WORD$) = read(DATA$);  end;  P_SEC = P_DSEC;  P_WRD = read(WORD$);  write(DATI$) = P_W1;  write(DATI$) = P_W2;  if P_W1 then do;    write(DATI$) = P_W3;    write(DATI$) = P_W4;  end;  write(DATA$) = NLS.EOS;  P            = read(WORD$);  write(WORD$) = NLS.LP;  write(DATA$) = P;  if P > NLS.LAST then P_DSEC = null;end PACK_NOTE;/* $subtitle STREAM_SEGMENT */STREAM_SEGMENT:procedure (ABORT) swap6;  dcl ABORT   boolean,      (TK,TH) fixed,      (FP,LP) fixed,      (NP,WL) fixed;/*error_case do;  pstring('        Stream here P_SSEC,P_DSEC ');pnum(P_SSEC,0);pnum(P_DSEC,10);crlf;  flush_term;end;*/  /* Get Track, First Pointer, and Last Pointer from source */  write(SECT$) = NAH.PTR + P_SSEC;  write(WORD$) = NLS.TRK;  TK           = read(DATI$); /* NLS.TRK - Absolute track # of this seg */  FP           = read(DATI$); /* NLS.FP */  LP           = read(DATI$); /* NLS.LP */  /* Get Track Header pointer for UPDATE_SEQ_POINTERS */  write(SECT$) = NAH.PTR;  write(WORD$) = TK;  TH           = read(DATA$);  do forever;    if FP >= LP \ (ABORT & ~term_idle) then do;      /* Update possible pointer to NLS.EOS (actually only at end of seq) */      call UPDATE_SEQ_POINTERS (TH,P_SSEC,FP,P_SEC,P_WRD+WL);      write(SECT$) = NAH.PTR + P_SSEC;      write(WORD$) = NLS.FP;      write(DATA$) = FP;      return;    end;    write(SECT$) = NAH.PTR + P_SSEC;    write(WORD$) = FP;    P_W1 = read(DATI$);    P_W2 = read(DATI$);    if P_W1 then do;      P_W3 = read(DATI$);      P_W4 = read(DATI$);    end;    NP = read(WORD$);    call PACK_NOTE;    call UPDATE_SEQ_POINTERS (TH,P_SSEC,FP,P_SEC,P_WRD);    WL = NP - FP;    FP = NP;  end;end STREAM_SEGMENT;/* $subtitle CLEAN_LIST and CLEAN_SEQUENCE */CLEAN_LIST:procedure (ABORT,SEC) swap6;  dcl ABORT boolean,      SEC   fixed,      FL    fixed;/*  pstring('    CleanList here SEC = ');pnum(SEC,0);crlf;flush_term; */  P_DSEC = null;  do while SEC ~= null;/*pstring('      Looping SEC = ');pnum(SEC,0);crlf;flush_term; */    write(SECT$) = NAH.PTR + SEC;    FL           = read(DATA$);   /* Get forward link */    write(WORD$) = NLS.FP;        /* Set up to read FP & LP */    if P_DSEC ~= null \           /* Always stream if packing */       ((read(DATI$) > NLS.FIRSTL \ read(DATA$) <= NLS.LAST) & /* If seg not full and */        FL ~= null)               /* not the last seg */    then do; /* Stream this seg */      P_SSEC = SEC;      call STREAM_SEGMENT (ABORT);      if (ABORT & ~term_idle) then return;    end;    write(SECT$) = NAH.PTR + SEC;    write(WORD$) = NLS.FP; /* Set up to read FP & LP */    if read(DATI$) >= read(DATA$) then call FREE_SEG (SEC); /* If this seg got used up, free it */    SEC = FL;  end;/*pstringr('    Leaving CleanList');flush_term;*/end CLEAN_LIST;CLEAN_SEQUENCE:procedure (ABORT) public swap0;  dcl ABORT   boolean,      ABS_TRK fixed, /* static init(0) */      (I,P,Q) fixed;/*clear_all; call rchar;pstringr('In clean_seq'); flush_term; */  do ABS_TRK = NUM.KBD.TRACKS to MAX.TRACKS;    write(SECT$) = NAH.PTR;    write(WORD$) = ABS_TRK;    P            = read(DATA$);/*if P ~= null then do;  pstring('  Looping over tracks NAH.PTR,ATRK,P ');  pnum(NAH.PTR,0);pnum(ABS_TRK,10);pnum(P,10);crlf;  flush_term;end;*/    if P ~= null then do;      write(SECT$) = NAH.PTR + P;      call CLEAN_LIST (ABORT,read(DATA$));      if (ABORT & ~term_idle) then return;      write(SECT$) = NAH.PTR + P;      Q            = read(DATA$);      write(WORD$) = THD.STIMB;      if read(DATA$) = 0 & Q = null then do;        write(SECT$) = NAH.PTR;        write(WORD$) = ABS_TRK;        write(DATA$) = null;        call FREE_SEG (P);      end;      else do;        I = 0;        do while Q ~= null;          write(SECT$) = NAH.PTR + Q;          Q            = read(DATA$);          I            = I + 1;        end;        write(SECT$) = NAH.PTR + P;        write(WORD$) = THD.NUM.NLS;        write(DATA$) = I;      end;    end;  end;/*pstringr('Leaving clean_seq'); call rchar;*/end CLEAN_SEQUENCE;/* $subtitle EDIT_TRACK */EDIT_TRACK:procedure (INS,DEL) public swap0;  /* If INS = true insert the note in #W1-4 at time #MSB,#LSB.     If DEL = true delete the note pointed to by #SEC,#WRD.     It assumes that the #'s are pointing into the track to be     edited and are valid. */  dcl (INS,DEL)  boolean,      PRIOR_NOTE boolean,      NEXT_NOTE  boolean,      (P,LP)     fixed,      (SEC,WRD)  fixed;/*error_case do;  clear;  pstring('EditTrack here, INS,DEL ');pnum(INS,0);pnum(DEL,8);crlf;  pstring('                SEC,WRD ');onum(#SEC,0);onum(#WRD,8);crlf;  flush_term;end;*/  /* Check if Track Header is present */  if #PTR = null  then if INS then #PTR = ALLOCATE.TRK.HEADER (#TRK);              else return;/*error_case do;  pstring('After AllocateTrkHeader #ptr = ');pnum(#PTR,0);crlf;  flush_term;end;*/  /* Update note count */  if INS xor DEL then do;    write(SECT$) = NAH.PTR + #PTR;    write(WORD$) = THD.NN.MSB;    DT(1)        = read(DATI$);    DT(0)        = read(DATA$);    if INS then call ADD32 (DT,1);    if DEL then call SUB32 (DT,1);    write(WORD$) = THD.NN.MSB;    write(DATI$) = DT(1);    write(DATA$) = DT(0);  end;/*error_case do;  pstringr('After update of note count');  flush_term;end;*/  /* Check if 1st NAH is present */  write(SECT$) = NAH.PTR + #PTR;  if read(DATA$) = null then if ~DEL then do;    P            = ALLOCATE_SEG;    write(SECT$) = NAH.PTR + #PTR;    write(DATA$) = P;    write(SECT$) = NAH.PTR + P;    write(DATI$) = null;                      /* 0 - NLS.FOR */    write(DATI$) = #PTR;                      /* 1 - NLS.REV */    write(DATI$) = #TRK - 1 + num.kbd.tracks; /* 2 - NLS.TRK */    write(DATI$) = NLS.FIRSTL;                /* 3 - NLS.FP  */    write(DATI$) = NLS.FIRSTL;                /* 4 - NLS.LP  */    write(DATI$) = 0;                         /* 5 - spare   */    write(DATI$) = 0;                         /* 6 - spare   */    write(DATI$) = 0;                         /* 7 - spare   */    write(WORD$) = NLS.FIRSTL;                /* This is redundant */    write(DATA$) = NLS.EOS;                   /* -1 is only "note" */    call INIT_SEQ_GLOBALS (#TRK);  end;  else return; /* If not inserting and no 1st NLS then quit *//*error_case do;  pstring('After Creating NAH area P = ');pnum(P,0);crlf;  flush_term;end;*/  /* $page */  /* Initialize position of #s if necessary */  CT(1) = #MSB;  CT(0) = #LSB;  if ~DEL then call POSITION_SEQ_GLOBALS (CT); /* Place #'s just after CT */  SEC = #SEC; /* From this point on, SEC,WRD points to note to delete */  WRD = #WRD;  PRIOR_NOTE = BACKUP.TO.PRIOR.REAL.NOTE; /* Place #'s on real note just before CT */  if PRIOR_NOTE then do;    PT(1) = #NMSB; PT(0) = #NLSB;  end;  else do;    PT(1) = 0;     PT(0) = 0;  end;  PSC = #SEC;  PWD = #WRD;  if DEL then do;    NEXT_NOTE = ADVANCE.TO.NEXT.REAL.NOTE;    if #SEC = SEC & #WRD = WRD then    NEXT_NOTE = ADVANCE.TO.NEXT.REAL.NOTE;    if ~INS then do;      CT(1) = PT(1); CT(0) = PT(0);    end;  end;  else do;    if #SEC = SEC & #WRD = WRD    then NEXT_NOTE = #ANYF;    else NEXT_NOTE = ADVANCE.TO.NEXT.REAL.NOTE; /* Place #'s on real note just after CT */  end;  if NEXT_NOTE then do;    NT(1) = #NMSB; NT(0) = #NLSB;  end;  else do;    NT(1) = CT(1); NT(0) = CT(0);  end;  NSC = #SEC;  NWD = #WRD;/*error_case do;  pstringr('After Positioning #s @@');  pstring('   #NMSB');unum(#NMSB,8);pstring('   #SEC');onum(#SEC,8);crlf;  pstring('   #NLSB');unum(#LMSB,8);pstring('   #WRD');onum(#WRD,8);crlf;  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/  P_DSEC = null;                   /* We want to pack into a new seg */  P_SSEC = SEC;                    /* From top of current note seg */  LP     = 0;  if PRIOR_NOTE then do;  /* If there WAS a previous note, */    write(SECT$) = NAH.PTR + PSC;    write(WORD$) = PWD;    if read(DATA$) then PWD = PWD + 4; /* advance over it */                   else PWD = PWD + 2;    write(WORD$) = NLS.LP;    LP           = read(DATA$);          /* Get original LP */    write(DATA$) = PWD;                  /* Set new LP at 1st unused word */    if PSC = SEC then call STREAM_SEGMENT (false); /* stream prior notes to new seg */    else do;      write(WORD$) = PWD;           /* else dump marker in last word */      write(DATA$) = NLS.EOS;      write(WORD$) = NLS.FOR;      PSC          = read(DATA$);      LP           = null;         /* So we know later that PSC ~= SEC */    end;  end;/*error_case do;  pstringr('Before PSC free');  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/  do while PSC ~= SEC;    P            = PSC;    write(SECT$) = NAH.PTR + PSC;    PSC          = read(DATA$);    call FREE_SEG (P);  end;/*error_case do;  pstringr('After setup for streaming');  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/  /* $page */  #LMSB = PT(1); /* Set LastTimes to prior note */  #LLSB = PT(0);  #ANYR = PRIOR_NOTE;  #ANYF = NEXT_NOTE;/*error_case do;  pstringr('Before packing');  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/  call DIF32 (CT,PT,DT);                  /* Find leading DTime */  if DT(1) ~= 0 \ DT(0) igt 1023 then do; /* Pack long rest if needed */    P_W1 = "100001";    P_W2 = DT(1);    P_W3 = DT(0);    P_W4 = VEL.NOTE;    call PACK_NOTE;    DT(0) = 0;    #ANYR = 1;  end;  if INS then do;    P_W1 = (#W1 & "174001") \ shl(DT(0),1); /* Pack new note */    P_W2 = #W2;    P_W3 = #W3;    P_W4 = #W4;    call PACK_NOTE;    #SEC  = P_SEC;   /* Leave #'s pointing to new note */    #WRD  = P_WRD;    #NMSB = CT(1); /* Set NextTimes to new note */    #NLSB = CT(0);    #ANYF = 1;  end;  else do;    #NMSB = NT(1); /* Set NextTimes to new note */    #NLSB = NT(0);  end;  if NEXT_NOTE then do; /* There is a note in next sect so reset FP */    call DIF32 (NT,CT,DT);                  /* Find trailing DTime */    if DT(1) ~= 0 \ DT(0) igt 1023 then do; /* Pack long rest if needed */      P_W1 = "100001";      P_W2 = DT(1);      P_W3 = DT(0);      P_W4 = VEL.NOTE;      call PACK_NOTE;      DT(0) = 0;    end;    if LP ~= null then do;      write(SECT$) = NAH.PTR + SEC;      write(WORD$) = NLS.LP; /* Set LP back to end of seg */      write(DATA$) = LP;    end;/*error_case do;  pstringr('Before NSC set');  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/    write(SECT$) = NAH.PTR + NSC; /* Point to next note sector */    write(WORD$) = NLS.FP;        /* Point FP at next note */    write(DATA$) = NWD;    write(WORD$) = NWD;           /* Set next note time delta */    write(DATA$) = (read(DATA$) & "174001") \ shl(DT(0),1);  end;  else NSC = null; /* Will cause remaining secs to be freed *//*error_case do;  pstringr('Before NSC free');  pstring('     PSC');pnum(PSC  ,6);pstring('    PWD');onum(PWD ,8);pstring('   PN');pnum(PRIOR_NOTE,4);crlf;  pstring('     SEC');pnum(SEC  ,6);pstring('    WRD');onum(WRD ,8);crlf;  pstring('     NSC');pnum(NSC  ,6);pstring('    NWD');onum(NWD ,8);pstring('   NN');pnum(NEXT_NOTE,4);crlf;  flush_term;end;*/  do while SEC ~= NSC & SEC ~= null;    P            = SEC;    write(SECT$) = NAH.PTR + SEC;    SEC          = read(DATA$);    call FREE_SEG (P);  end;/*error_case do;  pstringr('Leaving EditTrack'); flush_term;end;*/end EDIT_TRACK;/* $subtitle SLIDE_TRACK */SLIDE_TRACK:procedure (ST,FT,INSR) public swap0;  /* If  INSR then add FT-ST at time ST     If ~INSR then remove time between ST and FT     #'s are assumed to point into track to be edited */  dcl ST            fixed array,      FT            fixed array,      INSR          boolean,      AT(1)         fixed,      DT(1)         fixed,      PRIOR_NOTE    boolean,      NEXT_NOTE     boolean,      NOTES_REMOVED fixed,      (P,LP)        fixed;/*error_case do;  clear;  pstring('SlideTrack here, INSR,TRK '); pnum(INSR,0); pnum(#TRK,6); crlf;  pstring('  ST = '); unum(ST(1),0); unum(ST(0),6); crlf;  pstring('  FT = '); unum(FT(1),0); unum(FT(0),6); crlf;end;*/  /* Check if Track Header is present */  if #PTR = null then return;  /* Check if 1st NAH is present */  write(SECT$) = NAH.PTR + #PTR;  if read(DATA$) = null then return;  call DIF32 (FT,ST,DT); /* Time to insert or remove */  call POSITION_SEQ_GLOBALS (ST); /* Place #'s just after ST */  PRIOR_NOTE = BACKUP.TO.PRIOR.REAL.NOTE; /* Place #'s on real note just before ST */  if PRIOR_NOTE then do;    PT(1) = #NMSB; PT(0) = #NLSB;  end;  else do;    PT(1) = 0;     PT(0) = 0;  end;  PSC = #SEC;  PWD = #WRD;  if INSR then do;    AT(1) = ST(1);    AT(0) = ST(0);  end;  else do;    AT(1) = FT(1);    AT(0) = FT(0);  end;  /* Place #'s just after edit area */  NOTES_REMOVED = -1;  do while #ANYF & (#NMSB ilt AT(1) \ (#NMSB = AT(1) & #NLSB ilt AT(0)));    call ADVANCE.TO.NEXT.REAL.NOTE;    NOTES_REMOVED = NOTES_REMOVED + 1;  end;  if NOTES_REMOVED > 0 then do;    /* Update note count */    write(SECT$) = NAH.PTR + #PTR;    write(WORD$) = THD.NN.MSB;    AT(1)        = read(DATI$);    AT(0)        = read(DATA$);    call SUB32 (AT,NOTES_REMOVED);    write(WORD$) = THD.NN.MSB;    write(DATI$) = AT(1);    write(DATA$) = AT(0);  end;  NEXT_NOTE = #ANYF;  NT(1)     = #NMSB;  NT(0)     = #NLSB;  NSC       = #SEC;  NWD       = #WRD;/*error_case do;  pstringr('After time & pointer setup');  pstring('  ST = '); unum(ST(1),0); unum(ST(0),6); crlf;  pstring('  FT = '); unum(FT(1),0); unum(FT(0),6); crlf;  pstring('  DT = '); unum(DT(1),0); unum(DT(0),6); crlf;  pstring('  PT = '); unum(PT(1),0); unum(PT(0),6); crlf;  pstring('  NT = '); unum(NT(1),0); unum(NT(0),6); crlf;end;*/  P_DSEC = null;                   /* We want to pack into a new seg */  P_SSEC = NSC;                    /* From top of current note seg */  LP     = 0;  if PRIOR_NOTE then do;  /* If there WAS a previous note, */    write(SECT$) = NAH.PTR + PSC;    write(WORD$) = PWD;    if read(DATA$) then PWD = PWD + 4; /* advance over it */                   else PWD = PWD + 2;    write(WORD$) = NLS.LP;    LP           = read(DATA$);          /* Get original LP */    write(DATA$) = PWD;                  /* Set new LP at 1st unused word */    if PSC = NSC then call STREAM_SEGMENT (false); /* stream prior notes to new seg */    else do;      write(WORD$) = PWD;           /* else dump marker in last word */      write(DATA$) = NLS.EOS;      write(WORD$) = NLS.FOR;      PSC          = read(DATA$);      LP           = null;         /* So we know later that PSC ~= NSC */    end;  end;  if ~NEXT_NOTE then NSC = null;  do while PSC ~= NSC;    P            = PSC;    write(SECT$) = NAH.PTR + PSC;    PSC          = read(DATA$);    call FREE_SEG (P);  end;  if ~NEXT_NOTE then return;  call DIF32 (NT,PT,AT); /* Actual time accounted for *//*error_case do;  pstringr('Actual time dif: AT = NT - PT');  pstring('  AT = '); unum(AT(1),0); unum(AT(0),6); crlf;end;*/  if INSR then call SUM32 (AT,DT,DT);          else call DIF32 (AT,DT,DT);/*error_case do;  pstringr('Time to add: DT = AT + DT');  pstring('  DT = '); unum(DT(1),0); unum(DT(0),6); crlf;end;*/  if DT(1) ~= 0 \ DT(0) igt 1023 then do; /* Pack long rest if needed */    P_W1 = "100001";    P_W2 = DT(1);    P_W3 = DT(0);    P_W4 = VEL.NOTE;    call PACK_NOTE;    DT(0) = 0;  end;  if LP ~= null then do; /* PSC was = NSC */    write(SECT$) = NAH.PTR + NSC;    write(WORD$) = NLS.LP; /* Set LP back to end of seg */    write(DATA$) = LP;  end;  write(SECT$) = NAH.PTR + NSC; /* Point to next note sector */  write(WORD$) = NLS.FP;        /* Point FP at next note */  write(DATA$) = NWD;  write(WORD$) = NWD;           /* Set next note time delta */  write(DATA$) = (read(DATA$) & "174001") \ shl(DT(0),1);/*error_case do;  pstringr('Leaving SlideTrack'); call rchar;end;*/end SLIDE_TRACK;/* $subtitle COMPRESS_NAH_AREA */COMPRESS_NAH_AREA:procedure public swap0; /* Is this needed? */  /* This squeezes out free segments, filling them with (random)     segments off the ende of the NAH area. *//* error_case return; */  dcl (OP,P,S)   fixed,      (TK,FL,RL) fixed;  OP = NAH.PTR + NAH.LEN;  P  = OP;  do while FREESEG_HEAD ~= null;    P            = P - 1;    write(SECT$) = P;    write(WORD$) = NLS.TRK;    TK           = read(DATA$);    if TK = -1 then do; /* This sector is on the free list - link it out */      write(WORD$) = NLS.FOR;      FL           = read(DATI$);      RL           = read(DATI$);      if RL = null then FREESEG_HEAD = FL;      else do;        write(SECT$) = NAH.PTR + RL;        write(DATA$) = FL;      end;      if FL ~= null then do;        write(SECT$) = NAH.PTR + FL;        write(WORD$) = NLS.REV;        write(DATA$) = RL;      end;    end;    else do; /* This seg is in use, move it to one of the free ones */      NSC = ALLOCATE_SEG; /* This will take seg from free list since free head ~= null */      call COPY_EXT (P,0,NAH.PTR+NSC,0,256);      write(SECT$) = NAH.PTR + NSC;      FL           = read(DATI$);      RL           = read(DATI$);      write(SECT$) = NAH.PTR;      write(WORD$) = TK;      if RL = null then write(DATA$) = NSC; /* This is a track header */      else do; /* This is a NLS - Update ILS & ILE pointers and reverse link */        S            = P - NAH.PTR; /* WRONG? */        write(SECT$) = NAH.PTR + read(DATA$);        write(WORD$) = THD.ILS.SEC;        if read(DATA$) = S then write(DATA$) = NSC;        write(WORD$) = THD.ILE.SEC;        if read(DATA$) = S then write(DATA$) = NSC;        write(SECT$) = NAH.PTR + RL; /* Update reverse link */        write(DATA$) = NSC;      end;      if FL ~= null then do;        write(SECT$) = NAH.PTR + FL;        write(WORD$) = NLS.REV;        write(DATA$) = NSC;      end;    end;  end;  call XMEM_SECT_SLIDE (P,P - OP);end COMPRESS_NAH_AREA;/* $subtitle Get timbre name */GET_TIMBRE_NAME:procedure (TRACK,BUFF) public swap;  dcl TRACK   fixed,      BUFF    fixed array,      FOUND   boolean,      TIM_NUM fixed,      (I,J,K) fixed;  FOUND        = false;  write(SECT$) = NAH.PTR;                    /* track header area */  write(WORD$) = TRACK - 1 + num.kbd.tracks; /* load absolute track# */  write(SECT$) = NAH.PTR + read(DATA$); /* point to track header for this track */  write(WORD$) = THD.STIMB;             /* get starting timbre # from track */  TIM_NUM      = read(DATA$);  write(SECT$) = PAR.PTR;               /* Start scanning at start of area */  do I = 2 to TIM_NUM;    /* Process partials */    do J = 0 to NUM.PARTIALS - 1;      if read(DATI$) ~= SUP then do;        do K = 2 to NUM.PARAMS;          write(NOP) = read(DATI$);        end;        do while read(DATA$) = MOR;          write(NOP) = read(DATI$); /* Eat MOR marker (-1) */          write(NOP) = read(DATI$); /* Eat type */          K          = read(DATI$); /* Get length */          do while K igt 3;            write(NOP) = read(DATI$);            K = K - 1;          end;        end;        if read(DATA$) = PINFO then do K = 0 to PINFO.LEN - 1;          write(NOP) = read(DATI$);        end;      end;    end;    /* Process frames */    if read(DATA$) = TINFO then do;      if I = TIM_NUM then FOUND = true;      do J = 0 to TINFO.LEN - 1;        K = read(DATI$);        if FOUND & TI.NAME <= J & J < TI.NAME+8        then BUFF(J - TI.NAME + 1) = K;      end;    end;    /* Process misc */    do J = 0 to NUM.MISC.PARAMS - 1;      write(NOP) = read(DATI$);    end;  end;  if FOUND then do;    BUFF(0) = 16;    do while byte(BUFF,BUFF(0)-1) = sp & BUFF(0) > 0;      BUFF(0) = BUFF(0) - 1;    end;  end;  else BUFF(0) = 0;end GET_TIMBRE_NAME;end;end SYNCRTNS;