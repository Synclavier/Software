/* 578-SUBC  $TITLE  Routines to Run Enter Subcatalog Screen *//*   9/25/86 - KJO - updated for -7 catalog structure   8/21/86 - ts,eg - fixed bug in parse.treename   8/18/86 - tss - made change to PRINT.CURRENT.CATNAME call   5/22/86 - MPB - Input Command Structure Added   5/19/86 - eg - made procedures and some variables public.   5/15/86 - "official" creation of release-M modules*/dcl subcs.displayed  fixed; /* count of subcatalogs displayed */dcl subc.pos         fixed; /* current position on ENTER SUBCAT SCREEN */dcl last.subc.pos    fixed; /* last pos */dcl entering.treename     fixed;  /* nonzero when entering tree name */POS.ENTER.SUBCAT.CURSOR:  proc swapable; /* put cursor at correct location */   dcl len fixed static;   print.name: proc(p);      dcl (i,j,k,p) fixed;      len=0;      do i=0 to 3; /* loop over words in filename */         if p<64  /* set up ptr to desired name */         then write(mam)=trd.ptr;         else write(mam)=trd.ptr+1;         write(mal)=shl(p,2)+i; /* compute index into table */         j=read(md);         k=j&"377";         if k>sp then do;            len=len+1; call pc(k);   /* print lower byte */         end;         k=shr(j,8);         if k>sp then do;            len=len+1; call pc(k);   /* print lower byte */         end;      end;      end print.name;   /* redraw last pos without reverse video */   call cpos(7+shr(last.subc.pos,3),5+(last.subc.pos&7)*9);   if vt100<>0 then do; /* reprint name in REVERSE VIDEO to highlight it */      call print.name(last.subc.pos); /* draw the name */   end;   /* compute correct positioning coords */   call cpos(7+shr(subc.pos,3),5+(subc.pos&7)*9);   if vt100<>0 then do; /* reprint name in REVERSE VIDEO to highlight it */      call reverse.video(1); /* turn on reverse video */      call print.name(subc.pos);       /* draw the name */      call reverse.video(0); /* turn off reverse video */      call cpos(7+shr(subc.pos,3),5+len+(subc.pos&7)*9); /* reposition cursor */   end;   if (token(0)<>0) and (entering.treename<>0) then do;      call cpos(23,18); call ps(token);   end;end POS.ENTER.SUBCAT.CURSOR;/* $SUBTITLE  Routine to Draw Enter Subcatalog Screen */ENTER.SUBCAT.SCREEN:  proc swapable; /* screen to allow entering new subcat */   dcl dev.ok  fixed static; /* set to 1 if ok to read device */   dcl (i,j,k) fixed;   call clear.term;   call PRINT.SCREEN.FRAME(21,'SUBCATALOG DIRECTORY');   call cpos(6,0);   if vt100<>0 then do; call CH.SET(alt); call DRAW.TEE(t.left); end;   else call pc("174");   call DRAW.HOR(78);   if vt100<>0 then do; call DRAW.TEE(t.right); call CH.SET(norm); end;   if d44_present then call plot.mouse.hole(mouse.hole.lowerx,mouse.hole.lowery);      /* now fill in directions area */   call cpos(1, 7);   call ps('1.  Use this screen to enter a different Subcatalog.');   call cpos(2, 7);   call ps('2.  Move cursor over name of desired Subcatalog using arrow keys.');   call cpos(3, 7);   call ps('3.  Press <RETURN> to enter that Subcatalog.');   call cpos(4, 7);   call ps('4.  Or simply enter a valid treename for desired catalog.');   call cpos(5, 7);   call ps('5.  '); call PRINT.EXIT.SCREEN.PROMPT;   call tty_wait;   /* first fill ext mem with names of available subcatalogs */   subcs.displayed=0; dev.ok = 0;   if inc.mono<>0 then call stop.disk; /* stop output so we can read disk */   if read_catalog('',1) then do; /* catalog read successfully */      do i = 0 to (c#dir_size / c#len - 1); /* loop over catalog entries */         call get_fcb(i,misc.buf); /* put fcb into misc.buf */         if  (misc.buf(f#nm)<>0)               /* non-null name */         and ((misc.buf(f#ty)=t#subc)         /* file type is a subcatalog */         or   (misc.buf(f#ty)=t#lsubc)) then do; /* or a large subcat */            write(mam)=trd.ptr+subcs.displayed/64;            write(mal)=shl(subcs.displayed,2); /* compute index into table */            do k = f#nm to (f#nm + f#name_len - 1);               write(mdi)=misc.buf(k);      /* copy name to ext mem */            end;               subcs.displayed=subcs.displayed+1; /* advance count of subcatalogs displayed */         end; /* file found */      end; /* looping over catalog entries */   end; /* catalog read successfully */   else dev.ok = -1; /* catalog read failed */   /* $PAGE */   /* Fill box with subcats available from current cat */   if subcs.displayed<>0   then call SORT.NAMES(subcs.displayed); /* sort filenames into order */   devices=0;   do i=2 to 7;      j=find_device(i);        /* get ptr to config info */      if j<>0 then do;         /* valid device */         device.list(devices)=i; devices=devices+1;      end;   end;   /* slide the subcatalog names down to insert device names at front */   i=subcs.displayed-1;   do while i>=0;      write(mam)=trd.ptr+i/64;      write(mal)=shl(i,2); /* compute index into table */      do j=0 to 3; misc.buf(j)=read(mdi); end;      write(mam)=trd.ptr+(i+devices)/64;      write(mal)=shl(i+devices,2);      do j=0 to 3; write(mdi)=misc.buf(j); end;      i=i-1;   end;   do i=0 to devices-1; /* now put device names into table */      j=device.list(i);      write(mam)=trd.ptr; write(mal)=shl(i,2);      do case shr(j,1)-1;         write(mdi)=ASC.F\shl(ASC.0+(j&1),8);         write(mdi)=ASC.R\shl(ASC.0+(j&1),8);         write(mdi)=ASC.W\shl(ASC.0+(j&1),8);      end;      write(mdi)=COLON; write(mdi)=0; write(md)=0;   end;   subcs.displayed=subcs.displayed+devices; /* now this many things to enter */   do i=0 to subcs.displayed-1; /* loop over available subcats */      /* compute correct positioning coords */      call cpos(7+shr(i,3),5+(i&7)*9);      do k=0 to 3;         write(mam)=trd.ptr+i/64;         write(mal)=shl(i,2)+k; /* compute index into table */         j=read(md);         if (j&"377")>sp then call pc(j&"377");  /* print lower byte */         if shr(j,8)>sp  then call pc(shr(j,8)); /* print upper byte */      end;      end;   call PRINT.CCAT; /* show the current catalog name */   if dev.ok=(-1) then call no.floppy; /* no disk in drive */   if subc.pos>(subcs.displayed-1) then do;      subc.pos=0; last.subc.pos=0;   end;   call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */end ENTER.SUBCAT.SCREEN;/* $SUBTITLE  Routine to Enter a Subcatalog Given a Treename */PARSE.TREENAME:  proc returns (fixed) swapable; /* do complicated enter */   dcl err           fixed;   dcl restore.level fixed external;   if inc.mono<>0 then call stop.disk; /* stop disk operations */   if enter_catalog(token,1) then do; /* try to enter this catalog */      if (drive.select.active<>0)      then restore.level = 1;      else do;         active.level = 1;         call compute.dsel.button;      end;      entered.new.dev = 1;            /* denotes we have changed subcats */      err = 0;                        /* no error */   end;   else do; /* error entering catalog */      if c#status = e#no_config then do; /* not configured */         err = 3;         call device.error;      end;      else if (c#status = e#no_file) or (c#status = e#not_cat) then do; /* file not found */         call subcat.error;         err = 1;      end;      else do; /* any other error */         if c#status=e#invalid         then call invalid.directory;         else if c#status=e#treename         then call incorrect.treename;         else if c#status=e#no_path         then call inter.cat.not.found;         else call format.error;         err = 2;      end;   end;   token(0) = 0; /* clear out token */   return (err); /* return error */end PARSE.TREENAME;/* $SUBTITLE  Routine to Enter a Subcatalog */ENTER.SUBCAT:  proc(index) swapable; /* routine which activates selected subcat */   dcl (index,i) fixed; /* INDEX is ptr to desired subcat */   if index<64  /* set up ptr to desired name */   then write(mam)=trd.ptr;   else write(mam)=trd.ptr+1;   write(mal)=shl(index,2); /* compute index into table */   token(0)=0;   do index=0 to 3; /* loop over words in filename */      i=read(md)&"377";   /* extract lower byte */      if i>sp then do;         call pbyte(token,token(0),i);         token(0)=token(0)+1;      end;      i=shr(read(mdi),8); /* extract upper byte */      if i>sp then do;         call pbyte(token,token(0),i);         token(0)=token(0)+1;      end;   end;      call PARSE.TREENAME; /* actually do the enter now */end ENTER.SUBCAT;/*0.........1.........2.........3.........4.........5.........6.........7.........01234567890123456789012345678901234567890123456789012345678901234567890123456789мссссссссссссссссссссссссссх  SUBCATALOG DIRECTORY  фссссссссссссссссссссссссссл	//	00ш      1.  Use this screen to enter a different Subcatalog.                    ш	//	01ш      2.  Move cursor over name of desired Subcatalog using arrow keys.       ш	//	02ш      3.  Press <RETURN> to enter that Subcatalog.                            ш	//	03ш      4.  Or simply enter a valid treename for desired catalog.               ш	//	04ш      5.  Press <ENTER> when done with this screen.                           ш	//	05мссссссссссссссссссссссссссх  SUBCATALOG DIRECTORY  фссссссссссссссссссссссссссл	//	00ш        Move cursor over name of desired Subcatalog using arrow keys.         ш	//	01ш        Press <RETURN> to enter that Subcatalog.                              ш	//	02ш        Or simply enter a valid treename for desired catalog.                 ш	//	03ш        Press <ENTER> when done with this screen.                             ш	//	04фссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссх	//	06ш    <PARENT>   W0:      W1:      MLTISOUC MULTI                               ш	//	07		 1ш    12345678 12345678 12345678 12345678 12345678 12345678 12345678 12345678   ш	//	08		 2ш                                                                              ш	//	09		 3ш                                                                              ш	//	10		 4ш                                                                              ш	//	11		 5ш                                                                              ш	//	12		 6ш                                                                              ш	//	13		 7ш                                                                              ш	//	14		 8ш                                                                              ш	//	15		 9ш                                                                              ш	//	16		10ш                                                                              ш	//	17		11ш                                                                              ш	//	18		12ш                                                                              ш	//	19		13ш                                                                              ш	//	20		14ш                                                                              ш	//	21		15нсссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссссск	//	22Error: Incorrect Treename "::"                Current Catalog:  W1:MULTISGM		//	23evaluate 15*8120*//* $SUBTITLE  Routine to Handle Chars for This Screen */ENTER.SUBCAT.INPUT:  proc(in.cmd,in.arg) swapable; /* process input for the ENTER SUBCAT state */   dcl (in.cmd,in.arg)      fixed;   do case in.cmd;      do;        /* character input */         if in.arg="20" then do;                /* CTRL-P: print hardcopy of screen */            if D40_PRESENT<>0               /* if device available */            then call SCREEN_DUMP;                         else call no.printer;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */            return;         end;         if (in.arg<>esc) and (entering.treename=0) then do;            call remove.err; call PRINT.CCAT;         end;         if in.arg=esc /* <ESC>:  return to startup menu without changes */         then do;            entering.treename=0; token(0)=0; /* reset flag, erase any token */            call RETURN.TO.PREV.STATE;         end;         else if in.arg=cret then do; /* <RETURN>:  done with this screen */            if entering.treename<>0 then do;               entering.treename=0; /* reset flag to allow any error messages */               if PARSE.TREENAME=0               then call RETURN.TO.PREV.STATE;            end;            else do;               last.subc.pos=subc.pos;       /* save this last position */               call ENTER.SUBCAT(subc.pos);  /* enter the subcat */               /* call RETURN.TO.PREV.STATE; */ /* used to do this */               call ENTER.SUBCAT.SCREEN;     /* reprint the screen */               call POS.ENTER.SUBCAT.CURSOR; /* position the cursor */            end;         end;         else if in.arg=home then do;            /* go to home position */            last.subc.pos=subc.pos;          /* save this last position */            subc.pos=0;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if in.arg=l.arr then do;           /* move left */            last.subc.pos=subc.pos;            /* save this last position */            if subc.pos<>0 then subc.pos=subc.pos-1;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if in.arg=r.arr then do;           /* move right */            last.subc.pos=subc.pos;            /* save this last position */            if subc.pos<(subcs.displayed-1)            then subc.pos=subc.pos+1;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if in.arg=u.arr then do;           /* move up on screen */            last.subc.pos=subc.pos;            /* save this last position */            if shr(subc.pos,3)<>0 then subc.pos=subc.pos-8;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if in.arg=d.arr then do;           /* move down on screen */            last.subc.pos=subc.pos;            /* save this last position */            if subc.pos<(subcs.displayed-8) then subc.pos=subc.pos+8;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if (in.arg=del) or (in.arg="32") then do;            if token(0)<>0 then do;               token(0)=token(0)-1;   /* delete char */               if token(0)=0 then do; /* have deleted whole string */                  call cpos(23,0); do in.arg=1 to 20; call pc(sp); end;                  entering.treename=0;               end;               else do; call pc(bs); call pc(sp); end;            end;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else if (in.arg=colon) and (entering.treename=0) then do; /* COLON: enter treename */            entering.treename=1;            call pbyte(token,0,colon);            token(0)=1;            call cpos(23,0); call ps('Enter Treename -->');            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         /* $PAGE */         else if (in.arg>=sp) and (token(0)<20) then do; /* treename char */            if (LOWER.A<=in.arg) and (in.arg<=LOWER.Z) then in.arg=in.arg-"40"; /* up the case */            if entering.treename=0 then do;               entering.treename=1;               call cpos(23,0); call ps('Enter Treename -->');            end;            call pbyte(token,token(0),in.arg);            token(0)=token(0)+1;            call POS.ENTER.SUBCAT.CURSOR; /* position cursor last spot used */         end;         else call POS.ENTER.SUBCAT.CURSOR;      end;  /* character input */      do;	/* handle mouse clicks */         if entering.treename<>0 then do;            entering.treename=0; /* reset flag to allow any error messages */            if PARSE.TREENAME=0            then call RETURN.TO.PREV.STATE;         end;         else do;            last.subc.pos=subc.pos;       /* save this last position */            subc.pos = in.arg;            call ENTER.SUBCAT(subc.pos);  /* enter the subcat */            /** call RETURN.TO.PREV.STATE; **/ /* don't want to leave w/ mouse click either */            call ENTER.SUBCAT.SCREEN;     /* reprint the screen */            call POS.ENTER.SUBCAT.CURSOR; /* position the cursor */         end;      end;	/* mouse click */      ;      ;      do;         call return.to.prev.state;      end;   end;  /* do case in.cmd */end ENTER.SUBCAT.INPUT;/* $Subtitle Subcatalog Directory Mouse Mapping 578-SUBC */ENTER.SUBCAT.MOUSE.POS:  proc(x,y) swapable;       /* Subcat Directory Mouse positioner */   dcl (x,y) fixed;  /* mouse position in row/col coordinates */   if mouse.hole(x,y) then do;      call enter.subcat.input(in.rtps,0);      return;   end;   x = convert.mouse.x(x);   y = convert.mouse.y(y);   if (y >= 7) & (y < 22)   &  (x >= 5) & (x < 79)   then do;      write(5) = x-5; write(7) = 9;      if  (read(4) < 8 )             /* not on space */      and ((read(5) + shl((y-7),3))<subcs.displayed)      then do;         call ENTER.SUBCAT.INPUT(in.abss,READ(5) + shl((Y-7),3));      end;   end;end ENTER.SUBCAT.MOUSE.POS;