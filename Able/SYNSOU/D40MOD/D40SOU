/* D40SOU - $Title D40 Interrupt Driven Printer Routines */Module D40MOD;   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:asciilit';  /* ASCII literals */   insert ':synlits:globlits';  /* general global literals */   insert ':synlits:syslits';   /* for d40_present */   insert ':synmods:globdcl';   /* d54bits and other globals */   insert ':synmods:plotdcl';   /* plotting package */   insert ':synmods:ttydcl';    /* terminal i/o routines */   insert ':-xpl:intrprtr';   dcl d40.buf.len     lit '8'; /* 8 char d40 output buf length */   dcl (d40rptr,d40sptr)        fixed;    /* pointers into d40 output rotary buffer */   dcl (d40buf) (d40.buf.len-1) fixed;    /* d40 output rotary buffer */   dcl (d40busy)                fixed;    /* true when d40 output is active */   dcl (d40.stopped)            fixed;    /* true when printer sends XOFF */   enable_d40: proc PUBLIC swapable;  /* enables D40 interrupts */      d54bits=d54bits\1;              /* set d40 bit            */      if D40_PRESENT                  /* check for D40 in configuration */      then write(d54)=d54bits;        /* only do this if D40 is actually in system */   end enable_d40;   disable_d40: proc PUBLIC swapable; /* disables D40 interrupts */      d54bits=d54bits&"177776";       /* clear d40 bit           */      if D40_PRESENT                  /* check for D40 in configuration */      then write(d54)=d54bits;        /* only do this if D40 is actually in system */   end disable_d40;   boot_d40:  proc;                   /* start up D40 - MUST CALL WITH INTERRUPTS OFF */      if d40rptr<>d40sptr then do;         write(d40)=d40buf(d40rptr);  /* write out byte to printer   */         d40rptr=(d40rptr+1)&(d40.buf.len-1); /* bump and wrap read pointer  */         d40busy=1;                   /* mark busy if character sent */      end;      else do;         d40busy=0;                   /* no longer printing       */         write(d41)=0;                /* acknowledge interrupt(s) */      end;   end boot_d40;   when D40INT then begin;                    /* handle incoming XON/XOFF and output */      dcl i fixed;      if (read(d41)&2)<>0 then do;            /* have received an input char */         i=read(d40)&"177";                   /* get char, mask off parity */         if i="23" then d40.stopped=1;        /* control s */         else if i="21" then do;              /* control q */            if d40.stopped<>0 then do;        /* restart output */               if d40busy=0 then call boot_d40; /* start output unless already going */               d40.stopped=0;            end;         end;         return;      end;      /* else must be transmit interrupt */      if d40.stopped = 0      then call boot_d40;                     /* perform more output if not stopped */      else do;         d40busy = 0;                         /* mark un-busy if stopped */         write(d41) = 0;                      /* clear xmit done intrpt  */      end;                                    /* output will resume when */   end;                                       /* ctrl-q received         */   d40_wait:  proc PUBLIC swapable;           /* wait for printer to finish printing */      do while (d40rptr<>d40sptr)             /* wait here for all output */      or       (d40.stopped <> 0)             /* and x-on/x-off sequences */      or       (d40busy     <> 0);            /* to stop.                 */	  		chill.out.and.run.syn();      end;   end d40_wait;   sendc:  proc(ch) swapable;             /* send a character to printer by putting it on list of chars to print */      dcl ch fixed;      do while ((d40sptr+1)&(d40.buf.len-1))=d40rptr; /* there is no space in circ queue */			chill.out.and.run.syn();	  	 		      end;      disable;                             /* during pointer storage */      d40buf(d40sptr)=ch;                  /* store character in output buffer */      d40sptr=(d40sptr+1)&(d40.buf.len-1); /* bump and wrap output pointer */      if (d40.stopped=0) and (d40busy=0)      then call boot_d40;      enable;   end sendc;/* To use this set of routines you need to first check the configuration   area to see if a D40 is in the system.  When you want to begin printing,   call ENABLE_D40 to enable D40 interrupts.  Then use the following   routines.  When done printing, be sure to turn off interrupts by   calling DISABLE_D40. (These enable/disable routines are in addition   to the normal conventions regarding the ENABLE and DISABLE statements   in XPL. */   /* $SUBTITLE  Alphanumeric String Dump Routine */   SEND_STRING: proc (String) public swapable;   /* prints copy of alpha chars on screen */      dcl String   array;      dcl i        fixed;      do i=0 to String(0)-1; /* scan by bytes */         call sendc(byte(String,i));      end;   end SEND_STRING;   /* $SUBTITLE  Alphanumeric Screen Dump Routine */   SCREEN_DUMP: proc public swapable;   /* prints copy of alpha chars on screen */      dcl ch       fixed;               /* character */      dcl i        fixed;      if D40_PRESENT=0      then return;                      /* if device not available */      call enable_d40;                  /* turn on D40 interrupts */      do i=0 to shl(screen.image.len,1)-1; /* scan by bytes */         if (i mod 80=0) then do;            call sendc("15");            call sendc("12");            call sendc("24");         end;         write(mam)=img.ptr+shr(i,9);   /* point to the screen image in external memory */         write(mal)=shr(i,1);         ch=read(md);         if i then ch=shr(ch,8);        /* if odd take upper byte */         else ch=ch&"377";              /* lower byte */         call sendc(ch);      end;      call sendc("14");      call d40_wait;      call disable_d40;                 /* turn off D40 interrupts */   end SCREEN_DUMP;   /* Routine to Dump Copy of Graphics Screen to Matrix Printer */   hardcopy: proc public swapable; /* dumps from the screen to the I.D.S.*/      /*  NOTE: This procedure can dump a VT640, DQ640, or MG600 screen to printer.          It also handles all interrupts so that the user can print and play. */      dcl screen_width  fixed static; /* width of screen in pixels */      dcl screen_height fixed static; /* height of screen in pixels */      dcl groups        fixed static; /* width of screen in 6-pixel units */      dcl swaths        fixed static; /* height of screen in 7-pixel units */      dcl bit           fixed static;      dcl last_byt      fixed static;      dcl (i,j,k,n)     fixed static;      dcl gon      lit '03'; dcl goff     lit '02';      dcl linefeed lit '14'; dcl formfeed lit '12';      read_screen: proc(y); /* reads a line of pixels from terminal */         dcl y            fixed; /* Y position of line to read */         dcl byt          fixed; /* byte position in printer array */         dcl c            fixed; /* next character from screen */         dcl count        fixed; /* number of consecutive bytes */         dcl last_bit     fixed static; /* last bit on line */         dcl (i,j,k)      fixed;         map_bits: proc(c,byt,bits); /* map screen bits to printer bits */            dcl c    fixed; /* character to map */            dcl byt  fixed; /* byte position in mapped printer array */            dcl bits fixed; /* number of bits in C that are valid */            dcl j    fixed;            if mg600<>0 then c=rot(c,16-bits);    /* bits are in reverse order on the limey MG600 */            if c=0 then return;                /* just return if nothing to do */            if byt>last_byt then last_byt=byt; /* look for the end */            do j=0 to bits;                    /* map all bits that are valid */               byt=byt-1;               if c then do;                   /* if the bit is set, map it onto the printer */                  write(mam)=trd.ptr+shr(byt,9); write(mal)=shr(byt,1);                  if byt then write(md)=read(md)\shl(bit,8);                  else        write(md)=read(md)\bit;               end;               if mg600<>0 then c=rot(c,1);    /* if mg600 then take next bit from top */               else             c=shr(c,1);    /* otherwise look at the next bit from bottom */            end;                               /* of mapping bits */         end map_bits;         if mg600<>0 then do;    /* Monteray MG600 */            i=shr(y,5)+32; j=(y&"37")+96;     /* high y, low y */            call pc(esc); call ps('}9'); call pc(i); call pc(j); call pc(i); call pc(j); /* ask for line Y */         end;         else do;                /* VT640 or DQ640 */            call pc(esc); call ps('"0;'); call pnum(y,0); call pc(scolon); /* ask for line Y */            if dq640<>0 then do; /* for DQ640 */               call pnum(screen_width,0); call pc(asc.c);            end;            else do;             /* for VT640 */               call pnum(groups,0); call pc(lower.c);            end;                      end;                         call tty_wait; /* allow command to get to terminal */         		 if (interp_is_running == 0)		 // for some reason we needed to clear the input buffer at this point on some terminal???		 {			 do while num.of.d50.in.chars<>0;				call get.next.d50.in.char;			 end;		 }		         /* $page */         i=0;                                 /* start reading bytes at byte zero */		 k=0;								  /* assume must read EOT			  */         do while i<groups;                   /* read pixels from screen */            c=get.next.d50.in.char;            if c=asc.dollr then do;           /* repeating bytes of all zeroes */               c=0; count=get.next.d50.in.char&"077";     /* pattern repeated COUNT times */            end;            else if c=percent then do;        /* repeating bytes of all ones */               c="077"; count=get.next.d50.in.char&"077"; /* pattern repeated COUNT times */            end;            else if c=asc.amp then do;        /* repeating bytes of an arbitrary pattern */               c=get.next.d50.in.char; count=get.next.d50.in.char&"077"; /* pattern repeated COUNT times */            end;            else count=1;                     /* just a single byte */            write(mam)=trd.ptr+3;            do j=1 to count;                  /* save the bytes */               write(mal)=shr(i,1);           /* pt to next free word */               if i then write(md)=shl(c,8)\(read(md)&255); /* upper byte */               else      write(md)=c;         /* lower byte */               i=i+1;                         /* advance screen counter */            end;			if (c == 4)						  /* detect EOT */			{				i = groups;				k = 1;			}         end;		 		 if (k == 0)	         c=get.next.d50.in.char;             /* read trailer */         last_bit=((screen_width-1) mod n); /* last bit on line */         byt=0;                       /* start at beginning of printer array */         do i=0 to groups-2;          /* map the screen bytes onto the printer */            byt=byt+n;                /* advance printer counter */            write(mam)=trd.ptr+3; write(mal)=shr(i,1);            if i then j=shr(read(md),8);            else      j=read(md)&255;            call map_bits(j,byt,n-1); /* map bits */         end;         byt=byt+last_bit+1;          /* advance printer counter */         write(mam)=trd.ptr+3; write(mal)=shr(groups-1,1);         if (groups-1) then j=shr(read(md),8);         else               j=read(md)&255;         call map_bits (j,byt,last_bit); /* map final group of bits */      end read_screen;      sendc:  proc(ch); /* send a character to printer by putting it on list of chars to print */         dcl ch fixed;         do while ((d40sptr+1)&(d40.buf.len-1))=d40rptr; /* there is no space in circ queue */				chill.out.and.run.syn();	  	 		         end;         disable;                             /* during pointer storage */         d40buf(d40sptr)=ch;                  /* store character in output buffer */         d40sptr=(d40sptr+1)&(d40.buf.len-1); /* bump and wrap output pointer */         if (d40.stopped=0) and (d40busy=0)         then call boot_d40;                  /* start output if buffer rea#dy and printer idle */         enable;      end sendc;      /* $page */      if D40_PRESENT=0 		  then return; /* no D40 configured in system */      if ADM<>0        		  then return; /* only if not an ADM terminal */	  if interp_is_running<>0 then return; /* doesnt work any more 		  */      call enable_d40;              /* turn on D40 interrupts      */      call sendc(cret);      vector_mode;      if mg600<>0 then do;         screen_width=1024;         screen_height=780;         n=4; /* readback is in 4-pixel groups */      end;      else if dq640<>0 then do;         screen_width=800;         screen_height=480;         n=6; /* readback is in 6-pixel groups */      end;      else do;                  /* vt640 */         screen_width=640;         screen_height=480;         n=5; /* readback is in 5-pixel groups */      end;      call sendc(gon);      groups=(screen_width+(n-1))/n; /* round up to nearest N-pixel boundary */      swaths=(screen_height+6)/7;    /* round up to nearest 7-pixel boundary */            do i=0 to swaths-1;         write(mam)=trd.ptr;         do j=0 to (groups*n+1)/2; write(mdi)=0; end; /* zero out info */         last_byt=(-1); bit=1;         if i=swaths-1 then k=((screen_height-1) mod 7); /* restrict last swath to screen size */         else k=6;                           /* not last swath - create all 7 swath lines */         do j=0 to k;            call read_screen((screen_height-1)-i*7-j);            bit=shl(bit, 1);         end;         write(mam)=trd.ptr;         do j=0 to last_byt;            if j then k=shr(read(mdi),8); /* get upper byte */            else      k=read(md)&255;     /* get lower byte */            if k=3 then call sendc(gon);  /* special case in printer logic */            call sendc(k);         end;         call sendc(gon); call sendc(linefeed);      end;      call sendc(gon); call sendc(formfeed);      call sendc(gon); call sendc(goff); call sendc(cret);      call d40_wait;      call disable_d40; /* turn off D40 interrupts */      transparent_mode;   end hardcopy;end D40MOD;