/* Index File Update Routines   By Kip Olson, June 1987   Modification History:   10/19/90 - cj  - Inserted synmods:getvdcl to access new.poly.contents.                    Created event bit in Mount.Optical.Volume   03/14/89 - SGS - change .INDEX pathname, based on system device   05/01/88 - KJO - Added faster index file update routines*/   dcl debug        lit '0';   dcl debugalloc   lit '0';   dcl UpdateInterval lit '1000'; /* no. ms between screen updates */   dcl FileTree(ptr#len - 1) fixed; /* head of file tree */   dcl CatTree(ptr#len - 1)  fixed; /* head of category tree */   dcl I$IndexPath  data ('.INDEX' ); /* index file subcatalog */   dcl I$Index1Path data ('.INDEX1'); /* index file subcatalog */   dcl I$UnCategory data ('"UNCATEGORIZED"'); /* category for uncategorized files */   dcl FileList     file  public; /* file variable for file list  */   FileList = NullF;              /* points at no file initially */   dcl FileListBuf  fixed;        /* first sector of buffer */   dcl FileListLen  fixed;        /* no. sectors in buffer */   dcl FileListMed  fixed;        /* memory location */   dcl CatList      file  public; /* file variable for category list */   CatList = NullF;               /* points at no file initially */   dcl CatListBuf   fixed;        /* first sector of buffer */   dcl CatListLen   fixed;        /* no. sectors in buffer */   dcl CatListMed   fixed;        /* memory location */   dcl I$IndexStart fixed public; /* sector offset of file list index */   dcl I$IndexCount fixed public; /* no. entries in file list index */   dcl I$FileStart  fixed public; /* sector offset of file list */   dcl I$FileCount  fixed public; /* no. entries in file list */   dcl I$CatStart   fixed public; /* sector offset of category list */   dcl I$CatCount   fixed public; /* no. entries in catetgory list */   dcl I$EntryCount fixed public; /* no. directory entries on optical disk */   dcl I$Stride     fixed public; /* file list index stride */   insert ':synsou:indexmod:prints'; /* print routines */   insert ':synsou:indexmod:mount';  /* mount routines */   insert ':synsou:indexmod:update'; /* update routines */   insert ':synsou:indexmod:modify'; /* modify routines */   Init.Optical.Disk.Stuff: proc swapable; /* initialize stuff for Optical Disk and Index File routines */      dcl Base$OptBuf   fixed;      dcl FListBase     fixed;    /* disk buffers for FILEIO */      dcl FListLen      lit '4';  /* to use when managing    */      dcl CListBase     fixed;    /* index files             */      dcl CListLen      lit '4';      dcl StackBase     fixed;      dcl MemBase       fixed;      if (Find_Device(10) != 0 || Find_Device(11)  != 0)		then do;         Base$OptBuf  =ALLOC.EXAMOUNT(2);         FListBase    =ALLOC.EXAMOUNT(FListLen);         CListBase    =ALLOC.EXAMOUNT(CListLen);         if debugalloc then do;            StackBase = ALLOC.EXAMOUNT(32);            call DefineStack(StackBase,32);            //print 'Enter 0 to for external, 1 for poly memory',;            //input MemBase;            if MemBase = 1 then do;               MemBase = 0; /* start at beginning of poly memory */               call DefineMArea(0,0,MemBase,0,2048);            end;            else do;               MemBase = ALLOC.EXAMOUNT(2048);               call DefineMArea(-1,0,MemBase,0,2048);            end;         end;         call Set_OptBuf(Base$OptBuf,1); /* allocate space for optical disk buffer */         call DefineFileBuffers(FListBase, FListLen, 1, CListBase, CListLen, 1);         if debugalloc then         print 'Opt,FList,CList,Stack, Mem base = ',Base$OptBuf,FListBase,CListBase,StackBase,MemBase;      end;   end Init.Optical.Disk.Stuff;   call Init.Optical.Disk.Stuff;