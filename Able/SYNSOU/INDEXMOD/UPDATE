   /* 10/19/90 - cj - Created event bit when index file is modified */   dcl (TotalFiles,TotalCats) fixed; /* total files and subcats */   Attach_Data_Block: proc(treeptr,dataptr) swapable; /* attach data block to tree block */      dcl treeptr fixed array; /* pointer to tree block */      dcl dataptr fixed array; /* pointer to data block */      call WriteMBlock(treeptr,mem$ptr);      write(mdevi) = dataptr(0); write(mdevi) = dataptr(1); /* make tree block point to data block */      call WriteMBlock(dataptr,mem$ptr);      write(mdevi) = treeptr(0); write(mdevi) = treeptr(1); /* make data block point to tree block */   end Attach_Data_Block;   Get_Category_List: proc(Infile) returns (boolean) swapable; /* read category list into a balanced binary tree */      dcl Infile       fixed; /* input file */      dcl treeptr(ptr#len - 1) fixed; /* pointer to tree block */      dcl dataptr(ptr#len - 1) fixed; /* pointer to data block */      dcl CatName(64)  fixed; /* array space for large category name */      dcl NumFiles     fixed; /* no. file pointers in category */      dcl UpdateTime   fixed; /* last update time */      dcl (i,j,p)      fixed;      call Seek(Infile,I$CatStart,3); /* seek to first sector of category list */      if debug then do; print 'Category list starts at sector ',I$CatStart,', contains ',I$CatCount,' entries'; end;      UpdateTime = real.milliseconds; /* show initial update message */      i = 0;      do while i ilt I$CatCount; /* read in all categories from category list */			timeshare_with_host();         j = GetW(InFile); /* get forward pointer */         CatName(0) = GetW(InFile); /* get length of category name */         do j = 1 to shr(CatName(0) + 1,1); /* store category name */            CatName(j) = GetW(Infile);         end;         NumFiles = GetW(InFile); /* get no. file pointers */         if debug then do; print 'Category',i,': Name = ',string(CatName),', Files = ',NumFiles; end;         p = TreeInsert(CatName,CatTree,treeptr); /* insert category name into tree */         if p = NoMoreRoom then return (false); /* no room for new category */         if NewMBlock(dataptr,NumFiles,true) then do; /* create data block */            call Attach_Data_Block(treeptr,dataptr); /* attach to tree */            call WriteMBlock(dataptr,mem$used);            write(mdevi) = NumFiles; /* store the number of file pointers */            do j = 0 to NumFiles - 1; /* store file pointers */               p = GetW(InFile); /* get file pointer */               call WriteMBlock(dataptr,mem$data + j);               write(mdevi) = p; /* store file pointer */            end;         end;         else return (false); /* no room for data block */         j = GetW(InFile); /* get back pointer */         i = i + 1; /* get next category */         if (real.milliseconds >= UpdateTime) and (not debug) then do; /* time to display update message */            call Display_Update_Status(1,i,I$CatCount); /* show message */            UpdateTime = real.milliseconds + UpdateInterval; /* next update time */         end;      end; /* looping over categories */      if debug then do; print 'Category list created'; end;      if (not debug) then      call Display_Update_Status(1,i,I$CatCount); /* show final update status */      TotalCats = I$CatCount; /* count the no. categories in category tree */      return (true); /* category list successfully read from index file */   end Get_Category_List;   Count_Dir_Categories: proc returns (fixed) swapable; /* count no. categories in this file */      dcl (start,i) fixed; /* starting index */      start = gbuf(E$Header + sf.index.base); /* get first word of category data */      if start = 0 then start = 256; /* no index data, so start at end of header */      i = 0;      do while start < 256;         start = start + 1 + shr(gbuf(E$Header + start) + 1,1); /* skip to next category */         i = i + 1;      end;      return (i); /* return the no. categories found */   end Count_Dir_Categories;   Store_File_Data: proc(dataptr,Entry) swapable; /* store file list record to data block */      dcl dataptr fixed array; /* pointer to data block */      dcl Entry   fixed; /* directory entry on optical disk */      dcl Record(L#Rec_Length - 1) fixed; /* file list record */      dcl (i,j)   fixed;      do i = 0 to L#Rec_Length - 1; /* zero-out record */         Record(i) = 0;      end;      do i = 0 to L#Name_Max - 1; /* entry name */         Record(L$Name + i) = gbuf(E$$Name + i);      end;      Record(L$LS_SecStart) = gbuf(E$LS_SecStart); /* Sector Start */      Record(L$MS_SecStart) = gbuf(E$MS_SecStart);      Record(L$LS_SecLen) = gbuf(E$LS_SecLen); /* Sector Length */      Record(L$MS_SecLen) = gbuf(E$MS_SecLen);      Record(L$LS_WordLen) = gbuf(E$LS_WordLen); /* Word Length */      Record(L$MS_WordLen) = gbuf(E$MS_WordLen);      Record(L$File_Type) = gbuf(E$File_Type); /* File Type */      Record(L$Dir_Entry) = Entry; /* Directory Entry on Optical */      i = gbuf(E$Header + sf.sample.rate);      if i = 0 then do; /* no sample rate - must calculate it from period index */         j = gbuf(E$Header + sf.period.index); /* get period index */         write("5") = 30000;         write("6") = 10;         write("324") = read("5");         write("7") = j; /* sampling rate * 10 = (30000 * 10) / period */         i = read("5") + (read("4") ige shr(j,1));      end;      Record(L$Sample_Rate) = i; /* store sample rate */      Record(L$Flags) = ( gbuf(E$Header + sf.file.data.type) or                      shl(gbuf(E$Header + sf.stereo),10) );      j = gbuf(E$Header + sf.id.field.bytes); /* get length of caption */      if j igt shl(L#Caption_Max,1) then j = shl(L#Caption_Max,1); /* limit size of caption */      Record(L$Caption) = j; /* store length of caption */      do i = 1 to shr(j + 1,1); /* volume caption */         Record(L$Caption + i) = gbuf(E$Header + sf.id.field.bytes + i); /* store caption characters */      end;      call WriteMBlock(dataptr,mem$data);      do i = 0 to L#Rec_Length - 1; /* write this data out to data block */         write(mdevi) = Record(i);      end;   end Store_File_Data;   Store_File_Categories: proc(fileptr,CatCount) returns (boolean) swapable; /* store file's list of categories */      dcl fileptr     fixed array; /* pointer to file tree node */      dcl CatCount    fixed; /* no. categories for this file */      dcl CatName(64) fixed; /* category name */      dcl catptr(ptr#len - 1)      fixed; /* pointer to category tree node */      dcl catdataptr(ptr#len - 1)  fixed; /* pointer to category data block */      dcl start       fixed; /* start of category in directory entry record */      dcl count       fixed; /* no. categories to process */      dcl len         fixed; /* length of category in characters */      dcl index       fixed; /* index into category list */      dcl (i,j,p,s)   fixed;      if CatCount = 0 then count = 1; /* this file has no categories */      else do;         start = gbuf(E$Header + sf.index.base); /* get first word of category data */         count = CatCount; /* process all categories */      end;      call WriteMPtrBlock(fileptr,mem$ptr,mem$used);      write(mdevi) = count; /* store the no. categories */      index = mem$data + l#rec_length; /* add category pointers after file list record data */      do i = 1 to count; /* loop over all categories for this file */         if CatCount = 0 then do; /* file has no category, so put in "uncategorized" category */            len = I$UnCategory(0);            do j = 0 to shr(len + 1,1); /* store uncategory name */               CatName(j) = I$UnCategory(j);            end;         end;         else do;            p = E$Header + start;            len = gbuf(p); /* get length of category */            do j = 0 to shr(len + 1,1); /* copy words of category name */               CatName(j) = gbuf(p + j);            end;         end;         if (len and "1") <> 0 /* odd category length */         then call pbyte(CatName,len,0); /* zero out MS 8 bits */         s = TreeInsert(CatName,CatTree,catptr); /* insert category name into tree */         if s = NoMoreRoom then return (false); /* no room in tree for category */         if s = NodeCreated then do; /* category not already in tree */            if not NewMBlock(catdataptr,ptr#len,true) /* create data block for this category */            then return (false);            call Attach_Data_Block(catptr,catdataptr); /* attach to category tree */            call WriteMBlock(catdataptr,mem$used);            write(mdevi) = 0; /* no files in this category yet */            TotalCats = TotalCats + 1; /* count the total no. categories in the tree */         end;         call WriteMPtrBlock(fileptr,mem$ptr,index); /* add category to file's list of categories */         write(mdevi) = catptr(0); write(mdevi) = catptr(1);         index = index + ptr#len; /* skip to next category list position */         start = start + 1 + shr(len + 1,1); /* skip to next category */      end;      return (true); /* all categories added */   end Store_File_Categories;   dcl (FirstEntry,LastEntry) fixed; /* entry range in buffer */   Get_Entry: proc(Entry,Level) returns (boolean) swapable; /* get buffered entry */      dcl Entry fixed; /* entry to get */      dcl Level fixed; /* level to read */      if (Entry ige FirstEntry) and (Entry ile LastEntry) then do; /* this entry is already in the buffer */         O$BufPtr = R$StkBase + shl(Entry - FirstEntry,1); /* adjust buffer pointer */         return (true); /* go to it */      end;      else if Entry ilt O$EntryCount then do; /* valid entry no., so read in buffer load */         FirstEntry = Entry; /* this will be the first entry */         LastEntry = FirstEntry + shr(R$StkMax,8 + 1) - 1; /* use all of stack area for buffer */         if LastEntry ige O$EntryCount /* cannot go beyond end of used directory area */         then LastEntry = (O$EntryCount - 1); /* limit size */         O$BufPtr = R$StkBase; /* reset buffer pointer to beginning of stack area */         S$SenseKey = ReadEntries(FirstEntry,LastEntry - FirstEntry + 1,Level); /* read a buffer load of entries */         if S$SenseKey = S$Good  then do; /* no error reading entries */           return (true); /* go for it */         end;      end;      else do; /* invalid entry number, so die */         S$SenseKey = S$Good;         c#status = e#fcb; /* illegal FCB */      end;      return (false); /* something bad happened */   end Get_Entry;   Add_File: proc(Entry) returns (boolean) swapable; /* add file to tree */      dcl Entry                fixed; /* directory entry number of file */      dcl treeptr(ptr#len - 1) fixed; /* pointer to tree block */      dcl dataptr(ptr#len - 1) fixed; /* pointer to data block */      dcl FileName(L#Name_Max) fixed; /* name of file to add */      dcl CatCount   fixed; /* no. categories for this file */      dcl BlockSize  fixed; /* required size of data block in words */      dcl (i,s)      fixed;      CatCount = Count_Dir_Categories; /* count the no. categories for this file */      if CatCount = 0 /* no categories for this file */      then BlockSize = l#rec_length + 1*ptr#len; /* space for file record and "uncategorized" category pointer */      else BlockSize = l#rec_length + CatCount*ptr#len; /* space for file record and all category pointers */      call Get_File_Name(E$$Name,L#Name_Max,FileName); /* get name of file */      if debug then do; print 'Adding File ',string(FileName),; end;      s = TreeInsert(FileName,FileTree,treeptr); /* try to insert name into file tree */      if s = NoMoreRoom then return (false); /* no room in tree for file */      if s = NodeCreated then do; /* file added - create new data block */         if not NewMBlock(dataptr,BlockSize,true) /* create data block with room for category pointers */         then return (false); /* no room for new data block */         call Attach_Data_Block(treeptr,dataptr); /*  attach to tree */         TotalFiles = TotalFiles + 1; /* count the no. files in the file tree */         if debug then do; print ', Node Created'; end;      end;      else do; /* file already in tree - update existing data block */         i = GetMBlockSize(treeptr); /* get size of block */         call WriteMBlock(treeptr,mem$used);         write(mdevi) = i; /* store no. words used (in case file was previously deleted) */         call ReadMBlock(treeptr,mem$ptr);         dataptr(0) = read(mdevi); dataptr(1) = read(mdevi); /* get data block for this file */         if GetMBlockSize(dataptr) ilt BlockSize then do; /* not enough room in data block */            call DisposeMBlock(dataptr); /* get rid of this block */            if not NewMBlock(dataptr,BlockSize,true) /* create new data block with more room */            then return (false); /* no room for new data block */            call Attach_Data_Block(treeptr,dataptr); /* attach to tree */         end;         if debug then do; print ', Node Replaced'; end;      end;      call Store_File_Data(dataptr,Entry); /* store file information in data block */      if not Store_File_Categories(treeptr,CatCount) /* store categories in data block */      then return (false);      return (true); /* record added successfully */   end Add_File;   Delete_File: proc returns (boolean) swapable; /* delete file from tree */      dcl treeptr(ptr#len - 1) fixed; /* pointer to tree block */      dcl dataptr(ptr#len - 1) fixed; /* pointer to data block */      dcl FileName(L#Name_Max) fixed; /* name of file to add */      dcl s fixed;      call Get_File_Name(E$OldName,L#Name_Max,FileName); /* get name of file to delete */      if debug then do; print 'Deleting File ',string(FileName),',',; end;      s = TreeInsert(FileName,FileTree,treeptr); /* try to insert name into file tree */      if s = NoMoreRoom then return (false); /* no room in tree for file */      if s = NodeCreated then do; /* file added - create new data block */         if not NewMBlock(dataptr,1,true) /* create dummy data block */         then return (false); /* no room for new data block */         call Attach_Data_Block(treeptr,dataptr); /*  attach to tree */         TotalFiles = TotalFiles + 1; /* count the no. files in the file tree */         if debug then do; print ', Node Created, ',; end;      end;      call WriteMBlock(treeptr,mem$used);      write(mdevi) = -1; /* set flag to show that file has been deleted */      return (true); /* file was deleted from tree */   end Delete_File;   Get_Updates: proc(Level) returns (boolean) swapable; /* get updated directory entries off optical disk */      dcl Level		fixed;	/* level to use */      dcl Entry		fixed;	/* entry currently being processed */      dcl EntryType	fixed;	/* entry type */      dcl OptBufPtr	fixed;	/* optical disk buffer pointer */      dcl NoError		boolean;	/* TRUE if no error has occurred */      dcl UpdateTime	fixed;	/* last update time */      dcl i				fixed;      if debug then do; print 'Adding entries ',I$EntryCount,' to ',O$EntryCount - 1,'...'; print; end;      OptBufPtr = O$BufPtr; /* store current buffer pointer so it can be moved around */      FirstEntry = -1; /* nothing in buffer now */      LastEntry = -1;      UpdateTime = real.milliseconds; /* show initial update message */      NoError = true; /* assume no error */      Entry = I$EntryCount; /* start at first new entry */      do while (Entry ilt O$EntryCount) and (NoError); /* loop over new entries, quit on error */			timeshare_with_host();			         if debug then do; print; print 'Entry  ',Entry,': ',; end;         if Get_Entry(Entry,Level) then do; /* entry found */            EntryType = gbuf(E$$Type); /* get entry type */            if EntryType = E#Dir_Entry then do; /* this is a directory entry */               NoError = Add_File(Entry); /* add file to tree */            end;            else if EntryType = E#Delete_Entry then do; /* delete entry */               NoError = Delete_File; /* delete file from tree */               if debug then do; print ' Done'; end;            end;            else if EntryType = E#Rename_Entry then do; /* rename entry */               i = 0;               do while (i ilt E#Name_Max) and (gbuf(E$$Name + i) = gbuf(E$OldName + i)); /* see if new name is same as old name */                  i = i + 1;               end;               if debug then do;                  print 'Renaming File with ',;                  if i = E#Name_Max then print 'Same Name: ',; else print 'Different Name: ',;               end;               if i = E#Name_Max /* new name same as old name */               then NoError = true; /* don't go to trouble of deleting */               else NoError = Delete_File; /* delete old name from tree */               if NoError /* no error deleting */               then NoError = Add_File(Entry); /* add new file */            end;         end;         else NoError = false; /* an error occurred */         Entry = Entry + 1; /* go to next entry */         if (real.milliseconds >= UpdateTime) and (not debug) then do; /* time to display update message */            call Display_Update_Status(2,Entry - I$EntryCount,O$EntryCount - I$EntryCount + 1); /* display message */            UpdateTime = real.milliseconds + UpdateInterval; /* next update time */         end;      end;      if debug then do; print; print 'All entries added'; end;      O$BufPtr = OptBufPtr; /* restore buffer pointer to its original position */      if (not debug) then      call Display_Update_Status(2,Entry - I$EntryCount,O$EntryCount - I$EntryCount + 1); /* display status message */		#if (debug)         print 'Enter 1 to display trees, 0 to continue',;         // input i;         if i = 0 then return (NoError);         print;         print 'File Tree:';         call Print_Tree(FileTree,true);         print;         print 'Category Tree:';         call Print_Tree(CatTree,false);         //input i;      #endif      return (NoError); /* returns TRUE if updates added successfully */   end Get_Updates;   Initialize_Header: proc(Level,DirEntryCount) swapable; /* intialize header for index file */      dcl Level         fixed; /* level to read from */      dcl DirEntryCount fixed; /* no. directory entries on optical disk */      call ReadHeader(Level); /* read header into buffer */      call pbuf(H$LS_DirStart,shr(H#Rec_Length,8)); /* start of file list index */      call pbuf(H$MS_DirStart,0);      call pbuf(H$LS_DirLen,shr(H#Index_Length,8)); /* length of file list index */      call pbuf(H$MS_DirLen,0);      call pbuf(H$EntryCount,DirEntryCount); /* no. directory entries on optical disk */      call pbuf(H$Stride,0); /* no stride yet */   end Initialize_Header;   Save_Header: proc(OutFile) swapable; /* save index file header to disk */      dcl OutFile       file;  /* output file */      dcl (i,j)         fixed;      call Seek(OutFile,0,3); /* seek to first sector of header */      do i = 0 to H#Rec_Length - 1; /* write out header */         j = gbuf(i);         call PutW(j,OutFile);      end;   end Save_Header;   dcl FileListRec  fixed; /* current file list record being processed */   dcl FileListMax  fixed; /* max no. file list records in file list */   Save_File_List: proc(InFile,OutFile) returns (boolean) swapable; /* save file list to disk */      dcl InFile        file;  /* input file */      dcl OutFile       file;  /* output file */      dcl More_Nodes    boolean; /* TRUE if there are more nodes in tree to process */      dcl More_Files    boolean; /* TRUE if there are more file list records to process */      dcl ValidNode     boolean; /* TRUE if node has not been deleted */      dcl FileCount     fixed; /* no. file list records output to file */      dcl fileptr(ptr#len - 1) fixed; /* pointer to file's tree block */      dcl ListName(L#Name_Max) fixed; /* name of file in file list */      dcl ListRecord(L#Rec_Length - 1) fixed; /* informaton from file list */      dcl UpdateTime    fixed; /* last update time */      dcl (MSW,LSW)     fixed;      dcl (i,c,count)   fixed;      Get_Next_File: proc(F,Name,Record) returns (boolean); /* get next file list record */         dcl F          file; /* input file */         dcl Name       fixed array; /* name of file */         dcl Record     fixed array; /* record space to use */         dcl (i,c)      fixed;         if F <> NullF then do; /* there is an input file */            if FileListRec ilt FileListMax then do; /* more in file to get */               call FRead(Record,shl(L#Rec_Length,1),1,F); /* get record */               FileListRec = FileListRec + 1; /* got another record */               Name(0) = 0; i = 0; c = -1; /* get the name of the file */               do while (i ilt L#Name_Max) and (c <> 0); /* loop over characters of file name */                  c = Record(L$Name + i); /* get word of file name */                  if c <> 0 then do; /* there's a character in there somewhere */                     Name(1 + i) = c; /* store character(s) */                     Name(0) = Name(0) + 1 + (shr(c,8) <> 0); /* count the no. characters */                  end;                  i = i + 1; /* next word */               end;               return (true); /* got next file */            end;         end;         return (false); /* no more files to get */      end Get_Next_File;      Update_Categories: proc(DeleteIndex,IndexLimit,IndexAdjust) returns (boolean); /* update the file pointers in all categories */         dcl DeleteIndex fixed; /* delete every occurrence of this file index */         dcl IndexLimit  fixed; /* adjust everything >= this limit */         dcl IndexAdjust fixed; /* adjust factor (signed!) */         dcl treeptr(ptr#len - 1) fixed; /* pointer to tree block */         dcl dataptr(ptr#len - 1) fixed; /* pointer to data block */         dcl More_Nodes  boolean; /* TRUE if there are more nodes to process */         dcl FileIndex   fixed; /* index of file in file list index */         dcl NumFiles    fixed; /* no. files in category */         dcl count       fixed; /* no. elements in list */         dcl (i,j)       fixed;         if debug then do; print 'Updating categories'; end;         if debug then do; print 'DeleteIndex, IndexLimit, IndexAdjust: ', DeleteIndex, IndexLimit, IndexAdjust; end;         More_Nodes = TreeTraverse(CatTree,TRUE,treeptr); /* get first node */         if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */         then return (false); /* die */         do while More_Nodes; /* loop until the entire tree is traversed */				timeshare_with_host();            call ReadMBlock(treeptr,mem$ptr);            dataptr(0) = read(mdevi); dataptr(1) = read(mdevi); /* get pointer to data block */            if (dataptr(0) = MNullPtr(0)) and (dataptr(1) = MNullPtr(1)) /* no data block for this tree node */            then NumFiles = 0; /* so there are no files in this category */            else do;               call ReadMBlock(dataptr,mem$used);               NumFiles = read(mdevi); /* get the no. files in this category */            end;            count = 0;            do while count ilt NumFiles; /* loop over all file indexes in category */					timeshare_with_host();               call ReadMBlock(dataptr,mem$data + count);               FileIndex = read(mdevi); /* get file index */               if FileIndex = DeleteIndex then do; /* delete this file from category */                  call CopyMBlock(dataptr,mem$data + count + 1, /* shuffle data over this index */                                  dataptr,mem$data + count,                                  NumFiles - count - 1);                  NumFiles = NumFiles - 1; /* one less file index in list */                  call WriteMBlock(dataptr,mem$used);                  write(mdevi) = NumFiles; /* store the new no. files in the list */               end;               else do; /* see if limit needs adjusting */                  if FileIndex ige IndexLimit then do; /* update this pointer */                     FileIndex = FileIndex + IndexAdjust; /* adjust it up or down */                     call WriteMBlock(dataptr,mem$data + count);                     write(mdevi) = FileIndex; /* store updated file index */                  end;                  count = count + 1; /* go to next file index in list */               end;            end;            More_Nodes = TreeTraverse(CatTree,FALSE,treeptr); /* get next node in tree */            if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */            then return (false); /* die */         end; /* while traversing tree */         return (true);      end Update_Categories;      Insert_Index: proc(treeptr,dataptr,NumFiles,FileListIndex,InsertPt) returns (boolean); /* place file list index in proper place in category's list of files */         dcl treeptr             fixed array; /* pointer to category's tree block */         dcl dataptr             fixed array; /* pointer to category's data block */         dcl NumFiles            fixed; /* no. files in category's list of files */         dcl FileListIndex       fixed; /* index of file in file list */         dcl InsertPt            fixed; /* point to insert file in category's list of files */         dcl CurrentSize         fixed; /* current size of data block */         dcl NewSize             fixed; /* new size required for data block */         dcl newptr(ptr#len - 1) fixed; /* pointer to new data block */         dcl (i,p)               fixed;         CurrentSize = GetMBlockSize(dataptr); /* get current size of data block */         NewSize = NumFiles + 1; /* calculate new size of data block */         if NewSize igt CurrentSize then do; /* not enough room in current data block - make new one */            if not NewMBlock(newptr,NewSize,true) /* create new data block */            then return (false); /* no more room for new block */            call ReadMBlock(treeptr,mem$ptr);            dataptr(0) = read(mdevi); dataptr(1) = read(mdevi); /* get data pointer in case it moved */            call CopyMBlock(dataptr,mem$data, /* copy over data before the insert point */                            newptr, mem$data,                            InsertPt);         end;         else do; /* there is enough room in current data block */            newptr(0) = dataptr(0); newptr(1) = dataptr(1); /* use it */         end;         call CopyMBlock(dataptr,mem$data + InsertPt, /* move data after insert point to make room for new index */                         newptr, mem$data + InsertPt + 1,                         NumFiles - InsertPt);         call WriteMBlock(newptr,mem$data + InsertPt);         write(mdevi) = FileListIndex; /* write new file list index */         if NewSize igt CurrentSize then do; /* a new block was created */            call DisposeMBlock(dataptr); /* dispose of old data block */            call Attach_Data_Block(treeptr,newptr); /* attach new data block to tree */         end;         call WriteMBlock(newptr,mem$used);         write(mdevi) = NumFiles + 1; /* another file added to list */         return (true); /* index added */      end Insert_Index;      Add_File_To_Categories: proc(filetreeptr,FileListIndex,F) returns (boolean); /* add this file index to all of it's categories */         dcl filetreeptr   fixed array; /* pointer to file's tree block */         dcl FileListIndex fixed; /* index of file in file list */         dcl F             file;  /* input file */         dcl CatCount      fixed; /* no. categories in file's list of categories */         dcl cattreeptr(ptr#len - 1)  fixed; /* pointer to category's tree block */         dcl catdataptr(ptr#len - 1)  fixed; /* pointer to category's data block */         dcl filedataptr(ptr#len - 1) fixed; /* pointer to file's data block */         dcl FileCount     fixed; /* no. files in category's list of files */         dcl InsertPt      fixed; /* insert point in category's list of files */         dcl index         fixed; /* index of a category in file's list of categories */         dcl i             fixed;         if debug then do; print 'Adding file to categories'; end;         call ReadMBlock(filetreeptr,mem$ptr);         filedataptr(0) = read(mdevi); filedataptr(1) = read(mdevi); /* get pointer to file's data block */         if (filedataptr(0) = MNullPtr(0)) and (filedataptr(1) = MNullPtr(1)) /* no data block */         then CatCount = 0; /* this file has no categories - should never happen, right? */         else do; /* get no. categories */            call ReadMBlock(filedataptr,mem$used);            CatCount = read(mdevi); /* get the no. categories in file's list of categories */            index = mem$data + l#rec_length; /* index of first category pointer */         end;         do i = 0 to CatCount - 1; /* loop over categories */            /* don't use filedataptr instead following read */            /* - the heap may have been compacted, leaving  */            /* filedataptr a dangling ptr! */            call ReadMPtrBlock(filetreeptr,mem$ptr,index);              cattreeptr(0) = read(mdevi); cattreeptr(1) = read(mdevi); /* get pointer to category's tree block */            call ReadMBlock(cattreeptr,mem$ptr);            catdataptr(0) = read(mdevi); catdataptr(1) = read(mdevi); /* get pointer to category's data block */            call ReadMBlock(catdataptr,mem$used);            FileCount = read(mdevi); /* get the no. files in category's list of files */            if F = NullF then do; /* no input file - must be creating index file from scratch */               InsertPt = FileCount; /* add new file at end of list */            end;            else do; /* using file list, so find where to put this file */               InsertPt = 0; /* start at beginning of list */               call ReadMBlock(catdataptr,mem$data);               do while (InsertPt ilt FileCount) and (read(mdevi) ilt FileListIndex); /* loop until insert point is found */                  InsertPt = InsertPt + 1;               end;            end;            if not Insert_Index(cattreeptr,catdataptr,FileCount,FileListIndex,InsertPt)            then return(false); /* not enough room to insert index */            index = index + ptr#len; /* go to next category pointer */         end; /* looping over categories */         return (true); /* file added */      end Add_File_To_Categories;      Save_Data_Block: proc(treeptr,index,F); /* save data block to disk */         dcl treeptr fixed array; /* pointer to tree node */         dcl index   fixed; /* index of file in file list */         dcl F       file; /* file to use */         dcl Record(L#Rec_Length - 1) fixed; /* room for file list record */         dcl i       fixed;         call ReadMPtrBlock(treeptr,mem$ptr,mem$data);         do i = 0 to L#Rec_Length - 1; /* read file information from data block */            Record(i) = read(mdevi);         end;         call FWrite(Record,shl(L#Rec_Length,1),1,F); /* write out record to index file */      end Save_Data_Block;      /* Main procedure */      /* calculate start of file list area and seek there */      MSW = gbuf(H$MS_DirStart) + gbuf(H$MS_DirLen); /* file list starts right after file list index */      LSW = gbuf(H$LS_DirStart) + gbuf(H$LS_DirLen);      if LSW ilt gbuf(H$LS_DirStart) then MSW = MSW + 1;      call pbuf(H$LS_DataStart,LSW); /* store start of file list */      call pbuf(H$MS_DataStart,MSW);      call Seek(OutFile,LSW,3); /* seek to starting point */      /* save all records in file list to disk, updating the category list */      More_Nodes = TreeTraverse(FileTree,TRUE,fileptr); /* get first node in tree */      if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */      then return (false); /* die */      FileListRec = 0; /* start at first record in file list */      FileListMax = I$FileCount; /* total no. records in file list */      More_Files = Get_Next_File(Infile,ListName,ListRecord); /* get first file list record */      if More_Files then TotalFiles = TotalFiles + I$FileCount; /* add the files already in the file list */      UpdateTime = real.milliseconds; /* show initial update message */      FileCount = 0; /* no records saved yet */      count = 0; /* no files processed yet */      do while (More_Nodes) or (More_Files); /* loop until both the tree and the file list have been completely traversed */			timeshare_with_host();         if (More_Nodes) and (More_Files) /* both lists have not been completely traversed */         then c = CompareBlock(fileptr,tree$key,ListName); /* compare the file names */         else if (More_Nodes) and (not More_Files) /* file list has been traversed, so add everything else in tree */         then c = -1;         else if (not More_Nodes) and (More_Files) /* tree has been traversed, so copy everything else in file list */         then c = 1;         if debug then do; print 'Mode_Nodes, More_Files, c = ',More_Nodes,More_Files,c; end;         if c < 0 then do; /* file in tree is not in file list, so add it to file list */            call ReadMBlock(fileptr,mem$used);            ValidNode = (read(mdevi) <> -1); /* TRUE if this node has not been deleted */            if ValidNode then do; /* add this entry */               if Infile <> NullF then do; /* make room for new node if file list present */                  if not Update_Categories(-1,FileCount,+1) /* could not update them */                  then return (false);               end;               if not Add_File_To_Categories(fileptr,FileCount,Infile) /* add this file index to all of it's categories */               then return (false);               if debug then do; print 'Saving data block'; end;               call Save_Data_Block(fileptr,FileCount,OutFile); /* save node's data block to index file */               FileCount = FileCount + 1; /* another record saved */            end;            More_Nodes = TreeTraverse(FileTree,FALSE,fileptr); /* get next node from tree */            if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */            then return (false); /* die */         end;         else if c = 0 then do; /* file in tree is the same as the one in the file list, so deal with update */            call ReadMBlock(fileptr,mem$used);            ValidNode = (read(mdevi) <> -1); /* TRUE if this node has not been deleted */            if ValidNode then do; /* add this entry */               if debug then do; print 'Replacing file'; end;               if not Update_Categories(FileCount,-1,0) /* delete all current references to this file */               then return (false); /* could not update for some reason */               if not Add_File_To_Categories(fileptr,FileCount,Infile) /* add this file index to all of it's categories */               then return (false); /* could not add file to categories */               call Save_Data_Block(fileptr,FileCount,OutFile); /* save node's data block to index file */               FileCount = FileCount + 1; /* another record saved */            end;            else do; /* delete this entry */               if not Update_Categories(FileCount,FileCount,-1) /* delete all current references to this file and shift pointers up */               then return (false); /* could not update */            end;            More_Nodes = TreeTraverse(FileTree,FALSE,fileptr); /* get next node from tree */            if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */            then return (false); /* die */            More_Files = Get_Next_File(Infile,ListName,ListRecord); /* get next file */         end;         else do; /* file in file list is not in tree, so just copy to output file */            call FWrite(ListRecord,shl(L#Rec_Length,1),1,OutFile); /* save record to file list */            FileCount = FileCount + 1; /* another record saved */            More_Files = Get_Next_File(Infile,ListName,ListRecord); /* get next file */         end;         count = count + 1; /* another file processed */         if debug then do; print 'FileCount = ',FileCount; end;         if (real.milliseconds >= UpdateTime) and (not debug) then do; /* time to display update message */            call Display_Update_Status(3,count,TotalFiles);            UpdateTime = real.milliseconds + UpdateInterval; /* next update time */         end;      end;      if (not debug) then      call Display_Update_Status(3,count,TotalFiles); /* display final update status */      /* calculate file list parameters */      write("5") = FileCount; /* calculate the no. words used */      write("6") = L#Rec_Length; /* words used = no. records * record length */      write("324") = read("5");      i = Words_to_Secs(read("4"),read("5")); /* convert to sectors */      /* update file list fields in header */      call pbuf(H$LS_DataLen,i); /* sector length of file list */      call pbuf(H$MS_DataLen,0);      call pbuf(H$FileCount,FileCount); /* no. records in file list */      if debug then do;         print 'Enter 1 to display trees, 0 to continue',;         //input i;         if i = 0 then return (true);         print;         print 'Category Tree:';         call Print_Tree(CatTree,false);         //input i;      end;      return (true); /* file list saved */   end Save_File_List;   Save_Category_List: proc(OutFile) returns (boolean) swapable; /* save category list to disk */      dcl OutFile     file;  /* output file */      dcl treeptr(ptr#len - 1) fixed; /* pointer to tree block */      dcl dataptr(ptr#len - 1) fixed; /* pointer to data block */      dcl More_Nodes  boolean; /* TRUE if there are more nodes to print */      dcl RecLen      fixed; /* length of category record */      dcl NameLen     fixed; /* no. characters in category name */      dcl NumFiles    fixed; /* no. files in this category */      dcl CatCount    fixed; /* no. category list records output to file */      dcl (MSW,LSW)   fixed; /* no. words written out */      dcl Names(H#NameLineMax) fixed; /* array to store names/line values */      dcl UpdateTime   fixed; /* last update time */      dcl (i,count)   fixed;      /* calculate start of category list area and seek there */      MSW = gbuf(H$MS_DataStart) + gbuf(H$MS_DataLen); /* category list starts right after file list */      LSW = gbuf(H$LS_DataStart) + gbuf(H$LS_DataLen);      if LSW ilt gbuf(H$LS_DataStart) then MSW = MSW + 1;      call pbuf(H$LS_CatStart,LSW); /* store start of category list */      call pbuf(H$MS_CatStart,MSW);      call Seek(OutFile,LSW,3); /* seek to first sector of category list */      /* save all category records to disk */      do i = 1 to H#NameLineMax;         Names(i) = 0; /* no lines used yet */      end;      More_Nodes = TreeTraverse(CatTree,TRUE,treeptr); /* get first node */      if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */      then return (false); /* die */      UpdateTime = real.milliseconds; /* show initial update message */      CatCount = 0; /* no category records saved yet */      count = 0; /* no categories processed yet */      MSW = 0; LSW = 0; /* no words saved yet */      do while More_Nodes;			timeshare_with_host();         call ReadMBlock(treeptr,mem$ptr);         dataptr(0) = read(mdevi); dataptr(1) = read(mdevi); /* get pointer to data block */         call ReadMBlock(dataptr,mem$used);         NumFiles = read(mdevi); /* get the no. files in the list */         if NumFiles <> 0 then do; /* not a null category */            call ReadMBlock(treeptr,tree$key);            NameLen = read(mdevi); /* get no. characters in category name */            RecLen = shr(NameLen + 1,1) + NumFiles + 4; /* calculate no. words category record */            /* Write Category Record to disk */            call PutW(RecLen,OutFile); /* store forward pointer */            call PutW(NameLen,OutFile); /* store length of category name */            do i = 1 to shr(NameLen + 1,1); /* store category name */               call ReadMBlock(treeptr,tree$key + i);               call PutW(read(mdevi),OutFile);            end;            call PutW(NumFiles,OutFile); /* store no. file pointers */            do i = 0 to NumFiles - 1; /* write out file pointers */               call ReadMBlock(dataptr,mem$data + i);               call PutW(read(mdevi),OutFile); /* store updated index */            end;            call PutW(RecLen,OutFile); /* store back pointer */            CatCount = CatCount + 1; /* count the no. records output */            LSW = LSW + RecLen; /* count the no. words output */            if LSW ilt RecLen then MSW = MSW + 1;            do i = 1 to H#NameLineMax; /* add on the lines used by this category for all names/line values */               write("5") = NumFiles;               write("7") = i; /* divide no. files by no. files/line */               Names(i) = Names(i) + read("5") + (read("4") <> 0); /* store no. lines required */            end;         end;         More_Nodes = TreeTraverse(CatTree,FALSE,treeptr); /* get next node in tree */         if (not More_Nodes) and (S$SenseKey = S$Good) and (c#status = e#stack_full) /* blew the stack */         then return (false); /* die */         count = count + 1; /* another category processed */         if (real.milliseconds >= UpdateTime) and (not debug) then do; /* time to display update message */            call Display_Update_Status(4,count,TotalCats); /* display status */            UpdateTime = real.milliseconds + UpdateInterval; /* next update time */         end;      end;      if (not debug) then      call Display_Update_Status(4,count,TotalCats); /* display status */      /* calculate category list parameters */      i = Words_To_Secs(MSW,LSW); /* convert no. words to sectors */      /* update category list fields in header */      call pbuf(H$LS_CatLen,i); /* sector length of category list */      call pbuf(H$MS_CatLen,0);      call pbuf(H$CatCount,CatCount); /* no. category records in category list */      do i = 0 to H#NameLineMax - 1; /* store no. lines required for file names in category list */         call pbuf(H$CatLines + i,Names(i + 1));      end;      return (true); /* category list saved */   end Save_Category_List;   Save_File_List_Index: proc(Infile,OutFile) swapable; /* create file list index */      dcl InFile        file;  /* input file */      dcl OutFile       file;  /* output file */      dcl IndexEntries  fixed; /* no. entries in file list index */      dcl Stride        fixed; /* stride of file list index (no. records skipped between each entry) */      dcl Increment     fixed; /* no. bytes needed to skip to the next record */      dcl FileCount     fixed; /* no. files in file list */      dcl (i,j,k,count) fixed;      write("5") = gbuf(H$LS_DirLen); /* get no. sectors in file list index */      write("6") = 256; /* no. words = no. sectors * 256 */      write("324") = read("5");      write("7") = L#Name_Max; /* divide by the word length of the file names */      IndexEntries = read("5"); /* store the no. entries in the file list index */      if debug then do;          print 'File List Index starts at ',gbuf(H$LS_DirStart),', contains ',IndexEntries,' entries';         print 'File List starts at ',gbuf(H$LS_DataStart),', contains ',gbuf(H$FileCount),' entries';      end;      write("5") = gbuf(H$FileCount); /* calculate file list index stride */      write("7") = IndexEntries; /* index stride = no. records / no. file list index entries */      Stride = read("5"); /* store stride */      i = read("4"); /* store remainder */      if Stride = 0 then Stride = 1; /* FileCount < IndexEntries, so index every file */      else if i ige shr(IndexEntries,1) then Stride = Stride + 1; /* round up */      if debug then do;          print 'Stride = ',Stride;         print 'Here we go...';      end;      call Seek(Infile,gbuf(H$LS_DataStart),3); /* seek to first sector of file list */      call Seek(OutFile,gbuf(H$LS_DirStart),3); /* seek to first sector of file list index */      Increment = shl(Stride * L#Rec_Length - L#Name_Max,1); /* no. bytes to skip ahead each time */      FileCount = gbuf(H$FileCount); /* get the no. files in the file list */      count = 0; /* nothing in file list index yet */      i = 0;      do while i ilt FileCount; /* loop over file list records */			timeshare_with_host();         if count ilt IndexEntries then do;            do j = 1 to L#Name_Max; /* copy name to file list index */               k = GetW(Infile); /* get word from file list */               call PutW(k,OutFile); /* store in file list index */            end;            call Seek(Infile,Increment,1); /* seek to next record */            count = count + 1; /* count no. items in file list index */         end;         i = i + Stride; /* skip to next file */      end;      if debug then do; print count,' entries saved to index file '; end;      do i = (count + 1) to IndexEntries; /* pad remaining entries */         do j = 1 to L#Name_Max; /* set all bits in name, so nothing will be greater than it */            call PutW(-1,OutFile);         end;      end;      call pbuf(H$Stride,Stride); /* store stride value */   end Save_File_List_Index;   Update_Index_File: proc(TreeName,Level) returns (boolean) public swapable; /* save index to disk */      dcl TreeName      fixed array; /* array space for working treename 	*/      dcl Level         fixed;		 /* optical disk level to use */      		dcl TempName(15)  fixed;       /* array space for temp name 			*/		dcl DirName (15)  fixed;		 /* array space for dir name 				*/		dcl OrigName(15)  fixed;		 /* copy of original name					*/      dcl IndexPresent  boolean;		 /* TRUE if index file already present */		dcl Found			boolean;		dcl Status			fixed;      dcl (i,j,count)   fixed;      Open_Index_File: proc(Name, IndexPath) returns (boolean); /* open index file */         dcl Name      fixed array; /* treename of index file */         dcl IndexPath fixed array; /* the path to .INDEX */			if (Read_Catalog(IndexPath,1)) and (FindMax) then do; /* read index subcat and find largest block */				// Limit index file to 32 megs to avoid FileI IO bugs with index files greater than				// 32 megs in size								if ((F#MS_Length != 0) || (F#LS_Length IGT -256))					{F#MS_Length = 0; F#LS_Length = -256;}					            if (F#LS_Length and "HFF") = 0  then do; /* sector length is a multiple of 256 */               if F#LS_Length = 0 then F#MS_Length = F#MS_Length - 1;               F#LS_Length = F#LS_Length - 1; /* subtract one so FILEIO doesn't barf on this file */            end;            if Replace(Name, t#index, F#MS_Length, F#LS_Length, shl(F#LS_Length,8), 1) then do; /* room for this file */               if CatList <> NullF then CatList = Close_File(CatList); /* close up file variable */               CatList = Open_File(Name,'w',CatListBuf,CatListMed,CatListLen); /* try to open this file for output */               if CatList <> NullF then do; /* file opened successfully */                  return (TRUE); /* output file is ready to go */               end;            end;         end;         return (false); /* output file not ready to go */      end Open_Index_File;      Close_Index_File: proc(Name, OldIndex, OrigName) returns (boolean); /* close index file */         dcl Name      fixed array;			/* treename of index file */         dcl OldIndex  boolean;				/* TRUE if old index file was around */			dcl OrigName  fixed array;			/* treename of original index file */			         dcl FileName(F#Name_Len) fixed;	/* space for file name */         dcl (MSW,LSW) fixed;         dcl i         fixed;         FileList = Close_File(FileList); /* close input file */         CatList = Close_File(CatList); /* close output file */         MSW = gbuf(H$MS_CatStart) + gbuf(H$MS_CatLen); /* find no. sectors used in index file */         LSW = gbuf(H$LS_CatStart) + gbuf(H$LS_CatLen);         if LSW ilt gbuf(H$LS_CatStart) then MSW = MSW + 1;         if (LSW and "HFF") = 0  then do; /* sector length is a multiple of 256 */            LSW = LSW + 1; /* add one so FILEIO doesn't barf on this file */            if LSW = 0 then MSW = MSW + 1;         end;         if truncate(Name, MSW,LSW,shl(LSW,8),1) then do; /* truncate index file */            if not OldIndex then do; /* no old index file */               return (TRUE); /* index file closed successfully */            end;            else do; /* get rid of old index file */               if Delete(OrigName, 1) then do; /* delete old index file */                  do i = 0 to F#Name_Len; /* get name for index file */                     FileName(i) = O$Volume_Name(i);                  end;                  if FileName(0) > shl(F#Name_Len,1) then FileName(0) = shl(F#Name_Len,1); /* truncate name, if neccessary */                  if Rename(Name, FileName, 1) then do; /* rename new index file to be old index file */                     return (TRUE); /* successfully closed and renamed */                  end;               end;             end;         end;         return (FALSE); /* could not close index file */      end Close_Index_File;      /* main procedure */      if not Check_Optical(Level) then do; /* optical not open and ready to go */         if not ((S$SenseKey = S$Good)            and ((c#status = e#no_index) or (c#status = e#not_uptodate)) ) /* continue if there is no index file or it is not up to date */         then return (FALSE); /* some other problem, so die */      end;      if not (TreeInit(FileTree) and TreeInit(CatTree)) /* could not initialize trees */      then return (FALSE);      call StackInit; /* initialize stack */      TotalFiles = 0; /* no files in tree yet */      TotalCats = 0; /* no categories in tree yet */		Get_Index_Name(O$Volume_Name, TreeName); 					/* get treename of index file		*/		Get_Index_Name(O$Volume_Name, OrigName);					/* in two places...					*/		Get_Index_Directory_name(DirName);							/* and the directory name...		*/				Found = locate (TreeName, 1);								   /* see if exists in :.INDEX 		*/				if (Found == false)												/* not there: check :.INDEX1		*/		{			Status = c#status;											/* save error about .INDEX			*/						Get_Index1_Name(O$Volume_Name, TreeName); 			/* get treename of index1 file	*/			Get_Index1_Name(O$Volume_Name, OrigName);			Get_Index1_Directory_name(DirName);						Found = locate (TreeName, 1);								/* if that exists						*/						if (found == false)											/* not there neither					*/			{				if ((c#status == e#no_file)							/* if .INDEX1 exists but specific .index file is missing */				&&  (Status   == e#no_path))							/* and .INDEX subcatalog is missing								*/					;															/* then leave set up to use .INDEX1								*/					else															/* else revert to .INDEX for normal use						*/				{																		Get_Index_Name(O$Volume_Name, TreeName); 		/* get treename of index file		*/					Get_Index_Name(O$Volume_Name, OrigName);		/* in two places...					*/					Get_Index_Directory_name(DirName);				/* and the directory name...		*/				}			}		}						c#status   = 0;													/* toss bogus stati from index	*/		S$SenseKey = 0;													/* file search							*/     			/* change working name of .index file to a temp name (with _ in it) while we				*/		/* construct the new index.  That way it won't be used if we bomb during the				*/		/* update...																									*/				IndexPresent = (FileList <> NullF);							/* TRUE if index file already exists (hopefully is the one we just located!!!) */      if IndexPresent then do;										/* index file already exists		*/         if I$EntryCount = O$EntryCount then return (TRUE); /* nothing has changed			*/         if I$CatCount <> 0 then do;								/* need to read in current categories */            if not Get_Category_List(FileList)					/* read category list out of index file and into a balanced binary tree */            then return (false); /* could not do it for some reason */         end;         call Seek(FileList,I$FileStart,3); /* seek to first sector of file list */         call pbyte(TreeName, TreeName(0) - 1, a.score); /* change last character to underscore */      end;      else I$EntryCount = 0; /* no index file at all */      if Get_Updates(Level) then do; /* get new directory entries from optical disk and put into tree */         if Open_Index_File(TreeName, DirName) then do; /* index file opened for output */            call Initialize_Header(Level,O$EntryCount); /* set up header */            if not Save_File_List(FileList,CatList) /* save and update file list */            then return (false);            if not Save_Category_List(CatList) /* save category list */            then return (false);            call FFlush(CatList); /* flush output buffer to disk */            if FileList <> NullF then FileList = Close_File(FileList); /* close up file variable */            FileList = Open_File(TreeName,'r',FileListBuf,FileListMed,FileListLen); /* try to open output file for input */            if FileList <> NullF then do; /* file opened successfully */               call Save_File_List_Index(FileList,CatList); /* save file list index */               call Save_Header(CatList); /* save updated header */               if Close_Index_File(TreeName,IndexPresent, OrigName) then do; /* file closed successfully */                  if Open_Optical(TreeName,Level) then do; /* open volume again to set up for new index file */                     /* Set bit to create a protocol event when the */                     /* index file has been updated:                */                     new.poly.contents = new.poly.contents \ 8;                     return (TRUE); /* success!!!! */                  end;               end;            end;         end; /* index file opened */         i = c#status; /* store catalog error status */         j = S$SenseKey; /* store sense key status */         call Get_Index_Name(O$Volume_Name,TempName);		/* get treename of index file */         call pbyte(TempName,TempName(0) - 1,a.score);	/* set last character to underscore */         call Delete(TempName,1);								/* delete temporary file if it is still around */         call Get_Index1_Name(O$Volume_Name,TempName);	/* get treename of index file */         call pbyte(TempName,TempName(0) - 1,a.score);	/* set last character to underscore */         call Delete(TempName,1);								/* delete temporary file if it is still around */         c#status = i; /* restore original error status */         S$SenseKey = j;      end; /* adding new directory entries */      return (false); /* index file not created */   end Update_Index_File;