   DefineFileBuffers: proc(FileSec,FileLen,FileMed,CatSec,CatLen,CatMed) public swapable; /* define index file buffers */      dcl FileSec  fixed; /* sector start of file list buffer */      dcl FileLen  fixed; /* sector length of file list buffer */      dcl FileMed  fixed; /* file list buffer medium */      dcl CatSec   fixed; /* sector start of category list buffer */      dcl CatLen   fixed; /* sector length of category list buffer */      dcl CatMed   fixed; /* category list buffer medium */      FileListBuf = FileSec;      FileListLen = shl(FileLen,8);      FileListMed = FileMed;      CatListBuf = CatSec;      CatListLen = shl(CatLen,8);      CatListMed = CatMed;   end DefineFileBuffers;   str.insert:  proc(s,d,index) swapable; /* insert string s into string d starting at index */      dcl s     fixed array; /* source string */      dcl d     fixed array; /* destination string */      dcl index fixed; /* insertion point */      dcl i     fixed;      if index igt d(0) then return; /* insertion point out of range */      do i = d(0) - 1 to index by -1; /* make room for source string in destination */         call pbyte(d,i + s(0),byte(d,i));      end;      do i = 0 to s(0) - 1; /* put source string into proper location in destination string */         call pbyte(d,index + i,byte(s,i));      end;      d(0) = d(0) + s(0); /* adjust destination size accordingly */   end str.insert;   Words_To_Secs: proc(MSW,LSW) returns (fixed) swapable; /* convert words to sectors */      dcl (MSW,LSW) fixed; /* no. words */      LSW = LSW + 255; /* add 255 to round no. sectors up, if neccessary */      if LSW ilt 255 then MSW = MSW + 1;      LSW = (shl(MSW,8) or shr(LSW,8)); /* divide by 256 to get no. sectors */      MSW = shr(MSW,8);      return (LSW); /* return LS no. sectors */   end Words_To_Secs;   Get_File_Name: proc(BufIndex,Len,Name); /* get file name from optical disk buffer */      dcl BufIndex fixed; /* starting index of name in buffer */      dcl Len      fixed; /* length of name in words */      dcl Name     fixed array; /* array space to return name in */      dcl (i,c)   fixed;      Name(0) = 0; i = 0; c = -1; /* get the name of the file */      do while (i ilt Len) and (c <> 0); /* loop over characters of file name */         c = gbuf(BufIndex + i); /* get word of file name */         if c <> 0 then do; /* there's a character in there somewhere */            Name(1 + i) = c; /* store character(s) */            Name(0) = Name(0) + 1 + (shr(c,8) <> 0); /* count the no. characters */         end;         i = i + 1; /* next word */      end;   end Get_File_Name;   Get_Index_Directory_Name: proc(TreeName) public swapable; /* construct index file tree name */      dcl TreeName fixed array; /* array space for index file treename */      TreeName(0) = 0; /* nothing in treename */      if systyp = 0 then          call str.insert('F0:',TreeName,0);    /* floppy-based system */      else call str.insert('W0:',TreeName, 0); /* winchester-based system */      call str.insert(I$IndexPath,TreeName,TreeName(0)); /* start with path name */   end Get_Index_Directory_Name;   Get_Index_Name: proc(FileName,TreeName) public swapable; /* construct index file tree name */      dcl FileName fixed array; /* name of index file */      dcl TreeName fixed array; /* array space for index file treename */				Get_Index_Directory_Name(TreeName);		      call str.insert(':',TreeName,TreeName(0)); /* add colon */      call str.insert(FileName,TreeName,TreeName(0)); /* add file name */      if FileName(0) > shl(F#Name_Len,1) /* file name uses more than the allowed no. characters */      then TreeName(0) = TreeName(0) - (FileName(0) - shl(F#Name_Len,1)); /* lop off extra characters */   end Get_Index_Name;   Get_Index1_Directory_Name: proc(TreeName) public swapable; /* construct index file tree name */      dcl TreeName fixed array; /* array space for index file treename */      TreeName(0) = 0; /* nothing in treename */      if systyp = 0 then          call str.insert('F0:',TreeName,0);    /* floppy-based system */      else call str.insert('W0:',TreeName, 0); /* winchester-based system */      call str.insert(I$Index1Path,TreeName,TreeName(0)); /* start with path name */   end Get_Index1_Directory_Name;   Get_Index1_Name: proc(FileName,TreeName) swapable; /* construct index file tree name */      dcl FileName fixed array; /* name of index file */      dcl TreeName fixed array; /* array space for index file treename */		Get_Index1_Directory_Name(TreeName);      call str.insert(':',TreeName,TreeName(0)); /* add colon */      call str.insert(FileName,TreeName,TreeName(0)); /* add file name */      if FileName(0) > shl(F#Name_Len,1) /* file name uses more than the allowed no. characters */      then TreeName(0) = TreeName(0) - (FileName(0) - shl(F#Name_Len,1)); /* lop off extra characters */   end Get_Index1_Name;   Close_File: proc(F) returns (file) swapable; /* close file */      dcl F file; /* file to close */      dcl (i,j,k) fixed;      i = c#status; /* store statuses */      j = file_error;      k = s$sensekey;      call FClose(F); /* close file */      c#status = i; /* restore statuses */      file_error = j;      s$sensekey = k;      return (NullF); /* file is closed */   end Close_File;   Open_File: proc(Name,Access,BufPtr,BufMed,BufLen) returns (file) swapable; /* try to open file */      dcl Name   fixed array; /* treename of file to open */      dcl Access fixed array; /* access type */      dcl BufPtr fixed; /* pointer to file buffer */      dcl BufMed fixed; /* medium of file buffer */      dcl BufLen fixed; /* size of file buffer */      dcl F      file;  /* file variable returned by FOPEN */      dcl (i,j)  fixed;      F = FOpen(Name,Access); /* try to open file with given access */      if F <> NullF then do; /* opened successfully */         if SetBuf(F,BufPtr,BufMed,BufLen) <> EOF_Mark then do; /* buffer paremeters setup ok */            return (F); /* return file pointer */         end;      end;      if F <> NullF then F = Close_File(F); /* close up file variable if it was opened */      return (NullF); /* file not opened */   end Open_File;   Read_Volume_Name: proc(Name,Time,Level) returns (boolean); /* read volume name */      dcl Name   fixed array; /* array space to return name in */		dcl Time   fixed array; /* array space to return time in */      dcl Level  fixed; /* level to read name from */      dcl (i,ch) fixed;      if (ReadHeader(Level) != 0) 	/* header could be read */		{     		Get_File_Name(H$Name,H#Name_Max,Name); 	/* get name from buffer */			Time[0] = gbuf(H$Time);		}      else return (false); /* could not read header */      return (true); /* volume name read */   end Read_Volume_Name;   Mount_Volume: proc(Level) returns (boolean) public swapable; /* mount volume */      dcl Level fixed; /* level to mount */      dcl found fixed; /* true if directory area has any unused space */      if ReadHeader(Level) then do; 			/* try to read header */         found = FindNextUnused(O$MS_DirStart,O$LS_DirStart,O$MS_DirLen,O$LS_DirLen,Level); /* could not find free entry */         if (found) or ((not found) and (S$SenseKey = S$Good)) then do; /* directory area searched without any SCSI errors */            O$EntryCount = SecToEntry(F#MS_Sector,F#LS_Sector); /* convert sector to directory entry */            if Read_Volume_Name(O$Volume_Name, loc(addr(O$Volume_Time)), Level) then do; /* get volume name */               return (TRUE); /* volume mounted */            end;         end;      end;      return (FALSE); /* volume not mounted */    end Mount_Volume;   Check_Volume: proc(Level) returns (boolean) public swapable; /* see if volume has changed */      dcl Level fixed; /* level to check */      dcl New_Name(H#Name_Max) fixed; /* new volume name */      dcl New_Time(1         ) fixed;      CompareNames: proc(s1,s2) returns (boolean); /* returns TRUE if names are the same */         dcl (s1,s2) fixed array; /* strings to compare */         dcl i       fixed;         if s1(0) = s2(0) then do; /* same length */            do i = 0 to s1(0) - 1; /* loop over bytes of name */               if byte(s1,i) <> byte(s2,i) then return (false); /* different */            end;            return (true); /* same */         end;         return (false); /* names are different */      end CompareNames;      if Read_Volume_Name(New_Name,New_Time,Level) then do; /* try to read new volume name */         if ((CompareNames(O$Volume_Name,New_Name)) and (New_Time[0] == O$Volume_Time)) then do; /* volume name has not changed */            return (TRUE); /* volume has not changed */         end;         else c#status = e#volume_changed; /* new volume inserted */      end;      else do; /* volume name could not be read */         if S$SenseKey = S$UnitAttention then do; /* got a unit attention sense */            if Read_Volume_Name(New_Name,New_Time,Level) then do; /* and could read header this time */        		   if ((CompareNames(O$Volume_Name,New_Name)) and (New_Time[0] == O$Volume_Time)) then do; /* volume name has not changed */                  if FindEntryCount(Level) <> -1 then do; /* no new entries on optical disk */                     return (TRUE); /* volume has not changed */                  end;               end;               else c#status = e#volume_changed; /* new volume inserted */            end;         end;      end;      return (FALSE);   end Check_Volume;   Mount_Index: proc(TreeName) returns (boolean) swapable; /* mount optical disk volume */      dcl TreeName fixed array; /* treename of index file to mount */      OpenIndexFile: proc(Name) returns (boolean); /* open index file */         dcl Name   fixed array; /* treename of index file */         dcl (i,j)  fixed;         FileList = Open_File(Name,'r',FileListBuf,FileListMed,FileListLen); /* try to open index file for input */         if FileList <> NullF then do; /* opened successfully */            CatList = Open_File(Name,'r',CatListBuf,CatListMed,CatListLen); /* try to open index file for input */            if CatList <> NullF then do; /* opened successfully */               return (TRUE); /* index file opened and buffers allocated */            end;         end;         return (false); /* index file not opened */      end OpenIndexFile;      /* main procedure */      if FileList <> NullF then FileList = Close_File(FileList); /* close up file variables  */      if CatList  <> NullF then CatList  = Close_File(CatList ); /* from prior optical			*/      I$EntryCount = 0; /* assume index file will not be found */      if OpenIndexFile(TreeName) then do; /* index file found and opened for input */         call Seek(FileList,shl(H$Magic,1),0); /* seek to magic number field */         if GetW(FileList) < 0 then do; /* valid magic number */            call Seek(FileList,shl(H$LS_DirStart,1),0);            I$IndexStart = GetW(FileList); /* get first sector of file list index */            call Seek(FileList,shl(H$LS_DirLen,1),0);            write("5") = GetW(FileList); /* get no. sectors in file list index */            write("6") = 256; /* no. words = no. sectors * 256 */            write("324") = read("5");            write("7") = L#Name_Max; /* divide by the word length of the file names */            I$IndexCount = read("5"); /* store the no. entries in the file list index */            call Seek(FileList,shl(H$LS_DataStart,1),0);            I$FileStart = GetW(FileList); /* get first sector of file list */            call Seek(FileList,shl(H$FileCount,1),0);            I$FileCount = GetW(FileList); /* get no. records in file list */            call Seek(FileList,shl(H$LS_CatStart,1),0);            I$CatStart = GetW(FileList); /* get first sector of category list */            call Seek(FileList,shl(H$CatCount,1),0);            I$CatCount = GetW(FileList); /* get no. records in category list */            call Seek(FileList,shl(H$EntryCount,1),0); /* seek to directory entry count field */            I$EntryCount = GetW(FileList); /* get the no. entries the index file thinks are on the optical disk */            call Seek(FileList,shl(H$Stride,1),0); /* seek to stride field */            I$Stride = GetW(FileList); /* get file list index stride */            return (TRUE); /* index file is ready to go */         end;         else c#status = e#bad_index; /* index file header in bad state */      end; /* index file opened */      if FileList <> NullF then FileList = Close_File(FileList); /* close up file variables */      if CatList  <> NullF then CatList = Close_File(CatList);      return (FALSE); /* there was a problem mounting index */   end Mount_Index;   Check_Index: proc returns (boolean) public swapable; /* see if index has changed */      if (FileList <> NullF) and (CatList <> NullF) then do; /* file variables are still valid */         return (TRUE); /* index file is ready and willing */      end;      else c#status = e#no_index; /* no index file open */      return (FALSE);   end Check_Index;   Open_Optical: proc(TreeName,Level) returns (boolean) public swapable; /* open volume and index file */      dcl TreeName fixed array; 	/* array space for tree name */      dcl Level    fixed;			/* level of optical disk */		dcl Found    boolean;		dcl Status   fixed;				/* Note: see exactly similar logic in update_index that finds the correct 	*/		/* index file to update...																	*/      if Mount_Volume(Level) then do;									/* volume mounted */         call Get_Index_Name(O$Volume_Name,TreeName); 			/* get treename of index file */         Found = Mount_Index(TreeName);								/* see if exists in :.INDEX */						if (found == false)												/* not there: check :.INDEX1 */			{				Status = c#status;											/* save why failed */								call Get_Index1_Name(O$Volume_Name,TreeName); 		/* get treename of index file */				Found = Mount_Index(TreeName);								if (found == false)											/* could not find in .index1 either */				{					if ((c#status == e#no_file)							/* if .INDEX1 exists but specific .index file is missing */					&&  (status   == e#no_path))							/* and .INDEX subcatalog is missing								*/						;															/* then leave set up to use .INDEX1								*/					else															/* else revert to .INDEX for normal use						*/					{														        			call Get_Index_Name(O$Volume_Name,TreeName);	/* e.g. publish the error message that goes with .INDEX	*/						c#status = Status;									/* instead of .INDEX1...											*/					}				}			}			         if (found) then do; /* index mounted */            				call Seek(FileList,shl(H$Date,1),0); /* seek to date/time field */            				#if (0)				// force mounting of out-of-date index					O$EntryCount = I$EntryCount;					return (true);				#endif				if (gbuf(H$Date) = GetW(FileList)) and (gbuf(H$Time) = GetW(FileList)) then do; /* date and times match */               if O$EntryCount = I$EntryCount then do; /* disk is up to date */                  return (TRUE); /* volume is mounted */               end;               else if O$EntryCount igt I$EntryCount then do; /* new entries on optical */                  c#status = e#not_uptodate; /* index file is not up to date */                  return (FALSE); /* return without closing file variables */               end;               else c#status = e#no_file; /* more entries in index file???? */            end;            else c#status = e#no_file; /* date/time did not match, so file not found */         end;      end;      if FileList <> NullF then FileList = Close_File(FileList);      if CatList  <> NullF then CatList = Close_File(CatList);      return (FALSE); /* optical disk not open for business today */   end Open_Optical;   Check_Optical: proc(Level) returns (boolean) public swapable; /* see if optical system is still open */      dcl Level fixed; /* level of optical disk to verify */      if (Check_Volume(Level)) and (Check_Index) then do; /* volume and index files have not changed */         if O$EntryCount = I$EntryCount then do; /* disk is up to date */            return (TRUE); /* optical disk is still open */         end;         else c#status = e#not_uptodate; /* index file is not up to date */      end;      return (FALSE);   end Check_Optical;