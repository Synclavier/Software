   dcl RecNum fixed public; /* record number of entry in file list */   Index_Locate: proc(Name,Record,Level) returns (boolean) public swapable; /* locate file using index file */      dcl Name    fixed array; /* name to look for */      dcl Record  fixed array; /* array space to return record in */      dcl Level   fixed; /* level number of optical device */      dcl Target(L#Name_Max - 1) fixed; /* formatted target to look for */      dcl (i,j,c) fixed;/*      printstr: proc(s);         dcl s fixed array;         dcl (i,c) fixed;         do i = 0 to shl(l#name_max,1) - 1;            c = byte(loc(addr(s(0)) - 1),i);            if (c ige a.SP) and (c ile l.z)            then print chr(c),;            else print '*',;         end;      end printstr; */      CompareNames: proc(Name1,Name2) returns (fixed); /* compare names */         dcl (Name1,Name2) fixed array; /* names to compare */         dcl i fixed;         do i = 0 to L#Name_Max - 1; /* loop over all characters in name */            if      rot(Name1(i),8) ilt rot(Name2(i),8) then return (-1); /* less than */            else if rot(Name1(i),8) igt rot(Name2(i),8) then return (1); /* greater than */         end;         return (0); /* equal */      end CompareNames;      BinarySearch: proc(Source,Contender) returns (fixed); /* do binary search on index buffer */         dcl Source    fixed array; /* file name to search for */         dcl Contender fixed array; /* array space for contender name */         dcl Total     fixed; /* total no. records in database */         dcl First     fixed; /* first record */         dcl IndexBase fixed; /* byte base of file list index */         dcl (i,c)     fixed;         IndexBase = shl(I$IndexStart,8); /* first word of file list index in index file */         call Seek(CatList,I$IndexStart,3); /* seek to first sector of file list index */         i = GetW(CatList); /* get a word to prime the buffer */         First = 0; /* Start at the first entry */         Total = I$IndexCount;/* search all entries */         do while Total <> 0; /* Repeat until entire area has been searched */			   timeshare_with_host();			            i = First + shr(Total,1); /* find midpoint entry */            call Seek(CatList,shl(IndexBase + i*L#Name_Max,1),0); /* seek to first word of name */            call FRead(Contender,shl(L#Name_Max,1),1,CatList); /* get name */            c = CompareNames(Source,Contender); /* compare name to the one in the index buffer */            if c = 0 then do; /* source = contender */               return (i + 1); /* return entry location */            end;            else if c > 0 then do; /* source > contender */               First = i + 1; /* start at next record */               Total = Total - 1;            end;            Total = shr(Total,1); /* half the area has now been searched */          end;          return (First); /* return entry location to start linear search at */      end BinarySearch;      /* Main procedure */      S$SenseKey = S$Good; /* assume no error will occur */      c#status = e#none;      RecNum = 0;      if Check_Index then do; /* index file opened */         do i = 0 to shl(L#Name_Max,1) - 1; /* loop over all possible characters in name */            if i < Name(0) then do; /* valid name character */               c = byte(Name,i); /* get character of name */               if (c >= l.a) and (c <= l.z) then c = c - "40"; /* make upper case */            end;            else c = 0; /* insert a null */            call pbyte(loc(addr(Target(0)) - 1),i,c); /* add character to target name */         end;         i = BinarySearch(Target,Record); /* search for this name in the file list index */         if i <> 0 then do; /* name might be in file list - let's find out */            write("5") = i - 1; /* compute record to start search on */            write("6") = I$Stride; /* record location = buffer index * stride */            RecNum = read("5"); /* search will be started at this record */            write("6") = L#Rec_Length; /* word location = record location * record length in words */            write("324") = read("5");            write("7") = 256; /* sector = words / 256 */            i = read("5"); /* store sector */            j = read("4"); /* store word in that sector */            call Seek(FileList,I$FileStart + i,3); /* seek to this sector */            call Seek(FileList,shl(j,1),1); /* seek to byte in this sector */            c = -1; /* get into loop at least once */            do while (c < 0) and (RecNum ilt I$FileCount); /* loop while new names are less than target name */               call FRead(Record,shl(L#Rec_Length,1),1,FileList); /* get record */               c = CompareNames(loc(addr(Record(L$Name))),Target); /* compare names */               if c <> 0 then RecNum = RecNum + 1; /* next record */            end;            if c = 0 then do; /* file found */               F#MS_Sector = (shl(Level,8) or Record(L$MS_SecStart)); /* set up file variables */               F#LS_Sector = Record(L$LS_SecStart);               F#MS_Length = Record(L$MS_SecLen);               F#LS_Length = Record(L$LS_SecLen);               F#Words = Record(L$LS_WordLen);               F#Type = Record(L$File_Type);               return (TRUE); /* file found */            end;         end;         c#status = e#no_file; /* set appropriate status */         RecNum = 0;      end;      return (FALSE); /* file not found */   end Index_Locate;   Index_Replace: proc(Name,Type,MS_Len,LS_Len,WordLen,Header,Record,Level) returns (boolean) public swapable; /* replace on optical */      dcl Name             fixed array; /* name of file */      dcl Type             fixed; /* type of file */      dcl (MS_Len,LS_Len)  fixed; /* size of file in sectors */      dcl WordLen          fixed; /* size of file in words (mod 64K) */      dcl Header           fixed array; /* sound file header */      dcl Record           fixed array; /* array space to use */      dcl Level            fixed; /* level to replace on */      dcl Entry            fixed;      dcl found            boolean;      S$SenseKey = S$Good; /* assume no error will occur */      c#status = e#none;      if not Check_Optical(Level) then do; /* optical not open */         if not ((S$SenseKey = S$Good) and (c#status = e#not_uptodate)) /* something other than index file not up to date */         then return (FALSE); /* die */      end;      found = Index_Locate(Name,Record,Level); /* file to delete was found */      if (found) or ((not found) and (c#status = e#no_file)) then do; /* no bizarre errors occurred */         if found /* file already exists */         then Entry = Record(L$Dir_Entry); /* get most recent directory entry */         else Entry = -1; /* no directory entry for this file */                  if Optical_Replace(Name,Type,MS_Len,LS_Len,WordLen,Header,Entry,Level) then do; /* replace file on optical */            return (TRUE); /* delete record inserted */         end;      end;      return (FALSE);   end Index_Replace;   Index_Delete: proc(Name,Record,Level) returns (boolean) public swapable; /* delete file using index file */      dcl Name    fixed array; /* name to delete */      dcl Record  fixed array; /* record array space */      dcl Level   fixed; /* level of optical disk to delete on */      S$SenseKey = S$Good; /* assume no error will occur */      c#status = e#none;      if not Check_Optical(Level) then do; /* optical not open */         if not ((S$SenseKey = S$Good) and (c#status = e#not_uptodate)) /* something other than index file not up to date */         then return (FALSE); /* die */      end;      if Index_Locate(Name,Record,Level) then do; /* file to delete was found */                  if Optical_Delete(Name,Record(L$Dir_Entry),Level) then do;             return (TRUE); /* delete record inserted */         end;      end;      return (FALSE); /* delete record not inserted */   end Index_Delete;   Index_Update: proc(OldName,NewName,Header,Record,Level) returns (boolean) public swapable; /* update file using index file */      dcl OldName  fixed array; /* old name of file */      dcl NewName  fixed array; /* new name of file */      dcl Header   fixed array; /* new sound file header */      dcl Record   fixed array; /* record array space */      dcl Level    fixed; /* level of optical disk to rename on */      S$SenseKey = S$Good; /* assume no error will occur */      c#status = e#none;      if not Check_Optical(Level) then do; /* optical not open */         if not ((S$SenseKey = S$Good) and (c#status = e#not_uptodate)) /* something other than index file not up to date */         then return (FALSE); /* die */      end;      if Index_Locate(OldName,Record,Level) then do; /* old file name found */                  if Optical_Update(OldName,NewName,Header,Record(L$Dir_Entry),Level) then do; /* update file on optical */            return (TRUE); /* update record inserted */         end;      end;      return (FALSE); /* rename record not inserted */   end Index_Update;