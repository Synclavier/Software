/* Memory Block Management Routines   by Kip Olson, September 1987   Modification History:   	 11/26/96 - CWJ - Included comlits to get configuration info correct     05/02/88 - KJO - Updated for new poly routines*/module memblock;   insert ':synlits:comlits';  /* compilation literals */      insert ':-xpl:scsirout';    /* SCSI routines */   insert ':-xpl:catrout';     /* catalog routines */   insert ':-xpl:optlits';     /* optical literals */   insert ':synlits:globlits'; /* external memory literals */   insert ':synlits:fcodlits'; /* poly memory literals */   insert ':synmods:xmemdcl';  /* external memory routines and declarations */   insert ':synmods:polydcl';  /* for accessing poly memory */   insert ':synauxs:recrdlit'; /* block management literals */   /* The memory space in poly or external memory is allocated by word.      It is defined as follows:        word n  +---------------------------+                 |        Relocatable        | <- MStartPtr                |           Area            |                |                           |                |- - - - - - - - - - - - - -|                |                           | <- MRelocPtr                |           Free            |                |           Area            |                |                           |                |- - - - - - - - - - - - - -| <- MStaticPtr                |                           |                |          Static           |                |           Area            |                +---------------------------+   word n + len                               <- MEndPtr   */   /* Memory Definition */   dcl UsingPoly       boolean; /* TRUE if using poly memory, FALSE if using external memory */   dcl mdevi           fixed public; /* memory device to read/write */   /* Memory Block Parameters */   dcl MStartPtr (ptr#len - 1) fixed; /* start of memory area */   dcl MEndPtr   (ptr#len - 1) fixed; /* end of memory area */   dcl MRelocPtr (ptr#len - 1) fixed; /* next free section after reloc area */   dcl MStaticPtr(ptr#len - 1) fixed; /* last static block */   dcl MNullPtr  (ptr#len - 1) fixed public; /* null pointer */   /* Stack Parameters */   dcl R$StkBase       fixed public; /* base of stack in external memory */   dcl R$StkMax        fixed public; /* max no. items on stack */   dcl StkPtr          fixed; /* no. items on stack */   dcl BasePtr         fixed; /* pointer to current base of stack */   dcl MTreePtr(ptr#len - 1) fixed; /* tree node */   /* Memory Block Management Routines */   PtrToWords: proc(ptr,buf) public swapable; /* turn pointer address into a word address */      dcl ptr fixed array; /* pointer to convert */      dcl buf fixed array; /* array to return words in */      buf(0) = (shl(ptr(0) and "HF",8) or shr(ptr(1),8));      buf(1) = (shl(ptr(1),8) or (shr(ptr(0),4) and "HFF"));   end PtrToWords;   WordsToPtr: proc(buf,ptr) public swapable; /* turn word address into a pointer address */      dcl buf fixed array; /* words to convert */      dcl ptr fixed array; /* pointer to return */      ptr(0) = ((ptr(0) and "HF000") or shl(buf(1) and "HFF",4) or shr(buf(0),8));      ptr(1) = (shl(buf(0),8) or shr(buf(1),8));   end WordsToPtr;   ReadMBlock: proc(ptr,offset) public; /* setup to read block of memory */      dcl ptr     fixed array; /* pointer to block to read */      dcl offset  fixed; /* offset from beginning of pointer */      dcl base(1) fixed; /* base pointer */      offset = (shr(ptr(0),4) and "HFF") + offset; /* add on offset */      if UsingPoly then do; /* using poly memory */         base(LW#MSB) = (ptr(0) and "HF00F"); /* copy over bin and page fields */         base(LW#LSB) = ptr(1); /* copy over sector */         call psmread(base,0,offset); /* setup poly for read */      end;      else do; /* using external memory */         write(mam) = ptr(1) + shr(offset,8); /* starting sector */         write(mal) = (offset and "HFF"); /* starting word within that sector */      end;   end ReadMBlock;   WriteMBlock: proc(ptr,offset) public; /* setup to write block of memory */      dcl ptr     fixed array; /* pointer to block to read */      dcl offset  fixed; /* offset from beginning of pointer */      dcl base(1) fixed; /* base pointer */      offset = (shr(ptr(0),4) and "HFF") + offset; /* add on offset */      if UsingPoly then do; /* using poly memory */         base(LW#MSB) = (ptr(0) and "HF00F"); /* copy over bin and page fields */         base(LW#LSB) = ptr(1); /* copy over sector */         call psmwrite(base,0,offset); /* setup poly for write */      end;      else do; /* using external memory */         write(mam) = ptr(1) + shr(offset,8); /* starting sector */         write(mal) = (offset and "HFF"); /* starting word within that sector */      end;   end WriteMBlock;   ReadMPtrBlock: proc(ptr,ptroffset,offset) public swapable; /* setup to read memory block given by pointer */      dcl ptr       fixed array; /* pointer to source block */      dcl ptroffset fixed; /* offset of pointer in that block */      dcl offset fixed; /* offset in pointed-to block to read */      dcl p(ptr#len - 1) fixed;      call ReadMBlock(ptr,ptroffset);      p(0) = read(mdevi); p(1) = read(mdevi); /* get pointer */      call ReadMBlock(p,offset); /* read block pointed to */   end ReadMPtrBlock;   WriteMPtrBlock: proc(ptr,ptroffset,offset) public swapable; /* setup to write memory block given by pointer */      dcl ptr       fixed array; /* pointer to source block */      dcl ptroffset fixed; /* offset of pointer in that block */      dcl offset fixed; /* offset in pointed-to block to write */      dcl p(ptr#len - 1) fixed;      call ReadMBlock(ptr,ptroffset);      p(0) = read(mdevi); p(1) = read(mdevi); /* get pointer */      call WriteMBlock(p,offset); /* write block pointed to */   end WriteMPtrBlock;   CopyMBlock: proc(SourcePtr,SourceOffset,DestPtr,DestOffset,len) public swapable; /* copy block of memory */      dcl SourcePtr    fixed array; /* pointer to source block */      dcl SourceOffset fixed; /* offset from beginning of source block to start copy */      dcl DestPtr      fixed array; /* pointer to destination block */      dcl DestOffset   fixed; /* offset from beginning of destination block to copy to */      dcl len          fixed; /* no. words to copy */      dcl (SourceBase,DestBase)(1) fixed; /* base pointers */      SourceOffset = (shr(SourcePtr(0),4) and "HFF") + SourceOffset; /* add on offset */      DestOffset = (shr(DestPtr(0),4) and "HFF") + DestOffset;      if UsingPoly then do; /* using poly memory */         SourceBase(LW#MSB) = (SourcePtr(0) and "HF00F"); /* copy over bin and page fields */         SourceBase(LW#LSB) = SourcePtr(1); /* copy over sector */         DestBase(LW#MSB)   = (DestPtr(0) and "HF00F"); /* copy over bin and page fields */         DestBase(LW#LSB)   = DestPtr(1); /* copy over sector */         call Copy.Poly.Mem(SourceBase, 0, SourceOffset,                            DestBase,   0, DestOffset,                            0, len);      end;      else do; /* using external memory */         call Copy.Ext.Mem(SourcePtr(1),SourceOffset,                           DestPtr(1),  DestOffset,                           len);      end;   end CopyMBlock;   CompactMBlocks: proc swapable; /* compact relocateable memory */      dcl SourcePtr(ptr#len - 1) fixed; /* source pointer */      dcl DestPtr(ptr#len - 1)   fixed; /* destination pointer */      dcl ptr(ptr#len - 1)       fixed; /* scratch pointer */      dcl buf(1)       fixed; /* word buffer */      dcl alloclen     fixed; /* no. words allocated for block */      dcl datalen      fixed; /* no. words used for block */      SourcePtr(0) = MStartPtr(0); /* start at beginning of relocateable memory */      SourcePtr(1) = MStartPtr(1);      DestPtr(0) = SourcePtr(0); /* this is same as destination */      DestPtr(1) = SourcePtr(1);      do while (SourcePtr(0) <> MRelocPtr(0)) or (SourcePtr(1) <> MRelocPtr(1)); /* loop until end of relocateable area */         call ReadMBlock(SourcePtr,mem$alloc);         alloclen = read(mdevi); /* allocation */         datalen = read(mdevi); /* size */         ptr(0) = read(mdevi); /* pointer */         ptr(1) = read(mdevi);         if (ptr(0) = MNullPtr(0)) and (ptr(1) = MNullPtr(1)) and (datalen = 0) then do; /* skip deleted blocks */         end;         else do; /* valid data block */            if (SourcePtr(0) <> DestPtr(0)) or (SourcePtr(1) <> DestPtr(1)) then do; /* source <> destination, so shuffle down */               call CopyMBlock(SourcePtr,0,DestPtr,0,alloclen); /* copy data */               if (ptr(0) <> MNullPtr(0)) or (ptr(1) <> MNullPtr(1)) then do; /* something is pointing at this block */                  call WriteMBlock(ptr,mem$ptr); /* make it point to the new location */                  write(mdevi) = DestPtr(0);                  write(mdevi) = DestPtr(1);               end;            end;            call PtrToWords(DestPtr,buf);            buf(1) = buf(1) + alloclen;            if buf(1) ilt alloclen then buf(0) = buf(0) + 1;            call WordsToPtr(buf,DestPtr);         end;         call PtrToWords(SourcePtr,buf);         buf(1) = buf(1) + alloclen;         if buf(1) ilt alloclen then buf(0) = buf(0) + 1;         call WordsToPtr(buf,SourcePtr);      end;      MRelocPtr(0) = DestPtr(0); /* new end of relocatable area */      MRelocPtr(1) = DestPtr(1);   end CompactMBlocks;   GetMFree: proc(buf) public swapable; /* return no. words free in buffer area */      dcl buf fixed array; /* buffer to return memory data */      dcl (Static,Reloc)(1) fixed;      call PtrToWords(MStaticPtr,Static); /* convert to word pointers */      call PtrToWords(MRelocPtr,Reloc);      buf(0) = Static(0) - Reloc(0); /* free = static - reloc */      if Static(1) ilt Reloc(1) then buf(0) = buf(0) - 1;      buf(1) = Static(1) - Reloc(1);   end GetMFree;   GetMBlockSize: proc(ptr) returns (fixed) public swapable; /* return no. words used by memory block */      dcl ptr      fixed array; /* pointer to block */      call ReadMBlock(ptr,mem$alloc);      return (read(mdevi) - mem#len); /* return allocated size minus reserved words */   end GetMBlockSize;   NewMBlock: proc(ptr,len,relocate) returns (boolean) public swapable; /* allocate new memory block */      dcl ptr      fixed array; /* pointer to return */      dcl len      fixed; /* no. words to allocate */      dcl relocate boolean; /* TRUE if block is to be relocateable */      dcl total    fixed; /* total no. words to allocate */      dcl buf(1)   fixed;      total = len + mem#len; /* total no. words required */      call GetMFree(buf); /* find amount of free memory */      if (buf(0) = 0) and (buf(1) ilt total) then do; /* not enough room for requested block */         call CompactMBlocks; /* compact memory */         call GetMFree(buf); /* find amount of free memory */      end;      if (buf(0) = 0) and (buf(1) ilt total) then do; /* still not enough room for requested block */         S$SenseKey = S$Good;         c#status = e#record_full; /* set appropriate error message */         return (FALSE); /* die */      end;      if relocate then do; /* allocate relocateable block */         ptr(0) = MRelocPtr(0); /* store pointer */         ptr(1) = MRelocPtr(1);         call PtrToWords(MRelocPtr,buf); /* convert pointer to word */         buf(1) = buf(1) + total; /* move reloc pointer down */         if buf(1) ilt total then buf(0) = buf(0) + 1;         call WordsToPtr(buf,MRelocPtr); /* store new reloc pointer */      end;      else do; /* allocate static block */         call PtrToWords(MStaticPtr,buf); /* convert pointer to word */         if buf(1) ilt total then buf(0) = buf(0) - 1; /* backup the required no. words */         buf(1) = buf(1) - total;         call WordsToPtr(buf,MStaticPtr); /* store new static pointer */         ptr(0) = MStaticPtr(0); /* store pointer */         ptr(1) = MStaticPtr(1);      end;      call WriteMBlock(ptr,mem$alloc); /* intialize block */      write(mdevi) = total; /* store allocation length */      write(mdevi) = len; /* store used length */      write(mdevi) = MNullPtr(0); /* nothing points to this */      write(mdevi) = MNullPtr(1);      return (TRUE); /* block allocated */   end NewMBlock;   DisposeMBlock: proc(ptr) returns (boolean) public swapable; /* remove memory block */      dcl ptr      fixed array; /* pointer to block to remove */      dcl buf(1)   fixed;      dcl limit(1) fixed;      if (ptr(0) = MNullPtr(0)) and (ptr(1) = MNullPtr(1))      then return (FALSE); /* cannot delete null pointer */      call PtrToWords(ptr,buf);      call PtrToWords(MStartPtr,limit);      if (buf(0) ilt limit(0)) or ((buf(0) = limit(0)) and (buf(1) ilt limit(1)))      then return (FALSE); /* cannot delete a block before the beginning of the relocateable area */      call PtrToWords(MRelocPtr,limit);      if (buf(0) igt limit(0)) or ((buf(0) = limit(0)) and (buf(1) ige limit(1)))      then return (FALSE); /* cannot delete a block after the end of the relocateable area */      call WriteMBlock(ptr,mem$used);      write(mdevi) = 0; /* no words used */      write(mdevi) = MNullPtr(0); /* nothing points to this */      write(mdevi) = MNullPtr(1);      return (TRUE); /* block deleted */   end DisposeMBlock;   CompareBlock: proc(ptr,keyoffset,target) returns (fixed) public swapable; /* compare memory block string to given string */      dcl ptr       fixed array; /* pointer to block to compare */      dcl keyoffset fixed; /* offset of key in block */      dcl target    fixed array; /* target string to compare against */      dcl KeyWord   fixed; /* word of key */      dcl KeyCh     fixed; /* character of key */      dcl KeyLen    fixed; /* length of of key */      dcl TargetCh  fixed; /* character of target */      dcl TargetLen fixed; /* length of target */      dcl (max,i)   fixed;      call ReadMBlock(ptr,keyoffset); /* prepare to read key */      KeyLen = read(mdevi); /* get length of key string */      TargetLen = target(0); /* get length of target string */      if KeyLen ilt TargetLen then max = KeyLen; else max = TargetLen; /* limit search to minimum of the two strings */      KeyCh = 0; TargetCh = 0; /* get into loop first time */      i = 0; /* start at first character of target */      do while (i ilt max) and (KeyCh = TargetCh); /* loop until all characters have been compared or a difference is found */         if i then KeyCh = shr(KeyWord,8); /* get odd characters */         else do;            KeyWord = read(mdevi); /* get next word of key */            KeyCh = (KeyWord and "HFF"); /* get even characters */         end;         TargetCh = byte(Target,i); /* get next character of target */         i = i + 1; /* advance to next character position */      end;      if KeyCh ilt TargetCh /* key < target */      then return (-1);      else if KeyCh igt TargetCh /* key > target */      then return (1);      else do; /* all characters are the same */         if KeyLen = TargetLen /* lengths are the same */         then return (0); /* key = target */         else if KeyLen ilt TargetLen         then return (-1); /* key < target */         else return ( 1); /* key > target */      end;   end CompareBlock;   /* Tree Management Routines */   TreeInit: proc(h) returns (boolean) public swapable; /* intialize tree */      dcl h fixed array; /* head of tree */      if NewMBlock(h,tree#len + 1,false) then do;         call WriteMBlock(h,tree$leftptr);         write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* left pointer */         write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* right pointer */         write(mdevi) = false; /* red flag */         write(mdevi) = 0; /* zero-length key */         return (true); /* tree is ready */      end;      return (false); /* could not initialize tree */   end TreeInit;   TreeSearch: proc(s,h,x) returns (boolean) public swapable; /* search tree for string */      dcl s     fixed array; /* string to search for */      dcl h     fixed array; /* head of tree */      dcl x     fixed array; /* pointer to node */      dcl c     fixed;      x(0) = h(0); x(1) = h(1); /* start at root */      do while (x(0) <> MNullPtr(0)) or (x(1) <> MNullPtr(1));         c = CompareBlock(x,tree$key,s);         if      c > 0 then call ReadMBlock(x,tree$leftptr); /* node > string, so traverse left */         else if c < 0 then call ReadMBlock(x,tree$rightptr); /* node < string, so traverse right */         else return (true); /* key = node, so we are done */         x(0) = read(mdevi); x(1) = read(mdevi);      end;         return (false); /* string not found */   end TreeSearch;   TreeInsert: proc(s,h,result) returns (fixed) public swapable; /* insert string into tree */      dcl s      fixed array; /* string to insert */      dcl h      fixed array; /* head of tree */      dcl result fixed array; /* pointer to node found/created */      dcl (gg,g,f,x)(ptr#len - 1) fixed; /* various pointers */      dcl (redleft,redright) fixed;      dcl (i,c) fixed;      rotate: proc(s,y,result);         dcl s          fixed array; /* string to insert */         dcl y          fixed array; /* pointer to rotate */         dcl result     fixed array; /* function result */         dcl (ss,gs,t)(ptr#len - 1) fixed;         if CompareBlock(y,tree$key,s) > 0         then call ReadMBlock(y,tree$leftptr);         else call ReadMBlock(y,tree$rightptr);         ss(0) = read(mdevi); ss(1) = read(mdevi);         if CompareBlock(ss,tree$key,s) > 0 then do;            call ReadMBlock(ss,tree$leftptr);            gs(0) = read(mdevi); gs(1) = read(mdevi);            call ReadMBlock(gs,tree$rightptr);            t(0) = read(mdevi); t(1) = read(mdevi);            call WriteMBlock(ss,tree$leftptr);            write(mdevi) = t(0); write(mdevi) = t(1);            call WriteMBlock(gs,tree$rightptr);            write(mdevi) = ss(0); write(mdevi) = ss(1);         end;         else do;            call ReadMBlock(ss,tree$rightptr);            gs(0) = read(mdevi); gs(1) = read(mdevi);            call ReadMBlock(gs,tree$leftptr);            t(0) = read(mdevi); t(1) = read(mdevi);            call WriteMBlock(ss,tree$rightptr);            write(mdevi) = t(0); write(mdevi) = t(1);            call WriteMBlock(gs,tree$leftptr);            write(mdevi) = ss(0); write(mdevi) = ss(1);         end;         if CompareBlock(y,tree$key,s) > 0         then call WriteMBlock(y,tree$leftptr);         else call WriteMBlock(y,tree$rightptr);         write(mdevi) = gs(0); write(mdevi) = gs(1);         result(0) = gs(0); result(1) = gs(1);      end rotate;      split: proc(s,h,gg,g,f_arg,x_arg,result);         dcl s                    fixed array; /* string to insert */         dcl (h,gg,g,f_arg,x_arg) fixed array; /* various pointers */         dcl result               fixed array; /* function result */         dcl (f,x)(ptr#len - 1)   fixed; /* local variables */         f(0) = f_arg(0); f(1) = f_arg(1); /* copy to local variables */         x(0) = x_arg(0); x(1) = x_arg(1);         call WriteMBlock(x,tree$red);         write(mdevi) = true; /* set red flag to true */         call WriteMPtrBlock(x,tree$leftptr,tree$red);         write(mdevi) = false; /* set left child's red flag to false */         call WriteMPtrBlock(x,tree$rightptr,tree$red);         write(mdevi) = false; /* set right child's red flag to false */         call ReadMBlock(f,tree$red);         if read(mdevi) then do;            call WriteMBlock(g,tree$red);            write(mdevi) = true;            if (CompareBlock(g,tree$key,s) > 0)            <> (CompareBlock(f,tree$key,s) > 0)            then call rotate(s,g,f);            call rotate(s,gg,x);            call WriteMBlock(x,tree$red);            write(mdevi) = false;         end;         call WriteMPtrBlock(h,tree$rightptr,tree$red);         write(mdevi) = false; /* set right child's red flag to false */         result(0) = x(0); result(1) = x(1);      end split;      /* main procedure */      x(0) = h(0); x(1) = h(1); /* start at root */      f(0) = x(0); f(1) = x(1);      g(0) = x(0); g(1) = x(1);      do while (x(0) <> MNullPtr(0)) or (x(1) <> MNullPtr(1));         gg(0) = g(0); gg(1) = g(1);         g(0) = f(0); g(1) = f(1);         f(0) = x(0); f(1) = x(1);         c = CompareBlock(x,tree$key,s);         if      c > 0 then call ReadMBlock(x,tree$leftptr); /* node > string, so traverse left */         else if c < 0 then call ReadMBlock(x,tree$rightptr); /* node < string, so traverse right */         else do; /* key = node, so we are done */            result(0) = x(0); result(1) = x(1); /* store result */            return (NodeFound);         end;         x(0) = read(mdevi); x(1) = read(mdevi);         call ReadMPtrBlock(x,tree$leftptr,tree$red); /* get left child's red flag */         redleft = read(mdevi);         call ReadMPtrBlock(x,tree$rightptr,tree$red); /* get right child's red flag */         redright = read(mdevi);         if (redleft) and (redright) then do; /* this is a four-node, so split it */            call split(s,h,gg,g,f,x,x);         end;      end;      if NewMBlock(x,tree#len + shr(s(0) + 1,1) + 1,false) then do; /* could create new node */         call WriteMBlock(x,tree$leftptr);         write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* left pointer */         write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* right pointer */         write(mdevi) = false; /* red/black flag */         write(mdevi) = s(0); /* length of key */         do i = 1 to shr(s(0) + 1,1); /* store words of key */            write(mdevi) = s(i);         end;         if CompareBlock(f,tree$key,s) > 0         then call WriteMBlock(f,tree$leftptr);  /* node > string */         else call WriteMBlock(f,tree$rightptr); /* node < string */         write(mdevi) = x(0); write(mdevi) = x(1); /* make parent point to new child */         result(0) = x(0); result(1) = x(1);         call split(s,h,gg,g,f,x,x);         return (NodeCreated); /* new node inserted */      end;         return (NoMoreRoom); /* no more room in data area */   end TreeInsert;   TreeTraverse: proc(headptr,Initialize,nodeptr) returns (boolean) public swapable; /* traverse tree */      dcl headptr    fixed array; /* head of tree to traverse */      dcl Initialize boolean; /* TRUE to initialize traversal */      dcl nodeptr    fixed array; /* pointer to node found */      push: proc(value); /* push onto stack */         dcl value fixed; /* value to push */         write(mam) = R$StkBase + shr(StkPtr,8); /* sector in external memory */         write(mal) = (StkPtr and "HFF"); /* word in that sector */         write(md) = value; /* store value */         StkPtr = StkPtr + 1; /* increment stack pointer */      end push;      pop: proc; /* pop off of stack */         StkPtr = StkPtr - 1; /* decrement stack pointer */         write(mam) = R$StkBase + shr(StkPtr,8); /* sector in external memory */         write(mal) = (StkPtr and "HFF"); /* word in that sector */         return (read(md)); /* return value there */      end pop;               if Initialize then do; /* intialize stack for traversal */         call push(BasePtr); /* save current base pointer */         call push(MTreePtr(0)); /* save current tree pointer */         call push(MTreePtr(1));         BasePtr = StkPtr; /* this is now the new base pointer */         call ReadMBlock(headptr,tree$rightptr);         MTreePtr(0) = read(mdevi); MTreePtr(1) = read(mdevi); /* start at right child of header */      end;      do forever;         if (MTreePtr(0) = MNullPtr(0)) and (MTreePtr(1) = MNullPtr(1)) then do; /* cannot traverse left anymore */            if StkPtr = BasePtr then do; /* nothing left on this stack */               MTreePtr(1) = pop; /* restore old tree pointer */               MTreePtr(0) = pop;               BasePtr = pop; /* restore old base pointer */               S$SenseKey = S$Good; /* this is not an error */               c#status = e#none;               return (false); /* nothing left */            end;            nodeptr(1) = pop; /* get node to return */            nodeptr(0) = pop;            call ReadMBlock(nodeptr,tree$rightptr);            MTreePtr(0) = read(mdevi); MTreePtr(1) = read(mdevi); /* get right child */            return (true); /* node found */         end;         else do;            if StkPtr ige R$StkMax then do; /* no more room on stack */               S$SenseKey = S$Good; /* this is an error */               c#status = e#stack_full;               return (false);            end;            call push(MTreePtr(0)); /* save this node */            call push(MTreePtr(1));            call ReadMBlock(MTreePtr,tree$leftptr);            MTreePtr(0) = read(mdevi); MTreePtr(1) = read(mdevi); /* keep traversing to left */         end;      end;   end TreeTraverse;   /* Intialization Routines */   DefineMArea: proc(Bin,MS_Start,LS_Start,MS_Len,LS_Len) public swapable; /* define memory area */      dcl Bin                 fixed; /* bin to use */      dcl (MS_Start,LS_Start) fixed; /* starting sector of memory area */      dcl (MS_Len,LS_Len)     fixed; /* sector length of memory area */      if bin = -1 then do; /* use external memory */         UsingPoly = FALSE;         mdevi = mdi;         bin = 0;      end;      else do; /* use poly memory */         UsingPoly = TRUE;         mdevi = psd;      end;      MStartPtr(0) = (shl(bin,14) or shl(0,4) or (MS_Start and "HF")); /* bin, word, ms sec */      MStartPtr(1) = LS_Start; /* ls sec */      MS_Start = MS_Start + MS_Len; /* calculate end of memory area */      LS_Start = LS_Start + LS_Len;      if LS_Start ilt LS_Len then MS_Start = MS_Start + 1;      MEndPtr(0) = (shl(bin,14) or shl(0,4) or (MS_Start and "HF")); /* bin, word, ms sec */      MEndPtr(1) = LS_Start; /* ls sec */      MRelocPtr(0) = MStartPtr(0); /* reloc area starts at beginning of memory area */      MRelocPtr(1) = MStartPtr(1);      MStaticPtr(0) = MEndPtr(0); /* static area starts at end of memory area */      MStaticPtr(1) = MEndPtr(1);      call NewMBlock(MNullPtr,tree#len + 1,false); /* allocate null pointer in static area */      call WriteMBlock(MNullPtr,mem$ptr);      write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* does not point to a data block */      call WriteMBlock(MNullPtr,tree$leftptr);      write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* left pointer */      write(mdevi) = MNullPtr(0); write(mdevi) = MNullPtr(1); /* right pointer */      write(mdevi) = false; /* red flag */      write(mdevi) = 0; /* key length */   end DefineMArea;   DefineStack: proc(Base,Max) public swapable; /* define stack area */      dcl Base fixed; /* base of stack in external memory */      dcl Max  fixed; /* max no. sectors on stack */      R$StkBase = Base;      if Max igt 255 then Max = 255; /* limit to 255 sectors */      R$StkMax = shl(Max,8);   end DefineStack;   StackInit: proc public swapable; /* intialize stack */      StkPtr = 0;      BasePtr = StkPtr;      MTreePtr(0) = MNullPtr(0); MTreePtr(1) = MNullPtr(1);   end StackInit;end memblock;