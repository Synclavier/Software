/* GPRMMOD - ROUTINES TO STEP THROUGH .NEWDATA FILES OUT ON DISK */

/*
   3/23/87 - CJ - MODIFIED
   1/14/87 - cj - modified for m128k board boundary bug
*/


/* THESE ROUTINES PERFORM WORD-BY-WORD BUFFERING FROM THE DISK.     */
/* THEY ARE PASSED A BUFFER TO USE (OPTIMIZES TIMBRE BANK RECALL)   */


/*  1. PRIME.IO.BUFFER -  PRIMES IO BUFFER
    2. G.NEXT          -  GETS NEXT DISK WORD DURING TIMBRE READ
    3. G.NEXT.RECORD   -  FILLS RECORD FROM BUFFER QUICKLY
    4. SKIP.WRDS       -  SKIPS OVER WORDS IN BUFFER                */
    


/* THESE ROUTINES ARE VERY EASY TO USE: */

/* 1.  CALL PRIME.IO.BUFFER  (STARTING DEVICE,  SECTOR, WORD,        DISK ADDRESS TO START READING FROM 
                              MS SECTOR LENGTH, LS SECTOR LENGTH,    MAX # OF SECTORS TO READ 
                              EXMEM BUFF START, EXMEM BUFF LENGTH,   LOCATION OF DISK BUFFER TO USE IN EXTERNAL MEMORY (SECTOR START, SECTOR LENGTH)
                              CHUNK SIZE);                           CHUNK SIZE TO READ,  IN SECTORS

       
   2.  TO READ WORD BY WORD,  CALL G.NEXT

   3.  TO READ RECORD BY RECORD,  CALL G.NEXT.RECORD (ARRAY,LENGTH) */


MODULE GPRMMOD;

INSERT ':SYNLITS:COMLITS';
INSERT ':SYNLITS:GLOBLITS';
INSERT ':SYNLITS:PRMLITS';

INSERT ':SYNMODS:GLOBDCL';
INSERT ':SYNMODS:XMEMDCL';

/* VARIABLES FOR G.PRIME: */


DCL (COPY.BANK)   FIXED PUBLIC;  /* USED TO DETECT FULL BUFFER SITTING IN MEMORY */
DCL (DISK.DEV)    FIXED PUBLIC;  /* DEVICE TO READ INTO BUFFER */
DCL (DISK.SEC)    FIXED PUBLIC;  /* SECTOR NUMBER OF DISK THAT CORRESPONDS TO START OF BUFFER */
DCL (BUF.R.PTR)   FIXED PUBLIC;  /* BUFFER READING POINTER                 */

DCL (BUFR.START)  FIXED PUBLIC;  /* CORE LOCATION OF START OF BUFFER */
DCL (MAX.BUF.LEN) FIXED PUBLIC;  /* MAX LENGTH OF BUFFER BEFORE WE CREAM SOMETHING */
DCL (ACT.BUF.LEN) FIXED PUBLIC;  /* ACTIVE LENGTH OF BUFFER                */

DCL (MAX.LEN.MSB) FIXED PUBLIC;
DCL (MAX.LEN.LSB) FIXED PUBLIC;
DCL (CHUNK.SIZE)  FIXED PUBLIC;  /* NORMALLY BUFFER IN 32 SECTOR CHUNKS, FOR SPEED */

/* NOTE: G.PRIME AND G.NEXT ARE FULLY COMPATIBLE WITH */
/* 24 BIT SECTOR NUMBERS                              */


PRIME.IO.BUFFER:PROC(DISKDEV,  DISKSEC, DISKWORD, 
                     MSLEN,    LSLEN,   
                     BUFSTART, BUFLEN,  CHUNK) PUBLIC SWAPABLE; 
   DCL (DISKDEV,  DISKSEC, DISKWORD)  FIXED;
   DCL (MSLEN,    LSLEN            )  FIXED;
   DCL (BUFSTART, BUFLEN,  CHUNK   )  FIXED;

   DCL (I) FIXED;

   IF INC.MONO<>0  THEN CALL STOP.DISK;  /* STOP MONO OUTPUT SO WE CAN READ DISK */


   /* NORMALIZE DISK ADDRESS: */

   I=SHR(DISKWORD,8); DISKWORD=DISKWORD&255;
   DISKSEC=DISKSEC+I;
   IF DISKSEC ILT I THEN DISKDEV=DISKDEV+1;


   /* SET UP GLOBAL VARIABLES */
   /* FOR BUFFER:             */

   BUFR.START  =BUFSTART;                /* USE THIS BUFFER IN XMEM */
   MAX.BUF.LEN =BUFLEN;                  /* LENGTH IN SECTORS       */

   IF MAX.BUF.LEN ILT 4                  /* NOT ENOUGH ROOM IN PASSED BUFFER    */
   THEN DO;                              /* USE 4 SECTOR BUFFER */
      BUFR.START =EXTBUF.PTR;            /* THAT IS SITTING IN  */
      MAX.BUF.LEN=EXTBUF.LEN;            /* EXTERNAL MEMORY     */
   END;

   IF MAX.BUF.LEN IGT 254                /* LIMIT TO 254 SECTOR BUFFER */
   THEN MAX.BUF.LEN = 254;

   
   /* SET UP GLOBAL VARIABLES */
   /* FOR DISK ADDRESS:       */

   DISK.DEV   = DISKDEV;                 /* SET UP WORKING POINTER  */
   DISK.SEC   = DISKSEC;                 /* COMPUTE FIRST SECTOR TO READ */
   BUF.R.PTR  = DISKWORD;                /* AND OFFSET WITHIN SECTOR */

   MAX.LEN.MSB = MSLEN;                  /* SET UP WORKING POINTERS */
   MAX.LEN.LSB = LSLEN;                  /* FOR LENGTH              */

   CHUNK.SIZE  = CHUNK;                  /* SET CHUNK SIZE          */
   IF CHUNK.SIZE = 0
   THEN CHUNK.SIZE = 32;

   IF   CHUNK.SIZE IGT MAX.BUF.LEN
   THEN CHUNK.SIZE  =  MAX.BUF.LEN;

   IF  (MAX.LEN.MSB=0)
   AND (CHUNK.SIZE IGT MAX.LEN.LSB)
   THEN CHUNK.SIZE = MAX.LEN.LSB;

   /* FILL BUFFER WITH FIRST CHUNK */

   IF (MAX.LEN.MSB<>0)
   THEN ACT.BUF.LEN = (-1);
   ELSE ACT.BUF.LEN = MAX.LEN.LSB;       /* SEE MAX # OR SECTORS TO READ */

   IF ACT.BUF.LEN IGT CHUNK.SIZE         /* LIMIT TO CHUNK SIZE */
   THEN ACT.BUF.LEN=CHUNK.SIZE;

   CALL EXT.READDATA(DISK.DEV,DISK.SEC,BUFR.START,0,ACT.BUF.LEN,0);

   IF (COPY.BANK<>0) THEN DO;            /* ALSO SAVE IN EXT MEMORY DURING BANK READ */
      IF (COPY.BANK=BUFR.START) THEN DO; /* WE HAVE SAVED DATA IN EXT MEMORY,  AS REQUESTED */
         COPY.BANK=COPY.BANK+ACT.BUF.LEN;
      END;
      ELSE COPY.BANK=0;
   END;

END PRIME.IO.BUFFER;


PRIME.NEXT.BUFFER:PROC SWAPABLE;          /* HANDLE END OF BUFFER REACHED (I.E. ACT.BUF.LEN=BUF.R.PTR) */

   DCL (I,J) FIXED;

   /* ADD MORE DATA TO BUFFER */
   /* IF THERE IS ROOM        */

   IF ACT.BUF.LEN ILT MAX.BUF.LEN THEN DO;  /* MORE ROOM IN BUFFER - ADD TO IT SO MAYBE WE GET WHOLE BANK IN BUFFER!! */

      IF (MAX.LEN.MSB<>0)
      THEN ACT.BUF.LEN = (-1);
      ELSE ACT.BUF.LEN = MAX.LEN.LSB;       /* SEE MAX # OR SECTORS TO READ */

      IF ACT.BUF.LEN IGT (SHR(BUF.R.PTR,8)+CHUNK.SIZE)  /* BUT IF THAT WOULD MEAN READING MORE THAN A CHUNK */
      THEN ACT.BUF.LEN = (SHR(BUF.R.PTR,8)+CHUNK.SIZE); /* LIMIT IT TO CHUNK SIZE */

      IF   ACT.BUF.LEN IGT MAX.BUF.LEN
      THEN ACT.BUF.LEN  =  MAX.BUF.LEN; 

      I=DISK.DEV; J=DISK.SEC;
      J=J+SHR(BUF.R.PTR,8);
      IF J ILT SHR(BUF.R.PTR,8) 
      THEN I=I+1;

      CALL EXT.READDATA(I,J,BUFR.START,BUF.R.PTR,ACT.BUF.LEN-SHR(BUF.R.PTR,8),0);     /* ADD MORE TO BUFFER */

      IF (COPY.BANK<>0) THEN DO;            /* ALSO SAVE IN EXT MEMORY DURING BANK READ */
         IF (COPY.BANK=BUFR.START+SHR(BUF.R.PTR,8)) THEN DO; /* WE HAVE SAVED DATA IN EXT MEMORY,  AS REQUESTED */
            COPY.BANK=COPY.BANK+ACT.BUF.LEN-SHR(BUF.R.PTR,8);
         END;
         ELSE COPY.BANK=0;
      END;
   END;

   ELSE DO;       /* MUST RE-PRIME BUFFER FROM NEXT SECTOR */

      DISK.SEC = DISK.SEC + ACT.BUF.LEN;  /* ADVANCE DISK POINTER */
      IF DISK.SEC ILT ACT.BUF.LEN
      THEN DISK.DEV = DISK.DEV + 1;
      BUF.R.PTR = 0;                      /* START AT BEGINNING OF NEXT BUFFER */
      
      IF MAX.LEN.LSB ILT ACT.BUF.LEN
      THEN MAX.LEN.MSB = MAX.LEN.MSB - 1;
      MAX.LEN.LSB = MAX.LEN.LSB - ACT.BUF.LEN;

      IF (MAX.LEN.MSB<>0)
      THEN ACT.BUF.LEN = (-1);
      ELSE ACT.BUF.LEN = MAX.LEN.LSB;       /* SEE MAX # OR SECTORS TO READ */

      IF ACT.BUF.LEN IGT CHUNK.SIZE         /* LIMIT TO CHUNK SIZE */
      THEN ACT.BUF.LEN=CHUNK.SIZE;

      CALL EXT.READDATA(DISK.DEV,DISK.SEC,BUFR.START,0,ACT.BUF.LEN,0);

      COPY.BANK=0;
   END;

END PRIME.NEXT.BUFFER;

/* $PAGE - G.NEXT, SKIP.WRDS */

G.NEXT:PROC PUBLIC; /* GET NEXT WORD */

   IF BUF.R.PTR=SHL(ACT.BUF.LEN,8) /* END OF BUFFER REACHED */
   THEN CALL PRIME.NEXT.BUFFER;    /* ADD MORE TO BUFFER,  OR RE-READ IT */

   WRITE(MAM)=BUFR.START+SHR(BUF.R.PTR,8);
   WRITE(MAL)=BUF.R.PTR;
   BUF.R.PTR=BUF.R.PTR+1;      /* INCREMENT POINTER */
   RETURN READ(MD);            /* AND RETURN THE WORD */

END G.NEXT;


G.NEXT.RECORD:PROC(ARR,LEN) PUBLIC SWAPABLE; /* GET NEXT RECORD */
   DCL ARR  ARRAY;
   DCL LEN  FIXED;
   DCL I    FIXED;
   DCL J    FIXED;

   I=0;
   DO WHILE LEN<>0;
      J=SHL(ACT.BUF.LEN,8)-BUF.R.PTR;     /* GET WORDS LEFT IN BUFFER */
      IF J=0 THEN DO;
         CALL PRIME.NEXT.BUFFER;          /* ADD MORE TO BUFFER,  OR RE-READ IT */
         J=SHL(ACT.BUF.LEN,8)-BUF.R.PTR;  /* GET WORDS LEFT IN BUFFER */
      END;
      IF J IGT LEN THEN J=LEN;            /* LIMIT TO LENGTH LEFT     */

      WRITE(MAM)=BUFR.START+SHR(BUF.R.PTR,8);
      WRITE(MAL)=BUF.R.PTR;
      CALL COPY.IN(ADDR(ARR(I)),J);
      BUF.R.PTR=BUF.R.PTR+J;      /* INCREMENT POINTER */
      I        =I        +J;
      LEN      =LEN      -J;
   END;

END G.NEXT.RECORD;


SKIP.WRDS:PROC(NUM) PUBLIC;   /* SKIP N WORDS ON DISK */
   DCL (I,NUM,MAX) FIXED;

   DO WHILE NUM<>0;           /* ADVANCE DISK POINTERS AS REQUIRED */

      MAX=SHL(ACT.BUF.LEN,8)-BUF.R.PTR;  /* GET # OF WORDS LEFT IN BUFFER */
      IF MAX IGT NUM THEN MAX=NUM;       /* LIMIT TO # DESIRED            */

      BUF.R.PTR=BUF.R.PTR+MAX;           /* ADVANCE POINTER               */
      NUM=NUM-MAX;                       /* ACCOUNT FOR IT                */

      IF NUM<>0 THEN DO;                 /* MORE IN BUFFER                */
         CALL G.NEXT;                    /* RELOAD BUFFER, INCREMENT POINTER */
         NUM=NUM-1;                      /* ACCOUNT FOR 1 WORD G.NEXT        */
      END;
   END;
END SKIP.WRDS;

/* $PAGE - ROUTINES TO READ THROUGH TIMBRES ON DISK */


/* THE SYSTEM TRIES TO KEEP THE CURRENT TIMBRE BANK IN MEMORY (IF IT WILL FIT).
.  SOMETIMES (FOR EXAMPLE IF THERE IS NOT ENOUGH MEMORY AVAILABLE,  OR IN
.  THE CASE OF A SELECTIVE TRACK RECALL) IT IS NECESSARY TO READ A VARIABLE
.  LENGTH TIMBRE DIRECTLY FROM THE DISK TO MEMORY.   THESE ROUTINES ARE
.  USED FOR THIS.

    1. SKIP.DISK.PAR  -  SKIPS OVER PARTIAL TIMBRE DURING TIMBRE READ
    2. FIND.DISK.TIM  -  FINDS SPECIFIED TIMBRE # ON DISK */


SKIP.DISK.PAR:PROC PUBLIC SWAPABLE;     /* PROCEDURE TO SKIP OVER 1 PARTIAL TIMBRE ON DISK */
   DCL (I,L,T) FIXED;

   IF G.NEXT=SUP THEN RETURN 0;  /* SUPPRESSED, SKIP IT AND RETURN */

   CALL SKIP.WRDS(P.EPEAKL-1);   /* STEP TO ENVELOPE PEAK WORD */
   I=(G.NEXT\G.NEXT)&1023;       /* GET PEAK AND SUSTAIN */

   CALL SKIP.WRDS(NUM.PARAMS-P.IDELAY); /* SKIP OVER REST OF UNSUPPRESSED TIMBRE */

   DO WHILE G.NEXT=MOR;          /* GET NEXT WORD, ENTER LOOP IF CONTINUATION PARTIAL */
      T=G.NEXT;                  /* GET TYPE FIELD */
      L=G.NEXT;                  /* GET LENGTH FIELD */

      // TAKE A STAB AT DETECTING CORRUPTED FILES
      IF (T == TF.TYPE && L IGT LEN.TIMB.FRAME)
         L = LEN.TIMB.FRAME;

      IF (L ILT PT.LEN)
         L = PT.LEN;

      CALL SKIP.WRDS(L-(CLEN+1)); /* SKIP OVER FRAME */
   END;
   BUF.R.PTR=BUF.R.PTR-1;        /* BACK UP */
   IF G.NEXT=PINFO THEN CALL SKIP.WRDS(PINFO.LEN-1);
   ELSE BUF.R.PTR=BUF.R.PTR-1;   /* RESTORE WORD FOR NEXT GET.NEXT */
   RETURN I;                     /* NON-ZERO MEANS HAVE SOME PEAK OR SUSTAIN */
END SKIP.DISK.PAR;

DCL ABRT.LIMIT  FIXED    PUBLIC;       /* SET TO NONZERO TO ABORT DISKREADING IF BANK WON'T FIT IN MEMORY */
DCL (INDEX.DEV)   (7)    FIXED PUBLIC; /* INDEX CONSTRUCTED BY 'FIND.DISK.TIM' */
DCL (INDEX.SEC)   (7)    FIXED PUBLIC;
DCL (INDEX.PTR)   (7)    FIXED PUBLIC;


FIND.DISK.TIM:PROC(NUMBER) PUBLIC SWAPABLE; /* TIMBRE # - RETURN CORE POINTER TO TIMBRE */
   DCL (I,J,NUMBER,SEC) FIXED;

   SEC=DISK.SEC;            /* SAVE INITIAL DISK LOCATION */
   DO I=0 TO (NUMBER-1);    /* ADVANCE POINTER OVER TIMBRES */
      IF (ABRT.LIMIT<>0)&(I>=ABRT.LIMIT)&(DISK.SEC<>SEC) THEN RETURN; /* STOP READING AFTER DESIRED TIMBRE IF BANK WON'T FIT IN MEMORY */
      IF I<8 THEN DO;       /* STORE 0-7 IN INDEX, IN CASE BANK DOES NOT FIT IN MEMORY */
         INDEX.DEV(I)=DISK.DEV; /* SAVE POINTERS TO TIMBRE */
         INDEX.SEC(I)=DISK.SEC; 
         INDEX.PTR(I)=BUF.R.PTR;
      END;
      DO J=0 TO (NUM.PARTIALS-1); /* LOOP OVER PARTIALS */
         CALL SKIP.DISK.PAR; /* SKIP OVER THE PARTIAL */
      END;    
      IF G.NEXT=TINFO THEN CALL SKIP.WRDS(TINFO.LEN-1);  /* SKIP OVER TIMBRE INFO IF IT'S THERE */
      ELSE BUF.R.PTR=BUF.R.PTR-1;      /* RESTORE WORD FOR NEXT GET.NEXT */
      CALL SKIP.WRDS(NUM.MISC.PARAMS); /* SKIP OVER MISC INFO */
   END;
END FIND.DISK.TIM;

END GPRMMOD;
