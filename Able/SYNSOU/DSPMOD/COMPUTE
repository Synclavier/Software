when break then call exit(0);insert ':synlits:globlits';insert ':synlits:comlits';insert ':synmods:mathdcl';Compute.Compressed.Length: proc (InLen,OutLen,CRatio) public swapable;   dcl InLen     array; /* 32-bit sample count */   dcl OutLen    array; /* Length after compression   */   dcl CRatio    fixed; /* Compression factor 0-65535 */   dcl (I,T) (1) fixed;   dcl BitArray  lit 'loc(addr(BitMsb))';   /* Routine allows INLEN & OUTLEN to be the same */   /* and either or both can be (BITMSB,BITLSB)    */   call Copy32(InLen,I);    /* save copy of original input len */   call Copy32(I,BitArray); /* set up for ratio multiply */   if (CRatio&1)=0 then do; /* even ratio - simple algorithm is accurate */      call ratio_multiply(32768,32768+shr(CRatio,1));   end;   else do; /* odd ratio - use fancy algorithm to maintain precision */      /* Use linear interpolation to compute odd values */      /* compute lengths at both adjacent even CRATIOs  */      /* and then average results.                      */      /* Should be accurate to 32 bits.                 */      call ratio_multiply(32768,32768+shr(CRatio,1));      call Copy32(BitArray,T);         /* save 1st result */      call Copy32(I,BitArray);         /* set up for 2nd ratio multiply */      if CRatio<>65535      then call ratio_multiply(32768,32768+shr(CRatio,1)+1);      else call ratio_multiply(1,2);      call Add32(T,BitArray,BitArray); /* sum of both parts */      call Add16(1,BitArray);          /* to force round up */      call Shr32(BitArray,1);          /* average of the two values */   end;   call Copy32(BitArray,OutLen);       /* copy result to output array */end Compute.Compressed.Length;/* $SUBTITLE */Compute.Expanded.Length: proc (InLen,OutLen,CRatio) public swapable;   dcl InLen     array; /* 32-bit sample count */   dcl OutLen    array; /* Length after compression   */   dcl CRatio    fixed; /* Compression factor 0-65535 */   dcl (I,T) (1) fixed;   dcl BitArray  lit 'loc(addr(BitMsb))';   /* Routine allows INLEN & OUTLEN to be the same */   /* and either or both can be (BITMSB,BITLSB)    */   call Copy32(InLen,I);    /* save copy of original input len */   call Copy32(I,BitArray); /* set up for ratio multiply */   if (CRatio&1)=0 then do; /* even ratio - simple algorithm is accurate */      call ratio_multiply(shr(CRatio,1),32768);   end;   else do; /* odd ratio - use fancy algorithm to maintain precision */      /* Use linear interpolation to compute odd values */      /* compute lengths at both adjacent even CRATIOs  */      /* and then average results.                      */      /* Should be accurate to 32 bits.                 */      call ratio_multiply(shr(CRatio,1),32768);      call Copy32(BitArray,T);         /* save 1st result */      call Copy32(I,BitArray);         /* set up for 2nd ratio multiply */      if CRatio<>65535      then call ratio_multiply(shr(CRatio,1)+1,32768);      else;                            /* otherwise factor is 1.0000 - so do nothing */      call Add32(T,BitArray,BitArray); /* sum of both parts */      call Add16(1,BitArray);          /* to force round up */      call Shr32(BitArray,1);          /* average of the two values */   end;   call Add32(I,BitArray,OutLen);      /* add in original length and copy result to output array */end Compute.Expanded.Length;/* $SUBTITLE */Compute.Ratio.For.Time.Fit: proc (InLen,OutLen,Info) fixed public swapable;   dcl InLen  array; /* Original file length (3 word SFM format) */   dcl OutLen array; /* Desired  file length (3 word SFM format) */   dcl Info   array; /* Output results: Info(0)=compress or expand, Info(1)=ratio */   dcl C.Or.E lit 'Info(0)';   dcl Ratio  lit 'Info(1)';   dcl Status        fixed;   dcl (In,Out)  (1) fixed; /* 32-bit sample count versions of INLEN & OUTLEN */   dcl (Len,X,Y) (1) fixed;   dcl (Num,Den,I)   fixed;   call Convert.SF.Len.To.Samples(InLen ,In);   call Convert.SF.Len.To.Samples(OutLen,Out);   I=Com32(In,Out);       /* compare Input and Output file lengths */   if I = LW#IEQ then do; /* lengths are the same, nothing to do */      C.Or.E=0;           /* use compression */      Ratio =0;           /* identity ratio  */      Status=false;       /* disallow ratios of zero */   end;   else if I = LW#IGT then do; /* original is longer -- need to compress */      C.Or.E=0;                /* want time compression algorithm */      call Compute.Compressed.Length(In,Len,65535); /* compute shortest possible length */      if Com32(Out,Len) = LW#ILT then do;  /* desired compress is impossible */         Ratio =0;         /* identity ratio */         Status=false;     /* cannot perform desired compression */      end;      else do;             /* should be able to do this */         /* Algorithm:                         (Original Len - Desired Len)                 Ratio = ----------------------------   * 65536                                (Desired Len)         */         call Sub32(In,Out,Len);         Num=0;                     /* Scale LEN down to 16-bit value */         do while (Len(0)<>0);            Num=Num+1;            call Shr32(Len,1);         end;         call Copy32(Out,X);         Den=0;                     /* Scale copy of OUT down to 16-bit value */         do while (X(0)<>0);            Den=Den+1;            call Shr32(X,1);         end;         BitMsb=1; BitLsb=0;						/* set up 65536 constant */         call ratio_multiply(Len(1),X(1));	/* scale by ratio of lengths */         call Shr32(loc(addr(BitMsb)),Den-Num);	/* adjust ratio by previous scaling */         Ratio=BitLsb;                    /* first guess at compression ratio */         if Ratio<>65535 then do;         /* test next value so we can round */            call Compute.Compressed.Length(In,Len,Ratio);            if Com32(Out,Len) = LW#IGT    /* compute error with basic ratio */            then call Sub32(Out,Len,X);            else call Sub32(Len,Out,X);            call Compute.Compressed.Length(In,Len,Ratio+1);            if Com32(Out,Len) = LW#IGT    /* compute error with next ratio */            then call Sub32(Out,Len,Y);            else call Sub32(Len,Out,Y);            if Com32(X,Y) = LW#IGT then Ratio=Ratio+1; /* rounding will improve results */         end;                  Status=true;                    /* got a good ratio */      end;   end;                                  /* compute compression ratio */   else do;                /* original is shorter -- need to expand */      C.Or.E=1;            /* want time expansion algorithm */      call Compute.Expanded.Length(In,Len,65535); /* compute greatest possible length */      if Com32(Out,Len) = LW#IGT then do;  /* desired expansion is impossible */         Ratio =0;         /* identity ratio */         Status=false;     /* cannot perform desired compression */      end;      else do;             /* should be able to do this */         /* Algorithm:                         (Desired Len - Original Len)                 Ratio = ----------------------------   * 65536                                (Original Len)         */         call Sub32(Out,In,Len);         Num=0;                     /* Scale LEN down to 16-bit value */         do while (Len(0)<>0);            Num=Num+1;            call Shr32(Len,1);         end;         call Copy32(In,X);         Den=0;                     /* Scale copy of OUT down to 16-bit value */         do while (X(0)<>0);            Den=Den+1;            call Shr32(X,1);         end;         BitMsb=1; BitLsb=0;						/* set up 65536 constant */         call ratio_multiply(Len(1),X(1));	/* scale by ratio of lengths */         call Shr32(loc(addr(BitMsb)),Den-Num);	/* adjust ratio by previous scaling */         Ratio=BitLsb;                    /* first guess at compression ratio */         if Ratio<>65535 then do;         /* test next value so we can round */            call Compute.Expanded.Length(In,Len,Ratio);            if Com32(Out,Len) = LW#IGT    /* compute error with basic ratio */            then call Sub32(Out,Len,X);            else call Sub32(Len,Out,X);            call Compute.Expanded.Length(In,Len,Ratio+1);            if Com32(Out,Len) = LW#IGT    /* compute error with next ratio */            then call Sub32(Out,Len,Y);            else call Sub32(Len,Out,Y);            if Com32(X,Y) = LW#IGT then Ratio=Ratio+1; /* rounding will improve results */         end;                  Status=true;                    /* got a good ratio */      end;   end;                                  /* of compute expansion ratio */   return Status;end Compute.Ratio.For.Time.Fit;dcl (in,out) (2) fixed;dcl (t,x,y)  (2) fixed;dcl ratio        fixed;ratio=1;do while ratio<>0;   print 'In Len (3 words), Ratio',;    input in(0),in(1),in(2),ratio;   call Convert.SF.Len.To.Samples(In,T);   print '32-bit sample count: ',T(0),T(1);   print;   if ratio<>0 then do;      call copy32(T,X);      call Compute.Compressed.Length(X,Y,Ratio);      call Convert.Samples.To.SF.Len(Y,Out);      print 'Compressed: ',Out(0),Out(1),Out(2);      call copy32(T,X);      call Compute.Expanded.Length(X,Y,Ratio);      call Convert.Samples.To.SF.Len(Y,Out);      print 'Expanded:   ',Out(0),Out(1),Out(2);      print;print;   end;end;