/* $Title Debug Routines for L page Modify II *//*  12/13/88 - cj  - changed 'smart' to 'speech'    09/07/88 - SJS - Author */dcl time.seconds          fixed external;dcl time.milliseconds     fixed external;dcl time.microseconds     fixed external;dcl Index_to_Time         proc (fixed,fixed,fixed,fixed,fixed) external;dcl Conv.Fixed.to.Str     proc (fixed,fixed,fixed,fixed,array) external;dcl Append.to.Str         proc (array,array)                   external;dcl Copy.String           proc (array,array)                   external;/* $Page Edit to Symbol rouines */Next.Edits:proc (next.start,next.end) swapable;   dcl next.start       fixed array;   dcl next.end         fixed array;   dcl (msb,lsb,offset) fixed;   /* Upon entry, next.start and next.end hold sample numbers      of the next edit points.  They are converted to sound file times      and stored in the same array.   */   /* convert sample number to msb,lsb, offset */   offset = next.start(1)&255;   call shr32(next.start,8);   msb    = next.start(0);   lsb    = next.start(1);   /*convert to time and set next.start */   call Index_to_Time(msb,lsb,offset,stm.sample.rate,stereo);   next.start(0) = time.seconds;   next.start(1) = time.milliseconds;   next.start(2) = time.microseconds;   /* convert sample number to time */   offset = next.end(1)&255;   call shr32(next.end,8);   msb    = next.end(0);   lsb    = next.end(1);   /*convert to time and set next.end */   call Index_to_Time(msb,lsb,offset,stm.sample.rate,stereo);   next.end(0)   = time.seconds;   next.end(1)   = time.milliseconds;   next.end(2)   = time.microseconds;end Next.Edits;Next.Label:proc (name,val,in.or.out) swapable;   dcl name      fixed array;   dcl val       fixed;   dcl in.or.out fixed;/* 0 = edit in, 1 = edit out */   dcl str(2)    fixed;/* for label synthesis */   if in.or.out = 0 then do;/* in */      call Copy.String ('<',name);      call Conv.Fixed.to.Str(val,0,2,0,str);      call Append.to.Str (name,str);   end;   else do;/* out */      call Copy.String ('>',str);      call Conv.Fixed.to.Str(val,0,2,0,name);      call Append.to.Str (name,str);   end;end Next.Label;Edit.to.Symbol: proc (start.time) public swapable;   dcl start.time        fixed array;   dcl edit.start(2)     fixed;      /* SFTime edit time value */   dcl edit.end  (2)     fixed;   dcl name(4)           fixed;   dcl elist.ms          fixed;   dcl elist.ls          fixed;   dcl (msb,lsb,offset)  fixed;   dcl drop.through      fixed;   dcl endit             fixed;   dcl temp.buf(255)     fixed;   dcl (i,j,k)           fixed;   /* Find Edit List file */   if locate(':.system:.tsmelst',0) then do;/* if found elist file */      elist.ms = f#ms_sector;      elist.ls = f#ls_sector;      call readdata(elist.ms,elist.ls,temp.buf,256);/* read elist into miscbuf */      elist.ls = elist.ls+1;      if elist.ls = 0 then elist.ms = elist.ms+1;/* update address */   end;   else do;/* ERROR no elist file */      call cpos(23,0); call erase.to.end.of.line;      call ps('ERROR - could not find Edit List');      return;   end;   drop.through = -1;j=0;   do while (drop.through < 0);/* Search even values to get start of desired table */      edit.start(1) = temp.buf(j)  ;edit.start(0) = temp.buf(j+1);      edit.end  (1) = temp.buf(j+2);edit.end  (0) = temp.buf(j+3);      j = j+4;      if j ige 256 then do;         call readdata(elist.ms,elist.ls,temp.buf,256);/* read elist into miscbuf */         elist.ls = elist.ls+1;         if elist.ls = 0 then elist.ms = elist.ms+1;/* update address */         j = 0;      end;      call Next.Edits(edit.start,edit.end);/* put next available edit into edit.start,edit.end */      drop.through = Compare_Times(edit.start,start.time,3);/* compare */   end;   endit = 0;   i    = 1;/* init edit counter */   number_of_symbols = 4;   call psmwrite(SFILE.BASE,SF.HDR,sf.number.of.symbols);  /* update the number of symbols */   write(psd)=number_of_symbols;   do while ((not endit) and (number_of_symbols ilt max.symbols-1));      /* set number of symbols to minimum */      call Next.Label(name,i,0);                  /* synth next start label */      call Add_Symbol(SFILE.BASE,edit.start,name);/* add to symbol table */      do;/* #### */         call cpos(23,0);         call ps(name);         call ps(' ');         call print.parm(edit.start(0),0,0,3,0);         call ps('.');         call print_digits(edit.start(1),3);         call ps(' ');         call print_digits(edit.start(2),3);      end;      call Next.Label(name,i,1);                  /* synth next label */      call Add_Symbol(SFILE.BASE,edit.end,name);  /* add to symbol table */      do;/* #### */         call cpos(23,0);         call ps(name);         call ps(' ');         call print.parm(edit.end(0),0,0,3,0);         call ps('.');         call print_digits(edit.end(1),3);         call ps(' ');         call print_digits(edit.end(2),3);      end;      edit.start(1) = temp.buf(j)  ;edit.start(0) = temp.buf(j+1);      edit.end  (1) = temp.buf(j+2);edit.end  (0) = temp.buf(j+3);      i = i + 1;      j = j+4;      if j ige 256 then do;         call readdata(elist.ms,elist.ls,temp.buf,256);/* read elist into miscbuf */         elist.ls = elist.ls+1;         if elist.ls = 0 then elist.ms = elist.ms+1;/* update address */      end;      call Next.Edits(edit.start,edit.end);             /* get start edit */      if  (edit.start(0)=0      and  edit.start(1)=0      and  edit.start(2)=0)      then endit = 1;/* edit list is padded with zeros at the end */   end;end Edit.to.Symbol;Peek.At.DSP70.Memory: proc(mem.space,start,repeat) public swapable;   dcl mem.space      fixed;/* 0=x,1=y,2=p */   dcl start          fixed;/* starting address (decimal) */   dcl repeat         fixed;/* number of samples to read */   dcl secs           fixed;   dcl done           fixed;   dcl poll           fixed;   dcl (i,j,k)        fixed;   /* This procedure takes the above information and peeks into the      DSP70 memory, turning the result into a new sound file.   */   /* 2. Create newf */   call cpos(23,0);/* #### */   call ps('about to lookup sf.info          ');   call tty_wait;   stop 0;   call LOOK.UP.SF.INFO;   secs = shr(repeat,8);   if repeat&"hff" <> 0   then secs = secs+1;   call cpos(23,0);/* #### */   call ps('about to create sound file');   call tty_wait;   stop 1;   if CREATE.SOUND.FILE(secs+shr(BL.POLY,8),stm.sample.rate,0,0)<>0 then do;  /* try to create the output file */      call cpos(23,0);/* #### */      call ps('sound file created        ');      call tty_wait;      stop 2;      call PS.LOCK;/* lock out reboot, etc... */      call LOOK.UP.SF.INFO;      call psmwrite(SFILE.BASE,4,0);/* set up for data from the DSP70 */      disable;      call Select.DSP70;   end;   else do;      call cpos(23,0);/* #### */      call ps('sound file create failed     ');      call tty_wait;      stop 3;      return 0;   end;   /* 3. Start process,send data */   call dsp.write(cvr,"h99");/* host command vector h32 */   call dsp.write(icr,"h82");/* init host port, set treq */   write (DSPCtl)  = DSPWrite|DSP32SE;   write (DSPData) = start;   write (DSPData) = mem.space;   write (DSPData) = repeat;   write (DSPData) = 0;   /* 4. Poll, read data into poly */   done = false;   j    = 0;   call cpos(23,0);/* #### */   call ps('                                 ');   do while not done;      poll = dsp.read(isr);      call cpos(23,0);/* #### */      call pnum(j,0);call pnum(poll,0);      call tty_wait;      if (poll&"h18") = "h08" then do;/* read data from DSP70 */         call dsp.write(icr,"h89");/* ack hf0 */         write (DSPCtl) = DSPRead|DSP16ZF;         do while repeat <> 0;            if repeat >= 256 then do;               rpc 256;               write(psd) = read(DSPData);               repeat = repeat-256;            end;            else do;               rpc repeat;               write(psd) = read(DSPData);               repeat = repeat-repeat;            end;         end;         call dsp.write(icr,"h81");/* clear hf0 */      end;      if poll&"h18" = "h18" then do;         done = true;      end;      j = j+1;   end;   return 1;end Peek.At.DSP70.Memory;