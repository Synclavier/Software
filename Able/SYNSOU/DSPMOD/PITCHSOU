/* $Title Pitch detction subroutine    This routine will determine the fundamental pitch of a sound   buffer beginning at the time value passed to it.*//*   12/13/88 - cj  - changed 'smart' to 'speech'     10/17/88 - SJS - Author */dcl Time_to_Index         proc(fixed,fixed,fixed,fixed,fixed) external;dcl sector.msb            fixed external;dcl sector.numb           fixed external;dcl sector.offset         fixed external;PITCH.DETECT: proc(base,start.time) public swapable;   dcl base                array;/* start of sound file in poly */   dcl start.time          array;/* time pointer to start of buffer in sound file */   dcl (offset)            fixed;   dcl period              fixed;/* result of pitch detection */   dcl poll                fixed;   dcl done                fixed;   dcl in.len(1)           fixed static;   dcl l.or.r              fixed static;   dcl rptr                fixed static;/* for compatability with Send.Next.Block */   dcl rlimit              fixed static;/* read limit for poly memory */   dcl points              fixed static;/* number of samples to use for pitch detect */   dcl temp                fixed;   dcl (i,j,k)             fixed;   /* $PAGE (Note: this proc was stolen verbatim from TSMSOU */   Send.Next.Block.To.DSP70: proc(stereo);      /* transfers 256 samples to DSP70 */      dcl stereo  fixed;      dcl (i,j,k) fixed;      /* assumes that DSP70 is set up to receive data  */      /* and that poly memory read ptr has been set up */      /* Only sends every other word if stereo file */      call dsp.write(icr,"h92");        /* set hf1 */      write(DSPCtl) = DSPWrite|DSP16SE; /* set mods for xfer */      do k=0 to (stereo<>0);            /* loop once; twice if stereo file */         if rptr ilt (rlimit-1) then do;   /* up to but not last sector */            do i=0 to 255 by xfer.chunk;   /* send 1 sector, or 1/2 sector if stereo */               if use.poly then do;                  if stereo = 0 then do;   /* regular mono file: fastest */                     RPC xfer.chunk;       /* send whole sector */                     write(DSPData) = read(psd);  /* write data to DSP70 */                  end;                  /* Left side of stereo file: send ODD numbered words */                  else if L.or.R = 0 then do j = 1 to xfer.chunk by 2;                     write(DSPData)  = read(psd);  /* write odd data to DSP70 */                     write("300")    = read(psd);  /* skip even data */                  end;                  /* Right side of stereo file: send EVEN numbered words */                  else do j = 1 to xfer.chunk by 2;                     write("300")    = read(psd);  /* skip odd data */                     write(DSPData)  = read(psd);  /* write even data to DSP70 */                  end;               end;               else do;                    /* using external memory */                  if stereo = 0 then do;   /* regular mono file: fastest */                     RPC xfer.chunk;       /* send whole sector */                     write(DSPData) = read(mdi);     /* write data to DSP70 */                  end;                  /* Left side of stereo file: send ODD numbered words */                  else if L.or.R = 0 then do j = 1 to xfer.chunk by 2;                     write(DSPData) = read(mdi);  /* write odd data to DSP70 */                     write("300")    = read(mdi);  /* skip even data */                  end;                  /* Right side of stereo file: send EVEN numbered words */                  else do j = 1 to xfer.chunk by 2;                     write("300")    = read(mdi);  /* skip odd data */                     write(DSPData)  = read(mdi);  /* write even data to DSP70 */                  end;               end;       /* of external memory */            end;          /* of loop once for sector */            rptr=rptr+1;                    /* advance read ptr */         end;             /* of not up to last sector yet */         else if rptr=(rlimit-1) then do;   /* send last sector - partial */            i=0;                            /* i = word pointer in sector */            j=0;                            /* j = words written to 56000 */            do while i ilt (in.len(1) & "hff");  /* write last words in sector */               /* Doing right of stereo, skip over ODD word */               if (stereo <> 0) & (L.or.R = 1) then do;                  if use.poly                  then write("300") = read(psd);                  else write("300") = read(mdi);               end;               if use.poly               then write(DSPData) = read(psd); /* write data to 56K */               else write(DSPData) = read(mdi);               /* Doing left of stereo, skip over EVEN word */               if (stereo <> 0) & (L.or.R = 0) then do;                  if use.poly                  then write("300") = read(psd);                  else write("300") = read(mdi);               end;               i = i + 1 + (stereo <> 0);        /* we've processed 1 word; 2 if stereo */               j = j + 1;                        /* we've sent 1 word to the 56000 */            end;            do i=j to shr(255,(stereo<>0)); /* zero fill rest of sector (1/2 sector if stereo) */               write(DSPData) = 0;         /* write data to DSP70 */            end;            rptr=rptr+1;                    /* advance read ptr */         end;         else do;                           /* input file is shorter than 8 sectors - finish priming with zeroes */            do i=0 to 255 by xfer.chunk;    /* send 1 sector in chunks (1/2 sector if stereo) */               RPC shr(xfer.chunk,(stereo<>0));               write(DSPData) = 0;         /* write data to DSP70 */            end;         end;      end;                                  /* of loop: twice if stereo */      call dsp.write(icr,"h82");   end Send.Next.Block.To.DSP70;   points = 2048;   /* check to see that the value is in bounds */   /* convert time to sample number, address samples */   call Time_to_Index(start.time(0),start.time(1),start.time(2),stm.sample.rate,stereo);   temp       = sector.msb;/* trash this since poly sf < 32MB */   in.len(0)  = sector.numb;   in.len(1)  = sector.offset;   call psmread(base,(in.len(0)+4),in.len(1));   disable;   call Select.DSP70;   /* boot DSP70 with pitch detect code */   if Load.DSP70('PITCH') <> TRUE then return 0;   call dsp.write(cvr,"h92");   /* download tables to DSP70 */   if File.Search('.TSMDATA',3,-2,0,1)   then do;                        /* sine/cosine table and hanning window coefs */      TSMData_There = true;        /* data file found */      TSMData_MS    = F#MS_Sector;      TSMData_LS    = F#LS_Sector;      TSMData_Words = F#Words;      if TSMData_Words=0 then TSMData_Words=shl(F#LS_Length,8);   end;   call Download.TSM.Data;   /* download buffer to DSP70 */   l.or.r = 0;              /* if stereo force left channel for now */   rptr   = 0;              /* init sector counter */   rlimit = shr(points,8)+1;/* Kludge for send.next.block */   do while points > 0;      call Send.Next.Block.to.DSP70(stereo);      points = points-256;   end;   /* poll until DSP70 returns a value */   done = false;   do while done = false;      poll =  dsp.read(isr);      if (poll&"h18")   = "h18" then do;         call dsp.write(icr,"h99");         call dsp.write(icr,"h89");/* assume dsp70 will get there first */         write (DSPCtl) = DSP16SE|DSPRead;         period         = read(DSPData);         done           = true;      end;   end;   return period;end PITCH.DETECT;