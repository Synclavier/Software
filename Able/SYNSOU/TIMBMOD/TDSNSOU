/* TDSNSOU $TITLE  Numeric Display Screen (TDS) Code *//*   06/29/88 - MWH - Remove unused inserts   05/18/88 - LSS - insert -XPL:SYSLITS   02/20/87 - BSW - created this module*/Module TDSNMOD;   insert ':-xpl:syslits';      /* for mouse stuff */   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:asciilit';  /* ASCII literals */   insert ':synlits:globlits';  /* good globals */   insert ':synlits:prmlits';   /* literals for timbre data structure */   insert ':synlits:timlits';   /* timbre head literal definitions (i.e., tim.synth.type) */   insert ':synlits:statelit';  /* input state literals */   insert ':synlits:lpnlits';   /* literals for logical parameter numbers (i.e., hgs1.l) */   insert ':synauxs:timblits';  /* numeric timbre frame display literals  */   insert ':synmods:globdcl';   /* globals such as token */   insert ':synmods:moussdcl';  /* general mouse routines */   insert ':synmods:scrndcl';   /* screen primitive routines (i.e., print.parm) */   insert ':synmods:errdcl';    /* error handling routines */   insert ':synmods:ttydcl';    /* terminal i/o routines   */   insert ':synmods:tprimdcl';  /* terminal primitives used by all screens */   insert ':synmods:plotdcl';   /* plotting - for clear.term!! */   insert ':synmods:getdcl';    /* next.event.info */   insert ':synmods:getvdcl';   /* get.next.event global variables */   insert ':synmods:xmemdcl';   /* external memory routines */   insert ':synmods:linkdcl';   /* parse parameter          */   insert ':synmods:tdsudcl';   /* timbre display procedures used by both Numeric and Graphic Display Modules */   insert ':synrdcls:03-pdcls';   insert ':synrdcls:04-sdcls';   insert ':synrdcls:05-bdcls';   dcl tds.mode        fixed;   /* current mode: 0=ALPHANUMERIC, 1=GRAPHICS */   dcl tds.parm#       fixed;   /* current logical parm number */   dcl tds.pt#         fixed;   /* current partial      number */   dcl tds.frame#      fixed;   /* current timbre frame number */   dcl max.tlen        fixed;   /* maximum chars allowed in TOKEN() for current field */   dcl last.parm#      fixed;   /* last Synclavier parm to be selected */   /* $page */   SET.MAX.TLEN:  proc (tds.choice) swapable; /* sets the var MAX.TLEN to correct value */      /* NOTE:  This procedure looks at TDS.PARM#         to determine the proper max length for TOKEN() */      dcl tds.choice fixed;  /* considered screen */      dcl max.tlen.values data (0,7,0,5,6,6,2,5,5,5,4,0,0,0,2,4,2,3); /* maximum values for numeric display */      if (tds.choice=s.tds.afram) and (tds.parm#=5) then max.tlen=6;      else if tds.parm#<24 then max.tlen=5;      else max.tlen=max.tlen.values(tds.parm#-24);   end SET.MAX.TLEN;   MAP.SYN.TO.COMP:  proc(prm#) fixed swapable; /* maps Synclavier parm# to comparative parm # */      dcl prm# fixed;      dcl map  data (25,30,31,32,34,-1,-1,28,-1,29,-1,41,40,38,39,-1,-1,-1,-1,27,33,-1,-1);      /* NOTE:  Returns (-1) if no mapping defined for this display */      /* first 24 parms map directly */      if prm#>56 then prm#=(-1); /* these parms are all unused by TDS */      else do;         if prm#>=24 and prm#<36 then prm#=prm#-12;      /* 2nd 12 harmonic coefs map to 12-23 */         if prm#>=36             then prm#=map(prm#-36); /* others map all over */      end;      return prm#;   end MAP.SYN.TO.COMP;   MAP.COMP.TO.SYN:  proc(prm#) fixed swapable; /* maps comparative parm# to Synclavier parm# */      dcl prm# fixed;      dcl map data(36,-1,55,43,45,37,38,39,56,40,37,37,37,49,50,48,47);      if (prm#>=12) and (prm#<=23) then do;         write(mam)=trd.ptr+1; write(mal)=8; /* offset parm # for HGS value */         prm#=prm#+read(md)*12;      end;      else if (prm#>=25) and (prm#<>26) /* if a partial paramter setting and not pitch randomness */      then prm#=map(prm#-25); /* valid remapping */      else if prm#=26 then prm#=-1; /* if pitch randomness then invalid mapping */      return prm#;   end MAP.COMP.TO.SYN;   SELECT.COMPARATIVE.PARAMETER:  proc(par#,parm#) swapable;      dcl (par#,parm#) fixed;      if  (num.of.d50.in.chars<>0)             /* input char waiting */      and ((next.d50.in.char = u.arr)      or   (next.d50.in.char = d.arr)      or   (next.d50.in.char = r.arr)      or   (next.d50.in.char = l.arr)      or   (next.d50.in.char = home ))      then return;                             /* save time if we will return here immediately anyways */      if par#<>-1 then call SELECT.PARTIAL(par#);      parm#=MAP.COMP.TO.SYN(parm#);      if parm#<>-1 then do;         call SELECT.PARAMETER(parm#);         last.parm#=parm#; /* save last selected parm */      end;   end SELECT.COMPARATIVE.PARAMETER;   /* $Subtitle Numeric Display Cursor Handling Routine */   dcl comp.parm.x.coord data (0,3,0,11,17,24,31,36,42,48,54,59,60,61,64,68,74,77);   POS.COMPARATIVE.CURSOR:  proc swapable; /* position cursor correctly on menu */      if inc.tds=0 then return;      if tds.pt#<>-1 then do;         if      tds.parm#<12 then call cpos( 6+tds.pt#*3+tds.parm#/6,5+(tds.parm# mod 6)*6);         else if tds.parm#<24 then call cpos( 6+tds.pt#*3+(tds.parm#-12)/6,44+((tds.parm#-12) mod 6)*6);         else                      call cpos(20+tds.pt#,comp.parm.x.coord(tds.parm#-24));         call run.syn.loop;                  if token(0)<>0 then do; /* have some chars to display */            call ps(token);            call run.syn.loop;         end;      end;      else call POS.CHOICE.CURSOR(2);   end POS.COMPARATIVE.CURSOR;   /* $SUBTITLE  Routine to Label Harmonic Coefs on Comparative Display */   LABEL.HARMONICS:  proc swapable; /* prints correct label for harmonic coefs */      dcl h.c data('Harmonic Coefficients');      /* NOTE: This routine is used for COMPARATIVE display */      call cpos(5,43); /* draw frame for harmonic coefs */      if  (new.prm.info      = 0)      and (new.ABLE.prm.info = 0)      then call run.syn.loop;      if vt100 then do;         call CH.SET(alt); call DRAW.CORNER(c.u.l);         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;      end;      else call pc(sp);      call DRAW.HOR(2);      call CH.SET(norm);      if  (new.prm.info      = 0)      and (new.ABLE.prm.info = 0)      then call run.syn.loop;      if hgs=0      then do; call ps(' 1st 12 '); call ps(h.c); call pc(sp); end;      else do;         call pc(sp); call ps(h.c); call ps(' #');         call pnum(hgs*12+1,0);     call pc(asc.min);         call pnum((hgs+1)*12,0); call pc(sp);         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;      end;      call CH.SET(alt);  call DRAW.HOR(3);      if  (new.prm.info      = 0)      and (new.ABLE.prm.info = 0)      then call run.syn.loop;      if vt100 then call DRAW.CORNER(c.u.r);      call CH.SET(norm);      if  (new.prm.info      = 0)      and (new.ABLE.prm.info = 0)      then call run.syn.loop;      tds.change=1; /* denote change in screen */   end LABEL.HARMONICS;   /* $SUBTITLE  TDS Comparative Display Routine */   COMPARATIVE.DISPLAY:  proc public swapable; /* draw frame for comparative display */      dcl (i,j) fixed;      if inc.tds=0 then return;      call clear.term;      call cpos(0,28);      call DRAW.FRAME(2,'NUMERIC TIMBRE DISPLAY',2);      call cpos(1,0);      call ps('Press arrow key to move cursor and enter value. ');      call ps('Press <');      if vt100<>0 then call ps(ENTER.STR); else call ps(DBL.ESC);      call ps('> for Main Menu.');      call DRAW.MENU.SELECTION(2); /* draw menu selection line */      call cpos(3,0);      call DRAW.HOR(19);      call cpos(3,19);      call ps('  Timbre:  '); call PRINT.TIMBRE.NAME(3,31); call pc(sp); call pc(sp);      call cpos(3,63);      call DRAW.HOR(17);      call cpos(5,0);      if vt100 then do;         call ps('  ');; /* draw frame for envelope data */         call CH.SET(alt); call DRAW.CORNER(c.u.l); call DRAW.HOR(1); call CH.SET(norm);       end;      else call ps('    ');      call ps(' Delay Attck  IDec  FDec  Peak Sust ');      if vt100 then call DRAW.CORNER(c.u.r);            call LABEL.HARMONICS; /* draw harmonic label */      do i=1 to 4; /* loop over partials */         call cpos(6+(i-1)*3,0);         call pc(asc.0+i); call pc(dot); call pc(sp); call pc(asc.v);         call cpos(7+(i-1)*3,3);                      call pc(asc.h);      end;            call cpos(18,3); call DRAW.FRAME( 9,' Partial ', 9); /* draw frame for partial misc info */      call pc(sp);     call DRAW.FRAME(11,' Vibrato ',11); /* draw frame for vibrato info */      call pc(sp);     call DRAW.FRAME( 4,' Stereo ' , 5); /* draw frame for stereo info */      /* $PAGE */      call cpos(19,3);      do i=0 to 13; /* loop over fields */         do case i;            /* misc fields */            call ps('Tuning '); do; call pc(bs); call ps('Volume'); end;            call ps('FM Rat');  call ps('Chorus');            /* vibrato fields */            call ps('Wave');    call ps('Rate ');            call ps('Depth');   call ps('MDep ');            call ps('Attk');    call ps('IQB');            /* stereo fields */            call ps('Wave');    call ps('Rate');            call ps('Dep');     call ps('Pan');         end;         if (i<>3) and (i<>9) and (i<>13) then do;            call pc(lf);            if vt100<>0 then call CH.SET(alt);            do j=0 to 3;               if vt100<>0 then call pc("170");               else             call pc("174");               if j<>3 then do; call pc(bs); call pc(lf); end;            end;            if vt100<>0 then call CH.SET(norm);            do j=0 to 3;         /* step cursor back up screen */               if vt100 then do;                  screen.dump=0;                  call pc(esc); call pc(asc.lbr); call pc(asc.a);                  screen.dump=1;                  screen.y=screen.y-1;               end;               else call pc("13");            end;         end;         else if (i=3) or (i=9) then do;            if vt100<>0 then do; /* draw vertical line to separate sections */               call pc(lf);               do j=0 to 3;                  call pc("174");                  if j<>3 then do; call pc(bs); call pc(lf); end;               end;               do j=0 to 3;      /* step cursor back up screen */                  if vt100 then do;                     screen.dump=0;                     call pc(esc); call pc(asc.lbr); call pc(asc.a);                     screen.dump=1;                     screen.y=screen.y-1;                  end;                  else call pc("13");               end;            end;            else call pc(sp);    /* just step over one extra space */         end;      end;      /* $page */      do i=1 to 4;         call cpos(19+i,0); call pc(asc.0+i); call pc(dot);       end;      /* snap shot of timbre is at TRD.PTR, current display is at TRD.PTR+1 */      write(mam)=trd.ptr;      do i=0 to 3; write(mdi)=0;    end; /* first 4 wds tell which partials are displayed */      do i=0 to 3; write(mdi)=(-1); end; /* next 4 wds tell if any timbre frames on partial */      write(mdi)=hgs;                    /* sample current HGS */      write(mam)=trd.ptr+1;      do i=0 to 3; write(mdi)=0;    end; /* first 4 wds tell which partials are displayed */      do i=0 to 3; write(mdi)=(-1); end; /* next 4 wds tell if any timbre frames on partial */      write(mdi)=hgs;                    /* sample current HGS */      i=active.parms(0);                 /* init selected parameter if applicable */      if i<>0 then do; /* have an active parameter */         i=shr(active.parms(i),8);         if (i>=12) and (i<24) then i=i+hgs*12; /* adjust parm# for HGS */         j=MAP.SYN.TO.COMP(i);         if j<>-1 then do; /* have a valid mapping */            last.parm#=i; tds.parm#=j;         end;      end;      tds.pt#=-1; /* initialize the current partial to an illegal value */      tds.choice=1; tds.last.choice=1;  /* set menu selection to display screen */      call POS.CHOICE.CURSOR(2);      if D44_PRESENT      then call PLOT.MOUSE.HOLE(mouse.hole.lowerx,mouse.hole.lowery); /* plot a mouse hole if device available */      new.prm.info = new.prm.info \ "37";          /* force update */   end COMPARATIVE.DISPLAY;   /* $SUBTITLE  Routine to Change a Specific Parameter in Synclavier Timbre */   UPDATE.COMP.PARM:  proc(sec,pt#,parm#,new.val) swapable; /* puts new value into display area */      dcl sec   fixed; /* base sector in ext mem of parms */      dcl pt#   fixed;      dcl parm# fixed;      dcl base  fixed;      dcl new.val fixed;      write(mam)=sec;      base=16+pt#*60;                     /* base ptr for partial */      if parm#<24 then do;                /* get envelope info and harmonic coefs */         write(mal)=8; sec=read(md);      /* look up sampled HGS value */         if parm#<12 then write(mal)=base+parm#;         else             write(mal)=base+parm#+sec*12;         if (parm#=4) or (parm#=5) or (parm#>9) /* E.PEAKL,E.SUSTL,IPEAKL,ISUSTL, or COEF */         then write(md)=(read(md)&"176000")\new.val; /* only lower 10 bits are used */         else write(md)=new.val; /* all 16 bits are used */      end;      else do;         base=16+pt#*60+36;          /* jump over envelope and coef data */         do case (parm#-24);          /* handle other parms individually */            do; /* 24: NUMBER OF TIMBRE FRAMES */               write(mal)=base+12; write(md)=new.val;            end;            do; /* 25: PARTIAL TUNING          */               write(mal)=base; write(md)=new.val;            end;            do; /* 26: PITCH RANDOMNESS        */               write(mal)=base+13; write(md)=new.val;            end;            do; /* 27: PARTIAL VOLUME          */               write(mal)=base+10; write(md)=new.val;            end;            do; /* 28: FM RATIO                */               write(mal)=base+7; write(md)=new.val;            end;            do; /* 29: PARTIAL CHORUS          */               write(mal)=base+9; write(md)=new.val;            end;            do; /* 30: VIBRATO WAVE            */               write(mal)=base+1; write(md)=(read(md)&"177760")\new.val;            end;            do; /* 31: VIBRATO RATE            */               write(mal)=base+2; write(md)=new.val;            end;            do; /* 32: VIBRATO DEPTH           */               write(mal)=base+3; write(md)=new.val;            end;            do; /* 33: VIBRATO MODULATOR DEPTH */               write(mal)=base+11; write(md)=new.val;            end;            do; /* 34: VIBRATO ATTACK          */               write(mal)=base+4; write(md)=new.val;            end;            do; /* 35: VIBRATO INVERT   BIT    */               write(mal)=base+1; write(md)=(read(md)&(not "20"))\shl((new.val<>0),5);            end;            do; /* 36: VIBRATO QUANTIZE BIT    */               write(mal)=base+1; write(md)=(read(md)&(not "40"))\shl((new.val<>0),5);            end;            do; /* 37: VIBRATO BIAS     BIT    */               write(mal)=base+1; write(md)=(read(md)&(not "100"))\shl((new.val<>0),6);            end;            do; /* 38: STEREO WAVE             */               write(mal)=base+1; write(md)=(read(md)&"177")\shl(new.val,7);            end;            do; /* 39: STEREO RATE             */               write(mal)=base+6; write(md)=(read(md)&"1777")\shl(new.val,10);            end;            do; /* 40: STEREO DEPTH            */               write(mal)=base+5; write(md)=(read(md)&"177")\shl(new.val,7);            end;            do; /* 41: STEREO PAN              */               write(mal)=base+5; write(md)=(read(md)&"177003")\shl(new.val,2);            end;            /* $page */            do; /* 42: PORTAMENTO ON/OFF       */               write(mal)=base+5; write(md)=(read(md)&"177770")\new.val;            end;            do; /* 43: PORTAMENTO MODE         */               write(mal)=base+5; write(md)=(read(md)&"177770")\shl(new.val,1);            end;            do; /* 44: PORTAMENTO RATE         */               write(mal)=base+6; write(md)=(read(md)&"176000")\new.val;            end;         end;      end;   end UPDATE.COMP.PARM;   /* $SUBTITLE  Routine to Print TDS Parm in Correct Format */   DISPLAY.COMP.PARM:  proc(pt#,parm#,val) swapable; /* draws a parameter on screen */      dcl pt#   fixed; /* partial number of parameter */      dcl parm# fixed; /* parameter number */      dcl val   fixed; /* value of parameter */            tds.change=1;      if parm#<12 then do; /* draw envelope parameter */         call cpos(6+pt#*3+parm#/6,5+(parm# mod 6)*6);         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;         if (parm#=4) or (parm#=5)         then call print.parm(val,0,0,5,1);         else do;            if (parm#=1) or (parm#=7) then do;               load val; mul 36864; val=read(4);            end;            call print.parm(val,0,0,5,0);         end;         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;      end;      else if parm#<24 then do; /* draw harmonic coefficient */         call cpos(6+pt#*3+(parm#-12)/6,44+((parm#-12) mod 6)*6);         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         write(mam)=trd.ptr+1; write(mal)=pt#+4; /* look up partial type */         if read(md)=pt.type                     /* have a patch partial */         then call ps('     ');                  /* don't display harm coef */         else call print.parm(val,0,0,5,1);         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;      end;      else do; /* all other parameters */         call cpos(20+pt#,comp.parm.x.coord(parm#-24));         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         do case parm#-24;            ;                             /* 24: NUMBER OF TIMBRE FRAMES */            call print.parm(val,0,1,7,1); /* 25: PARTIAL TUNING */            ;                             /* 26: PITCH RANDOMNESS */            call print.parm(val,0,0,5,1); /* 27: PARTIAL VOLUME */            if val>=0                     /* 28: FM RATIO       */            then call print.parm(val,0,0,6,3); /* positive FM Ratios (16.000) */            else call print.parm(val,0,1,6,1); /* negative FM Ratios (-999.9) */            call print.parm(val,0,0,6,3); /* 29: PARTIAL CHORUS */            do;                           /* 30: VIBRATO WAVE   */               if (val=10) or (val=11) then call ps('Rnd');               else do case (val mod 5);                  call ps('Sin');                  call ps('Tri');                  call ps('Saw');                  call ps('ISw');                  call ps('Sqr');               end;               if (val>4) and (val<>10)               then call pc(asc.2);               else call pc(sp);            end;            call print.parm(val,0,0,5,2); /* 31: VIBRATO RATE   */            call print.parm(val,0,0,5,2); /* 32: VIBRATO DEPTH  */            call print.parm(val,0,0,5,2); /* 33: VIBRATO MODULATOR DEPTH */            call print.parm(val,0,0,4,0); /* 34: VIBRATO ATTACK */            do;                           /* 35: VIBRATO INVERT   BIT */               if val<>0 then call pc(asc.i);               else           call pc(sp);            end;            do;                           /* 36: VIBRATO QUANTIZE BIT */               if val<>0 then call pc(asc.q);               else           call pc(sp);            end;            do;                           /* 37: VIBRATO BIAS     BIT */               if val<>0 then call pc(asc.b);               else           call pc(sp);            end;            /* $PAGE */            call print.parm(val,0,0,2,0); /* 38: STEREO WAVE    */            call print.parm(val*10,0,0,4,2); /* 39: STEREO RATE    */            call print.parm(val,0,0,2,0); /* 40: STEREO DEPTH   */            do;                           /* 41: STEREO PAN     */               if val>64 then val=val-128;               call print.parm(val,0,1,3,0);            end;         end;         if  (new.prm.info      = 0)         and (new.ABLE.prm.info = 0)         then call run.syn.loop;         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;      end;   end DISPLAY.COMP.PARM;   /* $SUBTITLE  Routines to Display and Erase Complete Partials from TDS Display */   REMOVE.COMP.PARTIAL:  proc(pt#) swapable; /* called to erase partial display from screen */      dcl (pt#,i) fixed; /* partial display to erase */      REMOVE.COMP.PARM:  proc(parm#,pt#); /* removes a parameter from screen */         dcl (parm#,pt#) fixed; /* parameter number, partial# */                  p.sp: proc(num); /* prints NUM spaces */            dcl num fixed;            do num=1 to num; call pc(sp); end;         end p.sp;         if parm#<24 then do;            if parm#<12             then call cpos(6+pt#*3+parm#/6,5+(parm# mod 6)*6); /* pos for env parm */            else call cpos(6+pt#*3+(parm#-12)/6,44+((parm#-12) mod 6)*6); /* pos for harm coef */            if  (new.prm.info      = 0)            and (new.ABLE.prm.info = 0)            then call run.syn.loop;            if (new.timbre.info      <> 0)            or (new.ABLE.timbre.info <> 0)            then return;            call p.sp(5);       /* print spaces over field */            if  (new.prm.info      = 0)            and (new.ABLE.prm.info = 0)            then call run.syn.loop;            if (new.timbre.info      <> 0)            or (new.ABLE.timbre.info <> 0)            then return;         end;         else begin; /* all other parameters */            call cpos(20+pt#,comp.parm.x.coord(parm#-24));            if  (new.prm.info      = 0)            and (new.ABLE.prm.info = 0)            then call run.syn.loop;            do case parm#-24;               ;             /* 24: NUMBER OF TIMBRE FRAMES */               call p.sp(7); /* 25: PARTIAL TUNING */               ;             /* 26: PITCH RANDOMNESS */               call p.sp(5); /* 27: PARTIAL VOLUME */               call p.sp(6); /* 28: FM RATIO       */               call p.sp(6); /* 29: PARTIAL CHORUS */               call p.sp(4); /* 30: VIBRATO WAVE   */               call p.sp(5); /* 31: VIBRATO RATE   */               call p.sp(5); /* 32: VIBRATO DEPTH  */               call p.sp(5); /* 33: VIBRATO MODULATOR DEPTH */               call p.sp(4); /* 34: VIBRATO ATTACK */               call pc(sp);  /* 35: VIBRATO INVERT   BIT */               call pc(sp);  /* 36: VIBRATO QUANTIZE BIT */               call pc(sp);  /* 37: VIBRATO BIAS     BIT */               call p.sp(2); /* 38: STEREO WAVE    */               call p.sp(4); /* 39: STEREO RATE    */               call p.sp(2); /* 40: STEREO DEPTH   */               call p.sp(3); /* 41: STEREO PAN     */            end;            if  (new.prm.info      = 0)            and (new.ABLE.prm.info = 0)            then call run.syn.loop;            if (new.timbre.info      <> 0)            or (new.ABLE.timbre.info <> 0)            then return;         end;      end REMOVE.COMP.PARM;      tds.change=1;      do i=0 to 41;         if (i<>24) and (i<>26) then call REMOVE.COMP.PARM(i,pt#);         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;      end;   end REMOVE.COMP.PARTIAL;   DISPLAY.COMP.PARTIAL:  proc(pt#) swapable; /* called to draw all parms for partial display */      dcl pt# fixed; /* partial display to draw */      dcl i   fixed;      /* copy values from snap.shot area to display area when first drawn */      write(mam)=trd.ptr; write(mal)=16+pt#*60;      /* point to snap shot area parms for this partial */      call copy.in(addr(misc.buf(0)),num.params+2);  /* copy parms to temp buf */      write(mam)=trd.ptr+1; write(mal)=16+pt#*60;    /* point to display area parms for this partial */      call copy.out(addr(misc.buf(0)),num.params+2); /* copy temp buf to display area */      do i=0 to 41;         if (i<>24) and (i<>26)         then call DISPLAY.COMP.PARM(pt#,i,EXTRACT.COMP.PARM(trd.ptr+1,pt#,i));         if (new.timbre.info      <> 0)         or (new.ABLE.timbre.info <> 0)         then return;      end;   end DISPLAY.COMP.PARTIAL;   insert ':synsou:timbmod:TDSNSOUA';         /* more numeric comparative display routines */   insert ':synsou:timbmod:TDSNSOUB';         /* timbre frame routines*/   /* $Subtitle Activate Numeric Timbre Display */   TDS.NUMERIC.DISPLAY:  PROC(arg) PUBLIC SWAPABLE;  /* call to activate STM */      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.tds=0 then do;         call feature.not.available;         return (-1);      end;      call COMPARATIVE.DISPLAY;     /* draw frame for comparative display */      call POS.COMPARATIVE.CURSOR;  /* position cursor */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.new.timbre.info,  /* new kbd timbre/partial   */                               get.ertyp);           /* errors            */      call GET_ENABLE(get.prm.info);                 /* timbre parameter change ->tds.update*/      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call COMPARATIVE.DISPLAY.INPUT(in.chin,next.event.info);  /* state 08 - TDS Alpha Comparative Display */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call COMPARATIVE.DISPLAY.MOUSE.POS (mouse(release.x),mouse(release.y));/* TDS Alpha Comparative Display Mouse Positioner */            end;            ;                          /* mouse movement not used */            do;                        /* new timbre info     */               call PRINT.TIMBRE.NAME(3,31);  /* display new name */               call POS.COMPARATIVE.CURSOR;   /* reposition cursor */               new.ABLE.prm.info = new.ABLE.prm.info\"37";/* force an update    */            end;            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            do;               call UPDATE.COMPARATIVE.DISPLAY;   /* tds update      */               if tds.change<>0 then do;        /* have drawn something on screen */                  tds.change=0;                   call POS.COMPARATIVE.CURSOR;  /* reposition cursor */               end;            end;            ;                          /* dtd info - nothing      */            ;                          /* poly change- nothing    */            do;                        /* error message to display */               call Handle.System.Error.Codes(Next.Event.Info);               call POS.COMPARATIVE.CURSOR;            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.new.timbre.info,                                 get.ertyp);             call GET_DISABLE(get.prm.info);   /* timbre parameter change */      EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      return GOTO.THIS.SCREEN;   end TDS.NUMERIC.DISPLAY;   /* $Subtitle Activates Timbre Frame Screen */   TDS.TIMBRE.FRAME.DISPLAY: proc(arg) public swapable;      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.tds=0 then do;         call feature.not.available;         return (-1);      end;      call FRAME.ALPHA.DISP;        /* draw timbre frame screen frame */      call POS.ALPHA.FRAME.CURSOR;  /* reposition cursor */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.new.timbre.info,  /* new kbd timbre/partial   */                               get.ertyp);           /* errors            */      call GET_ENABLE(get.prm.info);                 /* timbre parameter change ->tds.update*/      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call FRAME.ALPHA.DISP.INPUT(in.chin,next.event.info);/* Timbre Frame display character processing routine */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call FRAME.ALPHA.DISP.MOUSE.POS (mouse(release.x),mouse(release.y));/* TDS Timbre Frame Display Mouse Positioner */            end;            ;                          /* mouse movement not used */            do;                        /* new timbre info     */               call PRINT.TIMBRE.NAME(1,start.tf.tim.nam);               call POS.ALPHA.FRAME.CURSOR;   /* reposition cursor */               new.ABLE.prm.info=new.ABLE.prm.info\"37"; /* force an update */            end;            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            do;               call UPDATE.FRAME.ALPHA.DISP; /* processes timbre frame changes ->tds.update*/               if tds.change<>0 then do;       /* have drawn something on screen */                  tds.change=0;                   call POS.ALPHA.FRAME.CURSOR; /* reposition the cursor */               end;            end;            ;                          /* dtd info - nothing      */            ;                          /* poly change- nothing    */            do;                        /* error message to display */               call Handle.System.Error.Codes(Next.Event.Info);               call POS.ALPHA.FRAME.CURSOR;            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.new.timbre.info,                                 get.ertyp);             call GET_DISABLE(get.prm.info);   /* timbre parameter change */      EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      return GOTO.THIS.SCREEN;   end TDS.TIMBRE.FRAME.DISPLAY;end TDSNMOD;