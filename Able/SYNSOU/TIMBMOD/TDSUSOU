/* TDSUSOU - $Title Timbre Display Utility Routines   Modified:   06/27/88 - MWH - Remove unused inserts   05/19/88 - LSS - changes for Macintosh support   02/20/87 - BSW - Put routines used by both the Numeric and Graphic                    displays into a Module */Module TDSUMOD;   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:globlits';  /* good globals */   insert ':synlits:statelit';  /* input state literals */   insert ':synlits:syslits';   /* for d40_present check */   insert ':synlits:timlits';   /* Timbre Head literal definitions */   insert ':synlits:prmlits';   /* literals for timbre definition  */   insert ':synmods:xmemdcl';   /* external memory routines (such as copy.in) */   insert ':synmods:globdcl';   /* globals such as token */   insert ':synmods:tprimdcl';  /* some primitives used by all screens */   insert ':synmods:errdcl';    /* error handling routines */   insert ':synmods:ttydcl';    /* terminal i/o routines   */   insert ':synmods:d40dcl';    /* printing routines */   insert ':synrdcls:03-pdcls';   insert ':synrdcls:05-bdcls';   dcl tds.change        fixed public;  /* set to 1 if any screen updates take place */   dcl tds.choice        fixed public;  /* screen selected */   dcl tds.last.choice   fixed public;  /* last screen selected */   dcl previous.partial  fixed public;  /* keep track of last partial displayed for an erase */   dcl #ypos             fixed public;  /* keep track of where mouse is on the screen for mapping purposes */   /* $Title TDS Menu Selection Routines */   DRAW.MENU.SELECTION: proc(line) public swapable; /* draw the menu selection given the line number */      dcl line fixed;      call cpos(line,0);      call ps('Select Display ==> Graphic  Numeric  Partial Timbre  Timbre Frame  3D  Hardcopy');   end DRAW.MENU.SELECTION;   POS.CHOICE.CURSOR: proc(line) public swapable;  /* position the menu selection cursor on the menu item*/      dcl line      fixed;   /* line number where menu is placed */      dcl selection fixed;   /* menu item selected */      dcl i         fixed;      if inc.tds=0 then return;      if vt100<>0 then do;      /* if a vt100 terminal */         selection=tds.last.choice;         do i=0 to 1;              /*first turn the reverse video off the last choice, then turn the new one on*/            call reverse.video(i);             do case(selection);               do;                     /* 0: Timbre Graphical Display */                  call cpos(line,19);                  call ps('Graphic');               end;               do;                    /* 1: Alphanumeric Timbre Display */                  call cpos(line,28);                  call ps('Numeric');               end;               do;                    /* 2: Partial Timbre Display */                  call cpos(line,37);                  call ps('Partial Timbre');               end;               do;                    /* 3: Timbre Frame */                  call cpos(line,53);                  call ps('Timbre Frame');               end;               do;                    /* 4: 3D Harmonic Display */                  call cpos(line,67);                  call ps('3D');               end;               do;                    /* 5: Hardcopy */                  call cpos(line,71);                  call ps('Hardcopy');               end;            end; /* of do case */            selection=tds.choice;         end;         call reverse.video(0);      end;                             /* of if a vt100 terminal */      else do case(tds.choice);        /* otherwise, position cursor at start of choice */         call cpos(line,18);           /* Graphic display */         call cpos(line,27);           /* Numeric display */         call cpos(line,36);           /* partial timbre display */         call cpos(line,52);           /* Timbre Frame */         call cpos(line,66);           /* 3D Harmonic */         call cpos(line,70);           /* Hardcopy */      end;   end POS.CHOICE.CURSOR;   /* $Subtitle Mouse TDS Menu Selection */   MOUSE.SELECT.TDS.SCREEN:  proc(x) public swapable;  /* selects TDS screen with mouse */      /*        Considers the following TDS variables:        tds.choice -> TDS menu selection        tds.last.choice -> last menu selection       */      dcl x             fixed;       /* screen column number (0-79) */      dcl i             fixed;       /* index to look up table */      dcl selection.x   data (7,19,28,37,53,67,71,79);      if inc.tds=0 then return;      if (x>=selection.x(1)) and (x<selection.x(selection.x(0))) then do; /* must be within range */         i=1;         do while (x>selection.x(i));    /* search thru the table */             i=i+1;         end;         if ((x<(selection.x(i)-2)) or (x=selection.x(i))) then do;      /* if not in between choices */            if x=selection.x(i)          /* return the tds.choice */            then return (i-1);            else return (i-2);                end;      end;      return (-1);   end MOUSE.SELECT.TDS.SCREEN;   /* $Subtitle Change Timbre Display States */   CHANGE.TDS.STATE:  proc (tds.choice,last.tds.choice) public swapable;   /* changes to the given tds state */      dcl tds.choice      fixed;      /* screen to go to */      dcl last.tds.choice fixed;      /* where you came from */      do case tds.choice;         do;                                   /* 0: Graphical Timbre Display */            if vt100<>0 then do; /* have vt100, vt640, dq640, mg600 or Mac */               if gtype<>0 then do; /* terminal has graphics */                  call SELECT.PARTIAL(previous.partial);                  call SELECT.TIMBRE.FRAME(previous.partial,0); /* activate timbre frame 0*/                  GOTO.THIS.SCREEN=s.tds.gcomp;                  EXIT.MY.SCREEN=1;               end;               else call no.graphics.terminal;            end;             else call no.graphics.terminal;         end;         do;            call SELECT.PARTIAL(previous.partial);            call SELECT.TIMBRE.FRAME(previous.partial,0); /* activate timbre frame 0*/            GOTO.THIS.SCREEN=s.tds.acomp;     /* 1: Alphanumeric Timbre Display */            EXIT.MY.SCREEN=1;         end;         do;                                   /* 2: Graphical Partial Timbre Display */            if vt100<>0 then do; /* have vt100, vt640, dq640, mg600 or Mac */               if gtype<>0 then do; /* terminal has graphics */                  call SELECT.PARTIAL(previous.partial);                  call SELECT.TIMBRE.FRAME(previous.partial,0); /* activate timbre frame 0*/                  GOTO.THIS.SCREEN=s.tds.part;                  EXIT.MY.SCREEN=1;               end;               else call no.graphics.terminal;            end;   /* any other type will fall out here without doing anything */            else call no.graphics.terminal;         end;         do;                                   /* 3: Alphanumeric Timbre Frame Display */            GOTO.THIS.SCREEN=s.tds.afram;            EXIT.MY.SCREEN=1;         end;         do;                                   /* 4: 3D Harmonic Display */            if vt100<>0 then do; /* have vt100, vt640, dq640, mg600 or Mac */               if gtype<>0 then do; /* terminal has graphics */                  call SELECT.PARTIAL(previous.partial);                  call SELECT.TIMBRE.FRAME(previous.partial,0); /* activate timbre frame 0*/                  GOTO.THIS.SCREEN=s.tds.gfram;                  EXIT.MY.SCREEN=1;               end;               else call no.graphics.terminal;            end;                               /* any other type will fall out here without doing anything */            else call no.graphics.terminal;         end;         do;                                   /* 5: Hardcopy */            if D40_PRESENT<>0 then do;         /* if device available */               if (last.tds.choice=s.tds.acomp) or (last.tds.choice=s.tds.afram) then do;                  if last.tds.choice=s.tds.acomp                  then call POS.CHOICE.CURSOR(2);                  else call POS.CHOICE.CURSOR(3);                  call SCREEN_DUMP;          /* screen dump */                  end;               else do;                  call POS.CHOICE.CURSOR(23);                  call hardcopy;              /* or print graphics */               end;            end;            else call no.printer;         end;      end;   end CHANGE.TDS.STATE;   /* $SUBTITLE  Routines to Update Comparative Partial Timbre Display */   COMPARATIVE.SNAP.SHOT:  proc public swapable; /* takes a picture of current timbre parms */      dcl (i,j,k,base) fixed;      dcl no.frames    fixed;  /* number of timbre frames */      /* SNAP SHOT AREA:         Whenever this routine is called a copy of most timbre parameters         is written to external memory.  The 46 basic numbers for each         partial timbre are saved plus any PARTIAL VOLUME, MODULATOR         DEPTH, number of timbre frames, and PITCH RANDOMNESS info.         Each partial has been allocated 60 words, 50 of which         are accounted for by the above parameters.  In addition to these         parameters, 16 words have been reserved at the start of the snap         shot area to store other info about the timbre as defined below:            MISC INFO AREA            Words 0 -  3 --> True if corresponding partial has non-zero volume.            Words 4 -  7 --> True if corresponding partial has timbre frames.            Word  8      --> Sampled HGS Value.            Words 9 - 15 --> Unused.                       ---------------------------------                      |  16 wds of misc snap shot info  |             S        |---------------------------------|             N        |  50 wds of parms for partial #1 |             A        |  10 unused wds                  |             P  A      ---------------------------------                R     |  50 wds of parms for partial #2 |             S  E     |  10 unused wds                  |             H  A      ---------------------------------             O        |  50 wds of parms for partial #3 |             T        |  10 unused wds                  |                       ---------------------------------                      |  50 wds of parms for partial #4 |                      |  10 unused wds                  |                       ---------------------------------     */      misc.buf(8)=hgs;                                   /* word 9 holds sampled HGS state */      do i=0 to 3;                                       /* loop over the 4 partial timbres */         base=16+i*60; j=TIM.HEAD.LOOKUP(0,tim.partial.pointers+i);   /* get ptr to this partial */         call p.lookup(j);                               /* set xmem ptr to partial data */         call copy.in(addr(misc.buf(base)),num.params);  /* copy partial timbre info to snap shot area */         k=j+num.params;                                 /* step past params */         if  (p.lookup(k)=mor) then do;                 /* have some kind of frame */            if p.lookup(k+type)=tf.type                 /* and it's a timbre frame */            then misc.buf(i+4)=tf.type;                 /* timbre frames on partial */            else if read(md)=pt.type                    /* have a patch timbre */            then misc.buf(i+4)=pt.type;                 /* set correct value */            else misc.buf(i+4)=(-1);                    /* no timbre frames on partial */         end;         else misc.buf(i+4)=(-1);                       /* no frames on partial */         no.frames=0;         do while p.lookup(k)=mor; no.frames=no.frames+1; k=k+p.lookup(k+clen); end; /* skip over frames */         if p.lookup(k)=pinfo then do;            misc.buf(base+num.params  )=p.lookup(k+pi.pvol); /* partial volume */            misc.buf(base+num.params+1)=p.lookup(k+pi.mdep); /* vibrato modulator depth */         end;         else do;            k=j+num.params;                             /* step past params */            if  (p.lookup(k  )=mor)                     /* have some kind of frame */            and (misc.buf(i+4)=tf.type)                 /* and it's a timbre frame */            then misc.buf(base+num.params)=p.lookup(k+p.e.seg.vol); /* look up old partial vol */            else misc.buf(base+num.params)=1000;        /* default 100.0 */            misc.buf(base+num.params+1)=0;              /* zero vibrato modulator depth */         end;         if misc.buf(i+4)=tf.type then do;              /* if timbre frames exist */            misc.buf(base+num.params+2)=no.frames;      /* set number of timbre frames */            misc.buf(base+num.params+3)=p.lookup(FIND.FRAME(i,1)+p.e.seg.rnd); /* determine pitch randomness */         end;         else do;                                       /* if no timbre frames */            misc.buf(base+num.params+2)=0;            misc.buf(base+num.params+3)=0;         end;         /* $page */         /* Either PEAK or SUST is non-zero */         if ((misc.buf(base+p.epeakl)\misc.buf(base+p.esustl))&1023)<>0         then misc.buf(i)=1;                          /* partial is active */         else do;            misc.buf(i)=0;                            /* partial is not active */            do j=0 to 59;               misc.buf(base+j)=0;            end;         end;      end;      write(mam)=trd.ptr;      call copy.out(addr(misc.buf(0)),256); /* copy MISC.BUF out to snap shot area */   end COMPARATIVE.SNAP.SHOT;   /* $SUBTITLE Routine to Extract a Specific Parameter from Synclavier Timbre */   EXTRACT.COMP.PARM:  proc(sec,pt#,parm#) fixed public swapable; /* gets parameter from snap shot or display area */      dcl sec   fixed; /* base sector in ext mem of parms */      dcl pt#   fixed;      dcl parm# fixed;      dcl base  fixed;      write(mam)=sec;      base=16+pt#*60;                 /* base ptr for partial */      if parm#<24 then do;            /* get envelope info and harmonic coefs */         write(mal)=8; sec=read(md);  /* look up sampled HGS */         if parm#<12 then write(mal)=base+parm#;         else             write(mal)=base+parm#+sec*12;         if (parm#=4) or (parm#=5) or (parm#>9) /* E.PEAKL,E.SUSTL,IPEAKL,ISUSTL, or COEF */         then return read(md)&1023;   /* only lower 10 bits are used */         else return read(md);        /* all 16 bits are used */      end;      else do;         base=16+pt#*60+36;           /* jump over envelope and coef data */         do case (parm#-24);          /* handle other parms individually */            do; /* 24: NUMBER OF TIMBRE FRAMES */               write(mal)=base+12; return read(md);            end;            do; /* 25: PARTIAL TUNING          */               write(mal)=base; return read(md);            end;            do; /* 26: PITCH RANDOMNESS            */               write(mal)=base+13; return read(md);            end;            do; /* 27: PARTIAL VOLUME          */               write(mal)=base+10; return read(md);            end;            do; /* 28: FM RATIO                */               write(mal)=base+7; return read(md);            end;            do; /* 29: PARTIAL CHORUS          */               write(mal)=base+9; return read(md);            end;            do; /* 30: VIBRATO WAVE            */               write(mal)=base+1; return read(md)&15;            end;            do; /* 31: VIBRATO RATE            */               write(mal)=base+2; return read(md);            end;            do; /* 32: VIBRATO DEPTH           */               write(mal)=base+3; return read(md);            end;            do; /* 33: VIBRATO MODULATOR DEPTH */               write(mal)=base+11; return read(md);            end;            do; /* 34: VIBRATO ATTACK          */               write(mal)=base+4; return read(md);            end;            do; /* 35: VIBRATO INVERT   BIT    */               write(mal)=base+1; return read(md)&"20";            end;            do; /* 36: VIBRATO QUANTIZE BIT    */               write(mal)=base+1; return read(md)&"40";            end;            do; /* 37: VIBRATO BIAS     BIT    */               write(mal)=base+1; return read(md)&"100";            end;            do; /* 38: STEREO WAVE             */               write(mal)=base+1; return shr(read(md),7);            end;            do; /* 39: STEREO RATE             */               write(mal)=base+6; return shr(read(md),10);            end;            do; /* 40: STEREO DEPTH            */               write(mal)=base+5; return shr(read(md),9);            end;            do; /* 41: STEREO PAN              */               write(mal)=base+5; return shr(read(md),2)&"177";            end;            /* $page */            do; /* 42: PORTAMENTO ON/OFF       */               write(mal)=base+5; return read(md)&"1";            end;            do; /* 43: PORTAMENTO MODE         */               write(mal)=base+5; return shr(read(md),1)&"7";            end;            do; /* 44: PORTAMENTO RATE         */               write(mal)=base+6; return read(md)&"1777";            end;         end;      end;   end EXTRACT.COMP.PARM;end TDSUMOD;