/* TDSGSOU   $TITLE Timbre Graphic and Partial Timbre Display Screen (TDS) Code *//*   06/29/88 - MWH - Remove unused inserts   05/18/88 - LSS - insert -XPL:SYSLITS   02/20/87 - BSW - Created a Graphical Timbre Display Module */Module TDSGMOD;   insert ':-xpl:syslits';      /* for mouse stuff */   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:asciilit';  /* ASCII literals */   insert ':synlits:globlits';  /* good globals */   insert ':synlits:prmlits';   /* literals for timbre data structure */   insert ':synlits:timlits';   /* timbre head literal definitions (i.e., tim.synth.type) */   insert ':synlits:statelit';  /* input state literals */   insert ':synmods:globdcl';   /* globals such as token */   insert ':synmods:moussdcl';  /* general mouse routines */   insert ':synmods:scrndcl';   /* screen primitive routines (i.e., print.parm) */   insert ':synmods:errdcl';    /* error handling routines */   insert ':synmods:ttydcl';    /* terminal i/o routines   */   insert ':synmods:tprimdcl';  /* terminal primitives used by all screens */   insert ':synmods:plotdcl';   /* plotting - for clear.term!! */   insert ':synmods:getdcl';    /* next.event.info */   insert ':synmods:getvdcl';   /* get.next.event global variables */   insert ':synmods:xmemdcl';   /* external memory routines */   insert ':synmods:tdsudcl';   /* timbre display procedures used by both Numeric and Graphic Display Modules */   insert ':synrdcls:03-pdcls';   insert ':synrdcls:05-bdcls';   insert ':synrdcls:11-tdcls';   dcl tic               fixed;  /* length of normal tic mark */   dcl tds.space         fixed;  /* space between tic mark and label */   /* Complete, Partial Timbre, and 3D display variables */   dcl (tds.minx,tds.miny) fixed; /* enclosing rectangle */   dcl (tds.maxx,tds.maxy) fixed;   dcl party1              fixed; /* divides partial 1 and 2 */   dcl party2              fixed; /* divides partial 2 and 3 */   dcl party3              fixed; /* divides partial 3 and 4 */   dcl deltay              fixed; /* change in y */   dcl max.sum             fixed; /* maximum summation of delay+attack+initial decay time */   dcl sum.shift           fixed; /* if 32 bit summation, number of bits to shift */   dcl max.final.decay     fixed; /* maximum final decay time */   dcl attack.start        fixed; /* location of starting attack time */   dcl attack.mid          fixed; /* location of middle of attack time */   dcl attack.end          fixed; /* location of ending attack time */   dcl attack.window       fixed; /* length of attack window */   dcl sustain.window      fixed; /* length of sustain window */   dcl final.decay.start   fixed; /* location of delay starting time */   dcl final.decay.mid     fixed; /* location of middle of delay time */   dcl final.decay.window  fixed; /* length of final decay time */   /* complete Graphic Timbre Display Variables */   dcl start.comp.titlex  fixed;        /* start of graphic display title */   dcl comp.tim.namx      fixed;        /* x location of graphic display timbre name */   dcl comp.tim.namy      fixed;        /* y location of graphic display timbre name */   dcl comp.head.line     fixed;        /* location of headings on graphic timbre display*/   dcl comp.key.loc       fixed;        /* location of envelope keys in graphic display */   dcl titley.comp.line   fixed;        /* y location graphic display title */   /* Partial Timbre Display variables */   dcl (col1h,row1)  fixed; /* location of (column 1, row 1) menu heading */   dcl col1s         fixed; /* location of column 1 menu setting */   dcl (col2h,row2)  fixed; /* location of (column 2, row 2) menu heading */   dcl col2s         fixed; /* location of column 2 menu setting */   dcl (col3h,row3)  fixed; /* location of (column 3, row 3) menu heading */   dcl col3s         fixed; /* location of column 3 menu setting */   dcl (col4h,row4)  fixed; /* location of (column 4, row 4) menu heading */   dcl col4s         fixed; /* location of column 4 menu setting */   dcl row5          fixed;   dcl row6          fixed;    dcl row7          fixed;   dcl row8          fixed;    dcl titlex.part.num    fixed;        /* x location of partial number in title */   dcl idx.part.num       fixed;        /* x location of identification partial number in partial timbre display */   dcl idy.part.num       fixed;        /* y location of identification partial number in partial timbre display */   dcl start.part.titlex  fixed;        /* start of partial display title */   dcl part.tim.namx      fixed;        /* x location of partial display timbre name */   dcl part.tim.namy      fixed;        /* y location of partial display timbre name */   dcl part.head.line     fixed;        /* location of headings on partial timbre display*/   dcl part.key.loc       fixed;        /* location of envelope keys in partial display */   dcl titley.part.line   fixed;        /* y location partial display title */   /* $page */   /* 3D Display variables */   dcl tot.atk.time          fixed; /* total attack time */   dcl plot.width            fixed; /* horizontal plot width of 3D coefficient display */   dcl plot.height           fixed; /* vertical plot height of 3D coefficient display */   dcl plot.time             fixed; /* diagonal plot time length */   dcl num.grid              fixed; /* number of ground plane grid marks */   dcl pitchy1               fixed; /* pitch envelope y minimum */   dcl pitchy2               fixed; /* pitch envelope y maximum */   dcl tframx1               fixed; /* pitch envelope timbre frame minimum */   dcl tframx2               fixed; /* pitch envelope timbre frame maximum */   dcl harm.screen.titley    fixed; /* y location of screen title */   dcl harm.screen.titlex    fixed; /* starting x location of screen title */   dcl largest.screen.width  fixed; /* largest screen width */   dcl max.harm              lit '24';     /* maximum number of harmonics */   /* $Subtitle Set Terminal Display Variables */   SET.TDS.TERMINAL.DISPLAY.VARIABLES: proc swapable;  /* set the display variables base on terminal type */      if mg600 then do;    /* if Pericom Monteray 6000 */         tic                =8;   /* length of normal tic mark */         tds.space          =16;  /* space between tic mark and label */         attack.start       =250; /* location of starting attack time */         attack.mid         =460; /* location of middle of attack time */         attack.end         =670; /* location of ending attack time */         attack.window      =420; /* length of attack window */         sustain.window     =125; /* length of sustain window */         final.decay.start  =795; /* location of delay starting time */         final.decay.mid    =883; /* location of middle of delay time */         final.decay.window =176; /* length of final decay time */         /* complete graphic display variables */         titley.comp.line   =751; /* y location for graphic display title is differnet for mg600 */         start.comp.titlex  =280; /* start of graphic display title */         comp.tim.namx      =377; /* x location of graphic display timbre name */         comp.tim.namy      =728; /* y location of graphic display timbre name */         comp.head.line     =705; /* location of headings on graphic timbre display*/         comp.key.loc       =100; /* location of envelope keys in graphic display */         /* Partial timbre display variables */         col1h =2;  row1=400; /* location of (column 1, row 1) menu heading */         col1s =210;           /* location of column 1 menu setting */         col2h =302; row2=360; /* location of (column 2, row 2) menu heading */         col2s =445;           /* location of column 2 menu setting */         col3h =523; row3=320; /* location of (column 3, row 3) menu heading */         col3s =705;           /* location of column 3 menu setting */         col4h =770; row4=280; /* location of (column 4, row 4) menu heading */         col4s =939;           /* location of column 4 menu setting */         row5  =240; row6=200;          row7  =160; row8=120;          idx.part.num       =18;  /* x location of identification partial number in partial timbre display */         idy.part.num       =583; /* y location of identification partial number in partial timbre display */         titley.part.line   =751; /* y location of partial display title is different for mg600*/         titlex.part.num    =420; /* x location of partial number in title */         start.part.titlex  =250; /* start of partial display title */         part.tim.namx      =374; /* x location of partial display timbre name */         part.tim.namy      =728; /* y location of partial display timbre name */         part.head.line     =705; /* location of headings on partial timbre display*/         part.key.loc       =436; /* location of envelope keys in partial display */         /* 3D Display variables */         largest.screen.width  =1023; /* largest screen width (MG600=1024) */         plot.width            =650; /* horizontal plot width of 3D coefficient display */         plot.height           =200; /* vertical plot height of 3D coefficient display */         plot.time             =280; /* diagonal plot time length */         num.grid              =40;  /* number of ground plane grid marks */         pitchy1               =640; /* pitch envelope y minimum */         pitchy2               =700; /* pitch envelope y maximum */         tframx1               =150; /* pitch envelope timbre frame minimum */         tframx2               =780; /* pitch envelope timbre frame maximum */         harm.screen.titley    =750;          harm.screen.titlex    =235; /* starting x location of screen title */      end;      /* $page */      else do;         tic                =5;   /* length of normal tic mark */         tds.space          =13;  /* space between tic mark and label */         attack.start       =161; /* location of starting attack time */         attack.mid         =295; /* location of middle of attack time */         attack.end         =431; /* location of ending attack time */         attack.window      =270; /* length of attack window */         sustain.window     =55;  /* length of sustain window */         final.decay.start  =485; /* location of delay starting time */         final.decay.mid    =545; /* location of middle of delay time */         final.decay.window =115; /* length of final decay time */         /* complete graphic display variables */         titley.comp.line   =470;         start.comp.titlex  =175; /* start of graphic display title */         comp.tim.namx      =231; /* x location of graphic display timbre name */         comp.tim.namy      =444; /* y location of graphic display timbre name */         comp.head.line     =431; /* location of headings on graphic timbre display*/         comp.key.loc       =52;  /* location of envelope keys in graphic display */         /* partial timbre display variables */         titley.part.line   =470;         titlex.part.num    =420; /* x location of partial number in title */         idx.part.num       =25;  /* x location of identification partial number in partial timbre display */         idy.part.num       =337; /* y location of identification partial number in partial timbre display */         start.part.titlex  =150; /* start of partial display title */         part.tim.namx      =261; /* x location of partial display timbre name */         part.tim.namy      =440; /* y location of partial display timbre name */         part.head.line     =415; /* location of headings on partial timbre display*/         part.key.loc       =240; /* location of envelope keys in partial display */         col1h =15;  row1=205;    /* location of (column 1, row 1) menu heading */         col1s =144;              /* location of column 1 menu setting */         col2h =205; row2=185;    /* location of (column 2, row 2) menu heading */         col2s =292;              /* location of column 2 menu setting */         col3h =340; row3=165;    /* location of (column 3, row 3) menu heading */         col3s =455;              /* location of column 3 menu setting */         col4h =500; row4=145;    /* location of (column 4, row 4) menu heading */         col4s =597;              /* location of column 4 menu setting */         row5  =125; row6=105;          row7  =85;  row8=65;          /* 3D Display Variables */         largest.screen.width  =799; /* largest screen width (DQ640=800) */         plot.width            =375; /* horizontal plot width of 3D coefficient display */         plot.height           =100; /* vertical plot height of 3D coefficient display */         plot.time             =200; /* diagonal plot time length */         num.grid              =40;  /* number of ground plane grid marks */         pitchy1               =396; /* pitch envelope y minimum */         pitchy2               =432; /* pitch envelope y maximum */         tframx1               =95;  /* pitch envelope timbre frame minimum */         tframx2               =480; /* pitch envelope timbre frame maximum */         harm.screen.titlex    =135; /* starting x location of screen title */         harm.screen.titley    =470;      end;   end SET.TDS.TERMINAL.DISPLAY.VARIABLES;   /* $Subtitle Timbre Graphic Display Routines  */   divide_envelope:proc(x1,y1,x2,y2) swapable; /* divide and display envelope area within the given limits */      dcl (x1,y1) fixed;  /* enclosing rectangle */      dcl (x2,y2) fixed;      call draw_rect(x1,y1,x2,y2);    /* draw the outline */      call connect(attack.start,y1,attack.start,y2); /* divide coefficient area */      call line_type(1);      call connect(attack.end,y1,attack.end,y2); /* divide attack portion of the display */      call connect(final.decay.start,y1,final.decay.start,y2); /* divide sustain and decay portion of the display */      call line_type(0);   end divide_envelope;   draw_envelope_tics:proc(y) swapable;      dcl y fixed;      call connect(attack.mid,y-tic,attack.mid,y);      call connect(attack.end,y-tic,attack.end,y);      call connect(final.decay.start,y-tic,final.decay.start,y);      call connect(final.decay.mid,y-tic,final.decay.mid,y);   end draw_envelope_tics;   draw_coefficient_tics: proc swapable;  /* draw coefficient labels */      dcl i           fixed;      do i = 1 to max.harm; /* draw coefficient tic marks and labels*/         if (i mod 5 = 0) then do;  /* label every fifth coefficient */            call connect(i,tic-3,i,tds.space);            call move_to(i,0);            alpha_mode;            call pnum(i,0);         end;         else call connect(i,tic+3,i,tds.space);      end;      vector_mode;   end draw_coefficient_tics;   /* $page */   display_headings:proc(y) swapable; /* display the envelope headings at the given height */      dcl y fixed; /* y location */      call move_to(tds.minx+((attack.start-tds.minx)/2)-((9/2)*char.width),y);      call pstring('Harmonics');      call move_to(attack.start+((attack.mid-attack.start)/2)-((6/2)*char.width),y);      call pstring('Attack');      call move_to(attack.mid+((attack.end-attack.mid)/2)-((13/2)*char.width),y);      call pstring('Initial Decay');      call move_to(attack.end+((final.decay.start-attack.end)/2)-((7/2)*char.width),y);      call pstring('Sustain');      call move_to(final.decay.mid-((11/2)*char.width),y);      call pstring('Final Decay');      vector_mode;   end display_headings;   partial_timbre_menu_headings:proc swapable; /* draw partial timbre menu headings */      call move_to(col1h,row1);       /* partial */      call pstring('Timbre Frames:');      call move_to(col1h,row2);          call pstring('Partial Tuning:');      call move_to(col1h,row3);      call pstring('Random Pitch:');      call move_to(col1h,row4);      call pstring('Partial Volume:');      call move_to(col1h,row5);      call pstring('FM Ratio:');      call move_to(col1h,row6);      call pstring('Partial Chorus:');      call move_to(col2h,row1);       /* vibrato */      call pstring('Vib Wave:');      call move_to(col2h,row2);      call pstring('Vib Rate:');      call move_to(col2h,row3);      call pstring('Vib Depth:');      call move_to(col2h,row4);      call pstring('Mod Depth:');      call move_to(col2h,row5);      call pstring('Attack:');      call move_to(col2h,row6);      call pstring('Invert:');      call move_to(col2h,row7);      call pstring('Quantize:');      call move_to(col2h,row8);      call pstring('Bias:');      call move_to(col3h,row1);     /* stereo */      call pstring('Stereo Wave:');      call move_to(col3h,row2);      call pstring('Stereo Rate:');      call move_to(col3h,row3);      call pstring('Stereo Depth:');      call move_to(col3h,row4);      call pstring('Stereo Pan:');      call move_to(col4h,row1);     /* portamento */      call pstring('Port On/Off:');      call move_to(col4h,row2);      call pstring('Port Mode:');      call move_to(col4h,row3);      call pstring('Port Rate:');      vector_mode;   end partial_timbre_menu_headings;   /* $Subtitle Draw Volume and Harmonic Envelopes */   display_keys:proc(y) swapable;/* display volume and harmonic envelope keys at given height */      dcl y fixed;      /* y loction of the graph keys */      vector_mode;      call line_type(1);      call connect(tds.minx,y,tds.minx+30,y);   /* display harmonic envelope key */      call move_to(tds.minx+30+char.width,y-5);      call pstring('Harmonic Envelope');      call line_type(0);      call connect(attack.end,y,attack.end+30,y); /* display volume envelope key */      call move_to(attack.end+30+char.width,y-5);      call pstring('Volume Envelope');      vector_mode;   end display_keys;   draw_time_scale:proc(y) swapable;      dcl y fixed; /* location of tics in comparison to labels */      call viewport(0,screen.width,0,screen.height);      call window  (0,screen.width,0,screen.height);      call move_to(attack.start+2,y-tds.space); /* delay+attack+initial decay start time */      call pstring('0');      call move_to(attack.mid+2,y-tds.space);   /* delay+attack+initial decay midpoint */      alpha_mode;      do case (sum.shift);         call pnum(shr(max.sum,1),0);  /* divide by two */         call pnum(max.sum,0);         /* it is already half of true number*/         call pnum(shl(max.sum,1),0);  /* multiply by two */      end;      call move_to(attack.end+2,y-tds.space);  /* total delay+attack+initial decay time */      alpha_mode;      do case (sum.shift);         call pnum(max.sum,0);         call pnum(shl(max.sum,1),0);  /* multiply by two */         call ps('75000');      end;      call move_to(final.decay.start+2,y-tds.space);      call pstring('0');      call move_to(final.decay.mid+2,y-tds.space);      alpha_mode;      call pnum(max.final.decay/2,0);      vector_mode;   end draw_time_scale;   /* $page */   DRAW_ENVELOPE: proc(sec,pt#,ox,oy,ltype) swapable; /* draws the volume or harmonic envelope display */      dcl sec     fixed; /* pointer to snap shot or display area in external memory */      dcl pt#     fixed; /* partial number */      dcl (ox,oy) fixed; /* envelope x,y offset of display */      dcl ltype   fixed; /* envelope type (0=volume; 1=harmonic;) */      dcl base    fixed; /* beginning of partial info */      dcl sum     fixed; /* summation of envelope display */      dcl (x,y)   fixed; /* x and y coordinates of envelope display */      dcl i       fixed;      vector_mode;      if ltype<>0 then do;        call line_type(ltype); /* harmonic ->(1) dashed line; volume ->(0) solid line */        i=6;      end;      else i=0;      call viewport(ox+1,attack.end-1,oy+1,oy+deltay-1);      call window  (0,max.sum,0,1000);      write(mam)=sec; base=16+pt#*60;   /* point to the beginning of the partial info */      write(mal)=base+i;      sum=shr(read(md),sum.shift);      /* find the delay time*/      call move_to(sum,0);              /* move to the partial location */      write(mam)=sec; write(mal)=base+i+1;      x=read(md);                       /* extract the attack time from the snap shot area */      load x; mul 36864; x=read(4);     /* this handles 4567 bug, scales attack time to real time */      sum=sum+shr(x,sum.shift);      write(mal)=base+i+4;      y=read(md)&"1777";                    /* extract the peak level */      call plot(sum,y);                   /* plot to the peak level */      write(mam)=sec; write(mal)=base+i+2;      x=read(md);                        /* lookup the initial decay time from the snapshot*/      sum=sum+shr(x,sum.shift);      write(mal)=base+i+5;      y=read(md)&"1777";                   /* lookup the sustain level */      call plot(sum,y);                  /* plot to the sustain level */      if y<>0 then do;                   /* if sustain level is non-zero */         call plot(max.sum,y);         call viewport(attack.end+1,final.decay.start-1,oy+1,oy+deltay-1); /* define sustain window */         call window  (0,1,0,1000);         call plot(1,y);         write(mam)=sec; write(mal)=base+i+3;         x=read(md);   /* extract the final decay time from the snapshot area */         call viewport(final.decay.start+1,tds.maxx-1,oy+1,oy+deltay-1);         call window  (0,max.final.decay,0,1000);         call move_to(0,y);         call plot(x,0);      end;      if ltype<>0 then call line_type(0); /* restore line type to solid line */   end DRAW_ENVELOPE;   DRAW_HARMONICS: proc(parm#,value,ox,oy) swapable;      dcl parm#           fixed;       /* parameter number */      dcl value           fixed;       /* parameter value */      dcl (ox,oy)         fixed;       /* x and y offset of the display */      dcl (log1,log2)     fixed static;      dcl offset lit '50';             /* for log computation */      log1=log1000(offset);            /* compute log constant 1 */      log2=log1000(1000+offset)-log1;  /*         log constant 2 */      XLOG: PROC (a) fixed;            /* returns log(a) for [0 <= a <=1000] */         dcl (a)  fixed;         return 1000*(log1000(a+offset)-log1)/log2;      END XLOG;      call viewport(ox+5,attack.start-1,oy+1,oy+deltay-1);      call window  (0,max.harm,0,1000);      call connect (parm#,0,parm#,XLOG(value));   end DRAW_HARMONICS;   /* $page */   DRAW_SETTINGS: proc(parm#,value) swapable; /* draw partial special effect settings */      dcl parm#   fixed;   /* parameter number */      dcl value   fixed;   /* parameter value */      call viewport (0,screen.width,0,screen.height);    /* define viewport and window */      call window   (0,screen.width,0,screen.height);      do case (parm#-36);         do;                          /* 36: Number of Timbre Frames */            call move_to(col1s,row1);                alpha_mode;            call print.parm(value,0,0,5,0);         end;         do;                          /* 37: Partial Tuning */            call move_to(col1s,row2);                alpha_mode;            call print.parm(value,1,1,7,1);         end;         do;                          /* 38: Pitch Randomness */            call move_to(col1s,row3);            alpha_mode;            call print.parm(value,0,0,5,2);         end;         do;                          /* 39: Partial Volume */            call move_to(col1s,row4);            alpha_mode;            call print.parm(value,1,0,7,1);         end;         do;                          /* 40: FM Ratio */            call move_to(col1s,row5);            alpha_mode;            if value>=0                           then call print.parm(value,1,0,7,3); /* positive FM Ratios (16.000) */            else call print.parm(value,1,1,7,1); /* negative FM Ratios (-999.9) */         end;         do;                          /* 41: Partial Chorus */            call move_to(col1s,row6);            alpha_mode;            call print.parm(value,1,0,7,3);         end;         do;                          /* 42: Vibrato Wave */            call move_to(col2s,row1);            alpha_mode;            if (value=10) or (value=11) then call ps('Rnd');            else do case (value mod 5);               call ps('Sin');               call ps('Tri');               call ps('Saw');               call ps('ISw');               call ps('Sqr');            end;            if (value>4) and (value<>10)            then call pc(asc.2);            else call pc(sp);         end;         do;                          /* 43: Vibrato Rate */            call move_to(col2s,row2);            alpha_mode;            call print.parm(value,1,0,5,2);         end;         do;                          /* 44: Vibrato Depth */            call move_to(col2s,row3);            alpha_mode;            call print.parm(value,1,0,5,2);         end;         do;                          /* 45: Vibrato Modulator Depth */            call move_to(col2s,row4);            alpha_mode;            call print.parm(value,1,0,5,2);          end;         /* $page */         do;                          /* 46: Vibrato Attack */            call move_to(col2s,row5);            alpha_mode;            call print.parm(value,1,0,5,0);          end;         do;                          /* 47: Vibrato Invert Bit */            call move_to(col2s,row6);            alpha_mode;            if value<>0 then call ps('On');            else             call ps('Off');         end;         do;                          /* 48: Vibrato Quantize Bit */            call move_to(col2s,row7);            alpha_mode;            if value<>0 then call ps('On');            else             call ps('Off');         end;         do;                          /* 49: Vibrato Bias Bit */            call move_to(col2s,row8);            alpha_mode;            if value<>0 then call ps('On');            else             call ps('Off');         end;         do;                          /* 50: Stereo Wave */            call move_to(col3s,row1);             alpha_mode;            call print.parm(value,1,0,4,0);         end;         do;                          /* 51: Stereo Rate */            call move_to(col3s,row2);            alpha_mode;            call print.parm(value*10,1,0,4,2);         end;         do;                          /* 52: Stereo Depth */            call move_to(col3s,row3);            alpha_mode;            call print.parm(value,1,0,4,0);          end;         do;                          /* 53: Stereo Pan */            call move_to(col3s,row4);            alpha_mode;            if value>64 then value=value-128;            call print.parm(value,1,1,4,0);         end;         do;                          /* 54: Portamento on/off */            call move_to(col4s,row1);              alpha_mode;            if value<>0 then call ps('On');            else             call ps('Off');         end;         do;                          /* 55: Portamento Mode */            call move_to(col4s,row2);            alpha_mode;            if value<>0 then call ps('Log');            else             call ps('Lin');         end;         do;            call move_to(col4s,row3); /* 56: Portamento Rate */            alpha_mode;            call print.parm(value,1,0,5,3);         end;      end;    /* of do case */      call move_to(0,0);     /* move cursor back to origin */   END DRAW_SETTINGS;   /* $Subtitle Process Timbre Changes */   DISP.PARAMETER: proc(sec,pt#,parm#,value,tds.choice) swapable;      dcl sec         fixed;   /* sector number which points to either the snapshot or display area */      dcl pt#         fixed;   /* partial number */      dcl parm#       fixed;   /* parameter number */      dcl value       fixed;   /* value of parameter */      dcl tds.choice  fixed;      dcl ltype       fixed;   /* volume or harmonic lines */      dcl (ox,oy)     fixed;   /* x and y offset of the display */      if parm#<36 then do;         do case (pt#);     /* find the y offset of the envelope and harmonic display */            oy=party1;            oy=party2;            oy=party3;            oy=tds.miny;         end;         if parm#<12 then do;/* draw the envelope */            ox=attack.start; /* find the x offset of the envelope display */            do ltype=0 to 1;               call DRAW_ENVELOPE(sec,pt#,ox,oy,ltype); /* draw the specified envelope */            end;         end;         else do;            /* draw the harmonic coefficients */            ox=tds.minx;            parm#=parm#-12;            if (value<>0) then call DRAW_HARMONICS(parm#,value,ox,oy);         end;      end;      else if ((tds.choice=s.tds.part) and ((parm#>=36) and (parm#<57))) then call DRAW_SETTINGS(parm#,value); /* if partial display and valid parameters */   END DISP.PARAMETER;   REMOVE.PARAMETER: proc(sec,pt#,parm#,value,tds.choice) swapable;      dcl sec         fixed;   /* sector number which points to either the snapshot or display area */      dcl pt#         fixed;   /* partial number */      dcl parm#       fixed;   /* parameter */      dcl value       fixed;   /* parameter value */      dcl tds.choice  fixed;   /* comparative graphic or partial display */      vector_mode;      call data_level(1);      call DISP.PARAMETER(sec,pt#,parm#,value,tds.choice); /* erase the specified envelope */      call data_level(0);   END REMOVE.PARAMETER;   /* $page */   DISPLAY.PARTIAL: proc(pt#,tds.choice) swapable; /* display the specified partial display */      dcl pt#        fixed; /* partial number */      dcl tds.choice fixed; /* comparative graphic or partial display */      dcl (i,j)      fixed; /* parameter number*/      dcl disp.val   fixed; /* display value */      dcl parm#      fixed; /* parameter number */      dcl oy         fixed; /* harmonic display offset */      call DISP.PARAMETER(trd.ptr+1,pt#,0,0,tds.choice); /* draw initial volume and harmonic envelopes */      do case(pt#);                                 /* find the y offset of the display */         oy=party1;         oy=party2;         oy=party3;         oy=tds.miny;      end;      call viewport(tds.minx+5,attack.start-1,oy+1,oy+deltay-1); /* draw harmonic coefficient */      call window  (0,max.harm,0,1000);      j=12+16+pt#*60;                               /* draw harmonic coefficients */      do i=12 to 35;         write(mam)=trd.ptr+1; write(mal)=j; disp.val=read(md)&"1777";         parm#=i-12;         call connect (parm#,0,parm#,disp.val);         j=j+1;      end;      if tds.choice=s.tds.part then do i=36 to 56;         call DRAW_SETTINGS(i,EXTRACT.COMP.PARM(trd.ptr+1,pt#,i-12)); /* display partial timbre parameters */      end;   end DISPLAY.PARTIAL;   /* $page */   TIMEX: proc(pt#) swapable; /* Finds the time scale for the specified partial */     /* NOTE:  It handles floating point math for summation of delay, attack,      and initial decay times.  The variables sum.shift, max.sum, and max.final.decay     are used by the routines DRAW_ENVELOPE and DRAW_TIME_SCALE. */      dcl pt#                  fixed; /* active partial number */      dcl (sum1.lsb,sum1.msb)  fixed; /* do 32 bit math for delay+attack+idecay */      dcl (sum2.lsb,sum2.msb)  fixed; /* do 32 bit math for delay+attack+idecay */      dcl base                 fixed; /* beginning of partial info */      dcl (i,j,k)              fixed;      dcl scale.numbers data (20,50,100,200,500,1000,2000,5000,10000,                              15000,20000,25000,30000,32500,32766,17500,20000,22500,                              25000,27500,30000,32500,32766,18750);      write(mam)=trd.ptr;      sum1.msb=0; sum2.msb=0;      base=16+pt#*60;                       /* point to the beginning of partial info */      write(mal)=base;   sum1.lsb=read(md); /* extract the volume delay time */      write(mal)=base+6; sum2.lsb=read(md); /* extract the harmonic delay time */      write(mal)=base+1; j=read(md);      /* extract the volume attack time from the snap shot area */      load j; mul 36864; j=read(4);       /* this handles 4567 bug, scales attack time to real time */      write(mal)=base+7; k=read(md);      /* extract the harmonic attack time */      load k; mul 36864; k=read(4);       /* this handles 4567 bug, scales attack time to real time */      sum1.lsb=sum1.lsb+j;                /* add volume delay and attack times*/      if (sum1.lsb ILT j) then sum1.msb=sum1.msb+1; /* if sum is greater than 16 bits, set MSB bit */      sum2.lsb=sum2.lsb+k;                /* add harmonic delay and attack times*/      if (sum2.lsb ILT k) then sum2.msb=sum2.msb+1; /* if sum is greater than 16 bits, set MSB bit */      write(mal)=base+2; j=read(md);      /* extract the volume initial decay time */      write(mal)=base+8; k=read(md);      /* extract the harmonic initial decay time */      sum1.lsb=sum1.lsb+j;                /* add delay, attack, and initial decay times */      if (sum1.lsb ILT j) then sum1.msb=sum1.msb+1; /* if sum is greater than 16 bits set msb bit*/      sum2.lsb=sum2.lsb+k;                /* add delay, attack, and initial decay times */      if (sum2.lsb ILT k) then sum2.msb=sum2.msb+1; /* if sum is greater than 16 bits set msb bit*/      if (sum1.msb ILT sum2.msb) or ((sum1.msb=sum2.msb) and (sum1.lsb ILT sum2.lsb)) then do;         sum1.msb=sum2.msb; sum1.lsb=sum2.lsb;      end;      sum.shift=0;  /* find the total number of shifts to scale the summation into 15 bits*/      do while(sum1.msb<>0) or (sum1.lsb IGT 32766); /* if MSB then a 32 bit number */         k=(sum1.msb&1);         sum1.msb=shr(sum1.msb,1);         sum1.lsb=shr(sum1.lsb,1) or shl(k,15);         sum.shift=sum.shift+1;      end;      max.sum=sum1.lsb;         /* set the new time scale */      write(mal)=base+3; max.final.decay=read(md); /* extract the volume final decay time from the snapshot area */      write(mal)=base+9;               j=read(md); /* extract the harmonic final decay time */      if j>max.final.decay then max.final.decay=j;      do case(sum.shift);  /* round summation of delay, attack, and initial decay time to a scaling number */         do;i=0; j=15;end;          do;i=15;j=23;end;         do;i=23;j=24;end;      end;      do while ((max.sum>scale.numbers(i)) and (i<j));i=i+1;end;      if i=j then i=i-1;      max.sum=scale.numbers(i);      i=0;  /* round longest final decay time to a scaling number */      do while (max.final.decay>scale.numbers(i));i=i+1;end;      max.final.decay=scale.numbers(i);   end TIMEX;   /* $page */   FIND.TIME.SCALE: proc(pt#) swapable;  /* finds time scale of the specified partial and redraws labels if time changes */      dcl pt#                  fixed;      dcl prev.max.sum         fixed; /* previous maximum summation of delay, attack, initial decay time*/      dcl prev.sum.shift       fixed;      dcl prev.max.final.decay fixed; /* previous maximum final decay time */      dcl temp.max.sum         fixed; /* temporary location */      dcl temp.sum.shift       fixed;      dcl temp.max.final.decay fixed;      prev.max.sum=max.sum;      prev.sum.shift=sum.shift;      prev.max.final.decay=max.final.decay;      call TIMEX(pt#); /* horizontally scale the envelope display to the selected snap shot partial */      if (prev.sum.shift<>sum.shift) or (prev.max.sum<>max.sum) or (prev.max.final.decay<>max.final.decay) then do;         temp.max.sum        =max.sum;         temp.sum.shift      =sum.shift;         temp.max.final.decay=max.final.decay;         max.sum             =prev.max.sum;         sum.shift           =prev.sum.shift;         max.final.decay     =prev.max.final.decay;         vector_mode;         call data_level(1);         call DRAW_TIME_SCALE(tds.miny); /* erase the old time scale */         max.sum             =temp.max.sum;         sum.shift           =temp.sum.shift;         max.final.decay     =temp.max.final.decay;         call data_level(0);         call DRAW_TIME_SCALE(tds.miny); /* draw the new time scale */      end;   end FIND.TIME.SCALE;   /* $page */   PROCESS.COMP.GRAPH.CHANGES: proc(any.changes) swapable;      dcl any.changes          fixed;      dcl pt#                  fixed; /* partial number */      dcl prev.max.sum         fixed; /* previous maximum summation of delay, attack, initial decay time*/      dcl prev.sum.shift       fixed;      dcl prev.max.final.decay fixed; /* previous maximum final decay time */      dcl temp.max.sum         fixed; /* temporary location */      dcl temp.sum.shift       fixed;      dcl temp.max.final.decay fixed;      prev.max.sum        =max.sum;      prev.sum.shift      =sum.shift;      prev.max.final.decay=max.final.decay;      temp.max.sum        =0;                 /* find maximum time scale for all partials */      temp.sum.shift      =0;      temp.max.final.decay=0;      do pt#=0 to 3;                  /* check each active partial timbre */         write(mam)=trd.ptr; write(mal)=pt#;         if read(md)<>0 then do;            call TIMEX(pt#); /* if peak or sustain non-zero horizontally scale the envelope display to the selected snap shot partial */            if ((sum.shift=temp.sum.shift) and (max.sum>temp.max.sum)) or (sum.shift>temp.sum.shift) then do;                temp.max.sum  =max.sum;               temp.sum.shift=sum.shift;            end;            if max.final.decay>temp.max.final.decay            then temp.max.final.decay=max.final.decay;         end;      end;      max.sum        =temp.max.sum;    /* set time scale values to the maximum */      sum.shift      =temp.sum.shift;      max.final.decay=temp.max.final.decay;      if (prev.sum.shift<>sum.shift) or (prev.max.sum<>max.sum) or (prev.max.final.decay<>max.final.decay) then do; /* if time change */         temp.max.sum        =max.sum;         temp.sum.shift      =sum.shift;         temp.max.final.decay=max.final.decay;         max.sum        =prev.max.sum;         sum.shift      =prev.sum.shift;         max.final.decay=prev.max.final.decay;         vector_mode;         call data_level(1);         call DRAW_TIME_SCALE(tds.miny);         /* erase the old time scale */         do pt#=0 to 3;                      /* erase old partial timbres */            call DISP.PARAMETER(trd.ptr+1,pt#,0,0,s.tds.gcomp); /* erase previous envelopes */         end;         call data_level(0);         max.sum        =temp.max.sum;         sum.shift      =temp.sum.shift;         max.final.decay=temp.max.final.decay;         call DRAW_TIME_SCALE(tds.miny);             /* draw the new time scale */         do pt#=0 to 3;  /* draw new partial timbres */            call DISP.PARAMETER(trd.ptr,pt#,0,0,s.tds.gcomp); /* if display is active, draw previous envelopes */            write(mam)=trd.ptr; write(mal)=16+pt#*60;  /* update */            call copy.in(addr(misc.buf(0)),12);            write(mam)=trd.ptr+1; write(mal)=16+pt#*60;            call copy.out(addr(misc.buf(0)),12);         end;  /* of draw new partial timbres */      end;     /* of if time change */      else do pt#=0 to 3; /*look over partial timbres */         if (any.changes&bits(pt#))<>0 then do;   /* of if any envelope changes for active partial */            call REMOVE.PARAMETER(trd.ptr+1,pt#,0,0,s.tds.gcomp); /* erase previous envelopes */            call DISP.PARAMETER  (trd.ptr,  pt#,0,0,s.tds.gcomp); /* if display is active, draw previous envelopes */            write(mam)=trd.ptr; write(mal)=16+pt#*60; /* update */            call copy.in(addr(misc.buf(0)),12);            write(mam)=trd.ptr+1; write(mal)=16+pt#*60;            call copy.out(addr(misc.buf(0)),12);            if (new.timbre.info      <> 0)            or (new.ABLE.timbre.info <> 0)            or (num.of.d50.in.chars  <> 0)            then do;                 /* then break out here  */               transparent_mode;     /* return in TRANSPARENT mode */               new.ABLE.prm.info = new.ABLE.prm.info \ "37";      /* force return for update */               return;            end;         end;   /* of if any envelope changes for active partial */      end;      /* of look over partial timbres */   end PROCESS.COMP.GRAPH.CHANGES;   /* $page */   UPDATE.COMP.GRAPH.DISP: proc swapable;  /* Updates Graphic Display */      dcl pt#                  fixed;  /* partial number */      dcl snap.val             fixed;  /* snap shot value */      dcl disp.val             fixed;  /* display area value */      dcl any.changes          fixed;      dcl any.env.changes      fixed;      dcl (i,j,k)              fixed;      if inc.tds=0 then return;      call comparative.snap.shot; /* take picture of timbre right now   */            call run.syn.loop;      if (new.timbre.info      <> 0)      or (new.ABLE.timbre.info <> 0)      then do;                    /* bag it if timbre changes */         transparent_mode;         return;      end;      any.changes=0;      any.env.changes=0;      do pt#=0 to 3;   /* compare all partial timbre harmonic coefficients */         j=12+16+pt#*60;         do i=12 to 35; /* update harmonic coefficients */            write(mam)=trd.ptr;   write(mal)=j; snap.val=read(md)&"1777";            write(mam)=trd.ptr+1; write(mal)=j; disp.val=read(md);            if snap.val<>disp.val then do;                  /* update this parameter */               any.changes=16;               call REMOVE.PARAMETER(trd.ptr+1,pt#,i,disp.val,s.tds.gcomp); /* erase display value */               call DISP.PARAMETER  (trd.ptr,  pt#,i,snap.val,s.tds.gcomp); /* draw value on screen */               write(mam)=trd.ptr+1; write(mal)=j; write(md)=snap.val;  /* update */               if (new.timbre.info      <> 0)               or (new.ABLE.timbre.info <> 0)               or (num.of.d50.in.chars  <> 0)               then do;                 /* then break out here  */                  transparent_mode;     /* return in TRANSPARENT mode */                  new.ABLE.prm.info = new.ABLE.prm.info \ "37";      /* force return here    */                  return;               end;            end;            j=j+1;         end;      end; /* of compare all partial harmonics */      do pt#=0 to 3;                       /* compare envelope changes for every partial */         write(mam)=trd.ptr; write(mal)=pt#;         if ((next.event.info&bits(pt#))<>0) then do;   /* if the partial has changed */            j=16+pt#*60;                    /* point to the partial */            snap.val=disp.val xor trd.ptr;  /* optimize compilers allocation of registers */            do i=0 to 11;                   /* update envelope parameters */               write(mam)=trd.ptr; write(mal)=j;               if (i=4) or (i=5) or (i=10) or (i=11) then do; /* if peak and sustain values, only lower 10 bits are used*/                  snap.val=read(md)&"1777";                  write(mam)=trd.ptr+1; write(mal)=j;                   disp.val=read(md)&"1777";               end;               else do;                                       /* otherwise, all 16 bits are used */                  snap.val=read(md);                  write(mam)=trd.ptr+1; write(mal)=j;                   disp.val=read(md);               end;               if snap.val<>disp.val then do;                  /* update this parameter (words changed)*/                  any.env.changes=1;                  any.changes=any.changes\bits(pt#);            /* indicate change for the active partial */               end;               j=j+1;            end;         end; /* of if partial is active */      end;    /* of compare envelope changes for every partial */      if any.env.changes<>0 then call PROCESS.COMP.GRAPH.CHANGES(any.changes);      transparent_mode;      /* return in TRANSPARENT mode */   end UPDATE.COMP.GRAPH.DISP;   /* $Subtitle TDS Graphical Display */   COMPLETE_DISPLAY:proc swapable;      dcl partx1 fixed;      if mg600 then do;             /* if Pericom Monteray 6000 */         partx1=15;                 /* location of partial number */         tds.minx=50; tds.miny=148;         tds.maxx=1000;tds.maxy=700;         deltay=138;      end;      else do;                      /* if vt640 or dq640 */         partx1=15;                 /* location of partial number */         tds.minx=25; tds.miny=73;         tds.maxx=600;tds.maxy=425;         deltay=88;      end;      party3=tds.miny+deltay;    /* divides partial 3 and 4 */      party2=party3  +deltay;    /* divides partial 2 and 3 */      party1=party2  +deltay;    /* divides partial 1 and 2 */      call move_to(start.comp.titlex,titley.comp.line);      call char_size(1);      alpha_mode;      call ps('Graphic Display');      call char_size(0);      call move_to(comp.tim.namx-7*char.width,comp.tim.namy);      alpha_mode;      call ps('Timbre ');      call DRAW.TIMBRE.NAME(comp.tim.namx,comp.tim.namy,0);   /* display timbre bank,entry and name */      call display_headings(comp.head.line);          /* display envelope headings */      call divide_envelope(tds.minx,tds.miny,tds.maxx,tds.maxy);      /* display envelope(s) division */      call move_to(partx1,party1+(tds.maxy-party1)/2);    /* partial timbre 1 */      call pstring('1');               call connect(tds.minx,party1,tds.maxx,party1);      call move_to(partx1,party2+(party1-party2)/2);  /* partial timbre 2 */      call pstring('2');      call connect(tds.minx,party2,tds.maxx,party2);      call move_to(partx1,party3+(party2-party3)/2);     /* partial timbre 3 */      call pstring('3');      call connect(tds.minx,party3,tds.maxx,party3);       call move_to(partx1,tds.miny+(party3-tds.miny)/2);   /* partial timbre 4 */      call pstring('4');      call display_keys(comp.key.loc);   /* display the volume and harmonic keys */      max.sum        =0;                 /* initialize maximum delay+attack+initial decay time */      sum.shift      =0;      max.final.decay=0;                 /* initialize maximum final decay time */      call draw_envelope_tics(tds.miny); /* draw the envelope time tics */            call EXTSET(trd.ptr+1,0,256,0);    /* clear out display area in external memory */   end COMPLETE_DISPLAY;   COMP.GRAPH.DISP:proc swapable; /* TDS comparative partial graphics display routine */      if inc.tds=0 then return;      call clear.term;                /* clear screen */      call SET.TDS.TERMINAL.DISPLAY.VARIABLES;      call viewport (0,screen.width,0,screen.height);      call window   (0,screen.width,0,screen.height);      if D44_present      then call PLOT.MOUSE.HOLE(mouse.hole.lowerx,mouse.hole.lowery); /* if device available draw the mouse hole */      vector_mode;      call COMPLETE_DISPLAY;      transparent_mode;               /* prompt for partial timbre display */      call DRAW.MENU.SELECTION(23);   /* draw the menu selection line */      tds.choice=0; tds.last.choice=0;/* set the menu selection to the screen */      call POS.CHOICE.CURSOR(23);      new.ABLE.prm.info = new.ABLE.prm.info \ "37"; /* set bits to force update */   end COMP.GRAPH.DISP;   insert ':synsou:timbmod:tdsgsoua';   /* $Subtitle Activates Graphic Timbre Display Screen */   TDS.GRAPHIC.DISPLAY: proc(arg) public swapable;      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.tds=0 then do;         call feature.not.available;         return (-1);      end;      call COMP.GRAPH.DISP;        /* draw graphic timbre display frame */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.new.timbre.info,  /* new kbd timbre/partial   */                               get.ertyp);           /* errors            */      call GET_ENABLE(get.prm.info);                 /* timbre parameter change ->tds.update*/      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call GRAPHICAL.DISPLAY.INPUT(in.chin,next.event.info,s.tds.gcomp); /* graphic display character processing routine */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call GRAPHICAL.DISPLAY.MOUSE.POS (mouse(release.x),mouse(release.y),s.tds.gcomp);/* TDS Graphic Display Mouse Positioner */            end;            ;                          /* mouse movement not used */            do;                        /* new timbre info     */               call viewport (0,screen.width,0,screen.height);               call window   (0,screen.width,0,screen.height);               call ERASE.TIMBRE.NAME(comp.tim.namx,comp.tim.namy,0); /* erase previous name */               call DRAW.TIMBRE.NAME (comp.tim.namx,comp.tim.namy,0);  /* draw new name */               new.ABLE.prm.info=new.ABLE.prm.info\"37";    /* force an update */               transparent_mode;            end;            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            call UPDATE.COMP.GRAPH.DISP;/* tds.update */            ;                          /* dtd info - nothing      */            ;                          /* poly change- nothing    */            do;                        /* error message to display */               call Handle.System.Error.Codes(Next.Event.Info);            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.new.timbre.info,                                 get.ertyp);             call GET_DISABLE(get.prm.info);   /* timbre parameter change */      EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      return GOTO.THIS.SCREEN;   end TDS.GRAPHIC.DISPLAY;   /* $Subtitle Activates Graphic Timbre Display Screen */   TDS.PARTIAL.DISPLAY: proc(arg) public swapable;      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.tds=0 then do;         call feature.not.available;         return (-1);      end;      call PART.GRAPH.DISP;        /* draw partial timbre display frame */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.new.timbre.info,  /* new kbd timbre/partial   */                               get.ertyp);           /* errors            */      call GET_ENABLE(get.prm.info);                 /* timbre parameter change ->tds.update*/      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call GRAPHICAL.DISPLAY.INPUT(in.chin,next.event.info,s.tds.part);/* graphic display character processing routine */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call GRAPHICAL.DISPLAY.MOUSE.POS (mouse(release.x),mouse(release.y),s.tds.part);/* TDS Graphic Display Mouse Positioner */            end;            ;                          /* mouse movement not used */            do;                        /* new timbre info     */               call viewport (0,screen.width,0,screen.height);               call window   (0,screen.width,0,screen.height);               call ERASE.TIMBRE.NAME(part.tim.namx,part.tim.namy,0); /* erase previous name */               call DRAW.TIMBRE.NAME (part.tim.namx,part.tim.namy,0);  /* draw new name */               transparent_mode;               new.ABLE.prm.info=new.ABLE.prm.info\"37";    /* force an update */            end;            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            call UPDATE.PART.GRAPH.DISP; /* tds update */            ;                          /* dtd info - nothing      */            ;                          /* poly change- nothing    */            do;                        /* error message to display */               call Handle.System.Error.Codes(Next.Event.Info);            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.new.timbre.info,                                 get.ertyp);             call GET_DISABLE(get.prm.info);   /* timbre parameter change */      EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      return GOTO.THIS.SCREEN;   end TDS.PARTIAL.DISPLAY;   /* $Subtitle Activates 3D Timbre Display Screen */   TDS.3D.DISPLAY: proc(arg) public swapable;      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.tds=0 then do;         call feature.not.available;         return (-1);      end;      new.ABLE.prm.info=new.ABLE.prm.info \ "37"; /* set bits to force redraw of data */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.new.timbre.info,  /* new kbd timbre/partial   */                               get.ertyp);           /* errors            */      call GET_ENABLE(get.prm.info);                 /* timbre parameter change ->tds.update*/      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call GRAPHICAL.DISPLAY.INPUT(in.chin,next.event.info,s.tds.gfram);/* graphic display character processing routine */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call GRAPHICAL.DISPLAY.MOUSE.POS (mouse(release.x),mouse(release.y),s.tds.gfram);/* TDS Graphic Display Mouse Positioner */            end;            ;                          /* mouse movement not used */            new.ABLE.prm.info = new.ABLE.prm.info\"37"; /* new timbre info    */            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            call UPDATE.FRAME.GRAPH.DISP;/* tds.update */            ;            ;                          /* dtd info - nothing      */            ;                          /* poly change- nothing    */            do;                        /* error message to display */               call Handle.System.Error.Codes(Next.Event.Info);            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.new.timbre.info,                                 get.ertyp);             call GET_DISABLE(get.prm.info);   /* timbre parameter change */      EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      return GOTO.THIS.SCREEN;   end TDS.3D.DISPLAY;end TDSGMOD;