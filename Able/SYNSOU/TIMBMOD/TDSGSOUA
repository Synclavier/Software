/* TDSGSOUA  $TITLE  Partial and 3D Harmonic Display Defs and Routines *//*   2/20/87 - BSW - Part of The Graphical Timbre Display Module, TDSGMOD*/   PROCESS.PART.GRAPH.CHANGES: proc(old.pt#,new.pt#) swapable;      dcl old.pt#           fixed; /* old partial number */      dcl new.pt#           fixed; /* new partial number */      dcl snap.val          fixed; /* snap shot value */      dcl disp.val          fixed; /* display area value */      dcl any.changes       fixed; /* if any changes occurred */      dcl (i,j,k)           fixed;      dcl (l,m)             fixed;      dcl parm.wd  data (12,0,13,10,7,9,1,2,3,11,4,1,1,1,1,6,5,5,5,5,6); /* offsets into the timbre definition */      any.changes=0;      /* compare envelope values */      j=16+new.pt#*60;                /* point to the new partial */      k=16+old.pt#*60;                /* point to the old partial */      do i=0 to 11;                   /* update envelope parameters */         write(mam)=trd.ptr;   write(mal)=j;         if (i=4) or (i=5) or (i=10) or (i=11) then do; /* if peak and sustain values, only lower 10 bits are used*/            snap.val=read(md)&"1777";            write(mam)=trd.ptr+1; write(mal)=k;             disp.val=read(md)&"1777";         end;         else do;                                       /* otherwise, all 16 bits are used */            snap.val=read(md);            write(mam)=trd.ptr+1; write(mal)=k;             disp.val=read(md);         end;         if snap.val<>disp.val then any.changes=1;      /* update this parameter (words changed)*/         j=j+1;         k=k+1;      end;      if any.changes<>0 then do; /* if any envelope changes redraw both volume and harmonic envelopes */         call REMOVE.PARAMETER(trd.ptr+1,old.pt#,0,0,s.tds.part);   /* erase old display envelope */         call FIND.TIME.SCALE(new.pt#);                  /* find the time scale of the envelope*/         call DISP.PARAMETER(trd.ptr,new.pt#,0,0,s.tds.part);       /* draw new snapshot envelope */      end;      /* compare all harmonic coefficients */      j=12+16+new.pt#*60;      k=12+16+old.pt#*60;      do i=12 to 35; /* update harmonic coefficients */         write(mam)=trd.ptr;   write(mal)=j; snap.val=read(md)&"1777";         write(mam)=trd.ptr+1; write(mal)=k; disp.val=read(md)&"1777";         if snap.val<>disp.val then do;                  /* update this parameter */            any.changes=1;            call REMOVE.PARAMETER(trd.ptr+1,old.pt#,i,disp.val,s.tds.part); /* erase old display value */            call DISP.PARAMETER  (trd.ptr,  new.pt#,i,snap.val,s.tds.part); /* draw new value on screen */         end;         j=j+1;         k=k+1;      end;      /* $page */      /* check all other parameters */      j=36+16+new.pt#*60;      k=36+16+old.pt#*60;      do i=36 to 56;  /* loop over number of params displayed on screen for this partial */         l=j+parm.wd(i-36);         m=k+parm.wd(i-36);         write(mam)=trd.ptr;   write(mal)=l; snap.val=read(md);         write(mam)=trd.ptr+1; write(mal)=m; disp.val=read(md);         if snap.val<>disp.val then do;                     /* MAYBE update this parameter */            snap.val=EXTRACT.COMP.PARM(trd.ptr  ,new.pt#,i-12); /* get parameter fram snap shot area */            disp.val=EXTRACT.COMP.PARM(trd.ptr+1,old.pt#,i-12); /* get parameter from display area */            if snap.val<>disp.val then do;                  /* update this parameter */               any.changes=1;               call REMOVE.PARAMETER(trd.ptr+1,old.pt#,i,disp.val,s.tds.part);    /* erase value on screen */               call DISP.PARAMETER  (trd.ptr,  new.pt#,i,snap.val,s.tds.part);    /* draw snap shot value on screen */            end;         end;      end;      if any.changes<>0 then do; /* if any changes update display area */         write(mam)=trd.ptr;         call copy.in (addr(misc.buf(0)),256);         write(mam)=trd.ptr+1;         call copy.out(addr(misc.buf(0)),256);      end;   end PROCESS.PART.GRAPH.CHANGES;   /* $page */   UPDATE.PART.GRAPH.DISP: proc swapable;      dcl (i,j)                fixed;            if inc.tds=0 then return;      call comparative.snap.shot; /* take picture of timbre right now */      call run.syn.loop;      if (new.timbre.info      <> 0)      or (new.ABLE.timbre.info <> 0)      then do;                    /* exit if new timbre or new partial */         transparent_mode;         return;      end;      i=previous.partial;                         /* get currently displayed partial */      if FIND.PARTIAL<>previous.partial then do;  /* different partial # selected */         call viewport (0,screen.width,0,screen.height);         call window   (0,screen.width,0,screen.height);         call ERASE.PARTIAL.NUMBER(idx.part.num,idy.part.num,0);         previous.partial=find.partial;         call DRAW.PARTIAL.NUMBER (previous.partial,idx.part.num,idy.part.num,0);      end;      call PROCESS.PART.GRAPH.CHANGES(i,previous.partial); /* process any changes that may occur between snap shot and display or old and new partials */      transparent_mode;                     /* return in TRANSPARENT mode */   end UPDATE.PART.GRAPH.DISP;   /* $Subtitle     Draw Partial Timbre Display */   PARTIAL_DISPLAY:proc swapable;     /* display the partial timbre */      dcl partx1   fixed;      dcl(i,j,k)   fixed;      if mg600 then do;         partx1=40;  /* location of partial number */         deltay=235;         tds.minx=50; tds.miny=465;         tds.maxx=1000;tds.maxy=700;      end;      else do;           /* if vt640 or dQ640 */         partx1=25;  /* location of partial number */         deltay=145;         tds.minx=35; tds.miny=265;         tds.maxx=610;tds.maxy=410;      end;      party1=tds.miny;party2=tds.miny;party3=tds.miny;      call move_to(start.part.titlex,titley.part.line);      call char_size(1);      call pstring('Partial Timbre Display');      call char_size(0);      call move_to(part.tim.namx-7*char.width,part.tim.namy);         /* display timbre name */      alpha_mode;      call ps('Timbre ');      call DRAW.TIMBRE.NAME(part.tim.namx,part.tim.namy,0); /* display timbre name */      call display_headings(part.head.line);             /* display the envelope headings */      call divide_envelope(tds.minx,tds.miny,tds.maxx,tds.maxy);         /* display the envelope division */      previous.partial=find.partial;      /* look up part#; save for later erase */      call DRAW.PARTIAL.NUMBER(previous.partial,idx.part.num,idy.part.num,0);      call viewport(tds.minx,attack.start,tds.miny-tds.space,tds.miny);  /* define coefficient area */      call window(0,max.harm+1,0,tds.space);      call draw_coefficient_tics;      max.sum        =0;                 /* initialize maximum delay+attack+initial decay time */      sum.shift      =0;      max.final.decay=0;                 /* initialize maximum final decay time */      call viewport (0,screen.width,0,screen.height);       /* redefine screen area */      call window   (0,screen.width,0,screen.height);      call draw_envelope_tics(tds.miny); /* draw envelope time tics */      call display_keys(part.key.loc);   /* display volume and harmonic envelope keys */      call partial_timbre_menu_headings; /* display special effect functions */      call comparative.snap.shot;       /* take picture of timbre right now */      call run.syn.loop;      call FIND.TIME.SCALE(previous.partial);      write(mam)=trd.ptr;               /* copy snapshot area to display area for all partials*/      call copy.in(addr(misc.buf(0)),256);      write(mam)=trd.ptr+1;      call copy.out(addr(misc.buf(0)),256);      call DISPLAY.PARTIAL(previous.partial,s.tds.part);           /* draw what is in snapshot area */   end PARTIAL_DISPLAY;   PART.GRAPH.DISP:proc swapable; /* TDS partial timbre graphics display routine */      if inc.tds=0 then return;      call clear.term;               /* clear screen */      call SET.TDS.TERMINAL.DISPLAY.VARIABLES;      call viewport (0,screen.width,0,screen.height);      call window   (0,screen.width,0,screen.height);      if D44_present      then call PLOT.MOUSE.HOLE(mouse.hole.lowerx,mouse.hole.lowery); /* if device available draw the mouse hole */      call PARTIAL_DISPLAY;      transparent_mode;              /* prompt for complete timbre display */      call cpos(22,0);      call ps('Press space bar to select partial.  Press <ENTER> for Main Menu.');      call DRAW.MENU.SELECTION(23);  /* draw menu selection line */      tds.choice=2; tds.last.choice=2;       /* set menu selection to display screen */      call POS.CHOICE.CURSOR(23);   end PART.GRAPH.DISP;   /* $Subtitle Timbre Graphic Display Character Handling Routine */   GRAPHICAL.DISPLAY.INPUT:  proc(in.cmd,in.arg,tds.screen) swapable; /* Graphic, partial timbre, and 3D display character processing routine */      dcl (in.cmd,in.arg) fixed; /* input command and argument */      dcl tds.screen      fixed; /* current timbre display screen */      dcl i               fixed;      do case (in.cmd);                     /* do depending upon the input command */         do;                                /* 0: character input */            if in.arg=ESC                   /* ESC:  Return to Main Menu */            then EXIT.MY.SCREEN=1;          /* return to Main Menu */            else if (in.arg=r.arr) or (in.arg=l.arr) then do; /* if moving the cursor keys */               tds.last.choice=tds.choice;               if in.arg=r.arr then do; /* if right arrow */                  tds.choice=tds.choice+1;                  if tds.choice>5 then tds.choice=5;               end;               else do;                  tds.choice=tds.choice-1;                  if tds.choice<0 then tds.choice=0;               end;               call remove.err;               call POS.CHOICE.CURSOR(23);            end;            else if in.arg=cret             then call CHANGE.TDS.STATE(tds.choice,tds.screen);            else if in.arg=sp then do;                 /* space - partial select */               i=find.partial+1;               if i=num.partials then i=0;               call SELECT.PARTIAL(i);               new.ABLE.prm.info = new.ABLE.prm.info \ "37"; /* force update */            end;         end;                                          /* of character input */         do;                                           /* 1: absolute select */            tds.last.choice=tds.choice;                /* update last choice */            tds.choice=in.arg;            call CHANGE.TDS.STATE(tds.choice,tds.screen);         end;         ;                                             /* 2: scroll down */         ;                                             /* 3: scroll up */         EXIT.MY.SCREEN=1;                             /* 4: return to previous screen */      end;                                             /* of do depending upon input command */   end GRAPHICAL.DISPLAY.INPUT;   GRAPHICAL.DISPLAY.MOUSE.POS:  proc(x,y,tds.choice) swapable;  /* TDS Graph, Partial, and 3D Comparative Display Mouse Positioner */      dcl (x,y)          fixed;    /* mouse position in screen coordinates */      dcl tds.choice     fixed;    /* screen from which this routine was called */      dcl i              fixed;    /* index to selection column look up table */      dcl selection.y    lit '23'; /* row on which menu selection exists */      if inc.tds=0 then return;      if mouse.hole(x,y) then do;                 /* if mouse scurries to mouse hole */         EXIT.MY.SCREEN=1;         return;      end;      if err.displayed<>0 then do;         call REMOVE.ERR;        /* remove any error */         call PRINT.CCAT;        /* show current cat name */         call POS.CHOICE.CURSOR(selection.y);      end;      /* convert pixel coordinates to screen coordinates */      x=CONVERT.MOUSE.X(x);              /* 0-79 */      y=CONVERT.MOUSE.Y(y);              /* 0-23 */      if y=selection.y then do;         i=MOUSE.SELECT.TDS.SCREEN(x);   /* select TDS screen with mouse */         if i>=0 then do;                /* if a valid selection */            call GRAPHICAL.DISPLAY.INPUT(in.abss,i,tds.choice);         end;      end;   end GRAPHICAL.DISPLAY.MOUSE.POS;   /* $Subtitle Draw Pitch Envelope and 3D Harmonic Display Routines*/   draw_frame_tics: proc(pt#) swapable;  /* draw the timbre frame splice time tics and labels for pitch offset display */      dcl pt#         fixed;   /* active partial number */      dcl i           fixed;   /* timbre frame number */      dcl splice.time fixed;   /* offset within the timbre frame block*/      dcl x           fixed;   /* summation of splice times */      dcl ox          fixed;   /* current pixel x location of splice time label */      dcl printx      fixed;   /* previous pixel x location of splice time label */      dcl num.frames  fixed;   /* number of timbre frames */      call viewport(tframx1,tframx2,pitchy1-(tic+tds.space+char.height),pitchy1); /* draw timbre frame splice time tics */      call window  (0,tot.atk.time,0,tic+tds.space+char.height);      x=0;                                    /* initialize */      printx=0;      num.frames=COUNT.TIMBRE.FRAMES(pt#);      do i=0 to num.frames;                   /* do for all frames */         if i=0 then do;            splice.time=p.lookup(FIND.FRAME(pt#,0)+p.eattack);  /* if frame 0 */            load splice.time; mul 36864; splice.time=shr(read(4),sum.shift);         end;         else splice.time=shr(p.lookup(FIND.FRAME(pt#,i)+p.e.seg.atk),sum.shift);         x=x+splice.time;                     /* lookup the splice time and add it to previous times */         ox=x*(tframx2-tframx1)/tot.atk.time; /* find the pixel offset */         call connect(x,tic+tds.space+char.height,x,tds.space+char.height); /* draw the tic mark */         if (i=0) or ((i<10) and ((ox-printx)>char.width))         or ((i>10) and (ox-printx>char.width*2)) then do; /* the size of a character font is 8*14 pixels */            call move_to(x,tds.space);            alpha_mode;            call pnum(i,0);            printx=ox;         end;      end;      vector_mode;   end draw_frame_tics;   draw_splice_time_tics: proc(pt#) swapable; /* draw diagonal splice time tics and labels */      dcl pt#         fixed;   /* active partial */      dcl x           fixed;   /* summation of timbre frames */      dcl (ox,oy)     fixed;   /* offset x and offset y */      dcl printx      fixed;   /* x location of printed label */      dcl i           fixed;   /* timbre frame number*/      dcl splice.time fixed;   /* offset within timbre frame block */      dcl num.frames  fixed;   /* number of timbre frames in partial */      call window (0,max.harm+1,0,tds.space);      x=0;      num.frames=COUNT.TIMBRE.FRAMES(pt#);      do i=0 to num.frames;                       /* draw splice time tic marks*/         if i=0 then do;            splice.time=p.lookup(FIND.FRAME(pt#,0)+p.eattack);  /* if frame 0 */            load splice.time; mul 36864; splice.time=shr(read(4),sum.shift);         end;         else splice.time=shr(p.lookup(FIND.FRAME(pt#,i)+p.e.seg.atk),sum.shift);         x=x+splice.time;                      /* sum up splice times */         ox=x*plot.time/tot.atk.time;         oy=x*plot.time/tot.atk.time;         call viewport(tds.maxx+ox,tds.maxx+ox+shl(tds.space,1),tds.miny+oy-tic,tds.miny+oy+tic);         call connect(0,9,tic,9);         if (i=0) or ((i<10) and ((ox-printx)>char.width))          or ((i>10) and ((ox-printx)>char.width*2)) then do;  /* font size is 8*14 pixels */            call move_to(tds.space,0);            alpha_mode;            call pnum(i,0);            printx=ox;         end;      end;      vector_mode;   end draw_splice_time_tics;   /* $page */   DRAW_PITCH_ENVELOPE: proc(pt#) swapable;  /* draw the change in pitch over time */      dcl pt#         fixed; /* active partial */      dcl min.pitch   fixed; /* minimum pitch value */      dcl max.pitch   fixed; /* maximum pitch value */      dcl sum         fixed;      dcl splice.time fixed; /* timbre frame attack time */      dcl (i,j)       fixed;      dcl (x,y)       fixed;      dcl num.frames  fixed; /* number of timbre frames in partial */      min.pitch=0; max.pitch=0;      num.frames=COUNT.TIMBRE.FRAMES(pt#);      do i=0 to num.frames;   /* find the minimum and maximum pitch values for all the timbre frames */         if i=0 then y=0;         else do;            y=p.lookup(FIND.FRAME(pt#,i)+p.e.seg.pdel)/100; /* get pitch offset */            if read(4)>50 then y=y+1;                         /* round the pitch offset up if remainder greater then 100/2 */         end;         if      y>max.pitch then max.pitch=y;                /* if greater than previous maximum */         else if y<min.pitch then min.pitch=y;                /* if less than minimum */      end;      if -min.pitch>max.pitch then max.pitch=-min.pitch;      /* find greatest value */      call viewport(0,screen.width,0,screen.height);      call window  (0,screen.width,0,screen.height);      call move_to(tframx1-4*char.width,pitchy2-char.width);      alpha_mode;      call print.parm(max.pitch,0,1,3,0);      call move_to(tframx1-4*char.width,pitchy1+shr((pitchy2-pitchy1),1)-shr(char.width,1));      alpha_mode;      call print.parm(0,0,1,3,0);      call move_to(tframx1-4*char.width,pitchy1);      alpha_mode;      call print.parm(min.pitch,0,1,3,0);      /* display pitch envelope time scale */      if tot.atk.time>0       then call draw_frame_tics(pt#);    /* draw splice time tic marks for pitch envelope */      call viewport(tframx1,tframx2,pitchy1,pitchy2);  /* timbre frame pitch offset*/      call window  (0,tot.atk.time,0,2*max.pitch);      call move_to(0,max.pitch);      x=0;      do i=0 to num.frames;         if i=0 then do;            splice.time=p.lookup(FIND.FRAME(pt#,0)+p.eattack);  /* if frame 0 */            load splice.time; mul 36864; splice.time=shr(read(4),sum.shift);            y=max.pitch;                                               /* pitch offset is 0 */         end;         else do;            j=FIND.FRAME(pt#,i);            splice.time=shr(p.lookup(j+p.e.seg.atk),sum.shift);            y=max.pitch+(p.lookup(j+p.e.seg.pdel)/100);                      /* add pitch offset */         end;         x=x+splice.time;         call plot(x,y);                /* plot pitch offset at timbre frame attack time */      end;      call plot(tot.atk.time,max.pitch);      transparent_mode;   end DRAW_PITCH_ENVELOPE;   /* $Subtitle 3D Timbre Display Character Handler */   HANDLE.3D.INPUT:  proc fixed swapable; /* processes chars typed while drawing 3D display */      dcl i                 fixed;      dcl (x,y)             fixed;      i=next.d50.in.char;      if (i=esc)       or (i=cret)       or (i>=asc.call.terminate)  /* special asc.call.terminate or convert or other special code */      then do;    /* if enter or carriage return */         if (mg600<>0) and ((#mode=#point) or (#mode=#alpha)) /* if pericom and in point or alpha mode */         then do;            if #mode=#point then alpha_mode;                  /* if in point_mode have to do a alpha_mode for transparent_mode */            transparent_mode;                                 /* must be in transparent mode to go into vector mode */         end;         vector_mode;         call data_level(0);         transparent_mode;         return 1;   /* signify that caller should quit plotting and return to main menu */      end;      else if (i=r.arr) or (i=l.arr) then do; /* if moving the cursor keys */         tds.last.choice=tds.choice;         if i=r.arr then do;         /* if right arrow */            tds.choice=tds.choice+1;            if tds.choice>5 then tds.choice=5;         end;         else do;                     /* if left arrow */            tds.choice=tds.choice-1;            if tds.choice<0 then tds.choice=0;         end;         if (mg600<>0) and (#mode=#point) then alpha_mode;   /* handle pericom bug */         transparent_mode;         call remove.err;         call POS.CHOICE.CURSOR(23);  /* move menu selection cursor*/         vector_mode;         point_mode;      end;      call get.next.d50.in.char;     /* ignore character */      return 0; /* signify that char was ignored (i.e., continue plotting) */   end HANDLE.3D.INPUT;   THREE.D.EXIT.CHECK:proc fixed SWAPABLE;      if (new.timbre.info      <> 0)      or (new.ABLE.timbre.info <> 0)      or (new.prm.info         <> 0)      or (new.ABLE.prm.info    <> 0)      then do;         if (mg600<>0) and ((#mode=#point) or (#mode=#alpha)) /* if pericom and in point or alpha mode */         then do;            if #mode=#point then alpha_mode;                  /* if in point_mode have to do a alpha_mode for transparent_mode */            transparent_mode;                                 /* must be in transparent mode to go into vector mode */         end;         vector_mode;         call data_level(0);             /* take drawing out of complement mode */         transparent_mode;         new.ABLE.prm.info = new.ABLE.prm.info \ "37";     /* force update */         return 1;      end;      else if (num.of.d50.in.chars<>0)      then do;    /* if something typed */         return (HANDLE.3D.INPUT);      end;      return 0;   end THREE.D.EXIT.CHECK;   /* $page */   setup.for.3d.display:proc swapable;      dcl i fixed;      call window  (0,plot.width,0,1000);      write(mam)=trd.ptr;                   /* zero out horizon area */      do i=0 to largest.screen.width;         write(mdi)=0;      end;      vector_mode;                          /* draw 3D in point and complement modes */      point_mode;      call data_level(2);   end setup.for.3d.display;   setup.for.3d.exit:proc swapable;      if (mg600<>0) and ((#mode=#point) or (#mode=#alpha)) /* if pericom and in point or alpha mode */      then do;         if #mode=#point then alpha_mode;  /* if in point_mode have to do a alpha_mode for transparent_mode */         transparent_mode;                 /* must be in transparent mode to go into vector mode */      end;      vector_mode;                      /* get back into expected modes in case change of state */      call data_level(0);      transparent_mode;   end setup.for.3d.exit;   DRAW_3D_COEFFICIENTS: proc(pt#) swapable;      dcl pt#                   fixed; /* active partial */      dcl (currx,curry)         fixed; /* current coordinate */      dcl (nextx,nexty)         fixed;      dcl (ox,oy)               fixed; /* offset x and offset y */      dcl (px,py)               fixed; /* previous offset x and y */      dcl (y1,y2)               fixed;      dcl below                 fixed static; /* if starting above(0) or below(1) the horizon */      dcl splice.time           fixed; /* timbre frame splice time */      dcl cross.fade            fixed; /* splice time cross fade value */      dcl distance              fixed; /* distance between timbre frames */      dcl grid                  fixed; /* 3D ground plane gridding */      dcl harm                  fixed; /* timbre frame harmonic value */      dcl sum                   fixed; /* summation of timbre frames */      dcl frame                 fixed; /* timbre frame */      dcl (i,j)                 fixed;      dcl (log1,log2)           fixed static;      dcl (counter)             fixed;      dcl offset lit '50';             /* for log computation */      log1=log1000(offset);            /* compute log constant 1 */      log2=log1000(1000+offset)-log1;  /*         log constant 2 */      XLOG: PROC (a) fixed;            /* returns log(a) for [0 <= a <=1000] */         dcl (a)  fixed;         return 1000*(log1000(a+offset)-log1)/log2;      END XLOG;      DRAW.PIXELS: proc(currx,curry,nextx,nexty) fixed; /* indicates if valid interrupt from mouse */         dcl (currx,curry)         fixed;   /* current coordinate */         dcl (nextx,nexty)         fixed;   /* next coordinate */         dcl horizon               fixed;   /* points to the horizon */         dcl (x,y)                 fixed;         dcl (code)                fixed;         do x=currx+1 to nextx;             /* do for every pixel */            /* The following causes the mouse cursor to be updated               every 20 or 60 msec */            code = check.next.event;        /* keep mouse moving; check for new timbre info, new prm info, new.in.char, etc. */            if  (code  <> 0)                /* if a system event has occurred */            and (code  <> get.in.char)      /* but not an inchar */            then do;               call setup.for.3d.exit;               return;            end;            write(mam)=trd.ptr+shr(x,8);    /* calculate sector address of horizon in external mem (base+offset)*/            write(mal)=x;                   /* point to the word */            horizon=read(md);               /* look up horizon(x) */            y=(x-currx)*(nexty-curry)/(nextx-currx)+curry;   /* find the y coordinate given the specified x */            if y<#view(2) then y=#view(2);  /* limit to the extent of the viewport */            if y<horizon then do;           /* if y below the horizon */               if not below then do;        /* if previous point above */                  call draw(x,horizon+1);   /* draw to the horizon ( +1 so not destroyed in complement mode)*/                  below=1;               end;            end;            else do;                        /* if y above the horizon */               if below then do;            /* if previous point below */                  call imove(x,horizon+1);  /* move to horizon (+1 so do not destroy in complement mode)*/                  below=0;               end;               write(mam)=trd.ptr+shr(x,8);               write(mal)=x;               write(md )=y;                /* store in external memory */               call draw(x,y);              /* draw to y */            end;         end;            return 0;      end DRAW.PIXELS;      /* $page */      call setup.for.3d.display;      do grid=1 to num.grid;                /* do for number of ground plane gridding */         frame=0;         sum=0;         i=grid*tot.atk.time/num.grid;      /* get milliseconds into sound */         do while sum<i;                    /* find endpoints of splice time */            if frame=0 then do;               splice.time=p.lookup(FIND.FRAME(pt#,0)+p.eattack);  /* if frame 0 */               load splice.time; mul 36864; splice.time=shr(read(4),sum.shift);            end;            else splice.time=shr(p.lookup(FIND.FRAME(pt#,frame)+p.e.seg.atk),sum.shift);            sum=sum+splice.time;            if sum<i then frame=frame+1;         end;         distance=i-(sum-splice.time);         /* determine the distance advanced between splice times */         cross.fade=1000*distance/splice.time; /* find the percentage of total distance */         ox=grid*(plot.time/num.grid);      /* find the offset from the origin */         oy=grid*(plot.time/num.grid);         px=ox-(plot.time/num.grid);        /* find the previous offset from the origin */         py=oy-(plot.time/num.grid);         call viewport(tds.minx+px,tds.maxx+px,tds.miny+py,tds.maxy+py);         below=1;                             /* assume we start below the horizon */         call imove(tds.minx+px,tds.miny+py); /* move to starting location */         if (DRAW.PIXELS(tds.minx+px,tds.miny+py,tds.minx+ox,tds.miny+oy))<>0         then return;                         /* draw the left hand axis if it is visible */         call viewport(tds.minx+ox,tds.maxx+ox,tds.miny+oy,tds.maxy+oy);         currx=tds.minx+ox; curry=tds.miny+oy;         below=1;                              /* assume start below the horizon */         call imove(currx,curry);              /* move to starting location and initialize lastx and lasty */         /* $page */         do j=1 to max.harm;                   /* do for all harmonics */            counter=counter+1;            if counter ige 10 then do;               if THREE.D.EXIT.CHECK<>0 then return;               counter=0;            end;            nextx=(j*plot.width/(max.harm+1))+#view(0);              /*            Logrithmically scale the amplitude of the harmonic.             Then, scale coefficients by peak where all values are in the lower 10 bits.            Finally, weight the change in harmonics by the cross fade - percentage of            total distance into the splice time.             */            if frame=0 then do;     /* if frame 0 */               y1=0;               i=FIND.FRAME(pt#,0);               harm=XLOG(p.lookup(i+p.coef.loc+j-1)&"1777");               y2=(harm*(p.lookup(i+p.epeakl)&"1777")/10000)*cross.fade/1000;            end;            else if frame=1 then do;    /* if first frame then must calculate address for frame 0 */               i=FIND.FRAME(pt#,0);               harm=XLOG(p.lookup(i+p.coef.loc+j-1)&"1777");               y1=(harm*(p.lookup(i+p.epeakl)&"1777")/10000)*(1000-cross.fade)/1000;                i=FIND.FRAME(pt#,frame);               harm=XLOG(p.lookup(i+s.env.h+j-1)&"1777");               y2=(harm*(p.lookup(i+p.e.seg.pk)&"1777")/10000)*cross.fade/1000;            end;            else do;               i=FIND.FRAME(pt#,frame-1);               harm=XLOG(p.lookup(i+s.env.h+j-1)&"1777");               y1=(harm*(p.lookup(i+p.e.seg.pk)&"1777")/10000)*(1000-cross.fade)/1000;                i=FIND.FRAME(pt#,frame);               harm=XLOG(p.lookup(i+s.env.h+j-1)&"1777");               y2=(harm*(p.lookup(i+p.e.seg.pk)&"1777")/10000)*cross.fade/1000;            end;            nexty=y1+y2+#view(2);               /* determine the cross-fade */            if (DRAW.PIXELS(currx,curry,nextx,nexty))<>0 then return;            currx=nextx; curry=nexty;           /* set current x and y to last x and y */         end;          if (DRAW.PIXELS(currx,curry,#view(1),#view(2)))<>0 then return;   /* draw to the right-most edge of the viewport (bring y to 0) */      end;    /* of do for number of ground plane gridding */      call data_level(0);   end DRAW_3D_COEFFICIENTS;   /* $Subtitle 3D Harmonic Display */   DISP.TIMBRE.FRAME: proc(pt#) swapable; /* display the timbre frame harmonics and pitch offset  */      dcl pt#               fixed; /* partial number */      dcl i                 fixed; /* parameter number*/      dcl (sum.msb,sum.lsb) fixed; /* handle 32 bits for summation of splice times */      dcl splice.time       fixed; /* offset from beginning of timbre block */      dcl num.frames        fixed; /* number of timbre frames in partial */      tot.atk.time=0;              /* initialize total attack time */      sum.msb=0;      sum.lsb=0;      num.frames=COUNT.TIMBRE.FRAMES(pt#);      do i=0 to num.frames;         /* find total attack time */         if i=0 then do;            splice.time=p.lookup(FIND.FRAME(pt#,0)+p.eattack);  /* if frame 0 */            load splice.time; mul 36864; splice.time=read(4);         end;         else splice.time=p.lookup(FIND.FRAME(pt#,i)+p.e.seg.atk);         sum.lsb=sum.lsb+splice.time;      end;      sum.shift=0;  /* find the total number of shifts to scale the summation into 15 bits*/      do while(sum.msb<>0) or (sum.lsb IGT 32766); /* if MSB then a 32 bit number */         i=(sum.msb&1);         sum.msb=shr(sum.msb,1);         sum.lsb=shr(sum.lsb,1) or shl(i,15);         sum.shift=sum.shift+1;      end;      tot.atk.time=sum.lsb;          /* total attack time is summation of all splice times */      call draw_splice_time_tics(pt#); /* draw splice time tic marks for 3D display*/      call DRAW_PITCH_ENVELOPE(pt#); /* Draw the pitch offsets */      if (new.timbre.info      <> 0)      or (new.ABLE.timbre.info <> 0)      or (new.prm.info         <> 0)      or (new.ABLE.prm.info    <> 0)      then do;         transparent_mode;         new.ABLE.prm.info = new.ABLE.prm.info \ "37";     /* force update */         return;      end;      else if (num.of.d50.in.chars<>0)      then do;         if HANDLE.3D.INPUT<>0         then return;      end;      if tot.atk.time>0      then call DRAW_3D_COEFFICIENTS(pt#);    /* draw 3D display in complement and therfore point mode */   end DISP.TIMBRE.FRAME;   /* $Subtitle Draw 3D Display Outline */   FRAME_GRAPH_DISPLAY: proc swapable; /* draw Timbre Frame Graphical Display */      dcl (ox,oy)      fixed;    /* offset x and offset y */      if mg600 then do;         tds.minx=25; tds.maxx=675;         tds.miny=150; tds.maxy=350;      end;      else do;         tds.minx=25; tds.maxx=400;         tds.miny=75; tds.maxy=175;      end;      call draw_text('3D Harmonic Display',harm.screen.titlex,harm.screen.titley,1);   /* draw screen title */      call draw_text('Partial Timbre',tframx1+shr((tframx2-tframx1),1)-(20*char.width),pitchy2+char.height,0);      previous.partial=find.partial;      call DRAW.PARTIAL.NUMBER(previous.partial,tframx1+shr((tframx2-tframx1),1)-(5*char.width),pitchy2+char.height,0);      call draw_text(' of ', tframx1+shr((tframx2-tframx1),1)-4*char.width,pitchy2+char.height,0);      call DRAW.TIMBRE.NAME(tframx1+shr((tframx2-tframx1),1),pitchy2+char.height,0);     /* draw timbre bank,entry, and name */      /* draw pitch envelope outline */      call draw_rect(tframx1,pitchy1,tframx2,pitchy2);      call connect(tframx1,pitchy1+shr((pitchy2-pitchy1),1),tframx2,pitchy1+shr((pitchy2-pitchy1),1));      call move_to(tframx1-11*char.width,pitchy2-char.height);     /* label the pitch offset area leaving room for (' -xx.xx ')*/      call pstring('Pitch');      call move_to(tframx1-11*char.width,pitchy1+char.height);      call pstring('Offset');      /* draw 3D display axis */      call viewport(0,screen.width,0,screen.height);      call window  (0,screen.width,0,screen.height);      call connect (tds.minx,tds.miny,tds.minx,tds.maxy);    /* draw amplitude axis */      call connect (tds.minx-3,tds.maxy-3,tds.minx,tds.maxy);/* draw arrow head */      call connect (tds.minx+3,tds.maxy-3,tds.minx,tds.maxy);      call connect (tds.minx,tds.miny,tds.maxx,tds.miny);    /* draw coefficient axis */      call connect (tds.maxx,tds.miny,tds.maxx+plot.time,tds.miny+plot.time);      call viewport(tds.minx,tds.maxx,tds.miny-tds.space,tds.miny);      call window  (0,max.harm+1,0,tds.space);      call draw_coefficient_tics;                            /* draw coefficent tic marks */      call viewport(tds.minx,tds.maxx,tds.miny-2*char.height,tds.miny); /* label coefficient axis */      call window  (0,max.harm+1,0,2*char.height);      call move_to (6,0);      call pstring ('Harmonic Coefficients');                      call viewport(tds.minx-char.width,tds.maxx,tds.miny,tds.maxy); /* label amplitude axis */      call window  (0,max.harm+1,0,10);      call draw_vertical_label('Amplitude');      call viewport(tds.maxx,tds.maxx+plot.time,tds.miny,tds.maxy);     /* show direction with an arrow */      call window (0,plot.height,0,plot.height);      if mg600 then do;         call move_to(135,88);         alpha_mode;         call ps('Splice');         call move_to(148,66);         alpha_mode;         call ps('Time');         call connect(160,122,180,150);  /* draw directional arrow */         call connect(180,140,180,150);          call connect(172,144,180,150);      end;      else do;         call move_to(75,80);         alpha_mode;         call ps('Splice');         call move_to(80,65);         alpha_mode;         call ps('Time');         call connect(59,70,74,100);  /* draw directional arrow */         call connect(70,97,74,100);          call connect(73,94,74,100);      end;      transparent_mode;             /* prompt for partial timbre display */      call DRAW.MENU.SELECTION(23); /* draw the menu selection line */      tds.choice=4; tds.last.choice=4;      /* set the menu selection to the display screen */      call POS.CHOICE.CURSOR(23);   end FRAME_GRAPH_DISPLAY;   /* $Subtitle Update the 3D Harmonic and Pitch Offset Display */   UPDATE.FRAME.GRAPH.DISP: proc swapable;      dcl pt#         fixed; /* partial timbre number */      dcl num.frames  fixed; /* number of timbre frames */      pt#=FIND.PARTIAL;      if TIM.HEAD.LOOKUP(0,tim.synth.typ+pt#)<2 /* if a synthesized timbre */      then num.frames=COUNT.TIMBRE.FRAMES(pt#); /* find number of timbre frames */      else num.frames=0;              /* if a patched list timbre */      call clear.term;                /* clear screen */      call SET.TDS.TERMINAL.DISPLAY.VARIABLES;      call viewport (0,screen.width,0,screen.height);      call window   (0,screen.width,0,screen.height);      if D44_present      then call PLOT.MOUSE.HOLE(mouse.hole.lowerx,mouse.hole.lowery); /* if device available draw the mouse hole */      call FRAME_GRAPH_DISPLAY;        /* display the screen frame */      call DISP.TIMBRE.FRAME(pt#);      if (mg600<>0) and (#mode=#point) /* if pericom and in point mode */      then alpha_mode;                 /* if in point_mode have to do a alpha_mode for transparent_mode */      transparent_mode;                /* RETURN in TRANSPARENT_MODE */   end UPDATE.FRAME.GRAPH.DISP;