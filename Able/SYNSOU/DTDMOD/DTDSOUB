/* DTDSOUB $Title Direct-to-Disk Multi-Track Recording Routines *//*   06/25/91 - cj - Added calls to check.next.event to speed up GPI   01/23/89 - cj - changes for multi-track DDT   04/29/88 - CJ  added Direct-Digital-Transfer field   04/26/88 - JSS - Displays and accepts front end gain in dBm, not "times"   11/12/87 - MWH - Make timer comparisons unsigned to fix "30 sec hang"   02/26/87 - BSW - part of the Direct-to-Disk Screen Module, DTDMOD*/   dcl previous.lod.recd.tracks fixed;   /* previous live recording tracks */   dcl Previous.Highlight.Code  fixed;   /* Holds information to detect     */                                         /* change in highlighting          */                                         /*   lower 8 bits = field (0-10)   */                                         /*   next  7 bits = dtd.track#     */                                         /*   top   1 bit  = 1 if cur obj   */                                         /*                  ID was display */                                         /*                  area           */   dcl Sampled.DTD.Track#   fixed;   dcl curr.fld             fixed;   /* current field number        */   dcl rec.max.tlen         fixed;   /* maximum token length        */   dcl trk.title(8)         fixed;   /* title of current selection  */   dcl track.command        fixed;   /* if track command   */   dcl track.command.type   fixed;   /* track command type */   SET.REC.MAX.TLEN:  proc swapable; /* sets the var REC.MAX.TLEN to correct value */      /*  This procedure looks at CURR.FLD          to determine the proper max length for TOKEN() */      dcl rec.max.tlen.values data (0, 16, 0, 0, 0, 2, 2, 2, 5, 3, 2);      rec.max.tlen=rec.max.tlen.values(curr.fld);   end SET.REC.MAX.TLEN;   /* $page */   /* convert two character string (in TOKEN) in format 1A - 4D */   /* to coded input # 1 - 16.   0 returned as 0                */   READ.INPUT.CHANNEL:  proc fixed swapable;      /* reads and translates user specified input channel */      dcl (i,j)  fixed;      dcl ch     fixed;      dcl chan   fixed;      GETC:  proc fixed;                    /* get next char from token buffer */         if tok.ptr=token(0) then return 0; /* return null at end of string */         tok.ptr=tok.ptr+1;                 /* increment pointer */         return byte(token,tok.ptr-1);      end GETC;      chan=-1;      tok.ptr=0;      ch=GETC;      if (ch<asc.0) or (ch>asc.4)      then call format.error;      else do;         i=ch-asc.0;         if (i<>0) then do;            ch=GETC;            if ((ch>=asc.a) and (ch<=asc.d)) or ((ch>=lower.a) and (ch<=lower.d)) then do; /* if A, B, C, or D */               if ((ch>=asc.a) and (ch<=asc.d))               then j=asc.d-ch;               else j=lower.d-ch;               chan=i*4-j;            end;            else call format.error;         end;         else chan=i;      end;      return chan;   end READ.INPUT.CHANNEL;   /* $Subtitle Print Current Song Information */   /* print song title on track directory */   PRINT.SONG.TITLE:  proc swapable;  /* prints current song info */      dcl (i,j) fixed;      call cpos(sng.yloc,sng.title.xloc);      call Set.Term.Attr(Attr#Normal   );      do i=0 to title.length-1;         /* loop over words of song title*/         j=title.off+i;                 /* compute pointer */         write(mam)=trd.ptr+2;         write(mal)=j;         j=read(md);         if  (j&255)>sp then call pc(j&255);    else call pc(sp); /* print character */         if shr(j,8)>sp then call pc(shr(j,8)); else call pc(sp);      end;      call Check.Next.Event;   end PRINT.SONG.TITLE;   /* print song start on track directory */   PRINT.SONG.START:  proc swapable;      dcl (i,j) fixed;      call cpos(sng.yloc,sng.start.xloc);      call Set.Term.Attr(Attr#Normal   );      write(mam)=trd.ptr+2;      write(mal)=start.time.off;      i=read(md);                              /* time is in seconds */      if i>=0 then do;                         /* if valid */         load i; div 60; i=res; j=rem;         /* convert seconds to minutes and seconds */         if i>0          then call print.parm(i,0,0,3,0);      /* print minutes */         else call ps('   ');                  /* otherwise print three spaces */         call pc(colon);         call print_digits(j,2);               /* print seconds */      end;      else call ps('      ');      call Check.Next.Event;   end PRINT.SONG.START;   /* print song end on track directory */   PRINT.SONG.END:  proc swapable;      dcl (i,j) fixed;      call cpos(sng.yloc,sng.end.xloc);      call Set.Term.Attr(Attr#Normal   );      write(mam)=trd.ptr+2;      write(mal)=end.time.off;      i=read(md);                              /* time is in seconds */      if i>=0 then do;                         /* if valid */         load i; div 60; i=res; j=rem;            /* convert seconds to minutes and seconds */         if i>0          then call print.parm(i,0,0,3,0);         /* print minutes */         else call ps('   ');                     /* otherwise print three spaces */         call pc(colon);         call print_digits(j,2);                 /* print seconds */      end;      else call ps('      ');      call Check.Next.Event;   end PRINT.SONG.END;   /* print song sampling rate on track directory */   PRINT.SONG.SRATE:  proc swapable;      dcl i fixed;      call cpos(sng.yloc+1,sng.rate.xloc);      call Set.Term.Attr(Attr#Normal   );      write(mam)=trd.ptr+2;      write(mal)=rate.off;      i=read(md);      if i>=0       then call print.parm(i,0,0,5,1);      else call ps('     ');      call Check.Next.Event;   end PRINT.SONG.SRATE;   /* $page */   /* print song time available on track directory */   PRINT.SONG.AVAIL:  proc swapable;      dcl (i,j)      fixed;      dcl end.time   fixed;      dcl start.time fixed;      dcl song.rate  fixed;      write(mam)=trd.ptr+2;               /* find end time */      write(mal)=end.time.off;      end.time=read(md);      write(mam)=trd.ptr+2;               /* find start time */      write(mal)=start.time.off;      start.time=read(md);                /* time is in seconds */      write(mam)=trd.ptr+2;               /* find sample rate */      write(mal)=rate.off;      song.rate=read(md);      i=end.time-start.time;              /* avail time=((end-start)*500)/rate */      load i; mul 500; i=res;      div song.rate; i=res; j=rem;      if j<>0 then i=i+1;                 /* round up */      call cpos(sng.yloc+1,sng.avail.xloc);      call Set.Term.Attr(Attr#Normal   );      load i; div 60; i=res; j=rem;      /* convert seconds to minutes and seconds */      if i>0      then call print.parm(i,0,0,3,0);   /* print minutes */      else call ps('   ');               /* print three spaces */      call pc(colon);      call print_digits(j,2);            /* print seconds */      call Check.Next.Event;   end PRINT.SONG.AVAIL;   /* print song used on track directory */   PRINT.SONG.USED:  proc swapable;      dcl (i,j) fixed;      call cpos(sng.yloc+1,sng.used.xloc);      call Set.Term.Attr(Attr#Normal   );      write(mam)=trd.ptr+2;      write(mal)=used.off;      i=read(md);                                 /* time is in seconds */      if i>=0 then do;                            /* if not empty  */         write(mam)=trd.ptr+2;         write(mal)=rate.off;         j=read(md);                              /* scale time used by sampling rate */         load i; mul 500; mwait;         div j; i=res; j=rem;         if j<>0 then i=i+1;         load i; div 60; i=res; j=rem;            /* convert seconds to minutes and seconds */         if i>0          then call print.parm(i,0,0,3,0);         /* print minutes */         else call ps('   ');                     /* otherwise print three spaces */         call pc(colon);         call print_digits(j,2);                 /* print seconds */      end;      else call ps('      ');      call Check.Next.Event;   end PRINT.SONG.USED;   /* print song status on track directory */   PRINT.SONG.STATUS:  proc swapable;      dcl (i,j) fixed;      call cpos(sng.yloc+1,sng.stat.xloc);       call Set.Term.Attr(Attr#Normal    );      write(mam)=trd.ptr+2;      write(mal)=song.stat.off;      j=read(md);      if j>=0 then do;                   /* if valid */         if (j&1)=0         then    call ps('Empty  ');         else do;            if (j&2)=0            then call ps('*READY*');            else call ps('Locked ');         end;      end;      else call ps('       ');      call Check.Next.Event;   end PRINT.SONG.STATUS;   /* $page */   /* print song crossfade on track directory */   PRINT.SONG.CROSSFADE:  proc swapable;  /* prints punch in crossfade */      dcl i  fixed;      call cpos(sng.yloc+1,sng.cross.xloc);       call Set.Term.Attr(Attr#Normal    );      write(mam)=trd.ptr+2;      write(mal)=cross.off;      i=read(md);      if i>=0      then call print.parm(i,0,0,2,0);      else call ps('  ');      call Check.Next.Event;   end PRINT.SONG.CROSSFADE;   /* $Subtitle Print Track Information for Direct-to-Disk Track Display */   /* Highlighting:                                                      */   /* Set.Dtd.Highlighting (track#, field)                               */   /* sets normal or reverse video mode so that the entry can be printed */   /* on the terminal                                                    */   Set.DTD.Highlighting:proc (track#, field#) swapable;      dcl track# fixed;      dcl field# fixed;      if  (track#     = Sampled.DTD.Track#)  /* if current track        */      and (field#     = Curr.Fld          )  /* and field               */      and (Cur.Obj.Id <> DTD.Time.Display )  /* and cur obj is display  */      then call Set.Term.Attr(Attr#Normal \ Attr#Reverse);      else call Set.Term.Attr(Attr#Normal               );   end Set.DTD.Highlighting;   /* Print.Track.Button prints out the VK button that is assigned to */   /* this DTD track# (if any).   Trk# passed is 0 - 15.              */   /* routine looks in the Synclavier's VK button map table to see    */   /* if any button is assigned to this DTD track                     */   PRINT.TRACK.BUTTON:  proc (trk#) swapable;      dcl trk# fixed;      dcl i fixed;      call cpos(trk.yloc+trk#,button.xloc);      call Set.DTD.Highlighting(trk#, 0);      do i=0 to num.track.buttons-1;      /* see if this lod trk has a button */         write(mam)=tbut.ptr;         write(mal)=i;         if  (read(md)&255)=first.lod.track+trk#         then do;            call ps('(');            call print.parm(i+1,0,0,2,0);            call ps(')');            return;         end;      end;      call ps('    ');      call Check.Next.Event;   end PRINT.TRACK.BUTTON;   /* print track task is called to print a * or a +  beside those tracks */   /* that have commands outstanding                                      */   PRINT.TRACK.TASK:  proc(trk#) swapable;   /* gives an indication as to what is happening to track */      /*  nothing means nothing, star means waiting to perform task, and plus means performing task */      dcl trk#  fixed;      dcl (i,j) fixed;      call cpos(trk#+trk.yloc,ttask.xloc);      call Set.Term.Attr(Attr#Normal    );      i=song.blen+trk#*mtrk.blen+ttask.off;    /* compute pointer to perform task word*/      write(mam)=trd.ptr+2+shr(i,8);      write(mal)=i&255;      i=read(md);      if i <> (-1) then do;                   /* if valid */         do case i&3;            call ps(' ');                     /* no tasks to perform       */            call ps('*');                     /* waiting to perform task   */            call ps('+');                     /* currently performing task */            call ps(' ');         end;      end;      else call ps(' ');                     /* no tasks to perform */      call Check.Next.Event;   end PRINT.TRACK.TASK;   /* print track name prints the current track name */   PRINT.TRACK.NAME: proc(trk#) swapable;  /* prints track name */      dcl trk#  fixed;      dcl (i,j) fixed;      call cpos(trk#+trk.yloc,tname.xloc);      call Set.DTD.Highlighting(trk#, 1);      do i=0 to trk.title.length-1;        /* loop over words of song title*/         j=song.blen+trk#*mtrk.blen+i;               /* compute pointer */         write(mam)=trd.ptr+2+shr(j,8);         write(mal)=j&255;         j=read(md);         if j=(-1) then j=sp\shl(sp,8);         if  (j&255)>sp then call pc(j&255);    else call pc(sp); /* print character */         if shr(j,8)>sp then call pc(shr(j,8)); else call pc(sp);      end;      call Check.Next.Event;   end PRINT.TRACK.NAME;   PRINT.TRACK.STATUS:  proc(trk#) swapable;    /* print track status */      dcl trk#  fixed;      dcl (i,j)    fixed;      call cpos(trk.yloc+trk#,tstat.xloc);      call Set.DTD.Highlighting(trk#, 2);      if ((dtd.avail.trks)&bits(trk#))=0      then call ps('Unavail');      else do;         i=song.blen+trk#*mtrk.blen+tstat.off;      /* compute pointer */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         if read(md) < 0                            /* no data yet     */         then call ps('       ');         else do;                                   /* data is there   */            j=read(md)&255;            write(mam)=trd.ptr+4+shr(i,8);          /* update display  */            write(mal)=i&255;                       /* area here       */            write(md )=(read(md)&"177400")\j;            if (j&2)=0 then do;                     /* if unlocked */               do case (j&1);                  call ps('Safe   ');                  call ps('*READY*');               end;            end;            else call ps('Locked ');         end;      end;      call Check.Next.Event;   end PRINT.TRACK.STATUS;   /* $page */   PRINT.TRACK.MODE:  proc(trk#) swapable;      dcl trk#   fixed;      dcl (i,j)  fixed;      call cpos(trk#+trk.yloc,tplay.xloc);      call Set.DTD.Highlighting(trk#, 3);      if (dtd.avail.trks&bits(trk#))=0      then call ps('      ');      else do;         i=song.blen+trk#*mtrk.blen+tstat.off;      /* see if track is unavailable */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         if read(md) < 0                            /* no data yet     */         then call ps('      ');         else do;                                   /* if valid        */            i=song.blen+trk#*mtrk.blen+tstat.off;            write(mam)=trd.ptr+2+shr(i,8);            write(mal)=i&255;            j=shr(read(md),8);            write(mam)=trd.ptr+4+shr(i,8);          /* update display area */            write(mal)=i&255;                       /* here for faster     */            write(md )=(read(md)&255)\shl(j,8);     /* toggles             */            do case j;               call ps('Repro ');               call ps('Input ');               call ps('Auto  ');               call ps('Cue PB');            end;         end;      end;      call Check.Next.Event;   end PRINT.TRACK.MODE;   PRINT.TRACK.TIME.USED:  proc(trk#) swapable; /* prints time available on the track */      dcl trk#  fixed;      dcl (i,j) fixed;      call cpos(trk#+trk.yloc,tused.xloc);      call Set.Term.Attr(Attr#Normal    );      if (dtd.avail.trks&bits(trk#))=0      then call ps('      ');      else do;         i=song.blen+trk#*mtrk.blen+tused.off;    /* compute pointer to track time used*/         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i=read(md);                              /* time is in seconds */         if i < 0                                 /* no data available  */         then call ps('      ');         else do;                                 /* data is there      */            write(mam)=trd.ptr+2;            write(mal)=rate.off;            j=read(md);                           /* scale time used by song sampling rate */            load i; mul 500; mwait;            div j; i=res; j=rem;            if j<>0 then i=i+1;            load i; div 60; i=res; j=rem;         /* convert seconds to minutes and seconds */            if i IGT 999 then call ps ('***');            else if i>0             then call print.parm(i,0,0,3,0);      /* print minutes */            else call ps('   ');                  /* otherwise print three spaces */            call pc(colon);            call print_digits(j,2);               /* print seconds */         end;      end;      call Check.Next.Event;   end PRINT.TRACK.TIME.USED;   /* $page */   PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN:  proc(trk#,code) swapable; /* prints input channel number */      dcl trk#  fixed;    /* track #, 0 - 15                         */      dcl code  fixed;    /* 0 = print all 3 fields                  */                          /* 1 = print source only (cursor move)     */                          /* 2 = print channel only (cursor move)    */                          /* 3 = print gain only    (cursor move)    */      dcl (i,j) fixed;      dcl (k,l) fixed;      dcl (source)   fixed;      dcl (chanl )   fixed;      dcl (gain  )   fixed;      /* look up source and channel # */      i=song.blen+trk#*mtrk.blen+tinchan.off;      write(mam)=trd.ptr+2+shr(i,8);      write(mal)=i&255;      k=read(md);      source = shr(k,8);    /* extract source */      chanl  = k & 255;     /* and channel    */            /* look up gain                 */      j=song.blen+trk#*mtrk.blen+tgain.off;             /* compute pointer */      write(mam)=trd.ptr+2+shr(j,8);      write(mal)=j&255;      gain = read(md);      /* see if no valid data received */      /* or  if track is not avail     */      if  (source IGT 3)                       /* data is not available */      or  ((dtd.avail.trks&bits(trk#))=0)      /* or trk not available  */      then do;         if  (code = 0)         or  (code = 1)         then do;            call cpos(trk.yloc+trk#,insrc.xloc);            call Set.DTD.Highlighting(trk#, 4);            call ps('   ');         end;         if  (code = 0)         or  (code = 2)         then do;            call cpos(trk.yloc+trk#,inchan.xloc);            call Set.DTD.Highlighting(trk#, 5);            call ps('  ');         end;         if  (code = 0)         or  (code = 3)         then do;            call cpos(trk.yloc+trk#,tgain.xloc);            call Set.DTD.Highlighting(trk#, 6);            call ps('  ');         end;         return;      end;      /* print out source code: */      if  (code = 0)      /* if print all fields        */      or  (code = 1)      /* or just source field...    */      then do;         call cpos(trk.yloc+trk#,insrc.xloc);         call Set.DTD.Highlighting(trk#, 4);         do case (source);            call ps('STM');            call ps('DIG');            call ps('OUT');            call ps('TRK');         end;         write(mam)=trd.ptr+4+shr(i,8);           /* update display area */         write(mal)=i&255;                        /* here for faster     */         write(md )=(read(md)&255)\shl(source,8); /* toggles             */      end;      /* print out input channel */      if  (code = 0)     /* if print of all fields desired     */      or  (code = 2)     /* or print of just input channel ... */      then do;         call cpos(trk.yloc+trk#,inchan.xloc);         call Set.DTD.Highlighting(trk#, 5);         /* If using multi track DDT,  print -- or input # if avail */         if  (source = 1)              /* DIG input                 */         and ((ddt.config & 15) = 2)   /* multi track DDT avail     */         then do;            if (ddt.avail.trks & bits(trk#)) = 0            then call ps('--');        /* print -- if not avail     */            else call print.parm(trk#+1, 0, 0, 2, 0); /* else #     */         end;         else if chanl = 0             /* spaces if no input assigned   */         then call ps('  ');         else if source = 0            /* if STM, then use 1A, 1B, etc  */         then do;            load chanl-1; div 4; k = res; l = rem;            call print.parm(k+1, 0, 0, 1, 0);            call pc(asc.a + l);         end;         else do;            call print.parm(chanl, 0, 0, 2, 0);         end;         write(mam)=trd.ptr+4+shr(i,8);           /* update display area */         write(mal)=i&255;                        /* here for faster     */         write(md )=(read(md)&"177400")\chanl;    /* toggles             */      end;      /* print out gain */      if  (code = 0)      or  (code = 3)      then do;         call cpos(trk.yloc+trk#,tgain.xloc);         call Set.DTD.Highlighting(trk#, 6);         if source<>0         then call ps('  ');       /* no gain unless STM */         else do;                  /* print out gain     */            k = map_times_to_dB (gain);       /* convert "times" value to dB   */            if k < 0 then do;               call ps('-');               call print.parm (abs(k),0,0,1,0);            end;            else do;               call print.parm (abs(k),0,0,2,0);            end;         end;         write(mam)=trd.ptr+4+shr(j,8);    /* update display area here */         write(mal)=j&255;                 /* for faster toggles       */         write(md )=gain;      end;      call Check.Next.Event;   end PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN;   /* $page = print track DOA routing */   PRINT.TRACK.DOA:  proc(trk#) swapable; /* prints track volume */      dcl trk#  fixed;      dcl (i,j) fixed;      call cpos(trk.yloc+trk#,tdoa.xloc);      call Set.DTD.Highlighting(trk#, 7);      if ((dtd.avail.trks&bits(trk#))=0)      /* if trk not available  */      then call ps('  ');      else do;         i=song.blen+trk#*mtrk.blen+trout.off; /* compute pointer to track routing */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         if read(md)>=0 then do;               /* if valid data there */            j=read(md)&255;                    /* get doa routing     */            if j <> 0            then call print.parm(j,0,0,2,0);            else call ps('  ');            write(mam)=trd.ptr+4+shr(i,8);    /* update display area here */            write(mal)=i&255;                 /* for faster toggles       */            write(md )=(read(md)&"177400")\j;         end;         else call ps('  ');      end;      call Check.Next.Event;   end PRINT.TRACK.DOA;   PRINT.TRACK.VOL:  proc(out#) swapable; /* prints track volume */      dcl out#  fixed;      dcl (i,j) fixed;      call cpos(trk.yloc+out#,tvol.xloc);      call Set.DTD.Highlighting(out#, 8);      if  (out# IGE Dtd.Num.Voices)            /* if output not available */      and ((dtd.avail.trks&bits(out#))=0)      /* and track not available */      then call ps('     ');      else do;         i=song.blen+out#*mtrk.blen+tvol.off;  /* compute pointer to track volume */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i=read(md);         if i>=0                               /* if valid */         then call print.parm(i,0,0,5,1);         else call ps('     ');      end;      call Check.Next.Event;   end PRINT.TRACK.VOL;   PRINT.TRACK.PAN:  proc(out#) swapable;     /* prints track pan  */      dcl out#  fixed;      dcl (i,j) fixed;      call cpos(trk.yloc+out#,tpan.xloc);     /* move to pan location */      call Set.DTD.Highlighting(out#, 9);      if  (out# IGE Dtd.Num.Voices)            /* if output not available */      and ((dtd.avail.trks&bits(out#))=0)      /* and track not available */      then call ps('   ');      else do;         i=song.blen+out#*mtrk.blen+tstat.off;   /* see if track is available */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         if read(md)>=0 then do;                 /* if valid */            i=song.blen+out#*mtrk.blen+tpan.off; /* compute pointer to track pan*/            write(mam)=trd.ptr+2+shr(i,8);            write(mal)=i&255;            i=read(md);            call print.parm(i,0,1,3,0);         end;         else call ps('   ');      end;      call Check.Next.Event;   end PRINT.TRACK.PAN;   /* $page - print out DDT output routing */   PRINT.TRACK.DIG:  proc(out#) swapable;     /* prints track DDT routing */      dcl out#  fixed;      dcl (i,j) fixed;      call cpos(trk.yloc+out#,tdig.xloc);     /* move to DDT location */      call Set.DTD.Highlighting(out#, 10);      if  (out# IGE Dtd.Num.Voices)            /* if output not available */      and ((dtd.avail.trks&bits(out#))=0)      /* and track not available */      then call ps('  ');      else do;         i=song.blen+out#*mtrk.blen+trout.off; /* compute pointer to track routing */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         if read(md)>=0 then do;               /* if valid data there */            j=shr(read(md),8);                 /* get ddt routing     */            /* If using multi track DDT,  print -- or input # if avail */            if ((ddt.config & 15) = 2)    /* multi track DDT avail     */            then do;               if (ddt.avail.trks & bits(out#)) = 0               then call ps('--');        /* print -- if not avail     */               else call print.parm(out#+1, 0, 0, 2, 0); /* else #     */            end;            else if j <> 0            then call print.parm(j,0,0,2,0);            else call ps('  ');            write(mam)=trd.ptr+4+shr(i,8);    /* update display area here */            write(mal)=i&255;                 /* for faster toggles       */            write(md )=(read(md)&255)\shl(j,8);         end;         else call ps('  ');      end;      call Check.Next.Event;   end PRINT.TRACK.DIG;   /* $Subtitle Direct-to-Disk Track Display Prompts and Cursor Routines*/   MULTI.TRACK.REC.DISPLAY.COMMANDS:  proc swapable;      dcl i fixed;      dcl cmd.line lit '21';      dcl column1  lit '2';      dcl column2  lit '20';      dcl column3  lit '38';      dcl column4  lit '51';      dcl column5  lit '67';      call cpos(cmd.line,  column1); call ps('^A Backup Track');         call cpos(cmd.line+1,column1); call ps('^B Load Track');      call cpos(cmd.line,  column2);call ps('^C Erase Track');      call cpos(cmd.line+1,column2);call ps('^D Enter Fade');      call cpos(cmd.line,  column3);call ps('^U UnLock');          call cpos(cmd.line+1,column3);call ps('^V Lock');      call cpos(cmd.line,  column4);call ps('^W All Repro');             call cpos(cmd.line+1,column4);call ps('^X All Input');      call cpos(cmd.line,  column5);call ps('^Y All Auto');      call cpos(cmd.line+1,column5);call ps('^Z All Safe');   end MULTI.TRACK.REC.DISPLAY.COMMANDS;   FIND.TRACK.TITLE.LENGTH:  proc fixed swapable;  /* finds and returns the number of characters in the track title for positioning prompt cursor */      dcl (i,j)              fixed;      dcl ch                 fixed;      dcl title.ptr          fixed;      trk.title(0)=0;      do i=0 to trk.title.length-1;               /* put title in temporary array */         j=song.blen+dtd.track#*mtrk.blen+i;         write(mam)=trd.ptr+2+shr(j,8);         write(mal)=j&255;         j=read(md);         if j=(-1) then j=shl(sp,8)\sp;         call pbyte(trk.title,trk.title(0),j&255);         trk.title(0)=trk.title(0)+1;         call pbyte(trk.title,trk.title(0),shr(j,8));         trk.title(0)=trk.title(0)+1;      end;      title.ptr=trk.title(0)-1;             /* set up title to print later */      ch=byte(trk.title,title.ptr);      do while (ch=sp) and (title.ptr>=0);  /* peel of the trailing spaces to count num of characters */         call pbyte(trk.title,title.ptr,0); /* put 0 instead of space      */         title.ptr=title.ptr-1;         if title.ptr>=0         then ch=byte(trk.title,title.ptr);      end;      return (title.ptr+1);   end FIND.TRACK.TITLE.LENGTH;   FIND.TRACK.NUM.LENGTH:  proc fixed swapable;   /* finds and returns  character length of track number */      if dtd.track#<10      then return 1;        /* one character long */      else return 2;        /* two */   end FIND.TRACK.NUM.LENGTH;   PRINT.TRACK.PROMPT:  proc swapable; /* prints track title in the command prompt */      dcl i fixed;      call pnum(dtd.track#+1,0);      i=FIND.TRACK.TITLE.LENGTH;      if i<>0 then do;        /* if there is a title print it */         trk.title(0)=i;         call ps(', ');         call ps('"');         call ps(trk.title);         call ps('"');      end;      call ps(' ->');   end PRINT.TRACK.PROMPT;   /* $page */   DISPLAY.TRACK.PROMPT:  proc swapable; /* displays command prompt */      if track.command<>0 then do;         call cpos(23,2);         call Set.Term.Attr(Attr#Normal);         if track.command.type<>3 then do;             if track.command.type=1            then call ps('Type LOAD ');            else if track.command.type=2            then call ps('Type ERASE ');            else call ps('Type OK ');            call ps('and press <RETURN> to ');         end;         do case (track.command.type);            do;                                        /* 0: backup track */               call ps('backup track ');               /* extends to (23,44) */               call PRINT.TRACK.PROMPT;            end;            do;                                        /* 1: load track */               call ps('load track ');                 /* extends to (23,42) */               call PRINT.TRACK.PROMPT;            end;            do;                                        /* 2: erase track */               call ps('erase track ');                /* extends to (23,45) */               call PRINT.TRACK.PROMPT;            end;            do;               call ps('Enter Punch In Crossfade ->'); /* 3: enter crossfade */            end;            do;                                        /* 4: unlock track */               call ps('unlock track ');                           call PRINT.TRACK.PROMPT;            end;            do;                                        /* 5: lock track */               call ps('lock track ');                 /* extends to (23,42) */               call PRINT.TRACK.PROMPT;            end;            call ps('repro all tracks ->');           /* 6: repro all */            call ps('input all tracks ->');           /* 7: input all */            call ps('auto all tracks ->');            /* 8: auto all */            call ps('safe all tracks ->');            /* 9: safe all; extends to (23,48) */         end;         prompt.xpos=screen.x + 1;         track.command=1;         dtd.prompt=1;      end;   end DISPLAY.TRACK.PROMPT;   /* $Subtitle Multi-Track Recording Cursor Routine */                  /* Print.Field - reprints field for highlighting changes */   Print.Field: proc (track#, field#);      dcl (Track#, Field#)  fixed;      dcl (i,j)  fixed;      do case(field#);         call PRINT.TRACK.BUTTON(Track#);     /* prints track number */         call PRINT.TRACK.NAME(Track#);         call PRINT.TRACK.STATUS(Track#);      /* prints safe,ready or unavailable */         call PRINT.TRACK.MODE(Track#);        /* prints input, auto, or repro */         call PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN(Track#,0); /* source - also print chanl & gain when source changes */         call PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN(Track#,2); /* just chanl  */         call PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN(Track#,3); /* just gain   */         call PRINT.TRACK.DOA(Track#);         /* doa output routing        */         call PRINT.TRACK.VOL(Track#);         /* output volume             */         call PRINT.TRACK.PAN(Track#);         /* output pan                */         call PRINT.TRACK.DIG(Track#);         /* digital output routing    */      end;   end Print.Field;   Pos.DTD.Cursor.For.Input:proc swapable;      if Cur.Obj.Id = DTD.Time.Display      /* if cur obj is time display */      then return;                          /* area,  then quit           */      if (track.command<>0) and (dtd.prompt<>1) then do;  /* if another error displayed */         track.command=0;         dtd.prompt=0;         token(0)=0;      end;      if track.command<>0 then do;     /* if responding to a command prompt */         call cpos(23,prompt.xpos);         call Set.Term.Attr(ATTR#Normal);      end;      else do case(Curr.fld);         call cpos(trk.yloc+Sampled.DTD.Track#,button.xloc);  /* button number */         call cpos(trk.yloc+Sampled.DTD.Track#,tname.xloc);   /* track nume */         call cpos(trk.yloc+Sampled.DTD.Track#,tstat.xloc);   /* safe,ready,locked or rehearse */         call cpos(trk.yloc+Sampled.DTD.Track#,tplay.xloc);   /* repro, input, or auto */         call cpos(trk.yloc+Sampled.DTD.Track#,insrc.xloc);   /* input source  */         call cpos(trk.yloc+Sampled.DTD.Track#,inchan.xloc);  /* input channel */         call cpos(trk.yloc+Sampled.DTD.Track#,tgain.xloc);   /* gain */         call cpos(trk.yloc+Sampled.DTD.Track#,tdoa.xloc);    /* doa routing */         call cpos(trk.yloc+Sampled.DTD.Track#,tvol.xloc);    /* volume */         call cpos(trk.yloc+Sampled.DTD.Track#,tpan.xloc);    /* pan */         call cpos(trk.yloc+Sampled.DTD.Track#,tdig.xloc);    /* DDT */      end;      if token(0)<>0      then do;         call Set.Term.Attr(ATTR#Reverse);         call ps(token);                   /* we have some characters to display */      end;      call Check.Next.Event;   end Pos.DTD.Cursor.For.Input;   /* $Subtitle Direct-to-Disk Track Display Snap Shot Routine */   MULTI.TRACK.REC.SNAP.SHOT:  proc swapable;  /* Direct-to-Disk Track Display Snap Shot Routine*/      dcl (i,j)              fixed;      call COPY.EXT.MEM.SEC(trd.ptr,trd.ptr+2,2);  /* copy from LOD to snap shot for 2 sectors */      call SET.REC.MAX.TLEN;         /* set the maximum token value */   end MULTI.TRACK.REC.SNAP.SHOT;    /* $page = change dtd highlighting */   /* Routine is called when current DTD.Track#,  Curr.Fld, or Cur.Obj.Id */   /* Changes.   routine un-highlights currently highlighted object       */   /* and highlights the new one                                          */   Change.DTD.Highlighting: proc(force) swapable;      dcl force   fixed;   /* 1: redraw field always   */      dcl newtrk  fixed;      newtrk = Curr.fld               /* sample field, track, ID   */             \ shl(DTD.Track#, 8)              \ shl(Cur.Obj.Id <> DTD.Time.Display, 15);      Sampled.DTD.Track# = DTD.Track#;      if  (newtrk <> Previous.Highlight.Code)   /* if new field       */      or  (force  <> 0                      )   /* or possible change */      then do;         if  (newtrk <> Previous.Highlight.Code)         then do;            if Previous.Highlight.Code < 0  /* if was highlighted - unhighlight */            then call Print.Field(shr(Previous.Highlight.Code,8)&127,                                      Previous.Highlight.Code   &255);            Previous.Highlight.Code = newtrk;         end;         if Previous.Highlight.Code < 0  /* if should be highlighted, do so  */         then call Print.Field(shr(Previous.Highlight.Code,8)&127,                                   Previous.Highlight.Code   &255);      end;      call Pos.DTD.Cursor.For.Input;   end Change.DTD.Highlighting;