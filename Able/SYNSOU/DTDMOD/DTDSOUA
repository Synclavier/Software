/* DTDSOUA $Title Direct-to-Disk Project Directory Routines *//*   11/18/91 - PF  - More quick update support   03/11/91 - cj  - Changed "show next proj" to "show proj info"   02/06/91 - cj  - reformulated screen for more tape commands   04/02/90 - cj  - added ADD password for add project, add all   03/22/89 - cj  - changed ERASE passwords   11/17/88 - cj - added ERASE 4TRK   11/16/88 - cj - fixed ERASE LONG - broken by 8/10/88 changes   11/16/88 - tss - Moved defaults info into .SDEF-7 file   08/10/88 - SGS added "New" command and Get.New.Project procedure   06/23/88 - cj  changed title and *READY* as per documentation request   06/15/88 - cj  finished up bounce and digital transfer   04/29/88 - CJ  added Direct-Digital-Transfer field*/   dcl prev.dtd.song#     fixed;   /* previous selection */   dcl prev.des           fixed;   /* previous selection description */   dcl curr.des           fixed;   /* current selection description */   dcl prev.max.secs      fixed;   /* previous maximum time available in seconds */   dcl prev.max.tracks    fixed;   /* previous maximum tracks available */   dcl sum.max.tlen       fixed;   /* maximum token length */   dcl #ypos              fixed;   /* y position on the screen indicates song number or command*/   dcl dtd.prompt         fixed;   /* if a command prompt do not display an error */   dcl prompt.xpos        fixed;   dcl song.command       fixed;   /* if a song command */   dcl song.command.type  fixed;   /* type of command */   SET.SUM.MAX.TLEN:  proc swapable; /* sets the var SUM.MAX.TLEN to correct value */      /*  This procedure looks at CURR.DES          to determine the proper max length for TOKEN() */      dcl sum.max.tlen.values data (24,6,6,6);      sum.max.tlen=sum.max.tlen.values(curr.des);   end SET.SUM.MAX.TLEN;   PRINT.TOT.TIME.AVAIL:  proc swapable;      dcl (i,j) fixed;      call cpos(4,43);      if dtd.max.secs>=0 then do;         load dtd.max.secs; div 60; i=res; j=rem;            /* convert seconds to minutes and seconds */         if i>0          then call print.parm(i,0,0,3,0);         /* print minutes */         else call ps('   ');                     /* otherwise print three spaces */         call pc(colon);         call cpos(4,47);         call print_digits(j,2);                 /* print seconds */      end;      else call ps('      ');   end PRINT.TOT.TIME.AVAIL;   PRINT.MAX.TRACKS.AVAIL:  proc swapable;      dcl i fixed;      dcl j fixed;      call cpos(4,70);      i = 0;      do j = 0 to 15;         if (dtd.avail.trks&bits(j))<>0         then i = i + 1;      end;      call print.parm(i,0,0,2,0);   end PRINT.MAX.TRACKS.AVAIL;   /* $Subtitle Print Song  Name, Number, Start and End Times */   PRINT.SONG.TASK:  proc(index) swapable;   /* gives an indication as to what is happening to track */      /*  nothing means nothing, star means waiting to perform task, and plus means performing task */      dcl index  fixed;      dcl (i) fixed;      call cpos(index+song.yloc,song.task.xloc);      i=index*song.blen+song.task.off;        /* compute pointer to perform task word*/      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);      if i>=0 then do;                        /* if valid */         do case i;            call ps(' ');                     /* no tasks to perform */            call ps('*');                     /* waiting to perform task */            call ps('+');                     /* currently performing task */         end;      end;      else call ps(' ');                      /* no tasks to perform */   end PRINT.SONG.TASK;   PRINT.NUMBER:  proc(index) swapable;   /* prints index number */      dcl index  fixed;      dcl (i,j)  fixed;      call cpos(song.yloc+index,num.xloc);      j=index*song.blen;                  /* compute pointer */      write(mam)=trd.ptr+1+shr(j,8);      write(mal)=j&255;      j=read(md);      if j>=0 then do;         call print.parm(j,0,0,2,0);         call pc(dot);      end;      else call ps('   ');   end PRINT.NUMBER;   PRINT.TNAME:  proc(song#) swapable; /* prints title cut */      dcl song#    fixed;              /* index to title */      dcl (i,j)   fixed;      call cpos(song.yloc+song#,title.xloc);      do i=0 to title.length-1;         /* loop over words of song title*/         j=song#*song.blen+title.off+i;  /* compute pointer */         write(mam)=trd.ptr+1+shr(j,8);         write(mal)=j&255;         j=read(md);         if j=(-1) then j=shl(sp,8)\sp;         if  (j&255)>sp then call pc(j&255);    else call pc(sp); /* print character */         if shr(j,8)>sp then call pc(shr(j,8)); else call pc(sp);      end;   end PRINT.TNAME;   PRINT.TIME.AVAIL:  proc (song#) swapable;      dcl song#      fixed;      dcl end.time   fixed;      dcl start.time fixed;      dcl song.rate  fixed;      dcl (i,j)      fixed;      i=song#*song.blen+end.time.off;     /* find end time */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      end.time=read(md);      i=song#*song.blen+start.time.off;   /* find start time */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      start.time=read(md);                /* time is in seconds */      i=song#*song.blen+rate.off;         /* find sample rate */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      song.rate=read(md);      i=end.time-start.time;              /* avail time=((end-start)*500)/rate */      load i; mul 500; mwait;      div song.rate; i=res; j=rem;      if j<>0 then i=i+1;                 /* round up seconds */      call cpos(song.yloc+song#,avail.xloc); /* move to available time location*/      load i; div 60; i=res; j=rem;      /* convert seconds to minutes and seconds */      if i>0      then call print.parm(i,0,0,3,0);   /* print minutes */      else call ps('   ');               /* print three spaces */      call pc(colon);      call cpos(song.yloc+song#,avail.xloc+4);      call print_digits(j,2);            /* print seconds */   end PRINT.TIME.AVAIL;   /* $page */   PRINT.START.TIME:  proc(song#) swapable;       /* prints start time in minutes and seconds */      dcl song#   fixed;      dcl (i,j)  fixed;      call cpos(song.yloc+song#,start.xloc);      /* start time */      i=song#*song.blen+start.time.off;           /* compute pointer */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);                                 /* time is in seconds */      if i>=0 then do;                            /* if valid */         load i; div 60; i=res; j=rem;            /* convert seconds to minutes and seconds */         if i>0          then call print.parm(i,0,0,3,0);         /* print minutes */         else call ps('   ');                     /* otherwise print three spaces */         call pc(colon);         call cpos(song.yloc+song#,start.xloc+4);         call print_digits(j,2);                  /* print seconds */      end;      else call ps('      ');   end PRINT.START.TIME;   PRINT.END.TIME:  proc(song#) swapable; /* prints ending time*/      dcl song#    fixed;      dcl (i,j)   fixed;      call cpos(song.yloc+song#,end.xloc);  /* ending time */      i=song#*song.blen+end.time.off;       /* compute pointer */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);      if i>=0 then do;                      /* if a valid time */         load i; div 60; i=res; j=rem;      /* convert seconds to minutes and seconds */         if i>0         then call print.parm(i,0,0,3,0);   /* print minutes */         else call ps('   ');               /* print three spaces */         call pc(colon);         call cpos(song.yloc+song#,end.xloc+4);         call print_digits(j,2);            /* print seconds */      end;      else call ps('      ');   end PRINT.END.TIME;   PRINT.SONG.RATE:  proc(song#) swapable;      dcl song#   fixed;      dcl i       fixed;      call cpos(song.yloc+song#,rate.xloc); /* move to sampling rate location */      i=song#*song.blen+rate.off;           /* compute pointer to sampling rate */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);      if i>=0      then call print.parm(i,0,0,5,1);      else call ps('     ');   end PRINT.SONG.RATE;   /* $page */   PRINT.TIME.USED:  proc (song#) swapable;      dcl song#      fixed;      dcl (i,j)      fixed;      dcl song.rate  fixed;      call cpos(song.yloc+song#,used.xloc); /* move to used location */      i=song#*song.blen+used.off;           /* compute pointer */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);      if i>=0 then do;                      /* if not empty  */         j=song#*song.blen+rate.off;        /* compute pointer */         write(mam)=trd.ptr+1+shr(j,8);         write(mal)=j&255;         song.rate=read(md);                /* scale time used by sampling rate */         load i; mul 500; mwait;         div song.rate; i=res; j=rem;         if j<>0 then i=i+1;                 /* round up seconds */         load i; div 60; i=res; j=rem;      /* convert used seconds to minutes and seconds */         if i>0         then call print.parm(i,0,0,3,0);   /* print minutes */         else call ps('   ');               /* print three spaces */         call pc(colon);         call cpos(song.yloc+song#,used.xloc+4);         call print_digits(j,2);            /* print seconds */      end;      else call ps('      ');   end PRINT.TIME.USED;   PRINT.SONG.STAT:  proc(song#) swapable;   /* Prints song sel status */      dcl song#     fixed;      dcl (i,j)    fixed;      call cpos(song.yloc+song#,song.stat.xloc);   /* move to status location*/      i=song#*song.blen+song.stat.off;             /* compute pointer to status*/      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      j=read(md);      if j>=0 then do;                             /* if valid */         if (j&1)=0         then    call ps('(Empty) ');         else do;            if (j&2)=0            then call ps('Unlocked');            else call ps('Locked  ');         end;      end;   end PRINT.SONG.STAT;   PRINT.MOD: proc(song#) swapable;    /* print whether song modified */      dcl song#    fixed;      dcl i       fixed;      call cpos(song.yloc+song#,modify.xloc); /* move to modify field */      i=song#*song.blen+modify.off;        /* look at modify word */      write(mam)=trd.ptr+1+shr(i,8);      write(mal)=i&255;      i=read(md);      if i>=0 then do;                    /* if not an empty song */         if i=0         then call ps('No ');         else call ps('Yes');      end;      else call ps('   ');   end PRINT.MOD;   /* $Subtitle Direct-to-Disk Song Directory Command Selection and Cursor*/   dcl column1  lit '11';   dcl column2  lit '28';   dcl column3  lit '44';   dcl column4  lit '58';   dcl column5  lit '70';   dcl column6  lit '79';   SONG.DIRECTORY.COMMAND.SELECTION:  proc swapable;      dcl line   lit  '18';      call cpos(line,3);      call ps  ('<CTRL>:');      call cpos(line,column1);  call ps('^A Backup Proj');      call cpos(line+1,column1);call ps('^B Load/Add Proj');      call cpos(line+2,column1);call ps('^C Erase Proj');      call cpos(line+3,column1);call ps(' Show Proj Info');      call cpos(line+4,column1);call ps(' Spin Disks');      call cpos(line,  column2);call ps('^D Backup All');         call cpos(line+1,column2);call ps('^E Load/Add All');      call cpos(line+2,column2);call ps('^F Erase All');      call cpos(line+3,column2);call ps(' Skip Forward');      call cpos(line+4,column2);call ps(' Sleep Disks');      call cpos(line,  column3);call ps('^O Home');      call cpos(line+1,column3);call ps('^R Verify');      call cpos(line+2,column3);call ps('^T Verify All');      call cpos(line+3,column3);call ps(' Skip Back');      call cpos(line+4,column3);call ps(' Format Disks');      call cpos(line,  column4);call ps('^U Unlock');          call cpos(line+1,column4);call ps('^V Lock');      call cpos(line+2,column4);call ps('^W Lock All');      call cpos(line+3,column4);call ps(' Dismount');      call cpos(line+4,column4);call ps(' Skip All');      call cpos(line,  column5);call ps('^X Eject');      call cpos(line+1,column5);call ps('^Y Abort');      call cpos(line+2,column5);call ps('^Z New');      call cpos(line+3,column5);call ps(' Mount');   end SONG.DIRECTORY.COMMAND.SELECTION;   GET.NEW.PROJECT: proc fixed swapable;      dcl proj.num    fixed; /* number of first empty project        */      dcl title       fixed; /* boolean to flag existence of a title */      dcl (i,j,k)     fixed;      dcl tmp(1)      fixed;      i=0; proj.num = -1;       /* find the first empty project */ /* (with no name ??)*/      do while (i<=40) and (proj.num = -1);         write(mam) = SCSI.Ptr;         write(mdi) = i;         if (!simulate.dtd) Send.To.Lod(189,2); /* get next ten songs */         j=0;         do while (j<10) and (proj.num = -1);            write(mam)=SCSI.Ptr;            write(mal)=24*j+1;            title=0;            do k=0 to title.length-1; /* check title ?? */               if (  read(md)&"377" <> a.sp)                or (shr(read(mdi),8) <> a.sp)               then; /* title=1; */            end;            if   (title=0)                /* no title                    */            and ((read(mdi)+read(mdi))=0) /* and start and end times = 0 */            then proj.num=i+j;            /* then found an empty one     */            j=j+1;         end;         i=i+10;      end;      if proj.num= -1 then return(0); /* all projects used */      call Select.DTD.Current.Project(proj.num); /* in :SYNSOU:AUDMOD:AUD-DTD */      /* set some things to default settings */      call STR32(DefDev,DefSec,tmp);      call ADD16(Info#AEEDefaults,tmp);      call Read.Defaults(D#In|D#Out|D#Samp|D#SIn|D#SDisp|D#SOffs|                         D#FDisp|D#FOffs|D#RecM|D#DForm,tmp(0),tmp(1));      return(1);                    /* successfully found an empty project */   end GET.NEW.PROJECT;   FIND.SONG.TITLE.LENGTH:  proc (title) fixed swapable;  /* finds and returns the number of characters in the song title for positioning prompt cursor */      /* NOTE: this procedure looks at title in display area because it is filled with spaces if not valid */      dcl title              array;      dcl (i,j)              fixed;      dcl ch                 fixed;      dcl title.ptr          fixed;      title(0)=0;      do i=0 to title.length-1;               /* put title in temporary array */         j=dtd.song#*song.blen+title.off+i;         write(mam)=trd.ptr+2+shr(j,8);         write(mal)=j&255;         j=read(md);         if j=(-1) then j=shl(sp,8)\sp;         call pbyte(title,title(0),j&255);         title(0)=title(0)+1;         call pbyte(title,title(0),shr(j,8));         title(0)=title(0)+1;      end;      title.ptr=title(0)-1;                 /* set up title to print later */      ch=byte(title,title.ptr);      do while (ch=sp) and (title.ptr>=0);  /* peel of the trailing spaces to count num of characters */         title.ptr=title.ptr-1;         if title.ptr>=0         then ch=byte(title,title.ptr);      end;      return (title.ptr+1);   end FIND.SONG.TITLE.LENGTH;   PRINT.SONG.PROMPT:  proc swapable; /* prints song title in the command prompt */      dcl i            fixed;      dcl title (12)   fixed;      i=FIND.SONG.TITLE.LENGTH(title);      if i<>0 then do;            /* if there is a title print it */         title(0)=i;         call ps(' ');         call ps('"');         call ps(title);         call ps('"');      end;   end PRINT.SONG.PROMPT;   /* $page */   DISPLAY.SONG.PROMPT:  proc swapable; /* displays command prompt */      if song.command<>0 then do;        		 call cpos(23,2);         		 if (song.command.type=1) or (song.command.type=4)      /* if a load command */         then call ps('Type LOAD or ADD ');         		 else if (song.command.type=2) /* ERASE PROJECT */         then call ps('Type ERASE ');        		 else if (song.command.type=5) /* ERASE ALL     */         then call ps('Type ERASE to ');         		 else if (song.command.type=27) /* FORMAT		*/         then call ps('Type FORMAT to ');       		 else call ps('Type OK ');         		 if ((song.command.type<>5 ) 		 &&  (song.command.type<>27))         then call ps('and press <RETURN> to ');         		 do case (song.command.type);            do;                                      	/* 0: backup song */               call ps('backup project');               call PRINT.SONG.PROMPT;               call ps(' ->');            end;            do;                                      	/* 1: load song */               call ps('load project');               call PRINT.SONG.PROMPT;               call ps(' ->');            end;            do;                                      	/* 2: erase song */               call ps('erase project');               call PRINT.SONG.PROMPT;               call ps(' ->');            end;            call ps('backup all projects ->');       	/* 3: backup all songs */            call ps('load all projects ->');         	/* 4: load all songs   */            call ps('erase all projects ->');        	/* 5: erase all songs */            call ps('go to the first project ->');   	/* 6: home */            call ps('verify the next project ->');   	/* 7: verify */            call ps('verify all of the projects ->');	/* 8: verify all */            do;                                      	/* 9: unlock song */               call ps('unlock project');               call PRINT.SONG.PROMPT;               call ps(' ->');            end;                                                 do;                                      	/* 10: lock song */               call ps('lock project');               call PRINT.SONG.PROMPT;               call ps(' ->');            end;            call ps('lock all projects ->');         	/* 11: lock all songs */            call ps('eject the tape ->');            	/* 12: eject */            call ps('abort process ->');             	/* 13: abort */            call ps('create new project ->');        	/* 14: new */            ;                                        	/* 15: used below used for erase long  */            ;                                        	/* 16: used below used for erase 4 trk */            ;                                        	/* 17: used below used for erase 2 trk */            ;                                        	/* 18: used below used for add proj    */            ;                                        	/* 19: used below used for add all     */            call ps('show project info ->');         	/* 20: show next proj */            call ps('skip forward one project ->');  	/* 21: skip forward   */            call ps('skip backward one project ->'); 	/* 22: skip back      */            call ps('dismount all drives ->');       	/* 23: dismount all   */            call ps('mount all drives ->');          	/* 24: mount all      */            call ps('spin up all drives ->');        	/* 25: spin	          */            call ps('sleep all drives ->');          	/* 26: sleep		    */            call ps('format all DTD hard drives ->');	/* 27: format all     */            call ps('skip over ALL PROJECTS ->');	   /* 28: skipfall       */         end;         song.command=1;         dtd.prompt=1;         prompt.xpos=screen.x;      end;   end DISPLAY.SONG.PROMPT;   /* $Subtitle Direct-to-Disk Song Directory Cursor Routine */   POS.SONG.DIRECTORY.CURSOR: proc swapable;    /* positions the star next to current selection */      dcl i             fixed;      dcl title (12)    fixed;      if inc.dtd=0 then return;      if (song.command<>0) and (dtd.prompt<>1) then do;  /* if another error displayed */         song.command=0;         dtd.prompt  =0;         token(0)=0;      end;     	  if song.command<>0 then do;  /* if responding to a command prompt */         call cpos(23,prompt.xpos);         call ps(token);      end;     	  else do;         do i=0 to 1;              /* first do previous then do current */            if ((i<>0) or          /* if current value or have changed positions */            (prev.dtd.song#<>dtd.song#) or            (prev.des<>curr.des)) then do;               if vt100<>0 then call reverse.video(i);  /* print value in reverse video */               if token(0)<>0 then do;                  do case(prev.des);                     call cpos(song.yloc+prev.dtd.song#,title.xloc);      /* title       */                     call cpos(song.yloc+prev.dtd.song#,start.xloc);      /* start time  */                     call cpos(song.yloc+prev.dtd.song#,end.xloc);        /* ending time */                     call cpos(song.yloc+prev.dtd.song#,rate.xloc);       /* sampling rate */                  end;                  call ps(token);             /* we have some characters to display */               end;               else do case(prev.des);                  call PRINT.TNAME(prev.dtd.song#);                  call PRINT.START.TIME(prev.dtd.song#);                  call PRINT.END.TIME(prev.dtd.song#);                  call PRINT.SONG.RATE(prev.dtd.song#);               end;               prev.dtd.song#=dtd.song#;               prev.des=curr.des;            end;                                /* of if current value or have changed positions */         end;                                   /* of first previous then current */         if vt100=0 then do;                    /* if an ADM terminal put cursor at beginning of field */            if token(0)=0            then do case(prev.des);               call cpos(song.yloc+prev.dtd.song#,title.xloc);      /* title       */               call cpos(song.yloc+prev.dtd.song#,start.xloc);      /* start time  */               call cpos(song.yloc+prev.dtd.song#,end.xloc);        /* ending time */               call cpos(song.yloc+prev.dtd.song#,rate.xloc);       /* sampling rate */            end;         end;         else call reverse.video(0);            /* otherwise turn off reverse video */      end;   end POS.SONG.DIRECTORY.CURSOR;   /* $Subtitle Direct-to-Disk Song Directory Snap Shot Routine */   SONG.DIRECTORY.SNAP.SHOT:  proc swapable;      /* copy song directory info from LOD to snapshot area */      write(mam)=trd.ptr;      call copy.in (addr(misc.buf(0)),256);      write(mam)=trd.ptr+1;      call copy.out(addr(misc.buf(0)),256);      call SET.SUM.MAX.TLEN;                 /* set the maximum token value */   end SONG.DIRECTORY.SNAP.SHOT;    /* $Subtitle Update Direct-to-Disk Song Directory Screen */   UPDATE.SONG.DIRECTORY:  proc fixed swapable;      dcl change          fixed;      dcl overall.change  fixed;      dcl (i,j,k)         fixed;      dcl x               fixed;      if inc.dtd=0 then return;   /* if no direct to disk, do not update sreen */      /* reset global flags */      change=0; overall.change=0;       /* assume no changes will take place */      call SONG.DIRECTORY.SNAP.SHOT;    /* take a snap shot of the song directory snap shot */      if (song.command<>0) and (dtd.prompt<>1) then do;  /* if a song command prompt and another error occurred  */         song.command=0;                                       /* pop out of it */         dtd.prompt  =0;         token(0)=0;         overall.change=1;      end;      if (prev.max.secs<>dtd.max.secs) then do;         call PRINT.TOT.TIME.AVAIL;         prev.max.secs=dtd.max.secs;         overall.change=1;      end;      if (prev.max.tracks<>dtd.avail.trks) then do;         call PRINT.MAX.TRACKS.AVAIL;         prev.max.tracks=dtd.avail.trks;         overall.change=1;      end;      /* compare snap shot to display area */      do i=0 to num.songs-1;            /* loop over 16 blocks in sector each 16 words */         /* compare task words to see if status has changed*/         x=0;         j=i*song.blen+song.task.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if (x<>read(md)) then do;            change=1;            call PRINT.SONG.TASK(i);         end;         /* compare item numbers */         x=0;         j=i*song.blen;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if (x<>read(md)) then do;            change=1;            call PRINT.NUMBER(i);         end;         /* compare titles */         x=0;                           /* assume both names are the same */         j=i*song.blen+title.off;       /* compute pointer */         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255; /* look at snap shot */         do k=0 to title.length-1;                misc.buf(k)=read(mdi);         end;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         do k=0 to title.length-1;            if read(md)=-1               /* if initially (-1) then treat as spaces so nothing printed */            then write(md)=shl(sp,8)\sp;            if misc.buf(k)<>read(mdi)    /* compare snap shot to display area */            then x=1;         end;         if x<>0 then do;                /* names differ - title name update necessary */            change=1;            call PRINT.TNAME(i);         /* print title of piece */         end;         /* $page */         /* check if start and end times are different */         j=i*song.blen+start.time.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;            change=1;            call PRINT.START.TIME(i);              call PRINT.TIME.AVAIL(i);  /* update time available on screen*/         end;         j=i*song.blen+end.time.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.END.TIME(i);              call PRINT.TIME.AVAIL(i);  /* update time available on screen*/         end;         /* check selection status */         j=i*song.blen+song.stat.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         if (x&1)=0 then do;            /* if empty */            k=i*song.blen+used.off;     /* set used and modified in snapshot to -1 */            write(mam)=trd.ptr+1+shr(k,8); write(mal)=k&255;            write(md)=(-1);            k=i*song.blen+modify.off;     /* set used and modified in snapshot to -1 */            write(mam)=trd.ptr+1+shr(k,8); write(mal)=k&255;            write(md)=(-1);         end;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.SONG.STAT(i);           end;         /* check song sampling rates */         j=i*song.blen+rate.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.SONG.RATE(i);              call PRINT.TIME.AVAIL(i);  /* update time available on screen*/            call PRINT.TIME.USED(i);   /* update time used */         end;         /* check time used*/         j=i*song.blen+used.off;        /* then compare used field */         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.TIME.USED(i);           end;         /* $page */         j=i*song.blen+modify.off;         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255;         x=read(md);         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.MOD(i);           end;         if change<>0 then do;            j=i*song.blen;            write(mam)=trd.ptr+1+shr(j,8);            write(mal)=j&255;            call copy.in (addr(misc.buf(0)),song.blen);            write(mam)=trd.ptr+2+shr(j,8);            write(mal)=j&255;            call copy.out(addr(misc.buf(0)),song.blen);            change=0; overall.change=1;      /* acknowledge that we updated for song and must make an overall change */         end;         if (num.of.d50.in.chars<>0)         /* if something else happened */         then do;            if overall.change<>0            then call POS.SONG.DIRECTORY.CURSOR;            /* Force re-entry after processing input character: */            new.ABLE.dtd.info = new.ABLE.dtd.info \ 1;            return;         end;      end;      if overall.change<>0      then call POS.SONG.DIRECTORY.CURSOR;      return overall.change;   end UPDATE.SONG.DIRECTORY;   /* $Subtitle Direct-to-Disk Song Directory Screen Display Routine */   DISP.SONG.DIRECTORY:  proc swapable;      dcl i fixed;      if inc.dtd=0 then return;  /* do not draw display if no direct-to-disk*/      call clear.term;      call DRAW.BOX(0,0,17,79);  /* enclose the screen display */      call PRINT.CCAT;           /* show current cat name */      call cpos(0,30);      call DRAW.TEE(t.right);    /* draw a right T */      call ps('PROJECT DIRECTORY');      call DRAW.TEE(t.left);     /* draw a left T */      call cpos(1,2);      call ps('Press <ENTER> to return to Main Menu.  Use arrow keys to move cursor.');      call cpos(2,2);      call ps('Enter values or toggle with space bar.  Press <CTRL> and letter for command.');      call cpos(3,1);      call DRAW.HOR(78);      call cpos(3,0);      call DRAW.TEE(t.left);      call cpos(3,79);      call DRAW.TEE(t.right);    /* draw a right T */      call cpos(17,23);      call ps(' Click here to see most recent message ');      call cpos(17,0);      call DRAW.TEE(t.left);      call cpos(17,79);      call DRAW.TEE(t.right);		call DRAW.VER(18, 0,22);		call DRAW.VER(18,79,22);				VECTOR_MODE;               /* vector                    */		call DATA_LEVEL(0);		call connect(gpos.x (75), gpos.y(2200), gpos.x( 7925), gpos.y( 2200));		TRANSPARENT_MODE;      		call SONG.DIRECTORY.COMMAND.SELECTION;      if D44_PRESENT      then call plot.mouse.hole(mouse.hole.lowerx,mouse.hole.lowery); /* if device available plot the mouse hole */      call cpos(4,12);      call ps('Total Recording Time (50 kHz):');      call cpos(4,52);      call ps('Tracks Available:');      call cpos(6,title.xloc+6);      call ps('Project Title');      call cpos(6,start.xloc+1);      call ps('Start');      call cpos(6,end.xloc+3);      call ps('End');      call cpos(6,rate.xloc+1);      call ps('Rate');      call cpos(6,avail.xloc+1);      call ps('Avail');      call cpos(6,used.xloc+2);      call ps('Used');      call cpos(6,song.stat.xloc);      call ps('Status');      call cpos(6,modify.xloc);      call ps('Mod');      call EXTSET(trd.ptr,0,768,-1);    /* clear out info from LOD, snap shot and display area in external memory */      store.dtd.info   =1;              /* indicate to LOD that we have song directory info */      prev.max.secs   =-1;              /* initialize previous maximum time available in seconds */      prev.max.tracks =-1;              /* initialize previous maximum tracks available */      song.command=0;      dtd.prompt  =0;      song.command.type=(-1);		if ((simulate.dtd == 0) && (lod.running == 0))		then call no.direct.to.disk;      else do;         if (!simulate.dtd) send.to.lod(dtd.select.song,0);  /* otherwise tell LOD to select a song */      end;      if  ((new.dtd.info     &1)=0)   /* position cursor here unless update is pending */      and ((new.ABLE.dtd.info&1)=0)      then call POS.SONG.DIRECTORY.CURSOR;   end DISP.SONG.DIRECTORY;   /* $page */   SONG.DIRECTORY.ATTRIBUTE.DEPOSIT: proc swapable; /* parses parameter and updates */      dcl val         fixed;      dcl (i,j)       fixed;      dcl ch          fixed;      dcl title (12)  fixed;		if ((simulate.dtd == 0) && (lod.running == 0)) then do;         call no.direct.to.disk;         return;      end;      else if token(0)<>0 then do;     /* otherwise it is running */         do case (curr.des);            do;                        /* 0: update title */               tok.ptr=0;              /* get title token value and space fill */               title(0)=0;               do while (tok.ptr<token(0));                  call pbyte(title,title(0),byte(token,tok.ptr));                  title(0)=title(0)+1;                  tok.ptr=tok.ptr+1;               end;               do while title(0)<shl(title.length,1);  /* space fill the rest of the title selection */                  call pbyte(title,title(0),sp);                  title(0)=title(0)+1;               end;               write(mam)=scsi.ptr;   /* update title */               do i=1 to title.length;                  write(mdi)=title(i);               end;               if (!simulate.dtd) send.to.lod(dtd.song.name,shl(title.length,1));               /* Set up global information right away - even through we will */               /* probably see an event shortly that will re-compute          */               /* everything again after all the error checking is complete.  */               call SET.UP.AEE.DTD.GLOBALS;            end;            do;                       /* 1: update start time */              call CONV.MIN.SEC.STR.TO.SEC.MSEC  (token, title);              if ertyp = 0 then do;          /* if a valid time */                 write(mam)=scsi.ptr;                 write(md) =title(0);        /* time is in seconds (2 bytes)*/                 if (!simulate.dtd) send.to.lod(dtd.song.start.time,2);                 /* Set up global information right away - even through we will */                 /* probably see an event shortly that will re-compute          */                 /* everything again after all the error checking is complete.  */                 call SET.UP.AEE.DTD.GLOBALS;              end;            end;            do;                      /* 2: update end time */              call CONV.MIN.SEC.STR.TO.SEC.MSEC  (token, title);              if ertyp = 0 then do;          /* if a valid time */                 write(mam)=scsi.ptr;                 write(md) =title(0);        /* time is in seconds (2 bytes)*/                 if (!simulate.dtd) send.to.lod(dtd.song.end.time,2);                 /* Set up global information right away - even through we will */                 /* probably see an event shortly that will re-compute          */                 /* everything again after all the error checking is complete.  */                 call SET.UP.AEE.DTD.GLOBALS;              end;            end;            do;                     /* 3: sampling rate */               i=CONV.STR.TO.FIXED(token,1,0);     /* get sampling rate in kHz*10 */               if ertyp=0 then do;        /* if so far so good */                  if (i<0) or (i>1000)                  then call range.error;  /* if sampling rate less than .1 */                  else do;                     write(mam)=scsi.ptr;                     write(md) =i;                     if (!simulate.dtd) send.to.lod(dtd.song.rate,2);                    /* Set up global information right away - even through we will */                    /* probably see an event shortly that will re-compute          */                    /* everything again after all the error checking is complete.  */                    call SET.UP.AEE.DTD.GLOBALS;                  end;               end;            end;                         /* of update sample rate */         end;      end;      token(0)=0;      call POS.SONG.DIRECTORY.CURSOR;               /* position cursor */   end SONG.DIRECTORY.ATTRIBUTE.DEPOSIT;   TEST.SONG.PASSWORD:  proc fixed swapable;  /* checks if user typed in the correct password */      dcl i fixed;      if (song.command.type=2) or (song.command.type=5) then do;  /* erase proj/erase all */         if (token(0)=5) or (token(0)=7) then do;     /* if five characters for ERASE or seven for ERASE 1, ERASE 2, ERASE 4 */            i=byte(token,0);                 /* see if user typed ERASE*/            if (i=asc.e) or (i=lower.e) then do;               i=byte(token,1);               if (i=asc.r) or (i=lower.r) then do;                  i=byte(token,2);                  if (i=asc.a) or (i=lower.a) then do;                     i=byte(token,3);                     if (i=asc.s) or (i=lower.s) then do;                        i=byte(token,4);                        if (i=asc.e) or (i=lower.e) then do;                          if token(0)=5                           then return 1;   /* typed ERASE */                          if song.command.type<>5                          then return 0;                          else do;                             if  ( byte(token,5) = sp      )                             and ( byte(token,6) = asc.1   )                             then do;                                song.command.type=15; /* send erase long command */                                return 1;             /* typed ERASE 1 */                             end;                             if  ( byte(token,5) = sp      )                             and ( byte(token,6) = asc.2   )                             then do;                                song.command.type=17; /* send erase 2trk command */                                return 1;             /* typed ERASE 2 */                             end;                             if  ( byte(token,5) = sp      )                             and ( byte(token,6) = asc.4   )                             then do;                                song.command.type=16; /* send erase 4trk command */                                return 1;             /* typed ERASE 4 */                             end;                          end;                        end;                     end;                  end;               end;            end;         end;      end;      else if (song.command.type=1) or (song.command.type=4) then do;  /* load/add to proj or all */         /* Check for LOAD */         if token(0)=4 then do;              /* if four characters for LOAD */            i=byte(token,0);                 /* see if user typed LOAD */            if (i=asc.l) or (i=lower.l) then do;               i=byte(token,1);               if (i=asc.o) or (i=lower.o) then do;                  i=byte(token,2);                  if (i=asc.a) or (i=lower.a) then do;                     i=byte(token,3);                     if (i=asc.d) or (i=lower.d)                     then return 1;                  end;               end;            end;         end;         if token(0)=3 then do;              /* if four characters for ADD */            i=byte(token,0);                 /* see if user typed ADD      */            if (i=asc.a) or (i=lower.a) then do;               i=byte(token,1);               if (i=asc.d) or (i=lower.d) then do;                  i=byte(token,2);                  if (i=asc.d) or (i=lower.d) then do;                     if song.command.type = 1     /* convert load proj */                     then song.command.type = 18; /* to      add  proj */                     else song.command.type = 19; /* to      add  all  */                     return 1;                  end;               end;            end;         end;      end;      else if (song.command.type=27) then do;  					/* format */         if (token(0)=6) then do;            i=byte(token,0);                 					/* see if user typed FORMAT */            if (i=asc.f) or (i=lower.f) then do;               i=byte(token,1);               if (i=asc.o) or (i=lower.o) then do;                  i=byte(token,2);                  if (i=asc.r) or (i=lower.r) then do;                     i=byte(token,3);                     if (i=asc.m) or (i=lower.m) then do;                        i=byte(token,4);                        if (i=asc.a) or (i=lower.a) then do;                       		i=byte(token,5);	                        if (i=asc.t) or (i=lower.t) then do;										return 1;									end;								end;							end;						end;					end;				end;			end;		end;      else if (token(0)<>0) then do;         i=byte(token,0);                  /* see if user typed OK */         if (i=asc.o) or (i=lower.o) then do;            if token(0)=2 then do;               i=byte(token,1);               if (i=asc.k) or (i=lower.k)               then return 1;            end;         end;      end;      		return 0;   end TEST.SONG.PASSWORD;   /* $Subtitle Multi-Track Summary Directory Character Handler */   SONG.DIRECTORY.INPUT:  proc(in.cmd,in.arg) swapable;    /* Multi-Track Summary Directory input handler */      dcl (in.cmd,in.arg)  fixed;   /* input command and argument */      dcl i                fixed;      dcl rec(CUE.HIST.REC.LEN-1) fixed;      dcl dtd.song.command data (0,   1,  4,  2,                                 3,   5, 19, 20,                                 22, 13, 12, 10,                                 21,  9,  0, 24,                                 41, 44, 52, 53,                                 54, 55, 56, 61,                                 62, 65, 64, 63,											66);      if inc.dtd=0 then return;         /* if no direct to disk, blow out of here */      if err.displayed<>0 then do;      /* if an error displayed other than (-1) a song command prompt */         if (song.command<>0) then do;  /* if there was a song command prompt there */            song.command=0;            token(0)=0;            dtd.prompt=0;         end;         call REMOVE.ERR;               /* remove any error */         call PRINT.CCAT;               /* show current cat name */         call POS.SONG.DIRECTORY.CURSOR;      end;      do case (in.cmd);             /* do depending upon input command */         do;                        /* 0: character input */            if in.arg=ESC then do;               song.command=0;               dtd.prompt  =0;               EXIT.MY.SCREEN=1;               return;            end;            else if (in.arg=tab) then do;               song.command=0;               dtd.prompt  =0;               EXIT.MY.SCREEN=1;               GOTO.THIS.SCREEN=s.track.display;               return;            end;            else if in.arg="20" then do;             /* CTRL-P: print hardcopy of screen */               if D40_PRESENT<>0                     /* if device available */               then call SCREEN_DUMP;                /* screen dump */                  else call no.printer;               return;            end;				if ((simulate.dtd == 0) && (lod.running == 0)) then do;               call no.direct.to.disk;               return;            end;            if (((in.arg>="1") and (in.arg<="6")) or      /* if CTRL-A -> CTRL-F */            (in.arg="17") or (in.arg="22") or             /* CTRL-O or CTRL-R */            ((in.arg>="24") and (in.arg<="32"))) then do; /* or CTRL-T -> CTRL-Z */               song.command=1;               if ((in.arg>="1") and (in.arg<="6"))       /* if CTRL-A -> CTRL-F */               then song.command.type=in.arg-1;               else if (in.arg="17") or (in.arg="22") then do;                          /* CTRL-O or CTRL-R */                  if in.arg="17"                  then song.command.type=6;                  else song.command.type=7;               end;               else song.command.type=(in.arg-"24")+8;               call ERASE.REST.OF.LINE(23,0);                       /* erase bottom line */               call DISPLAY.SONG.PROMPT;               token(0)=0;               call POS.SONG.DIRECTORY.CURSOR;            end;            /* $page */            else if (in.arg=cret) then do;             /* CR: if carriage return */               if song.command=0 then do;              /* if not responding to a song command */                  call SONG.DIRECTORY.ATTRIBUTE.DEPOSIT; /* enter new value */                  call POS.SONG.DIRECTORY.CURSOR;        /* position menu cursor */               end;               else do;                               /* if song command selected */                  call ERASE.REST.OF.LINE(23,0);                  if TEST.SONG.PASSWORD<>0 then do;   /* if the user typed in the right password */                     if song.command.type = 14 then do;                        call get.new.project;                     end;                     else do;                        write(mam)=scsi.ptr;                        write(md)=dtd.song.command(song.command.type);                        if (!simulate.dtd) send.to.lod(dtd.send.command,2);   /* send command to live overdub */                     end;                  end;                  else if (token(0)<>0) then call password.error; /* do not give error message on plain old carriage return */                  token(0)=0;                  song.command=0;                  dtd.prompt  =0;                  call POS.SONG.DIRECTORY.CURSOR;               end;                                   /*of if selected a song command */            end;                                       /* of if carriage return */            else if ((in.arg>=sp) and (in.arg<=asc.tilde)) then do; /* if a typed character */               if ((in.arg=asc.plus) or (in.arg=asc.min)) and (token(0)=0) and (song.command=0) then do;                  if in.arg=asc.plus                      /* add a song item*/                  then {if (!simulate.dtd) send.to.lod(dtd.add.song,   0);}                  else {if (!simulate.dtd) send.to.lod(dtd.insert.song,0);} /* insert a song item */               end;               else if (token(0) ILT sum.max.tlen)					or      ((song.command<>0) and (token(0)<5))               or      ((song.command<>0) and (song.command.type=5 ) and (token(0)<10))               or      ((song.command<>0) and (song.command.type=27) and (token(0)<6))					then do;     /* if token length within limits or responding to a command prompt */                  if ((song.command<>0) and (token(0)<5))                  or ((song.command<>0) and (song.command.type=5)  and (token(0)<10))               	or ((song.command<>0) and (song.command.type=27) and (token(0)<6))						then do;                     if (token(0)<2)							or (((song.command.type=1) or (song.command.type=4)) and (token(0)<4))    /* if typing load */                     or ((song.command.type=2) and (token(0)<5))                     or ((song.command.type=5) and (token(0)<10))                     or ((song.command.type=27) and (token(0)<6))							then do;    /* if typing erase */                        call pbyte(token,token(0),in.arg);                        token(0)=token(0)+1;                     end;                  end;                  else if (song.command=0) and (token(0) ILT sum.max.tlen) then do;                     call pbyte(token,token(0),in.arg);                     token(0)=token(0)+1;                  end;               end;               call POS.SONG.DIRECTORY.CURSOR;              /* reposition cursor */            end;                              /* of if a typed character */            else if (in.arg=del) then do;               if token(0)<>0 then do;                          /* chars to delete */                  token(0)=token(0)-1;                  call POS.SONG.DIRECTORY.CURSOR;                  call pc(sp); call pc(bs);               end;               else if song.command<>0 then do;                  song.command=0;                  dtd.prompt  =0;                  call ERASE.REST.OF.LINE(23,0);                /* erase bottom line */                  call POS.SONG.DIRECTORY.CURSOR;               end;               else if curr.des=0                        /* if in the title field */               then do;                  call Build.Proj.Hist.Rec(dtd.song#,1,rec);   /* mark the project deleted in cue history */                  call Add.Cue.To.Hist(rec);                  if (!simulate.dtd) send.to.lod(dtd.delete.song,0);   /* delete a song item */               end;            end;            /* $page */            else if (in.arg=u.arr) or (in.arg=d.arr) or (in.arg=l.arr) or (in.arg=r.arr) or (in.arg=home) then do; /* if up, down, or home arrow keys */               if song.command=0 then do;                  call SONG.DIRECTORY.ATTRIBUTE.DEPOSIT;     			/* enter value */                  if (in.arg=u.arr) or (in.arg=d.arr) then do;       /* if up or down arrow */                     call STOP.RECD.MOVE.PLAY;                     call DISPLAY.SEQUENCER.STATUS;                     if in.arg=u.arr                     then {if (!simulate.dtd) send.to.lod(dtd.up,  0);}                     else {if (!simulate.dtd) send.to.lod(dtd.down,0);}                     /* Set up global information right away - even through we will */                     /* probably see an event shortly that will re-compute          */                     /* everything again after all the error checking is complete.  */                     call SET.UP.AEE.DTD.GLOBALS;                  end;                  else if (in.arg=l.arr) or (in.arg=r.arr) then do;                     prev.des=curr.des;         /* save previous selection description */                     if in.arg=r.arr then do;                        if curr.des<max.des                        then curr.des=curr.des+1;                     end;                     else do;                        if curr.des>min.des                        then curr.des=curr.des-1;                     end;                  end;                  else do;                     if (!simulate.dtd) send.to.lod(dtd.home,0);   /* home */                     /* Set up global information right away - even through we will */                     /* probably see an event shortly that will re-compute          */                     /* everything again after all the error checking is complete.  */                     call SET.UP.AEE.DTD.GLOBALS;                  end;                  call SET.SUM.MAX.TLEN;         /* set the maximum token value */                  call POS.SONG.DIRECTORY.CURSOR;                end;            end;         end;                                 /* of character input */         do;                                  /* 1: mouse absolute select */ 				if ((simulate.dtd == 0) && (lod.running == 0)) then do;               call no.direct.to.disk;               return;            end;				if ((song.command == 0) && (token(0) != 0)) then do;					call SONG.DIRECTORY.ATTRIBUTE.DEPOSIT; /* enter new value */					call POS.SONG.DIRECTORY.CURSOR;        /* position menu cursor */				end;            				if (token(0) != 0)				{					call ERASE.REST.OF.LINE(23,0);    		/* erase bottom line 					*/					token(0) = 0;				}								if #ypos>=0 then do;              /* if a command was chosen */               token(0)=0;										if (#ypos == 25 || #ypos == 26)				/* for spin & sleep, don't prompt	*/					{														/* for password; just send				*/						write(mam)=scsi.ptr;							/* command to DTD							*/						write(md )=dtd.song.command(#ypos);						if (!simulate.dtd) send.to.lod(dtd.send.command,2);                  song.command=0;                  dtd.prompt  =0;						call ERASE.REST.OF.LINE(23,0);    		/* erase bottom line 					*/					}										else													/* else prompt for password for		*/					{														/* other commands							*/						song.command=1;						song.command.type=#ypos;						call ERASE.REST.OF.LINE(23,0);    		/* erase bottom line 					*/						call DISPLAY.SONG.PROMPT;					}            end;            else do;					song.command=0;								/* clean up pending command on click	*/					dtd.prompt  =0;								/* of data field								*/					call ERASE.REST.OF.LINE(23,0);    		/* erase bottom line 						*/              				   prev.des=curr.des;               curr.des=shr(in.arg,8);   /* set the field for cursor positioning*/               write(mam)=scsi.ptr;               write(md)=in.arg&255;               if (!simulate.dtd) send.to.lod(dtd.set.screen.line,2);  /* set the track number (0-15) */               /* Set up global information right away - even through we will */               /* probably see an event shortly that will re-compute          */               /* everything again after all the error checking is complete.  */					call SET.SUM.MAX.TLEN;         /* set the maximum token value */					call POS.SONG.DIRECTORY.CURSOR;               call SET.UP.AEE.DTD.GLOBALS;            end;            call POS.SONG.DIRECTORY.CURSOR;         end;         ;                                    /* 2: scroll down */         ;                                    /* 3: scroll up */         EXIT.MY.SCREEN=1;                    /* 4: return to previous screen */      end;                                    /* of do depending upon input command */   end SONG.DIRECTORY.INPUT;   /* $Subtitle Direct-To-Disk Song Directory Mouse Mapping 539-Live */   SONG.DIRECTORY.MOUSE.POS:  proc(x,y) swapable;      dcl (x,y)   fixed;      if inc.dtd=0 then return;      if mouse.hole(x,y) then do;         call song.directory.input(in.rtps,0);         return;      end;      if err.displayed<>0 then do;         call REMOVE.ERR;                /* remove any error */         call PRINT.CCAT;                /* show current cat name */         call POS.SONG.DIRECTORY.CURSOR; /* reposition the cursor */      end;		if ((simulate.dtd == 0) && (lod.running == 0)) then do;         call no.direct.to.disk;         return;      end;      /* convert the mouse pixel coordinates to screen coordinates */      x=CONVERT.MOUSE.X(x);     /* 0-79 */      y=CONVERT.MOUSE.Y(y);     /* 0-23 */      if (y>=7) and (y<17) then do;     /* perhaps a song parameter */         if ((x>=6) and (x<=30)) or ((x>=31) and (x<=37))         or ((x>=38) and (x<=44)) or ((x>=45) and (x<=50)) then do;            #ypos=(-1);                  /* indicate that this is not a command */            y=y-7;                       /* map to a song item*/            if (x>=6) and (x<=30)        /* if song title */            then x=0;            else if (x>=31) and (x<=37)  /* if song start time */            then x=1;            else if (x>=38) and (x<=44)  /* if song end time */            then x=2;            else if (x>=45) and (x<=50)  /* if song sample rate */            then x=3;            call SONG.DIRECTORY.INPUT(in.abss,shl(x,8)\y);         end;      end;      else if y = 17 then do;            /* redisplay most recent LOD message */         call set.error(err.lod,lod.message);      end;      else if (y>=18) and (y<=22) then do;         #ypos = (-1);         if (x>=column1) and (x<column2-1) then do;         /* backup, load, or erase song */            if      y=18 then #ypos=0;            else if y=19 then #ypos=1;            else if y=20 then #ypos=2;            else if y=21 then #ypos=20;            else              #ypos=25;         end;         else if (x>=column2) and (x<column3-1) then do;    /* if backup, load, or erase all */            if      y=18 then #ypos=3;            else if y=19 then #ypos=4;            else if y=20 then #ypos=5;            else if y=21 then #ypos=21;            else              #ypos=26;         end;         else if (x>=column3) and (x<column4-1) then do;    /* home, skip, skip all */            if      y=18 then #ypos=6;            else if y=19 then #ypos=7;            else if y=20 then #ypos=8;            else if y=21 then #ypos=22;            else              #ypos=27;         end;         else if (x>=column4) and (x<column5-1) then do;    /* unlock, lock, lock all and dismount */            if      y=18 then #ypos=9;            else if y=19 then #ypos=10;            else if y=20 then #ypos=11;            else if y=21 then #ypos=23;            else              #ypos=28;         end;         else if (x>=column5) and (x<column6-1) then do;   /* eject, abort, new and mount */            if      y=18 then #ypos=12;            else if y=19 then #ypos=13;            else if y=20 then #ypos=14;            else if y=21 then #ypos=24;         end;         if #ypos>=0 then call SONG.DIRECTORY.INPUT(in.abss,shl(x,8)\y);      end;   end SONG.DIRECTORY.MOUSE.POS;