   /* DTDSOUC - Update Direct-to-Disk Track display */   /* Modified:      09/13/91 - cj  - Created event bit on DTD track name change      08/14/91 - cj  - Added UDIO/DDSYN stuff      06/25/91 - cj  - Added calls to check.next.event to speed up GPI      02/01/89 - cj  - multitrack DDT code      06/15/88 - cj  - finished up bounce, digital transfer items      05/31/88 - TSS - Split up Define.And.Draw.DTD.Items to make swap area smaller   */   UPDATE.MULTI.TRACK.REC.DISPLAY:  proc fixed swapable;  /* updates Direct-to-Disk Track Display */      dcl change           fixed;      dcl overall.change   fixed;      dcl (i,j,k)          fixed;      dcl (x,y)            fixed;      if inc.dtd=0 then return 0;      /* reset global flags */      if safe.ready.toggles <> 0 then do;   /* toggle safe/ready from button panel */			if ((simulate.dtd != 0) || (lod.running != 0)) then do;            do i=0 to 15;               if (safe.ready.toggles & bits(i)) <>0 then do;                  write(mam)=scsi.ptr;                  write(md )=i;                  if (!simulate.dtd) send.to.lod(dtd.set.screen.line,2);  /* set the track number (0-15) */                  if (!simulate.dtd) send.to.lod(dtd.trk.status     ,0);  /* toggle mode                 */               end;            end;            call Update.AEE.Track.Status.Displays.And.Tallies (0, Safe.Ready.Toggles);         end;         safe.ready.toggles = 0;      end;      call MULTI.TRACK.REC.SNAP.SHOT;      /* check track button display  */      change=0; overall.change=0;           /* assume no changes will take place */      if (next.event.info&2)<>0 then do;    /* new track button listing   */         do i= 0 to num.tracks-1;            call PRINT.TRACK.BUTTON(i);            overall.change=1;            if (num.of.d50.in.chars<>0)     /* if something else happened */            then do;               /* Force a re-entry here to re-update screen */               new.ABLE.dtd.info=new.ABLE.dtd.info\6;               return;            end;         end;      end;      /* compute new lod.recd.tracks */      lod.recd.tracks=0;                /* init to off        */		if ((simulate.dtd != 0) || (lod.running != 0))      then do i=0 to num.tracks-1;         j=song.blen+i*mtrk.blen+tstat.off;         write(mam)=trd.ptr+2+shr(j,8);         write(mal)=j&255;         k=read(md)&255;                /* look at safe/ready */         if (k&1)<>0 then do;            lod.recd.tracks=lod.recd.tracks \ bits(i);         end;      end;      if lod.recd.tracks<>0 then do;   /* some lod recording tracks  */         if (recd)&(recd.trk<>0)       /* stop synclavier recording  */         then do;                      /* since we are now ready     */            call stop.record;          /* for live overdub recording */         end;      end;      else do;                         /* else still ready for syncl */         if (recd)&(recd.trk=0)        /* stop synclavier recording  */         then do;                      /* since we are now ready     */            call stop.record;          /* for live overdub recording */         end;      end;      recd.trk=0;                      /* ready for lod recording    */      call compute.active.trks;      call display.track.buttons;      call display.sequencer.status;      new.motion=1;      /* $page */      if new.pan<>0 then do;         if  (lod.recd.tracks<>0)         and (previous.lod.recd.tracks=0)         then do;            call clear.display;            call emit.string(0,'*  READY FOR   **LIVE RECORDING*');            upper.disp=lod.disp;            supress.beat.display=1;            beat.display.time=real.milliseconds;            both.display=1;         end;         else if (previous.lod.recd.tracks<>0)         and     (lod.recd.tracks=0)         and     (upper.disp=lod.disp)         then call clear.display;      end;      previous.lod.recd.tracks=lod.recd.tracks;               do i=0 to song.blen-1;         x=0;         write(mam)=trd.ptr+2;          /* look at snap shot */         write(mal)=i;         x=read(md);         write(mam)=trd.ptr+4;          /* look at display */         write(mal)=i;         if ((x<>read(md)) and (change=0)) then do;            change=1;            call PRINT.SONG.TITLE;            call PRINT.SONG.START;            call PRINT.SONG.END;            call PRINT.SONG.CROSSFADE;            call PRINT.SONG.STATUS;            call PRINT.SONG.SRATE;            call PRINT.SONG.AVAIL;            call PRINT.SONG.USED;            write(mam)=trd.ptr+2;            call copy.in (addr(misc.buf(0)),song.blen);            write(mam)=trd.ptr+4;            call copy.out(addr(misc.buf(0)),song.blen);         end;      end;      /* compare snap shot to display area */      do i=0 to num.tracks-1;            /* loop over 16 tracks */         /* compare task words to see if status has changed */          j=song.blen+i*mtrk.blen+ttask.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255;         x=read(md)&3;         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if (x<>(read(md)&3)) then do;            change=1;            call PRINT.TRACK.TASK(i);         end;         /* compare titles */         x=0;                           /* assume both names are the same */         j=song.blen+i*mtrk.blen;                 /* compute pointer */         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         do k=0 to trk.title.length-1;                misc.buf(k)=read(mdi);         end;         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         do k=0 to trk.title.length-1;            if read(md)=(-1)             /* set to spaces so no extra printing of spaces */            then write(md)=shl(sp,8)\sp;            if misc.buf(k)<>read(mdi)    /* compare snap shot to display area */            then x=1;         end;         if x<>0 then do;                /* names differ - title name update necessary */            change=1;            call PRINT.TRACK.NAME(i);    /* print title of timbre */         end;         /* $page */         /* check if modes are different */         j=song.blen+i*mtrk.blen+tstat.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;            change=1;            call PRINT.TRACK.STATUS(i);   /* safe or ready  */            call PRINT.TRACK.MODE(i);     /* repro, input, or auto */         end;         /* check time used */         j=song.blen+i*mtrk.blen+tused.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;             change=1;            call PRINT.TRACK.TIME.USED(i);           end;         /* check if input source, channel, or gain is different */         j = song.blen+i*mtrk.blen+tinchan.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x = read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         x = x - read(md);         j = song.blen+i*mtrk.blen+tgain.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         y = read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         y = y - read(md);         if (x<>0) or (y<>0)         then do;            change=1;            call PRINT.TRACK.SOURCE.CHANNEL.AND.GAIN(i,0);           end;         /* check track volume */         j=song.blen+i*mtrk.blen+tvol.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;            change=1;            call PRINT.TRACK.VOL(i);           end;         /* check track pan */         j=song.blen+i*mtrk.blen+tpan.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;            change=1;            call PRINT.TRACK.PAN(i);           end;         /* check track DDT and DOA routing */         j=song.blen+i*mtrk.blen+trout.off;         write(mam)=trd.ptr+2+shr(j,8); write(mal)=j&255; /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         if x<>read(md) then do;            change=1;            call PRINT.TRACK.DOA(i);            call PRINT.TRACK.DIG(i);         end;         /* $page */         /* COPY SNAPSHOT TO DISPLAY AREA */         if change<>0 then do;            j=song.blen+i*mtrk.blen;            write(mam)=trd.ptr+2+shr(j,8);            write(mal)=j&255;            call copy.in (addr(misc.buf(0)),mtrk.blen);            write(mam)=trd.ptr+4+shr(j,8);            write(mal)=j&255;            call copy.out(addr(misc.buf(0)),mtrk.blen);            change=0; overall.change=1;      /* acknowledge that we updated for song and must make an overall change */         end;         if (num.of.d50.in.chars<>0)         /* if something else happened */         then do;            new.ABLE.dtd.info=new.ABLE.dtd.info\4;     /* re-enter for screen update */            return;         end;         call Check.Next.Event;         do while Num.Of.D50.Out.Chars <> 0;            call Check.Next.Event;         end;      end;      return (overall.change);   end UPDATE.MULTI.TRACK.REC.DISPLAY;   /* $Subtitle Direct-to-Disk Track Display Routine */   /* small triangular icon for mark start take button */   LOAD.SMALL.TAKE.ICON: proc (Icon) swapable;      dcl Icon array;      write("313") = addr(icon(0));      mr13i    = O#Icon.MoveTo;          mr13i    =   0;          mr13i    =  40;      mr13i    = O#Icon.Plot;          mr13i    = 100;          mr13i    =  40;      mr13i    = O#Icon.Plot;          mr13i    =  50;          mr13i    =   0;      mr13i    = O#Icon.Plot;          mr13i    =   0;          mr13i    =  40;      mr13i    = O#Icon.MoveTo;          mr13i    =  50;          mr13i    =  20;      mr13i    = O#Icon.PolyFill;          mr13i    = "137";      mr13i    = O#Icon.End;   end LOAD.SMALL.TAKE.ICON;   dcl Dtd.Top   lit '-134';   dcl Dtd.Bot   lit '- 34';   Define.DTD.Items.Part1: proc swapable;      dcl s1(20) fixed;        dcl s2(20) fixed;      /* draw graphics boxes around text areas */      if GTYPE <> 0 then do;     /* graphics terminal     */         vector_mode;         /* outer box, double wide */         call GBOX   (gpos.x( -50),   gpos.y(0)+3,                      gpos.x(8050),   gpos.y((trk.yloc+num.tracks-1)*100)+4, 0);         call GBOX   (gpos.x( -50)-1, gpos.y(0)+4,                      gpos.x(8050)+1, gpos.y((trk.yloc+num.tracks-1)*100)+3, 0);         /* double horizontal line below project info */         call CONNECT(gpos.x( -50), gpos.y(200)+4,                      gpos.x(8050), gpos.y(200)+4);         call CONNECT(gpos.x( -50), gpos.y(200)+3,                      gpos.x(8050), gpos.y(200)+3);         /* triple verticle line between tracks and outputs */         call CONNECT(gpos.x(out.xloc*100-50)-1, gpos.y(200)+4,                      gpos.x(out.xloc*100-50)-1, gpos.y((trk.yloc+num.tracks-1)*100)+4);         call CONNECT(gpos.x(out.xloc*100-50)  , gpos.y(200)+4,                      gpos.x(out.xloc*100-50)  , gpos.y((trk.yloc+num.tracks-1)*100)+4);         call CONNECT(gpos.x(out.xloc*100-50)+1, gpos.y(200)+4,                      gpos.x(out.xloc*100-50)+1, gpos.y((trk.yloc+num.tracks-1)*100)+4);         transparent_mode;      end;      /* 1. Define graphics region for main DTD text area */      call Define.Graphics.Region(DTD.Display.Area, gpos.x(   0), gpos.y(   0),                                                    gpos.x(8000), gpos.y(2300));      call Set.Object.Action(DTD.Display.Area, O#ACT.Prev.Obj, false);      call Set.Object.Mouse.Access(DTD.Display.Area, O#ACT.Left.Press|O#ACT.Middle.Press|O#ACT.Right.Press);      /* 2. Define items on top row (left to right) */      if MG600 then do;         /* A. Define RECORD Button */         call Define.Graphics.Button.Table         (DTD.Record.Button, -50, Dtd.Top+3, 650, Dtd.Bot-3, 1, 1, 0);         call COPY.STRING('RECORD',s1);         call COPY.STRING('',      s2);         call Deposit.Graphics.Button.Table.Label(DTD.Record.Button, 0, 0, 2, s1, s2);         vector_mode;                                              call GBOX   (gpos.x(-50)-1, gpos.y(Dtd.Top+3)+1,      /* 3 boxes - one */                      gpos.x(650)+1, gpos.y(Dtd.Bot-3)-1, 0);  /* outside, one  */         call GBOX   (gpos.x(-50),   gpos.y(Dtd.Top+3),        /* around, one   */                      gpos.x(650),   gpos.y(Dtd.Bot-3), 0);    /* inside        */         call GBOX   (gpos.x(-50)+1, gpos.y(Dtd.Top+3)-1,                      gpos.x(650)-1, gpos.y(Dtd.Bot-3)+1, 0);         transparent_mode;         /* B. Define Motion Table */         call Define.Graphics.Button.Table         (DTD.Motion.Table, 1000, Dtd.Top+3, 3000, Dtd.Bot-3, 5, 1, 1);         call COPY.STRING('START',s1);         call COPY.STRING('',     s2);         call Deposit.Graphics.Button.Table.Label(DTD.Motion.Table, 0, 0, 1, s1, s2);         call COPY.STRING('STOP',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Motion.Table, 0, 1, 1, s1, s2);         call COPY.STRING('CONT',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Motion.Table, 0, 2, 1, s1, s2);         call COPY.STRING('REW',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Motion.Table, 0, 3, 1, s1, s2);         call COPY.STRING('FORWD',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Motion.Table, 0, 4, 1, s1, s2);         vector_mode;         call GBOX   (gpos.x(1000),   gpos.y(Dtd.Top+3),                      gpos.x(3000),   gpos.y(Dtd.Bot-3), 0);         call GBOX   (gpos.x(1000)-1, gpos.y(Dtd.Top+3)+1,                      gpos.x(3000)+1, gpos.y(Dtd.Bot-3)-1, 0);         transparent_mode;      end;   end Define.DTD.Items.Part1;   Define.DTD.Items.Part2: proc swapable;      dcl s1(20) fixed;        dcl s2(20) fixed;      dcl i fixed;      /* C. Draw Title */      call cpos(0,33);              /* title at top of screen  */      call ps('TRACK DISPLAY');      /* D. Define Time Display */      call Define.32Bit.MSEC(DTD.Time.Display, 0, 52, 11,          GID(Saved.AEE.Time.Format)\O#MSEC.RealTime,          cf#time, cf#default, cf#default);      call Set.Object.Action      (DTD.Time.Display,O#ACT.Update.On.Dep,true);      call Set.Object.Action      (DTD.Time.Display,O#ACT.RealTime.Object,true);		      if (MG600) then do;         /* E. Define Format Select Buttons */         call Define.Graphics.Button.Table         (DTD.Time.Format, 4900, Dtd.Bot-125, 5500, Dtd.Bot-76, 6, 1, 1);         vector_mode;         call GBOX   (gpos.x(4900),   gpos.y(Dtd.Bot-125),                      gpos.x(5500),   gpos.y(Dtd.Bot- 76), 0);         transparent_mode;         /* F. Define Time Format Label String */         call DEFINE.GRAPHICS.STRING (DTD.Format.String,                                      gpos.x(5600),                                     gpos.y(Dtd.Bot-76),                                      12, 1, 0, 0);         call Set.Object.Action      (DTD.Format.String,O#ACT.Update.On.Dep,true);         call Set.Object.Mouse.Access(DTD.Format.String, 0);         /* G. Define Digital Transfer Label */         call Define.Graphics.Button.Table         (DTD.Digital.Transfer, 6450, Dtd.Bot-58, 7650, Dtd.Bot-3, 1, 1, 0);         call COPY.STRING('Digital Xfer:',s1);         call COPY.STRING('',             s2);         call Deposit.Graphics.Button.Table.Label(DTD.Digital.Transfer, 0, 0, 1, s1, s2);         /* G'. Define DSP IN button */         call Define.Graphics.Button.Table         (DTD.Dsp.In, 7650, Dtd.Bot-58, 8050, Dtd.Bot-3, 1, 1, 0);         call COPY.STRING('DSP IN',s1);         call COPY.STRING('',      s2);         call Deposit.Graphics.Button.Table.Label(DTD.Dsp.In, 0, 0, 0, s1, s2);         /* H. Define Off.In.Out.Bounce Button row */			         call Define.Graphics.Button.Table         (DTD.Off.In.Out.Bounce, 6450, Dtd.Bot-120, 8050, Dtd.Bot-58, 4, 1, 1);         call COPY.STRING('OFF',s1);         call COPY.STRING('',     s2);         call Deposit.Graphics.Button.Table.Label(DTD.Off.In.Out.Bounce, 0, 0, 1, s1, s2);         call COPY.STRING('IN',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Off.In.Out.Bounce, 0, 1, 1, s1, s2);         call COPY.STRING('OUT',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Off.In.Out.Bounce, 0, 2, 1, s1, s2);         call COPY.STRING('BOUNCE',s1);         call Deposit.Graphics.Button.Table.Label(DTD.Off.In.Out.Bounce, 0, 3, 0, s1, s2);			         vector_mode;         call GBOX   (gpos.x(6450),   gpos.y(Dtd.Bot-120),                      gpos.x(8050),   gpos.y(Dtd.Bot-3), 0);         call GBOX   (gpos.x(6450)-1, gpos.y(Dtd.Bot-120)+1,                      gpos.x(8050)+1, gpos.y(Dtd.Bot-3)-1, 0);         call CONNECT(gpos.x(6450),   gpos.y(Dtd.Bot-58),                      gpos.x(8050),   gpos.y(Dtd.bot-58));         call CONNECT(gpos.x(7650),   gpos.y(Dtd.Bot-58),                      gpos.x(7650),   gpos.y(Dtd.bot- 3));         transparent_mode;         /* I. Define mark take button and on/off button */         call Define.Graphics.Button.Table         (DTD.Mark.On.Off, 5050, Dtd.Bot-47, 5150, Dtd.Bot-7, 1, 1, 0);         vector_mode;         call GBOX   (gpos.x(5050),   gpos.y(Dtd.Bot-47),                      gpos.x(5150),   gpos.y(Dtd.Bot- 7), 0);         transparent_mode;         call Load.Small.Take.Icon(Misc.Buf);         call Define.Graphics.Icon(DTD.Time.Take.Button,               4900, Dtd.Bot-7, 1, Misc.Buf);      end;      /* Define Mouse Hole */      call Define.Mouse.Hole.Icon(DTD.Mouse.Hole, 8100, Dtd.Bot); /* exit screen icon */   end Define.DTD.Items.Part2;   Define.And.Draw.DTD.Items: proc swapable;      call clear.term;      call initialize.screen.manager(TRD.LEN-8);      call set.screen.animate(0);                call Set.Term.Attr(Attr#Normal);      Previous.Highlight.Code = 0;          /* nothing highlighted */      Sampled.DTD.Track#      = Dtd.Track#; /* sampled dtd #       */      call Set.Default.Action(O#ACT.Middle.Press);      call Set.Default.Attr  (0,ATTR#Normal);      call Set.Default.Attr  (1,ATTR#Normal\ATTR#Reverse);      call Define.DTD.Items.Part1;  /* broke define code into two parts */      call Define.DTD.Items.Part2;  /* in order to keep swap area smaller */      call Activate.Screen(DTD.Display.Area);      call Update.Screen;         /* draw buttons here */      transparent_mode;   end Define.And.Draw.DTD.Items;   DISP.MULTI.TRACK.RECORD.SCREEN:  proc swapable;      dcl (i,j) fixed;      if inc.dtd=0 then return 0;      call Define.And.Draw.DTD.Items;      call PRINT.CCAT;              /* show current cat name   */      call cpos(trk.yloc-2,0);      /* TRACK/OUTPUTS line      */      call DRAW.CORNER(1);      call DRAW.HOR(26);      call ps(' TRACKS ');      call DRAW.HOR(25);      call DRAW.CORNER(0);      call ps(' ');      call DRAW.CORNER(1);      call DRAW.HOR(3);      call ps(' OUTPUTS ');      call DRAW.HOR(4);      call DRAW.CORNER(0);      call cpos(trk.yloc-1,button.xloc);      call ps('Butn No. Track Title      Status  Mode    Used  Input dB Out No.  Vol  Pan DDT');      call cpos(sng.yloc,2);      call ps('Proj:');      call cpos(sng.yloc,52);      call ps('Start:');      call cpos(sng.yloc,67);      call ps('End:');      call cpos(sng.yloc+1,2);      call ps('Crossfade:');      call cpos(sng.yloc+1,17);      call ps('ms');      call cpos(sng.yloc+1,34);      call ps('Rate:');      call cpos(sng.yloc+1,46);      call ps('kHz');      call cpos(sng.yloc+1,52);      call ps('Avail:');      call cpos(sng.yloc+1,66);      call ps('Used:');      call MULTI.TRACK.REC.DISPLAY.COMMANDS;      do i= 0 to num.tracks-1;         call PRINT.TRACK.BUTTON(i);         call Set.Term.Attr(Attr#Normal);         /* print track # index */         call cpos(trk.yloc+i,tnum.xloc);         call print.parm(i+1,0,0,2,0);         call pc(dot);         /* print out # index */         call cpos(trk.yloc+i,out.xloc);         call print.parm(i+1,0,0,2,0);         call pc(dot);      end;      call EXTSET(trd.ptr,0,1536,-1);   /* clear out info from LOD, snap shot and display area in external memory */      store.dtd.info = 2;               /* indicate to LOD that we have track display info */      track.command  = 0;      dtd.prompt     = 0;      track.command.type=(-1);      /* $page */		if ((simulate.dtd == 0) && (lod.running == 0))      then call no.direct.to.disk;      else if (!simulate.dtd) send.to.lod(dtd.select.track,0);  /* otherwise tell LOD to select a song */      new.ABLE.dtd.info = new.ABLE.dtd.info\2;      /* draw button list */      previous.lod.recd.tracks=0;   end DISP.MULTI.TRACK.RECORD.SCREEN;   /* $page */   TRACK.DISPLAY.ATTRIBUTE.DEPOSIT: proc swapable; /* parses parameter and updates */      dcl val   fixed;      dcl (i,j) fixed;      dcl ch    fixed;      if token(0)<>0 then do;     /* otherwise it is running */         do case (curr.fld);            ;                          /* 0: update button number */            do;                        /* 1: update title */               tok.ptr=0;              /* get title token value and space fill */               trk.title(0)=0;               do while (tok.ptr<token(0));                  call pbyte(trk.title,trk.title(0),byte(token,tok.ptr));                  trk.title(0)=trk.title(0)+1;                  tok.ptr=tok.ptr+1;               end;               do while trk.title(0)<shl(trk.title.length,1);  /* space fill the rest of the title selection */                  call pbyte(trk.title,trk.title(0),sp);                  trk.title(0)=trk.title(0)+1;               end;               write(mam)=scsi.ptr;               do i=1 to trk.title.length;                  write(mdi)=trk.title(i);               end;               if (!simulate.dtd) send.to.lod(dtd.track.name,shl(trk.title.length,1));               New.Seq.Info = New.Seq.Info | 2;           /* New track name */               write(MAM) = D115D.Note.Change.Tracks;               write(MAL) = FIRST.LOD.TRACK+DTD.Track#;               write(MD) = "177777";            /*   "new notes" OR "new timbre"    */            end;            ;                            /* 2: update track status */            ;                            /* 3: update track play mode */            ;                            /* 4: source field (space bar only) */            do;                          /* 5: update input channel */               /* see whether current source is stm, dig, out or trk */               i=song.blen+dtd.track#*mtrk.blen+tinchan.off;               write(mam)=trd.ptr+2+shr(i,8);               write(mal)=i&255;               if read(md) >= 0    /* make sure ddt data is available     */               then do;                  i=shr(read(md),8);  /* get source code: stm, dig, out, trk */                  if i = 0            /* if STM input                        */                  then do;                     val=READ.INPUT.CHANNEL;                     if (ertyp=0) and (val>=0) then do;                        write(mam)=scsi.ptr;                        write(md)=val;                        if (!simulate.dtd) send.to.lod(dtd.input.chan,2);                     end;                  end;                  else do;            /* dig, out, trk                       */                     val=CONV.STR.TO.FIXED(token,0,0); /* unsigned, no dec. pt. */                     if ertyp=0 then do;                        do case (i-1);       /* check value for this source */                           do;                             /* DIG                       */                              if ((ddt.config & 15) = 2)   /* multi track DDT avail     */                              then do;                                 call set.error(err.ddt.routs,'');                                 val = -1;                              end;                              else if val IGT 2 then val = -1;                           end;                           do;                              /* out                   */                              if  (val IGT dtd.max.tracks)                              and (val IGT dtd.num.voices)                              then val = -1;                           end;                           do;                               /* track                 */                              if  (val IGT dtd.max.tracks)                              then val = -1;                           end;                        end;                        if val >= 0 then do;                           write(mam)=scsi.ptr;                           write(md)=shl(i,8) \ val;                           if (!simulate.dtd) send.to.lod(dtd.input.chan,2);                        end;                        else call overflow.error;                     end;                  end;               end;            end;            do;                         /* 6: update track gain  */               val=CONV.STR.TO.FIXED(token,0,1); /* signed, no dec. pt. */               if ertyp=0 then do;                  if  val <= 28           /* if gain isn't too high... */                  and val >= -3 then do;  /* ...or too low,            */                     val = map_dB_to_times (val); /* Convert entered dB to "times" value */                     write(mam)=scsi.ptr;         /* setup and... */                     write(md)=val;                     if (!simulate.dtd) send.to.lod(dtd.track.gain,2);  /* Send gain to LOD */                  end;                  else call overflow.error;               end;            end;                        do;                         /* 7: new DOA routing */               val=CONV.STR.TO.FIXED(token,0,0);  /* get new routing */               if ertyp=0 then do;                  if val IGT DTD.Num.Voices                  then call overflow.error;                  else do;                     write(mam) = scsi.ptr;                     write(md)  = val;                     if (!simulate.dtd) send.to.lod(dtd.track.doa, 2);                  end;               end;            end;            do;                         /* 8: update track volume  */               val=CONV.STR.TO.FIXED(token,1,0);               if ertyp=0 then do;                  if val<=1000 then do;                     write(mam)=scsi.ptr;                     write(md)=val;                     if (!simulate.dtd) send.to.lod(dtd.track.vol,2);                  end;                  else call overflow.error;               end;            end;            do;                         /* 9: update track pan  */               val=CONV.STR.TO.FIXED(token,0,1);               if ertyp=0 then do;                  if (val>=-50) and (val<=50) then do;                     write(mam)=scsi.ptr;                     write(md)=val;                     if (!simulate.dtd) send.to.lod(dtd.track.pan,2);                  end;                  else call overflow.error;               end;            end;            do;                         /* 10: new DDT routing */               if ((ddt.config & 15) = 2)         /* multi track DDT avail     */               then call set.error(err.ddt.routs,'');               else do;                  val=CONV.STR.TO.FIXED(token,0,0);  /* get new routing */                  if ertyp=0 then do;                     if val IGT 16                     then call overflow.error;                     else do;                        write(mam)=scsi.ptr;                        write(md)=val;                        if (!simulate.dtd) send.to.lod(dtd.track.ddt,2);                     end;                  end;               end;            end;         end;         call MULTI.TRACK.REC.SNAP.SHOT;                 /* update new area */         call Print.Field(Sampled.DTD.Track#, Curr.Fld); /* hopefully get new field */         /* Create a system event for protocol devices when */         /* we change something about a track:              */         new.dtd.info = new.dtd.info \ 16384;      end;      token(0)=0;   end TRACK.DISPLAY.ATTRIBUTE.DEPOSIT;   /* $page */   TEST.TRACK.PASSWORD:  proc fixed swapable;  /* checks if user typed in the correct password */      dcl i fixed;      if (track.command.type=1) then do;  /* if loading track */         if token(0)=4 then do;              /* if four characters for LOAD */            i=byte(token,0);                 /* see if user typed LOAD */            if (i=asc.l) or (i=lower.l) then do;               i=byte(token,1);               if (i=asc.o) or (i=lower.o) then do;                  i=byte(token,2);                  if (i=asc.a) or (i=lower.a) then do;                     i=byte(token,3);                     if (i=asc.d) or (i=lower.d)                     then return 1;                  end;               end;            end;         end;      end;      else if (track.command.type=2) then do;  /* if erasing track */         if token(0)=5 then do;              /* if five characters for ERASE */            i=byte(token,0);                 /* see if user typed ERASE*/            if (i=asc.e) or (i=lower.e) then do;               i=byte(token,1);               if (i=asc.r) or (i=lower.r) then do;                  i=byte(token,2);                  if (i=asc.a) or (i=lower.a) then do;                     i=byte(token,3);                     if (i=asc.s) or (i=lower.s) then do;                        i=byte(token,4);                        if (i=asc.e) or (i=lower.e)                        then return 1;                     end;                  end;               end;            end;         end;      end;      else if (token(0)<>0) then do;         i=byte(token,0);                  /* see if user typed OK */         if (i=asc.o) or (i=lower.o) then do;            if token(0)=2 then do;               i=byte(token,1);               if (i=asc.k) or (i=lower.k)               then return 1;            end;         end;      end;      return 0;   end TEST.TRACK.PASSWORD;   /* $page - routines to increment/decrement fields */   Toggle.Button.Field:proc (arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;      dcl lim fixed;      if  (dtd.avail.trks&"177400") = 0 then lim =  8;  /* must be 8 trk  */      else                                   lim = 16;  /* must be 16 trk */      i=0;                  /* not found           */      j=0;                  /* see if lod tracks on button panel now */      do while (i=0)&(j<num.track.buttons);         write(mam)=tbut.ptr;         write(mal)=j;         if  ((read(md)&255)>=first.lod.track)         and ((read(md)&255)< last.lod.track )         then i=1;          /* lod tracks start here       */         else j=j+1;        /* else keep looking           */      end;      if i<>0 then do;      /* lod tracks there:           */         do i=0 to num.track.buttons-1;  /* remove current lod tracks */            write(mam)=tbut.ptr;         /* restore lod buttons to    */            write(mal)=i;                /* synclav buttons           */            if  ((read(md)&255)>=first.lod.track)            and ((read(md)&255)< last.lod.track )            then write(md)=(read(md)&"177400")\(i+num.kbd.tracks);         end;         if arg > 0 then do;            j=j+8;        /* move down 8 buttons       */              end;         else do;         /* move up   8 buttons       */            if j ilt 8 then j=32;            else            j=j-8;         end;      end;      else do;               /* buttons not on panel now  */         if arg = 1         then j=0;           /* put lod tracks on top row */         else j=24;          /* else bottom row           */      end;      /* $page */      do i=0 to lim-1;  /* now put lod tracks back in */         if (j+i)<num.track.buttons         then do;            write(mam)=tbut.ptr;            write(mal)=j+i;            write(md)=(read(md)&"177400")\(first.lod.track+i);         end;      end;      call display.track.buttons;      new.ABLE.dtd.info=new.ABLE.dtd.info\6;  /* update screen */   end Toggle.Button.Field;   Toggle.Status.Field: proc(arg) swapable;      dcl arg fixed;      if (!simulate.dtd) Send.To.Lod(dtd.trk.status,0);      /* Create a system event telling remote device the status */      /* may have changed:                                      */      new.seq.info = new.seq.info \ 4096;   end Toggle.Status.Field;      Toggle.Mode.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;      if arg > 0 then do;                          /* increment          */         if (!simulate.dtd) Send.To.Lod(dtd.trk.mode,0);      end;      else do;                                    /* decrement             */			if ((simulate.dtd != 0) || (lod.running != 0)) then do;            i=song.blen+dtd.track#*mtrk.blen+tstat.off; /* look up current val   */            write(mam)=trd.ptr+2+shr(i,8);            write(mal)=i&255;            if read(md) >=0 then do;              /* if data avail         */               i=shr(read(md),8);               write(mam) = SCSI.Ptr;               write(mdi) = (i-1)&3;               if (!simulate.dtd) Send.To.Lod(154,2);            end;         end;      end;      /* Create a system event telling remote device the mode   */      /* may have changed:                                      */      new.seq.info = new.seq.info \ 16384;   end Toggle.Mode.Field;   Toggle.Source.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;		if ((simulate.dtd != 0) || (lod.running != 0)) then do;         i=song.blen+dtd.track#*mtrk.blen+tinchan.off;         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i=read(md);         if i >=0 then do;                      /* if data avail         */            i = (i + shl(arg,8)) & "001777";    /* modulo 3, upper half  */            write(mam)=scsi.ptr;            write(md)=i;            if (!simulate.dtd) Send.To.Lod(dtd.input.chan,2);            /* Create a system event for protocol devices when */            /* we change something about a track:              */            new.dtd.info = new.dtd.info \ 16384;         end;      end;   end Toggle.Source.Field;   Toggle.Channel.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;		if ((simulate.dtd != 0) || (lod.running != 0)) then do;         i=song.blen+dtd.track#*mtrk.blen+tinchan.off;         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i=read(md);         if i >=0 then do;                      /* if data avail         */            j = (i&255) + arg;                  /* get current channel   */                                                /* incr/decr as desired  */                        if arg = 0 then j = 0;              /* arg = 0 for delete    */            do case (shr(i,8));                 /* check limit           */                                                /* based upon source     */               do;                              /* stm                   */                  if j <  0 then j = 16;        /* off, 1A - 4D          */                  if j > 16 then j = 0;               end;               do;                              /* DIG                   */                  if ((ddt.config & 15) = 2)    /* multi track DDT avail */                  then call set.error(err.ddt.routs,'');                  if j < 0 then j = 2;          /* off, 1, 2             */                  if j > 2 then j = 0;               end;               do;                              /* out                   */                  if j < 0 then do;             /* off, 1 - # of outs    */                     if dtd.num.voices <> 0     /* if new lod software   */                     then j = dtd.num.voices;                     else j = dtd.max.tracks;                  end;                  if  (j > dtd.max.tracks)                  and (j > dtd.num.voices)                  then j = 0;               end;               do;                                  /* track                 */                  if j < 0 then j = dtd.max.tracks; /* off, 1 - # of trks    */                  if  (j > dtd.max.tracks)                  then j = 0;               end;            end;            write(mam)=scsi.ptr;            write(md )=(i & "177400") \ j;            if (!simulate.dtd) Send.To.Lod(dtd.input.chan,2);                        /* Create a system event for protocol devices when */            /* we change something about a track:              */            new.dtd.info = new.dtd.info \ 16384;         end;      end;   end Toggle.Channel.Field;   Toggle.Gain.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;		if ((simulate.dtd != 0) || (lod.running != 0)) then do;         /* look up gain                 */         i=song.blen+dtd.track#*mtrk.blen+tgain.off;  /* compute pointer */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i = read(md);         i = map_times_to_dB (i) + arg;      /* convert "times" value to dB   */         if i < (-3) then i = (-3);         if i > (28) then i = (28);         i = map_dB_to_times (i);   /* Convert entered dB to "times" value */         write(mam) = scsi.ptr;     /* setup and... */         write(md)  = i;         if (!simulate.dtd) send.to.lod(dtd.track.gain,2);  /* Send gain to LOD */         /* Create a system event for protocol devices when */         /* we change something about a track:              */         new.dtd.info = new.dtd.info \ 16384;      end;   end Toggle.Gain.Field;   Toggle.Doa.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;		if ((simulate.dtd != 0) || (lod.running != 0)) then do;         /* look up doa routing */         i=song.blen+dtd.track#*mtrk.blen+trout.off;  /* compute pointer */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i = read(md) & 255;         if arg = 0         then i = 0;              /* delete function     */         else i = i + arg;        /* increment/decrement */         if i < (             0) then i = (DTD.Num.Voices);         if i > (DTD.Num.Voices) then i = (0             );         write(mam) = scsi.ptr;     /* setup and... */         write(md)  = i;         if (!simulate.dtd) send.to.lod(dtd.track.doa,2);  /* Send new doa to LOD */         /* Create a system event for protocol devices when */         /* we change something about a track:              */         new.dtd.info = new.dtd.info \ 16384;      end;   end Toggle.Doa.Field;   Toggle.DDT.Field: proc(arg) swapable;      dcl arg fixed;      dcl i   fixed;      dcl j   fixed;		if ((simulate.dtd != 0) || (lod.running != 0)) then do;         /* look up ddt routing */         i=song.blen+dtd.track#*mtrk.blen+trout.off;  /* compute pointer */         write(mam)=trd.ptr+2+shr(i,8);         write(mal)=i&255;         i = shr(read(md),8);         if arg = 0         then i = 0;              /* delete function     */         else i = i + arg;        /* increment/decrement */         if i < ( 0) then i = ( 2);         if i > ( 2) then i = ( 0);         if ((ddt.config & 15) = 2)    /* multi track DDT avail */         then call set.error(err.ddt.routs,'');         else do;            write(mam) = scsi.ptr;     /* setup and... */            write(md)  = i;            if (!simulate.dtd) send.to.lod(dtd.track.ddt,2);  /* Send new doa to LOD */         end;         /* Create a system event for protocol devices when */         /* we change something about a track:              */         new.dtd.info = new.dtd.info \ 16384;      end;   end Toggle.DDT.Field;   /* $Subtitle Direct-to-Disk Track Display Character Handler */   MULTI.TRACK.REC.INPUT:  proc(in.cmd,in.arg) fixed swapable;    /* Multi-Track Summary Directory input handler */      dcl (in.cmd,in.arg)  fixed;   /* input command and argument */      dcl i                fixed;      dcl j                fixed;      dcl dtd.track.command data (7,8,6,-1,14,15,16,17,18,11,9);      if inc.dtd=0 then return 0;      if err.displayed<>0 then do;       /* if an error displayed other than (-1) a song command prompt */         if (track.command<>0) then do; /* if there was a track command prompt there */            track.command=0;            token(0)=0;            dtd.prompt=0;         end;         call Set.Term.Attr(ATTR#Normal);         call REMOVE.ERR;               /* remove any error */         call Check.Next.Event;         call PRINT.CCAT;               /* show current cat name */         call Check.Next.Event;      end;      do case (in.cmd);             /* do depending upon input command */         do;                        /* 0: character input */            if  in.arg=ESC            then do;               if (recd<>0)&(recd.trk=0)               then do;                  call noexit.err;                  return;               end;               if (upper.disp=lod.disp)               then call clear.display;               track.command=0; dtd.prompt=0;               EXIT.MY.SCREEN=1;               return;            end;            else if in.arg=tab            then do;               if (upper.disp=lod.disp)               then call clear.display;               EXIT.MY.SCREEN=1;               GOTO.THIS.SCREEN=s.song.directory;               track.command=0; dtd.prompt=0;               return;            end;            else if in.arg="20" then do;       /* CTRL-P: print hardcopy of screen */               if D40_PRESENT<>0               /* if device available */               then call SCREEN_DUMP;          /* screen dump */                  else call no.printer;               return;            end;				if ((simulate.dtd == 0) && (lod.running == 0)) then do;               call no.direct.to.disk;               return;            end;            if (((in.arg>="1") and (in.arg<="4")) or  /* if CTRL-A -> CTRL-C */            ((in.arg>="25") and (in.arg<="32"))) then do;              /* or CTRL-U -> CTRL-Z */               track.command=1;               if ((in.arg>="1") and (in.arg<="4"))                 /* if CTRL-A -> CTRL-D */               then track.command.type=in.arg-"1";               else track.command.type=(in.arg-"25")+"4";           /* if CTRL-U -> CTRL-Z */               call ERASE.REST.OF.LINE(23,0);                       /* erase bottom line */               call DISPLAY.TRACK.PROMPT;               token(0)=0;            end;            /* $page */            else if (in.arg=cret) then do;             /* CR: if carriage return */               if track.command=0 then do;                  call TRACK.DISPLAY.ATTRIBUTE.DEPOSIT; /* enter new value */               end;               else do;                               /* if track command selected */                  call ERASE.REST.OF.LINE(23,0);                  if (token(0)<>0) then do;                     if track.command.type=3 then do; /* if entering crossfade time */                        i=CONV.STR.TO.FIXED(token,0,0);                        if (i<1) or (i>99)            /* check limits */                        then call overflow.error;                        else do;                      /* valid crossfade */                           write(mam)=scsi.ptr;                           write(md)=i;                           if (!simulate.dtd) send.to.lod(dtd.crossfade,2);  /* set cross fade */                        end;                     end;                     else if TEST.TRACK.PASSWORD<>0 then do;                        write(mam)=scsi.ptr;                        write(md)=dtd.track.command(track.command.type);                        if (!simulate.dtd) send.to.lod(dtd.send.command,2);    /* send command to live overdub */                        call Update.AEE.Track.Status.Displays.And.Tallies (-1, -1);                     end;                     else if (token(0)<>0) then call password.error; /* do not give error message on plain old carriage return */                  end;                  token(0)=0;                  track.command=0;                  dtd.prompt   =0;               end;                                   /* of if selected a track command */            end;                                      /* of if carriage return */            else if ((in.arg>=sp) and (in.arg<=asc.tilde)) then do; /* if a typed character */               if  (in.arg=sp)             /* if space is typed */               and (track.command=0)       /* no command        */               and ((curr.fld=0 )          /* on button field   */               or   (curr.fld=2 )          /* on status field   */               or   (curr.fld=3 )          /* on mode   field   */               or   (curr.fld=4 )          /* on source field   */               or   (curr.fld=5 )          /* on chanl  field   */               or   (curr.fld=6 )          /* on gain   field   */               or   (curr.fld=7 )          /* on DOA    field   */               or   (curr.fld=10))         /* or DDT    field   */               then do;                   if curr.fld=0 then do;   /* toggle button field */                     call Toggle.Button.Field(+1);                  end;                  else if curr.fld=2                  then do;                     call Toggle.Status.Field(+1);                     call Update.AEE.Track.Status.Displays.And.Tallies (0, bits(dtd.track#));                  end;                  else if curr.fld=3                  then do;                     call Toggle.Mode.Field(+1);                     call Update.AEE.Track.Status.Displays.And.Tallies (bits(dtd.track#), 0);                  end;                  else if (curr.fld = 4)          /* on source field   */                  then do;                     call Toggle.Source.Field(+1);                  end;                  else if (curr.fld = 5)          /* on chanl  field   */                  then do;                     call Toggle.Channel.Field(+1);                  end;                  else if (curr.fld = 6)          /* on gain   field   */                  then do;                     call Toggle.Gain.Field(+1);                  end;                  else if (curr.fld = 7)          /* on DOA    field   */                  then do;                     call Toggle.Doa.Field(+1);                  end;                  else if (curr.fld = 10)         /* or DDT    field   */                  then do;                     call Toggle.DDT.Field(+1);                  end;                  if (((New.Dtd.Info     &4)) <> 0)  /* try to update field quickly     */                  or (((New.ABLE.Dtd.Info&4)) <> 0)  /* if user is holding space bar!   */                  then do;                     call MULTI.TRACK.REC.SNAP.SHOT;                     call Print.Field(DTD.Track#, Curr.Fld);                  end;                                     /* mouse increments      */               end;               else if (token(0) ILT rec.max.tlen) or ((track.command<>0) and (token(0)<5)) then do;     /* if token length within limits or responding to a command prompt */                  if (track.command<>0) and (token(0)<5) then do;                     if (token(0)<2) or                     ((track.command.type=1) and (token(0)<4)) or    /* if typing load */                     ((track.command.type=2) and (token(0)<5)) then do;    /* if typing erase */                        call pbyte(token,token(0),in.arg);                        token(0)=token(0)+1;                     end;                  end;                  else if (track.command=0) and (token(0) ILT rec.max.tlen) then do;                     call pbyte(token,token(0),in.arg);                     token(0)=token(0)+1;                  end;               end;            end;            else if (in.arg=del) or (in.arg="32") then do;      /* DELETE or CTRL-Z: Erase last char */               if token(0)<>0 then do;                          /* chars to delete */                  token(0)=token(0)-1;                  if Token(0) = 0 then call Print.Field(Sampled.DTD.Track#, Curr.fld);                  else do;                     call Pos.DTD.Cursor.For.Input;                     call pc(sp); call pc(bs);                  end;               end;               else if track.command<>0 then do;                  track.command=0; dtd.prompt=0;                  call ERASE.REST.OF.LINE(23,0);                /* erase the prompt */               end;               else if curr.fld = 5 then do;                     /* if on the channel field */                  call Toggle.Channel.Field(0);               end;               else if curr.fld = 7                  /* on DOA    field   */               then do;                  call Toggle.Doa.Field(0);               end;               else if curr.fld = 10                 /* on DDT    field   */               then do;                  call Toggle.DDT.Field(0);               end;            end;            else if (in.arg=u.arr) or (in.arg=d.arr) or (in.arg=l.arr) or (in.arg=r.arr) or (in.arg=home) then do; /* if up, down, or home arrow keys */               if track.command=0 then do;                  /* if not a track command */                  call TRACK.DISPLAY.ATTRIBUTE.DEPOSIT;     /* enter value */                  if (in.arg=u.arr) or (in.arg=d.arr) then do;       /* if up or down arrow */                     if in.arg=u.arr                     then {if (!simulate.dtd) send.to.lod(dtd.up,  0);}                     else {if (!simulate.dtd) send.to.lod(dtd.down,0);}                     call Change.DTD.Highlighting(0);                  end;                  else if (in.arg=l.arr) or (in.arg=r.arr) then do;                     if in.arg=r.arr then do;                        if curr.fld<max.fld                        then do;                           curr.fld=curr.fld+1;                           call Change.DTD.Highlighting(0);                        end;                     end;                     else do;                        if curr.fld>min.fld                        then do;                           curr.fld=curr.fld-1;                           call Change.DTD.Highlighting(0);                        end;                     end;                  end;                  else do;                     if (!simulate.dtd) send.to.lod(dtd.home,0);                     call Change.DTD.Highlighting(0);                  end;                  call SET.REC.MAX.TLEN; /* set the maximum token value */               end;                      /* of if not a track command */            end;         end;                            /* of character input */         /* $page */         do;                             /* 1: absolute select */				if ((simulate.dtd == 0) && (lod.running == 0)) then do;               call no.direct.to.disk;               return;            end;            if track.command=0 then do;               call TRACK.DISPLAY.ATTRIBUTE.DEPOSIT; /* enter new value */            end;            if #ypos>=0 then do;         /* if a command was chosen */               token(0)=0;               track.command=1;               track.command.type=#ypos;               call ERASE.REST.OF.LINE(23,0);    /* erase bottom line */               call DISPLAY.TRACK.PROMPT;               token(0)=0;            end;            else do;               curr.fld=shr(in.arg,8);   /* set the field for cursor positioning */               write(mam)=scsi.ptr;               write(md)=in.arg&255;               if (!simulate.dtd) send.to.lod(dtd.set.screen.line,2);  /* set the track number (0-15) */            end;         end;         ;                               /* 2: scroll down */         ;                               /* 3: scroll up */         do;                             /* 4: return to previous screen */            track.command=0;            dtd.prompt   =0;            if (recd<>0)&(recd.trk=0)            then do;               call noexit.err;               return;            end;            if (upper.disp=lod.disp)            then call clear.display;            EXIT.MY.SCREEN=1;         end;      end;                              /* of do depending upon input character */   end MULTI.TRACK.REC.INPUT;   /* $Subtitle Direct-to-Disk Multi-Track Recording Mouse Mapping Routine 539-Live*/   MULTI.TRACK.REC.MOUSE.POS:  proc(x,y,code) swapable;      dcl (x,y)   fixed;      dcl (code)  fixed;    /* + 1 = right,  2 = middle,  3 = left */      dcl (i,j)   fixed;      if inc.dtd=0 then return;      if err.displayed<>0 then do;         call Set.Term.Attr(ATTR#Normal);         call REMOVE.ERR;               /* remove any error */         call PRINT.CCAT;               /* show current cat name */      end;		if ((simulate.dtd == 0) && (lod.running == 0)) then do;         call no.direct.to.disk;         return;      end;      /* convert the mouse pixel coordinates to screen coordinates */      x=CONVERT.MOUSE.X(x);     /* 0-79 */      y=CONVERT.MOUSE.Y(y);     /* 0-23 */      if (y >= trk.yloc) and (y < (trk.yloc+num.tracks))       then do;                  dcl mouse.me.data data (button.xloc, 4,   /* x position and   */                                 tname.xloc, 16,   /* field width of   */                                 tstat.xloc,  7,   /* mouse selected   */                                 tplay.xloc,  6,   /* fields on P      */                                 insrc.xloc,  3,   /* screen           */                                 inchan.xloc, 2,                                 tgain.xloc,  2,                                 tdoa.xloc,   3,                                 tvol.xloc,   5,                                 tpan.xloc,   3,                                 tdig.xloc,   3);         do i=0 to 10;                   /* see if in field */            if  (x >= (Mouse.Me.Data(shl(i,1))))            and (x <  (Mouse.Me.Data(shl(i,1)) + Mouse.Me.Data(shl(i,1)+1)))            then do;               #ypos=(-1);                         /* indicate not a command */               call MULTI.TRACK.REC.INPUT(in.abss, shl(i,8) \ (y-trk.yloc));               if  (code = mou#right.up)           /* incr/decr */               or  (code = mou#left.up )               then do;                  do case (i);                     call Toggle.Button.Field (2-code);  /*  0 = button field */                     ;                                   /*  1 = title        */                     call Toggle.Status.Field (2-code);  /*  2 = status       */                     call Toggle.Mode.Field   (2-code);  /*  3 = mode         */                     call Toggle.Source.Field (2-code);  /*  4 = source       */                     call Toggle.Channel.Field(2-code);  /*  5 = channel      */                     call Toggle.Gain.Field   (2-code);  /*  6 = gain         */                     call Toggle.Doa.Field    (2-code);  /*  7 = DOA          */                     ;                                   /*  8 = vol          */                     ;                                   /*  9 = pan          */                     call Toggle.DDT.Field    (2-code);  /* 10 = DDT          */                  end;                  if (((New.Dtd.Info     &4)) <> 0)  /* try to update field quickly     */                  or (((New.ABLE.Dtd.Info&4)) <> 0)  /* if user is holding space bar!   */                  then do;                     call MULTI.TRACK.REC.SNAP.SHOT;       /* the field on space    */                  end;                                     /* mouse increments      */                  call Change.DTD.Highlighting(1);         /* present new highlighting quickly */                  if (Curr.Fld = 3)                        /* then present new tallies */                  then call Update.AEE.Track.Status.Displays.And.Tallies (bits(dtd.track#), 0);                  if (Curr.Fld = 2)                        /* then present new tallies */                  then call Update.AEE.Track.Status.Displays.And.Tallies (0, bits(dtd.track#));               end;               else call Change.DTD.Highlighting(0);            end;         end;      end;      else if (y>=21) and (y<=22) then do;   /* perhaps a command */         if (x>=2) and (x<19) then do;      /* back up or load track */            if y=21 then #ypos=0;            else #ypos=1;         end;         else if (x>=19) and (x<36) then do; /* erase track or enter fade */            if y=21 then #ypos=2;            else #ypos=3;         end;         else if (x>=36) and (x<49) then do;   /* unlock or lock */            if y=21 then #ypos=4;            else #ypos=5;         end;         else if (x>=49) and (x<67) then do;  /* all repro or all input */            if y=21 then #ypos=6;            else #ypos=7;         end;         else if (x>=67) and (x<=79) then do;   /* all auto or all safe */            if y=21 then #ypos=8;            else #ypos=9;         end;         call MULTI.TRACK.REC.INPUT(in.abss,shl(x,8)\y);      end;   end MULTI.TRACK.REC.MOUSE.POS;