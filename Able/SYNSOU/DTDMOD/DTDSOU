/* DTDSOU $Title Direct-to-Disk Song Directory Routines   Modified:   11/13/91 - PF  - Removed mathdcl insert   08/14/91 - cj  - Added UDIO/DDSYN stuff   06/25/91 - cj  - Added calls to check.next.event to speed up GPI   10/30/90 - cj  - Checked more update bits in new dtd info   07/10/90 - PF  - Removed more unused inserts   08/29/89 - MWH - Reduce the number of symbols so this will compile!   12/20/88 - cj - changed use of dtd.xfer.mode for multi-track ddt   07/09/88 - cj  made time display more accurate   06/23/88 - MWH - Remove unused inserts   06/20/88 - cj  checked for lod.running   06/20/88 - MWH - Don't call send.to.lod unless DTD is there!   06/15/88 - cj  finished up bounce and digital transfer   04/29/88 - CJ  added Direct-Digital-Transfer field   04/26/88 - JSS added insert of mathdcl (contains dB <=> "times" procs)   02/26/87 - BSW put these routines into a Direct-to-Disk Screen Module*/Module DTDMOD;   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:asciilit';  /* ASCII literals */   insert ':synlits:globlits';  /* good globals */   insert ':synlits:statelit';  /* screen state literals */   insert ':synlits:syslits';   /* if d40_present */   insert ':synlits:lpnlits';   /* mark.l, etc.   */   insert ':synauxs:dtdlits';   /* song and multi-track literals */   insert ':synauxs:mathlits';     insert ':synmods:globdcl';   /* global routines */   insert ':synmods:ttydcl';    /* terminal i/o routines */   insert ':synmods:scrndcl';   /* screen design primitives */   insert ':synmods:errdcl';    /* error routines */   insert ':synmods:d40dcl';    /* for screen_dump */   insert ':synmods:moussdcl';  /* mouse routines */   insert ':synmods:plotdcl';   /* needed for clear.term (must erase mouse hole) */   insert ':synmods:tprimdcl';  /* general terminal routines */   insert ':synmods:tformdcl';  /* terminal formatting routines */   insert ':synmods:xmemdcl';   /* external memory module */   insert ':synmods:getvdcl';   /* globals for get.next.event */   insert ':synmods:getdcl';    /* for next.event.info */   insert ':synmods:loddcl';    /* live overdub   */   insert ':synmods:smgrdcl';   /* smgr items   */   insert ':synmods:giddcl';    /* PID/GID      */   insert ':synmods:seqdcl';    /* for cursor begin & end stuff  */   insert ':synmods:linkdcl';   /* for take system sequence time */	INSERT ':-XPL:INTRPRTR';   /* From TRAPDCL */   dcl Armed.for.Protocol.DTD.Recording fixed external;   dcl Protocol.Recording.State         fixed external;   insert ':synmods:audmods:apmendcl'; /* for READ.DEFAULTS() */   insert ':synmods:audmods:adtddcl';  /* for SELECT.DTD.CURRENT.PROJECT() */   insert ':synrdcls:08-idcls'; /* for DEFDEV, DEFSEC */   insert ':synrdcls:03-pdcls';   insert ':synrdcls:04-sdcls';   insert ':synrdcls:05-bdcls';   insert ':synlits:synclits';   /* get rtp literals */   /* From MATHDCL */   DCL STR32                 proc(fixed,fixed,array) external;   DCL ADD16                 proc(fixed,array) external;   dcl map_times_to_dB proc (fixed) returns (fixed) external;   dcl map_dB_to_times proc (fixed) returns (fixed) external;   DCL COPY32                proc(array,array) external;   DCL COM32                 proc(array,array) returns (fixed) external;   /* from 11-tdcls */   dcl COMPUTE.ACTIVE.TRKS proc external;   /* the following two routines must be brought in either by declaring */   /* dummy routines or by binding in the Audio Event Editor            */   dcl Initialize.Remote.Control.Items  proc external;   dcl Update.AEE.Track.Status.Displays.And.Tallies proc (fixed,fixed) external;   dcl simulate.dtd lit '0';   insert ':synsou:dtdmod:dtdsoua';   insert ':synsou:dtdmod:dtdsoub';   insert ':synsou:dtdmod:dtdsouc';   /* $Subtitle Activate Song Directory Screen */      DIRECT.TO.DISK.SONG.DIRECTORY:  PROC(arg) PUBLIC SWAPABLE;  /* call to activate DTD song Directory */      dcl arg     fixed;                    /* reserved for future use */      dcl (code)  fixed;      if inc.dtd=0 then do;         call feature.not.available;         return (-1);      end;      /*dtd.retries=0;*/                  /* if we had disconnected earlier, clear counter so we can try again */      call DISP.SONG.DIRECTORY;       /* draw the song directory screen */      call POS.SONG.DIRECTORY.CURSOR; /* position the cursor */      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS(get.in.char,          /* get in.chars      */                               get.mouse.button,     /* get mouse buttons */                               get.dtd.info,         /* direct-to-disk messages */                               get.ertyp);           /* errors            */      do while exit.my.screen=0;         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call RETURN.TO.PREV.STATE;               else call SONG.DIRECTORY.INPUT(in.chin,next.event.info);  /* Song Directory input handler */            end;            if next.event.info=2       /* look for release of middle button */            then do;               call SONG.DIRECTORY.MOUSE.POS (mouse(release.x),mouse(release.y));/* Mouse Positioner */            end;            ;                          /* mouse movement not used */            ;                          /* new timbre info         */            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            ;                          /* timbre parameter change */            do;                           /* see if new info from */               if (next.event.info&7)<>0  /* dtd has arrived      */               then do;                  if (UPDATE.SONG.DIRECTORY = 0) /* if no changes, see if we should */                  &  ((next.event.info&1) <> 0)  /* position cursor after new proj  */                  then call POS.SONG.DIRECTORY.CURSOR;               end;            end;            ;                          /* poly change- nothing    */            do;                        /* error message to display */                if dtd.prompt=0                then do;                  call Handle.System.Error.Codes(next.event.info);                  call POS.SONG.DIRECTORY.CURSOR;               end;					else					{						Chill.Out.And.Run.Syn();			  // keep mac happy while we wait for user to finish entering the prompt               	new.ABLE.ertyp = next.event.info;  /* else save error message until prompt goes away */					}            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* of loop              */      call DISABLE_SEVERAL_GETS(get.in.char,                                     get.mouse.button,                                get.dtd.info,                                 get.ertyp);             EXIT.MY.SCREEN   = 0;            /* clear flag after loop */      store.dtd.info    =0;            /* assume not in direct-to-disk state */      return GOTO.THIS.SCREEN;   end DIRECT.TO.DISK.SONG.DIRECTORY;   /* $Subtitle Activate Direct-to-Disk Track Display */   /* Routines to highlight buttons on top of motion panel */   /* routine highlight motion table (start,stop,cont,ff,rew) */   /* also highlights record button table                     */   Highlight.DTD.Motion.Table:proc swapable;      dcl info    fixed;      IF  (PLAY<>0)      AND (MOVE=0) THEN  INFO = INFO \ 1;           /* START BUTTON */      IF CONT<>0   THEN  INFO = INFO \ 4;           /* IF CONTINUE IS ACTIVE, LIGHT IT */      IF (MOVE<>0) THEN DO;                         /* FF OR REW */         IF MOVE.SPEED<0          THEN            INFO = INFO \ 8;           /* REWIND */         ELSE            INFO = INFO \ 16;          /* FAST FORWARD */      END;            call Highlight.Graphics.Button.Table(DTD.Motion.Table, info,  2, 0);      call Check.Next.Event;      info = 0;      IF ((RECD        )<>0)                        /* IF RECORDING, LIGHT RECORD BUTTON */      OR ((SMPTE.RECD&1)<>0)      THEN               INFO = INFO \ 1;           /* ALSO IF SMPTE FF/REW */      /* Also highlight the DTD record button if doing protocol */      /* DTD recording                                          */      if  (Armed.for.Protocol.DTD.Recording <> 0)      and (Protocol.Recording.State         >= 2)      then info = info \ 1;      call Highlight.Graphics.Button.Table(DTD.Record.Button, info,  3, 0);      call Check.Next.Event;   end Highlight.DTD.Motion.Table;   /* $page - handle motion control table mouse activity */   /* remember - perform highlighting quickly to provide snappy */   /* response to user                                          */   Handle.DTD.Motion.Table:proc swapable;      dcl tmp (1) fixed;      dcl time(1) fixed;      if Screen.Event.Info = S#MouseSelect      then do;         call Map.Graphics.Button.Table.Mouse.Press(DTD.Motion.Table, tmp);         do case (tmp(0));      /* branch on column */            do;               call Highlight.Graphics.Button.Table.Entry /* quickly turn on */               (DTD.Motion.Table, 0, 0, 1, 2, 0);         /* start button    */               call START.SEQUENCER;            end;            do;               call Highlight.Graphics.Button.Table       /* turn off all    */               (DTD.Motion.Table, 0,  2, 0);              /* lights quickly  */               call Highlight.Graphics.Button.Table       /* turn off all    */               (DTD.Record.Button,0,  3, 0);              /* lights quickly  */               if PLAY = 0                                /* if stopped now  */               then do;                                   /* then locate     */                  if DTD.Play.State <> 0                  /* stop DTD activity if any */                  then call STOP.DTD.PLAY.STATE;                  else if mark.button.disabled = 0                  then call SET.SEQUENCER.MARK.START.POINT(Mark.Button.Msb, Mark.Button.Lsb, 2);                  else call Play.Initialize;               end;               else call STOP.SEQUENCER;                  /* stop seq        */               call COPY32(loc(addr(Play.Time.Msb)),                            time);               disable.deposits = 1;               call Deposit.32Bit.Msec(DTD.Time.Display, time, Zero.Zero);               disable.deposits = 0;            end;            do;               call Highlight.Graphics.Button.Table.Entry /* quickly turn on */               (DTD.Motion.Table, 0, 0, 1, 2, 0);     /* start button    */               call CONTINUE.SEQUENCER;            end;            do;               call Highlight.Graphics.Button.Table.Entry /* quickly turn on */               (DTD.Motion.Table, 3, 0, 1, 2, 0);     /* rew   button    */               call REWIND.SEQUENCER;            end;            do;               call Highlight.Graphics.Button.Table.Entry /* quickly turn on */               (DTD.Motion.Table, 4, 0, 1, 2, 0);     /* for   button    */               call FAST.FORWARD.SEQUENCER;            end;         end;         /* provide speedy display by updating right here */         /* even if we will come back to update later     */         /* on                                            */         call Highlight.DTD.Motion.Table;         call DISPLAY.SEQUENCER.STATUS;      end;   end Handle.DTD.Motion.Table;   Handle.DTD.Record.Button:proc swapable;      dcl tmp(1) fixed;      if Screen.Event.Info = S#MouseSelect      then do;         call PROCESS.RECORD.BUTTON;         call Highlight.Graphics.Button.Table.Entry /* quickly turn on */         (DTD.Record.Button,   0, 0, 1, 3, 0);      /* recrd button    */         call Highlight.Graphics.Button.Table.Entry /* quickly turn on */         (DTD.Motion.Table, 0, 0, 1, 2, 0);         /* start button    */                  /* provide speedy display by updating right here */         /* even if we will come back to update later     */         /* on                                            */         /* if we turned on/off the correct ones up above */         /* then the following call will just check       */         /* all the other lights                          */         call Highlight.DTD.Motion.Table;         call DISPLAY.SEQUENCER.STATUS;      end;   end Handle.DTD.Record.Button;   /* $page - Track Directory Time Format Select Buttons */   /* Routine to set string in time format label: */   Set.Time.Format.Label.String:proc swapable;      dcl s1(12) fixed;      do case(GID(Saved.AEE.Time.Format));         call COPY.STRING('Seconds',s1);         call COPY.STRING('Beats',s1);         call COPY.STRING('Meas:Beats',s1);         call COPY.STRING('SMPTE',s1);         call COPY.STRING('Feet:Frames',s1);         call COPY.STRING('Mins:Seconds',s1);      end;      disable.deposits = 1;      call DEPOSIT.GRAPHICS.STRING(DTD.Format.String,s1);      disable.deposits = 0;   end Set.Time.Format.Label.String;   /* Handle mouse click on format select buttons */   Handle.DTD.Time.Format: proc swapable;      dcl tmp(1) fixed;      if Screen.Event.Info = S#MouseSelect      then do;         /* de-select time display when changing formats */         if Cur.Obj.Id = DTD.Time.Display         then call Select.New.Cur.Obj(DTD.Display.Area, -1, -1);         call Map.Graphics.Button.Table.Mouse.Press(DTD.Time.Format, tmp);         call PID(Saved.AEE.Time.Format, tmp(0));         call Highlight.Graphics.Button.Table(DTD.Time.Format, bits(GID(Saved.AEE.Time.Format)), 2, 0);         call Set.32Bit.MSEC.Display.Format(DTD.Time.Display,            GID(Saved.AEE.Time.Format)\O#MSEC.RealTime,            cf#time,cf#default,cf#default);         call Update.Object(DTD.Time.Display);         call Set.Time.Format.Label.String;      end;   end Handle.DTD.Time.Format;   /* $page - update real time display */   /* Important routine - set up Cursor.Scroll.Begin and Cursor.Scroll.End */   /* to reflect limits.                                                   */   UPDATE.DTD.PLAY.SCROLLING.BOUNDARIES: proc swapable;      dcl Aee.Time.Format  fixed;      dcl COMPUTE.TIME.DISPLAY.SCROLLING.BOUNDARIES proc(fixed,array,array) external;      AEE.Time.Format = GID(Saved.AEE.Time.Format);      call COMPUTE.TIME.DISPLAY.SCROLLING.BOUNDARIES(AEE.Time.Format,                                                      Cursor.Scroll.Begin,                                                     Cursor.Scroll.End);      new.ABLE.seq.info = new.ABLE.seq.info & (not 32);   end UPDATE.DTD.PLAY.SCROLLING.BOUNDARIES;   /* Set mark start button on/off as required: */   Update.DTD.Mark.Start.Info: proc swapable;      call Highlight.Graphics.Button.Table.Entry       (DTD.Mark.On.Off, 0, 0, Mark.Button.Disabled = 0, 2, 0);   end Update.DTD.Mark.Start.Info;   /* Take current sequencer time as mark start position */   Handle.Time.Take.Button: proc swapable;      dcl time(1) fixed;      if Screen.Event.Info = S#MouseSelect      then do;         call TAKE.SYSTEM.SEQUENCE.TIME(loc(addr(Mark.Button.Msb))); /* get synclav time */         mark.button.disabled = 0;                 /* turn on start pt      */         call Update.DTD.Mark.Start.Info;          /* show to user SNAPPILY */         call select.parameter(mark.l-par.l);      /* show to VK user too   */         call Map.Sequence.Time.To.Real.Time(loc(addr(Mark.Button.Msb)), time);         disable.deposits = 1;         call Deposit.32Bit.Msec(DTD.Time.Display, time, Zero.Zero);         disable.deposits = 0;      end;   end Handle.Time.Take.Button;   /* Handle mouse select or deposit of time display */   Handle.DTD.Time.Display: proc swapable;      dcl (msw,lsw)     fixed;      if Screen.Event.Info = S#Deposit      then do;         call fetch.32bit.msec(DTD.Time.Display, loc(addr(msw)));         if (msw = 0) and (lsw = zero.time) then lsw = 0;         mark.button.msb      = msw;         mark.button.lsb      = lsw;         mark.button.disabled = 0;         call Update.DTD.Mark.Start.Info;      /* show to user SNAPPILY */         call select.parameter(mark.l-par.l);  /* show to VK user too   */         call Select.New.Cur.Obj(DTD.Display.Area, -1, -1);         call Update.Object(DTD.Time.Display);      end;   end Handle.DTD.Time.Display;   /* mouse select on mark on/off button: */   Handle.DTD.Mark.On.Off: proc swapable;      if Screen.Event.Info = S#MouseSelect      then do;         mark.button.disabled = mark.button.disabled xor 1;         call Update.DTD.Mark.Start.Info;      /* show to user SNAPPILY */         call select.parameter(mark.l-par.l);  /* and show to VK users */      end;   end Handle.DTD.Mark.On.Off;   Handle.Off.In.Out.Bounce: proc swapable;      dcl tmp(1) fixed;      if Screen.Event.Info = S#MouseSelect      and (DTD.MAX.SECS      <> 0            )      then do;			if ((simulate.dtd == 0) && (lod.running == 0))         then call no.direct.to.disk;         else do;            call Map.Graphics.Button.Table.Mouse.Press(DTD.Off.In.Out.Bounce, tmp);                        write(mam) = Scsi.Ptr;     /* send new xfer code to LOD.  It */            write(mdi) = 40;           /* will generate an error message */            write(md ) = tmp(0);       /* and send us an init record     */								if (!simulate.dtd) Send.To.Lod(144,4);   /* if hardware is not available   */            call Highlight.Graphics.Button.Table(DTD.Off.In.Out.Bounce, DTD.Xfer.Mode&15, 2, 0);            call Highlight.Graphics.Button.Table(DTD.Dsp.In, shr(DTD.Xfer.Mode,4), 2, 0);         end;      end;   end Handle.Off.In.Out.Bounce;   Handle.Dsp.In: proc swapable;      dcl tmp(1) fixed;      if Screen.Event.Info = S#MouseSelect      and (DTD.MAX.SECS      <> 0            )      then do;			if ((simulate.dtd == 0) && (lod.running == 0))         then call no.direct.to.disk;         else do;            write(mam) = Scsi.Ptr;     /* send new xfer code to LOD.  It */            write(mdi) = 40;           /* will generate an error message */            write(md ) = 4;            /* and send us an init record     */            if (!simulate.dtd) Send.To.Lod(144,4);   /* if hardware is not available   */            call Highlight.Graphics.Button.Table(DTD.Off.In.Out.Bounce, DTD.Xfer.Mode&15, 2, 0);            call Highlight.Graphics.Button.Table(DTD.Dsp.In, shr(DTD.Xfer.Mode,4), 2, 0);         end;      end;   end Handle.Dsp.In;   /* Handle here any GPI button presses that cannot be handled         */   /* by the main loop:                                                 */   /* $page = check dtd remote control inputs for P Screen */   /* This routine is called to process input functions activated */   /* by the remote control interface.  Those input functions     */   /* that must be processed by the P screen software are         */   /* processed here                                              */   /* Note: we are only called from the P screen main loop        */   Check.P.Screen.Remote.Control.Inputs  :proc  PUBLIC swapable;      dcl RemoteControlInputUpdates   fixed external; /* bits for input updates  */      dcl RemoteControlArmUpdates     fixed external; /* bits for arm   updates  */      dcl NewModes     fixed;      dcl NewStatuses  fixed;      /* Update tally lines and screen displays for */      /* the new changes                            */      NewModes                  = RemoteControlInputUpdates;      NewStatuses               = RemoteControlArmUpdates;      RemoteControlInputUpdates = 0;      RemoteControlArmUpdates   = 0;      call Update.AEE.Track.Status.Displays.And.Tallies (NewModes, NewStatuses);   end Check.P.Screen.Remote.Control.Inputs;   /* $page - Direct to disk Track Display */   DIRECT.TO.DISK.TRACK.DISPLAY:  PROC(arg) PUBLIC SWAPABLE;  /* call to activate DTD track display */      dcl arg     fixed;                    /* reserved for future use */      dcl time(1) fixed;      dcl new (1) fixed;      dcl newtrk  fixed;      dcl pplay   fixed;      dcl P.Screen.Active fixed external;      if inc.dtd=0 then do;         call feature.not.available;         return (-1);      end;     // At one point we must have retried our search for a DTD when going to the Track Display screen     // Don't know when this was done     /*dtd.retries=0;*/                  /* if we had disconnected earlier, clear counter so we can try again */      call STR32(0,   0, Screen.Begin       );      call STR32(0,   0, Cursor.Begin       );      call STR32(-1, -1, Screen.End         );      call STR32(-1, -1, Cursor.End         );      call STR32(0,   0, Screen.Scroll.Begin);      call STR32(0,   0, Cursor.Scroll.Begin);      call STR32(-1, -1, Screen.Scroll.End  );      call STR32(-1, -1, Cursor.Scroll.End  );      call DISP.MULTI.TRACK.RECORD.SCREEN;  /* draw the multi-track display screen */      /* highlight initial values here */      call Highlight.DTD.Motion.Table;      call Highlight.Graphics.Button.Table(DTD.Time.Format, bits(GID(Saved.AEE.Time.Format)), 2, 0);      call Highlight.Graphics.Button.Table(DTD.Off.In.Out.Bounce, DTD.Xfer.Mode&15, 2, 0);      call Highlight.Graphics.Button.Table(DTD.Dsp.In, shr(DTD.Xfer.Mode,4), 2, 0);      call Set.Time.Format.Label.String;      call Update.DTD.Mark.Start.Info;      disable;         time(0)=play.time.msb;         time(1)=play.time.lsb;      enable;      disable.deposits = 1;      call Deposit.32Bit.Msec(DTD.Time.Display, time, Zero.Zero);      disable.deposits = 0;      call Update.DTD.Play.Scrolling.Boundaries; /* now advance CURSOR.SCROLL.BEGIN & CURSOR.SCROLL.END */      /* initialize remote control panel: */      call Initialize.Remote.Control.Items;      EXIT.MY.SCREEN   = 0;      GOTO.THIS.SCREEN = 0;      call ENABLE_SEVERAL_GETS (get.in.char,       /* get in.chars      */                                get.dtd.info,      /* DTD info          */                                get.ertyp,         /* errors            */                                get.play.scrolling);      call ENABLE_SEVERAL_GETS (Get.New.Seq.Info,  /* seq info          */                                Get.Screen.Event,  /* smgr items        */                                Get.Program.Exit,  /* break, enter      */                                Get.Arrow.Key   ); /* arrows            */      /* turn on tally output lines when entering screen */      P.Screen.Active =  1;      /* indicate screen is active now        */      call Update.AEE.Track.Status.Displays.And.Tallies (0, 0);      do while Exit.My.Screen = 0;         if Screen.Changed <> 0         then call Update.Screen;        /* check for smgr updates    */         newtrk = Curr.fld               /* sample field, track, ID   */                \ shl(DTD.Track#, 8)                 \ shl(Cur.Obj.Id <> DTD.Time.Display, 15);         /* detect change in highlighting */         if newtrk <> Previous.Highlight.Code  /* change in row, col, Id */         then call Change.DTD.Highlighting(0); /* re-highlight           */         else call Pos.DTD.Cursor.For.Input;   /* else just pos. cursor  */         call Get.Next.Screen.Event;         if (Screen.Event.Code = Get.New.Seq.Info)         then do;            if ((Screen.Event.Info&128)<>0) then do;  /* Motion change */               call Highlight.DTD.Motion.Table;               /* Detect end of sequencer motion (ie rewind to 0, or stop, */               /* etc.   Force an update of the time display when the      */               /* sequencer stops                                          */               if  (pplay <> 0)     /* if we were playing before ...       */               and (play   = 0)     /* but are no longer playing,  update  */               then Screen.Event.Info = Screen.Event.Info \ 32;               pplay = play;            end;            if (Screen.Event.Info&32) <> 0 then do;   /* cursor scroll */               /* sample actual play time */               disable;                  new (0) = play.time.msb;                  new (1) = play.time.lsb;               enable;               if (play=0) then do;      /* Sequencer Stopped - use it */                  call COPY32(new, time);               end;               else if move>=0 then do;  /* Play or FF                 */                  time(0)=Cursor.Scroll.End(0); /* use cursor end for best    */                  time(1)=Cursor.Scroll.End(1); /* display                    */                  if COM32(new,time) = lw#ilt   /* but check for loop  */                  then call COPY32(new, time);  /* or preset.play.time */               end;               else do;                  /* Rewind */                  time(0)=Cursor.Scroll.Begin(0);                   time(1)=Cursor.Scroll.Begin(1);               end;               call Update.DTD.Play.Scrolling.Boundaries; /* now advance CURSOR.SCROLL.BEGIN & CURSOR.SCROLL.END */               if Cur.Obj.Id <> DTD.Time.Display               then do;                  disable.deposits = 1;                  call Deposit.32Bit.Msec(DTD.Time.Display, time, Zero.Zero);                  disable.deposits = 0;               end;            end;            if ((Screen.Event.Info&1024)<>0)     /* new control inputs from d34/d35 remote control interface */            then do;               call Check.P.Screen.Remote.Control.Inputs;            end;            if ((Screen.Event.Info&(8\128))<>0)   /* will see motion change */            then do;                              /* on mark on/off         */               call Update.DTD.Mark.Start.Info;            end;         end;         else if (Screen.Event.Code = Get.DTD.Info)         then do;            /* Update DDT area after possible DDT state change: */            if (Screen.Event.Info&1)<>0             then do;               call Highlight.Graphics.Button.Table(DTD.Off.In.Out.Bounce, DTD.Xfer.Mode&15, 2, 0);               call Highlight.Graphics.Button.Table(DTD.Dsp.In, shr(DTD.Xfer.Mode,4), 2, 0);            end;            /* Update track display when new info is received:  */            if (Screen.Event.Info&7)<>0            then call UPDATE.MULTI.TRACK.REC.DISPLAY;  /* updates Direct-to-Disk Track Display */            /* Highlight the P page RECORD button when doing      */            /* protocol DTD recording:                            */            if (Screen.Event.Info&16)<>0            then call Highlight.DTD.Motion.Table;         end;         else if  (Screen.Event.Code = Get.In.Char  )         or       (Screen.Event.Code = Get.Arrow.Key)         then do;            if Cur.Obj.Id = DTD.Display.Area             then call MULTI.TRACK.REC.INPUT(in.chin,Screen.Event.Info);  /* Track Display input handler */         end;         else if (Screen.Event.Code = Get.Program.Exit)         then call RETURN.TO.PREV.STATE;         else if (Screen.Event.Code = Get.Screen.Event)         then do;                        if Screen.Event.Id = DTD.Display.Area then do;               if  (Screen.Event.Info = S#MouseSelect  )               or  (Screen.Event.Info = S#MouseActivate)               then do;                  if  (Screen.Event.Info = S#MouseSelect)  /* if prior area */                  and (Prev.Obj.Id = DTD.Time.Display   )  /* was time disp */                  then do;                     call Update.Object(DTD.Time.Display); /* un-highlight  */                  end;                  call MULTI.TRACK.REC.MOUSE.POS(mouse(press.x),mouse(press.y),abs(Screen.Event.Obj.Info));               end;            end;            else if Screen.Event.Id = DTD.Record.Button then do;               call Handle.DTD.Record.Button;            end;            else if Screen.Event.Id = DTD.Motion.Table then do;               call Handle.DTD.Motion.Table;            end;            else if Screen.Event.Id = DTD.Time.Format then do;               call Handle.DTD.Time.Format;            end;            else if Screen.Event.Id = DTD.Time.Take.Button then do;               call Handle.Time.Take.Button;            end;            else if Screen.Event.Id = DTD.Time.Display then do;               call Handle.DTD.Time.Display;            end;            else if Screen.Event.Id = DTD.Mark.On.Off then do;               call Handle.DTD.Mark.On.Off;            end;            else if Screen.Event.Id = DTD.Off.In.Out.Bounce then do;               call Handle.Off.In.Out.Bounce;            end;            else if Screen.Event.Id = DTD.Dsp.In then do;               call Handle.Dsp.In;            end;            else if Screen.Event.Id = DTD.Mouse.Hole then do;               if Screen.Event.Info = S#MouseSelect               then call RETURN.TO.PREV.STATE;            end;         end;         else if Screen.Event.Code = Get.Ertyp         then do;            if dtd.prompt=0             then do;               call Set.Term.Attr(Attr#Normal);               call Handle.System.Error.Codes(Screen.Event.Info);            end;				else				{					Chill.Out.And.Run.Syn();			  	// keep mac happy while we wait for user to finish entering the prompt					new.ABLE.ertyp = Screen.Event.Info;  	/* else save error message until prompt goes away */				}         end;      end;      P.Screen.Active = 0;      /* indicate screen is not active now     */      /* turn off tally output lines when leaving screen */      call Update.AEE.Track.Status.Displays.And.Tallies (0, 0);      call DISABLE_SEVERAL_GETS (get.in.char,       /* get in.chars      */                                 get.dtd.info,      /* DTD info          */                                 get.ertyp,         /* errors            */                                 get.play.scrolling);      call DISABLE_SEVERAL_GETS (Get.New.Seq.Info,  /* seq info          */                                 Get.Screen.Event,  /* smgr items        */                                 Get.Program.Exit,  /* break, enter      */                                 Get.Arrow.Key   ); /* arrows            */      EXIT.MY.SCREEN      =  0;     /* clear flag after loop */      lod.recd.tracks      = 0;     /* disable dtd recording when leaving screen */      if Lod.Punch.In.Tracks <> 0 then do; /* perform graceful punch      */         Lod.Punch.In.Tracks  = 0;         /* when leaving screen         */         new.motion           = 1;      end;      store.dtd.info        =0;     /* assume not in direct-to-disk state */      safe.ready.toggles   = 0;     /* clear bits when entering screen    */      if (recd<>0)&(recd.trk=0)     /* if lod recording                   */      then call stop.recd.move.play;      call compute.active.trks;      call display.track.buttons;      call display.sequencer.status;      new.motion=1;      return GOTO.THIS.SCREEN;   end DIRECT.TO.DISK.TRACK.DISPLAY;end DTDMOD;