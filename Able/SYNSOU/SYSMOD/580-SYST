/* 580-SYST  $TITLE  System Commands Screen Routines *//*  08/16/93 - PF  - Added disp.multi.errs  12/02/88 - TSS - Made changes to fix diagnostic bugs  10/15/88 - TSS - Fixed bug in E-page menu & swapped menu items around  09/27/88 - TS/SGS - Added diagnostics program   5/25/88 - LSS - code to deal with Macintosh ASC.SCREEN.REFRESH   7/17/87 - MWH - Update all to support max 4 poly bins, 512mb/bin   7/11/86 - BSW added plotting of mouse hole   5/22/86 - MPB - Input Command Structure Added   5/19/86 - eg - made procedures and some variables public.   5/15/86 - "official" creation of release-M modules*/dcl (#ypos,#lypos) fixed;/* number of commands on menu */dcl system.commands lit '(4+(inc.mono\inc.poly))';POS.SYSTEM.COMMAND.CURSOR:  proc swapable; /* positions cursor on system command display */   dcl (i,j,x,y) fixed;   do i=0 to 1;      if (i<>0) or (#ypos<>#lypos) then do;         call cpos(16+#lypos,3);         if i=0 then do j=1 to 17; call pc(sp); end;         else do;            call ps('Now Selected ==> ');            call REVERSE.VIDEO(1); /* turn on reverse video */         end;         call pc(asc.a+#lypos); call pc(dot); call pc(sp); call pc(sp);         do case #lypos;            call ps('Return to Previous Screen');            do;               call ps('Change Terminal Beep Mode:  ');               if beep.status<>0 then call ps('On '); else call ps('Off');            end;            do;               call ps('Change Multichannel Error Message Mode:  ');               if disp.multi.errs<>0 then call ps('On '); else call ps('Off');            end;            if inc.mono<>0 then do; /* either INC.MONO or INC.POLY but not both */               call ps('Recorder Overlay Mode:  ');               if overlay.status<>0 then call ps('On '); else call ps('Off');            end;            else if (inc.poly<>0)            then call ps('Erase All Sound Files from Poly Memory');            do;               call ps('Voice Diagnostics Test:   ');               call REVERSE.VIDEO(0);  /* erase line first */               do j=screen.x to 70; call pc(sp); end;               call cpos(16+#lypos,50);               if i=1 then call REVERSE.VIDEO(1); /* restore reverse video */               if diagnostics.enabled<>0 then do;                  call ps('Channel ');                  call pnum(XXXXCH,0);               end;               else do;                  call ps('Off');               end;            end;         end;         #lypos=#ypos;      end;   end;   if vt100=0 then call cpos(16+#lypos,19);   else            call REVERSE.VIDEO(0); /* turn off reverse video */end POS.SYSTEM.COMMAND.CURSOR;/* $SUBTITLE  Routine to Draw Frame of System Commands Screen */REFRESH.DIAGNOSTICS.CHANNEL: proc swapable;   call cpos(20,50);      /* position cursor so we only have to update channel # */   if #lypos=4 then call REVERSE.VIDEO(1); /* "Diagnostics" line currently selected */   if diagnostics.enabled<>0 then do;      call ps('Channel ');      call pnum(XXXXCH,0);   end;   else call ps('Off');   call REVERSE.VIDEO(0);   call ps('        ');end REFRESH.DIAGNOSTICS.CHANNEL;DRAW.SYSTEM.SCREEN:  proc swapable; /* draws description of special system commands */   DCL (I) FIXED;   call clear.term;   call PRINT.SCREEN.FRAME(21,'SYSTEM COMMANDS');   call cpos(1,3);   call ps('Use arrow keys to move cursor.  ');   call PRINT.EXIT.SCREEN.PROMPT;   if d44_present        /* if mouse present draw exit icon */   then call plot.mouse.hole(mouse.hole.lowerx,mouse.hole.lowery);   call cpos(2,0);   if vt100<>0 then do;      call CH.SET(alt); call DRAW.TEE(t.left);   end;   else call pc("174");   call DRAW.HOR(78);   if vt100<>0 then do; call DRAW.TEE(t.right); call CH.SET(norm); end;   call cpos( 4, 3); call ps('Several other modules are available from the Real-Time Performance system.');   call cpos( 6,18); call ps('Press  <BREAK>  to enter Monitor.');   do i=0 to vt100*2;      call cpos(7+i,25+vt100);      do case i;         do;            if vt100<>0 then call ps('<PF1>  '); else call ps('<ESC> 1 ');            call ps(' to enter Reverse Compiler.');         end;         if vt100<>0 then call ps('<PF3>   to enter Music Printing.');         if vt100<>0 then call ps('<PF4>   to enter SFM.');      end;   end;   call cpos(11,13); call ps('These keys are also available on the Main Menu.');       call cpos(13,15); call ps('Other system commands are available from this screen.');   call cpos(14,15); call ps('Press  <RETURN>  to activate selected function.');   do i=0 to (system.commands-1); /* list the items available here */      call cpos(16+i,20);      call pc(ASC.A+i); call pc(DOT); call pc(SP); call pc(SP);      do case i;         call ps('Return to Previous Screen');         do;            call ps('Change Terminal Beep Mode:  ');            if beep.status<>0 then call ps('On '); else call ps('Off');         end;         do;            call ps('Change Multichannel Error Message Mode:  ');            if disp.multi.errs<>0 then call ps('On '); else call ps('Off');         end;         if inc.mono<>0 then do;            call ps('Recorder Overlay Mode:  ');            if overlay.status<>0 then call ps('On '); else call ps('Off');         end;         else if (inc.poly<>0)         then call ps('Erase All Sound Files from Poly Memory');         do;            call ps('Voice Diagnostics Test:   ');            if diagnostics.enabled<>0 then do;               call ps('Channel ');               call pnum(XXXXCH,0);            end;            else call ps('Off');         end;      end;   end;   call PRINT.CCAT; /* print current catalog name */   call POS.SYSTEM.COMMAND.CURSOR;end DRAW.SYSTEM.SCREEN;/* $SUBTITLE */ZAP.ACTIVE.NOTES: proc SWAPABLE;   dcl i fixed;   do while (NOTELIST<>0)         /* wait for all channels to get freed up */   or  (SYSTEM.VOICES<>(core(fr1.ptr)+core(fr2.ptr)                       +core(fp0.ptr)+core(fp1.ptr)                       +core(fp2.ptr)+core(fp3.ptr)+inc.mono));      WRITE(MAM)=CLAV.PTR;                     /* SET UP PTR TO KEY STATE XMEM ARRAY */      DO I=0 TO NUM.KEYS-1;                    /* LOOP OVER ALL THE KEYS */         WRITE(MDI)=READ(MD) AND (NOT ACTIVE); /* AND TURN OFF THE ACTIVE BIT */      END;      call STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS; /* just turn everything off */      call CHILL.OUT.AND.RUN.SYN();   end;end ZAP.ACTIVE.NOTES;/* $SUBTITLE Routine to Change Voice Diagnostics Parameter(s) */DCL (PREVXXXXCH) FIXED;    /* PREVIOUS CHANNEL # FOR XXXX PROGRAM              */HANDLE.DIAGNOSTICS.CHANGE: proc (direction,ok.to.print) swapable;   dcl direction   fixed; /* -n= decrement channel num by n channels */                          /* +n= increment channel num by n channels */                          /*  0= turn off diagnostics  */   dcl ok.to.print fixed; /* 1 if ok to print to terminal, else 0 */   if (direction=0) then do;      diagnostics.enabled=0;                       /* turn off test */      XXXXCH = 0;      PrevXXXXCH= -1;                              /* initialize prev channel */   end;   else do;      if (diagnostics.enabled<>0) then do;         /* we were testing a voice */         XXXXCH = XXXXCH+direction;                /* incr/decr to next channel   */         if (XXXXCH > (MAX.DIAGNOSE.VOICES-1)) or (XXXXCH < 0)         then do;            diagnostics.enabled=0;                 /* turn off test */            XXXXCH = 0;            PrevXXXXCH= -1;                        /* initialize prev channel */         end;      end;      else do;                                     /* were not testing any voices */         diagnostics.enabled = 1;                  /* turn on test */         if direction>0          then XXXXCH = 0;                          /* first voice */         else XXXXCH = MAX.DIAGNOSE.VOICES-1;      /* last voice */         PrevXXXXCH= -1;                           /* initialize prev channel */      end;   end;   /* Do this to make sure all voices get put back */   /* on stack before we take any off or put any on */   call ZAP.ACTIVE.NOTES;   if diagnostics.enabled=1 then do;      /* Find out what bin the sound files */      /* for the current keyboard timbre   */      /* are in. Compare to requested bin  */      if ((POLYNUMVS(0) > 0)      &&  (POLYNUMVS(1) > 0)      &&  (shr(PrevXXXXCH,5)<>shr(XXXXCH,5))) then do;         /* If cur bin is different than the requested bin, */         /* put kbd timbre's sound files in requested bin   */         if ok.to.print<>0 then do;            call reverse.video(1);            call DRAW.MESSAGE('Moving sound files to new bin. Please wait....');         end;         PUSH.SYSTEM.PDL;           /* Save un-needed stack out to xmem */            call PS.DEALLOCATE.ALL; /* erase all poly files from RAM */            call ALLOC.AND.COMPUTE; /* reload into correct bin */         POP.SYSTEM.PDL;            /* restore stack to prior state */         if ok.to.print<>0 then do;            call reverse.video(0);            call ERASE.MESSAGE;         end;         call SELECT.PARAMETER(TBASE.L-PAR.L); /* redisplay on clavier after */                                               /* "Loading Sound File..." message */      end;      PrevXXXXCH = XXXXCH;       /* keep previous value up to date */   end;   call ZAP.ACTIVE.NOTES;        /* make double sure all voices have been returned to free channel lists */   call Init.Synths; /* rebuild free channel list, with either one voice activated */                     /* or all activated, depending on diagnostics.enabled */end HANDLE.DIAGNOSTICS.CHANGE;/* $SUBTITLE */DISPLAY.DIAGNOSTICS.MESSAGE:  proc(message) swapable;  /* displays messages related to run diagnostics command */   dcl message  fixed;  /* message number */   call reverse.video(1);   do case message;      call draw.message('Incorrect password.  Command ignored.'); /* 0: user did not type okay */      call draw.message('Diagnostics test now running.');/* 1: run test */      call draw.message('Diagnostics test now halted.'); /* 2: halt test */      call draw.message('No voices to test.');           /* 3: no voices */   end;   call reverse.video(0);   call PRINT.CCAT;end DISPLAY.DIAGNOSTICS.MESSAGE;JOG.DIAGNOSTICS.CHAN: proc (our.char, up.char, down.char, off.char) swapable;   dcl our.char  fixed; /* the char actually typed          */   dcl up.char   fixed; /* char which means jog up by 1     */   dcl down.char fixed; /* char which means jog down by 1   */   dcl off.char  fixed; /* char which turns diagnostics off */   if (MAX.DIAGNOSE.VOICES<>0) then do;      if (our.char = up.char) or (up.char = (-1))      then call HANDLE.DIAGNOSTICS.CHANGE(+1,1);        else if (our.char = down.char) or (down.char = (-1))      then call HANDLE.DIAGNOSTICS.CHANGE(-1,1);      else if (our.char = off.char) or (off.char = (-1))       then call HANDLE.DIAGNOSTICS.CHANGE(0,1);      if diagnostics.enabled<>0      then call DISPLAY.DIAGNOSTICS.MESSAGE(1);      else call DISPLAY.DIAGNOSTICS.MESSAGE(2);      call SELECT.PARAMETER(TBASE.L-PAR.L);          /* display on clavier, too */      new.prm.info = new.prm.info & (not 16);        /* clear bit we just set */   end;   else call DISPLAY.DIAGNOSTICS.MESSAGE(3);end JOG.DIAGNOSTICS.CHAN;/* $SUBTITLE  Routine to Handle Chars on System Commands Menu */CHANGE.DIAGNOSTICS.CHAN: proc public swapable;   dcl direction      fixed;   if  (diagnostics.enabled <> 0)   and (PrevXXXXCH <> XXXXCH) then do;      direction = XXXXCH - PrevXXXXCH;      XXXXCH = PrevXXXXCH;      /* do this so following proc does correct thing */      call HANDLE.DIAGNOSTICS.CHANGE(direction,0);   end;end CHANGE.DIAGNOSTICS.CHAN;SET.DIAGNOSTICS.CHAN: proc swapable;   dcl direction fixed;   if PrevXXXXCH <> XXXXCH then do;      direction = XXXXCH - PrevXXXXCH;      XXXXCH = PrevXXXXCH;      /* do this so following proc does correct thing */      call HANDLE.DIAGNOSTICS.CHANGE(direction,1);      call REFRESH.DIAGNOSTICS.CHANNEL;      new.prm.info = new.prm.info & (not 16);  /* clear bit to avoid infinite update loop */      if diagnostics.enabled<>0      then call DISPLAY.DIAGNOSTICS.MESSAGE(1);      else call DISPLAY.DIAGNOSTICS.MESSAGE(2);   end;end SET.DIAGNOSTICS.CHAN;/* $SUBTITLE  Routine to Handle Chars on System Commands Menu */SYSTEM.COMMAND.INPUT:  proc(in.cmd,in.arg) swapable; /* Process Input Chars for Main Menu */   dcl (in.cmd,in.arg) fixed;   dcl ch              fixed;   dcl waiting.for.OK  fixed static;  /* if waiting for OK in dialog */   ERASE.PROMPT: proc fixed; /* called to erase prompt for POLY ERASE */      dcl i fixed;      if waiting.for.OK<>0 then do;         waiting.for.OK=0;                  /* cancel OK dialog */         call cpos(21,3);         do i = 1 to 59; call pc(32); end;      end;   end ERASE.PROMPT;   DISPLAY.POLY.MEMORY.MESSAGE:  proc(message) fixed;  /* displays messages related to erase poly memory command */      dcl message  fixed;  /* message number */      call reverse.video(1);      if message=0           /* 0: user did not type okay */      then call draw.message('Incorrect password.  Command ignored.');      else call draw.message('Poly Memory has been erased.'); /* 1: poly memory erased */      call reverse.video(0);   end DISPLAY.POLY.MEMORY.MESSAGE;   do case in.cmd;      do;  /* character input */         ch = in.arg;         if (ch>=lower.a) and (ch<=lower.z) then ch=ch-"40"; /* convert to uppercase */         if ch=asc.call.terminate then do;    /* break received */            call.terminate=1;                        call LEAVE.SYNCLAVIER.PROGRAM;   /* try to terminate */            call.terminate=0;            return;         end;         else if ch=asc.screen.refresh then do; /* refresh from Termulator */            call reboot.terminal; /* reinits the terminal and mouse */            call RETURN.TO.PREV.STATE; /* ESC:  done with screen */         end;         else if  (ch>=asc.call.convert)         and (ch<=asc.call.convert+9)         then do;            call.convert=1;                           cnv.sta = ch-asc.call.convert;             call LEAVE.SYNCLAVIER.PROGRAM;   /* try to terminate */            call.convert=0;            return;         end;         if (ch<>esc) and (err.displayed<>0) then do;            call remove.err;            call PRINT.CCAT;                /* reprint current cat name */         end;         if (ch>=asc.a) and (ch<=asc.z) then do;  /* simulate normal selection */            if token(0)<2 then do;               call pbyte(token,token(0),ch);               token(0)=token(0)+1;            end;         end;         if (token(0)=1) and (((ch>=asc.a) and (ch<=asc.e)) or (ch=asc.p)) then do;             call ERASE.PROMPT;             /* cancel any OK dialog */            token(0)=0;            if ch=asc.p then do;                  /* print hardcopy of screen */               if D40_PRESENT<>0                  /* if device available */               then call SCREEN_DUMP;                            else call no.printer;               call POS.SYSTEM.COMMAND.CURSOR;               return;            end;            else do;               #ypos=ch-asc.a;                 /* compute which item is to be selected */               if ch<>asc.e then ch=cret;      /* map to <RETURN>, if not diagnostics test */            end;         end;         else if (ch=del) or (ch="32") then do;      /* DELETE or CTRL-Z: Erase last char */            if token(0)=0 then do;               call ERASE.PROMPT;                    /* cancel any OK dialoog */            end;            if token(0)<>0 then do;                  /* chars to delete */               token(0)=token(0)-1;               call pc(bs); call pc(sp); call pc(bs);            end;         end;         if ch=cret then do;                      /* go to selected screen */            if #ypos<system.commands            then do case #ypos;               call RETURN.TO.PREV.STATE;         /* A:  return to previous screen */               do;                                /* B:  toggle beep mode */                  beep.status=beep.status xor 1;                  call POS.SYSTEM.COMMAND.CURSOR;               end;               do;                                /* C:  toggle multichannel err msgs mode */                  disp.multi.errs=disp.multi.errs xor 1;                  call POS.SYSTEM.COMMAND.CURSOR;               end;               if inc.mono<>0 then do;            /* D:  either toggle overlay mode */                  overlay.status=overlay.status xor 1;                  call POS.SYSTEM.COMMAND.CURSOR;               end;               else if (inc.poly<>0) then do;     /* D:  or erase all sounds from polymem */                  call POS.SYSTEM.COMMAND.CURSOR;                  if (com16(0,polyamount)<>lw#ieq) then do;                     if waiting.for.OK=0 then do;                        call cpos(21,3);                        call ps('Type OK and press <RETURN> to erase all of Poly Memory ->');                        waiting.for.OK=1;                     end;                     else do;                        call ERASE.PROMPT;                        if (token(0)=2) and (byte(token,0)=asc.o) /* see if user typed OK */                        and (byte(token,1)=asc.k) then do;        /* and erase poly memory if so */                           if com16(0,polyamount)<>lw#ieq                           then call PS.DEALLOCATE.ALL;                           call DISPLAY.POLY.MEMORY.MESSAGE(1); /* indicate that it has been erased */                        end;                        else call DISPLAY.POLY.MEMORY.MESSAGE(0);                        token(0)=0;                        call POS.SYSTEM.COMMAND.CURSOR;                     end;                  end;               end;               do;                                /* E: change voice diagnostics mode */                  call JOG.DIAGNOSTICS.CHAN(ch,-1,0,0); /* increment channel # */                  call REFRESH.DIAGNOSTICS.CHANNEL;               end;            end;            else #ypos=#lypos;         end;         else if ch=esc then do;            call ERASE.PROMPT;                    /* cancel any OK dialoog */            call RETURN.TO.PREV.STATE; /* ESC:  done with screen */         end;         else if (ch=u.arr) or (ch=d.arr) then do;  /* try to step up a line */            call ERASE.PROMPT;                      /* cancel any OK dialoog */            if ch=u.arr then do;                    /* if up arrow */               if #ypos<>0               then #ypos=#ypos-1;            end;            else do;                                /* if down arrow */               if #ypos<(system.commands-1)               then #ypos=#ypos+1;            end;            call POS.SYSTEM.COMMAND.CURSOR;         end;         else if ((ch=l.arr) or (ch=r.arr) or (ch=del))         and (#ypos=4) then do;            call JOG.DIAGNOSTICS.CHAN(ch,r.arr,l.arr,del);            call REFRESH.DIAGNOSTICS.CHANNEL;         end;         else if (#ypos=1) or (#ypos=2) or ((inc.mono<>0)&(#ypos=3)) or (#ypos=4)         then do;   /* toggle the parm for any char when on these three lines */            if #ypos = 1            then beep.status=beep.status xor 1;            if #ypos = 2            then disp.multi.errs=disp.multi.errs xor 1;            else if ((inc.mono<>0)&(#ypos=3))            then overlay.status=overlay.status xor 1;            else if (#ypos = 4)                        /* any key other than arrow */            then call JOG.DIAGNOSTICS.CHAN(ch,-1,0,0); /* or delete increments diag chan */            call POS.SYSTEM.COMMAND.CURSOR;         end;         else if waiting.for.OK<>0 then do;   /* print letters typed */            call cpos(21,60);            call ps(token);         end;         else do;            call ERASE.PROMPT;            token(0)=0;                       /* reinitialize token value */            call POS.SYSTEM.COMMAND.CURSOR;         end;      end;   end;end SYSTEM.COMMAND.INPUT;/* $Subtitle System Command Mouse Mapping 580-SYST */SYSTEM.COMMAND.MOUSE.POS:  proc(x,y) swapable;     /* System Commands Help Screen Mouse positioner  */   dcl (x,y) fixed;  /* mouse position in row/col coordinates */   if mouse.hole(x,y) then do;                 /* if mouse scurries to mouse hole */      call SYSTEM.COMMAND.INPUT(in.chin,asc.a);/* return to previous screen */      return;   end;      x = convert.mouse.x(x);      /* convert to screen coordinates */   y = convert.mouse.y(y);   if (y = 16) & (x > 19) & (x < 50)           /* return to previous screen */   then call system.command.input(in.chin,asc.a);      else if (y = 17) & (x > 19) & (x < 56)      /* change terminal beep mode */   then call system.command.input(in.chin,asc.b);   else if (y = 18) & (x > 19) & (x < 65)      /* change multichannel eroor message mode */   then call system.command.input(in.chin,asc.c);   else if (y = 19) & (x > 19) then do;      if (inc.mono & (x < 52))                 /* toggle overlay mode */      or (inc.poly & (x < 63))                 /* erase poly memory */      then call system.command.input(in.chin,asc.d);   end;   else if (y = 20) & (x > 19) & (x < 53)      /* change voice diagnostic mode */   then call system.command.input(in.chin,asc.e);   else if ((y >= 6) and (y <= 9))             /* BREAK and PF keys */   and  ((x >= 27) and  (x < 33)) then do;      if y=6 then do;                          /* if BREAK */         do x=0 to 60; write(3)=0; end;        /* WAIT FOR BREAK TO GO AWAY */         call.terminate=1;                     /* STOP */      end;      else do;                                 /* if PF1, PF3, or PF4 */         if y=7         then cnv.sta=y-6;                     /* convert from PF1 key selection */         else cnv.sta=y-5;                     /* convert from PF3 or PF4 key selection */         call mouse.switch(0);                 /* shut off mouse */         call.convert=1;                       /* RESET ESC.RCVD IN CASE WE BOMB */      end;   end;end SYSTEM.COMMAND.MOUSE.POS;