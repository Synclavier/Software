/* MATHTEST   $TITLE  Checks out MATHMOD routines *//*   Modified:   11 Jun 1987    MWH   Author*/insert ':SYNMODS:MATHDCL';dcl i fixed;dcl (i32,j32) (1) fixed;out:proc;   dcl x fixed;   print 'The octal value of i32 is: ',octal(i32(lw#msb)),' ',octal(i32(lw#lsb)),;   print ' j32 is: ',octal(j32(lw#msb)),' ',octal(j32(lw#lsb));   if x = 0 then do;      print 'Press return to continue (non-zero to stop waiting)...',;      input x;   end;   print '';end out;   com_out:proc (i,str);   dcl i fixed;   dcl str fixed array;   if i = lw#ilt   then print string(str),' was less than j32';   else if i = lw#igt   then print string(str),' was greater than j32';   else if i = lw#ieq   then print string(str),' was equal to j32';   else print 'The compare returned an illegal value: ',i;   call out;end com_out;   print '';print 'Testing the 32-bit unsigned math routines';print '';print 'Storing 1 in i32 with str32()';call str32(0,1,i32);call out;print 'Adding 6 to i32 with add16()';call add16(6,i32);call out;print 'Adding 32760 to i32 with add16()';call add16(32760,i32);call out;print 'Adding 1 to i32 with add16()';call add16(1,i32);call out;print 'Adding 32767 to i32 with add16()';call add16(32767,i32);call out;print 'Adding 1 to i32 with add16()';call add16(1,i32);call out;print 'Adding 65535 to i32 with add16()';call add16(65535,i32);call out;print 'Adding 1 to i32 with add16()';call add16(1,i32);call out;print 'Subtracting 1 to i32 with sub16()';call sub16(1,i32);call out;print 'Storing 1 in j32 with str32()';call str32(0,1,j32);call out;print 'Adding j32 to i32 with add32()';call add32(j32,i32,i32);call out;print 'Subtracting j32 from i32 with sub32()';call sub32(i32,j32,i32);call out;print 'Comparing i32,j32 with com32()';i = com32(i32,j32);call com_out(i,'i32');print 'Adding i32 to j32 with add32()';call add32(i32,j32,j32);call out;print 'Comparing i32,j32 with com32()';i = com32(i32,j32);call com_out(i,'i32');print 'Subtracting 2 from j32 with sub16()';call sub16(2,j32);call out;print 'Comparing i32,j32 with com32()';i = com32(i32,j32);call com_out(i,'i32');print 'Adding 1 to i32 with add16()';call add16(1,i32);call out;print 'Copying i32 to j32 with copy32()';call copy32(i32,j32);call out;print 'Comparing i32,j32 with com32()';i = com32(i32,j32);call com_out(i,'i32');print 'Comparing 0 and j32 with com16()';i = com16(0,j32);call com_out(i,'0');print 'Storing 0 in j32 with str32()';call str32(0,0,j32);call out;print 'Comparing 0 and j32 with com16()';i = com16(0,j32);call com_out(i,'0');print 'Adding 1 to j32 with add16()';call add16(1,j32);call out;print 'Comparing 0 and j32 with com16()';i = com16(0,j32);call com_out(i,'0');print 'Comparing 2 and j32 with com16()';i = com16(2,j32);call com_out(i,'2');print 'Storing 65535 in j32 with str32()';call str32(0,65535,j32);call out;print 'Comparing 2 and j32 with com16()';i = com16(2,j32);call com_out(i,'2');print 'Subtracting 32767 from j32 with sub16';call sub16(32767,j32);call out;print 'Comparing 2 and j32 with com16()';i = com16(2,j32);call com_out(i,'2');print 'Subtracting 1 from j32 with sub16';call sub16(1,j32);call out;print 'Comparing 2 and j32 with com16()';i = com16(2,j32);call com_out(i,'2');print 'Adding 2 to j32 with add16()';call add16(2,j32);call out;print 'Adding i32 and j32 to themselves with add32()';call add32(i32,i32,i32);call add32(j32,j32,j32);call out;print 'Subtracting i32 and j32 from themselves with sub32()';call sub32(i32,i32,i32);call sub32(j32,j32,j32);call out;print 'Storing 32768 in i32 and 4096 in j32 with str32()';call str32(0,32768,i32);call str32(0,4096,j32);call out;print 'Shifting i32 and j32 left 10 with shl32()';call shl32(i32,10);call shl32(j32,10);call out;print 'Shifting i32 and j32 right 11 with shr32()';call shr32(i32,11);call shr32(j32,11);call out;/* Earlier test code... * * DCL (I,J,K,L) FIXED; * * DO WHILE 1; *    INPUT I,J; * *    CALL SEC.TO.MSEC(LOC(ADDR(I)),CF#TIME,LOC(ADDR(K))); *    PRINT K,L; * *    CALL SEC.TO.MSEC(LOC(ADDR(I)),CF#DUR,LOC(ADDR(K))); *    PRINT K,L; * *    CALL MSEC.TO.SEC(LOC(ADDR(I)),CF#TIME,LOC(ADDR(K))); *    PRINT K,L; * *    CALL MSEC.TO.SEC(LOC(ADDR(I)),CF#DUR,LOC(ADDR(K))); *    PRINT K,L; * END; */