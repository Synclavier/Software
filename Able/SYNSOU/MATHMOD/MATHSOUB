/* :SYNSOU:MATHMOD:MATHSOUB  $TITLE  HIGH PRECISION MATH ROUTINES AND TIME CONVERSION PROCS   Modified:   03/14/91 - cj  - moved some routines here   01/20/91 - PF  - Added proc FRACTDIV32   01/20/91 - PF  - Created this file*//* $SUBTITLE  ROUTINES TO CONVERT BETWEEN MSEC AND SEC ARRAY *//* converts seconds and milliseconds to a 32-bit time, corrects for zero.time */SEC.TO.MSEC: proc(sec,format,msec) public swapable;   dcl sec          array; /* input time (seconds & msec) */   dcl format       fixed;   dcl msec         array; /* 32-bit output milliseconds */   dcl secs         fixed;   dcl msecs        fixed;   dcl sign         fixed;   secs  = sec(0);   msecs = sec(1);   if (secs<0) or (msecs<0)   then do;      secs  = (- secs );      msecs = (- msecs);      sign  = 1;   end;   load secs; uload msecs; mul 1000;     /* convert to 32-bit ms. number */   msec(0)= ures; msec(1) = res;   if format=cf#time then do;        /* need to add in zero.time */      msec(1)=msec(1)+zero.time;      if msec(1) ilt zero.time then msec(0)=msec(0)+1;   end;   if sign   then call neg32(msec);end SEC.TO.MSEC;/* convert 32-bit ms to sec,msec - correct for zero.time */MSEC.TO.SEC: proc(msec,format,sec) public swapable;   dcl msec         array; /* input 32-bit milliseconds */   dcl format       fixed;   dcl sec          array;  /* output sec(0) and msec(1) */   dcl (msb,lsb)    fixed;   dcl sign         fixed;   msb=msec(0); lsb=msec(1); /* get local copies so we don't trash input array */   if msb<0 then do;      if lsb = 0 then msb = (- msb);      else do;         lsb = (-   lsb);         msb = (not msb);      end;      sign = 1;   end;   IF FORMAT=CF#TIME THEN DO;      IF (MSB=0)&(LSB ILT ZERO.TIME)          /* BEFORE 0.000 - LEAVE AT 0.000 */      THEN LSB=0;      ELSE DO;         IF LSB ILT ZERO.TIME THEN MSB=MSB-1; /* MOVE TO 0.000 FROM FIRST CLICK */         LSB=LSB-ZERO.TIME;      END;   END;   load lsb; uload msb;   div 1000;   sec(0)=res;   sec(1)=rem;   if sign   then do;      sec(0) = (- sec(0));      sec(1) = (- sec(1));   end;END MSEC.TO.SEC;/* $SUBTITLE  ROUTINES TO CONVERT BETWEEN MSEC DURATION FORMAT *//* converts from 32-bit millisecond time to format needed by note records *//* note: this routine is passed a SEQUENCE duration (not a real time      *//* duration).                                                             */MSEC.TO.DURATION:  PROC (MSEC) FIXED PUBLIC SWAPABLE;   DCL MSEC ARRAY; /* INPUT DURATION */   DCL (MSB,LSB) FIXED; /* 32-BIT DURATION IN MILLISECONDS */   MSB=MSEC(0); LSB=MSEC(1);                    /* COPY DUR INTO LOCAL TEMPS */   /* IF (MSB\LSB)=0 THEN LSB=1;                   SHORTEST NOTE IS 1 MSEC! */   IF ((MSB IGT 3))                             /* NOTE DURATION IS TOO */   OR ((MSB  =  3)                              /* LONG TO RECORD       */   AND (LSB IGT 65472))   THEN DO;                                     /* LIMIT DURATION     */      MSB=3; LSB=65472;                         /* TO 262.080 SECONDS */   END;   IF MSB=0 THEN DO;                            /* MAP DURATION TO MANTISSA & EXPONENT */      IF LSB IGT 16380 THEN DO;         LOAD LSB; DIV 16; LSB=RES;             /* MAKE NUMBER FIT IN 12-BITS */         IF REM IGE SHR(16,1) THEN LSB=LSB+1;   /* ROUND UP */         MSB=2;                                 /* THIS IS THE EXPONENT */      END;      ELSE IF LSB IGT 4095 THEN DO;         LOAD LSB; DIV 4; LSB=RES;              /* MAKE NUMBER FIT IN 12-BITS */         IF REM IGE SHR(4,1) THEN LSB=LSB+1;    /* ROUND UP */         MSB=1;                                 /* THIS IS THE EXPONENT */      END;      ELSE MSB=0;                               /* SMALL DURATIONS FIT WITH NO MULTIPLIER */   END;   ELSE DO;                                     /* REAL LONG NOTES */      LOAD LSB; ULOAD MSB; DIV 64; LSB=RES;     /* MAKE NUMBER FIT IN 12-BITS */      IF REM IGE SHR(64,1) THEN LSB=LSB+1;      /* ROUND UP */      MSB=3;                                    /* THIS IS THE EXPONENT */   END;   LOAD MSB; MUL 4096;                      /* SHIFT BITS INTO CORRECT POS */   RETURN RES\LSB;                          END MSEC.TO.DURATION;COMPARE_TIMES:proc(time1,time2,len) fixed public swapable; /* compares two times, return 0 if equal, 1 if a>b, -1 if a<b  */    dcl (time1,time2) fixed array;   dcl len   fixed;   dcl i     fixed;   do i=0 to len-1;      if time1(i)>time2(i) then return 1;      if time1(i)<time2(i) then return -1;   end;   return 0; /* equal */end COMPARE_TIMES;COPY_TIME:proc(time1,time2) public swapable;     /* =====>  */   dcl (time1,time2) fixed array;   dcl i             fixed;   do i=0 to 2;      time2(i)=time1(i);   end;end COPY_TIME;TIME_NORMALIZE:proc (time) public swapable;   dcl time fixed array;   do while time(2)<0;              /* normalize microseconds */      time(2)=time(2)+1000;      time(1)=time(1)-1;   end;   do while time(2)>999;      time(2)=time(2)-1000;      time(1)=time(1)+1;   end;   do while time(1)<0;              /* normalize milliseconds */      time(1)=time(1)+1000;      time(0)=time(0)-1;   end;   do while time(1)>999;      time(1)=time(1)-1000;      time(0)=time(0)+1;   end;end TIME_NORMALIZE;/* $SUBTITLE  ROUTINES TO DEAL WITH SOUND FILE TIMES */NORMALIZE.SF.TIME: proc(sf.time) public swapable;   dcl sf.time fixed array;   dcl n#sec  lit 'sf.time(0)';   dcl n#msec lit 'sf.time(1)';   dcl n#usec lit 'sf.time(2)';   load n#usec;  div 1000; n#msec=n#msec+res; n#usec =rem;   load n#msec;  div 1000; n#sec=n#sec+res;   n#msec =rem;end NORMALIZE.SF.TIME;ADD.SF.TIME: proc(add1,add2,dst) public swapable;   dcl add1  fixed array;   dcl add2  fixed array;   dcl dst   fixed array;   dst(0) = add1(0) + add2(0);       /* Add sec  */   dst(1) = add1(1) + add2(1);       /* Add msec */   dst(2) = add1(2) + add2(2);       /* Add usec */   call normalize.sf.time(dst);end ADD.SF.TIME;SUB.SF.TIME: proc(src,num,dst) public swapable;   dcl src    fixed array;   dcl num    fixed array;   dcl dst    fixed array;   dcl s (2)  fixed;   call blockmove(src,s,3);          /* Make local copy */   if s(2) < num(2) then do;         /* Check borrow */      s(2) = s(2) + 1000;      s(1) = s(1) - 1;   end;   dst(2) = s(2) - num(2);           /* Subtract usec */   if s(1) < num(1) then do;         /* Check borrow */      s(1) = s(1) + 1000;      s(0) = s(0) - 1;   end;   dst(1) = s(1) - num(1);           /* Subtract msec */   dst(0) = s(0) - num(0);           /* Subtract sec */end SUB.SF.TIME;Convert.SF.Len.To.Samples: proc(In,Out) public swapable;   dcl In    array; /* 3 word length format (Ms Sec, Ls Sec, Words) */   dcl Out   array; /* 32-bit sample count */   /* Convert SFM format length to 32-bit sample count */   /* IN and OUT can be the same (Lengths differ though - watch out!) */   /* Can handle un-normalized input data */   Out(0)=shl(In(0),8) + shr(In(1),8);   Out(1)=shl(In(1),8) +     In(2);   if Out(1) ilt In(2) then Out(0)=Out(0)+1;end Convert.SF.Len.To.Samples;Convert.Samples.To.SF.Len: proc(In,Out) public swapable;   dcl In  array; /* 32-bit sample count */   dcl Out array; /* 3 word length format (Ms Sec, Ls Sec, Words) */   dcl X (1) fixed;   /* Convert 32-bit sample count to SFM format length */   /* IN and OUT can be the same (Lengths differ though - watch out!) */   X(0)=In(0); X(1)=In(1); /* copy input into temp */   Out(0)=shr(X(0),8);   Out(1)=shl(X(0) & 255,8) | shr(X(1),8);   Out(2)=X(1) & 255;end Convert.Samples.To.SF.Len;/* $page - address mapping for direct to disk *//* The direct to disk stores all cue in/out pointers as an absolute *//* sample #.  These can be converted to a 32-bit milliseconds time  *//* that is with respect to the current project, or with respect     *//* to the entire dtd system, assuming the current sampling rate     *//* and speed and smpte offset are in effect                         *//* The following routines perform the conversions                   *//* DTD.Sample.#.To.Msecs converts a 32 bit sample # to a msec       *//* time.                                                            *//* returns time = abs zero if is before the passed base             *//* rounding is performed                                            */DTD.Sample.#.To.Msecs:proc (Sample#, Format, Speed, Rate, Base, Msec) Public Swapable;   dcl Sample#     array;    /* 32 bit dtd sample #  */   dcl Format      fixed;    /* time or duration     */   dcl Speed       fixed;    /* synclav speed        */   dcl Rate        fixed;    /* sample rate of proj  */   dcl Base        array;    /* project base sample  */   dcl Msec        array;    /* output msecs         */   if COM32(Sample#,Base) = lw#ilt   /* return absolute 0 if sample # */   then do;                          /* is before project start       */      call STR32(0,0,Msec);      return;   end;   call Sub32(Sample#, Base, Bit);      if  (rate = 319)                    /* if rate is 31.9 khz     */   or  (rate = 440)                    /* or 44.0 khz             */   or  (rate = 479)                    /* OR 47.9 KHZ             */   or  (rate = 881)                    /* OR 88.1 KHZ             */   or  (rate = 959)                    /* OR 95.9 KHZ             */   then do;      call ratio_multiply(speed,rate+1);	/* correct for user specified sampling rate and synclav speed */      call ratio_multiply(3000,2997);   end;   else if  (rate = 321)               /* if rate is 32.1 khz     */   or       (rate = 442)               /* or 44.2 khz             */   or       (rate = 481)               /* OR 48.1 KHZ             */   or       (rate = 883)               /* OR 88.3 KHZ             */   or       (rate = 961)               /* OR 96.1 KHZ             */   then do;      call ratio_multiply(speed,rate-1);	/* correct for user specified sampling rate and synclav speed */      call ratio_multiply(2997,3000);   end;   else call ratio_multiply(speed,rate);	/* correct for user specified sampling rate and synclav speed */   call ratio_multiply(1,100);				/* get milliseconds based upon 100 khz sampling */   call COPY32(Bit,Msec);   /* add zero.time from synclav time base      */   /* this will line up our recording with      */   /* the first click                           */   if Format = CF#Time   then call ADD16(zero.time, Msec);end DTD.Sample.#.To.Msecs;Signed.DTD.Sample.#.To.Msecs:proc (Sample#, Format, Speed, Rate, Base, Msec) Public Swapable;   dcl Sample#     array;    /* 32 bit dtd sample #  */   dcl Format      fixed;    /* time or duration     */   dcl Speed       fixed;    /* synclav speed        */   dcl Rate        fixed;    /* sample rate of proj  */   dcl Base        array;    /* project base sample  */   dcl Msec        array;    /* output msecs         */   dcl sign        fixed;    /* sign flag            */   if (Sample#(lw#msb) < 0)   then do;      call NEG32(Sample#);      sign = 1;   end;   call DTD.Sample.#.To.Msecs(Sample#, Format, Speed, Rate, Base, Msec);   if (sign = 1)   then call NEG32(Msec);end Signed.DTD.Sample.#.To.Msecs;/* $page - Compute Sample # from 32-bit msec time */MSEC.To.DTD.Sample.#: proc(Msec, Format, Speed, Rate, Base, Sample#) PUBLIC Swapable;   dcl Msec      array;   /* 32 bit millisecond time   */   dcl Format    fixed;   /* time or duration          */   dcl Speed     fixed;   /* Speed setting             */   dcl Rate      fixed;   /* sampling rate in question */   dcl Base      array;   /* sample base of project    */   dcl Sample#   array;   /* output array              */   dcl i         fixed;   dcl j         fixed;   call COPY32(msec,Bit);                   /* get temp copy         */   if Format = CF#Time then do;      if COM16(zero.time,Bit) = lw#igt      then do;         call STR32(0,0,Bit);      end;      else do;         call SUB16(zero.time,Bit);      end;   end;   call multiply(100,0,0,0);          /* compute sample # based on 100 khz sampling */   if  (rate = 319)                    /* if rate is 31.9 khz     */   or  (rate = 440)                    /* or 44.0 khz             */   or  (rate = 479)                    /* OR 47.9 KHZ             */   or  (rate = 881)                    /* OR 88.1 KHZ             */   or  (rate = 959)                    /* OR 95.9 KHZ             */   then do;      call ratio_multiply(Rate+1,speed);	/* correct for user specified sampling rate and synclav speed */      call ratio_multiply(2997,3000);   end;   else if  (rate = 321)               /* if rate is 32.1 khz     */   or       (rate = 442)               /* or 44.2 khz             */   or       (rate = 481)               /* OR 48.1 KHZ             */   or       (rate = 883)               /* OR 88.3 KHZ             */   or       (rate = 961)               /* OR 96.1 KHZ             */   then do;      call ratio_multiply(rate-1,speed);	/* correct for user specified sampling rate and synclav speed */      call ratio_multiply(3000,2997);   end;   else call ratio_multiply(Rate,Speed);	/* correct for user specified sampling rate and synclav speed */      call ADD32(Base, Bit, Sample#);   load Rate;                         /* get sample rate (500 = 50 khz)   */   mul  50;                           /* rate * .05 yields samples        */   mwait;                             /* in .5 milliseconds               */   div Speed;   i = res;                           /* 25 samples for 50 khz @ 1.000    */   j = Sample#(lw#lsb) & 255;         /* get low 8 bits of sample #       */   if j < i                           /* round sample # down to sector    */   then call SUB16(j, Sample#);       /* bound if close to there          */   else if j > (256-i)                /* else round up to sector bound    */   then call ADD16(256-j, Sample#);   /* if close to there                */end MSEC.To.DTD.Sample.#;Signed.MSEC.To.DTD.Sample.#: proc(Msec, Format, Speed, Rate, Base, Sample#) PUBLIC Swapable;   dcl Msec      array;   /* 32 bit millisecond time   */   dcl Format    fixed;   /* time or duration          */   dcl Speed     fixed;   /* Speed setting             */   dcl Rate      fixed;   /* sampling rate in question */   dcl Base      array;   /* sample base of project    */   dcl Sample#   array;   /* output array              */   dcl i         fixed;   dcl j         fixed;   dcl sign      fixed;   if (Msec(lw#msb) < 0)   then do;      call NEG32(Msec);      sign = 1;   end;   call MSEC.To.DTD.Sample.#(Msec, Format, Speed, Rate, Base, Sample#);   if (sign = 1)   then do;      call NEG32(Sample#);   end;end Signed.MSEC.To.DTD.Sample.#;/*------------------------------------------------------------------------------| PROCEDURES: map_times_to_dB and map_dB_to_times convert back and forth|   between linear ("times") and log (dB) amplitude scales.  The "times"|   values can range from 7 to 251 which represent actual multiplier values|   of 0.7 to 25.1.  The dB values range from -3dB to +28dB.  Over or under|   range parameter values will be mapped to the max and min values|   (they will be "clipped").| METHOD: Lookup tables are used to avoid floating point.  Entries included|   for each integer dB value (e.g. -3, -2, ... 28).| PARAMETER: times, dB - value to convert to other type.| RETURN: dB or "times" values.| BY: Cameron Jones  MODIFIED: JSS 4/26/88+-----------------------------------------------------------------------------*/map_times_to_dB: proc (times) returns (fixed) public swapable;   dcl times fixed;  /* passed 7 (represents 0.7) to 251 (25.1) times */   dcl i     fixed;   /* dB lookup table */   dcl log_scale data (       7,   8,   9,  10,  11,  13,  14,  16,  18,  20,  22,      25,  28,  32,  35,  40,  45,  50,  56,      63,  71,  79,  89,  100, 112, 126, 141,      158, 178, 200, 224, 251, 282, 316, 355);   /* Search table for value that corresponds to times value passed in */   do i = -3 to 28;      if log_scale (i + 3) >= times   /* If found in table */      then return (i);                /* return it         */   end;   return 28;    /* If not found return max gain: 28 dB */end map_times_to_dB;map_dB_to_times: proc (dB) returns (fixed) public swapable;   dcl dB fixed;        /* passed -3 to +28 dB */   /* dB lookup table */   dcl log_scale data (       7,   8,   9,  10,  11,  13,  14,  16,  18,  20,  22,      25,  28,  32,  35,  40,  45,  50,  56,      63,  71,  79,  89,  100, 112, 126, 141,      158, 178, 200, 224, 251, 282, 316, 355);   if dB > 28 then return (251);    /* If over range, clip high */   else if dB < -3 then return (7); /* If under range, clip low */   return log_scale (dB + 3);    /* else lookup value and return it */end map_dB_to_times;/* Routines are called from the interrupt routine, so must NOT      *//* swap and must be recursive:                                      */Remove.Zero.Time.Offset: proc(time) public recursive;   dcl time array;   if time(0) >= 0 then do;               /* if positive, check     */      call sub16(zero.time, time);      if time(0) < 0 then call str32(0, 0, time);   end;   else do;                               /* else handle negative   */      call add16(zero.time, time);      if time(0) >= 0 then call str32(0, 0, time);   end;end Remove.Zero.Time.Offset;Add.Zero.Time.Offset: proc(time) public recursive;   dcl time array;   if time(0) >= 0   then call add16(zero.time, time);   else call sub16(zero.time, time);end Add.Zero.Time.Offset;/* FRACTDIV32 -   INPUTS :    32 BIT INTEGER   NUM(0)   NUM(1)               32 BIT INTEGER   DENOM(0) DENOM(1)   OUTPUT:     48 BIT INTEGER   R(0) R(1) R(2)  *//* DECIMAL POINTS:   (NUM(0)   NUM(1)  )  =  32 BIT INTEGER LEFT OF DECIMAL POINT                     (DENOM(0) DENOM(1))  =  32 BIT INTEGER LEFT OF DECIMAL POINT                     (R(0)             )  =  16 BIT INTEGER LEFT OF DECIMAL POINT                     (     R(1) R(2)   )  =  32 BITS RIGHT       OF DECIMAL POINT*/FRACTDIV32:PROC(NUM,DENOM,R) PUBLIC SWAPABLE;   DCL NUM     FIXED ARRAY;   DCL DENOM   FIXED ARRAY;   DCL R       FIXED ARRAY;   DCL FNUM    FLOATING;   DCL FDENOM  FLOATING;   DCL FREM    FLOATING;   DCL X       FLOATING;   /* CONVERT NUMERATOR AND DENOMINATOR TO TYPE FLOATING */   FNUM   = (NUM(0)   * 65536) + NUM(1);   IF NUM(1) < 0 THEN FNUM = FNUM + 65536;    FDENOM = (DENOM(0) * 65536) + DENOM(1);   IF DENOM(1) < 0 THEN FDENOM = FDENOM + 65536;    X = INT(FNUM / FDENOM);                  /* CALC WHOLE PART OF RATIO */   R(0) = INT(X);                           /* PUT RES INTO RETURN ARG  */   IF X < 0 THEN X = X + 65536;             /* MAKE SURE RES IS POS     */   FREM = FNUM - (X * FDENOM);              /* GET REMAINDER            */   X = INT((FREM * 65536) / FDENOM);        /* CALC MSB OF FRACT        */   R(1) = INT(X);                           /* PUT RES INTO RETURN ARG  */   IF X < 0 THEN X = X + 65536;             /* MAKE SURE RES IS POS     */   FREM = FREM - ((X / 65536) * FDENOM);    /* GET REMAINDER            */   FREM = ((FREM * 65536) / FDENOM) * 65536;  /* CALC LSB OF FRACT AND SAVE IN FREM */   R(2) = INT(FREM);                        /* PUT RES IN RETURN ARG    */   X    = INT(FREM);                        /* SAVE INTEGER PART IN FLOATING VAR */   IF X < 0 THEN  X = X + 65536;            /* MAKE SURE RESULT IS POS  */   IF (FREM - X) >= .5                      /* CHECK FOR ROUND UP       */   THEN DO;      R(2) = R(2) + 1;                      /* ROUND UP                 */      IF R(2) = 0 THEN DO;         R(1) = R(1) + 1;         IF R(1) = 0         THEN R(0) = R(0) + 1;      END;   END;END FRACTDIV32;