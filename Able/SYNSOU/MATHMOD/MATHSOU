/* MATHSOU  $TITLE  HIGH PRECISION MATH ROUTINES AND TIME CONVERSION PROCS   Modified:   03/14/91 - cj  - Modified MULTIPLY to preserve all 80 bits of                    cross product for special purposes.  Added                    longinvert, multiple.precision.add   01/20/91 - PF  - Insert mathsoub   05/02/90 - cj  - added "pull-down" smpte code   11/15/89 - MWH - Make "neg32" public   09/27/89 - cj & JSS - corrected dtd sample # routines                    for 32.1, 44.2, 48.1, 88.3, 96.1                       DTD.Sample.#.To.Msecs                       MSEC.To.DTD.Sample.#   07/26/89 - CJ  - added smart routines to add & subtract 50 millisecond                    offset from 32-bit millisecond times   02/09/88 - cj  - fixed AEE bugs with 31.9, 44.0, 47.9, 88.1, 95.9 KHZ   10/24/88 - MWH - Fix math bug in converting MSEC to BEATS (per KJC)   08/04/88 - cj  - changed feet/footage routines to handle                    signed offsets.  Also other routines.                    Added NEG32 (but not public yet).                    Change smpte rounding to provide 1 millisecond                    (as opposed to two millisecond) resolution.   06/28/88 - cj  - changed msec to dtd sample # to round to sector                    boundary if sample # is close to sector   05/19/88 - MWH - Change SMPTE algorithms so they work a full 24 hours   04/26/88 - JSS - added map_dB_to_times, map_times_to_dB conversion routines   11/05/87 - EEG - ADDED 16MM/30FPS TO S$FMODE   11/12/87 - CJ  - merged in dtd sample # routines   11/10/87 - MWH - ADD and SUB routines for SOUND FILE TIME   10/30/87 - MWH - ADD and SUB routines for FEET, SMPTE and BEATS                    Add rounding (dead-band) to MSEC.TO.FEET   08/26/87 - MWH - Merge with other release-N edits   07/30/87 - MWH - MAKE COM16 UNSIGNED ONLY   06/11/87 - MWH - ADD/EXPAND CAMERON'S 32 BIT ROUTINES*/MODULE MATHMOD;/* NOTE: THESE VARIABLES MUST BE KEPT IN ORDER */DCL (BITMSB,BITLSB)       FIXED PUBLIC; /* KEEP VARS IN ORDER */DCL (MUL.LLSB)            FIXED PUBLIC;DCL (MULTIPLY.RESULT) (4) FIXED PUBLIC;DCL (BIT)           LIT   'LOC(ADDR(BITMSB))';INSERT ':SYNLITS:COMLITS';   /* ALL MODULES MUST INSERT COMLITS    */INSERT ':SYNLITS:GLOBLITS';  /* PRACTICALLY ALL WILL WANT GLOBLITS */INSERT ':SYNAUXS:MATHLITS';  /* MATH SPECIFIC LITERALS             *//* $SUBTITLE  32 BIT MATH ROUTINES *//* store (msb,lsb) into dst32                 *//* Note: must be recursive since called from  *//* the interrupt routine.                     */str32:proc(msb,lsb,dst32) public recursive;   dcl msb fixed;   dcl lsb fixed;   dcl dst32 fixed array;                                 dst32(lw#msb) = msb;   dst32(lw#lsb) = lsb;end str32;/* adds 16-bit unsigned num16 into dst32      *//* Note: must be recursive since called from  *//* the interrupt routine.                     */add16:proc(num16,dst32) public recursive;   dcl num16 fixed;   dcl dst32 fixed array;                                 dst32(lw#lsb) = dst32(lw#lsb) + num16;   if dst32(lw#lsb) ilt num16   then dst32(lw#msb) = dst32(lw#msb) + 1;end add16;/* subtracts 16-bit unsigned num16 from dst32 *//* Note: must be recursive since called from  *//* the interrupt routine.                     */sub16:proc(num16,dst32) public recursive;   dcl num16 fixed;   dcl dst32 fixed array;                                 if dst32(lw#lsb) ilt num16   then dst32(lw#msb) = dst32(lw#msb) - 1;   dst32(lw#lsb) = dst32(lw#lsb) - num16;end sub16;dcl copy32 proc (array,array) recursive;/* add1 + add2 into dst */add32:proc(add1,add2,dst) public recursive;  /* routines could be speed up by */   dcl add1 fixed array;                     /* assembly language later if    */   dcl add2 fixed array;                     /* desired.   add32 works on     */   dcl dst fixed array;                      /* signed or unsigned 32 bit     */   dcl r (1) fixed;                          /* numbers                       */   r(lw#msb) = add1(lw#msb) + add2(lw#msb);   r(lw#lsb) = add1(lw#lsb) + add2(lw#lsb);   if r(lw#lsb) ilt add1(lw#lsb)   then r(lw#msb) = r(lw#msb) + 1;   call copy32(r,dst);                       /* 'r' copes with add1 = add2 = dst      */end add32;/* src - num into dst */sub32:proc(src,num,dst) public recursive;    /* sub32 is only correct for     */   dcl src fixed array;                      /* unsigned 32 bit numbers       */   dcl num fixed array;   dcl dst fixed array;   dcl borrow fixed;   if src(lw#lsb) ilt num(lw#lsb) then borrow = 1;   dst(lw#msb) = src(lw#msb) - num(lw#msb) - borrow;   dst(lw#lsb) = src(lw#lsb) - num(lw#lsb);end sub32;/* comparison:       *//* a < b  returns lw#ilt (-1) *//* a = b  returns lw#ieq (0)  *//* a > b  returns lw#igt (+1) */com32:proc(a,b) public recursive;       /* com32 performs an unsigned    */   dcl a fixed array;                   /* comparison                    */   dcl b fixed array;   if a(lw#msb) ilt b(lw#msb) then return (lw#ilt);   if a(lw#msb) igt b(lw#msb) then return (lw#igt);   if a(lw#lsb) ilt b(lw#lsb) then return (lw#ilt);   if a(lw#lsb) igt b(lw#lsb) then return (lw#igt);   return (lw#ieq);end com32;/* compare (a16 = 16 bits unsigned) with (b32 = 32 bits unsigned) */com16:proc(a16,b32) public recursive;     /* com16 performs an unsigned    */   dcl a16 fixed;                         /* comparison                    */   dcl b32 fixed array;   if b32(lw#msb) igt 0                   /* 32 bit number is greater than */   then return (lw#ilt);                  /* largest possible 16 bit num   */   if a16 ilt b32(lw#lsb) then return (lw#ilt);   if a16 igt b32(lw#lsb) then return (lw#igt);   return (lw#ieq);end com16;/* 32 bit copy src -> dst */copy32:proc(src,dst) public recursive;   dcl src fixed array;   dcl dst fixed array;   dst(lw#msb) = src(lw#msb);   dst(lw#lsb) = src(lw#lsb);end copy32;/* shift num left by amount */shl32:proc(num,amount) public recursive;   dcl num fixed array;   dcl amount fixed;   dcl i fixed;   do i=1 to amount;      call add32(num,num,num);   end;end shl32;/* shift num right by amount */shr32:proc(num,amount) public recursive;   dcl num fixed array;   dcl amount fixed;   dcl (i,bit) fixed;   do i=1 to amount;      if num(lw#msb) then bit = "100000";      /* if msb is odd... */      else bit = 0;      num(lw#msb) = shr(num(lw#msb),1);      num(lw#lsb) = shr(num(lw#lsb),1) \ bit;  /* ...lsb needs that bit */   end;end shr32;neg32:proc(num) public recursive;        /* perform twos complement */   dcl num fixed array;                  /* negate on 32-bit        */                                         /* number                  */   if num(lw#lsb) = 0   then num(lw#msb) = (-   (num(lw#msb)));   else do;      num(lw#msb)   = (not (num(lw#msb)));      num(lw#lsb)   = (-   (num(lw#lsb)));   end;end neg32;/* MULTIPLY:   INPUTS :    32 BIT INTEGER   (BITMSB BITLSB)    (0-4,294,967,2XX)               64 BIT INTEGER   (A   B   C   D)    (0-65535.9999999)   OUTPUT:     48 BIT INTEGER   (BITMSB BITLSB).(MUL.LLSB)  *//* NOTE: BITMSB, BITLSB ARE ROUNDED HERE BASED ON MUL.LLSB  *//* OVERFLOW CONDITIONS ARE NOT DETECTED *//* DECIMAL POINTS:   (BITMSB BITLSB)  =  32 BIT INTEGER LEFT OF DECIMAL POINT                     (A            )  =  16 BIT INTEGER LEFT OF DECIMAL POINT                     (    B   C   D)  =  48 BITS RIGHT       OF DECIMAL POINT                     SO: */MULTIPLY:PROC(INA,INB,INC,IND) PUBLIC SWAPABLE;   /* SCALE BITMSB BITLSB BY A.BCD */   DCL (INA,INB,INC,IND)  FIXED;                  /* ROUND INTO BITMSB, BITLSB    */   dcl (a,b,c,d) fixed static;   dcl temp      fixed static;   dcl sr        fixed;   dcl a0      lit '"300"';   dcl a1      lit '"301"';   dcl a2      lit '"302"';   dcl a3      lit '"303"';   dcl add0    lit '"210"';   /* add 0            */   dcl add1    lit '"211"';   /* add 1            */   dcl add2    lit '"212"';   /* add 2            */   dcl add3    lit '"213"';   /* add 3            */   dcl addc0   lit '"270"';   /* add with carry 0 */   dcl addc1   lit '"271"';   /* add with carry 1 */   dcl addc2   lit '"272"';   /* add with carry 2 */   dcl addc3   lit '"273"';   /* add with carry 3 */   dcl r13     lit '"313"';   dcl mr13i   lit '"373"';   dcl i       lit 'BITMSB';   dcl j       lit 'BITLSB';   sr         = read(r13);   write(r13) = addr(multiply.result(0));   a = ina; b = inb;          /* copy input variables into statics */   c = inc; d = ind;   load a; mul i;   write(   a0) = res;        /* a*i; toss msb */   load a; mul j;             /* a*j           */   write(   a1) = res;   write( add0) = ures;   load b; mul i;             /* b*i           */   write( add1) = res;   write(addc0) = ures;   load b; mul j;             /* b*j           */   write(   a2) = res;   write( add1) = ures;   write(addc0) = 0;   load c; mul i;             /* c*i           */   write( add2) = res;   write(addc1) = ures;   write(addc0) = 0;   load c; mul j;             /* c*j           */   write(   a3) = res;   write( add2) = ures;   write(addc1) = 0;   write(addc0) = 0;   load d; mul i;             /* d*i           */   write( add3) = res;   write(addc2) = ures;   write(addc1) = 0;   write(addc0) = 0;   load d; mul j;             /* d*j           */   write( add3) = ures;       /* save res      */   write(addc2) = 0;          /* for storing   */   write(addc1) = 0;          /* below         */   write(addc0) = 0;   /* Store complete result */   write(mr13i) = read(a0);   write(mr13i) = read(a1);   write(mr13i) = read(a2);   write(mr13i) = read(a3);   write(mr13i) = res;   BITMSB = read(a0);          /* save rounded 32-bit result */   BITLSB = read(a1);          /* for use in simple cases    */   MUL.LLSB = read(a2);   /* NOW ROUND */   IF MUL.LLSB<0 THEN DO;            /* ROUND UP       */      BITLSB=BITLSB+1;      IF BITLSB=0      THEN BITMSB=BITMSB+1;   END;   write(r13) = sr;                  /* restore r13    */END MULTIPLY;UNROUND:PROC PUBLIC SWAPABLE;             /* PROCEDURE TO PROVIDE TRUNCATED RESULT */   IF MUL.LLSB<0 THEN DO;                 /* REMOVE ROUND UP       */      BITLSB=BITLSB-1;      IF BITLSB=(-1)      THEN BITMSB=BITMSB-1;   END;END UNROUND;/* $SUBTITLE - RATIO MULTIPLY *//* RATIOMULTIPLY -   COMPUTE  (BITMSB,BITLSB) * (NUM/DENOM) */RATIOMULTIPLY:PROC(NUM,DENOM) PUBLIC SWAPABLE;   DCL (NUM,DENOM)     FIXED;   DCL (I,S1,S2,S3,S4) FIXED;   IF DENOM=0 THEN DENOM=1;            LOAD NUM;  DIV  DENOM; S1=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S2=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S3=RES;   I=REM; LOAD 0; ULOAD I; DIV DENOM; S4=RES;   CALL MULTIPLY(S1,S2,S3,S4);END RATIOMULTIPLY;dcl ratio_multiply proc (fixed,fixed) external;/* Routine to compute inverse of 64 bit number.    *//* input is a.bcd                                  *//* output is 1/a.bcd in form p.qrs                 *//* restriction: a must be < 32768                  *//* full answer is returned in multiply.result      *//* rounded answer a.bc is returned in              *//* bitmsb, bitlsb, mul.llsb                        */LONGINVERT:proc(a,b,c,d) public swapable;   dcl (a,b,c,d)   fixed;   /* note: the following storage must be in order!!              */   dcl answer(3) fixed;       /* note: store lsb,...,msb !!!      */   dcl num   (3) fixed;       /* temp numerator                   */   dcl den   (3) fixed;       /* temp denominator                 */   dcl dif   (3) fixed;       /* holds temp new numerator         */   dcl sr        fixed;   dcl i         fixed;   dcl bit       fixed;   dcl a0      lit '"300"';   dcl a1      lit '"301"';   dcl a2      lit '"302"';   dcl a3      lit '"303"';   dcl add0    lit '"210"';   /* add 0            */   dcl add1    lit '"211"';   /* add 1            */   dcl add2    lit '"212"';   /* add 2            */   dcl add3    lit '"213"';   /* add 3            */   dcl addc0   lit '"270"';   /* add with carry 0 */   dcl addc1   lit '"271"';   /* add with carry 1 */   dcl addc2   lit '"272"';   /* add with carry 2 */   dcl addc3   lit '"273"';   /* add with carry 3 */   dcl sub0    lit '"214"';   /* sub 0            */   dcl sub1    lit '"215"';   /* sub 1            */   dcl sub2    lit '"216"';   /* sub 2            */   dcl sub3    lit '"217"';   /* sub 3            */   dcl subb0   lit '"274"';   /* subb 0           */   dcl subb1   lit '"275"';   /* subb 1           */   dcl subb2   lit '"276"';   /* subb 2           */   dcl subb3   lit '"277"';   /* subb 3           */   dcl r13     lit '"313"';   dcl mr13    lit '"353"';   dcl mr13i   lit '"373"';   dcl mr0i    lit '"360"';   sr = read(r13);                  /* save r13                       */   write(r13) = addr(answer(0));    /* initialize answer bits to 0000 */   rpc 4;   write(mr13i) = 0;   write(r13) = addr(num(0));       /* initialize numerator to 0010   */   write(mr13i) = 0;                /* note: num is shifted left by   */   write(mr13i) = 32768;            /* one before use.                */   write(mr13i) = 0;   write(mr13i) = 0;   write(r13) = addr(den(0));       /* initialize denom to abcd       */   write(mr13i) = d;   write(mr13i) = c;   write(mr13i) = b;   write(mr13i) = a;   bit = 0;                         /* initialize bit for pre-shift    */   do i = 0 to 65;                  /* compute answer bits             */      /* begin by pre-shifting answer and numerator                    */      write(r13  ) = addr(answer(0));      write(a0   ) = read(mr13);       /* shift answer bits one        */      write(add0 ) = read(a0  );       /* bit to the left              */      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);       /* now also shift numerator     */      write(add0 ) = read(a0  );       /* one bit to the left          */      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = read(a0  );      write(mr13i) = read(a0  );      answer(0) = answer(0) \ bit;     /* or in current answer bit     */      write(r13  ) = addr(num(0));  /* load numerator into a0..a3      */      write(a0   ) = read(mr13i);   /* note: a0 is ls word, a3         */      write(a1   ) = read(mr13i);   /* is ms word                      */      write(a2   ) = read(mr13i);      write(a3   ) = read(mr13i);      write(sub0 ) = read(mr13i);   /* subtract denominator            */      write(subb1) = read(mr13i);      write(subb2) = read(mr13i);      write(subb3) = read(mr13i);      write(mr13i) = read(a0   );   /* store difference                */      write(mr13i) = read(a1   );      write(mr13i) = read(a2   );      write(mr13i) = read(a3   );      if dif(3) < 0 then bit = 0;   /* if negative, shift in 0         */      else do;                      /* else shift in 1 & continue      */         write(r13) = addr(dif(0)); /* copy new difference into        */         write(a0 ) = addr(num(0)); /* numerator                       */         rpc 4;         write(mr0i) = read(mr13i);         bit = 1;      end;   end;   /* Round the ratio up if needed: */   if bit <> 0 then do;      write(r13  ) = addr(answer(0));      write(a0   ) = read(mr13);       /* round answer up by 1         */      write(add0 ) = 1;      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = 0;      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = 0;      write(mr13i) = read(a0  );      write(a0   ) = read(mr13);      write(addc0) = 0;      write(mr13i) = read(a0  );   end;   do i = 0 to 3;      multiply.result(i) = answer(3-i);   end;   multiply.result(4) = 0;   BITMSB   = multiply.result(0);   BITLSB   = multiply.result(1);   MUL.LLSB = multiply.result(2);   if multiply.result(3) < 0 then do;      MUL.LLSB = MUL.LLSB + 1;      IF MUL.LLSB = 0 THEN DO;         BITLSB = BITLSB + 1;         IF BITLSB = 0 THEN         BITMSB = BITMSB + 1;      END;   END;   write(r13) = sr;  /* restore r13 */end LONGINVERT;/* handy routine to perform long addition of very long numbers */multiple.precision.add: proc (a,b,out,n) public swapable;   dcl a    array;   /* input list     (msb in low memory)     */   dcl b    array;   /* input list     (msb in low memory)     */   dcl out  array;   /* output list                            */   dcl n    fixed;   /* number of precision                    */   dcl c    fixed;   c = 0;            /* initialize to no carry in              */   do while n <> 0;      n = n - 1;      if c <> 0 then do;         c = 0;         if (a(n) + b(n)) ILT a(n) then c = 1;         out(n) = a(n) + b(n) + 1;         if out(n) = 0 then c = 1;      end;      else do;         if (a(n) + b(n)) ILT a(n) then c = 1;         out(n) = a(n) + b(n);      end;   end;end multiple.precision.add;/* $SUBTITLE  SMPTE TIME CONVERSION ROUTINES *//* DROP FRAME CODE:   IN 30 FRAME, 25 FRAME, AND 24 FRAME SMPTE,  ONE "SMPTE SECOND"   EXACTLY EQUALS ONE "REAL SECOND".  IN DROP FRAME MODE,  A "SMPTE SECOND"   HAS A VARIABLE LENGTH.   IT IS THE POLICY OF THE SYNCLAVIER PROGRAM TO EXPRESS SMPTE TIMES   SUCH THAT THEY MATCH THE SMPTE READER.  ACCORDINGLY, THE FOLLOWING   ROUTINE IS USED TO MAP FROM "SMPTE TIME" INTO "REAL TIME". *//* BITS -   DROP FRAME CODE:      1,438,560   SMPTE BITS IN EACH 10 MINUTE PERIOD  (17982 FRAMES)          2,400   SMPTE BITS IN SECONDS 0-59, 61-119, 121-179, ETC.          2,240   SMPTE BITS IN SECONDS 60, 120, 180, 240, ETC.             80   SMPTE BITS PER FRAME                          1,438,560=21*64K+62304   30   FRAME CODE:      1,440,000   SMPTE BITS IN EACH 10 MINUTE PERIOD  (18000 FRAMES)          2,400   SMPTE BITS IN EACH SECOND             80   SMPTE BITS PER FRAME                          1,440,000=21*64K+63744   25   FRAME CODE:      1,200,000   SMPTE BITS IN EACH 10 MINUTE PERIOD  (15000 FRAMES)          2,000   SMPTE BITS IN EACH SECOND             80   SMPTE BITS PER FRAME                          1,200,000=18*64K+20352   24   FRAME CODE:      1,152,000   SMPTE BITS IN EACH 10 MINUTE PERIOD  (14400 FRAMES)          1,920   SMPTE BITS IN EACH SECOND             80   SMPTE BITS IN EACH FRAME                          1,152,000=17*64K+37888 */DCL SBITS.PER.FRAME   LIT '80';    /* EACH SMPTE FRAME DIVIDES INTO 80 PARTS */DCL FRAMES.PER.SECOND DATA PUBLIC  /* FRAMES PER SECOND (INDEXED BY SMPTE MODE) */( 30, 30, 25, 24, 30);DCL BITS.PER.DM.MSB DATA           /* SMPTE BITS IN  10 SMPTE MINUTES - MSB */(   21,   21,   18,   17,   21);DCL BITS.PER.DM.LSB DATA           /* SMPTE BITS IN  10 SMPTE MINUTES - LSB */(62304,63744,20352,37888,63744);DCL BITS.PER.24.MSB DATA           /* SMPTE BITS IN  24 SMPTE HOURS   - MSB */( 3160, 3164, 2636, 2531, 3164);DCL BITS.PER.24.LSB DATA           /* SMPTE BITS IN  24 SMPTE HOURS   - LSB */(58880, 4096,47104,16384, 4096);DCL BITS.PER.15.MSB DATA           /* SMPTE BITS IN  15 SMPTE MINUTES - MSB */(   32,   32,   27,   26,   32);DCL BITS.PER.15.LSB DATA           /* SMPTE BITS IN  15 SMPTE MINUTES - LSB */(60688,62848,30528,24064,62848);DCL DMS.PER.BIT.MSB DATA           /* NUMBER OF DECAMINUTES IN EACH SMPTE BIT */( 2985, 2982, 3579, 3728, 2982);   /* 48-BITS TO THE RIGHT OF DECIMAL PT      */DCL DMS.PER.BIT.LSB DATA           /* NUMBER OF DECAMINUTES IN EACH SMPTE BIT */(39438,40381, 9136,17709,40381);   /* IE:  0. 0 2982 40381                    */DCL BITS.PER.SECOND DATA           /* # OF SMPTE BITS IN ONE SMPTE SECOND     */(    0, 2400, 2000, 1920, 2400);   /* NOT USED FOR DROP FRAME COMPUTATION     *//* # OF SMPTE BITS PER MSEC (INDEXED BY SMPTE MODE) *//* 64-BIT VALUES:  A.BCD                            */DCL BITS.PER.MSEC.A  DATA  PUBLIC (    2,     2,    2,     1,     2);DCL BITS.PER.MSEC.B  DATA  PUBLIC (26057, 26214,    0, 60293, 26057);DCL BITS.PER.MSEC.C  DATA  PUBLIC (07444, 26214,    0,  7864, 07444);DCL BITS.PER.MSEC.D  DATA  PUBLIC (58300, 26214,    0, 20971, 58300);/* # OF MSEC PER SMPTE BIT (INDEXED BY SMPTE MODE) *//* 64-BIT VALUES:  A.BCD                           */DCL MSECS.PER.BIT.A  DATA  PUBLIC (    0,     0,     0,     0,     0);DCL MSECS.PER.BIT.B  DATA  PUBLIC (27334, 27306, 32768, 34133, 27334);DCL MSECS.PER.BIT.C  DATA  PUBLIC (   43, 43690,     0, 21845,    43);DCL MSECS.PER.BIT.D  DATA  PUBLIC (48129, 43690,     0, 21845, 48129);/* NOTE - C.HRS, C.MIN, C.SEC, C.FRA, C.BIT MUST BE DECLARED IN ORDER */DCL C.HRS       FIXED PUBLIC; /* GLOBALS USED BY SMPTE COMPUTATION ROUTINES */DCL C.MIN       FIXED PUBLIC; DCL C.SEC       FIXED PUBLIC; DCL C.FRA       FIXED PUBLIC;DCL C.BIT       FIXED PUBLIC;/* $SUBTITLE  ROUTINES TO CONVERT BETWEEN SMPTE TIMES, SMPTE BITS, AND MSEC */NORMALIZE.SMPTE: proc(time,smpte.mode) public swapable;   dcl time        array; /* input smpte time HH:MM:SS:FF.BB */   dcl smpte.mode  fixed; /* 0=drop; 1=non-drop; 2=25fps; 3=24fps */   dcl hrs  lit 'time(0)';   dcl min  lit 'time(1)';   dcl sec  lit 'time(2)';   dcl fra  lit 'time(3)';   dcl bit  lit 'time(4)';   load bit; div sbits.per.frame;               fra=fra+res; bit=rem;   load fra; div frames.per.second(smpte.mode); sec=sec+res; fra=rem;   load sec; div 60;                            min=min+res; sec=rem;   load min; div 60;                            hrs=hrs+res; min=rem;   if smpte.mode=sm#drop then do; /* drop frame mode */      load min; div 10;      if (rem<>0) and (sec=0) and (fra<2) then fra=2;   end;   do while hrs >= 24;   /* Normalize hours to be between 0 and 24 */      hrs = hrs - 24;   end;   do while hrs < 0;      hrs = hrs + 24;   end;end NORMALIZE.SMPTE;SMPTE.TO.SBITS: proc(smpte.time,smode,sbits) public swapable;   dcl smpte.time array;   /* input: hh:mm:ss:ff.bb          */   dcl smode      fixed;   /* SMPTE mode                     */   dcl sbits      array;   /* output: 32-bit smpte bit count */   dcl (i,j,k)    fixed;   dcl (hrs,min,sec,fra,bit) fixed;   dcl msb lit 'sbits(0)';   dcl lsb lit 'sbits(1)';   DO I=0 TO 4; /* COPY INPUT TIME INTO TEMP VALUES */      CORE(ADDR(HRS)+I)=SMPTE.TIME(I);   END;   LOAD HRS; MUL  6; I=  RES;   /* I=HRS*6+MIN/10: COMPUTE # OF 10 MINUTE INTERVALS, 0-143 */   LOAD MIN; DIV 10; I=I+RES;   LOAD REM; MUL 60; J=RES+SEC; /* J=(MIN MOD 10)*60+SEC: COMPUTE # OF SMPTE SECONDS      , 0-599 */   LOAD I; MUL BITS.PER.DM.MSB(SMODE); MSB=RES;   LOAD I; MUL BITS.PER.DM.LSB(SMODE); LSB=RES;                                       MSB=MSB+URES;   IF SMODE=0 THEN DO;              /* DROP FRAME                         */      IF J<>0 THEN DO;              /* COMPUTE # OF BITS IF NOT SECOND 0  */         I=(J-1)  /  60;            /* GET # OF SECONDS WITH 2240 BITS    */         K=( J ) MOD 60;            /* K=0 IF THIS SECOND ONLY HAS 2240   */         LOAD (J-I); MUL 2400;      /* # OF SECONDS WITH 2400 BITS        */           MSB=MSB+URES;         LSB=LSB+RES;         IF LSB ILT RES         THEN MSB=MSB+1;         LOAD ( I ); MUL 2240;      /* # OF SECONDS WITH 2240 BITS        */         MSB=MSB+URES;         LSB=LSB+RES;         IF LSB ILT RES         THEN MSB=MSB+1;         IF K=0 THEN DO;            /* DISALLOW FRAMES 0, 1               */            FRA=FRA-2;            IF FRA<0 THEN DO;               FRA=0; BIT=0;            END;         END;      END;   END;   ELSE DO;                         /* NON - DROP FRAME */      LOAD ( J );                   /* # OF SECONDS     */      MUL BITS.PER.SECOND(SMODE);      MSB=MSB+URES;      LSB=LSB+RES;      IF LSB ILT RES      THEN MSB=MSB+1;   END;   LOAD FRA; MUL SBITS.PER.FRAME;	/* FRAMES */   LSB=LSB+RES;   IF LSB ILT RES   THEN MSB=MSB+1;   LSB=LSB+BIT;							/* BITS  */   IF LSB ILT BIT   THEN MSB=MSB+1;end SMPTE.TO.SBITS;SBITS.TO.SMPTE: proc(sbits,smode,smpte.time) public swapable;   dcl sbits      array;   /* input: 32-bit smpte bit count  */   dcl smode      fixed;   /* SMPTE mode                     */   dcl smpte.time array;   /* output: hh:mm:ss:ff.bb         */   dcl (msb,lsb)  fixed;   dcl i          fixed;   dcl t(1)       fixed;   dcl HRS      lit 'smpte.time(0)';   dcl MIN      lit 'smpte.time(1)';   dcl SEC      lit 'smpte.time(2)';   dcl FRA      lit 'smpte.time(3)';   dcl BIT      lit 'smpte.time(4)';   t(0) = BITS.PER.24.MSB(smode);    /* look up # of smpte bits in */   t(1) = BITS.PER.24.LSB(smode);    /* 24 hours, for this mode    */   call COPY32(Sbits, BitMsbArray);  /* get working copy           */   /* bring smpte bits into range of 0 to 23:59:59:XX.79           */   do while BITMSB < 0;                          /* handle minus   */      call ADD32(BitMsbArray, T, BitMsbArray);   /* times here     */   end;   do while COM32(BitMsbArray, T) >= lw#ieq;     /* handle times   */      call SUB32(BitMsbArray, T, BitMsbArray);   /* > 24 hours     */   end;   MSB = BITMSB; LSB = BITLSB;       /* save copy temporarily      */   CALL MULTIPLY(0,0,DMS.PER.BIT.MSB(SMODE),DMS.PER.BIT.LSB(SMODE));   I=BITLSB+1;                       /* ROUND UP TO BE LARGER */   LOAD I; MUL BITS.PER.DM.MSB(SMODE); BITMSB=RES;   LOAD I; MUL BITS.PER.DM.LSB(SMODE); BITLSB=RES;                                       BITMSB=BITMSB+URES;   DO WHILE (BITMSB IGT MSB)         /* COMPUTE ACTUAL QUOTIENT, REMAINDER */   OR      ((BITMSB = MSB)&(BITLSB IGT LSB));      I=I-1;      LOAD I; MUL BITS.PER.DM.MSB(SMODE); BITMSB=RES;      LOAD I; MUL BITS.PER.DM.LSB(SMODE); BITLSB=RES;                                          BITMSB=BITMSB+URES;   END;   IF LSB ILT BITLSB                 /* NOW COMPUTE REMAINDER - (CHECK FOR BORROW) */   THEN MSB=MSB-BITMSB-1;            /* SUBTRACT WITH BORROW */   ELSE MSB=MSB-BITMSB  ;            /* NORMAL SUBTRACT      */   LSB=LSB-BITLSB;                   /* COMPUTE REMAINDER    */   HRS=(I  /  6);                  /* # OF COMPLETE SMPTE HOURS   */   MIN=(I MOD 6)*10;               /* FIRST PART OF SMPTE MINUTES */   LOAD LSB; ULOAD MSB; DIV SBITS.PER.FRAME;  /* GET FRAME #, REMAINING BITS */   FRA=RES; BIT=REM;             /* FRA = 0-17981, 0-17999, 0-14999, 0-14399 */   IF SMODE=0 THEN DO;               /* DROP FRAME                         */      IF FRA<1800 THEN DO;         /* MINUTE 00 - NO DROP FRAME          */         LOAD FRA; DIV FRAMES.PER.SECOND(SMODE);         SEC=RES; FRA=REM;       /* GET SECONDS 0-59    */      END;      ELSE DO;                       /* ONLY 1798 FRAMES IN EACH MINUTE HEREAFTER */         LOAD FRA-1800; DIV 1798;  /* GET MINUTES */         MIN=MIN+1+RES;          /* ACCOUNT FOR FIRST MINUTE */         LOAD REM+2;                 /* GET FRAME COUNT - OFFSET BY 2 FOR DROPPED FRAME */         DIV FRAMES.PER.SECOND(SMODE);         SEC=RES; FRA=REM;      END;   END;   ELSE DO;                          /* NON - DROP FRAME    */      LOAD FRA;                    /* GET FRA # 0-X       */      DIV FRAMES.PER.SECOND(SMODE);      SEC=RES; FRA=REM;          /* GET SECONDS 0-599   */      LOAD SEC; DIV 60;      MIN=MIN+RES; SEC=REM;   END;   CALL NORMALIZE.SMPTE(SMPTE.TIME,SMODE);  /* LIMIT HOURS TO 0-24 */end SBITS.TO.SMPTE;SBITS.TO.MSEC: proc(sbits,format,speed,smode,msec) public swapable;   dcl sbits     array; /* input 32-bit SMPTE bit count  */   dcl format    fixed; /* time or duration              */   dcl speed     fixed; /* sequencer speed               */   dcl smode     fixed; /* SMPTE mode                    */   dcl msec      array; /* output Synclavier 32-bit msec */   dcl sign      fixed;   /* NOTE: ROUTINE TRASHES BITMSB,BITLSB */   BITMSB=SBITS(0); BITLSB=SBITS(1); /* COPY INPUT TO TEMPS AND SET UP FOR MULTIPLY */   if bitmsb<0 then do;      call neg32(BitMsbArray);      sign = 1;   end;   CALL MULTIPLY(MSECS.PER.BIT.A(SMODE),MSECS.PER.BIT.B(SMODE),MSECS.PER.BIT.C(SMODE),MSECS.PER.BIT.D(SMODE));   IF SPEED<>1000                   /* CORRECT FOR SPEED SETTING */   THEN CALL ratio_multiply(SPEED,1000);   IF FORMAT=CF#TIME THEN DO;       /* ADD ZERO.TIME OFFSET IF A PLAY TIME */      CALL ADD16(ZERO.TIME,LOC(ADDR(BITMSB)));   END;   MSEC(0)=BITMSB; MSEC(1)=BITLSB;  /* COPY ROUNDED TIME INTO OUTPUT ARRAY */   if sign then do;      call neg32(msec);   end;end SBITS.TO.MSEC;MSEC.TO.SBITS: proc(msec,format,speed,smode,sbits) public swapable;   dcl msec      array; /* input Synclavier 32-bit msec  */   dcl format    fixed; /* time or duration              */   dcl speed     fixed; /* sequencer speed               */   dcl smode     fixed; /* SMPTE mode                    */   dcl sbits     array; /* output 32-bit SMPTE bit count */   dcl (msb,lsb) fixed;   dcl sign      fixed;   MSB=MSEC(0); LSB=MSEC(1);                  /* COPY INPUTS INTO TEMPS */   if msb<0 then do;      if lsb = 0 then msb = (- msb);      else do;         lsb = (-   (lsb));         msb = (not (msb));      end;      sign = 1;   end;   IF FORMAT=CF#TIME THEN DO;      IF (MSB=0)&(LSB ILT ZERO.TIME)          /* BEFORE 0.000 - LEAVE AT 0.000 */      THEN LSB=0;      ELSE DO;         IF LSB ILT ZERO.TIME THEN MSB=MSB-1; /* MOVE TO 0.000 FROM FIRST CLICK */         LSB=LSB-ZERO.TIME;      END;   END;   BITMSB=MSB; BITLSB=LSB;                    /* FOR MULTIPLY */   CALL MULTIPLY(BITS.PER.MSEC.A(SMODE),BITS.PER.MSEC.B(SMODE),  /* GET SMPTE */                 BITS.PER.MSEC.C(SMODE),BITS.PER.MSEC.D(SMODE)); /* SINCE START */   IF SPEED<>1000 THEN DO;                      /* CORRECT FOR SPEED SETTING */      IF SPEED=0 THEN DO;                       /* SPEED OF 0 */         IF (BITMSB\BITLSB)<>0 THEN DO;         /* ANY NONZERO TIME IS IN FUTURE!! */            BITMSB=(-1); BITLSB=(-1);           /* SET TO MAX */         END;                                   /* ELSE WILL BE AT 0.000 */      END;      ELSE DO;         CALL ratio_multiply(1000,SPEED);      END;   END;   SBITS(0)=BITMSB; SBITS(1)=BITLSB;   if sign then do;      call neg32(sbits);   end;end MSEC.TO.SBITS;MSEC.TO.SMPTE: proc(msec,format,speed,smode,offset,smpte.time) public swapable;   dcl msec       array;   /* input: 32-bit millisecond time */   dcl format     fixed;   /* time or duration               */   dcl speed      fixed;   /* sequencer speed                */   dcl smode      fixed;   /* smpte mode                     */   dcl offset     array;   /* input: SMPTE offset used only for time format */   dcl smpte.time array;   /* output: hh:mm:ss:ff.bb         */   dcl (msb,lsb)  fixed;   dcl sbits(1)   fixed;   /* smpte bits for "24 hours"      */   dcl (i,j)      fixed;   dcl t(1)       fixed;   /* ROUTINE TRASHES BITMSB, BITLSB, AND C.HRS,C.MIN,C.SEC,C.FRA,C.BIT */   t(0) = BITS.PER.24.MSB(smode);     /* look up # of smpte bits in */   t(1) = BITS.PER.24.LSB(smode);     /* 24 hours,  for this mode   */   CALL MSEC.TO.SBITS(MSEC,FORMAT,SPEED,SMODE,LOC(ADDR(BITMSB)));   do while bitmsb<0;      /* modulo 24 hours for minus times */      call ADD32(BitMsbArray, T, BitMsbArray);   end;   IF FORMAT=CF#TIME THEN DO;                    /* ADD IN SMPTE OFFSET TIME */      I=BITMSB; J=BITLSB;                        /* SAVE FOR ADD */      CALL SMPTE.TO.SBITS(OFFSET,SMODE,LOC(ADDR(BITMSB))); /* GET SMPTE BITS CORRESPONDING TO SEQ START */      BITMSB=BITMSB+I; BITLSB=BITLSB+J;          /* ADD TO SMPTE START TIME */      IF BITLSB ILT J THEN BITMSB=BITMSB+1;      /* CARRY    */   END;   CALL SBITS.TO.SMPTE(LOC(ADDR(BITMSB)),SMODE,LOC(ADDR(C.HRS)));   I=2;                                          /* GET SMPTE ROUNDING   */   IF SPEED<50 THEN I=40;                        /* SLOW SPEED - LIMIT   */   ELSE DO;      LOAD I; MUL 1000; MWAIT; DIV SPEED; I=RES;      IF REM<>0 THEN I=I+1;   END;   IF (C.BIT < I) THEN C.BIT=0;                  /* ROUND DOWN TO FRAME  */   ELSE IF C.BIT > (SBITS.PER.FRAME-I) THEN DO;  /* ROUND UP TO NEXT FR  */      C.BIT=0; C.FRA=C.FRA+1;                    /* (WILL BE NORMALIZED) */   END;   DO I=0 TO 4;                        /* COPY RESULT INTO OUTPUT ARRAY */      SMPTE.TIME(I)=CORE(ADDR(C.HRS)+I);   END;   CALL NORMALIZE.SMPTE(SMPTE.TIME,SMODE);end MSEC.TO.SMPTE;SMPTE.TO.MSEC: proc(smpte.time,format,speed,smode,offset,msec) public swapable;   dcl smpte.time array;   /* input: hh:mm:ss:ff.bb         */   dcl format     fixed;   /* time or duration               */   dcl speed      fixed;   /* sequencer speed                */   dcl smode      fixed;   /* smpte mode                     */   dcl offset     array;   /* input: SMPTE offset used only for time format */   dcl msec       array;   /* output: 32-bit millisecond time */   dcl sbits(1)   fixed;   /* smpte bits for "24 hours"      */   dcl obits (1)  fixed;   dcl t(1)       fixed;   dcl x(1)       fixed;   dcl y(1)       fixed;   /* ROUTINE TRASHES BITMSB, BITLSB, AND C.HRS,C.MIN,C.SEC,C.FRA,C.BIT */   t(0) = BITS.PER.24.MSB(smode);     /* look up # of smpte bits in */   t(1) = BITS.PER.24.LSB(smode);     /* 24 hours,  for this mode   */   x(0) = BITS.PER.15.MSB(smode);     /* look up # of smpte bits in */   x(1) = BITS.PER.15.LSB(smode);     /* 15 minutes for this mode   */   CALL SMPTE.TO.SBITS(SMPTE.TIME,SMODE,LOC(ADDR(BITMSB)));   IF FORMAT=CF#TIME THEN DO;                  /* SUBTRACT OUT SMPTE OFFSET TIME */      CALL SMPTE.TO.SBITS(OFFSET,SMODE,OBITS); /* GET SMPTE BITS CORRESPONDING TO SEQ START */      DO WHILE COM32(BitMsbArray, Obits) = LW#ILT;         CALL ADD32(BitMsbArray, T, BitMsbArray);      END;      CALL SUB32(BitMsbArray, OBITS, BitMsbArray);   END;   /* if more than 23:45:00:00 from now,  map to minus times: */   call SUB32(T, X, Y);        /* get # of bits at 23:45:00:00 */   if COM32(BitMsbArray, Y) >= LW#IEQ   then call SUB32(BitMsbArray, T, BitMsbArray); /* yields minus bits */   CALL SBITS.TO.MSEC(BitMsbArray, FORMAT, SPEED, SMODE, MSEC);end SMPTE.TO.MSEC;ADD.SMPTE: proc(add1,add2,dst,mode) public swapable;   dcl add1  fixed array;   dcl add2  fixed array;   dcl dst   fixed array;   dcl mode  fixed;   dst(0) = add1(0) + add2(0);       /* Add hours   */   dst(1) = add1(1) + add2(1);       /* Add minutes */   dst(2) = add1(2) + add2(2);       /* Add seconds */   dst(3) = add1(3) + add2(3);       /* Add frames  */   dst(4) = add1(4) + add2(4);       /* Add bits    */   call normalize.smpte(dst,mode);end ADD.SMPTE;SUB.SMPTE: proc(src,num,dst,mode) public swapable;   dcl src    fixed array;   dcl num    fixed array;   dcl dst    fixed array;   dcl mode   fixed;   dcl s (4)  fixed;   call blockmove(src,s,5);          /* Make local copy */   if s(4) < num(4) then do;         /* Check borrow */      s(4) = s(4) + sbits.per.frame;      s(3) = s(3) - 1;   end;   dst(4) = s(4) - num(4);           /* Subtract bits */   if s(3) < num(3) then do;         /* Check borrow */      s(3) = s(3) + frames.per.second(mode);      s(2) = s(2) - 1;   end;   dst(3) = s(3) - num(3);           /* Subtract frames */   if s(2) < num(2) then do;         /* Check borrow */      s(2) = s(2) + 60;      s(1) = s(1) - 1;   end;   dst(2) = s(2) - num(2);           /* Subtract seconds */   if s(1) < num(1) then do;         /* Check borrow */      s(1) = s(1) + 60;      s(0) = s(0) - 1;   end;   dst(1) = s(1) - num(1);           /* Subtract minutes */   dst(0) = s(0) - num(0);           /* Subtract hours */   call normalize.smpte(dst,mode);end SUB.SMPTE;/* $SUBTITLE  ROUTINES TO CONVERT BETWEEN FILM FOOTAGE TIMES, FOOTAGE BITS, AND MSEC *//*   s$fmode = 0 => 35mm, 30fps, 16fpf   s$fmode = 1 => 35mm, 25fps, 16fpf   s$fmode = 2 => 35mm, 24fps, 16fpf   s$fmode = 3 => 16mm, 30fps, 40fpf   s$fmode = 4 => 16mm, 25fps, 40fpf   s$fmode = 5 => 16mm, 24fps, 40fpf*/dcl film.fps  data public (30,25,24,30,25,24); /* frames per sec  indexed by FOOTAGE MODE   */dcl film.fpf  data public (16,16,16,40,40,40); /* frames per foot indexed by FOOTAGE MODE   */dcl fbits.per.frame   lit '80';           /* assume each frame divides into 80 parts */dcl fbits.per.foot    data (fbits.per.frame*16,fbits.per.frame*16,fbits.per.frame*16,                            fbits.per.frame*40,fbits.per.frame*40,fbits.per.frame*40);dcl frames.per.fbit.a lit '0';            /* 64-bit fraction = 1/80 */dcl frames.per.fbit.b lit '819';dcl frames.per.fbit.c lit '13107';dcl frames.per.fbit.d lit '13107';FEET.TO.FBITS: proc(footage,fmode,fbits) public swapable; /* convert footage to 80ths of film frames */   dcl footage array;              /* input: feet/frames.fbits           */   dcl fmode   fixed;              /* FILM FOOTAGE mode                  */   dcl fbits   array;              /* output: 32-bit frame bit count     */   dcl sign    fixed;   dcl feet    fixed;   dcl fra     fixed;   dcl bit     fixed;   /* note: handles minus footages, yields minus fbits */   dcl msb  lit 'fbits(0)';   dcl lsb  lit 'fbits(1)';   feet = footage(0);   fra  = footage(1);   bit  = footage(2);   if (feet<0) or (fra<0) or (bit<0)   then do;      feet = (- feet);      fra  = (- fra );      bit  = (- bit );      sign = 1;   end;   LOAD FEET; ULOAD FRA; MUL FILM.FPF(FMODE);   /* LINEAR FRAME COUNT */   MSB=URES; LSB=RES;   LOAD MSB; MUL FBITS.PER.FRAME; MSB=RES; /* CONVERT FRAMES TO 32-BIT FBIT COUNT */   LOAD LSB; MUL FBITS.PER.FRAME; MSB=MSB+URES; LSB=RES;   LSB=LSB+BIT;                            /* ADD IN EXTRA FBITS */   IF LSB ILT BIT THEN MSB=MSB+1;   if sign                                 /* return - number    */   then call neg32(fbits);                 /* if desired         */end FEET.TO.FBITS;FBITS.TO.FEET: proc(fbits,fmode,footage) public swapable; /* convert 80ths of frames to footage */   dcl fbits   array;              /* input: 32-bit frame bit count      */   dcl fmode   fixed;              /* FILM FOOTAGE mode                  */   dcl footage array;              /* output: feet/frames.fbits          */   dcl msb     fixed;   dcl lsb     fixed;   dcl sign    fixed;   /* note: handles minus fbits, yields minus footage */   dcl feet lit 'footage(0)';   dcl fra  lit 'footage(1)';   dcl bit  lit 'footage(2)';   msb = fbits(0);   lsb = fbits(1);   if msb<0 then do;                  /* if - bits,  then */      if lsb = 0 then msb = (- msb);  /* negate           */      else do;                        /* Must use two's   */         lsb = (-   (lsb));           /* complement       */         msb = (not (msb));           /* negate           */      end;      sign = 1;   end;   LOAD LSB; ULOAD MSB; DIV FBITS.PER.FOOT(FMODE); FEET=RES;   LOAD REM;            DIV FBITS.PER.FRAME;       FRA=RES;   BIT=REM;   if sign then do;      feet = (- feet);      fra  = (- fra );      bit  = (- bit );   end;end FBITS.TO.FEET;FBITS.TO.MSEC: proc(fbits,format,speed,fmode,msec) public swapable; /* converts film footage subframe bits to Synclavier msec */   dcl fbits     array; /* input: 32-bit frame bit count */   dcl format    fixed; /* time or duration              */   dcl speed     fixed; /* sequencer speed               */   dcl fmode     fixed; /* FILM FOOTAGE mode             */   dcl msec      array; /* output Synclavier 32-bit msec */   dcl sign      fixed;   /* NOTE: ROUTINE TRASHES BITMSB,BITLSB */   BITMSB=FBITS(0); BITLSB=FBITS(1); /* COPY INPUT TO TEMPS AND SET UP FOR MULTIPLY */   if bitmsb < 0 then do;      call neg32(BitMsbArray);      sign = 1;   end;   CALL ratio_multiply(1000,FILM.FPS(FMODE)*FBITS.PER.FRAME); /* 1.920 BITS PER MSEC AT 24 FPS & 2.000 BITS PER MSEC AT 25 FPS */   IF SPEED<>1000                   /* CORRECT FOR SPEED SETTING */   THEN CALL ratio_multiply(SPEED,1000);   IF FORMAT=CF#TIME THEN DO;       /* ADD ZERO.TIME OFFSET IF A PLAY TIME */      BITLSB=BITLSB+ZERO.TIME;      IF BITLSB ILT ZERO.TIME      THEN BITMSB=BITMSB+1;   END;   MSEC(0)=BITMSB; MSEC(1)=BITLSB;  /* COPY ROUNDED TIME INTO OUTPUT ARRAY */   if sign   then call neg32(msec);end FBITS.TO.MSEC;MSEC.TO.FBITS: proc(msec,format,speed,fmode,fbits) public swapable; /* converts Synclavier msec to film footage subframe bits */   dcl msec      array; /* input Synclavier 32-bit msec   */   dcl format    fixed; /* time or duration               */   dcl speed     fixed; /* sequencer speed                */   dcl fmode     fixed; /* FILM FOOTAGE mode              */   dcl fbits     array; /* output: 32-bit frame bit count */   dcl sign      fixed;   BITMSB=MSEC(0); BITLSB=MSEC(1);            /* COPY INPUTS INTO TEMPS */   if bitmsb < 0 then do;      call neg32(BitMsbArray);      sign = 1;   end;   IF FORMAT=CF#TIME THEN DO;      IF (BITMSB=0)&(BITLSB ILT ZERO.TIME)          /* BEFORE 0.000 - LEAVE AT 0.000 */      THEN BITLSB=0;      ELSE DO;         IF BITLSB ILT ZERO.TIME THEN BITMSB=BITMSB-1; /* MOVE TO 0.000 FROM FIRST CLICK */         BITLSB=BITLSB-ZERO.TIME;      END;   END;   CALL ratio_multiply(FILM.FPS(FMODE)*FBITS.PER.FRAME,1000); /* 1.920 BITS PER MSEC AT 24 FPS & 2.000 BITS PER MSEC AT 25 FPS */   IF SPEED<>1000 THEN DO;                      /* CORRECT FOR SPEED SETTING */      IF SPEED=0 THEN DO;                       /* SPEED OF 0 */         IF (BITMSB\BITLSB)<>0 THEN DO;         /* ANY NONZERO TIME IS IN FUTURE!! */            BITMSB=(-1); BITLSB=(-1);           /* SET TO MAX */         END;                                   /* ELSE WILL BE AT 0.000 */      END;      ELSE DO;         CALL ratio_multiply(1000,SPEED);      END;   END;   FBITS(0)=BITMSB; FBITS(1)=BITLSB;   if sign   then call neg32(fbits);end MSEC.TO.FBITS;MSEC.TO.FEET: proc(msec,format,speed,fmode,offset,footage) public swapable; /* converts Synclavier msec to Film Footage */   dcl msec       array;   /* input: 32-bit millisecond time */   dcl format     fixed;   /* time or duration               */   dcl speed      fixed;   /* sequencer speed                */   dcl fmode      fixed;   /* Film Footage Mode              */   dcl offset     array;   /* input: FOOTAGE offset used only for time format */   dcl footage    array;   /* output: feet/frames.fbits      */   dcl (i,j)      fixed;   dcl feet lit 'footage(0)';   dcl fra  lit 'footage(1)';   dcl bit  lit 'footage(2)';   /* ROUTINE TRASHES BITMSB, BITLSB, AND C.HRS,C.MIN,C.SEC,C.FRA,C.BIT */   CALL MSEC.TO.FBITS(MSEC,FORMAT,SPEED,FMODE,LOC(ADDR(BITMSB)));   IF FORMAT=CF#TIME THEN DO;                    /* ADD IN FOOTAGE OFFSET TIME */      I=BITMSB; J=BITLSB;                        /* SAVE FOR ADD */      CALL FEET.TO.FBITS(OFFSET,FMODE,LOC(ADDR(BITMSB))); /* GET SUBFRAME BITS CORRESPONDING TO SEQ START */      BITMSB=BITMSB+I; BITLSB=BITLSB+J;          /* ADD TO FOOTAGE OFFSET */      IF BITLSB ILT J THEN BITMSB=BITMSB+1;      /* CARRY                 */   END;   CALL FBITS.TO.FEET(LOC(ADDR(BITMSB)),FMODE,FOOTAGE);   I=2;                                          /* DO ROUNDING          */   IF SPEED<050 THEN I=40;                       /* SLOW SPEED - LIMIT   */   ELSE DO;      LOAD I; MUL 1000; MWAIT; DIV SPEED; I=RES;      IF REM<>0 THEN I=I+1;   END;   IF (abs(BIT) < I) THEN BIT=0;                /* ROUND DOWN TO FRAME  */   ELSE IF abs(BIT) > (FBITS.PER.FRAME-I) THEN DO;   /* ROUND UP TO NEXT FR  */      if bit < 0 then do;         BIT=0; FRA=FRA-1;         IF FRA=(-FILM.FPF(FMODE))         THEN DO;                                   /* ADVANCE SECONDS      */            FRA=0; FEET=FEET-1;         END;      END;      else do;         BIT=0; FRA=FRA+1;         IF FRA=FILM.FPF(FMODE)         THEN DO;                                   /* ADVANCE SECONDS      */            FRA=0; FEET=FEET+1;         END;      END;   END;end MSEC.TO.FEET;FEET.TO.MSEC: proc(footage,format,speed,fmode,offset,msec) public swapable; /* converts Film Footage to Synclavier msec */   dcl footage    array;   /* input: feet/frames.fbits        */   dcl format     fixed;   /* time or duration                */   dcl speed      fixed;   /* sequencer speed                 */   dcl fmode      fixed;   /* Film Footage Mode               */   dcl offset     array;   /* input: FOOTAGE offset used only for time format */   dcl msec       array;   /* output: 32-bit millisecond time */   dcl obits (1)  fixed;   /* ROUTINE TRASHES BITMSB, BITLSB, AND C.HRS,C.MIN,C.SEC,C.FRA,C.BIT */   CALL FEET.TO.FBITS(FOOTAGE, FMODE, BitMsbArray);   IF FORMAT=CF#TIME THEN DO;                   /* SUBTRACT OUT FOOTAGE OFFSET TIME */      CALL FEET.TO.FBITS(OFFSET, FMODE, OBITS); /* GET SUBFRAME BITS CORRESPONDING TO SEQ START */      CALL SUB32(BitMsbArray, Obits, BitMsbArray);   END;   CALL FBITS.TO.MSEC(BitMsbArray, FORMAT, SPEED, FMODE, MSEC);end FEET.TO.MSEC;NORMALIZE.FEET: proc(footage,fmode) public swapable;   dcl footage array; /* input footage: feet/frames.fbits */   dcl fmode   fixed; /* Film Footage Mode */   dcl feet   lit 'footage(0)';   dcl frames lit 'footage(1)';   dcl fbits  lit 'footage(2)';   load fbits;  div fbits.per.frame; frames=frames+res; fbits =rem;   load frames; div film.fpf(fmode); feet  =feet  +res; frames=rem;end NORMALIZE.FEET;ADD.FEET: proc(add1,add2,dst,mode) public swapable;   dcl add1  fixed array;   dcl add2  fixed array;   dcl dst   fixed array;   dcl mode  fixed;   dcl x(1)  fixed;   dcl y(1)  fixed;   call FEET.TO.FBITS (add1, mode,x);  /* get fbits for two's compl add */   call FEET.TO.FBITS (add2, mode,y);  /* get fbits for two's compl add */   call ADD32(x, y, y);                 /* two's complement              */   call FBITS.TO.FEET(y, mode, dst); /* convert 80ths of frames to footage */end ADD.FEET;SUB.FEET: proc(src,num,dst,mode) public swapable;   dcl src    fixed array;   dcl num    fixed array;   dcl dst    fixed array;   dcl mode   fixed;   dcl x(1)  fixed;   dcl y(1)  fixed;   call FEET.TO.FBITS (src, mode, x);  /* get fbits for two's compl add */   call FEET.TO.FBITS (num, mode, y);  /* get fbits for two's compl add */   call SUB32(x, y, y);   call FBITS.TO.FEET(y, mode, dst); /* convert 80ths of frames to footage */end SUB.FEET;/* $SUBTITLE  ROUTINES TO CONVERT BETWEEN MSEC AND BEATS *//* NOTE:  Some general conventions used in the following routines: *//*            1. The input arrays are not trashed by the           *//*               procedure calls.                                  *//*            2. However, it is okay to pass the same array for    *//*               both the input and output.  This will result in   *//*               replacing the input values with the converted     *//*               values.                                           *//* converts beats and fracs of a beat to milliseconds */BEATS.TO.MSEC: proc(beats,format,click.period,msec) public swapable;   dcl beats        array; /* input time (beats & fractions 0-999) */   dcl format       fixed;   dcl click.period fixed;   dcl msec         array; /* 32-bit output milliseconds */   dcl beat         fixed;   dcl frac         fixed;   dcl sign         fixed;   beat = beats(0);       /* get whole beats            */   frac = beats(1);       /* and fractions 0 - 999      */   if (beat<0) or (frac<0)   then do;      beat  = (- beat);      frac  = (- frac);      sign  = 1;   end;   if  (format = cf#time)  /* time format                */   and (beat <> 0       )  /* make sure valid            */   and (sign  = 0       )  /* positive only              */   then beat = beat - 1;   /* beat 1 is 0.000            */   load frac; mul click.period; mwait;  /* convert fractional beats 0-999 to ms. */   div 1000;   frac = res;   if rem ige (shr(1000,1)) then frac=frac+1;   load beat; uload frac;           /* convert beats to ms  */   mul click.period;   msec(0) = ures; msec(1) = res;   if format=cf#time then do;        /* need to add in zero.time */      msec(1)=msec(1)+zero.time;      if msec(1) ilt zero.time then msec(0)=msec(0)+1;   end;   if sign   then call neg32(msec);end BEATS.TO.MSEC;/* converts a 32 bit duration into beats and parts of a beat */MSEC.TO.BEATS: proc(msec,format,click.period,beats) public swapable;   dcl msec         array; /* input 32-bit milliseconds */   dcl format       fixed;   dcl click.period fixed;   dcl beats        array;  /* output beats(0) and fractions(1) of beats */   dcl (msb,lsb)    fixed;   dcl sign         fixed;   msb=msec(0); lsb=msec(1); /* get local copies so we don't trash input array */   if msb<0 then do;      if lsb = 0 then msb = (- msb);      else do;         lsb = (-   lsb);         msb = (not msb);      end;      sign = 1;   end;   IF FORMAT=CF#TIME THEN DO;      IF (MSB=0)&(LSB ILT ZERO.TIME)          /* BEFORE 0.000 - LEAVE AT 0.000 */      THEN LSB=0;      ELSE DO;         IF LSB ILT ZERO.TIME THEN MSB=MSB-1; /* MOVE TO 0.000 FROM FIRST CLICK */         LSB=LSB-ZERO.TIME;      END;   END;   load lsb; uload msb;   div click.period;   if  (format = cf#time)     /* if time, then start counting      */   and (sign   = 0      )     /* with 1.000 (if positive)          */   then beats(0) = res+1;     /* users count beats starting with 1 */   else beats(0) = res;       /* beat duration starts with 0       */   load rem; mul 1000; mwait;   div click.period;   beats(1) = res;   if rem ige (shr(click.period,1)) then beats(1)=beats(1)+1; /* round */   if beats(1)=1000 then do;      beats(1)=0;      beats(0)=beats(0)+1;   end;   if sign then do;      beats(0) = (- beats(0));      beats(1) = (- beats(1));   end;END MSEC.TO.BEATS;NORMALIZE.BEATS: proc(beats.bits) public swapable;   dcl beats.bits fixed array;   dcl n#beats  lit 'beats.bits(0)';   dcl n#bits   lit 'beats.bits(1)';   load n#bits;  div 1000; n#beats=n#beats+res; n#bits =rem;end NORMALIZE.BEATS;ADD.BEATS: proc(add1,add2,dst) public swapable;   dcl add1  fixed array;   dcl add2  fixed array;   dcl dst   fixed array;   dcl x(1)  fixed;   dcl y(1)  fixed;   call BEATS.TO.MSEC (add1, cf#dur, 1000, x);   call BEATS.TO.MSEC (add2, cf#dur, 1000, y);   call ADD32(x, y, y);   call MSEC.TO.BEATS(y, cf#dur, 1000, dst);end ADD.BEATS;SUB.BEATS: proc(src,num,dst) public swapable;   dcl src    fixed array;   dcl num    fixed array;   dcl dst    fixed array;   dcl x(1)  fixed;   dcl y(1)  fixed;   call BEATS.TO.MSEC (src, cf#dur, 1000, x);   call BEATS.TO.MSEC (dst, cf#dur, 1000, y);   call SUB32(x, y, y);   call MSEC.TO.BEATS(y, cf#dur, 1000, dst);end SUB.BEATS;insert ':synsou:mathmod:mathsoub';end MATHMOD;