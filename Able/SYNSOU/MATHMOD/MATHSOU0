/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: MATHSOU0PATH:		 :SYNSOU:MATHMOD:MATHSOU0CONTAINS: MORE 32-BIT MATH ROUTINES AND SOME OTHER STUFFREVISION HISTORY:00	1999/11/02	Todd Yvega	Created.*/module MATHMOD0;/*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/insert ':SYNLITS:COMLITS';		//	dcl pdl.size  lit '1500';insert ':SYNLITS:GLOBLITS'; 	//	D4567 and external memory literalsinsert ':-XPL:ASCIILIT';insert ':SYNLITS:L#ASM.0';		//	TY's pseudo assembly language literalsdcl free.r0	lit 'if (false) write(reg_dst|r0) = read(reg_src|r0)';	//	cool compiler trick/*ииииииииииииииии  E X T E R N A L   R E F E R E N C E S  ииииииииииииииии*///	insert ':-xpl:intrprtr';	//	only needed if temporary test code is enabledinsert ':SYNMODS:TTYDCL';		//	pc(), ps(), pnum(), cpos()dcl (BITMSB,BITLSB)	fixed			external;dcl MUL.LLSB			fixed			external;dcl MULTIPLY.RESULT	fixed array	external;dcl STR32	proc (fixed,fixed,fixed array)						external;dcl ADD16	proc (fixed,fixed array)								external;dcl SUB16	proc (fixed,fixed array)								external;dcl ADD32	proc (fixed array,fixed array,fixed array)		external;dcl SUB32	proc (fixed array,fixed array,fixed array)		external;dcl COM32	proc (fixed array,fixed array) returns (fixed)	external;dcl COM16	proc (fixed,fixed array)		 returns (fixed)	external;dcl COPY32	proc (fixed array,fixed array)						external;dcl SHL32	proc (fixed array,fixed)								external;dcl SHR32	proc (fixed array,fixed)								external;dcl NEG32	proc (fixed array)										external;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE sqroot																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	This quickly produces the truncated integer square root (unsigned 16-bit radicand to 8-bit result)sqroot: proc(radicand) returns (fixed) public swapable;	dcl radicand fixed;	dcl (bit, a, b, a_squared, b_squared, estimate_squared) fixed;	if (radicand ile 1) return radicand;	a = shr(radicand,1); bit = 0;	while (a != 0) {a = shr(a,1); bit = bit+1;}	//	bit = highest bit set (log base 2)	bit = shr(bit,1);										//	bit = 1/2 highest bit set (truncated)	a = shl(1,bit); b = a;					//	set up a	load a; mul a; a_squared = res;		//	set up a^2		while (bit != 0) {		bit = bit-1;		b = shr(b,1);							//	set up b		load b; mul b; b_squared = res;	//	set up b^2		load a; mul b;							//	set up 2ab (res+res)		estimate_squared = a_squared + res+res + b_squared;	//	(a+b)^2 = a^2 + 2ab + b^2		if (estimate_squared ile radicand) {			a = a+b; a_squared = estimate_squared;		}	}	return a;end sqroot;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE print_u32															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Prints the input 32-bit value as an unsigned integer//	Possible improvements://		interpret as signed or unsigned//		print with commas//		optional pointprint_u32: proc (input32,align) public swapable;	dcl input32		fixed array;	dcl align				boolean;	//	if true, insert leading spaces for table alignment	dcl (msw,lsw)			fixed;	//	copy of input to work with	dcl (index1,index2)	fixed;	//	index2 must be initialized to 0 if this procedure is made nonrecursive!	dcl strng(5)			fixed;	msw = input32(0); lsw = input32(1);	//	step 1: repeatedly divide by 10, filling the array from the right side	index1 = 9;	//	byte pointer into string	while (msw != 0) {		load msw; div 10; msw = res; write(reg_dst|r13) = rem;		load lsw; uload read(reg_src|r13); div 10; lsw = res;		pbyte(strng,index1,rem+a.0); index1 = index1-1;	}	while (lsw igt 9) {		load lsw; div 10; lsw = res;		pbyte(strng,index1,rem+a.0); index1 = index1-1;	}	pbyte(strng,index1,lsw+a.0);	//	step 2: clean up the string and print the result	if (align == false) {		//	ripple the string forward and set the length accordingly 		while (index2 != 10-index1) {			pbyte(strng,index2,byte(strng,index2+index1)); index2 = index2+1;		}		strng(0) = index2;	}	else {		//	fill the leading bytes with spaces and set the length to 10		while (index2 != index1) {			pbyte(strng,index2,a.space); index2 = index2+1;		}		strng(0) = 10;	}	ps(strng);end print_u32;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE ratio_multiply													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/ratio_multiply: proc (num,den) public swapable;	dcl (num,den)	fixed;	//	multiply up to 48-bit, then divide back down to 32 bit	load BITLSB;	mul num;	BITLSB = res; write("313") = ures;	load BITMSB; uload read("313");	mul num; mwait;	div den;	BITMSB = res; write("313") = rem;	load BITLSB; uload read("313");	div den;	BITLSB = res; write("313") = rem;	//	round: the fdiv method	load 0; uload read("313");	div den;	if (res < 0) {		BITLSB = BITLSB+1;		if (BITLSB == 0) BITMSB = BITMSB+1;	//	carry	}	MUL.LLSB = res;	//	for possible later use by UNROUND()end ratio_multiply;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE mul_32by32															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Multiply two 32-bit unsigned quantities to achieve a 64-bit product.//	For now, the product will be left in MATHMOD's static array "multiply.result".mul_32by32: proc (multiplicand32,multiplier32) public swapable;	dcl multiplicand32		fixed array;	dcl multiplier32			fixed array;	//	store the addresses of our arrays before starting assembly code	write(reg_dst|r4)	= read(reg_src|r0);	//	the compiler has placed addr(multiplicand32(0)) in r0	write(reg_dst|r5)	= read(reg_src|r1);	//	the compiler has placed addr(multiplier32(0)) in r1	write(reg_dst|r6)	= addr(multiply.result(0));	//	for outputting later (the addr function will glom r2)	//	START PSEUDO-ASSEMBLY CODE	write(reg_dst|r13)	= read(reg_src		 |r4);	//	to reset r4 after it has been incremented	write("5")				= read(mem_src|incr|r4);	//	load multiplicand32(0) to D5	write("6")				= read(mem_src		 |r5);	//	multiply by multiplier32(0)	write(load_acc	|a1)	= read("5");					//	load the lower result into accumulator 1	write(load_acc	|a0)	= read("4");					//	load the upper result into accumulator 0	write("5")				= read(mem_src		 |r4);	//	load multiplicand32(1) to D5	write("6")				= read(mem_src|incr|r5);	//	multiply by multiplier32(0)	write(load_acc	|a2)	= read("5");					//	load the lower result into accumulator 2	write(add		|a1)	= read("4");					//	add the upper result into accumulator 1	write(add_carry|a0)	= read(imm_src|0);			//	carry any overflow from the previous add		write(reg_dst	|r4)	= read(reg_src		 |r13);	//	re-point r4 to multiplicand32(0)	write("5")				= read(mem_src|incr|r4);	//	load multiplicand32(0) to D5	write("6")				= read(mem_src		 |r5);	//	multiply by multiplier32(1)	write(add		|a2)	= read("5");					//	add the lower result into accumulator 2	write(add_carry|a1)	= read("4");					//	add the upper result into accumulator 1 carrying any overflow from the previous add	write(add_carry|a0)	= read(imm_src|0);			//	carry any overflow from the previous add	write("5")				= read(mem_src		 |r4);	//	load multiplicand32(1) to D5	write("6")				= read(mem_src		 |r5);	//	multiply by multiplier32(1)	write(load_acc	|a3)	= read("5");					//	load the lower result into accumulator 3	write(add		|a2)	= read("4");					//	add the upper result into accumulator 2	write(add_carry|a1)	= read(imm_src|0);			//	carry any overflow from the previous add	write(add_carry|a0)	= read(imm_src|0);			//	carry any overflow from the previous add	//	output the product	write(mem_dst|incr|r6)	= read(reg_src|r0);		//	multiply.result(0) = accumulator0	write(mem_dst|incr|r6)	= read(reg_src|r1);		//	multiply.result(1) = accumulator1	write(mem_dst|incr|r6)	= read(reg_src|r2);		//	multiply.result(2) = accumulator2	write(mem_dst		|r6)	= read(reg_src|r3);		//	multiply.result(3) = accumulator3end mul_32by32;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE div_64by32															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Divide a 64-bit divisor by a 32-bit dividend to achieve a 32-bit rounded quotient.//	For now, the product left in MATHMOD's static variable "multiply.result" is used as the divisor.//	Note: This is not a general purpose routine!  It's only written to work for the expected range of input.div_64by32: proc (input_dividend32,output_quotient32) public swapable;	dcl input_dividend32		fixed array;	dcl output_quotient32	fixed array;	dcl scalar16						fixed;	dcl divisor64				(3)	fixed;	dcl dividend32				(1)	fixed;	dcl scaled_dividend16			fixed;	dcl partial_quotient32	(1)	fixed;	dcl quotient32				(1)	fixed;	dcl done								fixed;	//	for readability	dcl scaled_divisor64	lit 'multiply.result';	dcl product64			lit 'multiply.result';	dcl difference32		lit 'partial_quotient32';	//	make local copies of input arrays	write(reg_dst|r4)			= addr(divisor64(0));	write(reg_dst|r5)			= addr(multiply.result(0));	write("10")					= read(imm_src|3);	//	repeat next instruction 4 times	write(mem_dst|incr|r4)	= read(mem_src|incr|r5);	dividend32(0) = input_dividend32(0);	dividend32(1) = input_dividend32(1);	//	step 1: see if we can easily reduce the ratio until the dividend < 64K	if (dividend32(0) != 0) {		dcl divisor_lsw	lit 'done';		dcl dividend_lsw	lit 'scaled_dividend16';		divisor_lsw  = divisor64(3);		dividend_lsw =	dividend32(1);		write(reg_dst|r13) = divisor_lsw|dividend_lsw;		if	(read(reg_src|r13) == 0) {			/*			write(reg_dst|r12) = addr(divisor64(3));			rpc 3;			write(mem_dst|incr|r12) = read(mem_src|r12);			write(mem_dst|r12) = 0;			*/			divisor64(3) = divisor64(2);			divisor64(2) = divisor64(1);			divisor64(1) = divisor64(0);			divisor64(0) = 0;			dividend32(1) = dividend32(0);			dividend32(0) = 0;		}		else {			scalar16 = 1;			while ((read(reg_src|r13)&1) == 0) {				scalar16 = shl(scalar16,1);				divisor_lsw = shr(divisor_lsw,1);				dividend_lsw = shr(dividend_lsw,1);				write(reg_dst|r13) = divisor_lsw|dividend_lsw;			}			if (scalar16 != 1) {				//	divide divisor and dividend by scalar16				load dividend32(0);				div scalar16;//				if (res == 0) {	//	if (res != 0) then there's no point in pursuing this any further?				dividend32(0) = res; write(reg_dst|r13) = rem;				load dividend32(1); uload read(reg_src|r13);				div scalar16;				dividend32(1) = res;	//	there will be no remainder				load divisor64(0);				div scalar16;				divisor64(0) = res; write(reg_dst|r13) = rem;				load divisor64(1); uload read(reg_src|r13);				div scalar16;				divisor64(1) = res; write(reg_dst|r13) = rem;				load divisor64(2); uload read(reg_src|r13);				div scalar16;				divisor64(2) = res; write(reg_dst|r13) = rem;				load divisor64(3); uload read(reg_src|r13);				div scalar16;				divisor64(3) = res;	//	there will be no remainder//				}			}		}	}	//	step 2: if the dividend is only a 16-bit quantity then we can avoid all the hoopla	if (dividend32(0) == 0) {		//	if (divisor64(0) != 0) {ertyp = err.overflow; return}		free.r0;	//	make sure the following calls to addr() won't glom the registers we're writing to		write(reg_dst		|r4)	= addr(divisor64(1));		write(reg_dst		|r5)	= addr(quotient32(0));		write(reg_dst		|r6)	= dividend32(1);				//	this value will be referenced repeatedly		write(reg_dst		|r13)	= read(mem_src|incr|r4);	//	treat divisor64(1) as a remainder		write("5")					= read(mem_src|incr|r4);	//	load divisor64(2)		write("4")					= read(reg_src		 |r13);	//	uload remainder		write("7")					= read(reg_src		 |r6);	//	div dividend32(1)		write(mem_dst|incr|r5)	= read("5");					//	quotient32(0) = res		write(reg_dst		|r13)	= read("4");					//	save remainder		write("5")					= read(mem_src		 |r4);	//	load divisor64(3)		write("4")					= read(reg_src		 |r13);	//	uload remainder		write("7")					= read(reg_src		 |r6);	//	div dividend32(1)		write(mem_dst		|r5)	= read("5");					//	quotient32(1) = res		write(reg_dst		|r13)	= read("4");					//	save remainder		//	round using fractional divide		write("5")					= read(imm_src		 |0);		//	load 0		write("4")					= read(reg_src		 |r13);	//	uload remainder		write("7")					= read(reg_src		 |r6);	//	div dividend32(1)		if (res < 0) add16(1,quotient32);		copy32(quotient32,output_quotient32);		return;	}	//	If we've gotten this far then we are forced to divide by a 32-bit quantity.  (Actually we	//	could possibly further reduce the ratio by using iterative subtraction to find the GCD,	//	but this would likely take longer than just powering through the following procedure.)	//	//	32-bit division can be accomplished fairly quickly with the D4567 using the following method:	//	Scale the divisor and dividend by the 16-bit scalar necessary to get the dividend just under 64K.	//	Multiply the resulting quotient by the original 32-bit dividend, and subtract this product from	//	the original divisor.  If the difference is less than the original dividend, then we're done	//	and this difference is the remainder.  Otherwise we repeat the process.  In most cases we'll only	//	have to repeat once or not at all.	//	str32(0,0,quotient32);	//	initialize if not automatic	//	step 3: determine scalar to use from here on	load dividend32(1); uload dividend32(0);	div -1;	if (rem != 0) load res+1;	//	ensure that dividend/scalar < 64K	scalar16 = res;	//	step 4: determine 16-bit dividend to use from here on	load dividend32(1); uload dividend32(0);	div scalar16;	if (rem != 0) load res+1;	//	ensure that dividend*scaled_divisor/scaled_dividend < divisor	scaled_dividend16 = res;	//	step 5: scale divisor for the first iteration of the loop	//	scaled_divisor64(0) = 0;	//	this is never referenced	load divisor64(1); uload divisor64(0);	div scalar16;	scaled_divisor64(1) = res; write(reg_dst|r13) = rem;	load divisor64(2); uload read(reg_src|r13);	div scalar16;	scaled_divisor64(2) = res; write(reg_dst|r13) = rem;	load divisor64(3); uload read(reg_src|r13);	div scalar16;	scaled_divisor64(3) = res;	//	the remainder is discarded to ensure that dividend*scaled_divisor/scaled_dividend < divisor	done = false;	while (done == false) {		//	step 6: get partial quotient (scaled_divisor64/scaled_dividend16)		load scaled_divisor64(2); uload scaled_divisor64(1);		div scaled_dividend16;		partial_quotient32(0) = res; write(reg_dst|r13) = rem;		load scaled_divisor64(3); uload read(reg_src|r13);		div scaled_dividend16;		partial_quotient32(1) = res;		//	the remainder is discarded to ensure that dividend*partial_quotient < divisor		//	step 7: add this into the accumulated sum of all partial quotients and multiply this resulting quotient by the original dividend		add32(partial_quotient32,quotient32,quotient32);		mul_32by32(quotient32,dividend32);		//	step 8: subtract this product from the original divisor		free.r0;	//	make sure the following calls to addr() won't glom the registers we're writing to		write(reg_dst		|r4)	= addr(divisor64(1));	//	the high words are irrelevant		write(reg_dst		|r5)	= addr(product64(1));		write(reg_dst		|r6)	= addr(difference32(0));		write(load_acc		|a1)	= read(mem_src|incr|r4);		write(load_acc		|a2)	= read(mem_src|incr|r4);		write(load_acc		|a3)	= read(mem_src		 |r4);		write(subtract  	|a1)	= read(mem_src|incr|r5);		write(subtract  	|a2)	= read(mem_src|incr|r5);		write(sub_borrow	|a1)	= read(imm_src|0);	//	borrow if necessary		write(subtract  	|a3)	= read(mem_src		 |r5);		write(sub_borrow	|a2)	= read(imm_src|0);	//	borrow if necessary		write(sub_borrow	|a1)	= read(imm_src|0);	//	borrow if necessary		write(mem_dst|incr|r6)	= read(reg_src		 |r2);	//	difference32(0) = accumulator2		write(mem_dst		|r6)	= read(reg_src		 |r3);	//	difference32(1) = accumulator3		//	repeat steps 5 through 8 if necessary		write(reg_dst|r13) =  com32(difference32,dividend32);		if	(read(reg_src|r13) == lw#igt) {		//	difference exceeds dividend - must take another pass			//	step 4: scale divisor for the next iteration of the loop			scaled_divisor64(1) = 0;			load difference32(0);			div scalar16;			scaled_divisor64(2) = res; write(reg_dst|r13) = rem;			load difference32(1); uload read(reg_src|r13);			div scalar16;			scaled_divisor64(3) = res;			//	the remainder is discarded to ensure that dividend*scaled_divisor/scaled_dividend < divisor			//	however, me must guard against the possibility that scaled_divisor64 = scaled_dividend16-1			//	which can happen due to the fact that divisors are truncated whereas dividends are rounded up			if ((scaled_divisor64(2) == 0) && (scaled_divisor64(3) == scaled_dividend16-1)) {				add16(1,quotient32);					//	unity fraction - increment quotient and exit				done = true;			}		}		else {			if	(read(reg_src|r13) == lw#ilt) {	//	difference is less than dividend - round and exit				//	step 9: round & exit				//	at this point the remainder is in difference32				load difference32(1);				mul 2;				difference32(1) = res; write(reg_dst|r13) = ures;				load difference32(0); uload read(reg_src|r13);				mul 2;				difference32(0) = res;				if ((ures != 0) || (com32(difference32,dividend32) == lw#igt)) add16(1,quotient32);			}			else add16(1,quotient32);				//	difference equals dividend - increment quotient and exit			done = true;		}	}	//	end of while (done == false)	copy32(quotient32,output_quotient32);end div_64by32;#if(false)	//	beginning of temporary test code/*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/insert ':SYNAUXS:ERRLITS';		//	err.oom//	for selecting the preferred random number generator	dcl random	lit 'sedgewick_random';//	dcl random	lit 'chamberlin_random';/*ииииииииииииииии  E X T E R N A L   R E F E R E N C E S  ииииииииииииииии*/insert ':SYNMODS:GLOBDCL';		//	ertypinsert ':SYNRDCLS:03-PDCLS';	//	nah.ptr, nah.free, nah.#free/*иииииииииииииииииии  P U B L I C   V A R I A B L E S  иииииииииииииииииии*///	as usual with upper/lower word pairs, keep them declared in orderdcl (random_msw,random_lsw)	fixed;	//	seed for random number generatorrandom_msw = 139*149;	//	product of prime numbers surrounding the square root of 0b0101010101010101random_lsw = 199*211;	//	product of prime numbers surrounding the square root of 0b1010101010101010/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE chamberlin_random												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	A simple generator (linear congruential type) of uniformly distributed pseudo random numbers//	ranging from 0 to range.  The default range of 0 to 65535 is returned if you pass either//	0 or 65535 (-1).//	Note: this actually generates numbers in the range of 0 to (2^32)-1.  The mod function is//	achieved simply by letting the 32-bit arithmentic overflow.  Since the lower bits are less random//	than the higher bits, the most significant word is used for the returned value.  The values//	for the multiplier and addend were taken from a table in Hal Chamberlin's book, which claims//	that these values will produce a non-repeating sequence length of 2^32.chamberlin_random: proc (range) returns (fixed) public swapable;	dcl range		fixed;	//	multiplier = 196314165	dcl multiplier_msw	lit  '2995';	dcl multiplier_lsw	lit '33845';	//	addend = 907633515	dcl addend_msw			lit '13849';	dcl addend_lsw			lit '25451';	//	set up for speed	write(reg_dst	|r13)	= read(reg_src		 |r0);	//	the compiler has placed the value passed to "range" in r0	free.r0;	//	make sure the subsequent call to addr() doesn't mess with the register we're writing to	write(reg_dst	|r4)	= addr(random_msw);	write(reg_dst	|r5)	= read(reg_src		 |r4);	//	so we can easily reset an incremented r4 back to random_msw	write(reg_dst	|r6) 	= read(mem_src|incr|r17);	//	load the next data word to r6 and incr program counter	write(shr(multiplier_lsw,8))	= read(multiplier_lsw & lsb_mask);	//	data word is multiplier_lsw (this value will be accessed twice)	//	multiply (random_msw,lsw * multiplier_msw,lsw) with 32 bit truncation	write("5")				= read(mem_src|incr|r4);	//	load random_msw	write("6")				= read(reg_src		 |r6);	//	mul multiplier_lsw	write(reg_dst	|r7)	= read("5");					//	save the lower word of the product		write("5")				= read(mem_src		 |r4);	//	load random_lsw	write("4")				= read(reg_src		 |r7);	//	the previously saved product will be summed with the next one	write("6")				= read(mem_src|incr|r17);	//	multiply by the next data word (multiplier_msw)	write(shr(multiplier_msw,8))	= read(multiplier_msw & lsb_mask);	//	data word is multiplier_msw	write(load_acc	|a0)	= read("5");					//	truncated sum of these two products in accumulator 0	write("5")				= read(mem_src		 |r4);	//	load random_lsw	write("6")				= read(reg_src		 |r6);	//	mul multiplier_lsw	write(load_acc	|a1)	= read("5");					//	write lower word of this product to lower accumulator	write(add		|a0)	= read("4");					//	add upper word of this product into upper accumulator	//	add in addend_msw,lsw with 32 bit truncation	write(add		|a1)	= read(mem_src|incr|r17);	//	add next data word (addend_lsw) into lower accumulator	write(shr(addend_lsw,8))		= read(addend_lsw & lsb_mask);		//	data word is addend_lsw	write(add_carry|a0)	= read(mem_src|incr|r17);	//	add next data word (addend_msw) into upper accumulator, carrying from the previous add	write(shr(addend_msw,8))		= read(addend_msw & lsb_mask);		//	data word is addend_msw	//	write out the new random_msw,random_msw	write(reg_dst		|r4)	= read(reg_src|r5);	//	reset r4 to random_msw	write(mem_dst|incr|r4)	= read(reg_src|r0);	//	accumulator 0 to random_msw	write(mem_dst		|r4)	= read(reg_src|r1);	//	accumulator 1 to random_lsw	//	return 16-bit value	write("5")	= read(reg_src|r0);	//	load new value of random_msw (we're about to glom registers)	//	scale if desired (r13 holds the value of "range")	if ((read(reg_src|r13) != 0) && (read(reg_src|r13) != -1)) {		mul read(reg_src|r13);		mwait;		div -1;		if (rem < 0) load res+1;	}	return res;end chamberlin_random;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE sedgewick_random													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	This variation of the linear congruential method is from Robert Sedgewick's book "Algorithms".//	It differs from Hal Chamberlin's version in that it uses an addend of 1 and the multiplier is//	chosen in accordance with Donald E. Knuth's rules://		it should be one digit less than the modulus (in base 10)//		it should take the form ...x21 where x is even, and ... exhibits no particular patternsedgewick_random: proc (range) returns (fixed) public swapable;	dcl range		fixed;	//	multiplier = 178339021	dcl multiplier_msw	lit  '2721';	dcl multiplier_lsw	lit '15565';	//	set up for speed	write(reg_dst	|r13)	= read(reg_src		 |r0);	//	the compiler has placed the value passed to "range" in r0	free.r0;	//	make sure the subsequent call to addr() doesn't mess with the register we're writing to	write(reg_dst	|r4)	= addr(random_msw);	write(reg_dst	|r5)	= read(reg_src		 |r4);	//	so we can easily reset an incremented r4 back to random_msw	write(reg_dst	|r6) 	= read(mem_src|incr|r17);	//	load the next data word to r6 and incr program counter	write(shr(multiplier_lsw,8))	= read(multiplier_lsw & lsb_mask);	//	data word is multiplier_lsw (this value will be accessed twice)	//	multiply (random_msw,lsw * multiplier_msw,lsw) with 32 bit truncation	write("5")				= read(mem_src|incr|r4);	//	load random_msw	write("6")				= read(reg_src		 |r6);	//	mul multiplier_lsw	write(reg_dst	|r7)	= read("5");					//	save the lower word of the product		write("5")				= read(mem_src		 |r4);	//	load random_lsw	write("4")				= read(reg_src		 |r7);	//	the previously saved product will be summed with the next one	write("6")				= read(mem_src|incr|r17);	//	multiply by the next data word (multiplier_msw)	write(shr(multiplier_msw,8))	= read(multiplier_msw & lsb_mask);	//	data word is multiplier_msw	write(load_acc	|a0)	= read("5");					//	truncated sum of these two products in accumulator 0	write("5")				= read(mem_src		 |r4);	//	load random_lsw	write("4")				= read(imm_src		 |1);		//	add 1 to our final result	write("6")				= read(reg_src		 |r6);	//	mul multiplier_lsw	write(load_acc	|a1)	= read("5");					//	write lower word of this product to lower accumulator	write(add		|a0)	= read("4");					//	add upper word of this product into upper accumulator	//	write out the new random_msw,random_msw	write(reg_dst		|r4)	= read(reg_src|r5);	//	reset r4 to random_msw	write(mem_dst|incr|r4)	= read(reg_src|r0);	//	accumulator 0 to random_msw	write(mem_dst		|r4)	= read(reg_src|r1);	//	accumulator 1 to random_lsw	//	return 16-bit value	write("5")	= read(reg_src|r0);	//	load new value of random_msw (we're about to glom registers)	//	scale if desired (r13 holds the value of "range")	if ((read(reg_src|r13) != 0) && (read(reg_src|r13) != -1)) {		mul read(reg_src|r13);		mwait;		div -1;		if (rem < 0) load res+1;	}	return res;end sedgewick_random;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE chi_square															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	This chi_square test builds an array of length range+1 in the nah area for keeping track of//	the frequency of occurrence for each number in the range. chi_square: proc (range,seed_msw,seed_lsw) swapable;	dcl (range,seed_msw,seed_lsw)	fixed;	dcl sample						fixed;	dcl index16						fixed;	dcl index32				(1)	fixed;	dcl num_samples32		(1)	fixed;	//	32-bit number of samples taken	dcl sum_of_squares32	(1)	fixed;	dcl array_base					fixed;	//	absolute sector of our array in extmem	dcl numsectors					fixed;	//	sector length of our array in extmem	dcl stop.recd.move.play.xpos.cont.eras proc external;	stop.recd.move.play.xpos.cont.eras();	//	stop any performance	disable;	//	don't let the interrupt routines mess with the NAH area until we leave this procedure	//	as with the random() function, a range of 0 is interpreted to mean full range (65535)	if (range == 0)	range = -1;	//	ииииииииииииииии step 1: set up num_samples32 иииииииииииииииииииииииииииииииииииииииииииииииииии	//	To get a meaningful chi square value, the number of samples taken should be greater than	//	10 times (range+1).  Lets use the nearest multiple of 256 above 10 times (range+1).	if (range == -1)	{		load 0;		uload 10;	}	else {		load range+1;		mul 10; mwait;	}	div 256;	load res+1;;	mul 256;	num_samples32(1) = res;	num_samples32(0) = ures;	//	ииииииииииииииии step 2: initialize the extmem array ииииииииииииииииииииииииииииииииииииииииииии	//	make sure we have enough memory in the NAH area for our array	if (range == -1)	{		load 0;		uload 1;	}	else load range+1;	div 256;	if (rem != 0) load res+1;	numsectors = res;	write(reg_dst|r13) = nah.ptr + nah.len + numsectors;	//	if there is not enough memory in NAH area, see if sacrificing the timbre bank will get us enough	if (read(reg_src|r13) ige bnk.ptr) {		//	if there is not enough memory in NAH and Timbre Bank area combined, then report the problem and bail		if (read(reg_src|r13) ige bnk.ptr + bnk.len) {			ertyp = err.oom;			enable;	//	allow Synclavier real time operation to resume			return;		}		//	else toss the Timbre Bank		bnk.ptr = bnk.ptr + bnk.len;		bnk.len = 0;	}	array_base = nah.ptr + nah.len;	nah.len = nah.len + numsectors;	//	Fill the extmem array with zeros	write(reg_dst|r13) = 255;	do index16 = 0 to numsectors-1;		write(mam)	= array_base + index16;		write("10")	= read(reg_src|r13);		write(mdi)	= read(imm_src|0);	end;	//	ииииииииииииииии step 3: count the frequency of occurrence for each number in the range иииииииии	str32(0,0,index32);	random_msw = seed_msw; random_lsw = seed_lsw;	while (com32(index32,num_samples32) == lw#ilt) {		sample = random(range);		write(mam) = array_base + shr(sample,8);		write(mal) = sample & 255;		write(md ) = read(md)+1;		add16(1,index32);	}	//	ииииииииииииииии step 4: get the sum of the squares of all the frequencies ииииииииииииииииииииии	str32(0,0,sum_of_squares32);	str32(0,range,index32); add16(1,index32);	write(mam) = array_base;	while ((index32(1) != 0) || (index32(0) == 1)) {	//	while (com16(0,index32) != lw#ieq)		load read(mdi);		mul res;	//	square the frequency		add16(res,sum_of_squares32);		sub16(1,index32);	}	//	ииииииииииииииии step 5: calculate chi square иииииииииииииииииииииииииииииииииииииииииииииииииии	//	chi_square = (sum_of_squares32 * (range+1) / num_samples32) - num_samples32	//	use index32 to hold the possibly 17-bit value of range+1	str32(0,range,index32); add16(1,index32);	//	return (sum_of_squares32 * (range+1) / num_samples32) in sum_of_squares32	mul_32by32(sum_of_squares32,index32); div_64by32(num_samples32,sum_of_squares32);	sub32(sum_of_squares32,num_samples32,sum_of_squares32);	//	sum_of_squares32 now holds the chi square value	//	ииииииииииииииии step 6: report the results иииииииииииииииииииииииииииииииииииииииииииииииииииии	if (range == -1)	index16 = 512;	else					index16 = 2*sqroot(range+1);	print_u32(num_samples32,false);	ps (' samples were taken from a range of 0 to ');	pnum(range,0);	ps (' using a seed of: ');	print_u32(loc(addr(seed_msw)),false); pcr();	ps ('A chi square value of ');	print_u32(index32,false);	ps (' plus or minus ');	pnum(index16,0);	psr(' indicates a reasonably uniform');	ps ('distribution.  The closer the chi square value is to ');	print_u32(index32,false);	psr(', the more uniform the');	ps ('distribution is.  The chi square value for this sampling is: ');	print_u32(sum_of_squares32,false); pcr();	//	ииииииииииииииии step 7: clean up иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии	nah.len = array_base - nah.ptr;	//	restore nah.len to it's original value	enable;									//	allow Synclavier real time operation to resumeend chi_square;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE compare_results													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/compare_results: proc (input) swapable;	dcl input					 fixed;	dcl (result1,result2)(1) fixed;	dcl (num,den)				 fixed;	dcl number_of_tests		 fixed;	dcl this_test_BITMSB		 fixed;	dcl this_test_BITLSB		 fixed;	dcl trouble					 boolean;	trouble = false;	//	a reasonable test?	do number_of_tests = 0 to input-1;		this_test_BITMSB	= random(0);		this_test_BITLSB	= random(0);		num					= random(0);		den					= random(0);		if (num igt den) {	//	make sure denominator is greater than numerator			write("313") = num;			num = den;			den = read("313");		}		BITMSB = this_test_BITMSB;		BITLSB = this_test_BITLSB;		ratiomultiply(num,den);		result1(0) = BITMSB;		result1(1) = BITLSB;		BITMSB = this_test_BITMSB;		BITLSB = this_test_BITLSB;		ratio_multiply(num,den);		result2(0) = BITMSB;		result2(1) = BITLSB;		if ((result1(0) != result2(0)) || (result1(1) != result2(1))) trouble = true;	end;	if (trouble != false) print 'WARNING, WILL ROBINSON!';	else						 print 'Oh Goody!';end compare_results;#endif	//	end of temporary test codeend MATHMOD0;