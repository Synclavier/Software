...   MATHDOC......   Modified:...   11 Jun 1987    MWH   Added 32 bit routine documentation....ce~MATHMOD - 32 bit unsigned routines~.sp 2.ppThe following routines manipulate 32 bit unsigned quantities whichare used mostly as pointers into large address spaces.  The 32 bitdata is stored in an array of two fixed numbers, with the most significantbits first (lw#msb), followed by the least significant bits (lw#lsb).STR32(msb,lsb,dst32);.in +5Takes two fixed numbers (msb,lsb) and stores them in a 32 bitarray dst32..in -5ADD16(num16,dst32);.in +5Adds a 16 bit unsigned number to the 32 bit array..in -5SUB16(num16,dst32);.in +5Subtracts a 16 bit unsigned number from the 32 bit array..in -5ADD32(add1,add2,dst);.in +5Adds 32 bit numbers in add1 to add2 and puts the results in dst.  This will work with signed or unsigned 32 bit numbers.  It will also work if any or all of add1, add2 and dst are the same array..in -5SUB32(src,num,dst);.in +5Takes a 32 bit number in src, subtracts num from it and puts the results in dst.  This will only work correctly for 32 bit unsigned numbers but will work if any or all of src, num and dst are the same array..in -5COM32(a,b) returns (fixed);.in +5Compares unsigned 32 bit numbers in a and b and returns:.nf   lw#igt   if a > b   lw#ieq   if a = b   lw#ilt   if a < b.fi.in -5COM16(a16,b32) returns (fixed);.in +5Compares the unsigned fixed number in a16 with the unsigned 32 bit number in b32 and returns:.nf   lw#igt   if a16 > b32   lw#ieq   if a16 = b32   lw#ilt   if a16 < b32.fi.in -5COPY32(src,dst);.in +5Copies the 32 bit number in src to dst..in -5SHL32(num,amount);.in +5Shifts the 32 bit number "num" left by the amount specified..in -5SHR32(num,amount);.in +5Shifts the 32 bit number "num" right by the amount specified..in -5.bp.ce               ~MATHMOD - continued~.nf.lg 10.rm 60SOUND FILES REQUIRE THE FOLLOWING COMPUTATION TO COMPUTE A STARTING AND ENDING FILE POSITION FROM A STARTING AND ENDING TIME~TIME_TO_INDEX~    computes a sample time from a sound file     position where seconds, milliseconds, and     microseconds represent time. khz is sampling rate     in kHz*10 and stereo indicates if sound file is     stereo or mono.    NOTE:  It sets the globals     sector.msb, sector.numb and sector.offset.    call TIME_TO_INDEX (seconds,milliseconds,microseconds,                        khz,stereo);~PERIOD_TIME_TO_INDEX~    original version - based on d66 sample periods    computes a sample time from a sound file     position where seconds, milliseconds, and     microseconds represent time.    NOTE:  It sets the globals     sector.msb, sector.numb and sector.offset.    call PERIOD_TIME_TO_INDEX(seconds,milliseconds,                              microseconds,periods);~INDEX_TO_TIME~    converts address to time:  works for sector     numbers up to 24 bits, and times up to 32 bits     of milliseconds.    NOTE: It sets the globals     time.seconds, time.milliseconds, time.microseconds.     call INDEX_TO_TIME (sector.msb,sector.number,sector.offset,                        khz,stereo);    where sector.msb and sector.number represent     the sector number and sector.offset is the word     offset.  kHz is the sampling rate*10 and stereo     indicates if the sound file is stereo or mono..bp~INDEX_TO_PERIOD_TIME~    original version - based on d66 sample periods    convert sectors to time:  works for sector numbers    up to 24 bits, sampling periods up to 29,999,    and times up to 32 bits of milliseconds.    NOTE: It sets the globals     time.seconds, time.milliseconds, time.microseconds.     call INDEX_TO_PERIOD_TIME(sector.msb,sector.number,                                sector.offset,periods)