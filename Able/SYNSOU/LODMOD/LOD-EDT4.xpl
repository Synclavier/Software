/* :SYNSOU:LODMOD:LOD-EDT4  $TITLE  Routines to Edit Cue Record Reels (Part 4) *//* 04/25/91 - cj  - Rounded certain edits to sector boundary          *//*                  to fix Don Dorsey edit bugs                       *//* 07/29/88 - cj  - fixed bug in slide if clip.ptr = des.ptr          *//* 08/10/88 - cj  - store absolute # of smpte bits in cue record      *//* 08/08/88 - cj  - fixed usage of S$Soffset in clear.edits.from.reel *//* $SUBTITLE  Routine to Copy Part of a Reel */COPY.FROM.REEL: proc(Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr          fixed; /* external memory sector ptr to cue to delete from */   dcl Des.Ptr          fixed; /* xmem ptr to destination cue */   dcl Protect.Des.Name fixed; /* set true to preserve name of Dest Cue Record */      /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   return Extract.From.Reel.With.Extend(Sou.Ptr,Des.Ptr,Protect.Des.Name);end COPY.FROM.REEL;/* $SUBTITLE  Routine to Cut Out Part of a Reel (Puts Extracted Info in 2nd Reel) */CUT.FROM.REEL: proc(Sou.Ptr,Des.Ptr,Cut.Ptr,Protect.Des.Name,Protect.Cut.Name) fixed public swapable;   dcl Sou.Ptr          fixed; /* xmem ptr to cue to cut from */   dcl Des.Ptr          fixed; /* xmem ptr to cue to put left over material in */   dcl Cut.Ptr          fixed; /* xmem ptr to cue to put cut material in */   dcl Protect.Des.Name fixed; /* set true to preserve name of Dest Cue Record */   dcl Protect.Cut.Name fixed; /* set true to preserve name of Cut  Cue Record */   dcl Edit.In      (1) fixed;   dcl Edit.Out     (1) fixed;      /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   /*       CUT.PTR & DES.PTR cannot be the same.        */   if Cut.Ptr=Des.Ptr then do; /* consistency check */      E$Status=E#SysErr;      return E$Status;   end;   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out)=lw#igt   /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out)=lw#ieq   /* EDIT IN point equals EDIT OUT point */   then do;      E$Status=E#NoRegionSelected;      return E$Status;   end;   if Sou.Ptr<>Cut.Ptr   then E$Status=Copy.Cue(Sou.Ptr,Cut.Ptr,Protect.Cut.Name);   else if Sou.Ptr<>Des.Ptr   then E$Status=Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name);   if E$Status<>E#Good then return E$Status;   E$Status=Extract.From.Reel.With.Extend(Cut.Ptr,Cut.Ptr,false);   if E$Status<>E#Good then return E$Status;   return Delete.From.Reel(Des.Ptr,Des.Ptr,false);   end CUT.FROM.REEL;/* $SUBTITLE  Special Merge Routine used by PASTE and FILL */MERGE.EDIT.LISTS: proc (Sou.Ptr,Des.Ptr,Edit.In) fixed swapable;   dcl Sou.Ptr           fixed; /* xmem ptr to cue to merge into DES.PTR */    dcl Des.Ptr           fixed; /* xmem ptr to the output cue    */   dcl Edit.In           array; /* logical address to merge at   */   dcl (Num.Sou.Segs)    fixed;   dcl (Num.Des.Segs,S#) fixed;   dcl Des.Seg#          fixed;   dcl Cue.In        (1) fixed;   dcl Seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   /* NOTE: Routine is NOT a general EDL Merge procedure. */   /*       It should only be used to merge EDLs which    */   /*       do not overlap at all. (Used by PASTE & FILL) */   load Cue.Lookup(Des.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Des.Segs=res;                          /* number of edit segments in cue */   load Cue.Lookup(Sou.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Sou.Segs=res;                          /* number of edit segments in cue */   load Max.Cue.Record.Len-Cue.Lookup(Des.Ptr,Cue.List.Ptr);   div  Cue.Seg.Stride;            /* max number of edit segments that fit in this cue */   if (Num.Des.Segs+Num.Sou.Segs) igt res    then return E#TooLong;          /* no room in cue record for merge */   Des.Seg#=0;   call Get.Edit.Segment(Des.Ptr,Des.Seg#,Seg); /* read in 1st segment from dest */   do while (Des.Seg# ilt Num.Des.Segs)      and   (Com32(loc(addr(Seg(S#Sync.Msb))),Edit.In)=lw#ilt);      Des.Seg#=Des.Seg#+1;      if Des.Seg# ilt Num.Des.Segs      then call Get.Edit.Segment(Des.Ptr,Des.Seg#,Seg); /* read in next segment from dest */   end;   /* at this point, DES.SEG# points to the merge start point */   if (Num.Des.Segs-Des.Seg#)<>0 then do; /* shuffle segments beyond merge point up in memory */      /* create gap in edit list to merge in new segments */      call Shuffle.Edit.Segments(Des.Ptr,                                 Des.Seg#,Des.Seg#+Num.Sou.Segs,                                 Num.Des.Segs-Des.Seg#);    end;   call Read.Cue.Time(Sou.Ptr,Cue.S.Msb,Cue.In); /* look up original IN addr of paste material */   do S#=0 to Num.Sou.Segs-1;                 /* loop over all segments */      call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* read in segment from source */      call Sub32(loc(addr(Seg(S#Sync.Msb))),Cue.In ,loc(addr(Seg(S#Sync.Msb))));      call Add32(loc(addr(Seg(S#Sync.Msb))),Edit.In,loc(addr(Seg(S#Sync.Msb))));      call Put.Edit.Segment(Des.Ptr,Des.Seg#,Seg);      Des.Seg#=Des.Seg#+1;   end;                                        /* of loop over segments */   load Num.Des.Segs+Num.Sou.Segs;             /* recompute EDL length */   mul  Cue.Seg.Stride; S#=res;   call Cue.Store  (Des.Ptr,Cue.List.Len,S#);  /* save new lengths back in */   S#=S#+Cue.Lookup(Des.Ptr,Cue.List.Ptr);     /* dest. cue                */   call Cue.Store  (Des.Ptr,Cue.RLen    ,S#);   return E#Good;    /* merge was successful */end MERGE.EDIT.LISTS;/* $SUBTITLE  Routine to Paste One Reel into Another Reel */PASTE.INTO.REEL: proc(Sou.Ptr,Paste.Ptr,Des.Ptr,Protect.Des.Name,Loop.Paste) fixed public swapable;   dcl Sou.Ptr          fixed; /* xmem ptr to cue to paste into */   dcl Paste.Ptr        fixed; /* xmem ptr to cue to paste      */   dcl Des.Ptr          fixed; /* xmem ptr to the output cue    */   dcl Protect.Des.Name fixed; /* set to true to preserve name of Des cue */   dcl Loop.Paste       fixed; /* set to true to allow looping of PASTE.PTR to complete paste */   dcl Edit.In      (1) fixed; /* logical address to begin paste at */   dcl Edit.Out     (1) fixed;   dcl Edit.Len     (1) fixed;   dcl T            (1) fixed; /* time buffer */   dcl Tin          (1) fixed;   dcl Tout         (1) fixed;   /* NOTE:  Routine can do an in-place paste (i.e., SOU.PTR=DES.PTR  */   /*        and/or SOU.PTR=PASTE.PTR).                               */   /*        Routine assumes SCRATCH.CUE.PTR1 and SCRATCH.CUE.PTR2    */   /*        and CUE.BUILD.PTR point to cue records.                  */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb,Edit.In); /* look up paste point */   if Loop.Paste then do;      call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out);      call Sub32(Edit.Out,Edit.In,Edit.Len);               /* length to paste in */   end;   else do;      call Get.Cue.Duration(Paste.Ptr,Edit.Len);           /* length of cue to be pasted */      call Add32(Edit.In,Edit.Len,Edit.Out);               /* end time of pasted material */   end;   if Com32(Edit.In,Edit.Out)=lw#igt   /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if (Com32(Edit.In,Edit.Out) = lw#ieq)    /* disallow PASTE LEN = ( 0, 0) */   or (Edit.Len(0)=(-1) & Edit.Len(1)=(-1)) /* and      PASTE LEN = (-1,-1) */   then do;      E$Status=E#NoRegionSelected;      return E$Status;   end;   /* Round after performing region check to avoid changing the cue       */   /* when we know we can't do the edit                                   */   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call ROUND.EDIT.TIMES(Paste.Ptr);   /* round to sector bounds          */   /* Also round in & out times of Paste.Ptr because that is the region   */   /* that we paste in                                                    */   call Read.Cue.Time(Paste.Ptr,Cue.S.Msb,Tin);  /* get actual in and out */   call Read.Cue.Time(Paste.Ptr,Cue.E.Msb,Tout); /* times for paste cue   */   call ROUND.REGION.TIMES(Tin, Tout);   call Write.Cue.Time(Paste.Ptr,Cue.S.Msb,Tin);   call Write.Cue.Time(Paste.Ptr,Cue.E.Msb,Tout);   /* Look up times again because they may have changed                   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb,Edit.In); /* look up paste point */   if Loop.Paste then do;      call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out);      call Sub32(Edit.Out,Edit.In,Edit.Len);               /* length to paste in */   end;   else do;      call Get.Cue.Duration(Paste.Ptr,Edit.Len);           /* length of cue to be pasted */      call Add32(Edit.In,Edit.Len,Edit.Out);               /* end time of pasted material */   end;   if (Com32(Edit.In,Edit.Out) >= lw#ieq)      /* double check times */   or (Edit.Len(0)=(-1) & Edit.Len(1)=(-1))    /* after rounding     */   then do;                                    /* to avoid system    */      E$Status=E#NoRegionSelected;             /* errors             */      return E$Status;   end;   if Loop.Paste then do;      call Copy.Cue(Paste.Ptr,Cue.Build.Ptr,false); /* copy to temp cue */      call Read.Cue.Time   (Cue.Build.Ptr,Cue.S.Msb,T);      call Write.Cue.Time  (Cue.Build.Ptr,Cue.Edit.In.Msb,T); /* set up to paste at cue in point */      call Get.Cue.Duration(Cue.Build.Ptr,T);      do while Com32(T,Edit.Len)=lw#ilt;        /* loop until temp cue is long enough */         if Paste.Into.Reel(Cue.Build.Ptr,Paste.Ptr,Cue.Build.Ptr,false,false)<>E#Good         then return E$Status; /* paste failed */         call Get.Cue.Duration(Cue.Build.Ptr,T);      end;      call Read.Cue.Time (Cue.Build.Ptr,Cue.S.Msb,T); /* set cue OUT point to end at */      call Add32(T,Edit.Len,T);                 /* specified edit length    */      if Com32(T,Edit.Len)=lw#ilt then do;      /* overflow */         T(0)=(-1); T(1)=(-1);      end;      call Write.Cue.Time(Cue.Build.Ptr,Cue.E.Msb,T);   end;   call Copy.Cue(Sou.Ptr,Scratch.Cue.Ptr2,false); /* copy to temp cue */   call Write.Cue.Time(Scratch.Cue.Ptr2,Cue.Edit.Out.Msb,Edit.Out); /* save PASTE OUT addr in Des cue */   if Insert.Leader.On.Reel(Scratch.Cue.Ptr2,Scratch.Cue.Ptr2,false)<>E#Good   then return E$Status;   /* Extract segments from Paste Cue that will be pasted.       */   /* Extract cannot be done until after above INSERT, since     */   /* the insert requires the use of the SCRATCH.CUE.PTR1 buffer */   if Loop.Paste   then call Copy.Cue(Cue.Build.Ptr,Scratch.Cue.Ptr1,false); /* copy looped version to temp cue */   else call Copy.Cue(Paste.Ptr    ,Scratch.Cue.Ptr1,false); /* copy to temp cue */   call Read.Cue.Time (Scratch.Cue.Ptr1,Cue.S.Msb        ,T);  /* copy Cue IN & OUT addrs */   call Write.Cue.Time(Scratch.Cue.Ptr1,Cue.Edit.In.Msb  ,T);  /* over to Edit IN & OUT points */   call Read.Cue.Time (Scratch.Cue.Ptr1,Cue.E.Msb        ,T);   call Write.Cue.Time(Scratch.Cue.Ptr1,Cue.Edit.Out.Msb ,T);   if Extract.From.Reel.Without.Extend(Scratch.Cue.Ptr1,Scratch.Cue.Ptr1,false)<>E#Good   then return E$Status;   E$Status=Merge.Edit.Lists(Scratch.Cue.Ptr1,Scratch.Cue.Ptr2,Edit.In);   if E$Status<>E#Good then return E$Status;   call Garbage.Collect.Reel(Scratch.Cue.Ptr2); /* eliminate unecessary edit segments */   E$Status=Copy.Cue(Scratch.Cue.Ptr2,Des.Ptr,Protect.Des.Name);   call Write.Cue.Time(Des.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* save PASTE OUT addr in Des cue */   return E$Status;                           /* edit was successful */end PASTE.INTO.REEL;/* $SUBTITLE  Routine to Chain a Reel onto the End of Another Reel */CHAIN.ONTO.REEL: proc (Sou.Ptr,Chain.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr          fixed; /* xmem ptr to cue to chain onto */   dcl Chain.Ptr        fixed; /* xmem ptr to cue to chain with */   dcl Des.Ptr          fixed; /* xmem ptr to the output cue    */   dcl Protect.Des.Name fixed; /* set to true to preserve name of Des cue */   dcl Out          (1) fixed;   call Read.Cue.Time(Sou.Ptr,Cue.E.Msb,Out); /* look up OUT time of source cue */   call Write.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Out); /* set up edit times for */   call Write.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Out); /* paste to end of cue */   return Paste.Into.Reel(Sou.Ptr,Chain.Ptr,Des.Ptr,Protect.Des.Name,false);end CHAIN.ONTO.REEL;/* $SUBTITLE  Routine to Replace Part of a Reel with a Another Reel */FILL.REEL: proc(Sou.Ptr,Fill.Ptr,Des.Ptr,Protect.Des.Name,Loop.Fill) fixed public swapable;   dcl Sou.Ptr          fixed; /* xmem ptr to cue to fill into  */   dcl Fill.Ptr         fixed; /* xmem ptr to cue to fill from  */   dcl Des.Ptr          fixed; /* xmem ptr to the output cue    */   dcl Protect.Des.Name fixed; /* set to true to preserve name of Des cue */   dcl Loop.Fill        fixed; /* set to true to allow looping of FILL.PTR to complete fill */   dcl OK               fixed;   dcl Des.Seg#         fixed;   dcl Edit.In      (1) fixed; /* logical address to begin paste at */   dcl Edit.Out     (1) fixed;   dcl Edit.Len     (1) fixed;   dcl Cue.In       (1) fixed;   dcl (T)          (1) fixed; /* time buffer */   dcl (Tin,Tout)   (1) fixed;   /* NOTE:  Routine can do an in-place fill (i.e., SOU.PTR=DES.PTR  */   /*        or SOU.PTR=FILL.PTR).                                   */   /*        Routine assumes SCRATCH.CUE.PTR1 and SCRATCH.CUE.PTR2   */   /*        and CUE.BUILD.PTR point to cue records.                 */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up IN & OUT times for FILL */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out);   call Sub32(Edit.Out,Edit.In,Edit.Len);                 /* compute length of selected region */   if Com32(Edit.In,Edit.Out) = lw#igt /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out) = lw#ieq /* EDIT IN point equal to EDIT OUT point */   then do;      E$Status=Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name);      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   call Sub32(Edit.Out,Edit.In,Edit.Len);                 /* compute length of selected region */   call ROUND.EDIT.TIMES(Fill.Ptr);    /* round to sector bounds          */   /* Also round in & out times of Fill.Ptr because that is the region    */   /* that we fill with                                                   */   call Read.Cue.Time(Fill.Ptr,Cue.S.Msb,Tin);   /* get actual in and out */   call Read.Cue.Time(Fill.Ptr,Cue.E.Msb,Tout);  /* times for fill cue    */   call ROUND.REGION.TIMES(Tin, Tout);   call Write.Cue.Time(Fill.Ptr,Cue.S.Msb,Tin);   call Write.Cue.Time(Fill.Ptr,Cue.E.Msb,Tout);   call Get.Cue.Duration(Fill.Ptr,T);           /* get length of cue to fill from */   call Copy.Cue(Fill.Ptr,Cue.Build.Ptr,false); /* copy to temp cue */   if Com32(T,Edit.Len)=lw#ilt then do; /* fill cue is shorter than edit region */      if not Loop.Fill then do;         /* disallow edit if looping not allowed */         E$Status=E#FillTooShort;       /* fill cue is too short for edit */         return E$Status;      end;      /* otherwise fill cue will be looped until it is long enough */      call Read.Cue.Time   (Cue.Build.Ptr,Cue.S.Msb,T);      call Write.Cue.Time  (Cue.Build.Ptr,Cue.Edit.In.Msb,T); /* set up to paste at cue in point */      call Get.Cue.Duration(Cue.Build.Ptr,T);      do while Com32(T,Edit.Len)=lw#ilt;        /* loop until temp cue is long enough */         if Paste.Into.Reel(Cue.Build.Ptr,Fill.Ptr,Cue.Build.Ptr,false,false)<>E#Good         then return E$Status; /* paste failed */         call Get.Cue.Duration(Cue.Build.Ptr,T);      end;      call Read.Cue.Time (Cue.Build.Ptr,Cue.S.Msb,T); /* set cue OUT point to end at */      call Add32(T,Edit.Len,T);                 /* specified edit length    */      if Com32(T,Edit.Len)=lw#ilt then do;      /* overflow */         T(0)=(-1); T(1)=(-1);      end;      call Write.Cue.Time(Cue.Build.Ptr,Cue.E.Msb,T);   end;   if Fill.Reel.With.Leader(Sou.Ptr,Scratch.Cue.Ptr2,false)<>E#Good   then return E$Status;   /* Extract segments from Fill Cue that will be pasted in.   */   /* Set edit region to go from Cue IN to (Cue IN + EDIT LEN) */   call Read.Cue.Time (Cue.Build.Ptr,Cue.S.Msb      ,Cue.In); /* set up EDIT IN & OUT addrs */   call Write.Cue.Time(Cue.Build.Ptr,Cue.Edit.In.Msb,Cue.In); /* to extract region to FILL with */   call Add32(Cue.In,Edit.Len,T);                             /* corresponding EDIT OUT */   call Write.Cue.Time(Cue.Build.Ptr,Cue.Edit.Out.Msb,T);   E$Status=Extract.From.Reel.Without.Extend(Cue.Build.Ptr,Cue.Build.Ptr,false);   if E$Status<>E#Good then return E$Status;    /* extract failed */   E$Status=Merge.Edit.Lists(Cue.Build.Ptr,Scratch.Cue.Ptr2,Edit.In);   if E$Status<>E#Good then return E$Status;    /* merge failed */   call Garbage.Collect.Reel(Scratch.Cue.Ptr2); /* eliminate unecessary edit segments */   E$Status=Copy.Cue(Scratch.Cue.Ptr2,Des.Ptr,Protect.Des.Name);   return E$Status;                          /* edit was successful */end FILL.REEL;/* $SUBTITLE  Routine to Mix Two Reels Together */MIX.REELS: proc(Reel1.Ptr,Reel2.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Reel1.Ptr        fixed; /* xmem ptr to one of the cues to be mixed */   dcl Reel2.Ptr        fixed; /* xmem ptr to the other cue to mix */   dcl Des.Ptr          fixed; /* xmem ptr to the output cue       */   dcl Protect.Des.Name fixed; /* set to true to preserve name of Des cue */end MIX.REELS;/* $SUBTITLE  Routine to Exchange Edit Region of One Reel with Another Reel */EXCHANGE.REEL.WITH.EDIT.REGION: proc(Sou.Ptr,Clip.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr          fixed; /* xmem ptr to cue to exchange on */   dcl Clip.Ptr         fixed; /* xmem ptr to cue to exchange with edit region */   dcl Des.Ptr          fixed; /* xmem ptr to the output cue    */   dcl Protect.Des.Name fixed; /* set to true to preserve name of Des cue */   dcl Edit.In      (1) fixed; /* logical address to begin paste at */   dcl Edit.Out     (1) fixed;   /* NOTE:  Routine can do an in-place exchange (i.e., SOU.PTR=DES.PTR) */   /*        However, CLIP.PTR cannot be equal to SOU.PTR or DES.PTR.    */   /*        Routine assumes SCRATCH.CUE.PTR1 and SCRATCH.CUE.PTR2       */   /*        and CUE.BUILD.PTR point to cue records.                     */   if (Clip.Ptr=Des.Ptr) or (Clip.Ptr=Sou.Ptr) then do; /* consistency check */      E$Status=E#SysErr;      return E$Status;   end;   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up IN & OUT times for FILL */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out);   if Com32(Edit.In,Edit.Out)=lw#igt   /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out)=lw#ieq   /* EDIT IN point equals EDIT OUT point */   then do;      E$Status=E#NoRegionSelected;      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   call Copy.Cue(Sou.Ptr,Cue.Build.Ptr,false); /* save original source cue */   if Delete.From.Reel(Sou.Ptr,Sou.Ptr,false)<>E#Good then GOTO NO.ROOM;   if Paste.Into.Reel(Sou.Ptr,Clip.Ptr,Des.Ptr,Protect.Des.Name,false)<>E#Good then GOTO NO.ROOM;   /* Extract edit region from copy of Source Cue */   /* Put extracted EDL onto ClipBoard            */   if Extract.From.Reel.With.Extend(Cue.Build.Ptr,Clip.Ptr,true)<>E#Good then GOTO NO.ROOM;   /* Note: There is an outside chance that above EXTRACT will fail,    */   /*       if CUE.BUILD.PTR is totally full, and the name in CLIP.PTR  */   /*       is longer than the name in CUE.BUILD.PTR.                   */   /*       This will cause EXCHANGE to bomb out after changing DES.PTR */   /*       If DES.PTR<>SOU.PTR then this is a BUG.                     */   return E$Status;                          /* edit was successful */   /* ERROR HANDLERS BELOW: */   NO.ROOM:    call Copy.Cue(Cue.Build.Ptr,Sou.Ptr,false); /* restore source cue to original state */   E$Status=E#TooLong;   return E$Status;    /* ran out of room in edit list */end EXCHANGE.REEL.WITH.EDIT.REGION;/* $SUBTITLE  Routine to Slide edit region */SLIDE.EDIT.REGION: proc (Orig.Edit.In,Orig.Edit.Out,New.Edit.In,Sou.Ptr,Des.Ptr,Clip.Ptr,Fill.Mode) fixed public swapable;   dcl   Orig.Edit.In       array; /* edit in of original edit region */   dcl   Orig.Edit.Out      array; /* edit out of original edit region */   dcl   New.Edit.In        array; /* new edit in - where original edit region is to be moved */   dcl   Sou.Ptr            fixed; /* ptr to source cue */   dcl   Des.Ptr            fixed; /* ptr to dest cue   */   dcl   Clip.Ptr           fixed; /* ptr to clip/reel - only used if Fill.Mode=0 */   dcl   Fill.Mode          fixed; /*  0 = use Clip/Reel       */                                   /* -1 = use Leader          */                                   /*  1 = use displaced audio */   dcl   Orig.Edit.Len(1)   fixed; /* length of slide region */   dcl   Sou.Cue.In.Time(1) fixed; /* In and Out times of source cue */   dcl   Sou.Cue.Out.Time(1) fixed;   dcl   New.Edit.Out(1)    fixed; /* new edit out - where orig edit region will end after it's been slid */   dcl   Work.Cue.Ptr       fixed; /* temp work cue */   dcl   (temp.in,temp.out) (1) fixed;   dcl   (temp.str.in,temp.str.out) (15) fixed;   dcl   (offset)           (1) fixed;   dcl   NumTrks            fixed;   /* NOTE: if (SOU.PTR = DES.PTR) then routine assumes   */   /*       SCRATCH.CUE.PTR1, SCRATCH.CUE.PTR2,           */   /*       SCRATCH.CUE.PTR3, and CUE.BUILD.PTR point to  */   /*       cue records.                                  */   E$Status=E#Good;         /* assume edit operation will succeed */   if Com32(Orig.Edit.In,Orig.Edit.Out) = lw#igt   then do;      E$Status = E#SysErr;      return E$Status;   end;   if (Com32(Orig.Edit.In,Orig.Edit.Out) = lw#ieq)   or (Com32(Orig.Edit.In,New.Edit.In)   = lw#ieq)   then do;      E$Status = Copy.Cue(Sou.Ptr,Des.Ptr,false);      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);      /* round to sector bounds          */   call ROUND.REGION.TIMES(Orig.Edit.In, Orig.Edit.Out);   call ADD16(128, New.Edit.In);        /* round new in time as well       */   New.Edit.In(1) = New.Edit.In(1) & "177400";   if Cue.Lookup(Sou.Ptr,Cue.List.Ptr)=0 then do; /* cue is in "simple" format */      call Initialize.Reel(Sou.Ptr);              /* convert to reel cue format */   end;   /* Make a working copy of the source cue */   if ( Sou.Ptr   = Des.Ptr )   or ((Fill.Mode = 0      )   and (Clip.Ptr  = Des.Ptr))   then Work.Cue.Ptr=Scratch.Cue.Ptr3;   else Work.Cue.Ptr=Des.Ptr;   call Copy.Cue(Sou.Ptr,Work.Cue.Ptr,false);   /* Extract the original edit region */   call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,Orig.Edit.In);   call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,Orig.Edit.Out);   E$Status = Extract.From.Reel.Without.Extend(Work.Cue.Ptr,Cue.Build.Ptr,false);   if E$Status<>E#Good then return E$Status;   /* determine new edit region */   call Sub32(Orig.Edit.Out,Orig.Edit.In,Orig.Edit.Len);   call ADD32(New.Edit.In,Orig.Edit.Len,New.Edit.Out);   /* make sure new edit region is valid */   call Read.Cue.Time(Sou.Ptr,cue.s.msb,Sou.Cue.In.Time);   call Read.Cue.Time(Sou.Ptr,cue.e.msb,Sou.Cue.Out.Time);   call ROUND.REGION.TIMES(Sou.Cue.In.Time, Sou.Cue.Out.Time);   if (Com32(New.Edit.In, Sou.Cue.In.Time) = lw#ilt)   then do;      E$Status = E#BadSlideIn;      return E$Status;   end;   else if (Com32(New.Edit.Out, Sou.Cue.Out.Time) = lw#igt)   then do;      E$Status = E#BadSlideOut;      return E$Status;   end;   if (Fill.Mode < 1)   then do; /* user wants to fill hole with clip/reel or leader */      /* first, do fill with the original chunk of audio */      call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,New.Edit.In);      call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,New.Edit.Out);      E$Status = FILL.REEL(Work.Cue.Ptr,Cue.Build.Ptr,Work.Cue.Ptr,false,false);      if E$Status<>E#Good then return E$Status;      /* determine the leftover region */      if Com32(Orig.Edit.In,New.Edit.In) = lw#igt then do; /* slide back */         call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,New.Edit.Out);         call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,Orig.Edit.Out);      end;      else do; /* slide forward */         call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,Orig.Edit.In);         call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,New.Edit.In);      end;      /* fill the leftover region */      if (Fill.Mode = -1) then do;         E$Status = FILL.REEL.WITH.LEADER(Work.Cue.Ptr,Work.Cue.Ptr,false);      end;      else do;         E$Status = FILL.REEL(Work.Cue.Ptr,Clip.Ptr,Work.Cue.Ptr,false,false);      end;   end;   else do; /* user wants to shuffle displaced audio into hole */      call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,Orig.Edit.In);      call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,Orig.Edit.Out);      E$Status = CUT.FROM.REEL(Work.Cue.Ptr,Work.Cue.Ptr,Cue.Build.Ptr,false,false);      if E$Status<>E#Good then return E$Status;      if Com32(Orig.Edit.Out,New.Edit.In) = lw#ilt then do; /* special case */         call Sub32(New.Edit.In,Orig.Edit.Len,New.Edit.In);         call Sub32(New.Edit.Out,Orig.Edit.Len,New.Edit.Out);      end;      call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,New.Edit.In);      E$Status = PASTE.INTO.REEL(Work.Cue.Ptr,Cue.Build.Ptr,Work.Cue.Ptr,false,false);   end;   /* set scissors to the slid chunk of audio */   call Write.Cue.Time(Work.Cue.Ptr,cue.edit.in.msb,New.Edit.In);   call Write.Cue.Time(Work.Cue.Ptr,cue.edit.out.msb,New.Edit.Out);   if E$Status = E#Good then      E$Status = Copy.Cue(Work.Cue.Ptr,Des.Ptr,false);   return E$Status; end SLIDE.EDIT.REGION;/* $SUBTITLE Routine to Build a Cue which Spans Recorded Part of Current Project */EMPTY.REEL: proc (Cue.Ptr) public swapable; /* clears out all info from reel */   dcl Cue.Ptr fixed; /* xmem ptr to cue record */   dcl I       fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Len;   if read(md)<>0 then do;        /* this cue is a reel */      write(md )=0;               /* dump EDL */      write(mal)=Cue.List.Ptr;  I=read(md);  /* length of cue w/o EDL */      write(mal)=Cue.RLen;      write(md)=I; /* update cue record len */   end;   write(mal)=Cue.S.Msb;      write(mdi)=AEE.Current.Project.Base(0);      write(md )=AEE.Current.Project.Base(1);   write(mal)=Cue.E.Msb;      write(mdi)=AEE.Current.Project.Base(0);      write(md )=AEE.Current.Project.Base(1);   write(mal)=Cue.Edit.In.Msb;      write(mdi)=AEE.Current.Project.Base(0);      write(md )=AEE.Current.Project.Base(1);   write(mal)=Cue.Edit.Out.Msb;      write(mdi)=AEE.Current.Project.Base(0);      write(md )=AEE.Current.Project.Base(1);   write(mal)=Cue.SMPT.Msb;     write(mdi)=0; write(md )=0;   write(mal)=Cue.Off.Msb;      write(mdi)=0; write(md )=0;   write(mal)=Cue.Len.Msb;      write(mdi)=0; write(md )=0;   write(mal)=Cue.Trks;         write(mdi)=0; write(mdi)=0;                                write(mdi)=0; write(md )=0;   write(mal)=Cue.FIn;          write(md )=1;   write(mal)=Cue.FOut;         write(md )=1;   write(mal)=Cue.Bits;         write(md )=read(md) & (not "17") \ bit3;end EMPTY.REEL;CLEAR.EDITS.FROM.REEL: proc (Cue.Ptr,Set.To.Project) public swapable;   dcl Cue.Ptr        fixed; /* xmem ptr to cue record */   dcl Set.To.Project fixed; /* true to set cue IN & OUT to project boundaries */   dcl T          (1) fixed;   dcl Saved.Trks     fixed;   dcl I              fixed;   Saved.Trks=Cue.Lookup(Cue.Ptr,Cue.Trks);   if not Set.To.Project then do;      call Read.Cue.Time(Cue.Ptr,Cue.S.Msb,T); /* save original IN addr */      /* compute addr of 1st piece of audio */   end;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Len;   if read(md)<>0 then do;    /* this cue is a reel */      write(md )=0;           /* dump EDL */      write(mal)=Cue.List.Ptr;  I=read(md);  /* length of cue w/o EDL */      write(md )=0;           /* rezero edit list ptr, too */      write(mal)=Cue.RLen;      write(md)=I; /* update cue record len */   end;   if Set.To.Project then do; /* set up cue which spans entire project */      call Empty.Reel(Cue.Ptr); /* reset all info */      write(mam)=Cue.Ptr;      write(mal)=Cue.Trks; write(md)=Saved.Trks; /* restore trks to original state */      write(mal)=Cue.E.Msb;                  write(mdi)=AEE.Current.Project.End(0);        write(md )=AEE.Current.Project.End(1);      write(mal)=Cue.Edit.Out.Msb;        write(mdi)=AEE.Current.Project.End(0);        write(md )=AEE.Current.Project.End(1);      /* reset SYNC time to the SMPTE offset -- effectively zero.time */      call SMPTE.to.SBits(loc(addr(SM.HRS)), SM.MODE, T);      write(mam)=Cue.Ptr;      write(mal)=Cue.SMPT.Msb;         write(mdi)=T(0);         write(md )=T(1);      write(mal)=Cue.SMPT.Mode;         write(md )=SM.MODE;      write(mal)=Cue.Bits;         write(md )=read(md) \ bit3;   end;   else do;                   /* no EDL, but keep audio at original cue IN addr */   end;end CLEAR.EDITS.FROM.REEL;