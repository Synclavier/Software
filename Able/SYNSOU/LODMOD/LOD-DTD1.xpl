/* :SYNSOU:LODMOD:LOD-DTD1  $TITLE  LOD Routines for Remote Box, AEE, and Event Processing   Modified:   03/26/92 - cj & pf - Added Fetch.DTD.Cue.In.Samples   02/12/92 - cj  - Deskewed lod scrubbing & trigging for DSP option   12/18/91 - PF  - Update cue.alloc# in cue record when saving cues   12/06/91 - PF  - Fix Quick Update crashing bug on saving cues w/ max name len   12/06/91 - PF  - Split LOD-DTD into 2 files: LOD-DTD1, LOD-DTD2   11/30/91 - PF  - Check cue id before calling BUILD.CUE.HIST.REC   11/18/91 - PF  - More quick update support   11/04/91 - PF  - Added 'Quick Update' feature   09/26/91 - cj - Send envelope stuff to DSP during trig   09/11/91 - cj - Fixed bug where setting track outputs broke O page   07/31/91 - cj - kept track of scrubbing for fade-in and fade-out   05/29/91 - cj - added arg to trigger.dtd.cue.by.id   10/02/89 - cj  - fixed bug in CREATE.DTD.AUTO.ALLOCATE.CUE (cue length)   09/22/89 - cj - fixed "compute.actual.dtd.in.sample.#" to fix "fill with                   leader" cue moving bug.   06/22/89 - cj  - added several new routines for cue scrubbing   06/14/89 - cj  - added several new routines   05/16/89 - MWH - Move locate DTD cue procedure to LODMOD   05/03/89 - cj  - added fetch.dtd.sampling.rate   04/26/89 - cj  - moved more routines from aud-dtd*/dcl AEE.Current.Project          fixed public;  /* Current Project Number (0-49)     */dcl AEE.Current.Project.Name(12) fixed public;  /* Current project name (space filled) */dcl AEE.Current.Project.Base (1) fixed public;  /* Current project base sample #     */dcl AEE.Current.Project.End  (1) fixed public;  /* Current project end  sample #     */dcl AEE.Current.Project.Rate     fixed public;dcl CUE.HIST.THERE  fixed public;  /* TRUE IF .SCUE-7 FILE IS THERE */dcl CUE.HIST.BUF    fixed public;dcl CUE.HIST.SIZE   fixed public;dcl (CUEDEV,CUESEC) fixed public;  /* DISK PTRS TO THE FILE         *//* FETCH.DTD.CUE is called to fetch the basic cue *//* information (cue info + name) into a record    */FETCH.DTD.CUE: proc (id,cue.record) returns (fixed) public swapable;   dcl id         fixed;   dcl cue.record array;  /* Must be passed static array (256) to conserve stack */   DTD.Cue# = 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = id;      write(mdi) = 0;            /* basic cue info only             */      call Send.To.Lod(182,4);      if DTD.Cue# <> 0 then do;  /* Copy data into cue.record passed */         write(mam) = SCSI.Ptr;         call Copy.In(addr(cue.record(0)),read(md));      end;      else do;                   /* return all zeroes                */         write("313") = addr(cue.record(0));         rpc 256;         write("373") = 0;      end;   end;   return DTD.Cue#;end FETCH.DTD.CUE;/* FETCH.DTD.CUE.IN.SAMPLES is called to fetch the raw cue *//* information (cue info + name) into a record without     *//* any time mapping.  NOTE:   these sample number are      *//* absolute to the start of the disk,  not even relative   *//* to the audio portion of the DTD disks                   */Fetch.DTD.cue.in.samples: proc (id,cue.record) returns (fixed) public swapable;   dcl id         fixed;   dcl cue.record array;  /* Must be passed static array (256) to conserve stack */   DTD.Cue# = 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = id;      write(mdi) = 1;            /* cue info with no mapping         */      call Send.To.Lod(182,4);      if DTD.Cue# <> 0 then do;  /* Copy data into cue.record passed */         write(mam) = SCSI.Ptr;         call Copy.In(addr(cue.record(0)),read(md));      end;      else do;                   /* return all zeroes                */         write("313") = addr(cue.record(0));         rpc 256;         write("373") = 0;      end;   end;   return DTD.Cue#;end Fetch.DTD.cue.in.samples;/* Fetch.Entire.DTD.Cue is called to read an entire long *//* cue record into a section of external memory          */FETCH.ENTIRE.DTD.CUE: proc (id,mem.ptr) returns (fixed) public swapable;   dcl id      fixed;   dcl mem.ptr fixed;   DTD.Cue# = 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = id;      write(mdi) = 2;        /* fetch entire cue */      call Send.To.Lod(182,4);      if DTD.Cue# <> 0 then do;           write(mam) = SCSI.Ptr;         if read(md) igt Max.Cue.Record.Len then dtd.cue# = 0;         else do;                /* copy it into place               */            call COPY.EXT.MEM(Scsi.Ptr,0,Mem.Ptr,0,read(md));         end;      end;   end;   if DTD.Cue# = 0   then do;      write(mam) = mem.ptr;      rpc 256;      write(mdi) = 0;   end;   return DTD.Cue#;end FETCH.ENTIRE.DTD.CUE;/* Given a cue name string in "key", returns the cue ID, or zero if not found *//* This routine locates a cue in the cue directory.  It is passed a *//* name of a cue.   It returns a 0 if the cue is not found,  or     *//* it returns the cue ID#.                                          *//* The cue itself is not fetched.                                   */LOCATE.DTD.CUE: proc (key) returns (fixed) public swapable;   dcl key array;   DTD.Cue# = 0;   if key(0)=0 then return 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = true;                   /* reset pointers */      call Copy.Out(addr(key(0)),17);      call Send.To.Lod(181,shl( shr(key(0)+1,1) +1,1)+2); /* +2 for pointer flag */   end;   return DTD.Cue#;end LOCATE.DTD.CUE;/* Routine to perform partial name search: */LOCATE.PARTIAL.NAME.DTD.CUE: proc (key, code) returns (fixed) public swapable;   dcl key     array;   dcl code    fixed; /* 1 = get next >= alphabetic if no partial match */   DTD.Cue# = 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      call Copy.Out(addr(key(0)),17);      call Send.To.Lod(185,shl( shr(key(0)+1,1) +1,1));      if code = 1 then do;         if DTD.Cue# = 0 then     /* Try for first item after failed search */         call Send.To.Lod(24,0);  /* Get Next Alpha Cue */      end;   end;   return DTD.Cue#;end LOCATE.PARTIAL.NAME.DTD.CUE;/* Set.dtd.play.tracks is used to tell the DTD which tracks should *//* be heard when scrubbing through audio.                          */SET.DTD.PLAY.TRACKS: proc(track.bits) public swapable;   dcl track.bits fixed;   if LOD.Running <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = track.bits;      write(mdi) = 0;      write(mdi) = 0;      write(mdi) = 0;      call Send.To.Lod(134,8);   end;end SET.DTD.PLAY.TRACKS;/* Trigger.DTD.Cue.By.Id is used to manually trigger a cue or en event *//* by id.                                                              *//* returns true if the cue was actually triggered.                     */Trigger.DTD.Cue.By.Id: proc (Cue.Id, Trkinfo, Evptr, Code) public swapable;   dcl cue.id            fixed;  /* id# of cue to trigger            */   dcl Trkinfo           fixed;  /* syncl track # if any for routing */   dcl Evptr             fixed;  /* pass POINTER to event RECORD     */                                 /* or 0 for simple cue.             */   dcl Code              fixed;  /* Bits to pass to LOD              */   dcl i                 fixed;   dcl time(1)           fixed;   if (cue.id < (-1))    /* make sure ID makes sens.                 */   or (cue.id = ( 0))   then return 0;   if Evptr <> 0         /* if event info is present                 */   then call Map.Sequence.Time.To.Real.Time(loc(Evptr + Event.Time.Msb),                                            time);   if DTD.MAX.SECS = 0   /* also make sure DTD is up and running     */   then return 0;      call Set.DTD.Play.Tracks("177777");  /* All tracks on for LOD playback */      write(mam) = SCSI.Ptr;/*0*/ write(mdi) = cue.id;/*1*/ write(mdi) = Trkinfo;      /* for simple cue triggers,  just send a 0 */      if Evptr = 0 then do;           /* if no event info is passed *//*2*/    write(mdi) = 0;              /* then send a zero           */         call Send.To.Lod(133,6);         return 1;      end;/*2*/ write(mdi) = 1 \ shl(code,1);   /* else event info is present */      /*3*/ write(mdi) = core(Evptr + Event.Priority);  /* send over event   *//*4*/ write(mdi) = core(Evptr + Event.Output  );  /* record items.     *//*5*/ write(mdi) = core(Evptr + Event.Volume  );  /* 0 - 1000          *//*6*/ write(mdi) = core(Evptr + Event.Pan     );/*7*/ write(mdi) = time(0);                       /* pass sequence     *//*8*/ write(mdi) = time(1);                       /* time for scrub    */      write("300") = Evptr + Event.In.Msb;        /* then event record */      rpc Event.Caption - Event.In.Msb;           /* info itself.      */      write(mdi) = read("360");      rpc (32 - 9 - (Event.Caption - Event.In.Msb));      write(mdi) = 0;                             /* zero fill the     */      call Send.To.Lod(133,64);                   /* record for later. */      return 1;end Trigger.DTD.Cue.By.Id;/* Handy routine to get current DTD sampling rate "straight from the *//* horsed mouth"                                                     */Fetch.DTD.Sampling.Rate: proc public swapable;   if DTD.Max.Secs = 0 then return 500; /* assume 50 khz if no dtd */   DTD.Cue# = 500;                      /* also for old software   */   write(mam) = SCSI.Ptr;   write(mdi) = 50;   call Send.To.Lod(144,2);   return DTD.Cue#;end Fetch.DTD.Sampling.Rate;/* Compare.DTD.Cue.Maps compares the edit list mapping for two complete *//* dtd cues.   A 1 is returned if the edit list match,  else a 0 is     *//* returned.                                                            */Compare.DTD.Cue.Maps: proc (ptr1, ptr2) PUBLIC swapable;   dcl ptr1 fixed;    /* pointer to cue in ext memory                   */   dcl ptr2 fixed;   dcl i    fixed;   dcl j    fixed;   dcl (ptra, ptrb, len) fixed;   write(mam) = ptr1;             /* look up segment list info          */   write(mal) = cue.list.ptr;     /* from first cue                     */   ptra = read(mdi);              /* store in handy variables           */   len  = read(mdi);   write(mam) = ptr2;             /* see if they are the same as for    */   write(mal) = cue.list.ptr;     /* the second cue                     */   ptrb = read(mdi);              /* get its pointer; may differ if new */                                  /* caption                            */   if (read(mdi) <> len)          /* if lengths differ, however, one    */   then return 0;                 /* has more segments                  */   if ptra <> 0                   /* if any segments, compare them      */   then do i = 0 to len-1 by Cue.Seg.Stride;      write(mam) = ptr1 + shr(ptra,8);           /* get data from first */      write(mal) = ptra;                         /* cue                 */      call COPY.IN(addr(copy.buf(0)), Cue.Seg.Stride);      /* Note: ignore PixelPointers in comparison because they are      */      /* random numbers for display purposes only and do not affect     */      /* the audio.                                                     */      write(mam) = ptr2 + shr(ptrb,8);           /* compare with second */      write(mal) = ptrb;                         /* cue                 */      do j = S#Sync.Msb to S#Fade.Out;         if read(mdi) <> copy.buf(j) then return 0;      end;      ptra = ptra + Cue.Seg.Stride;              /* point to next       */      ptrb = ptrb + Cue.Seg.Stride;              /* segment             */   end;   return 1; /* if cues are equal */end Compare.DTD.Cue.Maps;/* Compare.DTD.Cue.Tracks compares the track list for two complete      *//* dtd cues.   A 1 is returned if the tracks match,  else a 0 is        *//* returned.                                                            */Compare.DTD.Cue.Tracks: proc (ptr1, ptr2) PUBLIC swapable;   dcl ptr1 fixed;    /* pointer to cue in ext memory                   */   dcl ptr2 fixed;   dcl i    fixed;   write(mam) = ptr1;             /* look up tracks                     */   write(mal) = CUE.TRKS;         /* from first cue                     */   i = read(md);   write(mam) = ptr2;             /* see if they are the same as for    */   write(mal) = CUE.TRKS;         /* the second cue                     */   if read(md) = i                /* if tracks match                    */   then return 1;                 /* then they are equal                */   else return 0;                 /* else they do not                   */end Compare.DTD.Cue.Tracks;/* Compare.DTD.Cue.Times compares the in/out times for two complete     *//* dtd cues.   A 1 is returned if the times match,  else a 0 is         *//* returned.                                                            */Compare.DTD.Cue.Times: proc (ptr1, ptr2) PUBLIC swapable;   dcl ptr1 fixed;    /* pointer to cue in ext memory                   */   dcl ptr2 fixed;   dcl x(cue.fout) fixed;   dcl i           fixed;   /* compare cue in time, out time, fade in, fade out as these are     */   /* the only things that affect the audio.                            */   write(mam) = ptr1;             /* look up cue info                   */   write(mal) = cue.s.msb;        /* from first cue                     */   call COPY.IN(addr(x(cue.s.msb)), cue.fout-cue.s.msb+1);   write(mam) = ptr2;             /* see if they are the same as for    */   write(mal) = cue.s.msb;        /* the second cue                     */   do i = cue.s.msb to cue.fout;      if read(mdi) <> x(i)      then return 0;   end;   return 1;                 /* then they are equal                */end Compare.DTD.Cue.Times;/* Count.DTD.Cue.Useage is used to determine how many times a cue     *//* is used in the current sequence.  This is used to give smart error *//* messages when saving cues.                                         */Count.DTD.Cue.Useage: proc (cueid, output) PUBLIC swapable;   dcl cueid       fixed;  /* id of cue in question                   */   dcl output      array;  /* output (0) = cue triggers; (1) = events */   dcl (i,j,k,l,m,n) fixed;   output(0) = 0;          /* initialize to no usage                  */   output(1) = 0;   i = 0;                       /* if so,  loop over all timbres */   do while i < par.numt;       /* loop over all timbers         */     write(mam) = tim.head;     /* see if timbre head exists     */     write(mal) = i;     if read(md) <> 0           /* if timbre head exists, check  */     then do;       if tim.head.lookup(i, TIM.SYNTH.TYP+0) = TIM#CUE       then do;                 /* if cue type,  check table          */         do j = 0 to num.partials-1;        /* check each partial     */           k = tim.head.lookup(i, tim.kbdtab.ptr       + j);           l = tim.head.lookup(i, tim.partial.pointers + j);           if k <> 0 then do;               /* if we have a kbd lookup */             write(mam)=tim.ptr + k - 1;             do m = 0 to 255;               /* look at its contents    */               n = read(mdi);               /* get cue id or pointer   */               if n <> 0 then do;           /* if nonzero, check       */                 if n = cueid               /* cue trigger event       */                 then output(0) = output(0) + 1;                 else if n < 0 then do;     /* else if pointer to evt  */                   if p.lookup(l-n+ev.cue.id) = cueid                   then output(1) = output(1) + 1;                   write(mam) = tim.ptr + k - 1;   /* restore mam ptr  */                   write(mal) = m+1;               /* after p.lookup   */                 end;               end;             end;           end;         end;       end;     end;     i = i + 1;   end;end Count.DTD.Cue.Useage;/* $page - routines to start and stop DTD cue scrubbing *//*  1. Prepare.DTD.For.Cue.Scrubbing                    *//*                                                      *//*      Just call.  No arguments,  No return value.     */Prepare.DTD.For.Cue.Scrubbing: proc PUBLIC swapable;   if DTD.MAX.SECS <> 0   then call Send.To.Lod(DTD.Prepare.For.Scrub, 0);   if dtd.is.trigging <> 0 then do;     /* reset trigging before start     */      dtd.is.trigging = 0;              /* of scrub...                     */      if dsp.running <> 0               /* tell DSP about scrubbing        */      then new.motion = 1;              /* if he is there                  */   end;end Prepare.DTD.For.Cue.Scrubbing;/*  2. Is.DTD.Ready.For.Cue.Stacking                                     *//*                                                                       *//*  Returns TRUE if DTD is ready to accept cues for stacking.  If DTD    *//*  is not ready,  then any events sent over for stacking will be tossed */Is.DTD.Ready.For.Cue.Stacking: proc PUBLIC swapable;   if DTD.Max.Secs = 0 then return 0;   /* not ready if no DTD           */   DTD.Cue# = 0;   write(mam) = SCSI.Ptr;   write(mdi) = 51;   call Send.To.Lod(144,2);   return DTD.Cue#;end Is.DTD.Ready.For.Cue.Stacking;/* 4. Set.Current.Scrub.Position (samples from start of sequence)           *//*                                                                          *//* This will start scrubbing at that point (for first one) or scrub forward *//* or backwards to that point for later ones.  System will scrub through    *//* fade-ins and fade-outs and DOA voice switching (more or less)            */Set.Current.Scrub.Position: proc (samplepos) PUBLIC swapable;   dcl samplepos array;   write(mam) = SCSI.Ptr;   write(mdi) = samplepos(0);   write(mdi) = samplepos(1);   rpc 16;   write(mdi) = 0;   call Send.To.Lod(139,32);   if dtd.is.scrubbing = 0 then do;      /* save first scrub pos as         */      dtd.scrub.msb = samplepos(0);      /* current position                */      dtd.scrub.lsb = samplepos(1);      if dsp.running <> 0                /* tell DSP about scrubbing        */      then new.motion = 1;               /* if he is there                  */   end;   dtd.is.scrubbing = 1;                 /* indicate we are scrubbing now   */end Set.Current.Scrub.Position;Send.Event.To.DTD.Scrub.Stack: proc (Event, Code) PUBLIC swapable;   dcl Event      array;   dcl Code       fixed;   dcl Trkinfo    fixed;   if event(event.track#) = 0                  /* if no track is           */   then Trkinfo = 0;                           /* referenced,  use no      */   else Trkinfo = 32768 \ event(event.track#); /* track volume, else do so */   call Trigger.DTD.Cue.By.Id(Event(event.cue.id), Trkinfo, addr(Event(0)), Code);   return Good.Event.Status;end Send.Event.To.DTD.Scrub.Stack;Terminate.DTD.Cue.Scrubbing: proc PUBLIC swapable;   call Send.To.Lod(DTD.Loop.Stop,    0);   /* stop output.  will be quick if not recording */   call Send.To.Lod(DTD.Scrolling.Off,0);   /* get last scroll position                     */   dtd.is.scrubbing = 0;                    /* no longer scrubbing                          */   if dsp.running <> 0                      /* tell DSP about scrubbing        */   then new.motion = 1;                     /* if he is there                  */END Terminate.DTD.Cue.Scrubbing;/* $page - compute actual dtd in sample # *//* This routine looks through a reel and computes the actual disk *//* sample # of the first segment of audio.   this is used         *//* to do time sorting                                             */COMPUTE.ACTUAL.DTD.IN.SAMPLE.#: proc(cue.ptr) PUBLIC swapable;   dcl cue.ptr   fixed;        /* ext mem sector # where cue sits     */   dcl (base,len)  fixed;      /* declare in order                    */   dcl (i,j,k)     fixed;   dcl (in)    (1) fixed;   dcl (sin)   (1) fixed;   dcl (sout)  (1) fixed;   dcl (ssync) (1) fixed;   dcl (slen)  (1) fixed;   dcl (ssend) (1) fixed;   dcl (ins#)  (1) fixed;   dcl (insync)(1) fixed;   lookup:proc(cue.ptr, ptr,arr);      dcl cue.ptr fixed;      dcl ptr     fixed;      dcl arr     array;      write(mam) = Cue.Ptr + shr(ptr,8);      write(mal) = ptr;      arr(0) = read(mdi);      arr(1) = read(mdi);   end lookup;   store:proc(cue.ptr, ptr,arr);      dcl cue.ptr fixed;      dcl ptr fixed;      dcl arr array;      write(mam) = Cue.Ptr + shr(ptr,8);      write(mal) = ptr;      write(mdi) = arr(0);      write(mdi) = arr(1);   end store;   /* get base and length of reel: */   call lookup(Cue.Ptr,Cue.List.Ptr,loc(addr(base)));   /* look up in time:             */   call lookup(Cue.Ptr, Cue.S.Msb, in);  /* get original in time */   /* look for first segment that  */   /* contains this in time:       */   if base <> 0   then do i = base to base + len - 1 by Cue.Seg.Stride;      call lookup(Cue.Ptr, i+S#Sync.Msb,ssync);  /* segment sync time    */      call lookup(Cue.Ptr, i+S#In.Msb  ,sin  );  /* segment disk in      */      call lookup(Cue.Ptr, i+S#Out.Msb ,sout );  /* segment disk out     */      if COM32(in, ssync) >= lw#ieq              /* in is after seg start */      then do;         if sout(0) = (-1) then do;              /* segment extends to end  */            call SUB32(in, ssync, in);           /* get offset              */            call ADD32(in, sin,   in);           /* and disk address        */            call store(Cue.Ptr, Cue.In.S#.Msb, in);            return;         end;         call SUB32(sout,  sin,  slen);          /* compute sync end time   */         call ADD32(ssync, slen, ssend);         if COM32(in, ssend) = lw#ilt            /* if in this seg, do it   */         then do;            call SUB32(in, ssync, in);           /* get offset              */            call ADD32(in, sin,   in);           /* and disk address        */            call store(Cue.Ptr, Cue.In.S#.Msb, in);            return;         end;      end;   end;   /* If is a reel,  but the cue in time is in a section of leader,  */   /* use the disk address of the audio from the first segment after */   /* the leader to determine which project the cue is in:           */   if base <> 0 then do;      /* Get sample # of first segment in case there ARE no segments */      /* after the IN time (IE cue is all silence).                  */      call lookup(Cue.Ptr, base + S#In.Msb, ins#);      call STR32 (-1, -1, insync);      /* find the segment that is triggered MOST SOON after the in   */      /* point (ie the first segment that is heard when the cue      */      /* is triggered (provided the out time is long enough!):       */      do i = base to base + len - 1 by Cue.Seg.Stride;         call lookup(Cue.Ptr, i+S#Sync.Msb,ssync); /* segment sync time    */         call lookup(Cue.Ptr, i+S#In.Msb  ,sin  ); /* segment disk in      */         if COM32(ssync, in) >= lw#ieq             /* if segment starts    */         then do;                                  /* after the IN time:   */            /* find the EARLIEST one in case (some day) the segment list   */            /* is no longer in order:                                      */            if COM32(ssync, insync) = lw#ilt            then do;               call COPY32(sin,   ins#);               call COPY32(ssync, insync);            end;         end;      end;      call store(Cue.Ptr, Cue.In.S#.Msb, ins#);      return;   end;   /* if not a reel, then use in time                 */   /* as disk sample # in time                        */   call store(Cue.Ptr, Cue.In.S#.Msb, in);end COMPUTE.ACTUAL.DTD.IN.SAMPLE.#;/* Set Cue Event Point is called whenever a cue is saved to disk.  It *//* makes sure that a copy of the cue in time is "frozen" so that      *//* once events are placed,  there is a fixed point of reference       *//* in the cue that the events can relate to.   This allows the user   *//* to change the cue in times after an event is placed without        *//* glomming the placed events.                                        *//* It is important to do this whenever a cue is first saved so that   *//* we have noted the fact everywhere that the edit pointers have      *//* been frozen.                                                       */Set.Cue.Event.Point: proc (cue.ptr) swapable;   dcl cue.ptr  fixed;   /* where cue sits in external memory */   dcl cuebits  fixed;   dcl cuein(1) fixed;   write(mam) = cue.ptr;      /* look at cue sitting in external */   write(mal) = cue.bits;     /* memory.  See if the in time     */   cuebits    = read(md);     /* has been sampled yet.           */   if (cuebits&16) = 0 then do;       /* if not,  then take a    */      write(md) = cuebits \ 16;       /* picture of the IN time  */      write(mal) = cue.s.msb;         /* here.   This will       */      cuein(0) = read(mdi);           /* define which project    */      cuein(1) = read(md );           /* the audio material is   */      write(mal) = event.in.s#.msb;   /* associated with.        */      write(mdi) = cuein(0);      write(md ) = cuein(1);   end;end Set.Cue.Event.Point;Project#.Of.Cue: proc (in) swapable;   dcl in       array;   dcl i        fixed;   dcl j        fixed;   dcl s        fixed;   dcl e        fixed;   dcl pbase(1) fixed;   dcl pend(1)  fixed;   do i = 0 to 49 by 10;              /* loop thru all projects */      write(mam) = scsi.ptr;      write(mdi) = i;      call Send.To.Lod(189,2);        /* get song directory */      do j = 0 to 9;         write(mam) = scsi.ptr + shr(j*24+13,8);         write(mal) = j*24+13;         s = read(mdi);         e = read(mdi);         call STR32(0,s,loc(addr(bitmsb)));         call ratio_multiply(50000,256);          /* get sector# to start */         call unround;                            /* truncate down */         call COPY32(loc(addr(bitmsb)),pbase);         call SHL32(pbase,8);                     /* get sample# */         call STR32(0,e,loc(addr(bitmsb)));         call ratio_multiply(50000,256);          /* get sector# to start */         call unround;                            /* truncate down */         call COPY32(loc(addr(bitmsb)),pend);         call SHL32(pend,8);                      /* get sample# */         if  (COM32(in, pbase) >= lw#ieq)         and (COM32(in, pend ) <  lw#ieq)         then return(i+j);      end;   end;   return (-1);           /* can't find project - serious problem */end Project#.Of.Cue;READ.IN.CUE.HIST: proc public swapable;   dcl i   fixed;   if CUE.HIST.THERE = 0   then return 0;	EXT.READDATA(CUEDEV, CUESEC, CUE.HIST.BUF, 0, CUE.HIST.SIZE, 0);   return 1;end READ.IN.CUE.HIST;WRITE.OUT.CUE.HIST: proc public swapable;   dcl i   fixed;   if CUE.HIST.THERE = 0   then return 0;	EXT.WRITEDATA(CUEDEV, CUESEC, CUE.HIST.BUF, 0, CUE.HIST.SIZE, 0);   return 1;end WRITE.OUT.CUE.HIST;dcl FETCH.DTD.SONG.DIRECTORY proc (fixed) recursive;BUILD.PROJ.HIST.REC: proc (proj#, code, rec) public swapable;   dcl proj# fixed;   dcl code  fixed;   dcl i     fixed;   dcl rec   array;	if (CUE.HIST.THERE == 0)		return;   call FETCH.DTD.SONG.DIRECTORY(proj#);   rec(0) = shl(10,8) | proj# + 50;            /* dir id - DTD:Project */   rec(1) = 0;                                               rec(2) = 0;                                 /* ds id msb/lsb  */   rec(3) = 0;                                 /* unused here */   rec(4) = code;                              /* change code <0:insert, 1:remove> */   rec(5) = 0;                                 /* length msb/lsb */   rec(6) = 24;   rec(7) = 0;                                 /* rev number */   rec(8) = 0;   rec(9) = 4;                                 /* 4:T#Dir */   write(mam) = Scsi.Ptr;                      /* point to song info */   write(mal) = 1;                             /* loc of song name */   do i = 1 to 12;                             /* get 24 chars */      rec(10 + i) = read(mdi);                 /* into xpl string */   end;   rec(10) = 24;                               /* set len */end BUILD.PROJ.HIST.REC;BUILD.CUE.HIST.REC: proc (cue#, code, rec) public swapable;   dcl cue#      fixed;   dcl code      fixed;   dcl rec       array;   dcl cue.in(1) fixed;   dcl project   fixed;   dcl i         fixed;   dcl sav.cue#  fixed;   sav.cue# = DTD.Cue#;   call FETCH.ENTIRE.DTD.CUE(cue#,scsi.ptr);   /* get cue info from lod */   rec(2) = 0;                                 /* ds id msb/lsb  */   rec(3) = cue# + 99;   rec(4) = code;                              /* change code <0:insert, 1:remove> */   write(MAM) = scsi.ptr;   write(MAL) = CUE.RLEN;   rec(5) = 0;                                 /* cue record length msb/lsb */   rec(6) = read(md);   rec(7) = 0;                                 /* rev number */   rec(8) = 0;   rec(9) = 0;                                 /* type <0:T#Cue> */   write(MAL) = CUE.NAME;   do i = 0 to 16;                             /* fill in cue name in able format */      rec(10 + i) = read(mdi);   end;   write(MAL) = cue.in.s#.msb;                 /* now get cue in time to determine project num */   cue.in(0) = read(mdi);   cue.in(1) = read(mdi);   call ADD16(128,cue.in);                     /* round to sector boundary */   cue.in(1) = cue.in(1) & "177400";           /* for correct comparison   */   project = Project#.Of.Cue(cue.in);          /* loads project info to scsi ptr */   rec(0) = shl(10,8) | project + 50;          /* go back and fill in dir id msb/lsb */   rec(1) = 0;                                               DTD.Cue# = sav.cue#;end BUILD.CUE.HIST.REC;ADD.CUE.TO.HIST: proc (rec) public swapable;   dcl rec          array;   dcl cur.stamp(1) fixed;   dcl wrd.ptr      fixed;	if (CUE.HIST.THERE == 0)		return;   if READ.IN.CUE.HIST = 0   then return 0;   write(MAM) = CUE.HIST.BUF;   cur.stamp(0) = read(mdi);   cur.stamp(1) = read(md );   call ADD16(1,cur.stamp);   wrd.ptr = ((cur.stamp(1) mod CUE.HIST.NUM.RECS) * CUE.HIST.REC.LEN) + CUE.HIST.HDR.LEN;   write(MAM) = CUE.HIST.BUF + shr(wrd.ptr,8);   write(MAL) = wrd.ptr;   write("313") = addr(rec(0));   rpc CUE.HIST.REC.LEN;   write(mdi) = read("373");   write(MAM) = CUE.HIST.BUF;   write(mdi) = cur.stamp(0);   write(md ) = cur.stamp(1);   call WRITE.OUT.CUE.HIST;   return(1);end ADD.CUE.TO.HIST;/* Define.dtd.cue is called to save a short dtd cue *//* on the direct to disk.   It is passed a short    *//* cue record in a passed array                     */DEFINE.DTD.CUE: proc (cue.record) returns (fixed) public swapable;    dcl cue.record array;   dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   DTD.Cue# = 0;   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      call Copy.Out(addr(cue.record(0)),cue.record(CUE.RLEN));      call COMPUTE.ACTUAL.DTD.IN.SAMPLE.#(Scsi.Ptr);      call Set.Cue.Event.Point(Scsi.Ptr);      call Send.To.Lod(180,shl(cue.record(CUE.RLEN),1));      /* Create a system event when the cue directory contents changes: */      new.dtd.info = new.dtd.info \ 8192;      if (DTD.Cue# > 0) then do;                         /* no errors */         call BUILD.CUE.HIST.REC(DTD.Cue#,0,hist.rec);   /* log changes */         call ADD.CUE.TO.HIST(hist.rec);      end;   end;     return DTD.Cue#;end DEFINE.DTD.CUE;/* define entire dtd cue saves a long cue that *//* is sitting in external memory               */DEFINE.ENTIRE.DTD.CUE: proc (Cue.Ptr) returns (fixed) public swapable;    dcl cue.ptr fixed;    /* sector of ext memory */   dcl i       fixed;      dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   DTD.Cue# = 0;   write(mam) = Cue.Ptr;   write(mal) = CUE.RLEN;   i          = read(md);   if DTD.MAX.SECS <> 0 then do;      call Set.Cue.Event.Point(Cue.ptr);   /* set in cue.ptr area so we know */                                           /* we have done it!               */      call COPY.EXT.MEM(Cue.ptr,0,Scsi.ptr,0,i);      call COMPUTE.ACTUAL.DTD.IN.SAMPLE.#(Scsi.Ptr);      call Send.To.Lod(180,shl(i,1));      /* Create a system event when the cue directory contents changes: */      new.dtd.info = new.dtd.info \ 8192;      if (DTD.Cue# > 0) then  do;                       /* no errors */         call BUILD.CUE.HIST.REC(DTD.Cue#,0,hist.rec);  /* log changes */         call ADD.CUE.TO.HIST(hist.rec);         /* keep the id in the cue record itself up to date */         write(mam) = Cue.Ptr;         write(mal) = cue.alloc#;         write(md)  = DTD.Cue#;      end;   end;     return DTD.Cue#;end DEFINE.ENTIRE.DTD.CUE;REPLACE.ENTIRE.DTD.CUE: proc (id,cue.ptr) returns (fixed) public swapable;   dcl id          fixed;   dcl cue.ptr     fixed;   dcl i           fixed;   dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   write(mam) = cue.ptr;     /* look up cue record length */   write(mal) = CUE.RLEN;    /* in words                  */   i          = read(md);   if DTD.MAX.SECS <> 0 then do;      write(mam) = SCSI.Ptr;      write(mdi) = id;      write(mdi) = 0;     /* basic cue info only           */      DTD.Cue# = 0;      call Send.To.Lod(182,4);   /* Fetch Cue */      if DTD.Cue# <> 0 then do;  /* Cue does exist */         call BUILD.CUE.HIST.REC(DTD.Cue#,1,hist.rec);    /* log old version as deleted before writing new cue */         call ADD.CUE.TO.HIST(hist.rec);         call Set.Cue.Event.Point(Cue.Ptr);         call COPY.EXT.MEM(Cue.Ptr,0,Scsi.Ptr,0,i);         call COMPUTE.ACTUAL.DTD.IN.SAMPLE.#(Scsi.Ptr);         DTD.Cue# = 0;         call Send.To.Lod(183,shl(i,1));  /* Rewrite cue */         /* Create a system event when the cue directory contents changes: */         new.dtd.info = new.dtd.info \ 8192;         call BUILD.CUE.HIST.REC(DTD.Cue#,0,hist.rec);         call ADD.CUE.TO.HIST(hist.rec);         /* keep the id in the cue record itself up to date */         write(mam) = Cue.Ptr;         write(mal) = cue.alloc#;         write(md)  = DTD.Cue#;         return DTD.Cue#;      end;      else return 0;   end;   else return 0;end REPLACE.ENTIRE.DTD.CUE;DELETE.DTD.CUE: proc (id) public swapable;   dcl id       fixed;   dcl i        fixed;   dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   if DTD.MAX.SECS <> 0 then do;      call BUILD.CUE.HIST.REC(id,1,hist.rec);    /* must build record before we ax the cue */      write(mam) = SCSI.Ptr;      write(mdi) = id;      DTD.Cue# = 0;      call Send.To.Lod(184,2);      /* Create a system event when the cue directory contents changes: */      new.dtd.info = new.dtd.info \ 8192;      call ADD.CUE.TO.HIST(hist.rec);      return DTD.Cue#;   end;   else return 0;end DELETE.DTD.CUE;