/* LOD-EDT2  $TITLE  Routines to Edit Cue Records (Part 2) */dcl E$Status         fixed public; /* status of last edit operation */CUE.LOOKUP: proc (Cue.Ptr,Offset) fixed public recursive;   dcl Cue.Ptr fixed;   dcl Offset  fixed;   write(mam)=Cue.Ptr+shr(Offset,8);   write(mal)=Offset;   return read(md);end CUE.LOOKUP;CUE.STORE: proc (Cue.Ptr,Offset,Value) fixed public recursive;   dcl Cue.Ptr fixed;   dcl Offset  fixed;   dcl Value   fixed;   write(mam)=Cue.Ptr+shr(Offset,8);   write(mal)=Offset;   write(mdi)=Value;end CUE.STORE;READ.CUE.TIME: proc (Cue.Ptr,Time.Ptr,Out.Time) public swapable;   dcl Cue.Ptr  fixed;   dcl Time.Ptr fixed;   dcl Out.Time array;   write(mam)=Cue.Ptr;   write(mal)=Time.Ptr;   Out.Time(0)=read(mdi);    Out.Time(1)=read(md);end READ.CUE.TIME;WRITE.CUE.TIME: proc (Cue.Ptr,Time.Ptr,Time) public swapable;   dcl Cue.Ptr  fixed;   dcl Time.Ptr fixed;   dcl Time     array;   write(mam)=Cue.Ptr;   write(mal)=Time.Ptr;   write(mdi)=Time(0);   write(md )=Time(1);end WRITE.CUE.TIME;COMPUTE.CUE.SEGMENT.PTR: proc (Cue.Ptr,Seg#) fixed public swapable;   dcl Cue.Ptr fixed;   dcl Seg#    fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Ptr;   load Seg#; mul Cue.Seg.Stride;   return read(md)+res; /* offset from start of cue to desired edit segment */end COMPUTE.CUE.SEGMENT.PTR;/* $SUBTITLE Primitives to PUT and GET Cue Edit List Segments */PUT.EDIT.SEGMENT: proc (Cue.Ptr,Seg#,Segment) public swapable;   dcl Cue.Ptr  fixed;   dcl Seg#     fixed;   dcl Segment  array;   dcl Ptr      fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Ptr;   load Seg#; mul Cue.Seg.Stride;   Ptr=read(md)+res;    /* offset from start of cue to desired edit segment */   write(mam)=Cue.Ptr+shr(Ptr,8);   write(mal)=Ptr;   write("300")=addr(Segment(0));   rpc Cue.Seg.Stride;   write(mdi)=read("360");end PUT.EDIT.SEGMENT;GET.EDIT.SEGMENT: proc (Cue.Ptr,Seg#,Segment) public swapable;   dcl Cue.Ptr  fixed;   dcl Seg#     fixed;   dcl Segment  array;   dcl Ptr      fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Ptr;   load Seg#; mul Cue.Seg.Stride;   Ptr=read(md)+res;    /* offset from start of cue to desired edit segment */   write(mam)=Cue.Ptr+shr(Ptr,8);   write(mal)=Ptr;   write("300")=addr(Segment(0));   rpc Cue.Seg.Stride;   write("360")=read(mdi);end GET.EDIT.SEGMENT;/* $SUBTITLE Routine to Append a Cue Edit Segment to the End of a Cue Record */APPEND.EDIT.SEGMENT: proc (Cue.Ptr,Segment) fixed public swapable;   dcl Cue.Ptr  fixed; /* xmem ptr to a reel cue record */   dcl Segment  array; /* an edit segment record */   dcl Ptr      fixed;   write(mam)=Cue.Ptr;   write(mal)=Cue.RLen;   Ptr=read(md)+Cue.Seg.Stride;        /* compute length of cue after append */   if (Ptr ilt Cue.Seg.Stride)         /* overflow */   or (Ptr igt Max.Cue.Record.Len)     /* or just no more room in cue record */   then do;      return E#TooLong;                /* cannot append edit segment to cue */   end;   write(md)=Ptr;                      /* set length of cue record after append */   write(mal)=Cue.List.Len;   Ptr       =read(md);                /* save relative ptr to end of edit list */   write(md )=Ptr+Cue.Seg.Stride;      /* advance length of edit list in cue record */   write(mam)=Cue.Ptr;                 /* compute offset from cue start */   write(mal)=Cue.List.Ptr;            /* to desired append location    */   Ptr=Ptr+read(md);   write(mam)=Cue.Ptr+shr(Ptr,8);   write(mal)=Ptr;   write("300")=addr(Segment(0));   rpc Cue.Seg.Stride;   write(mdi)=read("360");   return E#Good;end APPEND.EDIT.SEGMENT;/* $SUBTITLE Routine to Shuffle Parts of Cue Edit Lists Around */SHUFFLE.EDIT.SEGMENTS: proc (Cue.Ptr,Sou.Seg#,Des.Seg#,Num) public swapable;   dcl Cue.Ptr           fixed;   dcl Sou.Seg#          fixed;   dcl Des.Seg#          fixed;   dcl Num               fixed;   dcl (Sou.Ptr,Des.Ptr) fixed;   if Sou.Seg#=Des.Seg# then return;   write(mam)=Cue.Ptr;   write(mal)=Cue.List.Ptr;   if read(md)=0 then return;    /* simple cue -- nothing to shuffle */   load Sou.Seg#; mul Cue.Seg.Stride;   Sou.Ptr=read(md)+res;         /* offset from start of cue to source edit segment */   load Des.Seg#; mul Cue.Seg.Stride;   Des.Ptr=read(md)+res;         /* offset from start of cue to dest edit segment */   load Num; mul Cue.Seg.Stride; /* number of words to copy */   Num=res;      call Copy.Ext.Mem(Cue.Ptr,Sou.Ptr,Cue.Ptr,Des.Ptr,Num); /* do the copy */end SHUFFLE.EDIT.SEGMENTS;/* $SUBTITLE Routines to Initialize and Erase Cue Edit Lists */INITIALIZE.REEL: proc (Cue.Ptr) public swapable; /* turns old format "simple" cue into reel cue */   dcl Cue.Ptr    fixed; /* xmem ptr to cue record to segment to erase */   dcl RLen       fixed;   dcl Name.End   fixed;   dcl Drive.Bits fixed;   dcl SegPtr     fixed;   if Cue.Lookup(Cue.Ptr,Cue.List.Ptr)=0 then do; /* we are initializing a regular cue */      write(mal)=Cue.RLen;                   /* look up total cue record len */      RLen=read(md);      write(mal)=Cue.Name;      Name.End=Cue.Name+1+shr(read(md)+1,1); /* compute rel ptr to 1st word beyond cue name field */      if RLen ilt Name.End then return;      /* major problems here */      if RLen = Name.End then do;            /* no info in comment area */         write(mal)=RLen;         write(md )=0;                       /* save null string in comment field */         RLen=RLen+1;                        /* cue record 1 word longer */      end;      write(mal)=Cue.List.Ptr;      write(md )=RLen;                       /* edit segment list starts here */   end;   write(mal)=Cue.List.Len;   write(md )=Cue.Seg.Stride;     /* reset edit list len to 1 segment */   write(mal)=Cue.List.Ptr;   SegPtr    =read(md);           /* look up ptr to edit segment list */   write(mal)=Cue.Trks;           /* look up drive bits for cue       */   Drive.Bits=read(md);   write(mam)=Cue.Ptr+shr(SegPtr,8);   write(mal)=SegPtr;   /* set up initial data for simplest reel cue */   write(mdi)=0;          write(mdi)=0;    /* sync     addr      */    write(mdi)=0;          write(mdi)=0;    /* disk in  addr      */   write(mdi)=(-1);       write(mdi)=(-1); /* disk out addr      */   write(mdi)=Drive.Bits; write(mdi)=0;    /* 4 drive bits words */   write(mdi)=0;          write(mdi)=0;    /*   drive bits words */   write(mdi)=1;                           /* fade in  time      */   write(mdi)=1;                           /* fade out time      */   write(mdi)=0;          write(mdi)=0;    /* 4 reserved words   */   write(mdi)=0;          write(mdi)=0;    /*   reserved words   */   call Cue.Store(Cue.Ptr,Cue.RLen,SegPtr+Cue.Seg.Stride); /* adjust cue record length */end INITIALIZE.REEL;ERASE.REEL.EDIT.LIST: proc (Cue.Ptr) swapable; /* gets rid of entire edit list in a reel */   dcl Cue.Ptr  fixed; /* xmem ptr to cue record to erase */   dcl SegPtr   fixed;   if Cue.Lookup(Cue.Ptr,Cue.List.Ptr)=0    /* we are erasing a regular cue */   then call Initialize.Reel(Cue.Ptr);      /* first convert to reel format */   call Cue.Store(Cue.Ptr,Cue.List.Len,0);  /* reset length of edit list to zero */   SegPtr=Cue.Lookup(Cue.Ptr,Cue.List.Ptr); /* look up ptr to start of edit list segments */   call Cue.Store(Cue.Ptr,Cue.RLen,SegPtr); /* adjust cue record length */end ERASE.REEL.EDIT.LIST;/* $SUBTITLE Routines to Copy Cues and Parts of Cues */COPY.CUE: proc (Sou.Cue,Des.Cue,Protect.Name) fixed public swapable;   dcl (Sou.Cue,Des.Cue) fixed; /* xmem ptrs to source and dest cues */   dcl Protect.Name      fixed; /* set true to preserve name of Dest Cue Record */   dcl Sou.EDL.Ptr       fixed;   dcl Sou.EDL.Len       fixed;   dcl Des.EDL.Ptr       fixed;   dcl Cue.Len           fixed;   if Sou.Cue=Des.Cue then return E#Good;   if Protect.Name then do;      /* NOTE: Routine copies all header info except for Name */      /*       and Caption, and copies the Edit Decision List */      Sou.EDL.Ptr=Cue.Lookup(Sou.Cue,Cue.List.Ptr);      if Sou.EDL.Ptr<>0 then do; /* source cue contains an EDL */         Sou.EDL.Len=Cue.Lookup(Sou.Cue,Cue.List.Len);         Des.EDL.Ptr=Cue.Lookup(Des.Cue,Cue.List.Ptr);         if Des.EDL.Ptr=0 then do;            call Initialize.Reel(Des.Cue);            Des.EDL.Ptr=Cue.Lookup(Des.Cue,Cue.List.Ptr);         end;         /* see if room in dest cue to copy EDL */         if ((Des.EDL.Ptr+Sou.EDL.Len) igt Max.Cue.Record.Len)         or ((Des.EDL.Ptr+Sou.EDL.Len) ilt Sou.EDL.Len)         then return E#TooLong;      /* not enough room for copy */         /* copy cue header and EDL */         call Copy.Ext.Mem(Sou.Cue,          0,Des.Cue,          0,   Cue.Name); /* copy header info up to Name field */         call Copy.Ext.Mem(Sou.Cue,Sou.EDL.Ptr,Des.Cue,Des.EDL.Ptr,Sou.EDL.Len); /* copy EDL */         call Cue.Store(Des.Cue,Cue.List.Ptr,Des.EDL.Ptr);        /* restore EDL ptr to correct value */         call Cue.Store(Des.Cue,Cue.List.Len,Sou.EDL.Len);        /* save new EDL len */         call Cue.Store(Des.Cue,Cue.RLen    ,Des.EDL.Ptr+Sou.EDL.Len); /* and adjust destination cue record */      end;      else do; /* no EDL in Source, just copy header */         call Copy.Ext.Mem(Sou.Cue,1,Des.Cue,1,Cue.Name-1); /* copy header info up to Name field (except for Cue Len) */      end;   end;   else do;      write(mam)=Sou.Cue;      write(mal)=Cue.RLen;      Cue.Len=read(md);      call Copy.Ext.Mem(Sou.Cue,0,Des.Cue,0,Cue.Len); /* copy info over */   end;   return E#Good;end COPY.CUE;/* $PAGE */COPY.CUE.HEADER: proc (Sou.Cue.Ptr,Des.Cue.Ptr,Protect.Name) public swapable;   dcl Sou.Cue.Ptr  fixed; /* ptrs to source and destination cues */   dcl Des.Cue.Ptr  fixed;   dcl Protect.Name fixed; /* set true to preserve name of Dest Cue Record */   dcl Header.Len   fixed;   dcl Name.End     fixed;   dcl Saved.Ptr    fixed;   dcl Saved.Len    fixed;   dcl RLen         fixed; /* cue record length */   if Protect.Name then do;      /* Copies all cue header info except for Name and Comment fields */      /* Does not change Cue.List.Ptr or Cue.List.Len in Destination   */      /* Cue Record.                                                   */      Saved.Ptr=Cue.Lookup(Des.Cue.Ptr,Cue.List.Ptr);      Saved.Len=Cue.Lookup(Des.Cue.Ptr,Cue.List.Len);      call Copy.Ext.Mem(Sou.Cue.Ptr,0,Des.Cue.Ptr,0,Cue.Name); /* copy header info */      call Cue.Store(Des.Cue.Ptr,Cue.List.Ptr,Saved.Ptr);      call Cue.Store(Des.Cue.Ptr,Cue.List.Len,Saved.Len);   end;   else do;      /* Copies ALL cue header info (including Name and Comment fields) */      /* Routine assumes you will be rebuilding the EDL at some time    */      /* after doing this copy.                                         */      if Cue.Lookup(Sou.Cue.Ptr,Cue.List.Ptr)=0 then do; /* older format "simple" cue */         write(mal)=Cue.RLen;        /* look up total cue record len */         RLen=read(md);         write(mal)=Cue.Name;         Name.End=Cue.Name+1+shr(read(md)+1,1); /* compute rel ptr to 1st word beyond cue name field */         if RLen ilt Name.End          then return;                /* major problems here - just quit operation */         else Header.Len=RLen;       /* length of cue header */      end;      else do;                       /* reel cue format */         Header.Len=read(md);      end;      call Copy.Ext.Mem(Sou.Cue.Ptr,0,Des.Cue.Ptr,0,Header.Len); /* copy header info */   end;end COPY.CUE.HEADER;/* $SUBTITLE Routines to Perform Calculations on Edit Segments */GET.CUE.DURATION: proc (Cue.Ptr,OutDur) public swapable; /* compute length between IN and OUT addrs of cue */   dcl Cue.Ptr fixed; /* xmem ptr to cue record */   dcl OutDur  array;   write(mam)=Cue.Ptr;   write(mal)=Cue.E.Msb;   OutDur(0)=read(mdi); OutDur(1)=read(md);   write(mal)=Cue.S.Msb;   OutDur(0)=OutDur(0)-read(mdi);   if read(md) igt OutDur(1) then OutDur(0)=OutDur(0)-1;   OutDur(1)=OutDur(1)-read(md);end GET.CUE.DURATION;GET.SEGMENT.DURATION: proc (Segment,OutDur) public swapable; /* compute duration of passed edit segment */   dcl Segment array;   dcl OutDur  array;   call Sub32(Loc(Addr(Segment(S#Out.Msb))), /* compute duration of edit segment */              Loc(Addr(Segment(S#In.Msb))),              OutDur);end GET.SEGMENT.DURATION;GET.SEGMENT.SYNC.END.TIME: proc (Segment,OutTime) public swapable; /* compute sync end time of passed edit segment */   dcl Segment array;   dcl OutTime array;   call Sub32(Loc(Addr(Segment(S#Out.Msb))),  /* compute duration of edit segment */              Loc(Addr(Segment(S#In.Msb))),              OutTime);   call Add32(Loc(Addr(Segment(S#Sync.Msb))), /* add segment dur      */              OutTime,                        /* to segment sync time */              OutTime);                       /* to get sync end time */   if Com32(OutTime,Loc(Addr(Segment(S#Sync.Msb))))=lw#ilt   then do; /* Overflow -- limit to (-1,-1) */      OutTime(0)=(-1);      OutTime(1)=(-1);   end;end GET.SEGMENT.SYNC.END.TIME;/* $SUBTITLE Description of Relationships between Edit Regions and Cue Segments *//* THE SIX DIFFERENT RELATIONSHIPS BETWEEN CUE EDIT SEGMENTS .  AND EDIT IN/OUT ADDRS FOR OPERATIONS LIKE CUT, COPY, EXTRACT,.  DELETE, FILL, ETC:..                    EDIT IN                     EDIT OUT.                       +---------------------------+.                       |                           |.  [--+-------+---+--+--+----+----+-------+----+----+--+---+---+-------+--].     |       |   |  |       |    |       |    |       |   |   |       |.     +-------+   |  +-------+    +-------+    +-------+   |   +-------+.      Case #1    |   Case #2      Case #3      Case #4    |    Case #5.                 |                                        |.                 +----------------------------------------+.                                  Case #6..                             CUE EDIT SEGMENTS...............................................................................  THE THREE DIFFERENT RELATIONSHIPS BETWEEN CUE EDIT SEGMENTS .  AND EDIT IN/OUT ADDRS FOR PASTE OPERATIONS:..                    EDIT IN                     EDIT OUT.                       +-------- PASTE LEN --------+.                       |                           |.  [--+-------+------+--+----+----------------------+----------+-------+--].     |       |      |       |                                 |       |.     +-------+      +-------+                                 +-------+.      Case #1        Case #6                                   Case #5.                                                           .                             CUE EDIT SEGMENTS..................................................................................  TRUTH TABLE FOR THE 6 CASES:..     S In  = Segment Sync  In  Address.     S Out = Segment Sync  Out Address.     E In  = Edit Location In  Address.     E Out = Edit Location Out Address..     +----+------------+--------------+-------------+--------------+.     |Case|S In to E In|S Out to E In |S In to E Out|S Out to E Out|.     +----+------------+--------------+-------------+--------------+.     | 1  |    ILT     |     ILE      |    ILT      |     ILT      |.     +----+------------+--------------+-------------+--------------+.     | 2  |    ILT     |     IGT      |    ILT      |     ILE      |.     +----+------------+--------------+-------------+--------------+.     | 3  |    IGE     |     IGT      |    ILT      |     ILE      |.     +----+------------+--------------+-------------+--------------+.     | 4  |    IGE     |     IGT      |    ILT      |     IGT      |.     +----+------------+--------------+-------------+--------------+.     | 5  |    IGT     |     IGT      |    IGE      |     IGT      |.     +----+------------+--------------+-------------+--------------+.     | 6  |    ILT     |     IGT      |    ILT      |     IGT      |.     +----+------------+--------------+-------------+--------------+.*//* $PAGE */MAP.TIMES.TO.EDIT.CASE: proc (Sync.In,Sync.Out,Edit.In,Edit.Out) fixed swapable;   dcl (Sync.In,Sync.Out)   array; /* hold segment in and out sync addrs */   dcl (Edit.In,Edit.Out)   array; /* logical address to begin delete from */   dcl (SIn2EOut,SOut2Ein)  fixed; /* hold results of comparison of Sync addrs to Edit In addr */   dcl (SIn2EIn ,SOut2EOut) fixed; /* hold results of comparison of Sync addrs to Edit Out addr */   dcl Edit.Case            fixed;   /* NOTE: returns case numbers according to above diagrams */   SIn2EIn  =Com32(Sync.In, Edit.In);   /* compare each SYNC addr with */   SOut2EIn =Com32(Sync.Out,Edit.In);   /* each EDIT addr              */   SIn2EOut =Com32(Sync.In, Edit.Out);   SOut2EOut=Com32(Sync.Out,Edit.Out);   if SIn2EIn=lw#ilt then do;   /* either Case 1, Case 2, or Case 6 */      if SOut2EIn<>lw#igt       /* distinguishes Case 1 from Cases 2 & 6 */      then Edit.Case=1;      else if SOut2EOut=lw#igt  /* distinguishes Case 2 from Case 6 */      then Edit.Case=6;      else Edit.Case=2;   end;   else do;                     /* either Case 3, Case 4, or Case 5 */      if SOut2EOut<>lw#igt      /* distinguishes Case 3 from Cases 4 & 5 */      then Edit.Case=3;      else if SIn2EOut=lw#ilt   /* distinguishes Case 4 from Case 5 */      then Edit.Case=4;      else Edit.Case=5;   end;   return Edit.Case;end MAP.TIMES.TO.EDIT.CASE;/* $SUBTITLE Routine to Compress Out Unused Edit Segments in a Reel */SQUEEZE.UNUSED.SEGMENTS: proc (Cue.Ptr,Seg.Bits) swapable;   dcl Cue.Ptr       fixed;   dcl Seg.Bits      array;   dcl Num.Segs      fixed;   dcl (Sou,Des,Num) fixed;   /* deletes edit segments denoted by */   /* set bits in the array SEG.BITS   */   if Cue.Lookup(Cue.Ptr,Cue.List.Ptr)=0 then return; /* cue is in "simple" format - all done */   load Cue.Lookup(Cue.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Segs=res;                      /* number of edit segments in cue */   Des=0;   do while (Des ILT Num.Segs)  /* step past 1st block segments we want to keep */      and   ((Seg.Bits(shr(Des,4))&Bits(Des&15))=0);      Des=Des+1;   end;   Sou=Des+1;   do while Sou ILT Num.Segs;      do while (Sou ILT Num.Segs)  /* skip past segments we want to delete */         and   ((Seg.Bits(shr(Sou,4))&Bits(Sou&15))<>0);         Sou=Sou+1;      end;        Num=1;      do while ((Sou+Num) ILT Num.Segs)  /* count next block of segments we want to keep */      and      ((Seg.Bits(shr(Sou+Num,4))&Bits((Sou+Num)&15))=0);         Num=Num+1;      end;      if Sou ILT Num.Segs then do;  /* shuffle down block of segs to keep */         call Shuffle.Edit.Segments(Cue.Ptr,Sou,Des,Num);         Des=Des+Num;         Sou=Sou+Num;      end;   end;   load Des; mul Cue.Seg.Stride; Num=res;    /* final length of edit list */   Sou=Cue.Lookup(Cue.Ptr,Cue.List.Ptr);     /* length of cue w/o edit list */   call Cue.Store(Cue.Ptr,Cue.RLen,Sou+Num); /* new cue length after collect */   call Cue.Store(Cue.Ptr,Cue.List.Len,Num); /* new edit list length */end SQUEEZE.UNUSED.SEGMENTS;/* $SUBTITLE Routine to Garbage Collect Cue Records after an Edit */GARBAGE.COLLECT.REEL: proc (Cue.Ptr) public swapable;   dcl Cue.Ptr       fixed; /* xmem ptr to valid cue record */   dcl Num.Segs      fixed;   dcl (S#,I)        fixed;   dcl SOut2Sin      fixed;   dcl Sync.Out  (1) fixed;   dcl Seg.Modified  fixed;   dcl Seg  (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   dcl Seg1 (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   /* NOTE: Routine uses MISC.BUF to hold bits for collect */   /*       Performs an IN-PLACE garbage collect.          */   if Cue.Lookup(Cue.Ptr,Cue.List.Ptr)=0 then return; /* cue is in "simple" format - all done */   load Cue.Lookup(Cue.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Segs=res;                              /* number of edit segments in cue */   do I=0 to shr(Num.Segs,4);                 /* initialize bits of MISC.BUF */      Misc.Buf(I)=0;   end;   do S#=0 to Num.Segs-1;                     /* loop over all segments */      if (Misc.Buf(shr(S#,4))&Bits(S#&15))=0 then do; /* segment is not already deleted */         call Get.Edit.Segment(Cue.Ptr,S#,Seg);  /* read in segment from source */         if Com32(loc(addr(Seg(S#In.Msb))),loc(addr(Seg(S#Out.Msb))))=lw#ieq         then do; /* segment has zero duration - delete it */            Misc.Buf(shr(S#,4))=Misc.Buf(shr(S#,4))|Bits(S#&15); /* set bit to erase SEG */         end;         else do; /* look for segments which can be spliced to current seg */            I=S#+1; Seg.Modified=false;            do while I ILT Num.Segs;  /* search through segments following our current seg */               call Get.Edit.Segment(Cue.Ptr,I,Seg1); /* read in 2nd segment from source */               if Seg(S#DriveBits1)=Seg1(S#DriveBits1)                then do;                       /* exact match in drive bits */                  if Com32(loc(addr(Seg(S#Out.Msb))),loc(addr(Seg1(S#In.Msb))))=lw#ieq                  then do;                    /* and 1st Seg DISK OUT addr matches 2nd Seg DISK IN addr */                     call Get.Segment.Sync.End.Time(Seg,Sync.Out); /* compute SYNC OUT addr for 1st edit segment */                     SOut2Sin=Com32(Sync.Out,loc(addr(Seg1(S#Sync.Msb)))); /* compare SYNC OUT with SYNC IN of 2nd segment */                     if SOut2Sin=lw#ieq     /* times are equal -- these */                     then do;               /* segments can be combined */                        Seg.Modified=true;                        Misc.Buf(shr(I,4))=Misc.Buf(shr(I,4))|Bits(I&15); /* set bit to erase SEG1 */                        call Copy32(loc(addr(Seg1(S#Out.Msb))),loc(addr(Seg(S#Out.Msb)))); /* update info in SEG    */                     end;                  end;               end;               I=I+1;            end;           /* of inner loop through edit segments */            if Seg.Modified   /* write modified data back to cue */            then call Put.Edit.Segment(Cue.Ptr,S#,Seg);         end;           /* of looking for segments which can be spliced to current seg */      end;              /* of segment not already deleted */   end;                 /* of loop over segments */   call Squeeze.Unused.Segments(Cue.Ptr,Misc.Buf); /* toss segments which we don't need anymore */end GARBAGE.COLLECT.REEL;