/* LOD-EDT3  $TITLE  Routines to Edit Cue Record Reels (Part 3) *//*  05/03/91 - cj  - Fixed bug with PASTE from fixes of 4/25/91    *//*  04/25/91 - cj  - Rounded certain edits to sector boundary      *//*                   to fix Don Dorsey edit bugs                   *//*  08/08/88 - cj  - store absolute # of smpte bits in cue record  *//* Routine to intelligently round edit times to sector boundaries. *//* Done in a certain way to expan tiny segments to include audio   *//* as needed.                                                      */ROUND.REGION.TIMES: proc (In, Out) swapable;   dcl In  array;   dcl Out array;   /* note: this routine assumes the in time and out time          */   /* have been checked and that out > in                          */   if COM32(In, Out) = LW#IEQ            /* if no region is selected,    */   then do;                              /* then just round both         */      call ADD16(128, In);               /* in and out to the same time  */      In(1) = In(1) & "177400";          /* as opposed to extending the  */      call COPY32(In, Out);              /* edit region                  */      return;   end;   call ADD16(128, In);                  /* begin by rounding IN time to */   In(1) = In(1) & "177400";             /* sector bound                 */   if COM32(In, Out) >= LW#IEQ           /* if IN is now >= out, then    */   then call SUB16(256, In);             /* must be accessing short seg  */   call ADD16(128, Out);                 /* now round out to sector      */   Out(1) = Out(1) & "177400";           /* bound                        */   if COM32(In, Out) >= LW#IEQ           /* if zero length segment, then */   then call ADD16(256, Out);            /* expand it                    */end ROUND.REGION.TIMES;ROUND.EDIT.TIMES: proc (Cue.Ptr) swapable;   dcl Cue.Ptr                fixed;   dcl Edit.In  (1)           fixed;   dcl Edit.Out (1)           fixed;   dcl ptr                    fixed;   dcl len                    fixed;   dcl num.segs               fixed;   dcl s#                     fixed;   dcl t                      fixed;   dcl next(1)                fixed;   dcl temp(1)                fixed;   dcl seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   round:proc(seg, where);           /* handy procedure to  */      dcl seg    array;              /* round a time in     */      dcl where  fixed;              /* a segment           */      call ADD16(128, loc(addr(seg(where))));      seg(where+1) = seg(where+1)&"177400";   end round;   /* note: this routine assumes the edit in and edit out time     */   /* have been checked and the edit out > edit in                 */   call Read.Cue.Time(Cue.Ptr,Cue.Edit.In.Msb ,Edit.In ); /* get times   */   call Read.Cue.Time(Cue.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* handy       */   call ROUND.REGION.TIMES(Edit.In, Edit.Out);   call Write.Cue.Time(Cue.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* store back */   call Write.Cue.Time(Cue.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* in cue     */   /* Now round the cue segments the same way the real time software     */   /* does:                                                              */   ptr = Cue.Lookup(Cue.Ptr,Cue.List.Ptr);   len = Cue.Lookup(Cue.Ptr,Cue.List.Len);   if ptr<>0 then do;                    /* if any segments exist        */      load len;                          /* then figure out how many     */      div  Cue.Seg.Stride;               /* segments there are and       */      num.segs = res;                    /* process each one.            */      do s#=0 to num.segs-1;         call Get.Edit.Segment(Cue.Ptr,s#,seg);         if (seg(S#Out.Msb) = (-1))      /* if seg extends to infinity, */         then do;                        /* just round sync & in        */            call round(seg,s#sync.msb);  /* but leave out time at -1,   */            call round(seg,s#in.msb);    /* -1                          */         end;         else if s# = num.segs-1         /* else if last segment,       */         then do;                        /* round sync, in, out         */            call round(seg,s#in.msb);    /* because there is no next    */            call round(seg,s#out.msb);   /* segment to look at.         */            call round(seg,s#sync.msb);         end;         else do;                        /* else see if exact fit       */            t = ptr + (s#+1)*Cue.Seg.Stride + S#Sync.Msb;            write(mam)=Cue.Ptr+shr(t,8);            write(mal)=t;            next(0) = read(mdi);         /* get sync time of next       */            next(1) = read(mdi);         /* segment                     */            call Sub32(Loc(Addr(seg(S#Out.Msb))),   /* get length of    */                       Loc(Addr(seg(S#In.Msb ))),   /* this segment     */                       temp);            call Add32(Loc(Addr(seg(S#Sync.Msb))),  /* compute sync     */                       temp, temp);                 /* end time         */            if COM32(next,temp) = lw#ieq     /* if next segment begins  */            then do;                         /* at end of this segment, */               call round(seg,s#in.msb);     /* adjust length of this   */               call round(seg,s#sync.msb);   /* segment to reflect      */               call ADD16(128, next);        /* rounding.               */               next(1) = next(1) & "177400";               call SUB32(next, Loc(Addr(seg(S#Sync.Msb))), temp);               call ADD32(temp, Loc(Addr(seg(S#In.Msb))),                                Loc(Addr(seg(S#Out.Msb))));            end;            else do;                         /* else just round         */               call round(seg,s#in.msb);     /* all three times         */               call round(seg,s#out.msb);    /* if there is leader      */               call round(seg,s#sync.msb);   /* between this segment    */            end;                             /* and the next            */         end;         call Put.Edit.Segment(Cue.Ptr,s#,seg);      end;   end;end ROUND.EDIT.TIMES;/* Main routine for Cut and Delete */DELETE.FROM.REEL: proc (Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr                fixed; /* xmem ptr to cue to delete from */   dcl Des.Ptr                fixed; /* xmem ptr to cue to put result in */   dcl Protect.Des.Name       fixed; /* set true to preserve name of Dest Cue Record */   dcl Protect.Work.Name      fixed;   dcl Work.Cue.Ptr           fixed;   dcl Edit.In            (1) fixed; /* logical address to begin delete from */   dcl Edit.Out           (1) fixed; /* logical address to end delete at */   dcl (Num.Sou.Segs,S#)      fixed;   dcl Seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   dcl (T)                (1) fixed; /* time         buffer */   dcl (Sync.In,Sync.Out) (1) fixed; /* hold segment in and out sync addrs */   dcl Edit.Case              fixed;   /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out) = lw#igt /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out) = lw#ieq /* EDIT IN point equal to EDIT OUT point */   then do;      E$Status=Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name);      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   if Cue.Lookup(Sou.Ptr,Cue.List.Ptr)=0 then do; /* cue is in "simple" format */      call Initialize.Reel(Sou.Ptr);   /* convert to reel cue format */   end;   if Sou.Ptr=Des.Ptr then do;         /* doing an in-place extract */      Work.Cue.Ptr=Scratch.Cue.Ptr1;    /* use default scratch cue   */      Protect.Work.Name=false;         /* use source cue name       */   end;   else do;      Work.Cue.Ptr=Des.Ptr;               /* use passed cue         */      Protect.Work.Name=Protect.Des.Name; /* keep des cue name      */   end;   call Copy.Cue.Header(Sou.Ptr,Work.Cue.Ptr,Protect.Work.Name); /* copy source header onto work cue */   call Erase.Reel.Edit.List(Work.Cue.Ptr); /* dump EDL from Scratch Cue */   load Cue.Lookup(Sou.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Sou.Segs=res;                          /* number of edit segments in cue */   do S#=0 to Num.Sou.Segs-1;                 /* loop over all segments */      call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* read in segment from source */      call Copy32(loc(addr(Seg(S#Sync.Msb))),Sync.In ); /* extract SYNC IN  addr from edit segment */      call Get.Segment.Sync.End.Time    (Seg,Sync.Out); /* compute SYNC OUT addr for this edit segment */      Edit.Case=Map.Times.To.Edit.Case(Sync.In,Sync.Out,Edit.In,Edit.Out);      do case (Edit.Case-1);         do; /* CASE #1 */            /* edit segment unaffected            */            /* simply copy over to scratch buffer */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #2 */            /* trim edit segment DISK END address back to EDIT IN point */            /* if CUE OUT = EDIT OUT then we might */            /* want to extend DISK OUT to (-1,-1)? */            call Sub32(Edit.In,Sync.In,T); /* distance from SYNC IN to EDIT IN */            call Add32(loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#Out.Msb)))); /* move DISK OUT back to EDIT IN point */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #3 */            /* toss edit segment completely */         end;         /* $PAGE */         do; /* CASE #4 */            /* edit segment SYNC IN address gets set to EDIT IN point */            /* trim DISK IN address to EDIT OUT point                 */            call Sub32 (Edit.Out,Sync.In,T);                    /* distance from SYNC IN to EDIT OUT */            call Copy32(Edit.In,loc(addr(Seg(S#Sync.Msb)))); /* SYNC IN comes back to EDIT IN point */            call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#In.Msb)))); /* move DISK IN point back by amount deleted */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #5 */            /* subtract EDIT LENGTH from SYNC IN address     */            /* then just copy segment over to scratch buffer */            call Sub32(Edit.Out,Edit.In,T);  /* length of EDIT region */            call Sub32(loc(addr(Seg(S#Sync.Msb))),T,loc(addr(Seg(S#Sync.Msb)))); /* move SYNC IN point back by amount deleted */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #6 */            /* trim edit segment DISK END address back to EDIT IN point */            /* if CUE OUT = EDIT OUT then we might */            /* want to extend DISK OUT to (-1,-1)? */            call Sub32(Edit.In,Sync.In,T); /* distance from SYNC IN to EDIT IN */            call Add32(loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#Out.Msb)))); /* move DISK OUT back to EDIT IN point */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;            /* create 2nd edit segment                   */            /* set its SYNC IN address to EDIT IN  point */            /* set its DISK IN address to EDIT OUT point */            call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* re-read segment from source */            call Sub32 (Edit.Out,Sync.In,T);                    /* distance from SYNC IN to EDIT OUT */            call Copy32(Edit.In,loc(addr(Seg(S#Sync.Msb)))); /* SYNC IN comes back to EDIT IN point */            call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#In.Msb)))); /* move DISK IN point back by amount deleted */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;      end;                                    /* of do delete on this segment */   end;                                       /* of loop over segments */   call Garbage.Collect.Reel(Work.Cue.Ptr); /* eliminate unecessary edit segments */   call Write.Cue.Time(Work.Cue.Ptr,Cue.Edit.Out.Msb,Edit.In); /* reset EDIT OUT point to EDIT IN point */   call Sub32(Edit.Out,Edit.In,T);            /* compute length of region deleted */   call Read.Cue.Time(Work.Cue.Ptr,Cue.E.Msb,Sync.Out);   call Sub32(Sync.Out,T,Sync.Out);           /* back up cue end time by length deleted */   call Write.Cue.Time(Work.Cue.Ptr,Cue.E.Msb,Sync.Out);   if Sou.Ptr=Des.Ptr                         /* did an in-place insert */   then call Copy.Cue(Scratch.Cue.Ptr1,Sou.Ptr,false); /* copy info back from scratch buffer to our cue */   return E$Status;                           /* edit was successful */   /* ERROR HANDLERS BELOW: */   NO.ROOM: E$Status=E#TooLong; return E$Status; /* ran out of room in edit list */end DELETE.FROM.REEL;/* $SUBTITLE  Routine to Insert Silence on a Reel */INSERT.LEADER.ON.REEL: proc (Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr                fixed; /* xmem ptr to cue to insert from */   dcl Des.Ptr                fixed; /* xmem ptr to cue to put result in */   dcl Protect.Des.Name       fixed; /* set true to preserve name of Dest Cue Record */   dcl Protect.Work.Name      fixed;   dcl Work.Cue.Ptr           fixed;   dcl Edit.In            (1) fixed; /* logical address to begin insert at */   dcl Edit.Out           (1) fixed; /* logical address to slide EDIT IN point to */   dcl Edit.Len           (1) fixed; /* logical length to slide EDIT IN by */   dcl (Sync.In,Sync.Out) (1) fixed; /* hold segment in and out sync addrs */   dcl (T)                (1) fixed; /* time         buffer */   dcl (Num.Sou.Segs,S#)      fixed;   dcl Seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   dcl Edit.Case              fixed;   /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out) = lw#igt /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out) = lw#ieq /* EDIT IN point equal to EDIT OUT point */   then do;      E$Status=Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name);      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   call Sub32(Edit.Out,Edit.In,Edit.Len);                 /* compute length of leader to insert */   if Cue.Lookup(Sou.Ptr,Cue.List.Ptr)=0 then do; /* cue is in "simple" format */      call Initialize.Reel(Sou.Ptr);   /* convert to reel cue format */   end;   if Sou.Ptr=Des.Ptr then do;         /* doing an in-place extract */      Work.Cue.Ptr=Scratch.Cue.Ptr1;   /* use default scratch cue   */      Protect.Work.Name=false;         /* use source cue name       */   end;   else do;      Work.Cue.Ptr=Des.Ptr;               /* use passed cue         */      Protect.Work.Name=Protect.Des.Name; /* keep des cue name      */   end;   call Copy.Cue.Header(Sou.Ptr,Work.Cue.Ptr,Protect.Work.Name); /* copy source header onto work cue */   call Erase.Reel.Edit.List(Work.Cue.Ptr); /* dump EDL from Scratch Cue */   load Cue.Lookup(Sou.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Sou.Segs=res;                          /* number of edit segments in cue */   do S#=0 to Num.Sou.Segs-1;                 /* loop over all segments */      call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* read in segment from source */      call Copy32(loc(addr(Seg(S#Sync.Msb))),Sync.In ); /* extract SYNC IN  addr from edit segment */      call Get.Segment.Sync.End.Time    (Seg,Sync.Out); /* compute SYNC OUT addr for this edit segment */      Edit.Case=Map.Times.To.Edit.Case(Sync.In,Sync.Out,Edit.In,Edit.In);      if Edit.Case=1 then do; /* CASE #1 */         /* edit segment unaffected            */         /* simply copy over to scratch buffer */         if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;      end;      else if Edit.Case=5 then do; /* CASE #5 */         /* add EDIT LENGTH to SYNC IN address            */         /* then just copy segment over to scratch buffer */         call Add32(loc(addr(Seg(S#Sync.Msb))),Edit.Len,loc(addr(Seg(S#Sync.Msb)))); /* move SYNC IN point back by amount deleted */         if Com32(loc(addr(Seg(S#Sync.Msb))),Edit.Len)=lw#ilt then do; /* overflow */            /* might want to toss this segment in the overflow case? */            Seg(S#Sync.Msb)=(-1); Seg(S#Sync.Lsb)=(-1); /* limit */         end;         if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;      end;      /* $PAGE */      else if Edit.Case=6 then do; /* CASE #6 */         /* trim edit segment DISK END address back to EDIT IN point */         call Sub32(Edit.In,Sync.In,T); /* distance from SYNC IN to EDIT IN */         call Add32(loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#Out.Msb)))); /* move DISK OUT back to EDIT IN point */         if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         /* create 2nd edit segment                   */         /* set its SYNC IN address to EDIT IN point + EDIT LEN */         /* set its DISK IN address to EDIT IN point */         call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* re-read segment from source */         call Copy32(Edit.Out,loc(addr(Seg(S#Sync.Msb)))); /* SYNC IN goes out to EDIT IN point + EDIT LEN */         call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#In.Msb)))); /* move DISK IN point back by amount deleted */         if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;      end;   end;                                       /* of loop over segments */   call Read.Cue.Time (Work.Cue.Ptr,Cue.E.Msb,Sync.Out);   call Add32         (Sync.Out,Edit.Len,Sync.Out); /* slide cue end time by length inserted */   if Com32(Sync.Out,Edit.Len)=lw#ilt then do;      /* had an overflow - limit SYNC OUT to (-1,-1) */      Sync.Out(0)=(-1);      Sync.Out(1)=(-1);   end;   call Write.Cue.Time(Work.Cue.Ptr,Cue.E.Msb,Sync.Out);   if Sou.Ptr=Des.Ptr                                 /* did an in-place insert */   then call Copy.Cue(Scratch.Cue.Ptr1,Sou.Ptr,false); /* copy info back from scratch buffer to our cue */   return E$Status;                     /* edit was successful */   /* ERROR HANDLERS BELOW: */   NO.ROOM: E$Status=E#TooLong; return E$Status; /* ran out of room in edit list */end INSERT.LEADER.ON.REEL;/* $SUBTITLE Routine to Extract Part of a Reel and Extend Segment Endpoints */ADJUST.SMPTE.SYNC: proc (Cue.Ptr,Orig.In,New.In) swapable;   dcl Cue.Ptr     fixed;   dcl Orig.In     array;   dcl New.In      array;   dcl (D,S,T) (1) fixed;   dcl SMode       fixed;   dcl CueBits     fixed;   dcl Stemp   (4) fixed;   /* 1. convert old IN addr to MSEC */   /* 2. convert new IN addr to MSEC */   /* 3. compute MSEC we have changed IN addr by (signed result) */   /* 4. convert SYNC bits to MSEC */   /* 5. add/subtract MSEC to SYNC MSEC (limit to zero.time) */   /* 6. convert SYNC MSEC back to SMPTE BITS */   /* 7. save back in DES.PTR cue */   call DTD.Sample.#.To.Msecs(Orig.In, cf#time, SAMP.SPEED, Aee.Current.Project.Rate, zero.zero, T);   call DTD.Sample.#.To.Msecs(New.In,  cf#time, SAMP.SPEED, Aee.Current.Project.Rate, zero.zero, D);   call Sub32(D,T,D);                               /* msec Cue IN has changed by */   call Read.Cue.Time(Cue.Ptr,Cue.SMPT.Msb,S);   smode   = Cue.Lookup(Cue.Ptr,Cue.SMPT.Mode);     /* get mode code for smpt bits   */   cuebits = Cue.Lookup(Cue.Ptr,Cue.Bits);          /* get cue bits for abs/rel      */   if (cuebits & bit3) = 0   then call SBits.To.Msec(S,cf#time,SAMP.SPEED,smode,T);   else do;      call SBITS.TO.SMPTE(S, smode, stemp);      call SMPTE.TO.MSEC(stemp, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), T);      if T(0) < 0           /* but might be before start of sequence */      then call STR32(0, zero.time, T);   end;   call Add32(T,D,T);                               /* new adjusted SYNC time */   if (T(0)=0) & (T(1) ilt zero.time) then T(1)=zero.time; /* limit to zero.time */   call MSEC.TO.SMPTE(T, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), stemp);   call SMPTE.TO.SBITS (stemp, SM.MODE, S);   call Write.Cue.Time(Cue.Ptr,Cue.SMPT.Msb,S);     /* save back into dest cue */   call CUE.STORE (Cue.Ptr,Cue.Bits,cuebits \ bit3);end ADJUST.SMPTE.SYNC;EXTRACT.FROM.REEL.WITH.EXTEND: proc (Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr                fixed; /* external memory sector ptr to cue to delete from */   dcl Des.Ptr                fixed; /* xmem ptr to destination cue */   dcl Protect.Des.Name       fixed; /* set true to preserve name of Dest Cue Record */   dcl Protect.Work.Name      fixed;   dcl Work.Cue.Ptr           fixed;   dcl Edit.In            (1) fixed; /* logical address to begin extract from */   dcl Edit.Out           (1) fixed; /* logical address to end   extract at */   dcl (Sync.In,Sync.Out) (1) fixed; /* hold segment in and out sync addrs */   dcl (Num.Sou.Segs,S#)      fixed;   dcl Seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   dcl Edit.Case              fixed;   dcl (T,Orig.In)        (1) fixed; /* original cue IN addr */   BACKUP.SEGMENT.START: proc (Sync.In,Disk.In); /* moves SYNC IN & DISK IN back until one hits (0,0) */      dcl Sync.In array;      dcl Disk.In array;      if Com32(Sync.In,Disk.In)=lw#ilt then do; /* SYNC IN < DISK IN */         /* move SYNC IN back to (0,0) */         /* move DISK IN back to (DISK IN - SYNC IN) */         call Sub32(Disk.In,Sync.In,Disk.In); /* (DISK IN - SYNC IN) */         Sync.In(0)=0; Sync.In(1)=0;      end;      else do; /* SYNC IN >= DISK IN */         /* move DISK IN back to (0,0) */         /* move SYNC IN back to (SYNC IN - DISK IN) */         call Sub32(Sync.In,Disk.In,Sync.In); /* (SYNC IN - DISK IN) */         Disk.In(0)=0; Disk.In(1)=0;      end;   end BACKUP.SEGMENT.START;   /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.S.Msb       ,Orig.In);  /* save original cue IN addr */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out)=lw#igt   /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out)=lw#ieq   /* EDIT IN point equals EDIT OUT point */   then do;      E$Status=E#NoRegionSelected;      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   if Cue.Lookup(Sou.Ptr,Cue.List.Ptr)=0 then do; /* cue is in "simple" format */      call Initialize.Reel(Sou.Ptr);          /* convert to reel cue format */   end;   if Sou.Ptr=Des.Ptr then do;         /* doing an in-place extract */      Work.Cue.Ptr=Scratch.Cue.Ptr1;    /* use default scratch cue   */      Protect.Work.Name=false;         /* use source cue name       */   end;   else do;      Work.Cue.Ptr=Des.Ptr;               /* use passed cue         */      Protect.Work.Name=Protect.Des.Name; /* keep des cue name      */   end;   call Copy.Cue.Header(Sou.Ptr,Work.Cue.Ptr,Protect.Work.Name); /* copy source header onto work cue */   call Erase.Reel.Edit.List(Work.Cue.Ptr); /* dump EDL from Scratch Cue */   load Cue.Lookup(Sou.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Sou.Segs=res;                          /* number of edit segments in cue */   do S#=0 to Num.Sou.Segs-1;                 /* loop over all segments */      call Get.Edit.Segment(Sou.Ptr,S#,Seg);  /* read in segment from source */      call Copy32(loc(addr(Seg(S#Sync.Msb))),Sync.In ); /* extract SYNC IN  addr from edit segment */      call Get.Segment.Sync.End.Time    (Seg,Sync.Out); /* compute SYNC OUT addr for this edit segment */      Edit.Case=Map.Times.To.Edit.Case(Sync.In,Sync.Out,Edit.In,Edit.Out);      do case (Edit.Case-1);         do; /* CASE #1 */            /* edit segment outside of extract region - toss it */         end;         /* $PAGE */         do; /* CASE #2 */            /* move edit segment SYNC IN and DISK IN */            /* back until one of them hits (0,0)     */            call Backup.Segment.Start(loc(addr(Seg(S#Sync.Msb))),                                      loc(addr(Seg(S#In.Msb  ))));            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #3 */            if Com32(Edit.In,Sync.In)=lw#ieq then do;               /* move edit segment SYNC IN and DISK IN */               /* back until one of them hits (0,0)     */               call Backup.Segment.Start(loc(addr(Seg(S#Sync.Msb))),                                         loc(addr(Seg(S#In.Msb  ))));            end;            if Com32(Edit.Out,Sync.Out)=lw#ieq then do;               /* move DISK OUT to end of disk (-1,-1) */               Seg(S#Out.Msb)=(-1); Seg(S#Out.Lsb)=(-1); /* extend to end of disk */            end;            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #4 */            /* move DISK OUT to end of disk (-1,-1) */            Seg(S#Out.Msb)=(-1); Seg(S#Out.Lsb)=(-1); /* extend to end of disk */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;         do; /* CASE #5 */            /* edit segment outside of extract region - toss it */         end;         do; /* CASE #6 */            /* move edit segment SYNC IN and DISK IN */            /* back until one of them hits (0,0)     */            call Backup.Segment.Start(loc(addr(Seg(S#Sync.Msb))),                                      loc(addr(Seg(S#In.Msb  ))));            /* move DISK OUT to end of disk (-1,-1) */            Seg(S#Out.Msb)=(-1); Seg(S#Out.Lsb)=(-1); /* extend to end of disk */            if Append.Edit.Segment(Work.Cue.Ptr,Seg)<>E#Good then GOTO NO.ROOM;         end;      end;                                    /* of do delete on this segment */   end;                                       /* of loop over segments */   if Cue.Lookup(Work.Cue.Ptr,Cue.List.Len)=0    then do;                                   /* extract resulted in empty EDL on dest */      call Initialize.Reel(Work.Cue.Ptr);     /* set up default EDL */   end;   call Garbage.Collect.Reel(Work.Cue.Ptr);   /* eliminate unecessary edit segments */   call Write.Cue.Time(Work.Cue.Ptr,Cue.S.Msb,Edit.In ); /* Cue IN and OUT points get */   call Write.Cue.Time(Work.Cue.Ptr,Cue.E.Msb,Edit.Out); /* set to EDIT points */   if Sou.Ptr=Des.Ptr                                 /* did an in-place extract */   then call Copy.Cue(Scratch.Cue.Ptr1,Des.Ptr,false); /* copy info back from scratch buffer to our cue */   /* now correct SYNC time by amount we */   /* have changed our cue IN addr by    */   call Adjust.SMPTE.Sync(Des.Ptr,Orig.In,Edit.In);   return E$Status;                      /* edit was successful */   /* ERROR HANDLERS BELOW: */   NO.ROOM: E$Status=E#TooLong; return E$Status; /* ran out of room in edit list */end EXTRACT.FROM.REEL.WITH.EXTEND;/* $SUBTITLE Routine to Extract Part of a Reel w/o Extending Segment Endpoints */EXTRACT.FROM.REEL.WITHOUT.EXTEND: proc (Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr                fixed; /* xmem ptr to cue to extract from */   dcl Des.Ptr                fixed; /* xmem ptr to destination cue */   dcl Protect.Des.Name       fixed; /* set true to preserve name of Dest Cue Record */   dcl Edit.In            (1) fixed; /* logical address to begin extract at */   dcl Edit.Out           (1) fixed; /* logical address to end   extract at */   dcl (Sync.In,Sync.Out) (1) fixed; /* hold segment in and out sync addrs */   dcl (T)                (1) fixed; /* time buffer */   dcl (Num.Des.Segs,S#)      fixed;   dcl Seg (Cue.Seg.Stride-1) fixed; /* edit segment buffer */   dcl Edit.Case              fixed;   /* NOTE: Routine can do an in-place extract (i.e., SOU.PTR = DES.PTR) */   /*       This routine does not require any scratch buffers.           */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out)=lw#igt   /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out)=lw#ieq   /* EDIT IN point equals EDIT OUT point */   then do;      E$Status=E#NoRegionSelected;      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   if Cue.Lookup(Sou.Ptr,Cue.List.Ptr)=0 then do; /* cue is in "simple" format */      call Initialize.Reel(Sou.Ptr);          /* convert to reel cue format */   end;   if Sou.Ptr<>Des.Ptr then do;               /* not doing an in-place extract */      if Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name)<>E#Good      then GOTO NO.ROOM;   end;   load Cue.Lookup(Des.Ptr,Cue.List.Len);   div Cue.Seg.Stride;   Num.Des.Segs=res;                          /* number of edit segments in cue */   do S#=0 to shr(Num.Des.Segs,4);            /* initialize bits of MISC.BUF */      Misc.Buf(S#)=0;   end;   do S#=0 to Num.Des.Segs-1;                 /* loop over all segments */      call Get.Edit.Segment(Des.Ptr,S#,Seg);  /* read in segment from source */      call Copy32(loc(addr(Seg(S#Sync.Msb))),Sync.In ); /* extract SYNC IN  addr from edit segment */      call Get.Segment.Sync.End.Time    (Seg,Sync.Out); /* compute SYNC OUT addr for this edit segment */      Edit.Case=Map.Times.To.Edit.Case(Sync.In,Sync.Out,Edit.In,Edit.Out);      do case (Edit.Case-1);         do; /* CASE #1 */            /* edit segment is outside of extract region - toss it */            Misc.Buf(shr(S#,4))=Misc.Buf(shr(S#,4))|Bits(S#&15); /* set bit to erase SEG */         end;         do; /* CASE #2 */            /* move edit segment SYNC IN out to EDIT IN point */            /* move edit segment DISK IN out to EDIT IN point */            call Copy32(Edit.In,loc(addr(Seg(S#Sync.Msb)))); /* set SYNC IN to EDIT IN point */            call Sub32 (Edit.In,Sync.In,T);                  /* distance from original SYNC IN to EDIT IN */            call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#In.Msb)))); /* move DISK IN addr to EDIT IN point */            call Put.Edit.Segment(Des.Ptr,S#,Seg);         end;         /* $PAGE */         do; /* CASE #3 */            /* keep edit segment unchanged */         end;         do; /* CASE #4 */            /* set edit segment DISK OUT address to EDIT OUT point */            call Sub32 (Edit.Out,Sync.In,T);                 /* distance from SYNC IN to EDIT OUT */            call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#Out.Msb)))); /* move DISK OUT addr back to EDIT OUT point */            call Put.Edit.Segment(Des.Ptr,S#,Seg);         end;         do; /* CASE #5 */            /* edit segment outside of extract region - toss it */            Misc.Buf(shr(S#,4))=Misc.Buf(shr(S#,4))|Bits(S#&15); /* set bit to erase SEG */         end;         do; /* CASE #6 */            /* move edit segment SYNC IN out to EDIT IN point */            /* move edit segment DISK IN out to EDIT IN point */            call Copy32(Edit.In,loc(addr(Seg(S#Sync.Msb)))); /* set SYNC IN to EDIT IN */            call Sub32 (Edit.In,Sync.In,T);                  /* distance from SYNC IN to EDIT IN */            call Add32 (loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#In.Msb)))); /* move DISK IN addr to EDIT IN point */            /* backup edit segment DISK OUT address to EDIT OUT point */            call Sub32(Edit.Out,Edit.In,T);   /* length of data extracted */            call Add32(loc(addr(Seg(S#In.Msb))),T,loc(addr(Seg(S#Out.Msb)))); /* bring DISK OUT addr back to EDIT OUT point */            call Put.Edit.Segment(Des.Ptr,S#,Seg);         end;      end;                                    /* of do delete on this segment */   end;                                       /* of loop over segments */   call Squeeze.Unused.Segments(Des.Ptr,Misc.Buf); /* compress deleted segments from cue record */   if Cue.Lookup(Des.Ptr,Cue.List.Len)=0    then do;                                   /* extract resulted in empty EDL on dest */      call Initialize.Reel(Des.Ptr);          /* set up default EDL */   end;   else call Garbage.Collect.Reel(Des.Ptr);   /* eliminate unecessary edit segments */   call Write.Cue.Time(Des.Ptr,Cue.S.Msb,Edit.In ); /* Cue IN and OUT points get */   call Write.Cue.Time(Des.Ptr,Cue.E.Msb,Edit.Out); /* set to EDIT points */   return E$Status;                      /* edit was successful */   /* ERROR HANDLERS BELOW: */   NO.ROOM: E$Status=E#TooLong; return E$Status; /* ran out of room in edit list */end EXTRACT.FROM.REEL.WITHOUT.EXTEND;/* $SUBTITLE  Routine to Erase Part of a Reel (Overwrites Reel with Silence) */FILL.REEL.WITH.LEADER: proc (Sou.Ptr,Des.Ptr,Protect.Des.Name) fixed public swapable;   dcl Sou.Ptr          fixed; /* external memory sector ptr to cue to delete from */   dcl Des.Ptr          fixed; /* xmem ptr to destination cue */   dcl Protect.Des.Name fixed; /* set true to preserve name of Dest Cue Record */   dcl Work.Cue.Ptr     fixed;   dcl Edit.In      (1) fixed;   dcl Edit.Out     (1) fixed;      /* NOTE: if (SOU.PTR = DES.PTR), then routine assumes */   /*       SCRATCH.CUE.PTR1 points to a cue record block */   E$Status=E#Good;         /* assume edit operation will succeed */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* look up region to */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* be edited from passed cue record */   if Com32(Edit.In,Edit.Out) = lw#igt /* EDIT IN point beyond EDIT OUT point */   then do;      E$Status=E#SysErr;               /* don't do edit if out of order */      return E$Status;   end;   if Com32(Edit.In,Edit.Out) = lw#ieq /* EDIT IN point equal to EDIT OUT point */   then do;      E$Status=Copy.Cue(Sou.Ptr,Des.Ptr,Protect.Des.Name);      return E$Status;   end;   call ROUND.EDIT.TIMES(Sou.Ptr);     /* round to sector bounds          */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.In.Msb ,Edit.In);  /* may differ   */   call Read.Cue.Time(Sou.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* now          */   if Delete.From.Reel(Sou.Ptr,Des.Ptr,Protect.Des.Name)<>E#Good   then return E$Status;   call Write.Cue.Time(Des.Ptr,Cue.Edit.Out.Msb,Edit.Out); /* DELETE has changed EDIT OUT saved in cue */   return Insert.Leader.On.Reel(Des.Ptr,Des.Ptr,false);end FILL.REEL.WITH.LEADER;