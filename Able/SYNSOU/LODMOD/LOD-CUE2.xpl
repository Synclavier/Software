/*	:SYNSOU:LODMOD:LOD-CUE2 - routines for changing time fields in current cueModified:2001/02/19 - TY  - Made modifications needed for 24 hour wrap.*//*	first - routines to perform "EXCHANGE" function (store prior	*//*	value for "undo")																*/Push.DTD.Cue.Time:proc(gidloc,arr) public swapable;	dcl gidloc	fixed;	dcl arr		array;	call PID(gidloc,	arr(0));	call PID(gidloc+1,arr(1));end Push.DTD.Cue.Time;Pop.DTD.Cue.Time:proc(gidloc,arr) public swapable;	dcl gidloc	fixed;	dcl arr		array;	arr(0) = GID(gidloc	);	arr(1) = GID(gidloc+1);end Pop.DTD.Cue.Time;/*	handle a new cue in time from any source	*//*	This routine is passed a time and a code word.  The code		*//*	word tells what format the time is in:								*//*		0 = This is a 32-bit millisecond time that has the			*//*			 Cue.Time.Display.Offset in it (basic AEE in time).	*//*		1 = This is a 32-bit millisecond time that has been		*//*			 mapped to a sequencer time, as for the AEE audition	*//*			 mode time display.												*//*		2 = This is a 32-bit millisecond time with no offset		*//*			 added in.  This becomes the new time directoy.			*//*			 Error checking is performed - ie if the new in time	*//*			 is greater than the old out time, the new out time	*//*			 is set (for example to the end of the project.)		*//*		3 = This is a 32-bit millisecond time with no offset		*//*			 entered from a drag of the cue in time.  Exchange		*//*			 the in and out times if they cross.						*//*		4 = This is a 32-bit millisecond time from a slide of		*//*			 a cue region.  Skip other error checking.				*//*	Routine returns:															*//*		0 = assignment OK														*//*		1 = user tried to move the IN time before 0.000				*//*		2 = the new sync time would be before 0.000					*/ASSIGN.NEW.DTD.CUE.IN: proc (newintime,code,push) public swapable;	dcl newintime	array;	/*	pass new in time, normally from terminal	*/	dcl code			fixed;	dcl push			fixed;	/*	1 = push old value on exchange stack		*/	dcl new (1)		fixed;	dcl temp(1)		fixed;	dcl status		fixed;	status = 0;	/*	copy new in time to	*/	/*	handy temp:				*/	call COPY32(newintime,new);	/*	Remove Cue.Time.Display.Offset if needed:	*/	if code = 0 then do;		call SUB32(new, Cue.Time.Display.Offset, new);		if new(0)<0 then call STR32(0, zero.time, new);		else if COM16(zero.time, new) = lw#igt		then call STR32(0, zero.time,new);	end;	/*	Remove Audition display offset if needed:	*/	else if code = 1 then do;		if (new(0) < 0) wrap_24_hours(new);		/*	map from sequencer time if in	*/		/*	audition mode						*/		if COM32(new,Cue.Trig.Time) = lw#ilt	/*	new in time is earlier	*/		then do;			call SUB32(Cue.Trig.Time,new,new);	/*	get amount earlier		*/			call ADD16(zero.time,new);				/*	for comparison				*/			if COM32(new,Cue.In.Time) = lw#igt			then do;				status = 1;				call STR32(0,zero.time,new);		/*	move disk addr to 0.000	*/			end;			else do;				call SUB16(zero.time,new);				call SUB32(Cue.In.Time,new,new);			end;		end;		else do;			call SUB32(new,Cue.Trig.Time,new);	/*	new in time is later		*/			call ADD32(new,Cue.In.Time,new);		end;	end;	/*	make sure out time is > in time	*/	/*	set out time to end of proj		*/	/*	when moving out to in				*/	/*	or exchange them if input is		*/	/*	from mouse								*/	if code <> 4 then do;		/*	if the new in time is > the old out time, compute a new out	*/		/*	time that should (might?) match the end of the project:		*/		if COM32(new,Cue.Out.Time) >= lw#ieq		then do;			if code < 3 then do;						/*	compute new out time if not from mouse	*/				Call DTD.Sample.#.To.Msecs(AEE.Current.Project.End, CF#Time, SAMP.SPEED,													AEE.Current.Project.Rate, zero.zero, Cue.Out.Time);				if COM32(new,Cue.Out.Time) >= lw#ieq	/*	double check	*/				then call COPY32(new,Cue.Out.Time);		/*	if speed = 0	*/			end;			else do;										/*	exchange in/out times if mouse	*/				call COPY32(new,temp);				/*	save new flag position				*/				call COPY32(Cue.Out.Time,new);	/*	new in time will be here			*/				call COPY32(temp,Cue.Out.Time);	/*	and move out up to here				*/			end;		end;	end;	/*	change sync time, offset time, edit in time, and	*/	/*	edit out time for change in start time					*/	if COM32(new,Cue.In.Time) = lw#ilt					/*	new in time earlier		*/	then do;		call SUB32(Cue.In.Time,new,temp);				/*	get amount earlier		*/		if  (Current.Sync.Locked	= 0)					/*	if sync not locked		*/		and (Current.Cue.Sync.Mode	= 0)					/*	and showing pre			*/		then do;													/*	then preserve sync		*/			call ADD16(zero.time,temp);					/*	by changing sync			*/			if COM32(temp,Cue.Sync.Time) = lw#igt		/*	time							*/			then do;				status = 2;										/*	NT#SyncTimeError			*/				call STR32(0,zero.time,Cue.Sync.Time);			end;			else do;												/*	preserve picture sync	*/				call SUB16(zero.time,temp);				/*	by changing time			*/				call SUB32(Cue.Sync.Time,temp,Cue.Sync.Time);			end;		end;		if code <> 4 then do;			if COM32(Cue.In.Time,Cue.Offs.Time) = lw#ieq		/*	if no offset,		*/			then do;														/*	keep equal			*/				call COPY32(new,Cue.Offs.Time);			end;			if COM32(Cue.In.Time,Cue.Edit.In.Time) = lw#ieq	/*	if edit times		*/			then do;														/*	keep equal			*/				call COPY32(new,Cue.Edit.In.Time);			end;		end;	end;	else do;														/*	new time is later			*/		call SUB32(new,Cue.In.Time,temp);				/*	get amount later			*/		if  (Current.Sync.Locked	= 0)					/*	if sync not locked		*/		and (Current.Cue.Sync.Mode	= 0)					/*	and showing pre			*/		then do;			call ADD32(Cue.Sync.Time,temp,Cue.Sync.Time);		end;		if code <> 4 then do;			if COM32(Cue.In.Time,Cue.Offs.Time) = lw#ieq		/*	keep offset time	*/			then do;														/*	equal if it was	*/				call COPY32(new,Cue.Offs.Time);			end;			else do;														/*	make sure it is	*/				if COM32(Cue.Offs.Time,new) = lw#ilt			/*	still in range		*/				then call COPY32(new,Cue.Offs.Time);			/*	if not equal		*/			end;			if COM32(Cue.In.Time,Cue.Edit.In.Time) = lw#ieq	/*	if edit times		*/			then do;														/*	keep equal			*/				call COPY32(new,Cue.Edit.In.Time);			end;			else do;				if COM32(Cue.Edit.In.Time,new) = lw#ilt				then call COPY32(new,Cue.Edit.In.Time);			end;		end;	end;	/*	Make sure edit out time stays in range	*/	if COM32(new,Cue.Edit.Out.Time) >= lw#ieq			/*	also keep edit out		*/	then do;														/*	time in range				*/		call COPY32(Cue.Out.Time,Cue.Edit.Out.Time);	end;	/*	set modified if new value is different	*/	if COM32(new,Cue.In.Time) <> lw#IEQ	then call Set.Cue.Modified;	/*	save prior value for exchange	*/	if push<>0 then call Push.DTD.Cue.Time(Saved.AEE.Cue.In.Time,Cue.In.Time);	/*	store checked value in	*/	/*	global variable:			*/	call COPY32(new,Cue.In.Time);	/*	re-write all values out to the cue in external memory and	*/	/*	create a system event informing everyone of the change:		*/	call UPDATE.CURRENT.CUE.RECORD;	return status;end ASSIGN.NEW.DTD.CUE.IN;/*	$page - Assign a new cue out time	*//*	This routine is passed a time and a code word.  The code		*//*	word tells what format the time is in:								*//*		0 = This is a 32-bit millisecond time that has the			*//*			 Cue.Time.Display.Offset in it (basic AEE in time).	*//*		1 = This is a 32-bit millisecond time that has been		*//*			 mapped to a sequencer time, as for the AEE audition	*//*			 mode time display.												*//*		2 = This is a 32-bit millisecond time with no offset		*//*			 added in.  This becomes the new time directoy.			*//*			 Error checking is performed - ie if the new in time	*//*			 is greater than the old out time, the new out time	*//*			 is set (for example to the end of the project.)		*//*		3 = This is a 32-bit millisecond time with no offset		*//*			 entered from a drag of the cue in time.  Exchange		*//*			 the in and out times if they cross.						*//*		4 = This is a 32-bit millisecond time from a slide of		*//*			 a cue region.  Skip other error checking.				*/ASSIGN.NEW.DTD.CUE.OUT: proc (newouttime,code,push,dur) public swapable;	dcl newouttime	array;	/*	pass new out time here				*/	dcl code			fixed;	/*	pass code described above			*/	dcl push			fixed;	/*	1 = push on exchange stack			*/	dcl dur			fixed;	/*	1 = newouttime is a new duration	*/	dcl new (1)		fixed;	dcl sout(1)		fixed;	dcl status		fixed;	dcl i				fixed;	status = 0;	/*	copy new out time to	*/	/*	handy temp:				*/	call COPY32(newouttime,new);	/*	map to new actual end time if		*/	/*	showing duration						*/	if dur					/*	if showing duration, then	*/	then do;					/*	compute actual end time		*/		call ADD32(new,Cue.In.Time,new);	end;	/*	Remove the Cue.Time.Display.Offset if needed:	*/	else if code = 0 then do;		call SUB32(new, Cue.Time.Display.Offset, new);		if new(0)<0 then call STR32(0, zero.time, new);		else if COM16(zero.time, new) = lw#igt		then call STR32(0, zero.time,new);	end;	/*	Remove the Audition display offset if needed:	*/	else if code = 1 then do;		if (new(0) < 0) wrap_24_hours(new);		call SUB32(Cue.Out.Time,Cue.In.Time,sout);	/*	get cue length				*/		call ADD32(Cue.Trig.Time,sout,sout);			/*	compute sync out time	*/		if COM32(new,sout) = lw#ilt						/*	new out time is earlier	*/		then do;			call SUB32(sout,new,new);						/*	get amount earlier		*/			call ADD16(zero.time,new);						/*	for comparison				*/			if COM32(new,Cue.Out.Time) = lw#igt			then do;				status = 1;										/*	NT$InTimeError				*/				call STR32(0,zero.time,new);			end;			else do;				call SUB16(zero.time,new);				call SUB32(Cue.Out.Time,new,new);			end;		end;		else do;			call SUB32(new,sout,new);						/*	new out time is later	*/			call ADD32(new,Cue.Out.Time,new);		end;	end;	/*	if new out time is < in time, then	*/	/*	set both in and out times, as well	*/	/*	as all edit times							*/	/*	or exchange if from mouse				*/	if COM32(new,Cue.In.Time) = lw#ilt	then do;		if push<>0 then call Push.DTD.Cue.Time(Saved.AEE.Cue.Out.Time,Cue.Out.Time);		if Code < 3 then do;			call COPY32(new,Cue.Out.Time);			call COPY32(new,Cue.Edit.Out.Time);			/*	equal since new	*/		end;		else do;													/*	exchange				*/			call COPY32(Cue.In.Time,Cue.Out.Time);			call COPY32(Cue.In.time,Cue.Edit.Out.Time);		end;		call COPY32(new,Cue.Offs.Time);					/*	out is < old in	*/		call COPY32(new,Cue.Edit.In.Time);				/*	all these will be	*/		i = Assign.New.DTD.Cue.In(new, true, push);		if status = 0 then status = i;					/*	save first error message	*/	end;	else do;	/*	process new end time that is >= in time	*/		/*	keep edit times in range	*/		if COM32(new,Cue.Edit.In.Time) = lw#ilt		/*	limit edit in to	*/		then call COPY32(new,Cue.Edit.In.Time);		/*	end of cue			*/		if COM32(new,Cue.Offs.Time) = lw#ilt			/*	limit offset to	*/		then call COPY32(new,Cue.Offs.Time);			/*	end of cue			*/		if COM32(Cue.Out.Time,Cue.Edit.Out.Time) = lw#ieq	/*	keep times equal		*/		then call COPY32(new,Cue.Edit.Out.Time);		/*	if they were		*/		if COM32(new,Cue.Edit.Out.Time) = lw#ilt		/*	alwo in bounds		*/		then call COPY32(new,Cue.Edit.Out.Time);		/*	set modified if new value is different	*/		if COM32(new,Cue.Out.Time) <> lw#IEQ		then call Set.Cue.Modified;		/*	saved prior version for exchange			*/		if push<>0 then call Push.DTD.Cue.Time(Saved.AEE.Cue.Out.Time,Cue.Out.Time);		/*	store checked value in	*/		/*	global variable:			*/		call COPY32(new,Cue.Out.Time);		call UPDATE.CURRENT.CUE.RECORD;	end;	return status;end ASSIGN.NEW.DTD.CUE.OUT;/*	$page - assign a new edit in time to the current cue			*//*	This routine is passed a time and a code word.  The code		*//*	word tells what format the time is in:								*//*		0 = This is a 32-bit millisecond time that has the			*//*			 Cue.Time.Display.Offset in it (basic AEE in time).	*//*		1 = This is a 32-bit millisecond time that has been		*//*			 mapped to a sequencer time, as for the AEE audition	*//*			 mode time display.												*//*		2 = This is a 32-bit millisecond time with no offset		*//*			 added in.  This becomes the new time directoy.			*//*			 Error checking is performed - ie if the new in time	*//*			 is greater than the old out time, the new out time	*//*			 is set (for example to the end of the project.)		*//*		3 = This is a 32-bit millisecond time with no offset		*//*			 entered from a drag of the cue in time.  Exchange		*//*			 the in and out times if they cross.						*//*		4 = This is a 32-bit millisecond time from a slide of		*//*			 a cue region.  Skip other error checking.				*/ASSIGN.NEW.DTD.EDIT.IN: proc (newtime, code, push) public swapable;	dcl newtime		array;	/*	pass new offs time here				*/	dcl code			fixed;	/*	code word described above			*/	dcl push			fixed;	/*	1 = push prior value on stack		*/	dcl new	(1)	fixed;	dcl temp	(1)	fixed;	dcl status		fixed;	status = 0;	call COPY32(newtime,new);	/*	Remove cue.time.display.offset if needed:	*/	if code = 0 then do;		call SUB32(new, Cue.Time.Display.Offset, new);		if new(0)<0 then call STR32(0, zero.time, new);		else if COM16(zero.time, new) = lw#igt		then call STR32(0, zero.time,new);	end;	/*	Adjust a sequencer time if needed:			*/	else if code = 1 then do;		if (new(0) < 0) wrap_24_hours(new);		if COM32(new,Cue.Trig.Time) = lw#ilt		/*	if offset abs time < in time	*/		then do;			status = 1;										/*	NT#EditTimeError			*/			call STR32(0,zero.time,new);		end;		else do;			call SUB32(new,Cue.Trig.Time,new);			call ADD32(new,Cue.In.Time,new);		end;	end;	/*	make sure new edit in time is within	*/	/*	the cue in/out times							*/	if (COM32(new,Cue.In.Time) = lw#ilt)			/*	if offset abs time < in time	*/	then do;		if Pending.Edit=10								/*	if sliding edit region	*/		then status = 2;									/*	NT#BadSlideIn				*/		else status = 3;									/*	NT#EditTimeError			*/		call COPY32(Cue.In.Time,new);	end;	else if (COM32(new,Cue.Out.Time) = lw#igt)	/*	if abs time > out time	*/	then do;		status = 4;		call COPY32(Cue.Out.Time,new);	end;	/*	keep edit out time in range	*/	/*	If from terminal and user types an edit in time that is >	*/	/*	than the out time, move the out time up to the cue out		*/	if (COM32(new,Cue.Edit.Out.Time) = lw#igt)	then do;		if Code < 3 then do;			call COPY32(Cue.Out.Time,Cue.Edit.Out.Time);		end;		else do;			call COPY32(new,temp);						/*	save new value				*/			call COPY32(Cue.Edit.Out.Time,new);		/*	get cue out					*/			call COPY32(temp,Cue.Edit.Out.Time);	/*	new goes to edit out		*/		end;	end;	/*	Lock the edit region length during a SLIDE edit by updating	*/	/*	the edit.out time whenever the edit.in time is jogged,		*/	/*	and vice versa																*/	if (Pending.Edit=10) and (code < 2) then do;	/*	in SLIDE edit, user changed time field	*/		if COM32(new,Cue.Edit.In.Time) = lw#igt then do;			call SUB32(new,Cue.Edit.In.Time,temp);			call ADD32(Cue.Edit.Out.Time,temp,temp);		end;		else do;			call SUB32(Cue.Edit.In.Time,new,temp);			call SUB32(Cue.Edit.Out.Time,temp,temp);		end;		if (COM32(temp,Cue.Out.Time) = lw#igt)		then do;			status = 5;										/*	NT#BadSlideOut	*/			call COPY32(Cue.Out.Time,temp);		end;		call COPY32(temp,Cue.Edit.Out.Time);	end;	/*	save prior value for exchange	*/	if push<>0 then call Push.DTD.Cue.Time(Saved.AEE.Edit.In.Time,Cue.Edit.In.Time);	/*	store checked value in	*/	/*	global variable:		*/	call COPY32(new,Cue.Edit.In.Time);	/****** for now, keep edit in time and offset ******/	/****** time the same								 ******/	call COPY32(new,Cue.Offs.Time);	/***************************************************/	call UPDATE.CURRENT.CUE.RECORD;	return status;end ASSIGN.NEW.DTD.EDIT.IN;/*	This routine is passed a time and a code word.  The code		*//*	word tells what format the time is in:								*//*		0 = This is a 32-bit millisecond time that has the			*//*			 Cue.Time.Display.Offset in it (basic AEE in time).	*//*		1 = This is a 32-bit millisecond time that has been		*//*			 mapped to a sequencer time, as for the AEE audition	*//*			 mode time display.												*//*		2 = This is a 32-bit millisecond time with no offset		*//*			 added in.  This becomes the new time directoy.			*//*			 Error checking is performed - ie if the new in time	*//*			 is greater than the old out time, the new out time	*//*			 is set (for example to the end of the project.)		*//*		3 = This is a 32-bit millisecond time with no offset		*//*			 entered from a drag of the cue in time.  Exchange		*//*			 the in and out times if they cross.						*//*		4 = This is a 32-bit millisecond time from a slide of		*//*			 a cue region.  Skip other error checking.				*/ASSIGN.NEW.DTD.EDIT.OUT: proc (newtime,code,push,dur) public swapable;	dcl newtime		array;	/*	pass new edit out time here				*/	dcl code			fixed;	/*	code word described above					*/	dcl push			fixed;	/*	1 = push prior value on stack				*/	dcl dur			fixed;	/*	true if newtime is actually a duration	*/	dcl new	(1)	fixed;	dcl temp	(1)	fixed;	dcl status		fixed;	status = 0;	call COPY32(newtime,new);	/*	Map a duration to an end time if we are passed a duration:		*/	if dur						/*	if showing duration,			*/	then do;						/*	then remap if needed			*/		call ADD32(new,Cue.Edit.In.Time,new);	end;	/*	Remove the Cue.Time.Display.Offset if needed:				*/	else if code = 0 then do;		call SUB32(new, Cue.Time.Display.Offset, new);		if new(0)<0 then call STR32(0, zero.time, new);		else if COM16(zero.time, new) = lw#igt		then call STR32(0, zero.time,new);	end;	/*	Adjust a sequence time back to a cue in time if needed:	*/	else if code = 1 then do;		if (new(0) < 0) wrap_24_hours(new);		if COM32(new,Cue.Trig.Time) = lw#ilt		/*	if abs time < in time				*/		then do;			status = 1;			/*	NT#EditTimeError				*/			call STR32(0,zero.time,new);		end;		else do;			call SUB32(new,Cue.Trig.Time,new);			call ADD32(new,Cue.In.Time,new);		end;	end;	/*	make sure new out time is between cue in and out	*/	/*	times																*/	if (COM32(new,Cue.In.Time)	= lw#ilt)			/*	if edit out abs time < in time	*/	then do;		status = 2;				/*	NT#EditTimeError				*/		call COPY32(Cue.In.Time,new);	end;	else if (COM32(new,Cue.Out.Time)	= lw#igt)	/*	if out abs time > out time			*/	then do;		if Pending.Edit=10	/*	if sliding edit region		*/		then status = 3;		/*	NT#BadSlideOut					*/		else status = 4;		/*	NT#EditTimeError				*/		call COPY32(Cue.Out.Time,new);	end;	/*	keep edit in time in range	*/	/*	If from terminal and user types an edit out time that is <	*/	/*	than the in time, move the in time down to cue in				*/	/*	Exchange them if input came from mouse								*/	if (COM32(new,Cue.Edit.In.Time)	= lw#ilt)	then do;		if Code < 3 then do;			call COPY32(Cue.In.Time,Cue.Edit.In.Time);		end;		else do;			call COPY32(new,temp);					/*	save new value			*/			call COPY32(Cue.Edit.In.Time,new);	/*	get cue in				*/			call COPY32(temp,Cue.Edit.In.Time);	/*	new goes to edit in	*/		end;		/****** for now, keep edit in time and offset ******/		/****** time the same								 ******/		call COPY32(new,Cue.Offs.Time);		/***************************************************/	end;	/*	Lock the edit region length during a SLIDE edit by updating	*/	/*	the edit.in time whenever the edit.out time is changed		*/	if (Pending.Edit=10) and (code < 2) then do;		if COM32(new,Cue.Edit.Out.Time) = lw#igt then do;			call SUB32(new,Cue.Edit.Out.Time,temp);			call ADD32(Cue.Edit.In.Time,temp,temp);		end;		else do;			call SUB32(Cue.Edit.Out.Time,new,temp);			call SUB32(Cue.Edit.In.Time,temp,temp);		end;		if (COM32(temp,Cue.In.Time) = lw#ilt)		then do;			status = 5;			/*	NT#BadSlideIn	*/			call COPY32(Cue.In.Time,temp);		end;		call COPY32(temp,Cue.Edit.In.Time);	end;	/*	save prior value for exchange	*/	if push<>0 then call Push.DTD.Cue.Time(Saved.AEE.Edit.Out.Time,Cue.Edit.Out.Time);	/*	store checked value in	*/	/*	global variable:			*/	call COPY32(new,Cue.Edit.Out.Time);	call UPDATE.CURRENT.CUE.RECORD;	return status;end ASSIGN.NEW.DTD.EDIT.OUT;ASSIGN.NEW.DTD.SYNC.MODE: proc(setting) public swapable;	dcl setting	fixed;	if (setting igt 2) return;	/*	bozo award of the day	*/	Current.Cue.Sync.Mode = setting;	call UPDATE.CURRENT.CUE.RECORD;end ASSIGN.NEW.DTD.SYNC.MODE;/*	$page - routine to generate numerical cue names	*/GENERATE.NUMERICAL.CUE.NAME: proc (prefix,cuename) returns (fixed) public swapable;	dcl prefix				array;	/*	Prefix of numbered cue (i.e. 'TAKE')			*/	dcl cuename				array;	/*	Return array: Must be at least array(17-1)	*/	dcl tmp		(17-1)	fixed;	dcl prevname(17-1)	fixed;	dcl tmp1		(17-1)	fixed;	dcl (i,j)				fixed;	dcl origsuf				fixed;	dcl newsuf				fixed;	dcl tens					data	(0,0,99,999,9999);	dcl addspace			lit '1';	dcl #ofdigits			fixed;	insert ':synlits:asciilit';	/*	get ascii literals			*/	/*	remove (in-place) trailing spaces	*/	/*	from string									*/	remove.trailing.spaces:proc(str);		dcl str	array;		do while (str(0)<>0)		and byte(str,str(0)-1)=sp;			str(0)=str(0)-1;			call pbyte(str,str(0),0);		end;	end remove.trailing.spaces;	remove.suffix:proc(str,digs);	/*	trash suffix, if any			*/		dcl str			array;		/*	returns suffix value			*/		dcl digs			array;		dcl i				fixed;		dcl j				fixed;		dcl suf (17-1)	fixed;		i=str(0);		do while (i<>0)		and (byte(str,i-1)>=a.0)		and (byte(str,i-1)<=a.9)		and ((str(0)-i)	< 4  );			i=i-1;		end;		if i <> str(0) then do;		/*	numerical suffix exists		*/			suf(0) = str(0)-i;			do j=0 to suf(0)-1;				call pbyte(suf,j,byte(str,i+j));				call pbyte(str,i+j,0);			end;		end;		digs(0) = str(0)-i;			/*	# of suffix digits			*/		str (0) = i;					/*	new prefix string				*/		if (addspace)					/*	also space						*/		then call remove.trailing.spaces(str);		if suf(0)<>0 then	return CONV.STR.TO.FIXED(suf,0,0);		else					return 0;	end remove.suffix;	/*	1. Find largest cue with same prefix	*/	/*	2. Add 1 to the numerical part of it	*/	/*	3. Return new name in cuename				*/	if LOD.Running <> 0 then do;		call COPY.STRING(Prefix,tmp);		/*	get temp copy			*/		retry:;		/*	toss original suffix; get its value and # of digits	*/		origsuf = remove.suffix(tmp,loc(addr(#ofdigits)));		if #ofdigits <2 then #ofdigits = 2;		if tmp(0) igt CUE.NAME.L-#ofdigits-addspace	/*	limit to max len	*/		then tmp(0) = CUE.NAME.L-#ofdigits-addspace;		/*	look for "prefix 99" on disk	*/		if (addspace)							/*	add space				*/		and (tmp(0) <> 0)		then call APPENDC(tmp,sp);		do i=1 to #ofdigits;					/*	add digits				*/			call APPENDC(tmp,a.9);		end;		call SET.DTD.SCROLL.RANGE (0);	/*	look on entire disk	*/		if Locate.DTD.Cue(tmp) <> 0 then do;	/*	Exact match with <prefix>99; no more allowed	*/			if tmp(0) ilt CUE.NAME.L-#ofdigits-addspace			then do;								/*	try again 99 00		*/				call APPENDC(tmp,sp);		/*	keep from finding suffix	*/				goto retry;			end;			return false;		end;		/*	"prefix 99" does not exist:	*/		call Fetch.Previous.Alpha.DTD.Cue;		call remove.suffix(tmp,loc(addr(j)));	/*	clean up tmp always	*/		if DTD.Cue# = 0 then do;	/*	No previous cues at all; <prefix>0001 is name to use	*/			newsuf = 1;					/*	use 0001	*/		end;		else do;			/*	see if prefix matches	*/			write(mam) = SCSI.Ptr;			write(mal) = CUE.NAME;			call Copy.In(addr(prevname(0)),17);			i	= remove.suffix				(prevname,loc(addr(j)));			call REMOVE.SPACES.FROM.STRING(prevname,prevname);			call UPPERCASE.STRING			(prevname,prevname);			call COPY.STRING(tmp,tmp1);			call REMOVE.SPACES.FROM.STRING(tmp1,tmp1);			call UPPERCASE.STRING			(tmp1,tmp1);			if EQSTR(prevname,tmp1)=0		/*	matches		*/			then do;				newsuf = i + 1;			end;			else do;								/*	no match		*/				newsuf = 1;			end;		end;		if newsuf ile origsuf		then newsuf = origsuf + 1;		if newsuf igt tens(#ofdigits)		then #ofdigits = #ofdigits + 1;		call COPY.STRING(tmp,cuename);		call CONV.FIXED.TO.STR(newsuf,0,#ofdigits,cf#right\cf#zerofill,prevname);		call COPY.STRING(tmp,cuename);		if  (addspace)							/*	add space	*/		and (cuename(0) <> 0)		then call APPENDC(cuename,sp);		call APPEND.TO.STR(cuename,prevname);		return true;	end;	return false;end GENERATE.NUMERICAL.CUE.NAME;INCREMENT.DTD.CURRENT.CUE.NAME: proc public swapable;	dcl cname(17-1)	fixed;	write(mam) = Current.Cue.Ptr;	write(mal) = CUE.NAME;	call COPY.IN(addr(cname(0)),17);	if cname(0)=0 then do;									/*	null string		*/		call copy.string('Take',cname);	end;	call Generate.Numerical.Cue.Name(cname,cname);	/*	Get next name	*/	call ASSIGN.NEW.DTD.CUE.NAME(cname);end INCREMENT.DTD.CURRENT.CUE.NAME;