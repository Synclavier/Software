/*	:SYNSOU:LODMOD:LOD-CUE3  $TITLE  Routines for placing & saving current cue.Modified:2001/02/20 - TY  - Bug fix: PLAY.DTD.CURRENT.CUE() stopcode = 3 (play to end of project) didn't work.1989/08/31 - MWH - Declare event so screen updates after place track change*//*	The following routine is used to place the current cue in	*//*	the sequence:																*//*	returns 0 if cue is placed OK.										*//*	Else returns an error code for an error message					*//*	This routine is passed a pointer into the sequence				*//*	and a code word.  The code word is 1 if a "replace cue"		*//*	is to be done.  If the code word is 1, then the pointer		*//*	into the sequence must point to the note to replace.			*//*	If the cue is successfully placed, a pointer to it				*//*	is returned in the pointer array.									*//*	The following array can be used to point to a single			*//*	event in the sequence to provide a system wide "replace		*//*	cue in sequence" function												*/dcl Recalled.Event.Spointer (spointer.record.size-1)	fixed public;/*	Handy subroutines : see if track can accept cues, set			*//*	global "place track" track#											*/TRACK.AVAILABLE.FOR.CUES: proc (trk) fixed public swapable;	dcl (trk,i)	fixed;	if trk ilt Num.Kbd.Tracks then return false;	write(mam)=Trk.Head;	write(mal)=Trk;	if read(md)=0 then return true;	/*	empty track is ok to use for cues	*/	if Trk.Head.Lookup(trk,THD.CUE.TRACK)<>0 then return true;	/*	already a cue track	*/	I = TRK.HEAD.LOOKUP(TRK,THD.CTIMB);		/*	GET CUR TIMB #		*/	IF I<>0 THEN DO;								/*	IF ONE, CHECK IT	*/		IF TIM.HEAD.LOOKUP(I,TIM.SYNTH.TYP+0)<>4		THEN DO;										/*	IF NOT A CUE LIST	*/			CALL TRK.HEAD.LOOKUP(TRK,THD.NN.MSB);			IF (READ(MDI)\READ(MDI))<>0		/*	ANY NOTES ON TRK?	*/			THEN RETURN FALSE;					/*	NOT A CUE TRACK	*/		END;	END;	RETURN TRUE;end TRACK.AVAILABLE.FOR.CUES;ASSIGN.DTD.PLACE.TRACK: proc (Place.Track) public swapable;	/*	pass abs track #	*/	dcl Place.Track	fixed;	if Place.Track ilt Num.Kbd.Tracks then do;		Place.Track=Num.Kbd.Tracks;	end;	if Place.Track ige (Num.Kbd.Tracks+200) then do;		Place.Track=Num.Kbd.Tracks+199;	end;	call PID(Cue.Place.Track,Place.Track);	/*	Create a system event when the place track changes:	*/	new.dtd.info = new.dtd.info | 4096;	if not Track.Available.For.Cues(Place.Track)	then return 1;	else return 0;end ASSIGN.DTD.PLACE.TRACK;PLACE.DTD.CUE.IN.SEQUENCER: proc (Replpointer, code) public swapable;	dcl Replpointer	array;	/*	pointer into sequence for replace	*/	dcl code				fixed;	/*	0 = place,  1 = replace					*/	dcl event(event.record.size-1)	fixed;	dcl i			fixed;	dcl nlen		fixed;	dcl rlen		fixed;	dcl clen		fixed;	dcl event.to.remove(spointer.record.size-1)	fixed;	if code = 1 then do;		/*	if "Replace" - do delete	*/		/*	Look up information from the existing event to use as the	*/		/*	new event.																	*/		call blockmove(Replpointer, Event, spointer.record.size);		if Get.Sequencer.Event.Information(Event) <> Good.Event.Status		then return 1;			/*	NT#NoEventForReplace			*/		/*	save pointer to event for later removal if all error	*/		/*	checking is completed ok.										*/		call blockmove(event, event.to.remove, spointer.record.size);		/*	set event type to event if event to replace was a		*/		/*	cue trigger (or other randomness):							*/		if event(event.type) <> event.type.event then do;			call Get.Default.Event(event, event.type.event);	/*	get defaults	*/		end;	end;	/*	else if simple event place, get a default event:	*/	else do;		call Get.Default.Event(event, event.type.event);		/*	get defaults	*/	end;	/*	set up event record for place:	*/	event(event.track#)		 = GID(Cue.Place.Track);	call Map.Real.Time.To.Sequence.time(Cue.Trig.Time,													loc(addr(event(event.time.msb))));	event(event.time.count) = 0;	/*	important: set count to 0 so we	*/											/*	know we can find the note again	*/	write(mam) = Current.Cue.Ptr;	write(mal) = CUE.NAME;	call COPY.IN(addr(event(event.cue.name)),Event.Cue.Max.Words);	i = LOCATE.DTD.CUE(loc(addr(event(event.cue.name))));	if i=0 then return 2;	/*	NT#MustSaveCueBeforePlace	*/	event(event.cue.id) = i;	/*	At this point we could do some error checking to make sure	*/	/*	the event will indeed trigger the audio that is in the		*/	/*	cue editor.  Check mapping and track bits							*/	call FETCH.ENTIRE.DTD.CUE (i, Scsi.Ptr);	/*	get cue	*/	if Compare.DTD.Cue.Tracks (Current.Cue.Ptr, Scsi.Ptr) = 0	then return 3;				/*	NT#EventTracksDontMatch		*/	if Compare.DTD.Cue.Maps(Current.Cue.Ptr, Scsi.Ptr) = 0	then return 4;				/*	NT#VersionDoesntMatch		*/	write(mam) = Current.Cue.Ptr;	call COPY.IN(addr(MISC.BUF(0)), 256);	/*	make sure event.in.s#.msb has been set by saving cue:	*/	if (misc.buf(CUE.BITS)&16) = 0	then return 5;				/*	NT#MustSaveCueBeforePlace	*/	call SUB32(loc(addr(misc.buf(CUE.S.MSB))),				  loc(addr(misc.buf(EVENT.IN.S#.MSB))),				  loc(addr(event(event.in.msb))));	call SUB32(loc(addr(misc.buf(CUE.E.MSB))),				  loc(addr(misc.buf(EVENT.IN.S#.MSB))),				  loc(addr(event(event.out.msb))));	call SUB32(loc(addr(misc.buf(CUE.OFF.MSB))),				  loc(addr(misc.buf(EVENT.IN.S#.MSB))),				  loc(addr(event(event.mark.msb))));	event(event.fade.in)  = misc.buf(CUE.FIN);	event(event.fade.out) = misc.buf(CUE.FOUT);	/*	get caption	*/	event(event.caption) = 0;			/*	remove possible old caption	*/	rlen	  = misc.buf(CUE.RLEN);	nlen	  = shr(misc.buf(CUE.NAME)+3,1);	/*	# of wrds in cue name	*/	if rlen igt CUE.NAME+nlen	then do;		clen = misc.buf(CUE.NAME+nlen);		/*	caption length, bytes	*/		if clen <> 0 then do;			write(mam) = Current.Cue.Ptr;			write(mal) = CUE.NAME+nlen;			call COPY.IN(addr(event(event.caption)),shr(clen+3,1));		end;	end;	if code = 1 then do;					/*	delete prior event for "replace"	*/		call Remove.Sequencer.Event(event.to.remove);		call Garbage.Collect.Event.List(event.to.remove(spointer.track#));	end;	i = Place.Event.In.Sequence(event);		/*	put in sequence	*/	if (i = Bad.Event.Track# )	or (i = Event.Music.Track)	then return 6;				/*	NT#BadPlaceTrack	*/	else if (i = Event.Noroom#1)	or		  (i = Event.Noroom#3)	then return 7;				/*	NT#NoRoomForPlace	*/	else if i = Event.Noroom#2	then return 8;				/*	NT#CueListIsFull	*/	else if i <> Good.Event.Status	then return 9;				/*	NT#SystemError		*/	/*	Save return a pointer to the cue we just placed:	*/	call blockmove(Event, Replpointer, spointer.record.size);	return 0;end PLACE.DTD.CUE.IN.SEQUENCER;/*	$page - routine for performing simple save of current cue	*//*	The following routine performs a simple save of the	*//*	current cue without much error checking.					*//*	A more complete implementation with some "smart"		*//*	dialog boxes is in AUDMOD: "SAVE.CURRENT.CUE".  At		*//*	the moment it is hard to implement dialog boxes over	*//*	the protocol.														*//*	Routine returns 0 if direct to disk is not running		*//*			  returns + if cue is save (value is cue id)		*//*			  returns - if error										*/SAVE.CURRENT.CUE.ON.DTD: proc public swapable;	dcl tmp (17-1)			fixed;	dcl Current.Cue.Id	fixed;	if DTD.Max.Secs = 0	/*	return 0 if no DTD	*/	then return 0;	write(mam) = Current.Cue.Ptr;	write(mal) = Cue.Name;	if read(md) = 0	then call INCREMENT.DTD.CURRENT.CUE.NAME;	write(mam) = Current.Cue.Ptr;				/*	serious problem if we		*/	write(mal) = Cue.Name;						/*	cannot come up with			*/	call COPY.IN(addr(tmp(0)),17);			/*	a name to save with.			*/	if tmp(0) = 0 then return 0;	Current.Cue.Id = Locate.DTD.Cue(tmp);	/*	see if saved - look in cur project first	*/	if Current.Cue.Id = 0 then do;			/*	no cue exists - save it		*/		Current.Cue.Id = DEFINE.ENTIRE.DTD.CUE(Current.Cue.Ptr);	end;	else do;											/*	cue exists - see if used	*/		Current.Cue.Id = REPLACE.ENTIRE.DTD.CUE(Current.Cue.Id, Current.Cue.Ptr);	end;	call UnSet.Cue.Modified;	return Current.Cue.Id;end SAVE.CURRENT.CUE.ON.DTD;/*	$page - routines for playing current cue	*//*	DTD PLAY STATE keeps track of whether any DTD scrubbing is going on	*//*	or if a cue has been triggered from the cue directory or the cue		*//*	edit panel.  It is coded as follows:											*//*	0 = DTD is not playing a cue at this time (trig = 0)						*//*	2 = Segment playback - ie a section of the current cue has				*//*		 been triggered by PLAY.DTD.CUE.SEGMENT.									*//*	3 = Segment playback (same as 2) but AEE should not display				*//*		 the current DTD time in the Shuttle.Time.Display or by				*//*		 flagging the coarse bar.														*//*	5 = A cue has been triggered from the Cue Directory						*//*		 using TRIGGER.DTD.CUE.															*//*	6 = Manual DTD recording from AEE Record Panel.								*//*	7 = Cue scrubbing of current cue going on.									*//*	8 = Sequencer triggered (armed) recording going on							*/dcl DTD.PLAY.STATE	fixed public;/*	STOP.DTD.PLAY.STATE is used to stop DTD triggered output.	*/STOP.DTD.PLAY.STATE: proc public swapable;	if LOD.Running <> 0 then do;		/*	send stop trig and stop scroll:	*/		if DTD.PLAY.STATE = 7							/*	if scrubbing, then	*/		then call Send.To.Lod(DTD.Loop.Stop, 0);	/*	stop scrubbing,		*/		else call Send.To.Lod(DTD.Trig.Stop, 0);	/*	else stop trigging	*/		/*	get last scroll position:			*/		call Send.To.Lod(DTD.Scrolling.Off, 0);		/*	if we had been doing cue scrubbing or scan mode playback,	*/		/*	create an event here that will force a new anchor time		*/		/*	event.  This is done because we do not report the anchor		*/		/*	time event while actually scrubbing since this interferes	*/		/*	with the audio.															*/		if (DTD.PLAY.STATE = 2)			/*	if had been doing scan mode,	*/		or (DTD.PLAY.STATE = 3)			/*	or scan mode with no update,	*/		or (DTD.PLAY.STATE = 7)			/*	or scrubbing ...					*/		then new.dtd.info = new.dtd.info \ 512;	end;	DTD.Play.State				  = 0;	AEE.Cue.Blocking.Going.On = 0;end STOP.DTD.PLAY.STATE;/*	Take.Current.Shuttle.Time is used to take the current (or most recent)	*//*	Direct-to-Disk play time.																*/TAKE.CURRENT.SHUTTLE.TIME: proc (time) public swapable;	dcl time	array;	if	(DTD.Play.State <> 0)			/*	If we are currently playing	*/	&	(DTD.Play.State <> 7)			/*	and for sure not scrubbing		*/	&	(Lod.Running	 <> 0)			/*	take time from DTD directly	*/	then do;		call Send.To.Lod(23,0);			/*	Just to get current position updated	*/	end;	call COPY32(loc(addr(Cur.DTD.MS.msb)),time);	if COM16(zero.time,time) = lw#igt then time(1) = zero.time;end TAKE.CURRENT.SHUTTLE.TIME;/*	$page - routines to trigger segment & point playback		*//*	PLAY.DTD.CUE.SEGMENT is called to trigger audio from a	*//*	section of the DTD													*//*	the time that is passed is a 32-bit millisecond time with				*//*	respect to the start of the current cue (if (playcode&1)=1) or			*//*	with respect to the start of the current project (if (playcode&1)=0)	*/PLAY.DTD.CUE.SEGMENT: proc (start,stop,rate,playcode,extract,extractin,extractout) public swapable;	dcl start		array;	/*	in time to play from		*/	dcl stop			array;	/*	out time, or 0 for eof	*/	dcl rate			fixed;	/*	rate to use (encoded)	*/	dcl playcode	fixed;	/*	code bits to control		*/									/*	type of playback:			*/									/*		1: use tempcue area	*/	dcl extract		fixed;	/*	true to perform extract	*/	dcl extractin	array;	/*	extract in  (samples)	*/	/*	these are relative		*/	dcl extractout	array;	/*	extract out (samples)	*/	/*	to the passed in time	*/	dcl i				fixed;	if LOD.Running <> 0 then do;		write(mam) = SCSI.Ptr;		write(mdi) = start(0);		write(mdi) = start(1);		write(mdi) = stop(0);			/*	stop may be 0 for end of song/cue	*/		write(mdi) = stop(1);		write(mdi) = 4+8192;				/*	stop at section end, truncate			*/		write(mdi) = rate;		write(mdi) = 0;					/*	segment plbk (not point)	*/		write(mdi) = 0;					/*	unused codes for seg plbk	*/		write(mdi) = 0;		write(mdi) = 0;					/*	no time information			*/		write(mdi) = playcode;			/*	coded play control bits		*/		write(mdi) = extract;			/*	1 = perform extraction		*/		write(mdi) = extractin (0);	/*	extract in time				*/		write(mdi) = extractin (1);		write(mdi) = extractout(0);	/*	extract out time				*/		write(mdi) = extractout(1);		do i = 16 to 31;			write(mdi) = 0;		end;		call Send.To.Lod(132,64);		/*	send basic info over			*/		call Send.To.Lod( 64, 0);		/*	and start triggered output	*/		call Send.To.Lod(DTD.Scrolling.On,0);		call COPY32(start,loc(addr(Cur.DTD.Ms.Msb)));	/*	to where we started	*/		DTD.Play.State				 = 2;		Most.Recent.AEE.Activity = 0;	/*	for use by take buttons		*/	end;end PLAY.DTD.CUE.SEGMENT;/*	Play.DTD.At.Point is called to initiate point or loop playback		*//*	within the DTD system															*//*	the time that is passed is a 32-bit millisecond time with			*//*	respect to the start of the current cue (if tempcue=1) or			*//*	with respect to the start of the current project (if tempcue=0)	*/PLAY.DTD.AT.POINT: proc (point,mode,time,tempcue) public swapable;	dcl point	array;	/*	pass in time to start point playback at	*/	dcl mode		fixed;	/*	pass mode code for audio desired				*/	dcl time		fixed;	/*	real time milliseconds of mouse press		*/	dcl tempcue	fixed;	/*	1 = use temp cue as mapping					*/	dcl i			fixed;	if LOD.Running <> 0 then do;		write(mam) = SCSI.Ptr;		write(mdi) = point(0);		write(mdi) = point(1);		write(mdi) = 0;		write(mdi) = 0;		write(mdi) = 0;			/*	no bits							*/		write(mdi) = 0;			/*	rate								*/		write(mdi) = 1;			/*	1 for point playback			*/		if mode<3 then do;		/*	point playback					*/			write(mdi) = 0;		/*	0 = point;	1 = loop			*/			write(mdi) = mode;	/*	point playback response		*/		end;		else do;						/*	loop playback					*/			write(mdi) = 1;		/*	0 = point;	1 = loop			*/			write(mdi) = mode-3;	/*	0 = pre		1 = post			*/		end;		write(mdi) = time;		write(mdi) = tempcue;		do i = 11 to 31;			write(mdi) = 0;		end;		call Send.To.Lod(132,64);		call COPY32(point,loc(addr(Cur.DTD.Ms.Msb)));		DTD.Play.State				 = 7;	/*	set play state					*/		Most.Recent.AEE.Activity = 0;	/*	indicate user is shuttling	*/	end;end PLAY.DTD.AT.POINT;/*	$page - convenient routine to play all or part of current cue:	*//*	note: all times are in/out times with respect to the	*//*	current cue															*//*	Returns 0 if cue segment could be played ok.	*//*	Returns 1 no tracks soloed							*//*	Returns 2 if in time > out time					*//*	Returns 3 if some other kind of error.			*/PLAY.DTD.CURRENT.CUE: proc(startcode,backup,stopcode,drive.bits,tempcue) public swapable;	dcl startcode	fixed;	/*	0 = start at current position	*/									/*	1 = start at cue  in time		*/									/*	2 = start at edit in time		*/									/*	3 = start at shuttle bar in	*/									/*	4 = start at shuttle anchor	*/									/*	5 = start at offset time		*/									/*	6 = start at shuttle out		*/									/*	7 = start at cue  out time		*/									/*	8 = start at edit out time		*/	dcl backup		fixed;	/*	1 = backup before playing		*/	dcl stopcode	fixed;	/*	0 = play to end of cue			*/									/*	1 = play to edit out time		*/									/*	2 = play to end of shutle		*/									/*	3 = play to end of project		*/									/*	4 = "smart" limit					*/									/*	5 = play to edit in time		*/									/*	6 = play to time specified by STARTCODE	*/	dcl drive.bits	fixed;	/*	drive bits to play				*/	dcl tempcue		fixed;	/*	1 = use dtd temp cue mapping	*/	dcl intime (1)	fixed;	dcl outtime(1)	fixed;	dcl back	  (1)	fixed;	dcl i				fixed;	if Drive.Bits = 0			/*	no drives soloed?	*/	then return 1;	/*	figure out start time	*/	do case (StartCode);		call TAKE.CURRENT.SHUTTLE.TIME(intime);			/*	0	current position	*/		call COPY32(Cue.In.Time,intime);						/*	1	cue in time			*/		call COPY32(Cue.Edit.In.Time,intime);				/*	2	edit in time		*/		call COPY32(AEE.Shuttle.In.Time,intime);			/*	3	shuttle in time	*/		call COPY32(AEE.Shuttle.Anchor.Time,intime);		/*	4	shuttle anchor		*/		call COPY32(Cue.Offs.Time,intime);					/*	5	offset time			*/		call COPY32(AEE.Shuttle.Out.Time,intime);			/*	6	end of shuttle		*/		call COPY32(Cue.Out.Time,intime);					/*	7	cue out time		*/		call COPY32(Cue.Edit.Out.Time,intime);				/*	8	edit out time		*/	end;	/*	get and check end time	*/	do case (StopCode);		do;			call COPY32(Cue.Out.Time,outtime);				/*	0	cue out time		*/			if COM32(intime,outtime) >= lw#ieq				/*	if past end of cue	*/			then call COPY32(Cue.In.Time,intime);			/*	then play cue			*/			if COM32(intime,outtime) = lw#ieq			then return 2;		end;		do;			call COPY32(Cue.Edit.Out.Time,outtime);		/*	1	edit out time		*/			if COM32(intime,outtime) = lw#igt				/*	if past end of			*/			then call COPY32(Cue.Edit.In.Time,intime);	/*	edit point, do it		*/			if COM32(intime,outtime) = lw#ieq				/*	edit has zero size	*/			then return 3;											/*	then nothing to do	*/			if COM32(intime,outtime) = lw#igt				/*	if still past end		*/			then return 2;		end;		do;			call COPY32(AEE.Shuttle.Out.Time,outtime);	/*	2	shuttle out	time	*/			if COM32(intime,outtime) >= lw#ieq			then call STR32(0,0,outtime);						/*	play to proj end		*/		end;		do;															/*	3	end of project		*/			call STR32(0,0,outtime);							/*		see lod				*/		end;		do;															/*	4	smart limits		*/			if COM32(intime,Cue.Out.Time) = lw#ilt			/*	play to cue end		*/			then call COPY32(Cue.Out.Time,outtime);			else if COM32(intime,AEE.Shuttle.Out.Time) = lw#ilt			then call COPY32(AEE.Shuttle.Out.Time,outtime);	/*	play to shuttle end	*/			else call STR32(0,0,outtime);							/*	play to proj	 end	*/		end;		do;			call COPY32(Cue.Edit.In.Time,outtime);			/*	5	to edit in time		*/			if COM32(intime,outtime) >= lw#ieq			then return 2;		end;		do;															/*	6	to same time specified by STARTCODE	*/			call COPY32(intime,outtime);						/*	just copy time			*/			/*	no limit checking here -- this STOPCODE is	*/			/*	used in conjunction with the BACKUP flag		*/			/*	to play up to a specified DTD point.			*/		end;	end;	/*	back up if desired	*/	if backup then do;		i=Samp.Speed*2;					/*	back up 2 seconds			*/		if Current.Cue.Rate >0 then do;			i=i*(1+Current.Cue.Rate);	/*	+1 = 2x, +2 = 3x, etc	*/		end;		else if Current.Cue.Rate<0 then do;			i=i/(1-Current.Cue.Rate);	/*	-1 = 1/2, -2 = 1/3, etc	*/		end;		call STR32(0,i,back);		call ADD16(zero.time,back);		if COM32(back,intime) = lw#igt		then call STR32(0,zero.time,intime);		else do;			call SUB16(zero.time,back);			call SUB32(intime,back,intime);		end;	end;	if DTD.Max.Secs <> 0 then do;		call Set.DTD.Play.Tracks(Drive.Bits);		/*	If the region we wish to hear is within the in-time and out-time	*/		/*	of the current cue, and we have the latest LOD software				*/		/*	available, then use the 'extract' feature so we hear the				*/		/*	desired section of audio as modified by the fade-in/fade-out		*/		/*	parameters of the underlying cue:											*/		if  (COM32(outtime, zero.zero   ) != lw#ieq)		//	don't use this block if we're playing to end of project		and (COM32(intime,  Cue.In.Time ) >= lw#ieq)		and (COM32(outtime, Cue.Out.Time) <= lw#ieq)		and (lod.version						 >= 9		 )		then do;			call SUB32(intime,  Cue.In.Time, intime );	/*	get distance from cue in	*/			call SUB32(outtime, Cue.In.Time, outtime);			call Msec.To.DTD.Sample.#(intime,  CF#Dur, SAMP.SPEED, AEE.Current.Project.Rate, zero.zero, intime);			call Msec.To.DTD.Sample.#(outtime, CF#Dur, SAMP.SPEED, AEE.Current.Project.Rate, zero.zero, outtime);			call Play.DTD.Cue.Segment(Cue.In.Time, Cue.Out.Time, Current.Cue.Rate, tempcue, 1, intime, outtime);		end;		else call Play.DTD.Cue.Segment(intime,outtime,Current.Cue.Rate,tempcue, 0, zero.zero, zero.zero);	end;	return 0;	/*	Segment has been triggered!	*/end PLAY.DTD.CURRENT.CUE;