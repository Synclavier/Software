/* PRO-LOAD   $TITLE  Load remote devices via the D115D/RS422 interface   Modified:   07/24/89 - cj  - changed return value of map.d115.node.id   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/22/89 - MWH - Reload D115 when it requests it   03/10/89 - MWH - Fix bug in last packet length   02/10/89 - MWH - Add download of 68000 code to Remote Box   01/25/89 - MWH - Author   *//* This procedure looks in the system file ":.SYSTEM:.68K:NODENAME" and   searches for the name of a file to download to a peripheral via the   D115D.  If it finds the name, it returns it in the caller-defined array   "name_buf" and the procedure returns a "1".  If the name is not found,   the return value is "0" and name_buf is unchanged.  The argument "node" is   the device type number (as defined in PROLITS) shifted right-justified   (right 4: normally, over the network this number is in the upper nibble   of the lower byte).   The format of the NODENAME file is as follows:      * Any line starting with a "*" is a comment line (ignored)      * Blank lines are ignored too      * Data lines must have the device number, space(s), filename      * where device number is 0=Able, 1=Mac, 2=RBox, 3=MIDI;      * filename is a file containing the data to be downloaded to that      * device.  The file is assumed to be in the catalog ":.SYSTEM:.68K"      * Device number may be L or M for D115 load and main code respectively.      * Sample data lines:      L  D115LOAD      M  D115MAIN      1  MAC1.0      2  RBOX1.0 */Get.NodeName: proc(node,name_buf) public swapable;   dcl node            fixed;      /* Which device type is this */   dcl name_buf        array;      /* Caller gives us an array for the filename */   dcl names_fid       fixed;      /* File ID of the NODENAME file */   dcl line (128)      fixed;      /* Read file lines into here */   dcl line#           fixed;      /* Line number read in */   dcl which_char      fixed;      /* Current character pointer into line buffer */   dcl ch              fixed;      /* Character read from the line */   dcl found           fixed;      /* Set true when we find the one we want */   dcl num             fixed;      /* Build number here from ascii input */   dcl file_prefix     lit '''W0:.SYSTEM:.68K:''';   dcl node_name       lit '''W0:.SYSTEM:.68K:NODENAME''';   line#  = 0;   found = 0;   names_fid = fopen(node_name,'r');   if names_fid = NULLF then do;          /* No such file */      return (0);                         /* Failure */   end;   else call setbuf(names_fid,sect.ptr,1,256);   do while line# <> EOF_MARK   AND (not FEOF(names_fid));      line# = fgets(line,256,names_fid);  /* Get next line from file */      call upper(line);                   /* Make it all upper case */      which_char = 0;                     /* Init some things */      num = -1;      ch = byte(line,which_char);      if line(0) = 0                      /* Skip zero length line */      then ;      else if ch = a.star                 /* Skip comment line */      then ;      else if ch = a.l                    /* Found loader */      AND node = DD#Load      then do;         found = 1;         which_char = which_char + 1;      end;      else if ch = a.m                    /* Found d115 main program */      AND node = DD#Main      then do;         found = 1;         which_char = which_char + 1;      end;      /* Normal node number */      else do while ch >= a.0 AND ch <= a.9;         if num = -1 then num = 0;        /* Toss the -1 since we've found a digit */         num = (num * 10) + (ch - a.0);         which_char = which_char + 1;         ch = byte(line,which_char);      end;      if num <> -1                        /* Found a number */      AND node = num                      /* Is it the one we want? */      then do;         found = 1;                       /* Yes; found it */      end;      if found = 1 then do;         /* Skip spaces */         do while byte(line,which_char) = a.space;            which_char = which_char + 1;         end;         /* Here's the filename */         call Strcpy(name_buf,file_prefix);         call Strncpy(copy.buf,line,which_char,line(0));         call Strcat(name_buf,copy.buf);         call fclose (names_fid);         return(1);      end;   end;   call fclose (names_fid);   return(0);                    /* Never found the node in the NODENAME file */end Get.NodeName;/* Download 68k code quickly from an "open" (located) file */Download: proc(f#ms,f#ls,len,node_id) swapable;   dcl (f#ms,f#ls) fixed;  /* File pointers to download data */   dcl len         array;  /* Total length to send in bytes */   dcl node_id     fixed;  /* Destination node id */   dcl board       fixed;  /* Destination board number */   dcl send_len    fixed;  /* Length of this send packet */   dcl timer       fixed;  /* Time how long it takes to send successfully */   dcl p           fixed;  /* Pointer into sector read from disk */   dcl i           fixed;   p = 6;                    /* Start with 7th word of the file */   board = map.d115.node.id(node_id);   if board = -1 then do;              /* Didn't find the device */      /* Start a 3 second timer in case we're just coming up */      timer = real.milliseconds;      do while board = -1;         board = map.d115.node.id(node_id);         if (real.milliseconds - timer) igt 3000         then return(0);               /* There is no device to download */      end;   end;   copy.buf(P#Source) = board & 1;     /* Low bit is the channel # */   board = shr(board,1);               /* Get board #              */   copy.buf(P#Type) = T#Net_Reload_Data;   do while (com16(0,len) = lw#ilt);      if com16((L#Net_Reload_Data-6),len) <= lw#ieq then do;         send_len = L#Net_Reload_Data;   /* Room for another full message */      end;      else do;                           /* Send only the remaining bytes */         send_len = len(lw#lsb) + 6;     /* Add in 6 bytes for des, len, super/sub types */      end;      do i=1 to shr(send_len-5,1);       /* Yes (subtract to get just DATA words) */         copy.buf(i+2) = misc.buf(p);    /* Send data words */         p = p + 1;         if p >= 256 then do;            p = 0;            f#ls = f#ls + 1;            if f#ls = 0 then f#ms = f#ms + 1;            call readdata(f#ms,f#ls,misc.buf,256);         end;      end;      /* Start a 3 second timer in case send fails continuously */      i = 0;      timer = real.milliseconds;      copy.buf(P#Len) = send_len;      do while i = 0;         i = Fast.Send.Protocol.Packet(addr(copy.buf(0)),board);         if  i = 0         AND (real.milliseconds - timer) igt 3000         then return(0);                 /* Nobody's listening to us */      end;      send_len = send_len - 6;           /* Get DATA only from length */      if com16(send_len,len) = lw#ilt      then call sub16(send_len,len);     /* Subtract DATA only from remaining bytes */      else call str32(0,0,len);          /* Else, we're done */   end;                                  /* Of while there's more to send */   return(1);                            /* Success */end Download;Remote.Load: proc (device,node_id) swapable;       /* Load microcode into remote peripheral via RS422 */   dcl device        fixed;  /* Type of device to load */   dcl node_id       fixed;  /* Full ID of device to load */   dcl program_name (64) fixed;   dcl len (1)       fixed;  /* Length of program */   dcl timer         fixed;  /* Time how long it takes to send successfully */   dcl dl.msb        fixed;  /* Program download address */   dcl dl.lsb        fixed;   dcl start.msb     fixed;  /* Program transfer (start) address */   dcl start.lsb     fixed;   dcl (f#ms,f#ls)   fixed;  /* File pointers to download data */   dcl i             fixed;   if device = 0 then do;    /* Special: request to reload D115 itself */      call INIT.D115;        /* Initialize RS422 communications processor */      return(1);             /* We are done */   end;   if Get.NodeName(device,program_name) = 0   then return(1);                    /* We have no file to load */   i = locate(program_name,0);   if i = nullf then do;              /* No such file */      return(1);                      /* Failure - we're done */   end;   f#ms = F#MS_Sector;                /* Save where we found the file */   f#ls = F#LS_Sector;   call readdata(f#ms,f#ls,misc.buf,256);   len(lw#msb) = misc.buf(0);         /* Get length */   len(lw#lsb) = misc.buf(1);     dl.msb      = misc.buf(2);         /* Get program download address */   dl.lsb      = misc.buf(3);     start.msb   = misc.buf(4);         /* Get entry point offset */   start.lsb   = misc.buf(5);   copy.buf(0) = L#Net_Reload_Base_Addr;   copy.buf(1) = node_id;   copy.buf(2) = T#Net_Reload_Base_Addr;   copy.buf(3) = dl.msb;              /* Download address */   copy.buf(4) = dl.lsb;          /* If we get a download request just as the device is coming up, wait */   /* for it to send a "here-is" message and be in the mapping table */   i = map.d115.node.id(node_id);   if i = -1 then do;              /* Didn't find the device */      /* Start a 3 second timer in case we're just coming up */      timer = real.milliseconds;      do while i = -1;         i = map.d115.node.id(node_id);         if (real.milliseconds - timer) igt 3000         then return(0);               /* There is no device to download */      end;   end;   /* Now, we know the device is there, so start the download */   if Send.Protocol.Packet(addr(copy.buf(0)),0) = 0   then return(0);                    /* Failure - try again later */   call cpos(23,0);                /* 24th line of screen */   call pc(27);                    /* ESC */   call ps('[KDownloading ');   do case device;      ;                            /* 0 = Able (we don't load) */      call ps('MAC');              /* 1 = MAC */      call ps('DESC');             /* 2 = Remote Box */      call ps('MIDI');             /* 3 = Monster MIDI */   end;   call ps(' Computer Memory...');      interp_flush_char_output();   i = Download(f#ms,f#ls,len,node_id);  /* Download the user program */   call cpos(23,0);                      /* Clean up 24th line of screen */   call pc(27);   call ps('[K');   interp_flush_char_output();   if i = 0 then return(1);        /* Failure - we're done on download time-out */   copy.buf(0) = L#Net_Reload_Start_Addr;   copy.buf(1) = node_id;   copy.buf(2) = T#Net_Reload_Start_Addr;   copy.buf(3) = start.msb;   copy.buf(4) = start.lsb;   /* Start a 3 second timer in case send fails continuously */   i = 0;   timer = real.milliseconds;   do while i = 0;      i = Send.Protocol.Packet(addr(copy.buf(0)),0);      if (real.milliseconds - timer) igt 3000      then i = 1;                     /* Nobody's listening to us; we're done */   end;   return(1);                         /* Successful load */end Remote.Load;D115.Download: proc(node_id) public swapable;   dcl node_id fixed;   dcl device  fixed;/* dcl unit    fixed; */   device = shr(node_id & NN#Dev_Mask,4);    /* Get the remote device type *//* unit   = node_id & NN#Unit_Mask; */       /* For now, ignored (assume one of each type) */   return(Remote.Load(device,node_id));end D115.Download;