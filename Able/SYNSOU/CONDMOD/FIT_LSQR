/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: FIT_LSQRPATH:		 :SYNSOU:CONDMOD:FIT_LSQRCONTAINS: SOURCE CODE FOR THE PROCEDURE "least_squares_fit"REVISION HISTORY:00	1999/11/21	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*This file contains the procedure least_squares_fit which generates the optimal combination oftempo and offset such that the sum of the squares of the differences between the cue times andthe real times at which the target beats occur is minimized.Note: all sums below are over the range i = 0 to n-1------------------------------------tempo_numerator =+n * Sum(target(i)*cue(i))- Sum(cue(i)) * Sum(target(i))------------------------------------offset_numerator =+ Sum(cue(i)) * Sum(target(i)^2)-Sum(target(i)*cue(i)) * Sum(target(i))------------------------------------denominator =+ n * Sum(target(i)^2)-Sum(target(i))^2*//*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE least_squares_fit												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/least_squares_fit: proc swapable;	dcl smpte.time							(4)	fixed;	dcl tempo32								(1)	fixed;	//	the tempo on real microseconds per beat	dcl offset32							(1)	fixed;	//	the time in real milliseconds that we'll have to adjust the SMPTE and cue track by 	dcl cue32								(1)	fixed;	///////////////////////////////////////////////	DEBUG ONLY	dcl target32							(1)	fixed;	///////////////////////////////////////////////	DEBUG ONLY//	dcl temp_array	(1)	fixed;	dcl temp_array			lit 'tempo32';	dcl cue_ptr				lit 'x';	dcl target_ptr			lit 'y';	dcl sum_of_cues		lit 'aux1_ptr';	//	Sum(cue(i))					for i = 0 to n-1	dcl sum_of_targets	lit 'aux2_ptr';	//	Sum(target(i))				for i = 0 to n-1	dcl sum_of_products	lit 'aux3_ptr';	//	Sum(target(i)*cue(i))	for i = 0 to n-1	dcl sum_of_squares	lit 'aux4_ptr';	//	Sum(target(i)^2)			for i = 0 to n-1	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	/*																							*/	/*		SUBPROCEDURE recycle_all_apvs												*/	/*																							*/	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	//	This is provided to simplify exiting this procedure from the multitude of places where an error may occur.	recycle_all_apvs: proc;		//	RECYCLE REMAINING APVs		apv_recycle(cue_ptr);		apv_recycle(target_ptr);		apv_recycle(sum_of_cues);		apv_recycle(sum_of_targets);		apv_recycle(sum_of_products);		apv_recycle(sum_of_squares);		apv_recycle(aux_ptr);		apv_recycle(pre_ptr);		apv_recycle(num_ptr);		apv_recycle(den_ptr);		apv_recycle(smpte_num_ptr);		apv_recycle(smpte_den_ptr);	end recycle_all_apvs;	//	ииииииииииииииииииии   M A I N   P R O C E D U R E   S T A R T S   H E R E   ииииииииииииииииииии	if (CFit.Map.Ptr == null) return;		//	nothing to do	stop.recd.move.play.xpos.cont.eras();	//	stop any performance	//	get the number of cues	n = get_final_cfit_cue_info(temp_array);	//	Special Case: If there is only 1 cue, then we have nothing to calculate tempos with.  Just insert/delete	//	the necessary time at/from the beginning of the sequence (and alter the SMPTE offset accordingly) such that	//	the sequence travel path at the current tempo intersects the (target,cue) point.//	if (n == 1) {	if (n ilt 1) {		//	*** CURRENTLY NOT IMPLEMENTED ***		print 'fuggit';	//	For now		return;		//	THIS NEEDS TO BE CHECKED!		//	THIS PROCEDURE MAY ACTUALLY ACCOMPLISH THE DESIRED RESULT FOR (n == 1), OR IT MAY BLOW UP.		//	ALSO CHECK TO MAKE SURE NOTHING BLOWS UP FOR (n == 2) AND (n == 3).	}	//	ииииииииииииииии STEP 1: ALLOCATE APVs AND SET UP INITIAL VALUES ииииииииииииииииииииииииииииииии	//	ALLOCATE ALL APVs	cue_ptr				= apv_allocate_node;	target_ptr			= apv_allocate_node;	sum_of_cues			= apv_allocate_node;	sum_of_targets		= apv_allocate_node;	sum_of_products	= apv_allocate_node;	sum_of_squares		= apv_allocate_node;	aux_ptr				= apv_allocate_node;	pre_ptr				= apv_allocate_node;	num_ptr				= apv_allocate_node;	den_ptr				= apv_allocate_node;	smpte_num_ptr		= apv_allocate_node;	smpte_den_ptr		= apv_allocate_node;	//	INITIALIZE SMPTE CONSTANTS	 (This needs a DO CASE to handle the different SMPTE modes.)	load 50000; mul 1000;	apv_put_word(smpte_num_ptr,0,res);	apv_put_word(smpte_num_ptr,1,ures);	apv_assign(smpte_den_ptr,2997);	//	INITIALIZE APV POINTER ARRAYS AND APV VALUES	//	NOTE: SINCE "apv_allocate_node" LEAVES IT'S RETURNED POINTER IN REGISTER 13, A VALUE CAN	//	IMMEDIATELY THEREAFTER BE ASSIGNED TO THE NEWLY ALLOCATED APV BY PASSING "read(reg_src|r13)"	//	AS THE POINTER IN A SUBSEQUENT CALL TO "apv_assign" OR "apv_input_u32".			//	ииииииииииииииии STEP 2: PRECOMPUTE THE VALUES THAT WILL BE USED REPEATEDLY иииииииииииииииииииии	reset_cfit_map();	//	point all cfit variables to the first record (which is null)	do i = 0 to n-1;		//	PLUG IN CUE AND TARGET VALUES FROM THE CURVE FIT MAP		get_next_cfit_pair(BitMsbArray,temp_array);		//	we must remove the zero time offset from both the cues and the targets		if (bitlsb ilt zero.time) bitmsb = bitmsb-1;	//	borrow if necessary		bitlsb = bitlsb-zero.time;							//	remove zero time offset from cue		sub16(zero.time,temp_array);						//	remove zero time offset from target		//	also convert cue time to whole video fields		ratio_multiply(2997,50000);	//	(This needs a DO CASE to handle the different SMPTE modes.)		apv_input_u32(cue_ptr	,BitMsbArray);		apv_input_u32(target_ptr,temp_array);		//	accumulate sum_of_cues		apv_addsub(cue_ptr,sum_of_cues,sum_of_cues,#add);		//	accumulate sum_of_targets		apv_addsub(target_ptr,sum_of_targets,sum_of_targets,#add);		//	accumulate sum_of_products		apv_multiply(cue_ptr,target_ptr,aux_ptr);		apv_addsub(aux_ptr,sum_of_products,sum_of_products,#add);		//	accumulate sum_of_squares		apv_multiply(target_ptr,target_ptr,aux_ptr);		apv_addsub(aux_ptr,sum_of_squares,sum_of_squares,#add);	end;	apv_assign(pre_ptr,n);	least_squares(tempo32,offset32);	//	ииииииbиeиgиiиnиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииии	//	print out the results	cpos(0,0);	reset_cfit_map();	do i = 0 to n-1;		get_next_cfit_pair(cue32,target32);		ps('cue32 = '); print_u32(cue32,false);		ps(', target32 = '); print_u32(target32,false);		pcr();	end;	ps('tempo = '); print_u32(tempo32,false);	ps(', offset = '); print_u32(offset32,false);	pcr(); interp_flush_char_output();	input zilch;	//	ииииииeиnиdиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииииииии	//	ииииииииииииииии STEP 3: CLEAN UP иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии	recycle_all_apvs();	//	ииииииииииииииии STEP 4: CONVERT THE DESIGNATED CUE TRACK TO REAL TIME ииииииииииииииииииииииииии	//	This is done so that after the tempo map is generated, these cue notes can then be converted	//	back to sequence time, the end result being that they will still occur at the same real time	//	as they did before the map was generated.	//	All other notes in the sequence will follow the new temo map.	modify.bounce(cond_track#,op#seq.to.real,temp_array);	//	Note: The contents of temp_array are irrelevant here	//	ииииииииииииииии STEP 5: GENERATE NEW TEMPO MAP иииииииииииииииииииииииииииииииииииииииииииииииии	if (undo.enabled != false) save.undoseq();	//	set up for possible undo	samp.click.rate = 480;	//	For compatibility with just about all other MIDI sequencers	//	If no maps are in use yet, start by creating defaults.  However, if a tempo map already exists,	//	it must first be nuked first.	if (Meter.Map.Ptr == null)	Create.Default.Meter.Map();	if (Tempo.Map.Ptr != null)	Erase.Tempo.Map.Info();	Create.Default.Tempo.Map();	if ((Tempo.Map.Ptr|Meter.Map.Ptr) == null)	{	//	Bail if not enough memory for maps		ertyp = err.oom;		return;	}	Set.Tempo(zero.zerotime,tempo32);	//	ииииииииииииииии STEP 6: SLIDE THE CUE TRACK AND UPDATE THE SMPTE OFFSET ииииииииииииииииииииииии	//	(Note: This must be done before converting it back to sequence time.)	if	((offset32(0)|offset32(1)) != 0) {	//	(nothing to do if no offset)		if	(offset32(0) < 0) {			//	the offset is negative, so we need to insert time into the cue track			//	and subtract from the SMPTE start time to compensate			neg32(offset32);				//	the next call needs a positive time			Insert.Time.On.Trk(cond_track#,0,zero.time,offset32(0),offset32(1));			add16(zero.time,offset32);	//	we want this duration interpreted as an absolute time from zero			neg32(offset32);				//	re-negate so this time will be subtracted		}		else { 			//	the offset is positive, so we need to delete time from the cue track			//	and add to the SMPTE start time to compensate			Delete.Time.From.Trk(cond_track#,0,zero.time,offset32(0),offset32(1));			add16(zero.time,offset32);	//	we want this duration interpreted as an absolute time from zero		}		msec.to.smpte(offset32,cf#time,samp.speed,S$Smode,S$Soffset,smpte.time);		set.synclav.smpte.offset(smpte.time);		//	Note: The following will be achieved automatically since the new constants flag of new.seq.info has been set.		//	Sample.Syncl.Smgr.Globals();	//	let the screen manager know all about it	}	//	ииииииииииииииии STEP 7: CONVERT THE DESIGNATED CUE TRACK BACK TO SEQUENCE TIME иииииииииииииииии	modify.bounce(cond_track#,op#real.to.seq,temp_array);	//	Note: The contents of temp_array are irrelevant here	play.initialize();	//	Since a new tempo map was created	//	ииииииииииииииии STEP 8: UPDATE THE GRAPH иииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	The x-axis will remain the same but the spacing of the tick marks on the y-axis will probably change	//	Note: The following will be achieved automatically since the new constants flag of new.seq.info has been set.	//	erase_cfit_map();	//	since the real times of the cues have changed due to the new tempo and offsetend least_squares_fit;/*To Do:	Check for occurrences of these...Note: The following procedures will return without completing their tasks if memory is not available.Consequently one should check if (ertyp != null) after each call.	apv_allocate_node	apv_duplicate	apv_put_word	apv_negate	apv_or	apv_word_shr	apv_word_shl	apv_shr	apv_shl	apv_output_s32	apv_addsub	apv_multiply	apv_quotient	apv_mod	apv_gcd	apv_reduce	apv_printNote: The following procedures also will return without completing their tasks if a division by zero error occurs.Consequently one should check if (ertyp != null) after each call.	apv_quotient	apv_mod	apv_gcd	apv_reduceNote: The following procedure will return without completing its task if a sign error or overflow error occurs.Consequently one should check if (ertyp != null) after each call.	apv_output_u32cue32 =  1970, target32 =  1970cue32 =  4356, target32 =  4370cue32 =  7008, target32 =  6770cue32 =  9060, target32 =  9170cue32 =  9944, target32 = 10130cue32 = 12981, target32 = 13010cue32 = 15734, target32 = 15890cue32 = 17052, target32 = 16850tempo = 479367, offset = 5?cue32 =  1965, target32 =  1970cue32 =  4351, target32 =  4370cue32 =  7003, target32 =  7250cue32 =  9055, target32 =  9170cue32 =  9939, target32 = 10130cue32 = 12976, target32 = 13010cue32 = 15729, target32 = 15890cue32 = 17047, target32 = 16850tempo = 482698, offset = 4294967173?cue32 =  2088, target32 =  1970cue32 =  4474, target32 =  4370cue32 =  7126, target32 =  7250cue32 =  9178, target32 =  9170cue32 = 10062, target32 = 10130cue32 = 13099, target32 = 13010cue32 = 15852, target32 = 15890cue32 = 17170, target32 = 16850tempo = 482698, offset = 4294967290?cue32 =  2094, target32 =  1970cue32 =  4480, target32 =  4370cue32 =  7132, target32 =  7250cue32 =  9184, target32 =  9170cue32 = 10068, target32 = 10130cue32 = 13105, target32 = 13010cue32 = 15858, target32 = 15890cue32 = 17176, target32 = 16850tempo = 482819, offset = 2?cue32 =  2092, target32 =  1970cue32 =  4478, target32 =  4370cue32 =  7130, target32 =  7250cue32 =  9182, target32 =  9170cue32 = 10066, target32 = 10130cue32 = 13103, target32 = 13010cue32 = 15856, target32 = 15890cue32 = 17174, target32 = 16850tempo = 482698, offset = 4294967290?cue32 =  2098, target32 =  1970cue32 =  4484, target32 =  4370cue32 =  7136, target32 =  7250cue32 =  9188, target32 =  9170cue32 = 10072, target32 = 10130cue32 = 13109, target32 = 13010cue32 = 15862, target32 = 15890cue32 = 17180, target32 = 16850tempo = 482698, offset = 10??cue32 = 1826, target32 = 1970cue32 = 4034, target32 = 3890tempo = 554721, offset = 4294966846?cue32 = 2276, target32 = 1970cue32 = 4484, target32 = 3890tempo = 554721, offset = 0?cue32 = 2276, target32 = 1970cue32 = 4484, target32 = 3890tempo = 554721, offset = 0??*/