/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: CONDSOUPATH:		 :SYNSOU:CONDMOD:CONDSOUCONTAINS: DRIVER FOR "CONDUCTOR TOOLS" SCREENREVISION HISTORY:00	1999/10/10	Todd Yvega	Created.*/module condmod;/*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/insert ':SYNLITS:ALLTLITS';	//	get all terminal literalsinsert ':SYNAUXS:ERRLITS';		//	err.oominsert ':SYNAUXS:EDITLITS';	//	operation literals for modify.bounce()insert ':SYNLITS:L#ASM.0';		//	TY's pseudo assembly language literals//	For readabilitydcl #solid			lit '0';dcl #dotted			lit '1';dcl #pixels_on		lit '0';dcl #pixels_off	lit '1';//	This should eventually be a gid/pid variable editable by the user, but for now...dcl cond_track#	lit '31+1';	//	Temporary (for development purposes)//	values for the variable "subscreen" (also handy to pass as graphics.button.table row numbers)dcl target_editor	lit '0';	//	Target Editor Subscreendcl optimal_tempo	lit '1';	//	Optimal Tempo Graph Subscreendcl curve_fit		lit '2';	//	Curve Fit Graph Subscreendcl meter_chart	lit '3';	//	Meter Chart Subscreen//	screen manager object identifiers//	the first two objects will be defined just once and coexist with all subscreensdcl obj#infolabel				lit ' 1';	//	label used for progress reporting and as a current object during subscreen redefinitionsdcl obj#subscreen_select	lit ' 2';	//	graphics button table for selecting subscreen//	all subsequent objects will be redefined for each subscreendcl obj#graph					lit ' 3';dcl obj#button0				lit ' 4';dcl obj#scrollbar				lit ' 4';	//	subscreens with a scroll bar don't use obj#button0dcl obj#button1				lit ' 5';dcl obj#button2				lit ' 6';dcl obj#button3				lit ' 7';dcl obj#button4				lit ' 8';dcl obj#button5				lit ' 9';dcl obj#button6				lit '10';dcl obj#button7				lit '11';dcl #highest.object.id		lit '11';	// handy for erase.object.range() and undefine.object.range()//	Note regarding the size literals below: The sizes defined here are non-inclusive pixel widths.  That is,//	origin+size = the last pixel of the graph, not the first pixel after the graph.//	Programmers should be aware that the inclusive pixel width = size+1//	match #graph_origin_x to the left edge of leftmost transparent mode character, but subtract 12 pixels for the tick marksdcl #graph_origin_x	lit '(((0*100)*3/25)+23-12)';//	match #graph_origin_y to the bottom edge of row 22 in transparent modedcl #graph_origin_y	lit '((((23-22)*100)*3/10)+42)';//	for symmetry, use a right margin equal to the left margin.//	(121 is the inclusive pixel width of the subscreen selection button table, and 9 is the width of the gap between it and the graph.)dcl #graph_size_x		lit '(((1023-#graph_origin_x)-#graph_origin_x)-9-121)';//	match the top to the top edge of row 0 in transparent mode.//	(this will also be the top of the subscreen selection button table.)dcl #graph_size_y		lit '(((((23-(0-1))*100)*3/10)+42)-#graph_origin_y)';/*ииииииииииииииии  E X T E R N A L   R E F E R E N C E S  ииииииииииииииии*/insert ':-xpl:intrprtr';insert ':SYNMODS:GLOBDCL';		//	set.error(), ertypinsert ':SYNMODS:TPRIMDCL';	//	exit.my.screen, goto.this.screeninsert ':SYNMODS:GETDCL';		//	get_enable(), get_disable()insert ':SYNMODS:GETVDCL';		//	new.ABLE.seq.infoinsert ':SYNMODS:TTYDCL';		//	pc(), ps(), pnum(), cpos()insert ':SYNMODS:TFORMDCL';	//	copy.string()insert ':SYNMODS:SMGRDCL';		// get.next.screen.event(), zero.zerotimeinsert ':SYNMODS:LINKDCL';		//	set.synclav.smpte.offset()insert ':SYNMODS:EDITADCL';	//	undo.enabledinsert ':SYNMODS:PLOTDCL';		//	clear.term()insert ':SYNMODS:MATHDCL';		//	32-bit routines for sequence times.  Also msec.to.smpte()insert ':SYNMODS:APVDCL';		//	absolute precision math for gaussian elimination, etc.insert ':SYNRDCLS:03-PDCLS';	//	nah.ptr, nah.free, nah.#freeinsert ':SYNRDCLS:04-SDCLS';	//	#NMSB, #NLSB, #WRD, #SEC, load.seq.globals(), stop.recd.move.play.xpos.cont.eras()insert ':SYNRDCLS:12-EDCLS';	//	insert.time.on.trk(), delete.time.from.trk()//	Tempo/Meter map stuff.  These are inexplicably missing from :SYNRDCLS:03-PDCLSdcl Map.Long.Measures.Beats.To.Sequence.Time	proc (fixed array,fixed array) external;dcl Map.Sequence.Time.To.Long.Beats				proc (fixed array,fixed array) external;dcl Map.Sequence.Time.To.Nearest.Measures		proc (fixed array,fixed array,fixed array) external;dcl Create.Default.Tempo.Map						proc									 external;dcl Create.Default.Meter.Map						proc									 external;dcl Erase.Tempo.Map.Info							proc									 external;dcl Erase.Meter.Map.Info							proc									 external;//	Inexplicably missing from :SYNMODS:EDITBDCLdcl modify.bounce										proc (fixed,fixed,fixed array) returns (fixed) external;//	From :SYNRSOU:03-PRIM:043-MAPSdcl locate_tempo_map									proc (fixed array)				 external;dcl locate_cfit_map									proc (fixed array)				 external;dcl get_next_tempo_pair								proc (fixed array,fixed array) external;dcl get_next_cfit_pair								proc (fixed array,fixed array) external;dcl get_final_tempo_event_info					proc (fixed array,fixed array) external;dcl get_final_cfit_cue_info						proc (fixed array)				 returns (fixed) external;dcl cfit_target_to_record#							proc (fixed array)				 returns (fixed) external;dcl reset_cfit_map									proc									 external;dcl erase_cfit_map									proc									 external;dcl Create.CFit.Map.From.Track					proc (fixed)						 external;dcl CFit.Map.Ptr	fixed external;/*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*/dcl zilch fixed;	///////////////////////////////////////////////////////////	DEBUGdcl subscreen	fixed;	//	which subscreen is current//	STATIC VARIABLES (used by the various curve fit procedures and their subprocedures)dcl n	fixed;	//	NUMBER OF (TARGET,CUE) PAIRS TO FITdcl i	fixed;	//	GENERAL PURPOSE INDEXdcl (aux1_ptr,aux2_ptr,aux3_ptr,aux4_ptr,aux5_ptr)	pointer;dcl (aux_ptr,pre_ptr)										pointer;dcl (num_ptr,den_ptr)										pointer;//	THESE WILL POINT TO APVs HOLDING REPEATEDLY USED CONSTANT VALUESdcl (smpte_num_ptr,smpte_den_ptr)	pointer;//	INTERNAL POINTERS TO APV ARRAYS HOLDING POINTERS TO OTHER APVsdcl (x,y)									pointer;//	THESE WILL NOT BE ALLOCATED THEIR OWN APVs, BUT WILL BE USED TO REMEMBER THE VALUES OF OTHER//	POINTERS, TO AVOID HAVING TO REPEATEDLY LOOK UP POINTERS WITH CALLS TO "apv_get_value".dcl (tmp1_ptr,tmp2_ptr)					pointer;	/*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*///	Insert source files//	Graph plotting routines//	insert ':SYNSOU:CONDMOD:GRAPH_TE';	//	Target Editor Subscreen	insert ':SYNSOU:CONDMOD:GRAPH_OT';	//	Optimal Tempo Graph Subscreen	insert ':SYNSOU:CONDMOD:GRAPH_CF';	//	Curve Fit Graph Subscreen//	insert ':SYNSOU:CONDMOD:GRAPH_ME';	//	Meter Chart Subscreen//	Curve fit routines	insert ':SYNSOU:CONDMOD:FIT_SPLN';	//	spline_fit()	insert ':SYNSOU:CONDMOD:FIT_LSQR';	//	least_squares_fit()//	insert ':SYNSOU:CONDMOD:FIT_LSEG';	//	line_segment_fit()//	Command execution drivers and subscreen definition routines	insert ':SYNSOU:CONDMOD:SCRNDEFS';	//	definitions of each subscreen/*иииииииииииииииииии  P U B L I C   V A R I A B L E S  иииииииииииииииииии*//*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	Driver for Conductor ScreenCONDUCTOR.SCREEN: proc (arg) public swapable;	dcl arg		fixed;	//	argument - pass 0 for now	dcl event	fixed;	//	code returned by get.next.screen.event()	dcl label	(7)	fixed;	//	14 character dynamic string to pass to screen manager label routines	dcl cell		(1)	fixed;	//	column, row array for map.graphics.button.table.mouse.press()	//	print.ccat();	//	print current catalog name	//	cpos(0,0);		//	position cursor at row 0:column 0   clear.term();   initialize.screen.manager(trd.len);	//	note: this calls sample.syncl.smgr.globals()	//	Define obj#infolabel here (this will remain for all subscreens)	define.label(obj#infolabel,23,0,20,'');	set.object.attr(obj#infolabel,1,Attr#NoReverse);			//	we don't want highlighted text when selected	set.object.action(obj#infolabel,O#Act.Update.On.Dep,1);	//	so progress reports won't wait until the next call to get.next.screen.event()	set.object.mouse.access(obj#infolabel,0);						//	don't allow the mouse to select this label	//	Define subscreen selection button panel here (this will remain for all subscreens)	//	A note about coordinates passed to define.graphics.button.table():	//	For cosmetic reasons we will want the resultant non-inclusive pixel height to be an integer multiple of	//	the number of rows, and the resultant non-inclusive pixel width to be an integer multiple of the number	//	of columns.  Otherwise the last row or column will have more pixels than the others and the highlight	//	will not fill the button as expected, leaving an unsightly gap.	//	Use the following formulas to determine the values to pass: 	//	passed_height = round(desired_pixel_height*10/3)	//	passed_width = round(desired_pixel_width*25/3)	define.graphics.button.table(obj#subscreen_select,		((82-10)*100)+42,	//	x upper left	resultant pixel = round(7242*3/25)+23				= 892		(0-1)*100,			//	y upper left	resultant pixel = round((2300-(-100))*3/10)+42	= 762		((82-0)*100)+42,	//	x lower right	resultant pixel = round(8242*3/25)+23				= 1012		((0-1)*100)+293,	//	y lower right	resultant pixel = round((2300-193)*3/10)+42		= 674								//	resultant_pixel_width = 1012-892 = 120	(one column, so doesn't matter)								//	resultant_pixel_height = 762-674 = 88	(88 is an integer multiple of 4, i.e., 22 pixels per row)		1,4,O#GBTab.Divide);	//	For now, only allow mouse clicks to trigger activity on the subscreen selection button panel	//	set.object.get(obj#subscreen_select,get#mouse.button,1);	copy.string('Target Editor',label); deposit.graphics.button.table.label(obj#subscreen_select,target_editor,0,1,label,'');	copy.string('Optimal Tempo',label); deposit.graphics.button.table.label(obj#subscreen_select,optimal_tempo,0,1,label,'');	copy.string('Curve Fit'		,label); deposit.graphics.button.table.label(obj#subscreen_select,curve_fit	 ,0,1,label,'');	copy.string('Meter Chart'	,label); deposit.graphics.button.table.label(obj#subscreen_select,meter_chart	 ,0,1,label,'');	draw.gbox.around.object(obj#subscreen_select,O#GStr.Draw,0,0,0);	//	initialize with the target editor subscreen selected	subscreen = target_editor;	highlight.graphics.button.table.entry(obj#subscreen_select,0,subscreen,1,2,0);	//	highlight target editor button	init_target_editor();	//	note: this calls activate.screen()	//	Clear these flags before loop	exit.my.screen	= false;	goto.this.screen = 0;	while (exit.my.screen == false) {	//	Wait for exit condition		save.cursor();		//	for now		get_enable (get.screen.event);		get_enable (get.program.exit);		get_enable (get.in.char);		get_enable (get.new.seq.info);		get_enable (get.ertyp);		event = get.next.screen.event();	//	Get event		get_disable(get.screen.event);		get_disable(get.program.exit);		get_disable(get.in.char);		get_disable(get.new.seq.info);		get_disable(get.ertyp);		restore.cursor();	//	for now		if (event != get.null.event) {			//	first check for events common to all subscreens			if			(event == get.program.exit) exit.my.screen = true;			else if	(event == get.ertyp) {				save.cursor();				Handle.System.Error.Codes(next.event.info);				restore.cursor();			}			//	if we have activity on the subscreen selection button table...			else if ((event == get.screen.event) && (screen.event.id == obj#subscreen_select)) {				if (screen.event.info == S#MouseSelect) {					map.graphics.button.table.mouse.press(obj#subscreen_select,cell);					if (cell(1) != subscreen) {	//	do nothing if the selected subscreen is already current						highlight.graphics.button.table.entry(obj#subscreen_select,0,subscreen,0,2,0);	//	unhighlight old selection						subscreen = cell(1);						highlight.graphics.button.table.entry(obj#subscreen_select,0,subscreen,1,2,0);	//	highlight new selection						//	erase and undefine everything associated with the previous subscreen						select.new.cur.obj(obj#infolabel,0,0);						erase.object.range(obj#graph,#highest.object.id);						undefine.object.range(obj#graph,#highest.object.id);						// create the new subscreen						do case subscreen;							init_target_editor();	//	CASE 0: Target Editor Subscreen							init_optimal_tempo();	//	CASE 1: Optimal Tempo Graph Subscreen							init_curve_fit();			//	CASE 2: Curve Fit Graph Subscreen							init_meter_chart();		//	CASE 3: Meter Chart Subscreen						end;					}				}			}	//	end of activity on the subscreen selection button table			//	otherwise pass the event on to the current subscreen			else do case subscreen;				process_te_events();	//	CASE 0: Target Editor Subscreen				process_ot_events();	//	CASE 1: Optimal Tempo Graph Subscreen				process_cf_events();	//	CASE 2: Curve Fit Graph Subscreen				process_mc_events();	//	CASE 3: Meter Chart Subscreen			end;			//	screen.event.code = get.null.event;		}	//	end of if (event != get.null.event)	}		//	of wait for exit condition	if (CFit.Map.Ptr != null) erase_cfit_map();	//	During development: guard against accidentally leaving the cfit map in a sequence	exit.my.screen	= false;	//	Clear flag after loop	return goto.this.screen;end CONDUCTOR.SCREEN;end condmod;