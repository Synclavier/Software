/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: FIT_SPLNPATH:		 :SYNSOU:CONDMOD:FIT_SPLNCONTAINS: SOURCE CODE FOR THE PROCEDURE "spline_fit"REVISION HISTORY:00	1998/09/07	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*This file contains the procedure spline_fit which generates a tempo map that splines through allof the points defined by the cue times and the target beats in the curve fit map data structure.In order to maintain absolute precision during the Gaussian elimination process, all values aremaintained as ratios of APVs (integers which can grow to ludicrous proportions).The following may help avoid some confusion: Although the graph plots cue times on the x-axisand targets beats on the y-axis, the spline formula used here inputs target beats as x valuesand cue times as y-values.DEVELOPMENT DETAILS THAT WILL HAVE TO BE DEALT WITH:	The conversions between whole video fields and real time in microseconds will have to take the SMPTE mode into account.	For now, the procedure assumes 29.97 Drop Frame.	If the SMPTE mode is changed, then the cfit map becomes meaningless.  Consequently when the map is created, the current	SMPTE mode should be stored in the first record of the map (which is null).  Then only allow curve fit operations to be	performed if the current SMPTE mode matches (or perhaps just warn the user?)	When the APVs become NAH.COLLECT compliant, the smpte APVs should be initialized when entering the screen (rather than	in this and other curve fit procedures) and automatically updated when changed by the user.  They should be recycled when leaving the screen.	The thing that recalls sequences needs to set up the cfit variables (and Apv.Map.Ptr when that exists)	Much of the processing time is probably consumed by the calls to apv_reduce.	Try commenting these out and measuring the difference	There are still very few error checks in place after calls to apv procedures	Change the debug output to a message on row 23 with each subsequent message covering up the previous.	Also combine "forward elimination" and "backward substitution" into a single message "preparing XX%"	and change dots after processing beats to percentage.	------------------------------------time_numerator =+ 6 * p_den(i  ) * p_den(i+1) * (y(i  )*(x(i+1) - xx) + y(i+1)*(xx - x(i  )))-(xx - x(i  )) * (x(i+1) - xx) *(	+	p_num(i  ) * p_den(i+1) * ((x(i+1) - xx) + (x(i+1) - x(i  )))	+ 	p_num(i+1) * p_den(i  ) * ((xx - x(i  )) + (x(i+1) - x(i  ))))----time_denominator =6 * p_den(i  ) * p_den(i+1) * (x(i+1) - x(i  ))------------------------------------tempo_numerator =+ 6 * p_den(i  ) * p_den(i+1) * (y(i+1) - y(i  ))- p_num(i  ) * p_den(i+1) * (3*(x(i+1) - xx)^2 - (x(i+1) - x(i  ))^2)+p_num(i+1) * p_den(i  ) * (3*(xx - x(i  ))^2 - (x(i+1) - x(i  ))^2)----tempo_denominator =6 * p_den(i  ) * p_den(i+1) * (x(i+1) - x(i  ))*//*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE spline_fit															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/spline_fit: proc swapable;	dcl smpte.time							(4)	fixed;	dcl final_beat32						(1)	fixed;	//	SEQUENCE TIME IN MILLISECONDS OF THE FINAL BEAT OF THE SPLINE	dcl (this_beat32	,next_beat32 )	(1)	fixed;	//	SEQUENCE TIMES IN MILLISECONDS OF ADJACENT BEATS IN THE SPLINE	dcl (this_time32	,next_time32 )	(1)	fixed;	//	REAL TIMES IN MICROSECONDS OF ADJACENT BEATS IN THE SPLINE	dcl (prior_tempo32,this_tempo32)	(1)	fixed;	//	REAL DURATIONS IN MICROSECONDS OF ADJACENT BEAT SEGMENTS	dcl (old_offset32,new_offset32)	(1)	fixed;	//	REAL TIMES OF THE FIRST CUE UNDER THE OLD MAP, AND THE FIRST TARGET UNDER THE NEW MAP																	//	(USED TO OFFSET THE CUE TRACK AND THE SMPTE AFTER THE NEW MAP IS GENERATED)	dcl temp_array			lit 'next_beat32';	dcl first_target32	lit 'new_offset32';	//	Note: All static pointers are referenced by the subprocedures compute_microsecond_time() and compute_instantaneous_tempo()	//	POINTER TO APV HOLDING THE VALUE OF "beat32"	dcl xx_ptr	pointer static;	//	used only by the subprocedures compute_microsecond_time() and compute_instantaneous_tempo()	//	THESE WILL POINT TO AUXILLIARY APVs FOR HOLDING INTERIM VALUES	//	used only by the subprocedures compute_microsecond_time() and compute_instantaneous_tempo()	dcl length_total_ptr	lit 'aux3_ptr';	dcl length_done_ptr	lit 'aux4_ptr';	dcl length_to_go_ptr	lit 'aux5_ptr';		//	INTERNAL POINTERS TO APV ARRAYS HOLDING POINTERS TO OTHER APVs	dcl (u,d_num,d_den,w_num,w_den)		pointer;	//	Used only in Step 3 to compute p_num(i) AND p_den(i) values	dcl (p_num,p_den)							pointer static;		/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	/*																							*/	/*		SUBPROCEDURE compute_microsecond_time									*/	/*																							*/	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	//	Returns the microsecond real time corresponding to the passed sequence time	//	using the precalculated p_num(i)/p_den(i) apv ratios.	compute_microsecond_time: proc (beat32,time32);		dcl (beat32,time32)	fixed array;		apv_input_u32(xx_ptr,beat32);	//	all subsequent calculations need the input beat time represented as an apv		//	иииииииииииии DETERMINE WHICH SPLINE SEGMENT CONTAINS THE CURRENT BEAT иииииииииииииииииииииии		i = cfit_target_to_record#(beat32);	//	get the record number of the segment containing this beat		//	if this beat is at or after the end point of the spline, then we must place the beat using the		//	formula of the final spline segment.		if (i == n) i = i-1;		//	We need to subtract 1 to get the index for all subsequent calculations.  HOWEVER, in case we have		//	an initial target on a subdivision of a beat, then the first beat of the spline occurs prior to the		//	first spline segment.  So we must check for this condition and adjust so that the first beat will 		//	be placed using the formula of the first spline segment.		if (i != 0) i = i-1;		//	иииииииииииии PRECOMPUTE THE VALUES THAT WILL BE USED REPEATEDLY иииииииииииииииииииииииииииии		tmp1_ptr = apv_get_word(x,i  );		tmp2_ptr = apv_get_word(x,i+1);		//	Put (x(i+1) - x(i)) in the apv pointed to by length_total_ptr		apv_addsub(tmp2_ptr,tmp1_ptr,length_total_ptr,#subtract);		//	Put (x(i+1) - xx  ) in the apv pointed to by length_to_go_ptr		apv_addsub(tmp2_ptr,xx_ptr  ,length_to_go_ptr,#subtract);		//	Put (xx     - x(i)) in the apv pointed to by length_done_ptr		apv_addsub(xx_ptr  ,tmp1_ptr,length_done_ptr ,#subtract);		//	Put (6 * p_den(i) * p_den(i+1)) in the apv pointed to by pre_ptr		tmp1_ptr = apv_get_word(p_den,i  );		tmp2_ptr = apv_get_word(p_den,i+1);		apv_assign(aux_ptr,6);		apv_multiply(tmp1_ptr,tmp2_ptr,pre_ptr);		apv_multiply(aux_ptr,pre_ptr,pre_ptr);		//	иииииииииииии COMPUTE THE NUMERATOR ииииииииииииииииииииииииииииииииииииииииииииииииииииииииии		//	numerator =		//		(6 * p_den(i  ) * p_den(i+1) * (y(i  )*(x(i+1) - xx) + y(i+1)*(xx - x(i  )))) -		//		((xx - x(i  )) * (x(i+1) - xx) *		//		 ((p_num(i  ) * p_den(i+1) * ((x(i+1) - xx) + (x(i+1) - x(i  )))) +		//		  (p_num(i+1) * p_den(i  ) * ((xx - x(i  )) + (x(i+1) - x(i  ))))		//		 )		//		)		//	What a verbose mess!  If only XPL had operator overloading like C++		//	build first term		apv_multiply(apv_get_word(y,i  ),length_to_go_ptr,aux1_ptr);	//	aux1 = y(i  )*(x(i+1) - xx)		apv_multiply(apv_get_word(y,i+1),length_done_ptr ,aux2_ptr);	//	aux2 =								y(i+1)*(xx - x(i  ))		apv_addsub(aux1_ptr,aux2_ptr,aux_ptr,#add);							//	aux  = y(i  )*(x(i+1) - xx) + y(i+1)*(xx - x(i  ))		apv_multiply(pre_ptr,aux_ptr,aux_ptr);									//	aux  now holds the completed first term of the numerator		//	build second term		apv_addsub(length_to_go_ptr,length_total_ptr,aux1_ptr,#add);	//	aux1 =									 (x(i+1) - xx) + (x(i+1) - x(i  ))		apv_multiply(tmp2_ptr,aux1_ptr,aux1_ptr);								//	aux1 =				  p_den(i+1) * ((x(i+1) - xx) + (x(i+1) - x(i  )))		apv_multiply(apv_get_word(p_num,i  ),aux1_ptr,aux1_ptr);			//	aux1 = p_num(i  ) * p_den(i+1) * ((x(i+1) - xx) + (x(i+1) - x(i  )))		apv_addsub(length_done_ptr ,length_total_ptr,aux2_ptr,#add);	//	aux2 =									 (xx - x(i  )) + (x(i+1) - x(i  ))		apv_multiply(tmp1_ptr,aux2_ptr,aux2_ptr);								//	aux2 =				  p_den(i  ) * ((xx - x(i  )) + (x(i+1) - x(i  )))		apv_multiply(apv_get_word(p_num,i+1),aux2_ptr,aux2_ptr);			//	aux2 = p_num(i+1) * p_den(i  ) * ((xx - x(i  )) + (x(i+1) - x(i  )))		apv_addsub(aux1_ptr,aux2_ptr,aux2_ptr,#add);		apv_multiply(length_to_go_ptr,aux2_ptr,aux2_ptr);		apv_multiply(length_done_ptr ,aux2_ptr,aux2_ptr);					//	aux2 now holds the completed second term of the numerator		//	combine terms		apv_addsub(aux_ptr,aux2_ptr,num_ptr,#subtract);						//	num  now holds the completed numerator		//	иииииииииииии COMPUTE THE DENOMINATOR ииииииииииииииииииииииииииииииииииииииииииииииииииииииии		//	denominator = 6 * p_den(i  ) * p_den(i+1) * (x(i+1) - x(i  ))		apv_multiply(pre_ptr,length_total_ptr,den_ptr);						//	den  now holds the completed denominator		apv_reduce(num_ptr,den_ptr);		//	convert final ratio from video fields to microseconds		apv_multiply(num_ptr,smpte_num_ptr,num_ptr);		apv_multiply(den_ptr,smpte_den_ptr,den_ptr);		apv_quotient(num_ptr,den_ptr,aux_ptr,true);		apv_output_u32(aux_ptr,time32);	//	for debugging, check for sign error after this		add16(zero.time*1000,time32);		//	don't forget to add zero.time back in	end compute_microsecond_time;	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	/*																							*/	/*		SUBPROCEDURE compute_instantaneous_tempo								*/	/*																							*/	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	//	Returns the instantaneous tempo (in microseconds per beat) at the passed sequence time	//	using the precalculated p_num(i)/p_den(i) ratios.	//	Note that for nonconstant tempos, the instantaneous tempo is not the same	//	as the tempo in the tempo map (which is an average tempo over an interval).	compute_instantaneous_tempo: proc (beat32,tempo32);		dcl (beat32,tempo32)	fixed array;		apv_input_u32(xx_ptr,beat32);	//	all subsequent calculations need the input beat time represented as an apv		//	иииииииииииии DETERMINE WHICH SPLINE SEGMENT CONTAINS THE CURRENT BEAT иииииииииииииииииииииии		i = cfit_target_to_record#(beat32);	//	get the record number of the segment containing this beat		//	if this beat is at or after the end point of the spline, then we must calculate the tempo using		//	the formula of the final spline segment.		if (i == n) i = i-1;		//	We need to subtract 1 to get the index for all subsequent calculations.  HOWEVER, in case we have		//	an initial target on a subdivision of a beat, then the first beat of the spline occurs prior to the		//	first spline segment.  So we must check for this condition and adjust so that the tempo at the first		//	beat will be placed using the formula of the first spline segment.		if (i != 0) i = i-1;		//	иииииииииииии PRECOMPUTE THE VALUES THAT WILL BE USED REPEATEDLY иииииииииииииииииииииииииииии		tmp1_ptr = apv_get_word(x,i  );		tmp2_ptr = apv_get_word(x,i+1);		//	Put (x(i+1) - x(i)) in the apv pointed to by length_total_ptr		apv_addsub(tmp2_ptr,tmp1_ptr,length_total_ptr,#subtract);		//	Put (x(i+1) - xx  ) in the apv pointed to by length_to_go_ptr		apv_addsub(tmp2_ptr,xx_ptr  ,length_to_go_ptr,#subtract);		//	Put (xx     - x(i)) in the apv pointed to by length_done_ptr		apv_addsub(xx_ptr  ,tmp1_ptr,length_done_ptr ,#subtract);		//	Put (6 * p_den(i) * p_den(i+1)) in the apv pointed to by pre_ptr		tmp1_ptr = apv_get_word(p_den,i  );		tmp2_ptr = apv_get_word(p_den,i+1);		apv_assign(aux_ptr,6);		apv_multiply(tmp1_ptr,tmp2_ptr,pre_ptr);		apv_multiply(aux_ptr,pre_ptr,pre_ptr);		//	Needed only for second and third terms...		apv_assign(num_ptr,3);												//	temporarily put 3 in the apv pointed to by num_ptr		apv_multiply(length_total_ptr,length_total_ptr,den_ptr);	//	temporarily put (x(i+1) - x(i  ))^2 in the apv pointed to by den_ptr		//	иииииииииииии COMPUTE THE NUMERATOR ииииииииииииииииииииииииииииииииииииииииииииииииииииииииии		//	numerator =		//		(6 * p_den(i  ) * p_den(i+1) * (y(i+1) - y(i  ))) - 		//		(p_num(i  ) * p_den(i+1) * (3*(x(i+1) - xx)^2 - (x(i+1) - x(i  ))^2)) +		//		(p_num(i+1) * p_den(i  ) * (3*(xx - x(i  ))^2 - (x(i+1) - x(i  ))^2))		//	build the first term		apv_addsub(apv_get_word(y,i+1),apv_get_word(y,i  ),aux_ptr,#subtract);	//	aux = y(i+1) - y(i  )		apv_multiply(pre_ptr,aux_ptr,aux_ptr);								//	aux  now holds the completed first term of the numerator		//	build the second term		apv_multiply(length_to_go_ptr,length_to_go_ptr,aux1_ptr);	//	aux1 =										(x(i+1) - xx)^2		apv_multiply(num_ptr,aux1_ptr,aux1_ptr);							//	aux1 =									 3*(x(i+1) - xx)^2		apv_addsub(aux1_ptr,den_ptr,aux1_ptr,#subtract);				//	aux1 =									 3*(x(i+1) - xx)^2 - (x(i+1) - x(i  ))^2		apv_multiply(tmp2_ptr,aux1_ptr,aux1_ptr);							//	aux1 =				  p_den(i+1) * (3*(x(i+1) - xx)^2 - (x(i+1) - x(i  ))^2)		apv_multiply(apv_get_word(p_num,i  ),aux1_ptr,aux1_ptr);		//	aux1 = p_num(i  ) * p_den(i+1) * (3*(x(i+1) - xx)^2 - (x(i+1) - x(i  ))^2)		//	build the third term		apv_multiply(length_done_ptr,length_done_ptr,aux2_ptr);		//	aux2 =										(xx - x(i  ))^2		apv_multiply(num_ptr,aux2_ptr,aux2_ptr);							//	aux2 =									 3*(xx - x(i  ))^2		apv_addsub(aux2_ptr,den_ptr,aux2_ptr,#subtract);				//	aux2 =									 3*(xx - x(i  ))^2 - (x(i+1) - x(i  ))^2		apv_multiply(tmp1_ptr,aux2_ptr,aux2_ptr);							//	aux2 =				  p_den(i  ) * (3*(xx - x(i  ))^2 - (x(i+1) - x(i  ))^2)		apv_multiply(apv_get_word(p_num,i+1),aux2_ptr,aux2_ptr);		//	aux2 = p_num(i+1) * p_den(i  ) * (3*(xx - x(i  ))^2 - (x(i+1) - x(i  ))^2)		//	combine terms		apv_addsub(aux2_ptr,aux1_ptr,num_ptr,#subtract);				//	num  now holds + second term - first term		apv_addsub(aux_ptr,num_ptr,num_ptr,#add);							//	num  now holds the completed numerator		//	иииииииииииии COMPUTE THE DENOMINATOR ииииииииииииииииииииииииииииииииииииииииииииииииииииииии		//	denominator = 6 * p_den(i  ) * p_den(i+1) * (x(i+1) - x(i  ))		apv_multiply(pre_ptr,length_total_ptr,den_ptr);					//	den  now holds the completed denominator		apv_reduce(num_ptr,den_ptr);		//	convert final ratio from video fields per sequence millisecond to real microseconds per samp.click.rate sequence milliseconds		apv_assign(aux_ptr,samp.click.rate);		apv_multiply(num_ptr,aux_ptr,num_ptr);		apv_multiply(num_ptr,smpte_num_ptr,num_ptr);		apv_multiply(den_ptr,smpte_den_ptr,den_ptr);		apv_quotient(num_ptr,den_ptr,aux_ptr,true);		apv_output_u32(aux_ptr,tempo32);	//	for debugging, check for sign error after this	end compute_instantaneous_tempo;	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	/*																							*/	/*		SUBPROCEDURE recycle_all_apvs												*/	/*																							*/	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	//	This procedure recycles all the apvs still allocated after the completion of step 3.	//	This is provided to simplify exiting this procedure from the multitude of places	//	where an error may occur.	recycle_all_apvs: proc;		//	RECYCLE REMAINING APVs		do i = 0 to n-1;			apv_recycle(apv_get_word(x,i));			apv_recycle(apv_get_word(y,i));			apv_recycle(apv_get_word(p_num,i));			apv_recycle(apv_get_word(p_den,i));		end;		apv_recycle(x);		apv_recycle(y);		apv_recycle(p_num);		apv_recycle(p_den);		apv_recycle(aux_ptr);		apv_recycle(pre_ptr);		apv_recycle(xx_ptr);		apv_recycle(length_total_ptr);		apv_recycle(length_done_ptr);		apv_recycle(length_to_go_ptr);		apv_recycle(aux1_ptr);		apv_recycle(aux2_ptr);		apv_recycle(num_ptr);		apv_recycle(den_ptr);		apv_recycle(smpte_num_ptr);		apv_recycle(smpte_den_ptr);	end recycle_all_apvs;	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/	/*																							*/	/*		SUBPROCEDURE f																	*/	/*																							*/	/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/		//	Computes the number of sectors needed to list n pointers in an apv array	f: proc (num_cues) returns (fixed);		dcl num_cues	fixed;		//	Note: The logic here will have to be updated when the APV data structure is		//	modified to survive a call to "NAH.COLLECT".		//	The logic should be equivalent to that used by apv_get_word and apv_put_word		//	for finding the node containing a given word.		//	dcl num_sectors	fixed;		//	num_sectors = 1;			//	we'll always need at least one		//	num_cues = num_cues+1;	//	include in the word used to hold the wordlength		//	while (num_cues igt 255) {		//		num_sectors = num_sectors+1;		//		num_cues = num_cues-255;		//	}		//	return num_sectors;				load num_cues+1;	//	include in the word used to hold the wordlength		div 255;		return res+(rem != 0);	end;	//	ииииииииииииииииииии   M A I N   P R O C E D U R E   S T A R T S   H E R E   ииииииииииииииииииии	if (CFit.Map.Ptr == null) return;		//	nothing to do	stop.recd.move.play.xpos.cont.eras();	//	stop any performance	//	ииииииииииииииии STEP 1: DETERMINE IF WE HAVE SUFFICIENT MEMORY иииииииииииииииииииииииииииииииии	//	We can ascertain algebraically how many APVs will need to be allocated based on the number of cues	//	to process.  The formula is:	//	4(f(n) + f(n-2)) + f(n-1) + 9n - 5	//	where f(n) = the number of sectors needed to list n pointers in an apv array.	//	By disabling interrupts, then checking the available sectors in the nah.area, we can ensure that	//	we'll be able to allocate all APVs needed provided that we do so before reenabling the interrupts.	//	Note that this will not ensure the availability of additional nodes which may be needed to increase	//	apv lengths during subsequent calculations (only likely to happen if we are processing hundreds of	//	cues), so ertyp checks and escape routes will have to be programmed where such calculations take place. 	//	get the number of cues	n = get_final_cfit_cue_info(temp_array);	//	Special Case: If there is only 1 cue, then we have nothing to calculate tempos with.  Just insert/delete	//	the necessary time at/from the beginning of the sequence (and alter the SMPTE offset accordingly) such that	//	the sequence travel path at the current tempo intersects the (target,cue) point.//	if (n == 1) {	if (n ilt 1) {		//	*** CURRENTLY NOT IMPLEMENTED ***		print 'fuggit';	//	For now		return;		//	THIS NEEDS TO BE CHECKED!		//	THIS PROCEDURE MAY ACTUALLY ACCOMPLISH THE DESIRED RESULT FOR (n == 1), OR IT MAY BLOW UP.		//	ALSO CHECK TO MAKE SURE NOTHING BLOWS UP FOR (n == 2) AND (n == 3).	}	disable;	if ((4*(f(n) + f(n-2)) + f(n-1) + 9*n - 5) igt (inf.ptr - nah.ptr - nah.len + nah.#free)) {		ertyp = err.oom;		enable;		return;	}	//	ииииииииииииииии STEP 2: ALLOCATE APVs AND SET UP INITIAL VALUES ииииииииииииииииииииииииииииииии	//	ALLOCATE AUXILIARY APVs	aux_ptr			= apv_allocate_node;	pre_ptr			= apv_allocate_node;	smpte_num_ptr	= apv_allocate_node;	smpte_den_ptr	= apv_allocate_node;	//	ALLOCATE APV POINTER ARRAYS	x		= apv_allocate_node;	y		= apv_allocate_node;	p_num = apv_allocate_node;	p_den = apv_allocate_node;	u		= apv_allocate_node;	d_num = apv_allocate_node;	d_den = apv_allocate_node;	w_num = apv_allocate_node;	w_den = apv_allocate_node;	//	INITIALIZE SMPTE CONSTANTS	 (This needs a DO CASE to handle the different SMPTE modes.)	load 50000; mul 1000;	apv_put_word(smpte_num_ptr,0,res);	apv_put_word(smpte_num_ptr,1,ures);	apv_assign(smpte_den_ptr,2997);	//	INITIALIZE APV POINTER ARRAYS AND APV VALUES	//	NOTE: SINCE "apv_allocate_node" LEAVES IT'S RETURNED POINTER IN REGISTER 13, A VALUE CAN	//	IMMEDIATELY THEREAFTER BE ASSIGNED TO THE NEWLY ALLOCATED APV BY PASSING "read(reg_src|r13)"	//	AS THE POINTER IN A SUBSEQUENT CALL TO "apv_assign" OR "apv_input_u32".	reset_cfit_map();	//	point all cfit variables to the first record (which is null)	do i = 0 to n-1;		//	PLUG IN X AND Y VALUES FROM THE CURVE FIT MAP		get_next_cfit_pair(BitMsbArray,temp_array);		//	first convert cue time to whole video fields		if (bitlsb ilt zero.time) bitmsb = bitmsb-1;	//	borrow if necessary		bitlsb = bitlsb-zero.time;							//	remove zero time offset 		ratio_multiply(2997,50000);	//	(This needs a DO CASE to handle the different SMPTE modes.)		apv_put_word(x		,i,apv_allocate_node); apv_input_u32(read(reg_src|r13),temp_array);	//	target in x		apv_put_word(y		,i,apv_allocate_node); apv_input_u32(read(reg_src|r13),BitMsbArray);	//	converted cue in y		//	INITIALIZE p_num(i)/p_den(i) TO 0/1		apv_put_word(p_num,i,apv_allocate_node); //	0 AUTOMATICALLY ASSIGNED		apv_put_word(p_den,i,apv_allocate_node); apv_assign(read(reg_src|r13),1);	end;	do i = 0 to n-2;		apv_put_word(u,i,apv_allocate_node);		//	u(i) = x(i+1)-x(i)		apv_addsub(apv_get_word(x,i+1),apv_get_word(x,i),read(reg_src|r13),#subtract);	end;	//	Note: The following words are never utilized by the Gaussian elimination algorithm.	//	They are initialized here only to provide debug output consistent with Mathematica's.	//	apv_put_word(d_num,0,apv_allocate_node);	//	0 AUTOMATICALLY ASSIGNED	//	apv_put_word(d_den,0,apv_allocate_node); apv_assign(read(reg_src|r13),1);	//	apv_put_word(w_num,0,apv_allocate_node);	//	0 AUTOMATICALLY ASSIGNED	//	apv_put_word(w_den,0,apv_allocate_node); apv_assign(read(reg_src|r13),1);	do i = 1 to n-2;		//	d_num(i) = 2*(x(i+1)-x(i-1))		apv_put_word(d_num,i,apv_allocate_node);		num_ptr = read(reg_src|r13);	//	num_ptr = apv_get_word(d_num,i)		apv_addsub(apv_get_word(x,i+1),apv_get_word(x,i-1),read(reg_src|r13),#subtract);		apv_assign(aux_ptr,2);		apv_multiply(num_ptr,aux_ptr,num_ptr);		//	d_den(i) = 1		apv_put_word(d_den,i,apv_allocate_node); apv_assign(read(reg_src|r13),1);		//	w_num(i) = 6*( ( u(i-1) * (y(i+1)-y(i)) ) - ( u(i) * (y(i)-y(i-1)) ) )		apv_put_word(w_num,i,apv_allocate_node);		num_ptr = read(reg_src|r13);	//	num_ptr = apv_get_word(w_num,i);		apv_addsub(apv_get_word(y,i+1),apv_get_word(y,i),read(reg_src|r13),#subtract);		apv_multiply(num_ptr,apv_get_word(u,i-1),num_ptr);		apv_addsub(apv_get_word(y,i),apv_get_word(y,i-1),aux_ptr,#subtract);		apv_multiply(aux_ptr,apv_get_word(u,i),aux_ptr);		apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);		apv_assign(aux_ptr,6);		apv_multiply(num_ptr,aux_ptr,num_ptr);		//	w_den(i) = u(i)*u(i-1)		apv_put_word(w_den,i,apv_allocate_node);		den_ptr = read(reg_src|r13);	//	den_ptr = apv_get_word(w_den,i);		apv_multiply(apv_get_word(u,i),apv_get_word(u,i-1),den_ptr);		apv_reduce(num_ptr,den_ptr);	//	apv_reduce(apv_get_word(w_num,i),apv_get_word(w_den,i));	end;	enable;	//	we're done allocating APVs now, so allow the interrupt routines access to the nah area	//	ииииииииииииииии STEP 3: COMPUTE p_num(i) AND p_den(i) VALUES иииииииииииииииииииииииииииииииииии	//	For each point in the curve fit map, there is a p_num and p_den value.  These represent the	//	integer numerator and denominator of the second derivative of the sequence travel path (i.e.,	//	the rate of change of the tempo).  All subsequent calculations depend on these values.	//	PERFORM GAUSSIAN ELIMINATION OF SYMETRIC TRIDIAGONAL MATRIX	/*	------------------  FORWARD ELIMINATION PHASE  ------------------	*/	cpos(0,0);	//	this should be changed to put progress information on line 24	//	position cursor at row 0:column 0	ps('forward elimination phase ');	///////////////////////////////////////////////////////////	DEBUG	do i = 1 to n-3;		tmp1_ptr = apv_get_word(u    ,i);		tmp2_ptr = apv_get_word(d_num,i);		//	PRECOMPUTE THE FOLLOWING VALUE SINCE IT WILL BE USED TWICE		//		d_den(i) * u(i)		apv_multiply(apv_get_word(d_den,i),tmp1_ptr,pre_ptr);		num_ptr = apv_get_word(d_num,i+1);		den_ptr = apv_get_word(d_den,i+1);		//	d_num(i+1) = (d_num(i+1) * d_num(i)) - (d_den(i+1) * d_den(i) * u(i) * u(i))		apv_multiply(pre_ptr,tmp1_ptr,aux_ptr);		apv_multiply(aux_ptr,den_ptr,aux_ptr);		apv_multiply(num_ptr,tmp2_ptr,num_ptr);		apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);		//	d_den(i+1) = d_den(i+1) * d_num(i)		apv_multiply(den_ptr,tmp2_ptr,den_ptr);		apv_reduce(num_ptr,den_ptr);	//	apv_reduce(apv_get_word(d_num,i+1),apv_get_word(d_den,i+1));		num_ptr = apv_get_word(w_num,i+1);		den_ptr = apv_get_word(w_den,i+1);		//	w_num(i+1) = (w_num(i+1) * w_den(i) * d_num(i)) - (w_num(i) * w_den(i+1) * d_den(i) * u(i))		apv_multiply(apv_get_word(w_num,i),den_ptr,aux_ptr);		apv_multiply(aux_ptr,pre_ptr,aux_ptr);		//	PRECOMPUTE THE FOLLOWING VALUE SINCE IT WILL BE USED TWICE		//		w_den(i) * d_num(i)		apv_multiply(apv_get_word(w_den,i),tmp2_ptr,pre_ptr);		apv_multiply(num_ptr,pre_ptr,num_ptr);		apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);		//	w_den(i+1) = w_den(i+1) * w_den(i) * d_num(i)		apv_multiply(den_ptr,pre_ptr,den_ptr);		apv_reduce(num_ptr,den_ptr);	//	apv_reduce(apv_get_word(w_num,i+1),apv_get_word(w_den,i+1));		pc(a.period); interp_flush_char_output();	///////////////////////////////////////////////////////////	DEBUG	end;	/*	----------------   BACKWARD SUBSTITUTION PHASE   ----------------	*/	pcr(); ps('backward substitution phase ');	///////////////////////////////////////////////////////////	DEBUG	do i = n-2 to 1 by -1;		tmp1_ptr = apv_get_word(p_den,i+1);		tmp2_ptr = apv_get_word(w_den,i  );		num_ptr  = apv_get_word(p_num,i  );		den_ptr  = apv_get_word(p_den,i  );		//	p_num(i) = d_den(i) * ( (p_den(i+1) * w_num(i)) - (p_num(i+1) * w_den(i) * u(i)) )		apv_multiply(apv_get_word(p_num,i+1),tmp2_ptr,aux_ptr);		apv_multiply(aux_ptr,apv_get_word(u,i),aux_ptr);		apv_multiply(tmp1_ptr,apv_get_word(w_num,i),num_ptr);		apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);		apv_multiply(num_ptr,apv_get_word(d_den,i),num_ptr);		//	p_den(i) = p_den(i+1) * w_den(i) * d_num(i)		apv_multiply(tmp1_ptr,tmp2_ptr,den_ptr);		apv_multiply(den_ptr,apv_get_word(d_num,i),den_ptr);		apv_reduce(num_ptr,den_ptr);	//	apv_reduce(apv_get_word(p_num,i),apv_get_word(p_den,i));		pc(a.period); interp_flush_char_output();	///////////////////////////////////////////////////////////	DEBUG	end;	//	RECYCLE WORKING APVs USED FOR GAUSSIAN ELIMINATION	disable;	//	prevent interrupt code from nabbing any NLS blocks	do i = 0 to n-2;		apv_recycle(apv_get_word(u,i));	end;	do i = 1 to n-2;		apv_recycle(apv_get_word(d_num,i));		apv_recycle(apv_get_word(d_den,i));		apv_recycle(apv_get_word(w_num,i));		apv_recycle(apv_get_word(w_den,i));	end;	apv_recycle(u);	apv_recycle(d_num);	apv_recycle(d_den);	apv_recycle(w_num);	apv_recycle(w_den);	//	ALLOCATE APVs NEEDED TO COMPUTE SPLINED VALUES	//	Note: We know we will succeed at allocating the following five APVs since we just recycled	//	at the very least 9 apvs (for n == 1) with interrupts disabled.	//	Consequently we can dispense with all the ugly error checks and escape routes.	xx_ptr				= apv_allocate_node;	length_total_ptr	= apv_allocate_node;	length_done_ptr	= apv_allocate_node;	length_to_go_ptr	= apv_allocate_node;	aux1_ptr				= apv_allocate_node;	aux2_ptr				= apv_allocate_node;	num_ptr				= apv_allocate_node;	den_ptr				= apv_allocate_node;	enable;	//	back to biz	//	ииииииииииииииии STEP 4: SET UP INITIAL VALUES FOR THE LOOP IN STEP 7 иииииииииииииииииииииииииии	//	STEP 4.1: FIND THE FIRST AND FINAL BEAT IN THE SPLINE	//	Note: temp_array still contains the sequence time of the final target in the cfit map (from step 2).	copy32(temp_array,final_beat32);	//	Determine the final whole beat in the spline.  If (samp.crm != 1) this may not be the same as the final target.	sub16(zero.time,temp_array);	load temp_array(1); uload temp_array(0);	div samp.click.rate;	if (rem != 0) {		sub16(rem,final_beat32);		add16(samp.click.rate,final_beat32);	}	//	Now get the real time of the first cue and the sequence time of the first target from the cfit map	reset_cfit_map(); get_next_cfit_pair(old_offset32,first_target32);	copy32(first_target32,this_beat32);	//	Determine the first whole beat in the spline.  If (samp.crm != 1) this may not be the same as the first target.	copy32(first_target32,temp_array);	sub16(zero.time,temp_array);	load temp_array(1); uload temp_array(0);	div samp.click.rate;	sub16(rem,this_beat32);	//	STEP 4.2: INITIALIZE "this_time32" WITH THE MICROSECOND REAL TIME THE FIRST BEAT	compute_microsecond_time(this_beat32,this_time32);	//	STEP 4.3: INITIALIZE "prior_tempo32" WITH THE INSTANTANEOUS TEMPO AT THE FIRST BEAT	compute_instantaneous_tempo(this_beat32,prior_tempo32);	//	ииииииииииииииии STEP 5: CALCULATE INSTANTANEOUS TEMPOS AT THE CUE POINTS иииииииииииииииииииииии	//	ииииииииииииииииииииииии AND WRITE THEM INTO THE CURVE FIT MAP ииииииииииииииииииииииииииииииииии	//	These instantaneous tempos are not useful for generating the splined tempo map.  The reason	//	for writing them into the curve fit map is to allow future regional fits to match the	//	instantaneous tempo at the endpoints.	//	Note also that for nonconstant tempos, the instantaneous tempo is not the same as the tempo	//	in the tempo map (which is an average tempo over an interval).	//	*** CURRENTLY NOT IMPLEMENTED ***	//	ииииииииииииииии STEP 6: CONVERT THE DESIGNATED CUE TRACK TO REAL TIME ииииииииииииииииииииииииии	//	This is done so that after the tempo map is generated, these cue notes can then be converted	//	back to sequence time, the end result being that they will still occur at the same real time	//	as they did before the map was generated.	//	All other notes in the sequence will follow the new temo map.	modify.bounce(cond_track#,op#seq.to.real,temp_array);	//	Note: The contents of temp_array are irrelevant here	//	ииииииииииииииии STEP 7: GENERATE NEW TEMPO MAP иииииииииииииииииииииииииииииииииииииииииииииииии	//	TERRIBLE THINGS WILL HAPPEN if the following line is allowed to execute before the APV data structure is	//	updated to coexist peacefully with the NAH.COLLECT procedure.	/*	if (undo.enabled != false) save.undoseq();	//	set up for possible undo	*/	samp.click.rate = 480;	//	For compatibility with just about all other MIDI sequencers	//	If no maps are in use yet, start by creating defaults.  However, if a tempo map already exists,	//	it must first be nuked first.	if (Meter.Map.Ptr == null)	Create.Default.Meter.Map();	if (Tempo.Map.Ptr != null)	Erase.Tempo.Map.Info();	Create.Default.Tempo.Map();	if ((Tempo.Map.Ptr|Meter.Map.Ptr) == null)	{	//	Bail if not enough memory for maps		recycle_all_apvs();		ertyp = err.oom;		return;	}	//	STEP 7.1: TEMPO SEGMENT BEFORE THE SPLINE	//	Set the tempo of the region prior to the first beat of the spline to match the instantaneous tempo at that beat.	//	Note: The rate of change of the tempo (0) will match as well.	Set.Tempo(zero.zerotime,prior_tempo32);	//	STEP 7.2: TEMPO SEGMENTS IN THE SPLINE	//	MAIN LOOP: STEP THROUGH EACH BEAT IN THE SPLINE	pcr(); psr('processing beats'); zilch = 0;	///////////////////////////////////////////////////////////	DEBUG	while (com32(this_beat32,final_beat32) != lw#ieq) {		copy32(this_beat32,next_beat32);		add16(samp.click.rate,next_beat32);		compute_microsecond_time(next_beat32,next_time32);		sub32(next_time32,this_time32,this_tempo32);		if (com32(this_tempo32,prior_tempo32) != lw#ieq) {	//	Only insert a tempo event if the tempo actually changed			Insert.Tempo.Record(this_beat32); Set.Tempo(this_beat32,this_tempo32);		}		//	prepare for the next iteration		copy32(next_beat32 ,this_beat32	);		copy32(next_time32 ,this_time32	);		copy32(this_tempo32,prior_tempo32);		pc(a.period); zilch = zilch+1; if (zilch == 64) {pcr(); zilch = 0;} interp_flush_char_output();	///////////////////////////////////////////////////////////	DEBUG	}	//	END OF MAIN LOOP: STEP THROUGH EACH BEAT IN THE SPLINE	//	STEP 7.3: TEMPO SEGMENT AFTER THE SPLINE	//	Set the tempo of the region beyond the final beat of the spline to match the instantaneous tempo at that beat.	//	Note: The rate of change of the tempo (0) will match as well.	compute_instantaneous_tempo(this_beat32,this_tempo32);	if (com32(this_tempo32,prior_tempo32) != lw#ieq) {	//	Only insert this tempo event if the tempo actually changed		Insert.Tempo.Record(this_beat32); Set.Tempo(this_beat32,this_tempo32);	}	//	ииииииииииииииии STEP 8: CLEAN UP иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	RECYCLE REMAINING APVs	recycle_all_apvs();	//	ииииииииииииииии STEP 9: SLIDE THE CUE TRACK AND UPDATE THE SMPTE OFFSET ииииииииииииииииииииииии	//	Since the segment(s) prior to the first beat in the spline received a new tempo, we must insert or delete some	//	time from the cue track to compensate.  (Note: This must be done before converting it back to sequence time.)	//	We must also adjust the SMPTE offset such that the first cue time (now matched by the first target beat) syncs	//	to the same SMPTE time as before the splined tempo map was generated.		//	Get the real time of the first target under the influence of this new tempo map	Map.Sequence.Time.To.Real.Time(first_target32,new_offset32);	n = com32(new_offset32,old_offset32);	if	(n != lw#ieq) {	//	(nothing to do if they're equal)		if	(n == lw#ilt) {			//	the new offset is less than the old one, so we need to delete time from the cue track			//	and add to the SMPTE start time to compensate			sub32(old_offset32,new_offset32,temp_array);	//	subtract new from old to get the absolute value of the difference			Delete.Time.From.Trk(cond_track#,0,zero.time,temp_array(0),temp_array(1));			add16(zero.time,temp_array);	//	we want this duration interpreted as an absolute time from zero		}		else {	//	(n == lw#igt) 			//	the new offset is greater than the old one, so we need to insert time into the cue track			//	and subtract from the SMPTE start time to compensate			sub32(new_offset32,old_offset32,temp_array);	//	subtract old from new to get the absolute value of the difference			Insert.Time.On.Trk(cond_track#,0,zero.time,temp_array(0),temp_array(1));			add16(zero.time,temp_array);	//	we want this duration interpreted as an absolute time from zero			neg32(temp_array);				//	negate so this time will be subtracted		}		msec.to.smpte(temp_array,cf#time,samp.speed,S$Smode,S$Soffset,smpte.time);		set.synclav.smpte.offset(smpte.time);		//	Note: The following will be achieved automatically since the new constants flag of new.seq.info has been set.		//	Sample.Syncl.Smgr.Globals();	//	let the screen manager know all about it	}	//	ииииииииииииииии STEP 10: CONVERT THE DESIGNATED CUE TRACK BACK TO SEQUENCE TIME ииииииииииииииии	modify.bounce(cond_track#,op#real.to.seq,temp_array);	//	Note: The contents of temp_array are irrelevant here	play.initialize();	//	Since a new tempo map was created	//	ииииииииииииииии STEP 11: UPDATE THE GRAPH ииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	The x-axis will remain the same but the sequence travel path and possibly the spacing of the	//	tick marks on the y-axis will change	//	Note: The following will be achieved automatically since the new constants flag of new.seq.info has been set.	//	erase_cfit_map();	//	since the real times of the cues have changed due to the new tempo prior to the spline	end spline_fit;/*To Do:	Check for occurrences of these...Note: The following procedures will return without completing their tasks if memory is not available.Consequently one should check if (ertyp != null) after each call.	apv_allocate_node	apv_duplicate	apv_put_word	apv_negate	apv_or	apv_word_shr	apv_word_shl	apv_shr	apv_shl	apv_output_s32	apv_addsub	apv_multiply	apv_quotient	apv_mod	apv_gcd	apv_reduce	apv_printNote: The following procedures also will return without completing their tasks if a division by zero error occurs.Consequently one should check if (ertyp != null) after each call.	apv_quotient	apv_mod	apv_gcd	apv_reduceNote: The following procedure will return without completing its task if a sign error or overflow error occurs.Consequently one should check if (ertyp != null) after each call.	apv_output_u32*/