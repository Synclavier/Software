/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: GRAPH_CFPATH:		 :SYNSOU:CONDMOD:GRAPH_CFCONTAINS: SOURCE CODE FOR THE CURVE FIT GRAPH SUBSCREENREVISION HISTORY:00	1999/10/27	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*This program plots a graph to help the user comprehend the effect of the variouscurve fitting methods used to generate tempo maps.*//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/dcl #cfgraph_origin_x	lit '(#graph_origin_x+12)';	//	add 12 pixels to accommodate the tick marks dcl #cfgraph_origin_y	lit '(#graph_origin_y+6)';		//	add 6 pixels to accommodate the tick marksdcl #cfgraph_size_x		lit '(#graph_size_x-12)';		//	compensate for the 12 pixels added to #graph_origin_xdcl #cfgraph_size_y		lit '(#graph_size_y-6)';		//	compensate for the 6 pixels added to #graph_origin_y/*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*/dcl cfgraph_x_lower(1) fixed;	//	Curve Fit Graph horizontal axis lower limit represented as 32-bit millisecond real timedcl cfgraph_x_upper(1) fixed;	//	Curve Fit Graph horizontal axis upper limit represented as 32-bit millisecond real timedcl cfgraph_x_range(1) fixed;	//	Curve Fit Graph horizontal axis range represented as 32-bit millisecond real durationdcl cfgraph_y_lower(2) fixed;	//	Curve Fit Graph vertical axis lower limit represented as beats(msw), beats(lsw), thousandthsdcl cfgraph_y_upper(2) fixed;	//	Curve Fit Graph vertical axis upper limit represented as beats(msw), beats(lsw), thousandthsdcl cfgraph_y_range(2) fixed;	//	Curve Fit Graph vertical axis range represented as 48-bit millibeat duration/*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE beats_to_millibeats												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Convert in place a 3 word array containing beats(msw), beats(lsw), thousands to 48-bit millibeatsbeats_to_millibeats: proc (mbeats) swapable;	dcl mbeats fixed array;	//	load mbeats(1);	uload mbeats(2);				//	Addend	mul 1000;	mbeats(2) = res;	write(reg_dst|r13) = ures;	// Hang on to the upper result (to be added into the next product)	load mbeats(0);	uload read(reg_src|r13);	//	Addend	mul 1000;	mbeats(1) = res;	mbeats(0) = ures;end beats_to_millibeats;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE ms_to_x_coord														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/ms_to_x_coord: proc (input_time32) returns (fixed) swapable;	dcl input_time32	fixed array;	//	input real time (not seq time)	dcl time32(1)		fixed;			//	For local copy of input	//	when mapping quantized values from one scale to another, many engineers incorrectly treat them as if they are	//	instantaneous values on a continous domain.  i.e.:	//	cfgraph_x_lower+round(#cfgraph_size_x*(input_time32-cfgraph_x_lower)/(cfgraph_x_upper-cfgraph_x_lower))	//	The "proper Don W. Smith way" to do it is:	//	cfgraph_x_lower+truncate((#cfgraph_size_x+1)*((2*(input_time32-cfgraph_x_lower))+1)/(2*(cfgraph_x_upper-cfgraph_x_lower+1)))	//	Get the duration between the input time and the time corresponding to the lower limit of the graph	sub32(input_time32,cfgraph_x_lower,time32);	//	First multiply this duration by #cfgraph_size_x	//	Note: Even with #cfgraph_size_x set to the maximum possible value of 1024, multiplying our input 32-bit time by it	//	will only cause 32-bit overflow if (time32 ige 4194304).  This corresponds to 1 hour, 9 minutes and 54.304 seconds	//	into the sequence.  Consequently, it's not terribly important to check for overflow conditions right now.	load time32(1);	mul #cfgraph_size_x;	time32(1) = res;	write(reg_dst|r13) = ures;	// Hang on to the upper result (to be added into the next product)	load time32(0);	uload read(reg_src|r13);	//	Addend	mul #cfgraph_size_x;	time32(0) = res;	if (ures != 0) ertyp = err.overflow;	//	Report 32-bit overflow	//	Now divide the scaled input time by the graph range	copy32(cfgraph_x_range,BitMsbArray);	//	Use BitMsbArray so as not to alter cfgraph_x_range	while (BitMsb != 0) {						//	Reduce until the dividend is 16-bit		//	To maintain maximum precision over multiple iterations, always round to the nearest even result		write(reg_dst|r13) = time32(1) & 1;	//	remember the discarded bit for possible rounding below		shr32(time32,1);		if ((read(reg_src|r13) != 0) && ((time32(1) & 1) != 0)) add16(1,time32);	//	only add in the discarded bit if the shifted result is odd				write(reg_dst|r13) = BitLsb & 1;		//	remember the discarded bit for possible rounding below		shr32(BitMsbArray,1);		if ((read(reg_src|r13) != 0) && ((BitLsb & 1) != 0)) add16(1,BitMsbArray);	//	only add in the discarded bit if the shifted result is odd	}	//	Perform the division	load time32(1); uload time32(0);	div BitLsb;	//	Since the remainder may exceed 32K, we can't shift it left but instead must round the goofy way	if ((BitLsb & 1) != 0)	write(reg_dst|r13) = (rem igt shr(BitLsb,1));	else							write(reg_dst|r13) = (rem ige shr(BitLsb,1));	return #cfgraph_origin_x + res + read(reg_src|r13);end ms_to_x_coord;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE ms_to_y_coord														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/ms_to_y_coord: proc (input_time32) returns (fixed) swapable;	dcl input_time32	fixed array;	//	input seq time (not real time)	dcl mbeats(2)		fixed;			//	array for millibeats	dcl temp48(2)		fixed;			//	array for local copy of cfgraph_y_range	dcl discarded_bit	fixed;	//	First map the input time to beats(msw), beats(lsw), thousandths	Map.Sequence.Time.To.Long.Beats(input_time32,mbeats);	// Get the duration between this and the beat corresponding to the lower limit of the graph	sub32(mbeats,cfgraph_y_lower,mbeats);		//	First deal only with the 32-bit whole beats part	mbeats(2) = mbeats(2)-cfgraph_y_lower(2);	//	Then subtract the thousandths	if (mbeats(2) < 0) {								//	and borrow if necessary		sub16(1,mbeats);	//	borrow 1 from the whole part		mbeats(2) = mbeats(2)+1000;	}	beats_to_millibeats(mbeats);	//	Convert this to 48-bit millibeats	//	Now multiply the millibeats by #cfgraph_size_y	//	Note: Even with #cfgraph_size_x set to the maximum possible value of 768, multiplying our 48-bit millibeats by it	//	will only cause overflow if there are 366503876 or more beats in the sequence.  Even at the fastest possible tempo	//	of 25 milliseconds per beat, this would take 106 days to accomplish.	load mbeats(2);	mul #cfgraph_size_y;	mbeats(2) = res;	write(reg_dst|r13) = ures;	// Hang on to the upper result (to be added into the next product)	load mbeats(1);	uload read(reg_src|r13);	//	Addend	mul #cfgraph_size_y;	mbeats(1) = res;	write(reg_dst|r13) = ures;	load mbeats(0);	uload read(reg_src|r13);	mul #cfgraph_size_y;	mbeats(0) = res;	//	Now divide the scaled millibeats by the graph's millibeat range	temp48(0) = cfgraph_y_range(0);			//	Make local copy	temp48(1) = cfgraph_y_range(1);	temp48(2) = cfgraph_y_range(2);	while ((temp48(1) != 0) || (temp48(0) != 0) || (mbeats(0) != 0)) {	//	Reduce until the divisor is 32 bit and the dividend is 16-bit		//	To maintain maximum precision over multiple iterations, always round to the nearest even result		discarded_bit = mbeats(2) & 1;		//	remember the discarded bit for possible rounding below		//	shr mbeats(2)		write(reg_dst|r13) = mbeats(1) & 1;	//	set up carry bit from the next higher word		if (read(reg_src|r13) != 0) write(reg_dst|r13) = "100000";		mbeats(2) = shr(mbeats(2),1) | read(reg_src|r13);		//	shr mbeats(1)		write(reg_dst|r13) = mbeats(0) & 1;	//	set up carry bit from the next higher word		if (read(reg_src|r13) != 0) write(reg_dst|r13) = "100000";		mbeats(1) = shr(mbeats(1),1) | read(reg_src|r13);		//	shr mbeats(0)		mbeats(0) = shr(mbeats(0),1);		//	round mbeats		if ((discarded_bit != 0) && ((mbeats(2) & 1) != 0)) {	//	only add in the discarded bit if the shifted result is odd			//	use D4567 for brainless 48-bit add			load mbeats(2); uload 1; mul 1;			mbeats(2) = res; write(reg_dst|r13) = ures;			load mbeats(1); uload read(reg_src|r13); mul 1;			mbeats(1) = res; write(reg_dst|r13) = ures;			load mbeats(0); uload read(reg_src|r13); mul 1;			mbeats(0) = res;		}				discarded_bit = temp48(2) & 1;		//	remember the discarded bit for possible rounding below		//	shr temp48(2)		write(reg_dst|r13) = temp48(1) & 1;	//	set up carry bit from the next higher word		if (read(reg_src|r13) != 0) write(reg_dst|r13) = "100000";		temp48(2) = shr(temp48(2),1) | read(reg_src|r13);		//	shr temp48(1)		write(reg_dst|r13) = temp48(0) & 1;	//	set up carry bit from the next higher word		if (read(reg_src|r13) != 0) write(reg_dst|r13) = "100000";		temp48(1) = shr(temp48(1),1) | read(reg_src|r13);		//	shr temp48(0)		temp48(0) = shr(temp48(0),1);		//	round temp48		if ((discarded_bit != 0) && ((temp48(2) & 1) != 0)) {	//	only add in the discarded bit if the shifted result is odd			//	use D4567 for brainless 48-bit add			load temp48(2); uload 1; mul 1;			temp48(2) = res; write(reg_dst|r13) = ures;			load temp48(1); uload read(reg_src|r13); mul 1;			temp48(1) = res; write(reg_dst|r13) = ures;			load temp48(0); uload read(reg_src|r13); mul 1;			temp48(0) = res;		}	}	//	Perform the division	load mbeats(2); uload mbeats(1);	div temp48(2);	//	Since the remainder may exceed 32K, we can't shift it left but instead must round the goofy way	if ((temp48(2) & 1) != 0)	write(reg_dst|r13) = (rem igt shr(temp48(2),1));	else								write(reg_dst|r13) = (rem ige shr(temp48(2),1));	return #cfgraph_origin_y + res + read(reg_src|r13);end ms_to_y_coord;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_update													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_update: proc swapable;	dcl (prior32,next32)	(1)	fixed;	dcl limit32				(1)	fixed;	//	temporarily holds sequence times of cfgraph_x_lower and cfgraph_x_upper	dcl (x_coord,y_coord)		fixed;	dcl smpte32		lit 'limit32';	dcl cue32		lit 'prior32';	dcl target32	lit 'next32';	enter.vector.mode();	//	erase the graph area, including the tick marks	area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);	//	the recent call to highlight.graphics.button.table.entry() left the data level at #pixels_off	data_level(#pixels_on);	//	ииииииииииpиlиoиtиииtиhиeиииxиииaиxиiиsииииииииии	move_to(#cfgraph_origin_x,#cfgraph_origin_y);	plot	 (#cfgraph_origin_x+#cfgraph_size_x,#cfgraph_origin_y);	//	ииииииииииpиlиoиtиииtиhиeиииyиииaиxиiиsииииииииии	move_to(#cfgraph_origin_x,#cfgraph_origin_y);	plot	 (#cfgraph_origin_x,#cfgraph_origin_y+#cfgraph_size_y);	//	PLOT MINOR TICK MARKS AT EACH BEAT	Map.Real.Time.To.Sequence.Time(cfgraph_x_lower,limit32);	Map.Sequence.Time.To.Nearest.Beats(limit32,prior32,next32);	//	In case cfgraph_x_lower is on an even beat, don't skip it	if (com32(prior32,limit32) == lw#ieq) copy32(prior32,next32);	Map.Real.Time.To.Sequence.Time(cfgraph_x_upper,limit32);	while (com32(next32,limit32) != lw#igt) {		y_coord = ms_to_y_coord(next32);		move_to(#cfgraph_origin_x-1,y_coord);		plot	 (#cfgraph_origin_x-4,y_coord);		Map.Sequence.Time.To.Nearest.Beats(next32,prior32,next32);	}	//	PLOT MAJOR TICK MARKS AT EACH MEASURE	<===	something isn't right here: the first tick is always major	Map.Real.Time.To.Sequence.Time(cfgraph_x_lower,limit32);	Map.Sequence.Time.To.Nearest.Measures(limit32,prior32,next32);	Map.Sequence.Time.To.Nearest.Beats(limit32,prior32,next32);	//	In case cfgraph_x_lower is on an even measure, don't skip it	if (com32(prior32,limit32) == lw#ieq) copy32(prior32,next32);	Map.Real.Time.To.Sequence.Time(cfgraph_x_upper,limit32);	while (com32(next32,limit32) != lw#igt) {		y_coord = ms_to_y_coord(next32);		move_to(#cfgraph_origin_x-5,y_coord);		plot	 (#cfgraph_origin_x-12,y_coord);		Map.Sequence.Time.To.Nearest.Measures(next32,prior32,next32);	}	//	ииииииpиlиoиtиииtиhиeиииgиrиaиpиhиииaиrиeиaииииии		if (CFit.Map.Ptr != null) {					msec.to.sbits(cfgraph_x_lower,cf#time,S$Speed,S$Smode,cue32);	//	convert to SMPTE bits					// add in smpte offset					smpte.to.sbits(S$SOffset,S$Smode,smpte32);					add32(cue32,smpte32,cue32);					//	convert to whole fields					//	divide upper word					load cue32(0); div 40;					cue32(0) = res;					write("313") = rem;				//	save remainder to use as upper word in division of lower word					//	divide lower word					load cue32(1); uload read("313"); div 40;					cue32(1) = res + (rem ige 20);	//	rounded result		locate_cfit_map(cue32);		get_next_cfit_pair(cue32,target32);		//	for first iteration		//	convert from whole fields to SMPTE bits		//	multiply lower word		load cue32(1); mul 40;		cue32(1) = res;		write(reg_dst|r13) = ures;	//	save overflow to use as addend in multiplication of upper word		//	multiply upper word		load cue32(0); uload read(reg_src|r13); mul 40;		cue32(0) = res;		//	subtract out SMPTE offset		sub32(cue32,smpte32,cue32);		// convert to real milliseconds		sbits.to.msec(cue32,cf#time,S$Speed,S$Smode,cue32);		while (com32(cue32,cfgraph_x_upper) == lw#ilt) {			x_coord = ms_to_x_coord(cue32);			y_coord = ms_to_y_coord(target32);			//	plot tick marks at the cue times on the x axis			move_to(x_coord,#cfgraph_origin_y-1);						//	start one pixel below the x axis			plot	 (x_coord,#cfgraph_origin_y-6);			//	plot vertical dotted lines at the cue times			line_type(#dotted);			move_to(x_coord,#cfgraph_origin_y+1					 );	//	start one pixel above the axis			plot	 (x_coord,#cfgraph_origin_y+#cfgraph_size_y);			//	plot horizontal dotted lines at the target beats			move_to(#cfgraph_origin_x+1				  ,y_coord);	//	start one pixel to the right of the axis			plot	 (#cfgraph_origin_x+#cfgraph_size_x,y_coord);			line_type(#solid);			//	plot solid crosses to highlight the intersections			move_to(x_coord  ,y_coord-6); plot(x_coord  ,y_coord+6);			move_to(x_coord-6,y_coord	); plot(x_coord+6,y_coord	);			get_next_cfit_pair(cue32,target32);	//	for next iteration			//	convert from whole fields to SMPTE bits			//	multiply lower word			load cue32(1); mul 40;			cue32(1) = res;			write(reg_dst|r13) = ures;	//	save overflow to use as addend in multiplication of upper word			//	multiply upper word			load cue32(0); uload read(reg_src|r13); mul 40;			cue32(0) = res;			//	subtract out SMPTE offset			sub32(cue32,smpte32,cue32);			// convert to real milliseconds			sbits.to.msec(cue32,cf#time,S$Speed,S$Smode,cue32);		}	}	//	plot the path that the sequence travels through this 2-dimensional beat-time space	move_to(#cfgraph_origin_x,#cfgraph_origin_y);	//	start the vector drawing sequence at the origin of the graph	if (Tempo.Map.Ptr != null) {		disable;	//	don't let a playing sequence mess with the tempo map variables until this is complete		locate_tempo_map(cfgraph_x_lower);		get_next_tempo_pair(cue32,target32);			//	for first iteration		while (com32(cue32,cfgraph_x_upper) == lw#ilt) {			plot(ms_to_x_coord(cue32),ms_to_y_coord(target32));			locate_tempo_map(cue32);						//	because the call to ms_to_y_coord indirectly alters the tempo map variables			get_next_tempo_pair(cue32,target32);		//	for next iteration		}		enable;	}	//	If the tempo is constant then the sequence simply travels the diagonal line	plot(#cfgraph_origin_x+#cfgraph_size_x,#cfgraph_origin_y+#cfgraph_size_y);	enter.transparent.mode();end cfgraph_update;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE map_to_millibeat_range											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/map_to_millibeat_range: proc swapable;	//	Map the upper and lower limit times to beats(msw), beats(lsw), thousandths	Map.Real.Time.To.Sequence.Time(cfgraph_x_lower,cfgraph_y_lower);	Map.Sequence.Time.To.Long.Beats(cfgraph_y_lower,cfgraph_y_lower);	Map.Real.Time.To.Sequence.Time(cfgraph_x_upper,cfgraph_y_upper);	Map.Sequence.Time.To.Long.Beats(cfgraph_y_upper,cfgraph_y_upper);	// Subtract to get the duration	sub32(cfgraph_y_upper,cfgraph_y_lower,cfgraph_y_range);		//	First deal only with the 32-bit whole beats part	cfgraph_y_range(2) = cfgraph_y_upper(2)-cfgraph_y_lower(2);	//	Then subtract the thousandths	if (cfgraph_y_range(2) < 0) {											//	and borrow if necessary		sub16(1,cfgraph_y_range);	//	borrow 1 from the whole part		cfgraph_y_range(2) = cfgraph_y_range(2)+1000;	}	beats_to_millibeats(cfgraph_y_range);	//	Now convert this to 48-bit millibeatsend map_to_millibeat_range;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_init_ranges												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	The range of the curve fit graph will be based on the larger of the following two absolute times://	The time of the final tempo event if any//	The time of the final note on the cue track if any//	If there are no tempo events and no cue notes, then we'll just use a defaultcfgraph_init_ranges: proc swapable;	dcl (num_events, num)	fixed;	//	For counting	dcl temp_array(3)			fixed;	//	array for measures(msw), measures(lsw), beats, thousandths	set_default_range: proc;	// Sets a default range equivalent to 3 measures plus 1 beat		dcl measbeats(3) fixed;	//	array for measures(msw), measures(lsw), beats, thousandths		//		measbeats(1) = 3; measbeats(2) = 2;	//	Make measbeats array represent measure 3, beat 2		//	Set the lower limit to zero.time		str32(0,zero.time,cfgraph_x_lower);		//	Set the upper limit to the real time of measure 3, beat 2 (ignore live click track for these purposes)		Map.Long.Measures.Beats.To.Sequence.Time(measbeats,cfgraph_x_upper);		Map.Sequence.Time.To.Real.Time(cfgraph_x_upper,cfgraph_x_upper);		//	And of course the range is the difference		sub32(cfgraph_x_upper,cfgraph_x_lower,cfgraph_x_range);	end set_default_range;	//	if this sequence doesn't already contain curve fit data, then try to set it up	write(mam) = BAS.PTR;	//	look up the pointer to the curve fit map in the sequence base area	write(mal) = Seq.Map.Ptrs + CFit.Map#;	if (read(md) == null) Create.CFit.Map.From.Track(cond_track#);	else CFit.Map.Ptr == nah.ptr + read(md);	if (CFit.Map.Ptr == null)	{	str32(0,0,cfgraph_x_upper);	//	No cues to plot	}	else	{	// there is valid curve fit data (i.e., cues to plot)		//	Put the real time of the final cue in cfgraph_x_upper and the number of cues in num_events		num_events = get_final_cfit_cue_info(cfgraph_x_upper);		// if there are more cues than pixels-1, then truncate to pixels-1		if (num_events ige #cfgraph_size_x+1) num_events = #cfgraph_size_x;		//	convert from whole fields to SMPTE bits		//	multiply lower word		load cfgraph_x_upper(1); mul 40;		cfgraph_x_upper(1) = res;		write(reg_dst|r13) = ures;	//	save overflow to use as addend in multiplication of upper word		//	multiply upper word		load cfgraph_x_upper(0); uload read(reg_src|r13); mul 40;		cfgraph_x_upper(0) = res;		//	subtract out SMPTE offset		smpte.to.sbits(S$SOffset,S$Smode,temp_array);		sub32(cfgraph_x_upper,temp_array,cfgraph_x_upper);		// convert to real milliseconds		sbits.to.msec(cfgraph_x_upper,cf#time,S$Speed,S$Smode,cfgraph_x_upper);	}	if (Tempo.Map.Ptr == null)	{	str32(0,0,cfgraph_x_lower);	//	No tempo events to plot	}	else	{	// there is a tempo map in effect		//	Temporarily keep the real time of the final tempo event in cfgraph_x_lower and the number of tempo events in num		get_final_tempo_event_info(cfgraph_x_lower,temp_array);		// don't count the event at 0 or the event at zero.time		sub16(1,temp_array);	//	subtract 2 but add 1 since the tempo events are counted from zero		// if there are more tempo events than pixels-1, then truncate to pixels-1		if ((temp_array(0) != 0) || (temp_array(1) ige #cfgraph_size_x+1)) num = #cfgraph_size_x;		else num = temp_array(1);	}	// If there were no tempo events or cue notes after zero.time, then just use the default range	if ((num_events|num) == 0) {set_default_range(); map_to_millibeat_range(); return;}	//	Put the greater of the two times into cfgraph_x_upper	//	and the corresponding number of events into num_events	if (com32(cfgraph_x_lower,cfgraph_x_upper) == lw#igt) {		copy32(cfgraph_x_lower,cfgraph_x_upper);		num_events = num;	}	//	Prevent ludicrously small ranges when the only tempo events or cue notes are close to zero.time	temp_array(0) = 0; temp_array(1) = 2; temp_array(2) = 1;	//	Make temp_array represent measure 2, beat 1 (ignore live click track for these purposes)	//	Temporarily put the real time of measure 2, beat 1 in cfgraph_x_lower	Map.Long.Measures.Beats.To.Sequence.Time(temp_array,cfgraph_x_lower);	Map.Sequence.Time.To.Real.Time(cfgraph_x_lower,cfgraph_x_lower);	if (com32(cfgraph_x_upper,cfgraph_x_lower) == lw#ilt) {set_default_range(); map_to_millibeat_range(); return;}	//	Always initialize the graph with the lower limit set to zero.time	str32(0,zero.time,cfgraph_x_lower);	//	Extend the range to provide some space after the last event of interest	//	Range = (upper limit - lower limit) * (num_events+1)/num_events	sub32(cfgraph_x_upper,cfgraph_x_lower,BitMsbArray);	ratio_multiply(num_events+1,num_events);	copy32(BitMsbArray,cfgraph_x_range);	//	Recalculate the upper limit based on the extended range	add32(cfgraph_x_lower,cfgraph_x_range,cfgraph_x_upper);	map_to_millibeat_range();	// Map our final time range to it's corresponding millibeat rangeend cfgraph_init_ranges;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_scroll_page_up											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_scroll_page_up: proc swapable;	//	if ((cfgraph_x_upper(0) & cfgraph_x_upper(1)) == -1) return;	//	can't scroll any further	copy32(cfgraph_x_upper,cfgraph_x_lower);						//	Old upper limit becomes new lower limit	add32(cfgraph_x_upper,cfgraph_x_range,cfgraph_x_upper);	//	Keep range the same	if (com32(cfgraph_x_upper,cfgraph_x_range) == lw#ilt) {	//	Check for overflow		str32(-1,-1,cfgraph_x_upper);		sub32(cfgraph_x_upper,cfgraph_x_range,cfgraph_x_lower);	}	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_scroll_page_up;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_scroll_page_down										*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_scroll_page_down: proc swapable;	dcl scroll_duration(1)	fixed;	//	if (com32(cfgraph_x_lower,zero.zerotime) == lw#ieq) return;	//	can't scroll any further	//	Must check for lower bounds	copy32(cfgraph_x_lower,scroll_duration);	sub16(zero.time,scroll_duration);	if (com32(scroll_duration,cfgraph_x_range) == lw#igt) copy32(cfgraph_x_range,scroll_duration);	sub32(cfgraph_x_lower,scroll_duration,cfgraph_x_lower);	//	Subtract scroll_duration from each, keeping the  range the same	sub32(cfgraph_x_upper,scroll_duration,cfgraph_x_upper);	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_scroll_page_down;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_scroll_up												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_scroll_up: proc swapable;	//	1/16th of our range	dcl scroll_duration(1) fixed;	//	if ((cfgraph_x_upper(0) & cfgraph_x_upper(1)) == -1) return;	//	can't scroll any further	copy32(cfgraph_x_range,scroll_duration);	load scroll_duration(0); div 16;	scroll_duration(0) = res; write(reg_dst|r13) = rem;	load scroll_duration(1); uload read(reg_src|r13); div 16;	scroll_duration(1) = res + (rem ige 8);	add32(cfgraph_x_upper,scroll_duration,cfgraph_x_upper);	//	Add scroll_duration to each, keeping the  range the same	if (com32(cfgraph_x_upper,scroll_duration) == lw#ilt) {	//	Check for overflow		str32(-1,-1,cfgraph_x_upper);		sub32(cfgraph_x_upper,cfgraph_x_range,cfgraph_x_lower);	}	else add32(cfgraph_x_lower,scroll_duration,cfgraph_x_lower);	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_scroll_up;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_scroll_down												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_scroll_down: proc swapable;	//	1/16th of our range	dcl scroll_duration(1)	fixed;	dcl temp_duration(1)		fixed;	//	if (com32(cfgraph_x_lower,zero.zerotime) == lw#ieq) return;	//	can't scroll any further	copy32(cfgraph_x_range,scroll_duration);	load scroll_duration(0); div 16;	scroll_duration(0) = res; write(reg_dst|r13) = rem;	load scroll_duration(1); uload read(reg_src|r13); div 16;	scroll_duration(1) = res + (rem ige 8);	//	Must check for lower bounds	copy32(cfgraph_x_lower,temp_duration);	sub16(zero.time,temp_duration);	if (com32(scroll_duration,temp_duration) == lw#igt) copy32(temp_duration,scroll_duration);	sub32(cfgraph_x_lower,scroll_duration,cfgraph_x_lower);	//	Subtract scroll_duration from each, keeping the  range the same	sub32(cfgraph_x_upper,scroll_duration,cfgraph_x_upper);	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_scroll_down;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_zoom_in													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_zoom_in: proc swapable;	dcl temp32(1)		fixed;	dcl zoom.limit lit 'shr(#cfgraph_size_x+1,1)+1';			//	Don't get as small as half the number of pixels in milliseconds	//	if (com16(zoom.limit,cfgraph_x_range) == lw#ieq) return;	//	nothing to do if we're already zoomed in to the limit	//	get half the current width	copy32(cfgraph_x_range,temp32);	//	keep the original width for later	write(reg_dst|r13) = cfgraph_x_range(1)|1;											//	remember remainder	shr32(cfgraph_x_range,1);																	//	truncated quotient	if ((cfgraph_x_range(1)|read(reg_src|r13)) == 1) add16(1,cfgraph_x_range);	//	round toward even result	if (com16(zoom.limit,cfgraph_x_range) == lw#igt) str32(0,zoom.limit,cfgraph_x_range);	//	limit cfgraph_x_range to zoom.limit	//	add half the difference between the original and new widths to cfgraph_x_lower	sub32(temp32,cfgraph_x_range,temp32);	shr32(temp32,1);	add32(cfgraph_x_lower,temp32,cfgraph_x_lower);	add32(cfgraph_x_lower,cfgraph_x_range,cfgraph_x_upper);	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_zoom_in;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE cfgraph_zoom_out													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/cfgraph_zoom_out: proc swapable;	dcl temp32(1)		fixed;	//	str32(shr(-1,1),shr(-1-zero.time,1)|"100000",temp32);	//	put half of 2^32-1-zero.time in temp32	if (com32(cfgraph_x_range,temp32) == lw#igt) {		//	just max out the range		str32(0,zero.time,cfgraph_x_lower);		str32(-1,-1,cfgraph_x_upper);		sub32(cfgraph_x_upper,cfgraph_x_lower,cfgraph_x_range);	}	else {		copy32(cfgraph_x_range,temp32);		shr32(temp32,1);								//	get half the current width in temp32		shl32(cfgraph_x_range,1);					//	double cfgraph_x_range		sub32(cfgraph_x_lower,temp32,temp32);	//	temp32 now holds the likely new cfgraph_x_lower		if (com32(temp32,cfgraph_x_lower) == lw#igt) {			//	wrap-around occurred so limit cfgraph_x_lower to zero.zerotime			str32(0,zero.time,cfgraph_x_lower);			add32(cfgraph_x_lower,cfgraph_x_range,cfgraph_x_upper);		}		else {			copy32(temp32,cfgraph_x_lower);			add32(cfgraph_x_lower,cfgraph_x_range,temp32);	//	temp32 now holds the likely new cfgraph_x_upper			if (com32(temp32,cfgraph_x_upper) == lw#ilt) {				//	wrap-around occurred so limit cfgraph_x_upper to 2^32-1				str32(-1,-1,cfgraph_x_upper);				sub32(cfgraph_x_upper,cfgraph_x_range,cfgraph_x_lower);			}			else copy32(temp32,cfgraph_x_upper);		}	}	map_to_millibeat_range();	// Map our new time range to it's corresponding millibeat range	cfgraph_update();				//	Force a replotend cfgraph_zoom_out;// a procedure is needed here for resetting the range according to the percentage returned by the scroll bar box