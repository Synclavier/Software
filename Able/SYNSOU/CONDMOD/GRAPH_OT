/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: GRAPH_OTPATH:		 :SYNSOU:CONDMOD:GRAPH_OTCONTAINS: SOURCE CODE FOR THE OPTIMAL TEMPO GRAPH SUBSCREENREVISION HISTORY:00	1999/11/12	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*This file contains the procedure generate_ot_graph_data which generates the data in the cf_mapnecessary for the optimal tempo graph to be plotted.TO DO:	Warn user before paving an existing tempo map*//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*//*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*/dcl otgraph_x_lower(1)	fixed;	//	Optimal Tempo Graph horizontal axis lower limit represented as 32-bit microsecond tempodcl otgraph_x_upper(1)	fixed;	//	Optimal Tempo Graph horizontal axis upper limit represented as 32-bit microsecond tempodcl otgraph_data_ptr		pointer;	//	pointer to APV containing the optimal tempo graph data (tempo, offset, sqroot(error))/*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE least_squares														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	The code in this procedure is utilized both by least_squares_fit() and generate_ot_graph_data().//	It is left to the calling procedures to allocate all APVs referenced here, to assign the//	appropriate values, and to recycle them after the point of call.least_squares: proc (tempo32,offset32) swapable;	dcl (tempo32,offset32) fixed array;	dcl sum_of_cues		lit 'aux1_ptr';	//	Sum(cue(i))					for i = 0 to n-1	dcl sum_of_targets	lit 'aux2_ptr';	//	Sum(target(i))				for i = 0 to n-1	dcl sum_of_products	lit 'aux3_ptr';	//	Sum(target(i)*cue(i))	for i = 0 to n-1	dcl sum_of_squares	lit 'aux4_ptr';	//	Sum(target(i)^2)			for i = 0 to n-1	//	иииииииииииии COMPUTE THE DENOMINATOR ииииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	denominator = n * Sum(target(i)^2) - Sum(target(i))^2	apv_multiply(pre_ptr,sum_of_squares,den_ptr);			//	den = n * Sum(target(i)^2)	apv_multiply(sum_of_targets,sum_of_targets,aux_ptr);	//	aux = Sum(target(i))^2	apv_addsub(den_ptr,aux_ptr,den_ptr,#subtract);			//	den = n * Sum(target(i)^2) - Sum(target(i))^2	//	иииииииииииии COMPUTE THE TEMPO NUMERATOR ииииииииииииииииииииииииииииииииииииииииииииииииииии	//	numerator = n * Sum(target(i)*cue(i)) - Sum(cue(i)) * Sum(target(i))	apv_multiply(pre_ptr,sum_of_products,num_ptr);			//	num = n * Sum(target(i)*cue(i))	apv_multiply(sum_of_cues,sum_of_targets,aux_ptr);		//	aux = Sum(cue(i)) * Sum(target(i))	apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);			//	num = n * Sum(target(i)*cue(i)) - Sum(cue(i)) * Sum(target(i))	apv_duplicate(den_ptr,pre_ptr);	//	keep a safe copy of the demnominator so we can restore it for use with the offset	apv_reduce(num_ptr,den_ptr);	//	convert final ratio from video fields per sequence millisecond to real microseconds per samp.click.rate sequence milliseconds	apv_assign(aux_ptr,samp.click.rate);	apv_multiply(num_ptr,aux_ptr,num_ptr);	apv_multiply(num_ptr,smpte_num_ptr,num_ptr);	apv_multiply(den_ptr,smpte_den_ptr,den_ptr);	apv_quotient(num_ptr,den_ptr,aux_ptr,true);	apv_output_u32(aux_ptr,tempo32);	//	for debugging, check for sign error after this	//	иииииииииииии COMPUTE THE OFFSET NUMERATOR иииииииииииииииииииииииииииииииииииииииииииииииииии	//	numerator = Sum(cue(i)) * Sum(target(i)^2) - Sum(target(i)*cue(i)) * Sum(target(i))	apv_multiply(sum_of_cues,sum_of_squares,num_ptr);		//	num = Sum(cue(i)) * Sum(target(i)^2)	apv_multiply(sum_of_products,sum_of_targets,aux_ptr);	//	aux = Sum(target(i)*cue(i)) * Sum(target(i))	apv_addsub(num_ptr,aux_ptr,num_ptr,#subtract);			//	num = Sum(cue(i)) * Sum(target(i)^2) - Sum(target(i)*cue(i)) * Sum(target(i))	apv_reduce(num_ptr,pre_ptr);	//	use pre_ptr here in lieu of den_ptr	//	convert final ratio from video fields to milliseconds	apv_assign(aux_ptr,50000);	apv_put_word(aux_ptr,1,0);		//to prevent 50000 from being interpreted as a negative number	apv_multiply(num_ptr,aux_ptr,num_ptr);	apv_multiply(pre_ptr,smpte_den_ptr,pre_ptr);	apv_quotient(num_ptr,pre_ptr,aux_ptr,true);	apv_output_s32(aux_ptr,offset32);end least_squares;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE generate_ot_graph_data											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/generate_ot_graph_data: proc swapable;	//	offsets	dcl offset				fixed;	//	sequence time necessary to offset the sequence travel path by to produce a different list of targets.											//	(once this reaches "maximum_offset", the same target lists will repeat)	dcl maximum_offset	fixed;	//	the number of sequence deltas that must be added to a quantized value to cause it to quantize to the next value	dcl minimum_offset	fixed;	//	used to arrive at the value of "offest" for the next iteration	dcl temp_offset		fixed;	//	32-bit variables	dcl (quantum_msb,quantum_lsb)	fixed;	dcl tempo32				(1)	fixed;	//	the nearest tempo less than (faster than) the current tempo that will result in													//	a different list of targets being generated in the next iteration	dcl cue_time32			(1)	fixed;	dcl target_time32		(1)	fixed;	dcl quant_time32		(1)	fixed;	dcl halfway_time32	(1)	fixed;	//	apv stuff	dcl lol_ptr			pointer;	//	Pointer to the APV containing a list of pointers to other APVs containing										//	lists of targets.  "lol" stands for "list of lists".	dcl cur_tlist_ptr	pointer;	// Pointer to the current target list.	dcl num_tlists		fixed;	//	Keeps track of the number of pointers to target lists (in APVs) that are saved										//	in the APV pointed to by "lol_ptr".  This is zero-based so it can also be used										//	as an index into that APV in calls to apv_put_word() and apv_get_word().	dcl lol_index		fixed;	//	Index into the APV pointed to by "lol_ptr".	dcl tlist_index	fixed;	//	Index into any of the APVs containing lists of targets (pointed to by the										//	various words in the APV pointed to by "lol_ptr").  Note: since target times are										//	32-bit quantities, this index refers to pairs of words rather than single words. 	dcl temp				fixed;	//	Temporarily holds shl(tlist_index,1) to avoid repeated calls to shl(), as well as some other interim values.	dcl unique			boolean;	dcl temp32				lit 'target_time32';	dcl target32_1			lit 'cue_time32';				dcl target32_2			lit 'quant_time32';			dcl first_target32	lit 'halfway_time32';	dcl offset32			lit 'halfway_time32';	dcl cue_ptr				lit 'x';	dcl target_ptr			lit 'y';	dcl sum_of_cues		lit 'aux1_ptr';	//	Sum(cue(i))					for i = 0 to n-1	dcl sum_of_targets	lit 'aux2_ptr';	//	Sum(target(i))				for i = 0 to n-1	dcl sum_of_products	lit 'aux3_ptr';	//	Sum(target(i)*cue(i))	for i = 0 to n-1	dcl sum_of_squares	lit 'aux4_ptr';	//	Sum(target(i)^2)			for i = 0 to n-1	//	ииииииииииииии	Section 1: Preliminary stuff. ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	if this sequence doesn't already contain curve fit data, then try to set it up	write(mam) = BAS.PTR;	//	look up the pointer to the curve fit map in the sequence base area	write(mal) = Seq.Map.Ptrs + CFit.Map#;	if (read(md) == null) Create.CFit.Map.From.Track(cond_track#);	else CFit.Map.Ptr == nah.ptr + read(md);	if (CFit.Map.Ptr == null) return;			//	nothing to do	str32(7,11248,otgraph_x_upper);	//	470000 (faster tempo corresponds to lesser value)	///////////////////////////////////	TEMPORARY	str32(7,31248,otgraph_x_lower);	//	490000 (slower tempo corresponds to greater value)	///////////////////////////////////	TEMPORARY	stop.recd.move.play.xpos.cont.eras();		//	stop any performance	//	get the number of cues	n = get_final_cfit_cue_info(cue_time32);	//	cue_time32 is irrelevant here	//	Special Case: If there is only 1 cue, then all tempos will be equally groovy.	if (n == 1) {psr('fuggit'); return;}		//	For now	//	save the current sequence in .undoseq so we can restore it at the end of this procedure	#if (false)	//	don't do this until recalling sequences sets up cfit.map.ptr	save.undoseq();	#endif	samp.click.rate = 480;	//	set the divisions to 480	//	nuke any existing tempo/meter maps	if (Meter.Map.Ptr != null)	Erase.Meter.Map.Info();	if (Tempo.Map.Ptr != null)	Erase.Tempo.Map.Info();	//	set up default maps	Create.Default.Meter.Map();	Create.Default.Tempo.Map();	if ((Tempo.Map.Ptr|Meter.Map.Ptr) == null)	{	//	bail if not enough memory for maps		ertyp = err.oom;		return;	}	//	compute value of maximum_offset	load 480; div samp.crm;	//	at 480 divisions per click, equal subdivisions are produced by samp.crm == 1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 16	if (rem == 0)				 maximum_offset = res;	//	at 480 divisions per click, samp.crm == 14 produces unequal subdivisions within each half click	else if (samp.crm == 14) maximum_offset = 240; 	//	at 480 divisions per click, samp.crm == 7, 9, 11, 13 produce unequal subdivisions within each click	else							 maximum_offset = 480;ps('maximum_offset = '); pnum(maximum_offset,0); pcr();	////////////////////////////////////////////////////////	DEBUG	lol_ptr = apv_allocate_node;																	////////	needs error check	////////	num_tlists = -1;	copy32(otgraph_x_lower,tempo32);	//	initialize tempo32 to otgraph_x_lower	while (com32(tempo32,otgraph_x_upper) != lw#ilt) {ps('setting tempo to '); print_u32(tempo32,false); pcr(); interp_flush_char_output();	///////////////////////////////////////////////////////////	DEBUG		Set.Tempo(zero.zerotime,tempo32);		offset = 0;					//	initialize offset to 0 for each new tempo		str32(0,25000,tempo32);	//	set to smallest possible value (fastest tempo)		while (offset ilt maximum_offset) {//	print 'offset =',offset; zilch = read("50");	////////////////////////////////////////////////////////	DEBUG			//	ииииииииииииии	Section 2: Generate target list. иииииииииииииииииииииииииииииииииииииииииииииииииииииииииии			//	Generate the list of targets corresponding to this combination of tempo and offset.			//	Also calculate the minimum distance that the sequence travel path must be offset			//	in the next pass to cause a different list of targets to be generated.			//	allocate another apv to hold the list we're about to generate			cur_tlist_ptr = apv_allocate_node;													////////	needs error check	////////			num_tlists = num_tlists+1;			apv_put_word(lol_ptr,num_tlists,cur_tlist_ptr);									////////	needs error check	////////			minimum_offset = maximum_offset;	//	reinitialize minimum_offset for each pass through the cfit map			reset_cfit_map();						//	point all cfit variables to the first record (which is null)			do tlist_index = 0 to n-1;//	print 'tlist_index =',tlist_index; zilch = read("50");	////////////////////////////////////////////////////////	DEBUG				//	step 1: get unquantized sequence time corresponding to this que and add in the current offset				get_next_cfit_pair(cue_time32,target_time32);	//	we're really only interested in the cue time				map.real.time.to.sequence.time(cue_time32,target_time32);				sub16(zero.time,target_time32);						//	remove the zero time offset				add16(offset,target_time32);							//	but add in our own current offset				//	step 2: find the quantum value corresponding to this offset sequence time				bitmsb = target_time32(0); bitlsb = target_time32(1);				ratio_multiply(samp.crm,480);							//	round to quantum				quantum_msb = bitmsb; quantum_lsb = bitlsb;		//	remember this value for step 4				//	step 3: calculate the quantized sequence time from this quantum value				ratio_multiply(480,samp.crm);							//	convert quanta back to sequence time				str32(bitmsb,bitlsb,quant_time32);				//	step 4: calculate from the quantum value the earliest sequence time that would quantize to the next value				load quantum_lsb; uload 1; mul 2;					//	BitMsbArray = (quantum*2)+1				bitlsb = res; write(reg_dst|r13) = ures;				load quantum_msb; uload read(reg_src|r13); mul 2;				bitmsb = res;				ratio_multiply(240,samp.crm);				//	Important: we must use ceiling rounding here				if ((mul.llsb != 0) && (mul.llsb ilt "100000")) {	//	if there was a remainder and we didn't already round up, then do it here					bitlsb = bitlsb+1;					if (bitlsb == 0) bitmsb = bitmsb+1;					//	carry if necessary				}				str32(bitmsb,bitlsb,halfway_time32);				//	step 5: get the number of sequence deltas from the original (unquantized) time to the halfway point				//			  (this may be our new minimum offset)				sub32(halfway_time32,target_time32,temp32);				if (temp32(1) ilt minimum_offset) minimum_offset = temp32(1);				//	step 6: if this is our first time through the inner loop at this tempo, calculate tempo32 for the next iteration of the outer loop				if (offset == 0) {					//	calculate the slowest tempo faster than our current one which will cause this target to flip up to the next quantized value					// next_tempo = (cue_time32-zero.time)*480000/halfway_time32					sub16(zero.time,cue_time32);			//	remove the zero time offset from cue_time32					str32(7,21248,temp32);					//	temporarily put 480000 in temp32					mul_32by32(cue_time32,temp32);		//	(the interim 64-bit value is in MATHMOD's static array multiply.result)					div_64by32(halfway_time32,temp32);	//	the final result is in temp32					if (com32(temp32,tempo32) == lw#igt) copy32(temp32,tempo32);	//	keep the slowest one we find				}				//	step 7: append our final quantized target time to the current target list				temp = shl(tlist_index,1);				apv_put_word(cur_tlist_ptr,temp  ,quant_time32(0));				apv_put_word(cur_tlist_ptr,temp+1,quant_time32(1));			end;			//	ииииииииииииии	Section 3: Compare this newly generated list with all previously generated lists. ииииииииии			//	иииииииииииииииииииииииии Purge it if it's not unique. ииииииииииииииииииииииииииииииииииииииииииииииииииии			first_target32(0) = apv_get_word(cur_tlist_ptr,0);			first_target32(1) = apv_get_word(cur_tlist_ptr,1);			lol_index = 0; unique = true;			//	loop through each target list until a match is found//	print 'entering loop: limit =',num_tlists;	////////////////////////////////////////////////////////	DEBUG			while ((lol_index != num_tlists) && (unique != false)) {//	print 'lol_index =',lol_index; zilch = read("50");	////////////////////////////////////////////////////////	DEBUG				//	check the the first target of each list to see if we must deal with an offset				//	point tmp1_ptr to the target list to be compared with the current one				tmp1_ptr = apv_get_word(lol_ptr,lol_index);				target32_1(0) = apv_get_word(tmp1_ptr,0);				target32_1(1) = apv_get_word(tmp1_ptr,1);				temp = com32(target32_1,first_target32);				if	(temp == lw#ieq) {					//	no offset, so this is easy					if (apv_compare(tmp1_ptr,cur_tlist_ptr) == #ieq) unique = false;				}				else {					//	we have an offset					if	(temp == lw#igt) {						//	target32_1 igt first_target32, so temp_offset = target32_1 - first_target32						sub32(target32_1,first_target32,temp32);						temp_offset = temp32(1);						//	We'll want to subtract this offset from every target in the list pointed to by tmp1_ptr,						//	so set the temporary pointers accordingly.						tmp2_ptr = tmp1_ptr;						tmp1_ptr = cur_tlist_ptr;					}					else {						//	target32_1 ilt first_target32, so temp_offset = first_target32 - target32_1						sub32(first_target32,target32_1,temp32);						temp_offset = temp32(1);						//	We'll want to subtract this offset from every target in the list pointed to by cur_tlist_ptr,						//	so set the temporary pointers accordingly.						tmp2_ptr = cur_tlist_ptr;					}					tlist_index = 1; unique = false;					//	loop through each subsequent pair of targets in the two target lists until a mismatch is found//	print 'entering subloop: limit =',n;	////////////////////////////////////////////////////////	DEBUG					while ((tlist_index != n) && (unique == false)) {//	print 'tlist_index =',tlist_index; zilch = read("50");	////////////////////////////////////////////////////////	DEBUG						temp = shl(tlist_index,1);						target32_1(0) = apv_get_word(tmp1_ptr,temp  );						target32_1(1) = apv_get_word(tmp1_ptr,temp+1);						target32_2(0) = apv_get_word(tmp2_ptr,temp  );						target32_2(1) = apv_get_word(tmp2_ptr,temp+1);						sub16(temp_offset,target32_2);						if (com32(target32_1,target32_2) != lw#ieq) unique = true;						tlist_index = tlist_index+1;					}				}				lol_index = lol_index+1;			}	//	end of loop through each target list until a match is found			if (unique == false) {				apv_recycle(cur_tlist_ptr);				relinquish_high_word(lol_ptr);				num_tlists = num_tlists-1;			}			//	set the offset for the next iteration			//	(This is the positive y distance (sequence milliseconds) that the travel path will have to be offset			//	to cause the lowest target relative to it to flip up to the next quantized value.)			offset = offset + minimum_offset;		}	//	end of while (offset ilt maximum_offset)	}	//	end of while tempo in range	//	ииииииbиeиgиiиnиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииии	//	print out the results	#if (false)	pnum(num_tlists+1,0); psr(' target lists were generated');	do lol_index = 0 to num_tlists;		tmp1_ptr = apv_get_word(lol_ptr,lol_index);		do tlist_index = 0 to n-1;			temp = shl(tlist_index,1);			target_time32(0) = apv_get_word(tmp1_ptr,temp  );			target_time32(1) = apv_get_word(tmp1_ptr,temp+1);			print_u32(target_time32,true); pcr();		end;		pcr();	end;	#endif	//	ииииииeиnиdиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииииииии	//	ииииииииииииии	Section 4: Perform least squares fit for each target list. иииииииииииииииииииииииииииииииииииииии	//	perform a least squares linear fit for each of these combinations of cues and targets	//	store the resulting tempo, offset and sqroot(sum_of_squares) in an apv (allocated and deallocated outside this procedure)	//	sort them by tempo	//	ALLOCATE APVs	otgraph_data_ptr	= apv_allocate_node;	//	for now: eventually this should exist for the life of the graph	cue_ptr				= apv_allocate_node;	target_ptr			= apv_allocate_node;	sum_of_cues			= apv_allocate_node;	sum_of_targets		= apv_allocate_node;	sum_of_products	= apv_allocate_node;	sum_of_squares		= apv_allocate_node;	aux_ptr				= apv_allocate_node;	pre_ptr				= apv_allocate_node;	num_ptr				= apv_allocate_node;	den_ptr				= apv_allocate_node;	smpte_num_ptr		= apv_allocate_node;	smpte_den_ptr		= apv_allocate_node;	//	INITIALIZE SMPTE CONSTANTS	 (This needs a DO CASE to handle the different SMPTE modes.)	load 50000; mul 1000;	apv_put_word(smpte_num_ptr,0,res);	apv_put_word(smpte_num_ptr,1,ures);	apv_assign(smpte_den_ptr,2997);	do lol_index = 0 to num_tlists;		tmp1_ptr = apv_get_word(lol_ptr,lol_index);		reset_cfit_map();	//	point all cfit variables to the first record (which is null)		do tlist_index = 0 to n-1;			//	PLUG IN CUE TIMES FROM THE CURVE FIT MAP			get_next_cfit_pair(BitMsbArray,target_time32);	//	target_time32 is discarded here			//	remove the zero time offset from the cues			if (bitlsb ilt zero.time) bitmsb = bitmsb-1;		//	borrow if necessary			bitlsb = bitlsb-zero.time;								//	remove zero time offset from cue			//	convert cue time to whole video fields			ratio_multiply(2997,50000);	//	(This needs a DO CASE to handle the different SMPTE modes.)			apv_input_u32(cue_ptr	,BitMsbArray);			//	PLUG IN TARGET TIMES FROM THE CURRENT TARGET LIST			//	(Note: the zero time offset has already been removed from the targets)			temp = shl(tlist_index,1);			target_time32(0) = apv_get_word(tmp1_ptr,temp  );			target_time32(1) = apv_get_word(tmp1_ptr,temp+1);			apv_input_u32(target_ptr,target_time32);			//	accumulate sum_of_cues			apv_addsub(cue_ptr,sum_of_cues,sum_of_cues,#add);			//	accumulate sum_of_targets			apv_addsub(target_ptr,sum_of_targets,sum_of_targets,#add);			//	accumulate sum_of_products			apv_multiply(cue_ptr,target_ptr,aux_ptr);			apv_addsub(aux_ptr,sum_of_products,sum_of_products,#add);			//	accumulate sum_of_squares			apv_multiply(target_ptr,target_ptr,aux_ptr);			apv_addsub(aux_ptr,sum_of_squares,sum_of_squares,#add);		end;		apv_assign(pre_ptr,n);		least_squares(tempo32,offset32);		////////////////	===>	MUST ADD SOME CODE HERE!!	<===	////////////////		//	compute sqroot(error) here								<===	////////////////		//	error = (tempo*x + offset - cue_time32)^2		//	stick tempo, offset & sqroot(error) into apv here		<===	////////////////		//	ииииииbиeиgиiиnиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииии		//	print out the results		ps('for target list #'); pnum(lol_index+1,0);		ps(', tempo = '); print_u32(tempo32,false);		ps(', offset = '); print_u32(offset32,false);		pcr(); interp_flush_char_output();		//	ииииииeиnиdиииdиeиbиuиgиииsиcиhиpиuиtиzиииhиeиrиeииииииииии	end;	////////////////	===>	MUST ADD SOME CODE HERE!!	<===	////////////////	//	sort otgraph_data_ptr here								<===	////////////////	//	ииииииииииииии	Section 5: Clean up. иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии	//	deallocate all APVs before restoring the sequence	apv_recycle(otgraph_data_ptr);	//	for now: eventually this should exist for the life of the graph	apv_recycle(cue_ptr);	apv_recycle(target_ptr);	apv_recycle(sum_of_cues);	apv_recycle(sum_of_targets);	apv_recycle(sum_of_products);	apv_recycle(sum_of_squares);	apv_recycle(aux_ptr);	apv_recycle(pre_ptr);	apv_recycle(num_ptr);	apv_recycle(den_ptr);	apv_recycle(smpte_num_ptr);	apv_recycle(smpte_den_ptr);	do lol_index = 0 to num_tlists;		apv_recycle(apv_get_word(lol_ptr,lol_index));	end;	apv_recycle(lol_ptr);	//	restore the sequence to its original state	#if (false)	//	don't do this until recalling sequences sets up cfit.map.ptr	undo.sequence.changes();	#endifend generate_ot_graph_data;