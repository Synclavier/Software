/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: SCRNDEFSPATH:		 :SYNSOU:CONDMOD:SCRNDEFSCONTAINS: COMMAND EXECUTION DRIVERS AND SUBSCREEN DEFINITION ROUTINESREVISION HISTORY:00	1999/12/11	Todd Yvega	Created.*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//**//*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*//*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*//*иии  P R I V A T E   P R O C E D U R E S   A N D   F U N C T I O N S  иии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE tegraph_update													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/tegraph_update: proc swapable;	enter.vector.mode();	//	erase the graph area, including the tick marks	area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);	//	the recent call to highlight.graphics.button.table.entry() left the data level at #pixels_off	data_level(#pixels_on);	//	draw graph here	enter.transparent.mode();end tegraph_update;#if (false)otgraph_update: proc swapable;	enter.vector.mode();	//	erase the graph area, including the tick marks	area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);	//	the recent call to highlight.graphics.button.table.entry() left the data level at #pixels_off	data_level(#pixels_on);	//	draw graph here	enter.transparent.mode();end otgraph_update;mcgraph_update: proc swapable;	enter.vector.mode();	//	erase the graph area, including the tick marks	area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);	//	the recent call to highlight.graphics.button.table.entry() left the data level at #pixels_off	data_level(#pixels_on);	//	draw graph here	enter.transparent.mode();end mcgraph_update;#elsedcl otgraph_update	lit 'tegraph_update';dcl mcgraph_update	lit 'tegraph_update';#endif/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE init_target_editor												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Define and initialize Target Editor Subscreeninit_target_editor: proc swapable;	tegraph_update();	define.graphics.box(obj#graph, #graph_origin_x+12, #graph_origin_y+#graph_size_y, #graph_origin_x+#graph_size_x-12, #graph_origin_y, 0);	//																					 '1234567890123456	define.button.icon(obj#button0, ((82-10)*100)+42, (7+(0*3))*50, 0, 'TE Button 0', 1);	define.button.icon(obj#button1, ((82-10)*100)+42, (7+(1*3))*50, 0, 'TE Button 1', 1);	define.button.icon(obj#button2, ((82-10)*100)+42, (7+(2*3))*50, 0, 'TE Button 2', 1);	define.button.icon(obj#button3, ((82-10)*100)+42, (7+(3*3))*50, 0, 'TE Button 3', 0);	define.button.icon(obj#button4, ((82-10)*100)+42, (7+(4*3))*50, 0, 'TE Button 4', 0);	define.button.icon(obj#button5, ((82-10)*100)+42, (7+(5*3))*50, 0, 'TE Button 5', 0);	define.button.icon(obj#button6, ((82-10)*100)+42, (7+(6*3))*50, 0, 'TE Button 6', 0);	define.button.icon(obj#button7, ((82-10)*100)+42, (7+(7*3))*50, 0, 'TE Button 7', 0);	activate.screen(obj#infolabel);end init_target_editor;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE init_optimal_tempo												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Define and initialize Optimal Tempo Graph Subscreeninit_optimal_tempo: proc swapable;	otgraph_update();	define.graphics.box(obj#graph, #graph_origin_x+12, #graph_origin_y+#graph_size_y, #graph_origin_x+#graph_size_x-12, (((23-4)*100)*3/10)+42, 0);	//																					 '1234567890123456	define.button.icon(obj#button0, ((82-10)*100)+42, (7+(0*3))*50, 0, 'Spew Out Data', 0);	activate.screen(obj#infolabel);end init_optimal_tempo;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE init_curve_fit													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Define and initialize Curve Fit Graph Subscreeninit_curve_fit: proc swapable;	cfgraph_init_ranges(); cfgraph_update();	define.graphics.region(obj#graph, #graph_origin_x, #graph_origin_y+#graph_size_y, #graph_origin_x+#graph_size_x, #graph_origin_y);	define.scroll.bar(obj#scrollbar,O#SBar.Orient.Hor,O#SBar.Just.Bottom,		((2300-((7+(0*3))*50))*3/10)+42,	//	bottom		((((82-10)*100)+42)*3/25)+23,		//	left		((((82-0)*100)+42)*3/25)+23		//	right		);	//	For now, only allow mouse clicks to trigger activity on the scroll bar	//	set.object.get(obj#scrollbar,get#mouse.button,1);	//																					 '1234567890123456	define.button.icon(obj#button1, ((82-10)*100)+42, (7+(1*3))*50, 0, 'Reset Graph  ', 1);	define.button.icon(obj#button2, ((82-10)*100)+42, (7+(2*3))*50, 0, 'Zoom In      ', 0);	define.button.icon(obj#button3, ((82-10)*100)+42, (7+(3*3))*50, 0, 'Zoom Out     ', 0);	define.button.icon(obj#button4, ((82-10)*100)+42, (7+(4*3))*50, 0, 'LS Linear Fit', 1);	define.button.icon(obj#button5, ((82-10)*100)+42, (7+(5*3))*50, 0, 'Spline Fit   ', 1);	define.button.icon(obj#button6, ((82-10)*100)+42, (7+(6*3))*50, 0, 'Line Seg Fit ', 1);	activate.screen(obj#infolabel);	activate.scroll.bar(obj#scrollbar,500);end init_curve_fit;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE init_meter_chart													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Define and initialize Meter Chart Subscreeninit_meter_chart: proc swapable;	mcgraph_update();	define.graphics.box(obj#graph, #graph_origin_x+12, #graph_origin_y+#graph_size_y, #graph_origin_x+#graph_size_x-12, #graph_origin_y, 0);	//																					 '1234567890123456	define.button.icon(obj#button0, ((82-10)*100)+42, (7+(0*3))*50, 0, 'Blow Me', 1);	activate.screen(obj#infolabel);end init_meter_chart;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE process_te_events												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Process events in Target Editor Subscreenprocess_te_events: proc swapable;end process_te_events;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE process_ot_events												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Process events in Tempo Graph Subscreenprocess_ot_events: proc swapable;	if	(screen.event.code == get.screen.event) {		if			(screen.event.info == S#MouseSelect) {			do case screen.event.id-obj#graph;				//	Case 0: (screen.event.id == obj#graph)				;	//	what to do if the user clicks in the graph?				//	Case 1: (screen.event.id == obj#button0)				{					set.scrolling.region(6,24);	//	to prevent buttons from scrolling					cpos(5,0);							//	position cursor at row 5:column 0					erase.to.end.of.screen();					generate_ot_graph_data();					set.scrolling.region(1,24);				}			end;		}	}end process_ot_events;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE process_cf_events												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Process events in Curve Fit Graph Subscreenprocess_cf_events: proc swapable;	if			(screen.event.code == get.new.seq.info) {		//	new sequence notes/constants//	send 'next.event.info =',next.event.info;	//////////////////////////////////////////////////	DEBUG/*	//	recalling seqnext.event.info = 2343916384	//	Indicates change in DTD track mode (input, repro) 4096	//	Indicates new safe/ready for seq or dtd track (Used for multi-track midi recording & DTD) 2048	//	Indicates that the muted state of a synclavier track has changed.  512	//	Indicates change in sync mode (smpte on/off, auto-punch mode change).  Also change in MIDI sync output channel number  256	//	Indicates change in solo state for any track.  Also set if INFO MODE changes  128	//	Indicates change in sequencer motion (start, stop).  Also set if change in current MARK START     8	//	Indicates a new constant (click rate, crm, speed, smpte start time, etc.)    4	//	Indicates that a note was added or deleted on a track    2	//	Indicates new timbre name assigned to sequencer track    1	//	Indicates new sequence recallednext.event.info = 00132  128	//	Indicates change in sequencer motion (start, stop).  Also set if change in current MARK START    4	//	Indicates that a note was added or deleted on a track//	splinenext.event.info = 00004    4	//	Indicates that a note was added or deleted on a tracknext.event.info = 00142  128	//	Indicates change in sequencer motion (start, stop).  Also set if change in current MARK START    8 //	Indicates a new constant (click rate, crm, speed, smpte start time, etc.)    4	//	Indicates that a note was added or deleted on a track    2	//	Indicates new timbre name assigned to sequencer tracknext.event.info = 00132  128	//	Indicates change in sequencer motion (start, stop).  Also set if change in current MARK START    4	//	Indicates that a note was added or deleted on a track*/		//	filter out the flags that we're not concerned with		next.event.info = next.event.info & (		1|			//	Indicates new sequence recalled//		4|			//	Indicates that a note was added or deleted on a track		8|			//	Indicates a new constant (click rate, crm, speed, smpte start time, etc.)//		16|		//	Indicates that a new tempo or meter is now in effect//		32|		//	Indicates cursor boundary reached: the variables "cursor.scroll.begin" and "cursor.scroll.end" must be set up//		64|		//	Indicates screen boundary reached: the variables "screen.scroll.begin" and "screen.scroll.end" must be set up//		8192|		//	Indicates a note was placed using VITC		0);		if ((next.event.info & (1|8)) != 0) {				//	new sequence recalled or new constants			if ((next.event.info & 8) == 8) erase_cfit_map();	//	most changes to constants will cause the targets to change			Sample.Syncl.Smgr.Globals();			cfgraph_init_ranges(); cfgraph_update();			next.event.info = 0;									//	nothing else matters anymore		}//		else {//			if ((next.event.info & 32) != 0) {				//	cursor boundary reached//				//	update_play_marker();//				next.event.info = next.event.info & !32;//			}//			if ((next.event.info & 64) != 0) {				// screen boundary reached//				cfgraph_scroll_page_up();		//	what about scrolling down with rewind?//				next.event.info = next.event.info & !64;//			}//			if ((next.event.info & (4|8192)) != 0) {		// note was added, deleted or VITC placed//				//	Find out if the change was made to the cue track//				//	Update the graph if so//				cfgraph_update();					//	For now//				next.event.info = next.event.info & !(4|8|16|8192);//			}//		}	}	else if	(screen.event.code == get.screen.event) {		if			(screen.event.info == S#MouseSelect) {			if (screen.event.id == obj#graph) {				//	what to do if the user clicks in the graph			}			else do case screen.event.id-obj#button1;				//	Case 0: (screen.event.id == obj#button1)	Reset Graph				if (CFit.Map.Ptr != null) {					erase_cfit_map();					cfgraph_init_ranges(); cfgraph_update();				}				//	Case 1: (screen.event.id == obj#button2)	Zoom In				cfgraph_zoom_in();				//	Case 2: (screen.event.id == obj#button3)	Zoom Out				cfgraph_zoom_out();				//	Case 3: (screen.event.id == obj#button4)	Least Squares Linear Fit				least_squares_fit();				//	Case 4: (screen.event.id == obj#button5)	Cubic Spline Fit				spline_fit();				//	Case 5: (screen.event.id == obj#button6)	Line Segment Fit	//			;			end;		}		else if	(screen.event.info == S#SBArrowBack)		cfgraph_scroll_down();			//	User clicked left arrow		else if	(screen.event.info == S#SBArrowForward)	cfgraph_scroll_up();				//	User clicked right arrow		else if	(screen.event.info == S#SBPageBack)			cfgraph_scroll_page_down();	//	User clicked to the left of the box (but not on the arrow)		else if	(screen.event.info == S#SBPageForward)		cfgraph_scroll_page_up();		//	User clicked to the right of the box (but not on the arrow)	//	else if (screen.event.info == S#SBBoxMove) {		//	User moved the damned box	//		//	What to do?  What to do?	//	}	}	else if	(screen.event.code == get.in.char) {	//	input character typed		if	(next.event.info == a.cr) {			pcr();			//	test_this();	///////////////////////////////////////////////	DEBUG		}		else if	(next.event.info ige asc.fkey1) {			do case next.event.info-asc.fkey1;	//	SPECIAL FUNCTION KEYS				ps('F5 ');								//	CASE 0: F5				ps('F6 ');								//	CASE 1: F6				ps('F7 ');								//	CASE 2: F7				ps('F8 ');								//	CASE 3: F8				ps('F9 ');								//	CASE 4: F9				ps('F10 ');								//	CASE 5: F10				ps('F11 ');								//	CASE 6: F11				psr('F12 ');							//	CASE 7: F12				ps('Shift-F5 ');						//	CASE 8: Shift-F5				psr('Shift-F6 ');						//	CASE 9: Shift-F6//				{	clear.term();						//	CASE10: Shift-F7//					do_this();		///////////////////////////////////////////////	PISSED//				}					//				;											//	CASE11: Shift-F8//				;											//	CASE12: Shift-F9//				;											//	CASE13: Shift-F10//				;											//	CASE14: Shift-F11//				;											//	CASE15: Shift-F12			end;		}		else pc(next.event.info);	}end process_cf_events;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE process_mc_events												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	Process events in Meter Chart Subscreenprocess_mc_events: proc swapable;	////////////////////////////////////////////////////////	EVERYTHING IN HERE IS SCHPUTZ	dcl free_mem_start fixed;	cpos(0,0);	//	first word of heap = start of variable area + length of variable area + length of stack area	free_mem_start = core(c#contab+c#vstart) + core(c#contab+c#vlngth) + core(c#contab+c#stklen);	//	first word of system state variables = mem.size - 256 = loc.synret	ps('free_mem_start = '); pnum(free_mem_start,0); pcr();	ps('high_mem_start = '); pnum(loc.synret,0); pcr();	ps('length = '); pnum(loc.synret-free_mem_start,0);end process_mc_events;/*	//	erase the graph area, including tick marks	area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);	if (screen.event.code == get.screen.event) {		send 'process_mc_events: screen.event.info =',screen.event.info; zilch = read("50");	//////////////////////////////////////	DEBUG		if			(screen.event.id == obj#button0) {			if (screen.event.info == S#MouseSelect) {				cpos(0,0);				ps('Gargle glak!');			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}		else if	(screen.event.id == obj#button1) {			if (screen.event.info == S#MouseSelect) {				enter.vector.mode();				move_to(gpos.x(0),gpos.y(100));				data_level(#pixels_on);				enter.alpha.mode();				pc(esc); pc(scolon-3);	//	set char size				ps('Gargle glak!');				enter.transparent.mode();			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}		else if	(screen.event.id == obj#button2) {			if (screen.event.info == S#MouseSelect) {				enter.vector.mode();				move_to(gpos.x(0),gpos.y(200));				data_level(#pixels_on);				enter.alpha.mode();				pc(esc); pc(scolon-2);	//	set char size				ps('Gargle glak!');				enter.transparent.mode();			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}		else if	(screen.event.id == obj#button3) {			if (screen.event.info == S#MouseSelect) {				enter.vector.mode();				move_to(gpos.x(0),gpos.y(300));				data_level(#pixels_on);				enter.alpha.mode();				pc(esc); pc(scolon-1);	//	set char size				ps('Gargle glak!');				enter.transparent.mode();			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}		else if	(screen.event.id == obj#button4) {			if (screen.event.info == S#MouseSelect) {				enter.vector.mode();				move_to(gpos.x(0),gpos.y(400));				data_level(#pixels_on);				enter.alpha.mode();				pc(esc); pc(scolon-0);	//	set char size				ps('Gargle glak!');				enter.transparent.mode();			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}		else if	(screen.event.id == obj#button5) {			if (screen.event.info == S#MouseSelect) {				enter.alpha.mode();				//	erase the graph area, including tick marks				area.fill(#graph_origin_x,#graph_origin_y+#graph_size_y,#graph_origin_x+#graph_size_x,#graph_origin_y,#pixels_off,#solid);				enter.transparent.mode();			}			else send 'weirdo';	//////////////////////////////////////	DEBUG		}	}*/