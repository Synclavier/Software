/* ROUTSOUA  $TITLE  Routines to Drive the Midi Routing Screen   Modified:   11/08/89 - MWH - Mask off "midi.sync.out" for Paul   07/18/89 - PF  - Modified all occurrences of THD.MIDI to cope with MIDInet bit   06/15/89 - PF  - Removed references to inc.new.midi   05/15/89 - PF,TSS - Set bit in NEW.SEQ.INFO after sync mode change    1/13/89 - PF  - Monster MIDI code   09/02/87 - MWH - Add MIDI echo to screen   02/26/87 - BSW - Part of the routing display module*/	// Returns (-1) if no output, 0-based actual output number if routed to original hardware, THD.MIDI.OMS if routed to OMS, THD.MIDI.OMS + VPORT + 1 if routed to OMS virtual port   EXTRACT.MIDI.OUTPUT:  proc(wd) fixed swapable; /* extracts midi output# from routing word */      dcl wd fixed;		if ((wd&THD.MIDI.OMS) != 0)					  // routed to OMS		{			if ((wd&THD.MIDI.OMS.VPORT) != 0)		  // routed to OMS virtual port				return (THD.MIDI.OMS + shr(wd & THC.MIDI.OMS.VPNUM, 4) + 1);			else				return (THD.MIDI.OMS);		}		if ((wd&THD.MIDI.ORIG) != 0)					  // routed to original hardware     		return shl((wd&"37")-midi.subsys,2)+(shr(wd,5)&3);      return (-1);										  // neither to OMS or original   end EXTRACT.MIDI.OUTPUT;	// Returns (-1) if no output, 0-based actual channel number if routed to original hardware, or hardwired channel if routed to OMS   EXTRACT.MIDI.CHAN:  proc(track, wd) fixed swapable;   /* extracts midi channel from routing word */      dcl track fixed;      dcl wd    fixed;		if ((wd&THD.MIDI.OMS) != 0)					  // routed to OMS		{			if ((wd&THD.MIDI.OMS.VPORT) != 0)		  // routed to OMS Virtual Port				return (wd & THC.MIDI.OMS.VPMC);						if (track == 0 || track == 1)				  // channel 0 always used for keyboard				return (0);			else												  // else hard wired midi channel number				return ((track-num.kbd.tracks) & 0xF);		}				if ((wd&THD.MIDI.ORIG) != 0)					  // routed to original hardware      	return shr(wd,8)&"17";		return (-1);										  // neither to OMS or to original   end EXTRACT.MIDI.CHAN;	// Returns (-1) if no output, or 0-based pressure code if routed to either original hardware or OMS   EXTRACT.MIDI.PMODE:  proc(wd) fixed swapable;  /* extracts midi pressure mode from routing word */      dcl wd fixed;		if ((wd&THD.MIDI.OMS) != 0)					  // routed to OMS     		return shr(wd,12)&3;		if ((wd&THD.MIDI.ORIG) != 0)					  // routed to original hardware     		return shr(wd,12)&3;		return (-1);										  // neither to OMS or to original   end EXTRACT.MIDI.PMODE;   /* $page */	// Passed in (-1) if no output, 0-based actual output number if should route to original hardware, or THD.MIDI.OMS if should route to OMS   SET.MIDI.OUTPUT:  proc(t#, wd) swapable; 			/* sets midi output# in routing word */      dcl (t#,wd) fixed;				if ((midi.there & (MIDI.THERE.OMS | MIDI.THERE.ORIG)) == 0)		// No original hardware or OMS: can't change from this screen			return;			      if t#<num.kbd.tracks then t#=0;            /* if keyboard */      else do;         write(mam)=tbut.ptr;                    /* look up track number */         write(mal)=(t#-num.kbd.tracks);         /* index to trak but */         t#=read(md)&255;                        /* get track #       */      end;      if wd<0 then do;																// Turn off MIDI output for this track			IF (TRK.HEAD.LOOKUP(t#, THD.MIDI) & THD.MIDI.PRESURE) != 0			THEN CALL CLEANUP.MIDI.PRESSURE(t#);			// Store new value preserving MIDINet and pressure bits			CALL TRK.HEAD.STORE(t#, THD.MIDI, TRK.HEAD.LOOKUP(t#, THD.MIDI) & (THD.MIDI.MIDINET | THD.MIDI.PRESURE) );	/*	GET RID OF MIDI ROUTING BUT PRESERVE MIDINET AND PRESSURE BITS	*/			// If not routed anywhere now, make sure pressure bits are zero.			IF ((TRK.HEAD.LOOKUP(t#, THD.MIDI) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)				TRK.HEAD.STORE(t#, THD.MIDI, 0);							         if TRK.HEAD.LOOKUP(t#,thd.midi)=0         /* still no midi output */         then call CLEAR.MIDI.OUT.CONTROLLERS(t#); /* clear controller routings */      end;      else do;			IF (TRK.HEAD.LOOKUP(t#, THD.MIDI) & THD.MIDI.PRESURE) != 0			THEN CALL CLEANUP.MIDI.PRESSURE(t#);          if (TRK.HEAD.LOOKUP(t#, thd.midi) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0			then call SET.MIDI.OUT.CONTROLLERS(t#);			if (wd > THD.MIDI.OMS)			{				// Preserve channel number if set				if ((TRK.HEAD.LOOKUP(t#, thd.midi) & (THD.MIDI.OMS | THD.MIDI.OMS.VPORT)) == (THD.MIDI.OMS | THD.MIDI.OMS.VPORT))					wd = THD.MIDI.OMS | THD.MIDI.OMS.VPORT | shl(wd - THD.MIDI.OMS - 1, 4) | (TRK.HEAD.LOOKUP(t#, thd.midi) & THC.MIDI.OMS.VPMC);				else					wd = THD.MIDI.OMS | THD.MIDI.OMS.VPORT | shl(wd - THD.MIDI.OMS - 1, 4);			}						else if (wd == THD.MIDI.OMS)				;						else	         wd=(shr(wd,2)+midi.subsys)\shl(wd&3,5); 	/* convert to subsystem and out # */         call TRK.HEAD.STORE(t#, thd.midi, (TRK.HEAD.LOOKUP(t#,thd.midi) & (THD.MIDI.MIDINET | THD.MIDI.PRESURE)) \ wd);      end;      if t#=0   /* changing keyboard - keep MIDI button display up to date */      then call SELECT.PARAMETER(midi.l-par.l); /* select new parm */      call COMPUTE.MISC.INFO; /* make sure channel pressure stuff is correct */   end SET.MIDI.OUTPUT;	// Passed in (-1) if no channel, or 0-based actual channel number   SET.MIDI.CHAN:  proc(t#,wd) swapable; /* sets midi channel in routing word */      dcl (t#,wd) fixed;		if ((midi.there & (MIDI.THERE.OMS | MIDI.THERE.ORIG)) == 0)		// No original hardware or OMS: can't change from this screen			return;      if t#<num.kbd.tracks then t#=0;            /* if keyboard */      else do;         write(mam)=tbut.ptr;                    /* look up track number */         write(mal)=(t#-num.kbd.tracks);         /* index to trak but */         t#=read(md)&255;                        /* get track #       */      end;      if wd<0 then do;																// Turn off MIDI output for this track			IF (TRK.HEAD.LOOKUP(t#, THD.MIDI) & THD.MIDI.PRESURE) != 0			THEN CALL CLEANUP.MIDI.PRESSURE(t#);			// Store new value preserving MIDINet and pressure bits			CALL TRK.HEAD.STORE(t#, THD.MIDI, TRK.HEAD.LOOKUP(t#, THD.MIDI) & (THD.MIDI.MIDINET | THD.MIDI.PRESURE) );	/*	GET RID OF MIDI ROUTING BUT PRESERVE MIDINET AND PRESSURE BITS	*/			// If not routed anywhere now, make sure pressure bits are zero.			IF ((TRK.HEAD.LOOKUP(t#, THD.MIDI) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)				TRK.HEAD.STORE(t#, THD.MIDI, 0);							         if TRK.HEAD.LOOKUP(t#,thd.midi)=0         /* still no midi output */         then call CLEAR.MIDI.OUT.CONTROLLERS(t#); /* clear controller routings */      end;      else do;																								// Else real channel typed in			if ((TRK.HEAD.LOOKUP(t#, thd.midi) & (THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)	// If not routed anywhere, then initialize			{            if (TRK.HEAD.LOOKUP(t#, thd.midi) & THD.MIDI.MIDINET) == 0 					/* there was indeed no midi routing setup */            	call SET.MIDI.OUT.CONTROLLERS(t#);      										/* set up midi controllers */				if ((MIDI.THERE & MIDI.THERE.ORIG) != 0)            	call TRK.HEAD.STORE(t#, thd.midi, TRK.HEAD.LOOKUP(t#, thd.midi) \ midi.subsys);								else if ((MIDI.THERE & MIDI.THERE.OMS) != 0)            	call TRK.HEAD.STORE(t#, thd.midi, TRK.HEAD.LOOKUP(t#, thd.midi) \ THD.MIDI.OMS);			}						if ((TRK.HEAD.LOOKUP(t#, thd.midi) & THD.MIDI.OMS) != 0)							// Routed to OMS			{				if ((TRK.HEAD.LOOKUP(t#, thd.midi) & THD.MIDI.OMS.VPORT) != 0)				// Routed to OMS Virtual Port         		TRK.HEAD.STORE(t#, thd.midi, (TRK.HEAD.LOOKUP(t#, thd.midi) & (not THC.MIDI.OMS.VPMC)) \ (wd&THC.MIDI.OMS.VPMC));         }			else if ((TRK.HEAD.LOOKUP(t#, thd.midi) & THD.MIDI.ORIG) != 0)					// Else only makes sense if routed to original hardware         	TRK.HEAD.STORE(t#, thd.midi, (TRK.HEAD.LOOKUP(t#, thd.midi) & (not shl("17",8))) \ shl(wd&0xF,8));      end;      if t#=0   /* changing keyboard - keep MIDI button display up to date */      then call SELECT.PARAMETER(midi.l-par.l); /* select new parm */      call COMPUTE.MISC.INFO; /* make sure channel pressure stuff is correct */   end SET.MIDI.CHAN;   SET.MIDI.PMODE:  proc(t#,wd) swapable; /* sets midi pressure mode in routing word */      dcl (t#,wd) fixed;		if ((midi.there & (MIDI.THERE.OMS | MIDI.THERE.ORIG)) == 0)		// No original hardware or OMS: can't change from this screen			return;      if t#<num.kbd.tracks then t#=0;            /* if keyboard */      else do;         write(mam)=tbut.ptr;                    /* look up track number */         write(mal)=(t#-num.kbd.tracks);         /* index to trak but */         t#=read(md)&255;                        /* get track #       */      end;      if TRK.HEAD.LOOKUP(t#,thd.midi)<>0      then call CLEANUP.MIDI.PRESSURE(t#); 		 /* turn off current pressure before changing modes */      if wd<0 then do;									 // Turn off MIDI output for this track			// Store new value preserving MIDINet and pressure bits			CALL TRK.HEAD.STORE(t#, THD.MIDI, TRK.HEAD.LOOKUP(t#, THD.MIDI) & THD.MIDI.MIDINET );	/*	GET RID OF MIDI ROUTING BUT PRESERVE MIDINET BIT */         if TRK.HEAD.LOOKUP(t#,thd.midi)=0         /* still no midi output */         then call CLEAR.MIDI.OUT.CONTROLLERS(t#); /* clear controller routings */      end;      else do;			if ((TRK.HEAD.LOOKUP(t#, thd.midi) & (THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)	// If not routed anywhere, then initialize			{            if (TRK.HEAD.LOOKUP(t#, thd.midi) & THD.MIDI.MIDINET) == 0 					/* there was indeed no midi routing setup */            	call SET.MIDI.OUT.CONTROLLERS(t#);      										/* set up midi controllers */				if ((MIDI.THERE & MIDI.THERE.ORIG) != 0)            	call TRK.HEAD.STORE(t#, thd.midi, TRK.HEAD.LOOKUP(t#, thd.midi) \ midi.subsys);								else if ((MIDI.THERE & MIDI.THERE.OMS) != 0)            	call TRK.HEAD.STORE(t#, thd.midi, TRK.HEAD.LOOKUP(t#, thd.midi) \ THD.MIDI.OMS);			}         call TRK.HEAD.STORE(t#,thd.midi,(TRK.HEAD.LOOKUP(t#,thd.midi)&(not(THD.MIDI.PRESURE))) \ shl(wd,12)); /* set new mode bits */      end;      wd=TRK.HEAD.LOOKUP(t#,thd.active.midi.rtes) & (not B.PRESSURE);      if (TRK.HEAD.LOOKUP(t#,thd.midi)&THD.MIDI.PRESURE)<>0 then wd=wd\B.PRESSURE;      call TRK.HEAD.STORE(t#,thd.active.midi.rtes,wd);      call COMPUTE.MISC.INFO; /* make sure channel pressure stuff is correct */   end SET.MIDI.PMODE;   /* $page */   ADVANCE.MIDI.PMODE:  proc (t#) swapable;      dcl (t#,i) fixed;      write(mam)=trd.ptr; write(mal)=t#;      i=EXTRACT.MIDI.PMODE(read(md)); 	/* look up current pressure mode */      if i=2 then i=0;            		/* wrap from 2 back to zero */      else        i=i+1;          		/* otherwise go to next mode */      call SET.MIDI.PMODE (t#,i); 		/* store into routing word */   end ADVANCE.MIDI.PMODE;	// Midi.Input.Chan coding: (-2) == off; (-1) == all; 0-15 == 0-15   ADVANCE.MIDI.INPUT.CHAN:  proc swapable;      dcl i fixed;      write(mam)=clav.ptr;       /* need to turn off all notes */      do i=0 to max.key#;          write(mdi)=0;      end;      midi.input.chan=midi.input.chan+1;      if midi.input.chan=16 then midi.input.chan=(-2);	// Advance from 15 to off.   end ADVANCE.MIDI.INPUT.CHAN;   ADVANCE.MIDI.SYNC.IN:  proc swapable;		if ((midi.there & (MIDI.THERE.OMS | MIDI.THERE.ORIG)) == 0)		// No original hardware or OMS: can't change from this screen			return;      CALL STOP.RECD.MOVE.PLAY;      TIMING.CLOCK.ENABLE=0;                     /* DISABLE MIDI CLOCKS */		interp_init_oms_midi_sync(0);					 /* shut down OMS MIDI Sync while we make changes */      		IF EXT.CLOCK.MODE<3 THEN DO;					/*	FROM INTERNAL (OR WAS SMPTE) TO MIDI IN	*/			IF (MAX.MIDI.CHAN<>0)						/*	OK TO USE MIDI INPUT	*/			THEN EXT.CLOCK.MODE=3;						/*	GO TO MIDI INPUT SYNC	*/			ELSE IF (MAX.MIDINET.CHAN<>0)			THEN EXT.CLOCK.MODE=5;						/*	GO TO MIDINET SYNC	*/			ELSE IF (interp_is_running<>0)			THEN EXT.CLOCK.MODE=6;						/*	GO TO OMS MIDI SYNC	*/			ELSE EXT.CLOCK.MODE=0;						/* FAILED */		END;      ELSE IF (EXT.CLOCK.MODE=3) THEN DO;        /* CURRENTLY SYNCED TO INPUT JACK */         IF MAX.MIDI.CHAN>4                      /* AND OK TO USE AUX JACK */         THEN EXT.CLOCK.MODE=4;                  /* GO TO MIDI AUX SYNC */         ELSE IF MAX.MIDINET.CHAN<>0             /* OK TO USE MIDINET */         THEN EXT.CLOCK.MODE=5;                  /* GO TO MIDINET SYNC */			ELSE IF interp_is_running<>0				 /* OMS MIDI SYNC AVAIL */			THEN EXT.CLOCK.MODE=6;         ELSE EXT.CLOCK.MODE=0;                  /* GO TO INTERNAL */      END;      ELSE IF (EXT.CLOCK.MODE=4) THEN DO;        /* CURRENTLY SYNCE TO AUX JACK */         IF MAX.MIDINET.CHAN<>0             		 /* OK TO USE MIDINET */         THEN EXT.CLOCK.MODE=5;                  /* GO TO MIDINET SYNC */			ELSE IF interp_is_running<>0				 /* OMS MIDI SYNC AVAIL */			THEN EXT.CLOCK.MODE=6;         ELSE EXT.CLOCK.MODE=0;                  /* GO TO INTERNAL */		END;		ELSE IF (EXT.CLOCK.MODE=5) THEN DO;			 /* CURRENTLY SUNK TO MIDINET */			IF interp_is_running<>0				 		 /* OMS MIDI SYNC AVAIL */			THEN EXT.CLOCK.MODE=6;         ELSE EXT.CLOCK.MODE=0;                  /* GO TO INTERNAL */		END;      ELSE EXT.CLOCK.MODE=0;                     /* GO TO INTERNAL INPUT SYNC */      /* Create a system event when the sync mode changes: */      NEW.SEQ.INFO = NEW.SEQ.INFO \ 512;         /* CHANGE IN EXT SYNC MODE */      IF EXT.CLOCK.MODE=4                        /* NOW LISTENING TO THE AUX INPUT */      THEN CALL INIT.MIDI.FIFO(MIDI.SUBSYS+1,4); /* REZERO THE INPUT PORT SINCE IT MAY CONTAIN GARBAGE */				IF EXT.CLOCK.MODE=6								// if activating OMS midi sync, inform interp of our byte-pending flag		THEN CALL interp_init_oms_midi_sync(addr(ANY.OMS.MIDI.SYNC.BYTES));		      CALL CLEAR.PARAMETERS;                     /* CLEAR OTHER PARAMETER BUTTONS FOR CHANGING SYNC DELAY */      CALL DISPLAY.SEQUENCER.STATUS;             /* AND SET LIGHTS CORRECTLY, AS WELL AS MOTION CONTROLS FROM ABOVE CALL TO STOP.RECD.MOVE.PLAY  */   end ADVANCE.MIDI.SYNC.IN;   ADVANCE.MIDI.ECHO:  proc swapable;      MIDI.ECHO.DISABLED = MIDI.ECHO.DISABLED XOR 1;   END ADVANCE.MIDI.ECHO;   /* $SUBTITLE  Routines to Display Field Values */   DISPLAY.MIDI.OUTPUT:  proc (t#) swapable;  /* display the midi output routing */      dcl (t#,val,i) fixed;      if t#<>1 then do;                       /* exclude split keyboard */         write(mam)=trd.ptr; write(mal)=t#;   /* get the output routing for the specified track */         val=EXTRACT.MIDI.OUTPUT(read(md));         if t#=0 then i=0;         else i=t#-num.kbd.tracks+1;         if i<21         then call cpos(kbd.loc+i,24);       /* position cursor for track positon (0-20) */         else call cpos(kbd.loc+(i-12),65);  /* track position (21-32) */			if (val > THD.MIDI.OMS)					// Routed to OMS virtual port			{				call ps('V');				if (val >= THD.MIDI.OMS+10)            	call print.parm(val-THD.MIDI.OMS,0,0,2,0);  // Display with 1-based index            else            {            	call print.parm(val-THD.MIDI.OMS,0,0,1,0);  // Display with 1-based index            	call ps(' ');            }			}						else if (val == THD.MIDI.OMS)			// Routed to OMS				call ps('OMS');						else if (val == (-1))					// Routed to nowhere         	call ps('   ');			else			{            call print.parm(val+1,0,0,2,0);  // Display with 1-based index				call ps(' ');							// Erase 's' from OMS			}      end;   end DISPLAY.MIDI.OUTPUT;   DISPLAY.MIDI.CHAN:  proc (t#) swapable;  /* display the midi output channnel number */      dcl (t#,val,i) fixed;      if t#<>1 then do;                     /* exclude split keyboard */         write(mam)=trd.ptr; write(mal)=t#; /* get the output channel */         val=EXTRACT.MIDI.CHAN(t#, read(md));         if t#=0 then i=0;         else i=t#-num.kbd.tracks+1;         if i<21         then call cpos(kbd.loc+i,29);      /* position cursor for track positon (0-20) */         else call cpos(kbd.loc+(i-12),70); /* track position (21-32) */         if val<>(-1) then do;              /* if the value is valid */            val=val+1;            call print.parm(val,0,0,2,0);   /* print it */         end;         else call ps('  ');                /* otherwise leave it blank */      end;                                  /* of exclude split keyboard */   end DISPLAY.MIDI.CHAN;   DISPLAY.MIDI.PMODE:  proc (t#) swapable;  /* display the midi pressure mode */      dcl (t#,val,i) fixed;      if t#<>1 then do;                     /* exclude split keyboard */         write(mam)=trd.ptr; write(mal)=t#;     /* get the pressure mode */         val=EXTRACT.MIDI.PMODE(read(md));         if t#=0 then i=0;         else i=t#-num.kbd.tracks+1;         if i<21         then call cpos(kbd.loc+i,34);                /* position cursor for track positon (0-20) */         else call cpos(kbd.loc+(i-12),75);           /* track position (21-32) */         if val=(-1) then val=0;         do case val;            call ps('    ');            call ps('INDV');            call ps('CHAN');         end;      end;                   /* of exclude split keyboard */   end DISPLAY.MIDI.PMODE;   /* $PAGE */   DISPLAY.MIDI.SYNC.IN: proc swapable;      dcl mode fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons; /* get the midi input sync mode */      mode=read(md);      call cpos(sync.iny.prompt,sync.inx);      if      mode<3 then call ps('OFF  ');    /* using internal or other external sync mode */      else if mode=3 then call ps('INPUT');    /* synching to INPUT jack */      else if mode=4 then call ps('AUX  ');    /* synching to AUX   jack */      else if mode=5 then call ps('MNET ');    /* synching to MIDInet    */      else if mode=6 then call ps('OMS  ');    /* synching to OMS Midi   */   end DISPLAY.MIDI.SYNC.IN;   DISPLAY.MIDI.SYNC.OUT: proc swapable;      dcl mode fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons+1; /* get the sync out mode */      mode=read(md);      call cpos(sync.outy.prompt, sync.outx);		if ((mode && (MIDI.SYNC.ORIG | MIDI.SYNC.OMS)) == 0)			call ps('OFF');		else if ((mode && MIDI.SYNC.ORIG) != 0)      	call print.parm(mode,0,0,3,0); /* display output we will send real-time bytes to */		else if ((mode && MIDI.SYNC.OMS) != 0)			call ps('OMS'); 		else      	print.parm(mode,0,0,3,0); /* display output we will send real-time bytes to */   end DISPLAY.MIDI.SYNC.OUT;	// Midi.Input.Chan coding: (-2) == off; (-1) == all; 0-15 == 0-15   DISPLAY.MIDI.INPUT.CHAN: proc swapable;      dcl ch fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons+2; /* get the input channel */      ch=read(md);      call cpos(midi.in.chany.prompt,midi.in.chanx);      if      ch==(-2) then call ps('OFF'); 	/* ignore midi input */      else if ch==(-1) then call ps('ALL'); 	/* in omni mode */      else call print.parm(ch+1,0,0,3,0); 	/* display the 1-based channel we are listening to */   end DISPLAY.MIDI.INPUT.CHAN;   DISPLAY.MIDI.ECHO: proc swapable;      dcl mode fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons+3; /* get the midi echo mode */      mode=read(md);      call cpos(midi.echoy.prompt,midi.echox);      if mode=0 then call ps('ON ');      else           call ps('OFF');   end DISPLAY.MIDI.ECHO;   DISPLAY.MIDI.FORMAT: proc swapable;      dcl mode fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons+4; /* get the midi sync out type */      mode=read(md);      call cpos(midi.formaty.prompt,midi.formatx);      if mode=0 then call ps('CLK');      else           call ps('MTC');   end DISPLAY.MIDI.FORMAT;   DISPLAY.OMS.ONOFF: proc swapable;      dcl mode fixed;      write(mam)=trd.ptr; write(mal)=num.kbd.tracks+num.track.buttons+5; /* get the oms on off state */      mode=read(md);      call cpos(oms.onoffy.prompt,oms.onoffx);      if mode=0 then call ps('OFF');      else           call ps('ON ');   end DISPLAY.OMS.ONOFF;   /* $SUBTITLE  Code Prints Name of Track TName and Take Snap Shot of Track Names */   MIDI.TRACK.ROUTING.SNAP.SHOT:  proc swapable; /* takes snap shot of keyboard and sequencer routing for 32 buttons*/      dcl (i,j,k)    fixed;      do i=0 to num.kbd.tracks+num.track.buttons-1;   /* loop over tracks in system */         if i<num.kbd.tracks then do;                 /* keyboard routing */            j=TRK.HEAD.LOOKUP(0,thd.midi);            write(mam)=trd.ptr;            write(mal)=i;            write(md )=j;         end;         else do;                                     /* sequencer routing */            write(mam)=tbut.ptr;            write(mal)=(i-num.kbd.tracks);            /* index to trak but */            j=read(md)&255;                           /* get track #       */            j=TRK.HEAD.LOOKUP(j,thd.midi);            write(mam)=trd.ptr;            write(mal)=i;            write(md )=j;         end;      end;      write(mam)=trd.ptr;      write(mal)=num.kbd.tracks+num.track.buttons;      write(mdi)=ext.clock.mode;         										/* midi input sync mode */      write(mdi)=midi.sync.out & (MIDI.SYNC.OMS | MIDI.SYNC.ORIG); 	/* midi output sync mode */      write(mdi)=midi.input.chan;        										/* store midi input channel too */      write(mdi)=midi.echo.disabled;     										/* store midi echo */      write(mdi)=midi.sync.is.tc;		  										/* store sync type */      write(mdi)=OMS.MIDI.ENABLED;   end MIDI.TRACK.ROUTING.SNAP.SHOT;   /* $SUBTITLE  Routine to Fill In Midi Routing Display */   FILL.MIDI.SCREEN:  proc fixed swapable; /* fills in current routing */      dcl change  fixed;      dcl (i,j,k) fixed;      dcl x       fixed;      if inc.midi=0 then return;      call MIDI.TRACK.ROUTING.SNAP.SHOT; /* take a snap shot of the current routing */      call TRACK.NUMBER.SNAP.SHOT;       /* take a snap sot of the current track numbers */      call TIMBRE.NAME.SNAP.SHOT;        /* take a snap shot of the timbre names on the current tracks */      change=0;                     /* assume no changes will take place */      /* compare midi input channel and midi input/output sync mode */      do i=0 to 5;         j=i+num.kbd.tracks+num.track.buttons;       /* get pointer */         write(mam)=trd.ptr;   write(mal)=j;         /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+3; write(mal)=j;         /* look at display */         if x<>read(md) then do;                     /* if there is a difference */            change=1;                                /* indicate that a change must be made */            do case (i);               call DISPLAY.MIDI.SYNC.IN;               call DISPLAY.MIDI.SYNC.OUT;               call DISPLAY.MIDI.INPUT.CHAN;               call DISPLAY.MIDI.ECHO;               call DISPLAY.MIDI.FORMAT;               call DISPLAY.OMS.ONOFF;            end;         end;      end;      do i=0 to num.kbd.tracks+num.track.buttons-1;   /* loop over tracks in system */         /* compare track numbers */         write(mam)=trd.ptr;   write(mal)=track.numbers.offset+i;         x=read(md);         write(mam)=trd.ptr+3; write(mal)=track.numbers.offset+i;         if x<>read(md) then do;            change=1;            call PRINT.TNUM(i);           end;        /* compare timbre names on current track */         x=0;                       /* assume both names are the same */         j=i*tname.length;          /* compute pointer */         write(mam)=trd.ptr+1+shr(j,8); write(mal)=j&255; /* look at snap shot */         do k=0 to tname.length-1;                misc.buf(k)=read(mdi);         end;         write(mam)=trd.ptr+4+shr(j,8); write(mal)=j&255;         do k=0 to tname.length-1;            if misc.buf(k)<>read(mdi) then x=1;   /* compare snap shot to display area */         end;         if (x<>0) and (i<>1) then do;            /* names differ and not split keyboard - timbre name update necessary */            change=1;            if i=0 then j=0;            else j=i-num.kbd.tracks+1;            /* map to physical location of track */            if j<21             then call cpos(kbd.loc+j,5);          /* set to instrument name location for left group*/            else call cpos(kbd.loc+(j-12),47);             call PRINT.TIM.NAME(i);  /* print instrument name on track exclude split keyboard */         end;         /* $page */         /* compare midi track routing information */         write(mam)=trd.ptr;   write(mal)=i;         /* look at snap shot */         x=read(md);         write(mam)=trd.ptr+3; write(mal)=i;         /* look at display */         x=x-read(md);         if x<>0 then do;                            /* if there is a difference */            change=1;                                /* indicate that a change must be made */            call DISPLAY.MIDI.OUTPUT(i);            call DISPLAY.MIDI.CHAN(i);            call DISPLAY.MIDI.PMODE(i);         end;               end;      /* copy values from snap shot area to display area when done */      if change<>0                        /* did some kind of update */      then call COPY.EXT.MEM.SEC(trd.ptr,trd.ptr+3,3);      return change;   end FILL.MIDI.SCREEN;   /* $SUBTITLE  Routine to Parse New Midi Routing Assignments */   MIDI.DEPOSIT:  proc swapable;      dcl (i,num,neg) fixed;      dcl ch          fixed;      dcl live        fixed;      if token(0)=0 then return;     /* no string - no change */      live=0;     /* assume not a live track */      if (route.pos>0) and (field.pos=0) and ((byte(token,0)=asc.l) or (byte(token,0)=lower.l)) then do;   /* if L for Live track */         i=1;         num=0;         do while i<token(0); /* find the live track number */            ch=byte(token,i);            load num; mul 10;            num=res+(ch-asc.0);            i=i+1;         end;         num=num+200;   /* convert to live track number between 201 and 216 */         live=1;                    /* indicate that it is a live track */      end;		else if (route.pos<0  && field.pos == 1 && ((byte(token,0)=asc.o) or (byte(token,0)=lower.o)))		// Midi SYNC out to OMS			num = THD.MIDI.OMS;		else if (route.pos<0  && field.pos == 2 && ((byte(token,0)=asc.a) or (byte(token,0)=lower.a)))		// Midi Input from all channels			num = 0;		else if (route.pos<0  && field.pos == 2 && ((byte(token,0)=asc.n) or (byte(token,0)=lower.n)))		// Midi Input from No channels			num = -1;		else if (route.pos<0  && field.pos == 2 && ((byte(token,0)=asc.o) or (byte(token,0)=lower.o)))		// Midi Input Off			num = -1;		else if (route.pos>=0 && field.pos == 1 && ((byte(token,0)=asc.o) or (byte(token,0)=lower.o)))		// Midi Output out to OMS			num = THD.MIDI.OMS;		else if (route.pos>=0 && field.pos == 1 && ((byte(token,0)=asc.v) or (byte(token,0)=lower.v)))		// Midi Output out to Virtual Port		{         i=1;         num=0;         do while i<token(0); /* find the virtual port number */				ch=byte(token,i);         	if (ch >= asc.0 && ch <= asc.9)         	{					load num; mul 10;					num=res+(ch-asc.0);				}            i=i+1;         end;                  if ((num < 1) or (num > 64))				num = THD.MIDI.OMS;			else				num = THD.MIDI.OMS + num;		}		else if (route.pos>=0 && field.pos == 3 && ((byte(token,0)=asc.i) or (byte(token,0)=lower.i)))		// "i" for individual pressure			num = 1;		else if (route.pos>=0 && field.pos == 3 && ((byte(token,0)=asc.c) or (byte(token,0)=lower.c)))		// "c" for channel pressure			num = 2;      else			num=CONV.STR.TO.FIXED(token,0,1);     /* convert signed token to a numeric value */		// Change MIDI Sync Output, MIDI Input Channel, MIDI Echo mode by typing      if route.pos<0      then do case (field.pos);    /* enter values for misc fields */         ;																/* CASE 0:	midi sync input  mode -- not used (user toggles through modes) */         do;															/* CASE 1:	midi sync output mode */            call stop.recd.move.play;            				if (num == THD.MIDI.OMS)											// MIDI Sync Out to OMS				{					if ((midi.there & MIDI.THERE.OMS) == 0)               	call overflow.error;					else						midi.sync.out = (midi.sync.out & MIDI.SYNC.MIDINET) | MIDI.SYNC.OMS;				}								else																		// MIDI Sync Out to original hardware output				{					if num>max.midi.chan then num=max.midi.chan; 	 		/* limit to number of outputs */            	if num<=0            then num=0;   					 		/* means don't send real-time info out */           	   midi.sync.out=(midi.sync.out&MIDI.SYNC.MIDINET)\num;  /* don't change upper byte here (MIDInet sync out) */				}				if ((midi.sync.out & (MIDI.SYNC.OMS | MIDI.SYNC.ORIG)) == 0)				{					DISPLAY.MTC = 0;	  										 		/* TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT */					CLEAR.LOWER();				}				else if (midi.sync.is.tc != 0)							 		/* send out full frame when changing */				{					MIDI.FULL.FRAME(play.time.msb, play.time.lsb);	 		/* sync output routing					  */									DO CASE (SM.MODE);                      	   /* PRESENT MTC MODE */						CALL EMIT.STRING(16,'Drop Frame MTC');						CALL EMIT.STRING(16,'Non Drop   MTC');						CALL EMIT.STRING(16,'25 Frame   MTC');						CALL EMIT.STRING(16,'24 Frame   MTC');						CALL EMIT.STRING(16,'NTSC 30 Fr MTC');					END;										SUPRESS.BEAT.DISPLAY=1;                   	/* STOP BEAT DISPLAYS MOMENTARILY */					BEAT.DISPLAY.TIME=REAL.MILLISECONDS;      	/* HOLD DISPLAY FOR 5 SECONDS */					LOWER.DISP=SMODE.DISP;                    	/* INDICATE SMODE DISPLAYED   */				}								if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))		// Update display if showing midi clock/midi tc output					call display.par();            /* Create a system event when the midi output sync format */            /* changes as well:                                       */            new.seq.info = new.seq.info \ 512;         end;         do;															/* CASE 2:	midi input channel */				num = num - 1;				//	convert to zero-based: -2, -1, or 0 through 15				if (num > 15)	num = 15;				midi.input.chan = num;				            write(mam)=clav.ptr;            do i=0 to max.key#;		/* need to turn off all notes  */               write(mdi)=0;            end;         end;         midi.echo.disabled=midi.echo.disabled XOR 1;		/* CASE 3:	toggle state on ANY input! */			;																/* CASE 4:	output type: must use space */      end;		// Change MIDI Output, Channel, Presure by typing      else do;         if ((field.pos=1) or (field.pos=2))						// MIDI Output or Channel: use 1-based index for user; use 0-based index internally         {																	// Nonzero value entered for MIDI Output or MIDI Channel				if (field.pos == 1 && num >= THD.MIDI.OMS)		// Typing OMS or Virtual Port Number for MIDI Output; use THD.MIDI.OMS					;				else															// Else typed in 1-x or 0				{					if (field.pos == 1 && num > max.midi.chan)						num = max.midi.chan;											if (field.pos == 2 && num > 16)						num = 16;											num = num - 1;											// Map 0 to (-1) (off) and use 0-based index for actual hardware outputs from here on				}		   }           else if (field.pos=3)										// changing pressure field by typing			{				if (num < 0) num = 0;				if (num > 2) num = 2;			}			else																// Leave routing entries unchanged				;				         do case (field.pos);      /* branch according to the current column on display */            do;               if (((num<1) or (num>200)) and (live=0))               or ((live<>0) and ((num<201) or (num>216)))               then call overflow.error;               else call SET.TRACK.NUMBER(route.pos, num);            end;				do;					if (num >= THD.MIDI.OMS && ((midi.there & MIDI.THERE.OMS) == 0))               	call overflow.error;					else		            call SET.MIDI.OUTPUT(route.pos, num);      		end;		      call SET.MIDI.CHAN      (route.pos, num);            call SET.MIDI.PMODE     (route.pos, num);         end;      end;      token(0)=0;                    /* reset token to zero length */      call FILL.MIDI.SCREEN;         /* update display to reflect change */      call POS.TRACK.CURSOR;   end MIDI.DEPOSIT;