/*	:SYNSOU:ROUTMOD:ROUTSOUB  $Title  General Routing Display RoutinesModified:2000/11/17 - TY  - Fixed bug: When zeroing the routing using the delete key, the VK window did not update.1997/05/07 - CJ  - Added support for midi TC out1993/08/16 - PF  - Added disp.multi.errs1991/02/07 - MWH - Combine 3200, 6400 and 9600 RTP's1989/08/24 - PF  - Support for MIDInet Sync out path in upper byte of MIDI.SYNC.OUT1989/08/24 - PF  - Changed MIDI.THERE to allow for MIDInet bit1989/05/15 -PF,TSS-Fixed bug in logic to set NEW SEQ INFO for MIDI sync out change1989/03/29 - TSS - Fixed bug where MIDI INPUT field not refreshing properly1989/01/13 - PF  - used NEW SEQ INFO for MIDI sync out change1988/10/04 - tss - Minor change to multi-chan page to support Mono DAC voice cards1988/06/15 - cj  - Fixed bug with space bar in button field1987/12/17 - MWH - Merge poly updates with N-Final plus AEE sources1987/12/10 - MWH - Allow poly bin change even if no multi-channel hardware1987/09/08 - MWH - Fix minor bug in toggling between midi and multi1987/09/03 - MWH - Add MIDI echo to screen1987/09/01 - MWH - Add poly bin column to multichannel1987/02/26 - BSW - Part of the Routing Display Module*/	POS.FIELD.TRACK.CURSOR: proc swapable;	/*	echos token characters typed at y,x logical coordinates	*/		dcl i	fixed;		if route.pos=0 then i=0;	/*	map to keyboard or tracks, excluding split keyboard	*/		else i=route.pos-num.kbd.tracks+1;		/*	MIDI display and at top of screen	*/		if inc.midi and (routing.display.type=1) and (route.pos<0) then do;			do case (field.pos);				call cpos(sync.iny.prompt,			sync.inx);				call cpos(sync.outy.prompt,		sync.outx);				call cpos(midi.in.chany.prompt,	midi.in.chanx);				call cpos(midi.echoy.prompt,		midi.echox);				call cpos(midi.formaty.prompt,	midi.formatx);				call cpos(oms.onoffy.prompt,		oms.onoffx);			end;		end;		/*	Normal fields within the screen	*/		else do case (field.pos);			do;						/*	0: track number	*/				if group.pos=0				then call cpos(kbd.loc+i,1);				else call cpos(kbd.loc+(i-12),42);			end;			do;						/*	1: multi=left channel; midi=output channel	*/				if group.pos=0				then call cpos(kbd.loc+i,24);				else call cpos(kbd.loc+(i-12),65);			end;			do;						/*	2: multi=right channel; midi=channel	*/				if group.pos=0				then call cpos(kbd.loc+i,29);				else call cpos(kbd.loc+(i-12),70);			end;			do;						/*	3: multi=poly bin; midi=send pressure	*/				if group.pos=0				then call cpos(kbd.loc+i,34);				else call cpos(kbd.loc+(i-12),75);	/*	send pressure	*/			end;		end;	end POS.FIELD.TRACK.CURSOR;	POS.TRACK.CURSOR: proc swapable;	/*	if nothing typed positions cursor within field	*/		/*	takes previous value out of reverse video and puts current in reverse video	*/		dcl i	fixed;		if inc.mult and (routing.display.type=0) then do;	/*	MULTICHANNEL DISPLAY	*/			if  (multi.there	  = 0)	/*	if no multi hardware	*/			and (DTD.Num.Voices = 0)	/*	and no dtd voices		*/			then do;							/*	then no business being on screen	*/				if (err.displayed<>0) then call remove.err;				call cpos(23,0);				call REVERSE.VIDEO(1);				call DRAW.MESSAGE('NOTE: No Multichannel Distributor in System.');				call REVERSE.VIDEO(0);				call PRINT.CCAT;			end;			else if multi.errs<>0 then do;				if disp.multi.errs<>0 then do;					if (err.displayed<>0) then call remove.err;					call cpos(23,0);					call REVERSE.VIDEO(1);					call ps('NOTE:  '); call pnum(multi.errs,0);					call ps(' Channels not connected to Multichannel Distributor                   ');					call REVERSE.VIDEO(0);				end;			end;			if new.pan<>0 then do;									/*	only allowed on velocity keyboard	*/				if  (trout.trk#+num.kbd.tracks<>route.pos)	/*	parm is different	*/				and (route.pos=prev.route.pos)					/*	but not changed from terminal	*/				and (token(0)=0) then do;							/*	and not typing too	*/					if (trout.trk#<>-1) or (route.pos<>0) then do;						if trout.trk#=-1						then route.pos=0;						else route.pos=trout.trk#+num.kbd.tracks;	/*	new trk selected from kbd	*/						prev.group.pos=group.pos;						if route.pos>21						then group.pos=1;						else group.pos=0;						if held.trinf.button then field.pos=1;		/*	changing right routing only	*/					end;				end;			end;		end;	/*	of if multichannel display	*/		else if inc.midi then do;						/*	MIDI DISPLAY	*/			if (midi.there & (MIDI.THERE.ORIG | MIDI.THERE.OMS)) == 0 then do;	/*	no old midi hw or oMS in system	*/				if (err.displayed<>0) then do;					call remove.err;					call PRINT.CCAT;				end;				call cpos(23,0);				call REVERSE.VIDEO(1);				call ps('NOTE: No Midi Hardware in System.');				call REVERSE.VIDEO(0);			end;		end;		do i=0 to 1;									/*	first do previous then do current	*/			if (i<>0) or								/*	if current value or have changed positions	*/			((prev.group.pos<>group.pos) or			(prev.route.pos<>route.pos) or			(prev.field.pos<>field.pos)) then do;				if vt100<>0 then call reverse.video(i);	/*	print value in reverse video	*/				if token(0)<>0 then do;				/*	if something typed	*/					call POS.FIELD.TRACK.CURSOR;	/*	position the cursor at the beginning of the appropriate field	*/					call ps(token);					/*	echo the characters typed	*/				end;				else do;									/*	if changing fields	*/					if inc.mult and (routing.display.type=0) then do;	/*	MULTICHANNEL DISPLAY	*/						do case (prev.field.pos);							call PRINT.TNUM(prev.route.pos);					/*	track number	*/							call PRINT.ROUTE.CHANNEL(prev.route.pos,0);	/*	left channel	*/							call PRINT.ROUTE.CHANNEL(prev.route.pos,1);	/*	right channel	*/							call PRINT.POLY.BIN(prev.route.pos);			/*	poly bin			*/						end;					end;	/*	of if multichannel display	*/					else if inc.midi then do;			/*	MIDI DISPLAY	*/						if prev.route.pos<0 then do;	/*	if MIDI display and at top of screen	*/							do case (prev.field.pos);								call DISPLAY.MIDI.SYNC.IN;		/*	display midi input synchronization	*/								call DISPLAY.MIDI.SYNC.OUT;	/*	display external sync mode	*/								call DISPLAY.MIDI.INPUT.CHAN;	/*	display input channels		*/								call DISPLAY.MIDI.ECHO;			/*	display midi echo status	*/								call DISPLAY.MIDI.FORMAT;		/*	display midi sync format	*/								call DISPLAY.OMS.ONOFF;			/* display oms input on off   */							end;						end;						else do;	/*	else depending upon which box, print track numbers 1-20 or 21-32	*/							do case (prev.field.pos);								call PRINT.TNUM(prev.route.pos);				/*	track number	*/								call DISPLAY.MIDI.OUTPUT(prev.route.pos);	/*	midi output channel	*/								call DISPLAY.MIDI.CHAN(prev.route.pos);	/*	midi channel	*/								call DISPLAY.MIDI.PMODE(prev.route.pos);							end;						end;					end;									/*	otherwise midi display	*/					if inc.mult and (routing.display.type=0)	/*	if multichannel display	*/					then call SELECT.MULTI.PARM;	/*	select new track from terminal	*/					prev.group.pos=group.pos;		/*	update values	*/					prev.route.pos=route.pos;					prev.field.pos=field.pos;				end;			end;	/*	of if current value or have changed positions	*/		end;		/*	of first previous then current	*/		if vt100=0 then do;							/*	if an ADM terminal put cursor at beginning of field	*/			if token(0)=0			then call POS.FIELD.TRACK.CURSOR;		end;		else call reverse.video(0);				/*	otherwise turn off reverse video	*/	end POS.TRACK.CURSOR;	/*	$Subtitle Update Routines for Screen Display	*/	PRINT.DIRECTIONS: proc swapable;		call cpos(dir.y1,dir.x1);		call ps('1.  Move cursor with arrow keys');		call cpos(dir.y1+1,dir.x1);		call ps('2.  Press space bar to ');		call cpos(dir.y1+2,dir.x1+4);		call ps('increment values');	end PRINT.DIRECTIONS;	DRAW.TRACK.BUTTON.TIC.MARKS: proc swapable;	/*	draws tic marks to identify groups of 8 buttons	*/		dcl (i,j)	fixed;		do i=0 to 7;			do case (i);				do;			/*	0: keyboard	*/					call cpos(1,0);					if vt100<>0					then call DRAW.CORNER(c.l.l);					else call pc(asc.min);				end;				do;			/*	1: track 1	*/					call cpos(2,0);					if vt100<>0					then call DRAW.CORNER(c.u.l);					else call pc(asc.min);				end;				do;			/*	2: track 8	*/					call cpos(9,0);					if vt100<>0					then call DRAW.CORNER(c.l.l);					else call pc(asc.min);				end;				do;			/*	3: track 9	*/					call cpos(10,0);					if vt100<>0					then call DRAW.CORNER(c.u.l);					else call pc(asc.min);				end;				do;			/*	4: track 16	*/					call cpos(17,0);					if vt100<>0					then call DRAW.CORNER(c.l.l);					else call pc(asc.min);				end;				do;			/*	5: track 17	*/					call cpos(18,0);					if vt100<>0					then call DRAW.CORNER(c.u.l);					else call pc(asc.min);				end;				do;			/*	6: track 24	*/					call cpos(13,41);					if vt100<>0					then call DRAW.CORNER(c.l.l);					else call pc(asc.min);				end;				do;			/*	7: track 25	*/					call cpos(14,41);					if vt100<>0					then call DRAW.CORNER(c.u.l);					else call pc(asc.min);				end;			end;		end;	end DRAW.TRACK.BUTTON.TIC.MARKS;	DRAW.MULTI.MIDI.OUT: proc (y1,x1,y2,x2)swapable;	/*	draw multidistributor and midi display outlines	*/		dcl (x1,x2)	fixed;	/*	left and right coordinates	*/		dcl (y1,y2)	fixed;	/*	top and bottom coordinates	*/		call DRAW.BOX (y1,x1,y2,x2);	/*	draw multidistributor and midi display box outline	*/		call cpos(y1,x1+4);	if vt100<>0 then call DRAW.TEE(t.top);	/*	draw track division	*/		call DRAW.VER(y1+1,x1+4,y2-1);		call cpos(y2,x1+4);	if vt100<>0 then call DRAW.TEE(t.bot);		call cpos(y1,x1+22);	if vt100<>0 then call DRAW.TEE(t.top);	/*	draw instrument name division	*/		call DRAW.VER(y1+1,x1+22,y2-1);		call cpos(y2,x1+22);	if vt100<>0 then call DRAW.TEE(t.bot);	end DRAW.MULTI.MIDI.OUT;	UPDATE.TRACK.BOXES: proc(y1,x1,y2,x2,box.type) swapable;	/*	draw boxes for two sets of 16 tracks	*/		dcl (x1,x2)		fixed;	/*	left and right coordinates	*/		dcl (y1,y2)		fixed;	/*	top and bottom coordinates	*/		dcl box.type	fixed;	/*	first(0) or second(1) set of 16 tracks	*/		dcl (i,j,k)		fixed;		if inc.mult and (routing.display.type=0) then do;	/*	MULTICHANNEL DISPLAY	*/			if prev.routing.display.type=1 then do;			/*	if previously the midi display	*/				do i=y1+1 to y2-1;					call cpos(i,x1+24);					do j=0 to 13;		/*	erase the contents of the midi routing	*/						call pc(sp);					end;				end;				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at top		*/				call cpos(y2,x1+27);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at bottom	*/				call cpos(y1,x1+32);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at top		*/				call cpos(y2,x1+32);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at bottom	*/				call DRAW.VER(y1+1,x1+27,y2-1);				call DRAW.VER(y1+1,x1+32,y2-1);				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.TEE(t.top);				call cpos(y2,x1+27);		if vt100<>0 then call DRAW.TEE(t.bot);				call cpos(y1,x1+32);		if vt100<>0 then call DRAW.TEE(t.top);				call cpos(y2,x1+32);		if vt100<>0 then call DRAW.TEE(t.bot);				if box.type=0 then do;					call cpos(y1,x1+23);					if mono_voices_present		/*	for Mono DAC Voice Cards	*/					then call ps('L/M    R   Poly');					else call ps('Left Right Poly');				end;			end;			else do;				call DRAW.MULTI.MIDI.OUT(y1,x1,y2,x2);				call DRAW.VER(y1+1,x1+27,y2-1);				call DRAW.VER(y1+1,x1+32,y2-1);				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.TEE(t.top);				call cpos(y2,x1+27);		if vt100<>0 then call DRAW.TEE(t.bot);				call cpos(y1,x1+32);		if vt100<>0 then call DRAW.TEE(t.top);				call cpos(y2,x1+32);		if vt100<>0 then call DRAW.TEE(t.bot);				if box.type=0 then do;					call cpos(y1,x1+6);	call ps('Instrument Name');					call cpos(y1,x1+23);					if mono_voices_present		/*	for Mono DAC Voice Cards	*/					then call ps('L/M    R   Poly');					else call ps('Left Right Poly');					call cpos(y1+1,x1+1);call ps('KBD');				end;			end;		end;		else if inc.midi then do;									/*	MIDI DISPLAY	*/			if prev.routing.display.type<>0 then do;				call DRAW.MULTI.MIDI.OUT(y1,x1,y2,x2);				if box.type=0 then do;					call cpos(y1,x1+6);	call ps('Instrument Name');					call cpos(y1,x1+23);	call ps(' Out Chan Pres ');					call cpos(y1+1,x1+1);call ps('KBD');				end;				else do;					call cpos(y1,x1+27); if vt100<>0 then call DRAW.TEE(t.top);					call cpos(y1,x1+32); if vt100<>0 then call DRAW.TEE(t.top);				end;			end;			else do;				do i=y1+1 to y2-1;					call cpos(i,x1+24);					do j=0 to 13;		/*	erase the contents of the multichannel routing	*/						call pc(sp);					end;				end;				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at top	*/				call cpos(y2,x1+32);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at bottom	*/				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at top	*/				call cpos(y2,x1+32);		if vt100<>0 then call DRAW.HOR(1);	/*	replace erased T at bottom	*/			end;			call DRAW.VER(y1+1,x1+27,y2-1);			call cpos(y2,x1+27);			if vt100<>0 then call DRAW.TEE(t.bot);			call DRAW.VER(y1+1,x1+32,y2-1);			call cpos(y2,x1+32);			if vt100<>0 then call DRAW.TEE(t.bot);			if box.type=0 then do;				call cpos(y1,x1+23);	call ps(' Out Chan Pres ');			end;			else do;				call cpos(y1,x1+27);		if vt100<>0 then call DRAW.TEE(t.top);				call cpos(y1,x1+32);		if vt100<>0 then call DRAW.TEE(t.top);			end;		end;						/*	otherwise midi screen	*/	end UPDATE.TRACK.BOXES;	UPDATE.TRACK.SCREEN: proc swapable;	/*	updates screen display depending upon routing display type	*/		dcl (i,j)	fixed;		if prev.routing.display.type<>-1 then do;	/*	if changed displays indirectly	*/			do i=0 to 8;									/*	erase the directions and non-track fields	*/				call erase.rest.of.line(i,39);			end;		end;		call EXTSET(trd.ptr+3,0,256,-3);	/*	force an update of the routings by filling display area with impossible values	*/		if inc.mult and (routing.display.type=0) then do;	/*	Multichannel display	*/			call cpos(routing.titley,routing.titlex);			call ps('MULTICHANNEL ROUTING DISPLAY');			call PRINT.DIRECTIONS;			call cpos(avail.outputy.prompt,avail.outputx.prompt);			call ps('3.  M/C Outputs:');			call cpos(avail.outputy.prompt+1,avail.outputx.prompt);			call ps('    DTD Outputs:');			call cpos(avail.outputy.prompt,avail.multi.outputx);			call pnum(multi.max,0);			call cpos(avail.outputy.prompt+1,avail.multi.outputx);			call pnum(Dtd.Num.Voices,0);			call cpos(poly.outputy.prompt,poly.outputx.prompt);			call ps('Poly Bins:');			call cpos(poly.outputy.prompt,poly.multi.outputx);			call pnum(polynums,0);			field.max=3;							/*	track, left and right routing	*/			if (route.pos<0) then do;			/*	check for arriving at multi screen from midi screen with cursor in sync fields	*/				prev.group.pos	=  1;				prev.route.pos	= 22;				prev.field.pos	=  0;				group.pos		=  1;				route.pos		= 22;				field.pos		=  0;			end;			else if field.pos>field.max then do;	/*	check for arriving at multi screen with cursor field too large	*/				prev.field.pos	= field.max;				field.pos		= field.max;			end;			if (route.pos=0) and (field.pos=0)		/*	skip track # field if on keyboard line in all cases	*/			then do;				prev.field.pos	= 1;				field.pos		= 1;			end;			if route.pos<num.kbd.tracks	/*	set track routing number to track on screen	*/			then trout.trk#=(-1);			else trout.trk#=route.pos-num.kbd.tracks;		end;		else if inc.midi then do;									/*	Midi display	*/			call cpos(routing.titley,routing.titlex);			call ps('    MIDI ROUTING DISPLAY    ');			call PRINT.DIRECTIONS;			call cpos(avail.outputy.prompt, avail.outputx.prompt);			call ps('3.  Available Outputs:');			call cpos(avail.outputy.prompt, avail.midi.outputx);			if (midi.there & (MIDI.THERE.OMS + MIDI.THERE.ORIG)) == MIDI.THERE.OMS				call ps('OMS Only');			else if (midi.there & MIDI.THERE.OMS) == 0				call pnum(max.midi.chan,0);			else			{				call pnum(max.midi.chan,0);				call ps(' + OMS');			}			call cpos(sync.iny.prompt, sync.inx.prompt);			call ps('Sync In: ');			call cpos(midi.in.chany.prompt, midi.in.chanx.prompt);			call ps('Inputs:');			call cpos(sync.outy.prompt, sync.outx.prompt);			call ps('Sync Out:');			call cpos(midi.formaty.prompt, midi.formatx.prompt);			call ps('Clock Type:');			call cpos(midi.echoy.prompt, midi.echox.prompt);			call ps('Echo:');			call cpos(oms.onoffy.prompt ,oms.onoffx.prompt);			call ps('OMS Input:');			if (route.pos < 0)				field.max = 5;			else				field.max = 3;			if (route.pos=0) and (field.pos=0)	/*	skip track # field if on keyboard line in all cases	*/			then do;				prev.field.pos	= 1;				field.pos		= 1;			end;			if field.pos>field.max then do;				prev.field.pos	= field.max;				field.pos		= field.max;			end;			if route.pos<num.kbd.tracks	/*	set track routing number to track on screen	*/			then trout.trk#=(-1);			else trout.trk#=route.pos-num.kbd.tracks;		end;		call UPDATE.TRACK.BOXES(0, 0,22,38,0);	/*	draw box for tracks KBD-20	*/		call UPDATE.TRACK.BOXES(9,41,22,79,1);	/*	draw box for tracks 21-32	*/		call DRAW.TRACK.BUTTON.TIC.MARKS;		/*	draw tic marks to identify groups of 8 buttons	*/		prev.routing.display.type=routing.display.type;		/*	update routing display types	*/	end UPDATE.TRACK.SCREEN;	/*	$Subtitle Draw Display Screen Routine	*/	DRAW.TRACK.SCREEN: proc swapable;	/*	draws a mock up of the 32 track routing	*/		if (inc.mult=0) and (inc.midi=0) then return;		call clear.term;		call UPDATE.TRACK.SCREEN;		call PRINT.CCAT;		if D44_PRESENT then call plot.mouse.hole(mouse.hole.lowerx,mouse.hole.lowery);	/*	if device available plot the mouse hole	*/		call EXTSET(trd.ptr+3,0,256,-3);			/*	init all of trd+3 to -3	*/		call EXTSET(trd.ptr+3,0,NUM.KBD.TRACKS+NUM.TRACK.BUTTONS,0);	/*	SCREEN IS CLEARED	*/		call EXTSET(trd.ptr+4,0,TNAME.LENGTH*(NUM.KBD.TRACKS+NUM.TRACK.BUTTONS),0);	/*	timbre name field is empty	*/	end DRAW.TRACK.SCREEN;	TRACK.ROUTING.DEPOSIT: proc swapable;	/*	parses parameter and update track routing	*/		dcl val		fixed;		dcl (i,j)	fixed;		if inc.mult and (routing.display.type=0)		then call MULTI.DEPOSIT;		else if inc.midi then call MIDI.DEPOSIT;	end TRACK.ROUTING.DEPOSIT;	/*	$Subtitle Routing Display character handling routine	*/	TRACK.ROUTING.INPUT: proc(in.cmd,in.arg) swapable;	/*	routing display character handler	*/		dcl (in.cmd,in.arg)				fixed;	/*	input command and argument	*/		dcl (i,j)							fixed;		dcl (first.track,last.track)	fixed;	/*	track numbers for scrolling	*/		if (in.arg<>esc) and (err.displayed<>0) then do;	/*	remove any previous error	*/			call remove.err;			call PRINT.CCAT;		end;		do case (in.cmd);					/*	do depending upon input command	*/			do;								/*	0: input character	*/				if (in.arg>=lower.a) and (in.arg<=lower.z) then in.arg=in.arg-"40";	/*	convert to uppercase	*/				if in.arg=asc.p then do;					if D40_PRESENT<>0					then call SCREEN_DUMP;					else call no.printer;					call POS.TRACK.CURSOR;					return;				end;				if in.arg=cret then do;					call TRACK.ROUTING.DEPOSIT;					call POS.TRACK.CURSOR;				end;				else if in.arg=esc then do;					exit.my.screen=1;				end;				//	Typing space toggles mode...				else if (in.arg=sp) then do;					if inc.midi and (routing.display.type=1) and ((midi.there & (MIDI.THERE.ORIG | MIDI.THERE.OMS))<>0) then do;	/*	if midi routing display and hardware available	*/						token(0)=0;						if route.pos<0						then do case (field.pos);							call ADVANCE.MIDI.SYNC.IN;							do;																							//	Advance MIDI Sync Out								call stop.recd.move.play;								i = midi.sync.out & (MIDI.SYNC.OMS | MIDI.SYNC.ORIG);						//	Extract current value (e.g. wipe MIDINet info). NOTE ORIGINAL HARDWARE OUTPUT IS 1-based HERE!								if (i == MIDI.SYNC.OMS)																//	go from OMS to off									i = 0;								else if (i == max.midi.chan && ((midi.there & MIDI.THERE.OMS) != 0))	//	go from max chan to oms if oms there									i = MIDI.SYNC.OMS;								else if (i == max.midi.chan)														//	go from max midi chan to off if no OMS									i = 0;								else									i = i + 1;								midi.sync.out = (midi.sync.out & MIDI.SYNC.MIDINET) \ i;					/*	place in lower byte of sync word	*/								if ((midi.sync.out & (MIDI.SYNC.OMS | MIDI.SYNC.ORIG)) == 0)								{									DISPLAY.MTC = 0;																	/*	TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT	*/									CLEAR.LOWER();								}								else if (midi.sync.is.tc != 0)													/*	send out full frame when changing		*/								{									MIDI.FULL.FRAME(play.time.msb, play.time.lsb);							/*	sync output routing							*/									DO CASE (SM.MODE);								/*	PRESENT MTC MODE	*/										CALL EMIT.STRING(16,'Drop Frame MTC');										CALL EMIT.STRING(16,'Non Drop   MTC');										CALL EMIT.STRING(16,'25 Frame   MTC');										CALL EMIT.STRING(16,'24 Frame   MTC');										CALL EMIT.STRING(16,'NTSC 30 Fr MTC');									END;									SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/									BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/									LOWER.DISP=SMODE.DISP;							/*	INDICATE SMODE DISPLAYED	*/								}								if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))		//	Update display if showing midi clock/midi tc output									call display.par();								/*	Create a system event when changing the	*/								/*	output sync:										*/								new.seq.info = new.seq.info \ 512;								call display.sequencer.status;							end;							call ADVANCE.MIDI.INPUT.CHAN;							call ADVANCE.MIDI.ECHO;							do;								//	Advance midi timecode type								call stop.recd.move.play;								midi.sync.is.tc = midi.sync.is.tc xor 1;								if (midi.sync.out != 0)								{									if (midi.sync.is.tc == 0)									{										DISPLAY.MTC = 0;	/*	TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT	*/										CLEAR.LOWER();									}									else									{										MIDI.FULL.FRAME(play.time.msb, play.time.lsb);										DO CASE (SM.MODE);								/*	PRESENT MTC MODE	*/											CALL EMIT.STRING(16,'Drop Frame MTC');											CALL EMIT.STRING(16,'Non Drop   MTC');											CALL EMIT.STRING(16,'25 Frame   MTC');											CALL EMIT.STRING(16,'24 Frame   MTC');											CALL EMIT.STRING(16,'NTSC 30 Fr MTC');										END;										SUPRESS.BEAT.DISPLAY=1;							/*	STOP BEAT DISPLAYS MOMENTARILY	*/										BEAT.DISPLAY.TIME=REAL.MILLISECONDS;		/*	HOLD DISPLAY FOR 5 SECONDS	*/										LOWER.DISP=SMODE.DISP;							/*	INDICATE SMODE DISPLAYED	*/									}									if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))	//	Update display if showing midi clock/midi tc output										call display.par();								}								else								{									DISPLAY.MTC = 0;		/*	TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT	*/									CLEAR.LOWER();									if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))	//	Update display if showing midi clock/midi tc output										call display.par();								}								/*	Create a system event when changing the	*/								/*	output sync:										*/								new.seq.info = new.seq.info \ 512;								call display.sequencer.status;							end;														// Toggle OMS INput on/off							do;								if (OMS.MIDI.ENABLED == false)								{									OMS.MIDI.ENABLED = true;									interp_init_oms_midi_bulk(addr(ANY.OMS.MIDI.BULK.BYTES), OMSMIDI.PTR);								}																else								{									OMS.MIDI.ENABLED = false;									interp_init_oms_midi_bulk(0, 0);								}								if ((POLY.TIMBRE.MIDI.CONTROL | OMS.MIDI.ENABLED | MAX.MIDINET.CHAN) != 0)									MIDI.INPUT.ENABLED = true;								else									MIDI.INPUT.ENABLED = false;							end;													end;												// Else handle space character typed into field position						else do;							if route.pos<num.kbd.tracks							then j=0;							else do;								write(mam)=tbut.ptr;								write(mal)=route.pos-num.kbd.tracks;								j=read(md)&255;							end;							i=TRK.HEAD.LOOKUP(j,thd.midi);							if field.pos>0							then do case (field.pos-1);								do;																							//	Advance MIDI Output									j = EXTRACT.MIDI.OUTPUT(i);														//	Get current output (0-based) or (-1)																		j = j + 1;																				// increment (off to hardware 0, hardware x to hardware x+1, oms to oms+1)																		if ((j < THD.MIDI.OMS) && ((midi.there & MIDI.THERE.ORIG) == 0))		// No hardware at all - go to OMS										j = THD.MIDI.OMS;																			else if ((j < THD.MIDI.OMS) && (j >= max.midi.chan))						// Got to hardware limit - go to oms										j = THD.MIDI.OMS;																			if ((j == THD.MIDI.OMS) && ((midi.there & MIDI.THERE.OMS) == 0))		// No OMS - go to off										j = (-1);									else if (j > THD.MIDI.OMS+64)														//	go from OMS to off										j = (-1);															SET.MIDI.OUTPUT(route.pos, j);								end;								do;																							//	Advance MIDI Channel									call SET.MIDI.CHAN(route.pos, (EXTRACT.MIDI.CHAN (j, i)+1)&15);								end;								do;																							//	Advance MIDI Pressure Mode									call ADVANCE.MIDI.PMODE(route.pos);								end;							end;						end;						call FILL.MIDI.SCREEN;					end;	/*	of if midi routing display and available hardware	*/					else if inc.mult and (routing.display.type=0) then do;	/*	if multi routing display	*/						if (field.pos>0) & (field.pos<3)	/*	if the channel routing fields	*/						and (multi.there<>0)					/*	if hardware available	*/						or  (lod.running<>0)					/*	or DTD						*/						then call ADVANCE.CHANNEL.ROUTING(route.pos,field.pos-1);						else if field.pos=3						then call ADVANCE.POLY.BIN(route.pos);						/*	Create an ABLE screen event to force an update	*/						/*	of the entire screen:									*/						new.ABLE.prm.info = new.ABLE.prm.info \ "37";					end;					call POS.TRACK.CURSOR;				end;				else if (in.arg=tab) and (inc.mult) and (inc.midi) then do;	/*	(tab or CTRL-I) toggle between multichannel and midi displays	*/					call TRACK.ROUTING.DEPOSIT;			/*	deposit token value before changing screens	*/					prev.routing.display.type=routing.display.type;	/*	keep track of previous display screen	*/					routing.display.type=routing.display.type xor 1;					call UPDATE.TRACK.SCREEN;				/*	update screen and initialize display area in external memory	*/					exit.my.screen=1;					if routing.display.type=0					then goto.this.screen=s.multi.tab;	/*	change to multichannel	*/					else goto.this.screen=s.midi.tab;	/*	change to midi	*/					call CLEAR.PARAMETERS;					/*	clear the window display because probably invalid	*/					/*	Create an ABLE screen event to force an update	*/					/*	of the entire screen:									*/					new.ABLE.prm.info = new.ABLE.prm.info \ "37";				end;				else if ((in.arg>sp) and (in.arg<=asc.tilde)) then do;	/*	if a typed character	*/					//	Character typed on MULTI screen					if inc.mult and (routing.display.type=0)					{						if ((in.arg>=asc.0) and (in.arg<=asc.9)) or (in.arg=asc.l) then do;	/*	if a numeric value or L for LIVE	*/							if (((field.pos<>0) and (token(0)<2) and (in.arg<>asc.l))			/*	if changing a number other than track number and within limits	*/							or ((field.pos=0) and (token(0)=0) and (in.arg=asc.l))				/*	or indicating a track number is LIVE not Synclavier	*/							or ((field.pos=0) and (token(0)<3) and (in.arg<>asc.l))) then do;	/*	or changing the track number and within limits	*/								call pbyte(token,token(0),in.arg);	/*	store character in word	*/								token(0)=token(0)+1;						/*	increment token length	*/							end;						end;					}					//	Character typed on MIDI screen					else if inc.midi and (routing.display.type=1)					{						if (route.pos >= 0 && field.pos == 0)			//	Entering track #						&& (token(0) < 3)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9)) or (in.arg=asc.l) then do;			/*	if a numeric value or L for LIVE	*/								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}						else if (route.pos >= 0 && field.pos == 1)	//	MIDI Output						&& (token(0) < 3)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9))	//	Look for output or OMS or V(irtual Port)							or ((in.arg=asc.o) or (in.arg=lower.o))							or ((in.arg=asc.m) or (in.arg=lower.m))							or ((in.arg=asc.s) or (in.arg=lower.s))							or ((in.arg=asc.v) or (in.arg=lower.v))							then do;								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}						else if (route.pos >= 0 && field.pos == 2)	//	MIDI Channel						&& (token(0) < 2)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9))	//	Look for output or OMS							then do;								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}						else if (route.pos >= 0 && field.pos == 3)	//	MIDI Pressure						&& (token(0) < 4)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9))	//	Look for Indiv, Chan or numeric code							or ((in.arg=asc.i) or (in.arg=lower.I))							or ((in.arg=asc.n) or (in.arg=lower.n))							or ((in.arg=asc.d) or (in.arg=lower.d))							or ((in.arg=asc.v) or (in.arg=lower.v))							or ((in.arg=asc.c) or (in.arg=lower.c))							or ((in.arg=asc.h) or (in.arg=lower.h))							or ((in.arg=asc.a) or (in.arg=lower.a))							or ((in.arg=asc.n) or (in.arg=lower.n))							then do;								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}						else if (route.pos < 0 && field.pos == 1)		//	MIDI Sync Output						&& (token(0) < 3)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9))	//	Look for output or OMS							or ((in.arg=asc.o) or (in.arg=lower.o))							or ((in.arg=asc.m) or (in.arg=lower.m))							or ((in.arg=asc.s) or (in.arg=lower.s))							then do;								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}						else if (route.pos < 0 && field.pos == 2)		//	MIDI Input Channel						&& (token(0) < 3)						{							if ((in.arg>=asc.0) and (in.arg<=asc.9))	//	Look for channel number or ALL, Off, or None							or ((in.arg=asc.a) or (in.arg=lower.a))							or ((in.arg=asc.l) or (in.arg=lower.l))							or ((in.arg=asc.o) or (in.arg=lower.o))							or ((in.arg=asc.f) or (in.arg=lower.f))							then do;								call pbyte(token,token(0),in.arg);		/*	store character in word	*/								token(0)=token(0)+1;							/*	increment token length	*/							end;						}					}					call POS.TRACK.CURSOR;				end;				else if (in.arg=u.arr) or (in.arg=d.arr) or (in.arg=r.arr) or (in.arg=l.arr) or (in.arg=home) then do;	/*	if any of the arrow keys	*/					call TRACK.ROUTING.DEPOSIT;					prev.group.pos = group.pos;							/*	latch current cursor position for update	*/					prev.route.pos = route.pos;					prev.field.pos = field.pos;					if in.arg=u.arr then do;								/*	up arrow												*/						if ((routing.display.type == 1 )					/*	up arrow in midi sync fields					*/						&&  (route.pos				  == -1))						{							do case (field.pos);								// Up arrow in MIDI sync field area								;													// Up arrow in Sync In - stay put								field.pos = 0;									// Up arrow Sync Out to Sync In								;													// Up arrow Inputs - stay put								field.pos = 1;									// Up arrow Echo to Sync Out								field.pos = 2;									// Up arrow MIDI Clock Type to Inputs								field.pos = 4;									// Up arrow OMS INput on/off to MIDI Clock Type							end;						}						else if ((routing.display.type == 1 )			/*	up arrow from track 21 to sync fields		*/						&&			(route.pos				 == 22))						{							route.pos = -1;									/*	to midi sync fields								*/							field.pos = 5;										/*	specifically the oms input on/off field	*/							field.max = 5;						}						else if (route.pos == 22)							/*	up arrow from track 21							*/							{route.pos = 21; group.pos = 0;}						else if (route.pos == 2)							/*	up arrow from track 1 goes to kbd.			*/						{							route.pos = 0;							if (field.pos == 0)								/*	disallow kbd field itself						*/								field.pos = 1;						}						else if (route.pos != 0)							/*	else bump up a row if not at top line		*/							route.pos=route.pos-1;					end;					else if in.arg=d.arr then do;							/*	down arrow	*/						if ((routing.display.type == 1 )					/*	down arrow in midi sync fields				*/						&&  (route.pos				  == -1))						{							do case (field.pos);												// Down arrow in MIDI Sync Fields								field.pos = 1;													// Down arrow Sync In to Sync Out								field.pos = 3;													// Down arrow Sync Out to MIDI Echo								field.pos = 4;													// Down arrow MIDI Inputs to MIDI Clock TYpe								{route.pos = 22; field.pos = 1; field.max = 3;}		// Down arrow Echo to Track 21								field.pos = 5;													// Down arrow MIDI Clock Type to OMS Input on/off								{route.pos = 22; field.pos = 1; field.max = 3;}		// Down arrow OMS Input on/off to Track 21							end;						}						else if (route.pos == 0)							/*	from keyboard to track 1						*/							route.pos = 2;						else if (route.pos == 21)							/*	bump to track 21 from track 20				*/							{route.pos = route.pos + 1; group.pos = 1;}						else if (route.pos < num.track.buttons+1)		/*	else bump a row									*/							route.pos = route.pos+1;					end;					else if in.arg=l.arr then do;							/*	left arrow	*/						if ((routing.display.type == 1 )					/*	left arrow in midi sync fields				*/						&&  (route.pos				  == -1))						{							do case (field.pos);																// Left arrow in MIDI Sync Fields								{field.pos = 3; route.pos = 6; group.pos = 0; field.max = 3;}	// Left arrow Sync In Track 5								{field.pos = 3; route.pos = 7; group.pos = 0; field.max = 3;}	// Left arrow Sync Out Track 6								field.pos = 0;																	// Left arrow MIDI Inputs to Sync In								{field.pos = 3; route.pos = 8; group.pos = 0; field.max = 3;}	// Left arrow Echo to Track 7								field.pos = 1;																	// Left arrow MIDI Clock Type to Sync Out								field.pos = 3;																	// Left arrow OMS Input on/off to MIDI Echo							end;						}						else if (field.pos > 0)								/*	else left on a line								*/						{							if (route.pos != 0 || field.pos > 1)		/*	move left 1 field if not on kbd field 1	*/								field.pos = field.pos - 1;						}						else if (group.pos != 0)							/*	left arrow from field 0 of group 1			*/							{group.pos = 0; field.pos = 3; route.pos = route.pos - 12;}					end;					else if in.arg=r.arr then do;							/*	right arrow	*/						if ((routing.display.type == 1 )					/*	right arrow in midi sync fields				*/						&&  (route.pos				  == -1))						{							if		  (field.pos == 0) field.pos = 2;	/*	midi in to sync in								*/							else if (field.pos == 1) field.pos = 4;	/*	tc format to sync out							*/							else if (field.pos == 3) field.pos = 5;	/*	echo to oms input on/off						*/						}						else if (field.pos < field.max)					/*	else right on a line								*/							field.pos = field.pos + 1;						else if (route.pos == 6)							/*	else right to sync fields						*/							{field.pos = 0; route.pos = -1; group.pos = 1; field.max = 5;}						else if (route.pos == 7)							{field.pos = 1; route.pos = -1; group.pos = 1; field.max = 5;}						else if (route.pos == 8)							{field.pos = 3; route.pos = -1; group.pos = 1; field.max = 5;}						else if (group.pos == 0 && route.pos >= 10)	/*	else switch to group 2 if allowed			*/							{group.pos = 1; field.pos = 0; route.pos = route.pos + 12;}					end;					else if in.arg=home then do;						route.pos=0; field.pos=1; group.pos=0;					end;					call POS.TRACK.CURSOR;				end;				else if (in.arg=DEL) or (in.arg="32") then do;	/*	<DELETE> or CTRL-Z	*/					if token(0)<>0 then do;						/*	if typing a value	*/						token(0)=token(0)-1;						call POS.TRACK.CURSOR;						if token(0)<>0 then do;							call pc(SP); call pc(BS);			/*	print over with space	*/						end;					end;					else do;											/*	if nothing but delete	*/						if inc.mult and (routing.display.type=0) then do;	/*	if Multichannel display	*/	/*	0: MULTICHANNEL DISPLAY	*/							if (field.pos = 1)							or (field.pos = 2)							then do;								call SET.MULTI.CHANNEL.ROUTING(route.pos,0);	/*	set to 0	*/								if (TBUT.MAPPING(trout.trk#) < First.Lod.Track) DISPLAY.PAR();	//	redisplay value in the window								/*	Create an ABLE screen event to force an update	*/								/*	of the entire screen:									*/								new.ABLE.prm.info = new.ABLE.prm.info \ "37";							end;						end;						else if inc.midi then do;									/*	MIDI DISPLAY	*/							if (route.pos>0) or										/*	if looking at a track	*/							((route.pos<0) and (field.pos=2)) then do;		/*	or at input channel location	*/								write(mam)=clav.ptr;									/*	need to turn off all notes	*/								do i=0 to max.key#;									write(mdi)=0;								end;							end;							if route.pos<0							then do case (field.pos);								do;									/*	midi synchronization input	*/									ext.clock.mode=0;				/*	return to internal sync mode	*/									/*	Create a system event when changing the	*/									/*	system synch mode:								*/									call stop.recd.move.play;									NEW.SEQ.INFO = NEW.SEQ.INFO \ 512;	/*	CHANGE IN EXT SYNC MODE	*/									CALL RESYNC.TIME.BASE;									CALL CLEAR.PARAMETERS;					/*	CLEAR OTHER PARAMETER BUTTONS FOR CHANGING SYNC DELAY	*/									CALL DISPLAY.SEQUENCER.STATUS;		/*	AND SET EXT SYNC LIGHT CORRECTLY	*/								end;								do;									call stop.recd.move.play;									midi.sync.out=midi.sync.out & (MIDI.SYNC.MIDINET);	/*	turn off sync output - don't change upper byte here (MIDInet sync output)	*/									DISPLAY.MTC = 0;												/*	TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT	*/									CLEAR.LOWER();									if ((upper.disp = (midi.l-par.l)) && (MIDI.PARAM.ID == 1))	//	Update display if showing midi clock/midi tc output										call display.par();									/*	Create a system event when changing the	*/									/*	output sync:										*/									new.seq.info = new.seq.info \ 512;								end;								midi.input.chan=(-2);				/*	don't listen to midi input	*/								midi.echo.disabled=1;				/*	disable midi output (off)	*/								;											/*	delete inop for tc format field	*/								do;										// Delete in OMS MIDI Input on/off field									OMS.MIDI.ENABLED = false;									interp_init_oms_midi_bulk(0, 0);									if ((POLY.TIMBRE.MIDI.CONTROL | OMS.MIDI.ENABLED | MAX.MIDINET.CHAN) != 0)										MIDI.INPUT.ENABLED = true;									else										MIDI.INPUT.ENABLED = false;								end;							end;							else do;								if route.pos<num.kbd.tracks then i=0;		/*	if keyboard	*/								else do;									write(mam)=tbut.ptr;							/*	look up track number	*/									write(mal)=(route.pos-num.kbd.tracks);	/*	index to trak but		*/									i=read(md)&255;								/*	get track #				*/								end;								call SET.MIDI.OUTPUT(i,(-1));					/*	turns off midi output# on this trk	*/							end;							/*	Create an ABLE screen event to force an update	*/							/*	of the entire screen:									*/							new.ABLE.prm.info = new.ABLE.prm.info \ "37";						end;	/*	of if midi display	*/					end;		/*	of if nothing but delete	*/				end;				else call POS.TRACK.CURSOR;			end;	/*	of character input	*/			do;								/*	1: absolute select	*/				call TRACK.ROUTING.DEPOSIT;				prev.group.pos = group.pos;				prev.route.pos = route.pos;				prev.field.pos = field.pos;				if inc.midi and (#ypos=-1) and (routing.display.type=1) then do;	/*	if on midi synchronization line	*/					group.pos = 1;					route.pos =-1;					field.max = 5;					/*	6 fields on midi sync line	*/				end;				else do;								/*	otherwise within one of the fields	*/					group.pos = #ypos;					route.pos = in.arg&255;					field.max = 3;					/*	4 fields on all other lines	*/				end;				field.pos = shr(in.arg,8);				call POS.TRACK.CURSOR;			end;			;									/*	2: scroll down	*/			;									/*	3: scroll up	*/			exit.my.screen=1;				/*	4: return to previous state	*/		end;	/*	of do depending upon input command	*/	end TRACK.ROUTING.INPUT;	/*	$Subtitle Track Routing Mouse Mapping	*/	TRACK.ROUTING.MOUSE.POS: proc(x,y) swapable;		/*	Multichannel Routing, and MIDI Mouse Positioner	*/		/*			Considers the following track routing variables:			group.pos	-> left or right track routing group			route.pos	-> track number			field.pos	-> routing info		*/		dcl (x,y)			fixed;	/*	mouse position in row/col coordinates	*/		dcl route.box1		data ( 0, 0,22,38);		dcl route.box2		data ( 9,41,22,79);		dcl mm.field.pos1	data ( 1, 3,23,26,28,31,33,37);		dcl mm.field.pos2	data (42,44,64,67,69,72,74,78);		if (inc.mult=0) and (inc.midi=0) then return;		if mouse.hole(x,y) then do;					/*	if exit condition	*/			call TRACK.ROUTING.INPUT(in.rtps,0);	/*	return to previous screen	*/			return;		end;		if err.displayed<>0 then do;			call REMOVE.ERR;					/*	remove any error	*/			call PRINT.CCAT;					/*	show current cat name	*/			call POS.TRACK.CURSOR;			/*	reposition the cursor	*/		end;		/*	convert the mouse pixel coordinates to screen coordinates	*/		x=CONVERT.MOUSE.X(x);	/*	0-79	*/		y=CONVERT.MOUSE.Y(y);	/*	0-23	*/		if ((routing.display.type=1)		/*	if on midi screen								*/		&&  (y >= sync.iny.prompt	)		/*	and on sync in through echo line			*/		&&  (y <= midi.echoy.prompt)		/*	and in field area								*/		&&  (x >= sync.inx))		{			#ypos=-1;							/*	indicate that group pos should be 1 and route.pos should be -1	*/			if ((y == sync.iny.prompt) && (x >= sync.inx) && x <= (sync.inx + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(0,8));			else if ((y == sync.outy.prompt) && (x >= sync.outx) && x <= (sync.outx + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(1,8));			else if ((y == midi.in.chany.prompt) && (x >= midi.in.chanx) && x <= (midi.in.chanx + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(2,8));			else if ((y == midi.echoy.prompt) && (x >= midi.echox) && x <= (midi.echox + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(3,8));			else if ((y == midi.formaty.prompt) && (x >= midi.formatx) && x <= (midi.formatx + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(4,8));							else if ((y == oms.onoffy.prompt) && (x >= oms.onoffx) && x <= (oms.onoffx + 5))				call TRACK.ROUTING.INPUT(in.abss,shl(5,8));		end;		else if (((x>route.box1(1)) and (x<route.box1(3))) and	/*	if within the limits of the first box	*/		((y>route.box1(0)) and (y<route.box1(2)))) then do;			#ypos=0;																/*	indicate left box	*/			if y=1 then y=0;													/*	map track number to keyboard	*/			if (((x>=mm.field.pos1(0)) and (x<=mm.field.pos1(1)) and (y<>0))			or  ((x>=mm.field.pos1(2)) and (x<=mm.field.pos1(3)))			or  ((x>=mm.field.pos1(4)) and (x<=mm.field.pos1(5)))			or  ((x>=mm.field.pos1(6)) and (x<=mm.field.pos1(7)))) then do;				if		  ((x>=mm.field.pos1(0)) and (x<=mm.field.pos1(1))) then x=0;				else if ((x>=mm.field.pos1(2)) and (x<=mm.field.pos1(3))) then x=1;				else if ((x>=mm.field.pos1(4)) and (x<=mm.field.pos1(5))) then x=2;				else x=3;				call TRACK.ROUTING.INPUT(in.abss,shl(x,8)\y);			end;		end;	/*	of within the first box	*/		else if (((x>route.box2(1)) and (x<route.box2(3))) and	/*	if within the limits of the second box	*/		((y>route.box2(0)) and (y<route.box2(2)))) then do;			#ypos=1;																/*	indicate right box	*/			y=y+12;			if (((x>=mm.field.pos2(0)) and (x<=mm.field.pos2(1)) and (y<>0))	/*	if within the track number field and not keyboard	*/			or  ((x>=mm.field.pos2(2)) and (x<=mm.field.pos2(3)))			or  ((x>=mm.field.pos2(4)) and (x<=mm.field.pos2(5)))			or  ((x>=mm.field.pos2(6)) and (x<=mm.field.pos2(7)))) then do;				if		  ((x>=mm.field.pos2(0)) and (x<=mm.field.pos2(1))) then x=0;				else if ((x>=mm.field.pos2(2)) and (x<=mm.field.pos2(3))) then x=1;				else if ((x>=mm.field.pos2(4)) and (x<=mm.field.pos2(5))) then x=2;				else x=3;				call TRACK.ROUTING.INPUT(in.abss,shl(x,8)\y);			end;		end;	/*	of within the second box	*/	end TRACK.ROUTING.MOUSE.POS;