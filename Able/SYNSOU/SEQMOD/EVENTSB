/* :SYNSOU:SEQMOD:EVENTSB - more routines for SEQMOD to process events *//*Modified:1998/05/16 - TY  - Substituted call to SCALE.RTE.VAL passing 1, to call to SCALE.PERCENT.TO.RTE.1992/06/05 - PF  - Optimize inserting notes1992/02/06 - cj  - chaned dsp scrubbing to dsp trigging1992/02/17 - pf  - Speed up block sequence downloading over protocol1992/02/17 - pf  - broke this file off from eventsou*//* stop sequencer, clean up track, clean up event area, reposition seq:  */Garbage.Collect.Event.List: proc (track#) public swapable;   dcl track#      fixed;   dcl time(1)     fixed;   if  ((track# ILT Num.Kbd.Tracks   )     /* allow access to 200     */   or   (track# IGE First.Lod.Track  ))    /* syncl tracks plus cue   */   and ( track# INE Cue.Audition.Track)    /* audition track          */   then return Bad.Event.Track#;   /* now garbage collect any tracks of interest */   call Stop.Sequencer;   /* stop sequencer for the garbage collect */   call COPY32(loc(addr(Sampled.Actual.Play.Time.Msb)), time);   call GARBAGE.COLLECT.TRK(track#);   call Garbage.Collect.Event.Area(track#);   call Play.Initialize;          /* unscramble sequence pointers */   call SCROLL.SEQ  (time(0), time(1), 0);   return Good.Event.Status;end Garbage.Collect.Event.List;/*********************************************************************//* Place Event In Sequence is used to place an event on a particular *//* sequence track.  If an event already exists at that sequencer     *//* time, the new event is put BEFORE the existing event.  That way   *//* the address of the new event will always be equal to the address  *//* that was passed to Place Event In Sequence.                       *//* note: the address of other events in the sequence on this track   *//* that start at the same time as this event may be changed by       *//* placing the event on this track.                                  *//* See possible status codes in SEQLITS.                             */dcl temp.note.trk fixed public;Place.Event.In.Sequence: proc (event) public swapable;   dcl event       array; /* pass complete event                     */   dcl spointer(spointer.record.size-1) fixed;   dcl record(5)   fixed;   dcl status      fixed;   dcl p(1)        fixed;   dcl t(1)        fixed;   dcl first.place fixed;   dcl i           fixed;   #trk = event(event.track#);           /* get track #             */   if  ((#trk ILT Num.Kbd.Tracks   )     /* allow access to 200     */   or   (#trk IGE First.Lod.Track  ))    /* syncl tracks plus cue   */   and ( #trk INE Cue.Audition.Track)    /* audition track and      */   and ( #trk INE Temp.Trk)              /* temp track used for optimized note inserts */   then return Bad.Event.Track#;   /* Do some dirty work here that might move memory around so we         */   /* don't have to worry about the #sec, #wrd pointers getting out       */   /* of date.                                                            */   if (event(event.type) = event.type.cue  )  /* if this is cue trigger   */   or (event(event.type) = event.type.event)  /* or complex event         */   or (event(event.type) = event.type.poly)   /* or poly event            */   then do;     /* then store information in timbre area now.             */      write(mam)=trk.head;      write(mal)=#trk;      if (read(md)=0)                          /* no track head here       */      then first.place = TRUE;                 /* force an output routing  */      else do;         write(mam)=read(md);                  /* point at track head      */         write(mal)=thd.nn.msb;                /* check note count         */         if (read(mdi)\read(mdi)) = 0          /* no notes on trk          */         then first.place = TRUE;              /* force an output routing  */      end;      /* place cue name & event info on track */      if event(event.type) = event.type.cue      then i = ADD.CUE.TO.LIST  (event(event.track#),                                 loc(addr(event(event.cue.name))),                                 event(event.cue.id), 0);      else if event(event.type) = event.type.event      then i = ADD.EVENT.TO.LIST(event(event.track#),                                  loc(addr(event(event.cue.name))),                                 event(event.cue.id), 0,                                 loc(addr(event(event.in.msb))),                                 loc(addr(event(event.caption))),                                 ev.type);      else if event(event.type) = event.type.poly      then i = ADD.POLY.EVENT.TO.LIST(event(event.track#),                                      event(event.key#),                                      loc(addr(event(event.in.msb))),                                      loc(addr(event(event.out.msb))));      /* ERROR CONDITIONS ARE RETURNED AS FOLLOWS:                     */      /*   -1 : OUT OF ROOM IN MEMORY FOR CUE LIST, TRACK HEADER, ETC. */      /*   -2 : TRACK IS A NON-EMPTY FM OR POLY SYNTH TRACK            */      /*   -3 : CUE LIST IS FULL (250 CUES MAX PER TRACK)              */      /*      : OR PATCH LIST IS FULL IN CASE OF POLY EVENTS           */      if i = (-1)      then return Event.Noroom#1;      if i = (-2)      then return Event.Music.Track;      if i = (-3)      then return Event.Noroom#3;      if i < 0      then return Event.Seq.Err;      event(event.key#) = i;   /* this is "key no." for cue */   end;   if (temp.note.trk <> 0)                /* caller wants notes on temp track (for speed) */   then do;      #trk = temp.note.trk;      event(event.track#) = #trk;   end;   call blockmove(event, spointer, spointer.record.size); /* copy to temp */   /* begin by setting # variables to point to the closest event AT or    */   /* after the time of this new event:                                   */   status = Locate.Sequencer.Event(spointer,0);   if  (Status <> Good.Event.Status)      /* if we ran into some sort     */   and (Status <> Get.Info.Next    )      /* of error,  then complain     */   and (Status <> Get.Info.EOT     )      /* back to caller.              */   and (Status <> Get.Info.Empty   )   then return status;   if (Status = Get.Info.Empty) then do;  /* if empty track, initialize   */      /* initialize an empty track if needed: */      write(mam)=trk.head;      write(mal)=event(event.track#);      if (read(md)=0) then do;                   /* if there are no notes on this track yet */         if ALLOCATE.TRK.HEADER(event(event.track#))=0          then return Event.Noroom#1;         if (temp.note.trk = 0)                  /* normal mode - else leave trk with no timbre */         then call COPY.TIMBRE(0,event(event.track#));/* put keyboard timbre on this track */      end;      call LOAD.SEQ.GLOBALS(event(event.track#));   end;   /* 1.  ILPS - To place an independent loop on a track,  set up the    */   /*     event record as follows:                                       */   /*        event.track# = the track # (absolute) you want the loop on  */   /*        event.time   = msb,lsb = start of ilp, COUNT MUST BE ZERO   */   /*        event.type   = event.type.ilp                               */   /*        event.duration = msb,lsb must be the length of the loop     */   /*                         in sequencer units                         */   /*        other fields are not looked at for ILPS.                    */   if event(event.type) = event.type.ilp   then do;      call Stop.Sequencer;          /* for ilp create        */      call Map.Real.Time.To.Sequence.Time(loc(addr(play.time.msb)), p);      call REMOVE.ILP.FROM.TRACK(event(event.track#)); /* get rid of possible earlier loop */      call PLAY.INITIALIZE;                            /* get fresh pointers               */      call ADD32(loc(addr(event(event.time.msb))),                 loc(addr(event(event.duration.msb))), t);      call CREATE.ILP.ON.TRACK(event(event.track#),event(event.time.msb),                                                   event(event.time.lsb),                                                   t(0), t(1));      if COM32(p, loc(addr(event(event.time.msb)))) = lw#igt  /* limit scroll forward to where */      then call COPY32(loc(addr(event(event.time.msb))), p);  /* we created loop to avoid      */                                                              /* random time displays.         */      call SCROLL.SEQ(p(0),p(1),1);      /* move back to where we were before edit */      return Good.Event.Status;   end;   /* 2.   RTES - To place an RTE on a track, set up the event record     */   /*      as follows:                                                    */   /*         track#, time.msb, time.lsb, count ==> as needed.            */   /*         event.type = event.type.rte                                 */   /*         event.w1-event.w4 = construct 4-word note record as defined */   /*            for the effect.                                          */   /*         all other information is not looked at                      */   /* 3.   NOTES - to place a musical note on a track:                    */   /*         If the track is empty,  allocate the track header and       */   /*            copy the desired timbre to the track.                    */   /*         track#, time.msb, time.lsb, count ==> as needed.            */   /*         event.type = event.type.note                                */   /*         event.w1-event.w4 = construct 4-word note record for the    */   /*            note.   Seqsou:Build.Note.Record may be handy to do this */   /*            for you.   Seqsou:Compute.Default.Note is a conventient  */   /*            routine to get the correct duration for a sound file.    */   /*            Set special tied bits, volume, etc. etc. etc. as needed. */   /*         all other information is not looked at                      */   if (event(event.type) = event.type.rte)   or (event(event.type) = event.type.note)   or (event(event.type) = event.type.poly)   then do;      if event(event.type) = event.type.rte      then do;         #w1 = event(event.w1);         #w2 = event(event.w2);         #w3 = event(event.w3);         #w4 = event(event.w4);      end;      else if event(event.type) = event.type.note      or      event(event.type) = event.type.poly      then do;         record(0) = event(event.duration.msb);         record(1) = event(event.duration.lsb);         record(2) = event(event.key#);         record(3) = shr(event(event.w3),8);         record(4) = event(event.w3) & 255;         record(5) = shr(event(event.w4),8);         call BUILD.NOTE.RECORD(record);      end;      write(mam)=trk.head;      write(mal)=#trk;      #ptr      =read(md);      if (#ptr=0) then do;         if INSERT.NOTE.RECORD(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;      /* Now set up a bunch of global vars      */      /* which are needed by insert.note.record */      /* to correctly put a new note into the   */      /* sequence.                              */      write(mam)=#ptr;                /* restore ptr to trk head */      write("313")=addr(#nmsb);      write(mal)=thd.nmsb;      if inc.poly<>0 then do;         rpc 6;         write("373")=read(mdi);      end;      else do;         write("373")=read(mdi); write("373")=read(mdi); /* copy thd.nmsb,thd.nlsb into #nmsb,#nlsb */         write("373")=read(mdi); write("373")=read(mdi); /* copy thd.lmsb,thd.llsb into #lmsb,#llsb */         write("373")=read(mdi); write("373")=read(md ); /* copy thd.wrd ,thd.sec  into #wrd,#sec */      END;      write(mal)=thd.any.for;      write("373")=read(mdi); write("373")=read(md);  /* copy thd.any.for,thd.any.rev into #anyf,#anyr */      if #anyf=0                                    /* recording at end of track */      then do;         if APPEND.NOTE.DURING.PLAY(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;      else do;           if INSERT.NOTE.RECORD(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;   end;   /* 4.   CUES - to place a simple cue on a track:                        */   /*         note: cues cannot be placed on music tracks.   Track must    */   /*            be empty or must be a cuelist track.  Simple cue triggers */   /*            or complex cue events can be placed on the same track.    */   /*         track#, time.msb, time.lsb, count ==> set to place the cue   */   /*            trigger at the right time in the right place.             */   /*         event.type = event.type.cue                                  */   /*         event.w1-event.w4  ==>  these will be computed for and       */   /*            and returned in the note record                           */   /*         event.key# - ==> not used.  will be set for you.             */   /*         event.cue.id ==> you must get the ID of the cue in           */   /*            question and pass it here.   If the cue does not exist    */   /*            at the moment on the direct-to-disk,  then be sure to pass*/   /*            a cue.id of 0.   The cue will be placed correctly but     */   /*            will not be heard (obviously).   If the cue does exist    */   /*            on the DTD then you can use Locate.DTD.Cue to get its ID. */   /*         event.duration (msb,lsb) = not used for cue triggers.        */   /*         event.priority = must be zero for now                        */   /*         event.output   = also must be zero for now                   */   /*         event.volume   = set to desired volume.  1000 = max.         */   /*         event.pan      = also must be zero for now.                  */   /*         event.cue.name = correct name must be stored here.           */   /*                          Upper and lower case is ok (case is ignored)*/   /*                          But do not have any control characters      */   /*                          in the name.                                */   /*         all other information (event in/out, caption) etc. is not    */   /*            used for cue triggers.                                    */   /* 5.   EVENTS - to place a complex cue event on a cue track.           */   /*         note: complex cue events cannot be placed on music tracks.   */   /*            Track must be empty or must be a cuelist track.           */   /*            Simple cue triggers or complex cue events CAN be placed   */   /*            the same cuelist track.                                   */   /*         track#, time.msb, time.lsb, count ==> set to place the event */   /*            to start at the right time in the right place.            */   /*         event.type = event.type.event                                */   /*         event.w1-event.w4  ==>  these will be computed for you and   */   /*            returned in the not record.  No need to set them.         */   /*         event.key# - ==> not used.  will be set for you.             */   /*         event.cue.id ==> you must get the ID of the cue in           */   /*            question and pass it here.   If the cue does not exist    */   /*            at the moment on the direct-to-disk,  then be sure to pass*/   /*            a cue.id of 0.   The cue will be placed correctly but     */   /*            will not be heard (obviously).   If the cue does exist    */   /*            on the DTD then you can use Locate.DTD.Cue to get its ID. */   /*         event.duration (msb,lsb) = set to reflect how long the       */   /*            event last.   THIS MUST MATCH THE DISTANCE BETWEEN THE    */   /*            EVENT.IN(MSB,LSB) AND EVENT.OUT(MSB,LSB).                 */   /*         event.priority = must be zero for now                        */   /*         event.output   = also must be zero for now                   */   /*         event.volume   = set to desired volume.  1000 = max.         */   /*         event.pan      = also must be zero for now.                  */   /*         event.cue.name = correct name must be stored here.           */   /*                          Upper and lower case is ok (case is ignored)*/   /*                          But do not have any control characters      */   /*                          in the name.                                */   /*         event.in(msb,lsb) = pass a twos complement (signed) relative */   /*                          in time (more on this later).               */   /*         event.out(msb,lsb) = relative (signed) out time.             */   /*         event.mark(msb,lsb) = relative (signed) time for offset      */   /*                          point                                       */   /*         event.fade(in,out) = set in milliseconds.                    */   /*         event.caption    = store a caption string here if desired    */   if (event(event.type) = event.type.cue  )  /* for cue triggers or       */   or (event(event.type) = event.type.event)  /* complex events,  place    */   then do;  /* the note record in sequence here.                          */      if (0 & (first.place = TRUE)) then do;         /* User has just placed a cue onto an empty track. */         /* Be nice and give the sequence track a default   */         /* output routing.  Default routing corresponds    */         /* to the track number.  Only set up routing if    */         /* event/cue is placed on first N tracks, where    */         /* N is the number of outputs in the DTD system.   */         if ((event(event.track#)+(num.kbd.tracks-1)) < DTD.NUM.VOICES)         then do;            call Set.Sequencer.Output.Routing(event(event.track#),                                              event(event.track#)-num.kbd.tracks+1,                                              0);         end;      end;      /* place cue/event trigger on track                   */      /* construct note record to store cue information:    */      /* format of note record:                             */      /* w1 = upper 4 bits of 9-bit "key" number            */      /*      stored in bits 11,12,13,14                    */      /* w2 = lower 5 bits of "key" number stored in        */      /*      bits 0, 1, 2, 3, 4, 5                         */      /*    = 5 bit priority bits 6, 7, 8, 9, 10            */      /*    = 5 bit output # bits 11,12,13,14,15            */      /* w3 = volume (0 - rte.max) in lower half            */      /* w4 = pan info in upper half                        */      /*      vel.note in lower half                        */      #w1 = 1 \ shl(event(event.key#)&"740",6);      #w2 = (event(event.key#)&"37")          \ shl(event(event.priority)&"37",6)          \ shl(event(event.output)&"37",11);      #w3 = SCALE.PERCENT.TO.RTE(event(event.volume));      #w4 = vel.note\shl(event(event.pan),8);      event(event.w1) = #w1;   /* store note record for user */      event(event.w2) = #w2;   /* in case he is interested.  */      event(event.w3) = #w3;      event(event.w4) = #w4;      write(mam)=trk.head;      write(mal)=#trk;      #ptr      =read(md);      if (#ptr=0) then do;         if INSERT.NOTE.RECORD(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;      /* Now set up a bunch of global vars      */      /* which are needed by insert.note.record */      /* to correctly put a new note into the   */      /* sequence.                              */      write(mam)=#ptr;                /* restore ptr to trk head */      write("313")=addr(#nmsb);      write(mal)=thd.nmsb;      if inc.poly<>0 then do;         rpc 6;         write("373")=read(mdi);      end;      else do;         write("373")=read(mdi); write("373")=read(mdi); /* copy thd.nmsb,thd.nlsb into #nmsb,#nlsb */         write("373")=read(mdi); write("373")=read(mdi); /* copy thd.lmsb,thd.llsb into #lmsb,#llsb */         write("373")=read(mdi); write("373")=read(md ); /* copy thd.wrd ,thd.sec  into #wrd,#sec */      END;      write(mal)=thd.any.for;      write("373")=read(mdi); write("373")=read(md);  /* copy thd.any.for,thd.any.rev into #anyf,#anyr */      if #anyf=0                                    /* recording at end of track */      then do;         if APPEND.NOTE.DURING.PLAY(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;      else do;           if INSERT.NOTE.RECORD(event(event.time.msb),event(event.time.lsb))  /* add the rte or note */         then return Good.Event.Status;         else return Event.Noroom#1;      end;   end;   stop;  /* should not get here.  each case should return above     */end Place.Event.In.Sequence;/*************************************************************************//* Trigger Event For Audition is used to trigger an event without        *//* respect to the sequencer time base.   It plays the event at normal    *//* play speed.                                                           */Trigger.Event.For.Audition: proc (Event) public swapable;   dcl Event      array;   dcl Trkinfo    fixed;   dcl (dsp.running   )    fixed external;   dcl (dtd.is.trigging)   fixed external;   dcl (dtd.scrub.msb )    fixed external;   dcl (dtd.scrub.lsb )    fixed external;   dcl (time.base.mode)    fixed external;   #trk = event(event.track#);           /* get track #             */   if (#trk IGE First.Lod.Track)         /* 0 is ok here.           */   then return Bad.Event.Track#;         /* but > allowed is not.   */   if event(event.track#) = 0                  /* if no track is           */   then Trkinfo = 0;                           /* referenced,  use no      */   else Trkinfo = 32768 \ event(event.track#); /* track volume, else do so */   if (Event(event.type) = event.type.cue)   then call Trigger.DTD.Cue.By.Id(Event(event.cue.id), Trkinfo, 0, 0);   else if (Event(event.type) = event.type.event)   then do;      call Trigger.DTD.Cue.By.Id(Event(event.cue.id), Trkinfo, addr(Event(0)), 0);      if  (dsp.running      <> 0)        /* if dsp running        */      and (time.base.mode   =  0)        /* and syncl is idle     */      and (dtd.is.trigging  =  0)        /* and not scrubbing now */      then do;         dtd.is.trigging = 1;            /* indicate scrub/trig   */         dtd.scrub.msb = 0;              /* from zero             */         dtd.scrub.lsb = 0;         new.motion = 1;                 /* send to dsp           */      end;   end;   else if (Event(event.type) = event.type.note)   or      (Event(event.type) = event.type.poly)   then do;      #w1 = event(event.w1);    /* play music note using info */      #w2 = event(event.w2);    /* from sequencer.            */      #w3 = event(event.w3);      #w4 = event(event.w4);      call Audition.Music.Note; /* start the note playing     */      Timed.Info.Notes = 1;     /* set flag for main loop */      Info.Note.Timer(0) = 0;   /* reset info timer */      Info.Note.Timer(1) = 0;      /* use event duration for info note timer */      call COPY32(loc(addr(event(event.duration.msb))),Info.Note.Duration);      Info.Timer.Last = REAL.MILLISECONDS;     /* latch time base to keep timer going */   end;   /* set flag in track head so we know to stop the note audition */   write(mam) = trk.head;   write(mal) = event(event.track#);   #ptr       = read(md);   if #ptr <> 0   then call trk.head.store(event(event.track#), thd.info.trigger.key, 1);   return Good.Event.Status;end Trigger.Event.For.Audition;/* Stop Event Auditions is used to stop the auditioning of events.       *//* Any event that is currently auditioning will be stopped.              */// Note: This is called from the low level real time loopStop.Event.Auditions: proc public swapable;   dcl track# fixed;   do track# = 0 to First.Lod.Track-1; /* stop any audition triggers     */      write(mam) = trk.head;           /* see if track head exists       */      write(mal) = track#;      if read(md) <> 0 then do;        /* if so, then see if notes here. */         if trk.head.lookup(track#, thd.info.trigger.key) <> 0         then do;            call trk.head.store(track#, thd.info.trigger.key, 0);            call Stop.Info.Note(track#);         end;      end;   end;   Timed.Info.Notes = 0;               /* reset flag */   return Good.Event.Status;end Stop.Event.Auditions;/*************************************************************************/