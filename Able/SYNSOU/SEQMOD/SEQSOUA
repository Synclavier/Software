/* :SYNSOU:SEQMOD:SEQSOUA - moved seqsou subroutines *//*Modified:1998/05/16 - TY  - Substituted calls to SCALE.RTE.VAL passing 0, to calls to SCALE.RTE.TO.PERCENT.1998/05/01 - TY  - Fixed bug in COMPUTE.SOUND.FILE.OFFSET.TIME that cause it to give incorrect results for						 sample rates other than 50 KHz (actually removed the old code and rewrote from scratch).						 Also restructured so that when a soundfile is encountered with no offset, subsequent						 partials will be checked rather than returning a false to the point of call.						 Removed unnecessary variable.					  - Set COMPUTE.DEFAULT.NOTE to default to a3 even if a soundfile isn't found.					  - Removed the part of COMPUTE.DEFAULT.NOTE that scaled up duration by 1% "to cope						 with possible speed variations".  I think it's better to give an accurate result and						 not try to second-guess a user's possible speed variations.  1% is arbitrary and may						 not adequately cope anyway.1998/04/21 - TY  - Removed imbedded SCALE.RTE.VAL from EXPAND.EVENT.NOTE so that the improved						 version in SEQSOU will be used (also to eliminate unnecessary duplication).1991/08/29 - PF  - Made RAM Event time conversions work with different sampling rates1991/08/22 - PF  - Use extend mode for poly scrubbing only during trim1991/08/19 - PF  - Allow poly scrubbing of looped events1991/07/11 - cj  - Added correct mark start to poly scrubbing1991/06/03 - cj  - added Get.Event.HZ.Information1991/06/19 - pf  - extract note duration for patch list for poly RAM events1990/05/31 - cj  - speed up expand.event.note for EDITVIEW1989/05/25 - cj  - moved expand.event.note to this file1989/04/28 - cj  - added audition.music.note*//* EXPAND.EVENT.NOTE: routine examines global variables #w1, #w2, #w3, *//* #w4 and looks up lot's of info about the event or the cue           *//* trigger or the event.                                               *//* return 1 of cue trigger, event, or music note.                      *//* else return 0 (rests, ilps, rtes)                                   */expand.event.note:proc (event, code) PUBLIC SWAPABLE;	dcl event     array;	/* event record is filled here        */	dcl code      fixed;	/* 0 = skip caption.  1 = get caption */	dcl (ourtimb) fixed;	dcl (ptl    ) fixed;	dcl (ptlptr ) fixed;	dcl (kbdtab ) fixed;	dcl (k,l,m  ) fixed;	dcl (msb,lsb) fixed;	/* store basic note record away because someone might be interested */	event(event.w1) = #w1;	/* save actual note record */	event(event.w2) = #w2;	/* away for someone.       */	event(event.w3) = #w3;	event(event.w4) = #w4;	/* initialize rest of information to zeroes: */	if code = 1 then do;	/* if caption info to be included */		write("300") = addr(event(event.key#));	/* zap all info from    */		rpc (event.record.size-event.key#);			/* event.key# to end of */		write("360") = 0;									/* record.              */	end;	else do;													/* for smaller arrays   */		write("300") = addr(event(event.key#));	/* zap all info from    */		rpc (event.caption - event.key#);			/* event.key# to end of */		write("360") = 0;									/* record.              */	end;	/* rest note - indicate a serious programming error by someone: */	if isa.rest.note then do;		event(event.type) = (-1);		return 0;	end;	/* for ILP notes - set type,  return loop length:          */	if isa.ilp.note then do;		event(event.type) = event.type.ilp;		call STR32(TRK.HEAD.LOOKUP(#trk, THD.LOOPLEN.MSB),					  TRK.HEAD.LOOKUP(#trk, THD.LOOPLEN.LSB),					  loc(addr(event(event.duration.msb))));		return 0;	end;	/* for RTE notes - just set type.  User must extract info. */	if isa.rte.note then do;		event(event.type) = event.type.rte;		return 0;	end;	/* if this track is a cue track,  then expand note record */	/* information for cues and events:                       */	if trk.head.lookup(#trk,thd.cue.track)<>0	then do;													/* is a cue trk */		/* expand the note record information: */		event(event.type    ) = event.type.cue;	/* assume cue   */		event(event.priority) = shr(#w2, 6)&"37";	/* get priority */		event(event.output  ) = shr(#w2,11)&"37";	/* and output # */		event(event.volume  ) = #w3 & 255;			/* 0 - rte.max  */		event(event.pan     ) = shr(#w4,8);			/* unk. format  */		event(event.key#    ) = (#w2&"77") \ shr(#w1&"074000",6);	/* get key */		event(event.cue.id  ) = 0;						/* assume no id */		/* convert volume to 0 - 1000 for users: */		event(event.volume) = SCALE.RTE.TO.PERCENT(event(event.volume));		/* Look up cue id from keyboard look up table for cues: */		/* Initialize pointer to find event info on first try   */		/* for events                                           */		ourtimb = TRK.HEAD.LOOKUP(#trk,thd.ctimb);	/* get timbre # for this track */		ptl     = shr(event(event.key#),8);				/* get partial we should be on */		ptlptr  = TIM.HEAD.LOOKUP(ourtimb,tim.partial.pointers + ptl);		kbdtab  = TIM.HEAD.LOOKUP(ourtimb,tim.kbdtab.ptr       + ptl);		if p.lookup(ptlptr)<>SUP then do;	/* double check make sure partial exists */			/* if kbdtab exists, then look up cue id (for cues), or look */			/* point pointer to event.  Note:  kbdtab may exist but may  */			/* be filled with zeroes (for example if DTD is not running  */			/* yet.  Must perform linear search in that case.            */			if kbdtab<>0 then do;							/* table exists    */				write(mam)=tim.ptr+kbdtab-1;				/* point to it     */				write(mal)=event(event.key#) & 255;		/* point to entry  */				if read(md) >= 0 then do;					event(event.cue.id) = read(md);		/* get possible ID */					ptlptr = ptlptr + num.params;			/* point to frame  */				end;				/* Else set up pointers to event record */				else do;					ptlptr = ptlptr - read(md);			/* point to frame  */				end;			end;			else ptlptr = ptlptr + num.params;			/* point to frame  */			/* look up cue name and get event info from */			/* timbre area.                             */			do while (event(event.cue.name) = 0  )		/* look through frame */			and      (p.lookup(ptlptr)      = MOR);	/* list for match.    */				WRITE("313")=READ(MDI);		/* SKIP MOR                   */				k           =READ(MDI);		/* get and save type          */				l           =read(mdi);		/* get and save len           */				m           =read(mdi);		/* get and save poss key#     */				if  ((k = cu.type)			/* patch list is cue          */				or   (k = ev.type))			/* or is an event             */				and ((m+shl(ptl,8)) = event(event.key#))				then do;							/* here we are                */					/* get cue name: */					if k = ev.type				/* point to name in ev.type   */					then call p.lookup(ptlptr+ev.name);					event(event.cue.name)=read(mdi);					if event(event.cue.name) igt event.cue.max.bytes					then event(event.cue.name) = event.cue.max.bytes;					call copy.in(addr(event(event.cue.name+1)),shr(event(event.cue.name)+1,1));					if k = ev.type then do;	/* for event,  get more info */						event(event.type  ) = event.type.event;						event(event.cue.id) = p.lookup(ptlptr+ev.cue.id);	/* get cue id# */						call p.lookup(ptlptr+ev.in.msb);						call copy.in(addr(event(event.in.msb)),ev.name-ev.in.msb);						if code = 1 then do;							call p.lookup(ptlptr+ev.name+shr(event(event.cue.name)+3,1));							event(event.caption)=read(mdi);							if event(event.caption) igt event.cap.max.bytes							then event(event.caption) = event.cap.max.bytes;							call copy.in(addr(event(event.caption+1)),shr(event(event.caption)+1,1));						end;						call SUB32(loc(addr(event(event.out.msb))),									  loc(addr(event(event.in.msb ))),									  loc(addr(event(event.duration.msb))));						/* leave duration in samples for our internal */						/* purposes (most for speed reasons)          */					end;				end;				ptlptr = ptlptr+l;						/* advance by len */			end;		end;	end;	else do;													/* music track */		event(event.type  ) = event.type.note;		event(event.key#  ) = EXTRACT.KEY(loc(addr(#w1)));		event(event.volume) = #w3 & 255;				/* 0 - rte.max */		/* convert volume to 0 - 1000 for users: */		event(event.volume) = SCALE.RTE.TO.PERCENT(event(event.volume));		call EXTRACT.DUR(loc(addr(#w1)),loc(addr(event(event.duration.msb))));	/* GET DURATION FROM NOTE RECORD */		/* check to see if this is actually a RAM event */		ourtimb = TRK.HEAD.LOOKUP(#trk,thd.ctimb);	/* get timbre # for this track */		ptlptr  = TIM.HEAD.LOOKUP(ourtimb,tim.partial.pointers);	/* lookup partial pointer */		kbdtab  = TIM.HEAD.LOOKUP(ourtimb,tim.kbdtab.ptr);	/* and kbd lookup table pointer */		if p.lookup(ptlptr)<>SUP then do;	/* double check make sure partial exists */			if kbdtab<>0 then do;							/* table exists    */				WRITE(MAM)=TIM.PTR+KBDTAB-1;				/* point to entry in kbdtab for this key */				WRITE(MAL)=(event(event.key#)*KLT.SIZE)+KLT.PATCH.TIM.PTR;				IF READ(MD)<>0 THEN DO;								/* entry exists */					CALL P.LOOKUP(ptlptr+read(md)+PT.TLEN);	/* set mam/mal to patch frame data we need */					DO k=PT.TLEN TO PT.COPYL-1;					/* copy data into misc.buf */						MISC.BUF(k)=READ(MDI);					END;					IF  (MISC.BUF(PT.EVENT)<>0)		/* true if this is ram event */					THEN DO;						event(event.type  ) = event.type.poly;						/* lookup in/out times from patch list */						call COMPUTE.POLY.HZ.INFO(#trk, event(event.key#), 0);	/* lookup freq info for this note */						NOTEADD=shl(NOTEADD,MISC.BUF(PT.STEREO));						msb=misc.buf(pt.insofs)-shr(bl.poly,8);	/* subtract poly sampling hdr offset from in time */						lsb=misc.buf(pt.inwofs);						if msb igt misc.buf(pt.insofs)						then do;msb=0;lsb=0;end;						bitmsb = shr(msb,8);								/* load into globals in 32 bit sample# format */						bitlsb = lsb\shl(msb,8);						call ratio_multiply(NOTENUM, NOTEINC*NOTEADD);	/* convert to milliseconds */						call ratio_multiply(99, 10000);						call ratio_multiply(SAMP.SPEED, 1000);				/* adjust for sequence speed */						call COPY32(BitMSBArray,loc(addr(event(event.in.msb))));	/* copy into event in time field */						/* now compute total length in milliseconds */						IF (MISC.BUF(PT.ONLOOP)<>3)		/* if looping then use duration extracted from note record above */						then do;							call COPY32(loc(addr(MISC.BUF(PT.TLEN))),BitMSBArray);							call ratio_multiply(NOTENUM, NOTEINC*NOTEADD);	/* convert to milliseconds */							call ratio_multiply(99, 10000);							call ratio_multiply(SAMP.SPEED, 1000);				/* adjust for sequence speed */							call COPY32(BitMSBArray,loc(addr(event(event.duration.msb))));	/* copy into event duration field */						end;						/* now use in time + dur to get event out time */						call ADD32 (loc(addr(event(event.in.msb))),										loc(addr(event(event.duration.msb))),										loc(addr(event(event.out.msb))));					END;				END;			END;		END;	end;	return 1;end expand.event.note;/* $PAGE - ALLOCATE NLS BLOCKS FOR DATA STORAGE *//* ALLOCATE NLS BLOCKS FOR DATA STORAGE IS USED TO ALLOCATE *//* NLS'S THAT WILL BE USED TO STORE DATA OTHER THAN NOTES   *//* THE FIRST APPLICATION OF THIS ROUTINE IS TO ALLOCATE     *//* STORAGE FOR STORING THE LOCATE STACK                     *//* ROUTINE RETURNS TRUE IF STORAGE ALLOCATED, ELSE FALSE    */ALLOCATE.NLS.BLOCKS.FOR.DATA.STORAGE:PROC (TRACKNUM, NUMBLOCKS) PUBLIC SWAPABLE;	DCL TRACKNUM       FIXED;		/* ABS TRACK #       */	DCL NUMBLOCKS      FIXED;		/* # OF NLS'S TO GET */	DCL (I,J,K)        FIXED;	GET.TRK.HEAD: PROC (TRK) FIXED;	/* ALLOCATE TRK HEAD; RETURNS ABS PTR TO IT */		DCL TRK FIXED;		IF ALLOCATE.TRK.HEADER(TRK)=0	/* TRY TO CREATE THE THD     */		THEN DO;								/* NONE AVAILABLE            */			RETURN 0;						/* NO MEMORY - BOMB OUT      */		END;		WRITE(MAM)=TRK.HEAD;				/* GET ABS PTR TO NEW THD    */		WRITE(MAL)=TRK;		RETURN READ(MD);					/* RETURN ABS PTR TO NEW THD */	END GET.TRK.HEAD;						/* OF ALLOCATE NEW TRK HEAD  */	#TRK = TRACKNUM;						/* ASSIGN TRACK # OF INTEREST */	WRITE(MAM) = TRK.HEAD;				/* GET ITS TRACK HEAD         */	WRITE(MAL) = #TRK;					/* IF ANY                     */	#PTR = READ(MD);	IF #PTR = 0 THEN DO;		#PTR = GET.TRK.HEAD(#TRK);		/* ALLOCATE TRK HEAD FOR IT    */		IF #PTR=0 THEN RETURN 0;		/* RAN OUT OF MEMORY - QUIT    */	END;	/* COUNT HOW MANY BLOCKS ARE THERE */	WRITE(MAM) = #PTR;					/* SET THD.IGNORE BIT FOR ANY  */	WRITE(MAL) = THD.IGNORE;			/* DATA TRACKS IN CASE NOTES   */	WRITE(MD ) = 1;						/* MYSTERIOUSLY GET ADDED.     */	WRITE(MAL) = THD.FOR;	I=0;	DO WHILE READ(MD) <> 0;		I = I + 1;		WRITE(MAM) = NAH.PTR + READ(MD);		WRITE(MAL) = NLS.FOR;	END;	IF I IGE NUMBLOCKS					/* IF ENOUGH BLOCKS ALREADY */	THEN RETURN 1;							/* AVAIL, THEN DONE         */	WRITE(MAM) = #PTR;					/* GET INFO FROM TRK HEAD   */	CALL LOAD.#.INFO(THD.NMSB);		/* GET CURRENT PLAY INFO    */	IF #SEC=0 THEN DO;					/* GET FIRST NLS            */		IF ALLOCATE.FIRST.NLS=0 THEN RETURN 0;	/* OUT OF MEMORY   */		I = I + 1;							/* HAVE 1 BLOCK NOW         */	END;	ELSE DO;									/* POSITION POINTERS TO END */		DO WHILE #ANYF <> 0;				/* OF CURRENT TRACK         */			CALL ADVANCE.TO.NEXT.NOTE;		END;	END;	DO WHILE NUMBLOCKS IGT I;			/* NOW ALLOCATE MORE        */		IF ALLOCATE.NEXT.NLS(0)=0		/* GET ANOTHER NLS          */		THEN RETURN 0;		I = I + 1;	END;	RETURN 1;END ALLOCATE.NLS.BLOCKS.FOR.DATA.STORAGE;/* $page - compute sound file offset time                          *//* computes the # of milliseconds from the start of the sound file *//* to the mark offset point at the passed pitch, assuming          *//* no other pitch bending is occurring.                            *//* it is passed a code to either compute the offset time or the    *//* end time of the sound file.                                     *//* The time value returned is a REAL time not a SEQUENCE time.     */COMPUTE.SOUND.FILE.OFFSET.TIME: proc(trk, key, time, code) PUBLIC swapable;	dcl trk							fixed;	/* abs track #           */	dcl key							fixed;	/* pitch                 */	dcl time							array;	/* offset time returned  */	dcl code							fixed;	/* 0 for offset, 1 = end */	DCL TKEY							FIXED;	DCL (I,J,K)						FIXED;	DCL PARTIAL						FIXED;	DCL FRAMEBASE					FIXED;	dcl syntyp						fixed;	dcl start.time (2)			fixed;	dcl offset.time(2)			fixed;	dcl compare_times				proc (array,array,fixed)	external;	dcl time_normalize			proc (array)					external;	/* assume offset time will be zero: */	call STR32(0, 0, time);	tkey = key + TRK.HEAD.LOOKUP(trk,thd.cxpos);	/* correct key # for current transposition */	if  (tkey >=0)								/* look up offset if */	and (tkey <num.keys)						/* key is in range   */	then do;		i = TRK.HEAD.LOOKUP(trk,thd.ctimb);			/* get timbre # for this track */		do partial=0 to num.partials-1;						/* loop over partials */			syntyp=TIM.HEAD.LOOKUP(i,tim.synth.typ+partial);	/* get syntyp */			j=TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+partial);			/* look up pointer */			if j<>0 & (syntyp=tim#poly) then do;	/* pointer exists, poly file */				write(mam)=tim.ptr+j-1;				/* point to table     */				write(mal)=tkey * klt.size + klt.patch.tim.ptr;	/* index by key# */				if (read(md)<>0) then do;	/* if entry exists find out if there is an offset */					framebase          = read(mdi);					/* save & skip over frame pointer */					sfile.base(lw#msb) = read(mdi) & base#only;	/* poly bin/page# w/o stereo flag */					sfile.base(lw#lsb) = read(md);					/* get sector of poly memory */					if code = 0 then do;						/* get mark offset */						call psmread(sfile.base,sf.hdr,sf.mark.offset);						do k=0 to 2;							offset.time(k)=read(psd);						end;					end;					else do;										/* get mark end */						call psmread(sfile.base,sf.hdr,sf.mark.end);						do k=0 to 2;							offset.time(k)=read(psd);						end;					end;					call psmread(sfile.base,sf.hdr,sf.mark.start);					do k=0 to 2;						start.time(k)=read(psd);				/* get mark start */					end;					if compare_times(offset.time,start.time,3)>0		/* if offset time exists */					and (COMPUTE.POLY.HZ.INFO(trk,key,partial)<>0)	/* and polyhz globals are successfully set */					then do;														/* then go to town */							do k=0 to 2;											/* get difference */							offset.time(k)=offset.time(k)-start.time(k);						end;						call time_normalize(offset.time);						/* compute nominal 32-bit # of milliseconds */						load offset.time(0);						uload offset.time(1);	/* ADDEND */						mul 1000;						bitmsb=ures; bitlsb=res;						if offset.time(2) ige 500 then call add16(1,BitMsbArray);	/* ROUND */						/* GET NOMINAL SAMPLE RATE FROM SOUND FILE */												call psmread(sfile.base,sf.hdr,sf.sample.rate);						K=read(psd);					/* sound file sampling rate in increments of 100 Hz */												/* SCALE NOMINAL MILLISECONDS TO ACTUAL MILLISECONDS */												if K ine 0 then do;			/* IF SOUND FILE WAS CREATED WITH STM THEN USE STM INFO */							call ratio_multiply(99*notenum,noteadd*noteinc*10);	/* first scale up to minimize resolution loss */							call ratio_multiply(K,10000);									/* then scale down */						end;						else do;							/* IF SOUND FILE WAS CREATED IN SFM THEN USE D66 INFO */							call psmread(sfile.base,sf.hdr,sf.period.index);							K=read(psd);				/* the number of D66 clock ticks per sampling period */							call ratio_multiply(99*notenum,noteadd*noteinc);	/* first scale up to minimize resolution loss */							call ratio_multiply(3,K);									/* then scale down */						end;						k=TIM.HEAD.LOOKUP(i,tim.partial.pointers+partial);	/* look up pointer to partial info */						j=p.lookup(k+p.edelay);										/* look up envelope delay */						bitlsb=bitlsb+j;						if bitlsb ilt j then bitmsb=bitmsb+1;						call ratio_multiply(samp.speed,1000);					/* adjust for sequence speed */						call COPY32(BitMsbArray, Time);						return true;					end;	/* of "go to town"        */				end;		/* of file exists for key */			end;			/* kbdtab exists, is poly */		end;				/* of loop over partial   */	end;					/* of xposed key in range */	return false;		/* FM, no file, no fun, etc. etc. etc. */end COMPUTE.SOUND.FILE.OFFSET.TIME;/* $page - Look up sound file caption *//* Look Up Sound File Caption is used to extract the caption from the *//* sound file on a certain key of a track.                            *//* caption is limited to 64 characters so a 33 word array can be      *//* passed to receive it.                                              */LOOK.UP.SOUND.FILE.CAPTION: proc(trk, key, capt, code) PUBLIC swapable;	dcl (trk)                    fixed;	/* abs track #           */	dcl (key)                    fixed;	/* pitch                 */	dcl (capt)                   array;	/* caption returned      */	dcl (code)                   fixed;	/* at the moment unused  */	DCL (TKEY)                   FIXED;	DCL (I,J)                    FIXED;	DCL (PARTIAL)                FIXED;	DCL (FRAMEBASE)              FIXED;	dcl (syntyp)                 fixed;	/* assume caption does not exist: */	capt(0) = 0;	tkey = key + TRK.HEAD.LOOKUP(trk,thd.cxpos);	/* correct key # for current transposition */	if  (tkey >=0)								/* look up offset if      */	and (tkey <num.keys)						/* key is in range        */	then do;		i = TRK.HEAD.LOOKUP(trk,thd.ctimb);			/* get timbre # for this track */		do partial=0 to num.partials-1;						/* loop over partials */			syntyp=TIM.HEAD.LOOKUP(i,tim.synth.typ+partial);	/* get syntyp */			j=TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+partial);			/* look up pointer */			if j<>0 & (syntyp=tim#poly) then do;	/* pointer exists, poly file */				write(mam)=tim.ptr+j-1;				/* point to table     */				write(mal)=tkey * klt.size + klt.patch.tim.ptr;	/* index by key# */				if read(md)<>0 then do;				/* if entry exists, print it */					framebase          = read(mdi);					/* save & skip over frame pointer */					sfile.base(lw#msb) = read(mdi) & base#only;	/* poly bin/page# w/o stereo flag */					sfile.base(lw#lsb) = read(md);					/* get sector of poly memory */					call psmread(SFILE.BASE,SF.HDR,sf.id.field.bytes);	/* get byte count of sound file caption */					capt(0)=read(psd);					if capt(0) IGT 64						/* cannot display more than 43 characters across the screen */					then capt(0) = 64;					j=shr(capt(0)+1,1);					/* convert to word count */					do i=1 to j;						capt(i)=read(psd);					end;					/* Keep looking if caption is null string: */					if capt(0) <> 0 then return 1;				end;			/* of file exists for key  */			end;				/* kbdtab exists, is poly  */		end;					/* of loop over partial    */	end;						/* of xposed key in range  */	return 0;				/* FM, no file, etc. etc. etc. */end LOOK.UP.SOUND.FILE.CAPTION;/* $page - Handy routine to Get.Event.HZ.Information for event *//* This routine is used to look up some information about      *//* a POLY sampling note.  It is passed an EVENT record that    *//* describes the note, and an info record in which it  puts    *//* information.                                                *//* It returns true if the information was able to be computed, *//* else it returns false.                                      *//* NOTE: Logical HZ information is returned, not hardware HZ.  */Get.Event.HZ.Information: proc(Event, Info) public swapable;	dcl (Event)              array;	/* pass complete event     */	dcl (Info )              array;	/* returns info here       */												/* see seqlits for Hzinfo contents */	DCL (TKEY)               FIXED;	/* transposed key          */	DCL (I,J,K,framebase)    FIXED;	DCL (PARTIAL)            FIXED;	dcl (syntyp)             fixed;	dcl (trk)                fixed;	/* abs track #             */	dcl (key)                fixed;	/* pitch                   */	dcl (msb, lsb)           fixed;	dcl (stereo)             fixed;	dcl COMPUTE.POLY.HZ.INFO proc  (fixed, fixed, fixed) external;	dcl NOTEINC              fixed                       external;	dcl NOTENUM              fixed                       external;	dcl NOTEADD              fixed                       external;	trk = Event(Event.Track#);			/* get track #             */	key = Event(Event.Key#  );			/* get key# handy          */	tkey = key + TRK.HEAD.LOOKUP(trk,thd.cxpos);	/* correct key # for current transposition */	info(Hzinfo.delay)   =   0;	info(Hzinfo.noteinc) =  99;		/* initialize to 50 khz    */	info(Hzinfo.notenum) = 200;		/* values in case of fail  */	info(Hzinfo.noteadd) =   1;	info(Hzinfo.onloop)  =   0;	if  (tkey <0)							/* check for out of range  */	or  (tkey >=num.keys)				/* transposed key#         */	then return 0;	i = TRK.HEAD.LOOKUP(trk,thd.ctimb);			/* get timbre # for this track */	do partial=0 to num.partials-1;				/* loop over partials */		syntyp=TIM.HEAD.LOOKUP(i,tim.synth.typ+partial);	/* get syntyp */		j=TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+partial);		k=TIM.HEAD.LOOKUP(i,tim.partial.pointers+partial);		if (j<>0) & (syntyp=tim#poly) then do;	/* pointer exists, poly file */			write(mam)=tim.ptr+j-1;				/* point to table     */			write(mal)=tkey * klt.size + klt.patch.tim.ptr;	/* index by key# */			framebase = read(md);				/* get pointer to this patch frame */			if framebase<>0						/* if entry exists, print it */			then do;				call COMPUTE.POLY.HZ.INFO(trk,key,partial);				info(Hzinfo.delay)   = p.lookup(k+p.edelay);	/* look up envelope */				info(Hzinfo.noteinc) = NOTEINC;				info(Hzinfo.notenum) = NOTENUM;				info(Hzinfo.noteadd) = NOTEADD;				/* Look up the mark start point from the path list to       */				/* handle regular sound files and poly events:              */				call p.lookup(k+framebase+pt.sofs);		/* look up pt.srate entry */				msb = read(mdi) - shr(bl.poly, 8);		/* get pt.sofs      */				lsb = read(md );								/* get pt.wofs      */				info(Hzinfo.ms.msb) = shr(msb,8);		/* convert to 32    */				info(Hzinfo.ms.lsb) = shl(msb,8) \ lsb;	/* bit sample #     */				/* Check for looping patch entry and setup info accordingly */				if p.lookup(k+framebase+pt.onloop)=3	/* looping patch entry */				then do;					call p.lookup(k+framebase+pt.tlen);	/* user total length */					msb = read(mdi);							/* read in total length */					lsb = read(mdi);					if (msb\lsb)=0								/* no user loop specified */					then do;										/* check for sf loop */						call p.lookup(k+framebase+pt.sftl);	/* point to sound file total length */						msb = read(mdi);						/* read in sf tot len */						lsb = read(mdi);					end;					if ((msb\lsb) <> 0)						/* make sure we have a loop */					then do;						info(Hzinfo.tlen.msb)=msb;			/* total length */						info(Hzinfo.tlen.lsb)=lsb;						info(Hzinfo.llen.msb)=read(mdi);	/* loop length */						info(Hzinfo.llen.lsb)=read(md);						info(Hzinfo.onloop) = 1;			/* set looping bool */					end;				end;		/* of looping soundfile */				/* Compute event duration in 32 bit samp format */				stereo = p.lookup(k+framebase+pt.stereo);		/* get stereo info */				NOTEADD = shl(NOTEADD,stereo);					/* account for stereo files */				call COPY32(loc(addr(Event(event.duration.msb))), BitMsbArray);	/* copy to global    */				call ratio_multiply(1000, SAMP.SPEED);			/* get clock msecs   */				call ratio_multiply(10000, 99);				call ratio_multiply(NOTEINC*NOTEADD, NOTENUM);				call COPY32(BitMSBArray, loc(addr(info(Hzinfo.len.msb))));	/* copy result back into info record */				info(Hzinfo.extend) = 0;				/* set to zero for defualt */																/* allows only "event" audio to be scrubbed */				return 1;			end;		end;				/* kbdtab exists, is poly */	end;					/* of loop over partial   */	return 0;end Get.Event.HZ.Information;/* $page - subroutine to look up sound file name */Get.SF.Name: proc(trk, key#, cname) PUBLIC swapable;	dcl trk     fixed;	dcl key#    fixed;	dcl cname   array;	dcl (i,j,k) fixed;	dcl syntyp  fixed;	dcl partial fixed;	/* look up timbre name as default for notes with no */	/* sound files:                                     */	call LOOKUP.TRACK.TIMBRE.NAME(trk, cname);	if cname(0) = 0	then call COPY.STRING('Note', cname);	if inc.poly = 0		/* no sound file avail */	then return 0;	i = TRK.HEAD.LOOKUP(trk, thd.ctimb);				/* get timbre # for this track */	key# = key# + trk.head.lookup(trk, thd.cxpos);	/* correct key # for current transposition */	if key# < 0         then return;	if key# >= num.keys then return;	do partial=0 to num.partials-1;						/* loop over partials */		syntyp = TIM.HEAD.LOOKUP(i,tim.synth.typ+partial);	/* get synth type used */		j = TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+partial);		/* look up pointer */		if  (syntyp =  tim#poly)		and (j      <> 0       )		then do;			write(mam)=tim.ptr+j-1;				/* point to table */			write(mal)=key# * klt.size + klt.patch.tim.ptr;	/* index by key number */			if read(mdi)<>0 then do;			/* if entry exists, print it */				sfile.base(lw#msb)=read(mdi) & base#only;	/* poly bin/page# w/o stereo flag */				sfile.base(lw#lsb)=read(md);					/* get sector of ext/poly memory */				call ps.extract;									/* info from poly memory */				do k=0 to 3;					cname(k+1) = misc.buf(bl.fname+k);		/* copy name to print buffer for printing */				end;				do k=0 to 7;										/* pad with spaces */					if (byte(cname,k)=0)					then call pbyte(cname,k,sp);				end;				cname(0)=8;			end;				/* of entry exists */		end;	end;end Get.SF.Name;/* Compute default note sets up #w1 - #w4 for adding a music note to *//* a track.   For sampled sounds,  the note will be an a3 that       *//* lasts as long as the sounf file.                                  *//* Compute default note must be passed the SEQUENCE TIME             *//* at which the note is to be triggered,  so the correct             *//* sequence duration can be computed based upon the tempo map.       */Compute.Default.Note: proc(trk, trktime) public swapable;	dcl trk      fixed;	dcl trktime  array;	dcl dur      fixed;	dcl time(1)  fixed;	#w1 = 0;								/* set up for a two word record in case we can't get a sound file */	#w2 = Sync.Middle.C + 9 - 12;	/* default to a3 even if sound file isn't found */	#w3 = rte.max;	#w4 = vel.note;	/* if is a music track,  and a sound file exists for A3,  then */	/* set up default note to trigger this sound:                  */	if  (TRK.HEAD.LOOKUP(trk, THD.CUE.TRACK) = 0)	and (COMPUTE.SOUND.FILE.OFFSET.TIME(trk, Sync.Middle.C + 9, time, 1) <> 0)	then do;		call Map.Real.Duration.To.Sequence.Duration(trktime, time, time);		dur=MSEC.TO.DURATION(time);		#w1 = (#w1 & "103777") \ shl((dur&"036000"),1);	/* load exponent and 2-bit mantissa (msb) */		#w2 = (#w2 &     "77") \ shl( dur, 6);				/* load rest of mantissa             */		#w2=  (#w2 & "177700") \ (Sync.Middle.C + 9 - 12);	end;end Compute.Default.Note;/* $page - audition music note *//* Audition Music Note is used to audition a music note ie not a cue *//* trigger or an event.                                              *//* note:  call this routine with all variables intact.               *//*        specifically: #trk, #w1, #w2, #w3, #w4                     *//* note:  the note will not stop playing until other action is       *//*        taken - ie it will sound for ever.                         */Audition.Music.Note: proc PUBLIC swapable;	dcl i    fixed;	dcl Nptr fixed;			/* local nptr ***** */	insert ':synlits:quelits';	if (isa.ilp.note )		/* cannot play these kinds */	or (isa.rest.note)		/* of notes                */	or (isa.rte.note )	then return;	write(mam) = trk.head;	/* verify that #ptr        */	write(mal) = #trk;		/* is up to date.          */	#ptr = read(md);	if #ptr = 0 then return;	/* no track head?       */	i = Play.Seq.Note(#ptr, #w1, #w2, #w3, #w4);	/* mess with note end time in que list so note sounds */	/* for as long as we hold the mouse.  Also mark fendm */	/* for stop.info.notes.                               */	if trk.head.lookup(#trk, THD.CUE.TRACK) = 0	/* verify that this is */	then do;													/* not a cue track.    */		if  (i <> 0)			/* if we actually started a note ...       */		and (seqlast <> 0)	/* and there is a noteblock on the cue     */		then do;					/* then hopefully it is our note block!    */			nptr = seqlast;					/* point to it */			IF (MOVE=0) OR (MOVE.SPEED>0)	/* NOT REWINDING                   */			THEN DO;				FENDM=(-1);						/* info note - MARK FOR BUTTON RELEASE         */				FENDL=( 0);			END;			ELSE DO;				FENDM=0;				FENDL=0;			END;			IF PLAY=0 THEN TRIGGER.INFO.NOTES=1;	/* WILL FORCE INFO NOTE TO START */		END;	end;end Audition.Music.Note;