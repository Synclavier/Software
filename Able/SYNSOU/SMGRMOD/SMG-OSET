/* SMG-OSET   $TITLE  Object setting routines   Modified:2002/09/24 - TY  - restored alternate intensity after 14 years (it is now dynamically enabled/disabled in Termulator)   05/24/88 - LSS - turned off half intensity for the Mac (temporary)   12/05/87 - cj  - set screen change in set.object.attr.set   10/19/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   09/25/87 - MWH - Use literals for suffix lengths   */SET.OBJECT.STATUS: proc(id,bit,setting) public swapable;   dcl id      fixed;   dcl bit     fixed;   dcl setting fixed;   dcl status  fixed;   if Locate.Object(id) then do;                        /* Find object */      status = Read.Object(Object.Ptr+O#Status);        /* Get its status word */      if setting = 0 then status = (status & not(bit)); /* Set the passed bit to the passed setting */      else                status = status\bit;      call Write.Object(Object.Ptr+O#Status,status);    /* Write it to the object */      Screen.Changed = true;   end;end SET.OBJECT.STATUS;SET.OBJECT.ACTION: proc(id,bit,setting) public swapable;   dcl id      fixed;   dcl bit     fixed;   dcl setting fixed;   dcl action  fixed;   if Locate.Object(id) then do;                        /* Find object */      action = Read.Object(Object.Ptr+O#Action);        /* Get its action word */      if bit=O#ACT.RealTime.Object then do;         if  ((action&O#ACT.RealTime.Object)=0)  /* not currently set */         and (setting<>0)                        /* but we want to set it */         then Any.RealTime.Objects=Any.RealTime.Objects+1;         if  ((action&O#ACT.RealTime.Object)<>0) /* currently set */         and (setting=0)                         /* but we want to clear it */         then do;            Any.RealTime.Objects=Any.RealTime.Objects-1;            if Any.RealTime.Objects<0 then do; /* programming bug */               Any.RealTime.Objects=0;               call pc(7); call pc(7);            end;         end;      end;      if setting = 0 then action = (action & not(bit)); /* Clear the bit */      else                action = action\bit;          /* Set   the bit */      call Write.Object(Object.Ptr+O#Action,action);    /* Write it to the object */   end;end SET.OBJECT.ACTION;SET.OBJECT.ATTR: proc (id,set,attr) public swapable;   dcl id            fixed;   dcl set           fixed;  /* Which attr set to program */   dcl attr          fixed;  /* Same format at Set.Term.Attr */   dcl attr.word     fixed;   dcl attr.byte     fixed;   dcl old.attr.byte fixed;   dcl newflags      fixed;   dcl newbits       fixed;   dcl status        fixed;   if Locate.Object(id) then do;      if Read.Object(Object.Ptr+O#Type) < 0      /* Graphics Object */      then return;      status    = Read.Object(Object.ptr+O#Status); /* read object status bits */      attr.word = Read.Object(Object.Ptr+O#Attr);   /* and  object attrs       */      if set = 0 then attr.byte = Attr.Word&255;     /* Low byte */      else            attr.byte = shr(Attr.Word,8);  /* High byte */      old.attr.byte = attr.byte;      newflags  = (attr&127);      newbits   = (shr(attr,8)&127);      if (attr&Bit7)<>0 then attr.byte = 0;  /* Normal */      attr.byte = (attr.byte xor ((newflags&attr.byte) xor newbits));      /* CALL DEBUG(3,'SET.OBJ.ATTR: OLD ATTR = ',OLD.ATTR.BYTE); */      /* CALL DEBUG(3,'SET.OBJ.ATTR: NEW ATTR = ',ATTR.BYTE); */      if attr.byte <> old.attr.byte /* force refresh only if changes occurred */      then do;         if set = 0 then attr.word = (attr.word&"177400")\attr.byte;         else            attr.word = (attr.word&255)\shl(attr.byte,8);         /* CALL DEBUG(3,'SET.OBJ.ATTR: WRITING ATTR WORD: ',ATTR.WORD); */         call Write.Object(Object.Ptr+O#Attr,attr.word);         /* if displayed attribute set is not the desired one */         /* or we are changing the desired one,  then we must */         /* refresh the object.   Otherwise (ie changing      */         /* the attr set for the set that is not being used)  */         /* no terminal io is needed                          */         if (shr(status&O#STAT.Disp.Attr.Set,1)<>(status&O#STAT.Attr.Set))          or (((status&O#STAT.Attr.Set)<>0) = set)         then do;            if Check.Update.On.Deposit(Object.Ptr)<>0 then do;  /* See if table should be updated on deposit */               call Update.Object(id);            end;         end;      end;   end;end SET.OBJECT.ATTR;SET.OBJECT.ATTR.SET: proc(id,set) public swapable;   dcl id      fixed;   dcl set     fixed;   if Locate.Object(id) then do;      if Read.Object(Object.Ptr+O#Type) < 0 then return; /* graphics   */      call Set.Object.Status(id,O#STAT.Attr.Set,set&1);  /* Change set */      call Set.Object.Status(id,O#STAT.Update,true);      Screen.Changed = true;   end;end SET.OBJECT.ATTR.SET;SET.TERM.OBJ.ATTR: proc(ptr) public swapable;   dcl ptr      fixed;   dcl attr     fixed;   if (Read.Object(ptr+O#Status)&O#STAT.Attr.Set) = 0  /* Attr set 0 */   then attr = (Read.Object(ptr+O#Attr)&255);          /* Get low byte */   else attr = shr(Read.Object(ptr+O#Attr),8);         /* else get high byte */   call Set.Term.Attr((attr&127)\shl(attr,8)\ATTR#Normal);end SET.TERM.OBJ.ATTR;SET.OBJECT.ARROW.LINKS: proc (id,above,below,left,right) public swapable;   dcl id       fixed;   dcl above    fixed;   dcl below    fixed;   dcl left     fixed;   dcl right    fixed;   if Locate.Object(id) then do;      call Write.Object(Object.Ptr+O#ObjAbove,above);      call Write.Object(Object.Ptr+O#ObjBelow,below);      call Write.Object(Object.Ptr+O#ObjLeft, left);      call Write.Object(Object.Ptr+O#ObjRight,right);   end;end SET.OBJECT.ARROW.LINKS;SET.OBJECT.MOUSE.ACCESS: proc(id,access) public swapable;   dcl access fixed;  /* Access bits as described by O#ACT literals used below */   dcl id     fixed;   if Locate.Object(id) then do;      write(md) = ((Read.Object(Object.Ptr+O#Action)                    & not (  O#ACT.Left.Press                           \ O#ACT.Middle.Press                           \ O#ACT.Right.Press                           \ O#ACT.Left.Release                           \ O#ACT.Middle.Release                           \ O#ACT.Right.Release))                   \ access);   end;end SET.OBJECT.MOUSE.ACCESS;SET.OBJECT.JOG: proc(id,status) public swapable;   dcl id      fixed;   dcl ptr     fixed;   dcl status  fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      if status then call Write.Object(ptr + O#ACTION,Read.Object(ptr+O#ACTION)\O#ACT.Jog.Enabled);      else call Write.Object(ptr + O#ACTION,Read.Object(ptr+O#ACTION)&not(O#ACT.Jog.Enabled));   end;end Set.Object.Jog;SET.OBJECT.JOG.AMOUNT: proc(id,increment) public swapable;   dcl id           fixed;   dcl increment    fixed;   if Locate.Object(id) then   call write.object(Object.Ptr + O#JogAmount,increment);end Set.Object.Jog.Amount;SET.DEFAULT.ATTR: proc(set,attr) public swapable;   dcl set           fixed;   dcl attr          fixed;   dcl attr.word     fixed;   dcl attr.byte     fixed;   dcl old.attr.byte fixed;   dcl newflags      fixed;   dcl newbits       fixed;   attr.word = Default.Attr;   /* snapshot of global default */   if set = 0 then attr.byte = Attr.Word&255;     /* Low byte */   else            attr.byte = shr(Attr.Word,8);  /* High byte */   old.attr.byte = attr.byte;   newflags  = (attr&127);   newbits   = (shr(attr,8)&127);   if (attr&Bit7)<>0 then attr.byte = 0;  /* Normal */   attr.byte = (attr.byte xor ((newflags&attr.byte) xor newbits));   if set = 0 then attr.word = (attr.word&"177400")\attr.byte;   else            attr.word = (attr.word&255)\shl(attr.byte,8);   Default.Attr = attr.word;end SET.DEFAULT.ATTR;SET.DEFAULT.ACTION: proc (action) public swapable;   dcl action fixed;   Default.Action = action;end SET.DEFAULT.ACTION;SET.SCREEN.ANIMATE: proc (onoffon) public swapable;   dcl onoffon fixed;   Animate.Screen.Enabled = onoffon;end SET.SCREEN.ANIMATE;SET.OBJECT.GET: proc(id,get,setting) public swapable;   dcl id        fixed;  /* id of object */   dcl get       fixed;  /* One of the valid gets from GETMOD */   dcl setting   fixed;  /* 0 - turn get off  1 - turn get on */   dcl cur.gets  fixed;   /* Note: The first get is literally '1' so the first bit of O#ObjGets      is wasted.  We may wish to shift everything by one later */   if Locate.Object(id) then do;      cur.gets = Read.Object(Object.Ptr+O#UserGets);      if setting = 0 then cur.gets = cur.gets&not(bits(get-1));      else                cur.gets = cur.gets\bits(get-1);      call Write.Object(Object.Ptr+O#UserGets,cur.gets);   end;end SET.OBJECT.GET;SET.OBJECT.DEFAULT.GET: proc (id,get,setting) public swapable;   dcl id        fixed;  /* id of object */   dcl get       fixed;  /* One of the valid gets from GETMOD */   dcl setting   fixed;  /* 0 - turn get off  1 - turn get on */   dcl cur.gets  fixed;   if Locate.Object(id) then do;      cur.gets = Read.Object(Object.Ptr+O#ObjectGets);      if setting = 0 then cur.gets = cur.gets&not(bits(get-1));      else                cur.gets = cur.gets\bits(get-1);      call Write.Object(Object.Ptr+O#ObjectGets,cur.gets);   end;end SET.OBJECT.DEFAULT.GET;SET.OBJECT.DRAG: proc (id,state,type.check) public swapable;   dcl id         fixed;   dcl state      fixed;   dcl type.check fixed;   dcl action     fixed;   if Locate.Object(id) then do;      action = Read.Object(Object.Ptr+O#Action);      action = action & not(O#ACT.Drag.Enabled\O#ACT.Drag.Type.Check);      if state then do;         action = action \ O#ACT.Drag.Enabled;         if type.check then action = action \ O#ACT.Drag.Type.Check;         call Write.Object(Object.Ptr+O#Action,action);      end;   end;end SET.OBJECT.DRAG;SET.OBJECT.ERASE: proc (id,erasebits) public swapable;   dcl id        fixed;   dcl erasebits fixed;   if Locate.Object(id) then do;      if Read.Object(Object.Ptr+O#Type)>0 then do; /* object is transparent mode */         if read(md)=O$Frame                       /* for frames only allow full screen erase */         then erasebits=erasebits&O#ERAS.Whole.Screen;         call Write.Object(Object.Ptr+O#EraseMethod,erasebits);      end;   end;end SET.OBJECT.ERASE;SET.OBJECT.DEPOSIT.REPORTING: proc (id,setting) public swapable;   dcl id            fixed;   dcl setting       fixed;   if Locate.Object(id) then do;      if (setting&1) = 0       then write(md) = Read.Object(Object.Ptr+O#Action)\O#ACT.Deposit.Rept.Disabled;      else write(md) = Read.Object(Object.Ptr+O#Action)&Not(O#ACT.Deposit.Rept.Disabled);   end;end SET.OBJECT.DEPOSIT.REPORTING;