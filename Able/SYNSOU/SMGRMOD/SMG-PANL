/* SMG-PANL  $TITLE Panel Management Routines   Modified:   05/24/88 - TSS - Modified MOUSE.SWITCH calls to save and restore MOUSE.CURSOR.TYPE   10/07/87 - MWH - Remove (null) MOVE.SCREEN.SPACE procedure   09/24/87 - MWH - New literals   */dcl Panel.Base     fixed;dcl Panels.In.Use  fixed;dcl MaxRows        lit '24';ALLOCATE.SCREEN.SPACE: proc (min.lines,max.lines,panel.info) returns (fixed) public swapable;   dcl min.lines      fixed;   dcl max.lines      fixed;   dcl panel.info     array;   dcl largest        fixed;   dcl screen(23)     fixed;   dcl freerow (16)   fixed;   dcl freesize(16)   fixed;   dcl freespaces     fixed;   dcl (i,j,k)        fixed;   dcl row            fixed;   dcl size           fixed;   if Panels.In.Use >= 127 then return 0;   i = 0;   do i = 0 to 127;      write(mam) = Panel.Base;      write(mal) = shl(i,1);      row  = read(mdi);      size = read(mdi);      if row >= 0 then do;         do j = row to row+size-1;            screen(j) = 1;         end;      end;   end;   i = 0;   j = 0;   do while (j < maxrows-1);         /* 23 lines of usable space */      if (screen(j) = 0) then do;         freerow(i) = j;         do while (screen(j) = 0) & (j < maxrows-1);            freesize(i) = freesize(i)+1;            j = j + 1;         end;         i = i + 1;      end;      j = j + 1;   end;   freespaces = i;   i = 0;   panel.info(0) = 0;   do while (i < freespaces) & (panel.info(0) = 0);      if (freesize(i) >= min.lines) then do;         panel.info(1) = freerow(i);         if freesize(i) > max.lines         then freesize(i) = max.lines;         panel.info(2) = freesize(i);         write(mam) = Panel.Base;         j = 0;         do while (read(mdi) <> -1) & (j < 127);            write("324") = read(mdi);            j = j + 1;         end;         write(mam) = Panel.Base;         write(mal) = shl(j,1);         write(mdi) = freerow(i);         write(mdi) = freesize(i);         Panels.In.Use = Panels.In.Use+1;         panel.info(0) = j+1;         return true;      end;      i = i + 1;   end;   return false;end ALLOCATE.SCREEN.SPACE;DEALLOCATE.SCREEN.SPACE: proc (id) returns (fixed) public swapable;   dcl id    fixed;   dcl i     fixed;   id = id - 1;   if id < 0 then return 0;   if Panels.In.Use = 0 then return 0;   write(mam) = Panel.Base;   write(mal) = shl(id,1);   write(mdi) = -1;   write(mdi) = -1;   Panels.In.Use = Panels.In.Use - 1;   return 0;end DEALLOCATE.SCREEN.SPACE;ERASE.SCREEN.SPACE: proc (id) returns (fixed) public swapable;   dcl id        fixed;   dcl (i,j,k)   fixed;   dcl saved.cursor.type fixed;   if MG600 then do;      write(mam) = Panel.Base;      write(mal) = shl(id-1,1);      j = read(mdi);      k = read(mdi);      if j >= 0 then do;         do i = j to j+k-1;            call cpos(i,0);            call pc(27);            call ps('[K');         end;         saved.cursor.type = mouse.cursor.type;         call Mouse.Switch(0);         call area.fill(gpos.x(-200),gpos.y((j-1)*100)-1,gpos.x(8300),gpos.y((j+k-1)*100),1,0);         call Mouse.Switch(saved.cursor.type);         call Deallocate.Screen.Space(id);         return 0;      end;      else return id;  /* Not erased */   end;   else return id;     /* Not erased */end ERASE.SCREEN.SPACE;INIT.PANEL.MANAGER: proc (base) public swapable;   dcl base fixed;   dcl i    fixed;   Panel.Base    = base;   Panels.In.Use = 0;   write(mam) = Panel.Base;   do i = 0 to 255;      write(mdi) = -1;   end;end INIT.PANEL.MANAGER;