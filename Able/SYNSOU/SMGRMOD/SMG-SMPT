/* SMG-SMPT  $TITLE  32-bit SMPTE Routines for Screen Manager   Modified:   10/09/89 - cj  - removed incorrect reference to O#MSEC.Type   05/20/88 - MWH - Remove unused procedure; add true 24 hour SMPTE   12/03/87 - MWH - Fix minor bugs   11/30/87 - MWH - Add jogging of 32-Bit SMPTE objects by field   11/25/87 - MWH - Make 32-bit SMPTE use standard token processor   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   10/20/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/20/87 - MWH - Keep screen updated while waiting for events   10/01/87 - MWH - Make unreferenced procedures NON-public   09/25/87 - MWH - Use literals for suffix lengths   */DEFINE.32BIT.SMPTE: proc (id,row,col,width) public swapable;   dcl id    fixed;   dcl row   fixed;   dcl col   fixed;   dcl width fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   if Allocate.New.Object(O#Hlen+O#SMPTE.Size) then do;      call Write.Object(Object.Ptr + O#Type,  O$32Bit.SMPTE);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(Col*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(Row*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(Col*100)+gpix.x(1400));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(Row*100));      call Write.Object(Object.Ptr + O#Id,    Id);      call Write.Object(Object.Ptr + O#Action,Default.Action\O#ACT.Jog.Enabled);      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,Get#In.Char);      call Write.Object(Object.Ptr + O#Trans.Row,row);  /* Trans Row */      call Write.Object(Object.Ptr + O#Trans.Col,col);      call Write.Object(Object.Ptr + O#Trans.Width,width);      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.32BIT.SMPTE;UPDATE.32BIT.SMPTE: proc (ptr) public swapable;   dcl ptr             fixed;   dcl print.time (20) fixed;   dcl status          fixed;   dcl sbits (1)       fixed;  /* Current 32-bit SMPTE value */   dcl smpte (4)       fixed;   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (status and O#STAT.Update) <> 0 then do;      sbits(0) = Read.Object(ptr+O#SMPTE.MSW);      sbits(1) = Read.Object(ptr+O#SMPTE.LSW);      call SBITS.TO.SMPTE(sbits,S$SMODE,smpte);      call CONV.SMPTE.TO.STR(smpte,print.time,0,0);      call pad.string(print.time,a.sp,Read.Object(ptr+O#Trans.Width));      call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col));      call Set.Term.Obj.Attr(ptr);      call ps(print.time);      if Disable.Attr.Reset=0 then call Set.Term.Attr(ATTR#Normal);      call Write.Object(ptr+O#SMPTE.Disp.MSW,Read.Object(ptr+O#SMPTE.MSW));      call Write.Object(ptr+O#SMPTE.Disp.LSW,Read.Object(ptr+O#SMPTE.LSW));      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */   end;end UPDATE.32BIT.SMPTE;DEPOSIT.32BIT.SMPTE: proc (id,sbits) public swapable;   dcl id        fixed;   dcl ptr       fixed;   dcl status    fixed;   dcl sbits     array;   dcl cbits(1)  fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      status = Read.Object(ptr + O#Status);      cbits(0) = Read.Object(ptr + O#SMPTE.MSW);      cbits(1) = Read.Object(ptr + O#SMPTE.LSW);            call Write.Object(ptr+O#SMPTE.MSW,sbits(0));  /* write new value into it */      call Write.Object(ptr+O#SMPTE.LSW,sbits(1));      if (status & O#STAT.Exhibit) = 0          /* Object never displayed... */      or (cbits(0) <> sbits(0))                 /* ...or value changed */      or (cbits(1) <> sbits(1))      then do;         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.32Bit.SMPTE(ptr);     /* Do update right now */      end;   end;end DEPOSIT.32BIT.SMPTE;GET.32BIT.SMPTE: proc(ptr) returns (fixed) public swapable;   dcl ptr             fixed;   dcl sbits (1)       fixed;   dcl string (40)     fixed;   dcl smpte (4)       fixed;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   sbits(0) = Read.Object(ptr+O#SMPTE.MSW);   sbits(1) = Read.Object(ptr+O#SMPTE.LSW);   call SBITS.TO.SMPTE(sbits,S$SMODE,smpte);   call CONV.SMPTE.TO.STR(smpte,string,0,0);   return (Get.Simple.Token(ptr,string));end GET.32BIT.SMPTE;FETCH.32BIT.SMPTE: proc (id,out.time) public swapable;   dcl id       fixed;   dcl out.time array;   if Locate.Object(id) then do;      out.time(0) = Read.Object(Object.Ptr+O#SMPTE.MSW);      out.time(1) = Read.Object(Object.Ptr+O#SMPTE.LSW);   end;   else do;      out.time(0) = 0;      out.time(1) = 0;   end;end FETCH.32BIT.SMPTE;JOG.32BIT.SMPTE: proc (ptr,mx,my) public swapable;   dcl ptr         fixed;   dcl (mx,my)     fixed;    /* Mouse jog done at these coordinates */   dcl sbits (1)   fixed;    /* SMPTE 32 bits                       */   dcl smpte (4)   fixed;    /* SMPTE time in fields                */   dcl tbits (1)   fixed;    /* Temp SMPTE 32 bits                  */   dcl amount      fixed;    /* Amount to jog each field            */   dcl id          fixed;    /* Object ID                           */   dcl tx          fixed;    /* Transparent mode version of mx      */   dcl num.chars   fixed;    /* Moused at this # chars into string  */   dcl string (30) fixed;    /* String as displayed on terminal     */   dcl pbuf (4)    fixed;    /* Field parsing buffer                */   dcl field       fixed;    /* Which field the user is jogging     */   dcl tbuf (4)    fixed;    /* Alter this by one jog               */   dcl (i,j)       fixed;   amount = 0;   if Last.Event.Info = Mou#Left.Down   or Last.Event.Info = Mou#Left.Up   then amount = -1;                   /* Left => jog down */   else if Last.Event.Info = Mou#Right.Down   or Last.Event.Info = Mou#Right.Up   then amount = 1;                    /* Right => jog up */   if amount <> 0 then do;             /* It was an outside mouse button */      id = Read.Object(ptr + O#ID);      sbits(0) = Read.Object(ptr+O#SMPTE.MSW);      sbits(1) = Read.Object(ptr+O#SMPTE.LSW);      call SBITS.TO.SMPTE(sbits,S$SMODE,smpte);      call CONV.SMPTE.TO.STR(smpte,string,0,0);      call pad.string(string,a.sp,Read.Object(ptr+O#Trans.Width));      /* Now parse string to find fields; store breaks in pbuf */      do i=0 to string(0)-1;        /* Look through the whole string */         if byte(string,i) = dot    /* Find field separators (. or :) */         or byte(string,i) = colon         then do;            pbuf(j) = i;            /* Remember where the field breaks are */            j = j + 1;         end;      end;      pbuf(j) = string(0);          /* Last field goes to end of string */      tx = tpos.x(mx);              /* Get jog position in characters */      num.chars = tx - (Read.Object(ptr + O#Trans.Col));      if num.chars < 0 then num.chars = 0;      do i=4 to 0 by -1;              /* Get field number being jogged */         if num.chars < pbuf(i)         then field = i;              /* Last (lowest) of these is it */      end;      call blockset(tbuf,5,0);        /* Jog one field of this by one */      tbuf(field) = tbuf(field) + 1;      if amount > 0 then call ADD.SMPTE(smpte,tbuf,tbuf,S$SMode);      else               call SUB.SMPTE(smpte,tbuf,tbuf,S$SMode);      call SMPTE.TO.SBITS(tbuf,S$SMode,tbits);      call Deposit.32Bit.SMPTE(id,tbits);      call Update.32Bit.SMPTE(ptr);   end;      /* of outside mouse button */end JOG.32BIT.SMPTE;