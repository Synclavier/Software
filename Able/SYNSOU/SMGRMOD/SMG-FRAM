/* SMG-FRAM   $TITLE  Frames, boxes, and other screen template things   Modified:   05/24/88 - TSS - Modified MOUSE.SWITCH calls to save and restore MOUSE.CURSOR.TYPE   10/19/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   09/25/87 - MWH - Use literals for suffix lengths   */DEFINE.FRAME: proc(id,row,col,depth,width,title) public swapable;   dcl id    fixed;   dcl row   fixed;   dcl col   fixed;   dcl depth fixed;   dcl width fixed;   dcl title array;   dcl i     fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   if Allocate.New.Object(O#Hlen+O#FRAM.Size+shr(title(0)+1,1)+1) then do;      call Write.Object(Object.Ptr + O#Type,  O$Frame);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#Id,    id);      call Write.Object(Object.Ptr + O#Action,O#ACT.Prev.Obj);      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#Trans.Row,Row);  /* Trans Row */      call Write.Object(Object.Ptr + O#Trans.Col,Col);      call Write.Object(Object.Ptr + O#Trans.Width,Width);      call Write.Object(Object.Ptr + O#FRAM.Depth,Depth);      do i = 0 to shr(title(0)+1,1);         call Write.Object(Object.Ptr+O#FRAM.Title+i,title(i));      end;      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.FRAME;UPDATE.FRAME: proc (ptr) swapable; /* redraws value in field of object if different from displayed value */   dcl ptr           fixed; /* ptr to object to update */   dcl status        fixed;   dcl (i,j)         fixed;   dcl (row,col)     fixed;   dcl (depth,width) fixed;   dcl title (40)    fixed;  /* Title of frame */   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if ((status&O#STAT.Exhibit) = 0)      /* Undisplayed */   then do;                              /* Draw frame on screen  */      call Set.Term.Obj.Attr(ptr);       /* Set up terminal attrs */      depth = Read.Object(ptr+O#FRAM.Depth);      width = Read.Object(ptr+O#TRANS.Width);      row   = Read.Object(ptr+O#TRANS.Row);      col   = Read.Object(ptr+O#TRANS.Col);      do i = 0 to shr(Read.Object(ptr+O#FRAM.Title)+1,1);         title(i) = Read.Object(ptr+O#FRAM.Title+i);      end;      call Print.Box.With.Title(row,col,depth,width,title);      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */   end;end UPDATE.FRAME;ERASE.FRAME: proc (id) swapable;   dcl id fixed;   if Locate.Object(id) then do;      call Erase.Box.With.Title(Read.Object(Object.Ptr+O#Trans.Row),                                Read.Object(Object.Ptr+O#Trans.Col),                                Read.Object(Object.Ptr+O#FRAM.Depth),                                Read.Object(Object.Ptr+O#Trans.Width));      write(md) = Read.Object(Object.Ptr+O#Status)\(O#STAT.Update)&not(O#STAT.Exhibit);   end;end ERASE.FRAME;DEFINE.GRAPHICS.BOX: proc(id,ulx,uly,lrx,lry,type) public swapable;   dcl id   fixed;   dcl ulx  fixed;   dcl uly  fixed;   dcl lrx  fixed;   dcl lry  fixed;   dcl type fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   if Allocate.New.Object(O#Hlen+O#GBOX.Size) then do;      call Write.Object(Object.Ptr + O#Type,  O$Graphics.Box);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#Id,    id);      call Write.Object(Object.Ptr + O#Action,O#ACT.Prev.Obj);      call Write.Object(Object.Ptr + O#GBOX.ULX,ulx);      call Write.Object(Object.Ptr + O#GBOX.ULY,uly);      call Write.Object(Object.Ptr + O#GBOX.LRX,lrx);      call Write.Object(Object.Ptr + O#GBOX.LRY,lry);      call Write.Object(Object.Ptr + O#GBOX.Type,type);      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.GRAPHICS.BOX;UPDATE.GRAPHICS.BOX: proc(ptr) swapable;   dcl ptr    fixed;   dcl status fixed;   dcl saved.cursor.type fixed;   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if ((status&O#STAT.Exhibit)=0)   then do;      if gtype<> 0 then do;         vector_mode;         saved.cursor.type = mouse.cursor.type;         call mouse.switch(0);         call data_level(0);         call gbox(Read.Object(ptr+O#GBOX.ULX),                   Read.Object(ptr+O#GBOX.ULY),                   Read.Object(ptr+O#GBOX.LRX),                   Read.Object(ptr+O#GBOX.LRY),                   Read.Object(ptr+O#GBOX.Type));         call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                           \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */         call mouse.switch(saved.cursor.type);         transparent_mode;      end;   end;end UPDATE.GRAPHICS.BOX;ERASE.GRAPHICS.BOX: proc(id) swapable;   dcl id fixed;   dcl saved.cursor.type fixed;   if gtype=0 then return;   if Locate.Object(id) then do;      vector_mode;      saved.cursor.type = mouse.cursor.type;      call mouse.switch(0);      call data_level(1);      call gbox(Read.Object(Object.Ptr+O#GBOX.ULX),                Read.Object(Object.Ptr+O#GBOX.ULY),                Read.Object(Object.Ptr+O#GBOX.LRX),                Read.Object(Object.Ptr+O#GBOX.LRY),                Read.Object(Object.Ptr+O#GBOX.Type));      write(md) = Read.Object(Object.Ptr+O#Status)\(O#STAT.Update)&not(O#STAT.Exhibit);      call mouse.switch(saved.cursor.type);      transparent_mode;   end;end ERASE.GRAPHICS.BOX;