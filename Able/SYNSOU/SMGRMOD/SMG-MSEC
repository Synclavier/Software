/* :SYNSOU:SMGRMOD:SMG-MSEC  $TITLE  32-Bit Millisecond Time Routines *//*Modified:1998/05/20 - TY  - Fixed a bug in GET.32BIT.STRING that caused goofy display of Meas:Beats						 when using a click track.  Also removed unnecessary variable "BPM".1990/07/16 - PF  - Make jogging work with Meter Mapping1990/07/10 - PF  - Perform Meter Mapping on smgr time fields1989/10/04 - cj  - mapped sequence time to real time on output					  - changed 32bit msec data structure to store						 start time and duration so all time mapping can be						 done correctly.1988/10/03 - cj  - added support for O#MSEC.Remap1988/08/22 - cj  - set screen.changed in set.32.bit.msec.time.format.  Also						 better error check for minus values1988/08/18 - cj  - fixed bug in set.32.bit.millisecond.format for tables1988/08/05 - cj  - allow jogging to + and - time values1988/05/20 - MWH - Make SMPTE times true 24 hours; allow jog below zero1988/05/05 - CJ  - Truncated string to match field1987/11/30 - MWH - Make FINISH.JOG swapable1987/11/24 - MWH - Add editing of existing strings to token routine1987/11/17 - MWH - Split into 2 libraries; SMGR is too big1987/11/10 - MWH - Make jogging work in tables1987/10/30 - MWH - Fix bugs in jogging; break up fields for jogging1987/10/20 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY1987/09/25 - MWH - Use literals for suffix lengths1987/09/24 - MWH - Fix bug in setting display format for a whole table   */Define.32Bit.Msec: proc (id,TRow,TCol,width,format,time.or.dur,maxl,maxr) public swapable;   dcl id           fixed;   dcl (TCol,Trow)  fixed; /* Transparent position info */   dcl width        fixed; /* width of field in chars */   dcl format       fixed; /* initial display mode : Beats,SMPTE,etc. */   dcl time.or.dur  fixed; /* initial time type: CF#TIME or CF#DUR */   dcl maxl         fixed;   dcl maxr         fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   If Allocate.New.Object(O#Hlen+O#MSEC.Size) then do;      call Write.Object(Object.Ptr + O#Type,  O$32Bit.Msec);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(TCol*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(TRow*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(TCol*100)+gpix.x(width*100));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(TRow*100));      call Write.Object(Object.Ptr + O#Id,    Id);      call Write.Object(Object.Ptr + O#Action,Default.Action\O#ACT.Jog.Enabled);      if (Default.Action&O#ACT.RealTime.Object)<>0      then Any.RealTime.Objects=Any.RealTime.Objects+1;      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,Get#In.Char);      call Write.Object(Object.Ptr + O#Suffix,TRow);  /* Trans Row */      write(mdi) = TCol;          /* Trans column */      write(mdi) = width;         /* Field width */      call Write.Object(Object.Ptr + O#MSEC.Format,format);      call Write.Object(Object.Ptr + O#MSEC.Type  ,time.or.dur);      call Write.Object(Object.Ptr + O#MSEC.LSW   ,zero.time  );      call Write.Object(Object.Ptr + O#MSEC.Disp.LSW, zero.time);      call Write.Object(Object.Ptr + O#MSEC.Maxl  ,Maxl);      call Write.Object(Object.Ptr + O#MSEC.Maxr  ,Maxr);      call Write.Object(Object.Ptr + O#JogAmount,1);      Screen.Changed = true;      return Id;   end;   else return 0;end Define.32Bit.Msec;/*  $PAGE  The procedure Get.32Bit.String is used to generate the proper *  string when displaying a 32-bit millisecond time.  Given a "ptr" *  to the 32-bit millisecond object, it returns the string in "string". *  It also returns a buffer of data ("buf") in different formats depending *  on O#MSEC.Format.  After calling, "buf" and "string" will contain: * *       FORMAT        BUF(0)   BUF(1)   BUF(2)   BUF(3)   BUF(4)   STRING *       ------        ------   ------   ------   ------   ------   ------ *    0 = SEC MSEC       SEC     MSEC      X        X        X      SEC.MSEC *    1 = BEATS         BEATS  FRACTIONS   X        X        X      BEATS.FRACTIONS *    2 = MEAS BEATS    BEATS  FRACTIONS   X        X        X      MEASURES:BEATS.FRACTIONS *    3 = SMPTE         HOURS   MINUTES  SECONDS  FRAMES    BITS    HOURS:MINUTES:SECONDS:FRAMES.BITS *    4 = FEET FRAMES    FEET    FRAMES    BITS     X        X      FEET:FRAMES.BITS *    5 = MIN SEC        SEC     MSEC      X        X        X      MINUTES:SEC.MSEC * */Get.32Bit.String: proc (ptr,starttime,duration,string,buf) swapable;   dcl ptr         fixed;         /* Pointer to the object     */   dcl starttime   fixed array;   /* sequencer start time      */   dcl duration    fixed array;   /* sequencer duration        */   dcl string      fixed array;   /* Place to return string in */   dcl buf         fixed array;   /* Place to return intermediate data in */   dcl format      fixed;         /* Which format the display is in */   dcl td          fixed;         /* Time or duration */   dcl (maxl,maxr) fixed;         /* Max digits each side of decimal point */   dcl msec    (1) fixed;   dcl seqtime (1) fixed;   dcl seqdur  (1) fixed;   dcl endtime (1) fixed;   format  = Read.Object(ptr+O#MSEC.Format);   td      = Read.Object(ptr+O#MSEC.Type);   maxl    = Read.Object(ptr+O#MSEC.Maxl);   maxr    = Read.Object(ptr+O#MSEC.Maxr);   /* For measure & beat display - get logical beat time from sequence */   /* or real time as needed.                                          */   if ((format & 255) = O#MSEC.Beats         )  /* if display is beats */   or ((format & 255) = O#MSEC.Measures.Beats)  /* or measures:beats   */   then do;                                     /* then handle here.   */      /* get sequence time from real time if needed:                   */      if (format & O#MSEC.RealTime) <> 0     /* first map real times   */      then do;                               /* to sequence times      */         call Map.Real.Time.To.Sequence.Time(starttime, seqtime);         call ADD32(starttime, duration, endtime);         call Map.Real.Time.To.Sequence.Time(endtime, endtime);         call SUB32(endtime, seqtime, seqdur);      end;      else do;                               /* else we can use        */         call COPY32(starttime, seqtime);    /* sequencer times        */         call COPY32(duration,  seqdur );    /* directly               */      end;      /* get logical beat time if needed:                              */      if (Click.Track.Mode igt 3)            /* if live click track    */      then do;                               /* then map time.         */         call Remap.With.Live.Click(seqtime(0), seqtime(1), seqdur(0), seqdur(1), 1);         if td = CF#TIME         then call COPY32(loc(addr(Remapped.Time.Msb)), msec);         else call COPY32(loc(addr(Remapped.Dur.Msb )), msec);      end;      else do;         if td = CF#TIME                     /* if no live click,      */         then call COPY32(seqtime, msec);    /* compute info using     */         else call COPY32(seqdur,  msec);    /* internal click setting */      end;   end;   /* Else for seconds, smpte, feet, mins:seconds, get real time       */   /* from possible sequence time:                                     */   else do;      if (format & O#MSEC.RealTime) = 0     /* if times are seq times, */      then do;                              /* get corresp. real times */         if td = CF#TIME         then call Map.Sequence.Time.To.Real.Time(starttime, msec);         else call Map.Sequence.Duration.To.Real.Duration(starttime, duration, msec);      end;      else do;                                /* else if are real times */         if td = CF#TIME                      /* look up start time or  */         then call COPY32(starttime, msec);   /* duration value as      */         else call COPY32(duration,  msec);   /* needed.                */      end;   end;   /* Now construct the string in the correct format:                   */   do case (format&255);      do;	/* Seconds.Milliseconds */         call MSEC.TO.SEC(msec,td,buf);         call CONV.SEC.MSEC.TO.STR(buf,string,maxl,maxr);      end;      do;	/* Beats */         if Click.Track.Mode igt 3         then call MSEC.TO.BEATS(msec,td,1000,buf);         else do;            if td = CF#TIME            then call Map.Sequence.Time.To.Beats(msec,buf);            else call Map.Sequence.Duration.To.Beats(seqtime,msec,buf);         end;         call CONV.BEATS.TO.STR(buf,string,maxl,maxr); /* Maxl is supressed to knock off measures */      end;      do;	/* Measures:Beats */         if Click.Track.Mode igt 3         then do;				call MSEC.TO.BEATS(msec,td,1000,loc(addr(buf(1))));            if td = CF#TIME				then {load buf(1)-1;div SAMP.BPM;buf(0)=res;buf(1)=rem+1;}				else {load buf(1)  ;div SAMP.BPM;buf(0)=res;buf(1)=rem  ;}			end;         else do;            if td = CF#TIME            then call Map.Sequence.Time.To.Measures.Beats(msec,buf);            else call Map.Sequence.Duration.To.Measures.Beats(seqtime,msec,buf);         end;         call CONV.MEASURES.BEATS.TO.STR(buf,Lookup.Beats.Per.Measure(msec),string,maxl,maxr);         /* now set up buf to be BEATS:FRAC since that is what the caller will expect */         if td = CF#TIME         then call Map.Sequence.Time.To.Beats(msec,buf);         else call Map.Sequence.Duration.To.Beats(seqtime,msec,buf);      end;      do;	/* SMPTE */         if (format & O#MSEC.Alt.Offset) = 0         then call MSEC.TO.SMPTE(msec,td,S$Speed,S$SMode,S$SOffset,   buf);         else call MSEC.TO.SMPTE(msec,td,S$Speed,S$SMode,S$AltSOffset,buf);         call CONV.SMPTE.TO.STR(buf,string,maxl,maxr);      end;      do;	/* Feet:Frames */         if (format & O#MSEC.Alt.Offset) = 0         then call MSEC.TO.FEET(msec,td,S$Speed,S$FMode,S$FOffset,   buf);         else call MSEC.TO.FEET(msec,td,S$Speed,S$FMode,S$AltFOffset,buf);         call CONV.FEET.TO.STR(buf,string,maxl,maxr);      end;      do;	/* Minutes:Seconds */         call MSEC.TO.SEC(msec,td,buf);         call CONV.SEC.MSEC.TO.MIN.SEC.STR(buf,string,maxl,maxr);      end;   end;	/* of do case format */   call Pad.String(string,a.sp,Read.Object(ptr+O#Trans.Width));   if   string(0) > Read.Object(ptr+O#Trans.Width)   then string(0) = Read.Object(ptr+O#Trans.Width);end Get.32Bit.String;/* $PAGE */Update.32Bit.Msec: proc (ptr) public swapable; /* redraws value in field of object if different from displayed value */   dcl (ptr,status)	fixed;	/* ptr to object to update */   dcl msec		(1)	fixed;	/* 32 bit millisecond time */   dcl dur		(1)	fixed;	/* 32 bit duration         */   dcl buf		(4)	fixed;   dcl string	(30)	fixed;   dcl RT				boolean;	/* true if object is more real-time */   RT     = Read.Object(ptr+O#Action) & O#ACT.RealTime.Object;   status = Read.Object(ptr+O#Status);   /* read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (status and O#STAT.Update) <> 0 then do;      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col)); /* Position trans cursor */      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call Set.Term.Obj.Attr(ptr);      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      msec(0) = Read.Object(ptr+O#MSEC.MSW  );      msec(1) = Read.Object(ptr+O#MSEC.LSW  );      dur (0) = Read.Object(ptr+O#MSEC.Dur  );      dur (1) = Read.Object(ptr+O#MSEC.Dur+1);      call Get.32Bit.String(ptr,msec,dur,string,buf);      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call ps(string);      if Disable.Attr.Reset=0 then do;         call Set.Term.Attr(ATTR#Normal);         if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      end;      /* Copy values just displayed into object's display record */      if Read.Object(ptr+O#MSEC.Type) = CF#TIME      then do;         call Write.Object(ptr+O#MSEC.Disp.MSW, Read.Object(ptr+O#MSEC.MSW));         call Write.Object(ptr+O#MSEC.Disp.LSW, Read.Object(ptr+O#MSEC.LSW));      end;      else do;         call Write.Object(ptr+O#MSEC.Disp.MSW, Read.Object(ptr+O#MSEC.Dur  ));         call Write.Object(ptr+O#MSEC.Disp.LSW, Read.Object(ptr+O#MSEC.Dur+1));      end;      call Write.Object(ptr+O#MSEC.Disp.Format,Read.Object(ptr+O#MSEC.Format));      call Write.Object(ptr+O#MSEC.Disp.Type,  Read.Object(ptr+O#MSEC.Type));      call Write.Object(ptr+O#Status          ,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */   end;end Update.32Bit.Msec;Deposit.32Bit.MSEC: proc(id, starttime, dur) public swapable;   dcl id			fixed;   dcl starttime	array;   dcl dur			array;   dcl ptr			fixed;   dcl RT			boolean;	/*	true if object is more real-time	*/   dcl format		fixed;	/*	Which display format					*/   dcl status		fixed;   dcl oldtime(1)	fixed;   dcl olddur (1)	fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      RT  = (Read.Object(Ptr+O#Action)&O#ACT.RealTime.Object);      status = Read.Object(ptr + O#Status);      format = Read.Object(ptr + O#MSEC.Format);      if (RT<>0) then call Run.Syn.Loop;				/*	keep real time code going	*/      oldtime(0) = Read.Object(ptr+O#MSEC.MSW  );      oldtime(1) = Read.Object(ptr+O#MSEC.LSW  );      olddur (0) = Read.Object(ptr+O#MSEC.Dur  );      olddur (1) = Read.Object(ptr+O#MSEC.Dur+1);		Write.Object(ptr+O#MSEC.MSW,	starttime(0));	/*	write new value into it		*/		Write.Object(ptr+O#MSEC.LSW,	starttime(1));		Write.Object(ptr+O#MSEC.Dur,	dur		(0));	/*	write new value into it		*/		Write.Object(ptr+O#MSEC.Dur+1,dur		(1));      if  (( starttime(0)                < 0)		/*	see if user has jogged		*/      or   ( dur      (0)                < 0))      and ((format & O#MSEC.Allow.Minus) = 0 )		/*	to a minus value.				*/      then do;			if starttime(0) < 0			then do;				if (((format&255) == 3) && (SAMP.SPEED igt 20))	//	if displaying as SMPTE				{					dcl wrappedtime(1)	fixed;					dcl wrap_24_hours		proc (fixed array) external;					copy32(starttime, wrappedtime);					//	don't pollute the passed negative starttime					wrap_24_hours(wrappedtime);					Write.Object(ptr+O#MSEC.MSW, wrappedtime(0));					Write.Object(ptr+O#MSEC.LSW, wrappedtime(1));				}				else				{					Write.Object(ptr+O#MSEC.MSW,			0);					Write.Object(ptr+O#MSEC.LSW,Zero.Time);					Set.Error(Err.Lod,'Cannot enter time before start of sequence');				}			end;			if dur(0) < 0 then do;				Write.Object(ptr+O#MSEC.Dur,	 0);				Write.Object(ptr+O#MSEC.Dur+1, 0);				Set.Error(Err.Lod,'Cannot enter negative duration');			end;      end;      if (status & O#STAT.Exhibit) = 0					/*	Object never displayed...	*/      or (starttime(0) <> oldtime(0))					/*	...or value changed			*/      or (starttime(1) <> oldtime(1))      or (dur      (0) <> olddur  (0))      or (dur      (1) <> olddur  (1))      then do;         if (RT<>0) then call Run.Syn.Loop;			/*	Keep real time code going	*/         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.32Bit.Msec(ptr);			/*	Do update right now			*/      end;      if (RT<>0) then call Run.Syn.Loop;				/* Keep real time code going	*/   end;end Deposit.32Bit.MSEC;SET.32BIT.MSEC.DISPLAY.FORMAT: proc (id,format,time.or.dur,maxl,maxr) public swapable;   dcl id          fixed;   dcl format      fixed;   dcl time.or.dur fixed;   dcl (maxl,maxr) fixed;   dcl (i,j)       fixed;   dcl across      fixed;   dcl down        fixed;   dcl cell.ptr    fixed;   if Locate.Object(id) then do;      if Read.Object(Object.Ptr+O#Type) = O$Table then do;         across = Read.Object(Object.Ptr+O#TABL.Across);         down   = Read.Object(Object.Ptr+O#TABL.Down);         do i = 0 to across-1;            do j = 0 to down-1;               cell.ptr = ((j*across+i)*Read.Object(Object.Ptr+O#TABL.Cell.Mem))                        + Object.Ptr + O#TABL.Table;               call Write.Object(cell.ptr+O#TABL.Cell.Data+O#MSEC.Format-O#MSEC.Format, format);               call Write.Object(cell.ptr+O#TABL.Cell.Data+O#MSEC.Type-O#MSEC.Format,   time.or.dur);               call Write.Object(cell.ptr+O#TABL.Cell.Data+O#MSEC.Maxl-O#MSEC.Format,   maxl);               call Write.Object(cell.ptr+O#TABL.Cell.Data+O#MSEC.Maxr-O#MSEC.Format,   maxr);               write(md)=(Read.Object(cell.ptr+O#TABL.Cell.Status)\O#STAT.Update);            end;         end;      end;      else do;         call Write.Object(Object.Ptr+O#MSEC.Format,format);         call Write.Object(Object.Ptr+O#MSEC.Type  ,time.or.dur);         call Write.Object(Object.Ptr+O#MSEC.Maxl  ,maxl);         call Write.Object(Object.Ptr+O#MSEC.Maxr  ,maxr);      end;      call Set.Object.Status(id,O#STAT.Update,true);      Screen.Changed = true;   end;end SET.32BIT.MSEC.DISPLAY.FORMAT;GET.32BIT.MSEC: proc (ptr) returns (fixed) public swapable;   dcl ptr         fixed;   dcl event       fixed;   dcl msec   (1)  fixed;  /* 32 bit millisecond time */   dcl dur    (1)  fixed;   dcl buf    (4)  fixed;   dcl string (40) fixed;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   msec(0) = Read.Object(ptr+O#MSEC.MSW);   msec(1) = Read.Object(ptr+O#MSEC.LSW);   dur (0) = Read.Object(ptr+O#MSEC.Dur  );   dur (1) = Read.Object(ptr+O#MSEC.Dur+1);   call Get.32Bit.String(ptr,msec,dur,string,buf);   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   event=Get.Simple.Token(ptr,string);   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   return event;end GET.32BIT.MSEC;FETCH.32BIT.MSEC: proc(id,out.time) public swapable;   dcl id       fixed;   dcl out.time array;   if Locate.Object(id) then do;      if Read.Object(Object.Ptr+O#MSEC.Type) = CF#TIME      then do;         out.time(0) = Read.Object(Object.Ptr+O#MSEC.MSW);         out.time(1) = Read.Object(Object.Ptr+O#MSEC.LSW);      end;      else do;         out.time(0) = Read.Object(Object.Ptr+O#MSEC.Dur  );         out.time(1) = Read.Object(Object.Ptr+O#MSEC.Dur+1);      end;   end;   else do;      out.time(0) = 0;      out.time(1) = 0;   end;end FETCH.32BIT.MSEC;FINISH.JOG: proc (ptr,msec,dur,t.msec,amount,td,string) swapable;   dcl ptr        fixed;   dcl msec       array;       /* Original start time          */   dcl dur        array;       /* Original duration            */   dcl t.msec     array;       /* Jogged value                 */   dcl amount     fixed;       /* Which way we're jogging      */   dcl td         fixed;       /* Time or duration mode        */   dcl string     array;       /* Initial string value         */   dcl amt32  (1) fixed;       /* 32 bit "1"                   */   dcl tmp    (4) fixed;       /* Temp buffer                  */   dcl nstr  (30) fixed;       /* New string for comparison    */   dcl i          fixed;   call str32(0,1,amt32);   /* Get new string depending on whether we are jogging       */   /* the start time or the duration:                          */   if td = CF#TIME   then call Get.32Bit.String(ptr,t.msec,dur,nstr,tmp);   else call Get.32Bit.String(ptr,msec,t.msec,nstr,tmp);   /* Check for jog of value not yielding a different displayed    */   /* amount (ie happens when jogging SMPTE bit field when only    */   /* 1 msec resolution is provided).                              */   if eqstr(string,nstr) = 0 then do;    /* Hasn't changed yet     */      do i=1 to 20;                      /* Try up to 20 LSB's     */         if amount > 0 then call add32(t.msec,amt32,t.msec);         else               call sub32(t.msec,amt32,t.msec);         /* check for jogging through 0.000 if cf#time   */         if td = cf#time then do;            if  (t.msec(0) = (-1))             /* if wrapping through */            and (t.msec(1) IGE (- zero.time))  /* - 0.000             */            then do;               t.msec(0) = 0;               t.msec(1) = zero.time;            end;            else if  (t.msec(0) = 0)               /* if wrapping through */            and      (t.msec(1) ILT ( zero.time))  /* + 0.000             */            then do;               t.msec(0) = (- 1        );               t.msec(1) = (- zero.time);            end;            call Get.32Bit.String(ptr,t.msec,dur,nstr,tmp);         end;         else call Get.32Bit.String(ptr,msec,t.msec,nstr,tmp);         if eqstr(string,nstr) <> 0 then i=20;  /* Break loop */      end;   end;   if eqstr(string,nstr) = 0             /* OR still no change     */   then return;                          /* Don't jog value        */   /* Store jogged value back in correct variable:                 */   if td = CF#TIME   then call copy32(t.msec,msec);        /* Jogged value is OK     */   else call copy32(t.msec,dur );        /* Jogged value is OK     */end FINISH.JOG;JOG.32BIT.MSEC: proc (ptr,mx,my) public swapable;   dcl ptr         fixed;   dcl (mx,my)     fixed;    /* Mouse jog done at these coordinates */   dcl msec (1)    fixed;   dcl dur  (1)    fixed;   dcl amount      fixed;    /* Amount to jog each field            */   dcl id          fixed;    /* Object ID                           */   dcl format      fixed;    /* Which format the display is in      */   dcl td          fixed;    /* Time or duration                    */   dcl tx          fixed;    /* Transparent mode version of mx      */   dcl num.chars   fixed;    /* Moused at this # chars into string  */   dcl buf (4)     fixed;    /* Buffer returned by Get.32Bit.String */   dcl string (30) fixed;    /* String returned by Get.32Bit.String */   dcl pbuf (4)    fixed;    /* Field parsing buffer                */   dcl field       fixed;    /* Which field the user is jogging     */   dcl tbuf (4)    fixed;    /* Alter this by one jog               */   dcl t.msec (1)  fixed;    /* Try jogging 32 bit number here      */   dcl (i,j)       fixed;   dcl seqtime(1)  fixed;   amount = 0;   if Last.Event.Info = Mou#Left.Down   or Last.Event.Info = Mou#Left.Up   then amount = -1;                   /* Left => jog down */   else if Last.Event.Info = Mou#Right.Down   or Last.Event.Info = Mou#Right.Up   then amount = 1;                    /* Right => jog up */   if amount <> 0 then do;             /* It was an outside mouse button */      id = Read.Object(ptr + O#ID);      msec(0) = Read.Object(ptr+O#MSEC.MSW  );  /* get original time     */      msec(1) = Read.Object(ptr+O#MSEC.LSW  );  /* and duration.         */      dur (0) = Read.Object(ptr+O#MSEC.Dur  );      dur (1) = Read.Object(ptr+O#MSEC.Dur+1);      call Get.32Bit.String(ptr,msec,dur,string,buf); /* get string & info */      /* Now parse string to find fields; store breaks in pbuf */      do i=0 to string(0)-1;        /* Look through the whole string */         if byte(string,i) = dot    /* Find field separators (. or :) */         or byte(string,i) = colon         then do;            pbuf(j) = i;            /* Remember where the field breaks are */            j = j + 1;         end;      end;      pbuf(j) = string(0);          /* Last field goes to end of string */      tx = tpos.x(mx);              /* Get jog position in characters */      num.chars = tx - (Read.Object(ptr + O#Trans.Col));      if num.chars < 0 then num.chars = 0;      do i=4 to 0 by -1;              /* Get field number being jogged */         if num.chars < pbuf(i)         then field = i;              /* Last (lowest) of these is it */      end;      td     = Read.Object(ptr+O#MSEC.Type);      format = Read.Object(ptr+O#MSEC.Format);      call blockset(tbuf,5,0);        /* Jog one field of this by one */      /* get sequence time handy */      if (format & O#MSEC.RealTime) <> 0      then call Map.Real.Time.To.Sequence.Time(msec, seqtime);      else call COPY32(msec, seqtime);      do case (format & 255);         do;  /* Seconds.Milliseconds */            if (format & O#MSEC.RealTime) = 0     /* if times are seq times, */            then do;                              /* get corresp. real times */               if td = CF#TIME               then call Map.Sequence.Time.To.Real.Time(msec, t.msec);               else call Map.Sequence.Duration.To.Real.Duration(msec, dur, t.msec);            end;            else do;                              /* else if are real times */               if td = CF#TIME                    /* look up start time or  */               then call COPY32(msec, t.msec);    /* duration value as      */               else call COPY32(dur,  t.msec);    /* needed.                */            end;            /* remove the zero.time offset for correct jog through 0.000:   */            if td = cf#time then do;               if t.msec(0) < 0 then do;          /* subtract zero.time */                  call ADD16(zero.time, t.msec);  /* for proper jog     */                  if t.msec(0) >= 0               /* thru 0.000         */                  then call STR32(0, 0, t.msec);               end;               else do;                  call SUB16(zero.time, t.msec);                  if t.msec(0) < 0                  then call STR32(0, 0, t.msec);               end;            end;            /* jog milliseconds (if real time display) or jog sequencer */            /* milliseconds (if seq time display) as needed:            */            if amount > 0 then do case field;               call add16(1000,t.msec);  /* Add one second */               call add16(1,t.msec);     /* Add one millisecond */            end;            else do case field;               call sub16(1000,t.msec);  /* Subtract one second */               call sub16(1,t.msec);     /* Subtract one millisecond */            end;            if td = cf#time then do;     /* Add in zero.time after   */               if t.msec(0) < 0 then do; /* jog thru 0               */                  call SUB16(zero.time, t.msec);               end;               else do;                  call ADD16(zero.time, t.msec);               end;            end;         end;         do;  /* Beats */            /* Jog the measure:beat display as needed:             */            tbuf(field) = tbuf(field) + 1; /* jog desired field    */            if td = cf#time then do;       /* remove 1 beat offset */               if buf(0) > 0               /* for correct jog      */               then buf(0) = buf(0) - 1;   /* through 1.000        */            end;            if amount > 0 then call ADD.BEATS(buf,tbuf,tbuf);            else               call SUB.BEATS(buf,tbuf,tbuf);            if td = cf#time then do;       /* restore 1 beat offset */               if  (tbuf(0) >= 0)          /* after correct jog     */               and (tbuf(1) >= 0)          /* through 0.000         */               then tbuf(0) = tbuf(0) + 1;            end;            /* Get real sequence time from logical sequence time    */            /* if using live click track:                           */            if (Click.Track.Mode igt 3)            then do;               call BEATS.TO.MSEC(tbuf,     /* get logical sequence  */                                  td,       /* time based upon       */                                  1000,     /* 1000 ticks/beat       */                                  t.msec);               if (td = cf#time) then do;                  call Remap.With.Live.Click(t.msec(0), t.msec(1), 0, 0, 0);                  t.msec(0) = Remapped.Time.Msb;                  t.msec(1) = Remapped.Time.Lsb;               end;               else do;                  call Remap.With.Live.Click(msec(0), msec(1), t.msec(0), t.msec(1), 0);                  t.msec(0) = Remapped.Dur.Msb;                  t.msec(1) = Remapped.Dur.Lsb;               end;            end;            else do;               if td = cf#time               then call Map.Beats.To.Sequence.Time(tbuf,t.msec);               else call Map.Beats.To.Sequence.Duration(seqtime,tbuf,t.msec);            end;         end;         do;  /* Measures:Beats */            if field=0             /* Jogging measures */            then j=Lookup.Beats.Per.Measure(seqtime);   /* Do jog of "beats per measure" */            else do;               j=1;                /* Do jog of one beat            */               field = field - 1;  /* Point back at beats           */            end;            tbuf(field) = tbuf(field) + j;            if td = cf#time then do;       /* remove 1 beat offset */               if buf(0) > 0               /* for correct jog      */               then buf(0) = buf(0) - 1;   /* through 1.000        */            end;            if amount > 0 then call ADD.BEATS(buf,tbuf,tbuf);            else               call SUB.BEATS(buf,tbuf,tbuf);            if td = cf#time then do;       /* restore 1 beat offset */               if  (tbuf(0) >= 0)          /* after correct jog     */               and (tbuf(1) >= 0)          /* through 0.000         */               then tbuf(0) = tbuf(0) + 1;            end;            /* reconvert back to actual sequence time if using      */            /* live click track:                                    */            if (Click.Track.Mode igt 3)            then do;               call BEATS.TO.MSEC(tbuf,                                  td,                                  1000,                                  t.msec);               if (td = cf#time) then do;                  call Remap.With.Live.Click(t.msec(0), t.msec(1), 0, 0, 0);                  t.msec(0) = Remapped.Time.Msb;                  t.msec(1) = Remapped.Time.Lsb;               end;               else do;                  call Remap.With.Live.Click(msec(0), msec(1), t.msec(0), t.msec(1), 0);                  t.msec(0) = Remapped.Dur.Msb;                  t.msec(1) = Remapped.Dur.Lsb;               end;            end;            else do;               if td = cf#time               then call Map.Beats.To.Sequence.Time(tbuf,t.msec);               else call Map.Beats.To.Sequence.Duration(seqtime,tbuf,t.msec);            end;         end;         do; /* SMPTE */            if Read.Object(ptr+O#MSEC.Maxl) = 8         /* if no hours being shown */            then tbuf(field + 1) = tbuf(field + 1) + 1; /* then jog correct field  */            else tbuf(field) = tbuf(field) + 1;            if amount > 0 then call ADD.SMPTE(buf,tbuf,tbuf,S$SMode);            else               call SUB.SMPTE(buf,tbuf,tbuf,S$SMode);            if (format & O#MSEC.Alt.Offset) = 0            then call SMPTE.TO.MSEC(tbuf,td,S$Speed,S$SMode,S$SOffset,t.msec);            else call SMPTE.TO.MSEC(tbuf,td,S$Speed,S$SMode,S$AltSOffset,t.msec);         end;         do; /* Feet:Frames */            tbuf(field) = tbuf(field) + 1;            if amount > 0 then call ADD.FEET(buf,tbuf,tbuf,S$FMode);            else               call SUB.FEET(buf,tbuf,tbuf,S$FMode);            if (format & O#MSEC.Alt.Offset) = 0            then call FEET.TO.MSEC(tbuf,td,S$Speed,S$FMode,S$FOffset,t.msec);            else call FEET.TO.MSEC(tbuf,td,S$Speed,S$FMode,S$AltFOffset,t.msec);         end;         do; /* Minutes:Seconds */            if td = cf#time then do;     /* remove zero.time to jog thru 0 */               call copy32(msec,t.msec);               if t.msec(0) < 0 then do;                  call ADD16(zero.time, t.msec);                  if t.msec(0) >= 0                  then call STR32(0, 0, t.msec);               end;               else do;                  call SUB16(zero.time, t.msec);                  if t.msec(0) < 0                  then call STR32(0, 0, t.msec);               end;            end;            else call copy32(dur, t.msec);            if amount > 0 then do case field;               call add16(60000,t.msec); /* Add one minute (unsigned) */               call add16(1000,t.msec);  /* Add one second */               call add16(1,t.msec);     /* Add one millisecond */            end;            else do case field;               call sub16(60000,t.msec); /* Subtract one minute (unsigned) */               call sub16(1000,t.msec);  /* Subtract one second            */               call sub16(1,t.msec);     /* Subtract one millisecond       */            end;            if td = cf#time then do;     /* Add in zero.time after   */               if t.msec(0) < 0 then do; /* jog thru 0               */                  call SUB16(zero.time, t.msec);               end;               else do;                  call ADD16(zero.time, t.msec);               end;            end;         end;      end;  /* of do case format */      /* Get real time from sequence time if stored info      */      /* is real time:                                        */      if ((format & 255) = O#MSEC.Beats         )  /* if display is beats */      or ((format & 255) = O#MSEC.Measures.Beats)  /* or measures:beats   */      then do;                                     /* then handle here.   */         if (format & O#MSEC.RealTime) <> 0         then do;            if td = CF#TIME            then call Map.Sequence.Time.To.Real.Time(t.msec, t.msec);            else call Map.Sequence.Duration.To.Real.Duration(seqtime, t.msec, t.msec);         end;      end;      /* Map back to a sequence time if that is the format */      /* of the stored information:                        */      else do;         if (format & O#MSEC.RealTime) = 0     /* if times are seq times, */         then do;                              /* get corresp. real times */            if td = CF#TIME            then call Map.Real.Time.To.Sequence.Time(t.msec, t.msec);            else call Map.Real.Duration.To.Sequence.Duration(msec, t.msec, t.msec);         end;      end;      call FINISH.JOG(ptr,msec,dur,t.msec,amount,td,string);      call Deposit.32Bit.Msec(id,msec,dur);      call Update.32Bit.Msec(ptr);   end;        /* of outside mouse button */end JOG.32BIT.MSEC;