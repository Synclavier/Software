/* SMG-STR   $TITLE  Transparent mode string routines   Modified:   12/05/87 - cj  - removed never-executed key activate from token.change   11/24/87 - MWH - Add editing of existing strings to token routine   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   10/20/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/01/87 - MWH - Make unreferenced procedures NON-public   09/25/87 - MWH - Use literals for suffix lengths   */DEFINE.STRING: proc(id,row,col,chars,type) public swapable;   dcl id        fixed; /* user label for this string object (non-zero) */   dcl (row,col) fixed; /* transparent mode (x,y) coords for string */   dcl chars     fixed; /* max length of string in characters */   dcl type      fixed; /* type code of string */   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   if Allocate.New.Object(O#Hlen+O#STR.Size+shl(shr(chars+1,1)+1,1)) then do; /* get storage for object */      call Write.Object(Object.Ptr + O#Type,  O$String);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#Id,    id);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(col*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(row*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(col*100)+gpix.x(chars*100));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(row*100));      call Write.Object(Object.Ptr + O#Action,Default.Action);      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,Get#In.Char);      call Write.Object(Object.Ptr + O#Trans.Row,Row);  /* Trans Row */      call Write.Object(Object.Ptr + O#Trans.Col,Col);      call Write.Object(Object.Ptr + O#Trans.Width,Chars);      call Write.Object(Object.Ptr + O#STR.Type,Type);      call Write.Object(Object.Ptr + O#STR.Max.Chars,Chars);      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.STRING;dcl O#STR.Disp.String  lit '(O#STR.String+max.words)'; /* ptr offset to displayed string */UPDATE.STRING: proc (ptr) public swapable; /* redraws value in field of object if different from displayed value */   dcl ptr           fixed; /* ptr to object to update */   dcl status        fixed;   dcl (i,j,k)       fixed;   dcl max.words     fixed;   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   i = Read.Object(ptr+O#STR.Max.Chars);    /* Get max byte count from object */   j = Read.Object(ptr+O#STR.String);       /* Character length of string */   max.words = shr(i+1,1)+1;                /* Get max word length of string field */   k = Read.Object(ptr+O#STR.Disp.String);  /* Character length of displayed string */   if (status and O#STAT.Update) <> 0 then do;      if (shr(status&O#STAT.Disp.Attr.Set,1)<>(Status&O#STAT.Attr.Set)) then         k = Read.Object(ptr+O#Trans.Width);      call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col)); /* Position at string field */      call Set.Term.Obj.Attr(ptr);           /* put terminal into desired mode */      call Print.EMString(ptr+O#STR.String); /* print new transparent mode string */      do i = j+1 to k;         call pc(a.space);      end;      call Copy.EMString(ptr+O#STR.String,ptr+O#STR.Disp.String); /* update displayed version of string */      if Disable.Attr.Reset=0 then call Set.Term.Attr(ATTR#Normal); /* restore terminal to normal mode */      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */   end;end UPDATE.STRING;DEPOSIT.STRING: proc (id,string) public recursive; /* store new value into string type object */   dcl id        fixed;   dcl string    array; /* String to deposit */   dcl string0   fixed;   dcl (ptr,i)   fixed;   dcl max.words fixed;   if Locate.Object(id)<>0 then do;         /* Object exists  */      ptr = Object.Ptr;      string0=string(0);                    /* save original string len */      i = Read.Object(ptr+O#STR.Max.Chars); /* Get max byte count from object */      if string0 igt i then string(0)=i;    /* limit string length to allocated len */      max.words = shr(i+1,1)+1;             /* Get max word length of string field */      if (XMem.Str.Equals.IMem.Str(Ptr+O#STR.String,string)=0) /* strings are different */      or ((Read.Object(ptr + O#Status) & O#STAT.Exhibit)   =0) /* object is not displayed yet */      then do;         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         call Copy.String.To.Exmem(string,ptr+O#STR.String);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.String(ptr);      /* Do update right now */      end;      string(0)=string0;                    /* restore string to original len */   end;end DEPOSIT.STRING;GET.STRING: proc (ptr) returns (fixed) public swapable; /* tries to get a string */   dcl ptr         fixed; /* ptr to string object to get */   dcl evt         fixed;   dcl string (40) fixed;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   call Fetch.EMString(ptr+O#STR.String,string);   evt = Get.Simple.Token(ptr,string);   return evt;         end GET.STRING;FETCH.STRING: proc(id,out.string) public swapable; /* returns current value in specified string object */   dcl id         fixed; /* object to fetch string from */   dcl out.string array; /* output array */   dcl i          fixed;   if Locate.Object(id) then do; /* object exists */      do i = 0 to shr(Read.Object(Object.Ptr+O#STR.String)+1,1); /* copy words */         out.string(i) = Read.Object(Object.Ptr+O#STR.String+i);      end;   end;   else out.string(0) = 0; /* error - return null string */end FETCH.STRING;