/* SMG-GSTR $TITLE  Screen Manager Graphics String Routines   Modified:   10/24/88 - cj  - fixed bug with oversize strings in deposit                    graphics string   12/03/87 - MWH - Return delete attempt event when appropriate   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   11/11/87 - CJ  - Added 4 character sizes   10/28/87 - MWH - Echo chars typed properly on Pericom terminal   10/20/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/20/87 - MWH - Keep screen updated while waiting for events   10/01/87 - MWH - Make unreferenced procedures NON-public   09/30/87 - MWH - Fix bugs (graphics strings had never worked!)   09/25/87 - MWH - Use literals for suffix lengths   *//* note: with graphics character strings,  all terminal i/o is done *//* in complement mode.   the 'displayed' value in external memory   *//* must match the screen at all times                               */DEFINE.GRAPHICS.STRING:  proc (id,x,y,chars,set,mag,type) public swapable;   dcl id         fixed;  /* Id of string to define */   dcl (x,y)      fixed;  /* anchor corner of string */   dcl chars      fixed;  /* Max # char allowed in string */   dcl set        fixed;  /* Character set of string */   dcl mag        fixed;  /* Magnification of string */   dcl type       fixed;  /* String type */   dcl string.mem fixed;  /* memory words needed for string */   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   string.mem = shl(shr(chars+1,1)+1,1);   if Allocate.New.Object(O#Hlen+O#GSTR.Size+string.mem-1) then do;      call Write.Object(Object.Ptr+O#Type,  O$Graphics.String);      call Write.Object(Object.Ptr+O#Status,O#STAT.Update);      call Write.Object(Object.Ptr+O#ULX,   limit.x(x));      call Write.Object(Object.Ptr+O#ULY,   limit.y(y+Ver.Char.Size(set)));      call Write.Object(Object.Ptr+O#LRX,   limit.x(x+(chars*Hor.Char.Field(set))));      call Write.Object(Object.Ptr+O#LRY,   limit.y(y-Ver.Char.Desc(set)));      call Write.Object(Object.Ptr+O#Id,    id);      call Write.Object(Object.Ptr+O#Action,Default.Action);      call Write.Object(Object.Ptr+O#ObjectGets,Get#In.Char);           /* char.x, char.y hold a relative offset from the lower left corner */      /* of the region to the lower left corner of where to position      */      /* the cursor to print the string                                   */      call Write.Object(Object.Ptr+O#GSTR.Char.X, 0                 );      call Write.Object(Object.Ptr+O#GSTR.Char.Y, Ver.Char.Desc(set));      call Write.Object(Object.Ptr+O#GSTR.Type,      type);      call Write.Object(Object.Ptr+O#GSTR.Char.Set,  set);      call Write.Object(Object.Ptr+O#GSTR.Char.Mag,  mag);      call Write.Object(Object.Ptr+O#GSTR.Max.Chars, chars);      call Write.Object(Object.Ptr+O#GSTR.String.Words, shr(string.mem,1));      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.GRAPHICS.STRING;DRAW.GRAPHICS.STRING: proc (ptr,stringid) swapable;   dcl ptr             fixed;  /* Pointer to graphics object */   dcl stringid        fixed;  /* 0 = draw current string; 1 = displayed string */   dcl disp_str_offset fixed;  /* Size of current string (offset to displayed string) */   dcl (x,y)           fixed;   dcl (set)           fixed;   if gtype=0 then return;   call Push.Graphics.Attributes;   x   = Read.Object(ptr+O#GSTR.Char.X)+Read.Object(ptr+O#ULX); /* Compute x coord of string */   y   = Read.Object(ptr+O#GSTR.Char.Y)+Read.Object(ptr+O#LRY); /* Compute y coord           */   set = Read.Object(ptr+O#GSTR.Char.Set);                      /* and char set              */   vector_mode;                       /* set term to draw graphics */   call move_to(x,y);                 /* Position at field */   call data_level(2);                /* complement        */   alpha_mode;                        /* set term to print graphics chars */   call pc(ESC);                      /* set char set      */   call pc(scolon-set);               /* 0 = smallest      */   if stringid = 0                    /* draw string */   then call Print.EMString(ptr+O#GSTR.String);   /* Current string */   else do;                                       /* Displayed string */      disp_str_offset = Read.Object(ptr+O#GSTR.String.Words);      call Print.EMString(ptr+O#GSTR.String+disp_str_offset);   end;   call Pop.Graphics.Attributes;end DRAW.GRAPHICS.STRING;UPDATE.GRAPHICS.STRING: proc (ptr) public swapable; /* redraws value in field of object if different from displayed value */   dcl ptr             fixed; /* ptr to object to update */   dcl status          fixed;   dcl disp_str_offset fixed;  /* Size of current string (offset to displayed string) */   status = Read.Object(ptr+O#Status       );   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (status and O#STAT.Update) <> 0 then do;      if gtype<>0 then do;         vector_mode;                          /* so we don't switch back into transparent inbetween erase and draw */         call Draw.Graphics.String(ptr,1);     /* erase previous value */         call Draw.Graphics.String(ptr,0);     /* draw current value */         transparent_mode;      end;      disp_str_offset = Read.Object(ptr+O#GSTR.String.Words);      call Copy.EMString(ptr+O#GSTR.String,ptr+O#GSTR.String+disp_str_offset);      /* leave disp.attr.set free for boxing */      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update))                        \(O#STAT.Exhibit)); /* object now displayed and refreshed */   end;end UPDATE.GRAPHICS.STRING;ERASE.GRAPHICS.STRING: proc (id) swapable;   dcl id  fixed;   dcl disp_str_offset fixed;  /* Size of current string (offset to displayed string) */   if Locate.Object(id) then do;      disp_str_offset = Read.Object(Object.Ptr+O#GSTR.String.Words);      call Draw.Graphics.String(Object.Ptr,1);          /* Erase displayed value */      call Write.Object(Object.Ptr+O#GSTR.String+disp_str_offset,0);  /* displayed string is now null */   end;end ERASE.GRAPHICS.STRING;DEPOSIT.GRAPHICS.STRING: proc (id,string) public swapable;   dcl id      fixed;   dcl string  fixed array;  /* String to deposit */   dcl ptr     fixed;        /* Ptr to graphics string object */   dcl status  fixed;   dcl (i)     fixed;   dcl (j)     fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      status = Read.Object(ptr + O#Status);      i = Read.Object(ptr+O#GSTR.Max.Chars);   /* Get max byte count from object */      j = string(0);                           /* save original string length    */      if string(0) igt i then string(0) = i;   /* Limit length to max len        */      if ((status & O#STAT.Exhibit) = 0)       /* Object never displayed... */      or (XMEM.STR.EQUALS.IMEM.STR (ptr+O#GSTR.String,string)=false) /* or different */      then do;         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         do i = 0 to shr(i+1,1);               /* Copy length-limited string into object */            call Write.Object(ptr+O#GSTR.String+i,string(i));         end;         if Check.Update.On.Deposit(ptr) <> 0         then call Update.Graphics.String(ptr);     /* Do update right now */      end;      string(0) = j;                            /* restore original string length */   end;end DEPOSIT.GRAPHICS.STRING;GET.GRAPHICS.STRING: proc (ptr) returns (fixed) public swapable;   dcl ptr             fixed;   dcl event           fixed;   dcl ch              fixed;   dcl id              fixed;   dcl disp_str_offset fixed;  /* Size of current string (offset to displayed string) */   dcl (i,x,x1,y)      fixed;   dcl (set)           fixed;   if gtype=0 then return;   x   = Read.Object(ptr+O#GSTR.Char.X)+Read.Object(ptr+O#ULX); /* Compute x coord of string */   y   = Read.Object(ptr+O#GSTR.Char.Y)+Read.Object(ptr+O#LRY); /* Compute y coord */   set = Read.Object(ptr+O#GSTR.Char.Set);       /* and char set    */   id  = Read.Object(ptr+O#ID);   /* force update of object here so we don't do it from */   /* a call to update screen while we are inputting     */   /* the character string                               */   if (Read.Object(ptr + O#Status) and O#STAT.Update) <> 0 then do;      call UPDATE.GRAPHICS.STRING(ptr);   end;   x1 = x + Hor.Char.Field(set)*token(0);   call cpos(tpos.y(y),tpos.x(x1));         /* Transparent mode cursor */   disp_str_offset = Read.Object(ptr+O#GSTR.String.Words);   call Push.Graphics.Attributes;      vector_mode;                /* Position cursor at field location */   call move_to(x1,y);   call data_level(2);   alpha_mode;   call pc(ESC);               /* select character set      */   call pc(scolon-set);        /* 0 = smallest              */   do while 1;      call Enable.Object.and.User.Gets(ptr);      if Screen.Changed <> false            /* See if some objects need updating */      then do;                              /* Will return right away if events pending */         transparent_mode;         call Update.Screen;         x1 = x + Hor.Char.Field(set)*token(0);         vector_mode;                /* Position cursor at field location */         call move_to(x1,y);         call data_level(2);         alpha_mode;         call pc(ESC);               /* select character set      */         call pc(scolon-set);        /* 0 = smallest              */      end;      event = Get.Next.Event;          /* Get a char or system event */      call Disable.Object.and.User.Gets(ptr);      if event = get.in.char then do;  /* See if get returned ascii char */         ch = next.event.info;         if ch = a.cr then do;         /* Get returned CR; means deposit field */            /* Deposit value; deposit refreshes if action bits are set; generate screen event stack */            call Deposit.Graphics.String(id,token);            token(0) = 0;              /* Clear user entry buffer */            New.Screen.Event = S#ObjectTerminate; /* we will get a screen event momentarily */         end;         else if (ch = c.x) then do; /* Get returned CTRL-X; means erase field */            if token(0) <> 0 then do;             /* if anything to erase    */               call Draw.Graphics.String(ptr,1);  /* Erase displayed value (better = token) */               call Copy.EMString(ptr+O#GSTR.String,ptr+O#GSTR.String+disp_str_offset);               call Draw.Graphics.String(ptr,1);  /* restore original string */               token(0) = 0;                      /* Set token length to zero */            end;         end;         else if ch = a.del                    /* Back up a character */         then do;            if token(0) > 0 then do;           /* Char there to delete?    */               token(0) = token(0) - 1;        /* One less character       */               if byte(token,token(0)) <> SP   /* skip over space due to   */               then do;                        /* pericom bug. just repos  */                  call pc(a.bs);               /* cursor below             */                  call pc(byte(token,token(0)));  /* Erase previous char      */                  call pc(a.bs);                  /* Move cursor back         */               end;               do i = 0 to shr(token(0)+1,1);  /* set displayed string     */                  call Write.Object(ptr+O#GSTR.String+disp_str_offset+i,token(i));               end;               if token(0) = 0 then do;        /* restore original         */                  call Copy.EMString(ptr+O#GSTR.String,ptr+O#GSTR.String+disp_str_offset);                  call Draw.Graphics.String(ptr,1);  /* restore original string */               end;            end;            else do;               call Write.Event.Queue(Get.Screen.Event,S#DelAttempt,id);               New.Screen.Event = S#ObjectTerminate;            end;         end;         else if (ch >= a.space) &  (ch <= a.tilde)  /* Get returned character; add it to token */         then do;            if token(0) < Read.Object(ptr+O#GSTR.Max.Chars) then do; /* Room for char? */               if token(0) = 0 then do;       /* First one */                  call Draw.Graphics.String(ptr,1);  /* Erase previous value */                  call Write.Object(ptr+O#GSTR.String+disp_str_offset,0);  /* displayed string is now null */               end;               call pbyte(token,token(0),ch);       /* Place new char in token */               token(0) = token(0) + 1;             /* Increment length */               // breaks mac; if ch <> SP then call pc(ch);        /* Print it; avoid pericom bs/sp bug */               call pc(ch);               do i = 0 to shr(token(0)+1,1);       /* set displayed string */                  call Write.Object(ptr+O#GSTR.String+disp_str_offset+i,token(i));               end;            end;         end;         /* Keep both cursors in the right place */         x1 = x + Hor.Char.Field(set)*token(0);         transparent_mode;         call cpos(tpos.y(y),tpos.x(x1));         /* Transparent mode cursor */         vector_mode;                             /* Must go to alpha via vector */         call move_to(x1,y);         alpha_mode;                              /* Back to characters */      end;                        /* of get returned ascii char */      else do;                    /* Get returned non-char event; deposit token value and return */         call Pop.Graphics.Attributes;         return event;                                   end;   end;        /* of do while 1 */end GET.GRAPHICS.STRING;FETCH.GRAPHICS.STRING: proc (id,out.string) public swapable;   dcl id         fixed;   dcl out.string array;   dcl i          fixed;   if Locate.Object(id) then do;      do i = 0 to shr(Read.Object(Object.Ptr+O#GSTR.String)+1,1);         out.string(i) = Read.Object(Object.Ptr+O#GSTR.String+i);      end;   end;   else out.string(0) = 0;end FETCH.GRAPHICS.STRING;