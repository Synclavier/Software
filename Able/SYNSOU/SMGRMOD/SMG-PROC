/* SMG-PROC  $TITLE  Screen Manager Event Processing Routines   Modified:   02/13/90 - MWH - Fix bug: drag.object didn't return a value   06/21/88 - cj  - fixed bugs with jogging of tables (JOG.TABLE)   11/30/87 - MWH - Add jogging of 32-Bit SMPTE objects by field   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   11/10/87 - MWH - Make jogging work in tables   11/09/87 - MWH - Merge in Cameron's fixes (from his SMG-SMAN)   10/27/87 - MWH - Fix table wrapping on --> and <--   10/26/87 - MWH - Allow object jogging when screen animation is on   10/20/87 - MWH - Keep screen updated while waiting for events   10/15/87 - MWH - Create this file from some of SMG-SMAN   07/30/87 - CLS - Process arrow key does automatic search for object to select   *//* Procedure (based on GET.TABLE) to job values in tables: */JOG.TABLE: Proc (ptr,mx,my) returns (fixed) swapable;   dcl ptr         fixed;  /* ptr to table itself              */   dcl mx          fixed;  /* mouse x                          */   dcl my          fixed;  /* mouse y                          */   dcl id          fixed;   dcl tptr        fixed;   dcl cell.mem    fixed;   dcl cell.ptr    fixed;   dcl typ         fixed;   dcl row         fixed;   dcl col         fixed;   dcl width       fixed;   dcl i           fixed;   dcl tid         fixed;   tid=Read.Object(ptr+O#TABL.Cell.Type.Id);       /* save type id in temp  */   if Locate.Object(tid) then do;                  /* find Cell type object */      tptr = Object.Ptr;                           /* save Ptr to type object */      typ  = Read.Object(tptr+O#Type);             /* Type of table object */      id       = Read.Object(ptr+O#Id);            /* Id of table */      col      = Read.Object(ptr+O#TABL.Cur.Col);  /* Current col of table */      row      = Read.Object(ptr+O#TABL.Cur.Row);  /* Current row of table */      cell.mem = Read.Object(ptr+O#TABL.Cell.Mem); /* Memory for each cell in words */      cell.ptr = Compute.Cell.Ptr(ptr,col,row);    /* Get pointer to cell */      call Write.Object(tptr+O#Status,Read.Object(cell.ptr));  /* Write status */      if typ > 0 then do;                     /* Transparent mode cell */         width = Read.Object(tptr+O#Trans.Width); /* Width of cells in characters */         call Write.Object(tptr+O#Trans.Row,Row+Read.Object(ptr+O#Trans.Row));         call Write.Object(tptr+O#Trans.Col,Col*Width+Read.Object(ptr+O#Trans.Col));         call Copy.Exmem(cell.ptr+O#TABL.Cell.Data,tptr+O#Suffix+3,cell.mem-O#TABL.Cell.Data);      end;      else do;  /* Graphics cell */         call Copy.Exmem(cell.ptr+O#TABL.Cell.Data,tptr+O#Suffix,cell.mem-O#TABL.Cell.Data);      end;      /* Do the get by calling a standard routine */      if      typ = O$Fixed.Point     then call Jog.Fixed.Point    (tptr,mx,my);      else if typ = O$32Bit.Msec      then call Jog.32Bit.Msec     (tptr,mx,my);      else if typ = O$Sound.File.Time then call Jog.Sound.File.Time(tptr,mx,my);      else if typ = O$32Bit.SMPTE     then call Jog.32Bit.SMPTE    (tptr,mx,my);      else call Write.Event.Queue(Get.Screen.Event,S#JogAttempt,Read.Object(ptr+O#ID));      call Write.Object(cell.ptr,Read.Object(tptr+O#Status));      if typ > 0      /* Copy object suffix from type object back to table cell */      then call Copy.Exmem(tptr+O#Suffix+3,cell.ptr+O#TABL.Cell.Data,cell.mem-O#TABL.Cell.Data);      else call Copy.Exmem(tptr+O#Suffix  ,cell.ptr+O#TABL.Cell.Data,cell.mem-O#TABL.Cell.Data);      write(md)=Read.Object(tptr+O#Status)&(Not O#STAT.Enable); /* Disable Type Object */      write(md)=Read.Object( ptr+O#Status)\O#STAT.Update;       /* set flag to refresh table */      Screen.Changed = true;      i = out.event;      write(mam) = Queue.Base;      do while i <> in.event;      /* loop over all events in queue */         write(mal) = shl(i,3)+2;  /* point to next event id */         if read(md)=tid then do;  /* this event is our id   */            write(mdi) = id;       /* change to table event  */            write(mdi) = col;            write(mdi) = row;         end;         i = (i + 1) & (queue.events-1); /* step to next event */      end;   end;end JOG.TABLE;JOG.OBJECT: proc(ptr) swapable;   dcl ptr       fixed;   dcl type      fixed;   dcl (mx,my)   fixed;   if Any.RealTime.Objects <> 0 then call Run.Syn.Loop;   token(0) = 0;   type = Read.Object(ptr + O#Type);   if Last.Event.Info < 0 then do;  /* Find where the mouse did the jog */      mx = Mouse(press.x);      my = Mouse(press.y);   end;   else do;      mx = Mouse(release.x);      my = Mouse(release.y);   end;   if      type = O$Fixed.Point     then call Jog.Fixed.Point(ptr,mx,my);   else if type = O$32Bit.Msec      then call Jog.32Bit.Msec(ptr,mx,my);   else if type = O$Sound.File.Time then call Jog.Sound.File.Time(ptr,mx,my);   else if type = O$32Bit.SMPTE     then call Jog.32Bit.SMPTE(ptr,mx,my);   else if type = O$Table           then call Jog.Table(ptr,mx,my);   else call Write.Event.Queue(Get.Screen.Event,S#JogAttempt,Read.Object(ptr+O#ID));end JOG.OBJECT;DRAG.OBJECT: proc (drag.id,button) returns (fixed) swapable;   dcl drag.id       fixed;   dcl drag.type     fixed;   dcl button        fixed;   dcl (col,row)     fixed;   /*** declare in order ***/   dcl (ncol,nrow)   fixed;   dcl drop.id       fixed;   dcl drop.ptr      fixed;   dcl drop.type     fixed;   dcl action        fixed;   dcl (ulx,uly)     fixed static;   /* Used for plotting the box */   dcl (lrx,lry)     fixed static;   dcl (dbw,dbh)     fixed;   /* drag box width and height */   dcl (cx,cy)       fixed;   /* center of box relative to box upper left corner */   dcl ptr           fixed;   dcl (mx,my)       fixed static;   /* current mouse position as sampled */   dcl event         fixed;   dcl dragging      fixed static;   dcl tmp.id        fixed;   if Locate.Object(drag.id) then do;      ptr = Object.Ptr;      button = abs(button);  /* Look for releases only */      action = Read.Object(ptr+O#Action);      drag.type= Read.Object(ptr+O#Type);      if drag.type = O$Table then do;    /* Compute the cell size based on type */         if Locate.Object(Read.Object(ptr+O#TABL.Cell.Type.Id)) = 0 then do;            call Write.Event.Queue(Get.Screen.Event,S#ObjectDragAbort,drag.id);            Last.Event.Code = Get.Screen.Event;   /* Unsuccessful drag */            Last.Event.Info = S#ObjectTerminate;            return Last.Event.Code;         end;         ptr = Object.Ptr;         call Fetch.Table.Cur.Cell(drag.id,loc(addr(col)));  /* table current col */      end;      else do;         col = 0;   /* No rows/cols for non table types */         row = 0;      end;      dbw  = Read.Object(ptr+O#LRX)-Read.Object(ptr+O#ULX);      dbh  = Read.Object(ptr+O#ULY)-Read.Object(ptr+O#LRY);      cx   = shr(dbw,1); /* centers of box */      cy   = shr(dbh,1);      /* Check here to see if the user has already released the */      /* button in question.  This would have happened if the   */      /* user is quickly double-clicking on an object.  If      */      /* the user has already moved on, just return a drag      */      /* abort without going through the time consuming item    */      /* of drawing the diamond, etc.  In particular, do not    */      /* change the MOUSE.X, MOUSE.Y, since the mouse is no     */      /* longer in this galaxy                                  */          if Dragging = 0                  /* only check if not already  */      then do;                         /* dragging                   */             call Check.Next.Event;            /* check button result    */         if  (New.Mouse.Button = Button)   /* if desired button has  */         then do;                          /* been release, return.  */            New.Mouse.Button = 0;          /* toss event             */            call Write.Event.Queue(Get.Screen.Event,S#ObjectDragAbort,drag.id);            Last.Event.Code = Get.Screen.Event;   /* Unsuccessful drag */            Last.Event.Info = S#ObjectTerminate;            return Last.Event.Code;         end;          end;      call mouse.switch(0);      if gtype<>0 then do;         vector_mode;         call data_level(2);  /* complement */      end;      if not dragging then do;         mx   = Read.Object(ptr+O#ULX)+(col*dbw)+cx;         my   = Read.Object(ptr+O#ULY)-(row*dbh)-cy;						if (MOUSE.PORT.IS.D50 == 0)			{				disable;				mouse.x = mx;				mouse.y = my;				enable;			}			         ulx = mx-cx;         uly = my+cy;         lrx = ulx + dbw;         lry = uly - dbh;         if ulx < 0 then ulx = 0;         if uly > screen.height then uly = screen.height;         if lrx > screen.width  then lrx = screen.width;         if lry < 0 then lry = 0;         if gtype<>0 then call gdiam(mx,my);         dragging = true;      end;      do while 1;         call Get_Enable(Get.Mouse.Button);         call Get_Enable(Get.Mouse.Movement);         if Screen.Changed <> false            /* See if some objects need updating */         then call Update.Screen;              /* Will return right away if events pending */         event = Get.Next.Event;         call Get_Disable(Get.Mouse.Button);         call Get_Disable(Get.Mouse.Movement);         if (event = Get.Mouse.Button)         &  (Last.Event.Info = button)         then do;            if gtype<>0 then do;               call gdiam(mx,my);   /* erase the drag box */               mx = mouse(release.x);               my = mouse(release.y);               call data_level(0);               call line_type(0);               call mouse.switch(1);               transparent_mode;            end;            dragging = false;    /* Turn off state flag */            if POINT.IN.OBJECT(drag.id,mx,my)          /* make quick check for drag to same object */            then drop.id = drag.id;                    /* to make for speedy sound file recalls */            else drop.id = Map.Point.To.Object(mx,my);            if Drop.Id <> 0 then do;               if Locate.Object(Drop.Id)               then drop.ptr  = Object.Ptr;               else drop.id   = 0;            end;            if (drop.id > 0)            /* Valid drop object */            then do;               drop.type = Read.Object(drop.ptr+O#Type);               if drop.type = O$Table then do;                  call Map.Point.To.Table.Cell(mx,my,drop.id,loc(addr(ncol)));                  if Locate.Object(Read.Object(drop.ptr+O#TABL.Cell.Type.Id))                  then drop.type = Read.Object(Object.Ptr+O#Type);               end;               else do;       /* not a table; zero ncol,nrow for check below */                  ncol = 0;                  nrow = 0;               end;               if (drop.id <> drag.id)   /* if object has changed */               or (ncol    <> col)       /* or table column changed */               or (nrow    <> row)       /* or table row has changed */               then do;                  if (action&O#ACT.Drag.Type.Check)=0 then do;                     if drag.type = O$Table then do;                        if Locate.Object(Fetch.Object.Info(drag.id,O#TABL.Cell.Type.Id))                        then drag.type = Read.Object(Object.Ptr+O#Type);                     end;                  end;                  else drag.type = drop.type;  /* overrides type check */                  if drag.type = drop.type then do;   /* Successful drag */                     Screen.Event.Obj.Info = drop.id;                     Screen.Event.Obj.Col  = ncol;     /* save these for user; destination coordinates */                     Screen.Event.Obj.Row  = nrow;                     Last.Event.Code = Get.Screen.Event;                     Last.Event.Info = S#ObjectDrag;                     return Last.Event.Code;                  end;               end;               end;            call Write.Event.Queue(Get.Screen.Event,S#ObjectDragAbort,drag.id);            Last.Event.Code = Get.Screen.Event;   /* Unsuccessful drag */            Last.Event.Info = S#ObjectTerminate;            return Last.Event.Code;         end;         else if event = Get.Mouse.Movement then do;            if gtype<>0 then call gdiam(mx,my); /* erase previous box */            mx = mouse(current.x);            my = mouse(current.y);            ulx = mx-cx;            uly = my+cy;            lrx = ulx + dbw;            lry = uly - dbh;            if ulx < 0 then ulx = 0;            if uly > screen.height then uly = screen.height;            if lrx > screen.width then lrx = screen.width;            if lry < 0 then lry = 0;            if gtype<>0 then call gdiam(mx,my); /* plot new box */         end;         else do;            if gtype<>0 then do;               call data_level(0);               call line_type(0);               transparent_mode;            end;            return event;         end;      end;   end;    /* of found object */   /* If here, we never found the object */   Last.Event.Code = Get.Screen.Event;   /* Unsuccessful drag */   Last.Event.Info = S#ObjectTerminate;   return(Get.Screen.Event);end DRAG.OBJECT;ANIMATE.SCREEN: proc(button) swapable;    dcl old.id       fixed;  /* Object currently selecteed */   dcl new.id       fixed;   dcl button       fixed;  /* button release to look for */   dcl code         fixed;   dcl outside      fixed;   dcl (mx,my)      fixed;   dcl (ncol,nrow)  fixed;  /*** Declare in order ***/   dcl (ocol,orow)  fixed;  /*** Declare in order ***/   dcl exit.animate fixed;   dcl old.type     fixed;   dcl new.type     fixed;   button  = abs(button);      /* Translate to unsigned for processing */   mx      = mouse(press.x);   my      = mouse(press.y);   old.id      = Cur.Obj.Id;   /* Get id of selected current object */   old.type    = Fetch.Object.Info(Cur.Obj.Id,O#Type); /* Get its type */   if old.type = O$Table   then call Fetch.Table.Cur.Cell(old.id,loc(addr(ocol)));   new.id  = Map.Point.To.Object(mx,my);    /* Get id of object over which button was pressed */   if (new.id > 0)                                /* If its over an object */   &  ((Fetch.Object.Info(new.id,O#Status)&O#STAT.Enable)<>0)   /* object is enabled */   &  ((Fetch.Object.Info(new.id,O#Action)&Bits(button+7))<>0)  /* and button enabled? */   &  ((Fetch.Object.Info(new.id,O#Action)&O#ACT.Animate.Disabled)=0) /* Animate is enabled */   then do;      new.type = Fetch.Object.Info(new.id,O#Type); /* Get the type of the new object */      if new.type = O$Table      then call Map.Point.To.Table.Cell(mx,my,new.id,loc(addr(ncol)));  /* Get cell location of the press */      call mouse.switch(0);                       /* turns off mouse */   end;   else do;      outside = true;                             /* causes Cur.Obj to be un-highlighed */      new.id = 0;                                 /* no object to highlight; either we are not on a button or button access denied */   end;   if token(0) > 0 then do;   /* Deposit current object if user had typed anything into it */      call Deposit.Token(old.id,token);      token(0) = 0;   end;   if new.type < 0 then new.id = 0;  /* No graphics objects yet */   do while 1;      /*  Unhighlight the previous object if new object is different */      if (old.id > 0)          /* Valid old object   */      &  ((old.id <> new.id)   /* new is <> old id   */      or  (ocol   <> ncol)     /* cols are different */      or  (orow   <> nrow)     /* rows are different */      or  (outside))           /* we moved outside   */      then do;         if old.type <> O$Table then call Set.Object.Attr.Set(old.id,0);         else                        call Set.Table.Cell.Attr.Set(old.id,ocol,orow,0);         call Update.Object(old.id);         if outside then call mouse.switch(1);      end;      /* Highlight new object if it is different from old */      if (new.id > 0)          /* Valid new object   */      &  ((new.id <> old.id)   /* New id  <> old id  */      or  (ncol   <> ocol)     /* new col <> old col */      or  (nrow   <> orow))    /* new row <> old row */      then do;         if Fetch.Object.Info(new.id,O#Type) <> O$Table         then call Set.Object.Attr.Set(new.id,1);         else call Set.Table.Cell.Attr.Set(new.id,ncol,nrow,1);         call Update.Object(new.id);      end;      old.id   = new.id;      old.type = new.type;      ocol     = ncol;      orow     = nrow;      if exit.animate then do;         call mouse.switch(1);         if not outside then do;            if Select.New.Cur.Obj(new.id,ncol,nrow)            then call Write.Event.Queue(Get.Screen.Event,S#MouseSelect,New.Id);            else call Write.Event.Queue(Get.Screen.Event,S#MouseActivate,New.Id);         end;         return;      end;      call GET_ENABLE(get.mouse.button);      call GET_ENABLE(get.mouse.movement);      if Screen.Changed <> false            /* See if some objects need updating */      then call Update.Screen;              /* Will return right away if events pending */      if (screen.x <> 79)      or (screen.y <> 23)      then call cpos(23,0);   /* Move cursor to lower corner after update */      code=get.next.event;    /* Get what's happening to the system */      call GET_DISABLE(get.mouse.button);      call GET_DISABLE(get.mouse.movement);      if  (code=get.mouse.button)      and (last.event.info=button)      then do;                      /* release of desired button */         mx = mouse(release.x);         my = mouse(release.y);         new.id = Map.Point.To.Object(mx,my);         if (new.id > 0)         &  ((Fetch.Object.Info(new.id,O#Action)&Bits(button+7))<>0)  /* button enabled? */         &  ((Fetch.Object.Info(new.id,O#Status)&O#STAT.Enable)<>0)   /* enabled */         then do;            new.type = Fetch.Object.Info(new.id,O#Type);            if new.type = O$Table            then call Map.Point.To.Table.Cell(mx,my,new.id,loc(addr(ncol)));            outside = false;         end;         else do;  /* Release not on an object or not allowed button release */            if new.id = 0 then outside = true;  /* causes old id to erase if we let go off of object otherwise leave current object highlighted */            new.id      = Cur.Obj.Id;                /* Get Cur.Obj.Id and re-highlight it */            new.type    = Fetch.Object.Info(Cur.Obj.Id,O#Type);            if new.type = O$Table            then call Fetch.Table.Cur.Cell(new.id,loc(addr(ncol)));         end;         exit.animate = true;      end;      else if (code=get.mouse.movement)      then do;         mx = mouse(current.x);         my = mouse(current.y);         new.id = Map.Point.To.Object(mx,my);         if new.id = 0 then do;    /* New position is off of any object */            outside = true;         end;         else do;   /* we are on an object */            new.type = Fetch.Object.Info(new.id,O#Type);            if new.type = O$Table            then call Map.Point.To.Table.Cell(mx,my,new.id,loc(addr(ncol)));            if (new.id <> old.id)      /* Change in objects */            &  ((Fetch.Object.Info(new.id,O#Action)&Bits(button+7))<>0)  /* button enabled? */            &  ((Fetch.Object.Info(new.id,O#Status)&O#STAT.Enable)<>0)   /* enabled */            &  ((Fetch.Object.Info(new.id,O#Action)&O#ACT.Animate.Disabled)=0) /* Animate is enabled */            then do;               outside = false;                 if new.type > 0 then call mouse.switch(0);               else                 call mouse.switch(1);            end;            else new.id = old.id;      /* causes nothing to change */         end;      end;   end;end ANIMATE.SCREEN;PROCESS.SCREEN.EVENT: proc swapable;   dcl action fixed;   if Last.Event.Info <> S#ObjectTerminate    then call Write.Event.Queue(Last.Event.Code,Last.Event.Info,Cur.Obj.Id);   if  (Last.Event.Info =  S#NulEvent)   or  (Last.Event.Info =  S#ObjectTerminate)   or  (Last.Event.Info =  S#Deposit)       /* Object Deposited */   or  (Last.Event.Info =  S#ObjectDrag)    /* for case of return to previous object tables */   or  (Last.Event.Info =  S#ObjectDragAbort)   or ((Last.Event.Info >= S#SBArrow)       /* Some scroll bar event */   &   (Last.Event.Info <  S#SBBoxMove))    /* Do not include box move */   then do;         /* If we are done with object */      if Locate.Object(Cur.Obj.Id) then do;        /* Get ptr to current object */         action = Read.Object(Object.Ptr+O#Action);         If (action&O#ACT.Prev.Obj)=0 /* Look at return action */         then call Select.New.Cur.Obj(Cur.Obj.Id,-1,-1);  /* if 0 then update Prev.Obj and repeat current obj */         else do;            if Select.New.Cur.Obj(Prev.Obj.Id,-1,-1)            then call Write.Event.Queue(Get.Screen.Event,S#ArrowSelect,Cur.Obj.Id);         end;      end;   end;end PROCESS.SCREEN.EVENT;PROCESS.MOUSE.BUTTON: proc swapable;   dcl new.object    fixed;   dcl new.type      fixed;   dcl new.ptr       fixed;   dcl mouse.button  fixed;   dcl action        fixed;   dcl (px,py)       fixed;   dcl (cell.col,cell.row) fixed;  /* Declare in order! */   if Last.Event.Info < 0 then do;  /* Sample mouse position */      px = Mouse(press.x);        py = Mouse(press.y);   end;   else do;      px = Mouse(release.x);      py = Mouse(release.y);   end;   Mouse.Button = Last.Event.Info;   if Point.In.Object(Cur.Obj.Id,px,py)  /* Make quick check for press/release in current object */   then New.Object = Cur.Obj.Id;   else New.Object = Map.Point.To.Object(px,py);   Action = 0;                           /* Assume no type */   if New.Object <> 0 then do;           /* If press/release was on an object */      if Locate.Object(New.Object)       /* Find new object */      then do;         New.Ptr  = Object.Ptr;         New.Type = Read.Object(New.Ptr+O#Type);         Action   = Read.Object(New.Ptr+O#Action);      end;      else New.Object = 0;               /* Could not locate the object */   end;   if (Animate.Screen.Enabled)            /* User wants animation   */   &  (Last.Event.Info < 0)               /* A mouse button press   */   &  ((Action&O#ACT.Animate.Disabled)=0) /* Animate is enabled     */   &  ((Action&O#ACT.Drag.Enabled)=0)     /* Object is not dragable */   then do;      call Animate.Screen(Last.Event.Info);   end;   else do;       /* Unanimated mouse activity */      if (New.Object <> 0)                   /* See if select was on an object */      then do;         if  (((Mouse.Button < 0)           & ((Action&Bits(-Mouse.button+7))<>0))   /* O#ACT.{Left,Middle,Right}.Press */         or  ((Mouse.Button > 0)           & ((Action&Bits(Mouse.button+10))<>0)))  /* O#ACT.{Left,Middle,Right}.Release */         then do;                                   /* Action is press or release of a mouse button */            if New.Type = O$Table            then do;               call Map.Point.To.Table.Cell(px,py,New.Object,loc(addr(cell.col)));            end;            if  Select.New.Cur.Obj(New.Object,cell.col,cell.row) /* returns 1 if object changed from prev obj */            then call Write.Event.Queue(Get.Screen.Event,S#MouseSelect,Cur.Obj.Id);            else call Write.Event.Queue(Get.Screen.Event,S#MouseActivate,Cur.Obj.Id);            Screen.Event.Obj.Info=Mouse.Button; /* save info about press in GLOBAL */            if  ((Action&O#ACT.Drag.Enabled)<>0)            and (Mouse.Button = Mou#Middle.Down)            then do;               Dragging.Object = Cur.Obj.Id;               Dragging.Button = Mouse.Button;            end;            else if  ((Action & O#ACT.Jog.Enabled) <> 0)             and       (Mouse.Button <> Mou#Middle.Down)  /* Not middle down... */            and       (Mouse.Button < 0)                 /* ...but was a mouse button down */            then call Jog.Object(New.Ptr);         end;       /* of press or release of mouse */      end;          /* of select was on an object   */   end;             /* of unanimated mouse activity */end PROCESS.MOUSE.BUTTON;PROCESS.ARROW.KEY: proc swapable;   dcl new.object   fixed;   dcl cur.obj.ptr  fixed;   dcl new.obj.ptr  fixed;   dcl table.exit   fixed;   dcl (cell.col,cell.row) fixed;  /* Declare in order! */   dcl count        fixed;   dcl type         fixed;   if Locate.Object(Cur.Obj.Id) then do;      Cur.Obj.Ptr = Object.Ptr;      type = Read.Object(Cur.Obj.Ptr+O#Type);      if type = O$Table then do;         call Fetch.Table.Cur.Cell(Cur.Obj.Id,loc(addr(cell.col)));         if      Last.Event.Info = U.ARR then cell.row = cell.row - 1;         else if Last.Event.Info = D.ARR then cell.row = cell.row + 1;         else if Last.Event.Info = L.ARR then cell.col = cell.col - 1;         else if Last.Event.Info = R.ARR then cell.col = cell.col + 1;         if (Read.Object(Cur.Obj.Ptr + O#TABL.Bits) & O#TABL.Bits.Wrap) <> 0 then do;            if cell.col < 0 then do;               cell.row = cell.row - 1;               cell.col = Read.Object(Cur.Obj.Ptr+O#TABL.Across) - 1;            end;            else if cell.col >= Read.Object(Cur.Obj.Ptr+O#TABL.Across) then do;               cell.row = cell.row + 1;               cell.col = 0;            end;         end;                  table.exit = false;         if (cell.row < 0)         or (cell.row >= Read.Object(Cur.Obj.Ptr+O#TABL.Down))         or (cell.col < 0)         or (cell.col >= Read.Object(Cur.Obj.Ptr+O#TABL.Across))         then do;            table.exit = true;   /* We have gone beyond limits of table */         end;         else do;            if Select.New.Cur.Obj(Cur.Obj.Id,cell.col,cell.row)            then call Write.Event.Queue(Get.Screen.Event,S#ArrowSelect,Cur.Obj.Id);         end;      end;      if (type <> O$Table)      or (table.exit)      then do;         if Last.Event.Info = U.ARR         then do;            if Read.Object(Cur.Obj.Ptr + O#ObjAbove) = ARR#Auto            then New.Object = Calculate.Closest.Object(Cur.Obj.Id,Cur.Obj.Ptr,0);            else New.Object = Read.Object(Cur.Obj.Ptr + O#ObjAbove);         end;                                    else if Last.Event.Info = D.ARR         then do;            if Read.Object(Cur.Obj.Ptr + O#ObjBelow) = ARR#Auto            then New.Object = Calculate.Closest.Object(Cur.Obj.Id,Cur.Obj.Ptr,1);            else New.Object = Read.Object(Cur.Obj.Ptr + O#ObjBelow);         end;                                    else if Last.Event.Info = L.ARR         then do;            if Read.Object(Cur.Obj.Ptr + O#ObjLeft) = ARR#Auto            then New.Object = Calculate.Closest.Object(Cur.Obj.Id,Cur.Obj.Ptr,2);            else New.Object = Read.Object(Cur.Obj.Ptr + O#ObjLeft);         end;                                    else if Last.Event.Info = R.ARR         then do;            if Read.Object(Cur.Obj.Ptr + O#ObjRight) = ARR#Auto            then New.Object = Calculate.Closest.Object(Cur.Obj.Id,Cur.Obj.Ptr,3);            else New.Object = Read.Object(Cur.Obj.Ptr + O#ObjRight);         end;                                    if New.Object > 0 then do;   /* Not Nul */            if Locate.Object(New.Object) then New.Obj.Ptr = Object.Ptr;            if (Read.Object(New.Obj.Ptr + O#Status)&O#STAT.Enable) <> 0 then do;               if Read.Object(New.Obj.Ptr + O#Type) = O$Table then do;                  if Map.Object.To.Table.Cell(Cur.Obj.Id,New.Object,loc(addr(cell.col)))                  then do;                     if Select.New.Cur.Obj(New.Object,cell.col,cell.row)                     then call Write.Event.Queue(Get.Screen.Event,S#ArrowSelect,Cur.Obj.Id);                  end;               end;               else do;                  if Select.New.Cur.Obj(New.Object,-1,-1)                  then call Write.Event.Queue(Get.Screen.Event,S#ArrowSelect,Cur.Obj.Id);               end;            end;         end;         else do;  /* User hit an arrow and wants to leave object */            Screen.Event.Obj.Info = Last.Event.Info;  /* Save arrow key */            call Write.Event.Queue(Get.Screen.Event,S#ArrowSelectAttempt,Cur.Obj.Id);            Screen.Event.Obj.Info = Last.Event.Info;         end;      end;   end;end PROCESS.ARROW.KEY;