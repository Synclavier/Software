/* SMG-GET   $TITLE  Main event loop   Modified:   11/19/87 - MWH - Fix object dragging   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   09/25/87 - MWH - Use literals for suffix lengths   */ENABLE.USER.AND.GROUP.GETS: proc(id) swapable;   dcl id          fixed;   dcl all.gets    fixed;   dcl i           fixed;   write(mam) = Group.Base;   i=0;    do while (i ILT num.object.groups);      write("324") = read(mdi);       /* Skip over G#ID   */      write("324") = read(mdi);       /* Skip over G#LOW  */      write("324") = read(mdi);       /* Skip over G#HIGH */      all.gets = all.gets\read(mdi);  /* Or in G#BITS     */      i=i+1;   end;   if Locate.Object(id) then do;      all.gets = ((all.gets \ Read.Object(Object.Ptr+O#UserGets))                   & not(Read.Object(Object.Ptr+O#ObjectGets)));   end;   call ENABLE_BIT_GETS(all.gets);end ENABLE.USER.AND.GROUP.GETS;DISABLE.USER.AND.GROUP.GETS: proc(id) swapable;   dcl id          fixed;   dcl all.gets    fixed;   dcl i           fixed;   write(mam) = Group.Base;   i=0;    do while (i ILT num.object.groups);      write("324") = read(mdi);       /* Skip over G#ID   */      write("324") = read(mdi);       /* Skip over G#LOW  */      write("324") = read(mdi);       /* Skip over G#HIGH */      all.gets = all.gets\read(mdi);  /* Or in G#BITS     */      i=i+1;   end;   if Locate.Object(id) then do;      all.gets = ((all.gets\Read.Object(Object.Ptr+O#UserGets))                   & not(Read.Object(Object.Ptr+O#ObjectGets)));   end;   call DISABLE_BIT_GETS(all.gets);end DISABLE.USER.AND.GROUP.GETS;dcl GID proc (fixed) external;GET.NEXT.SCREEN.EVENT: proc returns (fixed) public swapable;  /* Get the current object or system event and return result */   dcl ret            fixed;   dcl enable.id      fixed;   dcl group.id       fixed;   dcl group.get.bits fixed;   dcl items.enabled  fixed;   dcl i              fixed;   do while 1;      do while Events.Pending <> 0;  /* Any stacked up events ? */         Screen.Event.Group     = 0;  /* assume not connected to group */         Screen.Event.Code      = Read.Event.Queue(S#Queue.Event);          Last.Event.Info        = Read.Event.Queue(S#Queue.Info);         Screen.Event.Info      = Last.Event.Info;         Screen.Event.Id        = Read.Event.Queue(S#Queue.Id);         Screen.Event.Table.Col = Read.Event.Queue(S#Queue.TabCol);         Screen.Event.Table.Row = Read.Event.Queue(S#Queue.TabRow);         /* This block is for debugging only *//* *     BEGIN; *        call Set.Term.Attr(ATTR#Normal); *        call cpos(23,0); call erase.to.end.of.line; *        call ps('Code'); call pnum(Screen.Event.Code,4); *        call ps(' Info'); call pnum(Screen.Event.Info,4); *        call ps(' Id'); call pnum(Screen.Event.Id,4); *        call ps(' Col'); call pnum(Screen.Event.Table.Col,4); *        call ps(' Row'); call pnum(Screen.Event.table.row,4); *     END; */         if Num.Object.Groups<>0 then do; /* we have some object groups */            do while (Group.Ptr ILT (Num.Object.Groups*G#BlkLen))            and ((New.Group.Ptr=0) or (Group.Ptr ILT New.Group.Ptr));               write(mam)=Group.Base+shr(Group.Ptr+G#Bits,8);               write(mal)=Group.Ptr+G#Bits;               if (read(md) & bits(Screen.Event.Code-1)) <> 0               then do;               /* group is interested in this type of event */                  write(mam)=Group.Base+shr(Group.Ptr+G#Id,8);                  write(mal)=Group.Ptr+G#Id;                  group.id=read(mdi);                 /* save id # */                  if Screen.Event.Code=Get.Screen.Event                  then do;                            /* make sure object is in range of our group */                     if  (Screen.Event.Id>=read(mdi)) /* G#LOW  */                     and (Screen.Event.Id<=read(md))  /* G#HIGH */                     then do;                        Screen.Event.Group=group.id;                     end;                  end;                  else Screen.Event.Group=group.id;                  if Screen.Event.Group<>0 then do;                     Group.Ptr=Group.Ptr+G#BlkLen; /* step to next group block */                     return Screen.Event.Code;  /* return code for current event */                  end;               end;               Group.Ptr=Group.Ptr+G#BlkLen; /* step to next group block */            end;            Group.Ptr=0;                     /* reset ptr to start of list */            New.Group.Ptr=0;                 /* now incorporate new groups into list */         end;         call Read.Event.Queue(S#Queue.Advance);  /* Advance to next event */         if Get.Item.Enabled(Screen.Event.Code)<>0 then return Screen.Event.Code;      end;      if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;      call Enable.User.and.Group.Gets(Cur.Obj.Id); /* Enable special user gets and default gets */      Enable.Id = Cur.Obj.Id;      if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;      if Dragging.Object > 0    /* legal id's only */      then do;         ret = Drag.Object(Dragging.Object,Dragging.Button);         if (ret = Get.Screen.Event)          /* If we are done with drag */         &  ((Last.Event.Info = S#ObjectDrag) /* reset drag.enable        */         or  (Last.Event.Info = S#ObjectTerminate))         then Dragging.Object= 0;                        Object.Exit.Code = Last.Event.Code;  /* Save what caused object exit */         Object.Exit.Info = Last.Event.Info;         Object.Exit.Id   = Cur.Obj.Id;      end;      else do;         call Get_Enable(Get.Arrow.Key);              /* For object selection */         call Get_Enable(Get.Mouse.Button);           /* For object selection */         call Get_Enable(Get.Screen.Event);           /* For our own events   */         items.enabled = 1;                           /* indicate we enabled for these items */         if Screen.Changed<>false                     /* something to update */         then call Update.Screen;                     /* Keep screen current */         if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;         ret = Get.Object(Cur.Obj.Id);                /* Get the Current Object */         if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;      end;      if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;      if ret = Get.Screen.Event then do;         call Process.Screen.Event;      end;      else if ret = Get.Mouse.Button then do;         if (Get.Item.Enabled(Get.Mouse.Button)>items.enabled)         then call Write.Event.Queue(Last.Event.Code,Last.Event.Info,Cur.Obj.Id);         call Process.Mouse.Button;      end;      else if ret = Get.Arrow.Key    then do;         if (Get.Item.Enabled(Get.Arrow.Key)>items.enabled)         then call Write.Event.Queue(Last.Event.Code,Last.Event.Info,Cur.Obj.Id);         call Process.Arrow.Key; /* Possible field switch */      end;      else call Write.Event.Queue(Last.Event.Code,Last.Event.Info,Cur.Obj.Id); /* Something other than arrow or mouse--we don't know */      if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;      call Disable.User.and.Group.Gets(Enable.Id);      if items.enabled <>0 then do;         call Get_Disable(Get.Arrow.Key);         call Get_Disable(Get.Mouse.Button);         call Get_Disable(Get.Screen.Event);         items.enabled = 0;      end;   end;end GET.NEXT.SCREEN.EVENT;