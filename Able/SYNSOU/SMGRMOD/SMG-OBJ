/* SMG-OBJ  $TITLE General Object Routines   Modified:   05/02/89 - TSS - Merged version with DUMP.OBJECTS included   06/17/88 - TSS - Fixed bug in commented out DUMP.OBJECTS routine   11/13/87 - MWH - Split into 2 libraries; SMGR is too big   10/20/87 - MWH - Make auto-arrow weighting 5:1, not 10:1; also don't                    find a closest object that is "O#ACT.Prev.Obj"   10/15/87 - MWH - New literals; clean up   09/22/87 - MWH - Add DUMP.OBJECTS procedure for debugging   */ALLOCATE.NEW.OBJECT: proc(Length) returns (fixed) public swapable;   dcl Length        fixed;                  /* words to allocate for new object */   if  (Length<>0)                           /* allocating some space */   and ((Screen.Length + Length) ILE Screen.Max.Length)   then do;                                  /* have enough room left for new object */      Object.Ptr = Screen.Length;            /* our object starts here */      Screen.Length=Screen.Length+Length;    /* advance ptr to next free word */      call Write.Object(Object.Ptr,Length);  /* Set ptr and zero out data record */      do Length = 2 to Length;         write(mdi)=0;      end;      write(mdi) = O#Len.End;                /* Set last element of list to nul */      return true;   end;   else do;      call cpos(23,0);      call pc(7);      call ps('SYSTEM ERROR: OUT OF MEMORY IN SCREEN MANAGER!');      call tty_wait;      return false;                          /* no room in memory for object */   end;end ALLOCATE.NEW.OBJECT;SHUFFLE.OBJECT.MEMORY:proc swapable;         /* garbage collect smgr memory */   dcl (sou,des,len) fixed;   sou=0; des=0;   len = Read.Object(sou);                   /* get length of first object (or -1 if empty list) */   do while len <> (O#Len.End);      if Read.Object(sou+O#TYPE)<>O$Delete then do; /* if object still defined,  preserve it */         call Copy.Ext.Mem(Screen.Base,Sou,Screen.Base,Des,len);         sou=sou+len;         des=des+len;      end;      else do;         sou=sou+len;      end;      len = Read.Object(sou);       /* look up next length (or -1) */   end;   call Write.Object(des,O#Len.End);   /* store -1 at end of list     */   Screen.Length = des;             /* new length                  */   Screen.Shuffled = true;          /* trash LocateObject Cache    */   call Compute.Max.Object.Id;      /* recompute after shuffle     */end Shuffle.Object.Memory;DEALLOCATE.OBJECT: proc(Ptr) swapable;  /* Does not do garbage collect */   dcl Ptr fixed; /* word ptr to object to be deleted */   call Write.Object(ptr+O#Type,O$Delete);   Screen.Shuffled = true;end DEALLOCATE.OBJECT;UNDEFINE.OBJECT.RANGE: proc(LowId,HighId) public swapable;   dcl LowId    fixed;   dcl HighId   fixed;   dcl Cur.Ptr  fixed;   dcl Next.Ptr fixed;   dcl Test.Id  fixed;   Next.Ptr = 0;   Cur.Ptr = 0;   do while Read.Object(Next.Ptr) <> O#Len.End;   /* Traverse entire list */      Cur.Ptr   = Next.Ptr;      Next.Ptr  = Next.Ptr + read(md);      Test.Id   = Read.Object(Cur.Ptr+O#Id);      if (Test.Id >= LowId)                /* If object id is within specified */      &  (Test.id <= HighId)               /* range change its set it up to be deleted */      then call Write.Object(Cur.Ptr+O#Type,O$Delete);   end;   call Shuffle.Object.Memory;end UNDEFINE.OBJECT.RANGE;UNDEFINE.OBJECT: proc (id) public swapable;   dcl id   fixed;   call Undefine.Object.Range(id,id);end UNDEFINE.OBJECT;Display.And.Undefine.Object: proc (id) public swapable;   dcl id fixed;   call Activate.Object.Range(id,id);   call Update.Object        (id);   call Undefine.Object      (id);end Display.And.Undefine.Object;LOCATE.OBJECT: proc(id) public swapable; /* set up ptr to object with our Id # */   dcl id           fixed;   dcl last.id (1)  fixed static;   dcl last.ptr(1)  fixed static;   dcl last.index   fixed static;   dcl Next.Ptr     fixed;   dcl count        fixed;   if (Screen.Shuffled = true)    /* if shuffle happend   */   then do;                       /* then trash the cache */      last.id(0) = 0;      last.id(1) = 0;      Screen.Shuffled = false;       end;   if (id = last.id(0))            /* If id is same as last call and memory hasn't moved */   then do;                        /* we can return what we found last time */      Object.Ptr = last.ptr(0);    /* Just in case user glommed Object.Ptr */      return true;                 /* Found it */   end;   if (id = last.id(1))            /* If id is same as last call and memory hasn't moved */   then do;                        /* we can return what we found last time */      Object.Ptr = last.ptr(1);    /* Just in case user glommed Object.Ptr */      return true;                 /* Found it */   end;   Next.Ptr = 0;              /* Zero search ptrs */   Object.Ptr = 0;   do while Read.Object(Next.Ptr) <> O#Len.End;  /* Go until end of list */      Object.Ptr = Next.Ptr;              /* Save where we are now in case it is it */      Next.Ptr  = Next.Ptr + read(md);    /* Get next ptr for next time around */      if Read.Object(Object.Ptr+O#Id) = Id then do; /* Is this the object? */         last.ptr(last.index) = Object.Ptr; /* Save object found for quick check next time */         last.id (last.index) = Id;         /* Save id for quick check */         last.index = last.index xor 1;         return true;                       /* Found it */      end;      if Any.Realtime.Objects<>0 then do;         count=count+1;         if count=20 then do;            count=0;            call Run.Syn.Loop;         end;      end;   end;   /* Object not found */   return false;   /* Didn't find it */end LOCATE.OBJECT;DUMP.OBJECTS: proc public swapable;  dcl This.Ptr     fixed;  dcl Next.Ptr     fixed;  dcl value        fixed;  call Set.Term.Attr(ATTR#Normal);  call cpos(23,0);  call tty_wait;  disable;  print;  print 'Dumping screen manager objects';  do while Read.Object(Next.Ptr) <> O#Len.End;   /* Go until end of list */     This.Ptr = Next.Ptr;                     /* Save where we are now */     Next.Ptr  = Next.Ptr + read(md);         /* Get next ptr for next time around */     print;     print 'Found object at PTR =',This.Ptr,',  Length =',read(md);     value = Read.Object(This.Ptr+O#Id);     print '  ID =',value,;     value = Read.Object(This.Ptr+O#Type);     print ',  Type =',value,;     value = Read.Object(This.Ptr+O#Status);     print ',  Status =',value;  end;  enable;end DUMP.OBJECTS;/* The 'item' parameter in Fetch.Object.Info and Deposit.Object.Info is   an offset into the object specified.  Literals for most items are    declared in SMGRLITS.  */   FETCH.OBJECT.INFO: proc(id,item) returns (fixed) public swapable;   dcl id   fixed;   dcl item fixed;   if Locate.Object(id) then do;      return Read.Object(Object.Ptr+item);   end;   return 0;end FETCH.OBJECT.INFO;DEPOSIT.OBJECT.INFO: proc(id,item,info) public swapable;   dcl id    fixed;   dcl item  fixed;   dcl info  fixed;   if Locate.Object(id) then do;      call Write.Object(Object.Ptr+item,info);   end;end DEPOSIT.OBJECT.INFO;DISABLE.OBJECT: proc(id) public swapable;   dcl id       fixed;   if Locate.Object(id) then do;      write(md) = Read.Object(Object.Ptr+O#Status)&not(O#STAT.Enable);   end;end DISABLE.OBJECT;ENABLE.OBJECT: proc (id) public swapable;   dcl id      fixed;   if Locate.Object(id) then do;      write(md) = Read.Object(Object.Ptr+O#Status)\O#STAT.Enable;   end;end ENABLE.OBJECT;ENABLE.OBJECT.RANGE: proc (lowid,highid) public swapable;   dcl lowid     fixed;   dcl highid    fixed;   dcl Next.Ptr  fixed;   dcl Cur.Ptr   fixed;   dcl id        fixed;   Next.Ptr = 0;   Cur.Ptr = 0;   do while Read.Object(Next.Ptr) <> O#Len.End;  /* Traverse entire list */      Cur.Ptr   = Next.Ptr;      Next.Ptr  = Next.Ptr + read(md);      Id        = Read.Object(Cur.Ptr+O#Id);      if (id >= lowid) & (id <= highid)      then write(md) = Read.Object(Cur.Ptr+O#Status)\O#STAT.Enable;  /* Set Enabled bit in Status word */   end;end ENABLE.OBJECT.RANGE;DISABLE.OBJECT.RANGE: proc (lowid,highid) public swapable;   dcl lowid     fixed;   dcl highid    fixed;   dcl Next.Ptr  fixed;   dcl Cur.Ptr   fixed;   dcl id        fixed;   Next.Ptr = 0;   Cur.Ptr = 0;   do while Read.Object(Next.Ptr) <> O#Len.End;  /* Traverse entire list */      Cur.Ptr   = Next.Ptr;      Next.Ptr  = Next.Ptr + read(md);      Id        = Read.Object(Cur.Ptr+O#Id);      if (id >= lowid) & (id <= highid)      then write(md) = Read.Object(Cur.Ptr+O#Status)&(not O#STAT.Enable);  /* Clear Enabled bit in Status word */   end;end DISABLE.OBJECT.RANGE;ENABLE.ALL.OBJECTS: proc public swapable;  /* Sets Enable bit to 1 for all defined objects */   call Enable.Object.Range(0,32767);end ENABLE.ALL.OBJECTS;MAP.POINT.TO.OBJECT: proc(x,y) returns (fixed) public swapable; /* sees if point is in any defined region */   dcl (x,y)    fixed; /* graphics coord to map */   dcl Next.Ptr fixed;   dcl Cur.Ptr  fixed;   dcl Id       fixed;   Cur.Ptr = 0;   Next.Ptr  = 0;  /* init ptr to start of object list */   do while Read.Object(Next.Ptr) <> O#Len.End;  /* Loop until end of list */      Cur.Ptr = Next.Ptr;      Next.Ptr  = Next.Ptr + read(md);      if (Read.Object(Cur.Ptr+O#Status)&O#STAT.Enable) <> 0 then do;  /* enabled */         call Read.Object(Cur.Ptr+O#ULX);         if (x >= read(mdi))       /* See if x,y is in object's region */         &  (y <= read(mdi))         &  (x <= read(mdi))         &  (y >= read(mdi))         then return read(md);   /* If so return the id# */      end;   end;   return 0;end MAP.POINT.TO.OBJECT;Map.Point.To.Any.Object: proc (X,Y,Cell) fixed public swapable; /* figures out which cell of which object (X,Y) lies on */   dcl (X,Y) fixed; /* point to map */   dcl Cell  array; /* Output Col & Row */   dcl Id    fixed; /* output object */   Id=Map.Point.To.Object(X,Y);   Cell(0)=(-1); Cell(1)=(-1); /* assume no cell mapping */   if Id<>0 then do;           /* point mapped to a real object */      if Fetch.Object.Info(Id,O#Type)=O$Table      then call Map.Point.To.Table.Cell(X,Y,Id,Cell);   end;   return Id;end Map.Point.To.Any.Object;POINT.IN.OBJECT: proc(id,x,y) public swapable;   dcl id    fixed;   dcl (x,y) fixed;   if Locate.Object(id) then do;      return (  (x >= Read.Object(Object.Ptr+O#ULX))              & (x <= Read.Object(Object.Ptr+O#LRX))              & (y >= Read.Object(Object.Ptr+O#LRY))              & (y <= Read.Object(Object.Ptr+O#ULY)));   end;   return 0;   /* No object located */end POINT.IN.OBJECT;CHECK.UPDATE.ON.DEPOSIT: proc (ptr) public swapable;   /* Called by most object's deposit routines */   dcl ptr    fixed;   dcl status fixed;   write(md)=Read.Object(ptr+O#Status)\(O#STAT.Update);      /* Force redisplay of object */   status = read(md);   if  ((Read.Object(ptr+O#Action)&O#ACT.Update.On.Dep)<>0)  /* Refresh on Deposit */   and ((status                   &O#STAT.Enable      )<>0)   then return true;   else do;      Screen.Changed = true;           /* Set change flag for later update */      return false;   end;end CHECK.UPDATE.ON.DEPOSIT;/* Calculate.Closest.Object: calculates the object closest to the   object with the passed id in the given direction. If there is no other   object, then it returns itself as the closest one.  It is called by    :synsou:smgrmod:smg-sman through the procedure Process.Arrow.Key   as part of a facility to automatically choose which object   the arrows should select. 7/10/87 cls   WARNING: This procedure modifies the global variable "Object.Ptr" !!  */CALCULATE.CLOSEST.OBJECT: procedure (current.id,obj.ptr,direction) returns (fixed) public swapable;   dcl min.id            fixed;       /* current closest id */   dcl current.id        fixed;       /* id of obj currently selected */   dcl obj.ptr             fixed;     /* permanent pointer to object */   dcl Next.Ptr          fixed;       /* for advancing pointer */   dcl (ulx,uly,lrx,lry) fixed;       /* the coordinates of obj searched */   dcl direction         fixed;       /* 0 = up, 1 = down, 2 = left, 3 = right */   dcl (curx,cury)       fixed;       /* coords of selected object - dcl in order */   dcl (newx,newy)       fixed;       /* coords of obj searched */   dcl (xdif,ydif)       fixed;       /* difference along two axes of two objects */   dcl (xweight,yweight) fixed;       /* weight given to distance along each axis */   dcl (dis.msb,dis.lsb)         fixed;/* distance from object to another */   dcl (min.dis.msb,min.dis.lsb) fixed;  /* min distance calculated so far */   dcl type                      fixed; /* type of current object */   dcl table                     fixed; /* true if current type is table */   dcl cell(1)             fixed;     /* array to receive col, row */   dcl (cell.col,cell.row) fixed;     /* permanent copy of same */   dcl (id,trans.width)    fixed;     /* save calls to Read.Object */   dcl (above,below,left,right) fixed;   dcl Links.Exist              fixed;   dcl action                   fixed;   dcl Mouse.Access             fixed;   dcl Directions.Match         fixed;   gpos.x: proc (x) returns (fixed); /* maps transparent x-coord to graphics pixel pos */      dcl x fixed; /* horizontal char pos * 100 (can be + or - ) */      if MG600 then do;         x = (x * 12 / 100) + 23;         if rem ige 50 then x = x + 1;      end;      else do; /* vt640 */         x = (x * 75 / 1000) + 8;         if rem ige 500 then x=x+1;      end;      if      x < 0            then x = 0;      else if x > screen.width then x = screen.width;      return x;   end gpos.x;   gpos.y: proc (y) returns (fixed); /* maps transparent y-coord to graphics pixel pos */      dcl y fixed; /* vertical char pos * 100 (can be + or - ) */      if MG600 then do;         y = ((2300-y) * 30 / 100) + 42;         if rem ige 50 then y = y + 1;      end;      else do; /* vt640 */         y = ((2300-y) * 20 / 100);         if rem ige 50 then y = y + 1;      end;      if      y < 0             then y = 0; /* limit coord to screen bounds */      else if y > screen.height then y = screen.height;      return y;   end gpos.y;/* Input.Type: This procedure returns true if the type passed to the   procedure is a type which allows numbers or letters to be deposited   to it from the keyboard via the screen. 7-13-87 cls */Input.Type: procedure (type) returns (fixed);   dcl type fixed;  /* type in question */   if (type = O$Fixed.Point)   or (type = O$32Bit.Msec)   or (type = O$32Bit.SMPTE)   or (type = O$Sound.File.Time)   or (type = O$String)   or (type = O$Graphics.String)   then return 1;   else return 0;      end Input.Type;/* Calculate.Object.Center: Calculates appropriate center for given   object.  If the object is one that can be typed into, the center   returned is the center of the current cursor position.  If it   is not one of these objects, it is merely the center of the   object.  For tables, this is done on the level of the cell, not   the object.   7-15-87 cls   WARNING: This procedure modifies the global variable "Object.Ptr" !!  */ Calculate.Object.Center: procedure (obj.id,obj.ptr,direction,coordinates) returns (fixed);   dcl obj.id      fixed;  /* object whose center is in question */   dcl obj.ptr     fixed;  /* pointer to aforemention object */   dcl direction   fixed;  /* must be < 2 for cursor checking */   dcl coordinates array;  /* where the coordinates of center are stored for return */   dcl (obj.x,obj.y)          fixed; /* working version of coordinates of center */   dcl (obj.height,obj.width) fixed; /* height, width in pixels of object */   dcl type                   fixed; /* type of object */   dcl inp.width              fixed; /* more width info for table calculations */   gpix.x: proc (chars) returns (fixed);      dcl chars fixed;  /* hundredths of chars to compute graphic pixels for */      load abs(chars);      mul  tchar.width;      mwait;      div  1000;      if chars < 0      then return -(res + (rem >= 500));      else return   res + (rem >= 500);   end gpix.x;   gpix.y: proc (chars) returns (fixed);      dcl chars fixed;  /* hundredths of chars to compute graphic pixels for */      load abs(chars);      mul  tchar.height;      mwait;      div  1000;      if chars < 0      then return -(res + (rem >= 500));      else return   res + (rem >= 500);   end gpix.y;   type = Read.Object(Obj.Ptr + O#Type);   if type <> O$Table then do;      obj.height= Read.Object(Obj.Ptr+O#ULY)-Read.Object(Obj.Ptr+O#LRY);      obj.y   = Read.Object(Obj.ptr+O#LRY)+shr(obj.height,1);      if  Input.Type(type)   /* one of the objects characters are entered to */      and ((Read.Object(Obj.Ptr + O#Action) & O#ACT.Get.Disabled) = 0) /* input not disabled */      and (direction < 2)    /* we are moving up or down, not sideways */      then do;  /* calculate from center of last character typed */         obj.width = gpix.x(token(0) * 100 + 50);   /* number of pixels to center of last character typed */         obj.x = Read.Object(Obj.Ptr + O#ULX) + obj.width;      end;      else do;  /* find center */          obj.width = Read.Object(Obj.Ptr+O#LRX)-Read.Object(Obj.Ptr+O#ULX);          obj.x = Read.Object(Obj.Ptr+O#ULX)+shr(obj.width,1);      end;   end;   else do;   /* Old object is a table */      if Locate.Object(Read.Object(obj.ptr+O#TABL.Cell.Type.Id)) then do;         obj.height= Read.Object(Object.Ptr+O#ULY)-Read.Object(Object.Ptr+O#LRY);         obj.y = Read.Object(obj.ptr+O#ULY)               - ((Read.Object(obj.ptr+O#TABL.Cur.Row)               * obj.height) + shr(obj.height,1));         obj.width = Read.Object(Object.Ptr + O#LRX) - Read.Object(Object.Ptr + O#ULX);         if  Input.Type(Read.Object(Object.Ptr + O#Type))         and ((Read.Object(Obj.Ptr + O#Action) & O#ACT.Get.Disabled) = 0)         then do; /* calculate from center of last character typed in appropriate cell */            inp.width = gpix.x(token(0) * 100 + 50);            obj.x = Read.Object(Obj.Ptr + O#ULX)                  + ((Read.Object(obj.ptr + O#TABL.Cur.Col)                  * obj.width) + inp.width);         end;         else do; /* calculate from center of appropriate cell */            obj.x = Read.Object(obj.ptr + O#ULX)                  + ((Read.Object(obj.ptr + O#TABL.Cur.Col)                  * obj.width) + shr(obj.width,1));         end;      end;      else return false;   end;   coordinates(0) = obj.x;   coordinates(1) = obj.y;   return true;end Calculate.Object.Center;   /* Give weight to the axis along which the selected arrow points.      This allows the arrow to give preference to those objects that      are more closely aligned with the current object, to make program      behaviour a little more intuitive. */   if direction > 1   then do;      xweight = 1;      yweight = 5;   end;   else do;      xweight = 5;      yweight = 1;   end;      if not Calculate.Object.Center(current.id,Obj.Ptr,direction,loc(addr(curx)))   then return false;   if curx > Read.Object(Obj.Ptr+O#LRX) then curx = Read.Object(Obj.Ptr+O#LRX);   min.id = current.id;  /* set to id passed in, in case no other is found */   min.dis.msb = -1;   min.dis.lsb = -1;       /* set to highest integer - all others must =  or <  */   Next.Ptr = 0;   Obj.Ptr = 0;   /* search loop - loops through all objects */   do while(Read.Object(Next.Ptr) <> O#Len.End);      Obj.Ptr = Next.Ptr;      Next.Ptr = Next.Ptr + read(md);      /* attributes check */      id = Read.Object(Obj.Ptr + O#ID);      trans.width = Read.Object(Obj.Ptr + O#TRANS.WIDTH);      type = Read.Object(Obj.Ptr + O#Type);      above = Read.Object(obj.ptr + O#ObjAbove);      below = Read.Object(obj.ptr + O#ObjBelow);      left  = Read.Object(obj.ptr + O#ObjLeft);      right = Read.Object(obj.ptr + O#ObjRight);      if  ((above = -1) or (above = 0))      and ((below = -1) or (below = 0))      and ((left  = -1) or (left  = 0))      and ((right = -1) or (right = 0))      then Links.Exist = 0;      else Links.Exist = 1;      action = Read.Object(obj.ptr + O#Action);      if  (((action&O#ACT.Middle.Press)      or  (action&O#ACT.Left.Press)      or  (action&O#ACT.Right.Press)      or  (action&O#ACT.Left.Release)      or  (action&O#ACT.Middle.Release)      or  (action&O#ACT.Right.Release)) <> 0)      then Mouse.Access = 1;      else Mouse.Access = 0;      if  (id <> current.id)                 /* Not current object */      and ((type > 0)                        /* Is transparent mode */      or   (type = O$Graphics.String))       /* or graphics string  */      and ((Read.Object(Obj.Ptr + O#Status)&O#STAT.Enable) <> 0)  /* Is enabled */      and Links.Exist                        /* Has links out */      and Mouse.Access                       /* Accepts some mouse input */      and (action & O#ACT.Prev.Obj) = 0      /* Won't bounce right back */      then do;                               /* Object is OK to try */         ulx = Read.Object(Obj.Ptr + O#ULX);         uly = Read.Object(Obj.Ptr + O#ULY);         lrx = Read.Object(Obj.Ptr + O#LRX);         lry = Read.Object(Obj.Ptr + O#LRY);         if type = O$Table then do; /* find center of closest cell in table */            call Map.Point.To.Table.Cell(curx,cury,id,cell);            cell.row = Read.Object(Obj.Ptr + O#TRANS.ROW) + cell(1);            cell.col = Read.Object(Obj.Ptr + O#TRANS.COL) + cell(0) * trans.width;            newx = gpos.x((cell.col+shr(trans.width,1))*100);            newy = gpos.y(cell.row*100+50);         end;         else do;  /* find center of object */            newx = ulx + shr((lrx - ulx),1);            newy = lry + shr((uly - lry),1);                                              end;         /* if a portion of an object is found in a direct line from the            point of reference of the original object, the intersection            point is considered the point of reference for that object,            thus preventing in some part, the problem of skipping over large            objects to smaller objects whose centers are more in line            with the original reference point. */         if direction < 2 then do;            if  (curx >= ulx)            and (curx <= lrx)            and (newy >= lry)            and (newy <= uly)            then newx = curx;         end;         else do;            if  (newx >= ulx)            and (newx <= lrx)            and (cury >= lry)            and (cury <= uly)            then newy = cury;         end;         xdif = newx - curx;         ydif = newy - cury;         /* the Distance Formula you learned in high school w/o the sq.rt.            using hardware mul/div to avoid floating point numbers. */         if ((xdif < 0) and (direction = 2))         or ((xdif > 0) and (direction = 3))         or ((ydif < 0) and (direction = 1))         or ((ydif > 0) and (direction = 0))         then Directions.Match = 1;         else Directions.Match = 0;         if Directions.Match then do;            load abs(xdif);            mul abs(xweight);            dis.msb = ures;            dis.lsb = res;            load abs(ydif);            mul abs(yweight);            dis.msb = dis.msb + ures;            dis.lsb = dis.lsb + res;            if dis.lsb ILT res then dis.msb = dis.msb + 1;                                                    /* vector check */            if ((dis.msb ILT min.dis.msb)                      /* closer */            or ((dis.msb = min.dis.msb)            and (dis.lsb ILT min.dis.lsb)))            then do;                                           /* meets requirements, reset minimum */               min.id = id;               min.dis.msb = dis.msb;               min.dis.lsb = dis.lsb;            end;         end;      /* of Directions.Match */      end;         /* of object is OK to try */   end;            /* of loop through all objects */   return min.id;   /* return ID number of "closest" object */end CALCULATE.CLOSEST.OBJECT;