/* SMG-SWCH   $TITLE  Transparent Mode Switch Routine   Modified:   11/21/90 - cj  - Worked around 'table update' problem which caused                    busted 'safe/ready' switch on Project Manager Panel   06/17/88 - TSS - Keep GET.SWITCH from disabling interrupts for so long   02/19/88 - MWH - Deposit new value AFTER comparing with current value   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   11/13/87 - MWH - Allow switch animation and numeric selection concurrently   10/30/87 - MWH - Make switches default to return to previous object   10/20/87 - MWH - Keep screen updated while waiting for events   10/19/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/15/87 - MWH - Clean up switch handling significantly   10/02/87 - MWH - Better error return   10/01/87 - MWH - Make unreferenced procedures NON-public   09/25/87 - MWH - Use literals for suffix lengths   */DEFINE.SWITCH.SUBROUTINE: proc (id,row,col,width,format,switch) swapable;   dcl id         fixed;   dcl row        fixed;   dcl col        fixed;   dcl width      fixed;   dcl format     fixed; /* Future use */   dcl switch     array;   dcl (i)        fixed;   dcl max.sw.pos fixed;   dcl max.size   fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   max.sw.pos = 1;               /* Count switch positions */   do i = 0 to switch(0)-1;      if byte(switch,i) = a.bar then max.sw.pos = max.sw.pos + 1;   end;   if max.sw.pos > 255 then max.sw.pos = 255;   /* Max positions */   max.size = max.sw.pos * (width+1);  /* allow room for full length switch settings - plus 1 character per setting for the bar */   if switch(0) >= max.size            /* but allow room in case initial string      */   then max.size = switch(0);          /* is incredably long                         */   if Allocate.New.Object(O#Hlen+O#SWCH.Size+shr(max.size+1,1)+1) then do;      call Write.Object(Object.Ptr+  O#Type,  O$Switch);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr+  O#Id,    id);      call Set.Object.Default.Get(id,Get.Mouse.Movement,true);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(col*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(row*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(col*100)+gpix.x(width*100));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(row*100));      call Write.Object(Object.Ptr + O#Action, O#ACT.Prev.Obj                                             \ O#ACT.Left.Press                                             \ O#ACT.Middle.Press                                             \ O#ACT.Right.Press                                             \ O#ACT.Animate.Disabled                                             \ Default.Action);       call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,  Get#In.Char                                                  \ Get#Mouse.Button);      call Write.Object(Object.Ptr + O#UserGets,Get#Mouse.Movement);      call Write.Object(Object.Ptr + O#Trans.Row,Row);  /* Trans Row */      call Write.Object(Object.Ptr + O#Trans.Col,Col);      call Write.Object(Object.Ptr + O#Trans.Width,Width);      call Write.Object(Object.Ptr + O#SWCH.Format,format);      call Copy.String.To.Exmem(switch,Object.Ptr+O#SWCH.Settings);      call Write.Object(Object.Ptr + O#SWCH.Info,max.sw.pos);      Screen.Changed = true;      return Id;   end;   else return 0;end DEFINE.SWITCH.SUBROUTINE;DEFINE.SWITCH: proc (id,row,col,width,format,switch) public recursive;   dcl id         fixed;   dcl row        fixed;   dcl col        fixed;   dcl width      fixed;   dcl format     fixed;   /* Future use */   dcl switch     array;   dcl oursw (64) fixed;   call copy.string(switch,oursw);   return Define.Switch.Subroutine (id,row,col,width,format,oursw);end DEFINE.SWITCH;DRAW.SWITCH: proc(ptr,curp) swapable;   dcl ptr        fixed;   dcl curp       fixed;   dcl (i,j,k)    fixed;   dcl switch.len fixed;   call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col));   call Set.Term.Obj.Attr(Ptr);   i = 0;   j = 0;   switch.len = Read.Object(ptr+O#SWCH.Settings);  /* Positions ext mem */   write("324") = read(mdi);                       /* Get to first char */   do while (i < switch.len) & (j < curp);      if (i&1) = 0 then k = read(md)&255;      else              k = shr(read(mdi),8);      if k = a.bar then j = j + 1;      i = i + 1;   end;   if (i&1) = 0 then k = read(md)&255;   else              k = shr(read(mdi),8);   j = 0;   do while (i < switch.len) & (k <> a.bar);      call pc(k);      j = j + 1;      i = i + 1;      if (i&1) = 0 then k = read(md)&255;      else              k = shr(read(mdi),8);   end;   do i = j to Read.Object(ptr+O#Trans.Width)-1;   /* to width of field */      call pc(a.space);   end;   if Disable.Attr.Reset=0 then call Set.Term.Attr(ATTR#Normal);end DRAW.SWITCH;UPDATE.SWITCH: proc (ptr) public swapable;   dcl ptr        fixed;   dcl status     fixed;   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (status and O#STAT.Update) <> 0 then do;      call Draw.Switch(ptr,Read.Object(ptr+O#SWCH.Pos));      call Write.Object(ptr+O#SWCH.Disp.Pos,Read.Object(ptr+O#SWCH.Pos));      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */   end;end UPDATE.SWITCH;DEPOSIT.SWITCH: proc (id,pos) public swapable;   dcl id      fixed;   dcl pos     fixed;   dcl ptr     fixed;   dcl max.pos fixed;   dcl status  fixed;   if Locate.Object(id) then do;      ptr = Object.ptr;      status = Read.Object(ptr + O#Status);      max.pos = Read.Object(ptr+O#SWCH.Info)-1; /* Limit position */      if pos > max.pos then pos = max.pos;      if pos < 0 then pos = 0;      if ((status & O#STAT.Exhibit) = 0)         /* Object never displayed... */      or (pos <> Read.Object(ptr + O#SWCH.Pos))  /* ...or value changed */      then do;         call Write.Object(ptr+O#SWCH.Pos,pos);  /* Write new position */         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.Switch(ptr);                /* Do update right now */      end;   end;end DEPOSIT.SWITCH;/* routine to change one field of a string */DEPOSIT.SWITCH.FIELD: proc (id,pos,field) public swapable;   dcl id         fixed;    /* switch id                */   dcl pos        fixed;    /* which position to change */   dcl field      array;    /* the new field            */   dcl (i,j)      fixed;   dcl str(64)    fixed;   dcl switch.len fixed;   dcl max.size   fixed;   dcl max.pos    fixed;   dcl ptr        fixed;   dcl curpos     fixed;   dcl dispos     fixed;   dcl start.of.field    fixed;   dcl end.of.field.bar  fixed;   if Locate.Object(id) then do;      ptr = Object.ptr;      max.pos = Read.Object(ptr+O#SWCH.Info); /* Limit position */      if pos >= max.pos then return false;      if pos <  0       then return false;      curpos = Read.Object(Ptr + O#SWCH.Pos);       dispos = Read.Object(Ptr + O#SWCH.Disp.Pos);      switch.len = Read.Object(ptr+O#SWCH.Settings);  /* Positions ext mem */      if switch.len > 128 then return false;      call copy.in(addr(str(0)),shr(switch.len+3,1));   /* get current string */      i=0;      j=0;      do while (i<switch.len) & (j<pos);         if byte(str,i) = a.bar then j = j + 1;         i=i+1;      end;               start.of.field = i;     /* save - point pointer to start of alpha field (not a possible preceding bar) */      do while (i<switch.len) & (byte(str,i) <> a.bar);         i=i+1;      end;      end.of.field.bar = i;      if  (start.of.field      +    field(0)       +    (str(0)-end.of.field.bar)) > 128 then return false;      i = field(0) - (end.of.field.bar-start.of.field); /* get length change */      if i>0 then do;              /* copy up */         j=switch.len;         do while j>end.of.field.bar;            j=j-1;            call pbyte(str,j+i,byte(str,j));         end;         str(0)=str(0)+i;      end;      else if i<0 then do;         /* copy down */         j=end.of.field.bar;         do while j<switch.len;            call pbyte(str,j+i,byte(str,j));            j=j+1;         end;         str(0)=str(0)+i;      end;      do i=0 to field(0)-1;         call pbyte(str,start.of.field+i,byte(field,i));      end;      max.size = max.pos * (Read.Object(ptr+O#Trans.Width)+1);  /* plus one for possible bars   */      if str(0) >= max.size              /* make sure new string fits    */      then return false;            call Copy.String.To.Exmem(str,Ptr+O#SWCH.Settings);      /* update screen only if changed position is the one */      /* now displayed or the one desired                  */      if (pos = curpos) or (pos = dispos)      then do;         if Check.Update.On.Deposit(ptr) <> 0         then call Update.Switch(ptr);                  /* Do update right now */      end;      return true;   end;   return false;end DEPOSIT.SWITCH.FIELD;GET.SWITCH: proc (ptr) returns (fixed) public swapable;   dcl ptr     fixed;   dcl evt     fixed;   dcl max.pos fixed;   dcl curp    fixed;   dcl disp    fixed;   dcl id      fixed;   dcl acc     fixed;   dcl accmax  fixed;   dcl switch.dist lit '25';   dcl pressed fixed;   dcl movemnt fixed;   dcl temp    fixed;   dcl (x,y)   fixed;	dcl where   fixed;   /* Take a snapshot of the switch object; initialize things */   id      = Read.Object(ptr+O#ID);   max.pos = Read.Object(ptr+O#SWCH.Info)-1;   accmax  = max.pos * switch.dist + switch.dist-1;   pressed = false;   movemnt = false;   /* This procedure processes outer mouse button presses */   BUMP.SWITCH: proc (ptr,info);      dcl ptr     fixed;      dcl info    fixed;      dcl max.pos fixed;      dcl curp    fixed;      max.pos = Read.Object(ptr+O#SWCH.Info)-1;      curp    = Read.Object(ptr+O#SWCH.Disp.Pos);      if info = Mou#Right.Down then curp = curp + 1;      else                          curp = curp - 1;      if curp > max.pos then curp = 0;      else if curp < 0 then curp = max.pos;      call Deposit.Switch(Read.Object(ptr+O#ID),curp);      call Update.Switch(ptr);      return curp;   end BUMP.SWITCH;   /* CALL DEBUG(2,'GET SWITCH  SCREEN.EVENT.CODE=',SCREEN.EVENT.CODE); */   /*  First, see if we are entering the switch via mouse, from a different    *  object.  If so, we need to take the event which caused the exit    *  from the previous object, and apply the appropriate action to the    *  switch (eg: right mouse button down => increment switch).    */   if Object.Exit.Id <> id then do;                   /* If we came from a different object */      if (Object.Exit.Code = Get.Mouse.Button)        /* Mouse button was previous object's event */      then do;         if (abs(Object.Exit.Info) <> Mou#Middle.Up)  /* ...but was not the middle button (up or down) */         then do;            if (Object.Exit.Info = Mou#Right.Down)    /* Triggering event was an outer mouse button down... */            or (Object.Exit.Info = Mou#Left.Down)     /* ...we want to increment or decrement switch */            then call BUMP.SWITCH(ptr,Object.Exit.Info);            Last.Event.Info = S#ObjectTerminate;            Last.Event.Code = Get.Screen.Event;            return Get.Screen.Event;         end;         else if (Object.Exit.Info = Mou#Middle.Down) then do;            pressed = true;                           /* A mouse click got us in, animate the switch */				where   = Mouse(press.x);            call Mouse.Switch(0);                     /* Turn off crosshair during animate */         end;      end;   end;   /*  Next, handle events which occur while the switch is the    *  current active object.  The do while 1 loop is in place    *  to handle animation (that is, changing the value of the    *  switch by holding the middle mouse button down and moving    *  left and right).    */   curp = Read.Object(ptr+O#SWCH.Disp.Pos);   /* Displayed position is current */   disp = curp;                               /* Save current position */   acc  = curp * switch.dist + shr(switch.dist,1);   do while 1;      call Enable.Object.and.User.Gets(ptr);      call Get_Enable(Get.Screen.Event);      /* Keep ourselves from clobbered by updating the table for which */      /* we are the type object!!:                                     */      if (Screen.Changed) and (not(pressed))      then call Update.Screen;      evt = Get.Next.Event;      call Disable.Object.and.User.Gets(ptr);      call Get_Disable(Get.Screen.Event);      if (evt = Get.Mouse.Button) then do;         if (Last.Event.Info < 0) then do;  /* A mouse button DOWN */            x = Mouse(press.x);             /* Get coordinates of where down */            y = Mouse(press.y);            /* If not pointing at the switch, then event is for someone else */            if POINT.IN.OBJECT(id,x,y) = FALSE  and  pressed = FALSE            then return Last.Event.Code;      /* Return the mouse event as is */         end;         if (Last.Event.Info = Mou#Middle.Up) then do;            if get.item.enabled(get.mouse.button) <> 0            then call Write.Event.Queue(Get.Mouse.Button,Last.Event.Info,id);            if pressed then do;  /* If we were doing animation */               x = gpos.x(100*(Read.Object(ptr+O#Trans.Col)+shr(Read.Object(ptr+O#Trans.Width),1)));               y = gpos.y(100*Read.Object(ptr+O#Trans.Row))+shr(gpix.y(100),1);               /* Put mouse cursor directly over switch after animation */			   					if (MOUSE.PORT.IS.D50 == 0)					{						disable;							Mouse.X = x;							Mouse.Y = y;						enable;					}					               call Mouse.Switch(1);                     /* Restore crosshairs */            end;            pressed = false;            if curp <> Read.Object(ptr+O#SWCH.Disp.Pos)  /* If switch position changed... */            then call Deposit.Switch(id,curp);           /* ...deposit new value */            call Update.Switch(ptr);            Last.Event.Info = S#ObjectTerminate;            Last.Event.Code = Get.Screen.Event;            return Get.Screen.Event;           end;         else if (Last.Event.Info = Mou#Middle.Down) then do; /* Pressed mouse to animate switch */            if get.item.enabled(get.mouse.button) <> 0            then call Write.Event.Queue(Get.Mouse.Button,Last.Event.Info,id);            pressed = true;				where   = Mouse(press.x);            movemnt = false;            call Mouse.Switch(0);  /* Turn off crosshair during animate */         end;         else if ((Last.Event.Info = Mou#Right.Down)   /* If event was an outer mouse button */         or (Last.Event.Info = Mou#Left.Down))         and pressed = false then do;            call BUMP.SWITCH(ptr,Last.Event.Info);            Last.Event.Info = S#ObjectTerminate;            Last.Event.Code = Get.Screen.Event;            return Get.Screen.Event;         end;      end;         /* of event was Get.Mouse.Button */      else if evt = Get.Mouse.Movement then movemnt = true;      else if evt = Get.Arrow.Key               /* Leaving via arrow key */      and pressed = false then return evt;      else if evt = Get.In.Char then do;         if Last.Event.Info = a.space then do;  /* toggle with space bar */            curp = curp + 1;            if curp > max.pos then curp = 0;            acc = curp * switch.dist + shr(switch.dist,1);         end;         else if  (Last.Event.Info >= a.0)  /* Type in switch position */         and (Last.Event.Info <= a.9)         then do;            temp = Last.Event.Info - a.0;            if temp = 0 then temp = 10;            temp = temp - 1;            if  (temp >= 0)            and (temp <= max.pos)            then curp = temp;            acc = curp * switch.dist + shr(switch.dist,1);         end;         if pressed = false then do;                     /* If we're not animating */            if curp <> Read.Object(ptr+O#SWCH.Disp.Pos)  /* If switch position changed... */            then call Deposit.Switch(id,curp);           /* ...deposit new value */            call Update.Switch(ptr);                     /* Do the update */            Last.Event.Info = S#ObjectTerminate;            Last.Event.Code = Get.Screen.Event;            return Get.Screen.Event;           end;      end;   /* of evt is Get.In.Char */      else if pressed = false then do;  /* Some other type of event */         call Set.Object.Status(id,O#STAT.Update,true);         return evt;        end;      if pressed and movemnt then do;   /* Middle button held, mouse moved */			x = Mouse(current.x);         acc = acc + x - where;    	    /* Calculate movement L to R */			where = x;         if acc < 0 then acc = 0;         else if acc > accmax then acc = accmax;         curp = acc/switch.dist;        /* Set current position */         movemnt = false;      end;            if curp <> disp then do;          /* If anything changed switch value... */         call Draw.Switch(ptr,curp);    /* ...draw new switch position */         disp = curp;      end;         end;    /* of do while 1 */end GET.SWITCH;FETCH.SWITCH: proc (id) returns (fixed) public swapable;   dcl id   fixed;      if Locate.Object(id) then do;      return Read.Object(Object.Ptr+O#SWCH.Pos);   end;   return 0;end FETCH.SWITCH;