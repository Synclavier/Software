/* SMG-TOKN  $TITLE  Global Token Get routines   Modified:   01/09/88 - CJ & SGS - FIXED SEQ PANEL BUG ENTERING TRASH INTO DISABLED                         FIELD (HANS TOBIESEN SEQ PANEL DISPLAY BUG)   07/27/88 - cj  - Changed the way delete is handled   01/12/88 - MWH - Fix tok.change so NAME KEYBOARD TIMBRE works properly   12/07/87 - CJ  - Changed to set overstrike mode always (per Bob M)   12/05/87 - cj  - keep extraneous deposits from occurring when changing objects by setting token(0) = 0   12/05/87 - cj  - fixed bug allowing input when string was max length   12/03/87 - MWH - Fix minor bugs   12/01/87 - MWH - Add editing of existing strings to token routine   10/20/87 - MWH - Keep screen updated while waiting for events   09/29/87 - MWH - Backspace is NOT equal to delete (it is left-arrow)   09/25/87 - MWH - Use literals for suffix lengths   *//* Get Simple Token first sets the terminal into the status state of   the passed object then proceeds to take characters filling up   the global string token.  A screen event S#Deposit is generated   when <RETURN> is pressed.  All other events received from Get.Next.Event   are passed up.   modified 7-30-87 cls *//* modified to include returning a S#KeyActivate if only return is   pressed, similar to SMG-LABL 8-14-87 cls *//* Find the next space, '.' or ':' in a field and position the cursor there */NEXT.SEPARATOR: proc (ch) swapable;   dcl ch fixed;    /* Which character to find (or zero if any separator OK) */   dcl f  boolean;  /* Flag when first separator found */   dcl w  fixed;    /* Remember where it was found */   dcl i  fixed;   f = false;   do i=tok.ptr to token(0)-1;       /* Look for next separator */      if f = false                   /* If none yet */      and (byte(token,i) = a.space   /* And found one of these */      or   byte(token,i) = dot      or   byte(token,i) = colon)      then do;         if ch = 0                   /* If any separator will do */         OR byte(token,i) = ch       /* OR this is the one we want */         then do;            f = true;            w = i;                   /* Remember where found */         end;      end;   end;   if f = false then do;             /* If we haven't looked from start yet */      if tok.ptr <> 0 then do;              do i=0 to tok.ptr-1;        /* Put cursor at start */            call pc(a.bs);         end;         tok.ptr = 0;                /* Wrap back to start */         if ch <> 0                  /* If not tabbing */         then do;            call next.separator(ch); /* Go to first specific instance */            return;                  /* And no more */         end;         else;                       /* If tabbing, just stay at start */      end;      else return;                   /* If none found anywhere, stay at start */   end;   if f = true then do i=tok.ptr to w;      call pc(byte(token,i));        /* Echo up to it */      tok.ptr = tok.ptr + 1;   end;   do while (tok.ptr < token(0)      /* Treat multiple spaces as ONE separator */   AND byte(token,tok.ptr) = a.space);      call pc(a.space);      tok.ptr = tok.ptr + 1;         /* (also skips leading spaces) */   end;end NEXT.SEPARATOR;/* Process the backspace key when editing a field */BACKSPACE: proc swapable;   dcl (rt,i) fixed;   if token(0) > 0                    /* Char there to delete?    */   and tok.ptr > 0 then do;      rt = token(0) - tok.ptr;        /* Chars to right of cursor */      tok.ptr = tok.ptr - 1;          /* Back one character       */      call pc(a.bs);                  /* Backup cursor to tok.ptr */      if rt > 0 then do i=0 to rt-1;  /* Move down rest of string */         call pbyte(token,tok.ptr+i,byte(token,tok.ptr+i+1));      end;      token(0) = token(0) - 1;        /* String is now one less   */      if rt > 0 then do i=0 to rt-1;  /* Echo rest of line right  */         call pc(byte(token,tok.ptr+i));      end;      call pc(a.space);               /* One space to erase char  */      do i=0 to rt;         call pc(a.bs);               /* Backup cursor to tok.ptr */      end;   end;end BACKSPACE;/* Returns a string which the user has edited/typed in */GET.SIMPLE.TOKEN: proc (ptr,pstr) returns (fixed) swapable;   dcl ptr        fixed;           /* Object we're getting token for */   dcl pstr       fixed array;     /* Previous string in the object  */   dcl event      fixed;   dcl ch         fixed;   dcl row        fixed;   dcl col        fixed;   dcl width      fixed;   dcl id         fixed;   dcl type       fixed;   dcl status     fixed;   dcl i          fixed;   dcl higher     fixed;   dcl editing    boolean;         /* Controls whether <-- and --> stay in object */   dcl insert     boolean;   dcl ret        boolean static;  /* Return typed, or just entered object */   dcl tok.change boolean;         /* Set true when user types something real */   dcl ctl.a      lit  '"001"';    /* Define editing control characters */   dcl ctl.d      lit  '"004"';   dcl ctl.e      lit  '"005"';   dcl ctl.r      lit  '"022"';   dcl ctl.x      lit  '"030"';   dcl pf.1       lit  'asc.call.convert+1';   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   tok.change = false;   row   = Read.Object(ptr+O#Trans.Row);   col   = Read.Object(ptr+O#Trans.Col);   width = Read.Object(ptr+O#Trans.Width);   id    = Read.Object(ptr+O#Id);   type  = Read.Object(ptr+O#Type);   status= Read.Object(ptr+O#Status);/* if type = O$String    */          /* Set insert/overstrike mode  *//* then insert = true;   */          /* Insert mode for string only *//* else insert = false;  */          /* Overstrike mode for times   */   insert = false;                   /* Always start in overstrike mode */   if token(0) = 0 then do;          /* We're at the start */      ret = true;                    /* Act as though after <CR> */      call copy.string(pstr,token);  /* Get displayed string */      do while token(0) > 0          /* Remove trailing spaces */      and byte(token,token(0)-1) = a.space;         token(0) = token(0) - 1;      end;      call cpos(row,col);            /* Position the cursor at start of token */      tok.ptr = 0;                   /* Point back at start */   end;   else do;                          /* We've re-entered with a partial token */      if ret = false then do;         call cpos(row,col+token(0));/* Position the cursor at end of token */         tok.ptr = token(0);         /* Point at end of token */      end;      else do;         call cpos(row,col);         /* Position the cursor at start of token */         tok.ptr = 0;                /* Point at start of token */      end;   end;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   do while 1;      call Enable.Object.and.User.Gets(ptr);      if Screen.Changed <> false            /* See if some objects need updating */      then do;         call Update.Screen;                /* Will return right away if events pending */         call cpos(row,col+tok.ptr);        /* Update screen might move cursor */      end;      event = Get.Next.Event;               /* Get a char and other already enabled events */      call Disable.Object.and.User.Gets(ptr);      higher = 0;      if (event = get.in.char)              /* Event received is a character */      then do;                              /* See if get returned ascii char */         if (get.item.enabled(get.in.char) <> 0)  /* Characters still enabled? */         then higher = true;                      /* Someone higher must want it */         if ((status&O#STAT.Enable)<>0) then      /* only look at char */         do;                                      /* if obj enabled    */            ch = last.event.info;            /* Special test for del key pressed at start of field */            if ch = a.del            AND ret = true      /* After <CR> */            AND token(0) <> 0   /* Not using <del> on empty field to restore previous value */            then do;               New.Screen.Event = S#ObjectTerminate;               call Write.Event.Queue(Get.Screen.Event,S#DelAttempt,id);            end;            /* On editing command, enter edit mode */            if  (ch >= ctl.a AND ch <= ctl.x)            OR   ch = pf.1            OR   ch = home            OR   ch = a.del            then do;               if ch <> a.del then editing = true;               if token(0) = 0 then do;          /* Fetch previous string */                  if ch = ctl.d                  /* If deleting chars... */                  OR ch = ctl.e                  OR ch = ctl.x                  OR ch = del                  then ch = 0;                   /* ...don't delete immediately */                  if  ch <> a.cr                 /* <CR> won't fetch old value */                  then do;                     call Set.Term.Obj.Attr(ptr);                     call cpos(row,col);                     call copy.string(pstr,token);  /* Get previous string... */                     tok.ptr = token(0);            /* ...point at it... */                     call ps(token);                /* ...echo it... */                     do while token(0) > 0          /* ...and remove trailing spaces */                     and byte(token,token(0)-1) = a.space;                        call backspace;                     end;                     tok.ptr = 0;                /* Point back at start */                     call cpos(row,col);                     tok.change = true;                  end;               end;   /* of fetch previous string */            end;            if ch = a.cr then do;      /* Get <CR>; deposit field */               call cpos(row,col);     /* Echo <CR> */               write(md) = (Read.Object(ptr+O#Status)\(O#STAT.Update));  /* Force object to be re-written */               Screen.Changed = true;               call Deposit.Token(id,token);               token(0) = 0;               tok.ptr = 0;               ret = true;               if not(tok.change) then do;                  call Write.Event.Queue(Get.Screen.Event,S#KeyActivate,id);               end;               New.Screen.Event = S#ObjectTerminate;   /* Deposit token generates the S#Deposit */            end;            else if (ch = ctl.x) then do; /* Get returned CTRL-X; means erase field */               call cpos(row,col);               call Set.Term.Obj.Attr(ptr);               do i = 1 to width;                  call pc(a.space);               end;               call cpos(row,col);               token(0) = 0;             /* Set token width to zero */               tok.ptr = 0;               editing = false;               tok.change = true;            end;            else if (ch = tab)   /* Tab means next field */            then do;               call Set.Term.Obj.Attr(ptr);               call next.separator(0);            end;      /* of char is tab */            else if ch = a.del              /* Back up a character */            then do;               call Set.Term.Obj.Attr(ptr);               call backspace;               tok.change = true;            end;            else if ch = ctl.a then do;  /* ^A means toggle insert/overstrike */               insert = insert xor 1;            end;            else if ch = ctl.d then do;  /* ^D means delete to right */               if tok.ptr < token(0) then do;  /* If chars exist to the right */                  call Set.Term.Obj.Attr(ptr);                  call pc(byte(token,tok.ptr));  /* Move ahead one char */                  tok.ptr = tok.ptr + 1;                  if insert = true then do;      /* If inserting */                     call backspace;             /* Then do "delete key" */                     tok.change = true;                  end;               end;            end;            else if ch = ctl.e then do;  /* ^E means delete to end */               if token(0) > 0               AND tok.ptr < token(0)               then do;                  call Set.Term.Obj.Attr(ptr);                  do i=tok.ptr to token(0)-1;                     call pc(a.sp);        /* Echo up to it */                  end;                  token(0) = tok.ptr;      /* Shorten the string */                  call cpos(row,col+token(0));                  tok.change = true;               end;            end;            else if ch = ctl.r           /* ^R means go to beginning of field */            OR      ch = pf.1            /* (PF1 too) */            OR      ch = home            /* (home too) */            then do;               call cpos(row,col);               tok.ptr = 0;            end;            else if (ch >= a.space) & (ch <= a.tilde)  /* Get returned a char; add it to token */            then begin;                            /* Insert character */               dcl rt        fixed;                /* Chars to right of insert */               dcl do.insert boolean;               do.insert = true;                   /* Normally, insert char */               /* First do special check for jump to next "." or ":" */               if (ch = colon OR ch = dot)         /* If "." or ":" typed */               AND type <> O$String                /* Not if general string, though */               AND editing = true                  /* Only if not typing in whole new value */               AND insert = false                  /* Only if overstrike mode */               then do i=0 to token(0)-1;          /* See if "." or ":" somewhere */                  if byte(token,i) = ch                  then do.insert = false;          /* Don't insert char, jump to it */               end;               call Set.Term.Obj.Attr(ptr);               if do.insert = false                /* If special "." or ":" case */               then do;                  editing = true;                  call next.separator(ch);       /* Only find next separator */               end;               else if (tok.ptr < token(0)         /* Room for character */               AND insert = false)               OR (token(0) < width)               OR ((ret = true) & (editing = false)) /* or we are about to trash current input string if not editing */               then do;                  /* Now, check to see if this is first char after <CR> */                  /* If so, we must zero out the previous string (if not editing) */                  if ret = true then do;                     ret = false;                     if editing = false then do;                        call cpos(row,col);                        do i = 1 to width;                           call pc(a.space);                        end;                        call cpos(row,col);                        token(0) = 0;                        tok.ptr = 0;                     end;                  end;                  if insert = true                  then rt = token(0) - tok.ptr;    /* Insert mode */                  else rt = 0;                     /* Overstrike mode */                  if rt > 0 then do;               /* Move up rest of string */                     do i=rt-1 to 0 by -1;                        call pbyte(token,tok.ptr+i+1,byte(token,tok.ptr+i));                     end;                     token(0) = token(0) + 1;      /* String is now one longer */                  end;                  call pbyte(token,tok.ptr,ch);    /* Place it in token */                  if tok.ptr = token(0)            /* If at end of token */                  then token(0) = token(0) + 1;    /* Increment length */                  tok.ptr = tok.ptr + 1;           /* Increment position */                  call pc(ch);                     /* Print it out */                  if rt > 0 then do;               /* Echo rest of string */                     do i=0 to rt-1;                        call pc(byte(token,tok.ptr+i));                     end;                     do i=0 to rt-1;                        call pc(a.bs);                     end;                  end;                  tok.change = true;               end;        /* of room to insert */            end;           /* of insert character */            if tok.ptr <> 0    /* If any command left the cursor to the right */            then ret = false;  /* Then we're not just after a <CR> */         end;         if higher AND ch <> 0 then do;            if (Any.RealTime.Objects <> 0) then call Run.Syn.Loop;            return event;         end;      end;   /* of event is get.in.char */      else if (event = get.arrow.key)       /* Event received is an arrow key */      AND editing = true                    /* And we're handling left/right arrows */      then do;         if last.event.info = l.arr then do;            if tok.ptr > 0 then do;         /* Go back if room... */               call pc(a.bs);               tok.ptr = tok.ptr - 1;            end;            else do;                        /* ...else, wrap around */               tok.ptr = token(0);               call cpos(row,col+token(0));            end;         end;         else if last.event.info = r.arr then do;            if tok.ptr < token(0) then do;  /* Go ahead if more chars... */               call Set.Term.Obj.Attr(ptr);               call pc(byte(token,tok.ptr));               tok.ptr = tok.ptr + 1;            end;            else do;                        /* ...else, wrap around */               tok.ptr = 0;               call cpos(row,col);            end;         end;         else do;            if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;            return event;   /* Something we're not processing here */         end;         if tok.ptr <> 0    /* If an arrow moved the cursor to the right */         then ret = false;  /* Then we're not just after a <CR> */      end;  /* of event is get.arrow.key */      else do;         if ret = true then token(0) = 0;   /* but no real token to deposit if we fabricated token */         if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;         return event;   /* Something other than character */      end;   end;     /* of do while 1 */end GET.SIMPLE.TOKEN;