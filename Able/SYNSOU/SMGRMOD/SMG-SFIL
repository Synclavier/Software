/* SMG-SFIL  $TITLE  Sound File Time Routines   Modified:   11/24/87 - MWH - Add editing of existing strings to token routine   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   11/10/87 - MWH - Add separate jogging for each field   10/26/87 - MWH - Fix bugs in jogging   10/20/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/14/87 - MWH - Use new mouse button event literals   10/01/87 - MWH - Make unreferenced procedures NON-public   09/25/87 - MWH - Use literals for suffix lengths   */Define.Sound.File.Time: proc (id,TRow,TCol,width,maxl,maxr) public swapable;   dcl id           fixed;   dcl (ULX,ULY)    fixed; /* graphics region info */   dcl (LRX,LRY)    fixed;    dcl (TCol,Trow)  fixed; /* Transparent position info */   dcl decimal      fixed; /* decimal point position */   dcl width        fixed; /* width of field in chars */   dcl (maxl,maxr)  fixed;   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   If Allocate.New.Object(O#Hlen+O#SF.Size) then do;      call Write.Object(Object.Ptr + O#Type,  O$Sound.File.Time);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(TCol*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(TRow*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(TCol*100)+gpix.x(width*100));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(TRow*100));      call Write.Object(Object.Ptr + O#Id,    Id);      call Write.Object(Object.Ptr + O#Action,Default.Action\O#ACT.Jog.Enabled);      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,Get#In.Char);      call Write.Object(Object.Ptr + O#Trans.Row,TRow);  /* Trans Row */      write(mdi) = TCol;          /* Trans column */      write(mdi) = width;         /* Field width */      call Write.Object(Object.Ptr + O#SF.Maxl,maxl);      call Write.Object(Object.Ptr + O#SF.Maxr,maxr);      call Write.Object(Object.Ptr + O#JogAmount,1);      Screen.Changed = true;      return Id;   end;   else return 0;end Define.Sound.File.Time;Update.Sound.File.Time: proc (ptr) public swapable; /* redraws value in field of object if different from displayed value */   dcl ptr           fixed; /* ptr to object to update */   dcl i             fixed;   dcl status        fixed;   dcl tmp    (4)    fixed;   dcl string (10)   fixed;   dcl width         fixed;   dcl cur.sec       fixed;   dcl cur.msec      fixed;   dcl cur.usec      fixed;   dcl disp.sec      fixed;   dcl disp.msec     fixed;   dcl disp.usec     fixed;   dcl (maxl,maxr)   fixed;   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (status and O#STAT.Update) <> 0 then do;      cur.sec      = Read.Object(ptr+O#SF.Sec);      cur.msec     = Read.Object(ptr+O#SF.Msec);      cur.usec     = Read.Object(ptr+O#SF.Usec);      disp.sec     = Read.Object(ptr+O#SF.Disp.Sec);      disp.msec    = Read.Object(ptr+O#SF.Disp.Msec);      disp.usec    = Read.Object(ptr+O#SF.Disp.Usec);      width        = Read.Object(ptr+O#Trans.Width);      maxl         = Read.Object(ptr+O#SF.Maxl);      maxr         = Read.Object(ptr+O#SF.Maxr);      call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col)); /* Position trans cursor */      call Set.Term.Obj.Attr(ptr);      call CONV.SFTIME.TO.STR(loc(addr(cur.sec)),string,maxl,maxr);      call Pad.String(string,a.sp,Read.Object(ptr+O#Trans.Width));      call ps(string);      if Disable.Attr.Reset=0 then call Set.Term.Attr(ATTR#Normal);      /* Copy values just displayed into object's display record */      call Write.Object(ptr+O#SF.Disp.Sec,Read.Object(ptr+O#SF.Sec));       call Write.Object(ptr+O#SF.Disp.Msec,Read.Object(ptr+O#SF.Msec));       call Write.Object(ptr+O#SF.Disp.Usec,Read.Object(ptr+O#SF.Usec));       call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(Status&O#STAT.Attr.Set,1))); /* object now displayed and refreshed */   end;end Update.Sound.File.Time;Deposit.Sound.File.Time: proc(id,time) public swapable;   dcl id   fixed;   dcl ptr  fixed;   dcl time array;   dcl comptime(2) fixed;   dcl status      fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      status = Read.Object(ptr + O#Status);      comptime(0) = Read.Object(ptr + O#SF.Sec);      comptime(1) = Read.Object(ptr + O#SF.Msec);      comptime(2) = Read.Object(ptr + O#SF.Usec);      call Write.Object(ptr+O#SF.Sec,time(0));  /* Write new value into it */      call Write.Object(ptr+O#SF.Msec,time(1));      call Write.Object(ptr+O#SF.Usec,time(2));      if (status & O#STAT.Exhibit) = 0          /* Object never displayed... */      or (comptime(0) <> time(0))               /* ...or value changed */      or (comptime(1) <> time(1))      or (comptime(2) <> time(2))      then do;         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.Sound.File.Time(ptr);     /* Do update right now */      end;   end;end Deposit.Sound.File.Time;GET.SOUND.FILE.TIME: proc (ptr) returns (fixed) public swapable;   dcl ptr         fixed;   dcl cur.sec     fixed;  /* Declare in order! */   dcl cur.msec    fixed;   dcl cur.usec    fixed;   dcl string (40) fixed;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   cur.sec      = Read.Object(ptr+O#SF.Sec);   cur.msec     = Read.Object(ptr+O#SF.Msec);   cur.usec     = Read.Object(ptr+O#SF.Usec);   call CONV.SFTIME.TO.STR(loc(addr(cur.sec)),                           string,                           Read.Object(ptr+O#SF.Maxl),                           Read.Object(ptr+O#SF.Maxr));   call Pad.String(string,a.sp,Read.Object(ptr+O#Trans.Width));   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   return Get.Simple.Token(ptr,string);end GET.SOUND.FILE.TIME;FETCH.SOUND.FILE.TIME: proc(id,out.time) public swapable;   dcl id       fixed;   dcl out.time array;   if Locate.Object(id) then do;      out.time(0) = Read.Object(Object.Ptr+O#SF.Sec);      out.time(1) = Read.Object(Object.Ptr+O#SF.Msec);      out.time(2) = Read.Object(Object.Ptr+O#SF.usec);   end;   else do;      out.time(0) = 0;      out.time(1) = 0;      out.time(2) = 0;   end;end FETCH.SOUND.FILE.TIME;JOG.SOUND.FILE.TIME: proc(ptr,mx,my) public swapable;   dcl ptr         fixed;   dcl (mx,my)     fixed;    /* Mouse jog done at these coordinates */   dcl sf.time (2) fixed;    /* Current sound file time value       */   dcl amount      fixed;    /* Amount to jog each field            */   dcl id          fixed;    /* Object ID                           */   dcl width       fixed;    /* Total width of the object           */   dcl (maxl,maxr) fixed;    /* Max chars left/right of decimal     */   dcl tx          fixed;    /* Transparent mode version of mx      */   dcl num.chars   fixed;    /* Moused at this # chars into string  */   dcl string (30) fixed;    /* String returned: CONV.SFTIME.TO.STR */   dcl pbuf (2)    fixed;    /* Field parsing buffer                */   dcl sf.delta(2) fixed;    /* Alter this by one jog               */   dcl field       fixed;    /* Which field the user is jogging     */   dcl f           fixed;    /* How many fields were found          */   dcl (i,j)       fixed;   amount = 0;   if Last.Event.Info = Mou#Left.Down   or Last.Event.Info = Mou#Left.Up   then amount = -1;                   /* Left => jog down */   else if Last.Event.Info = Mou#Right.Down   or Last.Event.Info = Mou#Right.Up   then amount = 1;                    /* Right => jog up */   if amount <> 0 then do;             /* It was an outside mouse button */      id = Read.Object(ptr + O#ID);      call Fetch.Sound.File.Time(id,sf.time);      maxl  = Read.Object(ptr+O#SF.Maxl);      maxr  = Read.Object(ptr+O#SF.Maxr);      width = Read.Object(ptr + O#Trans.Width);      call Conv.Sftime.To.Str(sf.time,string,maxl,maxr);      call pad.string(string,a.sp,width);      /* Now parse string to find fields; store breaks in pbuf */      do i=0 to string(0)-1;        /* Look through the whole string */         if byte(string,i) = dot    /* Find field separator (.) */         or (byte(string,i) = a.sp  /* Or first space after (.) */         and f = 1)         then do;            pbuf(f) = i;            /* Remember where the field break is */            f = f + 1;         end;      end;      pbuf(f) = string(0);          /* Last field goes to end of string */      tx = tpos.x(mx);              /* Get jog position in characters */      num.chars = tx - (Read.Object(ptr + O#Trans.Col));      if num.chars < 0 then num.chars = 0;      do i=2 to 0 by -1;              /* Get field number being jogged */         if num.chars < pbuf(i)         then field = i;              /* Last (lowest) of these is it */      end;      call blockset(sf.delta,3,0);    /* Jog one field of this by one */      if amount < 0                   /* Trying to go below zero? */      then do;         j = 0;         do i=0 to field;             /* Search all MSB's down to jog field */            if sf.time(i) > 0            then j = 1;               /* If any of them > 0, we can borrow, if necessary */         end;         if j=0 then do;              /* None > 0, we can't go down any more! */            call Write.Event.Queue(Get.Screen.Event,S#JogAttempt,id);            return;                   /* Bail out */         end;      end;      sf.delta(field) = sf.delta(field) + 1;      if amount > 0 then call ADD.SF.TIME(sf.time,sf.delta,sf.time);      else               call SUB.SF.TIME(sf.time,sf.delta,sf.time);      call Deposit.Sound.File.Time(id,sf.time);      call Update.Sound.File.Time(ptr);   end;   else call Write.Event.Queue(Get.Screen.Event,S#JogAttempt,id);end JOG.SOUND.FILE.TIME;