/* SMG-FIXP $TITLE  Fixed Point Routines   Modified:   08/08/88 - cj  - disallow jog of fixed point items to minus                    values unless cf#signed is set.   06/18/88 - cj  - removed point.in.object check in jog.fixed.point   11/24/87 - MWH - Add editing of existing strings to token routine   11/17/87 - MWH - Split into 2 libraries; SMGR is too big   11/10/87 - MWH - Make jogging work in tables   11/05/87 - MWH - Add separate jogging for digits each side of decimal   10/26/87 - MWH - Fix bugs in jogging   10/20/87 - MWH - Screen.Changed, Update, Exhibit, Enable USED CONSISTENTLY   10/14/87 - MWH - Use new mouse button event literals   10/01/87 - MWH - Make unreferenced procedures NON-public   09/25/87 - MWH - Use literals for suffix lengths   */Define.Fixed.Point: proc (id,TRow,TCol,chars,decimal,format) public swapable;   dcl id           fixed;   dcl (ULX,ULY)    fixed; /* graphics region info */   dcl (LRX,LRY)    fixed;    dcl (TCol,Trow)  fixed; /* Transparent position info */   dcl decimal      fixed; /* decimal point position */   dcl chars        fixed; /* width of field in chars */   dcl format       fixed; /* Format word in TFORMMOD style */   Id = Allocate.Id(Id);   /* keep system info up to date, possibly auto allocate id */   If Allocate.New.Object(O#Hlen+O#FIXP.Size) then do;      call Write.Object(Object.Ptr + O#Type,  O$Fixed.Point);      call Write.Object(Object.Ptr + O#Status,O#STAT.Update);      call Write.Object(Object.Ptr + O#ULX,   gpos.x(TCol*100));      call Write.Object(Object.Ptr + O#ULY,   gpos.y(TRow*100)+gpix.y(100));      call Write.Object(Object.Ptr + O#LRX,   gpos.x(TCol*100)+gpix.x(chars*100));      call Write.Object(Object.Ptr + O#LRY,   gpos.y(TRow*100));      call Write.Object(Object.Ptr + O#Id,    Id);      call Write.Object(Object.Ptr + O#Action,Default.Action\O#ACT.Jog.Enabled);      if (Default.Action&O#ACT.RealTime.Object)<>0      then Any.RealTime.Objects=Any.RealTime.Objects+1;      call Write.Object(Object.Ptr + O#Attr,  Default.Attr);      call Write.Object(Object.Ptr + O#ObjectGets,Get#In.Char);      call Write.Object(Object.Ptr + O#Trans.Row,TRow);  /* Trans Row */      write(mdi) = TCol;          /* Trans column */      write(mdi) = chars;         /* Field width */      write(mdi) = decimal;       /* Position of decimal point */      call Write.Object(Object.Ptr + O#FIXP.Format,format);      call Write.Object(Object.Ptr + O#JogAmount,1);      Screen.Changed = true;      return Id;                     /* return allocated Id to user */   end;   else return 0;end Define.Fixed.Point;Update.Fixed.Point: proc (ptr) public swapable; /* redraws value in field of object if different from displayed value */   dcl ptr           fixed; /* ptr to object to update */   dcl i             fixed;   dcl status        fixed;   dcl string (40)   fixed;   dcl disp.value    fixed;   dcl disp.point    fixed;   dcl cur.value     fixed;   dcl cur.point     fixed;   dcl width         fixed;   dcl format        fixed;   dcl RT            boolean;   /* true if object is more real-time */   RT     = (Read.Object(Ptr+O#Action)&O#ACT.RealTime.Object);   status = Read.Object(ptr+O#Status);   /* Read object status bits */   if (status & O#STAT.Enable) = 0       /* Object may not be drawn on screen */   then do;                              /* Just turn off update bit */      call Write.Object(ptr+O#Status,(Status & NOT(O#STAT.Update)));      return;   end;   if (RT<>0) then call Run.Syn.Loop;    /* Keep real time code going */   disp.point = Read.Object(ptr+O#FIXP.Disp.DP);   cur.point  = Read.Object(ptr+O#FIXP.DP);   if ((status and O#STAT.Update) <> 0)    or ( disp.point <> cur.point) then do;      disp.value = Read.Object(ptr+O#FIXP.Disp.Value);      cur.value  = Read.Object(ptr+O#FIXP.Value);      width      = Read.Object(ptr+O#Trans.Width);      format     = Read.Object(ptr+O#FIXP.Format);      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call cpos(Read.Object(ptr+O#Trans.Row),Read.Object(ptr+O#Trans.Col)); /* Position trans cursor */      call Set.Term.Obj.Attr(ptr);      call CONV.FIXED.TO.STR(cur.value,cur.point,width,format,string);      call pad.string(string,a.sp,width);      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call ps(string);      if Disable.Attr.Reset=0 then do;         call Set.Term.Attr(ATTR#Normal);      end;      /* Copy values just displayed into object's display record */      call Write.Object(ptr+O#FIXP.Disp.DP,cur.point);       call Write.Object(ptr+O#FIXP.Disp.Value,cur.value);      call Write.Object(ptr+O#Status,(Status&not(O#STAT.Update\O#STAT.Disp.Attr.Set))                        \(O#STAT.Exhibit\shl(status&O#STAT.Attr.Set,1)));      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */   end;end Update.Fixed.Point;DEPOSIT.FIXED.POINT: proc(id,value) public swapable; /* stores new value in object */   dcl id            fixed;   dcl value         fixed;   dcl ptr           fixed;   dcl RT            boolean;   /* true if object is more real-time */   dcl old.value     fixed;   dcl status        fixed;   if Locate.Object(id) then do;      ptr = Object.Ptr;      status = Read.Object(ptr + O#Status);      RT  = (Read.Object(Ptr+O#Action)&O#ACT.RealTime.Object);      old.value = Read.Object(ptr+O#FIXP.Value);      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */      call Write.Object(ptr+O#FIXP.Value,value);  /* write new value into it */      if (status & O#STAT.Exhibit) = 0          /* Object never displayed... */      or (value <> old.value)                   /* ...or value changed */      then do;         if (RT<>0) then call Run.Syn.Loop;     /* Keep real time code going */         call Write.Event.Queue(Get.Screen.Event,S#Deposit,id);         if Check.Update.On.Deposit(ptr) <> 0         then call Update.Fixed.Point(ptr);     /* Do update right now */      end;      if (RT<>0) then call Run.Syn.Loop; /* keep real time code going */   end;end DEPOSIT.FIXED.POINT;GET.FIXED.POINT: proc (ptr) returns (fixed) public swapable;   dcl ptr         fixed;   dcl event       fixed;   dcl width       fixed;   dcl string (40) fixed;   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   width = Read.Object(ptr+O#Trans.Width);   call CONV.FIXED.TO.STR(Read.Object(ptr+O#FIXP.Value),                          Read.Object(ptr+O#FIXP.DP),                          width,                          Read.Object(ptr+O#FIXP.Format),                          string);   call pad.string(string,a.sp,width);   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   event=Get.Simple.Token(ptr,string);   if (Any.RealTime.Objects<>0) then call Run.Syn.Loop;   return event;end GET.FIXED.POINT;FETCH.FIXED.POINT: proc(id) returns (fixed) public swapable;   dcl id    fixed;   dcl item  fixed;   if Locate.Object(id) then do;      return Read.Object(Object.Ptr+O#FIXP.Value);   end;   else return 0;end FETCH.FIXED.POINT;JOG.FIXED.POINT: proc (ptr,mx,my) public swapable;   dcl ptr         fixed;   dcl (mx,my)     fixed;    /* Mouse jog done at these coordinates */   dcl fixp        fixed;    /* Current fixed point value           */   dcl amount      fixed;    /* Amount to jog each field            */   dcl id          fixed;    /* Object ID                           */   dcl dp          fixed;    /* Decimal point position              */   dcl width       fixed;    /* Total width of the object           */   dcl tx          fixed;    /* Transparent mode version of mx      */   dcl num.chars   fixed;    /* Moused at this # chars into string  */   dcl string (30) fixed;    /* String returned by CONV.FIXED.TO.STR*/   dcl pbuf (2)    fixed;    /* Field parsing buffer                */   dcl field       fixed;    /* Which field the user is jogging     */   dcl f           fixed;    /* How many fields were found          */   dcl i           fixed;   dcl format      fixed;   amount = Read.Object(ptr + O#JogAmount);   if Last.Event.Info = Mou#Left.Down   or Last.Event.Info = Mou#Left.Up   then amount = -amount;              /* Left => jog down */   else if not (Last.Event.Info = Mou#Right.Down   or Last.Event.Info = Mou#Right.Up)  /* Right => jog up */   then amount = 0;                    /* Neither, don't jog */   if amount <> 0 then do;             /* It was an outside mouse button */      id = Read.Object(ptr + O#ID);      fixp   = Read.Object(ptr + O#FIXP.Value);      dp     = Read.Object(ptr + O#FIXP.DP);      width  = Read.Object(ptr + O#Trans.Width);      format = Read.Object(ptr + O#FIXP.Format);      call Conv.Fixed.To.Str(fixp,dp,width,format,string);      call pad.string(string,a.sp,width);      /* Now parse string to find fields; store breaks in pbuf */      do i=0 to string(0)-1;        /* Look through the whole string */         if byte(string,i) = dot    /* Find field separator (.) */         then do;            pbuf(f) = i;            /* Remember where the field break is */            f = f + 1;         end;      end;      pbuf(f) = string(0);          /* Last field goes to end of string */      tx = tpos.x(mx);              /* Get jog position in characters */      num.chars = tx - (Read.Object(ptr + O#Trans.Col));      if num.chars < 0 then num.chars = 0;      do i=1 to 0 by -1;              /* Get field number being jogged */         if num.chars < pbuf(i)         then field = i;              /* Last (lowest) of these is it */      end;      if f=0                          /* One field... */      or ((f=1) and (field=1))        /* ...or two fields but doing decimal */      then do;                        /* Right of decimal, or no decimal */         fixp = fixp + amount;        /* Simple jog */      end;      else do;                        /* Jogging left of decimal */         do i=1 to dp;            amount = amount * 10;     /* amount = amount * (10 ** dp) */         end;         fixp = fixp + amount;        /* Jog upper portion of number */      end;      if  (amount < 0)                 /* if minus value              */      and ((format & cf#signed) = 0)   /* but not allowed             */      then amount = 0;                 /* leave at 0.000              */      call Deposit.Fixed.Point(id,fixp);      call Update.Fixed.Point(ptr);   end;   else call Write.Event.Queue(Get.Screen.Event,S#JogAttempt,id);end JOG.FIXED.POINT;