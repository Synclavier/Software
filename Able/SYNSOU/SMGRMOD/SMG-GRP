/* SMG-GRP  $TITLE  Object Group Manager   Modified:   04/14/89 - SGS - Added DUMP.GROUPS and LOCATE.GROUP procedures   11/13/87 - MWH - Split into 2 libraries; SMGR is too big   09/25/87 - MWH - Use literals for suffix lengths   */dcl Group.Base           fixed external;     /* Abs Sector ptr to base of group info */dcl Group.Ptr            fixed external;     /* ptr to next group to process */dcl New.Group.Ptr        fixed external;     /* ptr to groups defined while an event is still being processed */dcl Num.Object.Groups    fixed external;     /* current number of groups */dcl Max.Group.Id         fixed external;     /* current max allocated id */DUMP.GROUPS: proc public swapable;   dcl This.Ptr     fixed;   call Set.Term.Attr(ATTR#Normal);   call cpos(23,0);   call tty_wait;   disable;   print;   print 'Dumping screen manager groups';   if Num.Object.Groups=0 then print 'There are no groups defined';   This.Ptr = 0;   do while This.Ptr ILT (Num.Object.Groups*G#BlkLen);      write(mam)=Group.Base+shr(This.Ptr+G#Id,8);      write(mal)=This.Ptr+G#Id;      print;      print 'Group Id#', read(mdi);      print 'Low Id =', read(mdi), '  High Id =', read(mdi);      This.Ptr=This.Ptr+G#BlkLen; /* step to next group block */   end;   enable;   call tty_wait;end DUMP.GROUPS;COMPUTE.MAX.GROUP.ID:  proc; /* recomputes Max.Group.Id */   dcl i fixed;   max.group.id=0;   do i=0 to num.object.groups-1;      write(mam)=Group.Base+shr(i*G#BlkLen+G#Id,8);      write(mal)=i*G#BlkLen+G#Id;      if read(md) igt max.group.id then max.group.id=read(md);   end;end COMPUTE.MAX.GROUP.ID;GROUP.OBJECTS:  proc (id,low.obj,high.obj,obj.gbits) returns (fixed) public swapable;   dcl id                 fixed; /* id to assign to this group */   dcl (low.obj,high.obj) fixed; /* range of object ids to put in this group */   dcl obj.gbits          fixed; /* bits for GETs this groups cares about (see GETLITS) */   dcl base               fixed;   if ((num.object.groups+1)*G#BlkLen) igt Group.Max.Length   then return 0; /* out of room */   if low.obj igt high.obj then do;  /* put ids into order */      base    =low.obj;              /* swap the two values */      low.obj =high.obj;      high.obj=base;   end;   if id=S#AutoAllocate then do;     /* auto allocate a group id */      max.group.id=max.group.id+1;   /* use next higher */      id=max.group.id;   end;   else do;      if id IGT max.group.id        /* keep max id up to date */      then max.group.id=id;   end;   /* If in the midst of processing some event, don't let Group.Ptr */   /* see new groups until it's done processing the event.          */   if (Group.Ptr<>0) and (New.Group.Ptr=0) then      New.Group.Ptr=num.object.groups*G#BlkLen;   num.object.groups=num.object.groups+1; /* save one more group record */   base=(num.object.groups-1)*G#BlkLen;       /* ptr to new group block */   write(mam)=Group.Base+shr(base,8); /* write out new group block */   write(mal)=base;   write(mdi)=Id;   write(mdi)=Low.Obj;   write(mdi)=High.Obj;   write(md )=Obj.Gbits;   return id;                        /* return id allocated for this group */end GROUP.OBJECTS;UNGROUP.OBJECTS:  proc (id) returns (fixed) public swapable; /* removes group of objects from group list */   dcl id       fixed; /* id of window to close */   dcl shuffled boolean;   dcl (base,i) fixed;   i=0; shuffled=false;   do while (not shuffled) and (i ILT num.object.groups);      base=i*G#BlkLen+G#Id;      write(mam)=Group.Base+shr(base,8);      write(mal)=base;      if read(md)=id then do;          /* delete this group block */         shuffled=true;         num.object.groups=num.object.groups-1;         if Group.Ptr igt i*G#BlkLen then            Group.Ptr=Group.Ptr-G#BlkLen; /* in midst of processing an event */         if New.Group.Ptr igt i*G#BlkLen then             New.Group.Ptr=New.Group.Ptr-G#BlkLen; /* in midst of processing an event */         if i<>num.object.groups       /* not deleting last group block */         then call Copy.Ext.Mem(Group.Base,(i+1)*G#BlkLen,Group.Base,i*G#BlkLen,(num.object.groups-i)*G#BlkLen);      end;      i=i+1;   end;   call Compute.Max.Group.Id;  /* recompute max id */   if shuffled                 /* we were able to delete the group */   then return 0;   else return Id;             /* couldn't do delete?? */end UNGROUP.OBJECTS;SET.GROUP.GET: proc (Id,WhichGet,Setting) public swapable;   dcl Id       fixed;   /* Id of a defined group */   dcl WhichGet fixed;   /* pass a "GET" code (i.e., Get.Screen.Event,Get.Mouse.Movement) */   dcl Setting  boolean; /* true to set bit, false to reset bit */   dcl (i,ptr)  fixed;   /* temps */   if WhichGet igt 16 then return;        /* only supports 1st 16 "GET" bits */   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;           /* this is our group (Just skipped over G#ID) */         write("324") = read(mdi);       /* Skip over G#LOW  */         write("324") = read(mdi);       /* Skip over G#HIGH */         /* now pointing at G#BITS word */         if Setting         then write(md)=read(md) \      Bits(WhichGet-1);  /* turn bit on  */         else write(md)=read(md) & (not Bits(WhichGet-1)); /* turn bit off */         return;                         /* all done */      end;      i=i+1;   end;end SET.GROUP.GET;ERASE.GROUP.OBJECTS: proc (id) public swapable;   dcl id         fixed;   dcl (i,ptr)    fixed;   /* temps */   dcl (low,high) fixed;   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;            /* this is our group (Just skipped over G#ID) */         low  = read(mdi);                /* Skip over G#LOW  */         high = read(mdi);                /* Skip over G#HIGH */         call Erase.Object.Range(low,high);         return;                         /* all done */      end;      i=i+1;   end;end ERASE.GROUP.OBJECTS;UNDEFINE.GROUP.OBJECTS: proc (id) public swapable;   dcl id         fixed;   dcl (i,ptr)    fixed;   /* temps */   dcl (low,high) fixed;   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;            /* this is our group (Just skipped over G#ID) */         low  = read(mdi);                /* Skip over G#LOW  */         high = read(mdi);                /* Skip over G#HIGH */         call Undefine.Object.Range(low,high);         return;                         /* all done */      end;      i=i+1;   end;end UNDEFINE.GROUP.OBJECTS;DISABLE.GROUP.OBJECTS: proc (id) public swapable;   dcl id         fixed;   dcl (i,ptr)    fixed;   /* temps */   dcl (low,high) fixed;   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;            /* this is our group (Just skipped over G#ID) */         low  = read(mdi);                /* Skip over G#LOW  */         high = read(mdi);                /* Skip over G#HIGH */         call Disable.Object.Range(low,high);         return;                         /* all done */      end;      i=i+1;   end;end DISABLE.GROUP.OBJECTS;ACTIVATE.GROUP.OBJECTS: proc (id) public swapable;   dcl id         fixed;   dcl (i,ptr)    fixed;   /* temps */   dcl (low,high) fixed;   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;            /* this is our group (Just skipped over G#ID) */         low  = read(mdi);                /* Skip over G#LOW  */         high = read(mdi);                /* Skip over G#HIGH */         call Activate.Object.Range(low,high);         return;                         /* all done */      end;      i=i+1;   end;end ACTIVATE.GROUP.OBJECTS;UPDATE.GROUP.OBJECTS: proc (id) public swapable;   dcl id         fixed;   dcl (i,ptr)    fixed;   /* temps */   dcl (low,high) fixed;   i=0;    do while (i ILT num.object.groups);   /* loop through all groups */      ptr=i*G#BlkLen;                    /* compute offset to next group */      write(mam) = Group.Base+shr(ptr,8);      write(mal) = ptr;      if read(mdi)=Id then do;            /* this is our group (Just skipped over G#ID) */         low  = read(mdi);                /* Skip over G#LOW  */         high = read(mdi);                /* Skip over G#HIGH */         call Update.Object.Range(low,high);         return;                         /* all done */      end;      i=i+1;   end;end UPDATE.GROUP.OBJECTS;LOCATE.GROUP: proc (object.id) returns (fixed) public swapable;   dcl object.id   fixed;  /* object whose group we're trying to find */   dcl grp.ptr     fixed;   dcl group.id    fixed;   grp.ptr = 0;   do while grp.ptr ILT (Num.Object.Groups*G#BlkLen);      write(mam)=Group.Base+shr(grp.ptr+G#Id,8);      write(mal)=grp.ptr+G#Id;      group.id=read(mdi);                 /* get group id # */      /* see if object is in range of our group */      if  (object.id >= read(mdi)) /* G#LOW  */      and (object.id <= read(md))  /* G#HIGH */      then do;         return group.id;          /* found one */      end;      else grp.ptr=grp.ptr+G#BlkLen; /* step to next group block */   end;end LOCATE.GROUP;