.bpage.ceSection 1 -- Introduction.te 'Section 1 -- Introduction.ttext ''.space 2.center~USING THE SCREEN MANAGER~.te '   USING THE SCREEN MANAGER.fillThe screen manager is a collection of routines which allow a programmer to define and control objects on a computer terminal.The current implementation supports the two terminal types that areused by New England Digital customers, the DEC/RG VT640 and the Pericom MG-600..spaceIt is strongly recommended that the screen manager be used for allnormal user-interfaces in the Synclavier.  This will present customerswith a consistent set of screen objects and standard ways of interactingwith them that don't change from one screen to the next.  It is ~much~ easier to develop and maintain code using the screen manager than to attempt to address the terminal directly..spacePrograms using the screen manager will generally divide into two sections: definition and operation.  In the definition stage, objects of various types are specified and added to a list of all objects which are to appear on the screen.  During the operation stage, objects which need updating are displayed, mouse and keyboard activity are monitored, and codes are returned to the host program indicating user activity..spaceThe basic skeleton of this organization looks like this in XPL:.nfill         call Initialize.Screen.Manager(TRD.LEN);   /* Definition */         /* Define.Objects */         call Activate.Screen;         call Mouse.Init;         do while 1;                                /* Operation  */            /* enable for events */            code = Get.Next.Screen.Event;            /* disable for events */            /* process code */         end;.fillThe definition stage is where the layout of the screen takes place.  UsingDEFINE procedures the host program builds a list of objects which are toappear on the screen.  The DEFINE procedures provide for the basic specificationof an object.  Other definition and SET procedures allow modificationsto be made after an object is created..spaceWhen definition is complete, the screen is activated using the ACTIVATE.SCREEN(object#) procedure.  Activate.Screen enables all normal objects for operation, while disabling some special objects.  Activate.Screen also sets the Current Object to the object passed..spaceThe Current Object is the object into which all input goes until anotherobject is selected.  Objects can be selected by the mouse or thekeyboard, or by the host program..spaceAfter activation, if it is to be used, the mouse needs to be intialized.  This is accomplished by calling MOUSE.INIT which is part of MOUSEMOD.  If no mouse is connected to the system (D40Q or D44) or the mouse is not configured (D44 only) then Mouse.Init does not enable mouse operation and no mouse cursor will be seen on the screen..spaceOnce everything is initialized, operation begins.  Operation is typically confined to a loop.  The loop consists of a call to Get.Next.Screen.Event, which returns a code, and the processing of the code..spaceGet.Next.Screen.Event is the main processing procedure for the screen manager.It updates the screen, maintains the Current Object, and responds tomouse and keyboard events, filtering and returning them to the caller..spaceGet.Next.Screen.Event gets its event information from Get.Next.Event (in GETMOD), which monitors the entire system, tracking terminal, mouse, and Synclavier activity.  Any events returned by Get.Next.Event which are unrelated to the screen, such as Synclavier events, are passed through the screen manager.  Other events that the screen manager mayuse but are not of the type "Get.Screen.Event" will also be passed through, if the calling routine has enabled them somehow. (See below.).bpage.center~EVENTS~.te '   EVENTSTo specify which events are to come back from Get.Next.Screen.Event, the host program must use the GET_ENABLE procedure (in GETMOD).  The set of events which can be enabled are defined in GETLITS.  To see any events from the screen manager the call would be:.nfill           call GET_ENABLE(Get.Screen.Event);.fillIt is good practice to place the GET_ENABLE and GET_DISABLE statementsimmediately around the Get.Next.Screen.Event calls.  GET_DISABLE shouldnever be called without a previous GET_ENABLE of the same event..ne 21Whenever a Get.Screen.Event code comes back from Get.Next.Screen.Event a number of global variables are set up:.nfill           Screen.Event.Code       - A copy of the code returned by                                     Get.Next.Screen event.  This                                     global is set up even if the                                     code returned is not a                                     Get.Screen.Event.           Screen.Event.Info       - A further description of the                                     screen event.           Screen.Event.Id         - The Current Object at the time                                     of the event.           Screen.Event.Group      - The group which contains this                                     object (or zero if not in a                                     group).           Screen.Event.Table.Col  - If Screen.Event.Id is the ID of a                                     table, these two variables           Screen.Event.Table.Row  - indicate which item (cell) of the                                     table it is..fillScreen.Event.Info contains a further description of the screen event.  If Screen.Event.Code is equal to "Get.Screen.Event", then Screen.Event.Info will specify which kind of screen event was generated.  Each of these values have literals defined in :SYNAUXS:SMGRLITS as follows:.nfill                                         General Events       S#NulEvent           - Nothing really happened       S#ObjectTerminate    - Finished with this object; go to next       S#KeyActivate        - User activated object with the keyboard       S#MouseActivate      - User activated object with the mouse       S#MouseSelect        - A new object was selected with mouse       S#ArrowSelect        - A new object was selected with arrows       S#ArrowSelectAttempt - Attempted to select, but no link set       S#ObjectEvent        - Special object event       S#ProgramExit        - Break key was pressed       S#Deposit            - User finished entering a field       S#ObjectDrag         - Object dragged and dropped on another       S#ObjectDragAbort    - Object dragged and dropped on nothing       S#JogAttempt         - Attempted to increment object value       S#DelAttempt         - Attempted to delete object    Scroll Bar Events       S#SBArrow            - User clicked back arrow       S#SBArrowBack        - User clicked back arrow       S#SBArrowForward     - User clicked forward arrow       S#SBPage             - User clicked in page back region       S#SBPageBack         - User clicked in page back region       S#SBPageForward      - User clicked in page forward region       S#SBBoxMove          - User moved the box.need 12Some typical event sequences might look as follows:.nfill            USER CLICKS AN OBJECT        First Event: If the user had typed anything into the current                     object before the click, the screen manager would                     deposit that value and return a deposit code.                     Screen.Event.Id would contain the id of the                     object deposited.                           GET.NEXT.SCREEN.EVENT = Get.Screen.Event                           SCREEN.EVENT.INFO     = S#Deposit                           SCREEN.EVENT.ID       = Fixed Point id.ne 10       Second Event: Next the screen manager would return a mouse                     select code indicating that a new current object                     had been selected.  Screen.Event.Id would contain                     the id of the new object:                           GET.NEXT.SCREEN.EVENT = Get.Screen.Event                           SCREEN.EVENT.INFO     = S#MouseSelect                           SCREEN.EVENT.ID       = New Object id.ne 12    USER TYPES IN A FIELD AND PRESSES RETURN          Only Event:  The screen manager would return a deposit code                        indicating the user had finished entering a                       field.  Screen.Event.Id would contain the Id                       of the object which was deposited.                           GET.NEXT.SCREEN.EVENT = Get.Screen.Event                           SCREEN.EVENT.INFO     = S#Deposit                           SCREEN.EVENT.ID       = Fixed Point id.fillAfter Get.Next.Screen.Event returns its code, the host program can processit.  This is the time when the host program can do what it has to do.During this time, the screen manager is essentially disabled.  Objectsettings are frozen so manipulation can be done without worry of conflicts..spaceHowever, because the screen manager ~is~ disabled, all screen activity stopsuntil Get.Next.Screen.Event is called again.  Processing of codes should takeplace as fast as possible..nfill.bpage.center~OBJECTS~.te '   OBJECTS.fillA screen created using the screen manager is built using objects.  Thescreen manager supports a variety of object types..space.ne 15All objects have several things in common:.nfill     Id          - A unique number given to each object for                   identification.  This number must be > 0     Region      - A rectangular area defined in graphics coordinates                   used for detecting mouse activity over an object     Status      - Several flags indicating how the object is displayed     Action      - Several flags indicating how input to the object                   should be treated     Attributes  - Two sets of attributes which define how the object                   looks when selected and when not selected     Arrow Links - Pointers to objects above, below, left, and right                   for use when users press arrow keys.fillId is set up during definition of an object and cannot be changed.  Region, status, action, attributes, and arrow links are set to default values during definition but can be changed later during screen operation using SET procedures..spaceThe default settings for attributes and action are as follows:.nfill     Attribute Set 0      - Normal: White text on black background       (Unselected)     Attribute Set 1      - Reverse: Black text on white background       (Selected)     Action               - Middle mouse button press selects object                           .fillThese defaults can be changed by two procedures, SET.DEFAULT.ATTR andSET.DEFAULT.ACTION.  These procedures can be called between definitions allowing objects to have different defaults..spaceSet.Default.Attr takes literal arguments defined in TTYLITS.  These literals can be ORed for different combinations.  A set (0 or 1) must be specified when setting the attributes.  In the screen manager, set 0 is the unselected state for an object and set 1 is the selected state..nfill        SET.DEFAULT.ATTR (set,attr) where attr is:           ATTR#Normal          - All attributes off or regular state           ATTR#Reverse         - Reverse video on           ATTR#NoReverse       - Reverse video off           ATTR#RegIntensity    - Regular video intensity           ATTR#AltIntensity    - Alternate video intensity           ATTR#Blink           - Blinking on           ATTR#NoBlink         - Blinking off           ATTR#Underline       - Underline on           ATTR#NoUnderline     - Underline off.fill.need 6Set.Default.Action takes the following literals from SMGRLITS.  The value passed to Set.Default.Action ~overwrites~ the previous value, so a complete action specification must be made in each call.  These literals can be ORed for different combinations.  All general actions default to off; mouse select actions default to a middle button press..nfill   SET.DEFAULT.ACTION (action) where action is:      ~General Actions~            O#ACT.Prev.Obj            - When Get.Object is finished with an                                  object, this action causes the screen                                  manager to select the object of the                                  previous Get.Object (used on switches                                  and scroll bars so they don't repeat                                  forever).      O#ACT.Update.On.Dep       - Update.On.Deposit: causes the deposit                                  routine to automatically update an                                  object when a new value is deposited                                  to it.      O#ACT.Drag.Enabled        - Object may be dragged.      O#ACT.Drag.Type Check     - Object may only be dropped on another                                  of the same type.      O#ACT.Animate.Disabled    - Don't allow animation of the object.      O#ACT.Deposit.Rept.Disabled-Don't report deposit events for                                  this object (even if they occur).      O#ACT.RealTime.Object     - Do RUN.SYN.LOOP calls during update                                  of this object.      O#ACT.Get.Disabled        - Disable all gets.      O#ACT.Jog.Enabled         - Object may be (in)(de)cremented by                                   mouse buttons      O#ACT.POAct.Changed       - Manipulation for tables of switches            ~Mouse Select Actions~      O#ACT.Left.Press          - Select on press of Left button      O#ACT.Middle.Press        - Select on press of Middle button      O#ACT.Right.Press         - Select on press of Right button                                 O#ACT.Left.Release        - Select on release of Left button      O#ACT.Middle.Release      - Select on release of Middle button      O#ACT.Right.Release       - Select on release of Right button.fill.spaceArrow links are id numbers of other objects.  These specify which object should be selected when the user presses an arrow key.  Object arrow links all default to null pointers (0) but can be set after defining an object by calling SET.OBJECT.ARROW.LINKS.  This procedure takes five arguments.  Above, below, left, and right specify the object id numbers for the up, down, left, and right arrow keys respectively.  An id of 0 specifies that no object should be selected.  Passing the literal ARR##Auto (=-2) in place of a directional id means that the computer should check for the closest object in that direction.  The intuitiveness of this feature is directly proportional to the tabularity and uniformity of the screen being built.  The computer will only consider objects that satisfy four properties: 1) They must be enabled, 2) They must be accessible with the mouse, 3) They must have an arrow link out, as well, and 4) They must be in transparent mode..nfill       SET.OBJECT.ARROW.LINKS (id#,above,below,left,right).fillOther operations to objects are detailed in Section 4 under "OBJECTRE-DEFINITION (SET) PROCEDURES".