.bpage.fo '3) INDIVIDUAL OBJECT ROUTINES'-#-'SCREEN MANAGER.ttext ''.ceSection 3 -- Individual Object Routines.te 'Section 3 -- Individual Object Routines.ttext ''.space 2.center~OBJECT TYPE DESCRIPTIONS~.te '   OBJECT TYPE DESCRIPTIONSFollowing are detailed descriptions of the different object types supported by the screen mananger.  Each one describes the object and all procedures associated with it.  Routines which are general to all objects are listed later in the section, ~General Object Routines~.  All procedure arguments are presumed to be "fixed" unless otherwise stated.Every object is assigned a unique ID number which is always used to refer to it.  ID numbers may only be in the range of 1 to 32767.  Each type of object is created with a DEFINE.XXX procedure.  When defining objects, you have the choice of passing in an ID number which you choose, or letting the system pick one for you.  Each of the DEFINE procedures below has a first argument of "id#".  If you wish to select your own ID number, you pass it to the DEFINE procedure.  If you want the system to select a number, pass the literal "S#AutoAllocate" (or "S#AA"), and the procedure will return the ID number it has assigned to that object.  You must then save this value for any future references to the object.Note: Beware of mixing auto allocation with manual assignment!  The system will always choose a number larger than the highest ID used SO FAR.  Therefore, if you are going to mix manual and automatic assignment, do the manual ones FIRST and you will be guaranteed unique ID's..bpage.center.ttext ''~TRANSPARENT REGION~.te '   TRANSPARENT REGIONA transparent region is a rectangular area on the screen sensitive to mouseclicks.  It is defined by two corners of the ~transparent mode~ display.Transparent mode is ~character~ display mode (as opposed to graphics).A Transparent Region serves only to report mouse activity in a rectangular area.  A Transparent Region cannot accept input or be updated or erased.The origin (0,0) is in the top left corner of the screen.  Thesecoordinates are given as (row,column).  On a VT640, the maximum value is (23,79) and on a Pericom it is (24,79).  Note that the ANSII terminalstandard calls for an origin of (1,1), but the screen manager adjuststhis to (0,0) for its purposes..ne 12.nfill     (ulrow,ulcol)                (ulrow,lrcol)           +----------------------------+           |                            |           |                            |           |                            |           |                            |           |                            |           +----------------------------+     (lrrow,ulcol)                (lrrow,lrcol).fill.ne 13.st {.te '      DEFINE.TRANSPARENT.REGION.ix 'DEFINE.TRANSPARENT.REGION\DEFINE.TRANSPARENT.REGION (id#,ulrow,ulcol,lrrow,lrcol) - Creates atransparent region.  Returns the ID if successful, otherwise 0..bu {\id# - Object identifier\ulrow - Upper left row\ulcol - Upper left column\lrrow - Lower right row\lrcol - Lower right column.bu }.st }.bpage.center.ttext ''~GRAPHICS REGION~.te '   GRAPHICS REGIONA graphics region is a rectangular area on the screen sensitive to mouse clicks.  It serves only to report mouse activity in a rectangular area.  It cannot accept input or be updated or erased.  A graphics region is defined by two corners of the ~graphics mode~ display in device dependent coordinates.The origin (0,0) is the lower left corner of the screen.  On a VT640,the maximum coordinate values at the top right are (640,480).  On thePericom terminal, they are (1024,780).  These coordinates are given as (x,y) where x is horizontal and y is vertical.  Note that the relative positioning of text and graphics differ on the two types of terminals..ne 12.nfill       (ulx,uly)                    (lrx,uly)           +----------------------------+           |                            |           |                            |           |                            |           |                            |           |                            |           +----------------------------+       (ulx,lry)                    (lrx,lry).fill.ne 13.st {.te '      DEFINE.GRAPHICS.REGION.ix 'DEFINE.GRAPHICS.REGION\DEFINE.GRAPHICS.REGION (id#,ulx,uly,lrx,lry) - Creates a graphicsregion.  Returns the ID if successful, 0 otherwise..bu {\id# - Object identifier\ulx - Upper left x coordinate\uly - Upper left y coordinate\lrx - Lower right x coordinate\lry - Lower right y coordinate.bu }.ne 14.te '      SET.GRAPHICS.REGION.ix 'SET.GRAPHICS.REGION\SET.GRAPHICS.REGION (id#,ulx,uly,lrx,lry) - Changes the selection region for a graphics object without changing its position on the screen.  Returns a 1 if successful, 0 otherwise..bu {\id# - Object identifier\ulx - Upper left x coordinate\uly - Upper left y coordinate\lrx - Lower right x coordinate\lry - Lower right y coordinate.bu }.st }.bpage.center.ttext ''~GRAPHICS BUTTON TABLE~.te '   GRAPHICS BUTTON TABLEA graphics button table is a special graphics region divided into different "buttons" which are sensitive to mouse presses.  These items are available ~only~ on the MG600 terminal.  The button table is defined as a graphics region.  Mouse presses are mapped (by the user) into row and column using the "MAP.GRAPHICS.BUTTON.TABLE.MOUSE.PRESS" routine below.  The interior of the table can be filled with dividers if desired.  Note that the coordinates are specified using (TRANSPARENT MODE COORDINATES * 100)..ne 20.st {.te '      DEFINE.GRAPHICS.BUTTON.TABLE.ix 'DEFINE.GRAPHICS.BUTTON.TABLE\DEFINE.GRAPHICS.BUTTON.TABLE (id#,ulx,uly,lrx,lry,cols,rows,bits) -Creates a graphics button table.Returns the ID if successful, 0 otherwise..bu {\id# - Object identifier\ulx - Upper left x coordinate (all in tchar * 100 units)\uly - Upper left y coordinate\lrx - Lower right x coordinate\lry - Lower right y coordinate\cols - Number of columns to create\rows - Number of rows to create\bits - Control bits, which can be:.bu {\Zero - Don't divide table\O#GBTAB.Divide - Divide table into cells with hatches.bu }.bu }.ne 24.te '      DEPOSIT.GRAPHICS.BUTTON.TABLE.LABEL.ix 'DEPOSIT.GRAPHICS.BUTTON.TABLE.LABEL\DEPOSIT.GRAPHICS.BUTTON.TABLE.LABEL (id#,row,col,size,s1,s2) -Deposits a graphics string label in a graphics button table.  This convenient routine constructs a 1 or 2 row button label in one cell of a graphics button table.  BE SURE TO COPY THE STRINGS TO A DYNAMIC ARRAY BEFORE CALLING THIS ROUTINE!  Procedure is a no-op if id# doesnot exist; no value is returned..bu {\id# - Object identifier\row - Row of table (0 = top) to deposit into\col - Col of table (0 = left) to deposit into\size - Character size to use:.bu {\0 - Smallest character set\1 - "Number 3 character set" in the Pericom\2 - "Number 2 character set" in the Pericom\3 - Largest character set.bu }\s1 - String #1\s2 - String #2 (May be null '' if only a one row label).bu }.ne 18.te '      MAP.GRAPHICS.BUTTON.TABLE.MOUSE.PRESS.ix 'MAP.GRAPHICS.BUTTON.TABLE.MOUSE.PRESS\MAP.GRAPHICS.BUTTON.TABLE.MOUSE.PRESS (id#,cell) - The following routine is provided to map the most recent mouse press into a row and column of a graphics button table.  It is most comonly called when the object of the table is selected.  Returns 1 if id# is found, 0 otherwise.  The row and column are returned in "colinfo"..bu {\id# - Object identifier\cell - FIXED ARRAY, defined by the caller to hold the return value whichis the cell selected:.nfill.in +3cell(0) = Columncell(1) = Row.in -3.fill.bu }.ne 22.te '      HIGHLIGHT.GRAPHICS.BUTTON.TABLE.ENTRY.ix 'HIGHLIGHT.GRAPHICS.BUTTON.TABLE.ENTRY\HIGHLIGHT.GRAPHICS.BUTTON.TABLE.ENTRY (id#,col,row,state,gap,code) -This routine is used to highlight or box an entry in a graphics button table.  It can highlight a region (ie: area fill in complementmode) or draw a box around a region (sub-highlight).  The pixel gap is used to control the size of the highlighting box and is a gap between the edge of the cell and box/highlight area.  The procedureis a no-op if id# is not found, or if row or col are out of range;no value is returned..bu {\id# - Object identifier\col - Col of table (0 = left) to highlight\row - Row of table (0 = top) to highlight\state - 1 = highlight; 0 = normal\gap - Number of pixels to use for the gap\code - 0 = fill; 1 = box.bu }.ne 23.te '      HIGHLIGHT.GRAPHICS.BUTTON.TABLE.ix 'HIGHLIGHT.GRAPHICS.BUTTON.TABLE\HIGHLIGHT.GRAPHICS.BUTTON.TABLE (id#,newbits,gap,code) - This is a convenient routine to highlight up to 16 elements of a graphics button table according to the passed bit pattern in "newbits".  The routine can HIGHLIGHT a cell (in complement mode) or it can draw an interior box.  Pass 1's in NEWBITS for every cell that should be highlighted or have a box.  The procedure is a no-op if id# is not found; no value is returned..bu {\id# - Object identifier\newbits - 16 bits telling which cells to highlight (fill) or box.The LSB is the top left cell; then, moving toward the MSB each bitcorresponds to all columns across the first row, then the second row,and so forth until the last or 16th cell, whichever comes first.\gap - Number of pixels to use for the gap\code - 0 = fill; 1 = box.bu }.st }.bpage.center.ttext ''~FRAME~.te '   FRAMEA frame is a box drawn in ~transparent mode~ graphics characters with a title centered in the top line of the box.  A frame with no title is drawn as a box.  A frame cannot be selected by the mouse or with arrow keys..nfill.ne 12       (row,col)                    (row,col+width)           +----------| Title |----------+           |                             |           |                             |           |                             |           |                             |           |                             |           +-----------------------------+    (row+depth,col)              (row+depth,col+width).ne 13.fill.st {.te '      DEFINE.FRAME.ix 'DEFINE.FRAME\DEFINE.FRAME (id#,row,col,depth,width,title) - Creates a frame.Returns the ID on success, or 0 on failure..bu {\id# - Object identifier\row - Character row of the top left corner\col - Character column of the top left corner\depth - Character height of the box\width - Character width of the box\title - FIXED ARRAY, title string.bu }.st }.bpage.center.ttext ''~GRAPHICS BOX~.te '   GRAPHICS BOXA graphics box is a box drawn in ~graphics mode~.  There are two types of boxes: flat and raised.  Raised boxes have two extra lines drawn on the right and bottom edges which make the box appear to have three-dimensions.  A graphics box cannot be selected by the mouse or with arrow keys..nfill.ne 12       (ulx,uly)                    (lrx,uly)           +----------------------------+           |                            |           |                            |           |                            |           |                            |           |                            |           +----------------------------+       (ulx,lry)                    (lrx,lry).ne 13.fill.st {.te '      DEFINE.GRAPHICS.BOX.ix 'DEFINE.GRAPHICS.BOX\DEFINE.GRAPHICS.BOX (id#,ulx,uly,lrx,lry,type) - Creates a graphicsbox.  Returns the ID if successful, otherwise 0..bu {\id# - Object identifier\ulx - Upper left x coordinate\uly - Upper left y coordinate\lrx - Lower right x coordinate\lry - Lower right y coordinate\type - 0 = Flat, 1 = Raised.bu }.st }.bpage.center~LABEL~.ttext ''.te '   LABELA Label is an alpha-numeric string displayed in ~transparent mode~.  Itcan be up to 80 characters long.Labels can be selected with the mouse or with arrow keys.  If the userpresses <RETURN> while on a selected object a special code S#KeyActivateis returned instead of S#Deposit.Labels can be made into buttons by setting the Return To Previous Objectbit of the Action word.  In this mode, labels will return S#MouseActivatewhen clicked and then return to the object which was selected before theclick on the Label.A label can also be set so that it is not selectable by the mouse by doing SET.OBJECT.MOUSE.ACCESS(label_id,0).  This may be used to create a line of informational text on the screen..ne 17.st {.te '      DEFINE.LABEL.ix 'DEFINE.LABEL\DEFINE.LABEL (id#,row,col,width,label) - Creates a label.  Returns the ID if successful, 0 otherwise..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the total width of the object in transparentmode characters.  Passing width a 0 causes width to be set tothe length of the passed label.\label - FIXED ARRAY, a string containing the initial contents of the label.  It can be set to nul ('') if width has a positive value..bu }.ne 14.te '      DEPOSIT.LABEL.ix 'DEPOSIT.LABEL\DEPOSIT.LABEL (id#,label) - Changes a label to be a new string of text.  Labels passed which are longer than the defined width of the label are truncated.  If O#ACT.Update.On.Dep is set then updating occurs immediately..bu {\id# - Object identifier\label - FIXED ARRAY, a string containing the new contents of the label.  It can be set to nul ('') if width has a positive value..bu }.ne 12.te '      FETCH.LABEL.ix 'FETCH.LABEL\FETCH.LABEL (id#,string) - Returns the current value of a label.Will return a null string if a bad id# is passed..bu {\id# - Object identifier\string - FIXED ARRAY, a pointer to an array provided by the callerto hold the value of the string.  No size checking is done, so thearray must be declared large enough..bu }.st }.bpage.center~STRING~.ttext ''.te '   STRINGA String is an editable sequence of characters displayed in ~transparent mode~.  It can be up to 80 characters long.Strings are selectable with the mouse or arrow keys and accept input ofall printable characters.  Filenames, treenames, and pitches are threespecial types of strings which can be set up to cause syntax checking tobe done and thereby limit user input to the string.  Like labels, a string will return a S#KeyActivate instead of an S#Deposit if a return is hit, providing that no other keys have been hit..ne 27.st {.te '      DEFINE.STRING.ix 'DEFINE.STRING\DEFINE.STRING (id#,row,col,width,type) - Creates a string which is a fixed-length field for the user to type characters into.  Returns the ID if successful, otherwise 0..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the total width of the object in transparentmode characters.  Width is also the maximum number of characters allowed in the string.\type - What kind of input is valid for the string.  The following literals from SMGRLITS are valid:.bu {\O#STR.General - General string; all alpahnumeric characters\O#STR.Pitch - Synclavier pitch name (i.e. C#3) A-G, digits, small f, and # are valid; lower case is converted to caps\O#STR.Treename - XPL treename (i.e. W0:SYNSOU:SMGRMOD)All letters, digits, .#$^():"' valid; lower case is converted to caps\O#STR.Filename - XPL filename (i.e. SMG-STR)All letters, digits, .#$^()"' valid; lower case is converted to caps.bu }.bu }.ne 11.te '      DEPOSIT.STRING.ix 'DEPOSIT.STRING\DEPOSIT.STRING (id#,string) - Makes string the current value of the object id#.  Strings passed which are longer than the defined width of the string are truncated..bu {\id# - Object identifier\string - FIXED ARRAY, a string containing the new contents..bu }.ne 13.te '      FETCH.STRING.ix 'FETCH.STRING\FETCH.STRING (id#,string) - Retrieves the current value of object and places it in passed array string.  If the object specified byid# does not exist, then a null string is returned..bu {\id# - Object identifier\string - FIXED ARRAY, a pointer to an array provided by the callerto hold the value of the string.  No size checking is done, so thearray must be declared large enough..bu }.st }.bpage.center~GRAPHICS STRING~.ttext ''.te '   GRAPHICS STRINGA Graphics String is the ~graphics mode~ version of a string.  It has the extra ability to display strings in the different character fonts and magnifications available in VT640 and MG600 alpha mode.  (Note thatonly the normal size is available in the current version of the screenmanager).  Graphics strings are slower than transparent mode strings.  To redraw a string the screen manager must first undraw the previous string..ne 47.st {.te '      DEFINE.GRAPHICS.STRING.ix 'DEFINE.GRAPHICS.STRING\DEFINE.GRAPHICS.STRING (id#,x,y,width,set,mag,type) - Creates a graphics string which is a fixed-length graphics field for the user to type characters into.  Returns the ID of the string or a 0 on failure..bu {\id# - Object identifier\x - Specifies the ~graphics mode~ "x" position of the string.\y - Specifies the ~graphics mode~ "y" position of the string.Note that these coordinates specify the lower left corner of the firstcharacter relative to (0,0) at the lower left corner of the screen.  The VT640 and MG600 have different resolutions, so the proper coordinates must be calculated for each!  Terminal independent values may be found by using two conversion routines from transparent coordinates:.nfill.indent +3x = gpos.x(100 * col);y = gpos.y(100 * row);.indent -3.fill\width - Specifies the maximum number of graphics mode charactersallowed in the string.\set - Specifies the character set to use.  The VT640 hasone character set (use arg of "1") while the MG600 has four:.bu {\0 - Smallest character set\1 - "Number 3 character set" in the Pericom\2 - "Number 2 character set" in the Pericom\3 - Largest character set.bu }\mag - Specifies the hardware character magnification.  On both theVT640 and MG600 four magnifications are available.  THIS ARGUMENT IS IGNORED; THE FEATURE IS NOT YET IMPLEMENTED.\type - Specifies what kind of input is valid for the string.  Thefollowing literals from SMGRLITS are valid:.bu {\O#GSTR.General - General string; all characters\O#GSTR.Pitch - Synclavier pitch name (i.e. C#3)A-G, digits, small f, and # are valid; lower case is converted to caps\O#GSTR.Treename - XPL treename (eg: W0:SYNSOU:SMGRMOD)All letters, digits, .#$^():"' valid; lower case is converted to caps\O#GSTR.Filename - XPL filename (eg: SMG-STR)All letters, digits, .#$^()"' valid; lower case is converted to caps.bu }.bu }.ne 12.te '      DEPOSIT.GRAPHICS.STRING.ix 'DEPOSIT.GRAPHICS.STRING\DEPOSIT.GRAPHICS.STRING (id#,string) - Makes string the current value of the object id#.  Strings passed which are longer than the defined width of the graphics string are ignored.  If the object"id#" can't be found, the procedure is a no-op..bu {\id# - Object identifier\string - FIXED ARRAY, a string containing the new contents..bu }.ne 16.te '      FETCH.GRAPHICS.STRING.ix 'FETCH.GRAPHICS.STRING\FETCH.GRAPHICS.STRING (id#,string) - Retrieves the current value of object and places it in passed array string.  The string passed must be at least as long as the defined width of the object.  If the object specified by id# does not exist, then a null string is returned..bu {\id# - Object identifier\string - FIXED ARRAY, a pointer to an array provided by the callerto hold the value of the string.  No size checking is done, so thearray must be declared large enough..bu }.st }.bpage.center~FIXED POINT~.ttext ''.te '   FIXED POINTA Fixed Point object is a 16-bit signed or unsigned integer.  Althougha Fixed Point is stored as a 16-bit integer a decimal point can be specifiedwhich will cause a decimal point to be displayed in the number simulatinga real number..ne 30.st {.te '      DEFINE.FIXED.POINT.ix 'DEFINE.FIXED.POINT\DEFINE.FIXED.POINT (id#,row,col,width,decimal,format) - Creates a fixedpoint number field.  Returns the ID of the object on success and 0otherwise..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the character width of the object.\decimal - Specifies the number of digits to be printed afterthe decimal point.  Decimal of 0 means no decimal point.\format - Specifies how the object is to appear within its         field. The following literals from TFORMLIT can be ORed fordifferent combinations..nfill~Literal       Meaning                Example~       <---field--->cf#unsigned   unsigned value         No decimal    <12345      >                                     Decimal 3     <12.345     >cf#signed     signed value           No decimal    <-12345     >                                     Decimal 3     <-12.345    >cf#left       left  justify output   Above are cf#leftcf#right      right justify output   No decimal    <      12345>                                     Decimal 3     <     12.345>cf#zerofill   fill with zeroes       cf#left       <12345000000>                                     cf#right      <00000012345>.bu }.fill.ne 11.te '      DEPOSIT.FIXED.POINT.ix 'DEPOSIT.FIXED.POINT\DEPOSIT.FIXED.POINT (id#,value) - Places value (word) into the object specified.  If O#ACT.Update.On.Dep is set then updating occurs immediately.  Procedure is a no-op if id# can't be found..bu {\id# - Object identifier\value - New fixed point number to deposit.bu }.ne 10.te '      FETCH.FIXED.POINT.ix 'FETCH.FIXED.POINT\FETCH.FIXED.POINT (id#) returns (fixed) - Returns the 16-bit ~current~ value of the object.  Returns a 0 if the object can'tbe found..bu {\id# - Object identifier.bu }.st }.bpage.center~SWITCH~.ttext ''.te '   SWITCHA Switch is a group of several labels, one of which can be displayed ata time to form a "choose one of n" option on the screen.  Which label is shown can be controlled by the mouse or by the host program.  A switch has an integer value representing which position the switch is currently in.  Zero represents the "left-most" value, and it counts up(1, 2, 3...) from there.The default mouse access for a switch is only the middle button.  The middle button causes the switch to animate.  A box is drawn around the switch and as the user moves the mouse back and forth on the x axis the switch positions change in real time.  When the user releases the middle button a screen event, S#Deposit, is passed to the host program.  The setting of the switch may then be read bycalling FETCH.SWITCH.The left and right buttons, if enabled, cause the switch to move one position backward or forward respectively.  Switches may also be accessed by arrow keys.  While on the switch, the user may press the space bar to step through the values in ascending order, wrapping when the highest is reached.  The user may also type in the number of the switch position desired, where 1 is the first setting..ne 17.st {.te '      DEFINE.SWITCH.ix 'DEFINE.SWITCH\DEFINE.SWITCH (id#,row,col,width,format,switch) - Creates a switchand enables actions O#ACT.Prev.Obj, O#ACT.Animate.Disabled, O#ACT.Left.Press, O#ACT.Middle.Press, O#ACT.Right.Press, plus any otherdefault actions set by the user.  Returns the ID of the switch, or a 0 on failure..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the character width of the object.\format - Not defined yet.\switch - FIXED ARRAY, specifies the switch settings.  It is a string array which takes the form:.in +3'Position1|Position2|Position3|....|PositionN'.in -3.bu }.ne 13.te '      DEPOSIT.SWITCH.ix 'DEPOSIT.SWITCH\DEPOSIT.SWITCH (id#,position) - Causes the switch to move to the passed position.  Switch positions begin at 0.  If a value is specifiedwhich is too low or too high, the switch will be set to 0 or themaximum value, respectively.  If the object id# can't be found, theprocedure does nothing..bu {\id# - Object identifier\position - Which switch position to select.bu }.ne 11.te '      DEPOSIT.SWITCH.FIELD.ix 'DEPOSIT.SWITCH.FIELD\DEPOSIT.SWITCH.FIELD (id#,position,field) - Changes the text string of oneposition in a switch.  Returns TRUE on success, FALSE on failure..bu {\id# - Object identifier\position - Which switch position to change.\field - FIXED ARRAY, new string of characters to use for the positionspecified..bu }.ne 9.te '      FETCH.SWITCH.ix 'FETCH.SWITCH\FETCH.SWITCH (id#) - Returns the current position of the switch.  Itreturns 0 if the id# can't be found..bu {\id# - Object identifier.bu }.st }.bpage.center~32-BIT MILLISECOND TIME~.ttext ''.te '   32-BIT MILLISECOND TIMEA 32-Bit Millisecond object is 32-bit number representing approximately 50 days in milliseconds.  Different display formats allow the milliseconds to be displayed as milliseconds, seconds, SMPTE, Feet/Frames, beats, or measures and beats.The times can also be displayed as durations for compatability withthe Synclavier program..ne 13.st {.te '      DEFINE.32BIT.MSEC\DEFINE.32BIT.MSEC (id#,row,col,width,format,type,maxl,maxr)- Creates a 32-bit millisecond object.  Returns the ID of theobject if successful, otherwise 0..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the character width of the object..ne 14\format - Specifies how the object should be formatted fordisplay.  The following literals from SMGRLITS are valid:.bu {\O#MSEC.Sec.Msec - Seconds/Milliseconds\O#MSEC.Beats - Beats/Fractions of a beat\O#MSEC.Measures.Beats - Measures:Beats/Fractions of a beat\O#MSEC.SMPTE - SMPTE\O#MSEC.Feet.Frames - Feet/Frames\O#MSEC.Minutes.Seconds - Minutes:Seconds.bu }.ne 10\type - Indicates whether a value is time or a duration.  The validvalues are defined in MATHLITS:.bu {\cf#time - Number is a time (0).\cf#dur - Number is a duration (1)..bu }.ne 15\maxl - Maximum characters to the left.\maxr - Maximum characters to the right.  These last two parametersspecify how many characters can appear to the left and right of major features of the above formats.  Two literals in TFORMLIT can be used or the number of digits may be passed in each Maxl and Maxr:.bu {\cf#default  - Big enough to hold largest legal value.\cf#supress  - Field and punctuation before field supressed.\digits      - A specific number of digits to display..bu }         .ne 14For each of the display formats MaxL and MaxR have differentmappings.  L = Maxl characters, R = Maxr characters, # = not affected.         .nfill.in +3Feet/Frames.SubFrames     LLLLL/##.RRSeconds.Milliseconds      LLLLL.RRRSMPTE                     LL:LL:LL:LL.RRBeats.Fraction            LLLLL.RRRMeasures:Beats.Fraction   LLLLL:###.RRR.in -3.fill.ne 20The SMPTE, Feet/Frames, and Beats display formats require extra information for conversion.  The Screen Manager maintains a snapshot of Synclavier variables for these conversions, but if the Synclavier Real Time module is not used these variables must be set by the host program:.nfill~Variable        Description          Default~S$Click         Click rate           500S$BPM           Beats per measure    4S$Speed         Sequencer speed      1000S$SMode         SMPTE Mode           0S$SOffset (4)   SMPTE Offset         0,0,0,0,0                                     (HH,MM,SS,FF,BB)S$FMode         Feet/Frames Mode     0S$FOffest (2)   Feet/Frames Offset   0,0,0                                     (Feet,Frames,Subframes).fill.bu }.ne 19.te '      SET.32BIT.MSEC.DISPLAY.FORMAT.ix 'SET.32BIT.MSEC.DISPLAY.FORMAT\SET.32BIT.MSEC.DISPLAY.FORMAT (id#,format,type,maxl,maxr) - This routine sets display.format, maxl, and maxr for already defined objects.  On the next call to Get.Next.Screen.Event the object will be updated.  "id#" can be the ID of a whole table of 32 bit millisecondvalues as well as a single object.  There is no return value; theprocedure is a no-op if the id# can't be found.  See the descriptions (above) under DEFINE.32BIT.MSEC for details of how format, type, maxl and maxr are specified.        .bu {\id# - Object identifier\format - Specifies how the object should be formatted.\type - Indicates whether a value is time or a duration.\maxl - Maximum characters to the left.\maxr - Maximum characters to the right..bu }.ne 16.te '      DEPOSIT.32BIT.MSEC.ix 'DEPOSIT.32BIT.MSEC\DEPOSIT.32BIT.MSEC (id#,time) - Places time (array) into object id#.  If O#ACT.Update.On.Dep is set then updating occurs immediately.  The procedure is a no-op if the object id# can't be found..bu {\id# - Object identifier\time - FIXED ARRAY, the 32 bit time with elements:.nfill.in +3time(0) = MSWtime(1) = LSW.in -3.fill.bu }.ne 12.te '      FETCH.32BIT.MSEC.ix 'FETCH.32BIT.MSEC\FETCH.32BIT.MSEC (id#,time) - Retrieves the current 32-bit time from object id#.  A 32-bit zero value is returned if the id# can't be found..bu {\id# - Object identifier\time - FIXED ARRAY, with 2 elements defined by the user.  A 32-bit value is returned into this array with the same format used inDEPOSIT.32BIT.MSEC, above..bu }.st }.bpage.center~32-BIT SMPTE~.ttext ''.te '   32-BIT SMPTEA 32 bit SMPTE object is a SMPTE time displayed in transparent mode characters.  The SMPTE format used is the one currently set in the Synclavier; the routine CONV.SMPTE.TO.STR is used to build the printable string from the 32-bit quantity..ne 14.st {.te '      DEFINE.32BIT.SMPTE.ix 'DEFINE.32BIT.SMPTE\DEFINE.32BIT.SMPTE (id#,row,col,width) - Defines a SMPTE field andreturns the ID if successful, otherwise 0..bu {\id# - Object identifier\row - Row in transparent mode coordinates.\col - Column in transparent mode coordinates.\width - Specifies the total width of the object in transparentmode characters..bu }.ne 14.te '      DEPOSIT.32BIT.SMPTE.ix 'DEPOSIT.32BIT.SMPTE\DEPOSIT.32BIT.SMPTE (id#,time) - Puts a 32bit SMPTE time into object.Procedure is a no-op if id# is undefined..bu {\id# - Object identifier\time - FIXED ARRAY, a standard Synclavier 32-bit SMPTE quantity..nfill   time(0) => msw   time(1) => lsw.fill.bu }.ne 14.te '      FETCH.32BIT.SMPTE.ix 'FETCH.32BIT.SMPTE\FETCH.32BIT.SMPTE (id#,out.time) - Returns the current value of a 32-bitSMPTE bit number.  The value returned is 32 bits of zeros if id# isnot defined..bu {\id# - Object identifier\time - FIXED ARRAY, an array declared by the caller to hold thevalue returned.  It must be at least two words (32 bits) long..nfill   out.time(0) => MSW   out.time(1) => LSW.fill.bu }.st }.bpage.center~SOUND FILE TIME~.ttext ''.te '   SOUND FILE TIMEA Sound File Time is a three word record containing seconds, milliseconds,and microseconds.  It has one display format but can be controlled usingthe maxl and maxr parameters..ne 29.st {.te '      DEFINE.SOUND.FILE.TIME.ix 'DEFINE.SOUND.FILE.TIME\DEFINE.SOUND.FILE.TIME (id#,row,col,width,maxl,maxr) - Creates asound file time field.  Returns the ID of the created object on success, otherwise, 0..bu {\id# - Object identifier\row - Location in transparent mode coordinates.\col - Location in transparent mode coordinates.\width - Specifies the character width of the object.\maxl - Characters to the left.\maxr - Characters to the right.  Maxl and Maxr specify how many characters can appear to the left and right of major features of the above formats.  Two literals from TFORMLIT can be used or the number of digits may be passed in each Maxl and Maxr:.bu {\cf#default - Big enough to hold largest legal value.\cf#supress - Field and punctuation before field supressed.\digits - A specific number of digits to display..bu }         Maxl and Maxr map to the Sound File format as follows (L => Maxl;R => MaxR):.in +3LLLLL.RRR RRR.in -3.bu }.ne 16.te '      DEPOSIT.SOUND.FILE.TIME.ix 'DEPOSIT.SOUND.FILE.TIME\DEPOSIT.SOUND.FILE.TIME (id#,time) - Places time (array) into object id#.  If O#ACT.Update.On.Dep is set then updating occurs immediately..bu {\id# - Object identifier\time - FIXED ARRAY, with elements:.nfill.in +3time(0) = Secondstime(1) = Millisecondstime(2) = Microseconds.in -3.fill.bu }.ne 13.te '      FETCH.SOUND.FILE.TIME.ix 'FETCH.SOUND.FILE.TIME\FETCH.SOUND.FILE.TIME (id#,time) - Retrieves the current sound file time from object id#.  Three zero words are returned if the id# can't be found..bu {\id# - Object identifier\time - FIXED ARRAY, with 3 elements defined by the user.  A 3-wordvalue is returned into this array with the same format used inDEPOSIT.SOUND.FILE.TIME, above..bu }.st }.bpage.center~SCROLL BAR~.ttext ''.te '   SCROLL BARA Scroll Bar is a graphic position indicator usually associated with text or other data which is too large to be displayed on the screen at once.  Scroll bars can be oriented horizontally and vertically.A box which slides back and forth in a slide-region of the scroll barindicates a current value.  This value can be used to position otherdata on the screen.The box can be moved by the mouse or the host program.  The box's positionis specified in percentages of the length of the scroll bar.Two regions with arrow icons at each end of the scroll bar can be clicked by the mouse.  These cause return codes, indicating the user wishes to scroll forward or backward.  The regions on either side of the sliding box are also sensitive.  They return codes indicating theuser wishes to page in one direction or the other.Scroll bars can be active or inactive.  Active scroll bars can be positioned by the mouse or by the host.  Inactive scroll bars have no box or scroll-region displayed (just the shell and scroll arrows) and cannot be positioned.A scroll bar may be drawn horizontally or vertically:.nfill             O#SBAR.Orient.Hor                   O#SBAR.Orient.Ver.space 22.fill.ne 36.st {.te '      DEFINE.SCROLL.BAR.ix 'DEFINE.SCROLL.BAR\DEFINE.SCROLL.BAR (id#,orient,just,edge,left.top,right.bottom)- Creates a scroll bar.  Returns the ID of the created object onsuccess or 0 otherwise..bu {\id# - Object identifier\orient - Specifies the orientation of the bar..bu {\O#SBAR.Orient.Hor - Horizontal scroll bar.\O#SBAR.Orient.Ver - Vertical scroll bar..bu }\just - Specifies which side of the scroll bar the next paramenter,edge, refers to.  "just" can take the values:.bu {\Horizontal Orientation.nfillO#SBAR.Just.Top    - Top side of the barO#SBAR.Just.Bottom - Bottom side of the bar.fill\Vertical Orientation.nfillO#SBAR.Just.Left   - Left side of the barO#SBAR.Just.Right  - Right side of the bar.fill.bu }\edge - Specifies the graphics mode position of the justified edge of the scroll bar.  Which edge this is depends upon justification and orientation, described above.  Note that graphicscoordinates start at (0,0) in the lower left corner of the screenand differ between the VT640 and the MG600.\left.top specifies the graphics mode position of the left edge of the bar for horizontal bars and the top edge for vertical bars\right.bot specifies the graphics mode position of the right edge of the bar for horizontal bars and the bottom edge for vertical bars.bu }.ne 10.te '      ACTIVATE.SCROLL.BAR.ix 'ACTIVATE.SCROLL.BAR\ACTIVATE.SCROLL.BAR (id#,position) - Puts the scroll bar passed into the active state.  If id# can't be found, the procedure is a no-op..bu {\id# - Object identifier\position - Where the box is placed in (percentage * 10); (0 to 1000)..bu }.ne 11.te '      DEACTIVATE.SCROLL.BAR.ix 'DEACTIVATE.SCROLL.BAR\DEACTIVATE.SCROLL.BAR (id#) - Puts the scroll bar passed into the inactive state.  The box and scroll-region are erased.  The shell of the bar and the arrows at each end are not erased.  If the id# can'tbe found, the procedure does nothing..bu {\id# - Object identifier.bu }.ne 13.te '      DEPOSIT.SCROLL.BAR.ix 'DEPOSIT.SCROLL.BAR\DEPOSIT.SCROLL.BAR (id#,position) - Causes the box in the scroll-region to move the specified position.  The procedure doesnothing if the id# is invalid..bu {\id# - Object identifier\position - Where the box is placed (in percentage * 10; 0 to 1000)..bu }.ne 10.te '      FETCH.SCROLL.BAR.ix 'FETCH.SCROLL.BAR\FETCH.SCROLL.BAR (id#) - Returns the current position of the scroll bar.  Returns 0 if the scroll bar is inactive, or if an invalid id#is passed..bu {\id# - Object identifier.bu }.ne 22.te '      SET.SCROLL.BAR.BITS.ix 'SET.SCROLL.BAR.BITS\SET.SCROLL.BAR.BITS (id#,bit,setting) - Sets or clears a bit in the scrollbar data structure: "O#SBAR.Bits".  A no-op if the id# is invalid; noreturn value..bu {\id# - Object identifier\bit - Which bit to set or clear, take from the list:.nfill.in +3O#SBAR.Bits.OrientO#SBAR.Bits.JustO#SBAR.Bits.StateO#SBAR.Bits.Disp.StateO#SBAR.Bits.Box.StateO#SBAR.Bits.Real.Time.in -3.fill\setting - If TRUE, will set "bit"; if FALSE, will clear..bu }.ne 20.te '      SET.SCROLL.BAR.FILL.PATTERN.ix 'SET.SCROLL.BAR.FILL.PATTERN\SET.SCROLL.BAR.FILL.PATTERN (id#,pattern) - Changes the scroll barfill pattern; has an effect on the MG600 only (NOT on the VT640).  Notethat the empty fill pattern is used to indicate an inactive scroll bar.This procedure is a no-op if the id# is non-existent..bu {\id# - Object identifier\pattern - A number specifying the MG600 pattern to use:.nfill.in +3~  Pattern    Result~          0  Default: Same as #10 (\\\; 4 pixels) 1, 2, 3, 4  Horizontal lines spaced 2,4,8 or 16 pixels 5, 6, 7, 8  Vertical lines spaced 2,4,8 or 16 pixels 9,10,11,12  \\\ lines spaced 2,4,8 or 16 pixels13,14,15,16  /// lines spaced 2,4,8 or 16 pixels.in -3.fill.bu }.ne 19.te '      COMPUTE.SCROLL.BAR.BOX.POSITION.ix 'COMPUTE.SCROLL.BAR.BOX.POSITION\COMPUTE.SCROLL.BAR.BOX.POSITION (id#,percent) - Routine computes the pixel position that corresponds to where the center of the box would be IF the passed percent were to be deposited.   This is to facilitate doing other kinds of scroll bar animations (ie: from the audio event editor).  The return value is the pixel position of the(would-be) center of the box.  If the scroll bar is in horizontalorientation, this is an "x" position; if in vertical orientation it isa "y" position.  A 0 is returned if id# is invalid..bu {\id# - Object identifier\percent - Position of scroll bar (in percentage * 10; 0 to 1000)..bu }.st }.bpage.center~TABLE~.ttext ''.te '   TABLEA table is a two-dimensional array of any single kind of object.  Allcells in the table share the same size and characteristics.Defining a table is accomplished by first defining a "type object",(eg: a string), with a (row,col) or (x,y) position equal to the desiredposition of the upper-leftmost cell of the table.  CallingDEFINE.TABLE with the table size in cells across and down and the id#of the "type object" creates the table.The "type object" must be a valid kind of object to build a table from.  Tables may currently be built from the objects:.bu {\Label\String\Fixed Point\32 Bit Millisecond Time\32 Bit SMPTE Time\Sound File Time\Switch.bu }The "type object" used in the definition of tables is disabled by the screen manager during ACTIVATE.SCREEN and cannot be used as a normal object.  However, it is used to deposit and fetch data to and from a table.  This object will never be shown on the screen and cannot be selected by the mouse or arrow keys.Because each cell of a table is in fact an individual object, the attributes and status of each cell can be different.  Several procedures listed below allow the host program control each cell.Each table has stored with it a current cell value which indicates which cell of the table is to be gotten during a Get.Object of a table.  This current cell is set by the screen manager when users move onto or in a table with the mouse or with arrow keys.  It can also be set by calling the procedure SET.TABLE.CUR.CELL (see below).Table column and row numbering starts at 0.  The upper left elementis (col 0,row 0)..ne 14.st {.te '      DEFINE.TABLE.ix 'DEFINE.TABLE\DEFINE.TABLE (id#,across,down,type.id#) - Creates a table using the"type-object" specified by type.id#.  Returns the ID of the ~whole table~if successful, else a 0..bu {\id# - Object identifier\across - Number of cells horizontally\down - Number of cells vertically\type.id# - Specifies an ~already defined~ object id# which is usedto establish the type and initial characteristics of each cell..bu }.ne 12.te '      DEPOSIT.TABLE.ix 'DEPOSIT.TABLE\DEPOSIT.TABLE (id#,col,row) - Deposits a value stored in the "type object"in cell (col,row).  The procedure is a no-op if either the id# of thetable is non-existent, or (col,row) are outside the range of the table..bu {\id# - Object identifier\col - Column number of the cell to deposit data in\row - Row number of the cell to deposit data in.bu }.ne 13.te '      FETCH.TABLE.ix 'FETCH.TABLE\FETCH.TABLE (id#,col,row) - Retrieves the current value of cell (col,row) and places it in the "type object".  Will not change the valuesin the "type object" if the id# is invalid, puts garbage data in the typeobject if row or column is out of range..bu {\id# - Object identifier\col - Column number of the cell to get data from\row - Row number of the cell to get data from.bu }.ne 26.te '      FILL.STRING.TABLE.ix 'FILL.STRING.TABLE\FILL.STRING.TABLE (id#,col,row,order,strings) - Fills many cells of a string-type table with the strings passed in strings.  String-type tables are STRING, GRAPHICS STRING, and LABEL.  Filling begins in the cell (col,row) and will continue as long as there is data in "strings" or until the end of the table is reached.  The procedure is a no-op if row or col is out of range, if id# does not exist, or if thecells are a type other than the legal ones mentioned above..bu {\id# - Object identifier\col - Column number of the cell to start filling from\row - Row number of the cell to start filling from\order - Specifies how the fill is to proceed.  Two literalsfrom :SYNAUXS:SMGRLITS can be used:.bu {\O#TABL.Fill.Across - Fill by row\O#TABL.Fill.Down - Fill by column.bu }\strings - FIXED ARRAY, Data to use to fill the table; takes the form:.in +3'String1|String2|String3|...|StringN'.in -3.bu }.te '      ENABLE.TABLE.CELL.ix 'ENABLE.TABLE.CELL\ENABLE.TABLE.CELL (id#,col,row) - Allows a cell of a table to be displayed by turning on the O#STAT.Enable bit.  A no-op if col or row is out of bounds, or if id# does not exist..bu {\id# - Object identifier\col - Column number of the cell to enable\row - Row number of the cell to enable.bu }.ne 12.te '      DISABLE.TABLE.CELL.ix 'DISABLE.TABLE.CELL\DISABLE.TABLE.CELL (id#,col,row) - Stops a cell of a table from beingdisplayed by turning off the O#STAT.Enable bit.  A no-op if col or row is out of bounds, or if id# does not exist..bu {\id# - Object identifier\col - Column number of the cell to disable\row - Row number of the cell to disable.bu }.ne 12.te '      SET.TABLE.CUR.CELL.ix 'SET.TABLE.CUR.CELL\SET.TABLE.CUR.CELL (id#,col,row) - Set which cell will be readduring the next "get" of the table.  A no-op if id# is undefinedor if (col,row) are outside of their defined values..bu {\id# - Object identifier\col - Column number of the cell\row - Row number of the cell.bu }.ne 14.te '      FETCH.TABLE.CUR.CELL.ix 'FETCH.TABLE.CUR.CELL\FETCH.TABLE.CUR.CELL (id#,cell) - Returns the coordinates of the current cell of table id#.  If the id# is undefined, the value ofcell is unchanged..bu {\id# - Object identifier\cell - FIXED ARRAY, is defined by the user to receive the returnedcoordinates:.nfill.in +3Cell(0) = ColCell(1) = Row.in -3.fill.bu }.ne 27.te '      SET.TABLE.CELL.ATTR.ix 'SET.TABLE.CELL.ATTR\SET.TABLE.CELL.ATTR (id#,col,row,set,attr) - Programs one set of the display attributes for a particular cell.  A no-op if col or row isout of bounds, or if id# does not exist..bu {\id# - Object identifier\col - Column number of the cell to change\row - Row number of the cell to change\set - Specifies which set of attributes to change, 0 to modifythe unselected state for an object, 1 for the selected state.\attr - Which attribute to change; any of:.nfill.in +3ATTR#NormalATTR#ReverseATTR#NoReverseATTR#AltIntensityATTR#RegIntensityATTR#BlinkATTR#NoBlinkATTR#UnderlineATTR#NoUnderlineATTR#GBoxATTR#NoGBox.in -3.fill.bu }.ne 22.te '      SET.SEVERAL.TABLE.CELL.ATTR.ix 'SET.SEVERAL.TABLE.CELL.ATTR\SET.SEVERAL.TABLE.CELL.ATTR (id#,col,row,#cells,updn,set,attr) - Programs one set of the display attributes for a number of cells.  A no-op if col or row is out of bounds, or if id# does not exist.  Ifnumcells would go beyond the end of the table, updating stops at thelast defined cell..bu {\id# - Object identifier\col - Column number of the cell to change\row - Row number of the cell to change\#cells - Count of how many cells to update.\updn - If 0, fill from across from left to right; if 1, fill downfrom top to bottom.\set - Specifies which set of attributes to change, 0 to modifythe unselected state for an object, 1 for the selected state.\attr - Which attribute to change; same possible values as inSET.TABLE.CELL.ATTR, above..bu }.ne 17.te '      SET.TABLE.CELL.ATTR.SET.ix 'SET.TABLE.CELL.ATTR.SET\SET.TABLE.CELL.ATTR.SET (id#,col,row,set) - Selects which attribute set of a cell (col,row) is to be used for display.It is a no-op if id# does not exist, or if col or row is out of bounds..bu {\id# - Object identifier\col - Column number of the cell to select attribute set in\row - Row number of the cell to select attribute set in\set - Specifies which set of attributes to use, 0 for the "unselected state" attributes for the cell, 1 for the "selected state" attributes..bu }.ne 19.te '      SET.TABLE.CONTROL.BITS.ix 'SET.TABLE.CONTROL.BITS\SET.TABLE.CONTROL.BITS (id#,bit,value) - Sets or clears a bit value in O#TABL.Bits.  It is a no-op if id# does not exist..bu {\id# - Object identifier\bit - One of the following:.bu {\O#TABL.Bits.Hardware.Scroll - Enables use of hardware scrolling if bit is set and table insert is done.\O#TABL.Bits.Animate - Enables animation of cell position with mouse.\O#TABL.Bits.Refresh.Dir - Direction to draw table: 0=Top-Down, 1=Bottom-Up.\O#TABL.Bits.Wrap - Wrap to next/previous row of a table rather thanleaving if on an outside column when an arrow key is pressed toward theperimeter of the table..bu }\value - 0 means clear "bit", 1 means set it..bu }.ne 14.te '      INSERT.TABLE.ROWS.ix 'INSERT.TABLE.ROWS\INSERT.TABLE.ROWS (id#,irow,up.down,nrows) - Inserts new row into a table, possibly causing hardware scroll.  It is a no-op if id# does not exist, or if col or row is out of bounds..bu {\id# - Object identifier\irow - Number of the first new table row to insert.\up.down - If 0, shift upper rows up; if 1, shift lower rows down.\nrows - Total number of table rows to insert..bu }.ne 18.te '      MAP.POINT.TO.TABLE.CELL.ix 'MAP.POINT.TO.TABLE.CELL\MAP.POINT.TO.TABLE.CELL (x,y,id#,cell) - Takes graphics coordinatesand checks to see which table cell they contain.  Procedure is ano-op if id# is not defined or not a table; does NO checking to be surex and y are inside the table..bu {\x - Coordinate\y - Coordinate\id# - Object identifier\cell - FIXED ARRAY, is defined by the user to receive the returnedcoordinates:.nfill.in +3Cell(0) = ColCell(1) = Row.in -3.fill.bu }.st }.bpage.center~GRAPHICS ICON~.ttext ''.te '   GRAPHICS ICONA Graphics Icon is a list of drawing instructions which can be reproducedrelative to any point on the screen.  Most of the standard VT640 andMG600 drawing commands are available..ne 19.st {.te '      DEFINE.GRAPHICS.ICON.ix 'DEFINE.GRAPHICS.ICON\DEFINE.GRAPHICS.ICON(id#,x,y,region,icon) - Creates a graphics mode icon (draws an object on the screen).  Returns the ID of the object if successful, otherwise 0..bu {\id# - Object identifier\x - ~Graphics mode~ x-coordinate for the icon\y - ~Graphics mode~ y-coordinate for the icon\region - Controls the size of the selectable region for the icon; legal values are:.bu {\0 - Don't create a mouse-selectable region\1 - Use the icon area only as a selectable region\2 - Like 1, but include a margin around the icon as well.bu }.ne 38\icon - An array containing the drawing instructions and parameters for the icon. Definition of the icon is most easily accomplished by defining a data array before calling DEFINE.GRAPHICS.ICON.  Each drawing instruction in the array is followed immediately by its parameters.  The literals for the instructions and their parameters are listed below:.nfill~Instruction         Parameter(s)    Function~O#ICON.MoveTo       X, Y            Move to X,Y w/o drawingO#ICON.Plot         X, Y            Plot from last point                                      drawn to X,YO#ICON.Connect      X1, Y1, X2, Y2  Plot from X1,Y1 to X2,Y2O#ICON.AlphaString  String          Plot an alpha string at                                      the current location.                                      String is a standard                                      XPL string. O#ICON.DataLevel    Data Level      Changes data level                                      0 - Draw                                      1 - Erase                                      2 - ComplementO#ICON.LineType     Line Type       Changes line type                                      0 - Solid                                      1 - Dotted                                      See terminal manuals                                      for other typesO#ICON.Fill         Fill pattern    Floods the area at the                                      current position with                                      a fill pattern.  MG600                                      ONLY.  Takes MG600 code                                      for fill pattern.O#ICON.InsertIcon   Icon Id#        Inserts an already                                      defined icon at the                                      current position.O#ICON.End          No parameters   Marks the end of the icon..fillAll icon arrays MUST end with the instruction O#ICON.End.All (X,Y) coordinates are in character units (100 units per character)as implemented in the GPOS routines.  All (X,Y) coordinates arerelative to the base X and Y coordinates given in the definition.Negative X and Y coordinates may be given to indicate points belowand to the left of base X and Y.Drawing of the icon begins always with a MoveTo the base X,Y anda data level of 0..ne 14Here is an example data array which draws a box circumscribing a character:.nfill    dcl icon data (O#ICON.Plot, 100,   0,                   O#ICON.Plot, 100, 100,                   O#ICON.Plot,   0, 100,                   O#ICON.Plot,   0,   0,                   O#ICON.End);.fill.bu }.ce--------------------------------------------------------.ne 9The following routines call DEFINE.GRAPHICS.ICON to create a specifictype of icon.  They all set up their icon data, call DEFINE.GRAPHICS.ICONand return the value which DEFINE.GRAPHICS.ICON passes back to them (ID number on success; 0 on failure)..ne 17.te '         DEFINE.BUTTON.ICON.ix 'DEFINE.BUTTON.ICON\DEFINE.BUTTON.ICON (id#,col,row,label,style) - Creates a "button" on thescreen in graphics mode consisting of a text label with an oval drawnaround it.  Maximum length of the label inside the button is 64 characters..bu {\id# - Object identifier\col - Column in transparent-mode coordinates * 100\row - Row in transparent-mode coordinates * 100\label - FIXED ARRAY, Text string to appear in the middle of the button\style - How to draw the button: 0 means normal, with a single line around the text string; 1 means draw a double line around it..bu }.ne 14.te '         DEFINE.GRAB.ICON.ix 'DEFINE.GRAB.ICON\DEFINE.GRAB.ICON (id#,col,row) - Creates a "grab" icon on thescreen in graphics mode (looks like a small box with a V inside)..bu {\id# - Object identifier\col - Column in transparent-mode coordinates * 100\row - Row in transparent-mode coordinates * 100.bu }.ne 14.te '         DEFINE.MOUSE.HOLE.ICON.ix 'DEFINE.MOUSE.HOLE.ICON\DEFINE.MOUSE.HOLE.ICON (id#,col,row) - Creates a "mouse hole" icon on thescreen in graphics mode (looks like two small concentric squares).  Thisis usually placed at the top right corner of all Synclavier screens, atcoordinate (col=8100,row=100) - 1st row, as far right as possible..bu {\id# - Object identifier\col - Column in transparent-mode coordinates * 100\row - Row in transparent-mode coordinates * 100.bu }.ne 16.te '         DEFINE.GRID.ICON.ix 'DEFINE.GRID.ICON\DEFINE.GRID.ICON (id#,row,col,numcols,numrows,width) - Creates an open grid on the screen in graphics mode (eg: a 3 X 3 grid looks like a "#")..bu {\id# - Object identifier\row - Row in transparent-mode coordinates\col - Column in transparent-mode coordinates\numcols - Number of columns\numrows - Number of rows\width - Character width of each column.bu }.ne 14.te '         DEFINE.GRAPHICS.LABEL.ix 'DEFINE.GRAPHICS.LABEL\DEFINE.GRAPHICS.LABEL (id#,row,col,string) - Displays a stringin graphics mode.  Maximum label is 32 characters long..bu {\id# - Object identifier\row - Row in transparent-mode coordinates * 100\col - Column in transparent-mode coordinates * 100\string - FIXED ARRAY, Text string to display.bu }.st }       