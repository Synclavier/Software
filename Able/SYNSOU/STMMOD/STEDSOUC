/* $Title STEDSOUC More Sound Editor Editing Commands -> Fill, Loop, Volume, and Normalize*//*   11/18/91 - PF  - More quick update support   05/02/88 - MWH - Clean up; new crossfade algorithm for FILL (like PASTE)   04/12/88 - MWH - Preserve mark start, mark end where possible   03/01/88 - LSS - fixed word lengths in header setup (off-by-one bug)   02/12/88 - MWH - Expand crossfade times to 65.535 seconds; improve   12/14/87 - MWH - Merge poly updates with N-Final plus AEE sources   08/14/87 - MWH - Update all to support max 4 poly bins, 512mb/bin   08/07/87 - MWH - Merge with CWJ's changes   07/14/87 - MWH - new interface for PS.SETUP   03/05/87 - BSW - Started Normalize command    02/08/87 - BSW - This is part of the command routine module, STEDMOD */   /* $Subtitle Fill the Current Sound File */   dcl fill.name(4) fixed; /* fill sound file name */   GET.FILL.FILENAME:  proc(file.start) fixed swapable; /* sets global fill.name if successful */      dcl file.start fixed;       /* start of .EDITBUF or filename in token array */      dcl i          fixed;      tok.ptr=file.start;      if (tok.ptr=token(0)) then do;        /* filename not supplied */         call stm.file.format;              /* Use Time,Time,Filename Format */         return 0;      end;      return (GET.FILENAME(token,tok.ptr,fill.name));   end GET.FILL.FILENAME;   /* $Subtitle Limit Fill Crossfade Length */   FILL.CROSSFADE:  proc(fill.base,fill.time,fill.tot.time,mark.start.time,                     mark.end.time,pre.xfade.time,post.xfade.time) fixed swapable;      /* Note: returns pre and post crossfade lengths in last two args  */      /* which are pointers to arrays supplied by the caller            */      /* Also, sets (borrowed) globals paste.alt.pre and paste.alt.post */      dcl fill.base            fixed array; /* base of sound file to be filled */      dcl fill.time            fixed array; /* total time of area being filled */      dcl fill.tot.time        fixed array; /* total time available to use for fill */      dcl mark.start.time      fixed array; /* mark start time of fill file */      dcl mark.end.time        fixed array; /* mark end time of fill file */      dcl pre.xfade.time       fixed array; /* RETURNED: crossfade before fill */      dcl post.xfade.time      fixed array; /* RETURNED: crossfade after fill */      dcl mark.end.sec         fixed;       /* mark end in fill file */      dcl mark.end.wrd         fixed;            dcl post.sec             fixed;       /* piece of .EDITBUF after mark end */      dcl post.wrd             fixed;      dcl post.time(2)         fixed;      dcl end.time(2)          fixed;       /* Time after the fill */      dcl end.and.fill.time(2) fixed;       /* Fill plus the time after it */      dcl fill.end.time(2)     fixed;       /* Time past what we're using from fill file */      dcl half.fill.time(2)    fixed;       /* Half of "fill.tot.time" */      dcl zero.time(2)         fixed;       /* Left as zeroes */      dcl i                    fixed;      /* limit size of crossfade to available data */      pre.xfade.time(1) = stm.crossfade;      call time_normalize(pre.xfade.time);      call copy_time(pre.xfade.time,post.xfade.time);      call TIME_TO_INDEX(mark.end.time(0),mark.end.time(1),mark.end.time(2),stm.sample.rate,stereo);      mark.end.sec=sector.numb;     /* get address of mark end in fill file */      mark.end.wrd=sector.offset;      /* Calculate the piece of .EDITBUF after mark end */      call psmread(fill.base,SF.HDR,sf.valid.data);      write("300")=read(psd);      post.sec=read(psd);      post.wrd=read(psd);      call subtract.addresses(post.sec,post.wrd,mark.end.sec,mark.end.wrd);      post.sec=a.sec;      post.wrd=a.wrd;      call INDEX_TO_TIME(0,post.sec,post.wrd,stm.sample.rate,stereo);      post.time(0)=time.seconds;      post.time(1)=time.milliseconds;      post.time(2)=time.microseconds;      /* calculate the time of the sound file after the end of the fill */      do i=0 to 2;         end.time(i) = tot.time(i) - stm.end.time(i);      end;      call TIME_NORMALIZE(end.time);      /* calculate start of fill to the end of the sound file */      do i=0 to 2;         end.and.fill.time(i) = fill.time(i) + end.time(i);      end;      call TIME_NORMALIZE(end.and.fill.time);      /* calculate time past what we're using from fill file */      do i=0 to 2;         /* time after mark end + (total fill material - what we're using) */         fill.end.time(i) = post.time(i) + (fill.tot.time(i) - fill.time(i));      end;      call TIME_NORMALIZE(fill.end.time);      call COPY_TIME(fill.tot.time,half.fill.time);      if (half.fill.time(0) & 1) <> 0                       /* If we're about to shift off 1 sec */      then half.fill.time(1) = half.fill.time(1) + 1000;    /* Carry down 1000 msec */      do i=0 to 2;                                          /* (Don't worry about usec) */         half.fill.time(i) = shr(half.fill.time(i),1);      /* Divide by two */      end;      i=0;   /* Haven't changed crossfade time yet */      if COMPARE_TIMES(mark.start.time,zero.time,3) <> 0      then paste.alt.pre = 0;      /* Material exists on clipboard before mark start for crossfade */      else paste.alt.pre = 1;      /* Mark start at time zero; use alternate crossfade algorithm */      if COMPARE_TIMES(post.time,zero.time,3) <> 0      then paste.alt.post = 0;      /* Material exists on clipboard after mark end for crossfade */      else paste.alt.post = 1;      /* Mark end at same time as END; use alternate crossfade algorithm */      /* Material exists on clipboard before mark start for crossfade */      if paste.alt.pre = 0 then do;         /* Pre crossfade can't be longer than sound file before start of fill */         if COMPARE_TIMES(pre.xfade.time,stm.begin.time,3) > 0 then do;            call copy_time(stm.begin.time,pre.xfade.time);            i=1;         end;         /* Pre crossfade can't be longer than fill file before mark start */         if COMPARE_TIMES(pre.xfade.time,mark.start.time,3) > 0 then do;            call copy_time(mark.start.time,pre.xfade.time);            i=1;         end;      end;      /* Mark start at time zero; use alternate crossfade algorithm */      else do;         /* Pre crossfade can't be longer than sound file after fill point */         if COMPARE_TIMES(pre.xfade.time,end.and.fill.time,3) > 0 then do;            call copy_time(end.and.fill.time,pre.xfade.time);            i=1;         end;         /* Pre crossfade can't be longer than half of piece being filled */         if COMPARE_TIMES(pre.xfade.time,half.fill.time,3) > 0 then do;            call copy_time(half.fill.time,pre.xfade.time);            i=1;         end;      end;      /* Material exists on clipboard after mark end for crossfade */      if paste.alt.post = 0 then do;         /* Post crossfade can't be longer than sound file after end of fill */         if COMPARE_TIMES(post.xfade.time,end.time,3) > 0 then do;            call copy_time(end.time,post.xfade.time);            i=1;         end;         /* Post crossfade can't be longer than fill file after what we're using */         if COMPARE_TIMES(post.xfade.time,fill.end.time,3) > 0 then do;            call copy_time(fill.end.time,post.xfade.time);            i=1;         end;      end;      /* Mark end at same time as END; use alternate crossfade algorithm */      else do;         /* Post crossfade can't be longer than sound file before end of fill */         if COMPARE_TIMES(post.xfade.time,stm.end.time,3) > 0 then do;            call copy_time(stm.end.time,post.xfade.time);            i=1;         end;         /* Post crossfade can't be longer than half of piece being filled */         if COMPARE_TIMES(post.xfade.time,half.fill.time,3) > 0 then do;            call copy_time(half.fill.time,post.xfade.time);            i=1;         end;      end;      /* notify user if we change crossfade length */      if i <> 0 then do;         /* Display truncation message showing shortest crossfade */         if COMPARE_TIMES(pre.xfade.time,post.xfade.time,3) > 0         then call COPY_TIME(post.xfade.time,some.time);         else call COPY_TIME(pre.xfade.time, some.time);         tok.ptr=0;         token(0)=tok.ptr;         call CONVERT.SAMPLE.TIME.TO.STRING(some.time);  /* converts an unsigned number between 0 and 999 to a string*/         call crossfade.override;                /* tell the user */      end;      return;   end FILL.CROSSFADE;   /* $Subtitle Fill Sound File Symbols */   FILL.SYMBOLS: proc(base,mark.start.time,fill.base,fill.time,new.base) swapable;      dcl base                   fixed array; /* current sound file base */      dcl mark.start.time        fixed array;      dcl fill.base              fixed array;      dcl fill.time              fixed array; /* the time to fill */      dcl new.base               fixed array; /* base of new sound file with fill*/      dcl new_number_of_symbols  fixed;      dcl (i,j,k)                fixed;      /* fill in the new symbols */      call psmread(new.base,SF.HDR,sf.number.of.symbols);      new_number_of_symbols=read(psd);      /* include all of the symbols up to the beginning fill time */      do i=0 to 2;  /* no differences between old and new symbol times */         some.time(i)=0;      end;      i=0;      j=FIND_TIME(base,stm.begin.time);      do while (i<j) and (new_number_of_symbols<max.symbols);         new_number_of_symbols=MOVE.SYMBOL(base,new.base,i,some.time,0,1);   /* insert all of the symbols into the new sound file */         i=i+1;      end;      /* include the symbols from the end of the fill to the end of the sound file */      i=FIND_TIME(base,stm.end.time);                              /* include the symbols after the deletion time */      call GET.SAMPLE.TIME(base,endname);      j=FIND_TIME(base,some.time);                             /* include the symbols after the deletion time */      do k=0 to 2;  /* no differences between old and new symbol times */         some.time(k)=0;      end;      do while (i<j) and (new_number_of_symbols<max.symbols);         new_number_of_symbols=MOVE.SYMBOL(base,new.base,i,some.time,0,1);         i=i+1;      end;                                                     /* of if not a duplicate name */      i=FIND_TIME(fill.base,mark.start.time);      do j=0 to 2;         fill.time(j)=fill.time(j)+mark.start.time(j);      end;      call TIME_NORMALIZE(fill.time);      j=FIND_TIME(fill.base,fill.time);      do k=0 to 2;  /* map symbols to fill area */         some.time(k)=stm.begin.time(k)-mark.start.time(k);      end;      call TIME_NORMALIZE(some.time);      do while (i<j) and (new_number_of_symbols<max.symbols);         new_number_of_symbols=MOVE.SYMBOL(fill.base,new.base,i,some.time,1,0);   /* insert all of the symbols into the new sound file */         i=i+1;      end;   end FILL.SYMBOLS;   /* $Subtitle Fill Samples */   FILL.SAMPLES:  proc (base,file.start) public swapable;   /* fills the current sound file with the contents of a specifed file or .EDITBUF */      dcl base                   fixed array; /* current sound file base */      dcl file.start             fixed;       /* start of .EDITBUF or filename in token array */      dcl fill.tot.time(2)       fixed;       /* the time available for fill */      dcl fill.base (1)          fixed;       /* base of fill sound file */      dcl old.base (1)           fixed;       /* 32 bit poly base */      dcl new.base (1)           fixed;       /* base of new sound file with fill*/      dcl current.name(4)        fixed;       /* current sound file name */      dcl rate                   fixed;       /* current sound file sample rate */      dcl type                   fixed;       /* if current sound file is stereo */      dcl prev.part              fixed static;/* previous sound file partial */      dcl fill.sec               fixed;       /* number of sectors in fill */      dcl fill.wrd               fixed;       /* remaining number of words in fill*/      dcl fill.time(2)           fixed;       /* the time to fill */      dcl origin.time(2)         fixed;       /* keeper of display start time of original sound file */      dcl (begin.sec,begin.wrd)  fixed;       /* address of beginning location */      dcl (end.sec,end.wrd)      fixed;       /* addres of ending location */      dcl mark.start.time(2)     fixed;       /* mark start time of fill file */      dcl mark.start.sec         fixed;      dcl mark.start.wrd         fixed;      dcl mark.end.time(2)       fixed;       /* mark end time of fill file */      dcl pre.xfade.time (2)     fixed;       /* crossfade before fill */      dcl post.xfade.time (2)    fixed;       /* crossfade after fill */      dcl pre.crossfade          fixed;       /* before fill, in milliseconds */      dcl post.crossfade         fixed;       /* after fill, in milliseconds */      dcl (ssec1,swrd1)          fixed;       /* source 1 address for crossfade */      dcl (ssec2,swrd2)          fixed;       /* source 2 address for crossfade */      dcl (dsec,dwrd)            fixed;       /* destination address for crossfade */      dcl temp.crossfade         fixed;      dcl i                      fixed;      dcl rec(POLY.HIST.REC.LEN-1) fixed;      RECOVER.KEY.TIMBRE: proc fixed;     /* recovers current keyboard timbre and erases it from old location */         call COPY.KBD.TIMBRES(1,0);             call ERASE.TIMBRE(1);         call SELECT.PARTIAL(prev.part);  /* select the original partial    */      end RECOVER.KEY.TIMBRE;      if inc.stmm=0 then return;          /* FILL is a STM release M feature */      current.name(0)=8;                  /* find the current sound file name */      do i=1 to 4;         current.name(i)=FNBUF(i);      end;      rate=stm.sample.rate;      type=stereo;      do i=0 to 2;  /* save this for later use because look.up.sf.info changes it for other partials */         origin.time(i)=start.time(i);      end;      if GET.STM.EDIT.TIMES(base)=0   /* if no good edit times */      then return;                    /* leave */      if GET.FILL.FILENAME(file.start)=0      then return;      /* $page */      call TIME_TO_INDEX(stm.begin.time(0),stm.begin.time(1),stm.begin.time(2),stm.sample.rate,stereo); /* find the address of the beginning time */      begin.sec=sector.numb;      begin.wrd=sector.offset;      call TIME_TO_INDEX(stm.end.time(0),stm.end.time(1),stm.end.time(2),stm.sample.rate,stereo); /* find the address of the ending time */      end.sec=sector.numb;      end.wrd=sector.offset;      call subtract.addresses(end.sec,end.wrd,begin.sec,begin.wrd);      fill.sec=a.sec;      fill.wrd=a.wrd;      call INDEX_TO_TIME(0,fill.sec,fill.wrd,stm.sample.rate,stereo);      fill.time(0)=time.seconds;      fill.time(1)=time.milliseconds;      fill.time(2)=time.microseconds;      if COMPARE_TIMES(fill.time,tot.time,3)<=0 then do;  /* if the time is available */         split.keyboard=0;         prev.part=FIND.PARTIAL;         /* remember the previously selected partial in case of error */         call COPY.KBD.TIMBRES(0,1);     /* copy current keyboard timbre */         /* set up sound files on first and second partials of keyboard timbre */         call ERASE.KEYBOARD.TIMBRE;     /* get rid of timbre #0        */         call SELECT.PARTIAL(0);         /* select the first partial    */         call CREATE.PATCH.PARTIAL(0,current.name);         /* turn this partial into a patch partial*/         call SELECT.PARTIAL(1);         /* select the second partial   */         call CREATE.PATCH.PARTIAL(1,fill.name);         /* turn this partial into a patch partial*/         if ertyp<>0 then do;            call RECOVER.KEY.TIMBRE;     /* recover keyboard timbre */            return;         end;         call SELECT.PARTIAL(1);                /* select second fill sound file */         call LOOK.UP.SF.INFO;         if sf.type<>1 then do;                 /* if not a sound file     */            call COPY_TIME(origin.time,start.time);            call RECOVER.KEY.TIMBRE;            /* recover keyboard timbre */            return;         end;         if stereo<>type then do;               /* check sound file types */            call COPY_TIME(origin.time,start.time);            call RECOVER.KEY.TIMBRE;            /* recover keyboard timbre */            call incompat.sf.types;             /* must both be mono or both stereo */            return;         end;         if stm.sample.rate<>rate then do;      /* check sampling rates */            call COPY_TIME(origin.time,start.time);            call RECOVER.KEY.TIMBRE;            /* recover keyboard timbre */            call incompat.sf.rates;            return;         end;         /* $page */         call copy32(SFILE.BASE,fill.base);         call psmread(fill.base,SF.HDR,sf.mark.start);         do i=0 to 2;            mark.start.time(i)=read(psd);         end;         call TIME_TO_INDEX(mark.start.time(0),mark.start.time(1),mark.start.time(2),stm.sample.rate,stereo);         mark.start.sec=sector.numb;         mark.start.wrd=sector.offset;         call psmread(fill.base,SF.HDR,sf.mark.end);    /* look up mark end time */         do i=0 to 2;            mark.end.time(i)=read(psd);         end;         do i=0 to 2;                           /* save the total time of the fill sound file */            fill.tot.time(i)=mark.end.time(i)-mark.start.time(i);         end;         call TIME_NORMALIZE(fill.tot.time);         /* $page */         if COMPARE_TIMES(fill.time,fill.tot.time,3)<=0 then do;   /* if there is enough time to fill the spot */            call SELECT.PARTIAL(0);                    /* select the current sound file */            call LOOK.UP.SF.INFO;                      /* check if it is okay */            if sf.type<>1 then do;                     /* if not a sound file */               call COPY_TIME(origin.time,start.time);               call RECOVER.KEY.TIMBRE;                /* recover keyboard timbre */               return;            end;            call TIME_TO_INDEX(tot.time(0),tot.time(1),tot.time(2),stm.sample.rate,stereo);            if sector.offset<>0            then sector.numb=sector.numb+1;            if sector.numb igt 30000 then do;   /* not enough memory for sound file creation */               call nomem.error;               call COPY_TIME(origin.time,start.time);               call RECOVER.KEY.TIMBRE;               return;            end;            if CREATE.SOUND.FILE(sector.numb+shr(BL.POLY,8),stm.sample.rate,0,stereo)<>0 then do;  /* if we can create a sound file large enough */               call copy32(SFILE.BASE,new.base);               call SELECT.PARTIAL(0);               call LOOK.UP.SF.INFO;       /* find original sound file again */               if sf.type<>1 then do;                  call COPY_TIME(origin.time,start.time);                  call RECOVER.KEY.TIMBRE;                  return;               end;               call copy32(SFILE.BASE,old.base);               call DRAW.MESSAGE('Filling Sound File...');               call PS.LOCK;               /* lock out a reboot */               /* copy up to the beginning of the fill */               call COPY.POLY.MEM(old.base,shr(BL.POLY,8),0,new.base,shr(BL.POLY,8),0,begin.sec,begin.wrd);               /* copy the piece of the sound file after the fill */               call psmread(old.base,SF.HDR,sf.valid.data);               i=read(psd);               ssec2=read(psd);               swrd2=read(psd);               call subtract.addresses(ssec2,swrd2,end.sec,end.wrd);               ssec2=a.sec;                              /* length to copy */               swrd2=a.wrd;               ssec1=shr(BL.POLY,8)+end.sec;             /* src */               swrd1=end.wrd;               dsec=ssec1;                               /* dst */               dwrd=swrd1;                 call COPY.POLY.MEM(old.base,ssec1,swrd1,new.base,dsec,dwrd,ssec2,swrd2); /* copy the samples after the fill */               /* copy in the filled piece itself */               ssec1=shr(BL.POLY,8)+mark.start.sec;               swrd1=mark.start.wrd;               dsec=shr(BL.POLY,8)+begin.sec;               dwrd=begin.wrd;               call COPY.POLY.MEM(fill.base,ssec1,swrd1,new.base,dsec,dwrd,fill.sec,fill.wrd); /* fill her up! */               /* compute and build crossfades */               call FILL.CROSSFADE(fill.base,fill.time,fill.tot.time,mark.start.time,                     mark.end.time,pre.xfade.time,post.xfade.time);               pre.crossfade  =  (pre.xfade.time(0) * 1000) +  pre.xfade.time(1);               post.crossfade = (post.xfade.time(0) * 1000) + post.xfade.time(1);               /* do initial crossfade */               call GET.CROSSFADE.WRD.LEN(pre.crossfade,stm.sample.rate,stereo);               /* Material exists on clipboard before mark start for crossfade */               if paste.alt.pre = 0 then do;                  call subtract.addresses(begin.sec,begin.wrd,xfade.sec,xfade.wrd);                  ssec1=shr(bl.poly,8) + a.sec;     /* fade out from original data */                  swrd1=a.wrd;                  call subtract.addresses(mark.start.sec,mark.start.wrd,xfade.sec,xfade.wrd);                  ssec2=shr(BL.POLY,8) + a.sec;     /* fading in data */                  swrd2=a.wrd;                  dsec =ssec1;                  dwrd =swrd1;               end;               /* Mark start at time zero; use alternate crossfade algorithm */               else do;                  ssec1=shr(bl.poly,8) + begin.sec;           /* fading out data */                  swrd1=begin.wrd;                  ssec2=shr(bl.poly,8) + mark.start.sec;      /* fading in data */                  swrd2=mark.start.wrd;                  dsec =ssec1;                  dwrd =swrd1;               end;               call POLY.CROSS.FADE(old.base,ssec1,swrd1,fill.base,ssec2,swrd2,new.base,dsec,dwrd,pre.crossfade,stm.sample.rate,stereo);               /* do trailing crossfade */               call GET.CROSSFADE.WRD.LEN(post.crossfade,stm.sample.rate,stereo);               if paste.alt.post = 0 then do;                  ssec1 = shr(bl.poly,8) + mark.start.sec + fill.sec;                  swrd1 = mark.start.wrd + fill.wrd;                  ssec2 = shr(BL.POLY,8) + end.sec;                  swrd2 = end.wrd;                  dsec  = ssec2;                  dwrd  = swrd2;               end;               /* Mark end at same time as END; use alternate crossfade algorithm */               else do;                  call subtract.addresses((mark.start.sec + fill.sec),(mark.start.wrd + fill.wrd),xfade.sec,xfade.wrd);                  ssec1 = shr(bl.poly,8) + a.sec;                  swrd1 = a.wrd;                  call subtract.addresses(end.sec,end.wrd,xfade.sec,xfade.wrd);                  ssec2 = shr(BL.POLY,8) + a.sec;                  swrd2 = a.wrd;                  dsec  = ssec2;                  dwrd  = swrd2;               end;               call POLY.CROSS.FADE(fill.base,ssec1,swrd1,old.base,ssec2,swrd2,new.base,dsec,dwrd,post.crossfade,stm.sample.rate,stereo);               call FILL.SYMBOLS(old.base,mark.start.time,fill.base,fill.time,new.base);               call PS.SETUP(new.base);      /* set up the new file */               call PS.UNLOCK;               /* unlock poly now */               call ERASE.KEYBOARD.TIMBRE;               call COPY.KBD.TIMBRES(0,1);   /* restore the split keyboard */               call SELECT.PARTIAL(0);       /* create a patch timbre */               call CREATE.PATCH.PARTIAL(0,NEWFNAME);               call CLEAR.PARAMETERS;        /* clear all previous active parameters */               call clear.display;           /* clear the synclavier window */               call COPY_TIME(origin.time,start.time);               new.poly.contents = new.poly.contents \ 1;               call ERASE.MESSAGE;           /* erase the message */               call BUILD.POLY.HIST.REC(new.base,0,rec);   /* show a new file created */               call ADD.POLY.TO.HIST(rec);            end;         end;         else do;            call COPY_TIME(origin.time,start.time);            call no.fill.time;            call RECOVER.KEY.TIMBRE;         end;      end;      else call no.fill.time;                 /* not enough time for a fill */   end FILL.SAMPLES;  /* $Subtitle Set up loop in a sound file */   LOOP.SOUND.FILE:  proc (base,cross.start) public swapable;     /* loops the sound file between two selected points */      dcl base                   fixed array; /* current sound file base */      dcl cross.start            fixed;       /* start of crossfade in token array */      dcl (begin.sec,begin.wrd)  fixed;       /* address of beginning location */      dcl (end.sec,end.wrd)      fixed;       /* address of ending location */      dcl (loop.sec,loop.wrd)    fixed;      dcl loop.time(2)           fixed;       /* loop time */      dcl old.base (1)           fixed;       /* 32 bit original poly sound file base */      dcl new.base (1)           fixed;       /* 32 bit new poly sound file base */      dcl temp.crossfade         fixed;      dcl crossfade.time(2)      fixed;      dcl (ssec1,swrd1)          fixed;       /* fading out address */      dcl (ssec2,swrd2)          fixed;       /* fading in address */      dcl (dsec,dwrd)            fixed;       /* crossfade destination address */      dcl new_number_of_symbols  fixed;       /* number of symbols in new sound file */      dcl (i,j)                  fixed;      dcl rec(POLY.HIST.REC.LEN-1) fixed;      if inc.stmm=0 then return;              /* LOOP is a STM release M feature */      if GET.STM.EDIT.TIMES(base)=0           /* if we cannot get good edit times */      then return;      if GET.CROSSFADE.TIME(cross.start)<>0      then call copy_time(some.time,crossfade.time);      else return;      call TIME_TO_INDEX(stm.begin.time(0),stm.begin.time(1),stm.begin.time(2),stm.sample.rate,stereo); /* find the address of the start loop time */      begin.sec=sector.numb;      begin.wrd=sector.offset;      call TIME_TO_INDEX(stm.end.time(0),stm.end.time(1),stm.end.time(2),stm.sample.rate,stereo); /* find the address of the ending time */      end.sec=sector.numb;      end.wrd=sector.offset;      call subtract.addresses(end.sec,end.wrd,begin.sec,begin.wrd);      loop.sec=a.sec;      loop.wrd=a.wrd;      call INDEX_TO_TIME(0,loop.sec,loop.wrd,stm.sample.rate,stereo);      loop.time(0)=time.seconds;      loop.time(1)=time.milliseconds;      loop.time(2)=time.microseconds;      if COMPARE_TIMES(loop.time,tot.time,3)<0 then do;  /* if the loop time is within limits */         /* compute cross fade time in msecs */         if crossfade.time(0) ige 65 then temp.crossfade=65535;  /* Limit to 16 bits of milliseconds */         else temp.crossfade=(crossfade.time(0)*1000)+crossfade.time(1);  /* convert to milliseconds */         /* compute cross fade length */         i=0;   /* Haven't changed crossfade time yet */         /* Crossfade can't be longer than sound file before loop */         if COMPARE_TIMES(crossfade.time,stm.begin.time,3) > 0 then do;            call copy_time(stm.begin.time,crossfade.time);            i=1;         end;         /* Crossfade can't be longer than loop itself */         if COMPARE_TIMES(crossfade.time,loop.time,3) > 0 then do;            call copy_time(loop.time,crossfade.time);            i=1;         end;         /* notify user if we change crossfade length */         if i <> 0 then do;            temp.crossfade=(crossfade.time(0)*1000)+crossfade.time(1);  /* convert to milliseconds */            tok.ptr=0;            token(0)=tok.ptr;            call CONVERT.SAMPLE.TIME.TO.STRING(crossfade.time);  /* converts an unsigned number between 0 and 999 to a string*/            call crossfade.override;                /* tell the user */         end;         if CREATE.SOUND.FILE(end.sec+(end.wrd<>0)+shr(BL.POLY,8),stm.sample.rate,0,stereo)<>0 then do;            call copy32(SFILE.BASE,new.base);  /* things may have changed */            call LOOK.UP.SF.INFO;              /* so find current file name again */            if sf.type=1 then do;              /* if a sound file */               call copy32(SFILE.BASE,old.base);               call DRAW.MESSAGE('Looping Sound File...');               call PS.LOCK;                   /* lock out a reboot */               call COPY.POLY.MEM(old.base,shr(BL.POLY,8),0,new.base,shr(BL.POLY,8),0,end.sec,end.wrd);  /* copy the extracted samples */               /* crossfade the end loop time with the start loop time */               call GET.CROSSFADE.WRD.LEN(temp.crossfade,stm.sample.rate,stereo);               call subtract.addresses(shr(BL.POLY,8)+end.sec,end.wrd,xfade.sec,xfade.wrd);               ssec1=a.sec;               swrd1=a.wrd;               call subtract.addresses(shr(BL.POLY,8)+begin.sec,begin.wrd,xfade.sec,xfade.wrd);               ssec2=a.sec;               swrd2=a.wrd;               dsec =ssec1;               dwrd =swrd1;               call POLY.CROSS.FADE(old.base,ssec1,swrd1,old.base,ssec2,swrd2,new.base,dsec,dwrd,temp.crossfade,stm.sample.rate,stereo);               call psmread(new.base,SF.HDR,sf.number.of.symbols);               new_number_of_symbols=read(psd);               do i=0 to 2;                  some.time(i)=0;               end;               i=0;                            /* include the symbols from the beginning of the sound file */               j=FIND_TIME(old.base,stm.end.time);                              /* to the end of the of the loop */               do while (i<j) and (new_number_of_symbols<max.symbols);  /* do while less than end loop time and number of symbols in new sound file is less than max */                  new_number_of_symbols=MOVE.SYMBOL(old.base,new.base,i,some.time,0,1);                  i=i+1;               end;                                               /* of if not a duplicate name */               /* Set MARK.END to last valid sample in file */               i = end.sec; /* sector length */               j = end.wrd - (1+stereo); /* subtract one sample from length */               if j < 0 then do; /* need to borrow from sectors */                  j = j&255; i = i - 1;                end;               call INDEX_TO_TIME(0,i,j,stm.sample.rate,stereo);               call psmwrite(new.base,SF.HDR,sf.mark.end);               write(psd)=time.seconds;               write(psd)=time.milliseconds;               write(psd)=time.microseconds;               call SET.SYMBOL.TIME(new.base,mend,time.seconds,time.milliseconds,time.microseconds);               /* Set DATA.END the same as MARK.END */               call psmwrite(new.base,SF.HDR,sf.data.end);               write(psd)=time.seconds;               write(psd)=time.milliseconds;               write(psd)=time.microseconds;               call SET.SYMBOL.TIME(new.base,ENDNAME,time.seconds,time.milliseconds,time.microseconds);               /* Set VALID.DATA to length of data in file */               call psmwrite(new.base,SF.HDR,sf.valid.data);               write(psd)=0;               write(psd)=end.sec;               write(psd)=end.wrd;               /* Set TOTAL.LENGTH */               call psmwrite(new.base,SF.HDR,sf.total.length);               write(psd)=0;               write(psd)=end.sec;               write(psd)=end.wrd;               /* Set perfect LOOP.LENGTH */               call psmwrite(new.base,SF.HDR,sf.loop.length);               write(psd)=0;               write(psd)=loop.sec;               write(psd)=loop.wrd;               /* Set data type */               call psmwrite(new.base,SF.HDR,sf.file.data.type);               write(psd)=512;   /* perfectly looped */               /* Set caption */               call psmwrite(new.base,SF.HDR,sf.id.field.bytes);               call copy_out_string(loopcap);               call PS.SETUP(new.base);               call PS.UNLOCK;               call SELECT.PARTIAL(0);          /* select the first partial */               call CREATE.PATCH.PARTIAL(0,NEWFNAME);          /* turn this partial into a patch partial */               call CLEAR.PARAMETERS;           /* get rid of active parms */               call ERASE.MESSAGE;               new.poly.contents = new.poly.contents \ 1;               call BUILD.POLY.HIST.REC(new.base,0,rec);   /* show a new file created */               call ADD.POLY.TO.HIST(rec);            end;         end;                                   /* of creating new sound file was succesful */      end;      else call no.loop.time;   end LOOP.SOUND.FILE;   /* $Subtitle Volume Control */   VOLUME: proc (base,y,msg) swapable;      dcl base  fixed array;  /* sound file base in poly */      dcl y           fixed;  /* gain ranging from 0 to 30000; 1000 = unity */      dcl msg         fixed;  /* 1 -> indicate where signal first clipped; 0 -> don't bother */      dcl (i,j)       fixed;      dcl #secs       fixed; /* file sector length */      dcl (overflow)  fixed; /* if an overflow occurred */		dcl (ovsec)	    fixed;		dcl (ovwrd)     fixed;		dcl r13   lit '"313"'; /* register 13 - always free */		dcl mr13  lit '"353"'; /* memory r13 */		dcl mr13i lit '"373"'; /* memory r13 then increment - used for buffering via r13 */     	   call psmread(base, 0, bl.len);   /* file get sector length */     	   #secs=read(psd)-shr(BL.POLY,8);      		i        = 0;		overflow = 0;     	   while (i != #secs)          		/* loop over samples */		{         call psmread(base, shr(BL.POLY,8)+i,0);  /* get sample */         call poly.in(addr(misc.buf(0)),256);			         call psmwrite(base,shr(BL.POLY,8)+i,0);						write(r13) = addr(misc.buf(0));         			do j=0 to 255;				if (read(mr13) < 0)						 	/* if negative....			*/				{					load 	-read(mr13i);						/* load abs(x)					*/					uload	500;									/* add 500 to product		*/					mul	y;										/* compute abs(x)*y+500		*/										if (URES >= 500)							/* overflow would occur		*/					{						if (overflow == 0)					/* detect first				*/						{							overflow = 1;						/* record where...			*/							ovsec    = i;							ovwrd    = j;						}												write(psd) = -32768;					/* clip							*/					}					else					{						div	1000;						write(psd) = -res;					}				}								else												/* if positive					*/				{					load 	read(mr13i);						/* load x  						*/					uload	500;									/* add 500 to product		*/					mul	y;										/* compute x*y+500			*/										if (URES >= 500)							/* overflow would occur		*/					{						if (overflow == 0)					/* detect first				*/						{							overflow = 1;						/* record where...			*/							ovsec    = i;							ovwrd    = j;						}												write(psd) = 32767;					}					else					{						div	1000;						write(psd) = res;					}				}			end;			if (overflow<>0) and (msg<>0) then do; /* if first time overflow and user wants to know */				call INDEX_TO_TIME(0,ovsec,ovwrd,stm.sample.rate,stereo);				some.time(0)=time.seconds;				some.time(1)=time.milliseconds;				some.time(2)=time.microseconds;				tok.ptr=0;				token(0)=0;				call CONVERT.SAMPLE.TIME.TO.STRING(some.time);				call volume.clipped; /* tell the user the sample time when the volume was first clipped */				msg=0;			end;         			i=i+1;			timeshare_with_host();      }   	end VOLUME;   VOLUME.CONTROL:  proc(base) public swapable;  /* applies gain to samples */      dcl base  fixed array;  /* file base in poly memory */      dcl new.base(1) fixed;  /* 32 bit poly base */      dcl y           fixed;      dcl flag        fixed;      dcl rec(POLY.HIST.REC.LEN-1) fixed;      /*         sample = sample*gain;  signal is amplified.                                where gain=any number between 0 and 30                                of the format xx.xxx                                so, sample=sample*30000/1000      */      if inc.stmm=0 then return;    /* VOLUME is a STM release M feature */      ertyp=0;                      /* forget previous errors */      y=CONV.STR.TO.FIXED(token,3,0);    /* expecting unsigned number with three numbers following decimal point */      if ertyp<>0 then return;      else if y igt 30000 then do;  /* if gain is larger than 30 */         call overflow.error;         return;      end;				call DRAW.MESSAGE('Adjusting soundfile volume...');      flag=1;                          /* assume all systems go */      call copy32(base,new.base);      /* initialize our local copy */      call psmread(base,0,bl.saved);   /* if the file is used or locked */      if (read(psd)<>0) or (locked<>0) then do;        /* we should make a copy */         if COPY.CURRENT.SOUND.FILE(base)<>0 then do;  /* if successful copy */            call LOOK.UP.SF.INFO;      /* look at the copied version */            call copy32(SFILE.BASE,new.base);         end;         else flag=0;                  /* cannot continue */      end;      if flag<>0 then do;              /* we can do our thing */         call PS.LOCK;                 /* lock out a reboot */         call VOLUME(new.base,y,1);    /* adjust volume level and let user know where signal was first clipped */         call PS.UNLOCK;         call dealloc(0);                              /* free up keyboard timbre */         call ps.setup(new.base);                      /* set up volume controlled file */         call alloc.timbre(0);                         /* re-assign keyboard timbre */         call CHANGE.SIGNAL.LEVEL;                     /* voltage value of sample at current cursor location needs to be updated */         new.poly.contents = new.poly.contents \ 1;         if (com32(new.base,base) <> lw#ieq) then do;            call BUILD.POLY.HIST.REC(new.base,0,rec);  /* show a new file created */            call ADD.POLY.TO.HIST(rec);         end;			call ERASE.MESSAGE;      end;		   end VOLUME.CONTROL;   /* $Subtitle Normalizes the Sound File Volume */   NORMALIZE:  proc(base) public swapable;  /* normalizes the volume */      dcl base  fixed array; /* file base in poly memory */      dcl new.base(1) fixed; /* 32 bit poly base */      dcl (i,j,k)     fixed;      dcl (x,y)       fixed; /* sample and gain norm*/      dcl max         fixed; /* absolute value of maximum peak value */		dcl rounder		 fixed; /* used for rounding */      dcl #secs       fixed; /* file sector length */      dcl flag        fixed;      dcl rec(POLY.HIST.REC.LEN-1) fixed;		dcl r13   lit '"313"'; /* register 13 - always free */		dcl mr13  lit '"353"'; /* memory r13 */		dcl mr13i lit '"373"'; /* memory r13 then increment - used for buffering via r13 */      if inc.stmm=0 then return;    	/* NORMALIZE is a STM release N feature */		call DRAW.MESSAGE('Normalizing soundfile volume...');     	   call psmread(base,0,bl.len);     /* file get sector length */      #secs=read(psd)-shr(BL.POLY,8);      flag=1;                          /* assume all systems go */      call copy32(base,new.base);      /* initialize our local copy */      call psmread(base,0,bl.saved);   /* if the file is used */      if (read(psd)<>0) or (locked<>0) then do;        /* we should make a copy */         if COPY.CURRENT.SOUND.FILE(base)<>0 then do;  /* if successful copy */            call LOOK.UP.SF.INFO;      /* look at the copied version */            call copy32(SFILE.BASE,new.base);         end;         else flag=0;                  /* cannot continue */      end;      if flag<>0 then do;              /* we can do our thing */         call PS.LOCK;                 /* lock out a reboot */         max=0;                        /* initialize the maximum value */         i=0;                          /* find the largest peak value */         do while i <> #secs;          /* loop over samples */            call psmread(new.base,shr(BL.POLY,8)+i,0);  /* get sample */            call poly.in(addr(misc.buf(0)),256);								write(r13) = addr(misc.buf(0));			/* point to samples									 */            do j=0 to 255;                         /* take the absolute value of the peak value  */					if (abs(read(mr13i)) IGT max)					{						write(r13) = read(r13) - 1;		/* back up if bigger									 */						max = abs(read(mr13i));					}            end;            i=i+1;				timeshare_with_host();         end;						if (max ILT 32760)								/* avoid division by 0								*/			{				rounder = max;				max     = shl(max,1) + 1;					/* prep for division */								i=0;				do while i <> #secs;          			/* loop over samples */						call psmread (new.base, shr(BL.POLY,8)+i,0);					call poly.in (addr(misc.buf(0)), 256);									call psmwrite(new.base, shr(BL.POLY,8)+i,0);									write(r13) = addr(misc.buf(0));		/* point to samples									 */					do j=0 to 255;                      /* take the absolute value of the peak value  */						if (read(mr13) < 0)					/* negative number									 */											{							load  rounder;							uload -read(mr13i);							div   max;							write(psd) = -res;						}												else						{							load  rounder;							uload read(mr13i);							div   max;							write(psd) = res;						}					end;										i=i+1;										timeshare_with_host();				end;			}         call PS.UNLOCK;         call dealloc(0);                              /* free up keyboard timbre */         call ps.setup(new.base);                      /* set up volume controlled file */         call alloc.timbre(0);                         /* re-assign keyboard timbre */         call CHANGE.SIGNAL.LEVEL;                     /* voltage value of sample at current cursor location needs to be updated */         new.poly.contents = new.poly.contents \ 1;         call ERASE.MESSAGE;         if (com32(new.base,base) <> lw#ieq) then do;            call BUILD.POLY.HIST.REC(new.base,0,rec);  /* show a new file created */            call ADD.POLY.TO.HIST(rec);         end;      end;         end NORMALIZE;