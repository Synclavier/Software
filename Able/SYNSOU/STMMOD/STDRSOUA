/*	$Title :SYNSOU:STMMOD:STDRSOUA - Sample-to-Memory Drawing RoutinesModified:2000/07/03 - TY  - Repaired a bug in DRAW.LANDSCAPE.CONTROL that caused an infinite loop in PLOT.SCALE when plotting soundfiles with only one sample.					  - Also replaced < with ilt in PLOT.SCALE to prevent sign misinterpretation which caused spurious scale numbers to be plotted when						 viewing soundfiles with only two samples.1999/10/15 - TY  - ERASE.SOUND.DISPLAY removes the patch assignment message1991/05/31 - CJ  - Slightly different usage of mouse.playing1988/04/22 - MWH - Add point mode and zero line1987/02/04 - BSW - Included these routines in the Sample-To-Memory Drawing Module*/	DISPLAY.SOUND.FILE.MESSAGE: proc(msg.num) swapable;	/*	displays an error message in the left sound file display	*/		dcl msg.num		fixed;		dcl no.chars	fixed;	/*	number of characters in message	*/		vector_mode;		call viewport(left.rect.minx+1,left.rect.maxx-1,(left.rect.miny+(left.rect.maxy-left.rect.miny)/2),(left.rect.miny+(left.rect.maxy-left.rect.miny)/2)+char.height);		call window  (0,display.width,0,char.height);		stm.disp.message=msg.num;	/*	indicates which error message is displayed	*/		if stm.disp.message<>0		then do case (stm.disp.message-1);			do;							/*	sound file not available	*/				no.chars=25;				call imove((left.rect.minx+(left.rect.maxx-left.rect.minx)/2)-((no.chars/2)*char.width),left.rect.miny+(left.rect.maxy-left.rect.miny)/2);	/*	center the error message	*/				call pstring('Sound File Not Available.');			end;			do;							/*	no sound file in partial	*/				no.chars=39;				call imove((left.rect.minx+(left.rect.maxx-left.rect.minx)/2)-((no.chars/2)*char.width),left.rect.miny+(left.rect.maxy-left.rect.miny)/2);	/*	center the error message	*/				call pstring('This Partial Does Not Use a Sound File.');			end;		end;		transparent_mode;	end DISPLAY.SOUND.FILE.MESSAGE;	dcl time.per.lpixel[1]	fixed public;							//	handy struct holds milliseconds/pixel	dcl (lsp.start,lsp.end)	fixed;	dcl time.per.lpixel.num	lit 'time.per.lpixel[lw#num]';	//	access num and denom of milliseconds/pixel	dcl time.per.lpixel.den	lit 'time.per.lpixel[lw#den]';	Plot.Tic: proc(pixel,size) swapable;							/*	plots landscape tic marks	*/		dcl pixel	fixed;		dcl size		fixed;		call move_to(pixel+landscape.left+1,landscape.bot-2	  );		call plot	(pixel+landscape.left+1,landscape.bot-size+1);	end;	/*	$Subtitle Landscape Pixel Routine	*/	Lpixel: proc(time,lscale) returns (fixed) swapable;	/*	returns a landcape pixel number given a time	*/		dcl time		fixed array;		dcl lscale	fixed array;		if (time(0) < 10)												//	if less than 10 seconds, compute microseconds; scale to 1000*pixel, divide & round		{			load  (1000*time(0) + time(1));						//	get milliseconds			uload time(2);												//	microseconds		}		else		{			load  time(0);												//	get seconds			if (time(2) >= 500)										//	round microseconds into milliseconds				uload time(1)+1;			else				uload time(1);		}		mul 1000;														//	compute 32-bit number of microseconds or milliseconds		bitmsb = ures;													//	publish for ratio_multiply		bitlsb = res;		ratio_multiply(lscale(lw#den), lscale(lw#num));		//	compute pixels or 1000*pixels		if (time(0) < 10)												//	if result was 1000*pixels, round to nearest pixel for <10 second case			ratio_multiply(1, 1000);		return bitlsb;	end Lpixel;	/*	$Subtitle Plot Landscape Times	*/	Plot.Time: proc(time,lscale,digits) swapable;			/*	plots landscape times	*/		dcl time		fixed array;		dcl lscale	fixed array;		dcl digits	fixed;								/*	# of digits after decimal		*/		dcl i			fixed;								/*	used for all sorts of things	*/		dcl divtab data (100,10,1);		vector_mode;										/*	place terminal in graphics	*/		i = lpixel(time,lscale);						/*	get x pixel location of time label	*/		call plot.tic(i,5);								/*	plot a tic there	*/		call move_to(landscape.left+i+1,landscape.bot-char.height-4);	/*	set up for plot of label	*/		alpha_mode;											/*	alpha-numeric graphics printing	*/		call pnum(time(0),0);							/*	print seconds	*/		call pc(dot);										/*	print decimal	*/		load(time(1));										/*	get milliseconds	*/		div divtab(digits-1);							/*	round to # of desired	*/		i = res;												/*	places after the decimal	*/		if rem > shr(divtab(digits-1),1) then i = i + 1;		call print_digits(i,digits);					/*	print result of rounding	*/		vector_mode;										/*	go back to graphics	*/	end Plot.Time;	/*	$Subtitle Plot Landscape Scale	*/	Plot.Scale: proc swapable;	/*	plots landscape scale	*/		dcl (i,j,k)								fixed;		dcl (snum,slsb,power,sdiv,quit)	fixed;		transparent_mode;		load tot.time(0);			/*	load tot.time seconds	*/		mul 10;						/*	mul 10						*/		slsb = res;					/*	slsb = tot.time secs * 10	*/		load tot.time(1);			/*	load tot.time msecs		*/		div 100;						/*	div by 100					*/		slsb = slsb + res;		/*	tot time in 10ths/sec	*/		load slsb;					/*	load tot time in 10ths secs	*/		div 5;						/*	number of divisions on the scale	*/		snum = res;					/*	division size in 10ths of seconds	*/		if snum = 0		then snum = 1;				/*	don't allow 0, causes inf loop	*/		power = 1;		j = snum;		do while j >= 10;			/*	compute rounded division size	*/			load j;			div 10;			j = res;			if rem <> 0 then j = j + 1;			power = power * 10;		end;		sdiv = j * power;		snum = sdiv;		vector_mode;		j = 0;						/*	danger: this is being reused!	*/		quit = 0;		do while quit = 0;			some.time(0) = snum/10;			some.time(1) = (snum - (some.time(0)*10))*100;			some.time(2) = 0;			i = 1;			k = some.time(0);		/*	compute length in chars of some.time(0)	*/			do while k > 10;		/*	i will contain length	*/				k = k/10;				i = i + 1;			end;			if (landscape.left + lpixel(some.time,time.per.lpixel) + 1) ilt (landscape.right-((i+3)*char.width))			then do;				call plot.time(some.time,time.per.lpixel,1);		/*	plot the scale time	*/				write(mam)=trd.ptr+8;				/*	set up ext mem for	*/				write(mal)=18+(j*3)+1;				/*	save of scale labels	*/				do i = 0 to 2;							/*	stored in format: 0-Sec 1-msec 2-usec	*/					write(mdi) = some.time(i);				end;				j = j + 1;								/*	inc ext memory offset counter	*/				snum = snum + sdiv;					/*	increment scale	*/			end;			else quit = 1;		end;		write(mam) = trd.ptr+8;		/*	set up ext memory for number of		*/		write(mal) = 18;				/*	scale divisions -- used later for	*/		write(md)  = j;				/*	erasing old scale labels				*/	end Plot.Scale;	/*	$subtitle Erase Landscape Routine	*/	dcl last.tot (2)							fixed;	/*	last sound file total time value	*/	dcl (last.lsp.start,last.lsp.end)	fixed;	dcl last.lpixel(1)						fixed;	/*	last scale of lscape plot	*/	ERASE.LANDSCAPE.CONTROL: proc public swapable;	/*	erases the landscape display	*/		dcl (i,j,num.labels)	fixed;		vector_mode;		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if (lsp.start <> last.lsp.start)		or (lsp.end   <> last.lsp.end)		then do;			if mg600 then do;				/*	erase by area fill	*/				call area.fill(landscape.left+1,landscape.top-2,landscape.right-1,landscape.bot+2,1,0);			end;			else do;				/*	erase landscape box	*/				call data_level(1);				call connect(last.lsp.start+landscape.left+1,landscape.top-1,last.lsp.start+landscape.left+1,landscape.bot+1);				call connect(last.lsp.end  +landscape.left+1,landscape.top-1,last.lsp.end+landscape.left+1,landscape.bot+1);				call line_type(5);	/*	dotted	*/				do i = landscape.bot+1 to landscape.top-1 by 3;					if (i mod 2) = 0					then call connect(last.lsp.start+landscape.left+1,i,last.lsp.end+landscape.left+1,i);					else call connect(last.lsp.start+landscape.left+2,i,last.lsp.end+landscape.left+1,i);				end;				call line_type(0);				call data_level(0);			end;		end;		/*	erase time labels	*/		if compare_times(tot.time,last.tot,3) <> 0 then do;	/*	if sound file length has changed	*/			if mg600			then call area.fill(landscape.left,landscape.bot-2,screen.width,landscape.bot-5-char.height,1,0);			else do;				call data_level(1);				write(mam) = trd.ptr+8;				write(mal) = 18;				num.labels = read(md);				j = 0;				do while j < num.labels;					write(mam)=trd.ptr+8;				/*	set up ext mem for	*/					write(mal)=18+(j*3)+1;				/*	save of scale labels	*/					do i = 0 to 2;							/*	stored in format: 0-Sec 1-msec 2-usec	*/						some.time(i) = read(mdi);					end;					call plot.time(some.time,last.lpixel,1);					j = j + 1;								/*	inc ext memory offset counter	*/				end;				call plot.time(last.tot,last.lpixel,3);				vector_mode;				call data_level(0);			end;		end;		transparent_mode;	end erase.landscape.control;	/*	$subtitle Draw Landscape Routine	*/	DRAW.LANDSCAPE.CONTROL: proc public swapable;	/*	draw the landscape	*/		dcl our.time(2)	fixed;		dcl i					fixed;		call Mouse.Switch(0);		vector_mode;		call data_level(0);		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		//	Compute the landscape time scale (milliseconds/pixel).  Take the total length		//	of the sound file.  limit to avoid math errors. round so that entire file		//	is encompased by landscape display		copy_time(tot.time, our.time);												//	get total sound file length		time.per.lpixel.den = (landscape.right-1)	- (landscape.left+1);	//	get pixels in scale area		while (our.time(0) IGE 30)														//	limit numerator to 30,000 to avoid math errors		{			our.time(0) = shr(our.time(0) + 1, 1);									//	round numerator up			our.time(1) = shr(our.time(1) + 1, 1);			our.time(2) = shr(our.time(2) + 1, 1);			time.per.lpixel.den = shr(time.per.lpixel.den, 1);					//	round denominator down		}		if (our.time(2) != 0)															//	round up microseconds into milliseconds			our.time(1) = our.time(1) + 1;		time.per.lpixel.num = our.time(0)*1000 + our.time(1);					//	get "milliseconds"		if (time.per.lpixel.den == 0)	time.per.lpixel.den = 1;				//	avoid extremely unlikely division by 0		if (time.per.lpixel.num == 0)	time.per.lpixel.num = 1;				//	avoid slightly more likely infinite loops				call compute_pixel_time(0,start.time);										/*	get start time of window time	*/		call compute_pixel_time(display.width,end.time);						/*	get end time of window	*/		lsp.start		 = lpixel(start.time,time.per.lpixel);					/*	get landscape pixel of start time	*/		landscape.start = lsp.start+landscape.left+1;							/*	set global	*/		if compare_times(tot.time,end.time,3) = 1 then							/*	get landscape pixel for end time	*/			lsp.end = lpixel(end.time,time.per.lpixel);		else			lsp.end = lpixel(tot.time,time.per.lpixel);		landscape.end = lsp.end+landscape.left+1;		call ERASE.LANDSCAPE.CONTROL;													/*	get rid of old!	*/		if mg600 then do;			call draw_rect(lsp.start+landscape.left+1,landscape.bot+2,lsp.end+landscape.left+1,landscape.top-2);		/*	draw inset landscape box	*/			call area.fill(lsp.start+landscape.left+3,landscape.top-4,lsp.end+landscape.left-1,landscape.bot+4,0,1);		end;		else do;			call connect(lsp.start+landscape.left+1,landscape.top-1,lsp.start+landscape.left+1,landscape.bot+1);			call connect(lsp.end+landscape.left+1,landscape.top-1,lsp.end+landscape.left+1,landscape.bot+1);			call line_type(5);	/*	dotted	*/			do i = landscape.bot+1 to landscape.top-1 by 3;				if (i mod 2) = 0				then call connect(lsp.start+landscape.left+1,i,lsp.end+landscape.left+1,i);				else call connect(lsp.start+landscape.left+2,i,lsp.end+landscape.left+1,i);			end;			call line_type(0);		end;		/*	$page	*/		some.time(0) = 0;			/*	set up for 0.0 time label	*/		some.time(1) = 0;		some.time(2) = 0;		call plot.time(some.time,time.per.lpixel,1);		/*	plot 0.0 time label	*/		call plot.time(tot.time,time.per.lpixel,3);		/*	plot end time label	*/		call plot.scale;					/*	plot inbetween times	*/		last.lsp.start	= lsp.start;		last.lsp.end	= lsp.end;		copy32	(time.per.lpixel,	last.lpixel);		copy_time(tot.time,			last.tot);		transparent_mode;		call Mouse.Switch(1);		call DRAW.SOUND.FILE.HOR.FACTOR;		return 0;			/*	satisfy function call	*/	end DRAW.LANDSCAPE.CONTROL;	//	Set a new region for display when the landscape box is moved or resized.	//	passed in pixel start and end time of landscape start	COMPUTE.NEW.LANDSCAPE: proc(p.start, p.end, lscale) public swapable;		dcl (p.start,p.end)	fixed;		dcl (lscale)			array;		dcl (i,spp)				fixed;		dcl (sf_length) (2)	fixed;		transparent_mode;		bitmsb = 0;													//	get pixels spanned by landscape box		bitlsb = p.end - p.start;		ratio_multiply(lscale(lw#num), lscale(lw#den));	//	compute pixels * milliseconds/pixel == milliseconds of time covered by landscape box		ratio_multiply(stm.sample.rate, 10);				//	milliseconds * 10*samples/milliseconds / 10 == samples spanned by landscape box		ratio_multiply(1,display.width);						//	samples/displaywidth == samples per pixel		spp = bitlsb;		if spp == 0 then spp = 1;								//	result: samples per pixel		//	find nearest factor		i = 0;		do while (i < stm.max.hor.factors) and (hor.zoom.table(i+1) <= spp);			i = i + 1;		end;		prev.stm.hor.scale  = stm.hor.scale;				/*	for erasing old scale	*/		prev.stm.hor.factor = stm.hor.factor;		stm.hor.factor	= i;										/*	new scale factor	*/		stm.hor.scale	= spp;									/*	new scale; may <> factor, but exact	*/		//	now compute start time where we want to display from		bitmsb = 0;													//	get pixel position of left end of landscape box		bitlsb = p.start;		ratio_multiply(lscale(lw#num), lscale(lw#den));	//	compute pixels * milliseconds/pixel == milliseconds into sound file of start time		ratio_multiply(stm.sample.rate, 10);				//	milliseconds * 10*samples/millisecond / 10 == samples into sound file		ratio_multiply(1,spp);									//	round to nearest logical pixel		ratio_multiply(spp,1);									//	round to nearest sample		Convert.Samples.To.SF.Len(BitMsbArray, sf_length);	//	compute length as if mono sound file		INDEX_TO_TIME(sf_length(0),sf_length(1),sf_length(2),stm.sample.rate,0);		start.time(0) = time.seconds;		start.time(1) = time.milliseconds;		start.time(2) = time.microseconds;		call compute_pixel_time(display.width,end.time);	/*	compute end.time	*/	end COMPUTE.NEW.LANDSCAPE;	/*	$Subtitle Complement state of "zero line" in middle of windows	*/	DRAW.ZERO.LINE: proc(left,right,channel) public swapable;		dcl (left,right)	fixed;	/*	pixel limitations to draw	*/		dcl channel			fixed;	/*	0-left; 1-right; 2-both		*/		dcl y					fixed;		call push.graphics.attributes;		transparent_mode;					/*	make sure we can get to vector_mode	*/		vector_mode;		call data_level(2);				/*	complement the zero line	*/		y = shr(pixel.samples+1,1);	/*	total y (height) / 2	*/		call window(0,display.width,1,pixel.samples+1);		if (channel = 1) or (channel = 2) then do;			call viewport(right.rect.minx+1,right.rect.maxx-1,right.rect.miny+1,right.rect.maxy-1);			call connect(left,y,right,y);		end;		if (channel = 0) or (channel = 2) then do;			call viewport( left.rect.minx+1, left.rect.maxx-1, left.rect.miny+1, left.rect.maxy-1);			call connect(left,y,right,y);		end;		call pop.graphics.attributes;		return;	end DRAW.ZERO.LINE;	/*	$Subtitle Draw and Erase Sound File Display	*/	ERASE.SAMPLES: proc(left,right,channel) public swapable;		dcl (left,right)	fixed;	/*	pixel limitations of sample in sound display	*/		dcl x					fixed;	/*	pixel location of sample in sound display		*/		dcl j					fixed;	/*	minimum and maximum samples for left sound	*/		dcl syn.counter	fixed;		dcl channel			fixed;	/*	0-left; 1-right; 2-both	*/		transparent_mode;				/*	make sure we can get to vector_mode	*/		vector_mode;					/*	make sure we can get to point_mode	*/		call data_level(2);			/*	erase display in complement mode		*/		if stm.draw.mode <> 0 AND ((vt640 <> 0) OR (dq640 <> 0))		then do;			point_mode;		end;		call window (0,display.width,1,pixel.samples+1);		do x=left to right;			if (channel = 0) or (channel = 2) then do;				if (vt640) or (dq640) then do;	/*	if either of these terminals erase on the fly	*/					write(mam)=trd.ptr+shr(x,8);					write(mal)=x;					j=read(md);					if j<>0 then do;					/*	if sample there	*/						call viewport(left.rect.minx+1,left.rect.maxx-1,left.rect.miny+1,left.rect.maxy-1);						call connect(x,j&255,x,shr(j,8));					end;				end;				write(mam)=trd.ptr+shr(x,8);		/*	zero out image in external memory	*/				write(mal)=x;							/*	point to the word	*/				write(md)=0;							/*	wipe out old min and max left sample in image(x)	*/			end;			if (channel = 1) or (channel = 2) then do;				if (vt640) or (dq640) then do;	/*	if either of these terminals erase on the fly	*/					write(mam)=trd.ptr+4+shr(x,8);					write(mal)=x;					j=read(md);					if j<>0 then do;						call viewport(right.rect.minx+1,right.rect.maxx-1,right.rect.miny+1,right.rect.maxy-1);						call connect(x,j&255,x,shr(j,8));					end;				end;				write(mam)=trd.ptr+4+shr(x,8);	/*	zero out image in external memory	*/				write(mal)=x;							/*	point to the word	*/				write(md)=0;							/*	wipe out old min and max right sample in image(x)	*/			end;			if (vt640) or (dq640) then do;		/*	only in this case because pericom so fast	*/				syn.counter=syn.counter+1;				if (syn.counter=10)				or (play<>0)				then do;					syn.counter=0;					call run.syn.loop;				end;				if STM.EXIT.CHECK<>0 then do;		/*	check for interruptions	*/					call data_level(0);					transparent_mode;					new.poly.contents = new.poly.contents \ 1;					return;				end;			end;		end;		/*	$page	*/		if mg600 then do;									/*	area erase on pericom	*/			if inc.mouse then do;				call push.mouse;							/*	save current mouse type	*/				call mouse.switch(0);					/*	turn mouse off	*/			end;			if (channel = 0) or (channel = 2) then do;				call viewport(left.rect.minx+1,left.rect.maxx-1,left.rect.miny+1,left.rect.maxy-1);				call area.fill(left,1,right,pixel.samples+1,1,0);				if (stm.graphx>=left)				&  (mouse.playing<>1)					/*	if not mouse stm vertical bar cursor	*/				&  (mouse.playing<>2)					/*	if not mouse stm vertical bar cursor	*/				then do;					call push.graphics.attributes;	/*	we could be in block mode here	*/					call blockmode_off;					call DRAW.GRAPHICS.CURSORS(stm.graphx,0);	/*	restore graphics cursor after an area erase	*/					call pop.graphics.attributes;				end;				else if ((mouse.playing=1)\(mouse.playing=2))				and (stm.mousex>= left)				and (stm.mousex<=right)				then call DRAW.MOUSE.PB.CURSOR(0);				/*	restore graphics cursor after an area erase	*/				if stm.zero.line <> 0				then call DRAW.ZERO.LINE(left,right,0);		/*	restore zero line, channel=0	*/			end;			if (channel = 1) or (channel = 2) then do;				call viewport(right.rect.minx+1,right.rect.maxx-1,right.rect.miny+1,right.rect.maxy-1);				call area.fill(left,1,right,pixel.samples+1,1,0);				if (stm.graphx>=left)				and (mouse.playing<>1)								/*	if not mouse stm vertical bar cursor	*/				and (mouse.playing<>2)								/*	if not mouse stm vertical bar cursor	*/				then do;					call push.graphics.attributes;				/*	we may be in blockmode at this point	*/					call blockmode_off;					call DRAW.GRAPHICS.CURSORS(stm.graphx,1);	/*	restore graphics cursor after an area erase	*/					call pop.graphics.attributes;				end;				else if ((mouse.playing=1)\(mouse.playing=2))				and (stm.mousex>= left)				and (stm.mousex<=right)				then call DRAW.MOUSE.PB.CURSOR(1);				if stm.zero.line <> 0				then call DRAW.ZERO.LINE(left,right,1);		/*	restore zero line, channel=1	*/			end;			call pop.mouse;	/*	restore mouse to what it was before erasing	*/		end;		transparent_mode;		/*	be sure we can get to transparent mode	*/		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.SAMPLES;	/*	$page	*/	ERASE.SOUND.DISPLAY: proc swapable;	/*	erases sound display	*/		erase.rest.of.line(22,46);	//	Remove the patch assignment message		POS.STM.ALPHA.CURSOR();		//	Don't leave the cursor at the end of the patch message		if stm.disp.message<>0 then do;	/*	first erase an error message if one is there	*/			vector_mode;			call data_level(1);			call DISPLAY.SOUND.FILE.MESSAGE(stm.disp.message);	/*	erase the previous message	*/			stm.disp.message=0;	/*	indicate message is no longer displayed	*/			vector_mode;			call data_level(0);	/*	put back in draw and transparent mode		*/			transparent_mode;		end;		else do;			call viewport(0,screen.width,0,screen.height);			call window  (0,screen.width,0,screen.height);			call ERASE.LANDSCAPE.CONTROL;			/*	erases the landscape display	*/			call ERASE.SOUND.FILE.NAME;			stm.file.name(0)=0;						/*	initialize to no name displayed	*/			if caption(0)<>0							/*	erase if had been displayed	*/			then call ERASE.SOUND.FILE.CAPTION;			caption(0)=0;								/*	inititalize to no caption display	*/			if prev.tot.time(0)<>(-1)				/*	erase if had been displayed	*/			then call ERASE.SOUND.FILE.LENGTH;	/*	erase previous if different than current	*/			prev.tot.time(0)=(-1);					/*	initialize to no tot time		*/			if prev.stm.sample.rate<>(-1)			/*	if had been displayed	*/			then call ERASE.SOUND.FILE.RATE;			prev.stm.sample.rate=(-1);				/*	initialize to no sample rate	*/			if prev.cursor.time(0)<>(-1)			/*	if had been drawn	*/			then call ERASE.CURSOR.TIME;			prev.cursor.time(0)=(-1);				/*	initialize to no cursor time	*/			if prev.stm.left.voltage<>(-1)		/*	if had been displayed	*/			or prev.stm.right.voltage<>(-1)			then call ERASE.SAMPLE.LEVEL;			prev.stm.left.voltage=(-1);			/*	initialize to no signal level	*/			prev.stm.right.voltage=(-1);			/*	initialize to no signal level	*/			if ERASE.TIME.LABELS<>0 then return;			if ERASE.SOUND.FILE.SYMBOLS<>0 then return;			if locked<>0 then do;				call ERASE.LOCK.NAME;				call DRAW.RIGHT.CHANNEL.LABEL;			end;			call ERASE.SAMPLES(0,display.width-1,2);		end;	end ERASE.SOUND.DISPLAY;