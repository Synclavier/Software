/* $SUBTITLE *//* 01/13/92 - cj - Added dtd bounce capability            *//* 11/17/88 - cj - changed buffer sizes for poly transfer */dcl Min.Buf.Size  lit '100';   /* min dtd buffer size (per track) */dcl Chunk         lit '(Min.Buf.Size/2)';/* routines to assist in looking up sound file info for *//* digital transfer                                     *//* routine looks up info for current sound file         *//* returns base it is in in poly memory,  as well as    *//* the length (sectors, words) between the mark         *//* start and the mark end points                        *//* note the base pointer is a sector pointer to the     *//* mark start sample of the sound file                  *//* returns true if sound file is available              */LOOKUP.CURRENT.SF.INFO: proc(name,sfbase,sfoffset,sflen,ratearr,stereoarr) returns (fixed) PUBLIC SWAPABLE;   dcl name             array;  /* returns name of current file */   dcl sfbase           array;  /* base in poly memory          */   dcl sfoffset         array;  /* (0) = sec   (1) = wrd - includes bl.poly       */   dcl sflen            array;  /* (0) = sec   (1) = wrd        */   dcl ratearr          array;  /* (0) = sample rate 500 = 50k  */   dcl stereoarr        array;  /* (0) = stereo                 */   dcl i                fixed;   call LOOK.UP.SF.INFO;    /* get info into global stm variables */   if sf.type<>1 then do;   /* no sound file is available         */      name(0)=0;      return 0;   end;   /* save name for user */   call copy.string(FNBUF,name);      do while (name(0)<>0) and (byte(name,name(0)-1)=0);  /* remove trailing zeroes */      name(0)=name(0)-1;                                /* to compute actual length */   end;   /* save current poly base */   call COPY32(sfile.base,sfbase);   /* look up mark start time */   call psmread(sfile.base,sf.hdr,sf.mark.start);   call time_to_index(read(psd),read(psd),read(psd),stm.sample.rate,stereo);   sfoffset(0)=shr(bl.poly,8)+sector.numb;   /* starting sector     */   sfoffset(1)=sector.offset;                /* word of that sector */   call psmread(sfile.base,sf.hdr,sf.mark.end);   call time_to_index(read(psd),read(psd),read(psd),stm.sample.rate,stereo);   sflen(0)=shr(bl.poly,8)+sector.numb;       /* starting sector   */   sflen(1)=sector.offset;                    /* last word to play */   sflen(0)=sflen(0)-sfoffset(0);             /* get length. can not */   sflen(1)=sflen(1)-sfoffset(1);             /* use 32-bit routines */   if sflen(1) < 0 then do;      sflen(1) = sflen(1) + 256;      sflen(0) = sflen(0) - 1;   end;   ratearr  (0) = stm.sample.rate;   stereoarr(0) = stereo;   return true;end LOOKUP.CURRENT.SF.INFO;/* Routine to send a sound file in poly memory over to the Direct *//* to disk                                                        *//* subroutines: */Poly.To.DTD.Checks:proc(i,stereo,error) swapable;   dcl i        fixed;   dcl stereo   fixed;   dcl error    array;   if i<>stereo+1 then do;      call copy.string('Mismatch with READY Tracks (system error)',error);      call set.error(err.lod,error);      return 0;   end;   if dtd.max.secs=0 then do;      /* see if dtd not running    */      call no.direct.to.disk;      /* give an error message     */      return 0;   end;   write(mam)=scsi.ptr;            /* check for record          */   write(md) =33;                  /* protection                */   call Send.To.Lod(144,2);   write(mam)=scsi.ptr;            /* check for record          */   if read(md)<>1 then do;         /* can not record            */      call Send.To.Lod(23,0);      /* hopefully get error msg   */      return 0;   end;   return 1;end Poly.To.DTD.Checks;/* data transfer subroutines */issue.read:proc(trk#,msb,len) swapable;   dcl trk# fixed;   dcl msb  array;   dcl len  fixed;   write(mam)=scsi.ptr;       /* set up dtd info    */   write(mdi)=trk#;           /* track #            */   write(mdi)=msb(lw#msb);    /* disk address       */   write(mdi)=msb(lw#lsb);   write(mdi)=len;            /* # of words to xfer */   call send.to.lod(192,8);   /* read lod data into dtd buffer only */end issue.read;issue.move.poly:proc(soutrk, souwrd, destrk, deswrd, wrdlen) swapable;   dcl soutrk fixed;   dcl souwrd fixed;   dcl destrk fixed;   dcl deswrd fixed;   dcl wrdlen fixed;   write(mam)=scsi.ptr;       /* set up dtd info    */   write(mdi)=59;             /* opcode for move    */   write(mdi)=soutrk;   write(mdi)=souwrd;   write(mdi)=destrk;   write(mdi)=deswrd;   write(mdi)=wrdlen;   call send.to.lod(144,12);end issue.move.poly;zero.fill:proc(trk#,bpos,blen) swapable;   dcl trk# fixed;   dcl bpos fixed;   dcl blen fixed;   write(mam)=scsi.ptr;       /* set up dtd info    */   write(mdi)=34;             /* meta code          */   write(mdi)=trk#;           /* track #            */   write(mdi)=bpos;           /* buffer pos         */   write(mdi)=blen;           /* # of words to xfer */   call send.to.lod(144,8);   /* zero fill buffer   */end zero.fill;command.busy:proc(trk#) swapable; /* see if command still happening     */   dcl trk# fixed;   write(mam)=Scsi.Ptr;   write(md )=trk#;   call Send.To.Lod(195,2);  /* see if command still happening      */   write(Mam)=Scsi.Ptr;   return read(md);end command.busy;/* this routine tells the dtd to write data from its buffer *//* out to its disk                                          */write.poly.data:proc(track#,daddr,wordlen) swapable;   dcl track#     fixed;   dcl daddr      array;   dcl wordlen    fixed;   write(mam)=Scsi.Ptr;   write(mdi)=track#;   write(mdi)=daddr(lw#msb);   write(mdi)=daddr(lw#lsb);   write(mdi)=wordlen;   call Send.To.Lod(198,8);end write.poly.data;wait.for.tracks.finished:proc(numt, tlist) swapable;   dcl numt        fixed;    /* number of tracks */   dcl tlist       array;    /* list of tracks   */   dcl i           fixed;   dcl st          fixed;   dcl timer       fixed;   timer = real.milliseconds;          /* must get disk data every 20 sec */   st=1;   do while (st<>0);                   /* wait for a reasonable amount of time */      st = 0;      do i = 0 to numt-1;         st = st \ command.busy(tlist(i));      end;      if STOP.HELD<>0 then do;  /* check for vk stopped button */         return 1;      end;      if (real.milliseconds - timer) IGT 20000 then return 2;      if DTD.Max.Secs = 0 then return 2;			chill.out.and.run.syn();   end;   return 0;end wait.for.tracks.finished;wait.for.finish:proc(firsttrack,secondtrack,stereo) swapable;   dcl firsttrack  fixed;   dcl secondtrack fixed;   dcl stereo      fixed;   dcl st          fixed;   dcl timer       fixed;   timer = real.milliseconds;          /* must get disk data every 20 sec */   st=1;   do while (st<>0);                   /* wait for a reasonable amount of time */      st=command.busy(firsttrack);      if stereo<>0 then do;         st=st\command.busy(secondtrack);      end;      if STOP.HELD<>0 then do;  /* check for vk stopped button */         return 1;      end;      if (real.milliseconds - timer) IGT 20000 then return 2;      if DTD.Max.Secs = 0 then return 2;		chill.out.and.run.syn();   end;   return 0;end wait.for.finish;Send.Poly.Data:proc(FirstTrack,SecondTrack,Stereo,                    SfBase,SfOffset,SfLen,Offctr,                    Sectors,bwpos) swapable;     dcl Firsttrack     Fixed;   dcl Secondtrack    Fixed;   dcl Stereo         fixed;   dcl SfBase         array;   /* pointer to sf base                   */   dcl SfOffset       array;   /* sector and word offset to mark start */   dcl SfLen          array;   /* sectors and words of sf length       */   dcl Offctr         array;   /* counter (basically sectors only)     */   dcl Sectors        fixed;   /* # of sectors to send to each trk     */   dcl bwpos          fixed;   /* buffer word pos to store data at     */   dcl zeroes.to.send fixed;   dcl (i,j,k)     fixed;   if Stereo then Sectors = shl (Sectors,1); /* we are passed # of disk sectors worth of data to send over */   zeroes.to.send         = 0;               /* assume no zeroes to send             */   if COM32(Offctr,Sflen) = lw#ilt   then do;                 /* if more data within sf, then do      */         i = Sectors;          /* # of sectors to send over            */      j = shl(Sectors,8);   /* # of words   to send over            */      if  (Sflen(0)-Offctr(0)) ilt 254      then do;              /* check for eof when getting close     */         k = shl(sflen(0)-offctr(0),8) + sflen(1);  /* get # of words left in sf */         if k ilt j         /* if shorter, then action must be taken */         then do;            zeroes.to.send = shr(j-k,stereo);            j=k;            /* only send over this many total        */         end;      end;      call psmread(sfbase,SfOffset(0)+Offctr(0),SfOffset(1));  /* note: SfOffset(0) includes bl.poly */      write(mam)=Scsi.Ptr;      write(mdi)=stereo;            /* 1 = stereo data being sent */      write(mdi)=j;                 /* # of words of poly data    */      write(mdi)=FirstTrack;      write(mdi)=SecondTrack;      write(mdi)=bwpos;             /* word position of buffer    */      call Send.To.Lod(196,10);     /* stream over poly data      */      bwpos = bwpos + shr(j,stereo); /* adv buf ptr in case z's   */      offctr(0) = offctr(0) + shr(j+255,8);  /* will put offctr over the top on the last transfer */   end;   else do;                          /* just zend z's             */      zeroes.to.send = shl(Sectors,8-stereo);   end;   if zeroes.to.send<>0          /* fill buffer with zeroes    */   then do;                      /* past end of sound file     */      call zero.fill(FirstTrack,bwpos,Zeroes.to.Send);      if stereo then do;         call zero.fill(SecondTrack,bwpos,Zeroes.to.Send);      end;   end;end Send.Poly.Data;/* $page - send poly data to direct to disk */Send.Poly.To.DTD:proc(sfbase,sfoffset,sflen,stereo,Record.Ready.Bits,smsb,emsb,lmsb) public swapable;   dcl sfbase            array;   /* sound file base for psmread          */   dcl sfoffset          array;   /* sector and word offset to mark start */   dcl sflen             array;   /* sector and word length to xfer       */   dcl stereo            fixed;   /* true if stereo sound file            */   dcl Record.Ready.Bits fixed;   /* pass track ready bits     */   dcl smsb              array;   /* starting sector # on disk */   dcl emsb              array;   /* ending sector # on disk   */   dcl lmsb              array;   /* length (sectors) on disk  */   dcl firsttrack        fixed;   dcl secondtrack       fixed;   dcl fadelen           fixed;   dcl FadeinSectors     fixed;   dcl DataSectors(1)    fixed;   dcl FadeOutSectors    fixed;   dcl FadeOutWpos       fixed;   dcl error(40)         fixed;   dcl sfsl              fixed;   dcl sfwl              fixed;   dcl loopstatus        fixed;   dcl offctr (1)        fixed;   /* incrementing pointer to poly memory */   dcl dctr   (1)        fixed;   /* incrementing pointer to disk        */   dcl temp   (1)        fixed;   dcl loopctr(1)        fixed;   dcl (i,j,k,l) fixed;   /* begin transfer by doing some error checks: */   i=0;               /* count # of ready tracks */   do j=0 to 15;      if (Record.Ready.Bits&bits(j))<>0 then do;         i=i+1;         if i=1 then firsttrack  = j;         if i=2 then secondtrack = j;      end;   end;   if Poly.To.DTD.Checks(i,stereo,error)=0   then return 0;   /* get current cross fade word length */   /* from direct-to-disk                */   call Send.To.Lod(34,0);         /* fetch current fade in     */   write(mam)=scsi.ptr;   write(mal)=3;   fadelen=read(md);   /* limit to 50 sector cross fade length since we */   /* assume that the direct to disk buffers        */   /* are at least 100 sectors in size              */   if fadelen igt chunk*256 then fadelen = chunk*256;  /* limit in case random # */   if fadelen  =  0         then fadelen = 1        ;  /* avoid math probs       */   /* compute some important information about the */   /* upcoming transfer                            */   sfsl = sflen(0);                      /* sector length of sf */   sfwl = sflen(1);                      /* word   length       */   if stereo then do;      sfwl = shr(sfwl,1)\shl(sfsl&1,7);  /* get sectors and words of */      sfsl = shr(sfsl,1);                /* sounf file used per trk  */   end;                                     if  (lmsb(lw#msb)=0)                     /* if disk area is shorter  */   and (lmsb(lw#lsb) ilt (sfsl+(sfwl<>0)))  /* than sound file length   */   then do;                                 /* then shorten sf (trunc)  */      sfsl=lmsb(lw#lsb);      sfwl=0;   end;   if (lmsb(lw#msb)=0)&(lmsb(lw#lsb) ilt 3) then do;      call copy.string('Start and End times are too close for punch in',error);      call set.error(err.lod,error);      return 0;   end;   /* compute 3 important variables:      FadeinSectors  =  # of complete sectors involving punch-in data      DataSectors    =  # of complete sectors involving data only      FadeOutSectors =  # of complete sectors involving fade out data        FadeOutWpos    =  word pos in last sector where fade out ends    */   FadeInSectors  = shr(fadelen+255,8);  /* # of sectors involving punch in data */   /* very important consideration:  if the sound file ends during */   /* the last sector transferred,  then we want to end the cross  */   /* fade right at the end of the sound file.   this will fill    */   /* the remaining sector with the sound recorded on the disk.    */   /* in the other case (ie truncate/fill),  the cross fade will   */   /* end at the end of the sector                                 */   if   (lmsb(lw#msb)=0)                 /* if disk space < 32 megs            */   and  (lmsb(lw#lsb)=sfsl+1)            /* and sound file ends in last sector */   and  (sfwl<>0)                        /* and sound file ends somehwere mid-sector */   then FadeOutWpos = sfwl;              /* end cross fade here  */   else FadeOutWpos = 256;               /* end at end of sector */   FadeOutSectors = FadeInSectors + (FadeOutWpos < 256);   /* make the fade in/out length shorter if we are */   /* not writing enough data to achieve the user's */   /* desired fade in/fade out times                */   if  (lmsb(lw#msb) = 0)                /* disk space < 32 megs     */   and (FadeInSectors + FadeOutSectors IGT lmsb(lw#lsb))   then do;                              /* truncate fades if disk space is very short */      FadeOutSectors = shr(lmsb(lw#lsb),1)+(FadeOutWpos < 256);      FadeInSectors  = lmsb(lw#lsb) - FadeOutSectors;      FadeLen        = shl(FadeInSectors,8);   end;   call Copy32(lmsb,DataSectors);   call Sub16(FadeInSectors+FadeOutSectors,DataSectors);   /* begin transfer of sound file to d-t-d */   if  (new.pan<>0)    then do;      call CLEAR.DISPLAY;      call EMIT.STRING( 0,'Transferring Snd');      call EMIT.STRING(16,'File to D-to-D');   end;   /* set up address counters */   call str32(0,0,offctr );  /* offctr counts sectors & words of poly data we have sent over to the dtd */   call copy32(smsb,dctr );  /* set up disk counter pointing to disk             */   call Send.To.Lod(68,0);      /* stop all other data transfer */                                /* and start function data      */                                /* read operation               */   /* begin by reading data for punch-in cross fade */   /* to the direct to disk memory buffers          */   run.syn = 0;                           /* keep button panel items from moving poly around and gloming psmwrite pointers */   call issue.read(firsttrack,dctr,0);   if stereo then do;                           call issue.read(secondtrack,dctr,0);   end;   loopstatus = wait.for.finish(firsttrack,secondtrack,stereo);   /* Now send over the data for the punch in */   if loopstatus = 0 then do;                     /* continue if not halted */      call Send.Poly.Data(FirstTrack,SecondTrack,Stereo,                          SfBase,SfOffset,SfLen,Offctr,                          FadeInSectors,shl(chunk,8));  /* # of sectors to send,  where in buffer to store it */      /* now construct cross fade */      write(mam)=Scsi.Ptr;      write(mdi)=FirstTrack;        /* track #                     */      write(mdi)=0;                 /* fade out source word ptr    */      write(mdi)=chunk*256;         /* fade in  source word ptr    */      write(mdi)=0;                 /* dest word pointer           */      write(mdi)=0;                 /* pre fade copy length        */      write(mdi)=fadelen;           /* cross fade length           */      write(mdi)=shl(FadeInSectors,8)-fadelen;  /* copy data       */      call Send.To.Lod(197,14);     /* construct cross fade        */      /* write that cross fade data to disk */      call write.poly.data(firsttrack,dctr,shl(FadeInSectors,8));      if stereo<>0 then do;         /* construct second fade       */         write(mam)=Scsi.Ptr;         write(mdi)=SecondTrack;    /* track #                     */         write(mdi)=0;              /* fade out source word ptr    */         write(mdi)=chunk*256;      /* fade in  source word ptr    */         write(mdi)=0;              /* dest word pointer           */         write(mdi)=0;              /* pre fade copy length        */         write(mdi)=fadelen;        /* cross fade length           */         write(mdi)=shl(FadeInSectors,8)-fadelen;  /* copy data       */         call Send.To.Lod(197,14);  /* construct cross fade        */         call write.poly.data(secondtrack,dctr,shl(FadeInSectors,8));      end;      call add16(FadeInSectors,dctr);      loopstatus = loopstatus \ wait.for.finish(firsttrack,secondtrack,stereo);   end;   /* now write out all of the data from the sound file that */   /* does not get modified in any way                       */   call str32(0,0,loopctr);  /* loopctr counts the # of data sectors transferred */   do while (com32(DataSectors,loopctr)<>lw#ieq) & (loopstatus=0);   /* wait for a reasonable amount of time */      call sub32(DataSectors,Loopctr,Temp);  /* get data sectors on disk remaining */      j=Temp(lw#lsb);      if  (temp(lw#msb) <>  0    )      or  (j            igt chunk)      then j  =  chunk;      call Send.Poly.Data(FirstTrack,SecondTrack,Stereo,                          SfBase,SfOffset,SfLen,Offctr,                          j,0);  /* # of sectors to send,  where in buffer to store it */      call write.poly.data(firsttrack,dctr,shl(j,8));      if stereo<>0 then do;         call write.poly.data(secondtrack,dctr,shl(j,8));      end;      call add16(j,dctr);      /* advance disk address */      call add16(j,loopctr);   /* advance loop ctr     */            loopstatus = loopstatus \ wait.for.finish(firsttrack,secondtrack,stereo);   end;   /* now we must construct the punch out */   /* begin with disk command to read     */   /* the punch out data                  */   if loopstatus = 0 then do;      call issue.read(firsttrack,dctr,0);      if stereo then do;            /* see if stereo transfer needed */         call issue.read(secondtrack,dctr,0);      end;      loopstatus = loopstatus \ wait.for.finish(firsttrack,secondtrack,stereo);   end;   /* Now send over the data for the punch out */   if (loopstatus=0) then do;      call Send.Poly.Data(FirstTrack,SecondTrack,Stereo,                          SfBase,SfOffset,SfLen,Offctr,                          FadeOutSectors,chunk*256);   /* # of sectors to send,  where in buffer to store it */      /* now construct cross fade */      i = shl(FadeOutSectors,8);    /* get # of words handy        */      write(mam)=Scsi.Ptr;      write(mdi)=FirstTrack;        /* track #                     */      write(mdi)=chunk*256;         /* fade out source word ptr    */      write(mdi)=0;                 /* fade in  source word ptr    */      write(mdi)=0;                 /* dest word pointer           */      write(mdi)=i-256+FadeOutWpos-Fadelen;     /* pre fade copy   */      write(mdi)=fadelen;           /* cross fade length           */      write(mdi)=256-FadeOutWpos;   /* post copy data              */      call Send.To.Lod(197,14);     /* construct cross fade        */      /* write that cross fade data to disk */      call write.poly.data(firsttrack,dctr,shl(FadeOutSectors,8));      if stereo<>0 then do;         /* construct second fade       */         i = shl(FadeOutSectors,8);    /* get # of words handy        */         write(mam)=Scsi.Ptr;         write(mdi)=SecondTrack;       /* track #                     */         write(mdi)=chunk*256;         /* fade out source word ptr    */         write(mdi)=0;                 /* fade in  source word ptr    */         write(mdi)=0;                 /* dest word pointer           */         write(mdi)=i-256+FadeOutWpos-Fadelen;     /* pre fade copy   */         write(mdi)=fadelen;           /* cross fade length           */         write(mdi)=256-FadeOutWpos;   /* post copy data              */         call Send.To.Lod(197,14);     /* construct cross fade        */         call write.poly.data(secondtrack,dctr,shl(FadeOutSectors,8));      end;      loopstatus = loopstatus \ wait.for.finish(firsttrack,secondtrack,stereo);   end;   run.syn = 1;            /* re allow run syns now                     */   call send.to.lod(33,0); /* restore normal play buffers               */   if  (new.pan<>0)    then do;      call CLEAR.DISPLAY;   end;   if loopstatus<>0 then do;                /* error was encountered - data not avail    */      if (loopstatus&1)<>0 then do;         /* stop button pressed   */         call DISPLAY.ERR(30);  /* LOADING HALTED */         call copy.string('Loading Halted',error);         call set.error(err.lod,error);      end;      else do;                              /* must be timeout       */         call copy.string('Track information could not be written (timeout)',error);         call set.error(err.lod,error);      end;      return 0;   end;   if  (new.pan<>0)    then do;      call EMIT.STRING( 0,'Transfer');      call EMIT.STRING(16,'Completed');   end;   return true;                 /* sound file transferred      */end Send.Poly.To.DTD;Bounce.Move.Cue.on.DTD:proc(id#, DTD.Start, Record.Ready.Bits) public swapable;   dcl id#               fixed;   /* =  0: cue is in scsi pointer and dtd  */                                  /* <> 0: id of cue to be bounced/moved   */   dcl DTD.Start         array;   /* sector # of dtd to start recording on */   dcl Record.Ready.Bits fixed;   /* pass track ready bits                 */   dcl cuetracks         fixed;   dcl rdytracks         fixed;   dcl cuetbits          fixed;   dcl rdytbits          fixed;   dcl cuelist (15)      fixed;   dcl rdylist (15)      fixed;   dcl cue.start (1) fixed;   dcl cue.end   (1) fixed;   dcl cue.len   (1) fixed;   dcl error(40)         fixed;   dcl loopstatus        fixed;   dcl dctr   (1)        fixed;   /* incrementing pointer to disk        */   dcl temp   (1)        fixed;   dcl buf.len           fixed;   dcl chunk.len         fixed;   dcl saved.syn         fixed;   dcl (i,j,k,l) fixed;   if Fetch.Entire.Cue(id#,error)=0   then do;      return 0;   end;   call COMPUTE.CUE.LENGTH.IN.SECTORS (SCSI.PTR, cue.start, cue.end, cue.len);   cuetracks = 0;   rdytracks = 0;   write(mam) = SCSI.PTR;   write(mal) = CUE.TRKS;                     /* get cue tracks    */   cuetbits   = read(md) & dtd.avail.trks;   rdytbits   = Record.Ready.Bits;            /* get rdy tracks    */   do i=0 to 15;                              /* count # of tracks */      if (cuetbits&bits(i))<>0 then do;       /* in cue and # of   */         cuelist(cuetracks) = i;              /* tracks that are   */         cuetracks = cuetracks + 1;           /* ready             */      end;      if (rdytbits&bits(i))<>0 then do;       /* also set up list  */         rdylist(rdytracks) = i;              /* to map from       */         rdytracks = rdytracks + 1;           /* source to dest    */      end;                                    /* track             */   end;   if  (cuetracks = 0) then do;      call copy.string('No tracks in cue',error);      call set.error(err.lod,error);      return 0;   end;   if  (cuetracks <> rdytracks)   then do;      call copy.string('Improper number of READY tracks',error);      call set.error(err.lod,error);      return 0;   end;   write(mam)=scsi.ptr;            /* check for record          */   write(md) =33;                  /* protection                */   call Send.To.Lod(144,2);   write(mam)=scsi.ptr;            /* check for record          */   if read(md)<>1 then do;         /* can not record            */      call Send.To.Lod(23,0);      /* hopefully get error msg   */      return 0;   end;   if lod.version < 11   then do;      call copy.string('Incompatible Direct-to-Disk software version',error);      call set.error(err.lod,error);      return 0;   end;   write(mam) = scsi.ptr;            /* get buf.len               */   write(md)  = 58;   call Send.To.Lod(144,2);   buf.len    = dtd.cue#;   if  (new.pan<>0)    then do;      call CLEAR.DISPLAY;      call EMIT.STRING( 0,'Copying Cue...  ');      /* Force an immediate update to the VK display on remote devices */      /* to provide an immediate update of the VK window display while */      /* we are transferring the sound file:                           */      if run.syn <> 0      then call Flush.VK.Display.To.Termulators;   end;   call Send.To.Lod(68,0);      /* stop all other data transfer */                                /* and start function data      */                                /* read operation               */   saved.syn  = run.syn;   run.syn    = 0;              /* disable LOD activity ...     */   call str32(0, 0, dctr);      /* initialize data pointer to 0 */   loopstatus = 0;   do while ((COM32(dctr, cue.len) <> lw#ieq)   and      (loopstatus            =  0     ));      call ADD32(cue.start, dctr, temp);      do i = 0 to cuetracks-1;  /* issue read from each track   */         call issue.read(cuelist(i), temp, 0);      end;      loopstatus = wait.for.tracks.finished(cuetracks, cuelist);      if loopstatus = 0 then do;                     /* continue if not halted */         call sub32(cue.len, dctr, Temp);            /* get data sectors on disk remaining */         chunk.len = Temp(lw#lsb);         if  (temp(lw#msb) <>  0    )         or  (chunk.len   igt buf.len)         then chunk.len  =  buf.len;         /* move data now */         /* Bizarre algorithm - works because tracks are not crossed  */         /* e.g. cuelist is in increasing order, as is rdylist        */         /* note: equal tracks don't neet to be moved                 */         do i = 0 to cuetracks-1;                     /* copy down    */            if rdylist(i) < cuelist(i)            then call issue.move.poly(cuelist(i), 0,                                      rdylist(i), 0,                                      shl(chunk.len, 8));         end;         do i = 1 to cuetracks;                       /* copy up      */            j = cuetracks - i;            if rdylist(j) > cuelist(j)            then call issue.move.poly(cuelist(j), 0,                                      rdylist(j), 0,                                      shl(chunk.len, 8));         end;         /* now write data out to disk:                               */         call ADD32(dtd.start, dctr, temp);         do i = 0 to rdytracks-1;  /* issue read from each track   */            call write.poly.data(rdylist(i), temp, shl(chunk.len,8));         end;         call add16(chunk.len, dctr);      /* advance disk address */               loopstatus = loopstatus \ wait.for.tracks.finished(rdytracks, rdylist);      end;   end;   run.syn = saved.syn;    /* re allow run syns now                     */   call send.to.lod(33,0); /* restore normal play buffers               */   if  (new.pan<>0)    then do;      call CLEAR.DISPLAY;   end;   if loopstatus<>0 then do;                /* error was encountered - data not avail    */      if (loopstatus&1)<>0 then do;         /* stop button pressed   */         call copy.string('Copy Halted',error);         call set.error(err.lod,error);      end;      else do;                              /* must be timeout       */         call copy.string('Cue could not be moved or bounced (timeout)',error);         call set.error(err.lod,error);      end;      return 0;   end;   if  (new.pan<>0)    then do;      call EMIT.STRING( 0,'Copy');      call EMIT.STRING(16,'Completed');   end;   return true;                 /* sound file transferred      */end Bounce.Move.Cue.on.DTD;