/*	$Title  :SYNSOU:STMMOD:STDRSOU  Sample To Memory Drawing RoutinesModified:1999/10/19 - TY  - Moved a block in DRAW.SOUND.FILE.NAME (See explanation there)1999/10/16 - TY  - Modified "<filename> Active on Keyboard" message to include patch info1989/04/14 - SJS - changed speech to 'ONE' and music to 'TWO'1988/12/13 - cj  - changed 'smart' to 'speech'1988/09/08 - SJS - Changed TSM length to SFTime format1988/08/25 - MWH - Add "real" DSP user interface1988/07/07 - MWH - Erase crossfade even when it's 65535 (-1)1988/06/23 - MWH - Remove unused inserts1988/05/18 - LSS - added insert -XPL:SYSLITS1988/04/18 - MWH - Add point mode and zero line1988/02/02 - MWH - Expand crossfade times to 65.535 seconds1987/12/11 - MWH - Merge poly updates with N-Final plus AEE sources1987/08/07 - MWH - Update all to support max 4 poly bins, 512mb/bin1987/02/04 - BSW - put routines in a module*/Module STDRMOD;	insert ':-xpl:catrout';			/*	for f#name_len	*/	insert ':-xpl:syslits';			/*	for mouse stuff	*/	insert ':-xpl:intrprtr';	insert ':synlits:comlits';		/*	compilation literals	*/	insert ':synlits:asciilit';	/*	ASCII literals	*/	insert ':synlits:globlits';	/*	good globals	*/	insert ':synlits:fcodlits';	/*	function code literals for FM and POLY synths (i.e., psd)	*/	insert ':synlits:samplits';	/*	sound file and sampling literals	*/	insert ':synauxs:stmlits';		/*	specific stm literals	*/	insert ':synmods:stutldcl';	/*	sample to memory utility routines	*/	insert ':synmods:strecdcl';	/*	sample.into.memory	*/	insert ':synmods:stindcl';		/*	input handling	*/	insert ':synmods:globdcl';		/*	globals, such as trd.ptr	*/	insert ':synmods:polydcl';		/*	for accessing poly memory	*/	insert ':synmods:mathdcl';		/*	for computations	*/	insert ':synmods:ttydcl';		/*	terminal i/o routines	*/	insert ':synmods:errdcl';		/*	error routines	*/	insert ':synmods:plotdcl';		/*	plotting package	*/	insert ':synmods:moussdcl';	/*	mouse routines	*/	insert ':synmods:mousrdcl';	/*	mouse routines	*/	insert ':synmods:scrndcl';		/*	screen primitive routines (i.e., print.parm)	*/	insert ':synmods:getvdcl';		/*	for new.poly.contents	*/	insert ':synmods:tformdcl';	/*	terminal formatting routines	*/	insert ':synmods:tprimdcl';	/*	primitives used by all screens (i.e., goto.this.screen)*/	insert ':synmods:getdcl';		/*	gets and checks events	*/	insert ':synmods:dspdcl';		/*	need lits from this module	*/	insert ':synrdcls:03-pdcls';	insert ':synrdcls:05-bdcls';	insert ':SYNRDCLS:11-TDCLS';	//	TDS.LINE#	dcl prompt.y		lit '18';					/*	Upper left corner of prompting area	*/	dcl prompt.x		lit '19';	dcl left.rect.minx			fixed public;	/*	left rectangle minimums and maximums	*/	dcl left.rect.miny			fixed public;	dcl left.rect.maxx			fixed public;	dcl left.rect.maxy			fixed public;	dcl right.rect.minx			fixed public;	/*	right rectangle minimums and maximums	*/	dcl right.rect.miny			fixed public;	dcl right.rect.maxx			fixed public;	dcl right.rect.maxy			fixed public;	dcl display.width				fixed public;	/*	width of display rectangle	*/	dcl display.height			fixed public;	/*	display height of display rectangle	*/	dcl landscape.bot				fixed public;	/*	bottom of landscape display	*/	dcl landscape.top				fixed public;	/*	top of landscape display	*/	dcl landscape.left			fixed public;	/*	left edge of landscape display	*/	dcl landscape.right			fixed public;	/*	right edge of landscape display box	*/	dcl landscape.start			fixed public;	/*	start of fill area	*/	dcl landscape.end				fixed public;	/*	end of fill area	*/	dcl prev.stm.vert.factor	fixed public;	/*	previous vertical scaling factor - a power of 2	*/	dcl prev.stm.hor.scale		fixed public;	/*	previous number of samples per pixel	*/	dcl prev.stm.hor.factor		fixed public;	/*	previous horizontal scaling factor	*/	dcl prev.stm.resolution		fixed public;	/*	previous block mode resolution	*/	dcl prev.stm.crossfade		fixed public;	/*	previous crossfade time	*/	dcl tsm.algorithm				fixed public;	/*	current setting of switch	*/	dcl tsm.length(2)				fixed;			/*	length of file in SFTime	*/	dcl tsm.ratio					fixed public;	/*	value: * 100	*/	dcl tsm.option					fixed public;	/*	cursor is on	*/	dcl tsm.last.option			fixed public;	/*	previous cursor option	*/	dcl tsm.max.option			fixed public;	/*	max value of tsm.option	*/	dcl tsm.pitch					fixed;			/*	fundamental pitch	*/	dcl tsm.period					fixed public;	/*	fundamental period	*/	dcl tsm.max.cut.samples		fixed public;	/*	maximum cut allowed (samples)	*/	dcl tsm.max.cut.time			fixed;			/*	maximum cut allowed (msecs)	*/	dcl tsm.justification		fixed public;	/*	1-10	*/	dcl debug.function			fixed public;	/*	DSP debug function switch	*/	dcl debug.option				fixed public;	/*	cursor is on	*/	dcl debug.last.option		fixed public;	/*	previous cursor option	*/	dcl debug.max.option			fixed public;	/*	max value of debug.option	*/	dcl debug.length(2)			fixed public;	/*	SFTime array for debug	*/	dcl debug.toggle				fixed public;	/*	Toggle for peak memory space	*/	dcl debug.start				fixed public;	dcl debug.repeat				fixed public;	dcl debug.srate				fixed public;	dcl stm.resolution			fixed public;	/*	block mode resolution (pixels/block)	*/	dcl stm.crossfade				fixed public;	/*	current crossfade time	*/	dcl stm.crossfade.drawn		fixed;			/*	true when value is drawn	*/	dcl prev.stm.symbol.index	fixed public;	/*	index to previous symbol selection from symbol catalog	*/	dcl stm.symbol.index			fixed public;	/*	index to current symbol selection	*/	dcl saving.current			fixed public;	/*	1 -> if saving current sound file	*/	dcl replace.file				fixed public;	/*	1 -> if replacing a sound file	*/	dcl pasting.edit				fixed public;	/*	1 -> if pasting edit buffer into sound file	*/	dcl fill.file					fixed public;	/*	1 -> if a filename has been specified	*/	dcl cross.loop					fixed public;	/*	1 -> if using the default crossfade time	*/	dcl unlabeling.current		fixed public;	/*	1 -> if unlabeling symbol at current cursor location	*/	dcl mix.level					fixed public;	/*	1 -> if mixing with the default volume level	*/	dcl stm.max.tlen				fixed public;	/*	maximum token length for command attributes	*/	dcl stm.record.choice		fixed public;	/*	current menu selection	*/	dcl stm.last.record.choice	fixed public;	/*	previous menu selection	*/	dcl stm.draw.mode				fixed public;	/*	0 = normal (vector), 1 = point	*/	dcl stm.is.drawing			fixed public;	/*	0 = not drawing, 1 = is	*/	dcl stm.zero.line				fixed public;	/*	0 = not there, 1 = there	*/	dcl prev.stm.sample.rate	fixed;	/*	previous sound file sample rate	*/	dcl prev.stm.left.voltage	fixed;	/*	previous left sample signal level	*/	dcl prev.stm.right.voltage	fixed;	/*	previous right sample signal level	*/	dcl stm.display.erased		fixed;	dcl stm.disp.message			fixed;	/*	number representing a display message in box	*/	/*	variables based on terminal type	*/	dcl char.offset				fixed;	/*	defines label clipping area beyond left-most edge of stereo windows	*/	dcl tic.space					fixed;	/*	distance between left or rectangle minimum and tic marks	*/	dcl min.tic						fixed;	/*	minimum y for tic mark	*/	dcl time.label.offset		fixed;	/*	offset from the origin for time labels	*/	dcl label.space				fixed;	/*	distance between left or right rectangle maximum and labels	*/	dcl min.label.offset			fixed;	/*	leftmost edge of right or left rectangle label	*/	dcl max.label.offset			fixed;	/*	rightmost edge of right or left label offset	*/	dcl sound.file.namey			fixed;	/*	y location of sound file name and caption	*/	dcl lock.name.sety			fixed;	/*	y location of locked sound file name	*/	dcl sound.file.captionx		fixed;	/*	x location of sound file caption	*/	dcl sound.file.sety			fixed;	/*	y location of sound file info	*/	dcl sound.file.name.setx	fixed;	/*	x location of current filename setting	*/	dcl sound.file.namex			fixed;	/*	x location of sound filename	*/	dcl sound.file.crossx		fixed;	/*	x location of crossfade	*/	dcl sound.file.crossms		fixed;	/*	x location of crossfade label in msec	*/	dcl sound.file.len.setx		fixed;	/*	x location of file length setting	*/	dcl sound.file.lengthx		fixed;	/*	x location of file length parameter	*/	dcl sound.file.secsx			fixed;	/*	x location of second label	*/	dcl sound.file.ratedx		fixed;	/*	x location of rate parameter	*/	dcl sound.file.ratekHz		fixed;	/*	x location of kHz label	*/	dcl sound.file.scale.sety	fixed;	/*	y location of scale setting indicator	*/	dcl sound.file.scale.setx	fixed;	/*	x location of scale setting indicator	*/	dcl sound.file.xx				fixed;	/*	x location of multiply sign	*/	dcl sound.file.vertx			fixed;	/*	x location of vertical scaling factor	*/	dcl sound.file.horx			fixed;	/*	x location of horizontal scaling factor	*/	dcl sound.file.scale.voltx	fixed;	/*	x location of vertical scale volt label	*/	dcl sound.file.scale.secx	fixed;	/*	x location of horizontal scale seconds label	*/	dcl sound.file.cursor.x		fixed;	/*	x location of file length setting	*/	dcl sound.file.cursorx		fixed;	/*	x location of file length parameter	*/	dcl sound.file.cursor.sec	fixed;	/*	x location of cursor time label	*/	dcl sound.file.cursory		fixed;	/*	y location of cursor time setting	*/	dcl sound.file.level.x		fixed;	/*	x location of sound file signal level labels	*/	dcl sound.file.levelx		fixed;	/*	x location of level parameter	*/	dcl sound.file.voltx			fixed;	/*	x location of volts label	*/	dcl sound.file.ratex			fixed;	/*	x location sound file rate	*/	dcl sound.file.reso.setx	fixed;	/*	x location of resolution label	*/	dcl sound.file.reso.sety	fixed;	/*	y location of resolution information	*/	dcl sound.file.reso.x		fixed;	/*	x location of resolution value	*/	/*	forward declarations	*/	dcl SED.COMMAND.ATTRIBUTE.DEPOSIT proc recursive;	dcl POS.STM.ALPHA.CURSOR			 proc recursive;	SET.STM.TERMINAL.DISPLAY.VARIABLES: proc swapable;	/*	sets display variables based on terminal type	*/		if mg600 then do;						/*	set the parameters for Pericom terminal	*/			display.height			 =127;	/*	height or display rectangles	*/			display.width			 =858;	/*	width of display rectangles	*/			char.offset				 =52;		/*	character offset clipping point	*/			label.space				 =10;			tic.space				 =15;		/*	distance between left or rectangle minimum and tic marks	*/			min.tic					 =11;		/*	minimum y for tic mark	*/			time.label.offset		 =41;			min.label.offset		 =20;		/*	leftmost edge of right or left rectangle label	*/			max.label.offset		 =10;		/*	rightmost edge of right or left lable offset	*/			left.rect.minx			 =60;		/*	left rectangle minimums and maximums	*/			left.rect.miny			 =497;			left.rect.maxx			 =920;			left.rect.maxy			 =left.rect.miny  + 129;			right.rect.minx		 =60;		/*	right rectangle minimums and maximums	*/			right.rect.miny		 =320;			right.rect.maxx		 =920;			right.rect.maxy		 =right.rect.miny + 129;			sound.file.namey		 =707;	/*	y location of sound file name and caption	*/			lock.name.sety			 =459;	/*	y location of locked sound file name	*/			sound.file.sety		 =684;			sound.file.cursory	 =660;	/*	y location of cursor time setting	*/			sound.file.captionx	 =426;	/*	x location of sound file caption	*/			sound.file.name.setx	 =60;		/*	x location of current filename setting	*/			sound.file.namex		 =297;	/*	x location of sound filename	*/			sound.file.len.setx	 =426;	/*	x location of file length setting	*/			sound.file.lengthx	 =527;	/*	x location of file length parameter	*/			sound.file.level.x	 =762;	/*	x location of sound file signal levels	*/			sound.file.ratedx		 =149;	/*	x location of rate parameter	*/			sound.file.ratex		 =60;		/*	x location sound file rate	*/			sound.file.ratekHz	 =230;	/*	x location of kHz label	*/			sound.file.crossx		 =202;	/*	x location of sound crossfade	*/			sound.file.crossms	 =270;	/*	x location of crossfade label in ms	*/			sound.file.secsx		 =666;	/*	x location of second label and rate setting	*/			sound.file.reso.setx	 =60;			sound.file.reso.sety	 =252;			sound.file.reso.x		 =215;			sound.file.scale.sety =277;	/*	y location of scale setting indicator	*/			sound.file.scale.setx =60;		/*	x location of scale settng indicator	*/			sound.file.vertx		 =60;		/*	x location of vertical scaling factor	*/			sound.file.scale.voltx=128;	/*	x location of volts scale value	*/			sound.file.xx			 =135;	/*	x location of multiply sign	*/			sound.file.horx		 =170;	/*	x location of horizontal scaling factor	*/			sound.file.scale.secx =238;	/*	x location of time scale secs label	*/			sound.file.cursor.x	 =426;	/*	x location of file length setting	*/			sound.file.cursorx	 =527;	/*	x location of file length parameter	*/			sound.file.cursor.sec =666;	/*	x location of cursor time label	*/			sound.file.levelx		 =843;	/*	x location of level parameter	*/			sound.file.voltx		 =914;	/*	x location of volts label	*/			landscape.bot			 =267;			landscape.top			 =landscape.bot+27;			landscape.left			 =301;			landscape.right		 =919;		end;		/*	$page	*/		else do;									/*	if a vt640 or dq640 terminal set the following display coordinates	*/			display.height			 =78;		/*	height or display rectangles	*/			display.width			 =538;	/*	width of display rectangles	*/			char.offset				 =32;		/*	character offset clipping point	*/			time.label.offset		 =26;			label.space				 =5;			tic.space				 =10;		/*	distance between left or rectangle minimum and tic marks	*/			min.tic					 =8;		/*	minimum y for tic mark	*/			min.tic					 =11;		/*	minimum y for tic mark	*/			min.label.offset		 =13;		/*	leftmost edge of right or left rectangle label	*/			max.label.offset		 =3;		/*	rightmost edge of right or left label offset	*/			left.rect.minx			 =30;		/*	left rectangle minimums and maximums	*/			left.rect.miny			 =306;			left.rect.maxx			 =570;			left.rect.maxy			 =left.rect.miny  + 80;			right.rect.minx		 =30;		/*	right rectangle minimums and maximums	*/			right.rect.miny		 =197;			right.rect.maxx		 =570;			right.rect.maxy		 =right.rect.miny + 80;			sound.file.namey		 =442;	/*	y location of sound file name and caption	*/			sound.file.sety		 =426;	/*	y location of sound file info	*/			lock.name.sety			 =282;	/*	y location of locked sound file name	*/			sound.file.cursory	 =409;	/*	y location of cursor time setting	*/			sound.file.captionx	 =256;	/*	x location of sound file caption	*/			sound.file.name.setx	 =30;		/*	x location of current filename setting	*/			sound.file.namex		 =176;	/*	x location of sound filename	*/			sound.file.len.setx	 =256;	/*	x location of file length setting	*/			sound.file.lengthx	 =318;	/*	x location of file length parameter	*/			sound.file.level.x	 =464;	/*	x location of sound file signal levels	*/			sound.file.crossx		 =118;	/*	x location of sound crossfade	*/			sound.file.crossms	 =158;	/*	x location of ms crossfade label	*/			sound.file.ratex		 =30;		/*	x location sound file rate	*/			sound.file.ratedx		 =86;		/*	x location of rate parameter	*/			sound.file.ratekHz	 =134;	/*	x location of kHz label	*/			sound.file.secsx		 =406;	/*	x location of second label and rate setting	*/			sound.file.scale.sety =155;	/*	y location of scale setting indicator	*/			sound.file.scale.setx =30;		/*	x location of scale setting indicator	*/			sound.file.vertx		 =30;		/*	x location of vertical scaling factor	*/			sound.file.scale.voltx=76;		/*	x location of volts scale value	*/			sound.file.xx			 =82;		/*	x location of multiply sign	*/			sound.file.horx		 =103;	/*	x location of horizontal scaling factor	*/			sound.file.scale.secx =148;	/*	x location of time scale secs label	*/			sound.file.cursor.x	 =256;	/*	x location of file length setting	*/			sound.file.cursorx	 =318;	/*	x location of file length parameter	*/			sound.file.cursor.sec =406;	/*	x location of cursor time label	*/			sound.file.levelx		 =516;	/*	x location of level parameter	*/			sound.file.voltx		 =564;	/*	x location of volts label	*/			landscape.bot			 =152;			landscape.top			 =landscape.bot+17;			landscape.left			 =187;			landscape.right		 =572;		end;	end SET.STM.TERMINAL.DISPLAY.VARIABLES;	/*	$Subtitle Draw and Erase left and right channel labels	*/	DRAW.RIGHT.CHANNEL.LABEL: proc public swapable;		call viewport (right.rect.minx-min.label.offset,right.rect.minx-max.label.offset,right.rect.miny,right.rect.maxy-20);	/*	label right window	*/		call window   (0,char.width,0,5);		vector_mode;		call data_level(0);		call draw_vertical_label('Right');		transparent_mode;	end DRAW.RIGHT.CHANNEL.LABEL;	DRAW.LEFT.CHANNEL.LABEL: proc public swapable;		call viewport (left.rect.minx-min.label.offset,left.rect.minx-max.label.offset,left.rect.miny,left.rect.maxy-20);	/*	label left window	*/		call window   (0,char.width,0,4);		vector_mode;		call data_level(0);		call draw_vertical_label('Left');		transparent_mode;	end DRAW.LEFT.CHANNEL.LABEL;	ERASE.RIGHT.CHANNEL.LABEL: proc public swapable;		call viewport (right.rect.minx-min.label.offset,right.rect.minx-max.label.offset,right.rect.miny,right.rect.maxy-20);	/*	label right window	*/		call window   (0,char.width,0,5);		vector_mode;		call data_level(1);		call draw_vertical_label('Right');		transparent_mode;	end ERASE.RIGHT.CHANNEL.LABEL;	ERASE.LEFT.CHANNEL.LABEL: proc public swapable;		call viewport (left.rect.minx-min.label.offset,left.rect.minx-max.label.offset,left.rect.miny,left.rect.maxy-20);	/*	label left window	*/		call window   (0,char.width,0,4);		vector_mode;		call data_level(1);		call draw_vertical_label('Left');		transparent_mode;	end ERASE.LEFT.CHANNEL.LABEL;	/*	$Subtitle Routines to Draw and Erase Sound File Information	*/	draw_time_tics: proc swapable;	/*	draws time tics	*/		dcl i	fixed;	/*	number to be printed	*/		dcl x	fixed;	/*	location of number as a result of summation	*/		do i=0 to total.time;	/*	do for total time in window	*/			if i mod 5=0 then do;				call connect(i,min.tic-3,i,tic.space);		/*	draw tic mark	*/			end;			else call connect(i,min.tic,i,tic.space);		end;		transparent_mode;	end draw_time_tics;	/*	$subtitle Routines to Draw and Erase STM Graphics Cursors	*/	DRAW.GRAPHICS.CURSORS: proc(x,channel) public swapable;		/*	draw the graphics cursors	*/		dcl x			fixed;	/*	x location within the window	*/		dcl channel	fixed;	/*	0 - left; 1 - right; 2 - both	*/		vector_mode;		call data_level(2);		if (channel = 0) or (channel = 2) then do;			call viewport(left.rect.minx+1,left.rect.maxx-1,left.rect.miny+1,left.rect.maxy-1);			/*	draw left window for sound file	*/			call window(0,display.width,0,display.height);	/*	draw left window for sound file	*/			call connect(x,0,x,display.height);		end;		if (channel = 1) or (channel = 2) then do;			call viewport(right.rect.minx+1,right.rect.maxx-1,right.rect.miny+1,right.rect.maxy-1);	/*	draw right window for sound file	*/			call window(0,display.width,0,display.height);	/*	draw left window for sound file	*/			call connect(x,0,x,display.height);		end;		vector_mode;		call data_level(0);	/*	put back in drawing mode when done	*/		transparent_mode;	end DRAW.GRAPHICS.CURSORS;	ERASE.GRAPHICS.CURSORS: proc(x,channel) public swapable;		dcl x			fixed;	/*	x location	*/		dcl channel	fixed;	/*	0 - left; 1 - right; 2 - both	*/		call DRAW.GRAPHICS.CURSORS(x,channel);	/*	erase cursor in complement mode	*/	end ERASE.GRAPHICS.CURSORS;	/*	$Subtitle Routines To Draw and Erase Sound File Information	*/	ERASE.SOUND.FILE.VERT.FACTOR: proc public swapable;	/*	erases current sound file vertical scale factor	*/		dcl (i,j)	fixed;		vector_mode;		call data_level(1);		call imove(sound.file.vertx,sound.file.scale.sety);	/*	print the vertical scale factor	*/		i=vert.zoom.table(prev.stm.vert.factor);		load i; mul 50; div 512;		i=res; j=rem;		load j; mul 100; div 512;		j=res;		alpha_mode;		call print.parm(i,0,0,3,1);		call print_digits(j,2);		vector_mode;		call data_level(0);	end ERASE.SOUND.FILE.VERT.FACTOR;	DRAW.SOUND.FILE.VERT.FACTOR: proc public swapable;		/*	draws current vertical sound file scale factor	*/		dcl (i,j)	fixed;		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if prev.stm.vert.factor<>stm.vert.factor		then call ERASE.SOUND.FILE.VERT.FACTOR;	/*	erase previous if different than current	*/		vector_mode;		call data_level(0);		call imove(sound.file.vertx,sound.file.scale.sety);	/*	print the filename length	*/		alpha_mode;		i=vert.zoom.table(stm.vert.factor);		load i; mul 50; div 512;		i=res; j=rem;		load j; mul 100; div 512;		j=res;		call print.parm(i,0,0,3,1);		call print_digits(j,2);		transparent_mode;	end DRAW.SOUND.FILE.VERT.FACTOR;	ERASE.SOUND.FILE.HOR.FACTOR: proc public swapable;		/*	erases current sound file horizontal scale factor	*/		vector_mode;		call data_level(1);		call imove(sound.file.horx,sound.file.scale.sety);	/*	print the horizontal scale factor	*/		call pstring(prev.hor.time);		vector_mode;		call data_level(0);	end ERASE.SOUND.FILE.HOR.FACTOR;	DRAW.SOUND.FILE.HOR.FACTOR: proc public swapable;	/*	draws current horizontal sound file scale factor	*/		dcl i					fixed;		dcl hor.time  (2)	fixed;	/*	total time displayed	*/		dcl start.time(2)	fixed;	/*	use **** local ***** start	time array here	*/		dcl end.time  (2)	fixed;	/*	use **** local ***** end	time array here	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		call ERASE.SOUND.FILE.HOR.FACTOR;	/*	erase previous	*/		call compute_pixel_time(0,start.time);					/*	get start time of window time	*/		call compute_pixel_time(display.width,end.time);	/*	get end time of window	*/		do i=0 to 2;	/*	find the total time displayed	*/			hor.time(i)=end.time(i)-start.time(i);		end;		call TIME_NORMALIZE(hor.time);		if CONVERT.HOR.TIME.TO.STRING(hor.time)<>0 then do;	/*	convert it to a string and put in token array	*/			vector_mode;			call data_level(0);			call imove(sound.file.horx,sound.file.scale.sety);	/*	print the horizontal scale factor of the sound file	*/			call pstring(prev.hor.time);		end;		transparent_mode;	end DRAW.SOUND.FILE.HOR.FACTOR;	ERASE.RESOLUTION: proc swapable;		/*	erases current sound file drawing resolution	*/		vector_mode;		call data_level(1);		call imove(sound.file.reso.x,sound.file.reso.sety);	/*	erase the resolution value	*/		alpha_mode;		call print.parm(prev.stm.resolution,0,0,2,0);		vector_mode;		call data_level(0);	end ERASE.RESOLUTION;	DRAW.RESOLUTION: proc public swapable;		/*	draws drawing resolution	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if prev.stm.resolution<>stm.resolution		then call ERASE.RESOLUTION;	/*	erase previous if different than current	*/		vector_mode;		call data_level(0);		call imove(sound.file.reso.x,sound.file.reso.sety);	/*	print the drawing resolution	*/		alpha_mode;		call print.parm(stm.resolution,0,0,2,0);		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.RESOLUTION;	/*	$page	*/	ERASE.CROSSFADE: proc swapable;	/*	erases current sound file crossfade time	*/		vector_mode;		call data_level(1);		call imove(sound.file.crossx,sound.file.cursory);	/*	erase the crossfade	*/		alpha_mode;		call print.parm(prev.stm.crossfade,0,0,5,0);		vector_mode;		call data_level(0);	end ERASE.CROSSFADE;	DRAW.CROSSFADE: proc public swapable;	/*	draws current sound file crossfade	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if stm.crossfade.drawn = true		then call ERASE.CROSSFADE;	/*	erase previous if different than current	*/		vector_mode;		call data_level(0);		call imove(sound.file.crossx,sound.file.cursory);	/*	print the crossfade time	*/		alpha_mode;		call print.parm(stm.crossfade,0,0,5,0);		transparent_mode;		stm.crossfade.drawn = true;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.CROSSFADE;	/*	$page	*/	ERASE.SOUND.FILE.NAME: proc public swapable;	/*	erases current sound file name	*/		vector_mode;		call data_level(1);		call imove(sound.file.namex,sound.file.namey);		/*	erase the current filename	*/		alpha_mode;		call ps(stm.file.name);		// Try area fill to get rid of descenders	   call area.fill(sound.file.namex,sound.file.namey+char.height+1,sound.file.captionx-1,sound.file.namey-5,1,0);		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.SOUND.FILE.NAME;	DRAW.SOUND.FILE.NAME: proc (name) public swapable;	/*	draws sound file name	*/		dcl i		fixed;		dcl name	fixed array;		//	The following block has been moved here (before the conditional return) because the VK window		//	should be updated even if the filename is the same, to allow showing the correct patch info		//	when stepping through a patch with the same sound file assigned to adjacent frames.		/*	update synclavier window	*/		if  (new.pan<>0)		and (ertyp=0)		and (held.psel.buttons=0)		then do;			//	assume name contains at least one character			do i = 1 to 7;						/*	space fill for emit.string	*/				if (byte(name,i)=0)				then call pbyte(name,i,sp);			end;			name(0)=8;			call CLEAR.PARAMETERS;			call CLEAR.DISPLAY;			call EMIT.STRING(0,name);			call EMIT.STRING(9,'Active on ');			call EMIT.STRING(19,TDS.PATCH.STR);			both.display=1;			supress.beat.display=1;			beat.display.time=real.milliseconds+5000;		end;		if eqstr(name,stm.file.name)=0	/*	if name is same	*/		then return 0;							/*	then no update	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		call ERASE.SOUND.FILE.NAME;		do i=0 to 4;						/*	save current sound file name	*/			stm.file.name(i)=name(i);		end;		vector_mode;		call data_level(0);		call imove(sound.file.namex,sound.file.namey);		/*	print the current filename	*/		call pstring(stm.file.name);		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.SOUND.FILE.NAME;	/*	$page	*/	ERASE.LOCK.NAME: proc public swapable;	/*	erases current sound file name	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		vector_mode;		call data_level(1);		call imove(sound.file.name.setx,lock.name.sety);	/*	print the current filename setting	*/		call pstring('Locked Filename:  ');		call pstring(lock.name);		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.LOCK.NAME;	DRAW.LOCK.NAME: proc public swapable;	/*	draws sound file name	*/		dcl i	fixed;		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		vector_mode;		call data_level(0);		call imove(sound.file.name.setx,lock.name.sety);	/*	print the current filename setting	*/		call pstring('Locked Filename:  ');		call pstring(lock.name);		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.LOCK.NAME;	/*	$page	*/	ERASE.SOUND.FILE.CAPTION: proc public swapable;	/*	erases current sound file caption	*/		vector_mode;		call data_level(1);		call imove(sound.file.captionx,sound.file.namey);		/*	erase the current caption	*/		call pstring(caption);				// Try area fill to get rid of descenders	   call area.fill(sound.file.captionx,sound.file.namey+char.height+1,screen.width,sound.file.namey-5,1,0);		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.SOUND.FILE.CAPTION;	DRAW.SOUND.FILE.CAPTION: proc public swapable;	/*	draws sound caption	*/		dcl i						fixed;		dcl caption.wrd.len	fixed;		if eqstr(stm.caption,caption)=0	/*	if caption is same	*/		then return 0;							/*	then no update	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if caption(0)<>0						/*	if previously displayed	*/		then call ERASE.SOUND.FILE.CAPTION;		caption.wrd.len=shr(stm.caption(0),1);		if stm.caption(0)		then caption.wrd.len=caption.wrd.len+1;		do i=0 to caption.wrd.len;			/*	set previous sound file caption	*/			caption(i)=stm.caption(i);		end;		vector_mode;		call data_level(0);		call imove(sound.file.captionx,sound.file.namey);	/*	print the current filename	*/		call pstring(stm.caption);		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.SOUND.FILE.CAPTION;	/*	$page	*/	ERASE.SOUND.FILE.LENGTH: proc public swapable;	/*	erases current sound file length	*/		vector_mode;		call data_level(1);		call imove(sound.file.lengthx,sound.file.sety);	/*	print the filename length	*/		alpha_mode;		call print.parm(prev.tot.time(0),0,0,3,0);		/*	seconds	*/		call pc(dot);		call print_digits(prev.tot.time(1),3);	/*	print milliseconds digits with leading zeros	*/		call pc(sp);		call print_digits(prev.tot.time(2),3);				/*	microseconds	*/		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.SOUND.FILE.LENGTH;	DRAW.SOUND.FILE.LENGTH: proc public swapable;	/*	draws current sound file length	*/		dcl i	fixed;		if compare_times(tot.time,prev.tot.time,3)=0	/*	if equal times	*/		then return 0;											/*	do nothing		*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if prev.tot.time(0)<>(-1)				/*	erase if had been displayed	*/		then call ERASE.SOUND.FILE.LENGTH;	/*	erase previous if different than current	*/		vector_mode;		call data_level(0);		call imove(sound.file.lengthx,sound.file.sety);	/*	print the filename length	*/		alpha_mode;		call print.parm(tot.time(0),0,0,3,0);	/*	seconds	*/		call pc(dot);		call print_digits(tot.time(1),3);		/*	milliseconds	*/		call pc(sp);		call print_digits(tot.time(2),3);		/*	microseconds	*/		do i=0 to 2;			prev.tot.time(i)=tot.time(i);			/*	set up previous values	*/		end;		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.SOUND.FILE.LENGTH;	/*	$page	*/	ERASE.SOUND.FILE.RATE: proc swapable;	/*	draw sound file rate	*/		vector_mode;		call data_level(1);		call imove(sound.file.ratedx,sound.file.sety);	/*	print the rate	*/		alpha_mode;		call print.parm(prev.stm.sample.rate,0,0,5,1);		vector_mode;		call data_level(0);	end ERASE.SOUND.FILE.RATE;	DRAW.SOUND.FILE.RATE: proc swapable;	/*	draw sound file rate	*/		if stm.sample.rate=prev.stm.sample.rate	/*	no change	*/		then return 0;										/*	no update	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);			/*	calculate sampling rate	*/		if prev.stm.sample.rate<>(-1)			/*	if had been displayed	*/		then call ERASE.SOUND.FILE.RATE;		vector_mode;		call data_level(0);		call imove(sound.file.ratedx,sound.file.sety);	/*	print the rate	*/		alpha_mode;		call print.parm(stm.sample.rate,0,0,5,1);		prev.stm.sample.rate=stm.sample.rate;	/*	set up the previous sampling rate	*/		transparent_mode;		if STM.EXIT.CHECK<>0 then do;			new.poly.contents = new.poly.contents \ 1;			return 1;		end;		return 0;	end DRAW.SOUND.FILE.RATE;	/*	$page	*/	ERASE.CURSOR.TIME: proc swapable;	/*	erase the graphics cursor sample time	*/		vector_mode;		call data_level(1);		call imove(sound.file.cursorx,sound.file.cursory);	/*	draw the current cursor time	*/		alpha_mode;		call print.parm(prev.cursor.time(0),0,0,3,0);	/*	seconds	*/		call pc(dot);		call print_digits(prev.cursor.time(1),3);			/*	milliseconds	*/		call pc(sp);		call print_digits(prev.cursor.time(2),3);			/*	microseconds	*/		vector_mode;		call data_level(0);		transparent_mode;	end ERASE.CURSOR.TIME;	DRAW.CURSOR.TIME: proc swapable;		/*	draw the graphics cursor sample time	*/		dcl i	fixed;		if compare_times(cursor.time,prev.cursor.time,3)=0	/*	if equal times	*/		then return 0;													/*	do nothing		*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		if prev.cursor.time(0)<>(-1)								/*	if had been drawn	*/		then call ERASE.CURSOR.TIME;		vector_mode;		call data_level(0);		call imove(sound.file.cursorx,sound.file.cursory);	/*	draw the current cursor time	*/		alpha_mode;		call print.parm(cursor.time(0),0,0,3,0);	/*	seconds	*/		call pc(dot);		call print_digits(cursor.time(1),3);		/*	milliseconds	*/		call pc(sp);		call print_digits(cursor.time(2),3);		/*	microseconds	*/		do i=0 to 2;				/*	save previous cursor time	*/			prev.cursor.time(i)=cursor.time(i);		end;		transparent_mode;		return 0;	end DRAW.CURSOR.TIME;	CHANGE.CURSOR.TIME: proc public swapable;		/*	converts the address pointed to by cursor location to a sample time	*/		call COMPUTE_PIXEL_TIME(stm.graphx,cursor.time);		call DRAW.CURSOR.TIME;	end CHANGE.CURSOR.TIME;	CHANGE.ZOOM.TIME: proc public swapable;	/*	leaves sample under cursor while zooming	*/		dcl i	fixed;		/*		Note: assumes horizontal scale has changed and cursor time has not!!		We want to leave current sample under cursor during zoom.		So, find the time difference between the new and old cursor times		before we change old cursor time and add the difference to the		start time of the display.		*/		call COMPUTE_PIXEL_TIME(stm.graphx,some.time);		/*	find new cursor time	*/		do i=0 to 2;													/*	find time difference between old and new cursor times	*/			some.other.time(i)=cursor.time(i)-some.time(i);		end;		call TIME_NORMALIZE(some.other.time);					/*	normalize the time	*/		do i=0 to 2;													/*	find new start time of display	*/			some.time(i)=start.time(i)+some.other.time(i);	/*	left or right	*/		end;		call TIME_NORMALIZE(some.time);							/*	normalize the time	*/		do i=0 to 2;			some.other.time(i)=0;									/*	compare to file limits	*/		end;		if (compare_times(some.time,some.other.time,3)>=0)	/*	if new starting time within the sound file limits	*/		and (compare_times(some.time,tot.time,3)<=0)		then call COPY_TIME(some.time,start.time);		else if (compare_times(some.time,some.other.time,3)<0) then do;	/*	if zooming in and cannot move left	*/	/*	not within the file limits, come as close as possible	*/			call ERASE.GRAPHICS.CURSORS(stm.graphx,2);		/*	place cursor on top of sample	*/			call COPY_TIME(some.other.time,start.time);			stm.graphx=COMPUTE_PIXEL_NUMBER(cursor.time);			call DRAW.GRAPHICS.CURSORS(stm.graphx,2);		end;	end CHANGE.ZOOM.TIME;	/*	$page	*/	ERASE.SAMPLE.LEVEL: proc swapable;	/*	draw sound file signal level for left and/or right channels	*/		vector_mode;		call data_level(1);		call imove(sound.file.levelx,sound.file.sety);		/*	print the voltage value	*/		alpha_mode;		call print.parm(prev.stm.left.voltage,0,1,6,3);		call imove(sound.file.levelx,sound.file.cursory);	/*	print the voltage value	*/		alpha_mode;		call print.parm(prev.stm.right.voltage,0,1,6,3);		vector_mode;		call data_level(0);	end ERASE.SAMPLE.LEVEL;	DRAW.SAMPLE.LEVEL: proc swapable;	/*	draw signal level of the current sample	*/		if  stm.left.voltage=prev.stm.left.voltage	/*	no change	*/		and stm.right.voltage=prev.stm.right.voltage		then return 0;											/*	no update	*/		call viewport(0,screen.width,0,screen.height);		call window  (0,screen.width,0,screen.height);		/*	calculate sampling rate	*/		if prev.stm.left.voltage <>(-1)		or prev.stm.right.voltage<>(-1)							/*	if had been displayed	*/		then call ERASE.SAMPLE.LEVEL;		vector_mode;		call data_level(0);		call imove(sound.file.levelx,sound.file.sety);		/*	print the signal level of the sample	*/		alpha_mode;		call print.parm(stm.left.voltage,0,1,6,3);		call imove(sound.file.levelx,sound.file.cursory);	/*	print the voltage value	*/		alpha_mode;		call print.parm(stm.right.voltage,0,1,6,3);		prev.stm.left.voltage=stm.left.voltage;		/*	set up the previous sampling rate	*/		prev.stm.right.voltage=stm.right.voltage;		transparent_mode;		return 0;	end DRAW.SAMPLE.LEVEL;	CHANGE.SIGNAL.LEVEL: proc public swapable;	/*	computes the signal level of the current sample and displays it	*/		call LOOK.UP.SF.INFO;		if sf.type=1 then do;			call COMPUTE_SIGNAL_LEVEL(SFILE.BASE);			call DRAW.SAMPLE.LEVEL;		end;	end CHANGE.SIGNAL.LEVEL;	/*	$page	*/	DRAW.TIME.LABEL: proc(i,time,lev) swapable;	/*	draws or erases the previous time tic labels	*/		dcl i		fixed;								/*	pass hor pos 0-5	*/		dcl time	fixed array;						/*	sec ms micsec		*/		dcl lev	fixed;								/*	data level			*/		draw_time: proc(i,time,lev);				/*	draws time value	*/			dcl i		fixed;							/*	pass hor pos 0-5	*/			dcl time	fixed array;					/*	sec ms micsec		*/			dcl lev	fixed;							/*	data level			*/			call move_to  (i,0);						/*	move to appropriate location	*/			alpha_mode;			call print.parm(time(0),0,0,3,0);	/*	print seconds		*/			call pc(dot);			call print_digits(time(1),3);			/*	print milliseconds digits with leading zeros	*/		end draw_time;		vector_mode;		call data_level(lev);		call viewport (left.rect.minx-time.label.offset,left.rect.maxx-time.label.offset,left.rect.miny-tic.space-5,left.rect.miny-5);			/*	label left window	*/		call window   (0,5,0,tic.space);		call draw_time(i,time,lev);				/*	print time labels	*/		call viewport (right.rect.minx-time.label.offset,right.rect.maxx-time.label.offset,right.rect.miny-tic.space-5,right.rect.miny-5);	/*	label right window	*/		call draw_time(i,time,lev);				/*	print time labels	*/		vector_mode;		call data_level(0);		transparent_mode;	end DRAW.TIME.LABEL;	/*	$page	*/	ERASE.TIME.LABELS: proc swapable;	/*	erases the time tic labels	*/		dcl (i,j,k)	fixed;		do i=0 to 5;					/*	6 axis labels		*/			write(mam)=trd.ptr+8;	/*	compare with old	*/			write(mal)=i*3;			do k=0 to 2;				some.other.time(k)=read(mdi);	/*	get old & store it	*/			end;			call DRAW.TIME.LABEL(i,some.other.time,1);	/*	erase the previous time label	*/			write(mam)=trd.ptr+8;	/*	compare with old	*/			write(mal)=i*3;			/*	erase the time label from external memory	*/			do k=0 to 2;				write(mdi)=0;			end;			if STM.EXIT.CHECK<>0 then do;				new.poly.contents = new.poly.contents \ 1;				return 1;			end;		end;		return 0;	end ERASE.TIME.LABELS;	DRAW.TIME.LABELS: proc swapable;	/*	draws the time tic labels	*/		dcl (i,j,k)	fixed;		do i=0 to 5;										/*	6 axis labels	*/			j=i*display.width/5;			call compute_pixel_time(j,some.time);	/*	get time for this pixel	*/			some.time(2)=some.time(2)+500;			/*	add 500 micsec for rnd	*/			call time_normalize(some.time);			/*	normalize					*/			write(mam)=trd.ptr+8;						/*	compare with old			*/			write(mal)=i*3;			j=0;												/*	assume equal				*/			do k=0 to 2;				some.other.time(k)=read(mdi);			/*	get old & store it		*/				if some.other.time(k)<>some.time(k)	/*	see if equal				*/				then j=1;			end;			if j<>0 then do;								/*	must update	*/				write(mal)=i*3;							/*	store new	*/				do k=0 to 2;					write(mdi)=some.time(k);				end;				call DRAW.TIME.LABEL(i,some.other.time,1);	/*	erase the previous time label	*/				call DRAW.TIME.LABEL(i,some.time,		0);	/*	draw the new time label	*/				if STM.EXIT.CHECK<>0 then do;					new.poly.contents = new.poly.contents \ 1;					return 1;				end;			end;		end;		return 0;	end DRAW.TIME.LABELS;	/*	$page	*/	DRAW.RIGHT.CHANNEL.SYMBOL: proc(text,x,mode) swapable;	/*	draws the symbol in the specified drawing mode	*/      dcl text				fixed array;	/*	symbol name	*/		dcl x					fixed;			/*	pixel location	*/		dcl mode				fixed;			/*	data_level (i.e., 0->draw, 1->erase, and 2->complement)	*/		dcl string.width	fixed;			/*	pixel width of string in alpha mode	*/		if (x>=0) and (x<=display.width) then do;	/*	if symbol is within bounds	*/			vector_mode;			call data_level(mode);						/*	set data level to complement mode	*/			if (x=display.width) and (text(0)>4) then text(0)=4;	/*	clip the string so it appears within bounds (i.e, character offset->8*4)	*/			string.width=char.width*text(0);			/*	width of string in pixels where character is 8*14	*/			call viewport(right.rect.minx+x+1,right.rect.minx+x+string.width+1,right.rect.maxy+1,right.rect.maxy+char.height);	/*	tic goes here based on current cursor loc	*/			call window  (0,string.width,0,char.height);			call move_to(0,0);			call plot (0,label.space-1);				/*	draw tic mark	*/			call viewport(right.rect.minx+x+1,right.rect.minx+x+string.width+1,				right.rect.maxy+label.space,right.rect.maxy+label.space+char.height);			call window  (0,string.width,0,char.height);			call imove(right.rect.minx+x+2,right.rect.maxy+label.space);	/*	do not glom tic mark with label	*/			call pstring(text);							/*	draw label	*/		end;		vector_mode;		call data_level(0);		transparent_mode;	end DRAW.RIGHT.CHANNEL.SYMBOL;	/*	$page	*/	DRAW.SYMBOL: proc(text,x,stereo) swapable;	/*	draws the labels at current graphics cursor location	*/		dcl text				fixed array;	/*	text	*/		dcl x					fixed;			/*	starting location	*/		dcl stereo			fixed;			/*	if stereo or mono	*/		dcl string.width	fixed;			/*	pixel width of string in alpha mode	*/		if (x>=0) and (x<=display.width) then do;	/*	if symbol is within bounds	*/			vector_mode;			call data_level(2);							/*	set data level to complement mode	*/			if (x=display.width) and (text(0)>4) then text(0)=4;	/*	clip the string so it appears within bounds (i.e, character offset->8*4)	*/			string.width=char.width*text(0);			/*	width of string in pixels where character is 8*14	*/			call viewport(left.rect.minx+x+1,left.rect.minx+x+string.width+1,left.rect.maxy+1,left.rect.maxy+char.height);			call window  (0,string.width,0,char.height);			call move_to(0,0);			call plot (0,label.space-1);				/*	draw tic mark	*/			call viewport(left.rect.minx+x+1,left.rect.minx+x+string.width+1,				left.rect.maxy+label.space,left.rect.maxy+label.space+char.height);	/*	label goes here based on current cursor loc	*/			call window  (0,string.width,0,char.height);			call imove(left.rect.minx+x+2,left.rect.maxy+label.space);	/*	do not glom tic mark	*/			call pstring(text);							/*	draw label	*/			if (stereo<>0) and (locked=0) then do;	/*	if stereo sound file and there is not a locked sound file in the other display	*/				call viewport(right.rect.minx+x+1,right.rect.minx+x+string.width+1,right.rect.maxy+1,right.rect.maxy+char.height);	/*	tic goes here based on current cursor loc	*/				call window  (0,string.width,0,char.height);				call move_to(0,0);				call plot (0,label.space-1);			/*	draw tic mark	*/				call viewport(right.rect.minx+x+1,right.rect.minx+x+string.width+1,					right.rect.maxy+label.space,right.rect.maxy+label.space+char.height);				call window  (0,string.width,0,char.height);				call imove(right.rect.minx+x+2,right.rect.maxy+label.space);	/*	do not glom tic mark with label	*/				call pstring(text);						/*	draw label	*/			end;			vector_mode;			call data_level(0);			transparent_mode;		end;					/*	of if symbol is within bounds	*/	end DRAW.SYMBOL;	ERASE.SYMBOL.AREA: proc swapable;      vector_mode;      call data_level(1);      call viewport(0,screen.width,0,screen.height);      call window  (0,screen.width,0,screen.height);      call area.fill(0,left.rect.maxy+1+char.height+1,screen.width,left.rect.maxy+1,1,0);      if (locked=0) then do;	/*	if stereo sound file and there is not a locked sound file in the other display	*/        call area.fill(0,right.rect.maxy+1+char.height+1,screen.width,right.rect.maxy+1,1,0);      end;      vector_mode;      call data_level(0);      transparent_mode;	end ERASE.SYMBOL.AREA;	ERASE.SOUND.FILE.SYMBOLS: proc swapable;	/*	Erases the displayed symbols	*/		dcl sym.name(4)	fixed;	/*	symbol name	*/		dcl x					fixed;	/*	pixel number	*/		dcl (i,j,k)			fixed;		dcl p					fixed;	/*	sound file format	*/		dcl pixel.number.offset	lit '5';	/*	offset in words from symbol entry	*/		dcl stereo.sym.offset	lit '6';	/*	offset in words from symbol entry	*/		dcl still.used.offset	lit '7';	/*	offset in words from symbol entry	*/        if interp_is_running then do;            call ERASE.SYMBOL.AREA;        end;		i=0;		do while i<max.symbols;						/*	loop over symbols in external memory and see if symbol name can be found	*/			j=i*symbol_length;						/*	look at symbol name first	*/			write(mam)=trd.ptr+9+shr(j,8);			write(mal)=j&255;			if read(md)<>0 then do;					/*	if there is a symbol here	*/				do k=0 to 4;							/*	find symbol name	*/					sym.name(k)=read(mdi);				end;				x=read(mdi);							/*	find pixel number	*/				p=read(md);								/*	find sound file format	*/               if ~interp_is_running then do;                  call DRAW.SYMBOL(sym.name,x,p);	/*	erase what was previously displayed	*/               end;				write(mam)=trd.ptr+9+shr(j,8);	/*	erase entry from external memory	*/				write(mal)=j&255;				do k=0 to symbol_length-1;					write(mdi)=0;				end;				if STM.EXIT.CHECK<>0 then do;					new.poly.contents = new.poly.contents \ 1;					return 1;				end;			end;		/*	of if there is a symbol here	*/			i=i+1;		end;			/*	of loop over symbols in external memory	*/		return 0;	end ERASE.SOUND.FILE.SYMBOLS;	/*	$page	*/	ERASE.RIGHT.CHANNEL.SYMBOL.AREA: proc swapable;      vector_mode;      call data_level(1);      call viewport(0,screen.width,0,screen.height);      call window  (0,screen.width,0,screen.height);      call area.fill(0,right.rect.maxy+1+char.height+1,screen.width,right.rect.maxy+1,1,0);      vector_mode;      call data_level(0);      transparent_mode;	end ERASE.RIGHT.CHANNEL.SYMBOL.AREA;	ERASE.RIGHT.CHANNEL.SYMBOLS: proc swapable;	/*	erases symbols drawn over the right channel display	*/		dcl sym.name(4)	fixed;		dcl (x,y,z)			fixed;		dcl (i,j)			fixed;      if interp_is_running then do;         call ERASE.RIGHT.CHANNEL.SYMBOL.AREA;      end;		i=0;		do while i<max.symbols;		/*	loop over all of the symbols in external memory	*/			x=i*symbol_length;		/*	look at symbol name	*/			write(mam)=trd.ptr+9+shr(x,8);			write(mal)=x&255;			if read(md)<>0 then do;	/*	if a symbol is found	*/				do j=0 to 4;			/*	get the name	*/					sym.name(j)=read(mdi);				end;				y=read(mdi);			/*	get the old pixel number	*/				z=read(md);				/*	determine if stereo format	*/				if z<>0 then do;		/*	if the symbol is drawn in stereo	*/					write(md)=0;		/*	indicate that this symbol is no longer drawn in stereo	*/               if ~interp_is_running then do;					   call DRAW.RIGHT.CHANNEL.SYMBOL(sym.name,y,1);	/*	erase the symbol	*/					end;				end;			end;			i=i+1;		end;	end ERASE.RIGHT.CHANNEL.SYMBOLS;	DRAW.RIGHT.CHANNEL.SYMBOLS: proc public swapable;	/*	draws the symbols of the right channel	*/		dcl sym.name(4)	fixed;		dcl (x,y,z)			fixed;		dcl (i,j)			fixed;      if interp_is_running then do;         call ERASE.RIGHT.CHANNEL.SYMBOLS;      end;		i=0;		do while i<max.symbols;		/*	loop over all of the symbols in external memory	*/			x=i*symbol_length;		/*	look at symbol name	*/			write(mam)=trd.ptr+9+shr(x,8);			write(mal)=x&255;			if read(md)<>0 then do;	/*	if a symbol is found	*/				do j=0 to 4;			/*	get the name	*/					sym.name(j)=read(mdi);				end;				y=read(mdi);			/*	get the old pixel number	*/				write(md)=1;			/*	indicate symbol is now in stereo format	*/				call DRAW.RIGHT.CHANNEL.SYMBOL(sym.name,y,0);	/*	draw the symbol	*/			end;			i=i+1;		end;	end DRAW.RIGHT.CHANNEL.SYMBOLS;	/*	$page	*/	DRAW.SOUND.FILE.SYMBOLS: proc (base) swapable;	/*	Draws the symbols in the sound file within the given limits	*/		dcl (base)		fixed array;	/*	poly base				*/		dcl symbol.time(2)	fixed;	/*	current symbol time	*/		dcl symbol.name(4)	fixed;	/*	current symbol name	*/		dcl symbol.index		fixed;	/*	symbol index of current symbol	*/		dcl start.index		fixed;	/*	symbol index to starting time of display	*/		dcl end.index			fixed;	/*	symbol index to ending time of display	*/		dcl sym.name(4)		fixed;	/*	previous symbol name	*/		dcl (i,j,k)				fixed;		dcl (p,q)				fixed;	/*	format of sound file stereo or mono	*/		dcl (x,y,z)				fixed;	/*	symbol pixel location	*/		dcl pixel.number.offset	lit '5';	/*	offset in words from symbol entry	*/		dcl stereo.sym.offset	lit '6';	/*	offset in words from symbol entry	*/		dcl still.used.offset	lit '7';	/*	offset in words from symbol entry	*/      if interp_is_running then do;         call ERASE.SYMBOL.AREA;      end;		/*	assume symbols are no longer used in display	*/		i=0;		do while i<max.symbols;			x=i*symbol_length+still.used.offset;	/*	initialize still used word	*/			write(mam)=trd.ptr+9+shr(x,8);			write(mal)=x&255;			write(md)=0;			i=i+1;		end;		start.index =FIND_TIME(base,start.time);		end.index	=FIND_TIME(base,end.time);		/*	loop over symbols in sound file that should be displayed	*/		do symbol.index=start.index to end.index-1;	/*	draw symbols from start to end time of display	*/			call psmread(base,SF.SYM,symbol.index * symbol_length);			do i=0 to 2;									/*	get symbol time	*/				symbol.time(i)=read(psd);			end;			do i=0 to 4;									/*	get symbol name	*/				symbol.name(i)=read(psd);			end;			y=COMPUTE_PIXEL_NUMBER(symbol.time);	/*	find the new pixel number for the symbol time	*/			p=stereo;										/*	set up format of the current sound file	*/			/*	loop over symbols in external memory to see if name found	*/			i=0;j=0;			do while (i<max.symbols) and (j=0);		/*	loop over symbols and see if symbol name can be found	*/				x=i*symbol_length;						/*	each symbol entry is eight words long	*/				write(mam)=trd.ptr+9+shr(x,8);		/*	symbol name (5), pixel number (1), sound file format(1), still used (1)	*/				write(mal)=x&255;				do k=0 to 4;								/*	get old symbol name	*/					sym.name(k)=read(mdi);				end;				if eqstr(sym.name,symbol.name)=0 then do;	/*	if name found	*/					j=x+pixel.number.offset;			/*	point to old pixel number	*/					write(mam)=trd.ptr+9+shr(j,8);					write(mal)=j&255;					z=read(mdi);							/*	get old pixel number		*/					q=read(md);								/*	get sound file format	*/				end;				i=i+1;			end;			/*	$page	*/			/*	if name found	*/			if j<>0 then do;				if (mg600) or (y<>z) or (p<>q) then do;   /*	if MG600 pixel numbers or formats different	*/               if ~interp_is_running then do;                  call DRAW.SYMBOL(symbol.name,z,q);	/*	erase symbol in old format at previous location	*/					end;					call DRAW.SYMBOL(symbol.name,y,p);	/*	draw symbol at new location	*/					j=x+pixel.number.offset;					write(mam)=trd.ptr+9+shr(j,8);	/*	update pixel number	*/					write(mal)=j&255;					write(mdi)=y;					write(md)=p;							/*	update symbol format	*/				end;				j=x+still.used.offset;					/*	indicate that the symbol is still being used in display	*/				write(mam)=trd.ptr+9+shr(j,8);		/*	symbol name (5), pixel number (1), sound file format (1), still used (1)	*/				write(mal)=j&255;				write(md)=1;								/*	update still used word	*/			end;												/*	of if name found	*/			/*	else new symbol	*/			else do;				i=0; j=0;				do while (i<max.symbols) and (j=0);	/*	loop over symbols in external memory and find free entry	*/					x=i*symbol_length;					/*	each symbol entry is eight words long	*/					write(mam)=trd.ptr+9+shr(x,8);	/*	symbol name (5), pixel number (1), still used (1), free (1)	*/					write(mal)=x&255;					if read(md)=0 then do;				/*	if empty entry	*/						j=1;									/*	indicate empty location found	*/						do k=0 to 4;						/*	put new symbol in external memory	*/							write(mdi)=symbol.name(k);	/*	symbol name	*/						end;						write(mdi)=y;						/*	pixel number	*/						write(mdi)=p;						/*	sound file format	*/						write(md)=1;						/*	still used in display flag	*/						call DRAW.SYMBOL(symbol.name,y,p);	/*	draw symbol on screen	*/					end;					i=i+1;				end;			end;		/*	end of if new symbol	*/			if STM.EXIT.CHECK<>0 then do;				new.poly.contents = new.poly.contents \ 1;				return 1;			end;		end;			/*	of draw symbols from start to end time of display	*/		i=0;		do while i<max.symbols;					/*	loop over symbols in external memory and see if symbol name can be found	*/			x=i*symbol_length;					/*	look at symbol name first	*/			write(mam)=trd.ptr+9+shr(x,8);			write(mal)=x&255;			if read(md)<>0 then do;				/*	if there is a symbol here	*/				do k=0 to 4;						/*	find symbol name	*/					sym.name(k)=read(mdi);				end;				z=read(mdi);						/*	find pixel number	*/				q=read(mdi);						/*	find sound file format	*/				if read(md)=0 then do;			/*	check not.used - erase symbol if not needed any more	*/               if ~interp_is_running then do;                  call DRAW.SYMBOL(sym.name,z,q);	/*	erase what was previously displayed	*/               end;                    					write(mam)=trd.ptr+9+shr(x,8);	/*	erase entry from external memory	*/					write(mal)=x&255;					do k=0 to symbol_length-1;						write(mdi)=0;					end;					if STM.EXIT.CHECK<>0 then do;						new.poly.contents = new.poly.contents \ 1;						return 1;					end;				end;			end;			i=i+1;		end;		return 0;	end DRAW.SOUND.FILE.SYMBOLS;	insert ':synsou:stmmod:stdrsoua';	/*	graphics display continued	*/	insert ':synsou:stmmod:stdrsoub';	/*	graphics display continued	*/	insert ':synsou:stmmod:stdrsouc';	/*	draw symbols catalog	*/	insert ':synsou:stmmod:stdrsoud';	/*	menu handling and cursor positioning	*/	insert ':synsou:stmmod:stdrsoue';	/*	display prompt routines	*/	insert ':synsou:stmmod:stdrsouf';	/*	display screen and update it	*/	tsm.algorithm = 1;						/*	initialize to 'ONE'	*/end STDRMOD;