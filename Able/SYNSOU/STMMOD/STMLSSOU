/* STMLSSOU - $Tittle STM Landscape Routines */DCL LANDSCAPE.ADJUST        FIXED PUBLIC;    /* IF CURRENTLY PLAYING WITH THE LANDSCAPE DISPLAY */DCL (OLS,OLE)               FIXED;DCL BOX.LENGTH              FIXED;DCL MIN.BOX.LENGTH			 FIXED;DCL BOX.HANDLE.LEFT			 FIXED;DCL BOX.HANDLE.RIGHT			 FIXED;landscape.release: proc swapable;   dcl l fixed;   if landscape.start > landscape.end then do;      l = landscape.start;      landscape.start = landscape.end;      landscape.end   = l;   end;   call STM.SOUND.EDITOR.INPUT(7,0);         /* replot landscape */end landscape.release;ERASE.LANDSCAPE.CURSOR: PROC SWAPABLE;   IF INC.STM=0 THEN RETURN;         /* DO NOT DRAW AN STM CURSOR IF NO STM */   CALL MOVE_TO(OLS,LANDSCAPE.BOT+4);   CALL    PLOT(OLS,LANDSCAPE.TOP-4);   CALL    PLOT(OLE,LANDSCAPE.TOP-4);   CALL    PLOT(OLE,LANDSCAPE.BOT+4);   CALL    PLOT(OLS,LANDSCAPE.BOT+4);END;DRAW.LANDSCAPE.CURSOR: PROC(PART,MX) SWAPABLE;   DCL PART    FIXED;   DCL MX      FIXED;   IF INC.STM=0 THEN RETURN;         /* DO NOT DRAW AN STM CURSOR IF NO STM */   DO CASE PART;      DO; OLS = mx; OLE=LANDSCAPE.END;   END;      DO; OLE = mx; OLS=LANDSCAPE.START; END;      DO; OLS = mx-BOX.HANDLE.LEFT; OLE = mx+BOX.HANDLE.RIGHT; END;   END;   IF OLS < LANDSCAPE.LEFT+1  THEN OLS = LANDSCAPE.LEFT+1;   /* RANGE CHECKS */   IF OLS > LANDSCAPE.RIGHT-1 THEN OLS = LANDSCAPE.RIGHT-1;   IF OLE > LANDSCAPE.RIGHT-1 THEN OLE = LANDSCAPE.RIGHT-1;   IF OLE < LANDSCAPE.LEFT+1  THEN OLE = LANDSCAPE.LEFT+1;   CALL MOVE_TO(OLS,LANDSCAPE.BOT+4);                    /* PLOT CURSOR */   CALL    PLOT(OLS,LANDSCAPE.TOP-4);   CALL    PLOT(OLE,LANDSCAPE.TOP-4);   CALL    PLOT(OLE,LANDSCAPE.BOT+4);   CALL    PLOT(OLS,LANDSCAPE.BOT+4);   LANDSCAPE.START = OLS;                                /* SET GLOBALS */   LANDSCAPE.END   = OLE;                                /* TO REFLECT */END;MAP.POINT.TO.LANDSCAPE.PART: proc (mx) swapable;   dcl mx  fixed;	// Before start time	if (mx < landscape.start - 3)		return -1;		   // Start time   if (mx >= landscape.start - 3) & (mx <= landscape.start + 3) & (mx < landscape.end)   	return 0;   // End Time   else if (mx > landscape.start) & (mx >= landscape.end - 3) & (mx <= landscape.end + 3)   	return 1;      // Middle (box) position   else if (mx > landscape.start) & (mx < landscape.end)   	return 2;	// After end time			else		return 3;end;/* $Subtitle Adjust Landscape Display */ADJUST.LANDSCAPE.DISPLAY: proc (repeat) public swapable;   dcl repeat        fixed;         /* if continuous */   dcl mx            fixed;         /* mouse x position */   dcl part          fixed static;  /* Which part of the landscape we are updating */   dcl code          fixed;         /* code of next event */   dcl ok.to.refresh fixed;         /* if it's okay to update the display */   START.LANDSCAPE.ADJUSTMENT:  proc(mx);      dcl mx  fixed;      part = Map.Point.To.Landscape.Part(mx);				// compute minimum box size		bitmsb = 0;																			// get # of samples in zoomed in display		bitlsb = display.width;		ratio_multiply(10,stm.sample.rate);											// get min # of milliseconds across display		ratio_multiply(time.per.lpixel[lw#den], time.per.lpixel[lw#num]);	// milliseconds * pixels / millisecond = pixels				MIN.BOX.LENGTH = bitlsb;														// save 		BOX.LENGTH     = LANDSCAPE.END - LANDSCAPE.START;		if (part < 0 || part > 2)														// scroll fwd, back handled elsewhere			return;					// limit mouse position if moving left edge		if (part == 0)		{			if      mx < landscape.left+1                 then mx = landscape.left+1;			else if mx > landscape.right-1-MIN.BOX.LENGTH then mx = landscape.right-1-MIN.BOX.LENGTH;				}				// handle scrubbing from right edge		else if (part == 1)		{			if      mx < landscape.left+1+MIN.BOX.LENGTH then mx = landscape.left+1+MIN.BOX.LENGTH;			else if mx > landscape.right-1               then mx = landscape.right-1;				}			// handle scrubbing the box		else		{			BOX.HANDLE.LEFT  = mx - landscape.start;			BOX.HANDLE.RIGHT = landscape.end - mx;		}		call Draw.Landscape.Cursor(part,mx);    	Landscape.Adjust = true;		   end START.LANDSCAPE.ADJUSTMENT;   EXIT.LANDSCAPE.ADJUSTMENT:  proc;      call Erase.Landscape.Cursor;      call Landscape.Release;      Landscape.Adjust = false;   end EXIT.LANDSCAPE.ADJUSTMENT;   call Push.Graphics.Attributes;   /* HANDLE PERICOM BUG WHERE IF YOU ARE IN POINT MODE */   /* MUST BE IN TRANSPARENT MODE FOR VECTOR MODE TO HAPPEN */   /* BUT HAVE TO DO ALPHA MODE FIRST */   IF (MG600<>0) AND (#MODE=#POINT) THEN DO;      ALPHA_MODE;      TRANSPARENT_MODE;   END;   IF #MODE <> #VECTOR THEN VECTOR_MODE;    IF #DATA.LEVEL <> 2 THEN CALL DATA_LEVEL(2);   /* WE ARE IN DESIRED MODES */   IF #BLOCKMODE  <> 0 THEN CALL BLOCKMODE_OFF;   CALL VIEWPORT(0,SCREEN.WIDTH,0,SCREEN.HEIGHT);      CALL WINDOW  (0,SCREEN.WIDTH,0,SCREEN.HEIGHT);   call mouse.switch(0);   mx = mouse(press.x);	call Start.Landscape.Adjustment(mx);		if (part < 0)												// scroll back	{		landscape.start = landscape.start - box.length;		if (landscape.start < landscape.left+1)			landscape.start = landscape.left+1;		landscape.end   = landscape.start + box.length;		landscape.release();				call Mouse.Switch(1);		call Pop.Graphics.Attributes;		return;	}		if (part > 2)	{		landscape.end = landscape.end + box.length;		if (landscape.end > landscape.right-1)			landscape.end = landscape.right-1;		landscape.start   = landscape.end - box.length;				landscape.release();				call Mouse.Switch(1);		call Pop.Graphics.Attributes;		return;	}   do while 1;      call Get_Enable(Get.Mouse.Movement);      call Get_Enable(Get.Mouse.Button);      code = Get.Next.Event;      call Get_Disable(Get.Mouse.Movement);      call Get_Disable(Get.Mouse.Button);      if code = Get.Mouse.Button then do;							// presumably a button release, but any will do...			if Landscape.Adjust<>0			then call Exit.Landscape.Adjustment;			call Mouse.Switch(1);			call Pop.Graphics.Attributes;			return;      end;      if code = Get.Mouse.Movement then do;						// mouse moved         mx = mouse(current.x);         if Landscape.Adjust<>0 then do;		 		// limit mouse position so the landscape box is not off the end of the display							// limit mouse position if moving left edge				if (part == 0)				{					if      mx < landscape.left+1                 then mx = landscape.left+1;					else if mx > landscape.right-1-MIN.BOX.LENGTH then mx = landscape.right-1-MIN.BOX.LENGTH;						}								// handle scrubbing from right edge				else if (part == 1)				{					if      mx < landscape.left+1+MIN.BOX.LENGTH then mx = landscape.left+1+MIN.BOX.LENGTH;					else if mx > landscape.right-1               then mx = landscape.right-1;						}							// handle scrubbing the box				else				{					if (mx-BOX.HANDLE.LEFT < LANDSCAPE.LEFT+1)					then mx = Landscape.Left+1+BOX.HANDLE.LEFT;					else if (mx+BOX.HANDLE.RIGHT > LANDSCAPE.RIGHT-1)					then mx = Landscape.Right - 1 - BOX.HANDLE.RIGHT;				}				// redraw cursor if position has moved            if ((part = 0) & (mx <> OLS))            or ((part = 1) & (mx <> OLE))            or ((part = 2) & (mx <> OLS+BOX.HANDLE.LEFT)) /* Center of box */            then do;                                        /* if current mouse position is different from the appropriate case above replot */               Erase.Landscape.Cursor();							// erase prior cursor               Draw.Landscape.Cursor(part,mx);            end;         end;      end;      else do;   															// Unknown event         if Landscape.Adjust<>0         then call Exit.Landscape.Adjustment;         call Mouse.Switch(1);         call Pop.Graphics.Attributes;         return;      end;   end;end ADJUST.LANDSCAPE.DISPLAY;