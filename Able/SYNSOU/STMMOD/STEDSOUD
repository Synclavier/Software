/* $Title STEDSOUD More Sound Editor Editing Commands -> Reverse Loop, Mix, Invert, Modulate *//*   12/26/96 - CJ  - Added modulate capability to mix command framework   11/18/91 - PF  - More quick update support   04/27/88 - MWH - Clean up; move some procedures since STEDLIB is too big   04/12/88 - MWH - Preserve mark start, mark end where possible   03/01/88 - LSS - fixed word lengths in header setup (off-by-one bug)   02/04/88 - MWH - Expand crossfade times to 65.535 seconds   12/14/87 - MWH - Merge poly updates with N-Final plus AEE sources   08/14/87 - MWH - Update all to support max 4 poly bins, 512mb/bin   08/07/87 - MWH - Merge with CWJ's changes   07/14/87 - MWH - new interface for PS.SETUP   03/09/87 - BSW - Started Reverse Loop command    03/23/87 - BSW - Started Mix command   04/15/87 - BSW - Tax day! Invert sound file command   04/16/87 - BSW - Started DC Trim command */ /* Set up reverse loop in a sound file */   REVERSE.LOOP:  proc (base,cross.start) public swapable;     /* reverses the loop between two selected points */      dcl base                           fixed array; /* current sound file base */      dcl cross.start                    fixed;       /* start of crossfade in token array */      dcl (begin.sec,begin.wrd)          fixed;       /* address of beginning location */      dcl (end.sec,end.wrd)              fixed;       /* address of ending location */      dcl rev.loop.time(2)               fixed;       /* reverse loop time */      dcl (rev.loop.sec,rev.loop.wrd)    fixed;       /* length of reverse loop */      dcl (tot.loop.sec,tot.loop.wrd)    fixed;       /* length of total loop time */      dcl old.base (1)                   fixed;       /* 32 bit poly base */      dcl new.base (1)                   fixed;            dcl temp.crossfade                 fixed;      dcl crossfade.time(2)              fixed;      dcl (ssec1,swrd1)                  fixed;       /* fading out address */      dcl (ssec2,swrd2)                  fixed;       /* fading in address */      dcl (dsec,dwrd)                    fixed;       /* crossfade destination address */      dcl new_number_of_symbols          fixed;       /* number of symbols in new sound file */      dcl (i,j)                          fixed;      dcl rec(POLY.HIST.REC.LEN-1)       fixed;      if inc.stmm=0 then return;              /* REVERSE LOOP is a STM release N feature */      if GET.STM.EDIT.TIMES(base)=0           /* if we cannot get good edit times */      then return;      if GET.CROSSFADE.TIME(cross.start)<>0      then call copy_time(some.time,crossfade.time);      else return;      call TIME_TO_INDEX(stm.begin.time(0),stm.begin.time(1),stm.begin.time(2),stm.sample.rate,stereo); /* find the address of the start loop time */      begin.sec=sector.numb;      begin.wrd=sector.offset;      call TIME_TO_INDEX(stm.end.time(0),stm.end.time(1),stm.end.time(2),stm.sample.rate,stereo); /* find the address of the ending time */      end.sec=sector.numb;      end.wrd=sector.offset;      call subtract.addresses(end.sec,end.wrd,begin.sec,begin.wrd);  /* find the length between the two times */      rev.loop.sec=a.sec;      rev.loop.wrd=a.wrd;      call INDEX_TO_TIME(0,rev.loop.sec,rev.loop.wrd,stm.sample.rate,stereo);  /* normalize the total loop time */      rev.loop.time(0)=time.seconds;      rev.loop.time(1)=time.milliseconds;      rev.loop.time(2)=time.microseconds;            if COMPARE_TIMES(rev.loop.time,tot.time,3)<0 then do;  /* if the reverse loop time is within limits */         /* compute cross fade time in msecs */         if crossfade.time(0) ige 65 then temp.crossfade=65535;  /* Limit to 16 bits of milliseconds */         else temp.crossfade=(crossfade.time(0)*1000)+crossfade.time(1);  /* convert to milliseconds */         /* $page */         i=0;   /* Haven't changed crossfade time yet */         /* Crossfade can't be longer than sound file before loop */         if COMPARE_TIMES(crossfade.time,stm.begin.time,3) > 0 then do;            call copy_time(stm.begin.time,crossfade.time);            i=1;         end;         /* Crossfade can't be longer than the reverse loop itself */         if COMPARE_TIMES(crossfade.time,rev.loop.time,3) > 0 then do;            call copy_time(rev.loop.time,crossfade.time);            i=1;         end;         /* notify user if we change crossfade length */         if i <> 0 then do;            temp.crossfade=(crossfade.time(0)*1000)+crossfade.time(1);  /* convert to milliseconds */            tok.ptr=0;            token(0)=tok.ptr;            call CONVERT.SAMPLE.TIME.TO.STRING(crossfade.time);  /* converts an unsigned number between 0 and 999 to a string*/            call crossfade.override;                /* tell the user */         end;         tot.loop.wrd=shl(rev.loop.wrd,1)+begin.wrd;     /* find the total loop length which is twice the loop length plus the beginning time*/         tot.loop.sec=shl(rev.loop.sec,1)+shr(tot.loop.wrd,8)+begin.sec;         tot.loop.wrd=tot.loop.wrd&255;         if CREATE.SOUND.FILE(tot.loop.sec+(tot.loop.wrd<>0)+shr(BL.POLY,8),stm.sample.rate,0,stereo)<>0 then do;            call copy32(SFILE.BASE,new.base);  /* things may have changed */            call LOOK.UP.SF.INFO;              /* so find current file name again */            if sf.type=1 then do;              /* if a sound file */               call copy32(SFILE.BASE,old.base);               call DRAW.MESSAGE('Reverse Looping Sound File...');               call PS.LOCK;                   /* lock out a reboot */               call COPY.POLY.MEM(old.base,shr(BL.POLY,8),0,new.base,shr(BL.POLY,8),0,end.sec,end.wrd);  /* copy the samples to the end of the loop */               call COPY.POLY.MEM(old.base,shr(BL.POLY,8)+begin.sec,begin.wrd,new.base,shr(BL.POLY,8)+end.sec,end.wrd,rev.loop.sec,rev.loop.wrd);  /* duplicate the loop for a reverse */               call REVERSE.WORDS(new.base,shr(BL.POLY,8)+end.sec,end.wrd,rev.loop.sec,rev.loop.wrd);  /* reverse the contents of the second part of the loop */               call GET.CROSSFADE.WRD.LEN(temp.crossfade,stm.sample.rate,stereo);               /* crossfade the reversed end loop time with the start loop time of overall loop */               call subtract.addresses(shr(BL.POLY,8)+tot.loop.sec,tot.loop.wrd,xfade.sec,xfade.wrd);               ssec1=a.sec;               swrd1=a.wrd;               call subtract.addresses(shr(BL.POLY,8)+begin.sec,begin.wrd,xfade.sec,xfade.wrd);               ssec2=a.sec;               swrd2=a.wrd;               dsec =ssec1;               dwrd =swrd1;               call POLY.CROSS.FADE(new.base,ssec1,swrd1,old.base,ssec2,swrd2,new.base,dsec,dwrd,temp.crossfade,stm.sample.rate,stereo);               /* crossfade the end time of the first part of the loop with the start loop time of the reversed part */               call subtract.addresses(shr(BL.POLY,8)+end.sec,end.wrd,xfade.sec,xfade.wrd);               ssec1=a.sec;               swrd1=a.wrd;               ssec2=shr(BL.POLY,8)+end.sec;               swrd2=end.wrd;               dsec =ssec1;               dwrd =swrd1;               call POLY.CROSS.FADE(old.base,ssec1,swrd1,new.base,ssec2,swrd2,new.base,dsec,dwrd,temp.crossfade,stm.sample.rate,stereo);               /* $page */               /* a crossfade length is lost so shift the data down by a crossfade length*/               ssec1=shr(BL.POLY,8)+end.sec+xfade.sec;     /* source */               swrd1=end.wrd+xfade.wrd;               dsec=shr(BL.POLY,8)+end.sec;                /* destination */               dwrd=end.wrd;               call subtract.addresses(rev.loop.sec,rev.loop.wrd,xfade.sec,xfade.wrd);               call COPY.POLY.MEM(new.base,ssec1,swrd1,new.base,dsec,dwrd,a.sec,a.wrd);               /* free up the block of poly memory that is a crossfade length long */               if xfade.sec<>0 then do;                  call psmread(new.base,0,bl.len);  /* read block length   */                  i=read(psd)-xfade.sec;            /* subtract crossfade length in sectors */                  call psmwrite(new.base,0,bl.len); /* update poly */                  write(psd)=i;                  call psmwrite(new.base,i,bl.len); /* set free block length to lost crossfade length */                  write(psd)=xfade.sec;                  do i=1 to 255;                    /* zero the rest of the poly memory header */                     write(psd)=0;                  end;               end;               call psmread(new.base,SF.HDR,sf.number.of.symbols);               new_number_of_symbols=read(psd);               do i=0 to 2;                  some.time(i)=0;               end;               i=0;                            /* include the symbols from the beginning of the sound file */               j=FIND_TIME(old.base,stm.end.time);                              /* to the end of the of the loop */               do while (i<j) and (new_number_of_symbols<max.symbols);  /* do while less than end loop time and number of symbols in new sound file is less than max */                  new_number_of_symbols=MOVE.SYMBOL(old.base,new.base,i,some.time,0,1);                  i=i+1;               end;                                               /* of if not a duplicate name */               /* Set MARK.END to last valid sample in file */               call subtract.addresses(tot.loop.sec,tot.loop.wrd,xfade.sec,xfade.wrd);   /* we lost a crossfade length */               i = a.sec; /* sector length */               j = a.wrd - (1+stereo); /* subtract one sample from length */               if j < 0 then do; /* need to borrow from sectors */                  j = j&255; i = i - 1;                end;               call INDEX_TO_TIME(0,i,j,stm.sample.rate,stereo);               call psmwrite(new.base,SF.HDR,sf.mark.end);               write(psd)=time.seconds;               write(psd)=time.milliseconds;               write(psd)=time.microseconds;               call SET.SYMBOL.TIME(new.base,mend,time.seconds,time.milliseconds,time.microseconds);               /* Set DATA.END the same as MARK.END */               call psmwrite(new.base,SF.HDR,sf.data.end);               write(psd)=time.seconds;               write(psd)=time.milliseconds;               write(psd)=time.microseconds;               call SET.SYMBOL.TIME(new.base,ENDNAME,time.seconds,time.milliseconds,time.microseconds);               /* Set VALID.DATA to length of data in file */               call psmwrite(new.base,SF.HDR,sf.valid.data);               write(psd)=0;               write(psd)=a.sec;               write(psd)=a.wrd;               /* Set TOTAL.LENGTH */               call psmwrite(new.base,SF.HDR,sf.total.length);               write(psd)=0;               write(psd)=a.sec;               write(psd)=a.wrd;               /* $page */               tot.loop.wrd=shl(rev.loop.wrd,1);     /* find twice the loop length*/               tot.loop.sec=shl(rev.loop.sec,1)+shr(tot.loop.wrd,8);               tot.loop.wrd=tot.loop.wrd&255;               call subtract.addresses(tot.loop.sec,tot.loop.wrd,xfade.sec,xfade.wrd);               /* Set perfect LOOP.LENGTH */               call psmwrite(new.base,SF.HDR,sf.loop.length);               write(psd)=0;               write(psd)=a.sec;               write(psd)=a.wrd;               /* Set data type */               call psmwrite(new.base,SF.HDR,sf.file.data.type);               write(psd)=512;   /* perfectly looped */               /* Set caption */               call psmwrite(new.base,SF.HDR,sf.id.field.bytes);               call copy_out_string(loopcap);               call PS.SETUP(new.base);               call PS.UNLOCK;               call SELECT.PARTIAL(0);          /* select the first partial */               call CREATE.PATCH.PARTIAL(0,NEWFNAME);          /* turn this partial into a patch partial */               call CLEAR.PARAMETERS;           /* get rid of active parms */               call ERASE.MESSAGE;               new.poly.contents = new.poly.contents \ 1;               call BUILD.POLY.HIST.REC(new.base,0,rec);               call ADD.POLY.TO.HIST(rec);            end;         end;                                   /* of creating new sound file was succesful */      end;      else call no.loop.time;   end REVERSE.LOOP;   /* $Subtitle Get Volume Level */   GET.VOLUME.LEVEL:  proc(str,str.ptr) fixed; /* Converts a substring to a fixed number */      /* returns the fixed number if successful or (-1) if unsuccessful */      dcl str      fixed array;      dcl str.ptr  fixed;      dcl parm(20) fixed;      dcl parm.ptr fixed;      dcl ch       fixed;      dcl i        fixed;      parm(0)=0;               /* copy the substring into as separate string array */      do while str.ptr<str(0);         call pbyte(parm,parm(0),byte(str,str.ptr));         parm(0)=parm(0)+1;         str.ptr=str.ptr+1;      end;      i=CONV.STR.TO.FIXED(parm,3,0);  /* convert string to fixed number */      if ertyp<>0              /* if an error occurred, return a bogus volume level */      then i=(-1);      return i;   end GET.VOLUME.LEVEL;   /* $page - part of mix subroutine */   set.up.for.mix1:proc(current.name,orig.disp.start.time,mix.name) swapable;      dcl current.name          array;         /* current sound file name */      dcl orig.disp.start.time  array;         /* time of left edge of original sound file display */      dcl mix.name              array;         /* mix sound file name */      dcl i                     fixed;      dcl y                     fixed;      current.name(0)=8;              /* save the current sound file name */      do i=1 to 4;         current.name(i)=FNBUF(i);      end;      do i=0 to 2;                    /* keep the start time of the display because look.up.sf.info clobbers it */         orig.disp.start.time(i)=start.time(i);      end;           tok.ptr=0;      tok.ptr=GET.FILENAME(token,tok.ptr,mix.name); /* get the sound file to mix with current one */      if tok.ptr=0 then return -1;     /* if getting the sound file was not successful */	  		if (tok.ptr >= token(0))         /* if end of input string, set possible mix volume		*/			y = 1000;							/* to unity.  Normal termination for modulate...		*/		else		{			i=byte(token,tok.ptr);			if i=comma then do;           /* now get the volume level to scale mix file */				tok.ptr=tok.ptr+1;				y=GET.VOLUME.LEVEL(token,tok.ptr); /* get the volume by which to adjust mix sound file */				if (y<0)				then return -1;				else if (y igt 30000) then do;					call overflow.error;					return -1;				end;			end;			else do;				call term.input.err;       /* user didn't specify a volume level */				return -1;			end;		}		      split.keyboard=0;      call COPY.KBD.TIMBRES(0,1);     /* copy current keyboard timbre */      call ERASE.KEYBOARD.TIMBRE;     /* get rid of timbre #0        */      call SELECT.PARTIAL(0);         /* select the first partial    */      call CREATE.PATCH.PARTIAL(0,current.name);     /* turn this partial into a patch partial*/      call SELECT.PARTIAL(1);         /* select the second partial   */      call CREATE.PATCH.PARTIAL(1,mix.name);         /* turn this partial into a patch partial*/      return y;   end set.up.for.mix1;   /* $Subtitle Mix Sound File */   MIX.OR.MODULATE.SF:  proc(base, code) public swapable;     /* adjusts volume of mix sound file and adds it to current sound file, also performs modulate function */      dcl base                     fixed array; /* current sound file base */		dcl code							  fixed;		   /* 0 == mix, 1 == modulate */      dcl cur.base (1)             fixed;       /* base of current sound file      					*/      dcl mix.base (1)             fixed;       /* base of mix file specified as argument 			*/      dcl new.base (1)             fixed;       /* base of new sound file with mixed sound file 	*/      dcl current.name(4)          fixed;       /* current sound file name */      dcl mix.name(4)              fixed;       /* mix sound file name */      dcl rate                     fixed;       /* current sound file sample rate */      dcl type                     fixed;       /* if current sound file is stereo */      dcl prev.part                fixed static;/* previous sound file partial */      		dcl orig.disp.start.time(2)  fixed;       /* time of left edge of original sound file display */      		dcl orig.mark.start.time(2)  fixed;       /* mark start time of current file */      dcl orig.mark.start.sec      fixed;       /* sector, word of mark start */      dcl orig.mark.start.wrd      fixed;		dcl orig.mark.end.time(2)    fixed;       /* mark end time of current file */		dcl orig.secs					  fixed;			/* sectors of data in original file */				dcl orig.data.secs           fixed;			/* num of sectors from mark start to end of data */		dcl orig.data.wrds			  fixed;			/* num of words   from mark start to end of data */           dcl mix.mark.start.time(2)   fixed;       /* mark start time of mix file */      dcl mix.mark.start.sec       fixed;       /* address of mix mark start time */      dcl mix.mark.start.wrd       fixed;		dcl mix.mark.end.time(2)     fixed;       /* mark end time of mix file */		dcl mix.secs					  fixed;			/* sectors of data in mix file */				dcl mix.data.secs            fixed;			/* num of sectors from mark start to end of data */		dcl mix.data.wrds			     fixed;			/* num of words   from mark start to end of data */     		dcl (data.secs, data.wrds)   fixed;						dcl new.secs					  fixed;		dcl new.time(2)              fixed;		      dcl old_number_of_symbols    fixed;       /* number of symbols in old sound file */      dcl new_number_of_symbols    fixed;       /* number of symbols in new sound file */		dcl mix_number_of_symbols    fixed;				dcl (i,j,k,l,m,x,y) fixed;				      dcl rec(POLY.HIST.REC.LEN-1) fixed;		dcl r13   lit '"313"'; /* register 13 - always free */		dcl mr13  lit '"353"'; /* memory r13 */		dcl mr13i lit '"373"'; /* memory r13 then increment - used for buffering via r13 */      RECOVER.KEY.TIMBRE:  proc fixed;       	/* recovers current keyboard timbre and erases it from old location */         call COPY.KBD.TIMBRES(1,0);          	/* copy split to keyboard */         call ERASE.TIMBRE(1);                	/* erase split */         call SELECT.PARTIAL(prev.part);      	/* select the old partial */      end RECOVER.KEY.TIMBRE;     	   if inc.stmm=0 then return;      				/* a Post M feature */      rate=stm.sample.rate;           				/* save the sampling rate of the current sound file */      type=stereo;                    				/* also type        */      prev.part=FIND.PARTIAL;         				/* remember the previously selected partial in case of error */      y = SET.UP.FOR.MIX1(current.name, orig.disp.start.time, mix.name);      if y<0      then return;                    				/* set up for mix #1 */      if ertyp<>0 then do;         call RECOVER.KEY.TIMBRE;         return;      end;		/* Stash some info about the current sound file: */		      call SELECT.PARTIAL(0);         				/* select the current sound file */      		call LOOK.UP.SF.INFO;           				/* check if it is okay */      		if sf.type<>1 then do;          				/* if not a sound file */         call RECOVER.KEY.TIMBRE;         return;      end;		call copy32(SFILE.BASE,cur.base);    		/* stash pointer to original current sound file */	   call psmread(cur.base,0,bl.len);     		/* file get sector length */      orig.secs = read(psd) - shr(BL.POLY,8);				call psmread(cur.base,SF.HDR,sf.mark.start);  	/* find the mark start of the original sound file	*/		do i=0 to 2;			orig.mark.start.time(i) = read(psd);			/* get original mark start time							*/		end;		call TIME_TO_INDEX(orig.mark.start.time(0), orig.mark.start.time(1), orig.mark.start.time(2), stm.sample.rate, stereo);		orig.mark.start.sec = sector.numb;			  		/* get sector and offset of original mark start		*/		orig.mark.start.wrd = sector.offset;     		call psmread(cur.base,SF.HDR,sf.mark.end);  		/* find the mark end of the original sound file		*/		do i=0 to 2;			orig.mark.end.time(i) = read(psd);				/* get original mark end time								*/		end;     		orig.data.secs = orig.secs - orig.mark.start.sec;		orig.data.wrds = 0         - orig.mark.start.wrd;				if (orig.data.wrds < 0)		{			orig.data.wrds = orig.data.wrds + 256;			orig.data.secs = orig.data.secs - 1;		}			  	   /* Stash some info about the mix file: */			   call SELECT.PARTIAL(1);         				/* select second mix sound file */     	   call LOOK.UP.SF.INFO;     	   if sf.type<>1 then do;          				/* if not a sound file     */         call COPY_TIME(orig.disp.start.time,start.time);         call RECOVER.KEY.TIMBRE;         return;      end;      		if stereo<>type then do;               	/* check sound file types */         call COPY_TIME(orig.disp.start.time,start.time);         call RECOVER.KEY.TIMBRE;         call incompat.sf.types;             	/* must both be mono or both stereo */         return;      end;     	   if stm.sample.rate<>rate then do;      	/* check sampling rates */         call COPY_TIME(orig.disp.start.time,start.time);         call RECOVER.KEY.TIMBRE;         call incompat.sf.rates;         return;      end;      call copy32(SFILE.BASE,mix.base);			   call psmread(mix.base,0,bl.len);     		/* file get sector length */      mix.secs = read(psd) - shr(BL.POLY,8);		call psmread(mix.base,SF.HDR,sf.mark.start);  /* find the mark start of the mix sound file */		do i=0 to 2;			mix.mark.start.time(i) = read(psd);		end;				call TIME_TO_INDEX(mix.mark.start.time(0), mix.mark.start.time(1), mix.mark.start.time(2), stm.sample.rate, stereo);		mix.mark.start.sec = sector.numb;		mix.mark.start.wrd = sector.offset;				call psmread(mix.base,SF.HDR,sf.mark.end);  		/* find the mark end of the mix sound file			*/		do i=0 to 2;			mix.mark.end.time(i) = read(psd);				/* get mix mark end time									*/		end;		mix.data.secs = mix.secs - mix.mark.start.sec;		mix.data.wrds = 0        - mix.mark.start.wrd;				if (mix.data.wrds < 0)		{			mix.data.wrds = mix.data.wrds + 256;			mix.data.secs = mix.data.secs - 1;		}						/* Consistency-check a few things... */		      if (orig.mark.start.sec IGE orig.secs)			/* inconsistent sound file								 */		or (mix.mark.start.sec  IGE mix.secs )			/* inconsistent sound file                       */		or (orig.mark.start.sec + mix.data.secs + 1  ILE orig.mark.start.sec)	/* indicates overflow */		or (orig.mark.start.sec + mix.data.secs + 20 ILE orig.mark.start.sec)	/* indicates overflow */		or (orig.mark.start.sec + mix.data.secs + 20 ILE 20                 )	/* indicates overflow */		then do;         call nomem.error;         call COPY_TIME(orig.disp.start.time,start.time);         call RECOVER.KEY.TIMBRE;         return;      end;						/* See how big of an output file we need: */		if (code == 0)												/* for mix, use all of orig file up to mark		*/		{																/* start, then longest data area						*/			new.secs = orig.mark.start.sec + mix.data.secs + shr(orig.mark.start.wrd + mix.data.wrds + 255, 8);						if (orig.secs IGT new.secs)						/* if original was longer, then use it...			*/				new.secs = orig.secs;		}				else															/* for modulate, use shorter of two... 			*/		{			if ((mix.data.secs ILT orig.data.secs)			||  (mix.data.secs ==  orig.data.secs && mix.data.wrds ILT orig.data.wrds))			{				data.secs = mix.data.secs;						/* use length of data area in mix file				*/				data.wrds = mix.data.wrds;						/* if it is shorter										*/			}			else			{				data.secs = orig.data.secs;					/* else use length of data area in orig file		*/				data.wrds = orig.data.wrds;					/* if it is shorter...									*/			}						new.secs = data.secs + shr(data.wrds + 255, 8);		}		/* allocate space in poly memory for the new sound file: */      if CREATE.SOUND.FILE(new.secs+shr(BL.POLY,8), stm.sample.rate, 0, stereo) <>0 then do;  /* if it is possible to create a sound file large enough */         call copy32(SFILE.BASE,new.base);   /* save pointer to output file					*/         call PS.LOCK;                 		/* lock out a reboot */			if (code == 0)			{         	call DRAW.MESSAGE('Mixing Sound Files...');         					call COPY.POLY.MEM(cur.base, shr(BL.POLY,8), 0,		/* copy all of original sound file	*/				                   new.base, shr(BL.POLY,8), 0,		/* into place								*/										 orig.secs, 0);								while (orig.secs ILT new.secs)							/* zero fill after original			*/				{					call psmwrite(new.base, shr(BL.POLY,8) + orig.secs, 0);										rpc	128;													/* write 256 zeroes...					*/					write(psd) = 0;										rpc	128;					write(psd) = 0;										orig.secs = orig.secs + 1;					timeshare_with_host();				}								/* now add in the mix file, scaling by volume setting 'y'. Line up the data such that	*/				/* the mark start from the mix file lines up with the mark start of the original			*/				/* file...																										*/								i = orig.mark.start.sec;									/* initialize working pointer			*/				j = orig.mark.start.wrd;								k = mix.mark.start.sec;				l = mix.mark.start.wrd;								while (mix.data.secs != 0 || mix.data.wrds != 0)	/* process all of mix data				*/				{					if (mix.data.wrds == 0)									/* compute partial sector if any, 	*/					{																/* otherwise process a full sector	*/						mix.data.secs = mix.data.secs - 1;						mix.data.wrds = mix.data.wrds + 256;					}					               call psmread(new.base, shr(BL.POLY,8) + i, j);               call poly.in(addr(misc.buf(0)), mix.data.wrds);					               call psmread(mix.base, shr(BL.POLY,8) + k, l);									write(r13) = addr(misc.buf(0));										do m = 0 to mix.data.wrds-1;												x = read(psd);											/* get mix sample							*/												if (x < 0)												/* if mix value is negative			*/						{							load 	-x;											/* load abs(x)								*/							uload	500;											/* add 500 to product					*/							mul	y;												/* compute abs(x)*y+500					*/														if (URES >= 500)									/* overflow would occur					*/								x = -32768;										/* clip										*/														else							{								div	1000;								x = -res;							}														if (read(mr13) >= 0)								/* if orig sample is positive,		*/								x = x + read(mr13);							/* just sum; no overflow possible	*/							else							{								x = x + read(mr13);							/* else sum and then perform			*/																					/* an overflow check						*/								if (x >= 0)									x = -32768;							}						}												else														/* mix value is positive				*/						{							load 	x;												/* load x  									*/							uload	500;											/* add 500 to product					*/							mul	y;												/* compute x*y+500						*/														if (URES >= 500)									/* overflow would occur					*/								x = 32767;														else							{								div	1000;								x = res;							}							if (read(mr13) < 0)								/* if orig sample is negative,		*/								x = x + read(mr13);							/* just sum; no overflow possible	*/														else							{								x = x + read(mr13);							/* else sum and then perform			*/																					/* an overflow check						*/								if (x < 0)									x = 32767;							}						}												write(mr13i) = x;										/* store output sample					*/					end;					               call psmwrite(new.base, shr(BL.POLY,8) + i, j);               call poly.out(addr(misc.buf(0)), mix.data.wrds);										j = j + mix.data.wrds;									/* advance read pointer by words		*/																					/* processed								*/					if (j >= 256)					{						j = j - 256;						i = i + 1;					}										l = l + mix.data.wrds;									/* advance read pointer by words		*/																					/* processed								*/					if (l >= 256)					{						l = l - 256;						k = k + 1;					}										mix.data.wrds = 0;										/* done with this many words			*/					timeshare_with_host();				}											/* copy symbols from original sound file to output file */         	call psmread(cur.base, SF.HDR, sf.number.of.symbols);  /* mix symbols in the sound file headers */				old_number_of_symbols=read(psd);				call psmread(new.base, SF.HDR, sf.number.of.symbols);				new_number_of_symbols=read(psd);					do j=0 to 2;                                           /* no differences between symbol times */					some.time(j)=0;				end;								i=0;				do while (i<old_number_of_symbols) and (new_number_of_symbols<max.symbols);					new_number_of_symbols=MOVE.SYMBOL(cur.base,new.base,i,some.time,0,1);   /* insert all of the symbols into the new sound file */					i=i+1;				end;					/* mix symbols in the sound file headers */				call psmread(mix.base,SF.HDR,sf.number.of.symbols);				mix_number_of_symbols = read(psd);				if compare_times(orig.mark.start.time, mix.mark.start.time,3)>0 then do; /* if the mark start of the current sound file starts after mix sound file */					do j=0 to 2;						some.time(j)=orig.mark.start.time(j)-mix.mark.start.time(j);					end;					j=1;      /* add the time change to the mix symbol */				end;				else do;					do j=0 to 2;						some.time(j)=mix.mark.start.time(j)-orig.mark.start.time(j);					end;					j=0;      /* subtract the time change from the mix symbol */				end;				call TIME_NORMALIZE(some.time);				i=0;				do while (i<mix_number_of_symbols) and (new_number_of_symbols<max.symbols);					new_number_of_symbols=MOVE.SYMBOL(mix.base, new.base, i ,some.time, j, 0);   /* insert all of the symbols into the new sound file */					i=i+1;				end;			}			/* handle modulate case */						else			{				dcl left_over   fixed;				dcl (secs,wrds) fixed;				dcl outsec      fixed;				dcl outwrd      fixed;				         	call DRAW.MESSAGE('Modulating Sound Files...');								i = orig.mark.start.sec;									/* initialize working pointer			*/				j = orig.mark.start.wrd;								k = mix.mark.start.sec;				l = mix.mark.start.wrd;								if (data.wrds != 0)					left_over = 256 - data.wrds;				else					left_over = 0;									secs = data.secs;												/* get working copy of length			*/				wrds = data.wrds;								outsec = 0;				outwrd = 0;								while (secs != 0 || wrds != 0)							/* generate needed output words		*/				{					if (wrds == 0)												/* compute partial sector if any, 	*/					{																/* otherwise process a full sector	*/						secs = secs - 1;						wrds = wrds + 256;					}					               call psmread(cur.base, shr(BL.POLY,8) + i, j);	/* read original samples				*/               call poly.in(addr(misc.buf(0)), wrds);					               call psmread(mix.base, shr(BL.POLY,8) + k, l);	/* read modulator samples				*/									write(r13) = addr(misc.buf(0));										do m = 0 to wrds-1;						x = read(mr13) % read(psd);						/* perform signed fract multiply		*/						write(mr13i) = shl(x,1) | (rot(res,1) & 1);	/* extract bits 30:15					*/					end;					               call psmwrite(new.base, shr(BL.POLY,8) + outsec, outwrd);               call poly.out(addr(misc.buf(0)), wrds);										j = j + wrds;												/* advance read pointer by words		*/																					/* processed								*/					if (j >= 256)					{						j = j - 256;						i = i + 1;					}										l = l + wrds;												/* advance read pointer by words		*/																					/* processed								*/					if (l >= 256)					{						l = l - 256;						k = k + 1;					}										outwrd = outwrd + wrds;									/* advance output pointer by words	*/																					/* processed								*/					if (outwrd >= 256)					{						outwrd = outwrd - 256;						outsec = outsec + 1;					}										wrds = 0;													/* done with this many words			*/					timeshare_with_host();				}											/* zero fill remaining block */								if (left_over != 0)				{               call psmwrite(new.base, shr(BL.POLY,8) + outsec, outwrd);					rpc left_over;					write(psd) = 0;				}								/* Set mark start and mark end.  Mark start of the output file is 0, since		*/				/* we (in effect) extracted from the mark start to the mark end of the			*/				/* original file.  Set the mark end to be the shorter of the data processed,	*/				/* the original mark start - mark end, or the modulator mark start - mark end	*/								new.time(0) = 0; new.time(1) = 0; new.time(2) = 0;				        		call add_mark(new.base, mstart, new.time);				     			call INDEX_TO_TIME(0, data.secs, data.wrds, stm.sample.rate, stereo);				new.time(0)=time.seconds;				new.time(1)=time.milliseconds;				new.time(2)=time.microseconds;        						call SUB.SF.TIME(orig.mark.end.time, orig.mark.start.time, orig.mark.end.time);				call SUB.SF.TIME(mix.mark.end.time,  mix.mark.start.time,  mix.mark.end.time );      						if (COMPARE_TIMES(orig.mark.end.time, new.time, 3) < 0)					COPY_TIME(orig.mark.end.time, new.time);								if (COMPARE_TIMES(mix.mark.end.time,  new.time, 3) < 0)					COPY_TIME(mix.mark.end.time,  new.time);								call add_mark(new.base, mend, new.time);												/* reset screen display to same point in modulated file, or 0 if original display	*/				/* point was before the mark start:																	*/				      		if (COMPARE_TIMES(orig.disp.start.time, orig.mark.start.time, 3) <0)				{					orig.disp.start.time(0) = 0;		/* if we were looking at the SF before the mark	*/					orig.disp.start.time(1) = 0;		/* start point, then show from 0.000 000			*/					orig.disp.start.time(2) = 0;				}				else					call SUB.SF.TIME(orig.disp.start.time, orig.mark.start.time, orig.disp.start.time);			}			/* Set data type */         			call psmwrite(new.base,SF.HDR,sf.file.data.type);         write(psd)=128;   /* Mixed Data */         /* Set caption */         call psmwrite(new.base,SF.HDR,sf.id.field.bytes);						if (code == 0)            call copy_out_string(mixcap);			else			   call copy_out_string(modcap);				         call PS.SETUP(new.base);          /* set up new file */         call PS.UNLOCK;         call ERASE.KEYBOARD.TIMBRE;         call COPY.KBD.TIMBRES(0,1);       /* clear the split keyboard timbre */         call SELECT.PARTIAL(0);           /* select the first partial */         call CREATE.PATCH.PARTIAL(0,NEWFNAME);     /* create a patch timbre */         call CLEAR.PARAMETERS;            /* clear all previous active parameters */         call clear.display;               /* clear the Synclavier window */         call ERASE.MESSAGE;               /* erase the mixing message */			         call COPY_TIME(orig.disp.start.time, start.time);         new.poly.contents = new.poly.contents \ 1;         call BUILD.POLY.HIST.REC(new.base,0,rec);         call ADD.POLY.TO.HIST(rec);      end;      else do;                              /* cannot create a sound file large enough */         call COPY_TIME(orig.disp.start.time,start.time);         call RECOVER.KEY.TIMBRE;      end;   end MIX.OR.MODULATE.SF;   /* $Subtitle Invert Sound File */   INVERT.SOUND.FILE:  proc(base) public swapable;   /* inverts the phase of a sound file */      dcl base		fixed array;  /* current sound file base */      dcl old.base (1)	fixed;  /* original sound file base */      dcl flag				fixed;  /* if current file has to be copied over */      dcl (i, k)			fixed;      dcl #secs			fixed;  /* sector length of file */      dcl rec(POLY.HIST.REC.LEN-1) fixed;      call DRAW.MESSAGE('Inverting soundfile...');      		flag=1;										/* assume it's okay to invert the sound file */		call copy32(base,old.base);			/* initialize our local copy */		call psmread(base,0,bl.saved);		/* if the file is saved */		if (read(psd)<>0) or (locked<>0) then do;			/* copy it over to another area in memory */			if COPY.CURRENT.SOUND.FILE(base)<>0 then do;	/* if successful in copying it over */				call LOOK.UP.SF.INFO;				call copy32(SFILE.BASE,old.base);			end;			else flag=0;		end;      if flag<>0 then do;						/* it is okay to invert the current sound file */         call PS.LOCK;							/* lock out a reboot */         call psmread(old.base,0,bl.len);	/* read the file length in sectors */         #secs=read(psd)-shr(bl.poly,8);	/* determine number of sectors of valid data */         do i = 0 to #secs-1;					/* loop over samples */				psmread(old.base,shr(BL.POLY,8)+i,0);  /* get sample */				poly.in(addr(copy.buf(0)),alt.copy.blen);				do k=0 to alt.copy.blen-1;					/* invert the samples */					copy.buf(k)	= (-1) - copy.buf(k);	/* introduces a slight dcoffset */				end;				psmwrite(old.base,shr(BL.POLY,8)+i,0);				poly.out(addr(copy.buf(0)),alt.copy.blen);				timeshare_with_host();         end;         call PS.UNLOCK;         call dealloc(0);         call ps.setup(old.base);         call alloc.timbre(0);         call CHANGE.CURSOR.TIME;         call CHANGE.SIGNAL.LEVEL;         new.poly.contents = new.poly.contents \ 1;         if (com32(old.base,base) <> lw#ieq)   /* if we actually created a new sound file */         then do;                              /* log it in the hist buffer */				BUILD.POLY.HIST.REC(old.base,0,rec);				ADD.POLY.TO.HIST(rec);         end;     	 call ERASE.MESSAGE;      end;                               /* of it's okay to invert the sound file */         end INVERT.SOUND.FILE;   /* $Subtitle Trim Dc Offset from Sound File */   DC.TRIM.SOUND.FILE:  proc (base) public swapable;      dcl base    fixed array;   /* current sound file base */      dcl old.base (1)  fixed;   /* 32 bit poly base */      dcl flag          fixed;   /* if current file has to be copied over */      dcl (i, k)			fixed;      dcl (x, y)			fixed;   /* sample values */      dcl (hi,mid,lo)   fixed;   /* 48-bit running sum of sound file samples */      dcl (msb,lsb)     fixed;   /* 32 bit number of samples */      dcl sign          fixed;   /* sign of running summation of samples */      dcl dcoffset      fixed;   /* dc offset from sound file origin*/      dcl #secs         fixed;   /* sector length of file */      dcl rec(POLY.HIST.REC.LEN-1) fixed;      call DRAW.MESSAGE('Trimming DC from Sound File...');		flag=1;										/* assume it's okay to trim the DC offset from the sound file */		call copy32(base,old.base);			/* initialize our local copy */		call psmread(base,0,bl.saved);		/* if the file is saved */		if (read(psd)<>0) or (locked<>0) then do;        /* copy it over to another area in memory */			if COPY.CURRENT.SOUND.FILE(base)<>0 then do;  /* if successful in copying it over */				call LOOK.UP.SF.INFO;				call copy32(SFILE.BASE,old.base);			end;			else flag=0;		end;      if flag<>0 then do;                /* it is okay to trim the current sound file */         call PS.LOCK;                   /* lock out a reboot */         call psmread(old.base,0,bl.len);   /* read the file length in sectors */         #secs=read(psd)-shr(bl.poly,8); /* determine number of sectors of valid data */         do i = 0 to #secs-1;           /* loop over samples and add them all together into a 48-bit number*/				call psmread(old.base,shr(BL.POLY,8)+i,0);  /* get sample */				call poly.in(addr(copy.buf(0)),alt.copy.blen);				do k=0 to alt.copy.blen-1;    /* add all of the samples */					x=copy.buf(k);					if x>0 then do;        /* if a positive sample */						if sign=0 then do;  /* if a positive running sum */							lo=lo+x;							if lo ilt x then do; /* overflow */								mid=mid+1;        /* add to the middle 16 bits */								if mid=0          /* if middle was negative carry over to the hi 16 bits */								then hi=hi+1;							end;						end;                /* of if a positive running sum */						else do;            /* if a negative running sum */							if (lo ile x) and ((hi\mid)=0) then do;  /* if a sign change will occur with the addition	*/								lo=x-lo;								sign=0;       /* indicate that the sign of the running sum has changed */							end;							else do;         /* if no running sum sign change */								if (lo ilt x) then do;  /* borrow from the others */									if mid=0             /* if nothing to borrow from the middle 16-bits */									then hi=hi-1;        /* steal it from the high */									mid=mid-1;								end;								lo=lo-x;							end;						end;					end;                   /* of if a positive sample */					/* $page */					else do;               /* if a negative sample */						x=abs(x);           /* change sample to an unsigned number */						if sign<>0 then do; /* if the running sum is negative */							lo=lo+x;							if lo ilt x then do; /* overflow */								mid=mid+1;    /* carry over to middle 16 bits */								if mid=0      /* if middle word was negative */								then hi=hi+1; /* carry over to the high */							end;						end;                /* of if the running sum is negative */						else do;            /* if running sum is positive */							if (lo ile x) and ((hi\mid)=0) then do;  /* if a sign change is about to happen */								lo=x-lo;								sign=1;       /* indicate sign of running sum is now negative */							end;             /* of sign change */							else do;         /* running sum becomes less negative */								if lo ilt x   /* need to borrow */								then do;									if mid=0 									then hi=hi-1;									mid=mid-1;								end;								lo=lo-x;							end;             /* of running sum becomes less */						end;                /* of if running sum is positive */					end;                   /* of if a negative sample */				end;				timeshare_with_host();         end;         /* find the number of samples */         load #secs; mul 256;         msb=ures; lsb=res;         /* shift the 32-bit number of samples and the 48-bit sum of samples for the averaging */         do while msb<>0;    /* shift the 32-bit # of samples into 16 bits */            lsb=shr(lsb,1);            if msb            then lsb=lsb\"100000";            msb=shr(msb,1);                             /* shift the 48 bits of summation into 32 bits */            lo=shr(lo,1);            if mid            then lo=lo\"100000";            mid=shr(mid,1);            if hi            then mid=mid\"100000";            hi=shr(hi,1);         end;         /* find the dc offset */         load lo; uload mid;         div lsb;         dcoffset=res;         if rem ige shr(lsb,1)     /* round */         then dcoffset=dcoffset+1;         if sign<>0                /* if the running sum of average was negative */         then dcoffset=-dcoffset;  /* the dcoffset is negative */         /* $page */         /* if there is a dcoffset */         if dcoffset<>0 then do;            do i = 0 to #secs-1;     /* loop over samples and add in dcoffset*/					call psmread(old.base,shr(BL.POLY,8)+i,0);  /* get sample */					call poly.in(addr(copy.buf(0)),alt.copy.blen);					do k=0 to alt.copy.blen-1;						x=copy.buf(k);						y=x-dcoffset;                     /* subtract the dc offset */						if (x xor dcoffset)<0 then do;    /* if sign is different*/							if (x xor y)<0 then do;        /* if overflow */								if x<0 then y=32768;        /* clip z at the lower bounds */								else        y=32767;        /* otherwise at the upper bounds */							end;						end;						copy.buf(k)=y;					end;					call psmwrite(old.base,shr(BL.POLY,8)+i,0);					call poly.out(addr(copy.buf(0)),alt.copy.blen);					timeshare_with_host();            end;         end;                                          /* of if there is a dc offset */         call PS.UNLOCK;         call dealloc(0);         call ps.setup(old.base);         call alloc.timbre(0);         call CHANGE.CURSOR.TIME;         call CHANGE.SIGNAL.LEVEL;         new.poly.contents = new.poly.contents \ 1;         if (com32(old.base,base) <> lw#ieq)   /* if we actually created a new sound file */         then do;                              /* log it in the hist buffer */               call BUILD.POLY.HIST.REC(old.base,0,rec);               call ADD.POLY.TO.HIST(rec);         end;      	call ERASE.MESSAGE;      end;                               /* of it's okay to trim the sound file */         end DC.TRIM.SOUND.FILE;