/* $Title STDRSOUC - Draw SYMBOL Catalog   12/11/87 - MWH - Merge poly updates with N-Final plus AEE sources   08/07/87 - MWH - Update all to support max 4 poly bins, 512mb/bin   02/06/87 - BSW - This file is a part of the module called STDRMOD*/   dcl (first.stm.symbol,last.stm.symbol)  fixed;   /* first and last symbols displayed */   dcl #syms.disp   lit '45';                       /* number of symbols displayed on symbol catalog screen  */   DISP.SYMBOL.TIME: proc(symbol_index) swapable;    /* displays the symbol time for the symbol catalog */      dcl symbol_index   fixed;      dcl symbol_time(2) fixed;      dcl (i,j,k)        fixed;      k=symbol_index-first.stm.symbol;         /* get absolute row and column */      load k; div 3;      i=res+row.offset;                        /* find (x,y) screen position */      j=((k mod 3)*27)+sym.time.col;      call cpos(i,j);      i=symbol_index*symbol_length;            /* get time from external memory */      write(mam)=trd.ptr+11+shr(i,8);      write(mal)=i&255;      do i=0 to 2;         symbol_time(i)=read(mdi);      end;      call print.parm(symbol_time(0),0,0,3,0);  /* seconds */      call pc(dot);      call print_digits(symbol_time(1),3);      /* milliseconds */      call pc(sp);      call print_digits(symbol_time(2),3);      /* microseconds */   end DISP.SYMBOL.TIME;   ERASE.SYMBOL.TIME:  proc (symbol.index) swapable;  /* erases the symbol time */      dcl (symbol.index)  fixed;      dcl (i,j,k)         fixed;      k=symbol.index-first.stm.symbol;      load k; div 3;       /* find x and y screen positions */      i=res+row.offset;      j=((k mod 3)*27)+sym.time.col;      call cpos(i,j);      do j=0 to 11;        /* erase the symbol time */         call pc(sp);      end;   end ERASE.SYMBOL.TIME;   DISP.SYMBOL.NAME: proc (symbol.index) public swapable;  /* displays the symbol name in the symbol catalog */      dcl symbol.index    fixed;      dcl (i,j,k)         fixed;      dcl symbol_name(4)  fixed;      k=symbol.index-first.stm.symbol;      load k; div 3;          /* find x and y screen positions */      i=res+row.offset;      j=((k mod 3)*27)+sym.name.col;      call cpos(i,j);      i=symbol.index*symbol_length+name_entry;  /* get name from external memory */      write(mam)=trd.ptr+11+shr(i,8);      write(mal)=i&255;      do i=0 to 4;         symbol_name(i)=read(mdi);      end;      call ps(symbol_name);   end DISP.SYMBOL.NAME;   ERASE.SYMBOL.NAME: proc (symbol.index) swapable;  /* erases the symbol name in the symbol catalog */      dcl symbol.index    fixed;      dcl (i,j,k)         fixed;      k=symbol.index-first.stm.symbol;      load k; div 3;          /* find x and y screen positions */      i=res+row.offset;      j=((k mod 3)*27)+sym.name.col;      call cpos(i,j);      do i=0 to 8;         call pc(sp);                    /* erase the name */      end;   end ERASE.SYMBOL.NAME;   /* $page */   DISP.STM.SYMBOLS: proc (symbol.index) swapable;      dcl symbol.index fixed;            do while (symbol.index<number_of_symbols) and (symbol.index<last.stm.symbol);         call DISP.SYMBOL.TIME(symbol.index);         call DISP.SYMBOL.NAME(symbol.index);         symbol.index=symbol.index+1;      end;   end DISP.STM.SYMBOLS;   ERASE.STM.SYMBOLS:  proc(symbol.index) swapable;      dcl symbol.index fixed;      dcl (i,j)        fixed;      do while (symbol.index<number_of_symbols) and (symbol.index<last.stm.symbol);         call ERASE.SYMBOL.TIME(symbol.index);         call ERASE.SYMBOL.NAME(symbol.index);         symbol.index=symbol.index+1;      end;   end ERASE.STM.SYMBOLS;   /* $Subtitle Sets The Symbol in the Middle of the Display Window */   SHOW.SYMBOL:  proc(stm.symbol.index) fixed swapable;   /* set the symbol in the center of the display window */      dcl stm.symbol.index fixed;      dcl symbol_time(2)   fixed;      dcl half.time(2)     fixed;      dcl (i,j)            fixed;      j=stm.symbol.index*symbol_length;   /* find the current symbol */      write(mam)=trd.ptr+11+shr(j,8);      write(mal)=j&255;      do i=0 to 2;                        /* center symbol time in the display */         symbol_time(i)=read(mdi);      end;      call COMPUTE_PIXEL_TIME(shr(display.width,1),half.time);      do i=0 to 2;                        /* find half of the display width time */         half.time(i)=half.time(i)-start.time(i);      end;      call TIME_NORMALIZE(half.time);      do i=0 to 2;         some.time(i)=symbol_time(i)-half.time(i);      end;      call TIME_NORMALIZE(some.time);      do i=0 to 2;         some.other.time(i)=0;      end;      if (compare_times(some.time,some.other.time,3)>=0)   /* if new starting time and within range of the sound file */      and (compare_times(some.time,tot.time,3)<=0) then do;         call COPY_TIME(some.time,start.time);       /* put cursor at half way point over sample*/         stm.graphx=shr(display.width,1);      end;      else if (compare_times(some.time,some.other.time,3)<0) then do; /* if we cannot quite center it */         if compare_times(some.other.time,start.time,3)<>0            /* if not already at beginning of the sound file */         then call COPY_TIME(some.other.time,start.time);             /* stick us back at the beginning of the sound file */         stm.graphx=COMPUTE_PIXEL_NUMBER(symbol_time);      end;   end SHOW.SYMBOL;   /* $Subtitle Set Symbol Limits */   SET.SYMBOL.LIMITS:  proc swapable;    /* sets first and last symbol displayed */      first.stm.symbol=stm.symbol.index;      if ((first.stm.symbol+#syms.disp)>number_of_symbols)  /* if there are more symbols than what fit on the screen */      then last.stm.symbol=number_of_symbols;      else last.stm.symbol=first.stm.symbol+#syms.disp;   end SET.SYMBOL.LIMITS;   /* $Subtitle Symbol Input Character Handler */   STM.SYMBOL.INPUT: proc (i) swapable;      dcl i fixed;  /* input character */      if i=cret then do;          call SHOW.SYMBOL(stm.symbol.index);         call SED.COMMAND.ATTRIBUTE.DEPOSIT;       /* terminate symbol catalog process */      end;      else if (i=ESC)      then do;         call SED.COMMAND.ATTRIBUTE.DEPOSIT;       /* terminate symbol catalog process */      end;      else if (i=u.arr) or (i=d.arr) or (i=r.arr) or (i=l.arr) or (i=home) then do; /* if any of the arrow keys */         prev.stm.symbol.index=stm.symbol.index;         if (i=u.arr) or (i=d.arr) then do;       /* if up or down arrow */            if i=u.arr then do;               if stm.symbol.index-3>=0               then stm.symbol.index=stm.symbol.index-3;            end;            else do;               if stm.symbol.index+3<number_of_symbols               then stm.symbol.index=stm.symbol.index+3;            end;         end;         else if (i=r.arr) or (i=l.arr) then do;  /* if right or left arrow */            if i=r.arr then do;               if stm.symbol.index+1<number_of_symbols               then stm.symbol.index=stm.symbol.index+1;            end;            else do;               if stm.symbol.index-1>=0               then stm.symbol.index=stm.symbol.index-1;            end;         end;         else stm.symbol.index=0;         /* home */         if (stm.symbol.index>=last.stm.symbol)       /* scroll up or down a page */         or (stm.symbol.index<first.stm.symbol) then do;            call ERASE.STM.SYMBOLS(first.stm.symbol); /* clear all the previous symbols */            call SET.SYMBOL.LIMITS;            call DISP.STM.SYMBOLS(stm.symbol.index);  /* display all of the new ones */            prev.stm.symbol.index=stm.symbol.index;   /* reset cursor */         end;         call POS.STM.ALPHA.CURSOR;       /* reposition cursor */      end;                                /* of if right or left arrow */   end STM.SYMBOL.INPUT;   /* $Subtitle Symbol Mouse Mapping Routine */   STM.SYMBOL.MOUSE.POS:  proc (x,y) swapable;    /* mouse positioning for STM Symbols feature */      dcl (x,y)   fixed;      if not mouse.hole(x,y) then do;         /* if not an exit condition */         x = convert.mouse.x(x);              /* convert to screen coordinates */         y = convert.mouse.y(y);         if (x>=2) and (x<=78) and (y>=7) and (y<=21) then do; /* if within shooting range */            prev.stm.symbol.index=stm.symbol.index;            stm.symbol.index=(-1);  /* assume not within range until proven otherwise */            if ((x>=2) and (x<=9)) or ((x>=13) and (x<=23)) /* first column of symbol names and times */            then stm.symbol.index=3*(y-row.offset);            else if ((x>=29) and (x<=36)) or ((x>=40) and (x<=50))   /* second column of symbol times and names */            then stm.symbol.index=1+(3*(y-row.offset));            else if ((x>=56) and (x<=63)) or ((x>=67) and (x<=77))            then stm.symbol.index=2+(3*(y-row.offset));            if (stm.symbol.index>=0) and (stm.symbol.index<number_of_symbols)            and (stm.symbol.index>=first.stm.symbol) and (stm.symbol.index<=last.stm.symbol) then do;  /* if a valid symbol */               call SHOW.SYMBOL(stm.symbol.index);               call SED.COMMAND.ATTRIBUTE.DEPOSIT;            end;         end;      end;                    /* of if not an exit condition */      else call SED.COMMAND.ATTRIBUTE.DEPOSIT;/* terminate symbol catalog process */   end STM.SYMBOL.MOUSE.POS;   /* $Subtitle Display Catalog of Sound File Symbols */   DISP.SYMBOL.CATALOG: proc public swapable;   /* displays a catalog of the symbols in the sound file */      dcl syn.counter    fixed;      dcl (i,j)          fixed;      dcl code           fixed;      if inc.stmm=0 then return; /* SYMBOLS is a STM release M feature */      call clear.term;      if D44_PRESENT             /* plot a mouse hole if the mouse is configured */      then call PLOT.MOUSE.HOLE(mouse.hole.lowerx,mouse.hole.lowery);      call DRAW.BOX(0,0,22,79);  /* enclose the screen display */      call cpos(0,23);      call DRAW.TEE(t.right);    /* draw a right T */      call ps('Symbols for Sound File           ');      call cpos(0,47);      call ps(stm.file.name);    /* print current sound file name */      call cpos(0,56);      call DRAW.TEE(t.left);     /* draw a left T */      call cpos(2,2);      call ps('Press <RETURN> to select and display a symbol.  Press <ENTER> for sound file');      call cpos(3,2);      call ps('display.  Use arrow keys to move cursor and scroll to see more.');      call cpos(4,1);      call DRAW.HOR(78);      call cpos(4,0);      call DRAW.TEE(t.left);      call cpos(4,79);      call DRAW.TEE(t.right);    /* draw a right T */      j=0;                       /* draw the symbol headers */      do while j<3;         call cpos(6,2+j*27);         call ps('Symbol');         call cpos(6,16+j*27);         call ps('Time');         j=j+1;      end;      call LOOK.UP.SF.INFO;             /* so find current file name again */      do i=0 to 1;                   /* copy the sound file symbol table to external memory */         call psmread(SFILE.BASE,SF.SYM+i,0);         do j=0 to 255;            misc.buf(j)=read(psd);         end;         write(mam)=trd.ptr+11+i;         do j=0 to 255;            write(mdi)=misc.buf(j);         end;      end;      stm.symbol.index=0;               /* initialize */      prev.stm.symbol.index=0;      call SET.SYMBOL.LIMITS;           /* sets first and last symbols to be displayed */      call DISP.STM.SYMBOLS(stm.symbol.index);      call POS.STM.ALPHA.CURSOR;                /* position cursor */      /* $page */      do while stm.cmd.line<>0;                 /* do while part of the command */         code = GET.NEXT.EVENT;                     /* get event         */         do case (code-1);            do;                        /* input character received */               if next.event.info >= asc.call.convert               then call SED.COMMAND.ATTRIBUTE.DEPOSIT;               else call STM.SYMBOL.INPUT(next.event.info);            end;                       /* of if input character received */            if next.event.info=2       /* look for release of middle button or continual press */            then do;               call STM.SYMBOL.MOUSE.POS(mouse(release.x),mouse(release.y));            end;                       /* of look if mouse button was released */            ;                          /* mouse movement not used */            do;                        /* new timbre info     */               call SED.COMMAND.ATTRIBUTE.DEPOSIT; /* terminate symbol catalog process */            end;            ;                          /* psfree not displayed    */            ;                          /* new seq info not used   */            ;                          /* no play scrolling       */            ;                          /* entry writes no effect  */            ;                          /* tds update - nothing    */            ;                          /* dtd info - nothing      */            do;                        /* poly change             */               call SED.COMMAND.ATTRIBUTE.DEPOSIT; /* terminate symbol catalog process */            end;            do;                        /* error message to display */               call DISPLAY.ERROR.MESSAGE(next.event.info,23,0);  /* ertyp - display error here */               call POS.STM.ALPHA.CURSOR;            end;            ;                          /* nothing on ork/smpte */         end;                          /* of do case           */      end;                             /* do while part of the command */   end DISP.SYMBOL.CATALOG;