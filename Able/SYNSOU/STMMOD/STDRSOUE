/*	:SYNSOU:STMMOD:STDRSOUE  $Title  Sample-To-Memory Sound Editor Command Prompt RoutinesModified:1999/10/13 - TY  - Changed help text to include the new commands for stepping						 through partials and patch lists1989/08/02 - SJS - added support for Sample Rate Conversion1988/09/08 - SJS - Changed TSM length to SFTime format1988/08/25 - MWH - Add "real" DSP user interface1988/05/19 - SJS - Added prompt for Sample Rate Conversion commands1988/04/27 - JSS - draw.command.prompt.2 inits both old & new SAFE properly1988/04/19 - MWH - Add "OK" prompt for collect, max_time, print1988/04/15 - MWH - Add point mode and zero line1988/03/08 - TSS - Added prompt for Time Scale Modify commands1988/02/16 - MWH - Improve crossfade handling1987/12/11 - MWH - Merge poly updates with N-Final plus AEE sources1987/08/19 - MWH - Add stm.max.time option to shuffle for max recording time1987/08/07 - MWH - Update all to support max 4 poly bins, 512mb/bin*/	ERASE.COMMAND.PROMPT: proc(command.letter) public swapable;		dcl command.letter	fixed;	/*	letter representing the selected command	*/		p.sp: proc(num);	/*	prints NUM spaces	*/			dcl num	fixed;			do num=1 to num; call pc(sp); end;		end p.sp;		erase.prompt: proc(#lines);	/*	erases the given number of command lines	*/			dcl #lines		fixed;			dcl i				fixed;			dcl start.line	lit '18';			dcl max.lines	lit  '4';			dcl start.x		lit '19';			if #lines>max.lines			then #lines=max.lines;	/*	only erase the number of lines available in command prompt	*/			do i=0 to #lines-1;				call cpos(start.line+i,start.x);				call p.sp(61);			end;		end erase.prompt;		do case(stm.select.mode);			/*	do depending upon selection mode	*/			do;									/*	if selection is display	*/				do case (command.letter);					;								/*	A: Display	*/					;								/*	B: Modify	*/					;								/*	C: Store		*/					call ERASE.PROMPT(2);	/*	D: show		*/					do;							/*	E: zoom		*/						call ERASE.PROMPT(2);						if mg600 then do;	/*	if erasing resolution prompt	*/							call cpos(20,19);							call p.sp(61);						end;					end;					call ERASE.PROMPT(1);	/*	F: search	*/					call ERASE.PROMPT(2);	/*	G label		*/					call ERASE.PROMPT(2);	/*	H: unlabel	*/					;								/*	I: center	*/					;								/*	J: mark start	*/					;								/*	K: mark end	*/					;								/*	L: Left		*/					if inc.stmm=0				/*	M: Symbols	*/					then call ERASE.PROMPT(1);					call ERASE.PROMPT(2);	/*	N: Print		*/					call ERASE.PROMPT(4);	/*	O: Help		*/					do;							/*	P: Caption	*/						if inc.stmm						then call ERASE.PROMPT(3);						else call ERASE.PROMPT(1);					end;					if inc.stmm=0				/*	Q: Mark Offset	*/					then call ERASE.PROMPT(1);					if inc.stmm					/*	R: Lock		*/					then call ERASE.PROMPT(1);					if inc.stmm=0				/*	S: Unlock	*/					then call ERASE.PROMPT(1);					call ERASE.PROMPT(1);	/*	T: Dot Mode	*/					call ERASE.PROMPT(1);	/*	U: Zero ---	*/					call ERASE.PROMPT(1);	/*	V: reserved	*/					call ERASE.PROMPT(1);	/*	W: reserved	*/				end;			end;			/*	of if selection is display		*/			/*	$page	*/			do;									/*	if selection is modify	*/				do case (command.letter);					;								/*	A: display	*/					;								/*	B: Modify	*/					;								/*	C: Store		*/					;								/*	D: reverse	*/					do;							/*	E: cut		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	F: paste		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	G: extract	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	H: delete	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					;								/*	I: exchange	*/					do;							/*	J: Combine	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	K: extract mono	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	L: crossfade	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	M: copy		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	N: Fill		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	O: Loop		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	P: Volume	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					call ERASE.PROMPT(1);	/*	Q: Normalize	*/					do;							/*	R: Modulate	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	S: Rev Loop	*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					do;							/*	T: Mix		*/						if inc.stmm						then call ERASE.PROMPT(2);						else call ERASE.PROMPT(1);					end;					call ERASE.PROMPT(1);	/*	U: Undo		*/					if inc.stm=0				/*	V: Invert	*/					then call ERASE.PROMPT(1);					if inc.stm=0				/*	W: DC Trim	*/					then call ERASE.PROMPT(1);				end;		/*	of do depending upon choice	*/			end;			/*	of if selection is modify		*/			/*	$page	*/			do;									/*	if selection is store	*/				do case(command.letter);					;								/*	A: display	*/					;								/*	B: Modify	*/					;								/*	C: Store		*/					call ERASE.PROMPT(2);	/*	D: save		*/					call ERASE.PROMPT(2);	/*	E: unsave	*/					call ERASE.PROMPT(2);	/*	F: rename	*/					call ERASE.PROMPT(2);	/*	G: recall	*/					call ERASE.PROMPT(2);	/*	H: collect	*/					call ERASE.PROMPT(3);	/*	I: record	*/					call ERASE.PROMPT(2);	/*	J: max time	*/					;								/*	K: reserved	*/					;								/*	L: reserved	*/					;								/*	M: reserved	*/					;								/*	N: reserved	*/					;								/*	O: reserved	*/					;								/*	P: reserved	*/					;								/*	Q: reserved	*/					;								/*	R: reserved	*/					call ERASE.PROMPT(1);	/*	S: reserved	*/					call ERASE.PROMPT(1);	/*	T: reserved	*/					call ERASE.PROMPT(1);	/*	U: reserved	*/					call ERASE.PROMPT(1);	/*	V: reserved	*/					call ERASE.PROMPT(1);	/*	W: reserved	*/				end;	/*	of do depending upon selection	*/			end;		/*	of if selection is store	*/			do;		/*	if selection is Modify II	*/				do case (command.letter);					;								/*	A: Display	*/					;								/*	B: Modify	*/					;								/*	C: Store		*/					if inc.stmm & inc.dsp.code then					call ERASE.PROMPT(4);	/*	D: TSM		*/					else					call ERASE.PROMPT(1);	/*	(or D: reserved)	*/					call ERASE.PROMPT(4);	/*	E: SRC		*/					call ERASE.PROMPT(1);	/*	F: reserved	*/					call ERASE.PROMPT(1);	/*	G: reserved	*/					;								/*	H: Monoize	*/					call ERASE.PROMPT(1);	/*	I: reserved	*/					call ERASE.PROMPT(1);	/*	J: reserved	*/					call ERASE.PROMPT(1);	/*	K: reserved	*/					call ERASE.PROMPT(1);	/*	L: reserved	*/					call ERASE.PROMPT(1);	/*	M: reserved	*/					call ERASE.PROMPT(1);	/*	N: reserved	*/					call ERASE.PROMPT(1);	/*	O: reserved	*/					call ERASE.PROMPT(1);	/*	P: reserved	*/					call ERASE.PROMPT(1);	/*	Q: reserved	*/					call ERASE.PROMPT(1);	/*	R: reserved	*/					call ERASE.PROMPT(1);	/*	S: reserved	*/					call ERASE.PROMPT(1);	/*	T: reserved	*/					call ERASE.PROMPT(1);	/*	U: reserved	*/					call ERASE.PROMPT(1);	/*	V: reserved	*/					if inc.stmm & inc.debug.code then					call ERASE.PROMPT(4);	/*	W: Debug		*/					else					call ERASE.PROMPT(1);	/*	(or W: reserved)	*/				end;			end;			/*	of if selection is Modify II	*/		end;				/*	of do depending upon selection mode	*/	end ERASE.COMMAND.PROMPT;	/*	$page	*/	DRAW.COMPILATION.ERROR: proc swapable;		call cpos(18,19);		call ps('Feature not available in this software.  Press <RETURN>.');	END DRAW.COMPILATION.ERROR;	draw.command.prompt.0:proc (command.letter) swapable;		dcl command.letter	fixed;		dcl i						fixed;		do case (command.letter);			;										/*	A: Display	*/			;										/*	B: Modify	*/			;										/*	C: Store		*/			do;									/*	D: Show		*/				call cpos(prompt.y,prompt.x);				call ps('Enter time value, label, or symbol to show');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	E: Zoom		*/				call cpos(prompt.y,prompt.x);				call ps('Press arrow keys to zoom in or out.');				call cpos(prompt.y+1,prompt.x);				call ps('Select feature by typing letter.');				if mg600 then do;					call cpos(prompt.y+2,prompt.x);					call ps('Assign resolution any value between 1 and 50 => ');					call cpos(prompt.y+2,68);					call print.parm(stm.resolution,0,0,2,0);				end;			end;			do;									/*	F: Search	*/				call cpos(prompt.y,prompt.x);				call ps('Enter amplitude level =>');			end;			do;									/*	G: Label		*/				call cpos(prompt.y,prompt.x);				call ps('Assign label name to time value of cursor location');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	H: Unlabel	*/				call cpos(prompt.y,prompt.x);				call ps('Enter label name to be removed');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			;										/*	I: Center	*/			;										/*	J: mark start	*/			;										/*	K: mark end	*/			;										/*	L: Left		*/			do;									/*	M: Symbols	*/				if inc.stmm=0 then call DRAW.COMPILATION.ERROR;			end;			do;									/*	N: Print		*/				call cpos(prompt.y,prompt.x);				call ps('Print the sound file display [OK Confirms]');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	O: Help		*/				cpos(prompt.y  ,prompt.x); ps('Press <ENTER> to return to Main Menu.  Select feature by');				cpos(prompt.y+1,prompt.x); ps('typing letter.  Separate time values or labels by commas.');				cpos(prompt.y+2,prompt.x); ps('Use arrow keys to move cursor.  Step through patch list');				cpos(prompt.y+3,prompt.x); ps('with < and >.  Step through partials with the space bar.');			end;			do;									/*	P: Caption	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Assign a caption to the sound file');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			if inc.stmm=0 then call DRAW.COMPILATION.ERROR;	/*	Q: mark offset	*/			if inc.stmm=0 then call DRAW.COMPILATION.ERROR;	/*	R: Lock		*/			if inc.stmm=0 then call DRAW.COMPILATION.ERROR;	/*	S: Unlock	*/			if inc.stmm=0 then call DRAW.COMPILATION.ERROR;	/*	T: Dot Mode	*/			if inc.stmm=0 then call DRAW.COMPILATION.ERROR;	/*	U: Zero ---	*/			;										/*	V: reserved	*/			;										/*	W: reserved	*/		end;	end draw.command.prompt.0;	/*	$page	*/	draw.command.prompt.1:proc (command.letter) swapable;		dcl command.letter	fixed;		dcl i						fixed;		do case (command.letter);			;										/*	A: display	*/			;										/*	B: Modify	*/			;										/*	C: Store		*/			;										/*	D: reverse	*/			do;									/*	E: Cut		*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, crossfade times ');					if D44_PRESENT					then call ps('or use the mouse');					else call ps('of sound file');					call ps(' to cut');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	F: Paste		*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter name of file and number of copies to paste ');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	G: Extract	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, crossfade times ');					if D44_PRESENT					then call ps('or use the mouse ');					else call ps('of sound file ');					call ps('to extract');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	H: delete	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, crossfade times ');					if D44_PRESENT					then call ps('or use the mouse ');					else call ps('of sound file ');					call ps('to delete');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	I: exchange	*/				if inc.stmm=0 then call DRAW.COMPILATION.ERROR;			end;			do;									/*	J: combine	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter name of sound file to combine with current file');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	K: extract mono	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Extract left or right channel for mono sound file');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	L: Crossfade	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter Crossfade length in milliseconds');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	Copy			*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, crossfade times ');					if D44_PRESENT					then call ps('or use the mouse ');					else call ps('of sound file ');					call ps('to copy');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	N: Fill		*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin and end times ');					call ps('and name of sound file ');					call ps('for fill');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	O: loop		*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, ');					call ps('and crossfade times ');					call ps('for loop');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	P: volume	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter a volume scale factor between 0.000 and 30.000');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	Q: Normalize	*/				if inc.stm=0				then call DRAW.COMPILATION.ERROR;			end;			do;									/*	R: Modulate	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter sound filename for modulation');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	S: Reverse Loop	*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter begin, end, ');					call ps('and crossfade times ');					call ps('for reverse loop');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	T: Mix		*/				if inc.stmm then do;					call cpos(prompt.y,prompt.x);					call ps('Enter sound filename and mix ratio between 0.000 and 30.000');					call cpos(prompt.y+1,prompt.x);					call ps('=>');				end;				else call DRAW.COMPILATION.ERROR;			end;			do;									/*	U: Undo		*/				call DRAW.COMPILATION.ERROR;			end;			do;									/*	V: Inverse	*/				if inc.stmm=0				then call DRAW.COMPILATION.ERROR;			end;			do;									/*	W: DC trim	*/				if inc.stmm=0				then call DRAW.COMPILATION.ERROR;			end;		end;			/*	of do depending upon choice		*/	end draw.command.prompt.1;	/*	$page	*/	draw.command.prompt.2:proc (command.letter) swapable;		dcl command.letter	fixed;		dcl i						fixed;		do case(command.letter);			;										/*	A: display	*/			;										/*	B: Modify	*/			;										/*	C: Store		*/			do;									/*	D: Save		*/				call cpos(prompt.y,prompt.x);				call ps('Enter name of file to save');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	E: Unsave	*/				call cpos(prompt.y,prompt.x);				call ps('Enter name of file to unsave');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	F: Rename	*/				call cpos(prompt.y,prompt.x);				call ps('Assign new filename to current sound file');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	G: recall	*/				call cpos(prompt.y,prompt.x);				call ps('Enter name of soundfile to recall or CTRL-C for Directory');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	H: collect	*/				call cpos(prompt.y,prompt.x);				call ps('Delete all unused sound files in poly memory [OK Confirms]');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			do;									/*	I: record	*/				call ad_init;							/*	reinitialize the A/D		*/				if (stm.record.rate=0) then do;	/*	if the first time thru	*/					stm.record.rate=500;				/*	initialize sampling rate	*/					stm.record.scale=10;				/*	Assume old SAFE for now & init gain to 1.0 times	*/					stm.record.threshold=15;		/*	inititalize threshold in volts	*/					STM.THRESHOLD=98;					/*	initialize threshold value used in SAMPLE.TO.MEMORY	*/					/*	Note: next line only checks polyadc in bin 0 since that's where poly sampling is done	*/					if ((polyadcs(0)=0) and ((core(core(1)+17)&"20000")<>0))	/*	if no stm hardware but configured for d66	*/               then stm.record.device = stm.record.device.d66;  /* initialize for d66 mono sampling */               else if ((polyadcs(0)=0) and ((read("51") & 0x8000) != 0) and ((read("57") & 0x4000) != 0))               then stm.record.device = stm.record.device.dig;  /* initialize for digital inputs */               else do;       /* otherwise initialize for stm mono sampling */                  stm.record.device=stm.record.device.stm;      /* set mode */						if (READ.STM.CONFIG(0) & "H8000") <> 0	/*	If new SAFE (Analogic ADC)		*/						then stm.record.scale=0;			/*	reinitialize gain value to 0 db	*/					end;				end;				call cpos(prompt.y+1,prompt.x);				call ps('Mode:');				call cpos(prompt.y+1,40);				call ps('Rate:');				call cpos(prompt.y+2,prompt.x);				call ps('Trigger:');				call cpos(prompt.y+2,40);				call ps('Threshold:');				do i=0 to 3;					/*	set up the initial menu	*/					call SET.RECORD.MENU(i);				end;				new.poly.contents = new.poly.contents \ 1;			end;			do;									/*	J: max time	*/				call cpos(prompt.y,prompt.x);				call ps('Shuffle poly memory for maximum recording time [OK Confirms]');				call cpos(prompt.y+1,prompt.x);				call ps('=>');			end;			;										/*	K: reserved	*/			;										/*	L: reserved	*/			;										/*	M: reserved	*/			;										/*	N: reserved	*/			;										/*	O: reserved	*/			;										/*	P: reserved	*/			;										/*	Q: reserved	*/			;										/*	R: reserved	*/			;										/*	S: reserved	*/			;										/*	T: reserved	*/			;										/*	U: reserved	*/			;										/*	V: reserved	*/			;										/*	W: reserved	*/		end;			/*	of do depending upon selection	*/	end draw.command.prompt.2;	/*	$page	*/	draw.command.prompt.3:proc (command.letter) swapable;		dcl command.letter	fixed;		dcl i						fixed;		do case(command.letter);			;										/*	A: display	*/			;										/*	B: Modify	*/			;										/*	C: Store		*/			do;									/*	D: TSM		*/				if inc.stmm & inc.dsp.code then do;					tsm.ratio = 0;	/*	reset so that will be set to default len,ratio	*/					call cpos(prompt.y,prompt.x);					call ps('Algorithm:');					call cpos(prompt.y,prompt.x+19);					call ps('New Length (sec):');					call cpos(prompt.y,prompt.x+48);					call ps('Ratio:');					call cpos(prompt.y+3,prompt.x);					call ps('Press <RETURN> to begin or <ENTER> to return to menu.');					do i=0 to 1;					/*	set up the initial menu	*/						call SET.TSM.MENU(i);	/*	only need to draw 1st 2 to get all	*/					end;				end;			end;			do;									/*	E: SRC		*/				call cpos(prompt.y+1,prompt.x+10);				call ps('New Sample Rate: ');			end;			;										/*	F: reserved	*/			;										/*	G: reserved	*/			;										/*	H: reserved	*/			;										/*	I: reserved	*/			;										/*	J: reserved	*/			;										/*	K: reserved	*/			;										/*	L: reserved	*/			;										/*	M: reserved	*/			;										/*	N: reserved	*/			;										/*	O: reserved	*/			;										/*	P: reserved	*/			;										/*	Q: reserved	*/			;										/*	R: reserved	*/			;										/*	S: reserved	*/			;										/*	T: reserved	*/			;										/*	U: reserved	*/			;										/*	V: reserved	*/			do;									/*	W: Debug		*/				if inc.stmm & inc.debug.code then do;					call cpos(prompt.y,prompt.x);					call ps('Debug Function:');					call SET.DEBUG.MENU(0);				end;			end;		end;			/*	of do depending upon selection	*/	end draw.command.prompt.3;	DRAW.COMMAND.PROMPT: proc(command.letter) public swapable;		dcl command.letter	fixed;	/*	letter representing the selected command	*/		do case(stm.select.mode);					/*	do depending upon selection mode	*/			call draw.command.prompt.0(command.letter);			call draw.command.prompt.1(command.letter);			call draw.command.prompt.2(command.letter);			call draw.command.prompt.3(command.letter);		end;			/*	of do depending upon selection mode	*/		call SET.MAXIMUM.TOKEN.LEN;		call POS.STM.ALPHA.CURSOR;		/*	moves the cursor to command line setting location	*/	end DRAW.COMMAND.PROMPT;