/* D42MOD - INTERRUPT CODE FOR D42 *//*   11/4/86 - FIXED BUG IN D42PC WHERE INTERRUPTS WERE DISABLED AT WRONG TIME   5/15/86 - "official" creation of release-M modules*/module d42mod;INSERT ':SYNLITS:COMLITS';   /* ALL MODULES MUST INSERT COMLITS    */INSERT ':SYNLITS:GLOBLITS';  /* PRACTICALLY ALL WILL WANT GLOBLITS */INSERT ':SYNMODS:GLOBDCL';   /* FOR D54 BITS                       */insert ':-xpl:intrprtr';dcl (d42.buf.len)            lit '64'; /* 64 char d42 output buf length */dcl (d42rptr,d42sptr)        fixed;    /* pointers into d42 output rotary buffer */dcl (d42buf) (d42.buf.len/2) fixed;    /* d42 output rotary buffer */dcl (d42.busy)               fixed;    /* true when d42 output is active */dcl (d42.stopped)            fixed;    /* true when printer sends XOFF */enable_d42: proc public swapable;     /* enables d42 interrupts */   d54bits=d54bits\2;             /* set bit for d42        */   write(D54)=d54bits;end enable_d42;disable_d42: proc public swapable;    /* disables d42 interrupts */   d54bits=d54bits&"177775";      /* clear bit for d42       */   write(D54)=d54bits;end disable_d42;boot_d42:  proc;                 /* start up d42 - MUST CALL WITH INTERRUPTS OFF */   dcl i fixed;   if d42rptr<>d42sptr then do;      write(d42)=byte(d42buf,d42rptr);     /* write out byte to printer   */      d42rptr=(d42rptr+1)&(d42.buf.len-1); /* bump and wrap read pointer  */      d42.busy=1;                          /* mark busy if character sent */   end;   else do;      write(d43)=0;                        /* acknowledge interrupt */      d42.busy=0;                          /* no longer printing    */   end;end boot_d42;dcl d42.output.happening fixed public;     /* flag is cleared when buffer becomes empty */when d42INT then begin;                    /* handle incoming XON/XOFF and output */   dcl i         fixed;   dcl reply.ptr fixed;   dcl reply data                          /* index reply   */   (027,080,048,059,051,049,059,048,122,027,092);   if (read(d43)&2)<>0 then do;            /* have received a input char */      i=read(d42)&"177";                   /* get char, mask off parity  */      if i="23" then d42.stopped=1;        /* control s      */      else if i="21" then do;              /* control q      */         if d42.stopped<>0 then do;        /* restart output */            if d42.busy=0                  /* but check busy */            then call boot_d42;            /* in case still  */            d42.stopped=0;                 /* going          */         end;      end;      else do;                             /* check for reply      */         if i=reply(reply.ptr) then do;    /* next byte in seq     */            reply.ptr=reply.ptr+1;         /* advance              */            if reply.ptr=11 then do;       /* complete msg         */               d42.output.happening=0;     /* indicate done        */               reply.ptr=0;                /* right now            */            end;         end;         else do;            reply.ptr=0;                   /* reset to start       */            if i=reply(reply.ptr)          /* see if start of new  */            then reply.ptr=1;              /* message              */         end;      end;      return;   end;   else do;                                /* output done interrupt */      if d42.stopped=0      then call boot_d42;                  /* perform more output if not stopped */      else do;         write(d43)=0;                     /* acknowledge interrupt   */         d42.busy  =0;                     /* mark un-busy if stopped */      end;   end;end; /* of WHEN d42INT */d42_wait:  proc public swapable;                  			/* wait for printer to finish printing */   do while d42rptr<>d42sptr; chill.out.and.run.syn(); end; /* loop until char comes in */end d42_wait;d42pc:proc(x) public;   dcl x fixed;   do while ((d42sptr+1)&(d42.buf.len-1))=d42rptr;   	chill.out.and.run.syn();   end;   disable;   call pbyte(d42buf,d42sptr,x);   d42sptr=(d42sptr+1)&(d42.buf.len-1);   if d42.busy=0 then call boot_d42;   enable;end d42pc;end d42mod;