/* TRAPUTIL  $TITLE  ROUTINES TO PROCESS UTILITY PACKETS   Modified:   10/10/91 - MWH - Add "ping" message for protocol handshaking   03/13/91 - KJC - Added config byte (w/D34GPI existence) to CONFIGURATION message   12/14/89 - MWH - Move "AEE Notice" from Utilities to Events super-type   09/01/89 - MWH - Rework the protocol for release 2.2   08/24/89 - PF  - Modified CONFIGURATION message to support MAX.MIDINET.CHAN   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   01/17/89 - MWH - Add configuration message   11/30/88 - MWH - Clean up unreferenced public's   09/15/88 - PF - Created this source file*/Send.Configuration.Message: proc (packet,des) swapable;   dcl packet         array;   dcl des            fixed;              /* Packet destination */   dcl dtd.tracks     fixed;   dcl midi.in.ports  fixed;   dcl midi.out.ports fixed;   dcl multi.outs     fixed;   dcl dtd.outs       fixed;   dcl poly.voices    fixed;   dcl config         fixed;   dcl i              fixed;   poly.voices = 0;   do i = 0 to (psmaxbins-1);          /* Get # of poly voices in each bin */      poly.voices = poly.voices + PolyNumVs(i);   end;   if DTD.Max.Secs <> 0 then do;       /* DTD is there & initialized */      dtd.tracks = dtd.max.tracks;      dtd.outs   = dtd.num.voices;   end;   else do;                            /* No DTD (at least yet)       */      dtd.tracks = 0;      dtd.outs   = 0;   end;   if max.midi.chan <> 0 then do;      /* MIDI is there */      midi.in.ports  = 1;              /* For now; 8 max with "Monster MIDI" */      midi.out.ports = max.midi.chan;  /* 16 output ports max */   end;   else do;                            /* No MIDI */      midi.in.ports  = 0;      midi.out.ports = 0;   end;   /* Multichannel outputs */   if multi.there <> 0 then do;        /* Multichannel is there */      multi.outs = multi.max;   end;   else do;                            /* No multichannel */      multi.outs = 0;   end;   /* Configuration information */   config = (d34gpi.there & 1);        /* start with D34GPI bit */   write(mam) = misc.ptr;      write(mdi) = L#Configuration;   write(mdi) = des;   write(mdi) = T#Configuration;   write(mdi) = packet(0);             /* tag */   write(mdi) = poly.voices;   write(mdi) = fm.voices;   write(mdi) = shl(dtd.tracks,8) | max.midinet.chan;   write(mdi) = shl(max.midi.chan,8) | multi.outs;   write(mdi) = shl(dtd.outs,8) | config;   return(Send.Protocol.Packet(misc.ptr,1));end Send.Configuration.Message;Send.Ping.Message: proc (packet,des) swapable;   dcl packet         array;   dcl des            fixed;              /* Packet destination */   write(mam) = misc.ptr;      write(mdi) = L#Ping;   write(mdi) = des;   write(mdi) = T#Ping;   write(mdi) = packet(0);             /* tag */   return(Send.Protocol.Packet(misc.ptr,1));end Send.Ping.Message;// Error text subcodes:	//	The Error_Text message includes a sub-code field that directs how the receiver// should process the message:dcl 	ERR_COMPLETE_ERROR_TEXT lit '0';			// complete error string in 1 packetdcl 	ERR_LONG_ERROR_START		lit '1';			// first packet of long error stringdcl 	ERR_LONG_ERROR_CONTINUE lit '2';			// continuation packet of long error stringdcl 	ERR_LONG_ERROR_END		lit '3';			// final packet of long error stringSend.Error.Text.Message: proc (packet,des) swapable;   dcl packet        array;   dcl des           fixed;              		/* Packet destination */	dcl total_out    	fixed;	dcl which_type    fixed;	dcl this_len		fixed;   dcl my_buf(40) 	fixed;	dcl i					fixed;   dcl cur.err.len 	fixed external; 			/* used to keep track of current error message len */	dcl cur.err.sec  	fixed external; 			/* if nonzero, holds external memory sector to build error messge in */	dcl latched.ertyp	fixed external;	dcl ps.error      proc (fixed) external;  	cur.err.len = 0;									/* set variables to write error string to memory */	cur.err.sec = misc.ptr;	   ps.error(Latched.Ertyp);								// retrieve error message	cur.err.sec = 0;	// Return error string in pieces if need be.		if (cur.err.len == 0)									// if no error string, then done...		return (TRUE);		if ((cur.err.len & 1) != 0)		cur.err.len = cur.err.len + 1;					// round up to word boundary			total_out = packet(1);									// byte position of where to start		this_len = cur.err.len - total_out;					// compute bytes left to send		if (this_len <= 0)										// no more to send		return (TRUE);			if (this_len > 52)										// limit to what fits in one packet		this_len = 52;	if (total_out == 0 && this_len == cur.err.len)	// if first one & it all fits...		which_type = ERR_COMPLETE_ERROR_TEXT;			// then send complete message in 1 string			else if (total_out == 0)								// else if this is first one...		which_type = ERR_LONG_ERROR_START;				// send start		else if (total_out + this_len == cur.err.len)	// else if is last...		which_type = ERR_LONG_ERROR_END;					// then indicate so			else		which_type = ERR_LONG_ERROR_CONTINUE;			// else must be middle				write("313") = addr(my_buf(0));						// create message in my_buf	write("373") = L#Error_Text + this_len;			// length	write("373") = des;										// where to	write("373") = T#Error_Text;							// our mesage type	write("373") = packet(0);								// message tag	write("373") = which_type;								// type of string		write(mam) = misc.ptr;									// access string	write(mal) = 1 + shr(total_out, 1);		i = 0;		while (i < this_len)	{		write("373") = rot(read(mdi), 8);		i = i + 2;	}			write("373") = 0;											// make sure null trails partial strings		if (SEND.PROTOCOL.PACKET.WITH.RETRY(addr(my_buf(0)),0,10000) == FALSE)		return (FALSE);	return (TRUE);	end Send.Error.Text.Message;Handle.Utility: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam)   = Packet.Ptr;   write(mal)   = P#LEN;    len     = read(md);   write(mal)   = P#SOURCE; des     = read(md);   write(mal)   = P#TYPE;      subtype      = read(md) & "377";   write(mal)   = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   if subtype < 16   then do case subtype;         /* Branch on specific command (0-15) */      do;  /* 0:  Request Configuration Message */         ret = Send.Configuration.Message(packet,des);      end;      do;  /* 1: Configuration */         /* This is handled by the request routine */      end;   end;             /* of branch on specific command (0-15) */   else if subtype < 32   then do case (subtype - 16);  /* Branch on specific command (16-31) */      do;  /* 16: Help Message (only; last) */         /* Not implemented yet! */      end;      do;  /* 17: Help Message (multi; initial) */         /* Not implemented yet! */      end;      do;  /* 18: Request able error text */         ret = Send.Error.Text.Message(packet,des);      end;	  ;     /* 19: not used inbound; holds outgoing error text string */	     end;             /* of branch on specific command (16-31) */   else if subtype < 48   then do case (subtype - 32);  /* Branch on specific command (32-47) */      do;  /* 32: Request Ping */         ret = Send.Ping.Message(packet,des);      end;      do;  /* 33: Ping */         /* This is handled by the request routine */      end;   end;             /* of branch on specific command (16-31) */   return (ret);end Handle.Utility;