/* TRAPCR  $TITLE  ROUTINES TO PROCESS CREATION / RECORDING PACKETS   Modified:   03/10/92 - cj  - Cleaned up protocol recording on 'safing' dtd   01/07/92 - PF  - Return correct allocate time during possible cue punch extension   01/07/92 - PF  - CUE.LOCK.TIME should hold track end time, not project end time   01/06/92 - PF  - Only setup cue lock globals when arming for record   12/06/91 - PF  - Log cue as deleted on retake for Quick Updates   08/29/91 - CJ  - Added cue lock recording stuff   03/13/91 - KJC - Add Set External Record Triggers message   10/24/90 - MWH - Add more DTD state bits to "request DTD record state"   11/09/89 - MWH - Declare sync mode event when auto punch mode changes   09/22/89 - MWH - Make sure seq triggered record gets ALL requested audio   09/21/89 - MWH - Add ZERO.TIME to "arm for recording" messages   09/20/89 - MWH - Fix request recording time with only a "tag" argument   08/28/89 - MWH - Rework the protocol for release 2.2   06/16/89 - MWH - Remove ZERO.TIME offset from times sent over the protocol   06/08/89 - MWH - Process start/stop record protocol packets faster   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   04/11/89 - MWH - Split TRAPMOD into modules because it is too big!   03/14/89 - PF  - changed process packet processing logic   01/18/89 - MWH - Add Auto Punch feature   11/30/88 - MWH - Clean up unreferenced public's   09/15/88 - PF - Created this source file*/dcl Auto.Punch.In.Armed    fixed external;  /* Record pressed, ready to punch in *//* $Subtitle  Start record command */Process.Start.Record.Command: proc swapable;   dcl Stop.Move     proc external;   dcl Start.Record  proc external;   dcl Stop.Play     proc external;   if (recd = 0)                                   /* If not recording then begin */   or (pnch <>0)                                   /* If punching then go to merge mode */   then do;      if pnch<>0 then do;         pnch=0;                                   /* If punching & press record - just record */         new.motion=1;                             /* Tell live overdub about it    */      end;      else do;                                     /* Start recording */         if move<>0 then call Stop.Move;           /* Abort ff/rewind */         if (play=0)                               /* Get sequencer moving */         then do;            call Continue.Sequencer;            cont = 0;                              /* No setting a start loop from the remote box */         end;         if play<>0 then do;                       /* Am now playing */            if Auto.Punch.On <> 0                  /* If in auto-punch mode */            then do;               Check.Sequencer.Times = 1;          /* Set so next var will be looked at */               Auto.Punch.In.Armed = 1;            /* Get ready to punch in */            end;            else do;                               /* Else start recording now */               if Start.Record = 0                 /* Stop if error encountered */               then do;                  call Stop.Play;               end;            end;         end;      end;      call Display.Sequencer.Status;                  /* Let everyone know */   end;   return(TRUE);end Process.Start.Record.Command;/* $Subtitle  Start punch in command */Process.Start.Punch.Command: proc swapable;   dcl Continue.Sequencer    proc external;   dcl Process.Punch.Button  proc external;   if (pnch = 0)                                   /* If not recording then begin */   then do;      if (play=0)                                  /* Get sequencer moving */      then do;         call Continue.Sequencer;         cont = 0;                                 /* No setting a start loop from the remote box */      end;      call Process.Punch.Button;                   /* Handle like vk panel punch button */   end;   call Display.Sequencer.Status;                  /* Let everyone know */   return(TRUE);end Process.Start.Punch.Command;/* $Subtitle  Stop recording command */Process.Stop.Record.Command: proc swapable;   dcl Process.Record.Button proc external;   if (pnch <> 0)                                  /* We are punching         */   then call Process.Record.Button;                /* Go from punch to record */   if (recd <> 0)                                  /* We are recording        */   then call Process.Record.Button;                /* Go from record to play  */   call Display.Sequencer.Status;                  /* Let everyone know */   return(TRUE);end Process.Stop.Record.Command;/* $Subtitle  Auto Punch Mode Routines */Send.Auto.Punch.Mode: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl time (1)  fixed;   write(mam) = misc.ptr;       /* Build output packet in external memory */   write(mdi) = L#Auto_Punch_Info;   write(mdi) = des;   write(mdi) = T#Auto_Punch_Info;   write(mdi) = packet(0);      /* Tag */   call copy32(loc(addr(pre.roll.msb)),time);   if com16(ZERO.TIME,time) <> lw#igt               /* If the time is large enough */   then call sub16(ZERO.TIME,time);                 /* Remove "ZERO.TIME" offset */   else call str32(0,0,time);                       /* Else, put us at zero */   write(mdi) = time(lw#msb);                       /* Pre-roll time */   write(mdi) = time(lw#lsb);   call copy32(loc(addr(auto.punch.in.msb)),time);   if com16(ZERO.TIME,time) <> lw#igt               /* If the time is large enough */   then call sub16(ZERO.TIME,time);                 /* Remove "ZERO.TIME" offset */   else call str32(0,0,time);                       /* Else, put us at zero */   write(mdi) = time(lw#msb);                       /* Auto punch in time */   write(mdi) = time(lw#lsb);   call copy32(loc(addr(auto.punch.out.msb)),time);   if com16(ZERO.TIME,time) <> lw#igt               /* If the time is large enough */   then call sub16(ZERO.TIME,time);                 /* Remove "ZERO.TIME" offset */   else call str32(0,0,time);                       /* Else, put us at zero */   write(mdi) = time(lw#msb);                       /* Auto punch out time */   write(mdi) = time(lw#lsb);   /* Auto punch time and rehearse mode */   write(mdi) = shl(Auto.Punch.On,8) | Rehearse.Mode;   return(Send.Protocol.Packet(misc.ptr,1));end Send.Auto.Punch.Mode;/* Process a set auto punch mode command */dcl mark.is.saved fixed;dcl save.mark.dis fixed;dcl save.mark.msb fixed;dcl save.mark.lsb fixed;Set.Auto.Punch.Mode: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl mode      fixed;   dcl clear.lower proc external;   dcl emit.string proc(fixed, fixed array) external;   mode = shr(packet(0),8);                 /* Upper byte is mode */   if mode = 0   then do;                                 /* Auto punch mode off */      auto.punch.on = 0;      auto.punch.in.armed = 0;      new.seq.info = new.seq.info | 512;    /* Sync mode change */      if mark.is.saved <> 0 then do;        /* If we've previously turned mark ON, restore it */         pre.roll.msb = mark.button.msb;    /* Reset pre-roll in case mark moved during auto-punch */         pre.roll.lsb = mark.button.lsb;         mark.button.disabled = save.mark.dis;         if mark.button.disabled = 0        /* There is still a mark point... */         AND ((save.mark.msb <> 0)          /* ...set to a real value */         OR   (save.mark.lsb ige zero.time))         then do;            call set.sequencer.mark.start.point(save.mark.msb,save.mark.lsb,0);         end;         else do;                           /* Mark point went off */            mark.button.msb = save.mark.msb;            mark.button.lsb = save.mark.lsb;            if new.pan then do;               call Clear.Lower;               call Emit.String(16,'MARK POINT: OFF');            end;         end;         mark.is.saved = 0;         new.motion = 1;                    /* Be sure LOD knows */      end;   end;   else do;                                 /* Auto punch mode on */      auto.punch.on = 1;      auto.punch.in.armed = 0;              /* But not punching yet */      new.seq.info = new.seq.info | 512;    /* Sync mode change */      save.mark.dis = mark.button.disabled;      save.mark.msb = mark.button.msb;      save.mark.lsb = mark.button.lsb;      mark.is.saved = 1;      call set.sequencer.mark.start.point(pre.roll.msb,pre.roll.lsb,0);   end;   new.seq.info = new.seq.info | 128;    /* New motion status */   return(TRUE);end Set.Auto.Punch.Mode;Set.Rehearse.Mode: proc (packet) swapable;   dcl packet    array;   dcl state     fixed;   state = shr(packet(0),8);   if state < 0   OR state > 1   then return(TRUE);   Rehearse.Mode = state;   New.Seq.Info = New.Seq.Info | 128;    /* New motion status */   return(TRUE);end Set.Rehearse.Mode;Process.Set.Auto.Punch.Time: proc (packet) swapable;   dcl packet    array;   dcl which     fixed;   dcl time (1)  fixed;   call copy32(packet,time);   call add16(ZERO.TIME,time);          /* Add "ZERO.TIME" offset */   which = shr(packet(2),8);            /* Last (upper) byte is which */   do case which;      do;                       /* 0: intro (pre-roll) time */         call copy32(time,loc(addr(pre.roll.msb)));         if auto.punch.on <> 0         then call set.sequencer.mark.start.point(time(0),time(1),0);      end;      do;                       /* 1: rec in time */         call copy32(time,loc(addr(auto.punch.in.msb)));      end;      do;                       /* 2: rec out time */         call copy32(time,loc(addr(auto.punch.out.msb)));      end;   end;  /* of do case which */      New.Seq.Info = New.Seq.Info | 128;    /* New motion status */   return(TRUE);end Process.Set.Auto.Punch.Time;/* Fetch cue lock info looks at a description of the current  *//* cue.  It is passed in the end-of-track(s) and end-of-      *//* project times returned by fetch.dtd.info.  It compares     *//* the record region with the cue and finds out what areas    *//* of the disk can be recorded.  It returns the two times     *//* between which cue lock recording is possible.              */dcl Cue.Lock.Case     fixed public;dcl Cue.Lock.Time (1) fixed public;Fetch.Cue.Lock.Info: proc(time1, time2, time3, code) public swapable;   dcl time1       array;    /* pass end of track time now    */   dcl time2       array;    /* pass end of project           */   dcl time3       array;    /* sync time is returned here    */   dcl code        fixed;    /* 0: request only, 1:set cue lock globals */   dcl start (1)   fixed;   dcl stop  (1)   fixed;   dcl sync  (1)   fixed;   dcl time  (1)   fixed;   dcl a     (1)   fixed;   dcl mode        fixed;   dcl temp  (4 )  fixed;   dcl cuebits     fixed;   dcl base        fixed;   round32:proc(num);      /* routine to round up by 128 samples */      dcl num array;      call ADD16(128,num);      num(lw#lsb) = num(lw#lsb) & "177400";   end round32;   call COMPUTE.ACTUAL.DTD.IN.SAMPLE.#(Current.Cue.Ptr);   write(mam) = Current.Cue.Ptr;     /* look up info from current cue */   write(mal) = CUE.S.MSB;           /* get info about current cue    */   call COPY.IN(addr(start(0)), 2);   write(mal) = CUE.E.MSB;   call COPY.IN(addr(stop (0)), 2);   write(mal) = CUE.SMPT.MSB;   call COPY.IN(addr(sync (0)), 2);   write(mal) = CUE.SMPT.MODE;   mode       = read(md);   write(mal) = CUE.BITS;   cuebits    = read(md);   write(mal) = CUE.LIST.PTR;   base       = read(md);   /* sync time is easy: */   if (cuebits & bit3) = 0      /* cue.smpt.msb is relative to smpte offset */   then call SBITS.TO.MSEC(sync ,cf#time, SAMP.SPEED, mode, sync);   else do;      call SBITS.TO.SMPTE(sync, mode, temp);      call SMPTE.TO.MSEC(temp, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), sync);      if sync(0) < 0           /* but might be before start of sequence */      then call STR32(0, zero.time, sync);   end;   call COPY32(sync, time3);   /* return sync time of current cue in msecs */   /* compute in/out times with respect to current proj */   call SUB32(stop, start, time);     /* get cue length, samples */   write(mam) = Current.Cue.Ptr;      /* and get in.s#           */   write(mal) = CUE.IN.S#.MSB;   call COPY.IN(addr(start(0)), 2);   /* actual in sample #      */   call ADD32(start, time, stop);     /* and abs out time        */   /* make sure cue is in current project: */   call COPY32(start, a); call ROUND32(a);   if  (COM32(a, AEE.Current.Project.Base) >= lw#ieq)   and (COM32(a, AEE.Current.Project.End )  = lw#ilt)   and (base                                = 0     )   then do;      if COM32(stop, AEE.Current.Project.End) = lw#igt      then call COPY32(AEE.Current.Project.End, stop);      call DTD.Sample.#.To.Msecs(Start, CF#Time, SAMP.SPEED, AEE.Current.Project.Rate, AEE.Current.Project.Base, Start);      call DTD.Sample.#.To.Msecs(Stop,  CF#Time, SAMP.SPEED, AEE.Current.Project.Rate, AEE.Current.Project.Base, Stop );      /* if cue extends up to the end of the recorded      */      /* area, allow recording from start of cue to        */      /* end of project:                                   */      call COPY32(stop, temp);   /* extend cue by 100 msecs to account for */      call ADD16 (100,  temp);   /* round off.                             */      if (COM32(temp, time1) >= lw#ieq)   /* if cue extends up to end of track */      or ((Armed.For.Protocol.DTD.Recording = 1)  /* or we are already cue punching */      and (cue.lock.case = 2))            /* to end of project */      then do;                            /* allow recording to end of project */         if  (code = 1)                   /* caller wants globals set up   */         then do;            cue.lock.case = 2;                 /* set case code for correct cue     */            call COPY32(time1, Cue.Lock.Time); /* save current end of track */         end;         call COPY32(start, time1);       /* now load start time - stop time is end of project in this case (already loaded above) */      end;      else do;                            /* Otherwise, just allow         */         call COPY32(start, time1);       /* recording directly over       */         call COPY32(stop,  time2);       /* the cue.                      */         if  (code = 1)                   /* caller wants globals set up   */         then do;            cue.lock.case = 1;         end;      end;   end;   /* if cue is not in current project, just set record */   /* information to zero length. Also do same if       */   /* cue is an edited reel:                            */   else do;      call COPY32(time1, time2);   end;end Fetch.Cue.Lock.Info;Process.Allocate.Recording.Time.Available: proc(packet,des,len,code) swapable;   dcl packet array;    /* and pass incoming packet  */   dcl des    fixed;    /* pass node it came from    */   dcl len    fixed;    /* length of incoming packet */   dcl code   fixed;    /* 0 = allocate; 1 = cue loc */   dcl tag    fixed;   dcl base   fixed;   dcl trks   fixed;   dcl i      fixed;   dcl time1    ( 1) fixed;   dcl time2    ( 1) fixed;   dcl time3    ( 1) fixed;   dcl length   ( 1) fixed;   dcl modes    (15) fixed;   dcl statuses (15) fixed;   dcl cuetrks       fixed;   dcl toready       fixed;   dcl tosafe        fixed;   tag  = packet(0);            /* Get incoming message id tag */   if len = Able_Packet_Head + 4      /* if no incoming tracks, only a "tag" */   then do;      base = 0;               /* Default */      trks = 0;               /* send a 0 to the lod so it looks at the ready tracks */   end;   else do;      base = packet(1);       /* First track bit is this one */      trks = packet(2);       /* else these are tracks of interest      */   end;   if base <> 0   then return(TRUE);           /* Someday we'll cope with different bases, if necessary */   if code <> 0 then do;        /* If looking at cue lock, ready the right tracks */      write(mam) = Current.Cue.Ptr;  /* get tracks for this cue  */      write(mal) = cue.trks;      cuetrks    = read(md);      toready    = 0;      tosafe     = 0;      if trks <> 0 then trks = cuetrks;      call SEND.FOR.DTD.TRACK.MODES(modes, statuses);      do i = 0 to 15;                 /* lookup new ready bits */         if (statuses(i) = 1)         /* if track is ready     */         and ((cuetrks & bits(i)) = 0)         then tosafe = (tosafe \ bits(i)) & DTD.AVAIL.TRKS;         if (statuses(i) <> 1)        /* if track is not ready */         and ((cuetrks & bits(i)) <> 0)         then toready = (toready \ bits(i)) & DTD.AVAIL.TRKS;      end;      if tosafe  <> 0 then call Set.DTD.Drive.Status(0, tosafe );      if toready <> 0 then call Set.DTD.Drive.Status(1, toready);   end;   call FETCH.DTD.AUTO.ALLOCATE.TIME(trks,time1,time2);   /* If doing cue lock recording,  see where the current cue lies */   /* with respect to this recording area and adjust               */   /* accordingly:                                                 */   if code <> 0 then do;      call Fetch.Cue.Lock.Info(time1, time2, time3, 0);   /* just look up times */   end;   call SUB32(time2,time1,length);   call Remove.Zero.Time.Offset(time1);   /* Send back:  message tag                     */   /*             disk address to start recording */   /*             length one can record for       */   write(mam) = misc.ptr;      write(mdi) = L#Recording_Time_Avail;   write(mdi) = des;   write(mdi) = T#Recording_Time_Avail;   write(mdi) = tag;   write(mdi) = time1  (lw#msb);   write(mdi) = time1  (lw#lsb);   write(mdi) = length (lw#msb);   write(mdi) = length (lw#lsb);   return(Send.Protocol.Packet(misc.ptr,1));end Process.Allocate.Recording.Time.Available;Send.DTD.Status.Packet: proc(packet,des) swapable;   dcl packet  array;            /* pass incoming packet        */   dcl des     fixed;   dcl tag     fixed;   dcl info(1) fixed;   dcl state   fixed;   tag = packet(0);             /* get incoming message id tag */   /* fetch.dtd.drive status sets up a two word array indicating the */   /* state of the direct to disk                                    */   /*                                                                */   /*   array(0) = 0 if not recording                                */   /*              1 if armed                                        */   /*              2 if recording (but not armed) ??????             */   /*              3 if recording and armed                          */   /*   array(1) = tracks we are recording on at the moment          */   call FETCH.DTD.DRIVE.STATUS(info);   /* Create bit encoded reply:                                      */   /*    1 = DTD is ready for recording (READY lights on bridge)     */   /*    2 = DTD is armed for recording (armed message received)     */   /*    4 = DTD is actually  recording                              */   /*    8 = DTD is playing audio                                    */   /*   16 = DTD is scrubbing                                        */   state = 0;   if DTD.Play.State = 2       /* Playing a cue segment                 */   OR DTD.Play.State = 3       /* Playing a segment w/o moving AEE flag */   OR DTD.Play.State = 5       /* Cue triggered from cue directory      */   then state = state | 8;     /* Indicate that we are playing audio    */   else if DTD.Play.State = 7  /* Scrubbing a cue                       */   then state = state | 16;    /* Indicate that we are playing audio    */   write(mam) = misc.ptr;      write(mdi) = L#DTD_Rec_State;   write(mdi) = des;   write(mdi) = T#DTD_Rec_State;   write(mdi) = tag;   write(mdi) = (shl(info(0),1) & "6") | DTD.Ready.Enabled | state;   return(Send.Protocol.Packet(misc.ptr,1));end Send.DTD.Status.Packet;/* Initialize.Armed.Recording.States is used to initialize the *//* public variables that the operating system uses to keep     *//* track of protocol dtd recording.   The OS must do this to   *//* create the cue after doing allocate mode recording.         *//* This routine is called after we have supposedly armed       *//* the DTD for recording.   If perhaps we could not do any     *//* recording (for example if the project is locked),  then     *//* the state variables will be cleared.                        */Initialize.Armed.Recording.States: proc(state, time) swapable;   dcl state      fixed; /* pass code for Armed.for.Protocol.DTD.Recording */   dcl time       array; /* disk time (allocate mode only) we start at     */   dcl info(1)    fixed;   /* Assume the arm was successful: */   Armed.for.Protocol.DTD.Recording = state;   call COPY32(time, Protocol.Recording.Time);   Protocol.Recording.Drives        = 0;   /* See whether we are indeed armed or actually recording:               */   call FETCH.DTD.DRIVE.STATUS(info);   Protocol.Recording.State = info(0);   if Protocol.Recording.State = 0   then do;      Armed.for.Protocol.DTD.Recording = 0;      DTD.Play.State = 0;   end;   /* Keep track of which drives we are actually recording on: */   if (Protocol.Recording.State & 2) <> 0   then Protocol.Recording.Drives = info(1);end Initialize.Armed.Recording.States;Arm.DTD.for.manual.allocate.recording: proc(packet, code) swapable;   dcl packet array;    /* pass incoming packet - contains max length to record for */   dcl code   fixed;    /* 0 = allocate; 1 = cue lock */   dcl time1 (1)  fixed;   dcl time2 (1)  fixed;   dcl time3 (1)  fixed;   dcl length(1)  fixed;   /* Make sure the external software has readied for recording: */   if DTD.Ready.Enabled = 0 then do;      call Present.Protocol.Error.Message(NT#PleaseReadyTracks,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* Get the auto allocate time for READY tracks */   call FETCH.DTD.AUTO.ALLOCATE.TIME(0, time1, time2);   cue.lock.case = 0;   if code <> 0 then do;      call Fetch.Cue.Lock.Info(time1, time2, time3, 1);  /* look up times and set up globals */   end;   /* see if we are trying to record for too long */   call SUB32(time2, time1, length);   if COM32(packet, length) = lw#igt   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   call ADD32(time1, packet, time2);   call RECORD.DTD.SYNCED.TO.SYNCLAV(zero.zero,	/* for manual trigger pass 0 */                                     time1,		/* disk address to start at  */                                     time2,		/* disk address to end   at  */                                     0,			/* use READY tracks          */                                     0,			/* 0 = manual trigger        */                                     0,			/* no REHEARSE               */                                     0,			/* no trackbits              */                                     0);			/* no audiobits              */   DTD.Play.State = 6;  /* manual armed recording    */   /* Set up initial states of the public variables */   call Initialize.Armed.Recording.States(1, time1);   return(TRUE);end Arm.DTD.for.manual.allocate.recording;Arm.DTD.for.seq.trig.allocate.recording: proc(packet, code) swapable;   dcl packet array;    /* pass incoming packet                        */                        /*   0 = seq time to start recording at        */                        /*   2 = length to record for                  */                        /*   4 = uper half = 0 = record, 1 = rehearse  */   dcl code       fixed;/* 0 = allocate; 1 = cue lock                  */   dcl stime (1)  fixed;   dcl len   (1)  fixed;   dcl out   (1)  fixed;   dcl time1 (1)  fixed;   dcl time2 (1)  fixed;   dcl time3 (1)  fixed;   dcl temp  (1)  fixed;   dcl delta      fixed;   dcl rate       fixed;   dcl rehearse   fixed;   dcl i          fixed;   dcl samples    lit  '128';  /* Number of samples in 1/2 sector on the DTD */   /* Make sure the external software has readied for recording: */   if DTD.Ready.Enabled = 0 then do;      call Present.Protocol.Error.Message(NT#PleaseReadyTracks,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* Get arguments; put "times" in Synclavier format */   call copy32(packet,stime);               /* Get seq time */   call add16(ZERO.TIME,stime);             /* Add "ZERO.TIME" offset */   call copy32(loc(addr(packet(2))),len);   /* Get length */   rehearse = shr(packet(4), 8);            /* Get rehearse state */   /* Be sure we are recording AT LEAST the audio requested.  This is */   /* necessary because the DTD only works to the NEAREST SECTOR.     */   /* What we do is calculate how many milliseconds are in 1/2 sector */   /* and extend the start and end times by that much.                */   /* This is only done for CMX recording where we know we want to    */   /* capture a certain amount of audio and we are recording at the   */   /* end of the project.  For cue lock recording,  use the passed    */   /* valued directly.                                                */   if code = 0 then do;                     /* allocate only...            */      rate = Fetch.DTD.Sampling.Rate;       /* Samples per 1/100 of a sec */      load rate;      div 10;                               /* Convert to samples per msec */      rate = res;      load samples;                         /* Samples in 1/2 sector */      div rate;                             /* SAMP / (SAMP/MSEC) = MSEC */      delta = res;                          /* msec to widen start & end by */      if rem <> 0 then delta = delta + 1;   /* Always round up */      if com16(ZERO.TIME+delta,stime) <> lw#igt /* If the time is large enough */      then do;         call sub16(delta,stime);           /* Move back a few msec */         call add16(shl(delta,1),len);      /* Add to len what we subtracted, plus another delta */      end;      else do;         i = stime(lw#lsb) - ZERO.TIME;     /* Amount we will subtract */         if i > delta then i = delta;       /* But no more than a delta */         call str32(0,ZERO.TIME,stime);     /* Put start at zero */         call add16(i,len);                 /* Add to len what we subtracted */         call add16(delta,len);             /* Also add another delta */      end;   end;   /* Get the auto allocate time for READY tracks */   call FETCH.DTD.AUTO.ALLOCATE.TIME(0, time1, time2);   /* adjust for cue lock recording if needed:    */   cue.lock.case = 0;   if code <> 0 then do;      call Fetch.Cue.Lock.Info(time1, time2, time3, 1);  /* look up times and set up globals */      call ADD32(stime, len, out);            /* get sync punch out time   */      /* If doing cue lock recording, check/adjust sequencer time  */      /* as needed                                                 */      if COM32(out, time3) <= lw#ieq           /* if punching out before   */      then do;                                 /* start of cue, then no    */         return(TRUE);                         /* can do!!!                */      end;      if COM32(stime, time3) = lw#ilt          /* if the punch-in time is  */      then do;                                 /* before the sync time...  */         call COPY32(time3, stime);            /* then delay recording     */         call SUB32 (out, stime, len);         /* get new length           */      end;                                     /* to start of cue          */      else do;                                 /* see how far into cue we  */         call SUB32(stime, time3, temp);       /* want to punch in at.     */         call ADD32(time1, temp, time1);       /* punch in later into cue  */         if COM32(time1, time2) >= lw#ieq      /* if past end of cue       */         then do;                              /* then user missed the     */            return(TRUE);                      /* end of the cue...        */         end;      end;      call SUB32(time2, time1, temp);          /* get length avail on disk */      if COM32(len, temp) = lw#ilt             /* if recording for short   */      then do;                                 /* time, then limit end     */         call ADD32(time1, len, time2);      end;   end;   /* else if allocate (vs cue lock) make sure we are not trying to        */   /* record past the end of the project:                                  */   else do;      /* compute the disk punch out time:            */      call ADD32(time1, len, out);      /* punch out early if desired:                 */      if COM32(out, time2) = lw#ilt      then call COPY32(out, time2);   end;   call RECORD.DTD.SYNCED.TO.SYNCLAV(stime,    /* seq time to start record */                                     time1,    /* disk address to start at */                                     time2,    /* disk address to end   at */                                     0,        /* use READY tracks         */                                     1,        /* 1 = seq trig no resync   */                                     rehearse, /* 1 = rehearse             */                                     0,        /* no trackbits             */                                     0);       /* no audiobits             */   DTD.Play.State = 8;                        /* sequencer armed recording */   call Initialize.Armed.Recording.States(1, time1);   return(TRUE);end Arm.DTD.for.seq.trig.allocate.recording;Arm.DTD.for.punch.in.recording: proc(packet) swapable;   dcl packet array;    /* pass incoming packet                        */                        /*   0 = seq time to start recording at        */                        /*   2 = length to record for                  */                        /*   4 = uper half = 0 = record, 1 = rehearse  */   dcl stime(1) fixed;   dcl time (1) fixed;   dcl rehearse fixed;   call copy32(packet,stime);           /* Get seq time */   call add16(ZERO.TIME,stime);         /* Add "ZERO.TIME" offset */   /* Make sure the external software has readied for recording: */   if DTD.Ready.Enabled = 0 then do;      call Present.Protocol.Error.Message(NT#PleaseReadyTracks,ATTR#Reverse,0,0,0);      return(TRUE);   end;   rehearse = shr(packet(4), 8);   call ADD32(stime, loc(addr(packet(2))), time);   call RECORD.DTD.SYNCED.TO.SYNCLAV(stime,    /* seq time to start record */                                     stime,    /* disk address to start at */                                     time,     /* disk address to end   at */                                     0,        /* use READY tracks         */                                     1,        /* 1 = seq trig no resync   */                                     rehearse, /* 1 = rehearse             */                                     0,        /* no trackbits             */                                     0);       /* no audiobits             */   DTD.Play.State = 8;                        /* sequencer armed recording */   call Initialize.Armed.Recording.States(2, stime);   return(TRUE);end Arm.DTD.for.punch.in.recording;Set.Ext.Rec.Triggers: proc(packet) returns (boolean) swapable;   dcl packet array;    /* pass incoming packet          */                        /*   0 = preroll trigger time    */                        /*   2 = record in trigger time  */                        /*   4 = record out trigger time */   if d34gpi.there then do; /* must have a D34GPI to do this */      call copy32(packet,               preroll_trigger); /* pick up triggers */      call copy32(loc(addr(packet(2))), rec_in_trigger);      call copy32(loc(addr(packet(4))), rec_out_trigger);      call add16(ZERO.TIME, preroll_trigger);             /* add "ZERO.TIME" offset */      call add16(ZERO.TIME, rec_in_trigger);      call add16(ZERO.TIME, rec_out_trigger);      ext.rec.trigger.state = 1;                          /* trigger during recording */      check.sequencer.times = 1;                          /* set so next var will be looked at */   end;   return(true);end Set.Ext.Rec.Triggers;Erase.Current.Cue.For.Retake: proc swapable;   dcl time1(1)   fixed;   dcl time2(1)   fixed;   dcl time3(1)   fixed;   dcl time4(1)   fixed;   dcl hist.rec(CUE.HIST.REC.LEN - 1) fixed;   dcl id         fixed;   /* This protocl message will erase the section of the direct-to-disk */   /* that is reflected by the current cue.  It is up to the user to    */   /* make sure that the current cue reflects a section of the          */   /* direct-to-disk that should be erased!!                            */   /* First make sure there are no edit flags present:                  */   write(mam) = Current.Cue.Ptr;   write(mal) = cue.list.ptr;   if (read(mdi) <> 0)   or (read(mdi) <> 0)   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* Fetch the recording times associated with the current project: */   call FETCH.DTD.AUTO.ALLOCATE.TIME(0, time1, time2);   /* Map the cue in & out times to the current project:             */   call ADD32(Cue.In.Time,  Cue.Time.Display.Offset, time3);   call ADD32(Cue.Out.Time, Cue.Time.Display.Offset, time4);   /* see if cue time is before current project:                     */   if (time3(0) < 0) or (time4(0) < 0) then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* see if times are after current project:                        */   if (COM32(time3, time2) = lw#igt)   or (COM32(time4, time2) = lw#igt)   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* log cue as deleted for Quick Updates */   write(mam) = Current.Cue.Ptr;   write(mal) = cue.alloc#;   id = read(md);   call BUILD.CUE.HIST.REC(id,1,hist.rec);   call ADD.CUE.TO.HIST(hist.rec);   /* and erase that region (should delete cue(s) as well) */   call ERASE.DTD.DRIVE.AREA(Current.Cue.Drive.Bits,                             Time3, Time4);   return(TRUE);end Erase.Current.Cue.For.Retake;/* Block.Cue.During.Allocate is only called during allocate mode *//* recording.   It creates a current cue that represents the     *//* recording time to date.                                       */Block.Cue.During.Allocate: proc swapable;   dcl time1  (1)  fixed;   dcl time2  (1)  fixed;   dcl time3  (1)  fixed;   dcl time4  (1)  fixed;   dcl buf    (4)  fixed;   /* Make sure we are doing protocol allocate mode recording: */   if Armed.for.Protocol.DTD.Recording <> 1   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* Make sure recording is actually going on now:            */   call FETCH.DTD.DRIVE.STATUS(buf);   if (buf(0)&2) = 0   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* See if the allocate times have changed, if so    */   /* assume it means we did a recording.  Define a    */   /* cue that covers the recorded area and create a   */   /* system event saying the allocate recording has   */   /* been completed.                                  */   call FETCH.DTD.SYNC.POINT        (   time3, time4);   call FETCH.DTD.AUTO.ALLOCATE.TIME(0, time1, time2);   /* time1 = length of DTD track(s) now						*/   /* time2 = length of current project						*/   /* time3 = disk address we started recording at			*/   /* timr4 = sequencer time we started recording at		*/   /* note: presumably TIME3 = PROTOCOL.RECORDING.TIME)	*/   /* Create the cue if we actually recorded some audio: */   if COM32(time1, Protocol.Recording.Time) <= lw#ieq   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      return(TRUE);   end;   /* Update the lod's sync time as we are blocking cues so the OS will */   /* know what the sync time is for the remaining cues:                */   call SET.DTD.SYNC.POINT(time1);   /* Create this cue as a current cue:                */   call SET.DTD.CURRENT.REEL(0);           /* sel "CUE" */   call CREATE.DTD.AUTO.ALLOCATE.CUE        (Protocol.Recording.Time,    /* disk start time */         time1,                      /* disk end   time */         Protocol.Recording.Drives,  /* track bits      */         time4);                     /* sync time       */   write(mam) = Current.Cue.Ptr;           /* copy      */   call COPY.OUT(addr(misc.buf(0)), 256);  /*      out  */   /* Set up all the AEE global variables and create    */   /* whatever new cue events are needed:               */   call Deposit.A.New.Current.Cue(1);   /* Update the protocol.recording.time in case        */   /* we someday start blocking cues:                   */   call COPY32(time1, Protocol.Recording.Time);   return(TRUE);end Block.Cue.During.Allocate;/* $Subtitle  Dispatch to routine to handle individual creation/recording command */Handle.Creation.Recording: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam)   = Packet.Ptr;   write(mal)   = P#LEN;    len     = read(md);   write(mal)   = P#SOURCE; des     = read(md);   write(mal)   = P#TYPE;      subtype      = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   if subtype < 16   then do case subtype;         /* Branch on specific command (0-15) */      do;  /* 0:  Start Record */         ret = Process.Start.Record.Command;      end;      do;  /* 1:  Start Punch */         ret = Process.Start.Punch.Command;      end;      do;  /* 2:  Stop Record */         ret = Process.Stop.Record.Command;      end;   end;             /* of branch on specific command (0-15) */   else if subtype < 32   then do case (subtype - 16);  /* Branch on specific command (16-31) */      do;  /* 16:  Set Auto Punch Mode */         ret = Send.Auto.Punch.Mode(packet,des);      end;      do;  /* 17:  Auto Punch Mode */         /* This is handled by the request routine */      end;      do;  /* 18:  Set Auto Punch Mode */         ret = Set.Auto.Punch.Mode(packet,des);      end;      do;  /* 19:  Set Rehearse Mode */         ret = Set.Rehearse.Mode(packet);      end;      do;  /* 20:  Set An Auto Punch Time */         ret = Process.Set.Auto.Punch.Time(packet);      end;   end;             /* of branch on specific command (16-31) */   else if subtype < 48   then do case (subtype - 32);  /* Branch on specific command (32-47) */      do;  /* 32:  Request recording time available */         ret = Process.Allocate.Recording.Time.Available(packet,des,len,0);      end;      do;  /* 33:  Send recording time available */         /* This is handled by the request routine */      end;      do;  /* 34:  Request current status of armed recording */         ret = Send.DTD.Status.Packet(packet,des);      end;      do;  /* 35:  Arm/recording state */         /* This is handled by the request routine */      end;      do;  /* 36:  Set DTD record ready */         if shr(packet(0), 8) = 0                     /* clean up aborted */         then Armed.For.Protocol.DTD.Recording = 0;   /* ops on safing    */         call SET.DTD.READY.LIGHT(shr(packet(0), 8));      end;      do;  /* 37:  Arm DTD for manual allocate recording */         ret = Arm.DTD.for.manual.allocate.recording(packet, 0);      end;            do;  /* 38:  Arm dtd for seq trig allocate recording */         ret = Arm.DTD.for.seq.trig.allocate.recording(packet, 0);      end;      do;  /* 39:  Arm dtd for seq trig allocate recording */         ret = Arm.DTD.for.punch.in.recording(packet);      end;      do;  /* 40:  Set external record triggers */         ret = Set.Ext.Rec.Triggers(packet);      end;      do;  /* 41:  Request cue lock recording time available */         ret = Process.Allocate.Recording.Time.Available(packet,des,len,1);      end;      do;  /* 42:  Arm DTD for manual cue lock recording */         ret = Arm.DTD.for.manual.allocate.recording(packet, 1);      end;            do;  /* 43:  Arm dtd for seq trig cue lock recording */         ret = Arm.DTD.for.seq.trig.allocate.recording(packet, 1);      end;   end;             /* of branch on specific command (32-47) */   else if subtype < 64   then do case (subtype - 48);  /* Branch on specific command (48-63) */      do;  /* 48:  Erase current cue for retake */         ret = Erase.Current.Cue.For.Retake;      end;      do;  /* 49:  Block current cue while doing allocate recording */         call Block.Cue.During.Allocate;      end;   end;             /* of branch on specific command (48-63) */   return(ret);             /* return processed status */end Handle.Creation.Recording;