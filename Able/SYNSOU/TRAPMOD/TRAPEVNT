/* TRAPEVNT   $TITLE  ROUTINES TO PROCESS EVENTS PACKETS   Modified:   01/30/91 - MWH - Report which tracks have had new notes   12/14/89 - MWH - Move "AEE Notice" from Utilities to Events super-type   08/28/89 - MWH - Rework the protocol for release 2.2   05/24/89 - MWH - Don't change event enables remotely (yet)   05/19/89 - MWH - Add new protocol messages for MAC event editor window   05/02/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/22/89 - MWH - changed event status bulk to seq info only   03/14/89 - PF  - changed process packet processing logic   11/28/88 - MWH - Clean up unreferenced public's   09/15/88 - PF - Created this source file*/Set.Event.Enables: proc (des,packet) swapable;   dcl des    fixed;   dcl packet array;   dcl bit    fixed;   dcl chan   fixed;   dcl i      fixed;   /* Get actual board # for this node: */   chan = map.d115.node.id(des);           /* get board/channel #       */   bit = bits(chan);                       /* bit to mask for tracks    */   if chan = (-1)                          /* not found, cannot         */   then return(TRUE);                      /* process!!                 */   write(mam) = D115D.Event.Enable.Ptr;    /* index to enable bits      */   write(mal) = chan * num.of.OS.events;   /* for this board            */   do i = 0 to (num.of.OS.events-1);      write(mdi) = packet(i);   end;   /* If we've enabled this channel for reporting new notes or timbres, */   /* init the array in external memory where we save the tracks which  */   /* change. */   if ((packet(get.OS.seq.info) & ("2" | "4")) <> 0) then do;      write(mam) = D115D.Note.Change.Tracks;      write(mal) = 2;               /* Ignore the 2 keyboard tracks */      do i=0 to 253;                /* We need to cover 200 tracks (but we have 254 words in external memory) */         write(mdi) = read(md) & not(bit);      end;   end;   return(TRUE);end Set.Event.Enables;Broadcast.AEE.Notice: proc (des,id,arg1,arg2,arg3) public swapable;   dcl des        fixed;              /* packet destination */   dcl id         fixed;              /* error id           */   dcl arg1       fixed;   dcl arg2       fixed;   dcl arg3       fixed;   write(mam) = misc.ptr;      write(mdi) = L#AEE_Notice;   write(mdi) = des;   write(mdi) = T#AEE_Notice;   write(mdi) = id;   write(mdi) = arg1;   write(mdi) = arg2;   write(md ) = arg3;   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      return(FALSE);               /* return zero - try again later         */   end;   return(TRUE);                   /* success */end Broadcast.AEE.Notice;Handle.Events: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   do case subtype;    /* branch on specific sound editing command */      do; /*  0:  set event enables */         ret = Set.Event.Enables(des,packet);      end;   end;   /* Note: 160 = Broadcast.AEE.Notice; sent as messages are generated */   /* It is called directly from the AEE -- see AUD-NOTE */   return(ret);             /* return processed status */end Handle.Events;