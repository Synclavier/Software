/* TRAPTS2   $TITLE  ROUTINES TO PROCESS TRACK SETUP PACKETS   Modified:   10/10/91 - MWH - Add Request Single Track State message   09/11/91 - cj  - Fixed bug where setting track outputs broke O page   05/23/91 - MWH - Retry MIDInet routing packets since Able is too fast for D115D   04/09/91 - MWH - added cue tracks to multichannel routing request   03/04/91 - MWH - Force an answer from "request DTD outputs" even when DTD is down   10/26/90 - MWH - Force an "answer" from all "request" messages   09/10/90 - TSS - Moved code in SET.MULTICHANNEL.ROUTING to new proc in SEQSOU   03/07/90 - PF  - added Valid.Tracks proc and call to it   02/21/90 - MWH - deal with empty track heads (change from PForstman)   01/31/90 - MWH - Fix some protocol bugs for Paul   01/11/90 - MWH - Update AEE proj/event panels when DTD/MCH routing changes   01/03/90 - MWH - Request all routing info is shorter with DTD tracks   09/20/89 - PF  - Allow MIDI inputs to be mapped to tracks with no heads   09/08/89 - PF  - (MWH) Merged in Paul's MIDI changes, modified for 2.2   09/01/89 - MWH - Rework the protocol for release 2.2   09/01/89 - MWH - Split from TRAPTS*//* This file contains ROUTING procedures: MIDI, DTD, Multichannel */Send.DTD.Inputs: proc (track,des,tag) swapable;   dcl track     fixed;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl source    fixed;  /* 0=STM, 1=DIG, 2=DTD out, 3=DTD track */   dcl channel   fixed;   dcl dtd.track fixed;   dcl i         fixed;   if (track < first.lod.track)   OR (track >= last.lod.track)   then do;                               /* Bad parameters; quit */      call Send.Only.Tag(des,tag,T#DTD_Inputs);      return(TRUE);   end;   dtd.track = track - first.lod.track;   /* Make a "DTD track" (0 to 15) */   call Snarf.Track.Directory;            /* get track directory  */   i = (16 * dtd.track) + 10;                   /* Index into data: "+ 10" skips 8 words of track title, status/mode word, used word */   write(mam) = SCSI.Ptr + shr(i,8);   write(mal) = i;                              /* 10 skips 8 words of track title, status/mode word, used word */   source    = shr(read(md),8);                 /* Get DTD source */   channel   = read(mdi) & "377";               /* Get DTD channel */   write(mam) = misc.ptr;      write(mdi) = L#DTD_Inputs;   write(mdi) = des;   write(mdi) = T#DTD_Inputs;   write(mdi) = tag;   write(mdi) = sync.to.proto.dtrk(track);   write(mdi) = shl(source,8) | channel;   return(Send.Protocol.Packet(misc.ptr,1));  end Send.DTD.Inputs;Send.Midi.Inputs: proc (channel,des,tag) swapable;   dcl channel   fixed;   dcl des       fixed;   dcl tag       fixed;      /* Caller's ID to be returned */   dcl track     fixed;      /* We find this from channel passed in */   dcl port      lit '1';    /* For now, there is only one input port! */   dcl i         fixed;   if max.midi.chan=0        /* Can't change routing if no midi */   then return(TRUE);   i = channel + 1;   track = midi.mapping(i);   write(mam) = misc.ptr;      write(mdi) = L#Midi_In_Out;   write(mdi) = des;   write(mdi) = T#Midi_In_Out;   write(mdi) = tag;   write(mdi) = sync.to.proto.strk(track);    /* Track number */   write(mdi) = shl(0,8) | port;              /* 0=MIDI in; MIDI input number */   write(mdi) = shl(channel,8);               /* Input channel number */   return(Send.Protocol.Packet(misc.ptr,1));end Send.Midi.Inputs;/* Extracts midi output number from routing word (borrowed from ROUTSOUA) */EXTRACT.MIDI.OUTPUT:  proc(wd) fixed swapable;   dcl wd fixed;   if (wd & THD.MIDI.ORIG) == 0 then return (-1);       /* no old midi info */   if (wd & THD.MIDI.OMS ) != 0 then return (-1);       /* no old midi info (is OMS) */   return shl((wd&"37")-midi.subsys,2)+(shr(wd,5)&3);end EXTRACT.MIDI.OUTPUT;Send.Midi.Outputs: proc (track,des,tag) swapable;   dcl track     fixed;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl port      fixed;   dcl channel   fixed;   dcl i         fixed;   if max.midi.chan=0        /* Can't change routing if no midi */   then return(TRUE);   if track <> 1 then do;                     /* exclude split keyboard */      /* Port is in low byte and channel in low 4 bits of upper byte */      i = TRK.HEAD.LOOKUP(track,thd.midi);      port = EXTRACT.MIDI.OUTPUT(i);      if port = (-1)                          /* if the value is invalid */      then return(1);      else port = port + 1;                   /* make it start at '1'    */      channel = (shr(i,8) & "17") + 1;   end;   else return(TRUE);   write(mam) = misc.ptr;      write(mdi) = L#Midi_In_Out;   write(mdi) = des;   write(mdi) = T#Midi_In_Out;   write(mdi) = tag;   write(mdi) = sync.to.proto.strk(track);    /* Track number */   write(mdi) = shl(1,8) | port;              /* 1=MIDI out; MIDI out number */   write(mdi) = shl(channel,8);               /* Output channel number */   return(Send.Protocol.Packet(misc.ptr,1));end Send.Midi.Outputs;Send.Multichan.Outputs: proc (track,des,tag) swapable;   dcl track     fixed;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl left      fixed;   dcl right     fixed;   dcl i         fixed;   if  (track >= First.Lod.Track)                   /* check L1 - L16    */   and (track <  Last.Lod.Track )   then do;                        /* Send back a short message with only a tag */      call Send.Only.Tag(des,tag,T#Multichan);      return(TRUE);                                 /* Not multichannel  */   end;   else if TRK.HEAD.LOOKUP(track,THD.CUE.TRACK)<>0  /* Cue track */   then do;      left = TRK.HEAD.LOOKUP(track,THD.CUE.OUT);    /* Get dtd output #  */      if left <> 0 then left = (left & 63) + 1;     /* Map value if routing exists */   end;   else if (TRK.HEAD.LOOKUP(track,THD.NN.MSB)<>0)   /* non-empty, non-Q  */   OR      (TRK.HEAD.LOOKUP(track,THD.NN.LSB)<>0)   /* track: get mc #   */   OR      (track = 0)                              /* or keyboard       */   then do;      i = TRK.HEAD.LOOKUP(track,THD.TROU);      left = (shr(i,8) & "77") + 1;      right = (i & "77") + 1;   end;   else do;                                         /* none of the above */      call Send.Only.Tag(des,tag,T#Multichan);      return(TRUE);   end;   write(mam) = misc.ptr;      write(mdi) = L#Multichan;   write(mdi) = des;   write(mdi) = T#Multichan;   write(mdi) = tag;   write(mdi) = sync.to.proto.strk(track);    /* Track number */   write(mdi) = shl(left,8) | right;   return(Send.Protocol.Packet(misc.ptr,1));end Send.Multichan.Outputs;Send.DTD.Outputs: proc (track,des,tag) swapable;   dcl track     fixed;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl dtd.track fixed;   dcl left      fixed;   dcl right     fixed;   dcl i         fixed;   if  (track >= First.Lod.Track)                   /* check L1 - L16    */   and (track <  Last.Lod.Track )   then do;      if Lod.Running = 0                            /* better have a DTD */      OR DTD.Max.Secs = 0      then do;         call Send.Only.Tag(des,tag,T#DTD_Outputs);         return(TRUE);      end;      dtd.track = track - First.Lod.Track;          /* get dtd trk#      */      left = 0;                                     /* assume no routing */      call Snarf.Track.Directory;                   /* get track directory */      write(mam) = Scsi.Ptr;                     /* look up tdir info */      write(mal) = dtd.track * mtrk.blen + trout.off;      left = read(md) & "377";      if left > DTD.Num.Voices                   /* if invalid voice  */      then left = 0;                             /* then delete it    */      right = left;   end;   else if TRK.HEAD.LOOKUP(track,THD.CUE.TRACK)<>0   then do;                                     /* cue track         */      i = TRK.HEAD.LOOKUP(track,THD.CUE.OUT);   /* get dtd output #  */      left = (shr(i,8) & "77") + 1;      right = (i & "77") + 1;      dtd.track = 0;                            /* so we know a DTD  */   end;   else return(TRUE);                           /* Not a DTD track   */   write(mam) = misc.ptr;      write(mdi) = L#DTD_Outputs;   write(mdi) = des;   write(mdi) = T#DTD_Outputs;   write(mdi) = tag;   write(mdi) = sync.to.proto.dtrk(track);      /* DTD track number */   write(mdi) = shl(left,8) | right;   return(Send.Protocol.Packet(misc.ptr,1));end Send.DTD.Outputs;Send.MIDInet.Outputs: proc (track,des,tag) swapable;   dcl track     fixed;   dcl des       fixed;   dcl tag       fixed;   dcl port      fixed;   dcl channel   fixed;   dcl i         fixed;/* Sometimes, MIDInet asks for 256 of these with one "request" message. *//* Because we can overrun the D115D FIFO, we must be tolerant of        *//* "FIFO is half full" conditions.                                      */   dcl RETRY_TIME lit '1000';  /* Try for up to 1 second to send these packets */   if (midi.there & MIDI.THERE.MIDINET)=0        /* Can't change routing if no MIDInet */   then return(1);   if track <> 1 then do;                     /* exclude split keyboard */      if (TRK.HEAD.LOOKUP(track,thd.midi) & THD.MIDI.MIDINET) = 0    /* MIDInet bit not set in THD.MIDI */      then do;         port = 0;                            /* no MIDInet routing */         channel = 0;      end;      else do;         i = TRK.HEAD.LOOKUP(track,thd.midi.path);    /* Lookup MIDInet routing info */         port = i & "377";                            /* extract path number */         channel = shr(i,8) + 1;                      /* and MIDI channel */      end;   end;   else return(1);   write(mam) = misc.ptr;      write(mdi) = L#Midi_In_Out;   write(mdi) = des;   write(mdi) = T#Midi_In_Out;   write(mdi) = tag;   write(mdi) = sync.to.proto.strk(track);    /* Track number */   write(mdi) = shl(2,8) | port;              /* 2=MIDInet out; MIDInet path number */   write(mdi) = shl(channel,8);               /* Output channel number */   return(Send.Protocol.Packet.With.Retry(misc.ptr,1,RETRY_TIME));end Send.MIDInet.Outputs;Do.Routing.Request: proc(packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl base      fixed;   dcl mode      fixed;  /* 0=DTD in, 1=MIDI in, 2=MIDI out, 3=MULTI out, 4=DTD out 5=MIDInet out */   dcl track     fixed;  /* Which track is being requested */   dcl ret       fixed;   dcl tbits(15) fixed;  /* Build Synclavier-style track bit array here */   dcl (i,j)     fixed;   tag  = packet(0);     /* Get incoming arguments */   mode = packet(1);   base = packet(2);   if (mode < 0)   OR (mode > 5)   OR (base <> 0)   then return(TRUE);    /* Argument is out of range */   if mode = 1 then do;         /* If MIDI in, ignore tracks, we always send routing for all 16 channels */      packet(3) = "177777";     /* Use first word to represent 16 CHANNELS */      call blockset(loc(addr(packet(4))),15,0);  /* Clear all other "channels" */   end;   call blockset(misc.buf,15,0);        /* Create some zeros */   /* Re-pack the incoming track bits from S-trk or D-trk arrays to Synclavier format */   /* If tracks are DTD tracks, use zeros in misc.buf for SEQ tracks */   if (mode = 0)   /* DTD inputs */   OR (mode = 4)   /* DTD outputs */   then call proto.to.sync.bits(misc.buf,loc(addr(packet(3))),tbits);   /* Else tracks are SEQ tracks, use zeros in misc.buf for DTD tracks */   else call proto.to.sync.bits(loc(addr(packet(3))),misc.buf,tbits);   /* Find out which tracks are being requested */   do i=0 to 15;                /* For each data word containing track bits */      do j=0 to 15;             /* For each bit in the word */         track = shl(i,4) + j;  /* (16 * i) + j */         if (tbits(i) & bits(j)) <> 0    /* We need to send this track */         then do;            do case mode;               do;                       /* 0: DTD in */                  ret = Send.DTD.Inputs(track,des,tag);               end;               do;                       /* 1: MIDI in */                  ret = Send.Midi.Inputs(track+1,des,tag); /* Note: 1st arg is CHANNEL (1-16) in this case! */               end;               do;                       /* 2: MIDI out */                  ret = Send.Midi.Outputs(track,des,tag);               end;               do;                       /* 3: Multichannel out */                  ret = Send.Multichan.Outputs(track,des,tag);               end;               do;                       /* 4: DTD out */                  ret = Send.DTD.Outputs(track,des,tag);               end;               do;                       /* 5: MIDInet out */                  ret = Send.MIDInet.Outputs(track,des,tag);               end;            end;    /* of do case mode    */           if ret <> 1 then return(FALSE);  /* Couldn't send state; need to try remaining track(s) again */        end;     /* of send this track */      end;       /* of loop over bits  */   end;          /* of loop over words */   return(TRUE);end Do.Routing.Request;Request.MIDI.Routing: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl track     fixed;  /* Track for output, channel for input request */   dcl which     fixed;  /* 0=input, 1=output */   dcl ret       fixed;  /* Return value */   tag = packet(0);   track = packet(1);   which = shr(packet(2),8);   do case which;      do;                /* 0: Input */         ret = Send.Midi.Inputs(track,des,tag);      end;      do;                /* 1: Output */         track = proto.to.sync.strk(track);         ret = Send.Midi.Outputs(track,des,tag);      end;      do;                /* 2: MIDINet Output */         track = proto.to.sync.strk(track);         ret = Send.MIDInet.Outputs(track,des,tag);      end;   end;   return(ret);end Request.MIDI.Routing;Set.MIDI.Routing: proc(packet) swapable;   dcl packet    array;   dcl track     fixed;            /* Which track */   dcl which     fixed;            /* 0=MIDI input, 1=MIDI output */   dcl port      fixed;            /* MIDI input/output number */   dcl channel   fixed;            /* MIDI channel number */   dcl i         fixed;   track   = proto.to.sync.strk(packet(0));  /* Get arguments passed in */   which   = shr(packet(1),8);   port    = packet(1) & "377";   channel = shr(packet(2),8);   if track < 0                    /* Check parameters */   OR track >= first.lod.track   OR port < 0   OR (which = 0 AND port > 8)     /* 8 input ports max */   OR (which = 1 AND port > 16)    /* 16 output ports max */   OR channel < 0   OR channel > 127   then return(TRUE);              /* Bad parameters; quit */   WRITE(MAM)=TRK.HEAD;   WRITE(MAL)=track;   if (READ(MD) = 0) then do;                           /* If no track head */      if (which = 1 OR which = 2)                       /* assigning output */      AND port <> 0 then do;                            /* to non-zero value */         if ALLOCATE.TRK.HEADER(track) = 0              /* try to create a track head */            then return(TRUE);         call COPY.TIMBRE(ALWAYS.EMPTY.TRACK, track);   /* place null timbre on new track */      end;      else if which <> 0 then return(TRUE);             /* not assigning inputs */   end;   do case which;      do;                          /* 0: Assign MIDI input */         i = channel + 1;         if track <> midi.mapping(i) then do;            call clear.poly.timbre.notes(midi.mapping(i));	// was midi  mapped; actuall not midi mapped!            midi.mapping(i) = track;            new.seq.info = new.seq.info | 8;           /* New constants: update screen if there */         end;      end;                         /* of assign MIDI input */      do;                          /* 1: Assign MIDI output */         if max.midi.chan=0        /* Can't change routing if no midi */         then return(TRUE);         if (channel = 0) OR (port = 0) then do;    /* If clearing MIDI routing */			IF (TRK.HEAD.LOOKUP(track, THD.MIDI) & THD.MIDI.PRESURE)<>0			THEN CALL CLEANUP.MIDI.PRESSURE(track);            call TRK.HEAD.STORE(track,thd.midi,TRK.HEAD.LOOKUP(track,thd.midi) & THD.MIDI.MIDINET);  /* Get rid of routing info... (preserve MIDInet bit) */			// Clear presure bit if setting routing to 0			if ((TRK.HEAD.LOOKUP(track,thd.midi) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)				TRK.HEAD.STORE(track,thd.midi,0);            if TRK.HEAD.LOOKUP(track,thd.midi)=0         /* no midi output */            then call CLEAR.MIDI.OUT.CONTROLLERS(track); /* clear controller routings */         end;         else do;                  /* Non zero output routing */            if TRK.HEAD.LOOKUP(track,thd.midi)=0             then call SET.MIDI.OUT.CONTROLLERS(track);      /* make sure routing is meaningful */            port = port - 1;            port = (shr(port,2)+midi.subsys)\shl(port&3,5); /* Convert to subsystem and out # */            /* Keep top 4 bits; put port in low byte and channel in low 4 bits of upper byte */            call TRK.HEAD.STORE(track,thd.midi, (TRK.HEAD.LOOKUP(track,thd.midi) & (not(THD.MIDI.ORIG)) & (not(THC.MIDI.OMS.ALL))) | port | shl((channel-1),8));         end;         new.seq.info = new.seq.info | 8;              /* New constants: update screen if there */         if track=0   /* changing keyboard - keep MIDI button display up to date */         then call SELECT.PARAMETER(midi.l-par.l);     /* Select new parm */         call COMPUTE.MISC.INFO;   /* Make sure channel pressure list is correct */      end;                         /* of assign MIDI output */      do;                          /* 2: Assign MIDInet output */         if (MIDI.THERE & MIDI.THERE.MIDINET)=0         then return(TRUE);        /* Can't set routing if no MIDInet there */         if (channel = 0) OR (port = 0) then do;    /* If clearing MIDI routing */			IF (TRK.HEAD.LOOKUP(track, THD.MIDI) & THD.MIDI.PRESURE)<>0			THEN CALL CLEANUP.MIDI.PRESSURE(track);            call TRK.HEAD.STORE(track,thd.midi,TRK.HEAD.LOOKUP(track,thd.midi)&(not(THD.MIDI.MIDINET)));  /* Clear MIDInet bit (preserve old MIDI info) */            call TRK.HEAD.STORE(track,thd.midi.path,0);  /* clear MIDInet routing info */			// Clear presure bit if setting routing to 0			if ((TRK.HEAD.LOOKUP(track,thd.midi) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)				TRK.HEAD.STORE(track,thd.midi,0);            if TRK.HEAD.LOOKUP(track,thd.midi)=0         /* no midi output */            then call CLEAR.MIDI.OUT.CONTROLLERS(track); /* clear controller routings */         end;         else do;                  /* Non zero output routing */            if TRK.HEAD.LOOKUP(track,thd.midi)=0             then call SET.MIDI.OUT.CONTROLLERS(track);      /* make sure routing is meaningful */            channel = channel - 1;            call TRK.HEAD.STORE(track,thd.midi,(TRK.HEAD.LOOKUP(track,thd.midi) & (not(THD.MIDI.MIDINET))) | THD.MIDI.MIDINET);  /* Set MIDInet bit */            call TRK.HEAD.STORE(track,thd.midi.path,port | shl(channel,8));   /* path in lower byte; midi channel in upper */         end;         new.seq.info = new.seq.info | 8;              /* New constants: update screen if there */         call COMPUTE.MISC.INFO;   /* Make sure channel pressure stuff is correct */      end;                         /* of assign MIDInet output */   end;                            /* of do case which */   return(TRUE);end Set.MIDI.Routing;Request.Multichannel.Routing: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl track     fixed;  /* Track for output, channel for input request */   tag = packet(0);   track = proto.to.sync.strk(packet(1));   return(Send.Multichan.Outputs(track,des,tag));end Request.Multichannel.Routing;Set.Multichannel.Routing: proc (packet) swapable;   dcl packet    array;   dcl track     fixed;            /* Which track */   dcl left      fixed;            /* Left channel */   dcl right     fixed;            /* Right channel or zero if same as left */   track = proto.to.sync.strk(packet(0));  /* Get arguments passed in */   left  = shr(packet(1),8);   right = packet(1) & "377";   return Set.Sequencer.Output.Routing(track,left,right);end Set.Multichannel.Routing;Request.DTD.Input.Routing: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl track     fixed;  /* Track for output, channel for input request */   tag = packet(0);   track = proto.to.sync.dtrk(packet(1));   return(Send.DTD.Inputs(track,des,tag));end Request.DTD.Input.Routing;Set.DTD.Input.Routing: proc (packet) swapable;   dcl packet    array;   dcl source    fixed;            /* 0=STM, 1=DIG, 2=DTD out, 3=DTD track */   dcl the_input fixed;            /* Which STM to use */   dcl track     fixed;            /* Which track to change the input of */   track     = packet(0);          /* Get arguments passed in */   source    = shr(packet(1),8);   the_input = packet(1) & "377";   if (track       < 0  )   OR (track       > 15 )   OR (the_input   < 0  )   OR (the_input   > 16 )   OR (source      < 0  )   OR (source      > 3  )   OR (Lod.Running = 0  )   then return(TRUE);              /* Bad parameters OR no DTD system; quit */   do case source;      do;                          /* 0: STM */         call set.dtd.drive.parameter(track,0,packet(1));      end;      do;                          /* 1: DIG */         call set.dtd.drive.parameter(track,0,packet(1));      end;      do;                          /* 2: DTD out */         call set.dtd.drive.parameter(track,0,packet(1));      end;      do;                          /* 3: DTD track */         call set.dtd.drive.parameter(track,0,packet(1));      end;   end;   /* of do case source */   return(TRUE);end Set.DTD.Input.Routing;Request.DTD.Output.Routing: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;  /* Caller's ID to be returned */   dcl track     fixed;  /* Track for output, channel for input request */   tag = packet(0);   track = proto.to.sync.dtrk(packet(1));   return(Send.DTD.Outputs(track,des,tag));end Request.DTD.Output.Routing;Set.DTD.Output.Routing: proc (packet) swapable;   dcl packet    array;   dcl track     fixed;            /* Which track */   dcl left      fixed;            /* Left channel */   dcl right     fixed;            /* Right channel or zero if same as left */   dcl dtd_out   fixed;            /* DTD output channel */   /* Provide a sneak path to the Audio Event Editor so it does */   /* not have to update every line of the Project Panel        */   /* when one item is changed from the protocol:               */   dcl Display.New.Project.Info fixed external;   track = proto.to.sync.dtrk(packet(0));  /* Get arguments passed in */   left  = shr(packet(1),8);   right = packet(1) & "377";   if right = 0 then right = left; /* If nothing different given; use right for both */   if track < first.lod.track   OR track >= last.lod.track   OR left  < 0   OR right < 0   then return(TRUE);              /* Bad parameters; quit */   dtd_out = left;           /* Limit to the available DTD outputs */   if dtd_out > Dtd.Num.Voices then dtd_out = Dtd.Num.Voices;   if Lod.Running <> 0 then do;      call send.to.lod(dtd.select.track,0);      /* Select track dir */      write(mam) = Scsi.Ptr;      write(md)  = track - First.Lod.Track;      call send.to.lod(dtd.set.screen.line,2);   /* Set the track number (0-15) */      write(mam) = scsi.ptr;      write(md)  = dtd_out;      call send.to.lod(dtd.track.doa, 2);        /* Write the DTD routing */      /* Create an event when we change the track */      /* DOA routing:                             */      new.dtd.info = new.dtd.info | 16384;/*    Display.New.Project.Info = Display.New.Project.Info | bits(track - First.Lod.Track); *//*    Well, the above code is a nice idea, but it just doesn't work! */      Display.New.Project.Info = "177777";       /* Force update of all tracks! */      if store.dtd.info = 1                      /* if sitting on O page */      then call send.to.lod(dtd.select.song,0);  /* Select song dir      */   end;   return(TRUE);end Set.DTD.Output.Routing;Valid.Tracks: proc (des,tag) swapable;   dcl des       fixed;          /* Destination node */   dcl tag       fixed;          /* Caller's ID to be returned */   dcl (i,j)     fixed;   dcl tbits(15) fixed;   dcl sbits(15) fixed;   dcl dbits(7)  fixed;   write(mam)=TRK.HEAD;   do i=0 to 15;      do j =0 to 15;         if read(mdi) <> 0         then tbits(i) = tbits(i) | bits(j);         else tbits(i) = tbits(i) & (not bits(j));      end;   end;   call sync.bits.to.proto(tbits,sbits,dbits);   write(mam) = misc.ptr;          /* Build output packet in external memory */   write(mdi) = L#Valid_Tracks;   write(mdi) = des;   write(mdi) = T#Valid_Tracks;   write(mdi) = tag;   do i=0 to 15;      write(mdi) = sbits(i);   end;   return(Send.Protocol.Packet(misc.ptr,1));end Valid.Tracks;/* Routine to assign DTD inputs: */Handle.Track.Setup: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam)   = Packet.Ptr;   write(mal)   = P#LEN;    len     = read(md);   write(mal)   = P#SOURCE; des     = read(md);   write(mal)   = P#TYPE;      subtype      = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   if subtype < 16   then do case subtype;         /* Branch on specific command (0-15) */      do;  /* 0:  Request Track States */         ret = Request.Track.States(packet,des);      end;      do;  /* 1:  Track States */         /* This is handled by the request routine */      end;      do;  /* 2:  Set Track State */         ret = Set.Track.State(packet);      end;      do;  /* 3:  Set Multiple Track States */         ret = Set.Multiple.Track.States(packet);      end;      do;  /* 4:  Clear All Tracks */         ret = Clear.All.Track.States(packet);      end;      do;  /* 5:  Unused */         /* Available */      end;      do;  /* 6:  Request Single Track State */         ret = Send.Single.Track.State(packet,des);      end;      do;  /* 7:  Send Single Track State */         /* This is handled by the request routine */      end;   end;             /* of branch on specific command (0-15) */   else if subtype < 32   then do case (subtype - 16);  /* Branch on specific command (16-31) */      do;  /* 16:  Request Group */         ret = Request.Group(packet,des);      end;      do;  /* 17: Group (only; last) */         /* This is handled by the request routine */      end;      do;  /* 18: Group (multi; initial) */         /* This is handled by the request routine */      end;      do;  /* 19:  Set Group (only; last) */         ret = Set.Group(packet,des);      end;      do;  /* 20:  Set Group (multi; initial) */         /* This is not implemented yet */      end;      do;  /* 21:  Request Valid Groups */         ret = Valid.Groups(des,packet(0));      end;      do;  /* 22:  Valid Groups */         /* This is handled by the request routine */      end;      do;  /* 23:  Set Group States */         ret = Set.Track.Group.States(packet);      end;   end;             /* of branch on specific command (16-31) */   else if subtype < 48   then do case (subtype - 32);  /* Branch on specific command (32-47) */      do;  /* 32:  Request Routing Info */         ret = Do.Routing.Request(packet,des);      end;      do;  /* 33:  Request MIDI In/Out Routing */         ret = Request.MIDI.Routing(packet,des);      end;      do;  /* 34:  MIDI In/Out */         /* This is handled by the request routine */      end;      do;  /* 35:  Assign MIDI Input or Output Routing */         ret = Set.MIDI.Routing(packet);      end;      do;  /* 36:  Request Multichannel Routing */         ret = Request.Multichannel.Routing(packet,des);      end;      do;  /* 37:  Multichannel Routing */         /* This is handled by the request routine */      end;      do;  /* 38:  Assign Multichannel Routing */         ret = Set.Multichannel.Routing(packet);      end;      do;  /* 39:  Request DTD Input Routing */         ret = Request.DTD.Input.Routing(packet,des);      end;      do;  /* 40:  DTD Input Routing */         /* This is handled by the request routine */      end;      do;  /* 41:  Assign DTD Input Routing */         ret = Set.DTD.Input.Routing(packet);      end;      do;  /* 42:  Request DTD Output Routing */         ret = Request.DTD.Output.Routing(packet,des);      end;      do;  /* 43:  DTD Output Routing */         /* This is handled by the request routine */      end;      do;  /* 44:  Assign DTD Output Routing */         ret = Set.DTD.Output.Routing(packet);      end;      do;  /* 45: Request Valid Tracks */         ret = Valid.Tracks(des,packet(0));      end;   end;             /* of branch on specific command (32-47) */   return(ret);             /* return processed status */end Handle.Track.Setup;