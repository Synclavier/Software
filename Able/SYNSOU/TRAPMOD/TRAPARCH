/* TRAPARCH  $TITLE  ROUTINES TO PROCESS ARCHIVAL PACKETS   Modified:   11/20/90 - CJ  - changed arguments to process.record.panel.record.button   10/02/89 - CJ  - fixed error message bug with "save cue"   09/01/89 - MWH - Rework the protocol for release 2.2   03/14/89 - PF  - changed process packet processing logic   11/29/88 - MWH - Add increment cue name   11/10/88 - MWH - Clean up messages and update lengths   09/15/88 - PF - Created this source file*/Process.Store.Current.Cue.Message: proc swapable;   dcl i							fixed;   dcl j							fixed;   dcl tmp(Event.Cue.Max.Words-1)	fixed;   dcl dtdstat(1)					fixed;   dcl AEE.Screen.State                    fixed        external;   dcl Record.Recording.State              fixed        external;   dcl Record.Ready.Bits                   fixed        external;   dcl Process.Record.Panel.Record.Button  proc (fixed, array) external;   dcl Record.Group                        fixed        external;   dcl Protocol.Error.Arg0                 array        external;   /* For now,  handle AEE recording using screen software.  Store Current */   /* Cue actually means stop recording and store the current cue:         */   /* It also may mean that we should BLOCK the current cue!!              */   if  (AEE.Screen.State                 =  1)   /* aee is up              */   and (Record.Recording.State           >= 2)   /* recording              */   and (Record.Group                     <> 0)   /* rec pan                */   and (Armed.for.Protocol.DTD.Recording =  0)   /* no protocol recording  */   then do;      call Fetch.DTD.Drive.Status(dtdstat);      call Process.Record.Panel.Record.Button(Record.Ready.Bits, dtdstat);   end;   else do;      i = SAVE.CURRENT.CUE.ON.DTD;      write(mam) = Current.Cue.Ptr;    /* Get current cue pointer */      write(mal) = CUE.NAME;           /* handy.                  */      do j=0 to Event.Cue.Max.Words-1;         tmp(j)=read(mdi);      end;      if i > 0 then do;         call Present.Protocol.Error.Message(NT#CueSaved,ATTR#Normal,0,0,0);         call copy.string(tmp, Protocol.Error.Arg0);      end;      else do case abs(i);         call Present.Protocol.Error.Message(NT#SystemError,         ATTR#Normal,0,0,0);         call Present.Protocol.Error.Message(NT#CueNameTooLong,      ATTR#Normal,tmp(0),0,0);         do;            call Present.Protocol.Error.Message(NT#CueNameAlreadyExists,ATTR#Normal,0,0,0);            call copy.string(tmp, Protocol.Error.Arg0);         end;         call Present.Protocol.Error.Message(NT#TooManyCues,         ATTR#Normal,0,0,0);         call Present.Protocol.Error.Message(NT#OutOfCueTableMemory, ATTR#Normal,0,0,0);         call Present.Protocol.Error.Message(NT#CueRecordTooLong,    ATTR#Normal,CUE.NAME+1+shr(tmp(0)+1,1),0,0);      end;   end;   return(TRUE);end Process.Store.Current.Cue.Message;Handle.Archival: proc public swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   do case subtype;    /* branch on specific archival command */      do; /*  0:  Save current cue */         ret = Process.Store.Current.Cue.Message;      end;   end;             /* of branch on specific archival command */   return(ret);             /* return processed status */end Handle.Archival;