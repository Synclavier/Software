/* TRAPXFR1   $TITLE  UTILITY ROUTINES FOR BLOCK TRANSFERS OF ABLE DATA STRUCTS   Modified:   02/26/92 - PF -  Block transfer of tempo/meter maps   12/12/91 - PF  - Created this source file*/Write.Seq.Scale: proc (scale,offset,len) swapable;   dcl scale   array;                /* new scale */   dcl offset  fixed;   dcl len     fixed;   dcl i       fixed;   dcl new     fixed;   new = false;                      /* assume no new data */   write(mam)=bas.ptr;               /* set mam to seq info area */   write(mal)=seq.scale + offset;    /* access keyboard scale info */   do i = offset to (len - 1);       /* step thru          */      if (read(md) <> scale(i))      /* if new value       */      then do;         new = true;                 /* set data changed flag */      end;      write(mdi)=scale(i);           /* store frequency for this key */   end;   if new then do;                   /* any new data written */      reset.bits=reset.bits\r.freqs; /* new synth data reqd */      new.kbd.pre=1;                 /* precompute table    */   end;end Write.Seq.Scale;Write.Seq.Speed: proc (speed) swapable;   dcl speed fixed;   dcl new   fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.speed;   if (read(md) <> speed)   then do;      new = true;      write(md ) = speed;               /* store new value  */   end;   if new then do;      call speed.comp;                  /* compute stuff after speed change */   end;end Write.Seq.Speed;Write.Seq.Click: proc (click) swapable;   dcl click fixed;   dcl new   fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.click;   if (read(md) <> click)   then do;      new = true;      write(md) = click;   end;   if new then do;      if ((Tempo.Map.Ptr|Meter.Map.Ptr) == NULL)      then new.seq.info = new.seq.info \ 8;			/*	new.constants on click rate change	*/      else Activate.Sequence.For.New.Map(0,click);	/*	must recalc tempo/meter map stuff	*/   end;end Write.Seq.Click;Write.Seq.CRM: proc (crm) swapable;   dcl crm   fixed;   dcl new   fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.crm;   if (read(md) <> crm)   then do;      new = true;      write(md) = crm;   end;   if new then do;      call resync.time.base;      call speed.comp;   end;end Write.Seq.CRM;Write.Seq.SMode: proc (smode) swapable;   dcl smode fixed;   dcl new   fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.smode;   if (read(md) <> smode)   then do;      new = true;   end;   if new then do;      call stop.sequencer;      call init.smpte;                    /* re-initialize on mode chnage */      write(mam) = bas.ptr;      write(mal) = seq.smode;      write(md ) = smode;      new.seq.info = new.seq.info\8;      /* new constants after changing smpte mode */      new.seq.info = new.seq.info\512;    /* change in ext sync mode     */   end;end Write.Seq.SMode;Write.Seq.Smpte: proc (smpte) swapable;   dcl smpte array;   dcl new fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.smbits;   if (read(mdi) <> smpte(0))   or (read(mdi) <> smpte(1))   or (read(mdi) <> smpte(2))   then do;      new = true;   end;   if new then do;      write(mam) = bas.ptr;      write(mal) = seq.smbits;      write(mdi) = smpte(0);      write(mdi) = smpte(1);      write(mdi) = smpte(2);      call speed.comp;                    /* sample info         */      new.seq.info = new.seq.info \ 8;    /* new constants on smpte offset change */   end;end Write.Seq.Smpte;Write.Seq.BPM: proc (bpm) swapable;   dcl bpm fixed;   dcl new fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.bpm;   if (read(md) <> bpm)   then do;      new = true;      write(md) = bpm;   end;   if new then do;   end;end Write.Seq.BPM;Write.Seq.Mark.Start: proc (mark) swapable;   dcl mark array;   dcl new  fixed;   new = false;   write(mam) = bas.ptr;   write(mal) = seq.mark.msb;   if (read(mdi) <> mark(0))   or (read(mdi) <> mark(1))   then do;      new = true;      write(mal) = seq.mark.msb;      write(mdi) = mark(0);      write(mdi) = mark(1);   end;   if new then do;      new.motion =1;                       /* tell lod about it */      new.seq.info = new.seq.info \ 128;   /* create system event for mark start change */   end;end Write.Seq.Mark.Start;Write.Seq.Footage.Mode: proc (mode) swapable;   dcl mode fixed;   write(mam) = bas.ptr;   write(mal) = seq.fmode;   write(md ) = mode;end Write.Seq.Footage.Mode;Write.Seq.Footage.Display.Offset: proc (frames) swapable;   dcl frames array;   write(mam) = bas.ptr;	write(mal) = SEQ.FOFFSET;   write(mdi) = frames(0);   write(mdi) = frames(1);   write(mdi) = frames(2);end Write.Seq.Footage.Display.Offset;Write.Seq.Smpte.Display.Offset: proc (offset) swapable;   dcl offset array;   write(mam) = bas.ptr;   write(mal) = seq.doffset;   write(mdi) = offset(0);   write(mdi) = offset(1);end Write.Seq.Smpte.Display.Offset;Write.Seq.Smpte.Display: proc (state) swapable;   dcl state fixed;   write(mam) = bas.ptr;   write(mal) = seq.doffdis;   write(md ) = state;end Write.Seq.Smpte.Display;Write.Seq.Oratio: proc (oratio) swapable;   dcl oratio fixed;   write(mam) = bas.ptr;   write(mal) = seq.octratio;   write(md ) = oratio;end Write.Seq.Oratio;Write.Seq.Loop: proc (loop) swapable;   dcl loop fixed;   write(mam) = bas.ptr;   write(mal) = seq.loop;   write(md ) = loop;end Write.Seq.Loop;Write.Seq.Loop.Times: proc (lend, lstart) swapable;   dcl lend   array;   dcl lstart array;   write(mam) = bas.ptr;   write(mal) = seq.g.p.t;   write(mdi) = lend(0);   write(mdi) = lend(1);   write(mdi) = lstart(0);   write(mdi) = lstart(1);end Write.Seq.Loop.Times;Write.Seq.Poly.Freq: proc (poly.freq) swapable;   dcl poly.freq fixed;   write(mam) = bas.ptr;   write(mal) = seq.poly.freq.table;   write(md ) = poly.freq;end Write.Seq.Poly.Freq;Write.Seq.Caption: proc (name) swapable;   dcl name array;   dcl i    fixed;   write(mam) = bas.ptr;   write(mal) = seq.capts;   do i = 0 to 39;      write(mdi) = name(i);   end;end Write.Seq.Caption;Write.Seq.MIDInet.Filename: proc (name) swapable;   dcl name array;   dcl i    fixed;   write(mam) = bas.ptr;   write(mal) = seq.midinet;   do i = 0 to 15;      write(mdi) = name(i);   end;end Write.Seq.MIDInet.Filename;Write.Trk.MIDI.Routing: proc (track, routing) swapable;   dcl track   fixed;   dcl routing fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.midi;   if read(md) <> routing   then do;      new = true;      write(md ) = routing;   end;end Write.Trk.MIDI.Routing;Write.Trk.Volume: proc (track, vol) swapable;   dcl track   fixed;   dcl vol     fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.tvol;   if read(md) <> vol   then do;      new = true;      write(md ) = vol;   end;end Write.Trk.Volume;Write.Trk.Routing: proc (track, left,right) swapable;   dcl track   fixed;   dcl left    fixed;   dcl right   fixed;   dcl newrout fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   newrout = shl(left,8) | (right & 255);   write(mam) = read(md);   write(mal) = thd.trou;   if read(md) <> newrout   then do;      new = true;      write(md ) = newrout;   end;end Write.Trk.Routing;Write.Trk.Pan: proc (track, pan) swapable;   dcl track   fixed;   dcl pan     fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.tpan;   if read(md) <> pan   then do;      new = true;      write(md ) = pan;   end;end Write.Trk.Pan;Write.Trk.Octave.Ratio: proc (track, oratio) swapable;   dcl track   fixed;   dcl oratio  fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.oratio;   if read(md) <> oratio   then do;      new = true;      write(md ) = oratio;   end;end Write.Trk.Octave.Ratio;Write.Trk.Xpos: proc (track, xpos) swapable;   dcl track   fixed;   dcl xpos    fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.sxpos;   if read(md) <> xpos   then do;      new = true;      write(md ) = xpos;   end;end Write.Trk.Xpos;Write.Trk.ILP: proc (track, ilp) swapable;   dcl track   fixed;   dcl ilp     fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.ilp;   if read(md) <> ilp   then do;      new = true;      write(md ) = ilp;   end;end Write.Trk.ILP;Write.Trk.ILP.Times: proc (track, start,len) swapable;   dcl track   fixed;   dcl start   array;   dcl len     array;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.countin.msb;   if (read(mdi) <> start(0))   or (read(mdi) <> start(1))   or (read(mdi) <> len(0))   or (read(mdi) <> len(1))   then do;      new = true;      write(mal) = thd.countin.msb;      write(mdi) = start(0);      write(mdi) = start(1);      write(mdi) = len(0);      write(mdi) = len(1);   end;end Write.Trk.ILP.Times;Write.Trk.MIDI.Filter: proc (track, filter) swapable;   dcl track   fixed;   dcl filter  fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.active.midi.rtes;   if read(md) <> filter   then do;      new = true;      write(md ) = filter;   end;end Write.Trk.MIDI.Filter;Write.Trk.Cue.Output: proc (track, output) swapable;   dcl track   fixed;   dcl output  fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.cue.out;   if read(md) <> output   then do;      new = true;      write(md ) = output;   end;end Write.Trk.Cue.Output;Write.Trk.Name: proc (track, name) swapable;   dcl track   fixed;   dcl name    array;   dcl i       fixed;   dcl new     fixed;   new = false;   write(mam) = trk.head;   write(mal) = track;      if read(md) = 0   then return;   write(mam) = read(md);   write(mal) = thd.track.title;      do i = 0 to shr(name(0)+1,1);      if read(mdi) <> name(i)      then new = true;   end;   if new then do;      write(mal) = thd.track.title;         do i = 0 to shr(name(0)+1,1);         write(mdi) = name(i);      end;   end;end Write.Trk.Name;