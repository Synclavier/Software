/*	:SYNSOU:TRAPMOD:TRAPTIME  $TITLE  ROUTINES TO PROCESS TIME BASE PACKETSModified:2001/02/19 - TY  - Make modifications needed for 24 hour wrap.  Removed unused automatic variables.1992/01/15 - cj  - Added DTD sync mode message1991/08/29 - PF  - Fixed ZERO.TIME bug in SET.MARK.START.TIME1991/08/16 - PF  - Don't call SET.SEQUENCER.MARK.START.POINT unless time						 passed in actually differs from current mark point1991/03/27 - MWH - Add arg to Read and Store Locate Stack routines1991/03/07 - MWH - Add AEE's 20 saved mark points to the protocol1990/07/18 - cj  - added mark.button.disabled to mark time message1990/07/11 - CJ  - Added messages to get at raw SMPTE time1989/09/29 - MWH - Set footage offset correctly1989/09/20 - MWH - Set the sync mode correctly, allowing for MIDInet1989/09/19 - MWH - Don't change SMPTE mode in Sync Mode; already in Time Parameters1989/09/08 - PF  - (MWH) Merged in Paul's MIDI changes1989/08/28 - PF  - Add Set.MIDI.Sync.Out and Set.MIDInet.Sync.out1989/08/28 - MWH - Rework the protocol for release 2.21989/07/25 - cj  - called new routines1989/07/07 - MWH - Declare new constants event when display format changes1989/06/15 - PF  - Removed references to inc.new.midi1989/05/01 - MWH - Support for multiple D115 boards & channels; timeouts1989/03/14 - PF  - changed process packet processing logic1989/01/19 - MWH - Add Auto Punch feature1989/01/13 - PF  - Monster MIDI code1988/12/15 - MWH - Add time parameters message1988/11/28 - MWH - Clean up unreferenced public's1988/11/21 - MWH - Temporarily, allow time messages to be turned off1988/11/10 - MWH - Clean up messages and update lengths1988/10/19 - MWH - Put bytes in correct order for sync mode1988/09/28 - MWH - Add sync mode1988/09/15 - PF  - Created this source file*//*	$SUBTITLE Process messages to send and set the time parameters	*/Send.Time.Parameters.Packet: proc (packet,des) swapable;	dcl packet						array;	dcl des							fixed;	dcl smpte.offset.sbits (1)	fixed;	dcl feet.bits(1)				fixed;	call SMPTE.TO.SBITS(loc(addr(SM.HRS)),SM.MODE,smpte.offset.sbits);	call FEET.TO.FBITS(S$FOffset,S$FMode,feet.bits);	write(mam) = misc.ptr;	write(mdi) = L#Time_Parameters;	write(mdi) = des;	write(mdi) = T#Time_Parameters;	write(mdi) = packet(0);		/*	Tag	*/	write(mdi) = smpte.offset.sbits(lw#msb);	write(mdi) = smpte.offset.sbits(lw#lsb);	write(mdi) = feet.bits(lw#msb);	write(mdi) = feet.bits(lw#lsb);	write(mdi) = samp.speed;	write(mdi) = samp.click.rate;	write(mdi) = samp.bpm;	write(mdi) = AEE.Current.Project.Rate;	write(mdi) = shl(SM.MODE,8) | S$FMode;	write(mdi) = shl(AEE.Time.Format,8);	if not Send.Protocol.Packet(misc.ptr,1)	then do;							/*	no room in protocol output buffer now	*/		return(0);					/*	return zero - try again later				*/	end;	return(1);						/*	success	*/end Send.Time.Parameters.Packet;Set.Time.Parameters: proc (packet) swapable;	dcl packet	array;	dcl which	fixed;	dcl tmp(8)	fixed;	dcl msb		lit '0';	dcl lsb		lit '1';	dcl SET.SYNCLAV.FEET.MODE		proc(fixed, fixed)					external;	dcl SET.SYNCLAV.SMPTE.MODE		proc(fixed)								external;	dcl Store.Syncl.Param			proc(fixed, fixed, fixed, fixed)	external;	dcl SET.SYNCLAV.FEET.OFFSET	proc(array)								external;	dcl SET.SYNCLAV.SMPTE.OFFSET	proc(array)								external;	dcl SET.DTD.PROJECT.PARAMETER	proc (fixed,fixed)					external;	which = shr(packet(2),8);	/*	Get arguments passed in	*/	do case which;		do;	/*	0 = Set SMPTE offset	*/			call SBITS.TO.SMPTE(loc(addr(packet(msb))),SM.MODE,tmp);			call SET.SYNCLAV.SMPTE.OFFSET(tmp);		end;		do;	/*	1 = Set SMPTE mode	*/			call SET.SYNCLAV.SMPTE.MODE(packet(lsb));		end;		do;	/*	2 = Set footage offset	*/			call FBITS.TO.FEET(loc(addr(packet(msb))),S$FMode,tmp);			call SET.SYNCLAV.FEET.OFFSET(tmp);	/*	Sets in external memory (at BAS.PTR) only!	*/			S$FOffset(lw#msb) = tmp(msb);			/*	So, also set internal memory variables for the screen manager	*/			S$FOffset(lw#lsb) = tmp(lsb);		end;		do;	/*	3 = Set footage mode	*/			S$FMode = packet(lsb);			call SET.SYNCLAV.FEET.MODE(-1, -1);	/*	store in sequence & create event	*/		end;		do;	/*	4 = Set speed	*/			call Store.Syncl.Param(3, 0, speed.l, packet(lsb));		end;		do;	/*	5 = Set click rate	*/			call Store.Syncl.Param(3, 0, click.l, packet(lsb));		end;		do;	/*	6 = Set beats per measure	*/			call Store.Syncl.Param(3, 0, bpm.l, packet(lsb));		end;		do;	/*	7 = Set display format	*/			AEE.Time.Format = packet(lsb);			New.Seq.Info = New.Seq.Info | 8;		/*	New constants	*/		end;		do;	/*	8 = Set DTD sample rate	*/			call Set.DTD.Project.Parameter(2,packet(lsb));		end;	end;	return(TRUE);end Set.Time.Parameters;/*	$SUBTITLE Send message with external sync status	*/Send.Sync.Mode.Packet: proc(packet,des) swapable;	dcl packet	array;	dcl des		fixed;	dcl mode		fixed;	dcl smpte.onoff		fixed external;	dcl ext.clock.mode	fixed external;	dcl midi.sync.out		fixed external;	/*	set up temp status variable	*/	/*	ext.clock.mode has the following values:	*/	/*		0 = Internal Sync								*/	/*		1 = 50 Hertz Sync								*/	/*		2 = External Beat Sync						*/	/*		3 = MIDI Input Sync							*/	/*		4 = MIDI Aux Sync								*/	/*		5 = MIDInet Sync								*/	/*		6 = OMS MIDI Sync								*/	if smpte.onoff <> 0 then do;	/*	SMPTE is on	*/		mode = shl(4,8);	end;	else do;								/*	Get sync mode from ext.clock.mode	*/		if ext.clock.mode >= 0 AND ext.clock.mode <= 2	/*	Internal & External Sync	*/		then mode = shl(ext.clock.mode,8);		else if ext.clock.mode = 3								/*	MIDI Input Sync	*/		then mode = shl(3,8) | 0;		else if ext.clock.mode = 4								/*	MIDI Aux Sync		*/		then mode = shl(3,8) | 1;		else if ext.clock.mode = 5								/*	MIDInet Sync		*/		then mode = shl(3,8) | 2;		else if ext.clock.mode = 6								/*	OMS Midi Sync		*/		then mode = shl(6,8) | 2;		else return(1);				/*	We're done (ext.clock.mode in strange state)	*/	end;	write(mam) = misc.ptr;	write(mdi) = L#Sync_Mode;	write(mdi) = des;	write(mdi) = T#Sync_Mode;	write(mdi) = packet(0);			/*	Send the tag	*/	write(mdi) = mode;	write(mdi) = midi.sync.out&0x7FFF;	/*	holds MIDInet path in upper/MIDI sync out in lower	*/	if not Send.Protocol.Packet(misc.ptr,1)	then do;								/*	no room in protocol output buffer now	*/		return(FALSE);					/*	try again later								*/	end;	return(TRUE);						/*	success	*/end Send.Sync.Mode.Packet;/*	$SUBTITLE Process message to set external sync's	*/Set.Sync.Mode:proc (packet) swapable;	dcl packet	array;	/*	From the packet	*/	dcl mode		fixed;	/*	Sync mode			*/	dcl type		fixed;	/*	Modifier for mode eg: which SMPTE mode	*/	dcl Set.System.Synclav.Sync.Mode	proc(fixed) external;	dcl Set.Synclav.Smpte.Mode			proc(fixed) external;	mode = shr(packet(0),8);			/*	First  (upper) byte is mode	*/	type = packet(0) & "377";			/*	Second (lower) byte is type	*/	/*	Map message states to modes for "ext.clock.mode"	*/	do case mode;		call Set.System.Synclav.Sync.Mode(0);			/*	internal sync	*/		call Set.System.Synclav.Sync.Mode(1);			/*	ext 50 hz sync	*/		call Set.System.Synclav.Sync.Mode(2);			/*	ext beat sync	*/		call Set.System.Synclav.Sync.Mode(3+type);	/*	midi in & aux & MIDInet	*/		call Set.System.Synclav.Sync.Mode(6);			/*	SMPTE				*/		call Set.System.Synclav.Sync.Mode(6);			/*	VITC				*/		call Set.System.Synclav.Sync.Mode(7);			/*	OMS Midi Sync	*/	end;	return(TRUE);end Set.Sync.Mode;Set.MIDI.Sync.Out: proc (packet) swapable;	dcl packet	array;	dcl out		fixed;	dcl DISPLAY.MTC		fixed external;	dcl midi.sync.is.tc	fixed external;	dcl midi.full.frame	proc(fixed, fixed) external;	out = shr(packet(0),8);	if max.midi.chan = 0						/*	no original MIDI hardware in system	*/	then return;	if out <> (midi.sync.out & "377")	/*	stored in lower byte	*/	then do;		call stop.recd.move.play;		midi.sync.out = (midi.sync.out & "HFF00") | out;	/*	preserve MIDInet sync out path in upper byte	*/		if ((midi.sync.out & 0xFF) == 0)			DISPLAY.MTC = 0;					/*	TURN OFF MTC DISLPAY WHEN TURNING OFF MIDI SYNC OUT	*/		else if (midi.sync.is.tc != 0)							/*	send out full frame when changing	*/			MIDI.FULL.FRAME(play.time.msb, play.time.lsb);	/*	sync output routing						*/		new.seq.info = new.seq.info | 512;	end;	return 1;end Set.MIDI.Sync.Out;Set.MIDInet.Sync.Out: proc (packet) swapable;	dcl packet	array;	dcl path		fixed;	path = shr(packet(0),8);	if path <> (shr(midi.sync.out,8)&0x7f)	then do;		midi.sync.out = (midi.sync.out & "H80FF") | shl(path&0x7F,8);	//	Note: Mac header file implies 7 bits of port info in path		new.seq.info = new.seq.info | 512;	end;	return 1;end Set.MIDInet.Sync.Out;/*	$SUBTITLE Update the destination sync time in the current cue		*/Set.Destination.Sync.Time: proc (time) swapable;	dcl time	array;	call COPY32(time,Cue.Sync.Time);	/*	save in global variable			*/	call UPDATE.CURRENT.CUE.RECORD;	/*	store in cue in ext memory		*/												/*	and create events to update	*/	return(1);								/*	screens and devices.				*/end Set.Destination.Sync.Time;/*	$SUBTITLE Process message to take AEE time	*/dcl Set.Cue.Time.With.Format	proc (array, fixed) recursive;Take.Current.Time: proc (packet,des) swapable;	dcl packet	array;	dcl des		fixed;	dcl which	fixed;	dcl tmp(2)	fixed;	dcl format	fixed;	dcl i			fixed;	dcl j			fixed;	which = shr(packet(0),8);			/*	Get time which we're taking		*/	if which < 0	OR which > 6	then return(TRUE);					/*	Parameter is out of bounds			*/	/*	See what time format this device is asking for cue times in (ie	*/	/*	cue times offset to current project, or cue times offset to			*/	/*	correct sequence time:															*/	i = map.d115.node.id(des);			/*	get board/channel #					*/	if i <> (-1)	then j = ((d115d.format(i) & PFORM#DTDSeq) <> 0);	/*	Get the desired time for the take:	*/	if which < 5 then do;				/*	handle cue in/out/edit times		*/		/*	If playing the DTD (ie triggering a cue or scrubbing), then		*/		/*	get the current direct-to-disk time.									*/		if (DTD.Play.State <> 0)		/*	if DTD is playing or scrubbing	*/		then do;								/*	then get abs DTD time				*/			/*	Stop DTD playback & get precise time we stopped if taking	*/			/*	cue out time or edit out time:										*/			if (which = 1)					/*	stop playback & get precise		*/			or (which = 3)					/*	position for end times.				*/			then call STOP.DTD.PLAY.STATE;			call Take.Current.Shuttle.Time(tmp);			format = 2;						/*	absolute disk time					*/		end;		else if (Most.Recent.AEE.Activity = 0)	/*	if we just triggered		*/		or		  (j								 = 0)	/*	or not audit mode			*/		then do;			call COPY32(AEE.Shuttle.Anchor.Time,tmp);			format = 2;									/*	absolute disk time		*/		end;		/*	else if DTD is not playing, we are showing sequencer times,		*/		/*	and the most recent activity was a sequence or VITC movement,	*/		/*	then assume the user is trying to take a VITC time:				*/		else do;								/*	else if not playing, audition		*/			call Take.System.Sequence.Time(tmp);	/*	times, then assume	*/			format = 1;										/*	is a sequence time	*/		end;		if (tmp(lw#msb) < 0) wrap_24_hours(tmp);	/*	avoid assigning negative numbers		*/		if (com16(zero.time,tmp) == lw#igt) STR32(0, zero.time, tmp);	//	THIS SHOULD NEVER HAPPEN	end;	/*	for other times, just start with sequence time:	*/	else do;		call Take.System.Sequence.Time(tmp);	/*	times, then assume	*/		if (tmp(lw#msb) < 0)							/*	VITC placing is		*/		or (com16(zero.time,tmp) = lw#igt)		/*	being done.				*/		then call STR32(0, zero.time, tmp);	end;	/*	assign the taken time to the correct entity:							*/	do case which;										/*	Time to take			*/		do;												/*	0 = cue in time		*/			tmp(2) = shl(0,8);						/*	Select cue in time	*/			call Set.Cue.Time.With.Format(tmp,format);		end;		do;												/*	1 = cue out time		*/			tmp(2) = shl(1,8);						/*	Select cue out time	*/			call Set.Cue.Time.With.Format(tmp,format);		end;		do;												/*	2 = edit in time		*/			tmp(2) = shl(2,8);						/*	Select edit in time	*/			call Set.Cue.Time.With.Format(tmp,format);		end;		do;												/*	3 = edit out time		*/			tmp(2) = shl(3,8);						/*	Select edit out time	*/			call Set.Cue.Time.With.Format(tmp,format);		end;		do;												/*	4 = source sync (edit in time)	*/			tmp(2) = shl(2,8);						/*	Select edit in time	*/			call Set.Cue.Time.With.Format(tmp,format);		end;		call Set.Destination.Sync.Time(tmp);	/*	5 = destination sync	*/		do;												/*	6 = mark point			*/			call Set.Sequencer.Mark.Start.Point(tmp(0), tmp(1), 0);		end;		do;												/*	7 = pre-roll time		*/			pre.roll.msb = tmp(lw#msb);			pre.roll.lsb = tmp(lw#lsb);			if auto.punch.on <> 0 then do;				call Set.Sequencer.Mark.Start.Point(tmp(lw#msb),tmp(lw#lsb),0);			end;		end;		do;												/*	8 = record in time	*/			auto.punch.in.msb = tmp(lw#msb);			auto.punch.in.lsb = tmp(lw#lsb);		end;		do;												/*	9 = record out time	*/			auto.punch.out.msb = tmp(lw#msb);			auto.punch.out.lsb = tmp(lw#lsb);		end;	end;	return(TRUE);end Take.Current.Time;Send.Mark.Time.Packet: proc (packet,des) swapable;	dcl packet		array;	dcl des			fixed;	dcl time (1)	fixed;	write(mam) = misc.ptr;	write(mdi) = L#Mark_Time;	write(mdi) = des;	write(mdi) = T#Mark_Time;	write(mdi) = packet(0);									/*	Return the tag		*/	call copy32(loc(addr(mark.button.msb)),time);	/*	Get the current mark time		*/	if com16(ZERO.TIME,time) <> lw#igt					/*	If the time is large enough	*/	then call sub16(ZERO.TIME,time);						/*	Remove "ZERO.TIME" offset		*/	else call str32(0,0,time);								/*	Else, put us at zero				*/	write(mdi) = time(lw#msb);								/*	MARK time			*/	write(mdi) = time(lw#lsb);	write(mdi) = (mark.button.disabled=0);				/*	true if enabled	*/	if not Send.Protocol.Packet(misc.ptr,1)	then do;							/*	no room in protocol output buffer now	*/		return(FALSE);				/*	try again later								*/	end;	return(TRUE);end Send.Mark.Time.Packet;Set.Mark.Start.Time: proc (time) swapable;	dcl time			array;	dcl (msb,lsb)	fixed;	call add16(ZERO.TIME,time);	/*	Add "ZERO.TIME" offset	*/	msb=mark.button.msb;				/*	copy mark start time		*/	lsb=mark.button.lsb;	if  (msb=0)							/*	check for < zero.time	*/	and (lsb ilt zero.time)	then lsb=zero.time;	if  (time(0)=msb)					/*	if time matches current mark point	*/	and (time(1)=lsb)	then return(1);					/*	avoid redundant calls	*/	call Set.Sequencer.Mark.Start.Point(time(0),time(1),0);	return(1);end Set.Mark.Start.Time;/*	Routines to access raw SMPTE times	*/Send.Cur.Smpte.Time: proc (packet,des) swapable;	dcl packet	array;	dcl des		fixed;	write(mam) = misc.ptr;	write(mdi) = L#Cur_SMPTE_Time;	write(mdi) = des;	write(mdi) = T#Cur_SMPTE_Time;	write(mdi) = packet(0);			/*	Return the tag		*/	write(mdi) = packet(1);			/*	and option bits	*/	/*	For now, just return the raw SMPTE time.  Could look at option	*/	/*	bits for VITC information, display offsets, which SMPTE time,	*/	/*	etc.																				*/	write(mdi) = shl(cur.hrs,8)\cur.min;	write(mdi) = shl(cur.sec,8)\cur.fra;	if not Send.Protocol.Packet(misc.ptr,1)	then do;						/*	no room in protocol output buffer now	*/		return(FALSE);			/*	try again later								*/	end;	return(TRUE);end Send.Cur.Smpte.Time;Send.Valid.Saved.Marks: proc (packet,des) swapable;	dcl packet		array;	dcl des			fixed;	dcl valid(2)	fixed;	/*	Build array of valid marks here	*/	dcl time(1)		fixed;	/*	Fetch times into here	*/	dcl s1(20)		fixed;	/*	Fetch strings into here	*/	dcl s2(20)		fixed;	dcl i				fixed;	call Read.In.Entire.AEE.Locate.Stack(0);	/*	Fetch all saved marks from XMEM	*/	do i=0 to 19;		call Fetch.AEE.Locate.Stack.Entry(i,time,s1,s2);		if time(lw#msb) <> 0 OR time(lw#lsb) <> 0						/*	Time is non-zero		*/		then valid(shr(i,4)) = valid(shr(i,4)) | bits(i & "17");	/*	We are saving a mark	*/	end;	write(mam) = misc.ptr;	write(mdi) = L#Valid_Saved_Marks;	write(mdi) = des;	write(mdi) = T#Valid_Saved_Marks;	write(mdi) = packet(0);	/*	Return the tag	*/	write(mdi) = 0;			/*	Base - first mark is "0"	*/	write(mdi) = valid(0);	/*	Valid bits		*/	write(mdi) = valid(1);	rpc 14;	write(mdi) = 0;			/*	We only have 20 saved marks for now		*/	if not Send.Protocol.Packet(misc.ptr,1)	then do;						/*	no room in protocol output buffer now	*/		return(FALSE);			/*	try again later								*/	end;	return(TRUE);end Send.Valid.Saved.Marks;Send.Saved.Mark: proc (packet,des) swapable;	dcl packet	array;	dcl des		fixed;	dcl tag		fixed;	dcl time(1)	fixed;	/*	Fetch time into here	*/	dcl s1(40)	fixed;	/*	Fetch strings into here	*/	dcl s2(20)	fixed;	dcl i			fixed;	tag = packet(0);	/*	Arg out of bounds, send back a short answer with only a tag		*/	if packet(1) < 0 OR packet(1) > 19 then do;		write(mam) = misc.ptr;		rpc 64;		write(mdi) = 0;	/*	Just in case someone tries to read data!	*/		call Send.Only.Tag(des,tag,T#Saved_Mark);		return(TRUE);	end;	call Read.In.Entire.AEE.Locate.Stack(0);	/*	Fetch all saved marks from XMEM	*/	call Fetch.AEE.Locate.Stack.Entry(packet(1),time,s1,s2);	call Remove.Zero.Time.Offset(time);	write(mam) = misc.ptr;	write(mdi) = L#Saved_Mark;	write(mdi) = des;	write(mdi) = T#Saved_Mark;	write(mdi) = tag;						/*	Return the tag	*/	write(mdi) = packet(1);				/*	Mark #			*/	write(mdi) = time(lw#msb);			/*	Mark time		*/	write(mdi) = time(lw#lsb);	if s1(0) > 20 then s1(0) = 20;	/*	Limit string to 20 chars long		*/	call pbyte(s1,s1(0),0);				/*	Add null to end of Able string	*/	s1(0) = s1(0) + 1;	if s2(0) > 20 then s2(0) = 20;	/*	Ditto for s2	*/	call pbyte(s2,s2(0),0);	s2(0) = s2(0) + 1;	/*	Smash the strings together since the first may end on an odd byte	*/	do i=0 to s2(0)-1;					/*	For each char in second string	*/		call pbyte(s1,s1(0),byte(s2,i));		s1(0) = s1(0) + 1;	end;	/*	Write out the merged strings	*/	do i=1 to shr(s1(0)+1,1);			/*	Number of words to send				*/		write(mdi) = rot(s1(i),8);		/*	Swap the bytes in the string!		*/	end;	write(mam) = misc.ptr;	/*	Add string byte lengths to packet length.  We already			*/	/*	allowed for the nulls, so subtract 2 from the total length	*/	write(md) = read(md) + s1(0) - 2;	if not Send.Protocol.Packet(misc.ptr,1)	then do;							/*	no room in protocol output buffer now	*/		return(FALSE);				/*	try again later								*/	end;	return(TRUE);end Send.Saved.Mark;Set.Saved.Mark: proc (packet) swapable;	dcl packet	array;	dcl s1(20)	fixed;	/*	Build strings into here	*/	dcl s2(20)	fixed;	/*	Check for arg out of bounds		*/	if packet(0) < 0 OR packet(0) > 19 then return(TRUE);	/*	Convert strings to Able format	*/	call C.To.Able.String(s1,loc(addr(packet(3))),0);	/*	If the first string was an odd # of chars, it's even with the null	*/	/*	so the second string starts on a word boundary (fine).					*/	if s1(0) & 1 then	call C.To.Able.String(s2,loc(addr( packet(3+(shr(s1(0)+1,1))) )),0);	/*	Otherwise, we start the conversion in the middle of a word	*/	/*	(ie: last arg is "1")													*/	else	call C.To.Able.String(s2,loc(addr( packet(3+(shr(s1(0)+1,1))) )),1);	/*	Now we have the arguments that were passed in, so set the saved mark	*/	/*	Fetch all saved marks from XMEM	*/	call Read.In.Entire.AEE.Locate.Stack(0);	/*	Change the mark of interest		*/	call Add.Zero.Time.Offset(loc(addr(packet(1))));	call Store.AEE.Locate.Stack.Entry(packet(0),loc(addr(packet(1))),s1,s2);	/*	Declare an event so the protocol knows this has changed	*/	New.Seq.Info = New.Seq.Info | 8;		/*	New constants	*/	/*	Now, save all the entries back in the sequence		*/	call Store.Entire.AEE.Locate.Stack(0);	return(TRUE);end Set.Saved.Mark;/*	Routines to set the DTD sync mode	*/Send.DTD.DSP.Sync.Mode.Packet: proc (packet,des) swapable;	dcl packet	array;	dcl des		fixed;	dcl dtd.dsp.sync.mode	fixed external;	write(mam) = misc.ptr;	write(mdi) = L#DTD_DSP_Sync_Mode;	write(mdi) = des;	write(mdi) = T#DTD_DSP_Sync_Mode;	write(mdi) = packet(0);				/*	Send the tag	*/	write(mdi) = dtd.dsp.sync.mode + 1;	if not Send.Protocol.Packet(misc.ptr,1)	then do;									/*	no room in protocol output buffer now	*/		return(FALSE);						/*	try again later								*/	end;	return(TRUE);							/*	success	*/end Send.DTD.DSP.Sync.Mode.Packet;Set.DTD.DSP.Sync.Mode: proc (packet) swapable;	dcl packet	array;	/*	From the packet	*/	if (dtd.max.secs <> 0)				/*	if DTD is running				*/	then do;		write(mam) = scsi.ptr;			/*	send message to DTD asking	*/		write(mdi) = 60;					/*	it to sync to DSP.			*/		write(mdi) = packet(0) - 1;		call Send.To.Lod(144,4);	end;	return(TRUE);end Set.DTD.DSP.Sync.Mode;/*	$SUBTITLE Process time base messages	*/Handle.Time.Base: proc swapable;	dcl (len,des)	fixed;	dcl subtype		fixed;	dcl data_words	lit '32';				/*	Number of data words to read		*/	dcl packet(data_words-1)	fixed;	/*	Array to hold data from packet	*/	dcl ret			fixed;	dcl i				fixed;	write(mam) = Packet.Ptr;	write(mal) = P#LEN;	  len	= read(md);	write(mal) = P#SOURCE; des	= read(md);	write(mal) = P#TYPE;	subtype	  = read(md) & "377";	write(mal) = P#DATA;	write("313") = addr(packet(0));	rpc data_words;	write("373") = read(mdi);	ret = 1;	/*	assume ok unless someone returns a specific error	*/	if subtype < 16	then do case subtype;			/*	Branch on specific command (0-15)	*/		do;	/*	0:  Current Time	*/			/*	This is handled by the interrupt routine in :SYNRSOU:10-INT:144-TIM2	*/		end;		do;	/*	 1:  Request time parameters	*/			ret = Send.Time.Parameters.Packet(packet,des);		end;		do;	/*	 2:  Time parameters	*/			/*	This is handled by the request routine	*/		end;		do;	/*	 3:  Set time parameters	*/			ret = Set.Time.Parameters(packet);		end;	end;		/*	of branch on specific command (0-15)	*/	else if subtype < 48	then do case (subtype - 16);	/*	Branch on specific command (16-47)	*/		do;	/*	16:  Request sync mode	*/			ret = Send.Sync.Mode.Packet(packet,des);		end;		do;	/*	17:  Sync mode	*/			/*	This is handled by the request routine	*/		end;		do;	/*	18:  Set sync mode	*/			ret = Set.Sync.Mode(packet);		end;		do;	/*	19:  Set MIDI sync out port	*/			ret = Set.MIDI.Sync.Out(packet);		end;		do;	/*	20:  Set MIDInet sync out path	*/			ret = Set.MIDInet.Sync.Out(packet);		end;		do;	/*	21:  Take current time	*/			ret = Take.Current.Time(packet,des);		end;		do;	/*	22:  Request mark time	*/			ret = Send.Mark.Time.Packet(packet,des);		end;		do;	/*	23:  Mark time	*/			/*	This is handled by the request routine	*/		end;		do;	/*	24:  Set mark time	*/			ret = Set.Mark.Start.Time(packet);		end;		do;	/*	25:  Request raw SMPTE time	*/			ret = send.cur.SMPTE.time(packet,des);		end;		do;	/*	26:  Raw SMPTE time answer	*/		end;		do;	/*	27:  Request valid saved marks	*/			ret = Send.Valid.Saved.Marks(packet,des);		end;		do;	/*	28:  Valid saved marks	*/			/*	This is handled by the request routine	*/		end;		do;	/*	29:  Request saved mark	*/			ret = Send.Saved.Mark(packet,des);		end;		do;	/*	30:  Saved mark	*/			/*	This is handled by the request routine	*/		end;		do;	/*	31:  Set saved mark	*/			ret = Set.Saved.Mark(packet);		end;	end;		/*	of branch on specific command (16-31)	*/	else if subtype < 64	then do case (subtype - 48);	/*	Branch on specific command (48-63)	*/		do;	/*	48:  Request DTD/DSP sync mode	*/			ret = Send.DTD.DSP.Sync.Mode.Packet(packet,des);		end;		do;	/*	49:  Current DTD/DSP Sync mode	*/			/*	This is created by the request routine	*/		end;		do;	/*	50:  Set sync mode	*/			ret = Set.DTD.DSP.Sync.Mode(packet);		end;	end;	/*	----------- old do case stuff -----------	*/	if 0 then do case subtype;	/*	branch on specific time base command	*/		do;	/*	 6:  set DTD time format - set format for dtd times		*/			i = map.d115.node.id(des);				/*	get board/channel #		*/			if i <> (-1)								/*	make sure we found it	*/			then do;				if shr(packet(0),8) = 0				/*	wants disk times			*/				then d115d.format(i) = d115d.format(i) & (not(PFORM#DTDSeq));				else d115d.format(i) = d115d.format(i) \ PFORM#DTDSeq;			end;		end;	end;				/*	of branch on specific creation/recording command	*/	return(ret);	/*	return processed status	*/end Handle.Time.Base;