/* TRAPSND  $TITLE  ROUTINES TO PROCESS SOUND EDITING PACKETS   Modified:   01/15/97 - CJ  - Cached cue info in Request.Cue.String.By.Id to speed up index update   09/20/91 - CJ  - Added in time offset to cue.data.by.id record   07/12/91 - PF  - removed BadPlaceTrack error call from Set.Place.Track.Value   10/26/90 - MWH - Force an "answer" from all "request" messages   05/10/90 - cj  - added messages to get at cue info by id   01/11/90 - MWH - Remove zero.time offset from destination sync time   09/28/89 - MWH - Add reels to Set Cue String; fix save/rest, trk bugs   08/30/89 - MWH - Rework the protocol for release 2.2   07/27/89 - MWH - Subtract ZERO.TIME instead of adding it for CUE DATA   06/28/89 - cj  - began changes for 2.2 event processing   06/16/89 - MWH - Remove ZERO.TIME offset from times sent over the protocol   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/21/89 - MWH - Wait for AEE to be up to date before doing a slide   03/16/89 - MWH - Add looping to PASTE and FILL edits   03/14/89 - PF  - changed process packet processing logic   01/20/89 - MWH - Fix bug with slide: deferring too many messages!   12/20/88 - MWH - Allow pasting and filling of leader   11/30/88 - MWH - Add AEE editing functions   11/10/88 - MWH - Clean up messages and update lengths   09/15/88 - PF - Created this source file*//* Define literals for max # of reels we can access.  Currently set *//* at 12 for current cue, 3 clipboards, 8 reels.                    */dcl Max.Reels  lit '12';Send.Cue.Data.Packet: proc (des,cue,tag) swapable;   dcl des        fixed;    /* Packet destination */   dcl cue        fixed;    /* Which cue: -1 = current, 0-(Max.Reels-1) are cue, clip/reel's */   dcl tag        fixed;    /* ID of requestor to be returned */   dcl other      fixed;    /* Is data about an "other" (non-current) cue */   dcl save.reel  fixed;    /* Save "current cue" here */   dcl time (1)   fixed;    /* Add ZERO.TIME offset and store times here */   dcl sbits(1)   fixed;    /* Create raw sync time here */   dcl smode      fixed;    /* Mode for raw sync time */   dcl place_trk  fixed;    /* Cue place track */   dcl fade_in    fixed;   dcl fade_out   fixed;   dcl (i,j)      fixed;   Adjust.Disk.Time: proc (intime, format, outtime);      dcl intime  array;      dcl format  fixed;      dcl outtime array;      if format = 0 then do;     /* adjust for current project display   */         call ADD32(intime, Cue.Time.Display.Offset, outtime);      end;      else do;                   /* adjust for sequence display          */         call SUB32(intime,  Cue.In.Time,   outtime); /* get dist into cue */         call ADD32(outtime, Cue.Trig.Time, outtime); /* get seq time      */      end;      call Remove.Zero.Time.Offset(outtime);   end Adjust.Disk.Time;   other = 0;   if  (cue <> -1)                /* If we're not just sending the current cue */   AND (cue <> Current.Cue.Reel)  /* ...and the one desired is not current */   then do;                       /* ...then we must select it temporarily */      other = 1;      save.reel = Current.Cue.Reel;      call SET.DTD.CURRENT.REEL(cue);     /* select that reel              */      call DEPOSIT.A.NEW.CURRENT.CUE(0);  /* set up global information     */   end;   /* Get the "raw" sync time in SMPTE bits */   write(mam) = Current.Cue.Ptr;   write(mal) = cue.smpt.msb;   sbits(0)   = read(mdi);   sbits(1)   = read(mdi);   smode      = read(mdi);   /* Fade in and fade out */   write(mal) = cue.fin;   fade_in    = read(md);   write(mal) = cue.fout;   fade_out   = read(md);   /* Cue place track */   place_trk = GID(Cue.Place.Track);   place_trk = sync.to.proto.strk(place_trk);   /* Look up the DTD time format that this device is using so we can */   /* map the DTD times correctly:                                    */   i = map.d115.node.id(des);         /* get board/channel #       */   if i <> (-1)   then j = ((d115d.format(i) & PFORM#DTDSeq) <> 0);   else j = 0;   /* Now build the output packet */   write(mam) = misc.ptr;      write(mdi) = L#Cue_Data;   write(mdi) = des;   write(mdi) = T#Cue_Data;   write(mdi) = tag;   /* Get the cue times and send them over: */   call Adjust.Disk.Time(Cue.In.Time, j, time);       /* in time         */   write(mdi) = time(0); write(mdi) = time(1);   call Adjust.Disk.Time(Cue.Out.Time, j, time);      /* out time        */   write(mdi) = time(0); write(mdi) = time(1);   call Adjust.Disk.Time(Cue.Edit.In.Time, j, time);  /* edit in time    */   write(mdi) = time(0); write(mdi) = time(1);   call Adjust.Disk.Time(Cue.Edit.Out.Time, j, time); /* edit out time   */   write(mdi) = time(0); write(mdi) = time(1);   call Adjust.Disk.Time(Cue.Offs.Time, j, time);     /* offset time     */   write(mdi) = time(0); write(mdi) = time(1);   call copy32(Cue.Sync.Time,time);                   /* sync time       */   call Remove.Zero.Time.Offset(time);   write(mdi) = time(0); write(mdi) = time(1);   write(mdi) = sbits(0);                             /* "raw" sync time */   write(mdi) = sbits(1);   write(mdi) = smode;   write(mdi) = fade_in;                              /* fade in         */   write(mdi) = fade_out;                             /* fade out        */   write(mdi) = 0;                                    /* track base      */   write(mdi) = Current.Cue.Drive.Bits;               /* 8 wds trk bits  */   rpc 7;   write(mdi) = 0;   write(mdi) = place_trk;                            /* cue place track */   write(mdi) = shl(Current.Cue.Sync.Mode,8)          /* place mode      */              | Current.Cue.Reel;                     /* reel number     */   write(mdi) = shl(other,8);                         /* current reel?   */   /* Reselect original reel if we need to: */   if other <> 0 then do;            /* If sending info about an "other" reel */      call SET.DTD.CURRENT.REEL     (save.reel);      call DEPOSIT.A.NEW.CURRENT.CUE(0        );   end;   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      return(0);                   /* return zero - try again later         */   end;   return(1);                      /* success */end Send.Cue.Data.Packet;Request.Cue.Data: proc (packet,des) swapable;   dcl packet     array;               /* Protocol arguments passed in */   dcl des        fixed;               /* Destination node id */   dcl reel       fixed;   dcl tag        fixed;   tag  = packet(0);                   /* Get data passed in to us */   reel = shr(packet(1),8);   if reel & "200" <> 0                /* If the byte is negative */   then reel = reel | "177400";        /* Perform a sign extend */   if (reel >= Max.Reels OR reel < -1) /* If invalid cue/clip/reel */   then do;      call Send.Only.Tag(des,tag,T#Cue_Data);      return(1);                       /* That is all              */   end;   return(Send.Cue.Data.Packet(des,reel,tag));end Request.Cue.Data;dcl cached.cue.id fixed;dcl (cached.in,cached.out,cached.editin)  (1) fixed;dcl (cached.editout,cached.offset)        (1) fixed;dcl (cached.sbits)                        (1) fixed;dcl (cached.smode)                            fixed;dcl (cached.tracks)                       (7) fixed;dcl (cached.fin,cached.fout)                  fixed;dcl (cached.eventin)                      (1) fixed;Request.Cue.Data.by.ID: proc (packet,des) swapable;   dcl packet     array;               /* Protocol arguments passed in */   dcl des        fixed;               /* Destination node id */   dcl tag        fixed;   dcl id         fixed;   dcl i          fixed;	dcl len(1)     fixed;	dcl inoffset (1) fixed;   tag = packet(0);                    /* Get message tag     */   id  = packet(2);                    /* and cue ID          */	if (cached.cue.id != id)				/* if not cached...	  */	{		call Fetch.Entire.DTD.Cue(id,Scsi.Ptr); 		        /* fetch entire cue, or all zeroes */			cached.cue.id = id;				write(mam) = Scsi.Ptr;		write(mal) = cue.s.msb;		cached.in (0)     = read(mdi); cached.in (1) = read(mdi);   /* cue.s.msb, cue.s.lsb */		cached.out(0)     = read(mdi); cached.out(1) = read(mdi);   /* cue.e.msb, cue.e.lsb */		cached.fin        = read(mdi);                       /* cue.fin              */		cached.fout       = read(mdi);                       /* cue.fout             */		cached.tracks(0)  = read(mdi);                       /* cue.trks             */		cached.tracks(1)  = read(mdi);		cached.tracks(2)  = read(mdi);		cached.tracks(3)  = read(mdi);			write(mal) = cue.smpt.msb;		cached.sbits(0)   = read(mdi);                       /* cue.smpt.msb         */		cached.sbits(1)   = read(mdi);                       /* cue.smpt.lsb         */		cached.smode      = read(mdi);                       /* cue.smpt.mode        */			cached.editin (0) = read(mdi);                       /* cue.edit.in.msb      */		cached.editin (1) = read(mdi);                       /* cue.edit.in.lsb      */		cached.editout(0) = read(mdi);                       /* cue.edit.out.msb     */		cached.editout(1) = read(mdi);                       /* cue.edit.out.lsb     */		cached.offset (0) = read(mdi);                       /* cue.off.msb          */		cached.offset (1) = read(mdi);                       /* cue.off.lsb          */			write(mal) = event.in.s#.msb;                        /* event.in.s#.msb      */		cached.eventin(0) = read(mdi);		cached.eventin(1) = read(mdi);	}	   /* Compute cue length in 32-bit milliseconds */   call SUB32(cached.out, cached.in, len);   call DTD.Sample.#.To.Msecs(len, CF#Dur, SAMP.SPEED, AEE.Current.Project.Rate, zero.zero, len);   call SUB32(cached.in, cached.eventin, inoffset);   /* Now build the output packet */   write(mam) = misc.ptr;      write(mdi) = L#Cue_Data_By_ID;   write(mdi) = des;   write(mdi) = T#Cue_Data_By_ID;   write(mdi) = tag;   write(mdi) = 0;                 write(mdi) = id;    write(mdi) = cached.in(0);      write(mdi) = cached.in(1);   write(mdi) = cached.out(0);     write(mdi) = cached.out(1);   write(mdi) = cached.editin(0);  write(mdi) = cached.editin(1);   write(mdi) = cached.editout(0); write(mdi) = cached.editout(1);   write(mdi) = cached.offset(0);  write(mdi) = cached.offset(1);   write(mdi) = cached.sbits(0);   write(mdi) = cached.sbits(1);   write(mdi) = cached.smode;   write(mdi) = cached.fin;   write(mdi) = cached.fout;   write(mdi) = len(0);     write(mdi) = len(1);   write(mdi) = 0;                                    /* track base      */   do i = 0 to 7;      write(mdi) = cached.tracks(i);   end;   write(mdi) = inoffset(0);   write(mdi) = inoffset(1);	cached.cue.id = 0;				  /* only cache once; this will help		 */											  /* transfermation updates but will       */											  /* minimize occurrences of a cache	    */											  /* match error...							    */   	if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      return(0);                   /* return zero - try again later         */   end;   return(1);                      /* success */end Request.Cue.Data.By.ID;/* $page - routine to set a time for the current cue *//* This routine is called to set a CUE IN, CUE OUT, EDIT IN, or EDIT out *//* time.   It is passed a time format code and a packet.                 *//* Description of time format codes:                                     *//* code = 0  ==> means the time in question is a direct-to-disk time     *//*               that has been offset to show the disk time with respect *//*               to the current project (if possible).  This was done    *//*               by adding Cue.Time.Display.Offset to the original time. *//* code = 1  ==> means the time in question is a direct-to-disk time     *//*               that has been offset to show the disk time with respect *//*               to the sequencer (assuming the current cue is placed    *//*               at its sync time).                                      *//* These codes match the time formats available in the 'here is'         *//* message and the Cue Data message.                                     */Set.Cue.Time.With.Format: proc (packet,format) swapable;   dcl packet    array;                 /* From the packet           */   dcl format    fixed;                 /* pass code for time format */   dcl mode      fixed;   dcl time (1)  fixed;   dcl i         fixed;   mode = shr(packet(2),8);            /* Last (upper) byte is mode */   if (mode igt 7) return(1);				/* Be sure input is legal    */   call copy32(packet,time);   do case mode;                       /* branch on type         */      do; /*  0: set cue in time */           i = ASSIGN.NEW.DTD.CUE.IN(time, format, 1);         do case i-1;            call Present.Protocol.Error.Message(NT#InTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#SyncTimeError,ATTR#Reverse,0,0,0);         end;         call Set.DTD.Scrub.Anchor.Point(Cue.In.Time);      end;      do; /*  1: set cue out time */         i = ASSIGN.NEW.DTD.CUE.OUT(time, format, 1, 0);         if i = 1         then call Present.Protocol.Error.Message(NT#InTimeError,ATTR#Reverse,0,0,0);         call Set.DTD.Scrub.Anchor.Point(Cue.Out.Time);      end;      do; /*  2: set edit in time */         i = ASSIGN.NEW.DTD.EDIT.IN(time, format, 1);         do case i-1;            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideIn,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideOut,ATTR#Reverse,0,0,0);         end;         call Set.DTD.Scrub.Anchor.Point(Cue.Edit.In.Time);      end;      do; /*  3: set edit out time */         i = ASSIGN.NEW.DTD.EDIT.OUT(time, format, 1, 0);         do case i-1;            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideOut,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideIn,ATTR#Reverse,0,0,0);         end;         call Set.DTD.Scrub.Anchor.Point(Cue.Edit.Out.Time);      end;      do;  /* 4: set cue offset time - for now, same as edit in */         i = ASSIGN.NEW.DTD.EDIT.IN(time, format, 1);         do case i-1;            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideIn,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#EditTimeError,ATTR#Reverse,0,0,0);            call Present.Protocol.Error.Message(NT#BadSlideOut,ATTR#Reverse,0,0,0);         end;         call Set.DTD.Scrub.Anchor.Point(Cue.Edit.In.Time);      end;      do; /* 5: set destination sync time */         call Set.Destination.Sync.Time(time);      end;      do; /* 6: set fade in time */         write(mam) = Current.Cue.Ptr;    /* store in cue record     */         write(mal) = CUE.FIN;         write(md ) = time(1);         call Set.Cue.Modified;           /* has been changed        */         call UPDATE.CURRENT.CUE.RECORD;  /* create new audition */                                          /* cue if needed       */      end;      do; /* 7: set fade out time */         write(mam) = Current.Cue.Ptr;    /* store in cue record     */         write(mal) = CUE.FOUT;         write(md ) = time(1);         call Set.Cue.Modified;           /* has been changed        */         call UPDATE.CURRENT.CUE.RECORD;  /* create new audition */                                          /* cue if needed       */      end;   end;   return(1);end Set.Cue.Time.With.Format;Set.Cue.Time: proc (packet,des) swapable;   dcl packet    array;                 /* From the packet */   dcl des       fixed;                 /* node id         */   dcl mode      fixed;   dcl time (1)  fixed;   dcl i         fixed;   dcl j         fixed;   /* Look up the time format of the time we are passed.  Set j to  */   /* 1 if this is an audition format time, else set j to 0         */   i = map.d115.node.id(des);          /* get board/channel #       */   if i <> (-1)   then j = ((d115d.format(i) & PFORM#DTDSeq) <> 0);      mode = shr(packet(2),8);            /* Last (upper) byte is mode */   if  (mode <> 6)                     /* no zero.time offset       */   and (mode <> 7)                     /* for fade in time          */   then call add16(ZERO.TIME, packet); /* Add "ZERO.TIME" offset    */   call Set.Cue.Time.With.Format(packet,j);   return(1);end Set.Cue.Time;Select.DTD.Cue.Tracks: proc(tbits,state) swapable;   dcl tbits   fixed;   dcl state   fixed;   dcl i       fixed;   if (state <> 0)   then i = Current.Cue.Drive.Bits \ tbits;   else i = Current.Cue.Drive.Bits & (not tbits);   i = i & DTD.AVAIL.TRKS;   call ASSIGN.NEW.DRIVE.BITS.TO.REEL (Current.Cue.Ptr, i);   if DTD.PLAY.STATE <> 0   then call Set.DTD.Play.Tracks(Current.Cue.Drive.Bits);end Select.DTD.Cue.Tracks;Set.Cue.Tracks: proc (packet) swapable;   dcl packet    array;   dcl base      fixed;   dcl tbits     fixed;   dcl state     fixed;   base = packet(0);   if base <> 0 then return(TRUE);   tbits = packet(1);   state = shr(packet(9),8);   call Select.DTD.Cue.Tracks(tbits,state);   return(TRUE);end Set.Cue.Tracks;Set.Place.Track.Value: proc (packet) swapable;   dcl packet array;   dcl track  fixed;   dcl i      fixed;   track = proto.to.sync.strk(packet(0));   /* Use system routine to assign track & notify everyone of events: */   if track = -1 then i = 1;                 /* Bad track number passed in */   else i = ASSIGN.DTD.PLACE.TRACK(track);   return(TRUE);end Set.Place.Track.Value;Request.Cue.String: proc (packet,des) swapable;   dcl packet     array;    /* Data received over the protocol */   dcl des        fixed;    /* Node id */   dcl tag        fixed;    /* ID of requestor to be returned */   dcl string     fixed;    /* Which string to send: 0=name, 1=caption */   dcl cue        fixed;    /* Which cue: -1 = current, 0-(Max.Reels-1) are cue, clip/reel's */   dcl save.reel  fixed;    /* Save "current cue" here */   dcl other      fixed;    /* Is data about an "other" (non-current) cue */   dcl rlen       fixed;    /* Cue record length */   dcl nlen       fixed;    /* Cue name length */   dcl clen       fixed;    /* Caption length */   dcl i          fixed;   tag    = packet(0);   string = packet(1);   cue    = shr(packet(2),8);   if cue & "200" <> 0                 /* If the byte is negative */   then cue = cue | "177400";          /* Perform a sign extend */   if string < 0   OR string > 1   then do;      call Send.Only.Tag(des,tag,T#Cue_String);      return(TRUE);   end;   if  (cue <> -1)                /* If we're not just sending the current cue */   AND (cue <> Current.Cue.Reel)  /* ...and the one desired is not current */   then do;                       /* ...then we must select it temporarily */      other = 1;      save.reel = Current.Cue.Reel;      call SET.DTD.CURRENT.REEL(cue);     /* select that reel              */      call DEPOSIT.A.NEW.CURRENT.CUE(0);  /* set up global information     */   end;   /* Get the string of interest into misc.buf */   write(mam) = Current.Cue.Ptr;   do case string;      do;  /* 0:  Name */         write(mal) = CUE.NAME;         call COPY.IN(addr(misc.buf(0)),17);      end;      do;  /* 1:  Caption */         misc.buf(0) = 0;                       /* In case we don't find a caption */         write(mal) = CUE.RLEN;         rlen       = read(md);         write(mal) = CUE.NAME;         nlen       = shr(read(md)+3,1);        /* # of words in cue name  */         if (rlen) IGT (CUE.NAME + nlen) then do;            write(mal) = CUE.NAME + nlen;            clen  = read(md);                   /* Caption length in bytes */            if clen <> 0 then call COPY.IN(addr(misc.buf(0)),shr(clen+3,1));         end;      end;   end;   call pbyte(misc.buf,misc.buf(0),0);     /* Null at the end of "C" string */   /* Write out the header data which is common to both answers */   write(mam) = misc.ptr;      write(mdi) = L#Cue_String + misc.buf(0);   write(mdi) = des;   write(mdi) = T#Cue_String;   write(mdi) = tag;   write(mdi) = string;   write(mdi) = shl(Current.Cue.Reel,8) | other;   do i=1 to shr(misc.buf(0)+2,1);         /* Number of words to send */      write(mdi) = rot(misc.buf(i),8);     /* Swap the bytes in the string! */   end;   i = TRUE;                       /* Return TRUE if send works OK */   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      i = FALSE;                   /* return zero - try again later         */   end;   if other <> 0 then do;            /* If sending info about an "other" reel */      call SET.DTD.CURRENT.REEL     (save.reel);      call DEPOSIT.A.NEW.CURRENT.CUE(0        );   end;   return(i);end Request.Cue.String;Request.Cue.String.By.Id: proc (packet,des) swapable;   dcl packet     array;    /* Data received over the protocol */   dcl des        fixed;    /* Node id */   dcl tag        fixed;    /* ID of requestor to be returned */   dcl string     fixed;    /* Which string to send: 0=name, 1=caption */   dcl id         fixed;    /* Cue id */   dcl rlen       fixed;    /* Cue record length */   dcl nlen       fixed;    /* Cue name length */   dcl clen       fixed;    /* Caption length */   dcl i          fixed;   tag    = packet(0);   id     = packet(2);   string = packet(3);   if string < 0   OR string > 1   then do;      call Send.Only.Tag(des,tag,T#Cue_String_By_ID);      return(TRUE);   end;   /* Get the string of interest into misc.buf */   call Fetch.Entire.DTD.Cue(id,Scsi.Ptr); /* fetch entire cue, or all zeroes */	cached.cue.id = id;   	write(mam) = Scsi.Ptr;						/* cache info about the cue for anticipated */   write(mal) = cue.s.msb;						/* fetch of data ...								  */   cached.in (0)     = read(mdi); cached.in (1) = read(mdi);   /* cue.s.msb, cue.s.lsb */   cached.out(0)     = read(mdi); cached.out(1) = read(mdi);   /* cue.e.msb, cue.e.lsb */   cached.fin        = read(mdi);                       /* cue.fin              */   cached.fout       = read(mdi);                       /* cue.fout             */   cached.tracks(0)  = read(mdi);                       /* cue.trks             */   cached.tracks(1)  = read(mdi);   cached.tracks(2)  = read(mdi);   cached.tracks(3)  = read(mdi);   write(mal) = cue.smpt.msb;   cached.sbits(0)   = read(mdi);                       /* cue.smpt.msb         */   cached.sbits(1)   = read(mdi);                       /* cue.smpt.lsb         */   cached.smode      = read(mdi);                       /* cue.smpt.mode        */   cached.editin (0) = read(mdi);                       /* cue.edit.in.msb      */   cached.editin (1) = read(mdi);                       /* cue.edit.in.lsb      */   cached.editout(0) = read(mdi);                       /* cue.edit.out.msb     */   cached.editout(1) = read(mdi);                       /* cue.edit.out.lsb     */   cached.offset (0) = read(mdi);                       /* cue.off.msb          */   cached.offset (1) = read(mdi);                       /* cue.off.lsb          */   write(mal) = event.in.s#.msb;                        /* event.in.s#.msb      */   cached.eventin(0) = read(mdi);   cached.eventin(1) = read(mdi);   write(mam) = Scsi.Ptr;   do case string;      do;  /* 0:  Name */         write(mal) = CUE.NAME;         call COPY.IN(addr(misc.buf(0)),17);      end;      do;  /* 1:  Caption */         misc.buf(0) = 0;                       /* In case we don't find a caption */         write(mal) = CUE.RLEN;         rlen       = read(md);         write(mal) = CUE.NAME;         nlen       = shr(read(md)+3,1);        /* # of words in cue name  */         if (rlen) IGT (CUE.NAME + nlen) then do;            write(mal) = CUE.NAME + nlen;            clen  = read(md);                   /* Caption length in bytes */            if clen <> 0 then call COPY.IN(addr(misc.buf(0)),shr(clen+3,1));         end;      end;   end;   call pbyte(misc.buf,misc.buf(0),0);     /* Null at the end of "C" string */   /* Write out the header data which is common to both answers */   write(mam) = misc.ptr;      write(mdi) = L#Cue_String_By_ID + misc.buf(0);   write(mdi) = des;   write(mdi) = T#Cue_String_By_ID;   write(mdi) = tag;   write(mdi) = 0;   write(mdi) = id;   write(mdi) = string;   do i=1 to shr(misc.buf(0)+2,1);         /* Number of words to send */      write(mdi) = rot(misc.buf(i),8);     /* Swap the bytes in the string! */   end;   i = TRUE;                       /* Return TRUE if send works OK */   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      i = FALSE;                   /* return zero - try again later         */   end;   return(i);end Request.Cue.String.By.Id;Set.Cue.String: proc (packet) swapable;   dcl packet     array;   dcl string     fixed;    /* Which string to set: 0=name, 1=caption */   dcl cue        fixed;    /* Which cue: -1 = current, 0-(Max.Reels-1) are cue, clip/reel's */   dcl save.reel  fixed;    /* Save "current cue" here */   dcl other      fixed;    /* Is data about an "other" (non-current) cue */   dcl i          fixed;   string = packet(0);   cue    = shr(packet(1),8);   if cue & "200" <> 0                 /* If the byte is negative */   then cue = cue | "177400";          /* Perform a sign extend */   if string < 0   OR string > 1   then return(TRUE);   if  (cue <> -1)                /* If we're not just setting the current cue */   AND (cue <> Current.Cue.Reel)  /* ...and the one desired is not current */   then do;                       /* ...then we must select it temporarily */      other = 1;      save.reel = Current.Cue.Reel;      call SET.DTD.CURRENT.REEL(cue);     /* select that reel              */      call DEPOSIT.A.NEW.CURRENT.CUE(0);  /* set up global information     */   end;   /* Convert "C" string to "XPL" string, trashing "packet" array: */ // that is, we convert the packet argument from a packet into an able string format   do i = 1 to 31;      packet(i) = (packet(i) & "377") | (packet(i+1) & "177400");		// Note we bring the upper byte down from the next word   end;   /* get length of string. Look for a null at the end of the C string */   i = 0;   do while (i < 62) and (byte(packet,i) <> 0);      i = i + 1;   end;   packet(0) = i;   do case string;      call ASSIGN.NEW.DTD.CUE.NAME    (packet);   /* 0 = name */      call ASSIGN.NEW.DTD.CUE.CAPTION (packet);   /* 1 = caption */   end;   if other <> 0 then do;            /* If setting string in an "other" reel */      call SET.DTD.CURRENT.REEL     (save.reel);      call DEPOSIT.A.NEW.CURRENT.CUE(0        );   end;   return(TRUE);end Set.Cue.String;Copy.Cue.Memory: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl src        fixed;   dcl dst        fixed;   dcl src.ptr    fixed;   dcl dst.ptr    fixed;   dcl mode       fixed;   src  = shr(packet(0),8);            /* Get data passed in to us */   dst  = packet(0) & "377";           /* Clip/Reel to use         */   mode = shr(packet(1),8);            /* 0 = Copy entire cue      */                                       /* 1 = Copy edit region     */   if ((mode = 0) & (src = dst))       /* Copy to same place is no action */   OR (src >= Max.Reels | src < 0)     /* OR invalid cue/clip/reel        */   OR (dst >= Max.Reels | dst < 0)   then return(1);                     /* That is all                     */   src.ptr = Cue.Build.Ptr + ((src+6)*(shr(Max.Cue.Record.Len+255,8)));   dst.ptr = Cue.Build.Ptr + ((dst+6)*(shr(Max.Cue.Record.Len+255,8)));   if mode=0   then E$Status = COPY.CUE      (src.ptr,dst.ptr,false); /* Copy entire cue */   else E$Status = COPY.FROM.REEL(src.ptr,dst.ptr,false); /* Copy only edit */   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   if dst.ptr = Current.Cue.Ptr            /* if copying to current cue, */   then call Deposit.A.New.Current.Cue(1); /* then set up info and       */                                           /* create events.             */   return(1);end Copy.Cue.Memory;Cut.From.Cue: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl dst        fixed;   dcl dst.ptr    fixed;   dst  = shr(packet(0),8);            /* Get data passed in to us */   if (dst >= Max.Reels | dst < 0)     /* if invalid cue/clip/reel */   then return(1);                     /* then quit.               */   dst.ptr = Cue.Build.Ptr + ((dst+6)*(shr(Max.Cue.Record.Len+255,8)));   if dst = Current.Cue.Reel           /* cannot cut to/from self  */   then E$Status=E#CutNotAllowed;      /* (ie harri-karri)         */   else do;      call CUT.FROM.REEL(Current.Cue.Ptr,Current.Cue.Ptr,dst.ptr,0,1);      call Deposit.A.New.Current.Cue(0);   end;   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   return(1);end Cut.From.Cue;Paste.Into.Cue: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl src        fixed;   dcl src.ptr    fixed;   dcl looping    fixed;   dcl i          fixed;   src     = shr(packet(0),8);         /* Get data passed in to us */   looping = packet(0) & "377";        /* and see if loop paste    */   if ((src >= Max.Reels | src < 0)    /* if invalid cue/clip/reel */   AND  src <> 100)   then return(1);                     /* That is all              */   if src = 100 then do;               /* paste in leader          */      call INSERT.LEADER.ON.REEL(Current.Cue.Ptr, Current.Cue.Ptr, false);   end;   else do;                            /* else compute src ptr     */      src.ptr = Cue.Build.Ptr + ((src+6)*(shr(Max.Cue.Record.Len+255, 8)));      call PASTE.INTO.REEL(Current.Cue.Ptr, src.ptr, Current.Cue.Ptr, false, looping<>0);   end;   /* Set new track bits in current cue after a paste to bring in */   /* the audio for any newly brought in tracks:                  */   i = OR.ALL.REEL.TRACK.BITS(Current.Cue.Ptr);   write(mam) = Current.Cue.Ptr;   write(mal) = Cue.Trks;   write(md ) = i;   call Deposit.A.New.Current.Cue(0);  /* set up info & create events */   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   return(1);end Paste.Into.Cue;Chain.Cue: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl src        fixed;   dcl src.ptr    fixed;   dcl i          fixed;   src  = shr(packet(0),8);            /* Get data passed in to us */   if (src >= Max.Reels | src < 0)     /* if invalid cue/clip/reel */   then return(1);                     /* That is all              */   src.ptr = Cue.Build.Ptr + ((src+6)*(shr(Max.Cue.Record.Len+255, 8)));   call CHAIN.ONTO.REEL(Current.Cue.Ptr, src.ptr, Current.Cue.Ptr, false);   /* Set new track bits in current cue after a chain to bring in */   /* the audio for any newly brought in tracks:                  */   i = OR.ALL.REEL.TRACK.BITS(Current.Cue.Ptr);   write(mam) = Current.Cue.Ptr;   write(mal) = Cue.Trks;   write(md ) = i;   call Deposit.A.New.Current.Cue(0);  /* set up info & create events */   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   return(1);end Chain.Cue;Fill.Cue: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl src        fixed;   dcl src.ptr    fixed;   dcl looping    fixed;   dcl i          fixed;   src     = shr(packet(0),8);         /* Get data passed in to us */   looping = packet(0) & "377";        /* see if looping fill      */   if ((src >= Max.Reels | src < 0)    /* if invalid cue/clip/reel */   AND  src <> 100)   then return(1);                     /* That is all              */   if src = 100 then do;               /* fill with leader         */      call FILL.REEL.WITH.LEADER(Current.Cue.Ptr, Current.Cue.Ptr, false);   end;   else do;                            /* else fill from reel      */      src.ptr = Cue.Build.Ptr + ((src+6)*(shr(Max.Cue.Record.Len+255, 8)));      call FILL.REEL(Current.Cue.Ptr, src.ptr, Current.Cue.Ptr, false, looping<>0);   end;   /* Set new track bits in current cue after a fill to bring in  */   /* the audio for any newly brought in tracks:                  */   i = OR.ALL.REEL.TRACK.BITS(Current.Cue.Ptr);   write(mam) = Current.Cue.Ptr;   write(mal) = Cue.Trks;   write(md ) = i;   call Deposit.A.New.Current.Cue(0);  /* set up info & create events */   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   return(1);end Fill.Cue;Slide.Cue: proc (packet) swapable;   dcl packet         array;           /* From the packet */   dcl src            fixed;   dcl src.ptr        fixed;   dcl slide_time (1) fixed;   dcl orig.in    (1) fixed;   dcl orig.out   (1) fixed;   dcl in_time    (1) fixed;   dcl new.in     (1) fixed;   dcl mode           fixed;   dcl slide.mode     fixed;   call copy32(packet,slide_time);     /* Get 32-bit msec time to slide    */   mode = shr(packet(2),8);            /* Get 0 = ldr, 1 = audio, 2 = reel */   src  = packet(2) & "377";           /* Get source if reel  slide        */   src.ptr = Cue.Build.Ptr + ((src+6)*(shr(Max.Cue.Record.Len+255, 8)));   if ((mode = 2) & (src >= Max.Reels | src < 0)) /* if invalid cue/clip/reel       */   then return(1);                       /* then quit.                     */   /* Get current edit in & out times in samples.  This identifies         */   /* the region to slide:                                                 */   call Read.Cue.Time(Current.Cue.Ptr, Cue.Edit.In.Msb , orig.in );   call Read.Cue.Time(Current.Cue.Ptr, Cue.Edit.Out.Msb, orig.out);   /* Compute new destination time for the slide audio:                    */   call add32(Cue.Edit.In.Time, slide_time, in_time);   if (in_time(0) < 0)                      /* if sliding to before 0      */   or (com16(zero.time, in_time) = lw#igt)  /* or before zero.time         */   then call STR32(0, zero.time, in_time);  /* then limit to 0.000         */   call Msec.To.DTD.Sample.#(in_time, CF#Time, SAMP.SPEED, AEE.Current.Project.Rate, zero.zero, new.in);   if      mode = 0 then slide.mode = (-1);               /* Fill with leader */   else if mode = 1 then slide.mode = ( 1);               /* Fill with displaced audio */   else                  slide.mode = ( 0);               /* Fill with audio from a clip/reel */   call SLIDE.EDIT.REGION(orig.in, orig.out, new.in,                           Current.Cue.Ptr, Current.Cue.Ptr, src.ptr,                          slide.mode);   call Deposit.A.New.Current.Cue(0); /* set up info & create events */   call HANDLE.PROTOCOL.EDIT.ERROR.STATUS;   return(1);end Slide.Cue;Select.Reel: proc (packet) swapable;   dcl packet     array;               /* From the packet */   dcl reel       fixed;   reel = shr(packet(0),8);            /* Get data passed in to us */   if (reel >= Max.Reels | reel < 0)   /* if invalid cue/clip/reel */   then return(1);                     /* That is all              */   call SET.DTD.CURRENT.REEL(reel);    /* select that reel              */   call DEPOSIT.A.NEW.CURRENT.CUE(0);  /* set up global information     */   return(1);end Select.Reel;Handle.Sound.Editing: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   /* NOTE: "packet" is modified by Set.Cue.String */   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   if subtype < 16   then do case subtype;         /* Branch on specific command (0-15) */      do;  /* 0:  Request cue data */         ret = Request.Cue.Data(packet,des);      end;      do;  /* 1:  Cue data */         /* This is handled by the request routine */      end;      do; /*  2:  Cue time */         ret = Set.Cue.Time(packet,des);      end;      do;  /* 3:  Set cue tracks */         ret = Set.Cue.Tracks(packet);      end;      do;  /*  4:  set track to place cues on */         ret = Set.Place.Track.Value(packet);      end;      do;  /*  5: Set DTD place mode (pre, offset, post) */         call ASSIGN.NEW.DTD.SYNC.MODE(shr(packet(0),8));      end;      do;  /*  6: Request cue string */         ret = Request.Cue.String(packet,des);      end;      do;  /* 7:  Cue string */         /* This is handled by the request routine */      end;      do;  /*  8: Set cue name or caption */         ret = Set.Cue.String(packet);      end;      do;  /* 9: get cue data by I.D. */         ret = Request.Cue.Data.by.ID(packet,des);      end;      do;  /* 10: cue data by id          */      end;      do;  /* 11: Request cue string by id */         ret = Request.Cue.String.By.Id(packet,des);      end;   end;             /* of branch on specific command (0-15) */   else if subtype < 32   then do case (subtype - 16);  /* Branch on specific command (16-31) */      do;  /* 16:  Copy cue memory */         ret = Copy.Cue.Memory(packet);      end;      do;  /* 17:  Cut from cue */         ret = Cut.From.Cue(packet);      end;      do;  /* 18:  Paste into cue */         ret = Paste.Into.Cue(packet);      end;      do;  /* 19:  Chain cue */         ret = Chain.Cue(packet);      end;      do;  /* 20:  Fill cue */         ret = Fill.Cue(packet);      end;      do;  /* 21:  Slide cue */         ret = Slide.Cue(packet);      end;      do;  /* 22:  Select reel */         ret = Select.Reel(packet);      end;   end;             /* of branch on specific command (16-31) */   return (ret);             /* return processed status */end Handle.Sound.Editing;