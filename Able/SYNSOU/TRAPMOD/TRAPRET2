/* TRAPRET2 - Subroutines for protocol directory commands   Modified:   10/10/91 - MWH - Fix broken hash logic for POLY sound file DSID's   07/07/91 - cj  - Accessed poly sound file contents over protocol   04/23/91 - cj  - Fixed type filter bugs for Librarian   04/03/91 - cj  - Used cue.in.s# to find which project cue is in. Also rounded.   03/15/91 - cj  - Fixed bug f#len VS c#len   11/08/90 - MWH - Reformat DS routines   10/15/90 - CJ - CREATED.   *//* Status codes returned by many directory commands:        */dcl ##.good           lit '  0';dcl ##.bad.id         lit '  1';dcl ##.bad.entry.#    lit '  2';dcl ##.no.media       lit '  3';dcl ##.bad.access     lit '  4';dcl ##.bad.arg        lit '  5';dcl ##.no.id          lit '  6';dcl ##.bad.filetype   lit '  7';dcl ##.opt.xfer.err   lit '  8';dcl ##.invalid.name   lit '  9';dcl ##.dup.name       lit ' 10';dcl ##.no.storage     lit ' 11';dcl ##.scsi.error     lit '256';  /* lower half has S$SenseKey    */dcl ##.able.cat.err   lit '512';  /* lower half has C#Status      *//* Data array to map able file type to protocol file type:        */dcl type.of data (     /* maps able file type to protocol type    */   -1, -1, -1, -1,        /* text, exec, reloc, data              */   T#Seq,                 /* Synclavier sequence file             */   T#Snd,                 /* Synclavier poly sound file           */   T#Dir,                 /* Subcatalog                           */   T#Dir,                 /* Large Subcatalog                     */   -1,-1,                 /* dump file, spectral file             */   T#Opt,                 /* Optical disk index file              */   T#Tim);                /* Timbre                               *//* Literals for pseudo device codes:                              *//* device     0 = Root Directory                                  *//* device 1 - 8 = Able levels 0 - 7                               */dcl optical           lit ' 9';    /* ned O0 worm                 */dcl dtd_device        lit '10';    /* direct to disk              */dcl poly_ram          lit '11';    /* poly ram                    */dcl cur_timbres       lit '12';    /* timbre bank & entries       */dcl max_devices       lit '13';dcl odev              lit '10';    /* ABLE optical device level code */ /* same as LaserDev in RTP *//* Misc info about the direct to disk:                               */dcl Doing.Proto.Audition fixed PUBLIC;dcl num.dtd.projs     lit '50';    /* number of projects on DTD      */dcl song.len          lit '24';    /* words in each dtd proj entry   */dcl song.start        lit '13';    /* start time, secs, 50 khz       */dcl song.end          lit '14';    /* end   time, secs, 50 khz       *//* Codings for special direct to disk files and directories:         */dcl dtd_cp             lit '  1';  /* Current Project:               */dcl dtd_pd             lit '  2';  /* Project Info                   */dcl dtd_td             lit '  3';  /* Track Info                     */dcl dtd_audio          lit ' 16';  /* 16-31 = track x audio          */dcl dtd_projs          lit ' 50';  /* 50 - 99 = projects             */dcl dtd_cues           lit '100';  /* cues                           *//* Subroutines used by several protocol directory routines:          *//* Handy routines to access Direct to disk in convenient ways:       *//*   - get record and name of a dtd project:                         */fetch.dtd.song.info: proc (song, info, name) swapable;   dcl song    fixed;   dcl info    array;   dcl name    array;   dcl i       fixed;   call FETCH.DTD.SONG.DIRECTORY(song);   write(mam) = scsi.ptr;   call COPY.IN(addr(info(0)), song.len);   name(0) = 24;   do i = 1 to 12;      name(i) = info(i);   end;   do while (name(0) <> 0) & (byte(name, name(0)-1) = a.space);      name(0) = name(0) - 1;   end;   if name(0) <> 0 then call append.to.str(name, ':');   call pbyte(name, name(0), 0);   return (name(0) <> 0)                              /* return true if    */   &      ((info(song.start)\info(song.end)) <> 0);   /* project exists    */end fetch.dtd.song.info;/* Handy routine to fetch entire dtd cue and its name:                     */fetch.dtd.cue.info: proc (cue, name) swapable;   dcl cue    fixed;   dcl name   array;   call FETCH.ENTIRE.DTD.CUE(cue, scsi.ptr);   write(mam) = Scsi.Ptr;   write(mal) = CUE.NAME;   call COPY.IN(addr(name(0)), 17);   if name(0) IGT 32 then name(0) = 32;   call pbyte(name, name(0), 0);   return (name(0) <> 0);end fetch.dtd.cue.info;/* Handy routine to set up global information about a "local" current      *//* project:                                                                */set.up.local.project: proc(info, local.project.start, local.project.end) swapable;   dcl info                    array;   dcl local.project.start     array;   dcl local.project.end       array;   dcl s    fixed;   dcl e    fixed;   s          = info(song.start);       /* get song start and end    */   e          = info(song.end  );       /* times                     */   call STR32(0, S, Loc(Addr(BITMSB)));   call ratio_multiply(50000,256);      /* get sector # to start     */   call unround;                        /* truncate down             */   call COPY32(Loc(Addr(BITMSB)), local.project.start);   call SHL32(local.project.start, 8);  /* get sample #              */   call STR32(0, E, Loc(Addr(BITMSB)));   call ratio_multiply(50000,256);      /* get sector # to start     */   call unround;                        /* truncate down             */   call COPY32(Loc(Addr(BITMSB)), local.project.end);   call SHL32(local.project.end, 8);    /* get sample #              */end set.up.local.project;/* Handy routine to see if the cue sitting at scsi.ptr is in a certain *//* project                                                             */cue.in.local.project: proc(local.project.start, local.project.end) swapable;   dcl local.project.start     array;   dcl local.project.end       array;   dcl a(1) fixed;   write(mam) = scsi.ptr;   write(mal) = cue.in.s#.msb;   a(0) = read(mdi);   a(1) = read(mdi);   call ADD16(128,a);         /* round to sector boundary for */   a(1) = a(1) & "177400";    /* correct comparison           */   if (COM32(a, local.project.start) >= lw#ieq)   &  (COM32(a, local.project.end  ) <  lw#ieq)   then return true;   else return false;end cue.in.local.project;/* Handy routine to fetch file name from opticl disk index file record: */fetch.optical.name: proc (record, name) swapable;   dcl record array;                       /* handy routine to fetch    */   dcl name   array;                       /* optical disk index file   */   dcl i      fixed;                       /* name into xpl string      */   do i = 0 to l#name_max - 1;      name(1+i) = record(l$name+i);   end;   name(0) = shl(l#name_max, 1);           /* toss trailing nulls       */   do while (name(0) <> 0) & (byte(name, name(0) - 1) = 0);      name(0) = name(0) - 1;   end;   call pbyte(name, name(0), 0);           /* store trailing null for   */end fetch.optical.name;                    /* c string output           *//* Handy routine to look up name of basic device type:               */get.device.name.2: proc(index, name) swapable;   dcl index fixed;   dcl name  array;   name(0) = 0;                       /* initialize answer         */   do case (index);                   /* get name                  */      call COPY.STRING('Root Directory:',     name);      call COPY.STRING('System Catalog:',     name);      call COPY.STRING('Current Catalog:',    name);      call COPY.STRING('F0:',                 name);      call COPY.STRING('F1:',                 name);      call COPY.STRING('R0:',                 name);      call COPY.STRING('R1:',                 name);      call COPY.STRING('W0:',                 name);      call COPY.STRING('W1:',                 name);      do;         call COPY.STRING('O0:', name);         if Optical.Disk.Ready = 0         then call Mount.Optical.Volume;         if Optical.Disk.Ready <> 0         then do;            call APPEND.TO.STR(name, O$Volume_Name);            call APPEND.TO.STR(name, ':');         end;      end;      call COPY.STRING('Direct to Disk:',     name);      call COPY.STRING('Poly Ram:',           name);      call COPY.STRING('Timbres:',            name);   end;end get.device.name.2;/* Handy routine to get name of special DTD directory/file:        *//* Also returns data structure type.                               */get.dtd.name: proc(code, info, name) swapable;   dcl code           fixed;   dcl info           array;   dcl name           array;   name(0) = 0;   if code >= dtd_cues                      /* get name of cue             */   then do;      if fetch.dtd.cue.info (code - dtd_cues + 1, name)      then return T#Cue;      else return    -1;   end;   else if code >= dtd_projs                /* get name of project         */   then do;      if fetch.dtd.song.info(code - dtd_projs, info, name)      then return T#Dir;      else return    -1;   end;   else if code >= dtd_audio                /* get name of audio file      */   then do;      /*************/                       /* disabled for now            */      return -1;                            /* until lod code let's us     */      /************/                        /* read audio easily.          */      if code >= dtd_audio + 16             /* does not exist              */      then return -1;      if (dtd.avail.trks & bits(code - dtd_audio)) = 0      then return -1;                       /* track not avail             */      call COPY.STRING('Track ', name);      call CONV.FIXED.TO.STR(code - dtd_audio + 1, 0, 2,cf#append\cf#right, name);      call APPEND.TO.STR(name, ' Audio');      return T#Raw16Audio;   end;   else do case (code-1);      do;         call fetch.dtd.song.info(AEE.Current.Project, info, name);         call COPY.STRING('Current Project:', name);         return T#Dir;      end;      do;         call COPY.STRING('Project Info', name);         return T#DtdProj;      end;      do;         call COPY.STRING('Track Info', name);         return T#DtdTrackDir;      end;   end;   return (-1);end get.dtd.name;/* Handy routine to check type filter bits for DTD items: */check.dtd.type: proc (typebits, type) swapable;   dcl typebits fixed;   dcl type     fixed;   if (type     < ( 0)) then return FALSE; /* ignore bad types always        */   if (typebits = (-1)) then return TRUE;  /* return true of all types ok    */   if (type    >= 16  ) then return FALSE; /* return false if no bit defined */   return ((typebits&bits(type)) <> 0);    /* return true if bit is set      */end check.dtd.type;/* Handy routines to perform name comparisons: */check.match.code: proc(match, name, it) swapable;   dcl match fixed;                        /* name filter.  pass        */   dcl name  array;                        /* match code (0 = full,     */   dcl it    array;                        /* 1 = partial match OK      */   dcl saved fixed;   if it(0) = 0                            /* if null name, do no       */   then return TRUE;                       /* filter                    */   saved = name(0);                        /* save orinal name length   */   if (match = 1) and (name(0) > it(0))    /* if looking for partial,   */   then name(0) = it(0);                   /* then allow partial match  */   if EQSTR(it, name) = 0                  /* if bytes match up to      */   then do;                                /* correct limit, then OK    */      name(0) = saved;                     /* restore name length       */      return TRUE;   end;   name(0) = saved;                        /* restore name length       */   return FALSE;                           /* does not match            */end check.match.code;/* Even handier routine to compare name to device code name:            */check.match.code.to.device: proc(match, index, it) swapable;   dcl match fixed;   dcl index fixed;   dcl it    array;   dcl name(18) fixed;   if it(0) = 0                         /* if no name to match to, then */   then return TRUE;                    /* all names match              */   call get.device.name.2(index, name);   /* get name of this device      */   return check.match.code(match, name, it);end check.match.code.to.device;/* Device ids - able data structures are referenced by a 32-bit   *//* "data structure id".   The first byte identifies which device  *//* the data structure is on.  Some of these devices map directly  *//* the Able catalog structure 'level' concept.  For such devices, *//* the other three bytes are pointers into the catalog entries    *//* allowing access to files 3 levels deep.                        *//* The following routines are provided to manipulate data         *//* structure id's.  Returns true if a good id.                    */decode.dsid: proc(dsid, tree) swapable;  /* expand into tree      */   dcl dsid array;   dcl tree array;   dcl i    fixed;   call blockset(tree, 4, 0);            /* initialize to zero    */   tree(0) = shr(dsid(0), 8);            /* get first byte        */   if tree(0) = 0                        /* 0 first byte means    */   then do;                              /* root directory        */      if (dsid(0)\dsid(1)) = 0           /* make sure all bits    */      then return TRUE;                  /* are zero              */      else return FALSE;   end;      if (tree(0) < optical   )             /* check for devices     */   or (tree(0) = dtd_device)             /* or direct to disk     */   then do;                              /* if ABLE catalog       */      tree(1) = dsid(0) & 255;           /* structure device,     */      tree(2) = shr(dsid(1), 8);         /* then expand 3         */      tree(3) = dsid(1) & 255;           /* entry pointers        */      i = 1;                             /* find out how many     */      do while (i<4) & (tree(i)<>0);     /* levels are accessed.  */         i = i + 1;      end;      do while (i<4);                    /* make sure other       */         if tree(i) <> 0                 /* index pointers are    */         then return false;              /* zeroes.               */         i = i + 1;      end;      return true;  end;  if tree(0) < max_devices               /* check other devices   */  then do;     do i = 1 to 3;                      /* other devices have    */        if tree(i) <> 0                  /* only one level codes  */        then return false;               /* for now               */     end;     return true;  end;  return false;                          /* unknown               */end decode.dsid;encode.dsid: proc(tree, dsid) swapable;  /* expand into tree      */   dcl tree array;   dcl dsid array;   call blockset(dsid, 2, 0);            /* initialize to zero    */   if tree(0) = 0                        /* 0 first byte means    */   then return TRUE;                     /* pointer to root dir   */      if (tree(0) < optical   )             /* check for devices     */   or (tree(0) = dtd_device)             /* or dtd                */   then do;                              /* if ABLE catalog       */      dsid(0) = shl(tree(0),8) \ tree(1);      dsid(1) = shl(tree(2),8) \ tree(3);      return TRUE;   end;   dsid(0) = shl(tree(0), 8);             /* store pseudo device   */   return true;end encode.dsid;/* Special note:  There is no clearcut way to encode a pointer to  *//* a sound file in poly memory in a 32 bit number.  Sure, we could *//* store a pointer to the actual poly memory location of the SF,   *//* but that would be useless the next time poly memory was         *//* shuffled.  We could store the original device and sector of     *//* where the sound file came from, but that may fail for floppies  *//* and opticals.                                                   *//* Instead,  we will generate a 32 bit number by encoding          *//* the file name, length, device, and sector using random numbers. *//* Check it out...                                                 */encode.ram.addr:proc (len, dev, sec, name);   dcl (len, dev, sec) fixed;   dcl (name         ) array;   dcl (i            ) fixed;   dcl crnd data    (46827, 23922,  54168,  5986, 39886, 18635,  31555,  1298,    11532, 44794,  48026, 63648, 32951, 58239);   add_in: proc(val, ix);      dcl (val, ix) fixed;      load crnd(ix+ix); mul val;      bitmsb = bitmsb + ures;      bitlsb = bitlsb +  res;      if bitlsb ILT res then bitmsb = bitmsb + 1;      load crnd(ix+ix+1); mul val;      bitmsb = bitmsb + res;   end add_in;   bitmsb = 0; bitlsb = 1;       /* initialize to 1 */   call add_in(len, 0);   call add_in(dev, 1);   call add_in(sec, 2);   do i = 0 to f#name_len - 1;      call add_in(name(i), 3+i);   end;end encode.ram.addr;/* Routine to fetch a directory pointed to by a dsid.  Used        *//* to fetch directory information,  or to fetch directory          *//* entries.  For root directory,  num.of.entries will be # of      *//* entries in root directory, next.level will be 0.                *//* For able directories,  the actual directory will be read into   *//* the catalog buffer,  num.of.entries will be set, and next.level *//* will point to where in tree() the next index will be stored.    */dcl num.of.entries          fixed;dcl next.level              fixed;dcl local.project.start (1) fixed;dcl local.project.end   (1) fixed;fetch.dsid.directory: proc(dsid, tree, types, match, it, count_entries) swapable;   dcl dsid          array;   dcl tree          array;   dcl types         fixed;   dcl match         fixed;   dcl it            array;   dcl count_entries fixed;   dcl fcb_data   (f#len - 1) fixed;   dcl name       (18)        fixed;   dcl songinfo   (song.len)  fixed;   dcl level       fixed;   dcl i           fixed;   dcl j           fixed;   dcl (k,bin)     fixed;   dcl (temp.base) (1)        fixed;   dcl (ix       ) (1)        fixed;   dcl psd         lit '"157"';   Optical.Disk.Ready = 0;                 /* force mount.volume if we    */                                           /* access the optical          */   num.of.entries     = 0;                 /* initialize                  */   next.level         = 0;   if decode.dsid(dsid, tree) = FALSE      /* expand dsid.  quit now      */   then return ##.bad.id;                  /* if bad id                   */   /* Check for root directory */   if tree(0) = 0 then do;                 /* count entries in root       */      if count_entries = false             /* accessing root directory    */      then return ##.good;      if (types&bits(T#Dir)) = 0           /* if not looking for          */      then return ##.good;                 /* directories, no entries!    */      do i = 0 to 7;                       /* check ABLE devices          */         if  (find_device (i) <> 0)         and (check.match.code.to.device(match, i+1, it) <> 0)         then num.of.entries = num.of.entries + 1;      end;      if  (find_device(odev) <> 0)         /* check for O0:               */      and (check.match.code.to.device(match, optical, it) <> 0)      then num.of.entries = num.of.entries + 1;      if  (dtd.max.secs <> 0)              /* check dtd                  */      then do;         if check.match.code.to.device(match, dtd_device, it) <> 0         then num.of.entries = num.of.entries + 1;      end;      if  (polynums <> 0)                   /* check poly                 */      and (check.match.code.to.device(match, poly_ram, it) <> 0)      then num.of.entries = num.of.entries + 1;      if check.match.code.to.device(match, cur_timbres, it) <> 0      then num.of.entries = num.of.entries + 1;      return ##.good;   end;   /* Check for devices in root directory: */   if tree(0) < optical                    /* accessing device with       */   then do;                                /* able catalog structure      */      do while (next.level < 4)            /* see how many levels down    */      &        (tree(next.level) <> 0);    /* we need to go               */         next.level = next.level + 1;      end;      if read_catalog('', tree(0) - 1) = FALSE   /* read root device.  If */      then return ##.no.media;                   /* cannot, no media      */      /* Decend down catalog structure as needed */      do level = 1 to (next.level - 1);         if (get_fcb(tree(level) - 1, fcb_data))         &  ((fcb_data(f#ty) = T#Subc) or (fcb_data(f#ty) = T#LSubc))         &  (fcb_data(f#nm) <> 0)         then do;            call clean_fcbname(fcb_data, name);            if readdir(name) = FALSE            then return ##.bad.id;         end;         else return ##.bad.id;      end;      if count_entries = false             /* all set to go now if we     */      then return ##.good;                 /* don't need entry count      */      do i = 0 to c#dir_size/c#len - 1;         call get_fcb(i, fcb_data);         if (fcb_data(f#nm) <> 0)         &  (type.of(fcb_data(f#ty)) >= 0)         &  ((next.level < 4) \ (type.of(fcb_data(f#ty)) <> T#Dir))         &  ((types & bits(type.of(fcb_data(f#ty)))) <> 0)         then do;            call clean_fcbname(fcb_data, name);            if (fcb_data(f#ty) = T#Subc)         /* add colon to name */            or (fcb_data(f#ty) = T#LSubc)        /* if is a directory */            then call append.to.str(name, ':');            if check.match.code(match, name, it) <> 0            then num.of.entries = num.of.entries + 1;         end;      end;      return ##.good;   end;   /* Check for pseudo devices:            */   if tree(0) = optical                    /* accessing optical disk      */   then do;      S$SenseKey = 0;      C#Status   = 0;      if (mount.optical.volume = 0)        /* mount it; get info          */      then do;         if S$SenseKey <> 0         then return (##.scsi.error   + (S$SenseKey & 255));         else return (##.able.cat.err + (C#Status   & 255));      end;      if count_entries = false             /* all set to go now if we     */      then return ##.good;                 /* don't need entry count      */      if (types = (-1))                    /* if looking for all types    */      &  (it(0) = ( 0))                    /* with no name filter, assume */      then do;                             /* all files on the optical    */         num.of.entries = I$FileCount;     /* should be counted.          */         return ##.good;                   /* otherwise, optical takes    */      end;                                 /* for EVER !!!!!              */      call seek(FileList, I$FileStart, 3);      i = 0;      do while i <> I$FileCount;           /* check files on optical      */         call fread(copy.buf, L#Rec_Length, 2, FileList);         call fetch.optical.name(copy.buf, name);         if (name(0) <> 0)                 /* if name exists              */         &  (type.of(copy.buf(L$File_Type)) >= 0)         &  ((types & bits(type.of(copy.buf(L$File_Type)))) <> 0)         &  (check.match.code(match, name, it) <> 0)         then num.of.entries = num.of.entries + 1;         i = i + 1;      end;      return ##.good;   end;   if tree(0) = dtd_device                 /* accessing direct to disk    */   then do;      do while (next.level < 4)            /* see how many levels down    */      &        (tree(next.level) <> 0);    /* we need to go               */         next.level = next.level + 1;      end;      if dtd.max.secs = 0                  /* if no dtd                   */      then return ##.no.media;             /* cannot, no media            */      /* Count projects in Direct to Disk directory:                      */      if next.level = 1                    /* accesing Direct to Disk     */      then do;         if (types & bits(T#Dir)) = 0      /* no need to count if not     */         then return ##.good;              /* looking for directories     */         call get.dtd.name(dtd_cp, songinfo, name);         if  (check.match.code(match, name, it) <> 0)         then num.of.entries = num.of.entries + 1;         do i = dtd_projs to dtd_projs + num.dtd.projs - 1;            if (get.dtd.name(i, songinfo, name) = T#Dir)            &  (check.match.code(match, name, it))            then num.of.entries = num.of.entries + 1;         end;         return ##.good;      end;      if next.level = 2                    /* accessing a project         */      then do;         if tree(1) = dtd_cp               /* accessing Current Project:  */         then do;            if count_entries = false    /* accessing something in          */            then return ##.good;        /* Direct to Disk:Current Project: */            do i = dtd_pd to dtd_audio + 15;              /* check proj   */               j = get.dtd.name(i, songinfo, name);       /* dir, track   */               if (check.dtd.type(types, j))               &  (check.match.code(match, name, it))               then num.of.entries = num.of.entries + 1;            end;            /* Check cues as well:                                        */            call FETCH.DTD.SYSTEM.INFO;    /* get # of cues up to date    */            call SET.DTD.SCROLL.RANGE(1);  /* current project only        */            do i = 0 to dtd.cp.cues - 1;   /* check each cue              */               j = FETCH.NTH.ALPHA.DTD.CUE(i);    /* get id               */               if j <> 0 then do;                  j = get.dtd.name(dtd_cues + j - 1, songinfo, name);                  if (check.dtd.type(types, j))                  &  (check.match.code(match, name, it))                  then num.of.entries = num.of.entries + 1;               end;            end;            return ##.good;         end;         /* See if accessing a project as a directory                     */         else if (tree(1) >= dtd_projs) & (tree(1) < dtd_cues)         then do;            if get.dtd.name(tree(1), songinfo, name) <> T#Dir            then return ##.bad.id;            call set.up.local.project(songinfo, local.project.start, local.project.end);            if count_entries = false   /* accessing something in          */            then return ##.good;       /* Direct to Disk:Dog Project:     */            j = get.dtd.name(dtd_pd, songinfo, name);  /* see if user     */            if (check.dtd.type(types, j))              /* wants to see    */            &  (check.match.code(match, name, it))     /* Project Info    */            then num.of.entries = num.of.entries + 1;            /* Check ques as well:                                        */            call FETCH.DTD.SYSTEM.INFO;    /* get # of cues up to date    */            call SET.DTD.SCROLL.RANGE(0);  /* all projects here           */            do i = 0 to dtd.num.cues - 1;  /* check each cue              */               j = FETCH.NTH.ALPHA.DTD.CUE(i);    /* get id               */               if j <> 0 then do;                  j = get.dtd.name(dtd_cues + j - 1, songinfo, name);                  if (check.dtd.type(types, j))                  &  (check.match.code(match, name, it))                  &  (cue.in.local.project(local.project.start, local.project.end))                  then num.of.entries = num.of.entries + 1;               end;            end;            return ##.good;         end;         else return ##.bad.id;            /* not a dtd directory         */      end;      else return ##.bad.id;               /* else bad dir id             */   end;   /* Count number of sound files in poly memory:                         */   if tree(0) = poly_ram                   /* accessing sound files       */   then do;                                /* stored in poly RAM          */      if polynums = 0                      /* check poly                  */      then return ##.good;                 /* no entries if no poly       */      if count_entries = false             /* all set to go now if we     */      then return ##.good;                 /* don't need entry count      */      do bin = 0 to polynums - 1;          /* look in each poly bin       */         call set.cur.bin(bin);            /* point at current in         */         call copy32(psfirst, ix);         /* start at first block        */         do while com32(ix, pslast) <> lw#ieq;   /* look at each block    */            call copy32(ix, temp.base);    /* get working copy            */            temp.base(0) = temp.base(0) \ shl(bin,base#bin_p);            call psmread(temp.base, 0, 0); /* set up for read             */            j = read(psd);                 /* get block length in sectors */            k = read(psd);                 /* get and ignore users        */            do i = 0 to f#name_len - 1;    /* get file name               */               fcb_data(f#nm + i) = read(psd);            end;            if (fcb_data(f#nm) <> 0)       /* ignore empty blocks...      */            &  (fcb_data(f#nm) <> 1)       /* ignore sound file cache     */            then do;               call clean_fcbname(fcb_data, name);               if (name(0) <> 0)           /* if name exists              */               &  ((types & bits(type.of(t#sound))) <> 0)               &  (check.match.code(match, name, it) <> 0)               then num.of.entries = num.of.entries + 1;            end;            call add16(j, ix);             /* skip over this block        */         end;                              /* of loop through bin         */      end;                                 /* of loop over bin            */      return ##.good;                      /* done                        */   end;   /* xxxx - timbres, others */   return ##.bad.id;end fetch.dsid.directory;/* routines to fetch & send directory information */Send.Directory.Info: proc (des, tag, dsid, entries, revision, status) swapable;   dcl des       fixed;   /* destination node                            */   dcl tag       fixed;   /* message tag #                               */   dcl dsid      array;   /* directory id                                */   dcl entries   fixed;   dcl revision  fixed;   dcl status    fixed;   /* status word to return                       */   write(mam) = misc.ptr;      write(mdi) = L#Directory_Info;   write(mdi) = des;   write(mdi) = T#Directory_Info;   write(mdi) = tag;             /* word: message tag                    */   write(mdi) = dsid(0);   write(mdi) = dsid(1);   write(mdi) = 0;               /* long: # of entries                   */   write(mdi) = entries;   write(mdi) = 0;               /* long: revision # (date code?)        */   write(mdi) = revision;   write(mdi) = status;          /* 0 = good; 1 = bad id; 3 = no media   */   return Send.Protocol.Packet.With.Retry(misc.ptr, 1, 10000);end Send.Directory.Info;Request.Directory.Info: proc (packet,des) swapable;   dcl packet     array;   dcl des        fixed;   dcl tag        fixed;   dcl dsid(1)    fixed;   dcl types      fixed;   dcl match      fixed;   dcl it(18)     fixed;   dcl tree(3)    fixed;   dcl revision   fixed;   dcl status     fixed;   dcl i          fixed;   tag     = packet(0);             /* get tag                        */   dsid(0) = packet(1);   dsid(1) = packet(2);   types   = packet(4);             /* type matching bits             */   match   = packet(5);             /* match code                     */   do i = 1 to 17;      it(i) = rot(packet(5+i),8);   end;   if types = 0                     /* type filter of 0 means get     */   then types = (-1);               /* all types                      */   do while byte(it, it(0)) <> 0;   /* get name match in ABLE format  */      it(0) = it(0) + 1;   end;   call pbyte(it, it(0)+1, 0);      /* zero out upper half (maybe)    */   status = fetch.dsid.directory(dsid, tree, types, match, it, true);   if (tree(0) = optical)           /* for optical disk, use actual   */   and (optical.disk.ready <> 0)    /* # of entries on disk as the    */   then revision = O$EntryCount;    /* revision #                     */   return Send.Directory.Info(des, tag, dsid, num.of.entries, revision, status);end Request.Directory.Info;/* $page - Routine to fetch directory entries: */Request.Directory.Entries: proc (packet,des) swapable;   dcl packet     array;   dcl des        fixed;   dcl tag        fixed;   dcl dsid(1)    fixed;   dcl entry      fixed;   dcl number     fixed;   dcl maxlen     fixed;   dcl types      fixed;   dcl match      fixed;   dcl it(18)     fixed;   dcl tree(3)    fixed;   dcl newt(3)    fixed;   dcl newd(1)    fixed;   dcl status     fixed;   dcl i          fixed;   dcl j          fixed;   dcl k          fixed;   dcl pointer    fixed;   dcl entrysize  fixed;   dcl totalsize  fixed;   dcl datasize   fixed;   dcl useblock   fixed;   dcl actual     fixed;   dcl index      fixed;   dcl idmsb      fixed;   dcl idptr      fixed;   dcl counter    fixed;   dcl exists     fixed;   dcl fcb_data   (f#len - 1) fixed;   dcl name(19)   fixed;   dcl songinfo   (song.len)  fixed;   dcl type       fixed;   dcl lengthmsb  fixed;   dcl lengthlsb  fixed;   dcl revision   fixed;   dcl a(1)       fixed;   dcl (l,bin)    fixed;   dcl (temp.base) (1)        fixed;   dcl (ix       ) (1)        fixed;   dcl psd         lit '"157"';   tag     = packet(0);             /* get tag                        */   dsid(0) = packet(1);             /* get data structure id          */   dsid(1) = packet(2);   entry   = packet(4);             /* starting entry                 */   number  = packet(6);             /* number of entries              */   maxlen  = packet(7);             /* max name length in bytes       */                                    /* including C-string null        */   types   = packet(9);             /* type matching bits             */   match   = packet(10);            /* match code                     */   do i = 1 to 17;      it(i) = rot(packet(10+i),8);   end;   if types = 0                     /* type filter of 0 means get     */   then types = (-1);               /* all types                      */   do while byte(it, it(0)) <> 0;   /* get name match in ABLE format  */      it(0) = it(0) + 1;   end;   call pbyte(it, it(0)+1, 0);      /* zero out upper half (maybe)    */   status = fetch.dsid.directory(dsid, tree, types, match, it, true);   if status = ##.good then do;     /* if good directory id ...       */      if entry < num.of.entries     /* see if asking for good entry   */      then do;         if (entry + number) > num.of.entries   /* if asking for more than   */         then number = num.of.entries - entry;  /* available, limit it       */      end;      else do;         status = ##.bad.entry.#;   /* else bad entry #               */         number = 0;                /* send back no entries           */      end;   end;   else number = 0;                 /* cannot return data if bad id   */   /* Construct reply message (s) */   if maxlen then maxlen = maxlen + 1;  /* round up to boundary       */   if maxlen IGT 34                     /* limit to 34 bytes so       */   then maxlen = 34;                    /* info fits in block         */   if maxlen   = 0                      /* always send at least       */   then maxlen = 2;                     /* a trailing null!!          */   entrysize = 14 + maxlen;             /* bytes in entry             */   totalsize = 18 + number * entrysize; /* bytes of response          */   write(mam) = misc.ptr;               /* set up ext mem block       */   write(mdi) = 0;                      /* length - set later         */   write(mdi) = des;                    /* set destination            */   if totalsize IGT 60 then do;         /* begin blocking if need to  */      useblock   = 1;                   /* use blocking               */      write(mdi) = T#Net_Block \ T#Net_Block_Start;      write(mdi) = tag;                 /* tag for block transfer     */      write(mdi) = totalsize + 2;       /* data bytes for blocks      */   end;                                 /* plus suptype/subtype       */   write(mdi) = T#Directory_Entries;   write(mdi) = tag;                      /* word: tag                */   write(mdi) = dsid(0);                  /* long: directory id       */   write(mdi) = dsid(1);   write(mdi) = 0;                        /* long: entry #            */   write(mdi) = entry;   write(mdi) = 0;                        /* long: number of entries  */   write(mdi) = number;   write(mdi) = maxlen;                   /* word: max name len       */   write(mdi) = status;                   /* 0 = good; 1 = bad dir id; 2 = bad entry # */   datasize = 18;                         /* 18 data bytes so far     */   if (useblock) or (number = 0)          /* send header here if multi block */   then do;                               /* transfer, or no information     */      pointer = read(mal);      write(mal) = P#Len;      write(md ) = shl(pointer,1);      call SEND.PROTOCOL.PACKET.WITH.RETRY(misc.ptr, 1, 10000);      if number = 0                       /* done if no entries avail */      then return 1;      write(mam) = misc.ptr;      write(mal) = P#Type;      write(mdi) = T#Net_Block;         /* continuation block         */      write(mdi) = tag;                 /* tag for block transfer     */      write(mdi) = 0;                   /* reserved                   */      datasize   = 0;                   /* reset data size for next   */   end;   /* Send entry information: */   counter = 0;   index   = 0;   actual  = 0;   idmsb   = 0;   idptr   = 0;   /* Perform several optimizations for the optical.  Quickly seek to    */   /* correct position in file list if we are asking for all files.      */   if (number <> 0) & (tree(0) = optical)   then do;      if (types = (-1))                    /* if looking for all types    */      &  (it(0) = ( 0))                    /* with no name filter, assume */      then do;                             /* all files on the optical    */         actual = entry;                   /* are desired.  Quickly       */         index  = entry;                   /* jump to this entry.         */         a(0)   = 0;                       /* get index # into file list  */         a(1)   = entry;         call SHL32(a, 6);                 /* get sector and word         */         i = a(1) & 255;                   /* get words                   */         call SHR32(a, 8);                 /* get sectors                 */         call seek(FileList, I$FileStart + a(1), 3);         call seek(FileList, shl(i, 1), 1);      end;      else do;                                 /* else must set up for    */         call seek(FileList, I$FileStart, 3);  /* complete search of      */      end;                                     /* index file              */   end;   if tree(0) = poly_ram                       /* set up for loop         */   then do;                                    /* through poly ram        */      bin = 0;                                 /* start with bin 0        */      call set.cur.bin(bin);                   /* point to it             */      call copy32(psfirst, ix);                /* point to first blk      */   end;   do while (counter < number);         /* send back needed info         */      pointer = read(mal);              /* save ext mem pointer          */      do while actual <= entry + counter;      /* find desired entry     */         /* Get info for root directory: */         lengthmsb = 0;                  /* assume length will be 0      */         lengthlsb = 0;         revision  = 0;         if tree(0) = 0 then do;               /* construct root dir     */            exists = 0;                        /* scan for devices       */            do while (exists = 0);             /* find next device       */               index = index + 1;              /* compute & advance      */               idptr = index;                  /* that is id pointer     */               if index < optical              /* see if device exists   */               then exists = find_device(index - 1);               else do case (index - optical);                  exists = find_device(odev);         /* optical         */                  exists = dtd.max.secs;              /* direct to disk  */                  exists = polynums;                  /* poly            */                  exists = 1;                         /* timbres         */               end;               if exists <> 0 then do;                  call get.device.name.2(index, name);                  if check.match.code(match, name, it) = 0                  then exists = 0;                  else do;                     lengthlsb = 0;          /* assume length is 0 */                     do case (index - 1);                        lengthlsb = shl(core(loc.sctl), 1); /* system cat  */                        lengthlsb = shl(core(loc.uctl), 1); /* user   cat  */                        lengthlsb = 512;                    /* f0          */                        lengthlsb = 512;                    /* f1          */                        lengthlsb = 512;                    /* r0          */                        lengthlsb = 512;                    /* r1          */                        lengthlsb = 2048;                   /* w0          */                        lengthlsb = 2048;                   /* w1          */                        do;                                 /* O0          */                           lengthlsb = shl(H#Rec_Length, 1);                           if Optical.Disk.Ready                           then revision = O$EntryCount;                        end;                        lengthlsb = 0;                      /* dtd         */                        lengthlsb = 0;                      /* ram         */                        ;   /* xxxx */                      /* timbres     */                     end;                  end;               end;            end;            type      = T#Dir;        /* all items in root directory are  */         end;         /* Get info for devices in root directory or their subcatalogs */         else if tree(0) < optical         then do;            call get_fcb      (index, fcb_data);            call clean_fcbname(fcb_data, name );            if fcb_data(f#nm) <> 0 then do;               if (fcb_data(f#ty) = T#Subc)         /* add colon to name */               or (fcb_data(f#ty) = T#LSubc)        /* if is a directory */               then call append.to.str(name, ':');            end;            do while (fcb_data(f#nm) = 0)            or       (type.of(fcb_data(f#ty)) < 0)            or       ((next.level >= 4) & (type.of(fcb_data(f#ty)) = T#Dir))            or       ((types & bits(type.of(fcb_data(f#ty)))) = 0)            or       (check.match.code(match, name, it) = 0);               index = index + 1;               call get_fcb      (index, fcb_data);               call clean_fcbname(fcb_data, name );               if fcb_data(f#nm) <> 0 then do;                  if (fcb_data(f#ty) = T#Subc)         /* add colon to name */                  or (fcb_data(f#ty) = T#LSubc)        /* if is a directory */                  then call append.to.str(name, ':');               end;            end;            index     = index + 1; /* create pointer & advance it */            idptr     = index;     /* that is id pointer          */            type      = type.of(fcb_data(f#ty));            if fcb_data(f#ty) = T#Subc            then lengthlsb = 512;            else if fcb_data(f#ty) = T#LSubc            then lengthlsb = 2048;            else do;               lengthmsb = shl(fcb_data(f#ml),9) \ shr(fcb_data(f#ll),7);               lengthlsb = shl(fcb_data(f#ll),9);               if (fcb_data(f#wd)&255) <> 0         /* if not event sectors */               then call SUB16(512 - shl(fcb_data(f#wd)&255, 1),                               loc(addr(lengthmsb)));            end;         end;         /* Get information for optical disk: */         else if tree(0) = optical         then do;            call fread(copy.buf, L#Rec_Length, 2, FileList);            call fetch.optical.name(copy.buf, name);            if (types <> (-1))           /* if performing type filter      */            or (it(0) <> ( 0))           /* or name filter                 */            then do while (name(0) = 0)  /* then find next entry           */            or            (type.of(copy.buf(L$File_Type)) < 0)            or            ((types & bits(type.of(copy.buf(L$File_Type)))) = 0)            or            (check.match.code(match, name, it) = 0);               index = index + 1;               call fread(copy.buf, L#Rec_Length, 2, FileList);               call fetch.optical.name(copy.buf, name);            end;            index     = index + 1; /* create pointer & advance it */            idptr     = index;     /* that is id pointer          */            type      = type.of(copy.buf(L$File_Type));            if type < 0 then type = T#Unk;            revision  = copy.buf(L$Dir_Entry);            lengthmsb = shl(copy.buf(L$MS_SecLen), 9)                      \ shr(copy.buf(L$LS_SecLen), 7);            lengthlsb = shl(copy.buf(L$LS_SecLen), 9);         end;         /* Handle accessing the Direct to Disk */         else if tree(0) = dtd_device         then do;            if tree(1) = 0                     /* check for entries       */            then do;                           /* in "Direct to Disk:"    */               j = get.dtd.name(index + 1, songinfo, name);               do while (j <> T#Dir)               or       (check.match.code(match, name, it) = 0);                  index = index + 1;                  j = get.dtd.name(index + 1, songinfo, name);               end;               index     = index + 1; /* create pointer & advance it */               idptr     = index;     /* that is id pointer          */               type      = T#Dir;               lengthlsb = shl(song.len, 1);            end;            else if tree(1) = dtd_cp       /* accessing Current Project:  */            then do;               next.cp.index:;             /* re-enter                    */               j = (-1);                   /* assume entry not found      */               lengthmsb = 0;              /* and length is 0             */               lengthlsb = 0;               if (index >= (dtd_pd        ))      /* check proj dir,     */               &  (index <= (dtd_audio + 15))      /* track dir, audios   */               then do;                  j     = get.dtd.name(index, songinfo, name);                  idptr = index;                  if j = T#DtdProj                  then lengthlsb = shl(song.len, 1);                  else if j = T#DtdTrackDir                  then lengthlsb = 512;                  else if j = T#Raw16Audio                  then do;                     call SUB32(AEE.Current.Project.End,   /* get length */                                AEE.Current.Project.Base,  /* in samples */                                loc(addr(lengthmsb)));                     call SHL32(loc(addr(lengthmsb)), 1);                  end;               end;               else if index >= dtd_cues               then do;                  k = FETCH.NTH.ALPHA.DTD.CUE(index - dtd_cues);    /* get id               */                  if k <> 0 then do;                     j     = get.dtd.name(dtd_cues + k - 1, songinfo, name);                     idptr = dtd_cues + k - 1;    /* store id #       */                     write(mam) = scsi.ptr;       /* get cue.rlen     */                     lengthlsb = shl(read(md), 1);                  end;               end;               if  (check.dtd.type  (types, j       ) = FALSE)               or  (check.match.code(match, name, it) = FALSE)               then do;                  index = index + 1;                  goto next.cp.index;               end;               index = index + 1;          /* advance index pointer       */               type  = j;                  /* set file type               */            end;            /* Check if accessing a project directly:                     */            else do;                       /* else must be project        */               next.pr.index:;             /* re-enter                    */               j = (-1);                   /* assume entry not found      */               lengthmsb = 0;              /* and length is 0             */               lengthlsb = 0;               if index = dtd_pd           /* check for project           */               then do;                    /* info file in project        */                  j     = get.dtd.name(index, songinfo, name);                  idptr = index;                  lengthlsb = shl(song.len, 1);               end;               else if index >= dtd_cues   /* check all cues              */               then do;                  k = FETCH.NTH.ALPHA.DTD.CUE(index - dtd_cues);    /* get id               */                  if k <> 0 then do;                     j     = get.dtd.name(dtd_cues + k - 1, songinfo, name);                     idptr = dtd_cues + k - 1;    /* store id #       */                     write(mam) = scsi.ptr;       /* get cue.rlen     */                     lengthlsb = shl(read(md), 1);                     if (cue.in.local.project(local.project.start, local.project.end) = false)                     then j = (-1);                  end;               end;               if (check.dtd.type  (types, j       ) = FALSE)               or (check.match.code(match, name, it) = FALSE)               then do;                  index = index + 1;                  goto next.pr.index;               end;               index = index + 1;          /* advance index pointer   */               type  = j;                  /* set file type           */            end;         end;         /* Advance pointer through poly memory:                      */         else if tree(0) = poly_ram         then do;            next.ram.sf:;            do while com32(ix, pslast) = lw#ieq;  /* move on to next bin */               bin = bin + 1;               call set.cur.bin(bin);               call copy32(psfirst, ix);            end;            call copy32(ix, temp.base);          /* get working copy     */            temp.base(0) = temp.base(0) \ shl(bin,base#bin_p);            call psmread(temp.base, 0, 0);       /* set up for read      */            j = read(psd);                /* get block length in sectors */            k = read(psd);                /* get and ignore users        */            do i = 0 to f#name_len - 1;   /* get file name               */               fcb_data(f#nm + i) = read(psd);            end;            k = read(psd); /* bl.dev  */  /* get original device and     */            l = read(psd); /* bl.sec  */  /* sector to locate file       */            if (fcb_data(f#nm) = 0)       /* ignore empty blocks...      */            \  (fcb_data(f#nm) = 1)       /* ignore sound file cache     */            then do;               index = index + 1;         /* advance index (why not?)    */               call add16(j, ix);         /* skip over this block        */               goto next.ram.sf;            end;            call clean_fcbname(fcb_data, name);            if (name(0) = 0)              /* if no name                  */            \  ((types & bits(type.of(t#sound))) = 0)            \  (check.match.code(match, name, it) = 0)            then do;               index = index + 1;         /* advance index (why not?)    */               call add16(j, ix);         /* skip over this block        */               goto next.ram.sf;            end;            index     = index + 1;        /* advance (unused) index      */            call add16(j, ix);            /* skip over this block        */            call encode.ram.addr(j, k, l, loc(addr(fcb_data(f#nm))));            idmsb     = bitmsb;           /* save encoded info to find   */            idptr     = bitlsb;           /* the sound file again        */            type      = type.of(t#sound); /* and save type               */            lengthlsb = shl(j-1, 9);      /* get lsb length in bytes     */            lengthmsb = shr(j-1, 7);      /* get msb length in bytes     */         end;                             /* ignoring base sector        */         /* Handle other devices */         else do;            /* handle other devices here - if any! */         end;         actual = actual + 1;               /* count actual entry found */      end;      if type = T#Dir                       /* for directories, create  */      then do;                              /* complete dsid            */         call blockmove(tree, newt, 4);     /* construct new tree name  */         newt(next.level) = idptr;          /* store pointer            */         call encode.dsid(newt, newd);      /* get as dsid              */      end;      else do;                              /* else just store pointer  */         newd(0) = idmsb; newd(1) = idptr;  /* to this non-directory    */      end;                                  /* structure.               */      write(mam) = misc.ptr;                /* reset xmem pointers      */      write(mal) = pointer;      write(mdi) = newd(0);      write(mdi) = newd(1);      write(mdi) = lengthmsb;       /* long: length                     */      write(mdi) = lengthlsb;      write(mdi) = 0;      write(mdi) = revision;      write(mdi) = type;            /* word: type                       */      if name(0) > (maxlen-1)       /* limit name to extracted bytes    */      then name(0) = (maxlen-1);      call pbyte(name, name(0),   0);  /* convert to C string           */      call pbyte(name, name(0)+1, 0);      do i = 0 to shr(name(0), 1);         write(mdi) = rot(name(i+1),8);      end;      do i = shr(name(0) + 2 ,1) to shr(maxlen,1)-1;         write(mdi) = 0;      end;      datasize = datasize + entrysize; /* count data bytes written    */      counter = counter + 1;           /* count entries sent          */      /* Force buffer out over protocol if needed:                    */      if (counter = number)            /* if sending last one         */      or ((datasize + entrysize) > 60) /* or no room for another one  */      then do;         pointer = read(mal);         write(mal) = P#Len;         write(md ) = shl(pointer,1);         if (useblock) & (counter = number)  /* set end of block bit for */         then do;                            /* last block               */            write(mal) = P#Type;            write(md ) = read(md) \ T#Net_Block_Last;         end;         call SEND.PROTOCOL.PACKET.WITH.RETRY(misc.ptr, 1, 10000);         write(mam) = misc.ptr;    /* set up for write of more */         write(mal) = P#Data + 2;  /* data                     */         datasize   = 0;      end;   end;   return 1;end Request.Directory.Entries;