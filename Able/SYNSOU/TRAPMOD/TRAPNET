/* TRAPNET  $TITLE  ROUTINES TO PROCESS NETWORK PACKETS   Modified:   07/30/91 - MWH - File transfer on sector boundaries doesn't allocate extra   02/28/91 - MWH - Add text type to MAC->ABLE file transfer   09/10/90 - MWH - Add ability to name MAC->ABLE xfr'd file from the MAC   05/24/90 - MWH - Add file transfer support (for internal MAC->ABLE xfr)   09/20/89 - PF - Do not re-init MIDInet whenever Mac appears on DAWN   08/24/89 - MWH - Rework the protocol for release 2.2   07/28/89 - CJ/PF - init midi subsystem for both MAC sign-on and                      MIDI-net signon.   06/29/89 - MWH - Add Relay Data packet   06/15/89 - PF  - Added call to INIT.MIDI.SUBSYSTEMS in PROCESS.HERE.IS   06/01/89 - MWH - Log message when new devices come up (first "here-is")   05/04/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/14/89 - PF  - changed process packet processing logic   01/25/89 - MWH - Add download of 68000 code to Remote Box   11/10/88 - MWH - Author*/dcl Block.Tag    fixed public;dcl Block.Len    fixed public;dcl Block.MAM    fixed public;dcl Block.MAL    fixed public;dcl Block.Busy   fixed public;dcl saved_node_id   fixed;/* Process crash/download request from a remote device *//* Note that the first crash message is also treated as a "here-is" */Process.Here.Is: proc (packet,des) swapable;   dcl packet  array;  /* Procotol packet data */   dcl des     fixed;  /* Board and channel number (on here-is only) */   dcl board   fixed;  /* Board number which sent the here-is */   dcl channel fixed;  /* Channel number on the board */   dcl node_id fixed;  /* Which device is connected to the channel now */   dcl device  fixed;  /* Device number for debugging print */   dcl ptr     fixed;  /* Pointer into the d115 channel arrays */   dcl i       fixed;   dcl init.midi.subsystems proc external;   /* Fetch our parameters */   board   = shr(des,8);   channel = des & "377";   node_id = shr(packet(0),8);   ptr     = shl(board,1) + channel;   if d115d.chans(ptr) = node_id  /* If same value, then the same device is still on this channel */   OR board   < 0                 /* Also, check for valid arguments... */   OR board   > 3                 /* ...before zapping the array! */   OR channel < 0   OR channel > 1   then do;      return(TRUE);    /* We have nothing more to do */   end;   /* If here, this is either a new device, or one just moved to this channel */   do i=0 to (shl(num.d115d.bds,1) - 1);      if d115d.chans(i) = node_id      then d115d.chans(i) = 0;   /* Remove this device from any previous channel */   end;   d115d.chans(ptr) = node_id;   /* Add device to the table where we found it connected */   /* Re-initialize monster midi system when monster midi */   /* signs on:                                           */   if node_id = nn#midi             /* this device is MIDInet */   then call init.midi.subsystems;  /* init MIDI stuff        */   if  (inc.trap.dbug)                        /* if debug included      */   and ((Allow.Proto.Msgs & "7") >= 1)        /* At least brief logging */   then do;      call cpos(23,0);                        /* Move to bottom line of screen */      if (Allow.Proto.Msgs & "7") = 1         /* Brief */      then do;                                /* Erase it */         call pc(27); call ps('[K');      end;      else call pcr;                          /* Or get a new line */      call ps('[NEW_DEV]');      call ps(' Board = ');     call pnum(board,0);      call ps(', Chan = ');     call pnum(channel,0);      call ps(', Node = ');     call pnum(node_id,0);      device = shr(node_id & NN#Dev_Mask,4);    /* Get the remote device type */      do case device;         ;                            /* 0 = Able (we don't receive from!) */         call ps(', (MAC)');          /* 1 = MAC */         call ps(', (DESC)');         /* 2 = Remote Box */         call ps(', (MIDI)');         /* 3 = Monster MIDI */      end;      if (Allow.Proto.Msgs & "7") >= 2 then do;  /* Full dump of output packet */         call pcr;      end;   end;   return(TRUE);end Process.Here.Is;Process.Relay.Data: proc(packet,len) swapable;   dcl packet  array;  /* Procotol packet data */   dcl len     fixed;  /* Byte length of the original message */   dcl wlen    fixed;  /* Word length of the original message */   wlen = shr(len+1,1);   write(MAM) = Packet.Ptr;                   /* Get the original packet */   call copy.in(addr(misc.buf(0)),wlen);   misc.buf(P#Source) = shr(packet(0),8);     /* Change the destination to where we are relaying this to */   write(mam) = misc.ptr;                     /* Write it out as modified */   call copy.out(addr(misc.buf(0)),wlen);   return(Send.Protocol.Packet(misc.ptr,1));  /* Relay the packet */end Process.Relay.Data;Process.Crash.1: proc(packet,des) swapable;   dcl packet  array;  /* Procotol packet data */   dcl des     fixed;  /* Board and channel number (on here-is only) */   saved_node_id = shr(packet(0),8);   /* Save the node id for when the second crash message comes */   call Process.Here.Is(packet,des);   /* This MIGHT be the first we hear from this device! */   return(TRUE);end Process.Crash.1;Process.Crash.2: proc swapable;   return (D115.Download(saved_node_id));end Process.Crash.2;/* $Subtitle Routines to handle quick file create/receive on the Able */dcl receive.xmem     fixed;     /* Sector buffer of external memory */dcl receive.mal      fixed;dcl f#m              fixed;     /* Where we are writing to the file */dcl f#l              fixed;dcl f#m.end          fixed;     /* First illegal sector past EOF */dcl f#l.end          fixed;dcl rcv_name(20)     fixed;     /* Store file name string here */dcl rcv_text         fixed;     /* Set to 1 if receiving a text file */dcl line#            fixed;dcl dest             fixed;Process.Receive.File: proc (packet,len) swapable;   dcl packet   array;  /* Procotol packet data */   dcl len      fixed;   dcl sect.msb fixed;   dcl sect.lsb fixed;   dcl words    fixed;   dcl type     fixed;   dcl j        fixed;   dcl trk  lit '178';  /* MAC stores filename to create in trackname #177 */   dcl big.trouble proc external;   /* Add one byte since we're converting to WORDS */   call add16(1,packet);   if (len > Able_Packet_Head + 2 + 4)  /* Old versions didn't have text option */   then do;      rcv_text = packet(2);      call C.To.Able.String(rcv_name,loc(addr(packet(3))),0);   end;   else do;      rcv_text = 0;   end;   /* Convert byte length to sectors & words */   call sub16(2,packet);  /* Make word range 0-255, not 1-256 */   sect.msb = shr(packet(lw#msb),9);   sect.lsb = shl(packet(lw#msb),7) | shr(packet(lw#lsb),9);   sect.lsb = sect.lsb + 1;         /* Add an extra sector for trailing words */   if sect.lsb = 0 then sect.msb = sect.msb + 1;   call add16(2,packet);  /* Restore original length */   words = shr(packet(lw#lsb),1);   if (packet(lw#msb) & 1) <> 0   then packet(lw#lsb) = packet(lw#lsb) | "100000";   /* If we created the file, allocate a buffer used to build it */   call cpos(22,0);             /* Move to next to bottom line of screen */   call pc(27);                 /* Escape */   if (rcv_text = 1) then do;      type = T#Text;      /* Add to the length of the file to allow for line numbers, etc. */      j = shr(sect.lsb,3);      j = j + 1;                                /* Round up one sector */      sect.lsb = sect.lsb + j;      if sect.lsb ILT j then sect.msb = sect.msb + 1;      if (sect.msb <> 0) OR (sect.lsb > 255) then do;         f#m = 0;         f#l = 0;         rcv_text = 0;         call ps('[KText file is too large:');         call ps(rcv_name);         call big.trouble;       /* This will send a PE_ERR_MESSAGE event to the MAC */         return(TRUE);      end;      words = 0;                 /* Let FILEIO set the word size */      line# = 1;                 /* Initialize line number counter */   end;   else do;      type = T#Data;   end;   if (replace(rcv_name,type,sect.msb,sect.lsb,words,1)) then do;      if (receive.xmem = 0) then receive.xmem = alloc.examount(2);      f#m = F#MS_Sector;  /* The replace worked, remember where the file is */      f#l = F#LS_Sector;      f#m.end = f#m + sect.msb;      f#l.end = f#l + sect.lsb;      if f#l.end ilt f#l then f#m.end = f#m.end + 1;      receive.mal = 0;      call ps('[KCreating ');      if (rcv_text = 1) then call ps('text ');      call ps('file: ');      call ps(rcv_name);      call ps('...');      call tty_wait;   end;   else do;      f#m = 0;      f#l = 0;      rcv_text = 0;      call ps('[KUnable to create file:');      call ps(rcv_name);      call big.trouble;       /* This will send a PE_ERR_MESSAGE event to the MAC */   end;   if (rcv_text = 1) then do;      dest = fopen(rcv_name,'w');      /* NOTE HERE:  A SETBUF CALL MUST BE DONE RIGHT AFTER OPENING A */      /* FILE WITH FOPEN.  THIS IS DONE IN Process.Receive.File.Data  */      if dest = nullf then do;         f#m = 0;         f#l = 0;         rcv_text = 0;         call ps('[KUnable to open text file:');         call ps(rcv_name);         call big.trouble;       /* This will send a PE_ERR_MESSAGE event to the MAC */      end;   end;   return(TRUE);end Process.Receive.File;Process.Receive.File.Data: proc (packet,len) swapable;   dcl packet     array;  /* Procotol packet data */   dcl len        fixed;  /* Byte length of the original message */   dcl wlen       fixed;  /* Word length of the original message */   dcl params (3) fixed;  /* Parameters block for extwrite */   dcl s.buf(130) fixed;  /* String buffer */   dcl (c1,c2)    fixed;  /* Characters read in */   dcl (c3,c4)    fixed;   dcl (i,j,k)    fixed;   if (f#m = 0 AND f#l = 0)  /* Do we have a file to write to? */   then return(TRUE);        /* Nope */   /* This block of total nonsense is necessary because the fileio   */   /* package is broken.  It advertises that file buffers may be     */   /* used in internal, external or poly memory.  Don't believe it.  */   /* Only internal memory works, and since misc.buf is our only     */   /* sector-sized buffer and we don't have room to randomly declare */   /* another 256-word buffer just for this, we have to store the    */   /* fileio buffer in external memory between function calls and    */   /* restore it to misc.buf whenever we come in here.               */   if rcv_text <> 0 then do;  /* We only call fputs for text files   */      write(MAM) = receive.xmem + 1;      call copy.in(addr(misc.buf(0)),256);      /* If this SETBUF call is not done, fileio will attempt to     */      /* use misc.buf as its file buffer (since loading the D115     */      /* used misc.buf earlier -- see :SYNRSOU:08-INIT:610-INI1).    */      /* This may be fine, but LOTS of other code uses misc.buf too  */      /* in-between our calls to this function!!                     */      /*  This will fail after the first time, but who cares.        */      call setbuf(dest,addr(misc.buf(0)),0,256);   end;   /* Word length to write */   wlen = shr( (len - Able_Packet_Head - 2) + 1,1);   write(mam) = receive.xmem;   write(mal) = receive.mal;   do i=0 to wlen - 1;       /* Loop over words in message */      if rcv_text = 0 then do;         write(mdi) = packet(i);         if read(mal) = 0 then do;     /* Wrapped; write out a sector     */            if  f#m =   f#m.end        /* Are we beyond the end of file?  */            AND f#l ige f#l.end            then do;               f#m = 0;                /* Yep....stop writing to it...    */               f#l = 0;               return(TRUE);           /* ...and bail out!                */            end;            params(0) = receive.xmem;  /* External memory sector to write */            params(1) = 0;             /* Word offset within the sector   */            params(2) = 1;             /* Number of sectors to write      */            params(3) = 0;             /* Number of words beyond last sec */            call extwrite(f#m,f#l,params);            write(mam) = receive.xmem;            write(mal) = 0;            f#l = f#l + 1;            if f#l = 0 then f#m = f#m + 1;         end;   /* of write out a sector */      end;      else do;  /* Creating a text file */         c1 = shr(packet(i),8);  /* Byte swap the MAC/C string */         /* If last time through the loop and byte count is ODD */         if (i = (wlen - 1)) AND len         then c2 = -1;         else c2 = packet(i) & "377";         if c1 <> "15"           /* MAC end-of-line char */         then do;            write(mdi) = c1;            if  c2 <> "15"            AND c2 <> -1 then write(mdi) = c2;         end;         if (c1 = "15") OR (c2 = "15")         then do;            k = read(MAL);       /* Remember where the end of the line is */            write(MAM) = receive.xmem;            s.buf(0) = k;        /* String length */            do j=1 to shr(k+1,1);               c3 = read(MDI);               c4 = read(MDI);               s.buf(j) = c3 | shl(c4,8);            end;            write(MAM) = receive.xmem;            if  c1 =  "15"           /* End of line was on first char */            AND c2 <> "15"           /* And second is not just a blank line */            AND c2 <> -1 then do;    /* And second is a valid char */               write(MDI) = c2;      /* Start next line with second char */            end;            receive.mal = read(mal);  /* Remember where we are (fputs may trash) */            call fputs(s.buf,line#,dest); /* Write the line out */            line# = line# + 1;          /* Bump the line number counter */            /* If we happened to get 2 EOL's at once, write the second (blank) line */            if (c1 = "15") AND (c2 = "15") then do;               s.buf(0) = 0;               call fputs(s.buf,line#,dest);               line# = line# + 1;            end;            write(MAM) = receive.xmem;     /* Restore */            write(MAL) = receive.mal;         end;      end;   /* of creating a text file */   end;      /* of loop over words in message */   receive.mal = read(mal);  /* Remember where we are */   write(MAM) = receive.xmem + 1;   call copy.out(addr(misc.buf(0)),256);   return(TRUE);end Process.Receive.File.Data;Process.End.Receive.File: proc (packet) swapable;   dcl packet     array;  /* Procotol packet data */   dcl params (3) fixed;  /* Parameters block for extwrite */   if (f#m = 0 AND f#l = 0)         /* Do we have a file to write to? */   then return(TRUE);               /* Nope */   if rcv_text = 0 then do;         /* End of receiving non-text file  */      params(0) = receive.xmem;  /* External memory sector to write */      params(1) = 0;             /* Word offset within the sector   */      params(2) = 1;             /* Number of sectors to write      */      params(3) = 0;             /* Number of words beyond last sec */      call extwrite(f#m,f#l,params);   end;   else do;                             /* End of receiving a text file */      write(MAM) = receive.xmem + 1;      call copy.in(addr(misc.buf(0)),256); /* Restore the SETBUF buffer */      call fclose(dest);                   /* fclose may use misc.buf   */      rcv_text = 0;      /* Shorten file to be the actual length we used */      if (locate(rcv_name,1)) then do;         call truncate(rcv_name, 0, shr(F#Words,8)+1, F#Words, 1);      end;   end;   f#m = 0;            /* Stop writing to output file */   f#l = 0;   /* This will send a PE_VOLUME_UPDATED event to the MAC */   new.poly.contents = new.poly.contents | 8;   call ps('Done');   call tty_wait;   return(TRUE);end Process.End.Receive.File;dcl Data.Write.Subroutine proc (fixed,fixed,fixed,array) returns (fixed) recursive;Process.Block.Overwrite: proc (packet,des) swapable;   dcl packet array;   dcl des    fixed;   dcl tag    fixed;   dcl status fixed;   dcl ret    fixed;   ret = 1;   tag = packet(0);   status = b#busy;   write(mam) = XFER.PTR;                    if read(md) = T#Request_Data_Write   then do;      ret = Data.Write.Subroutine (status,tag,des,packet);   end;   return ret;end Process.Block.Overwrite;Process.Block: proc (packet,des) swapable;   dcl packet array;   dcl des    fixed;   dcl tag    fixed;   dcl status fixed;   dcl ret    fixed;   ret = 1;   tag = packet(0);   if tag <> Block.Tag   then status = status | b#busy;   if packet(1) igt Max_Block_Length   then status = status | b#overflow;   write(mam) = XFER.PTR;                    if read(md) = T#Request_Data_Write   then do;      ret = Data.Write.Subroutine (status,tag,des,packet);   end;   Block.Busy = 0;   return ret;end Process.Block;/* Note: This super-type is mostly used INTERNALLY by the network *//* Some sub-types ARE, however, visible at this level.            */Handle.Network.ID: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '33';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   if subtype <= 23 then   do case (subtype-16);     /* branch on specific network ID command */      do;                    /*  16: Machine Crashed (part-1) */         ret = Process.Crash.1(packet,des);      end;      do;                    /*  17: Machine Crashed (part-2) */         ret = Process.Crash.2;      end;      ;                      /*  18: Unused */      ;                      /*  19: Unused */      ;                      /*  20: Unused */      do;                    /*  21: Receive a file to create on the Able */         ret = Process.Receive.File(packet,len);      end;      do;                    /*  22: Receive a packet of file data */         ret = Process.Receive.File.Data(packet,len);      end;      do;                    /*  23: End of receiving file */         ret = Process.End.Receive.File(packet);      end;   end;             /* of branch on specific network ID command */   else if subtype < 48 then   do case (subtype-32);     /* branch on specific network ID command */      do;                    /* 32: Here is */         ret = Process.Here.Is(packet,des);      end;      do;                    /* 33: Relay data */         ret = Process.Relay.Data(packet,len);      end;   end;             /* of branch on specific network ID command */   else if subtype < 51 then   do case (subtype-48);     /* branch on specific network ID command */      do;                    /* 48: Block Continuation */         /* handled at interrupt */      end;      do;                    /* 49: Block Start */         /* handled at interrupt unless overwrite situation occurs */         ret = Process.Block.Overwrite(packet,des);      end;      do;                    /* 50: Block End */         ret = Process.Block(packet,des);      end;   end;             /* of branch on specific network ID command */   return(ret);             /* return processed status */end Handle.Network.ID;