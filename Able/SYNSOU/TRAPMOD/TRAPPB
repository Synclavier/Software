/* TRAPPB   $TITLE  Process playback messages   Modified:   10/30/91 - pf  - Refixing scrubbing bug when sample rate diff. from DTD   08/22/91 - pf  - Use extend mode for poly scrubbing only during trim   08/19/91 - PF  - Allow poly scrubbing of looped events   07/11/91 - cj  - Added correct mark start to poly scrubbing   05/29/91 - cj  - added ability to  scrub an extended DTD cue/event                    Also added protocol scrubbing of poly files   01/15/91 - TSS - Added Stop.Event.Auditions feature to Process.Play.Event   11/15/90 - TSS - Subtract ZERO.TIME when send Play-To time out SyncNet   11/08/90 - MWH - Reformat DS routines   11/06/90 - CJ  - Added play to information to motion status   11/05/90 - CJ  - ADDED PLAY REGION   11/01/90 - MWH - Add locate to relative time for sequences & cues   10/26/90 - MWH - Add scrubbing by time rather than relative position   07/10/90 - PF  - Replace calls to DISPLAY.BEAT.NUMBER with NEW.BEAT.NUMBER flag   06/05/90 - cj  - clarify arguments to send.event.snapshot   06/01/90 - cj  - fixed editview "rubber band" problem   01/25/90 - MWH - Fix "300 msec delay starting cues" bug (from EditView)   12/15/89 - MWH - Fix locate to zero, mark; speed up long rewinding locates   12/08/89 - CJ  - call Stop.Sequencer before calling Preset.Play.Time   11/07/89 - MWH - Optimize locate to zero by doing a play initialize   10/12/89 - MWH - Fix packet format on start scrub   09/29/89 - MWH - Display beat number after doing a locate to mark   09/26/89 - MWH - Set new motion status bit if SMPTE is locked   08/28/89 - MWH - Rework the protocol for release 2.2*/Process.Play.Command: proc swapable;   call CONTINUE.SEQUENCER;   CONT = 0;   return (1);end Process.Play.Command;Process.Stop.Command:proc swapable;   dcl i fixed;   /* If the direct-to-disk is triggering a cue or scrubbing,  stop */   /* it.                                                           */   if DTD.Play.State <> 0 then do;  /* If doing DTD playing, stop */      call STOP.DTD.PLAY.STATE;     /* it.                        */   end;   /* else if the sequencer is running,  then stop it.            */   else if PLAY <> 0 then do;      CALL STOP.SEQUENCER;      CALL DISPLAY.SEQUENCER.STATUS;     /* TELL EVERYONE ABOUT THE CHANGES */   end;   /* else if stopped pressed twice, then clean up some extra       */   /* things and locate the sequencer.                              */   else do;      CALL STOP.RECD.MOVE.PLAY.XPOS.CONT.ERAS; /* STOP SEQUENCER & TURN OFF ALL LIGHTS */      WRITE(MAM)=CLAV.PTR;      DO I=0 TO (NUM.KEYS-1);            /* CLEAR CLAV.STAT  */        WRITE(MDI)=0;                    /* TO TURN OFF      */      END;                               /* STUCK MIDI NOTES */      NUM.HELD.KEYS=0;                   /* NONE HELD        */      CALL ALL.MIDI.NOTES.OFF;           /* EXTRA INSURANCE  */      CALL DISPLAY.SEQUENCER.STATUS;            /* TELL EVERYONE ABOUT THE CHANGES */   end;   return (1);end Process.Stop.Command;Process.Rewind.Command: proc swapable;   call rewind.sequencer;                         /* perform rewind */   if move.speed = 0 then call stop.sequencer;    /* if we just moved from +2000 to 0 speed then stop */   call display.sequencer.status;                 /* let everyone know - this will set new.seq.info\128(motion change) */   return(1);end Process.Rewind.Command;Process.Fast.Forward.Command: proc swapable;     call fast.forward.sequencer;                   /* perform ff */   if move.speed = 0 then call stop.sequencer;    /* if we just hit zero then stop */   call display.sequencer.status;                 /* update displays - set new.seq.info\128 */   return(1);end Process.Fast.Forward.Command;Process.Locate.Command: proc(packet,des) swapable;   dcl packet    array;   dcl des       fixed;     /* pass the node we are talking to       */   dcl code lit   ' 0';     /* 0 = absolute note, 1 = relative note  */                            /* 2 = absolute time, 3 = relative time  */                            /* 4 = mark                              */   dcl msb  lit   ' 1';   dcl lsb  lit   ' 2';   dcl trk  lit   ' 3';   dcl seq     fixed;   dcl type    fixed;   dcl s_trk   fixed;   dcl time(1) fixed;   dcl i       fixed;   dcl j       fixed;   /* Extract information from the packet: */   seq = shr(packet(code), 8);     /* upper half: 0 = DTD locate   */                                   /*             1 = sequencer    */   type = packet(code) & 255;      /* time type:  0 = abs note     */                                   /*             1 = relative     */                                   /*             2 = absolute     */                                   /*             3 = relative     */                                   /*             4 = mark #       */   time(0) = packet(msb);          /* and get the passed time      */   time(1) = packet(lsb);   call add16(ZERO.TIME,time);     /* Add "ZERO.TIME" offset       */   s_trk = packet(trk);            /* Sequencer track for note loc */   s_trk = proto.to.sync.strk(s_trk);   if type = 0 AND s_trk = -1 then return(1);   /* See what time format this node is using for DTD times:       */   i = map.d115.node.id(des);      /* get board/channel #          */   if i <> (-1)   then j = ((d115d.format(i) & PFORM#DTDSeq) <> 0);   /* Check for type */   do case type;      ;                            /* 0: Absolute note */      do;                          /* 1: Relative note */      end;      do;                          /* 2: Absolute time */         /* Handle Sequencer Locates: */         if seq = 1 then do;            call Stop.Sequencer;            if com16(zero.time,time) >= lw#ieq          /* If request is to the beginning */            then call Play.Initialize;                  /* Quickly go there */            /* Not locating to zero */            else do;               /* Do we need to rewind to locate? */               if(com32(loc(addr(play.time.msb)),time) = lw#igt) then do;                  if play.time.msb IGT (time(lw#msb) + 1)  /* If we're a LONG way off, fast forward is MUCH faster */                  then call Play.Initialize;               /* So go to the beginning */               end;               call Scroll.Seq(time(0),time(1),0);            end;            New.Beat.Number = 1;         end;         /* Handle DTD locates:       */         else do;            /* correct for sequencer format time display if needed */            if j = 1 then do;               call SUB32(time, Cue.Trig.Time, time);   /* get dist rel to cue trig point (+/-) */               call ADD32(time, Cue.In.Time,   time);   /* add to in time                       */            end;            else do;   /* remove the offset that showed time as a cur proj time: */               call SUB32(time, Cue.Time.Display.Offset, time);            end;            if (time(0) < 0)            or (COM16(zero.time, time) = lw#igt)            then call STR32(0, zero.time, time);            call Set.DTD.Scrub.Anchor.Point(time);         end;      end;      do;                          /* 3: Relative time */         if seq = 1 then do;       /* Handle sequencer locates */            call Stop.Sequencer;            /* Do we need to rewind to locate? */            if time(lw#msb) < 0 then do;               if time(lw#msb) <> "177777"              /* If we're going a LONG way off, fast forward is MUCH faster */               then call Play.Initialize;               /* So go to the beginning */            end;            call add32(time,loc(addr(play.time.msb)),time);            call Scroll.Seq(time(0),time(1),0);            New.Beat.Number = 1;         end;         else do;                  /* Handle DTD locates */            call ADD32(time,AEE.Shuttle.Anchor.Time,time);            /* call Stop.DTD.Playback; */            call Set.DTD.Scrub.Anchor.Point(time);         end;      end;      do;                          /* 4: Mark          */         /* Quickly locate to the mark point, ready to play */         call Stop.Sequencer;         if MARK.BUTTON.DISABLED=0             /* MARK button active */         then call Preset.Play.Time(0);        /* Jump to mark point */         else call Play.Initialize;            /* Jump to start      */         New.Beat.Number = 1;      end;   end;   return(1);end Process.Locate.Command;Send.Motion.Status.Packet: proc(packet,des) swapable;   dcl packet      array;   dcl des         fixed;   dcl status      fixed;   dcl play.to (1) fixed;   dcl slocked     fixed external; /* True if locked to SMPTE */   /* set up status variable */   status = 0;   if  (play               <> 0)   and (move                = 0) then status = status | 1;   /* play         */   if  (recd               <> 0) then status = status | 2;   /* record       */   if  (pnch               <> 0) then status = status | 4;   /* punch        */   if  (move               <> 0)   and (move.speed          < 0) then status = status | 8;   /* rewind       */   if  (move               <> 0)   and (move.speed          > 0) then status = status | 16;  /* fast forward */   if  (slocked            <> 0) then status = status | 32;  /* smpte locked */   if  (play.seq.to.a.time <> 0) then status = status | 64;  /* "play to"    */   write(mam) = misc.ptr;      write(mdi) = L#Motion_Status + shl(play.seq.to.a.time, 2);   write(mdi) = des;   write(mdi) = T#Motion_Status;   write(mdi) = packet(0);         /* Tag */   write(mdi) = status;            /* Status bits */   if play.seq.to.a.time <> 0 then do;      /* subtract off ZERO.TIME from all times going out */      /* SyncNet so applications don't have to think     */      /* about it.                                       */      if (SEQ.PLAY.TO.MSB=0) and (SEQ.PLAY.TO.LSB ilt ZERO.TIME)      then do;                     /* limit to zero */         Play.To(0)=0;         Play.To(1)=0;      end;      else do;                     /* adjust for ZERO.TIME */         call STR32(SEQ.PLAY.TO.MSB, SEQ.PLAY.TO.LSB, Play.To);         call SUB16(ZERO.TIME, Play.To);      end;      write(mdi) = Play.To(0);     /* and write info into packet */      write(mdi) = Play.To(1);   end;   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      return(FALSE);               /* try again later                       */   end;   return(TRUE);                   /* success */end Send.Motion.Status.Packet;/* Handy routine to trigger a portion of the current cue: */PLAY.PROTOCOL.CURRENT.CUE: proc(startcode,backup,stopcode,drive.bits,tempcue) swapable;   dcl startcode  fixed;  /* See the operating system routine */   dcl backup     fixed;  /* "PLAY.DTD.CURRENT.CUE" for a     */   dcl stopcode   fixed;  /* description of these arguments   */   dcl drive.bits fixed;   dcl tempcue    fixed;   dcl i          fixed;   i = PLAY.DTD.CURRENT.CUE(startcode,backup,stopcode,drive.bits,tempcue);   if i = 1   then call Present.Protocol.Error.Message(NT#NoDrivesSoloed,ATTR#Reverse,0,0,0);   if i = 2   then call Present.Protocol.Error.Message(NT#InTimeEqualsOutTime,ATTR#Reverse,0,0,0);end PLAY.PROTOCOL.CURRENT.CUE;Process.Play.Edit.Command: proc (packet,is.cue) swapable;   dcl packet       array;    /* Arguments */   dcl is.cue       fixed;    /* True if it is CUE "play edit", else we don't know */   dcl in.time  (1) fixed;   dcl out.time (1) fixed;   dcl any.times    fixed;   if not (is.cue) then do;   /* We don't know for sure */      if shr(packet(4),8) = 0      then is.cue = TRUE;      else is.cue = FALSE;      any.times   = TRUE;      call COPY32(loc(addr(packet(0))), in.time );      call COPY32(loc(addr(packet(2))), out.time);   end;   if is.cue then do;         /* Cue "play to" */      if any.times = FALSE      then do;         call Load.DTD.Temp.Cue        (Current.Cue.Ptr);         call Play.Protocol.Current.Cue(2,0,1,Current.Cue.Drive.Bits,1); /* play edit in to edit out */      end;      else do;         /* need ability to play a region of the current cue.  Hello?   Hello?  Earth to cue??  Earth to cue,  come in cue??? */      end;   end;   else do;                   /* Sequence "play to" with arguments */      call add16(ZERO.TIME,in.time);              /* Add "ZERO.TIME" offset */      call add16(ZERO.TIME,out.time);             /* Add "ZERO.TIME" offset */      call Stop.Sequencer;      call Scroll.Seq(in.time(lw#msb),in.time(lw#lsb),0);      if COM32(in.time, out.time) = LW#ILT      then do;         New.Beat.Number = 1;         call Continue.Seq.With.Pre.Roll(Silent.Pre.Roll.Value);         cont = 0;                            /* No setting a start loop from the remote box */         /* Set these up AFTER sequencer starts going; start clears them! */         call copy32(out.time,loc(addr(Seq.Play.To.MSB)));         Check.Sequencer.Times = 1;         Play.Seq.To.A.Time    = 1;      end;   end;    /* of sequence "play edit" */   return(1);end Process.Play.Edit.Command;/* Handy routine to play all or part of the current cue: */Process.Play.From.Command: proc (packet,is.cue) swapable;   dcl packet    array;    /* Arguments */   dcl is.cue    fixed;    /* True if it is CUE "play from", else we don't know */   if not (is.cue) then do;   /* We don't know for sure */      if shr(packet(2),8) = 0      then is.cue = TRUE;      else is.cue = FALSE;   end;   if is.cue then do;         /* Cue "play from" */      call Load.DTD.Temp.Cue        (Current.Cue.Ptr);      call Play.Protocol.Current.Cue(4,0,3,Current.Cue.Drive.Bits,1); /* play from anchor point to end of project */   end;   else do;                   /* Sequence "play from" */      call Stop.Sequencer;      call add16(ZERO.TIME,packet);        /* Add "ZERO.TIME" offset */      call Scroll.Seq(packet(lw#msb),packet(lw#lsb),0);      New.Beat.Number = 1;      call Continue.Seq.With.Pre.Roll(Silent.Pre.Roll.Value);      cont = 0;                            /* No setting a start loop from the remote box */   end;   return(1);end Process.Play.From.Command;Process.Play.To.Command: proc (packet,is.cue) swapable;   dcl packet       array;    /* Arguments */   dcl is.cue       fixed;    /* True if it is CUE "play to", else we don't know */   dcl seq.time (1) fixed;   if not (is.cue) then do;   /* We don't know for sure */      if shr(packet(2),8) = 0      then is.cue = TRUE;      else is.cue = FALSE;   end;   if is.cue then do;         /* Cue "play to" */      call Load.DTD.Temp.Cue   (Current.Cue.Ptr);      call Play.Protocol.Current.Cue(4,1,6,Current.Cue.Drive.Bits,1); /* play up to anchor point */   end;   else do;                   /* Sequence "play to" */      call add16(ZERO.TIME,packet);              /* Add "ZERO.TIME" offset */      call Take.System.Sequence.Time(seq.time);  /* Get the current sequence time */      if com32(Seq.Time,packet) = LW#ILT         /* Are we before "play to" time? */      then do;         call Continue.Sequencer;         cont = 0;                                     /* No setting a start loop from the protocol */         /* Set these up AFTER sequencer starts going; start clears them! */         call copy32(packet,loc(addr(Seq.Play.To.MSB)));         Check.Sequencer.Times = 1;         Play.Seq.To.A.Time    = 1;      end;   end;    /* of sequence "play to" */   return(1);end Process.Play.To.Command;/* $SUBTITLE  Sequence scrubbing routines */dcl Events.Stacked boolean;dcl Scrub.Type     fixed;        /* 0 = no scrubbing                   */                                 /* 1 = Sequence Scrubbing             */                                 /* 2 = DTD Event Scrubbing            */                                 /* 3 = POLY Event Scrubbing           */dcl Scrub.Start(1) fixed;        /* holds seq time of event start      */dcl Scrub.Delay    fixed;        /* holds delay field                  */Start.Sequence.Scrubbing: proc (packet) swapable;   dcl packet      array;   /* Arguments passed in */   dcl i           fixed;   Scrub.Type = 0;          /* initialize scrub type to 0 in case we	*/                            /* come across an error						*/									 	interpret_set_timebase_mode(TIME.BASE.MODE);   Events.Stacked = FALSE;   if dtd.max.secs = 0      /* For now, Sequence Scrubbing can only    */   then return(TRUE);       /* be used with the DTD                    */   call Prepare.DTD.For.Cue.Scrubbing;   /* Create a dummy "tag" at the start of the packet.                 */   /* We borrow the routines which process "request sequence snapshot" */   /* and it has the same format packet with a "tag" and long "return  */   /* bits" prefix                                                     */   do i = shr((L#Start_Scrubbing-5),1) - 1 to 0 by -1;      packet(i+3) = packet(i);   end;   packet(0) = 0;     /* provide tag of 0 and return bits of 0         */   packet(1) = 0;     /* to generate consistent results from           */   packet(2) = 0;     /* send.event.snapshot                           */   Scrub.Type = 1;    /* indicate DTD sequence VS event scrubbing      */	interpret_set_timebase_mode(-Scrub.Type);   if Is.DTD.Ready.For.Cue.Stacking = TRUE then do;      call Send.Event.Snapshot(packet,0,1);      Events.Stacked = TRUE;   end;   else do;    /* DTD is not ready; remember the packet for later use */      write(MAM) = Scrub.Ptr;      call Copy.Out(addr(packet(0)),shr((L#Req_Seq_Snapshot - 5),1));   end;   return(TRUE);end Start.Sequence.Scrubbing;Scrub.To.New.Time: proc (packet) swapable;   dcl packet                         array;   /* Arguments passed in */   dcl event    (Event.Record.Size-1) fixed;   /* Event record        */   dcl msecs    (                  1) fixed;   dcl samples  (                  1) fixed;   dcl Start.POLY.Scrubbing   proc        external;   dcl Compute.POLY.Scrubbing proc(array) external;	dcl MIDI.SYNC.OUT 					  fixed external;	dcl MIDI.SYNC.IS.TC					  fixed external;   dcl TIME.BASE.MODE					  fixed external;	dcl MIDI.FULL.FRAME       			  proc(fixed, fixed) external;   /* Stop "rubber banding" by ignoring stacked up new position */   /* messages                                                  */   if COM32(packet, most.recent.scrub.pos) <> LW#IEQ   then return(true);   if Scrub.Type = 0       /* ignore scrub position if we never */   then return(true);      /* found the event to scrub          */   if Scrub.Type = 3       /* if scrubbing poly, then update    */   then do;                /* scrub position here               */      if Events.Stacked = FALSE then do;   /* set up to start   */         call Start.POLY.Scrubbing;        /* output first      */         Events.Stacked = TRUE;            /* time through      */      end;      /* EditView passes the sample time from the start of the sequence.  */      /* Begin by computing the real sequence time (in msecs) that this   */      /* corresponds to:                                                  */      call DTD.Sample.#.To.Msecs(packet, CF#Time, SAMP.SPEED, AEE.CURRENT.PROJECT.RATE, zero.zero, msecs);      /* Compute distance from the start of the event in real seq msecs:  */      call SUB32(msecs, Scrub.Start, msecs);      /* Subtract off the delay that is applied during playback to get    */      /* the position (in msecs) relative to the start of the file:       */      call SUB16(Scrub.Delay, msecs);      call Compute.POLY.Scrubbing(msecs);            /* mouse me ...      */      return(true);        /* done with poly scrubbing case     */   end;   /* Else handle DTD Sequence or Event scrubbing.              */   /* If cues have not been stacked yet, then stack them now:   */   if Events.Stacked = FALSE then do;      if Is.DTD.Ready.For.Cue.Stacking = TRUE  /* ...but it is now */      then do;         /* Stack multiple events for normal sequence scrub:           */         if Scrub.Type = 1 then do;            write(MAM) = Scrub.Ptr;            /* Retrieve what we're going to scrub */            call Copy.In(addr(event(0)),shr((L#Req_Seq_Snapshot - 5),1));            call Send.Event.Snapshot(event,0,1);  /* Stack events on DTD */         end;         /* Stack single events for extended event scrub:              */         else do;            write(MAM) = Scrub.Ptr;            /* Retrieve what we're going to scrub */            call Copy.In(addr(event(0)),Event.Record.Size);            call Send.Event.To.DTD.Scrub.Stack(event, 1);    /* Stack on DTD with extend */         end;         Events.Stacked = TRUE;                /* events now stacked   */      end;      else return(TRUE);                       /* DTD is still not ready; ignore */   end;   /* DTD has all events stacked and is ready to start or continue scrubbing */   call Set.Current.Scrub.Position(packet);	IF ((MIDI.SYNC.OUT   != 0)	&&  (MIDI.SYNC.IS.TC != 0)	&&  (TIME.BASE.MODE  == 0))	{      call DTD.Sample.#.To.Msecs(packet, CF#Time, SAMP.SPEED, AEE.CURRENT.PROJECT.RATE, zero.zero, msecs);				MIDI.FULL.FRAME(msecs(0), msecs(1));	}	   return(TRUE);end Scrub.To.New.Time;Stop.Sequence.Scrubbing: proc (packet) swapable;   dcl packet                     array;   /* Arguments passed in */   dcl Stop.POLY.Scrubbing proc   external;   if Scrub.Type = 0       /* ignore scrub stop if we never     */   then return(true);      /* found the event to scrub          */   if Scrub.Type = 3       /* if scrubbing poly, then stop      */   then do;                /* poly playback here                */      call Stop.POLY.Scrubbing;  /* stop output, restore vars   */      Scrub.Type = 0;            /* done with scrub type        */		interpret_set_timebase_mode(TIME.BASE.MODE);      return(true);        /* done with poly scrubbing case     */   end;   call Terminate.DTD.Cue.Scrubbing;  /* terminate DTD case     */	interpret_set_timebase_mode(TIME.BASE.MODE);   return(TRUE);end Stop.Sequence.Scrubbing;Process.Scrub.Cue.Command: proc(packet) swapable;   dcl packet    array;  /* packet(0) = normalized amount of movement                  */                         /* packet(1) = 0=fine, 1=medium, 2=coarse scrub IN HIGH BYTE! */   dcl scrubmode fixed;  /* temp holds desired scrub mode             */   dcl amount    fixed;  /* Positive normalized amount to move bar    */   dcl direction fixed;  /* -1 for backwards, 1 for forwards          */   dcl remainder fixed STATIC;  /* save remainder to not lose pixels. */   dcl pixels.for.whole.bar lit '8192';  /* twice around wheel gives whole fine bar */     /* See what type of scrubbing is desired: */   do case shr(packet(1),8);      scrubmode = 0;                              /* 0: Fine bar           */      scrubmode = 0;                              /* 1: Coarse bar "scrub" */      scrubmode = 1;                              /* 2: Scan mode          */   end;   /* Check for change of mode desired: */   if DTD.Play.State <> 0 then do;         /* if now playing or scrubbing  */      if  ((scrubmode      =  0)           /* if point desired             */      and  (DTD.Play.State <> 7))          /* but now doing something else */      or  ((scrubmode      =  1)           /* or scan mode playback        */      and  (DTD.Play.State <> 2))          /* desired but doing elsely ... */      then call STOP.DTD.PLAY.STATE;       /* then stop current DTD motion */   end;   Scrub.Scan.Mode = scrubmode;            /* now save desired mode        */   /* Load the current cue into the direct-to-disk when we first start     */   /* scrubbing.  Also start scrubbing here if that is what we want:       */   if DTD.Play.State = 0   then do;      call Load.DTD.Temp.Cue(Current.Cue.Ptr);      if Scrub.Scan.Mode = 0      then do;         call Set.DTD.Play.Tracks(Shuttle.Drive.Bits );         call Send.To.Lod        (DTD.Scrolling.Off,0);         call Play.DTD.At.Point(AEE.Shuttle.Anchor.Time,1,0,1);      end;   end;   /* Now compute the new anchor time based on the knob movement,          */   /* update the shuttle time (but suppress events),  then scrub to (or    */   /* start scan mode playback at) the new anchor time.                    */   /* Normalized shuttle controller returns +/- 4096 for each revolution   */   amount = packet(0);              /* Get positive amount to move bar */   if amount < 0 then do;           /* Backwards (down) */      direction = -1;               /* Remember direction to move it   */      amount = -amount;             /* Make amount positive            */      if remainder < 0              /* if we had a remainder in the    */      then remainder = -remainder;  /* negative direction, keep it     */      else remainder = 0;           /* else toss it to simplify        */   end;                             /* math.                           */   else do;      direction = 1;                /* set positive direction          */      if remainder < 0              /* remove any left over negative   */      then remainder = 0;           /* remainder, but keep posative    */   end;                             /* remainder.                      */   /* Scrub.Scale.Table holds the amount of audio in .1 second units   */   /* for the whole coarse bar.  Pixels.for.whole.bar is the number    */   /* of incremental scrub units that should match the whole bar.      */   /* So to get # of milliseconds in this particular movement:         */   /* Compute # of milliseconds in fine bar:                           */   load  100*scrub.scale.table(GID(Saved.AEE.Shuttle.Fine.Switch) + Fine.Switch.Default);   uload remainder;   /* Multiply by # of pixels we moved by:                              */   mul amount;  /* creates amount*scale+remainder                       */   /* Divide by knob pixels in whole bar:                               */   div pixels.for.whole.bar;   amount    = res;                 /* get # of milliseconds to scrub   */   remainder = rem;                 /* save remainder (1/8192 of msec)  */   if direction < 0 then do;        /* if going, limit to 0             */      if COM16(amount, AEE.Shuttle.Anchor.Time) = lw#igt      then call STR32(0, 0, AEE.Shuttle.Anchor.Time);      else call SUB16(amount, AEE.Shuttle.Anchor.Time);      remainder = -remainder;       /* negate remainder for next time   */   end;   else call ADD16(amount, AEE.Shuttle.Anchor.Time);   /* Change the scrubbing position if we should:                       */   if Scrub.Scan.Mode = 0 then do;      call Play.DTD.At.Point(AEE.Shuttle.Anchor.Time,1,0,1);      /* Inform the ABLE screen code about the new scrub time by        */      /* creating an event for the ABLE screen.   Do not bother to      */      /* send an event out to all devices at this time,  since devices  */      /* can see the DTD time in every "here-is" message anyways.       */      new.ABLE.dtd.info = new.ABLE.dtd.info \ 8;   end;   /* Else perform scan mode playback:                                  */   else do;      call Play.Protocol.Current.Cue(4,0,2,Current.Cue.Drive.Bits,1); /* play from new anchor point to end of sbar */   end;   return(1);                       /* Processing is complete */end Process.Scrub.Cue.Command;Process.Scrub.Cue.By.Time: proc(packet,des) swapable;   dcl packet    array;     /* packet(0) = MSB of cue time (in msec) */                            /* packet(1) = LSB */   dcl des       fixed;     /* Pass the node we are talking to       */   dcl new (1)   fixed;     /* Construct new anchor time here        */   dcl (i,j)     fixed;   call add16(ZERO.TIME,packet);     /* Add "ZERO.TIME" offset       */   if  packet(0) < 0     /* Negative time would be illegal */   then return(1);   /* If here, then we have a valid time to scrub to in "packet" */   i = map.d115.node.id(des);             /* Get board/channel # */   if i <> (-1)   then j = ((d115d.format(i) & PFORM#DTDSeq) <> 0);   else j = 0;   call copy32(packet,new);     /* Remove Cue.Time.Display.Offset if needed */   if j = 0 then do;         call SUB32(new,Cue.Time.Display.Offset,new);   end;   /* Remove Audition display offset if needed */   else do;      call SUB32(new, Cue.Trig.Time, new);   /* get dist rel to cue trig point (+/-) */      call ADD32(new, Cue.In.Time,   new);   /* add to in time                       */   end;   /* Make sure we didn't go below zero.time */   if (new(lw#msb) < 0)   OR (COM16(zero.time,new) = lw#igt)   then call STR32(0,zero.time,new);   /* Check for change of mode desired: */   if  DTD.Play.State <> 0                 /* if now playing               */   and DTD.Play.State <> 7                 /* but not currently scrubbing  */   then call STOP.DTD.PLAY.STATE;          /* then stop current DTD motion */   /* Load the current cue into the direct-to-disk when we first start     */   /* scrubbing.  Also, start scrubbing from the current anchor point.     */   if DTD.Play.State = 0   then do;      call Load.DTD.Temp.Cue(Current.Cue.Ptr);      call Set.DTD.Play.Tracks(Shuttle.Drive.Bits );      call Send.To.Lod        (DTD.Scrolling.Off,0);      call Play.DTD.At.Point(AEE.Shuttle.Anchor.Time,1,0,1);   end;   /* Set the new anchor time to be the scrub dest in "packet"       */   call copy32(new,AEE.Shuttle.Anchor.Time);   /* Change the scrubbing position if we should:                    */   call Play.DTD.At.Point(AEE.Shuttle.Anchor.Time,1,0,1);   /* Inform the ABLE screen code about the new scrub time by        */   /* creating an event for the ABLE screen.   Do not bother to      */   /* send an event out to all devices at this time,  since devices  */   /* can see the DTD time in every "here-is" message anyways.       */   new.ABLE.dtd.info = new.ABLE.dtd.info \ 8;   return(1);                       /* Processing is complete */end Process.Scrub.Cue.By.Time;Start.Event.Scrubbing: proc (packet) swapable;   dcl packet         array;   dcl i              fixed;   dcl event (Event.Record.Size-1)  fixed;     /* event record */   dcl info  (Hzinfo.Record.Size-1) fixed;     /* info  record */   dcl Initialize.for.POLY.Scrubbing proc(array, array) external;   dcl Get.Event.HZ.Information      proc(array, array) external;   Scrub.Type = 0;           /* initialize scrub type to 0 in case we	*/                             /* come across an error							*/   Events.Stacked = FALSE;   /* indicate not stacked yet						*/   call add16(ZERO.TIME,loc(addr(packet(1))));/* Add "ZERO.TIME" offset */   packet(0) = proto.to.sync.strk(packet(0)); /* Convert track number   */   if packet(0) = -1                          /* was not a Syncl trk    */   then return(TRUE);   do i=0 to (Spointer.Record.Size - 1);      /* Get event ID passed in */      event(i) = packet(i);                   /* Trk#, Seq_time, Count  */   end;   /* If we can exactly find the event being referenced, get ready to   */   /* scrub it:                                                         */   if Get.Sequencer.Event.Information(event) <> Good.Event.Status   then return(TRUE);   if  (event(event.type) = event.type.note)     /* if music note       */   or  (event(event.type) = event.type.poly)     /* or poly note, see   */   then do;                                      /* if type is poly     */      /* At this point, we just set up some global information.  We     */      /* do not start any scrub output until the first time we          */      /* get a mouse movement                                           */      if Get.Event.HZ.Information(event, info) <> TRUE /* get hz info avail   */      then return(TRUE);      if (packet(4) <> 0)                        /* test callers extend mode */      then info(Hzinfo.extend) = 1;              /* allow scrubbing of entire sound file */      else info(Hzinfo.extend) = 0;              /* limit scrubbing to event only */      if Initialize.for.POLY.Scrubbing(loc(addr(Event(event.cue.name))),                                       info) = TRUE      then do;			Scrub.Type = 3;                         /* indicate poly scrub */			interpret_set_timebase_mode(-Scrub.Type);		end;		      /* Save away the event time so we can compute the relative        */      /* mouse position:                                                */      call COPY32(loc(addr(Event(Event.Time.Msb))), Scrub.Start);      Scrub.Delay = info(0);      return(TRUE);                              /* Nothing more to do  */   end;   if  (Event(event.type) <> event.type.cue  )   /* for now, only scrub */   and (Event(event.type) <> event.type.event)   /* dtd cues/events     */   then return(TRUE);   if dtd.max.secs = 0       /* Make sure the DTD is up and running to  */   then return(TRUE);        /* dtd DTD event scrubbing                 */   call Prepare.DTD.For.Cue.Scrubbing;           /* tell DTD to get rdy */   Scrub.Type = 2;    /* indicate event VS sequence scrubbing           */	interpret_set_timebase_mode(-Scrub.Type);   if Is.DTD.Ready.For.Cue.Stacking = TRUE then do;      call Send.Event.To.DTD.Scrub.Stack(event, 1);    /* Stack on DTD with extend */      Events.Stacked = TRUE;   end;   else do;    /* DTD is not ready; remember the event for later use    */      write(MAM) = Scrub.Ptr;      call Copy.Out(addr(event(0)),Event.Record.Size);   end;   return(TRUE);                              /* Nothing more to do */end Start.Event.Scrubbing;Process.Play.Event: proc (packet) swapable;   dcl packet         array;   dcl i              fixed;   dcl event (Event.Record.Size-1) fixed;     /* Event record */   if  (packet(0) = (-1))          /* track is (-1)    */   and (packet(1) = (-1))          /* time  is (-1)    */   and (packet(2) = (-1))   and (packet(3) = (-1))          /* count is (-1)    */   then do;                        /* means stop auditioning */      call Stop.Event.Auditions;      return (TRUE);               /* done with packet */   end;   call add16(ZERO.TIME,loc(addr(packet(1))));/* Add "ZERO.TIME" offset */   packet(0) = proto.to.sync.strk(packet(0)); /* Convert track number   */   if packet(0) = -1                          /* was not a Synclavier trk */   then return(TRUE);   do i=0 to (Spointer.Record.Size - 1);      /* Get event ID passed in */      event(i) = packet(i);                   /* Trk#, Seq_time, Count  */   end;   if  (Stop.Info.Cues <> 0)                  /* about to squelch cue auditions */   and (Trk.Head.Lookup(packet(0),thd.cue.track)<>0) /* but want to trigger new cues */   then Stop.Info.Cues = 0;                   /* just clear the flag */   /* If we can exactly find the event being referenced, play it */   if Get.Sequencer.Event.Information(event) = Good.Event.Status   then call Trigger.Event.For.Audition(event);   else call Stop.Event.Auditions;            /* what the heck - stop other auditions */   return(TRUE);                              /* Nothing more to do */end Process.Play.Event;Send.Audition.Mode: proc (packet,des) swapable;   dcl packet array;   dcl des    fixed;   dcl Current.Cue.Audition fixed external;   write(mam) = misc.ptr;      write(mdi) = L#Audition_Mode;   write(mdi) = des;   write(mdi) = T#Audition_Mode;   write(mdi) = packet(0);         /* Tag */   write(mdi) = shl(Current.Cue.Audition,8);   if not Send.Protocol.Packet(misc.ptr,1)   then do;                        /* no room in protocol output buffer now */      return(FALSE);               /* try again later                       */   end;   return(TRUE);                   /* success */end Send.Audition.Mode;Handle.Playback: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* Assume ok unless someone returns a specific error */   if subtype < 16   then do case subtype;         /* Branch on specific command (0-15) */      do;  /* 0:  Play */         ret = Process.Play.Command;      end;      do;  /* 1:  Stop */         ret = Process.Stop.Command;      end;      do;  /* 2:  Rewind */         ret = Process.Rewind.Command;      end;      do;  /* 3:  Fast Forward */         ret = Process.Fast.Forward.Command;      end;      do;  /* 4:  Locate */         ret = Process.Locate.Command(packet,des);      end;      do;  /* 5: Request Motion Status */         ret = Send.Motion.Status.Packet(packet,des);      end;      do;  /* 6: Motion Status */         /* This is handled by the request routine */         /* Nobody ever tells us what our motion status is! */      end;   end;             /* of branch on specific command (0-15) */   else if subtype < 32   then do case (subtype - 16);  /* Branch on specific command (16-31) */      do;  /* 16: Play Cue */         call Load.DTD.Temp.Cue        (Current.Cue.Ptr);         call Play.Protocol.Current.Cue(1,0,0,Current.Cue.Drive.Bits,1); /* play start to end of cue */      end;      do;  /* 17: Play Edit */         ret = Process.Play.Edit.Command(packet,len=(Able_Packet_Head+2));      end;      do;  /* 18: Play From */         ret = Process.Play.From.Command(packet,len=(Able_Packet_Head+2));      end;      do;  /* 19: Play To */         ret = Process.Play.To.Command(packet,len=(Able_Packet_Head+2));      end;      do;  /* 20: Pause/Continue - for now only applies to DTD */         if DTD.Play.State <> 0 then do;  /* If doing DTD playing, stop */            call STOP.DTD.PLAY.STATE;     /* it.                        */         end;         else do;  /* We are not playing; continue */            call Load.DTD.Temp.Cue(Current.Cue.Ptr);            call Play.Protocol.Current.Cue(0,0,4,Current.Cue.Drive.Bits,1); /* current position play to smart limit */         end;      end;      do;  /* 21: Stop DTD activity (for example: stop scrubbing) */         call STOP.DTD.PLAY.STATE;      end;   end;             /* of branch on specific command (16-31) */   else if subtype < 48   then do case (subtype - 32);  /* Branch on specific command (32-47) */      do;  /* 32: Start scrubbing the sequence */         ret = Start.Sequence.Scrubbing(packet);      end;      do;  /* 33: Scrub to a new sequencer point */         ret = Scrub.To.New.Time(packet);      end;      do;  /* 34: Terminate sequence scrubbing */         ret = Stop.Sequence.Scrubbing(packet);      end;      do;  /* 35: Scrub current cue */         ret = Process.Scrub.Cue.Command(packet);      end;      do;  /* 36: Scrub current cue by time */         ret = Process.Scrub.Cue.By.Time(packet,des);      end;      do;  /* 37: Start Event Scrubbing */         ret = Start.Event.Scrubbing(packet);      end;   end;             /* of branch on specific command (32-47) */   else if subtype < 64   then do case (subtype - 48);  /* Branch on specific command (48-63) */      do;  /* 48: Play Event */         ret = Process.Play.Event(packet);      end;   end;             /* of branch on specific command (48-63) */   else if subtype < 80   then do case (subtype - 64);  /* Branch on specific command (64-79) */      do;  /* 64: Request DTD Audition Mode */         ret = Send.Audition.Mode(packet,des);      end;      do;  /* 65: Send DTD Audition Mode */         /* This is handled by the request routine */      end;      do;  /* 66: Set DTD Audition Mode */         call ASSIGN.NEW.DTD.AUDITION(shr(packet(0),8));      end;   end;             /* of branch on specific command (64-79) */   else if subtype < 96   then do case (subtype - 80);  /* Branch on specific command (80-95) */      do;  /*  80: audition data structure */         ret = Access.Data.Structure(packet,des,DS_ACCESS_AUDITION);      end;   end;             /* of branch on specific command (80-95) */   return(ret);             /* return processed status */end Handle.Playback;