/* EMULATE   $TITLE  Emulator / Debugger for protocol packets   Modified:   03/01/91 - MWH - Fix Karim's newline bug in print_packet   05/24/90 - MWH - Add Karim's HEX logging routines   05/21/90 - MWH - Improve D115 diagnostic logging   01/29/90 - MWH - Always dump crash requests in full, if special mode set   09/20/89 - MWH - Do both parts of crash msgs to fix intermittent download   08/23/89 - MWH - Rework the protocol for release 2.2   06/29/89 - MWH - Create output as well as input packets   06/01/89 - MWH - Dump channel mapping table on request   05/02/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/14/89 - PF  - changed process packet processing logic   12/02/88 - MWH - Put RYO message in more sensible order   11/10/88 - MWH - Clean up messages and update lengths   10/14/88 - MWH - Add RS422 driver   09/23/88 - MWH - Incorporate emulator into the full system   09/21/88 - MWH - Author   */dcl Em.addr     fixed;          /* Destination address for packets coming from this emulator (0 = none) */dcl Log.Crashes fixed;          /* Log all crash packets */dcl Log.Format  fixed public;   /* Log in HEX or DECIMAL */Protocol.Emulator: proc public swapable;   dcl ch      fixed;   dcl val     fixed;   dcl len     fixed;   dcl i       fixed;   dcl ptr     fixed;   dcl status  fixed;   dcl output  fixed static;   dcl sr      fixed;   insert ':synlits:asciilit';   insert ':synmods:mousrdcl';   insert ':synmods:plotdcl';    insert ':synmods:tprimdcl';   insert ':synmods:tformdcl';   if inc.trap.dbug = 0 then return;   prompt: proc;      dcl ch fixed;      call cpos(23,0);                   /* Move to bottom line of screen */      call pc(27); call ps('[K');        /* Erase it */      call ps('>>>');                    /* Prompt */      call tty_wait;		disable;      ch = read("050");                  /* Get a character */		enable;      if ch >= l.a and ch <= l.z         /* Lower case? */      then ch = ch - "040";              /* Make it upper case */      return ch;   end prompt;   log.cmd: proc(msg);      dcl msg fixed array;      if (Allow.Proto.Msgs & "7") > 0      then call ps(msg);   end log.cmd;   get.num: proc recursive;      dcl ch   fixed;      dcl num  fixed;      dcl sign fixed;      dcl echo boolean;      call tty_wait;      sign = 1;      do while ch <> a.cr;			disable;         ch = read("050");               /* Get a character */			enable;         echo = true;                    /* Assume we echo it */         if      ch = a.minus then sign = -1;         else if ch = a.plus  then sign =  1;         else if ch >= a.0 and ch <= a.9         then num = (num * 10) + (ch - a.0);         else if ch = a.del              /* Delete a digit */         AND num <> 0 then do;            num = num / 10;            write("050") = a.bs;            write("050") = a.sp;            write("050") = a.bs;         end;         else echo = false;         if echo = true         then write("050") =ch;          /* Echo character */      end;      return (num * sign);   end get.num;   protocol.trap = 0;                    /* Reset flag that gets us here */   sr      = run.syn;   run.syn = 0;   call push.graphics.attributes;   transparent_mode;   DISABLE;   if  ((Packet.Free.Ptr = Packet.Ptr)   /* buffer is full */   and (Protocol.Packet.There = 1))      /* (not empty)    */   then do;                              /* bail out       */      i = 0;      do while i<200;  /* try to clear things out so the user can type a command */         ENABLE;         call process.protocol.message;         DISABLE;         if  ((Packet.Free.Ptr = Packet.Ptr)   /* buffer is still full? */         and (Protocol.Packet.There = 1))      /* (not empty)    */         then i = i + 1;                       /* try again */         else i = 1000;                        /* we now have room */      end;      if i <> 1000 then do;                    /* we never found room */         ENABLE;         call cpos(23,0);         call pc(27); call ps('[K');         call ps('!!! Oops - The buffer is full.  Try again later... ');         call tty_wait;         call pop.graphics.attributes;         call tty_wait;         run.syn = sr;         return;      end;   end;   /* Now allocate a sector while we are still disabled */   /* so the interrupt doesn't take it away             */      ptr = Packet.Free.Ptr;            /* temp copy of free ptr */   Protocol.Packet.There = 1;        /* buffer about to be non-empty */   Packet.Free.Ptr = Packet.Free.Ptr + 1;   /* increment pointer */   if Packet.Free.Ptr = Packet.Bas.Ptr + Sizeof.Packet.Buf   then Packet.Free.Ptr = Packet.Bas.Ptr;   /* wrap pointer */     /* disable all d115d interrupts in case we want to restore Packet.Free.Ptr */     do i=0 to (num.d115d.bds - 1);           /* Loop over boards */      write(cpsel) = cp#sel_group_20 | i;   /* First group of boards, board "i" */      write(cpcmd) = cp#disable_rx;         /* Disable all receive interrupts */   end;     d115d.ints.enabled = false;   ENABLE;   status = 0;             /* assume this sector will not be used */   ch = prompt;   do while ch = a.question;             /* List commands */      call clear.term;      call ps('Press a character to send one of these messages (space = NOP):');           call pcr;      call ps(' . = Build your own packet');                                               call pcr;      call pcr;      call ps(' P = Play                 R = Start Record         Y = Sync Mode');         call pcr;      call ps(' S = Stop                 / = Start Punch');                                call pcr;      call ps(' < = Rewind               X = Stop Record');                                call pcr;      call ps(' > = Fast Forward');                                                        call pcr;      call ps(' L = Locate               D = Download D115');                              call pcr;      call pcr;      call ps(' ( = Specify device');                                                      call pcr;      call ps(' C = Dump D115 chans      H = Print next HereIs');                          call pcr;      call ps(' + = Verbose messages     I = Build Input msgs');                           call pcr;      call ps(' _ = Brief   messages     O = Build Output msgs');                          call pcr;      call ps(' = = ALL crash msgs       * = Show data log in HEX');                       call pcr;      call ps(' - = No      messages');                                                    call pcr;      call ps(' [ = Input   messages');                                                    call pcr;      call ps(' ] = Output  messages');                                                    call pcr;      call pcr;      ch = prompt;   end;   write(MAM) = ptr;  /* Zero out packet sector */   RPC 256;   write(MDI) = 0;   if ch = a.p then do;      call log.cmd('Play');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Play;            /* Bytes in packet from P#Type on down */      write(MAL) = P#Source;  write(MD)  = em.addr;           /* Source node */      write(MAL) = P#Type;    write(MD)  = T#Play;            /* Packet super & sub type codes */      write(MAL) = P#Data;    write(MDI) = 0;                 /* Other data */      status = 1;                                             /* We now have a packet */   end;   else if ch = a.c then do;   /* Dump D115 channel allocation list */      call cpos(23,0);      call pc(27); call ps('[K');      call ps('D115D channels: ');      if num.d115d.bds > 0      then do i=0 to (shl(num.d115d.bds,1) - 1);         if i <> 0 then call ps(', ');         call pnum(d115d.chans(i),0);      end;      else call ps('none, num.d115d.bds = 0');   end;   else if ch = a.h then do;   /* Allow another "here-is" to print */      hereis.printed = 0;                   end;   else if ch = a.d then do;      call cpos(23,0);      call pc(27); call ps('[K');      call ps('!!! Reload D115 firmware from disk [0=NO, 1=YES]: ');      if get.num = 1 then do;         call log.cmd('Reload D115');         Packet.Free.Ptr = ptr;            /* restore free ptr */         if Packet.Free.Ptr = Packet.Ptr   /* buffer is empty  */         then Protocol.Packet.There = 0;   /* reset flag       */         /* D115 interrupts are enabled by the following routine */         call INIT.D115;      end;   end;   else if ch = a.s then do;      call log.cmd('Stop');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Stop;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Stop;      status = 1;   end;   else if ch = a.less then do;      call log.cmd('Rewind');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Rewind;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Rewind;      status = 1;   end;   else if ch = a.greater then do;      call log.cmd('Fast Forward');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Fast_Forward;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Fast_Forward;      status = 1;   end;   else if ch = a.l then do;      call cpos(23,0);                   /* Move to bottom line of screen */      call pc(27); call ps('[K');        /* Erase it */      call log.cmd('Locate - ');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Locate;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Locate;      write(MAL) = P#Data;      val = -1;      do while val < 0 or val > 4;         call ps('Enter 0=Abs note, 1=Rel note, 2=Abs time 3=Rel time, 4=Mark# :');         val = get.num;         call cpos(23,0);                /* Move to bottom line of screen */         call pc(27); call ps('[K');     /* Erase it */      end;      write(MDI) = val;      call ps('Enter sequencer position value (MSB): ');      val = get.num;      write(MDI) = val;      call cpos(23,0);      call pc(27); call ps('[K');      call ps('Enter sequencer position value (LSB): ');      val = get.num;      write(MDI) = val;      status = 1;   end;   else if ch = a.r then do;      call log.cmd('Start Record');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Start_Record;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Start_Record;      status = 1;   end;   else if ch = a.slash then do;      call log.cmd('Start Punch');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Start_Punch;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Start_Punch;      status = 1;   end;   else if ch = a.x then do;      call log.cmd('Stop Record');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Stop_Record;      write(MAL) = P#Source;  write(MD)  = em.addr;          write(MAL) = P#Type;    write(MD)  = T#Stop_Record;      status = 1;   end;   else if ch = a.y then do;             /* Sync mode */      call cpos(23,0);                   /* Move to bottom line of screen */      call pc(27); call ps('[K');        /* Erase it */      call log.cmd('Set sync - ');      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = L#Set_Sync_Mode;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = T#Set_Sync_Mode;      write(MAL) = P#Data;      val = -1;      do while val < 0 or val > 5;         call ps('Enter 0=Internal, 1=50HZ, 2=Beat, 3=MIDI, 4=SMPTE, 5=VITC:');         val = get.num;         call cpos(23,0);                /* Move to bottom line of screen */         call pc(27); call ps('[K');     /* Erase it */      end;      write(MDI) = val;      if val=3 then do;                  /* Second data word for MIDI */         val = -1;         do while val < 0 or val > 1;            call ps('Enter 0=MIDI IN, 1=MIDI AUX:');            val = get.num;            call cpos(23,0);                /* Move to bottom line of screen */            call pc(27); call ps('[K');     /* Erase it */         end;         write(MDI) = val;      end;      else if val=4 then do;             /* Second data word for SMPTE */         val = -1;         do while val < 0 or val > 3;            call ps('Enter 0=30fps Drop, 1=30fps Non-drop, 2=25fps, 3=24fps:');            val = get.num;            call cpos(23,0);                /* Move to bottom line of screen */            call pc(27); call ps('[K');     /* Erase it */         end;         write(MDI) = val;      end;      status = 1;   end;   else if ch = a.i then do;             /* Building input packets */      output = 0;      call ps('Building INPUT packets');   end;   else if ch = a.o then do;             /* Building output packets */      output = 1;      call ps('Building OUTPUT packets');   end;   else if ch = a.star then do;          /* Change output format */      call ps('Data packets logged in: ');      Log.Format = Log.Format XOR 1;      if (Log.Format <> 0)      then call ps('HEX');      else call ps('DECIMAL');   end;   else if ch = a.period then do;        /* Build your own packet */      call cpos(23,0);                   /* Move to bottom line of screen */      call pc(27); call ps('[K');        /* Erase it */      call log.cmd('Build own ');      if output = 0 then call log.cmd('INPUT');      else               call log.cmd('OUTPUT');      call log.cmd(' packet - ');      call ps('Enter super-type: ');      val = shl(get.num,8);      call cpos(23,0);                /* Move to bottom line of screen */      call pc(27); call ps('[K');     /* Erase it */      call ps('Enter sub-type: ');      val = val | (get.num & "377");      call cpos(23,0);                /* Move to bottom line of screen */      call pc(27); call ps('[K');     /* Erase it */      call ps('Enter network byte length of msg: ');      len = get.num + 4;      write(MAM) = ptr;      write(MAL) = P#Len;     write(MD)  = len;      write(MAL) = P#Source;  write(MD)  = em.addr;      write(MAL) = P#Type;    write(MD)  = val;      write(MAL) = P#Data;      do i=1 to (shr(len+1,1) - 3);         call cpos(23,0);         call pc(27); call ps('[K');         call ps('Enter data word: ');         write(MDI) = get.num;      end;      if output = 0 then do;       /* Built an input packet */         status = 1;               /* We have it in external memory */      end;      else do;                     /* Built an output packet */         if send.protocol.packet(ptr,1) = FALSE then do;            call cpos(23,0);            call pc(27); call ps('[K');            call ps('FAILED TO SEND!');         end;      end;   end;   else if ch = a.lparen then do;      call cpos(23,0);      call pc(27); call ps('[K');      call ps('Enter device (0=Able,16=MAC,32=DESC,48=MIDI), current is: ');      call pnum(em.addr,0);      call ps(', new value: ');      em.addr = get.num;   end;   else if ch = a.plus then do;      if  (Allow.Proto.Msgs & "140000") = 0      then Allow.Proto.Msgs = Allow.Proto.Msgs \ "140000";      call ps('Verbose messages');      Allow.Proto.Msgs = (Allow.Proto.Msgs & "140000") | 2;   end;   else if ch = a.score then do;      if  (Allow.Proto.Msgs & "140000") = 0      then Allow.Proto.Msgs = Allow.Proto.Msgs \ "140000";      call ps('Brief messages');      Allow.Proto.Msgs = (Allow.Proto.Msgs & "140000") | 1;   end;   else if ch = a.minus then do;      call ps('Disable messages');      Allow.Proto.Msgs = (Allow.Proto.Msgs & "140000") | 0;   end;   else if ch = a.equals then do;      call ps('Crash message & "super-type F0" logging: ');      Log.Crashes = Log.Crashes XOR 1;      if (Log.Crashes <> 0)      then do;         call ps('ON');         Allow.Proto.Msgs = Allow.Proto.Msgs | "040000";  /* Be sure input logging is on */      end;      else call ps('OFF');   end;   else if ch = a.lbracket then do;        /* [ */      call ps('Input printing = ');      Allow.Proto.Msgs = Allow.Proto.Msgs XOR "040000";      if (Allow.Proto.Msgs & "040000") <> 0      then call ps('ON');      else call ps('OFF');   end;   else if ch = a.rbracket then do;       /* ] */      call ps('Output printing = ');      Allow.Proto.Msgs = Allow.Proto.Msgs XOR "100000";      if Allow.Proto.Msgs < 0      then call ps('ON');      else call ps('OFF');   end;   /* We've finished whatever we're going to do on cmd line, echo <CR> */   call ps('<-');   if status = 1                         /* We have a packet */   AND (Allow.Proto.Msgs & "7") >= 2     /* We're allowed to dump it */   then do;      call pcr;      call ps('External memory at Packet.Free.Ptr:');       call pcr;      write(MAM) = ptr;             len = read(MDI);      call ps('Length      = ');    call pnum((len-4),0);   call pcr;      call ps('Source node = ');    call pnum(read(MDI),0); call pcr;      i = read(MDI);      call ps('Super  type = ');    call pnum(shr(i,8), 0); call pcr;      call ps('Sub    type = ');    call pnum(i & "377",0); call pcr;      do i=1 to (shr(len+1,1) - 3);         call ps('Data word   = '); call pnum(read(MDI),0); call pcr;      end;   end;   if status = 0 then do;         /* we never got a packet */      Packet.Free.Ptr = ptr;      /* restore free ptr */      if Packet.Free.Ptr = Packet.Ptr   /* buffer is empty */      then Protocol.Packet.There = 0;   /* reset flag      */   end;   /* now enable d115 interrupts ONLY IF buffer is not full! */   DISABLE;   if (Packet.Free.Ptr <> Packet.Ptr)       	/* not full */   or (Protocol.Packet.There = 0)           	/* empty    */   then do;      do i=0 to (num.d115d.bds - 1);      		/* Loop over boards   */         write(cpsel) = cp#sel_group_20 | i;   	/* First group of boards, board "i" */         write(cpcmd) = cp#enable_rx_a;        	/* Enable Rx interrupt on condition A (packet present) */      	 d115d.ints.enabled = true;	  end;   end;   ENABLE;   call pop.graphics.attributes;   call tty_wait;   run.syn = sr;   return;end Protocol.Emulator;/* $page - routines output the packet data in hexadecimal */phex: proc(n) swapable; /* output byte in hex */   dcl n fixed;   phex1: proc(n);      dcl n fixed;      n = (n and "17");      if n >= 10 then call pc(n - 10 + a.a); else call pc(n + a.0);   end phex1;   call phex1 (shr(n, 4));   call phex1 (n);end phex;print_packet: proc(packet, len) public swapable; /* print data section of packet */   dcl packet pointer; /* pointer to packet data */   dcl len    fixed; /* byte length of packet data */   dcl word   fixed; /* next word from packet */   dcl i      fixed;   do i = 0 to len - 1; /* print all of the data */      word = core(packet + i/2);      if i /* print LS second */      then call phex (word);      else call phex (shr(word, 8)); /* and MS first */      if (i + 1) mod 16 = 0 /* put sixteen across on a line */      then call pcr;      else call pc(a.sp);   end;   if len mod 16 <> 0 /* if need final newline */   then call pcr;end print_packet;/* $page - routine to log incoming messages to terminal */log.input.message: proc(ptr) public swapable;   dcl ptr   fixed;                  /* Where in external memory to read the data */   dcl len   fixed;                  /* Length of packet in bytes */   dcl type  fixed;   dcl super fixed;   dcl i     fixed;   dcl sr    fixed;   if inc.trap.dbug = 0 then return;   if (Allow.Proto.Msgs & "7") = 0   /* if no actual input logging then */   AND Log.Crashes = 0   then return;                      /* quit early.                     */   /* Cannot do any logging if we are (at the moment) called from */   /* PC itself:                                                  */   if disable.protocol.output <> 0   then return;   /* Print lines something like: */   /* [Input]  Super = 12, Sub = 8, len = 2, node = 32  <*IGNORED*> */   write(MAM) = ptr;                  /* Copy data from external memory */   call copy.in(addr(misc.buf(0)),256);   len   = misc.buf(P#Len);   type  = misc.buf(P#Type);   if type = T#Net_Here_Is            /* Don't log R-Box "here I am" message */   then do;      if hereis.printed <> 0 then return;     /* Unless we NEVER have */      else hereis.printed = 1;                /* OK, once is enough! */   end;   sr = run.syn;   run.syn = 0;   super = shr(type,8);   call tty_wait;   if (Allow.Proto.Msgs & "7") >= 1     /* Brief log of input */   OR (Log.Crashes <> 0   AND   (type = T#Net_Crash_Part1)   OR    (type = T#Net_Crash_Part2)   OR    (super = P#LOCAL))   then do;      call cpos(22,0);                  /* Move to next to bottom line of screen */      if (Allow.Proto.Msgs & "7") = 1      then do;         call pc(27); call ps('[K');    /* Erase it */      end;      else call pcr;      call ps('[Input] ');      call ps(' Super = ');     call pnum(super,0);      call ps(', Sub  = ');     call pnum(type & "377",0);      call ps(', len = ');      call pnum((len-4),0);      call ps(', node = ');     call pnum(misc.buf(P#Source),0);      if misc.buf(P#Source) <= 0      AND type <> T#Net_Here_Is               /* But don't worry about a "here-is" */      AND type <> T#Net_Crash_Part1           /* (this is also treated as a "here-is") */      AND type <> T#Net_Crash_Part2           /* (we need both parts of the crash msg) */      then call ps('  <*IGNORED*>');   end;   if (Allow.Proto.Msgs & "7") >= 2           /* Full dump of input packet */   OR (Log.Crashes <> 0   AND   (type = T#Net_Crash_Part1)   OR    (type = T#Net_Crash_Part2)   OR    (super = P#LOCAL))   then do;      call pcr;      if Log.Format = 0 then do;              /* Log in decimal */         do i=0 to (shr(len+1,1) - (P#Data + 1));            call pc(27); call ps('[K');          /* Erase line */            call ps('   Data word = '); call pnum(misc.buf(i+P#Data),0);            call pcr;         end;      end;      else do;         call print_packet(addr(misc.buf(P#Data)),len - (shl(P#Data,1)));      end;   end;   call tty_wait;   run.syn = sr;end log.input.message;