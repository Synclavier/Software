/* TRAPRET  $TITLE  ROUTINES TO PROCESS RETRIEVAL PACKETS   Modified:   03/18/91 - MWH - Request DTD project name and number   10/15/90 - CJ  - Moved some stuff to trapret2   08/24/89 - MWH - Rework the protocol for release 2.2   03/14/89 - PF  - changed process packet processing logic   11/28/88 - MWH - Clean up unreferenced public's   11/10/88 - MWH - Clean up messages and update lengths   09/15/88 - PF - Created this source file*//* The following literals define the file types that are returned *//* over the protocol.  They are both "file types" and "data       *//* structure types",  since many of the data structures are not   *//* actual files.                                                  */dcl T#Cue          lit '  0';    /* DTD Cue                  */dcl T#Snd          lit '  1';    /* Sound file               */dcl T#Tim          lit '  2';    /* Synclavier Timbre        */dcl T#Seq          lit '  3';    /* Synclavier Sequence      */dcl T#Dir          lit '  4';    /* Directory                */dcl T#Opt          lit '  5';    /* NED Opt Disk Index File  */dcl T#Unk          lit '256';    /* Unknown data file        */dcl T#AbleDir      lit '257';    /* Able directory           */dcl T#NedWorm      lit '258';    /* NED Optical WORM         */dcl T#DTDProj      lit '259';    /* DTD Project Dir Entry    */dcl T#DTDTrackDir  lit '260';    /* DTD Track Directory      */dcl T#Raw16Audio   lit '261';    /* Raw 16 bit audio         *//* Routine to send out a Directory Key */Send.Directory.Key: proc (des,tag,status,id#,index#,maxindex#,type,name) swapable;   dcl des       fixed;   /* destination node                            */   dcl tag       fixed;   /* message tag #                               */   dcl status    fixed;   /* status word to return                       */   dcl id#       fixed;   /* cue id#                                     */   dcl index#    fixed;   /* index# in directory (0 - maxindex#-1)       */   dcl maxindex# fixed;   /* # of entries in index                       */   dcl type      fixed;   /* type of entry (0 = cue)                     */   dcl name      array;   /* NED format name string.                     */   dcl i         fixed;   write(mam) = misc.ptr;      write(mdi) = L#Directory_Key + name(0);   write(mdi) = des;   write(mdi) = T#Directory_Key;   write(mdi) = tag;             /* word: message tag                    */   write(mdi) = status;          /* word: status code                    */   write(mdi) = 0;               /* long:                                */   write(mdi) = id#;             /*       cue id#                        */   write(mdi) = 0;               /* long:                                */   write(mdi) = index#;          /*       entry index #                  */   write(mdi) = 0;               /* long:                                */   write(mdi) = maxindex#;       /*       # of entries in index          */   write(mdi) = type;            /* word: type                           */   /* Append a trailing null to the NED string to convert to a C string  */   call pbyte(name, name(0), 0);   do i = 1 to shr(name(0) + 2, 1);  /* write out trailing null! */      write(mdi) = rot(name(i),8);   end;   return(Send.Protocol.Packet(misc.ptr,1));end Send.Directory.Key;/* This routine (for starters) is used to get at the cue directory *//* information                                                     */Request.Directory.Key.By.Name: proc (packet,des) swapable;   dcl packet     array;   dcl des        fixed;   dcl tag        fixed;   dcl index      fixed;   dcl project    fixed;   dcl filter     fixed;   dcl callup     fixed;   dcl match      fixed;   dcl name(18)   fixed;  /* 18 to convert to C string in place */   dcl pname(18)  fixed;  /* Project name */   dcl indexcode  fixed;   dcl status     fixed;   dcl id#        fixed;   dcl index#     fixed;   dcl maxindex#  fixed;   dcl type       fixed;   dcl err        fixed;   dcl (i,j)      fixed;   tag     = packet(0);             /* get tag                        */   index   = shr(packet(1),8);      /* get index code                 */   project = packet(1) & "377";     /* 0=cur proj, 1=all proj         */   filter  = packet(2);             /* none=all, 1=cue, 2=snd file, 4=timb, 8=seq, 16=dir/proj */   callup  = shr(packet(3),8);      /* which index                    */   match   = packet(3) & "377";     /* 0=exact, 1=partial, 2=IGE      */   /* Extract the string name */   do i = 1 to 17;                  /* be sure to get trailing null   */      name(i) = rot(packet(3+i),8); /* byte swap the C string         */   end;   i = 0;   do while (i < 32) and (byte(name,i) <> 0);      i = i + 1;   end;   name(0) = i;   /* Set up for search of directory */   status    = 1;   /* assume status is initally 'not found' */   id#       = 0;   index#    = 0;   maxindex# = 0;   err       = 0;   /* no errors yet */   /* make sure arguements are valid for cue directory search    */   if ((name(0) = 0)       /* no name (use spaces) - not allowed  */   AND (filter = 1))       /* when asking about CUE */   OR (index   < 0)        /* present error message               */   OR (index   = 2)        /* if any argument is out of           */   OR (index   = 3)        /* range.                              */   OR (index   = 4)   OR (index   > 5)   OR (project < 0)   OR (project > 1)   OR ((filter <> 1)       /* For now, we only support "cue"...   */   AND (filter <> 16))     /* ...or "project"                     */   OR (callup  < 0)   OR (callup  > 1)   OR (match   < 0)   OR (match   > 2)   OR ((match  > 0)        /* ALSO - must be using ALPHA index if */   AND (index <> 0))       /* partial name search                 */   OR (DTD.MAX.SECS = 0)   /* No DTD at all */   then do;      err = 1;             /* error */   end;   /* Else check info and look further */   /* Cue case */   if (err = 0) AND (filter = 1) then do;      type = 0;                                /* cue */      /* Set up index code */      if      index = 0 then indexcode = 0;    /* set up 0 = total alpha */      else if index = 1 then indexcode = 1;    /*        1 = total disk  */      else                   indexcode = 2;    /*        2 = total sync  */                                               /*        3 = cp    alpha */      if project = 1                           /*        4 = cp    disk  */      then indexcode = indexcode + 3;          /*        5 = cp    sync  */      /* Fetch system info to get # of cues defined */      call FETCH.DTD.SYSTEM.INFO;      if project = 0                   /* all projects               */      then maxindex# = dtd.num.cues;   /* get total # of cues        */      else maxindex# = dtd.cp.cues;    /* get curr project cues      */      call SET.DTD.SCROLL.RANGE(project); /* set scroll range so     */                                          /* dtd knows how to do     */                                          /* index computation.      */      if match = 0                     /* if looking for exact match */      then do;                         /* then do so                 */         call LOCATE.DTD.CUE(name);         id#  = DTD.CUE#;              /* save possible cue id#      */         if id# <> 0 then do;          /* if found - set status      */            status  = 0;               /* indicate found             */            index#  = FETCH.DTD.CUE.INDEX(indexcode);         end;      end;      else do;                         /* partial, or >              */         /* If partial name match - look for first dtd cue with      */         /* partial match.   Return id# = 0 if there is no cue       */         /* with a partial match:                                    */         if match = 1         then call LOCATE.PARTIAL.NAME.DTD.CUE(name, 0);         /* Else if finding first cue with name >= the passed        */         /* name, then do so:                                        */         else call LOCATE.PARTIAL.NAME.DTD.CUE(name, 1);         id#     = DTD.CUE#;           /* return the id              */         index#  = FETCH.DTD.CUE.INDEX(indexcode);         if id# <> 0                   /* if anything found          */         then do;            status  = 0;               /* good status                */            call FETCH.DTD.CUE (id#, misc.buf);  /* get actual name  */            call BLOCKMOVE(loc(addr(misc.buf(CUE.NAME))), name, 17);         end;      end;      if  (id#    <> 0)    /* if cue was found   */      and (callup <> 0)    /* and should call up */      then do;         call SET.DTD.CURRENT.REEL(0);     /* select "cue"             */         call Fetch.Entire.DTD.Cue(id#,Current.Cue.Ptr);         call Deposit.A.New.Current.Cue(1);         call UnSet.Cue.Modified;      end;   end;   /* Project case */   else if (err = 0) AND (filter = 16) then do;      type = 4;                                /* DTD Project */      maxindex# = 49;                          /* For now */      if name(0) <> 0 then do;                 /* We need to look for a matching project name */         do i=0 to 49;                         /* Look at all possible projects */            call Fetch.DTD.Song.Directory(i);            write(MAM) = SCSI.PTR;            write(MAL) = 1;            do j=1 to 12;               pname(j) = read(MDI);            end;            do j=0 to 23;               if  byte(pname,j) > "40"        /* Greater than space */               AND byte(pname,j) < "177"       /* Less than "delete" */               then pname(0) = j + 1;          /* Remember last valid char as string length */            end;            if eqstr(name,pname) = 0 then do;  /* Found a match */               status = 0;                     /* Success */               index# = i;                     /* Remember project number */               i = 100;                        /* Break out of search loop */            end;         end;         if  (status = 0)     /* If project was found...  */         and (callup <> 0)    /* ...and should call it up */         then do;            call Ask.For.DTD.Current.Project(index#);         end;         else call Set.Up.AEE.DTD.Globals;     /* Only reset globals */      end;      else do;          /* Asking about the current project only */         call Set.Up.AEE.DTD.Globals;          /* Set up globals */         index# = AEE.Current.Project;         call Copy.String(AEE.Current.Project.Name,name);         do j=0 to 23;            if  byte(name,j) > "40"        /* Greater than space */            AND byte(name,j) < "177"       /* Less than "delete" */            then name(0) = j + 1;          /* Remember last valid char as string length */         end;         status = 0;                              /* Success */      end;   end;   /* of project case */   return Send.Directory.Key(des, tag, status, id#, index#, maxindex#, type, name);end Request.Directory.Key.By.Name;Request.Directory.Key.By.Index: proc (packet,des) swapable;   dcl packet        array;   /* pass incoming packet    */   dcl des           fixed;   /* node for destination    */   dcl tag           fixed;   dcl index#        fixed;   dcl sort          fixed;   dcl project       fixed;   dcl filter        fixed;   dcl callup        fixed;   dcl name(18)      fixed;  /* 18 to convert to C string in place */   dcl indexcode     fixed;   dcl status        fixed;   dcl id#           fixed;   dcl maxindex#     fixed;   dcl type       fixed;   dcl err        fixed;   dcl j          fixed;   tag       = packet(0);             /* get message tag         */   index#    = packet(2);             /* LONG index#             */   sort      = shr(packet(3),8);      /* get index code          */   project   = packet(3) & "377";     /* 1 = cur proj only       */   filter    = packet(4);             /* none=all, 1=cue, 2=snd file, 4=timb, 8=seq, 16=dir/proj */   callup    = shr(packet(5),8);      /* 1 = call up             */   status    = 1;       /* assume status is initally 'not found' */   id#       = 0;   maxindex# = 0;   name(0)   = 0;   if (sort    < 0)   OR (sort    = 2)   OR (sort    = 3)   OR (sort    = 4)   OR (sort    > 5)   OR (project < 0)   OR (project > 1)   OR ((filter <> 1)       /* For now, we only support "cue"...   */   AND (filter <> 16))     /* ...or "project"                     */   OR (callup  < 0)   OR (callup  > 1)   OR (DTD.MAX.SECS = 0)   /* No DTD at all */   then do;      err = 1;             /* error */   end;   /* Cue case */   if (err = 0) AND (filter = 1) then do;      type = 0;                                /* cue */      if      sort = 0 then indexcode = 0;     /* set up 0 = total alpha */      else if sort = 1 then indexcode = 1;     /*        1 = total disk  */      else                  indexcode = 2;     /*        2 = total sync  */                                               /*        3 = cp    alpha */      if project = 1                           /*        4 = cp    disk  */      then indexcode = indexcode + 3;          /*        5 = cp    sync  */      /* Fetch system info to get # of cues defined */      call FETCH.DTD.SYSTEM.INFO;      if project = 0                   /* all projects               */      then maxindex# = dtd.num.cues;   /* get total # of cues        */      else maxindex# = dtd.cp.cues;    /* get curr project cues      */      call SET.DTD.SCROLL.RANGE(project); /* set scroll range so     */                                          /* dtd knows how to do     */                                          /* index computation.      */      if      sort = 0      then call FETCH.NTH.ALPHA.DTD.CUE(index#); /* get alpha        */      else if sort = 1      then call FETCH.NTH.TIME.DTD.CUE(index#);  /* get time cue     */      else call FETCH.NTH.SYNC.DTD.CUE(index#);  /* get sync cue     */      if DTD.CUE# <> 0 then do;                  /* if found         */         id#     = DTD.CUE#;                     /* save id#         */         index#  = FETCH.DTD.CUE.INDEX(indexcode);         status  = 0;                            /* good status      */         call FETCH.DTD.CUE (id#, misc.buf);     /* get actual name  */         call BLOCKMOVE(loc(addr(misc.buf(CUE.NAME))), name, 17);         if callup then do;            call SET.DTD.CURRENT.REEL(0);     /* select "cue"             */            call Fetch.Entire.DTD.Cue(id#,Current.Cue.Ptr);            call Deposit.A.New.Current.Cue(1);            call UnSet.Cue.Modified;         end;      end;   end;   /* Project case */   else if (err = 0) AND (filter = 16) then do;      type = 4;                         /* DTD Project */      maxindex# = 49;                   /* For now */      call Fetch.DTD.Song.Directory(index#);      write(MAM) = SCSI.PTR;      write(MAL) = 1;      do j=1 to 12;         name(j) = read(MDI);      end;      do j=0 to 23;         if  byte(name,j) > "40"        /* Greater than space */         AND byte(name,j) < "177"       /* Less than "delete" */         then name(0) = j + 1;          /* Remember last valid char as string length */      end;      if (name(0) > 0)                  /* If we found a project... */      then status = 0;                  /* ...good status */      if  (status = 0)     /* If project was found...  */      and (callup <> 0)    /* ...and should call it up */      then do;         call Ask.For.DTD.Current.Project(index#);      end;      else call Set.Up.AEE.DTD.Globals; /* Only reset globals */   end;   return Send.Directory.Key(des, tag, status, id#, index#, maxindex#, type, name);end Request.Directory.Key.By.Index;Request.Directory.Key.By.Id: proc (packet,des) swapable;   dcl packet        array;   /* pass incoming packet    */   dcl des           fixed;   /* node for destination    */   dcl tag           fixed;   dcl id#           fixed;   dcl sort          fixed;   dcl project       fixed;   dcl filter        fixed;   dcl callup        fixed;   dcl name(18)      fixed;  /* 18 to convert to C string in place */   dcl indexcode     fixed;   dcl status        fixed;   dcl index#        fixed;   dcl maxindex#     fixed;   tag       = packet(0);             /* get message tag         */   id#       = packet(2);             /* LONG id#                */   sort      = shr(packet(3),8);      /* get index code          */   project   = packet(3) & "377";     /* 1 = cur proj only       */   filter    = packet(4);             /* none=all, 1=cue, 2=snd file, 4=timb, 8=seq, 16=dir/proj */   callup    = shr(packet(5),8);      /* 1 = call up             */   status    = 1;       /* assume status is initally 'not found' */   index#    = 0;   maxindex# = 0;   name(0)   = 0;   if (sort    < 0)   OR (sort    = 2)   OR (sort    = 3)   OR (sort    = 4)   OR (sort    > 5)   OR (project < 0)   OR (project > 1)   OR (filter <> 1)        /* For now, we only support "cue" */   OR (callup  < 0)   OR (callup  > 1)   then do;      call Present.Protocol.Error.Message(NT#SystemError,ATTR#Reverse,0,0,0);      /* but create a return message that says not found */   end;   else do;      if      sort = 0 then indexcode = 0;     /* set up 0 = total alpha */      else if sort = 1 then indexcode = 1;     /*        1 = total disk  */      else                  indexcode = 2;     /*        2 = total sync  */                                               /*        3 = cp    alpha */      if project = 1                           /*        4 = cp    disk  */      then indexcode = indexcode + 3;          /*        5 = cp    sync  */      /* Fetch system info to get # of cues defined */      call FETCH.DTD.SYSTEM.INFO;      if project = 0                   /* all projects               */      then maxindex# = dtd.num.cues;   /* get total # of cues        */      else maxindex# = dtd.cp.cues;    /* get curr project cues      */      call SET.DTD.SCROLL.RANGE(project); /* set scroll range so     */                                          /* dtd knows how to do     */                                          /* index computation.      */      call FETCH.DTD.CUE(id#, misc.buf);  /* get the cue             */      if DTD.CUE# = 0                     /* no longer there!!       */      then id#    = 0;                    /* must have been bad id   */      else do;         status = 0;                      /* return found            */         call BLOCKMOVE(loc(addr(misc.buf(CUE.NAME))), name, 17);         /* ******************************************************** */         /* Must locate cue by name to set up index pointers         */         /* ******************************************************** */         call LOCATE.DTD.CUE(name);         if DTD.CUE# <> 0 then do;     /* if found - get index #     */            index#  = FETCH.DTD.CUE.INDEX(indexcode);         end;         if callup then do;            call SET.DTD.CURRENT.REEL(0);     /* select "cue"             */            call Fetch.Entire.DTD.Cue(id#,Current.Cue.Ptr);            call Deposit.A.New.Current.Cue(1);            call UnSet.Cue.Modified;         end;      end;   end;   return Send.Directory.Key(des, tag, status, id#, index#, maxindex#, 0, name);end Request.Directory.Key.By.Id;