/* TRAPMIDI  $TITLE  ROUTINES TO PROCESS MIDI EVENTS   Modified:	2007/02/02 - CJ  - Change NUM.MIDI.TRACKS to MAX.INPUTS = 202   03/15/91 - PF  - support for MIDInet with new SyncNet driver   03/09/89 - PF  - Increase MAX.INPUTS to 128   10/30/89 - MWH - Add MIDI channel limit checking (per Paul)   09/30/89 - PF  - Fake a tag (for now) in the MIDInet Filename message   08/24/89 - MWH - Rework the protocol for release 2.2   07/24/89 - PF  - Deleted T#MIDI_Input_Routing alltogether   07/24/89 - PF  - Send/Recieve MIDInet filename   07/20/89 - PF  - Added PROCESS.ALL.NOTES.OFF proc   07/06/89 - PF  - Deleted Timbre Mapping from T#MIDI_Input_Routing packet   06/15/89 - PF  - Added support for receiving sysex over rs422   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   03/14/89 - PF  - changed process packet processing logic    1/13/89 - PF - added file to master source during MMIDI merge   10/15/88 - PF - Created this source file*/Process.System.Exclusive.Packet: proc (len,data) swapable;   dcl len  fixed;   dcl data array;   dcl i    fixed;   dcl trk  fixed;      trk = midi.mapping(data(0) & "377");           /* extract destination track */   if MIDI.INPUT.ENABLED = 0                	  /* midi is mapped to kbd */   then trk = recd.trk;                           /* route to current record track */   write(mam)=tbut.ptr;                           /* point to track lookup table */   write(mal)=trk;                                /* for this track */   if  (recd<>0)                                  /* we are recording */   and ((trk=recd.trk)                            /* this is the record track */   or  ((recd.trk<>0)                             /* or synclavier recording     */   and ((read(md)&b.ready.trk)<>0)))              /* and this track is armed   */   or  (midi.echo.disabled = 0)                   /* we are echoing midi */   then do;                                             if (data(0) & "100000") = 0 then do;        /* this is the first packet in what could be a series */         if (sysex.write.ptr<>(sysex.read.ptr-1)) /* room in sysex input buffer */         then do;            write(mam)=sysex.buf+(shr(sysex.write.ptr&"7777",8));            write(mal)=sysex.write.ptr;           /* set up pointers into sysex input buffer */            write(md) = "hf0" | shl(trk,8);       /* start of exclusive status byte - always "or" in track number in upper byte */            sysex.write.ptr=sysex.write.ptr+1;    /* increment pointer */         end;         else do;                                 /* buffer is full */            midi.overrun=1;                       /* we are going to lose some data */             sysex.read.ptr=sysex.write.ptr;       /* clear the sysex input buffer */            return(1);                            /* bail out */         end;      end;      do i = 0 to (len-8-1);                      /* step thru data bytes (8 is the number of header bytes to skip) */         if (sysex.write.ptr<>(sysex.read.ptr-1)) /* room in sysex input buffer */         then do;            write(mam)=sysex.buf+(shr(sysex.write.ptr&"7777",8));            write(mal)=sysex.write.ptr;           /* set up pointers into sysex input buffer */            if (i & 1) = 0 then do;               /* index counter is even */               write(md)=shr(data(1 + shr(i,1)),8) | shl(trk,8); /* extract byte from upper half - always "or" in destination track in upper half of word */            end;            else do;                              /* counter is odd */               write(md)=(data(1 + shr(i,1)) & "377") | shl(trk,8); /* extract byte from lower half - "or" in track number */            end;            sysex.write.ptr=sysex.write.ptr+1;    /* increment buffer head pointer */         end;         else do;                                 /* buffer is full */            midi.overrun=1;                       /* about to lose some data */             sysex.read.ptr=sysex.write.ptr;       /* clear the sysex input buffer */            return(1);                            /* bail out */         end;      end;                                        /* of stepping thru data bytes in packet */   end;                                           /* of processing this sysex packet */   return(1);end Process.System.Exclusive.Packet;Process.All.Notes.Off: proc (data) swapable;   dcl data    array;   if data(0) IGE MAX.INPUTS                      /* illegal channel number */   then return;   call clear.poly.timbre.notes(midi.mapping(data(0)));		// was midi  mapped; actually not midi mapped!end Process.All.Notes.Off;Clear.MIDI.Routing: proc swapable;   dcl i fixed;   do i = 0 to max.tracks;      write(mam) = trk.head;      write(mal) = i;      if read(md) <> 0 then do;         write(mam) = read(md);         write(mal) = thd.midi;		 		 if ((read(md) & THD.MIDI.PRESURE) != 0)			// If had been sending pressure, send out o pressure of 0 on this track		 {			CLEANUP.MIDI.PRESSURE(i);			write(mam) = trk.head;			write(mal) = i;			write(mam) = read(md);            write(mal) = thd.midi;		 }         write(md) = read(md) & (not(THD.MIDI.MIDINET));	// Turn off MIDINet bit		 // Clear pressure bits if setting routing to 0		 if ((read(md) & (THD.MIDI.MIDINET | THD.MIDI.OMS | THD.MIDI.ORIG)) == 0)		 	write(md) = 0;         write(mal) = thd.midi.path;						// Turn off MIDINet routing         write(md)  = 0;      end;   end;   do i = 0 to max.inputs - 1;      if i = 0 then do;         call clear.poly.timbre.notes(0);      end;      else do;         if midi.mapping(i) <> 1 then do;            call clear.poly.timbre.notes(midi.mapping(i));	// was midi  mapped; actually not midi mapped!            midi.mapping(i) = 1;         end;      end;   end;   call COMPUTE.MISC.INFO;   			 /* Make sure channel pressure list is correct */   new.seq.info = new.seq.info | 8;      /* New constants */   return(1);                            /* succes */end Clear.MIDI.Routing;Send.MIDInet.Filename: proc (packet,des) swapable;   dcl packet array;   dcl des    fixed;   dcl tag    fixed;   dcl i      fixed;   tag = packet(0);   write(mam) = bas.ptr;                 /* first copy MIDInet filename into misc.buf */   write(mal) = seq.midinet;   call copy.in(addr(misc.buf(0)),16);   write(mam) = misc.ptr;                /* use misc.ptr sector */   write(mdi) = L#MIDInet_Filename;      /* fill in length */   write(mdi) = des;                     /* destination */   write(mdi) = T#MIDInet_Filename;      /* sub/super type */   write(mdi) = tag;                     /* return tag */   do i = 0 to 15;                       /* now copy filename back into packet */      write(mdi) = misc.buf(i);   end;   if not Send.Protocol.Packet(misc.ptr,1)   then do;                              /* no room in protocol output buffer now */      return(0);                         /* return zero - try again later         */   end;   return(1);                            /* success */end Send.MIDInet.Filename;Receive.MIDInet.Filename: proc (data) swapable;   dcl data array;   dcl i    fixed;   write(mam) = bas.ptr;              /* point to sequence bas area */   write(mal) = seq.midinet;          /* loc of midinet filename */   do i = 0 to 15;      write(mdi) = data(i);           /* copy new name into bas.ptr */   end;   return(1);                         /* success */end Receive.MIDInet.Filename;Handle.MIDI: proc public swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam) = Packet.Ptr;   write(mal) = P#LEN;    len     = read(md);   write(mal) = P#SOURCE; des     = read(md);   write(mal) = P#TYPE;      subtype    = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   do case subtype;    /* branch on specific MIDI subtype */      /* most of the midi messages are handled at the interrupt level */      ;    /*  0:  undefined */      ;    /*  1:  Note Off  */                   ;    /*  2:  Note On   */      ;    /*  3:  Polyphonic Key Pressure */      ;    /*  4:  Continuous Control Change */      ;    /*  5:  Switch Control Change */      ;    /*  6:  Program Change */      ;    /*  7:  Channel Pressure */      ;    /*  8:  Pitch Bend Change */      ;    /*  9:  MIDI Song Position Pointer */      ;    /* 10:  MIDI Timing Clock */      ;    /* 11:  MIDI Start */      ;    /* 12:  MIDI Continue */      ;    /* 13:  MIDI Stop */      do;  /* 14:  System Exclusive Packet */         ret = Process.System.Exclusive.Packet(len,packet);      end;      ;    /* 15:  Undefined */      ;    /* 16: MIDI Bulk */      ;    /* 17: End Of Exclusive */      do;  /* 18: All Notes Off */         ret = Process.All.Notes.Off(packet);      end;      do;  /* 19: Clear MIDI routing (MIDInet only for now) */         call Clear.MIDI.Routing;      end;      do;  /* 20: request MIDInet filename */         ret = Send.MIDInet.Filename(packet,des);      end;      do;  /* 21:  return MIDInet filename */         /* This is handled by the request routine */      end;      do;  /* 22: set MIDInet filename */         ret = Receive.MIDInet.Filename(packet);      end;   end;   return(ret);             /* return processed status */end Handle.MIDI;