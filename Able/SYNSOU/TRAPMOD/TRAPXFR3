/* TRAPXFR3  $TITLE  ROUTINES TO HANDLE BLOCK TRANSFERS OF ABLE DATA STRUCTS   Modified:   02/13/94 - PF  - Fixed msb,lsb glomming bug in call to SBITS.TO.SMPTE   02/26/92 - PF  - Add read/write of tempo/meter maps   01/10/92 - PF  - Split this file off from trapxfr2*//* This routine responds to the data request for: Able:Sequence:Tracks. *//* The response consists of a small track information record for each   *//* valid track in the current sequence.                                 */Read.Track.List: proc (des,tag) swapable;   dcl des      fixed;   dcl tag      fixed;   dcl i        fixed;   dcl type     fixed;   dcl track    fixed;   dcl count(1) fixed;   dcl records  fixed;   dcl length   fixed;   write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer 	*/   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes 		*/   write(mdi) = tag;                       /* tag 										*/     write(mdi) = 0;                         /* status - fill in below (begin of data) 	*/      write(mdi) = 0;                         /* length msb/lsb 							*/   write(mdi) = 0;                         /* fill in length below 						*/      write(mdi) = 0;                         /* begin of addr - num levels 				*/   write(mdi) = 3;     write(mdi) = 0;                         /* Able 										*/   write(mdi) = 1;              write(mdi) = 0;                         /* Sequence 									*/   write(mdi) = 1;   write(mdi) = 0;                         /* Tracks 									*/   write(mdi) = 1;   rpc(20);                                /* zero out the rest of the addr 			*/   write(mdi) = 0;   write(mdi) = 0;                         /* record count - 							*/   write(mdi) = 0;                         /* fill in below 							*/   save;   /* now loop thru possible tracks and build record for each valid entry */   do i = num.kbd.tracks to first.lod.track - 1;      write(mam)=trk.head;                 write(mal)=i;      if read(md) <> 0 then do;            /* we have a track head */         records = records + 1;         write(mam) = read(md);            /* point at track header */         write(mal) = thd.cue.track;         if (read(md) <> 0)                /* this is a cue track */         then type = 2;                    /* set type word */         else type = 1;         write(mal) = thd.nn.msb;          /* point to 32 bit number of notes */         count(0) = read(mdi);         count(1) = read(mdi);         /* now write a track info record into the block transfer buffer */         restore;         write(mdi) = l#tracks_info;        /* record size 							*/         write(mdi) = type;                 /* track type: <1=Note, 2=Cue> 			*/         write(mdi) = i;                    /* track number - Synclaiver format 	*/         write(mdi) = count(0);             /* number of events on track 			*/         write(mdi) = count(1);         save;      end;   end;   /* now we can compute byte length of "block" transfer */   length = l#buf_header                   /* total length of header stuff */          + (l#tracks_info * records);     /* and n records of track info */                                     write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer */   write(mal) = loc#status;                /* point to status word */   write(mdi) = s#good_status;             /* status */   write(mdi) = 0;                         /* msb/lsb */   write(mdi) = length - 4;                /* don't include super/sub and tag */   write(mal) = loc#count;                 /* point to record count */   write(mdi) = 0;                         /* num track info records msb/lsb */   write(mdi) = records;                      /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Track.List;/* This routine builds data for the req: Able:Sequence:Tracks:Trkn.      *//* The repsonse consists of select data from the track header of trk n   *//* in the current Synclavier sequence.                                   */Read.Track.Header: proc (des,tag,track) swapable;   dcl des     fixed;   dcl tag     fixed;   dcl track   fixed;   dcl length  fixed;   dcl records fixed;   write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = s#good_status;             /* assume success - begin of data */     write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = 0;                         /* fill in length below */     write(mdi) = 0;                         /* begin of addr - num levels */   write(mdi) = 4;   write(mdi) = 0;                         /* Able */   write(mdi) = 1;              write(mdi) = 0;                         /* Sequence */   write(mdi) = 1;   write(mdi) = 0;                         /* Tracks */   write(mdi) = 1;   write(mdi) = 0;                         /* Synclavier track number */   write(mdi) = track;   rpc(18);                                /* zero out the rest of the addr */   write(mdi) = 0;   write(mdi) = 0;                         /* record count - */   write(mdi) = 0;                         /* fill in below */   save;   /* init length to known length so far */   length = l#buf_header;                  /* total length of header stuff */   /* now look at the track head in question making sure one exists */   write(mam) = trk.head;   write(mal) = track;   if read(md) <> 0 then do;               /* track header exists */      records = 1;                         /* we will have one record */      length = length + l#track_header;    /* bump up length to include header */            write("313") = addr(misc.buf(0));    /* set up to build data in misc.buf */      write("373") = l#track_header;       /* record size */      write(mam) = read(md);      write(mal) = thd.cue.track;                if (read(md) <> 0)                   /* type */      then write("373") = 2;      else write("373") = 1;      write(mal) = thd.nn.msb;      write("373") = read(mdi);            /* event count */      write("373") = read(mdi);      write(mal) = thd.midi;           write("373") = read(mdi);            /* midi routing */      write("373") = read(mdi);            /* track volume */      write("373") = shr(read(md),8);      /* multi routing left */      write("373") = read(mdi) & 255;      /* multi routing right */      write("373") = read(mdi);            /* pan */      write("373") = read(mdi);            /* octave ratio */      write(mal) = thd.sxpos;      write("373") = read(mdi);            /* starting transposition */      write(mal) = thd.ilp;      write("373") = read(mdi);            /* ilp present */      write("373") = read(mdi);            /* ilp start */      write("373") = read(mdi);                  write("373") = read(mdi);            /* ilp length */      write("373") = read(mdi);                  write(mal) = thd.active.midi.rtes;      write("373") = read(mdi);            /* midi controller filter */      write(mal) = thd.cue.out;      write("373") = read(mdi);            /* cue output */      write(mal) = thd.track.title;      rpc(17);      write("373") = read(mdi);            /* name */      /* now move this record from misc.buf into our blk xfer buf location */      write("313") = addr(misc.buf(0));    /* setup to read from misc.buf */      restore;      rpc(shr(l#track_header,1));          /* repeat on byte len / 2 */      write(mdi) = read("373");   end;   write(MAM) = XFER.PTR;                  /* fill in length and record count */   write(mal) = loc#size;                  /* point to size */   write(mdi) = 0;                         /* msb/lsb */   write(mdi) = length - 4;                /* don't include super/sub and tag */   write(mal) = loc#count;                 /* point to record count */   write(mdi) = 0;                         /* num track info records msb/lsb */   write(mdi) = records;                      /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Track.Header;/* This routine builds data for the req: Able:Sequence:Tracks:Trkn:r1:r2 *//* where r1-r2 represents a range of time on track n.  An event record   *//* will be built for each event in the corresponding range.              */Read.Track.Events: proc (des,tag,track,tstart,tend) swapable;   dcl des               fixed;   dcl tag               fixed;   dcl track             fixed;   dcl tstart            array;   dcl tend              array;   dcl length            fixed;   dcl records           fixed;   dcl status            fixed;   dcl last.new.time(1)  fixed;   dcl count             fixed;   dcl reclen            fixed;   dcl key               fixed;   dcl dur(1)            fixed;   dcl native_offset(1)  fixed;   dcl event.start(1)    fixed;   dcl event.end(1)      fixed;   dcl (msb,lsb)         fixed;   dcl i                 fixed;   dcl last.good.records fixed;   dcl last.good.length  fixed;   dcl eot               fixed;   dcl cue.track         fixed;   dcl vel               fixed;   dcl con               fixed;   dcl sync(1)           fixed;   dcl smpte(4)          fixed;   dcl mode              fixed;   dcl tbits             fixed;   dcl event(Event.Record.Size - 1) fixed;    /* Event record */   dcl FETCH.DTD.CUE.IN.SAMPLES   proc (fixed,array) returns (fixed) external;   Point.To.First.Note: proc (track);     /* sets up globals to point at first note of track */      dcl track fixed;      write(mam) = trk.head;              /* point to track head list */      write(mal) = track;                 /* this track */      if read(md) = 0                     /* no track header exists */      then return 0;                      /* return end of track */      write(mam)=read(md);                /* point to this tracks header */      write(mal)=thd.for;                 /* get forward ptr to 1st note list segment */      #sec=read(md);      if #sec=0 then do;                  /* empty track */         return 0;                        /* bail out */      end;      next.sector:                        /* jump here for next note list segment */      write(mam)=nah.ptr+#sec;            /* set up abs ptrs to nls   */      write(mal)=nls.fp;                  /* get first pointer        */      #wrd=read(md);                      /* use first note record in segment */      write(mal)=#wrd;                    /* actually point to the note */      if read(md)=nls.eos then do;        /* end of this nls           */         write(mal)=nls.for;              /* look up forward ptr       */         if read(md)=0 then do;           /* end of track -- bomb out  */            return 0;         end;         #sec=read(md);                   /* update global sector prt  */         goto next.sector;                /* continue from next nls    */      end;      #nmsb = 0;      #nlsb = shr(read(md),1)&1023;       /* extract start time delta for note record */      return 1;   end Point.To.First.Note;   /* build block transfer data for track events */   write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = 0;                         /* status - fill in below (begin of data) */   write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = 0;                         /* fill in length below */   write(mdi) = 0;                         /* begin of addr - num levels */   write(mdi) = 7;   write(mdi) = 0;                         /* 1:Able */   write(mdi) = 1;              write(mdi) = 0;                         /* 2:Sequence */   write(mdi) = 1;   write(mdi) = 0;                         /* 3:Tracks */   write(mdi) = 1;   write(mdi) = 0;                         /* 4:Track n */   write(mdi) = track;   write(mdi) = 0;                         /* 5:Events */   write(mdi) = 1;   write(mdi) = tstart(0);                 /* 6:Range - start */   write(mdi) = tstart(1);   write(mdi) = tend(0);                   /* 7:Range - end */   write(mdi) = tend(1);   rpc(12);                                /* zero out the rest of the addr */   write(mdi) = 0;   write(mdi) = 0;                         /* record count - */   write(mdi) = 0;                         /* fill in below */   /* now step thru events on track all fill transfer buffer till */   /* all events in range are processed or the buffer fills up    */   save;   length = l#buf_header;                 /* total length of header stuff */   status = s#good_status;                /* assume no problems */   tstart(1) = tstart(1) + zero.time;     /* add zero.time offset to incoming times */   if tstart(1) ilt zero.time             /* check for wrap on lsb */   then do;      tstart(0) = tstart(0) + 1;      if tstart(0) = 0 then do;           /* check for msb wrap error */         tstart(0) = "177777";            /* limit to max_int32 */         tstart(1) = "177777";      end;   end;   tend(1) = tend(1) + zero.time;         /* add zero.time offset to incoming times */   if tend(1) ilt zero.time               /* check for wrap on lsb */   then do;      tend(0) = tend(0) + 1;      if tend(0) = 0 then do;             /* check for msb wrap error */         tend(0) = "177777";              /* limit to max_int32 */         tend(1) = "177777";      end;   end;   last.new.time(0) = 0;                   /* make sure last new time init to zero */   last.new.time(1) = 0;   write(mam) = trk.head;                  /* lookup track head */   write(mal) = track;   if read(md) = 0                         /* no header for this track */   then eot = 1;                           /* set end of track */   else do;      write(mam) = read(md);               /* point to our header */      write(mal) = thd.cue.track;          /* get track type */      if read(md) <> 0      then cue.track = 1;                        /* now setup globals to point to first note on track (if any) */      if (Point.To.First.Note(track) = 0)     /* no notes on track */      then eot = 1;                           /* we are at end of track */   end;   #trk = track;                           /* init global track var for calls below */   /* first advance to first note in our range */   do while (eot = 0)                      /* while we are not at end of track */   and      ((#nmsb ilt tstart(0))         /* but still before start time of range */   or       ((#nmsb  =  tstart(0))   and      (#nlsb ilt tstart(1))));      if (Advance.To.Next.Note = 0)        /* keep on andvancing */      then eot = 1;                        /* check for hitting end of track */   end;   /* if we didn't hit end of track start processing notes */   do while (eot = 0)                      /* while not at end of track */   and      ((#nmsb ilt tend(0))           /* and still within range of time */   or       ((#nmsb  =  tend(0))   and      (#nlsb ile tend(1))));      #w1 = read(mdi);      #w2 = read(mdi);      #w3 = read(mdi);      #w4 = read(mdi);      /* check for rest notes */      if ((#w1 & "174001") = "100001")               /* extended rest note */      or ((#w1 >= 0) and ((#w2 & "77") = rest.note)) /* regular rest note */      then do;         if (Advance.To.Next.Note = 0)        /* skip over rest records */         then eot = 1;      end;      else do;                                /* valid note exists here */         if (last.new.time(0) <> #nmsb)       /* first check for begin of "events at new time" */         or (last.new.time(1) <> #nlsb)       /* in case we reach buffer size limit */         then do;                             /* we want to be able to make sure the next time requested */                                              /* will represent the first event at that time */            last.new.time(0) = #nmsb;         /* latch new times */            last.new.time(1) = #nlsb;            last.good.records = records;      /* save record count of last record before new time */             last.good.length = length;        /* and length too */            count = 0;                        /* keep event count correct too */         end;         else count = count + 1;                       reclen = l#cue_record;               /* init length to largest record we might excpect to see since we don't know actual length until below */         if ((length + reclen) igt Max_Block_Length)  /* next record would send us over our size limit */         then do;            records = last.good.records;           /* get record and length */            length  = last.good.length;            /* at last valid stopping point */            status = status & (not b#complete);    /* clear complete status bit */            eot = 1;                               /* use end of track to break out of do loop */         end;         else do;                                  /* have room to process this event */            if ((#w1) & ((#w3 & shl(b.upd,8)) <> 0))   /* rte note */            then do;               reclen = l#rte_record;                  /* set length of real time effect record */               msb = #nmsb;                            /* get start time of event - zero.time */               lsb = #nlsb - zero.time;               if (lsb igt #nlsb)               then msb = msb - 1;               restore;               write(mdi) = reclen;                    /* build event record */               write(mdi) = xt#rte;                    /* type */               write(mdi) = msb;                       /* start time */               write(mdi) = lsb;               write(mdi) = #w1;                       /* for now just write out raw data */               write(mdi) = #w2;               write(mdi) = #w3;               write(mdi) = #w4;               save;               records = records + 1;                  /* one more record processed */               length = length + reclen;               /* keep length correct */            end;            else if ((#w1 & "174001") = "104001")      /* ilp start record */            then do;               reclen = l#ilp_record;                  /* set length of independent loop record */               msb = #nmsb;                            /* get start time of event - zero.time */               lsb = #nlsb - zero.time;               if (lsb igt #nlsb)               then msb = msb - 1;               /* compute ind loop end time */               call TRK.HEAD.LOOKUP(track, THD.LOOPLEN.MSB);                dur(0) = read(mdi);               dur(1) = read(md );               call add32(loc(addr(msb)),dur,event.end);               restore;               write(mdi) = reclen;                    /* build event record */               write(mdi) = xt#ilp;                    /* type */               write(mdi) = msb;                       /* sequencer start time of loop */               write(mdi) = lsb;               write(mdi) = event.end(0);              /* end time of loop */               write(mdi) = event.end(1);               save;               records = records + 1;                  /* one more record processed */               length = length + reclen;               /* keep length correct */            end;            else if ((#w1 & "174001") = "110001")      /* independent loop end record */            then do;                                   /* do nothing - all handled by ilp start */               ;            end;            else if (cue.track <> 0)                   /* cue track */            then do;               reclen = l#cue_record;                  /* set length of cue record */               event(Event.Track#)     = track;           /* Set up sequencer pointer */               event(Event.Time.Msb)   = #nmsb;               event(Event.Time.Lsb)   = #nlsb;               event(Event.Time.Count) = count;               call Expand.Sequencer.Event.Information (event,1);               /* Replace sequencer event time with ZERO.TIME offset removed */               call copy32(loc(addr(event(Event.Time.Msb))),event.start);               if com16(ZERO.TIME,event.start) <> lw#igt   /* If the time is large enough */               then call sub16(ZERO.TIME,event.start);     /* Remove "ZERO.TIME" offset */               else call str32(0,0,event.start);           /* Else, put us at zero */               /* compute event out time */               event.end(0) = event.start(0) + event(Event.Duration.Msb);               event.end(1) = event.start(1) + event(Event.Duration.Lsb);               if event.end(1) ilt event.start(1)               then event.end(0) = event.end(0) + 1;               /* look up some info direct from cue */               i = run.syn;                  /* save state of run.syn global */               run.syn = 0;                  /* try to speed up send.to.lod */               if Fetch.DTD.cue.in.samples(event(Event.Cue.Id),misc.buf) <> 0 then do;                  /* sync time is easy: */                  sync(0)    = misc.buf(CUE.SMPT.MSB);                  sync(1)    = misc.buf(CUE.SMPT.LSB);                  mode       = misc.buf(CUE.SMPT.MODE);                  if (misc.buf(CUE.BITS) & 8) = 0      /* cue.smpt.msb is relative to smpte offset */                  then call SBITS.TO.MSEC(sync ,cf#time, SAMP.SPEED, mode, sync);                  else do;                     call SBITS.TO.SMPTE(sync, mode, smpte);                     call SMPTE.TO.MSEC(smpte, cf#time, SAMP.SPEED, SM.MODE, loc(addr(SM.HRS)), sync);                     if sync(0) < 0           /* but might be before start of sequence */                     then call STR32(0, zero.time, sync);                  end;                  if com16(ZERO.TIME,sync) <> lw#igt   /* If the time is large enough */                  then call sub16(ZERO.TIME,sync);     /* Remove "ZERO.TIME" offset */                  else call str32(0,0,sync);           /* Else, put us at zero */                  call sub32(loc(addr(misc.buf(CUE.E.MSB))),   /* get length of cue in samples */                             loc(addr(misc.buf(CUE.S.MSB))),                             loc(addr(msb                )));                  call Signed.DTD.Sample.#.To.MSECS(loc(addr(msb)),                                            CF#DUR,                                            SAMP.SPEED,                                            AEE.Current.Project.Rate,                                            zero.zero, dur);                  call sub32(loc(addr(misc.buf(EVENT.IN.S#.MSB))),  /* compute negative offset from cue.s.msb to event.in.s#.msb */                             loc(addr(misc.buf(CUE.S.MSB      ))),                             native_offset);                  tbits  = misc.buf(CUE.TRKS);         /* track bits for this cue */               end;               else do;                  call str32(0,0,sync);                  call str32(0,0,dur);                  call str32(0,0,native_offset);                  tbits = 0;               end;               run.syn = i;                  /* restore run.syn state */               /* convert mark and in/out times from dtd.sample# to msecs */               call add32(loc(addr(event(Event.Mark.Msb))),   /* pass to Ev 2000 offset from start of event to current cue in time */                          native_offset,                          loc(addr(event(Event.Mark.Msb))));               call Signed.DTD.Sample.#.To.MSECS(loc(addr(event(Event.Mark.Msb))),                                         CF#DUR,                                         SAMP.SPEED,                                         AEE.Current.Project.Rate,                                         zero.zero,                                         loc(addr(event(Event.Mark.Msb))));               call add32(loc(addr(event(Event.In.Msb))),                          native_offset,                          loc(addr(event(Event.In.Msb))));               call Signed.DTD.Sample.#.To.MSECS(loc(addr(event(Event.In.Msb))),                                         CF#DUR,                                         SAMP.SPEED,                                         AEE.Current.Project.Rate,                                         zero.zero,                                         loc(addr(event(Event.In.Msb))));               call add32(loc(addr(event(Event.Out.Msb))),                          native_offset,                          loc(addr(event(Event.Out.Msb))));               call Signed.DTD.Sample.#.To.MSECS(loc(addr(event(Event.Out.Msb))),                                         CF#DUR,                                         SAMP.SPEED,                                         AEE.Current.Project.Rate,                                         zero.zero,                                         loc(addr(event(Event.Out.Msb))));               call neg32(native_offset);              /* pass actual desired offset to EV 2000 */               restore;               write(mdi) = reclen;                    /* build event record */               write(mdi) = xt#cue;                    /* type */               write(mdi) = event.start(0);            /* start time */               write(mdi) = event.start(1);               write(mdi) = event(Event.Mark.Msb);     /* mark */               write(mdi) = event(Event.Mark.Lsb);               write(mdi) = event(Event.In.Msb);       /* in time */               write(mdi) = event(Event.In.Lsb);               write(mdi) = event(Event.Out.Msb);      /* out time */               write(mdi) = event(Event.Out.Lsb);               write(mdi) = event(Event.Fade.In);      /* ramp in */               write(mdi) = event(Event.Fade.Out);               write(mdi) = event(Event.Volume);       /* volume */               write(mdi) = event(Event.SVol);         /* start volume */               write(mdi) = event(Event.EVol);         /* end volume */               write(mdi) = tbits;                     /* track bits */               write(mdi) = dur(0);                    /* original cue length */               write(mdi) = dur(1);               write(mdi) = sync(0);                   /* original cue sync time */               write(mdi) = sync(1);               write(mdi) = native_offset(0);               write(mdi) = native_offset(1);               /* setup to read name  and caption */               write("313") = addr(event(Event.Cue.Name));               rpc (17);               write(mdi) = read("373");               /* read in name */               write("313") = addr(event(Event.Caption));               rpc (49);                               /* read in caption */               write(mdi) = read("373");               save;               records = records + 1;                  /* one more record processed */               length = length + reclen;               /* keep length correct */            end;            else do;                                   /* regular note */               reclen = l#note_record;                 /* set length of regular note record */               /* get key number from note record */               key=(#w2 & 63)+12;                           /* get basic key# - add 1 octave */               if (#w1) then do;                            /* 4 word record */                  if  (#w4 & lower.key)<>0 then key=key-12; /* c0 - b0 */  /* may be random   in case of   word rest record */                  if  (#w4 & raise.key)<>0 then key=key+12; /* c#6- c7 */                  vel = #w3 & 255;                          /* get velocity */                  con = shr(#w3,8);                         /* and controller bits */               end;               else do;                                     /* 2 word record - assign default values */                  vel = rte.max;                  con = 0;               end;               /* extract duration from note record */               i=shr(#w1,11);                            dur(1)=shr(#w2, 6);                       dur(1)=dur(1)\shl(i&3,10);                dur(0)=0;                                 i=shr(i,2);               do while i<>0;                  dur(0)=shl(dur(0),2)\shr(dur(1),14);                  dur(1)=shl(dur(1),2);                  i=i-1;               end;               msb = #nmsb;                            /* get start time of event - zero.time */               lsb = #nlsb - zero.time;               if (lsb igt #nlsb)               then msb = msb - 1;               event.end(0) = msb + dur(0);            /* compute event end time */               event.end(1) = lsb + dur(1);               if event.end(1) ilt lsb               then event.end(0) = event.end(0) + 1;               restore;               write(mdi) = reclen;                    /* build event record */               write(mdi) = xt#note;                   /* type */               write(mdi) = msb;                       /* start time */               write(mdi) = lsb;               write(mdi) = event.end(0);              /* end time */               write(mdi) = event.end(1);               write(mdi) = shl(key,8) | vel;          /* key# | velocity */               write(mdi) = shl(con,8);                /* controllers */                               save;               records = records + 1;                  /* one more record processed */               length = length + reclen;               /* keep length correct */            end;            if (Advance.To.Next.Note = 0)            then eot = 1;         end;      end;   end;   write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer */   write(mal) = loc#status;                /* point to status */   write(mdi) = status;                    /* status */   write(mdi) = 0;                         /* msb/lsb */   write(mdi) = length - 4;                /* don't include super/sub and tag */   write(mal) = loc#count;                 /* point to record count */   write(mdi) = 0;                         /* num track info records msb/lsb */   write(mdi) = records;                      /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Track.Events;/* This routine builds data for the req: Able:Sequence:Tracks:Trkn:Timbre. *//* The timbre# is looked up for Trkn (if any) and the resulting timbre     *//* in synclavier format is copied into the output buffer.                  */Read.Track.Timbre: proc (des,tag,track) swapable;   dcl des         fixed;   dcl tag         fixed;   dcl track       fixed;   dcl tim#        fixed;   dcl length      fixed;   dcl records     fixed;   dcl tim.len     fixed;   dcl rec.size    fixed;   dcl i           fixed;   records = 0;                            /* init record count to zero */   /* init length to header size, increas below if we get a timbre record */   length = l#buf_header;                  /* total length of header stuff */                                     write(MAM) = XFER.PTR;                  /* build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = s#good_status;             /* assume success - begin of data */   write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = 0;                         /* fill in below */   write(mdi) = 0;                         /* begin of addr - num levels */   write(mdi) = 5;   write(mdi) = 0;                         /* Able */   write(mdi) = 1;              write(mdi) = 0;                         /* Sequence */   write(mdi) = 1;   write(mdi) = 0;                         /* Tracks */   write(mdi) = 1;   write(mdi) = 0;                         /* Synclavier track number */   write(mdi) = track;   write(mdi) = 0;                         /* Timbre */   write(mdi) = 2;   rpc(16);                                /* zero out the rest of the addr */   write(mdi) = 0;   write(mdi) = 0;                         /* record count - */   write(mdi) = 0;                         /* fill in below */   save;                                   /* save mam/mal */   tim# = (-1);                            /* init to no timbre found */   /* now check track for valid timbre */   if track < num.kbd.tracks               /* keyboard track */   then tim# = track;                      /* easy */      else do;                                /* sequencer track */      write(mam) = trk.head;      write(mal) = track;      if read(md) <> 0 then do;            /* has a track head */         write(mam) = read(md);         write(mal) = thd.ctimb;                    if read(md) <> 0                  /* and a valid timbre */         then do;                          /* copy timbre to our output buffer */            tim# = read(md);               /* get timbre number */         end;      end;   end;   if tim# <> (-1) then do;                /* a valid timbre was found */                                        /* get length of timbre */      i       = FIND.TIMBRE(PAR.PTR,tim#);          /* get word offset to start of timbre */      tim.len = FIND.TIMBRE(PAR.PTR,tim# + 1) - i;  /* derive length by subtracting from pointer to next timbre */      rec.size = 2 + shl(tim.len,1);       /* record size = bytes in timbre length plus record count itself */      restore;                             /* restore mam/mal to our position in output buffer */      write(mdi) = rec.size;               /* start of timbre record - write out record size in bytes */      save;                                /* load mam/mal into sav.ptrs */      call COPY.EXT.MEM(PAR.PTR,i,sav.ptrs(0),sav.ptrs(1),tim.len);      length = length + rec.size;          /* keep byte count correct */      records = 1;                         /* found a timbre so we will have one record */   end;   write(MAM) = XFER.PTR;                  /* fill in length and count */   write(mal) = loc#size;                  /* point to length word */   write(mdi) = 0;                         /* msb/lsb */   write(mdi) = length - 4;                /* new length - don't include super/sub and tag */   write(mal) = loc#count;                 /* point to record count */   write(mdi) = 0;                         /* num track info records msb/lsb */   write(mdi) = records;                      /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Track.Timbre;Read.Sequence.Tempo.Records: proc(des,tag,tstart,tend) swapable;   dcl des          fixed;   dcl tag          fixed;   dcl tstart       array;   dcl tend         array;   dcl range(3)     fixed;   dcl (x,y)        fixed;   dcl #records     fixed;   dcl record(shr(l#tempo_record,1)-1) fixed;   dcl length       fixed;   dcl status       fixed;   status = s#good_status;                 /* assume no problems */   tstart(1) = tstart(1) + zero.time;     /* add zero.time offset to incoming times */   if tstart(1) ilt zero.time             /* check for wrap on lsb */   then do;      tstart(0) = tstart(0) + 1;      if tstart(0) = 0 then do;           /* check for msb wrap error */         tstart(0) = "177777";            /* limit to max_int32 */         tstart(1) = "177777";      end;   end;   tend(1) = tend(1) + zero.time;         /* add zero.time offset to incoming times */   if tend(1) ilt zero.time               /* check for wrap on lsb */   then do;      tend(0) = tend(0) + 1;      if tend(0) = 0 then do;             /* check for msb wrap error */         tend(0) = "177777";              /* limit to max_int32 */         tend(1) = "177777";      end;   end;   /* get record numbers that fall within this range */   call Fetch.Sequencer.Tempo.Range(tstart,tend,range);   /* compute number of records in range */   call SUB32(loc(addr(range(2))),loc(addr(range(0))),loc(addr(x)));   if  (x <> 0)                            /* non zero msb */   or  (y igt ((max.xfer.length - l#buf_header) / l#tempo_record))    /* more records than will fit in one pass */   then do;      #records = ((max.xfer.length - l#buf_header) / l#tempo_record); /* limit to buffer size */      /* limit ending record# of range */      call ADD32(loc(addr(range(0))),loc(addr(x)),loc(addr(range(2))));      status = status & (not b#complete);  /* clear complete status bit */   end;   else #records = y;                      /* we can handle this many in one pass */   length = l#buf_header                   /* total length of header stuff */          + (l#tempo_record * #records);   /* and n tempo records */                                     write(MAM) = XFER.PTR;                  /* build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = status;                    /* fill in status word */   write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = length - 4;                /* don't include super/subtype and tag */   write(mdi) = 0;                         /* begin of addr - num levels */   write(mdi) = 5;   write(mdi) = 0;                         /* Able */   write(mdi) = 1;              write(mdi) = 0;                         /* Sequence */   write(mdi) = 1;   write(mdi) = 0;                         /* Tempo */   write(mdi) = 2;   write(mdi) = tstart(0);                 /* Range - start */   write(mdi) = tstart(1);   write(mdi) = tend(0);                   /* Range - end */   write(mdi) = tend(1);   rpc(16);                                /* zero out the rest of the addr */   write(mdi) = 0;   write(mdi) = 0;                         /* record count - */   write(mdi) = #records;                     save;                                   /* save mam/mal */   call COPY32(loc(addr(range(0))),loc(addr(x)));    /* copy starting record# into local */   record(0) = l#tempo_record;             /* set "Record Size" word in transfer tempo record */   record(1) = 0;                          /* set "Type" ??? */   /* now step thru each tempo record in our range */   do while (COM32(loc(addr(x)),loc(addr(range(2)))) = lw#ilt);      call Fetch.Sequencer.Tempo.Map.Record(loc(addr(x)),loc(addr(record(2))));      restore;                             /* restore mam/mal to current buffer pos */      write("313") = addr(record(0));      /* set up pointer to tempo record */      rpc (shr(l#tempo_record,1));         /* repeat on word count of record length */      write(mdi) = read("373");            /* write the rec into output buffer */      save;                                /* save buffer pos */      call ADD16(1,loc(addr(x)));          /* advance record index */   end;   /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Sequence.Tempo.Records;Read.Sequence.Meter.Records: proc(des,tag,tstart,tend) swapable;   dcl des          fixed;   dcl tag          fixed;   dcl tstart       array;   dcl tend         array;   dcl range(3)     fixed;   dcl (x,y)        fixed;   dcl #records     fixed;   dcl record(shr(l#meter_record,1)-1) fixed;   dcl length       fixed;   dcl status       fixed;   status = s#good_status;                 /* assume no problems */   tstart(1) = tstart(1) + zero.time;     /* add zero.time offset to incoming times */   if tstart(1) ilt zero.time             /* check for wrap on lsb */   then do;      tstart(0) = tstart(0) + 1;      if tstart(0) = 0 then do;           /* check for msb wrap error */         tstart(0) = "177777";            /* limit to max_int32 */         tstart(1) = "177777";      end;   end;   tend(1) = tend(1) + zero.time;         /* add zero.time offset to incoming times */   if tend(1) ilt zero.time               /* check for wrap on lsb */   then do;      tend(0) = tend(0) + 1;      if tend(0) = 0 then do;             /* check for msb wrap error */         tend(0) = "177777";              /* limit to max_int32 */         tend(1) = "177777";      end;   end;   /* get record numbers that fall within this range */   call Fetch.Sequencer.Meter.Range(tstart,tend,range);   /* compute number of records in range */   call SUB32(loc(addr(range(2))),loc(addr(range(0))),loc(addr(x)));   if  (x <> 0)                            /* non zero msb */   or  (y igt ((max.xfer.length - l#buf_header) / l#meter_record))    /* more records than will fit in one pass */   then do;      #records = ((max.xfer.length - l#buf_header) / l#meter_record); /* limit to buffer size */      /* limit ending record# of range */      call ADD32(loc(addr(range(0))),loc(addr(x)),loc(addr(range(2))));      status = status & (not b#complete);  /* clear complete status bit */   end;   else #records = y;                      /* we can handle this many in one pass */   length = l#buf_header                   /* total length of header stuff */          + (l#meter_record * #records);   /* and n tempo records */                                     write(MAM) = XFER.PTR;                  /* build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = status;                    /* fill in status word */   write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = length - 4;                /* don't include super/subtype and tag */   write(mdi) = 0;                         /* begin of addr - num levels */   write(mdi) = 5;   write(mdi) = 0;                         /* Able */   write(mdi) = 1;              write(mdi) = 0;                         /* Sequence */   write(mdi) = 1;   write(mdi) = 0;                         /* Meter */   write(mdi) = 3;   write(mdi) = tstart(0);                 /* Range - start */   write(mdi) = tstart(1);   write(mdi) = tend(0);                   /* Range - end */   write(mdi) = tend(1);   rpc(16);                                /* zero out the rest of the addr */   write(mdi) = 0;   write(mdi) = 0;                         /* record count - */   write(mdi) = #records;                     save;                                   /* save mam/mal */   call COPY32(loc(addr(range(0))),loc(addr(x)));    /* copy starting record# into local */   record(0) = l#meter_record;             /* set "Record Size" word in transfer meter record */   record(1) = 0;                          /* set "Type" ??? */   /* now step thru each tempo record in our range */   do while (COM32(loc(addr(x)),loc(addr(range(2)))) = lw#ilt);      call Fetch.Sequencer.Meter.Map.Record(loc(addr(x)),loc(addr(record(2))));      restore;                             /* restore mam/mal to current buffer pos */      write("313") = addr(record(0));      /* set up pointer to tempo record */      rpc (shr(l#meter_record,1));         /* repeat on word count of record length */      write(mdi) = read("373");            /* write the rec into output buffer */      save;                                /* save buffer pos */      call ADD16(1,loc(addr(x)));          /* advance record index */   end;   /* now send it out using block transfer mode */   return Read.Data(des,tag,length);end Read.Sequence.Meter.Records;Send.Error.Response: proc (des,tag,packet,status) swapable;   dcl des    fixed;   dcl tag    fixed;   dcl packet array;   dcl status fixed;   dcl i      fixed;   write(MAM) = XFER.PTR;                  /* now build transfer block in xfer buffer */   write(mdi) = T#Data_Read;               /* begin of block transfer data bytes */   write(mdi) = tag;                       /* tag */   write(mdi) = status;                    /* begin of data xfer standard header - status word */   write(mdi) = 0;                         /* length msb/lsb */   write(mdi) = l#standard_header;           do i = 0 to shr(l#addr,1) - 1;          /* return addr to caller */      write(mdi) = packet(1 + i);   end;   write(mdi) = 0;                         /* record count - no records since error condition */   write(mdi) = 0;                            return Read.Data(des,tag,l#buf_header);  /* pass length of block transfer data here  - includes super/sub and tag words */end Send.Error.Response;/* Main routine to process data transfer requests */Process.Request.Data.Read: proc (packet,des) swapable;   dcl packet array;   dcl des    fixed;   dcl tag    fixed;   dcl levels fixed;               /* number of tree levels in address 				*/   dcl track  fixed;               /* holds track number if addr references one 	*/   dcl ret    fixed;	/* equivalent struct: 																			*/	/*		short 	tag																				*/	/* 	long  	number of levels in address (packet( 1):packet( 2))				*/	/*    long		first  address					 (packet( 3):packet( 4))				*/	/*		long		second address					 (packet( 5):packet( 6))				*/	/*		long		third  address					 (packet( 7):packet( 8))				*/	/*		long		fourth address					 (packet( 9):packet(11))				*/   tag    = packet(0);             /* get tag 												*/   levels = packet(2);             /* get number of levels specified in address	*/   ret = (-1);                     /* so we can tell below if addr was valid 		*/							/* packet(2) = number of levels specified in addressi			*/		/* level 1 */		/* packet(4) = 1 for access to any able structure				*/		/* level 2 */		/* packet(6) = 0 ==> unused											*/							/*             1 ==> able sequence									*/		/* level 3 */		/* packet(8) = 0 ==> unused											*/							/*           = 1 ==> access tracks									*/							/*               packet(10) = which track							*/							/*					  packet(12) = 1 ==>									*/							/*           = 1 ==> access tempo meter							*/							/*               packet(9:10) thru (11:12) ==> range			*/							/*				 etc. etc. etc.											*/						   if packet(4) = n#able           /* first node must equal Able */   then do case packet(6);         /* branch on first level after "Able" */      ;                            /* 0: unused */      do;                          /* 1: Able:Sequence */         if levels = 2             /* this is the last node in the addr */         then do;                  /* send back the sequence header */            ret = Read.Sequence.Header(des,tag);         end;         else do case packet(8);   /* branch on level 3 */            ;                      /* 0: unused */            do;                    /* 1: Able:Sequence:Tracks */               if levels = 3       /* this is the last level in addr */               then do;            /* send back the track list */                  ret = Read.Track.List(des,tag);               end;               else do;                    /* Able:Sequence:Tracks:Trackn */                  track = packet(10);      /* get track number from address */                  if levels = 4            /* this is the last level in addr */                  then do;                 /* send back the track header */                     ret = Read.Track.Header(des,tag,track);                  end;                  else do case packet(12); /* branch on level 5 */                     ;                     /* 0: unused */                     do;                   /* 1: Able:Sequence:Tracks:Track#:Events */                        if levels < 7      /* must have 7 levels here to represent range of time for events */                        then do;           /* do nothing - return unknown addr below */                        end;                        /* else we can get the times and process the request */                       else ret = Read.Track.Events(des,tag,track,loc(addr(packet(13))),loc(addr(packet(15))));                     end;                     do;                   /* 2: Able:Sequence:Tracks:Track#:Timbre */                        if levels = 5      /* this is the last level in addr */                        then do;           /* read a timbre */                           ret = Read.Track.Timbre(des,tag,track);                        end;                        else do;           /* do nothing - return unknown addr */                        end;                     end;                  end;              /* of branching on level 5 */               end;                 /* of branching on level 4 */            end;            do;                     /* 2: Able:Sequence:Tempo */               if levels < 5        /* must have 5 levels here to represent range of time for events */               then do;             /* do nothing - return unknown addr below */               end;               /* else we can get the times and process the request */               else ret = Read.Sequence.Tempo.Records(des,tag,loc(addr(packet(9))),loc(addr(packet(11))));            end;            do;                     /* 3: Able:Sequence:Meter */               if levels < 5        /* must have 5 levels here to represent range of time for events */               then do;             /* do nothing - return unknown addr below */               end;               /* else we can get the times and process the request */              else  ret = Read.Sequence.Meter.Records(des,tag,loc(addr(packet(9))),loc(addr(packet(11))));            end;         end;                       /* of branching on level 3 */      end;   end;                             /* of branching on level 2 */   if ret = (-1) then do;          /* ret still initialized - means addr is unknown */      ret = Send.Error.Response (des,tag,packet,0);   end;   return ret;end Process.Request.Data.Read;Data.Write.Subroutine: proc (status,tag,des,packet) public swapable;   dcl status  fixed;   dcl tag     fixed;   dcl des     fixed;   dcl packet  array;   dcl ret     fixed;   dcl size(1) fixed;   dcl levels  fixed;   dcl records fixed;   dcl address fixed;   dcl track   fixed;   dcl in(1)   fixed;   dcl out(1)  fixed;   if (status <> 0)   then return (Send.Error.Response (des,tag,packet,status));   ret = (-1);                              /* set to impossible value so we know below if addr was valid */   write(mam) = XFER.PTR;   write(mal) = 2;   status       = read(mdi);                /* first data word - status */   size(0)      = read(mdi);                /* len of block in bytes */   size(1)      = read(mdi);                /* lsb */   write("313") = read(mdi);                /* skip msb of levels */   levels       = read(mdi);                /* get levels */   write("313") = read(mdi);                /* skip msb of level 1 */   address      = read(mdi);                /* get 1st level address */   if (address = n#able)                    /* first node must be able */   then do;      write("313") = read(mdi);             /* skip msb of level 2 */      address      = read(mdi);             /* get 2nd level address */      do case address;         ;                                  /* 0: unused */         do;                                /* Able:Sequence */            if levels = 2                   /* this is it */            then do;               ret = Write.Sequence.Header (des,tag);            end;            else do;               write("313") = read(mdi);             /* skip msb of level 3 */               address      = read(mdi);             /* get 3rd level address */               do case address;                  ;                                  /* 0: unused */                  do;                                /* 1: Able:Sequence:Tracks */                     if levels = 3                   /* this is it */                     then do;                        ;                            /* we don't receive track list */                     end;                     else do;                        write("313") = read(mdi);             /* skip msb of level 3 */                        track        = read(mdi);             /* get absolute track number */                        if levels = 4                   /* this is it */                        then do;                           ret = Write.Track.Header (des,tag,track); /* pass track number in "address" */                        end;                        else do;                           write("313") = read(mdi);             /* skip msb of level address */                           address      = read(mdi);             /* get 5th level address */                           do case address;                              ;                          /* 0: unused */                              do;                        /* 1:Able:Sequence:Tracks:Trackn:Events:R1:R2: */                                 in(0)  = read(mdi);                                 in(1)  = read(mdi);                                 out(0) = read(mdi);                                 out(1) = read(mdi);                                 ret = Write.Sequence.Events(des,tag,track,in,out);                              end;                              do;                        /* 2:Able:Sequence:Tracks:Trackn:Timbre: */                                 if (levels = 5)                                 then do;                /* handle timbre write */                                    ret = Write.Track.Timbre(des,tag,track);                                 end;                                 else do;                /* unknown addr */                                    ;                                 end;                              end;                           end;                        end;                     end;                  end;                  do;                                /* 2: Able:Sequence:Tempo */                     if levels = 5 then do;                        ret = Write.Tempo.Records (des,tag);                     end;                  end;                  do;                                /* 3: Able:Sequence:Meter */                     if levels = 5 then do;                        ret = Write.Meter.Records (des,tag);                     end;                  end;               end;            end;         end;      end;   end;   if ret = (-1) then do;          /* ret still initialized - means addr is unknown */      ret = 1;                     /* what to do here??? */   end;   return ret;end Data.Write.Subroutine;Process.Request.Data.Write: proc (packet) swapable;   dcl packet array;   /* currently handled by call from block_end receive */end Process.Request.Data.Write;Handle.Data.Transfer: proc swapable;   dcl (len,des)            fixed;   dcl subtype              fixed;   dcl data_words           lit '32';      /* Number of data words to read   */   dcl packet(data_words-1) fixed;         /* Array to hold data from packet */   dcl ret                  fixed;   write(mam)   = Packet.Ptr;               write(mal)   = P#LEN;    len     = read(md);   write(mal)   = P#SOURCE; des     = read(md);   write(mal)   = P#TYPE;      subtype      = read(md) & "377";   write(mal) = P#DATA;   write("313") = addr(packet(0));   rpc data_words;   write("373") = read(mdi);   ret = 1;            /* assume ok unless someone returns a specific error */   do case subtype;    /* Branch on specific command (0-3) */      do;   /* 0: Request Data Read */         ret = Process.Request.Data.Read(packet,des);      end;      do;   /* 1: Data Read */         /* this is generated by the request routine */      end;      do;   /* 2: Request Data Write */         ret = Process.Request.Data.Write(packet);      end;      do;   /* 3: Data Write */         /* this is generated by the request routine */      end;   end;                /* of branch on subtype */   return(ret);        /* return processed status */end Handle.Data.Transfer;