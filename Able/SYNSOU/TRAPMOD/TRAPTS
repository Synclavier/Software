/* TRAPTS   $TITLE  ROUTINES TO PROCESS TRACK SETUP PACKETS   Modified:   10/21/91 - PF  - Cleared up descrepancy in track state reporting   10/10/91 - MWH - Add Request Single Track State message   10/26/90 - MWH - Force an "answer" from all "request" messages   09/20/89 - MWH - Set multiple track states with the correct bit array   09/01/89 - MWH - Rework the protocol for release 2.2   07/28/89 - cj  - called new routines for release 2.2   05/03/89 - LSS - removed external dcl for SET.DTD.PLAY.TRACKS   05/01/89 - MWH - Support for multiple D115 boards & channels; timeouts   04/11/89 - MWH - Split TRAPMOD into modules because it is too big!   03/14/89 - PF  - changed process packet processing logic   03/13/89 - MWH - Allow zero to mean no DTD/MIDI routing   02/13/89 - MWH - Make set track mute public for rehearse mode   01/05/89 - MWH - Add send of routing states to Remote Box   12/16/88 - MWH - Add input/output routing   12/05/88 - MWH - Simplify track setup messages   11/28/88 - MWH - Clean up unreferenced public's   11/14/88 - MWH - Add group storage on Synclavier   11/10/88 - MWH - Clean up messages and update lengths   09/15/88 - PF  - Created this source file*//* This file contains TRACK STATE and GROUP procedures *//* Some local literals for track setup attributes and states */dcl a#ready   lit '0';dcl a#solo    lit '1';dcl a#mute    lit '2';dcl a#input   lit '3';dcl a#auto    lit '4';dcl a#cuepb   lit '5';dcl s#clear   lit '0';dcl s#set     lit '1';/* $page - routine to set syncl track bits for DTD monitor states *//* Set.Tbut.Bits.For.DTD.Tracks is used to set up the bits        *//* in the TBUT.PTR array to reflect the current state of the      *//* DTD tracks.                                                    */Set.Tbut.Bits.For.DTD.Tracks: proc swapable;   dcl modes    (15)  fixed;   dcl statuses (15)  fixed;   dcl i              fixed;   call SEND.FOR.DTD.TRACK.MODES (modes,statuses);  /* leave values at 0 if dtd not ready */   write(mam) = tbut.ptr;   write(mal) = first.lod.track;   /* set B.READY.TRK bits in TBUT.PTR array for all DTD tracks */   /* that are ready,  since that is how the protocol wants     */   /* to see the information:                                   */   do i = 0 to 15;      if (statuses(i) = 1)      then write(mdi) = read(md) | b.ready.trk;      else write(mdi) = read(md) & (not b.ready.trk);   end;   /* Also set the b.input track bits in the TBUT.PTR array     */   write(mam) = tbut.ptr;   write(mal) = first.lod.track;   do i = 0 to 15;      if modes(i) = 1            /* if track is input mode,  record that */      then do;                   /* fact, but preserve repro/auto/cuepb  */         write(mdi) = read(md) | b.input.trk;      end;      else do;                   /* not input mode.                      */         write(md ) = read(md) & (not b.input.trk);          if (modes(i) = 0)       /* if REPRO                             */         or (modes(i) = 2)       /* or AUTO                              */         then write(mdi) = read(md) | b.auto.cue.trk;         else if (modes(i) = 3)  /* else record that it was CUE PB       */         then write(mdi) = read(md) & (not b.auto.cue.trk);      end;   end;end Set.Tbut.Bits.For.DTD.Tracks;/* $Subtitle Routine to send the attributes of a range of tracks */Send.Multiple.Track.States.Packet: proc (attr,des,tag) swapable;   dcl attr       fixed;              /* Type of packet to send based on track attributes */   dcl des        fixed;              /* Packet destination */   dcl tag        fixed;              /* Caller's ID to be returned */   dcl bit        fixed;              /* Which bit to check for in tbut */   dcl states(15) fixed;              /* Temp variable to hold 256 states */   dcl strks(15)  fixed;              /* Build sequencer track states here */   dcl dtrks(7)   fixed;              /* Build DTD track states here */   dcl (i,j)      fixed;   /* Begin by setting up the tbut.bits for the DTD tracks */   call Set.Tbut.Bits.For.DTD.Tracks;   do case attr;      bit = b.ready.trk;      				/* 0: a#ready   */      bit = b.soloed.trk;     				/* 1: a#solo    */      bit = b.muted.trk;      				/* 2: a#mute    */      bit = b.input.trk;      				/* 3: a#input   */      bit = b.input.trk|b.auto.cue.trk;   	/* 4: a#auto    */      bit = b.input.trk|b.auto.cue.trk;   	/* 5: a#cuepb   */   end;   /* Set up "states" array in Synclavier format, not protocol format */   write(mam) = tbut.ptr;   do i = 0 to 15;      do j = 0 to 15;         if attr <= a#input then do;            if ((read(mdi) & bit) <> 0)            then states(i) = states(i) | bits(j);         end;         else if attr = a#auto then do;            if  ((read(mdi) & bit) = b.auto.cue.trk)    /* input bit must be clear */            then states(i) = states(i) | bits(j);         end;         else if attr = a#cuepb then do;                /* input and auto bits are clear */            if  ((read(mdi) & bit) = 0)              then states(i) = states(i) | bits(j);         end;      end;   end;   /* Convert "states" to two protocol-format arrays */   call sync.bits.to.proto(states,strks,dtrks);   /* Now, build the output packet */   write(mam) = misc.ptr;      write(mdi) = L#Track_States;   write(mdi) = des;   write(mdi) = T#Track_States;   write(mdi) = tag;   write(mdi) = 0;                     /* Sequencer track base */   write("313") = addr(strks(0));   rpc 16;   write(mdi) = read("373");           /* Sequencer tracks */   write(mdi) = 0;                     /* DTD track base */   write("313") = addr(dtrks(0));   rpc 8;   write(mdi) = read("373");           /* DTD tracks */   write(mdi) = shl(attr,8);           /* Attribute requested */   return(Send.Protocol.Packet(misc.ptr,1));end Send.Multiple.Track.States.Packet;/* $SUBTITLE  Track state routines */Request.Track.States: proc(packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl tag       fixed;   dcl attribute fixed;   dcl state     fixed;   dcl ret       fixed;   tag = packet(0);                /* Get arguments passed in */   attribute = shr(packet(1),8);   if (attribute < a#ready)        /* Be sure arguments are within limits */   OR (attribute > a#cuepb)   then do;                        /* Send back a short message with only a tag */      call Send.Only.Tag(des,tag,T#Track_States);      return(TRUE);   end;   do case attribute;      do;                          /* 0: Ready */         ret = Send.Multiple.Track.States.Packet(a#ready,des,tag);      end;      do;                          /* 1: Solo */         ret = Send.Multiple.Track.States.Packet(a#solo,des,tag);      end;      do;                          /* 2: Mute */         ret = Send.Multiple.Track.States.Packet(a#mute,des,tag);      end;      do;                          /* 3: Request tracks in input mode */         ret = Send.Multiple.Track.States.Packet(a#input,des,tag);      end;      do;                          /* 4: Request tracks in auto mode */         ret = Send.Multiple.Track.States.Packet(a#auto,des,tag);      end;      do;                          /* 5: Request tracks in cue playback mode */         ret = Send.Multiple.Track.States.Packet(a#cuepb,des,tag);      end;   end;   /* of do case attribute */   return(ret);end Request.Track.States;Set.Track.Ready.State: proc (first.trk#,last.trk#,state) swapable;   dcl first.trk#  fixed;   dcl last.trk#   fixed;   dcl state       fixed;    /* 0 = Clear, 1 = Set */   dcl abs.trk#    fixed;   dcl tbits       fixed;   if last.trk# < first.trk# then do;   /* swap out of order trk range */      abs.trk# = first.trk#; first.trk# = last.trk#; last.trk# = abs.trk#;   end;   do abs.trk# = first.trk# to last.trk#;      if  (abs.trk#>= first.lod.track)      and (abs.trk#< last.lod.track )      then tbits = tbits | bits(abs.trk#-first.lod.track);   /* compute bits for live tracks */      else do;         write(mam)=tbut.ptr;         write(mal)=abs.trk#;         if (state = s#set) then do;            if (read(md)&b.ready.trk)=0            then do;               num.enabled.trks=num.enabled.trks+1;               write(md)=read(md) | b.ready.trk;               /* Create a system event when the safe/ready status */               /* of a track is changed:                           */               new.seq.info = new.seq.info | 4096;            end;         end;         else if (state = s#clear) then do;            if (read(md)&b.ready.trk)<>0            then do;               num.enabled.trks=num.enabled.trks-1;               write(md)=read(md) & (not b.ready.trk);               /* Create a system event when the safe/ready status */               /* of a track is changed:                           */               new.seq.info = new.seq.info | 4096;            end;         end;      end;   end;   /* Handle change in safe/ready of DTD tracks: */   tbits = tbits & DTD.Avail.Trks;   if tbits <> 0   then call Set.DTD.Drive.Status(state,tbits);   call Display.Track.Buttons;                     /* update everybody */      return(1);end Set.Track.Ready.State;Set.Track.Mute.State: proc (first.trk#,last.trk#,state) swapable;   dcl (first.trk#,last.trk#) fixed;   dcl state                  fixed;   dcl abs.trk#               fixed;   dcl recompute.flag         fixed;   if last.trk# < first.trk# then do;   /* swap out of order trk range */      abs.trk# = first.trk#; first.trk# = last.trk#; last.trk# = abs.trk#;   end;   recompute.flag=0;                    /* init update flag                  		*/	/* Begin by expanding all track groupings */		CLEAR.GRP.SEL.BITS();									/* CLEAR GROUP SELECT BITS		*/		   do abs.trk#=first.trk# to last.trk#;		RECURS.TRACK.GROUP(abs.trk#);						/* EXPAND TO GET ALL TRACKS	*/	end;	   do abs.trk#=NUM.KBD.TRACKS to 255;      write(mam)=tbut.ptr;              				/* index to this track			*/      write(mal)=abs.trk#;		if ((read(md) & b.grpsel.trk) != 0)				/* if member of group			*/		{			if  (((state<>s#clear)			and   ((read(md)&b.muted.trk)=0))			or   ((state=s#clear)			and   ((read(md)&b.muted.trk)<>0)))			{                         		/* if the mute state is changing  */				if state=s#clear				then write(md)=read(md)&(not b.muted.trk); /* clear muted bit    */				else write(md)=read(md) | b.muted.trk;     /* set muted bit      */				recompute.flag=1;                          /* set flag for below */			}		}   end;   if recompute.flag then do;      call compute.active.trks;              /* recompute active.tracks */      new.seq.info = new.seq.info | 2048;    /* track mute change       */   end;   return(1);end Set.Track.Mute.State;Set.Track.Monitor.State: proc (trk#,attr,state) swapable;   dcl trk#  fixed;   dcl attr  fixed;              /* 0 = repro        */                                 /* 1 = input        */                                 /* 2 = auto         */                                 /* 3 = cue playback */   dcl state fixed;              /* s#clear or s#set */   dcl tbits fixed;   if  (trk#>=first.lod.track)   and (trk#< last.lod.track )   then do;                      /* Handle dtd tracks */      tbits = bits(trk#-first.lod.track) & DTD.Avail.Trks;      if state = s#clear then do;                  /* Maybe modify target state if we're CLEARING */         write(mam) = tbut.ptr;         write(mal) = trk#;         if attr = 1 then do;       /* s#clear input */            if ((read(md) & b.auto.cue.trk) <> 0)  /* See if bit is set */            then attr = 2;                         /* Set track to AUTO */            else attr = 3;                         /* Set track to CUEPB */         end;         else if attr = 2 then do;  /* s#clear auto */            if ((read(md) & b.input.trk) = 0)      /* See if input bit is clear */            then attr = 3;                         /* Set track to CUEPB */            else return(1);                        /* Ignore if track is in INPUT mode */         end;         else if attr = 3 then do;  /* s#clear cuepb */            if ((read(md) & b.input.trk) = 0)      /* See if input bit is clear */            then attr = 2;                         /* Set track to AUTO */            else return(1);                        /* Ignore if track is in INPUT mode */         end;      end;      call Set.DTD.Drive.Mode(attr,tbits);   end;     /* of handle DTD tracks */   else do;                                        /* synclavier tracks */      /* nothing for now */   end;   return(1);end Set.Track.Monitor.State;Set.Track.State: proc(packet) swapable;   dcl packet    array;   dcl trk#      fixed;    /* Might be sequencer or DTD track */   dcl kind      fixed;    /* 0=Seq track, 1=DTD track */   dcl attribute fixed;    /* 0=ready, 1=solo, 2=mute, 3=input, 4=auto, 5=cuepb */   dcl state     fixed;    /* 0=clear, 1=set */   dcl ret       fixed;   trk#      = packet(0);          /* Get arguments passed in */   kind      = shr(packet(1),8);   attribute = packet(1) & "377";   state     = shr(packet(2),8);   if (state     < s#clear)        /* Be sure arguments are within limits */   OR (state     > s#set  )   OR (attribute < a#ready)   OR (attribute > a#cuepb)   OR (kind      < 0)   OR (kind      > 1)   then return(TRUE);   do case kind;      trk# = proto.to.sync.strk(trk#);   /* 0: Convert SEQ track */      trk# = proto.to.sync.dtrk(trk#);   /* 1: Convert DTD track */   end;	   do case attribute;      do;                          /* 0: Ready / Unready */         ret = Set.Track.Ready.State(trk#,trk#,state);      end;      do;                          /* 1: Solo / Unsolo */         ret = Set.Track.Solo.State(trk#,trk#,state);      end;      do;                          /* 2: Mute / Unmute */         ret = Set.Track.Mute.State(trk#,trk#,state);      end;      do;                          /* 4: Set / Clear Input */         call Set.Tbut.Bits.For.DTD.Tracks;         ret = Set.Track.Monitor.State(trk#,1,state);      end;      do;                          /* 5: Set / Clear Auto */         call Set.Tbut.Bits.For.DTD.Tracks;         ret = Set.Track.Monitor.State(trk#,2,state);      end;      do;                          /* 6: Set / Clear Cue Playback */         call Set.Tbut.Bits.For.DTD.Tracks;         ret = Set.Track.Monitor.State(trk#,3,state);      end;   end;   /* of do case attribute */   return(ret);end Set.Track.State;/* $Subtitle Routines to set the attributes of all tracks */Set.Multiple.Ready.States: proc (trks,state) swapable;   dcl trks        array;   dcl state       fixed;   dcl abs.trk#    fixed;   dcl tbits       fixed;   dcl (i,j)       fixed;   write(mam)=tbut.ptr;   do i=0 to 15;      do j=0 to 15;         if (trks(i)&bits(j))<>0 then do;            abs.trk#=(shl(i,4)+j);            if  (abs.trk#>= first.lod.track)            and (abs.trk#< last.lod.track )            then tbits = tbits | bits(abs.trk#-first.lod.track);   /* compute bits for live tracks */            else do;               write(mal)=abs.trk#;               if (state = s#set) then do;                  if (read(md)&b.ready.trk)=0                  then do;                     num.enabled.trks=num.enabled.trks+1;                     write(md)=read(md) | b.ready.trk;                     new.seq.info = new.seq.info | 4096;                  end;               end;               else if (state = s#clear) then do;                  if (read(md)&b.ready.trk)<>0                  then do;                     num.enabled.trks=num.enabled.trks-1;                     write(md)=read(md) & (not b.ready.trk);                     new.seq.info = new.seq.info | 4096;                  end;               end;            end;         end;      end;   end;   tbits = tbits & DTD.Avail.Trks;   if tbits <> 0   then do;      call Set.DTD.Drive.Status(state,tbits);   end;   call Display.Track.Buttons;  /* update possible VK display */      return(1);end Set.Multiple.Ready.States;Set.Multiple.Solo.States: proc (trks,state) swapable;  /* set solo state of tracks */   dcl trks                   array;   dcl state                  fixed; /* 0=>off, 1=>on */   dcl abs.trk#               fixed;   dcl recompute.flag         boolean;   dcl (i,j)                  fixed;   recompute.flag=false;   write(mam)=tbut.ptr;   do i=0 to 15;      do j=0 to 15;         if (trks(i)&bits(j))<>0 then do;   /* change the state of this track */            abs.trk#  =(shl(i,4)+j);            write(mal)=abs.trk#;            if  (recd<>0)                   /* recording                */            and ((abs.trk#=recd.trk)        /* on this synclavier track */            or  ((recd.trk<>0)              /* synclavier recording     */            and ((read(md)&b.ready.trk)<>0)))  /* this track is armed   */            then do;                        /* recording on this track  */               /* nothing */            end;            else do;                             /* as long as not recording */               if state=s#clear then do;         /* unsolo track */                  if (read(md)&b.soloed.trk)<>0 then do;    /* only unsolo if currently soloed */                     write(md)=read(md)&(not b.soloed.trk); /* clear soloed bit */                     num.of.soloed.tracks=num.of.soloed.tracks-1;                     if abs.trk#=recd.trk           /* if track was blinking,   */                     then recd.trk=0;               /* turn it off              */                     recompute.flag=true;                  end;               end;               else do;                  if (read(md)&b.soloed.trk)=0 then do; /* only solo if currently unsoloed */                     write(md)=read(md) | b.soloed.trk; /* set soloed bit */                     num.of.soloed.tracks=num.of.soloed.tracks+1;                     if  (recd=0)                      and (lod.recd.tracks=0)                     and (abs.trk#<first.lod.track)                     then recd.trk=abs.trk#;     /* and arm for record */                     recompute.flag=true;                  end;               end;            end;         end;      end;   end;   if recompute.flag then call compute.active.trks; /* recompute active.tracks */   call Display.Track.Buttons; /* display possibly new track buttons */                               /* and create an event to tell        */                               /* people of the solo change          */   return(1);end Set.Multiple.Solo.States;Set.Multiple.Mute.States: proc (trks,state) swapable;   dcl trks                   array;   dcl state                  fixed;   dcl abs.trk#               fixed;   dcl recompute.flag         fixed;   dcl (i,j)                  fixed;   recompute.flag=0;                    /* init update flag                  */	/* Begin by expanding all track groupings */		CLEAR.GRP.SEL.BITS();									/* CLEAR GROUP SELECT BITS		*/   do i=0 to 15;      do j=0 to 15;         if (trks(i)&bits(j))<>0 then do;   			/* change the state of this track */            abs.trk#  =(shl(i,4)+j);				RECURS.TRACK.GROUP(abs.trk#);				/* EXPAND TO GET ALL TRACKS		*/			end;		end;	end;	   do abs.trk#=NUM.KBD.TRACKS to 255;      write(mam)=tbut.ptr;              				/* index to this track			*/      write(mal)=abs.trk#;		if ((read(md) & b.grpsel.trk) != 0)				/* if member of group			*/		{			if  (((state<>s#clear)			and   ((read(md)&b.muted.trk)=0))			or   ((state=s#clear)			and   ((read(md)&b.muted.trk)<>0)))			{                         		/* if the mute state is changing  */				if state=s#clear				then write(md)=read(md)&(not b.muted.trk); /* clear muted bit    */				else write(md)=read(md) | b.muted.trk;     /* set muted bit      */				recompute.flag=1;                          /* set flag for below */			}		}   end;	if recompute.flag then do;		call compute.active.trks;              		/* recompute active.tracks */		new.seq.info = new.seq.info | 2048;    		/* track mute change       */	end;   return(1);end Set.Multiple.Mute.States;Set.Multiple.Monitor.States: proc (trks,attr,state) swapable;   dcl trks     array;   dcl attr     fixed;           /* 0 = repro        */                                 /* 1 = input        */                                 /* 2 = auto         */                                 /* 3 = cue playback */   dcl state    fixed;           /* s#clear or s#set */   dcl tbits    fixed;   dcl abs.trk# fixed;   /* Begin by setting up the tbut.bits for the DTD tracks */   call Set.Tbut.Bits.For.DTD.Tracks;   do abs.trk#=first.lod.track to last.lod.track;      if (trks(shr(abs.trk#,4))&bits(abs.trk#&15))<>0      then do;         /* Clear must be done one at a time; each may revert to a DIFFERENT state! */         if state = s#clear then do;            call Set.Track.Monitor.State(abs.trk#,attr,s#clear);         end;         /* Accumulate track bits for SET; may be done all at once */         else tbits = tbits | bits(abs.trk#-first.lod.track);      end;   end;   tbits = tbits & DTD.Avail.Trks;   if tbits <> 0   then do;      call Set.DTD.Drive.Mode(attr,tbits);   end;   return(1);end Set.Multiple.Monitor.States;Set.Multiple.Track.States: proc(packet) swapable;   dcl packet    array;   dcl Sbase     fixed;   dcl Dbase     fixed;   dcl attribute fixed;   dcl state     fixed;   dcl ret       fixed;   dcl i         fixed;   dcl tbits(15) fixed;  /* Build Synclavier-style track bit array here */   Sbase  = packet(0);             /* Get arguments passed in */   Dbase = packet(17);   attribute = shr(packet(26),8);   state     = packet(26) & "377";   if (state     < s#clear)        /* Be sure arguments are within limits */   OR (state     > s#set  )   OR (attribute < a#ready)   OR (attribute > a#cuepb)   OR (Sbase    <> 0)   OR (Dbase    <> 0)   then return(TRUE);   /* Re-pack the incoming track bits from S-trk and D-trk arrays to Synclavier format */   call proto.to.sync.bits(loc(addr(packet(1))),loc(addr(packet(18))),tbits);   do case attribute;      do;                          /* 0: Ready / Unready */         ret = Set.Multiple.Ready.States(tbits,state);      end;      do;                          /* 1: Solo / Unsolo */         ret = Set.Multiple.Solo.States(tbits,state);      end;      do;                          /* 2: Mute / Unmute */         ret = Set.Multiple.Mute.States(tbits,state);      end;      do;                          /* 3: Set track to input mode */         ret = Set.Multiple.Monitor.States(tbits,1,state);      end;      do;                          /* 4: Set track to auto mode */         ret = Set.Multiple.Monitor.States(tbits,2,state);      end;      do;                          /* 5: Set track to cue playback mode */         ret = Set.Multiple.Monitor.States(tbits,3,state);      end;   end;   /* of do case attribute */   return(ret);end Set.Multiple.Track.States;Clear.All.Track.States: proc(packet) swapable;   dcl packet    array;   dcl attribute fixed;   dcl ret       fixed;   attribute = shr(packet(0),8);   /* Get arguments passed in */   if (attribute < a#ready)        /* Be sure arguments are within limits */   OR (attribute > a#cuepb)   then return(TRUE);   do case attribute;      do;     /* 0:  Clear Readys       */         ret = Set.Track.Ready.State(0,max.tracks,0);      end;      do;     /* 1:  Clear Solos        */         ret = CLEAR.TRACK.SOLO.STATES();      end;      do;     /* 2:  Clear Mutes        */         ret = Set.Track.Mute.State(0,max.tracks,0);      end;      do;     /* 3:  Clear Input Tracks */         call blockset(misc.buf,16,"177777");         ret = Set.Multiple.Monitor.States(misc.buf,1,s#clear);      end;      do;     /* 4:  Clear Auto Tracks  */         call blockset(misc.buf,16,"177777");         ret = Set.Multiple.Monitor.States(misc.buf,2,s#clear);      end;      do;     /* 5:  Clear Cuepb Tracks */         call blockset(misc.buf,16,"177777");         ret = Set.Multiple.Monitor.States(misc.buf,3,s#clear);      end;   end;   /* of do case attribute */   return(ret);end Clear.All.Track.States;Send.Single.Track.State: proc(packet,des) swapable;   dcl packet     array;   dcl des        fixed;   dcl tag        fixed;   dcl p_trk#     fixed;   /* Might be sequencer or DTD track - protocol format */   dcl s_trk#     fixed;   /* Track number converted to Synclavier format */   dcl kind       fixed;   /* 0=Seq track, 1=DTD track */   dcl flags      fixed;   /* Output bits: 1=ready, 2=solo, 4=mute, 8=input, 16=auto, 32=cuepb, 64=note, 128=empty */   dcl i          fixed;   /* From 11-TDCLS */   DCL TIM.HEAD.LOOKUP    PROC(FIXED,FIXED) EXTERNAL; /* LOOK UP SINGLE WORD FROM SPECIFIED TIMBRE INFO AREA */   /* From TIMLITS (we're out of symbol table space!!) */   DCL TIM.SYNTH.TYP         LIT  '( 12)';  /* SYNTH TYPE            */   DCL TIM#POLY              LIT      '2';  /* SYNTH TYPE IS POLY    */   tag       = packet(0);          /* Get arguments passed in */   p_trk#    = packet(1);   kind      = shr(packet(2),8);   if (kind < 0)                  /* Be sure arguments are within limits */   OR (kind > 1)   then do;      call Send.Only.Tag(des,tag,T#Single_Track_State);      return(TRUE);   end;   do case kind;      s_trk# = proto.to.sync.strk(p_trk#);     /* 0: Convert SEQ track */      do;         s_trk# = proto.to.sync.dtrk(p_trk#);  /* 1: Convert DTD track */         call Set.Tbut.Bits.For.DTD.Tracks;      end;   end;   flags = 0;              /* Initialize output flags */   /* Now, see which bits we should set in "flags" */   write(mam) = tbut.ptr;   write(mal) = s_trk#;   if ((read(md) & b.ready.trk) <> 0)   then flags = flags | 1;               /* Track is ready */   if ((read(md) & b.soloed.trk) <> 0)   then flags = flags | 2;               /* Track is soloed */   if ((read(md) & b.muted.trk) <> 0)   then flags = flags | 4;               /* Track is muted */   if ((read(md) & b.input.trk) <> 0)   then flags = flags | 8;               /* Track is in input mode */   if ((read(md) & b.auto.cue.trk) <> 0)   then flags = flags | 16;              /* Track is in auto mode */   else flags = flags | 32;              /* Track is in cue playback mode */   /* See if it is a poly note track */   i = trk.head.lookup(s_trk#,THD.CTIMB);   if i <> 0 then do;      if (tim.head.lookup(i,TIM.SYNTH.TYP) & TIM#POLY) <> 0      then flags = flags | 64;   end;   /* See if there are any notes at all on the track */   write(mam)=trk.head;   write(mal)=s_trk#;   if (read(md) = 0)                     /* No track head here */   then flags = flags | 128;             /* Definitely no notes! */   else do;      write(mam) = read(md);             /* Point at track head */      write(mal) = thd.nn.msb;           /* Check note count */      if (read(mdi) | read(mdi)) = 0     /* No notes on the track */      then flags = flags | 128;   end;   /* See if it is a DTD cue track */   if (trk.head.lookup(s_trk#,THD.CUE.TRACK) <> 0)    then flags = flags | 256;   /* Now, build the output packet */   write(mam) = misc.ptr;      write(mdi) = L#Single_Track_State;   write(mdi) = des;   write(mdi) = T#Single_Track_State;   write(mdi) = tag;   write(mdi) = p_trk#;                  /* Track number in Protocol format */   write(mdi) = shl(kind,8);             /* Track type (+ unused byte) */   write(mdi) = 0;                       /* Track attribute bits (MSB) */   write(mdi) = flags;                   /* Track attribute bits (LSB) */   return(Send.Protocol.Packet(misc.ptr,1));end Send.Single.Track.State;/* $Subtitle Routines to deal with groups *//* Format of "groups_file":   This file contains bitmaps and labels for 32 groups defined in the   Remote Box (or any part of the Synclavier system).  The groups are   stored in "groups_file" on the system device, a 4-sector file.   The format is:                  <tracks in group>  16 words (256 bits)                  <label>            16 words (32 chars, nulls at end)   This structure repeats 32 times, once for each group.  If the file   is missing, or the wrong size, it is re-created.*/dcl groups_file   data (':USER:.groups');            /* Groups file treename   */dcl groups_length lit '4';                      /* Sectors in groups file */dcl rec_length    lit '32';                     /* Length of each record  */dcl Valid.Groups  proc (fixed,fixed) recursive; /* Sends out valid groups *//* Note: this routine uses misc.buf */Read.A.Group: proc (group,output) swapable;   dcl group  fixed;       /* Which group number to read */   dcl output array;       /* 16 words to write the group's track bits in */   dcl f#m    fixed;   dcl f#l    fixed;   dcl sect   fixed;   dcl word   fixed;   dcl i      fixed;   if locate(groups_file,0) = FALSE         /* No groups file exists  */   then return(0);                          /* We're done; failure    */   f#m = F#MS_Sector;           /* Locate worked, remember where found */   f#l = F#LS_Sector;   word = rec_length * group;   /* Word offset based on record length */   sect = shr(word,8);          /* Sectors */   if sect > 3                  /* Looking past end of file? */   then return(0);              /* If so, quit now */   f#l = f#l + sect;            /* Add sectors to file pointer */   word = word & "377";         /* Keep just the words */   if f#l ilt sect              /* Carry */   then f#m = f#m + 1;   call readdata(f#m,f#l,misc.buf,256);   do i = 0 to 15;      output(i) = misc.buf(word+i);   end;   return(1);                   /* Success */end Read.A.Group;Request.Group: proc (packet,des) swapable;   dcl packet     array;   dcl des        fixed;   dcl tag        fixed;   dcl group      fixed;   dcl strks(15)  fixed;     /* Build sequencer track states here */   dcl dtrks(7)   fixed;     /* Build DTD track states here */   dcl i          fixed;   tag   = packet(0);   group = shr(packet(1),8);    /* Get group number from packet */   if Read.A.Group(group,copy.buf) = 0   then return(TRUE);   /* Convert the group to two protocol-format arrays */   call sync.bits.to.proto(copy.buf,strks,dtrks);   write(mam) = misc.ptr;       /* Build output packet in external memory */   write(mdi) = L#Group;   write(mdi) = des;   write(mdi) = T#Group;   write(mdi) = tag;   write(mdi) = 0;                     /* Sequencer track base */   write("313") = addr(strks(0));   rpc 16;   write(mdi) = read("373");           /* Sequencer tracks */   write(mdi) = 0;                     /* DTD track base */   write("313") = addr(dtrks(0));   rpc 8;   write(mdi) = read("373");           /* DTD tracks */   write(mdi) = shl(group,8);   return(Send.Protocol.Packet(misc.ptr,1));end Request.Group;/* If we receive this message, someone is defining a group for us to save */Set.Group: proc (packet,des) swapable;   dcl packet    array;   dcl des       fixed;   dcl f#m       fixed;   dcl f#l       fixed;   dcl sect      fixed;   dcl word      fixed;   dcl group     fixed;   dcl tbits(15) fixed;  /* Build Synclavier-style track bit array here */   dcl i         fixed;   /* Re-pack the incoming track bits from S-trk and D-trk arrays to Synclavier format */   call proto.to.sync.bits(loc(addr(packet(1))),loc(addr(packet(18))),tbits);   i = locate(groups_file,0);   if i = FALSE                       /* No groups file exists  */   OR F#LS_Length <> groups_length    /* OR it's the wrong size */   OR F#Words <> shl(groups_length,8)   then do;      if replace(groups_file,T#Data,0,groups_length,shl(groups_length,8),0) = false      then return(1);                 /* We can't save the group */      if locate(groups_file,0) = false      then return(1);      /* Since we've re-created the file, zero out the sectors allocated */      f#m = F#MS_Sector;      f#l = F#LS_Sector;      call blockset(misc.buf,256,0);      do i=1 to 4;         call writedata(f#m,f#l,misc.buf,256);         f#l = f#l + 1;         if f#l = 0 then f#m = f#m + 1;      end;   end;   f#m = F#MS_Sector;  /* One of the locates worked, remember where found */   f#l = F#LS_Sector;   group = shr(packet(26),8);   /* Get group number from packet */   word = rec_length * group;   /* Word offset based on record length */   sect = shr(word,8);          /* Sectors */   if sect > (groups_length-1)  /* Looking past end of file? */   then return(1);              /* If so, quit now */   f#l = f#l + sect;            /* Add sectors to file pointer */   word = word & "377";         /* Keep just the words */   if f#l ilt sect              /* Carry */   then f#m = f#m + 1;   call readdata(f#m,f#l,misc.buf,256);   call blockmove(tbits,loc(addr(misc.buf(word))),16);   call writedata(f#m,f#l,misc.buf,256);   return(Valid.Groups(des,0)); /* Now send list of valid groups, then we're done */end Set.Group;Valid.Groups: proc (des,tag) swapable;   dcl des     fixed;            /* Destination node */   dcl tag     fixed;            /* Caller's ID to be returned */   dcl f#m     fixed;            /* File pointer */   dcl f#l     fixed;   dcl word    fixed;            /* Word offset in file (as read into misc.buf) */   dcl group   fixed;            /* Current group we're looking at */   dcl temp(1) fixed;            /* Temp long word used to set bit in "bits" */   dcl bits(1) fixed;            /* Result to be returned: 1 bit per group found */   dcl i       fixed;   call str32(0,0,bits);         /* No groups to return yet */   if locate(groups_file,0) <> FALSE        /* Groups file does exist */   then do;      f#m = F#MS_Sector;        /* Locate worked, remember where found */      f#l = F#LS_Sector;      word = 0;      call readdata(f#m,f#l,misc.buf,256);      do group=0 to 31;               /* Loop over all groups */         if (word & "177400") <> 0 then do;            f#l = f#l + 1;            /* Next sector */            if f#l = 0            then f#m = f#m + 1;       /* Carry */            word = word & "377";      /* Keep just the words */            call readdata(f#m,f#l,misc.buf,256);         end;         do i=0 to 15;                /* Look for non-zero bits in group */            if misc.buf(word+i) <> 0            then do;               call str32(0,1,temp);          /* Set first bit */               call shl32(temp,group);        /* Put bit in this group's position */               call add32(bits,temp,bits);    /* Set bit in result */               i = 15;                        /* Break loop; found a non-zero word */            end;         end;         word = word + rec_length; /* Get next Word offset based on record length */      end;   /* of loop over groups   */   end;      /* of groups file exists */   write(mam) = misc.ptr;          /* Build output packet in external memory */   write(mdi) = L#Valid_Groups;   write(mdi) = des;   write(mdi) = T#Valid_Groups;   write(mdi) = tag;   write(mdi) = bits(0);   write(mdi) = bits(1);   return(Send.Protocol.Packet(misc.ptr,1));end Valid.Groups;Set.Track.Group.States: proc(packet) swapable;   dcl packet      array;   dcl group       fixed;   dcl attribute   fixed;   dcl state       fixed;   dcl tracks (15) fixed;   dcl ret         fixed;   group     = shr(packet(0),8);   /* Get arguments passed in */   attribute = packet(0) & "377";   state     = shr(packet(1),8);   if (state     < s#clear)        /* Be sure arguments are within limits */   OR (state     > s#set  )   OR (attribute < a#ready)   OR (attribute > a#cuepb)   then return(1);   if Read.A.Group(group,tracks) = 0   then return(TRUE);   do case attribute;      do;                          /* 0: Ready / Unready */         ret = Set.Multiple.Ready.States(tracks,state);      end;      do;                          /* 1: Solo / Unsolo */         ret = Set.Multiple.Solo.States(tracks,state);      end;      do;                          /* 2: Mute / Unmute */         ret = Set.Multiple.Mute.States(tracks,state);      end;      do;                          /* 3: Set track to input mode */         ret = Set.Multiple.Monitor.States(tracks,1,state);      end;      do;                          /* 4: Set track to auto mode */         ret = Set.Multiple.Monitor.States(tracks,2,state);      end;      do;                          /* 5: Set track to cue playback mode */         ret = Set.Multiple.Monitor.States(tracks,3,state);      end;   end;   /* of do case attribute */   return(ret);end Set.Track.Group.States;