/*ииииииииииииииииииии  A B O U T   T H I S   F I L E  ииииииииииииииииииии*//*FILENAME: APVSOUPATH: 	 :SYNSOU:APVMOD:APVSOUCONTAINS: SOURCE CODE FOR TY'S ABSOLUTE PRECISION VARIABLE SUBROUTINESREVISION HISTORY:02	2000/06/13	Todd Yvega	Accelerated apv_quotient() and apv_mod().01	1999/10/24	Todd Yvega	Converted to work within the Synclavier RTP environment.  However, won't survive a call to NAH.COLLECT()00	1998/09/07	Todd Yvega	Created.  (Stand-alone version - claimed all of external memory for itself.)*//*ииииииииииииииииииииииии  D E S C R I P T I O N  ииииииииииииииииииииииии*//*THIS FILE CONTAINS A LIBRARY OF PROCEDURES AND FUNCTIONS FOR USING "ABSOLUTEPRECISION VARIABLES" WITHIN THE SYNCLAVIER RTP ENVIRONMENT.Description of Absolute Precision Variables:Absolute Precision Variables, hereafter referred to as "apv"s, are dynamically allocated from the NAH area ofexternal memory at run-time and will grow and shrink to any size as needed.  A pointer to the absolute sectoraddress of the first node (aka head node) should be maintained by the program as a normal XPL pointer variable.Each node occupies a sector of external memory.Head Node:	Word 0:			Forward pointer to the sector address of the subsequent node.  (null if no subsequent node exists.)	Word 1:			Total word length of this apv variable in unsigned fixed format.	Words 002-255:	Signed fixed integer data in ascending significance (i.e., Word 2 is the least significant word)*.						(These Words are indexed as 0 through 253.)Subsequent Nodes:	Word 0:			Forward pointer to the sector address of the subsequent node.  (null if no subsequent node exists.)	Words 1-255:	Signed fixed integer data in ascending significance (i.e., Word 1 is the least significant word).						(These Words are indexed as (254 through 508) plus 255 for each susequent node.)*	This of course only pertains to APVs used to represent numeric values.  APVs need not only be used for arithmetic however.	The procedure "apv_print" provides an example in which an APV is used to hold a string of indeterminant length.	It's also convenient to use APVs as dynamically sized arrays of pointers to other APVs.Note: The following procedures will return without completing their tasks if memory is not available.Consequently one should check if (ertyp != null) after each call.	apv_allocate_node	apv_duplicate	apv_put_word	apv_negate	apv_or	apv_word_shr	apv_word_shl	apv_shr	apv_shl	apv_output_s32	apv_addsub	apv_multiply	apv_quotient	apv_mod	apv_gcd	apv_reduce	apv_printNote: The following procedures also will return without completing their tasks if a division by zero error occurs.Consequently one should check if (ertyp != null) after each call.	apv_quotient	apv_mod	apv_gcd	apv_reduceNote: The following procedure will return without completing its task if a sign error or overflow error occurs.Consequently one should check if (ertyp != null) after each call.	apv_output_u32*/module S#APV.0;/*иииииииииииииии  L I T E R A L   D E C L A R A T I O N S  иииииииииииииии*/insert ':-XPL:ASCIILIT';insert ':SYNLITS:COMLITS';		//	dcl pdl.size  lit '1500';insert ':SYNLITS:GLOBLITS'; 	//	D4567 and external memory literalsinsert ':SYNLITS:THDLITS';		//	NLS.FOR, NLS.REV, etc.insert ':SYNAUXS:ERRLITS';		//	err.oominsert ':SYNLITS:APVLITS';insert ':SYNLITS:L#ASM.0';		//	TY's pseudo assembly language literals/*ииииииииииииииии  E X T E R N A L   R E F E R E N C E S  ииииииииииииииии*/insert ':SYNMODS:GLOBDCL';		//	set.error(), ertypinsert ':SYNRDCLS:04-SDCLS';	//	deallocate.nah.block()insert ':SYNRDCLS:03-PDCLS';	//	nah.ptr, nah.free, nah.#freeinsert ':SYNMODS:TTYDCL';		//	pc(), ps(), pcr()/*иииииииииииииииии  F O R W A R D   R E F E R E N C E S  иииииииииииииииии*//*ииииииииииииииииии  P R I V A T E   V A R I A B L E S  ииииииииииииииииии*//*ииииииииииииииииии   P U B L I C   V A R I A B L E S   ииииииииииииииииии*//*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE relinquish_high_word											*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "relinquish_high_word" DECREMENTS THE WORD LENGTH OF THE APV POINTED TO BY THE PASSED POINTER.//	IF THE RELINQUISHED WORD IS THE FIRST DATA WORD OF A NODE, THE FORWARD POINTER TO THAT NODE IS ZEROED AND//	THE NODE IS INSERTED AT THE FRONT OF THE FREE NODE LIST.relinquish_high_word: proc (apv_ptr) public swapable;	dcl apv_ptr pointer;	dcl node_index pointer;	//	RELINQUISH HIGH WORD	write(mam)	= apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE OUTPUT APV'S WORD LENGTH	node_index	= read(md);	write(md)	= read(md)-1;					//	WRITE DECREMEMTED WORD LENGTH	//	DETERMINE IF THE WORD JUST DELETED IS THE FIRST DATA WORD OF A NODE.  IF SO, RECYCLE THE NODE	if ((node_index mod 255) == 0) {		while (node_index igt 255) {			write(mal) = NLS.FOR;				//	LOOK UP THIS NODE'S FORWARD POINTER			write(mam) = read(md);				//	POINT TO THE NEXT NODE			node_index = node_index-255;		}		write(mal)	= NLS.FOR;					//	LOOK UP THE FORWARD POINTER TO THE NODE TO BE RECYCLED		write(reg_dst|r13) = read(md);		//	TEMPORARILY SAVE IT		write(md)	= 0;							//	CLEAR THE FORWARD POINTER		deallocate.nah.block(read(reg_src|r13)-nah.ptr);	//	RECYCLE THE NODE (PASS RELATIVE POINTER, NOT ABSOLUTE)	}end relinquish_high_word;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING PROCEDURE IS ONLY FOR PROVIDING OUTPUT FOR DEBUGGING/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_show_words													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_show_words" PRINTS THE DECIMAL SIGNED INTEGER VALUES OF EACH INDIVIDUAL//	WORD (INCLUDING THE WORD LENGTH BUT NOT THE FORWARD POINTER) OF THE ABSOLUTE PRECISION//	VARIABLE POINTED TO BY THE PASSED POINTER.//	CURRENTLY THIS PROCEDURE DOES NOT WORK BEYOND THE FIRST NODE.apv_show_words: proc (apv_ptr) public swapable;	dcl apv_ptr pointer;	dcl index fixed;	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE APV'S WORD LENGTH	print 'Word Length =',read(md),', Value = ',;	do index = 1 to read(mdi); print read(mdi),; end;	print;end apv_show_words;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING PROCEDURES ARE FOR ALLOCATING AND DEALLOCATING NODES BETWEEN //	ABSOLUTE PRECISION VARIABLES AND THE FREE NODE LIST./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_allocate_node												*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_allocate_node" RETURNS A RELATIVE POINTER TO A FREE NODE//	AND INITIALIZES IT'S FIRST THREE WORDS.apv_allocate_node: proc returns (pointer) public swapable;	write(reg_dst|r13) = allocate.nah.block;	//	GET BLOCK FROM NAH AREA	if (read(reg_src|r13) == null) {				//	BAIL IF NO MORE MEMORY		set.error(err.oom,'');						//	REPORT THAT WE'VE RUN OUT OF MEMORY		return null;	}	else write(reg_dst|r13) = read(reg_src|r13)+nah.ptr;	//	CONVERT TO ABSOLUTE POINTER	write(mam) = read(reg_src|r13);				//	POINT TO OUR NEW BLOCK	write(mdi) = null;								//	CLEAR THE FORWARD POINTER															//	IN CASE THIS WILL BE A HEAD NODE,	write(mdi) = 1;									//	INITIALIZE WORD LENGTH TO 1,	write(md ) = 0;									//	AND INITIALIZE VALUE TO 0.	return read(reg_src|r13);						//	LEAVING THE POINTER IN r13 IS VERY CONVENIENT FOR THE CALLERend apv_allocate_node;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_recycle														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_recycle" RECYCLES THE ENTIRE LINKED LIST COMPRISING THE APV POINTED TO BY THE PASSED POINTER.//	THIS EFFECTIVELY DEALLOCATES THE APV.  CONSEQUENTLY THE POINTER PASSED TO THIS PROCEDURE WILL BE INVALID UNTIL REALLOCATED.//	THIS VERSION CALLS "deallocate.nah.block" ONCE FOR EACH NODE, AND NECESSARILY LINKS THEM ON TO THE FREE LIST IN REVERSE ORDER./*apv_recycle: proc (node_ptr) public swapable;	dcl node_ptr pointer;	write(mam) = node_ptr;								//	POINT TO THE FIRST NODE'S FORWARD POINTER	write(reg_dest|r13) = read(md);					//	REMEMBER IT	deallocate.nah.block(node_ptr-nah.ptr);		//	RECYCLE THE FIRST NODE (PASS RELATIVE POINTER, NOT ABSOLUTE)	while (read(reg_src|r13) != null) {				//	AS LONG AS SUBSEQUENT NODES ARE LINKED, RECYCLE THEM AS WELL		node_ptr = read(reg_src|r13);		write(mam) = read(reg_src|r13);				//	POINT TO THIS NODE'S FORWARD POINTER		write(reg_dest|r13) = read(md);				//	REMEMBER IT FOR THE NEXT ITERATION		deallocate.nah.block(node_ptr-nah.ptr);	//	RECYCLE THIS NODE	}end apv_recycle;*///	THIS ALTERNATE VERSION LINKS THE ENTIRE APV ONTO THE UNUSED LIST AT ONCE IN IT'S ORIGINAL ORDER.//	IT DOES NOT CALL "deallocate.nah.block" BUT IS ITSELF A MODIFIED VERSION OF "deallocate.nah.block".apv_recycle: proc (apv_ptr) public swapable;	dcl apv_ptr pointer;	dcl #nodes	fixed;	//	CONDITION FIRST NODE	#nodes = 1;	write(mam) = apv_ptr; write(mal) = NLS.REV;	write(mdi) = -1; write(md) = -1;		//	STORE -1 IN NLS.REV AND	NLS.TRK TO CATCH PROGRAMMING BUGS	write(mal) = NLS.FOR;					//	NOW POINT TO THE FORWARD POINTER		//	STEP THROUGH ALL SUBSEQUENT NODES, CONDITIONING EACH	while (read(md) != null) {		#nodes = #nodes+1;		write(mam) = read(md); write(mal) = NLS.REV;		write(mdi) = -1; write(md) = -1;	//	STORE -1 IN NLS.REV AND	NLS.TRK TO CATCH PROGRAMMING BUGS		write(mal) = NLS.FOR;				//	NOW POINT TO THIS NODE'S FORWARD POINTER	}	//	LINK THE ENTIRE APV ON TO THE FREE LIST	write(md) = nah.free;	nah.free  = apv_ptr-nah.ptr;			//	RELATIVE POINTER, NOT ABSOLUTE!	nah.#free = nah.#free+#nodes;end apv_recycle;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_duplicate														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_duplicate" COPIES THE DATA IN THE APV POINTED TO BY "src_ptr" INTO//	THE APV POINTED TO BY "dst_ptr".  THIS IS TYPICALLY DONE SO THAT ARITHMETIC OPERATIONS CAN//	BE PERFORMED ON THE COPY WITHOUT ALTERING THE ORIGINAL.//	NOTE THAT THE APV pointed to by "dest_ptr" MUST BE ALLOCATED PRIOR TO CALLING THIS PROCEDURE.apv_duplicate: proc (src_ptr,dst_ptr) public swap;	//	CAN'T USE "swapable" (= recursive swap) BECAUSE OF THE NEED FOR STATIC VARIABLES	dcl (src_ptr,dst_ptr)	pointer static;	//	DECLARED AS static SO THAT "copy_node" CAN ACCESS THEM	dcl node_index				pointer static;	copy_node: proc;		dcl index pointer;		dcl limit fixed;		if (node_index igt 255) {limit = 255; node_index = node_index-255;}		else limit = node_index;		do index = 1 to limit;			write(mam) = src_ptr;				//	POINT TO THE SOURCE NODE			write(mal) = index;					//	POINT TO THE INDEXED WORD			write(reg_dst|r13) = read(md);	//	STORE IT IN REGISTER 13			write(mam) = dst_ptr;				//	POINT TO THE DESTINATION NODE			write(mal) = index;					//	POINT TO THE INDEXED WORD			write(md) = read(reg_src|r13);	//	WRITE THE VALUE STORED IN REGISTER 13		end;		write(mam) = src_ptr;					//	POINT TO THE SOURCE APV'S CURRENT NODE'S FORWARD POINTER	end;	//	STEP 1: COPY ALL NODES ALLOCATING NEW DESTINATION NODES AS NEEDED	write(mam) = src_ptr; write(mal) = apv#wlen;	//	POINT TO THE SOURCE APV'S WORD LENGTH	node_index = read(md)+1;	copy_node();								//	COPY THE FIRST NODE	while (read(md) != null) {		src_ptr = read(md);					//	MAKE CURRENT THE SOURCE APV'S NEXT NODE		write(mam) = dst_ptr;				//	POINT TO THE DESTINATION APV'S MOST RECENTLY COPIED NODE'S FORWARD POINTER		if (read(md) == null) {				//	FORWARD POINTER IS NULL, MUST FIRST ALLOCATE NEW NODE			apv_allocate_node();				//	THIS LEAVES THE POINTER IN r13			if (read(reg_src|r13) == null) return;	//	BAIL IF ALLOCATION FAILED			write(mam) = dst_ptr;			//	MUST RE-POINT HERE BECAUSE THE CALL TO "apv_allocate_node" CHANGED WHERE WE'RE POINTING			write(md) = read(reg_src|r13);		}		dst_ptr = read(md);					//	MAKE CURRENT THE DESTINATION APV'S NEXT NODE		copy_node();							//	COPY THE CURRENT NODE	}	//	STEP 2: RECYCLE ANY REMAINING NODES FROM THE DESTINATION APV	write(mam) = dst_ptr;					//	POINT TO THE DESTINATION APV'S MOST RECENTLY COPIED NODE'S FORWARD POINTER	if (read(md) != null) {		write(reg_dst|r13) = read(md);	//	TEMPORARILY SAVE THE POINTER TO THE HEAD NODE TO BE RECYCLED		write(md) = null;						//	CLEAR THE FORWARD POINTER		apv_recycle(read(reg_src|r13));	}end apv_duplicate;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING TWO PROCEDURES ARE FOR READING AND WRITING INDIVIDUAL WORDS//	TO ABSOLUTE PRECISION VARIABLES USING AN INDEX./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_get_word														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_get_word" RETURNS THE VALUE OF THE INDEXED WORD//	OF THE ABSOLUTE PRECISION VARIABLE POINTED TO BY THE PASSED POINTER.//	IF THE INDEXED WORD IS BEYOND THE MOST SIGNIFICANT WORD OF THE APV,//	THE APPROPRIATE SIGN EXTENDED WORD IS RETURNED.apv_get_word: proc (apv_ptr,index) returns (fixed) public swapable;	dcl (apv_ptr,index) pointer;	dcl node_index pointer;	//	STEP 1: IF THE TARGET WORD IS BEYOND THE WORD LENGTH OF THIS APV,	//	THEN RETURN EITHER -1 OR 0 DEPENDING ON THE SIGN	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE APV'S WORD LENGTH	if (index ige read(md)) {		//	CHECK THE SIGN OF THE MOST SIGNIFICANT WORD OF THIS VARIABLE		if (apv_get_word(apv_ptr,read(md)-1) < 0)	return -1;	//	IF THIS VARIABLE IS NEGATIVE THEN RETURN -1		else													return  0;	//	ELSE RETURN 0	}	//	STEP 2: FIND THE NODE CONTAINING THE TARGET WORD	node_index = index + apv#lsw;	while (node_index igt 255) {		write(mal) = NLS.FOR;	//	LOOK UP THIS NODE'S FORWARD POINTER		write(mam) = read(md);	//	POINT TO THE NEXT NODE		node_index = node_index-255;	}	//	STEP 3: RETURN THE VALUE OF THE TARGET WORD	write(mal) = node_index;	return read(md);end apv_get_word;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_put_word														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_put_word" PLACES THE PASSED VALUE INTO THE INDEXED WORD//	OF THE ABSOLUTE PRECISION VARIABLE POINTED TO BY THE PASSED POINTER.//	THIS PROCEDURE FINDS THE PROPER NODE AND ALLOCATES NEW NODES AS NEEDED.apv_put_word: proc (apv_ptr,index,value) public swapable;	dcl (apv_ptr,index) pointer;	dcl value fixed;	dcl node_index pointer;	node_index = index + apv#lsw;	write(mam) = apv_ptr; 	//	LOOK UP THE HEAD NODE'S FORWARD POINTER	//	STEP 1: FIND THE NODE CONTAINING THE TARGET WORD	while (node_index igt 255) {		if (read(md) == null) {			//	FORWARD POINTER IS NULL, MUST FIRST ALLOCATE NEW NODE			dcl temp fixed;			temp = read(mam);			if (apv_allocate_node == null) return;	//	BAIL IF ALLOCATION FAILED			write(mam) = temp;			//	MUST RE-POINT TO THE FORWARD POINTER BECAUSE OF THE CALL TO "apv_allocate_node"			write(md) = read(reg_src|r13);			//	THE CALL TO "apv_allocate_node" LEFT THE POINTER TO THE NEW NODE IN r13		}		write(mam) = read(md);			//	POINT TO THE NEXT NODE		node_index = node_index-255;	}	//	STEP 2: WRITE value INTO THE TARGET WORD	write(mal) = node_index;	write(md) = value;	//	STEP 3: IF THE TARGET WORD IS BEYOND THE WORD LENGTH OF THIS APV,	//	THEN SET THIS APV'S WORD LENGTH TO THE VALUE OF index+1	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE APV'S WORD LENGTH	if (index ige read(md)) write(md) = index+1;end apv_put_word;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_compare														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_compare" COMPARES THE TWO PASSED APVs AND RETURNS ONE OF THE FOLLOWING FIXED VALUES...//	#ieq (0) IF THE TWO APVs ARE IDENTICAL,//	#dif (1) IF THE TWO APVs HAVE DIFFERENT SIGNS,//	#ilt (2) IF THE APV POINTED TO BY "ptr1" IS LESS THAN (CLOSER TO ZERO THAN) THE APV POINTED TO BY "ptr2",//	#igt (3) IF THE APV POINTED TO BY "ptr1" IS GREATER THAN (FARTHER FROM ZERO THAN) THE APV POINTED TO BY "ptr2".////	FOR NOW WE ASSUME THAT THE TWO APVs ARE POSITIVE (I.E., WE ONLY RETURN #ieq, #ilt OR #igt)apv_compare: proc(ptr1,ptr2) returns (fixed) public swapable;	dcl (ptr1,ptr2) pointer;	dcl (tmp1,tmp2,word_legth) fixed;	//	CHECK WORD LENGTHS OF BOTH APVs	write(mam) = ptr1; write(mal) = apv#wlen; tmp1 = read(md);	write(mam) = ptr2; write(mal) = apv#wlen; tmp2 = read(md);	if (tmp1 ilt tmp2) return #ilt;	if (tmp1 igt tmp2) return #igt;	word_legth = tmp1-1;	//	GET HIGH WORDS	tmp1 = apv_get_word(ptr1,word_legth);	tmp2 = apv_get_word(ptr2,word_legth);	while ((tmp1 == tmp2) && (word_legth != 0)) {		word_legth = word_legth-1;		//	GET NEXT LOWER WORDS		tmp1 = apv_get_word(ptr1,word_legth);		tmp2 = apv_get_word(ptr2,word_legth);	}		if (tmp1 ilt tmp2) return #ilt;	if (tmp1 igt tmp2) return #igt;	return #ieq;end apv_compare;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING TWO PROCEDURES PERFORM LOW LEVEL ARITHMETIC FUNCTIONS WITH ABSOLUTE PRECISION VARIABLES.//	THEY ARE NEEDED BY THE PROCEDURES WHICH FOLLOW/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_assign															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_assign" ASSIGNS THE PASSED SIGNED 16-BIT FIXED VALUE//	TO THE ABSOLUTE PRECISION VARIABLE POINTED TO BY THE PASSED POINTER.apv_assign: proc (apv_ptr,value) public swapable;	dcl apv_ptr pointer;	dcl value fixed;	write(mam) = apv_ptr;	if (read(md) != null) apv_recycle(read(md));	write(mam) = apv_ptr;	//	THIS IS REPEATED HERE BECAUSE THE PREVIOUS CALL TO "apv_recycle" MAY HAVE WRITTEN A NEW VALUE TO "mam"	write(mdi) = null;		//	WRITE NULL FORWARD POINTER	write(mdi) = 1;			//	WRITE WORD LENGTH OF 1	write(md) = value;		//	WRITE VALUEend apv_assign;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_negate															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_negate" PLACES THE NEGATIVE OF THE VALUE OF THE APV POINTED TO BY "src_ptr" INTO//	THE APV POINTED TO BY "dst_ptr".//	NOTE THAT THIS PROCEDURE WILL WORK EVEN IF "src_ptr" AND "dst_ptr" POINT TO THE SAME APV.apv_negate: proc (src_ptr,dst_ptr) public swapable;	dcl (src_ptr,dst_ptr) pointer;	dcl index		pointer;	dcl wlength		fixed;	dcl negative	boolean;	//	IF THE SOURCE AND DESTINATION APV ARE NOT THE SAME THEN WE MUST FIRST DUPLICATE THE SOURCE INTO THE DESTINATION	//	THIS WILL RESET THE WORD LENGTH OF THE DESTINATION AND RECYCLE ANY EXCESS NODES	if (src_ptr != dst_ptr) apv_duplicate(src_ptr,dst_ptr); if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	write(mam) = src_ptr; write(mal) = apv#wlen;	//	POINT TO INPUT APV'S WORD LENGTH	wlength = read(md);	negative = (apv_get_word(src_ptr,read(md)-1) < 0);	//	REMEMBER IF INPUT APV IS NEGATIVE	//	STEP 1: COPY BITWISE NOT OF EACH WORD IN SOURCE APV TO EACH WORD IN OUTPUT APV	do index = 0 to wlength-1;		apv_put_word(dst_ptr,index,!apv_get_word(src_ptr,index));	end;	if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	//	STEP 2: INCREMENT OUTPUT APV BY 1	index = 0;	while ((apv_get_word(dst_ptr,index) == -1) && index != wlength) {apv_put_word(dst_ptr,index,0); index = index+1;}	if (index != wlength) apv_put_word(dst_ptr,index,apv_get_word(dst_ptr,index)+1);	//	STEP 3: CHECK FOR SPECIAL CASE NEED TO EXTEND OR REMOVE HIGH WORD	//	IF INPUT WAS POSITIVE AND RESULT'S HIGH WORD = -1 AND NEXT WORD IS NEGATIVE, THEN REMOVE HIGH WORD;	if (negative == false) {		if (wlength igt 1) {			if ((apv_get_word(dst_ptr,wlength-1) == -1) && (apv_get_word(dst_ptr,wlength-2) < 0)) relinquish_high_word(dst_ptr);		}	}	//	IF INPUT APV WAS NEGATIVE AND RESULT IS NEGATIVE THEN EXTEND WITH 0	else if (apv_get_word(dst_ptr,wlength-1) < 0) apv_put_word(dst_ptr,wlength,0);end apv_negate;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING PROCEDURES PERFORM BIT-WISE AND WORD-SHIFT FUNCTIONS WITH ABSOLUTE PRECISION VARIABLES./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_or																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_or" RETURNS THE "BITWISE OR" OF THE TWO PASSED APVs.apv_or: proc(ptr1,ptr2,output_ptr) public swapable;	dcl (ptr1,ptr2,output_ptr)	pointer;	dcl tmp_ptr				pointer;	//	WORKING APV	dcl (wlength,index)	fixed;	//	DETERMINE WHICH INPUT APV HAS THE LONGER WORD LENGTH.	//	IF NECESSARY, SWAP THE POINTERS SUCH THAT "ptr1" POINTS TO THE LONGER APV.	//	ALSO REMEMBER THE WORD LENGTH OF THE SHORTER APV	write(mam) = ptr1; write(mal) = apv#wlen; wlength = read(md);	write(mam) = ptr2; write(mal) = apv#wlen;	if (read(md) ilt wlength)	wlength = read(md);	else								{write(reg_dst|r13) = ptr1; ptr1 = ptr2; ptr2 = read(reg_src|r13);}	//	SWAP POINTERS	//	ALLOCATE WORKING APV AND COPY THE LONGER APV THERE	tmp_ptr = apv_allocate_node; if (tmp_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	apv_duplicate(ptr1,tmp_ptr);	if (ertyp != null) {apv_recycle(tmp_ptr); return;}				//	BAIL IF ERROR OCCURRED	do index = 0 to wlength-1;		apv_put_word(tmp_ptr,index,apv_get_word(ptr1,index) | apv_get_word(ptr2,index));	end;	//	COPY FINAL RESULT INTO OUTPUT APV AND RECYCLE THE WORKING APV	apv_duplicate(tmp_ptr,output_ptr);	apv_recycle(tmp_ptr);end apv_or;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_word_shr														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_word_shr" SHIFTS THE PASSED APV RIGHT BY 1 WORD.apv_word_shr: proc(src_ptr,dst_ptr) public swapable;	dcl (src_ptr,dst_ptr)	pointer;	dcl index					pointer;	//	IF THE SOURCE AND DESTINATION APV ARE NOT THE SAME THEN WE MUST FIRST DUPLICATE THE SOURCE INTO THE DESTINATION	//	THIS WILL RESET THE WORD LENGTH OF THE DESTINATION AND RECYCLE ANY EXCESS NODES	if (src_ptr != dst_ptr) apv_duplicate(src_ptr,dst_ptr); if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	write(mam) = dst_ptr; write(mal) = apv#wlen;	//	LOOK UP WORD LENGTH	if (read(md) == 1) {apv_assign(dst_ptr,0); return;}	do index = 1 to read(md)-1;		apv_put_word(dst_ptr,index-1,apv_get_word(dst_ptr,index));	end;	relinquish_high_word(dst_ptr);end apv_word_shr;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_word_shl														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_word_shl" SHIFTS THE PASSED APV LEFT BY 1 WORD.apv_word_shl: proc(src_ptr,dst_ptr) public swapable;	dcl (src_ptr,dst_ptr)	pointer;	dcl index					pointer;	//	IF THE SOURCE AND DESTINATION APV ARE NOT THE SAME THEN WE MUST FIRST DUPLICATE THE SOURCE INTO THE DESTINATION	//	THIS WILL RESET THE WORD LENGTH OF THE DESTINATION AND RECYCLE ANY EXCESS NODES	if (src_ptr != dst_ptr) apv_duplicate(src_ptr,dst_ptr); if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	write(mam) = dst_ptr; write(mal) = apv#wlen;	//	LOOK UP WORD LENGTH	apv_put_word(dst_ptr,read(md),0); if (ertyp != null) return;	//	FIRST MAKE SURE THERE'S MEMORY FOR THE NEW WORD	write(mam) = dst_ptr; write(mal) = apv#wlen;	//	MUST RE-POINT BECAUSE OF PREVIOUS CALL	do index = read(md)-1 to 1 by -1;		apv_put_word(dst_ptr,index,apv_get_word(dst_ptr,index-1));	end;	apv_put_word(dst_ptr,0,0);end apv_word_shl;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING PROCEDURES PERFORM BIT-SHIFT FUNCTIONS WITH ABSOLUTE PRECISION VARIABLES./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_shr																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_shr" SHIFTS THE PASSED APV RIGHT BY 1 BIT.apv_shr: proc(src_ptr,dst_ptr) public swapable;	dcl (src_ptr,dst_ptr)		pointer;	dcl (wlength,temp,carry)	fixed;	dcl index						pointer;	dcl highword	lit 'temp';	dcl nextword	lit 'carry';	//	IF THE SOURCE AND DESTINATION APV ARE NOT THE SAME THEN WE MUST FIRST DUPLICATE THE SOURCE INTO THE DESTINATION	//	THIS WILL RESET THE WORD LENGTH OF THE DESTINATION AND RECYCLE ANY EXCESS NODES	if (src_ptr != dst_ptr) apv_duplicate(src_ptr,dst_ptr); if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	//	GET WORD LENGTH AND SIGN	write(mam) = dst_ptr; write(mal) = apv#wlen;	wlength = read(md);	carry = (apv_get_word(dst_ptr,read(md)-1) & "100000");	//	BRAINLESSLY SHIFT	do index = wlength-1 to 0 by -1;		temp = apv_get_word(dst_ptr,index);		apv_put_word(dst_ptr,index,shr(temp,1) | carry);		carry = (temp & 1); if (carry != 0) carry = "100000";	end;	//	CHECK FOR REDUNDANT HIGH WORDS	if (wlength != 1) {		highword = apv_get_word(dst_ptr,wlength-1);		nextword = apv_get_word(dst_ptr,wlength-2);		if (((highword ==  0) && ((nextword & "100000") == 0))	//	BUG WORK-AROUND: (nextword >= 0) evaluates to true if (nextword == -32768)		||  ((highword == -1) && (nextword < 0)))		relinquish_high_word(dst_ptr);	}end apv_shr;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_shl																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_shl" SHIFTS THE PASSED APV LEFT BY 1 BIT, BUT PRESERVES THE SIGN.//	IT MAY BE FASTER TO MULTIPLY THE INPUT BY TWO OR ADD IT TO ITSELF.apv_shl: proc(src_ptr,dst_ptr) public swapable;	dcl (src_ptr,dst_ptr)		pointer;	dcl (wlength,temp,carry)	fixed;	dcl index						pointer;	dcl negative					boolean;	//	IF THE SOURCE AND DESTINATION APV ARE NOT THE SAME THEN WE MUST FIRST DUPLICATE THE SOURCE INTO THE DESTINATION	//	THIS WILL RESET THE WORD LENGTH OF THE DESTINATION AND RECYCLE ANY EXCESS NODES	if (src_ptr != dst_ptr) apv_duplicate(src_ptr,dst_ptr); if (ertyp != null) return;	//	BAIL IF ERROR OCCURRED	//	GET WORD LENGTH AND SIGN	write(mam) = dst_ptr; write(mal) = apv#wlen;	wlength = read(md);	negative = (apv_get_word(dst_ptr,read(md)-1) < 0);	//	BRAINLESSLY SHIFT	carry = 0;	do index = 0 to wlength-1;		temp = apv_get_word(dst_ptr,index);		apv_put_word(dst_ptr,index,shl(temp,1) | carry);		carry = (temp < 0);	end;	//	IF THE SIGN CHANGED, THEN EXTEND	if (negative != false) {		//	IF THE ORIGINAL WAS NEGATIVE BUT THE HIGHWORD HAS BECOME POSITIVE, THEN EXTEND WITH -1		if ((apv_get_word(dst_ptr,wlength-1) & "100000") == 0) apv_put_word(dst_ptr,wlength,-1);	//	BUG WORK-AROUND: (x >= 0) evaluates to true if (x == -32768)	}	else {		//	IF THE ORIGINAL WAS POSITIVE BUT THE HIGHWORD HAS BECOME NEGATIVE, THEN EXTEND WITH 0		if (apv_get_word(dst_ptr,wlength-1) < 0) apv_put_word(dst_ptr,wlength,0);	}end apv_shl;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING TWO PROCEDURES ARE FOR MOVING NUMERIC VALUES BETWEEN ABSOLUTE//	PRECISION VARIABLES AND 32-BIT INTEGERS./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_output_s32													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	RETURNS FALSE IF THE APV IS TOO LARGE TO FIT IN A SIGNED 32-BIT VARIABLEapv_output_s32: proc (apv_ptr,passed_array) returns (boolean) public swapable;	dcl apv_ptr			pointer;	dcl passed_array	fixed array;	dcl wlength			fixed;	//	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	point to the apv's word length	// Check for overflow error	if (read(md) igt 2) {ertyp = err.overflow; return false;}	// Go to town	write(reg_dst|r13) = read(md);					//	remember word length	write(mal) = apv#lsw;								//	point to the apv's least significant word	passed_array(lw#lsb) = read(md);	if (read(reg_src|r13) == 1)	{		//	extend according to sign		if (read(md) < 0)	passed_array(lw#msb) = -1;		else					passed_array(lw#msb) =	0;	}	else {		write(cond|never)		= read(mdi);	//	skip past low word		passed_array(lw#msb)	= read(md);	}end apv_output_s32;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_output_u32													*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	RETURNS FALSE IF THE APV IS NEGATIVE OR TOO LARGE TO FIT IN AN UNSIGNED 32-BIT VARIABLEapv_output_u32: proc (apv_ptr,passed_array) returns (boolean) public swapable;	dcl apv_ptr			pointer;	dcl passed_array	fixed array;	dcl (wlength,highword)	fixed;	//	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	point to the apv's word length	wlength = read(md); highword = apv_get_word(apv_ptr,read(md)-1);	//	Check for incorrect sign error	if (highword < 0) {ertyp = err.sign; return false;}	// Check for overflow error	if ((wlength igt 3) || ((wlength == 3) && (highword != 0))) {ertyp = err.overflow; return false;}	// Go to town	write(mal) = apv#lsw;								//	point to the apv's least significant word	passed_array(lw#lsb) = read(mdi);	if (wlength == 1)	passed_array(lw#msb) = 0;	else					passed_array(lw#msb) = read(md);end apv_output_u32;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_input_u32														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*/apv_input_u32: proc (apv_ptr,passed_array) public swapable;	dcl apv_ptr			pointer;	dcl passed_array	fixed array;	//	apv_assign(apv_ptr,passed_array(lw#lsb));	//	This will recycle any subsequent nodes and set the word length to 1	if (passed_array(lw#msb) == 0) {		if (passed_array(lw#lsb) < 0) apv_put_word(apv_ptr,1,0);	//	necessary to interpret apv as positive	}	else apv_put_word(apv_ptr,1,passed_array(lw#msb));end apv_input_u32;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE FOLLOWING PROCEDURES PERFORM HIGH LEVEL ARITHMETIC FUNCTIONS WITH ABSOLUTE PRECISION VARIABLES./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_addsub															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_addsub" SUMS THE APV POINTED TO BY "apv_ptr2" WITH THE APV POINTED TO BY//	"apv_ptr1" AND PLACES THE RESULT IN THE APV POINTED TO BY "output_ptr".  IF THE PASSED//	BOOLEAN "subtract" IS SET TO TRUE, THEN THE APV POINTED TO BY "apv_ptr2" IS NEGATED FIRST//	AND THEREBY SUBTRACTED FROM THE APV POINTED TO BY "apv_ptr1".  NOTE THAT SINCE THE//	PROCEDURE OPERATES ON A TEMPORARY COPY OF THE PASSED APVS, AND ONLY COPIES THE RESULT//	TO THE APV POINTED TO BY "output_ptr" UPON COMPLETION, THE PROCEDURE WILL WORK EVEN IF//	"apv_ptr1", "apv_ptr2" AND "output_ptr" ALL POINT TO THE SAME APV.apv_addsub: proc (apv_ptr1,apv_ptr2,output_ptr,subtract) public swapable;	dcl (apv_ptr1,apv_ptr2,output_ptr)	pointer;	//	PASSED APVs	dcl subtract								boolean;	dcl (tmp_ptr,sum_ptr)					pointer;	//	WORKING APVs	dcl (index,carry_index)					pointer;	dcl (sum_wlength,tmp_wlength,signinfo)	fixed;	dcl highword	lit 'tmp_wlength';	dcl clean_up	label;		/*	--------------------------------- STEP 1: SET UP  ---------------------------------	*/	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE SECOND APV HAS A VALUE OF ZERO	write(mam) = apv_ptr2; write(mal) = apv#wlen;	//	POINT TO THE SECOND APV'S WORD LENGTH	//	IF THE SECOND APV HAS A VALUE OF ZERO, THEN RETURN THE FIRST APV	if ((read(mdi) == 1) && (read(md) == 0)) {		apv_duplicate(apv_ptr1,output_ptr);		return;										//	WE'RE DONE	}	//	ALLOCATE WORKING APV	tmp_ptr = apv_allocate_node; if (tmp_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	//	COPY THE SECOND APV INTO THE WORKING APV AND DO SIGN CONVERSION IF SUBTRACTION IS REQUESTED	if (subtract != false)	apv_negate	 (apv_ptr2,tmp_ptr);	else							apv_duplicate(apv_ptr2,tmp_ptr);	if (ertyp == null) {														//	ONLY CONTINUE IF NO ERROR	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE FIRST APV HAS A VALUE OF ZERO	write(mam) = apv_ptr1; write(mal) = apv#wlen;	//	POINT TO THE FIRST APV'S WORD LENGTH	sum_wlength = read(md);									//	SAVE IT FOR LATER	//	IF THE FIRST APV HAS A VALUE OF ZERO, THEN RETURN THE (POSSIBLY NEGATED) SECOND APV	if ((read(mdi) == 1) && (read(md) == 0)) {		apv_duplicate(tmp_ptr,output_ptr);		apv_recycle(tmp_ptr);					//	CLEAN UP		return;										//	WE'RE DONE	}	//	ALLOCATE SUM APV AND COPY THE FIRST APV THERE	sum_ptr = apv_allocate_node; if (sum_ptr != null) {	//	ONLY CONTINUE IF NO ERROR	apv_duplicate(apv_ptr1,sum_ptr);	if (ertyp == null) {												//	ONLY CONTINUE IF NO ERROR	//	TO MINIMIZE PROCESSING TIME, WE WANT "sum_ptr" TO POINT TO THE LONGER OF THE TWO APVs	//	FIND OUT WHICH APV HAS THE LONGEST WORD LENGTH AND EXCHANGE "sum_ptr" WITH "tmp_ptr" AND	//	"sum_wlength" WITH "tmp_wlength" IF NECESSARY	write(mam) = tmp_ptr; write(mal) = apv#wlen;	//	POINT TO THE WORKING APV'S WORD LENGTH	if (read(md) igt sum_wlength) {			//	IF THE WORKING APV'S WORD LENGTH IS LONGER THAN THE SUM'S,		tmp_wlength = sum_wlength;				//	THEN EXCHANGE "sum_wlength" WITH "tmp_wlength"		sum_wlength = read(md);		write(reg_dst|r13) = tmp_ptr;			//	AND EXCHANGE THE POINTERS		tmp_ptr = sum_ptr;		sum_ptr = read(reg_src|r13);	}	else tmp_wlength = read(md);	//	GET INFORMATION ABOUT THE SIGNS OF THE TWO APVs THAT WILL BE NEEDED LATER	//	WE WANT:	signinfo = -1 IF BOTH APVs ARE NEGATIVE	//				signinfo =  0 IF THE TWO APVs HAVE DIFFERENT SIGNS	//				signinfo =  1 IF BOTH APVs ARE POSITIVE	if (apv_get_word(sum_ptr,sum_wlength-1) < 0)	signinfo = -1;					//	GET SIGN OF TOP APV	else														signinfo =  1;	if (apv_get_word(tmp_ptr,tmp_wlength-1) < 0)	write(reg_dst|r13) = -1;	//	GET SIGN OF BOTTOM APV	else														write(reg_dst|r13) =  1;	if (signinfo != read(reg_dst|r13)) signinfo = 0;	/*	------------------------------ STEP 2: DO ARITHMETIC ------------------------------	*/	//	STEP 2.1: ADD IN ALL LOWER WORDS INTERPRETED AS POSITIVE NUMBERS	index = 0;	while (index ilt tmp_wlength-1) {		load apv_get_word(sum_ptr,index);	//	LOAD INDEXED WORD OF THE TOP APV INTO THE HMD'S LSW		uload apv_get_word(tmp_ptr,index);	//	LOAD INDEXED WORD OF THE BOTTOM APV INTO THE HMD'S MSW (ADDEND)		mul 1;										//	MULTIPLY BY 1 (TO INITIATE ADD)		apv_put_word(sum_ptr,index,res);		//	PLACE THE LOWER RESULT INTO THE INDEXED WORD OF THE SUM APV		//	IF WE HAVE A 1 TO CARRY, THEN INCREMENT THE TOP APV'S NEXT WORD BY 1,		//	CASCADING UPWARDS IF NECESSARY.  BUT DON'T CARRY PAST THE HIGH WORD.		if (ures != 0) {			carry_index = index+1;			while ((carry_index != sum_wlength) && (apv_get_word(sum_ptr,carry_index) == -1)) {				apv_put_word(sum_ptr,carry_index,0);				carry_index = carry_index+1;			}			if (carry_index != sum_wlength) apv_put_word(sum_ptr,carry_index,apv_get_word(sum_ptr,carry_index)+1);		}		index = index+1;	}	//	STEP 2.2: WHEN THE HIGH WORD IS ENCOUNTERED, IT'S SIGN MUST BE ACCOUNTED FOR (UNLESS sum_wlength == tmp_wlength)	while (index == tmp_wlength-1) {		load apv_get_word(sum_ptr,index);	//	LOAD INDEXED WORD OF THE TOP APV INTO HMD'S LSW		write(reg_dst|r13) = apv_get_word(tmp_ptr,index);	//	THIS IS DONE TO PREVENT HAVING TO CALL apv_get_word(tmp_ptr,index) TWICE		uload read(reg_src|r13);				//	LOAD INDEXED WORD OF THE BOTTOM APV INTO HMD'S MSW (ADDEND)		mul 1;										//	MULTIPLY BY 1 (TO INITIATE ADD)		apv_put_word(sum_ptr,index,res);		//	PLACE THE LOWER RESULT INTO THE INDEXED WORD OF THE SUM APV		//	UNLESS THE WORD LENGTHS ARE EQUAL, WE MAY HAVE TO SIGN-EXTEND THE BOTTOM APV, DEPENDING ON WHETHER WE HAVE A 1 TO CARRY		if (sum_wlength != tmp_wlength) {			if (ures == 0) {				if (read(reg_src|r13) < 0) {						//	IF THE BOTTOM APV IS NEGATIVE AND WE DON'T HAVE A 1 TO CARRY					apv_put_word(tmp_ptr,tmp_wlength,-1);		//	THEN EXTEND WITH -1					if (ertyp != null) goto clean_up;			//	BAIL IF ERROR OCCURRED					tmp_wlength = tmp_wlength+1;					//	AND INCREMENT THE WORDLENTH TO FORCE ANOTHER PASS THROUGH THIS WHILE LOOP				}			}			else {				if ((read(reg_src|r13) & "100000") == 0) {	//	IF THE BOTTOM APV IS POSITIVE AND WE HAVE A 1 TO CARRY					apv_put_word(tmp_ptr,tmp_wlength,1);		//	THEN EXTEND WITH 1					if (ertyp != null) goto clean_up;			//	BAIL IF ERROR OCCURRED					tmp_wlength = tmp_wlength+1;					//	AND INCREMENT THE WORDLENTH TO FORCE ANOTHER PASS THROUGH THIS WHILE LOOP				}			}		}		index = index+1;	}	/*	---------------- STEP 3: REMOVE OR EXTEND HIGH WORDS IF NECESSARY  ----------------	*/	if (signinfo == 0) {	//	INPUT APVs HAD DIFFERENT SIGNS.  THEREFORE REDUNDANT HIGH WORDS MAY HAVE TO BE DELETED		if (sum_wlength != 1) {			//	SET UP FOR THE FIRST ITERATION			index = sum_wlength-1;			highword = apv_get_word(sum_ptr,index); write(reg_dst|r13) = apv_get_word(sum_ptr,index-1);			while ((index != 0)			&& (((highword ==  0) && ((read(reg_src|r13) & "100000") == 0))	//	BUG WORK-AROUND: (x >= 0) evaluates to true if (x == -32768)			||  ((highword == -1) && (read(reg_src|r13) < 0)))) {				relinquish_high_word(sum_ptr);				//	SET UP FOR THE NEXT ITERATION				index = index-1;				if (index != 0) {highword = apv_get_word(sum_ptr,index); write(reg_dst|r13) = apv_get_word(sum_ptr,index-1);}			}		}	}	else {		//	IF BOTH APVs WERE POSITIVE, THEN IF RESULT IS NEGATIVE, EXTEND WITH 0		if (signinfo == 1) {if (apv_get_word(sum_ptr,sum_wlength-1) < 0) apv_put_word(sum_ptr,sum_wlength,0);}		//	IF BOTH APVs WERE NEGATIVE, THEN IF RESULT IS POSITIVE, EXTEND WITH -1		else					 {if ((apv_get_word(sum_ptr,sum_wlength-1) & "100000") == 0) apv_put_word(sum_ptr,sum_wlength,-1);}		if (ertyp != null) goto clean_up;	//	BAIL IF ERROR OCCURRED	}	/*	-------------------------------- STEP 4: CLEAN UP  --------------------------------	*/	//	COPY FINAL RESULT INTO OUTPUT APV AND RECYCLE WORKING APVs	apv_duplicate(sum_ptr,output_ptr);	}				//	END OF SUCCESS DUPLICATING TO "sum_ptr"	clean_up:;	//	LABEL FOR GOTOS	apv_recycle(sum_ptr);	}				//	END OF SUCCESS ALLOCATING "sum_ptr"	}				//	END OF SUCCESS DUPLICATING OR NEGATING TO "tmp_ptr"	apv_recycle(tmp_ptr);end apv_addsub;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_multiply														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_multiply" MULTIPLIES THE APV POINTED TO BY "apv_ptr1" BY THE APV//	POINTED TO BY "apv_ptr2" AND PLACES THE RESULT IN THE APV POINTED TO BY "product_ptr".//	NOTE THAT SINCE THE PROCEDURE OPERATES ON A TEMPORARY COPY OF THE PASSED APVS, AND ONLY//	COPIES THE RESULT TO THE APV POINTED TO BY "product_ptr" UPON COMPLETION, THE PROCEDURE//	WILL WORK EVEN IF "apv_ptr1", "apv_ptr2" AND "product_ptr" ALL POINT TO THE SAME APV.apv_multiply: proc (apv_ptr1,apv_ptr2,product_ptr) public swapable;	dcl (apv_ptr1,apv_ptr2,product_ptr)					pointer;	dcl (tmp_ptr1,tmp_ptr2,subproduct_ptr,sum_ptr)	pointer;	//	WORKING APVs	dcl (index1,index2,carry_index)						pointer;	dcl word			fixed;	dcl negative	boolean;	dcl wlength		lit 'word';	dcl clean_up_temps	label;	dcl clean_up_all		label;	/*	--------------------------------- STEP 1: SET UP  ---------------------------------	*/	//	SPECIAL CASES: AVOID FURTHER COMPUTATION IF ONE OF THE PASSED APVs HAS A VALUE OF 0, 1 OR -1	write(mam) = apv_ptr1; write(mal) = apv#wlen;	//	POINT TO THE FIRST APV'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{								//	IF THIS APV HAS A VALUE OF ZERO,			apv_assign(product_ptr,0);						//	THEN RETURN ZERO			return;		}		if (read(md) == 1)	{								//	IF THE FIRST APV HAS A VALUE OF ONE,			apv_duplicate(apv_ptr2,product_ptr);		//	THEN RETURN THE SECOND APV			return;		}		if (read(md) == -1)	{								//	IF THE FIRST APV HAS A VALUE OF NEGATIVE ONE,			apv_negate(apv_ptr2,product_ptr);			//	THEN RETURN THE NEGATED SECOND APV			return;		}	}	write(mam) = apv_ptr2; write(mal) = apv#wlen;	//	POINT TO THE SECOND APV'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{								//	IF THIS APV HAS A VALUE OF ZERO,			apv_assign(product_ptr,0);						//	THEN RETURN ZERO			return;		}		if (read(md) == 1)	{								//	IF THE SECOND APV HAS A VALUE OF ONE,			apv_duplicate(apv_ptr1,product_ptr);		//	THEN RETURN THE FIRST APV			return;		}		if (read(md) == -1)	{								//	IF THE SECOND APV HAS A VALUE OF NEGATIVE ONE,			apv_negate(apv_ptr1,product_ptr);			//	THEN RETURN THE NEGATED FIRST APV			return;		}	}	//	ALLOCATE WORKING APVs, DUPLICATE THE INPUT APVs THERE AND DEAL WITH SIGN CONVERSIONS	tmp_ptr1 = apv_allocate_node; if (tmp_ptr1 == null) return;	//	BAIL IF ALLOCATION FAILED	write(mam) = apv_ptr1; write(mal) = apv#wlen;	//	POINT TO THE FIRST APV'S WORD LENGTH	if (apv_get_word(apv_ptr1,read(md)-1) < 0) {apv_negate	(apv_ptr1,tmp_ptr1); negative = true;}	else													 {apv_duplicate(apv_ptr1,tmp_ptr1); negative = false;}	if (ertyp != null) {apv_recycle(tmp_ptr1); return;}			//	BAIL IF ERROR OCCURRED		tmp_ptr2 = apv_allocate_node; if (tmp_ptr2 == null) return;	//	BAIL IF ALLOCATION FAILED	write(mam) = apv_ptr2; write(mal) = apv#wlen;	//	POINT TO THE SECOND APV'S WORD LENGTH	if (apv_get_word(apv_ptr2,read(md)-1) < 0) {apv_negate	(apv_ptr2,tmp_ptr2); negative = negative xor true;}	else													  apv_duplicate(apv_ptr2,tmp_ptr2);	if (ertyp == null) {		//	ONLY CONTINUE IF NO ERROR	//	TO MINIMIZE PROCESSING TIME, WE WANT "tmp_ptr1" TO POINT TO THE LONGER OF THE TWO APVs	//	FIND OUT WHICH APV HAS THE LONGEST WORD LENGTH AND EXCHANGE "tmp_ptr1" WITH "tmp_ptr2" IF NECESSARY	write(mam) = tmp_ptr1; write(mal) = apv#wlen;	//	POINT TO THE FIRST APV'S WORD LENGTH	write(reg_dst|r13) = read(md);						//	SAVE IT IN REGISTER 13	write(mam) = tmp_ptr2; write(mal) = apv#wlen;	//	POINT TO THE SECOND APV'S WORD LENGTH	if (read(md) igt read(reg_src|r13)) {	//	IF THE SECOND APV'S WORD LENGTH IS LONGER THAN THE FIRST, THEN EXCHANGE THE POINTERS		write(reg_dst|r13) = tmp_ptr1;		tmp_ptr1 = tmp_ptr2;		tmp_ptr2 = read(reg_src|r13);	}	/*	------------------------------ STEP 2: DO ARITHMETIC ------------------------------	*/	//	ALLOCATE WORKING APV	sum_ptr = apv_allocate_node;	if (sum_ptr != null) {	//	ONLY CONTINUE IF ALLOCATION SUCCEEDED	write(mam) = tmp_ptr2; write(mal) = apv#wlen;	//	POINT TO THE SHORTER APV'S WORD LENGTH	do index1 = 0 to read(md)-1;		word = apv_get_word(tmp_ptr2,index1);		if (word != 0) {			//	REALLOCATE SUBPRODUCT APV FOR EACH ITERATION			subproduct_ptr = apv_allocate_node; if (subproduct_ptr == null) goto clean_up_all;	//	BAIL IF ALLOCATION FAILED			/*	---------------------- STEP 2.1: CALCULATE SUBPRODUCT  ----------------------	*/			/*	----- (MULTIPLY THE LONGER APV BY THE INDEXED WORD OF THE SHORTER APV)  -----	*/			write(reg_dst|r13) = 0;									//	ZERO THE ADDEND FOR THE FIRST ITERATION			write(mam) = tmp_ptr1; write(mal) = apv#wlen;	//	POINT TO THE LONGER APV'S WORD LENGTH			do index2 = 0 to read(md)-1;				load apv_get_word(tmp_ptr1,index2);				//	LOAD INDEXED WORD OF LONGER APV INTO HMD'S LSW				uload read(reg_src|r13);							//	LOAD ADDEND FROM PREVIOUS ITERATION INTO HMD'S MSW				mul word;												//	MULTIPLY BY THE CURRENT WORD OF THE SHORTER APV				apv_put_word(subproduct_ptr,index2,res);		//	PLACE THE LOWER RESULT INTO THE SUBPRODUCT APV				if (ertyp != null) {apv_recycle(subproduct_ptr); goto clean_up_all;}	//	BAIL IF ERROR OCCURRED				write(reg_dst|r13) = ures;							//	STORE THE UPPER RESULT TO BE THE ADDEND IN THE NEXT ITERATION			end;			if (ures != 0) {				apv_put_word(subproduct_ptr,index2,ures);				if (ertyp != null) {apv_recycle(subproduct_ptr); goto clean_up_all;}	//	BAIL IF ERROR OCCURRED			}			/*	------------- STEP 2.2: ADD SUBPRODUCT INTO THE CUMMULATIVE SUM -------------	*/			write(mam) = subproduct_ptr; write(mal) = apv#wlen;	//	POINT TO THE SUBPRODUCT APV'S WORD LENGTH			do index2 = index1 to index1+read(md)-1;				write(mam) = sum_ptr; write(mal) = apv#wlen;			//	POINT TO THE SUM APV'S WORD LENGTH				if (read(md) == index2) {					apv_put_word(sum_ptr,index2,apv_get_word(subproduct_ptr,index2-index1));					if (ertyp != null) {apv_recycle(subproduct_ptr); goto clean_up_all;}	//	BAIL IF ERROR OCCURRED				}				else {					wlength = read(md); 					load apv_get_word(sum_ptr,index2);						//	LOAD INDEXED WORD OF SUM APV INTO HMD'S LSW					uload apv_get_word(subproduct_ptr,index2-index1);	//	LOAD INDEXED WORD OF SUBPRODUCT APV INTO HMD'S MSW (ADDEND)					mul 1;															//	MULTIPLY BY 1 (TO INITIATE ADD)					apv_put_word(sum_ptr,index2,res);						//	PLACE THE LOWER RESULT INTO THE SUM APV					if (ures != 0) {												//	IF CARRY, THEN INCREMENT NEXT WORD BY 1, CASCADING UPWARDS IF NECESSARY						carry_index = index2+1;						while ((apv_get_word(sum_ptr,carry_index) == -1) && (carry_index != wlength)) {							apv_put_word(sum_ptr,carry_index,0);							carry_index = carry_index+1;						}						if (carry_index == wlength) {							apv_put_word(sum_ptr,carry_index,1);							if (ertyp != null) {apv_recycle(subproduct_ptr); goto clean_up_all;}	//	BAIL IF ERROR OCCURRED						}						else apv_put_word(sum_ptr,carry_index,apv_get_word(sum_ptr,carry_index)+1);					}				}			end;			//	DEALLOCATE SUBPRODUCT APV BEFORE REITERATING		apv_recycle(subproduct_ptr);		}	end;	/*	---------------------- STEP 3: EXTEND HIGH WORD IF NECESSARY ----------------------	*/	write(mam) = sum_ptr; write(mal) = apv#wlen;	//	POINT TO THE SUM APV'S FINAL WORD LENGTH	wlength = read(md);	if (apv_get_word(sum_ptr,read(md)-1) < 0) {		apv_put_word(sum_ptr,wlength,0);				//	IF THE HIGHWORD IS NEGATIVE, EXTEND WITH 0		if (ertyp != null) goto clean_up_all;		//	BAIL IF ERROR OCCURRED	}	/*	-------------------------------- STEP 4: CLEAN UP  --------------------------------	*/	//	COPY FINAL RESULT INTO OUTPUT APV	if (negative != false)	apv_negate	 (sum_ptr,product_ptr);	else							apv_duplicate(sum_ptr,product_ptr);	//	RECYCLE WORKING APVs	clean_up_all:;			//	LABEL FOR GOTOS	apv_recycle(sum_ptr);	}	//	END OF "ONLY CONTINUE IF ALLOCATION SUCCEEDED"	}	//	END OF "ONLY CONTINUE IF NO ERROR"	clean_up_temps:;		//	LABEL FOR GOTOS	apv_recycle(tmp_ptr1);	apv_recycle(tmp_ptr2);end apv_multiply;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_quotient														*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_quotient" DIVIDES THE APV POINTED TO BY "divisor_ptr" BY THE APV POINTED TO BY//	"dividend_ptr" AND PLACES THE INTEGER PART OF THE QUOTIENT IN THE APV POINTED TO BY "output_ptr".//	IF THE PASSED BOOLEAN "round" IS SET TO TRUE, THEN THE QUOTIENT IS ROUNDED.apv_quotient: proc(divisor_ptr,dividend_ptr,output_ptr,round) public swapable;	dcl (divisor_ptr,dividend_ptr,output_ptr)	pointer;	dcl round		boolean;	dcl negative	boolean;	dcl (quotient_ptr,quotient_bit_ptr,tmp_dividend_ptr,tmp_ptr)	pointer;	//	WORKING APVs	dcl clean_up_args	label;	dcl clean_up_all	label;	/*	---------------------------- STEP 1: PRELIMINARY CRUD  ----------------------------	*/	//	SPECIAL CASES: AVOID FURTHER COMPUTATION IF DIVIDEND HAS A VALUE OF 0, 1 OR -1	write(mam) = dividend_ptr; write(mal) = apv#wlen;	//	POINT TO THE DIVIDEND'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{									//	IF THE DIVIDEND HAS A VALUE OF ZERO,			set.error(err.div.zero,'');						//	THEN REPORT A "DIVISION BY ZERO" ERROR			return;													//	AND BAIL		}		if (read(md) == 1)	{									//	IF THE DIVIDEND HAS A VALUE OF ONE,			apv_duplicate(divisor_ptr,output_ptr);			//	THEN RETURN THE DIVISOR			return;		}		if (read(md) == -1)	{									//	IF THE DIVIDEND HAS A VALUE OF NEGATIVE ONE,			apv_negate(divisor_ptr,output_ptr);				//	THEN RETURN THE NEGATED DIVISOR			return;		}	}	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF DIVISOR HAS A VALUE OF 0	write(mam) = divisor_ptr; write(mal) = apv#wlen;	//	POINT TO THE DIVISOR'S WORD LENGTH	if ((read(mdi) == 1) && (read(md) == 0)) {			//	IF THE DIVISOR HAS A VALUE OF ZERO,		apv_assign(output_ptr,0);								//	THEN RETURN ZERO		return;	}	//	DUPLICATE THE INPUT APVs AND DEAL WITH SIGN CONVERSIONS	//	ALLOCATE WORKING APV	tmp_ptr = apv_allocate_node; if (tmp_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	write(mam) = divisor_ptr; write(mal) = apv#wlen;				//	POINT TO THE DIVISOR'S WORD LENGTH	if (apv_get_word(divisor_ptr,read(md)-1) < 0) {apv_negate	(divisor_ptr,tmp_ptr); negative = true;}	else														 {apv_duplicate(divisor_ptr,tmp_ptr); negative = false;}	if (ertyp != null) {apv_recycle(tmp_ptr); return;}				//	BAIL IF ERROR OCCURRED	divisor_ptr = tmp_ptr;	//	FROM HERE ON WE'LL REFERENCE THE WORKING (POSSIBLY NEGATED) COPY RATHER THAN THE ORIGINAL	//	REALLOCATE WORKING APV	tmp_ptr = apv_allocate_node;	if (tmp_ptr != null) {	//	ONLY CONTINUE IF ALLOCATION SUCCEEDED	write(mam) = dividend_ptr; write(mal) = apv#wlen;				//	POINT TO THE DIVIDEND'S WORD LENGTH	if (apv_get_word(dividend_ptr,read(md)-1) < 0) {apv_negate	 (dividend_ptr,tmp_ptr); negative = negative xor true;}	else															apv_duplicate(dividend_ptr,tmp_ptr);	if (ertyp != null) {		//	BAIL IF ERROR OCCURRED		apv_recycle(tmp_ptr);		apv_recycle(divisor_ptr);		return;	}	dividend_ptr = tmp_ptr;	//	FROM HERE ON WE'LL REFERENCE THE WORKING (POSSIBLY NEGATED) COPY RATHER THAN THE ORIGINAL	//	SAVE COMPARISON FOR SPECIAL CASES BELOW	write(reg_dst|r13) = apv_compare(divisor_ptr,dividend_ptr);	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE DIVISOR IS EQUAL TO THE DIVIDEND	if (read(reg_src|r13) == #ieq) {		if (negative != false)	apv_assign(output_ptr,-1);		else							apv_assign(output_ptr,1);		goto clean_up_args;	//	WE'RE DONE	}	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE DIVISOR IS LESS THAN THE DIVIDEND	if (read(reg_src|r13) == #ilt) {		if (round != false) {			apv_shl(divisor_ptr,divisor_ptr);			if (ertyp != null) goto clean_up_args;						//	BAIL IF ERROR OCCURRED			if (apv_compare(divisor_ptr,dividend_ptr) == #ilt)	apv_assign(output_ptr,0);			else {				if (negative != false)	apv_assign(output_ptr,-1);				else							apv_assign(output_ptr,1);			}		}		else apv_assign(output_ptr,0);		goto clean_up_args;	//	WE'RE DONE	}	//	ALLOCATE WORKING APVs	quotient_ptr				 = apv_allocate_node; if (quotient_ptr					!= null) {	quotient_bit_ptr			 = apv_allocate_node; if (quotient_bit_ptr			!= null) {	tmp_dividend_ptr			 = apv_allocate_node; if (tmp_dividend_ptr			!= null) {	tmp_ptr						 = apv_allocate_node; if (tmp_ptr						!= null) {	apv_assign(quotient_ptr,0);	/*	------------------ STEP 2: PRE-NORMALIZE FOR MAXIMUM EFFICIENCY  ------------------	*/	#if (false) 	//	NEVER MIND: This section of code doesn't really speed things up in most cases.  In fact it slows things down	//	trying to minimize the sizes of the divisor and dividend, but this doesn't really benefit us except in the most	//	absurd and rare of circumstances.	//	REMOVE COMMON POWERS OF 64K	while ((apv_get_word(divisor_ptr,0) == 0) && (apv_get_word(dividend_ptr,0) == 0)) {		apv_word_shr(divisor_ptr,					divisor_ptr);					if (ertyp != null) goto clean_up_all;		apv_word_shr(dividend_ptr,					dividend_ptr);					if (ertyp != null) goto clean_up_all;		apv_word_shl(modulus_scale_factor_ptr,	modulus_scale_factor_ptr);	if (ertyp != null) goto clean_up_all;	}	//	REMOVE COMMON POWERS OF 2	while (((apv_get_word(divisor_ptr,0) & 1) == 0) && ((apv_get_word(dividend_ptr,0) & 1) == 0)) {		apv_shr(divisor_ptr,					divisor_ptr);					if (ertyp != null) goto clean_up_all;		apv_shr(dividend_ptr,				dividend_ptr);					if (ertyp != null) goto clean_up_all;		apv_shl(modulus_scale_factor_ptr,modulus_scale_factor_ptr);	if (ertyp != null) goto clean_up_all;	}	//	SHIFT DIVISOR RIGHT BY WORDS WHILE ITS LOW WORD = 0 UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR	compare_result = #igt;	write(mam) = divisor_ptr; write(mal) = apv#lsw;	//	point to the divisor's least significant word	while ((read(md) == 0) && (compare_result == #igt)) {		apv_word_shr(divisor_ptr,tmp_ptr);		compare_result = apv_compare(tmp_ptr,dividend_ptr);		if (compare_result != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = divisor_ptr;			divisor_ptr = read(reg_src|r13);			//	ADJUST THE INITIAL QUOTIENT BIT AND THE MODULUS SCALE FACTOR ACCORDINGLY			apv_word_shl(initial_quotient_bit_ptr,initial_quotient_bit_ptr); if (ertyp != null) goto clean_up_all;			apv_word_shl(modulus_scale_factor_ptr,modulus_scale_factor_ptr); if (ertyp != null) goto clean_up_all;			//	SET UP FOR NEXT ITERATION			write(mam) = divisor_ptr; write(mal) = apv#lsw;	//	point to the divisor's least significant word		}	}	//	SHIFT DIVISOR RIGHT BY BITS WHILE IT'S EVEN UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR	compare_result = #igt;	write(mam) = divisor_ptr; write(mal) = apv#lsw;	//	point to the divisor's least significant word	while (((read(md) & 1) == 0) && (compare_result == #igt)) {		apv_shr(divisor_ptr,tmp_ptr);		compare_result = apv_compare(tmp_ptr,dividend_ptr);		if (compare_result != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = divisor_ptr;			divisor_ptr = read(reg_src|r13);			//	ADJUST THE INITIAL QUOTIENT BIT AND THE MODULUS SCALE FACTOR ACCORDINGLY			apv_shl(initial_quotient_bit_ptr,initial_quotient_bit_ptr); if (ertyp != null) goto clean_up_all;			apv_shl(modulus_scale_factor_ptr,modulus_scale_factor_ptr); if (ertyp != null) goto clean_up_all;			//	SET UP FOR NEXT ITERATION			write(mam) = divisor_ptr; write(mal) = apv#lsw;	//	point to the divisor's least significant word		}	}	#endif	/*	------------------------------- STEP 3: GO TO TOWN  -------------------------------	*/	while (apv_compare(divisor_ptr,dividend_ptr) != #ilt) {		apv_duplicate(dividend_ptr,tmp_dividend_ptr); if (ertyp != null) goto clean_up_all;		apv_assign(quotient_bit_ptr,1);		/*	--------------------- STEP 3.1: NORMALIZE TEMP DIVIDEND ---------------------	*/		//	SHIFT DIVIDEND LEFT BY WORDS UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR		apv_word_shl(tmp_dividend_ptr,tmp_ptr);		if (ertyp != null) goto clean_up_all;		while (apv_compare(divisor_ptr,tmp_ptr) != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = tmp_dividend_ptr;			tmp_dividend_ptr = read(reg_src|r13);			//	ADJUST THE QUOTIENT BIT ACCORDINGLY			apv_word_shl(quotient_bit_ptr,quotient_bit_ptr);			if (ertyp != null) goto clean_up_all;			//	SET UP FOR NEXT ITERATION			apv_word_shl(tmp_dividend_ptr,tmp_ptr);			if (ertyp != null) goto clean_up_all;		}		//	SHIFT DIVIDEND LEFT BY BITS UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR		apv_shl(tmp_dividend_ptr,tmp_ptr);		if (ertyp != null) goto clean_up_all;		while (apv_compare(divisor_ptr,tmp_ptr) != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = tmp_dividend_ptr;			tmp_dividend_ptr = read(reg_src|r13);			//	ADJUST THE QUOTIENT BIT ACCORDINGLY			apv_shl(quotient_bit_ptr,quotient_bit_ptr);			if (ertyp != null) goto clean_up_all;			//	SET UP FOR NEXT ITERATION			apv_shl(tmp_dividend_ptr,tmp_ptr);			if (ertyp != null) goto clean_up_all;		}		/*	--------------------------- STEP 3.2: ARITHMETIC  ---------------------------	*/		apv_addsub(divisor_ptr,tmp_dividend_ptr,divisor_ptr,#subtract);		if (ertyp != null) goto clean_up_all;		apv_or(quotient_bit_ptr,quotient_ptr,quotient_ptr);		if (ertyp != null) goto clean_up_all;	}	//	NOTE: THE REMAINDER IS NOW IN THE APV POINTED TO BY "divisor_ptr"	if (round != false) {		apv_shl(divisor_ptr,tmp_ptr); if (ertyp != null) goto clean_up_all;		if (apv_compare(tmp_ptr,dividend_ptr) != #ilt) {			apv_assign(tmp_ptr,1);			apv_addsub(quotient_ptr,tmp_ptr,quotient_ptr,#add);			if (ertyp != null) goto clean_up_all;		}	}	/*	-------------------------------- STEP 4: CLEAN UP  --------------------------------	*/	//	COPY FINAL RESULT INTO OUTPUT APV	if (negative != false)	apv_negate	 (quotient_ptr,output_ptr);	else							apv_duplicate(quotient_ptr,output_ptr);	//	RECYCLE WORKING APVs	clean_up_all:;		//	LABEL FOR GOTOS	apv_recycle(tmp_ptr);	}	//	END OF "if (tmp_ptr				!= null)"	apv_recycle(tmp_dividend_ptr);	}	//	END OF "if (tmp_dividend_ptr	!= null)"	apv_recycle(quotient_bit_ptr);	}	//	END OF "if (quotient_bit_ptr	!= null)"	apv_recycle(quotient_ptr);	}	//	END OF "if (quotient_ptr		!= null)"	clean_up_args:;	//	LABEL FOR GOTOS	apv_recycle(dividend_ptr);	}	//	END OF "ONLY CONTINUE IF ALLOCATION SUCCEEDED"	apv_recycle(divisor_ptr);end apv_quotient;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_mod																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_mod" RETURNS THE REMAINDER AFTER DIVIDING THE PASSED APVs.apv_mod: proc(divisor_ptr,dividend_ptr,output_ptr) public swapable;	dcl (divisor_ptr,dividend_ptr,output_ptr)	pointer;	dcl (tmp_dividend_ptr,tmp_ptr)				pointer;	//	WORKING APVs	dcl negative	boolean;	dcl clean_up_args	label;	dcl clean_up_all	label;	/*	---------------------------- STEP 1: PRELIMINARY CRUD  ----------------------------	*/	//	SPECIAL CASES: AVOID FURTHER COMPUTATION IF DIVIDEND HAS A VALUE OF 0, 1 OR -1	write(mam) = dividend_ptr; write(mal) = apv#wlen;	//	POINT TO THE DIVIDEND'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{									//	IF THE DIVIDEND HAS A VALUE OF ZERO,			set.error(err.div.zero,'');						//	THEN REPORT A "DIVISION BY ZERO" ERROR			return;													//	AND BAIL		}		if ((read(md) == 1) || (read(md) == -1))	{		//	IF THE DIVIDEND HAS A VALUE OF ONE OR NEGATIVE ONE,			apv_assign(output_ptr,0);							//	THEN RETURN ZERO			return;		}	}	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF DIVISOR HAS A VALUE OF 0, 1 OR -1	write(mam) = divisor_ptr; write(mal) = apv#wlen;	//	POINT TO THE DIVISOR'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{									//	IF THE DIVISOR HAS A VALUE OF ZERO,			apv_assign(output_ptr,0);							//	THEN RETURN ZERO			return;		}		if ((read(md) == 1) || (read(md) == -1))	{		//	IF THE DIVISOR HAS A VALUE OF ONE OR NEGATIVE ONE,			apv_assign(output_ptr,read(md));					//	THEN RETURN THE DIVISOR			return;		}	}	//	DUPLICATE THE INPUT APVs AND DEAL WITH SIGN CONVERSIONS	//	ALLOCATE WORKING APV	tmp_ptr = apv_allocate_node; if (tmp_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	write(mam) = divisor_ptr; write(mal) = apv#wlen;				//	POINT TO THE DIVISOR'S WORD LENGTH	if (apv_get_word(divisor_ptr,read(md)-1) < 0) {apv_negate	(divisor_ptr,tmp_ptr); negative = true;}	else														 {apv_duplicate(divisor_ptr,tmp_ptr); negative = false;}	if (ertyp != null) {apv_recycle(tmp_ptr); return;}				//	BAIL IF ERROR OCCURRED	divisor_ptr = tmp_ptr;	//	FROM HERE ON WE'LL REFERENCE THE WORKING (POSSIBLY NEGATED) COPY RATHER THAN THE ORIGINAL	//	REALLOCATE WORKING APV	tmp_ptr = apv_allocate_node;	if (tmp_ptr != null) {	//	ONLY CONTINUE IF ALLOCATION SUCCEEDED	write(mam) = dividend_ptr; write(mal) = apv#wlen;				//	POINT TO THE DIVIDEND'S WORD LENGTH	if (apv_get_word(dividend_ptr,read(md)-1) < 0)	apv_negate	 (dividend_ptr,tmp_ptr);	else															apv_duplicate(dividend_ptr,tmp_ptr);	if (ertyp != null) {		//	BAIL IF ERROR OCCURRED		apv_recycle(tmp_ptr);		apv_recycle(divisor_ptr);		return;	}	dividend_ptr = tmp_ptr;	//	FROM HERE ON WE'LL REFERENCE THE WORKING (POSSIBLY NEGATED) COPY RATHER THAN THE ORIGINAL	//	SAVE COMPARISON FOR SPECIAL CASES BELOW	write(reg_dst|r13) = apv_compare(divisor_ptr,dividend_ptr);	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE DIVISOR IS EQUAL TO THE DIVIDEND	if (read(reg_src|r13) == #ieq) {		apv_assign(output_ptr,0);		goto clean_up_args;	//	WE'RE DONE	}	//	SPECIAL CASE: AVOID FURTHER COMPUTATION IF THE DIVISOR IS LESS THAN THE DIVIDEND	if (read(reg_src|r13) == #ilt) {		if (negative != false)	apv_negate	 (divisor_ptr,output_ptr);		else							apv_duplicate(divisor_ptr,output_ptr);		goto clean_up_args;	//	WE'RE DONE	}	//	ALLOCATE WORKING APVs	tmp_dividend_ptr	= apv_allocate_node; if (tmp_dividend_ptr	!= null) {	tmp_ptr				= apv_allocate_node; if (tmp_ptr				!= null) {	/*	------------------------------- STEP 3: GO TO TOWN  -------------------------------	*/	while (apv_compare(divisor_ptr,dividend_ptr) != #ilt) {		apv_duplicate(dividend_ptr,tmp_dividend_ptr); if (ertyp != null) goto clean_up_all;	//	BAIL IF ERROR OCCURRED		/*	--------------------- STEP 3.1: NORMALIZE TEMP DIVIDEND ---------------------	*/		//	SHIFT DIVIDEND LEFT BY WORDS UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR		apv_word_shl(tmp_dividend_ptr,tmp_ptr);		if (ertyp != null) goto clean_up_all;		while (apv_compare(divisor_ptr,tmp_ptr) != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = tmp_dividend_ptr;			tmp_dividend_ptr = read(reg_src|r13);			//	SET UP FOR NEXT ITERATION			apv_word_shl(tmp_dividend_ptr,tmp_ptr);			if (ertyp != null) goto clean_up_all;		}		//	SHIFT DIVIDEND LEFT BY BITS UNTIL IT WOULD CAUSE DIVIDEND TO EXCEED DIVISOR		apv_shl(tmp_dividend_ptr,tmp_ptr);		if (ertyp != null) goto clean_up_all;		while (apv_compare(divisor_ptr,tmp_ptr) != #ilt) {			//	SWAP THE POINTERS			write(reg_dst|r13) = tmp_ptr;			tmp_ptr = tmp_dividend_ptr;			tmp_dividend_ptr = read(reg_src|r13);			//	SET UP FOR NEXT ITERATION			apv_shl(tmp_dividend_ptr,tmp_ptr);			if (ertyp != null) goto clean_up_all;		}		/*	--------------------------- STEP 3.2: ARITHMETIC  ---------------------------	*/		apv_addsub(divisor_ptr,tmp_dividend_ptr,divisor_ptr,#subtract);		if (ertyp != null) goto clean_up_all;	}	//	NOTE: THE REMAINDER IS NOW IN THE APV POINTED TO BY "divisor_ptr"	/*	-------------------------------- STEP 4: CLEAN UP  --------------------------------	*/	//	COPY FINAL RESULT INTO OUTPUT APV	if (negative != false)	apv_negate	 (divisor_ptr,output_ptr);	else							apv_duplicate(divisor_ptr,output_ptr);	//	RECYCLE WORKING APVs	clean_up_all:;		//	LABEL FOR GOTOS	apv_recycle(tmp_ptr);	}	//	END OF "(tmp_ptr			  != null)"	apv_recycle(tmp_dividend_ptr);	}	//	END OF "(tmp_dividend_ptr != null)"	clean_up_args:;	//	LABEL FOR GOTOS	apv_recycle(dividend_ptr);	}	//	END OF "ONLY CONTINUE IF ALLOCATION SUCCEEDED"	apv_recycle(divisor_ptr);end apv_mod;#if (false)/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_sqroot															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_sqroot" OUTPUTS THE TRUNCATED INTEGER SQUARE ROOT OF THE INPUT APV.apv_sqroot: proc(input_ptr,output_ptr) public swapable;	dcl (input_ptr,output_ptr) pointer;	dcl radicand_ptr	pointer;	//	SPECIAL CASE: ZERO OR ONE	write(mam) = input_ptr; write(mal) = apv#wlen;	//	POINT TO THE INPUT APV'S WORD LENGTH	if ((read(mdi) == 1) && (read(md) ile 1)) {		if (input_ptr != output_ptr) apv_duplicate(input_ptr,output_ptr);		return;	}	//	ALLOCATE WORKING APV	radicand_ptr = apv_allocate_node; if (radicand_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	//	RECYCLE WORKING APV	apv_recycle(radicand_ptr);end apv_sqroot;sqroot: proc(radicand) returns (fixed) public swapable;	dcl radicand fixed;	dcl (bit, a, b, a_squared, b_squared, estimate_squared) fixed;		if (radicand ile 1) return radicand;	a = shr(radicand,1); bit = 0;	while (a != 0) {a = shr(a,1); bit = bit+1;}	//	bit = highest bit set (log base 2)	bit = shr(bit,1);										//	bit = 1/2 highest bit set (truncated)	a = shl(1,bit); b = a;					//	set up a	load a; mul a; a_squared = res;		//	set up a^2		while (bit != 0) {		bit = bit-1;		b = shr(b,1);							//	set up b		load b; mul b; b_squared = res;	//	set up b^2		load a; mul b;							//	set up 2ab (res+res)		estimate_squared = a_squared + res+res + b_squared;	//	(a+b)^2 = a^2 + 2ab + b^2		if (estimate_squared ile radicand) {			a = a+b; a_squared = estimate_squared;		}	}	return a;end sqroot;#endif/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_gcd																*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_gcd" RETURNS THE GREATEST COMMON DIVISOR OF THE TWO PASSED APVs.apv_gcd: proc(ptr1,ptr2,output_ptr) public swapable;	dcl (ptr1,ptr2,output_ptr)					pointer;	dcl (larger_ptr,smaller_ptr,mod_ptr)	pointer;	//	WORKING APVs	dcl negative	boolean;	dcl clean_up	label;	//	ALLOCATE WORKING APVs, DUPLICATE THE INPUT APVs THERE AND DEAL WITH SIGN CONVERSIONS	larger_ptr	= apv_allocate_node; if (larger_ptr	 == null) return;	//	BAIL IF ALLOCATION FAILED	write(mam) = ptr1; write(mal) = apv#wlen;	//	POINT TO THE FIRST APV'S WORD LENGTH	if (apv_get_word(ptr1,read(md)-1) < 0)	{apv_negate   (ptr1,larger_ptr); negative = true;}	else												{apv_duplicate(ptr1,larger_ptr); negative = false;}	if (ertyp == null) {			//	ONLY CONTINUE IF NO ERROR	smaller_ptr	= apv_allocate_node;	if (smaller_ptr != null) {	//	ONLY CONTINUE IF ALLOCATION SUCCEEDED	write(mam) = ptr2; write(mal) = apv#wlen;	//	POINT TO THE SECOND APV'S WORD LENGTH	if (apv_get_word(ptr2,read(md)-1) < 0)	{apv_negate   (ptr2,smaller_ptr); negative = (negative & true);}	else												{apv_duplicate(ptr2,smaller_ptr); negative = false;}	if (ertyp == null) {			//	ONLY CONTINUE IF NO ERROR	//	MAKE SURE THAT THE VALUE OF THE APV POINTED TO BY "smaller_ptr" IS LESS THAN THE VALUE OF THE APV POINTED TO BY "larger_ptr"	if apv_compare(larger_ptr,smaller_ptr) == #ilt {		//	SWAP THE POINTERS		write(reg_dst|r13) = larger_ptr;		larger_ptr = smaller_ptr;		smaller_ptr = read(reg_src|r13);	}	//	ALLOCATE ONE MORE WORKING APV	mod_ptr = apv_allocate_node;	if (mod_ptr != null) {		//	ONLY CONTINUE IF ALLOCATION SUCCEEDED	//	SET UP FOR FIRST ITERATION	apv_mod(larger_ptr,smaller_ptr,mod_ptr);	if (ertyp == null) {			//	ONLY CONTINUE IF NO ERROR	write(mam) = mod_ptr; write(mal) = 1;	//	KEEP REDUCING UNTIL THE MODULUS IS ZERO	while ((read(mdi) != 1) || (read(md) != 0)) {		//	CYCLE THE POINTERS		write(reg_dst|r13) = larger_ptr;		larger_ptr = smaller_ptr;		smaller_ptr = mod_ptr;		mod_ptr = read(reg_src|r13);		//	SET UP FOR NEXT ITERATION		apv_mod(larger_ptr,smaller_ptr,mod_ptr);		if (ertyp != null) goto clean_up;	//	BAIL IF ERROR OCCURRED		write(mam) = mod_ptr; write(mal) = 1;	}	//	COPY FINAL RESULT INTO OUTPUT APV	if (negative != false)	apv_negate	 (smaller_ptr,output_ptr);	else							apv_duplicate(smaller_ptr,output_ptr);	//	RECYCLE WORKING APVs	}	//	END OF "ONLY CONTINUE IF NO ERROR"	clean_up:;	//	LABEL FOR GOTOS	apv_recycle(mod_ptr);	}	//	END OF "ONLY CONTINUE IF ALLOCATION SUCCEEDED"	}	//	END OF "ONLY CONTINUE IF NO ERROR"	apv_recycle(smaller_ptr);	}	//	END OF "ONLY CONTINUE IF ALLOCATION SUCCEEDED"	}	//	END OF "ONLY CONTINUE IF NO ERROR"	apv_recycle(larger_ptr);end apv_gcd;/*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_reduce															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE FUNCTION "apv_reduce" REDUCES THE PASSED RATIO OF APVs IN PLACE TO IT'S LOWEST FORM.apv_reduce: proc(numerator_ptr,denominator_ptr) public swapable;	dcl (numerator_ptr,denominator_ptr) pointer;	dcl gcd_ptr	pointer;	//	SPECIAL CASES: AVOID FURTHER COMPUTATION IF THE DENOMINATOR HAS A VALUE OF 0 OR 1	write(mam) = denominator_ptr; write(mal) = apv#wlen;	//	POINT TO THE DENOMINATOR'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{										//	IF THE DENOMINATOR HAS A VALUE OF ZERO,			set.error(err.div.zero,'');							//	THEN REPORT A "DIVISION BY ZERO" ERROR			return;														//	AND BAIL		}		if (read(md) == 1) return;									//	IF THE DENOMINATOR HAS A VALUE OF ONE, THEN BAIL	}	//	SPECIAL CASES: AVOID FURTHER COMPUTATION IF THE NUMERATOR HAS A VALUE OF 0 OR 1	write(mam) = numerator_ptr; write(mal) = apv#wlen;		//	POINT TO THE NUMERATOR'S WORD LENGTH	if (read(mdi) == 1)	{		if (read(md) == 0)	{										//	IF THE NUMERATOR HAS A VALUE OF ZERO,			apv_assign(denominator_ptr,1);						//	THEN RETURN 0/1			return;		}		if (read(md) == 1) return;									//	IF THE NUMERATOR HAS A VALUE OF ONE, THEN BAIL	}	//	ALLOCATE WORKING APV	gcd_ptr = apv_allocate_node; if (gcd_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	//	GET GREATEST COMMON DIVISOR	apv_gcd(numerator_ptr,denominator_ptr,gcd_ptr);	if (ertyp == null) {		//	ONLY CONTINUE IF NO ERROR		//	ONLY REDUCE IF GCD IS NOT 1		write(mam) = gcd_ptr; write(mal) = apv#wlen;			//	POINT TO GCD's WORD LENGTH		if ((read(mdi) != 1) || (read(md) != 1)) {			apv_quotient(numerator_ptr  ,gcd_ptr,numerator_ptr  ,false);			apv_quotient(denominator_ptr,gcd_ptr,denominator_ptr,false);		}	}	//	END OF "ONLY CONTINUE IF NO ERROR"	//	RECYCLE WORKING APV	apv_recycle(gcd_ptr);end apv_reduce;/*ииии  P U B L I C   P R O C E D U R E S   A N D   F U N C T I O N S  ииии*///	THE REMAINING PROCEDURES PERFORM VARIOUS OTHER (NON-MATHEMATICAL) OPERATIONS//	WITH ABSOLUTE PRECISION VARIABLES./*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*//*																							*//*		PROCEDURE apv_print															*//*																							*//*	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	*///	THE PROCEDURE "apv_print" PRINTS THE DECIMAL SIGNED INTEGER VALUE OF//	THE ABSOLUTE PRECISION VARIABLE POINTED TO BY THE PASSED POINTER.apv_print: proc (apv_ptr) public swapable;	dcl apv_ptr						pointer;	dcl (tmp_ptr,quotient_ptr)	pointer;	//	WORKING APVs	dcl string_ptr					pointer;	//	STRING APV	dcl (string_index,digit_index,index)	pointer;	dcl (word,remainder)			fixed;	dcl negative					boolean;	dcl clean_up					label;	//	SPECIAL CASE: 0	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE APV'S WORD LENGTH	if ((read(mdi) == 1) && (read(md) == 0)) {pc(a.0); return;}		/*	-------------------------- STEP 1: ALLOCATE WORKING APVs --------------------------	*/	//	ALLOCATE WORKING APV	tmp_ptr = apv_allocate_node; if (tmp_ptr == null) return;	//	BAIL IF ALLOCATION FAILED	//	MAKE A WORKING COPY OF THE INPUT APV	//	DETERMINE IF THE INPUT APV IS NEGATIVE, NEGATE THE COPY IF SO	write(mam) = apv_ptr; write(mal) = apv#wlen;	//	POINT TO THE APV'S WORD LENGTH	if (apv_get_word(apv_ptr,read(md)-1) < 0)	{apv_negate   (apv_ptr,tmp_ptr); negative = true;}	else													{apv_duplicate(apv_ptr,tmp_ptr); negative = false;}	if (ertyp == null) {														//	ONLY CONTINUE IF NO ERROR	//	ALLOCATE OUTPUT STRING APV	string_ptr	 = apv_allocate_node; if (string_ptr	!= null) {	//	ALLOCATE ANOTHER WORKING APV	quotient_ptr = apv_allocate_node; if (quotient_ptr	!= null) {	/*	------------------------- STEP 2: GENERATE OUTPUT STRING  -------------------------	*/	string_index = -1; digit_index = 0;	write(mam) = tmp_ptr; write(mal) = apv#wlen;	//	POINT TO THE WORKING APV'S WORD LENGTH	while ((read(mdi) != 1) || (read(md) != 0)) {		/*	---------------------- STEP 2.1: DIVIDE THE APV BY 10  ----------------------	*/		//	PERFORM THE DIVISION		remainder = 0;										//	ZERO THE REMAINDER FOR THE FIRST ITERATION		write(mal) = apv#wlen;							//	POINT TO THE DIVISOR'S WORD LENGTH		do index = read(md)-1 to 0 by -1;			load apv_get_word(tmp_ptr,index);		//	LOAD INDEXED WORD OF DIVISOR INTO HMD'S LSW			uload remainder;								//	LOAD REMAINDER FROM PREVIOUS ITERATION INTO HMD'S MSW			div 10;											//	DIVIDE BY 10			apv_put_word(quotient_ptr,index,res);	//	PLACE THE INTEGER RESULT INTO THE QUOTIENT APV			if (ertyp != null) goto clean_up;		//	BAIL IF ERROR OCCURRED			remainder = rem;								//	STORE THE REMAINDER FOR THE NEXT ITERATION		end;		write(mam) = quotient_ptr; write(mal) = apv#wlen;		//	POINT TO THE QUOTIENT'S WORD LENGTH		if ((read(md) != 1) && (apv_get_word(quotient_ptr,read(md)-1) == 0)) {			//	MUST DECREMENT THE QUOTIENT'S WORD LENGTH			write(mam) = quotient_ptr; write(mal) = apv#wlen;	//	POINT TO THE QUOTIENT'S WORD LENGTH AGAIN			write(md) = read(md)-1;		}		//	COPY THE QUOTIENT APV INTO THE WORKING APV		apv_duplicate(quotient_ptr,tmp_ptr);		/*	---------- STEP 2.2: PLACE THE REMAINDER IN THE OUTPUT STRING APV  ----------	*/		if ((digit_index & 3) == 0) {word = rem; string_index = string_index+1;}		else word = word|shl(rem,shl(digit_index&3,2));		apv_put_word(string_ptr,string_index,word);		if (ertyp != null) goto clean_up;	//	BAIL IF ERROR OCCURRED		digit_index = digit_index+1;				write(mam) = tmp_ptr; write(mal) = apv#wlen;	//	POINT TO THE WORKING APV'S WORD LENGTH IN PREPARATION FOR NEXT ITERATION	}	//	OF DO WHILE	/*	------------------------------ STEP 3: SCREEN OUTPUT ------------------------------	*/	if (negative == false)	pc(a.plus);	else							pc(a.minus);	do index = digit_index-1 to 0 by -1;		//	PRINT THE DIGIT		pc(a.0+(shr(word,shl(index&3,2))&15));		//	PRINT A COMMA IF APPROPRIATE		load index; div 3;		if ((rem == 0) && (index != 0)) {			pc(a.comma);			//	PRINT CR,LF,SPACE IF APPROPRIATE			write(reg_dst|r13) = digit_index-index;			if (read(reg_src|r13) igt 2) {				load read(reg_src|r13); div 57;				if (rem ile 2) {pcr(); pc(a.space);}			}		}		//	DECREMENT THE STRING APV'S INDEX AND GET NEXT WORD IF APPROPRIATE		if ((index & 3) == 0) {			string_index = string_index-1;			word = apv_get_word(string_ptr,string_index);		}	end;	/*	-------------------------- STEP 4: RECYCLE WORKING APVs  --------------------------	*/	clean_up:;	//	LABEL FOR GOTOS	apv_recycle(quotient_ptr);	}	//	END OF "if (quotient_ptr != null)"	apv_recycle(string_ptr);	}	//	END OF "if (string_ptr	 != null)"	}	//	END OF "ONLY CONTINUE IF NO ERROR"	apv_recycle(tmp_ptr);end apv_print;end S#APV.0;