/* OPTICAL  $TITLE  Routines to Activate, Format, & Update Optical Disk *//* Modified:   10/19/90 - cj  - cleared event bits generated by ourselves   08/06/90 - LSS - call to new error for unformatted magneto optical media   05/03/89 - SGS - Moved Transfer.Optical.Data from ARC-ACT to here   05/03/89 - TSS - Merged changes for Optical disk to DTD transfer project   02/17/89 - SGS - index creation bug when .INDEX is full   09/08/88 - KJO - added one parameter to OPTICAL_FORMAT   05/22/88 - KJO - updated for new version of UPDATE_INDEX_FILE   11/14/87 - LSS - bug fix in ACTIVATE.OPTICAL*/dcl Open.Format.Optical.Dialog         proc                recursive;dcl Get.Format.Optical.Response        proc (array,array,array,array)  returns(fixed) recursive; /* handle input on FORMAT dialog panel */dcl Open.Update.Optical.Dialog         proc                recursive;dcl Get.Update.Optical.Response        proc returns(fixed) recursive; /* handle input on UPDATE OPTICAL dialog panel */dcl Open.Optical.Volume.Change.Dialog  proc                recursive;dcl Get.Optical.Volume.Change.Response proc returns(fixed) recursive; /* handles input on VOLUME CHANGE dialog panel */Able.To.Format.Optical.Disk: proc boolean swapable; /* tries to format optical disk */   dcl Name     (8) fixed;   dcl Caption (40) fixed;   dcl Date    (10) fixed;   dcl Time    (10) fixed;   dcl FormatOk     boolean;   FormatOk=false;   do while not FormatOk;        /* loop until format succeeds or dies completely */      call Open.Format.Optical.Dialog; /* prompt user for info */      if Get.Format.Optical.Response(Name,Caption,Date,Time) then do;        /* user wants to format */         call Set.Term.Attr(ATTR#Normal);         call Draw.Message('Formatting Optical Disk...');         if Optical_Format(Name,Caption,CONV.STR.TO.DATE(date),CONV.STR.TO.TIME(time),0,LaserDev) then do; /* format was successful */            FormatOk=true;            call Set.Term.Attr(ATTR#Normal);            call Draw.Message('Optical Disk Format Completed');         end;         else do; /* had an error */            if S$SenseKey<>S$Good then do; /* a scsi error */               if S$SenseKey=S$DataProtect               then call Set.Optical.Error(Err#WriteProtected);               else call Set.Optical.Error(Err#OtherScsiError);               return false;            end;            else do; /* a catalog error */               if C#Status=E#Treename then do;                  call Copy.String(name,fnbuf);                  call Set.Optical.Error(Err#BadVolumeName);               end;               else do;                  call Set.Optical.Error(Err#OtherCatError);                  return false;               end;            end;         end;      end;      else return false;            /* could not format - have to quit */   end;                             /* of loop until format succeeds or dies */   return true;                     /* was able to format disk */end Able.To.Format.Optical.Disk;/* $SUBTITLE Routine to Rebuild Winchester Index File after Optical Disk Operation *//* Handy routine to clear event bits that were created by our own *//* activities to keep from resetting optical disk file pointers   *//* when we do not want to:                                        */Clear.Our.Event.Bits: proc swapable;   if (new.poly.contents & (4\8)) <> 0    /* if any optical events pending */   then do;                               /* then send them over the       */      call check.next.event;              /* protocol & clear our bits     */      new.ABLE.poly.contents = new.ABLE.poly.contents & (not(4\8));   end;end Clear.Our.Event.Bits;Update.Laser.Index: proc boolean public swapable; /* tries to bring index file up to date with Optical disk */   dcl (BufPtr,BufSecs,BufMed)    fixed; /* main buffer defintion */   dcl (ExtPtr,ExtSecs,PolySecs)  fixed; /* stack buffer definition (always in external memory) */   dcl Treename              (40) fixed; /* space for a long treename */   dcl (i,status)                 fixed;      PUSH.SYSTEM.PDL;               /* free up as much of stack as we can */   call Set.Term.Attr(ATTR#Normal);   call Draw.Message('Updating optical disk index...');   bnk.len = 0;                       /* toss bank to get memory */   call MAXIMIZE.MEMORY.FOR.RECORD;   ExtPtr  = nah.ptr + nah.len;       /* start of external memory free area */   ExtSecs = bnk.ptr - ExtPtr;        /* length of external memory free area */   PolySecs=0;                              /* assume no poly   */   i=0;   call Set.Cur.Bin(i);   /* Maybe someday we will check other bins for room... */   /* 		do while ((com16(0,polyamount)<>lw#ieq) and (i<polynum));      	  call Set.Cur.Bin(i);      	  i=i+1;   		end;   		if i=polynum then i=0;   */      // CJ - 6/7/99 - Code looks totally screwed.  Will use wrong page of poly   // memory if PSLASTS(LW#MSB) is nonzero.      // Users may wish to erase poly memory before doing an update.      if com16(0,polyamount)<>lw#ieq then do;  /* poly memory is available */      call PS.SHUFFLE(0);                   /* get free space           */	  	   if (PSLASTS(LW#MSB) != 0)				  // can't use beyond first page (see call to DefineMArea below)			PolySecs = 0;							  // so no poly memory available				else if (PSMAXS(LW#MSB) != 0)			  // else if more than 32 megs available			PolySecs = 65535 - PSLASTS(LW#LSB);	  // limit to free memory on page 0		else											  // else less than 32 megs	      PolySecs = PSMAXS(LW#LSB)-PSLASTS(LW#LSB); /* length of poly memory free area */   end;   if PolySecs igt ExtSecs then do;         /* use poly memory           */      BufPtr  = PSLASTS(LW#LSB);            /* start at pslast in poly   */      BufSecs = PolySecs;                   /* total poly available      */      BufMed  = 2;                          /* in poly                   */   end;   else do;                                 /* use external memory       */      i = shr(ExtSecs,4);                   /* use 1/16 for stack        */      if i igt 64 then i=64;                /* but limit to 64 sectors   */      BufPtr  = ExtPtr + i;                 /* start main buffer right after stack buffer */      BufSecs = ExtSecs - i;                /* length of main buffer */      BufMed  = 1;                          /* in external memory */      ExtSecs = i;                          /* adjust size of stack buffer */   end;   if ExtSecs ile 2 then do;                /* minimum stack space not found */     call Set.Optical.Error(Err#MoreExternalMemoryNeeded);     status = false;                        /* memory allocation failed */   end;   else if BufSecs ile 2 then do;           /* minimum buffer space not found */      if BufMed = 2      then call Set.Optical.Error(Err#MorePolyMemoryNeeded);      else call Set.Optical.Error(Err#MoreExternalMemoryNeeded);      status = false;                       /* memory allocation failed */   end;   else do;                                 /* got the memory - go do update */      call DefineStack(ExtPtr,ExtSecs);            if BufMed = 2 /* use poly memory */      then call DefineMArea(0,0,BufPtr,0,BufSecs); /* use bin 0, 16-bit addressing */      else call DefineMArea(-1,0,BufPtr,0,BufSecs);      if Update_Index_File(Treename,LaserDev) then do; /* update the index file */         call Clear.Our.Event.Bits;         status=true;      end;      else do;         if S$SenseKey<>S$Good then do; /* a scsi error */            call Set.Optical.Error(Err#OtherScsiError);         end;         else do; /* a catalog error */            if (C#Status=E#Storage)            or (C#Status=E#CStorage)            or (C#Status=E#Dir_Full)            or (C#Status=E#Truncate)            then do;               /* get rid of index file that was partially built */               call Set.Optical.Error(Err#NoRoomInIndexCat);               if not Delete(Treename,0) then do;                  call ps(' Please delete ');                  call ps(Treename);               end;            end;            else if (C#Status=E#Stack_Full)            then do;               call Set.Optical.Error(Err#MoreExternalMemoryNeeded);            end;            else if (C#Status=E#Record_Full)            then do;               if BufMed=2 then call Set.Optical.Error(Err#MorePolyMemoryNeeded);               else             call Set.Optical.Error(Err#MoreExternalMemoryNeeded);            end;            else do;               call Set.Optical.Error(Err#SystemErrorWithUpdateIndex);            end;         end;         status=false;      end;   end;   if status=true then do;      call Set.Term.Attr(ATTR#Reverse);      call Draw.Message('Index update operation completed successfully.');   end;   POP.SYSTEM.PDL;               /* restore stack */   return status;end Update.Laser.Index;/* $SUBTITLE */dcl Activate.Operations.Performed fixed public; /* bits get set in word by Activate.Optical */Activate.Optical: proc (ControlBits) boolean public swapable;   dcl ControlBits     fixed;   dcl Name       (40) fixed;   Optical.Disk.Ready=0;            /* assume we will fail */   Activate.Operations.Performed=0; /* clear word */   do while 1;                   /* loop until Optical all ready or we die */      TRY.AGAIN:      if Check_Optical(LaserDev) then do;         Optical.Disk.Ready=1;         return true; /* everything in okay state */      end;      if S$SenseKey<>S$Good then do;        /* check for fatal scsi error  */         if (S$SenseKey=S$SelFailed) then do; /* these are all fatal optical */            call Set.Optical.Error(Err#NoSignal);            return false;         end;         else if (S$SenseKey=S$D24NotThere) then do;     /* disk hardware errors        */            call Set.Optical.Error(Err#NoD24Found);            return false;         end;         else if (S$SenseKey=S$MediumError) then do;            call Set.Optical.Error(Err#MediumError);            return false;         end;         else if (S$SenseKey=S$HardwareError) then do;            call Set.Optical.Error(Err#FatalHardware);            return false;         end;         else if (S$SenseKey=S$BadDevice) then do;            call Set.Optical.Error(Err#NotConfigured);            return false;         end;         else if S$SenseKey=S$NotReady then do;            call Set.Optical.Error(Err#DriveNotReady);  /* Either no disk in drive or needs to have LOAD pressed */            return false;         end;         else if S$SenseKey=S$BlankCheck then do; /* unformatted disk in drive */            if (ControlBits&O#FormatDialog)<>0 then do; /* open format dialog panel */               if not Able.To.Format.Optical.Disk then return false;               ControlBits=O#AutoUpdate|O#AutoVolChange; /* want to fully mount newly formatted disk */               Activate.Operations.Performed=Activate.Operations.Performed|ACT#Format;               GOTO TRY.AGAIN;              /* kludge */            end;            else do;               call Set.Optical.Error(Err#UnFormattedOptical);               return false;            end;         end;      end;      else do;                              /* check for fatal catalog error */         if C#Status=E#Not_Initialized then do; /* unformatted M/O media */            call Set.Optical.Error(Err#NotInitialized);            return false;         end;         else if C#Status=E#Bad_Volume then do;            call Set.Optical.Error(Err#BadOpticalVolume);            return false;         end;         else if C#Status=E#Volume_Changed then do; /* had a disk change */            if (ControlBits&(O#AutoVolChange|O#VolChangeDialog))<>0            then do;                            /* mount of new volume allowed */               if (ControlBits&O#VolChangeDialog)<>0               then do;                         /* open dialog for remount */                  call Open.Optical.Volume.Change.Dialog;                  if not Get.Optical.Volume.Change.Response then return false;               end;               Activate.Operations.Performed=Activate.Operations.Performed|ACT#VolChange;            end;            else do;               call Set.Optical.Error(Err#VolumeIndexMismatch);               return false;            end;         end;      end;      /* $PAGE */      if Open_Optical(Name,LaserDev) then do;         new.poly.contents = new.poly.contents \ 4;  /* create protocol event */         call Clear.Our.Event.Bits;         Optical.Disk.Ready=1;         return true;      end;      /* Possible problems at this point:                               */      /*    1. Can't find "W0:.INDEX" or "F0:.INDEX" catalog            */      /*    2. Can't find an Index file for this volume                 */      /*    3. Current Index file does not match current Optical volume */      /*    4. Index file is not up-to-date or is glommed               */      if S$SenseKey<>S$Good then do; /* have some unknown system error */         call Set.Optical.Error(Err#OtherScsiError);         return false;      end;      else do; /* have some catalog error */         if C#Status=E#No_Path then do;            call Set.Optical.Error(Err#NoIndexCatFound);            return false;         end;         else if C#Status=E#Not_Cat then do;            call Set.Optical.Error(Err#IndexCatTypeMismatch);            return false;         end;         else if (C#Status<>E#Bad_Index)         and     (C#Status<>E#No_File)         and     (C#Status<>E#No_Index)         and     (C#Status<>E#Not_UpToDate)         then do;   /* some other catalog error - treat as fatal */            call Set.Optical.Error(Err#OtherCatError);            return false;         end;         /* All other errors will be resolved at this */         /* point by trying to rebuild index file     */         if (ControlBits&(O#AutoUpdate|O#UpdateDialog))<>0         then do;                              /* try to update index file */            if (ControlBits&O#UpdateDialog)<>0            then do;               call Open.Update.Optical.Dialog; /* prompt user for info */               if Get.Update.Optical.Response then do;  /* user wants to update */                  Activate.Operations.Performed=Activate.Operations.Performed|ACT#Update;                  if Update.Laser.Index then do;        /* try to do it     */                     Optical.Disk.Ready=1;                     return true;                  end;               end;               else return false;                       /* could not update */            end;            else do;               Activate.Operations.Performed=Activate.Operations.Performed|ACT#Update;               if Update.Laser.Index then do;        /* try to do it     */                  Optical.Disk.Ready=1;                  return true;               end;               else return false;            end;         end;         else do;                              /* fatal error */            if (C#Status=E#Bad_Index)            then call Set.Optical.Error(Err#BadIndexFormat);            else if (C#Status=E#No_File)            or      (C#Status=E#No_Index)            then call Set.Optical.Error(Err#NoIndexFound);            else if (C#Status=E#Not_UpToDate)            then call Set.Optical.Error(Err#OutOfDateIndex);            return false;         end;      end;   end;end Activate.Optical;/* $SUBTITLE Transfer Data To and From the Optical Disk *//* NOTE:  TRANSFER.OPTICAL.DATA can copy from anywhere on the system          to the optical disk.  It can copy from the optical disk to          anywhere on the system EXCEPT poly memory.  This code can be          added (PS.LOAD), it just hasn't been.   LSS - 11/04/87 */Transfer.Optical.Data: proc(MS_Source,LS_Source,MS_Dest,LS_Dest,MS_Total,LS_Total,Sour_Dev,Dest_Dev) boolean public swapable;   dcl (MS_Source,LS_Source) fixed; /* source      file base address */   dcl (MS_Dest,LS_Dest)     fixed; /* destination file base address */   dcl (MS_Total,LS_Total)   fixed; /* total no. sectors to transfer */   dcl (Sour_Dev,Dest_Dev)   fixed; /* logical device #s - need these to deal with poly mem case */   dcl (Sour_Buf)            fixed; /* buffer contains info to write - only used if source dev is -1 */   dcl (MS_Moved,LS_Moved)   fixed; /* no. sectors transferred so far */   dcl chunk                 fixed; /* sector chunk of file */   dcl (msw,lsw)             fixed;   dcl BufBase               fixed; /* base sector address of disk buffer */   dcl BufSecSize            fixed; /* size of free memory in sectors */   /* NOTE: Routine assumes ACTIVATE.OPTICAL has */   /*       been called to set up Optical disk.  */   /* See note above - this routine currently cannot do this one case */   if Dest_Dev=PolyMemDev then return (false); /* trying to do optical to poly - can't do this yet */   run.syn=0;/* Let calling proc take care of status messages *//* call Set.Term.Attr(Attr#Normal);   if Sour_Dev=LaserDev then call Draw.Message('Reading from Optical Disk...');   else                      call Draw.Message('Writing to Optical Disk...');*/   if Sour_Dev <> PolyMemDev then do;   /* source is a real disk */      /* NOTE: BUFSECSIZE MUST BE AN EVEN NUMBER OF SECTORS */      bnk.len = 0;        /* toss bank to get memory */      call MAXIMIZE.MEMORY.FOR.RECORD;      BufBase    = nah.ptr + nah.len;      bufSecSize = bnk.ptr - BufBase;      if bufSecSize ilt EXTBUF.LEN THEN DO;         bufbase = extbuf.ptr;         BufSecSize = extbuf.len;      end;      BufSecSize = BufSecSize & "177776"; /* make multiple of 2 to write to optical disk since physical sector size is 1024 bytes */      MS_Moved = 0; LS_Moved = 0;   /* no sectors moved yet */      do while (MS_Moved ilt MS_Total) or ((MS_Moved = MS_Total) and (LS_Moved ilt LS_Total)); /* repeat until file is transferred */         msw = MS_Total - MS_Moved; /* find amount left to transfer */         if LS_Total ilt LS_Moved then msw = msw - 1;         lsw = LS_Total - LS_Moved;         if msw <> 0                /* more than 64k sectors to move */         then chunk = 65535;        /* set to 64K */         else chunk = lsw;          /* set to amount left to move */         if chunk igt BufSecSize then chunk = BufSecSize; /* limit to size of buffer */         call Ext.ReadData(MS_Source,LS_Source,BufBase,0,Chunk,0); /* get buffer full */         LS_Source = LS_Source + chunk; /* update starting sector */         if LS_Source ilt chunk then MS_Source = MS_Source + 1;         call Ext.WriteData(MS_Dest,LS_Dest,BufBase,0,Chunk,0); /* write this buffer */         LS_Dest = LS_Dest + chunk; /* update starting sector */         if LS_Dest ilt chunk then MS_Dest = MS_Dest + 1;         LS_Moved = LS_Moved + chunk; /* count sectors moved */         if LS_Moved ilt chunk then MS_Moved = MS_Moved + 1;		 		 timeshare_with_host();      end;   end;   else do; /* save file from Poly Memory onto Optical disk */      call poly.writedata (MS_Dest,LS_Dest,                           loc(addr(MS_Source)),                           0,0,                                               LS_Total);   end;/* Let calling proc take care of status messages *//* call Draw.Message('Operation Completed');     */   run.syn = 1;   return (true);end Transfer.Optical.Data;