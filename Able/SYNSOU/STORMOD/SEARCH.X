/* SEARCH   $TITLE  Search routines   Modified:   06/30/89 - SGS - Fixed bug in Get.Next.Search.Event   05/02/89 - TSS - Merged changes for Optical disk to DTD transfer project   12/01/88 - cj  - allow double click on Search button   12/21/87 - MWH - Use Get.Next.Optical.Event directly   12/07/87 - SGS - Added capability to match " " to "_" when comparing strings   *//* Searches for match in index list, starting with the currently    *//* selected cell.  If found returns true, else false.  Sets F/CList *//* pointers to appropriate place in index list                      */Search.DirTable.Forward: proc (Match,Code,Coord) fixed public swapable;   dcl Match       array; /* look for match with this string */   dcl Code        fixed; /* sort code - not used yet        */   dcl Coord       array; /* coordinates of match, if found: */                          /* Coord(0) = Col; Coord(1) = Row; */   dcl Curline     fixed; /* holds pointer to current line   */   dcl Linecount   fixed; /* # of lines scanned              */   dcl Col         fixed;   dcl Row         fixed;   dcl (i,j,k)     fixed;   dcl SearchCpos  fixed;   dcl ItemType    fixed;   dcl AbortSearch fixed; /* user hits a key or mouse to abort search */   dcl StrBuf (40) fixed;   Check.For.Update:proc(ptr);  /* pass ptr to NoUpdates */      dcl ptr fixed;		if ((NUM.OF.D50.IN.CHARS != 0                 )		/* if break received from toiminal */		&&  (next.d50.in.char    == ASC.CALL.TERMINATE))		{			core(ptr) = 1;			get.next.d50.in.char();		}		      if ((new.in.char       <>0)  /* and input character typed  */      or  (new.mouse.button  < 0)  /* or button is pressed       */      or  (m$Presses         <>0)) /* or released then pressed   */      then do;         core(ptr) = 1;            /* stop search */      end;		   end Check.For.Update;   AbortSearch = 0;   call FETCH.TABLE.CUR.CELL(GID(DirTable),loc(addr(col)));   if col = (GID(DirTableCols)/CharsPerFile)-1 then do;       /* start with first file on next line */      SearchCpos = 0;                        /* start search at first file */      Curline = ScreenTopLine + row + 1;     /* on next row                */   end;   else do;      SearchCpos = (Col+1) * CharsPerFile;   /* start search at next file */      Curline = ScreenTopLine + row;         /* on this row               */   end;   if Curline ige TotalDisplayLines       /* start at beginning of file */   then Curline = 0;                      /* if user already off end    */   call Seek.To.Line(Curline);            /* position here     */   Curline=GID(Scroll.CurrentLine);   Linecount = 0;      call Draw.Message('Searching for "');    call ps(match); call ps('"...');   call tty_wait;      call Check.For.Update(addr(AbortSearch));   do while (linecount ilt TotalDisplayLines+2) and (AbortSearch=0);	  timeshare_with_host();      if CurItemType = ITEM$EOF then do;  /* end of file reached */         Curline = 0;         call Rezero.Index.File.Ptrs;         end;      if CurItemType = ITEM$EOF then do;         Linecount = TotalDisplayLines+2; /* special case to handle empty files */      end;      else do;         ItemType = Get.Next.Line(StrBuf);  /* get the new line */         if  (match(0)<>0       )         and (ItemType<>ITEM$EOF)         then do;                             /* look for match if search string is not null */            i=Ucase(byte(match,0));            do j=SearchCpos to strbuf(0)-1;    /* check first byte quickly */               if Ucase(Byte(StrBuf,j))=i then do;                  k=1;                  do  while (k   < match (0))                  and       (j+k < strbuf(0))                  and ((ucase(byte(match,k)) = ucase(byte(strbuf,j+k)))                  or  ((byte(match,k)=a.sp) and (byte(strbuf,j+k)=a.score)));                     k=k+1;                  end;                  if k=match(0) then do;  /* equal string found */                     call Draw.Message('Search Completed');                     load j; div CharsPerFile;          /* compute column */                     col = res;                         /* based upon     */                     row = 0;                     if   (Curline Ige ScreenTopLine)                     and  (CurLine Ilt (ScreenTopLine + GID(DirTableRows)))                     then do;                           /* position cursor without scrolling */                        row = Curline - ScreenTopLine;                     end;                     else do;                           /* set this line at top of table */                        call BackUp.To.Prior.Line;      /* back up to match line we just read */                        ScreenTopLine=CurLine;          /* new current position */                     end;                     Coord(0) = Col; Coord(1) = Row;                     return true;                  end;               end;            end;         end;         CurLine    = CurLine   + 1;        /* advance 1 line */         if Curline ige TotalDisplayLines   /* start at beginning of file */         then do;            Curline = 0;                    /* if user already off end    */            call Rezero.Index.File.Ptrs;    /* quick seek to the top      */         end;         linecount  = linecount + 1;   /* count it       */         SearchCpos = 0;               /* start at left  */      end;      call Check.For.Update(addr(AbortSearch));   end;/* call Set.Optical.Error(ERR#NoMatchFound); */   if (AbortSearch <> 0) then do;      call Draw.Message('Search aborted.');   end;   else do;      call Draw.Message('"');       call ps(match);       call ps('" not found.');   end;   call Set.Dirtable.Position(-1,-1);         /* make sure un-highlighted - get next debug event will hightlight it for us */   return false;end Search.DirTable.Forward;Open.Search.Dialog: proc (TopRow) swapable;   dcl TopRow       fixed; /* row of top of panel */   dcl (FirstId,Id) fixed;   dcl Str (40)     fixed; /* a string buffer */   dcl i            fixed;   if GID(SFDDlgGrp)<>(-1) then call Close.Dialog.Panel;   call Set.DlgOrigObj;   call Set.Auto.Allocation.Id(OBJ$Dialog); /* reset id # */   /* TOP LINE OF DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* Enter search ID:                                          [SEARCH]    [CANCEL] */   call Copy.String('Enter search ID:',Str);   FirstId=Define.Label(s#aa,TopRow,0,Str(0),Str);   call Set.Object.Mouse.Access(FirstId,0);   call Set.Object.Attr(FirstId,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);   Id=Define.String(s#aa,TopRow,17,32,0);   call PID(DlgSearchString,Id);   if GID(SearchString)<>0 then do;       /* get prior string */      do i=0 to SearchStringLen-1;         str(i)=GID(SearchString+i);      end;      disable.deposits=1;      call deposit.string(id,str);      disable.deposits=0;   end;   call Copy.String('[SEARCH]',Str);   Id=Define.Label(s#aa,TopRow,58,Str(0),Str);   call PID(DlgGo,Id);      call Copy.String('[CANCEL]',Str);   Id=Define.Label(s#aa,TopRow,70,Str(0),Str);   call PID(DlgAbort,Id);   /* call Set.Object.Arrow.Links(Id,Above,Below,Left,Right)  */   call Set.Object.Arrow.Links(GID(DlgSearchString)  ,-1,-1,-1,GID(DlgGo));   call Set.Object.Arrow.Links(GID(DlgGo)            ,-1,-1,GID(DlgSearchString),GID(DlgAbort));   call Set.Object.Arrow.Links(GID(DlgAbort)         ,-1,-1,GID(DlgGo),-1);   Id=Group.Objects(GRP$Dialog,FirstId,Id,Get#Screen.Event\Get#Ertyp);   call PID(SFDDlgGrp,Id);   call Activate.Group.Objects(GID(SFDDlgGrp));   call Update.Group.Objects  (GID(SFDDlgGrp));   call Select.New.Cur.Obj    (GID(DlgSearchString),-1,-1);end Open.Search.Dialog;/* $PAGE */Get.Search.Response: proc (str) fixed swapable;    dcl str         array;   dcl was.enabled fixed;   dcl i           fixed;   dcl Col         fixed;   dcl Row         fixed;   if GID(FindNextMatch)<>0 then do;   /* continue searching with prev string */      call PID(FindNextMatch,0);      if GID(SearchString)<>0 then do; /* get prev string */         do i=0 to SearchStringLen-1;            str(i)=GID(SearchString+i);         end;         return true;      end;      else do;                         /* prev string was null */         /* old way:         call Draw.Message('Search string is null');         return false;   */      end;   end;   /* must disable for input characters here since they */   /* have to be typed in                               */   was.enabled = get.item.enabled(get.in.char);   get.item.enabled(get.in.char) = 0;   call FETCH.TABLE.CUR.CELL(GID(DirTable),loc(addr(col)));   call Set.Dirtable.Position(row,col); /* highlight current item so user knows where search started */   call Get.Next.Optical.Event;           /* get first event */   do while Exit.My.Screen=0;           /* wait for exit condition */      if Screen.Event.Group=GID(SFDDlgGrp) then do;     /* make sure still in dialog group */         if Screen.Event.Code=Get.Screen.Event then do;            if (Screen.Event.Info=S#MouseSelect)            or (Screen.Event.Info=S#MouseActivate)            or (Screen.Event.Info=S#KeyActivate)            then do;               if (Screen.Event.Id=GID(DlgGo))               or (Screen.Event.Id=GID(DlgAbort)) then do;                  call Set.Term.Attr(ATTR#Normal);                  call Close.Dialog.Panel;                  do i=0 to SearchStringLen-1;     /* get most recent string */                     str(i)=GID(SearchString+i);   /* for possible search    */                  end;                  get.item.enabled(get.in.char) = was.enabled;                  call Set.Dirtable.Position(-1,-1);                   if str(0)=0 then return false;   /* null string */                  else return (Screen.Event.Id=GID(DlgGo));               end;               else call Get.Next.Optical.Event;     /* else just get another event if selecting the string field */            end;            else if (Screen.Event.Id  =GID(DlgSearchString) )            and     ((Screen.Event.Info=S#Deposit          )            or       (Screen.Event.Info=S#KeyActivate      ))            then do;               call Fetch.String(Screen.Event.Id,str);   /* save string in */               do i=0 to SearchStringLen-1;              /* ext memory     */                  call PID(SearchString+i,str(i));       /* for next time  */               end;               call Set.Term.Attr(ATTR#Normal);               call Close.Dialog.Panel;               get.item.enabled(get.in.char) = was.enabled;               call Set.Dirtable.Position(-1,-1); /* SMGR BUG: If user arrows around after typing in a new string,             smgr processes an S#Deposit in string before it processes             the S#ArrowSelect.  Is there a way to look ahead to the             next event on the queue to prevent returning in this case ??             i.e. "if Events.Pending <>0 then don't return" */                if str(0)=0 then return false; /* null string   */               else             return true;  /* do search now */            end;            else call Get.Next.Optical.Event;         end;         else if Screen.Event.Code=Get.Ertyp then do;  /* error message */            if  (GID(SFDErrRow) = 23)   /* use system routine to get both 24 and */            and (GID(SFDErrCol) = 0 )   /* 25 line error codes if possible.      */            then call Handle.System.Error.Codes(Screen.Event.Info);            else if Screen.Event.Info then do;               call Display.Error.Message(Latched.Ertyp,GID(SFDErrRow),GID(SFDErrCol));            end;            call Get.Next.Optical.Event;         end;         else call Get.Next.Optical.Event;   /* get another event */      end;      else if Screen.Event.Group=GID(SFDMiscGrp) then do;         call Set.Term.Attr(ATTR#Normal);         call Close.Dialog.Panel;         get.item.enabled(get.in.char) = was.enabled;         call Set.Dirtable.Position(-1,-1);          return false;  /* let higher event loop take care of this */      end;      else if Screen.Event.Code=Get.Screen.Event then do; /* screen event on some other group */         if (Screen.Event.Info=S#MouseSelect)         or (Screen.Event.Info=S#MouseActivate)         then do; /* user selected some object outside dialog box */            /* Detect Double Click on Search button: */            if  (Screen.Event.Group = GID(WindowGrp     ))            and (Screen.Event.Id    = GID(DirTableSearch))            then do;               call Set.Term.Attr(ATTR#Normal);               call Close.Dialog.Panel;               do i=0 to SearchStringLen-1;     /* get most recent string */                  str(i)=GID(SearchString+i);   /* for possible search    */               end;               get.item.enabled(get.in.char) = was.enabled;               call Set.Dirtable.Position(-1,-1);                if str(0)=0 then return false;   /* null string */               else return true;            end;            call Select.New.Cur.Obj(GID(DlgAbort),-1,-1); /* force back to dialog object */            call Set.Optical.Error(Err#NeedDialogResponse);         end;         call Get.Next.Optical.Event;      end;      else call Get.Next.Optical.Event; /* ignore all other events */   end;   call Set.Term.Attr(ATTR#Normal);   call Close.Dialog.Panel;   get.item.enabled(get.in.char) = was.enabled;   call Set.Dirtable.Position(-1,-1);    return false; /* did not get format command */end Get.Search.Response;Get.Next.Search.Event: proc swapable;   dcl match(SearchStringLen-1) fixed;   dcl (Col,Row)                fixed;   dcl SavedTopLine             fixed;   SavedTopLine = ScreenTopLine;   if (GID(FindNextMatch)=0)      /* wants new search dialog          */   or ((GID(FindNextMatch)<>0)    /* or treat empty FindNext function */   and (GID(SearchString)=0))     /* as wanting new search dialog     */   then do;      call Open.Search.Dialog(GID(SFDDlgRow));  /* open up the dialog */   end;   /* otherwise skip dialog and do the search with the old string */   if Get.Search.Response(match) then do;      if Search.DirTable.Forward (Match,0,loc(addr(Col))) then do;                  /* only redraw display if top line has changed */         if SavedTopLine <> ScreenTopLine then            call Fill.DirTable(true);         call SET.TABLE.CUR.CELL(GID(DirTable),Col,Row);         call Set.Dirtable.Position(-1,-1); /* make sure un-highlighted - get next debug event will hightlight it for us */         call Set.ScrollBar.Pos;            /* keep scroll box in correct position */         call SELECT.NEW.CUR.OBJ(GID(DirTable),Col,Row); /* select table as current object after search (esp on archive screen) */      end;   end;   /* get next event only if user really hit CANCEL (he could've */   /* clicked on a misc object, like the mouse hole)             */   if Screen.Event.Group<>GID(SFDMiscGrp) then      call Get.Next.Optical.Event;end Get.Next.Search.Event;