/*	:SYNSOU:STORMOD:STATE  $TITLE  Code to Save and Restore Window State Variables	*//*Modified:2000/02/27 - TY  - Made changes to indirectly accommodate display of sound file loops*/dcl sflag	lit '0';Dump.Saved.State.Info: proc (Str,WindowId) swapable;	dcl windowid		fixed;	dcl Str				array;	dcl base				fixed;	dcl copy.buf (64)	fixed;	dcl i					fixed;	if sflag=0 then return;	call Save.Cursor;	call Set.Scrolling.Region(1,8);	call cpos(7,0);	call pc(7);	call psr(Str);	call ps('Saved Window State: '); call pnum(windowid,0); call pcr;	wait; wait;	base=windowid*state.stride;	write(mam)=State.Base+shr(Base+S#Device.Mounted,8);	write(mal)=Base+S#Device.Mounted;	call Copy.In(Addr(Copy.Buf(0)),33);	do i=0 to 30;		do case i;			call ps('Device.Mounted: ');			call ps('DirDevice: ');			call ps('SnapFCBs: ');			call ps('FListIndex: ');			call ps('FListSector: ');			call ps('FListWord: ');			call ps('CListIndex: ');			call ps('CListSector: ');			call ps('CListWord: ');			call ps('CListRecLen: ');			call ps('CListCurPos: ');			call ps('CListFiles: ');			call ps('TotalCatCount: ');			call ps('TotalFileCount: ');			call ps('TotalDisplayLines: ');			call ps('ScreenTopLine: ');			call ps('MaxItemChars(0): ');			call ps('MaxItemChars(1): ');			call ps('MaxRowItems(0): ');			call ps('MaxRowItems(1): ');			call ps('FListDisplayLines(0): ');			call ps('FListDisplayLines(1): ');			call ps('CListDisplayLines(0): ');			call ps('CListDisplayLines(1): ');			call ps('CListDisplayLines(2): ');			call ps('SortInfo: ');			call ps('UserSort: ');			call ps('CurItemType: ');			call ps('FunctionInfo: ');			call ps('ShowInfo: ');			call ps('ItemFilter: ');		end;		call pnum(copy.buf(i),0); call pcr;		if (i&3)=3 then do; wait; wait; end;	end;	call pcr; wait; wait;	/*	$PAGE	*/	write(mam)=State.Base+shr(Base+S#ScrollBar,8);	write(mal)=Base+S#ScrollBar;	call Copy.In(Addr(Copy.Buf(0)),16);	do i=0 to 12;		do case i;			call ps('ScrollBar          : ');			call ps('DirTable.Type.Obj  : ');			call ps('DirTable           : ');			call ps('DirTableRows       : ');			call ps('DirTableCols       : ');			call ps('DirTableYPos       : ');			call ps('DirTableXPos       : ');			call ps('DirTableTitle      : ');			call ps('DirTableTop        : ');			call ps('DirTableSearch     : ');			call ps('Scroll.CurrentLine : ');			call ps('Scroll.Index       : ');			call ps('Scroll.CurPos      : ');			call ps('Scroll.Sector      : ');			call ps('Scroll.Word        : ');		end;		call pnum(copy.buf(i),0); call pcr;		if ((27+i)&3)=3 then do; wait; wait; end;	end;	call Set.Scrolling.Region(1,24);	call Restore.Cursor;	call tty_wait;	wait; wait;end Dump.Saved.State.Info;/*	$PAGE	*/Dump.Current.Window.State: proc (Str,windowid) swapable;	dcl WindowId		fixed;	dcl Str				array;	dcl i					fixed;	dcl copy.buf (64)	fixed;	if sflag=0 then return;	call Save.Cursor;	call Set.Scrolling.Region(1,8);	call cpos(7,0);	call pc(7);	call psr(Str);	call ps('Current Window State: '); call pnum(WindowId,0); call pcr;	wait; wait;	call ps('Device.Mounted: ');		call pnum(device.mounted,0);		call pcr;	call ps('DirDevice: ');				call pnum(dirdevice,0);				call pcr;	call ps('SnapFCBs: ');				call pnum(snapfcbs,0);				call pcr;	call ps('FListIndex: ');			call pnum(flistindex,0);			call pcr;	wait; wait;	call ps('FListSector: ');			call pnum(flistsector,0);			call pcr;	call ps('FListWord: ');				call pnum(flistword,0);				call pcr;	call ps('CListIndex: ');			call pnum(clistindex,0);			call pcr;	call ps('CListSector: ');			call pnum(clistsector,0);			call pcr;	wait; wait;	call ps('CListWord: ');				call pnum(clistword,0);				call pcr;	call ps('CListRecLen: ');			call pnum(clistreclen,0);			call pcr;	call ps('CListCurPos: ');			call pnum(clistcurpos,0);			call pcr;	call ps('CListFiles: ');			call pnum(clistfiles,0);			call pcr;	wait; wait;	call ps('TotalCatCount: ');		call pnum(TotalCatCount,0);		call pcr;	call ps('TotalFileCount: ');		call pnum(TotalFileCount,0);		call pcr;	call ps('TotalDisplayLines: ');	call pnum(Totaldisplaylines,0);	call pcr;	call ps('ScreenTopLine: ');		call pnum(screentopline,0);		call pcr;	wait; wait;	call ps('FunctionInfo: ');			call pnum(functioninfo,0);			call pcr;	call ps('ShowInfo: ');				call pnum(showinfo,0);				call pcr;	call ps('SortInfo: ');				call pnum(sortinfo,0);				call pcr;	call ps('UserSort: ');				call pnum(usersort,0);				call pcr;	call ps('ItemFilter: ');			call pnum(itemfilter,0);			call pcr;	wait; wait;	call pcr;	call ps('WindowGrp          : ');	call pnum(GID(WindowGrp),0);				call pcr;	call ps('ScrollBar          : ');	call pnum(GID(ScrollBar),0);				call pcr;	wait; wait;	call ps('DirTable.Type.Obj  : ');	call pnum(GID(DirTable.Type.Obj),0);	call pcr;	call ps('DirTable           : ');	call pnum(GID(DirTable),0);				call pcr;	call ps('DirTableRows       : ');	call pnum(GID(DirTableRows),0);			call pcr;	call ps('DirTableCols       : ');	call pnum(GID(DirTableCols),0);			call pcr;	wait; wait;	call ps('DirTableYPos       : ');	call pnum(GID(DirTableYPos),0);			call pcr;	call ps('DirTableXPos       : ');	call pnum(GID(DirTableXPos),0);			call pcr;	call ps('DirTableTitle      : ');	call pnum(GID(DirTableTitle),0);			call pcr;	call ps('DirTableTop        : ');	call pnum(GID(DirTableTop),0);			call pcr;	call ps('DirTableSearch     : ');	call pnum(GID(DirTableSearch),0);		call pcr;	call ps('Scroll.CurrentLine : ');	call pnum(GID(Scroll.CurrentLine),0);	call pcr;	wait; wait;	call ps('Scroll.Index       : ');	call pnum(GID(Scroll.Index),0);			call pcr;	call ps('Scroll.CurPos      : ');	call pnum(GID(Scroll.CurPos),0);			call pcr;	call ps('Scroll.Sector      : ');	call pnum(GID(Scroll.Sector),0);			call pcr;	call ps('Scroll.Word        : ');	call pnum(GID(Scroll.Word),0);			call pcr;	call Set.Scrolling.Region(1,24);	call Restore.Cursor;	call tty_wait;	wait; wait;end Dump.Current.Window.State;/*	$SUBTITLE	*/Save.Window.State: proc (WindowID) swapable;	/*	saves state info for specified window	*/	dcl WindowID	fixed;	dcl (Base,I)	fixed;	if (debug<>0) then do;	/************* DEBUG *******************/		call dump.saved.state.info('Start of Save.Window.State',windowid);	end;	if WindowId IGE Max.Open.Windows then return;	/*	illegal code	*/	Base=WindowID*State.Stride;	/*	compute ptr into state memory table	*/	/*	Save current values of Internal Memory	*/	/*	State vars in State Memory Table			*/	write(mam)=State.Base+shr(Base+S#Device.Mounted,8);	write(mal)=Base+S#Device.Mounted;	write("313")=Addr(First.State.Var);	do while read("313") ile Addr(Last.State.Var);		write(mdi)=read("373");	end;	/*	Copy External Memory State Variables into Temp Buffer	*/	write("313")=addr(Copy.Buf(0));	call GID(ScrollBar);	do i=ScrollBar to DirTablePrint;		write("373")=read(mdi);	end;	call GID(Scroll.CurrentLine);	do i=Scroll.CurrentLine to Scroll.Word;		write("373")=read(mdi);	end;	/*	Write Temp Buffer to State Memory Table	*/	write("313")=addr(Copy.Buf(0));	write(mam)=State.Base+shr(Base+S#ScrollBar,8);	write(mal)=Base+S#ScrollBar;	do i=S#ScrollBar to S#Scroll.Word;		write(mdi)=read("373");	end;	if (debug<>0) then do;	/************* DEBUG *******************/		call dump.saved.state.info('End of Save.Window.State',windowid);	end;end Save.Window.State;/*	$SUBTITLE	*/Activate.Window: proc (WindowID) swapable;	/*	reloads state info for specified window	*/	dcl WindowID	fixed;	dcl (Base,I)	fixed;	if (debug<>0) then do;	/************* DEBUG *******************/		call Dump.Current.Window.State('Start of Activate.Window',activewindowid);	end;	if WindowId IGE Max.Open.Windows	then return;	/*	illegal code	*/	if WindowId  =  ActiveWindowId	then return;	/*	window is already open	*/	ActiveWindowId=WindowId;	/*	will be using a different window	*/	call PID(WindowGrp,GRP$Window+WindowId);	/*	and set up group id for active window	*/	Base=WindowID*State.Stride;	/*	compute base ptr into state memory table	*/	/*	Reload Internal Memory State vars with new values	*/	write(mam)=State.Base+shr(Base+S#Device.Mounted,8);	write(mal)=Base+S#Device.Mounted;	write("313")=Addr(First.State.Var);	do while read("313") ile Addr(Last.State.Var);		write("373")=read(mdi);	end;	/*	Copy Info from State Memory Table into Temp Buffer	*/	write(mam)=State.Base+shr(Base+S#ScrollBar,8);	write(mal)=Base+S#ScrollBar;	write("313")=addr(Copy.Buf(0));	do i=S#ScrollBar to S#Scroll.Word;		write("373")=read(mdi);	end;	/*	Copy from Temp Buffer to External Memory State Vars	*/	call GID(ScrollBar);			/*	set ext mem ptrs	*/	write("313")=addr(Copy.Buf(0));	do i=ScrollBar to DirTablePrint;		write(mdi)=read("373");	end;	call GID(Scroll.CurrentLine);	/*	set ext mem ptrs to next section of state info	*/	do i=Scroll.CurrentLine to Scroll.Word;		write(mdi)=read("373");	end;	if (debug<>0) then do;	/************* DEBUG *******************/		call Dump.Current.Window.State('End of Activate.Window',windowid);	end;end Activate.Window;/*	$SUBTITLE	*/dcl Do.Selection.HighLighting proc (fixed,fixed,fixed) recursive;	/*	unhighlight current position	*/Select.Active.Window: proc (NewWindowId) public swapable;	dcl NewWindowId	fixed;/*	this proc may be used to refresh the active window,		*//*	(i.e. when poly memory changes and it's being displayed)	*//*	so don't use following statement:  ??							*/	if NewWindowId = ActiveWindowId then return true;	if (OpenWindowBits&Bits(NewWindowId))<>0 then do;	/*	window is open	*/		if ActiveWindowId<>(-1) then do;			call Do.Selection.HighLighting(GID(DirTableYPos),GID(DirTableXPos),0);	/*	unhighlight current position	*/			call Save.Window.State(ActiveWindowId);		end;		call Activate.Window(NewWindowId);		/*	added 3/28/88 - SGS	*/		call Select.New.Cur.Obj(GID(DirTable),-1,-1);		call Do.Selection.HighLighting(GID(DirTableYPos),GID(DirTableXPos),1);	/*	highlight current position	*/		return true;	end;	return false;end Select.Active.Window;dcl Compute.SortFormat proc (fixed,fixed) recursive;dcl Find.Entry.At.Cursor.Position proc (array) recursive;dcl Store.DC.Top.Pointers proc (array,fixed,fixed) recursive;dcl Store.DC.Cursor.Pointers proc (array,fixed,fixed) recursive;dcl Get.Index.And.Offset proc (array) recursive;/*	Saves pointers to both the Top entry and the Cursor entry	*//*	Assumes the window displaying Device is active					*/SaveDisplayPos: proc (Device,Row) public swapable;	dcl Device	fixed;	dcl Row		fixed;	/*	the first entry on this row will be			*/								/*	used as the starting point when redrawing	*/								/*	the screen											*/	dcl (TopIndex,TopOffset)			fixed;	dcl (CursorIndex,CursorOffset)	fixed;	call GetListPos(Row);	call Get.Index.And.Offset(loc(addr(TopIndex)));	call Store.DC.Top.Pointers(loc(addr(TopIndex)),Device,Compute.SortFormat(SortInfo,ItemFilter));	call Find.Entry.At.Cursor.Position(loc(addr(CursorIndex)));	call Store.DC.Cursor.Pointers(loc(addr(CursorIndex)),Device,Compute.SortFormat(SortInfo,ItemFilter));	call pid(sfr.dirdevice, dirdevice);end SaveDisplayPos;