/* SBAR   $TITLE Scroll Bar Event Handler   Modified:   11/12/87 - MWH - Make timer comparisons unsigned to fix "30 sec hang"   */dcl Compute.ScrollBar.Line proc recursive;Set.ScrollBar.Pos: proc public swapable;   dcl Percent  fixed;   dcl SBScreenTopLine fixed;   Percent=ScreenTopLine*1000/(TotalDisplayLines-1);   Disable.Deposits=true;   call Deposit.Scroll.Bar(GID(ScrollBar),Percent);   /* Mapping between box position and display lines may have */   /* resolution problems.                                    */   if (Compute.ScrollBar.Line <> ScreenTopLine) then do;      /* remember the display line that should be mapped to the sbbox */      call Deposit.Object.Info(GID(ScrollBar),O#UserData,ScreenTopLine);    end;   else do; /* sbbox position maps to correct display line */      call Deposit.Object.Info(GID(ScrollBar),O#UserData,-1);   end;   Disable.Deposits=false;   call Update.Object(GID(ScrollBar));end Set.ScrollBar.Pos;Handle.ScrollBar.RealTime.Step: proc (Direction) swapable;   dcl Direction      fixed; /* "+x" means increment, "-x" means decrement */   dcl MouseActivity  fixed;   dcl NextScrollTime fixed;   Scroll.One.Line: proc (Direction);      dcl Direction fixed;      if      Direction>0 then call Scroll.DirTable.Forward (1);      else if Direction<0 then call Scroll.DirTable.Backward(1);      call Set.ScrollBar.Pos;            /* and reposition scroll box to new position */      call Update.Object(GID(DirTable)); /* make sure new items get displayed on screen */   end Scroll.One.Line;   call Scroll.One.Line(Direction);       /* do the first step */	run.syn.tty.wait();	   NextScrollTime=Real.Milliseconds;      /* start repeating right away */	// Here we are squeezed.  We would like to run at DTask time so we could handle scrolling	// from a termulator over the network (which, if on the same machine, would be hogging CPU	// while mouse down).  On the other hand, that might allow us to scroll several times	// before we saw a mouse release (if the screen redraw on the scroll took a while).		// We will improve things by waiting for the TTY output to finish before scrolling	// again, as well as throttling it...	   do while Direction<>0;			Chill.Out.And.Run.Syn();      Check.Next.Event();              	  			/* do another system scan */      if New.Mouse.Button<>0 then do;     			/* mouse button activity */         if New.Mouse.Button=2 then Direction=0; 	/* pending button release */         New.Mouse.Button=0;      end;      else if (Real.Milliseconds-NextScrollTime) IGE 100 then do;         NextScrollTime=Real.Milliseconds;   /* do it again asap */         call Scroll.One.Line(Direction);    /* step again */			run.syn.tty.wait();      end;   end;end Handle.ScrollBar.RealTime.Step;/* $SUBTITLE */Display.Current.ScrollBox.Position: proc (Line,Buf) swapable;   dcl Line     fixed; /* which line to give status for */   dcl Buf      array; /* string buffer */   dcl Item     fixed;   dcl SavePos  fixed;   dcl SaveInfo fixed;   dcl (X,Y)    fixed;   dcl ActualLine fixed;   if Line=GID(LastSBBoxMoveLine) then return;   /* Make sure sbbox really moved and we didn't just force a status line */   if (GID(LastSBBoxMoveLine)<> -1) then call PID(BoxMoved,true);   call PID(LastSBBoxMoveLine,Line);      /* save new position */   /* If sbbox actually mapped to a line different than the one */   /* passed as an argument, use the former.                    */   ActualLine = Fetch.Object.Info(GID(ScrollBar),O#UserData);   if ((not GID(BoxMoved)) and (ActualLine <> -1)) then do;      Line=ActualLine;   end;   if (SortInfo  =  SORT$Filename)        /* looking at filenames only */   or (ItemFilter=FILTER$Filename)        /* or categories only        */   then do;      call Get.Line(Line,Buf);   end;   else do;                               /* looking at categories & filenames */      Item=Seek.To.Line(Line);      if Item=ITEM$Filename then do;      /* get category name that goes with this line */         SavePos=CListCurPos;             /* save current offset into category */         call SetCListPos(CListIndex,-1); /* step to category for this file */         call Get.Next.Line(Buf);         /* build status line */         call SetCListPos(CListIndex,SavePos); /* reposition to desired line */         call Append.To.Str(Buf,'-->');         call Append.Current.CatList.Item(Buf,GID(DirTableCols));      end;      else call Get.Next.Line(Buf);      /* just get the category name */   end;   if Locate.Object(GID(DirTable)) then do;    /* display status line */      Y=Read.Object(Object.Ptr+O#Trans.Row)-2; /* put on line above table */      X=Read.Object(Object.Ptr+O#Trans.Col);   /* at left edge of table */      call Display.Optical.Status(Buf,Y,X);   end;end Display.Current.ScrollBox.Position;/* $SUBTITLE */Compute.ScrollBar.Line: proc fixed swapable; /* computes line position base on scroll box pos */   dcl Line       fixed;   dcl MaxLines   fixed;   dcl ActualLine fixed;   MaxLines=GID(DirTableRows);   Line=Fetch.Scroll.Bar(GID(ScrollBar));   if debug igt 1 then do;      call cpos(2,0); call erase.to.end.of.line;      call ps('Scroll Bar Percent: '); call pnum(line,1);   end;   if TotalDisplayLines ile MaxLines   then Line=0;   else Line=Line*(TotalDisplayLines-1)/1000;   if debug igt 1 then do;      call ps('   Line Number: '); call pnum(line,0);      call tty_wait;   end;   return Line;end Compute.ScrollBar.Line;/* $SUBTITLE */Get.Next.ScrollBar.Event: proc public swapable;   dcl Line        fixed;   dcl SavedFilter fixed;   dcl StrBuf (40) fixed;   do while Exit.My.Screen=0;           /* wait for exit condition */      if Screen.Event.Group<>GID(WindowGrp) then return;      if Screen.Event.Code=Get.Screen.Event then do;         if Screen.Event.Id<>GID(ScrollBar) then return;         if TotalDisplayLines igt GID(DirTableRows) then do; /* can do scrolling functions */            if (Screen.Event.Info=S#SBBoxMove) then do;               Line=Compute.ScrollBar.Line;   /* current top line */               call Display.Current.ScrollBox.Position(Line,StrBuf);            end;            else if Screen.Event.Info=S#MouseSelect then do;               call PID(LastSBBoxMoveLine,-1);               call PID(BoxMoved,false);               call GetListPos(0);               call SaveListPos(ScrollMem#);               call PID(Scroll.CurrentLine,ScreenTopLine);            end;            else if Screen.Event.Info=S#Deposit then do;               Line=Compute.ScrollBar.Line;   /* line to put at top of screen */               if GID(BoxMoved) then do;                  /* sbbox maps to correct display line */                  call Deposit.Object.Info(GID(ScrollBar),O#UserData,-1);               end;               else do; /* recall old display line */                  if (Fetch.Object.Info(GID(ScrollBar),O#UserData)<>-1) then                  Line=Fetch.Object.Info(GID(ScrollBar),O#UserData);               end;               call Scroll.To.Line(Line);     /* do it */               call Erase.Optical.Status;             /* get rid of status line */            end;            else if Screen.Event.Info=S#SBArrowForward then do; /* increment */               call Handle.ScrollBar.RealTime.Step(+1);            end;            else if Screen.Event.Info=S#SBArrowBack then do; /* decrement */               call Handle.ScrollBar.RealTime.Step(-1);            end;            else if Screen.Event.Info=S#SBPageForward then do;               call Page.DirTable.Forward;               call Set.ScrollBar.Pos;                    /* put box in correct pos */            end;            else if Screen.Event.Info=S#SBPageBack then do;               call Page.DirTable.Backward;               call Set.ScrollBar.Pos;                    /* put box in correct pos */            end;         end;         if debug igt 0 then do;            call cpos(2,0); call erase.to.end.of.line;            call ps('ScreenTopLine:'); call pnum(ScreenTopLine,0);            call ps(' ScrollBoxPercent: '); call pnum(Fetch.Scroll.Bar(GID(ScrollBar)),0);            call tty_wait;         end;         call Get.Next.Optical.Event;         /* have used up event, get another */      end;      else call Get.Next.Optical.Event;       /* get the next event to handle */   end;end Get.Next.ScrollBar.Event;