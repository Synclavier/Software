/*	:SYNSOU:STORMOD:ARC-CTRL  $TITLE  Define and Handle Routines for Table Control Objects	*//*	MODIFIED:2000/02/27 - TY  - Modified Get.DirModeSwitch.Event() to indirectly accommodate display of sound file loops.1990/10/19 - cj  - added code to update optical window on media change1989/05/02 - TSS - Merged changes for Optical disk to DTD transfer project*/Open.OptWindow.Control.Objects: proc (LeftX,TopY,NumLines,CharWidth) swapable;	dcl (LeftX,TopY,NumLines,CharWidth)	fixed;	dcl TStr	(20)		fixed;	dcl (FirstId,Id)	fixed;	dcl Icon	(32)		fixed;	/*	watch out here!!! don't get too big!!!	*/	dcl (X,Y)			fixed;	dcl OptFormatXOffs	lit '12';	dcl MR13I				lit 'write("373")';	call Set.Auto.Allocation.Id(OBJ$OptCtrl);	/*	reset id #	*/	/*	build a 3 sided fancy frame icon	*/	X=(CharWidth+3)*100+30; Y=-200;	write("313")=Addr(Icon(0));	mr13i=O#ICON.Plot;	 mr13i=0;	  mr13i=Y;	mr13i=O#ICON.Plot;	 mr13i=X;	  mr13i=Y;	mr13i=O#ICON.Plot;	 mr13i=X;	  mr13i=0;	mr13i=O#ICON.Connect; mr13i=	  0; mr13i=-100; mr13i=		X; mr13i=-100;	mr13i=O#ICON.Connect; mr13i=+1150; mr13i=0;	  mr13i=+1150; mr13i=-100;	mr13i=O#ICON.Connect; mr13i=+3050; mr13i=0;	  mr13i=+3050; mr13i=-100;	mr13i=O#ICON.End;	FirstId=Define.Graphics.Icon(s#aa,LeftX*100-25,(TopY+NumLines-1)*100,0,Icon);	Id=Define.Label(s#aa,TopY+NumLines,LeftX,12,'Load Volume');	call Set.Object.Action(Id,O#ACT.Prev.Obj,true);	/*	return to prev object	*/	call PID(MountButton,Id);	Id=Define.Switch(s#aa,TopY+NumLines,LeftX+OptFormatXOffs,18,0,'Categories Only|Categories & Files|Files Only');	call PID(OptFormatSwitchId,Id);	Id=Define.Label(s#aa,TopY+NumLines+1,LeftX,CharWidth+3,'');	call Set.Object.Action(Id,O#ACT.Update.On.Dep,true);	call Set.Object.Mouse.Access(Id,0);		/*	cannot select this one	*/	call PID(StatsLabel,Id);					/*	save id of statistics label	*/	Id=Group.Objects(GRP$OptCtrl,FirstId,Id,Get#Screen.Event);	call PID(OptCtrlGrp,Id);	call Activate.Group.Objects(GID(OptCtrlGrp));	call Update.Group.Objects	(GID(OptCtrlGrp));	call Display.Optical.Statistics(TStr);	/*	shows how much of optical disk is left	*/	Disable.Deposits=true;		call Deposit.Label(GID(StatsLabel),TStr);	Disable.Deposits=false;end Open.OptWindow.Control.Objects;/*	$SUBTITLE	*/Build.Device.Switch.String.And.Table: proc (SwitchStr)	fixed swapable;	dcl SwitchStr		array;	dcl DevList			data (PolyCacheDev,PolyMemDev,1,6,7,2,3,4,5,-1);	dcl (Dev,NewDev)	fixed;	dcl NumDevices		fixed;	dcl AddDevice		boolean;	dcl Len				fixed;	dcl LongestLen		fixed;	dcl Str	(16)		fixed;	/*	used to hold device names	*/	LongestLen=0;	NumDevices=0;	Dev		 =0;	/*	start with 1st device in list	*/	do while (DevList(Dev)<>(-1));	/*	loop through possible devices	*/		NewDev=DevList(Dev);		AddDevice=False;					/*	assume we will not add the next device to menu	*/		if NewDev<=LaserDev then do;	/*	a real disk device	*/			if Find_Device(NewDev)<>0			then AddDevice=true;			/*	and drive exists	*/		end;		else if inc.poly & (Com16(0,PolyAmount)<>LW#IEQ) then do;	/*	have some poly	*/			if ((NewDev=PolyCacheDev) and (Cache.Secs<>0))			or ((NewDev=PolyMemDev							  ))			then AddDevice=true;		end;		if AddDevice then do;			/*	device exists	*/			if (NewDev			<>1)		/*	not the current catalog device	*/			or (core(LOC.CCNM)<>0)		/*	or actually in a subcatalog	*/			then do;							/*	put new device onto menu		*/				call PID(DeviceSwitchTable+NumDevices,NewDev);	/*	save device corresponding to this switch pos	*/				NumDevices=NumDevices+1;				Len=Get.Device.Name(NewDev,Str);				if Len IGT LongestLen then LongestLen=Len;				call Append.To.Str(SwitchStr,Str);				call AppendC(SwitchStr,"174");			end;		end;		Dev=Dev+1;	/*	step to next device in list	*/	end;	call PID(DeviceSwitchTableLen,NumDevices);	if Byte(SwitchStr,SwitchStr(0)-1)="174"	/*	get rid of trailing "|"	*/	then SwitchStr(0)=SwitchStr(0)-1;	return LongestLen;end Build.Device.Switch.String.And.Table;/*	$SUBTITLE	*/Define.Device.Switch: proc (Id,TopY,LeftX)	fixed swapable;	dcl Id					fixed;	dcl (TopY,LeftX)		fixed;	dcl LongestSwitch		fixed;	dcl SwitchStr	(64)	fixed;	dcl DevSwitchXOffs	lit '16';	/*	where to put the switch	*/	LongestSwitch=Build.Device.Switch.String.And.Table(SwitchStr);	Id=Define.Switch(Id,TopY,LeftX,16/*	LongestSwitch	*/,0,SwitchStr);	if Id<>0 then do;		call Set.Object.Attr(Id,0,ATTR#Normal);		call Set.Object.Attr(Id,1,ATTR#Normal\ATTR#AltIntensity\ATTR#Reverse);		/*	reset the region to include the "CONTENTS OF:" label	*/		call Locate.Object(Id);		call Write.Object(Object.Ptr+O#ULX,Read.Object(Object.Ptr+O#ULX)-gpix.x((DevSwitchXOffs-3)*100));	end;	return Id;end Define.Device.Switch;ReDefine.Device.Switch: proc swapable;	/*	used after catalog enter or optical disk mount	*/	dcl Id				fixed;	dcl (TopY,LeftX)	fixed;	Id=GID(DeviceSwitchId);	/*	look up id of existing switch	*/	if Locate.Object(Id) then do;	/*	switch does in fact exist	*/		TopY	=Read.Object(Object.Ptr+O#Trans.Row);		LeftX	=Read.Object(Object.Ptr+O#Trans.Col);		call Erase.Object   (Id);	/*	remove from display	*/		call UnDefine.Object(Id);	/*	free up its memory	*/		Id=Define.Device.Switch(Id,TopY,LeftX);		call Activate.Object.Range(Id,Id);		call Update.Object		  (Id);	end;end ReDefine.Device.Switch;/*	$SUBTITLE	*/Open.DirWindow.Control.Objects: proc (LeftX,TopY,NumLines,CharWidth) swapable;	dcl (LeftX,TopY,NumLines,CharWidth)	fixed;	dcl (FirstId,Id)		fixed;	dcl LongestSwitch		fixed;	dcl SwitchStr	(64)	fixed;	dcl DevSwitchXOffs	lit '16';	/*	where to put the switch	*/	dcl Icon			(32)	fixed;		/*	watch out here!!! don't get too big!!!	*/	dcl (X,Y)				fixed;	dcl MR13I				lit 'write("373")';	call Set.Auto.Allocation.Id(OBJ$DirCtrl);	/*	reset id #	*/	FirstId=Define.Device.Switch(s#aa,TopY,LeftX+DevSwitchXOffs);	call PID(DeviceSwitchId,FirstId);	Id=Define.Grab.Icon(s#aa,LeftX*100,TopY*100+10);	call PID(DeviceGrabIcon,Id);	/*	build a 3 sided fancy frame icon	*/	X=(CharWidth+3)*100+30; Y=-200;	write("313")=Addr(Icon(0));	mr13i=O#ICON.Plot;	 mr13i=0;	  mr13i=Y;	mr13i=O#ICON.Plot;	 mr13i=X;	  mr13i=Y;	mr13i=O#ICON.Plot;	 mr13i=X;	  mr13i=0;	mr13i=O#ICON.Connect; mr13i=	  0; mr13i=-100; mr13i=		X; mr13i=-100;	mr13i=O#ICON.Connect; mr13i=+3050; mr13i=   0; mr13i=+3050; mr13i=-100;	mr13i=O#ICON.Connect; mr13i=+3350; mr13i=-100; mr13i=+3350; mr13i=-200;	mr13i=O#ICON.End;	Id=Define.Graphics.Icon(s#aa,LeftX*100-25,(TopY+NumLines-1)*100,0,Icon);	Id=Define.Switch(s#aa,TopY+NumLines,LeftX,30,0,		'SHOW: Names Only|SHOW: Names,Captions|SHOW: Names,SECONDS,Captions|SHOW: Names,MEGABYTES,Captions|SHOW: Names,SECTORS,Captions');	call PID(DirFormatSwitchId,Id);	Id=Define.Switch(s#aa,TopY+NumLines+1,LeftX,33,0,		'FUNCTION: None|FUNCTION: Recall Files|FUNCTION: Recall & Audition Files');	call PID(DirFunctionSwitchId,Id);	Id=Group.Objects(GRP$DirCtrl,FirstId,Id,Get#Screen.Event|Get#Poly.Contents);	call PID(DirCtrlGrp,Id);	call Activate.Group.Objects(GID(DirCtrlGrp));	call Update.Group.Objects	(GID(DirCtrlGrp));end Open.DirWindow.Control.Objects;/*	$SUBTITLE	*/Get.OptFormatSwitch.Event: proc swapable;	dcl (Switch,Filter)	fixed;	dcl Title	(32)		fixed;	dcl pos					fixed;	dcl restore				boolean;	dcl NewSort				fixed;	dcl NewFilter			fixed;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(OptCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if Screen.Event.Id<>GID(OptFormatSwitchId) then return;			if (Screen.Event.Info=S#Deposit)			then do;									/*	toggle display mode	*/				do case (Fetch.Switch(GID(OptFormatSwitchId)));					call Change.Window.Sort.Format(OptWindowId,SORT$Category,FILTER$Filename);					call Change.Window.Sort.Format(OptWindowId,SORT$Category,FILTER$None);					call Change.Window.Sort.Format(OptWindowId,SORT$Filename,FILTER$None);				end;				call Refresh.OptWindow.Title(OptWindowId);			end;			call Get.Next.Optical.Event;		end;		else call Get.Next.Optical.Event;	/*	get another event	*/	end;end Get.OptFormatSwitch.Event;Process.Mount.Button: proc swapable;	dcl Title (32)	fixed;	if Activate.Optical(O#FormatDialog|O#UpdateDialog|O#AutoVolChange)	then do;		call Reset.DC.Pointers(LaserDev);		Optical.Disk.Ready=0;					/*	reset flag	*/		call Display.Optical.Statistics(Title);	/*	show some info about current volume	*/		Disable.Deposits=true;		call Deposit.Label(GID(StatsLabel),Title);		Disable.Deposits=false;		call Select.Active.Window(OptWindowId);		call Mount.New.Device(DirDevice);		call Refresh.OptWindow.Title(OptWindowId);		call Fill.DirTable(true);	end;end Process.Mount.Button;Get.MountButton.Event: proc swapable;	do while Exit.My.Screen=0;				/*	wait for exit condition	*/		if Screen.Event.Group<>GID(OptCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if Screen.Event.Id<>GID(MountButton) then return;			if (Screen.Event.Info=S#MouseSelect)			or (Screen.Event.Info=S#MouseActivate)			or (Screen.Event.Info=S#KeyActivate)			then do;				call Process.Mount.Button;			end;			call Get.Next.Optical.Event;		end;		else call Get.Next.Optical.Event;	/*	get another event	*/	end;end Get.MountButton.Event;/*	$SUBTITLE	*/dcl Open.Action.Buttons proc(fixed) recursive;	/*	puts up command buttons	*/Get.DeviceSwitch.Event: proc swapable;	dcl CatName (16)	fixed;	dcl NewDev			fixed;	dcl Ok				fixed;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(DirCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if  (Screen.Event.Id<>GID(DeviceSwitchId))			and (Screen.Event.Id<>GID(DeviceGrabIcon))			then return;			if Screen.Event.Id=GID(DeviceSwitchId) then do;				if Screen.Event.Info=S#Deposit then do;	/*	switch change	*/					NewDev=GID(DeviceSwitchTable+Fetch.Switch(GID(DeviceSwitchId)));					call Select.New.Window.Device(DirWindowId,NewDev);				end;			end;			else if Screen.Event.Id=GID(DeviceGrabIcon) then do;				if (Screen.Event.Info=S#MouseSelect)				or (Screen.Event.Info=S#MouseActivate)				then do;					if ActiveWindowId<>DirWindowId					then call Select.Active.Window(DirWindowId);					NewDev=DirDevice;				/*	store dir window device # in temp	*/					if NewDev<>PolyCacheDev then do;						if GID(MenuModified) then do;	/*	have made a change to menu	*/							call Open.Info.Panel.Dialog(DialogRow,DLG#MenuChange);							if Get.Dialog.Response then do;								Ok=true;								call PID(MenuModified,false);	/*	reset flag	*/							end;							else Ok=false;						end;						else Ok=true;						if Ok then do;							if NewDev=1							then call Copy.String('Current Catalog',CatName);							else call Get.Device.Name(NewDev,CatName);							if NewDev<>PolyMemDev then do;								if Read_Catalog('',NewDev) then do;									call PID(FileOnSource,true);			/*	catalog exists	*/									if C#Dir_Size=256									then call PID(FileType,T#Subc);		/*	save type of current object	*/									else call PID(FileType,T#LSubc);									call PID(FileDevice	,NewDev);		/*	device when enter happened	*/									call PID(FileAddress	,C#MS_Sector); write(md)=C#LS_Sector;	/*	save abs addr of catalog	*/									call PID(FileLength	,C#MS_Length); write(md)=C#LS_Length;	/*	and length of catalog		*/								end;								else call PID(FileOnSource,false);		/*	system error??	*/							end;							else if inc.poly then do;								call PID(FileOnSource,true);				/*	catalog exists	*/								call PID(FileType,T#LSubc);				/*	????	*/								call PID(FileDevice	,NewDev);								call PID(FileAddress	,0); write(md)=0;								call PID(FileLength	,0); write(md)=0;							end;							Disable.Deposits=true;								call Deposit.Label (GID(SFNameLabel),'Subcatalog:');								call Deposit.String(GID(	  SFName),CatName);								call Deposit.String(GID(SavedSFName),CatName);							Disable.Deposits=false;							call Open.Action.Buttons(CatalogMode);		/*	display STORE CATALOG button	*/						end;					end;					else call Set.Optical.Error(ERR#CacheStoreNotAllowed);				end;			end;			call Get.Next.Optical.Event;		end;		else call Get.Next.Optical.Event;	/*	get another event	*/	end;end Get.DeviceSwitch.Event;Get.DirModeSwitch.Event: proc swapable;	dcl Info	fixed;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(DirCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if  (Screen.Event.Id<>GID(DirFormatSwitchId))			and (Screen.Event.Id<>GID(DirFunctionSwitchId))			then return;			if Screen.Event.Info=S#Deposit then do;	/*	switch change	*/				if Screen.Event.Id=GID(DirFormatSwitchId) then do;					do case Fetch.Switch(GID(DirFormatSwitchId));						Info=INFO$Filename;						Info=INFO$Filename|INFO$Caption;						Info=INFO$Filename|INFO$Caption|INFO$Second;						Info=INFO$Filename|INFO$Caption|INFO$MByte;						Info=INFO$Filename|INFO$Caption|INFO$Sector;					end;					if ActiveWindowId<>DirWindowId					then call Select.Active.Window(DirWindowId);					call SaveDisplayPos(DirDevice,0);					call Change.Window.Info.Format(DirWindowId,Info);					if ActiveWindowId<>OptWindowId					then call Select.Active.Window(OptWindowId);					call SaveDisplayPos(LaserDev,0);					call Change.Window.Info.Format(OptWindowId,Info);					call Refresh.OptWindow.Title(OptWindowId);				end;				else do;	/*	function switch event	*/					do case Fetch.Switch(GID(DirFunctionSwitchId));						Info = FunctionInfo &(not (INFO$Recall|INFO$Audition));	//	case 0: Recall off, Audition off						Info = (FunctionInfo&(not INFO$Audition))|INFO$Recall;	//	case 1: Recall on,  Audition off						Info = FunctionInfo|(INFO$Recall|INFO$Audition);			//	case 2: Recall on,  Audition on					end;					call Change.Window.Function.Format(DirWindowId,Info);					call Change.Window.Function.Format(OptWindowId,Info);				end;			end;			call Get.Next.Optical.Event;		end;		else call Get.Next.Optical.Event;	/*	get another event	*/	end;end Get.DirModeSwitch.Event;/*	$SUBTITLE	*/Get.Next.OptWindow.Control.Event: proc swapable;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(OptCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if Screen.Event.Id=GID(MountButton)			then call Get.MountButton.Event;			else if Screen.Event.Id=GID(OptFormatSwitchId)			then call Get.OptFormatSwitch.Event;			else call Get.Next.Optical.Event;		end;		else call Get.Next.Optical.Event;	/*	get another event	*/	end;end Get.Next.OptWindow.Control.Event;Get.Next.DirWindow.Control.Event: proc swapable;	dcl priorwindow	fixed;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(DirCtrlGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if (Screen.Event.Id=GID(DeviceSwitchId))			or (Screen.Event.Id=GID(DeviceGrabIcon))			then call Get.DeviceSwitch.Event;			else if (Screen.Event.Id=GID(DirFormatSwitchId))			or		  (Screen.Event.Id=GID(DirFunctionSwitchId))			then call Get.DirModeSwitch.Event;			else call Get.Next.Optical.Event;		end;		else if Screen.Event.Code=Get.Poly.Contents then do;	/*	memory has changed in poly	*/			if (Screen.Event.Info & 1) <> 0 then do;				if ActiveWindowId<>DirWindowId then do;					call Select.Active.Window(DirWindowId);					priorwindow = 1;				end;				if DirDevice=PolyMemDev then do;	/*	need to refresh info	*/					call Select.New.Window.Device(DirWindowId,DirDevice);				end;				if priorwindow<>0 then do;					call Select.Active.Window(OptWindowId);					priorwindow = 0;				end;			end;			else if (Screen.Event.Info & (4\8)) <> 0 then do;				if ActiveWindowId<>OptWindowId then do;					call Select.Active.Window(OptWindowId);					priorwindow = 1;				end;				if DirDevice=LaserDev then do;	/*	need to refresh info	*/					call Process.Mount.Button;				end;				if priorwindow<>0 then do;					call Select.Active.Window(DirWindowId);					priorwindow = 0;				end;			end;			call Get.Next.Optical.Event;			/*	get next event		*/		end;		else call Get.Next.Optical.Event;		/*	get another event	*/	end;end Get.Next.DirWindow.Control.Event;Get.Next.MultiWindow.Control.Event: proc swapable;	dcl SelectedObject		fixed;	dcl OldGroupId				fixed;	dcl OldObjectId			fixed;	dcl OldWindowId			fixed;	dcl Restore.Attribute	boolean;	dcl Temp.Label				fixed;	dcl (Col,Row)				fixed;	if ((Screen.Event.Group <> GID(DirCtrlGrp))	and (Screen.Event.Group <> GID(OptCtrlGrp)))	then return;	OldWindowId	= -1;	Temp.Label	= -1;	if (Screen.Event.Id=GID(DeviceSwitchId))	or (Screen.Event.Id=GID(DirFormatSwitchId))	or (Screen.Event.Id=GID(DirFunctionSwitchId))	or (Screen.Event.Id=GID(OptFormatSwitchId))	then do;		if (Screen.Event.Info = S#MouseSelect)		or (Screen.Event.Info = S#MouseActivate)		then do;			/*	will return to temp label when done with switch	*/			OldObjectId = Prev.Obj.Id;			if Prev.Obj.Id = GID(DirTable) then				OldWindowId = ActiveWindowId;	/*	remember which window	*/			else				OldWindowId = -1;					/*	or non-window object	*/			call Set.Auto.Allocation.Id(OBJ$Temp);			Temp.Label	= Define.Label(S#AA,24,0,1,' ');	/*	dummy object	*/			call Set.Object.Mouse.Access(Temp.Label,0);			call PID(TempGrp,Group.Objects(GRP$Temp,Temp.Label,Temp.Label,Get#Screen.Event));			Prev.Obj.Id	= Temp.Label;		end;	end;	if (Screen.Event.Group=GID(DirCtrlGrp)) then		call Get.Next.DirWindow.Control.Event;	else if (Screen.Event.Group=GID(OptCtrlGrp)) then		call Get.Next.OptWindow.Control.Event;	do while Exit.My.Screen=0;					/*	wait for exit condition	*/		if Screen.Event.Group<>GID(TempGrp) then return;		if Screen.Event.Code=Get.Screen.Event then do;			if Screen.Event.Id = Temp.Label then do;				if (Screen.Event.Info=S#ArrowSelect) then do;					/*	undefine the temp label	*/					call Erase.Group.Objects	(GID(TempGrp));					call Undefine.Group.Objects(GID(TempGrp));					call Ungroup.Objects			(GID(TempGrp));					call PID(TempGrp,-1);		/*	no longer defined	*/					if OldWindowId <> -1 then do;						/*	remap to an arrow select in proper window	*/						call Select.Active.Window(OldWindowId);						call Fetch.Table.Cur.Cell(GID(DirTable),Loc(Addr(Col)));						call Select.New.Cur.Obj(GID(DirTable),Col,Row);						Screen.Event.Group=GID(WindowGrp);						Screen.Event.Id	=GID(DirTable);						Screen.Event.Code	=Get.Screen.Event;						Screen.Event.Info	=S#ArrowSelect;						Screen.Event.Table.Col=Col;						Screen.Event.Table.Row=Row;					end;					else do;	/*	return to non-window object	*/						if (Cur.Obj.Id = GID(DirTable)) then							call Set.DirTable.Position(-1,-1);						call Select.New.Cur.Obj(OldObjectId,-1,-1);						call Get.Next.Optical.Event;					end;				end;				else call Get.Next.Optical.Event;			end;			else call Get.Next.Optical.Event;		end;	end;end Get.Next.MultiWindow.Control.Event;