/* ARC-DLG2  $TITLE  Additional Dialog Box Routines for Archival Screen *//* Modified:   05/02/89 - TSS - Merged changes for Optical disk to DTD transfer project   06/27/88 - SGS - File created.*//* $SUBTITLE  Get .INDEX information about a category */Get.Category.Size: proc (SectorPtr,WordPtr) swapable;   dcl (SectorPtr,WordPtr)      fixed;   dcl FileSector    fixed; /* index address of file */   dcl FileWord      fixed;   dcl Name(8)       fixed;   dcl FileLen(1)    fixed;   dcl (i,j,k)       fixed;   call STR32(0,0,CY#FilesSum);   CY#NumFiles = 0;   call Seek(CatList,I$CatStart+SectorPtr,3); /* seek to category */   call Seek(CatList,shl(WordPtr,1),1);   call GetW(CatList);              /* skip CListRecLen */   i = 1+shr(GetW(CatList)+1,1);    /* words in category name */   call Seek(CatList,shl(i-1,1),1); /* seek past category name */   CY#NumFiles=GetW(CatList);    /* number of files in this category */   do I=0 to CY#NumFiles-1; /* loop over all files in category  */      load GetW(CatList);                        /* get file address */      mul L#Rec_Length;      mwait; div 256;      FileSector=res; FileWord=rem;      call Seek(FileList,I$FileStart+FileSector,3); /* seek to appropriate sector in file list */      call Seek(FileList,shl(FileWord,1),1);        /* seek to appropriate word in this sector */      call FRead(Copy.Buf,shl(L#Rec_Length,1),1,FileList); /* get file list record */      call STR32(Copy.Buf(L$MS_SecLen),Copy.Buf(L$LS_SecLen),FileLen);      call ADD32(FileLen,CY#FilesSum,CY#FilesSum);  /* add file length to total */   end; /* looping over file entries */end Get.Category.Size;/* $SUBTITLE  Get current catalog information */Get.Catalog.Info: proc swapable;   dcl FCB (f#len-1)   fixed;   dcl FileLen(1)      fixed;   dcl (i,j,k)         fixed;   if not Read_Catalog('',1) then do;      call Set.Optical.Error(ERR#OtherCatError);      return;   end;   /* initialize */   CG#NumFiles = 0;   call STR32(0,0,CG#FreeSec);   call STR32(0,0,CG#FreeBlock);   /* get total space available in current catalog */   call STR32(c#ms_length, c#ls_length, CG#FreeSec);   /* subtract the directory size */   call SUB16(shr(c#dir_size,8),CG#FreeSec);   /* subtract each file from total free space */   do i = 0 to ((c#dir_size/c#len)-1);      call Get_FCB(i, FCB);  /* get next file */      if FCB(F#NM) <> 0 then do;         /* keep track of number of non-null files */         CG#NumFiles = CG#NumFiles+1;         call STR32(FCB(F#ML),FCB(F#LL),FileLen);         call SUB32(CG#FreeSec, FileLen, CG#FreeSec);      end;   end;   /* get largest free block */   if FindMax then call STR32(F#MS_LENGTH,F#LS_LENGTH,CG#FreeBlock);   /* else FindMax failed - read c#status ?? */end Get.Catalog.Info;Open.Cat.Info.Panel: proc (TopRow) swapable; /* get options for catalog store */   dcl TopRow        fixed; /* row of top of panel */   dcl (FirstId,Id)  fixed;   dcl Str      (40) fixed; /* a string buffer */   dcl Icon     (32) fixed;   dcl Name     (4)  fixed;   dcl CatName (32)  fixed;   dcl NumNew        fixed; /* number of files not already on optical disk */   dcl NumExisting   fixed; /* number of file that already exist on optical */   dcl (Bin,Len,I)   fixed;   dcl Temp.Base (1) fixed;   dcl Base      (1) fixed;   dcl XCol1 lit '1'; dcl XCol2 lit '22'; dcl XCol3 lit '34';   dcl mr13i lit 'write("373")';   /* $PAGE */   /* DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* Cur Category: ABCDEFGHIJKLMNOPCAT Cur Catalog: XX:ABCDECAT            [CANCEL]   */   /*    Sound Files:123456                   Entries:123456    Largest Avail Space:   */   /*  Total Sectors:123456             Avail Sectors:123456           123456          */   call Set.Auto.Allocation.Id(OBJ$Dialog); /* reset id # */   FirstId=Define.Label(s#aa,TopRow,0,14,'Cur Category: ');   call Set.Object.Mouse.Access(FirstId,0);   call Set.Object.Attr(FirstId,0,ATTR#Normal);   call Fetch.String(GID(SFName),Str); /* append category name to string */   if Str(0) > 18 then Str(0) = 18;   Id=Define.Label(s#aa,TopRow,14,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   call Set.Object.Attr(Id,0,ATTR#Normal|ATTR#Reverse|ATTR#AltIntensity);   Id=Define.Label(s#aa,TopRow,34,13,'Cur Catalog: ');   call Set.Object.Mouse.Access(Id,0);   call Set.Object.Attr(Id,0,ATTR#Normal);   call Get.Device.Name(1,Str);      /* get cur catalog name */   Id=Define.Label(s#aa,TopRow,47,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   call Set.Object.Attr(Id,0,ATTR#Normal|ATTR#Reverse|ATTR#AltIntensity);   call Copy.String('[CANCEL]',Str);   Id=Define.Label(s#aa,TopRow,70,Str(0),Str);   call Set.Object.Attr(Id,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);   call PID(DlgAbort,Id);   /* SECOND & THIRD LINES OF DIALOG: */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /*    Sound Files:123456                   Entries:123456    Largest Avail Space:   */   /*  Total Sectors:123456             Avail Sectors:123456           123456          */   call Get.Category.Size(GID(SavedCatSector),GID(SavedCatWord));   call Get.Catalog.Info;   Disable.Deposits = true;   call Copy.String('Sound Files:',Str);   Id=Define.Label(s#aa,TopRow+1,3,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   Id=Define.Fixed.Point(s#aa,TopRow+1,15,6,0,cf#right);   call Deposit.Fixed.Point(Id,CY#NumFiles);   call Copy.String('Total Sectors:',Str);   Id=Define.Label(s#aa,TopRow+2,1,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   call Conv.32Bit.Int.To.Str(CY#FilesSum,Str);   /* right justify number */   Name(0) = 0;   do i = (Str(0)+1) to 6;      call Append.To.Str(Name,' ');   end;   call Append.To.Str(Name,Str);   Id=Define.Label(s#aa,TopRow+2,15,Name(0),Name);   call Copy.String('Entries:',Str);   Id=Define.Label(s#aa,TopRow+1,40,Str(0),Str);   call Set.Object.Mouse.Access(Id,0); /* no mouse activity here */   Id=Define.Fixed.Point(s#aa,TopRow+1,48,6,0,cf#right);   call Deposit.Fixed.Point(Id,CG#NumFiles);   call Copy.String('Avail Sectors:',Str);   Id=Define.Label(s#aa,TopRow+2,34,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   call Conv.32Bit.Int.To.Str(CG#FreeSec,Str);   /* space fill front of string */   Name(0) = 0;   do i = (Str(0)+1) to 6;      call Append.To.Str(Name,' ');   end;   call Append.To.Str(Name,Str);   Id=Define.Label(s#aa,TopRow+2,48,Name(0),Name);   call Copy.String('Largest Avail Space:',Str);   Id=Define.Label(s#aa,TopRow+1,58,Str(0),Str);   call Set.Object.Mouse.Access(Id,0);   call Conv.32Bit.Int.To.Str(CG#FreeBlock,Str);   /* space fill front of string */   Name(0) = 0;   do i = Str(0) to 5;      call Append.To.Str(Name,' ');   end;   call Append.To.Str(Name,Str);   Id=Define.Label(s#aa,TopRow+2,65,Name(0),Name);   Disable.Deposits = false;   /* $PAGE */   /* put a small frame around the dialog panel */   I=(XCol3-1)*100-25; /* x-coord offset of vertical dividing line */   write("313")=Addr(Icon(0));   mr13i=O#ICON.Plot;     mr13i=   0; mr13i=-295;   mr13i=O#ICON.Plot;     mr13i=8025; mr13i=-295;   mr13i=O#ICON.Plot;     mr13i=8025; mr13i=   0;   mr13i=O#ICON.LineType; mr13i=1;   mr13i=O#ICON.Connect;  mr13i=   I; mr13i=   0; mr13i=   I; mr13i=-295;   mr13i=O#ICON.End;   Id=Define.Graphics.Icon(s#aa,-25,TopRow*100-95,0,Icon);   Id=Group.Objects(GRP$Dialog,FirstId,Id,Get#Screen.Event);   call PID(SFDDlgGrp,Id);   call Activate.Group.Objects(GID(SFDDlgGrp));   call Update.Group.Objects  (GID(SFDDlgGrp));   call Select.New.Cur.Obj    (GID(DlgAbort),-1,-1);end Open.Cat.Info.Panel;/* literals for COPY CATEGORY warning messages */dcl CatCopy#TooManyFiles      lit '01';dcl CatCopy#NotEnoughFreeSecs lit '02';Open.Copy.Category.Warning: proc (TopRow,Bits) swapable;   dcl TopRow        fixed;   dcl Bits          fixed; /* warning bits: see CatCopy# literals */   dcl (FirstId,Id)  fixed;   dcl Str      (40) fixed; /* a string buffer */   dcl Num (1)       fixed;   dcl NumStr (8)    fixed;   dcl Icon     (32) fixed;   dcl NextRow       fixed;   dcl i             fixed;   dcl XCol1 lit '1'; dcl XCol2 lit '22'; dcl XCol3 lit '34';   dcl mr13i lit 'write("373")';   if (Bits&(CatCopy#TooManyFiles|CatCopy#NotEnoughFreeSecs))=0      then return;   if (GID(SFDDlgGrp)<>-1) then call Close.Dialog.Panel;   /* $PAGE */   /* 0         1         2         3         4         5         6         7          */   /* 01234567890123456789012345678901234567890123456789012345678901234567890123456789 */   /* WARNING:                                               [CONTINUE]     [CANCEL]   */   /* Cur category holds at least 12345 more files than will fit.                      */   /* Cur category's total size exceeds available space by 12345 secs.                 */   call Set.Auto.Allocation.Id(OBJ$Dialog); /* reset id # */   FirstId=Define.Label(s#aa,TopRow,0,8,'WARNING:');   call Set.Object.Mouse.Access(FirstId,0);   call Set.Object.Attr(FirstId,0,ATTR#Normal|ATTR#Reverse);   call Copy.String('[CONTINUE]',Str);   Id=Define.Label(s#aa,TopRow,55,Str(0),Str);   call Set.Object.Attr(Id,0,ATTR#Normal);   call PID(DlgGo,Id);   call Copy.String('[CANCEL]',Str);   Id=Define.Label(s#aa,TopRow,70,Str(0),Str);   call Set.Object.Attr(Id,0,ATTR#Normal|ATTR#AltIntensity|ATTR#Reverse);   call PID(DlgAbort,Id);   /* call Set.Object.Arrow.Links(Id,Above,Below,Left,Right)  */   call Set.Object.Arrow.Links(GID(DlgGo)     ,-1,-1,-1,GID(DlgAbort));   call Set.Object.Arrow.Links(GID(DlgAbort)  ,-1,-1,GID(DlgGo),-1);   NextRow = TopRow+1;   if (Bits&CatCopy#TooManyFiles) <> 0 then do;      call Copy.String('Cur category holds at least ',Str);      call Read_Catalog('',1);  /* necessary to reconfirm c#dir_size and c#len ?? */      Num(0) = CY#NumFiles-((c#dir_size/c#len)-CG#NumFiles);      call Conv.Fixed.To.Str(Num(0),0,5,CF#Unsigned|CF#Append|CF#Right|CF#SPFill,Str);      call Append.To.Str(Str,' more files than will fit.');      Id=Define.Label(s#aa,NextRow,0,Str(0),Str);      call Set.Object.Mouse.Access(Id,0);      NextRow = NextRow+1;   end;   if (Bits&CatCopy#NotEnoughFreeSecs) <> 0 then do;      call Copy.String('Cur category''s total size exceeds available space by ',Str);      call SUB32(CY#FilesSum,CG#FreeSec,Num);      call Conv.32Bit.Int.To.Str(Num,NumStr);      call Append.To.Str(Str,NumStr);      call Append.To.Str(Str,' secs.');      Id=Define.Label(s#aa,NextRow,0,Str(0),Str);      call Set.Object.Mouse.Access(Id,0);   end;   /* $PAGE */   /* put a small frame around the dialog panel */   I=(XCol3-1)*100-25; /* x-coord offset of vertical dividing line */   write("313")=Addr(Icon(0));   mr13i=O#ICON.Plot;     mr13i=   0; mr13i=-295;   mr13i=O#ICON.Plot;     mr13i=8025; mr13i=-295;   mr13i=O#ICON.Plot;     mr13i=8025; mr13i=   0;   mr13i=O#ICON.LineType; mr13i=1;   mr13i=O#ICON.End;   Id=Define.Graphics.Icon(s#aa,-25,TopRow*100-95,0,Icon);   Id=Group.Objects(GRP$Dialog,FirstId,Id,Get#Screen.Event);   call PID(SFDDlgGrp,Id);   call Activate.Group.Objects(GID(SFDDlgGrp));   call Update.Group.Objects  (GID(SFDDlgGrp));   call Select.New.Cur.Obj    (GID(DlgAbort),-1,-1);end Open.Copy.Category.Warning;Get.Warning.Response: proc returns (boolean) swapable;   call Get.Next.Optical.Event;         /* get first event */   do while Exit.My.Screen=0;           /* wait for exit condition */      if Screen.Event.Group=GID(SFDDlgGrp) then do;         if Screen.Event.Code=Get.Screen.Event then do;            if (Screen.Event.Info=S#MouseSelect)            or (Screen.Event.Info=S#MouseActivate)            or (Screen.Event.Info=S#KeyActivate)            then do;               if (Screen.Event.Id=GID(DlgGo))               or (Screen.Event.Id=GID(DlgAbort)) then do;                  call Close.Dialog.Panel;                  return (Screen.Event.Id=GID(DlgGo));               end;            end;            else call Get.Next.Optical.Event;         end;         else call Get.Next.Optical.Event;   /* get another event */      end;      else if Screen.Event.Group=GID(MiscGrp) then do;         call Get.Next.Misc.Event; /* might be mouse hole or ENTER */      end;      else if Screen.Event.Code=Get.Screen.Event then do; /* screen event on some other group */         if (Screen.Event.Info=S#MouseSelect)         or (Screen.Event.Info=S#MouseActivate)         then do; /* user selected some object outside dialog box */            call Select.New.Cur.Obj(GID(DlgAbort),-1,-1); /* force back to dialog object */            call Set.Optical.Error(Err#NeedDialogResponse);         end;         call Get.Next.Optical.Event;      end;      else call Get.Next.Optical.Event; /* ignore all other events */   end;   call Close.Dialog.Panel;   return false; /* did not get the go ahead from user */end Get.Warning.Response;