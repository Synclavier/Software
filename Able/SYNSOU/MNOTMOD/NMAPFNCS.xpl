/* $title Note Map Building Routines *//*   6/02/86 - adt & eg - updated for rel M   5/20/86 - eg - made procedures and some variables pub.   5/15/86 - "official" creation of release-M modules*/DCL (#TRK)            FIXED EXTERNAL; /* ABS TRK NUMBER ACTION IS TO TAKE PLACE ON */DCL (#PTR)            FIXED EXTERNAL; /* ABS PTR TO TRACK HEAD */DCL (#NMSB,#NLSB)     FIXED EXTERNAL; /* NEXT TIME CORRESPONDING TO PTR */DCL (#LMSB,#LLSB)     FIXED EXTERNAL; /* LAST TIME CORRESPONDING TO PTR */DCL (#WRD,#SEC)       FIXED EXTERNAL; /* RELATIVE PTR INTO NAH AREA AT WHICH ACTION OCCURS */DCL (#W1,#W2,#W3,#W4) FIXED EXTERNAL; /* 4 WORDS TO HOLD A NOTE RECORD */DCL (#MSB,#LSB)       FIXED EXTERNAL; /* GENERAL 32-BIT VALUE TO PASS OR RETURN */DCL (#ANYR,#ANYF)     FIXED EXTERNAL; /* ANY REV & FOR FOR THIS POINT   */NOTE_INSERT:procedure (LP,REC_P) swapable; /* Insert a chord list record into a chord list by Key No. */ dcl  REC_P  pointer,      (LP,P) pointer;  if REC_P = null then return; /* No record was passed (probably wasn't allocated due to running out of core) */  P = core(LP);  do while core(REC_P+C_KEY) <= core(P+C_KEY) & P ~= null;    LP = core(LP); P = core(P);  end;  core(LP) = REC_P; core(REC_P) = P;end NOTE_INSERT;SEQ_LOAD:procedure (TH) swapable;  dcl TH            fixed array,      ST(1)         fixed,      KEY_NO        fixed,      DURATION      fixed,      I             fixed;  call UNCONVERT_TIME (TH,0);  do while TRACK_PRESENT & #ANYF &            (#NMSB < TH(1) \ (#NMSB = TH(1) & #NLSB ile TH(0)));    call LOOK.UP.NOTE.INFO;    if ~rot(#W1,1) & ~rot(#W3,1) then do; /* Ignore alt & update recs */    ST(1)    = #NMSB;    ST(0)    = #NLSB;    DURATION = CONVERT_TIME (ST,GET_DURATION);    KEY_NO   = #W2 & MASK6;    if KEY_NO = REST.NOTE then KEY_NO = REST#;                          else KEY_NO = KEY_NO + 12;    if #W1 then do;      if (#W4 & LOWER.KEY) ~= 0 then KEY_NO = KEY_NO - 12;      if (#W4 & RAISE.KEY) ~= 0 then KEY_NO = KEY_NO + 12;    end;    if KEY_NO ~= REST# then do;      REC(C_MSB) = ST(1);      REC(C_LSB) = ST(0);      REC(C_SEC) = #SEC;      REC(C_WRD) = #WRD;      REC(C_DUR) = DURATION;      REC(C_KEY) = KEY_NO;      REC(C_BIT) = 0;      call NOTE_INSERT (addr(NEW_HEAD),ALLOCATE);      if ST(1) ilt EARLIEST_ST(1) \        (ST(1) = EARLIEST_ST(1) & ST(0) ilt EARLIEST_ST(0))      then do;        EARLIEST_ST(1) = ST(1);        EARLIEST_ST(0) = ST(0);      end;    end;    end; /* End of Normal Format note record case */    if ABORT_REFRESH(0) then return;    call ADVANCE.TO.NEXT.NOTE;  end; /* End of scanning loop */end SEQ_LOAD;SCAN_CHORD:procedure (THRESH) returns (boolean) swapable; /* Most of the work is done here! */  dcl THRESH    fixed array,      FINISH(1) fixed,      P         pointer,      DONE      boolean;  P    = OLD_HEAD;  DONE = false;  do while P ~= null;    FINISH(1) = core(P+C_MSB);    FINISH(0) = core(P+C_LSB);    call ADD32 (FINISH,core(P+C_DUR));    if FINISH(1) ilt THRESH(1) \      (FINISH(1) = THRESH(1) & FINISH(0) ile THRESH(0)) then do;      core(P+C_BIT) = core(P+C_BIT) \ H_DONE;      DONE          = true;    end;    P = core(P);  end;  return (DONE);end SCAN_CHORD;STACK_CHORD:procedure (POSITION,COUNT,REST) returns (fixed) swapable;  dcl POSITION     fixed,      COUNT        fixed,      REST         boolean,      (C,DIR,I)    fixed,      (BLKS,TYP)  fixed,      (P,NP)       pointer,      DOTTED       boolean;  TYP    = WHOLE#;  DOTTED = false;  if REST & FIRST & (POSITION + COUNT + (START_CLICK - 1) * BEAT) mod                    (CLICKS_MEASURE * BEAT) = 0  then BLKS = COUNT; /* Whole rest of any length */  else do;    C = CLICKS_MEASURE * BEAT -        (POSITION + (START_CLICK - 1) * BEAT) mod (CLICKS_MEASURE * BEAT);    if COUNT < C then C = COUNT;    if C > BEAT & BEAT mod 3 = 0 then C = C - C mod BEAT;    BLKS = WHOLE_SIZE;    do while (BLKS > C);      BLKS = BLKS / 2; TYP = TYP + 1;    end;    I = BLKS + BLKS / 2;    if BLKS > 1 & C = I then do; /* Allow for a dotted note ???? */      BLKS = I; DOTTED = true;    end;  end;  if BLKS = 0 then BLKS = 1; /* TimeSig/Reso incompatable */  if (REST) \ (TYP = WHOLE#) then STEM_LENGTH = 0;  else if TYP <= EIGHTH# then STEM_LENGTH = 7;  else                        STEM_LENGTH = 7 + (TYP - EIGHTH#) * 2;  if (NMAP_WORD+52) IGE (shl(NOTE_MAP_SIZE,8))  /* see if this record would */  then return;                                  /* put us past end of trd.ptr */                                                /* (save room for 2 word header, 16 notes, bar line) */  NP           = NMAP_WORD + 2;  P     = OLD_HEAD;  C     = 0;  FIRST = false;  if REST ~= 0 then do;    write(SECT$) = NMAP_SECT + shr(NP,8);    write(WORD$) = NP;    REC(0) = N_REST \ 31;    if DOTTED then REC(0) = REC(0) \ N_DOT;    write(DATI$) = REC(0);    write(DATI$) = 0;    write(DATI$) = 0;    NP = NP + 3;  end;  else do while P ~= null;    write(SECT$) = NMAP_SECT + shr(NP,8);    write(WORD$) = NP;    REC(0) = KEY_NOTE(core(P+C_KEY));    REC(1) = core(P+C_SEC); /* Note Pointer (sector) */    REC(2) = core(P+C_WRD); /* Note Pointer (word)   */    C      = C + (REC(0) & MASK6);    if (core(P+C_BIT) & H_TIED) ~= 0    then REC(0) = REC(0) & "177477"; /* No accidentals on tied to notes */    if DOTTED                         then REC(0) = REC(0) \ N_DOT;    if (core(P+C_BIT) & H_TIED)   ~= 0 \       (core(P+C_BIT) & H_SLUR)   ~= 0   then REC(0) = REC(0) \ N_CTIE;    if (core(P+C_BIT) & H_DONE)    = 0 \       (core(P+C_BIT) & H_UPDATE) ~= 0 \       BLKS < COUNT                   then REC(0) = REC(0) \ N_OTIE;    write(DATI$) = REC(0);    write(DATI$) = REC(1);    write(DATI$) = REC(2);    core(P+C_BIT) = core(P+C_BIT) \ H_TIED; /* Heap note is now tied to */    P             = core(P);    NP            = NP + 3;  end; /* End of chord loop */  /* Create Position Header */  DIR = 0; /* This mess finds the average Ypos */  if C / ((NP-NMAP_WORD-2)/2) > 30 then DIR = P_DIR; /* The () = # of notes in chord */  if REST then REST = P_REST; /* This combined use of REST just saves vars */  /* This should be cleaned up? */  I = false;  if (POSITION + BLKS + (START_CLICK - 1) * BEAT) mod (CLICKS_MEASURE * BEAT) = 0  then do;    if BLKS = 1 then REST = REST \ P_BAR; /* Mark this position for barline */                else I = true;            /* or create a new position */    ACC_LIST(0) = 0;    FIRST       = true;  end;  write(SECT$) = NMAP_SECT + shr(NMAP_WORD,8);  write(WORD$) = NMAP_WORD;  write(DATI$) = shl(POSITION,6) \ (NP - NMAP_WORD);  write(DATI$) = DIR \ P_FLAG \ REST \ shl(TYP,5) \ STEM_LENGTH;  if I then do; /* Stack an extra position header for barline */    write(SECT$) = NMAP_SECT + shr(NP,8);    write(WORD$) = NP;    write(DATI$) = shl(POSITION+BLKS-1,6) \ 2;    write(DATI$) = P_BAR;    NP           = NP + 2;    ACC_LIST(0)  = 0;  end;  NMAP_WORD = NP;  return (BLKS);end STACK_CHORD;SCAN_SEQ:procedure (NPSN) returns (fixed) swapable;  dcl NPSN         fixed,      T(1)         fixed,      HI_THRESH(1) fixed,      DIV_CNT      fixed,      MAX_CNT      fixed,      COUNT        fixed,      (DT,I)       fixed;  COUNT      = 1;  BREAK_NOTE = false;  MAX_CNT    = WHOLE_SIZE;  DIV_CNT    = NPSN mod BEAT;  if DIV_CNT ~= 0 then do while DIV_CNT mod MAX_CNT ~= 0;    MAX_CNT = MAX_CNT / 2;  end;/*  if NPSN = 0 & OLD_HEAD = null then MAX_CNT = NOTE_BLOCKS; ***** */  do forever; /* Loop over template by resolution */                     /*VVVVVVVVVVVVVVVVV*/    if COUNT = MAX_CNT /*& OLD_HEAD = null*/ then BREAK_NOTE = true;    if (NPSN + COUNT + (START_CLICK - 1) * BEAT) mod /* Stop at barline */       (CLICKS_MEASURE * BEAT) = 0 then BREAK_NOTE = true;/*    if NPSN + COUNT > BLOCKS then return (COUNT); * WAS >= ??? */    write(SECT$) = TEMP_BASE;    write(WORD$) = TEMP_WORD;    I            = read(DATI$);    DT           = read(DATA$) - I;    TEMP_WORD    = TEMP_WORD + 1;/*    START(1) = START_TIME(1);    START(0) = START_TIME(0);    call ADD32 (START,I);*/    HI_THRESH(1) = START_TIME(1); /* Set High Threshold */    HI_THRESH(0) = START_TIME(0); /* to POS + dT/2      */    call ADD32 (HI_THRESH,I + shr(DT,1));/*  call SEQ_LOAD (LO_THRESH,HI_THRESH); */    T(1) = HI_THRESH(1);    T(0) = HI_THRESH(0);    call SEQ_LOAD (T);    /* Load notes up to HI_THRESH (trashes passed agg.) */    if ABORTING  then return (0);    if NPSN = -1 then return (0); /* Init case */    LO_THRESH(1) = HI_THRESH(1);    LO_THRESH(0) = HI_THRESH(0);    if SCAN_CHORD (HI_THRESH) \ BREAK_NOTE \ NEW_HEAD ~= null then return (COUNT);    COUNT = COUNT + 1;  end;end SCAN_SEQ;BUILD_PART_MAP:procedure (SECT,WORD,CORE_AREA) returns (fixed) swapable;  PURGE:procedure;       /* PUT HERE TO REDUCE SWAPPING */    dcl (LP,P) pointer;    LP = addr(OLD_HEAD); P = OLD_HEAD;    do while P ~= null;      if (core(P+C_BIT) & (H_DONE \ H_UPDATE)) ~= 0 then do;        core(LP) = core(P);        call FREE (P);        P = core(LP);      end;      else do;        LP = P; P = core(P);      end;    end;  end PURGE;  MERGE:procedure;      /* PUT HERE TO REDUCE SWAPPING */    dcl (P,Q) pointer;    P = NEW_HEAD;    do while P ~= null;      Q = core(P);      call NOTE_INSERT (addr(OLD_HEAD),P);      P = Q;    end;  end MERGE;  dcl SECT  fixed,      WORD  fixed,      PPSN  fixed,      BLKS  fixed,      COUNT fixed,      FLAG  boolean;  DCL CORE_AREA ARRAY;  NMAP_SECT   = SECT;  NMAP_WORD   = WORD;  TEMP_WORD   = 0;  OLD_HEAD    = null;  LIST_BASE   = addr(CORE_AREA(0));  LIST_TOP    = LIST_BASE + 256;  FREE_HEAD   = null;  FREE_TAIL   = addr(FREE_HEAD);/*  if (PBITS & (P_JAZZ \ P_CLAS)) ~= 0  then MEAS_DIV = BLOCKS_MEASURE;  else MEAS_DIV = WHOLE_SIZE / BEAT_NOTE;  if (PBITS & P_JAZZ) = 0 & BEAT_MEAS mod 3 = 0 & BEAT_NOTE > 4  then MEAS_DIV = (WHOLE_SIZE * 3) / BEAT_NOTE;  if BEAT_MEAS mod 3 = 0 & BEAT_NOTE > 4  then BEAM_DIV = (WHOLE_SIZE * 3 * RES_MULT) / 8;  else BEAM_DIV = (WHOLE_SIZE     * RES_MULT) / 4;*/  FIRST            = true;  FLAG             = true;  PPSN             = 0;  ACC_LIST(0)      = 0;  NEW_HEAD = null;  call SCAN_SEQ (-1);  call MERGE;  do while FLAG;    NEW_HEAD = null;    COUNT    = SCAN_SEQ (PPSN);    if ABORTING then return (0);    do while COUNT > 0;      if OLD_HEAD ~= null then do;        BLKS       = STACK_CHORD (PPSN,COUNT,false);/*      BEAM_FLAGS = 0; * This should be in StackChord */      end;      else BLKS = STACK_CHORD (PPSN,COUNT,true);      if ABORTING then return (0);      PPSN = PPSN + BLKS;/*    if PPSN mod BEAM_DIV = 0 then BEAM_FLAGS = B_BREAK; */      if PPSN >= BLOCKS then do;        FLAG  = false;        COUNT = 0;      end;      else COUNT = COUNT - BLKS;    end;    call PURGE;    call MERGE;    if ABORT_REFRESH(0) then return (0);  end; /* End of note resolution loop */  return (NMAP_WORD - WORD);end BUILD_PART_MAP;SET_SEQ_POINTERS:procedure (TRACK) swapable;  dcl TRACK      fixed,      T(1)       fixed,      I          fixed;  /* Set initial low threshold */  write(SECT$) = TEMP_BASE;  write(WORD$) = 0;  I            = read(DATI$);  I            = read(DATA$) - I; /* Get delta of first block */  LO_THRESH(1) = START_TIME(1);  LO_THRESH(0) = START_TIME(0);  call SUB32 (LO_THRESH,shr(I,1)); /* Window starts 1/2 delta prior to first point */  T(1) = LO_THRESH(1); /* We will scan in abs time for efficiency */  T(0) = LO_THRESH(0);  call UNCONVERT_TIME (T,0); /* T = lower boundary of screen window */  TRACK_PRESENT = LOAD.SEQ.GLOBALS (NUM.KBD.TRACKS+TRACK);  if TRACK_PRESENT then do;    /* Scan backward until outside (prior to) window */    do while #ANYR & (#NMSB igt T(1) \ (#NMSB = T(1) & #NLSB ige T(0)));      call BACKUP.TO.PRIOR.NOTE;    end;    /* Scan forward until just inside window */    do while #ANYF & (#NMSB ilt T(1) \ (#NMSB = T(1) & #NLSB ilt T(0)));      call ADVANCE.TO.NEXT.NOTE;    end;  end;end SET_SEQ_POINTERS;BUILD_TIME_TEMPLATE:procedure swapable;  dcl I fixed;  write(SECT$) = TEMP_BASE;  write(DATI$) = 0;  do I = 1 to BLOCKS + 1;    write(DATI$) = SIEVE(TICS,BLOCKS,I);  end;/*call print_template (TEMP_BASE,BLOCKS+1);*/end BUILD_TIME_TEMPLATE;BUILD_NOTE_MAP:procedure (CORE_AREA) swapable;  DCL CORE_AREA ARRAY;  dcl namearray (8) fixed;  dcl STAFF fixed,      (P,Q) pointer;  EARLIEST_ST(1) = 0; /* Holds earliest note on screen */  EARLIEST_ST(0) = 0; /* (used for note searches in editor) */  P = 16;  do STAFF = 0 to STAVES;    call LOAD_PART_VECTOR (MENU_BASE,8+STAFF*8);    MAX_KEY_LENGTH = NEW_MAX_KEY_LENGTH;    MEASRS         = MEASURES;    CLICNOTE       = CLICK_NOTE;    CLICS          = CLICKS;    MAX_BLOCKS     = NEW_MAX_BLOCKS;    call DUMP_PART_VECTOR (NEW_SECT,P);    P = P + 8;    /* Get timbre name */    call LOOKUP.TRACK.TIMBRE.NAME(NUM.KBD.TRACKS + TRACK,NAMEARRAY);    DO Q=NAMEARRAY(0) TO 15;                  /* SPACE FILL TO 16 */       CALL PBYTE(NAMEARRAY,Q,SP);    END;    WRITE(MAM) = NEW_SECT + SHR(P,8);    WRITE(MAL) = P;    CALL COPY.OUT(ADDR(NAMEARRAY(1)),8);    P = P + 8;    WHOLE_SIZE  = RESOLUTION * MULTIPLIER;    BLOCKS      = (shr(CLICK_NOTE,8) * WHOLE_SIZE * CLICKS) / (CLICK_NOTE & LBYTE);    BEAT        = (shr(CLICK_NOTE,8) * WHOLE_SIZE) / (CLICK_NOTE & LBYTE);    if BLOCKS igt 250 then BLOCKS = 250; /* LIMIT TO SMALLER THAN 1 SECTOR (AND THEN SOME) */    if BEAT      = 0 then BEAT      = 1;    call BUILD_TIME_TEMPLATE;    call SET_SEQ_POINTERS (TRACK);    P = P + BUILD_PART_MAP (NEW_SECT,P,CORE_AREA);    if ABORTING then return;    write(SECT$) = NEW_SECT;    write(WORD$) = 8 + STAFF;    write(DATI$) = P;  end; /* End of staff loop */  do STAFF = STAVES + 1 to 7; /* Fill out list pointer area with emptys */    write(DATI$) = P;  end;  write(SECT$) = NEW_SECT;  write(DATA$) = shr(P+255,8);end BUILD_NOTE_MAP;