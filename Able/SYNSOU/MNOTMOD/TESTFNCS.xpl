/*   5/30/86 - adt & eg - updated for rel M   5/20/86 - eg - made procedures and some variables pub.   5/15/86 - "official" creation of release-M modules*//*checksum:proc;  dcl (i,j,check) fixed;  dcl (s,w) fixed;  i = 0;  j = core(core(1) + 4);  check = 0;  do while (i ilt j);    if i = core(1) then i = core(core(1) + 7);    check = check + core(i);    i = i + 1;  end;  stop(check);  s     = read("60");  w     = read("61");  i     = core(core(core(1)+5));  check = 0;  do while i ilt 1024 - 32;    write("60") = i;    do j = 0 to 255;      check = check + read("63");    end;    i = i + 1;  end;  write("60") = s;  write("61") = w;  stop(check);end checksum;*/onum:proc (X,S) swapable;  dcl (X,S,I) fixed;        do I = 7 to S; call pc(sp); end;  X = rot(X,1);  if X then call pc(asc.1); else call pc(asc.0);  do I = 1 to 5;    X = rot(X,3);    call pc(asc.0+(X&MASK3));  end;end onum;print_note_map:proc (sect,mess) swapable;  dcl sect      fixed,      mess      fixed array,      buff(7)   fixed,      (I,J,L,P) fixed;  call clear.term; transparent_mode;  call cpos(0,0); call ps(mess); call pcr; call pcr;  write(SECT$) = SECT;  do I = 1 to 8; call onum(read(DATI$),8); end; crlf;  do I = 0 to 7;    buff(I) = read(DATI$);    call pnum(buff(I),0); call pc(sp);  end; crlf; crlf;  P = 16;  do I = 0 to STAVES;    call ps('Part: '); call pnum(I+1,0); crlf;    do J = 1 to 8; call onum(read(DATI$),8); end; crlf;    P = P + 8;    do while P ilt buff(I);      L = (read(DATA$) & MASK6) - 2; P = P + 2;      call pnum(shr(read(DATA$),6),0); call pc(sp);      call pnum(read(DATI$)&MASK6,0);      call onum(read(DATA$),8);        call pc(sp);      call pnum(shr(read(DATA$),5)&MASK3,0); call pc(sp);      call pnum(read(DATI$)&MASK5,0);      wchar(colon);      do J = 1 to L / 2;        call onum(read(DATA$),8);               call pc(sp);        call pnum(shr(read(DATA$),6)&MASK2,0);  call pc(sp);        call pnum(read(DATI$)&MASK6,0);        call onum(read(DATI$),8);        P = P + 2;      end; crlf;    end;  end;  crlf;  call tty_wait; stop(1);  vector_mode;end print_note_map;print_template:procedure (SECT,BLOCKS) swapable;  dcl SECT   fixed,      BLOCKS fixed,      I      fixed;  write(SECT$) = TEMP_BASE;  do I = 0 to BLOCKS;    if I mod 8 = 0 then crlf;    call pnum(read(DATI$),0); call pc(sp);  end;  crlf; crlf;end print_template;