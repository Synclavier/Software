/* :SYNSOU:RECMOD:557REC1A  $TITLE  Routines to Run Recorder Display (Part 4 of 4) *//*Modified:1998/07/09 - TY  - Assigned S-page's Transpose function to function keys.1998/05/20 - TY  - Removed unused variable "RATE" from RECORDER.DEPOSIT as well as a chunk of code for setting						 the value of this variable.1998/04/19 - TY  - Added a case block to RECORDER.DISPLAY.INPUT so that edit functions can be assigned to Fkeys.					  - Modified RECORDER.DISPLAY.MOUSE.POS so that "col" is calculated differently based on the						 vertical position clicked on.  This was done to accurately match mouse fields to the printed						 commands in the various panels.  Also nested the "figure out field" part inside of the						 "IF CLICKED IN THE NOTE AREA" section since the fields are of no consequence elsewhere.						 Removed two unnecessary variables.1998/04/17 - TY  - Modified the "esc" and "asc.great" blocks of RECORDER.DISPLAY.INPUT so that if ">" or "escape"						 are pressed while a token or ripple edit is pending, the token will be deposited first.					  - Modified RECORDER.DISPLAY.MOUSE.POS so that in the instructions, <Enter>, <Delete>, H and #						 are also clickable.1998/04/16 - TY  - Added "abort entry" and "repeat entry" functions to RECORDER.DISPLAY.INPUT (in.arg=c.x).					  - Modified RECORDER.DEPOSIT and the "in.arg>sp" block of RECORDER.DISPLAY.INPUT to accommodate						 the "repeat entry" function.					  - Added conditionals to the "in.arg=sp" block of RECORDER.DISPLAY.INPUT to prevent the entire						 screen from redrawing when toggling "Note Ripple" or "UNDO Enable" or when typing spaces over						 pitches.					  - Modified RECORDER.DISPLAY.MOUSE.POS so that when the mouse is clicked while a token is						 pending or a ripple edit is in progress, the token will first be deposited where entered						 rather than at the new position.  Also restructured the "figure out row" part so that testing						 for the more likely case occurs before testing for less likely cases.  Also greatly reduced the						 number of conditional tests required for this and for "figure out col" and "figure out field".					  - Restructured DISPLAY.RIPPLE.MESSAGE and RIPPLE.DEPOSIT to remove unnecessary duplication.					  - Reduced size of tmp.tok from 11 words to 7 because the longest token allowed by RECMAX is 12						 characters in length.1998/04/15 - TY  - Restructured RECORDER.DEPOSIT so that testing for the very likely case occurs first rather						 than after testing for an unlikely case.  Also avoided redundant "token(0)=0".1998/04/08 - TY  - Added a line of code to the delete/ctrl-z case in RECORDER.DISPLAY.INPUT that disables the						 record track feature when the record track is deselected by pressing the delete key in the						 track select field.1998/04/07 - TY  - Removed a line of code in the delete/ctrl-z case in RECORDER.DISPLAY.INPUT that caused the						 cursor to jump to line 2 when a note on line 1 was deleted.  VERY annoying.1990/10/11 - PF  - Expand TRACK.FORMAT to allow for beats only display mode1990/01/09 - MWH - Don't "zero" entered note start times when UNDO is on1988/10/20 - cj  - check for un-initialized track in undo*/UPDATE.MODE.SELECTION: proc swapable;	dcl i fixed;	if show.modes=false then return;	do i = 0 to 1;		if i<>0 then do;					/* figure new choice and set last.sel */			do.reverse=true;				/* turn on reverse for new one */			if trrow=(-3) then do;				if      trcol=0 then last.sel=1;				else if trcol=1 then last.sel=2;				else if trcol=2 then last.sel=3;			end;			else if trrow=(-2) then do;				if      trcol=0 then last.sel=4;				else if trcol=1 then last.sel=5;				else if trcol=2 then last.sel=6;			end;			else last.sel=0;		end;		else do.reverse=false;			/* turn off reverse for old one */		do case (last.sel);			/*0*/ ;	/* do nothing */			/*1*/ call PRINT.SEC.FIELD;			/*2*/ call PRINT.OFFSET.FIELD;			/*3*/ call PRINT.UNDO.FIELD;			/*4*/ call PRINT.THIRD.FIELD;			/*5*/ call PRINT.RTE.FIELD;			/*6*/ call PRINT.RIP.FIELD;		end;	end;end UPDATE.MODE.SELECTION;/* Routine to change certain parameters of the recorder screen */TOGGLE.STATES: proc swapable;	do.reverse=(trrow < 0);	/* don't want reverse if user is toggling outside of mode screen */	if ((trrow=(-3) and (trcol=0)) or (trrow>(-1) and (trfld=0)))	then do;														/* sec/beats/measures/smpte  */		disp.mode=disp.mode+1;								/* advance mode */		if disp.mode=5 then disp.mode=0;		if  (disp.mode=1)										/* new mode is beats  */		and (click.track.mode=3)							/* but using ext clik */		then disp.mode=3;										/* then skip beats & measures */		do case disp.mode;									/* set track.format */			do;	//	case 0: SECONDS				track.format	= 2;							/* seconds     */				pid(sav.time.mode, 0);						/* update seq. editor time format to match */			end;			do;	//	case 1: BEATS				track.format	= 0;							/* beats       */				pid(sav.time.mode, 2);						/* update seq. editor time format to match */			end;			do;	//	case 2: MEAS:BEAT				track.format	= 1;							/* measures    */				pid(sav.time.mode, 3);						/* update seq. editor time format to match */			end;			do;	//	case 3: SMPTE				if (new.pan != 0)	track.format	= 3;	/* smpte       */				else					track.format	= 2;	/* use seconds */				pid(sav.time.mode, 4);						/* update seq. editor time format to match */			end;			do;	//	case 4: FEET:FRA				track.format	= 0;							/* feet:frames */				pid(sav.time.mode, 5);						/* update seq. editor time format to match */			end;		end;		//	we should update the VK display to reflect the change		Display.Track.Format.Change();		if show.modes<>0 then call PRINT.SEC.FIELD;	end;	else if (trrow=(-3) and (trcol=1))				/* show sound file offset */	then do;		show.offsets=show.offsets xor 1;		if show.modes<>0 then call PRINT.OFFSET.FIELD;	end;	else if (trrow=(-3) and (trcol=2))				/* undo enable/disable */	then do;		undo.enabled = undo.enabled xor 1;		if show.modes<>0 then call PRINT.UNDO.FIELD;		if (not(undo.enabled)) then do;	/* clear these out so they don't take up any note space */			call ERASE.TRACK(undo.trk);			call ERASE.TRACK(undo.tmp.trk);		end;	end;	else if ((trrow=(-2) and (trcol=0)) or (trrow>(-1) and (trfld=2)))	then do;													/* velocity/duration/end time/name  */		third.fld=third.fld + 1;		if third.fld=4 then third.fld=0;		if show.modes<>0 then call PRINT.THIRD.FIELD;	end;	else if (trrow=(-2) and (trcol=1))	then do;													/* rte/no rte       */		show.rte=show.rte xor 1;		if show.modes<>0 then call PRINT.RTE.FIELD;	end;	else if (trrow=(-2) and (trcol=2))	then do;													/* ripple/no ripple/verify ripple */		ripple=ripple+1;		if ripple=3 then ripple=0;		if show.modes<>0 then call PRINT.RIP.FIELD;	end;end TOGGLE.STATES;/* $SUBTITLE  Routines to Handle Recorder Display Input and Scrolling Display */SAVE.TRK.FOR.UNDO: proc swapable;	dcl save.new.seq			fixed;	dcl save.new.ABLE.seq	fixed;	if (undo.enabled == 0) then return;		/* only do this if undo is enabled */	saved.trk = trkindex(trcol);				/* need to know this later (when user hits ctrl-u) */	save.new.seq = new.seq.info;				/* save any current event bits */	save.new.ABLE.seq = new.ABLE.seq.info;	call Fast.Copy(saved.trk, undo.trk);	if ((TRK.HEAD.LOOKUP(undo.trk, thd.ignore) & THD.IGNORE.IGNORE) == 0) then do;	/* make sure this is set */		WRITE(MD) = READ(MD) | THD.IGNORE.IGNORE;		call COMPUTE.ACTIVE.TRKS;	end;	if (play<>0) then call stop.play;	call Play.Initialize;	new.seq.info = save.new.seq;				/* ignore event bits created by  */	new.ABLE.seq.info = save.new.ABLE.seq;	/* Fast.Copy and Play.Initialize */end SAVE.TRK.FOR.UNDO;RECORDER.DEPOSIT: proc swapable;				/* store input in track display */	dcl I		fixed;	dcl ch	fixed;	if (err.displayed<>0) then do;		call remove.err;		call PRINT.CCAT;	/* reprint current cat name */	end;	if token(0)=0 then return;						/* no string - no change */	tok.ptr=0;											/* init pointer for input scan */	if (trrow > -1) then do;		/* HANDLE INPUT IN BODY */		call LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;	/* need info to know what's going on */		call SAVE.TRK.FOR.UNDO;						/* save copy of current trk */		do case (trfld);								/* branch according to field dtype */			do;				call EDIT.NOTE.START;				/* 0: change start time of note under cursor */			end;			do;				if (isa.rte.note=false)				then call EDIT.NOTE.PITCH;			/* 1: change pitch of note under cursor */				else call EDIT.RTE.CODE;			/* or change type of rte record */			end;			do;				if ((third.fld=1 or third.fld=2) 				and (isa.rte.note=false))				then call EDIT.NOTE.DURATION;		/* 2: change duration of note under cursor  */				else if ((third.fld=0) or (isa.rte.note<>0))				then call EDIT.RTE.VALUE;			/* or change rte value of note under cursor */			end;		end;	/* of do case */		saved.token.length=token(0);token(0)=0;/* reset deposited token but save character-length for possible repeat */		if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */		then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */		call RE.UPDATE.TRACK.DISPLAY;				/* redraw display */	end;		else do;		if trrow=(-1) then do;		/* ENTERING NEW TRACK SELECTION */			ertyp=0;											/* clear out any un-presented (ie sample rate overrun) errors */			i=CONV.STR.TO.FIXED(token,0,0);			/* read track selection */			if (i<=0)\(i>200) then call format.error;			if ertyp=0 then do;							/* store if ok input */				trkindex(trcol)=i+num.kbd.tracks-1;	/* select new track */				/* force an update of track titles to this screen only when */				/* changing which tracks are displayed:                     */				new.ABLE.seq.info = new.ABLE.seq.info \ 6;				if (trcol = recd.col)					/* person entered a number where recd track used to be */				then recd.col = -1;						/* so reset recd.col */			end; 			else call REDRAW.TRACK.TITLE(trcol);	/* else restore old information */		end;		token(0)=0;	/* reset deposited token, don't allow repeat */	end;end RECORDER.DEPOSIT;/* $SUBTITLE  Routine to Process Chars Typed on Recorder Display */dcl tmp.tok(6) fixed;ERASE.RIPPLE.PROMPT: proc swapable;	call erase.rest.of.line(23,0);	call RE.UPDATE.TRACK.DISPLAY;end ERASE.RIPPLE.PROMPT;DISPLAY.RIPPLE.MESSAGE: proc(message) swapable;	/* displays messages related to ripple edit */	dcl message fixed;	/* message number */	call reverse.video(1);	call cpos(23,0);	if message<>0	/* user typed okay */	then call ps(' Ripple Edit Executed Succesfully ');	else call ps(' Ripple Edit Not Executed ');	call reverse.video(0);	call print.ccat;end DISPLAY.RIPPLE.MESSAGE;ripple.deposit:proc swapable;	dcl i  fixed;	dcl ch fixed;	if  (ripple=2) 	and (trfld =0)	and (trrow>(-1))	and ((token(0)<>0)\(ripple.edit<>0)) 	then do;		if ripple.edit<>0		then do;		/* STEP 2: EXPECTING CONFIRMATION */			call ERASE.RIPPLE.PROMPT;			if (eqstr(token,'OK')<>0)			then do;	/* RIPPLE DECLINED */				do i = 0 to 6;					/* restore time value */					token(i) = tmp.tok(i);				end;				ripple=0;						/* user didn't type ok, */				call RECORDER.DEPOSIT;		/* so enter new value, but don't ripple */				ripple=2;						/* restore verify state */				call DISPLAY.RIPPLE.MESSAGE(0);	/* indicate Not Executed */			end;			else do;	/* RIPPLE CONFIRMED */				do i = 0 to 6;					/* restore time value */					token(i) = tmp.tok(i);				end;				call RECORDER.DEPOSIT;		/* user typed ok so do a ripple edit */				call DISPLAY.RIPPLE.MESSAGE(1);	/* indicate Executed Succesfully */			end;			ripple.edit=0;	/* reset to step one for next call */			call POS.RECORDER.CURSOR;		end;		else do;		/* STEP 1: TIME JUST TYPED */			do i = 0 to 6;				/* save time value */				tmp.tok(i) = token(i);			end;			token(0)=0;					/* reset token so user can type 'OK' */			call erase.rest.of.line(23,0);			call cpos(23,0);			call ps('Type OK and press <RETURN> to Perform Ripple Edit ->');			ripple.edit=1;				/* set to step 2 for next call */			return 0;					/* do not move yet */		end;	end;	else call RECORDER.DEPOSIT;	return 1;end ripple.deposit;RECORDER.DISPLAY.INPUT: proc(in.cmd,in.arg) swapable;	/* Process Input Chars on Recorder Display */	dcl (in.cmd,in.arg)	fixed;	dcl (i,j,k,ch)			fixed;	do case (in.cmd);							/* do depending upon input command */		do;										/* 0: character input */			if (in.arg>=lower.a) and (in.arg<=lower.z) then in.arg=in.arg-"40";	/* convert to uppercase */			if (in.arg=asc.h and token(0)=0) then do;	/* h => print hardcopy of screen */				if D40_PRESENT<>0				/* if device available */				then call SCREEN_DUMP;				else call no.printer;				call POS.RECORDER.CURSOR;				return;			end;			if (in.arg<>esc) and (err.displayed<>0) then do;				call remove.err;				call PRINT.CCAT;	/* reprint current cat name */			end;			if in.arg=esc then do;						/* ESC: return to Main Menu */				if ripple.deposit<>0 then do;					call RETURN.TO.PREV.STATE;					return;				end;			end;			else if (in.arg = asc.great) then do;	/* >: jump to sequence editor */				if ripple.deposit<>0 then do;					GOTO.THIS.SCREEN = 30;				/* want to go to sequence editor */					call RETURN.TO.PREV.STATE;					return;				end;			end;			else if (in.arg=cret) then do;			/* return */				call ripple.deposit;			end;			else if (in.arg=home) then do;			/* home */				if ripple.deposit<>0 then do;					trrow=0; trfld=0;						/* init row & column for same track */					call UPDATE.MODE.SELECTION;		/* move highlighted selection if necessary */				end;			end;			else if (in.arg=r.arr) then do;			/* right-arrow */				if ripple.deposit<>0 then do;					if trrow<=(-1) then do;				/* in track select field or options field */						if trcol=2 then trcol=0;						else            trcol=trcol+1;						call UPDATE.MODE.SELECTION;	/* move highlighted selection if necessary */					end;					else if trfld=2 then do;			/* select next track if left column already */						trfld=0;						if trcol=2 then trcol=0;						else            trcol=trcol+1;					end;					else trfld=trfld+1;					/* else just next column */				end;			end;			else if (in.arg=l.arr) then do;			/* left-arrow */				if ripple.deposit<>0 then do;					if trrow<=(-1) then do;				/* in track select field or options field */						if trcol=0						then trcol=2;						else trcol=trcol-1;						call UPDATE.MODE.SELECTION;	/* move highlighted selection if necessary */					end;					else if trfld=0 then do;			/* column 0 - move to col 2 */						trfld=2;						if trcol=0						then trcol=2;						else trcol=trcol-1;					end;					else trfld=trfld-1;					/* else just change column */				end;			end;			else if (in.arg=u.arr) then do;			/* up-arrow */				if ripple.deposit<>0 then do;					if (trrow=(-1) and show.modes=false)					or (trrow=(-3))  					then do; 						call SCROLL.BACK.1.LINE(loc(addr(rdis.time.msb)));	/* step backwards 1 line */						/* Force a screen update when we scroll back: */						new.ABLE.seq.info = new.ABLE.seq.info \ 4;					end;					else do;						if (trrow>(-3)) 						then trrow=trrow-1;						call UPDATE.MODE.SELECTION;	/* move highlighted selection if necessary */					end;				end;			end;			else if (in.arg=d.arr) then do;			/* line feed/down-arrow */				if ripple.deposit<>0 then do;					if trrow<9 then do;						trrow=trrow+1;						call UPDATE.MODE.SELECTION;	/* move highlighted selection if necessary */					end;					else do;						call SCROLL.FORWARD.SOME.LINES(trd.ptr+3, 3, loc(addr(rdis.time.msb)), 5);	/* scroll display down */						trrow = 5;	/* reposition cursor to note after the one that was on the bottom line */					end;				end;			end;			else if in.arg="20" then call START.SEQUENCER;	/* CTRL-P: START Recorder (P -> Play) */			else if in.arg="05" then call STOP.SEQUENCER;	/* CTRL-E: STOP Recorder (E -> End Play) */			else if in.arg="03" then do;				if (update.finished) then do;						/* only do this if snapshot is valid */					call FIND.NON.BLANK.ROW;						/* jump cursor to non-blank row if one */					if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)		/* see if note on line */					then call SCROLL.SEQ(#nmsb, #nlsb, 1);		/* move seq to cursor pos */				end;				call CONTINUE.SEQUENCER;	/* CTRL-C: CONTINUE Recorder */			end;			else if in.arg="06" then call FAST.FORWARD.SEQUENCER;	/* CTRL-F: FAST FORWARD Recorder */			else if in.arg="22" then call REWIND.SEQUENCER;			/* CTRL-R: REWIND Recorder */			else if (in.arg=asc.plus)		/* plus: append note after current note */			and     (trrow>=0)				/* not in track select field */			and     (trfld<>2)				/* and not in duration field */			and     (token(0)=0)				/* and not mid-token */			then do;				call SAVE.TRK.FOR.UNDO;		/* save copy of current trk */				i=CREATE.NEW.NOTE(0);		/* append note after current pos */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */				then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */			end;			else if (in.arg=asc.min)		/* minus: insert note before current note */			and     (trrow>=0)				/* not in track select field */			and     (trfld<>2)				/* and not in duration field */			and     (token(0)=0)				/* and not mid-token */			then do;				call SAVE.TRK.FOR.UNDO;		/* save copy of current trk */				i=CREATE.NEW.NOTE(1);		/* insert note before current pos */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */				then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */			end;			else if (in.arg=asc.tilde)		/* tilde: create an ilp on this track */			and     (trrow>=0)				/* not in track select field */			and     (token(0)=0)				/* and not mid-token */			then do;				call SAVE.TRK.FOR.UNDO;		/* save copy of current trk */				i=CREATE.NEW.NOTE(2);		/* create an ilp at this time */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */				then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */			end;			else if (in.arg=asc.star)		/* star: create an rte note on this track */			and     (trrow>=0)				/* not in track select field */			and     (token(0)=0)				/* and not mid-token */			then do;				call SAVE.TRK.FOR.UNDO;		/* save copy of current trk */				i=CREATE.NEW.NOTE(3);		/* create an rte note at this time */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */				then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */			end;			else if (in.arg=asc.lbr)		/* [ : set start of edit region to this spot */			and     (trrow>=0)				/* not in track select field */			and     (token(0)=0)				/* and not mid-token */			then do;				call load.seq.globals.from.snapshot;				call pid(sav.time1.ms, #nmsb);				call pid(sav.time1.ls, #nlsb);				if ( #nmsb igt gid(sav.time2.ms))				or ((#nmsb  =  gid(sav.time2.ms))				and (#nlsb ige gid(sav.time2.ls)))	/* BUG FIX, IGE WAS IGT */				then do;							/* make sure edit end is > edit start */					write("313")	= #nlsb+1;					call pid(sav.time2.ls, read("313"));					if (read("313") == 0)					then call pid(sav.time2.ms, #nmsb+1);					else call pid(sav.time2.ms, #nmsb);				end;				call UPDATE.TRACK.DISPLAY((2\4\8),1);			end;			else if (in.arg=asc.rbr)		/* ] : set end of edit region to this spot */			and     (trrow>=0)				/* not in track select field */			and     (token(0)=0)				/* and not mid-token */			then do;				call load.seq.globals.from.snapshot;				call add16(1, loc(addr(#nmsb)));	/* add 1 msec. so this note will be included in the edit region */				call pid(sav.time2.ms, #nmsb);				call pid(sav.time2.ls, #nlsb);				if ( #nmsb ilt gid(sav.time1.ms))				or ((#nmsb  =  gid(sav.time1.ms))				and (#nlsb ilt gid(sav.time1.ls)))				then do;							/* make sure edit end is > edit start */					call pid(sav.time1.ls, #nlsb-1);					if (#nlsb == 0)					then call pid(sav.time1.ms, #nmsb-1);					else call pid(sav.time1.ms, #nmsb);				end;				call UPDATE.TRACK.DISPLAY((2\4\8),1);			end;			else if (in.arg=asc.sharp)		/* #: set track # to current record track */			and     (trrow=-1)				/* in track select field */			and     (token(0)=0)				/* and not in mid-token */			then do;								/* stuff current record trk into token & deposit */				recd.col = trcol;				trkindex(trcol)=recd.trk;			/* put record track into index */				call REDRAW.TRACK.TITLE(trcol);	/* print new track number, timbre name, smpte label */				new.ABLE.seq.info = new.ABLE.seq.info \ 4;	/* snap shot */			end;			else if (in.arg = c.u) then do;	/* ctrl-u: undo last operation */				if (undo.enabled) & (saved.trk <> 0) then do;					call Fast.Copy(saved.trk, undo.tmp.trk);	/* move most recently changed track to undo.tmp.track (so redo can be done) */					call Fast.Copy(undo.trk, saved.trk);		/* recall track - undo last operation */					call Fast.Copy(undo.tmp.trk, undo.trk);	/* move undo.tmp.trk to undo.trk  (so redo can be done) */					call Erase.Track(undo.tmp.trk);				/* don't need to use up notespace... */					if ((TRK.HEAD.LOOKUP(undo.trk, thd.ignore) & THD.IGNORE.IGNORE) == 0) then do;	/* make sure this is set */						WRITE(MD) = READ(MD) | THD.IGNORE.IGNORE;						call COMPUTE.ACTIVE.TRKS;					end;					call Play.Initialize;				end;			end;			else if (in.arg=DEL) or (in.arg="32") then do;	/* delete/ctrl-z: do some delete function */				if token(0)<>0				then do;													/* non-empty token */					token(0)=token(0)-1;					if token(0)<>0					then do;						call pc(bs); call pc(sp);	/* print over with space */					end;					else do; 						if ripple.edit<>0 then do;	/* CANCEL EDIT */							call ERASE.RIPPLE.PROMPT;							ripple.edit=0;						end;						if trrow=(-1) then call REDRAW.TRACK.TITLE(trcol);						else call RE.UPDATE.TRACK.DISPLAY;					end;				end;				else do;							/* empty token: remove note or de-select this track */					if ripple.edit<>0 then do;						call ERASE.RIPPLE.PROMPT;						ripple.edit=0;					end;					else if (trrow>=0) then do;					/* not in track select field */						call SAVE.TRK.FOR.UNDO;						/* save copy of current trk */						call DELETE.CURRENT.NOTE;					/* erase note at cursor pos */						/*if trrow=0 then trrow=1;*/				/* make multiple deletes easier (MY ASS!) */						call FIND.NON.BLANK.ROW;					/* jump cursor to non-blank row if one */						if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0)	/* see if note on line */						then call SCROLL.SEQ(#nmsb, #nlsb, 1);	/* move seq to cursor pos */					end;					else if (trrow=-1) then do;					/* de-select this track */						trkindex(trcol)=0;							/* no track selected */						if (trcol=recd.col) then recd.col=-1;	/* disable record track feature if active */						call REDRAW.TRACK.TITLE(trcol);			/* fix track heading */						new.ABLE.seq.info = new.ABLE.seq.info \ 4;	/* snap shot */					end;				end;			end;			else if in.arg=sp then do;					/* space */				if not ((trfld=1) and (trrow>-1))			/* IF NOT OVER PITCHES */				then do;					call UPDATE.MODE.SELECTION;				/* move highlighted selection if necessary */					call TOGGLE.STATES;					if not ((trrow<=-2) and (trcol=2))		/* IF TOGGLING ANYTHING OTHER THAN "Note Ripple" OR "UNDO Enabled" */					then do;						do i=0 to 2;								/* relabel tracks for new timbres */							if trkindex(i)<>(0)					/* if active track                */							then call REDRAW.TRACK.TITLE(i);	/* print track number, timbre name, smpte label */						end;						new.ABLE.seq.info = new.ABLE.seq.info\8;	/* mode change - redraw entire screen */					end;				end;			end;			else if in.arg=tab then do;		/* tab/control-i: toggle what is shown up top */				if ripple.deposit<>0 then do;					show.modes=show.modes xor 1;					#msb = trrow;					/* temp, save for swap */					#lsb = trcol;					trrow = sav.trrow;					trcol = sav.trcol;					sav.trrow = #msb;					sav.trcol = #lsb;					call ERASE.INSTRUCTIONS;					call PRINT.INSTRUCTIONS;				end;			end;			else if in.arg=c.x then do;	/* CONTROL-X: ABORT ENTRY/REPEAT ENTRY */				if trrow>-1 then do;					if token(0)<>0 then do;	/* ABORT ENTRY */						saved.token.length=token(0);	/* save for possible repeat */						token(0)=0;						call POS.RECORDER.CURSOR;						call RE.UPDATE.TRACK.DISPLAY;					end;					else do;						/*REPEAT ENTRY */						token(0)=saved.token.length;						call ps(token);					end;				end;			end;/*   U S E   T H E   F O L L O W I N G   C A S E   L I S T   W H E N   T H E   E D I T   F U N C T I O N S   A R E   R E A D Y   */			else if in.arg ige asc.fkey1 then do case in.arg-asc.fkey1; /* SPECIAL FUNCTION KEYS */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0) then call TRANSPOSE.NOTE( -1, 0);	/* CASE 0: F5  */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0) then call TRANSPOSE.NOTE(  1, 0);	/* CASE 1: F6  */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0) then call TRANSPOSE.NOTE(-12, 0);	/* CASE 2: F7  */				if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0) then call TRANSPOSE.NOTE( 12, 0);	/* CASE 3: F8  *///				;																									/* CASE 4: F9  *///				;																									/* CASE 5: F10 *///				;																									/* CASE 6: F11 *///				;																									/* CASE 7: F12 *///				;																									/* CASE 8: Shift-F5  *///				;																									/* CASE 9: Shift-F6  *///				;																									/* CASE10: Shift-F7  *///				;																									/* CASE11: Shift-F8  *///				;																									/* CASE12: Shift-F9  *///				;																									/* CASE13: Shift-F10 *///				;																									/* CASE14: Shift-F11 *///				;																									/* CASE15: Shift-F12 */			end;			else if in.arg>sp then do;						/* a non-space char */				if token(0)=0 then saved.token.length=0;	/* when a new token is started, the previous one is no longer repeatable */				if token(0)<recmax then do;				/* accept input     */					call pbyte(token,token(0),in.arg);	/* store character in word */					token(0)=token(0)+1;				end;			end;			call POS.RECORDER.CURSOR;		end;								/* of character input */		;									/* 1: absolute select */		;									/* 2: scroll down */		;									/* 3: scroll up */		call RETURN.TO.PREV.STATE;	/* 4: return to previous screen */	end;									/* of do case input command */end RECORDER.DISPLAY.INPUT;RECORDER.DISPLAY.MOUSE.POS:  proc(x,y) swapable;	/* Recorder Display Mouse Positioner*/	dcl (x,y) fixed;	/* mouse position in row/col coordinates */	dcl (r,c) fixed;	dcl (row,col,field) fixed;	if ripple.deposit<>0 then do;		if mouse.hole(x,y) then do;						/* if exit condition */			call RECORDER.DISPLAY.INPUT(in.rtps,0);	/* return to previous screen */			return;		end;		if err.displayed<>0 then do;			call REMOVE.ERR;				/* remove any error */			call PRINT.CCAT;				/* show current cat name */			call POS.RECORDER.CURSOR;	/* reposition the cursor */		end;		/* convert the mouse pixel coordinates to screen coordinates */		x=CONVERT.MOUSE.X(x);	/* 0-79 */		y=CONVERT.MOUSE.Y(y);	/* 0-23 */		/* figure out row */		if (y ige 7) then do;				/* IF CLICKED BELOW MODE SELECT PANEL */			/* figure out col */			load x;div colwidth/*27*/;col=res;			if (y ige 12) then do;			/* IF CLICKED IN THE NOTE AREA */				row = y-12;				if row > 9 then row = 9;	/* limit to bottom of screen */				/* figure out field */				if disp.mode ile 2 then do;	/* SECONDS, BEATS OR MEAS:BEATS */					if ( x < secndcol(1)+(col*colwidth))					then field = 0;					else if ( x < secndcol(2)+(col*colwidth))					then field = 1;					else field = 2;				end;				else do;								/* SMPTE OR FEET:FRAMES */					if ( x < smptecol(1)+(col*colwidth))					then field = 0;					else if ( x < smptecol(2)+(col*colwidth))					then field = 1;					else field = 2;				end;				trrow=row; trcol=col; trfld=field;			end;			else do;								/* IF CLICKED IN THE TRACK TITLES AREA */				trcol=col;				trrow=-1;						/* track # row */			end;			call POS.RECORDER.CURSOR;		end;		else if (show.modes<>0) then do;			if (y=5 or y=6) then do;				/* figure out col */				load x;div 30;col=res;	/* NO NEED FOR FIELDS */				if (y=5) then row = -3;				/* top line of mode selection row */				else row = -2;							/* second line of mode selection row */				r=trrow;c=trcol;						/* store cursor position */				trrow=row;trcol=col;					/* set up globals */				call RECORDER.DISPLAY.INPUT(in.chin,sp);	/* make it look like a space was hit */				trrow=r;trcol=c;						/* restore cursor position */				call POS.RECORDER.CURSOR;			end;			else if (y ige 1 and y ile 3) then do;				/* figure out col */				if x ilt 34 then col=0;else if x ilt 53 then col=1;else col=2;	/* NO NEED FOR FIELDS */				do case y-1;					do case (col);	/* CASE 0: y=1 */						call RECORDER.DISPLAY.INPUT(in.chin,sp);			/* 0 => make it look like a space was hit */						call RECORDER.DISPLAY.INPUT(in.chin,asc.min);	/* 1 => make it look like a minus sign was hit */						;																/* 2 => nothing for now, maybe input rte types? */					end;					do case (col);	/* CASE 1: y=2 */						call RECORDER.DISPLAY.INPUT(in.chin,tab);			/* 0 => make it look like a tab was hit */						call RECORDER.DISPLAY.INPUT(in.chin,asc.plus);	/* 1 => make it look like a plus sign was hit */						;																/* 2 => nothing for now, maybe input rte types? */					end;					do case (col);	/* CASE 2: y=3 */						call RECORDER.DISPLAY.INPUT(in.chin,asc.tilde);	/* 0 => make it look like a tilde was hit */						call RECORDER.DISPLAY.INPUT(in.chin,asc.star);	/* 1 => make it look like an asterisk was hit */						;																/* 2 => nothing for now, maybe input rte types? */					end;				end;			end;		end;		else do;		/* showing regular instructions */			if (y=5) and (x ige 14) and (x ile 18)			then call RECORDER.DISPLAY.INPUT(in.chin,tab);		/* make it look like a tab was hit */			else if (y=6) and (x ige 42) and (x ile 48)			then call RECORDER.DISPLAY.INPUT(in.chin,esc);		/* make it look like an escape was hit */			else if (y=3) and (x ige 16) and (x ile 23)			then call RECORDER.DISPLAY.INPUT(in.chin,del);		/* make it look like a delete was hit */			else if (y=2) and (x ieq 16)			then call RECORDER.DISPLAY.INPUT(in.chin,asc.sharp);	/* make it look like a # was hit */			else if (y=6) and (x ieq 16)			then call RECORDER.DISPLAY.INPUT(in.chin,asc.h);	/* make it look like an H was hit */		end;	end;	/* of "if ripple.deposit<>0" */end RECORDER.DISPLAY.MOUSE.POS;