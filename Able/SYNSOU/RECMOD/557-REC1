/* :SYNSOU:RECMOD:557-REC1  $TITLE  Routines to Run Recorder Display (Part 3 of 4) *//*Modified:2002/09/08 - TY  - Added safeguard to EDIT.NOTE.START() to prevent negative times returned by SMPTE.TO.MSEC()						 from causing the system to hang.1999/04/05 - TY  - Removed some stray do-nothing code.1998/05/20 - TY  - Made entry of Beats and Meas:Beats work correctly when using a Live Click Track.					  - Unused variables removed from EDIT.NOTE.DURATION: BPM, RATE (passed argument).					  - Unused variable removed from EDIT.NOTE.START: RATE (passed argument).					  - Modified CREATE.NEW.NOTE so that the default loop length will be set correctly when using a						 Live Click Track. 1998/05/18 - TY  - Added "or RAM.EVENTS.DISPLAYED<>0" to the conditional in the "if timbre changed on a track"						 block of UPDATE.TRACK.DISPLAY because RAM event durations and endtimes can change as a result						 of a timbre change, regardless of whether soundfile offsets or soundfile names are displayed.1998/05/16 - TY  - Substituted call to SCALE.RTE.VAL passing 1, to call to SCALE.PERCENT.TO.RTE.1998/05/07 - TY  - Changed CREATE.NEW.NOTE so that the default loop length is set according to the meter map.1998/05/01 - TY  - Changed the "add rte" part of CREATE.NEW.NOTE so that if the cursor rests on an existing						 RTE, that RTE is duplicated rather than the previous RTE created or the default.					  - Added a call to COMPUTE.DEFAULT.NOTE in CREATE.NEW.NOTE so that duration will default to						 sound file length.					  - Deleted 3 unused variables from CREATE.NEW.NOTE.1998/04/21 - TY  - Removed unnecessary variable from EDIT.NOTE.PITCH.1998/04/19 - TY  - Removed (commented out) a line that caused CREATE.NEW.NOTE to create a normal note when						 no others were found despite the user requesting and RTE or loop.  Changed the default						 loop length from 4 to "SAMP.BPM".  Changed the default pitch from C1 to A3.  Added						 "isa.ilp.note" check so that Loop Start or Loop End will not be duplicated with "-" or "+".1998/04/14 - TY  - Added a line to UPDATE.TRACK.DISPLAY that forces a redraw of notes if a timbre is changed						 on a track while "show offsets" is in use.1998/04/13 - TY  - Rewrote the scaling algorithm in the pitch bend block of EDIT.RTE.VALUE to have the						 following rounding characteristics:						 1) for even divisors, a value at the halfway point will round up.						 2) for negative values, "rounding up" means more negative.					  - Also rewrote the algorithm in the pitchbend block of EDIT.RTE.VALUE that limits the						 input value if it exceeds "pitch.bend.range".  The original algorithm failed when						 "pitch.bend.range" was outside the range of -16384 TO 16383.1998/04/09 - TY  - Added an else clause to UPDATE.TRACK.DISPLAY to strip bit 8 (256) off of "info" if the						 "record track" feature is not in use.					  - Also disabled (commented out) an "if" block in UPDATE.TRACK.DISPLAY that caused all						 three track titles to be reprinted whenever a constant was changed (click, speed, etc.).1991/05/17 - PF  - changed MIDI program numbers from 1-128 to 0-1271991/04/02 - PF  - Removed prescan offset for rtes on input and display1990/11/06 - PF  - Screen support for new sustain update record1990/08/27 - PF  - Support all MIDI controllers1989/10/04 - cj  - performed tempo mapping for time displays1987/02/11 - eeg - modified to work with tformmod,mathmod1987/01/19 - eeg - added verify state to ripple1987/01/16 - eeg - bug fixes for m-beta; zero.time bug with end time;1987/01/07 - eeg - now assumes user is in the same hour when entering smpte end time1986/11/14 - eeg - added code to ripple back...1986/11/07 - eeg - ILT bug fix in scroll.back.5.lines1986/11/07 - eeg - combined new recorder display features w/ existing code1986/09/03 - EEG - added better error message for inverse loops1986/07/25-eeg,tss-fixes in change.note.duration and change.note.start1986/07/24 - eeg - ilp fixes, added ability to create an ilp on a track1986/07/14 - cj  - allowed scrolling while playing1986/07/14 - eeg - removed restrictions on editing while recording1986/07/14 - eeg - added code to change start time for ilp start or end notes1986/06/23 - eeg - modifications to edit.note.xxxx routines1986/06/16 - eeg - changed some calls to print.track.row to redraw.track.title1986/05/22 - BSW - Character input changes1986/05/19 - eeg - made procedures and some variables public.1986/05/15 - "official" creation of release-M modules*//* $PAGE - FILL IN TRACK DISPLAY FOR NEW CHANGES */UPDATE.TRACK.DISPLAY:  proc(info,update.current.line) swapable;	/* called from main loop when new seq info event is reported. */	dcl (info)						fixed;	/* bits from next.event.info */	dcl (update.current.line)	fixed;	/* 1 to force update of trrow, trcol */	dcl (row,trk) fixed;	update.compare:proc(row,trk,update.current.line);		dcl (row,trk,k,l)			fixed;		dcl update.current.line	fixed;		dcl rec.buf(15)			fixed;		write(mam) = trd.ptr+trk;		write(mal) = index.start+row;		if read(md) = 0 then do;						/* current line should be blank */			write(mam) = trd.ptr+3+trk;				/* compare w/ old entry for this space */			write(mal) = 16*row;			if (read(md)<>0)								/* if old entry is not blank */			or ((update.current.line<>0)			and (row=trrow)			and (trk=trcol))			then do;				write(md) = 0;								/* zero out old entry */				call erase.entry(row,trk);				/* clear out entry on screen */			end;		end;		else do;												/* compare old and new entries */			write(mal) = read(md);						/* extract pointer to new entry */			if (inc.poly<>0) or (modc<>0) then do;	/* test for faster way */				write("300") = addr(rec.buf(0));				rpc 16;				write("360") = read(mdi);			end;			else do k = 0 to 15;				rec.buf(k) = read(mdi);			end;			if (rec.buf(5) & "174001") = "110001" then do;	/* ilp end */				#nmsb = rec.buf(1);				#nlsb = rec.buf(2);				if  ((#nmsb ilt Screen.End(0)))	/* if before end of screen... */				or  ((#nmsb  =  Screen.End(0))				and  (#nlsb ilt Screen.End(1)))				then do;									/* then make ilp end the end of the screen to force update */					Screen.End(0)=#nmsb;					Screen.End(1)=#nlsb;					call Map.Sequence.Time.To.Real.Time(Screen.End,Screen.Scroll.End);				end;			end;			/* check current image */			write(mam) = trd.ptr+3+trk;			write(mal) = 16*row;			if (read(md)=0)					/* if this line was empty */			or ((mode.change&8)<>0)			/* or mode/const change   */			or ((update.current.line<>0)			and (row=trrow)			and (trk=trcol))			then do;				write(mam) = trd.ptr+trk+3;	/* point to old snapshot area */				write(mal) = 16*row;				do k = 0 to 15;					write(mdi) = rec.buf(k);	/* update the old note info with new note info */				end;				call print.recorder.info(rec.buf,row,trk);	/* print entire row */			end;			else do;									/* must compare */				k = 0;				l = 0;				do while ((l=0) and (k<14));	/* compare until done or a difference is found */					if (rec.buf(k) <> read(mdi)) then l=1;	/* only compare entries up to 13 */					k = k+1;				end;				if (l<>0) then do;					write(mam) = trd.ptr+trk+3;	/* point to old snapshot area */					write(mal) = 16*row;					do k = 0 to 15;						write(mdi) = rec.buf(k);	/* update the old note info with new note info */					end;					call print.recorder.info(rec.buf,row,trk);				end;			end;		end;	end update.compare;	if (recd.col <> -1) then do;	/* a track has been set to show current record track */		if (trkindex(recd.col) <> recd.trk) then do;			trkindex(recd.col) = recd.trk;			info = info \ 2 \ 4;		/* force redraw of titles and notes */		end;	end;	else info=info & not 256;		/* IF THE RECORD TRACK FEATURE IS NOT IN USE, THEN WE ARE NO LONGER												CONCERNED WITH THE FACT THAT A TRACK SOLO HAS CHANGED */	if (info&1)<>0						/* sequence recalled     */	then do;		call sample.sequence.time;	/* reset time base       */		info = info \ 2				/* redraw timbre names   */						\ 4				/* redraw notes          */						\ 8				/* mode change as well   */					 xor 1;				/* turn off new seq bit  */	end;	if (info&2)<>0						/* if timbre changed on a track, draw new track titles */	then do;		call redraw.track.titles;	/* redraw all titles */		info = info xor 2;		/* also force redraw of notes if "show offsets" is on,			RAM event durations or endtimes are being displayed,			or if displaying soundfile names */		if (SHOW.OFFSETS<>0) or (third.fld ieq 3) or (RAM.EVENTS.DISPLAYED<>0) then info=info\8;			end;	if info=0 then return;			/* done with update       */	/* update note section of recorder display */	mode.change = info;				/* get mode change bits   */	call our.recorder.snap.shot;	/* get snap shot of notes */	call CHECK.NEXT.EVENT;	update.finished = false;		/* reset this flag, we need to know when we're done updating */	do row = 0 to 9;		do trk = 0 to 2;			if (num.of.d50.in.chars<>0) then do;			/* if a character has been typed, exit */				new.ABLE.seq.info = new.ABLE.seq.info \ mode.change;	/* set bits to return here */				new.ABLE.in.char = 1;	/* this is set here so that the character         */												/* will be processed before the new.ABLE.seq.info */												/* in getsou                                      */				if update.current.line<>0				then call update.compare(trrow,trcol,1);				return;			end;			call update.compare(row,trk,update.current.line);		end;								/* trk = 0 to 2 */		call CHECK.NEXT.EVENT;			/* once per row */	end;									/* row = 0 to 9 */	update.finished = true;	call CHECK.NEXT.EVENT;	call draw.stars;	call CHECK.NEXT.EVENT;END UPDATE.TRACK.DISPLAY;RE.UPDATE.TRACK.DISPLAY:  proc swapable;	/* called after edit to update screen */	dcl info fixed;	/* First, send an event out to any remote devices that might */	/* be interested in the new.seq event.  Also set the bits in */	/* new.ABLE.seq.info correctly:										 */	call PERFORM;	info = (new.ABLE.seq.info & (1\2\4\8)) \ 4;	/* force snapshot/scan even if error message only */	new.ABLE.seq.info = new.ABLE.seq.info & not(info);	call UPDATE.TRACK.DISPLAY(info,1);end RE.UPDATE.TRACK.DISPLAY;/*  $SUBTITLE - Routine to Jump Cursor to Nearby Note */FIND.NON.BLANK.ROW:  proc swapable;	/* sets TRROW to jump cursor to nearby note */	dcl (i,found) fixed;	if trrow = -1 then return;	write(mam)=trd.ptr+trcol+3;	write(mal)=trrow*16;	if read(md)=0 then do;		i=trrow+1; found=false;		do while (i ilt 10) and (found=false);			write(mal)=i*16;			if read(md)<>0 then do;				trrow=i;				found=true;			end;			i=i+1;		end;		if found=false then do;			i=trrow-1;			do while (i>=0) and (found=false);				write(mal)=i*16;				if read(md)<>0 then do;					trrow=i;					found=true;				end;				i=i-1;			end;		end;	end;end FIND.NON.BLANK.ROW;/* $SUBTITLE  Routine to Insert or Append Note to Sequencer */CREATE.NEW.NOTE: proc (note.type) swapable;	/* create note before or after current note */	dcl note.type			fixed;	/* set to 3 to create an rte note, 2 to create an ilp, 1 to insert normal note before, 0 to append after */	dcl (msb,lsb)			fixed;	/* KEEP IN ORDER */	dcl (i,j,found,tmp)	fixed;	dcl m(2)					fixed;	/* FOR METER-MAP SAVVY LOOP END TIME CALCULATION */	if (trkindex(trcol)=0) then do;				/* if no track is selected */		call NO.EDIT.ALLOWED;		return 0;	end;	write(mam)=trk.head;	write(mal)=trkindex(trcol);	if (read(md)=0) then do;						/* if there are no notes on this track yet */		if ALLOCATE.TRK.HEADER(trkindex(trcol))=0 then do;	/* create track header */			call NOMEM.ERROR;			return 0;		end;		call COPY.TIMBRE(0,trkindex(trcol));	/* put keyboard timbre on this track */	end;	found=0;	i=LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;			/* see if note on line */	if i<>0 then do;									/* this will do fine   */		msb=#nmsb;		lsb=#nlsb;		found=1;											/* really found it     */		if (note.type=0) then do;					/* append after current note */			call ADVANCE.TO.NEXT.NOTE;			if trrow<9 then trrow=trrow+1;		/* move cursor to that note  */		end;	end;	else do;												/* find time from track      */		tmp=trcol; j=0;		do while (found=0);			i=LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;	/* try to find time for current row in other columns */			if i<>0 then do;				found=1;									/* 1=> really found a note */				msb=#nmsb;								/* time of note to insert  */				lsb=#nlsb;			end;			else do;				j=j+1;									/* not found, try next column */				trcol=trcol+1;				if trcol>2 then trcol=0;				if (trkindex(trcol)=0) then do;	/* if no notes in this column, skip it */					j=j+1;								/* not found, try next column */					trcol=trcol+1;					if trcol>2 then trcol=0;				end;				if j=3 then do;						/* no time on any col for this row */					if trrow<>0 then do;				/* back up one row            */						trrow=trrow-1;						j=0;								/* search this row            */					end;					else do;								/* if trrow=0, then must be empty sequence */						msb=0; lsb=zero.time;		/* stick a note at 0.000      */						found=2;							/* 2 => didn't really find it */						/* note.type=1; */			/* WHY NOT GIVE THE USER THE TYPE OF NOTE REQUESTED? */					end;				end;			end;		end;		if found=1 then call LOOK.UP.NOTE.INFO;	/* load #w1-#w4 */		trcol=tmp;		call LOAD.SEQ.GLOBALS(trkindex(trcol));	end;	if (msb=0)&(lsb ilt zero.time)	/* zero.time correction */	then lsb=zero.time;	if (note.type=3) then do;			/* * - add rte note   */		if show.rte=false  then do;			show.rte=true;					/* force to true      */			if show.modes<>0 then do;				do.reverse=false;				call PRINT.RTE.FIELD;			end;		end;		if found<>false					/* if we found a note */		then tmp=isa.rte.note;			/* then see if it is an rte	(if so then duplicate) */		else tmp=false;					/* else it's not					(otherwise do the following) */		if tmp=false then do;			#w1=1;								/* zero time, indicate 4 word record */			if (oldw2\oldw3)<>0 then do;				#w2=oldw2;						/* make this the same as the last rte created */				#w3=oldw3;			end;			else do;				#w2=shl(2,8);					/* default to ModW, value=RTE.MAX */				#w3=rte.max\shl(b.upd,8);				oldw2=#w2;				oldw3=#w3;			end;			#w4=vel.note;		end;		call INSERT.NOTE.RECORD(msb,lsb);		if trrow<9 then trrow=trrow+1;	/* move cursor to that note */	end;	else if (note.type = 2) then do;		/* creating an ilp */		if play<>0 then do;			call no.edit.while.play;			return 0;		end;		call COPY32(loc(addr(play.time.msb)),						loc(addr(play.msb)));		call REMOVE.ILP.FROM.TRACK(trkindex(trcol));		call PLAY.INITIALIZE;		/* CREATE LOOP (METER-MAP AND CLICK TRACK SAVVY VERSION) */	   /* compute loop end time */				if Click.Track.Mode igt 3			/* live click track */		then do;			/* CALCULATE LOOP LENGTH IN "CLICK TRACK" MILLIBEATS */			load Lookup.Beats.Per.Measure(loc(addr(msb)));mul 1000;			/* CONVERT THIS TO SEQUENCE LOOP DURATION */			call Remap.With.Live.Click(msb,lsb,ures,res,2);			/* ADD SEQUENCE LOOP DURATION TO SEQUENCE LOOP START AND SAVE AS SEQUENCE LOOP END TIME */			call add32(loc(addr(msb)),loc(addr(Remapped.Dur.Msb)),m);		end;		else do;			call Map.Sequence.Time.To.Measures.Beats(loc(addr(msb)),m);			m(0)=m(0)+1;	/* add a measure */			call Map.Measures.Beats.To.Sequence.Time(m,m);		end;		call CREATE.ILP.ON.TRACK(trkindex(trcol),msb,lsb,m(0),m(1));		/* CREATE LOOP (METER-MAP AND CLICK TRACK UN-SAVVY VERSION) */		/*		tmp=SAMP.CLICK.RATE*SAMP.BPM;	/ * set loop duration to 1 measure * /		if (lsb ilt (lsb+(tmp)))		/ * overflow test * /		then call CREATE.ILP.ON.TRACK(trkindex(trcol),msb,lsb,msb,lsb+(tmp));		else call CREATE.ILP.ON.TRACK(trkindex(trcol),msb,lsb,msb+1,lsb+(tmp));		*/		call SCROLL.SEQ(play.msb,play.lsb,0);	/* move back to where we were before edit */	end;	else do;		if (found<>1) or (isa.ilp.note<>0)	/* didn't find a note, or the note found is a loop start or end */		then call COMPUTE.DEFAULT.NOTE(trkindex(trcol),loc(addr(msb)));		call INSERT.NOTE.RECORD(msb,lsb);	end;end CREATE.NEW.NOTE;/* $SUBTITLE  Routine to Delete Current Note from Recorder Display */DELETE.CURRENT.NOTE: proc swapable;		/* erase note at cursor loc */	write(mam)=trd.ptr+trcol+3;	write(mal)=trrow*16;	if (trkindex(trcol)=0) or (read(md)=0) then do;		call NO.EDIT.ALLOWED;		return 0;	end;	if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT=0 then do;	/* set up for next calls */		call NO.ADD.DELETE.ALLOWED;		return 0;	end;	if isa.ilp.note<>0						/* test for loop note record */	then call REMOVE.ILP.FROM.TRACK(trkindex(trcol));	else call REMOVE.NOTE.RECORD;	call RE.UPDATE.TRACK.DISPLAY;	/* so call to find.non.blank has new material to start from */	return 1;end DELETE.CURRENT.NOTE;/* $SUBTITLE  Routine to See if OK to Perform Edit Operation */CHECK.SNAP.SHOT: proc fixed swapable;	dcl i fixed;	/* This routine determines if it is OK to do a note edit on the current		cursor position of the Recorder Display.  It returns a 1 if it is ok		to perform the edit, or a 0 if no editing should be allowed.	*/	if (trkindex(trcol)=0) then do;		call NO.EDIT.ALLOWED;		return 0;	end;	if ((new.seq.info      & (1\4\8))<>0)	/* if seq recall, pointer/note change, constant change, mode change */	or ((new.ABLE.seq.info & (1\4\8))<>0)	then return 0;			/* not ok to try to change note info */	else return 1;			/*     ok to edit note info			 */end CHECK.SNAP.SHOT;EDIT.NOTE.START: proc swapable;	/* changes start time of note displayed under cursor */	dcl (msb,lsb)  fixed;	dcl (sec,msec) fixed;	/* KEEP IN THIS ORDER */	dcl (i,j)      fixed;	dcl time(4)    fixed;	/* will hold smpte times */	if CHECK.SNAP.SHOT<>0 then do;		if disp.mode=0 then do;										/* disp.mode = 0 => seconds */			if (CONV.STR.TO.SEC.MSEC(token,loc(addr(sec))) = 0)	/* try to parse a time */			then do;				call SEC.TO.MSEC(loc(addr(sec)),cf#time,loc(addr(msb)));				call Map.Real.Time.To.Sequence.Time(loc(addr(msb)), loc(addr(msb)));			end;			else i=0;									/* set error flag */		end;		else if (disp.mode=1 or disp.mode=2) then do;		/* disp.mode = 1=>beats, 2=>measures */			if CONV.STR.TO.BEATS(token,cf#time,0,disp.mode,loc(addr(sec))) = 0 then do;	/* try to parse a time */				if Click.Track.Mode igt 3							/* live click track */				then do;					call BEATS.TO.MSEC(loc(addr(sec)),cf#time,1000,loc(addr(msb)));					call remap.with.live.click(msb,lsb,0,0,0);					msb = remapped.time.msb;					lsb = remapped.time.lsb;				end;				else call Map.Beats.To.Sequence.Time(loc(addr(sec)),loc(addr(msb)));			end;			else i=0;								/* set error flag */		end;		else if (disp.mode=3) then do;							/* disp.mode = 3 => smpte */			call CONV.STR.TO.SMPTE(token,time);	/* read smpte start time */			call SMPTE.TO.MSEC(time,cf#time,samp.speed,S$Smode,S$Soffset,loc(addr(msb)));			//	wrap negative time to 24 hours later			if  (msb < 0)			{				if (SAMP.SPEED igt 20)				{					dcl wrap_24_hours		proc (fixed array) external;					wrap_24_hours(loc(addr(msb)));				}				else				{					msb	= 0;					lsb	= Zero.Time;				}			}			call Map.Real.Time.To.Sequence.Time(loc(addr(msb)), loc(addr(msb)));		end;		else if (disp.mode=4) then do;							/* disp.mode = 4 => feet:frames */			call CONV.STR.TO.FEET(token,time);			call FEET.TO.MSEC(time,cf#time,samp.speed,S$FMode,S$FOffset,loc(addr(msb)));			call Map.Real.Time.To.Sequence.Time(loc(addr(msb)), loc(addr(msb)));		end;	end;	if ertyp=0 then do;		if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT <> 0		then do;			/* CHECK FOR POSSIBLE OFFSET TIME */			if SHOW.OFFSETS<>0 THEN DO;				write(mam)=trd.ptr+3+trcol;				write(mal)=trrow*16+14;				i=read(mdi); j=read(md);				if  ((msb igt i))				or  ((msb  =  i)				and  (lsb ige j))				then do;					msb = msb-i;					if lsb ilt j then msb=msb-1;					lsb = lsb-j;				end;			end;			CHANGE.NOTE.START(loc(addr(msb)),ripple);		end;		else call NO.EDIT.ALLOWED;	end;end EDIT.NOTE.START;EDIT.NOTE.PITCH:     proc swapable;		/* changes pitch of note displayed under cursor */	dcl pitch fixed;	if CHECK.SNAP.SHOT<>0	then do;										/* ok to try to change note pitch */		pitch=CONV.STR.TO.KEY#(token);	/* try to read new pitch */		if ertyp=0 then do;			if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT <> 0			then do;				write(mam)=#ptr;				write(mal)=thd.cue.track;				if read(md)<>0 then call no.edit.allowed;				else if isa.ilp.note			/* can't edit pitch for ilp start or end */				then call CANT.EDIT.LOOP;				else call CHANGE.NOTE.PITCH(pitch);			end;			else call NO.EDIT.ALLOWED;		end;	end;end EDIT.NOTE.PITCH;EDIT.NOTE.DURATION: proc swapable;	/* changes duration of note displayed at trcol and trrow */	dcl (msb,lsb,duration)	fixed;	dcl (sec,msec)				fixed;	dcl time(5)					fixed;	/* will hold smpte times */	dcl notetime(1)			fixed;	dcl endtime(1)				fixed;	dcl xbuf(5)					fixed;	/* Get some information about the note handy in case we are */	/* doing some tempo mapping or editing end times:				*/	if CHECK.SNAP.SHOT<>0 then do;		if disp.mode=0 then do;									/* disp.mode = 0 => seconds */			if (CONV.STR.TO.SEC.MSEC(token,loc(addr(sec))) = 0)	/* try to parse a time */			then call SEC.TO.MSEC(loc(addr(sec)),third.fld<>2,loc(addr(msb)));		end;				else if (disp.mode=1 or disp.mode=2) then do;	/* disp.mode = 1=>beats, 2=>measures */			call LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;			/* try to parse a time */			if CONV.STR.TO.BEATS(token,third.fld<>2,Lookup.Beats.Per.Measure(loc(addr(#nmsb))),disp.mode,loc(addr(sec))) = 0 then do;				if Click.Track.Mode igt 3					/* live click track */					then do;					call BEATS.TO.MSEC(loc(addr(sec)),third.fld<>2,1000,loc(addr(msb)));					if third.fld=2					then do;										/* map end time     */						call REMAP.WITH.LIVE.CLICK(msb,lsb,0,0,0);						msb = remapped.time.msb;						lsb = remapped.time.lsb;					end;					else do;										/* map duration     */						call REMAP.WITH.LIVE.CLICK(#nmsb,#nlsb,msb,lsb,2);						msb = remapped.dur.msb;						lsb = remapped.dur.lsb;					end;				end;				else do;					if third.fld=2								/* end time */					then call Map.Beats.To.Sequence.Time(loc(addr(sec)),loc(addr(msb)));					else call Map.Beats.To.Sequence.Duration(loc(addr(#nmsb)),loc(addr(sec)),loc(addr(msb)));				end;			end;		end;		else if disp.mode=3 then do;							/* disp.mode = 3 => smpte */			if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT <> 0			then do;				/* get smpte start time of note handy in case user is */				/* typing in just a smpte end time without the hours  */				/* field available:												*/				call MSEC.TO.SMPTE(loc(addr(#NMSB)),cf#time,samp.speed,										 S$Smode, S$Soffset, xbuf);				call CONV.STR.TO.SMPTE(token,time);		/* read smpte time */				if third.fld=2 then do;						/* showing end time, use start time hrs,min */					if time(0)=0 then time(0)=xbuf(0);					if time(1)=0 then time(1)=xbuf(1);				end;				call SMPTE.TO.MSEC(time,third.fld<>2,samp.speed,S$Smode,S$Soffset,loc(addr(msb)));			end;		end;		else do;														/* disp.mode = 4 => feet:frames */			call CONV.STR.TO.FEET(token,loc(addr(sec)));			call FEET.TO.MSEC(loc(addr(sec)),third.fld<>2,samp.speed,S$FMode,S$FOffset,loc(addr(msb)));		end;		/* Now convert to sequence times if we need to: */		if  (disp.mode <> 1)			/* if not showing beats or measures, */		and (disp.mode <> 2)			/* then process a real time input:   */		then do;			if third.fld = 2			/* if showing end time - easy        */			then call Map.Real.Time.To.Sequence.Time(loc(addr(msb)), loc(addr(msb)));			else do;						/* correct for tempo map             */				/* Get duration in sequencer units:                       */				call LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;				call Map.Sequence.Time.To.Real.Time(loc(addr(#NMSB)), notetime);				call ADD32(loc(addr(msb)), notetime, endtime);				call Map.Real.Time.To.Sequence.Time(endtime, endtime);				call SUB32(endtime, loc(addr(#NMSB)), loc(addr(msb)));			end;		end;	end;	if ertyp=0 then do;		if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0		then do;			write(mam)=#ptr;			write(mal)=thd.cue.track;			if read(md)<>0 then call no.edit.allowed;			else if isa.ilp.note				/* can't edit duration for ilp start or end */			then call CANT.EDIT.LOOP;			else CHANGE.NOTE.DURATION(loc(addr(msb)),third.fld=2);		end;		else call NO.EDIT.ALLOWED;	end;end EDIT.NOTE.DURATION;/* edit the rte value or Velocity of a note */EDIT.RTE.VALUE: proc swapable;	dcl val	fixed static;	/* get a value between 0 and 1000 */	READ.NORMAL.RTE.VAL: proc;		val=CONV.STR.TO.FIXED(token,1,0);		if ertyp<>0 then do;			call format.error; val=-10000; return 0;		end;		if val igt 1000 then do;			call format.error; val=1000;		end;		val = SCALE.PERCENT.TO.RTE(val);	/* take from 0-1000, make it between 0-rte.max */	end READ.NORMAL.RTE.VAL;	if (ertyp == 0)	{		if (LOAD.SEQ.GLOBALS.FROM.SNAPSHOT <> 0)		{			dcl rte.code fixed;			rte.code = shr(#w2,8);			if			(isa.ilp.note != false)	call CANT.EDIT.LOOP;			/* can't edit value for ilp start or end */			else if	(isa.rte.note == false)	call READ.NORMAL.RTE.VAL;	/* editing velocity value */			else do case (shr(#w2,6)&3);				/* editing rte update record - find type */				do;											/* type = 0; normal update record */					if (rte.code&"200")<>0 then do;	/* midi controller update */						val = CONV.STR.TO.FIXED(token,0,0);						if ertyp<>0 then do;							call format.error; val=-10000;						end;						else do;							if (val > 127) then val = 127;							else if (val < 0) then val=0;						end;					end;					else if (rte.code = 5) then do;	/* ribbon filter +- 100 */						val = CONV.STR.TO.FIXED(token,0,1);						if (val > 100) then val = 100;						else if (val < (-100)) then val=(-100);						val = val&255;					end;					else if (rte.code = 4) then do;	/* pitch wheel - semitones */						dcl (pitch.bend.range) fixed;						pitch.bend.range = get.pitch.bend.range(trkindex(trcol));						val = CONV.STR.TO.FIXED(token,2,1);						/* THE FOLLOWING ALGORITHM LIMITS "val" IF IT EXCEEDS "pitch.bend.range".  THE ORIGINAL ALGOTHITHM USED							THE OPERATORS < AND > WHICH ONLY WORK RELIABLY FOR VALUES IN THE RANGE OF -16384 TO 16383, BUT							"pitch.bend.range" CAN HAVE ANY VALUE FROM -24000 TO 24000.  THE REWRITTEN ALGORITHM HANDLES VALUES							FROM -32768 TO 32767. */						if val < 0						then do;if -val igt pitch.bend.range then val=-pitch.bend.range;end;						else do;if val igt pitch.bend.range then val=pitch.bend.range;end;						val = srscale(val,100,pitch.bend.range) & 255;					end;					else call READ.NORMAL.RTE.VAL;	/* all the rest of normal type updates */				end;				do;											/* type = 1; toggle bits update record */					/* DEBUG */				end;				do;											/* type = 2; pressure update record */					call READ.NORMAL.RTE.VAL;				end;				do;											/* type = 3; midi update record */					do case rte.code;						/* editing rte update record - find type */						do;							val = CONV.STR.TO.FIXED(token,0,0);	/* midi program change, # in between 0 and 127 */							if (val > 127 or val < 0) then do;								call FORMAT.ERROR;								return;							end;						end;						do;														/* sysex byte */							if (third.fld=0) or (third.fld=2)							then val = CONV.STR.TO.FIXED(token,0,0);	/* sys ex change, # in between 0 and 255 */							else val = CONV.HEXSTR.TO.FIXED(token);							if (val > 255 or val < 0) then do;								call FORMAT.ERROR;								return;							end;						end;						do;												/* sustain update record */							val = CONV.STR.TO.FIXED(token,0,0);	/* sustain value */							if (val<>0) then val = 127;			/* midi rte max */						end;					end;				end;			end;	/* of do case */			if (val <> -10000)				/* make sure read.normal.val worked */			{				call CHANGE.RTE.VALUE(val);				if (isa.rte.note = true)	/* editing RTE value */				then do;oldw2=#w2; oldw3=#w3; end;			}		}	//	end of if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT()		else call NO.EDIT.ALLOWED;	}	//	of if (ertyp == 0)end EDIT.RTE.VALUE;EDIT.RTE.CODE: proc swapable;	dcl i fixed;	if LOAD.SEQ.GLOBALS.FROM.SNAPSHOT<>0 then do;		if      (eqstr(token,'PED1')=0) then call CHANGE.RTE.CODE(0);		else if (eqstr(token,'PED2')=0) then call CHANGE.RTE.CODE(1);		else if (eqstr(token,'MODW')=0) then call CHANGE.RTE.CODE(2);		else if (eqstr(token,'BRTH')=0) then call CHANGE.RTE.CODE(3);		else if (eqstr(token,'PTCH')=0) then call CHANGE.RTE.CODE(4);		else if (eqstr(token,'RIBF')=0) then call CHANGE.RTE.CODE(5);		else if (eqstr(token,'TOGG')=0) then call CHANGE.RTE.CODE(6);		else if (byte(token,0)=asc.p or byte(token,0)=lower.p)			and (byte(token,1)=asc.r or byte(token,1)=lower.r)			and (token(0) >= 4)			then call CHANGE.RTE.CODE(7);		else if (eqstr(token,'MIPGM')=0) then call CHANGE.RTE.CODE(8);		else if (eqstr(token,'SYSEX')=0) then call CHANGE.RTE.CODE(9);		else if ((byte(token,0)>=asc.0) and (byte(token,0)<=asc.9))			then call CHANGE.RTE.CODE(10);		else if (byte(token,0)=asc.m or byte(token,0)=lower.m)			and (byte(token,1)=asc.i or byte(token,1)=lower.i)			and (token(0) >= 3)			then do;				if token(0) <> 0 then do;					do i=0 to 3;						call pbyte(token,i,byte(token,i+2));	/* move control# to beginning of token */					end;					token(0)=token(0)-2;				end;				call CHANGE.RTE.CODE(10);			end;		else if (eqstr(token,'SUST')=0) then call CHANGE.RTE.CODE(11);		else call format.error;		if ertyp=0 then do; oldw2=#w2; oldw3=#w3; end;	end;	else call NO.EDIT.ALLOWED;end EDIT.RTE.CODE;