/* $TITLE :SYNSOU:RECMOD:RECSOU - Module for: Recorder Screen *//*Modified:1998/07/09 - TY  - Added external reference to the S-page's transpose function.1998/05/18 - TY  - Added "or RAM.EVENTS.DISPLAYED<>0" to the "if SHOW.OFFSETS<>0" conditional from the						 "new prm info" case because RAM-event durations and endtimes can be altered by these						 parameters whether soundfile offsets are displayed or not.1998/04/19 - TY  - Modified the "input character received" case so that the function keys can be utilized.1998/04/14 - TY  - Added several conditionals to the "new prm info" case so that parameter changes will only						 force a redraw of offset times if the parameter affects the tracks displayed.1998/04/08 - TY  - Modified the "new seq info" case so that bit 8 (256) is retained in "next.event.info".						 Thereby, a change in solo state for any track will force a call to UPDATE.TRACK.DISPLAY.						 (This was done so that when the "record track" feature is in use, changing the record track						 with the keyboard buttons will immediately affect the display.)1997/03/31 - CJ  - moved init of trkindex to startup; inited to 16 tracks1990/10/15 - PF  - Removed more unused inserts - SMGRDCL1990/07/10 - PF  - Removed more unused inserts1989/06/13 - TSS - Made change to not look at new track solo status bits1989/02/27 - TSS - Added literal to change RUN.SYN.LOOP to CHECK.NEXT.EVENT1988/08/08 - cj  - changed usage of SM.HRS so smpte display offsets are used.1988/06/30 - MWH - Remove unused inserts1987/02/18 - eg  - created this file*/module recmod;	insert ':synlits:alltlits';	/* get all terminal literals */	insert ':-xpl:intrprtr';		//	only needed for interp_flush_char_output during debugging on PPC	insert ':synmods:seqdcl';	insert ':synmods:giddcl';	insert ':synmods:globdcl';	insert ':synmods:mathdcl';	insert ':synmods:polydcl';	insert ':synmods:ttydcl';	insert ':synmods:loddcl';	insert ':synmods:errdcl';	insert ':synmods:getvdcl';	insert ':synmods:scrndcl';	insert ':synmods:d40dcl';	insert ':synmods:tformdcl';	insert ':synmods:getdcl';	insert ':synmods:tprimdcl';	insert ':synmods:moussdcl';	insert ':synrdcls:03-pdcls';	insert ':synrdcls:04-sdcls';	insert ':synrdcls:05-bdcls';	insert ':synlits:synclits';	BEGIN;	//	used for ram events	DCL NOTEADD FIXED EXTERNAL;	/* MUST DECLARE THIS IN ORDER */	DCL NOTENUM FIXED EXTERNAL;	/* TO MATCH PARTIAL BLOCK     */	DCL NOTEINC FIXED EXTERNAL;	/* ORDER FOR FASTER WRITES    */	DCL COMPUTE.POLY.HZ.INFO PROC(FIXED,FIXED,FIXED) EXTERNAL;	/* PASS ABS TRACK #, KEY #, PARTIAL # */	//	used when typing a note onto a blank track	DCL COPY.TIMBRE			PROC(FIXED,FIXED) RETURNS(FIXED)	EXTERNAL;	/* COPIES A TIMBRE FROM ONE TRK TO ANOTHER */	//	used for undo.trk	DCL COMPUTE.ACTIVE.TRKS	PROC										EXTERNAL;	/* CALL THIS PROCEDURE TO SET UP WORDS */	DCL FAST.COPY				PROC(FIXED,FIXED)						EXTERNAL;	DCL ERASE.TRACK			PROC(FIXED)								EXTERNAL;	/* ERASE ONE TRACK */	DCL TRANSPOSE.NOTE		PROC(FIXED,FIXED)						EXTERNAL;	/* S-page's transpose function */	DCL CLEAR.TERM				PROC										EXTERNAL;	/* CLEAR SCREEN, LEAVE IN ADM MODE */	dcl S$SMode	fixed external;	dcl S$SOffset array external;	dcl S$FMode	fixed external;	dcl S$FOffset array external;	dcl SAMPLE.SYNCL.SMGR.GLOBALS proc external;	/* get source files */	insert ':synsou:recmod:557-rec0';	insert ':synsou:recmod:557rec0a';	insert ':synsou:recmod:557-rec1';	insert ':synsou:recmod:557rec1a';	/* $PAGE - driver for Recorder Screen */	RECORDER.SCREEN:proc (arg) public swapable;		dcl arg  fixed; /* argument - must pass 0 for now  */		dcl code fixed; /* code returned by get.next.event */		call SAMPLE.SYNCL.SMGR.GLOBALS;	/* set up S$Soffset, S$Foffset, etc. */		call PRINT.RECORDER.DISPLAY;		/* set up frame */		/* Force an update of everything when we start the screen: */		new.ABLE.seq.info = new.ABLE.seq.info \ 2 \ 4 \ 16;		call POS.RECORDER.CURSOR;			/* and position cursor for input/echo */		EXIT.MY.SCREEN	= 0;					/* clear these flags before loop */		GOTO.THIS.SCREEN = 0;		do while EXIT.MY.SCREEN = 0;	/* wait for exit condition */			call ENABLE_SEVERAL_GETS(get.in.char,			/* get in.chars		*/											 get.mouse.button,	/* get mouse buttons */											 get.ertyp,				/* errors				*/											 get.prm.info);		/* timbre parameter change */			call ENABLE_SEVERAL_GETS(get.play.scrolling,	/* check window boundaries */											 get.new.seq.info,	/* new notes, constants, etc */											 0,											 0);			code = GET.NEXT.EVENT;		/* get event */			call DISABLE_SEVERAL_GETS(get.in.char,											 get.mouse.button,											 get.ertyp,											 get.prm.info);			call DISABLE_SEVERAL_GETS(get.play.scrolling,											 get.new.seq.info,											 0,											 0);			do case (code-1);				do;									/* input character received */					/* if next.event.info ige asc.call.convert */					/* SUBSTITUTE THE FOLLOWING LINE FOR THE ONE ABOVE TO MAKE USE OF THE FUNCTION KEYS */					if ((next.event.info ige asc.call.convert) and (next.event.info ilt asc.fkey1)) or (next.event.info igt asc.fkey16)					then call RETURN.TO.PREV.STATE;					else call RECORDER.DISPLAY.INPUT(in.chin,next.event.info);				end;				if next.event.info=2 then do;	/* look for release of middle button */					call RECORDER.DISPLAY.MOUSE.POS(mouse(release.x),mouse(release.y));				end;				;										/* mouse movement not used */				;										/* new timbre not used */				;										/* psfree not displayed */				do;									/* new seq info */					/* recall, new name, new notes, constants, cursor scroll, screen scroll, solo change only */					next.event.info = next.event.info & (1\2\4\8\32\64\256);					if (next.event.info&32)<>0 then do;		/* cursor boundary */						call DRAW.STARS;							/* move stars		*/						next.event.info = next.event.info & not(32);					end;					if (next.event.info&64)<>0 then do;		/* screen boundary reached */						call sample.sequence.time;				/* sample new screen time  */						next.event.info = (next.event.info & not(64)) \ 4;					end;					if (next.event.info&(1\8))<>0					then call SAMPLE.SYNCL.SMGR.GLOBALS;	/* set up S$Soffset, S$Foffset, etc. */					if (next.event.info<>0)						/* sequencer event happened */					then call UPDATE.TRACK.DISPLAY(next.event.info,0);				end;				;										/* no play scrolling */				;										/* entry writes no effect */														/* new prm info */																								if (SHOW.OFFSETS<>0) or (RAM.EVENTS.DISPLAYED<>0)	/* if showing sound file offsets or RAM event durations/endtimes, then... */				then do;					if ((next.event.info&16) ine 0)						/* if prm affects the sequence, or...     */					or KEYBOARD.TIMBRE.CONTROL.IN.USE					/* keyboard timbre control is in use with one of the displayed tracks... */					then new.ABLE.seq.info = new.ABLE.seq.info\8;	/* ...then force redraw of times */				end;				;										/* dtd info - nothing */				;										/* poly change - nothing */				do;									/* error message to display */					call Handle.System.Error.Codes(Next.Event.Info);					call POS.RECORDER.CURSOR;				end;				;										/* nothing on ork/smpte */			end;										/* of do case */		end;											/* of wait for exit */		EXIT.MY.SCREEN	= 0;						/* clear flag after loop */		return GOTO.THIS.SCREEN;	end RECORDER.SCREEN;	END;end recmod;