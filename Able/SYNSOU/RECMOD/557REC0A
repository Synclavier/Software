/*	:SYNSOU:RECMOD:557REC0A  $TITLE  Routines to Run Recorder Display (Part 2 of 4)	*//*				 $SUBTITLE  Synclavier Key Number, and Note Record Printing Routines		*//*Modified:1998/05/20 - TY  - Made display of Beats and Meas:Beats work correctly when using a Live Click Track.					  - Unused variables removed from PRINT.START.TIME:						 TIME.TOO.BIG data ('****.***'), BPM, RATE (passed arument).					  - Unused variables removed from PRINT.DURATION: I, RATE (passed arument).					  - Unused variable removed from PRINT.RECORDER.INFO: RATE.1998/05/17 - TY  - Rewrote the code in the "IF THIS IS A NON-LOOPING POLY EVENT" part of the duration part of						 PRINT.RECORDER.INFO to display the actual RAM event durations and endtimes based on the						 globals set by COMPUTE.POLY.HZ.INFO.  (Consequently deleted another unneeded variable.)					  - Replaced the code in PRINT.RECORDER.INFO which extracts the key# from a note record, to a						 call to EXTRACT.KEY (defined in :SYNSOU:SEQMOD:SEQSOU).1998/05/16 - TY  - Substituted calls to SCALE.RTE.VAL passing 0, to calls to SCALE.RTE.TO.PERCENT.1998/05/10 - TY  - Diddled a gazillion calls to PC(SP) and CONV.FIXED.TO.STR to account for the new position						 of the pitch field (allowing RECMAX=5 so MiXXX controllers etc. can be entered).					  - Fixed a really annoying bug that caused clutter and confusion by failing to overwrite						 trailing characters in the third field when sustain toggles were displayed.  Fixed similar						 bugs when displaying velocities and cues.					  - Changed declaration of str(4) in PKEY to str(2).  Only 3 characters are ever filled.						 Changed str(5) in PRINT.VELOCITY to str(4).  Max 8 characters filled.  Lots more like this.1998/05/01 - TY  - Removed a giant chunk of code from PRINT.RECORDER.INFO that is duplicated in the public						 procedure COMPUTE.SOUND.FILE.OFFSET.TIME in SEQSOUA.  Substituted a call to that procedure						 and removed 6 variables and two arrays which are consequently no longer needed.1998/04/20 - TY  - In PRINT.RECORDER.INFO, changed the number of spaces used to print over the soundfile name						 when not found from 7 to 8.  This caused trailing characters to litter the screen.1998/04/15 - TY  - Modified PRINT.RTE.INFO such that when pitch bend values are printed, the pitch.bend.range						 of the timbre on the track being printed is used, rather than the track where the cursor sits.						 In doing this I have eliminated PRINT.RTE.INFO as a procedure and moved it's code into						 PRINT.RECORDER.INFO at it's former point of call, thereby eliminated the need for passing 4						 arguments.  (No other procedures call PRINT.RTE.INFO.)1998/04/14 - TY  - Rewrote the scaling algorithm in the pitchbend block (case 0) of PRINT.RTE.INFO to have						 the following rounding characteristics:						 1) a value at the halfway point will round up.						 2) for negative values, "rounding up" means more negative.1991/08/05 - PF  - look up duration from patch list for poly RAM events1991/05/17 - PF  - changed MIDI program numbers from 1-128 to 0-1271991/04/02 - PF  - Removed prescan offset for rtes on input and display1990/11/06 - PF  - Screen support for new sustain update record1990/08/27 - PF  - Support all MIDI controllers1990/07/10 - PF  - Performed meter mapping for time displays1989/10/04 - cj  - performed tempo mapping for time displays1988/08/10 - EEG - Cleaned up printing w/feet:frames disp.mode1988/08/08 - cj  - used smpte display offset for smpte times1988/05/09 - MWH - Change Cue to Q so we can print 2 more chars of name1987/12/17 - MWH - Merge poly updates with N-Final plus AEE sources1987/11/04 - EEG - fixed live click track bugs, also bugs w/ format args added to conv.beats.to.str1987/08/26 - MWH - Merge with other release-N edits1987/07/16 - MWH - Update all to support max 4 poly bins, 512mb/bin1987/07/06 - MWH - kbd lookup table literals; restructured for 32 bit poly1987/04/30 - TSS - ADDED FORMAT ARG TO CONV.BEATS.TO.STR CALLS*/PRINT.START.TIME: proc(msb,lsb) swapable;	dcl (msb,lsb)	fixed;	dcl stime(4)	fixed;	/*	temp to hold smpte time	*/	dcl str	(8)	fixed;	/*	LEAVE THIS "TOO LONG" IN CASE OF MULTI-DIGIT TIME SIGNATURES, ETC.	*/	dcl buf	(2)	fixed;	/*	Note: if a click track is being referenced and the format is beats or meas:beats,		*/	/*	the time passed to this procedure has already been remapped to click track millibeats.	*/	/*	Otherwise it is a SEQUENCE time.																			*/	do case disp.mode;		do;							/*	seconds	*/			call Map.Sequence.Time.To.Real.Time(loc(addr(msb)), loc(addr(msb)));			call MSEC.TO.SEC(loc(addr(msb)),cf#time,loc(addr(msb)));			call CONV.SEC.MSEC.TO.STR(loc(addr(msb)),str,cf#default,cf#default);		end;		do;							/*	beats	*/			if Click.Track.Mode igt 3			then call MSEC.TO.BEATS(loc(addr(msb)),cf#time,1000,buf);			else call Map.Sequence.Time.To.Beats(loc(addr(msb)),buf);			call CONV.BEATS.TO.STR(buf,str,cf#default,cf#default);		end;		do;							/*	measures:beats	*/			if Click.Track.Mode igt 3			then do;				call MSEC.TO.BEATS(loc(addr(msb)),cf#time,1000,loc(addr(buf(1))));				load buf(1)-1;div SAMP.BPM;buf(0)=res;buf(1)=rem+1;			end;			else call Map.Sequence.Time.To.Measures.Beats(loc(addr(msb)),buf);			call CONV.MEASURES.BEATS.TO.STR(buf,Lookup.Beats.Per.Measure(loc(addr(msb))),str,4,cf#default);		end;		do;							/*	smpte	*/			call Map.Sequence.Time.To.Real.Time(loc(addr(msb)), loc(addr(msb)));			call MSEC.TO.SMPTE(loc(addr(msb)),cf#time,samp.speed,S$Smode,S$Soffset,stime);			call CONV.SMPTE.TO.STR(stime,str,cf#default,cf#suppress);		end;		do;							/*	feet:frames	*/			call Map.Sequence.Time.To.Real.Time(loc(addr(msb)), loc(addr(msb)));			call MSEC.TO.FEET(loc(addr(msb)),cf#time,samp.speed,S$FMode,S$FOffset,misc.buf);			call CONV.FEET.TO.STR(misc.buf,str,cf#default,cf#default);		end;	end;	call ps(str);end PRINT.START.TIME;PRINT.DURATION: proc(start, duration) swapable;	dcl start			array;	/*	note start time in sequencer units	*/	dcl duration		array;	/*	note duration in sequencer units	*/	dcl str		(8)	fixed;	/*	LEAVE THIS "TOO LONG" IN CASE OF MULTI-DIGIT TIME SIGNATURES, ETC.	*/	dcl stime	(4)	fixed;	dcl endtime	(1)	fixed;	dcl newstart(1)	fixed;	dcl newend	(1)	fixed;	dcl info		(2)	fixed;	/*	Note: if a click track is being referenced and the format is beats or meas:beats,	*/	/*	the START and DURATION passed to this procedure have already been remapped to			*/	/*	click track millibeats.  Otherwise both times passed are SEQUENCE times.				*/	call ADD32(start, duration, endtime);	/*	get end time handy	*/	if third.fld = 2								/*	if showing an end time	*/	then do;		if (disp.mode=1 or disp.mode=2)		/*	if showing beats or meas:beats	*/		then call COPY32(endtime, info);		else call Map.Sequence.Time.To.Real.Time(endtime, info);	end;	else do;											/*	else (if showing duration)	*/		if (disp.mode=1 or disp.mode=2)		/*	if showing beats or meas:beats	*/		then call COPY32(duration, info);		else do;			call Map.Sequence.Time.To.Real.Time(start,	newstart);			call Map.Sequence.Time.To.Real.Time(endtime,	newend  );			call SUB32(newend, newstart, info);		end;	end;	do case disp.mode;		do;									/*	seconds	*/			call MSEC.TO.SEC(info,third.fld<>2,info);			call CONV.SEC.MSEC.TO.STR(info,str,cf#default,cf#default);		end;		do;									/*	beats	*/			if Click.Track.Mode igt 3	/*	live click track	*/			then call MSEC.TO.BEATS(info,third.fld<>2,1000,info);			else do;				if third.fld=2				/*	end time	*/				then call Map.Sequence.Time.To.Beats(info,info);				else call Map.Sequence.Duration.To.Beats(start,info,info);			end;			call CONV.BEATS.TO.STR(info,str,cf#default,cf#default);		end;		do;									/*	measures:beats	*/			if Click.Track.Mode igt 3	/*	live click track	*/			then do;				if third.fld=2				/*	end time	*/				then do;					call MSEC.TO.BEATS(info,cf#time,1000,loc(addr(info(1))));					load info(1)-1;div SAMP.BPM;info(0)=res;info(1)=rem+1;				end;				else do;					call MSEC.TO.BEATS(info,cf#dur,1000,loc(addr(info(1))));					load info(1);div SAMP.BPM;info(0)=res;info(1)=rem;				end;			end;			else do;				if third.fld=2				/*	end time	*/				then call Map.Sequence.Time.To.Measures.Beats(info,info);				else call Map.Sequence.Duration.To.Measures.Beats(start,info,info);			end;			call CONV.MEASURES.BEATS.TO.STR(info,Lookup.Beats.Per.Measure(info),str,3,cf#default);		end;		do;									/*	smpte	*/			call MSEC.TO.SMPTE(info,third.fld<>2,samp.speed,S$Smode,S$Soffset,stime);			call CONV.SMPTE.TO.STR(stime,str,8,cf#suppress);		end;		do;									/*	feet:frames	*/			call MSEC.TO.FEET(info,third.fld<>2,samp.speed,S$FMode,S$FOffset,misc.buf);			call CONV.FEET.TO.STR(misc.buf,str,cf#default,cf#suppress);		end;	end;	call ps(str);end PRINT.DURATION;PRINT.VELOCITY: proc(vel) swapable;	dcl vel		fixed;	dcl str(4)	fixed;	call CONV.FIXED.TO.STR(vel,1,8,cf#right\cf#unsigned\cf#erase\cf#spfill,str);	call ps(str);	IF (DISP.MODE<>3) AND (DISP.MODE<>4) THEN CALL PC(SP);end PRINT.VELOCITY;/*	$SUBTITLE - ROUTINE TO PRINT SOUNDFILE NAME ON RECORDER SCREEN	*/PRINT.SOUNDFILE.NAME: proc(key#,track) swapable;	dcl (key#,track)	fixed;	dcl print.fn(5)	fixed;	/*	Max character length: 10 (for cue names)	*/	FIND.SOUNDFILE.NAME: proc(key#,track,print.fn);		dcl (key#,track)		fixed;		dcl print.fn			array;		dcl (partial,i,j,k)	fixed;		dcl syntyp				fixed;		i = TRK.HEAD.LOOKUP(track,thd.ctimb);		/*	get timbre # for this track	*/		if trk.head.lookup(track,thd.cue.track)<>0		then do;												/*	cue track - look up name	*/			IF LOD.RUNNING  = 0 THEN RETURN 0;		/*	NO CUE NAME IF LOD NOT RUNNING		*/			IF DTD.MAX.SECS = 0 THEN RETURN 0;		/*	NO CUE NAME IF LOD NOT INITIALIZED	*/			i=tim.head.lookup(i,tim.kbdtab.ptr+0);			if i=0 then return 0;						/*	no cue look up table	*/			write(mam)=tim.ptr+i-1;			write(mal)=key#;			i=read(md);										/*	get id #				*/			WRITE(MAM)=SCSI.PTR;							/*	SEND OVER CUE ID#	*/			WRITE(MD )=i;			DTD.CUE#=0;										/*	ZERO CUE #			*/			CALL SEND.TO.LOD(182,2);					/*	FETCH CUE RECORD	*/			IF DTD.CUE#=0 THEN RETURN 0;				/*	NO CUE				*/			WRITE(MAM)=SCSI.PTR;			WRITE(MAL)=CUE.NAME;							/*	EXTRACT CUE NAME	*/			DO I=0 TO 5;									/*	GET 10 CHARS OF	*/				PRINT.FN(I)=READ(MDI);					/*	CUE NAME				*/			END;			IF PRINT.FN(0) IGT 10						/*	LIMIT TO 10 CHARS	*/			THEN PRINT.FN(0)=10;			DO I=PRINT.FN(0) TO 9;						/*	SPACE FILL			*/				CALL PBYTE(PRINT.FN,I,SP);			END;			PRINT.FN(0)=10;								/*	LENGTH OF 10		*/			RETURN 1;		END;		key# = key# + trk.head.lookup(track,thd.cxpos);	/*	correct key # for current transposition	*/		if key# < 0			  then return 0;		if key# >= num.keys then return 0;		do partial=0 to num.partials-1;								/*	loop over partials	*/			syntyp = TIM.HEAD.LOOKUP(i,tim.synth.typ+partial);	/*	get synth type used	*/			j=TIM.HEAD.LOOKUP(i,tim.kbdtab.ptr+partial);			/*	look up pointer	*/			if j<>0 then do;				write(mam)=tim.ptr+j-1;									/*	point to table	*/				write(mal)=key# * klt.size + klt.patch.tim.ptr;	/*	index by key number	*/				if read(mdi)<>0 then do;								/*	if entry exists, print it	*/					sfile.base(lw#msb)=read(mdi) & base#only;		/*	poly bin/page# w/o stereo flag	*/					sfile.base(lw#lsb)=read(md);						/*	get sector of ext/poly memory	*/					if (inc.poly) & (syntyp=tim#poly)					then call ps.extract;							/*	info from poly memory	*/					else if (inc.mono) & (syntyp=tim#mono)					then call ms.extract;							/*	info from mono memory	*/					else return 0;										/*	wrong synthtyp			*/					do k=0 to 3;						print.fn(k+1)=misc.buf(bl.fname+k);		/*	copy name to print.fn for printing	*/					end;					do k=0 to 7;										/*	pad with spaces	*/						if (byte(print.fn,k)=0)						then call pbyte(print.fn,k,sp);					end;					print.fn(0)=8;					return 1;		/*	return '1' when first partial is found	*/				end;					/*	of entry exists	*/			end;		end;		return 0;	end FIND.SOUNDFILE.NAME;	if ((FIND.SOUNDFILE.NAME(key#,track,print.fn)<>0) and (print.fn(0)<>0)) then do;		call ps(print.fn);		print.fn(0)=0;		if (disp.mode<>3) and (disp.mode<>4) then call pc(sp);		return 1;	end;	else return 0;end PRINT.SOUNDFILE.NAME;PKEY:  proc(key#)  swapable;	/*	print the pitch and octave of a key number	*/	dcl (key#,i)	fixed;	dcl str (2)	fixed;	call CONV.KEY#.TO.STR(key#,str);	call ps(str);call pc(sp);call pc(sp);end PKEY;/*	$SUBTITLE - MAIN ROUTINE TO PRINT NOTE INFORMATION IN RECORDER SCREEN	*/PRINT.RECORDER.INFO: proc(BUF,Row,Trk) swapable;	DCL BUF					FIXED ARRAY;	DCL (Row,Trk)			FIXED;	DCL (KEY,VEL)			FIXED;	DCL (I,L,M,N)			FIXED;	DCL TIME.WAS.OFFSET	FIXED;	DCL (TYPE,CODE,VAL)	FIXED;	/*	For velocity/RTEs	*/	dcl (tnum,ptr)			fixed;	dcl pitch.bend.range	fixed;	dcl str(5)				fixed;	dcl duration(1)		fixed;	call CHECK.NEXT.EVENT;								/* PLAY NOTES AGAIN  */	if trk.head.lookup(trkindex(trk),thd.cue.track)=0	then do;												/*	not a cue track	*/		call EXTRACT.DUR(loc(addr(BUF(5))),duration);	/*	GET DURATION FROM NOTE RECORD	*/		KEY= EXTRACT.KEY(loc(addr(BUF(5))));				/*	GET KEY FROM NOTE RECORD	*/		/*	NOW CHECK TO SEE IF THIS IS ACTUALLY A		*/		/*	RAM EVENT TRIGGER IN WHICH CASE WE WILL	*/		/*	EXTRACT THE DURATION FOR THIS "NOTE" FROM	*/		/*	THE PATCH LIST.									*/		I = TRK.HEAD.LOOKUP(TRKINDEX(Trk),THD.CTIMB);		IF TIM.HEAD.LOOKUP(I,TIM.POLY.EVENT)<>0		THEN DO;											/*	POLY EVENTS USED IN THIS TIMBRE	*/			WRITE(MAL)=TIM.PARTIAL.POINTERS;		/*	Partial 1 assumed for Poly Events	*/			I			 =READ(MD);						/*	SAVE POINTER TO OUR PARTIAL	*/			WRITE(MAL)=TIM.KBDTAB.PTR;				/*	POINT TO KBD LOOKUP TABLE	*/			WRITE(MAM)=TIM.PTR+READ(MD)-1;			WRITE(MAL)=(KEY*KLT.SIZE)+KLT.PATCH.TIM.PTR;			IF READ(MD)<>0 THEN DO;					/*	MAKE SURE KBDTAB EXISTS	*/				CALL P.LOOKUP(I+READ(MD)+PT.TLEN);				DO i=PT.TLEN TO PT.KHZ;				/*	COPY INFO WE NEED INTO MISC.BUF	*/					MISC.BUF(i)=READ(MDI);				END;				IF  (MISC.BUF(PT.EVENT)<>0)		/*	ONLY IF THIS IS A NON-LOOPING POLY EVENT	*/				AND (MISC.BUF(PT.ONLOOP)<>3)				THEN DO;					call COMPUTE.POLY.HZ.INFO(Trk,KEY,0);		/*	lookup freq info for this event (Poly Events only use partial 1)	*/					NOTEADD=shl(NOTEADD,MISC.BUF(PT.STEREO));	/*	double NOTEADD if this is a stereo soundfile	*/					/*	compute total length in words	*/					call COPY32(loc(addr(MISC.BUF(PT.TLEN))),BitMSBArray);					/*	convert to real milliseconds	*/					call ratio_multiply(NOTENUM, NOTEINC*NOTEADD);					call ratio_multiply(99, 10000);					call ratio_multiply(SAMP.SPEED, 1000);		/*	adjust for sequence speed	*/					/*	map this duration to sequencer units for the computations below	*/					call Map.Real.Duration.To.Sequence.Duration(loc(addr(buf(1))),BitMSBArray,duration);				END;			END;		END;		/*	determine if offsets should and can be displayed, and if so, adjust accordingly	*/		TIME.WAS.OFFSET = 0;		if  (SHOW.OFFSETS <> 0)				/*	offsets desired		*/		and (inc.poly)							/*	offsets only avail for poly	*/		and (buf(5)			>= 0)				/*	normal format record	*/		and ((buf(7)&shl(b.upd,8))=0)		/*	not an update record	*/		then do;									/*	check for offset		*/			if COMPUTE.SOUND.FILE.OFFSET.TIME(buf(11),key,BitMsbArray,0)<>0			then do;				call Map.Real.Duration.To.Sequence.Duration(loc(addr(buf(1))),BitMsbArray,BitMsbArray);				buf(1) = buf(1) + bitmsb;	/*	add msecs to	*/				buf(2) = buf(2) + bitlsb;	/*	start time		*/				if buf(2) ilt bitlsb			/*	of note			*/				then buf(1) = buf(1)+1;				write(mam) = trd.ptr+trk+3;	/*	point to old snapshot area	*/				write(mal) = 16*row+14;				write(mdi) = bitmsb;				/*	save time offset		*/				write(md ) = bitlsb;				/*	for start time entry	*/				TIME.WAS.OFFSET = 1;			end;		end;	end;	else do;											/*	cue track	*/		key = (buf(6)&63) \ shr(buf(5)&"074000",6) \ "100000";		call STR32(0, 0, duration);		/*	could look up volume, pan, priority, and output here as well	*/	end;	IF ((MODE.CHANGE&8)<>0)						/*	IF CHANGING MODES	*/	THEN CALL ERASE.ENTRY(Row,Trk);			/*	clear out entry on screen	*/	IF DISP.MODE ige 2	/*	IF DISPLAYING FEET OR SMPTE OR MEASURES	*/	THEN HPOS=SMPTECOL(0);						/*	THEN START AT SMPTE COLUMN	*/	ELSE HPOS=SECNDCOL(0);	CALL CPOS(12+Row,HPOS+Trk*COLWIDTH);	/*	POSITION CURSOR TO PRINT TIME	*/	#msb = gid(sav.time1.ms);					/*	edit start (set by s screen)	*/	#lsb = gid(sav.time1.ls);	l = (com32(loc(addr(buf(1))), loc(addr(#msb))));	if (l = lw#igt) or (l = lw#ieq) then do;	/*	if note time >= edit start	*/		#msb = gid(sav.time2.ms);		#lsb = gid(sav.time2.ls);		l = (com32(loc(addr(buf(1))), loc(addr(#msb))));		if (l = lw#ilt)	/*	or (l = lw#ieq)	*/						/*	if note time < edit end	*/		then call Set.Term.Attr(ATTR#Reverse\ATTR#AltIntensity);	/*	then print in reverse	*/	end;	/*	SET UP FOR LIVE CLICK TRACK IF NECESSARY	*/	if (disp.mode=1 or disp.mode=2) then do;	/*	if showing beats or meas:beats	*/		if click.track.mode igt 3 then do;		/*	live click track	*/			call remap.with.live.click(buf(1),buf(2),duration(0),duration(1),1);			buf(1)		= remapped.time.msb;			buf(2)		= remapped.time.lsb;			duration(0)	= remapped.dur.msb;			duration(1)	= remapped.dur.lsb;		end;	end;	CALL PRINT.START.TIME(BUF(1),BUF(2));	IF TIME.WAS.OFFSET<>false	THEN CALL PC(a.cflex);	ELSE CALL PC(SP);	IF (BUF(5)&"174001")="104001" THEN DO;			/*	ILP START	*/		CALL PS('Loop Start   ');		IF (DISP.MODE<>3) AND (DISP.MODE<>4) THEN CALL PC(SP);	END;	ELSE IF (BUF(5)&"174001")="110001" THEN DO;	/*	ILP END	*/		CALL PS('Loop End     ');		IF (DISP.MODE<>3) AND (DISP.MODE<>4) THEN CALL PC(SP);	END;	ELSE IF ((BUF(5)) & ((BUF(7)&SHL(B.UPD,8))<>0)) THEN DO;	/*	RTE RECORD	*/		IF (BUF(7)&SHL(B.GUI,8))<>0 THEN DO;			TYPE=4;			VAL=BUF(7)&7;								/*	GET GUITAR STRING #	*/			CODE=0;		END;		ELSE DO CASE (SHR(BUF(6),6)&3);			/*	BRANCH ON UPDATE TYPE	*/			DO;											/*	0 => NORMAL UPDATE	*/				TYPE = 0;				CODE = SHR(BUF(6),8);				/*	RTE DATA CODE			*/				VAL=(BUF(7)&255);						/*	RTE VALUE				*/			END;			DO;											/*	1 => TOGGLE BITS		*/				TYPE = 1;			END;			DO;											/*	2 => PRESSURE UPDATE	*/				TYPE = 2;				CODE = KEY;				VAL = BUF(7)&255;						/*	PRESSURE VALUE			*/			END;			DO;											/*	3 => MIDI UPDATE		*/				TYPE = 3;				CODE = SHR(BUF(6),8);				/*	GET UPDATE CODE		*/				IF CODE=0 THEN VAL = (BUF(7)&"177");	/*	MIDI PROGRAM #	*/				ELSE VAL=(BUF(7)&255);				/*	OTHER	*/			END;		END;		do case (type);	/*	PRINT REAL TIME EFFECTS INFORMATION	*/			do;				if (code&"200")<>0 then do;		/*	midi update record	*/					str(0)=0;							/*	init str to null		*/					call ps('Mi');					call CONV.FIXED.TO.STR((code&"177"),0,3,cf#right\cf#zerofill\cf#erase,str);					call ps(str);					call CONV.FIXED.TO.STR(val,0,5,cf#right\cf#unsigned\cf#erase\cf#spfill,str);					call ps(str);call pc(sp);call pc(sp);				end;				else do;					if		  (code = r.pedal1) then call ps('Ped1');					else if (code = r.pedal2) then call ps('Ped2');					else if (code = r.mwheel) then call ps('ModW');					else if (code = r.pwheel) then call ps('Ptch');					else if (code = r.ribbon) then call ps('RibF');					else if (code = r.breath) then call ps('Brth');					else									 call ps('????');					if (code = r.ribbon) then do;						if val >= 128 then val=val\"177400";	/*	should be negative, so sign extend	*/						call CONV.FIXED.TO.STR(val,0,6,cf#right\cf#signed\cf#erase\cf#spfill,str);						call ps(str);call pc(sp);call pc(sp);					end;					else if (code = r.pwheel) then do;						tnum = TRK.HEAD.LOOKUP(trkindex(trk),thd.ctimb);	/*	get timbre # for this track	*/						ptr = TIM.HEAD.LOOKUP(tnum,tim.tinfo.pointer);						if ptr=0						then pitch.bend.range=200;									/*	default: units are cents (semitones*100)	*/						else pitch.bend.range=P.LOOKUP(ptr+ti.tbd);			/*	look it up	*/						if val >= 128 then val=val\"177400";					/*	should be negative, so sign extend	*/						/*	SINCE SPEED IS CRITICAL HERE, USE THE FOLLOWING IN LIEU OF "val=srscale(val,pitch.bend.range,100);"	*/						val = val * pitch.bend.range / 100;						/*	scale and round	*/						if (val < 0) {if (rem igt 50) val=val+1;}						else			 {if (rem ige 50) val=val+1;}						call CONV.FIXED.TO.STR(val,2,9,cf#right\cf#signed\cf#erase\cf#spfill,str);						call ps(str);					end;					else do;	/*	print normal parameter value	*/						val = SCALE.RTE.TO.PERCENT(val);						call CONV.FIXED.TO.STR(val,1,8,cf#right\cf#unsigned\cf#erase\cf#spfill,str);						call ps(str);					end;				end;			end;			do;		/*	type 1 => toggle bits	*/				/*	DEBUG - IS THIS THE RIGHT THING TO PRINT? WHAT VALUE SHOULD BE SHOWN?	*/				call ps('Togg');call ps($eight.spaces);			end;			do;		/*	type 2 => pressure update	*/				call ps('Pr');				call pkey(code);				val = SCALE.RTE.TO.PERCENT(val);				call CONV.FIXED.TO.STR(val,1,5,cf#right\cf#unsigned\cf#erase\cf#spfill,str);				call ps(str);			end;			do;		/*	type 3 => midi program change	*/				DO CASE CODE;					DO;						call ps('MiPgm');						call CONV.FIXED.TO.STR(val,0,5,cf#right\cf#unsigned\cf#erase\cf#spfill,str);					END;					DO;						CALL PS('SysEx');						if (third.fld=0) or (third.fld=2)						then call CONV.FIXED.TO.STR(val,0,5,cf#right\cf#unsigned\cf#erase\cf#spfill,str);						else do;call pc(sp);call CONV.FIXED.TO.HEXSTR(val,str);end;					END;					DO;						call ps('Sust');						if (val<>0) then val = 1;						call CONV.FIXED.TO.STR(val,0,6,cf#right\cf#unsigned\cf#erase\cf#spfill,str);					END;				END;				call ps(str);call pc(sp);call pc(sp);			end;			do;		/*	type 4 => guitar update	*/				call ps('Guit');				call CONV.FIXED.TO.STR(val,0,6,cf#right\cf#unsigned\cf#erase\cf#spfill,str);				call ps(str);call pc(sp);call pc(sp);			end;		end;		IF (DISP.MODE<>3) AND (DISP.MODE<>4) THEN CALL PC(SP);		if (code<>r.pwheel) then call pc(sp);	END;	ELSE DO;		IF KEY < 0 THEN DO;					/*	CUE ID # - PRINT ID#				*/			call ps('Cue  ');			IF (DISP.MODE<>3) AND (DISP.MODE<>4) THEN CALL PC(SP);		END;		ELSE DO;			CALL PKEY(KEY);					/*	PRINT KEY NAME IN EITHER CASE	*/		END;		IF (THIRD.FLD=3)\(key<0) THEN DO;		/*	DISPLAY SOUNDFILE NAME (used also to print spaces when cue track)	*/			I = PRINT.SOUNDFILE.NAME(KEY&1023,TRKINDEX(Trk));			IF I=0 THEN CALL PS($eight.spaces);	/*	COULDN'T FIND NAME, SO PRINT BLANKS	*/		END;		ELSE IF (third.fld=1 or third.fld=2)				/*	WILL SHOW DURATION (or end time)	*/		THEN CALL PRINT.DURATION(loc(addr(buf(1))), duration);		ELSE DO;														/*	WILL SHOW VELOCITY	*/			IF ((BUF(5)&1)=0)										/*	2 WORD, USE RTE.MAX	*/			THEN VEL=1000;											/*	SCALED RTE.MAX			*/			ELSE VEL=SCALE.RTE.TO.PERCENT((BUF(7)&255));	/*	SCALE TO 0.0-100.0	*/			CALL PRINT.VELOCITY(VEL);		END;	END;	IF  (STAR.ROW(Trk)=Row)			/*	IF THERE WAS A STAR HERE		*/	AND (STAR.COL(Trk)>=HPOS)		/*	AND WE JUST OVERWROTE IT		*/	THEN STAR.ROW(Trk)=(-1);		/*	SO INDICATE WE ZAPPED THE *	*/	call Set.Term.Attr(ATTR#NoReverse\ATTR#RegIntensity);	/*	make sure no reverse is on	*/	CALL CHECK.NEXT.EVENT;				/* PLAY NOTES AGAIN AFTER SWAP PROCEDURE RETURN */	if inc.mouse then call MOUSE.CURSOR.UPDATE;				/*	keep mouse moving		*/end PRINT.RECORDER.INFO;