/* 557-REC0  $TITLE  Routines to Run Recorder Display (Part 1 of 4) *//*Modified:2001/09/09 - TY  - If no time display mode was set from the S-page or by the .SDEF-7 file, it will be set to						 match that of the VK keyboard rather than arbitrarily defaulting to meas:beats. 1998/05/18 - TY  - Added RAM.EVENTS.DISPLAYED and KEYBOARD.TIMBRE.CONTROL.IN.USE procedures.1998/05/14 - TY  - To maintain consistent nomenclature, changed 'Append EFX:  *' to 'Insert RTE:  *'1998/04/18 - TY  - Changed the field positions in the data array SECNDCOL and SMPTECOL and declared MEASRCOL						 to be referenced when meas:beats is displayed.  Modified POS.RECORDER.CURSOR to accommodate.						 This was done to increase the number of characters the user can type into the end-time						 and start-time fields.  (It was insufficient in certain cases before.)  Also the pitch field						 in SMPTECOL didn't match where the pitches were printed.  The pitch field has been moved one						 space to the left to allow RECMAX=5 for entry of MiXXX controllers.					  - Changed the values assigned to "sec.x", "third.x", "off.x", "rte.x", "undo.x" and "rip.x"						 in order to improve the appearance of the mode selection panel.1998/04/15 - TY  - Defined string constants to prevent unnecessary duplication in the mode fields.					  - Also streamlined mode field procedures.1998/04/09 - TY  - Modified Instructions to include Record Track feature.					  - Fixed an error in a call to DRAW.VER in ERASE.INSTRUCTIONS that caused a right-tee						 to be printed over (never to be recovered).					  - Modified PRINT.RECORDER.DISPLAY so that screen initializes with show.modes=true and sav.trrow=0.1998/04/08 - TY  - Centered the title at the top of the frame (it was at 15, should have been at 17).					  - Centered 'No Track Displayed' in column (it was at 3, should have been at 4) and						 adjusted "POS.RECORDER.CURSOR" to accommodate.1998/04/07 - TY  - Modified the end of redraw.track.title to provide an indication for when the						 record track feature is in use but no track is in record ready mode.1990/11/06 - PF  - Screen support for new sustain update record1990/08/27 - PF  - Support all MIDI controllers1988/10/20 - EG/LSS - UNDO feature now defaults to OFF1988/06/21 - EG  - added undo enable switch & undo capabilities1987/09/18 - eg  - move scroll.back.1.line and scroll.forward.some.lines to seqmod1987/07/   - cj  - moved snap shot to seqmod1987/01/19 - eeg - added verify state to ripple; measure:beats display1987/01/16 - eeg - m-beta fixes, cursor cleanup, field-widths1987/01/07 - EEG - when showing sound file names, will not print duration if no name found*//* defs for the 3 sub-fields (TRFLD) within each track column */DCL SECNDCOL DATA (2,12,17,26);	/* FIELD SPACING WHEN SECONDS OR BEATS ARE DISPLAYED */DCL MEASRCOL DATA (1,12,17,26);	/* FIELD SPACING WHEN MEASURES:BEATS ARE DISPLAYED */DCL SMPTECOL DATA (1,13,18,26);	/* FIELD SPACING WHEN SMPTE TIMES OR FEET:FRAMES ARE DISPLAYED *//* STRING CONSTANTS */dcl $yes				data ('YES');dcl $no				data ('NO ');dcl $eight.spaces data ('        ');dcl star.row(2)	fixed;	/* indicates which row has the star ("*") */dcl star.col(2)	fixed;	/* indicates which col has the star ("*") */dcl rdis.time.msb fixed;	/* !! MUST BE KEPT IN THIS ORDER */dcl rdis.time.lsb fixed;dcl trcol			fixed;	/* track column (0-2) on Recorder Display */dcl (trfld,trrow)	fixed;	/* track sub-field (0-2) and row (0-9) within a column of Recorder Display */dcl recd.col		fixed;	/* which column, if any, is displaying current record track */dcl disp.mode		fixed;	/* 0=SECONDS, 1=BEATS, 2=MEAS:BEAT, 3=SMPTE, 4=FEET:FRA */dcl ripple			fixed;	/* Off, On, Verify */DCL MODE.CHANGE	fixed;	/* SET TO ERASE ALL INFO */dcl RECMAX			fixed;	/* Maximum character length allowed for input (depends on trfld and disp.mode) */dcl hpos							fixed;dcl (play.msb,play.lsb)		fixed;dcl last.sel					fixed;dcl (sav.trrow,sav.trcol)	fixed;dcl (oldw2,oldw3)				fixed;	/* used to hold last rte created */dcl se.button					fixed;	/* holds id for button to jump to seq editor */dcl third.fld					fixed;	/* 0 => velocity, 1 => duration, 2 => end time 3 => soundfile name */dcl saved.trk					fixed;	/* holds abs trk# of track saved on undo.trk */dcl saved.token.length		fixed;	/* Remembers the character length of the token after it is deposited */dcl update.finished		 boolean;	/* true if all rows have been updated & snapshot matches current seq position */dcl do.reverse				 boolean;	/* true when inverse video is used (for notes in the edit region) */dcl our.first.time		 boolean;dcl show.offsets			 boolean;	/* true if going to show sound file offsets rather than actual sf start times */dcl show.modes				 boolean;	/* true if mode selections are displayed rather than instructions */dcl show.rte				 boolean;	/* whether or not to show rte records */dcl ripple.edit			 boolean;	/* if user is about to perform a ripple edit */dcl undo.enabled			 boolean;	/* true if undo is turned on */dcl sec.y	lit ' 5';dcl sec.x	lit ' 2';dcl third.y	lit ' 6';dcl third.x	lit ' 2';dcl off.y	lit ' 5';dcl off.x	lit '31';dcl rte.y	lit ' 6';dcl rte.x	lit '31';dcl undo.y	lit ' 5';dcl undo.x	lit '61';dcl rip.y	lit ' 6';dcl rip.x	lit '61';/* ROUTINE TO DETERMINE IF RAM EVENT DURATIONS OR ENDTIMES ARE BEING DISPLAYED */RAM.EVENTS.DISPLAYED: proc swapable;	dcl TrkCol pointer;	if (third.fld=1 or third.fld=2)	/* IF DISPLAYING DURATIONS OR ENDTIMES... */	then do TrkCol = 0 to 2;		IF TIM.HEAD.LOOKUP(TRK.HEAD.LOOKUP(TRKINDEX(TrkCol),THD.CTIMB),TIM.POLY.EVENT) ine 0 then return true;	end;	return false;end RAM.EVENTS.DISPLAYED;/* ROUTINE TO DETERMINE IF KEYBOARD TIMBRE CONTROL IS IN USE WITH ONE OF THE DISPLAYED TRACKS */KEYBOARD.TIMBRE.CONTROL.IN.USE: proc swapable;	dcl TrkCol pointer;	if (KEYBOARD.TIMBRE.CONTROL ine 0)	/* IF KEYBOARD TIMBRE CONTROL IS IN USE AT ALL... */	then do TrkCol = 0 to 2;		IF KEYBOARD.TIMBRE.CONTROL ieq trkindex(TrkCol) then return true;	end;	return false;end KEYBOARD.TIMBRE.CONTROL.IN.USE;/* Routine to load sequencer globals from the snapshot for the current note */LOAD.SEQ.GLOBALS.FROM.SNAPSHOT: proc swapable;	if trrow > -1 then return GET.SNAPSHOT.INFO(trd.ptr+3, trcol, trkindex, trrow);	return 0;end LOAD.SEQ.GLOBALS.FROM.SNAPSHOT;SAMPLE.SEQUENCE.TIME: proc swapable;	call Map.Real.Time.To.Sequence.Time(loc(addr(sampled.actual.play.time.msb)),loc(addr(rdis.time.msb)));end;CLEAR.OLD.SNAPSHOT.AREA: proc swapable;	call erase.snapshot.area (trd.ptr+3,3);end CLEAR.OLD.SNAPSHOT.AREA;/* $PAGE - ROUTINES TO PRINT MODE SELECT FIELDS */PRINT.SEC.FIELD: PROC SWAPABLE;	dcl i fixed;	call cpos(sec.y,sec.x);	i=disp.mode;									/* get disp mode      */	if  (click.track.mode=3)					/* if using ext click */	and ((disp.mode=1) or (disp.mode=2))	/* and beats selected */	then i=0;										/* then use seconds   */	call ps('Show Times in   : ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	do case (i);		call ps('SECONDS ');	/* disp.mode = 0 */		call ps('BEATS   ');	/* disp.mode = 1 */		call ps('MEASURES');	/* disp.mode = 2 */		call ps('SMPTE   ');	/* disp.mode = 3 */		call ps('FEET:FRA');	/* disp.mode = 4 */	end;	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.SEC.FIELD;PRINT.THIRD.FIELD: PROC SWAPABLE;	call cpos(third.y,third.x);	call ps('Dur/End/Name/Vel: ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	do case (third.fld);		call ps('VELOCITY');	/* 0 => velocity       */		call ps('DURATION');	/* 1 => duration       */		call ps('END TIME');	/* 2 => end time       */		call ps('FILENAME');	/* 3 => soundfile name */	end;	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.THIRD.FIELD;PRINT.OFFSET.FIELD: PROC SWAPABLE;	call cpos(off.y,off.x);	call ps('Show Sound File Offsets: ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	if show.offsets<>0	then call ps($yes);	else call ps($no);	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.OFFSET.FIELD;PRINT.RTE.FIELD: PROC SWAPABLE;	call cpos(rte.y,rte.x);	call ps('Show Real-Time Effects : ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	if show.rte<>0	then call ps($yes);	else call ps($no);	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.RTE.FIELD;PRINT.UNDO.FIELD: PROC SWAPABLE;	call cpos(undo.y,undo.x);	call ps('UNDO Enabled: ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	if undo.enabled<>0	then call ps($yes);	else call ps($no);	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.UNDO.FIELD;PRINT.RIP.FIELD: PROC SWAPABLE;	call cpos(rip.y,rip.x);	call ps('Note Ripple : ');	if do.reverse<>0 then call REVERSE.VIDEO(1);	/* turn on reverse  */	do case (ripple);		call ps('OFF');		call ps('ON ');		call ps('VER');	end;	if do.reverse<>0 then call REVERSE.VIDEO(0);	/* turn off reverse */END PRINT.RIP.FIELD;/* $PAGE - ROUTINES TO PRINT AND ERASE INSTRUCTIONS */ERASE.INSTRUCTIONS: proc swapable;	dcl (i,j) fixed;	do i=1 to 6;		if vt100<>0		then call ERASE.REST.OF.LINE(i,1);		else do;			call cpos(i,1);			do j=0 to 77;				call pc(sp);			end;		end;	end;	if (vt100<>0) then do;		call DRAW.VER(1,79,6);		call cpos(11,26);		call DRAW.TEE(t.top);		call cpos(11,53);		call DRAW.TEE(t.top);	end;end ERASE.INSTRUCTIONS;PRINT.INSTRUCTIONS: proc swapable;	if show.modes=false then do;	/* show instructions */		call cpos(1,6);		call ps('1.  Enter Track numbers from top-most row to display desired Tracks.');		call cpos(2,6);		call ps('2.  Press # from top-most row to display Record Track.');		call cpos(3,6);		call ps('3.  Press <');		if vt100<>0 then call ps('DELETE'); else call ps('RUBOUT');		call ps('> from top-most row to remove Track from display.');		call cpos(4,6);		call ps('4.  Move cursor with arrow keys, and enter values to change notes.');		call cpos(5,6);		call ps('5.  Use <TAB> key to view/change mode selections.');		call cpos(6,6);		call ps('6.  Press H to Print Screen.  Press <');		if vt100<>0 then call ps('ENTER'); else call ps('ESC><ESC');		call ps('> to return to Main Menu.');	end;	else do;								/* show the mode selection window */		call cpos(1,3);		call ps('Change Selections:  <SPACE>     Insert Note: -     Ped1  Ped2  ModW  Mi000');		call cpos(2,3);		call ps('Review Instructions: <TAB>      Append Note: +     RibF  Brth  Ptch  Sust');		call cpos(3,3);		call ps('Add Independent Loop:  ~        Insert RTE:  *     PrC#2 MiPgm SysEx');		call cpos(4,1); call DRAW.HOR(78);		do.reverse = false;	/* don't want these drawn in reverse video */		call PRINT.THIRD.FIELD;		call PRINT.SEC.FIELD;		call PRINT.OFFSET.FIELD;		call PRINT.RTE.FIELD;		call PRINT.RIP.FIELD;		call PRINT.UNDO.FIELD;	end;END PRINT.INSTRUCTIONS;/* $PAGE - PRINT.RECORDER.DISPLAY *//* FILL IN BASIC FRAME FOR RECORDER DISPLAY */dcl our.recorder.snap.shot proc recursive;PRINT.RECORDER.DISPLAY: proc swapable;	/* print basic sequence display frame */	dcl (i) fixed;	call clear.term;	if vt100<>0 then call CH.SET(alt);	call DRAW.BOX(0,0,11,79);	if vt100<>0 then call CH.SET(norm);	call cpos(0,17);	call ps('  MEMORY RECORDER COMPARATIVE TRACK DISPLAY  ');	if vt100<>0 then call CH.SET(alt);	call cpos(7,0);	if vt100<>0 then call DRAW.TEE(t.left); else call pc("174");	call DRAW.HOR(78);	if vt100<>0 then call DRAW.TEE(t.right);	call cpos(22,0); call DRAW.HOR(80);	call cpos(11,26);	if vt100<>0 then call DRAW.TEE(t.top);	call DRAW.VER(12,26,21);	if vt100<>0 then call DRAW.TEE(t.bot);	call cpos(11,53);	if vt100<>0 then call DRAW.TEE(t.top);	call DRAW.VER(12,53,21);	if vt100<>0 then do; call DRAW.TEE(t.bot); call CH.SET(norm); end;	if (our.first.time<>-1) then do;		show.modes		= true;		show.offsets	= false;		third.fld		= 1;			/* 1 => show duration */		show.rte			= false;		ripple			= false;		undo.enabled	= false;		last.sel			= 4;		sav.trrow		= 0;		sav.trcol		= 0;		recd.col			= -1;		oldw2				= shl(2,8);	/* default to ModW, value=0 */		oldw3				= rte.max\shl(b.upd,8);		our.first.time	= -1;	end;/*	disp.mode	//	case 0: SECONDS	//	case 1: BEATS	//	case 2: MEAS:BEAT	//	case 3: SMPTE	//	case 4: FEET:FRA*/	if (gid(sav.time.mode) < 0)	/* (haven't been to the S screen yet) && (no preference stored in .SDEF-7)	*/	{		if (gid(saved.aee.time.format) < 0)	/* (haven't been to the Q-page yet)	*/		{	/* default to the display mode currently set on the VK keyboard */			do case TRACK.FORMAT;				disp.mode	= 1;	//	case 0: BEATS				->	1: BEATS				disp.mode	= 2;	//	case 1: MEASURES/BEATS	->	2: MEAS:BEAT				disp.mode	= 0;	//	case 2: SECONDS			->	0: SECONDS				disp.mode	= 3;	//	case 3: SMPTE				->	3: SMPTE			end;		}		else		{	/* default to the display mode currently set on the Q-page */			disp.mode	= gid(saved.aee.time.format);//			if (disp.mode == O#MSEC.Minutes.Seconds)	disp.mode	= O#MSEC.Sec.Msec;			if (disp.mode == 5							)	disp.mode	= 0;		}	}	else	{	/* default to the display mode set by the S screen or the .SDEF-7 file */		do case gid(sav.time.mode);			disp.mode	= 0;	//	case 0: seconds			->	0: SECONDS			disp.mode	= 0;	//	case 1: min:sec			->	0: SECONDS			disp.mode	= 1;	//	case 2: beats				->	1: BEATS			disp.mode	= 2;	//	case 3: measures/beats	->	2: MEAS:BEAT			disp.mode	= 3;	//	case 4: smpte				->	3: SMPTE			disp.mode	= 4;	//	case 5: feet:frames		->	4: FEET:FRA		end;	}	if D44_PRESENT								/* if device available */	then call plot.mouse.hole(mouse.hole.lowerx,mouse.hole.lowery);	call PRINT.INSTRUCTIONS;	call PRINT.CCAT;							/* print current catalog name */	do i=0 to 2; star.row(i)=(-1); end;	/* indicate no *'s yet */	/* zero out display area to force complete redraw */	call clear.old.snapshot.area;	call sample.sequence.time;	call our.recorder.snap.shot;	call scroll.back.1.line(loc(addr(rdis.time.msb)));	new.ABLE.seq.info = new.ABLE.seq.info \ 6;	/* draw titles and check notes upon startup */END PRINT.RECORDER.DISPLAY;/* $SUBTITLE  Routine to Take Snap Shot of Sequencer State */our.recorder.snap.shot: proc swapable;	call recorder.screen.snapshot(trd.ptr,3,trkindex,	/* xmem.ptr,#trks,trkindex, */											rdis.time.msb, rdis.time.lsb, 10,											(snap#notes\snap#ilps)\(snap#rtes*(show.rte<>0))\(snap#begs\snap#runs));end our.recorder.snap.shot;/* $SUBTITLE Cursor Position and Display Update Routines for Recorder Display */POS.RECORDER.CURSOR:PROC SWAPABLE;	/* POSITION CURSOR FOR TRACK FRAME INPUT */	IF TRROW=(-1) THEN DO;									/* IN TRACK SELECT FIELDS */		IF TRKINDEX(trcol)=(0)		THEN CALL CPOS(9, 4+trcol*COLWIDTH);		ELSE CALL CPOS(9,15+trcol*COLWIDTH);	/* POSITION FOR TRACK SELECTION */		RECMAX=8;		CALL CHECK.NEXT.EVENT;							/* KEEP SOUNDS GOING */	END;	ELSE IF (TRROW<-1 AND SHOW.MODES<>0) THEN DO;	/* IN MODE SELECTION AREA */		RECMAX=0;		IF TRROW=(-2) THEN DO;			DO CASE (TRCOL);				CALL CPOS(THIRD.Y,THIRD.X+17);				CALL CPOS(RTE.Y,RTE.X+24);				CALL CPOS(RIP.Y,RIP.X+13);			END;		END;		ELSE IF TRROW=(-3) THEN DO;			DO CASE (TRCOL);				CALL CPOS(SEC.Y,SEC.X+17);				CALL CPOS(OFF.Y,OFF.X+24);				CALL CPOS(UNDO.Y,UNDO.X+13);			END;		END;	END;	ELSE DO;														/* IN FIELD - POSITION CURSOR */		IF DISP.MODE ile 1 THEN DO;		/* SECONDS OR BEATS */			CALL CPOS(12+TRROW,SECNDCOL(TRFLD)+trcol*COLWIDTH);			RECMAX=SECNDCOL(TRFLD+1)-SECNDCOL(TRFLD);		END;		ELSE IF DISP.MODE ige 3 THEN DO;	/* SMPTE AND FEET:FRAMES */			CALL CPOS(12+TRROW,SMPTECOL(TRFLD)+trcol*COLWIDTH);			RECMAX=SMPTECOL(TRFLD+1)-SMPTECOL(TRFLD);		END;		ELSE DO;									/* MEAS:BEATS */			CALL CPOS(12+TRROW,MEASRCOL(TRFLD)+trcol*COLWIDTH);			RECMAX=MEASRCOL(TRFLD+1)-MEASRCOL(TRFLD);		END;		CALL CHECK.NEXT.EVENT;	/* KEEP SOUNDS GOING */	END;	IF TOKEN(0)<>0 THEN DO;	/* REPOSITION CURSOR IF IN MIDDLE OF INPUT STRING */		IF RIPPLE.EDIT<>0		/* WAITING FOR USER TO TYPE OK */		THEN CALL CPOS(23,55);		CALL PS(TOKEN);		/* REWRITE INPUT STRING TO POSITION CURSOR */		CALL CHECK.NEXT.EVENT;	/* KEEP SOUNDS GOING */	END;END POS.RECORDER.CURSOR;/* $SUBTITLE  Routine to Place Stars on Recorder Display in Correct Locations */DRAW.STARS:  proc swapable;	/* puts stars on tracks in correct spots */	dcl (trk,row,l)	fixed;	dcl (msb,lsb)		fixed;	dcl temp				fixed;	/* holds current hpos */	dcl time(1)			fixed;	call COPY32(Screen.Begin,       Cursor.Begin);	call COPY32(Screen.End,         Cursor.End  );	call COPY32(Screen.Scroll.Begin,Cursor.Scroll.Begin);	call COPY32(Screen.Scroll.End,  Cursor.Scroll.End  );	/* find out where the sequencer is in sequence time units: */	call Map.Real.Time.To.Sequence.Time(loc(addr(sampled.actual.play.time.msb)), time);	temp = hpos;	IF ((DISP.MODE=4) OR (DISP.MODE=3) OR (DISP.MODE=2))	/* IF DISPLAYING FEET OR SMPTE OR MEASURES */	OR ((MODE.CHANGE&16)<>0)	/* OR CHANGING MODES   */	THEN HPOS=SMPTECOL(0)-1;	/* THEN START AT SMPTE */	ELSE HPOS=SECNDCOL(0)-1;	/* COLUMN              */	do trk=0 to 2;	/* set correct * for each track to indicate next note */		row = 10;		do while row > 0;			row=row-1;			write(mam) = trd.ptr+3+trk;			write(mal) = row*16;			if read(mdi)<>0 then do;				msb = read(mdi);				lsb = read(md );				if ((msb ilt time(0)))	/* find first note that is */				or ((msb  =  time(0))	/* at or before the        */				and (lsb ile time(1)))	/* current sequence time.  */				then do;					if (star.row(trk)<>row)					or (star.col(trk)<>hpos)					then do;					/* must move star if different */						if star.row(trk)<>(-1) then do;	/* remove star if was there */							call cpos(12+star.row(trk),star.col(trk)+trk*colwidth);							call pc(sp);							call CHECK.NEXT.EVENT;	/* run synclavier loop here to keep response better while printing */						end;						call cpos(12+row,hpos+trk*colwidth);						call pc(asc.star);						star.row(trk)=row;						star.col(trk)=hpos;						call CHECK.NEXT.EVENT;		/* run synclavier loop here to keep response better while printing */					end;					/* set Cursor.Begin to prior note */					do while row<>0;							/* look back for prior note */						row = row-1;						write(mam) = trd.ptr+3+trk;						write(mal) = row*16;						if read(mdi)<>0 then do;							#nmsb = read(mdi);							#nlsb = read(md );							if (#nmsb <> msb) or (#nlsb <> lsb) then do;	/* different times */								if ((#nmsb igt Cursor.Begin(0)))								or ((#nmsb  =  Cursor.Begin(0))								and (#nlsb igt Cursor.Begin(1)))								then do;									Cursor.Begin(0) = #nmsb;									Cursor.Begin(1) = #nlsb;									row = 0;						/* stop searching */								end;							end;						end;					end;					row = (-1);				end;				/* if this note is still after the *, set cursor.end  */				/* so we will see an event when the play.time reaches */				/* this note:														*/				else do;					if ((msb ilt Cursor.End(0)))					or ((msb  =  Cursor.End(0))					and (lsb ilt Cursor.End(1)))					then do;						Cursor.End(0) = msb;						Cursor.End(1) = lsb;					end;				end;			end;			if row=0 then do;				if star.row(trk)<>(-1) then do;	/* remove star if 1) no track selected, or 2) no match found */					call cpos(12+star.row(trk),star.col(trk)+trk*colwidth);					call pc(sp);					call CHECK.NEXT.EVENT;				/* run synclavier loop here to keep response better while printing */					star.row(trk)=(-1);				end;			end;		end;	end;	hpos = temp;	/* reset hpos */	/* Set up scroll boundaries for real time usage: */	call Map.Sequence.Time.To.Real.Time(Cursor.Begin, Cursor.Scroll.Begin);	if Cursor.End(0) = (-1)	then call STR32(-1, -1, Cursor.Scroll.End);	else call Map.Sequence.Time.To.Real.Time(Cursor.End, Cursor.Scroll.End);	call POS.RECORDER.CURSOR;	/* update normal cursor */end DRAW.STARS;/* erase an entry at the passed row and track */erase.entry: proc(row,trk) swapable;	dcl (row,trk) fixed;	dcl i         fixed;	IF ((DISP.MODE=4) OR (DISP.MODE=3) OR (DISP.MODE=2))	/* IF DISPLAYING FEET OR SMPTE OR MEASURES */	OR ((MODE.CHANGE&16)<>0)										/* OR CHANGING MODES                       */	THEN HPOS=SMPTECOL(0);											/* THEN START AT SMPTE                     */	ELSE HPOS=SECNDCOL(0);											/* COLUMN                                  */	call cpos(row+12,hpos+trk*colwidth);	do i=hpos to colwidth-2;		call pc(sp);	end;	if inc.mouse then call MOUSE.CURSOR.UPDATE;	/* keep mouse moving */end erase.entry;/* redraws the timbre names and column titles for the passed track (0 - 2) */redraw.track.title: proc(T) swapable;	dcl (t) fixed;	dcl (i,j) fixed;	dcl print.fn(8) fixed;	/* PRINT COLUMN TITLE (TRACK & NAME) */	CALL CPOS( 9,4+T*COLWIDTH); DO I=0 TO 18; CALL PC(SP); END;	/* ERASE EARLIER TRACK ID */	CALL CPOS(10,4+T*COLWIDTH); DO I=0 TO 17; CALL PC(SP); END;	/* ERASE EARLIER NAME     */	CALL CPOS(11,1+T*COLWIDTH);				/* ERASE FORMER LABELS  */	IF T<>2 THEN CALL DRAW.HOR(COLWIDTH);	/* JUST DASHES          */	ELSE DO;											/* SPECIAL CASE FOR COR */		CALL DRAW.HOR(COLWIDTH-1);				/* FOR BOTH TERMINALS   */		IF VT100<>0 THEN DO;						/* DRAW CORNER          */			CALL CH.SET(ALT);						/* ALT MODE             */			CALL PC("152");						/* LOWER RIGHT CORNER   */			CALL CH.SET(NORM);		END;		ELSE CALL PC(SP);							/* ERASE POSSIBLE 'S'   */	END;	if (vt100<>0) then do;		call cpos(11,26);		call DRAW.TEE(t.top);		call cpos(11,53);		call DRAW.TEE(t.top);	end;	IF TRKINDEX(T)<>(0) THEN DO;	/* PRINT NAME IF NOT SUPPRESSED */		CALL CPOS(9,9+T*COLWIDTH);	/* POSITION FOR TRACK SELECTION */		CALL PS('Track ');		CALL PNUM(TRKINDEX(T)-NUM.KBD.TRACKS+1,0);		IF (T = RECD.COL)				/* INDICATE THIS IS CURRENT RECORD TRACK */		THEN CALL PS(' (R)');		ELSE CALL PS('    ');		/* NOTE FOR FUTURE IMPROVEMENT: MODIFY "LOOKUP.TRACK.TIMBRE.NAME" TO USE Q-PAGE TRACK NAMES WHEN THEY EXIST */		CALL LOOKUP.TRACK.TIMBRE.NAME(TRKINDEX(T),PRINT.FN);		if print.fn(0)<>0 then do;	/* name exists */			call cpos(10,4+colwidth*t+shr(16-print.fn(0),1));	/* position for centering */			call ps('"'); call ps(print.fn); call ps('"');		end;		i=disp.mode;					/* get disp  mode     */		if  (click.track.mode=3)	/* if using ext click */		and ((disp.mode=1)			/* and beats selected */		or   (disp.mode=2))			/* or measures        */		then i=0;						/* then use seconds   */		do case (i);					/* now draw units label */			do;							/* seconds */				call cpos(11,T*colwidth+4);				call ps('Seconds');				call cpos(11,T*colwidth+17);			end;			do;							/* beats */				call cpos(11,T*colwidth+4);				call ps('Beats');				call cpos(11,T*colwidth+17);			end;			do;							/* measures */				call cpos(11,T*colwidth+1);				call ps('Meas:Beat');				call cpos(11,T*colwidth+17);			end;			do;							/* smpte */				call cpos(11,T*colwidth+1);				call ps('HH:MM:SS:FF');				call cpos(11,T*colwidth+17);			end;			do;							/* FEET:FRAMES */				call cpos(11,T*colwidth+1);				call ps('Feet:Frames');				call cpos(11,T*colwidth+17);			end;		end;		do case (third.fld);			call ps('Velocity');		/* 0 => velocity  */			call ps('Duration');		/* 1 => duration  */			call ps('End-Time');		/* 2 => end time  */			call ps('Soundfile');	/* 3 => soundfile */		end;	END;	ELSE DO;		CALL CPOS(9,4+T*COLWIDTH);		IF T = RECD.COL		THEN CALL PS('No Record Track (R)');		ELSE CALL PS('No Track Displayed ');	END;end redraw.track.title;/* redraw ALL the timbre names and column titles */redraw.track.titles: proc swapable;	call redraw.track.title(0);	call redraw.track.title(1);	call redraw.track.title(2);	call pos.recorder.cursor;end redraw.track.titles;