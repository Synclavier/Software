/* :SYNSOU:SCRNMOD:SCRNSOU  $TITLE  Terminal Primitives for Drawing Menus *//*Modified:1998/05/17 - TY  - Fixed a bug in PRINT.SCREEN.FRAME1 that caused all						 titles to be offset one character to the right.1987/01/29 - BSW - put terminal primitive routines into a module*/Module SCRNMOD;   insert ':synlits:comlits';   /* compilation literals */   insert ':synlits:globlits';  /* global literals      */   insert ':synlits:asciilit';  /* ascii code literals  */   insert ':synauxs:scrnlits';  /* literals used by this module */   insert ':synmods:ttydcl';    /* for ps, pc */   print_digits: proc(num,n) public swapable; /* prints positive number in n places with leading zeros */      dcl (num,n) fixed; /* number and places */      dcl (i,k)   fixed;      if num<0 then return;      k=1;      do i=1 to n-1;        k=k*10;        if num<k then call pc(ASC.0);      end;        if num=0 then call pc(ASC.0);      else          call pnum(num,0);   end print_digits;   /* $SUBTITLE  General Parameter Formatted Printing Routine */   print.parm:  proc(p.val,p.just,p.sign,p.field,p.dp) public swapable; /* uses above globals to print a parameter */      dcl p.val   fixed; /* number to convert to string       */      dcl p.just  fixed; /* 0=right justify, 1=left justify   */      dcl p.sign  fixed; /* 0=unsigned, 1=signed              */      dcl p.field fixed; /* field width, 1 to 6               */      dcl p.dp    fixed; /* digits to right of decimal point  */      dcl sign    fixed;      dcl tens    fixed;      dcl digit   fixed;      dcl (len,i) fixed;      if p.dp<>0 then len=p.dp+1+1;      else            len=1;      sign=0;      if (p.sign<>0) then do;                 /* SIGNED NUMBER */         if p.just=0 then do;                 /* RIGHT JUSTIFY CASE */            if p.val<0 then do;               sign=asc.min; p.val=-p.val;    /* save sign make number positive */            end;            else sign=sp;                     /* print a leading SPACE char anyway */            len=len+1;         end;         else if p.val<0 then do;             /* LEFT JUSTIFY CASE negative # */            sign=asc.min;            p.val=-p.val;                     /* make number unsigned */            len=len+1;         end;      end;      tens=p.val;      do i=1 to p.dp; write(5)=tens; write(7)=10; tens=read(5); end;      if       tens IGT 9999 then len=len+4;      else  if tens IGT  999 then len=len+3;      else  if tens IGT   99 then len=len+2;      else  if tens IGT    9 then len=len+1;      if len IGT p.field then do; /* error: number too long - print stars */         do i=1 to p.field; call pc(asc.star); end;         return;      end;      if p.just=0 then do;     /* RIGHT JUST: print leading spaces */         do i=1 to p.field-len; call pc(sp); end;         if p.sign<>0 then do; /* SIGNED: print minus or space */            call pc(sign);            len=len-1;         end;      end;      else if sign<>0 then do; /* LEFT JUST: print sign if minus */         call pc(sign);         len=len-1;      end;      sign=0; tens=10000;                          /* now using SIGN as a flag */      do i=1 to 5+(p.dp<>0);                       /* print rest of number */         if (p.dp<>0) and (i=(6-p.dp)) then do;            call pc(dot);         end;         else do;            load p.val; div tens; digit=res;            if (digit<>0) or (i=(5-p.dp)) then sign=1;    /* now start printing zeros */            if sign<>0 then call pc(asc.0+digit);            load digit; mul tens; p.val=p.val-res; /* P.VAL=P.VAL-DIGIT*TENS */            load tens;  div 10;   tens =res;       /* divide tens by 10 */         end;      end;      if p.just<>0 then do i=len+1 to p.field;     /* LEFT JUST: print trailing blanks */         call pc(sp);      end;   end print.parm;   DRAW.CORNER: proc(c.type) public swapable; /* prints corner on VT100 */      dcl c.type       fixed;      dcl save.ch.mode fixed;      if vt100 then do;         save.ch.mode=ch.mode;         call CH.SET(1);    /* set in alternate character mode */         do case c.type;            call pc("153"); /* upper right corner */            call pc("154"); /* upper left  corner */            call pc("155"); /* lower left  corner */            call pc("152"); /* lower right corner */         end;         call CH.SET(save.ch.mode);      end;   end DRAW.CORNER;   DRAW.TEE:  proc(t.type) public swapable; /* draws a T if on VT100 */      dcl t.type fixed;      dcl save.ch.mode fixed;      if vt100 then do;         save.ch.mode=ch.mode;         call CH.SET(1);    /* set in alternate character mode */         do case t.type;            call pc("167"); /* top    T */            call pc("166"); /* bottom T */            call pc("164"); /* left   T */            call pc("165"); /* right  T */            call pc("156"); /* cross  + */         end;         call CH.SET(save.ch.mode);      end;   end DRAW.TEE;   /* $PAGE */   DRAW.HOR:  proc(num) public swapable; /* prints horiz. dashed or VT100 line NUM chars long */      dcl num fixed;      dcl save.ch.mode fixed;      if vt100 then do;         save.ch.mode=ch.mode;         call CH.SET(1); /* set in alternate character mode */      end;      do num=1 to num;        if vt100 then call pc("161");        else          call pc( "55");      end;      if vt100 then call CH.SET(save.ch.mode);   end DRAW.HOR;   DRAW.VER:  proc(y1,x,y2) public swapable; /* draws a vertical line between (y1,x) and (y2,x) */      dcl y1       fixed; /* starting Y coordinate */      dcl x        fixed; /* starting X coordinate */      dcl y2       fixed; /* ending   Y coordinate */      dcl i        fixed;      dcl save.scr fixed; /* current value of screen dump */      dcl save.ch.mode fixed;      if (vt100<>0) then do;         save.ch.mode=ch.mode;         call CH.SET(1);       /* set in alternate character mode */      end;      if y1>y2 then do;     /* y1 needs to be less than y2 */         i=y1; y1=y2; y2=i; /* swap values */      end;      call cpos(y1,x);      do i=y1 to y2;         if vt100<>0 then call pc("170");         else             call pc("174");         /* position for vertical line */         if x<79 then call pc(bs); /* cannot backspace if in column 79 */         call pc(lf);      end;      if (vt100<>0) then call CH.SET(save.ch.mode);      i=y2+1; if i>23 then i=23;      call cpos(i,x); /* simulate LF,BS */   end DRAW.VER;   /* $PAGE */   DRAW.BOX:  proc(up.left.y, up.left.x, low.right.y, low.right.x) public swapable; /* prints a box on VT100 or ADM */      dcl (  up.left.y,  up.left.x) fixed; /* upper left  screen pos for box */      dcl (low.right.y,low.right.x) fixed; /* lower right screen pos for box */      dcl i                         fixed;      dcl save.ch.mode              fixed;      /* X coordinates should be in range 0 to 79 */      /* Y coordinates should be in range 0 to 23 */      if vt100 then do;         save.ch.mode=ch.mode; call CH.SET(1); /* set in alternate character mode */      end;      call cpos(up.left.y,up.left.x);   /* position at upper left corner */      if vt100 then call pc("154");     /* draw upper left corner */      else          call pc(sp);      do i=up.left.x to low.right.x-2;         if vt100 then call pc("161");         else          call pc(asc.min);      end; /* draw top side */      if vt100 then call pc("153");    /* position at upper right corner */      else          call pc(sp);      call cpos(up.left.y+1,low.right.x); /* draw right side */      do i=up.left.y+1 to low.right.y-1;          if vt100 then call pc("170");         else          call pc("174");         if i<>(low.right.y-1) then do;            call pc(lf);            if low.right.x<79 then call pc(bs);         end;      end;      call cpos(up.left.y+1,up.left.x);   /* draw left side */      do i=up.left.y+1 to low.right.y-1;         if vt100 then call pc("170");         else          call pc("174");         if i<>(low.right.y-1) then do;            call pc(lf);            call pc(bs);         end;      end;      call cpos(low.right.y,up.left.x);      if vt100 then call pc("155");    /* draw lower left corner */      else          call pc(sp);      do i=up.left.x to low.right.x-2; /* draw bottom side */         if vt100 then call pc("161");         else          call pc(asc.min);      end;      if vt100 then call pc("152");    /* draw lower right corner */      else          call pc(sp);      if vt100 then call CH.SET(save.ch.mode); /* return to normal char set */   end DRAW.BOX;   ERASE.BOX:  proc(up.left.y,up.left.x,low.right.y,low.right.x) public swapable; /* ERASES a box on VT100 or ADM */      dcl (  up.left.y,  up.left.x) fixed; /* upper left  screen pos for box */      dcl (low.right.y,low.right.x) fixed; /* lower right screen pos for box */      dcl i                         fixed;      /* X coordinates should be in range 0 to 79 */      /* Y coordinates should be in range 0 to 23 */      call cpos(up.left.y,up.left.x);   /* position at upper left corner */      do i=up.left.x to low.right.x;    /* erase top side                */         call pc(sp);      end;       call cpos(up.left.y+1,low.right.x); /* draw right side */      do i=up.left.y+1 to low.right.y-1;          call pc(sp);         if i<>(low.right.y-1) then do;            call pc(lf);            if low.right.x<79 then call pc(bs);         end;      end;      call cpos(up.left.y+1,up.left.x);   /* draw left side */      do i=up.left.y+1 to low.right.y-1;         call pc(sp);         if i<>(low.right.y-1) then do;            call pc(lf);            call pc(bs);         end;      end;      call cpos(low.right.y,up.left.x);      do i=up.left.x to low.right.x;      /* draw bottom side */         call pc(sp);      end;   end ERASE.BOX;   /* $PAGE */   /* DRAW.FRAME and PRINT.SCREEN.FRAME force the terminal into NORMAL      character mode. Note that all the above routines return the      terminal mode to the mode they were in when the routines started. */   DRAW.FRAME1: proc (left) swapable;      dcl left fixed;      if VT100 then call CH.SET     (1);  /* set in alternate character mode */      if VT100 then call DRAW.CORNER(c.u.l);      else          call pc         ("55");      call DRAW.HOR                 (left-1);      if VT100 then call CH.SET     (0);  /* set in normal character mode */   end DRAW.FRAME1;   DRAW.FRAME2: proc (right) swapable;      dcl right fixed;      if VT100 then call CH.SET     (1); /* set in alternate character mode */       call DRAW.HOR                 (right-1);      if VT100 then call DRAW.CORNER(c.u.r);      else          call pc         ("55");      if VT100 then call CH.SET     (0); /* set in normal character mode */   end DRAW.FRAME2;   DRAW.FRAME:  proc(left,text,right) public /* NON - SWAP */; /* draws a frame at current cursor pos */                                      /* do not swap so string constants stay in ext memory */      dcl left  fixed;       /* spaces to left of text  */      dcl text  fixed array; /* frame label             */      dcl right fixed;       /* spaces to right of text */      /* NOTE: Leaves terminal in NORMAL character mode when done with routine */      call DRAW.FRAME1(left);      call PS         (text);      call DRAW.FRAME2(right);   end DRAW.FRAME;   PRINT.SCREEN.FRAME1: proc (ulrow,ulcol,rows,columns,title0) swapable;      dcl (ulrow,ulcol,rows,columns,title0) fixed;      if vt100<>0 then call CH.SET(1); /* set in alternate character mode */      call DRAW.BOX(ulrow,ulcol,ulrow+rows-1,ulcol+columns-1);      if title0=0 then do;         if vt100<>0 then call CH.SET(0);  /* set in normal character mode when done */         return;         /* no title - just a box */      end;      call cpos(ulrow,ulcol+shr(columns-title0,1)-3);      if vt100<>0 then do; call DRAW.TEE(t.right); call CH.SET(0); end; /* set in normal character mode when done */      else                 call pc(asc.min);      call ps('  ');    end PRINT.SCREEN.FRAME1;   PRINT.SCREEN.FRAME2: proc swapable;      call ps('  ');      if vt100<>0 then call DRAW.TEE(t.left);      else             call pc(asc.min);   end PRINT.SCREEN.FRAME2;   PRINT.BOX.WITH.TITLE:proc (ulrow,ulcol,rows,columns,title) public recursive;      dcl (ulrow,ulcol,rows,columns) fixed;      dcl (title)                    array;      call PRINT.SCREEN.FRAME1 (ulrow,ulcol,rows,columns,title(0));      if title(0)<>0 then do;         call ps(title);          call PRINT.SCREEN.FRAME2;      end;   end PRINT.BOX.WITH.TITLE;   ERASE.BOX.WITH.TITLE:proc (ulrow,ulcol,rows,columns) public swapable;      dcl (ulrow,ulcol,rows,columns) fixed;      call ERASE.BOX(ulrow,ulcol,ulrow+rows-1,ulcol+columns-1);   end ERASE.BOX.WITH.TITLE;   PRINT.SCREEN.FRAME:  proc(lines,title) public recursive/* NON-SWAP */; /* draws standard screen title in a box */                                          /* do not swap so string constants stay in ext memory */      dcl lines fixed;       /* lines to reserve inside frame box (0 to 22) */      dcl title fixed array; /* screen title */      call PRINT.BOX.WITH.TITLE(0,0,lines+2,80,title);   end PRINT.SCREEN.FRAME;end SCRNMOD;